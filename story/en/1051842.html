<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>构建缩放静音按钮 Building a Zoom Mute Button</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Building a Zoom Mute Button<br/>构建缩放静音按钮 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-12 03:20:02</div><div class="page_narrow text-break page_content"><p>Instagram recently showed me an ad for a dedicated mute button for Zoom, which seemed a little too on the nose.</p><p>Instagram最近向我展示了一个专用静音按钮的广告，用于缩放，这在鼻子上看起来很少。</p><p>  Yes, I’m on Zoom calls all day. Yes, I have a toddler that makes guest appearances on those calls. You win, Instagram ad algorithm, I want one.</p><p>  是的，我整天都在缩放。是的，我有一个小孩，让客人出现在那些电话上。你赢了，Instagram广告算法，我想要一个。</p><p> But I have my reservations. This is an Instagram ad for a Kickstarter project. I don’t want to contribute to Facebook’s ad revenue by even clicking on it.  There’s No Such Thing as a Free Watch by Jenny Odell sums up my perception of the quality of products in Instagram ads. And my Kickstarter Trivial Pursuit pie is pretty full.</p><p> 但我有我的预订。这是一个用于Kickstarter项目的Instagram广告。即使点击它，我不想为Facebook的广告收入做出贡献。 Jenny Odell没有免费腕表，总结了我对Instagram广告中产品质量的看法。我的Kickstarter琐碎的追求饼非常满。</p><p>  I’ve backed a lot of projects on Kickstarter and sometimes the end result reminds me of the hamburger that Michael Douglas gets in Falling Down.</p><p>  我已经支持了很多关于Kickstarter的项目，有时最终结果让我想起了迈克尔道格拉斯跌倒的汉堡包。</p><p>   The first thing to consider is: What would be satisfying to press? If you’ve read my  post about Yubikeys, you’ll know this is an important point for me.</p><p>   首先要考虑的是：媒体令人满意的是什么？如果您阅读了关于Yubikeys的帖子，那么您将知道这对我来说是一个重要的一点。</p><p> I use Cherry MX switches in my keyboards. There are three types of mechanical switches: linear, tactile, and clicky. Linear is your basic switch that goes up and down without much feedback. Tactile switches have a bump in the middle of travel that let you feel that your key press happened. And clicky switches have stronger tactile feedback AND make an audible click when you press them.</p><p> 我在键盘中使用樱桃MX交换机。有三种机械开关：线性，触觉和咔哒声。线性是您的基本交换机，无需多大反馈即可上下。触觉交换机在旅行中有一个凹凸，让您觉得您的主要压力机发生了。键盘交换机具有更强的触觉反馈，并在按下它们时会发出声音。</p><p> Normally you’d buy a  switch tester and figure out which one  feels right to you and also survey your co-workers to determine what kind of sound they’d let your keyboard produce before murdering you. But we’re in the middle of COVID - you don’t have any co-workers around you! Let’s go with a Cherry MX Blue switch that has satisfying tactile feedback but is also extremely loud. Cherry MX’s website calls this switch “Clicky and Noticeable” which is quite an understatement.</p><p> 通常，您可以购买交换机测试仪，并弄清楚哪一个对您感到有权，并调查您的同事以确定他们在谋杀您之前让您的键盘产生的声音。但我们在Covid的中间 - 你没有你周围的任何合作工人！让我们一起去一个令人满意的触觉反馈的樱桃MX蓝色开关，但也非常响亮。 Cherry MX的网站调用此交换机“咔哒声”，这是一个非常轻描淡写的。 </p><p>  Looks nice, but I think we can do even better. If a Cherry MX Blue switch is satisfying to press, wouldn’t a comically large Cherry MX Blue switch be even more satisfying to press?</p><p>看起来不错，但我想我们可以做得更好。如果樱桃MX蓝色开关令按压力机，那么又不会是一个可笑的大樱桃MX蓝色开关更加令人满意？</p><p>   It’s 4 times bigger on each size and 64 times bigger in volume than a normal switch. It even comes with a giant keycap!</p><p>   它在每个尺寸越大4倍，体积比正常开关更大64倍。它甚至带有一个巨大的钥匙图！</p><p>  Unfortunately, the Big Switch doesn’t come with a case, so we’ll need to 3D print one. I found a nice looking case on Thingiverse:  NovelKeys Big Switch Case. It’s always worth looking through the remixes in case anyone has improved upon the original design. In this case, there’s a  remix that adds a housing for a Pro Micro and makes a tighter fit for the switch, so I printed that one.</p><p>  不幸的是，大型交换机不带案例，因此我们需要3D打印。我发现了一个漂亮的案例：novelkeys大开关盒。如果有人改善了原始设计，它总是值得浏览混音。在这种情况下，有一个混音，用于为Pro Micro添加一个外壳，并使开关更紧密，因此我印刷了一个。</p><p>  Now that we have the case, we’ll need a board to put into it and wire it up to the switch.</p><p>  现在我们有这样的情况，我们需要一个板子进入它并将其连接到开关。</p><p> The  Pro Micro has a ATmega32U4 chip that allows it to emulate a USB HID device, like a USB keyboard. It’s also tiny.</p><p> Pro Micro具有Atmega32U4芯片，允许其模拟USB HID设备，如USB键盘。这也很小。</p><p>  If you look at the bottom of the Big Switch, there are two metal contacts.</p><p>  如果看看大开关的底部，有两个金属触点。</p><p>  Inside the switch, pressing down on the key causes the circuit to be completed between these contacts.</p><p>  在开关内部，按下钥匙上的按下导致电路在这些触点之间完成。 </p><p>    We can connect GND to one metal contact and Pin 2 to the other metal contact. Pin 2 is a digital I/O pin which will read HIGH when the key is pressed and LOW when it’s not.</p><p>我们可以将GND连接到一个金属触点和销2到另一个金属接触。 PIN 2是数字I / O引脚，当键按下并且当它不是时，将读取高电平。</p><p> It would also be nice if we could have some sort of visual indicator of the mute status, so we can add an LED.</p><p> 如果我们可以拥有静音状态的某种视觉指示器，它也会很好，因此我们可以添加LED。</p><p>     For LEDs, the longer leg connects to PWR and the shorter leg connects to GND. We’ll stick the resistor between the longer leg and a different pin to lower the amount of current - I chose Pin 9 at the bottom of the board. The shorter leg I wired up to GND. I found  this page about LEDs and resistors to be helpful.</p><p>     对于LED，较长的腿连接到PWR，较短的腿连接到GND。我们将粘贴在长腿之间的电阻和不同的销之间，以降低电流底部的电流量 - 我选择销9。我越短的腿直到gnd。我发现这个页面有关LED和电阻的有用。</p><p>       Now we get to write some software, the spiritual opposite of being on a Zoom call.</p><p>       现在我们可以编写一些软件，在缩放呼叫中的精神相反。</p><p> I started with some code that Sparkfun had written to build a  giant Save Button and modified it a bit.</p><p> 我始于一些代码，Sparkfun已经写成了构建一个巨大的保存按钮并修改了一下。</p><p> The basic idea behind our mute button is that when you press the key, it will emit the Zoom hotkey for muting and unmuting, which on a Mac is Cmd-Shift-A. You’ll want to change your Zoom settings so this keystroke will be recognized even when Zoom isn’t focused with the  Enable Global Shortcut toggle:</p><p> 我们静音按钮背后的基本思想是，当您按下键时，它将发出变焦热键，以便静音和未经操作，在MAC上是CMD移位-A。您将要更改缩放设置，因此即使缩放未与“启用全局快捷方式”切换：</p><p>  We also want to toggle the LED on and off after each key press. I decided to treat the LED being on similar to an “On Air” light - when the blue LED is on, I’m unmuted and people can hear what I say.</p><p>  我们还要在每个钥匙按下后打开和关闭LED。我决定将LED视为类似于“空气”光 - 当蓝色LED亮起时，我取得取得取消，人们可以听到我所说的话。 </p><p> But if we just toggle the LED on and off after each key press, how will it stay in sync with the actual mute status on Zoom?</p><p>但是，如果我们刚刚在每个钥匙按下拨打的LED和关闭后，它将如何与缩放的实际静音状态同步？</p><p> One nice thing about the Pro Micro is that it also has serial communication. This is usually used for printing debugging information in the Arduino IDE, but we can use it to help us stay in sync with Zoom’s mute status.</p><p> 关于Pro Micro的一个很好的事情是它也具有串行通信。这通常用于在Arduino IDE中打印调试信息，但我们可以使用它来帮助我们与缩放的静音状态保持同步。</p><p>  #include &#34;Keyboard.h&#34;// OS parameterstypedef enum { LINUX, WINDOWS, MAC} os_types;// Change this to your operating systemconst os_types OS = MAC;// Pinsconst int btn_pin = 2;const int led_pin = 9;// Constantsconst int debounce_delay = 50; // ms// Globalsint btn_state = HIGH;int btn_prev = HIGH;unsigned long last_debounce_time = 0;int os_ctrl;int led_state = LOW;void setup() { Serial.begin(57600); // opens serial port, sets data rate to 57600 bps // Set up LED and button pins pinMode(btn_pin, INPUT_PULLUP); // Set the button as an input pinMode(led_pin, OUTPUT); digitalWrite(led_pin, led_state); // Begin keyboard Keyboard.begin(); // Switch to correct control/command key switch(OS){ case LINUX: case WINDOWS: os_ctrl = KEY_LEFT_CTRL; break; case MAC: os_ctrl = KEY_LEFT_GUI; break; default: os_ctrl = KEY_LEFT_CTRL; break; } // Get initial timestamp Serial.println(&#34;started&#34;); }void loop() { // Read current state of the button int btn_read = digitalRead(btn_pin); // Remember when the button changed states if ( btn_read != btn_prev ) { last_debounce_time = millis(); } // Wait before checking the state of the button again if ( millis() &gt; (last_debounce_time + debounce_delay) ) { if ( btn_read != btn_state ) { btn_state = btn_read; if ( btn_state == LOW ) { // Send cmd+shift+a Keyboard.press(KEY_LEFT_SHIFT); Keyboard.press(os_ctrl); Keyboard.press(&#39;a&#39;); delay(100); Keyboard.releaseAll(); Serial.println(&#34;pressed&#34;); if (led_state == LOW) { led_state = HIGH; } else { led_state = LOW; } digitalWrite(led_pin, led_state); } } } // Remember the previous button position for next loop() btn_prev = btn_read; if (Serial.available() &gt; 0) { String incomingString = Serial.readStringUntil(&#39;\n&#39;); if (incomingString == &#34;muted&#34;) { led_state = LOW; } else if (incomingString == &#34;unmuted&#34;) { led_state = HIGH; } digitalWrite(led_pin, led_state); } }</p><p>  #include＆＃34; keyboard.h＆＃34; //os parationstypeef enum {linux，windows，mac} os_types; //将其更改为您的操作系统const os_types os = mac; // pinsconst int btn_pin = 2; const int let_pin = 9; // constantsconst int deboune_delay = 50; // ms // globalsint btn_state = high; int btn_prev = high; unsigned long last_debounce_time = 0; int os_ctrl; int let_state = low; void setup（）{serial.begin（57600）; //打开串行端口，将数据速率设置为57600 BPS //设置LED和按钮引脚PINMODE（BTN_PIN，INPUT_PULLUP）; //将按钮设置为输入Pinmode（LED_PIN，输出）; DigitalWrite（LED_PIN，LED_STATE）; //开始键盘键盘.Begin（）; //切换到正确的控制/命令键交换机（OS）{案例Linux：case Windows：OS_CTRL = KEY_LEFT_CTRL;休息;案例mac：os_ctrl = key_left_gui;休息;默认值：os_ctrl = key_left_ctrl;休息; } //获得初始时间戳序列序列.println（＆＃34;开始＆＃34;）; } void循环（）{//读取按钮的当前状态int btn_read = digitalread（btn_pin）; //请记住，如果（btn_read！= btn_prev）{last_debounce_time = millis（）; } //在再次检查按钮的状态（millis（）＆gt;（last_debounce_time + devounce_delay））之前等待在检查按钮的状态之前）{if（btn_read！= btn_state）{btn_state = btn_read; if（btn_state == low）{//发送cmd + shift +键盘.press（key_left_shift）;键盘.press（os_ctrl）;键盘。按（＆＃39; a＆＃39;）;延迟（100）;键盘.releaseall（）; serial.println（＆＃34;按下＆＃34;）; if（LED_STATE == LOW）{LED_STATE = HIGH; } else {led_state = low; DigitalWrite（LED_PIN，LED_STATE）; }} //记住下一个循环的上一个按钮位置（）btn_prev = btn_read; if（serial.available（）＆gt; 0）{string incomingstring = serial.readstringuntil（＆＃39; \ n＆＃39;）; if（incomingstring ==＆＃34;柔和＆＃34;）{led_state = low; }如果（incomingstring ==＆＃34;取得的＆＃34;）{LED_STATE = HIGH; DigitalWrite（LED_PIN，LED_STATE）; }}</p><p> Next, we can add an Applescript that will report back what the current Zoom status is. I found a  Zoom plugin for a Streamdeck device that contained the initial Applescript and modified it to only report back whether Zoom was opened and its mute status. I also changed it to output JSON.</p><p> 接下来，我们可以添加一个AppleScript，它将报告当前缩放状态是什么。我找到了一个Zoom插件，用于集成初始AppleScript的StreamFeck设备，并将其修改为仅报告缩放是否已打开，并且其静音状态。我也改变了它来输出json。</p><p> set zoomStatus to &#34;closed&#34;set muteStatus to &#34;disabled&#34;tell application &#34;System Events&#34;	if exists (window 1 of process &#34;zoom.us&#34;) then		set zoomStatus to &#34;open&#34;		tell application process &#34;zoom.us&#34;			if exists (menu bar item &#34;Meeting&#34; of menu bar 1) then				set zoomStatus to &#34;call&#34;				if exists (menu item &#34;Mute audio&#34; of menu 1 of menu bar item &#34;Meeting&#34; of menu bar 1) then					set muteStatus to &#34;unmuted&#34;				else					set muteStatus to &#34;muted&#34;				end if			end if		end tell	end ifend tellcopy &#34;{\&#34;mute\&#34;:\&#34;&#34; &amp; (muteStatus as text) &amp; &#34;\&#34;,\&#34;status\&#34;:\&#34;&#34; &amp; (zoomStatus as text) &amp; &#34;\&#34;}&#34; to stdout</p><p> 将ZoomStatus设置为＆＃34;关闭＆＃34;将Mutestatus设置为＆＃34;禁用＆＃34;告诉申请＆＃34;系统事件＆＃34;如果存在（进程的窗口1和＃34; zoom.us＆＃34;）然后将zoomstatus设置为＆＃34;开放＆＃34;告诉申请流程＆＃34; zoom.us＆＃34;如果存在（菜单栏项＆＃34;会议＆＃34;菜单栏1）然后将zoomstatus设置为＆＃34;呼叫＆＃34;如果存在（菜单项＆＃34;静音音频＆＃34;菜单栏项目的菜单1＆＃34;会议＆＃34;菜单栏1）然后将Mutestatus设置为＆＃34;未被发电和＃34;否则将mutestatus设置为＆＃34;柔和＆＃34;如果结束结束，如果结束告诉最终IFEND thelcopy＆＃34; {\＆＃34;静音\＆＃34;：\＆＃34;＆＃34; ＆amp; （mutestatus作为文本）＆amp; ＆＃34; \＆＃34;，\＆＃34;状态\＆＃34;：\＆＃34;＆＃34; ＆amp; （ZoomStatus作为文本）＆amp; ＆＃34; \＆＃34;}＆＃34;到了斯丁</p><p> Now when we run it while we’re on a Zoom call, we get output like this:</p><p> 现在，当我们在缩放呼叫时运行它时，我们会像这样更多输出：</p><p>  Finally, I wrote a small node app that acts as a middleman between the Pro Micro and this script:</p><p>  最后，我写了一个小节点应用程序，它在Pro Micro和此脚本之间充当中间人： </p><p> const { exec } = require(&#39;child_process&#39;);const SerialPort = require(&#39;serialport&#39;);const Readline = require(&#39;@serialport/parser-readline&#39;);const port = new SerialPort(&#39;/dev/tty.usbmodemHIDPC1&#39;, { baudRate: 57600});var checkStatus = function() { console.log(&#39;Checking status...&#39;); exec(&#39;osascript get-zoom-status.scpt&#39;, (error, stdout, stderr) =&gt; { if (error) { console.error(`exec error: ${error}`); return; } var status = JSON.parse(stdout); if (status.mute == &#39;unmuted&#39;) { port.write(&#39;unmuted&#39;); } else { port.write(&#39;muted&#39;); } });}const parser = port.pipe(new Readline({ delimiter: &#39;\r\n&#39; }))parser.on(&#39;data&#39;, function (data) { if (data == &#34;pressed&#34;) { console.log(&#39;Button pressed.&#39;); checkStatus(); }})checkStatus();setInterval(checkStatus, 30000);</p><p>const {exec} =要求（＆＃39; child_process＆＃39;）; const serialport =要求（＆＃39; serialport＆＃39;）; const readline =要求（＆＃39; @ serialport / parser-readline＆＃39; ）; const port = new serialport（＆＃39; /dev/tty.usbmodemhidpc1&#39;，{baudrate：57600}）; var checkstatus = function（）{console.log（＆＃39;检查状态...＆ ＃39;）; Exec（＆＃39; Osascript get-zoom-status.scpt＆＃39;（错误，stdout，stderr）=＆gt; {if（错误）{console.error（`exec错误：$ {错误}`）;返回;} var status = json.parse（stdout）;如果（status.mute ==＆＃39;取得的＆＃39;）{port.write（＆＃39;未被发音＆＃39;）;否则{port.write（ ＆＃39;柔和＆＃39;）;}}）;} const parser = port.pipe（新readline（{delimiter：＆＃39; \ r \ n＆＃39;}）parser.on（＆＃39;数据＆＃39;，函数（数据）{if（data ==＆＃34;按下＆＃34;）{console.log（＆＃39;按下。＆＃39;）; checkstatus（）;}}）checkstatus （）; setInterval（checkstatus，30000）;</p><p> This script does two things. When the button is pressed, the Pro Micro sends a “pressed” command over the serial port and this calls the Applescript to determine the current Zoom mute status. Then it sends either a “muted” or “unmuted” command back to the Pro Micro, which triggers the corresponding LED state. There’s also a timer that runs this every 30 seconds in case I accidentally mute or unmute using the Zoom UI instead of the key - otherwise it would only resolve state when the key is pressed.</p><p> 这个脚本做了两件事。按下按钮时，Pro Micro将在串口上发送“按下”命令，并且这调用AppleScript来确定当前的缩放静音状态。然后，它将“静音”或“取消静音”命令发送回Pro Micro，触发相应的LED状态。如果我意外静音或取消静音，则还有一个每30秒运行这一点的计时器 - 否则只能在按下键时解析状态。</p><p>   Please back my Kickstarter - just kidding, there is no Kickstarter, but hopefully now you can build one yourself.</p><p>   请回到我的kickstarter  - 只是开玩笑，没有Kickstarter，但希望现在你可以自己建立一个。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bert.org/2021/03/10/building-a-zoom-mute-button/">https://bert.org/2021/03/10/building-a-zoom-mute-button/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/缩放/">#缩放</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/zoom/">#zoom</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/led/">#led</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>