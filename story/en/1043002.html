<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ZedRipper：第2部分 The ZedRipper: Part 2</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The ZedRipper: Part 2<br/>ZedRipper：第2部分 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-03 09:38:39</div><div class="page_narrow text-break page_content"><p>I initially finished  this project at the beginning of December 2019, and unlike most of my projects which immediately go on a shelf, never to blink again, this one immediately became my go-to ‘commuter hobby.’ My job, at the time, had entailed a ~45 minute train ride to and from the office each day, which was the perfect time to relax and write some Turbo Pascal.</p><p>我最初是在2019年12月开始完成这个项目的，与我大多数立即上架，再也不会眨眼的项目不同，这个项目立即成为我的“通勤者爱好”。每天往返办公室约45分钟的火车车程，这是放松和写一些Turbo Pascal的最佳时机。</p><p> As soon as I started using it, I immediately wanted to make it better, so as soon as it was ‘finished’, I embarked on a steady 3 months of gradual upgrades (before that whole pandemic thing happened and my commute disappeared). It’s mostly been sitting on a shelf since then, awaiting the end of the pandemic and the return of my daily commute.</p><p> 一开始使用它，我便立即想做得更好，因此，一旦它“完成”，我便开始了稳定的3个月的逐步升级（在整个大流行发生之前，我的通勤消失了）。从那以后，它大部分时间一直放在架子上，等待大流行结束并恢复我的日常通勤。</p><p>  For the sake of expediency, I had initially run the whole system on a common clock frequency of 83 MHz (dictated by the video generation logic). I decoupled the video generation from the rest of the system, and was able to increase the system clock (which drives the 16 Z80 cores and the unidirectional ring network that connects them all) to 140 MHz – a solid 68% speedup (and it’s genuinely noticeable on some Turbo Pascal tasks). That’s basically where I run into the timing ceiling on the Z80 core I’m using. I also sped up the SD card access a little bit, but that’s still one of the more obnoxiously slow parts of the system, and ripe for upgrading in the future.</p><p>  为了方便起见，我最初将整个系统运行在83 MHz的通用时钟频率上（由视频生成逻辑决定）。我将视频生成与系统的其余部分解耦，并能够将系统时钟（驱动16个Z80内核和连接它们的单向环形网络）提高到140 MHz –稳定的68％提速（这是真正的）在某些Turbo Pascal任务中值得注意）。基本上，这就是我所使用的Z80内核的时序上限的地方。我也加快了SD卡的访问速度，但这仍然是系统中最令人讨厌的缓慢部分之一，并且将来可以升级。</p><p> I did experiment with some nominally ‘faster’ Z80 cores like the  NextZ80, but I both had issues with getting them to run reliably (since almost all of them use slightly different logical interfaces), and they all had lower achievable clock rates. This is probably worth revisiting at some point in the future, but for now my 140MHz Z80 cores are quite peppy by 8-bit standards.</p><p> 我曾经尝试过像NextZ80这样名义上“更快”的Z80内核，但是我都在使它们可靠运行方面存在问题（因为几乎所有内核都使用略有不同的逻辑接口），而且它们都具有较低的可实现时钟速率。在将来的某个时候，这可能值得重新讨论，但是就目前而言，以8位标准来看，我的140MHz Z80内核还相当可观。</p><p>   Okay, it’s more of a joystick than a mouse, but still! I installed a 5-switch joystick thingy that connects to the keyboard controller. At the moment, the CP/NET server reads it and allows me to re-arrange terminal windows on the fly. I also added a nice blinky-border effect to indicate which terminal is ‘active.’</p><p>   好的，它比鼠标更像是一个操纵杆，但还是！我安装了一个5开关操纵杆，可以连接键盘控制器。此刻，CP / NET服务器读取了它，并允许我即时重新排列终端窗口。我还添加了一个很好的眨眼效果，以指示哪个终端处于“活动状态”。</p><p> My longer term goal is to eventually make a full-fledged ‘GUI’, but this is genuinely a nice feature for multi-tasking thus far (and much nicer to work with than the keyboard-controlled ’tiled’ interface in my original iteration.</p><p> 我的长期目标是最终制作一个完整的“ GUI”，但到目前为止，这确实是一个不错的多任务功能（比我最初的迭代中键盘控制的“平铺”界面好用得多）。</p><p>  One of those ‘practical’ issues that popped up on my daily commute was knowing what the state of the battery was – there is no built-in battery protection circuitry, the battery terminals just connect to the voltage regulator on the FPGA board through a mechanical switch. It would be really nice to have something like the ubiquitous battery icon modern devices have showing you what percentage of your battery life is left. A 5V micro controller was already present to convert the keyboard and joystick signals into serial commands to the FPGA – I was able to add a voltage divider that the micro controller can sample with an ADC (and use some of the unused serial commands) to provide some low-resolution battery monitoring. Once I get a proper battery monitor somewhere on the screen, I’ll never need to fear another impromptu shutdown in the middle of an intense Zork session!</p><p>  每天通勤时出现的“实用”问题之一就是知道电池的状态–没有内置的电池保护电路，电池端子仅通过机械装置连接到FPGA板上的稳压器开关。像现代设备中无处不在的电池图标可以向您显示剩余的电池寿命百分比，这真是太好了。已经存在一个5V的微控制器，可以将键盘和操纵杆信号转换为串行命令，发送给FPGA –我能够添加一个分压器，该微控制器可以通过ADC进行采样（并使用一些未使用的串行命令）以提供一些低分辨率的电池监控。一旦我在屏幕上的某个地方找到了合适的电池监控器，就再也无需担心在Zork紧张的会议期间再次即刻关机！ </p><p>   This is one of the bigger features I added – and I managed to get it all working about a week before my commute abruptly came to an end, so I only got to actually use it once or twice ‘in the field’, but it does work pretty well!</p><p>这是我添加的更大功能之一-在通勤突然结束之前的一周左右，我设法使其全部正常工作，所以我只需要在“现场”实际使用一两次，但它确实工作还不错！</p><p> I added an ESP32 board loaded with a ‘wifi modem’ firmware, which emulates a Hayes-compatible modem. This is then wired into a UART connected to the server Z80 – voila! I was able to tether to my cell phone and connect to a BBS on the train! The hardware terminals my Z80 cores use are ANSI-compatible, so my ‘terminal client’ was a handful of lines of Turbo Pascal, to basically route things from the modem to the terminal and from the keyboard to the modem – and now I can connect to ANSI-compatible bulletin boards via telnet! It really does work fine, and is pretty fun.</p><p> 我添加了一个装有“ wifi调制解调器”固件的ESP32板，该板可模拟与Hayes兼容的调制解调器。然后将其连接到连接到服务器Z80的UART –瞧！我能够系好手机并连接到火车上的BBS！我的Z80内核使用的硬件终端是ANSI兼容的，所以我的“终端客户端”是Turbo Pascal的几行，基本上可以将东西从调制解调器路由到终端，从键盘路由到调制解调器-现在我可以连接了通过telnet连接到ANSI兼容的公告板！它确实工作正常，并且非常有趣。</p><p>  With some more effort, this can also be used to do things like easy file transfers with modern computers via Kermit (my preferred solution when working with my Kaypro, which has a similar modem connected to it).</p><p>  付出更多的努力，这也可以用于通过Kermit与现代计算机轻松进行文件传输（这是我与连接了类似调制解调器的Kaypro一起使用时的首选解决方案）。</p><p>  I wanted an easy way to talk to it without cracking open the case, so I wired a simple FTDI-compatible UART port to the side of the case.</p><p>  我想通过一种简单的方式与之交谈，而又不会打开外壳，所以我将一个兼容FTDI的简单UART端口连接到了外壳的侧面。</p><p>   Originally, the ‘windowing’ feature was pretty limited – you could display 4 tiled terminal windows at a time, and keyboard hot keys let you select which terminal each tile was showing. As mentioned when discussing the mouse upgrade, I can now freely move terminal windows around the screen with the built-in joystick.</p><p>   最初，“窗口”功能非常有限-您一次只能显示4个平铺的终端窗口，而键盘热键则可以选择每个平铺显示的终端。就像在讨论鼠标升级时提到的那样，我现在可以使用内置操纵杆在屏幕上自由移动终端窗口。</p><p> I also added an equally useful upgrade that required a bit more surgery – two window sizes! All of the terminals are a fixed 80×25 characters, but it initially only supported a fixed 8×16 font. I was able to hack in a ‘big’ and ‘small’ mode by dynamically switching between a half-sized 4×8 font and the original 8×16 font, scaling the window to 1/4 its original size! This not only lets you display all 16 cores on the screen at once, but lets you mix-and-match things so that interactive applications can be full-sized, while background or multi-core applications can be quarter-sized.</p><p> 我还添加了同样有用的升级程序，需要进行更多的手术-两种窗口大小！所有终端都是固定的80×25字符，但最初仅支持固定的8×16字体。通过在半尺寸4×8字体和原始8×16字体之间动态切换，将窗口缩放到其原始大小的1/4，我能够破解“大”和“小”模式！这不仅可以让您一次在屏幕上显示所有16个核，而且还可以混合搭配使用，以便交互式应用程序可以全尺寸显示，而后台或多核应用程序可以为四分之一尺寸。</p><p>   In its initial incarnation, the ZedRipper was more like having a 1980s computer lab on your lap than what we think of as a ‘multicore’ computer. How to actually use this beast? I logically subdivided my 16 CPUs into 8 ‘application’ processors, to be used for running individual programs simultaneously, and an 8-core ‘hoard’ to be used for multiprocessing experiments. This provides a stable target for multicore applications, while leaving ample CPU available for any actual applications I need to run.</p><p>   最初的ZedRipper更像是拥有1980年代的计算机实验室，而不是我们认为的“多核”计算机。如何实际使用这种野兽？从逻辑上讲，我将16个CPU细分为8个“应用程序”处理器，用于同时运行各个程序，将8个内核的“存储库”用于多处理实验。这为多核应用程序提供了稳定的目标，同时为我需要运行的任何实际应用程序留出了充足的CPU。 </p><p> How to  actually use those cores though? Remember – my system is architected as a CP/NET server that is monitoring the keyboard and forwarding it to the appropriate CPU core, which is running CP/NOS. Initially my thought was that you might launch the applications individually, but that turns out to be terrible. Now, when you select cores 1-7, the individual ‘application’ processors are targeted as normal, but selecting core 8 conveniently broadcasts keystrokes to cores 8-15 – so you can now launch your application on all 8 cores simultaneously, and the CP/NET server just takes care of I/O automagically! The cores have ID registers they can read, so that you know which core you’re running on, and it kind of gives you an MPI-flavored means of multi-programming. This probably works better in practice than my description would imply – you can be editing a Turbo Pascal program in one window, compile it, and then run it on 8 cores in parallel w hile you still have your window open (!).</p><p>但是如何实际使用这些内核？记住–我的系统被构造为CP / NET服务器，该服务器监视键盘并将其转​​发到运行CP / NOS的适当CPU内核。最初，我的想法是您可以单独启动应用程序，但是事实证明这很糟糕。现在，当您选择内核1-7时，通常会以单个“应用程序”处理器为目标，但是选择内核8则可以方便地将击键广播到内核8-15-因此，您现在可以同时在所有8个内核上启动应用程序，并且CP / NET服务器只是自动处理I / O！内核具有可读取的ID寄存器，因此您可以知道正在运行的内核，并为您提供了MPI风格的多程序方式。在实践中，这可能比我的描述所暗示的要好得多–您可以在一个窗口中编辑Turbo Pascal程序，进行编译，然后在8个内核上并行运行它，而同时仍要打开窗口（！）。</p><p> Thanks to multi-sized window supports, my preferred mode of working has now become having all 8 cores of the hoard displayed on the bottom half of the screen, with 2 foreground applications in the top half, as can be seen in the Conway’s Game of Life demo GIF above.</p><p> 得益于多尺寸的窗户支撑，我首选的工作模式现在已将所有8个core积核心显示在屏幕的下半部分，上半部分显示了2个前台应用程序，如Conway的Game of以上是生活演示GIF。</p><p>  First of all, this whole pandemic things needs to wrap up, so that I can get back to train hacking. Once that’s taken care of, however, there’s still some items on my ZedRipper to-do list.</p><p>  首先，需要对整个大流行病进行总结，以便我可以重新培训黑客。不过，一旦解决了这些问题，我的ZedRipper待办事项清单上仍然会有一些项目。</p><p> Better storage! The SD card module I’m using is flakey, slow, and it’s frustrating to use. I think the FPGA board has some on-board flash memory that could be used, or just improving the performance and reliability of the existing SD card interface. Definitely a weak point at the moment.</p><p> 更好的存储！我正在使用的SD卡模块不稳定，运行缓慢，使用起来令人沮丧。我认为FPGA板上有一些板载闪存可以使用，或者只是改善现有SD卡接口的性能和可靠性。目前绝对是一个薄弱环节。</p><p> Use that RAM! The big SRAMs that are still unused could definitely support a big shared memory pool for the Z80s, as well as a good frame buffer for playing around with graphics.</p><p> 使用该RAM！仍未使用的大型SRAM肯定可以支持Z80的大型共享内存池，以及用于播放图形的良好帧缓冲区。</p><p> More Z80s? When my initial write-up on the ZedRipper got posted, someone brought a 1980s machine called the  ZMOB to my attention (which had a surprisingly similar architecture to the Zed Ripper), which intrigued me. Moving to a cache-based scheme backed by SRAMs would probably let me move to 64-256 Z80 cores, although I haven’t decided if that’s actually an improvement or not. For the record, the ZMOB had 256 * (4 MHz Z80A) = 1 GHZ80, whereas the ZedRipper now has 16 * (140 MHz Z80) = 2.24 GHZ80, so it’s already more than 2x faster than the previous Z80-based champion!</p><p> 更多Z80s？当我发布有关ZedRipper的第一篇文章时，有人引起了我的注意，那台1980年代的机器叫做ZMOB（其结构与Zed Ripper惊人地相似），这引起了我的兴趣。转向采用SRAM支持的基于缓存的方案可能会使我转向64-256 Z80内核，尽管我尚未确定这是否实际上是一种改进。根据记录，ZMOB具有256 *（4 MHz Z80A）= 1 GHZ80，而ZedRipper现在具有16 *（140 MHz Z80）= 2.24 GHZ80，所以它已经比以前的基于Z80的冠军快了2倍！</p><p> Better ROM? I’ve been following the very cool  RomWBW project, which offers a ton of features that would be nice to have on the ZedRipper.</p><p> 更好的ROM？我一直在关注非常酷的RomWBW项目，该项目提供了很多功能，这些功能很适合ZedRipper使用。 </p><p> Software! Software! Software! This thing already has so much unused capability, it’s just begging for more time to sit down and write software for it.</p><p>软件！ 软件！ 软件！ 这个东西已经有很多未使用的功能，只是乞求更多的时间坐下来为它编写软件。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.chrisfenton.com/the-zedripper-part-2/">http://www.chrisfenton.com/the-zedripper-part-2/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/zedripper/">#zedripper</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>