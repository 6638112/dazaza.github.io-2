<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>亚马逊助理让亚马逊跟踪网络上的每一个举动 Amazon Assistant lets Amazon track your every move on the web</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Amazon Assistant lets Amazon track your every move on the web<br/>亚马逊助理让亚马逊跟踪网络上的每一个举动 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-11 00:21:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/fea96122b4d14f3134cc08126822ea33.png"><img src="http://img2.diglog.com/img/2021/3/fea96122b4d14f3134cc08126822ea33.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I recently noticed that Amazon is promoting their Amazon Assistant extension quite aggressively. With success: while not all browsers vendors provide usable extension statistics, it would appear that this extension has beyond 10 million users across Firefox, Chrome, Opera and Edge. Reason enough to look into what this extension is doing and how.</p><p>我最近注意到亚马逊正在积极地推广他们的亚马逊助理延期。凭借成功：虽然并非所有浏览器供应商提供可用的扩展统计数据，但似乎这个延期超过了Firefox，Chrome，Opera和Edge的1000万用户。原因足以研究这个扩展正在做什么以及如何。</p><p> Here I must say that the privacy expectations for shopping assistants  aren’t very high to start with. Still, I was astonished to discover that Amazon built the perfect machinery to let them track any Amazon Assistant user or all of them: what they view and for how long, what they search on the web, what accounts they are logged into and more. Amazon could also mess with the web experience at will and for example hijack competitors’ web shops.</p><p> 在这里，我必须说，对购物助手的隐私期望并不高。尽管如此，我仍然惊讶地发现亚马逊建造了完美的机器，让他们跟踪任何亚马逊助理用户或他们所有人：他们在Web上搜索的是多长时间，他们登录的是什么帐户。亚马逊也可以弄乱Web体验，例如劫持竞争对手的网站商店。</p><p>  Mind you, I’m not saying that Amazon is currently doing any of this. While I’m not done analyzing the code, so far everything suggests that Amazon Assistant is only transferring domain names of the web pages you visit rather than full addresses. And all website manipulations seem in line with the extension’s purpose. But since all extension privileges are delegated to Amazon web services, it’s impossible to make sure that it always works like this. If for some Amazon Assistant users the “hoover up all data” mode is switched on, nobody will notice.</p><p>  介意你，我并不是说亚马逊目前正在这样做。虽然我没有完成分析代码，但到目前为止一切都表明Amazon Assistant只是传输您访问的网页的域名而不是完整地址。所有网站操纵似乎都与延期的目的一致。但由于所有扩展权限都委派给Amazon Web服务，因此不可能确保它始终是这样的。如果对于一些亚马逊助理用户，“胡佛所有数据”模式已打开，没有人会注意到。</p><p>   On the first glance, Amazon Assistant is just the panel showing up when you click the extension icon. It will show you current Amazon deals, let you track your orders and manage lists of items to buy. So far very much confined to Amazon itself.</p><p>   在第一眼看来，亚马逊助手只是在点击扩展名图时出现的面板。它将显示您当前的亚马逊交易，让您跟踪您的订单并管理购买的项目列表。到目前为止，非常局限于亚马逊本身。</p><p>  What’s not quite obvious: “Add to list” will attempt to recognize what product is displayed in the current browser tab. And that will work not only on Amazon properties. Clicking this button while on some other web shop will embed an Amazon Assistant into that web page and offer you to add this item to your Amazon wishlist.</p><p>  什么并不完全明显：“添加到列表”将尝试识别当前浏览器选项卡中显示的产品。这不仅可以在亚马逊属性上工作。在某些其他网站上单击此按钮将嵌入Amazon Assistant进入该网页，并为您提供将此项目添加到Amazon Wishlist中。</p><p> But Amazon Assistant will become active on its own as well. Are you searching for “playstation” on Google? Amazon Assistant will show its message right on top of Google’s ads, because you might want to buy that on Amazon.</p><p> 但亚马逊助理也将自己变得活跃。您在谷歌上寻找“PlayStation”吗？亚马逊助理将在谷歌广告的顶部显示其信息，因为您可能想在亚马逊上购买。</p><p>   So you can already guess that Amazon Assistant will ask Amazon web services what to do on any particular website: how to recognize searches, how to extract product information. There are just too many shops to keep all this information in the extension. As a side-effect that is certainly beneficial to Amazon’s business, Amazon will learn which websites you visit and what you search there. That’s your unavoidable privacy cost of this extension. But it doesn’t stop here.</p><p>   因此，您已经猜测亚马逊助理将要求亚马逊Web服务在任何特定网站上做什么：如何识别搜索，如何提取产品信息。商店太多了，可以在扩展中保留所有这些信息。作为对亚马逊业务肯定有益的副作用，亚马逊将了解您访问的网站以及您在那里搜索的网站。这是您对此延期的不可避免的隐私费用。但它不会在这里停留。 </p><p>  Let’s first take a look at what this extension is  allowed to do. That’s the  permissions entry in the extension’s  manifest.json file:</p><p>让我们先看看允许这个扩展名的事情。这是扩展名单中的权限条目：</p><p>  This is really lots of privileges. First note  http://*/* and  https://*/*: the extension has access to each and every website (I cut off the long list of Amazon properties here which is irrelevant then). This is necessary if it wants to inject its content there. The  tabs permission then allows recognizing when tabs are created or removed, and when a new page loads into a tab.</p><p>  这真的很有特权。第一笔记http：// * / *和https：// * / *：扩展名可以访问每个网站和每个网站（我切断了此处无关的亚马逊属性的长名单）。如果它想要将其内容注入那里，这是必要的。然后，选项卡权限允许识别在创建或删除选项卡时，并且当新页面加载到选项卡时。</p><p> The  storage permission allows the extension to keep persistent settings. One of these settings is called  ubpv2.Identity.installationId and contains (you guessed it) a unique identifier for this Amazon Assistant installation. Even if you log out of Amazon and clear your cookies, this identifier will persist and allow Amazon to connect your activity to your identity.</p><p> 存储权限允许扩展保持持久设置。其中一个设置称为UBPv2.identity.InstallationID，并包含（您猜测了它）此Amazon Assistant安装的唯一标识符。即使您退出亚马逊并清除Cookie，此标识符也将持续并允许Amazon将您的活动连接到您的身份。</p><p> Two other permissions are also unsurprising. The  notifications permission presumably lets the extension display a desktop notification to keep you updated about your order status. The  contextMenus permission lets it add an “Add to Amazon Lists” item to the browser’s context menu.</p><p> 另外两个权限也是不熟产的。通知权限可能会允许扩展显示桌面通知，以便您可以让您更新您的订单状态。 ContextMenus权限允许它在浏览器的上下文菜单中添加“添加到Amazon列表”项。</p><p> The  cookies permission is unusual however. In principle, it allows the extension to access cookies on any website. Yet it is currently only used to access Amazon cookies in order to recognize when the user logs in. The same could be achieved without this privilege, merely by accessing  document.cookie on an Amazon website (which is how the extension in fact does it in one case).</p><p> 然而，Cookies许可是异常的。原则上，它允许扩展访问任何网站上的cookie。然而，目前仅用于访问亚马逊cookie以识别用户登录时。如果在亚马逊网站上访问Document.Cookie，则可以在没有此权限的情况下实现同样的一个案例）。</p><p> Even weirder is the  management permission which is only requested by the Firefox extension but not the Chrome one. This permission gives an extension access to other browser extension and even allows uninstalling them. Requesting it is highly unusual and raises suspicions. Yet there is only code to call  management.uninstallSelf() and  management.getSelf(), the two function that don’t require this permission! And even this code appears to be unused.</p><p> 即使是奇特是管理许可，只能由Firefox扩展请求但不是Chrome一个。此权限提供对其他浏览器扩展的扩展访问，甚至允许卸载它们。要求它非常不寻常，并提出怀疑。然而，只有代码可以调用Management.Uninstallself（）和Management.getSelf（），这两个功能不需要此权！甚至此代码似乎未使用。</p><p> Now it’s not unusual for extensions to request wide reaching privileges. It’s not even unusual to request privileges that aren’t currently used, prompting Google to  explicity forbid this in their Chrome Web Store policy. The unusual part here is how almost all of these capabilities are transferred to Amazon web properties.</p><p> 现在，扩展要求广泛达到特权并不罕见。请求当前未使用的权限甚至不寻常，提示谷歌在其Chrome Web Store策略中禁止缩略。这里的不寻常部分是将所有这些功能传输到Amazon Web属性的几乎。 </p><p>  When you start looking into how the extension uses its privileges, it’s hard to overlook the fact that it appears to be an empty shell. Yes, there is a fair amount of code. But all of it is just glue code. Neither the extension’s user interface nor any of its logic is to be found anywhere. What’s going on? It gets clearer if you inspect the extension’s background page in Developer Tools:</p><p>当您开始查看扩展程序如何使用其权限时，很难忽略它似乎是空壳的事实。是的，有一个相当数量的代码。但所有这一切都只是胶水代码。任何地方都没有扩展的用户界面和任何逻辑都可以在任何地方找到。这是怎么回事？如果在Developer Tools中检查了分机的后台页面，则会更清晰：</p><p>  Yes, that’s eight remote frames loaded into the extension’s background page, all pointing to Amazon domains. And the ninth remote frame loads when you click the extension icon, it contains the user interface of the panel shown above. All these panels communicate with each other and the extension via Amazon’s internal UBP protocol, exchanging messages via  window.postMessage().</p><p>  是的，那是一个八个远程帧加载到扩展后的后台页面，所有这些都指向亚马逊域。和第九次远程帧加载时单击扩展名图标时，它包含上面显示的面板的用户界面。所有这些面板通过Amazon的内部UBP协议互相通信和扩展，通过Window.PostMessage（）交换邮件。</p><p> How does the extension know what page to load in the frames and what these should be allowed to do? It doesn’t, this information is downloaded as  FeatureManifest.js from an Amazon server. This file defines a number of “processes,” each with its list of provided and consumed APIs and events. And while the extension code makes sure that processes only access what they are allowed to access, this file on an Amazon web service sets the rules.</p><p> 扩展如何知道在帧中加载哪些页面以及应该允许这些页面进行操作？它没有，此信息从Amazon Server下载为FeatureManifest.js。此文件定义了许多“进程”，每个“进程”都包含提供和消费的API和事件的列表。虽然扩展代码确保只访问允许访问的进程，但Amazon Web服务上的此文件设置规则。</p><p> Here is what this file currently has to say about  AAWishlistProcess, a particularly powerful process:</p><p> 以下是此文件目前要对AawishListProcess的说法，一个特别强大的进程：</p><p> &#34;AAWishlistProcess&#34;  :  {  &#34;manifestVersion&#34;  :  &#34;2015-03-26&#34; ,  &#34;manifest&#34;  :  {  &#34;name&#34;  :  &#34;AAWishlistProcess&#34; ,  &#34;version&#34;  :  { &#34;major&#34;  :  1 ,  &#34;minor&#34;  :  1 ,  &#34;build&#34;  :  1 ,  &#34;revision&#34;  :  1 },  &#34;enabled&#34;  :  true ,  &#34;processType&#34;  :  &#34;Remote&#34; ,  &#34;configuration&#34;  :  {  &#34;url&#34;  :  &#34;https://horizonte.browserapps.amazon.com/wishlist/aa-wishlist-process.html&#34; ,  &#34;assetTag&#34;  :  &#34;window.eTag = \&#34;e19e28ac-784e-4e22-8e2b-6d36a9d3aaf2\&#34;; window.lastUpdated= \&#34;2021-01-14T22:57:46.422Z\&#34;;&#34;  },  &#34;consumedAPIs&#34;  :  {  &#34;Identity&#34;  :  [  &#34;getAllWeblabTreatments&#34; ,  &#34;getCustomerPreferences&#34;  ],  &#34;Dossier&#34;  :  [  &#34;buildURLs&#34;  ],  &#34;Platform&#34;  :  [  &#34;getPlatformInfo&#34; ,  &#34;getUWLItem&#34; ,  &#34;getActiveTabInfo&#34; ,  &#34;createElement&#34; ,  &#34;createSandbox&#34; ,  &#34;createSandboxById&#34; ,  &#34;createLocalSandbox&#34; ,  &#34;modifySandbox&#34; ,  &#34;showSandbox&#34; ,  &#34;sendMessageToSandbox&#34; ,  &#34;destroySandbox&#34; ,  &#34;scrape&#34; ,  &#34;listenerSpecificationScrape&#34; ,  &#34;applyStyle&#34; ,  &#34;resetStyle&#34; ,  &#34;registerAction&#34; ,  &#34;deregisterAction&#34; ,  &#34;createContextMenuItem&#34; ,  &#34;deleteAllContextMenuItems&#34; ,  &#34;deleteContextMenuItemById&#34; ,  &#34;getCookieInfo&#34; ,  &#34;bulkGetCookieInfo&#34; ,  &#34;getStorageValue&#34; ,  &#34;putStorageValue&#34; ,  &#34;deleteStorageValue&#34; ,  &#34;publish&#34;  ],  &#34;Reporter&#34;  :  [  &#34;appendMetricData&#34;  ],  &#34;Storage&#34;  :  [  &#34;get&#34; ,  &#34;put&#34; ,  &#34;putIfAbsent&#34; ,  &#34;delete&#34;  ]  },  &#34;consumedEvents&#34;  :  [  &#34;Tabs.PageTurn&#34; ,  &#34;Tabs.onRemoved&#34; ,  &#34;Sandbox.Message.UBPSandboxMessage&#34; ,  &#34;Action.Message&#34; ,  &#34;Platform.PlatformDataUpdate&#34; ,  &#34;Contextmenu.ItemClicked.AAWishlistProcess&#34; ,  &#34;Identity.CustomerPreferencesUpdate&#34; ,  &#34;Gateway.AddToListClick&#34;  ],  &#34;providedAPIs&#34;  :  {  },  &#34;providedEvents&#34;  :  [  &#34;Wishlist.update&#34; ,  &#34;Storage.onChange.*&#34; ,  &#34;Storage.onChange.*.*&#34; ,  &#34;Storage.onChange.*.*.*&#34; ,  &#34;Storage.onChange.*.*.*.*&#34; ,  &#34;Storage.onChange.*.*.*.*.*&#34; ,  &#34;Storage.onDelete.*&#34; ,  &#34;Storage.onDelete.*.*&#34; ,  &#34;Storage.onDelete.*.*.*&#34; ,  &#34;Storage.onDelete.*.*.*.*&#34; ,  &#34;Storage.onDelete.*.*.*.*.*&#34;  ],  &#34;CTI&#34;  :  {  &#34;Category&#34;  :  &#34;AmazonAssistant&#34; ,  &#34;Type&#34;  :  &#34;Engagement&#34; ,  &#34;Item&#34;  :  &#34;Wishlist&#34;  }  } } ,</p><p> ＆＃34; aawishlistprocess＆＃34; ：{＆＃34; Manifestversion＆＃34; ：＆＃34; 2015-03-26＆＃34; ，＆＃34;清单＆＃34; ：{＆＃34;姓名＆＃34; ：＆＃34; aawishlistprocess＆＃34; ，＆＃34;版本＆＃34; ：{＆＃34;主要＆＃34; ：1，＆＃34;次要＆＃34; ：1，＆＃34; Build＆＃34; ：1，＆＃34;修订版＆＃34; ：1}，＆＃34;启用＆＃34; ：真实，＆＃34; processtype＆＃34; ：＆＃34; remote＆＃34; ，＆＃34;配置＆＃34; ：{＆＃34; url＆＃34; ：＆＃34; https：//horizo​​nte.browserapps.amazon.com/wishlist/aa-wishlist-process.html&#34; ，＆＃34; assettag＆＃34; ：＆＃34; window.etag = \＆＃34; e19e28ac-784e-4e22-8e2b-6d36a9d3aaf2 \＆＃34 ;; window.lastupdated = \＆＃34; 2021-01-14T22：57：46.4222Z \＆＃34 ;;＆＃34; }，＆＃34; confecedapis＆＃34; ：{＆＃34;身份＆＃34; ：[＆＃34; getallweblabtreatments＆＃34; ，＆＃34; getCustomerPreferences＆＃34; ]，＆＃34;档案＆＃34; ：[＆＃34; buildurls＆＃34; ]，＆＃34;平台＆＃34; ：[＆＃34; getplatforminfo＆＃34; ，＆＃34; getuwlitem＆＃34; ，＆＃34; getActivetabinfo＆＃34; ，＆＃34;牧场和＃34; ，＆＃34; createSandbox＆＃34; ，＆＃34; createsandboxbyid＆＃34; ，＆＃34; createlocalsandbox＆＃34; ，＆＃34; modifysandbox＆＃34; ，＆＃34; showsandbox＆＃34; ，＆＃34; sendmessagetosandbox＆＃34; ，＆＃34; destroyandbox＆＃34; ，＆＃34;刮伤＆＃34; ，＆＃34; listenerspecificiedscrape＆＃34; ，＆＃34; ApplyStyle＆＃34; ，＆＃34; ResetStyle＆＃34; ，＃34;注册和＃34; ，＆＃34; deregisteraction＆＃34; ，＆＃34; createcontextmenuitem＆＃34; ，＆＃34; deleteallcontextmenuitems＆＃34; ，＆＃34; deletecontextmenuitembyid＆＃34; ，＆＃34; getcookieinfo＆＃34; ，＆＃34; bulkgetcookieinfo＆＃34; ，＆＃34; getstoragevalue＆＃34; ，＆＃34; putstoragevalue＆＃34; ，＆＃34; deletestoragevalue＆＃34; ，＆＃34;发布＆＃34; ]，＆＃34;记者＆＃34; ：[＆＃34; Appendmetricdata＆＃34; ]，＆＃34;存储＆＃34; ：[＆＃34;获得＆＃34; ，＃34;放＆＃34; ，＆＃34; putifabsent＆＃34; ，＆＃34;删除＆＃34; ]}，＆＃34;消费＆＃34; ：[＆＃34;标签.PageTurn＆＃34; ，＆＃34; tabs.onremoved＆＃34; ，＆＃34; sandbox.message.ubpsandboxmessage＆＃34; ，＆＃34;动作.message＆＃34; ，＆＃34; platform.platformdataupdate＆＃34; ，＆＃34; contextmenu.itemclicked.aawishlistprocess＆＃34; ，＆＃34; Identity.CustomerPreefercessupdate＆＃34; ，＆＃34; gateway.addtolistClick＆＃34; ]，＆＃34;提供＆＃34; ：{}，＆＃34;提供者＆＃34; ：[＆＃34; Histlist.update＆＃34; ，＆＃34; storage.onchange。*＆＃34; ，＆＃34; storage.onchange。*。*＆＃34; ，＆＃34; storage.onchange。*。*。*。*。*。*＆＃34; ，＆＃34; storage.onchange。*。*。*。*。*。*。*＆＃34; ，＆＃34; storage.onchange。*。*。*。*。*。*＆＃34; ，＆＃34; storage.ondelete。*＆＃34; ，＆＃34; storage.ondelete。*。*＆＃34; ，＆＃34; storage.ondelete。*。*。*。*。*。*。*＆＃34; ，＆＃34; storage.ondelete。*。*。*。*。*。*＆＃34; ，＆＃34; storage.ondelete。*。*。*。*。*。*＆＃34; ]，＆＃34; CTI＆＃34; ：{＆＃34;类别＆＃34; ：＆＃34; amazonassistantant＆＃34; ，＆＃34;类型＆＃34; ：＆＃34;订婚＆＃34; ，＆＃34;项目＆＃34; ：＆＃34;愿望清单＆＃34; }}}，</p><p> The interesting consumed APIs are the ones belonging to  Platform: that “process” is provided by the extension. So the extension lets this website among other things request information on the active tab, create context menu items, retrieve cookies and access extension’s storage.</p><p> 有趣的消费API是属于平台的API：“进程”由扩展提供。因此，扩展程序允许本网站在其他内容请求有关“活动”选项卡的信息，创建上下文菜单项，检索Cookie和访问扩展名存储。</p><p>  We don’t have to speculate, it’s easy to try things out that this website is allowed to do. For this, change to the Console tab in Developer Tools and make sure  aa-wishlist-process.html is selected as context rather than  top. Now enter the following command making sure incoming messages are logged:</p><p>  我们不必推测，很容易尝试解决这个网站允许做的事情。为此，更改为开发人员工具中的控制台选项卡，并确保将AA-Wishlist-process.html选择为上下文而不是顶部。现在输入以下命令确保已记录传入的消息： </p><p>  Note: For me,  console.log() didn’t work inside a background page’s frame on Firefox, so I had to do this on Chrome.</p><p>注意：对于我来说，console.log（）没有在Firefox上的背景页面的帧内工作，所以我必须在Chrome上执行此操作。</p><p>  parent . postMessage ({  mType :  0 ,  source :  &#34;AAWishlistProcess&#34; ,  payload :  {  msgId :  &#34;test&#34; ,  mType :  &#34;rpcSendAndReceive&#34; ,  payload :  {  header :  {  messageType :  2 ,  name :  &#34;subscribe&#34; ,  namespace :  &#34;PlatformHub&#34;  },  data :  {  args :  {  eventName :  &#34;Tabs.PageTurn&#34;  }  }  }  } },  &#34;*&#34; );</p><p>  父母。 PostMessage（{Mtype：0，来源：＆＃34; aawishListprocess＆＃34;，有效载荷：{msgid：＆＃34; test＆＃34;，mtype：＆＃34; rpcsendandreceive＆＃34;，有效载荷：{header：{messageType ：2，名称：＆＃34;订阅＆＃34;，命名空间：＆＃34; platformhub＆＃34;}，数据：{args：{eventname：＆＃34; tabs.pageTurn＆＃34;}}}}}}}}}， ＆＃34; *＆＃34;）;</p><p> A message from  PlatformHub comes in indicating that the call was successful ( &#34;error&#34;: null). Good, if we now open  https://example.com/ in a new tab… Three messages come in, first one indicating that the page is loading, second that its title is now known and finally the third one indicating that the page loaded:</p><p> 来自PlatformHub的一条消息，指示呼叫成功（＆＃34;错误＆＃34 ;: null）。好的，如果我们现在在一个新的选项卡中打开https://example.com/ ......三个消息进来，第一个指示页面正在加载的消息，第二个消息，其标题现在已知，最后是第三个指示页面加载的第三个消息：</p><p> {  &#34;mType&#34; :  0 ,  &#34;source&#34; :  &#34;PlatformHub&#34; ,  &#34;payload&#34; :  {  &#34;msgId&#34; :  &#34;3eee7d9b-ee2b-4f1d-be92-693119b5654c&#34; ,  &#34;mType&#34; :  &#34;rpcSend&#34; ,  &#34;payload&#34; :  {  &#34;header&#34; :  {  &#34;messageType&#34; :  2 ,  &#34;name&#34; :  &#34;publish&#34; ,  &#34;namespace&#34; :  &#34;PlatformHub&#34; ,  &#34;sourceProcessName&#34; :  &#34;Platform&#34; ,  &#34;extensionStage&#34; :  &#34;prod&#34;  },  &#34;data&#34; :  {  &#34;args&#34; :  {  &#34;eventName&#34; :  &#34;Tabs.PageTurn&#34; ,  &#34;eventArgs&#34; :  {  &#34;tabId&#34; :  &#34;31&#34; ,  &#34;url&#34; :  &#34;http://example.com/&#34; ,  &#34;status&#34; :  &#34;complete&#34; ,  &#34;title&#34; :  &#34;Example Domain&#34;  }  }  }  }  } }</p><p> {＆＃34; mtype＆＃34; ：0，＆＃34;来源＆＃34; ：＆＃34;平台Hub＆＃34; ，＆＃34;有效载荷和＃34; ：{＆＃34; msgd＆＃34; ：＆＃34; 3eee7d9b-ee2b-4f1d-be92-693119b5654c＆＃34; ，＆＃34; mtype＆＃34; ：＆＃34; rpcsend＆＃34; ，＆＃34;有效载荷和＃34; ：{＆＃34;标题＆＃34; ：{＆＃34; messageType＆＃34; ：2，＆＃34;姓名＆＃34; ：＆＃34;发布＆＃34; ，＆＃34;名称空间＆＃34; ：＆＃34;平台Hub＆＃34; ，＆＃34; sourceprocessname＆＃34; ：＆＃34;平台＆＃34; ，＆＃34; ExtensionStage＆＃34; ：＆＃34; prod＆＃34; }，＆＃34;数据＆＃34; ：{＆＃34; args＆＃34; ：{＆＃34; eventname＆＃34; ：＆＃34;标签.PageTurn＆＃34; ，＆＃34; Eventargs＆＃34; ：{＆＃34; tabid＆＃34; ：＆＃34; 31＆＃34; ，＆＃34; url＆＃34; ：＆＃34; http：//example.com/&#34; ，＆＃34;状态＆＃34; ：＆＃34;完成＆＃34; ，＆＃34;标题＆＃34; ：＆＃34;示例域名＆＃34; }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}</p><p> Yes, that’s essentially the  tabs.onUpdated extension API exposed to a web page. The  Tabs.onRemoved event works similarly, that’s  tabs.onRemoved extension API exposed.</p><p> 是的，这基本上是标签。oonupdated扩展API暴露于网页。选项卡.OnOremoved事件类似地，该选项卡。曝光的扩展API。</p><p>  parent . postMessage ({  mType :  0 ,  source :  &#34;AAWishlistProcess&#34; ,  payload :  {  msgId :  &#34;test&#34; ,  mType :  &#34;rpcSendAndReceive&#34; ,  payload :  {  header :  {  messageType :  1 ,  name :  &#34;getCookieInfo&#34; ,  namespace :  &#34;Platform&#34;  },  data :  {  args :  {  url :  &#34;https://www.google.com/&#34; ,  cookieName :  &#34;CONSENT&#34;  }  }  }  } },  &#34;*&#34; );</p><p>  父母。 PostMessage（{Mtype：0，来源：＆＃34; aawishListprocess＆＃34;，有效载荷：{msgid：＆＃34; test＆＃34;，mtype：＆＃34; rpcsendandreceive＆＃34;，有效载荷：{header：{messageType ：1，名称：＆＃34; getcookieinfo＆＃34;，命名空间：＆＃34;平台＆＃34;}，数据：{args：{url：＆＃34; https：//www.google.com/&# 34;，cookiename：＆＃34;同意＆＃34;}}}}，＆＃34; *＆＃34;）;</p><p>  {  &#34;mType&#34; :  0 ,  &#34;source&#34; :  &#34;PlatformHub&#34; ,  &#34;payload&#34; :  {  &#34;msgId&#34; :  &#34;fefc2939-70c3-4138-8bb6-a6120b57e563&#34; ,  &#34;mType&#34; :  &#34;rpcReply&#34; ,  &#34;payload&#34; :  {  &#34;cookieFound&#34; :  true ,  &#34;cookieInfo&#34; :  {  &#34;name&#34; :  &#34;CONSENT&#34; ,  &#34;domain&#34; :  &#34;.google.com&#34; ,  &#34;value&#34; :  &#34;PENDING+376&#34; ,  &#34;path&#34; :  &#34;/&#34; ,  &#34;session&#34; :  false ,  &#34;expirationDate&#34; :  2145916800.121322  }  },  &#34;t&#34; :  1615035509370 ,  &#34;rMsgId&#34; :  &#34;test&#34; ,  &#34;error&#34; :  null  } }</p><p>  {＆＃34; mtype＆＃34; ：0，＆＃34;来源＆＃34; ：＆＃34;平台Hub＆＃34; ，＆＃34;有效载荷和＃34; ：{＆＃34; msgd＆＃34; ：＆＃34; fefc2939-70c3-4138-8bb6-a6120b57e563＆＃34; ，＆＃34; mtype＆＃34; ：＆＃34; rpcreply＆＃34; ，＆＃34;有效载荷和＃34; ：{＆＃34; cookiemound＆＃34; ：真实，＆＃34; cookieinfo＆＃34; ：{＆＃34;姓名＆＃34; ：＆＃34;同意＆＃34; ，＆＃34;域名＆＃34; ：＆＃34; .google.com＆＃34; ，＆＃34;价值＆＃34; ：＆＃34;待+ 376＆＃34; ，＃34;道路＆＃34; ：＆＃34; /＆＃34; ，＆＃34;会议＆＃34; ：假，＆＃34; expirydate＆＃34; ：2145916800.121322}}，＆＃34; t＆＃34; ：1615035509370，＆＃34; rmsgid＆＃34; ：＆＃34;测试＆＃34; ，＆＃34;错误＆＃34; ：  空值  } } </p><p> Yes, that’s the  CONSENT cookie I have on  google.com. So that’s pretty much  cookies.get() extension API available to this page.</p><p>是的，这是我在google.com上的同意cookie。所以这是这个页面可用的很多cookies.get（）扩展API。</p><p>   Displays a “badge” on the extension’s icon (typically a number indicating unread messages)</p><p>   在扩展名图标上显示“徽章”（通常是指示未读消息的数字）</p><p>       Queries information about the page in any tab, clicks elements, sends  input and  keydown events</p><p>       查询有关任何选项卡中页面的信息，单击元素，发送输入和键盘事件</p><p>  Correspond to  webRequest API listeners (this functionality is currently inactive, the extension has no  webRequest permission)</p><p>  对应WebRequest API侦听器（此功能当前处于非活动状态，扩展名没有WebRequest权限）</p><p> Given  extension’s privileges, not much is missing here. The  management permission is unused as I mentioned before, so listing installed extensions isn’t possible. Cookie access is read-only, setting cookies isn’t possible. And general webpage access appears to stop short of arbitrary code execution. But does it?</p><p> 鉴于延期的特权，这里缺少并不多。管理权限在我之前提到的，因此列出已安装的扩展是不可能的。 cookie访问是只读的，设置cookie是不可能的。常规网页访问权限似乎停止任意代码执行。但是吗？</p><p> The  createSandbox call can be used with any frame address, no checks performed. This means that a  javascript: address is possible as well. So if we run the following code in the context of  aa-wishlist-process.html:</p><p> CreateSandbox调用可以与任何帧地址一起使用，没有执行检查。这意味着一个JavaScript：地址也是可能的。因此，如果我们在aa-wishlist-process.html的上下文中运行以下代码：</p><p> parent . postMessage ({  mType :  0 ,  source :  &#34;AAWishlistProcess&#34; ,  payload :  {  msgId :  &#34;test&#34; ,  mType :  &#34;rpcSendAndReceive&#34; ,  payload :  {  header :  {  messageType :  1 ,  name :  &#34;createSandbox&#34; ,  namespace :  &#34;Platform&#34;  },  data :  {  args :  {  tabId :  31 ,  sandboxSpecification :  {  proxy :  &#34;javascript:alert(document.domain)//&#34; ,  url :  &#34;test&#34; ,  sandboxCSSSpecification :  &#34;none&#34;  }  }  }  }  } },  &#34;*&#34; );</p><p> 父母。 PostMessage（{Mtype：0，来源：＆＃34; aawishListprocess＆＃34;，有效载荷：{msgid：＆＃34; test＆＃34;，mtype：＆＃34; rpcsendandreceive＆＃34;，有效载荷：{header：{messageType ：1，名称：＆＃34; createAndbox＆＃34;，命名空间：＆＃34;平台＆＃34;}，数据：{args：{tabid：31，沙箱特性：{proxy：＆＃34; javascript：警报（文档。域）//＆＃34;，网址：＆＃34;测试＆＃34;，sandboxCSSSpecification：＆＃34;无＆＃34;}}}}}}＆＃34; *＆＃34）; </p><p> Yes, a message pops up indicating that this successfully executed JavaScript code in the context of the  example.com domain. So there is at least one way for Amazon services to do anything with the web pages you visit. This particular attack worked only on Chrome however, not on Firefox.</p><p>是的，弹出消息，表示在example.com域的上下文中成功执行了JavaScript代码。因此，亚马逊服务至少有一种方法可以使用您访问的网页进行任何操作。然而，这种特殊的攻击仅在Chrome上工作，而不是Firefox。</p><p>  As I already pointed out  in a previous article, it’s hard to build a shopping assistant that wouldn’t receive all its configuration from some server. This makes shopping assistants generally a privacy hazard. So maybe this privacy and security disaster was unavoidable?</p><p>  正如我已经在上一篇文章中指出的那样，很难建立一个无法从某些服务器收到所有配置的购物助手。这使得购物助理通常是隐私危害。所以也许这种隐私和安全灾难是不可避免的？</p><p> No, for most part this isn’t the case. Amazon’s remote “processes” aren’t some server-side magic. They are merely static JavaScript files running in a frame. Putting these JavaScript files into the extension would have been possible with almost no code changes. And it would open up considerable potential for code simplification and performance improvements if Amazon is interested.</p><p> 不，在大多数方面，这不是这种情况。亚马逊的遥控程序“不是一些服务器端魔法。它们只是在帧中运行的静态JavaScript文件。将这些JavaScript文件放入扩展名，几乎没有代码更改。如果亚马逊感兴趣，它将开辟代码简化和性能改进的相当大潜力。</p><p> This design was probably justified with “we need this to deploy changes faster.” But is it really necessary? The  FeatureManifest.js file mentioned above happens to contain update times of the components. Out of nine components, five had their last update five or six months ago. One was updated two months ago, another a month ago. Only two were updated recently (four and twelve days ago).</p><p> 这种设计可能是合理的，“我们需要更快地部署变化”。但它真的是必要吗？上面提到的featuremanifest.js文件恰好包含组件的更新时间。在九个成分中，五个组成部分最新了五六多月前。一个月前，一个是在两个月前更新的另一个月。最近只更新了两个（四天和十二天前）。</p><p> It seems that these components are maintained by different teams who work on different release schedules. But even if Amazon cannot align the release schedules here, this doesn’t look like packaging all the code with the extension would result in unreasonably frequent releases.</p><p> 似乎这些组件由在不同释放时间表上工作的不同团队维护。但即使亚马逊不能在这里对齐发布时间表，这看起来看起来不像打包所有代码，扩展将导致不合理的频繁版本。</p><p>  Why does it make a difference where this code is located? It’s the same code doing the same things, whether it is immediately bundled with the extension or whether the extension merely downloads it from the web and gives it access to the necessary APIs, right?</p><p>  为什么它会产生此代码的差异？这是做同样的代码，是否立即与扩展捆绑在一起或扩展只是从Web下载并提供必要的API，右边的访问权限吗？</p><p> Except: there is no way of knowing that it is always the same code. For example, there isn’t actually a single  FeatureManifest.js file on the web but rather 15 of them, depending on your language. Similarly, there are 15 versions of the JavaScript files it references. Presumably, this is merely about adjusting download servers to the ones closer to you. The logic in all these files should be exactly identical. But I don’t have the resources to verify this, and maybe Amazon is extracting way more data for users in Brazil for example.</p><p> 除了：没有办法知道它总是相同的代码。例如，根据您的语言，Web上实际上没有单个FeatureManifest.js文件，而是6个。同样，它引用了15个版本的JavaScript文件。据推测，这只是将下载服务器调整到靠近您的下载服务器。所有这些文件中的逻辑应该完全相同。但我没有资源来验证这一点，也许亚马逊正在为巴西的用户提取更多数据。 </p><p> And this is merely what’s visible from the outside. What if some US government agency asks Amazon for the data of a particular user? Theoretically, Amazon can serve up a modified  FeatureManifest.js file for that user only, one that gives them way more access. And this attack wouldn’t leave any traces whatsoever. No extension release where malicious code could theoretically be discovered. Nothing.</p><p>这只是从外面看到的。如果一些美国政府机构要求亚马逊向特定用户的数据要求亚马逊怎么办？从理论上讲，亚马逊可以为该用户提供修改的FeatureManifest.js文件，其中一个让它们提供更多访问权限。这种攻击不会留下任何痕迹。没有理论上可以发现恶意代码的延期发布。没有。</p><p> That’s the issue here: Amazon Assistant is an extension with very extensive privileges. How are these being used? If all logic were contained in the extension, we could analyze it. As things are right now however, all we can do is assuming that everybody gets the same logic. But that’s really at Amazon’s sole discretion.</p><p> 这就是这里的问题：亚马逊助手是一个具有非常广泛的特权的扩展。这些如何使用？如果扩展中包含所有逻辑，我们可以分析它。然而，当事情现在是正确的，我们所能做的就是假设每个人都获得相同的逻辑。但这真的在亚马逊的唯一自由裁量权。</p><p>  There is another aspect here. Even the regular functionality of Amazon Assistant is rather invasive, with the extension letting Amazon know of every website you visit as well as some of your search queries. In theory, the extension has settings to disable this functionality. In practice, it’s impossible to verify that the extension will always respect these settings.</p><p>  这里还有另一个方面。即使是亚马逊助手的常规功能也是侵入性的，扩展名让亚马逊知道您访问的每个网站以及一些搜索查询。在理论上，扩展名为禁用此功能的设置。在实践中，不可能验证扩展将始终尊重这些设置。</p><p>  If we are talking about legal boundaries such as GDPR, Amazon provides a  privacy policy for Amazon Assistant. I’m no expert, but my understanding is that this meets the legal requirements, as long as what Amazon does matches this policy. For the law, it doesn’t matter what Amazon  could do.</p><p>  如果我们谈论GDPR等法律界限，亚马逊为亚马逊助理提供了隐私政策。我没有专家，但我的理解是，这符合法律要求，只要亚马逊确实符合这项政策。对于法律来说，亚马逊可以做什么并不重要。</p><p> That’s different for browser vendors however who have an interest in keeping their extensions platform secure. Things are most straightforward for Mozilla, their  add-on policies state:</p><p> 这对于浏览器供应商来说是不同的，但是，谁对保持其扩展平台安全的兴趣。对于Mozilla，他们的附加政策州最简单的事情是最直接的：</p><p>  While, technically speaking, no remote code is being executed in extension context here, delegating all extension privileges to remote code makes no difference in practice. So Amazon Assistant clearly violates Mozilla’s policies, and we can expect Mozilla to enforce their policies here. With Honey,  another shopping assistant violating this rule the enforcement process is already in its fifth month, and the extension is still available on Mozilla Add-ons without any changes. Well, maybe at some point…</p><p>  虽然在技术上说话，但在这里，在扩展上下文中没有在扩展上下文中执行远程代码，委派所有扩展权限到远程代码在实践中没有任何区别。因此，亚马逊助理显然违反了Mozilla的政策，我们可以预期Mozilla在这里执行他们的政策。通过蜂蜜，另一个购物助理违反了这一规则，执法进程已经在第五个月内，延伸仍然可以在Mozilla附加组件上没有任何变化。好吧，也许在某些时候......</p><p>  Your extension should avoid using remote code except where absolutely necessary. Extensions that use remote code will need extra scrutiny, resulting in longer review times. Extensions that call remote code and do not declare and justify it using the field shown above will be rejected.</p><p>  除非绝对必要的情况，您的扩展应该避免使用远程代码。使用远程代码的扩展需要额外的审查，从而导致较长的审查时间。将拒绝呼叫远程代码和不使用上面显示的字段声明和证明它的扩展。 </p><p> This isn’t a real ban on remote code. Rather, remote code can be used where “absolutely necessary.” Extension authors then need to declare and justify remote code. So in case of Amazon Assistant there are two possibilities: either the developers declared this usage of remote code and Google accepted it. Or they didn’t declare it, and Google didn’t notice remote code being loaded here. There is no way for us to know which is true, and so no way of knowing whether Google’s policies are being violated. This in turn means that there is no policy violation to be reported, we can only hope for Google to detect a policy violation on their own, something that couldn’t really be relied upon in the past.</p><p>这不是远程代码的真正禁令。相反，远程代码可以使用“绝对必要的”。然后，扩展作者需要声明并证明远程代码。因此，如果亚马逊助手有两种可能性：开发人员宣布此使用远程代码和Google接受了它。或者他们没有声明它，谷歌没有注意到这里加载的远程代码。我们没有办法知道哪个是真的，所以没有办法了解谷歌的政策是否被侵犯。这反过来意味着没有报告的政策违规，我们只能希望谷歌自行检测政策违规，这是过去无法真正依赖的事情。</p><p>  No external JavaScript is allowed. All JavaScript code must be contained in the extension. External APIs are ok.</p><p>  不允许外部JavaScript。所有JavaScript代码都必须包含在扩展名中。外部API是可以的。</p><p> Arguably, what we have here is way more than “external APIs.” So Amazon Assistant violates Opera’s policies as well and we can expect enforcement action here.</p><p> 可以说，我们在这里有什么比“外部API”。因此，亚马逊助理也违反了歌剧的政策，我们可以预期在此处的执法行动。</p><p> Finally, there is Microsoft Edge. The only related statement I could find in  their policies reads:</p><p> 最后，有Microsoft Edge。我在政策中可以找到的唯一有关的陈述读：</p><p> For example, your extension should not download a remote script and subsequently run that script in a manner that is not consistent with the described fun</p><p> 例如，您的扩展名不应下载远程脚本，然后以与所描述的乐趣不一致的方式运行该脚本</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://palant.info/2021/03/08/how-amazon-assistant-lets-amazon-track-your-every-move-on-the-web/">https://palant.info/2021/03/08/how-amazon-assistant-lets-amazon-track-your-every-move-on-the-web/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/amazon/">#amazon</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/亚马逊/">#亚马逊</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/跟踪/">#跟踪</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/扩展/">#扩展</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>