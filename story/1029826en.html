<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在无赖中发展多面体生物</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在无赖中发展多面体生物</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-19 23:23:52</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/7f6d6b702a813a7b0dbad84320b17946.png"><img src="http://img2.diglog.com/img/2020/10/7f6d6b702a813a7b0dbad84320b17946.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Creatures/entities that occupy more than one space in the grid-based world of a roguelike still aren’t all that common, although in the development community this is an increasingly popular topic. Many of these discussions revolve around how to solve various technical and design issues associated with this type of entity, and while I’ve provided input in a number of these conversations over the years, it’s really about time to collect some of these experiences, observations and advice into a single article for better reference :)</p><p>在基于网格的流氓世界中占据多个空间的生物/实体仍然不是那么常见，尽管在开发社区中这是一个越来越受欢迎的话题。其中许多讨论都围绕着如何解决与这类实体相关的各种技术和设计问题，虽然多年来我已经在许多这样的对话中提供了意见，但现在确实是时候将其中一些经验、观察和建议收集到一篇文章中，以便更好地参考：)。</p><p> I gave “multi-tile robots”  cursory coverage back when I was first spinning up Cogmind as a commercial project in 2013, but all I really did there was give a basic description rather than look into the nuts and bolts underpinning this feature.</p><p>2013年，当我第一次将CogMind作为一个商业项目进行开发时，我粗略地介绍了“多瓦片机器人”，但我真正做的只是给出了一个基本的描述，而不是研究支撑这一功能的细节。</p><p> I’ve been working with multitile creatures since 2011 when I first  added them to X@COM. As I wrote about there, it was quite a headache because I didn’t include them from the very beginning, but it was both necessary to do considering the primary source material (X-Com) and also definitely adds a  lot of character to these creatures, so very much worthwhile.</p><p>自从2011年我第一次将多瓦片生物添加到X@com后，我就一直在处理它们。就像我在那里写的那样，这是相当令人头疼的，因为我从一开始就没有把它们包括在内，但考虑到主要的来源材料(X-Com)，这既是必要的，也肯定会给这些生物增加很多性格，所以非常值得。</p><p> The famous example of a big ‘D’ dragon occupying only one space, the same tactical unit as a tiny adventurer, is great in its own way (elegant!), but there’s something to be said for the psychological impact and mechanical implications of an actually physically larger creature.</p><p>一个著名的例子是，一条巨大的“D”龙只占据了一个空间，就像一个小冒险家一样的战术单位，以它自己的方式很棒(优雅！)，但对于一个实际更大的生物的心理影响和机械影响，还是有一些可以说的。</p><p>  I guess there’s also the realism argument--although complete realism isn’t usually a good goal in games, it’s always nice when you can both embrace it and get some benefits in return.</p><p>我猜还有现实主义的论据--虽然在游戏中完全的现实主义通常不是一个好的目标，但当你既能拥抱它又能得到一些回报时，总是很好的。</p><p> “Holy… look at that thing! We probably can’t take it on at this point, but if we escape down this narrow corridor it probably won’t be able to follow us… We’ll find another way around.”</p><p>“神圣的…。看那东西！我们现在可能不能带上它，但如果我们沿着这条狭窄的走廊逃走，它可能就不能跟着我们了…。我们会找到另一条路绕过去的。“。</p><p>  Technically the concept of “multitile” creatures can be subdivided into a number of different categories, not all of which I’ll be covering in detail here.</p><p>从技术上讲，“多瓦片”生物的概念可以细分为许多不同的类别，我不会在这里详细介绍所有这些类别。</p><p> For example a number of roguelikes have stationary multitile creatures, like Ivy Creepers in Ragnarok.</p><p>例如，一些盗贼拥有固定的多瓦片生物，比如Ragnarok的常春藤爬行者。</p><p>  Although stationary, sometimes creatures in this category can also grow outward, like the various Ivies in HyperRogue.</p><p>虽然是静止的，但有时这类生物也可以向外生长，就像HyperRogue中的各种常春藤一样。</p><p>  Overall these are fairly easy for developers to work with, it’s just a case of whether you want/need something like this in game.</p><p>总体而言，这些对于开发人员来说都相当容易使用，这只是游戏中您是否想要/需要这样的东西的一个例子。</p><p> There are also snake-styled multitile creatures which can move, but where the body essentially follows whatever path the head has taken, so also not all that hard to manage.</p><p>也有蛇形的多瓦片生物可以移动，但身体基本上遵循头部所走的任何路径，所以也不是很难管理。</p><p>    The genre also includes amorphous area-based creatures like DCSS Krakens, which consist of a single body tile and send out tentacles which essentially behave as individual creatures (although their range from the body is restricted, and damaging them also damages the Kraken).</p><p>这一类型还包括无定形的区域生物，如DCSS Krakens，它由单一的身体瓷砖组成，并发出触角，本质上是单个生物的行为(尽管它们与身体的距离受到限制，而且伤害它们也会伤害Kraken)。</p><p>  For the purposes of this article, to keep the scope in check (and more importantly to cover the especially challenging areas where questions usually arise) I’m really only interested in the most generic type of multitile creatures, those where the entire creature is a “connected solid blob” that is present on the map and moves as a unit like other single-tile creatures.</p><p>出于本文的目的，为了控制范围(更重要的是为了涵盖通常会出现问题的特别具有挑战性的领域)，我实际上只对最普通的多瓦片生物感兴趣，在这种类型中，整个生物是一个“连接的实心斑点”，它出现在地图上，像其他单瓦片生物一样作为一个单元移动。</p><p> Probably the most extreme example of this category would be Dumuzid, a 7DRL explicitly designed around the concept of size, so it’s not surprising that you can end up with a massive sprawling body that moves as one.</p><p>这一类别最极端的例子可能是Dumuzid，这是一款明确围绕大小概念设计的7DRL，所以你最终会拥有一个庞大的四肢伸展的身体，作为一个整体移动也就不足为奇了。</p><p>  Some more typical examples, all coincidentally reflecting the theme that multitile creatures are often used for especially challenging or awe-inspiring enemies like bosses:</p><p>一些更典型的例子，都巧合地反映了这样一个主题，即多层生物经常被用来对付特别具有挑战性或令人敬畏的敌人，比如老板：</p><p>      For  X@COM I went all in on the multitile units, branching out from the original requirements for X-Com. It’s fun to drive a tank through walls and watch the building collapse :). It’s also fun--but scarier--to watch huge enemies rampage through buildings, knocking down walls and crushing furniture! X-Com itself only had units up to 2×2, but when putting in place mechanics like this, may as well make the size arbitrary! Back then while recording a video demonstrating sound testing there was a 5×5 Colossus at the end, which you can see below starting from 3:50:</p><p>对于X@COM，我全力以赴地使用多瓦片单元，从X-Com最初的需求扩展而来。开着坦克穿过墙壁，看着大楼倒塌，这是一件很有趣的事情：)。看着巨大的敌人在建筑物中横冲直撞，推倒墙壁，压碎家具，这也是一件有趣的事情，但更可怕的是！X-Com本身只有2×2的单元，但是当把这样的机械装置放在适当的位置时，可能会让大小变得任意！当时在录制声音测试演示视频时，末尾有一个5x5的巨像，从3点50分开始，你可以看到下面的画面：</p><p>  Having inherited its architecture and even some mechanics from X@COM,  Cogmind also includes a number of multitile entities for their shock and awe factor. Although there are slightly more obstacles to overcome when moving from a more open surface environment vs. the subterranean environments more typical among roguelikes, for me it’s worth the trouble.</p><p>从X@com继承了它的架构，甚至继承了一些机制，CogMind还包含了许多多瓦片实体，以满足它们的震撼和敬畏因素。虽然从更开放的地面环境和更典型的地下环境相比，需要克服的障碍稍微多一些，但对我来说，这是值得的。</p><p>  IVAN reportedly also has 2×2 monsters that can usually destroy walls in order to move around (or are simply stationary), but I couldn’t find any good resources or images on those.</p><p>据报道，伊凡也有2×2的怪物，它们通常可以摧毁墙壁以便四处走动(或者只是静止不动)，但我找不到任何好的资源或图像。</p><p> I’ll be sharing more examples from Cogmind and other roguelikes below where applicable to the topics we’ll be covering.</p><p>我将在下面分享更多适用于我们将要讨论的主题的CogMind和其他无赖的示例。</p><p> Note that as discussed here multitile creatures refer to those of an  actual larger size when it comes to mechanics and the number of grid spaces they occupy, not just cosmetic size, which a number of games do as a simple way around implementation issues, but as a result also don’t fully realize their potential.</p><p>请注意，正如这里讨论的那样，多瓦片生物指的是那些实际更大的生物，涉及到机械和它们占据的网格空间的数量，而不仅仅是表面上的大小，这是许多游戏为了绕过实现问题而做的简单方式，但结果也没有充分发挥它们的潜力。</p><p>  There are a number of different ways to depict multitile creatures on the map, some of which might need to get creative if limited to ASCII and/or traditional grids with an otherwise uniform cell size.</p><p>在地图上描绘多瓦片生物有许多不同的方法，如果仅限于ASCII和/或具有统一单元大小的传统网格，其中一些可能需要更有创意。</p><p> For Cogmind’s ASCII mode I chose to repeat the single character across the area currently occupied by the entity. The usual opposition to this concept claims that it becomes impossible to distinguish whether it is a group of entities or a single large entity, but in practice that’s not really much of an issue since based on the game content it’s otherwise extremely rare to have individuals matching that letter both adjacent to each other in a uniform shape and also moving in perfect formation. Not to mention when examining such an entity  all the spaces are highlighted together, and labeling (or for example in other roguelikes listing what is currently visible) only does so once for the entire thing, rather than for every constituent cell. So this isn’t really something to worry about unless there is something else specific to the given game’s content or mechanics that might lead to confusion.</p><p>对于CogMind的ASCII模式，我选择在实体当前占用的区域中重复单个字符。通常反对这一概念的人声称，无法区分它是一组实体还是单个大型实体，但在实践中，这并不是什么大问题，因为根据游戏内容，其他情况下，个人既以统一的形状相邻，又以完美的队形移动，这是极其罕见的。更不用说当检查这样的实体时，所有的空间一起突出显示，并且标记(或者例如在列出当前可见的内容的其他流氓中)只对整个事物执行一次，而不是针对每个组成单元格执行一次。因此，这并不是真正需要担心的问题，除非有其他特定于给定游戏的内容或机制的东西可能会导致混淆。</p><p>    Incursion offers another potential approach for ASCII-based roguelikes, linking the creature’s character to its surrounding occupied cells with a separate representative character, in this case using ‘+’:</p><p>入侵为基于ASCII的流氓提供了另一种可能的方法，通过单独的代表角色将生物的角色链接到其周围占用的单元，在本例中使用‘+’：</p><p>  Under a very strict grid-based system like that often used in ASCII games, it’s technically still possible to draw multitile creatures using a sprite that extends over more than one cell. Cogmind’s engine in particular doesn’t even support drawing anything that doesn’t match the grid size, so the only way to draw a multitile object is to do it piecemeal, one cell at a time. For example, the 2×2 Behemoth consists of four separate cells, appearing as such in the sprite sheet:</p><p>在ASCII游戏中经常使用的基于网格的非常严格的系统下，从技术上讲，仍然可以使用延伸到多个单元的精灵来绘制多瓦片生物。尤其是CogMind的引擎甚至不支持绘制任何与网格大小不匹配的内容，因此绘制多瓦片对象的唯一方法是分段绘制，一次绘制一个单元格。例如，2x2庞然大物由四个单独的单元格组成，在精灵工作表中按如下方式显示：</p><p>  Many roguelikes using modern engines don’t necessarily care about this sort of thing, and are instead able to simply draw any sprite, large or small, at any position.  Zorbus offers a good example of multiple different methods for drawing large creatures when there aren’t any architectural restrictions.</p><p>许多使用现代引擎的流氓并不一定关心这类事情，而是能够在任何位置简单地画出任何大小的精灵。Zorbus提供了一个很好的例子，在没有任何建筑限制的情况下，可以使用多种不同的方法来绘制大型生物。</p><p>   A number of roguelikes (including Zorbus above) might display multitile creatures simply using large characters, highlighting another consideration when working with multitile creatures: partial visibility. Field of view in roguelikes is almost always handled on a cellwise basis, so what does the player see if only one or more pieces of a multitile creature are visible?</p><p>许多盗贼(包括上面的Zorbus)可能会简单地使用大字符显示多瓦片生物，这突出了使用多瓦片生物时需要考虑的另一个问题：局部可见性。盗贼的视野几乎总是以细胞为基础来处理的，那么如果一个多瓦片生物只有一块或多块可见，玩家会看到什么呢？</p><p> In terms of ASCII and Cogmind’s default approach of repeating the same character throughout every occupied cell, seeing only part of a creature doesn’t make much of a difference since every cell contains the same representation. Perhaps the main concern here would be that a player might not be able to immediately distinguish whether a single ‘B’, for example, is a corner piece of a large Behemoth or a single-tile Brawler-class robot. This is where it helps to have those automated labels demonstrated earlier--the question is answered immediately on spotting them!</p><p>根据ASCII和CogMind的默认方法，即在每个占用的单元中重复相同的字符，只看到生物的一部分没有太大区别，因为每个单元都包含相同的表示。也许这里最主要的担忧是，玩家可能不能立即分辨出，例如，一个“B”是一个大型庞然大物的角落部分，还是一个单瓦的布劳勒级机器人。这就是早些时候演示这些自动标签的帮助之处--问题一发现就会立即得到回答！</p><p>  To demonstrate another scenario, we can use a  graphical Cogmind mod recently released by Ape, which converts the default multicharacter style to instead use large characters like so:</p><p>为了演示另一个场景，我们可以使用Ape最近发布的图形CogMind mod，它将默认的多字符样式转换为使用大字符，如下所示：</p><p>    Again the autolabeling will help here anyway, but the top-left corner of a large ‘B’ character actually looks like an off-center ‘c’! And of course each other corner, or side, will have its own unique appearance. Partial visibility doesn’t work so well with this approach as far as quick visual parsing goes (usually one of the advantages of using ASCII in the first place).</p><p>再说一次，自动标记在这里无论如何都会有帮助，但是一个大的“B”字符的左上角实际上看起来像一个偏离中心的“c”！当然，每一个角落，或者每一边，都会有自己独特的面貌。就快速视觉解析而言，部分可见性在这种方法中不能很好地工作(通常这是首先使用ASCII的优点之一)。</p><p> Based on this info, with multitile creatures we might want to break the mold of displaying only the cells that a player can currently see, and instead allow the player to know and see the full extent of any multitile creature they can at least see part of. This could apply to both ASCII and tilesets. Either show the entire creature normally if any of its parts are visible, or show it all but consider fading those cells not currently in FOV, since it can still be important to know when certain subsections are technically out of view.</p><p>基于这个信息，对于多瓦片生物，我们可能想要打破只显示玩家当前可以看到的细胞的模式，而是允许玩家知道和看到他们至少可以看到部分的任何多瓦片生物的全部范围。这既适用于ASCII，也适用于平铺集。要么正常显示整个生物(如果它的任何部分可见)，要么将其全部显示，但考虑淡化当前不在FOV中的那些单元，因为知道某些部分何时从技术上看不到仍然很重要。</p><p>  For cogmind in particular I decided against showing parts outside FOV (which is an option even if separate characters are used for each part!) because it would complicate a lot of the UI features in my case. I imagine it would work fine for a lot of other roguelikes, though.</p><p>尤其是出于深思熟虑，我决定不在FOV之外显示部件(这是一个选项，即使每个部件都使用不同的字符！)。因为在我的情况下，这会使很多UI功能复杂化。不过，我想这对很多其他流氓来说应该没什么问题。</p><p>  Handling relative position data for entities is fairly straightforward when each one can only occupy one cell at a time, but what do you do for those with a larger footprint? Some people get hung up on this question. The answer for a given roguelike could depend on other needs and architectural concerns, but here I’ll share what’s worked well for me.</p><p>当每个实体一次只能占用一个单元格时，处理实体的相对位置数据相当简单，但是对于占用空间较大的实体该怎么办呢？有些人在这个问题上犹豫不决。对于给定的流氓类型，答案可能取决于其他需求和架构考虑，但在这里我将与您分享适合我的解决方案。</p><p> This is rooted in the format for general map data, so here’s a diagram of how Cogmind map objects are structured:</p><p>这植根于常规地图数据的格式，因此下面的图表展示了CogMind地图对象的结构：</p><p>  This diagram includes some superfluous info because I pulled it from a broader discussion, but the concept to pay attention to here is that 1) an entire map/floor is represented by a two-dimensional matrix of Cell objects, and 2) within each of those cells is an Entity object. “Entity” refers to an actor/creature/character/mob/whateveryoucallit, where the Cell stores its occupant’s handle (sorta like a pointer) or simply null if no Entity is currently present at that location.</p><p>此图包含一些多余的信息，因为我是从更广泛的讨论中提取的，但这里要注意的概念是：1)整个地图/楼层由Cell对象的二维矩阵表示，2)在每个单元格内是一个Entity对象。“Entity”指的是actor/creature/character/mob/whateveryoucallit，中存储其占有者句柄(有点像指针)的单元，或者如果该位置当前没有实体，则直接为NULL。</p><p> Although I do also have a list of all the Entities in existence (technically managed as a separate list for each faction), and that format clearly comes in handy for some types of operations that need to iterate over all Entities, I find it very useful to have an actual 2D space across which to perform spacial searches and apply effects etc. For performance reasons this is especially important in Cogmind where there are  hundreds of Entities at once.</p><p>虽然我也有一个现有所有实体的列表(从技术上讲，每个派别都作为单独的列表进行管理)，而且这种格式对于需要迭代所有实体的某些类型的操作显然很有用，但我发现拥有一个实际的2D空间非常有用，可以在其中执行空间搜索和应用效果等。出于性能原因，这在CogMind中尤其重要，因为一次有数百个实体。</p><p> So what does this mean for multitile Entities? Well… just put their unique handle in every Cell they occupy :)</p><p>那么，这对多瓦片实体意味着什么呢？Well…。只需将其独特的句柄放在它们占据的每个单元格中：)。</p><p> It’s not like the Entity object itself is actually copied anywhere--it’s just a little handle, so there’s no serious waste of space, but definitely a serious bonus to convenience. Processes checking who’s occupying any one (or more) of those Cells will be pointed to the same Entity. Whenever the Entity changes position, it just moves its handles from  all of the original space(s) it occupied to the new ones.</p><p>这并不像实体对象本身实际上被复制到任何地方--它只是一个很小的句柄，所以不会严重浪费空间，但绝对是对便利性的重大好处。检查谁占用了这些单元格中的任何一个(或多个)的进程将指向同一实体。每当实体改变位置时，它只是将其控制柄从它占用的所有原始空间移动到新的空间。</p><p> Each Entity itself also stores a  list of all the map coordinates it currently occupies. While it’s true that for most/single-celled Entities this list only contains one coordinate, implementing the system like this makes it easily scalable. At the same time, although for most roguelikes you could generally extrapolate these additional coordinates if you know their reference position and size, that’s pretty slow to be doing all the time!</p><p>每个实体本身也存储其当前占用的所有地图坐标的列表。虽然对于大多数/单元格实体来说，这个列表确实只包含一个坐标，但是这样实现系统使它很容易扩展。同时，尽管对于大多数流氓来说，如果您知道它们的参考位置和大小，通常可以推断出这些额外的坐标，但这样做的速度很慢！</p><p> In my case I chose the Entity’s top-left corner as their “reference position,” the first to appear in its list, where any additional coordinates are added in row-first order (notice how the indices here will conveniently mirror offsets in the sprite sheet shown earlier ;)). The idea of a reference position will come in handy later.</p><p>在我的示例中，我选择实体的左上角作为它们的“参考位置”，这是它的列表中第一个出现的位置，在这里，任何其他坐标都是按行优先顺序添加的(请注意，这里的索引将如何方便地反映前面显示的精灵工作表中的偏移量；)。设立一个参考职位的想法稍后会派上用场。</p><p> (Although most devs there don’t make mention of multitile entities, regarding map object architecture you might find other inspiration in the  previous  relevant FAQs over on r/RoguelikeDev.)</p><p>(尽管那里的大多数开发人员没有提到多瓦片实体，但是关于地图对象体系结构，您可以在r/RoguelikeDev上前面的相关常见问题中找到其他灵感。)</p><p>  Before we go any further it’s important to talk about  shape as it relates to multitile creatures.</p><p>在我们进一步讨论之前，重要的是讨论一下形状，因为它与多层生物有关。</p><p> By far the most common multitile creature in a roguelike, if there are any at all, is the so-called “2×2″, occupying a total of four cells. As a square this is fairly easy to deal with because it doesn’t have any convex or concave elements to complicate movement or interactions.</p><p>到目前为止，盗贼类生物中最常见的多瓦片生物(如果有的话)是所谓的“2×2”，总共占据四个细胞。作为一个正方形，这是相当容易处理的，因为它没有任何凸或凹的元素来使移动或交互复杂化。</p><p> Non-square shapes (even just rectangles!) are problematic since then you likely have to deal with the logic and consequences of  rotation, among other issues. With multitile creatures already introducing enough of their own complications, most roguelikes don’t venture into other shapes. (Something like Dumuzid is of course an exception here, since its a small game where the central theme happens to be size manipulation. Interestingly, it does not allow rotation, either.) Rotation suggests an explicit  facing, anyway, and most roguelikes don’t have facing mechanics, so multitile creatures that imply multiple orientations are often avoided.</p><p>非正方形形状(甚至只有矩形！)。是有问题的，因为你可能不得不处理轮换的逻辑和后果，以及其他问题。由于多瓦片生物已经引入了足够的复杂性，大多数盗贼不会冒险进入其他形状。(像Dumuzid这样的东西在这里当然是个例外，因为它是一个中心主题恰好是大小操纵的小游戏。有趣的是，它也不允许轮换。)。不管怎么说，旋转意味着一个明确的面向，而且大多数盗贼没有面向机制，所以通常会避免暗示多个方向的多瓦片生物。</p><p>  Whenever the topic of multitile creatures pops up in the roguelikedev community, there’s a good chance it’s someone asking about pathfinding. In a game where every actor occupies exactly one space, moving them across a grid seems a lot more straightforward than managing those which need extra space to move around.</p><p>每当roguelikedev社区中出现多瓦片生物的话题时，很有可能是有人询问寻路。在每个参与者正好占据一个空间的游戏中，在网格中移动他们似乎比管理那些需要额外空间来四处移动的人简单得多。</p><p> For the purposes of pathfinding for multitile creatures we’re going to be ignoring these less common scenarios and, again, creatures outside this article’s scope:</p><p>为了寻找多层生物的路径，我们将忽略这些不太常见的场景，同样，也忽略本文范围之外的生物：</p><p> non-square shapes (and by extension any rotation involved with those--CDDA has rotating multitile vehicles of various shapes if you want to look into that, for example  here)</p><p>非正方形形状(以及与这些形状相关的任何旋转--CDDA有各种形状的旋转多瓦片交通工具，例如，您可以在这里查看)。</p><p> Still, if you’re working with any of the above, it’s mainly a case of picking a primary reference part (of the creature in question) on which the pathfinding is based, and extrapolate positions for other connected parts as it’s moving, which is actually akin to what we’ll be doing here in a moment for regular square multitile creatures.</p><p>尽管如此，如果你使用上面的任何一个，它主要是选择一个主要的参考部分(有问题的生物的)作为寻路的基础，并在它移动时推断其他相连部分的位置，这实际上类似于我们稍后将在这里为普通的正方形多瓦片生物所做的事情。</p><p>  One method I haven’t used before but have seen others use is to explicitly map out the spaces available to large creatures, and use that map for pathfinding. Taking the most common 2×2 creature as an example, you can make a copy of your map and block any otherwise open spaces that have a wall or other impassable obstacle to their south, east, or southeast.</p><p>有一种方法我以前没有用过，但见过其他人用过，那就是明确地标出大型生物可用的空间，然后用这张地图来寻路。以最常见的2×2生物为例，你可以复制你的地图，阻挡任何在其南面、东面或东南面有围墙或其他不可逾越障碍的空地。</p><p>  So as per the above screenshots, pathfinding algorithms would rely on two separate maps, one used for standard-sized actors, and another for 2×2 creatures:</p><p>因此，根据上面的屏幕截图，寻路算法将依赖于两个独立的地图，一个用于标准大小的演员，另一个用于2×2的生物：</p><p>    However, this approach works better for static maps, since changes to the map due to terrain destruction or other factors would require recalculating the pathfinding map(s) (or at least parts of it). I love rampant terrain destruction in my roguelikes, so this approach won’t really work so well in my case. As you’ll see below, an alternative dynamic approach can also take into account more factors, anyway, creature size being just one of them.</p><p>但是，此方法更适用于静态地图，因为由于地形破坏或其他因素导致的地图更改将需要重新计算寻路地图(或至少部分地图)。我喜欢在我的无赖中肆虐的地形破坏，所以这种方法在我的情况下不会真正起到很好的作用。正如你将在下面看到的，另一种动态方法也可以考虑更多的因素，无论如何，生物大小只是其中之一。</p><p>  The dynamic approach starts getting more deeply into how  you build your pathfinding system architecture. Amit’s got  great resources on A* pathfinding over at Red Blob if you want to read up on that common algorithm for more background. I’m not going over basic A* here, instead looking at how to best apply it so that it can specifically account for creatures of arbitrary size.</p><p>动态方法开始更深入地研究如何构建您的寻路系统架构。阿米特在Red Blob有很好的A*寻路资源，如果你想了解更多背景知识的话。我不会在这里复习基本的A*，而是研究如何最好地应用它，这样它就可以特别地考虑任意大小的生物。</p><p> For all but the simplest roguelike worlds you’ll often want to have creatures actually examine each potential cell along a path and weigh it in terms of various relevant factors, for example terrain movement costs (which can differ by creature type and terrain?), or the creature’s own capabilities (able to swim? fly? open doors? some other form of environmental interaction?). One nice way to compartmentalize this feature: Callbacks.</p><p>除了最简单的无赖世界外，你通常希望让生物实际检查一条路径上的每个潜在细胞，并根据各种相关因素对其进行加权，例如地形移动成本(可能因生物类型和地形而异？)，或者生物自身的能力(会游泳吗？飞?。开门吗？某种其他形式的环境相互作用？)。划分此功能的一个很好的方法是：回调。</p><p> In simple terms, when a creature wants to find a path from point A to point B and calls the game’s pathfinding function, it also provides a callback function that essentially contains instructions for how to value cells along prospective paths. A* pathfinding operates by assigning “cost” values to cells until it finds the sequence of moves that can arrive at the intended target for the lowest total cost. So the callback’s job is to just return the cost for a given cell in order to facilitate those calculations.</p><p>简而言之，当生物想要找到从A点到B点的路径并调用游戏的寻路函数时，它还提供了一个回调函数，该函数本质上包含如何沿预期路径为单元赋值的指令。*寻径的操作方式是将“成本”值分配给单元格，直到它找到能够以最低总成本到达预期目标的移动序列。因此，回调的工作就是返回给定单元格的成本，以便于这些计算。</p><p>  As shown above, Cogmind’s primary movement pathfinding callback that’s sent to the algorithm is actually an object holding multiple methods, originally virtually defined by the base class associated with the pathfinder itself (Cartographer2D). I found it more efficient to split out into multiple methods some of the checks that a callback might need to handle, e.g. isValid() is used to tell whether the goal is a valid movement position, which is probably important to know before bothering to start :P. (Cartographer2d also supports pathfinding via cell-enabled teleportation, but Cogmind itself doesn’t feature that kind of teleportation so the callback object doesn’t define the necessary method.)</p><p>如上所述，发送到算法的CogMind的主要移动寻径回调实际上是一个包含多个方法的对象，最初由与寻路器本身相关联的基类(Cartorapher2D)虚拟定义。我发现将回调可能需要处理的一些检查拆分为多个方法会更有效，例如，isValid()用于告知目标是否为有效的移动位置，这在费心开始之前可能很重要：p。(Cartorapher2d也支持通过启用细胞的隐形传送进行寻路，但CogMind本身并不具有这种传送功能，因此回调对象没有定义必要的方法。)。</p><p> Where does this accommodate multitile creatures? First of all, remember that the reference part of the creature is what’s being used to calculate their path--the beginning of the path matches their top-left corner, and the end of the path will be the final location of their top-left corner.</p><p>在哪里可以容纳多瓦片生物呢？首先，记住生物的参考部分是用来计算它们的路径的--路径的起点与它们的左上角匹配，而路径的终点将是它们的左上角的最终位置。</p><p>  The isValid() function* just needs to be sure to check not only whether the reference position at each cell along the path is valid, but that all other relative parts of the same creature are also valid (*and by extension getMoveCost(), which is what checks isValid() before calculating and returning the cost for a cell).</p><p>IsValid()函数*只需要确保不仅检查路径上每个单元格的引用位置是否有效，而且同一生物的所有其他相关部分也是有效的(*以及扩展为getMoveCost()，这是在计算和返回单元格的成本之前检查isValid()的内容)。</p><p>  This dynamic approach doesn’t require precalculating or maintaining any other pathfinding maps, can take into account any number of other factors (regardless of whether they’re changing all the time!), and is clearly just what we need for allowing multitile creatures to move around while also considering whatever else they need to consider.</p><p>这种动态方法不需要预先计算或维护任何其他路径地图，可以考虑任何数量的其他因素(不管它们是否一直在变化！)，显然这正是我们允许多瓦片生物四处移动的需要，同时还可以考虑它们需要考虑的任何其他因素。</p><p> In summary you get a lot of flexibility by using callbacks for pathfinding. We can add whatever absolute checks we want to isValidCell() and they’ll be applied to any cell the creature might think about occupying, or add checks to getMoveCost() for moves that are allowed but might have a different cost than moving into/through a normal cell. Cogmind doesn’t make especially heavy use of these features, though as you can see there are conditions determining whether or not an entity can use different types of hidden doors, and the cost of pathing through a known trap or area prone to cave-ins is higher (making it less likely).</p><p>总而言之，通过使用回调查找路径，您可以获得很大的灵活性。我们可以向isValidCell()添加任何我们想要的绝对检查，它们将应用于生物可能考虑占用的任何单元，或者将检查添加到getMoveCost()，检查允许的移动，但可能与移动到/穿过普通单元的成本不同。CogMind不会特别频繁地使用这些功能，尽管如您所见，有一些条件决定了实体是否可以使用不同类型的隐藏门，并且通过已知陷阱或容易塌陷的区域的成本较高(使其不太可能发生)。</p><p> Aside: The popular roguelike library  libtcod (which I recommend in my  How to Make a Roguelike talk/article) includes support for  pathfinding callbacks! In fact, using libtcod in my early roguelikedev days is actually where I learned about them in the first place :)</p><p>旁白：流行的类似无赖的库libtcod(我在我的“如何进行类似无赖的演讲/文章”中推荐的)包括对寻径回调的支持！事实上，在我早期的roguelikedev时代使用libtcod实际上是我最初了解它们的地方：)。</p><p>  Having gotten the primary technical concerns out of the way, there’s also the design side of the equation when it comes to multitile creatures. Surely you can’t just drop them into a world made for your typical 1×1 cell-sized creatures and expect everything to be okay :P</p><p>在解决了主要的技术问题之后，当涉及到多层生物时，也有设计方面的问题。当然，你不能就这样把它们放进一个为典型的1×1细胞大小的生物量身定做的世界里，然后指望一切都会好起来：P。</p><p>  Naturally more open maps are better suited for these large creatures, since terrain is the biggest obstacle to their movement. Although roguelike maps tend to have a lot of tight spaces, even subterranean maps can also be made more hospitable for large creatures if there are at least  some open areas for them to comfortably occupy.</p><p>自然，更开放的地图更适合这些大型生物，因为地形是它们移动的最大障碍。虽然流氓地图往往有很多狭小的空间，但如果至少有一些开放的区域让大型生物舒适地占据，即使是地下地图也可以变得更适合大型生物使用。</p><p> For example Cogmind’s most common 2×2 unit, Behemoth</p><p>例如，CogMind最常见的2×2单位，庞然大物。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.gridsagegames.com/blog/2020/04/developing-multitile-creatures-roguelikes/">https://www.gridsagegames.com/blog/2020/04/developing-multitile-creatures-roguelikes/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/多面体/">#多面体</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/multitile/">#multitile</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/生物/">#生物</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>