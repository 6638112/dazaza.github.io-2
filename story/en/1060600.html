<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们如何使用Web组件 How we use web components</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How we use web components<br/>我们如何使用Web组件 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-05 20:56:33</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/8a5cdda641447f749a5b8cbea7d113a1.png"><img src="http://img2.diglog.com/img/2021/5/8a5cdda641447f749a5b8cbea7d113a1.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>At GitHub, we pride ourselves on delivering a first-class developer experience. A considerable part of our work is on our front end, which we strive to keep as lightweight, fast, and accessible as possible. For a product as large as GitHub, this can be quite the task. Like many front-end codebases, we leverage components, independent, isolated, and reusable pieces of code that allow application teams to deliver high fidelity UI quickly and efficiently while still keeping to our high standards of quality.</p><p>在GitHub，我们为提供一流的开发人员体验而自豪。我们正面的一部分是我们的前端，我们努力保持尽可能轻便，快速，快速。对于像GitHub一样大的产品，这可以是完全的任务。与许多前端码布一样，我们利用组件，独立，隔离和可重复使用的代码，允许应用团队快速有效地提供高保真UI，同时仍然保持高标准的质量。</p><p> We’re using Web Components in a big way at GitHub. We have  over a dozen open-source Web Components and with dozens more that are closed source.</p><p> 我们在GitHub中使用Web组件。我们拥有十几个开源Web组件，并且数十个是封闭源的更多。</p><p>  When GitHub launched over a decade ago, we had a modest front-end codebase that mostly used jQuery. Ten years and nearly 85,000 lines of code later, we had a large front-end codebase that was starting to show growing pains. We ultimately transitioned away from jQuery ( for reasons which we detailed in a blog post at the time) and started using new technologies which could better solve our problems.</p><p>  当GitHub在十年前推出时，我们有一个适度的前端代码库，主要用于jQuery。十年和近85,000行代码稍后，我们有一个大型前端码布开始展示成长的痛苦。我们最终从jQuery转变（出于当时的博客文章中详述的原因）并开始使用能够更好地解决我们问题的新技术。</p><p> We began to dabble with a new technology called   Web Components, a set of native browser technologies that allow the development of customized HTML elements, progressively enhanced with JavaScript.</p><p> 我们开始涉及一种名为Web组件的新技术，这是一组允许开发自定义HTML元素的本机浏览器技术，逐步增强了JavaScript。</p><p> We chose to use Web Components because our codebase was already structured into component-like behaviors. Still, as the GitHub monolith grew in size, we saw the need to implement better encapsulations before the front-end became unmanageable – and Web Components fit the bill. Web Components offered better portability and encapsulation than our existing JavaScript behaviors. We were happy to experiment with Web Components alongside our existing front-end infrastructure since it doesn’t incur any upfront cost or “buy-in” to a specific framework.</p><p> 我们选择使用Web组件，因为我们的代码库已经构建成组件类似的行为。尽管如此，随着GitHub Monolith的规模，我们认为在前端变得无法管理之前，我们看到需要更好的封装 - 并且Web组件适合账单。 Web组件提供比我们现有的JavaScript行为更好的可移植性和封装。我们很乐意与我们现有的前端基础架构一起尝试网络组件，因为它不会对特定框架的预付成本或“买入”并不产生。</p><p> Our first two custom elements shipped in 2014:   &lt;relative-time&gt; and  &lt;local-time&gt;, which show times and dates in friendly formats, and   &lt;include-fragment&gt;, which allows us to lazy load HTML fragments. Slowly we realized just how powerful these elements could be and began replacing design patterns within the codebase wholesale, such as replacing our “facebox” modal dialog pattern with   &lt;details-dialog&gt;. Our components now range from very generic, multi-purpose behaviors like   &lt;remote-input&gt; to specific single-purpose components such as the   &lt;markdown-toolbar&gt; element and its siblings.</p><p> 我们的前两个自定义元素于2014年发货：＆lt;相对时间＆gt;和＆lt; local-time＆gt;，以友好格式的显示时间和日期，＆lt; include-fragment＆gt;，它允许我们延迟加载HTML片段。慢慢地，我们实现了这些元素的功能如何强大，并开始替换CodeBase批发内的设计模式，例如用＆lt;详细信息对话框替换我们的“面向框”模态对话框模式。我们的组件现在的范围是＆lt;远程输入＆gt的非常通用的多功能行为。对于特定的单一用途组件，例如＆lt; markdown-toolbar＆gt;元素及其兄弟姐妹。</p><p> For the power Web Components affords, there are still pain points and pitfalls. With such a large codebase owned by hundreds of engineers across dozens of teams, we need to provide as much support and tooling as possible, encoding best practices without manual code review becoming a bottleneck.</p><p> 对于电源网组件提供，仍有疼痛点和陷阱。通过跨越数十个团队的数百名工程师拥有的如此大的CodeBase，我们需要提供尽可能多的支持和工具，编码最佳实践，无需手动代码审查成为一个瓶颈。 </p><p>  To make engineers effective at writing high-quality Web Components—and encourage best practices—we’ve been working on a few tools to make authoring Web Components much easier.</p><p>为了使工程师在编写高质量的Web组件时 - 并鼓励最佳实践 - 我们一直在努力使创作Web组件更容易的工具。</p><p>  We’ve been transitioning our Rails code to using ViewComponent, a framework for building reusable components within Rails. ViewComponent goes hand-in-hand with Web Components since a ViewComponent can have a one-to-one relationship with a Web Component, allowing our developers to work on a single abstraction for both front-end and backend.</p><p>  我们一直将我们的Rails代码转换为使用ViewComponent，这是一种在Rails中构建可重用组件的框架。 ViewComponent使用Web组件携手，因为ViewComponent可以与Web组件具有一对一关系，允许我们的开发人员对前端和后端的单个抽象工作。</p><p>  Catalyst, our open source library that makes it easier to write web components, has been a driving force that ties together some of our best practices. Catalyst leverages TypeScript to add decorators, which save on a lot of the boilerplate necessary to write Web Components.</p><p>  Catalyst，我们的开源库，使其更容易编写Web组件，这是一个推动力，这些驱动力与我们的最佳实践中的一些有关。 Catalyst利用TypeScript添加装饰器，该装饰器保存在编写Web组件所需的很多样式板上。</p><p> Catalyst took inspiration from the excellent  Stimulus library, and Google’s  LitElement. It is designed to answer the specific set of needs our developers require. Our internal developer experience surveys have shown success in providing a substantial improvement in authoring code over legacy patterns.</p><p> 催化剂从优秀的刺激图书馆和谷歌的诉讼中获取了灵感。它旨在回答我们开发人员需要的特定需求集。我们的内部开发人员体验调查表明了在遗留模式下提供了重大改进。</p><p> You can read more about Catalyst and its conventions, patterns, and anti-patterns in our  guide.</p><p> 您可以在我们的指南中阅读更多关于Catalyst及其约定，模式和反模式的信息。</p><p>  We provide a set of open-source linter configurations for developers. For general code practices we have  eslint-plugin-github. We also have  eslint-plugin-custom-elements, which provides further checks for authoring Web Components. Extracting these to open source repositories allows us to remove code from the monolith but remain consistent.</p><p>  我们为开发人员提供了一组开源Lint配置。对于一般代码实践，我们有eslint-plugin-github。我们还有eslint-plugin-custom-compents，它提供了进一步检查创作Web组件。提取这些以开源存储库允许我们从单甘石中删除代码，但保持一致。</p><p> We also have internal tests to verify that developers follow best practices and ensure that they don’t continue to use deprecated patterns and behaviors. One of our tests makes sure that a deprecated “facebox” pattern isn’t introduced to the codebase and suggests using a   &lt;details-dialog&gt; element as an alternative.</p><p> 我们还具有内部测试，以验证开发人员遵循最佳实践，并确保他们不继续使用已弃用模式和行为。我们的测试之一，确保不推出弃用的“面部框”模式，并使用A＆lt; dialogy-dialog＆gt;元素作为替代品。 </p><p> class FaceboxDeprecationTest &lt; Test::Fast::TestCase EXPECTED_NUMBER_OF_FACEBOXES = 44 # Find facebox triggers set with rel=facebox, in either HTML attributes or # as part of hash assignment (for rails helpers) REGEX_FOR_FACEBOX_BINDING = %r|rel\s*[=:]&gt;?\s*[&#34;&#39;]?facebox| REGEX_FOR_DATA_FACEBOX = %r|data-facebox\s*=&gt;?\s*| def test_limit_facebox actual_rel_facebox = grep(REGEX_FOR_FACEBOX_BINDING, options: %w[-In], paths: %w[app/**/*.erb]) actual_data_facebox = grep(REGEX_FOR_DATA_FACEBOX, options: %w[-In], paths: %w[app/**/*.erb]) count = actual_rel_facebox.count(&#34;\n&#34;) + actual_data_facebox.count(&#34;\n&#34;) assert_operator count, :&lt;=, EXPECTED_NUMBER_OF_FACEBOXES, &lt;&lt;-EOLIt looks like you added a facebox. Please use &lt;details-dialog&gt; instead.If you must increment EXPECTED_NUMBER_OF_FACEBOXES in this test, please/cc @github/ui-frameworks-reviewers in your pull request, as we may be able to help! Thanks.EOL assert_equal EXPECTED_NUMBER_OF_FACEBOXES, count, &lt;&lt;-EOLIt looks like you removed a facebox. YOU ARE AWESOME! 💖 💖 💖 💖 💖Please decrement EXPECTED_NUMBER_OF_FACEBOXES in this test and treat yourself tosomething special. You deserve it.EOL endend</p><p>Class FaceBoxDeprecationTest＆lt; test :: fast :: testcase预期_number_of_faceboxes = 44＃查找使用rel = facebox设置的面部框触发器，在html属性或＃中作为哈希分配的一部分（对于Rails帮助者）Regex_for_faceBox_Binding =％R | rel \％r | rel \ s * [=：]＆gt ;？\ s * [＆＃34;＆＃39;]？面向框架regex_for_data_facebox =％r |数据面框\ s * =＆gt;？\ s * | def test_limit_facebox实际_rel_facebox = grep（regex_for_facebox_binding，选项：％w [-in]，paths：％w [app / ** / *。erb]）实际_data_facebox = grep（regex_for_data_facebox，选项：％w [-in]，paths：％ w [app / ** / *。erb]）count =实际= actic_rel_facebox.count（＆＃34; \ n＆＃34;）+ active_data_facebox.count（＆＃34; \ n＆＃34;）assert_operator count，：＆lt; = ，预期的_number_of_faceboxes，＆lt;＆lt;＆lt; -eolit看起来您添加了一个面部框。请使用＆lt;详细信息对话框和gt;相反。如果您必须在此测试中递增预期，请在此测试中，请/ cc @ github / ui-frameworks-readyers，因为我们可能会提供帮助！ vishent.eol assert_equal预期_number_of_faceboxes，count，＆lt;＆lt; -eolit看起来像你删除了一个面向框。你太棒了！ 💖💖💖💖💖💖💖💖💖递减预期_Number_of_faceboxes在此测试中并享受自己特殊的。你应该得到它。将endend</p><p>  The road from an application-specific front-end behavior to an open-source Web Component starts with a Catalyst component inside the monolith codebase. Components that are good candidates for extraction get generalized into a robust, strictly behavioral, dependency-free Web Component.</p><p>  从应用程序特定的前端行为到开源Web组件的道路以Monolith CodeBase内的催化剂组件开头。提取良好候选人的组件将广泛化为强大的，严格的行为依赖性Web组件。</p><p> In the monolith, engineers might prototype ideas and ship them slowly using feature flags while continuously revising them. After the component has been tested in production for some time, we will look for opportunities to lift the component into its own repository. We also regularly assess the codebase to find reusable patterns, generic behaviors, or components that otherwise have a compelling reason to be lifted into their own repositories.</p><p> 在整形单片中，工程师可能会在不断修改它们的同时使用特色标志慢慢地思考并慢慢运送它们。在组件在生产中进行了一段时间后，我们将寻找机会将组件升级为自己的存储库。我们还定期评估CodeBase，以查找可重用的模式，通用行为或组件，否则有令人信服的原因被解除为自己的存储库。</p><p>  We encourage developers to write Catalyst components while developing user interfaces within the dotcom monolith. The benefits of utilizing Catalyst from the start are that the library abstracts away some common pitfalls of writing Web Components and enforces best practices.</p><p>  我们鼓励开发人员编写Catalyst组件，同时在Dotcom Monolith开发用户界面。利用催化剂从一开始的好处是图书馆摘要一些常见的写作Web组件的缺陷并强制执行最佳实践。</p><p> Registering a Web Component can incur some boilerplate, but we make it easier with naming conventions and a sprinkle of  TypeScript decorators.  Actions in Catalyst make event listening easier than managing global event listeners. Mutating  targets for existing HTML is better than rendering HTML templates in the browser.</p><p> 注册Web组件可能会产生一些样板，但我们可以更轻松地命名约定和洒上的打字装饰器。催化剂中的行动使得事件倾听比管理全球活动侦听器更容易。突变现有HTML的目标优于浏览器中的HTML模板更好。</p><p>  While contained within our application, components might have appli cation-specific code added to them as they get used in different contexts. Application-specific code is OK when you have specific needs that you need to fulfill, but if a component is supposed to work in other contexts, it needs to be flexible and generalized. Most often, this comes in the form of hard-coded options that should be made configurable. Generalizing a component so that it is more portable is critical to enabling re-use by other teams.</p><p>  虽然包含在我们的应用程序中，因此组件可能会在不同上下文中使用时添加特定于特定的代码。特定于应用程序的代码是可以完成的特定需求，但如果组件应该在其他上下文中工作，则需要灵活和概括。通常，这是以硬编码选项的形式来配置，这些选项应该是可配置的。概括一个组件，使其更加便携对于能够通过其他团队重复使用至关重要。</p><p> Before extracting the Catalyst component, we remove the Catalyst-specific functionality and convert it to a plain Web Component. Why remove the library that the team claims makes writing Web Components easier? While Catalyst is beneficial for developers, we want our components to have zero dependencies. Requiring developers outside of the GitHub organization to understand Catalyst before contributing code back to the component is extra friction that we don’t want to incur.</p><p> 在提取催化剂组分之前，我们去除催化剂特异性功能并将其转换为平纹网组件。为什么删除团队声明的库使得编写Web组件更容易？虽然Catalyst对开发人员有益，但我们希望我们的组件具有零依赖性。在GitHub组织之外需要开发人员在贡献代码之前了解Catalyst，这是我们不想产生的额外摩擦。 </p><p>  While monolith components might be tightly coupled to specific application logic, have third-party dependencies, and lean on existing tests, we have a different set of standards for open source components. Our open source components should have close to 0 dependencies, be framework and library agnostic, lightweight, style free, decoupled from any other components, and should do only one thing and one thing well.</p><p>虽然Monolith组件可能紧密耦合到特定的应用程序逻辑，但有第三方依赖项，并依赖于现有测试，我们有一个不同的开源组件的标准。我们的开源组件应靠近0依赖性，框架和图书馆不可知，轻巧，自由，从任何其他组件解耦，并应该只做一件事和一件事。</p><p> While we want our components to be dependency-free, we also want the same robustness guarantees from the monolith—and that includes types. We include TypeScript definitions with our components, also written using ES modules, to enable bundlers to consume it easily. We also ensure there is a full test suite and linter setup using our standardized configurations.</p><p> 虽然我们希望我们的组件无依赖，但我们也希望从泰勒斯 - 而且包括类型的稳健性保证。我们包含使用ES模块写入的组件的类型键盘定义，以使Bundler能够轻松消耗。我们还确保使用我们的标准化配置确保有一个完整的测试套件和Linter设置。</p><p> An excellent example of a component that has gone through the open-source lifecycle is the  &lt;typing-effect&gt; element. A product engineering team within GitHub recently prototyped a terminal-inspired UI in which text appeared as if someone were typing it. In a previous project, we used the excellent and robust  typed.js for a typing animation, and the team initially reached for that library again.</p><p> 通过开源生命周期的组件的一个很好的例子是＆lt;键入效果＆gt;元素。 GitHub中的产品工程团队最近被原型设计了一个终端启发的UI，其中文本出现在某人键入它。在以前的项目中，我们使用了键入动画的优秀和强大的键入.js，并且该团队最初达到该库。</p><p> The parts of the UI that the team already built were lightweight, and our tooling identified that adding  typed.js to the page would increase the bundle size fivefold. The UI Systems team asked the product engineering team to consider other options. We found that the functionality we needed for this application was limited enough that it was worth trying to build it ourselves.</p><p> UI已经构建的UI的部分是轻量级的，我们的工具识别为页面添加键入的.js将增加捆绑尺寸五倍。 UI系统团队要求产品工程团队考虑其他选择。我们发现，我们为此申请所需的功能有限，以至于值得自己建立自己。</p><p> The product engineering team wrote the first version of our own typing animation for the new UI. Using Catalyst, it took less than a day and fewer than 40 lines of code. Realizing that other teams could use this effect, we decided to put it through the lifecycle steps. We refactored the component to have zero dependencies, “ejected” it out of the Catalyst library, and open-sourced the component as   &lt;typing-effect&gt;.</p><p> 产品工程团队为新UI写了我们自己键入动画的第一版。使用催化剂，花费不到一天，少于40行代码。意识到其他团队可以使用这种效果，我们决定将它通过生命周期步骤。我们将组件重构为具有零依赖性的组件，“将”它从催化剂文库中出来，并将组件开放为＆lt;键入效果。</p><p>  Overall, we’re thrilled with the changes that we’ve made to the GitHub front-end since our last post. According to the internal developer surveys that we’ve conducted, our developers are pleased with Catalyst and ViewComponent!</p><p>  总的来说，我们很激动我们的最后一篇文章以来我们向Github前端做出了兴奋。根据我们进行的内部开发人员调查，我们的开发人员对催化剂和景观感到满意！</p><p> Developers enjoy the encapsulation of ViewComponent, making it easier to test UI and increasing developer confidence. Developers feel Catalyst is a welcome change from “old-style” JavaScript without the massive leap to a different framework or paradigm.</p><p> 开发人员享受ViewComponent的封装，使测试UI更易于测试，并增加开发人员的信心。开发人员感到催化剂是从“旧式”JavaScript的欢迎变化，而无需巨大的框架或范例。 </p><p>  We’re continuing to open source more generic open-source behavioral Web Components under the name “GitHub Elements.” We have a collection of these elements on  https://github.com/github/github-elements, which syncs to  our page on webcomponents.org.</p><p>我们继续在名称“GitHub元素”下开源更广泛的开源行为Web组件。我们在https://github.com/github-中有一系列这些元素，它将在WebComponents.org上同步到我们的页面。</p><p> We’re excited about Web Components’ future and continue to monitor proposed changes to the HTML spec. The two proposals we are most excited about these days are the  Template Parts and  Declarative Shadow DOM proposals. These proposals would make it even easier for engineers to ship Web Components and would solve some common pain points that we have with the current state of Web Components.  We’ve implemented the minimum viable bits of Template Parts in a ponyfill, which is being used in production today, and we’re keen to see it gain traction from the broader community.</p><p> 我们对Web组件的未来感到兴奋，并继续监控提出的HTML规范的更改。我们最兴奋的两项建议是模板零件和陈述的影子DOM提案。这些提案将使工程师更容易运送Web组件，并且可以解决我们具有当前Web组件状态的常见疼痛点。我们在今天正在生产的Ponyfill中实施了最低可行的模板零件，我们热衷于看到它从更广泛的社区获得牵引力。</p><p>  Thanks to Keith Cirkel for kick-starting this post, Ben Scofield and Joel Hawksley for reviewing it, and Nick Holden for working with us to extract the  &lt;typing-effect&gt; element.</p><p>  感谢Keith Cirkel开始启动这篇文章，Ben Scofield和Joel Hawksley进行审查，并昵称霍尔登与我们一起使用以提取＆lt;打字效果＆gt;元素。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.blog/2021-05-04-how-we-use-web-components-at-github/">https://github.blog/2021-05-04-how-we-use-web-components-at-github/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/组件/">#组件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>