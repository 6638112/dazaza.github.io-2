<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>八卦传播 Gossip Dissemination</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Gossip Dissemination<br/>八卦传播 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-20 13:14:43</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/75a9cc1b6393d9a1e22cbfa337298e13.png"><img src="http://img2.diglog.com/img/2021/6/75a9cc1b6393d9a1e22cbfa337298e13.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Use random selection of nodes to pass on information to ensure it reaches all the nodes in the cluster without flooding the network</p><p>使用随机选择节点来传递信息，以确保它在不泛滥网络的情况下达到群集中的所有节点</p><p>  In a cluster of nodes, each node needs to pass metadata information it has, to all the other nodes in the cluster, without depending on a shared storage. In a large cluster, if all servers communicate with all the other servers, a lot of network bandwidth can be consumed. Information should reach all the nodes even when some network links are experiencing issues.</p><p>  在一组节点中，每个节点需要将元数据信息传递给群集中的所有其他节点，而无需取决于共享存储。在一个大群集中，如果所有服务器与所有其他服务器通信，则可以消耗大量的网络带宽。即使某些网络链接遇到问题，信息也应该达到所有节点。</p><p> Cluster nodes use gossip style communication to propagate state updates. Each node selects a random node to pass the information it has. This is done at a regular interval, say every 1 second. Each time, a random node is selected to pass on the information.</p><p> 群集节点使用Gossip样式通信来传播状态更新。每个节点选择一个随机节点来传递它的信息。这是经常间隔完成的，每1秒钟说。每次，选择随机节点以传递信息。</p><p>   The messages should not consume a lot of network bandwidth. There should be an upper bound of say a few hundred Kbs, making sure that the applications&#39; data transfer is not impacted by too many messages across the cluster.</p><p>   消息不应消耗大量的网络带宽。应该有几百kBs的上限，确保应用程序＆＃39;数据传输不会受到群集中过多的消息。</p><p> The metadata propagation should tolerate network and a few server failures. It should reach all the cluster nodes even if a few network links are down, or a few servers have failed.</p><p> 元数据传播应该容忍网络和一些服务器故障。即使少量网络链路已关闭，也应该达到所有群集节点，或者一些服务器失败。</p><p>  Each cluster nodes stores the metadata as a list of key value pairs associated with each node in the cluster as following:</p><p>  每个群集节点将元数据存储为与群集中的每个节点相关联的键值对列表：</p><p>     At startup, each cluster node adds the metadata about itself, which needs to be propagated to other nodes. An example of metadata can be the IP address and port the node listens on, the partitions it&#39;s responsible for, etc. The Gossip instance needs to know about at least one other node to start the gossip communication. The well known cluster node, which is used to initialize the Gossip instance is called as a seed node or an introducer. Any node can act as an introducer.</p><p>     在启动时，每个群集节点会添加关于自身的元数据，需要传播到其他节点。元数据的一个例子可以是节点侦听的IP地址和端口，＆＃39负责等。八卦实例需要了解至少一个其他节点以启动八字通信。众所周知的群集节点用于初始化八足实例称为种子节点或介绍者。任何节点都可以充当介绍者。 </p><p>  public Gossip(InetAddressAndPort listenAddress, List&lt;InetAddressAndPort&gt; seedNodes, String nodeId) throws IOException { this.listenAddress = listenAddress; //filter this node itself in case its part of the seed nodes this.seedNodes = removeSelfAddress(seedNodes); this.nodeId = new NodeId(nodeId);  addLocalState(GossipKeys.ADDRESS, listenAddress.toString()); this.socketServer = new NIOSocketListener(newGossipRequestConsumer(), listenAddress); } private void addLocalState(String key, String value) { NodeState nodeState = clusterMetadata.get(listenAddress); if (nodeState == null) { nodeState = new NodeState(); clusterMetadata.put(nodeId, nodeState); } nodeState.add(key, new VersionedValue(value, incremenetVersion())); }</p><p>public gossip（inetaddressandport listendaddress，list＆lt; inetaddressandport＆gt; seednodes，string nodeid）抛出ioException {this.listenaddress = listenaddress; //在其Seed节点的一部分中筛选此节点本身.SeedNodes = RemoveSfaddress（Seednodes）; this.nodeId = new nodeid（nodeid）; addlocalstate（gossipkeys.address，listendaddress.tostring（））; this..socketserver = new nioscoptlistener（newgossiprequestconsumer（），lisisidaddress）;私有void addLocalstate（String键，字符串值）{nodestate nodeState = clustermetadata.get（listenaddress）; if（nodestate == null）{nodestate = new nodestate（）; clustermetadata.put（nodeid，nodestate）; nodeState.Add（key，new serveoryedvalue（值，IncremenetVersion（）））; }</p><p> Each cluster node schedules a job to transmit the metadata it has to other nodes at regular intervals.</p><p> 每个群集节点调度作业以定期将其传输到其他节点的元数据。</p><p>  private ScheduledThreadPoolExecutor gossipExecutor = new ScheduledThreadPoolExecutor(1); private long gossipIntervalMs = 1000; private ScheduledFuture&lt;?&gt; taskFuture; public void start() { socketServer.start(); taskFuture = gossipExecutor.scheduleAtFixedRate(()-&gt; doGossip(), gossipIntervalMs, gossipIntervalMs, TimeUnit.MILLISECONDS); }</p><p>  Private ScheduledThreadPoolExecutor Gossipexecutor =新的ScheduledThreadPoolExecutor（1）;私人长gossipintervalms = 1000;私人调度＆lt;？＆gt;任务费; public void start（）{socketserver.start（）;任务文件= gossipexecutor.scheduleatfixedrate（（） - ＆gt; dogossip（），gossipintervalms，gossipintervalms，timeunit.milliseconds）; }</p><p> When the scheduled task is invoked, it picks up a small set of random nodes from the list of servers from the metadata map. A small constant number, defined as Gossip fanout, determines how many nodes to pick up as gossip targets. If nothing is known yet, it picks up a random seed node and sends the metadata map it has to that node.</p><p> 调用计划任务时，它会从元数据映射的服务器列表中拾取一小组随机节点。定义为Gossip Fanout的小常量数，确定要作为八卦目标拾取的节点。如果已知任何内容，它会拾取一个随机种子节点，并将其发送到该节点的元数据映射。</p><p>  public void doGossip() { List&lt;InetAddressAndPort&gt; knownClusterNodes = liveNodes(); if (knownClusterNodes.isEmpty()) { sendGossip(seedNodes, gossipFanout); } else { sendGossip(knownClusterNodes, gossipFanout); } } private List&lt;InetAddressAndPort&gt; liveNodes() { Set&lt;InetAddressAndPort&gt; nodes = clusterMetadata.values() .stream() .map(n -&gt; InetAddressAndPort.parse(n.get(GossipKeys.ADDRESS).getValue())) .collect(Collectors.toSet()); return removeSelfAddress(nodes); }</p><p>  public void dogossip（）{list＆lt; inetaddressandport＆gt; nextedclusternodes = liveodes（）; if（nexinnclusterternode.isusptey（））{sendgossip（Seednodes，Gossipfanout）; } else {sendgossip（joadingclusternodes，gossipfanout）;私人列表＆lt; inetaddressandport＆gt; liveodes（）{set＆lt; inetaddressandport＆gt; nodes = clustermetadata.values（）.stream（）.map（n  - ＆gt; inetaddressandport.parse（n.get（gossipkeys.address）.getvalue（）））.collect（collectors.toset（））; return removeselfaddress（节点）; }</p><p>  private void sendGossip(List&lt;InetAddressAndPort&gt; knownClusterNodes, int gossipFanout) { if (knownClusterNodes.isEmpty()) { return; } for (int i = 0; i &lt; gossipFanout; i++) {  InetAddressAndPort nodeAddress = pickRandomNode(knownClusterNodes); sendGossipTo(nodeAddress); }}private void sendGossipTo(InetAddressAndPort nodeAddress) { try { getLogger().info(&#34;Sending gossip state to &#34; + nodeAddress); SocketClient&lt;RequestOrResponse&gt; socketClient = new SocketClient(nodeAddress); GossipStateMessage gossipStateMessage = new GossipStateMessage(this.clusterMetadata); RequestOrResponse request = createGossipStateRequest(gossipStateMessage); byte[] responseBytes = socketClient.blockingSend(request); GossipStateMessage responseState = deserialize(responseBytes); merge(responseState.getNodeStates()); } catch (IOException e) { getLogger().error(&#34;IO error while sending gossip state to &#34; + nodeAddress, e); }}private RequestOrResponse createGossipStateRequest(GossipStateMessage gossipStateMessage) { return new RequestOrResponse(RequestId.PushPullGossipState.getId(), JsonSerDes.serialize(gossipStateMessage), correlationId++);}</p><p>  私有void sendgossip（list＆lt; inetaddressandport＆gt; nearyClUsternodes，int gossipfanout）{if（nextedClusterternode.Isempty（））{return; for（int i = 0; i＆lt; gossipfanout; i ++）{inetaddressandport nodeaddress = pickrandomnode（nearyClusternodes）; sendgossipto（nodeaddress）;私有void sendgossipto（inetaddressandport nodeaddress）{try {getlogger（）。信息（＆＃34;向＆＃34发送八卦状态）; socketClient＆lt; RequestorResponse＆gt; socketClient =新的侧面（Nodeaddress）; gossipstatemessage gossipstatemessage = new gossipstatemessage（this.clustermetadata）; RequestorResponse Request = creategossipstateRequest（gossipstatemessage）; byte [] responseBytes = socketClient.Blocksend（请求）; gossipstatemessage rendalestate = deserialize（responseBytes）;合并（ReplaceState.getNodeStates（））; catch（ioException e）{getlogger（）。错误（＆＃34; io错误，同时将八卦状态发送到＆＃34; + nodeaddress，e）; Private RequestorResponse CreateGossipstateRequest（GossipStateMessage GossipStateMessage）{return new RequestorResponse（requestId.pushpullgossipstate.getId（），jsonserdes.serialize（gossipstatemessage），correlitationId ++）;}</p><p> The cluster node receiving the gossip message inspects the metadata it has and finds three things.</p><p> 接收GOSSIP消息的群集节点检查它拥有的元数据并找到三件事。 </p><p> The values which are in the incoming message but not available in this node&#39;s state map</p><p>在此节点中的传入消息中的值＆＃39; s状态图</p><p>  The higher version value is chosen when the node has the values present in the incoming message</p><p>  当节点具有输入消息中存在的值时，选择更高版本值</p><p> It then adds the missing values to its own state map. Whatever values were missing from the incoming message, are returned as a response.</p><p> 然后它将缺失值添加到自己的状态映射。无论从传入消息中缺少什么值，都将作为响应返回。</p><p> The cluster node sending the Gossip message adds the values it gets from the gossip response to its own state.</p><p> 发送Gossip消息的群集节点会添加其从八卦响应到自己状态的值。</p><p>  private void handleGossipRequest(org.distrib.patterns.common.Message&lt;RequestOrResponse&gt; request) { GossipStateMessage gossipStateMessage = deserialize(request.getRequest()); Map&lt;NodeId, NodeState&gt; gossipedState = gossipStateMessage.getNodeStates(); getLogger().info(&#34;Merging state from &#34; + request.getClientSocket()); merge(gossipedState); Map&lt;NodeId, NodeState&gt; diff = delta(this.clusterMetadata, gossipedState); GossipStateMessage diffResponse = new GossipStateMessage(diff); getLogger().info(&#34;Sending diff response &#34; + diff); request.getClientSocket().write(new RequestOrResponse(RequestId.PushPullGossipState.getId(), JsonSerDes.serialize(diffResponse), request.getRequest().getCorrelationId())); }</p><p>  私有void handlegossiprequest（org.distrib.patterns.common.message＆lt; RequestorResponse＆gt;请求）{gossipstatemessage gossipstatemessage = deserialize（request.getrequest（））;地图＆lt; nodeid，nodestate＆gt; gossipedstate = gossipstatemessage.getnodeStates（）; getLogger（）。信息（＆＃34;来自＆＃34的合并状态; + Request.getClientsocket（））;合并（八卦斯特泰特）;地图＆lt; nodeid，nodestate＆gt; diff = delta（this.clustermetadata，gossedstate）; gossipstatemessage diffresponse = new gossipstatemessage（diff）; getlogger（）。信息（＆＃34;发送差异响应＆＃34; +差异）; Request.getClientsocket（）。写（new RequestorResponse（requestId.pushpullgossipstate.getId（），jsonserdes.serialize（diffresponse），Request.getRequest（）。getcorrelationId（）））; }</p><p> public Map&lt;NodeId, NodeState&gt; delta(Map&lt;NodeId, NodeState&gt; fromMap, Map&lt;NodeId, NodeState&gt; toMap) { Map&lt;NodeId, NodeState&gt; delta = new HashMap&lt;&gt;(); for (NodeId key : fromMap.keySet()) { if (!toMap.containsKey(key)) { delta.put(key, fromMap.get(key)); continue; } NodeState fromStates = fromMap.get(key); NodeState toStates = toMap.get(key); NodeState diffStates = fromStates.diff(toStates); if (!diffStates.isEmpty()) { delta.put(key, diffStates); } } return delta;}</p><p> 公共图＆lt; nodeid，nodestate＆gt; delta（map＆lt; nodeid，nodestate＆gt; frommap，map＆lt; nodeid，nodestate＆gt; tomap）{map＆lt; nodeid，nodestate＆gt; delta = new hashmap＆lt;（）; for（nodeid密钥：frommap.keyset（））{if（！tomap.containskey（key））{delta.put（key，frommap.get（key））;继续;从states = frommap.get（key）; nodestate tostates = tomap.get（key）; nodestate差异= fromstates.diff（tostates）; if（！diffstates.isusemaly（））{delta.put（key，差错）; }}返回delta;}</p><p> public void merge(Map&lt;NodeId, NodeState&gt; otherState) { Map&lt;NodeId, NodeState&gt; diff = delta(otherState, this.clusterMetadata); for (NodeId diffKey : diff.keySet()) { if(!this.clusterMetadata.containsKey(diffKey)) { this.clusterMetadata.put(diffKey, diff.get(diffKey)); } else { NodeState stateMap = this.clusterMetadata.get(diffKey); stateMap.putAll(diff.get(diffKey)); } }}</p><p> 公共void合并（Map＆lt; nodeid，nodestate＆gt; Otherstate）{map＆lt; nodeid，nodestate＆gt; diff = delta（Otherstate，this.clustermetadata）; for（nodeid diffkey：diff.keyset（））{if（！thice.clustermetadata.containskey（diffkey））{this.clustermetadata.put（diffkey，diff.get（diffey））; } else {nodestate statemap = this.clustermetadata.get（diffkey）; statemap.putlal（diff.get（diffkey））; }}} </p><p> This process happens every one second at each cluster node, each time selecting a different node to exchange the state.</p><p>每个群集节点在每个群集节点处每隔一秒一次发生此过程，每次选择不同的节点以交换状态。</p><p> The above code example shows that the complete state of the node is sent in the Gossip message. This is fine for a newly joined node, but once the state is up to date, it&#39;s unnecessary to send the complete state. The cluster node just needs to send the state changes since the last gossip. For achieving this, each node maintains a version number which is incremented every time a new metadata entry is added locally.</p><p> 上面的代码示例显示了节点的完整状态在GOSSIP消息中发送。这对新加入的节点很好，但是一旦状态是最新的，它就不必发送了完整状态。群集节点只需要自上次八卦以来发送状态更改。为了实现这一目标，每个节点都维护每次在本地添加新的元数据条目时递增的版本号。</p><p>   Each value in the cluster metadata is maintained with a version number. This is an example of pattern  Versioned Value.</p><p>   群集元数据中的每个值都以版本号维护。这是模式版本为值的示例。</p><p>  int version; String value; public VersionedValue(String value, int version) { this.version = version; this.value = value; } public int getVersion() { return version; } public String getValue() { return value; }</p><p>  int版本;字符串值; public supmentedValue（String值，int版）{this.version =版本; this.value = value; public int getversion（）{返回版本; public string getValue（）{返回值; }</p><p>   private void sendKnownVersions(InetAddressAndPort gossipTo) throws IOException { Map&lt;NodeId, Integer&gt; maxKnownNodeVersions = getMaxKnownNodeVersions(); RequestOrResponse knownVersionRequest = new RequestOrResponse(RequestId.GossipVersions.getId(), JsonSerDes.serialize(new GossipStateVersions(maxKnownNodeVersions)), 0); SocketClient&lt;RequestOrResponse&gt; socketClient = new SocketClient(gossipTo); byte[] knownVersionResponseBytes = socketClient.blockingSend(knownVersionRequest); } private Map&lt;NodeId, Integer&gt; getMaxKnownNodeVersions() { return clusterMetadata.entrySet() .stream() .collect(Collectors.toMap(e -&gt; e.getKey(), e -&gt; e.getValue().maxVersion())); }</p><p>   私有void sendknversions（inetaddressandport gossipto）抛出IoException {Map＆lt; nodeId，Integer＆gt; maxknnownnodeversions = getmaxknownnodeversions（）; RequestorResponse mepardversionRequest = new RequestorResponse（requestId.gossipversions.getId（），jsonserdes.serialize（新的gossipstateversions（maxknownnodeversionsions），0）; socketClient＆lt; RequestorResponse＆gt; socketClient =新侧面套接字（Gossipto）; byte [] hypernversionResponseBytes = SocketClient.BlockingsEnd（ketapversversionRequest）;私人地图＆lt; nodeid，整数＆gt; getmaxknnodeversions（）{return clustermetadata.entryset（）.stream（）.collect（collectors.tomap（e-＆gt; e.getkey（），e-＆gt; e.getvalue（）。maxversion（））; }</p><p>   The receiving node can then send the values only if the versions are greater than the ones in the request.</p><p>   然后，当版本大于请求中的版本时，接收节点只能发送值。</p><p>  Map&lt;NodeId, NodeState&gt; getMissingAndNodeStatesHigherThan(Map&lt;NodeId, Integer&gt; nodeMaxVersions) { Map&lt;NodeId, NodeState&gt; delta = new HashMap&lt;&gt;(); delta.putAll(higherVersionedNodeStates(nodeMaxVersions)); delta.putAll(missingNodeStates(nodeMaxVersions)); return delta; } private Map&lt;NodeId, NodeState&gt; missingNodeStates(Map&lt;NodeId, Integer&gt; nodeMaxVersions) { Map&lt;NodeId, NodeState&gt; delta = new HashMap&lt;&gt;(); List&lt;NodeId&gt; missingKeys = clusterMetadata.keySet().stream().filter(key -&gt; !nodeMaxVersions.containsKey(key)).collect(Collectors.toList()); for (NodeId missingKey : missingKeys) { delta.put(missingKey, clusterMetadata.get(missingKey)); } return delta; } private Map&lt;NodeId, NodeState&gt; higherVersionedNodeStates(Map&lt;NodeId, Integer&gt; nodeMaxVersions) { Map&lt;NodeId, NodeState&gt; delta = new HashMap&lt;&gt;(); Set&lt;NodeId&gt; keySet = nodeMaxVersions.keySet(); for (NodeId node : keySet) { Integer maxVersion = nodeMaxVersions.get(node); NodeState nodeState = clusterMetadata.get(node); if (nodeState == null) { continue; } NodeState deltaState = nodeState.statesGreaterThan(maxVersion); if (!deltaState.isEmpty()) { delta.put(node, deltaState); } } return delta; }</p><p>  地图＆lt; nodeid，nodestate＆gt; getmissingandnodestateshigherthan（map＆lt; nodeid，整数＆gt; nodemaxversions）{map＆lt; nodeid，nodestate＆gt; delta = new hashmap＆lt;（）; delta.cputall（legervacessednodeStates（nodemaxversions））; delta.putlal（漏洞（nodemaxversions））;返回三角洲;私人地图＆lt; nodeid，nodestate＆gt;漏洞（Map＆lt; nodeid，整数＆gt; nodemaxversions）{map＆lt; nodeid，nodestate＆gt; delta = new hashmap＆lt;（）;列表＆lt; nodeid＆gt; missingkeys = clustermetadata.keyset（）。stream（）。过滤器（key  - ＆gt;！nodemaxversions.containskey（key））。收集（收集器.Tolist（））; for（nodeid missingkey：missingkyys）{delta.put（lisskey，clustermetadata.get（忘掉））; }返回三角洲;私人地图＆lt; nodeid，nodestate＆gt;高reserversedNodeStates（Map＆lt; nodeid，整数＆gt; nodemaxversions）{map＆lt; nodeid，nodestate＆gt; delta = new hashmap＆lt;（）;设置＆lt; nodeid＆gt; keyset = nodemaxversions.keyset（）; for（nodeId节点：keyset）{整数maxversion = nodemaxversions.get（节点）; nodestate nodestate = clustermetadata.get（节点）; if（nodestate == null）{继续; nodestate deltastate = nodestate.statesgreaterthan（maxversion）; if（！deltastate.isusemal（））{delta.put（node，deltastate）; }}返回delta; } </p><p> Gossip implementation in  [cassandra] optimizes state exchange with a three-way handshake, where the node receiving the gossip message also sends the versions it needs from the sender, along with the metadata it returns. The sender can then immediately respond with the requested metadata. This avoids an extra message that otherwise would have been required.</p><p>Gossip在[Cassandra]中的实现优化了一种用三方握手优化状态交换，其中接收Gossip消息的节点也将从发件人提供所需的版本以及它返回的元数据。然后，发件人可以立即使用所请求的元数据响应。这避免了额外的消息，否则是必需的。</p><p> Gossip protocol used in  [cockroachdb] maintains state for each connected node. For each connection, it maintains the last version sent to that node, and the version received from that node. This is so that it can send &#39;state since the last sent version&#39; and ask for &#39;state from the last received version&#39;.</p><p> [蟑螂]中使用的八卦协议为每个连接的节点维护状态。对于每个连接，它将发送到该节点的最后一个版本，并从该节点接收的版本。这是可以发送＆＃39;自上次发送的版本以来的状态。并询问＆＃39;来自上次收到的版本和＃39的状态;</p><p> Some other efficient alternatives can be used as well, sending a hash of the entire Map and if the hash is the same, then doing nothing.</p><p> 也可以使用一些其他有效的替代方案，发送整个地图的哈希，如果哈希相同，则无效。</p><p> Cluster nodes randomly select the node to send the Gossip message. An example implementation in Java can use java.util.Random as following:</p><p> 群集节点随机选择要发送八卦消息的节点。 Java中的示例实现可以使用java.util.random如下：</p><p>  private Random random = new Random(); private InetAddressAndPort pickRandomNode(List&lt;InetAddressAndPort&gt; knownClusterNodes) { int randomNodeIndex = random.nextInt(knownClusterNodes.size()); InetAddressAndPort gossipTo = knownClusterNodes.get(randomNodeIndex); return gossipTo; }</p><p>  私有随机= new random（）;私有inetaddressandport pickrandomnode（list＆lt; inetaddressandport＆gt; nearyClusternodes）{intrandnnodeindex = wandom.nextint（nexindclusternodes.size（））; inetaddressandport gossipto = nugindclusterternode.get（randomnodeindex）;返回gossipto; }</p><p> There can be other considerations such as the node that is least contacted with. For example, Gossip protocol in  Cockroachdb selects nodes this way.</p><p> 可以存在其他考虑因素，例如最少联系的节点。例如，蟑螂中的八卦协议以这种方式选择节点。</p><p> Maintaining the list of available nodes in the cluster is one of the most common usage of Gossip protocols. There are two approaches in use.</p><p> 维护群集中的可用节点列表是Gossip协议最常见的使用之一。使用两种方法。 </p><p> [swim-gossip] uses a separate probing component which continuously probes different nodes in the cluster to detect if they are available. If it detects that the node is alive or dead, that result is propagated to the entire cluster with Gossip communication. The prober randomly selects a node to send the Gossip message. If the receiving node detects that this is new information, it immediately sends the message to a randomly selected node. This way, the failure of a node or newly joined node in the cluster is quickly known to the entire cluster.</p><p>[Swim-Gossip]使用一个单独的探测组件，该组件在群集中连续探测群集中的不同节点以检测它们是否可用。如果检测到节点是活着的或死亡，则该结果与八卦通信传播到整个群集。探测器随机选择一个节点以发送八卦消息。如果接收节点检测到这是新信息，则会立即将消息发送到随机选择的节点。这样，整个群集将在群集中快速已知群集中的节点或新连接的节点的故障。</p><p> The cluster node can periodically update its own state to reflect its heartbeat. This state is then propagated to the entire cluster through the gossip messages exchanged. Each cluster node can then check if it has received any update for a particular cluster node in a fixed amount of time or else mark that node as down. In this case, each cluster node independently determines if a node is up or down.</p><p> 群集节点可以定期更新自己的状态以反映其心跳。然后通过交换的八字消息传播到整个群集。然后，每个群集节点可以检查它是否已在固定的时间内接收到特定群集节点的任何更新，或者将节点的标记为下降。在这种情况下，每个群集节点独立地确定节点是否上或向下。</p><p> The versioned values does not work well if the node crashes or restarts, as all the in-memory state is lost. More importantly, the node can have different values for the same key. For example, the cluster node can start with a different IP address and port, or can start with a different configuration.  Generation Clock can be used to mark generation with every value, so that when the metadata state is sent to a random cluster node, the receiving node can detect changes not just by the version number, but also with the generation.</p><p> 如果节点崩溃或重新启动，则版本后的值不起作用，因为所有内存状态都丢失。更重要的是，节点可以对相同键具有不同的值。例如，群集节点可以以不同的IP地址和端口启动，或者可以以不同的配置开始。生成时钟可用于标记每个值的生成，从而当元数据状态被发送到随机簇节点时，接收节点可以检测不仅仅是由版本号的变化，还可以与生成一起检测。</p><p> It is useful to note that this mechanism is not necessary for the core Gossip protocol to work. But it&#39;s implemented in practice to make sure that the state changes are tracked correctly.</p><p> 值得注意的是，这种机制不是必需的核心八卦协议工作。但它在实践中实施了它＆＃39，以确保正确跟踪状态更改。</p><p> [cassandra] uses Gossip protocol for the group membership and failure detection of cluster nodes. Metadata for each cluster node such as the tokens assigned to each cluster node, is also transmitted using Gossip protocol.</p><p> [Cassandra]使用Gossip协议进行组成员身份和群集节点的故障检测。还使用GOSSIP协议发送诸如分配给每个群集节点的令牌的每个群集节点的元数据。</p><p>   Blockchain implementations such as  Hyperledger Fabric use Gossip protocol for group membership and sending ledger metadata.</p><p>   BlockChain实现，如Hyperlowger Fabric，使用Gossip协议进行组成员身份和发送分类帐元数据。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://martinfowler.com/articles/patterns-of-distributed-systems/gossip-dissemination.html">https://martinfowler.com/articles/patterns-of-distributed-systems/gossip-dissemination.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/八卦/">#八卦</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gossip/">#gossip</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/节点/">#节点</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>