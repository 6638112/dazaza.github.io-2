<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>联合Linux随机数设备Uniting the Linux random-number devices</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Uniting the Linux random-number devices<br/>联合Linux随机数设备</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-18 23:18:18</div><div class="page_narrow text-break page_content"><p>The following subscription-only content has been made available to you by an LWN subscriber. Thousands of subscribers depend on LWN for the best news from the Linux and free software communities. If you enjoy this article, please consider  subscribing to LWN. Thank youfor visiting LWN.net!</p><p>LWN订户已向您提供以下仅限订阅的内容。成千上万的订阅者依靠LWN从Linux和自由软件社区获得最好的消息。如果您喜欢这篇文章，请考虑订阅LWN。感谢您访问LWN。网</p><p> Blocking in the kernel&#39;s random-number generator (RNG)—causing a process towait for &#34;enough&#34;entropy to generate strong random numbers—has always been controversial. It has also led tovarious kinds of problems over the years, from timeouts and delays causedby misuse in user-spaceprograms to deadlocks and other problems in the bootprocess. That behavior has undergone a number of changes over the last fewyears and it looks possible that the last vestige of the difference betweenmerely &#34;good&#34; and &#34;cryptographic-strength&#34; random numbers may go away in someupcoming kernel version.</p><p>内核中的阻塞&#39；s随机数生成器（RNG）-导致进程等待&#34；够了&#34；熵产生强随机数一直是有争议的。多年来，它还导致了各种各样的问题，从用户空间程序中的误用导致的超时和延迟，到引导过程中的死锁和其他问题。在过去的几年里，这种行为已经发生了很多变化，而且看起来很有可能，依赖和#34；好&#34；和&#34；密码强度&#34；在即将到来的内核版本中，随机数可能会消失。</p><p>  The history of the kernel RNG is long and somewhat twisty; there are tworandom-number devices in the kernel,  /dev/random and  /dev/urandom, that can be read in order to obtain the randomdata.  /dev/urandom was always meant as the device for nearlyeverything to use, as it does not block; it simply provides the best randomnumbers that the kernel can provideat the time it is read. /dev/random, on the other hand, blocks whenever it does not have sufficient entropy to provide cryptographic-strength randomnumbers. That entropy comes fromsources like interrupt timing for various kinds of devices (e.g. disk,keyboard, network) and hardware RNGs if they are available.  /dev/urandom will log a warning message (once) if it is called before itspool is initialized (from the  random pool once it has beeninitialized using gathered entropy), but it will provide output from its pseudorandom-number generator (PRNG) and never block.</p><p>内核RNG的历史很长，有些曲折；内核中有两个随机数设备，/dev/random和/dev/urandom，可以读取它们以获取随机数据/dev/Uradom一直被认为是几乎所有东西都可以使用的设备，因为它不会阻塞；它只是提供了内核在读取时能够提供的最佳随机数/另一方面，当dev/random没有足够的熵来提供密码强度时，它就会阻塞。这种熵来自各种设备（如磁盘、键盘、网络）的中断时间和硬件RNG（如果可用）/dev/Uradom将记录一条警告消息（一次），如果在初始化其池之前调用它（一旦使用收集的熵初始化了随机池），但它将提供其伪随机数生成器（PRNG）的输出，并且从不阻塞。</p><p> In 2014, for Linux 3.17, the   getrandom()system call was added  to provide a reliableway for user-space applications to request random numbers even in the face of file-descriptor exhaustion orlack of access to the random devices (as might happen for an applicationrunning in a container). getrandom() was designed to use the  urandom  pool, butonly after it has been fully initialized from the  random pool.So, while reads to  /dev/urandom do not block, calls to getrandom() would until the requisite entropy is gathered. getrandom() callers can choose to use the  random pool via a flag, which makesthe call subject to the full entropy requirements for data coming from that pool.</p><p>2014年，对于Linux 3.17，添加了getrandom（）系统调用，为用户空间应用程序提供了一种可靠的方式，即使在文件描述符耗尽或无法访问随机设备的情况下，也可以请求随机数（对于在容器中运行的应用程序可能会发生这种情况）。getrandom（）旨在使用Uradom池，但只有在从随机池完全初始化之后。因此，虽然对/dev/uradom的读取不会被阻塞，但对getrandom（）的调用会被阻塞，直到收集到所需的熵。getrandom（）调用者可以通过一个标志选择使用随机池，这使得调用受制于来自该池的数据的完整熵要求。</p><p> In 2019, an unrelated change to the ext4 filesystem  led to systems that would not boot because itreduced the number of interrupts being generated, so the  urandompool did not get initialized and calls to  getrandom() blocked.Since those calls were made early in the boot process, the system nevercame up to a point where enough entropy could be gathered, because the bootprocess was waiting for  getrandom() to return—thus a deadlockresulted. The ext4 change was temporarily reverted for the 5.3 kernel and a  more permanent solution was added by LinusTorvalds for 5.4. It used  CPU execution time jitter as a source ofentropy to ensure that the  random pool initialized within asecond or so. That technique is somewhat controversial, even Torvalds issomewhat skeptical of it, but it has been in place, and working as far asanyone can tell, for several years now.</p><p>2019年，对ext4文件系统的一次不相关的更改导致系统无法启动，因为它减少了生成的中断次数，因此urandompool没有初始化，对getrandom（）的调用被阻止。由于这些调用是在引导过程的早期进行的，因此系统无法达到可以收集足够熵的程度，因为引导过程正在等待getrandom（）返回，从而导致死锁。5.3内核暂时恢复了ext4更改，LinusTorvalds为5.4添加了一个更持久的解决方案。它使用CPU执行时间抖动作为熵源，以确保随机池在大约一秒钟内初始化。这项技术有点争议，甚至托瓦尔兹也对此持怀疑态度，但它已经存在了好几年，而且一直在尽可能地发挥作用。</p><p> In 2020, the blocking nature of  /dev/random was  changed to behave like  getrandom(),in that it would only block until it is initialized, once, and then would provide cryptographic-strength random numbers thereafter. Andy Lutomirski, whocontributed the patches for that change, said: &#34; Linux&#39;s CRNGgenerates output that is good enough to use even for key generation. Theblocking pool is not stronger in any material way, and keeping it aroundrequires a lot of infrastructure of dubious value.&#34; Those patchesalso added a  GRND_INSECURE flag for  getrandom() thatwould return &#34;best effort&#34; random numbers even if the pool was not yetinitialized.</p><p>2020年，/dev/random的阻塞性质被更改为与getrandom（）类似，因为它只会在初始化之前阻塞一次，然后提供加密强度随机数。安迪·卢托米尔斯基（Andy Lutomirski）为这一变化提供了补丁，他说：&#34；Linux&#39；CRNGS生成的输出足以用于密钥生成。阻塞池在任何物质方面都不强大，保持它的存在需要大量价值可疑的基础设施&#34; 这些补丁还为getrandom（）添加了一个GRND#u unsecure标志，该标志将返回&#34；尽力而为&#34；随机数，即使池没有被细化。</p><p> As can be seen, the lines between the two devices have become ratherblurrier over time. More of the history of the kernel RNG, going evenfurther back in time, can be found inthis  LWN kernel indexentry. Given that the two devices have grown together, it is perhapsno surprise that a new proposal, to effectively eliminate the distinction,has been raised.</p><p>可以看出，随着时间的推移，两台设备之间的线路变得越来越模糊。更多关于内核RNG的历史，甚至可以追溯到更远的时间，可以在LWN内核索引中找到。考虑到这两种设备已经发展到一起，一个有效消除这种差异的新提议被提出或许并不令人惊讶。</p><p>  Jason A. Donenfeld, who  stepped upas a co-maintainer of the kernel&#39;s RNG subsystem a few months back, hasbeen rather active in doing cleanups and making other changes to that codeof late. On February 11, he  postedan RFC—perhaps a &#34; request forgrumbles&#34; in truth—patch proposing the removal of the ability for /dev/urandom to return data before the pool is initialized. It would mean thatthe kernel RNG subsystem would always block waiting to initialize, but always returncryptographic-strength random numbers thereafter (unless the GRND_INSECURE flag to  getrandom() is used). Because ofthe changes made by Torvalds in 5.4, which Donenfeld calls the &#34; Linus JitterDance&#34;, the maximum wait for initialization is minimal, so Donenfeldsuggested the change: So, given that the kernel has grown this mechanism for seeding itselffrom nothing, and that this procedure happens pretty fast, maybe there&#39;sno point any longer in having /dev/urandom give insecure bytes. In thepast we didn&#39;t want the boot process to deadlock, which wasunderstandable. But now, in the worst case, a second goes by, and theproblem is resolved. It seems like maybe we&#39;re finally at a point whenwe can get rid of the infamous &#34;urandom read hole&#34;.</p><p>Jason A.Donenfeld，作为内核的共同维护者&#39；几个月前，s RNG子系统在最近的清理工作中相当活跃，并对代码进行了其他更改。2月11日，他发布了RFC，可能是a&#34；请求赔偿损失&#34；实际上，补丁建议在池初始化之前删除/dev/uradom返回数据的功能。这意味着内核RNG子系统将始终阻塞等待初始化，但此后始终返回加密强度随机数（除非使用getrandom（）的GRND_unsecure标志）。因为Torvalds在5.4中所做的修改，Donenfeld称之为&#34；莱纳斯吉特舞&#34；，初始化的最大等待时间是最小的，因此Donenfeld建议进行更改：因此，考虑到内核从无到有地发展了这种播种机制，并且这个过程发生得非常快，可能有#39；不再需要/dev/uradom提供不安全的字节。过去我们没有&#39；我不希望启动过程死锁，这是可以理解的。但现在，在最坏的情况下，一秒钟过去了，问题就解决了。似乎我们&#39；我们终于可以摆脱臭名昭著的&#34；Uradom read hole&#34；。</p><p> There are some potential hurdles to doing so, however. The jitter entropytechnique relies on differences in timing when running the same code, whichrequires both a high-resolution CPU cycle counter and a CPU that appears to benondeterministic (due to caching, instruction reordering, speculation, andso on). There are some architectures that do not provide that, however, sono entropy can be gathered that way. Donenfeld noted that non-Amiga m68ksystems, two MIPS models (R6000 and R6000A), and, possibly, RISC-V would beaffected; he wondered if there were other similarly affected architectures out there.He believes that the RISC-V code is not truly a problem, however, and no onehas yet spoken up to dispute that.Meanwhile, setting those others aside might be the right approach: If my general analysis is correct, are these ancient platforms reallyworth holding this back? I halfway expect to receive a few throwntomatoes, an angry fist, and a &#34;get off my lawn!&#34;, and if that&#39;s _all_ Ihear, I&#39;ll take a hint and we can forget I ever proposed this. Asmentioned, I do not intend to merge this unless there&#39;s broad consensusabout it. But on the off chance that people feel differently, perhapsthe Linus Jitter Dance is finally the solution to years of /dev/urandomkvetching.</p><p>然而，要做到这一点，还有一些潜在的障碍。抖动entropytechnique依赖于运行同一代码时的时间差异，这需要一个高分辨率的CPU周期计数器和一个看起来不确定的CPU（由于缓存、指令重新排序、推测等）。但是，有些体系结构并没有提供这样的功能，可以通过这种方式收集声熵。Donenfeld指出，非Amiga M68K系统、两种MIPS型号（R6000和R6000A）以及RISC-V可能会受到影响；他想知道是否还有其他受到类似影响的建筑。然而，他认为RISC-V代码并不是一个真正的问题，目前还没有人对此提出异议。同时，把其他平台放在一边可能是正确的方法：如果我的总体分析是正确的，那么这些古老的平台真的值得保留吗？我有一半希望收到一些西红柿，一个愤怒的拳头和一个&#34；离开我的草坪&#34;, 如果是&#39；s_all_Ihear，我&#39；我给你一个暗示，我们可以忘记我曾经提出过这个建议。如上所述，我不打算合并，除非有&#39；这是一个广泛的共识。但是，人们可能会有不同的感觉，也许莱纳斯抖动舞最终是解决多年来/dev/uradomkvetch问题的方法。</p><p> The proposed patch was fairly small; it simply eliminated the file_operations struct for  /dev/urandom and reused theone for  /dev/random in its place, thus making the two devicesbehave identically. It also shorted out thebehavior of the  GRND_INSECURE flag, but he later  saidthat was something of a distraction. The main intent of his proposal wasto do the following:</p><p>提议的补丁相当小；它只是删除了/dev/uradom的文件操作结构，并在其位置重用了/dev/random的一个，从而使这两个设备的行为相同。这也缩短了GRND_不安全旗的行为，但他后来说这有点分散注意力。他的提议的主要目的是：</p><p> Torvalds had a  positiveresponseto the RFC. He said that the patch makes sense for architectures that havea cycle counter; the jitter entropy change has been active fortwo-and-a-half years without much complaint, so &#34; I think we can callthat thing a success&#34;. There may have been a few complaints about it,but: &#34; Honestly, I think all the complaints would have been from thetheoretical posers that don&#39;t have any practical suggestionsanyway&#34;. Torvalds is known to have little patience for  theoretical concerns about cryptography (ortheoretical concerns about anything else, in truth).</p><p>托瓦尔兹对RFC有积极的反应。他说，这个补丁对于有循环计数器的架构是有意义的；抖动熵变已经活跃了两年半，没有多少抱怨，因此&#34；我认为我们可以称之为成功；。对此可能有一些抱怨，但：&#34；老实说，我认为所有的抱怨都来自那些不&#39；无论如何，我没有任何实际的建议；。众所周知，托瓦尔兹对密码学的理论担忧（事实上，对其他任何事情的理论担忧）几乎没有耐心。</p><p> He did object to removing  GRND_INSECURE for architectures thatcannot do the jitter dance, since it is a way for user space to work aroundthe lack of boot-time entropy, even if it is not at all secure: Those systems are arguably broken from a randomness standpoint - whatthe h*ll are you supposed to do if there&#39;s nothing generating entropy- but broken or not, I suspect they still exists. Those horrendousMIPS things were quite common in embedded networking (routers, accesspoints - places that *should* care) [...] And almost nobody tests those broken platforms: even people who buildnew kernels for those embedded networking things probably end up usingsaid kernels with an existing user space setup - where people havesome existing saved source of pseudo-entropy. So they might not evereven trigger the &#34;first boot problem&#34; that tends to be the worst case.</p><p>他确实反对为那些不能跳抖动舞的架构移除不安全的GRND#U，因为这是一种让用户空间解决启动时间熵不足的方法，即使它一点也不安全：从随机性的角度来看，这些系统可以说是被破坏的——如果存在&#39；没有什么东西能产生熵——但不管破碎与否，我怀疑它们仍然存在。这些可怕的事情在嵌入式网络中非常常见（路由器、接入点——应该关注的地方）[……]几乎没有人测试这些坏平台：即使是为那些嵌入式网络设备构建新内核的人，最终也可能会在现有的用户空间设置中使用这些内核——在那里，人们有一些已保存的伪熵源。因此，它们甚至可能不会触发&#34；第一次开机问题&#34；这往往是最糟糕的情况。</p><p> But, he said, he would be willing to apply the patch: &#34; at some point &#39;worryabout broken platforms&#39; ends up being too weak an excuse not to justapply it&#34;.  According to Joshua Kinard, the two MIPS models inquestion were from the 1980s, not ever used in systems, and the kernel testfor them in the random code &#34; was probably added as a mental exercise following aprocessor manual or such&#34;. Maciej W. Rozycki  saidthat there may have been a few systems using those models, but no Linuxport was ever made for them. That might mean that the only problem systemsare &#34; some m68kmuseum pieces&#34;, Donenfeld  said.</p><p>但是，他说，他愿意应用补丁：&#34；在某个时刻&#39；担心平台破损&#39；最终成为了一个软弱的借口，不去运用它&#34；。据约书亚·基纳德（Joshua Kinard）称，这两个MIPS模型都是20世纪80年代的，从未在系统中使用过，而内核测试则是在随机代码中进行的#34；很可能是作为一种心理练习，在一本处理器手册或诸如此类的内容之后添加的；。Maciej W.Rozycki说，可能有一些系统使用这些模型，但从来没有为它们制作过Linuxport。这可能意味着唯一的问题是&#34；一些m68kmuseum作品&#34；，多恩菲尔德说。</p><p> As Geert Uytterhoeven  pointedout, though, the cycle-counter code for the Linux generic architecture,which is the default and starting point for new architectures, is hardwiredto return zero. &#34; Several architectures do not implement get_cycles(), or implement itwith a variant that&#39;s very similar or identical to the genericversion.&#34; David Laight  addeda few examples (old x86, nios2) of architectures where that is the case.</p><p>然而，正如Geert Uytterhoeven指出的那样，Linux通用体系结构的循环计数器代码（新体系结构的默认值和起点）硬连接为返回零&#34; 有几种体系结构不实现get_cycles（），也不使用&#39；它与一般版本非常相似或相同&#34; David Laight补充了一些架构的例子（旧x86、nios2）。</p><p>  Lutomirski had a more prosaic  complaint: I dislike this patch for a reason that has nothing to do withsecurity. Somewhere there’s a Linux machine that boots straight to Nethackin a glorious 50ms. If Nethack gets 256 bits of amazing entropy from/dev/urandom, then the machine’s owner has to play for real. If it repeatsthe same game on occasion, the owner can be disappointed or amused. If itgets a weak seed that can be brute forced, then the owner can have funbrute forcing it. If, on the other hand, it waits 750ms for enough jitter entropy to beperfect, it’s a complete fail. No one wants to wait 750ms to playNethack.</p><p>卢托米尔斯基有一个更平淡无奇的抱怨：我不喜欢这个补丁，因为它与安全无关。某个地方有一台Linux机器，可以在50毫秒内直接引导到Nethack。如果Nethack从/dev/uradom获得了256位惊人的熵，那么机器的所有者就必须真正玩了。如果它偶尔重复同样的游戏，主人可能会感到失望或好笑。如果它得到了一个可以用蛮力强迫的弱种子，那么主人可以用蛮力强迫它。另一方面，如果它等待750ms，等待足够的抖动熵达到完美状态，那就是完全失败。没有人想等750ms后再玩Nethack。</p><p> More seriously, he was concerned about devices like backup cameras orlight bulbs that need to boot &#34;immediately&#34;, and where the quality of therandom numbers may not truly be a problem. The  GRND_INSECUREescape hatch is there for just that reason. In a similar vein, LennartPoettering was  worried thatsystemd would have to wait one second to get a seed for its hash tables,when it already has a mechanism to reseed the tables: So, systemd uses (potentially half-initialized) /dev/urandom forseeding its hash tables. For that its kinda OK if the random valueshave low entropy initially, as we&#39;ll automatically reseed when toomany hash collisions happen, and then use a newer (and thus hopefullybetter) seed, again acquired through /dev/urandom. i.e. if the seedsare initially not good enough to thwart hash collision attacks, oncethe hash table are actually attacked we&#39;ll replace the seeds with[something] better. For that all we need is that the random pooleventually gets better, that&#39;s all.</p><p>更严重的是，他担心备份摄像头或灯泡等需要开机的设备；立即&#34；，而且随机数的质量可能不是真正的问题。GRND_不安全逃生舱就是因为这个原因。与此类似，LennartPoettering担心systemd需要等待一秒钟才能为其哈希表获取种子，而它已经有了为这些表重新设定种子的机制：因此，systemd使用（可能是半初始化的）/dev/uradom放弃其哈希表种子。对于这一点，如果随机值最初是低熵的，那就没关系了，就像我们&#39；当发生太多散列冲突时，我们将自动重新设定种子，然后使用更新的（因此有望更好）种子，再次通过/dev/uradom获取。i、 e.如果种子最初不足以阻止哈希冲突攻击，一旦哈希表实际受到攻击，我们&#39；I’我会用更好的东西代替种子。为此，我们所需要的只是随机池最终变得更好，即&#39；就这些。</p><p> It turns out that systemd is  already using GRND_INSECURE on systems where it is available, so notchanging that behavior, as was originally proposed, would neatly fix Poettering&#39;sconcern. Donenfeld was completely amenable to  pulling the disabling of GRND_INSECURE from his patch; it is not really hisprimary focus with the proposal, as noted.</p><p>事实证明，systemd已经在可用的系统上使用了GRND#U Unsecure，因此，如果不像最初提议的那样改变这种行为，就可以很好地修复Poettering&#39；斯肯森。多恩费尔德完全可以把格恩德的伤残从他的补丁中拉出来；如前所述，这并不是他的主要关注点。</p><p> Based on Torvalds&#39;s response, it would seem there are no huge barriers toremoving the final distinction between  /dev/random and /dev/urandom—other than the names, of course. If there are morearchitectures that cannot use the jitter technique, though, thatdistinction may live on, since Torvalds also thought there might be valuein keeping &#34; the stupid stuff around as a &#39;doesn&#39;t hurt good platforms, mighthelp broken ones&#39;&#34;. The code removal would not be huge, so it doesnot really provide much of a code simplification, Donenfeld said; it ismore a matter of being able to eliminate the endless debate aboutwhich source of randomness to use on Linux. To that end, it seems like aworthwhile goal.</p><p>基于托瓦尔兹&#39；当然，在我们的回应中，除了名称之外，似乎没有太大的障碍来消除/dev/random和/dev/uradom之间的最终区别。但是，如果有更多的体系结构不能使用抖动技术，那么这种区别可能会继续存在，因为托瓦尔兹也认为保持&#34；那些愚蠢的东西就像&#39；不&#39；不要伤害好平台，可以帮助坏平台&#39&#34;. Donenfeld说，代码删除量不会很大，因此它并不能真正简化代码；更重要的是能够消除关于在Linux上使用哪种随机性源的无休止的争论。为此，这似乎是一个值得追求的目标。</p><p>       ( Log in to post comments)</p><p>（登录发表评论）</p><p>  The irony is that nethack internal RNG is very weak so is easy to bruteforce even if the kernel RNG was perfect. &lt; https://nethackwiki.com/wiki/Random_number_generator&gt;</p><p>具有讽刺意味的是，nethack的内部RNG非常弱，因此即使内核RNG非常完美，也很容易被粗暴对待&书信电报；https://nethackwiki.com/wiki/Random_number_generator&gt;</p><p>   Thanks for this summary. Encouraged by your read on the discussion, I wound up submitting a real v1 of the patch:  https://lore.kernel.org/lkml/20220217162848.303601-1-Jaso...</p><p>谢谢你的总结。受您对讨论的阅读鼓舞，我最终提交了一个真正的补丁v1：https://lore.kernel.org/lkml/20220217162848.303601-1-Jaso...</p><p>  Let me get this straight:  At the moment, both /dev/random and /dev/urandom block, until they have enough entropy. However their entropy sources differ. /dev/random draws from &#34;truly random, crpto-ready&#34; bits that came directly from a hardware source of some kind, where as /dev/urandom draws from a PRNG that is seeded from /dev/random&#39;s hardware-backed bits.  But we don&#39;t care, because the bits that have passed through the pseudo-RNG have like 99% of the randomness of the hardware bits and are &#34;good enough&#34; for crypto to rely on? (even though they might be a little stale if it&#39;s been a while since the PRNG was re-seeded)  I _suppose_ that drawing from /dev/urandom right after it&#39;s been seeded the first time with bits from /dev/random might be just as good as drawing from /dev/urandom, but what&#39;s the difference in their worst case? ie. if I&#39;m an attacker and later I draw 1 billion numbers from the PRNG before the next time it&#39;s re-seeded.</p><p>让我直截了当地说：目前，/dev/random和/dev/uradom都会阻塞，直到它们有足够的熵。然而，它们的熵源不同/开发/随机抽取自&#34；真正随机，crpto就绪#34；直接来自某种硬件源的位，其中as/dev/urandom从/dev/random&#39的种子PRNG中提取；它的硬件支持位。但我们没有&#39；不在乎，因为通过伪RNG的位具有硬件位99%的随机性，并且是&#34；足够好&#34；crypto需要依靠什么？（即使他们可能会有点过时，如果PRNG重新播种已经有一段时间了）我想那是从/dev/uradom开始的；第一次使用/dev/random中的位作为种子可能与使用/dev/urandom中的位一样好，但是什么&#39；他们最糟糕的情况有什么不同？如果我&#39；我是一个攻击者，后来我从PRNG中提取了10亿个数字，然后下一次它&#39；重新播种。</p><p> No, other than initial blocking behavior they are the same already, they use the same entropy pool and the same crng algorithm. If there is not yet enough entropy one blocks while the other warns and returns possibly-not-random data.</p><p>不，除了初始阻塞行为，它们已经是相同的，它们使用相同的熵池和相同的crng算法。如果还没有足够的熵，一个阻塞，而另一个警告，并返回可能不是随机数据。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>