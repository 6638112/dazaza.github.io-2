<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Bevy 0.3：锈迹斑斑的游戏引擎</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Bevy 0.3：锈迹斑斑的游戏引擎</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-04 05:28:25</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/48db8eb787e01587afbae8abe49292fa.png"><img src="http://img2.diglog.com/img/2020/11/48db8eb787e01587afbae8abe49292fa.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>A little over a month after releasing Bevy 0.2, and thanks to  59 contributors,  122 pull requests, and our   generous sponsors, I&#39;m happy to announce the  Bevy 0.3 release on  crates.io!</p><p>在发布Bevy 0.2一个多月后，感谢59位贡献者、122个拉请求和我们慷慨的赞助商，我很高兴地在crates.io！上宣布Bevy 0.3发布。</p><p> For those who don&#39;t know, Bevy is a refreshingly simple data-driven game engine built in Rust. You can check out  Quick Start Guide to get started. Bevy is also free and open source forever! You can grab the full  source code on GitHub.</p><p>对于那些不知道的人来说，Bevy是一个令人耳目一新的简单的数据驱动的游戏引擎，它内置在Rust。您可以查看快速入门指南以开始使用。Bevy也是永远免费和开源的！您可以在GitHub上获取完整的源代码。</p><p>     You can try out the  Bevy Android example by following the  instructions here. While many things work, please note that this is  very hot off the presses. Some features will work and others probably won&#39;t. Now is a great time to dive in and help us close the gaps!</p><p>您可以按照这里的说明试用bevy Android示例。虽然很多东西都能用，但请注意这是印出来的很热的东西。一些功能可以工作，而其他功能可能无法工作。现在是深入研究并帮助我们缩小差距的好时机！</p><p>        You can try out the  Bevy iOS example by following the  instructions here. This one is also hot off the presses: some features will work and others probably won&#39;t.</p><p>您可以按照此处的说明试用bevy iOS示例。这本书也是热印的：一些功能可以工作，其他的可能不会。</p><p>       @mrk-its has been hard at work on expanding Bevy&#39;s WASM support. In this release we landed WASM asset loading. You can now load assets when you publish to WASM just like you would on any other platform:</p><p>@Mr k-its一直在努力扩大Bevy&#39；的WASM支持。在此版本中，我们完成了WASM资产加载。现在，您可以在发布到WASM时加载资源，就像在任何其他平台上一样：</p><p>  If the asset hasn&#39;t already been loaded, this will make a  fetch() request to retrieve the asset over HTTP.</p><p>如果资产尚未加载，这将发出一个FETCH()请求以通过HTTP检索资产。</p><p> @mrk-its has also been building a custom WebGL2  bevy_render backend. It is already pretty usable, but its not  quite ready yet. Expect more news on this soon!</p><p>@mrk-its也一直在构建定制的WebGL2bevy_ender后端。它已经很好用了，但还没有完全准备好。期待更多关于这方面的消息！</p><p>    fn  touch_system ( touches :  Res &lt; Touches &gt;) {  // you can iterate all current touches and retrieve their state like this:  for  touch  in  touches . iter () {  println! (&#34; active touch: {:?} &#34;,  touch ); }  for  touch  in  touches . iter_just_pressed () {  println! (&#34; just pressed {:?} &#34;,  touch ); }  for  touch  in  touches . iter_just_released () {  println! (&#34; just released {:?} &#34;,  touch ); }  for  touch  in  touches . iter_just_cancelled () {  println! (&#34; just cancelled {:?} &#34;,  touch ); }}</p><p>Fn touch_system(Touches：res&lt；Touches&gt；){//您可以迭代所有当前的触摸并检索其状态，如下所示：用于触摸。ITER(){println！(&#34；active touch：{：？}&#34；，touch)；}用于触摸。Iter_Just_Press(){println！(&#34；刚才按了{：？}&#34；，touch)；}进行触摸。ITER_Just_Release(){println！(&#34；刚刚发布{：？}&#34；，touch)；}用于触摸。Iter_Just_Cancel(){println！(&#34；刚才取消了{：？}&#34；，touch)；}}</p><p>     Assets are now automatically freed when their &#34;handle reference count&#34; reaches zero. This means you no longer need to think about freeing assets manually:</p><p>现在，当资产的&#34；句柄引用计数为零时，资产将自动释放。这意味着您不再需要考虑手动释放资产：</p><p> // Calling load() now returns a strong handle: let  handle  =  asset_server . load (&#34; sprite.png &#34;); // Note that you no longer need to unwrap() loaded handles. Ergonomics for the win!// Cloning a handle increases the reference count by one let  second_handle  =  handle . clone (); // Spawn a sprite and give it our handle commands . spawn ( SpriteComponents  {  material :  materials . add ( handle . into ()), .. Default :: default ()}); // Later in some other system: commands . despawn ( sprite_entity ); // There are no more active handles to &#34;sprite.png&#34;, so it will be freed before the next update</p><p>//调用load()现在返回一个强句柄：let Handle=ASSET_SERVER。Load(&#34；sprite.png&#34；)；//请注意，您不再需要解开()加载的句柄。致胜的人体工程学！//克隆句柄会使引用计数增加一个let Second_HANDLE=HANDLE。Clone()；//生成一个精灵并给它我们的Handle命令。Screen(SpriteComponents{材质：材质。添加(句柄。变成())，..。Default：：default()})；//稍后在某些其他系统中：命令。Despawn(SPRITE_ENTITY)；//&#34；sprite.png&#34；没有更多的活动句柄，因此将在下次更新之前将其释放。</p><p>  In past releases,  AssetLoaders could only produce a single asset of a single type. In  Bevy 0.3, they can now produce any number of assets for any type. The old behavior was extremely limiting when loading assets like GLTF files, which might produce many meshes, textures, and scenes.</p><p>在以前的版本中，资源加载器只能生成单一类型的单个资源。在Bevy 0.3中，它们现在可以为任何类型生成任意数量的资源。加载资源(如GLTF文件)时，旧的行为受到极大限制，这可能会生成许多网格、纹理和场景。</p><p>  Sometimes you only want to load a specific asset from an asset source. You can now load sub assets like this:</p><p>有时，您只想从资源源加载特定资源。现在可以像这样加载子资源：</p><p>   The  AssetServer is now backed by the  AssetIo trait. This allows us to load assets from whatever storage we want. This means on desktop we now load from the filesystem, on Android we use the Android Asset Manager, and on the web we make HTTP requests using the  fetch() api.</p><p>AssetServer现在由AssetIo特性支持。这允许我们从任何我们想要的存储中加载资产。这意味着在桌面上我们现在从文件系统加载，在Android上我们使用Android Asset Manager，在Web上我们使用Fetch()API发出HTTP请求。</p><p>  Assets can now depend on other assets, which will automatically be loaded when the original asset is loaded. This is useful when loading something like a &#34;scene&#34; which might reference other asset sources. We utilize this in our new GLTF loader.</p><p>资源现在可以依赖于其他资源，这些资源将在加载原始资源时自动加载。当加载可能引用其他资源源的类似场景的内容时，此选项非常有用。我们在新的GLTF加载器中利用了这一点。</p><p>  This might rustle some feathers, but  AssetServer::load_sync() had to go! This api wasn&#39;t WASM friendly, encouraged users to block game execution for the sake of convenience (which causes &#34;hitching&#34;), and was incompatible with the new AssetLoader api. Asset loading is now always asynchronous. Users of  load_sync() should instead  load() their assets, check load status in their systems, and change game state accordingly.</p><p>这可能会惹恼一些人，但是AssetServer：：Load_sync()必须去掉！此API对WASM不友好，鼓励用户出于方便(这会导致搭便车)而阻止游戏执行，并且与新的AssetLoader API不兼容。资产加载现在始终是异步的。Load_sync()的用户应该改为load()他们的资源，检查其系统中的加载状态，并相应地更改游戏状态。</p><p>   Up until this point, the GLTF loader was painfully limited. It could only load the first mesh with a single texture in a GLTF file. For  Bevy 0.3, we took advantage of the asset system improvements to write a new  GltfLoader that loads GLTF files as Bevy  Scenes, along with all meshes and textures in the files.</p><p>在此之前，GLTF加载器都受到极大的限制。它只能加载GLTF文件中具有单个纹理的第一个网格。对于bevy 0.3，我们利用资源系统的改进编写了一个新的GltfLoader，它将GLTF文件加载为bevy场景，以及文件中的所有网格和纹理。</p><p> Here&#39;s Bevy loading the Khronos Flight Helmet example, which consists of multiple meshes and textures!</p><p>这里是装载Khronos飞行头盔的小猎犬，它由多个网格和纹理组成！</p><p>  Here is the complete code for a system that loads a GLTF file and spawns it as a scene:</p><p>以下是加载GLTF文件并将其派生为场景的系统的完整代码：</p><p>     In this release I finally was able to remove the one thing I  truly despised in Bevy ECS. In previous versions of Bevy, iterating over the components in a  Query looked like this:</p><p>在这个版本中，我终于能够删除我在bevy ECS中真正鄙视的一件事。在Bevy的以前版本中，迭代查询中的组件如下所示：</p><p> for  ( a ,  b ) in &amp; mut  query . iter () {  // The `&amp;mut` here just felt so unnatural } // Or if you preferred you could do this for  ( a ,  b ) in  query . iter (). iter () {  // query.iter().iter()? Really??? }</p><p>用于(a，b)in&amp；mut查询。Iter(){//这里的`&amp；mu`感觉非常不自然}//或者如果您愿意，可以对查询中的(a，b)执行此操作。ITER()。Iter(){//query.iter().iter()？真的吗？}。</p><p>  if let  Ok ( mut  result ) =  query . entity ( entity ) {  if let  Some (( a ,  b )) =  result . get () {  // access components here  }}</p><p>如果让OK(MUT RESULT)=QUERY。Entity(Entity){if设Some((a，b))=Result。Get(){//此处访问组件}}。</p><p>  // iteration for  ( a ,  b ) in  query . iter () {  // sweet ergonomic bliss } // entity lookup if let  Ok (( a , b )) =  query . entity ( entity ) {  // boilerplate be gone! }</p><p>//查询中(a，b)的迭代。Iter(){//甜蜜的人体工程学幸福}//实体查找if let OK((a，b))=query。实体(实体){//样板消失！}。</p><p>    The old api looked the way it did for a reason. It was the result of good design choices that protect against unsafe memory access in a parallel environment.</p><p>旧的API看起来是这样的是有原因的。这是良好的设计选择的结果，可以防止在并行环境中进行不安全的内存访问。</p><p> query.iter() didn&#39;t actually return an iterator. It returned a  wrapper that held an atomic lock on the component storages. The same was true for the type returned by  query.entity()</p><p>Query.iter()实际上没有返回迭代器。它返回一个包装器，该包装器在组件存储上持有原子锁。Query.entity()返回的类型也是如此</p><p> Removing these &#34;wrapper types&#34; would have allowed unsafe behavior because another Query could access the same components in a way that violated Rust&#39;s mutability rules.</p><p>删除这些包装器类型将允许不安全的行为，因为另一个查询可能会以违反Rust的可变性规则的方式访问相同的组件。</p><p> Due to the iterator implementation and quirks in the rust compiler, removing the wrapper type  tanked iteration performance by about ~2-3x.</p><p>由于Rust编译器中的迭代器实现和怪癖，删除包装器类型会使迭代性能下降约2-3倍。</p><p> Fortunately we finally found ways to solve all of these problems. The newly added  QuerySets allow us to completely remove the locks (and wrapper types). And by completely rewriting  QueryIter we were able to avoid the performance hit that removing the wrapper incurred. Read on for the details!</p><p>幸运的是，我们终于找到了解决所有这些问题的方法。新添加的QuerySet允许我们完全删除锁(和包装器类型)。通过完全重写QueryIter，我们能够避免删除包装器带来的性能影响。请继续阅读以了解详细信息！</p><p>  Bevy ECS is now completely lock free. In Bevy 0.2, we made direct  World access and &#34;for-each&#34; systems lock free. This is possible because the Bevy ECS scheduler ensures that systems only run in parallel in ways that respect Rust&#39;s mutability rules.</p><p>Bevy ECS现在完全解锁了。在BEVY 0.2中，我们使直接全球访问和每个系统的锁都是自由的。这是可能的，因为bevy ECS调度器确保系统只以遵守Rust的易变性规则的方式并行运行。</p><p>  fn  conflicting_query_system ( mut  q0 :  Query &lt;&amp; mut  A &gt; ,  mut  q1 :  Query &lt;(&amp; mut  A,  &amp; B )&gt;) {  let  a  =  q0 . get_mut ( some_entity ). unwrap ();  let  ( another_a ,  b ) =  q1 . get_mut ( some_entity ). unwrap ();  // Aaah!!! We have two mutable references to some_entity&#39;s A component! // Very unsafe! }</p><p>Fn Conflicting_Query_System(mut q0：查询&lt；&amp；mut A&gt；，mut q1：查询&lt；(&amp；mut A，&amp；B)&gt；){设a=q0.。Get_mut(某些实体)。UNWRAP()；设(Another_a，b)=q1。Get_mut(某些实体)。Unwork()；//aaah！我们有两个对SOME_ENTITY A组件的可变引用！//非常不安全！}。</p><p> The locks ensured that the second  q1.get_mut(some_entity) access panicked, keeping us nice and safe. In  Bevy 0.3, a system like  conflicting_query_system will fail when the schedule is constructed. By default,  systems cannot have conflicting queries.</p><p>这些锁确保了第二个q1.get_mut(Ome_Entity)访问死机，保证了我们的安全。在bevy 0.3中，像conflicting_query_system这样的系统在构建时间表时会失败。默认情况下，系统不能有冲突的查询。</p><p> However there are some cases where a system  needs conflicting queries to do what it needs to do. For these cases, we added  QuerySets:</p><p>但是，在某些情况下，系统需要冲突的查询来执行它需要做的事情。对于这些情况，我们添加了QuerySets：</p><p> fn  system ( mut  queries :  QuerySet &lt;( Query &lt;&amp; mut  A &gt; , Query &lt;(&amp; mut  A,  &amp; B )&gt;)&gt;) {  for  a  in  queries . q0_mut (). iter_mut () { }  for  ( a ,  b ) in  queries . q1_mut (). iter_mut () { }}</p><p>Fn system(mut查询：QuerySet&lt；(query&lt；&amp；mut A&gt；，query&lt；(&amp；mut A，&amp；B)&gt；)&gt；){用于输入查询。Q0_mut()。查询中(a，b)的iter_mut(){}。Q1_mut()。Iter_mut(){}}</p><p> By putting our conflicting  Queries in a  QuerySet, the Rust borrow checker protects us from unsafe query accesses.</p><p>通过将冲突的查询放在QuerySet中，Rust借入检查器保护我们免受不安全的查询访问。</p><p> Because of this, we were able to remove  all safety checks from  query.iter() and  query.get(entity), which means these methods are now  exactly as fast as their  World counterparts (which we made lock-free in Bevy 0.2).</p><p>正因为如此，我们能够从query.iter()和query.get(Entity)中删除所有安全检查，这意味着这些方法现在的速度与它们的World对应方法(我们在bevy 0.2中使其无锁)完全一样快。</p><p>   Removed archetype &#34;safety checks&#34; from Query access. At this point we have already verified that the given Query access is safe, so we don&#39;t need to check again on every call.</p><p>从查询访问中删除了原型&#34；安全检查&#34；。在这一点上，我们已经验证了给定的查询访问是安全的，因此我们不需要在每次调用时再次检查。</p><p> Rewrote  QueryIter to be simpler (and therefore easier to control optimizations for), which allowed us to remove the iterator wrapper without tanking performance. This also resolved some performance inconsistencies where some system permutations performed optimally and others didn&#39;t. Now everything is on the &#34;fast path&#34;!</p><p>重写了QueryIter以使其更简单(因此更容易控制优化)，这允许我们删除迭代器包装器，而不会影响性能。这也解决了一些性能不一致的问题，其中一些系统排列执行得最好，而另一些则不是。现在一切都在快速进行中！</p><p> Ported some performance improvements from upstream hecs, which improved iteration over heavily fragmented archetypes and improved component insertion times</p><p>从上游HECS移植了一些性能改进，这改进了大量碎片原型的迭代，并缩短了组件插入时间。</p><p>   This is where the big wins were. By removing locks and safety checks from Query systems, we were able to  significantly reduce the cost of retrieving a specific entity&#39;s component from within a system.</p><p>这就是大获全胜的地方。通过从查询系统中移除锁定和安全检查，我们能够显著降低从系统中检索特定实体组件的成本。</p><p> I included a comparison to  Legion ECS (another great archetypal ECS with a parallel scheduler) to illustrate why Bevy&#39;s new approach is so cool. Legion exposes a direct &#34;world like&#34; api (called a SubWorld) in its systems. The SubWorld&#39;s entry api  cannot know ahead of time what types will be passed into it, which means it  must do (relatively) expensive safety checks to ensure the user doesn&#39;t request access to something they shouldn&#39;t.</p><p>我包括了一个与军团ECS(另一个伟大的原型ECS与并行调度程序)的比较，以说明为什么贝维的新方法是如此酷。军团在其系统中公开了一个类似于世界的直接API(称为亚世界)。子世界的入口API无法提前知道将向其传递哪些类型，这意味着它必须进行(相对)昂贵的安全检查，以确保用户不会请求访问他们不应该访问的内容。</p><p> Bevy&#39;s scheduler pre-checks  Queries once ahead of time, which allows systems to access their results without any additional checks.</p><p>Bevy&#39；的调度程序提前对查询进行一次预检查，这使得系统无需任何额外检查即可访问其结果。</p><p> The test was to lookup (and modify) a specific entity&#39;s component 100,000 times on each system iteration. Here is a quick rundown of how these tests were performed in each case:</p><p>测试是在每次系统迭代中查找(和修改)特定实体的组件100,000次。以下是这些测试在每种情况下是如何执行的快速概要：</p><p>  Its worth noting that using  query.get_component::&lt;T&gt;(entity) instead of  query.get(entity) does require safety checks, for the same reason the legion entry api does. We cannot know ahead of time what component type a caller will pass into the method, which means we  must check it to make sure it matches the  Query.</p><p>值得注意的是，使用query.get_component：：&lt；T&gt；(实体)而不是query.get(实体)确实需要进行安全检查，原因与军团进入API相同。我们不能提前知道调用者将向方法传递什么组件类型，这意味着我们必须检查它以确保它与查询匹配。</p><p>         Some resource types cannot (or should not) be passed between threads. This is often true for low level apis like windowing, input, and audio. It is now possible to add &#34;thread local resources&#34; to the  Resources collection, which can only be accessed from the main thread using &#34;thread local systems&#34;:</p><p>有些资源类型不能(或不应该)在线程之间传递。对于窗口、输入和音频等低级API通常都是如此。现在可以将&#34；线程本地资源&#34；添加到资源集合，该资源集合只能使用&#34；线程本地系统&#34；从主线程访问：</p><p> // in your app setup app . add_thread_local_resource ( MyResource ); // a thread local system fn  system ( world : &amp; mut  World,  resources : &amp; mut  Resources ) {  let  my_resource  =  resources . get_thread_local ::&lt; MyResource &gt;(). unwrap ();}</p><p>//在您的应用设置应用程序中。Add_thread_local_resource(MyResource)；//a线程本地系统fn system(world：&amp；mut World，resources：&amp；mut Resources){let my_resource=resources。GET_THREAD_LOCAL：：&lt；MyResource&gt；()。UnWrap()；}。</p><p>  First, to improve clarity we renamed  query.get::&lt;Component&gt;(entity) to  query.get_component::&lt;Component&gt;(entity). We now return the &#34;full&#34; query result for a specific entity using  query.get(entity).</p><p>首先，为了提高清晰度，我们将query.get：：&lt；Component&gt；(Entity)重命名为query.get_component：：&lt；Component&gt；(entity).。现在，我们使用query.get(Entity)返回特定实体的&#34；完整&#34；查询结果。</p><p> To allow multiple concurrent reads of Queries (where it is safe), we added separate  query.iter() and  query.iter_mut() apis, as well as  query.get(entity) and  query.get_mut(entity). Queries that are &#34;read only&#34; can now retrieve their results via an immutable borrow.</p><p>为了允许查询的多个并发读取(在安全的情况下)，我们添加了单独的query.iter()和query.iter_mut()API，以及query.get(实体)和query.get_mut(实体)。只读查询现在可以通过不变的借阅检索其结果。</p><p>    Bevy meshes used to require exactly three &#34;vertex attributes&#34;:  position,  normal, and  uv. This worked for most things, but there are a number of cases that require other attributes, such as &#34;vertex colors&#34; or &#34;bone weights for animation&#34;.  Bevy 0.3 adds support for custom vertex attributes. Meshes can define whatever attributes they want and shaders can consume whatever attributes they want!</p><p>Bevy网格过去只需要三个顶点属性：位置、法线和UV。这适用于大多数情况，但也有许多情况需要其他属性，例如动画的顶点颜色&34；或骨骼权重&#34；。Bevy 0.3添加了对自定义顶点属性的支持。网格可以定义他们想要的任何属性，着色器可以使用他们想要的任何属性！</p><p> Here is an example that illustrates how to define a custom shader that consumes a mesh with an added &#34;vertex color&#34; attribute.</p><p>下面是一个示例，说明如何定义使用具有添加的顶点颜色属性的网格的自定义着色器。</p><p>    Rendering meshes often involves using vertex &#34;indices&#34; to cut down on duplicate vertex information. Bevy used to hard code the precision of these indices to  u16, which was too small for some cases. Now render pipelines can &#34;specialize&#34; based on a configured index buffer, which now defaults to  u32 to cover most use cases.</p><p>渲染网格通常涉及使用顶点索引来减少重复的顶点信息。Bevy过去常常将这些索引的精度硬编码为u16，这对于某些情况来说太小了。现在，渲染管道可以根据配置的索引缓冲区进行专门化，索引缓冲区现在默认为u32以覆盖大多数用例。</p><p>   Transforms are important to get right. They are used in many slices of the engine, user code touches them constantly, and they are relatively expensive to compute: especially transform hierarchies.</p><p>转换是正确的，这一点很重要。它们用在引擎的许多部分中，用户代码经常接触到它们，而且它们的计算成本相对较高：尤其是转换层次结构。</p><p> In the last release, we vastly simplified Bevy&#39;s transform system to use a consolidated  Transform and  GlobalTransform instead of multiple separate  Translation,  Rotation, and  Scale components (which were synced to  Transform and  GlobalTransform). This made the user-facing api/dataflow simpler, as well as the underlying implementation. The  Transform component was backed by a 4x4 matrix. I pressed the big green &#34;merge&#34; button ... happy that we had solved the Transform problem once and for all!</p><p>在上一个版本中，我们大大简化了bevy的变换系统，使用统一的变换和全局变换，而不是多个独立的平移、旋转和缩放组件(它们与变换和全局变换同步)。这使得面向用户的API/数据流以及底层实现变得更简单。变换分量由4x4矩阵支持。我按下了大绿色的合并按钮...。很高兴我们一劳永逸地解决了变形问题！</p><p> It turns out there was still more work to be done!  @AThilenius pointed out that using a 4x4 matrix as the source of truth for an affine transform accumulates error over time. Additionally, the Transform api was still a little cumbersome to use.  At the suggestion of @termhn we decided to investigate using a &#34;similarity&#34; as the source of truth. This had the following benefits:</p><p>原来还有更多的工作要做！@ATHilenius指出，使用4x4矩阵作为仿射变换的真值来源会随着时间的推移累积误差。此外，转换API的使用仍然有点麻烦。在@Termhn的建议下，我们决定用相似性作为真相来源进行调查。这有以下好处：</p><p>  We collectively decided this was a good path forward and now we have a re-rewrite that is even better. Yes this is  another breaking change, but thats why we label Bevy as being in the &#34;experimentation phase&#34;. Now is the time to break things as often as possible to ensure that we find good apis that will stand the test of time.</p><p>我们共同认为这是一条很好的前进道路，现在我们重写了一次，甚至更好。是的，这是另一个突破性的变化，但这就是为什么我们给Bevy贴上了实验阶段的标签。现在是时候尽可能多地破坏东西，以确保我们找到经得起时间考验的好API。</p><p>  fn  system ( mut  transform :  Mut &lt; Transform &gt;) {  // move along the positive x-axis  transform . translation  +=  Vec3 :: new ( 1.0 ,  0.0 ,  0.0 );  // rotate 180 degrees (pi) around the y-axis  transform . rotation  *=  Quat :: from_rotation_y ( PI );  // scale 2x  transform . scale  *=  2.0 ;}</p><p>FN系统(mut变换：mut&lt；变换&gt；){//沿着正x轴变换移动。平移+=ve3：：new(1.0，0.0，0.0)；//围绕y轴变换旋转180度(Pi)。Rotation*=Quat：：From_Rotation_y(PI)；//缩放2x变换。Scale*=2.0；}。</p><p> Compared to the last version this is easier to use, more correct, and should also be slightly faster.</p><p>与上一个版本相比，这个版本更容易使用，更正确，而且速度也应该会稍微快一些。</p><p>   The newly added  GamepadSettings resource gives developers the ability to customize gamepad settings on a per-controller, per-axis/button basis:</p><p>新添加的GamepadSettings资源允许开发人员基于每个控制器、每个轴/按钮自定义游戏手柄设置：</p><p> fn  system ( mut  gamepad_settings :  ResMut &lt; GamepadSettings &gt;) {  gamepad_settings . axis_settings . insert (  GamepadAxis ( Gamepad ( 0 ),  GamepadAxisType :: LeftStickX ),  AxisSettings  {  positive_high :  0.8 ,  positive_low :  0.01 , .. Default :: default () }, );}</p><p>Fn system(mut gamepad_settings：ResMut&lt；GamepadSettings&gt；){gamepad_settings。AXIS_SETTINGS。Insert(GamepadAxis(Gamepad(0)，GamepadAxisType：：LeftStickX)，AxisSettings{Positive_High：0.8，Positive_Low：0.01，..。Default：：Default()}，)；}。</p><p>     This adds the plugins for all of the &#34;core&#34; engine functionality (rendering, input, audio, windowing, etc). It was straightforward, but also very static. What if you don&#39;t want to add  all of the default plugins? What if you want to create your own custom set of plugins?</p><p>这将添加所有核心引擎功能(渲染、输入、音频、窗口等)的插件。它是直截了当的，但也非常静态。如果您不想添加所有默认插件，该怎么办？如果您想创建自己的自定义插件集，该怎么办？</p><p> To resolve this, we added  PluginGroups, which are ordered collections of plugins that can be individually enabled or disabled:</p><p>为了解决这个问题，我们添加了PluginGroups，它们是可以单独启用或禁用的插件的有序集合：</p><p> // This: app . add_default_plugins () // Has been replaced by this: app . add_plugins ( DefaultPlugins ) // You can disable specific plugins in a PluginGroup: app . add_plugins_with ( DefaultPlugins , | group | {  group . disable ::&lt; RenderPlugin &gt;() . disable ::&lt; AudioPlugin &gt;()}); // And you can create your own PluginGroups: pub struct  HelloWorldPlugins ; impl  PluginGroup  for  HelloWorldPlugins  {  fn  build (&amp; mut  self ,  group : &amp; mut  PluginGroupBuilder ) {  group . add ( PrintHelloPlugin ) . add ( PrintWorldPlugin ); }} app . add_plugins ( HelloWorldPlugins );</p><p>//这个：APP。Add_default_plugins()//已被替换为：app。Add_plugins(DefaultPlugins)//您可以关闭PluginGroup：APP中的特定插件。Add_plugins_with(DefaultPlugins，|GROUP|{GROUP。禁用：：&lt；RenderPlugin&gt；()。禁用：：&lt；AudioPlugin&gt；()})；//您可以创建自己的PluginGroups：pub struct HelloWorldPlugins；Iml PluginGroup for HelloWorldPlugins{fn build(&amp；mut self，group：&amp；mut PluginGroupBuilder){group。添加(PrintHelloPlugin)。添加(PrintWorldPlugin)；}}应用。Add_plugins(HelloWorldPlugins)；</p><p>   Bevy provides a backend-agnostic windowing api. Up until this point, window settings could only be set once at app startup. If you wanted to set window settings dynamically, you had to directly interact with window backends (ex: winit).</p><p>Bevy提供与后端无关的窗口API。在此之前，窗口设置只能在应用程序启动时设置一次。如果您想要动态设置窗口设置，则必须直接与窗口后端交互(例如：winit)。</p><p> In this release we added the ability to dynamically set window properties at runtime using the Bevy window abstraction:</p><p>在此版本中，我们添加了使用bevy窗口抽象在运行时动态设置窗口属性的功能：</p><p> // This system dynamically sets the window title to the number of seconds since startup. Because why not? fn  change_title ( time :  Res &lt; Time &gt; ,  mut  windows :  ResMut &lt; Windows &gt;) {  let  window  =  windows . get_primary_mut (). unwrap ();  window . set_title ( format! ( &#34; Seconds since startup: {} &#34;,  time . seconds_since_startup  ));}</p><p>//该系统将窗口标题动态设置为启动后的秒数。有何不可呢？Fn change_title(time：res&lt；time&gt；，mut windows：ResMut&lt；windows&gt；){let Window=windows.。Get_primary_mut()。UnWrap()；Window。SET_TITLE(FORMAT！(&#34；秒自启动：{}&#34；，时间。秒_自_启动))；}。</p><p>   The  bevy crate documentation search function now returns results for all sub-crates (like bevy_sprite). Due to how documentation is generated for re-exported crates, by default the  bevy search index only covered the &#34;prelude&#34;. @memoryruins found a way to fix this problem by creating new modules and exporting the contents of each crate within those modules (as opposed to aliasing the crates).</p><p>Bevy crate文档搜索函数现在返回所有子箱的结果(如bevy_spite)。由于为再出口的板条箱生成文档的方式，默认情况下，bevy搜索索引仅覆盖&#34；前奏&#34；。@Mememyruins找到了一种解决此问题的方法，方法是创建新模块并导出这些模块中每个板条箱的内容(而不是给板条箱设置别名)。</p><p>      sRGB awareness for  Color Color is now assumed to be provided in the non-linear sRGB colorspace.Constructors such as  Color::rgb and  Color::rgba will be converted to linear sRGB.</p><p>现在假定在非线性sRGB颜色空间中提供对颜色的sRGB感知。Color：：RGB和Color：：RGBA等构造函数将转换为线性sRGB。</p><p> New methods  Color::rgb_linear and  Color::rgba_linear will accept colors already in linear sRGB (the old behavior)</p><p>新方法Color：：RGB_LINEAR和Color：：RGBA_LINEAR将接受已在线性sRGB中的颜色(旧行为)。</p><p> Mesh overhaul with custom vertex attributes For missing attributes (requested by shader, but not defined by mesh), Bevy will provide a zero-filled fallback buffer.</p><p>使用缺少属性的自定义顶点属性进行网格大修(着色器请求，但未由网格定义)，bevy将提供填充为零的回退缓冲区。</p><p> Despawning an entity multiple times causes a debug-level log message to be emitted instead of a panic:  #649,  #651</p><p>多次取消绘制实体会导致发出调试级日志消息，而不是死机：#649、#651。</p><p>    A huge thanks to the  59 contributors that made this release (and associated docs) possible!</p><p>非常感谢59位贡献者，他们使这个版本(以及相关文档)成为可能！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bevyengine.org/news/bevy-0-3/">https://bevyengine.org/news/bevy-0-3/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/engine/">#engine</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/现在/">#现在</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1032933.html"><img src="http://img2.diglog.com/img/2020/11/thumb_0803f67b2dea838dffa8a2a38c7afff6.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032933.html">Scipio：适用于Rust和Linux的每核线程机箱</a></div><span class="my_story_list_date">2020-11-3 14:45</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032908.html"><img src="http://img2.diglog.com/img/2020/11/thumb_be7c5ac7c26fb279aed5af0ebbacaf23.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032908.html">OX是一个用Rust编写的快速文本编辑器，可以在您的终端上运行</a></div><span class="my_story_list_date">2020-11-3 12:4</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032258.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032258.html">古物鉴定师的铁锈</a></div><span class="my_story_list_date">2020-10-30 19:30</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032252.html"><img src="http://img2.diglog.com/img/2020/10/thumb_32a6a18f6a7b3db994451021b6994b68.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032252.html">铁锈网到了吗？是的，而且它跑得太快了</a></div><span class="my_story_list_date">2020-10-30 18:37</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>