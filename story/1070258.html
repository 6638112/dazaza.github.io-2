<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>van Laarhoven Free Monad 中的可扩展效果</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">van Laarhoven Free Monad 中的可扩展效果</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-07-29 21:55:27</div><div class="page_narrow text-break page_content"><p>代数效应似乎是函数式编程中的一种圣杯。当我在这里说“代数效应”时，我的意思是：将任何效应视为程序中的值或类型，同时还有一些简单的运算（代数）来组合效应。这实际上是什么样子的？想到的两种语言是 Idris 和 PureScript。当您使用他们的效果支持进行编程时，您编写了 monadic 代码，但本质上有一个您可以从环境中提取的效果列表：日志记录、状态、IO 等。此外，您可以针对一堆效果进行编程，只需假设这些效果你需要的存在，允许我们根据需要任意增加效果堆栈。这是很不错的。不幸的是，我们无法在 Haskell 中访问这些工具。相反，haskellers 通常依赖于 mtl 或 Free Monads。我今天要展示的是一个接近 Idris 和 PureScript 的效果库，使用 van Laarhoven 编码的 Free Monad，配备了一个异构列表 (HList) 效果。我声称这具有 Idris 和 PureScript 中 Effect 工具的一些好处，与常规 Free Monads 相同的表现力，比 Church、Fused 或 Oleg 编码更高效的编码，并且只需要我们进行一些扩展。全部在大约 60 行代码中。 -- |我们使用显式的 `liftVL` 组合器用于说明目的。-- 在实际代码中，您将拥有自己的组合器。-- 发布 requestpostReq :: HasEffect 效果 Http =&gt; Url -&gt; RequestBody -&gt; FreeVL 效果 StatusCodepostReq url body = do resp &lt;- liftVL (\http -&gt; put http url body) return (statusCode resp)-- 取任意自由 monad 并用 loggingwithLog 包装它 :: HasEffect effects Logging =&gt; String -&gt; String -&gt; FreeVL effects a -&gt; FreeVL 效果 awithLog preMsg postMsg program = do liftVL (\log -&gt; infoLogger log preMsg) a &lt;- program liftVL (\log -&gt; infoLogger log postMsg) return a-- 用于定义解释器类型的具体效果列表 MyEffects = ( Http &#39;: Logging &#39;: Random &#39;: State &#39;: &#39;[] )--作为值的解释器ioInterpreter :: Effects MyEffects IOioInterpreter = httpIO .: loggerIO .: randomIO .: stateIO .: EmptyEffect--实际运行我们的programmain :: IO ()main = interpret ioInterpreter (withLog &quot;POST!&quot; &quot;phew! made it!&quot; (postReq &quot;https://weirdcanada.com&quot; &quot;rare=cool&quot;) ) 上面唯一缺少的部分是我们的效果（Http、Logger 等）的样子。下面是一个例子： -- HTTP effectdata Http m = Http { get :: Url -&gt; m Response , put :: Url -&gt; RequestBody -&gt; m Response -- 等等 }-- Logging effectdata Logging m = Logging { infoLogger :: String -&gt; m (), debugLogger :: String -&gt; m ()-- 等等}</p><p>这篇文章的其余部分是用识字的haskell写的。我鼓励您剪切并粘贴此代码并自己玩！首先，让我们进行一些扩展和导入！ &gt; {-# LANGUAGE DataKinds #-}&gt; {-# LANGUAGE FlexibleContexts #-}&gt; {-# LANGUAGE FlexibleInstances #-}&gt; {-# LANGUAGE GADTs #-}&gt; {-# LANGUAGE KindSignatures #-}&gt; {-# LANGUAGE MultiParamTypeClasses #-}&gt; {-# LANGUAGE PolyKinds #-}&gt; {-# LANGUAGE RankNTypes #-}&gt; {-# LANGUAGE TypeOperators #-}&gt; &gt; module Main where&gt; &gt; import Control.Arrow ((&amp;&amp;&amp;))&gt; import Control .Concurrent(threadDelay)&gt; import Control.Exception(catch)&gt; import Control.Lens((^.))&gt; import Data.ByteString.Lazy(ByteString)&gt; import Network.Wreq(get, post, Response, responseStatus, statusCode) &gt; 导入 Network.HTTP.Client (HttpException(StatusCodeException))&gt; 导入合格的 Network.HTTP.Types.Status 作为 S&gt; 导入 System.Random (randomIO) 我向您推荐 Russell O&#39;Connor 在 van Laarhoven Free Monad 上的精彩博文.这是一个简短而简洁的读物。从某种意义上说，van Laarhoven Free Monad 与普通单子是双重的。我们使用乘积而不是使用 sum 类型来对操作进行建模。 &gt; -- 输入别名，使它看起来像真正的代码。&gt; type Url = String&gt; type RequestBody = ByteString&gt; &gt; -- 老式的自由单子编码&gt; data Free effect a = Pure a&gt; | Free (effect (Free effect a))&gt; &gt; -- 示例http效果：为简洁起见，使用Strings表示url和响应&gt; data YeOldeHttp a = Get Url (Response ByteString -&gt; a)&gt; | Post Url RequestBody (Response ByteString -&gt; a)&gt; &gt; -- 示例解释器&gt; freeIOInterp :: Free YeOldeHttp a -&gt; IO a&gt; freeIOInterp (Pure a) = return a&gt; freeIOInterp (Free (Get url next)) = get url &gt; &gt;= freeIOInterp 。 next&gt; freeIOInterp (Free (Post url body next)) = post url body &gt;&gt;= freeIOInterp 。 next&gt; &gt; -- 示例组合器&gt; oldGet :: Url -&gt; Free YeOldeHttp (Response ByteString)&gt; oldGet url = Free (Get url Pure) 给定一个效果，它本身是一个sum-type（每个分支不同的操作（例如Get , Put)) 我们可以证明 Free YeOldHttp a 是一个 monad（有关更多信息，请参阅 Gabriel 的博客文章）并针对它编写解释器，为其提供正确的语义。 Free Monads 的重要部分是我们可以编写不同的解释器，每个解释器都有自己的特定用途（测试、生产、调试等）。现在，van Laarhoven Free Monad 是一种不同的编码，需要您将效果表示为乘积而不是总和。上面的例子相当于： &gt; -- (简单) van Laarhoven Free Monad encoding&gt; newtype FreeVL1 effect a =&gt; FreeVL1 { runFreeVL1 :: forall m. Monad m =&gt; effect m -&gt; ma }&gt; &gt; -- 例子Http effect&gt; data NewHttp m =&gt; NewHttp { getNewHttp :: Url -&gt; m (Response ByteString)&gt; , postNewHttp :: Url -&gt; RequestBody -&gt; m (Response ByteString)&gt; }&gt; &gt; -- 示例解释器&gt; newHttpIO :: NewHttp IO&gt; newHttpIO = NewHttp { getNewHttp = get, postNewHttp = post }&gt; &gt; freeVL1IOInterpreter :: FreeVL1 NewHttp a -&gt; IO a&gt; freeVL1IOInterpreter program = runFreeVL1 program newHttpIO&gt; -- 示例组合&gt; newGet :: Url -&gt; FreeVL1 NewHttp (Response ByteString)&gt; newGet url = FreeVL1 (\httpEffects -&gt; getNewHttp httpEffects url)</p><p>FreeVL1 的好处在于它只是一个函数。要解释用 FreeVL1 NewHttp a 编写的程序，我们只需要提供 NewHttp m 类型的值，如上所示。这意味着针对 FreeVL1 NewHttp a 编写程序将具有与函数组合或 Reader monad 相同的运行时成本。将此与 Free 的常规编码进行对比，后者在绑定下执行得非常糟糕（它基本上是一个花哨的操作链表）。我们可以使用 Church-encoding 来大幅改善这一点，但它也有其他的权衡。现在，简单的 van Laarhoven 编码的缺点是我们一次只有一种效果。让我们看看我们如何改进它！我们现在的动机是创建新的效果（例如，也许我们想要日志、随机数等，而不是仅仅 Http）并将它们组合起来。在传统的 Free Monad 编码中这样做的一种方法是使用联产品（请参阅此处的博客文章）。由于每个 effect 都是一个 Functor，而 Functors 的 Co-Products 仍然是一个 Functor，这在技术上是可能的。然而，它使得从堆栈中提取效果以及编写和组合解释器变得非常麻烦。在 van Laarhoven 编码中，我们的效果已经是一个产品类型了。我们想要的是能够为我们的效果添加更多“字段”。例如，如果我们可以添加字段 log :: String -&gt; m()，那几乎就像在我们的效果堆栈中添加一个记录器一样！添加字段的一种等效方法是创建一个 Heterogeneous 效果列表！如果我们不是将我们的效果产品“相乘”，而是将它们附加到一个异构列表中，那么我们就有了一种添加更多效果的方法，这与添加更多字段是同构的。让我们设计一个这样的 HList 并展示它如何使我们能够扩展以前的 van Laarhoven 编码！ &gt; -- |我们的 HList of effects&gt; -- 请注意，根据 van Laarhoven 编码，我们的效果是参数化的&gt; -- 由一个 monad m.&gt; data EffectStack a (m :: * -&gt; *) where&gt; EmptyEffect :: EffectStack &#39;[] m&gt; ConsEffect :: effect m -&gt; EffectStack 效果 m -&gt; EffectStack (effect &#39;: effects) m</p><p>EffectStack 现在包含一个任意的效果列表，每个效果由 m 参数化。我们现在准备定义堆栈驱动的 van Laarhoven Free Monad： &gt; -- van Laarhoven Free Monad with Effect Stacks encoding&gt; newtype FreeVL effects a =&gt; FreeVL { runFreeVL :: forall m. Monad m =&gt; EffectStack effects m -&gt; ma }&gt; &gt; -- 是的，它是一个monad&gt; instance Functor (FreeVL effects) where&gt; fmap f (FreeVL run) = FreeVL (fmap f .run)&gt; &gt; instance Applicative (FreeVL)效果) where&gt; pure a = FreeVL (const (pure a))&gt; (FreeVL fab) (FreeVL a) =&gt; FreeVL $ uncurry () 。 (fab &amp;&amp;&amp; a)&gt; &gt; instance Monad (FreeVL effects) where&gt; (FreeVL run) &gt;&gt;= f =&gt; FreeVL $ \effects -&gt; run effects &gt;&gt;= \a -&gt; runFreeVL (fa) effects &gt; -- 解释一个van Laarhoven Free Monad with Effect Stacks&gt; interperet :: Monad m&gt; =&gt; EffectStack effects m&gt; -&gt; FreeVL effects a&gt; -&gt; ma&gt; interperet interpreter program = runFreeVL program interpreter 不幸的是，我们还没有准备好以我们的新幻想编写程序免费的单子。我们需要构建具有任意效果堆栈的程序，为此，我们需要一种从 EffectStack 中提取效果并使用它的方法。为了实现这一点，我从 haskell-servant 的 Julian Arni 那里借用了一个技巧（你可以在这里看到他的代码）。本质上，我们创建了一个类型类，它能够在 EffectStack 中抓取 HList 并搜索我们想要的效果，然后返回它。 &gt; -- 定义一个类型类，只有在有某种效果时才会编译&gt; -- 存在于栈中，如果存在则返回。&gt; class HasEffect (effects :: [((* -&gt; *) -&gt; *)]) (effect :: ((* -&gt; *) -&gt; *)) where&gt; getEffect :: EffectStack effects m -&gt; effect m&gt; &gt; -- 让我们提供一些`HasEffect`的实例，可以爬行EffectStack看&gt; -- 对于匹配然后返回的效果。&gt; &gt; -- 第一个实例处理我们的效果类型与 HList 的 &gt; -- 头部不匹配并进一步递归的情况。&gt; 实例 {-# OVERLAPPABLE #- }&gt; HasEffect effects effect =&gt; HasEffect (notIt &#39;: effects) effect where&gt; getEffect (ConsEffect _ effects) = getEffect effects&gt; &gt; -- 这个实例匹配我们的&#39;effect&#39;类型匹配head的情况&gt; -- HList的.然后我们返回那个效果。&gt; instance {-# OVERLAPPABLE #-}&gt; HasEffect (effect &#39;: effects) effect where&gt; getEffect (ConsEffect effect _) = effect 那些类型类可能会让你有点想歪了（他们肯定会歪曲我的） ，但如果你自己写（我鼓励你这样做），你就会掌握它的窍门。 （PS - 我永远感谢朱利安的这个想法，因为它太方便了！）</p><p>现在我们有了选择效果的工具，我们可以开始编写组合器，让我们可以针对任意效果堆栈编写程序。 &gt; -- 将操作提升到 van Laarhoven Free Monad&gt;liftVL :: HasEffect 效果效果&gt; -- ^ 约束强制我们的效果在效果堆栈中&gt; =&gt; (forall m. effect m -&gt; ma)&gt; -- ^ 方法从我们的效果中提取我们的操作。&gt; -&gt; FreeVL effects a&gt;liftVL getOp = FreeVL (\effects -&gt; getOp (getEffect effects)) 让我们编写一些用户代码。我们将从定义三个效果开始： &gt; -- HTTP Effect&gt; data Http m =&gt; Http { getHttpEff :: Url -&gt; m (Either Int (Response ByteString))&gt; , postHttpEff :: Url -&gt; RequestBody -&gt; m (要么 Int (Response ByteString))&gt; }&gt; &gt; -- Logging Effect&gt; data Logging m = Logging { logEff :: String -&gt; m () }&gt; &gt; -- 随机数效应&gt; data Random m = Random { getRandEff :: m Int }&gt; &gt; -- suspend effect&gt; data Suspend m = Suspend { suspendEff :: Int -&gt; m () } 现在来看一些代码。让我们为每个效果中的每个运算符编写组合子。 &gt; getHttp :: HasEffect 效果 Http&gt; =&gt; Url&gt; -&gt; FreeVL 效果 (Either Int (Response ByteString))&gt; getHttp url =liftVL (`getHttpEff` url)&gt; &gt; postHttp :: HasEffect 效果 Http&gt; =&gt; Url&gt; -&gt; RequestBody&gt; -&gt; FreeVL 效果（Either Int (Response ByteString))&gt; postHttp url body = liftVL (\http -&gt; postHttpEff http url body)&gt; &gt; logMsg :: HasEffect effects Logging&gt; =&gt; String&gt; -&gt; FreeVL effects ()&gt; logMsg msg = LiftVL (`logEff` msg)&gt; &gt; getRand :: HasEffect 效果随机&gt; =&gt; FreeVL 效果 Int&gt; getRand = LiftVL getRandEff&gt; &gt; 暂停 :: HasEffect 效果 Suspend&gt; =&gt; Int&gt; -&gt; FreeVL 效果 ()&gt; 暂停i = liftVL (`suspendEff` i) 有了这些组合器，我们就可以编写程序了！让我们编写一个程序来发出一个网络请求，如果失败，则暂停 100 毫秒并重试。它将重试随机次数。</p><p>&gt; repeatReq :: ( HasEffect effects Http&gt; , HasEffect effects Random&gt; , HasEffect effects Suspend&gt; )&gt; =&gt; Url&gt; -&gt; FreeVL effects (Either Int (Response ByteString))&gt; repeatReq url = do&gt; numRetries &lt;- (flip mod 10) ) getRand&gt; eResponse &lt;- getHttp url&gt; go numRetries eResponse&gt; where&gt; go 0 r = return r&gt; go i _ = do&gt; eResponse &lt;- getHttp url&gt; case eResponse of&gt; r@(Right _) -&gt; return r&gt; l @(Left _) -&gt; suspend 100 &gt;&gt; go (i-1) eResponse &gt; withLog :: HasEffect effects Logging&gt; =&gt; String&gt; -&gt; String&gt; -&gt; FreeVL effects a&gt; -&gt; FreeVL effects a&gt; withLog preMsg postMsg program = do&gt; logMsg preMsg&gt; a &lt;- program&gt; logMsg postMsg&gt; return a 最后，让我向您展示，我们可以通过将我们之前的 repeatReq 代码与日志记录和提供 url 一起包装来组合任意程序和效果堆栈。 &gt; -- 让我们结合一些程序&gt; program :: ( HasEffect effects Http&gt; , HasEffect effects Random&gt; , HasEffect effects Suspend&gt; , HasEffect effects Logging&gt; )&gt; =&gt; FreeVL effects (Either Int (Response ByteString))&gt; program = withLog &quot;运行请求！” “完毕！” (repeatReq &quot;http://aaronlevin.ca&quot;) 请注意，如果您删除这些约束之一（例如 Suspend），您将收到一个编译错误：01.lhs:313:49:Could not deduce (HasEffect effects Suspend ) 从上下文（HasEffect 效果 Http、HasEffect 效果随机、HasEffect 效果记录）中使用 &#39;repeatReq&#39; 产生，由程序的类型签名约束 ::（HasEffect 效果 Http、HasEffect 效果随机、HasEffect 效果记录）=&gt; FreeVL effects (Maybe (Response ByteString)) at 01.lhs:(308,14)-(312,57) 在 &#39;withLog&#39; 的第三个参数中，即 &#39;(repeatReq &quot;http://aaronlevin.ca&quot;)&#39; 中表达： withLog &quot;正在运行的请求！&quot; “完毕！” (repeatReq &quot;http://aaronlevin.ca&quot;) 在 &#39;program&#39; 的等式中： program = withLog &quot;running request!&quot; “完毕！” (repeatReq &quot;http://aaronlevin.ca&quot;) 现在我们已经编写了一些程序，我们需要提供一些解释器。我们将提供 IO 中的主要解释器，并将其作为练习留给读者来创建一个纯粹的解释器。</p><p>回想一下 van Laarhoven Free Monad 中的解释器只是一个 effect m 类型的值。同样，在效果堆栈版本中，它是一个 EffectStack 效果 m 类型的值，它只是我们效果的 HList。 &gt; -- 一个使创建 HList 在语法上更好的组合器。&gt; (.:.) :: effect m -&gt; EffectStack effects m -&gt; EffectStack (effect &#39;: effects) m&gt; effect .:. effects = ConsEffect effect effects&gt; infixr 4 .:.&gt; &gt; -- 解释IO中的http动作&gt; handleExcep :: HttpException -&gt; Each Int a&gt; handleExcep (StatusCodeException status _ _) = Left (S.statusCode status)&gt; handleExcep _ =错误“未处理的 HttpException”&gt; &gt; httpIO :: Http IO&gt; httpIO =&gt; Http { getHttpEff = \req -&gt; (Right get req) `catch` (return .handleExcep)&gt; , postHttpEff = \req body -&gt; (Right post req body) `catch` (return .handleExcep)&gt; }&gt; &gt; -- 解释 IO 中的日志操作&gt; logIO :: Logging IO&gt; logIO = Logging { logEff = putStrLn }&gt; &gt; -- IO 中的随机数生成器&gt; randIO :: Random IO&gt; randIO = Random { getRandEff = randomIO }&gt; &gt; -- 在IO中暂停&gt; suspendIO :: Suspend IO&gt; suspendIO = Suspend { suspendEff = threadDelay }&gt; &gt; -- 我们的效果栈&gt; type MyEffects = ( Http &#39;: Logging &#39;: Random &#39;: Suspend &#39;: &#39;[] )&gt; &gt; -- 我们的解释器&gt; ioInterpreter :: EffectStack MyEffects IO&gt; ioInterpreter = httpIO .:.日志IO .:.随机数 .:.暂停IO .:. EmptyEffect 希望现在您已经确信我们已经实现了我们的目标：我们可以在 Haskell 中针对效果进行编程，就像我们使用 Idris 和 PureScript 编程的同志一样（我说这完全是半开玩笑）。此外，我们可以提供任意效果堆栈并以我们想要的任何方式组合解释器（只要它们共享相同的 monad）。调查程序分析。 van Laarhoven Free Monad 只是一个函数，但我们可以为它提供一个为程序或静态分析构建的效果堆栈吗？</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://aaronlevin.ca/post/136494428283/extensible-effect-stacks-in-the-van-laarhoven-free">https://aaronlevin.ca/post/136494428283/extensible-effect-stacks-in-the-van-laarhoven-free</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/laarhoven/">#laarhoven</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/effects/">#effects</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gt/">#gt</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>