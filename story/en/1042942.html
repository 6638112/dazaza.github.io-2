<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何不教递归 How Not to Teach Recursion</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How Not to Teach Recursion<br/>如何不教递归 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-02 17:06:34</div><div class="page_narrow text-break page_content"><p>We all know how to teach recursion. We’ve done it for decades. We pick somehonored, time-tested examples— Fibonacci numbers and factorial being leadingcandidates— and use them to teach the general idea. They’re so canonical theycome directly from the gods: you can find these in books by people likeNiklaus Wirth.</p><p>我们都知道如何教授递归。我们已经做到了数十年。我们选择了一些久经考验的示例-斐波那契数和阶乘为领先的候选人-并用它们来教授总体思想。它们是如此经典，直接来自神灵：您可以在书中找到尼古拉斯·沃思（Niklaus Wirth）这样的人。</p><p> But I’m here to tell you they got it wrong, and everyone’s been getting itwrong ever since. Students come away underwhelmed and baffled, and go on tobecome the next generation of teachers who repeat this process. However, weneed not repeat this cycle; we have much better methods.</p><p> 但我在这里告诉您他们弄错了，从那以后每个人都在弄错。学生们不知所措，困惑不解，继续成为重复此过程的下一代教师。但是，我们不需要重复此循环。我们有更好的方法。</p><p>  Let’s start by looking at what’s wrong with our canonical examples.</p><p>  首先，我们来看一下规范示例中的问题。</p><p>  First off, almost nobody has ever needed to compute a factorial. I’ve beenprogramming for about 35 years and the only times I’ve needed to compute afactorial was when doing recreational mathematics or using programming toexplore some especially thorny combinatorics problem. Otherwise, I’ve never hadany need for factorials.</p><p>  首先，几乎没有人需要计算阶乘。我已经进行了大约35年的编程，而我唯一需要计算阶乘的时间是在做休闲数学或使用编程来探究一些特别棘手的组合问题时。否则，我永远不需要阶乘。</p><p> Second, the answer isn’t  meaningful. Quick, what’s the factorial of 13?Most people have no idea and (related to the above) don’t care. There’s nothingrecognizable about the answer. The only reason most programmers recognize thenumber 3628800 is because we’ve tested factorial on a “big enough number” toconfirm that it worked, not because we actually cared about it. If you adopt acurriculum that asks students to  develop examplesbefore they write code, students would be hard-pressed to write the answerindependently; many would resort to implementing it first and plugging in theanswer.</p><p> 其次，答案没有意义。很快，13的阶乘是多少？大多数人不知道，并且（与上述情况有关）不在乎。答案无法辨认。大多数程序员认可3628800的唯一原因是因为我们已经在“足够大的数字”上测试了阶乘以确认其有效，而不是因为我们实际上对此很在意。如果您采用要求学生在编写代码之前先开发示例的课程，则学生很难独立地编写答案。许多人会首先实施它并插入答案。</p><p> Third, factorial has poor numeric properties in most languages. Unless you havebuilt-in, automatic support for big numbers, you will soon either get answersthat print in odd-looking scientific notation, or worse, overflow (on manylanguages, with default integers, factorial of 17 is -288522240).</p><p> 第三，阶乘在大多数语言中具有较差的数值属性。除非您具有对大数的内置自动支持，否则您很快就会获得以奇怪的科学计数形式显示的答案，或者更糟的是会出现溢出（在许多语言中，使用默认整数，阶乘17是-288522240）。</p><p> Finally, many students have written factorial-like programs before, perhapseven factorial itself, using loops. A natural question they (should!) ask aninstructor is, “Why should I do this again?” The answer, inevitably, is,“Because I’m asking you to.” There’s no better way to turn off a student.</p><p> 最后，许多学生甚至使用循环编写了类似阶乘的程序，甚至连阶乘本身也是如此。他们（应该！）向教师问的一个自然问题是：“为什么我要再次这样做？”答案不可避免地是：“因为我要你这样做。”没有更好的方法来关闭学生。 </p><p> So let’s summarize the “recursion experience”: a useless problem, withunrecognizable answers, with wonky-looking behavior, using an unnecessary newtechnique that you’re forced to use “because”.</p><p>因此，让我们总结一下“递归体验”：一个无用的问题，无法识别的答案，行为古怪，使用不必要的新技术，而您不得不使用“因为”。</p><p>   First off, almost nobody has ever needed to compute a Fibonacci number,either. I’ve been programming for about 35 years and the only times I’ve neededit was when doing recrea— you see where this is going.   I do find themuseful to convert beween miles and kilometers, though.</p><p>   首先，几乎没有人需要计算斐波那契数。我已经进行了大约35年的编程，而我唯一需要的时间就是进行recrea时，您会知道它的发展方向。不过，我确实发现它们在转换英里和公里之间很有用。</p><p> Second, the answer isn’t meaningful, and students would again be hard-pressedto write the answer independently (what, keep track of all thosecalls?!?). Third, it has poor numeric properties: around 44, Fibonacci iscorrect, then becomes negative (which is obviously incorrect), then immediatelyagain is a very reasonable-looking positive number that just happens to becompletely wrong. The main reason we haven’t cared for decades is because wereally just don’t have much use for Fibonacci numbers.</p><p> 其次，答案没有意义，并且学生将再次很难独立编写答案（什么，要跟踪所有这些呼叫？！？）。第三，它的数字特性很差：大约44，斐波那契是正确的，然后变成负数（这显然是不正确的），然后立即又是一个看起来非常合理的正数，而恰好是完全错误的。我们几十年来一直不在意的主要原因是，因为斐波纳契数在总体上用处不大。</p><p>  So let’s summarize the “recursion experience”: a useless problem, withunrecognizable answers, with wonky-looking behavior, that runs really sloooowly(and worse, the slowness first creeps up on you stealthily and then suddenlyadministers a hammer-blow to the back of your head). In fact, its main value isas a function that you should  not write (straightforwardly) recursively.</p><p>  因此，让我们来总结一下“递归体验”：一个毫无用处的问题，无法识别的答案，看上去很古怪的行为，确实运行得很慢（更糟的是，缓慢性首先悄悄地蔓延到您身上，然后突然对您的后背进行锤击）头）。实际上，它的主要价值是一个您不应递归编写的函数。</p><p>     Okay, I’ll grant, many students have at least heard of the greatest commondivisor. They may vaguely recall using it in school for dealing withfractions. So it has familiarity going for it.</p><p>     好吧，我会答应的，很多学生至少听说过最伟大的除数。他们可能会隐约记得在学校中使用它来处理违规情况。因此它很熟悉。</p><p> Unfortunately, it was useful in a context that  no longer makessense. Once you have a programming language, you have a calculator. Unlessyou’re implementing a calculator (and perhaps even then), you have no real needto implement Euclid’s algorithm.</p><p> 不幸的是，它在不再有意义的情况下很有用。一旦有了编程语言，便有了计算器。除非您要实现计算器（也许甚至在那时），否则您就不需要实现Euclid的算法。</p><p> And even if you do, admit it: you don’t remember why Euclid’s algorithmworks. I certainly have to re-derive why it produces the right answer everytime I’ve implemented it (purely for illustrative purposes, every fewyears). Otherwise, it’s just a mystical pattern.</p><p> 即使这样做，也要承认：您不记得为什么Euclid的算法有效。我当然必须重新推论为什么每次实施该解决方案（每隔几年就出于说明目的）都会产生正确的答案。否则，这只是一个神秘的模式。 </p><p> So what’s the lesson we get from Euclid’s algorithm? That recursion is forencoding mystical patterns for no-longer-useful functions? In fact, isrecursion useful for anything  other than weird math functions?</p><p>那么我们从Euclid算法中得到的教训是什么？那个递归是为不再有用的功能预编码了神秘的模式吗？实际上，除了怪异的数学函数以外，递归对其他有用吗？</p><p>   First, we’ll start with some invented Eastern mysticism. Orientalism is alwaysa good pedagogic device, right?</p><p>   首先，我们将从一些发明的东方神秘主义开始。东方主义永远是一种很好的教学手段，对吗？</p><p> Next, it’s a problem fraught with questions of representation: how exactly doyou represent the content of the towers? That is actually a somewhatinteresting question for a beginning student, but (a) it’s not obvious untilyou’ve had some programming practice, and (b) it has absolutely nothing to dowith recursion. So you have a hard, unrelated sub-problem in the middle of yourexample that “demonstrates” recursion. Doesn’t that utterly violate thepedagogic principle of changing just one thing at a time so students can focuson what’s salient? (And don’t forget, this is another problem with exponentialtime behavior!)</p><p> 接下来，这是一个充满代表性问题的问题：您如何精确地代表塔楼的内容？对于初学者来说，这实际上是一个有趣的问题，但是（a）在您进行过编程实践之前并不明显，并且（b）与递归完全无关。因此，您的示例中间存在一个困难的，无关的子问题，它“证明”了递归。难道这完全违反了一次只改变一件事，使学生可以专注于哪些显着性的教学原则吗？ （并且不要忘记，这是指数时间行为的另一个问题！）</p><p> Furthermore, if you don’t tell students the (recursive) solution and leave themto figure it out for themselves, you haven’t given them a programming problem:you’ve given them a puzzle. Those are different things. In particular, theTowers of Hanoi is a particularly  difficult kind of recursion— oh, youdidn’t know there are different kinds of recursion? Read on.</p><p> 此外，如果您不告诉学生（递归）解决方案并让他们自己解决问题，那么您就没有给他们带来编程上的问题：您给了他们一个难题。那是不同的东西。尤其是，河内之塔是一种特别困难的递归-哦，您不知道会有不同的递归吗？继续阅读。</p><p> Finally, again, does anyone care? Do students believe they would be called onto help monks move disks around? What other problem is similar to this one? Andif there are any, do we teach them, or do we present these magnificentlyisolated monks…in magnificent isolation?</p><p> 最后，再次有人在乎吗？学生是否相信他们会被召唤帮助僧侣移动磁盘？还有什么其他问题与此类似？如果有的话，我们应该教他们吗，或者我们要以宏伟的隔离呈现这些宏伟的隔离僧侣？</p><p> What’s worse is that so many of these are fundamentally  static problems:there are only so many interesting inputs, and each one has a completelydeterministic solution, so once one builds up a table of outputs for standardinputs, the problem is essentially solved. For such problems, it would be smart(especially when the run-time complexity is exponential in the input) to juststash the answers and never run the code again.   Yes, I know,memoization.</p><p> 更糟糕的是，这些问题中有许多根本上是静态问题：只有那么多有趣的输入，并且每个输入都有一个完全确定性的解决方案，因此，一旦为标准输入建立了输出表，就可以从根本上解决问题。对于此类问题，明智的做法（尤其是当输入中的运行时复杂度呈指数级时）仅存储答案，而不必再次运行代码。是的，我知道。</p><p>  Another standard, time-honored pedagogic device is the dumb joke: “tounderstand recursion you must understand recursion”, and so on.</p><p>  另一个久经考验的标准教学方法是愚蠢的笑话：“要理解递归，您必须理解递归”，依此类推。 </p><p>  If you don’t understand the difference, don’t use the dumb jokes.</p><p>如果您不了解其中的区别，请不要使用愚蠢的笑话。</p><p> If you do understand the difference, don’t use the dumb jokes theneither. They’re still  dumb jokes.</p><p> 如果您确实了解其中的区别，那就不要使用愚蠢的笑话。他们仍然是愚蠢的笑话。</p><p>  An attempt at a better answer might be that a  problem is “inherently”recursive. However, that’s just a limitation of viewpoint. There’s nothing moreinherently recursive than iterative about factorial. All the problems above canbe expressed even more declaratively, as in a mathematical specification, thateliminates any implementation directive (e.g.: the greatest common divisor is the greatest,  common,  divisor: the definition of the problemsays nothing about how to find it, and searching through all numbers to finddivisors that are common and taking the largest one is no less valid asolution).</p><p>  尝试更好的答案可能是问题是“固有的”递归的。但是，这只是观点的局限。关于阶乘的迭代本来就是递归的。上面的所有问题都可以用数学上的说明来更明确地表达，从而消除任何实现指令（例如：最大公约数是最大公约数）：问题的定义与如何查找和搜索无关。找出所有最常见且除数最大的除数的有效解决方案）。</p><p>    But I know, I can’t just stop here. So I’ll give you a brief peek of how toproceed.</p><p>    但我知道，我不能就此止步。因此，我将简要介绍如何进行。</p><p> In   How to Design Programs ( ), we have a rather different view ofrecursion. The key idea is this.</p><p> 在“如何设计程序”（）中，我们对递归有不同的看法。关键思想是这样。</p><p>  Where does recursion come from?   argues that it arises from self-references in data. That is,  recursive data suggest recursivesolutions. This is the key insight you need for understanding recursion. Notonly does it make sense once you think about it, it also demonstrates why mostother approaches to teaching recursion are essentially incorrect.</p><p>  递归来自哪里？认为这源于数据的自我参照。也就是说，递归数据建议使用递归解决方案。这是您了解递归所需的关键见解。一旦您考虑了它，它不仅有意义，而且还证明了为什么大多数其他递归教学方法本质上是不正确的。</p><p> teaches a design “recipe”. In it, you describe your program’s (orfunction’s) data structures, and identify self-references in thesedata. Self-referential data are pretty straightforward: even kids can understandthem. For instance, even a child informed about biology can answer basicquestions like these:</p><p> 讲授设计“配方”。在其中，您可以描述程序（或函数）的数据结构，并在这些数据中标识自我引用。自我指称数据非常简单：甚至孩子也可以理解它们。例如，即使是一个了解生物学的孩子，也可以回答以下基本问题： </p><p>  They can see where this goes. They grasp the idea of a (biological) family treepretty intuitively. They can similarly see other kinds of self-referential dataeven at a young age, well before they program.</p><p>他们可以看到结果。他们非常直观地掌握了（生物）家谱的想法。他们甚至可以在编程之前就在很小的时候就看到其他类型的自我参照数据。</p><p> Next,   explains how the structure of the data suggest a structure to thesolution. This solution structure is generic, and called the “template”. Youarrive at this entirely mechanically from the data structure, even beforeyou’ve contemplated the exact problem you’re trying to solve.</p><p> 接下来，说明数据的结构如何暗示解决方案的结构。此解决方案结构是通用的，称为“模板”。您甚至完全没有想过要解决的确切问题，就从数据结构中完全机械地做到了这一点。</p><p> (The template is not a rule, it’s a suggestion. It helps you overcome the“blank page” problem by offering the outline of a suggestion. Sometimes, thetemplate leads to a correct but insufficiently-efficient solution. Such asolution is still useful as a reference solution against which to test moreefficient proposals.)</p><p> （模板不是一个规则，它是一个建议。它通过提供建议的概述来帮助您克服“空白页”问题。有时，模板会导致正确但效率不高的解决方案。测试更有效提案的参考解决方案。）</p><p> Separately, you write down examples of your problem. In the process you explorehow the self-reference in the solution (what one would call “recursion”) canhelp you solve the task. (  Programming and Programming Languages explores this in more detail.)</p><p> 另外，您写下问题的示例。在此过程中，您将探索解决方案中的自引用（称为“递归”）如何帮助您解决任务。 （“编程和编程语言”对此进行了更详细的探讨。）</p><p> And that’s where recursive functions come from. This form of recursion iscalled structural recursion, because the recursive form follows the structureof the datum.</p><p> 这就是递归函数的来源。这种递归形式称为结构递归，因为递归形式遵循基准的结构。</p><p>  One of the added advantages of working with recursive data is that a givendatatype will often generate many problems. This has the virtue of seting upcomparisons and contrasts. A student’s effort at getting familiar with thedatatype and writing good examples of it can pay off in multiple settings.</p><p>  使用递归数据的其他优点之一是，给定的数据类型通常会产生许多问题。这具有建立比较和对比的优点。学生努力熟悉数据类型并编写好的示例可以在多种设置中获得回报。</p><p> Students can also be exposed to different datatypes for the same problemspace (as I discuss below). This lets them contemplate the benefits anddisadvantages that each representation has over the others. This is a problemof general value, unrelated to recursion, that hasn’t been studied enough,but it also lends itself particularly well to recursive settings.</p><p> 学生也可以针对相同的问题空间使用不同的数据类型（如下所述）。这使他们可以考虑每种表示形式相对于其他表示形式的利弊。这是一个与递归无关的通用价值问题，尚未得到足够的研究，但它也特别适合于递归设置。 </p><p>  Later, HtDP teaches  generative recursion, where it doesnot. Generative recursion requires an “a ha!”, because you have to come up withthe non-structural solution.   Why the term “generative”? Read the book.Consider, for instance, lists defined recursively with a singleton head and therest of the list as a tail. For such lists, there is a  natural sortingalgorithm: the one that follows structurally.</p><p>后来，HtDP教授生成递归，而递归则没有。生成递归需要一个“ ha！”，因为您必须提出非结构性解决方案。为什么使用“生成式”一词？阅读本书，例如考虑以单例头递归定义的列表，列表的其余部分作为尾部。对于这样的列表，有一个自然的排序算法：结构上遵循的一种。</p><p>  I say it’s “natural” because it’s the one you would arrive at with the leastwork and that best reflects the structure of the datum. Other standard sortingsolutions require some generative step.</p><p>  我说这是“自然的”，因为它是您用最少的工作就能得到的，并且最能反映出基准的结构。其他标准分类解决方案需要一些生成步骤。</p><p> However, what is structural varies, naturally, by the structure. Imagine youinstead represent lists by appending two sub-lists.</p><p> 但是，结构自然会因结构而异。想象一下，您将通过附加两个子列表来表示列表。</p><p>   In principle, natural numbers are also recursive data: a number is either zeroor the successor of another natural number. However, this way of thinking isnot natural to students (most don’t see natural numbers and immediately think,“Oh, a self-referential datatype!” the way they learn to with, say, a tree). So  introduces recursion over the naturals much later than other booksdo. It’s just not that interesting.</p><p>   原则上，自然数也是递归数据：数字要么为零，要么为另一个自然数的后继。但是，这种思维方式对学生而言并不自然（大多数人看不到自然数，而是立即想到“哦，一种自我参照的数据类型！”，例如他们学习树的方式）。因此，比其他书本更晚地引入自然递归。只是没那么有趣。</p><p> Given this setup, we can actually see problems like factorial and Fibonacci asstructurally recursive functions. Euclid’s Algorithm is still notstructural— it’s very much generative. Towers of Hanoi sits in an interestingmiddle ground. But we’ve already seen why those problems are awful, so there’sno need to dwell on them further!</p><p> 通过这种设置，我们实际上可以看到像阶乘和斐波那契这样的结构递归函数。 Euclid的算法仍然不是结构性的-它非常具有生成性。河内的塔楼坐落在一个有趣的中间地带。但是我们已经知道了为什么这些问题很糟糕，因此无需进一步讨论它们！</p><p>  The power of recursion lies not only in capturing certain patterns of data, butalso in generalizing loops. You can accumulate data, as you would with loops,but you can also return data, even return data  as you process. Butrecursion is even more useful than that: you can recur  mutually,capturing rich patterns of interconnection in data. For an unusual example ofthis, see this paper.</p><p>  递归的力量不仅在于捕获某些数据模式，还在于概括循环。您可以像使用循环一样累积数据，但也可以返回数据，甚至在处理过程中也返回数据。但是，递归甚至比这更有用：您可以相互递归，捕获数据互连的丰富模式。有关此示例的不寻常示例，请参见本文。</p><p>  It sure was! I’ve tried to distill a few hundred pages down to aboutone. The un-distilled   is available, fully and for free, online.</p><p>  肯定是！我试图将几百页内容精简为一个。未蒸馏的溶液可完全免费在线获得。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://parentheticallyspeaking.org/articles/how-not-to-teach-recursion/">https://parentheticallyspeaking.org/articles/how-not-to-teach-recursion/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/递归/">#递归</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/teach/">#teach</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>