<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>具有Comonad、可表示函子和依赖类型的元胞自动机</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">具有Comonad、可表示函子和依赖类型的元胞自动机</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-19 13:52:16</div><div class="page_narrow text-break page_content"><p>After reading Chris Penner&#39;s blog post on  Conway&#39;s Game Of Life Using Representable and Comonads, I decided to implement a similar solution for the 1 dimensional automata  Rule 110. Being such a simple algorithm I thought the implementation would be trivial. However, it turns out that working with arbitarily bounded spaces in the  Store Comonad requires a clever use of dependent types to apply memoizaition as described in Chris&#39; blog.</p><p>在阅读了克里斯·彭纳(Chris Penner)在Conway‘s Game of Life Using Represable and Comonads上的博客文章后，我决定为一维自动机规则110实现一个类似的解决方案。作为一个如此简单的算法，我认为它的实现将是微不足道的。然而，事实证明，在Store Comonad中使用任意限定的空间需要巧妙地使用依赖类型来应用回忆化，如Chris&#39；blog中所述。</p><p> This blog post walks through my experience attempting to use  Store,  Representable in Haskell to implement Rule 110, difficulty finding a suitable  Representable instance, and then a pivot to Idris where I was able to solve the problem using the finite set type  Fin n.</p><p>这篇博客文章讲述了我尝试使用Store(可在Haskell中表示)来实现规则110的经历，很难找到合适的可表示实例，然后转向Idris，在那里我能够使用有限集类型Fin n来解决问题。</p><p> The Rule 110 algorithm takes a vector of boolean values and applies a simple set of rules for transforming each index based upon its neighbors. You can think of it as a 1 dimensional variant of Conway&#39;s Game of Life, but with the twist that the first and last element of the vector are considered neighbors. In other words, the automata in Rule 110 exists on a circle rather then a line segment.</p><p>规则110算法采用布尔值的向量，并应用一组简单的规则，用于基于每个索引的邻居来转换每个索引。你可以把它想象成康威的“生活的游戏”的1维变体，但有一点不同，那就是矢量的第一个和最后一个元素被认为是邻居。换句话说，规则110中的自动机存在于圆而不是线段上。</p><p>   This post assumes no prior knowledge of Comonads, Representable Functors,  Fin n. The first few sections are intended to introduce these concepts by focusing on the actual implementations of their APIs.</p><p>这篇文章不假定事先了解Comonad、可表示的函数器、Fin n。前几节旨在通过重点介绍它们的API的实际实现来介绍这些概念。</p><p>  The  Store type can be thought of as a way to query some indexable state along with a cursor that queries into the store at some index.</p><p>Store类型可以被认为是一种查询某些可索引状态的方式，以及在某个索引处查询到存储区的游标。</p><p>  State is held implicitly in your query function and, as we shall see later, can be transformed through composition.</p><p>状态隐式保存在您的查询函数中，稍后我们将看到，状态可以通过组合进行转换。</p><p> As an example, we can construct a  Store whose implicit state is an infinite list of Booleans which we index into with an Integer:</p><p>例如，我们可以构造一个Store，其隐式状态是使用Integer对其进行索引的布尔值的无限列表：</p><p> initialStore ::  Store  Int  Bool  initialStore  =  Store query  0    where    query ::  Int  -&gt;  Bool   query i  = ( cycle [ True,  False])  !!  abs i</p><p>InitialStore：：Store Int Bool initialStore=Store query 0 where query：：int-&gt；Bool query i=(Cycle[True，False])！！腹肌I</p><p> The  Store API then allows us to do things like query arbitrary indices, shift around our cursor, and through its  Functor and  Comonad instances to perform transformations on the implicit state held inside the query function.</p><p>然后，Store API允许我们执行查询任意索引、移动光标以及通过其函数器和Comonad实例对查询函数内的隐式状态执行转换等操作。</p><p>     peek :: s  -&gt;  Store s a  -&gt; a  peek s ( Store query _)  = query s     peeks :: (s  -&gt; s)  -&gt;  Store s a  -&gt; a  peeks f ( Store query s)  = query (f s)</p><p>Peek：：s-&gt；Store s a-&gt；a Peek s(Store Query_)=查询s Peek：：(s-&&gt;s)-&gt；Store s a-&gt；a Peek f(Store Query S)=query(F S)。</p><p> peek disregards the current cursor and instead applies a new cursor to the store&#39;s query function.  peeks uses a function  s -&gt; s to modify the current cursor and then query the store with the new cursor.</p><p>PEEK忽略当前游标，转而将新游标应用于商店的查询函数。PEEKS使用函数s-&gt；s修改当前游标，然后使用新游标查询商店。</p><p>  seek :: s  -&gt;  Store s a  -&gt;  Store s a  seek s ( Store query _)  =  Store query s     seeks :: (s  -&gt; s)  -&gt;  Store s a  -&gt;  Store s a  seeks f ( Store query s)  =  Store query (f s)</p><p>Seek：：s-&gt；Store s a-&gt；Store s a查找f(Store Query S)=Store Query(F S)。</p><p> This covers are basic getters and setters, but what if we wanted a way to query multiple indices into our store?</p><p>这个封面是基本的getter和setter，但是如果我们想要一种向我们的商店查询多个索引的方法，该怎么办呢？</p><p>  peekMany :: [s]  -&gt;  Store s a  -&gt; [a]  peekMany xs store  =  fmap ( flip peek store) xs</p><p>PeekMany：：[s]-&gt；Store s a-&gt；[a]peekMany Xs store=FMAP(翻转peek store)Xs。</p><p> This function looks pretty good, but notice we are using  fmap. We can take advantage of polymorphism here allow use use of any  Functor:</p><p>此函数看起来相当不错，但请注意我们使用的是FMAP。我们可以在这里利用多态性，允许使用任何函数器：</p><p> peekFunctor ::  Functor f  =&gt; f s  -&gt;  Store s a  -&gt; f a  peekFunctor fs store  =  fmap ( flip peek store) fs</p><p>PeekFunctor：：functor f=&gt；f s-&gt；Store s a-&gt；f a peekFunctor fs store=FMAP(翻转peek store)fs</p><p> Now we can use any  Functor we want, but notice how we aren&#39;t using our cursor at all. This is a clue that we might be able to generalize this function further.</p><p>现在我们可以使用任何我们想要的函数器，但是请注意我们是如何根本不使用光标的。这是一个线索，表明我们也许能够进一步推广这个函数。</p><p> It would be great if we could modify  peekFunctor to use our cursor value without losing the current behavior of the function.</p><p>如果我们可以修改peekFunctor以使用我们的游标值，而不会丢失函数的当前行为，那就太好了。</p><p> If we replace the  f s parameter with a function  s -&gt; f s then we could apply the current cursor to our function and generate an  f s to generate our  f a output. Then if we want the precise behavior of  peekFunctor we can simply apply  const (x :: f s) and ignore the current cursor!</p><p>如果我们用函数s-&gt；f s替换f s参数，那么我们可以将当前游标应用于我们的函数，并生成f s来生成我们的f a输出。然后，如果我们想要peekFunctor的精确行为，我们可以简单地应用const(x：：fs)并忽略当前游标！</p><p> experiment ::  Functor f  =&gt; (s  -&gt; f s)  -&gt;  Store s a  -&gt; f a  experiment f store  =  fmap ( flip peek store) (f (pos store))</p><p>实验：：Functor f=&gt；(s-&gt；f s)-&gt；store s a-&gt；f a实验f store=FMAP(Flip Peek Store)(f(Pos Store))。</p><p>  pos ::  Store s a  -&gt; a   peek :: s  -&gt;  Store s a  -&gt; a   peeks :: (s  -&gt; s)  Store s a  -&gt; a   seek :: s  -&gt;  Store s a  -&gt; a   seeks :: (s  -&gt; s)  Store s a  -&gt; a   experiment ::  Functor f  =&gt; (s  -&gt; f s)  -&gt;  Store s a  -&gt; f a</p><p>POS：：Store s a-&&gt;；a Peek：：S-&&gt;；Store s a-&&gt;；a Peek：：(S-&&gt;；Store s a-&&gt;；a Seek：：S-&&gt;；Store s a-&gt；a Seek：：(S-&&gt;)Store s a-&&gt;；a实验：：Functor f=&gt；(s-&&gt;；f s)-&gt；商店s a-&gt；f a。</p><p>  The state of the system is stored implicitely inside the  s -&gt; a query function rather then in some data structure. Because of this, the only way to modify the state would be to modify the query function itself.</p><p>系统的状态隐含地存储在查询函数内，而不是存储在某种数据结构中。因此，修改状态的唯一方法是修改查询函数本身。</p><p> We can do this by first querying the current store to get an  a value and then apply some  a -&gt; b function to the value to produce a modified version of the state at that index.</p><p>为此，我们可以首先查询当前存储以获得a值，然后对该值应用某个a-&gt;b函数，以生成该索引处的状态的修改版本。</p><p> We can do this by pattern matching on our  Store then composing an  a -&gt; b function with our query function:</p><p>我们可以通过在Store上进行模式匹配来实现这一点，然后将a-&&gt;b函数与我们的查询函数组合在一起：</p><p> updateStoreState :: (a  -&gt; b)  -&gt;  Store s a  -&gt;  Store s b  updateStoreState f ( Store query s)  =  Store (f  . query) s</p><p>UpdateStoreState：：(a-&gt;b)-&gt；Store s a-&gt；Store s b updateStoreState f(Store Query S)=Store(f.。查询)%s。</p><p> updateStoreState allows you to modify the query result for all possible values inside the Store&#39;s implicit state. This signature shoud look familiar as it is  fmap and  Store is in fact a  Functor.</p><p>UpdateStoreState允许您修改Store隐式状态内所有可能值的查询结果。这个签名看起来应该很熟悉，因为它是FMAP，而Store实际上是一个函数器。</p><p> instance  Functor ( Store s)  where    fmap :: (a  -&gt; b)  -&gt;  Store s a  -&gt;  Store s b    fmap f ( Store query s)  =  Store (f  . query) s</p><p>实例函数(Store S)，其中FMAP：：(a-&gt;b)-&gt；Store s a-&gt；Store s b FMAP f(Store Query S)=Store(f.。查询)%s。</p><p> Now we can model successive transformations of the state through applications of  fmap. For example, using the  Store Int Bool example from earlier, we might want to apply  not :: Bool -&gt; Bool to invert the state of our system:</p><p>现在，我们可以通过应用FMAP来建模状态的连续转换。例如，使用前面的Store Int Bool示例，我们可能希望应用Not：：Bool-&gt；Bool来反转系统的状态：</p><p> initialStore ::  Store  Int  Bool  initialStore  =  Store query  0    where   query i  = ( cycle [ True,  False])  !! i     newState ::  Store  Int  Bool  newState  =  fmap  not initialStore</p><p>InitialStore：：Store Int Bool initialStore=Store query 0 where query i=(Cycle[True，False])！！I NewState：：Store Int Bool NewState=FMAP NOT InitialStore。</p><p>  newState  =  fmap  not initialStore    =  fmap  not ( Store query s)    =  Store ( not  . query) s</p><p>NewState=FMAP NOT InitialStore=FMAP NOT(Store Query S)=Store(NOT.。查询)%s。</p><p> Using this technique to model 3 manipulations of a system shows how each modification to the implicit state builds up a larger composed query function:</p><p>使用此技术对系统的3个操作进行建模，显示了对隐式状态的每次修改如何构建更大的组合查询函数：</p><p> newState :: (a  -&gt; b)  -&gt; (b  -&gt; c)  -&gt; (c  -&gt; d)  -&gt;  Store s a  -&gt;  Store s b  newState h g f store  =  fmap f ( fmap g ( fmap h store))    =  fmap f ( fmap g ( fmap h ( Store query s)))    =  fmap f ( fmap g ( Store (h  . query) s))    =  fmap f ( Store (g  . h  . query) s)    =  Store (f  . g  . h  . query) s</p><p>NewState：：(a-&&gt;b)-&&gt;；(b-&&gt;；c)-&&gt;；(c-&&gt;d)-&gt；Store s a-&gt；Store s b Newstate h g f store=FMAP f(FMAP g(FMAP H Store))=FMAP f(FMAP g(FMAP h(Store Query S)=FMAP f(FMAP g(Store(h.。查询)s)=FMAP f(存储(g。H.。查询)s)=存储(f.。G。H.。查询)%s</p><p> While elegant, modeling state transformations as function composition means that every time we query an index in a  Store, we must recalculate every single previous transformation going back to the original  Store query. Without caching these intermediate computations this will get very expensive.</p><p>虽然优雅，但将状态转换建模为函数组合意味着每次查询Store中的索引时，都必须重新计算返回到原始Store查询的每个先前的转换。如果不缓存这些中间计算，这将变得非常昂贵。</p><p> Luckily, Chris Penner showed us a fantastic solution for this using Representable Functors. We will look at  Representable shortly, but for now lets ignore the performance issue and focus on the tools we need to naively implement Rule 110.</p><p>幸运的是，Chris Penner使用可表示的函数器向我们展示了一个奇妙的解决方案。我们很快就会看一下Reportable，但现在让我们忽略性能问题，将重点放在我们需要的工具上，以便天真地实现规则110。</p><p>   Comonads are the dual of  Monads. Where  Monads introduce some effect to an argument via the form  a -&gt; m b,  Comonads introduce a notion of querying a structure for data (co-effects):</p><p>Comonad是单曲的对偶。单音节通过a-&gt；m b形式为论点引入一些效果，而单音节则引入查询数据结构的概念(共同效果)：</p><p> -- Monadic  a  -&gt; m a   repeat  :: a  -&gt; [a]   -- Comonadic  w a  -&gt; a   length  :: [a]  -&gt;  Int</p><p>--一元a-&&gt;m a重复：：a-&&gt;；[a]--并元w a-&gt；a长度：：[a]-&gt；整数。</p><p>  class  Functor w  =&gt;  Comonad w  where    extract :: w a  -&gt; a    duplicate :: w a  -&gt; w (w a)    extend :: (w a  -&gt; b)  -&gt; w a  -&gt; w b</p><p>类函数w=&gt；Comonad w其中Extract：：w a-&gt；a副本：：w a-&gt；w(W A)扩展：：(w a-&gt；b)-&gt；w a-&gt；w b。</p><p>  extract :: w a  -&gt; a   return  :: a  -&gt; m a     duplicate :: w a  -&gt; w (w a)   join :: m (m a)  -&gt; m a     extend :: (w a  -&gt; b)  -&gt; w a  -&gt; w b   (=&lt;&lt;) :: (a  -&gt; m b)  -&gt; m a  -&gt; m b</p><p>提取：：w a-&gt；a返回：：a-&gt；m副本：：w a-&gt；w(W A)联接：：m(M A)-&gt；m a扩展：：(w a-&gt；b)-&gt；w a-&gt；w b(=&lt；&lt；)：：(a-&gt；m b)-&gt；m a-&gt；m b。</p><p> If a defining characteristic of  Comonads in Haskell is to provide a mechanism for querying some structure for data, then we can almost definitionally say that  Store is a  Comonad.  Store is literally a mechnanism for querying a structure to produce data!</p><p>如果Haskell中Comonad的一个定义特征是提供一种查询数据结构的机制，那么我们几乎可以肯定地说Store是一个Comonad。存储实际上是查询结构以产生数据的机制！</p><p> instance  Comonad ( Store s)  where    extract ::  Store s a  -&gt; a   extract ( Store query s)  = query s      extend :: ( Store s a  -&gt; b)  -&gt;  Store s a  -&gt;  Store s b   extend f ( Store query s)  =  Store (\s&#39;  -&gt; f ( Store query s&#39;)) s</p><p>实例Comonad(Store S)WHERE Extract：：Store s a-&gt；a Extract(Store Query S)=查询s Extension：：(Store s a-&&gt;b)-&gt；Store s a-&gt；Store s b Extension f(Store Query S)=Store(\s&39；-&&gt;f(Store Query s&39；))s</p><p> extract applies the current cursor to the query function and  extend chains state transforming queries.</p><p>Extract将当前游标应用于查询函数，并扩展链状态转换查询。</p><p> extract is fairly trivial in this case, but  extend is a little trickier. It helps to think about in relation to our  fmap implementation.</p><p>在这种情况下，Extract相当简单，但Extension则稍微棘手一些。这有助于考虑与我们的FMAP实现相关的问题。</p><p> Like  fmap, it uses a function to modify our implicit state, but where  fmap composed a pure  a -&gt; b function with our query,  extend creates a new query function by applying your entire store to a comonadic action. This allows us to bring into scope the entire current store when modifying particular points in the store.</p><p>与FMAP一样，它使用一个函数来修改我们的隐式状态，但是当FMAP使用我们的查询组成一个纯a-&gt;b函数时，Extended通过将整个存储应用于一个共同的操作来创建一个新的查询函数。这允许我们在修改商店中的特定点时将整个当前商店纳入范围。</p><p> extend is extremely powerful and allows us to do really interesting things like create windowing functions and perform kernel convolution. It allows us to modify every single individual points in &#34;parallel&#34; using the entire state as context.</p><p>Extension非常强大，允许我们做一些非常有趣的事情，比如创建窗口函数和执行内核卷积。它允许我们使用整个状态作为上下文来修改并行中的每个单独的点。</p><p> One interesting example of extend is to perform a moving average on some time series data.</p><p>EXTEND的一个有趣的例子是对一些时间序列数据执行移动平均。</p><p> First we need a  Store modeling time sequenced data. We will use  Int for our Index and it will represent a single unit of time in a data stream. We want some fairly dynamic data source so I chose the Fibbonaci sequence. At each point in time (each index) we get the next Fibbonaci number.</p><p>首先，我们需要一个存储建模时间排序的数据。我们将使用Int作为索引，它将表示数据流中的单个时间单位。我们需要一些相当动态的数据源，所以我选择了Fibbonaci序列。在每个时间点(每个指数)，我们得到下一个Fibbonaci数。</p><p> fibStore ::  Store  Int  Int  fibStore  = store query  0    where    query ::  Int  -&gt;  Int   query  0  =  0   query  1  =  1   query n  = query (n  -  1)  + query (n  -  2)</p><p>FiStore：：store Int Int fib Store=store query 0 where query：：int-&gt；Int query 0=0 query 1=1 query n=query(n-1)+query(n-2)。</p><p> Now, if we want to calculate a window starting from a given cursor want some way to query for the subsequent points in time.  experiement will work perfectly here:</p><p>现在，如果我们想要从给定的游标开始计算一个窗口，需要某种方法来查询后续的时间点。体验将在这里完美发挥作用：</p><p>   Now notice the shape of  window is  Store Int a -&gt; [a]. That looks a lot like the comonadic action for  extend:  Store s a -&gt; b. We can use  extend to apply  window over the enter store:</p><p>现在请注意，窗口的形状是Store Int a-&gt；[a]。这看起来很像EXTEND：STORE s a-&gt；b的共同操作。我们可以使用EXTEND将窗口应用于Enter Store：</p><p>  Now if we  peek at any index in the store we see a window of the subsequent Fibonacci numbers!</p><p>现在，如果我们看一看商店中的任何指数，我们会看到一个随后的斐波纳奇数字的窗口！</p><p>   With the tools now available to us, we can make a first attempt at our Rule 110 algorithm.</p><p>有了现在可用的工具，我们可以第一次尝试我们的规则110算法。</p><p>  type  Index  =  Int     initializeStore :: [ Bool]  -&gt;  Store  Index  Bool  initializeStore xs  =  Store query  0    where    query ::  Index  -&gt;  Bool   query i  = xs  !! i</p><p>Type Index=Int initializeStore：：[Bool]-&gt；Store Index Bool InitializeStore xs=Store query 0 where query：：index-&gt；Bool query i=xs！！我。</p><p> We are modeling our initial state as a list and using an unsafe list lookup function for our query. This isn&#39;t ideal, but we are just trying to put together a rough draft.</p><p>我们将初始状态建模为列表，并对查询使用不安全的列表查找函数。这不是很理想，但我们只是在试着起草一份粗略的草稿。</p><p> Next we need a way to query an index and its neighbors. Just like our windowing function, we can use  experiment here.</p><p>接下来，我们需要一种查询索引及其邻居的方法。就像我们的窗口函数一样，我们可以在这里使用实验。</p><p>  _lookupIndices is a type hole we need to fill. By starting from  neighborValues we let GHC tell us what shape we need for  lookupIndices:</p><p>_lookupIndices是我们需要填充的类型空洞。从Neighbor Values开始，我们让GHC告诉我们lookupIndices需要什么形状：</p><p>    But which accounts for the fact that our automata lives on a circle not a line. We need to be able to identify the first and last index and use that information to select the correct neighbors.</p><p>但这解释了我们的自动机生活在一个圆上，而不是一条线上。我们需要能够识别第一个和最后一个索引，并使用该信息选择正确的邻居。</p><p> The first, simplest solution is to pass in the length of the list as a value:</p><p>第一个也是最简单的解决方案是将列表的长度作为值传入：</p><p> type  Index  =  Int   type  Size  =  Int     lookupIndices ::  Size  -&gt;  Index  -&gt; [ Index]  lookupIndices size i    | i  ==  0  = [size  -  1,  0,  1]    | i  == size  - 1  = [i  -  1, i,  0]    |  otherwise  = [i  -  1, i, i  +  1]     neighbors ::  Size  -&gt;  Store  Int  Bool  -&gt; [ Bool]  neighbors size  = experiment (lookupIndices size)</p><p>Type Index=Int type size=Int lookupIndices：：size-&gt；Index-&gt；[Index]lookupIndices size I|i==0=[size-1，0，1]|i==size-1=[i-1，i，0]|否则=[i-1，i，i+1]邻居：size-gt；Store Int Bool-&gt；[Bool]Neighbors size=实验(LookupIndices Size)。</p><p> With a mechanism to lookup the state for our index and its neighbors, we next need to use that information to calculate the next state of at our index. We can do this by casing on the output of  neighborValues:</p><p>通过一种机制来查找索引及其邻居的状态，我们接下来需要使用该信息来计算索引的下一个状态。我们可以通过使用NeighbValues的输出大小写来实现这一点：</p><p> Now we need to case on the state of the neighbors and apply our rubric to determine the new state at our index:</p><p>现在，我们需要对邻居的状态进行案例分析，并应用我们的准则来确定索引处的新状态：</p><p> newState ::  Size  -&gt;  Store  Index  Bool  -&gt;  Bool  newState size store  =    case neighbors size store  of   [ False,  False,  False]  -&gt;  False   [ True,  False,  False]  -&gt;  False   [ True,  True,  True]  -&gt;  False   _  -&gt;  True</p><p>NewState：：Size-&gt；存储索引Bool-&gt；Bool Newstate Size Store=案例邻居大小存储[False，False，False]-&gt；False[True，False，False]-&gt；False[True，True，True]-&gt；False_-&gt；True。</p><p> Lastly, we need a way to apply this transformation to the entire store to create the next generation of the automata.  extend to the rescue!</p><p>最后，我们需要一种将此转换应用于整个商店的方法，以创建下一代自动机。伸出援手去营救！</p><p> nextGen ::  Size  -&gt;  Store  Index  Bool  -&gt;  Store  Index  Bool  nextGen size  = extend (newState size)</p><p>NextGen：：Size-&gt；商店索引Bool-&gt；商店索引Bool NextGen Size=EXTEND(新州大小)。</p><p> Lets use equational reasoning to take a closer look at what happens when you call  nextGen:</p><p>让我们使用等式推理来仔细看看调用NextGen时会发生什么：</p><p> nextGen size store  = extend (newState size) store    = extend (newState size) ( Store query s)    =  Store (\s&#39;  -&gt; (newState size) ( Store query s&#39;)) s</p><p>下一代大小STORE=EXTEND(Newstate Size)STORE=EXTEND(Newstate Size)(Store Query S)=Store(\s&#39；-&&gt;；(Newstate Size)(Store Query s&#39；))s。</p><p>  nextGen size (nextGen size store)  = extend (newState size) (extend (newState size) store)    = extend (newState size) (extend (newState size) ( Store query s))    = extend (newState size) ( Store (\s&#39;  -&gt; (newState size) ( Store query s&#39;)) s)    =  Store (\s&#39;&#39;  -&gt; (newState size) ( Store (\s&#39;  -&gt; (newState size) ( Store query s&#39;)) s&#39;&#39;)) s</p><p>下一代大小(NextGen Size Store)=EXTEND(NESTATE SIZE)(EXTEND(NESTATE SIZE)STORE)=EXTEND(NESTATE SIZE)(EXTEND(NESTATE SIZE)(存储查询))=EXTEND(NESTATE SIZE)(Store(\s&39；-&gt；(Newstate Size)(Store Query s&#39；))s)=Store(\s&#39；&39；-&gt；(NEWSTATE SIZE)(STORE(\s&39；-&gt；(新州大小)(商店查询s&#39；))s&#39；&#39；))%s。</p><p> Its a little hard to grok, but if you squint your eyes a bit you can see that we are building up our  query function by chaining calls of  newState on the store. So whenever you query an index, the composed query function will apply  newState a bunch of times to your store.</p><p>这有点难理解，但是如果您稍微眯着眼睛就可以看到，我们正在通过链接商店上的newstate调用来构建我们的查询函数。因此，无论何时查询索引，组合查询函数都会多次将NEWSTATE应用到您的商店。</p><p> The last step to a working implementation is a function to view a store as a list. This isn&#39;t really a part of the algorithm per se, but we do want a way to view our results!</p><p>工作实现的最后一步是以列表形式查看商店的函数。这本身并不是算法的一部分，但我们确实想要一种查看结果的方式！</p><p> viewStore ::  Size  -&gt;  Store  Index  Bool  -&gt; [ Bool]  viewStore size store  = experiment ( const [ 0 ..size]) store</p><p>ViewStore：：Size-&gt；Store Index Bool-&gt；[Bool]viewStore Size store=实验(const[0..size])store。</p><p> To run the simulation we can use a recursive function in  IO to repeatedely print the result of  viewStore and then call  nextGen to update the state:</p><p>要运行模拟，我们可以在IO中使用递归函数来重复打印viewStore的结果，然后调用NextGen来更新状态：</p><p> runSimulation ::  Size  -&gt;  Store  Index  Bool  -&gt;  IO ()  runSimulation size store  =  do    print  $ viewStore size store   runSimulation size  $ nextGen size store</p><p>运行模拟：：SIZE-&gt；存储索引Bool-&gt；IO()Run模拟大小STORE=DO PRINT$viewStore SIZE STORE Run模拟大小$NextGen SIZE STORE。</p><p> This implementation does work, but if you try running it you will see that it has major performance issue. Extending a new generation means growing a chain of calls to  newState.</p><p>这个实现确实可以工作，但是如果您尝试运行它，您会发现它存在严重的性能问题。延长新一代意味着增加到新州的一系列电话。</p><p> This ever growing query function has to be calculated in full every time you peek into an index. We do that for every index at every generation when we call  runSimulation.</p><p>这个不断增长的查询函数在您每次查看索引时都必须进行完整的计算。当我们调用runSimulation时，我们对每一代的每个索引都这样做。</p><p> Its actually worse then that though! To calculate the new state at each index we also have to peek at its neighbors. So that means for every index we are repeating the same huge query 3 times!</p><p>不过，实际上比那更糟！要计算每个指数的新状态，我们还必须查看其邻居。因此，这意味着对于每个索引，我们将重复相同的巨大查询3次！</p><p>   A  Functor  f is representable if it has a corresponding type  Rep f that indexes  f completely. There must be a valid index into  f for every value of  Rep f and at the same time we must be able to construct a container where each element in the container is produced from its  Rep f index.</p><p>函数f是可表示的，如果它具有完全索引f的对应类型Rep f。对于Rep f的每个值，必须有一个有效的f索引，同时我们必须能够构造一个容器，其中容器中的每个元素都是从其Rep f索引中产生的。</p><p> Another more formal way of stating this is that there must exist an isomorphism between  f a and  Rep f -&gt; a. This isomorphism is witnessed by the  tabulate and  index functions from the  Representable typeclass:</p><p>另一种更正式的表述方式是，f a和Rep f-&gt；a之间必须存在同构。来自可表示类型类的表格和索引函数证明了这种同构：</p><p> class  Functor f  =&gt;  Representable f  where    type  Rep  f ::  *    tabulate :: ( Rep f  -&gt; a)  -&gt; f a    index :: f a  -&gt; ( Rep f  -&gt; a)</p><p>类函数f=&gt；可表示f，其中类型Rep f：：*Tablate：：(Rep f-&gt；a)-&gt；f a索引：：f a-&gt；(Rep f-&gt；a)。</p><p> It&#39;s hard to see exactly how this would be useful to us, but there is a clever trick we can play with  Representable to get memoization &#39;for free.&#39;</p><p>很难确切地看出这对我们有什么用处，但我们可以玩一个聪明的把戏，让代表人免费获得备忘录。</p><p> tabulate will takes some function that produces  a values from  Rep f values and then constructors a  Representable f containing an  a value for every possible  Rep f value.</p><p>TABLATE将接受一些函数，该函数从Repf值生成a值，然后构造一个可表示的f，其中包含每个可能的Repf值的a值。</p><p> index lets you use a  Rep f to query a  Representable f for  a values. One nice property of  Representable is that if you have a lawful instance then  index must be a safe function without the need for  Maybe!</p><p>索引允许您使用Rep f来查询a值的可表示f。RETRACTABLE的一个很好的属性是，如果你有一个合法的实例，那么索引必须是一个安全的函数，而不需要可能！</p><p>  The most obvious first choice for  Functor is  [], but what would we use for  Rep f?  Int doesn&#39;t work because you can&#39;t have a negative index into  [].  Nat almost works, but then what happes if the list is empty? Unfortunately there is no  Representable instance for  [].</p><p>函数器最明显的首选是[]，但是我们会对rep f使用什么呢？Int不起作用，因为您不能在[]中使用负索引。NAT几乎可以工作，但是如果列表为空会发生什么呢？遗憾的是，[]没有可表示的实例。</p><p> NonEmpty solves those problems, but it is still possible to have a  NonEmpty without an element for every  Nat.</p><p>NonEmpty解决了这些问题，但是对于每个NAT，仍然可以有一个没有元素的NonEmpty。</p><p>  newtype  Stream a  =  Cons a ( Strema a)   data  Nat  =  Z  |  S  Nat     instance  Functor  Stream  where    fmap :: (a  -&gt; b)  -&gt;  Stream a  -&gt;  Stream b    fmap f ( Stream a as)  =  Cons (f a) ( fmap f as)     instance  Representable  Stream  where    type  Rep f  =  Nat      tabulate :: ( Nat  -&gt; a)  -&gt;  Stream a   tabulate f  =  Cons (f  Z) (tabulate (f  .  S))      index ::  Stream a  -&gt;  Nat  -&gt; a    index ( Cons a as)  Z  = a    index ( Cons _ as) ( S n)  =  index as n</p><p>Newtype Stream a=CONS a(Strema A)数据NAT=Z|S NAT实例functor Stream Where FMAP：：(a-&gt;b)-&gt；Stream a-&gt；Stream b FMAP f(Stream A As)=CONS(F A)(FMAP F As)实例可表示流，其中type Rep f=NAT Tablate：：(NAT-&&gt;a)-&gt；Stream a Tablate f=CONS(F Z)(Tablate(f.。S))index：：stream a-&&gt;；NAT-&&gt;；a index(CONS A As)Z=a index(CONS_AS)(SN)=index as n。</p><p>  data  Identity a  =  Identity a     instance  Functor  Identity  where    fmap f ( Identity a)  =  Identity (f a)     instance  Representable  Identity  where    type  Rep f  = ()      tabulate :: (()  -&gt; a)  -&gt;  Identity a   tabulate f  =  Identity  $ f ()      index ::  Identity a  -&gt; ()  -&gt; a    index ( Identity a) ()  = a</p><p>数据标识a=标识实例函数器标识，其中FMAP f(标识a)=标识(F A)实例可表示标识，其中类型表示f=()TABLATLE：：(()-&gt；a)-&gt；标识a表f=标识$f()index：：标识a-&gt；()-&gt；a索引(标识a)()=a。</p><p> Since  Identity can only hold a single  a and  () is inhabited by a single value, this instance lawful and total. :)</p><p>由于标识只能包含单个a，并且()由单个值驻留，因此此实例是合法的和完全的。：)。</p><p> If our  Store had a single element  Identity would be perfect to represent queries into it and likewise, if it had an infinite amount of elements  Stream might be perfect. However, we are looking for something in between.</p><p>如果我们的Store只有一个元素，那么标识将非常适合表示对它的查询，同样，如果它有无限数量的元素，则Stream可能是完美的。然而，我们正在寻找介于两者之间的东西。</p><p> What we need is some sort of bounded data structure, but in order to make it  Representable we also need a corresponding bounded indexing type  Rep f.  Identity and  () is a great example of a such a bounded  Representable, but its bound at a fixed size of 1 element. We would like some  Functor f and  Rep f where we can fix the bound at whatever size we wish.</p><p>我们需要的是某种有界数据结构，但是为了使其可表示，我们还需要相应的有界索引类型Rep f。Identity和()就是这样的有界可表示的一个很好的例子，但是它的界限是1个元素的固定大小。我们想要一些函数器f和代表f，在那里我们可以将边界固定在我们想要的任何大小。</p><p> Another way of saying this is that we want is a family of  Representable functors and a family of corresponding  Rep f types, one pairing for each possible size boundary.</p><p>另一种说法是，我们想要的是一个可表示函数族和一个对应的Rep f类型族，每个可能的大小边界对应一个配对。</p><p> We can do this using  Vect n a and  Fin n a.  Vect is a fixed length vector whose length is encoded with a type level  Nat.  Fin is a finite natural whose maximum value is encoded with a type level  Nat.</p><p>我们可以使用Vect n a和Fin n a来实现这一点。Vect是一个固定长度的向量，其长度用类型级别NAT编码。FIN是有限自然数，其最大值使用类型级别NAT进行编码。</p><p> data  Vect ( n ::  Nat) a  where    VNil  ::  Vect  Z a    VCons  :: a  -&gt;  Vect n a  -&gt;  Vect ( S n) a     data  Fin ( n ::  Nat)  where    FZ  ::  Fin ( S n)    FS  ::  Fin n  -&gt;  Fin ( S n)</p><p>Data Vect(n：：NAT)a WHERE VNIL：：Vect Z a VCons：：A-&gt；Vect n a-&gt；Vect n a-&gt；Vect(SN)a Data FIN(n：：NAT)Where FZ：：FIN(SN)FS：：FIN n-&gt；Fin(SN)。</p><p> And like that, we have entered the world of dependent types. A world very messy and confusing in Haskell. It is now time to switch over to Idris, but don&#39;t worry all the implementations up to this point are identical modulo a few small syntax changes.</p><p>就这样，我们进入了依赖类型的世界。哈斯克尔的世界非常混乱和令人困惑。现在是时候切换到Idris了，但是不要担心到目前为止所有的实现都是相同的，只是稍有一些语法上的变化。</p><p>  interface  Functor f  =&gt;  Representable (f  :  Type  -&gt;  Type) (rep  :  Type)  | f  where    tabulate  : (rep  -&gt; a)  -&gt; f a    index  : f a  -&gt; rep  -&gt; a     Representable ( Vect n) ( Fin n)  where   tabulate f {n  =  Z}  = []   tabulate f {n  = ( S k)}  = f  FZ  :: tabulate (f  .  FS)   index (x  ::  _)  FZ {n  = ( S k)}  = x   index ( _  :: xs) ( FS x) {n  = ( S k)}  = index xs x</p><p>接口函数f=&gt；可表示(f：type-&gt；type)(rep：type)|f其中TABLATE：(rep-&gt；a)-&gt；f a索引：f a-&gt；rep-&gt；a可表示(Vect N)(Fin N)，其中TABLATE f{n=Z}=[]TABLATE f{n=(S K)}=f FZ：：TABLATE(f.。Fs)index(x：：_)fz{n=(Sk)}=x index(_：：xs)(FS X){n=(Sk)}=index xs x。</p><p> In Idris there is no distinction between the &#34;type level&#34; and &#34;term level.&#34; Types are first class values that can be passed around and worked with like any other values.</p><p>在Idris中，&#34；类型Level&#34；和&#34；Term Level之间没有区别。&#34；类型是一流的值，可以像任何其他值一样传递和使用。</p><p> Correspondingly, type parameters (such as the  n in  Vect n (Fin n) are the same as term level parameters and can be passed into functions and pattern matched on. You can see this in the definition of  tabulate above where the  n from  Vect n is wrapped in curly braces and treated like a function parameter.</p><p>相应地，类型参数(如Vect n(Fin N)中的n)与术语级别参数相同，可以传递到匹配的函数和模式中。您可以在上面的TABLATE定义中看到这一点，其中来自Vect n的n用大括号括起来，并被当作函数参数对待。</p><p> The curly braces indicate that it is an implict parameter. This means that the typechecker is able to infer the value of the parameter and the caller never has to explicitely pass a value in. This might seem like magic, but its very similar to the type inference you are used to with Haskell.</p><p>大括号表示它是一个隐式参数。这意味着类型检查器能够推断参数的值，调用者永远不需要显式地传入值。这可能看起来很神奇，但它非常类似于您在Haskell中习惯的类型推断。</p><p> With this instance of  Representable, the indexing type  Fin n cannot ever produce a value greater then  n - 1 and the  Functor must be of size  n. This is guaranteed at compile time.</p><p>使用此REFACTABLE实例，索引类型Fin n永远不能生成大于n-1的值，并且函数器的大小必须为n。这在编译时是有保证的。</p><p> This means that by choosing a different value for  n, we can have a  Representable instance for an arbitrary fixed length vector.</p><p>这意味着通过为n选择一个不同的值，我们可以为任意固定长度的向量提供一个可表示的实例。</p><p>  Now that we have switched over to Idris we need to rewrite our  Store type. We also need to make it to work with  Representable:</p><p>现在我们已经切换到Idris，我们需要重写Store类型。我们还需要使其与可代表合作：</p><p> data  Store  : ( Type  -&gt;  Type)  -&gt;  Type  -&gt;  Type  -&gt;  Type  where    MkStore  : rep  -&gt; f a  -&gt;  Store f rep a</p><p>数据存储：(类型-&gt;类型)-&&gt;；类型-&&gt;；类型-&&gt;类型MkStore：rep-&gt；f a-&gt；Store f rep a。</p><p> This version of  Store contains our current index (now called  rep) and our  Representable type  f a. We no longer have a query function. Instead we are going to store our state as data in the  R</p><p>这个版本的Store包含我们的当前索引(现在称为rep)和我们可表示的类型f a。我们不再有查询函数。相反，我们将把我们的状态存储为R中的数据。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.cofree.coffee/2020-10-17-bounded-space-automata/">https://blog.cofree.coffee/2020-10-17-bounded-space-automata/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/comonad/">#comonad</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/automata/">#automata</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/store/">#store</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>