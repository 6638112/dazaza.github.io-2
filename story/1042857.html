<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Concurrencpp –一个C ++并发库 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Concurrencpp –一个C ++并发库 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-02 08:21:55</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/ef812e52d976fb74194da576eed9833d.png"><img src="http://img2.diglog.com/img/2021/1/ef812e52d976fb74194da576eed9833d.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>concurrencpp是C ++的任务库，允许开发人员通过使用任务，执行程序和协程轻松安全地编写高度并发的应用程序。使用concurrencpp应用程序可以将需要异步处理的大型过程分解为可并行运行并可以在内部运行的较小任务。合作的方式来达到所需的结果。concurrencpp还允许应用程序使用并行协程轻松编写并行算法。</p><p>  能够编写现代并发代码，而不必依赖诸如锁和条件变量之类的低级并发原语。</p><p> 能够编写高度并发和并行的应用程序，这些应用程序可以根据需要自动扩展以使用所有硬件资源。</p><p> 通过使用C ++ 20协程和co_await关键字，可以轻松地编写非阻塞，类似同步的代码。</p><p> 通过使用具有内置同步功能的高级对象，减少争用条件，数据争用和死锁的可能性。</p><p>      concurrencpp是一个以任务为中心的库。任务是异步操作。与传统的以线程为中心的方法相比，任务为并发代码提供了更高级别的抽象。任务可以链接在一起，这意味着任务将它们的异步结果从一个传递到另一个，其中一个任务的结果就好像它是另一个正在进行的任务的参数或中间值一样使用。与可以使用原始线程相比，任务可以使应用程序更好地利用可用的硬件资源，并且规模更大，因为任务可以挂起，等待另一个任务产生结果，而不会阻塞底层的OS线程。任务使开发人员可以将更多的精力放在业务逻辑上，而不必将其放在线程管理和线程间同步等低层概念上，从而为他们带来了更高的生产力。</p><p> 任务指定必须执行哪些操作时，执行程序是指定执行任务的位置和方式的工作对象。执行人员可以自己为应用程序分配线程池和任务队列的管理权限。执行程序还通过提供用于创建和调度任务的统一API，将那些概念与应用程序代码分离开来。 </p><p>任务使用结果对象相互通信。结果对象是一个异步管道，它将一个任务的异步结果传递给另一个正在进行的任务。可以以无阻碍的方式等待和解决结果。</p><p> 这三个概念-任务，执行程序和相关结果是concurrencpp的基础。执行程序运行通过结果对象发送结果而彼此通信的任务。任务，执行程序和结果对象共生地协同工作，以生成快速，干净的并发代码。</p><p> concurrencpp是围绕RAII概念构建的。为了使用任务和执行程序，应用程序在主函数的开头创建一个运行时实例。然后，运行时用于获取现有执行程序并注册新的用户定义的执行程序。执行程序用于创建和调度要运行的任务，它们可能会返回结果对象，该结果对象可用于将异步结果封送给另一个充当其使用者的任务。运行时被破坏时，它将遍历每个存储的执行程序并调用其关闭方法。然后，每个执行者都会正常退出。计划外的任务被销毁，尝试创建新任务将引发异常。</p><p>  ＃include＆＃34; concurrencpp / concurrencpp.h＆＃34;＃include＆lt; iostream＆gt; int main（）{concurrencpp :: runtime运行时；自动结果=运行时间。 thread_executor（）-＆gt;提交（[] {std :: cout＆lt;＆lt;＆＃34; hello world＆＃34;＆lt;＆lt; std :: endl;}）;结果。得到（）;返回0;}</p><p> 在这个基本示例中，我们创建了一个运行时对象，然后从运行时获取了线程执行程序。我们使用Submit传递lambda作为给定的可调用对象。该lambda返回void，因此，执行程序返回结果。将异步结果封送回调用方的对象。 main调用将阻塞主线程，直到结果准备就绪为止。如果没有抛出异常，则get返回void。如果抛出异常，请重新抛出该异常。异步地，thread_executor启动一个新的执行线程并运行给定的lambda。它隐式co_return void并且任务已完成。然后将main解锁。</p><p>  ＃include＆＃34; concurrencpp / concurrencpp.h＆＃34;＃include＆lt; iostream＆gt;＃include＆lt; vector＆gt;＃include＆lt; algorithm＆gt;＃include＆lt; ctime＆gt;使用命名空间concurrencpp; std :: vector＆lt; int＆gt; make_random_vector（）{std :: vector＆lt; int＆gt; vec（64 * 1＆＃39; 024）; std :: srand（std :: time（nullptr））;对于（auto＆amp; i：vec）{i = :: rand（）; } return vec;} result＆lt; size_t＆gt; count_even（std :: shared_ptr＆lt; thread_pool_executor＆gt; tpe，const std :: vector＆lt; int＆amp; vector）{const auto vecor_size = vector。尺寸（）; const auto concurrency_level = tpe-＆gt; max_concurrency_level（）; const auto chunk_size = vecor_size / concurrency_level; std :: vector＆lt; result＆lt; size_t＆gt;＆gt; chunk_count; for（auto i = 0; i＆lt; concurrency_level; i ++）{const auto chunk_begin = i * chunk_size; const auto chunk_end =块开始+块大小;自动结果= tpe->提交（[＆amp; vector，chunk_begin，chunk_end]（）-> size_t {返回std :: count_if（vector。begin（）+ chunk_begin，vector。begin（）+ chunk_end，[]（auto i）{返回i％ 2 == 0;}）;}）; chunk_count。 emplace_back（std :: move（result））; } size_t total_count = 0; for（自动＆结果：chunk_count）{total_count + = co_await结果; } co_return total_count;} int main（）{concurrencpp :: runtime运行时； const auto vector = make_random_vector（）;自动结果= count_even（运行时.thread_pool_executor（），向量）; const auto total_count =结果。得到（）; std :: cout＆lt;＆lt; ＆＃34;有＆＃34; ＆lt;＆lt; total_count＆lt;＆lt; ＆＃34;向量＆＃34;中的偶数＆lt;＆lt; std :: endl;返回0;}</p><p> 在此示例中，我们通过创建运行时对象来启动程序。我们创建一个填充有随机数的向量，然后从运行时获取thread_pool_executor并调用count_even。 count_even是一个协程，它产生更多的任务并协同唤醒它们以在内部完成。 max_concurrency_level返回执行程序支持的最大工作程序数量，在线程池执行程序的情况下，工作程序数量是根据核心数量计算得出的，然后对数组进行分区以匹配工作程序数量，并在其数组中发送要处理的每个块自己完成任务。工作人员异步计算每个块包含多少个偶数，并共同返回结果。 count_even通过使用co_await拉计数来对每个结果求和，然后最终结果co_return。被调用get阻塞的主线程被取消阻塞并返回总计数。main打印偶数个数并且程序正常终止。 </p><p>Warning: Can only detect less than 5000 characters</p><p>线程池执行程序-维护线程池的通用执行程序。线程池执行程序适用于不阻塞的短CPU绑定任务。鼓励应用程序将此执行程序用作非阻塞任务的默认执行程序。concurrencpp线程池提供动态线程注入和动态工作平衡。</p><p> 阻塞执行程序-具有更大线程池的线程池执行程序。适用于启动简短的阻止任务，例如文件io和db查询。</p><p> 线程执行程序-执行程序，它启动每个排队的任务以在新的执行线程上运行。线程不被重用。此执行程序对于长时间运行的任务（例如运行工作循环的对象或长时间阻塞的操作）很有用。</p><p> 辅助线程执行程序-维护单个任务队列的单个线程执行程序。当应用程序需要专用线程来执行许多相关任务时，此方法非常适合。</p><p> 手动执行程序-本身不执行协程的执行程序。应用程序代码可以通过手动调用其执行方法来执行先前排队的任务。</p><p> 可派生执行程序-用户定义的执行程序的基类。尽管可以直接从concurrencpp :: executor继承，但是derivable_executor使用CRTP模式，该模式为编译器提供了一些优化机会。</p><p> 内联执行程序-主要用于替代其他执行程序的行为。使任务入队等效于内联调用它。 </p><p>执行程序的裸机制封装在其enqueue方法中，该方法将要执行的任务排队，并有两个重载：一个重载接收单个任务对象作为参数，另一个重载接收任务对象的范围，第二个重载是用于排队一批任务。这样可以更好地安排试探法并减少争用。</p><p> 应用程序不必单独依赖排队，concurrencpp :: executor提供了一个API，用于通过将用户可调用对象转换为幕后任务对象来调度用户可调用对象。应用程序可以请求执行者返回一个结果对象，该结果对象对可调用对象的异步结果进行了编组。提供可调用的。这是通过调用executor :: submit和execuor :: bulk_submit完成的。提交获取可调用对象，并返回结果对象。 executor :: bulk_submit获取可调用对象的范围并以类似于提交工作的方式返回结果对象的向量。在许多情况下，应用程序对异步值或异常不感兴趣。在这种情况下，应用程序可以使用executor ::: post和executor :: bulk_post安排要执行的可调用对象或可调用对象的范围，而且还告诉任务删除任何返回的值或引发的异常。不对异步结果进行封送比对封送进行封送要快，但是那样我们就无法知道正在进行的任务的状态或结果。</p><p> post，bulk_post，submit和bulk_submit在幕后使用底层调度机制。</p><p>  可以使用concurrencpp结果对象来消耗异步值和异常。结果对象是异步结果的管道，例如std :: future。当任务完成执行时，它要么返回有效值要么抛出异常。 ，此异步结果将编组到结果对象的使用者。因此，结果状态从空闲（异步结果或异常尚未准备好）到值（通过返回有效值终止的任务）到异常之间不等（任务因引发异常而终止）。</p><p> 结果对象是仅移动类型，因此，将它们的内容移动到另一个结果对象后将无法使用它们。在这种情况下，结果对象被认为是空的，并尝试调用除操作符bool和operator =之外的任何方法。将异步结果从结果对象中拉出之后（通过调用get，await或await_via），结果对象变为空。可以使用操作员布尔来测试是否为空。</p><p>   可以通过调用result :: wait，result :: wait_for，result :: wait_until或result :: get中的任何一个来等待结果。等待结果是一项阻塞操作（在异步结果未准备好的情况下），并将暂停等待异步结果可用的整个执行线程。通常不鼓励等待操作，并且仅在根级任务或允许它的上下文中允许等待操作，例如阻塞主线程以等待应用程序的其余部分正常完成，或者使用concurrencpp :: blocking_executor或concurrencpp :: thread_executor。</p><p> 等待结果意味着暂停当前协程，直到异步结果准备就绪。如果从关联的任务返回了有效值，则会从结果对象中减去该有效值。如果相关任务抛出异常，则将其重新抛出。在等待时，如果结果已经准备就绪，则当前协程将立即恢复。否则，它会由设置异步结果或异常的线程恢复。 </p><p>等待结果对象的行为可以通过使用await_via进行进一步的微调，该方法接受一个执行程序和一个布尔标志（force_rescheduling）。如果在等待的时候结果已经准备好了，则该行为取决于force_rescheduling如果force_rescheduling为true，则当前协程被强制挂起并在给定的执行器中恢复;如果force_rescheduling为false，则当前协程将立即在调用线程中恢复;如果异步结果在等待时尚未准备好，则当前通过设置结果在给定的提取器中运行，协程可以在设置结果后恢复。</p><p> 解决结果类似于等待结果。不同之处在于，co_await表达式将以就绪状态返回非空形式的结果对象本身。然后可以通过使用get或co_await来获取异步结果。就像await_via一样，resolve_via通过传递执行程序和标志来微调协程的控制流，该执行器和标志建议在结果准备好后如何执行操作。</p><p> 通过使用co_await（并同时将当前函数/任务也转换为协程）来等待结果对象是使用结果对象的首选方式，因为它不会阻塞底层线程。</p><p>  class result {/ *创建与任何任务都不相关的空结果。 * / result（）noexcept =默认值； / *销毁结果。相关任务不会被取消。析构函数不会阻止等待异步结果准备就绪。 * /〜result（）noexcept =默认值； / *将rhs的内容移动到* this。调用之后，rhs为空。 * / result（result＆amp;＆rhs）noexcept =默认值； / *将rhs的内容移动到* this。调用之后，rhs为空。返回* this。 * / result＆amp;运算子=（result＆amp;＆rhs）noexcept =默认值; / *如果这是非空结果，则返回true。如果this-＆gt;运算符bool（）为假，则应用程序不得使用此对象。 * /运算符bool（）const noexcept; / *查询* this的状态。返回值可以是result_status :: idle，result_status :: value或result_status :: exception中的任何一个。如果* this为空，则抛出concurrencpp :: errors :: empty_result。 * / result_status status（）const; / *当status（）！= result_status :: idle时，阻塞当前执行线程，直到准备好该结果。如果* this为空，则抛出concurrencpp :: errors :: empty_result。 * / void wait（）; / *阻塞，直到准备好结果或持续时间为止。解锁后返回此结果的状态。如果* this为空，则抛出concurrencpp :: errors :: empty_result。 * / template＆lt; ＆lt;等级持续时间单位，等级比率＆gt; result_status wait_for（std :: chrono :: duration＆lt; duration_unit，rat</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/David-Haim/concurrencpp">https://github.com/David-Haim/concurrencpp</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/任务/">#任务</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1042783.html"><img src="http://img2.diglog.com/img/2021/1/thumb_4127c1d751fd486005de4a5a9ebd8340.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042783.html">2020年首创（或C ++的好消息）– Herb Sutter </a></div><span class="my_story_list_date">2021-1-1 9:3</span></div><div class="col-sm"><div><a target="_blank" href="/story/1042200.html"><img src="http://img2.diglog.com/img/2020/12/thumb_13978cda23992f3c036f3b2810e7c91f.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042200.html">Wisp：用C ++编写的轻量级Lisp </a></div><span class="my_story_list_date">2020-12-28 22:47</span></div><div class="col-sm"><div><a target="_blank" href="/story/1042100.html"><img src="http://img2.diglog.com/img/2020/12/thumb_b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042100.html">东正教C ++ </a></div><span class="my_story_list_date">2020-12-28 5:47</span></div><div class="col-sm"><div><a target="_blank" href="/story/1041879.html"><img src="http://img2.diglog.com/img/2020/12/thumb_6aa94bd50df08daa9373a24000494d15.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1041879.html">Dev-C ++是内置于Delphi中的低内存Windows Native C ++ IDE </a></div><span class="my_story_list_date">2020-12-26 10:33</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>