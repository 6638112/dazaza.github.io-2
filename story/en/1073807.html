<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>关于在Bash中从头开始编写Minecraft服务器的思考My thoughts on writing a Minecraft server from scratch in Bash</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">My thoughts on writing a Minecraft server from scratch in Bash<br/>关于在Bash中从头开始编写Minecraft服务器的思考</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 11:30:45</div><div class="page_narrow text-break page_content"><p>For the past year or so, I&#39;ve been thinking about writing a Minecraft server in Bash as a thought excercise. I once tried that before with the Classic protocol (the one from 2009), but I quickly realized there wasn&#39;t really a way to properly parse binary data in bash. Take the following code sample:</p><p>在过去的一年左右，我&#39；我一直在考虑在Bash中编写一个Minecraft服务器作为一种思维练习。我曾经用经典的协议（2009年的协议）尝试过，但我很快意识到没有&#39；这并不是在bash中正确解析二进制数据的一种方法。以下面的代码示例为例：</p><p> function a() {	read -n 2 uwu	echo &#34;$uwu&#34; | xxd} This would read two bytes into a variable, and then pass them to `xxd`, which should show the hexdump of the data.</p><p>函数a（）{read-n2 uwu echo&#34；$uwu&#34；|xxd}这将把两个字节读入一个变量，然后将它们传递给`xxd'，后者将显示数据的十六进制转储。</p><p>   Everything&#39;s great, until we pass a nullbyte (0x00). Not only does Bash ignore nullbytes in strings, it also doesn&#39;t present any way to detect that a nullbyte has occured. Considering that the protocol I&#39;m trying to implement is strictly binary, this can severely mangle the data.</p><p>一切&#39；很好，直到我们传递一个空字节（0x00）。Bash不仅忽略字符串中的空字节，还不忽略&#39；不提供任何方法来检测是否发生了空字节。考虑到第一号议定书&#39；我试图实现的是严格的二进制，这可能会严重损坏数据。</p><p>    One rainy evening in late January, I&#39;ve had a revelation. What if I reversed the order of that function? If the binary data never reaches a variable (or, more precisely, a substitution), and just stays inside a pipe, can it pass nullbytes around?</p><p>一月底的一个雨夜，我&#39；我有一个启示。如果我颠倒了函数的顺序呢？如果二进制数据从未到达一个变量（或者更准确地说，是一个替换），只是停留在管道中，它能传递空字节吗？</p><p>   The answer is yes! After some iterations, I decided to use `dd` passed to `xxd` instead of just `xxd`, because this way I can finetune how many bytes to read.</p><p>答案是肯定的！经过一些迭代之后，我决定使用'dd'传递给'xxd'，而不仅仅是'xxd'，因为这样我可以微调要读取的字节数。</p><p> # the $len variable is assigned earlier, basing on a similar read functiona=$(dd count=$len bs=1 status=none | xxd -p) This gave me a hex string, on which I could do pattern matching, pattern replace, data extraction... and more. Sending out responses could be done analogically, using xxd&#39;s Reverse switch.</p><p>#$len变量在前面被赋值，基于一个类似的read function a=$（dd count=$len bs=1 status=none | xxd-p）这给了我一个十六进制字符串，我可以在这个字符串上进行模式匹配、模式替换、数据提取。。。还有更多。发送回复可以类似地进行，使用xxd和#39；s倒车开关。</p><p> `ncat` is used for listening on Minecraft&#39;s default TCP port. It launches the main shell script (`mc.sh`) after it receives an incoming connection.</p><p>`ncat`用于收听Minecraft&#39；默认的TCP端口。它在收到传入连接后启动主shell脚本（`mc.sh`）。</p><p>  Note: the following section contains mostly my ramblings about implementing number conversion routines in Bash; If this does not interest you, feel free to  skip it.</p><p>注意：以下部分主要是我在Bash中实现数字转换例程的漫谈；如果你对此不感兴趣，可以跳过它。</p><p> The first thing one should implement for a Minecraft server to function would be the  Server List Ping packet - not because it&#39;s required (heck, your server can just not reply to it properly, and you&#39;d still be able to join the game), but because it&#39;s the easiest to tackle first. It helps to familiarize yourself with core protocol concepts, such as  data types types:</p><p>Minecraft服务器要运行，首先应该实现的是服务器列表Ping数据包，而不是因为它&#39；这是必需的（见鬼，你的服务器无法正确回复，你仍然可以加入游戏），但因为它&#39；这是最容易解决的第一个问题。它有助于您熟悉核心协议概念，例如数据类型：</p><p>  Most data types were trivial to implement, but some gave me more of a fight than others - notably the IEEE754 floating point numbers (more on them later), and so-called VarInt/VarLong numbers. Those may be familar to those acquainted with the MQTT protocol, as they&#39;re just a modified version of the  LEB128 encoding.</p><p>大多数数据类型的实现都很简单，但有些数据类型比其他数据类型更让我头疼——尤其是IEEE754浮点数（稍后会有更多介绍），以及所谓的VarInt/VarLong数。那些人可能熟悉MQTT协议，因为他们&#39；我们只是LEB128编码的一个修改版本。</p><p> LEB128 is a compression scheme for integers. By splitting a byte into 1 signalling bit and 7 data bits, the scheme stores the number length. If the 1st bit is 0, then this byte is the last one; else, then there&#39;s another byte after this one. Great scheme if most of your numbers are either between 0 and 127 or 256 and 16383, otherwise it&#39;s `buy one byte, get one free` situation, because numbers that would otherwise fit in a byte get pushed out to the next one by a single bit.</p><p>LEB128是一种整数压缩方案。通过将一个字节拆分为1个信号位和7个数据位，该方案存储数字长度。如果第一位为0，则该字节为最后一位；除此之外，还有&#39；在这个字节之后是另一个字节。如果你的大多数数字在0到127之间或256到16383之间，那么这是一个很好的方案，否则就是&#39；“买一个字节，得到一个自由”的情况，因为本来可以放在一个字节中的数字会被一位推到下一个字节。</p><p>   # from  src/int.sh# int2varint(int)function int2varint() {	local a	local b	local c	local out	out=$(printf &#39;%02x&#39; &#34;$1&#34;)	if [[ $1 -lt 128 ]]; then		:	elif [[ $1 -lt 16384 ]]; then		a=$(($1%128))		b=$(($1/128))		out=$(printf &#34;%02x&#34; $((a+128)))$(printf &#34;%02x&#34; $b)	elif [[ $1 -lt $((128*128*128)) ]]; then		a=$(($1%128))		c=$((($1/128)%128))		b=$(($1/16384))		out=$(printf &#34;%02x&#34; $((a+128)))$(printf &#34;%02x&#34; $((c+128)))$(printf &#34;%02x&#34; $b)	fi	echo -n &#34;$out&#34;} I&#39;ve had problems translating the reference implementation to Bash, so instead I played with the protocol enough to write my own from scratch. I figured out that it was basically a modulo and a division in a trenchcoat, which I used to my advantage in the code snippet above.</p><p>#从src/int.sh#int2varint（int）函数int2varint（）{local a local b local c local out=$（printf&#39；%02x&#39；&#34；$1&#34；）如果[$1-lt 128]]；然后：以利夫[$1-lt 16384]；然后a=$（$1%128））b=$（$1/128））out=$（printf&#34；%02x&#34；$（a+128））$（printf&#34；%02x&#34；$b）elif[$1-lt$（128*128*128））；然后a=$（$1%128））c=$（$1/128）%128））b=$（$1/16384））out=$（printf&#34；%02x&#34；$（a+128））$（printf&#34；%02x&#34；$（c+128））$（printf&#34；%02x&#34；$b）fi echo-n&#34$出去&#34；}我&#39；我在将参考实现转换为Bash时遇到了问题，所以我使用了足够多的协议，从头开始编写自己的协议。我发现它基本上是一个挖沟机中的模和除法，我在上面的代码片段中利用了这一点。</p><p> I took a more contemporary approach on  the decoder, using an AND, and then multiplying the result - similarly to how the reference did it.</p><p>我对解码器采取了一种更现代的方法，使用AND，然后将结果相乘——类似于引用的方法。</p><p> LEB128 definitely wasn&#39;t the hardest or the most annoying to implement (that one goes to IEEE754 floating point); I still don&#39;t like how it is sprinkled in random places inside the protocol, interleaved with regular ints (and longs), and in some cases even signed shorts.</p><p>LEB128肯定不是&#39；它不是最难实现或最烦人的（这一个是IEEE754浮点）；我仍然不知道&#39；I don’我不喜欢它被散布在协议内部的随机位置，与常规整数（和长整数）交织，在某些情况下甚至是有符号的短整数。</p><p>  I&#39;m not a math person. When I see the exponential notation spewed out by Python, I scream and run. This may be the main cause of why I hated implementing these floating point converters. I won&#39;t be going too deep into specifics of how this format works - instead, I recommend you check out  this wikipedia page.</p><p>我&#39；我不是数学爱好者。当我看到Python发出的指数符号时，我尖叫着跑开了。这可能是我讨厌实现这些浮点转换器的主要原因。我赢了&#39；不要深入探讨这种格式的具体工作原理——相反，我建议你查看这个维基百科页面。</p><p> The basic implementation requires a loop, inside of which there&#39;s a negative power applied to the result; Bash doesn&#39;t natively support negative powers, which sent me on a trip to find a utility that does.</p><p>基本实现需要一个循环，其中有&#39；对结果施加负幂；Bash没有&#39；我天生就不支持消极力量，这让我不得不去寻找一个能做到这一点的工具。</p><p> A suggestion I found while duckduckgoing was to use perl, but I consider that cheating. Alternatively, tried using `bc`, but it seems that either it doesn&#39;t support powers at all, or the busybox version does not. Bummer.</p><p>我在DukDukEk中发现的一个建议是使用Perl，但我认为这是作弊。或者，尝试使用“bc”，但似乎要么没有&#39；根本不支持电源，或者busybox版本不支持。真倒霉</p><p> When I was about to give up, I got reminded that  Kate once made a  plot program in awk. Surely, awk has powers? ~~Maybe even super cow powers?~~ It turns out that it does!</p><p>当我准备放弃的时候，我被提醒凯特曾经在awk做过一个情节规划。当然，awk有能力吗~~甚至可能是超级牛的力量事实证明确实如此！</p><p> $ echo &#39;&#39; | awk &#39;{print (2**-1)}&#39;0.5 With this knowledge, I scribbled a working implementation and attached it to data decoded from the Player Move packet. In a trial run, the client sent around 50-100 packets like that, each one with three doubles (X, Y, Z). It turned out that the conversion function was so slow, that the server wasn&#39;t done with that workload after multiple minutes - something rather unacceptable for a real-time game.</p><p>$echo和#39&#39; | awk和#39；{print（2**-1）}&#39；0.5有了这些知识，我草草画出了一个工作实现，并将其附加到从播放器移动数据包解码的数据中。在一次试运行中，客户机发送了大约50-100个这样的数据包，每个数据包有三个双倍（X、Y、Z）。结果是转换功能太慢了，服务器没有&#39；在几分钟后，我无法完成这项工作——这对于实时游戏来说是相当不可接受的。</p><p> The easiest solution to lowering the response time would be lowering the amount of calls to external binaries, such as awk. As most of my workload was already inside a bash `for` loop, I just  moved the loop inside `awk`, which has saved me literally tens of calls to awk.</p><p>降低响应时间的最简单解决方案是减少对外部二进制文件（如awk）的调用量。由于我的大部分工作负载已经在bash`for`循环中，所以我将循环移到了`awk`中，这样就节省了对awk的数十次调用。</p><p> # (...)asdf=$(cut -c 13- &lt;&lt;&lt; $val | sed -E &#39;s/./,&amp;/g;s/,//&#39; | tr -d &#39;n&#39; | awk -F , &#39;{power_count=-1x=0;for(i=1; i&lt;=NF; i++) {x=(x + ($i * (2 ** power_count)))power_count=power_count-1;}print(x+1)}&#39;)# (...) The conversion is still quite slow (it takes ~10ms on my Xeon E5-2680v2), but this is to be expected with bash scripts. For a cheap comparsion, the old version took around 350ms, but I don&#39;t have solid measurements to prove that. ~~still, 35x faster, woo!~~</p><p># (...)asdf=$（cut-c 13-&lt；&lt；&lt；$val | sed-E&#39；s/，&amp；/g；s/，//&#tr-d&#39；n&#awk-F，&#39+{power u count 1x=0；对于（i=1；i&lt；=NF i）{x=（x+（$i*（2**power u count u））power打印（x+1）&#39；#(...) 转换仍然很慢（在我的Xeon E5-2680v2上需要约10毫秒），但这在bash脚本中是意料之中的。相比之下，旧版本大约需要350毫秒，但我没有&#39；我没有可靠的测量数据来证明这一点~~还是快了35倍，哇~~</p><p>  Finally, something made up by Mojang themselves!  Position is a 64-bit Long value, where three coordinates are stored alongside each other: X gets 26 most significant bits, Z gets 26 middle bits, Y gets 12 least significant bits. I&#39;m not the biggest fan of weird data types like this one, but it was  crazy easy to implement in Bash, because it has all the needed bitshift operators.</p><p>最后，莫强自己编的东西！Position是一个64位长的值，其中三个坐标并排存储：X获得26个最高有效位，Z获得26个中间位，Y获得12个最低有效位。我&#39；我不太喜欢这种奇怪的数据类型，但在Bash中实现起来非常简单，因为它有所有需要的位移位运算符。</p><p> The worst part about this data type is that it doesn&#39;t actually get used much. Around half of the packets store X, Y and Z coordinates as separate Double vaules. This means that:</p><p>这种数据类型最糟糕的地方在于它没有&#39；我其实没怎么习惯。大约一半的数据包将X、Y和Z坐标存储为单独的双变量。这意味着：</p><p> we get 9 digits of floating point accuracy, if we assume that we&#39;re only ever going to need numbers up to 30 000 000 (where the world border is at by default)</p><p>如果假设我们&#39；We’我们只需要不超过3000000的数字（默认情况下，世界边界在哪里）</p><p> I kinda see the reasoning as to why it&#39;s like that, but I still don&#39;t like the current state. Normal server communication uses zlib anyways, and you realistically won&#39;t ever need more than two (or maybe three max) digits of decimal precision to describe a position within a block.</p><p>我有点明白为什么会这样&#39；是这样的，但我还是不&#39；我不喜欢现在的状态。不管怎么说，正常的服务器通信都使用zlib，而您实际上赢了&#39；I don’描述一个块中的一个位置永远不需要超过两位（最多三位）的十进制精度。</p><p>  Lastly, there&#39;s the  NBT format, also an internal thing made by  Mojang  Hatsune Miku herself. NBT is like JSON, but for binary data. Not unlike JSON, it gets abused to store arbitrary data beyond spec - for example, Mojang stores bitstreams of variable length as an array of Longs; if such array isn&#39;t long-aligned, or even byte-aligned, the last Long is padded with zeroes.</p><p>最后是&#39；这是NBT格式，也是Mojang Hatsune Miku自己制作的内部产品。NBT类似于JSON，但用于二进制数据。与JSON不同，它被滥用来存储超出规范的任意数据——例如，Mojang将可变长度的比特流存储为一个长数组；如果这样的数组不是&#39；t long-aligned，甚至字节对齐，最后一个long用零填充。</p><p> At one point I&#39;ve had a NBT parser implementation implemented almost fully, but I decided it was not worth the hassle to finish it. The code is currently lost, due to my extensive use of tmpfs as a project directory, and a system crash.</p><p>有一次我&#39；我几乎完全实现了一个NBT解析器实现，但我觉得不值得费心去完成它。由于我广泛使用tmpfs作为项目目录，以及系统崩溃，代码目前已丢失。</p><p>  With all the math out of the way, here comes the *actually fun* part. I documented some of my adventures  on Twitter, but that thread was merely a glimpse on the actual development process. Also, let&#39;s assume that we already have the Server Ping packet out of our way, and it&#39;s a matter of actually making the game joinable now.</p><p>所有的数学问题都解决了，接下来就是“真正有趣”的部分。我在Twitter上记录了我的一些冒险经历，但那条线索只是对实际开发过程的一个粗略了解。还有，让&#39；假设我们已经有了服务器Ping数据包，它&#39；这是一个让游戏可以加入的问题。</p><p> To allow a client to join your server, it has to complete the handshake process and send a few extra packets (chunks, player position, inventory, join game). Two biggest obstacles on that course were the Join Game packet, and the data structure within the Chunk packets.</p><p>为了让客户端加入您的服务器，它必须完成握手过程并发送一些额外的数据包（区块、玩家位置、库存、加入游戏）。这一过程中最大的两个障碍是Join Game数据包和Chunk数据包中的数据结构。</p><p>  The join game sends some initial metadata: player&#39;s entity ID, gamemode, some information about the world and, since ~1.16, a &#34;Dimension codec&#34;. This is a NBT Compound, containing the following fields:</p><p>join游戏会发送一些初始元数据：player&#39；s实体ID、游戏模式、一些关于世界的信息，以及自~1.16以来的a&#34；Dimension编解码器&#34；。这是一种NBT化合物，包含以下字段：</p><p>   The Dimension codec part was a major pain to implement. For my purposes, I decided to retrieve that NBT field from a vanilla server. It&#39;s the only binary blob in this implementation, and while it could be reimplemented, I don&#39;t see any reason to reimplement something that I don&#39;t necessarily need (or want) to customize.</p><p>Dimension编解码器部分是实现的一大难题。出于我的目的，我决定从一个普通服务器检索NBT字段。它&#39；它是这个实现中唯一的二进制blob，虽然它可以重新实现，但我不&#39；我看不出有任何理由重新实施我不知道的事情&#39；不一定需要（或想要）定制。</p><p>  At first glance, this packet looks huge and scary! If you have the table from the link above open side by side with this article, I invite you to imagine that every one of those huge BitSet fields is actually just `0x00`, and that you don&#39;t need to send the Block Entity field at all. This leaves us with X, Y, heightmaps (which are fancily encoded repetitions of `b000000010`, and could be virtually anything), and the ominous Data field. Less scary, right?</p><p>乍一看，这个包裹看起来又大又吓人！如果上面链接中的表与本文并排打开，我请您想象一下，这些巨大的位集字段中的每一个实际上都是“0x00”，而您没有&#39；根本不需要发送块实体字段。这就给我们留下了X、Y、高度图（它们是“b000000010”的奇特编码重复，几乎可以是任何东西），以及不祥的数据字段。没那么可怕吧？</p><p>  The Data field is actually an array of Chunk Section. A Chunk Section is 16 by 16 by 16 blocks, and multiple sections can be stacked together to create a Chunk. For our purposes, this array only has a single element, just to simplify the code a bit.</p><p>数据字段实际上是块段的数组。一个块段是16×16×16块，多个块段可以堆叠在一起创建一个块。出于我们的目的，这个数组只有一个元素，只是为了简化代码。</p><p> A Chunk Section contains a block count, a block states container, and a biome container. Both of these containers use palette structure to encode possible block values - this means that before the real block data, server has to define a mapping from the &#34;local&#34; block IDs, to &#34;global&#34; block IDs. This aims to squish as much data as possible inside a small space - a block definition can be as small as 4 bits.</p><p>块段包含块计数、块状态容器和biome容器。这两个容器都使用调色板结构对可能的块值进行编码——这意味着在生成真正的块数据之前，服务器必须从&#34；本地和#34；区块ID，至&#34；全球和#34；阻止ID。其目的是在一个小空间内挤压尽可能多的数据——一个块定义可以小到4位。</p><p> As in my opinion the wiki page doesn&#39;t explain it well enough to quickly comprehend, here&#39;s another drawing:</p><p>在我看来，维基页面没有&#39；我解释得不够好，不能很快理解；这是另一幅画：</p><p>   For me, the easiest way I found to send those fields data management-wise was to use an 8 bit (instead of a minimal 4 bit) block definition length. This would give me a whopping 256 possible palette entries, out of all available blocks to choose from. Then, writing actual chunk data would be as easy as sending hex numbers referencing those palette entries. A 4-bit palette would be equally easy (a byte represented as a hex string is two characters, representing 4 bits each, so `0x01` would represent two blocks - one with id 0, and another with id 1), but it would limit me to 16 blocks per chunk.</p><p>对我来说，我发现发送这些字段数据管理的最简单方法是使用8位（而不是最小的4位）块定义长度。这将给我一个惊人的256个可能的调色板条目，从所有可用的块中选择。然后，编写实际的区块数据就像发送引用这些调色板条目的十六进制数一样简单。4位调色板也同样简单（一个十六进制字符串表示的字节是两个字符，每个字符表示4位，所以“0x01”将表示两个块——一个id为0，另一个id为1），但它会将我限制为每个块16个块。</p><p> The standard actually allows for anything from 4 bits per block to 9bpb, otherwise it assumes a direct palette mapping with 15bpb - I too have no idea why it isn&#39;t byte-aligned.</p><p>该标准实际上允许从每个块4位到9bpb的任何内容，否则它假设一个15bpb的直接调色板映射——我也不知道为什么它不是&#39；t字节对齐。</p><p> The biome palette works a bit differently in my implementation - it just sends an empty palette, and then maps biome ID 0x01 (minecraft:plains) directly to all regions inside the chunk. This was based on my reverse engineering of how vanilla works - I suspect that the existing documentation of this part of the packet is incorrect, as I&#39;m either getting too much data, or missing a few bytes every time.</p><p>在我的实现中，biome调色板的工作方式有点不同——它只发送一个空调色板，然后将biome ID 0x01（minecraft:plains）直接映射到区块内的所有区域。这是基于我对香草如何工作的逆向工程——我怀疑包中这部分的现有文档是不正确的，因为我&#39；我要么得到太多数据，要么每次都丢失几个字节。</p><p>    By now, we only have a plain chunk, not anything special by any means. I definitely wanted to make a few demos to show that the server can do *more* than just load and show a chunk, but I didn&#39;t want to create a separate source tree for every demo I spewed out. My solution is a series of overridable functions I called `hooks`, and an option for the server to load your own code. This allows for anything from changing how the world looks, to hooking up a pkt_effect so your player makes ticking noises while you move the mouse. Below I attach a simple (unoptimized) &#34;plugin&#34; that generates a chunk with random blocks from the default palette, which makes for an oddity that&#39;s kinda interesting visually.</p><p>到目前为止，我们只有一块普通的，没有任何特别的东西。我当然想做一些演示，展示服务器可以做的*更多*而不仅仅是加载和显示块，但我没有&#39；我不想为我的每个演示创建一个单独的源代码树。我的解决方案是一系列我称之为“hooks”的可重写函数，以及服务器加载自己代码的选项。这允许任何事情，从改变世界的外观，到连接pkt_效果，让玩家在移动鼠标时发出滴答声。下面我附上一个简单的（未优化的）&#34；插件&#34；这会从默认调色板中生成一个包含随机块的块，这会产生一个奇怪的结果&#39；这在视觉上有点有趣。</p><p> #!/usr/bin/env bash# map.sh - simple map modification showcasefunction hook_chunks() {chunk_headerfor (( i=0; i&lt;4096; i++ )); dochunk+=&#34;$(printf &#39;%02x&#39; $((RANDOM%30)))&#34;donechunk_footerecho &#34;$chunk&#34; &gt; $TEMP/world/0000000000000000pkt_chunk FFFFFFFF FFFFFFFF 00pkt_chunk FFFFFFFF 00000000 00pkt_chunk FFFFFFFF 00000001 00pkt_chunk 00000000 FFFFFFFF 00pkt_chunk 00000000 00000000pkt_chunk 00000000 00000001 00pkt_chunk 00000001 FFFFFFFF 00pkt_chunk 00000001 00000000 00pkt_chunk 00000001 00000001 00}   Another demo worth taking a look at is digmeout - it&#39;s a simple highscore based game, which throws you onto a chunk with randomly placed stone and ores. Dig out the most valuable ores until the timer runs out!</p><p>#!/usr/bin/env bash#地图。sh-简单地图修改展示函数hook_chunks（）{chunk_headerfor（（i=0；i&lt；4096；i++）；dochunk+=&#34；$（printf&#39；%02x&#39；$（随机%30）))&#34;donechunk#u footeecho和#34$块和#34&gt$TEMP/world/0000000000000000 pkt_chunk FFFFFFFFFFFFFF00pkt_chunk FFFFFFFF00000000pkt_chunk 00000000 FFFFFF00pkt_chunk 00000000 pkt_chunk 00000000000000000000 pkt_chunk 00000000000000 pkt_chunk 00000001 FFFFFF00pkt_chunk 00000001 00000000 pkt_chunk 00000001它&#39；这是一个简单的高分游戏，它把你扔到一块随机放置的石头和矿石上。挖出最有价值的矿石，直到计时器耗尽！</p><p>     Bash is notoriously bad at handling decimal numbers. It&#39;s *ok* with Integers (as long as you don&#39;t do too advanced maths on them), but the only way to handle a decimal number is by multiplying it on input, and somehow placing a dot in the correct place for output. Because of this, most (if not all?) numbers handled by Witchcraft are ints.</p><p>众所周知，Bash不擅长处理十进制数。它&#39；对于整数，s*ok*（只要你不&#39；对它们做太多高等数学运算），但处理十进制数的唯一方法是在输入时将其相乘，然后在正确的输出位置放置一个点。正因为如此，大多数（如果不是全部的话？）巫术处理的数字是整数。</p><p> The multiplayer doesn&#39;t really work? I mean, it kinda does, but I never really took time to finish it and polish it up.</p><p>多人游戏没有&#39；真的不行吗？我的意思是，有点像，但我从来没有真正花时间来完成它和擦亮它。</p><p>  ... which means that it has to use terrible hacks to communicate between threads. Currently, most global data is stored under `/dev/shm/witchcraft`, internally referenced to as `$TEMP`.</p><p>... 这意味着它必须使用可怕的黑客在线程之间进行通信。目前，大多数全局数据存储在“/dev/shm/witchcraft”下，内部称为“$TEMP”。</p><p> Witchcraft is slow, especially in terms of data exchange between multiple threads. Don&#39;t expect to be able to send massive amounts of data, generating and sending 16 solid chunks can take as long as a second.</p><p>巫术很慢，尤其是在多线程之间的数据交换方面。唐&#39；I don’我不希望能够发送大量数据，生成和发送16个实体块可能需要一秒钟的时间。</p><p> Witchcraft currently runs *only* if you have the latest BusyBox (1.35.0) installed. I haven&#39;t tested it with GNU coreutils, but I expect it won&#39;t work.</p><p>巫术目前只有在安装了最新的BusyBox（1.35.0）的情况下才能运行。我没有&#39；我没有用GNU coreutils测试它，但我预计它会赢&#39；不行。</p><p>      A: Witchcraft-internal IDs are defined in  src/palette.sh, and can be redefined in &#34;plugins&#34;. The external IDs to which the internal ones are mapped can be acquired from the vanilla server. Check out this reference page on  Data Generators.</p><p>答：巫术内部ID在src/palette中定义。sh，可以在&#34中重新定义；插件&#34；。可以从服务器获取内部ID映射到的外部ID。查看有关数据生成器的参考页。</p><p>   A: selfisekai came up with that name, possibly because I&#39;m a (bash) witch, and I thought it was *great*</p><p>答：selfisekai提出了这个名字，可能是因为我&#39；我是个女巫，我觉得很棒*</p><p> Everyone at 15.02.2022, 16:40:40  helpful person at 15.02.2022, 16:59:22 This project is wicked cool but your font choices make it super hard to read. And this black-on-dark-gray comment box is insane! :D</p><p>大家在2022年2月15日16:40:40乐于助人在2022年2月15日16:59:22这个项目非常酷，但你的字体选择让它非常难以阅读。这个黑底灰的评论框简直是疯了！：D</p><p>  Saphire at 15.02.2022, 17:10:48 Oh dear, that is cursed. Much more so than the HTTP(s) server in bash that I have seen around... I love it~!...wait is the font for this the minecraft font. And agree with previous comment, the black-on-gray is hard to read q-q</p><p>萨菲尔2022年2月15日17:10:48哦，天哪，这是诅咒。比我在bash中看到的HTTP（s）服务器更重要。。。我喜欢~！。。。等等，这是minecraft字体。与之前的评论一致，灰色上的黑色很难理解</p><p> new reader at 15.02.2022, 17:48:56 as someone that knows very little bash, this was extremely fun to read. love the website too! :)</p><p>《新读者》于2022年2月15日17:48:56作为一个对bash知之甚少的人，这本书读起来非常有趣。我也喜欢这个网站！：）</p><p> awesome stuff at 15.02.2022, 17:49:01  josé at 15.02.2022, 18:06:37 I&#39;ve had this idea a few months ago and I didn&#39;t think it was possible. This is awesome! good work.</p><p>2022年2月15日17:49:01 josé2022年2月15日18:06:37 I&#39；我几个月前就有了这个想法，但我没有&#39；我不认为这是可能的。这太棒了！干得好。</p><p>  Artur at 15.02.2022, 18:15:27   lily at 15.02.2022, 18:17:05   prefetcher at 15.02.2022, 18:22:08  Rafael at 15.02.2022, 18:49:27   Daniel at 15.02.2022, 18:49:40  keldu at 15.02.2022, 19:20:46 That&#39;s crazy. I wrote a small MC network implementation in C++ and gave up after I started to see how they randomly change packets in different versions.I didn&#39;t want to keep up with that. But do this in bash for MC is crazy.I went back and wrote a small reverse proxy server for MC though.</p><p>2022年2月15日阿图尔，2022年2月15日18:15:27莉莉，2022年2月15日18:17:05预取，2022年2月15日18:22:08拉斐尔，2022年2月15日18:49:27丹尼尔，2022年2月15日18:49:40凯尔杜，2022年2月15日19:20:46那&#39；这太疯狂了。我在C++中编写了一个小型MC网络实现，在我开始看到它们如何随机地改变不同版本的数据包后，放弃了。我没有&#39；我不想跟上。但在bash for MC中这样做太疯狂了。我回去为MC编写了一个小型反向代理服务器。</p><p>  Theo at 15.02.2022, 19:36:33 Your website is great. Your posts are great. Your everything is great. Keep up the work, It&#39;s definitely worth it...</p><p>西奥：2022年2月15日19:36:33你的网站很棒。你的帖子很棒。你的一切都很好。继续工作，它&#39；这绝对值得。。。</p><p> bigking at 15.02.2022, 19:39:06 ilove this. gonna play with it, if i manage to make something worthwhile i let you know. thanks for this interesting unconventional project.</p><p>比金2022年2月15日19:39:06我喜欢这个。如果我能做点有价值的事，我会告诉你的。感谢这个有趣的非传统项目。</p><p> Mikael at 15.02.2022, 20:03:07 Cool project! May I ask how much time went into it? I don&#39;t really know how complex the protocol is or how long time each test takes, like if you need to restart the client and stuff.</p><p>2022年2月15日，20:03:07米凯尔的节目很酷！请问花了多少时间？我不&#39；我真的不知道协议有多复杂，或者每个测试需要多长时间，比如你是否需要重启客户端等等。</p><p> anon at 15.02.2022, 20:53:12  Triggernometry at 15.02.2022, 21:16:27 this is a glorious write-up of the process tho.one of the best ways to learn coding is to do or see &#34;what if i did this stupid pointless thing&#34; then seeing aaaaaall the pitfalls</p><p>2022年2月15日的anon，2022年2月15日的20:53:12，2022年2月21日的21:16:27这是一篇关于这一过程的精彩文章。学习编码的最佳方法之一是做或看&#34；如果我做了这件愚蠢无意义的事&#34；然后看到所有的陷阱</p><p> eggmtf at 15.02.2022, 21:19:43   hyperupcall at 15.02.2022, 21:25:36 I do a lot of Bash and lemmie tell you, this is pretty badass! Some people would say it&#39;s cursed, but I think its just cool - Thanks for sharing ^w^</p><p>2022年2月15日的eggmtf，2022年2月15日21:19:43的hyperupcall，2022年2月15日21:25:36我做了很多Bash和lemmie告诉你，这真是太糟糕了！有人会说&#39；它被诅咒了，但我觉得它很酷——谢谢分享^w^</p><p> egg at 15.02.2022, 22:03:16 Wow for the hackery of the &#34;in Bash&#34;, and nice font reminds me of some VGA stuff.</p><p>2022年2月15日，22:03:16，为&#34的黑客们欢呼；在Bash&#34；，漂亮的字体让我想起一些VGA的东西。</p><p> anon at 15.02.2022, 22:17:18   j3s at 16.02.2022, 01:34:09  a nat you don&#39;t know at 16.02.2022, 02:19:17   chip at 16.02.2022, 02:49:23  ayo at 16.02.2022, 06:12:39  trekkie1701c at 16.02.2022, 06:16:55 You can hackily handle floating point numbers in a bash script by piping the equation through BCMath.In the case that I&#39;ve had to do it, it&#39;s pretty much:var=$(echo &#34;scale=9;$num1/$num2&#34; | bc)Where the 9 is the number of decimal places and / is the operand and can be replaced by whatever.This is probably highly inefficient but hey it works.</p><p>2022年2月15日，22:17:18，2022年2月16日，01:34:09，a nat you don&#39；我不知道2022年2月16日02:19:17 chip at 16.02.2022，2022年2月16日02:49:23 ayo，2022年2月16日06:12:39 trekkie1701c，2022年2月16日06:16:55，你可以通过BCMath将方程传输到bash脚本中，在其中巧妙地处理浮点数。如果我&#39；我不得不这么做，它&#39；s相当于：var=$（echo&#34；scale=9；$num1/$num2&#34；|bc），其中9是小数位数和/是操作数，可以用任何数字替换。这可能效率很低，但它确实有效。</p><p> punk xfce at 16.02.2022, 08:19:20  annow at 16.02.2022, 11:11:57  M at 16.02.2022, 11:21:37 This is exactly the kind of insane (in a good way) stuff I love to read about! Looking forward to more of this! :3</p><p>2022年2月16日08:19:20安诺2022年2月16日11:11:57米2022年2月16日11:21:37这正是我喜欢读的那种疯狂的东西！期待更多这样的事情！：3.</p><p> Charles Duffy at 16.02.2022, 13:13:19 You can absolutely read and write streams containing NULs in bash -- the trick is to store them as arrays (with the terminal element containing everything after the last NUL) instead of as strings. Also, echo is an abomination in general, and even the POSIX spec describing it says that printf should be used instead -- search for the excellent answer by Stéphane Chazelas to &#34;Why is printf better than echo?&#34; on unix.stackexchange.com</p><p>Charles Duffy于2022年2月16日13:13:19在bash中完全可以读写包含NUL的流——诀窍是将它们存储为数组（终端元素包含最后一个NUL之后的所有内容），而不是字符串。而且，echo总体上是一个令人憎恶的东西，甚至描述它的POSIX规范也说应该使用printf——寻找Stéphane Chazelas对&#34；为什么printf比echo更好&#34; 在unix上。斯塔克交换。通用域名格式</p><p> RJM at 16.02.2022, 19:12:40  RSEA at 16.02.2022, 20:00:24   LeigerGaming at 16.02.2022, 22:23:12  Wensz at 16.02.2022, 22:42:09    By commenting, you agree for the session cookie to be stored on your device ;p</p><p>2022年2月16日的RJM、2022年2月16日的19:12:40 RSEA、2022年2月16日的20:00:24 Leiger Gaming、2022年2月16日的22:23:12 Wensz、2022年2月16日的22:42:09通过评论，您同意将会话cookie存储在您的设备上；P</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/服务器/">#服务器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/writing/">#writing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>