<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>JavaScript如何工作：3种多态性 How JavaScript works: 3 types of polymorphism</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How JavaScript works: 3 types of polymorphism<br/>JavaScript如何工作：3种多态性 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-10 08:00:29</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/c37e3a1a40098617855f653d8bc3e621.jpeg"><img src="http://img2.diglog.com/img/2021/5/c37e3a1a40098617855f653d8bc3e621.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This is post # 26 of the series, dedicated to exploring JavaScript and its building components. In the process of identifying and describing the core elements, we also share some rules of thumb we use when building  SessionStack, a JavaScript application that needs to be robust and high-performing to help companies optimize the digital experience of their users.</p><p>这是该系列中的第26页，致力于探索JavaScript及其构建组件。在识别和描述核心元素的过程中，我们还分享了在构建会话中使用的拇指规则，需要坚固且高性能的JavaScript应用程序来帮助公司优化用户的数字体验。</p><p> In real life, a woman can have different roles. She can be a mother, an employee, and a wife at the same time. The same woman will perform different functions depending on her particular role at the moment. This is the concept of polymorphism, being able to take on different forms.</p><p> 在现实生活中，一个女人可以有不同的角色。她可以同时成为一名母亲，员工和妻子。同一女性将根据她目前的特定角色进行不同的功能。这是多态性的概念，能够采用不同的形式。</p><p> Although numerous people don’t know what polymorphism is, how it works in JavaScript and why it is needed generally, polymorphism is important in programming; it is a core feature for object-oriented programming. For instance, while the woman is at work as an employee, she’s very unlikely going to take on the characteristics of a mother and vice versa when she’s at home as a mother.</p><p> 虽然众多人不知道多态是什么，它如何在JavaScript中工作以及为什么需要它，多态性在编程中很重要;它是面向对象编程的核心功能。例如，虽然这个女人在作为雇员的工作中，但她很不可能承担母亲的特征，而她作为母亲家里的反之亦然。</p><p> For programming languages that are data-oriented like Rust, polymorphism is also an important feature that is achieved with Entity Component System (ECS). A programming language can present the same interface for several different underlying data types. Programs written in JavaScript can take on different forms. In this article, we’ll explore what polymorphism is, how it applies to JavaScript, the different types of polymorphism, and things to have in mind when dealing with polymorphism.</p><p> 对于数据导向的编程语言，如锈，多态性也是用实体组件系统（ECS）实现的重要特征。编程语言可以为几种不同的底层数据类型呈现相同的接口。用JavaScript编写的程序可以采用不同的形式。在本文中，我们将探讨哪种多态性是什么，它如何适用于JavaScript，不同类型的多态性，在处理多态性时要记住的事情。</p><p>  Let’s imagine that we’ll need to write a program that’ll calculate the area and perimeter of shapes. To do this, we’ll need to define methods to calculate the  area and  perimeter of our shapes;  area() and  perimeter(). However, basic knowledge of geometry tells us that we can’t solve for the area and perimeter of different shapes in the same way. For instance, the perimeter of a circle is  2 x Pi x radius and the perimeter of a square is  4 x Length.</p><p>  让我们想象一下，我们需要编写一个计算区域和周边的程序。为此，我们需要定义计算我们形状的区域和周边的方法;区域（）和周边（）。然而，几何形状的基本知识告诉我们，我们无法以同样的方式为不同形状的区域和周长求解。例如，圆的周边是2×PI x半径，方形的周边为4×长度。</p><p> So, we’ll need to define the different shapes as sub-classes or derived classes of the base class  shapes. Therefore, we’ll have a subclass circle, square, trapezium, polygon which will all have their methods and different parameters. What we have done above is polymorphism. Our class  shapes now has different forms and characteristics like circle, square, trapezium, and polygon as sub-classes.</p><p> 因此，我们需要将不同的形状定义为基类形状的子类或派生类。因此，我们将拥有一个子类圈，平方，梯形，多边形，所有这些都有它们的方法和不同的参数。我们上面所做的是多态性。我们的班级形状现在具有不同的形式和特征，如圆形，方形，梯形和多边形，作为子类。</p><p> Polymorphism is derived from two words; poly and morphism which means many and variance of form. In programming, polymorphism is defined as the ability of an object to take on different forms. In the next section, we’ll get a deeper understanding of how JavaScript handles polymorphism.</p><p> 多态性来自两个词;多种和态塑，这意味着形式的许多和方差。在编程中，多态性被定义为对象采用不同形式的能力。在下一节中，我们将深入了解JavaScript如何处理多态性。 </p><p>  The way programming languages implement polymorphism differs. As an example, Java and JavaScript are both object-oriented programming languages and they don’t handle polymorphism in the same manner. Although polymorphism is a core feature for object-oriented programming languages, some data-oriented languages achieve polymorphism with Entity Component System (ECS) pattern. We’ll also look at how polymorphism works with inheritance and encapsulation.</p><p>编程语言实现多态性的方式不同。作为一个例子，Java和JavaScript都是面向对象的编程语言，并且它们不会以相同的方式处理多态性。虽然多态性是面向对象编程语言的核心特征，但是一些数据导向语言实现了与实体组件系统（ECS）模式的多态性。我们还将研究多态性如何与继承和封装有效。</p><p>  To understand how polymorphism works in object-oriented programming, it’ll be best if we understand the concept of the object-oriented model. The object-oriented model relies on the concept of objects and classes. This type of model can mutate its data fields with the notion of  this or  self.</p><p>  要了解多态性如何在面向对象的编程中工作，如果我们理解面向对象模型的概念，它将是最好的。面向对象的模型依赖于对象和类的概念。这种类型的模型可以通过这个或自我的概念使其数据字段变异。</p><p> Although not in the scope of this article, I’ll explain how polymorphism in JavaScript works by comparing polymorphism in the object-oriented model as interface and polymorphism in data-oriented programming as Entity Component System (ECS).</p><p> 虽然没有在本文的范围内，我将解释JavaScript的多态性如何通过将面向对象模型中的多态性与作为实体组件系统（ECS）的数据导向编程中的界面和多态性进行比较。</p><p> In object-oriented programming, we can create a class that calculates the area and perimeter of different shapes with the block of code below:</p><p> 在面向对象的编程中，我们可以创建一个类，该类别使用下面的代码块计算不同形状的区域和周边：</p><p>    We can recreate the program from our code above with ECS in pseudocode denoting a data-oriented language.</p><p>    我们可以从上面的代码中使用伪代码中的ECS重新创建计划，该伪表示以数据为导向的语言。</p><p>  The difference between both examples is that in object-oriented programming from our JavaScript code, we made use of deep inheritance due to interface/abstraction. However, in data-oriented programming from our pseudocode, we used the ECS model to decouple entities into components for easy retrieval of data.</p><p>  这两个示例之间的差异是，在来自我们的JavaScript代码的面向对象编程中，我们由于接口/抽象而造成了深度继承。然而，在来自我们的伪代码的数据导向编程中，我们使用ECS模型将实体与组件隔离成分以便于检索数据。</p><p> Let’s get a better understanding of what inheritance is in JavaScript and how it relates to polymorphism.</p><p> 让我们更好地了解继承中的javascript是什么以及它与多态性有关的原因。 </p><p>  Inheritance is an important feature in polymorphism in object-oriented programming. Let’s look at an example of a  car object:</p><p>继承是面向对象编程中多态性的重要特征。让我们来看看汽车对象的一个​​例子：</p><p>  Now, our  car object will have different sub-classes for different car makes like BMW, Toyota, Bentley, etc., and different properties like color and speed:</p><p>  现在，我们的汽车对象将为不同的汽车提供不同的子类，如宝马，丰田，宾利等，以及颜色和速度的不同属性：</p><p>     From our example, a child class can take up a property from the superclass, to define it. Inheritance can grow from present family to grandparents or even great-grandparents.</p><p>     从我们的示例开始，子类可以占用超类的属性，以定义它。继承可以从现在的家庭到祖父母或甚至曾祖父母。</p><p>  Inheritance is a very wide topic in JavaScript, as there are different ways to implement it. For instance, there’s the prototypal, pseudoclassical and functional inheritance. Let’s look briefly at how these inheritance types differ and how they work with polymorphism in JavaScript.</p><p>  继承是JavaScript中的一个非常广泛的主题，因为有不同的方法来实现它。例如，有原型，伪像和功能遗传。让我们简要介绍这些继承类型的不同以及它们如何在JavaScript中使用多态性。</p><p>  Prototypal inheritance is a type of inheritance that adds new properties and methods to an existing object. This inheritance makes use of prototype objects i.e.  object.prototype</p><p>  原型继承是一种继承类型，可以为现有对象添加新的属性和方法。此继承利用原型对象i.e. object.Prototype</p><p>    Psuedoclassical inheritance is similar to prototypal inheritance. This type of inheritance emulates classical inheritance using prototypal inheritance. However, if you’re programming with ES6, the use of psuedoclassical inheritance isn’t encouraged since you can use conventional classes (the class keyword). In psuedoclassical inheritance, we try to create a class with a function that is intended to be called with the new keyword. To understand this better, we’ll be using our car example. Let’s imagine we have a car object as shown in the code below:</p><p>    Psiedoclassical继承类似于原型继承。这种类型的继承使用原型继承模拟了经典继承。但是，如果您使用ES6进行编程，则不鼓励使用PsuedClassical继承，因为您可以使用传统类（类关键字）。在psiedoclassical继承中，我们尝试使用函数创建一个旨在用新关键字调用的函数的类。要更好地了解，我们将使用我们的汽车示例。让我们想象我们有一个汽车对象，如下代码所示：</p><p>  We can create sub-types of different  car makes objects with prototype using the  new keyword:</p><p>  我们可以使用新的关键字创建不同车的子类型，使原型的对象： </p><p>  With prototype, we have created new objects with the different  car makes. Next, we’ll understand how to pass the prototype as inheritance and how it affects polymorphism.</p><p>使用原型，我们创建了不同的汽车的新对象。接下来，我们将了解如何将原型传递为继承以及它如何影响多态性。</p><p> First, we’ll create a function called  dialogue that we’ll want our cars to inherit:</p><p> 首先，我们将创建一个名为DIANVEUS的函数，我们希望我们的汽车继承：</p><p>  After that, we’ll allow our cars to inherit the  dialogue function with prototype:</p><p>  之后，我们将允许我们的车与原型继承对话函数：</p><p>   The program above should output “I am a red Toyota with 100mph speed”, “I am a green BMW with 90mph speed”, and “I am a white Bentley with 120mph speed” accordingly in your console.</p><p>   上面的程序应该输出“我是一个带有100万小时的红色丰田”，“我是一个带90英里的绿色宝马”，并在你的控制台中相应地“我是一个白色的宾利速度为120英里的速度”。</p><p>  Functional inheritance involves inheriting features with the use of an augmenting function to an object instance:</p><p>  功能继承涉及使用使用增强函数来对象实例的继承功能：</p><p>     Since we have gotten a better understanding of how inheritance in polymorphism work, it’ll be easier to understand how encapsulation works in polymorphism. While programming, there’ll be a need to bundle or put data together in such a way that users can’t access state values of the variables of a particular object from outside.</p><p>     由于我们已经更好地了解了多态性工作的继承，因此更容易了解封装如何在多态性上工作。在编程时，需要将数据捆绑或将数据捆绑在一起，使用户无法从外部访问特定对象的变量的状态值。</p><p> From the example below, we’re validating the marks of a student by bundling their data together and inheriting them using prototype-based polymorphism.</p><p> 从下面的示例中，我们通过将数据捆绑在一起并使用基于原型的多态性继承它们来验证学生的标记。 </p><p>    A lot of people don’t understand that there’s a difference between abstraction and encapsulation. In abstraction, only certain information is shown while the rest is hidden. Whereas in encapsulation, data is bundled into a single entity and hidden from outside reach. The main reason for encapsulation is to control and validate data. Just as in our example above, validation of student score is done in such a way that the student/public can’t interfere.</p><p>很多人都不明白，抽象和封装之间存在差异。在抽象中，只有在其余隐藏时显示某些信息。虽然在封装中，数据被捆绑成单个实体并隐藏在外部范围内。封装的主要原因是控制和验证数据。就像我们上面的例子一样，学生评分的验证是以学生/公众不能干扰的方式完成的。</p><p>  There are different types of polymorphism in JavaScript. In this section, we’ll be discussing the three major types which are ad-hoc, Sub-type, and parametric polymorphism.</p><p>  JavaScript中有不同类型的多态性。在本节中，我们将讨论为ad-hoc，子类型和参数多态性的三种主要类型。</p><p>  Ad-hoc polymorphism is a type of polymorphism that allows a value to exhibit different behaviors when “viewed” at different types. Ad-hoc polymorphism can involve a function taking on different forms but bearing the same name.</p><p>  ad-hoc多态性是一种多态性，可以在不同类型的“观察”时允许值表现出不同的行为。 Ad-hoc多态性可以涉及占用不同形式但承载相同名称的功能。</p><p> This type of polymorphism is oftentimes called overloading. Let’s look at a type of ad-hoc polymorphism called operator overloading.</p><p> 这种类型的多态性是称为超载的。让我们来看看一种称为操作员重载的ad-hoc多态性。</p><p>   From the example above, the operator  + is taking up different forms of adding numbers and concatenating Strings.</p><p>   从上面的示例，操作员+正在占用不同形式的添加数字和连接字符串。</p><p>  Parametric polymorphism is a type of polymorphism that deals with generic functions and generic data types while still maintaining static type safety. Generic functions and data types are functions or data types that can be written in a way so that they can handle values similarly without classifying them based on their type.</p><p>  参数多态性是一种多态性，其涉及通用功能和通用数据类型，同时仍然保持静态类型安全性。通用函数和数据类型是可以以一种方式编写的函数或数据类型，以便它们可以类似地处理值，而无需基于其类型对其进行分类。</p><p> For example, objects can store different data types. It doesn’t distinguish its values based on their types:</p><p> 例如，对象可以存储不同的数据类型。它不会根据其类型区分其值： </p><p>  From the code above, we have an object named after a person  Ann. The object contains Ann’s first and last name which are Strings, Ann’s age which is a number, and a Boolean which states that Ann isn’t an adult. Although there are different data types in our object  Ann, the object handles them similarly.</p><p>从上面的代码中，我们有一个以人安格特命名的对象。该对象包含Ann的名字和姓氏，这些名字是一个字符串，Ann的年龄，这是一个数字，以及一个巢穴不是成年人的布尔值。虽然我们的对象ANN中存在不同的数据类型，但是对象同样处理它们。</p><p> Another quick example is an array. In JavaScript, an array can take up different data types as its element.</p><p> 另一个快速示例是一个数组。在JavaScript中，数组可以将不同的数据类型作为其元素占用。</p><p>  Just as in our object example, our array example consists of various data types all treated similarly. If you run  console.log(Ann) for our object or array, you should get a list of the elements.</p><p>  就像我们的Object示例一样，我们的数组示例包含了类似地处理的各种数据类型。如果为我们的对象或数组运行console.log（ANN），则应获取元素列表。</p><p>     In the example above,  id doesn’t distinguish the values  1 and  foo according to their types. So,  id can be in different data types; strings or numbers etc.</p><p>     在上面的示例中，ID不会根据其类型区分值1和foo。所以，ID可以是不同的数据类型;字符串或数字等</p><p>  Subtype polymorphism involves a subtype and a supertype data type. This type of polymorphism shouldn’t be confused with inheritance as it doesn’t involve the creation of new objects from existing objects — even though inheritance is used most times with this type of polymorphism in JavaScript. Rather, this type of polymorphism is about implementing an interface and substituting different implementations.</p><p>  亚型多态性涉及子类型和超型数据类型。这种类型的多态性不应与继承混淆，因为它不涉及从现有对象中创建新对象 - 即使在JavaScript中的这种类型多态性使用大部分继承。相反，这种类型的多态性是关于实现界面并代替不同的实现。</p><p> For example, if a relative unfortunately died and left you his bookstore. You can read all the books there, sell off the books if you like, you can look at the deceased accounts, the deceased customer list, etc. This is inheritance; you have everything the relative had. Inheritance is a form of code reuse.</p><p> 例如，如果一个相对不幸的是死亡并留下了他的书店。您可以阅读那里的所有书籍，如果您愿意，您可以看看书籍，您可以查看已故的帐户，已故的客户名单等。这是继承;你有一个亲戚的一切。继承是一种代码重用的形式。</p><p> If your relative doesn’t leave the bookstore for you in his will, you can reopen the bookstore yourself, taking on all of the relative’s roles and responsibilities, add even some changes of your own — this is subtyping; you are now a bookstore owner, just like your relative used to be.</p><p> 如果您的亲戚不会在他的意志中为您留下书店，您可以自行重新打开书店，以所有相对的角色和责任携带，增加了自己的一些变化 - 这是亚型;你现在是一个书店所有者，就像你的亲戚一样。 </p><p>   Cat, dog and goat are subtypes of animals. An animal can either be a cat, dog or goat etc. You can substitute different implementations for our different animals.</p><p>猫，狗和山羊是动物的亚型。动物可以是猫，狗或山羊等。您可以为我们的不同动物替换不同的实施。</p><p>  We’ve explored polymorphism briefly in this article, I’ll point out some things to have in mind when dealing with polymorphism in JavaScript.</p><p>  我们在这篇文章中概述了多态性，我将在javascript中处理多态性时指出一些令人想到的事情。</p><p> 1. Polymorphic functions affect the performance of your code, i.e. how fast your program runs. For instance, a monomorphic function will run faster compared to a polymorphic function. In some cases, this difference in performance may be insignificant if they’re frequently run.</p><p> 1.多态函数影响代码的性能，即，程序运行的快速。例如，与多晶型功能相比，单数函数将更快地运行。在某些情况下，如果它们经常运行，这种性能的差异可能是微不足道的。</p><p> 2. Sometimes, polymorphism reduces the readability of a program. To solve this problem, it is important to comment on your code so that people can identify the runtime behavior of the program.</p><p> 2.有时，多态性降低了程序的可读性。为了解决这个问题，重要的是对您的代码发表评论，以便人们可以识别程序的运行时行为。</p><p> 3. To implement polymorphism easily in JavaScript, one needs to understand inheritance. This is because polymorphism in JavaScript is centered around inheritance.</p><p> 3.在JavaScript中轻松实现多态，需要了解遗产。这是因为JavaScript中的多态性以遗传为中心。</p><p>  For numerous JavaScript developers, there’s a need for code reusability. This is one of the features of polymorphism. Code that has been previously written, can be reused. For instance, the superclass  person can be inherited by a subclass  employee. Another reason why polymorphism is an integral part of JavaScript developers is the ability to store values of different data types together. For example, a lot of JavaScript developers are familiar with creating an array. You can create an array with values of different data types put together. A quick example is an array below which has integers, strings, and booleans.</p><p>  对于众多JavaScript开发人员来说，需要代码可重用性。这是多态性的特征之一。以前写的代码可以重用。例如，超类人可以由子类员工继承。多态性是JavaScript开发人员的一个组成部分的另一个原因是能够将不同数据类型的值存储在一起。例如，许多JavaScript开发人员熟悉创建数组。您可以创建一个带有不同数据类型的值的数组。快速示例是下面的数组，其具有整数，字符串和布尔值。</p><p>   In projects where high performance is not crucial, the design decision whether to use polymorphism or not depends mainly on the approach which will make the code more extensible and maintainable.</p><p>   在高性能不明显的项目中，设计决定是否使用多态性或不依赖于将使代码更加可扩展和可维护的方法。 </p><p> In the cases where performance is top priority, it becomes the main driving force to design and architectural decisions.  For example, one of the components of SessionStack is a library that is integrated into websites and web apps. The library consumes data from the browser such as DOM changes, user interactions, JavaScript exceptions, stack traces, network requests, and debug messages. Afterward, the SessionStack platform allows teams to replay user journeys as videos in order to optimize product workflows, reproduce bugs, or see where users are stuck.  Since the library is integrated into other products, it needs to be highly optimized not to cause any negative performance impact during runtime. This means that polymorphism and high levels of abstractions are avoided while efficiency and performance are a top priority. The platform, on the other hand, can utilize abstractions and other methodologies to make the code easily scalable.</p><p>在表现最优先事项的情况下，它成为设计和架构决策的主要驱动力。例如，SessionStack的一个组件是将库集成到网站和Web应用程序中的库。该库从浏览器中消耗数据，例如DOM更改，用户交互，JavaScript异常，堆栈痕迹，网络请求和调试消息。之后，SessionStack平台允许团队重播用户旅行作为视频，以优化产品工作流，再现错误或查看用户卡的位置。由于库被集成到其他产品中，因此需要高度优化，不会在运行时造成任何负面性能影响。这意味着避免了多态性和高水平的抽象，而效率和性能是最优先级。另一方面，该平台可以利用抽象和其他方法来使代码容易可扩展。</p><p> There is a free trial if you’d like to  give SessionStack a try.</p><p> 如果您想尝试一下，有免费试用。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.sessionstack.com/how-javascript-works-3-types-of-polymorphism-f10ff4992be1?source=collection_category---4------0-----------------------">https://blog.sessionstack.com/how-javascript-works-3-types-of-polymorphism-f10ff4992be1?source=collection_category---4------0-----------------------</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/works/">#works</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/多态性/">#多态性</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>