<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我在Zig中重写了我的生锈键盘固件：一致性，掌握和乐趣 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我在Zig中重写了我的生锈键盘固件：一致性，掌握和乐趣 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-07 22:25:11</div><div class="page_narrow text-break page_content"><p>←返回到Kevin＆＃39;首页发布：2021年3月7日我花了最后一年的建筑键盘，其中包括写入固件的品种定制电路板。</p><p> 我最初在生锈中写了这个固件，但尽管几年的语言经验丰富了，但我仍然挣扎了很多。我最终得到了我的键盘工作，但它令人尴尬的时间很长一段时间，并不好玩。</p><p> 经过更多锈蚀和计算经验丰富的朋友杰米布兰登的重复建议，我在Zig重写了固件，这些固件失去了游泳。</p><p> 我发现这非常令人惊讶，因为我之前从未见过Zig，它是一个由一个主要的PDX时髦，基本上只有一个单一页面的文档。</p><p> 事实上，这种经验很好，我现在感觉就像转向Zig（一种我用过十几个小时的语言）到生锈（我至少曾至少一千个小时）。</p><p> 当然，这是对我和我的兴趣相比，这是一个关于这些语言的兴趣。所以我必须首先从系统编程语言中解释我想要的东西。</p><p> 此外，为了解释为什么我挣扎的原因我将不得不展示很多复杂的代码，我显然不开心。这里的意图不是为了弥补生锈，而是建立我的（缺乏）信誉：这是如此你可以以合理的方式使用Rust的功能，或者如果我完全失去了情节，你可以判断自己。 </p><p>最后，虽然它的风险落入了可怕的无聊“语言x比y”博客的追踪更好，但我觉得如果我明确比较生锈和锯齿，而不是写一个完全积极的“zig的伟大” “文章。（毕竟，我稳定地忽略了六个月的杰米涌出了Zig，因为“那是伟大的伙伴，但我已经知道生锈了，我只想让我的键盘完成，好吗？”）</p><p>  我被教育为物理学家和学习的编程，所以我可以制作数据可视化。我的第一语言是PostScript和Ruby（动态，解释语言），我后来移动到JavaScript，所以我可以在Web上绘制克洛尼（使用Clojurescript在网上画画，我花了很多职业生涯。</p><p> 2017年，我决定学习一个系统语言.Partly这是智慧的好奇心 - 我想更熟悉堆栈，堆，指针和静态类型，这些概念是一个留给我作为Web开发人员的糟糕。但主要是因为我希望系统所承诺的系统语言的能力：</p><p> 写快速的代码;这可能利用计算机实际工作方式和运行快速运行的方式。</p><p> 编写可以在最少环境中运行的应用程序，如微控制器或Web组件，在那里它只是不可行（在时间或空间中）携带垃圾收集器，语言运行时等。</p><p> 我的兴趣不是（并且仍然没有）在操作系统，编程语言设计或安全（关于内存，正式的验证，建模为类型等）中。</p><p> 我只是想在屏幕上和关闭屏幕上的leplle正方形。 </p><p>基于其在开源社区的越来越受欢迎和大量的初学者到系统编程文档中，我依靠版本1.18拾取生锈。</p><p> 从那时起，Rust毫无疑问地帮助我实现了我之后的那些能力：我能够将其编译为WASM的布局引擎，构建和销售快速桌面搜索应用程序（锈盛到电子中），并将RUDER编译为STM32G4微控制器要驾驶轨道SAW机器人（我甚至在寄存器定义中找到了一个错字;完整的“硬模式”嵌入式调试体验！）。</p><p> 尽管如此，我仍然不觉得生锈感到舒适。它感觉是分歧复杂的 - 似乎每次我在新项目上使用铁锈，我遇到了一些问题，迫使我面对语言/生态系统的新角落。发展我的键盘固件也不例外：我遇到了两个问题，每个都需要学习一个完全新的语言功能。</p><p> 这些问题并不是真正的嵌入式，但它们代表了过去三年我遇到过锈病的挑战。</p><p> 如果您想要谷植物嵌入的详细信息或了解为什么我根本正在使用Newfangled语言编写自己的固件，请参阅在构建键盘上的笔记。</p><p>  我用Rust遇到的第一个挑战是让我的固件从4-Butte Dev-kit PCB到一个无线拆分到单个ATREUS的左/右半部分时，运行硬件</p><p>  在编译时改变固件的功能被称为“条件编译”。（它需要在编译时间而不是运行时完成，因为微控制器具有有限的程序空间，大约在我的情况下大约为10-100kb。） </p><p>RUST对此问题的解决方案是“功能”，它在Cargo.Toml中定义：</p><p> [依赖关系] cortex-m =＆＃34; 0.6＆＃34; nrf52840-hal = {version =＆＃34; 0.11＆＃34; ，可选= true，default-feature = false} nrf52833-hal = {version =＆＃34; 0.11＆＃34; ，可选= true，default-feature = false} arraydeque = {version =＆＃34; 0.4＆＃34; ，默认特征= false} reapless =＆＃34; 0.5＆＃34; [特点] Keytron = [＆＃34; NRF52833＆＃34;] Keytron-DK = [＆＃34; NRF52833＆＃34;] SplitaPple = [＆＃34; NRF52840＆＃34;] Splitapple-left = [＆＃34; scletapple＆＃34;] splitapple-ricons = [＆＃34; scletapple＆＃34;]＃在这里指定默认值，以便Rust-Analyzer可以构建项目;在建立使用时 - 不默认 - 功能要关闭此默认= [＆＃34; keytron＆＃34;] nrf52840 = [＆＃34; nrf52840-hal＆＃34;] nrf52833 = [＆＃34; nrf52833-hal＆ ＃34;]</p><p> 例如，为特定键盘硬件设计启用了Keytron功能。硬件取决于NRF52833功能（代表一种微控制器），这取决于NRF52833-HAL箱（将微控制器的外围存储器地址映射到的实际代码） RUDE类型）。</p><p> 然后，我的生锈代码可以使用属性注释来有条件启用stuff.e.g。，命名空间可以导入特定于微控制器的克拉特：</p><p>   fn read_keys（） - ＆gt;数据包{让设备=不安全{hw :: filipherals :: lest（）}; ＃[cfg（任何（特征=＆＃34; keytron＆＃34;特征=＆＃34; Keytron-dk＆＃34;）]让你= {设=设备。 P0。在_ 。读 （）。比特（）;让P1 =设备。 P1。在_ 。读 （）。比特（）; //逆变，因为键是活动低GPIO :: P0 :: Pack（！P0）| GPIO :: P1 :: Pack（！P1）}; ＃[CFG（功能=＆＃34; scletapple＆＃34;）]让你= gpio :: splitapple :: read_keys（）;数据包（U）}</p><p>  可选= true必须添加到Cargo.Toml中的设备箱中（即使源已经有条件要求它们！）</p><p> 如何在构建静态二进制时启用功能（Cargo Build  - 释放 - 不默认 - 功能 -  Features＆＃34; Keytron＆＃34;） </p><p>在某些时候，我放弃了尝试将设备外设传递为函数参数，因为我无法弄清楚如何添加条件属性到类型 - “显而易见”的东西不起作用：  有一个整洁的嵌入式框架，RTIC，其主要入口点是一个应用程序注释，它将设备箱为uh，uh，参数：  考虑扫描键盘矩阵：如果我们没有足够的微控制器引脚将每个键盘切换直接连接到引脚，我们可以将带有二极管（单向阀）的开关将开关放入矩阵：  然后，我们将单列设置为高，然后读出行以查找该列的开关的状态。  在此示例中，如果我们设置引脚1.10高（COL0），然后读取0.13（RON1），我们知道按下开关K8。  为单个引脚执行此操作，例如外围端口P0的PIN 10，很简单：  但我的专栏引脚遍布两个端口，所以我想写的是什么： </p><p>for（端口，PIN）IN＆amp; [（p0,10），（p1,7），..] {端口。 PIN_CNF [PIN]。写（| w | {w.input（）。disconnect（）; w。dir（）。输出（）; w}）; }</p><p> 不会飞行，因为现在元组有不同的类型 - （P0，USIZE）和（P1，USIZIZE） - 因此它们不能在同一收集中挂起。</p><p>  键入pinidx = u8;类型端口= U8; const col_pins：[（port，pinidx）; 7] = [（1,10），（1,13），（1,15），（0,2），（0,29），（1,0），（0,17）]; pub fn init_gpio（）{for（port，pin_idx）IN＆amp; COL_PINS {匹配端口{0 =＆gt; {    设备 。 P0。 PIN_CNF [* PIN_IDX为USIZE]。写（| w | {w.input（）。disconnect（）; w。dir（）。输出（）; w}）; 1 =＆gt; {    设备 。 P1。 PIN_CNF [* PIN_IDX为USIZE]。写（| w | {w.input（）。disconnect（）; w。dir（）。输出（）; w}）; } _ =＆gt; {}}}}</p><p>  但是等等，我听到你问，宏怎么样？哦，是的，我的朋友，我在实际扫描程序中剃了宏牦牛：</p><p> PUB FN READ_KEYS（） - ＆gt; U64 {让设备=不安全{Crate :: HW ::外围设备::窃取（）};让mut键：u64 = 0;宏_rules！ scan_col {（$ col_idx：tt; $（$ low_idx：tt =＆gt; $ key：tt，）*）=＆gt; {让（端口，pin_idx）= col_pins [$ col_idx]; ///////////////// set col high不安全{match port {0 =＆gt; {    设备 。 P0。一开始。写（| W | W.位（1＆lt;＆lt; pin_idx））; 1 =＆gt; {    设备 。 P1。一开始。写（| W | W.位（1＆lt;＆lt; pin_idx））; } _ =＆gt; {}}} cortex_m :: ASM :: Delay（1000）; //读取行并进入打包键U64。 //键是1索引。让Val =设备。 P0。在_ 。读 （）。比特（）; $（键| =（（（（Val＆gt;＆gt; row_pins [$ row_idx]）＆amp; 1）作为u64）＆lt;＆lt;（$ key-1））;）* /////////////////// ////// //设置col低不安全{match port {0 =＆gt; {    设备 。 P0。 outclr。写（| W | W.位（1＆lt;＆lt; pin_idx））; 1 =＆gt; {    设备 。 P1。 outclr。写（| W | W.位（1＆lt;＆lt; pin_idx））; } _ =＆gt; {}}}; }; // col_idx; row_idx =＆gt;键ID＃[CFG（功能=＆＃34; scletapple-left＆＃34;）] {scan_col！ （0; 0 =＆gt; 1,1 =＆gt; 8,2 =＆gt; 15,3 =＆gt; 21,4 =＆gt; 27,5 =＆gt; 33，）; scan_col！ （1; 0 =＆gt; 2,1 =＆gt; 9,2 =＆gt; 16,3 =＆gt; 22,4 =＆gt; 28,5 =＆gt; 34，）; scan_col！ （2; 0 =＆gt; 3,1 =＆gt; 10,2 =＆gt; 17,3 =＆gt; 23,4 =＆gt; 29,5 =＆gt; 35，）; scan_col！ （3; 0 =＆gt; 4,1 =＆gt; 11,2 =＆gt; 18,3 =＆gt; 24,4 =＆gt; 30,5 =＆gt; 36，）; scan_col！ （4; 0 =＆gt; 5,1 =＆gt; 12,2 =＆gt; 19,3 =＆gt; 25,4 =＆gt; 31,5 =＆gt; 37，）; scan_col！ （5; 0 =＆gt; 6,1 =＆gt; 13,2 =＆gt; 20,3 =＆gt; 26,4 =＆gt; 32,5 =＆gt; 38，）; scan_col！ （6; 0 =＆gt; 7,1 =＆gt; 14，）; }＃[CFG（特征=＆＃34; scletapple-overs＆＃34;）] {scan_col！ （0; 0 =＆gt; 1,1 =＆gt; 8,2 =＆gt; 15,3 =＆gt; 23,4 =＆gt; 30,5 =＆gt; 37，）; scan_col！ （1; 0 =＆gt; 2,1 =＆gt; 9,2 =＆gt; 16,3 =＆gt; 24,4 =＆gt; 31,5 =＆gt; 38，）; scan_col！ （2; 0 =＆gt; 3,1 =＆gt; 10,2 =＆gt; 17,3 =＆gt; 25,4 =＆gt; 32,5 =＆gt; 39，）; scan_col！ （3; 0 =＆gt; 4,1 =＆gt; 11,2 =＆gt; 18,3 =＆gt; 26,4 =＆gt; 33,5 =＆gt; 40，）; scan_col！ （4; 0 =＆gt; 5,1 =＆gt; 12,2 =＆gt; 19,3 =＆gt; 27,4 =＆gt; 34,5 =＆gt; 41，）; scan_col！ （5; 0 =＆gt; 6,1 =＆gt; 13,2 =＆gt; 20,3 =＆gt; 28,4 =＆gt; 35,5 =＆gt; 42，）; scan_col！ （6; 0 =＆gt; 7,1 =＆gt; 14,2 =＆gt; 21,3 =＆gt; 29,4 =＆gt; 36,5 =＆gt; 22，）; }键}</p><p>  基本上，每个Scan_Col！宏调用扩展到设置列PIN高的代码中，读出行，并将其状态推向可变键的适当位：U64变量在函数顶部。</p><p> 如果您想更详细地理解，请抓住您最喜爱的饮料，并使用Rust Book的宏观部分或Rust的宏参考文档花费一些优质的时间。 </p><p>我对我来的PIN初始化或矩阵扫描代码不满意，但我是最清晰的我能够写入。从Google结果的第一页的“RUST键盘固件”，它看起来像其他Rustacean解决了这个问题：</p><p> 迭代大量使用和匹配破坏性元组;我喜欢这种宏观方法（我将它拿到我的豪华触摸板），尽管用行/列坐标识别开关意味着每个行/列具有相同数量的交换机，但情况并非总是如此。</p><p> 依赖于（他们的单词）宏以在T元组结构上实现特征对象的迭代器;我不确定这里发生了什么。</p><p> 真正的星际的理解水平;我真的不确定在这里发生了什么。</p><p> 虽然在所有这些解决方案中肯定有很多语言复杂性，但Rust值得比传统方法更卑鄙的荣誉。不失C的臭名昭着的文本预处理器宏（#define，#ifdef等），例如Rust的宏不会导致扩展的莫名语法错误。（所有扩展代码都是选中的类型！）</p><p> Rust的工具太好了 -  Rust Analyzer是足够的，足以了解在跳过围绕代码时的特征注释，我从未弄清楚C.</p><p> 鉴于铁锈贡献者的聪明是多么聪明 - 看看他们在公共RFC进程中所做的所有体内讨论和权衡的权衡 - 我很想得出结论，嗯，所有这些复杂性必须是固有的.Perhaps这只是难以做到的努力时间配置和以安全的编译语言有效地迭代独特的类型？ </p><p>也许，但Zig为令人信服的案例进行了令人信服的案例 - 至少对于我的大流行业余机项目键盘固件 - 我可以通过较少的概念获得。</p><p>  以下是我如何使用Zig通过不同类型解决条件汇编和迭代的这两个问题。（参见Jamie的帖子，以获得Rust和Zig的更全面的比较。）</p><p> 完全披露：这是我用Zig写的第一个代码，因此可能存在更加惯用的或整洁的解决方案。</p><p>       常见的ztron.zig文件然后通过@import（＆＃34; root＆＃34;）（“root”是编译器entrintpoint导入那些公共常量，所以这是一个循环参考;它很好！）直接使用它们：</p><p>  没有特别的“功能”语义来学习，货物。要重新排列，或者标志传递给编译器。货物甚至不存在！</p><p> 要指定要编译的代码，请呃，只需告诉编译器：要编译devkit硬件，请运行zig build-obj dk.zig;对于atreus，zig build-obj atreus.zig。</p><p> 这是作用，因为Zig仅根据需要评估代码。（不仅仅是导入的文件 - 编译器不介意半写入，不良键入的函数，只要它们未被调用。） </p><p>至于键盘矩阵引脚设置？嗯，外围设备仍然是不同的类型，但这是......罚款：</p><p> const行=。{。{。端口= P1，。 PIN = 0}，。{。端口= P1，。 PIN = 1}，。{。端口= P1，。 PIN = 2}，。{。端口= P1，。 PIN = 4}，}; const cols =。{。{。端口= P0，。 PIN = 13}，。{。端口= P1，。 PIN = 15}，。{。端口= P0，。 PIN = 17}。{。端口= P0，。 PIN = 20}，。{。端口= P0，。 PIN = 22}，。{。端口= P0，。 PIN = 24}，。{。端口= P0，。 PIN = 9}，。{。端口= P0，。 PIN = 10}，。{。端口= P0，。 PIN = 4}。{。端口= P0，。 PIN = 26}，。{。端口= P0，。 PIN = 2}，}; PUB FN initkeyboardgpio（）void {inline for（行）| x | {    X 。港口 。 pin_cnf [x。别针 ]。修改（。{。dir =。输入，。输入=。连接，。拉扯=。下拉，}）; }内联（cols）| x | {    X 。港口 。 pin_cnf [x。别针 ]。修改（。{。dir =。输出，。输入=。disconnect，}）; }}</p><p>  这并不是在这里关心生成的机器指令 - 循环实际上是展开的 - 而是语言让我表达我在异构地键入的集合中“循环”的愿望。</p><p>  const col2row2key =。{。{0,1}，。{1,11}，。{2,21}，。{3,32}}，。{。{0,2}，。{1,12 }，。{2,22}。{3,33}}，。{。{0,3}，。{1,13}，。{2,23}，。{3,34}}，{ 。{0，4}，。{1,14}，。{2,24}，。{3,35}}，。{。{0,5}，。{1,15}，。{2,25 }，。{3,36}}，。{2,26}，。{3,37}}，。{。{0,6}，。{1,16}，。{2,27}， 。{3,38}}，。{。{0,7}，。{1,17}，。{2,28}，。{3,39}}，。{。{0,8}，。{ 1,18}，。{2,29}，。{3,40}}，。{0,9}，。{1,19}，。{2,30}，。{3,41}} ，。{。{0,10}，。{1,20}，。{2,31}，。{3， 42}}，}; PUB FN Readkeys（）PackedKeys {var pk = packedkeys。新的 （）; inline for（col2row2key）| row2key，col | {//设置col high cols [col]。港口 。一开始。 write_raw（1＆lt;＆lt; cols [col]。pin）;延迟（1000）; const val =行[0]。港口 。在 。 read_raw（）; inline for（row2key）| row_idx_and_key | {const row_pin =行[row_idx_and_key [0]]。别针 ; PK。键[（row_idx_and_key [1]  -  1）] =（1 ==（（val＆gt; row_pin）＆amp; 1））; } //设置Col Low Cols [Col]。港口 。 outclr。 write_raw（1＆lt;＆lt; cols [col]。pin）;返回pk; }</p><p> 概念上的Zig内联求解Rust的语法宏解决的同一问题（在编译时生成特定于类型的代码），但没有学习LIL'模式匹配/扩展语言的侧面追求。</p><p> 实际上，由于行/列/交换机布局存在于CONST结构中，因此可以使用它来计算.G，以计算（在编译时）键盘上的开关数：</p><p> pub const switch_count = comptime {var n = 0; for（col2row2key）| x | n + = x。 len;返回n; }; </p><p>我不知道如何从生锈语法宏调用中完成这一点：  scan_col！ （0; 0 =＆gt; 1,1 =＆gt; 8,2 =＆gt; 15,3 =＆gt; 21,4 =＆gt; 27,5 =＆gt; 33，）;  （虽然我确定它是可能的 - 专家发现，锈宏可以达到500左右，也许有一天，达到更大的数字。）  使用Zig只是几个小时突出了我的生锈方面，我从未考虑过。特别的是，我对域的无意识的复杂性大大 - “这是系统编程就像” - 是的 事实上，刻意的防锈设计决策的结果。  例如，它现在非常清楚，生锈是一种含别人  ...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://kevinlynagh.com/rust-zig/">https://kevinlynagh.com/rust-zig/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/键盘/">#键盘</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/一致性/">#一致性</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1050971.html"><img src="http://img2.diglog.com/img/2021/3/thumb_51afa555e07b0b63c68750b72a3388c9.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1050971.html">用下降Ctrl在机械键盘兔孔上打字 </a></div><span class="my_story_list_date">2021-3-7 10:32</span></div><div class="col-sm"><div><a target="_blank" href="/story/1050161.html"><img src="http://img2.diglog.com/img/2021/3/thumb_2ad8cf9d270a33e24d1a9916cf707bfd.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1050161.html">TechCrunch编辑人员的键盘 </a></div><span class="my_story_list_date">2021-3-1 23:58</span></div><div class="col-sm"><div><a target="_blank" href="/story/1048222.html"><img src="http://img2.diglog.com/img/2021/2/thumb_8bbc3c1018b9d713fcaeacd964890308.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1048222.html">新型M是美国制造的键盘，可为您的打字增添弹性 </a></div><span class="my_story_list_date">2021-2-18 16:54</span></div><div class="col-sm"><div><a target="_blank" href="/story/1048087.html"><img src="http://img2.diglog.com/img/2021/2/thumb_2c1b39c0afe786278528f3d92463870e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1048087.html">超级用户：“为什么Windows认为我的无线键盘是烤面包机？” </a></div><span class="my_story_list_date">2021-2-18 3:5</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>