<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>对话–互动小说的领域特定语言 Dialog – domain-specific language for interactive fiction</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Dialog – domain-specific language for interactive fiction<br/>对话–互动小说的领域特定语言 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-04 00:35:54</div><div class="page_narrow text-break page_content"><p>Disclaimer: I am not responsible for what people (other than myself) write in the forums. Please report any abuse, such as insults, slander, spam and illegal material, and I will take appropriate actions. Don&#39;t feed the trolls.</p><p>免责声明：我对别人（除了我自己）在论坛中写的内容不承担任何责任。请举报任何侮辱，诽谤，垃圾邮件和非法材料之类的虐待行为，我将采取适当的措施。不要给巨魔喂食。</p><p> Jag tar inget ansvar för det som skrivs i forumet, förutom mina egna inlägg. Vänligen rapportera alla inlägg som bryter mot reglerna, så ska jag se vad jag kan göra. Som regelbrott räknas till exempel förolämpningar, förtal, spam och olagligt material. Mata inte trålarna.</p><p> 除我自己的帖子外，我对论坛中的内容不承担任何责任。请举报任何违反规则的帖子，我将拭目以待。违规包括例如侮辱，诽谤，垃圾邮件和非法材料。不要喂拖网。</p><p> if I have an object in a closed transparent container how do I override the default &#39;you can&#39;t reach obj&#39; take fail message?  (instead of [take *]) doesn&#39;t seem to work in this case (scope?)</p><p> 如果我在封闭的透明容器中有一个对象，该如何覆盖默认值＆＃39;您可以＆＃39; t不能达到obj＆＃39;接受失败消息？ （而不是[take *]）＆＃39; t在这种情况下似乎不起作用（范围？）</p><p> if I have an object in a closed transparent container how do I override the default &#39;you can&#39;t reach obj&#39; take fail message?  (instead of [take *]) doesn&#39;t seem to work in this case (scope?)</p><p> 如果我在封闭的透明容器中有一个对象，该如何覆盖默认值＆＃39;您可以＆＃39; t不能达到obj＆＃39;接受失败消息？ （而不是[take *]）＆＃39; t在这种情况下似乎不起作用（范围？）</p><p> The &#34;can&#39;t reach&#34; message is printed by (refuse $), which is invoked before instead-of. So you can override refuse with a negated rule:  ~(refuse [take *]) %% Don&#39;t refuse to take this object.</p><p> ＆＃34;可以＆＃39;无法到达＆＃34;消息由（拒绝$）打印，它在代替之前被调用。因此，您可以使用否定规则覆盖拒绝：〜（refuse [take *]）%% Don＆＃39; t拒绝接受此对象。</p><p> Is it possible to suppress implicit actions temporarily. For example 1.dropping something in a held container first tries to take the object before dropping.  2. putting something into something where the first something is in a held container tries to take before putting in  If I know that the take will always succeed can I suppress the first trying to take reporting.</p><p> 是否可以暂时抑制隐式动作。例如1.在放置的容器中放置东西首先要尝试在放置之前取走物体。 2.将某物放入第一个存放在存放容器中的东西，然后再尝试放入。如果我知道该提取将永远成功，那么我可以禁止执行第一个尝试进行报告的事情。</p><p> If I know that the take will always succeed can I suppress the first trying to take reporting.</p><p> 如果我知道举报将永远成功，那么我可以取消第一次举报的尝试。 </p><p> Yes, there are several ways. You can override the before-predicate for that particular case, with a negative rule. For each particular action:  ~(before [drop $X])         ($X is #in $Y)         ($Y is #heldby $Z)         (current player $Z)  But many actions invoke a common predicate, &#39;(ensure $ is held)&#39;, and you can add a new rule to that one instead:  (ensure $X is held)         ($X is #in $Y)         ($Y is #heldby $Z)         (current player $Z)  When the given conditions are true, your rule will succeed, and this prevents the later rule definition in the library from executing.</p><p>是的，有几种方法。您可以使用否定规则覆盖该特定情况的先行谓词。对于每个特定动作：〜（在[drop $ X]之前）（$ X是$ Y中的#X）（$ Y是$ Z被$ Z持有）（当前玩家$ Z）但是许多动作调用一个公共谓词＆＃39; （确保$被保留）＆＃39 ;，您可以改为向其中添加新规则：（确保$ X被保留）（$ X是$ y中的$ X）（$ Y是$ Z中的$ hold）（当前玩家$ Z）在给定条件为真时，您的规则将成功执行，这将阻止执行库中更高的规则定义。</p><p> The Cloak of Darkness example seems bugged under 0.15. Attempting to go somewhere yields a crash:   fatal error: attempting to store to nonexistent local variable 3:  routine has 0 (pc = 0x2aba)</p><p> 黑暗斗篷示例似乎在0.15以下错误。尝试去某个地方会导致崩溃：致命错误：尝试存储到不存在的局部变量3：例程的值为0（pc = 0x2aba）</p><p> The Cloak of Darkness example seems bugged under 0.15. Attempting to go somewhere yields a crash:   fatal error: attempting to store to nonexistent local variable 3:  routine has 0 (pc = 0x2aba)</p><p> 黑暗斗篷示例似乎在0.15以下错误。尝试去某个地方会导致崩溃：致命错误：尝试存储到不存在的局部变量3：例程的值为0（pc = 0x2aba）</p><p> This is odd. I get the same error when running the first example in chapter 5. I&#39;m running the win32 version of dialogc on Windows 10, in case that matters.</p><p> 这很奇怪。运行第5章中的第一个示例时，我遇到相同的错误。如果重要的话，我正在Windows 10上运行win32版本的dialogc。</p><p> I&#39;ve now checked each release of the compiler, and found that moving between rooms only works under release 0b/01. Later than that leads to the fatal error described above.</p><p> 现在，我检查了编译器的每个发行版，发现在房间之间移动仅在版本0b / 01下有效。迟于导致上述致命错误。</p><p> I&#39;ve now checked each release of the compiler, and found that moving between rooms only works under release 0b/01. Later than that leads to the fatal error described above.</p><p> 现在，我检查了编译器的每个发行版，发现在房间之间移动仅在版本0b / 01下有效。迟于导致上述致命错误。</p><p> Not sure if it&#39;s related but I only get the error when using Gargoyle. Frotz doesn&#39;t give the error. (latest versions Windows 10)</p><p> 不知道它是否相关，但是我只在使用石像鬼时得到错误。 Frotz没有给出错误。 （最新版本的Windows 10） </p><p> Not sure if it&#39;s related but I only get the error when using Gargoyle. Frotz doesn&#39;t give the error. (latest versions Windows 10)</p><p>不知道它是否相关，但是我只在使用石像鬼时得到错误。 Frotz没有给出错误。 （最新版本的Windows 10）</p><p> Thank you. Can verify. Does anyone know the best way to pass a bug report to one of the maintainers?</p><p> 谢谢你。可以验证。有谁知道将错误报告传递给其中一位维护者的最佳方法？</p><p>   Can I reference an object variable from within the scoring options? (increase score by (#object variable))</p><p>   我可以从评分选项中引用对象变量吗？ （将得分增加（#object变量））</p><p> Can I reference an object variable from within the scoring options? (increase score by (#object variable))</p><p> 我可以从评分选项中引用对象变量吗？ （将得分增加（#object变量））</p><p> As a general rule, queries can&#39;t be nested; they don&#39;t even have return values.  (Confusingly, rule heads may contain nested expressions, but that is a special case of syntactic sugar.)  But output can be communicated using ordinary parameters. To take the output from one query, and use it as input in another, you would write the queries one after the other. Then you&#39;d use a variable to carry the value.  Assuming you have a predicate ($ has score $) that assigns a score to every object:          (#object has score $X) %% Here, $X becomes bound (i.e. to the output).         (increase score by $X) %% Use the value of $X as input.</p><p> 通常，查询不能嵌套；他们甚至没有返回值。 （令人困惑的是，规则头可能包含嵌套表达式，但这是语法糖的特例。）但是可以使用普通参数来传递输出。要从一个查询中获取输出，并在另一个查询中用作输入，则可以一个接一个地编写查询。然后，您将使用变量来携带值。假设您有一个谓词（$得分为$）为每个对象分配一个得分：（#object的得分为$ X）%%在这里，$ X被绑定（即到输出）。 （将分数增加$ X）%%使用$ X的值作为输入。</p><p> The following code crashes the compiler   If I substitute the (else) with (if), I get a more reasonable message : &#34;Error (if) without (then).  ** The comment editor seems to strip away the indentation ... does it accept some kind of &#39;markup&#39; ? (I.e. the second line (else) *was* indented.  Also I had much more in the source file, I isolated the crash down to these two lines.  Assertion failed!  Program: c:\bats\dialogc.exe File: backend_z.c, Line 3348  Expression: call_lab  -------------------- (story title)		  (else)</p><p> 以下代码使编译器崩溃：如果将（else）替换为（if），则会得到一条更合理的消息：＆＃34; Error（if）不包含（then）。 **评论编辑器似乎剥夺了缩进...是否接受某种标记。 ？ （即第二行（其他）已缩进。另外，我在源文件中还有更多内容，我将崩溃隔离到这两行。声明失败！程序：c：\ bats \ dialogc.exe文件：backend_z。 c，第3348行表达式：call_lab --------------------（故事标题）（其他）</p><p> The actual &#39;realistic&#39; use case for the above was that I had accidentally &#34;not-escaped&#34; the title i.e. (story title) ( Else) test file instead of   (story title) \(Else \) test file</p><p> 实际的＆＃39;＆＃39;上面的用例是我不小心逃脱了标题，即（故事标题）（Else）测试文件而不是（故事标题）\（Else \）测试文件 </p><p> Thanks! I&#39;ll fix that.  There&#39;s currently no tag to retain formatting in the comments; sorry for that. I&#39;ve been using hardspaces to get around it. I suppose I&#39;ll fix that too.</p><p>谢谢！我会解决这个问题。当前没有标签可保留评论中的格式；对此表示抱歉。我一直在使用硬空间来解决它。我想我也会解决这个问题。</p><p> Are global flags (or maybe it&#39;s the (now) predicate) designed to work in &#34;open code&#34; (like global variables?  If I put :  (now)(a-global-flag) in &#34;open code&#34;, I get :  &#34;Special syntax cannot be redefined&#34;  Mike</p><p> 是旨在在开放代码中使用的全局标志（或者也许是（现在）谓词） （像全局变量一样？）如果我在打开代码中放入：（现在）（一个全局标记），我会得到：＆＃34;特殊语法无法重新定义＆＃34; Mike</p><p> Are global flags (or maybe it&#39;s the (now) predicate) designed to work in &#34;open code&#34; (like global variables?  If I put :  (now)(a-global-flag) in &#34;open code&#34;, I get :  &#34;Special syntax cannot be redefined&#34;  Mike</p><p> 是否设计为可在开放代码中使用的全局标志（或也许是现在的谓词）？ （像全局变量一样？）如果我在打开代码中放入：（现在）（一个全局标记），我会得到：＆＃34;无法重新定义特殊语法＆＃34; Mike</p><p> Anything that starts in the very first column of a line is interpreted as a rule definition, so the compiler thinks you&#39;re trying to define a rule for a predicate called &#39;(now)&#39;. But that&#39;s special syntax, so its behaviour can&#39;t be modified.  If you would like the global flag to be initially set, define a rule with an empty rule body:  (a-global-flag)  This is analogous to how the initial values of other kinds of dynamic properties are defined. For instance:  (#box is #heldby #player) (#box is open) (current player #player)</p><p> 从一行的第一列开始的任何内容都将解释为规则定义，因此编译器认为您正在尝试为谓词（现在）定义规则。但这是特殊的语法，因此无法修改其行为。如果希望初始设置全局标志，请定义一个空规则主体的规则：（a-global-flag）这类似于如何定义其他种类的动态属性的初始值。例如：（#box是#heldby #player）（#box已打开）（当前玩家#player）</p><p> Ok, thanks, that works ... but ...  The &#34;first-column-global&#34; (fcg ? :)) is not showing up in the debugger&#39;s @dynamic output.  The flag *does* work though (of course),if I enter (a-global-flag), giving the expected &#34;Query succeeded:(a-global-flag)  The @dy(namic) cmd seems to be only finding global flags that are referenced inside a rule :  (test) __ (now)(a-global-flag)   Mike</p><p> 好的，谢谢，这可行...但是...＆＃34; first-column-global＆＃34; （fcg？:)）没有显示在调试器的@dynamic输出中。如果我输入（a-global-flag），该标志*确实可以工作，但如果成功完成预期的查询：（a-global-flag）@dy（namic）cmd似乎是只找到规则内引用的全局标志：（测试）__（现在）（a-global-flag）迈克</p><p> The @dy(namic) cmd seems to be only finding global flags that are referenced inside a rule</p><p> @dy（namic）cmd似乎仅找到规则内引用的全局标志</p><p> That is correct. A predicate is only considered dynamic if it appears in a (now)-statement somewhere. So, if there&#39;s a (now) (a-global-flag) somewhere, then (a-global-flag) is regarded as a boolean variable that can be toggled at runtime. And its initial value is determined by the rule definitions for it. Otherwise, it behaves more like a boolean-valued function, and the rule definitions make up its function body.  It&#39;s a matter of terminology. Something that can change is dynamic, but something that cannot possibly change is not.</p><p> 那是正确的。仅当谓词出现在（现在）语句中的某个位置时，该谓词才被认为是动态的。因此，如果某处有一个（现在）（一个全局标志），则（一个全局标志）被视为可以在运行时切换的布尔变量。其初始值由其规则定义确定。否则，它的行为更像是布尔值函数，并且规则定义构成其函数主体。这是一个术语问题。可以改变的东西是动态的，但是不可能改变的东西不是动态的。 </p><p> This crashes both the windows and linux-64 compilers, version  0d02_0_19, and 0e01_0_20,but NOT the 0c05_0_17 version   #gnue (name *)	gnue (dict *)	plane (vehicle *)   Again it&#39;s only a code fragment, but I was trying to split a larger program into multiple files.  Mike</p><p>这会使Windows和linux-64编译器版本0d02_0_19和0e01_0_20崩溃，但不会使0c05_0_17版本#gnue（name *）gnue（dict *）plane（vehicle *）崩溃。我试图将一个较大的程序拆分为多个文件。麦克风</p><p> Thank you! I can reproduce it. Amusingly, I can get the program to compile by adding a room:  (room #x)  But it&#39;s still a compiler bug, of course, and I&#39;ll fix it as soon as possible.</p><p> 谢谢！我可以复制它。有趣的是，我可以通过添加一个房间来使程序得以编译：（room #x）但是，它当然仍然是一个编译器错误，我会尽快修复它。</p><p>  I think there may be a bug with (fungibility enabled appearance $ $ $)  I noticed that when I had (fungibility enabled) an explicit (appearance $ $ $) rule set on an object did not fire until the object had been moved. After a bit of digging I came to the conclusion that the problem was with stdlib line 3788. What seems to be happening is that when nothing&#39;s been touched the list being handled by (fungibility-enabled appearance $ $ $) starts with an object with no appearance, which means that a rule fails on the first object and it never recurses.  If I add an (or) so that it reads  (if)($Ninc = 1)(then)  (appearance $Head $Rel $Loc)  (or)  it works. I&#39;m not sure that adding an (or) simply to prevent failure is good style of course ...  Paul</p><p>  我认为可能存在一个带有（启用可替换性的外观$ $ $）的错误，我注意到当我在某个对象上设置（启用可替换性）一个显式（外观$ $ $）规则时，该对象不会移动，直到该对象被移动。经过一番挖掘，我得出的结论是问题出在stdlib第3788行。似乎正在发生的事情是，当什么都没有碰到时，由（启用可移植性的外观$ $ $）处理的列表开始于没有外观的对象，这意味着规则在第一个对象上失败，并且永远不会重复发生。如果我添加一个（or）使其读为（if）（$ Ninc = 1）（then）（外观$ Head $ Rel $ Loc）（或），它将起作用。我不确定添加（或）只是为了防止失败是当然的好方法...保罗</p><p> Thank you! This was indeed a bug, and I&#39;ve added the &#39;(or)&#39; in library version 0.24. I think it&#39;s a reasonably clean fix. The alternative would have been to add a default rule definition for &#39;(appearance $ $ $)&#39; with a blank rule body, but such a change would also have affected stories that do not make use of fungibility, so I decided against it. For now, at least.</p><p> 谢谢！这确实是一个错误，因此我添加了＆＃39;（or）＆＃39;在库版本0.24中。我认为这是一个相当干净的解决方案。另一种选择是为＆＃39;（appearance $ $ $）＆＃39;添加默认规则定义。规则主体为空白，但这样的更改也会影响没有利用可替代性的故事，因此我决定反对。至少现在。</p><p> I can&#39;t seem to build this. backend.c and backend_z.h seem to be missing from the tarball.</p><p> 我似乎无法建立这个。在压缩包中似乎缺少backend.c和backend_z.h。</p><p> I can&#39;t seem to build this. backend.c and backend_z.h seem to be missing from the tarball.</p><p> 我似乎无法建立这个。在压缩包中似乎缺少backend.c和backend_z.h。</p><p> Whoops! Should be fixed now in 0g/02, which is otherwise identical.</p><p> 哎呀！现在应该固定在0g / 02中，否则相同。 </p><p> I can&#39;t seem to build this. backend.c and backend_z.h seem to be missing from the tarball.</p><p>我似乎无法建立这个。在压缩包中似乎缺少backend.c和backend_z.h。</p><p> Whoops! Should be fixed now in 0g/02, which is otherwise identical.</p><p> 哎呀！现在应该固定在0g / 02中，否则相同。</p><p>  That got me going, thanks. Have you ever considered putting this in a public repository so that others can contribute, too?   I really like the idea of this system: it&#39;s a nice sweet spot between writing and programming.</p><p>  那让我走了，谢谢。您是否曾经考虑过将其放在公共存储库中，以便其他人也可以做出贡献？我真的很喜欢这个系统的想法：它是编写和编程之间的一个好地方。</p><p> I have published a mostly-complete conversion of Pick Up the Phone Booth and Die to Dialog.  https://github.com/jpcompton/Dialog-diversions  Please enjoy dubious code examples, make improvements, or be inspired to greater heights!</p><p> 我已经发布了《拾起电话亭和骰子到对话框》的几乎完整的转换。 https://github.com/jpcompton/Dialog-diversions请欣赏可疑的代码示例，进行改进或激发灵感！</p><p> I just tried a hello world example and segfaulted the compiler (Dialog, release 0h/02, library 0.30, prebuilt for Linux x64)  $ cat test.dg  (story ifid) B0E2A7D1-45F7-46A1-8348-53ADA71F2CD8 (program entry point)  We&#39;ll find out how this works, slowly.  $ valgrind dialogc test.dg ==14539== Memcheck, a memory error detector ==14539== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al. ==14539== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info ==14539== Command: dialogc test.dg ==14539==  ==14539== Invalid read of size 1 ==14539== at 0x12A4FA: addstr_escape.constprop.1 (in /usr/local/bin/dialogc) ==14539== by 0x12AE3D: emit_blorb (in /usr/local/bin/dialogc) ==14539== by 0x129FF1: backend_z (in /usr/local/bin/dialogc) ==14539== by 0x10D487: main (in /usr/local/bin/dialogc) ==14539== Address 0x0 is not stack&#39;d, malloc&#39;d or (recently) free&#39;d ==14539==  ==14539==  ==14539== Process terminating with default action of signal 11 (SIGSEGV) ==14539== Access not within mapped region at address 0x0 ==14539== at 0x12A4FA: addstr_escape.constprop.1 (in /usr/local/bin/dialogc) ==14539== by 0x12AE3D: emit_blorb (in /usr/local/bin/dialogc) ==14539== by 0x129FF1: backend_z (in /usr/local/bin/dialogc) ==14539== by 0x10D487: main (in /usr/local/bin/dialogc) ==14539== If you believe this happened as a result of a stack ==14539== overflow in your program&#39;s main thread (unlikely but ==14539== possible), you can try to increase the size of the ==14539== main thread stack using the --main-stacksize= flag. ==14539== The main thread stack size used in this run was 8388608. ==14539==  ==14539== HEAP SUMMARY: ==14539== in use at exit: 613,930 bytes in 657 blocks ==14539== total heap usage: 1,170 allocs, 513 frees, 1,450,866 bytes allocated ==14539==  ==14539== LEAK SUMMARY: ==14539== definitely lost: 7,600 bytes in 50 blocks ==14539== indirectly lost: 206,966 bytes in 102 blocks ==14539== possibly lost: 0 bytes in 0 blocks ==14539== still reachable: 399,364 bytes in 505 blocks ==14539== suppressed: 0 bytes in 0 blocks ==14539== Rerun with --leak-check=full to see details of leaked memory ==14539==  ==14539== For counts of detected and suppressed errors, rerun with: -v ==14539== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) Segmentation fault (core dumped)</p><p> 我只是尝试了一个hello世界示例，并对编译器（对话框，版本0h / 02，库0.30，针对Linux x64预先构建）进行了段错误处理$ cat test.dg（story ifid）B0E2A7D1-45F7-46A1-8348-53ADA71F2CD8（程序入口点）我们将慢慢找出它是如何工作的。 $ valgrind dialogc test.dg == 14539 == Memcheck，内存错误检测器== 14539 ==版权所有（C）2002-2017，以及Julian Seward等人的GNU GPL＆＃39; d。 == 14539 ==使用Valgrind-3.13.0和LibVEX;使用-h重新运行以获取版权信息== 14539 ==命令：dialogc test.dg == 14539 == == 14539 ==大小为1的无效读取== 14539 ==在0x12A4FA：addstr_escape.constprop.1（在/ usr中/ local / bin / dialogc）== 14539 ==通过0x12AE3D：emit_blorb（在/ usr / local / bin / dialogc中）== 14539 ==通过0x129FF1：backend_z（在/ usr / local / bin / dialogc中）== 14539 ==通过0x10D487：main（在/ usr / local / bin / dialogc中）== 14539 ==地址0x0不是堆栈，malloc或（最近）空闲== 14539 = = == 14539 == == 14539 ==进程以信号11（SIGSEGV）的默认操作终止== 14539 ==访问不在地址0x0的映射区域内== 14539 ==在0x12A4FA：addstr_escape.constprop.1（in / usr / local / bin / dialogc）== 14539 ==通过0x12AE3D：emit_blorb（在/ usr / local / bin / dialogc中）== 14539 ==通过0x129FF1：backend_z（在/ usr / local / bin / dialogc）= = 14539 ==通过0x10D487：main（在/ usr / local / bin / dialogc中）== 14539 ==如果您认为这是由于堆栈而导致的== 14539 ==程序主线程中的溢出（不太可能，但== 14539 == possi ble），您可以尝试使用--main-stacksize =标志来增加== 14539 ==主线程堆栈的大小。 == 14539 ==此运行中使用的主线程堆栈大小为8388608。== 14539 == == 14539 ==堆摘要：== 14539 ==出口处使用：657块中的613,930字节== 14539 ==总堆使用量：1,170个分配，513个释放，1,450,866个字节已分配== 14539 == == 14539 ==泄漏摘要：== 14539 ==绝对丢失：50个块中的7,600字节== 14539 ==间接丢失：206,966字节102个块== 14539 ==可能丢失：0个字节中的0个字节== 14539 ==仍可访问：505个块中的399,364个字节== 14539 ==被抑制：0个块中的0个字节== 14539 ==用--leak重新运行-check = full以查看泄漏的内存的详细信息== 14539 == == 14539 ==对于检测到的和抑制的错误计数，请重新运行：-v == 14539 ==错误摘要：1个上下文中有1个错误（抑制：0从0开始）分段错误（核心已转储）</p><p>  I just tried a hello world example and segfaulted the compiler (Dialog, release 0h/02, library 0.30, prebuilt for Linux x64)</p><p>  我只是尝试了一个hello world示例，并对编译器进行了段错误处理（Dialog，版本0h / 02，库0.30，已针对Linux x64预先构建）</p><p> Thanks for reporting it!  This appears to happen for small input (i.e. without the standard library), in combination with the zblorb format. I&#39;ll fix it tonight. Meanwhile, either switch to the z8 format or include the standard library.</p><p> 感谢您举报！对于zblorb格式的少量输入（即没有标准库），似乎会发生这种情况。今晚我将修复它。同时，要么切换到z8格式，要么包括标准库。 </p><p> I just tried a hello world example and segfaulted the compiler (Dialog, release 0h/02, library 0.30, prebuilt for Linux x64)</p><p>我只是尝试了一个hello world示例，并对编译器进行了段错误处理（Dialog，版本0h / 02，库0.30，已针对Linux x64预先构建）</p><p> This is now fixed in 0h/03.</p><p> 现在，此问题已在0h / 03中修复。</p><p> Using dialogc-0h03:  The following program crashes the compiler, regardless of the output format. It works on version 0d02.   (program entry point)  (now) ~($ has parent $)  Error messages:  backend_z.c:2010: generate_code: Assertion `ci-&gt;oper[0].value != DYN_HASPARENT&#39; failed. and  backend_aa.c:1350: compile_routines: Assertion `ci-&gt;oper[0].value != DYN_HASPARENT&#39; failed.  --------------------------------------------------------  The following three programs crash the compiler when compiling for the Aa-machine but work fine on the Z-machine:   (program entry point)  (#a = $X)  Error message:  backend_aa.c:752: encode_dest: Assertion `0&#39; failed.  --------------------------------------------------------  Note: I have been unable to minimize this program further because removing any line will cause the crash to disappear.   (program entry point)  ($x = 3)  ($y = 3)  ($ = $)  ([#a #b] = [#a #b])  ([#a #b] = [#b #a])  ([1 [@a] 3] = [1 [@a] 3])  ([1 [@a #b] 3] = [2 [@a #b] 3])  ([1 [@a #b] 3] = [1 [@a #b] 3])  ([1 2 3 4] = [$a $b $c $d])  Error message:  backend_aa.c:3151: opersize: Assertion `aao.value &lt;= 0x3f&#39; failed.  --------------------------------------------------------  And a similar program, also as simplified as possible:   (program entry point)  ($x = 3)  ($y = 3)  ($ = $)  ([#a] = [])  ([#a #b] = [#a #b])  ([#a #b] = [#b #a])  ([1 [#a #b] 3] = [1 [#a #b] 3])  ([1 [#a #b] 3] = [2 [#a #b] 3])  ([1 [#a #b] 3] = [1 [#a #b] 3])  ([1 [#a #b] 3] = [1 [#a] 3])  Error message:  backend_aa.c:3151: opersize: Assertion `aao.value &lt;= 0x3f&#39; failed.</p><p> 使用dialogc-0h03：无论输出格式如何，以下程序都会使编译器崩溃。它适用于版本0d02。 （程序入口点）（现在）〜（$具有父$）错误消息：backend_z.c：2010：generate_code：断言`ci-> oper [0] .value！= DYN_HASPARENT＆＃39;失败的。 and backend_aa.c：1350：compile_routines：断言`ci-> oper [0] .value！= DYN_HASPARENT＆＃39;失败的。 -------------------------------------------------- ------以下三个程序在为Aa机进行编译时会使编译器崩溃，但在Z机上可以正常工作：（程序入口点）（＃a = $ X）错误消息：backend_aa.c：752： encode_dest：断言“ 0＆＃39;失败的。 -------------------------------------------------- ------注意：我无法进一步最小化该程序，因为删除任何行都将导致崩溃消失。 （程序入口点）（$ x = 3）（$ y = 3）（$ = $）（[#a #b] = [#a #b]）（[#a #b] = [#b #a ]）（[1 [@a] 3] = [1 [@a] 3]）（[1 [@a #b] 3] = [2 [@a #b] 3]）（[1 [@a #b] 3] = [1 [@a #b] 3]）（[1 2 3 4] = [$ a $ b $ c $ d]）错误消息：backend_aa.c：3151：opersize：断言`aao .value＆lt; = 0x3f＆＃39;失败的。 -------------------------------------------------- ------还有一个类似的程序，也要尽可能简化：（程序入口点）（$ x = 3）（$ y = 3）（$ = $）（[#a] = []）（[ #a #b] = [#a #b]）（[#a #b] = [#b #a]）（[1 [#a #b] 3] = [1 [#a #b] 3] ）（[1 [#a #b] 3] = [2 [#a #b] 3]）（[1 [#a #b] 3] = [1 [#a #b] 3]）（[1 [#a #b] 3] = [1 [#a] 3]）错误消息：backend_aa.c：3151：opersize：断言`aao.value＆lt; = 0x3f＆＃39;失败的。</p><p> Thanks! I&#39;ll look into these. The first two are corner cases that I hadn&#39;t thought of; they should be easy to fix.  The last two happen because the compiler is running out of registers for holding temporary values. Fixing this involves a more substantial implementation effort that I&#39;ve been putting off. But it needs to be done, of course.</p><p> 谢谢！我会调查这些。前两个是我没有想到的极端情况；它们应该易于修复。后两种情况的发生是因为编译器用尽了用于保存临时值的寄存器。解决此问题涉及我一直在推迟的更大量的实现工作。但是，这当然需要完成。</p><p> Any chance of linking to the source repo, to accept patches. I&#39;ve found a couple of nits in the documentation I could fix.</p><p> 链接到源存储库以接受补丁的任何机会。我在可以修复的文档中找到了一些建议。</p><p> Is there a GitHub project for this? I noticed a couple of tiny documentation bugs that I would submit a PR for.  Also, what&#39;s the trajectory here: do you know what &#34;feature complete&#34; looks like, and what&#39;s the journey there look like?  I&#39;ve been dabbling in IF for quite some time; As a coder (I work in Clojure) I prefer the Dialog syntax over Inform (as nifty as Inform7 can be).   Also your forums are broken; database error, can&#39;t register.  HLS</p><p> 为此有一个GitHub项目吗？我注意到我要为其提交PR的几个微小的文档错误。另外，这里的轨迹是什么：您知道功能完整吗？看起来怎么样，那里的旅程看起来如何？我已经涉足IF已有一段时间了；作为编码员（我在Clojure工作），我更喜欢Dialog语法而不是Inform（与Inform7一样漂亮）。您的论坛也被打破了；数据库错误，无法注册。 HLS</p><p> Is there a GitHub project for this? I noticed a couple of tiny documentation bugs that I would submit a PR for.</p><p> 为此有一个GitHub项目吗？我注意到我要为其提交PR的几个微小的文档错误。 </p><p> It&#39;s on the todo list. My own repo is intertwined with the development of Tethered, so I have to create a new, public repo with a clean history.   Also, what&#39;s the trajectory here: do you know what &#34;feature complete&#34; looks like, and what&#39;s the journey there look like?</p><p>在Todo列表中＆＃39; s。我自己的回购与系列的发展交织在一起，所以我必须创建一个新的公共回购，并在干净的历史记录。此外，这里的轨迹＆＃39;你知道什么＆＃34;功能完成＆＃34;看起来，什么样的旅程看起来像？</p><p> There&#39;s no detailed long-term plan, but I think the bulk of the functionality is already in place. The Å-machine needs to run on vintage hardware, as promised, and I&#39;m currently working on that. I have some ideas for new bells and whistles, but the core Dialog language feels fairly stable, and will probably evolve in a backwards-compatible way. But I don&#39;t promise this until we get to version 1, which will probably happen when (if) people start to release stuff made in Dialog.    Huh, I haven&#39;t been able to reproduce this. Is it still broken from your end?</p><p> 没有详细的长期计划，但我认为大部分功能已经到位了。 Å-machine需要根据承诺的复古硬件运行，我常用于此。我对新的铃声和吹口哨有一些想法，但核心对话语言感觉相当稳定，并且可能以前后兼容的方式发展。但我不承诺这一点，直到我们到达版本1，这可能会发生（如果）人们开始释放在对话中制作的东西。呵呵，我哈文＆＃39;它能够重现这个。它仍然从你的末端打破了吗？</p><p> Thanks for the update.  I was able to register on the forum this time, so whatever it was, resolved itself.</p><p> 感谢更新。我今天能够在论坛上注册，所以无论它是什么，都解决了。</p><p> So, out of an abundance of hubris, I&#39;m trying to bring Threaded Conversation to Dialog, despite:  - insufficient experience w/ TC in Inform7 - not fully fluent in Inform7 - new to Dialog - very limited time to work on this!   I&#39;m struggling with scope.  Quips are the basic thing in TC - they represent a exchange between the player and the NPC, and include predicates that govern who can say the quip, and how quips directly or indirectly follow each other (plus much more in TC).   So a player command might be ASK BARMAID ABOUT RUMORS and this should be understood as [discuss #whether-rumors-tell-truly with #barmaid].  But my code, as it stands, is failing:  &gt; ask bar maid about rumors  The whether the rumors tell truly isn&#39;t here.  So that&#39;s a scoping issue.   What&#39;s confusing to me is that, when tracing, it looks like it found it:  | | | | | FOUND (understand [ask bar maid rumors] as [discuss #whether-rumors-tell-truly with #barmaid]) /usr/local/share/dialog-if/stdlib.dg:4710  (I haven&#39;t put in any code to restrict quips in any way, that comes soon)  but then Dialog continues on from there:  | | | | | | | | | ENTER (parse [bar maid] as object [1] [13] [1] 0) /usr/local/share/dialog-if/stdlib.dg:4394 | | | | | | | | | QUERY (allowing parse errors) /usr/local/share/dialog-if/stdlib.dg:4395 | | | | | | | | ENTER (split [maid rumors] anywhere into [maid | $] and $) /usr/local/share/dialog-if/stdlib.dg:5273 | | | | | | | | QUERY *(split [rumors] anywhere into $ and $) /usr/local/share/dialog-if/stdlib.dg:5274 | | | | | | | | | ENTER (split [rumors] anywhere into [rumors | $] and $) /usr/local/share/dialog-if/stdlib.dg:5273 | | | | | | | | | QUERY *(split [] anywhere into $ and $) /usr/local/share/dialog-if/stdlib.dg:5274 | | | | | | ENTER (understand [ask bar maid rumors] as [ask $ about $]) /usr/local/share/dialog-if/stdlib.dg:1916  So despite finding a good match, it seems to wander off based on the built-in ask action (?).  Later in the trace it feels like it&#39;s back to my discussing action, but something (even with the trace, it&#39;s hard to follow) deciding that #whether-rumors-tell-truly is not reachable.  I tried adding   ((quip $) in is scope)   to make all quips in scope, but that doesn&#39;t seem to help.   My code so far (cobbled from stdlib.dg and guess work and experimentation):   (rewrite [ask | $Words] into [ask | $TailWords])  (split $Words by [about] into $Person and $MoreWords)  (append $Person $MoreWords $TailWords)  (understand [ask | $Text] as [discuss $Quip with $Person])  *(split $Text anywhere into $Someone and $QuipWords)  *(understand $Someone as single object $Person preferably animate)  *(understand $QuipWords as questioning quip $Quip)  (understand $Words as questioning quip $Quip)  *(understand $Words as quip $Quip)  (questioning quip $Quip)  (understand $Words as quip $Quip)  (filter $Words into $Filtered)  (nonempty $Filtered)  (determine object $Quip)  *(quip $Quip)  %% TODO: In scope for conversation ...  (from words)  *(dict $Quip)  (matching all of $Filtered)    So I thought I&#39;d check to see if I&#39;m even headed in the right direction on this.  For TC managing the scope is pretty essential; TC is about a balance of revealing what you can talk about in the current point of the current conversation without giving away other possible conversation quips that don&#39;t (yet) apply. So ultimately, whether Dialog should recognize &#39;rumors&#39; as referring the quip depends on who the player is conversing with, what quips have already been performed, and whether a potential quip follows (directl</p><p> 所以，逃离哈布里斯的丰富，我试图将线程对话带到对话框，尽管：-TC在Inform7中没有足够的经验 - 没有完全流利的Inform7  - 对话 - 新的对话 - 非常有限的时间 - 非常有限的时间！！我挣扎着挣扎着。 Quips是TC中的基本问题 - 它们代表了玩家和NPC之间的交换，包括治理谁可以说Quip的谓词，以及如何直接或间接地互相遵循（加上TC更多的Quifs）。所以一个玩家命令可能会询问传言的竞争，这应该被理解为[讨论＃是否与#barmaid真正讲述。但是我的代码，就像它所说，失败：＆gt;问酒吧女仆关于谣言谣言是否告诉真正的isn＆＃39; t这里。所以它的一个范围问题。令我困惑的是，当追踪时，它看起来像它找到它：| | | | |找到（理解[询问酒吧女仆谣言]作为[讨论＃rumors-thel-truce-stural #barmaid]）/usr/local/share/dialog-if/stdlib.dg:4710（我viden＆＃39; t进来任何代码以任何方式限制Quips，即很快就会限制Quips），但随后对话框继续存在：| | | | | | | | |进入（解析[栏长]作为对象[1] [13] [1] 0）/usr/local/share/dialog-if/stdlib.dg:4394 | | | | | | | | |查询（允许解析错误）/usr/local/share/dialog-if/stdlib.dg:4395 | | | | | | | |进入（将[MAID RUMORS]拆分到[MAID | $]和$）/usr/local/share/dialog-if/stdlib.dg:5273 | | | | | | | |查询*（将[谣言]拆分为$和$）/usr/local/share/dialog-if/stdlib.dg:5274 | | | | | | | | |输入（将[谣言]拆分为[谣言| $]和$）/usr/local/share/dialog-if/stdlib.dg:5273 | | | | | | | | |查询*（将[]拆分为$和$）/usr/local/share/dialog-if/stdlib.dg:5274 | | | | | |进入（理解[ark maid rumors]作为[ask $ the $]）/usr/local/share/dialog-if/stdlib.dg:1916所以尽管找到了一个很好的匹配，但它似乎基于内置的徘徊在询问行动（？）。后来在痕迹中，感觉就像它＆＃39;回到我的讨论行动，但是，即使是痕迹，它难以追随它）决定＃谣言 - 判断真的是无法到达的。我尝试在范围内添加（（Quip $））来制作范围的所有Quips，但它似乎有助于帮助。到目前为止，我的代码（从Stdlib.dg堆放和猜测工作和实验）:(将[ark | $ look]重写为[ask | $ tailwords]（通过[tem]拆分为$ person和$ morewords）（附加$ person $ morewords $ tailwords）（理解[ask | $ text]作为[与$ persons]的[讨论$ quip]）*（将$ temint拆分为$某人和$ quipwords）*（理解$某人作为单个对象$人员，最好是动画）*（理解$ Quipwords质疑Quip $ Quip）（理解$单词作为质疑Quip $ Quip）*（理解$单词作为Quip $ Quip）（质疑Quip $ Quip）（理解$单词作为Quip $ Quip）（过滤器$单词进入$ filtered）（nonempty $ filtered）（确定对象$ quip）*（quip $ quip）%% todo：在​​对话的范围内......（来自单词）*（dict $ quip）（匹配$ zhip）（匹配$ zhip）所以我以为我＆＃39检查我是否甚至在正确的方向上朝着正确的方向前进。对于管理范围的TC非常重要; TC是关于揭示您在当前对话的当前点谈论的平衡，而不会赠送Don＆＃39; T（尚未）的其他可能的对话Quips。最终，对话是否应该识别＆＃39;谣言＆＃39;由于引用Quip取决于玩家正在与谁交往，已经执行了哪些Quips，以及潜在的Quip是否遵循（DirectL</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.linusakesson.net/dialog/index.php">https://www.linusakesson.net/dialog/index.php</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/小说/">#小说</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/domain/">#domain</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>