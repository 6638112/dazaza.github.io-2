<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>每个程序员绝对、积极地需要了解的编码（2011）What Every Programmer Absolutely, Positively Needs To Know About Encodings (2011)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What Every Programmer Absolutely, Positively Needs To Know About Encodings (2011)<br/>每个程序员绝对、积极地需要了解的编码（2011）</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 09:43:29</div><div class="page_narrow text-break page_content"><p>What every programmer absolutely, positively needs to know about encodings and character sets to work with text</p><p>每一个程序员都绝对、积极地需要了解编码和字符集来处理文本</p><p> If you are dealing with text in a computer, you need to know about encodings. Period. Yes, even if you are just sending emails. Even if you are just  receiving emails. You don&#39;t need to understand every last detail, but you must at least know what this whole &#34;encoding&#34; thing is about. And the good news first: while the topic  can get messy and confusing, the basic idea is really, really simple.</p><p>如果你在计算机中处理文本，你需要了解编码。时期是的，即使你只是发送电子邮件。即使你只是收到电子邮件。你没有&#39；我不需要理解每一个细节，但你至少必须知道这整个&#34；编码&#34；事情是这样的。首先，好消息是：虽然这个话题可能会变得混乱，令人困惑，但基本思路非常非常简单。</p><p> This article is about encodings and character sets. An article by Joel Spolsky entitled  The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!) is a nice introduction to the topic and I greatly enjoy reading it every once in a while. I hesitate to refer people to it who have trouble understanding encoding problems though since, while entertaining, it is pretty light on actual technical details. I hope this article can shed some more light on what exactly an encoding is and just why all your text screws up when you least need it. This article is aimed at developers (with a focus on PHP), but any computer user should be able to benefit from it.</p><p>本文是关于编码和字符集的。Joel Spolsky的一篇文章，题为《绝对最小值——每个软件开发人员绝对、肯定必须了解Unicode和字符集》（没有借口！）这是一个很好的主题介绍，我非常喜欢偶尔读一读。我不太愿意让那些在理解编码问题上有困难的人使用它，尽管这很有趣，但它对实际的技术细节却非常浅显。我希望这篇文章能进一步阐明编码到底是什么，以及为什么在你最不需要的时候，你的所有文本都会出错。本文的目标是开发人员（重点是PHP），但任何计算机用户都应该能够从中受益。</p><p>  Everybody is aware of this at some level, but somehow this knowledge seems to suddenly disappear in a discussion about text, so let&#39;s get it out first: A computer cannot store &#34;letters&#34;, &#34;numbers&#34;, &#34;pictures&#34; or anything else. The only thing it can store and work with are  bits. A bit can only have two values:  yes or  no,  true or  false,  1 or  0 or whatever else you want to call these two values. Since a computer works with electricity, an &#34;actual&#34; bit is a blip of electricity that either is or isn&#39;t there. For humans, this is usually represented using  1 and  0 and I&#39;ll stick with this convention throughout this article.</p><p>在某种程度上，每个人都知道这一点，但不知何故，这种知识似乎突然消失在关于文本的讨论中，所以让&#39；让我们先把它拿出来：计算机不能存储&#34；字母&#34&#34;数字&#34&#34;图片&#34；或者别的什么。它唯一能存储和使用的东西是比特。一个位只能有两个值：是或否、真或假、1或0或任何你想称之为这两个值的值。因为计算机是用电工作的，所以&#34；实际和#34；bit是电的一点，要么是，要么不是&#39；不在那里。对于人类来说，这通常用1和0以及I&#39来表示；在这篇文章中，我们将坚持这个惯例。</p><p> To use bits to represent anything at all besides bits, we need rules. We need to convert a sequence of bits into something like letters, numbers and pictures using an  encoding scheme, or  encoding for short. Like this:</p><p>要用位来表示除位之外的任何东西，我们需要规则。我们需要使用一种编码方案，或简称编码，将一系列位转换成字母、数字和图片。这样地：</p><p>  In this  encoding,  01100010 stands for the letter &#34;b&#34;,  01101001 for the letter &#34;i&#34;,  01110100 stands for &#34;t&#34; and  01110011 for &#34;s&#34;. A certain sequence of bits stands for a letter and a letter stands for a certain sequence of bits. If you can keep this in your head for 26 letters or are really fast with looking stuff up in a table, you could read bits like a book.</p><p>在这种编码中，01100010代表字母#34；b&#34；，01101001为字母&#34；我&#34；，01110100代表&#34；t&#34；和011110011用于&#34；s&#34；。一个特定的位序列代表一个字母，一个字母代表一个特定的位序列。如果你能把它记在脑子里26个字母，或者在桌子上快速查找东西，你可以像读一本书一样读一些东西。</p><p> The above encoding scheme happens to be ASCII. A string of  1s and  0s is broken down into parts of eight bit each (a  byte for short). The ASCII encoding specifies a table translating bytes into human readable letters. Here&#39;s a short excerpt of that table:</p><p>上述编码方案恰好是ASCII码。由1和0组成的字符串被分解成8位的部分（简称一个字节）。ASCII编码指定将字节转换为人类可读字母的表格。这里&#39；下面是该表格的一个简短摘录：</p><p>  There are 95 human readable characters specified in the ASCII table, including the letters A through Z both in upper and lower case, the numbers 0 through 9, a handful of punctuation marks and characters like the dollar symbol, the ampersand and a few others. It also includes 33 values for things like space, line feed, tab, backspace and so on. These are not  printable per se, but still visible in some form and useful to humans directly. A number of values are only useful to a computer, like codes to signify the start or end of a text. In total there are 128 characters defined in the ASCII encoding, which is a nice round number (for people dealing with computers), since it uses all possible combinations of 7 bits ( 0000000,  0000001,  0000010 through  1111111).  1</p><p>ASCII表中指定了95个人类可读字符，包括大写和小写字母A到Z、数字0到9、少量标点符号和字符，如美元符号、符号和其他一些字符。它还包括空间、换行、制表符、退格等33个值。它们本身不可打印，但仍以某种形式可见，对人类直接有用。许多值只对计算机有用，比如表示文本开始或结束的代码。ASCII编码总共定义了128个字符，这是一个很好的整数（对于与计算机打交道的人来说），因为它使用了7位的所有可能组合（0000000、0000001、0000010到1111111）。1.</p><p> And there you have it, the way to represent human-readable text using only  1s and  0s.</p><p>现在你有了它，一种只使用1和0来表示人类可读文本的方法。</p><p>   To  encode something in ASCII, follow the table from right to left, substituting letters for bits. To decode a string of bits into human readable characters, follow the table from left to right, substituting bits for letters.</p><p>要用ASCII编码，请按照表格从右到左的顺序，用字母代替位。要将一串位解码为人类可读的字符，请按照表格从左到右的顺序，用位替换字母。</p><p> encode |enˈkōd|  verb [ with obj. ]   convert into a coded form</p><p>编码| enˈkōd |动词[用obj.]转换成编码形式</p><p>  code |kōd|  noun   a system of words, letters, figures, or other symbols substituted for other words, letters, etc.</p><p>代码| kōd |名词一个由单词、字母、数字或其他符号组成的系统，用来代替其他单词、字母等。</p><p> To  encode means to use something to represent something else. An  encoding is the set of rules with which to convert something from one representation to another.</p><p>编码意味着用某物来表示其他的东西。编码是一组规则，用于将某个事物从一种表示形式转换为另一种表示形式。</p><p>  The set of characters that can be encoded. &#34;The ASCII encoding encompasses a character set of 128 characters.&#34; Essentially synonymous to &#34;encoding&#34;.</p><p>可以编码的字符集&#34;ASCII编码包含128个字符的字符集&#34; 本质上与&#34同义；编码&#34；。</p><p>  A &#34;page&#34; of codes that map a character to a number or bit sequence. A.k.a. &#34;the table&#34;. Essentially synonymous to &#34;encoding&#34;.</p><p>A&#34；第34页；将字符映射到数字或位序列的代码。A.k.A.和#34；桌子&#34；。本质上与&#34同义；编码&#34；。</p><p>  A string is a bunch of items strung together. A bit string is a bunch of bits, like  01010011. A character string is a bunch of characters,  like this. Synonymous to &#34;sequence&#34;.</p><p>一根绳子是一堆串在一起的东西。位字符串是一组位，比如01010011。字符串是一组字符，就像这样。与#34同义；顺序&#34；。</p><p>  There are many ways to write numbers. 10011111 in binary is 237 in octal is 159 in decimal is 9F in hexadecimal. They all represent the same value, but hexadecimal is shorter and easier to read than binary. I will stick with binary throughout this article to get the point across better and spare the reader one layer of abstraction. Do not be alarmed to see character codes referred to in other notations elsewhere, it&#39;s all the same thing.</p><p>写数字有很多方法。10011111在二进制中是237在八进制中是159在十进制中是9F在十六进制中。它们都代表相同的值，但十六进制比二进制更短，更容易读取。在本文中，我将坚持使用二进制，以便更好地理解这一点，并为读者节省一层抽象。如果在其他地方看到其他符号中提到的字符代码，请不要惊慌，因为它&#39；都一样。</p><p>  Now that we know what we&#39;re talking about, let&#39;s just say it: 95 characters really isn&#39;t a lot when it comes to languages. It covers the basics of English, but what about writing a risqué letter in French? A Straßen­übergangs­änderungs­gesetz in German? An invitation to a smörgåsbord in Swedish? Well, you couldn&#39;t. Not in ASCII. There&#39;s no specification on how to represent any of the letters é, ß, ü, ä, ö or å in ASCII, so you can&#39;t use them.</p><p>现在我们知道我们&#39；我们在谈论，让&#39；就这么说吧：95个字符真的不是&#39；说到语言，我觉得不多。它涵盖了英语的基础知识，但是用法语写一封情书怎么样？德语中的Straßenübergangsänderungsägesetz？瑞典语的一份邀请信？嗯，你不能&#39；t、 不是ASCII码。那里&#39；没有关于如何在ASCII中表示字母é、ß、ü、ä、ö或å的规范，因此您可以&#39；不要用它们。</p><p> &#34;But look at it,&#34; the Europeans said, &#34;in a common computer with 8 bits to the byte, ASCII is wasting an entire bit which is always set to  0! We can use that bit to squeeze a whole &#39;nother 128 values into that table!&#34; And so they did. But even so, there are more than 128 ways to stroke, slice, slash and dot a vowel. Not all variations of letters and squiggles used in all European languages can be represented in the same table with a maximum of 256 values. So what the world ended up with is  a wealth of encoding schemes, standards, de-facto standards and half-standards that all cover a different subset of characters. Somebody needed to write a document about Swedish in Czech, found that no encoding covered both languages and invented one. Or so I imagine it went countless times over.</p><p>&#34;但看看它，&#34；欧洲人说&#34；在一台字节为8位的普通计算机中，ASCII浪费了一整位，而这一整位总是设置为0！我们可以用这个钻头挤压一个整体#39；表中还有128个值&#34; 他们就是这样做的。但即便如此，仍然有超过128种方法可以划过、切掉、斜线和点元音。并非所有欧洲语言中使用的字母和波形的所有变体都可以在同一个表中以最多256个值表示。因此，世界最终得到了大量的编码方案、标准、事实上的标准和半标准，它们都涵盖了不同的字符子集。有人需要用捷克语写一份关于瑞典语的文件，发现没有编码覆盖两种语言，于是发明了一种。或者说，我想这已经发生了无数次了。</p><p> And not to forget about Russian, Hindi, Arabic, Hebrew, Korean and all the other languages currently in active use on this planet. Not to mention the ones not in use anymore. Once you have solved the problem of how to write mixed language documents in all of these languages, try yourself on Chinese. Or Japanese. Both contain tens of thousands of characters. You have 256 possible values to a byte consisting of 8 bit. Go!</p><p>不要忘了俄语、印地语、阿拉伯语、希伯来语、韩语和所有其他目前在这个星球上活跃使用的语言。更不用说那些不再使用的了。一旦你解决了如何用所有这些语言编写混合语言文档的问题，那就试试中文吧。或者日本人。两者都包含数万个字符。一个由8位组成的字节有256个可能的值。去</p><p>  To create a table that maps characters to letters for a language that uses more than 256 characters, one byte simply isn&#39;t enough. Using two bytes (16 bits), it&#39;s possible to encode 65,536 distinct values.  BIG-5 is such a  double-byte encoding. Instead of breaking a string of bits into blocks of eight, it breaks it into blocks of 16 and has a big (I mean, BIG) table that specifies which character each combination of bits maps to. BIG-5 in its basic form covers mostly Traditional Chinese characters.  GB18030 is another encoding which essentially does the same thing, but includes both Traditional and Simplified Chinese characters. And before you ask, yes, there are encodings which cover only Simplified Chinese. Can&#39;t just have one encoding now, can we?</p><p>要为使用256个字符以上的语言创建一个将字符映射为字母的表，一个字节根本不是&#39；这还不够。使用两个字节（16位），它&#39；可以对65536个不同的值进行编码。BIG-5就是这样一种双字节编码。它不是将一串位分解为八个块，而是将其分解为16个块，并有一个大的（我的意思是，大的）表，指定每个位组合映射到哪个字符。基本形式的BIG-5主要包括繁体汉字。GB18030是另一种基本上做相同事情的编码，但包括繁体和简体汉字。在你问之前，是的，有一些编码只包括简体中文。可以&#39；我们现在不能只有一种编码，对吗？</p><p>   GB18030 covers quite a range of characters (including a large part of latin characters), but in the end is yet another specialized encoding format among many.</p><p>GB18030涵盖了相当多的字符（包括大部分拉丁字符），但最终是许多字符中的另一种特殊编码格式。</p><p>   Finally somebody had enough of the mess and set out to  forge a ring to bind them all create one encoding standard to unify all encoding standards. This standard is Unicode. It basically defines a ginormous table of 1,114,112 code points that can be used for all sorts of letters and symbols. That&#39;s plenty to encode all European, Middle-Eastern, Far-Eastern, Southern, Northern, Western, pre-historian and future characters mankind knows about.  2 Using Unicode, you can write a document containing virtually any language using any character you can type into a computer. This was either impossible or very very hard to get right before Unicode came along. There&#39;s even an  unofficial section for Klingon in Unicode. Indeed, Unicode is big enough to allow for  unofficial, private-use areas.</p><p>最后，有人受够了这种混乱，开始锻造一个戒指，把它们都绑起来，创建一个编码标准来统一所有的编码标准。这个标准是Unicode。它基本上定义了一个包含1114112个代码点的ginormous表，可以用于各种字母和符号。那&#39；这足以编码所有欧洲、中东、远东、南部、北部、西部、史前和人类所知的未来人物。2使用Unicode，你可以使用任何可以在计算机中键入的字符编写一个包含几乎任何语言的文档。在Unicode出现之前，这要么是不可能的，要么是非常困难的。那里&#39；这甚至是Unicode中克林贡语的非官方部分。事实上，Unicode足够大，允许非官方的私人使用区域。</p><p> So, how many bits does Unicode use to encode all these characters?  None. Because Unicode is not an encoding.</p><p>那么，Unicode使用多少位来编码所有这些字符呢？没有一个因为Unicode不是一种编码。</p><p> Confused? Many people seem to be.  Unicode first and foremost defines a table of  code points for characters. That&#39;s a fancy way of saying  &#34;65 stands for A, 66 stands for B and 9,731 stands for ☃&#34; (seriously, it does). How these code points are actually  encoded into bits is a different topic. To represent 1,114,112 different values, two bytes aren&#39;t enough. Three bytes are, but three bytes are often awkward to work with, so four bytes would be the comfortable minimum. But, unless you&#39;re actually using Chinese or some of the other characters with big numbers that take a lot of bits to encode, you&#39;re never going to use a huge chunk of those four bytes. If the letter &#34;A&#34; was always encoded to  00000000 00000000 00000000 01000001, &#34;B&#34; always to  00000000 00000000 00000000 01000010 and so on, any document would bloat to four times the necessary size.</p><p>困惑的许多人似乎是这样。Unicode首先定义了字符的代码点表。那&#39；这是一种奇特的说法&#34；65代表A，66代表B，9731代表☃&#34; （说真的，的确如此）。这些代码点实际上是如何被编码成比特的是另一个话题。为了表示1114112个不同的值，两个字节是&#39；这还不够。三个字节是，但三个字节通常很难使用，所以四个字节是最合适的最小值。但是，除非你&#39；如果你真的使用中文或其他一些大数字字符，需要很多位来编码，你&#39；我们永远不会使用这四个字节中的一大块。如果字母&#34；A&#34；始终被编码为00000000000000000001000001和#34；B&#34；始终为00000000000000000000000001000010等等，任何文档都会膨胀到所需大小的四倍。</p><p> To optimize this, there are several ways to encode Unicode code points into bits. UTF-32 is such an encoding that encodes all Unicode code points using 32 bits. That is, four bytes per character. It&#39;s very simple, but often wastes a lot of space. UTF-16 and UTF-8 are  variable-length encodings. If a character can be represented using a single byte (because its code point is a very small number), UTF-8 will encode it with a single byte. If it requires two bytes, it will use two bytes and so on. It has elaborate ways to use the highest bits in a byte to signal how many bytes a character consists of. This can save space, but may also waste space if these signal bits need to be used often. UTF-16 is in the middle, using at least two bytes, growing to up to four bytes as necessary.</p><p>为了优化这一点，有几种方法可以将Unicode代码点编码为位。UTF-32是一种使用32位编码所有Unicode码点的编码。也就是说，每个字符有四个字节。它&#39；这很简单，但通常会浪费很多空间。UTF-16和UTF-8是可变长度编码。如果一个字符可以用一个字节来表示（因为它的代码点是一个非常小的数字），UTF-8将用一个字节对其进行编码。如果需要两个字节，它将使用两个字节，以此类推。它有详细的方法来使用字节中的最高位来表示一个字符由多少字节组成。这可以节省空间，但如果需要经常使用这些信号位，也可能会浪费空间。UTF 16处于中间，使用至少两个字节，根据需要增长到四字节。</p><p>  And that&#39;s all there is to it. Unicode is a large table mapping characters to numbers and the different UTF encodings specify how these numbers are encoded as bits. Overall, Unicode is  yet another encoding scheme. There&#39;s nothing special about it, it&#39;s just trying to cover everything while still being efficient. And that&#39;s A Good Thing.™</p><p>那&#39；这就是全部。Unicode是一个将字符映射到数字的大表，不同的UTF编码指定这些数字如何编码为位。总的来说，Unicode是另一种编码方案。那里&#39；这没什么特别的，它&#39；It’他只是想在保持效率的同时覆盖一切。那&#39；这是件好事。™</p><p>   Characters are referred to by their &#34;Unicode code point&#34;. Unicode code points are written in hexadecimal (to keep the numbers shorter), preceded by a &#34;U+&#34; (that&#39;s just what they do, it has no other meaning than &#34;this is a Unicode code point&#34;). The character Ḁ has the Unicode code point U+1E00. In other (decimal) words, it is the 7680th character of the Unicode table. It is officially called &#34;LATIN CAPITAL LETTER A WITH RING BELOW&#34;.</p><p>字符由其&#34表示；Unicode代码点&#34；。Unicode代码点是用十六进制（以保持数字更短）编写的，前面是&#34；U+#34；（这正是他们所做的，除了&#34；这是一个Unicode码点&#34；）没有其他意义。角色Ḁ 具有Unicode代码点U+1E00。换句话说（十进制），它是Unicode表的第7680个字符。官方名称为&#34；拉丁文大写字母A，下面带圈&#34；。</p><p>  A summary of all the above: Any character can be encoded in many different bit sequences and any particular bit sequence can represent many different characters, depending on which encoding is used to read or write them. The reason is simply because different encodings use different numbers of bits per characters and different values to represent different characters.</p><p>以上所有内容的总结：任何字符都可以在许多不同的位序列中编码，任何特定的位序列都可以代表许多不同的字符，这取决于读取或写入字符所使用的编码。原因很简单，因为不同的编码每个字符使用不同的比特数和不同的值来表示不同的字符。</p><p>    Having said all that, we come to the actual problems experienced by many users and programmers every day, how those problems relate to all of the above and what their solution is. The biggest problem of all is:</p><p>说到这里，我们来谈谈许多用户和程序员每天遇到的实际问题，这些问题与上述所有问题的关系，以及他们的解决方案。最大的问题是：</p><p>   If you open a document and it looks like this, there&#39;s one and only one reason for it: Your text editor, browser, word processor or whatever else that&#39;s trying to read the document is assuming the wrong encoding. That&#39;s all. The document is not broken (well, unless it is, see below), there&#39;s no magic you need to perform, you simply need to select the right encoding to display the document.</p><p>如果你打开一个文档，它看起来像这样，那么&#39；这只有一个原因：你的文本编辑器、浏览器、文字处理器或其他任何东西&#39；s试图读取文档时假设编码错误。那&#39；就这些。文件没有破损（好吧，除非是破损的，见下文），有&#39；It’您不需要执行任何魔术，只需选择正确的编码即可显示文档。</p><p>  10000011 01000111 10000011 10010011 10000011 01010010 10000001 0101101110000011 01100110 10000011 01000010 10000011 10010011 10000011 0100111110000010 11001101 10010011 11101111 10000010 10110101 10000010 1010110110000010 11001000 10000010 10100010</p><p>10000011 01000111 10000011 10010011 10000011 01010010 10000001 0101101110000011 01100110 10000011 01000010 10000011 10010011 10000011 0100111110000010 11001101 10010011 11101111 10000010 10110101 10000010 1010110110000010 11001000 10000010 10100010</p><p> Now, quick, what encoding is that? If you just shrugged, you&#39;d be correct. Who knows, right‽</p><p>快，那是什么编码？如果你只是耸耸肩，你&#39；那是对的。谁知道，对吧</p><p> Well, let&#39;s try to interpret this as ASCII. Hmm, most of these bytes start  3 with a  1 bit. If you  remember correctly, ASCII doesn&#39;t use that bit. So it&#39;s not ASCII. What about UTF-8? Hmm, no, most of these sequences are not valid UTF-8.  4 So UTF-8 is out, too. Let&#39;s try &#34;Mac Roman&#34; (yet another encoding scheme for them Europeans). Hey, all those bytes are valid in Mac Roman.  10000011 maps to &#34;É&#34;,  01000111 to &#34;G&#34; and so on. If you read this bit sequence using the Mac Roman encoding, the result is &#34;ÉGÉìÉRÅ[ÉfÉBÉìÉOÇÕìÔÇµÇ≠Ç»Ç¢&#34;. That looks like a valid string, no? Yes? Maybe? Well, how&#39;s the computer to know? Maybe somebody meant to write &#34;ÉGÉìÉRÅ[ÉfÉBÉìÉOÇÕìÔÇµÇ≠Ç»Ç¢&#34;. For all I know that could be a DNA sequence.  5 Unless you have a better suggestion, let&#39;s declare this to be a DNA sequence, say this document was encoded in Mac Roman and call it a day.</p><p>好吧，让&#39；让我们试着将其解释为ASCII。嗯，大多数字节都是以1位开始的。如果你没记错的话，ASCII不会&#39；别用那个。所以它&#39；这不是ASCII码。UTF-8呢？不，大多数序列都不是有效的UTF-8。所以UTF-8也被淘汰了。让&#39；让我们试试&#34；麦克·罗曼&#34；（对他们来说，这是另一种编码方案）。嘿，所有这些字节在Mac Roman中都是有效的。1000011映射到&#34；É&#34;,  01000111至&#34；G&#34；等等如果使用Mac Roman编码读取该位序列，结果为&#34；ÉGìÉRÉ≠Ç»Ç¢&#34;. 看起来是个有效的字符串，不是吗？对大概那么，如何&#39；计算机知道什么？也许有人想写&#34；ÉGìÉRÉ≠Ç»Ç¢&#34;. 据我所知，这可能是一个DNA序列。5除非你有更好的建议，否则就让&#39；让我们宣布这是一个DNA序列，说这个文件是用Mac Roman编码的，到此为止。</p><p>  Of course, that unfortunately is complete nonsense. The correct answer is that this text is encoded in the Japanese Shift-JIS encoding and was supposed to read &#34;エンコーディングは難しくない&#34;. Well, who&#39;d&#39;ve thunk?</p><p>当然，不幸的是，这完全是胡说八道。正确的答案是，这篇文章是用日文Shift-JIS编码的，应该读&#34；エンコーディングは難しくない&#34;. 嗯，谁&#39；d&#39；维特·图恩？</p><p> The  primary cause of garbled text is: Somebody is trying to read a byte sequence using the wrong encoding. The computer always needs to be told what encoding some text is in. Otherwise it can&#39;t know. There are different ways how different kinds of documents can specify what encoding they&#39;re in and these ways should be used. A raw bit sequence is always a mystery box and could mean anything.</p><p>造成文本乱码的主要原因是：有人试图用错误的编码读取字节序列。计算机总是需要被告知某些文本的编码方式。否则它可以&#39；我不知道。不同类型的文档可以通过不同的方式指定它们的编码&#39；我们应该使用这些方法。原始位序列总是一个神秘的盒子，可能意味着任何东西。</p><p> Most browsers allow the selection of a different encoding in the View menu under the menu option &#34;Text Encoding&#34;, which causes the browser to reinterpret the current page using the selected encoding. Other programs may offer something like &#34;Reopen using encoding…&#34; in the File menu, or possibly an &#34;Import…&#34; option which allows the user to manually select an encoding.</p><p>大多数浏览器允许在菜单选项&#34；文本编码&#34；，这会导致浏览器使用选定的编码重新解释当前页面。其他项目可能会提供&#34；使用编码重新打开…&#34；在文件菜单中，或者可能是&#34；进口…#34；允许用户手动选择编码的选项。</p><p>  If a sequence of bits doesn&#39;t make sense (to a human) in any encoding, the document has mostly likely been converted incorrectly at some point. Say we took the above text &#34;ÉGÉìÉRÅ[ÉfÉBÉìÉOÇÕìÔÇµÇ≠Ç»Ç¢&#34; because we didn&#39;t know any better and saved it as UTF-8. The text editor assumed it correctly read a Mac Roman encoded text and you now want to save this text in a different encoding. All of these characters are valid Unicode characters after all. That is to say, there&#39;s a code point in Unicode that can represent &#34;É&#34;, one that can represent &#34;G&#34; and so on. So we can happily save this text as UTF-8:</p><p>如果一个位序列没有&#39；（对人类）来说，任何编码都没有意义，文档很可能在某个时候被错误地转换了。假设我们把上面的文字&#34；ÉGìÉRÉ≠Ç»Ç¢&#34; 因为我们没有&#39；I don’我不知道更多，并将其保存为UTF-8。文本编辑器假定它正确地读取了Mac Roman编码的文本，现在您希望以不同的编码保存该文本。毕竟，所有这些字符都是有效的Unicode字符。也就是说，有&#39；s Unicode中的一个代码点，可以表示&#34；É&#34;, 一个能代表&#34；G&#34；等等因此，我们可以很高兴地将此文本保存为UTF-8：</p><p> 11000011 10001001 01000111 11000011 10001001 11000011 10101100 1100001110001001 01010010 11000011 10000101 01011011 11000011 10001001 0110011011000011 10001001 01000010 11000011 10001001 11000011 10101100 1100001110001001 01001111 11000011 10000111 11000011 10010101 11000011 1010110011000011 10010100 11000011 10000111 11000010 10110101 11000011 1000011111100010 10001001 10100000 11000011 10000111 11000010 10111011 1100001110000111 11000010 10100010</p><p>11000011 10001001 01000111 11000011 10001001 11000011 10101100 1100001110001001 01010010 11000011 10000101 01011011 11000011 10001001 0110011011000011 10001001 01000010 11000011 10001001 11000011 10101100 1100001110001001 01001111 11000011 10000111 11000011 10010101 11000011 1010110011000011 10010100 11000011 10000111 11000010 10110101 11000011 1000011111100010 10001001 10100000 11000011 10000111 11000010 10111011 1100001110000111 11000010 10100010</p><p> This is now the UTF-8 bit sequence representing the text &#34;ÉGÉìÉRÅ[ÉfÉBÉìÉOÇÕìÔÇµÇ≠Ç»Ç¢&#34;. This bit sequence has absolutely nothing to do with our original document. Whatever encoding we try to open it in, we won&#39;t ever get the text &#34;エンコーディングは難しくない&#34; from it. It is completely lost. It would be possible to recover the original text from it if we knew that a Shift-JIS document was misinterpreted as Mac Roman and then accidentally saved as UTF-8 and reversed this chain of missteps. But that would be a lucky fluke.</p><p>这是表示文本的UTF-8位序列&#34；ÉGìÉRÉ≠Ç»Ç¢&#34;. 这个位序列与我们的原始文档完全无关。不管我们试图用什么编码来打开它，我们都赢了&#39；我从来没有读过这篇文章&#34；エンコーディングは難しくない&#34; 从中。它完全消失了。如果我们知道Shift JIS文档被错误地理解为Mac Roman，然后意外地保存为UTF-8，并扭转了这一错误链，那么就有可能从中恢复原始文本。但这将是一个幸运的运气。</p><p> Many times certain bit sequences are invalid in a particular encoding. If we tried to open the original document using ASCII, some bytes would be valid in ASCII and map to a real character and others wouldn&#39;t. The program you&#39;re opening it with may decide to silently discard any bytes that aren&#39;t valid in the chosen encoding, or possibly replace them with  ?. There&#39;s also the &#34;Unicode replacement character&#34; � (U+FFFD) which a program may decide to insert for any character it couldn&#39;t decode correctly when trying to handle Unicode. If a document is saved with some characters gone or replaced, then those characters are  really gone for good with no way to reverse-engineer them.</p><p>很多时候，某些位序列在特定编码中是无效的。如果我们尝试使用ASCII打开原始文档，一些字节在ASCII中是有效的，并映射到真实字符，而其他字节则不会&#39；t、 你&#39；使用重新打开时，可能会决定以静默方式丢弃任何不为&#39；t在所选的编码中无效，或者可能替换为？。那里&#39；这也是&#34；Unicode替换字符&#34；� （U+FFFD）程序可能决定为其无法插入的任何字符插入&#39；尝试处理Unicode时无法正确解码。如果文档保存时某些字符消失或被替换，那么这些字符实际上就永远消失了，无法对它们进行反向工程。</p><p> If a document has been misinterpreted and converted to a different encoding, it&#39;s broken. Trying to &#34;repair&#34; it may or may not be successful, usually it isn&#39;t. Any manual bit-shifting or other encoding voodoo is mostly that, voodoo. It&#39;s trying to fix the symptoms after the patient has already died.</p><p>如果文档被误解并转换为不同的编码，则它&#39；它坏了。试图&#34；修理和#34；它可能成功，也可能不成功，通常不是&#39；t、 任何手动位移动或其他编码巫毒都是巫毒。它&#39；It’在病人去世后，他正在努力纠正症状。</p><p>  It&#39;s really simple:  Know what encoding a certain piece of text, that is, a certain byte sequence, is in, then interpret it with that encoding. That&#39;s all you need to do. If you&#39;re writing an app that allows the user to input some text, specify what encoding you accept from the user. For any sort of text field, the programmer can usually decide its encoding. For any sort of file a user may upload or import into a program, there needs to be a specification what encoding that file should be in. Alternatively, the user needs some way to tell the program what encoding the file is in. This information may be part of the file format itself, or it may be a selection the user has make (not that most users would usually know, unless they have read this article).</p><p>它&#39；这真的很简单：知道某段文本的编码是什么，也就是某个字节序列，然后用这种编码来解释它。那&#39；这就是你需要做的。如果你&#39；重新编写一个允许用户输入一些文本的应用程序，指定您从用户那里接受的编码。对于任何类型的文本字段，程序员通常可以决定其编码。对于用户可能上传或导入到程序中的任何类型的文件，都需要有一个规范，说明该文件应该采用什么编码。或者，用户需要某种方法来告诉程序文件的编码是什么。这些信息可能是文件格式本身的一部分，也可能是用户做出的选择（大多数用户通常不会知道，除非他们读过本文）。</p><p> If you need to convert from one encoding to another, do so cleanly using tools that are specialized for that. Converting between encodings is the tedious task of comparing two code pages and deciding that character 152 in encoding A is the same as character 4122 in encoding B, then changing the bits accordingly. This particular wheel does not need reinventing and any mainstream programming language includes some way of converting text from one encoding to another without needing to think about code points, pages or bits at all.</p><p>如果您需要从一种编码转换为另一种编码，请使用专门用于转换的工具干净地进行转换。在编码之间转换是一项繁琐的任务，比较两个代码页，确定编码A中的字符152与编码B中的字符4122相同，然后相应地更改位。这个特殊的轮子不需要重新发明，任何主流编程语言都包括一些将文本从一种编码转换为另一种编码的方法，而不需要考虑代码点、页面或位。</p><p> Say, your app  must accept files uploaded in GB18030, but internally you are handling all data in UTF-32. A tool like  iconv can cleanly convert the uploaded file with a one-liner like  iconv(&#39;GB18030&#39;, &#39;UTF-32&#39;, $string). That is, it will preserve the characters while changing the underlying bits:</p><p>比如说，你的应用程序必须接受GB18030中上传的文件，但你在内部处理的是UTF-32中的所有数据。像iconv这样的工具可以使用像iconv这样的一行代码（GB18030&#39；，&#39；UTF-32&#39；，$string）干净地转换上传的文件。也就是说，它将在更改基础位的同时保留字符：</p><p>  That&#39;s all there is to it. The  content of the string, that is, the human readable characters, didn&#39;t change, but it&#39;s now a valid UTF-32 string. If you keep treating it as UTF-32, there&#39;s no problem with garbled characters. As discussed at the  very beginning though, not all encoding schemes can represent all characters. It&#39;s not possible to encode the character &#34;縧&#34; in any encoding scheme designed for European languages. Something Bad™ would happen if you tried to.</p><p>那&#39；这就是全部。字符串的内容，即人类可读的字符，没有&#39；不会改变，但它&#39；现在是一个有效的UTF-32字符串。如果你一直把它当作UTF-32，那么&#39；It’乱码没问题。不过，正如一开始所讨论的，并非所有的编码方案都能代表所有字符。它&#39；不可能对字符进行编码#34；縧&#34; 在任何为欧洲语言设计的编码方案中。糟糕的事™ 如果你尝试的话就会发生。</p><p>  Precisely because of that, there&#39;s virtually no excuse in this day and age not to be using Unicode all the way. Some specialized encodings may be more efficient than the Unicode encodings for certain languages. But unless you&#39;re storing terabytes and terabytes of very specialized text (and that&#39;s  a lot of text), there&#39;s usually no reason to worry about it. Problems stemming from incompatible encoding schemes are much worse than a wasted gigabyte or two these days. And this will become even truer as storage and bandwidth keeps growing larger and cheaper.</p><p>正因为如此，才有&#39；在这个时代，几乎没有理由不一直使用Unicode。对于某些语言，某些专用编码可能比Unicode编码更有效。但除非你&#39；重新存储太字节和太字节的非常专门的文本（这是很多文本），有&#39；it’通常没有理由担心。如今，由不兼容的编码方案引起的问题比浪费一两个千兆字节要严重得多。随着存储和带宽的不断增大和降低，这一点将变得更加真实。</p><p> If your system nee</p><p>如果你的系统</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/了解/">#了解</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编码/">#编码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>