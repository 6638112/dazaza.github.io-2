<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么朱莉娅工作得这么好？</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">为什么朱莉娅工作得这么好？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-21 19:09:57</div><div class="page_narrow text-break page_content"><p>it&#39;s faster than other scripting languages, allowing you to have the rapid development of Python/MATLAB/R while producing code that is as fast as C/Fortran</p><p>它比其他脚本语言更快，使您可以快速开发Python/MATLAB/R，同时生成与C/Fortran一样快的代码。</p><p>  Why not just make other scripting languages faster? If Julia can do it, why can&#39;t others?</p><p>为什么不干脆让其他脚本语言变得更快呢？如果朱莉娅能做到，为什么其他人做不到呢？</p><p> How do you interpert Julia benchmarks to confirm this? (This is surprisingly difficult for many!)</p><p>你如何干预朱莉娅基准来证实这一点？(这对许多人来说是出乎意料的困难！)。</p><p> Many people believe Julia is fast  because it is Just-In-Time (JIT) compiled (i.e. every statement is run using compiled functions which are either compiled right before they are used, or cached compilations from before). This leads to questions about what Julia gives over JIT&#39;d implementations of Python/R (and MATLAB by default uses a JIT). These JIT compilers have been optimized for far longer than Julia, so why should we be crazy and believe that somehow Julia quickly out-optimized all of them? However, that is a complete misunderstanding of Julia. What I want show, in a very visual way, is that Julia is fast because of its design decisions. The core design decision,  type-stability through specialization via multiple-dispatch is what allows Julia to be very easy for a compiler to make into efficient code, but also allow the code to be very concise and &#34;look like a scripting language&#34;. This will lead to some very clear performance gains.</p><p>许多人认为Julia速度很快，因为它是实时(JIT)编译的(即，每条语句都是使用编译函数运行的，这些函数要么在使用前编译，要么使用之前缓存的编译)。这就引出了一个问题，即Julia比Python/R的JIT实现提供了什么(而MATLAB默认使用JIT)。这些JIT编译器的优化时间比Julia长得多，所以我们为什么要疯狂地相信Julia很快就优化了所有这些编译器呢？然而，这完全是对朱莉娅的误解。我想以一种非常直观的方式展示朱莉娅的速度，因为她的设计决定。核心设计决策，即通过多分派实现专门化的类型稳定性，使得Julia能够非常容易地将编译器转换成高效的代码，同时也允许代码非常简洁，并且看起来像是一种脚本语言。这将带来一些非常明显的性能提升。</p><p> But what we will see in this example is that Julia does not always act like other scripting languages. There are some &#34;lunches lost&#34; that we will have to understand. Understanding how this design decision effects the way you must code is crucial to producing efficient Julia code.</p><p>但是我们将在本例中看到Julia并不总是像其他脚本语言那样工作。我们必须了解一些丢失的午餐。理解此设计决策如何影响您必须编码的方式，对于生成高效的Julia代码至关重要。</p><p> In general, math in Julia looks the same as in other scripting languages. One detail to note is that the numbers are &#34;true numbers&#34;, as in a  Float64 is truly the same thing as a 64-bit floating point number or a &#34;double&#34; in C. A  Vector{Float64} is the same memory layout as an array of doubles in C, both making interop with C easy (indeed, in some sense &#34;Julia is a layer on top of C&#34;) and it leads to high performance (the same is true for NumPy arrays).</p><p>一般来说，Julia中的数学与其他脚本语言中的数学看起来是一样的。需要注意的一个细节是，这些数字是实数，因为在Float64中，它确实与64位浮点数或C中的Double&34；相同。A Vector{Float64}与C中的Double数组是相同的内存布局，两者都使得与C的互操作变得容易(实际上，在某种意义上，Julia是C&34；之上的一层)，并且它可以带来高性能(NumPy数组也是如此)。</p><p> a  =  2 + 2 b  =  a / 3 c  =  a÷3  #\div tab completion, means integer division d  =  4 * 5 println ([ a ; b ; c ; d ])</p><p>A=2+2 b=a/3 c=a？3#\div制表符补全，表示整数除d=4*5 println([a；b；c；d])。</p><p> Note here that I showed off Julia&#39;s unicode tab completion. Julia allows for unicode characters, and these can be used by tab completing Latex-like statements. Also, multiplication by a number is allowed without the * if followed by a variable. For example, the following is allowed Julia code:</p><p>请注意，我在这里展示了Julia的Unicode制表符完成功能。Julia允许使用Unicode字符，这些字符可以通过制表符完成类Latex语句使用。此外，如果后跟变量，则允许不带*的数字乘法。例如，允许使用以下Julia代码：</p><p>  Type stability is the idea that there is only 1 possible type which can be outputtted from a method. For example, the reasonable type to output from  *(::Float64,::Float64) is a  Float64. No matter what you give it, it will spit out a  Float64. This right here is multiple-dispatch: the  * operator calls a different method depending on the types that it sees. When it sees floats, it will spit out floats. Julia provides code introspection macros so that way you can see what your code actually compiles to. Thus Julia is not just a scripting language, it&#39;s a scripting language which lets you deal with assembly! Julia, like many languages, compiles to LLVM (LLVM is a type of portable assembly language).</p><p>类型稳定性是指一个方法只能输出一个可能的类型。例如，从*(：：Float64，：：Float64)输出的合理类型是Float64。不管你给它什么，它都会吐出Float64。这里的情况是多重分派：*运算符会根据它看到的类型调用不同的方法。当它看到浮标时，它会吐出浮标。Julia提供了代码内省宏，这样您就可以看到您的代码实际编译成了什么。因此，Julia不仅仅是一种脚本语言，它还是一种可以让你处理汇编的脚本语言！像许多语言一样，Julia编译成LLVM(LLVM是一种可移植的汇编语言)。</p><p> ; Function *; Location: int.jl:54define i64 @&#34;julia_*_33751&#34;(i64, i64) {top: %2 = mul i64 %1, %0 ret i64 %2}</p><p>；函数*；位置：int.jl：54定义i64@&#34；julia_*_33751&#34；(i64，i64){顶部：%2=mul i64%1，%0 ret i64%2}。</p><p> This output is saying that a floating point multiplication operation is performed and the answer is returned. We can even look at the assembly</p><p>此输出表示执行了浮点乘法运算，并返回了答案。我们甚至可以看一看这个集合体。</p><p> .text; Function * {; Location: int.jl:54	imulq	%rsi, %rdi	movq	%rdi, %rax	retq	nopl	(%rax,%rax);}</p><p>.text；function*{；location：int.jl：54 imulq%rsi，%rdi movq%rdi，%rax retq nopl(%rax，%rax)；}。</p><p> This shows us that the  * function has compiled down to exactly the same operation as what happens in C/Fortran, meaning it achieves the same performance (even though it&#39;s defined in Julia). Thus it is possible to not just get &#34;close&#34; to C, but actually get the same C code out. In what cases does this happen?</p><p>这表明*函数已经编译成与C/Fortran中完全相同的操作，这意味着它实现了相同的性能(尽管它是在Julia中定义的)。因此，不仅可以将&#34；Close&#34；转换为C，而且可以实际得到相同的C代码。在什么情况下会发生这种情况？</p><p> The interesting thing about Julia is that, asking which cases this happens is not the right question. the right question is, in what cases does the code not compile to something as efficient as C/Fortran? The key here is type-stability. If a function is type-stable, then the compiler can know what the type will be at all points in the function and smartly optimize it to the same assembly as C/Fortran. If it is not type-stable, Julia has to add expensive &#34;boxing&#34; to ensure types are found/known before operations.</p><p>朱莉娅的有趣之处在于，询问发生这种情况的情况并不是正确的问题。正确的问题是，在什么情况下，代码不能编译成像C/Fortran那样高效的代码？这里的关键是类型稳定性。如果函数是类型稳定的，那么编译器可以知道函数中所有点的类型是什么，并智能地将其优化到与C/Fortran相同的程序集中。如果它不是类型稳定的，Julia必须添加昂贵的装箱，以确保在操作之前找到/知道类型。</p><p>  The upside is that Julia&#39;s functions, when type stable, are essentially C/Fortran functions. Thus  ^ (exponentiation) is fast. However,  ^(::Int64,::Int64) is type-stable, so what type should it output?</p><p>优点是，当类型稳定时，Julia的函数本质上是C/Fortran函数。因此^(取幂)速度很快。但是，^(：：Int64，：：Int64)是类型稳定的，那么它应该输出什么类型呢？</p><p>   Here we get an error. In order to guarantee to the compiler that  ^ will give an Int64 back, it has to throw an error. If you do this in MATLAB, Python, or R, it will not throw an error. That is because those languages do not have their entire language built around type stability.</p><p>这里我们得到一个错误。为了向编译器保证^将返回Int64，它必须抛出错误。如果在MATLAB、Python或R中执行此操作，则不会抛出错误。这是因为这些语言的整个语言并不是围绕类型稳定性构建的。</p><p>  .text; Function ^ {; Location: intfuncs.jl:220	pushq	%rax	movabsq	$power_by_squaring, %rax	callq	*%rax	popq	%rcx	retq	nop;}</p><p>.text；function^{；location：intfuncs.jl：220 Push q%rax movabq$power_by_ssquing，%rax callq*%rax popq%rcx retq NOP；}。</p><p> Now let&#39;s define our own exponentiation on integers. Let&#39;s make it &#34;safe&#34; like the form seen in other scripting languages:</p><p>现在，让我们定义我们自己对整数的求幂。让我们让它像在其他脚本语言中看到的形式一样安全：</p><p>     .text; Function expo {; Location: In[8]:2	pushq	%rbx	movq	%rdi, %rbx; Function &gt;; {; Location: operators.jl:286; Function &lt;; {; Location: int.jl:49	testq	%rdx, %rdx;}}	jle	L36; Location: In[8]:3; Function ^; {; Location: intfuncs.jl:220	movabsq	$power_by_squaring, %rax	movq	%rsi, %rdi	movq	%rdx, %rsi	callq	*%rax;}	movq	%rax, (%rbx)	movb	$2, %dl	xorl	%eax, %eax	popq	%rbx	retq; Location: In[8]:5; Function convert; {; Location: number.jl:7; Function Type; {; Location: float.jl:60L36:	vcvtsi2sdq	%rsi, %xmm0, %xmm0;}}; Location: In[8]:6; Function ^; {; Location: math.jl:780; Function Type; {; Location: float.jl:60	vcvtsi2sdq	%rdx, %xmm1, %xmm1	movabsq	$__pow, %rax;}	callq	*%rax;}	vmovsd	%xmm0, (%rbx)	movb	$1, %dl	xorl	%eax, %eax; Location: In[8]:3	popq	%rbx	retq	nopw	%cs:(%rax,%rax);}</p><p>.text；function expo{；location：in[8]：2presq%rbx movq%rdi，%rbx；function&gt；；{；location：operators.jl：286；function&lt；；{；location：int.jl：49testq%rdx；}}jle L36；location：in[8]：3；function^；{；location：intfuncs.jl：220 movabq$power_by_ssquing，%rax movq%rsi，%rdi movq%rdx；}movq%rax，(%rbx)movb$2，%dl xorl%eax，%eax popq%rbx retq；位置：in[8]：5；函数转换；{；location：num.jl：7；函数类型；{；location：float.jl：60L36：vcvtsi2sdq%rsi，%xmm0，%xmm0；}}；位置：in[8]：6；函数^；{；位置：math.jl：780；函数类型；{；位置：float.jl：60 vcvtsi2sdq%rdx，%xmm1，%xmm1 movabq$__power，%rax；}callq*%rax；}vmovsd%xmm0，(%rbx)movb$1，%dl xorl%eax，%eax；位置：in[8]：3 popq%rbx retq nopw%cs：(%rax，%rax)；}。</p><p> That&#39;s a very visual demonstration on why Julia achieves such higher performance than other scripting languages by how it uses type inference.</p><p>这是一个非常直观的演示，说明了为什么Julia在如何使用类型推理方面比其他脚本语言实现了如此高的性能。</p><p> Type stability is one crucial feature which separates Julia apart from other scripting languages. In fact, the core idea of Julia is the following statement:</p><p>类型稳定性是Julia区别于其他脚本语言的一个重要特性。事实上，朱莉娅的核心理念是这样表述的：</p><p>  This is what Julia is all about, so let&#39;s take some time to dig into it.If you have type stability inside of a function (meaning, any function call within the function is also type-stable), then the compiler can know the types of the variables at every step. Therefore it can compile the function with the full amount of optimizations since at this point the code is essentially the same as C/Fortran code. Multiple-dispatch works into this story because it means that  * can be a type-stable function: it just means different things for different inputs. But if the compiler can know the types of  a and  b before calling  *, then it knows which  * method to use, and therefore it knows the output type of  c=a*b. Thus it can propogate the type information all the way down, knowing all of the types along the way, allowing for full optimiziations. Multiple dispatch allows  * to mean the &#34;right thing&#34; every time you use it, almost magically allowing this optimization.</p><p>这就是Julia所要做的，所以让我们花一些时间来深入研究它。如果你在函数内部有类型稳定性(也就是说，函数中的任何函数调用也是类型稳定的)，那么编译器在每一步都可以知道变量的类型。因此，它可以编译经过充分优化的函数，因为此时的代码与C/Fortran代码本质上是相同的。多分派之所以适用于这个故事，是因为它意味着*可以是类型稳定的函数：它只是对不同的输入有不同的含义。但是，如果编译器可以在调用*之前知道a和b的类型，那么它就知道要使用哪个*方法，因此它知道c=a*b的输出类型。因此，它可以一路向下传播类型信息，知道整个过程中的所有类型，从而实现完全优化。多重分派允许*在您每次使用它时都意味着正确的事情，几乎神奇地实现了这种优化。</p><p> There are a few things we learn from this. For one, in order to achieve this level of optimization, you must have type-stability. This is not featured in the standard libraries of most languages, and was choice that was made to make the experience a little easier for users. Secondly, multiple dispatch was required to be able to specialize the functions for types which allows for the scripting language syntax to be &#34;more explicit than meets the eye&#34;. Lastly, a robust type system is required. In order to build the type-unstable exponentiation (which may be needed) we needed functionalities like convert. Thus the language must be designed to be type-stable with multiple dispatch and centered around a robust type system in order to achieve this raw performance while maintaining the syntax/ease-of-use of a scripting language. You can put a JIT on Python, but to really make it Julia, you would have to design it to be Julia.</p><p>我们从中学到了一些东西。首先，为了实现这种级别的优化，您必须具有类型稳定性。这不是大多数语言的标准库中的特色，选择它是为了让用户的体验更容易一些。其次，需要多个分派能够专门化类型的函数，这使得脚本语言语法比看上去更明确。最后，需要一个健壮的类型系统。为了构建类型不稳定的求幂(可能需要)，我们需要像转换这样的功能。因此，语言必须设计为具有多个分派的类型稳定，并且以健壮的类型系统为中心，以便在保持脚本语言的语法/易用性的同时实现这种原始性能。您可以将JIT放在Python上，但要真正使其成为Julia，您必须将其设计为Julia。</p><p> The Julia benchmarks, featured on  the Julia website, test components of the programming language for speed.  This doesn&#39;t mean it&#39;s testing the fastest implemention. That is where a major misconception occurs. You&#39;ll have an R programmer look at the R code for the Fibonacci calculator and say &#34;wow, that&#39;s terrible R code. You&#39;re not supposed to use recursion in R. Of course it&#39;s slow&#34;. However, the Fibonacci problem is designed to test recursion, not the fastest implementation to the the ith Fibonacci number. The other problems are the same way: testing basic components of the langauge to see how fast they are.</p><p>Julia网站上的Julia基准测试对编程语言的组件进行了速度测试。这并不意味着它正在测试最快的实现。这就是一个重大误解发生的地方。你会让一个R程序员看着斐波纳契计算器的R代码，然后说，哇，那是个可怕的R代码。你不应该在R中使用递归，当然它很慢。然而，斐波那契问题是用来测试递归的，并不是第i个斐波纳契数的最快实现。其他问题也是一样的：测试语言的基本组件，看看它们有多快。</p><p> Julia is built up using multiple-dispatch on type-stable functions. As a result, even the earliest versions of Julia were easy for compilers to optimize to C/Fortran efficiency. It&#39;s clear that in almost every case Julia is close to C. Where it is not close to C actually has a few details. The first is the Fibonacci problem where Julia is 2.11x from C. This is because it is a test of recursion, and Julia does not fully optimize recursion (but still does very well on this problem!). The optimization which is used to receive the fastest times for this type of problem is known as Tail-Call Optimization. Julia can at any time add this optimization, though  there are reasons why  they choose not to. The main reason is: any case where tail-call optimization is possible, a loop can also be used. But a loop is also more robust for optimizations (there are many recursive calls which will fail to tail-call optimize) and thus they want to just recommend using loops instead of using fragile TCO.</p><p>Julia是使用类型稳定函数的多重调度建立的。因此，即使是最早的Julia版本，编译器也很容易将其优化为C/Fortran效率。很明显，几乎在每一种情况下，朱莉娅都很接近C，而不是接近C的地方，实际上有一些细节。第一个是Fibonacci问题，其中Julia是C语言的2.11x，这是因为它是对递归的测试，而Julia没有完全优化递归(但在这个问题上仍然做得非常好！)。用于接收此类问题的最快时间的优化称为尾部调用优化。Julia可以随时添加此优化，尽管他们选择不添加是有原因的。主要原因是：在任何可能进行尾部调用优化的情况下，也可以使用循环。但是循环对于优化也更健壮(有许多递归调用将无法进行尾部调用优化)，因此他们希望只推荐使用循环，而不是使用脆弱的TCO。</p><p> The other cases where Julia doesn&#39;t do as well are the  rand_mat_stat and the  parse_int tests. However, this is largely due to a feature known as bounds checking. In most scripting languages, you will receive an error if you try to index an array outside of its bounds. Julia will do this by default:</p><p>Julia做不到的其他情况是rand_mat_stat和parse_int测试。然而，这在很大程度上要归功于一种称为边界检查的功能。在大多数脚本语言中，如果试图在数组边界之外编制索引，则会收到错误。默认情况下，Julia将执行此操作：</p><p> BoundsError: attempt to access 3-element Array{Float64,1} at index [4]Stacktrace: [1] setindex! at ./array.jl:769 [inlined] [2] test1() at ./In[11]:4 [3] top-level scope at In[11]:7</p><p>边界错误：尝试访问索引[4]处的3元数组{Float64，1}，堆栈跟踪：[1]setindex！At./array.jl：769[inline][2]test1()at./in[11]：4[3]顶级作用域at in[11]：7。</p><p>   This gives you the same unsafe behavior as C/Fortran, but also the same speed (indeed, if you add these to the benchmarks they will speed up close to C). This is another interesting feature of Julia: it lets you  by default have the safety of a scripting language, but turn off these features when necessary (/after testing and debugging) to get full performance.</p><p>这为您提供了与C/Fortran相同的不安全行为，但也提供了相同的速度(实际上，如果您将这些添加到基准测试中，它们的速度将接近C)。这是Julia的另一个有趣的特性：默认情况下，它让您拥有脚本语言的安全性，但是在必要时(/在测试和调试之后)关闭这些特性以获得完整的性能。</p><p>  Type-stability is not the only necessity. You also need strict typing. In Python you can put anything into an array. In Julia, you can only put types of  T into a  Vector{T}. To give generality, Julia offers various non-strict forms of types. The biggest example is  Any. Anything satisfies  T:&lt;Any (hence the name). Therefore, if you need it, you can create a  Vector{Any}. For example:</p><p>类型稳定性并不是唯一的必需品。您还需要严格键入。在Python中，您可以将任何内容放入数组。在Julia中，您只能将T类型放入Vector{T}。为了提供一般性，Julia提供了各种非严格形式的类型。最大的例子是任何。任何满足T：&lt；any的东西(因此而得名)。因此，如果需要，可以创建Vector{any}。例如：</p><p>  A less extreme form of an abstract type is a Union type, which is just what it sounds like. For example:</p><p>抽象类型的另一种不太极端的形式是UNION类型，它听起来就像这样。例如：</p><p>  This will only accept floating point numbers and integers. However, it is still an abstract type. A function which is called on an abstract type cannot know the type of any element (since, in this example, any element can be either a float or an integer). Thus the optimization that was achieved by multiple-dispatch, knowing the type each step of the way, is no longer present. Therefore the optimizations are gone and Julia will slow down to the speed of other scripting languages.</p><p>这将只接受浮点数和整数。但是，它仍然是一个抽象类型。在抽象类型上调用的函数不能知道任何元素的类型(因为在本例中，任何元素都可以是浮点型或整型)。因此，通过多分派(知道每一步的类型)实现的优化不再存在。因此，优化没有了，Julia将减慢到其他脚本语言的速度。</p><p> This leads to the performance principle: use strict typing whenever possible. There are other advantages: a strictly typed  Vector{Float64} is actually byte-compatible with C/Fortran, and so it can be used directly by C/Fortran programs without conversion.</p><p>这就引出了性能原则：尽可能使用严格的类型化。还有其他优点：严格类型的Vector{Float64}实际上与C/Fortran是字节兼容的，因此C/Fortran程序无需转换就可以直接使用它。</p><p> It&#39;s clear that Julia made clever design decisions in order to achieve its performance goals while still being a scripting language. However, what exactly is lost? Next I will show you a few pecularities of Julia that come from this design decision, and the tools Julia gives you to handle them.</p><p>很明显，Julia做出了聪明的设计决定，以实现其性能目标，同时仍然是一种脚本语言。然而，到底失去了什么呢？接下来，我将向您展示来自此设计决策的几个Julia特点，以及Julia提供给您处理这些问题的工具。</p><p> One thing I already showed is that Julia gives many ways to achieve high performance (like  @inbounds), but they don&#39;t have to be used. You can write type-unstable functions. It will be as slow as MATLAB/R/Python, but you can do it. In places where you don&#39;t need the best performance, it&#39;s nice to have this as an option.</p><p>我已经展示过的一件事是，Julia给出了很多实现高性能的方法(比如@inbound)，但是它们并不是必须要使用的。您可以编写类型不稳定的函数。它将和MATLAB/R/Python一样慢，但您可以做到。在你不需要最佳性能的地方，这是很好的选择。</p><p> Since type-stability is so essential, Julia gives you tools to check that your functions are type stable. The most important is the  @code_warntype macro. Let&#39;s use it to check a type-stable function:</p><p>由于类型稳定性是如此重要，Julia提供了一些工具来检查您的函数是否类型稳定。最重要的是@code_warntype宏。让我们用它来检查类型稳定函数：</p><p> Body ::Int64 │ 220 1 ─ %1 = invoke Base.power_by_squaring(_2::Int64, _3::Int64) ::Int64 │  └── return %1</p><p>Body：：Int64│220 1─%1=调用Base.Power_by_Ssquing(_2：：Int64，_3：：Int64)：：Int64│└──返回%1。</p><p> Notice that it shows all of the variables in the function as strictly typed. What about in our  expo?</p><p>请注意，它将函数中的所有变量显示为严格类型。我们的世博会怎么样？</p><p> Body ::Union{Float64, Int64} │╻╷ &gt; 2 1 ─ %1 = (Base.slt_int)(0, y) ::Bool │   └── goto #3 if not %1 │  3 2 ─ %3 = π (x,  Int64) │╻ ^  │ %4 = invoke Base.power_by_squaring(%3::Int64, _3::Int64) ::Int64 │   └── return %4 │  5 3 ─ %6 = π (x,  Int64) ││╻ Type  │ %7 = (Base.sitofp)(Float64, %6) ::Float64 │  6 │ %8 = π (%7,  Float64) │╻ ^  │ %9 = (Base.sitofp)(Float64, y) ::Float64 ││   │ %10 = $(Expr(:foreigncall, &#34;llvm.pow.f64&#34;, Float64, svec(Float64, Float64), :(:llvmcall), 2, :(%8), :(%9), :(%9), :(%8))) ::Float64 │   └── return %10</p><p>正文：：联合{flat64，int64}│╻╷&gt；2 1─%1=(Base.slt_int)(0，y)：：bool│└──转到#3如果不是%1│3 2─%3=π(x，int64)│╻^│%4=Invoke Base.Power_by_Sequing(%3：：int64，_3：：int64)：：int64│└──Return%4│5 3─%6=π(x，int64)││╻类型│%7=(Base.sitofp)(浮动64，%6)：：Float64│6│%8=π(%7，Float64)│╻^│%9=(Base.sitofp)(Float64，y)：：Float64│││%10=$(EXPR(：FOREIGNCALL，&#34；Llvm.power.f64&#34；，flat64，svec(flat64，flat64)，：(：llvmcall)，2，：(%8)，：(%9)，：(%9)，：：(%8))：：flat64│└──返回%10。</p><p> Notice that possible returns are the temporary  %4 and  %10 which are different types, and so the return type is inferred as  Union{Float64,Int64}. To trace exactly to where this instability occurs, we can use Traceur.jl:</p><p>请注意，可能的返回是临时的%4和%10，它们是不同的类型，因此返回类型被推断为UNION{Float64，Int64}。要准确跟踪这种不稳定发生的位置，我们可以使用Traceur.jl：</p><p> ┌ Warning: x is assigned as Int64└ @ In[8]:2┌ Warning: x is assigned as Float64└ @ In[8]:5┌ Warning: expo returns Union{Float64, Int64}└ @ In[8]:2</p><p>┌警告：X被指定为└@in[8]：2┌警告：X被指定为Float64└@in[8]：5┌警告：博览会返回联盟{flat64，int64}└@in[8]：2</p><p> This tells us that on line 2  x is assigned to an  Int while on line 5 it&#39;s assigned to a  Float64, and so it&#39;s inferred as  Union{Float64, Int64}. Line 5 is where we put the explicit  convert call, so this identified exactly the issue for us.</p><p>这告诉我们，在第2行x被分配给Int，而在第5行x被分配给Float64，因此它被推断为Union{Float64，Int64}。第5行是我们放置显式转换调用的位置，因此这正好为我们确定了问题所在。</p><p> For one, I already showed that some functions will error while in other scripting languages they will &#34;read your mind&#34;. In many cases you will realize that you could&#39;ve just used a different type from the start and achieved type-stability (why not just do  2.0^-5?). However, there are some cases where you won&#39;t find an appropriate type. This can be easily fixed by conversions, though you then lose type stability. Instead you have to think about your design and cleverly use multiple dispatch.</p><p>首先，我已经展示了一些函数会出错，而在其他脚本语言中，它们会读懂您的心思。在许多情况下，您会意识到您可以从一开始就使用不同的类型并实现类型稳定性(为什么不直接使用2.0^-5呢？)。但是，在某些情况下，您找不到合适的类型。这可以很容易地通过转换来修复，尽管这样会失去类型稳定性。相反，您必须考虑您的设计，并巧妙地使用多个分派。</p><p> So let&#39;s say that we have  a as a  Vector{Union{Float64,Int}}. We may run into a case where we have to use  a. Assume that on each element of  a we have to perform a lot of operations. In this case, knowing the type of a given element will lead to massive performance gains, but since it&#39;s in a  Vector{Union{Float64,Int}}, they will not be known in a function like:</p><p>因此，假设我们有一个作为向量的{Union{Float64，Int}}。我们可能会遇到这样的情况，我们必须使用a，假设在a的每个元素上，我们必须执行大量的操作。在这种情况下，知道给定元素的类型将带来巨大的性能提升，但由于它位于向量{Union{Float64，Int}}中，因此它们在如下函数中是未知的：</p><p> function  foo ( array )  for  i  in  eachindex ( array )  val  =  array [ i ]  # do algorithm X on val  end end</p><p>函数foo(Array)for i in Eachindex(Array)val=array[i]#在val结束时执行算法X。</p><p> However, we can fix this with multiple dispatch. We can write a dispatch on elements:</p><p>但是，我们可以使用多个派单来解决此问题。我们可以写一份关于元素的派单：</p><p>    Since types are checked for dispatch, the function  inner_foo is strictly typed. Thus if  inner_foo is type-stable, then we can achieve high performance by allowing it to specialize within  inner_foo. This leads to a general design principle that, if you&#39;re dealing with odd/non-strict types, you can use an outer function to handle the type logic while using an inner function for all of the hard calculations and achieve close to optimal performance while still having the generic abilities of a scripting language.</p><p>因为要检查类型以进行分派，所以函数INTERN_FOO是严格类型化的。因此，如果INTERN_FOO是类型稳定的，那么我们可以通过允许它在INTERN_FOO中专门化来实现高性能。这就产生了一个一般的设计原则，即如果您正在处理奇数/非严格类型，您可以使用外部函数来处理类型逻辑，同时使用内部函数来处理所有的硬计算，并在仍具有脚本语言的通用功能的情况下实现接近最佳的性能。</p><p>  Globals in Julia have awful performance. Not using globals is  the first fact in the Performance Tips. However, what newcommers don&#39;t realize is that the REPL is the global scope. To see why, recall that Julia has nested scopes. For example, if you have a function inside of a function, then the inner function has all of the variables of the outer function.</p><p>朱莉娅的全球赛表现糟糕透顶。不使用全局变量是性能提示中的第一个事实。然而，新上班族没有意识到的是，REPL是全球范围的。要了解原因，请回想一下Julia有嵌套的作用域。例如，如果函数内部有一个函数，则内部函数具有外部函数的所有变量。</p><p>  In  test2,  y is known because it is defined in  test. This will all work to give something performant if  y is type-stable since  test2 could then assume that  y is always an integer. But now look at what happens at the highest scope (and thus effectively the global scope):</p><p>在test2中，y是已知的，因为它是在test中定义的。如果y是类型稳定的，那么这一切都可以提供一些高性能的东西，因为test2可以假设y始终是一个整数。但现在看看在最高范围(从而有效地在全局范围内)发生了什么：</p><p>  Because no dispatch is used to specialize  badidea, and we can change the type of  a at any time, and therefore  badidea cannot add optimizations when compiling since the type of  a is unknown during compile time. However, Julia allows us to specify variables as constant:</p><p>因为没有使用分派来专门化badidea，并且我们可以随时更改a的类型，因此badidea不能在编译时添加优化，因为a的类型在编译时是未知的。但是，Julia允许我们将变量指定为常量：</p><p>  Beware that functions will specialize using the value of the constants, so they should go unchanged after being set.</p><p>请注意，函数将使用常量的值进行专门化，因此它们在设置后应该保持不变。</p><p> This will show up when trying to do benchmarks. The most common human error to see is for newcomers to benchmark Julia like:</p><p>这将在尝试进行基准测试时显示出来。最常见的人为错误是新来者以朱莉娅为基准，如下所示：</p><p>  However, if we put this in a function, it will optimize (in fact, it will optimize away the loop and stick in the answer)</p><p>但是，如果我们将其放入一个函数中，它将会优化(实际上，它会优化掉循环并停留在答案中)。</p><p> function  timetest ()  a  =  3.0  @time  for  i  =  1 : 4  a  +=  i  end end timetest ()  # First time compiles timetest ()</p><p>函数时刻表()a=3.0@time for i=1：4a+=i结束时刻表()#首次编译时刻表()。</p><p> This is a very easy problem to fall for: don&#39;t benchmark or time things in the REPL&#39;s global scope. Always wrap things in a function or declare them as const. There is a developer thread  to make the global performance less awful but, given the information from this notebook, you can already see that it will never be &#34;not awful&#34;, it will just be &#34;less awful&#34;.</p><p>这是一个很容易陷入的问题：不要在REPL的全球范围内进行基准测试或计时。始终将对象包装在函数中或将其声明为常量。有一个开发人员线程可以使全局性能不那么糟糕，但是，根据这本笔记本中的信息，您已经可以看到，它永远不会不糟糕，它只会不那么糟糕。</p><p> Julia is fast by design. Type stability and multiple dispatch is necessary to do the specialization that is involved in Julia&#39;s compilation to make it work so well. The robust type system is required to make working with types at such a fine level in order to effectively achieve type-stability whenever possible, and manage optimizations when it&#39;s not totally possible.</p><p>朱莉娅是故意跑得快的。类型稳定性和多重分派是进行Julia编译中所涉及的专门化以使其工作得如此好所必需的。健壮的类型系统需要在如此精细的级别上处理类型，以便在任何可能的情况下都能有效地实现类型稳定，并在不完全可能的情况下管理优化。</p><p>  Here&#39;s a good learning project: how would you design a new type  EasyFloats to build MATLAB/Python/R arithmetic into Julia? How would you designed &#34;arrays with NAs&#34; to mimic R? Time the results and see what the difference from optimal is.</p><p>这里有一个很好的学习项目：您将如何设计一个新类型的EasyFloats来将MATLAB/Python/R算法构建到Julia中？您将如何设计带有Nas的阵列来模拟R？计算结果的时间，看看与最优的区别是什么。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ucidatascienceinitiative.github.io/IntroToJulia/Html/WhyJulia">https://ucidatascienceinitiative.github.io/IntroToJulia/Html/WhyJulia</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/julia/">#julia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1030150.html"><img src="http://img2.diglog.com/img/2020/10/thumb_26810144d219c4006831567257391f46.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030150.html">Julia GPU：Julia语言如何让程序员轻松使用GPU</a></div><span class="my_story_list_date">2020-10-21 3:23</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029253.html"><img src="http://img2.diglog.com/img/2020/10/thumb_070a521b98a9fc0be3f7a1195e666f28.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029253.html">媒体对朱利安·阿桑奇听证会保持沉默是一种耻辱</a></div><span class="my_story_list_date">2020-10-16 23:5</span></div><div class="col-sm"><div><a target="_blank" href="/story/1028210.html"><img src="http://img2.diglog.com/img/2020/10/thumb_9f6f6fa763b64246c0bbfc3bb35b29cc.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1028210.html">CSV阅读器基准：Julia阅读CSV的速度比Python和R快10-20倍</a></div><span class="my_story_list_date">2020-10-12 7:11</span></div><div class="col-sm"><div><a target="_blank" href="/story/1028150.html"><img src="http://img2.diglog.com/img/2020/10/thumb_97602150f979aada960272c7e87d54ab.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1028150.html">Nilang.jl，一个可逆的Julia DSL</a></div><span class="my_story_list_date">2020-10-11 18:10</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>