<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>锈病是专业人士 Rust is for Professionals</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rust is for Professionals<br/>锈病是专业人士 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-14 01:24:28</div><div class="page_narrow text-break page_content"><p>A professional programmer delivers value through the authoring and maintainingof software that solves problems. (There are other important ways forprofessional programmers to deliver value but this post is aboutprogramming.)</p><p>专业程序员通过创作和维护解决问题的软件提供价值。 （还有其他重要的方法可以提供价值的专业程序员，但这篇文章是aboutprogramming。）</p><p> Programmers rely on various tools to author software. Arguably the mostimportant and consequential choice of tool is the programming language.</p><p> 程序员依靠各种工具来作者软件。可以说是最重要的和后续选择的工具是编程语言。</p><p> In this post, I will articulate why I believe Rust is a highly compellingchoice of a programming language for software professionals. I will statemy case that Rust disposes software to a lower defect rate, reduces totaldevelopment and deployment costs, and is exceptionally satisfying to use.In short, I hope to convince you to learn and deploy Rust.</p><p> 在这篇文章中，我将阐明为什么我相信Rust是一种高度批评的软件专业人士的编程语言。我将确定硬化软件将软件分类到较低的缺陷率，降低总行失和部署成本，并且非常满意。在短时间内，我希望说服您学习和部署生锈。</p><p>  Before I go too far, I&#39;m targeting this post towards  professional programmers -people who program (or support programming through roles like management) astheir primary line of work or who spend sufficient time programming outside ofwork. I consider myself a  professional programmer both because I am a full-timeengineer in the software industry and because I contribute to some significantopen source projects outside of my day job.</p><p>  在我走得太远之前，I＆＃39; m针对这篇文章，针对专业程序员 - 在人们（或通过管理等角色支持编程）asheir初级工作或在工作之外花费足够的时间编程的人的人员（或支持编程）。我认为自己是一个专业的程序员，因为我是软件行业的一个全时工程，因为我为我的日常工作之外的一些重要的商业项目做出了贡献。</p><p> The statement  Rust is for Professionals does not imply any logical variantthereof. e.g. I am not implying  Rust is not for non-professionals. Rather,the subject/thesis merely defines the audience I want to speak to: people whospend a lot of time authoring, maintaining, and supporting software and areinvested in its longer-term outcomes.</p><p> 声明锈病是专业人士并不意味着任何逻辑变种。例如我并不暗示Rust不是非专业人士。相反，主题/论文只是定义了我想说的观众：人们在长期的成果中获得了大量的时间创作，维护和支持软件，并在其长期结果中被投资。</p><p> I think opinion pieces about programming languages benefit from knowingthe author&#39;s experience with programming. I first started hacking on code inthe late 1990&#39;s. I&#39;ve been a full-time software developer since 2007 aftergraduating with a degree in Computer Engineering (after an aborted attemptat Biomedical Engineering - hence my affinities for hardware and biologicalsciences). I&#39;ve programmed in the following languages: C, C++ (only untilC++11), C#, Erlang, Go, JavaScript, Java, Lua, Perl, PHP, Python, Ruby,Rust, shell, SQL, and Verilog. Notably missing from this list is a Lisp anda Haskell/Scala type language. Of these languages, I&#39;ve spent the most timewith C, C#, JavaScript, Perl, PHP, Python, and Rust.</p><p> 我认为关于编程语言的意见作品受益于创新作者＆＃39;在编程的体验中受益。我第一次开始在1990年底＆＃39;秒开始黑客攻击。自2007年以来，我是一家全日制软件开发商，在计算机工程学位（中止的生物医学工程后，您是硬件和生物学的亲和力。在以下语言中编程：C，C ++（仅限++ 11），C＃，Erlang，Go，JavaScript，Java，Lua，Perl，PHP，Python，Ruby，Rust，Shell，SQL和Verilog 。显着从此列表中缺少是一个LISP和SACKELL / SCALA类型语言。这些语言，I＆＃39;在C，C＃，JavaScript，Perl，PHP，Python和Rust中度过了最多的时间。</p><p> I&#39;m not that strong in computer science or language theory: many colleaguescan talk circles around me when it comes to describing computer scienceand programming language concepts like algorithms, type theory, and common termsused to describe languages. (I have failed many technical interviews because ofmy limitations here.) In contrast, I perceive my technical strengths as applyingan engineering rigor and practicality to problem solving. I care vastly moreabout how/why things work the way they do and the practical consequences ofdecisions/choices we make when it comes to software. I find that I tend tothink about 2nd and 3rd order effects and broader or longer-term consequencesmore often than others. Some would call this  systems engineering.</p><p> 我不是那么强大的计算机科学或语言理论：在描述计算机SCIECEAND编程语言概念等算法，键入理论和常用术语时，许多同事针织圈在我周围谈话。 （因为这里有局限性，我失败了很多技术面试。）相比之下，我认为我的技术优势是应用程序工程严谨和实用性解决问题。我在乎很大地监督如何/为什么事情就像他们所做的方式以及我们在软件方面做出的实际后果/选择。我发现，我倾向于往往比其他人更广泛的2次和第3次订单效应和更广泛或长期后果。有些人会称这个系统工程。 </p><p> I&#39;ve programmed all kinds of different software. Backend web services,desktop applications, web sites, Firefox browser internals, the Mercurialversion control tool, build systems, system/machine management. Notably missingare mobile programming (e.g. iOS/Android) and serious embedded systems (I&#39;vehacked around with Raspberry Pis and Arduinos, but those seem very friendlycompared to other embedded devices). My strongest affinity is probably towards systems software and general purpose tools: I enjoy building software thatother people use to build things.  Infrastructure if you will.</p><p>我编程了各种不同的软件。后端Web服务，桌面应用程序，网站，Firefox浏览器内部，MercurialVersion控制工具，构建系统，系统/机器管理。值得注意的是迷失移动编程（例如iOS / Android）和严重的嵌入式系统（I＆＃39;带覆盆子PIS和Arduinos的车辆，但那些似乎非常友好地对其他嵌入式设备）。我最强大的亲和力可能朝着系统软件和通用工具：我喜欢在其他人用来建造东西的软件。如果您愿意，基础设施。</p><p> Finally, I am expressing my personal opinion in this post. I do not speak forany employer, present or former. While I would love to see more Rust at mycurrent employer, this post is not an attempt to influence what happens behindmy employer&#39;s walls: there a better ways to conduct successful nemawashi / 根回し than a publicblog post. I am not affiliated with the Rust Project in any capacitybeyond a very infrequent code contributor and issue filer: I view myself as anormal Rust user. I did work at Mozilla - the company who bankrolled most ofRust&#39;s initial development. I even briefly worked in the same small Vancouveroffice as Graydon Hoare, Rust&#39;s primary credited inventor! While I was keen forRust to succeed because it was affiliated with my then employer, I was mostdefinitely not a Rust evangelist or fan boy while at Mozilla. I have littleto personally benefit from this post: I&#39;m writing it because I enjoy writingand I believe the message is important.</p><p> 最后，我在这篇文章中表达了我的个人意见。我不会在雇主，礼物或前者讲。虽然我很乐意在MyCurrent雇主看到更多Rust，但这篇文章并不试图影响Laughmy雇主＆＃39; S墙上的发生影响：有更好的方法可以成功地进行Nemawashi /根回し而不是Pulidblog帖子。我在任何CompanationBeond中都没有与Rust项目隶属于一个非常不频繁的代码贡献者和发布文件：我将自己视为Anormal Rust用户。我在Mozilla工作了 - 该公司在最常见的初始开发中加入了最常见的。我甚至在与Graydon Hoare的同一个小的温哥华办公室，生锈＆＃39;初级记入发明者！虽然我热衷于成功，因为它是与我的雇主隶属于，但我在Mozilla的时候最重要的是一个生锈福音师或粉丝男孩。我有利于这篇文章的个人受益：我写它，因为我喜欢写作，我相信这封信很重要。</p><p>   When I look back at my professional self when I was in my 20s, I feel like I wasyoung and dumb and overly exuberant about computers, technology, new software, andthe like. An older, more grizzled professional, I now accept the reality that it isa miracle computers and software work as well as they do as often as they do. Pointat any common task on a computer and an iceberg of complexity and nuance lingersunder the surface. Our industry is abound in the repetition of proven sub-optimalideas. You see practices cargo culted across the decades (like the 80 character terminal/line width and null-terminated strings,which can both be traced back to Hollerith punchcards from the late 19th century).You witness cycles of pendulum swings, the same fads and trends, just with differentlabels (microservices are the new SOA, YAML is the new XML, etc). I can definitelyrelate to people in this industry who want to drop everything and move to a farm orsomething (but I grew up in Indiana and had cows living down the street, so Iknow this lifestyle isn&#39;t for me).</p><p>   当我回顾我的专业自我时，当我在20多岁时，我觉得我曾经是计算机，技术，新软件和那样的愚蠢和愚蠢而且过于旺盛。一个较旧的，更富有的专业人士，我现在接受它是ISA奇迹计算机和软件工作的现实，以及他们经常这样做。 Point在计算机上的任何共同任务和冰山的复杂性和细微偏执下的冰山。我们的行业在重复经过验证的次疗优惠中取比。你看到几十年中追查的实践货物（如80个字符终端/线宽和零终止的字符串，它可以追溯到19世纪后期的Hollerith Pundards）。你的位置摆动的循环，同样的曲线和趋势，只是用不同的标签（微野跑是新的SOA，Yaml是新的XML等）。我可以肯定地对这个行业的人们想要放弃一切并搬到一个农场orsomething（但我在印第安纳长大，让奶牛在街上生活，所以我知道这个生活方式是＆＃39; t对我而言）。</p><p> Rust is the first programming language I&#39;ve encountered in years that makesme excited. And not just normal excited: irrationally excited. Like the kindof excitement you have for something when you are naive about its limitationsand don&#39;t know any better (like many blockchain/cryptocurrency advocates). Ifeel like the discovery of Rust is transporting me back to my younger self,before I discovered the ugly realities of how computers and software work, andis giving me hope that better tools, better ways of building software couldactually exist. To channel my inner Marie Kondo: Rust sparks joy.</p><p> Rust是第一个编程语言我＆＃39;在多年来遇到的兴奋剂。而不仅仅是正常兴奋：令人兴奋的兴奋。就像你天真的兴奋一样，关于它的限制和Don＆＃39; ton＆＃39; t更好（如许多区块链/加密货币倡导者）。 ifeel喜欢生锈的发现是将我送回我的年轻人，在我发现了计算机和软件工作的丑陋现实之前，Andis给我希望更好的工具，更好的建筑软件可以存在。通道我内心的Marie Kondo：Rust引发了快乐。</p><p> When I started learning Rust in earnest in 2018, I thought this was a fluke.  Itis just the butterflies you get when you think you fall in love, I told myself. Give it time: your irrational excitement will fade. But after using Rust for~2.5 years now, my positive feelings about it have only grown  stronger. There&#39;sa reason Rust has claimed the top spot in Stack Overflow&#39;s most loved languages surveyfor 5 years and running. And not by the skin of its teeth: Rust is blowingthe competition out of the water. 19% over TypeScript and Python. 23% over Kotlinand Go. If this were a Forrester report for a company-offered product, Rustwould be the  clear market leader and marketers and salespeople would be usingthis result to sign up new customers in droves and print money hand over fist.</p><p> 当我在2018年开始学习生锈时，我以为这是一个侥幸。 ITIS只是你认为你坠入爱河的蝴蝶，我告诉自己。给它时间：你的非理性兴奋会褪色。但是在使用RUDE〜2.5年后，我对它的积极情绪只有更强大。 ＆＃39; SA原因Rust声称堆栈溢出的顶部点＆＃39;最亲爱的语言调查，5年和跑步。而不是牙齿的皮肤：锈的吹出水中的竞争。在类型签字和python上的19％。 Kotlinand的23％Go。如果这是一份公司提供的产品的Forrester报告，Rirtwould是明确的市场领导者，营销人员和销售人员将使用这一结果来注册开发人员的新客户，并将钱交出拳头。</p><p>   After you&#39;ve learned enough programming languages, you start to see commonpatterns. Manual versus garbage collected memory management. Control flowprimitives like  if,  else,  do,  while,  for,  unless. Nullable types.Variable declaration syntax. The list goes on.</p><p>   在你学习了足够的编程语言之后，开始看到commonPatterns。手动与垃圾收集的内存管理。除非，否则，控制流程的流量可用的类型。变性声明语法。列表继续。</p><p> To me, Rust introduced a number of new concepts, like  match for controlflow, enums as algebraic types, the borrow checker, the  Option and  Resulttypes/enums and more. There were also behaviors of Rust that were differentfrom languages I knew: variables are immutable by default,  Result typesmust be checked they aren&#39;t an error to avoid a compiler warning, refusingto compile if there are detectable memory access issues, and tons more.</p><p> 对我来说，Rust引入了许多新概念，例如匹配控制流，枚举作为代数类型，借用检查器，选项和结果类型/枚举等。还有不同于我知道的语言不同的生锈行为：变量默认是不可变的，结果类型usenust and＃39; t一个错误，避免编译器警告，如果有可检测的内存访问问题，则拒绝编译，并且更多。 </p><p> Many of the new concepts weren&#39;t novel to Rust. But considering I&#39;ve had exposureto many popular programming languages, the fact many were new to me means thesearen&#39;t common features in  mainstream languages.  Learning Rust felt like freshair to me: here was a language designed to be general purpose and make inroads intoindustry adoption while also willing to buck many of the trends of conventionallanguage design from the last several decades.</p><p>许多新的概念都在＆＃39; t小说生锈。但考虑到我的exposureto许多流行的编程语言，许多人对我来说是新的，这意味着TheSearen＆＃39;常见的特征在主流语言中。学习铁锈感觉像是我的新航空：这是一种旨在是通用的一种语言，并进入进入工业的采用，同时也愿意从过去几十年开始降低大股的许多趋势。</p><p> When going against conventional practice, it is very easy to unintentionallyalienate yourself from potential users. Design a programming language too unlikeanything in common use and you are going to have a difficult time attractingusers. This is a problem with many  academic/ opinionated programminglanguages (or so I hear). Rust does venture away from the tried and popular.And that does contribute to a steeper learning curve. However, there is enoughfamiliarity in Rust&#39;s core language to give you a foothold when learning Rust.(And Rust&#39;s  official learning resources areterrific.)</p><p> 违背传统实践时，非常容易从潜在用户无意中无意中彻底地努力。设计一种在常见使用中的编程语言过于unikehything，您将遇到困难的时间吸引人。这是许多学术/自以为期的编程语言（或者我听到）的问题。 Rust确实冒险远离尝试并受欢迎。这确实有助于陡峭的学习曲线。然而，生锈的核心语言中有足够的摩里尼，在学习生锈时会给你一个立足点。（和生锈＆＃39;官方学习资源。）</p><p> I feel like Rust&#39;s language designers set out to take a first principlesapproach to the language using modern ideas and ignoring old, disproven ones,realized they needed to ground the language in familiarity to achieve marketpenetration, and produced reasonable compromises to yield something that wasnew and novel but familiar enough to not completely alienate its largepotential user base.</p><p> 我觉得自己疯狂＆＃39;他的语言设计师举行了使用现代想法和忽视旧的，不当的语言的语言，实现了他们所需要的语言，熟悉熟悉的语言，以实现市场的合理妥协这是新的和新颖，但熟悉不完全疏远其大型用户群。</p><p> If you don&#39;t like being exposed to new ideas and ways of working, Rust&#39;sapproach is probably a negative to you. But if you are like me and enjoycontinuously expanding your knowledge and testing new ideas, Rust&#39;snovelty and willingness to  be different is a much welcomed attribute.</p><p> 如果你不喜欢暴露在新的想法和工作方式，生锈＆＃39; Saproach可能是一个消极的。但是，如果你喜欢我，并且享受着你的知识和测试新的想法，Rust＆＃39; Snovelty和愿意是不同的，是一个非常受欢迎的属性。</p><p>  It used to be that programming languages were just compilers or interpreters.In recent years, we&#39;ve seen more and more programming languages bundledwith other tools, such as build/packaging tools, code formatters, linters,documentation generators, language servers, centralized package repositories,and more.</p><p>  它曾经是编程语言只是编译器或口译员。近年来，我们看到了越来越多的编程语言，其他工具，如构建/包装工具，代码格式，intinters，linters，文档生成器，语言服务器，集中包存储库等等。</p><p> I&#39;m not sure what spurred this trend (maybe it was Go?), but I think it isa good move. Programming languages are ecosystems and the compiler/interpreteris just one part of a complex system. If you care about end-user experienceand adoption (especially if you are a new language), you want an as turnkeyon-boarding experience as possible. I think that&#39;s easier to pull off whenyou offer a cohesive, multi-tool strategy to attract and retain users.</p><p> 我不确定是什么刺激了这一趋势（也许是去的？），但我认为这是一个很好的举动。编程语言是生态系统和编译器/译员只是复杂系统的一部分。如果您关心最终用户体验，则采用（特别是如果您是一种新语言），则希望尽可能成为转牌顿的登机体验。我认为当你提供凝聚力，多工具策略吸引和留住用户时更容易拔下＆＃39;</p><p> We refer to programming languages with a comprehensive standard library as batteries included. I&#39;m going to refer to programming languages withadditional included tools beyond the compiler/interpreter as  toolboxincluded.</p><p> 我们将编程语言参考与包含电池的综合标准库。我将参考编程语言与编译器/解释器之外的添加工具作为工具禁止。 </p><p> Rust, is very much a  toolbox included language. (Unless you are installingit via your Linux distribution: in that case Linux packagers have likelyunbundled all the tools into separate packages, making the experience a bitmore end-user hostile, as Linux packagers tend to do for reasons thatmerit their own blog post. If you want to experience Rust the way itsmaintainers intended - the  Director&#39;s Cut if you will - install Rust via rustup.)</p><p>RUDE，是一个工具箱包括语言。 （除，想要体验Rust以Itsmaintainers预期的方式 - 导演＆＃39;如果您愿意，请通过Rustup安装Rust。）</p><p> In addition to the Rust compiler ( rustc) and the Rust standard library,the following components are all officially developed and offered as partof the Rust programming language  on GitHub:</p><p> 除了生锈编译器（RustC）和Rust标准库外，以下组件都是正式开发的，并作为GitHub上的Rust编程语言的部分提供：</p><p> vscode-rust - Visual Studio Code extension adding support for Rust. (JetBrains has their own high quality extension for their IDEs, which they develop themselves.)</p><p> vscode-rust  -  Visual Studio代码扩展名为Forth添加支持。 （Jetbrains为他们的IDES拥有自己的高质量延伸，他们培养自己。）</p><p> As an end-user, having all these tools and resources at my fingertips,maintained by the official Rust project is an absolute joy.</p><p> 作为最终用户，拥有我指尖的所有这些工具和资源，由官方生锈项目维护是绝对的快乐。</p><p> For the local tools,  rustup ensures they are upgraded as a group, so I don&#39;thave to worry about managing them. I periodically run  rustup update toensure my Rust  toolbox is up-to-date and that&#39;s all I have to do.</p><p> 对于本地工具，Rustup可确保它们作为一个组升级，所以我不＆＃39; Thave担心管理它们。我定期运行Rustup Update ocensure My Rust Toolbox是最新的，并且所有我所要做的所有＆＃39;</p><p> Contrast with say Node.js,  Python, and Ruby, wherethe package manager is on a separate release cadence from the core languageand I have to think about managing multiple tools. (Rust will likely haveto cross this bridge once there are multiple implementations of Rust ormultiple popular package managers. But until then, things are very simple.)</p><p> 与Say Node.js，python和Ruby对比，Wherethe Package Manager是核心Langamageand的单独发布节奏，我必须考虑管理多个工具。 （生锈可能HAVETO越过这座桥梁，一旦有多种生锈或多次流行的套餐管理者。但直到那时，事情很简单。）</p><p> Further contrast with languages like JavaScript/Node.js, Python, and Ruby,where tools like a code formatter, linter, and documentation generatoraren&#39;t always developed under the core project umbrella. As an end-user,you have to know to seek out these additional value-add tools. Furthermore,you have to know which ones to use and how to configure them. Thefragmentation also tends to yield varying levels of quality and end-userexperience, to the detriment of end-users. The Rust toolbox, by contrast,feels simple and polished.</p><p> 与JavaScript / node.js，python和Ruby等语言进行了相反的对比，其中代码格式化器，linter和文档生成的工具＆＃39; t始终在核心项目伞下开发。作为最终用户，您必须知道寻找这些额外的值 - 添加工具。此外，您必须知道哪些使用以及如何配置它们。该案也倾向于产生不同水平的质量和最终过分率，以损害最终用户。相比之下，锈的工具箱感觉简单和抛光。 </p><p> Rust&#39;s  toolbox included approach enables me to follow unified practices(arguably best practices) while expending minimal effort. As a result,the following tend to be very similar across nearly every Rust project you&#39;llrun into:</p><p>RUDER＆＃39; S Toolbox包含的方法使我能够遵循统一实践（可争议的最佳实践），同时消耗最低努力。结果，以下几乎每个生锈项目都往往非常相似.LLRUN进入：</p><p>     As a build system, Cargo is generally a breeze to work with. Configurationfiles are TOML. Adding dependencies is often a 1 line addition to a Cargo.toml file. Dependencies often  just work on the first try. It&#39;snot like say C/C++, where taking on a new dependency can easily consumea day or two to get it integrated in your build system and compatible withyour source code base.  I can&#39;t emphasize enough how much joy it bringsto be able to leverage an  it just works build tool for systems-levelprogramming: I&#39;m finding myself doing things in Rust like parsing ELF, PE,and Mach-O binaries because it is so easy to integrate low-level functionalitylike this into any Rust program. Cargo is  boring. And when it comes tobuild systems, that&#39;s a massive compliment!</p><p>     作为构建系统，货物通常是微风。 ConfigurationFiles是TOML。添加依赖项通常是to cargo.toml文件的1行。依赖关系通常只是在第一次尝试时工作。它＆＃39; snot say say c / c ++，在那里拍摄新依赖性，可以轻松消费的一天或两个，以便在您的构建系统中集成并兼容您的源代码库。我可以＆＃39; t强调它带来的快乐能够利用它只是工程为系统建立工具 - 水平编程：我发现自己在像解析精灵，pe和mach-o二进制文件那样做事因为它如此简单地将低级功能范围集成到任何生锈程序中。货物很无聊。当它来到造成讲解系统时，＆＃39;是一种巨大的恭维！</p><p> No other language I&#39;ve used has as comprehensive and powerful of a toolbox as Rust does. This  toolbox is highly leveraged by the Rustcommunity, resulting is remarkable consistency across projects. Thisconsistency makes it easier to understand, use, and contribute back toother Rust projects. Contrast this with say C/C++, where large code basesoften employ multiple tools in the same space on different parts of thesame code base, leading to cognitive dissonance and overhead.</p><p> 没有其他语言I＆＃39; ve使用的是一个工具箱的全面和强大的工具箱。该工具箱由RustCommunity高度杠杆杠杆化，导致项目跨越项目卓越。这本来使得更容易理解，使用和贡献回更多的生锈项目。将其与C / C ++进行对比，其中大代码Baseoften在同一空间中使用多个工具在Chesame代码库的不同部分，导致认知不应和开销。</p><p> As a professional programmer, Rust&#39;s powerful and friendly  toolboxenables me to build Rust software more easily than with other languages.I spend less time wrangling tools and more time coding. That translatesto less overhead delivering value through software. Other languageswould be wise to emulate aspects of Rust&#39;s model.</p><p> 作为专业的程序员，Rust＆＃39; SURIVE和友好的工具忠诚的工具，比其他语言更轻松地构建生锈软件。我花费更少的时间绞刑工具和更多时间编码。翻译通过软件的开销较少提供价值。其他语言会明智地模拟生锈的方面。</p><p>  Of all the programming languages I&#39;ve used, Rust seems to empathizewith its users the most.</p><p>  所有的编程语言I＆＃39;已经使用过的，rust似乎同情最适合用户。</p><p>  A lot of care seems to have gone into the end-user experience of theRust  toolbox.</p><p>  很多关怀似乎已经进入了Therust工具箱的最终用户体验。</p><p> The Rust compiler often gives extremely actionable error and warningmessages. If something is wrong, it tells me why it is wrong, oftenpointing out exactly where in source code the problem resides, drawingcarets to the source code where things went wrong. In many cases,the compiler will emit a suggested fix, which I can incorporateautomatically by pressing a few keys in my IDE. Contrast this withC/C++ and even Go, which tend to have either too-terse-to-be-actionableor too-verbose-to-make-sense-of feedback. By comparison, output fromother compilers often comes across as condescending, as if they aresaying  git gud, idiot. Rust&#39;s compiler output tends to come acrossas  I&#39;m sorry you had a problem: how can I help? I feel like thecompiler actually cares about my [valuable] time and satisfaction.It wants to keep me in flow.</p><p> Rust编译器通常提供极其可操作的错误和警告。如果出现问题，它会告诉我为什么它是错误的，常常究竟在源代码中的位置驻留在哪里，绘制了源代码的源代码。在许多情况下，编译器将发出建议的修复，我可以通过按IDE中的一些键来填充。将此与C ++对比，甚至可以转移，这往往具有太简洁的actionabledor过于简洁地呈现给予的反馈意见。相比之下，来自其他编译器的产出往往伴随着居高临下，仿佛他们aresaying gud，白痴。 Rust＆＃39; S编译器输出往往会遇到I＆＃39;对不起你有问题：我该怎么帮忙？我觉得自己认为我的[有价值]时间和满足。它想要让我流入。 </p><p>  One thing I love about Clippy is - like the compiler - many of the lintscontain suggestions, which I can incorporate automatically through myIDE. So many other linters just tell you what is wrong and don&#39;t seemto go the extra mile to be respectful of my time by offering to fix itfor me.</p><p>我喜欢Clippy的一件事是 - 就像编译器 - 许多LintScontain建议，我可以通过IDIDE自动融入。这么多其他的林德斯只是告诉你有什么问题和守恒似乎似乎恭敬我的时间来尊重我的时间来解决它。</p><p> Another aspect of Clippy I love is it is like having an invisible Rustmentor continuously providing constructive feedback to help me level-up myRust. I don&#39;t know how many times I&#39;ve written Rust code similarly to how Iwould write code in other languages and Clippy suggests a more  Rusticsolution. Most of the time I&#39;m like  oh, I didn&#39;t know about that: that&#39;sa much better pattern/solution than what I wrote!</p><p> Clippy的另一个方面是我爱的是，它就像是一个不可见的Rustummentor，不断提供建设性的反馈，以帮助我升级近距离。我不知道我知道有多少次＆＃39; VE写了多少次的铁锈代码，类似于我如何用其他语言编写代码，CLIPPY建议更古老的研究。大多数时候我和＃39; m喜欢哦，我没有知道这个问题：那个＆＃39; sa比我写的更好的模式/解决方案！</p><p> Do I agree with Clippy all the time? Nope. But I do find its signal tonoise ratio is exceptionally high compared to other linters I&#39;ve used.And Clippy is trivial to configure and override, so disagreements areeasy to manage. Like the Rust compiler, I feel that Clippy is respectfulof my time and has the long term maintainability and correctness of mysoftware at heart.</p><p> 我一直同意Clippy吗？不。但是，与其他林德，我确实发现它的信号儿童比例非常高。使用。Clippy配置和覆盖是微不足道的，因此分歧是易于管理的。像生锈编译器一样，我觉得Clippy是尊重我的时间，并且拥有MySoftware在心脏的长期可维护性和正确性。</p><p> Then there&#39;s the Rust Community - the people behind the core Rust projects. The Rust Community is one of the most professional and welcoming I&#39;veseen. Their  Code of Conductis sufficiently comprehensive and actionable. They have their vigorousdebates like any other community. But the conversation is civil. Badapples are discarded when they crop up.</p><p> 然后在生锈界 - 核心生锈项目后面的人民。铁锈界是最专业和最热情的I＆＃39; VESEEN。他们的行为准则足够全面和可行。他们像任何其他社区一样有活力。但谈话是民事的。在播种时丢弃了守护行。</p><p> At a talk I made about PyOxidizer at a Rust meetup a few years back,I made a comment in passing about a negative comment I encountered ona Rust sub-Reddit. After the talk, a moderator of that sub who was inthe audience (unbeknownst to me) approached for more information so theycould investigate, which they did.</p><p> 在谈话中，我在几年后在生锈举行的肥胖化器上做了关于蟒蛇多，我发表了评论，通过关于我遇到的否定评论，我遇到了ona生锈子reddit。在谈话结束后，那个位于受众（Unbebownst的Sub的主持人接近了更多信息，所以他们可以调查他们所做的。</p><p> I once tweeted about a somewhat confusing, not-very-actionable compilererror I encountered. A few minutes later, some compiler developers wereconversing in replies. A few hours later, a pull request was created anda much better error message was merged in short order. I&#39;m not a specialone-off here either: I&#39;ve stumbled across Stack Overflow questions andother forums where Rust core developers see that someone is encounteringa confusing issue, question the process that got them to that point, andthen make refinements to minimize it from happening in the future. Thepractice is very similar to what empathetic product managers and userexperience designers do.</p><p> 我曾经推特大约有点令人困惑，不是非常可操作的编译器。几分钟后，一些编译器开发人员在回复中加剧。几个小时后，创建了一个拉出请求，并且在短订单中合并了更好的错误消息。我不是在这里的一个专家：i＆＃39;在堆栈溢出的问题上困扰了跨越的问题和其他论坛，其中生锈核心开发人员看到某人遇到令人困惑的问题，质疑将它们达到这一点的过程，安直尽量减少将来发生。实践非常相似于同情产品经理和超速设计师。</p><p> Not many other communities (or companies for that matter) seem todemonstrate such a high level of compassion and empathy for theirusers. To be honest, I&#39;m not sure how Rust manages to pull it off,as this tends to be very expensive in terms of people time and it canbe very easy to not prioritize. One thing is for certain:  the Rust Communityis loaded with empathetic people who care about the well-being of usersof their products. And it shows from the interaction in forums tothe software tools they produce. To everyone who has contributed in theRust Community: thank you for all that you have done and for setting anexample for the rest of us to live up to.</p><p> 不是许多其他社区（或公司的公司）似乎对他们的人来说似乎很高的同情和同理心。要诚实，我不确定铁锈的设法如何将其拉下来，因为这在人们的时间方面往往非常昂贵，它很容易不优先考虑。有一件事是肯定的：锈细节被载有关心用户产品的福祉的同情心。它从论坛中的互动显示了他们生产的软件工具。对于在Therust社区提供贡献的每个人：谢谢你所做的一切，并为我们其他人设立一个anexample来锻炼身体。 </p><p>  One of the reasons I avoided learning Rust for years is that I perceivedit was too low level and therefore tedious. Rust was being advertised asa  systems programming language and you would hear stories of  fightingthe borrow checker. I assumed I&#39;d need to be thinking a lot about memoryand ownership. I assumed the cost to author and maintain Rust code would behigh. I thought Rust would be  a safer C/C++, with many of the softwaredevelopment lifecycle caveats that apply. And for the software I waswriting at a time, the value proposition of Rust seemed weak. I thoughta combination of C and say Python was  good enough. When I startedwriting  PyOxidizer, I initiallythought only the run-time code calling into the Python interpreter C APIswould be written in Rust and the rest would be Python.</p><p>我避免学习生锈的原因之一是我认识到水平过低，因此乏味。 Rust正在被广告为ASA Systems编程语言，您可以听到借用检查员的故事。我假设我需要思考记忆和所有权。我假设作者的成本并保持生锈代码。我以为锈病将是一个更安全的C / C ++，许多软件的生命周期施用。而对于软件我一次怀疑，Rust的价值主张似乎很弱。我觉得c的组合，并说python足够好。当我暂停烙氧化器时，我初始化呼叫进入Python解释器C API的运行时间代码将被用Rust编写，其余的将是Python。</p><p>  When I actually started coding Rust, I was shocked at how high-level itfelt. Now, depending on the space of your software, Rust code can bevery low-level and tedious (not unlike C/C++). However,  for thevast majority of code I author, Rust feels more like Python than C. Andeven the lower-level code feels much higher level than C or even C++.</p><p>  当我实际开始编码生锈时，我感到震惊，这是如何令人震惊的。现在，根据软件的空间，Rust代码可以享注低级和繁琐的（不像C / C ++不同）。但是，对于我作者的TheVast大多数代码，Rust比C.而不是C. Andeven较低级别的代码比C甚至C ++的水位高得多。</p><p> In my mind,  the expressiveness of Rust comes very close to higher-level,dynamic languages (like JavaScript, Python, and Ruby) while maintainingthe raw speed of C/C++ all without sacrificing low-level control forcases when you need it. And it does all of this while maintaining strongsafety guarantees (unlike say</p><p> 在我看来，Rust的表现力非常接近高级，动态语言（如JavaScript，Python和Ruby），同时保持C / C ++的原始速度，而无需在需要时牺牲低级控制Forcase。它在保持强度保证的同时确实如此（不同于</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gregoryszorc.com/blog/2021/04/13/rust-is-for-professionals/">https://gregoryszorc.com/blog/2021/04/13/rust-is-for-professionals/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/锈病/">#锈病</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>