<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>二次时间排列不可见的图标 Arranging Invisible Icons in Quadratic Time</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Arranging Invisible Icons in Quadratic Time<br/>二次时间排列不可见的图标 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-17 18:27:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/5d995162b823978ac277c88d0369bcf6.png"><img src="http://img2.diglog.com/img/2021/2/5d995162b823978ac277c88d0369bcf6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Near the end of January I was pointed to a twitter thread where a Windows user with a powerful machine was hitting random hangs in explorer. Lots of unscientific theories were being proposed. I don’t generally do random analysis of strangers’ performance problems but the case sounded interesting so I thought I’d take a look.</p><p>一月底，我被指到了一个推特线程，一个拥有强大计算机的Windows用户正在浏览器中随机挂起。提出了许多不科学的理论。我通常不会对陌生人的表现问题进行随机分析，但此案听起来很有趣，所以我想看看。</p><p>  Freya shared an  ETW trace of what was happening on her machine and I took a look using  Windows Performance Analyzer (WPA). The first thing I noticed was that the UI Delays graph showed that, as promised,  explorer.exe’s thread 7,888 was failing to check for messages for 20.531 seconds. It was hung.</p><p>  Freya分享了她的计算机上发生的事件的ETW跟踪信息，我使用Windows Performance Analyzer（WPA）进行了研究。我注意到的第一件事是，UI延迟图显示，正如所承诺的那样，explorer.exe的线程7888在20.531秒内未能检查消息。它挂了。</p><p>  Now, explorer.exe has many UI threads so it’s not like the entire process was hung, but one of its windows was definitely hung, it was causing hangs elsewhere, and this is bad.</p><p>  现在，explorer.exe具有许多UI线程，因此它好像不是整个过程都被挂起了，但是它的一个窗口肯定被挂起了，这导致了其他地方的挂起，这很糟糕。</p><p> If a thread is failing to pump messages then that is either because it is busy doing something else ( consuming CPU) or it is waiting on something else ( idle CPU). After zooming in to the 20.531 second  MsgCheck Delay time period I checked the  CPU Usage (Precise) data (derived from context switch instrumentation and 100% accurate) and saw that thread 9,228 was running 99.2% of the time – it was consuming lots of CPU.</p><p> 如果线程无法发送消息，则可能是因为它正在忙于执行其他操作（消耗CPU），或者是在等待其他操作（空闲CPU）。放大20.531秒的MsgCheck Delay时间段后，我检查了CPU使用率（精确）数据（来自上下文切换工具，准确度为100％），发现线程9228运行99.2％的时间–它消耗大量CPU 。</p><p> The next task was to figure out what it was doing. The  CPU Usage (Sampled) data (derived from a 1 kHz sampling profiler) told me that thread 9,228 was spending roughly 99.7% of its time (26994 out of 27074 samples) in the  BatchPositionChangesHelper destructor (line 21) and its children (lines 23-25). That is a very expensive destructor.</p><p> 下一个任务是弄清楚它在做什么。 CPU使用率（采样）数据（来自1 kHz采样分析器）告诉我，线程9,228在BatchPositionChangesHelper析构函数（第21行）及其子代（第23行）中花费了大约99.7％的时间（在27074个样本中占26994）。 -25）。那是一个非常昂贵的析构函数。</p><p>  I don’t have access to this source code but I looked through the stacks for a bit and they seemed to suggest that explorer.exe was spending more than 20 seconds doing a lot of tasks related to… arranging icon positions.</p><p>  我没有访问此源代码的权限，但我对堆栈进行了仔细的浏览，似乎表明explorer.exe花了20多秒钟来完成许多与……安排图标位置有关的任务。</p><p>  Arranging icons on the desktop is pretty simple. You just stack then in columns, overflow to the next column, and stop when the screens are full. So, 20 seconds arranging icons didn’t seem plausible and I assumed that the root cause would be some weird shell extension or other third-party software, but eventually I tried to reproduce the bug in the simplest way possible. I thought to myself, what if I just make a thousand copies of a tiny .jpg image on my desktop and see if explorer.exe misbehaves. It was too dumb to be sufficient, and yet:</p><p>  在桌面上排列图标非常简单。您只需要在各列中堆叠然后溢出到下一列，然后在屏幕满时停止即可。因此，排列图标20秒似乎不太合理，我认为根本原因是某些奇怪的Shell扩展程序或其他第三方软件，但最终我尝试以最简单的方式重现该错误。我心想，如果我只是在桌面上制作一千个.jpg图像的小副本，然后查看explorer.exe的行为不正常怎么办。这太愚蠢了，不足以解决问题，但是： </p><p> src = os.path.join(script_path, ‘SunsetWhales.jpg’) dst = os.path.join(desktop_path, ‘TestFiles%04d.jpg’) for i in range(file_count):   shutil.copy(src, dst % i)</p><p>src = os.path.join（script_path，'SunsetWhales.jpg'）dst = os.path.join（desktop_path，'TestFiles％04d.jpg'）适用于范围（file_count）中的i：一世）</p><p> I ran this simple script with a  file_count of 1,000 and suddenly explorer.exe was spinning like mad for more than twenty seconds. It really was that simple.</p><p> 我使用file_count为1000运行了这个简单的脚本，然后explorer.exe像疯了似的旋转了二十多秒钟。真的就是这么简单。</p><p>  Computers today are really fast. The CPU of the original reporter (OP) was running at 4.6 GHz and they had approximately 950 GIF files on their desktop. In 20 seconds their CPU would tick through 92  billion cycles, or 97  million cycles per image. That is a lot.</p><p>  今天的计算机确实非常快。原始报告程序（OP）的CPU运行在4.6 GHz上，台式机上大约有950个GIF文件。在20秒内，他们的CPU将完成920亿个周期，即每个图像9700万个周期。好多</p><p> My guess was that  once again this was due to an observation which I have taken to calling  Dawson’s first law of computing:  O(n^2) is the sweet spot of badly scaling algorithms: fast enough to make it into production, but slow enough to make things fall down once it gets there.</p><p> 我的猜测是，这再次归因于我观察到的一种称为Dawson的第一个计算定律：O（n ^ 2）是缩放算法很差的地方：足够快以使其投入生产，但足够慢使事情一到就掉下来。</p><p> That is, the most likely explanation for why arranging icons was taking so long is that the icon rearranging code used an O(n^2) (aka  quadratic) algorithm such that as the number of icons doubled the time to arrange them quadrupled. This sort of performance scaling can take an algorithm that works fine for ten items and make it fail miserably with just 1,000 items.</p><p> 就是说，最有可能解释为什么安排图标花这么长时间的原因是，图标重新排列代码使用了O（n ^ 2）（又称二次方）算法，使得图标的数量增加了两倍，而排列它们的时间增加了四倍。这种性能扩展可以采用一种算法，该算法可以很好地处理十个项目，而仅用1,000个项目就可能导致失败。</p><p>   I started by writing a script that would populate my desktop with a specified number of images. I ran that repeatedly with increasingly large numbers of images, and recorded an ETW trace so that I could measure the performance. I also monitored  explorer.exe using  Task Manager so that I could tell when it had finished one job and was ready for the next.</p><p>   我首先编写了一个脚本，该脚本将用指定数量的图像填充桌面。我用越来越多的图像反复运行，并记录了ETW轨迹，以便可以测量性能。我还使用任务管理器监视了explorer.exe，这样我就可以知道它何时完成一项工作并为下一项做好准备。</p><p> My first test gave messy results – it looked like a non-linear increase but any attempt at line fitting was going to be more about hope-and-magic than following the data. I needed to understand what was going on in order to better test my theory.</p><p> 我的第一个测试给出了混乱的结果–看起来像是非线性的增长，但是任何进行直线拟合的尝试都将更多地是希望和魔术，而不是跟随数据。我需要了解正在发生的事情，以便更好地检验我的理论。 </p><p> While looking at the traces I realized that the  BatchPositionChangesHelper destructor was running  most of the time (blue region) but not  all of the time that explorer was running (green region):</p><p>在查看跟踪时，我意识到BatchPositionChangesHelper析构函数在大多数时间（蓝色区域）都在运行，但在资源管理器的所有时间（绿色区域）中都没有运行：</p><p>  I realize that, among other things, the layout work was being interrupted by display work, and then I understood the cause of the variability.</p><p>  我意识到，除其他外，布局工作被显示工作打断了，然后我理解了变化的原因。</p><p> When my Python script started creating images the  explorer.exe process would notice and immediately start trying to lay out icons. It might end up doing this multiple times while I was creating the images and this was creating unpredictable results. It was a race condition which made the total cost inconsistent. Since I didn’t have access to the  explorer.exe source code I had to hack up a way to make it wait until all of the images were created before doing any layout. I did this by using  psutil to suspend the  explorer.exe process while I was creating the images. Then when I resumed the process it would do all of the work. The code looks something like this:</p><p> 当我的Python脚本开始创建图像时，explorer.exe进程会注意到并立即开始尝试布局图标。在创建图像时，它可能会多次执行此操作，而这会产生不可预测的结果。这是一个竞赛条件，使总成本不一致。由于我无法访问explorer.exe源代码，因此我不得不寻找一种方法，使其等待所有图像创建完成后再进行任何布局。在创建映像时，我通过使用psutil暂停了explorer.exe进程来做到这一点。然后，当我恢复该过程时，它将完成所有工作。代码看起来像这样：</p><p>  With that in place I ran  my test batch file while recording an ETW trace. To minimize noise and trace size I disabled context switch call stacks (unneeded) and I turned off indexing for the desktop folder. I monitored  explorer.exe CPU usage with Task Manager and hit enter to go to the next test whenever it had gone to zero. That gave me this very nice graph of the CPU Usage of  explorer.exe:</p><p>  有了这个，我在记录ETW跟踪的同时运行了我的测试批处理文件。为了最大程度地减少噪声和跟踪大小，我禁用了上下文切换调用堆栈（不需要），并且关闭了桌面文件夹的索引编制功能。我使用任务管理器监视explorer.exe的CPU使用情况，并在输入为零时按Enter键进入下一个测试。这给了我explorer.exe CPU使用率的这张非常漂亮的图表：</p><p>  The individual blocks represent CPU usage for 100, 200, 300, and so on images up to 1,000. If you have a keen eye then you will see that the CPU usage increases  faster than linear but  slower than quadratic. That is, the initial data suggests that the layout algorithm is  not-quite-O(n^2).</p><p>  各个块代表100、200、300等的CPU使用率，以此类推，直到1,000张图像。如果您有敏锐的眼光，那么您会发现CPU使用率的增加快于线性速度，但慢于平方速度。即，初始数据表明布局算法不是相当-O（n ^ 2）。</p><p> However, explorer does more work that just icon layout. If some of its tasks are O(n) – linear – then they will diffuse the impact of the O(n^2) tasks. As ‘n’ increases the O(n^2) tasks will eventually dominate, but I didn’t want my test harness to run even longer than the 160 seconds it was already taking.</p><p> 但是，资源管理器所做的工作不仅仅是图标布局。如果其某些任务是O（n）（线性），那么它们将分散O（n ^ 2）任务的影响。随着'n'的增加，O（n ^ 2）任务最终将占主导地位，但我不希望我的测试工具的运行时间超过已经花费的160秒。</p><p>  Therefore my next task was to isolate out the time spent in the  BatchPositionChangesHelper destructor. It represented 78.4% of the time spent in explorer.exe in my test trace, and 92.3% of the time spent in the busy thread, and if I could prove that it was quadratic then I would have proved that as ‘n’ increased it would dominate evermore.</p><p>  因此，我的下一个任务是找出在BatchPositionChangesHelper析构函数中花费的时间。在我的测试跟踪中，它花费了78.4％的时间用于explorer.exe，而在繁忙的线程中则花费了92.3％的时间，如果我能证明它是二次方的，那么我会证明随着'n'的增加将永远统治。 </p><p> To do that I looked at the CPU Usage (Sampled) data and filtered it down to just show the samples in the  BatchPositionChangesHelper destructor and its children. I then looked at the ten different areas of the graph, and graphed the sample counts. The curve is so smooth that it looks fake, but this is the actual data.</p><p>为此，我查看了CPU使用率（采样）数据并将其过滤掉，以仅在BatchPositionChangesHelper析构函数及其子代中显示样本。然后，我查看了图形的十个不同区域，并绘制了样本计数的图形。曲线是如此平滑，以致看起来是假的，但这是实际数据。</p><p> If you look at key points on the graph such as when the image count is 500 and then 1,000 you can see that the performance scaling is slightly  worse than O(n^2). That is, laying out 1,000 icons takes more than four times longer than laying out 500 icons.</p><p> 如果查看图形上的关键点（例如，当图像计数为500时，然后是1,000时），则可以看到性能缩放比O（n ^ 2）稍差。也就是说，布置1,000个图标所需的时间是布置500个图标所需时间的四倍以上。</p><p>  I don’t tend to have many icons on my desktop, so I am mostly immune to this bug. However I’ve seen people with their desktop completely full of icons and they are probably hitting lesser versions of this.</p><p>  我的桌面上通常不会有很多图标，因此我几乎不受此错误的影响。但是，我看到人们的桌面上完全装有图标，他们可能正在使用次要版本。</p><p> The OP used their desktop to store GIF files. They treated it like a folder (which it is) where you can easily store images. They rarely used the icons on the desktop. So, when the number of icons eventually became excessive they decided to uncheck “Show desktop icons” to reduce the clutter. The icons were hidden and they could continue to store images in that folder.</p><p> OP使用其桌面存储GIF文件。他们将其视为一个文件夹（可以在其中轻松存储图像）。他们很少使用桌面上的图标。因此，当图标的数量最终变得过多时，他们决定取消选中“显示桌面图标”以减少混乱。图标被隐藏，它们可以继续将图像存储在该文件夹中。</p><p>  The hangs that they saw, where  explorer was repeatedly spending 20+ seconds arranging the icons on their desktop, where  explorer was burning 92  billion CPU cycles to get the icons positioned  just right… were happening with the icons hidden.</p><p>  他们看到的死机是，资源管理器反复花费20多秒钟在桌面上排列图标，而资源管理器正在消耗920亿个CPU周期以使图标定位正确……这是在隐藏图标的情况下发生的。</p><p>  Laying out icons on a grid should be an inherently linear operation, but somehow it was written as quadratic and was executed even when the icons were not being displayed.</p><p>  在网格上布置图标应该是一种固有的线性操作，但是以某种方式将其编写为二次方，即使未显示图标也可以执行。</p><p> That’s it. If you write code that is going to be run by others then make sure that it scales well enough to handle any conceivable data set – reasonable or not. Quadratic algorithms usually fail that test.</p><p> 而已。如果您编写将由其他人运行的代码，请确保其伸缩性足够好以处理任何可能的数据集（无论是否合理）。二次算法通常无法通过该测试。 </p><p>  The original bug seemed to be related to rearranging multi-monitor setups (a job hazard for streamers, so I’m told) so for a while I was testing by plugging and unplugging my external monitor. That works poorly for efficient testing, and it also seems to have worn out the external monitor connection on my personal laptop. My laptop can no longer see my external monitor. Oops.</p><p>最初的错误似乎与重新排列多显示器设置有关（据告诉，这对拖缆有工作危险），所以一段时间以来，我一直在通过插拔外部显示器进行测试。这对于有效的测试而言效果不佳，而且似乎也耗尽了我个人笔记本电脑上的外接显示器连接。我的笔记本电脑不再能看到我的外接显示器。哎呀。</p><p>  When I analyzed the OP’s trace I just loaded it into Windows Performance Analyzer (WPA) and waited. I didn’t have to check to see what version of Windows they were running or what patches they had installed. WPA just looked at the debug information for all of the EXEs and PE files and downloaded symbol files from Microsoft’s symbol servers (and Chrome’s because I have that configured as well).  Symbol servers are good. If you are on Windows then make sure you are using symbol servers. If you are not on Windows – I’m very sorry.</p><p>  在分析OP的轨迹时，我只是将其加载到Windows Performance Analyzer（WPA）中并等待。我不必查看运行的Windows版本或已安装的补丁程序。 WPA只是查看了所有EXE和PE文件的调试信息，并从Microsoft的符号服务器（以及Chrome浏览器，因为我也配置了它们）下载了符号文件。符号服务器很好。如果您使用的是Windows，请确保使用符号服务器。如果您使用的不是Windows，则非常抱歉。</p><p>  I don’t know how many people this bug affects (anyone with 200-300 icons is hitting a modest version of this, and it gets progressively worse with more) and I have no power to fix it. So,  I filed a bug. I am not hopeful that it will be fixed. My last  quadratic-in-Windows bug has had zero comments since it was filed a few months ago.</p><p>  我不知道此错误会影响多少人（任何带有200-300个图标的人都遇到了该错误的中等版本，并且随着更多的使用，它会变得越来越糟），而且我无力修复。因此，我提交了一个错误。我不希望它会解决。自几个月前提交以来，我的上一个Windows二次方错误已被零评论。</p><p> The raw measurements from my tests are  here and the tests themselves are  here on github. This bug is extremely easy to reproduce. If somebody wants a Feedback Hub entry they should create one. I recommend using UIforETW’s  Browse Folder option while the desktop is hung – the operation will be blocked for the duration.</p><p> 我的测试的原始测量值在这里，测试本身在github上。此错误非常容易重现。如果有人想要“反馈中心”条目，则应创建一个。我建议在桌面挂起时使用UIforETW的“浏览文件夹”选项-在整个操作过程中，该操作将被阻止。</p><p>  I’ve gone through quite a few interview loops during my career. I have often been asked to come up with an algorithm to do some artificial task. The obvious “brute-force” algorithm   would usually be quadratic (O(n^2)) or, occasionally, exponential (O(2^n)). This would then generally lead to a discussion of:</p><p>  在我的职业生涯中，我经历了许多采访循环。经常有人要求我提出一种算法来完成一些人工任务。显而易见的“蛮力”算法通常是二次方（O（n ^ 2））或偶尔是指数方（O（2 ^ n））。这样通常会引起以下讨论：</p><p>  Despite the obvious awareness of this issue we, as an industry, keep shipping code that is quadratic. Code that is fast enough to make it into production, but  slow enough to make things fall down once it gets there. See for example  this,  this,  this,  this,  this, and many more. We really need to stop.</p><p>  尽管对这个问题有明显的了解，但作为一个行业，我们仍然保持二次运输代码。足够快的代码可以将其投入生产，但是足够慢的代码可以使它在投入生产后就崩溃了。例如，请参见此，此，此，此以及更多。我们真的需要停下来。</p><p> Tired of reading boring performance analysis? Instead you can read about how I used  19 different commute methods in September 2018, or  20 different commute methods in April 2017.</p><p> 厌倦了阅读枯燥的性能分析？相反，您可以了解我在2018年9月如何使用19种不同的通勤方法，或者在2017年4月如何使用20种不同的通勤方法。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://randomascii.wordpress.com/2021/02/16/arranging-invisible-icons-in-quadratic-time/">https://randomascii.wordpress.com/2021/02/16/arranging-invisible-icons-in-quadratic-time/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/时间/">#时间</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/invisible/">#invisible</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/图标/">#图标</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>