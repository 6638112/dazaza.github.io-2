<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何使您的代码审查员爱上您 How to Make Your Code Reviewer Fall in Love with You</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to Make Your Code Reviewer Fall in Love with You<br/>如何使您的代码审查员爱上您 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-07 20:13:09</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/523ab707491f5b1920cd0d89321a5db5.jpg"><img src="http://img2.diglog.com/img/2020/12/523ab707491f5b1920cd0d89321a5db5.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>When people talk about code reviews, they focus on the reviewer. But the developer who writes the code is just as important to the review as the person who reads it. There’s scarcely any guidance on preparing your code for review, so authors often screw up this process out of sheer ignorance.</p><p>当人们谈论代码审查时，他们专注于审查者。但是，编写代码的开发者与阅读者一样，对审查同样重要。几乎没有指导您编写代码进行审查的指南，因此作者常常出于纯粹的无知而将这一过程搞砸了。</p><p> This article describes best practices for participating in a code review when you’re the author. In fact, by the end of this post, you’re going to be so good at sending out your code for review that  your reviewer will literally fall in love with you.</p><p> 本文介绍了当您是作者时参与代码审查的最佳做法。实际上，在这篇文章的结尾，您将非常擅长发送代码进行审核，以至于您的审核者会真正爱上您。</p><p> But I don’t want my reviewer to fall in love with me  🔗︎</p><p> 但我不希望我的审稿人爱上我🔗︎</p><p> They’re going to fall in love with you. Deal with it. Nobody ever complained on their deathbed that too many people fell in love with them.</p><p> 他们会爱上你的。处理它。没有人在临终前抱怨过太多人爱上了他们。</p><p>   Learn faster: If you prepare your changelist properly, it directs your reviewer’s attention to areas that support your growth rather than boring style violations. When you demonstrate an appreciation for constructive criticism, your reviewer provides better feedback .</p><p>   更快地了解：如果您正确地准备了更改列表，它将使审阅者的注意力转移到支持您的成长而不是无聊的风格违规的领域。当您对建设性批评表示赞赏时，您的审稿人会提供更好的反馈。</p><p> Make others better: Your code review techniques set an example for your colleagues. Effective author practices rub off on your teammates, which makes your job easier when they send code to you.</p><p> 使其他人变得更好：您的代码审查技术为您的同事树立了榜样。有效的作者做法会削弱您的队友，使他们在向您发送代码时更加轻松。</p><p> Minimize team conflicts: Code reviews are a common source of friction. Approaching them deliberately and conscientiously minimizes arguments.</p><p> 最小化团队冲突：代码审查是造成冲突的常见原因。认真而认真地对待它们可以减少争论。 </p><p>  This advice sounds obvious, but I often see authors treat their reviewers like personal quality assurance technicians. These authors make zero effort to catch their own errors or to design their changelist for reviewability.</p><p>这个建议听起来很明显，但是我经常看到作者像对待个人质量保证技术人员一样对待审稿人。这些作者竭尽全力发现自己的错误或设计变更列表以供审核。</p><p> Your teammate arrives at work each day with a finite supply of focus. If they allocate some of it to you, that’s time they can’t spend on their own work. It’s only fair that you maximize the value of their time.</p><p> 您的队友每天都会集中精力集中工作。如果他们将其中的一部分分配给您，那就是他们无法花费自己的时间的时候。您可以最大限度地利用他们的时间，这是公平的。</p><p> Reviews drastically improve when both participants trust each other. Your reviewer puts in more effort when they can count on you to take their feedback seriously. Viewing your reviewer as an obstacle you have to overcome limits the value they offer you.</p><p> 当两个参与者彼此信任时，评论会大大改善。当他们可以指望您认真对待他们的反馈时，您的审阅者会付出更多的努力。将审阅者视为必须克服的障碍，这限制了他们为您提供的价值。</p><p>    Before sending code to your teammate, read it yourself. Don’t just check for mistakes — imagine reading the code for the first time. What might confuse you?</p><p>    在向您的队友发送代码之前，请自己阅读。不要只是检查错误-想象一下第一次阅读代码。有什么可能会使您感到困惑？</p><p> I find it helpful to take a break between writing my code and reviewing it. People often fire off their changes at the end of the day, but that’s when you’re most likely to overlook careless errors. Wait until morning, and look at the changelist with fresh eyes before handing it over to your teammate.</p><p> 我发现在编写代码和检查代码之间稍作休息会有所帮助。人们通常会在一天结束时取消更改，但是那时候您很可能会忽略粗心的错误。等到早晨，再将新鲜的眼睛看着变更列表，然后再将其移交给您的队友。</p><p>  Adopt your reviewer’s environment as much as possible. Use the same diff view that they’ll see. It’s easier to catch dumb mistakes in a diff view than in your regular source editor.</p><p>  尽可能采用您的审阅者的环境。使用他们将看到的相同的差异视图。与常规源代码编辑器相比，在差异视图中发现愚蠢的错误要容易得多。</p><p> Don’t expect yourself to be perfect. Inevitably, you’ll send out a changelist with debugging code that you forgot to delete or a stray file you meant to exclude. These mistakes aren’t the end of the world, but they’re worth tracking. Pay attention to your patterns of error, and think about creating systems to prevent them. If they happen too frequently, it signals to your reviewer that you don’t value their time.</p><p> 不要期望自己是完美的。不可避免地，您将发送一个更改列表，其中包含您要删除的调试代码或要排除的杂散文件。这些错误不是世界末日，但值得我们跟踪。注意您的错误模式，并考虑创建系统来防止它们。如果它们发生得太频繁，则会向您的审阅者发出信号，表示您不珍惜他们的时间。 </p><p>  At my last job, I met regularly with a senior engineer as part of a developer mentorship program. Before our first meeting, he asked me to bring a design document I’d written. As I handed it to him, I explained what the project was and how it aligned with my team’s goals. My mentor frowned. “Everything you just told me should be on the first page of your design doc,” he said, bluntly.</p><p>在上一份工作中，作为开发人员指导计划的一部分，我定期会见一位高级工程师。在我们第一次见面之前，他请我带上我写的设计文件。当我将其交给他时，我解释了该项目是什么以及它如何与我的团队目标保持一致。我的导师皱了皱眉。他直截了当地说：“您刚才告诉我的所有内容都应该在设计文档的首页上。”</p><p> He was right. I wrote the design document imagining how my teammates would read it, but I failed to consider other readers. There was a broader audience beyond my immediate teammates that included partner teams, mentors, and  promotion committees. They should all be able to understand the document as well. Since that discussion, I always think about how to frame my work to explain its context.</p><p> 他是对的。我写了设计文档，想像我的队友将如何阅读它，但是我没有考虑其他读者。除了我的直接队友之外，还有更广泛的听众，包括合作伙伴团队，导师和晋升委员会。他们都应该也能够理解该文档。从那次讨论开始，我一直在思考如何构建我的作品以解释其背景。</p><p> Your changelist description should summarize any background knowledge the reader needs. You might have a code reviewer in mind when you write the description, but they don’t necessarily have the context you imagine. Besides, your other teammates might need to read this changelist as well, and readers in the future should understand your intentions when they look back on the change history.</p><p> 您的变更列表说明应总结读者需要的所有背景知识。在编写说明时，您可能会想到一个代码审阅者，但是他们不一定具有您所想象的上下文。此外，您的其他队友也可能需要阅读此更改列表，将来的读者在回顾更改历史时应了解您的意图。</p><p> A good changelist description explains  what the change achieves, at a high level, and  why you’re making this change.</p><p> 良好的变更列表说明从总体上说明了变更所能实现的目标以及进行此变更的原因。</p><p> For a deeper dive into writing excellent changelist descriptions, see  “How to Write a Git Commit Message” by Chris Beams and  “My favourite Git commit” by David Thompson.</p><p> 要深入研究编写出色的变更列表说明，请参阅Chris Beams的“如何编写Git提交消息”和David Thompson的“我最喜欢的Git提交”。</p><p>  If you rely on your reviewer to tell you when your curly braces are on the wrong line or that your change broke the automated test suite, you’re wasting their time.</p><p>  如果您依靠审稿人告诉您何时花括号用错了线，或者您的更改破坏了自动测试套件，那是在浪费他们的时间。</p><p>  Automated tests should be part of your team’s standard workflow. The review begins after  all automated checks pass in a continuous integration environment.</p><p>  自动化测试应成为您团队标准工作流程的一部分。在所有自动检查均在连续集成环境中通过后，审核开始。 </p><p> If your team is woefully misguided and refuses to invest in continuous integration, automate these checks yourself. Add  git pre-commit hooks, linters, and formatters to your development environment to ensure that your code observes proper conventions and preserves intended behavior on each commit.</p><p>如果您的团队受到严重误导，并且拒绝投资进行持续集成，请自己进行自动化检查。向您的开发环境中添加git pre-commit钩子，短绒和格式化程序，以确保您的代码遵守正确的约定并在每次提交时保留预期的行为。</p><p>     The author helped me understand the function, but what about the next person who reads it? Should they dive into the change history and read every code review discussion ever? Worse is when the author comes over to my desk to give me an in-person explanation, which both interrupts my focus and ensures that nobody else ever has access to the information.</p><p>     作者帮助我理解了该功能，但是下一个阅读它的人呢？他们是否应该深入研究变更历史并曾经阅读过每个代码审查讨论？更糟糕的是，当作者来到我的办公桌前给我当面解释时，这既打断了我的注意力，又确保了其他任何人都无法访问该信息。</p><p> When your reviewer expresses confusion about how the code works, the solution isn’t to explain it to that one person. You need to explain it to  everyone.</p><p> 当您的审阅者对代码的工作方式感到困惑时，解决方案不是向那个人解释它。您需要向所有人解释。</p><p>   The best way to answer someone’s question is to refactor the code and eliminate the confusion. Can you rename things or restructure logic to make it more clear? Code comments are an acceptable solution, but they’re strictly inferior to code that documents itself naturally.</p><p>   回答某人问题的最好方法是重构代码并消除混乱。您可以重命名事物或重组逻辑以使其更清晰吗？代码注释是可以接受的解决方案，但绝对不如自然地编写文档的代码。</p><p>  Scope creep is a common anti-pattern in code reviews. A developer starts to fix a logic bug, but they notice a UI blemish in the process. “While I’m here,” they think, “I’ll just fix this other thing.” But now they’ve muddled things. Their reviewer has to figure out which changes serve goal A and which serve goal B.</p><p>  范围蠕变是代码审查中常见的反模式。开发人员开始修复逻辑错误，但他们在此过程中注意到UI缺陷。他们认为，“虽然我在这里，但我会解决其他问题。”但是现在他们把事情弄糊涂了。他们的审阅者必须弄清楚哪些更改服务于目标A，哪些更改服务于目标B。</p><p> The best changelists just  Do One Thing. The smaller and simpler the change, the easier it is for the reviewer to keep all the context in their head. Decoupling unrelated changes also allows you to parallelize your reviews across teammates, reducing turnaround time for your changes.</p><p> 最好的变更列表只是做一件事情。更改越小越简单，审阅者就越容易将所有上下文保持在头脑中。将不相关的更改脱钩，还可以使团队成员之间的审核并行化，从而减少更改的周转时间。</p><p>   Developers inexperienced with code reviews often violate this rule. They’ll make a two-line change, and then their code editor automatically reformats the entire file. The developer either fails to recognize what they did or decides that the new formatting is better. They send out a two-line functional change buried in hundreds of lines of non-functional whitespace changes.</p><p>   没有代码审查经验的开发人员通常会违反此规则。他们将进行两行更改，然后他们的代码编辑器会自动重新格式化整个文件。开发人员要么无法识别他们做了什么，要么认为新的格式更好。他们发出两行功能更改，这些功能更改埋在数百行非功能空白更改中。 </p><p>   Jumbled changelists are a massive insult to your reviewer. Whitespace-only changes are easy to review. Two-line changes are easy to review. Two-line functional changes lost in a sea of whitespace changes are tedious and maddening.</p><p>混乱的变更列表是对您的审阅者的极大侮辱。仅空白的更改很容易查看。两行更改很容易查看。在空白空间的海洋中丢失的两行功能变化既乏味又令人发疯。</p><p> Developers also tend to mix changes inappropriately while refactoring. I love it when my teammates refactor code, but I hate it when they refactor while changing the code’s behavior.</p><p> 开发人员在重构时也倾向于不适当地混合更改。当队友重构代码时，我喜欢它，但是当他们在更改代码行为时重构时，我讨厌它。</p><p>   If a piece of code requires refactoring  and behavioral changes, it should happen in two to three changelists:</p><p>   如果一段代码需要重构和行为更改，则应在两到三个更改列表中进行：</p><p>  By leaving the automated tests untouched in step 2, you prove to your reviewer that your refactoring preserves behavior. When you reach step 3, your reviewer doesn’t have to untangle the behavioral changes from the refactoring changes, as you’ve decoupled them ahead of time.</p><p>  通过使步骤2中的自动化测试保持不变，您可以向审阅者证明重构可以保留行为。当您到达第3步时，您的审核者就不必从重构更改中解脱出行为更改，因为您已经提前将它们分离了。</p><p>  Overly large changelists are the ugly cousins of  scope creep. Suppose a developer finds that in order to introduce feature X, they must modify semantics of existing libraries A and B. If it’s a small set of changes, that’s fine, but too many of these sprawling modifications can make the changelist enormous.</p><p>  太大的变更列表是范围蠕变的丑陋表亲。假设开发人员发现为了引入功能X，他们必须修改现有库A和B的语义。如果这是一小组更改，那很好，但是太多的此类修改会使更改列表变得巨大。</p><p> A changelist’s complexity grows exponentially with the number of code lines it touches. When my changes exceed 400 lines of production code, I look for opportunities to break it up before requesting a review.</p><p> 变更列表的复杂度随着其接触的代码行数量呈指数增长。当我的更改超过400条生产代码时，我会寻找机会将其分解，然后再要求进行审查。</p><p> Instead of changing everything at once, can you change the dependencies first and add the new feature in a subsequent changelist? Can you keep the codebase in a sane state if you add half of the feature now and the other half in the next changelist?</p><p> 您可以先更改依赖关系，然后在后续的更改列表中添加新功能，而不是立即更改所有内容吗？如果现在添加功能的一半，并在下一个变更列表中添加另一项功能，是否可以使代码库保持健全状态？ </p><p> It’s tedious to break up your code to find a subset that makes a working, intelligible change, but it yields better feedback and puts less strain on your reviewer.</p><p>分解代码以找到可以进行有效且可理解的更改的子集很繁琐，但可以产生更好的反馈，并减轻了审阅者的负担。</p><p>  The fastest way to ruin a code review is to take feedback personally. This is challenging, as many developers take pride in their work and see it as an extension of themselves. If your reviewer tactlessly frames their feedback  as a personal attack, it’s even harder.</p><p>  破坏代码审查的最快方法是亲自获得反馈。这是具有挑战性的，因为许多开发人员对他们的工作感到自豪，并将其视为自己的扩展。如果您的审阅者巧妙地将他们的反馈视为人身攻击，那就更难了。</p><p> As the author,  you ultimately control your reaction to feedback. Treat your reviewer’s notes as an objective discussion about the code, not your personal worth as a human. Responding defensively will only make things worse.</p><p> 作为作者，您最终可以控制对反馈的反应。将审阅者的注释视为对准则的客观讨论，而不是作为人的个人价值。做出防守反应只会使事情变得更糟。</p><p> I try to interpret all notes as helpful lessons. When a reviewer catches an embarrassing bug in my code, my first instinct is to make excuses. Instead, I catch myself and praise my reviewer for their scrupulousness.</p><p> 我尝试将所有注释解释为有用的课程。当审阅者在我的代码中发现一个令人尴尬的错误时，我的本能是找借口。取而代之的是，我抓紧自己并赞扬我的审稿人的谨慎。</p><p>   Surprisingly, it’s a  good sign when your reviewer spots subtle flaws in your code. It indicates that you’re packaging your changelists well. Without all the obvious issues like bad formatting and confusing names, your reviewer can focus deeply on logic and design, yielding more valuable feedback.</p><p>   出乎意料的是，当您的审阅者发现代码中的细微缺陷时，这是一个好兆头。这表示您打包好了变更列表。由于没有格式错误和名称混乱等所有显而易见的问题，您的审阅者可以深入关注逻辑和设计，从而获得更有价值的反馈。</p><p>  From time to time, reviewers are flat out wrong. Just as you can accidentally write buggy code, your reviewer can misunderstand correct code.</p><p>  审核者有时会断然错误。正如您可能不小心编写错误的代码一样，您的审阅者也会误解正确的代码。</p><p> Many developers react to reviewer mistakes with defensiveness. They take it as an affront that someone would insult their code with criticisms that  aren’t even true.</p><p> 许多开发人员对审阅者的错误采取防御措施。他们以冒犯他人侮辱自己的代码为耻，这甚至是不正确的。 </p><p> Even when your reviewer is mistaken, that’s still a red flag. If they misread it, will others make the same mistake? Does the reader have to exercise an abnormal level of scrutiny to reassure themselves that a particular bug  isn’t there?</p><p>即使您的审稿人弄错了，那仍然是一个危险信号。如果他们误读了，别人也会犯同样的错误吗？读者是否必须进行异常级别的审查才能确保自己没有特定的错误？</p><p>   Look for ways to refactor the code, or add comments that make the code more  obviously correct. If the confusion stems from obscure language features, rewrite your code using mechanisms that are intelligible to non-experts.</p><p>   寻找重构代码的方法，或添加使代码更明显正确的注释。如果混淆是由模糊的语言功能引起的，请使用非专家可理解的机制来重写代码。</p><p>  I frequently run into a scenario where I give someone notes, they update their code to address  some of my feedback, but they don’t write any replies. Now, we’re in an ambiguous state. Did they miss my other notes, or are they still working? If I begin a new round of review, I’m potentially wasting my time on a half-finished changelist. If I wait, I might create a deadlock where both of us are expecting the other to continue.</p><p>  我经常遇到这样的情况：我给别人做笔记，他们更新他们的代码以解决我的一些反馈，但是他们没有写任何答复。现在，我们处于模棱两可的状态。他们是否想念我的其他笔记，或者他们还在工作？如果我开始新一轮的审核，则可能会浪费时间在未完成的变更列表上。如果我等待，我可能会造成一个僵局，我们俩都希望对方继续下去。</p><p> Establish conventions on your team that make it clear who’s “holding the baton” at any point. Either the author is working on edits, or the reviewer is writing feedback. There should never be a situation where the process stalls because nobody knows who’s doing what. You can accomplish this easily with changelist-level comments that indicate when you’re handing control back and forth.</p><p> 在您的团队中建立约定，以便随时清楚谁在“握着警棍”。作者正在进行编辑，或者审阅者正在撰写反馈。永远都不会因没有人知道谁在做什么而导致程序停顿的情况。您可以通过更改列表级别的注释来轻松完成此操作，这些注释指示何时来回传递控件。</p><p>   For every note that requires action, respond explicitly to confirm that you’ve addressed it. Some code review tools allow you to mark comments as resolved. Otherwise, follow a simple convention, like, “Done,” for each note. If you disagree with the note, politely explain why you declined to take action.</p><p>   对于需要采取措施的每个便笺，请明确回答以确认您已解决。一些代码查看工具可让您将注释标记为已解决。否则，请为每个音符遵循一个简单的约定，例如“完成”。如果您不同意该说明，请有礼貌地说明您为什么拒绝采取行动。</p><p>   Adjust your response based on your reviewer’s effort. If they write a detailed note to help you learn something new, don’t just mark it done. Respond thoughtfully to show gratitude for their effort.</p><p>   根据您的评论者的努力调整您的回复。如果他们写了详细的说明以帮助您学习新知识，则不要仅将其标记为已完成。若有所思地回应，以感谢他们的努力。</p><p>  Sometimes code review notes leave too much room for interpretation. When you receive a comment like, “This function is confusing,” you probably wonder what “confusing” means, exactly. Is the function too long? Is the name unclear? Does it require more documentation?</p><p>  有时，代码复习笔记为解释留下了太多的空间。当您收到诸如“此功能令人困惑”之类的评论时，您可能想知道“令人困惑”的含义是什么。该功能是否太长？名字不清楚吗？是否需要更多文档？ </p><p> For a long time, I struggled to clarify ambiguous notes without sounding defensive. My instinct was to ask, “What’s confusing about it?” but that comes across as grouchy.</p><p>长期以来，我一直在努力澄清含混不清的音符，但听起来并不具有防御性。我的直觉是问：“这有什么令人困惑的地方？”但这听起来很gr脚。</p><p> Once, I unintentionally sent a vague note to my teammate, and he responded in a way that I found fantastically disarming:</p><p> 一次，我无意间给队友发了一张模糊的纸条，他以一种令人惊奇的方式解除了武装：</p><p>  I love this response because it signals a lack of defensiveness and openness to criticism. Whenever a reviewer gives me unclear feedback, I always respond with some variation of, “What would be helpful?”</p><p>  我喜欢这种回应，因为这表明缺乏防御和公开批评。每当审阅者给我不清楚的反馈意见时，我总是会做出一些“有帮助吗？”的变化。</p><p> Another useful technique is to guess your reviewer’s intent and proactively edit your code based on that assumption. For a note like, “this is confusing,” give your code a second look. Usually, there’s  something you can do to improve clarity. A revision communicates to your reviewer that you’re amenable to change, even if it’s not the one they had in mind.</p><p> 另一种有用的技术是猜测您的审阅者的意图，并根据该假设主动编辑您的代码。对于“这很令人困惑”之类的注释，请重新看一下您的代码。通常，您可以采取一些措施来提高清晰度。修订版本会通知您的审核者，您可以更改，即使不是他们所考虑的版本。</p><p>  In tennis, when you’re unsure if your opponent’s serve landed out of bounds, you give them the benefit of the doubt. There should be a similar expectation for code reviews.</p><p>  在网球比赛中，如果不确定对手的发球范围是否超出范围，则可以给他们带来疑问的好处。对代码审查应该有类似的期望。</p><p>   Some decisions about code are a matter of personal taste. If your reviewer thinks your 8-line function would be better as two 5-line functions, neither of you is objectively “right.” It’s a matter of opinion which version is better.</p><p>   有关代码的某些决定取决于个人喜好。如果您的审稿人认为您的8行功能会比两个5行功能更好，那么您俩都不是客观上的“正确”。哪个版本更好是一个问题。</p><p> When your reviewer makes a suggestion, and you each have roughly equal evidence to support your position, defer to your reviewer. Between the two of you, they have a better perspective on what it’s like to read this code fresh.</p><p> 当您的审稿人提出建议时，并且每个人都有大致相等的证据来支持您的立场，请交给您的审稿人。在你们两个之间，他们对于重新阅读此代码有什么更好的了解。 </p><p>  A few months ago, a user contributed a small change to an open-source project I maintain. I gave them feedback within hours, but they promptly disappeared. I checked again a few days later, and there was still no response.</p><p>几个月前，一个用户为我维护的一个开源项目做出了很小的改变。我在几个小时内给了他们反馈，但是他们很快就消失了。几天后，我再次检查，但仍然没有任何回应。</p><p> Six weeks later, the mysterious developer reappeared to submit their revisions. While I appreciated their effort, the lag between rounds of review had doubled my workload. Not only did I have to re-read their code, but I also had to re-read my feedback to restore my memory of the discussion. Had they followed up within a day or two, I wouldn’t have had to do all that extra work.</p><p> 六个星期后，这位神秘的开发人员再次出现并提交了他们的修订版。当我赞赏他们的努力时，两轮审阅之间的间隔使我的工作量增加了一倍。我不仅必须重新阅读他们的代码，而且还必须重新阅读我的反馈以恢复对讨论的记忆。如果他们在一两天内跟进，我就不必做所有这些额外的工作。</p><p>  A six-week pause is extreme, but I frequently see long, unnecessary delays among teammates. Someone sends out a changelist for review, receives feedback, then puts it on the back burner for a week because another task distracted them.</p><p>  六周的停顿是极端的，但我经常看到队友之间漫长而不必要的延迟。有人发出变更列表以供审核，接收反馈，然后将其放回一个星期，因为另一个任务分散了他们的注意力。</p><p> In addition to the time lost in restoring context, half-finished changelists increase complexity. They make it harder for everyone to keep track of what’s already merged and what’s in-flight. With more partially-complete changelists, there are more merge conflicts, and nobody likes fixing those.</p><p> 除了在还原上下文中浪费时间之外，半成品变更列表还会增加复杂性。它们使每个人都很难跟踪已经合并的内容和正在运行的内容。有了部分完成的变更列表，合并冲突就会更多，没有人会喜欢解决这些冲突。</p><p> Once you send your code out, driving the review to completion should be your highest priority. Delays on your end waste time for your reviewer and increase complexity for your whole team.</p><p> 发出代码后，将审查推进为最高优先级。延迟最终审阅时间会浪费您的审阅者，并增加整个团队的复杂性。</p><p>  As you prepare your next changelist for review, consider the factors you control, and use them to guide the review productively. As you participate in reviews, look for patterns that stall progress or waste effort.</p><p>  在准备下一个变更列表进行审核时，请考虑您控制的因素，并用它们有效地指导审核。当您参与评论时，请寻找阻碍进度或浪费精力的模式。</p><p> Remember the golden rule: value your reviewer’s time. A reviewer generates high-quality feedback when you allow them to focus on the interesting parts of your code. If you require them to untangle your code or police simple mistakes, you both suffer.</p><p> 记住黄金法则：珍惜评论者的时间。当您允许审阅者专注于代码的有趣部分时，审阅者会生成高质量的反馈。如果您要求他们解开您的代码或警告简单的错误，那么你们俩都会受苦。 </p><p> Lastly, communicate thoughtfully. It’s frighteningly easy for simple miscommunications or thoughtless comments to derail a review. Emotions run hot when critiquing someone else’s work, so be conscious of pitfalls that could make your reviewer feel attacked or disrespected.</p><p>最后，进行周到的沟通。简单的误解或粗心的评论容易使评论脱节。在批评别人的作品时，情绪高涨，所以要注意陷阱，这可能会使您的审稿人感到受攻击或不尊重。</p><p> Congratulations! If you’ve reached this point, you’re now an expert reviewee. Your reviewer is likely in love with you, so treat them well.</p><p> 恭喜你！如果您已达到这一点，那么您现在是专家审阅者。评论者可能会爱上您，因此请善待他们。</p><p> Over the past three years, I&#39;ve written 17 posts that reached the front page of Hacker News, with five of them reaching the #1 spot. Over the same period, many of my posts absolutely flopped and went nowhere.</p><p> 在过去的三年中，我撰写了17篇帖子，这些帖子到达了Hacker News的首页，其中有五篇达到了第一名。在同一时期，我的许多帖子绝对失败了，无所作为。</p><p>  Now, I&#39;m sharing lessons from years of success and failure in blogging to teach you how to choose topics, write articles, and iterate on your results to gain traction with technically sophisticated audiences on Hacker News, reddit, and Twitter.</p><p>  现在，我将分享在博客方面的成功与失败所带来的教训，以教会您如何选择主题，撰写文章以及对结果进行迭代，从而在Hacker News，reddit和Twitter上吸引技术精湛的受众。</p><p>  Learn more</p><p>  学到更多</p><p>  How to do Code Reviews Like a Human: Now that you’ve learned effective practices from the author side, learn to improve your code reviews when you’re the reviewer.</p><p>  如何像人一样进行代码审查：既然您已经从作者那边学到了有效的做法，那么当您成为审查者时，要学会改进代码审查。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://mtlynch.io/code-review-love/">https://mtlynch.io/code-review-love/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/reviewer/">#reviewer</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1037992.html"><img src="http://img2.diglog.com/img/2020/12/thumb_a0007978221fe230a02adbf9307293b0.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037992.html">Sourcegraph的通用代码搜索服务已由Amazon和PayPal等公司使用，在3月份进行了2300万美元的B轮融资后，C筹集了5000万美元 </a></div><span class="my_story_list_date">2020-12-6 9:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037955.html"><img src="http://img2.diglog.com/img/2020/12/thumb_f270635e9216e255b031339ed6071ff8.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037955.html">DRY是一支步枪，记住YAGNI </a></div><span class="my_story_list_date">2020-12-6 3:53</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037842.html"><img src="http://img2.diglog.com/img/2020/12/thumb_5a89a3ead3d78942ec6f0558acd0a675.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037842.html">Moov Financial开发了一个开放源代码平台，用于在应用程序中添加银行业务和支付功能，并获得由a16z领投的2700万美元A轮融资 </a></div><span class="my_story_list_date">2020-12-5 8:6</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037765.html"><img src="http://img2.diglog.com/img/2020/12/thumb_e64f82a14c0471c89d7870c1f40bc2a8.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037765.html">代码覆盖率神话 </a></div><span class="my_story_list_date">2020-12-5 3:16</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>