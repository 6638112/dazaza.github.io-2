<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们如何在Kotlin协程中测试并发基元 How We Test Concurrent Primitives in Kotlin Coroutines</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How We Test Concurrent Primitives in Kotlin Coroutines<br/>我们如何在Kotlin协程中测试并发基元 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-26 10:18:54</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/72fe2387ca31a2e5c578b720ebeb5caa.png"><img src="http://img2.diglog.com/img/2021/2/72fe2387ca31a2e5c578b720ebeb5caa.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Many of our users are delighted with the experience of using coroutines to write asynchronous code. This does not come as a surprise, since with coroutines we are able to write straightforward and readable code, with almost all the asynchronicity happening under the hood. For simplicity, we can think of coroutines in Kotlin as super-lightweight threads with some additional power, such as cancellability and structured concurrency. However, coroutines also make the code much safer. Traditional concurrent programming involves manipulating a shared mutable state, which is arguably error-prone. As an alternative, coroutines provide special communicating primitives, such as  Channel, to perform the synchronization. Using channels and a couple of other primitives as building blocks, we can construct extremely powerful things, such as the recently introduced  Flows. However, nothing is free. While the message passing approach is typically safer, the required primitives are not trivial to implement and, therefore, have to be tested as thoroughly as possible. Simultaneously, testing concurrent code may be as complicated as writing it.</p><p>我们的许多用户对使用协程编写异步代码的经验感到高兴。这不足为奇，因为使用协程，我们能够编写简单易懂的代码，而几乎所有异步都在后台进行。为简单起见，我们可以将Kotlin中的协程视为具有某些附加功能的超轻量级线程，例如可取消性和结构化并发。但是，协程也使代码更安全。传统的并发编程涉及操纵一个共享的可变状态，这可以说是容易出错的。作为替代，协程可以提供特殊的通信原语（例如Channel）来执行同步。使用渠道和其他几个原语作为构建块，我们可以构建功能非常强大的东西，例如最近推出的Flows。但是，没有什么是免费的。尽管消息传递方法通常更安全，但是实现所需的原语并不是一件容易的事，因此必须尽可能全面地对其进行测试。同时，测试并发代码可能和编写它一样复杂。</p><p> That is why we have Lincheck – a special framework for testing concurrent data structures on the JVM. This framework’s main advantage is that it provides a simple and declarative way to write concurrent tests. Instead of describing how to perform the test, you specify  what to test by declaring all the operations to examine along with the required correctness property (linearizability is the default one, but various extensions are supported as well) and restrictions (e.g. “single-consumer” for queues).</p><p> 这就是为什么我们拥有Lincheck –一种用于在JVM上测试并发数据结构的特殊框架。该框架的主要优点在于，它提供了一种简单且声明性的方式来编写并发测试。您无需声明如何执行测试，而是通过声明所有要检查的操作以及所需的正确性属性（线性化是默认值，但也支持各种扩展）和限制（例如“单用户”）来指定要测试的内容”）。</p><p>  Let’s consider a simple concurrent data structure, such as the stack algorithm presented below. In addition to the standard  push(value) and  pop() operations, we also implement a non-linearizable (thus, incorrect)  size(), which increases and decreases the corresponding field following successful push and pop invocations.</p><p>  让我们考虑一个简单的并发数据结构，例如下面介绍的堆栈算法。除了标准的push（value）和pop（）操作之外，我们还实现了不可线性化（因此是不正确的）size（），它在成功执行push和pop调用后增加和减少了相应的字段。</p><p> class Stack&lt;T&gt; { private val top = atomic&lt;Node&lt;T&gt;?&gt;(null) private val _size = atomic(0) fun push(value: T): Unit = top.loop { cur -&gt; val newTop = Node(cur, value) if (top.compareAndSet(cur, newTop)) { // try to add _size.incrementAndGet() // &lt;-- INCREMENT SIZE return } } fun pop(): T? = top.loop { cur -&gt; if (cur == null) return null // is stack empty? if (top.compareAndSet(cur, cur.next)) { // try to retrieve _size.decrementAndGet() // &lt;-- DECREMENT SIZE return cur.value } } val size: Int get() = _size.value}class Node&lt;T&gt;(val next: Node&lt;T&gt;?, val value: T)</p><p> 类Stack＆lt; T＆gt; { 私有val top =原子＆lt; Node＆lt; T＆gt;？＆gt;（null） 私有val _size =原子（0） fun push（value：T）：Unit = top.loop {cur-＆gt; val newTop =节点（cur，value） if（top.compareAndSet（cur，newTop））{//尝试添加 _size.incrementAndGet（）//＆lt;-增量大小 返回 } } 有趣的pop（）：是吗？ = top.loop {cur-＆gt; if（cur == null）返回null //堆栈为空吗？ if（top.compareAndSet（cur，cur.next））{//尝试检索 _size.decrementAndGet（）//＆lt;-DECREMENT SIZE 返回当前值 } } val大小：Int get（）= _size.value}类Node＆lt; T＆gt;（val下一个：Node＆lt; T＆gt;？，val值：T）</p><p> To write a concurrent test for this stack without any tool, you have to manually run parallel threads, invoke the stack operations, and finally check that some sequential history can explain the obtained results. We have used such manual tests in the past, and all of them contained at least a hundred lines of boilerplate code. But with Lincheck, this machinery is automated, and tests become short and informative.</p><p> 要在没有任何工具的情况下为此堆栈编写并发测试，您必须手动运行并行线程，调用堆栈操作，最后检查一些顺序历史记录可以解释所获得的结果。过去我们使用过这种手动测试，并且所有这些测试至少包含一百行样板代码。但是使用Lincheck，该机器是自动化的，并且测试变得简短而有用。</p><p> To write a concurrent test with Lincheck, you need to list the data structure operations and mark them with a special  @Operation annotation. The initial state is specified in the constructor (here, we create a new  TriebeStack&lt;Int&gt; instance). After that, we need to configure the testing modes, which can be done using special annotations on the test class –  @StressCTest for stress testing and  @ModelCheckingCTest for model checking mode. Finally, we can run the analysis by invoking the  Linchecker.check(..) function on the testing class.</p><p> 要使用Lincheck编写并发测试，您需要列出数据结构操作，并使用特殊的@Operation批注对其进行标记。初始状态在构造函数中指定（在此，我们创建一个新的TriebeStack＆lt; Int＆gt;实例）。之后，我们需要配置测试模式，可以使用测试类上的特殊注释来完成测试– @StressCTest用于压力测试，@ModelCheckingCTest用于模型检查模式。最后，我们可以通过在测试类上调用Linchecker.check（..）函数来运行分析。</p><p>  @StressCTest@ModelCheckingCTestclass StackTest { private val s = TrieberStack&lt;Int&gt;() @Operation fun push(value: Int) = s.push(value) @Operation fun pop() = s.pop() @Operation fun size() = s.size @Test fun runTest() = LinChecker.check(this::class)}</p><p>  @StressCTest@ModelCheckingCTest类StackTest { 私有值s = TrieberStack＆lt; Int＆gt;（） @Operation fun push（值：整数）= s.push（值） @Operation fun pop（）= s.pop（） @Operation fun size（）= s.size @Test fun runTest（）= LinChecker.check（this :: class）} </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.jetbrains.com/kotlin/2021/02/how-we-test-concurrent-primitives-in-kotlin-coroutines/">https://blog.jetbrains.com/kotlin/2021/02/how-we-test-concurrent-primitives-in-kotlin-coroutines/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>