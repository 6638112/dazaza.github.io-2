<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>定义新的HTTP方法：HTTP搜索 Defining a new HTTP method: HTTP SEARCH</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Defining a new HTTP method: HTTP SEARCH<br/>定义新的HTTP方法：HTTP搜索 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-17 07:09:20</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/993f84db1dfa54cd8f8bf6e88f46b003.jpg"><img src="http://img2.diglog.com/img/2021/4/993f84db1dfa54cd8f8bf6e88f46b003.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>HTTP SEARCH is a new HTTP method, for safe requests that include a request body. It&#39;s still early &amp; evolving, but it was recently adopted as an IETF draft standard, and it&#39;s going to add some great new tools for HTTP development everywhere.</p><p>HTTP搜索是一种新的HTTP方法，用于包括请求正文的安全请求。它仍然早期＆＃39;不断发展，但它最近被作为IETF草案标准，它将在任何地方添加一些伟大的新工具。</p><p> What does that mean, why do we need a new HTTP method, how would HTTP SEARCH work?</p><p> 这是什么意思，为什么我们需要一个新的HTTP方法，如何如何重新搜索工作？</p><p>   To understand how each one works, it&#39;s important to remember that HTTP is defined in terms of resources. A resource might be a document, or a photo, or a specific customer, or the whole list of customers, and it&#39;s identified by a URL like  example.com/customers (all customers of example.com) or  example.com/customers/123 (one specific customer).</p><p>   要了解每个人的工作，它是如何记住在资源方面定义的HTTP的重要性。资源可能是文档或照片或特定客户或整个客户列表，它由URL识别的URL（例如example.com）或示例的所有客户身份标识。 COM /客户/ 123（一个特定的客户）。</p><p>  A GET request asks the server for a resource. This is frequently used to request HTML pages, read data from an API, or load images.</p><p>  GET请求询问服务器进行资源。这通常用于请求HTML页面，从API读取数据或加载图像。</p><p> These are intended to be &#39;safe&#39; requests, which purely read data. They shouldn&#39;t change the state of the server, they shouldn&#39;t have side effects, and so they can be cached in many cases (which means that many client GET responses will come from a cache, and never hit the real server).</p><p> 这些旨在是＆＃39;安全＆＃39;请求，纯粹读取数据。他们应该改变服务器的状态，他们应该有副作用，所以它们可以在许多情况下缓存（这意味着许多客户端获取响应将来自缓存，而且永远不会击中真实的服务器）。</p><p> GET requests can be parameterized by their URL, which might contain a path and/or query parameters, but they can&#39;t have a request body. It&#39;s not specifically banned, but it is defined as being completely meaningless, and many existing implementations will ignore the body or reject the request entirely if you try to send one.</p><p> 获取请求可以由其URL参数化，可能包含路径和/或查询参数，但它们可以＆＃39; t有一个请求身体。它没有特别禁止它，但它被定义为完全毫无意义，并且许多现有的实现将忽略身体或完全拒绝请求，如果您尝试发送一个。</p><p> They can also use Accept, Accept-Language and Accept-Encoding headers to request a specific content type, language or encoding (&#39;give me customer 123 as XML please&#39;), and use Range headers to request only part of a document (&#39;give me the first 100 bytes of video 24 please&#39;).</p><p> 它们还可以使用接受，接受语言和接受编码标题来请求特定的内容类型，语言或编码（＆＃39;给我客户123作为XML，请＆＃39;），并使用范围标题仅要求部分文件（＆＃39;给我前100个字节的视频24＆＃39;）。 </p><p>  A POST request sends data to a resource on the server, and asks the server to process that data. This is a very generic &#34;do something&#34; request, often used to post messages, create new resources (e.g. a new customer) or trigger processing of some input.</p><p>POST请求将数据发送到服务器上的资源，并询问服务器处理该数据。这是一个非常通用的＆＃34;做点什么＆＃34;请求通常用于发布消息，创建新的资源（例如新客户）或触发某些输入的触发处理。</p><p> Just like GET requests they can be parameterized by URL and various headers, but they can also include a request body: the data that the server should process. To help the server process this, the request can also have a Content-Type header, specifying the type of data in the body (e.g.  application/json).</p><p> 就像get请求一样，它们可以由URL和各种标题参数化，但它们也可以包含请求正文：服务器应该处理的数据。为了帮助服务器处理此项，请求还可以具有内容类型标题，指定正文中的数据类型（例如，应用/ JSON）。</p><p> Of course, these aren&#39;t safe requests. They can change server state (by design) and may have side effects elsewhere too. Because of that, they&#39;re not cacheable in almost all cases. In fact they&#39;re anti-cacheable:  if a CDN or browser sees an outgoing POST request for a resource, it will invalidate and drop any existing cached data it has for that resource.</p><p> 当然，这些aren＆＃39; t安全请求。它们可以更改服务器状态（按设计），也可能在其他地方具有副作用。因为那个，他们在几乎所有情况下都没有缓存。事实上，他们＆＃39;重新缓存</p><p>  A PUT request sends data to a resource on the server, and asks the server to create or replace the resource using that data. This is more specific than POST: while POST is used for arbitrary actions, PUT is only used to create/update state to match the body of the request.</p><p>  PUT请求将数据发送到服务器上的资源，并询问服务器使用该数据创建或替换资源。这比帖子更具体：当POST用于任意操作时，PUT仅用于创建/更新状态以匹配请求的正文。</p><p> These are generally used in APIs as a way to specifically do create &amp; update actions on data (whilst POST might be used to trigger arbitrary actions against that data instead).</p><p> 这些通常在API中使用，作为特异性创造的一种方式。更新数据上的操作（虽然可能用于触发对该数据的任意操作）。</p><p> Just like POST, this will include a request body and may affect the server&#39;s state (so invalidates caching), but it  can&#39;t have side effects. Instead, PUT requests must be  idempotent. That means that if you successfully send the exact same PUT request twice, and nothing else happens, then everything should be in the same state as if you sent the request just once.</p><p> 就像帖子一样，这将包括请求身体，并可能影响服务器和＃39; s状态（所以使缓存无效），但它可以＆＃39; t有副作用。相反，请将请求必须是幂改量。这意味着如果您成功发送了两次完全相同的PUT请求，并且没有否则发生，那么一切都应该处于相同的状态，好像您只发送一次请求。</p><p> You can see the difference if you think about  POST /documents vs  PUT /documents. That POST request typically means &#39;create a new document&#39;, and every time you make the same request a new document will be created. The PUT request meanwhile must mean &#39;create or replace the entire document list with the given data&#39;. Assuming that&#39;s something the server allows, sending a request repeatedly will leave the documents in the same state as sending it just once.</p><p> 如果您考虑帖子/文档VS PUT / DEPORY，您可以看到差异。该POST请求通常意味着＆＃39;创建一个新的文档＆＃39;，每次制作相同的请求时都会创建一个新文档。 PUT请求同时必须意味着＆＃39;使用给定的数据创建或替换整个文档列表和＃39;假设服务器允许的东西，反复发送请求将使文档与同一状态留下作为发送一次。 </p><p>  A PATCH request sends data to a resource on the server, and asks the server to  partially update the resource using that data. This can be used to update a customer&#39;s address or to append to a text document.</p><p>修补程序请求将数据发送到服务器上的资源，并询问服务器使用该数据部分更新资源。这可用于更新客户＆＃39; s地址或附加到文本文档。</p><p> Like PUT &amp; POST, this will include a request body. They&#39;re not safe requests, and they&#39;re not idempotent either (appending the same thing to a document twice will change that document both times).</p><p> 像Put＆amp;帖子，这将包括请求身体。它们＆＃39;重复不安全的请求，它们＆＃39;重复不幂等待（两次向文档附加相同的事情将改变何时文档）。</p><p>  A DELETE request asks the server to delete the resource. This one&#39;s pretty self-explanatory I think.</p><p>  删除请求询问服务器删除资源。我认为这个＆＃39;我认为很自我解释。</p><p> One important note: like GET, DELETE requests cannot include a body. It doesn&#39;t make any sense to provide data when deleting data, and servers reserve the right to ignore or reject you completely if you do.</p><p> 一个重要说明：就像Get一样，删除请求不能包含一个正文。它不会在删除数据时提供数据，服务器保留忽略或拒绝如果您完全拒绝的权利。</p><p>   OPTIONS: request information about how to make other requests, mainly used for CORS in browsers</p><p>   选项：请求有关如何制作其他请求的信息，主要用于浏览器中的CORS</p><p>  TRACE: request an echo of your request, used to trace requests through proxies &amp; CDNs (very rarely used/supported)</p><p>  跟踪：请求您的请求的回声，用于跟踪通过代理＆amp的请求; CDNS（非常易于使用/支持）</p><p> All of these are great, but none of them matter right now, so let&#39;s ignore them.</p><p> 所有这些都很棒，但现在没有一个重要的是，所以让＆＃39;忽略它们。 </p><p>  So: GET gets data, POST performs arbitrary unsafe operations, PUT performs idempotent full updates, PATCH performs partial updates, and DELETE deletes. GET and DELETE aren&#39;t allowed a body, but all the others are.</p><p>所以：Get获取数据，POST执行任意不安全操作，PUT执行IDEMPOTENT全更新，修补程序执行部分更新，并删除删除。得到和删除aren＆＃39; t允许一个身体，但所有其他人都是。</p><p> The differences between these have important implications. Cacheability is critical in many large applications, request safety has important UX implications, and each of these helps communicate to API developers how your API works.</p><p> 这些具有重要意义之间的差异。可耻性在许多大型应用中都是至关重要的，请求安全具有重要的UX含义，并且每个都有助于对API开发人员进行通信您的API如何工作。</p><p> In practice, if you swap all your GET requests for POST requests tomorrow, it&#39;ll technically work, but only in the loosest possible sense. Responses will cease to be cacheable, so your CDN will give up entirely and your server will burst into flames as traffic increases 10,000%. Browsers will refuse to go back/forward in your page history or retry failed page loads without huge warnings (because that&#39;s unsafe, and might have side effects), and nobody else looking at your code or request will have any idea what the hell you&#39;re trying to do.</p><p> 在实践中，如果您明天将所有GET请求交换所有GET请求，它会在技术上工作，但只在可能的意义上。响应将停止可缓存，因此您的CDN将完全放弃，您的服务器将突发成火焰，因为流量增加了10,000％。浏览器将拒绝在页面历史记录或重试失败的页面加载中拒绝/转发，没有巨大的警告（因为它的不安全，并且可能具有副作用），没有其他人查看您的代码或请求将有任何想法到了你的地狱＆＃39;重新尝试。</p><p> These semantics help many of the tools and infrastructure we all use to understand what your HTTP requests mean. Using the right methods for the right things matters.</p><p> 这些语义有助于许多工具和基础架构我们都使用它来了解HTTP请求的意思。使用正确的方法来实现正确的事情。</p><p>   What if you want to do a complicated data retrieval, sending lots of data but not changing the server state?</p><p>   如果要做复杂的数据检索，请发送大量数据但未更改服务器状态怎么办？</p><p>  Use a GET, and squeeze all the parameters you need in the URL or headers somewhere</p><p>  使用Get，并挤压您在URL或标题中所需的所有参数</p><p>  URLs &amp; headers typically have arbitrary non-standard length limits, and create a terrible UX for large values. You have to encode special characters &amp; newlines, so the URL becomes completely unreadable, and you can&#39;t specify a content type for convenient parsing either. Because it&#39;s non-standard, few tools will make this easy for you too, so you&#39;re back to stringifying and concatenating queries all by yourself. You deserve better.</p><p>  URL＆amp;标题通常具有任意的非标准长度限制，并为大值创建可怕的UX。您必须编码特殊字符和amp;纽丁，所以URL变得完全不可读，你可以＆＃39; t指定一个内容类型，可以方便地解析。因为它＆＃39;没有标准，很少有工具将为您做出这么容易，所以你＆＃39;重新回到自己所有的询问和串联询问。你理应获得更好的。 </p><p> Meanwhile, caching is a big deal, and POST invalidates that completely. It&#39;s also fundamentally the wrong semantics: this request is not going to change any state, it&#39;s not going to have any side effects, and requiring all tools to treat it as if it will is problematic.</p><p>同时，缓存是一个很大的交易，并且完全发布了无效。它和＃39;它的根本基本上是错误的语义：这个请求不会改变任何州，它不会有任何副作用，并要求所有工具将其视为问题。</p><p> In addition, the kind of resources to which you might want to send a complex query are also the kind of resources to which you might want to POST data. If  POST /customers creates a new customer, how do I POST a query for customer data? It is possible, but using POST for multiple operations on the same resource quickly leads you down a long and hacky road to bad software.</p><p> 此外，您可能想要发送复杂查询的资源也是您可能想要发布数据的资源类型。如果帖子/客户创建新客户，如何为客户数据发布查询？有可能，但在同一资源上使用帖子，很快让您降低一个漫长而俗话的道路到坏软件。</p><p>    A SEARCH request is a request that&#39;s safe (does not change the target resource) that can include a body.</p><p>    搜索请求是＆＃39; s safe（不改变目标资源）的请求。</p><p> This helps because with SEARCH we can implement the above: we can send complex data queries clearly, without either encoding them in a URL or using a POST request.</p><p> 这有助于搜索我们可以实现上面的实施方式：我们可以清楚地发送复杂的数据查询，而无需在URL中编码它们或使用POST请求。</p><p> Note that this is still only a draft standard. The details will probably change, and even the name isn&#39;t 100% fixed yet (the draft is officially named &#34;safe method with body&#34;, rather than referencing SEARCH, to make that easy to change).</p><p> 请注意，这仍然只是标准草案。细节可能会改变，甚至名称是＆＃39; t 100％修复（草案是正式命名的＆＃34;安全方法与身体＆＃34;而不是参考搜索，使得易于改变）。</p><p> Take all this with a grain of salt, but as of March 2021 it&#39;s now an officially adopted IETF HTTP  draft specification, so it is on an official path towards eventual standardization, if all goes well.</p><p> 把这一切都用一粒盐，但截至3月2021日，它现在正式采用了IETF HTTP草案规范，因此如果一切顺利，它就在最终标准化的官方路径上。</p><p>   (No, you shouldn&#39;t let remote clients send you arbitrary SQL queries, but you get the idea)</p><p>   （不，你应该让远程客户端向您发送任意SQL查询，但您得到了想法） </p><p> Right now the spec does  not define the result of this query as cacheable. It&#39;s not completely clear why, but I suspect this is because caches today never take the body into account, and starting to do so would be a major change that needs some careful thought and consultation.</p><p>现在，规范没有将此查询的结果定义为可缓存。它并不完全清楚为什么，但我怀疑这是因为今天的高速缓存永远不会考虑到身体，并开始这样做是一个需要一些仔细思考和咨询的重大变化。</p><p> That said, it does avoid the cache invalidation of the equivalent POST requests. The above request as a POST would require every cache en route to drop any cached data it has for  /customers, forcing all that data to be reloaded. SEARCH does not, and that alone will be a big boost to many caching setups.</p><p> 也就是说，它确实避免了等效的POST请求的缓存失效。以上要求作为帖子需要每次缓存渠道删除它为/客户提供的任何缓存数据，强制要重新加载的所有数据。搜索没有，而且单独将是许多缓存设置的大升高。</p><p>  The request body is clearly readable and manageable - no special encoding or length limits involved</p><p>  请求主体明显可读且可管理 - 没有特殊的编码或长度限制</p><p>  You&#39;re now free to have separate semantics for GET, SEARCH &amp; POST on the same URL</p><p>  你现在可以自由地获得单独的语义，搜索和amp;在同一URL上发布</p><p>  You can use this to support complex querying in any language you like, from GraphQL to SQL to OData. Of course the server needs to understand whichever query language you&#39;re using, and you should indicate the format clearly in the Content-Type header of the request to make that possible.</p><p>  您可以使用它来支持您喜欢的任何语言的复杂查询，从GraphQL到SQL到OData。当然服务器需要了解您＆＃39的任何查询语言;重新使用，并且您应该在请求的内容类型标题中清楚地指示格式，以使可实现这一目标。</p><p> This is especially interesting for GraphQL. GraphQL currently falls perfectly into the above trap, supporting both GET requests or POST requests, but with awkward caveats in either case. Moving to SEARCH for read-only GraphQL requests would improve the UX significantly, and could allow GraphQL to better integrate with built-in HTTP features like caching in future.</p><p> 这对GraphQL特别有趣。 GraphQL目前将完全陷入上述陷阱，支持GET请求或发布请求，但在任何一种情况下都有尴尬的警告。搬到搜索只读GraphQL请求将显着提高UX，并且可以允许GraphQL更好地与将来缓存的内置HTTP功能集成。</p><p> Query languages like this are the most obvious use case, but you can go well beyond that too: this supports anything that sends a body to request data from the server without side effects.</p><p> 像这样的查询语言是最明显的用例，但您也可以超越它：这支持任何发送身体的任何东西，以便在没有副作用的情况下从服务器请求数据。 </p><p> RPC-style APIs using HTTP or other APIs that don&#39;t really &#39;query&#39; data as such will get value from this being supported too (although this does stretch the currently defined semantics a bit). For example, an API to which you can send data and have the server encrypt it and return it to you. This doesn&#39;t change anything on the server, so POST isn&#39;t appropriate, and GET has the same limitations as above.</p><p>rpc-style apis使用htth或其他apis don＆＃39; t真实＆＃39;查询＆＃39;数据的数据也会从此受支持（尽管这确实会延长当前定义的语义）。例如，您可以发送数据并将服务器加密的API并将其返回给您。这并不是改变服务器上的任何东西，所以Post ISN＆＃39; T适当，并获得与上述相同的限制。</p><p> You could even use this to support things like a dry-run API for POST requests (don&#39;t change anything yet, but tell me what would happen if I did POST this data). There&#39;s a long list of possibilities!</p><p> 您甚至可以使用此方法来支持与发布请求的干运行API（Don＆＃39; T更改任何内容，但请告诉我如果我发布此数据会发生什么）。有很长的可能性列表！</p><p>  In addition to SEARCH, the specification also defines an Accept-Search header. That can be used in responses like so:</p><p>  除搜索外，规范还定义了接受搜索标题。可以在响应中使用，如此：</p><p>  This allows a server to advertise that it accepts SEARCH requests, and signal the specific format(s) of query that it will accept. This is similar to the existing  Accept-Patch header.</p><p>  这允许服务器通告它接受搜索请求，并通过它将接受的查询的特定格式发出特定格式。这类似于现有的接受贴片标题。</p><p> The server could include this in any responses, but it&#39;s particularly useful in responses to OPTIONS requests, where the client queries a resource to ask what functionality is supported.</p><p> 服务器可以在任何响应中包括它，但它＆＃39; s响应对选项请求的响应特别有用，客户端查询资源以询问支持哪些功能。</p><p>  This is the start of a great proposal imo, but there are things you need to be aware of, which create some gotchas and possible improvements in the spec as it stands today.</p><p>  这是一个伟大的提案IMO的开始，但您需要了解它的事情，这在今天展台时创建了一些Gotchas和可能的改进。</p><p>  This standard is based on the  SEARCH method from WebDAV (an HTTP extension designed for document authoring &amp; versioning on the web).</p><p>  本标准基于WebDAV的搜索方法（为文档创作＆amp设计的HTTP扩展;在Web上版本控制）。 </p><p>  Because a similar method has existed in the past, it does mean that many existing tools including   HTTP Toolkit itself and infrastructure like proxies &amp; CDNs will already support this, and could accept SEARCH requests immediately without any hassle.</p><p>因为过去存在类似的方法，所以它确实意味着许多现有工具包括HTTP工具包本身和基础设施，如代理＆amp; CDN已经支持这一点，可以立即接受搜索请求而没有任何麻烦。</p><p> On the other hand, adding SEARCH to HTTP itself without breaking WebDAV requires some thought around compatibility. The current workaround for this in the spec is that any request with an  application/xml or  text/xml content-type header must follow the specific format rules defined in the WebDAV spec for its query body.</p><p> 另一方面，在不破坏WebDAV的情况下添加到HTTP本身的搜索需要兼容性的一些思想。目前的解决方法在规范中是应用程序/ XML或Text / XML Content-Type标题的任何请求都必须遵循其查询正文中的WebDAV规范中定义的特定格式规则。</p><p> Anything else would not be a valid WebDAV request, so can freely ignore that, but this does create a real problem for SEARCH in XML APIs. It&#39;s likely that in future the spec will be relaxed to apply this requirement only to XML within WebDAV&#39;s XML namespaces, but that&#39;s not yet formally specified.</p><p> 其他任何其他都不会是有效的WebDAV请求，因此可以自由地忽略这一点，但这确实为在XML API中搜索了一个真正的问题。它可能在将来的情况下，将放宽规范，仅在WebDAV和＃39; s XML命名空间内应用此要求，但尚未正式指定。</p><p>  While not invalidating caches is a good start, the results of a SEARCH aren&#39;t actually cacheable themselves. That doesn&#39;t just mean they&#39;re not cacheable by default: even with explicit cache headers, they are not cacheable.</p><p>  虽然没有失效的缓存是一个很好的开端，搜索结果＆＃39; t实际上很宽松。这不仅意味着它们＆＃39;默认情况下没有可缓存：即使使用显式缓存标头，它们也不可缓存。</p><p> This is unfortunate because it&#39;s a clear limitation when compared with GET, and caching query results is a super common use case.</p><p> 这是不幸的，因为它＆＃39;与Get相比，并缓存查询结果是一个超级常用用例。</p><p> There&#39;s ongoing work here to specify exactly under what conditions SEARCH could become cacheable, which would unlock a lot more benefit from this standard. I think the likely result is that it won&#39;t be cacheable by default, but will be cacheable given the appropriate headers, but again that&#39;s not yet specified, so let&#39;s wait &amp; see.</p><p> 在这里，在这里持续的工作是在搜索可能变得可缓存的情况下准确指定，这将从本标准解锁更多的利益。我认为可能的结果是它默认赢得＆＃39; t默认是可缓存的，但是给予适当的标题，但再次录制＆＃39;尚未指定，所以让＆＃39;等待＆＃39;看。</p><p>  SEARCH isn&#39;t a great name. Not every query is a search, and there&#39;s a wide variety of other uses for &#34;safe method with a body&#34; that go entirely beyond simple querying of a data set, as discussed above.</p><p>  搜索不是一个伟大的名字。并非每一个查询都是搜索，而且有各种各样的其他用途为＆＃34;安全方法，身体＆＃34;如上所述，完全超出简单查询数据集。 </p><p> This has been recognized and it&#39;s being debated, and there are other proposals (like QUERY or FETCH). SEARCH does have some compatibility benefits due to its existing usage in WebDAV though, so there&#39;s a challenging balance to be made.</p><p>这已被识别出来，它被争论，并且还有其他提案（如查询或获取）。搜索确实具有一些兼容性优势，因为它在WebDAV中的现有用途，所以有一个挑战性的平衡。</p><p> Changing the name would slow down adoption in all existing software, but might make the method clearer for developers to understand and use. There&#39;s no easy answer here unfortunately.</p><p> 更改名称将减缓所有现有软件中的采用，但可能使方法更清晰地了解和使用。 ＆＃39;不幸的是，这里没有容易答案。</p><p>  Personally, I think SEARCH would be valuable in itself already, despite these caveats, and there are good options available here to quickly improve the standard further.</p><p>  就个人而言，尽管有这些警告，但我认为搜索本身就是有价值的，并且这里有很好的选择可以进一步迅速改善标准。</p><p> If you&#39;d like to dig into the details further, the current specification is available  from the IETF website, and you can get involved by  joining the IETF HTTP Working Group mailing list or opening issues/PRs directly via the  http-extensions GitHub repo (an umbrella repo for this spec plus a few other prospective HTTP additions). Share your thoughts and help shape the HTTP of the future!</p><p> 如果您＆＃39; d进一步挖掘详细信息，可以通过IETF网站获得当前规范，您可以通过HTTP-Extensions Github连接IETF HTTP工作组邮件列表或打开问题/ PRS来获取。 repo（此规范的伞仓库加上其他一些潜在的HTTP添加）。分享您的想法并帮助塑造未来的HTTP！</p><p> If you have any other questions, or is there anything I&#39;ve missed? Feel free to  get in touch on Twitter, I&#39;d love to hear about it.</p><p> 如果您还有其他问题，或者有任何＆＃39;遗漏了吗？随意取得联系，我喜欢听到它。</p><p> Do you work with HTTP?   Download HTTP Toolkit now to inspect &amp; mock HTTP from browsers, servers, apps and anywhere else in one click.</p><p> 你用http工作吗？立即下载HTTP Toolkit签署＆amp;从浏览器，服务器，应用程序和其他任何地方进行Mock http。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://httptoolkit.tech/blog/http-search-method/">https://httptoolkit.tech/blog/http-search-method/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/http/">#http</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/请求/">#请求</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>