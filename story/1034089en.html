<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>铁锈为何是游戏开发的未来</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">铁锈为何是游戏开发的未来</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-10 01:58:19</div><div class="page_narrow text-break page_content"><p>Rust, not related to the video game also called Rust, is a promising systems programming language with novel features ideally suited for game development. Exposure and awareness within the game developer community, however, remains limited. In this post, I provide a gentle introduction to Rust and attempt to justify its place on your radar.</p><p>Rust与视频游戏(也称为Rust)无关，是一种很有前途的系统编程语言，具有新颖的功能，非常适合游戏开发。然而，游戏开发者社区内的曝光率和认知度仍然有限。在这篇文章中，我对铁锈做了一个温和的介绍，并试图证明它在你的雷达上的地位是正确的。</p><p>  What is Rust, and where did it come from? In  this fantastic talk, James Munns gives us a detailed oral history. Way back around 2010, Mozilla was frustrated by the state of development in Firefox, a massive software project written mostly in C++. Despite best practices and an abundance of engineering talent, writing high-performance, parallelised, and memory-safe code, at that scale of complexity, remained fraught and error-prone.</p><p>什么是铁锈？它是从哪里来的？在这个精彩的演讲中，詹姆斯·芒斯为我们讲述了一段详细的口述历史。早在2010年左右，Mozilla就对Firefox的开发现状感到沮丧，Firefox是一个主要用C++编写的大型软件项目。尽管有最佳实践和丰富的工程人才，但以这种复杂程度编写高性能、并行化和内存安全的代码仍然令人担忧且容易出错。</p><p> Bear in mind, this predates the advent of C++11 (aka the 2011 edition) which heralded efforts to somewhat modernise the language. Even so, manual memory manipulation is easy to get wrong, and  research from  multiple vendors describes this category of error as responsible for 70% of security vulnerabilities.</p><p>请记住，这早于C++11(也就是2011版)的问世，它预示着语言在某种程度上现代化的努力。即便如此，手动内存操作也很容易出错，多家供应商的研究表明，70%的安全漏洞都是由这类错误造成的。</p><p> Into this context steps Graydon Hoare, a Mozilla employee, introducing  a potential solution to the roadblock: Rust, the hobby language he&#39;d been tinkering with since 2006. In 2012, Mozilla would formally announce Servo, an experimental research project to re-imagine a browser engine built with memory safety and concurrency as first principles. And alongside it, Rust, the companion language to make it all possible.</p><p>在这个背景下，Mozilla员工格雷登·霍尔(Graydon Hoare)介绍了一种潜在的解决方案：铁锈，这是他自2006年以来一直在修修补补的业余爱好语言。2012年，Mozilla将正式宣布Servo，这是一个实验研究项目，旨在重新设想一个以内存安全和并发性为首要原则的浏览器引擎。与之并驾齐驱的是铁锈，这是使这一切成为可能的配套语言。</p><p> These early days of Rust are described as a Cambrian explosion of ideas and wild experimentation. Concepts were liberally stolen from other languages, from C++ to OCaml, Haskell, Erlang, ML, C#, Ruby and more, reflecting the diverse pool of engineers working on the language at the time. Still, most in the industry, while admiring the optimism in taking such an ambitious moon shot,  remained pessimistic about the prospects of success.</p><p>铁锈的早期被描述为寒武纪思想的爆发和狂野的实验。概念从其他语言(从C++到OCaml、Haskell、Erlang、ML、C#、Ruby等等)被大量窃取，反映了当时从事该语言工作的工程师的多样性。尽管如此，大多数业内人士在钦佩如此雄心勃勃的登月行动的乐观情绪的同时，仍对成功的前景持悲观态度。</p><p> 2015 saw a major milestone, with the release of Rust v1.0. Perhaps as significant as the feature list, was the number of failed experiments left behind on the cutting room floor, the team unafraid to pare down the language to its quintessential elements. This was also the first time stability guarantees would be offered, a quality notoriously absent before.</p><p>2015年，随着Rust v1.0的发布，这是一个重要的里程碑。也许与功能清单同样重要的是，在剪辑室地板上留下的失败实验的数量，团队不怕把语言削减到它的精髓元素。这也是第一次提供稳定保证，这是出了名的缺乏这种品质。</p><p> Soon after, in 2016, Firefox  shipped its first production Rust code. The industry and community started to take notice, and Rust began its impressive, and as yet unbroken,  four  five year streak as Stack Overflow&#39;s most beloved language. [ Thank you James Munns for pointing out it&#39;s now actually five years].</p><p>不久之后，在2016年，火狐发布了它的第一个生产铁锈代码。业界和社区开始注意到，Rust开始了其令人印象深刻的、至今仍未中断的四个五年的连续五年，成为Stack Overflow最受欢迎的语言。[感谢詹姆斯·芒斯指出，现在实际上已经是五年了]。</p><p> Right from the outset, Rust set out with a clear focus on building an inclusive community. They, in turn, have contributed to Rust&#39;s impressive technical aptitude, but have also fostered a sense of reverence and fondness not often witnessed in other languages. Are they crazy zealots or onto something?</p><p>从一开始，拉斯特就明确将重点放在建设一个包容的社区上。反过来，他们为拉斯特令人印象深刻的技术天赋做出了贡献，但也培养了一种在其他语言中不常见的崇敬和喜爱之情。他们是疯狂的狂热者还是在做什么？</p><p>   This was the first time Rust hijacked my attention. C++ enjoys a long-standing ubiquity, in part, due to its ability to express zero cost abstractions. As explained by Bjarne Stroustrup, the creator of C++:</p><p>这是铁锈第一次引起我的注意。C++由来已久，部分原因是它能够表达零成本抽象。正如C++的创建者Bjarne Stroustrup所解释的那样：</p><p> What you don&#39;t use, you don&#39;t pay for. And further: What you do use, you couldn&#39;t hand code any better.</p><p>你不用的东西，你不用付钱。更进一步：你用的是什么，你的手写代码再好不过了。</p><p> It&#39;s easy to spot the relevancy to games. Making frame-rate while simulating entire worlds is a daunting performance challenge. Indeed, C++ underpins the bulk of game engines. There simply is  no other industrial language that offers the same speed and low-level control, whilst writing programs in the large.</p><p>很容易发现它与游戏的相关性。在模拟整个世界的同时实现帧速率是一个令人望而生畏的性能挑战。事实上，C++支撑了大部分游戏引擎。在大量编写程序的同时，根本没有其他工业语言可以提供相同的速度和低级控制。</p><p> C++, however, suffers from the weight of its legacy. The accumulation of features over 40 years makes for a complex and intricate language. In the last decade modernisation of the standard has done well to uplift it from its C roots, but the experienced programmer must build up an arcane lore of which features are blessed, and which machinery is dangerous. As Stroustrup again describes:</p><p>然而，C++受到其遗留问题的影响。40多年的特点积累造就了一种复杂而错综复杂的语言。在过去的十年里，标准的现代化很好地将它从C语言的根源提升了出来，但经验丰富的程序员必须建立一个神秘的知识，其中的功能是有福的，而哪些机器是危险的。正如斯特罗斯特鲁普再次描述的那样：</p><p>  This makes the language daunting and difficult to approach for beginners. In  this blog post, Rust contributor  withoutboats defines an import quality about abstraction:</p><p>这使得初学者很难掌握这门语言。在这篇博客文章中，Rust撰稿人Without Boats定义了一个关于抽象的重要品质：</p><p> A zero cost abstraction, like all abstractions, must actually offer a better experience than the alternative.</p><p>与所有抽象一样，零成本抽象实际上必须提供比备选方案更好的体验。</p><p> So yes, of course, C++ offers a better time than your own hand wrought assembly. However, this is making the subtle point that it&#39;s competing against a secondary force: a more expensive abstraction that justifies its cost by being more comfortable and convenient.</p><p>所以，是的，C++提供了比你自己手工编写的汇编更好的时间。然而，这说明了一个微妙的问题：它正在与另一股次要力量竞争：一种更昂贵的抽象设计，它更舒适、更方便，从而证明了它的成本是合理的。</p><p> We see this writ large in the rise of popular game engines that eschew the complexity of C++, the most notable being Unity. End users write code in C#, a more forgiving and ergonomic language, creating a boon in developer productivity and a reduction in iteration time.</p><p>我们在流行游戏引擎的崛起中看到了这一点，这些引擎避开了C++的复杂性，最引人注目的是Unity。最终用户用C#编写代码，C#是一种更具容错性和符合人体工程学的语言，从而提高了开发人员的工作效率，减少了迭代时间。</p><p>  In large codebases though, near the edge of the performance envelope, this trade-off begins to bite. The garbage collector eliminates an entire category of errors by removing responsibility for memory management from the end-user. However as its workload grows, so do periodic performance spikes antithetical to smooth gameplay.</p><p>不过，在接近性能极限的大型代码库中，这种权衡开始发挥作用。垃圾回收器通过将内存管理责任从最终用户身上移除，从而消除了整个类别的错误。然而，随着其工作量的增加，周期性的性能峰值也会增加，而不是流畅的游戏玩法。</p><p>  The experienced developer can still create a performant experience, however, this demands plugging the leaks in the abstraction. They must build a mental model of the machinery behind the curtain, a collection of arcane wisdom that bans many of the original conveniences, lest they disturb the garbage collector.</p><p>有经验的开发人员仍然可以创建性能体验，然而，这需要填补抽象中的漏洞。他们必须建立幕后机器的心理模型，这是一种神秘智慧的集合，禁止了许多原始的便利，以免它们打扰垃圾收集器。</p><p> So development teams face a choice. Better resourced AAA studios generally choose Unreal or in-house engine tech built on C++, able to absorb the overhead for long term gain. Less resourced studios optimise for time to market, choosing Unity, or one of the many other accessible game making tools (Godot, Haxe, Game Maker, etc.). They often postpone performance concerns until after business eligibility is secured.</p><p>因此，开发团队面临着一个选择。资源更充足的AAA工作室通常选择基于C++的虚幻或内部引擎技术，能够吸收开销以获得长期收益。资源较少的工作室会优化上市时间，选择Unity或许多其他可用的游戏制作工具(Godot、Haxe、Game Maker等)之一。他们通常将业绩担忧推迟到确保业务资格之后。</p><p> Rust, however, for the first time, promises a third way. A world where it&#39;s possible to write zero cost abstractions without sacrificing higher-order elegance.</p><p>然而，铁锈第一次承诺了第三条道路。在这个世界里，你可以在不牺牲高阶优雅的情况下，写出零成本的抽象概念。</p><p>  To understand Rust&#39;s special sauce, we&#39;re going have to talk about ownership and how it handles memory. This is only a simple sketch, but  in-depth resources exist for the curious.</p><p>为了理解铁锈的独特之处，我们不得不谈谈所有权以及它是如何处理内存的。这只是一个简单的草图，但对于好奇的人来说，有深入的资源可供参考。</p><p> Writing optimised code is often about taking the way we, as humans, naturally think of an idea or algorithm, and instead expressing it in terms that favour the computer. This act often harms the legibility and understanding of a program, which makes it much harder for us, the humans, to reason about its correctness.</p><p>编写优化的代码通常是采用我们作为人类自然想到的想法或算法的方式，而不是用有利于计算机的语言来表达它。这种行为通常会损害程序的易读性和理解性，这使得我们人类更难对其正确性进行推理。</p><p> In a manually managed language, like C, the hapless programmer is left responsible for the machinations of the machine. They must take great care to ensure data is appropriately loaded into memory before operation, and then responsibly disposed of afterwards. A difficult dance in which missteps either cause dramatic crashes or else subtle and hard to detect vulnerabilities. But these are the very same tools that allow careful users to tune performance.</p><p>在像C这样的手动管理语言中，倒霉的程序员要为机器的阴谋负责。他们必须非常小心地确保数据在操作前被适当地加载到内存中，然后在操作之后负责任地处理。一种困难的舞蹈，其中的失误要么会导致戏剧性的崩溃，要么就是微妙而难以察觉的漏洞。但这些工具正是允许细心用户调优性能的工具。</p><p> At the other end of the spectrum, garbage collection promises the programmer it will automatically deal with the problem on their behalf. They are now free to express code naturally, but in doing so, it ties hands behind their back. They no longer have, at least not without indirection, the levers needed to wring out maximal performance.</p><p>另一方面，垃圾收集向程序员承诺，它将代表程序员自动处理问题。他们现在可以自由地自然地表达代码，但这样做会把他们的双手绑在背后。他们不再拥有实现最高绩效所需的杠杆，至少不是没有间接的杠杆。</p><p> Rust begins from a different premise. Rather than hiding this complexity, it accepts that computers are hard for humans, and instead tries to save us from the dangerous bits. Users can still tune the machine, but with less rope to wrap around their necks.</p><p>生锈是从一个不同的前提开始的。它没有隐藏这种复杂性，而是承认计算机对人类来说是困难的，相反，它试图将我们从危险中拯救出来。用户仍然可以调整机器，但脖子上缠绕的绳子更少了。</p><p> In the same way that static typing exists, very clever people have figured out how to make the compiler eliminate a whole category of memory and concurrency errors. To achieve this, Rust makes a bargain with the developer:</p><p>与静态类型存在的方式相同，非常聪明的人已经想出了如何让编译器消除整个类别的内存和并发错误。为了实现这一点，Rust与开发商进行了讨价还价：</p><p> &#34;I&#39;m going to keep track of the lifetime of every piece of memory in your program for you. This way, I can detect the moment you&#39;re no longer using it and safely free it on your behalf. But in return, I&#39;m going to need you to follow  strict rules about the ownership of that memory. If you try to use it outside of the scope that owns it, my humourless friend here, the borrow checker, is going to make sure you don&#39;t hurt yourself.&#34;</p><p>我将为您记录程序中每一块内存的生命周期。这样，我可以检测到您不再使用它的时刻，并代表您安全地释放它。但作为回报，我需要你严格遵守有关内存所有权的规定。如果你试图在拥有它的范围之外使用它，我这位没有幽默感的朋友，借阅检查员，会确保你不会伤到自己。</p><p> However, like static typing, this lunch isn&#39;t free. Rust is known to have a steep learning curve, &#34;fighting the borrow checker&#34; becomes a right of passage. It takes time to learn this new paradigm. Ownership makes some familiar patterns difficult or impossible and demands new ones be learnt in their place. Perhaps we should revise our earlier statement as: &#34;The performance of C++ with the  convenience safety of C#&#34;</p><p>然而，就像静态打字一样，这顿午餐也不是免费的。众所周知，生锈有一个陡峭的学习曲线，与借阅检查员抗争成为一种通行权。学习这种新模式需要时间。所有权使一些熟悉的模式变得困难或不可能，并要求在它们的位置上学习新的模式。也许我们应该把我们之前的说法修改为：C++的性能和C#&34的便捷安全性；</p><p>  Early adopters have a selfish reason to extol the virtues of their chosen technology, as widespread adoption enhances the return on their risky investment. In this respect, while interest is high but opportunities for real-world exposure are limited, is it possible that Rust is cresting a wave of unearned hype?  Not every javascript or python developer interested in the language, for example, has a use case that merits the additional complexity.</p><p>早期采用者有一个自私的理由来赞扬他们选择的技术的优点，因为广泛采用提高了他们高风险投资的回报。在这方面，虽然人们的兴趣很高，但接触现实世界的机会有限，但拉斯特有没有可能正在掀起一波不劳而获的炒作浪潮？例如，并不是每个对该语言感兴趣的Javascript或Python开发人员都有值得增加复杂性的用例。</p><p> To a developer standing on the shores of 2010,  git, a new version control system with a steep learning curve, may have seemed like a risky investment. But, in the ensuing world of Github, it&#39;s hard to argue the effort was wasted, even if some workloads (i.e. large games) still require alternatives.</p><p>对于一个站在2010年海岸线上的开发者来说，Git这个学习曲线陡峭的新版本控制系统似乎是一项高风险的投资。但是，在接下来的Github世界里，即使一些工作量(即大型游戏)仍然需要替代方案，也很难辩称这些努力是徒劳的。</p><p> In a similar vein, how can we qualify Rust&#39;s popularity as a meaningful signal? Ultimately, we will only know by the volume of mud we&#39;ve dug through in the trenches, and admittedly, it is far too early to collect this data for games.</p><p>同样，我们如何才能将铁锈的受欢迎程度定义为一个有意义的信号呢？最终，我们只能通过我们在战壕中挖出的泥土的数量来知道，诚然，现在为游戏收集这些数据还为时过早。</p><p> In other industries, though, early reports of Rust are effusive.  Mircosoft,  Facebook,  Amazon,  Dropbox,  Cloudflare all have Rust deployed in production. The  Linux Kernel and  Chrome teams have at least investigated pathways towards integrating Rust. These companies aren&#39;t looking to throw out multi-million line codebases and rewrite everything, but they are, where it makes sense to do so, choosing Rust for self-contained new projects. At a systems programming level (operating systems and web browsers) Rust does seem to be competent and desirable.</p><p>然而，在其他行业，有关铁锈的早期报道是热情洋溢的。微软、Facebook、亚马逊、Dropbox、Cloudflare都部署了Rust。Linux内核和Chrome团队至少已经调查了整合Rust的途径。这些公司并不打算扔掉数百万行代码库，重写所有代码，但他们选择了Rust作为独立的新项目，这样做是有意义的。在系统编程层面(操作系统和Web浏览器)，Rust看起来确实是称职和可取的。</p><p> It&#39;s also garnered interest  up and down the entire stack, from bare-metal microcontrollers to web applications deployed via web assembly. Rust has done very well to make it&#39;s ecosystem comfortable and welcoming. Compiler tooling, documentation, error messages, cross-platform support, modules, dependency management and packages are all first class.</p><p>从裸机微控制器到通过网络组装部署的网络应用，它还在整个堆栈上下引起了人们的兴趣。铁锈已经做得非常好，使它的生态系统舒适和欢迎。编译工具、文档、错误消息、跨平台支持、模块、依赖项管理和包都是一流的。</p><p> To anyone booting up a commercial game engine, this might not seem like a novelty. Still, to the beleaguered operating system kernel developer, sequestered away writing C, it&#39;s hard to overstate how exciting the chance to have nice things  must feel.</p><p>对于任何启动商业游戏引擎的人来说，这可能并不是什么新鲜事。尽管如此，对于四面楚歌的操作系统内核开发人员来说，要想有机会拥有美好的东西，这种感觉怎么说都不为过。</p><p> There, however, exists another axis on which we should be interested in Rust. As a systems developer, Bryan Cantrill, explains in his highly entertaining  talk, with enough experience and care, it is possible to write well behaved C code. But Rust excites him because, as well as memory safety, it unlocks new abstractions.</p><p>然而，还有另一个我们应该对铁锈感兴趣的轴。作为一名系统开发人员，布莱恩·坎特里尔(Bryan Cantrill)在他非常有趣的演讲中解释道，只要有足够的经验和细心，就有可能写出行为良好的C代码。但“锈”让他兴奋，因为除了记忆安全，它还解锁了新的抽象概念。</p><p> Better abstraction, of course, is the  raison d&#39;etre of C++, and why it was bolted onto C in the first place. But, even in comparison to C++ or C#, there is real innovation here. Mainstream programming may have rejected hardcore functional programming languages like Haskell, but it hasn&#39;t stopped the best ideas from percolating into the groundwater of other languages.</p><p>当然，更好的抽象性是C++的理由，也是为什么它一开始就被固定在C上的原因。但是，即使与C++或C#相比，这里也有真正的创新。主流编程可能已经拒绝了像Haskell这样的核心函数式编程语言，但它并没有阻止最好的想法渗透到其他语言的地下水中。</p><p> Normally this manifests as bolted-on language extensions, one example being  LINQ in C#.  LINQ gives developers a concise declarative language to query and manipulate data. Compelling, except, as a source of garbage collection pressure, game developers soon learn to steer clear. Rust, however, was built with these inspirations from day one. Rust iterators, the equivalent of  LINQ, are available as zero cost abstractions, closing the gap between how humans think and what the machine expects.</p><p>通常，这表现为固定的语言扩展，C#中的LINQ就是一个例子。LINQ为开发人员提供了一种简洁的声明性语言来查询和操作数据。令人信服的是，除了作为垃圾收集压力的来源，游戏开发人员很快就学会了避开。然而，从第一天起，铁锈就是基于这些灵感而形成的。Rust迭代器，相当于LINQ，可以作为零成本抽象使用，缩小了人类思维方式和机器期望之间的差距。</p><p> Functional programming is, at its heart, about creating contracts to avoid unintended consequences. This DNA is apparent all over Rust, the quality of &#34;correctness&#34; permeates far beyond the memory model. If you&#39;re working on a complex project or with a large team, this should be a strong selling point. Immutability is on by default.  Strict read/write rules on mutable data allow Rust to promise fearless concurrency. While  the type system departs from C++ and C#, there are no inheritance-based classes, for example, it broadens the scope of what can be verified. Often if it compiles, it runs.</p><p>函数式编程的核心是创建契约以避免意想不到的后果。这种DNA在“锈”中随处可见，其正确性的品质远远超出了记忆模型的范畴。如果你正在做一个复杂的项目或和一个大团队一起工作，这应该是一个很好的卖点。默认情况下，不可变性处于启用状态。对可变数据的严格读写规则允许Rust承诺无畏的并发性。虽然类型系统不同于C++和C#，但是没有基于继承的类，例如，它拓宽了可以验证的范围。通常，如果它编译了，它就会运行。</p><p> Swift and Kotlin, two other modern and well-reviewed languages, perhaps signal these are ideas whose time has come. Whilst each has different memory models (Swift is C++ like, and Kotlin is garbage collected), they represent the state of the art on their respective platforms (iOS and Android). Although to different degrees, like Rust, both have a hybrid semi-functional flavour to them.</p><p>斯威夫特(Swift)和科特林(Kotlin)这两种现代且广受好评的语言，或许标志着这些想法的时代已经到来。虽然它们都有不同的内存模型(Swift类似于C++，而Kotlin是垃圾收集的)，但它们代表了各自平台(iOS和Android)上的最新技术。虽然程度不同，但和铁锈一样，两者都有一种混合的半功能性味道。</p><p>  Rust is still an immature language. Today there are still useful features in C++ that Rust, as yet, cannot match. However, this is not a static target. With the groundswell and energy around it, and new language release every six weeks, this gap has been closing rapidly.</p><p>铁锈仍然是一种不成熟的语言。时至今日，C++中仍有一些有用的特性是Rust无法比拟的。然而，这不是一个静态的目标。随着它周围的风起云涌和活力，以及每六周发布一次新语言，这一差距正在迅速缩小。</p><p> Perhaps of more concern is the lack of maturity in the broader ecosystem. For example, anybody building a desktop application today would be frustrated by the lack of de facto GUI (Graphical User Interface) tools. Building new GUI systems is an elaborate multi-year effort, but here the vibrancy of the package ecosystem and community shines. There are already tens of thousands of crates (i.e. libraries) listed on  the package registry. Though an overabundance of choice can ultimately become its  own burden, there are already enough building blocks available to begin answering these questions. Indeed,  several early-stage GUI libraries are vying to do so.</p><p>或许更令人担忧的是，更广泛的生态系统还不够成熟。例如，今天构建桌面应用程序的任何人都会因为缺乏事实上的图形用户界面(GUI)工具而感到沮丧。构建新的图形用户界面系统是一项精心设计的多年努力，但在这里，包生态系统和社区的活力大放异彩。程序包注册表中已经列出了数万个板条箱(即库)。尽管过多的选择最终可能会成为它自己的负担，但已经有足够的积木可以开始回答这些问题。事实上，几个早期的图形用户界面库都在争先恐后地这么做。</p><p> This illustrates the biggest hurdle to adoption. Modern game engines are a vast orchestration of different technologies, of which the choice of programming language is only a small piece of the pie. Building a mature engine, from scratch, might be a decade long endeavour. We could easily say the same for multiple sub-technologies, for example, rendering, networking, physics and audio middleware.</p><p>这说明了采用的最大障碍。现代游戏引擎是不同技术的巨大编排，其中编程语言的选择只是蛋糕的一小块。从零开始打造一台成熟的发动机可能需要十年的努力。我们可以很容易地对多个子技术说同样的话，例如，渲染、网络、物理和音频中间件。</p><p> It&#39;s best to reuse what we can. Rust has some advantage here, calling native C code from high-level languages, like C#, can be expensive. Rust behaves more like C++ though where the overhead is negligible. However, most middleware is written in C++, not C, and there is no simple bridge to call C++ code from Rust. That&#39;s not to say inter-op is impossible, C can  be used as a lowest common denominator to glue the two together, an operation that demands a strong stomach.</p><p>最好重新利用我们能利用的东西。Ruust在这方面有一些优势，从高级语言(如C#)调用本机C代码的成本可能很高。Ruust的行为更像C++，尽管开销可以忽略不计。然而，大多数中间件都是用C++编写的，而不是C，而且没有从Rust调用C++代码的简单桥梁。这并不是说互操作是不可能的，C可以作为将两者粘合在一起的最低公分母，这是一种需要强大胃口的操作。</p><p> However, as with any common denominator, does the trade-off eliminate the safety we sought in the first place? Ultimately native solutions would be preferable. Here, again, the ecosystem is already at work to provide many of the  building blocks. I had initially assumed graphics programming would be one of the last holdouts, where vfx are built with rudimentary C-like shader languages. But even here we see promising Rust based  alternatives. An innovation that might, ironically, be a pathway for Rust into existing engines.</p><p>然而，与任何共同点一样，这种权衡是否会消除我们最初寻求的安全？归根结底，本地解决方案会更可取。在这一点上，生态系统已经在工作，以提供许多构建块。我最初以为图形编程将是最后的顽固者之一，在那里VFX是用基本的类似C的着色器语言构建的。但即使在这里，我们也看到了前景看好的铁锈替代能源。具有讽刺意味的是，这一创新可能是铁锈进入现有发动机的一条途径。</p><p>  Disruptive technologies often aren&#39;t successful on their technical merits alone. In the case of  git, Github was the killer application that allowed it to out-compete rival distributed version control systems, and ultimately disrupt the sector as a whole.</p><p>颠覆性技术往往不会仅仅因为它们的技术优势而成功。就Git而言，Github是杀手级应用，它让它在竞争中击败了竞争对手分布式版本控制系统，并最终颠覆了整个行业。</p><p> In the case of games, the killer application is almost certainly going to be a game engine. Unity had many compelling features: the ease of use and price point was a revolution in democratising game development. But it was also uniquely positioned in time as the best way to access the exploding iOS app store. Unity built on that success and mind share to eventually compete and disrupt far beyond just the mobile space.</p><p>就游戏而言，杀手级应用几乎肯定是游戏引擎。Unity有许多引人注目的特点：易用性和价格点是游戏开发民主化的一场革命。但它在时间上也是独一无二的，成为访问爆炸式增长的iOS应用商店的最佳方式。建立在这种成功和思想共享基础上的团结最终将在移动领域以外的领域展开竞争和颠覆。</p><p> Mind share is important; the virtuous cycle that builds a moat around a technology. Years of institutional knowledge keeps teams invested. It maintains their access to a broad talent pool and maximises chances new a platform or middleware vendor will prefer their chosen engine.</p><p>思想分享很重要；围绕一项技术建立护城河的良性循环。多年的机构知识让团队不断投入。它保持了他们对广泛人才库的访问权，并最大限度地增加了新平台或中间件供应商更喜欢他们选择的引擎的机会。</p><p> Rust shows promise as a compelling language for engine development, and there is no reason this should be any different for programmers at the business end of large or complicated in-game systems. However, not every member of a development team is pitching at this level, or even at all. To a level designer making scripted gameplay content, building interactivity with Rust might be overwhelming.</p><p>对于引擎开发来说，Ruust显示出了作为一种引人注目的语言的前景，对于大型或复杂游戏中系统的业务端的程序员来说，这没有理由有什么不同。然而，并不是每个开发团队成员都达到这个级别，甚至根本不是。对于制作脚本游戏内容的设计师来说，与Rust建立互动性可能是压倒性的。</p><p> Other engines resolve this dissonance by providing simpler interfaces. Either a simplified scripting language like Lua or else visual programming like Blueprints in Unreal. To an artist though, they&#39;d be far more concerned with the efficiency of the art pipeline.</p><p>其他引擎通过提供更简单的接口来解决这种不和谐。要么是像Lua这样的简化脚本语言，要么是像虚幻中的蓝图那样的可视化编程。然而，对于艺术家来说，他们更关心的是艺术管道的效率。</p><p> It&#39;s not that a Rust flavoured game engine can&#39;t solve these concerns, but building a robust user experience stretches beyond the programming language. It&#39;s plausible Rust will engender enough programmer goodwill to drive adoption, we are an opinionated bunch, after all. However, it seems more likely a new game engine will secure its future with unprecedented democratisation, either of new workflows or new markets.</p><p>这并不是说铁锈口味的游戏引擎不能解决这些问题，但构建强大的用户体验超出了编程语言的范畴。IT看似铁锈将产生足够的程序员善意来推动采用，毕竟我们是一群固执己见的人。然而，无论是新的工作流程还是新的市场，新的游戏引擎似乎更有可能通过前所未有的民主化来确保其未来的安全。</p><p> Predicting specifics would be an act of fortune-telling. However, I can offer some educated guesses:</p><p>预测细节将是一种算命行为。然而，我可以提供一些有根据的猜测：</p><p> After a long burn, the open-sourced Blender has begun disrupting 3D content creation software. It&#39;s reasonable to expect a game engine might follow suit; however, Godot already has a significant first-mover advantage. Early efforts would be competing directly with Godot rather than the incumbents.</p><p>在经历了漫长的磨难之后，开源的Blender开始颠覆3D内容创作软件。我们有理由期待游戏引擎也会紧随其后；然而，戈多已经拥有了显著的先发优势。早期的努力将是与戈多直接竞争，而不是与现任者竞争。</p><p> Despite the advent of accessible game engines, the expert skills required to produce content remain labour intensive, and therefore expensive. Procedural content and AI-assisted art tools have tremendous potential to usher revolution here, as seen in  early research. However, this innovation is broadly available to commercial engines too, and we already see  the first fruits ripen.</p><p>尽管出现了无障碍游戏引擎，但制作内容所需的专业技能仍然是劳动密集型的，因此成本高昂。程序性内容和人工智能辅助艺术工具具有巨大的潜力，可以在这里带来革命，正如早期研究所看到的那样。然而，这一创新也广泛应用于商用发动机，我们已经看到了第一批成熟的成果。</p><p> Increasingly, chart-topping games are expected to provide large multiplayer shared worlds. Networking is already hard, but large scale distributed computing is difficulty on hell-mode. We&#39;ve seen  massive venture-backed plays in the space, hoping to provide developers on existing engines an easy onboarding, so far with  mixed results.</p><p>越来越多的排行榜冠军游戏有望提供大型多人共享世界。联网已经很困难，但大规模分布式计算在地狱模式下是困难的。我们已经在这个领域看到了大量风投支持的游戏，希望能为现有引擎上的开发人员提供一种简单的入门方式，到目前为止，结果好坏参半。</p><p> On this last point, Rust may be able to differentiate itself technically. Fearless concurrency and functional programming are eminently well suited to distributed computing. Web platforms adopting Rust can only further this cause. A game engine that better navigates this distributed world will have a significant advantage. Though it&#39;s just as likely any eventual winner will embody all of the above and more.</p><p>在这最后一点上，铁锈或许能够在技术上脱颖而出。无所畏惧的并发性和函数式编程非常适合分布式计算。采用Rust的网络平台只会进一步推动这一事业。一个更好地驾驭这个分布式世界的游戏引擎将具有显著的优势。不过，任何最终的获胜者都有可能实现以上所有目标，甚至更多。</p><p>  Immaturity can be fixed with time and effort, but escaping the scrapheap of obscurity is much harder. Nobody wants to be stranded on a sinking island. Whilst it&#39;s impossible to say how long Rust&#39;s tail will be, the same is not true for proven technologies. Even if everyone stopped writing C++ overnight, code written in the language would continue to exist for decades to come.</p><p>不成熟可以通过时间和努力来修复，但逃离默默无闻的废墟要难得多。没有人想被困在一个下沉的小岛上。虽然不可能说出铁锈的尾巴会有多长，但对于经过验证的技术来说，情况并非如此。即使每个人都在一夜之间停止编写C++，用这种语言编写的代码也会在未来几十年里继续存在。</p><p> This year Mozilla, in reaction to their precarious financial position,  laid off scores of developers - including the entire Servo team (the experimental browser engine paired with Rust). There was a time when this could have been the death knell. However, it seems, there is enough resilience for the language to survive and prosper. With investment from industry, some teams finding  new homes, and  the announcement of an independent foundation, it does seem we&#39;re witnessing a dawn rather than a twilight.</p><p>今年，由于财务状况不稳定，Mozilla解雇了数十名开发人员--包括整个Servo团队(试验性浏览器引擎与Rust配对)。曾经有一段时间，这可能是丧钟。然而，似乎有足够的韧性让这门语言生存和繁荣。随着来自行业的投资，一些团队找到了新家，以及宣布成立一个独立的基金会，我们似乎确实看到了曙光，而不是曙光。</p><p>   Whilst the incremental grow</p><p>在增量增长的同时。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://thefuntastic.com/blog/why-rust-is-the-future-game-dev">https://thefuntastic.com/blog/why-rust-is-the-future-game-dev</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/future/">#future</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034009.html"><img src="http://img2.diglog.com/img/2020/11/thumb_5b26d5089bfc1f5a4a23cabc2ba0f4e4.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034009.html">Dog是一个DNS客户端，使用Rust、Dns-over-TLS、DNS-over-HTTPS、Colors、JSON编写</a></div><span class="my_story_list_date">2020-11-9 20:29</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033930.html"><img src="http://img2.diglog.com/img/2020/11/thumb_3a1be40609f8294f8c760a1e36d336a5.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033930.html">避免Bash受挫-将Python用于Shell脚本</a></div><span class="my_story_list_date">2020-11-9 4:51</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033855.html"><img src="http://img2.diglog.com/img/2020/11/thumb_367ac685dc4860fe22904640413e025b.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033855.html">让我们加密警告说，从2021年开始，运行安卓7.1或更早版本的手机将不会连接到许多安全网站，因为它们将不再信任其根证书</a></div><span class="my_story_list_date">2020-11-8 23:7</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033693.html"><img src="http://img2.diglog.com/img/2020/11/thumb_fbae8366a92252684fa42b8b22c473bc.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033693.html">阿帕奇箭头2.0.0锈色亮点</a></div><span class="my_story_list_date">2020-11-7 18:11</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>