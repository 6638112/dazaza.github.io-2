<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#解析器</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#解析器</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1056518.html">Elixir中的解析器组合者 </a></div><div class="item_title_en"><a target="_blank" href="https://serokell.io/blog/parser-combinators-in-elixir">Parser Combinators in Elixir</a><span>(serokell.io)</span></div><span class="my_story_list_date">2021-4-6 23:8</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1056518.html"><img src="http://img2.diglog.com/img/2021/4/thumb_b2188a990a28459d68dc1456374c3e8c.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">解析器组合器是解析的最有用工具之一。与正则表达式相比，它们更具可读性和可维护性，使其成为更复杂任务的绝佳选择。
 本文有两部分。首先，我解释了解析器组合者如何工作以及它们所做的。之后，我将通过在Elixir编写的解析器组合库库中使用nimbleparsec进行CSV解析器来指导您完成CSV解析器。
   在这一部分中......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1051607.html">Zig，Parser组合者 - 为什么他们 </a></div><div class="item_title_en"><a target="_blank" href="https://devlog.hexops.com/2021/zig-parser-combinators-and-why-theyre-awesome">Zig, Parser Combinators – and Why They're</a><span>(devlog.hexops.com)</span></div><span class="my_story_list_date">2021-3-11 6:10</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1051607.html"><img src="http://img2.diglog.com/img/2021/3/thumb_396866748a130de0ed49af3ea9dd8c0d.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在本文中，我们将探索解析器组合器是什么，运行时解析器生成是 - 为什么它们有用，然后通过Zig实现。
     解析器组合器是一个高阶函数，它将解析器作为输入，并生成一个新的解析器作为输出：
   假设我们想解析描述正则表达式的语法：[bc]。* abc
 我们可以定义一些解析器，以帮助我们解析此语法（例如，进入令牌......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/parser/">#parser</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1050195.html">应用解析 </a></div><div class="item_title_en"><a target="_blank" href="https://jobjo.github.io/2019/05/19/applicative-parsing.html">Applicative Parsing</a><span>(jobjo.github.io)</span></div><span class="my_story_list_date">2021-3-2 2:12</span><div class="my_story_list_item_desc">解析器组合器是用于以可组合方式构建解析器的功能集。 Haskell的Parsec库和OCaml的Angstrom是两个示例。这两个库都公开了用于描述上下文相关语法的monadic接口。这篇文章着眼于实现一个更受限制的解析库，该解析库是围绕applicativefunctors而不是monads构造的。
 有什么理由可......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/应用/">#应用</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037453.html">新的Pip解析器需要很长时间才能完成 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/pypa/pip/issues/9187">New Pip resolver takes a long time to complete</a><span>(github.com)</span></div><span class="my_story_list_date">2020-12-4 20:35</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1037453.html"><img src="http://img2.diglog.com/img/2020/12/thumb_3a4ad09fc72f54e1c1e265d0c5167538.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">已经满足的要求：/opt/hostedtoolcache/Python/3.7.9/x64/lib/python3.7/site-packages中的google-auth＆lt; 2.0dev，＆gt; = 1.21.1（来自google-api-core [grpc] ＆lt; 2.0.0dev，＆gt; = 1......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/resolver/">#resolver</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/来自/">#来自</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036627.html">解析器生成器DSL：使用Babel和JavaScript模板构建解析器</a></div><div class="item_title_en"><a target="_blank" href="https://kitten.sh/parser-generator-dsl">Parser Generator DSLs: Building Parsers with Babel and JavaScript Templates</a><span>(kitten.sh)</span></div><span class="my_story_list_date">2020-11-26 6:52</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1036627.html"><img src="http://img2.diglog.com/img/2020/11/thumb_1bf7db1cefcd5c92e57847aa36377f1c.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">自从我开始处理样式化组件以来，我一直对解析器着迷。第一次为Webpack或Babel编写插件感觉就像是纯粹的魔术，尤其是如果该插件不只是出于兼容性原因而传递一些可移植的代码或添加一些元数据，而是生成了全新的编码器或启用了无法在运行时实现的功能时，仅代码。
 这些天来，JavaScript开发人员解析器无处不在。当我们......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/generator/">#generator</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语法/">#语法</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1030323.html">Lezer解析器系统</a></div><div class="item_title_en"><a target="_blank" href="https://lezer.codemirror.net/">The Lezer Parser System</a><span>(lezer.codemirror.net)</span></div><span class="my_story_list_date">2020-10-22 3:37</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1030323.html"><img src="http://img2.diglog.com/img/2020/10/thumb_32b692da469ef4a807a74bc16141af46.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">60多年来，结构化文本的解析问题一直在抵制“一刀切”的解决方案。Lezer也不是这样的解决方案，但它是一个非常不错的解析器生成器，特别适合在代码编辑器中使用。
Lezer(荷兰语中的读取器，发音类似于“LASSER”)提供了一个解析器生成器，该生成器输出JavaScript模块，可以加载这些模块将代码解析到非抽象语法......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parser/">#parser</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1026110.html">CPython编译器的工作原理</a></div><div class="item_title_en"><a target="_blank" href="https://tenthousandmeters.com/blog/python-behind-the-scenes-2-how-the-cpython-compiler-works/">How the CPython compiler works</a><span>(tenthousandmeters.com)</span></div><span class="my_story_list_date">2020-9-24 17:31</span><div class="my_story_list_item_desc">在本系列的第一篇文章中，我们介绍了CPython VM。我们已经了解到它是通过执行一系列称为字节码的指令来工作的。我们还看到，Python字节码不足以完全描述一段代码的功能。这就是存在代码对象概念的原因。执行诸如模块或函数的代码块意味着执行相应的代码对象。代码对象包含块的字节码、常量和块中使用的变量名称以及块的各种属......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1024959.html">制作一个Pratt解析器生成器</a></div><div class="item_title_en"><a target="_blank" href="https://www.robertjacobson.dev/designing-a-pratt-parser-generator">Making a Pratt Parser Generator</a><span>(www.robertjacobson.dev)</span></div><span class="my_story_list_date">2020-9-19 5:59</span><div class="my_story_list_item_desc">编程语言解析器的历史主要是解析表达式的棘手挑战，特别是数学表达式，考虑到表达式中运算符的优先顺序。现代形式语言理论始于20世纪50年代诺姆·乔姆斯基(Noam Chomsky)的工作，乔姆斯基在其中为语言学建立了一个数学框架。在这个数学框架下，语言存在于根据语言的难解析性定义的语言世系中。但是计算机程序员需要实用、高......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pratt/">#pratt</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/运算符/">#运算符</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021687.html">Pasukon-简单的JavaScript解析器生成器</a></div><div class="item_title_en"><a target="_blank" href="https://pasukon.rocks/">Pasukon – The easy JavaScript parser generator</a><span>(pasukon.rocks)</span></div><span class="my_story_list_date">2020-9-2 11:27</span><div class="my_story_list_item_desc">Lex Match Number/[0-9]+(？：\.[0-9]+)？/Match plus&#39；+&#39；Match减去&#39；--&#39；Match Time&#39；*&#39；Match DIV&#39；/&#39；Match POPEN&#39；(&#39；Match PCLOSE&#39；)&......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/easy/">#easy</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/match/">#match</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1018534.html">使用Rust和Nom的解析器组合器的错误恢复</a></div><div class="item_title_en"><a target="_blank" href="https://www.eyalkalderon.com/nom-error-recovery/">Error recovery with parser combinators, using Rust and nom</a><span>(www.eyalkalderon.com)</span></div><span class="my_story_list_date">2020-8-17 3:1</span><div class="my_story_list_item_desc">随着新冠肺炎疫情继续肆虐全球，许多人都呆在家里，要么远程工作，要么无所事事地坐着。前一天下午，我无意中看到一则在线公告，称ACM数字图书馆已向所有人免费开放，供所有人阅读和下载，以帮助在这一危机时期促进研究、发现和学习。我感到好奇，而且之前曾想阅读ACM DL的某些研究论文，于是利用这个机会仔细阅读了它的图书馆，并尽......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/recovery/">#recovery</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012144.html">不要惊慌！为LR解析器提供更好、更少的语法错误</a></div><div class="item_title_en"><a target="_blank" href="https://soft-dev.org/pubs/html/diekmann_tratt__dont_panic/">Don't Panic! Better, Fewer, Syntax Errors for LR Parsers</a><span>(soft-dev.org)</span></div><span class="my_story_list_date">2020-7-16 4:33</span><div class="my_story_list_item_desc">抽象语法错误对于人类来说通常很容易修复，但不适用于一般的解析器，也不适用于特定的LR解析器。传统的“恐慌模式”错误恢复，虽然易于实现且适用于任何语法，但通常会导致一系列错误，从而淹没了原始错误。更先进的错误恢复技术受到这个问题的影响较小，但几乎没有实际用途，因为它们的典型性能被认为很差，其最坏情况是无界的，并且它们报......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/errors/">#errors</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/算法/">#算法</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1009923.html">构建快速JSON解析器和完整的JSONPath，OJ for Go的旅程</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/ohler55/ojg/blob/master/design.md">A Journey building a fast JSON parser and full JSONPath, Oj for Go</a><span>(github.com)</span></div><span class="my_story_list_date">2020-7-5 20:54</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1009923.html"><img src="http://img.diglog.com/img/2020/7/thumb_c2508fdd7e89237e2e894dda4e20d210.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">PermalLink GitHub是5000多万开发人员的家园，他们一起工作，共同托管和审查代码、管理项目和构建软件。
报名。
我做了一个梦。我将编写一个快速的JSON解析器、泛型数据和JSONPath实现，它将非常漂亮、组织良好，并且值得钦佩。嗯，现实开始发挥作用，嘲笑那些流言蜚语。Go JSON解析器和工具可能具......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/oj/">#oj</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/building/">#building</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1004193.html">解析器组合器中有什么？(2016)</a></div><div class="item_title_en"><a target="_blank" href="https://remusao.github.io/posts/whats-in-a-parser-combinator.html">What's in a Parser Combinator? (2016)</a><span>(remusao.github.io)</span></div><span class="my_story_list_date">2020-5-29 10:51</span><div class="my_story_list_item_desc">作为我在Haskell取得进展的持续努力的一部分(这是我2016年的目标之一！)，我在edX上关注Erik Meijer的函数式编程MOOC。
第一堂课是非常基础的东西，我很快就学完了。第7课是关于函数解析器和M*(可怕的)。这就是我第一次遇到困难的地方，我想这会是一篇有趣的文章。我以前已经在Haskell中使用过解......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/组合/">#组合</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parser/">#parser</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1001488.html">替换CPython的解析器</a></div><div class="item_title_en"><a target="_blank" href="https://pyfound.blogspot.com/2020/04/replacing-cpythons-parser-python.html">Replacing CPython’s Parser</a><span>(pyfound.blogspot.com)</span></div><span class="my_story_list_date">2020-5-10 13:41</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1001488.html"><img src="http://img.diglog.com/img/2020/5/thumb_7fb638f9cf6507a7566ea857846f3e2a.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">从一开始，Python的语法就是LL(1)：它只需要一个从左到右的解析器，向前看一个标记来解决歧义。标准CPython解析器是由一个简单的自定义解析器生成器生成的。然而，这种简单性是有代价的。首先，官方的Python语法文件没有准确捕获语言。语法允许无效的构造，例如，这个赋值表达式(使用new walrus运算符)：......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cpython/">#cpython</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button></div></div></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>