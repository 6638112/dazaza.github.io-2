<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我在Forth和堆栈机上的历史（2010年） My history with Forth and stack machines (2010)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">My history with Forth and stack machines (2010)<br/>我在Forth和堆栈机上的历史（2010年） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-21 07:50:00</div><div class="page_narrow text-break page_content"><p>My VLSI tools take a chip from conception through testing. Perhaps 500 lines of source code. Cadence, Mentor Graphics do the same, more or less. With how much source/object code?</p><p>我的VLSI工具采用了从构思到测试的所有芯片。也许有500行源代码。 Cadence，Mentor Graphics或多或少都这样做。用多少源代码/目标代码？</p><p>  This is a personal account of my experience implementing and using the Forth programming language and the stack machine architecture. &#34;Implementing and using&#34; – in that order, pretty much; a somewhat typical order, as will become apparent.</p><p>  这是我在实施和使用Forth编程语言以及堆栈计算机体系结构方面的经验的个人说明。 ＆＃34;实施和使用＆＃34; –按照这个顺序，差不多；这将是显而易见的典型顺序。</p><p> It will also become clear why, having defined the instruction set of a processor designed to run Forth that went into production, I don&#39;t consider myself a competent Forth programmer (now is the time to warn that my understanding of Forth is just that – my own understanding; wouldn&#39;t count on it too much.)</p><p> 这也将变得很清楚，为什么在定义了用于运行Forth并投入生产的处理器的指令集之后，我却不认为自己是合格的Forth程序员（现在是时候警告我对Forth的理解仅仅是那是我自己的理解；不要指望太多。）</p><p> Why the epigraph about Chuck Moore&#39;s VLSI tools? Because Forth is very radical. Black Square kind of radical. An approach to programming seemingly leaving out most if not all of programming:</p><p> 为什么关于Chuck Moore的VLSI工具的题词？因为Forth非常激进。黑方有点激进。一种编程方法似乎遗漏了大部分（如果不是全部）编程：</p><p> …Forth does it differently. There is no syntax, no redundancy, no typing. There are no errors that can be detected. …there are no parentheses. No indentation. No hooks, no compatibility. …No files. No operating system.</p><p> …Forth则有所不同。没有语法，没有冗余，没有打字。没有可以检测到的错误。 ……没有括号。没有缩进。没有钩子，没有兼容性。 …没有文件。没有操作系统。</p><p>  I&#39;ve never been a huge fan of suprematism or modernism in general. However, a particular modernist can easily get my attention if he&#39;s a genius in a traditional sense, with superpowers. Say, he memorizes note sheets upon the first brief glance like Shostakovich did.</p><p>  一般而言，我从来都不是超级至上主义或现代主义的忠实拥护者。但是，如果特定的现代主义者是具有超能力的传统意义上的天才，则很容易引起我的注意。说，他像肖斯塔科维奇一样，在第一眼便能一眼便能记住便条纸。</p><p> Now, I&#39;ve seen chip design tools by the likes of Cadence and Mentor Graphics. Astronomically costly licenses. Geological run times. And nobody quite knows what they do. To me, VLSI tools in 500 lines qualify as a superpower, enough to grab my attention.</p><p> 现在，我已经看到了Cadence和Mentor Graphics之类的芯片设计工具。天文数字昂贵的许可证。地质运行时间。而且没人知道他们在做什么。对我来说，有500条生产线的VLSI工具具有超强能力，足以吸引我的注意力。 </p><p>   I was intrigued with Forth ever since I read about it in Bruce Eckel&#39;s book on C++, a 198-something edition; he said there that &#34;extensibility got a bad reputation due to languages like Forth, where a programmer could change everything and effectively create a programming language of his own&#34;. WANT!</p><p>自从布鲁斯·埃克尔（Bruce Eckel）撰写的198年代的C ++书中读到它以来，我就对它深感兴趣。他在那儿说，“可扩展性”因诸如Forth之类的语言而声名狼藉，因为程序员可以改变一切并有效地创建自己的编程语言。想！</p><p> A couple of years later, I looked for info on the net, which seemed somewhat scarce. An unusually looking language. Parameters and results passed implicitly on a stack. 2 3 + instead of 2+3. Case-insensitive. Nothing about the extensibility business though.</p><p> 几年后，我在网上寻找了一些稀缺的信息。一种看起来异常的语言。参数和结果在堆栈上隐式传递。 2 3 +而不是2 + 3。不区分大小写。不过，关于可扩展性业务一无所获。</p><p> I thought of nothing better than to dive into the source of an implementation,  pForth – and I didn&#39;t need anything better, as my mind was immediately blown away by the following passage right at the top of  system.fth, the part of pForth implemented in Forth on top of the C interpreter:</p><p> 我认为没有什么比深入了解实现的源头pForth更好的了，我并不需要什么更好的东西，因为我的想法立即被系统顶部的以下段落震惊。在C解释器之上在Forth中实现的pForth的代码：</p><p> : ( 41 word drop ; immediate( That was the definition for the comment word. )( Now we can add comments to what we are doing! )</p><p> ：（下降41个字;立即（这是注释词的定义。）（现在，我们可以为正在执行的操作添加注释！）</p><p>  What this does is define a word (Forth&#39;s name for a function) called &#34;(&#34;. &#34;(&#34; is executed at compile time (as directed by IMMEDIATE). It tells the compiler to read bytes from the source file (that&#39;s what the word called, um, WORD is doing), until a &#34;)&#34; – ASCII 41 – is found. Those bytes are then ignored (the pointer to them is removed from the stack with DROP). So effectively, everything inside &#34;( … )&#34; becomes a comment.</p><p>  这样做是定义一个称为＆＃34;（＆＃34 ;.＆＃34;（＆＃34;）的单词（函数的名称），该单词在编译时执行（由IMMEDIATE指示）。它告诉编译器从源文件中读取字节（这就是所谓的um和WORD所做的事情），直到找到＆＃34;）– ASCII 41 –。然后忽略（指向它们的指针使用DROP从堆栈中删除）。有效地，＆＃34;（…）＆＃34;中的所有内容都变为注释。</p><p> Wow. Yeah, you definitely can&#39;t do that in C++. (You  can in Lisp but they don&#39;t teach you those parts at school. They teach the pure functional parts, where you  can&#39;t do things that you  can in C++. Bastards.)</p><p> 哇。是的，您绝对不能在C ++中做到这一点。 （您可以在Lisp中使用，但他们在学校不会教您这些部分。他们教的是纯功能性部分，您无法在C ++中做您可以做的事情。混蛋。）</p><p>  conditional primitives: IF  ( -- f orig ) ?comp compile 0branch conditional_key &gt;mark ; immediate: THEN  ( f orig -- ) swap ?condition &gt;resolve ; immediate: BEGIN  ( -- f dest ) ?comp conditional_key &lt;mark ; immediate: AGAIN  ( f dest -- ) compile branch swap ?condition &lt;resolve ; immediate: UNTIL  ( f dest -- ) compile 0branch swap ?condition &lt;resolve ; immediate: AHEAD  ( -- f orig ) compile branch conditional_key &gt;mark ; immediate</p><p>  条件原语：IF（-f orig）？comp编译0branch conditional_key＆gt; mark;即时：然后（f orig-）swap？condition＆gt; resolve;即时：开始（-f dest）？comp conditional_key＆lt; mark;即时：AGAIN（f dest-）编译分支交换？condition＆lt; resolve;即时：UNTIL（f dest-）编译0branch swap？condition＆lt; resolve;即时：AHEAD（-f orig）编译分支conditional_key＆gt; mark;即时 </p><p> Conditional  primitives?! Looks like conditional primitives aren&#39;t – they  define them here. This COMPILE BRANCH business modifies the code of a function that uses IF or THEN, at compile time. THEN – one part of the conditional – writes (RESOLVEs) a branch offset to a point in code saved (MARKed) by IF, the other part of the conditional.</p><p>有条件的原语？看起来条件原语不是-它们在这里定义它们。该COMPILE BRANCH业务在编译时修改使用IF或THEN的函数的代码。然后-有条件的一部分-将分支偏移写入（RESOLVE）到条件代码的另一部分IF保存（标记）的代码点。</p><p> It&#39;s as if a conventional program modified the assembly instructions generated from it at compile time. What? How? Who? How do I wrap my mind around this?</p><p> 好像常规程序在编译时修改了从其生成的汇编指令。什么？如何？谁？如何解决这个问题？</p><p>  Sort of understood how Forth code was represented and interpreted. Code is this array of &#34;execution tokens&#34; – function pointers, numbers and a few built-ins like branches, basically. A Forth interpreter keeps an instruction pointer into this array (ip), a data stack (ds), and a return stack (rs), and does this:</p><p>  有点理解Forth代码是如何表示和解释的。代码是＆＃34;执行令牌＆＃34;的此数组。 –基本来说，函数指针，数字和一些内置函数（如分支）。 Forth解释器将指令指针保存在此数组（ip），数据堆栈（ds）和返回堆栈（rs）中，并执行以下操作：</p><p> while( true) {  switch(*ip) {  //arithmetics (+,-,*...):  case PLUS: ds.push(ds.pop() + ds.pop()); ++ip;  //stack manipulation (drop,swap,rot...):  case DROP: ds.pop(); ++ip;  //literal numbers (1,2,3...):  case LITERAL: ds.push(ip[1]); ip+=2;  //control flow:   case COND_BRANCH:  if(!ds.pop()) ip+=ip[1];  else ip+=2;   case RETURN: ip = rs.pop();  //user-defined words: save return address &amp; jump   default: rs.push(ip+1); ip = *ip; }}</p><p> while（true）{  开关（* ip）{  //算术（+，-，* ...）：  案例加：ds.push（ds.pop（）+ ds.pop（））; ++ ip;  //堆栈操作（drop，swap，rot ...）：  案例DROP：ds.pop（）; ++ ip;  //文字数字（1,2,3 ...）：  大小写：ds.push（ip [1]）; ip + = 2;  //控制流： 情况COND_BRANCH：if（！ds.pop（））ip + = ip [1];否则ip + = 2; 案例返回：ip = rs.pop（）;  //用户定义的字词：保存返回地址＆amp;跳 默认值：rs.push（ip + 1）; ip = * ip; }}</p><p> That&#39;s it, pretty much. Similar, say, to the virtual stack machine used to implement Java. One difference is that compiling a Forth program is basically writing to the code array in a WYSIWYG fashion. COMPILE SOMETHING simply appends the address of the word SOMETHING to the end of the code array. So does plain SOMETHING when Forth is compiling rather than interpreting, as it is between a colon and a semicolon, that is, when a word is defined.</p><p> 就是这样。类似于用于实现Java的虚拟堆栈机。一个区别是，编译Forth程序基本上是以WYSIWYG方式写入代码数组。 COMPLEE SOMETHING只是将单词SOMETHING的地址附加到代码数组的末尾。当Forth进行编译而不是解释时，普通的SOMETHING也是如此，因为它位于冒号和分号之间，也就是说，当定义了一个单词时。</p><p>   simply appends {&amp;2dup,&amp;up,&amp;right,&amp;down,&amp;left,RETURN} to the code array. Very straightforward. There are no parameters or declaration/expression syntax as in…</p><p>   只需将{＆amp; 2dup，＆amp; up，＆amp; right，＆amp; down，＆amp; left，RETURN}附加到代码数组即可。非常简单。没有参数或声明/表达式语法，如…</p><p>  …to make it less than absolutely clear how the source code maps to executable code. &#34;C maps straightforwardly to assembly&#34;? Ha!  Forth maps straightforwardly to assembly. Well, to the assembly language of a virtual stack machine, but still. So one can understand how self-modifying code like IF and THEN works.</p><p>  …要使源代码如何映射到可执行代码还不是很清楚。 ＆＃34; C可以直接映射到程序集＆＃34 ;？哈！ Forth直接映射到装配体。嗯，关于虚拟堆栈机的汇编语言，但是仍然如此。因此，人们可以理解诸如IF和THEN之类的自我修改代码的工作方式。 </p><p> On the other hand, compared to drawRectangle, it is somewhat unclear what DRAW-RECTANGLE  does. What are those 2 values on the top of the stack that 2DUP duplicates before meaningful English names appear in DRAW-RECTANGLE&#39;s definition? This is supposed to be ameliorated by stack comments:</p><p>另一方面，与drawRectangle相比，DRAW-RECTANGLE的功能尚不清楚。 2DUP在有意义的英文名称出现在DRAW-RECTANGLE的定义中之前在堆栈顶部重复的那两个值是什么？应该通过堆栈注释来改善：</p><p>  …tells us that DRAW-RECTANGLE expects to find height at the top of the stack, and width right below it.</p><p>  …告诉我们DRAW-RECTANGLE希望在堆栈顶部找到高度，而在堆栈下方找到宽度。</p><p> I went on to sort of understand CREATE/DOES&gt; – a further extension of this compile-time self-modifying code business that you use to &#34;define defining words&#34; (say, CONSTANT, VARIABLE, or CLASS). The CREATE part says what should be done when words (say, class names) are defined by your new defining word. The DOES&gt; part says what should be done when those words are used. For example:</p><p> 我继续了解CREATE / DOES＆gt; –您可以使用此编译时自修改代码业务的进一步扩展，以“定义定义单词”。 （例如，常量，变量或类）。 CREATE部分说明了用新的定义词定义词（例如，类名）时应该怎么做。 部分说了使用这些词时应该怎么做。例如：</p><p> : CONSTANT  CREATE ,  DOES&gt; @; \ usage example:7 CONSTANT DAYS-IN-WEEKDAYS-IN-WEEK 2 + .  \ should print 9</p><p> ： 持续的 创建 ， 是否＆gt; @; \用法示例：连续7天DAYS-IN-WEEK 2+。 \应该打印9</p><p> CREATE means that every time CONSTANT is called, a name is read from the source file (similarly to what WORD would have done). Then a new word is created with that name (as a colon would have done). This word records the value of HERE – something like sbrk(0), a pointer past the last allocated data item. When the word is executed, it pushes the saved address onto the data stack, then calls the code after DOES&gt;. The code after CREATE can put some data after HERE, making it available later to the DOES&gt; part.</p><p> CREATE意味着每次调用CONSTANT时，都会从源文件中读取一个名称（类似于WORD所做的事情）。然后使用该名称创建一个新单词（就像冒号一样）。该字记录了HERE的值-类似于sbrk（0），它是最后分配的数据项之后的指针。当执行该字时，它将保存的地址压入数据堆栈，然后在DOES＆gt;之后调用代码。 CREATE之后的代码可以在此处放置一些数据，以便稍后可用于DOES＆gt;部分。</p><p> With CONSTANT, the CREATE part just saves its input (in our example, 7) – the comma word does this: *HERE++ = ds.pop(); The DOES&gt; part then fetches the saved number – the @ sign is the fetch word: ds.push( *ds.pop() );</p><p> 使用CONSTANT，CREATE部分仅保存其输入（在我们的示例中为7）–逗号这样做：* HERE ++ = ds.pop（）; 然后，部分将获取保存的数字– @符号是获取词：ds.push（* ds.pop（））;</p><p> CONSTANT works somewhat similarly to a class, CREATE defining its constructor and DOES&gt; its single method:</p><p> CONSTANT的工作方式与类类似，CREATE定义其构造函数，DOES＆gt;它的单一方法： </p><p> class Constant def initialize(x) @x=x end def does() @x endenddaysInWeek = Constant.new(7)print daysInWeek.does() + 2</p><p>类常量 def initialize（x）@ x = x结束 def dos（）@x结束结尾daysInWeek = Constant.new（7）打印daysInWeek.does（）+ 2</p><p>  Another example is defining C-like structs. Stripped down to their bare essentials (and in Forth things tend to be stripped down to their bare essentials), you can say that:</p><p>  另一个示例是定义类似C的结构。精简为基本要素（在Forth中，事物往往精简为基本要素），您可以这样说：</p><p>  …simply gives 8 (the structure size) a new name Rectangle, and gives 0 and 4 (the members&#39; offsets) new names, width and height. Here&#39;s  one way to implement structs in Forth:</p><p>  …简单地给8（结构尺寸）一个新名称Rect​​angle，并给0和4（成员偏移量）一个新名称，宽度和高度。这是在Forth中实现结构的一种方法：</p><p> struct cell field width cell field heightconstant rectangle \ usage example: \ here CREATE is used just for allocationcreate r1 rectangle allot  \ r1=HERE; HERE+=82 r1 width !3 r1 height !: area dup width @ swap height @ * ;r1 area .  \ should print 6</p><p> 结构 单元场宽度 细胞场高度恒定矩形 \用法示例： \这里CREATE仅用于分配创建r1矩形分配\ r1 = HERE;这里+ = 82 r1宽度！3 r1高度！：区域dup宽度@交换高度@ *;r1区域。 \应该打印6</p><p> CELL is the size of a word; we could say &#34;4 field width&#34; instead of &#34;cell field width&#34; on 32b machines. Here&#39;s the definition of FIELD:</p><p> CELL是一个字的大小；我们可以说＆＃34; 4字段宽度＆＃34;而不是＆＃34;单元格字段宽度＆＃34;在32b机器上。这是FIELD的定义：</p><p> : field  ( struct-size field-size -- new-struct-size ) create over , + does&gt; @ + ;</p><p> ：字段（struct-size field-size-new-struct-size） 创建结束，+ 确实＆gt; @ +;</p><p> Again, pretty compact. The CREATE part stores the offset, a.k.a current struct size (OVER does ds.push(ds[1]), comma does *HERE++=ds.pop()), then adds the field size to the struct size, updating it for the next call to FIELD. The DOES&gt; part fetches the offset, and adds it to the top of the stack, supposedly containing the object base pointer, so that &#34;rect width&#34; or &#34;rect height&#34; compute &amp;rect.width or &amp;rect.height, respectively. Then you can access this address with @ or ! (fetch/store). STRUCT simply pushes 0 to the top of the data stack (initial size value), and at the end, CONSTANT consumes the struct size:</p><p> 再次，非常紧凑。 CREATE部分存储偏移量，即当前结构大小（OVER执行ds.push（ds [1]），逗号执行* HERE ++ = ds.pop（）），然后将字段大小添加到结构大小中，以将其更新为下次致电FIELD。 部分获取偏移量，然后将其添加到堆栈的顶部（假定包含对象基础指针），以使＆＃34; rect width＆＃34;或＆＃34;身高＆＃34;分别计算＆amp; rect.width或＆amp; rect.height。然后，您可以使用@或！访问该地址。 （获取/存储）。 STRUCT只需将0推入数据堆栈的顶部（初始大小值），最后，CONSTANT会使用结构大小： </p><p> struct  \ data stack: 0 cell  ( ds: 0 4 ) field width  ( ds: 4 ) cell  ( ds: 4 4 ) field height  ( ds: 8 )constant rectangle  ( ds: as before STRUCT )</p><p>结构\数据堆栈：0 像元（ds：0 4）场宽（ds：4） 像元（ds：4 4）场高（ds：8）恒定矩形（ds：和STRUCT一样）</p><p> You can further extend this to support polymorphic methods – METHOD would work similarly to FIELD, fetching a function pointer (&#34;execution token&#34;) through a vtable pointer and an offset kept in the CREATEd part.  A basic object system in Forth can thus be implemented in one screen (a Forth code size unit – 16 lines x 64 characters).</p><p> 您可以进一步扩展它以支持多态方法-METHOD的工作方式与FIELD相似，通过vtable指针和保留在CREATEd部分中的偏移量来获取函数指针（＆＃34;执行令牌＆＃34;）。因此，可以在一个屏幕中实现Forth中的基本对象系统（Forth代码大小单位– 16行x 64个字符）。</p><p> To this day, I find it shocking that you can  define defining words like CONSTANT, FIELD, CLASS, METHOD – something reserved to built-in keywords and syntactic conventions in most languages – and you can do it so compactly using such crude facilities so trivial to implement. Back when I first saw this, I didn&#39;t know about DEFMACRO and how it could be used to implement the defining words of CLOS such as DEFCLASS and DEFMETHOD (another thing about Lisp they don&#39;t teach in schools). So Forth was completely mind-blowing.</p><p> 直到今天，令您震惊的是，您可以定义诸如CONSTANT，FIELD，CLASS，METHOD之类的定义词-保留给大多数语言中的内置关键字和语法约定的东西-而且您可以使用如此简单的粗俗工具如此紧凑地完成它实施。当我第一次看到它的时候，我不知道DEFMACRO，以及如何将其用于实现CLOS的定义性单词，例如DEFCLASS和DEFMETHOD（关于Lisp，他们在学校没有教过的另一件事）。因此，Forth完全令人振奋。</p><p>  It seemed more suited for number crunching/&#34;systems programming&#34; than text processing/&#34;scripting&#34;, whereas it is scripting that is the best trojan horse for pushing a language into an organization. Scripting is usually mission-critical without being acknowledged as such, and many scripts are small and standalone. Look how many popular &#34;scripting languages&#34; there are as opposed to &#34;systems programming languages&#34;. Then normalize it by the amount of corporate backing a language got on its way to popularity. Clearly scripting is the best trojan horse.</p><p>  它似乎更适合于数字运算/系统编程。而不是文本处理/脚本编写，而正是脚本编写才是将一种语言推入组织的最佳特洛伊木马。脚本通常是任务关键型的，因此无法得到承认，并且许多脚本很小且独立。看看有多少种流行的＆＃34;脚本语言＆＃34;与＆＃34;系统编程语言＆＃34;相反。然后通过公司支持某种语言使其流行的数量对其进行标准化。显然，脚本是最好的特洛伊木马。</p><p> In short, there were few opportunities to play with Forth at work, so I didn&#39;t. I fiddled with the interpreter and with the metaprogramming and then left it at that without doing any real programming.</p><p> 简而言之，在工作中很少有机会和Forth一起玩，所以我没有。我摆弄了解释器和元编程，然后不做任何实际的编程就把它留给了。</p><p> Here&#39;s what Jeff Fox, a prominent member of the Forth community who&#39;ve worked with Chuck Moore for years, has to say about people like me:</p><p> 以下是与Chuck Moore合作多年的Forth社区杰出成员Jeff Fox对我这样的人的评价：</p><p> Forth seems to mean programming applications to some and porting Forth or dissecting Forth to others. And these groups don&#39;t seem to have much in common.</p><p> Forth似乎意味着对某些应用程序进行编程，并将Forth移植或将Forth解剖到其他应用程序。这些团体似乎没有太多共同之处。 </p><p> …One learns one set of things about frogs from studying them in their natural environment or by getting a doctorate in zoology and specializing in frogs. And people who spend an hour dissecting a dead frog in a pan of formaldehyde in a biology class learn something else about frogs.</p><p>…人们通过在自然环境中研究青蛙或通过获得动物学博士学位并专门研究青蛙来学习一套有关青蛙的知识。花一小时在生物学课上解剖一锅甲醛的死青蛙的人会学到关于青蛙的其他知识。</p><p> …One of my favorite examples was that one notable colorforth [a Forth dialect]  enthusiast who had spent years studying it, disassembling it, reassembling it and modifying it, and made a lot of public comments about it, but had never bothered running it and in two years of &#39;study&#39; had not been able to figure out how to do something in colorforth as simple as:</p><p> …我最喜欢的例子之一是一位著名的colorforth [Forth方言]爱好者，他花了很多年研究，分解，重新组装和修改它，并对它进行了很多公开评论，但从未打扰过它，并且在两年的学习中一直无法弄清楚如何在colorforth中做某事，例如：</p><p>  …[such Forth users] seem to have little interest in what it does, how it is used, or what people using it do with it. But some spend years doing an autopsy on dead code that they don&#39;t even run.</p><p>  ……[Forth用户]对它的功能，使用方式或使用它的人们似乎并不感兴趣。但是有些人花了数年的时间对甚至无法运行的死代码进行尸检。</p><p> Ouch. Quite an assault not just on a fraction of a particular community, but on language geeks in general.</p><p> 哎哟。不仅对特定社区的一小部分发动了袭击，而且对一般语言爱好者也发动了袭击。</p><p> I guess I feel that I could say that if it isn&#39;t solving a significant real problem in the real world it isn&#39;t really Forth.</p><p> 我想我可以说，如果不能解决现实世界中的重大现实问题，那真的不是Forth。</p><p> True, I guess, and equally true from the viewpoint of someone extensively using any non-mainstream language and claiming enormous productivity gains for experts. Especially true for the core (hard core?) of the Forth community, Forth being their only weapon. They actually live in Forth; it&#39;s DIY taken to the extreme, something probably unparalleled in the history of computing, except, perhaps, the case of Lisp environments and Lisp machines (again).</p><p> 我猜是对的，从某人广泛使用任何非主流语言并声称专家获得巨大生产力的角度来看，也是如此。对于Forth社区的核心（硬核？）尤其如此，Forth是他们的唯一武器。他们实际上住在福斯。 DIY达到了极致，这在计算历史上可能是空前的，除了Lisp环境和Lisp机器（再一次）。</p><p> Code running on Forth chips. Chips designed with Forth CAD tools. Tools developed in a Forth environment running on the bare metal of the desktop machine. No standard OS, file system or editor. All in recent years when absolutely nobody else would attempt anything like it. They  claim to be 10x to 100x more productive than C programmers (a generic pejorative term for non-Forth programmers; Jeff Fox is careful to put &#34;C&#34; in quotes, presumably either to make the term more generic or more pejorative).</p><p> 在Forth芯片上运行的代码。使用Forth CAD工具设计的芯片。在Forth环境中在台式机的裸机上运行的工具。没有标准的操作系统，文件系统或编辑器。在最近几年中，绝对没有其他人会尝试类似的事情。他们声称自己的生产率比C程序员高出10到100倍（非Forth程序员是通用的贬义词； Jeff Fox小心地将＆＃34; C＆＃34;用引号引起来，大概是使术语更通用或更多。贬义的）。 </p><p> …people water down the Forth they do by not exercising most of the freedom it offers… by using Forth only as debugger or a yet another inefficient scripting language to be used 1% of the time.</p><p>......通过仅作为调试器或又一效率的脚本语言来使用1％的时间来使用它的大部分自由，他们淹没了它的大部分自由。</p><p> Forth is about the freedom to change the language, the compiler, the OS or even the hardware design and is very different than programming languages that are about fitting things to a fixed language syntax in a narrow work context.</p><p> 第四是关于改变语言，编译器，操作系统甚至硬件设计的自由，并且与在狭窄的工作环境中拟合事物的编程语言非常不同。</p><p> What can be said of this? If, in order to &#34;really&#34; enter a programming culture, I need to both &#34;be solving a significant real problem in the real world&#34;  and exercising &#34;the freedom to change the language, the compiler, the OS or even the hardware design&#34;, then there are very few options for entering this culture indeed. The requirement for &#34;real world work&#34; is almost by definition incompatible with &#34;the freedom to change the language, the compiler, the OS and the hardware design&#34;.</p><p> 这可以说什么？如果，为了＆＃34;真的＆＃34;进入编程文化，我需要兼到＆＃34;在现实世界中解决一个重要的真正问题。并锻炼＆＃34;改变语言，编译器，操作系统甚至硬件设计的自由，那么确实有很少的选择进入这种文化。 ＆＃34的要求;现实世界工作＆＃34;几乎是根据定义与＆＃34不兼容;改变语言的自由，编译器，操作系统和硬件设计＆＃34;</p><p> And then it so happened that I started working on a real-world project about as close to Forth-level DIY as possible. It was our own hardware, with our own OS, our own compilers, designed to be running our own application. We did use standard CAD tools, desktop operating systems and editors, and had standard RISC cores in the chip and standard C++ cross compilers for them. Well, everyone has weaknesses. Still, the system was custom-tailored, embedded, optimized, standalone, with lots of freedom to exercise – pretty close to the Forth way, in one way.</p><p> 然后它发生了，我开始尽可能靠近第四级DIY的现实世界项目。这是我们自己的硬件，我们自己的操作系统我们自己的编译器，旨在运行我们自己的应用程序。我们确实使用标准CAD工具，桌面操作系统和编辑器，并为它们提供标准的RISC核心和标准C ++交叉编译器。好吧，每个人都有弱点。尽管如此，该系统仍然是定制的，嵌入式，优化的独立式，锻炼的自由度 - 非常接近四种方式。</p><p> One part of the system was an image processing co-processor, a variation on the VLIW theme. Its memory access and control flow was weird and limited, to the effect that you could neither access nor jump to an arbitrary memory address. It worked fine for the processing-intensive parts of our image processing programs.</p><p> 系统的一部分是图像处理协处理器，VLIW主题的变化。它的内存访问和控制流程是奇怪而有限的，既不能访问也不能跳转到任意内存地址。它对我们的图像处理程序的加工密集型部分工作了很好。</p><p> We actually intended to glue those parts together with a few &#34;control instructions&#34; setting up the plentiful control registers of this machine. When I tried, it quickly turned out, as was to be expected, that those &#34;control instructions&#34; must be able to do, well, everything – arithmetic, conditions, loops. In short, we needed a CPU.</p><p> 我们实际上打算将这些部件与一些＆＃34粘合在一起;控制指令＆＃34;设置本机的丰富控制寄存器。当我尝试时，它迅速出现，正如要预期的那样，那些＆＃34;控制指令＆＃34;必须能够做到，嗯，一切 - 算术，条件，环。简而言之，我们需要一个CPU。</p><p> We thought about buying a CPU, but it was unclear how we could use an off-the-shelf product. We needed to dispatch VLIW instructions from the same instruction stream. We also needed a weird mixture of features. No caches, no interrupts, no need for more than 16 address bits, but for accessing 64 data bits, and 32-bit arithmetic.</p><p> 我们考虑了购买CPU，但目前尚不清楚我们如何使用现成的产品。我们需要从相同的指令流中调度VLIW指令。我们还需要一种奇怪的功能混合。没有缓存，没有中断，不需要超过16个地址位，但要访问64个数据位，以及32位算术。 </p><p> We thought about making our own CPU. The person with the overall responsibility for the hardware design gently told me that I was out of my mind. CPUs have register files and pipeline and pipeline stalls and dependency detection to avoid those stalls and it&#39;s too complicated.</p><p>我们考虑过要制造自己的CPU。全面负责硬件设计的人轻轻地告诉我，我不在意。 CPU具有寄存器文件以及管道和管道停顿以及相关性检测功能，可以避免这些停顿，而且过于复杂。</p><p> And then I asked, how about a stack machine? No register file. Just a 3-stage pipeline – fetch, decode, execute. No problem with register dependencies, always pop inputs from the top of the stack, push the result.</p><p> 然后我问，堆栈机怎么样？没有注册文件。只是一个3级流水线-提取，解码，执行。寄存器相关性没有问题，总是从堆栈顶部弹出输入，然后推入结果。</p><p> He said it sounded easy enough alright, we could do that. &#34;It&#39;s just like my RPN calculator. How would you program it?&#34; &#34;In Forth!&#34;</p><p> 他说听起来很容易，我们可以做到。就像我的RPN计算器一样。您将如何编程？＆＃34; ＆＃34;在！！＆＃34;</p><p> I defined the instruction set in a couple of hours. It mapped to Forth words as straightforwardly as possible, plus it had a few things Forth doesn&#39;t have that C might need, as a kind of insurance (say, access to 16-bit values in memory).</p><p> 我在几个小时内定义了指令集。它尽可能直接地映射到Forth单词，此外，Forth还具有C可能不需要的一些东西（作为一种保险）（例如，访问内存中的16位值）。</p><p> This got approved and implemented; not that it became the schedule bottleneck, but it was harder than we thought. Presumably that was partly the result of  not reading &#34; Stack Computers: the new wave&#34;, and  not studying the chip designs of Forth&#39;s creator Chuck Moore, either. I have a feeling that knowledgable people would have sneered at this machine: it was trivial to compile Forth to it, but at the cost of complicating the hardware.</p><p> 这已经得到批准和实施；并不是说它成为计划的瓶颈，但这比我们想象的要难。大概部分原因是未阅读＆＃34; Stack Computers：新的潮流，也不是研究Forth的创造者Chuck Moore的芯片设计。我感觉有见识的人会嘲笑这台机器：将Forth编译成它是微不足道的，但是要付出使硬件复杂化的代价。</p><p> But I was satisfied – I got a general-purpose CPU for setting up my config regs at various times through my programs, and as a side effect, I got a Forth target. And even if it wasn&#39;t the most cost-effective Forth target imaginable, it was definitely a time to start using Forth at work.</p><p> 但是我很满意–我得到了一个通用CPU，可以通过我的程序在不同时间设置配置注册表，而且副作用是，我得到了Forth目标。即使它不是可以想到的最具成本效益的Forth目标，也绝对是时候开始在工作中使用Forth。</p><p> (Another area of prior art on stack machines that I failed to study in depth was  4stack – an actual VLIW stack machine, with 4 data stacks as suggested by its name. I was very interested in it, especially during the time when we feared implementation problems with the multi-port register file feeding our multiple execution units. I didn&#39;t quite figure out how programs would map to 4stack and what the efficiency drop would be when one had to spill stuff from the data stacks to other memory because of data flow complications. So we just went for a standard register file and it worked out.)</p><p> （我无法深入研究的堆栈计算机上的另一个现有技术领域是4stack – 4台真正的VLIW堆栈计算机，顾名思义，它具有4个数据堆栈。我对此非常感兴趣，尤其是在我们担心实现的时候多端口寄存器文件为我们的多个执行单元提供数据的问题我没有弄清楚程序如何映射到4stack，以及当人们不得不将数据从数据栈中溢出到其他内存时效率会下降多少，因为数据流的复杂性。因此，我们只是去了一个标准的寄存器文件，结果就解决了。） </p><p> The first thing I did was write a Forth cross-compiler for the machine – a 700-line C++ file (and for reasons unknown, the slowest-compiling C++ code that I have ever seen).</p><p>我做的第一件事是为机器编写一个Forth交叉编译器–一个700行的C ++文件（由于未知的原因，这是我见过的最慢的编译C ++代码）。</p><p> I left out all of the metaprogramming stuff. For instance, none of the Forth examples above, the ones that drove me to Forth, could be made to work in my own Forth. No WORD, no COMPILE, no IMMEDIATE, no CREATE/DOES&gt;, no nothing. Just colon definitions, RPN syntax, flow control words built into the compiler. &#34;Optimizations&#34; – trivial constant folding so that 1 2 + becomes 3, and inlining – :INLINE 1 + ; works just like : 1 + ; but is inlined into the code of the caller. (I was working on the bottlenecks so saving a CALL and a RETURN was a big deal.) So I had that, plus inline assembly for the VLIW instructions. Pretty basic.</p><p> 我忽略了所有元编程内容。例如，上面的所有Forth示例（将我带到Forth的示例）都无法在我自己的Forth中工作。没有字，没有编译，没有立即，没有创建/完成＆gt ;，什么也没有。只是冒号定义，RPN语法，内置在编译器中的流控制字。 ＆＃34;优化＆＃34; –平常不变的折叠，使1 2 +变为3，并内联–：INLINE 1 +;就像：1 +;但内联到调用者的代码中。 （我正在研究瓶颈，因此节省了CALL和RETURN是一件大事。）因此，我有了，再加上VLIW指令的内联汇编。很基本。</p><p> I figured I didn&#39;t need the more interesting metaprogramming stuff for my first prototype programs, and I could add it later if it turned out that I was wrong. It was wierd to throw away everything I originally liked the most, but I was all set to start writing real programs. Solving real problems in the real world.</p><p> 我认为我的第一个原型程序不需要更有趣的元编程内容，如果后来发现我错了，可以稍后再添加。抛弃我本来最喜欢的一切都是很奇怪的，但是我准备开始编写真正的程序了。解决现实世界中的现实问题。</p><p>  All kinds of attempts at libraries and small test programs aside, my biggest program was about 700 lines long (that&#39;s 1 line of compiler code for 1 line of application code). Here&#39;s a sample function:</p><p>  除了对库和小型测试程序的各种尝试之外，我最大的程序长约700行（这是1行编译器代码对于1行应用程序代码）。这是一个示例函数：</p><p> : mean_std  ( sum2 sum inv_len -- mean std )  \ precise_mean = sum * inv_len;  tuck u*  \ sum2 inv_len precise_mean  \ mean = precise_mean &gt;&gt; FRAC;  dup FRAC rshift -ro</p><p> ：mean_std（sum2 sum inv_len-平均值std）  \ precision_mean =总和* inv_len;  tuck u * \ sum2 inv_len precision_mean  \均值= precision_mean＆gt;＆gt; FRAC；  双重FRAC rshift -ro</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://yosefk.com/blog/my-history-with-forth-stack-machines.html">https://yosefk.com/blog/my-history-with-forth-stack-machines.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/机上/">#机上</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/stack/">#stack</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>