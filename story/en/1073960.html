<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>第24天代码的出现：集合计算Advent of Code Day 24: Computing with Sets</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Advent of Code Day 24: Computing with Sets<br/>第24天代码的出现：集合计算</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-19 00:01:15</div><div class="page_narrow text-break page_content"><p>Day 24 of Advent of Code naively involves implementing a machine that implements an imaginary assembly language, with a program given as the puzzle input. This must then be executed up to 9^14 times to search for the lowest and highest program inputs that yield a specific result.</p><p>《代码的出现》第24天天真地涉及到实现一台机器，它实现了一种假想的汇编语言，并将一个程序作为谜题输入。然后必须执行9^14次，以搜索产生特定结果的最低和最高程序输入。</p><p> Implementing it as an interpreter is computationally infeasible. I did this as a first pass, and it would have taken almost one hundred years of wall clock time to execute.</p><p>将其实现为解释器在计算上是不可行的。我做这件事是第一次，执行这件事几乎需要100年的挂钟时间。</p><p> Looking through the solutions posted to the  Advent of Code subreddit for Day 24, there were a wide variety of solutions, including:</p><p>查看第24天Code subreddit发布的解决方案，有多种解决方案，包括：</p><p>  My solution was to modify my interpreter to work on sets, to search multiple possibilities in parallel. It wasn’t similar to any I saw, so I thought I’d write it up here.</p><p>我的解决方案是修改我的解释器，使其能够处理集合，并行搜索多种可能性。它和我看到的都不一样，所以我想把它写在这里。</p><p>  First, let’s look at an interpreter for the specified ALU. Not shown is the step that parses the instructions. For example, the  &#34;mul x 0&#34;string is transformed into the Clojure representation  [:mul :x 0].</p><p>首先，让我们看看指定ALU的解释器。未显示解析指令的步骤。例如&#34；mul x 0和#34；字符串被转换为Clojure表示形式[：mul:x 0]。</p><p> ( defn machine [input] { :memory { :x  0  :y  0  :z  0  :w  0}  :input input})( def machine-ops { :mul *  :add +  :div ( fn [a b] (int (/ a b)))  :mod mod  :eql ( fn [a b] ( if (= a b)  1  0))})( defn advance [machine instr] ( let [[a b c] instr get-val ( fn [v] ( if (keyword? v) ( get-in machine [ :memory v]) v))] ( if (=  :inp a) (-&gt; machine ( assoc-in [ :memory b] (first ( :input machine))) ( update  :input rest)) ( assoc-in machine [ :memory b] (( machine-ops a) ( get-val b) ( get-val c))))))( defn run-program [machine instrs] (reduce advance machine instrs))</p><p>defn machine[input]{:memory{:x0:y0:z0:w0}:input-input}（def machine ops{:mul*：add+:div（fn[ab]（int（/ab））：mod mod:eql（fn[ab]（if（=ab）10））（defn advanced[machine instr]（让[abc]instr获得val（fn[v]（if（关键字？v）（进入机器[：内存v]））））]（if:inpa）（&gt；machine）（在[:memory b]中关联（第一个（：input machine））（更新：input rest））（在机器[:memory b]中关联）（机器操作a）（获取值b）（获取值c‘‘‘‘‘）’）（defn运行程序[machine instrs]（减少高级机器指令））</p><p> The  advancefunction takes a machine and an instruction, and returns a new machine advanced by that instruction. The  run-programfunction reduces the machine over a stream of instructions.</p><p>AdvancedFunction接受一台机器和一条指令，并返回一台由该指令推进的新机器。run PROGRAME（运行程序）功能通过一系列指令来减少机器。</p><p>  From here, the naive interpreter can be modified to operate on sets of integers, rather than integers.</p><p>从这里，可以修改naive解释器，使其对整数集而不是整数集进行操作。</p><p>  When executing an operation on two sets, for example  (+ a b), the result is a set that contains each possible value that applies  +to any member of  aand any member of  b. This is a cartesian operation between the sets.</p><p>当对两个集合（例如（+a b）执行操作时，结果是一个集合，其中包含应用于a的任何成员和b的任何成员的每个可能值。这是两个集合之间的笛卡尔运算。</p><p>  ;; In Clojure notation, Set A + Set B, each containing 1, 2 and 3(+  #{ 1  2  3}  #{ 1  2  3}) ;; [A0 + B0, A0 + B1, A0 + B2], [A1 + B0, A1 + B1, ...=&gt; [[ 2  3  4] [ 3  4  5] [ 4  5  6]] ;; All possibilities are concatenated together=&gt; [ 2  3  4  3  4  5  4  5  6] ;; And finally, they&#39;re placed in a set, which removes duplicates=&gt;  #{ 2  3  4  5  6}(*  #{ 1  2  3}  #{ 0})=&gt; [[ 0] [ 0] [ 0]=&gt; [ 0  0  0]=&gt;  #{ 0}(=  #{ 1  2}  #{ 0  1  3})=&gt; [[ 0  1  0] [ 0  0  0]]=&gt; [ 0  1  0  0  0  0]=&gt;  #{ 0  1}</p><p>;; 在Clojure记数法中，集合A+集合B，每个集合包含1，2和3（+#{1,2,3}{1,2,3}）；；[A0+B0，A0+B1，A0+B2]，[A1+B0，A1+B1，…=&gt；[2 3 4][3 4 5][4 5 6]；；所有可能性都连接在一起=&gt；[ 2  3  4  3  4  5  4  5  6] ;; 最后，他们&#39；重新放置在一个集合中，这将删除重复项=&gt#{2 3 4 5 6}（*{1 2 3}{0}）=&gt；[0][0][0]=&gt；[0]=&gt#{0}（#{1 2}{0 1 3}）=&gt；[[0 1 0][0 0]=&gt；[0 1 0 0 0]=&gt#{ 0  1}</p><p> The intention is to cull large segments of the search space in parallel, by fixing some inputs and leaving others floating.</p><p>这样做的目的是通过固定一些输入，让其他输入浮动，从而并行地剔除搜索空间的大部分。</p><p> Imagine we are looking to search for  a + b + c + d = 35, where each are between  1-9, inclusive.</p><p>想象一下，我们正在寻找a+b+c+d=35，其中每个都在1-9之间，包括1-9。</p><p>  (+  #{ 1}  ; a  #{ 1  2  3  4  5  6  7  8  9}  ; b  #{ 1  2  3  4  5  6  7  8  9}  ; c  #{ 1  2  3  4  5  6  7  8  9})  ; d=&gt;  #{ 4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28}</p><p>（+#{1}；a#{1 2 3 4 5 6 7 8 9}；b#{1 2 3 4 5 6 7 8 9}；c#{1 2 3 4 5 6 7 8 9}）；d=&gt#{ 4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28}</p><p>  False positives are possible. The cartesian product is blind to correlations between variables. For example,  (- x x)where  x = #{1 2}would return  #{-1 0 1}instead of exactly  #{0}.</p><p>假阳性是可能的。笛卡尔积对变量之间的相关性视而不见。例如，（-x x），其中x=#{12}将返回#{1 0 1}，而不是精确地返回#{0}。</p><p> However, false negatives are not possible. If the desired result is not found in a set, it is guaranteed that no combination of inputs would yield it, and that part of the search space can be skipped.</p><p>然而，假阴性是不可能的。如果在一个集合中找不到所需的结果，则可以保证输入的组合不会产生该结果，并且可以跳过该部分搜索空间。</p><p> Provenance is also not tracked. You know what possible results are, but not what inputs could have led to them.</p><p>出处也没有被追踪。你知道可能的结果是什么，但不知道是什么输入导致了这些结果。</p><p>   The machine is initialized with memory constaining  #{0}, which is the default initial value wrapped in a set.</p><p>机器用内存constaining#{0}初始化，这是封装在集合中的默认初始值。</p><p>  ( defn machine [input] { :memory { :x  #{ 0}  :y  #{ 0}  :z  #{ 0}  :w  #{ 0}}  :input input})( def machine-ops { :mul *  :add +  :div ( fn [a b] (int (/ a b)))  :mod mod  :eql ( fn [a b] ( if (= a b)  1  0))})( defn cartesian-op [op va vb] (into  #{} (for [a va b vb] ( op a b))))( defn advance [machine instr] ( let [[a b c] instr get-val ( fn [v] ( if (keyword? v) ( get-in machine [ :memory v])  #{v}))] ( if (=  :inp a) (-&gt; machine ( assoc-in [ :memory b] (first ( :input machine))) ( update  :input rest)) ( assoc-in machine [ :memory b] ( cartesian-op ( machine-ops a) ( get-val b) ( get-val c))))))( defn run-program [machine instrs] (reduce advance machine instrs))</p><p>defn machine[input]{:memory{:x{0}:y}:z{0}:w{0}:input-input}（def machine ops{:mul*：add+:div（fn[ab]（int（/ab））：mod mod mod:eql（fn[ab]（if（=ab）1 0））（defn笛卡尔运算[op-vb]（in#in#for[a]）（for[a]）（for[b]）（instr advanced machine]如果（：inp a）（&gt；机器（assoc in[：memory b]）（first（：input machine））（update:input rest））（assoc in machine[：memory b]（笛卡尔运算（machine ops a）（get val b）（get val c‘）；）（defn run program[machine instrs]（减少高级机器指令））</p><p> After the program has executed, the  :zmemory location is tested for inclusion of the value  0.</p><p>程序执行后，测试：zmemory位置是否包含值0。</p><p> In the worst case, the size of the sets may grow very large, and a circuit breaker would be needed - but it was not a necessary feature in order to solve Day 24.</p><p>在最坏的情况下，电视机的尺寸可能会变得非常大，需要一个断路器——但这不是解决第24天问题的必要功能。</p><p>  Now we’ve built an interpreter that can search inputs in parallel, it’s time to discuss the search strategy. Our inputs are  14digits long. Some digits in an input may be fixed to a single value, while others are left unknown, which is bound to the set  #{1 2 3 4 5 6 7 8 9}.</p><p>现在我们已经建立了一个可以并行搜索输入的解释器，现在是讨论搜索策略的时候了。我们的输入是14位数。输入中的一些数字可能固定为单个值，而其他数字则未知，这与集合#{1 2 3 4 6 7 9}有关。</p><p> I will use the notation  263xxxxxxxxxxxto represent an input where the first three digits are fixed to  263, and the rest left unknown.</p><p>我将使用符号263XXXXXXXXXX表示一个输入，其中前三位固定为263，其余数字未知。</p><p> The search function is passed a list of fixed and free numbers. It checks every variation of the first free number to see if the intended result is possible. If so, it sets that number as fixed and recurses further.</p><p>搜索函数会被传递一个固定号码和自由号码的列表。它会检查第一个自由数的每一个变化，以确定预期结果是否可能。如果是这样，它将该数字设置为固定值，并进一步递归。</p><p>   ( defn search [instrs fixed free] (apply concat (filter identity (for [i (first free)] ( let [inp (concat fixed [ #{i}] (rest free)) m ( run-program ( machine inp) instrs) mem ( get-in m [ :memory  :z])] (when (contains? mem  0) ( if ( empty? (rest free)) (conj fixed  #{i}) ( search instrs (conj fixed  #{i}) (rest free)))))))))</p><p>（defn search[instrs fixed free]（apply concat（filter identity）（针对[i（first free）]（让[inp（concat fixed[#i}]（rest free））m（运行程序（机器inp）instrs）mem（get in m[：memory:z]）（当（包含？mem 0）（如果（空的话）（rest free））（conj fixed#{i}）（search instrs（conj fixed#{i}）（rest free#）（rest#}）（rest free)))))41</p><p>   To parallelize the execution, all permutations of the first three numbers are checked independently in a threadpool. A search path starting from  263may look like:</p><p>为了并行执行，前三个数字的所有排列都会在线程池中独立检查。从263开始的搜索路径可能如下所示：</p><p>   On a single core of my Ryzen 3900X, testing  917xxxxxxxxxxxindicates without further recursion that this pattern will yield no answer, and takes 1231ms to execute.</p><p>在Ryzen 3900X的单核上，测试917xxxxxxxxxxxin无需进一步递归即可表明此模式不会产生任何答案，需要1231ms才能执行。</p><p> This excludes 31.4 billion possibilities from the search. The initial scalar implementation of the interpreter takes approximately 0.1ms to test a single number.</p><p>这将314亿种可能性排除在搜索之外。解释器的初始标量实现大约需要0.1ms来测试单个数字。</p><p> This means that ruling out the search space via the set approach gives us a speed up of approximately 2.5 million times.</p><p>这意味着通过set方法排除搜索空间会使我们的速度提高大约250万倍。</p><p> There are 729 possible values for the first three digits. Of these, 702 are immediately ruled out a single check. Others require recursion.</p><p>前三位有729个可能的值。其中，702人立即被排除在一张支票之外。其他需要递归。</p><p>  Part I of the puzzle asks for the highest input that returns the expected result, which is  91397187145896. This takes  75 seconds to compute, using all available cores.</p><p>谜题的第一部分要求返回预期结果的最高输入，即91397187145896。这需要75秒的时间来计算，使用所有可用的内核。</p><p> Part II of the puzzle asks for the lowest input that returns the expected result, which is  41178298586991. This takes  248 seconds to compute.</p><p>谜题的第二部分要求返回预期结果的最低输入，即41178298586991。这需要248秒来计算。</p><p> Additionally, the entire space can be searched, and  12,096 solutions can be retrieved in  3,486 seconds.</p><p>此外，可以搜索整个空间，在3486秒内检索12096个解决方案。</p><p> Not bad. But we can do better! In the next post, we’ll attempt to build a compiler to turn the ALU instructions into Rust.</p><p>不错。但我们可以做得更好！在下一篇文章中，我们将尝试构建一个编译器，将ALU指令转换为Rust。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/code/">#code</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/搜索/">#搜索</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>