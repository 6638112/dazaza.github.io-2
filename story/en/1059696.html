<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么试图闯入NT 3.1内核重新启动我的486DX4机器？ Why does trying to break into the NT 3.1 kernel reboot my 486DX4 machine?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why does trying to break into the NT 3.1 kernel reboot my 486DX4 machine?<br/>为什么试图闯入NT 3.1内核重新启动我的486DX4机器？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-22 13:05:45</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/bff2a714cd7081340512131d66996508.png"><img src="http://img2.diglog.com/img/2021/4/bff2a714cd7081340512131d66996508.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I installed Windows NT 3.1 on a Compaq ProSignia 3080 system, because of several reasons: I know that this machine was running Windows NT 3.1 when it was in productive use. And I think this machine was one of the machines Microsoft explicitly targeted with Windows NT. For improved performance, I maxed out the RAM at 128MB and swapped the socketed Intel 486DX-33 by an AMD enhanced 486DX4-SV8B (write-back cache and SMM) in a voltage adapter socket. I postponed dealing with BIOS support for 486DX4 processors, and jumpered the processor to a 2x multiplier. Without chipset support for L1 write-back and with a 2x multiplier, the processor is supposed to be software compatible to the Intel 80486DX2-66, which is a supported option for that system.</p><p>我在Compaq Prosignia 3080系统上安装了Windows NT 3.1，因为有几个原因：我知道这台机器正在运行Windows NT 3.1在生产性使用时。我认为这台机器是Microsoft明确定位Windows NT的机器之一。为了提高性能，我在128MB时将RAM最大限度地缩小，并在电压适配器插座中通过AMD增强的486DX4-SV8B（回写缓存和SMM）交换了插座的Intel 486DX-33。我推迟处理BIOS支持486DX4处理器，并将处理器跳到2倍乘数。如果没有芯片组支持L1回写和2倍乘法器，则处理器应该是Intel 80486DX2-66兼容的软件，这是该系统的支持选项。</p><p> While installing Windows NT 3.1 worked perfectly, I really like to tinker with my retro stuff. The Windows NT 3.1 CD comes with the full set of debugging symbols, I&#39;m curious into investigating why NetDDE throws an error into the event log, and the system crashes with a specific EISA ethernet card (which might be due to faulty hardware), so I decided to dive into kernel debugging. Setting up kernel debugging is straight-forward, once you realize you should use the  i386kd executable supplied with Windows NT 3.1 instead of  kd/ ntkd from the current Windows 10 develepmont kit.</p><p> 安装Windows NT 3.1完全工作时，我真的很想用我的复古的东西修补。 Windows NT 3.1 CD附带了全套调试符号，我很想调查NetDDE在事件日志中将错误投入错误，并且系统崩溃与特定的EISA以太网卡（可能是由于硬件故障导致的系统崩溃），所以我决定潜入核心调试。设置内核调试直截了当，一旦您实现了使用Windows NT 3.1提供的I386KD可执行文件，而不是来自当前Windows 10 DevelepMont套件的KD / NTKD。</p><p> As soon as I want to break in (using Ctrl-C in  i386kd), the target machine reboots instead of providing a  kd&gt; prompt.</p><p> 一旦我想打破（在I386KD中使用Ctrl-C），目标机器重新启动而不是提供KD＆gt;迅速的。</p><p>  There is no hardware watchdog active that reboots the machine when the kernel is interrupted for debugging</p><p>  在内核中断进行调试时，没有硬件看门狗活动将重新启动计算机</p><p> The USB-to-serial adapter I use (which seems to be a counterfeit PL2301) in the host communicates properly. It&#39;s not mis-sending some debugger commands as &#34;reboot system&#34; command (the KD protocol provides one, though!)</p><p> USB-to-erial适配器我在主机中使用（似乎是伪造PL2301）正常通信。它没有错误地发送一些调试器命令作为＆＃34;重启系统＆＃34;命令（KD协议提供一个，但是！）</p><p>  The Windows NT 3.1 kernel is incompatible with enhanced 486 processors. Specifically, it is incompatible with 486 processors providing the  CPUID instructions. Kernel debugging works fine with the 486DX-33 that was originally installed in the machine, and with the older non-enhanced core in a write-through Am486DX4-NV8T without SMM.</p><p>  Windows NT 3.1内核与增强型486处理器不兼容。具体地，它与提供CPUID指令的486个处理器不兼容。内核调试与最初安装在机器中的486dx-33，以及在无线电的写入am486dx4-nv8t中的旧的非增强核心。</p><p> If your goal is just toying around with NT 3.1 kernel debugging, you might want to use a processor that is compatible with Windows NT 3.1 out-of-the-box. If you are as curious as me, you might want to fix Windows NT. Keep reading in this case.</p><p> 如果您的目标只是用NT 3.1内核调试进行Toing，您可能希望使用与框中的Windows NT 3.1兼容的处理器。如果你和我一样好奇，你可能想要修复Windows NT。在这种情况下继续阅读。 </p><p>  The incompatibility is due to a bug in  KiSaveProcessorControlState (and a similar bug in the counterpart  KiRestoreProcessorControlState), which is called from three locations inside NTOSKRNL.EXE:</p><p>不兼容是由于KisaveProcessorControlstate的错误（以及对应于kirestoreProcessorControlState的类似错误），从Ntoskrnl.exe中的三个位置调用：</p><p> When an exception is reflected to the kernel debugger using  KdpTrap (If I use Ctrl-C to break into the kernel debugger, a breakpoint exception is raised from the break-in polling functionality in the timer tick interrupt)</p><p> 当使用kdptrap反映在内核调试器中（如果我使用ctrl-c打入内核调试器时，断点异常从计时器滴答中断中的断开轮询功能引发了一个断点异常）</p><p>  When  KiSaveProcessorState is invoked. This appears to never happen, as this function is neither exported nor called from inside NTOSKRNL if the control flow analysis by IDA in NTOSKRNL.EXE is exhaustive.</p><p>  当调用KisaveProcessorState时。如果NTOSKRNL.EXE中的IDA控制流分析穷举，则此功能似乎不会导出，也不是从NTOSKRNL中的导出，而不是从NTOSKRNL中调用。</p><p> This function is supposed to save the processor control registers into an extended  CONTEXT structure. Its disassembly looks like this:</p><p> 该功能应该将处理器控制寄存器保存到扩展的上下文结构中。它的拆卸看起来像这样：</p><p> .text:80106740 ; __stdcall KiSaveProcessorControlState(x).text:80106740 public _KiSaveProcessorControlState@4.text:80106740 _KiSaveProcessorControlState@4 proc near.text:80106740.text:80106740 dest = dword ptr 4.text:80106740.text:80106740 mov edx, [esp+dest].text:80106744 xor ecx, ecx.text:80106746 mov eax, cr0.text:80106749 mov [edx+0CCh], eax.text:8010674F mov eax, cr2.text:80106752 mov [edx+0D0h], eax.text:80106758 mov eax, cr3.text:8010675B mov [edx+0D4h], eax.text:80106761 mov [edx+0D8h], ecx.text:80106767 cmp ds:word_FFDFF138, 5.text:8010676F jb short @@before_pentium.text:80106771 mov eax, cr4.text:80106774 mov [edx+0D8h], eax.text:8010677A @@before_pentium:.text:8010677A mov eax, dr0.text:8010677D mov [edx+0DCh], eax.text:80106783 mov eax, dr1.text:80106786 mov [edx+0E0h], eax.text:8010678C mov eax, dr2.text:8010678F mov [edx+0E4h], eax.text:80106795 mov eax, dr3.text:80106798 mov [edx+0E8h], eax.text:8010679E mov eax, dr6.text:801067A1 mov [edx+0ECh], eax.text:801067A7 mov eax, dr7.text:801067AA mov dr7, ecx.text:801067AD mov [edx+0F0h], eax.text:801067B3 sgdt fword ptr [edx+0F6h].text:801067BA sidt fword ptr [edx+0FEh].text:801067C1 str word ptr [edx+104h].text:801067C8 sldt word ptr [edx+106h].text:801067CF retn 4.text:801067CF _KiSaveProcessorControlState@4 endp</p><p> .text：80106740; __stdcall kisaveprocessorcontrolstate（x）.text：80106740 public _kisaveprocessorcontrolstate@4.text：80106740 _kisaveProcessorControlstate @ 4 Proc yourt.text：80106740.Text：80106740.Text：80106740.Text：80106740 Mov EDX，[ESP + Dest ] .Text：80106744 XOR ECX，ECX.Text：80106746 MOV EAX，CR0.Text：80106749 MOV [EDX + 0CCH]，EAX.Text：8010674F Mov EAX，CR2.Text：80106752 Mov [EDX + 0D0H]，EAX。文本：80106758 MOV EAX，CR3.Text：8010675B MOV [EDX + 0D4H]，EAX.Text：80106761 MOV [EDX + 0D8H]，ECX.Text：80106767 CMP DS：Word_FFDFF138，5.Text：8010676F JB Short @@ Breat_pentium .text：80106771 mov eax，cr4.text：80106774 mov [edx + 0d8h]，eax.text：8010677a @@ breat_pentium：.text：8010677a mov eax，dr0.text：8010677d mov [edx + 0dch]，eax.text ：80106783 MOV EAX，DR1.Text：80106786 MOV [EDX + 0E0H]，EAX.Text：8010678C MOV EAX，DR2.Text：8010678F MOV [EDX + 0E4H]，EAX.Text：80106795 Mov EAX，DR3.Text：80106798 mov [edx + 0e8h]，eax.text：8010679e mov eax，dr6.text：801067a1 mov [edx + 0ch]，eax.text：801067a7 mov eax，dr7.text：80106 7aa mov dr7，ecx.text：801067AD mov [edx + 0f0h]，eax.text：801067b3 sgdt fword ptr [edx + 0f6h] .text：801067ba sidt fword ptr [edx + 0feh] .text：801067c1 str word ptr [edx + 104h] .text：801067C8 SLDT Word PTR [EDX + 106H] .text：801067CF retn 4.text：801067CF _KisaveProcessorControlstate @ 4 EPEP</p><p> This function is supposed to save all control register (CR0, CR2, CR3, and CR4 on pentium and later processors), all debug registers (DR0-DR3, DR6, DR7) and various global protected mode settings (the address of the GDT, the address of the IDT, the selector of the active TSS and the selector of the LDT). To detect the processor type, it uses a value from the KPRCB (Kernel Processor Control Block). The KPRCB is part of the KPCR (Kernel Processor Control Region). The KPRCB for the boot processor (or the only processor on uniprocessor systems) is located at virtual address  FFDFF120, which is hard-coded into this method.  Geoff Chappell writes this about the relevant part of the KPRCB in NT 3.1:</p><p> 该功能应该保存所有控制寄存器（CR0，CR2，CR3和CR4上的Pentium和更高版本处理器），所有调试寄存器（DR0-DR3，DR6，DR7）和各种全局保护模式设置（GDT的地址， IDT的地址，活动TS的选择器和LDT的选择器）。要检测处理器类型，它使用KPRCB（内核处理器控制块）的值。 KPRCB是KPCR（内核处理器控制区域）的一部分。用于引导处理器的KPRCB（或单处理器系统上的唯一处理器）位于虚拟地址FFDFF120，其硬编码为此方法。 Geoff Chappell在NT 3.1中写下了KPRCB的相关部分：</p><p>  These members of the KPCRB are initialized by  KiSetProcessorType, which identifies the relevant processors correctly (but be aware that it mistrusts processors that report a CPUID feature level above 3 and considers them as &#34;generic non-CPUID capable 586 compatible processors&#34;. The byte at offset 18 is set to 4 for 486 processors, 5 for Pentium processors and 6 for Pentium Pro and Pentium II/III processors. The byte at offset 19 is a boolean flag that indicates whether the processor support CPUID and it behaves &#34;reasonable&#34;.</p><p>  KPCRB的这些成员被KisetProcessorType初始化，它正确标识了相关处理器（但请注意，它不信任报告高于3的CPUID功能级别的处理器，并将其视为＆＃34;通用非CPUID的586兼容处理器＆＃34 ;。偏移量18的字节设置为4个486处理器，5用于Pentium Pro和Pentium II / III处理器的6个。偏移量19的字节是一个布尔标志，指示处理器是否支持CPUID并表现＆＃34;合理＆＃34; </p><p> A very attentive reader might already have noticed the bug: The CMP instruction uses the  word at address  FFDFF138 (which is 18h bytes into the KPRCB), instead of the  byte at that address. This means the byte at offset 19h in the KPRCB is considered part of the model number. If a processor supports CPUID, its model number is considered to be 256 bigger than it actually is. This means Windows NT 3.1 treats a CPUID capable 80-4-86 processor as 80-260-86 processor. And as 260 is way larger than 5 (Pentium), that processor better had CR4.</p><p>一个非常细心的读者可能已经注意到了错误：CMP指令使用地址FFDFF138（18h字节进入KPRCB），而不是该地址的字节。这意味着KPRCB中的偏移量19h的字节被认为是型号的一部分。如果处理器支持CPUID，则其型号被认为是比实际更大的256。这意味着Windows NT 3.1将CPUID处理80-4-86处理器视为80-260-86处理器。随着260的方式大于5（奔腾），该处理器更好地具有CR4。</p><p>  The fix is obvious once the bug is identified. The instruction  cmp ds:word_FFDFF138, 5 only appears twice in NTOSKRNL.EXE, specifically in  KiSaveProcessorControlState and  KiRestoreProcessorControlState, and it needs to be patched to be a byte compare instead of a word compare. Use your favorite hex editor to patch  66 83 3D 38 F1 DF FF 05 to  90 80 3D 38 F1 DF FF 05, two times. This fix applies both the NTOSKRNL.EXE from the original NT 3.1 Advanced Server distribution as well as NT 3.1 SP3.</p><p>  一旦识别出错误，修复很明显。指令cmp ds：word_ffdff138,5仅在Ntoskrnl.exe中显示两次，特别是在KisaveProcessorControlstate和KirestoreProcessorControlstate中，并且需要修补为字节比较而不是单词比较。使用您最喜爱的六十三38 f1 df 05至90 34 f1 df 05，两次。此修复程序从原始NT 3.1高级服务器分发以及NT 3.1 SP3应用NTOSKRNL.EXE。</p><p>  8  I see your  NOP ( 90h), and raise you an explicit  DS prefix ( 3Eh). It&#39;s all about the  style points! :-) Any instruction with a memory operand can have a segment prefix. In this case, the  DS prefix is implicit/implied, but it can be explicitly specified without changing the meaning of the instruction. Both ways work to pad the extra leftover byte of space, but the explicit  DS prefix does not change the instruction&#39;s execution speed, whereas the  NOP actually takes 1 cycle of time to execute (plus possible decoding). –  Cody Gray</p><p>  8我看到你的NOP（90h），并提高了一个明确的DS前缀（3eh）。它＆＃39;所有关于风格的点！ :-)具有内存操作数的任何指令都可以具有段前缀。在这种情况下，DS前缀是隐式/暗示的，但可以在不改变指令的含义的情况下明确指定它。这两种方式都可以解决额外的剩余空间的剩余字节，但显式DS前缀不会改变指令和＃39; S执行速度，而NOP实际上需要1个时间循环以执行（加上可能的解码）。  -  Cody Gray.</p><p>    By clicking “Post Your Answer”, you agree to our  terms of service,  privacy policy and  cookie policy</p><p>    点击“发布答案”，您同意我们的服务条款，隐私政策和Cookie政策</p><p>  Not the answer you&#39;re looking for? Browse other questions tagged         or  ask your own question.</p><p>  不是答案你和＃39;寻找？浏览其他标记的问题或提出您自己的问题。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://retrocomputing.stackexchange.com/q/19655/7932">https://retrocomputing.stackexchange.com/q/19655/7932</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/闯入/">#闯入</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/break/">#break</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/处理器/">#处理器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>