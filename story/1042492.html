<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Ruby 3.0的变化 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Ruby 3.0的变化 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-30 07:03:44</div><div class="page_narrow text-break page_content"><p>Ruby 3.0是主要的语言版本。核心团队努力保持向后兼容性，同时提供了一些巨大而令人兴奋的新功能。</p><p> Ractors：类似线程的对象，用于实现actor模型，并最终解除GVL（全局虚拟机锁）并实现真正的并发</p><p>   分离从2.7开始（已弃用），现已完全完成。这意味着关键字参数不是在哈希值之上的“语法糖”，并且它们永远不会隐式地相互转换：</p><p> 代码：def old_style（name，options = {}）end def new_style（name，** options）end new_style（＆＃39; John＆＃39;，{age：10}）＃Ruby 2.6：有效＃Ruby 2.7：警告：不建议使用最后一个参数作为关键字参数；也许应该在通话中添加**＃Ruby 3.0：ArgumentError（错误的参数数量（给定2个，预期为1个））new_style（＆＃39; John＆＃39;，年龄：10）＃=＆gt;作品h = {age：10} new_style（＆＃39; John＆＃39;，** h）＃=＆gt;有效，**是必填项＃仍允许不使用{}传递最后一个哈希参数：old_style（＆＃39; John＆＃39;，年龄：10）＃=＆gt;作品</p><p>  注意：在Ruby站点上，有一个大而详尽的解释，解释了分离的原因，逻辑和边缘情况，该解释是在2.7年初问世的，因此在这里我们将不再赘述。</p><p>   代码：block = proc {| * args，** kwargs |放置＆＃34; args =＃{args}，kwargs =＃{kwargs}＆＃34; }块。 call（1，2，a：true）＃Ruby 2.7：args = [1，2]，kwargs = {：a =＆gt; true}-如预期的那样＃Ruby 2.7：args = [1，2]，kwargs = {：a =＆gt; true}-相同的块。 call（1，2，{a：true））＃Ruby 2.7：＃警告：不建议将最后一个参数用作关键字参数＃args = [1，2]，kwargs = {：a =＆gt; true}-但尽管如此，还是提取为关键字args＃Ruby 3.0：＃args = [1、2，{：a =＆gt; true}]，kwargs = {} –不会尝试将哈希提取到关键字中，也不会出现错误/警告</p><p>  原因：参数转发在2.7中引入时，只能转发全有或全无。事实证明这还不够。前导参数的重要用法之一是诸如method_missing和其他DSL定义的方法之类的情况，这些情况需要传递给嵌套方法：some_symbol +所有原始参数。 </p><p>代码：def请求（method，url，标头：{}）放入＆＃34; ＃{ 方法 。大写}＃{url}（headers =＃{headers}）＆＃34; end def get（...）请求（：get，...）end get（＆＃39; https：//example.com&#39;，标头：{content_type：＆＃39; json＆＃39;}） ＃GET https://example.com（headers = {：content_type =＆gt;＆＃34; json＆＃34;}）＃调用和定义中都可能存在前置参数：def logging_get（message，.. ）放置消息get（...）结束日志记录（＆＃39; Logging＆＃39;，＆＃39; https：//example.com&#39;，标头：{content_type：＆＃39; json＆＃39; }）</p><p>  注意：“所有参数splat” ...应该是参数列表中的最后一条语句（在声明和调用上）</p><p>  在方法声明中，...之前的参数只能是位置（而不是关键字）参数，并且不能具有默认值（应为SyntaxError）；</p><p>  在方法调用中，...之前传递的参数不能为关键字参数（应为SyntaxError）；</p><p>  确保彻底检查标点符号，因为任何...都是无限范围的语法，这些构造是有效的语法，但不会达到预期的效果：def委托（...）＃调用时不带＆＃34;（） ＆＃34; -实际上解析为（p（）...）p ...＃不输出任何内容，但发出警告：警告：...在EOL时，应加括号吗？ ＃＆＃34;，＆＃34; 1之后意外丢失，只有一个参数：1 ... p（1 ...）＃打印＆＃34; 1 ...＆＃34; p（1，...）＃按预期方式打印：＃1＃5个最终代表（5）</p><p>  现在可以使用语法def method（）= statement定义仅一个语句的方法。 （语法不需要结尾，因此是“无尽定义”的绰号。）</p><p> 原因：Ruby的终结点（与C语言类似，{}不同）对于Rubyist来说通常是可以的，但是使小型实用程序方法看起来比他们应有的繁重。对于主体仅包含一个简短语句的小型实用程序方法，例如：…“正确”的定义可能看起来如此繁重，以至于人们会决定反对该定义，以使类更具可读性（相反，使类的客户端仅执行obj.internal.empty ？本身，从而减少语义）。在这种情况下，单行快捷方式定义可能会更改对实用程序方法创建的理解： </p><p>代码：def dbg = puts（＆＃34; DBG：＃{呼叫者。首先}＆＃34;）dbg＃打印：DBG：test.rb：3：＆lt; main＆gt;＆＃39; ＃方法定义支持各种参数：def dbg_args（a，b = 1，c：，d：6，＆amp; block）= puts（＆＃34;传递的Args：＃{[a，b，c，d ，block。call]}＆＃34;）dbg_args（0，c：5）{7}＃打印：传递了Args：[0，1，5，6，7]＃对于参数定义，（）是强制性的def方x = x ** 2＃语法错误，意外的输入终止-因为Ruby将其视为＃def square（x = x ** 2）＃... eg一个具有默认值的参数，它本身是引用的，并且没有方法主体＃这可以使def square（x）= x ** 2 square（100）＃=> 10000＃为避免混淆，禁止定义方法名称，例如＃foo =，类A＃SyntaxError＆＃34; setter方法不能在无休止的方法定义中定义＆＃34 ;： def attr =（val）= @attr = val＃其他后缀还可以：def attr？ （）= !! @attr def attr！ （）= @attr = true end＃很有趣，运算符方法也可以，包括＃== class A def ==（other）= true end p A。 new == 5＃=＆gt; true＃任何奇异的表达式都可以是方法body＃这可以正常工作：def read（name）= File。读（名字）。分割（＆＃34; \ n＆＃34;）。地图（＆amp;：strip）。拒绝（＆amp;：：empty？）。 uniq。排序＃或什至是什么意思？.. def weird（name）=开始数据= File。 read（名称）进程（数据）true抢救false end＃方法主体内部，不带括号的方法调用会导致语法错误：def foo（）= puts＆＃34; bar＆＃34; ＃^语法错误，意外的字符串文字，期望`do＆＃39;或＆＃39; {＆＃39;或＆＃39;（＆＃39;＃这是由于解析歧义而导致的，并且与其他一些地方对齐，例如x = 1 + sin y＃^语法错误，意外的tIDENTIFIER，期望keyword_do或＆＃39; {＆＃ 39;或＆＃39;（＆＃39;</p><p>  注意：最初的提议似乎是愚蠢的愚人节玩笑，然后每个人都突然喜欢上了它，并且在语法上稍作更改，它就被接受了；</p><p>  该功能被标记为EXPERIMENTAL，但它不会产生警告，它是有意的，请参阅其他＃17399中的讨论。</p><p>    原因：这很有趣。在2.7和3.0之间讨论了两个事实：在大多数其他语言中，单行模式匹配的顺序（＆lt; pattern＆gt;＆lt; operator＆gt;＆lt; data＆gt;）与在Ruby 2.7中引入的顺序（＆lt; data＆gt; ;＆lt; pattern＆gt;）中的内容；和“向右赋值运算符”的思想=>以获得更自然的链接。然后，在某个时候，想法汇聚得最为成功。</p><p>  讨论：功能＃17260（主模式匹配跟踪票），功能＃16670（反向顺序），功能＃15921（独立的向右赋值运算符），功能＃15799（废弃的“管道运算符”构想），在讨论哪种“向右赋值”出生于）</p><p>    代码：＃匹配并解压缩：{db：{用户：＆＃39; John＆＃39; ，角色：＆＃39; admin＆＃39; }} =＆gt; {db：{user：，role：}} p [user，role]＃=＆gt; [＆＃34; John＆＃34 ;,＆＃34; admin＆＃34;]＃模式匹配作为长时间实验的向右分配：File。阅读（＆＃39; test.txt＆＃39;）。分割（＆＃34; \ n＆＃34;）。地图（＆amp;：strip）。拒绝（＆amp;：：empty？）。首先（10）=> lines p lines＃文件的前10个非空行＃拆包+分配功能非常强大：（1 .. 10）。 to_a。洗牌=> [*之前，（2 .. 4）=＆gt;阈值，*在]＃...之后，在输入序列中，找到2..4范围内的第一个条目，将其放入`threshold`，＃并分割序列之前/之后的部分p [之前，threshold，之后]＃由于随机播放，您的结果可能会有所不同:)＃=＆gt; [[7，5，8]，3，[1，10，6，9，4，2]]＃事情真的可以很快失控：Time。现在。小时=> .. 9 | 18 .. =>非工作时间</p><p>  注意：功能标记为EXPERIMENTAL，会在尝试使用时发出警告，并且将来可能会更改； </p><p>但是简单的分配用法（数据=＆gt;变量）不被认为是实验性的，并且在这里仍然存在；</p><p>  一个可能不是很明显的怪癖：模式匹配只能对局部变量进行解构分配，因此使用=＆gt;作为赋值运算符，您将看到这些是语法错误：some_statement =＆gt; @x some_statement =＆gt; obj。 attr＃的意思是调用`obj.attr =`some_statement =＆gt; $ y＃...虽然也许不要使用全局变量:)</p><p>  在上述更改之后，重新引入了in以返回true / false（模式是否匹配），而不是引发NoMatchingPatternError。</p><p> 原因：新含义允许模式匹配与控制流程中的其他构造（例如迭代和常规条件）更紧密地集成在一起。</p><p>      代码：用户= {角色：＆＃39; admin＆＃39; ，登录：＆＃39; matz＆＃39; }（如果用户以{角色：＆＃39; admin＆＃39; ，name：}放置＆＃34;授予管理范围：＃{name}＆＃34;结束＃，否则只需进行常规操作，无需提高用户= [{名称：＆＃39; John＆＃39; ，角色：＆＃39;用户＆＃39; }，{名称：＆＃39; Jane＆＃39; ，registered_at：时间。 new（2017，5，8）}，{名称：＆＃39; Barb＆＃39; ，角色：＆＃39; admin＆＃39; }，{名称：＆＃39; Dave＆＃39; ，角色：＆＃39;用户＆＃39; }] old_users_range =时间。新（2016）..时间。新增功能（2019）＃仅针对某些通知选择管理员和旧用户用户。选择{|你担任{角色：＆＃39; admin＆＃39; } | {register_at：^ old_users_range}}＃=＆gt; [{：name =＆gt;＆＃34; Jane＆＃34 ;,：registered_at =＆gt; 2017-05-08 00:00:00 +0300}，{：name =＆gt;＆＃34; Barb＆＃34 ;, ：role =＆gt;＆＃34; admin＆＃34;}]</p><p>  注意：功能标记为EXPERIMENTAL，会在尝试使用时发出警告，并且将来可能会更改。</p><p>   代码：用户= [{名称：＆＃39; John＆＃39; ，角色：＆＃39;用户＆＃39; }，{名称：＆＃39; Jane＆＃39; ，角色：＆manager＆＃39; }，{名称：＆＃39; Barb＆＃39; ，角色：＆＃39; admin＆＃39; }，{名称：＆＃39; Dave＆＃39; ，角色：＆manager＆＃39; }]＃现在，您如何找到仅具有模式匹配功能的管理员？。＃Ruby 3.0：[*，{name：，role：＆＃39; admin＆＃39; }，*]＃注意模式：在中间放置一些东西，放置之前和之后的物品数量未知＆＃34; Admin：＃{name}＆＃34;结束＃=＆gt;管理员：Barb＃在不受限制的情况下选择值，第一个splat是非贪婪的：[* before，user，* after]的case用户将＆＃34;匹配之前：＃{before}＆＃34;放置＆＃34;匹配：＃{用户}＆＃34;比赛后放置＆＃34 ;：}＆＃34;之后## end＃比赛之前：[]＃比赛：{：name =＆gt;＆＃34; John＆＃34 ;,：role =＆gt;＆＃34; user＆＃34;}＃比赛后：[{：name =＆gt; ＆＃34; Jane＆＃34 ;,：role =＆gt;＆＃34; manager＆＃34;}，{：name =＆gt;＆＃34; Barb＆＃34 ;,：role =＆gt;＆＃34; admin＆＃ 34;}，{：name =＆gt;＆＃34; Dave＆＃34 ;,：role =＆gt;＆＃34; manager＆＃34;}]＃选择从何处开始播放时不考虑Guard子句：[ *，用户，*]（如果用户[：role] ==＆＃39; admin＆＃39;将＆＃34;用户：＃{用户}＆＃34;结束＃=＆gt; NoMatchingPatternError-它首先将John放入`user`中，＃然后才检查了guard子句，该子句不匹配使用（模式中有多个splat），＃应该恰好有两个，并且它们可能仅是第一个，而＃是最后一个元素：[first_user，*，{name：，角色：＆＃39;管理员＆＃39; }，*]＃^语法错误，意外*将＆＃34; Admin：＃{name}＆＃34; end＃仍然可以在任意位置使用splat：在[{name：first_user_name}，*，{name：last_user_name}]中的case用户将＆＃34;第一用户：＃{first_user_name}，最后一个用户：＃{last_user_name}＆ ＃34;结束＃=＆gt;第一个用户：John，最后一个用户：Dave </p><p>注意：功能标记为EXPERIMENTAL，会在尝试使用时发出警告，并且将来可能会更改。</p><p>  当类@@ variable被类的父级或所包含的模块覆盖时，将引发错误。此外，顶级类变量访问也会引发错误。</p><p> 原因：具有“非直观”访问规则的类变量通常被认为是不良做法。它们对于在整个类层次结构中跟踪某些内容仍然非常有用。但是，整个层次结构共享相同的变量这一事实可能会导致难以调试的错误，因此已进行了修正，以提高似乎无意的用法。</p><p>      代码：＃预期用途：父类定义了所有子类都可用的变量Good @@ registry = []＃假定它旨在存储所有子类def self。注册表@@ registry结束结束类GoodChild＆lt;自我防卫能力强。寄存器！ @@ registry＆lt;＆lt;自我@@ registry = @@ registry。 sort＃重新分配值-但它仍然是PARENT的变量结束端GoodChild。寄存器！ p好。注册表＃=＆gt; [GoodChild]＃意外使用：该变量在子级中定义，但随后父级将其更改为Bad def self类。腐败注册表！ @@ registry = []结束类BadChild＆lt;错误的@@ registry = {}＃这是一些变量，它属于THIS类def self。注册表@@ registry结束结束错误。腐败注册表！ ＃对于BadChild的作者来说可能是意外的，其祖先更改了变量BadChild。注册表＃下次尝试访问变量时，将引发错误＃2.7：=＆gt; []＃3.0：RuntimeError（BadChild的类变量@@ registry被Bad取代）＃如果所包含的模块突然更改类模块OtherRegistry @@ registry = {} end Good，则会引发相同的错误。包括OtherRegistry Good。注册表＃下次尝试访问变量时，将引发错误＃2.7：=＆gt; {}＃3.0：RuntimeError（GoodRegistry的类变量@@ registry被OtherRegistry覆盖）</p><p>  在2.7中已弃用的单例类定义中的yield现在是SyntaxError – Feature＃15575</p><p>  现在，分配给带编号的参数（在2.7中引入）是SyntaxError而不是警告。</p><p>  关于静态或渐进类型的可能解决方案以及Ruby代码中类型声明的可能语法的讨论已经开放了多年。在3.0版本中，Ruby的核心团队决定在单独的文件和单独的工具中检查类型的类型声明。因此，从3.0开始： </p><p>类型声明的语法如下（小示例）：类Dog attr_reader名称：String def initialize：（name：String）-＆gt; void def bark：（at：Person | Dog | nil）-＆gt;弦尾</p><p>  核心类的类型声明和标准库随语言一起提供；</p><p>  rbs库随Ruby一起提供，提供了用于根据声明检查代码中实际类型的工具；用于（在某种程度上）自动检测尚未键入的代码的实际类型；</p><p>  TypeProf是随Ruby 3.0捆绑提供的另一个工具（“ Type Profiler”），可通过“抽象解释”（无需实际执行代码即可遍历代码）自动检测Ruby的实际类型；</p><p> 为了更深入地了解，请查看这些工具的文档；邪恶火星人的弗拉基米尔·德门蒂耶夫（Vladimir Dementiev）的这篇文章也对工具和概念进行了详细研究。</p><p>    原因：主要是为了保持一致性。 Ruby 2.4中引入了Object＃clone（freeze：false）作为产生未冻结对象的唯一方法。 clone（freeze：true）基本上等同于clone + Frozen。</p><p>      代码：o =对象。新o。克隆（Frozen：true）。冻结？ ＃=＆gt;在Ruby 2.7中为false。在Ruby 3.0中为true o = Object。新的。冻结o。克隆（Frozen：false）。冻结？ ＃=＆gt;在Ruby 2.7和3.0中为false </p><p>专门的构造函数#initialize_clone（在克隆对象时调用）现在可以接收Frozen：参数（如果已将其传递给#clone）。</p><p> 原因：对于复合对象，如果没有此参数，则很难解决#initialize_clone中嵌套数据的冻结/取消冻结。</p><p>      代码：require＆＃39;设置＆＃39; set =设置[1，2，3]。冻结设置。冻结？ ＃=＆gt;真实设置。 instance_variable_get（＆＃39; @ hash＆＃39;）。冻结？ ＃=＆gt;正确，如预期的那样取消冻结= set。复制（frozen：false）未冻结。冻结？ ＃=＆gt;错误，如预期的那样冻结。 instance_variable_get（＆＃39; @ hash＆＃39;）。冻结？ ＃2.7：=＆gt;正确，仍然是＃3.0：=＆gt;假，应该是这样-如果Set已重新定义#initialize_clone unfrozen＆lt;＆lt; 4＃2.7：FrozenError（无法修改冻结的Hash：{1 =＆gt; true，2 =＆gt; true，3 =＆gt; true}）＃3.0：=＆gt; ＃＆lt;设置：{1、2、3、4}＆gt;</p><p>  注意：Ruby 3.0中适当的对象冻结引起了很多关注，这是由于引入了Ractors，如果真正地冻结了对象（因此可以安全地在并行的ractors之间共享），Ractors就会带来重要的区别。</p><p>  现在，当第二个参数（绑定）传递给eval时，评估代码中的__FILE__为（eval），而__LINE__从1开始（就像没有绑定一样）。在2.7之前，它是在绑定的上下文中进行评估的（例如，绑定来自的返回文件），在2.7上会打印警告；现在该行为被认为是最终的。</p><p> 原因：绑定可能会传递给eval，以便提供对评估所必需的某些上下文的访问（例如，此技术在模板引擎中经常使用）；但这会使__FILE__和__LINE__指向未实际评估的代码产生了意想不到的结果，这可能会引起误解，例如在错误处理方面。</p><p>      代码：＃文件a.rb类A def get_binding绑定结束端＃文件b.rb require_relative＆＃39; a＆＃39; eval（＆＃39; p [__FILE__，__LINE __]＆＃39;）＃不绑定eval（＆＃39; p [__FILE__，__LINE __]＆＃39;，A. new。get_binding）＃从另一个文件绑定＃ Ruby 2.6：＃[＆＃34;（eval）＆＃34;，1]＃[＆＃34; a.rb＆＃34;，3]＃Ruby 2.7：＃[＆＃34;（eval）＆＃34 ;，1]＃[＆＃34; a.rb＆＃34 ;, 3]＃警告：eval中的__FILE__可能不会返回绑定中的位置；使用Binding＃source_location代替＃警告：eval中的__LINE__可能不会返回绑定中的位置；使用Binding＃source_location代替＃Ruby 3.0：＃[＆＃34;（eval）＆＃34 ;, 1]＃[＆＃34;（eval）＆＃34 ;, 1] </p><p>原因：更改与Ractor的引入有关（请参见下文）：当在tracer之间共享对象时，是否冻结对象产生了不同。由于范围和正则表达式都具有不变的核心数据，因此认为冻结它们是正确的做法。</p><p>    代码：/ foo /。冻结？ ＃=＆gt;正确（42 ...）。冻结？ ＃=＆gt; true＃即使使用动态插值/构造正则表达式也会冻结。 ＃{rand（10）} /。冻结？ ＃=＆gt; true＃...但是当使用构造函数Regexp构造它们时不是。新（＆＃39; foo＆＃39;）。冻结？ ＃=＆gt; false＃...但范围始终冻结Range。新（＆＃39; a＆＃39;，＆＃39; b＆＃39;）。冻结？ ＃=＆gt; true＃定期地，由于无论如何都无法更改数据，因此冻结不会影响您的代码。 ＃但是，如果代码做了一些聪明的事情，则可能是这样：regexp = / ^ \ w + \ s * \ w * $ / regexp。 instance_variable_set（＆＃39; @ context＆＃39;，：name）＃2.7：好的＃3.0：FrozenError（无法修改冻结的Regexp：/ ^ \ w + \ s * \ w * $ /）＃...或RANGE = Time。新（2020,3,1）..时间。新（2020,9,1）def RANGE。自我。开始 。 strftime（＆＃39;％Y，％b％d＆＃39;）+＆＃39; -＆＃39; +自我。结束 。 strftime（＆＃39;％b％d＆＃39;）结束＃2.7：OK＃3.0：FrozenError（无法修改冻结的对象：2020-03-01 00:00:00 + 0200..2020-09 -01 00:00:00 +0300）＃另请注意，范围冻结不是＆＃34; deep＆＃34 ;： string_range =＆＃39; a＆＃39; ..＆＃39; z＆＃39; string_range。结束 。大写！ string_range＃=＆gt; ＆＃39; ..＆＃39; Z＆＃39; ＃clone（freeze：false）仍然允许解冻两个：unfrozen = RANGE</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://rubyreferences.github.io/rubychanges/3.0.html">https://rubyreferences.github.io/rubychanges/3.0.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/def/">#def</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1041881.html"><img src="http://img2.diglog.com/img/2020/12/thumb_feb0307586085b572c07461c5885df6e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1041881.html">在RBS中采用Ruby 3类型 </a></div><span class="my_story_list_date">2020-12-26 11:21</span></div><div class="col-sm"><div><a target="_blank" href="/story/1036013.html"><img src="http://img2.diglog.com/img/2020/11/thumb_a1fe6584030c6a7cb2547a0764fd0777.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1036013.html">StimulusReflex：使用Ruby on Rails构建现代的反应式Web界面</a></div><span class="my_story_list_date">2020-11-23 8:30</span></div><div class="col-sm"><div><a target="_blank" href="/story/1035840.html"><img src="http://img2.diglog.com/img/2020/11/thumb_11c826cfa4b68a0727ed56dfc94a9e82.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035840.html">我对Ruby类一无所知</a></div><span class="my_story_list_date">2020-11-22 8:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1035641.html"><img src="http://img2.diglog.com/img/2020/11/thumb_e3cca80340e666a775173cbbdc0b7a39.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035641.html">Ruby的静态类型：大规模采用冰糕</a></div><span class="my_story_list_date">2020-11-21 21:33</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>