<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Buildpacks与Dockerfiles Buildpacks vs. Dockerfiles</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Buildpacks vs. Dockerfiles<br/>Buildpacks与Dockerfiles </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-09 20:25:03</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/8de73e56dba35513364a52e804b55c41.jpeg"><img src="http://img2.diglog.com/img/2021/2/8de73e56dba35513364a52e804b55c41.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>BTW, we&#39;re ⚡ hiring Infra, SRE, Web, Mobile, and Data engineers at  Doximity (see roles) -- find out more about our  technical stack.</p><p>顺便说一句，我们正在Doximity雇用Infra，SRE，Web，移动和数据工程师（请参阅角色），以了解有关我们技术堆栈的更多信息。</p><p>  At Doximity, we are running more and more of our applications and services on Kubernetes. To help our teams move faster, we’ve built a platform around Kubernetes to get code from developer’s laptops into the cloud quickly and safely.</p><p>  在Doximity，我们正在Kubernetes上运行越来越多的应用程序和服务。为了帮助我们的团队更快地移动，我们围绕Kubernetes构建了一个平台，可将代码从开发人员的笔记本电脑快速安全地获取到云中。</p><p> When deploying to our platform, the first step is to containerize the application. Containerizing an application allows us to deploy and run it in a repeatable and reliable manner by packaging the application with its dependencies. Containerization also includes making configuration choices that enable an application to run better in a container environment, like logging to stdout. The outcome of containerizing an application is an image. Once a team has an image, they can run their application on the platform. But how do they get that image?</p><p> 部署到我们的平台时，第一步是将应用程序容器化。打包应用程序使我们可以通过打包应用程序及其依赖项来以可重复且可靠的方式部署和运行它。容器化还包括做出配置选择，使应用程序能够在容器环境中更好地运行，例如登录到stdout。容器化应用程序的结果是一个图像。一旦团队有了映像，他们就可以在平台上运行其应用程序。但是，他们如何获得该图像？</p><p> Let’s start at the beginning. As more of our development teams moved their applications onto our platform, they needed a way to continuously build and deploy their container images. We removed that burden by building it into our platform. We investigated different approaches to turning application source code into container images. Two of the most popular are Dockerfiles and buildpacks. In this post, I’ll explain the choices we’ve made in our platform to move our development teams from Dockerfiles to buildpacks.</p><p> 让我们从头开始。随着越来越多的开发团队将其应用程序移至我们的平台上，他们需要一种持续构建和部署其容器映像的方法。我们通过将其构建到平台中消除了这种负担。我们研究了将应用程序源代码转换为容器映像的不同方法。最受欢迎的两个是Dockerfiles和buildpacks。在这篇文章中，我将解释我们在平台中所做的选择，以将我们的开发团队从Dockerfiles迁移到buildpacks。</p><p>  A Dockerfile is a text file that contains commands that will be executed by Docker to build a container image. Dockerfiles always start with a FROM directive specifying the base image to start from. Subsequent commands build on top of and modify that base image.</p><p>  Dockerfile是一个文本文件，其中包含将由Docker执行以构建容器映像的命令。 Dockerfile始终以FROM指令开头，该指令指定要从其开始的基本映像。后续命令建立在该基础映像之上并对其进行修改。</p><p> Below is an example. This Dockerfile uses a ruby base image. The bulk of the Dockerfile contains commands to add libraries and packages needed to build or run the application. If you know about BuildKit, you can configure these commands to optimize for cache utilization and other features. The last part of a Dockerfile is what runs by default when we launch the image.</p><p> 下面是一个例子。该Dockerfile使用ruby基本映像。大部分Dockerfile包含用于添加构建和运行应用程序所需的库和包的命令。如果您了解BuildKit，则可以配置这些命令以优化缓存利用率和其他功能。 Dockerfile的最后一部分是启动映像时默认运行的内容。</p><p> FROM  ruby:2.6.6-alpine3.12  # Install tools RUN apk add  --no-cache  --update tool=v1.2.3 \ more-tools=v3.4.5 \ extra-tools=v6.7.8  # Setup non-root user RUN addgroup  -g 1000  -S app  &amp;&amp; adduser  -u 1000  -S  -D  -G app app # Create some folders, install bundler, configure bundler, run bundle install, move some files around, set some environment variables, configure yarn, configure registry access, … # Example of a cache-optimized command  RUN  --mount = type =cache,uid =1000,gid =1000,target =/app/.cache/yarn  \  --mount = type =cache,uid =1000,gid =1000,target =/app/.cache/node_modules  \  --mount = type =cache,uid =1000,gid =1000,target =/app/tmp/cache  \ yarn  install  --check-files  --non-interactive  --production  --modules-folder /app/.cache/node_modules  --verbose  &amp;&amp;  \  cp  -ar /app/.cache/node_modules node_modules  &amp;&amp;  \  SECRET_KEY_BASE =some-secret-key-base bundle  exec rails assets:precompile ENV  PORT 8080 EXPOSE  8080 CMD  [&#34;bundle&#34;, &#34;exec&#34;, &#34;rails&#34;, &#34;server&#34;]</p><p> FROM ruby​​：2.6.6-alpine3.12＃安装工具RUN apk添加--no-cache --update tool = v1.2.3 \ more-tools = v3.4.5 \ extra-tools = v6.7.8＃设置非root用户用户RUN addgroup -g 1000 -S app＆amp;＆amp; adduser -u 1000 -S -D -G app app＃创建一些文件夹，安装bundler，配置bundler，运行bundle install，移动一些文件，设置一些环境变量，配置yarn，配置注册表访问，…＃缓存示例-优化的命令RUN --mount =类型= cache，uid = 1000，gid = 1000，target = / app / .cache / yarn \ --mount =类型= cache，uid = 1000，gid = 1000，target = / app /.cache/node_modules \ --mount =类型= cache，uid = 1000，gid = 1000，target = / app / tmp / cache \ yarn install --check-files --non-interactive --production --modules-文件夹/app/.cache/node_modules --verbose＆amp;＆amp; \ cp -ar /app/.cache/node_modules node_modules＆amp;＆amp; \ SECRET_KEY_BASE =基于某些秘密密钥的包exec rails资产：预编译ENV PORT 8080 EXPOSE 8080 CMD [＆＃34; bundle＆＃34 ;,＆＃34; exec＆＃34 ;,＆＃34; rails＆＃34 ;, ＆＃34;服务器＆＃34;] </p><p>  If you’ve ever used Heroku or Cloud Foundry, then you’ve already used buildpacks.</p><p>如果您曾经使用过Heroku或Cloud Foundry，那么您已经使用过buildpack。</p><p> A  buildpack is a program that turns source code into a runnable container image. Usually, buildpacks encapsulate a single language ecosystem toolchain. There are buildpacks for Ruby, Go, NodeJs, Java, Python, and more.</p><p> buildpack是将源代码转换为可运行容器映像的程序。通常，构建包会封装单个语言生态系统工具链。有用于Ruby，Go，NodeJ，Java，Python等的buildpack。</p><p> These buildpacks can be grouped together into collections called a  builder. In a builder, each buildpack will inspect the application source code and  detect if it should participate in the build process. For example, a Go buildpack would look for files ending in  *.go, while a Ruby buildpack would look for  *.rb files. Once a buildpack (or set of buildpacks) has matched, it moves on to the  build step. That’s when the buildpack does its job. It might add a layer to the container image that contains a dependency, like the Go distribution, or it runs a command, like  go build.</p><p> 这些构建包可以组合在一起，称为“构建器”。在构建器中，每个buildpack将检查应用程序源代码并检测是否应参与构建过程。例如，Go构建包将查找以* .go结尾的文件，而Ruby构建包将查找* .rb文件。一旦一个构建包（或一组构建包）匹配，它将继续进行构建步骤。那就是buildpack完成工作的时候。它可能会在容器映像中添加一个包含依赖项的层（例如Go发行版），或者运行一个命令（例如go build）。</p><p>  There are a few places to find buildpacks these days.  Heroku, the originator of the buildpack idea, has their own repository. Recently,  Google has started integrating buildpacks into many of their cloud products. We chose to use  Paketo buildpacks for our platform for a few reasons. The Paketo project is open source, backed by the Cloud Foundry foundation, and has a full-time core development team that is sponsored by VMware. They’ve chosen to create many small, modular buildpacks that can be mixed, matched, and extended to serve a lot of different use cases. Underneath the covers, the Paketo buildpacks implement the  Cloud Native Buildpacks specification, meaning that we can write our own or find buildpacks from different projects that might fit other needs. They’re also really focused on building out a broad community around buildpacks. In fact, we’ve already contributed our  first buildpack to the Ruby ecosystem!</p><p>  这些天有些地方可以找到buildpack。构建包思想的发起者Heroku有自己的存储库。最近，Google已开始将buildpack集成到他们的许多云产品中。我们出于某些原因选择使用Paketo构建包作为平台。 Paketo项目是开源的，由Cloud Foundry基金会支持，并拥有一个由VMware赞助的全职核心开发团队。他们选择创建许多小型的模块化构建包，可以对其进行混合，匹配和扩展，以服务于许多不同的用例。在幕后，Paketo构建包实现了Cloud Native Buildpacks规范，这意味着我们可以编写自己的构建包或从可能适合其他需求的不同项目中找到构建包。他们还真正致力于围绕buildpack建立一个广泛的社区。实际上，我们已经为Ruby生态系统贡献了我们的第一个buildpack！</p><p>  Paketo has their own set of reference builders ( tiny,  base, or  full) that include support for Java, .NET Core, NodeJS, Go, PHP, Ruby, and static file deployments using NGINX or Apache HTTPD. For our platform, we wanted to tailor the set of available buildpacks to those we are using to build our applications. To do this, we created a custom builder. Our builder includes the Go and Ruby Paketo buildpacks.</p><p>  Paketo有自己的一组参考构建器（微小，基本或完整），包括对Java，.NET Core，NodeJS，Go，PHP，Ruby和使用NGINX或Apache HTTPD的静态文件部署的支持。对于我们的平台，我们想针对我们用来构建应用程序的构建包量身定制一组可用的构建包。为此，我们创建了一个定制构建器。我们的构建器包括Go和Ruby Paketo构建包。</p><p> Besides buildpacks, the builder also references another container image called a  stack. You can think of a stack like you would the base image defined by the  FROM directive in a Dockerfile. It&#39;s a starter image that the buildpacks can build on top of. A  stack is composed of a build-time image and a run-time image. The former is used when the buildpacks are analyzing the application source code and building the application’s container image. The latter is used as the base of the final application image. Just like the builder, a stack can be modified, and we’ve created our own based on the Paketo  full stack with a few modifications. Now that we’d put the buildpacks that our development teams use in a builder that runs on top of a stack customized for their needs, we were ready to start building applications.</p><p> 除了buildpacks之外，构建器还引用了另一个称为栈的容器映像。您可以像使用Dockerfile中FROM指令定义的基本映像那样来考虑堆栈。它是构建包可以构建在其上的入门映像。堆栈由构建时映像和运行时映像组成。当构建包正在分析应用程序源代码并构建应用程序的容器映像时，将使用前者。后者用作最终应用程序映像的基础。就像构建器一样，可以修改堆栈，并且我们基于Paketo完整堆栈创建了自己的堆栈，并进行了一些修改。现在，我们将开发团队使用的构建包放到了一个构建器中，该构建器运行在根据其需求定制的堆栈之上，我们准备开始构建应用程序。</p><p> Let’s take a step back though and spend a little bit of time explaining why we chose to integrate buildpacks into our platform.</p><p> 不过，让我们退后一步，花点时间解释为什么我们选择将buildpack集成到我们的平台中。 </p><p>   In making this decision, our primary concern was developer productivity. We wanted to onboard development teams to the new platform with the least amount of friction.</p><p>在做出此决定时，我们的主要关注点是开发人员的生产力。我们希望以最小的负担将开发团队加入新平台。</p><p> Our first approach was a simple one. We asked development teams to include a Dockerfile in their source code. The platform would use that Dockerfile to build their application container image before it was deployed. After a few of the teams completed their onboarding, we discovered a few issues with this approach. Familiarity with Docker and Dockerfile syntax is not universal. Even those with experience may not be equipped to write a Dockerfile that can quickly build (and rebuild) a small and secure image. It’s the type of knowledge that tends to get “cargo-culted” around a development organization.</p><p> 我们的第一种方法很简单。我们要求开发团队在其源代码中包含一个Dockerfile。该平台将在部署之前使用该Dockerfile构建其应用程序容器映像。在一些团队完成入职之后，我们发现了这种方法的一些问题。并不熟悉Docker和Dockerfile语法。即使是有经验的人，也可能不具备编写可以快速构建（和重建）小型安全映像的Dockerfile的能力。这是一种易于在开发组织中“培养”的知识类型。</p><p> It was clear that our development teams wanted something that “just worked,” and it was costly for them to develop and optimize their own Dockerfiles from scratch. This is where buildpacks really made the most sense. With buildpacks, our development teams didn’t need to write, really, anything. They didn’t need to worry about the size and security of their application image. And they didn’t need to worry about optimizing the build and rebuild times. The buildpacks can make those decisions for them. And we can rely upon an open-source project and its community to contribute to making those buildpacks work well.</p><p> 显然，我们的开发团队需要“工作正常”的东西，并且从头开始开发和优化自己的Dockerfile的成本很高。这正是buildpack最有意义的地方。使用buildpack，我们的开发团队无需编写任何东西。他们无需担心应用程序映像的大小和安全性。而且，他们无需担心优化构建和重建时间。构建包可以为他们做出那些决定。而且我们可以依靠一个开源项目及其社区来为使这些buildpack正常工作做出贡献。</p><p> While some folks might find using buildpacks to be restrictive compared to the complete freedom of Dockerfiles, most of our developers saw that freedom as a burden. They didn’t want to keep on top of language runtime vulnerabilities or figure out the best way to keep the image small without losing build time speed. As platform operators, choosing buildpacks meant big efficiencies for us as well. If we identified a dependency that required updating, we didn’t need to make pull requests to a dozen repositories to update a dozen Dockerfiles written a dozen different ways. Instead, we bumped the buildpack or stack to a newer version and rolled out the change with our builder.</p><p> 尽管有些人可能会发现使用buildpacks与Dockerfiles的完全自由相比是限制性的，但我们的大多数开发人员都将这种自由视为负担。他们不想继续关注语言运行时漏洞，也不想找出在不损失构建时间速度的情况下保持图像较小的最佳方法。作为平台运营商，选择buildpack对我们也意味着巨大的效率。如果我们确定需要更新的依赖项，则无需向十二个存储库发出拉取请求来更新以十二种不同方式编写的十二个Dockerfile。取而代之的是，我们将buildpack或stack升级到了较新的版本，并与构建器一起推出了更改。</p><p> By moving to buildpacks, we had removed a lot of onboarding friction for teams looking to move their applications to our platform.</p><p> 通过迁移到构建包，我们为希望将其应用程序迁移到我们平台的团队消除了很多入门障碍。</p><p>  Now that we had a few teams running their apps on our new platform, we wanted to ensure they were doing that securely. Many modern applications include dozens, if not thousands, of dependencies that perform many standard plumbing and infrastructural concerns. Our applications are no different. Keeping on top of the new features, bug fixes, and vulnerability alerts for all of these dependencies is a full-time job. We wanted a solution that could take some of that burden off of our development teams.</p><p>  现在我们已经有一些团队在新平台上运行他们的应用程序，我们希望确保他们能够安全地执行此操作。许多现代应用程序包含数十个（即使不是数千个）依赖项，这些依赖项执行许多标准的管道和基础设施问题。我们的应用程序没有什么不同。掌握所有这些依赖项的新功能，错误修复和漏洞警报是一项全职工作。我们想要一个可以减轻开发团队负担的解决方案。</p><p> Again, this is where buildpacks shine. The Paketo buildpacks are continuously updating upstream languages, runtimes, and frameworks in response to vulnerabilities, bug fixes, and new feature updates. Their core development team has built automated tooling that monitors those dependencies looking for new releases and updating them when needed. For a buildpack, like Ruby, the team has automation that polls the release sites for the Ruby runtime, ensuring it executes well against the stack, and updating the buildpack with automated pull requests. In many cases, these new dependencies can be available for our application developers to use almost as soon as they are released.</p><p> 同样，这是buildpack的亮点。 Paketo构建包不断更新上游语言，运行时和框架，以响应漏洞，错误修复和新功能更新。他们的核心开发团队构建了自动化工具，该工具可以监视那些依赖项以寻找新版本并在需要时进行更新。对于像Ruby这样的buildpack，该团队具有自动化的功能，可以轮询Ruby运行时的发布站点，以确保其在堆栈中执行得很好，并使用自动拉取请求更新buildpack。在许多情况下，这些新依赖项几乎可以在应用程序发布后立即提供给我们的应用程序开发人员使用。 </p><p> There are other choices that the Cloud Native Buildpack project has made that just make buildpacks more secure by default. The buildpacks execute as a dedicated non-root user when building and running applications on top of the stack. Each stack image has detailed metadata describing the image’s components, such as the base operating system and packages. Each stack has separate images for building and running applications. The packages on the runtime image are curated to exclude compilers and other tools that might pose security risks. You can learn more by checking out the Paketo  stacks repository.</p><p>Cloud Native Buildpack项目还提供了其他选择，这些选择可以使默认情况下的构建包更安全。在堆栈顶部构建和运行应用程序时，构建包将以专用的非root用户身份执行。每个堆栈映像都有详细的元数据，这些元数据描述映像的组件，例如基本操作系统和软件包。每个堆栈都有用于构建和运行应用程序的单独映像。选择了运行时映像上的软件包，以排除可能带来安全风险的编译器和其他工具。您可以通过检出Paketo堆栈存储库来了解更多信息。</p><p>  Once our development teams had started deploying their apps onto our platform, we wanted to make sure they could keep doing that quickly. Writing a Dockerfile that ensures that rebuilt images do so quickly and efficiently might as well be a “dark art.” Not only do you need to know how to get a dependency into the image, you need to know how to keep it cached in case you need it on a subsequent rebuild, and you need to know when to throw that cache away. Multiply that knowledge across the dozens of dependencies we commonly see in our apps. It’s not hard to see why our development teams would struggle to keep up their deployment velocity.</p><p>  一旦我们的开发团队开始将他们的应用程序部署到我们的平台上，我们就想确保他们可以继续快速地完成工作。编写一个Dockerfile来确保重建后的图像能够快速有效地执行，这可能也是“黑暗的艺术”。您不仅需要知道如何在映像中获得依赖关系，还需要知道如何在需要后续重建时将其保留在高速缓存中，并且还需要知道何时将该高速缓存扔掉。将这些知识乘以我们通常在应用程序中看到的数十种依赖项。不难看出为什么我们的开发团队会努力保持其部署速度。</p><p> Buildpacks  encode this knowledge into their implementation. When an application’s  Gemfile.lock changes, the Ruby buildpack knows that it needs to rebuild the layer that contains all of the application’s Ruby gems. It also knows how to do that in a way that keeps the gems that didn’t change. This means that builds happen quickly and efficiently. We aren’t wasting developer time waiting for the same dependencies to be downloaded and installed over and over again.</p><p> Buildpacks将这些知识编码到其实现中。当应用程序的Gemfile.lock更改时，Ruby buildpack知道需要重建包含所有应用程序Ruby gem的层。它还知道如何做到这一点，以保持不变的宝石。这意味着构建可以快速有效地进行。我们并没有浪费开发人员等待一遍又一遍地下载和安装相同依赖项的时间。</p><p> There are also performance benefits that we like as platform operators. Buildpacks can create layers that can be shared between applications. For example, if all of our applications are using the same version of Go, there is only one layer with that version of Go created in our image registry. On a Kubernetes node, there’s only one copy of that layer that can be read by all of the container instances running on that node. If another application that already uses that layer is running on that node, we don’t need to fetch that layer. All of this means we can be efficient in the space our registry consumes, reduce the disk usage of applications on a Kubernetes node, and reduce deploy times.</p><p> 作为平台运营商，我们还希望获得性能上的好处。 Buildpacks可以创建可以在应用程序之间共享的图层。例如，如果我们所有的应用程序都使用相同版本的Go，则在我们的图像注册表中仅创建一层具有该版本的Go。在Kubernetes节点上，该层上只有一个副本，该节点上运行的所有容器实例都可以读取该副本。如果已经在该节点上运行的另一个应用程序正在该节点上运行，则无需获取该层。所有这些意味着我们可以有效利用注册表所占用的空间，减少Kubernetes节点上应用程序的磁盘使用量，并减少部署时间。</p><p>  Many of the comparisons between buildpacks and Dockerfiles can feel like they boil down to “convention versus configuration”. It&#39;s a matter of building with Lego blocks instead of Play-Doh. Both ideas have their place. When choosing a project that prefers convention, we wanted to make sure we weren’t prevented from making everything configurable. The Paketo core development team has made the right kind of tradeoffs, creating buildpacks that are easily composable, configurable, and replaceable.</p><p>  buildpack和Dockerfile之间的许多比较都可以归结为“常规与配置”。这是用乐高积木而不是Play-Doh建造的问题。这两个想法都有自己的位置。在选择喜欢约定的项目时，我们希望确保不会妨碍我们进行所有配置。 Paketo核心开发团队进行了适当的权衡，创建了易于组合，可配置和可替换的构建包。</p><p> Technically, this means that the buildpack our development teams use to build Ruby applications is really composed of many smaller buildpacks. These buildpacks handle discrete parts of the build process, like installing Bundler, compiling static assets with the Rails Asset Pipeline, or declaring the command the application should use to run. Each of these pieces fit together, providing and requiring pieces of the build environment. Customizing the larger Ruby experience for our development teams can mean adding, removing, or reorganizing these pieces to fit better to their needs.</p><p> 从技术上讲，这意味着我们的开发团队用来构建Ruby应用程序的构建包实际上由许多较小的构建包组成。这些构建包处理构建过程中的离散部分，例如安装Bundler，使用Rails Asset Pipeline编译静态资产，或声明应用程序应使用的运行命令。这些部分中的每一个都可以放在一起，从而提供并需要构建环境的各个部分。为我们的开发团队定制更大的Ruby经验可能意味着添加，删除或重组这些片段，以更好地满足他们的需求。</p><p> Today, we use a custom builder that includes the buildpacks that our development teams care about. We’ve chosen those pieces that work for them, and as we learn more about their specific needs, we’ll continue to customize and streamline that set of buildpacks to make our image-building experience more useful, efficient, and secure.</p><p> 今天，我们使用一个自定义构建器，其中包含我们开发团队关心的构建包。我们已经选择了适合他们的作品，并且在我们进一步了解它们的特定需求时，我们将继续自定义和精简该组构建包，以使我们的图像构建体验更加有用，高效和安全。 </p><p>  Beyond just using the buildpacks provided by the Paketo project, we’ve also started to build our own. Let me tell you a bit about our first custom buildpack and our experience working with the Paketo core team to contribute it upstream.</p><p>除了使用Paketo项目提供的构建包外，我们还开始构建自己的构建包。让我告诉您一些有关我们的第一个定制buildpack以及我们与Paketo核心团队合作在上游做出贡献的经验。</p><p> The Paketo project, while still a relatively new community, is growing and our experiences collaborating with the core team have been very productive. When we first started exploring using buildpacks to build our Ruby applications, we found that the buildpack was missing a feature that we needed. We weren’t the only ones. There was already an open  GitHub issue that described the problem. We needed the Ruby buildpack to do  asset precompilation as part of the build process. After some guidance from the Ruby buildpack maintainers  (thank you  Sophie Wigmore &amp;  Ryan Moran), we decided to contribute to the Paketo project by creating the   rails-assets buildpack!</p><p> Paketo项目虽然仍是一个相对较新的社区，但仍在不断发展，我们与核心团队合作的经验非常有成​​效。当我们第一次开始探索使用buildpacks构建Ruby应用程序时，我们发现buildpack缺少我们需要的功能。我们不是唯一的。已经存在描述该问题的GitHub公开问题。在构建过程中，我们需要Ruby buildpack进行资产预编译。经过Ruby buildpack维护者的一些指导（感谢Sophie Wigmore和Ryan Moran），我们决定通过创建rails-assets buildpack为Paketo项目做出贡献！</p><p>  We appreciate being able to easily contribute to and collaborate with the Paketo project. They enabled us to contribute a new feature without the responsibility of continuing to build, maintain, and regularly release new versions.</p><p>  我们感谢能够轻松地为Paketo项目做出贡献并与之合作。它们使我们能够贡献新功能，而无需继续构建，维护和定期发布新版本。</p><p>  Beyond the buildpacks themselves, the Cloud Native Buildpacks project has enabled the community to develop a Kubernetes-native container-building service called  kpack. The service provides declarative Kubernetes resource definitions for mapping source code to buildpacks, and then on to images that can run in our platform. It constantly monitors the application source code, buildpacks, and stack, rebuilding our images when there are changes. As a platform team, having a platform that is as easy to maintain and upgrade as the applications running on it is key to our success in keeping it running.</p><p>  除了构建包本身之外，Cloud Native Buildpacks项目还使社区能够开发名为kpack的Kubernetes本地容器构建服务。该服务提供了声明性的Kubernetes资源定义，用于将源代码映射到buildpack，然后再映射到可以在我们的平台上运行的映像。它会不断监视应用程序源代码，buildpack和堆栈，并在发生更改时重建我们的映像。作为一个平台团队，拥有一个与在其上运行的应用程序一样易于维护和升级的平台，对于我们成功保持其运行至关重要。</p><p>  At Doximity, we aim to build great products for our clinicians. Internally, we are building a platform to help our teams deliver those products more efficiently. In the process, we’ve thought a lot about how to navigate the container image-building ecosystem. We decided to prioritize a buildpacks-based image building workflow over a Dockerfile one. I hope this helps as you make decisions about your own platform.</p><p>  在Doximity，我们致力于为临床医生打造优质产品。在内部，我们正在构建一个平台，以帮助我们的团队更有效地交付这些产品。在此过程中，我们对如何导航容器图像构建生态系统进行了很多思考。我们决定优先于基于Dockerfile的基于buildpacks的映像构建工作流。我希望这对您决定自己的平台有帮助。</p><p> Be sure to follow  @doximity_tech if you&#39;d like to be notified about new blog posts.</p><p> 如果您希望收到有关新博客文章的通知，请务必关注@doximity_tech。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://technology.doximity.com/articles/buildpacks-vs-dockerfiles">https://technology.doximity.com/articles/buildpacks-vs-dockerfiles</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/docker/">#docker</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/构建/">#构建</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>