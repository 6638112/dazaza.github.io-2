<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>git 2.31的亮点 Highlights from Git 2.31</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Highlights from Git 2.31<br/>git 2.31的亮点 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-16 07:28:06</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/d3532a4744f1ad0e950f23e2abd682c3.jpeg"><img src="http://img2.diglog.com/img/2021/3/d3532a4744f1ad0e950f23e2abd682c3.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The open source Git project  just released Git 2.31 with features and bug fixes from 85 contributors, 23 of them new. Last time  we caught up with you, Git 2.29 had just been released. Two versions later, let’s take a look at the most interesting features and changes that have happened since.</p><p>开源Git项目刚刚发布了Git 2.31，其中包含85个贡献者的功能和错误修复，其中23个新的。上次我们赶上了你，Git 2.29刚刚被释放。稍后两个版本，让我们来看看自从此发生的最有趣的功能和变化。</p><p>  Picture this: you’re at your terminal, writing commits, pulling from another repository, and pushing up the results when all of the sudden, you’re greeted by this unfriendly message:</p><p>  图片：你在你的终端，写作提交，从另一个存储库中拉动，并在突然突然推出结果，你是由这个不友好的消息打招呼：</p><p> Auto packing the repository for optimum performance. You may alsorun &#34;git gc&#34; manually. See &#34;git help gc&#34; for more information.</p><p> 自动打包存储库以获得最佳性能。你可以alsorun＆＃34; git gc＆＃34;手动。查看＆＃34; git帮助gc＆＃34;欲获得更多信息。</p><p> …and, you’re stuck. Now you’ve got to wait for Git to finish running  git gc --auto before you can get back to work.</p><p> ......，你被困。现在你必须等待git完成跑步git gc --auto，然后才能回到工作。</p><p> What happened here? In the course of normal use, Git writes lots of data: objects, packfiles, references, and the like. Some of those paths are optimized for write performance. For example, it’s much quicker to  write a  single “loose” object, but it’s faster to read a  packfile.</p><p> 这里发生了什么？在正常使用过程中，Git写了大量数据：对象，包装，引用等。其中一些路径是针对写性能进行的优化。例如，编写单个“松散”对象更快，但读取包文件更快。</p><p> To keep you productive, Git makes a trade-off: in general, it optimizes for the write path while you’re working, pausing every so often to represent its internal data-structures in a way that is more efficient to read in order to keep you productive in the long-run.</p><p> 要使您持续生产，Git会进行折衷：一般来说，它在您工作时为写路径进行优化，每次暂停其内部数据结构，以便更有效地读取长期以来一直保持富有成效。</p><p> Git has its own heuristics about when is a good time to perform this “pause,” but sometimes those heuristics trigger a blocking  git gc at the worst possible time. You could manage these data-structures yourself, but you might not want to invest the time figuring out when and how to do that.</p><p> Git有自己的启发式信息，何时是何时执行此类“暂停”，但有时候那些启发式触发最糟糕的时间触发阻塞Git GC。您可以自己管理这些数据结构，但您可能不希望投资时间讨论何时何时以及如何做到这一点。 </p><p> Starting in Git 2.31, you can get the best of both worlds with  background maintenance. This cross-platform feature allows Git to keep your repository healthy while not blocking any of your interactions. In particular, this will improve your  git fetch times by pre-fetching the latest objects from your remotes once an hour.</p><p>从Git 2.31开始，您可以获得与背景维护的世界上最好的。此跨平台功能允许Git保留您的存储库健康，同时不会阻止您的任何交互。特别是，这将通过预先获取每小时从遥控器中预订最新对象来改善您的GIT获取时间。</p><p> Getting started with background maintenance couldn’t be easier. Simply navigate your terminal to any repository you want to enable background maintenance on, and run the following:</p><p> 开始后台维护的入门不能更容易。只需将终端导航到您要启用后台维护的任何存储库，并运行以下内容：</p><p>  …and Git will take care of the rest. Besides pre-fetching the latest objects once an hour, Git will make sure that  its own data is organized, too. It will update its   commit-graph file once an hour, and pack any loose objects (as well as incrementally repack packed objects) nightly.</p><p>  ......而Git将照顾其余的。除了每小时预先获取最新的物体，Git也将确保其自己的数据也是组织。它将每小时一次更新其提交图文件，并将任何松散的对象（以及逐渐重新包装包装）包装。</p><p> Read more about this feature in  the  git maintenance documentation and learn how to customize it with   maintenance.* config options. If you have any trouble, you can check the  troubleshooting documentation.</p><p> 在GIT维护文档中阅读有关此功能的更多信息，并学习如何使用维护自定义。*配置选项。如果您有任何问题，可以检查故障排除文档。</p><p>   You may know that Git stores all data as “objects:” commits, trees, and blobs which store the contents of individual files. For efficiency, Git puts many objects into packfiles, which are essentially a concatenated stream of objects (this same stream is also how objects are transferred by  git fetch and  git push). In order to efficiently access individual objects, Git generates an index for each packfile. Each of these  .idx files allows quick conversion of an object id into its byte offset within the packfile.</p><p>   您可能知道Git将所有数据存储为“对象：”提交，树木和Blob，它存储单个文件的内容。为了效率，Git将许多对象放入PackFiles，这些对象基本上是一个连接的对象流（同一流也是通过Git获取和Git推送对象的方式。为了有效访问单个对象，Git为每个PackFile生成索引。这些.idx文件中的每一个允许将对象ID快速转换为包文件中的字节偏移量。</p><p> What happens when you want to go in the other direction? In particular, if all Git knows is what byte it’s looking at in some packfile, how does it go about figuring out which object that byte is part of?</p><p> 当你想进入另一个方向时会发生什么？特别是，如果所有Git都知道它在某些PackFile中看到的字节是什么，它是如何弄清楚字节是部分的？</p><p> To accomplish this, Git uses an aptly-named  reverse index: an opaque mapping between locations in a packfile, and the object each location is a part of. Prior to Git 2.31, there was no on-disk format for reverse indexes (like there is for the  .idx file), and so it had to generate and store the reverse index in memory each time. This roughly boils down to generating an array of object-position pairs, and then sorting that array by position (for the curious, the exact details can be found  here).</p><p> 为实现此目的，Git使用适当命名的反向索引：PackFile中的位置之间的不透明映射，并且每个位置的对象是其中的一部分。在git 2.31之前，没有用于反向索引的磁盘格式（如对于.idx文件），因此它必须在每次中生成并存储内存中的反向索引。这大致归结为生成对象位置对数组，然后按位置对数组进行排序（对于好奇，可以在此处找到确切的细节）。 </p><p> But this takes time. In the case of repositories with large packfiles, this can take a lot of time. To better understand the scale, consider an experiment which compares the time it takes to print the size of an object, versus the time it a takes to print that object’s contents. To simply print an object’s contents, Git uses the forward index to locate the desired object in a pack, and then it reassembles and prints out its contents. But to print an object’s  size in a packfile, Git needs to locate not just the object we want to measure, but the object immediately following it, and then subtract the two to find out how much space it’s using. To find the position of the first byte in the adjacent object, Git needs to use the reverse index.</p><p>但这需要时间。在具有大包装文件的存储库的情况下，这可能需要很多时间。为了更好地了解规模，考虑一个实验，该实验比较打印对象的大小所需的时间，而不是打印该对象的内容的时间。为了简单地打印对象的内容，Git使用前进索引来定位包中的所需对象，然后重新组装并打印其内容。但要在PackFile中打印对象的大小，Git不仅要定位我们要测量的对象，而且紧接着它的对象，然后减去两者以找出它使用了多少空间。要在相邻对象中找到第一个字节的位置，Git需要使用反向索引。</p><p> Comparing the two, it is more than  62 times slower to print the size of an object than it is to print that entire object’s contents. You can try this at home with  hyperfine by running:</p><p> 比较这两个，打印对象的大小比要打印整个对象的内容，它比打印的大小慢62倍。您可以通过运行通过HyperFine在家中尝试：</p><p> $ git rev-parse HEAD &gt;tip$ hyperfine --warmup=3 \ &#39;git cat-file --batch &lt;tip&#39; \ &#39;git cat-file --batch-check=&#34;%(objectsize:disk)&#34; &lt;tip&#39;</p><p> $ git rev-parse头＆gt; tip $ hyperfine --warmup = 3 \＆＃39; git cat-file --batch＆lt; tip＆＃39; \＆＃39; git cat-file  - 咬 - 检查=＆＃34;％（对象化：磁盘）＆＃34; ＆lt;提示＆＃39;</p><p> In 2.31, Git gained the ability to serialize the reverse index into a new, on-disk format with the  .rev extension. After generating an on-disk reverse index and repeating the above experiment, our results now show that it takes roughly the same amount of time to print an object’s contents as it does its size.</p><p> 在2.31中，GIT获得了与.Rev扩展的新磁盘格式序列化反向索引。在生成磁盘反向索引并重复上述实验后，我们的结果表明，在其大小的情况下打印对象的内容需要大致相同的时间。</p><p> Observant readers may ask themselves why Git even needs to bother using a reverse index. After all, if you can print the contents of an object, then surely printing that object’s size is no more difficult than knowing how many bytes you wrote when printing the contents. But, this depends on the size of the object. If it’s enormous, then counting up all of its bytes is much more expensive than simply subtracting.</p><p> 敏锐的读者可能会问自己为什么需要使用反向索引来打扰的git。毕竟，如果可以打印对象的内容，那么肯定打印该对象的大小并不比知道打印内容时写入多少字节。但是，这取决于对象的大小。如果它是巨大的，那么计算所有字节都比简单的减去更昂贵。</p><p> Reverse indexes can help beyond synthetic experiments like these: when sending objects for a fetch or push, the reverse index is used to send object bytes directly from disk. Having a reverse index computed ahead of time makes this process run faster.</p><p> 反向索引可以帮助超越合成实验，如这些：当向获取或推送发送对象时，反向索引用于直接从磁盘发送对象字节。提前计算的反向指数使得此过程运行得更快。</p><p> Git doesn’t generate  .rev files by default yet, but you can experiment with them yourself by running  git config pack.writeReverseIndex true, and then repacking your repository (with  git repack -Ad). We have been using these at GitHub for the past couple of months to enable dramatic improvements in many different Git operations.</p><p> Git默认情况下不会生成.REV文件，但您可以通过运行Git Config Pack.WriteReverseIndex True来尝试自己，然后重新包装存储库（带Git Repack -Ad）。我们在Github上使用了这几个月，以便在许多不同的GIT操作中实现戏剧性的改进。 </p><p>   We’ve talked on this blog before about the  commit-graph file. It’s an incredibly useful serialization of common information about commits, like which parents they have, what their root tree is, and so on. (For a more detailed exposition, the blog post series beginning  here is a great exposition). Commit graphs also store information about a commit’s   generation number, which can be used to accelerate many kinds of commit walks. In Git 2.31, a new kind of generation number was used, which can improve performance further in certain situations.These patches were contributed by  Abhishek Kumar, a  Google Summer of Code student.</p><p>在The Commit-Graph文件之前，我们在此博客上介绍了此博客。这是一个有关提交的常见信息的非常有用的序列化，与他们拥有的父母一样，他们的根树是什么，依此类推。 （对于更详细的博览会，博客帖子系列开始这里是一个很好的博览会）。提交图还存储有关提交的生成号码的信息，可以用于加速许多种类的散步。在Git 2.31中，使用了一种新的一代数量，这可以在某些情况下进一步提高性能。这些补丁是由代码学生的谷歌夏季的Abhishek Kumar贡献。</p><p> In recent versions of Git, it has become easier to change the default name for the main branch in a new repository with  the  init.defaultBranch configuration. Git has always tried to check out the branch at the  HEAD of your remote (i.e., if the remote’s default branch was “ foo“, then  git clone would try to checkout  foo locally), but this hasn’t worked with empty repositories.In Git 2.31, this now works with empty repositories, too. Now if you are cloning a newly-created repository locally to start writing the first patches, your local copy will respect the default branch name set by the remote, even if there aren’t any commits yet.</p><p> 在最近的Git版本中，在具有init.defaultbranch配置的新存储库中更容易更改主分支的默认名称。 Git一直试图检查遥控器头部的分支（即，如果遥控器的默认分支是“foo”，则Git Clone会尝试在本地结账），但这尚未使用空的存储库.in Git 2.31，现在也适用于空的存储库。现在，如果您克隆了在本地创建的新创建的存储库开始编写第一个修补程序时，您的本地副本将尊重遥控器设置的默认分支名称，即使还有任何提交。</p><p> On the topic of renaming things, Git 2.30 makes it easier to change the name of another default: a repository’s first remote. When  git clone-ing a repository, the first remote initialized is always named “origin”.Prior to Git 2.30, your options for renaming this were limited to running  git remote rename origin &lt;newname&gt;. Git 2.30 allows you to configure a different name to be chosen by default, instead of always using “origin”. To give it a try for yourself, set the  clone.defaultRemoteName configuration.</p><p> 在重命名事物的主题上，Git 2.30使更改更改另一个默认值的名称：存储库的首个遥控器。当GIT克隆存储库时，第一个远程初始化始终命名为“源”.PROR到GIT 2.30，重新命名的选项仅限于运行Git远程重命名源＆lt; newname＆gt ;. Git 2.30允许您配置默认情况下选择其他名称，而不是始终使用“源”。要为自己提供尝试，请设置clone.defaultremotename配置。</p><p> When a repository grows large, it can be hard to figure out which branches are responsible. In Git 2.31,  git rev-list now has a   --disk-usage option which is both simpler and faster than using the existing tools to sum up object sizes. The  examples section of the  rev-list manual shows off some uses (and check out the source link below for timings and to see the “old” way of doing it).</p><p> 当存储库变大时，很难弄清楚哪个分支负责。在Git 2.31中，Git Rev-list现在具有 -  Disk-Usage选项，它既比使用现有工具总结对象大小的速度更大且速度。 Rev-List手册的示例部分显示了一些使用（并查看下面的源链接以进行时间，并查看“旧”方式）。</p><p> You may have used Git’s  -G&lt;regex&gt; option to find commits which modified a line that mentions a particular string (e.g.,  git log -G&#39;foo\(&#39; will look for changes that added, removed, or modified calls to the  foo() function). But you may also want to  ignore lines matching a certain pattern. Git 2.30 introduces  -I&lt;regex&gt;, which lets you ignore changes in lines matching a regular expression. For instance,  git log -p -I&#39;//&#39; would show the patch for each commit, but omit any hunks that only touched comment lines (those containing  //).</p><p> 您可能已经使用git的-g＆lt;正则表达式＆gt;找到修改提交的行的提交的选项（例如，git log -g＆＃39; foo \（＆＃39;将查找为foo（）函数的调用）。但是，您也可能忽略匹配某个模式的行。Git 2.30介绍-i＆lt; regex＆gt;，它允许您忽略与正则表达式匹配的行中的更改。例如，git log -p -i＆＃39; //＃ 39;将显示每个提交的补丁，但省略了只触及注释行的任何人（包含//）。</p><p> In preparation for replacing the merge backend, rename detection has been substantially optimized. You can read more about these changes from their author in  Optimizing git’s merge machinery, #1, and  Optimizing git’s merge machinery, #2.</p><p> 在准备更换合并后端的准备时，重命名检测已经大大优化。您可以在优化Git的合并机械，＃1和优化Git的合并机械，＃2中了解更多有关这些更改的更多信息。</p><p> That’s just a sample of changes from the last couple of releases. For more, check out the release notes for  2.30 and  2.31, or  any previous version in the  Git repository.</p><p> 这只是过去几对释放的变化示例。有关更多，请在GIT存储库中查看2.30和2.31中的发行说明或以前的版本。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.blog/2021-03-15-highlights-from-git-2-31/">https://github.blog/2021-03-15-highlights-from-git-2-31/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012 - 2021 diglog.com </div></div></body></html>