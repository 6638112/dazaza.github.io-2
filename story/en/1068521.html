<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Y组合者 The Y Combinator</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Y Combinator<br/>Y组合者 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-29 23:06:04</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/8d479f58cb870fe04619d7cd96a723a1.png"><img src="http://img2.diglog.com/img/2021/6/8d479f58cb870fe04619d7cd96a723a1.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Tiger got to hunt, Bird got to fly; Lisper got to sit and wonder, (Y (Y Y))?  Tiger got to sleep, Bird got to land; Lisper got to tell himself he understand.      — Kurt Vonnegut, modified by Darius Bacon</p><p>老虎必须追捕，鸟飞得苍蝇; Lisper得坐下来，（Y（Y Y））？老虎睡了，鸟来落地; Lisper得告诉自己他了解。 -  Kurt Vonnegut，由Darius Bacon修改</p><p>  I recently wrote a blog post about the Y combinator. Since then, I&#39;ve received so many useful comments that I thought it was appropriate to expand the post into a more complete article. This article will go into greater depth on the subject, but I hope it&#39;ll be more comprehensible as well. You don&#39;t need to have read the previous post to understand this one (in fact, it&#39;s probably better if you haven&#39;t.) The only background knowledge I require is a tiny knowledge of the Scheme programming language including recursion and first-class functions, which I will review. Comments are (again) welcome.</p><p>  我最近写了一个关于y组合者的博客文章。从那以后，我收到了许多有用的评论，我认为将帖子扩展到更完整的文章中是合适的。本文将对主题进行更深入的深度，但我希望它能够更加可理解。你不需要阅读前一篇文章以了解这一点（其实，如果你没有，那么它可能更好，如果你verven＆＃39;）我所需要的唯一背景知识是对该方案的微小了解编程语言包括递归和一流的功能，我将审查。评论（再次）欢迎。</p><p>   Before I get into the details of what Y actually is, I&#39;d like to addressthe question of why you, as a programmer, should bother to learn about it. Tobe honest, there aren&#39;t a lot of good nuts-and-bolts practical reasons forlearning about Y. Even though it does have a few practical applications, forthe most part it&#39;s mainly of interest to computer language theorists.Nevertheless, I do think it&#39;s worth your while to know something about Y forthe following reasons:</p><p>   在我进入y实际上的细节之前，我想解决为什么你作为程序员的问题应该烦恼地了解它。诚实的，那里an＆＃39;塔很多好螺母 - 螺栓的实际原因，即使它确实存在了一些实际应用，大部分都是计算机语言理论家的兴趣。无论如何，我觉得它＆＃39;值得你的虽然是关于你的想法：</p><p> It&#39;s one of the most beautiful ideas in all of programming. If you have any sense of programming aesthetics, you&#39;re sure to be delighted by Y.</p><p> 它＆＃39;在所有编程中最美丽的想法之一。如果您有任何编程美学的感觉，则＆＃39; Quecate将被Y愉快地高兴。</p><p> It shows in a very stark way how amazingly powerful the simple ideas of functional programming are.</p><p> 它以一种非常显着的方式显示了功能性编程的简单思想。</p><p> In 1959, the British scientist C. P. Snow gave a famous lecture called  The Two Cultures where he bemoaned the fact that many intelligent and well-educated people of the time had almost no knowledge of science. He used knowledge of the Second Law of Thermodynamics as a kind of dividing line between those who were scientifically literate and those who weren&#39;t. I think we can similarly use knowledge of the Y combinator as a dividing line between programmers who are &#34;functionally literate&#34; ( i.e. have a reasonably deep knowledge of functional programming) and those who aren&#39;t. There are other topics that could serve just as well as Y (notably monads), but Y will do nicely. So if you aspire to have the True Lambda-Nature, read on.</p><p> 1959年，英国科学家C. P. Snow给了一个着名的讲座，称为两种文化，他讨论了许多智能和受过良好的人们的时间几乎没有科学知识。他使用了对那些科学识字的人之间的第二种热力学定律，以及那些温和的人之间的分界线和＆＃39; t。我认为我们可以类似地使用Y组合者的知识作为＆＃34的程序员之间的分界线;功能识字＆＃34; （即对功能规划的合理知识）和那些aren的人和＃39; t。还有其他议题可以服务，也可以（特别是MONADS），但y会很好。所以，如果你渴望拥有真正的兰布 - 性质，请阅读。</p><p> By the way,  Paul Graham (the Lisp hacker, Lisp book author, essayist, and now venture capitalist) apparently thinks so highly of Y that he named his startup incubator company  Y Combinator. Paul got rich from his knowledge of ideas like these; maybe someone else will too. Maybe even you.</p><p> 顺便说一下，Paul Graham（Lisp黑客，Lisp Book Authory，Essayist和现在风险资本主义）显然非常重要，他将他命名为他的启动孵化器公司Y Combinator。保罗从他的想法知识中富有丰富;也许其他人也会。也许甚至你。 </p><p>    We&#39;ll start our exploration of the Y combinator by defining some functions to compute factorials. The factorial of a non-negative integer  n is the product of all integers starting from  1 and going up to and including  n. Thus we have:</p><p>我们＆＃39; ll通过定义一些函数来计算阶段来开始探索Y组合器。非负整数N的源极是从1开始的所有整数的乘积，并延长到和包括n。因此我们有：</p><p> factorial 1 = 1 factorial 2 = 2 * 1 = 2 factorial 3 = 3 * 2 * 1 = 6 factorial 4 = 4 * 3 * 2 * 1 = 24</p><p> 因子1 = 1因子2 = 2 * 1 = 2因子3 = 3 * 2 * 1 = 6因子4 = 4 * 3 * 2 * 1 = 24</p><p> and so on. (I&#39;m using a function notation without parentheses here, so  factorial 3  is the same as what is usually written as  factorial(3).  Humor me.) Factorials increase veryrapidly with increasing  n; the factorial of  20 is 2432902008176640000. The factorial of  0 is definedto be  1; this turns out to be the appropriate definition for the kinds of things factorials are actually used for (like solving problems incombinatorics).</p><p> 等等。 （i＆＃39; m使用没有括号的函数表示法，所以armential 3与通常写入的因子（3）。幽默我。）因子越来越多地增加; 20的因子为2432902008176640000。0的因子是1;事实证明，对于实际用于造票的种类的适当定义（如解决问题，议题蛋白）。</p><p>  It&#39;s easy to write a function in a programming language to compute factorials using some kind of a looping control construct like a  while or  for loop ( e.g. in C or Java). However, it&#39;s also easy to write a recursive function to compute factorials, because factorials have a very natural recursive definition:</p><p>  它易于在编程语言中编写功能，以使用某种循环控制构造的编程语言中的函数，例如循环或循环（例如，在C或Java中）。但是，它也很容易编写递归函数来计算阶乘，因为阶乘有一个非常自然的递归定义：</p><p>  where the second line applies for all  n greater than zero. Infact, in the computer language  Haskell,that&#39;s the way you actually define the factorial function. In  Scheme, the language we&#39;ll be using here,this function would be written like this:</p><p>  第二行适用于大于零的所有n。 Infact，在计算机语言Haskell，那就是您实际定义因子函数的方式。在方案中，我们＆＃39的语言; ll在这里使用，这个函数将写类似：</p><p>  Scheme uses a parenthesized prefix notation for everything, so something like   (- n 1)  represents what is usually written   n - 1  in most programming languages. The reasons for this are beyond the scope of this article, but getting used to this notation isn&#39;t very hard.</p><p>  方案使用括号前缀符号为所有内容，因此类似于（ -  n 1）表示通常在大多数编程语言中写入的n  -  1。这的原因超出了本文的范围，但习惯了这个符号，非常努力。</p><p> In fact, the above definition of the factorial function in Scheme could also be written in a slightly more explicit way as follows:</p><p> 事实上，上述方案中的阶乘函数的定义也可以以稍微明确的方式编写如下： </p><p> (define factorial (lambda (n) (if (= n 0) 1 (* n (factorial (- n 1))))))</p><p>（定义因子（lambda（n）（如果（= n 0）1（* n（armborial（ -  n 1）））））））））</p><p> The keyword  lambda simply indicates that the thing we&#39;redefining ( i.e. whatever is enclosed by the open parenthesis to theimmediate left of the  lambda and its corresponding closeparenthesis) is a function. What comes immediately after the word lambda, in parentheses, are the  formal arguments of thefunction; here there is just one argument, which is  n. The body of the function comes after the formal arguments, and hereconsists of the expression  (if (= n 0) 1 (* n (factorial (- n1)))). This kind of function is an  anonymous function. Here youdo give the anonymous function the name  factorial after you&#39;vedefined it, but you don&#39;t have to, and often it&#39;s handy not to if you&#39;re onlygoing to be using it once. In Scheme and some other languages, anonymousfunctions are also called  lambda expressions. Many programminglanguages besides Scheme allow you to define anonymous functions, includingPython, Ruby, Javascript, Ocaml, and Haskell (but not C, C++, or Java,unfortunately). We&#39;ll be using lambda expressions a lot below.</p><p> 关键字Lambda简单地表明了我们＆＃39的东西;重新定义（即，由打开的括号封闭到Lambda的左侧和其相应的衣服内部）是一个功能。在Lambda中，在括号中的话是什么之后，是Function的正式论点;这里只有一个参数，这是n。该函数的主体在正式参数之后，以及表达式的秘书主义者（如果（= n 0）1（* n（armborial（ -  n1））））））。这种功能是匿名功能。在这里，你给了你匿名函数你＆＃39之后的姓名因子; vedefined它，但你不必，并且经常它＆＃39; s handy不是如果你＆＃39;重新使用它一次。在方案和一些其他语言中，匿名功能也称为Lambda表达式。除了方案之外的许多编程规程允许您定义匿名函数，包括PyThon，Ruby，JavaScript，OCAML和Haskell（但不遗憾的是C，C ++或Java）。我们＆＃39; ll在下面使用lambda表达式。</p><p> In the Scheme language, the definition of  factorial just givenis identical to the one before it; Scheme simply translates the firstdefinition into the second one before evaluating it. So all functions inScheme are really lambda expressions.</p><p> 在方案语言中，因子的定义仅仅与之相同;方案在评估之前简单地将FirstDefinition转换为第二个。所以所有功能术语都是真正的lambda表达。</p><p> Note that the body of the function has a call to the  factorialfunction (which we&#39;re in the process of defining) inside it, which makes thisa recursive definition. I will call this kind of definition, where the name ofthe function being defined is used in the body of the function, an explicitly recursive definition. (You might wonder what an &#34;implicitlyrecursive&#34; function would be. I&#39;m not going to use that expression, but thenotion I have in mind is a recursive function which is generated throughnon-recursive means — keep reading!)</p><p> 请注意，该函数的主体对其中的FactorialFunction（＆＃39;在定义过程中的过程中的调用，这使得该递归定义。我会调用这种定义，其中定义的函数的名称用于函数的主体，一个明确的递归定义。 （你可能想知道一个＆＃34;隐式的副顾忌＆＃34;功能是。我不会使用那种表达，但我想到的是一个递归函数，它是通过未经递归手段生成的递归函数 - 继续阅读！）</p><p> For the sake of argument, we&#39;re going to assume that our version of Schemedoesn&#39;t have the equivalent of  for or  while loops inC or Java (although in fact, real Scheme implementations do have suchconstructs, but under a different name), so that in order to define a functionlike  factorial, we pretty much have to use recursion. Scheme isoften used as a teaching language partly for this reason: it forces studentsto learn to think recursively.</p><p> 为了参与争论，我们将假设我们的Schemedoesn和＃39; t的版本有相当于循环Inc或Java（但实际上，实际方案实现确实有这样的结构，但在不同的情况下名称），以便为了定义函数函数，我们几乎必须使用递归。计划以外用作教学语言的原因：它迫使学生学习者学会递归思考。</p><p>  Scheme is a cool language for many reasons, but one that is relevant to ushere is that it allows you to use functions as &#34;first class&#34; data objects(this is often expressed by saying that Scheme supports  first-classfunctions). This means that in Scheme, we can pass a function to anotherfunction as an argument, we can return a function as the result of evaluatinganother function applied to its arguments, and we can create functionson-the-fly as we need them (using the  lambda notation shownabove). This is the essence of functional programming, and it will featureprominently in the ensuing discussion. Functions which take other functions asarguments, and/or which return other functions as their results, are usuallyreferred to as  higher-order functions.</p><p>  方案是一种很多原因的酷语言，但是一个与之相关的语言是它允许您使用＆＃34;头等舱＆＃34;数据对象（通常通过说方案支持第一类功能）来表示。这意味着在方案中，我们可以将函数传递给另一个功能作为参数，我们可以返回一个函数，因为应用于其参数的评估another函数的结果，我们可以在我们需要时创建CombourcyOn-Fly（使用lambda符号表示）。这是功能规划的本质，它将在随后的讨论中括起来。使用其他功能的函数和/或将其他函数返回其结果，通常是更高阶函数的。</p><p>  Now, here&#39;s the puzzle: what if you were asked to define the factorial function in Scheme, but were told that you could notuse recursive function calls in the definition (for instance, in the factorial function given above you cannot use the word factorial anywhere in the body of the function). However, you are allowed to use first-class functions and higher-order functions anyway you see fit. With this knowledge, can you define the factorial function?</p><p>  现在，这里＆＃39;拼图：如果要求您在方案中定义阶乘函数，则何时才能告知您可以在定义中通知递归函数调用（例如，在上面给出的因子函数中，您无法使用词因子在函数的身体中的任何地方）。但是，无论如何，允许您使用一流的功能和高阶函数，您认为您会看到合适。通过这种知识，您能定义因子函数吗？ </p><p> The answer to this question is yes, and it will lead us directly to the Ycombinator.</p><p>这个问题的答案是肯定的，它将直接向我们带到Ycombinator。</p><p>   The Y combinator is a higher-order function. It takes a single argument,which is a function that isn&#39;t recursive. It returns a version of the functionwhich is recursive. We will walk through this process of generating recursivefunctions from non-recursive ones using Y in great detail below, but that&#39;sthe basic idea.</p><p>   Y组合器是一个高阶函数。它需要一个参数，这是一个函数，即递归。它返回递归的功能版本。我们将在下面使用y详细介绍从非递归人生成递归功能的过程，但是基本想法。</p><p> More generally, Y gives us a way to get recursion in a programming languagethat supports first-class functions but that doesn&#39;t have recursion built into it. So what Y shows us is that such a language already allows us to definerecursive functions, even though the language definition itself says nothingabout recursion. This is a Beautiful Thing: it shows us that functionalprogramming alone can allow us to do things that we would never expect to beable to do (and it&#39;s not the only example of this).</p><p> 更一般地说，Y为我们提供了一种方法来在编程语言中获得递归，支持一流的功能，但它没有内置递归。所以你们表明我们的是这种语言已经允许我们允许我们过期函数，即使语言定义本身表示缺点递归。这是一件美丽的事情：它向我们展示了单独的功能性能可以让我们做我们永远不会期望Beable的事情（而且它不是这个问题的唯一例子）。</p><p>  We will be looking at two broad classes of computer languages: those that use  lazy evaluation and those that use  strict evaluation. Lazyevaluation means that in order to evaluate an expression in the language, youonly evaluate as much of the expression as is needed to get the final result.So (for instance) if there is a part of the expression that doesn&#39;t need toget evaluated (because the result will not depend on it) it won&#39;t beevaluated. In contrast, strict evaluation means that all parts of anevaluation will be evaluated completely before the value of the expression asa whole is determined (with some necessary exceptions, such as if expressions, which have to be lazy to work properly). Inpractice, lazy evaluation is more general, but strict evaluation is morepredictable and often more efficient. Most programming languages use strictevaluation. The programming language  Haskell uses lazy evaluation, and this isone of the most interesting things about that language. We will use both kindsof evaluation in what follows.</p><p>  我们将看一下两种广泛的计算机语言：那些使用懒惰评估的人和使用严格评估的人。 lazyevaluation意味着为了评估语言中的表达，您可以评估最终结果所需的表达式。等（例如）如果有一部分表达式，则需要忘记评估（因为结果不依赖于它）它赢得了＆＃39; t beevalated。相反，严格的评估意味着在确定ASA整体的表达式的价值之前，将在表达式的值（具有一些必要的例外）之前完全评估所有部分，例如表达式，这必须懒得正常工作）。懒惰评估更为一般，但严格的评估是更为预测和往往更有效的。大多数编程语言使用严格的评估。编程语言Haskell使用懒惰的评估，这是关于该语言最有趣的事情。我们将在下面使用两种类型的评估。</p><p>  Even though we often refer to Y as &#34;the&#34; Y combinator, in actual fact thereare an infinite number of Y combinators. We will only be concerned with two ofthese, one lazy and one strict. We need two Y combinators because the Ycombinator we define for lazy languages will not work for strict languages.The lazy Y combinator is often referred to as the  normal-order Ycombinator and the strict one is referred to as the  applicative-order Ycombinator. Basically,  normal-order is another way of saying &#34;lazy&#34;and  applicative-order is another way of saying &#34;strict&#34;.</p><p>  尽管我们经常指Y和＃34;＆＃34; y组合器，实际上是一个无限数量的y组合器。我们只会关注两个人，一个懒惰和一个严格的。我们需要两个y组合器，因为Ycombinator我们为懒人语言定义不适用于严格的语言。懒惰的Y组合器通常被称为正常阶Ycombinator，严格的组合器被称为适用于Applicated-Order Ycombinator。基本上，正常顺序是另一种说法的方式＆＃34;懒惰＆＃34;和申请订单是另一种说法的方式＆＃34;严格＆＃34;</p><p>  Another big dividing line in programming languages is between  statictyping and  dynamic typing. A statically-typed language is one wherethe types of all expressions are determined at compile time, and any typeerrors cause the compilation to fail. A dynamically-typed language doesn&#39;t doany type checking until run time, and if a function is applied to arguments ofinvalid types ( e.g. by trying to add together an integer and a string),then an error is reported. Among commonly-used programming languages, C, C++and Java are statically typed, and Perl, Python and Ruby are dynamicallytyped. Scheme (the language we&#39;ll be using for our examples) is alsodynamically typed. (There are also languages that straddle the border betweenstatically-typed and dynamically-typed, but I won&#39;t discuss thisfurther.)</p><p>  在编程语言中的另一个大划分线是统计学和动态键入之间。静态类型的语言是在编译时确定所有表达式的类型，并且任何类型的错误都会导致编译失败。动态类型的语言不会＆＃39; t doany型检查直到运行时间，并且如果函数应用于某种类型的参数（例如，通过尝试将整数和字符串添加在一起），则报告错误。在常用的编程语言中，C，C ++和Java是静态键入的，而Perl，Python和Ruby是动态的。方案（我们的语言我们和我们的例子使用的语言）是独奏动力学的。 （也有语言跨越边界之间的典型和动态类型，但我赢得了＆＃39; T讨论了这件事。）</p><p> One often hears static typing referred to as  strong typing anddynamic typing referred to as  weak typing, but this is an abuse ofterminology. Strong typing simply means that every value in the language hasone and only one type, whereas weak typing means that some values can havemultiple types. So Scheme, which is dynamically typed, is also strongly typed,while C, which is statically typed, is weakly typed (because you can cast apointer to one kind of object into a pointer to another type of object withoutaltering the pointer&#39;s value). I will only be concerned with strongly typedlanguages here.</p><p> 人们经常听到静态打字，称为强键入的曲折打字，这是一种弱打字，但这是滥用的。强的打字简单意味着语言中的每个值都有一个类型，而只有一种类型，而弱打字意味着某些值可以获得任何类型的类型。因此，动态类型的方案也被强烈打字，而C静态键入的C是弱键入的（因为您可以将一个物体投射到指向另一类型对象的指针中的指针＆＃39; s价值）。我将只关注这里的强烈打字语言。 </p><p> It turns out to be much simpler to define the Y combinator in dynamicallytyped languages, so that&#39;s what I&#39;ll do. It is possible to define a Ycombinator in many statically typed languages, but (at least in the examplesI&#39;ve seen) such definitions usually require some non-obvious type hackery,because the Y combinator itself doesn&#39;t have a straightforward static type.That&#39;s beyond the scope of this article, so I won&#39;t mention it further.</p><p>事实证明，以动态的语言定义y组合器更简单，所以＆＃39; s我＆＃39; ll做。可以以许多静态类型的语言定义Ycombinator，但（至少在示例中和＃39; ve看到）这些定义通常需要一些非明显的类型的黑掩饰，因为Y组合器本身并不是直截了当的静态类型。除了本文的范围之外，我赢得了＆＃39;我进一步提到它。</p><p>  A combinator is just a  lambda expression with no  freevariables. We saw above what lambda expressions are (they&#39;re justanonymous functions), but what&#39;s a free variable? It&#39;s a variable ( i.e. a name or identifier in the language) which isn&#39;t a  boundvariable. Happy now? No? OK, let me explain.</p><p>  组合者只是一个λ表达式，没有自由偏离。我们看到了λ表达式（它们＆＃39; justanonymous函数），但是一个免费变量＆＃39;它＆＃39; s一个变量（即语言中的名称或标识符），哪个是姓名的。现在开心？不？好的，让我解释一下。</p><p> A bound variable is simply a variable which is contained inside the body of a lambda expression that has that variable name as one of its arguments.</p><p> 绑定变量简直是一个变量，该变量包含在Lambda表达式的主体内，该λ表达式具有该变量名称作为其参数之一。</p><p>   Are the variables in the body of these lambda expressions free variables or bound variables? We&#39;ll ignore the formal arguments of the lambda expressions, because only variables in the body of the lambda expression can be considered free or bound. As for the other variables, here are the answers:</p><p>   这些lambda表达式的体变量是免费变量还是绑定变量？我们＆＃39; ll忽略了lambda表达式的形式参数，因为λ表达的身体中只能被视为自由或绑定的变量。至于其他变量，这里有答案：</p><p> The  x in the body of the lambda expression is a boundvariable, because the formal argument of the lambda expression is also x. This lambda expression has no other variables, therefore ithas no free variables, therefore it&#39;s a combinator.</p><p> λ表达体内的X是一个边界，因为λ表达的正式参数也是x。这种λ表达没有其他变量，因此没有自由变量，因此＆＃39; s组合器。</p><p>  The  y in the lambda body is a free variable. This lambda expression is therefore not a combinator.</p><p>  Lambda身体中的Y是一个自由变量。因此，这种λ表达不是组合者。</p><p>  Aside from the formal arguments of the lambda expression, there is only one variable, the final  x, which is a bound variable (it&#39;s bound by the formal argument of the outer lambda expression). Therefore, this lambda expression as a whole has no free variables, so this is a combinator.</p><p>  除了Lambda表达的形式参数之外，只有一个变量，最终x，这是一个绑定变量（由外部λ表达的正式参数绑定）。因此，这个Lambda表达式整体没有自由变量，所以这是一个组合者。 </p><p>  Aside from the formal arguments of the lambda expression, there are two variables, the final  x and  y, both bound variables. This is a combinator.</p><p>除了Lambda表达式的形式参数之外，还有两个变量，最终x和y，两个绑定变量。这是一个组合者。</p><p>  The entire expression is not a lambda expression, so it&#39;s by definition not a combinator. Nevertheless, the  x is a free variable and the final  y is a bound variable.</p><p>  整个表达不是λ表达，所以它根据定义而不是组合者。然而，X是一个自由变量，最终y是绑定变量。</p><p>  Again, the entire expression isn&#39;t a lambda expression (it&#39;s a function application), so this isn&#39;t a combinator either. The second  x is a bound variable while the  y is a free variable.</p><p>  再次，整个表达是＆＃39; t一个λ表达（它＆＃39; s函数应用程序），所以这是一个组合者。第二x是绑定变量，而Y是自由变量。</p><p>  (define factorial (lambda (n) (if (= n 0) 1 (* n (factorial (- n 1))))))</p><p>  （定义因子（lambda（n）（如果（= n 0）1（* n（armborial（ -  n 1）））））））））</p><p> is a combinator, you don&#39;t consider the  define part, so what you&#39;re really asking is if</p><p> 是一个组合者，你不考虑定义部分，所以你＆＃39;重新询问是什么</p><p>  is a combinator. Since in this lambda expression, the name factorial represents a free variable (the name factorial is not a formal argument of the lambda expression), this is not a combinator. This will be important below. In fact, the names  =,  *, and  - are also free variables, so even without the name  factorial this would not be a combinator (to say nothing of the numbers!).</p><p>  是一个组合者。由于在该Lambda表达式中，名称阶乘代表一个自由变量（名称阶乘不是Lambda表达式的正式参数），这不是组合者。这将是重要的。事实上，名称=，*，和 - 也是免费变量，所以即使没有名称因子，这不是一个组合者（说不出数字！）。</p><p>     (define factorial (lambda (n) (if (= n 0) 1 (* n (factorial (- n 1))))))</p><p>     （定义因子（lambda（n）（如果（= n 0）1（* n（armborial（ -  n 1））））））））） </p><p> What we want to do is to come up with a version of this that does the same thing but doesn&#39;t have that pesky recursive call to  factorial in the body of the function.</p><p>我们想要做的就是提出这一版本，这是同样的事情，但并不是＆＃39; t在函数体内有讨厌的递归调用阶乘呼叫。</p><p> Where do we start? It would be nice if you could save all of the function except for the offending recursive call, and put something else there. That might look like this:</p><p> 我们在哪里开始？如果您可以保存所有功能，除了违规递归调用之外，它会很好，并在那里放一些东西。这可能是这样的：</p><p> (define sort-of-factorial (lambda (n) (if (= n 0) 1 (* n (&lt;???&gt; (- n 1))))))</p><p> （定义局部排序（如果（= n 0）1（* n（＆lt ;??＆gt;（ -  n 1））））））））））</p><p> This still leaves us with the problem of what to put in the place marked  &lt;???&gt;. It&#39;s a tried-and-true principle of functional programming that if you don&#39;t know exactly what you want to put somewhere in a piece of code, just abstract it out and make it a parameter of a function. The easiest way to do this is as follows:</p><p> 这仍然让我们留下了标有标记的地方的问题。它＆＃39;如果您不知道您想要在一段代码中的某个地方究竟知道您想要放入某个代码的某个地方，请将其摘录并使其成为函数的参数，这是一个验证和真正的功能编程原则最简单的方法如下：</p><p> (define almost-factorial (lambda (f) (lambda (n) (if (= n 0) 1 (* n (f (- n 1)))))))</p><p> （定义几乎 - 因子（Lambda（F）（如果（= n 0）1（* n（f（ -  n 1）））））））））</p><p> What we&#39;ve done here is to rename the recursive call to factorial to  f, and to make  f anargument to a function which we&#39;re calling  almost-factorial.Notice that  almost-factorial is not at all the factorialfunction. Instead, it&#39;s a higher-order function which takes a single argument f, which had better be a function (or else  (f (- n1)) won&#39;t make sense), and  returns another function (the (lambda (n) ...) part) which (hopefully) will be a factorialfunction if we choose the right value for  f.</p><p> 我们在这里完成了什么是将递归调用重命名为F的递归调用，并使F Anargument与我们＆＃39;重新调用近极某的函数。差异差异不是所有的因子函数。相反，它＆＃39;一个高阶函数，它采用一个参数f，它更好地是一个函数（或f（ -  n1））won＆＃39; t有意义），并返回另一个函数（（如果我们为F选择合适的价值，那么（希望）将是一个（希望）的部分）。</p><p> It&#39;s important to realize that this trick is not in any way specific to the  factorial function. We can do exactly the same trick with any recursive function. For instance, consider a recursive function to compute fibonacci numbers. The recursive definition of fibonacci numbers is as follows:</p><p> 它很重要，意识到这个技巧不是以任何方式特定于阶乘函数。我们可以用任何递归函数做出完全相同的技巧。例如，考虑递归函数来计算FibonAcci数字。 Fibonacci号码的递归定义如下： </p><p> fibonacci 0 = 0 fibonacci 1 = 1 fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)</p><p>fibonacci 0 = 0 fibonacci 1 = 1 fibonacci n = fibonacci（n  -  1）+ fibonacci（n  -  2）</p><p> (In fact, that&#39;s the definition of the fibonacci function in Haskell.) In Scheme, we can write the function this way:</p><p> （事实上​​，＆＃39;在Haskell中的Fibonacci函数的定义。）在方案中，我们可以以这种方式编写功能：</p><p> (define fibonacci (lambda (n) (cond ((= n 0) 0) ((= n 1) 1) (else (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))))</p><p> （定义Fibonacci（lambda（n）（cond（= n 0）0）（（= n 1）1）（else（+（fibonacci（ -  n 1））（fibonacci（ -  n 2）））））））））） ）</p><p> (where  cond is just a shorthand expression for nested  if expressions). We can then remove the explicit recursion just like we did for  factorial:</p><p> （COND只是嵌套如果表达式的速记表达式）。然后，我们可以像我们为因素做的那样删除显式递归：</p><p> (define almost-fibonacci (lambda (f) (lambda (n) (cond ((= n 0) 0) ((= n 1) 1) (else (+ (f (- n 1)) (f (- n 2))))))))</p><p> （定义几乎 - 斐波纳（Lambda（F）（Lambda（n）（cond（（= n 0）0）（（= n 1）1）（否则（+（f（ -  n 1））（f（ -  n 2））））））））））</p><p> As you can see, the transformation from a recursive function to a non-recursive  almost- equivalent function is a purely mechanical one: you rename the name of the recursive function inside the body of the function to  f and you wrap a  (lambda (f) ...) around the body.</p><p> 正如您所见，从递归函数到非递归几乎等效函数的转换是纯机械唯一的：您将函数函数的名称重命名为f到f，并且您包装a（lambda（f ）......）在身体周围。</p><p> If you&#39;ve followed what I just did (never mind  why I did it; we&#39;ll see that later), then congratulations! As Yoda says, you&#39;ve just taken the first step into a larger world.</p><p> 如果你＆＃39;我跟着我刚刚做了什么（从不介意为什么我做到了;我们稍后会看到那个），然后祝贺！正如尤达所说，你刚刚走进了一个更大的世界。 </p><p>  I probably shouldn&#39;t do this yet, but I&#39;m going to give you a sneak preview of where we&#39;re going. Once we define the Y combinator, we&#39;ll be able to define the factorial function using  almost-factorial as follows:</p><p>我可能不应该这样做，但是我会给你一个偷偷摸的预览我们＆＃39;重新进入的地方。一旦我们定义了Y组合器，我们就可以使用几个差异定义差异函数，如下所示：</p><p>  where  Y is the Y combinator. Note that this definition of factorial doesn&#39;t have any explicit recursion in it. Similarly,we can define the  fibonacci function using almost-fibonacci in the same way:</p><p>  其中y是y组合器。请注意，此因子的定义不具有任何明确的递归。同样，我们可以以相同的方式使用近似 - 斐波纳契定义Fibonacci函数：</p><p>  So the Y combinator will give us recursion wherever we need it as long as we have the appropriate  almost- function available ( i.e. the non-recursive function derived from the recursive one by abstracting out the recursive function calls).</p><p>  因此，只要我们拥有适当的几乎函数（即，通过抽出递归函数调用，我们将在何时何时何时何地提供额外的次数</p><p>   Let&#39;s assume, for the sake of argument, that we already had a working factorial function lying around (recursive or not, we don&#39;t care). We&#39;ll call that hypothetical factorial function  factorialA. Now let&#39;s consider the following:</p><p>   为了论述，假设我们已经拥有了一个工作阶乘函数（递归或不，我们不小心）。我们＆＃39; ll致电该假设的阶乘函数因子。现在让＆＃39; s考虑以下内容：</p><p>    (define factorialB ((lambda (f) (lambda (n) (if (= n 0) 1 (* n (f (- n 1)))))) factorialA))</p><p>    （定义FactoriaNB（（λ（λ（n）（如果（= n 0）1（* n（f（ -  n 1））））））））</p><p> Now, by substituting  factorialA for  f inside the body of the lambda expression we get:</p><p> 现在，通过在我们得到的Lambda表达式身体内代替f的facoriala：</p><p> (define factorialB (lambda (n) (if (= n 0) 1 (* n (factorialA (- n 1))))))</p><p> （定义FactorizerB（lambda（n）（如果（= n 0）1（* n（factoriala（ -  n 1））））））））） </p><p> This looks a lot like the recursive factorial function, but it isn&#39;t: factorialA is not the same function as  factorialB.So it&#39;s a non-recursive function that depends on a hypothetical factorialA function to work. Does it actually work? Well, it&#39;spretty obvious that it should work for  n = 0, since (factorialB 0) will just return  1 (the factorial of 0). If  n &gt; 0, then the value of  (factorialBn) will be  (* n (factorialA (- n 1))). Now, we assumedthat  factorialA would correctly compute factorials, so (factorialA (- n 1)) is the factorial of  n - 1, andtherefore  (* n (factorialA (- n 1))) is the factorial of n (by the definition of factorial), thus proving that factorialB computes the factorial function correctly as long as factorialA does. So this works. The only problem is that we don&#39;tactually have a  factorialA lying around.</p><p>这看起来很像递归阶段函数，但它是＆＃39; t：factoriala与factorizerb.so＆＃39; s一个非递归函数，这取决于假设的事项a函数。它实际上有效吗？嗯，它＆＃39; Spretty显然，它应该为n = 0工作，因为（FactorizerB 0）将只是返回1（所0的因子）。如果是N＆gt; 0，然后（FactorialBn）的值将是（* n（factoriala（ -  n 1））））。现在，我们假设事项是正确计算阶乘的影响，因此（因此（ -  n 1））是n  -  1的因子，因此（* n（factoriala（ -  n 1）））是n的因子（通过定义阶乘），从而证明，只要各种情况，就可以正确计算因子函数。所以这是有效的。唯一的问题是我们不＆＃39;智能地有一个撒谎的局势。</p><p> Now, if you&#39;re really clever, you might be asking yourself whether we can just do this:</p><p> 现在，如果你真的很聪明，你可能会问自己是否可以这样做：</p><p>  The idea is this: let&#39;s assume that  factorialA is a valid factorial function. Then </p><p>  这一想法是：假设Sfaciala是一个有效的因子函数。然后</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://mvanier.livejournal.com/2897.html">https://mvanier.livejournal.com/2897.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/组合/">#组合</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>