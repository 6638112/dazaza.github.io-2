<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我要离开戈朗先生的《狂野旅程》（2020） I want off Mr. Golang's Wild Ride (2020)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">I want off Mr. Golang's Wild Ride (2020)<br/>我要离开戈朗先生的《狂野旅程》（2020） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-03 11:12:48</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/99194f67e5542018f2c1c325832cade0.png"><img src="http://img2.diglog.com/img/2021/1/99194f67e5542018f2c1c325832cade0.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This article is going to have a different tone from what I&#39;ve been postingthe past year - it&#39;s a proper rant. And I always feel bad writing those,because, inevitably, it discusses things a lot of people have been workingvery hard on.</p><p>这篇文章的语气将与我去年发布的内容有所不同-这是恰当的说法。我总是很不高兴写这些内容，因为它不可避免地会讨论许多人一直在努力工作的事情。</p><p>  Having invested thousands of hours into the language, and implemented severalcritical (to my employer) pieces of infrastructure with it, I wish I hadn&#39;t.</p><p>  我已经为该语言投入了数千小时的时间，并用它对我的雇主实施了几个关键的基础架构，我希望自己没有。</p><p> If you&#39;re  already heavily invested in Go, you probably shouldn&#39;t read this,it&#39;ll probably just twist the knife. If you work on Go, you  definitelyshouldn&#39;t read this.</p><p> 如果您已经在Go上投入了大量资金，那么您可能不应该读这本书，它可能只是绞刀而已。如果您使用Go语言，则绝对不应阅读此书。</p><p> I&#39;ve been suffering Go&#39;s idiosyncracies in relative silence for too long,there&#39;s a few things I really need to get off my chest.</p><p> 我一直在相对安静的状态下经历过Go的特质，这是我真正需要摆脱的一些事情。</p><p>   By now, everybody knows Go doesn&#39;t have generics, which makes a lot ofproblems impossible to model accurately (instead, you have to fall back toreflection, which is  extremely unsafe, and the API is very error-prone),error handling is wonky (even with your pick of the third-party librariesthat add context or stack traces), package management took a while to arrive,etc.</p><p>   到现在为止，每个人都知道Go还没有泛型，这使得很多问题无法准确建模（相反，您必须回退到反射，这是非常不安全的，并且API容易出错），错误处理太奇怪了（即使您选择了添加上下文或堆栈跟踪的第三方库），程序包管理也花了一段时间等等。</p><p> But everybody also knows Go&#39;s strengths: static linking makes binaries easyto deploy (although, Go binaries get  verylarge,even if you strip DWARF tables - stack trace annotations still remain, and are  costly).</p><p> 但是每个人也都知道Go的优势：静态链接使二进制文件易于部署（尽管，即使剥离了DWARF表，Go二进制文件也会变得非常大-堆栈跟踪注释仍然存在，而且成本很高）。</p><p> Compile times are short (unless you need cgo), there&#39;s an interactive runtimeprofiler (pprof) at arm&#39;s reach, it&#39;s relatively cross-platform (there&#39;s evena  tiny variant for embedded), it&#39;seasy to syntax-highlight, and there&#39;s now an official  LSPserver for it.</p><p> 编译时间很短（除非您需要cgo），只有一个交互式的运行时配置程序（pprof）触手可及，它是一个相对跨平台的（甚至有一个很小的嵌入式变体） ），语法突出显示起来很容易，并且现在有一个官方的LSPserver。 </p><p>      Or rather, it&#39;s a half-truth that conveniently covers up the fact that, whenyou make something simple, you move complexity elsewhere.</p><p>或更确切地说，它是一个半真相，可以很方便地掩盖一个事实，当您使简单的事情变复杂时，您会将其转移到其他地方。</p><p> Computers, operating systems, networks are a hot mess. They&#39;re barelymanageable, even if you know a decent amount about what you&#39;re doing. Nineout of ten software engineers agree: it&#39;s a miracle anything works at all.</p><p> 计算机，操作系统，网络都是一团糟。即使您知道自己在做什么，也几乎无法管理。十个软件工程师中有九个同意：一切都行得通的奇迹。</p><p>   This example does go on for a while, actually - but don&#39;t let the specificsdistract you. While it goes rather in-depth, it illustrates a larger point.</p><p>   实际上，这个示例确实进行了一段时间-但不要让细节分散您的注意力。尽管深入，但它说明了一个更大的观点。</p><p> Most of Go&#39;s APIs (much like NodeJS&#39;s APIs) are designed for Unix-likeoperating systems. This is not surprising, as Rob &amp; Ken are from the  Plan 9gang.</p><p> Go的大多数API（非常类似于NodeJS的API）都是为Unix操作系统设计的。这并不奇怪，因为Rob＆amp;肯来自9gang计划。</p><p>  // File represents an open file descriptor. type  File  struct {  * file  // os specific} func ( f  * File)  Stat() ( FileInfo,  error) {  // omitted} // A FileInfo describes a file and is returned by Stat and Lstat. type  FileInfo  interface {	 Name()  string  // base name of the file	 Size()  int64  // length in bytes for regular files; system-dependent for others	 Mode()  FileMode  // file mode bits	 ModTime() time. Time  // modification time	 IsDir()  bool  // abbreviation for Mode().IsDir()	 Sys()  interface{}  // underlying data source (can return nil)} // A FileMode represents a file&#39;s mode and permission bits. // The bits have the same definition on all systems, so that // information about files can be moved from one system // to another portably. Not all bits apply to all systems. // The only required bit is ModeDir for directories. type  FileMode  uint32 // The defined file mode bits are the most significant bits of the FileMode. // The nine least-significant bits are the standard Unix rwxrwxrwx permissions. // The values of these bits should be considered part of the public API and // may be used in wire protocols or disk representations: they must not be // changed, although new bits might be added. const (	 // The single letters are the abbreviations	 // used by the String method&#39;s formatting.	 ModeDir  FileMode  = 1  &lt;&lt; (32  - 1  -  iota)  // d: is a directory	 ModeAppend  // a: append-only	 ModeExclusive  // l: exclusive use	 ModeTemporary  // T: temporary file; Plan 9 only	 ModeSymlink  // L: symbolic link	 ModeDevice  // D: device file	 ModeNamedPipe  // p: named pipe (FIFO)	 ModeSocket  // S: Unix domain socket	 ModeSetuid  // u: setuid	 ModeSetgid  // g: setgid	 ModeCharDevice  // c: Unix character device, when ModeDevice is set	 ModeSticky  // t: sticky	 ModeIrregular  // ?: non-regular file; nothing else is known about this file	 // Mask for the type bits. For regular files, none will be set.	 ModeType  =  ModeDir  |  ModeSymlink  |  ModeNamedPipe  |  ModeSocket  |  ModeDevice  |  ModeCharDevice  |  ModeIrregular	 ModePerm  FileMode  = 0777  // Unix permission bits)</p><p>  // File表示一个打开的文件描述符。类型File struct {* file //特定于操作系统} func（f * File）Stat（）（FileInfo，error）{//省略} // FileInfo描述了一个文件，由Stat和Lstat返回。类型FileInfo接口{Name（）字符串//文件的基本名称Size（）int64 //常规文件的长度（以字节为单位）；系统依赖于其他模式Mode（）FileMode //文件模式位ModTime（）时间。时间//修改时间IsDir（）bool // Mode（）的缩写。IsDir（）Sys（）接口{} //基础数据源（可以返回nil）} // FileMode表示文件的模式，并且权限位。 //这些位在所有系统上都具有相同的定义，以便可以将有关文件的信息从一个系统//移植到另一个系统。并非所有位都适用于所有系统。 //唯一需要的位是目录的ModeDir。 type FileMode uint32 //定义的文件模式位是FileMode的最高有效位。 //这9个最低有效位是标准的Unix rwxrwxrwx权限。 //这些位的值应被视为公共API的一部分，并且//可以在有线协议或磁盘表示中使用：//尽管可以添加新的位，但不得更改它们。 const（//单个字母是String方法格式使用的缩写。ModeDir FileMode = 1＆lt;＆lt;（32-1-iota）// // d：是目录ModeAppend // a：仅附加ModeExclusive // l：专用ModeTemporary // T：临时文件;仅计划9 ModeSymlink // L：符号链接ModeDevice // D：设备文件ModeNamedPipe // p：命名管道（FIFO）ModeSocket // S： Unix域套接字ModeSetuid // // u：setuid ModeSetgid // g：setgid ModeCharDevice // c：Unix字符设备，设置了ModeDevice后ModeSticky // t：sticky ModeIrregular //？：非常规文件；对此一无所知file //类型位的掩码。对于常规文件，将不会设置任何值。ModeType= ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice | ModeCharDevice | ModeIrregular ModePerm FileMode = 0777 // Unix权限位）</p><p>  Every file has a mode, there&#39;s even a command that lets you dump it as hex:</p><p>  每个文件都有一个模式，甚至还有一个命令可以让您将其转储为十六进制：</p><p>   package main import (  &#34;fmt&#34;  &#34;os&#34;) func  main() {  arg  :=  os. Args[1]  fi,  _  :=  os. Stat( arg)  fmt. Printf( &#34;(%s) mode = %o\n&#34;,  arg,  fi. Mode()  &amp;  os. ModePerm)}</p><p>   包主要导入（＆＃34; fmt＆＃34;＆＃34; os＆＃34;）func main（）{arg：= os。 Args [1] fi，_：= os。 Stat（arg）fmt。 Printf（＆＃34;（％s）mode =％o \ n＆＃34 ;, arg，fi。Mode（）＆os。ModePerm）} </p><p> $ go run main.go /etc/hosts(/etc/hosts) mode = 644$ go run main.go /usr/bin/man(/etc/hosts) mode = 755</p><p>$运行main.go / etc / hosts（/ etc / hosts）模式= 644 $运行main.go / usr / bin / man（/ etc / hosts）模式= 755</p><p> On Windows, files don&#39;t have modes. It doesn&#39;t have  stat,  lstat,  fstatsyscalls - it has a  FindFirstFile family of functions (alternatively, CreateFile to open, then  GetFileAttributes, alternatively, GetFileInformationByHandle), which takes a pointer to a  WIN32_FIND_DATAstructure, which contains  fileattributes.</p><p> 在Windows上，文件没有模式。它没有stat，lstat，fstatsyscalls-它具有FindFirstFile系列函数（或者，要打开的CreateFile，然后是GetFileAttributes，或者是GetFileInformationByHandle），该函数采用指向WIN32_FIND_DATA结构的指针，该结构包含文件属性。</p><p>    // src/os/types_windows.go func ( fs  * fileStat)  Mode() ( m  FileMode) {	 if  fs  ==  &amp; devNullStat {		 return  ModeDevice  |  ModeCharDevice  | 0666	}	 if  fs. FileAttributes &amp; syscall. FILE_ATTRIBUTE_READONLY  != 0 {		 m  |= 0444	}  else {		 m  |= 0666	}	 if  fs. isSymlink() {		 return  m  |  ModeSymlink	}	 if  fs. FileAttributes &amp; syscall. FILE_ATTRIBUTE_DIRECTORY  != 0 {		 m  |=  ModeDir  | 0111	}	 switch  fs. filetype {	 case  syscall. FILE_TYPE_PIPE:		 m  |=  ModeNamedPipe	 case  syscall. FILE_TYPE_CHAR:		 m  |=  ModeDevice  |  ModeCharDevice	}	 return  m}</p><p>    // src / os / types_windows.go func（fs * fileStat）Mode（）（m FileMode）{如果fs ==＆amp; devNullStat {返回ModeDevice | ModeCharDevice | 0666}如果fs。文件属性和系统调用。 FILE_ATTRIBUTE_READONLY！= 0 {m | = 0444}否则{m | = 0666}如果fs。 isSymlink（）{返回m | ModeSymlink}如果是fs。文件属性和系统调用。 FILE_ATTRIBUTE_DIRECTORY！= 0 {m | = ModeDir | 0111}开关fs。文件类型{case syscall。 FILE_TYPE_PIPE：m | = ModeNamedPipe案例syscall。 FILE_TYPE_CHAR：m | = ModeDevice | ModeCharDevice}返回m}</p><p>  Using &#34;whatever Unix has&#34; as the lowest common denominator is  extremelycommon in open-source codebases, so it&#39;s not surprising.</p><p>  使用Unix所具有的一切因为最低的公分母在开源代码库中非常普遍，所以这并不奇怪。</p><p> Let&#39;s go a little bit further. On Unix systems, you can change the modes offiles, to make them read-only, or flip the executable bit.</p><p> 让我们再进一步一点。在Unix系统上，您可以更改文件的模式，使其成为只读文件，或翻转可执行位。</p><p> package main import (	 &#34;fmt&#34;	 &#34;os&#34;) func  main() {	 arg  :=  os. Args[1]	 fi,  err  :=  os. Stat( arg)	 must( err)	 fmt. Printf( &#34;(%s) old mode = %o\n&#34;,  arg,  fi. Mode() &amp; os. ModePerm)	 must( os. Chmod( arg, 0755))	 fi,  err  =  os. Stat( arg)	 must( err)	 fmt. Printf( &#34;(%s) new mode = %o\n&#34;,  arg,  fi. Mode() &amp; os. ModePerm)} func  must( err  error) {	 if  err  !=  nil {		 panic( err)	}}</p><p> 包主要导入（＆＃34; fmt＆＃34;＆＃34; os＆＃34;）func main（）{arg：= os。 Args [1] fi，err：= os。 stat（arg）must（err）fmt。 Printf（＆＃34;（％s）旧模式=％o \ n＆＃34 ;, arg，fi.Mode（）＆amp; os.ModePerm）must（os.Chmod（arg，0755））fi，err = os 。 stat（arg）must（err）fmt。 Printf（＆＃34;（％s）new mode =％o \ n＆＃34 ;, arg，fi。Mode（）＆amp; os。ModePerm）} func must（err error）{if err！= nil {panic（呃）	}}</p><p>  $ touch test.txt$ go run main.go test.txt(test.txt) old mode = 644(test.txt) new mode = 755</p><p>  $ touch test.txt $去运行main.go test.txt（test.txt）旧模式= 644（test.txt）新模式= 755 </p><p>   So, no errors.  Chmod just silently does... nothing. Which is reasonable -there&#39;s no equivalent to the &#34;executable bit&#34; for files on Windows.</p><p>因此，没有错误。 Chmod只是默默地做...什么。这是合理的-它不等同于可执行位。 Windows上的文件。</p><p>  // src/syscall/syscall_windows.go func  Chmod( path  string,  mode  uint32) ( err  error) {	 p,  e  :=  UTF16PtrFromString( path)	 if  e  !=  nil {		 return  e	}	 attrs,  e  :=  GetFileAttributes( p)	 if  e  !=  nil {		 return  e	}	 if  mode &amp; S_IWRITE  != 0 {		 attrs &amp;^=  FILE_ATTRIBUTE_READONLY	}  else {		 attrs  |=  FILE_ATTRIBUTE_READONLY	}	 return  SetFileAttributes( p,  attrs)}</p><p>  // src / syscall / syscall_windows.go func Chmod（路径字符串，模式uint32）（err错误）{p，e：= UTF16PtrFromString（path）如果e！= nil {return e} attrs，e：= GetFileAttributes（p）如果e！= nil {return e}如果mode＆amp; S_IWRITE！= 0 {attrs＆amp; ^ = FILE_ATTRIBUTE_READONLY} else {attrs | = FILE_ATTRIBUTE_READONLY} return SetFileAttributes（p，attrs）}</p><p>  We have an  uint32 argument, with four billion two hundred ninety-fourmillion nine hundred sixty-seven thousand two hundred ninety-five possiblevalues, to encode... one bit of information.</p><p>  我们有一个uint32的论点，用42.149.497.295的可能值编码……一点信息。</p><p> That&#39;s a pretty innocent lie. The assumption that files have modes was bakedinto the API design from the start, and now, everyone has to live with it.Just like in Node.JS, and probably tons of other languages.</p><p> 那是一个很纯真的谎言。从一开始就将文件具有模式的假设引入了API设计，现在，每个人都必须使用它，就像在Node.JS中，可能还有其他许多语言一样。</p><p>  A language with a more involved type system, and better designed librariescould avoid that pitfall.</p><p>  具有更多类型系统和更好设计的库的语言可以避免这种陷阱。</p><p>  Well, I tried  real hard to keep Rust out of all of this. Among otherthings, because people are going to dismiss this article as coming from &#34;atypical rustacean&#34;.</p><p>  好吧，我竭尽全力使Rust摆脱了所有这些。除其他外，因为人们会认为这篇文章来自“非典型的甲壳类动物”。</p><p> But for all the problems I raise in this article... Rust gets it right.If I had another good example, I&#39;d use it. But I don&#39;t, so, here goes.</p><p> 但是，对于本文中提出的所有问题，Rust都是正确的。如果我有另一个很好的例子，我会使用它。但是我不知道，所以去吧。 </p><p>   This function signatures tells us a lot already. It returns a  Result, whichmeans, not only do we know this can fail, we  have to handle it. Either bypanicking on error, with  .unwrap() or  .expect(), or by matching it against Result::Ok /  Result::Err, or by bubbling it up with the  ? operator.</p><p>这个函数签名已经告诉了我们很多。它返回一个结果，这意味着，不仅我们知道这会失败，而且我们必须处理它。通过使用.unwrap（）或.expect（）来对错误进行恐慌，或者将其与Result :: Ok / Result :: Err进行匹配，或者通过将它冒泡？操作员。</p><p> The point is, this function signature makes it  impossible for us to accessan invalid/uninitialized/null  Metadata. With a Go function, if you ignore thereturned  error, you  still get the result - most probably a null pointer.</p><p> 关键是，此函数签名使我们无法访问无效/未初始化/空的元数据。使用Go函数，如果忽略了所产生的错误，您仍然会得到结果-最有可能是空指针。</p><p> Also, the argument is not a string - it&#39;s a path. Or rather, it&#39;s somethingthat  can be turned into a path.</p><p> 另外，该参数也不是字符串-它是路径。更确切地说，它可以变成一条路径。</p><p>  fn  main ( ) {  let metadata = std ::fs :: metadata ( &#34;Cargo.toml&#34; ) . unwrap ( ) ;  println ! ( &#34;is dir? {:?}&#34;, metadata.is_dir ( ) ) ;  println ! ( &#34;is file? {:?}&#34;, metadata.is_file ( ) ) ;}</p><p>  fn main（）{让元数据= std :: fs ::元数据（＆＃34; Cargo.toml＆＃34;）。解开（）; println！ （＆＃34;是dir？{：？}＆＃34 ;, metadata.is_dir（））; println！ （＆＃34;是文件吗？{：？}＆＃34 ;, metadata.is_file（））;}</p><p> But paths are not necessarily strings. On Unix (!), paths can be any sequenceof bytes, except null bytes.</p><p> 但是路径不一定是字符串。在Unix（！）上，路径可以是任何字节序列，但空字节除外。</p><p> $ cd rustfun/$ touch &#34;$(printf &#34;\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98&#34;)&#34;$ lsls: cannot compare file names ‘Cargo.lock’ and ‘\275\262=\274 ⌘’: Invalid or incomplete multibyte or wide character src target Cargo.lock Cargo.toml &#39;&#39;$&#39;\275\262&#39;&#39;=&#39;$&#39;\274&#39;&#39; ⌘&#39;</p><p> $ cd rustfun / $ touch＆＃34; $（printf＆＃34; \ xbd \ xb2 \ x3d \ xbc \ x20 \ xe2 \ x8c \ x98＆＃34;）＆＃34; $ llsls：无法比较文件名'Cargo .lock'和'\ 275 \ 262 = \ 274⌘'：无效或不完整的多字节或宽字符src目标Cargo.lock Cargo.toml＆＃39;＆＃39; $＆＃39; \ 275 \ 262＆＃39; ＆＃39; =＆＃39; \ 274＆＃39;＆＃39; ⌘＆＃39;</p><p> We&#39;ve just made a file with a  very naughty name - but it&#39;s a perfectlyvalid file, even if  ls struggles with it.</p><p> 我们刚刚制作了一个文件名很顽皮的文件-但这是一个完全有效的文件，即使ls很难解决。 </p><p> $ stat &#34;$(printf &#34;\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98&#34;)&#34; File: = ⌘ Size: 0 Blocks: 0 IO Block: 65536 regular empty fileDevice: 8c70d496h/2356204694d Inode: 72620543991375285 Links: 1Access: (0644/-rw-r--r--) Uid: (197611/ amos) Gid: (197611/ amos)Access: 2020-02-28 13:12:12.783734000 +0100Modify: 2020-02-28 13:12:12.783734000 +0100Change: 2020-02-28 13:12:12.783329400 +0100 Birth: 2020-02-28 13:12:12.783329400 +0100</p><p>$ stat＆＃34; $（printf＆＃34; \ xbd \ xb2 \ x3d \ xbc \ x20 \ xe2 \ x8c \ x98＆＃34;）＆＃34;文件：=⌘大小：0块：0 IO块：65536常规空文件设备：8c70d496h / 2356204694d索引节点：72620543991375285链接：1访问权限：（0644 / -rw-r--r--）Uid：（197611 / amos）Gid： （197611 / amos）访问：2020-02-28 13：12：12.783734000 +0100修改：2020-02-28 13：12：12.783734000 +0100更改：2020-02-28 13：12：12.783329400 +0100出生日期：2020-02 -28 13：12：12.783329400 +0100</p><p> That&#39;s not something we can represent with a  String in Rust, because  RustStrings are valid utf-8, and this isn&#39;t.</p><p> 那不是我们可以用Rust中的String表示的东西，因为RustStrings是有效的utf-8，而事实并非如此。</p><p>  And so, if we use  std::fs::read_dir, we have no problem listing it andgetting its metadata:</p><p>  因此，如果我们使用std :: fs :: read_dir，则列出它并获取其元数据没有问题。</p><p> use std ::fs ; fn  main ( ) {  let entries = fs :: read_dir ( &#34;.&#34; ) . unwrap ( ) ;  for entry  in entries {  let path = entry . unwrap ( ) . path ( ) ;  let meta = fs :: metadata ( &amp;path ) . unwrap ( ) ;  if meta . is_dir ( ) {  println ! ( &#34;(dir) {:?}&#34;, path ) ; }  else {  println ! ( &#34; {:?}&#34;, path ) ; } }}</p><p> 使用std :: fs; fn main（）{让条目= fs :: read_dir（＆＃34;。＆＃34;）。解开（）;用于输入条目{let path = entry。展开（）。路径（）;让meta = fs ::元数据（＆amp; path）。解开（）;如果meta。 is_dir（）{println！ （＆＃34;（dir）{：？}＆＃34 ;, path）; } else {println！ （＆＃34; {：？}＆＃34 ;，路径）； }}}</p><p>   package main import (  &#34;fmt&#34;  &#34;os&#34;) func  main() {  arg  :=  os. Args[1]  f,  err  :=  os. Open( arg)  must( err)  entries,  err  :=  f. Readdir( -1)  must( err)  for  _,  e  :=  range  entries {  if  e. IsDir() {  fmt. Printf( &#34;(dir) %s\n&#34;,  e. Name()) }  else {  fmt. Printf( &#34; %s\n&#34;,  e. Name()) } }} func  must( err  error) {  if  err  !=  nil {  panic( err) }}</p><p>   包主要导入（＆＃34; fmt＆＃34;＆＃34; os＆＃34;）func main（）{arg：= os。 Args [1] f，err：= os。打开（arg）必须（err）条目，err：= f。 _，e：=范围条目{如果e。的Readdir（-1）必须（err）。 IsDir（）{fmt。 Printf（＆＃34;（dir）％s \ n＆＃34 ;，例如Name（））}否则{fmt。 Printf（＆＃34;％s \ n＆＃34 ;，例如Name（））}}} func must（err error）{if err！= nil {panic（err）}}</p><p>   See, there&#39;s no &#34;path&#34; type in Go. Just &#34;string&#34;. And Go strings  are justbyte slices, with no guarantees what&#39;s inside.</p><p>   看，没有路径。输入Go。只是＆＃34;字符串＆＃34;。 Go字符串是justbyte切片，无法保证其中包含什么。</p><p> So it prints garbage, whereas in Rust,  Path does not implement  Display, sowe couldn&#39;t do this:</p><p> 因此它会打印垃圾，而在Rust中，Path不实现Display，因此我们无法做到这一点： </p><p>    And if we wanted a friendlier output, we  could handle both cases: whenthe path happens to be a valid utf-8 string, and when it doesn&#39;t:</p><p>而且，如果我们希望获得更友好的输出，我们可以处理两种情况：路径恰好是有效的utf-8字符串，以及何时路径不正确：</p><p> use std ::fs ; fn  main ( ) {  let entries = fs :: read_dir ( &#34;.&#34; ) . unwrap ( ) ;  for entry  in entries {  let path = entry . unwrap ( ) . path ( ) ;  let meta = fs :: metadata ( &amp;path ) . unwrap ( ) ;  let prefix =  if meta . is_dir ( ) {  &#34;(dir)&#34; }  else {  &#34; &#34; } ;  match path . to_str ( ) { Some (s ) =&gt;  println ! ( &#34;{} {}&#34;, prefix, s ), None =&gt;  println ! ( &#34;{} {:?} (invalid utf-8)&#34;, prefix, path ), } }}</p><p> 使用std :: fs; fn main（）{让条目= fs :: read_dir（＆＃34;。＆＃34;）。解开（）;用于输入条目{let path = entry。展开（）。路径（）;让meta = fs ::元数据（＆amp; path）。解开（）;让前缀=如果meta。 is_dir（）{＆＃34;（dir）＆＃34; }其他{＆＃34; ＆＃34; };匹配路径。 to_str（）{某些=> println！ （＆＃34; {} {}＆＃34 ;，前缀s），无=＆gt; println！ （＆＃34; {} {：？}（无效utf-8）＆＃34 ;，前缀，路径），}}}</p><p> $ cargo run --quiet(dir) ./src ./Cargo.toml ./.gitignore &#34;./\xBD\xB2=\xBC ⌘&#34; (invalid utf-8)(dir) ./.git ./Cargo.lock(dir) ./target</p><p> $ cargo run --quiet（dir）./src ./Cargo.toml ./.gitignore＆＃34; ./ \ xBD \ xB2 = \ xBC⌘＆＃34; （无效的utf-8）（dir）./.git ./Cargo.lock(dir）./target</p><p>  Except when they aren&#39;t. And paths aren&#39;t. So, in Go, all path manipulationroutines operate on  string, let&#39;s take a look at the  path/filepath package.</p><p>  除非他们不是。路径不是。因此，在Go中，所有路径操作例程都对字符串进行操作，让我们看一下path / filepath包。</p><p> Package filepath implements utility routines for manipulating filename pathsin a way compatible with the target operating system-defined file paths.</p><p> 软件包filepath实现了实用程序例程，用于以与目标操作系统定义的文件路径兼容的方式来处理文件名路径。</p><p> The filepath package uses either forward slashes or backslashes, depending onthe operating system. To process paths such as URLs that always use forwardslashes regardless of the operating system, see the path package.</p><p> 文件路径包使用正斜杠或反斜杠，具体取决于操作系统。若要处理诸如URL之类的路径，无论使用什么操作系统，该路径始终使用正斜杠，请参阅路径包。</p><p>  func  Abs( path  string) ( string,  error) func  Base( path  string)  string func  Clean( path  string)  string func  Dir( path  string)  string func  EvalSymlinks( path  string) ( string,  error) func  Ext( path  string)  string func  FromSlash( path  string)  string func  Glob( pattern  string) ( matches [] string,  err  error) func  HasPrefix( p,  prefix  string)  bool func  IsAbs( path  string)  bool func  Join( elem  ... string)  string func  Match( pattern,  name  string) ( matched  bool,  err  error) func  Rel( basepath,  targpath  string) ( string,  error) func  Split( path  string) ( dir,  file  string) func  SplitList( path  string) [] string func  ToSlash( path  string)  string func  VolumeName( path  string)  string func  Walk( root  string,  walkFn  WalkFunc)  error</p><p>  func Abs（路径字符串）（字符串，错误）func Base（路径字符串）字符串func Clean（路径字符串）字符串func Dir（路径字符串）字符串func EvalSymlinks（路径字符串）（字符串，错误）func Ext（路径字符串）字符串func FromSlash（路径字符串）字符串func Glob（模式字符串）（匹配[]字符串，错误错误）func HasPrefix（p，前缀字符串）bool func IsAbs（路径字符串）bool func Join（elem ... string）字符串func Match （模式，名称字符串）（匹配的布尔值，错误错误）func Rel（基本路径，targpath字符串）（string，错误）func Split（路径字符串）（dir，文件字符串）func SplitList（路径字符串）[]字符串func ToSlash（路径字符串）字符串func VolumeName（路径字符串）字符串func Walk（根字符串，walkFn WalkFunc）错误 </p><p>   // Ext returns the file name extension used by path. The extension is the suffix // beginning at the final dot in the final element of path; it is empty if there // is no dot. func  Ext( path  string)  string</p><p>// Ext返回路径使用的文件扩展名。扩展名是后缀// //从path的最后一个元素的最后一个点开始； //如果没有点，则为空。 func Ext（路径字符串）字符串</p><p>  package main import (  &#34;fmt&#34;  &#34;path/filepath&#34;) func  main() {  inputs  := [] string{  &#34;/&#34;,  &#34;/.&#34;,  &#34;/.foo&#34;,  &#34;/foo&#34;,  &#34;/foo.txt&#34;,  &#34;/foo.txt/bar&#34;,  &#34;C:\\&#34;,  &#34;C:\\.&#34;,  &#34;C:\\foo.txt&#34;,  &#34;C:\\foo.txt\\bar&#34;, }  for  _,  i  :=  range  inputs {  fmt. Printf( &#34;%24q =&gt; %q\n&#34;,  i,  filepath. Ext( i)) }} func  must( err  error) {  if  err  !=  nil {  panic( err) }}</p><p>  包主要导入（＆＃34; fmt＆＃34;＆＃34; path / filepath＆＃34;）func main（）{输入：= []字符串{＆＃34; /＆＃34 ;,＆＃34; / 。＆＃34 ;、＆＃34; /。foo＆＃34 ;、＆＃34; / foo＆＃34 ;、＆＃34; /foo.txt&#34 ;、＆＃34; /foo.txt/bar&# 34;，＆＃34; C：\\＆＃34;，＆＃34; C：\\。＆＃34;，＆＃34; C：\\ foo.txt＆＃34;，＆＃34; C ：\\ foo.txt \\ bar＆＃34 ;,}，用于_，i：=范围输入{fmt。 Printf（＆＃34;％24q =＆gt;％q \ n＆＃34;，i，文件路径。Ext（i））}} func must（err error）{if err！= nil {panic（err）}}</p><p> $ go run main.go &#34;/&#34; =&gt; &#34;&#34; &#34;/.&#34; =&gt; &#34;.&#34; &#34;/.foo&#34; =&gt; &#34;.foo&#34; &#34;/foo&#34; =&gt; &#34;&#34; &#34;/foo.txt&#34; =&gt; &#34;.txt&#34; &#34;/foo.txt/bar&#34; =&gt; &#34;&#34; &#34;C:\\&#34; =&gt; &#34;&#34; &#34;C:\\.&#34; =&gt; &#34;.&#34; &#34;C:\\foo.txt&#34; =&gt; &#34;.txt&#34; &#34;C:\\foo.txt\\bar&#34; =&gt; &#34;.txt\\bar&#34;</p><p> $ go运行main.go＆＃34; /＆＃34; =＆gt; ＆＃34;＆＃34; ＆＃34; /.&# 34; =＆gt; ＆＃34;。＆＃34; ＆＃34; /。foo＆＃34; =＆gt; ＆＃34; .foo＆＃34; ＆＃34; / foo＆＃34; =＆gt; ＆＃34;＆＃34; ＆＃34; /foo.txt&#34; =＆gt; ＆＃34; .txt＆＃34; ＆＃34; /foo.txt/bar&#34; =＆gt; ＆＃34;＆＃34; ＆＃34; C：\\＆＃34; =＆gt; ＆＃34;＆＃34; ＆＃34; C：\\。＆＃34; =＆gt; ＆＃34;。＆＃34; ＆＃34; C：\\ foo.txt＆＃34; =＆gt; ＆＃34; .txt＆＃34; ＆＃34; C：\\ foo.txt \\ bar＆＃34; =＆gt; ＆＃34; .txt \\ bar＆＃34;</p><p> Right away, I&#39;m in debating mood - is  .foo&#39;s extension  really  .foo? Butlet&#39;s move on.</p><p> 马上，我正在辩论情绪-.foo的扩展名真的是.foo吗？巴特继续前进。</p><p>  Why? Because the Go standard library makes the assumption that a platform hasa single path separator - on Unix and BSD-likes, it&#39;s  /, and on Windowsit&#39;s  \\.</p><p>  为什么？因为Go标准库假设平台具有单个路径分隔符-在Unix和BSD之类的平台上，在Windowsit的\\上。</p><p>  // in `fun.c` void  main() {  HANDLE  hFile =  CreateFile( &#34;C:/Users/amos/test.txt&#34;,  GENERIC_WRITE, 0,  NULL,  CREATE_NEW,  FILE_ATTRIBUTE_NORMAL,  NULL);  char  * data =  &#34;Hello from the Win32 API&#34;;  DWORD  dwToWrite = ( DWORD)  strlen( data);  DWORD  dwWritten = 0;  WriteFile( hFile,  data,  dwToWrite,  &amp; dwWritten,  NULL);  CloseHandle( hFile);}</p><p>  //在`fun.c`中void main（）{处理hFile = CreateFile（＆＃34; C：/Users/amos/test.txt&#34;，GENERIC_WRITE，0，NULL，CREATE_NEW，FILE_ATTRIBUTE_NORMAL，NULL）； char * data =＆＃34; Win32 API中的Hello DWORD dwToWrite =（DWORD）strlen（数据）; DWORD dwWritten = 0; WriteFile（hFile，data，dwToWrite，＆amp; dwWritten，NULL）; CloseHandle（hFile）;}</p><p> &gt; cl fun.cMicrosoft (R) C/C++ Optimizing Compiler Version 19.23.28107 for x64Copyright (C) Microsoft Corporation. All rights reserved.fun.cMicrosoft (R) Incremental Linker Version 14.23.28107.0Copyright (C) Microsoft Corporation. All rights reserved./out:fun.exefun.obj&gt; .\fun.exe&gt; type C:\Users\amos\test.txtHello from the Win32 API</p><p> ＆gt; cl fun.c适用于x64的Microsoft（R）C / C ++优化编译器版本19.23.28107版权所有（C）Microsoft Corporation。保留所有权利。fun.c Microsoft（R）增量链接程序版本14.23.28107.0版权所有（C）Microsoft Corporation。保留所有权利。/out:fun.exefun.obj&gt; 。\ fun.exe＆gt;从Win32 API输入C：\ Users \ amos \ test.txtHello </p><p>     // src/os/path_windows.go const (	 PathSeparator  =  &#39;\\&#39;  // OS-specific path separator	 PathListSeparator  =  &#39;;&#39;  // OS-specific path list separator)</p><p>// src / os / path_windows.go const（PathSeparator =＆＃39; \\＆＃39; //操作系统特定的路径分隔符PathListSeparator =＆＃39 ;;＆＃39; //操作系统特定的路径列表分隔符）</p><p>  $ go run main.go &#34;/&#34; =&gt; &#34;&#34; &#34;/.&#34; =&gt; &#34;.&#34; &#34;/.foo&#34; =&gt; &#34;.foo&#34; &#34;/foo&#34; =&gt; &#34;&#34; &#34;/foo.txt&#34; =&gt; &#34;.txt&#34; &#34;/foo.txt/bar&#34; =&gt; &#34;&#34; &#34;C:\\&#34; =&gt; &#34;&#34; &#34;C:\\.&#34; =&gt; &#34;.&#34; &#34;C:\\foo.txt&#34; =&gt; &#34;.txt&#34; &#34;C:\\foo.txt\\bar&#34; =&gt; &#34;&#34;</p><p>  $ go运行main.go＆＃34; /＆＃34; =＆gt; ＆＃34;＆＃34; ＆＃34; /.&# 34; =＆gt; ＆＃34;。＆＃34; ＆＃34; /。foo＆＃34; =＆gt; ＆＃34; .foo＆＃34; ＆＃34; / foo＆＃34; =＆gt; ＆＃34;＆＃34; ＆＃34; /foo.txt&#34; =＆gt; ＆＃34; .txt＆＃34; ＆＃34; /foo.txt/bar&#34; =＆gt; ＆＃34;＆＃34; ＆＃34; C：\\＆＃34; =＆gt; ＆＃34;＆＃34; ＆＃34; C：\\。＆＃34; =＆gt; ＆＃34;。＆＃34; ＆＃34; C：\\ foo.txt＆＃34; =＆gt; ＆＃34; .txt＆＃34; ＆＃34; C：\\ foo.txt \\ bar＆＃34; =＆gt; ＆＃34;＆＃34;</p><p>  // src/path/filepath/path.go func  Ext( path  string)  string {	 for  i  :=  len( path)  - 1;  i  &gt;= 0  &amp;&amp;  ! os. IsPathSeparator( path[ i]);  i -- {		 if  path[ i]  ==  &#39;.&#39; {			 return  path[ i:]		}	}	 return  &#34;&#34;}</p><p>  // src / path / filepath / path.go func Ext（路径字符串）字符串{for i：= len（path）-1;我＆gt; = 0＆amp;＆amp; ！ os。 IsPathSeparator（path [i]）; i-{如果path [i] ==＆＃39;。＆＃39; {return path [i：]}} return＆＃34;＆＃34;}</p><p>   // src/os/path_windows.go // IsPathSeparator reports whether c is a directory separator character. func  IsPathSeparator( c  uint8)  bool {	 // NOTE: Windows accept / as path separator.	 return  c  ==  &#39;\\&#39;  ||  c  ==  &#39;/&#39;}</p><p>   // src / os / path_windows.go // IsPathSeparator报告c是否为目录分隔符。 func IsPathSeparator（c uint8）bool {//注意：Windows接受/作为路径分隔符。返回c ==＆＃39; \\＆＃39; || c ==＆＃39; /＆＃39;}</p><p> (Can I just point out how hilarious that &#34;Extension&#34; was deemed longenough to abbreviate to &#34;Ext&#34;, but &#34;IsPathSeparator&#34; wasn&#39;t?)</p><p> （我能否指出“扩展名”被认为足以缩写为“＃Ext ##”，但“＆＃34; IsPathSeparator＆＃34; t不是那么有趣？”）</p><p>   /// Determines whether the character is one of the permitted // path separators for the current platform. pub  fn  is_separator ( c:  char ) -&gt;  bool</p><p>   ///确定字符是否为当前平台允许的//路径分隔符之一。 pub fn is_separator（c：char）->布尔</p><p>  /// The primary separator of path components for the current platform. ///  /// For example, / on Unix and \ on Windows. pub  const MAIN_SEPARATOR:  char</p><p>  ///当前平台的路径组件的主要分隔符。 /// ///例如，在Unix上为/，在Windows上为\。 pub const MAIN_SEPARATOR：char </p><p> The naming along makes it much clearer that there  might be secondary pathseparators, and the rich Path manipulation API makes it much less likelyto find this kind of code, for example:</p><p>命名方式使我们更加清楚可能存在辅助路径分隔符，并且丰富的Path操作API使得查找此类代码的可能性大大降低，例如：</p><p>   if  os. PathSeparator  ==  &#39;/&#39; {		 projname  =  strings. Replace( name, &#34;\\&#34;, &#34; /&#34;,  -1)	}  else  if  os. PathSeparator  ==  &#39;\\&#39; {		 projname  =  strings. Replace( name, &#34; /&#34;, &#34;\\&#34;,  -1)	}</p><p>   如果是。 PathSeparator ==＆＃39; /＆＃39; {projname =字符串。如果是os，请替换（name，＆＃34; \\＆＃34 ;,＆＃34; /＆＃34 ;, -1）}否则。 PathSeparator ==＆＃39; \\＆＃39; {projname =字符串。 Replace（name，＆＃34; /＆＃34 ;,＆＃34; \\＆＃34 ;, -1）}</p><p>   It turns out Rust also has a &#34;get a path&#39;s extension&#34; function, but it&#39;s a lotmore conservative in the promises it makes:</p><p>   事实证明，Rust还具有“获取路径”扩展名。功能，但在其做出的承诺中要保守得多：</p><p> // Extracts the extension of self.file_name, if possible. //  // The extension is: //  // * None, if there is no file name; // * None, if there is no embedded .; // * None, if the file name begins with . and has no other .s within; // * Otherwise, the portion of the file name after the final . pub  fn  extension ( &amp; self ) -&gt;  Option &lt; &amp; OsStr &gt;</p><p> //提取self.file_name的扩展名（如果可能）。 // //扩展名是：// // * *无，如果没有文件名； // *无，如果没有嵌入式。 // *如果文件名以开头，则为None。并且没有其他.s； // *否则，文件名中final之后的部分。 pub fn扩展名（＆amp; self）-＆gt;选项＆lt; ＆amp; OsStr＆gt;</p><p>  fn  main ( ) {  let inputs =  [  r&#34;/&#34;,  r&#34;/.&#34;,  r&#34;/.foo&#34;,  r&#34;/foo&#34;,  r&#34;/foo.txt&#34;,  r&#34;/foo.txt/bar&#34;,  r&#34;C:\&#34;,  r&#34;C:\.&#34;,  r&#34;C:\foo.txt&#34;,  r&#34;C:\foo.txt\bar&#34;,  ] ;  for input  in  &amp;inputs {  use std ::path ::Path ;  println ! ( &#34;{:&gt;20} =&gt; {:?}&#34;, input, Path::new (input ).extension ( ) ) ; }}</p><p>  fn main（）{让输入= [r＆＃34; /＆＃34 ;、 r＆＃34; /.&# 34 ;、 r＆＃34; /。foo＆＃34 ;、 r＆＃34; / foo＆＃34; ，r＆＃34; /foo.txt&#34;，r＆＃34; /foo.txt/bar&#34;，r＆＃34; C：\＆＃34;，r＆＃34; C：\。＆＃34 ;，r＆＃34; C：\ foo.txt＆＃34 ;, r＆＃34; C：\ foo.txt \ bar＆＃34 ;,];用于＆amp; inputs中的输入{使用std :: path :: Path; println！ （＆＃34; {：＆gt; 20} =＆gt; {：？}＆＃34 ;，输入，路径：: new（input）.extension（））； }}</p><p>  $ cargo run --quiet / =&gt; None /. =&gt; None /.foo =&gt; None /foo. =&gt; Some(&#34;&#34;) /foo =&gt; None /foo.txt =&gt; Some(&#34;txt&#34;) /foo.txt/bar =&gt; None C:\ =&gt; None C:\. =&gt; Some(&#34;&#34;) C:\foo.txt =&gt; Some(&#34;txt&#34;) C:\foo.txt\bar =&gt; Some(&#34;txt\\bar&#34;)</p><p>  $货物运行-安静/ =＆gt;没有 /。 =＆gt;无/.foo =＆gt;无/ foo。 =＆gt; Some（＆＃34;＆＃34;）/ foo =＆gt;无/foo.txt =＆gt;某些（＆＃34; txt＆＃34;）/foo.txt/bar =＆gt;无C：\ =＆gt;无C：\。 =＆gt;某些（＆＃34;＆＃34;）C：\ foo.txt =＆gt;某些（＆＃34; txt＆＃34;）C：\ foo.txt \ bar =＆gt;一些（＆＃34; txt \\ bar＆＃34;）</p><p>  $ cargo run --quiet / =&gt; None /. =&gt; None /.foo =&gt; None /foo. =&gt; Some(&#34;&#34;) /foo =&gt; None /foo.txt =&gt; Some(&#34;txt&#34;) /foo.txt/bar =&gt; None C:\ =&gt; None C:\. =&gt; None C:\foo.txt =&gt; Some(&#34;txt&#34;) C:\foo.txt\bar =&gt; None</p><p>  $货物运行-安静/ =＆gt;没有 /。 =＆gt;无/.foo =＆gt;无/ foo。 =＆gt; Some（＆＃34;＆＃34;）/ foo =＆gt;无/foo.txt =＆gt;某些（＆＃34; txt＆＃34;）/foo.txt/bar =＆gt;无C：\ =＆gt;无C：\。 =＆gt;无C：\ foo.txt =＆gt;某些（＆＃34; txt＆＃34;）C：\ foo.txt \ bar =＆gt;没有 </p><p>      Let&#39;s dissect that: first it calls  file_name(). How does that work? Is it whereit searches for path separators backwards from the end of the path?</p><p>我们来剖析一下：首先它调用file_name（）。这是如何运作的？它是从路径末尾向后搜索路径分隔符的地方吗？</p><p> pub  fn  file_name ( &amp; self ) -&gt;  Option &lt; &amp; OsStr &gt; {	 self . components ( ) . next_back ( ) . and_then (|p|  match p {		 Component ::Normal (p ) =&gt; Some (p . as_ref ( ) ),		_ =&gt; None,	} )}</p><p> pub fn file_name（＆amp; self）-＆gt;选项＆lt; ＆amp; OsStr＆gt; {自我。组件 （ ） 。 next_back（）。 and_then（| p |匹配p {组件:: Normal（p）=＆gt;一些（p。as_ref（）），_ =＆gt;无，}）}</p><p> No! It calls  components which returns a type that implements  DoubleEndedIterator -an iterator you can navigate from the front or the back.  Then it grabs the first itemfrom the back - if any - and returns that.</p><p> 没有！它调用组件，该组件返回实现DoubleEndedIterator的类型-您可以从正面或背面导航的迭代器。然后，它从背面抓取第一个项目（如果有的话）并将其返回。</p><p> The iterator  does look for path separators - lazily, in a re-usable way. There isno code duplication, like in the Go library:</p><p> 迭代器确实以可重复使用的方式懒惰地查找路径分隔符。没有代码重复，例如在Go库中：</p><p> // src/os/path_windows.go func  dirname( path  string)  string {	 vol  :=  volumeName( path)	 i  :=  len( path)  - 1	 for  i  &gt;=  len( vol)  &amp;&amp;  ! IsPathSeparator( path[ i]) {		 i --	}	 dir  :=  path[ len( vol) :  i +1]	 last  :=  len( dir)  - 1	 if  last  &gt; 0  &amp;&amp;  IsPathSeparator( dir[ last]) {		 dir  =  dir[: last]	}	 if  dir  ==  &#34;&#34; {		 dir  =  &#34;.&#34;	}	 return  vol  +  dir}</p><p> // src / os / path_windows.go func dirname（path string）string {vol：= volumeName（path）i：= len（path）-1 for i＆gt; = len（vol）＆amp;＆amp; ！ IsPathSeparator（path [i]）{i-} dir：= path [len（vol）：i +1] last：= len（dir）-如果last＆gt; 0＆amp;＆amp; IsPathSeparator（dir [last]）{dir = dir [：last]}如果dir ==＆＃34;＆＃34; {dir =＆＃34;。＆＃34; } return vol + dir}</p><p> So, now we have  only the file name. If we had  /foo/bar/baz.txt, we&#39;re now onlydealing with  baz.txt - as an  OsStr,  not a utf-8  String. We can still haverandom bytes.</p><p> 因此，现在我们只有文件名。如果我们有/foo/bar/baz.txt，现在只处理baz.txt-作为OsStr，而不是utf-8字符串。我们仍然可以拥有随机字节。</p><p>     pub  fn extension ( &amp; self ) -&gt;  Option &lt; &amp; OsStr &gt; {	 if  let Some (file_name ) =  self . file_name ( ) {		 let  (before, after ) =  split_fi</p><p>     pub fn扩展名（＆amp; self）-＆gt;选项＆lt; ＆amp; OsStr＆gt; {如果让Some（file_name）= self。 file_name（）{let（before，after）= split_fi </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride">https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/戈朗/">#戈朗</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/wild/">#wild</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/路径/">#路径</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>