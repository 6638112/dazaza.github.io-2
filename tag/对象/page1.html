<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#对象</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#对象</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1026740.html">纪元图形引擎</a></div><div class="item_title_en"><a target="_blank" href="https://6502disassembly.com/a2-epoch/engine.html">Epoch Graphics Engine</a><span>(6502disassembly.com)</span></div><span class="my_story_list_date">2020-9-28 1:18</span><div class="my_story_list_item_desc">图形可能有点闪烁，当东西重叠时会有很多颜色冲突，但像素填充率很高。每个物体的开销相当高，特别是对于移动的物体。你可以通过降低玩家投射的移动速度到爬行(515a：20000)并快速点击空格键来观察到这一点。在飞行中使用20多个投射的性能相当差；与标题演示(19-矩形纪元标志和8颗星)和空间区域5(1艘船和最多32颗星)......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/图形/">#图形</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/graphics/">#graphics</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1022203.html">扎根的语言学习快与慢</a></div><div class="item_title_en"><a target="_blank" href="https://arxiv.org/abs/2009.01719">Grounded Language Learning Fast and Slow</a><span>(arxiv.org)</span></div><span class="my_story_list_date">2020-9-5 10:46</span><div class="my_story_list_item_desc">下载PDF摘要：最近的研究表明，大型基于文本的神经语言模型，按照传统的监督学习目标进行训练，获得了一种令人惊讶的倾向，可以进行少量和一次性的学习。在这里，我们证明了一个位于模拟3D世界中的具体化Agent，并被赋予了一种新的双编码外部记忆，当用传统的强化学习算法训练时，可以表现出类似的一次性单词学习。在通过连续的视觉......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/language/">#language</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021945.html">对象关系映射是计算机科学的越南(2006)</a></div><div class="item_title_en"><a target="_blank" href="https://blog.codinghorror.com/object-relational-mapping-is-the-vietnam-of-computer-science/">Object-Relational Mapping Is the Vietnam of Computer Science (2006)</a><span>(blog.codinghorror.com)</span></div><span class="my_story_list_date">2020-9-4 0:1</span><div class="my_story_list_item_desc">今年，我有机会在TechEd见到了泰德·纽瓦德(Ted Neward)。泰德在2004年末创造了著名的短语“对象关系映射是我们行业的越南”。
这是一个可怕的类比，但很贴切。我看到开发人员多年来一直在为关系数据库模型和传统对象模型之间的巨大不匹配而苦苦挣扎。而他们提出的所有解决方案似乎都让问题变得更糟。我完全同意Ted......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/关系/">#关系</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021484.html">在简约中自娱自乐</a></div><div class="item_title_en"><a target="_blank" href="https://selflanguage.org/">Self – Fun Through Simplicity</a><span>(selflanguage.org)</span></div><span class="my_story_list_date">2020-9-1 1:2</span><div class="my_story_list_item_desc">Self是一种基于原型的动态面向对象编程语言、环境和虚拟机，其核心是简单、统一、具体和活泼的原则。SELF包括编程语言、用SELF语言定义的对象集合、以及SELF内置的用于编写SELF程序的编程环境。语言和环境试图以尽可能直接和物理的方式向程序员和用户呈现对象。系统采用基于原型的对象构造方式。Self包含专为“严肃”......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/自娱自乐/">#自娱自乐</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fun/">#fun</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1015567.html">设计一个物理引擎</a></div><div class="item_title_en"><a target="_blank" href="https://blog.winter.dev/2020/designing-a-physics-engine/">Designing a Physics Engine</a><span>(blog.winter.dev)</span></div><span class="my_story_list_date">2020-8-1 13:9</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1015567.html"><img src="http://img.diglog.com/img/2020/8/thumb_6b8c6a23a673e3f3d3d9d1794c74ef24.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">巧合的是，就在切尔诺宣布他的游戏引擎系列的时候，我刚刚开始使用我自己的引擎。我迫不及待地想最终就如何制作一部电影有一个专业的意见。对于自学成才的编程，很难不不断地怀疑自己，怀疑自己是否做得对，或者只是认为自己做得对。
最近，他一直在发布关于他的引擎的巨大方面的视频，比如物理和实体系统，这是我真的想通过自己制作来了解的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/物理/">#物理</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/physics/">#physics</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1013758.html">JavaScript记录和元组提案进入第二阶段</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/tc39/proposal-record-tuple">JavaScript Records and Tuples Proposal goes to stage 2</a><span>(github.com)</span></div><span class="my_story_list_date">2020-7-23 23:7</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1013758.html"><img src="http://img.diglog.com/img/2020/7/thumb_4cc867a79e0f116d971b0a175c317057.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">记录和元组只能包含基元和其他记录和元组。您可以将Records和Tuples视为复合原语。由于完全基于基元而不是对象，因此记录和元组是完全不变的。
记录和元组支持舒适的构造、操作和使用习惯用法，类似于使用对象和数组。他们被深入比较的是他们的内容，而不是他们的身份。
JavaScript引擎可以对记录和元组的构造、操作......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/记录/">#记录</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/records/">#records</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1013152.html">Pharo Smalltalk概述</a></div><div class="item_title_en"><a target="_blank" href="https://www.pharo.org/features">Pharo Smalltalk Overview</a><span>(www.pharo.org)</span></div><span class="my_story_list_date">2020-7-21 7:17</span><div class="my_story_list_item_desc">Pharo得益于优雅的设计，可以相对简单地实现许多高级编程技术。以下是其中一些：
在Pharo中，可以消除程序和IDE之间的边界。这意味着您可以在调试期间直接使用代码来直观地表示数据结构，并且可以轻松地修改内置工具以满足您的需要，等等。
在断点上，使用调试器中的自定义电路区域可视化表示形式，对原始调试器内的一段代码运......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/smalltalk/">#smalltalk</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012335.html">对象过多：减少Python实例的内存开销</a></div><div class="item_title_en"><a target="_blank" href="https://pythonspeed.com/articles/python-object-memory/">Too many objects: Reducing memory overhead from Python instances</a><span>(pythonspeed.com)</span></div><span class="my_story_list_date">2020-7-17 0:42</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1012335.html"><img src="http://img.diglog.com/img/2020/7/thumb_0246ad23b833bbcfd8c809c620eb2291.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">每次在Python中创建类的实例时，都会消耗一些内存-包括实际上可能比您关心的数据更大的开销。创建一百万个对象，开销是原来的一百万倍。
而且这种开销可能会累积起来，要么会阻止您运行程序，要么会增加您在硬件配置上的花费。
那么让我们来看看这个开销到底有多大(预告：它很大！)。以及你能做些什么。
在Python中，普通类......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/减少/">#减少</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/reducing/">#reducing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012242.html">泡菜的九大缺陷</a></div><div class="item_title_en"><a target="_blank" href="https://nedbatchelder.com/blog/202006/pickles_nine_flaws.html">Pickle’s Nine Flaws</a><span>(nedbatchelder.com)</span></div><span class="my_story_list_date">2020-7-16 17:8</span><div class="my_story_list_item_desc">Python的icklemodule是序列化和反序列化对象的一种非常方便的方法。它不需要模式，可以处理任意的Python对象。但它也有问题。这篇文章简要解释了这些问题。
有些人会告诉你永远不要用泡菜，因为它不好。我不会走那么远的。我要说的是，只有当你对泡菜的九个缺点没有意见的时候，才可以使用泡菜：
泡菜可以是手工制作......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/九大/">#九大</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pickle/">#pickle</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010027.html">德墨特定律：不要和陌生人说话</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/better-programming/demeters-law-don-t-talk-to-strangers-87bb4af11694">Demeter’s Law: Don’t talk to strangers</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-7-6 6:50</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1010027.html"><img src="http://img.diglog.com/img/2020/7/thumb_ed7bc9fb18965843810a97defd339614.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">德米特定律(LOD)或最小知识原理是开发软件，特别是面向对象程序的设计指南。
这项法律是由伊恩·霍兰德在1987年提出的。霍兰德和他的同事正在使用面向对象编程对一个名为Demeter的系统进行编程。在系统开发过程中，他们意识到满足一系列规则的代码耦合度较低。
德米特定律被称为“不要和陌生人说话”，因为：
每个单位应该......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/德墨特/">#德墨特</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/law/">#law</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1009369.html">OpenJDK中Z垃圾收集器的压缩转发信息</a></div><div class="item_title_en"><a target="_blank" href="https://inside.java/2020/06/25/compact-forwarding/">Compact forwarding information for the Z Garbage Collector in the OpenJDK</a><span>(inside.java)</span></div><span class="my_story_list_date">2020-7-2 4:31</span><div class="my_story_list_item_desc">这里介绍的工作是甲骨文、乌普萨拉大学和KTH联合研究项目的一部分。在inside.java这里关注博客系列，阅读更多关于在斯德哥尔摩的Oracle开发办公室进行的JVM研究的内容。
这是关于我在硕士论文中所做的垃圾收集工作的简短描述。这项工作是与甲骨文合作完成的，这给了我一个机会，让我有机会与才华横溢的人一起解决具有......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/转发/">#转发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1007809.html">巨蟒泡菜的缺陷</a></div><div class="item_title_en"><a target="_blank" href="https://nedbatchelder.com/blog/202006/pickles_nine_flaws.html">Python Pickle’s Flaws</a><span>(nedbatchelder.com)</span></div><span class="my_story_list_date">2020-6-23 23:27</span><div class="my_story_list_item_desc">Python的Pickle模块是序列化和反序列化对象的一种非常方便的方式。它不需要模式，可以处理任意的Python对象。但它也有问题。这篇文章简要解释了这些问题。
有些人会告诉你永远不要用泡菜，因为它不好。我不会走那么远的。我要说的是，只有当你对泡菜的九个缺点没有意见的时候，才可以使用泡菜：
泡菜可以是手工制作的，当......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/泡菜/">#泡菜</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pickle/">#pickle</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1006093.html">联机文本到图表工具</a></div><div class="item_title_en"><a target="_blank" href="https://smusamashah.github.io/text-to-diagram">Online Text to Diagram Tools</a><span>(smusamashah.github.io)</span></div><span class="my_story_list_date">2020-6-11 10:51</span><div class="my_story_list_item_desc">图表：活动、类、组件、对象、用例、序列、状态、部署、计时、GUI、Archimate、甘特图、思维导图、树、数学、实体关系</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/文本/">#文本</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/text/">#text</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1006029.html">YOLOv5在这里：140 FPS的最先进的对象检测</a></div><div class="item_title_en"><a target="_blank" href="https://blog.roboflow.ai/yolov5-is-here/">YOLOv5 Is Here: State-of-the-Art Object Detection at 140 FPS</a><span>(blog.roboflow.ai)</span></div><span class="my_story_list_date">2020-6-11 0:8</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1006029.html"><img src="http://img.diglog.com/img/2020/6/thumb_d0bbbcf0ec5f1db4b54763c4697a0408.gif" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">实时目标检测技术发展迅速。改善的速度甚至更快。结果令人震惊。
3月18日，谷歌开源了他们的EfficientDet实现，这是一种不同规模的快速培训模型，其中之一提供实时输出。4月23日，Alexey Bochoviskiy等人。开源的YOLOv4。6月9日，Glenn Jocher开源实现了YOLOv5。
跳过这篇信......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/state/">#state</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/yolov5/">#yolov5</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1004708.html">渲染和编辑器之间的边界-第2部分：拾取</a></div><div class="item_title_en"><a target="_blank" href="https://ourmachinery.com/post/borderland-part-2-picking/">Borderland Between Rendering and Editor – Part 2: Picking</a><span>(ourmachinery.com)</span></div><span class="my_story_list_date">2020-6-2 2:32</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1004708.html"><img src="http://img.diglog.com/img/2020/6/thumb_62b7bb36b176aa66d66859238e80ee08.gif" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">3月初，我在我们的编辑中写了一篇关于网格渲染的文章。在我们进入今天的主题之前，我想展示一下我自上一篇文章以来添加的网格渲染的一个小功能，即在启用捕捉的情况下渲染对象局部网格，以指导对象的移动：
我认为结果相当不错，感觉像是一个很好的例子，说明了Mechanical的模块化在实践中是如何工作的-只需查询对tm_grid......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/渲染/">#渲染</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rendering/">#rendering</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1003952.html">首先了解JavaScript中的记录和元组</a></div><div class="item_title_en"><a target="_blank" href="https://2ality.com/2020/05/records-tuples-first-look.html">A first look at records and tuples in JavaScript</a><span>(2ality.com)</span></div><span class="my_story_list_date">2020-5-28 0:57</span><div class="my_story_list_item_desc">在这篇博客文章中，我们首先来看看由Robin Ricard和Rick Button提出的ECMAScript提案“Record&amp；Tuple”。该方案在JavaScript中增加了两种复合原始值：
目前，JavaScript仅按值比较诸如字符串之类的原始值(通过查看其内容)：
相反，对象按身份进行比较(对象仅与......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/了解/">#了解</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tuples/">#tuples</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1003841.html">面向C++·V8的高性能垃圾回收</a></div><div class="item_title_en"><a target="_blank" href="https://v8.dev/blog/high-performance-cpp-gc">High-performance garbage collection for C++ · V8</a><span>(v8.dev)</span></div><span class="my_story_list_date">2020-5-27 5:2</span><div class="my_story_list_item_desc">在过去，我们已经写过关于JavaScript的垃圾收集、文档对象模型(DOM)，以及如何在V8中实现和优化所有这些内容。不过，Chromium中并不是所有的东西都是JavaScript，因为嵌入了V8的浏览器及其Blink渲染引擎的大部分都是用C++编写的。JavaScript可用于与DOM交互，然后由呈现管道处理该......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1003789.html">如何在JavaScript中检测对象是否已被垃圾回收</a></div><div class="item_title_en"><a target="_blank" href="http://stevehanov.ca/blog/?id=148">How to detect if an object has been garbage collected in JavaScript</a><span>(stevehanov.ca)</span></div><span class="my_story_list_date">2020-5-26 23:7</span><div class="my_story_list_item_desc">如果您正在用Javascript编写应用程序，很快您将不得不担心内存泄漏。但是，甚至很难知道是否存在内存泄漏。这个方便的方法可以有所帮助。起初，您可能认为WeakMap可以做到这一点。WeakMap/WeakSet将为您保留内容，但不要阻止对象被垃圾收集。一旦对象是GC&#39；d，它就会从WeakMap或WeakS......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/object/">#object</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1003564.html">跨语言互操作性的挑战(2013)</a></div><div class="item_title_en"><a target="_blank" href="https://queue.acm.org/detail.cfm?id=2543971">The Challenge of Cross-language Interoperability (2013)</a><span>(queue.acm.org)</span></div><span class="my_story_list_date">2020-5-25 4:15</span><div class="my_story_list_item_desc">2013年11月19日第11卷第10期自从第二种编程语言发明以来，语言之间的互操作性一直是个问题。解决方案的范围从独立于语言的对象模型(如COM(组件对象模型)和CORBA(公共对象请求代理体系结构))到为集成语言而设计的VM(虚拟机)，如JVM(Java虚拟机)和CLR(公共语言运行时)。随着软件变得越来越复杂，硬......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cross/">#cross</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1002254.html">CMU的OpenTPOD：创建无需编码的深度学习对象检测器</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/cmusatyalab/opentpod">CMU's OpenTPOD: Create Deep Learning Object Detectors Without Coding</a><span>(github.com)</span></div><span class="my_story_list_date">2020-5-16 0:50</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1002254.html"><img src="http://img.diglog.com/img/2020/5/thumb_106c065e1e5e8355f3ffe493f4161598.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">OpenTPOD是一个一体式开源工具，供非专家创建自定义深度神经网络对象检测器。它的设计目的是降低进入门槛，并促进使用最先进的深度学习方法的自定义对象检测的端到端创作工作流。
一键训练/微调目标检测深度神经网络，包括SSD MobileNet、更快的RCNN Inception和更快的RCNN ResNet，使用Te......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/深度学习/">#深度学习</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/opentpod/">#opentpod</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1002234.html">没有对象或虚拟函数的运行时多态性</a></div><div class="item_title_en"><a target="_blank" href="https://www.fluentcpp.com/2020/05/15/runtime-polymorphism-without-virtual-functions/">Runtime Polymorphism Without Objects or Virtual Functions</a><span>(www.fluentcpp.com)</span></div><span class="my_story_list_date">2020-5-15 23:1</span><div class="my_story_list_item_desc">当考虑多态性，特别是运行时多态性时，首先想到的是虚函数。
虚拟函数非常强大，适合某些用例。但在使用它们之前，最好考虑一下我们对多态性的确切需求，看看是否有其他更适合的工具来满足它。
实际上，虚函数会在对象上创建多态性。但是，如果您不需要对象怎么办？如果您只需要您的代码根据某些条件以不同的方式运行，但是您不需要任何涉及......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/计算器/">#计算器</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="/tag/对象/">0</a></li><li class="page-item active"><a class="page-link" href="/tag/对象/page1.html">1</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>