<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>耐久性规律 The Laws of Durability</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Laws of Durability<br/>耐久性规律 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-14 23:42:25</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/b8321d825abe4a7e23679749bade0932.jpeg"><img src="http://img2.diglog.com/img/2021/3/b8321d825abe4a7e23679749bade0932.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>When it comes tohaving durable data, there are four ways to do it:  undo log,  redo log,  shadowcopy and  shadow data.</p><p>在持续耐用的数据时，有四种方法可以做到：撤消日志，重做日志，镜像和影子数据。</p><p>    Well, durable meansthat whatever data you&#39;re trying to save, has reached your storage device in aconsistent way. It means that when you write to storage you want it to be&#34;permanent&#34;, whether that storage device is a USB key, a CD ROM, anhard drive, and SSD, or a non-volatile memory DIMM like Intel&#39;s Optane DC PM.</p><p>    嗯，耐用的意思是你尝试保存的任何数据，都以发声方式到达了您的存储设备。这意味着当您写入存储时，您希望它成为＆＃34;永久和＃34;那里是该存储设备是USB密钥，CD ROM，ANHARD驱动器和SSD，还是像英特尔＆＃的非易失性存储器DIMM 39; S Optane DC PM。</p><p> For any of thesestorage devices, the algorithms are always the same: you have to use one of thefour mentioned above.</p><p> 对于任何历程设备，算法始终相同：您必须使用上面提到的其中一个。</p><p> Keep in mind thatthese are needed if the data needs to be consistent, i.e. you want to see thewhole data before the storage or none of the data. I mean, if we were ok withhaving garbled data, then why would we bother saving it in permanent storage?The whole point of making data durable is because it has important informationand therefore, it implies consistency.</p><p> 请记住，如果数据需要保持一致，即您希望在存储之前或没有数据之前看到窗口数据。我的意思是，如果我们还可以使用乱码的数据，我们为什么要在永久存储中幸免于它？制作数据的整个点是因为它具有重要信息，因此它意味着一致性。</p><p>   I&#39;m going to focuson these in the context of transactions, but they don&#39;t have to be necessarilyabout that.</p><p>   我将在交易的背景下重点融合这些，但他们不必如此。</p><p>  Undo log istechnique where we write to durable storage a log entry of each write is doneto storage. It allows multiple independent (non-atomic) writes to becomedurable in an all-or-nothing way, like a transaction, or a checkpoint.</p><p>  undo log iStechnique在我们写入持久存储的位置，每次写入的日志条目是doneto存储。它允许多个独立的（非原子）写入以全面或无线方式可获得，如事务或检查站。</p><p> In the context ofpersistent memory,  libpmemobj in PMDK is an example of a transactional systemthat uses undo log.</p><p> 在逻辑内存中的上下文中，PMDK中的LibpMemobj是事务系统的示例，它使用撤消日志。 </p><p>  In  Redo log we writethe log with multiple entries to storage before writing the actual data. Thedifference between redo and undo is that undo log does one entry in the log ata time followed by one modification, while the redo log does all entries in thelog in one shot and then all the modifications in one shot.</p><p>在Redo日志中，我们在编写实际数据之前，请在使用多个条目的日志中编写日志。重做和撤消之间的目的是，撤消日志在日志ATA时间内执行一个条目，然后是一个修改，而重做日志在一个拍摄中在Thelog中的所有条目，然后一次拍摄的所有修改。</p><p>   Shadow copy,sometimes called Copy-On-Write ( COW) creates a new replica of the data andwrites the new data along with the unchanged contents to durable storage,before swapping some kind of pointer to indicate the this is the newobject/data and the old one can be discarded. COW can&#39;t really be used byitself for transactions over multiple objects, but it can be combined with redolog to make it more efficient.</p><p>   暗影副本，有时称为编写写作（COW）创建一个新的数据副本，并在交换某种指针之前，将新数据与未改变的内容一起与耐用存储一起，以指示这是newObject /数据和数据旧的人可以被丢弃。 COW CAN＆＃39; t真的是在多个对象上进行的交易，但它可以与REDOOL结合，使其更有效。</p><p>   Shadow data cansometimes be confused with COW but it is not the same thing. In shadow data two (or more)replicas of the entire data are kept in durable storage and they both areupdated with the modifications, one at a time. First one replica, then alogical pointer and then the second replica. On the next set of atomic writesthe recently updated replica is the first to be updated.</p><p>   阴影数据cansmimes与牛混淆，但它不是一回事。在阴影数据中，整个数据的两种（或更多）副本保存在耐用的存储中，并且一次将其进行了一次修改。第一个副本，然后是可动性的指针，然后是第二个副本。在下一组原子译文上，最近更新的副本是第一个更新的副本。</p><p>    We though long andhard at the similarities and differences between these four algorithms fordurable transactions, and we found they possess four common characteristics,regardless of the underlying storage media for which they are intended.</p><p>    我们虽然长时间的虽然在这四种算法之间的相似之处和差异，但我们发现它们具有四个共同特征，无论它们的底层存储介质如何。</p><p> Each one of thesecharacteristics reveals an important insight into the concept of durability andwe believe these to be empirical rules to which all durable techniques abide.These rules are:</p><p> 对象中的每一个都揭示了对耐用性概念的重要洞察力，我们认为这些是所有持久技术遵守的经验规则。这些规则是：</p><p>    The first keyinsight regarding durable transactions is that a consistent and durable  replicaof the data must exist at all times. This replica may be a full copy of thedata, such as on shadow data, or it may be a logical replica, such as on undolog and redo log.</p><p>    关于持久事务的第一个keyInsight是数据必须始终存在的一致和持久的副本。此副本可能是TheData的完整副本，例如在阴影数据上，或者它可能是逻辑副本，例如未经删除和重做日志。</p><p> Intuitively, therehas to be a consistent replica of the data, so that there is a way to recoverdata to its original consistent state in the event of a failure. Shadow datakeeps a full replica of the data thus incurring a high permanent usage of thedurable media (space amplification), while the undo log and redo log approacheshave to write in durable storage, not just the new data but also, encodedinformation about the location and size of the modification (writeamplification).</p><p> 直观地，有一个是数据的一致副本，因此在发生故障时有一种方法可以在其原始一致状态下恢复到其原始的一致状态。 Shadow Datakeeps的全部复制品，因此，凸起的媒体（空间放大）的高永久性使用，而撤消日志和重做日志接近以写入耐用存储，而不仅仅是新数据，还有，还有关于位置和大小的编码信息修改（Writeamplification）。 </p><p> There&#39;s clearly animportant trade-off here: log-based algorithms will increase (amortized) writeamplification but shadow-data-based algorithms will increase spaceamplification.</p><p>这里有明显的动漫折衷：基于日志的算法将增加（摊销）编写池，但基于阴影数据的算法将增加间隔展。</p><p>  The second empiricalrule implies that the algorithm must ensure that, irrespective of when afailure occurs, there is a way for the recovery procedure to determine which ofthe replicas is  consistent.</p><p>  第二个empiricalrule意味着算法必须确保，无论发生遗迹，都有一种方法，恢复过程确定哪些复制品是一致的。</p><p> Shadow data likeRomulus uses a two-bit variable to determine which of the two replicas isconsistent, while redo log and undo log can use the size of the log (zero ornon-zero) to indicate if the log is consistent.</p><p> 影子数据likeromulus使用两位变量来确定两个副本中的哪一个，而重做日志和撤消日志可以使用日志（零ornon-onony）的大小来指示日志是否一致。</p><p> By itself, there isno significant difference in any of the approaches however, the exactmechanics, will influence the number of ordering constraints in the algorithm.</p><p> 本身，任何方法都没有显着差异，但是精确的力学将影响算法中的排序约束的数量。</p><p>  This leads us to thethird insight, that data consistency is possible only through  ordering of someof the writes.</p><p>  这导致我们才能识别，只有通过订购写作的订购，可以实现数据一致性。</p><p> For shadow-copying,the modifications on the new block must be made durable  before thepointer swap, otherwise a failure occurring after the pointer swap is madedurable, would leave the pointer referencing an inconsistent block. This meansthat apart from block allocation and de-allocation details, shadow-copying hasa single ordering constraint, or in other words, a single ordering fence.</p><p> 对于卷影复制，必须在Pointer交换之前对新块的修改持续，否则在指针交换后发生故障，将使指针引用不一致的块。这意味着除了块分配和解除分配细节之外，影子复制Hasa单个订购约束，还是换句话说，单个订购围栏。</p><p> Shadow data likeRomulus uses a two-bit state (though one bit would suffice) to indicate whichof the two replicas is the consistent one, or whether both are consistent. Ifthe state variable indicating which replica is the consistent one becomesdurable before or after the modifications on either replica and a crash occurs,upon recovery it may be referencing the inconsistent replica. For thisalgorithm, three ordering constraints exist: one to prevent the state fromchanging to COPYING  before the modifications in main replica aredone; another to prevent the modifications in back replica from being done  before the state changes to COPYING; and another one to prevent thestate change to IDLE  before the changes on back replica are durable.</p><p> 影子数据likeromulus使用双位状态（虽然一点就足够）来指示两个副本是一致的一个，或者两者是一致的。如果指示哪个副本的状态变量是在副本的修改之前或之后的一致性的状态变量，则在恢复时，可以参考不一致的副本。对于本发明算法，存在三个排序约束：一个以防止状态从主副本aredone的修改之前从复制到复制;另一种防止在状态更改复制之前从后退副本中的修改;而另一个可以防止在反复复制品的更改之前阻止变为空闲。 </p><p> The undo logtechnique has two constraints per modified object/range: the log entry mustcontain the old value  before the entry is added to the log; and theentry must be added to the log  before the modification is done on thedata. Undo log has one extra constraint per transaction, requiring the lastmodification to be durable  before the log is reset.</p><p>undo logtechnique每个修改的对象/范围有两个约束：日志条目必须在输入到日志之前的旧值;在TheData上完成修改之前，必须将Entry添加到日志中。 undo log每个事务具有一个额外的约束，要求在重置日志之前持久进行持久。</p><p> The Redo logtechnique has three constraints per transaction: all the log entries must bedurable  before the log size is set; the log size must be set  before the modifications are done on the data; the modifications onthe data must be durable  before the log is reset.</p><p> Redo Logtechnique每次交易有三个约束：在设置日志大小之前，所有日志条目必须耐用;必须在对数据上进行修改之前设置日志大小;在重置日志之前，数据的修改必须持久。</p><p>  The fourth and finalrule addresses the need for a  round-trip synchronization mechanism to thestorage domain, such that the hardware can guarantee that it contains, instable durable storage, all the previously written data. The cost of such afence is typically of the order of the storage device&#39;s latency.</p><p>  第四个和FinalLule解决了对脚轮域的往返同步机制的需要，使得硬件可以保证它包含，可稳定的耐用存储，所有先前写入的数据。这种情况的成本通常是存储设备的顺序＆＃39;延迟。</p><p> Fast devices like PMimplement this round-trip fence orders of magnitude faster than slower devices,like hard drives.</p><p> 像PMIMPLEMENT这样的快速设备此往返围栏的数量级比较慢的设备更快，如硬盘驱动器。</p><p> Without such amechanism, it is not possible to have durable operations, even if orderingconstraints are set: in the event of a failure, the ordering constraints imposea temporal sequence of which the writes will be made durable, but there is noguarantee on durability.</p><p> 如果没有这样的机狱，即使设置了OrderingConstraints，也不可能具有持久的操作：如果发生故障，则在发生故障时，将持久的持久性序列的排序限制是持久的，但是耐久性的诺斯坦假设。</p><p> A corollary of thisis that all algorithms require one and only one such fence, strategicallyplaced.</p><p> 所有算法都需要一个且只有一个这样的栅栏，战略性地围栏。</p><p> Notice that theordering constraints may be replaced by such synchronous fences, at thedetriment of performance, and in fact, many storage systems make no distinctionbetween the two. Ordering is typically achieved with an asynchronrous fence andit relates to the order to which certain writes will be made durable in thestorage media.</p><p> 请注意，由于性能的分枝，并且实际上，许多存储系统在两者中没有区分，因此可以通过这种同步围栏代替。通常通过异步栅栏实现订购，并且涉及某些写入将在特定介质中进行耐用的顺序。 </p><p>  In Persistent Memory(PM) ordering can be achieved through the combination of flushes (clwb) andfences (sfence) or by writing to the same cache line. The round-trip guaranteeof durability is given by a synchronous fence, either  fsync()/fdatasync()on block storage, or  sfence on PM storage.</p><p>在持久存储器（PM）中，可以通过刷新（CLWB）和文件（SFENCE）的组合或通过写入同一缓存行来实现订购。耐久性的往返保障是由同步栅栏，fsync（）/ fdatasync（）上的块存储，或在PM存储上的Sfence。</p><p>  In case you haven&#39;tnoticed, the fact that all algorithms require one round-trip fence to thedevice (psync), but may require multiple ordering fences (pfence) hasimplications in performance. This is specially true given that the psync hasinescapable physical implications:  it is not possible to have all-or-nothingconsistent durability without a psync that physically does a round trip to thestorage device (or at least the storage domain) and therefore the latency costof this single round trip is inescapable.</p><p>  如果您没有＃39;这一事实，所有算法都需要一个往返围栏的事实，而是可能需要多个订购围栏（PFENCE）具有性能的HASIMPLIMICS。考虑到Psync具有具有物理影响：没有Psync的Psync，这是特别的，这是特别的真实的，没有Psync，它物理地对Thestorage设备（或至少存储域）进行往返，因此延迟成本单一往返旅行是不可避免的。</p><p>   Yes, fsync() is usedfor both sync and ordering on block devices, and the sfence instruction is alsoused for both in PM, however, there are tricks. In PM, writes to the same cacheline are guaranteed to be ordered and therefore, no sfence is needed to orderthem, as long as store with memory_order_release is used.</p><p>   是的，FSYNC（）用于块设备上的同步和排序，并且SFENCE指令在PM中都有陈旧，但是，有技巧。在PM中，保证对同一个高速缓冲线的写入是订购的，因此，只要使用Memory_Order_Releaseease的存储，orderthem即可不需要Sf等。</p><p> Seen as these roundtrips are typically the bottleneck when doing random writes to PM, the factthat we can create an algorithm with a lower number of psyncs means we can havea performance gain that is nearly proportional to the reduction in the number ofsuch fences.</p><p> 由于这些往返通常是对PM进行随机写入时的瓶颈，因此我们可以创建一个具有较小PSYNC的算法意味着我们可以获得与宇宙数量的减少成比例的性能增益。</p><p>   Trinity is a noveldurability technique that needs just two fences per transaction and reduces thenumber of flushes when doing random writes. It consumes more memory than theother previous techniques but it has significant higher performance.</p><p>   Trinity是一种不需要的技术，只需每次交易中只需要两个围栏，并且在随机写入时减少了冲洗的模糊。它比以前的技术人员消耗更多的内存，但它具有显着的性能。</p><p> Moreover, wecombined it with our own variant of TL2 for highly scalable durablelinearizable transactions, and we used that to make a K/V store, which islikely that fastest K/V store on the planet with full transactions (though youneed Optane Persistent Memory to be able to run it).</p><p> 此外，使用我们自己的TL2变体讨论了高度可扩展的耐麸屈得可巧的事务，我们使用它来制作K / V商店，这是一个具有完整事务的星球上最快的K / V商店（虽然您是您的Optane持久存储器能够运行它）。</p><p>      https://youtu.be/vdInrf_kk1w</p><p>      https://youtu.be/vdinrf_kk1w </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://concurrencyfreaks.blogspot.com/2021/03/the-4-laws-of-durability.html">https://concurrencyfreaks.blogspot.com/2021/03/the-4-laws-of-durability.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/耐久性/">#耐久性</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/laws/">#laws</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012 - 2021 diglog.com </div></div></body></html>