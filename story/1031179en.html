<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>不，C++仍然不支持</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">不，C++仍然不支持</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-26 10:56:40</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/3884453f3945027ebd4444634fa4c369.png"><img src="http://img2.diglog.com/img/2020/10/3884453f3945027ebd4444634fa4c369.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>While that title presumes the answer (after all, a &#34;bad rap&#34; implies that the judgement is undeserved), I think C++&#39;s reputation for making it very difficult to achieve security or memory safety or thread-safety remains well-deserved, even though it&#39;s gotten a lot better over the years. I mean that: The c++-17 version of that program is years better than it would have been with c++0x, and it let a careful programmer write a nice program.</p><p>虽然这个标题假定了答案(毕竟，糟糕的说唱意味着这个判决是不值得的)，但我认为C++让实现安全性、内存安全或线程安全变得非常困难的名声仍然是当之无愧的，尽管多年来它已经变得好了很多。我的意思是：该程序的c++-17版本比使用c++0x要好几年，而且它让细心的程序员可以编写出很好的程序。</p><p> The post used a simple multi-file word count as an example:  Count all words in all &#34;.txt&#34; files in the current directory and all of its subdirectories, where words were defined as things matching the regexp  &#34;([a-z]{2,})&#34; in a case-insensitive manner.</p><p>这篇帖子以一个简单的多文件字数统计为例：统计当前目录及其所有子目录中所有&#34；.txt&34；文件中的所有字数，其中的字数被定义为以不区分大小写的方式与regexp&34；([a-z]{2，})&#34；匹配的字数。</p><p> First, I&#39;ll walk through the example from that blog post and identify some remaining bugs.  And then we&#39;ll build up a (IMO) better version in Rust that&#39;s faster, safer, and more concise.  Let&#39;s start with the body that processes the files and adds the counts to a hash table:</p><p>首先，我将浏览该博客文章中的示例，并找出一些剩余的错误。然后，我们将在Rust中构建一个(IMO)更好的版本，它更快、更安全、更简洁。让我们从处理文件并将计数添加到哈希表的正文开始：</p><p>  A few things immediately come to mind when examining this code from a safety perspective.  First, it uses a  filesystem::recursive_directory_iterator to identify the files in the current directory, testing their types and names before processing them.  It then opens the file using  std::ifstream.</p><p>当从安全角度检查此代码时，有几件事立即浮现在脑海中。首先，它使用文件系统：：RECURSIVE_DIRECTORY_Iterator命令来标识当前目录中的文件，在处理它们之前测试它们的类型和名称。然后，它使用std：：ifstream打开文件。</p><p> From the way I phrased this, you&#39;re probably already guessing that this is a TTCTTOU eror -- time-to-check-to-time-of-use. The program validates that the entry is a regular file, but then later opens it, and assumes that the result of the check holds. We should ask ourselves:</p><p>从我用词的方式来看，您可能已经猜到这是TTCTTOU的错误--检查时间到使用时间(Time-to-Check-to-Time-of-Use)。该程序验证该条目是否为常规文件，但稍后将其打开，并假定检查结果有效。我们应该问问自己：</p><p>  What happens if the file has been deleted between the directory listing and the open?</p><p>如果文件在目录列表和打开之间被删除，会发生什么情况？</p><p> What happens if the file has been replaced by, e.g., a pipe or other not regular_file?</p><p>如果文件已替换为管道或其他非常规文件，会发生什么情况？</p><p>For the second case, it&#39;s pretty clear that the program will try to open it and operate on it; this is therefore a bug with respect to the intent of the programmer. Is it a huge bug in this context? Not at all, but analogous bugs have led to serious security problems.  For the first case, I wasn&#39;t sure - and I bet many other C++ programmers aren&#39;t either. The answer is that the std::ifstream is safe, and will simply behave in the same way as if EOF was reached, but I wasn&#39;t certain about that until I googled it a lot and wrote a test program to verify it. Accidental correctness is better than being wrong, but we should strive for more in our programs.  Finally, the way it&#39;s written isn&#39;t very conducive to future multithreading. That&#39;s wasn&#39;t the point of the exercise, but I think it&#39;s worth thinking about as many modern data processing programs take an evolutionary path from single-threaded to multi-threaded. Constructs like this invite threading bugs:</p><p>对于第二种情况，很明显，程序将尝试打开它并对其进行操作；因此，从程序员的意图来看，这是一个错误。在这种情况下，它是一个巨大的错误吗？完全没有，但类似的漏洞已经导致了严重的安全问题。对于第一种情况，我不确定-我打赌其他许多C++程序员也不确定。答案是std：：ifstream是安全的，它的行为方式就像访问了EOF一样，但我并不确定这一点，直到我在谷歌上搜索了很多次，并编写了一个测试程序来验证它。偶然的正确总比错误好，但是我们应该在我们的程序中争取更多的东西。最后，它的编写方式对未来的多线程不是很有帮助。这不是练习的重点，但我认为这是值得考虑的，因为许多现代数据处理程序都采用了从单线程到多线程的进化道路。这样的构造会招致线程错误：</p><p>  (1) It separates the computation of a safe size range from the use of that range;  (2) it destructively modifies the word_array for no reason other than to make it easy to print the first 10 items.  And adding multithreading to things in C++ still remains somewhat painful.  Here are some reasons I&#39;m coming to prefer Rust as a systems language. It&#39;s not remarkably shorter - the Python or shell version of all this can be expressed in a few lines of code!  But it&#39;s a bit shorter, and it&#39;s more clear where corners have been cut or errors properly handled:     Ok, that&#39;s 39 lines of code, but not counting the Cargo.toml file, which is another 4 of non-boilerplate (the four dependencies, which are fairly analogous to the #include lines in the C++ version, so should be counted).</p><p>(1)它将安全大小范围的计算与该范围的使用分开；(2)它无缘无故地破坏性地修改WORD_ARRAY，只是为了方便打印前10项。而且在C++中为事物添加多线程仍然有些痛苦。(2)它将安全大小范围的计算与该范围的使用分开；(2)它无缘无故地破坏性地修改word_array，只是为了便于打印前10项。以下是我更喜欢将Rust作为系统语言的一些原因。它并不是特别短-Python或shell版本的所有这些都可以用几行代码来表示！但是它稍微短了一点，而且它更清楚哪里被偷工减料或者正确处理了错误：好的，这39行代码，但不包括Cargo.toml文件，它是另外4行非样板文件(这四个依赖项相当类似于C++版本中的#include行，所以应该被计算在内)。(这四个依赖项相当类似于C++版本中的#include行，所以应该被计算在内)，但不包括Cargo.toml文件，它是另一个非样板文件(这四个依赖项非常类似于C++版本中的#include行，所以应该计算在内)。</p><p>  A little shorter.  But what I like about the Rust version is that there&#39;s a lot less guessing about the error handling.  Did the file fail to open?  We know it&#39;s skipped, because the  filter_map will discard that file if the result of the open is not ok.  We know errors in  globwalk or constructing the regex are handled, because the  ? will cause the function to return an error if they return an error.  The more functional  . take(N) idiom is a little more idiot-proof than the equivalent code in the C++ version, as we know it returns early if there are fewer than N items.</p><p>稍微短了一点。但我喜欢Rust版本的一点是，关于错误处理的猜测少了很多。文件打开失败了吗？我们知道它被跳过了，因为如果打开的结果不好，filter_map会丢弃该文件。“我们知道globwald或构造正则表达式中的错误都会得到处理，因为？如果函数返回错误，将导致函数返回错误。功能越强。Take(N)惯用语比C++版本中的等效代码更容易出错，因为我们知道，如果条目少于N项，它就会提前返回。</p><p>  While modern C++ lets a careful programmer write a good program, it still lets a less-careful programmer do things in ways that create errors. Rust has less of that: it will nag you to cover corner cases more carefully.</p><p>虽然现代C++允许细心的程序员编写好的程序，但它仍然允许粗心的程序员以产生错误的方式做事。铁锈就没有那么多了：它会缠着你，让你更仔细地盖住角落里的箱子。</p><p>  Rust doesn&#39;t make it magically easier to avoid that TTCTTOU problem - it would have been just as easy to write the code using   std::fs::metadata(path) in the same way it was in the C++ version.  But it does improve my confidence that were that bug present, the code would have handled the &#34;file doesn&#39;t exist&#34; problem. But it still would have opened a special file or directory with aplomb.  It&#39;s also very easy to convert to a multithreaded program:  Just turn the for x in ... loop into a for_each, and use the  Rayon crate  .par_bridge() to cause the function in for_each to be executed in parallel.</p><p>生锈并不能神奇地使避免TTCTTOU问题变得更容易-使用std：：fs：：Metadata(Path)编写代码与在C++版本中一样简单。但是它确实增强了我的信心，即如果该错误存在，代码就会处理文件不存在的问题。但它仍然会以沉着的方式打开一个特殊的文件或目录。它也很容易转换成多线程程序：只需将FOR x在……中。循环到for_each中，并使用raon crate.par_bridge()使for_each中的函数并行执行。</p><p>    Of course, that won&#39;t compile, because we&#39;ve forgotten to use any locking on the hash table into which we&#39;re inserting counts:</p><p>当然，这无法编译，因为我们忘记了对重新插入计数的哈希表使用任何锁定：</p><p>  error[E0596]: cannot borrow `wordcounts` as mutable, as it is a captured variable in a `Fn` closure</p><p>错误[E0596]：无法将`wordcounts`借用为可变变量，因为它是`Fn`闭包中的捕获变量。</p><p>   So then we either switch it to a parallel hash table, or we guard it with a mutex. I&#39;ll take the simple approach of locking the table before using it, and do just enough optimization to make it faster than the single-threaded version. In this case, I parse each line into lowercased-words, which I store in a vector, before locking the hash table and then bulk-inserting the line&#39;s worth of words:</p><p>因此，我们要么将其切换到并行哈希表，要么使用互斥来保护它。我将采取简单的方法，在使用表之前将其锁定，并进行足够的优化，使其比单线程版本更快。在本例中，我将每行解析为小写单词，并将其存储在向量中，然后锁定哈希表，然后批量插入该行的单词：</p><p>    Not bad - about ten lines of code changed to make a basic parallel version of the code.</p><p>不错--大约有十行代码被修改，形成了一个基本的并行代码版本。</p><p>  There are some advantages to the C++ version that reflect the immaturity of the Rust standard library.  It was able to easily use a partial_sort to reduce the amount of work done sorting by counts; I had to find the lazysort crate, which isn&#39;t part of the standard library, which does the same thing.</p><p>C++版本有一些优点反映了Rust标准库的不成熟。它能够很容易地使用Partial_Sort来减少按计数排序的工作量；我必须找到lazysorcrate，它不是标准库的一部分，它做同样的事情。</p><p>  Both are fast; depending on the C++ compiler, the rust one may or may not be faster.  ( Updated:  More benchmarks, prompted by @cb321 on hacker news, and switched the benchmark to something easily downloaded:  Charles Dickens &#34; A Tale of Two Cities&#34;)   - I7-7920HQ, MacOS Rust version: 90ms (rustc 1.47.0 (18bf6b4f0 2020-10-07)) C++ version: 340ms (Apple clang version 12.0.0 (clang-1200.0.32.2)) - Xeon(R) Gold 6130 (skylake, Ubuntu 20.04) Rust: 76ms (rustc-1.47.0) C++: 60ms (gcc version 9.3.0 (Ubuntu 9.3.0-10ubuntu2)), -O3, no PGO</p><p>两者都很快；根据C++编译器的不同，锈色的可能更快，也可能不更快。)(更新：更多基准，由@cb321在黑客新闻上提示，并将基准切换到容易下载的东西：查尔斯·狄更斯；A Tale of Two Cities&#34；(更新：更多基准，由@cb321在黑客新闻上提示)：查尔斯·狄更斯&#34；双城记&#34；)-i7-7920HQ，MacOS Rust版本：90ms(rustc 1.47.0(18bf6b4f02020-10-07))C++版本：340ms(Apple clang版本12.0.0(clang-1200.0.32.2))-至强(R)Gold6130(Skylake，Ubuntu20.04)rut：76ms(rustc-1.47.0)C++：60ms(GCC版本9.3.0(Ubuntu 9.3.0-10ubuntu2))，-O3，无PGO。</p><p> With a lot of larger files, the parallel version can wordcount four 2mb sample files in 0.307 seconds using a quad-core CPU - not quite linear scaling, but not bad for a few minutes of tweaking.  The single-threaded C++ version, meanwhile, is stuck taking about 3.55 seconds on MacOS.</p><p>并行版有很多更大的文件，使用四核处理器可以在0.307秒内数出4个2MB的样本文件-这不是很线性的缩放，但对于几分钟的调整来说还不错。同时，单线程C++版本在MacOS上停留了大约3.55秒。</p><p>  Despite its shorter length, the Rust version probably took me longer to write than the C++ version would have.  I had to spend more time figuring out what functions returned so I could handle their possible return types, and had to spend a bit more time googling for things like the filesystem metadata, probably because I&#39;m newer to the language. But making it correct and making it parallel took  less time, even though I&#39;m less experienced in the language. I&#39;ll take that tradeoff in a lot of what I do.</p><p>尽管Rust版本的长度较短，但可能比C++版本花了我更长的时间来编写。我不得不花更多的时间弄清楚返回了哪些函数，以便处理它们可能的返回类型，并且不得不花更多的时间搜索文件系统元数据等内容，这可能是因为我是这门语言的新手。但是，使其正确并使其并行所需的时间较少，尽管我在这门语言方面经验较少。在我做的很多事情中，我都会做这样的权衡。</p><p>   Update:  Some good feedback from burntsushi about the unnecessary use of globwalk introducing a lot of extra dependencies.  This is a good point about the risks of making it too easy to use random crates off of github -- or, perhaps, about the dangers inherent in having a less-fully-fledged stdlib.  An updated version of the code that&#39;s faster to compile is:</p><p>更新：来自burntsushi的一些很好的反馈是关于不必要地使用globwalt引入了很多额外的依赖。这是一个很好的观点，说明了在GitHub上使用随机板条箱太容易的风险--或者，可能是关于拥有一个不那么成熟的stdlib的固有危险。代码的更新版编译起来更快，这是一个很好的观点：</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://da-data.blogspot.com/2020/10/no-c-still-isnt-cutting-it.html?m=1">https://da-data.blogspot.com/2020/10/no-c-still-isnt-cutting-it.html?m=1</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/isn/">#isn</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1030259.html"><img src="http://img2.diglog.com/img/2020/10/thumb_9777c4662921ff2c4e18742ec7d96b33.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030259.html">使用MESON对C、C++和其他语言进行货运式依赖管理</a></div><span class="my_story_list_date">2020-10-21 14:2</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029622.html"><img src="http://img2.diglog.com/img/2020/10/thumb_3884453f3945027ebd4444634fa4c369.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029622.html">不，C++仍然不支持</a></div><span class="my_story_list_date">2020-10-18 23:53</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029433.html"><img src="http://img2.diglog.com/img/2020/10/thumb_9288d7ad6e1e89befcae18c6478b039f.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029433.html">SWIFT与C++的互操作性</a></div><span class="my_story_list_date">2020-10-17 19:38</span></div><div class="col-sm"><div><a target="_blank" href="/story/1028278.html"><img src="http://img2.diglog.com/img/2020/10/thumb_112e8ad687703295c4a6e412456388da.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1028278.html">C++中按返回类型重载</a></div><span class="my_story_list_date">2020-10-12 21:43</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>