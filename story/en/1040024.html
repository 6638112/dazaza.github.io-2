<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>冒泡排序，摇滚排序和鸡尾酒摇床排序 Bubblesort, rocksort, and cocktail-shaker sort</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Bubblesort, rocksort, and cocktail-shaker sort<br/>冒泡排序，摇滚排序和鸡尾酒摇床排序 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-16 16:53:40</div><div class="page_narrow text-break page_content"><p>I’m currently participating in a book club for Donald Knuth’s  The Art ofComputer Programming. It’s run by Zartaj Majeed; you can find the detailson Meetup  here.</p><p>我目前正在参加Donald Knuth的《计算机编程艺术》的读书俱乐部。由Zartaj Majeed经营；您可以在此处找到有关Meetup的详细信息。</p><p> Yesterday we went over the first half of section 5.2.2, “Sorting by Exchanging.”(We’re reading in an extremely non-linear fashion.) This section starts withvariations on the bubble sort. I wrote some C++ code to demonstrate threeof the algorithms in this section; I figure I might as well share it.</p><p> 昨天，我们讨论了第5.2.2节“通过交换进行排序”的前半部分。（我们正在以非常非线性的方式阅读。）本节从气泡排序的变化开始。我编写了一些C ++代码来演示本节中的三种算法。我想我最好也分享一下。</p><p>   First of all, what’s the difference between “bubble sort” and“insertion sort” (which Knuth covers in section 5.2.1, “Sorting by Insertion”)? This StackOverflow answerreally helped me with a clear answer to that. In each step of insertion sort, you’re bubblingthe uppermost unsorted element through the  sorted section to its proper place (Knuth callsthis the “bridge-player” method). In each step of bubble sort, you’re sifting through the unsorted section to find the maximum, whose proper place is necessarily rightat the bottom of the sorted section.</p><p>   首先，“冒泡排序”和“插入排序”（Knuth在第5.2.1节“通过插入排序”中涉及）之间有什么区别？这个StackOverflow回答确实为我提供了明确的答案。在插入排序的每个步骤中，您都将最上面未排序的元素通过排序部分冒泡到正确的位置（Knuth将此称为“ bridge-player”方法）。在气泡排序的每个步骤中，您都在未排序部分中进行筛选以找到最大值，该最大值的正确位置必须在已排序部分的底部。</p><p> And in “selection sort,” you’re  scanning through the unsorted section to find themaximum — doing no exchanges until the very end of the step. Only one array elementmoves upward in any given pass. Whereas in bubble sort, you might bubble up a fewnon-maximum elements before finding the actual maximum.</p><p> 在“选择排序”中，您要遍历未排序的部分以找到最大数量-在此步骤结束之前不进行任何交换。在任何给定的传递中，只有一个数组元素向上移动。而在冒泡排序中，您可能会冒泡一些非最大元素，然后再找到实际的最大值。</p><p>   for (int i=0; i &lt; n; ++i) { for (int j=0; j &lt; n-i-1; ++j) { if (a[j+1] &lt; a[j]) swap(a[j], a[j+1]); }}</p><p>   for（int i = 0; i＆lt; n; ++ i）{for（int j = 0; j＆lt; ni-1; ++ j）{if（a [j + 1]＆lt; a [j] ）swap（a [j]，a [j + 1]）; }}</p><p> But Knuth presents bubblesort with a neat optimization. Think of the upward-moving elementsas air bubbles bubbling through water. As the algorithm proceeds, we accumulate airat the top of our water column. In each pass, the water level will drop by at least one…but maybe more! Knuth’s archetypal bubblesort (Algorithm B in section 5.2.2)tracks the true water level in a variable called  BOUND,and can terminate in fewer than  n passes — as soon as  BOUND hits zero, we’re done.</p><p> 但是Knuth提出的bubbleort具有巧妙的优化。将向上运动的元素视为气泡在水中冒泡。随着算法的进行，我们将空气积聚在水柱的顶部。每次通过时，水位至少会下降一个……但可能还会下降更多！ Knuth的原型气泡排序（第5.2.2节中的算法B）在称为BOUND的变量中跟踪真实水位，并且可以终止少于n次传递-BOUND达到零时，我们就完成了。</p><p>  Knuth volume 3, page 106, gives the above beautifulvisualization of bubblesort (complete with a little bubbly trace as each elementin the watery unsorted section moves closer to the surface). The horizontal linein each column represents the water level. The trick to maintaining it is to noticethat in each column, the water level is set precisely between the last two elementswe exchanged in the previous step.</p><p>  第106页的Knuth第3卷，给出了上面关于冒泡现象的漂亮可视化效果（当含水未分类部分中的每个元素移近表面时，都会有气泡状痕迹）。每列中的水平线代表水位。维持这一技巧的诀窍是要注意，在每一列中，水位都是在上一步交换的最后两个元素之间精确设置的。 </p><p> In Pass 4 of this example, we bubble up 512, swapping it with 426, 154, and 509.Then, since 512 was less than 612, we take up 612 as our new maximum without swapping;then 653, 677, and 703. (That is, we don’t swap any of these elements.) So the lastpair of elements we swapped in Pass 4 was 509 and 512. That’s why the water levelafter Pass 4 has dropped five places to land between 509 and 512. We just savedfour passes compared to the “naïve” nested-loop bubblesort code I presented above!</p><p>在本例的第4遍中，我们冒出512，将其交换为426、154和509，然后由于512小于612，因此我们将612作为新的最大值而不进行交换;然后是653、677和703。 （也就是说，我们不交换任何这些元素。）因此，我们在Pass 4中交换的最后一对元素是509和512。这就是Pass 4之后的水位下降了五个位置以降落在509和512之间的原因。我们只是与上面介绍的“幼稚”嵌套循环Bubblesort代码相比，savefourfour通过了！</p><p>  One can easily imagine a version of bubblesort with all the counters reversed,in which instead of raising up “airy” elements to the  top of the column,we sink “heavy” elements to the  bottom of the column. At the Meetup, MichaelZalewski referred to this variation as “rocksort.”</p><p>  可以很容易地想象出所有反向计数器都冒着气泡的版本，在这种情况下，我们将“重”元素沉没到了列的底部，而不是将“通风”元素抬高到了列的顶部。在聚会上，迈克尔·扎列夫斯基（MichaelZalewski）将此变化称为“摇滚排序”。</p><p> On pages 109–110, Knuth points out that the ordinary bubble sort has a naturaltendency to sink the “rocks” toward the bottom on its own. Each time we bubbleone light element upward, we’re moving it past arbitrarily many heavier elements,each of which sinks slightly downward. Notice that during Pass 4 in Figure 14,elements 061 and 087 have already reached the bottom of the column.If we were tracking a “rock level” in addition to our “water level,” we’d beable to skip comparing those two elements on every subsequent pass. Knuth writes:</p><p> 在第109-110页上，克努斯指出，普通的气泡类型具有自然的倾向，可以使“岩石”自行沉入底部。每次我们向上充气一个轻元素时，我们都会将其任意随机地移过许多较重的元素，每个元素都会稍微向下沉。请注意，在图14的通道4中，元素061和087已经到达列的底部。如果我们除了跟踪“水位”之外还跟踪“岩石级”，我们可以跳过对这两个元素的比较在随后的每个通行证上。努斯写道：</p><p>   Knuth volume 3, page 110, gives the above beautifulvisualization of the cocktail shaker sort. Notice that this time, alternate passesleave bubbly traces in opposite directions. The first pass bubbles air upwardand lowers the water level; the second pass bubbles rocks downward and raisesthe rock level. After six passes, the water level meets the rock level, whichmeans we’re done.</p><p>   Knuth第3卷，第110页，给出了鸡尾酒搅拌器分类的上述精美外观。请注意，这一次，交替的通行泡沿相反的方向起泡。第一道气泡使空气向上气泡并降低水位；第二次通过时，气泡向下倾斜，从而提高了岩石高度。经过六遍后，水位达到了岩石水位，这就是我们要做的。</p><p>   Another idea [for refining bubblesort] is to eliminate most of the exchanges;since most elements simply shift left one step during an exchange, we couldachieve the same effect by viewing the array differently, shifting theorigin of indexing!</p><p>   [精炼Bubblesort]的另一个想法是消除大多数交换；由于大多数元素在交换过程中仅向左移动一步，因此我们可以通过不同地查看数组，移动索引的原点来实现相同的效果！</p><p> What does he mean, “most elements simply shift left one step”? Well, thenumber of airy elements that move upward tends to be small — most of ourtime is spent bubbling upward the same few elements. Every element which isheavier than the current maximum ends up moving exactly one step downward(when that airy element bubbles past it). It’s true that  some elements willmove upward, and  some elements will stay in the same place (the wayFigure 14’s element 170 does, in Passes 4 through 7, before moving againin Pass 8). But a very significant majority of elements do move downwardone step in each pass.</p><p> 他是什么意思，“大多数元素只是向左移动一步”？好吧，向上移动的通风元件的数量往往很少-我们大部分时间都花在向上鼓泡相同的少数元件上。每个比当前最大值重的元素最终都会向下精确地向下移动一步（当该通风的元素冒泡经过它时）。确实有些元素会向上移动，而有些元素会留在同一位置（图14的元素170在第4遍到第7步中所做的操作，然后再次在第8遍中移动）。但是，绝大多数元素的确在每次通过时都向下移动了一步。</p><p> So, instead of describing an exchange as “element  a[i] goes to  a[i+1] and  a[i+1]goes to  a[i],” let’s imagine overlaying an array  b such that  b[0]is an alias for  a[1], and let’s say “element  a[i] goes to  b[i+2] and a[i+1] goes to  b[i+1].” Remember that  a[i] probably won’t  land at b[i+2] anyway, because  a[i] is the current maximum and it’ll likelybubble upward by multiple places at once. Then, in the next pass, we simplychange our indexing scheme so that we’re operating on the aliased array  binstead of array  a…</p><p> 因此，我们不打算将交换描述为“元素a [i]进入a [i + 1]，a [i + 1]进入a [i]”，而是想象覆盖数组b使得b [0]为a [1]的别名，比方说“元素a [i]进入b [i + 2]，a [i + 1]进入b [i + 1]。”请记住，a [i]无论如何都不会落在b [i + 2]上，因为a [i]是当前的最大值，并且可能会一次向上气泡多个位置。然后，在下一步中，我们只需更改索引方案，以便对数组a的别名数组binstead进行操作... </p><p> This scheme seems to cause the array to creep rightward in memory witheach pass. But we can fix that by using cocktail-shaker sort instead ofstraight bubblesort! In the odd-numbered passes, we’ll overlay  b such that b[0] is an alias for  a[1] and so “sinking” elements don’t have to move.In the even-numbered passes, we’ll overlay  c such that  c[1] is an aliasfor  b[0], and so “rising” elements don’t have to move. That gets our arrayright back to its starting position.</p><p>这种方案似乎会使数组在每次通过时在内存中向右爬行。但是我们可以通过使用鸡尾酒摇床排序而不是直接的冒泡排序来解决此问题！在奇数遍中，我们将覆盖b，使得b [0]是a [1]的别名，因此“下沉”元素不必移动。在偶数遍中，我们将覆盖c，使得c [1]是b [0]的别名，因此“上升”元素不必移动。这使我们的数组回到了初始位置。</p><p> This refinement increases the aptness of the name “cocktail-shaker sort,”because now we’re literally shifting the whole container up and downby small increments in a repetitive motion. But paradoxically, we’re shiftingthe container in order to impart  less motion to the elements inside; andthe result is not a perfectly mixed drink but rather a perfectly  unmixed one.</p><p> 这种改进提高了“鸡尾酒摇床排序”这个名称的适用性，因为现在我们实际上是通过重复的动作将整个容器上下移动一小段。但是，自相矛盾的是，我们正在移动容器，以使内部元素的运动减少；结果不是完全混合的饮料，而是完全没有混合的饮料。</p><p>  I decided to write up the algorithms for bubble sort, cocktail-shaker sort,and the “shifting cocktail-shaker sort” described above, to see with my own eyesthe effect of Knuth’s different refinements. (Also, I needed to convince myselfthat the shifting shaker sort was implementable!)</p><p>  我决定编写上述用于气泡排序，鸡尾酒摇床排序和“移动鸡尾酒摇床排序”的算法，以亲眼看到Knuth不同改进的效果。 （此外，我需要说服自己，这种振动筛可以实现！）</p><p>  It generates an array of 100 random ints, and then sorts it in five different ways.</p><p>  它生成一个包含100个随机整数的数组，然后以五种不同的方式对其进行排序。</p><p> Naïve: 4950c 2468s - Bubble: 4931c 2468s - Shake: 3477c 2468s - Shift: 3477c 1118s - Std: 808c 70sNaïve: 4950c 2391s - Bubble: 4814c 2391s - Shake: 3295c 2391s - Shift: 3295c 999s - Std: 820c 66sNaïve: 4950c 2203s - Bubble: 4833c 2203s - Shake: 3007c 2203s - Shift: 3007c 913s - Std: 746c 57sNaïve: 4950c 2652s - Bubble: 4761c 2652s - Shake: 3472c 2652s - Shift: 3472c 924s - Std: 810c 56s</p><p> 天真：4950c 2468s-气泡：4931c 2468s-摇动：3477c 2468s-移位：3477c 1118s-标准：808c 70s天真：4950c 2391s-泡沫：4814c 2391s-摇动：3295c 2391s-移位：3295c 999s-标准：820c 66s -气泡：4833c 2203s-抖动：3007c 2203s-移位：3007c 913s-标准：746c 57s天真：4950c 2652s-气泡：4761c 2652s-抖动：3472c 2652s-移位：3472c 924s-标准：810c 56s</p><p> Each line of output represents a different random input. 4950c means the algorithm did 4950 comparisons, and  2468s means it did 2468 swaps.</p><p> 输出的每一行代表一个不同的随机输入。 4950c表示算法进行了4950次比较，而2468s表示进行了2468次交换。</p><p> “Bubble” is Knuth’s bubble sort, tracking the water level. Notice that it does the same number of swaps as “Naïve,” but saves some comparisons because elements above the waterline needn’t be compared.</p><p> “气泡”是Knuth的气泡排序，可跟踪水位。请注意，它的交换次数与“朴素”次数相同，但是由于不需要比较水线上方的元素，因此可以节省一些比较。 </p><p>  “Shake” is Knuth’s cocktail-shaker sort, tracking both water and rock levels. Notice that it does the same number of swaps, but saves some more comparisons because elements below the seafloor needn’t be compared.</p><p>“摇动”是Knuth的鸡尾酒摇动器，可同时跟踪水位和岩石位。请注意，它进行的交换次数相同，但是由于不需要比较海底以下的元素，因此可以节省更多的比较。</p><p>  “Shift” is my interpretation of the shifting cocktail-shaker sort. Notice that it does the same number of comparisons as “Shake,” but this time it saves some swaps. My implementation involves “pulling out” the currently bubbling element into a local variable rather than keeping it in the array; I tally a “swap” only once when the pullout is created and once when it’s put back into its final position in the array.</p><p>  “转变”是我对不断变化的鸡尾酒摇床的解释。请注意，它执行与“摇动”相同的比较次数，但是这次它节省了一些交换。我的实现涉及将当前冒泡的元素“拉出”到局部变量中，而不是将其保留在数组中。创建抽出菜单时，我仅会计算一次“交换”，而一旦将其放回阵列中的最终位置，我便会计算一次。</p><p>  “Std” is the C++ standard library’s  std::sort, just for fun. I believe this is usually  introsort. Notice that it does vastly fewer comparisons  and vastly fewer swaps. However, be aware that the “swaps” number might be a bit of a lie;  std::sort is allowed to use pullouts similar to my shifting shaker sort, and it’s  not required to “report” those operations for tallying. (We could give  Wrapped some special member functions to tally those operations too, but I didn’t.) Interestingly, libc++ seems to use a different and more swap-heavy algorithm for types that are move-only.</p><p>  “ Std”是C ++标准库的std :: sort，只是为了好玩。我相信这通常是introsort。请注意，它所做的比较少得多，交换也少得多。但是，请注意，“掉期”号码可能是个谎言。允许std :: sort使用与我的振动筛排序类似的提取，并且不需要“报告”这些操作以进行计数。 （我们也可以为Wrapped提供一些特殊的成员函数来对这些操作进行计数，但我没有这样做。）有趣的是，libc ++似乎对仅移动类型使用了另一种更为繁重的交换算法。</p><p>  Finally, I thought it was interesting to note that all of “Naïve,” “Bubble,”and “Shake” do exactly the same number of swaps. This is because eachswap exchanges two adjacent out-of-order elements, and thus decreases thearray’s number of  inversionsby exactly 1. When the number of inversions reaches zero, the array is sorted.Therefore, every sorting algorithm that swaps  only out-of-order adjacent elementsmust perform exactly the same number of swaps. Also, every such algorithm is stable practically bydefinition.</p><p>  最后，我认为有趣的是，所有“天真”，“冒泡”和“摇动”都执行完全相同的交换次数。这是因为eachswap交换了两个相邻的乱序元素，因此将数组的反转数精确地减少了1。当反转数达到零时，将对数组进行排序。因此，每个仅交换乱序的排序算法相邻元素必须执行完全相同数量的交换。同样，每个这样的算法实际上都是稳定的。</p><p> To perform fewer total swaps, you must perform some swaps that decrease thenumber of inversions by more than 1 at a swoop. This means you must swap somenon-adjacent pairs of elements. The tradeoff is that this can easily make yoursorting algorithm non-stable.</p><p> 要执行更少的总交换，您必须执行一些交换，从而一举将倒置次数减少超过1。这意味着您必须交换一些不相邻的元素对。折衷方案是，这很容易使您的排序算法不稳定。</p><p>  By the way, Knuth is interested in these algorithms mainly for the interestingmathematical problems that arise during analysis of their running times —not because they’re in any way efficient algorithms! If you ever have tosort a million 32-bit integers, the bubble sort would be the wrong way to go.</p><p>  顺便说一下，Knuth对这些算法很感兴趣，主要是因为它们在运行时间分析过程中出现了有趣的数学问题，而不是因为它们无论如何都是有效的算法！如果必须对一百万个32位整数进行排序，那么冒泡排序将是错误的方法。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://quuxplusone.github.io/blog/2020/12/13/bubblesort-rocksort-shakersort/">https://quuxplusone.github.io/blog/2020/12/13/bubblesort-rocksort-shakersort/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/排序/">#排序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rocksort/">#rocksort</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/元素/">#元素</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>