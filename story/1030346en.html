<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>/*您不需要理解这一点*/</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">/*您不需要理解这一点*/</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-22 08:51:06</div><div class="page_narrow text-break page_content"><p>The title of this post,  you are not expected to understand this, is one of the most famous comments ever. It is in the v6 version of Unix, the mother operating system of Linux, Android,and iOS. Unix was developed by Dennis Ritchie and Ken Thompson at Bell Labs in the early 1970s. When I say &#34;comment&#34; I am using the word in the technical sense of an annotation to the source code for human readers that is ignored by the compiler.</p><p>这篇帖子的标题，你是不会理解的，这是有史以来最著名的评论之一。它位于Unix的V6版本中，Unix是Linux、Android和iOS的母版操作系统。UNIX是由贝尔实验室的丹尼斯·里奇和肯·汤普森于20世纪70年代初开发的。当我说注释时，我使用的是编译器忽略的源代码注释的技术意义上的这个词。</p><p>  The v6 version of Unix was especially famous because John Lions of University of New South Wales in Australia wrote an annotated version of the source code which was used by many computer science departments to teach operating system design. That is the orange book below.</p><p>Unix的V6版本特别出名，因为澳大利亚新南威尔士大学的John Lions编写了源代码的注释版本，许多计算机科学系都使用该版本来教授操作系统设计。那是下面那本橙色的书。</p><p> But AT&amp;T decided to make money on Unix and insisted that Lyons book could only be used in schools that were paid-up Unix licensees (since it contained a copy of the source code). That had approximately zero effect, and everyone simply photocopied it like samizdat publications in the Soviet Union. Eventually, the book was published through normal channels and you can still buy it on  Amazon. Interestingly, the cover, above on the right, shows students illicitly photocopying the original version. My copy from postgrad days was a photocopy. I only discovered the cover used to be orange when writing this post.</p><p>但AT&amp；T决定在Unix上赚钱，并坚称莱昂斯的书只能在付费Unix许可证的学校使用(因为它包含了源代码的副本)。这几乎没有效果，每个人都只是简单地影印，就像苏联的Samizdat出版物一样。最终，这本书是通过正常渠道出版的，你仍然可以在亚马逊上买到它。有趣的是，在右上方的封面上，学生们非法复印了原版。我研究生时代的复印件是复印件。我在写这篇文章的时候才发现封面原来是橙色的。</p><p> One part of the code is concerned with what is called a context switch. The same thing is going on in your laptop, and even your phone, but since you are the only person using it then it is less obvious. Back in the 1970s, computers were too big and expensive to give everyone their own, and so they were shared, an approach known as time-sharing. Each user would have a keyboard and screen and be connected to the computer over a wire (there were ways to do dialup too). The trick was that it seemed to each user that they had the whole machine. The operating system would switch from one user to another as they hit keys, or the clock interrupted, and so on.</p><p>代码的一部分涉及所谓的上下文切换。同样的事情也发生在你的笔记本电脑上，甚至你的手机上，但既然你是唯一使用它的人，那么它就不那么明显了。回到20世纪70年代，计算机太大太贵，不能给每个人都有自己的，所以它们是共享的，这种方式被称为分时。每个用户都有键盘和屏幕，并通过一条线连接到计算机(也有拨号的方法)。诀窍在于，在每个用户看来，他们似乎拥有整台机器。当用户击键或时钟中断时，操作系统将从一个用户切换到另一个用户，等等。</p><p>  I still remember my first operating system course when Roger Needham, who was the lecturer, explained the notion of a process. It was a wonderfully simple and elegant idea once you understood it. I&#39;ll try and explain it. A computer, like the PDP11 that the early Unix ran on, had a number of general-purpose hardware registers (used for calculation, word processing, and so on), and a few other more specialized ones. Each user (actually each process, but let&#39;s just assume each user is only doing one thing at a time) had a little bit of memory allocated that was large enough to hold a copy of these registers. When one process was done running (for example, it was waiting for its user to type a key, which takes place approximately every century in computer time) then the operating system would perform the context switch. All the general and special registers would be saved in the special bit of memory for that process.</p><p>我还记得我的第一堂操作系统课，当时讲师罗杰·李约瑟(Roger Needham)解释了进程的概念。一旦你理解了，这是一个极其简单而优雅的想法。我会试着解释一下。一台计算机，如早期Unix运行的PDP11，有许多通用硬件寄存器(用于计算、字处理等)，以及其他一些更专用的寄存器。每个用户(实际上是每个进程，但让我们假设每个用户一次只做一件事)分配了一点足够大的内存来保存这些寄存器的副本。当一个进程完成运行时(例如，它正在等待其用户键入密钥，这大约每一个世纪在计算机时间内发生一次)，那么操作系统将执行上下文切换。所有通用寄存器和特殊寄存器都将保存在该进程的特殊存储器位中。</p><p> Then a new process would be selected to run next. There always is one, since if there is no real work to be done, there is a sort of last-ditch process called the idle process, which is always ready to run (and does nothing when it does, just wasting time until something more useful needs to be run). To run the new process, the general and special purpose registers were loaded from the saved values in the special piece of memory for that process, which were saved the last time it ran. When the code starts to execute, it looks to the user sitting at the terminal as if nothing has happened in between keystrokes, but actually, the system got on with all the other things that other users wanted to achieve.</p><p>然后，将选择下一步运行的新进程。总是有一个，因为如果没有真正的工作要做，就会有一种称为空闲进程的最后一搏进程，它总是准备好运行(当它运行时什么也不做，只是在需要运行更有用的东西之前浪费时间)。为了运行新进程，从该进程的专用内存中保存的值加载通用寄存器和专用寄存器，这些值是上次运行时保存的。当代码开始执行时，在坐在终端的用户看来，就好像在两次击键之间什么都没有发生一样，但实际上，系统继续执行其他用户想要实现的所有其他事情。</p><p>  The famous comment occurs at the end of the little bit of code in the operating system that gives control to the new process after it has loaded some of the registers. Having written my share of code like this, I&#39;ll point out that it is pretty tricky. After all, having loaded the registers, the operating system is in a sort of halfway-house, with some registers containing operating system values, and some containing the new process values. So everything has to be done very carefully in the right order. Here&#39;s the code from the 1975 Unix v6 source:</p><p>这条著名的注释出现在操作系统中的一小段代码的末尾，该代码在新进程加载到一些寄存器后将控制权交给它。在编写了我的部分代码之后，我将指出这是相当棘手的。毕竟，加载了寄存器之后，操作系统就处于某种折中状态，一些寄存器包含操作系统值，另一些包含新的进程值。所以每件事都必须非常仔细地按照正确的顺序做。以下是1975年Unix V6源代码中的代码：</p><p> /*	 * Switch to stack of the new process and set up	 * his segmentation registers.	 */	retu(rp-&gt;p_addr);	sureg();	/*	 * If the new process paused because it was	 * swapped out, set the stack level to the last call	 * to savu(u_ssav). This means that the return	 * which is executed immediately after the call to aretu	 * actually returns from the last routine which did	 * the savu.	 *	  * You are not expected to understand this.	 */	if(rp-&gt;p_flag&amp;SSWAP) {		rp-&gt;p_flag =&amp; ~SSWAP;		aretu(u.u_ssav);	}	/*	 * The value returned here has many subtle implications.	 * See the newproc comments.	 */	return(1);</p><p>/**切换到新进程的堆栈并设置*HIS分段寄存器。*/retu(rp-&gt；p_addr)；sureg()；/**如果新进程因为*换出而暂停，请将堆栈级别设置为对savu(U_Ssav)的最后一次调用*。这意味着，在调用aretu*之后立即执行的return*实际上是从执行*savu的最后一个例程返回的。**您不需要理解这一点。*/if(rp-&gt；p_flag&amp；SSWAP){rp-&gt；p_flag=&amp；~SSWAP；aretu(U.U_ssav)；}/**此处返回的值有许多微妙的含义。*见newproc评论。*/return(1)；</p><p>   This code is operating system code, unlike something that would happen in a normal program. The &#34;retu&#34; statement overwrites the return address (and some other registers) on the stack with the value from the little saved block for that process. The return statement at the end will pull that return address off the stack and go there. In a normal program, the return always goes back to where a procedure was called from, since a normal user doesn&#39;t get to play around adjusting the return address. But there is a complication, that if the process was swapped out (had all its memory written to the disk) then it needs to return to a different place because it shouldn&#39;t return back to the swap code that was running when the old process finally gave up control. Instead, it needs to return to a special value the swap code saved before it did its work. The return statemnt at the end will return to the equivalent place, whether the process was swapped out or not, reload the rest of the registers, and the user program will carry on as if nothing had happened.</p><p>这段代码是操作系统代码，不同于在正常程序中会发生的事情。&#34；retu&#34；语句用该进程的小块中保存的值覆盖堆栈上的返回地址(和其他一些寄存器)。末尾的RETURN语句将把返回地址从堆栈中取出并转到那里。在正常的程序中，返回总是返回到调用过程的地方，因为普通用户无法调整返回地址。但是有一个复杂的问题，如果进程被换出(将其所有内存写入磁盘)，那么它需要返回到不同的位置，因为它不应该返回到旧进程最终放弃控制时正在运行的交换代码。相反，它需要将交换代码在执行其工作之前保存的特定值返回。不管进程是否被换出，最后的返回状态都将返回到等价的位置，重新加载其余的寄存器，用户程序将继续运行，就好像什么都没有发生一样。</p><p>  Interestingly, years later, Ken Thompson admitted that the reason that it was so hard to wrap your head around what is going on is that it is wrong. As Thompson said:</p><p>有趣的是，几年后，肯·汤普森承认，很难理解正在发生的事情的原因是它是错误的。正如汤普森所说：</p><p> The real problem is that we didn&#39;t understand what was going on either. The savu/retu mechanism for doing process exchange was fundamentally broken because it depended on switching to a previous stack frame and executing function return code in a different procedure from the one that saved the earlier state. This worked on the PDP-11 because its compiler always used the same context-save mechanism; with the Interdata compiler, the procedure return code differed depending on which registers were saved.</p><p>真正的问题是，我们也不知道发生了什么。用于进行进程交换的SAVU/RETU机制从根本上被打破，因为它依赖于切换到前一个堆栈帧，并在与保存较早状态的过程不同的过程中执行函数返回代码。这在PDP-11上有效，因为它的编译器总是使用相同的上下文保存机制；对于InterData编译器，过程返回代码根据保存的寄存器而不同。</p><p> What this snippet of code above got wrong was the assumption that you could just put return at the end of the snippet, and it would execute exactly the same code as the procedure that had actually been called. On the PDP that was true, but on other systems it was not. So they fixed it to work and removed the famous comment.</p><p>上面这段代码的错误之处在于，假设您只需将return放在代码段的末尾，它就会执行与实际调用的过程完全相同的代码。在PDP上这是真的，但在其他系统上不是这样。所以他们修复了它，并删除了这条著名的评论。</p><p>  But a modern operating system is simply too big to use for a university course. Linux is 15+M lines of code. As Ken Thompson is quoted on the cover of Lions&#39; book:</p><p>但是，现代操作系统实在太大了，不适合在大学课程中使用。Linux有15+M行代码。正如肯·汤普森(Ken Thompson)在“狮子队”(Lions&#39；)一书的封面上所说：</p><p> After 20 years this is still the best exposition of the workings of a real operating system</p><p>20年后，这仍然是对真实操作系统工作原理的最好阐述。</p><p> But at only 9,000 lines, Unix v6 was tractable, people continued to study it (and maybe still do), and the famous comment lived on. The fact that every smartphone operating system owes its heritage to this system makes it remain historically important today. And every supercomputer, and most cloud servers. It has to be the most influential 9,000 lines of code of all time.</p><p>但是，Unix V6只有9000行代码，很容易理解，人们继续研究它(也许现在还在这样做)，这条著名的评论流传了下来。事实上，每个智能手机操作系统都要归功于这个系统，这使得它在今天仍然具有历史重要性。以及每台超级计算机和大多数云服务器。它必须是有史以来最有影响力的9000行代码。</p><p> Reading real programs is a part of learning computer science that should be emphasized more. As an undergraduate, we mostly programmed in BCPL, a local Cambridge language that is the fore-runner of C and C++. We had access to the full source code of the compiler and reading it was as valuable as the more theoretical aspects we learned in our compiler-writing course. Today, with open source, it is easy to read the source code for many systems actually in use (Linux, the Apache web server, Hadoop, TensorFlow, and thousands more) but these are hundreds of thousands, if not millions, of lines of code. As I said above, Linux is somewhere between 15M and 20M lines of code, depending on just what you include.</p><p>阅读真实的程序是学习计算机科学的一部分，应该更加强调。作为一名本科生，我们主要使用BCPL编程，这是一种剑桥本地语言，是C和C++的先行者。我们可以访问编译器的全部源代码，阅读它与我们在编译器编写课程中学到的更多理论方面一样有价值。今天，有了开放源码，很容易阅读许多实际使用的系统(Linux、Apache web服务器、Hadoop、TensorFlow等等)的源代码，但这些代码即使不是数百万行，也有数十万行。正如我在上面说过的，Linux的代码行在1500万到2000万行之间，这取决于您包含的内容。</p><p> Just as no English teacher is going to teach only writing, without also expecting students to read good writing (although who knows what goes on in English departments today), no programming teacher should expect to teach only writing, without expecting students to read good programming. I suppose you could say that due to Lions, Unix v6 became the  To Kill a Mockingbird of computer science.</p><p>就像没有英语教师会只教写作，而不期望学生阅读好的写作一样(尽管谁知道今天英语部门发生了什么)，任何编程教师都不应该期望只教写作，而不期望学生阅读好的编程。我想你可以说，由于有了狮子队，Unix V6成为了计算机科学界的“杀死一只知更鸟”(To Kill A Mockingbird)。</p><p> If you didn&#39;t understand this post...well, I did warn you. It&#39;s the title of the post.</p><p>如果你不理解这篇帖子…那么，我的确警告过你。这是这篇文章的标题。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://community.cadence.com/cadence_blogs_8/b/breakfast-bytes/posts/memorial-day">https://community.cadence.com/cadence_blogs_8/b/breakfast-bytes/posts/memorial-day</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/需要/">#需要</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/expected/">#expected</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/进程/">#进程</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>