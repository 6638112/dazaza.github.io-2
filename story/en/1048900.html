<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ComputeSharp，在GPU上运行C＃ ComputeSharp, Run C# on the GPU</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">ComputeSharp, Run C# on the GPU<br/>ComputeSharp，在GPU上运行C＃ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-24 21:36:43</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/384ab6337c402ad8cd5703112cd6d519.png"><img src="http://img2.diglog.com/img/2021/2/384ab6337c402ad8cd5703112cd6d519.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>ComputeSharp is a .NET Standard 2.1 library to run C# code in parallel on the GPU through DX12 and dynamically generated HLSL compute shaders. The available APIs let you allocate GPU buffers and write compute shaders as simple lambda expressions or local methods, with all the captured variables being handled automatically and passed to the running shader.</p><p>ComputeSharp是一个.NET Standard 2.1库，可通过DX12和动态生成的HLSL计算着色器在GPU上并行运行C＃代码。可用的API使您可以分配GPU缓冲区并将计算着色器编写为简单的lambda表达式或本地方法，所有捕获的变量都将自动处理并传递给正在运行的着色器。</p><p>        ComputeSharp exposes a  Gpu class that acts as entry point for all public APIs. It exposes the  Gpu.Default property that lets you access the main GPU device on the current machine, which can be used to allocate buffers and perform operations.</p><p>        ComputeSharp公开了一个Gpu类，该类充当所有公共API的入口点。它公开了Gpu.Default属性，该属性使您可以访问当前计算机上的主GPU设备，该属性可用于分配缓冲区和执行操作。</p><p> The following sample shows how to allocate a writeable buffer, populate it with a compute shader, and read it back.</p><p> 下面的示例演示如何分配可写缓冲区，使用计算着色器填充该缓冲区以及将其读回。</p><p> // Define a simple shader public  readonly  struct  MyShader :  IComputeShader{  public  readonly  ReadWriteBuffer&lt; float&gt;  buffer;  public  MyShader( ReadWriteBuffer&lt; float&gt;  buffer) {  this. buffer  =  buffer; }  public  void  Execute( ThreadIds  ids) {  buffer[ ids. X]  =  ids. X; }}  // Allocate a writeable buffer on the GPU, with the contents of the array using  ReadWriteBuffer&lt; float&gt;  buffer  =  Gpu. Default. AllocateReadWriteBuffer&lt; float&gt;(1000);  // Run the shader Gpu. Default. For( 1000,  new  MyShader( buffer));  // Get the data back float[]  array  =  buffer. GetData();</p><p> //定义一个简单的着色器public readonly struct MyShader：IComputeShader {public readonly ReadWriteBuffer＆lt;浮动＆gt;缓冲; public MyShader（ReadWriteBuffer＆lt; float＆gt;缓冲区）{this。缓冲=缓冲; } public void Execute（ThreadIds ids）{buffer [ids。 X] = ID。 X; }} //在GPU上分配可写缓冲区，并使用ReadWriteBuffer＆lt;浮动＆gt;缓冲区= Gpu。默认。 AllocateReadWriteBuffer＆lt;浮动＆gt;（1000）; //运行着色器Gpu。默认。 For（1000，新的MyShader（缓冲区））; //将数据取回float [] array = buffer。 GetData（）;</p><p>  If the shader in C# is capturing some local variable, those will be automatically copied over to the GPU, so that the HLSL shader will be able to access them just like you&#39;d expect. Additionally,  ComputeSharp can also resolve static fields being used in a shader. The captured variables need to be convertible to valid HLSL types: either scalar types ( int,  uint,  float, etc.) or known HLSL structs (eg.  Vector3). Here is a list of the variable types currently supported by the library:</p><p>  如果C＃中的着色器正在捕获某些局部变量，则这些局部变量将被自动复制到GPU，这样HLSL着色器将能够像您期望的那样访问它们。此外，ComputeSharp还可以解析着色器中使用的静态字段。捕获的变量需要转换为有效的HLSL类型：标量类型（int，uint，float等）或已知的HLSL结构（例如Vector3）。这是库当前支持的变量类型的列表：</p><p>   ✅ HLSL types:  Bool,  Bool2,  Bool3,  Bool4,  Float2,  Float3,  Float4,  Int2,  Int3,  Int4,  UInt2,  Uint3, etc.</p><p>   ✅HLSL类型：Bool，Bool2，Bool3，Bool4，Float2，Float3，Float4，Int2，Int3，Int4，UInt2，Uint3等</p><p>   ✅  Func&lt;T&gt;s or delegates with a valid HLSL signature, with the target method being  static</p><p>   带有有效HLSL签名的Func＆T或委托，目标方法为静态 </p><p>    There are a number of extension APIs for the  GraphicsDevice class that can be used to allocate GPU buffers of three types:  ConstantBuffer&lt;T&gt;,  ReadOnlyBuffer&lt;T&gt; and  ReadWriteBuffer&lt;T&gt;. The first is packed to 16 bytes and provides the fastest possible access for buffer elements, but it has a limited maximum size (around 64KB) and requires additional overhead when copying data to and from it if the size of each element is not a multiple of 16. The other buffer types are tightly packed and work great for all kinds of operations, and can be thought of the HLSL equivalent of  T[] arrays in C#. If you&#39;re in doubt about which buffer type to use, just use either  ReadOnlyBuffer&lt;T&gt; or  ReadWriteBuffer&lt;T&gt;, depending on whether or not you also need write access to that buffer on the GPU side.</p><p>有许多用于GraphicsDevice类的扩展API，可用于分配三种类型的GPU缓冲区：ConstantBuffer＆lt; T＆gt; ReadOnlyBuffer＆lt; T＆gt;。和ReadWriteBuffer＆lt; T＆gt;。前者压缩为16个字节，并提供对缓冲区元素的尽可能最快的访问，但是它的最大大小有限（约64KB），并且如果每个元素的大小都不是其倍数，则在往返之间复制数据时需要额外的开销。 16.其他缓冲区类型紧密包装，适用于所有类型的操作，可以认为C＃中T []数组的HLSL等效项。如果您不确定要使用哪种缓冲区类型，请使用ReadOnlyBuffer＆lt; T＆gt;。或ReadWriteBuffer＆lt; T＆gt ;，这取决于您是否还需要对GPU端的该缓冲区进行写访问。</p><p> NOTE: although the APIs to allocate buffers are simply generic methods with a  T : unmanaged constrain, they should only be used with C# types that are fully mapped to HLSL types. That means either  int,  uint,  float,  double, .NET vector types or HLSL types. The  bool type should not be used in buffers due to C#/HLSL differences: use the  Bool type instead.</p><p> 注意：尽管分配缓冲区的API只是带有T：非托管约束的通用方法，但它们仅应与完全映射到HLSL类型的C＃类型一起使用。这意味着int，uint，float，double，.NET矢量类型或HLSL类型。由于C＃/ HLSL的差异，不应在缓冲区中使用bool类型：请改用Bool类型。</p><p>  ComputeSharp lets you dispatch compute shaders over thread groups from 1 to 3 dimensions, includes supports for constant and readonly buffers, and more. Additionally, most of the  HLSL intrinsic functions are available through the  Hlsl class. Here is a more advanced sample showcasing all these features.</p><p>  ComputeSharp使您可以在1到3维的线程组上分派计算着色器，包括对常量和只读缓冲区的支持等等。此外，大多数HLSL内在函数可通过Hlsl类获得。这是展示所有这些功能的更高级的示例。</p><p> // Define a class with some utility static functions public  static  class  Activations{  public  static  float  Sigmoid( float  x)  =&gt;  1  / ( 1  +  Hlsl. Exp( - x));}  // Define the shader public  readonly  struct  ActivationShader :  IComputeShader{  private  readonly  int  width;  public  readonly  ReadOnlyBuffer&lt; float&gt;  x;  public  readonly  ReadWriteBuffer&lt; float&gt;  y;  public  ActivationShader(  int  width,  ReadOnlyBuffer&lt; float&gt;  x,  ReadWriteBuffer&lt; float&gt;  y) {  this. width  =  width;  this. x  =  x;  this. y  =  y; }  public  void  Execute( ThreadIds  ids) {  int  offset  =  ids. X  +  ids. Y  *  width;  float  pow  =  Hlsl. Pow( x[ offset],  2);  y[ offset]  =  Activations. Sigmoid( pow); }} int  height  =  10,  width  =  10; float[]  x  =  new  float[ height  *  width];   // Array to sum to y float[]  y  =  new  float[ height  *  width];   // Result array (assume both had some values) using  ReadOnlyBuffer&lt; float&gt;  xBuffer  =  Gpu. Default. AllocateReadOnlyBuffer( x);  using  ReadWriteBuffer&lt; float&gt;  yBuffer  =  Gpu. Default. AllocateReadWriteBuffer( y);  // Run the shader Gpu. Default. For( width,  height,  new  ActivationShader( width,  xBuffer,  yBuffer));  // Get the data back and write it to the y array yBuffer. GetData( y);</p><p> //使用一些实用程序静态函数定义一个类public static class Activations {public static float Sigmoid（float x）=＆gt; 1 /（1 + Hlsl。Exp（-x））;} //定义着色器公共只读结构ActivationShader：IComputeShader {private readonly int width;公共只读ReadOnlyBuffer＆lt;浮动＆gt; X;公共只读ReadWriteBuffer＆lt;浮动＆gt; y; public ActivationShader（int width，ReadOnlyBuffer＆lt; float＆gt; x，ReadWriteBuffer＆lt; float＆gt; y）{this。宽度=宽度;这。 x = x;这。 y = y; } public void Execute（ThreadIds ids）{int offset = ids。 X + ID。 Y *宽度；浮标= Hlsl。 Pow（x [offset]，2）; y [offset] =激活。乙状结肠（战俘）; }} int height = 10，width = 10; float [] x =新的float [高*宽]； //求和为y的数组float [] y = new float [height * width]; //使用ReadOnlyBuffer＆lt;的结果数组（假设两者都有一些值）；浮动＆gt; xBuffer = Gpu。默认。 AllocateReadOnlyBuffer（x）;使用ReadWriteBuffer＆lt;浮动＆gt; yBuffer = Gpu。默认。 AllocateReadWriteBuffer（y）; //运行着色器Gpu。默认。 For（width，height，new ActivationShader（width，xBuffer，yBuffer））; //取回数据并将其写入y数组yBuffer。 GetData（y）;</p><p>  The  ComputeSharp library requires .NET Standard 2.1 support, and it is available for applications targeting:</p><p>  ComputeSharp库需要.NET Standard 2.1支持，并且可用于面向以下应用程序：</p><p>  Additionally, you need an IDE with .NET Core 3.1 and C# 8.0 support to compile the library and samples on your PC.</p><p>  此外，您需要具有.NET Core 3.1和C＃8.0支持的IDE才能在PC上编译库和示例。</p><p>  The  ComputeSharp library is based on some of the code from the  DX12GameEngine repository by  Amin Delavar. Additionally,  ComputeSharp uses NuGet packages from the following repositories (excluding those from Microsoft):</p><p>  ComputeSharp库基于Amin Delavar的DX12GameEngine存储库中的某些代码。此外，ComputeSharp使用以下存储库中的NuGet软件包（不包括来自Microsoft的软件包）： </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/Sergio0694/ComputeSharp/tree/dev">https://github.com/Sergio0694/ComputeSharp/tree/dev</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c#/">#c#</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gpu/">#gpu</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/run/">#run</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/缓冲区/">#缓冲区</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>