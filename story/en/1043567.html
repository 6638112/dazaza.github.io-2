<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>尾部呼叫优化如何工作 How Tail Call Optimization Works</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How Tail Call Optimization Works<br/>尾部呼叫优化如何工作 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-09 07:40:06</div><div class="page_narrow text-break page_content"><p>Most undergraduate computer sciences courses teach students about  tail calloptimization (TCO), and even if youdon&#39;t have a formal computer science background the concept is talked aboutenough that you might be familiar with it anyway, especially if you&#39;ve ever doneany functional programming. However, I think the way TCO is normally taught isvery confusing, because it&#39;s normally taught in the context of recursion. It&#39;staught this way because without TCO many recursive functions can blow up thestack causing a stack overflow. Therefore by teaching people about TCO in thecontext of recursion, you can teach them why optimizing compilers (orinterpreters) can run tail recursive code efficiently and without causing astack overflow.</p><p>大多数本科计算机科学课程都会教给学生有关尾部呼叫优化（TCO）的知识，即使您没有正式的计算机科学背景，也要谈论这个概念，足以使您无论如何都要熟悉它，尤其是如果您曾经完成任何功能编程。但是，我认为通常讲授TCO的方式非常令人困惑，因为通常在递归的上下文中讲授TCO。之所以如此，是因为没有TCO，许多递归函数可能会使堆栈崩溃，从而导致堆栈溢出。因此，通过在递归的背景下向人们介绍TCO，您可以教会他们为什么优化编译器（或解释器）可以有效地运行尾递归代码，而不会引起堆栈溢出。</p><p> However, the recursion case for TCO is actually not the norm: in fact, if you&#39;rewriting code in C, C++, or any most other languages with an optimizing compileryou&#39;re almost certainly having TCO applied all over your programs even if theydon&#39;t use any recursion whatsoever. Understanding the non-recursive case of TCOis actually a lot simpler, and if you understand the non-recursive case yourealize that there&#39;s actually nothing special whatsoever about how TCO isapplied to recursive functions.</p><p> 但是，TCO的递归情况实际上不是常态：实际上，如果您使用C，C ++或任何其他大多数语言使用优化的编译器重写代码，则几乎可以肯定的是，TCO已遍及整个程序即使他们不使用任何递归。了解TCO的非递归情况实际上要简单得多，而且如果您了解非递归的情况，您会意识到，实际上没有什么特别的方法可以将TCO应用于递归函数。</p><p>  First I&#39;m going to give a refresher about how function calls work on x86. Notethat basically every ISA has this same model, including ARM, so nothing I sayhere is x86 specific except for the registers and x86 mnemonics I&#39;ll use.</p><p>  首先，我将重新介绍函数调用在x86上的工作方式。请注意，基本上每个ISA都具有相同的模型，包括ARM，因此我要说的是x86专用的，除了寄存器和我将使用的x86助记符。</p><p> Your computer has a bunch of registers, and one of them is  program counter(PC), which is also called the instruction pointer in x86. Every time the CPU executes an instruction itautomatically increments the PC so that it points to the next instruction. Forexample, suppose we execute a  nop instruction in x86, which is a no-opinstruction that&#39;s encoded using a single byte. After executing the  nopinstruction the PC will be advanced by 1, because that&#39;s the size of  nop andadvancing it by 1 causes it to point to the next instruction. There are somespecial instructions that modify the PC in a different way:  jmp (i.e. &#34;jump&#34;), call, and  ret (i.e. &#34;return&#34;). Typically  jmp and  call are called with animmediate operand which is the offset in number of bytes to adjust the PC by,and  ret has no arguments.</p><p> 您的计算机上有一堆寄存器，其中一个是程序计数器（PC），在x86中也称为指令指针。每次CPU执行一条指令时，它都会自动递增PC，使其指向下一条指令。例如，假设我们在x86中执行一个nop指令，这是一个使用单个字节编码的非操作指令。执行nopin指令后，PC将前进1，因为那是nop的大小并将其前进1会导致它指向下一条指令。有一些特殊的指令以不同的方式修改PC：jmp（即＆＃34; jump＆＃34;），调用和ret（即＆＃34; return＆＃34;）。通常，使用立即操作数调用jmp和call，该操作数是用于调整PC的字节数偏移量，而ret没有参数。</p><p> We&#39;ll start with  jmp, because that&#39;s the simpler of these instructions. Aninstruction like  jmp $15 means &#34;set the PC to be 15 more than it&#39;s currentvalue&#34;, in other words it jumps forward 15 bytes worth of instructions (I&#39;musing AT&amp;T syntax here, which is why the 15 has a  $ in front---this denotes itas an immediate value, rather than a memory address). You can also jumpbackwards if the operand is a negative value. Normally this instruction is usedto implement basic flow control constructs like  if,  else,  for, etc.</p><p> 我们将从jmp开始，因为这是这些说明中的更简单的方法。像jmp $ 15这样的指令意味着将PC设置为比当前值高15，换言之，它将PC向前跳转15个字节的指令值（此处是逗AT＆amp; T语法，这就是为什么15的前面带有$的原因-这表示它是立即数，而不是内存地址。如果操作数为负值，也可以向后跳转。通常，此指令用于实现基本的流控制结构，例如if，else，for等。</p><p> The cousin of  jmp is  call, and it works exactly the same was as  jmp exceptit also has the side effect of pushing the PC onto the stack. More precisely, onx86 the PC is adjusted  before an instruction executes, so when  call pushesthe PC onto the stack it&#39;s actually pushing the address of the instruction after the  call instruction. The PC is pushed onto the stack so the calledfunction can return back to the right spot. To return from a function, afunction executes  ret which pops the top value on the stack and then jumpsback to that location. Both  call and  ret are simply convenience instructionsand act as if executing a  push +  jmp or  pop +  jmp.</p><p> jmp的表弟是call，它的工作原理与jmp完全相同，除了它还有将PC推入堆栈的副作用。更精确地说，在指令执行之前先对PC进行onx86调整，因此，当调用将PC压入堆栈时，实际上是在调用指令之后压入指令的地址。将PC推入堆栈，以便调用的函数可以返回到正确的位置。要从函数返回，函数将执行ret，后者将栈顶值弹出，然后跳回该位置。 call和ret都是简单的便捷说明，就像执行push + jmp或pop + jmp一样。</p><p>   void foo(int x) { int y = x * 2; printf(&#34;x = %d, y = %d\n&#34;, x, y);}</p><p>   void foo（int x）{int y = x * 2; printf（＆＃34; x =％d，y =％d \ n＆＃34 ;, x，y）;} </p><p> If you compile this code with  gcc -O1 it will generate assembly for thisfunction the obvious way. Here&#39;s what it looks like:</p><p>如果使用gcc -O1编译此代码，它将以明显的方式为此功能生成程序集。外观如下：</p><p> (gdb) disas fooDump of assembler code for function foo: 0x0000000000000000 &lt;+0&gt;:	sub $0x8,%rsp 0x0000000000000004 &lt;+4&gt;:	mov %edi,%esi 0x0000000000000006 &lt;+6&gt;:	lea (%rdi,%rdi,1),%edx 0x0000000000000009 &lt;+9&gt;:	mov $0x0,%edi 0x000000000000000e &lt;+14&gt;:	mov $0x0,%eax 0x0000000000000013 &lt;+19&gt;:	call 0x18 &lt;foo+24&gt; 0x0000000000000018 &lt;+24&gt;:	add $0x8,%rsp 0x000000000000001c &lt;+28&gt;:	ret</p><p> （gdb）disas foo函数foo的汇编代码的转储：0x0000000000000000＆lt; + 0＆gt ;: sub $ 0x8，％rsp 0x0000000000000004＆lt; + 4＆gt ;: mov％edi，％esi 0x0000000000000006＆lt; + 6＆gt ;: lea（％rdi， ％rdi，1），％edx 0x0000000000000009＆lt; + 9＆gt ;: mov $ 0x0，％edi 0x000000000000000e＆lt; + 14＆gt ;: mov $ 0x0，％eax 0x0000000000000013＆lt; + 19＆gt ;:呼叫0x18＆lt; foo + 24＆gt; 0x0000000000000018＆lt; + 24＆gt ;:添加$ 0x8，％rsp 0x000000000000001c＆lt; + 28＆gt ;: ret</p><p> I&#39;m not going to explain every line of this but I&#39;ll explain the important bits.The first instruction  sub $0x8,%rsp reserves 8 bytes of space on the stack forthe variable  y from our C code. The penultimate instruction is  add $0x8,%rspwhich adjusts the stack pointer back to its original value, and the lastinstruction is  ret which returns to the caller in the way described earlier(i.e. by popping the return address from the stack and jumping to it). Ingeneral, before calling  ret a function always needs to undo any adjustments itmade to the stack pointer ( %rsp) so that  ret will pop the right value beforereturning. There&#39;s also a funny looking  call instruction in this example; thisis actually a bogus operand to  call because the compiler just sees the forwarddeclaration of  printf() and doesn&#39;t know where it actually is yet. In thefinal linking step the operand to the  call instruction will be updated so thatit calls into libc.</p><p> 我不会解释其中的每一行，而是会解释重要的位。第一个指令sub $ 0x8，％rsp在栈中为我们C代码中的变量y保留了8个字节的空间。倒数第二条指令是添加$ 0x8，％rsp，它将堆栈指针调整回其原始值，而last指令是ret，它以前面描述的方式返回调用方（即，从堆栈中弹出返回地址并跳转到它） 。通常，在调用ret之前，函数始终需要撤消对堆栈指针（％rsp）所做的任何调整，以便ret在返回之前弹出正确的值。在此示例中，还有一个有趣的调用指令；这实际上是一个虚假的操作数，因为编译器仅看到printf（）的前向声明，并且不知道它实际在哪里。在最后的链接步骤中，将对调用指令的操作数进行更新，以使其调用libc。</p><p>  (gdb) disas fooDump of assembler code for function foo: 0x0000000000000000 &lt;+0&gt;:	mov %edi,%esi 0x0000000000000002 &lt;+2&gt;:	lea (%rdi,%rdi,1),%edx 0x0000000000000005 &lt;+5&gt;:	xor %eax,%eax 0x0000000000000007 &lt;+7&gt;:	mov $0x0,%edi 0x000000000000000c &lt;+12&gt;:	jmp 0x11</p><p>  （gdb）disas foo函数foo的汇编代码的转储：0x0000000000000000＆lt; + 0＆gt ;: mov％edi，％esi 0x0000000000000002＆lt; + 2＆gt ;: lea（％rdi，％rdi，1），％edx 0x0000000000000005＆lt; + 5＆gt; ;：xor％eax，％eax 0x0000000000000007＆lt; + 7＆gt ;: mov $ 0x0，％edi 0x000000000000000c＆lt; + 12＆gt ;: jmp 0x11</p><p> In this example we see that the compiler optimized away the stack code by using lea to load the value of  y directly into the relevant register (in this case %edx) instead of using space on the stack, but this isn&#39;t really relevant toTCO. The interesting bit related to TCO is the end of the function. Where beforewe had a  call, now we have a  jmp; and also notable, there&#39;s no more  retinstruction. Once again the operand to  jmp is just a dummy value here thatwill be replaced at link time by the linker.</p><p> 在此示例中，我们看到编译器通过使用lea将y的值直接加载到相关寄存器（在本例中为％edx）而不是在堆栈上使用空间的方式优化了堆栈代码，但这并不是真的与TCO相关。与TCO相关的有趣部分是功能的结尾。以前我们打过电话的地方，现在有了一个跳；而且值得一提的是，不再进行任何改造。再一次，jmp的操作数只是一个伪值，在链接时将被链接器替换。</p><p> This is tail call optimization. Tail call optimization happens when the compilertransforms a  call immediately followed by a  ret into a single  jmp. Thistransformation saves one instruction, and more importantly it eliminates theimplicit push/pop from the stack done by  call and  ret. And your compilerdoes it  all the time, not just for recursive function calls. In general TCOwill be applied  any time the last instruction of a function is anotherfunction call. So how does it work?</p><p> 这是尾叫优化。尾部调用优化发生在编译器立即将调用转换为ret，然后转换为单个jmp时。这种转换节省了一条指令，更重要的是，它消除了由调用和ret完成的隐式推/弹出操作。而且您的编译器会一直这样做，而不仅仅是递归函数调用。通常，只要某个函数的最后一条指令是另一个函数调用，就会应用TCO。那么它是怎样工作的？</p><p> In the optimized version the  jmp instruction will jump directly to  printf,without pushing the PC onto the stack. Imagine this is part of a larger program,and some other subroutine called  foo. When  foo is entered the address of thecaller will be at the top of the stack. When  foo executes the  jmp at theend, it will jump directly to the  printf code, and the address of the callerof  foo will still be on top of the stack. The  printf function itself has itsown  ret that it uses to return. Since  foo didn&#39;t push its own address ontothe stack, when  printf executes its  ret instruction it will actually pop thevalue from the stack that corresponds to the address of the caller of  foo.</p><p> 在优化版本中，jmp指令将直接跳转到printf，而无需将PC推入堆栈。想象一下，这是一个更大程序的一部分，以及其他一些名为foo的子程序。输入foo后，调用者的地址将在堆栈的顶部。当foo在最后执行jmp时，它将直接跳到printf代码，并且foo的调用者的地址仍将位于堆栈的顶部。 printf函数本身具有自己的ret，可用于返回。由于foo不会将其自己的地址压入堆栈，因此当printf执行其ret指令时，它将实际上从堆栈中弹出与foo调用者地址相对应的值。 </p><p>  If a function makes a recursive tail call, TCO will be applied exactly as above.A simple compiler can actually treat recursive TCO exactly the same asnon-recursive TCO, without any special logic. For fun let&#39;s look at a tail-callversion of factorial:</p><p>如果函数进行了递归尾调用，则将完全按照上面的方法应用TCO。一个简单的编译器实际上可以将递归TCO与非递归TCO完全相同，而无需任何特殊逻辑。为了好玩，让我们看一下阶乘的尾调：</p><p> /* Tail-call recursive helper for factorial */int factorial_accumulate(int n, int accum) { return n &lt; 2 ? accum : factorial_accumulate(n - 1, n * accum);}int factorial(int n) { return factorial_accumulate(n, 1); }</p><p> / *阶乘的尾调用递归助手* / int factorial_accumulate（int n，int accum）{return n＆lt; 2？ accum：factorial_accumulate（n-1，n * accum）;} int factorial（int n）{return factorial_accumulate（n，1）; }</p><p> Note that this is not the naive version of factorial implemented as  n * factorial(n-1), because in the naive version the function needs to make arecursive call, and then multiply the return value of the recursive call beforereturning, meaning that the recursive call is  not in the tail position.</p><p> 请注意，这不是实现为n * factorial（n-1）的阶乘的朴素版本，因为在朴素的版本中，该函数需要进行递归调用，然后在返回之前乘以递归调用的返回值，这意味着递归通话不在尾部位置。</p><p>  (gdb) disas factorialDump of assembler code for function factorial: 0x0000000000000040 &lt;+0&gt;:	mov $0x1,%eax 0x0000000000000045 &lt;+5&gt;:	cmp $0x1,%edi 0x0000000000000048 &lt;+8&gt;:	jle 0x60 &lt;factorial+32&gt; 0x000000000000004a &lt;+10&gt;:	nopw 0x0(%rax,%rax,1) 0x0000000000000050 &lt;+16&gt;:	imul %edi,%eax 0x0000000000000053 &lt;+19&gt;:	sub $0x1,%edi 0x0000000000000056 &lt;+22&gt;:	cmp $0x1,%edi 0x0000000000000059 &lt;+25&gt;:	jne 0x50 &lt;factorial+16&gt; 0x000000000000005b &lt;+27&gt;:	ret 0x000000000000005c &lt;+28&gt;:	nopl 0x0(%rax) 0x0000000000000060 &lt;+32&gt;:	retEnd of assembler dump.(gdb) disas factorial_accumulateDump of assembler code for function factorial_accumulate: 0x0000000000000020 &lt;+0&gt;:	mov %esi,%eax 0x0000000000000022 &lt;+2&gt;:	cmp $0x1,%edi 0x0000000000000025 &lt;+5&gt;:	jle 0x3b &lt;factorial_accumulate+27&gt; 0x0000000000000027 &lt;+7&gt;:	nopw 0x0(%rax,%rax,1) 0x0000000000000030 &lt;+16&gt;:	imul %edi,%eax 0x0000000000000033 &lt;+19&gt;:	sub $0x1,%edi 0x0000000000000036 &lt;+22&gt;:	cmp $0x1,%edi 0x0000000000000039 &lt;+25&gt;:	jne 0x30 &lt;factorial_accumulate+16&gt; 0x000000000000003b &lt;+27&gt;:	retEnd of assembler dump.</p><p>  （gdb）disas factorial函数析构函数的汇编代码转储：0x0000000000000040＆lt; + 0＆gt ;: mov $ 0x1，％eax 0x0000000000000045＆lt; + 5＆gt ;: cmp $ 0x1，％edi 0x0000000000000048＆lt; + 8＆gt ;: jle 0x60＆lt; factorial + 32＆gt; 0x000000000000004a＆lt; + 10＆gt ;: nopw 0x0（％rax，％rax，1）0x0000000000000050＆lt; + 16＆gt ;: imul％edi，％eax 0x0000000000000053＆lt; + 19＆gt ;: sub $ 0x1，％edi 0x0000000000000056＆lt; + 22＆gt; ：cmp $ 0x1，％edi 0x0000000000000059＆lt; + 25＆gt ;: jne 0x50＆lt; factory + 16＆gt; 0x000000000000005b＆lt; + 27＆gt ;: ret 0x000000000000005c＆lt; + 28＆gt ;: nopl 0x0（％rax）0x0000000000000060＆lt; + 32＆gt ;:汇编程序转储的结尾。 ;：mov％esi，％eax 0x0000000000000022＆lt; + 2＆gt ;: cmp $ 0x1，％edi 0x0000000000000025＆lt; + 5＆gt ;: jle 0x3b＆lt; factor_accumulate + 27＆gt; 0x0000000000000027＆lt; + 7＆gt ;: nopw 0x0（％rax，％rax，1）0x0000000000000030＆lt; + 16＆gt ;: imul％edi，％eax 0x0000000000000033＆lt; + 19＆gt ;: sub $ 0x1，％edi 0x0000000000000036＆lt; + 22＆gt; ：cmp $ 0x1，％edi 0x0000000000000039＆lt; + 25＆gt ;: jne 0x30＆lt; factoral_accumulate + 16＆gt; 0x000000000000003b＆lt; + 27＆gt ;：汇编程序转储的retEnd。</p><p> This is actually pretty interesting! For one thing, in the code for  factorialit completely inlined the  factorial_accumulate logic, so  factorial doesn&#39;tcall  factorial_accumulate at all. However, the compiler still generated codefor  factorial_accumulate in my object file. If you take a minute to readthrough this you can see how  factorial_accumlate works. The first threeinstructions which are a sequence of  mov,  cmp,  jle test for the recursionbase case (i.e.  n &lt; 2) and jump to a  ret instruction in this base case. Whenthe condition  n &lt; 2 is false then the code enters a loop of instructions imul for the multiply,  sub to decrement  n, another  cmp to see if thebase case has been hit, and a  jne to return to the  imul instruction with thebase case isn&#39;t hit. When the base case is hit the  jne falls through to the ret.</p><p> 这实际上很有趣！一方面，在factorialit的代码中完全内联了factorial_accumulate逻辑，因此factorial根本不调用factorial_accumulate。但是，编译器仍在我的目标文件中生成了factorial_accumulate的代码。如果您花一点时间通读此书，则可以看到factorial_accumlate的工作原理。前三个指令是对递归基本情况（即n <2）的mov，cmp，jle序列测试，在此基本情况下跳转到ret指令。当条件n ＜ 2为假，则代码进入指令循环imul进行乘法运算，将n减1，再执行另一个cmp以查看是否已击中基本情况，并且未击中返回具有基本情况的imul指令的jne 。当击打基本情况时，枪管会掉到后座。</p><p> The code for  factorial works almost exactly the same way, and you&#39;ll noticeessentially the same instruction sequence. Some of the registers are differentbecause  factorial is called with one parameter instead of two. For some reasonit has two  ret statements, presumably for alignment reasons (this is also whythe  nopw and  nopl instructions are here, these are no-op instructions thatonly exist for alignment purposes).</p><p> 阶乘的代码几乎完全以相同的方式工作，并且您将注意到基本相同的指令序列。一些寄存器是不同的，因为阶乘是用一个参数而不是两个参数来调用的。由于某种原因，它有两个ret语句，大概是出于对齐的原因（这也是为什么nopw和nopl指令在此处，它们是仅用于对齐目的的无操作指令的原因）。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://eklitzke.org/how-tail-call-optimization-works">https://eklitzke.org/how-tail-call-optimization-works</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/呼叫/">#呼叫</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/call/">#call</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lt/">#lt</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>