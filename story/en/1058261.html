<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>数据流水线工具的未来必须包括比ETL更好的转换 The future of data pipeline tools must include better transformations than ETL</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The future of data pipeline tools must include better transformations than ETL<br/>数据流水线工具的未来必须包括比ETL更好的转换 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-14 12:02:48</div><div class="page_narrow text-break page_content"><p>Everybody hates data transformations in their pipeline tools. Developers hated the transformations in ETL tools so much that they came up with a whole new tool classification – ELT – that removed transformations completely, leaving that work to specialized tools such as  dbt to do on the data warehouse.</p><p>每个人都讨厌其管道工具中的数据转换。开发人员如此讨厌ETL工具中的转换，以至于它们提出了一个全新的工具分类 -  elt  - 完全删除了转换，将其工作到Date Warehouse上的DBT等专业工具。</p><p> It’s easy to understand why. Data pipeline tools have always made transformations difficult to use. Send it to the warehouse and transform it there. It’s easier. You only have to know SQL, and those scripts run way faster.</p><p> 很容易理解原因。数据管道工具始终使变换难以使用。将其发送到仓库并在那里转换它。它更容易。你只需要知道SQL，那些脚本运行得更快。</p><p> Well… I’m calling BS on this commonly held belief. While it’s not wrong, the problem with it is that no data pipeline tool has implemented data transformations well.</p><p> 好吧......我在这个普遍认为的信仰上呼唤BS。虽然它没有错误，但问题是没有数据流水线工具已经很好地实现了数据变换。</p><p>  RudderStack Transformations are easy to build, debug, and manage; and they run in real-time. They’re data transformations that work like you think they should.</p><p>  Rudderstack转换易于构建，调试和管理;他们实时运行。他们是像你认为应该一样的数据转换。</p><p> The Problems with Data Transformations in Every Data Pipeline Tool You’ve Ever Used</p><p> 您曾经使用过的每个数据流水线工具中数据转换的问题</p><p>  When you’re transforming data there is always going to be some level of technical complexity. It almost always takes programming knowledge to build data transformations in pipeline tools. Yet these tools always seem to have some level of disdain for the data engineers that use them, and that is where things get complex.</p><p>  当您转换数据时，总始终存在一些技术复杂程度。它几乎总是需要编程知识来构建管道工具中的数据转换。然而，这些工具似乎似乎对使用它们的数据工程师似乎有一定程度的蔑视，这就是事情变得复杂的地方。</p><p> At this point, most of these tools support reusing data transformations, which is good, but reuse is the bare minimum.</p><p> 此时，大多数这些工具都支持重用数据转换，这很好，但重用是最小的。 </p><p> Can I reuse this transformation? Yes. Great, can I reuse it in this other transformation to perform a more complex transformation???</p><p>我可以重用这种转变吗？是的。伟大的，我可以在这种其他转变中重用它来执行更复杂的转换吗???</p><p> Data pipeline tools don’t support common software engineering concepts such as modularity. This makes a data engineer’s job more complex. You end up having to copy and paste code from one transformation to another to replicate existing functionality as part of a new but different transformation. Then you have to manually maintain it forever.</p><p> 数据流水线工具不支持常见的软件工程概念，如模块化。这使得数据工程师的工作更加复杂。您最终必须从一个转换复制和粘贴到另一个转换的代码，以将现有功能复制为新但不同的转换的一部分。然后你必须手动保持它。</p><p> It’s difficult to integrate building transformations into your engineering processes too. The code for your transformations lives in the data pipeline tool, and, while you can likely version your transformations at this point, only a few tools have git integration. Even more rare is a data pipeline tool having an API that lets you build and manage your transformations with all your preferred processes and tools.</p><p> 难以将建筑转换整合到您的工程过程中。转换的代码生存在数据流水线工具中，而且在此时可能会在此时版本的版本，只有几个工具都有Git集成。更罕见的是具有API的数据流水线工具，可让您构建和管理您的转换以及所有首选的流程和工具。</p><p>   Debugging data transformations is a nightmare too. Having a debugger on the code is great and most do at this point, but that’s the bare minimum once again.</p><p>   调试数据转换也是一个噩梦。在代码上有调试器很棒，大多数此时都是这样做的，但这是赤裸的最小。</p><p>  The solution that data pipeline tools have come up with for this is… nothing. Run data through it, and see what comes out the other side. Some have a data debugger, but you still have to run data through it.</p><p>  数据流水线工具已经提出的解决方案是......没有。通过它运行数据，看看另一边出现了什么。有些人有一个数据调试器，但您仍然必须通过它运行数据。</p><p> Nobody in the history of time has ever thought doing this testing on Production was a good idea (or, if they did, they regretted it). So what do you do? Build a test environment… for your ETL tool?</p><p> 在时间历史上没有人想过这项测试的生产测试是一个好主意（或者，如果他们这样做，他们后悔了）。所以你会怎么做？构建测试环境......为您的ETL工具？</p><p>   Data transformations in pipeline tools always run in batches. This is an artifact of the tools they are a part of – ETL tools – which run jobs in batch and apply the transformations when the job runs.</p><p>   管道工具中的数据转换始终批量运行。这是它们是它们是-ETL工具的一部分的工具的工件 - 这是批量运行作业并在作业运行时应用转换。 </p><p> The stereotype of traditional ETL tools is that you’d have to wait until tomorrow morning or next week to get updated data. These waiting periods are the frequency each batch runs, and they aren’t anywhere near as bad as they used to be. Most of the major ETL tools are configurable and have trimmed it down to 5 minutes or so at the shortest.</p><p>传统ETL工具的刻板印象是您必须等到明天早上或下周获得更新的数据。这些等待期间是每个批处理运行的频率，而且它们不像过去那样差的任何地方。大多数主要ETL工具可配置，并将其修整至最短的时间为5分钟左右。</p><p> That’s much improved, but the standard isn’t 5 minutes – that’s the best and most expensive option – and 5 minutes isn’t close to real-time. A lot of the data you want to integrate and transform in-transit is more valuable when delivered in real-time.</p><p> 这很好，但标准不是5分钟 - 这是最好和最昂贵的选择 -  5分钟并不接近实时。在实时交付时，您要集成和转换在运输中的许多数据更有价值。</p><p> There are Good Reasons why You’d Want to Transform Data Before Sending it to a Destination</p><p> 在将数据发送到目的地之前，您希望转换数据有很好的原因</p><p> Given the deficiencies, the mantra of ELT seems like a plain one to align with. Your data pipeline is for extracting and loading data. Use specific data transformation tools to transform your data in your warehouse. It works better.</p><p> 鉴于缺陷，Elt的口头禅似乎是一个与之对齐的普通人。您的数据流水线用于提取和加载数据。使用特定的数据转换工具在仓库中转换数据。它更好。</p><p> ELT assumes something that isn’t true in data pipelines anymore. ELT assumes the destination is the data warehouse. So, if you don’t apply a transformation before loading, no biggie. Apply it after. It makes no real difference.</p><p> Elt在数据管道中不再承担了不正确的东西。 elt假设目的地是数据仓库。因此，如果您在加载前不应用转换，则没有Biggie。以后申请。它没有真正的区别。</p><p> Modern data stacks are more complex than that though. You want to send your data to your warehouse, but you also have 20 other tools you want to send it to as well. Each of them has its own transformation needs, and applying transformations after the fact often isn’t realistic or possible.</p><p> 现代数据堆栈比其更复杂。您想将数据发送到仓库，但您还有20个您想要发送的其他工具。他们每个人都有自己的转型需求，并且在事实之后施加变换通常不会逼真或可能。</p><p> While you should do most modeling and heavy transformation at-rest in your warehouse with tools like dbt, in-transit transformations are still critical to solving the problems modern companies face.</p><p> 虽然您应该在仓库中进行大多数建模和繁重的转型，但与DBT这样的工具，在运输过程中仍然至关重要，以解决现代公司面临的问题。 </p><p> One classic use case that benefits from in-transit transformations is filtering and enforcing data quality before sending to your warehouse. Performing this transformation in-transit means the data in your warehouse is always analysis-ready. If done at-rest, the fidelity of your analysis-ready data will only be as often as your transformation runs.</p><p>一个经典用例，在传输转换中受益在发送到仓库之前过滤和实施数据质量。执行此转换的转换意味着仓库中的数据总是准备好分析。如果在休息状态下，您的分析准备数据的保真度只能与变换运行一样经常。</p><p> Another, more modern use case that benefits from in-transit transformations is masking or removing PII and sensitive data. It’s better if this kind of data is never loaded anywhere it isn’t needed, including your warehouse. While you can mask/remove PII after loading data into your warehouse, you probably can’t after loading into your 20 other destination tools. You need in-transit transformations to support this very common use case.</p><p> 另一个，更多的现代用例，从过境转换中受益是屏蔽或去除PII和敏感数据。如果这种数据从未加载任何地方，则更好，包括您的仓库。虽然您可以在将数据加载到仓库后屏蔽/删除PII时，您可能无法在加载到其他20个目的地工具之后。您需要传输转换以支持这一非常常见的用例。</p><p>  When you step outside of the batch world of ETL and ELT pipelines and into the real-time world of event streaming pipelines, the ability to transform data before loading in a destination tool becomes much more critical.</p><p>  当您介绍ETL和Elt管道的批量世界，进入事件流水线的实时世界时，在达到目的地工具中加载之前转换数据的能力更为关键。</p><p> Sending real-time events is incredibly valuable, because you can start to implement behavior-based tactics by sending this data to tools that use it to automate execution – think sending an email through  Customer.io or personalizing a user’s experience through  Braze, both based on triggering actions in your application. These behavior-based tactics can have a very high ROI when done well.</p><p> 发送实时事件非常有价值，因为您可以通过将此数据发送到使用它来自动执行的工具开始实现基于行为的策略 - 思考通过Customer.IO发送电子邮件或通过钎焊来个性化用户的体验触发应用程序中的操作。这些行为的策略在完成时可以具有非常高的投资回报率。</p><p> You can’t send a raw event stream to every destination tool that you use though. Your data quality would suffer. Also, you probably want to enrich your events – such as adding info from Clearbit or location data.</p><p> 您无法将原始事件流发送到您使用的每个目标工具。您的数据质量会受到影响。此外，您可能希望丰富您的活动 - 例如从Clearbit或位置数据添加信息。</p><p> More importantly, you can’t send the PII and sensitive data in your event stream to all your destination tools. That is a data privacy nightmare. You should be masking or removing as much PII and sensitive data as possible before it ever reaches a destination tool. This is the safest approach for your customers and your business. For businesses in highly regulated industries, the feasibility of event streaming will hinge on this.</p><p> 更重要的是，您无法将事件流中的PII和敏感数据发送到所有目标工具。这是一个数据隐私噩梦。在达到目标工具之前，您应该在屏蔽或删除尽可能多的PII和敏感数据。这是您的客户和您的业务的最安全的方法。对于高度监管行业的企业，事件流的可行性将铰接在此。</p><p>  RudderStack Transformations let you transform any data that you send through RudderStack and you can use them across Event Stream, Warehouse Actions, and Cloud Extract pipelines. They are easy to build, debug, and manage; and they run in real-time, after data collection and before delivery to a destination. They’re data transformations that work like you think they should.</p><p>  Rudderstack转换让您通过RudderStack转换您发送的任何数据，您可以在事件流，仓库操作和云提取管道上使用它们。它们很容易构建，调试和管理;他们实时运行，在数据收集后和送达到目的地之前。他们是像你认为应该一样的数据转换。 </p><p> RudderStack Transformations are easy to write and maintain. You write them in Javascript, which is a common and easy-to-use language. Every transformation is reusable. So if you write it once, you can use it everywhere. Transformations are modular too. You can save them to your organization’s Transformation Library and reuse them as part of other transformations, just like libraries in software programming (we’re even including some out-of-the-box transformation libraries in the RudderStack Library).</p><p>Rudderstack变换易于编写和维护。您将它们写在JavaScript中，这是一种常见而易于使用的语言。每次转换都是可重复使用的。所以如果你写一次，你可以随处使用它。变换也是模块化的。您可以将它们保存到组织的转换库并将其作为其他转换的一部分重用，就像软件编程中的库一样（我们甚至包括Rudderstack库中的一些开箱即用的转换库）。</p><p> You can even build transformations using all the processes and tools you prefer with the Transformations API. With it, you can programmatically add and remove transformations to the platform, create an organization-wide sandbox where your team can store transformations before publishing them to the live environment, define libraries, and version control your transformations.</p><p> 您甚至可以使用更喜欢的所有进程和工具来构建转换，转换API。有了它，您可以以编程方式为平台添加和删除转换，创建一个组织范围的沙箱，在将其团队发布到Live环境，定义库和版本之前，您的团队可以存储转换。</p><p>   Not only do we give you a code debugger so you can confirm your transformation will run, but we have a transformation test as well. It lets you send a sample payload through the transformation and see the results inside of RudderStack before ever applying it to your data pipelines. We provide sample event stream payloads you can use for testing your transformations, but you can change the payload to replicate the data you will be transforming.</p><p>   我们不仅给您一个代码调试器，所以您可以确认您的转换将运行，但我们也有一个转换测试。它允许您通过转换发送样本有效载荷，并在曾经将其应用于数据管道之前，请参阅Rudderstack内部的结果。我们提供样本事件流有效载荷可以用于测试转换，但您可以更改有效载荷以复制您将要转换的数据。</p><p>  RudderStack Transformations run in real-time. They aren’t batch. They are applied in-transit after data collection and before delivery to a destination. So they work with our event streaming and reverse-ETL pipelines in addition to our ELT pipelines.</p><p>  Rudderstack改造实时运行。他们不批量。它们在数据收集后和交付到目的地之前应用于过境。因此，除了我们的灯管管道之外，他们还使用我们的活动流和Reverse-Etl管道。</p><p> Learn more about all of the new functionality we added to Transformations in our post,  Introducing New Functionality to RudderStack Transformations: API, Libraries, and Debugger.</p><p> 了解有关我们在帖子中添加到转换的所有新功能的更多信息，向RudderStack转换引入新功能：API，库和调试器。</p><p>   Start using a smarter customer data pipeline that builds your customer data lake on your data warehouse. Use all your customer data. Answer more difficult questions. Send insights to your whole customer data stack. Sign up for RudderStack Cloud Free today.</p><p>   开始使用更智能的客户数据流水线，在数据仓库上构建您的客户数据湖泊。使用所有客户数据。回答更困难的问题。向整个客户数据堆栈发送见解。立即注册Rudderstack云。</p><p> Join our  Slack to chat with our team, check out our open source repos on  GitHub, subscribe to  our blog, and follow us on social:  Twitter,  LinkedIn,  dev.to,  Medium,  YouTube. Don’t miss out on any updates.  Subscribe to our blogs today!</p><p> 加入我们的聊天与我们的团队聊天，查看GitHub上的开源回购，订阅我们的博客，并在社交：推特，LinkedIn，Dev.to，Medie，YouTube上关注我们。不要错过任何更新。今天订阅我们的博客！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://rudderstack.com/blog/the-future-of-data-pipeline-tools-must-include-better-transformations-than-etl-ever-had">https://rudderstack.com/blog/the-future-of-data-pipeline-tools-must-include-better-transformations-than-etl-ever-had</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/流水线/">#流水线</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/data/">#data</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/转换/">#转换</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>