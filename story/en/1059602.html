<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>有多少x86指令？ （2016） How many x86 instructions are there? (2016)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How many x86 instructions are there? (2016)<br/>有多少x86指令？ （2016） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-22 11:55:18</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/7cf484ceeae6bc7fc2161eddc603cd15.jpg"><img src="http://img2.diglog.com/img/2021/4/7cf484ceeae6bc7fc2161eddc603cd15.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>It’s surprisingly hard to give a good answer (the question was raised in  this article). It depends on how you count, and the details are interesting (to me anyway).</p><p>令人惊讶的是，给出一个很好的答案（在本文中提出的问题）。这取决于你的统计方式，细节很有趣（无论如何）。</p><p> To not leave you hanging: Intel has an official x86 encoder/decoder library called  XED. According to Intel’s XED, as of this writing, there are 1503 defined x86 instructions (“iclasses” in XED lingo), from  AAA to  XTEST (this includes AMD-specific extensions too, by the way). Straightforward, right?</p><p> 不要离开你挂起：英特尔有一个官方x86编码器/解码器库，名为xed。根据英特尔的XED，就像这种写作一样，有1503个定义的x86指令（“Xed Lingo的iClasses”），从AAA到XTest（这也包括AMD特定的扩展，顺便说一句）。直截了当，对吧？</p><p> Well, it depends on what you wanted to count. For example, as per XED,  ADD and  LOCK ADD are different “instruction classes”. Many assembly programmers would consider  LOCK a prefix and  LOCK ADD an addition with said prefix, not a distinct instruction, but XED disagrees. And in fact, for the purposes of execution, so do current x86s. An atomic add does very different things from a regular add. The prefix thing crops up elsewhere: is say  MOVSD (copy a single 32-bit word) a different “instruction class” from  REP MOVSD (block copy several 32-bit words)? XED says yes. But it doesn’t handle  all prefixes this way in all contexts. For example, the operand-size prefix ( 0x66) turns integer instructions operating on 32-bit registers into the equivalent instruction operating on their lower 16-bit halves, but unlike with the  REP or  LOCK prefixes, XED does not count these as separate instruction classes. If you disagree about any of these choices, your count will come out different.</p><p> 嗯，这取决于你想要的依据。例如，根据XED，添加和锁添加是不同的“指令类”。许多装配程序员将考虑锁定前缀和锁添加添加添加的前缀，而不是一个不同的指令，而是xed不同意。实际上，为了执行目的，所以当前x86s。原子添加从常规添加中添加了非常不同的东西。前缀在其他地方杂耍的前缀：例如，来自rep movsd的movsd（复制一个32位字）不同的“指令类”（块复制多个32位字）？ xed说是的。但它不能在所有上下文中以这种方式处理所有前缀。例如，操作数大小前缀（0x66）将在32位寄存器上运行的整数指令转换为在其较低的16位半部上运行的等效指令，但与REP或Lock前缀不同，XED不会将其视为单独的指令课程。如果你不同意这些选择中的任何一个选择，你的伯爵会出现不同。</p><p>  It all depends on how precisely we define an instruction. Is it something with a distinct mnemonic? Let’s first look at what the article I quoted above says is by far the most common x86 instruction, at 33% of the total sample set:  MOV. So let’s look up MOV in the Intel Architecture manuals. And… there are 3 different top-level entries? “MOV—Move”, “MOV—Move to/from Control registers”, “MOV—Move to/from Debug Registers”. The latter are sufficiently distinct from “regular”  MOV to rate their own documentation pages, they have completely different instruction encodings (not even in the same encoding block as regular  MOV), and they’re privileged instructions, meaning lowly user-mode code isn’t even allowed to execute them. Consequently they’re also extremely rare, and are likely to account for approximately 0% of the test sample. And, sure enough, XED counts them as separate instruction classes ( MOV_CR and  MOV_DR).</p><p>  这一切都取决于我们如何定义指令。它是一种独特的助记符吗？让我们首先查看我上面引用的文章所说的是到目前为止最常见的X86指令，占总样品集的33％：mov。因此，让我们在英特尔架构手册中查找MOV。 ...有3个不同的顶级条目？ “mov-move”，“移动到/从控制寄存器移动”，“移动到/从调试寄存器移动”。后者与“常规”mov中的速度充分不同，以评估自己的文档页面，它们具有完全不同的指令编码（即使与常规mov的相同编码块），它们是特权指令，含量低于用户模式代码甚至允许执行它们。因此，它们也非常罕见，并且可能占测试样本的约0％。并且，肯定，XED将它们计为单独的指令类（MOV_CR和MO​​V_DR）。</p><p> So these instructions may be  called  MOV, but they’re weird, special snowflakes, and from the processor’s point of view they’re entirely different instructions in a different part of the encoding space and with different rules. Calling them  MOV is essentially nothing but syntactic sugar in the official Intel assembly language.</p><p> 因此，这些指令可能被称为MOV，但它们是奇怪的，特殊的雪花，以及从处理器的角度来看，它们在编码空间的不同部分和不同的规则中完全不同的指令。调用他们的mov基本上是官方英特尔汇编语言中的句子糖。</p><p> And on the subject of syntactic sugar: some mnemonics are just aliases. For example,  SAL (shift arithmetic left) is a long-standing alias for  SHL (shift left). Both are just bit shifts; there is no distinction between “arithmetic” and “logical” left shifts like there is between arithmetic and logical right shifts, but the Intel manuals list  SAL (with an encoding that happens to be the same as  SHL) and all x86 assemblers I’ve ever used accept it. Hilariously, in official Intel syntax, we’re simultaneously miscounting in the other direction, since at least two mnemonics got assigned twice: we already saw the “copy” variant of  MOVSD (which has no explicit operands), but there’s also  MOVSD as in “move scalar double” (which always has two explicit operands) which is an entirely different instruction (XED calls it  MOVSD_XMM to disambiguate, and the same problem happens with  CMPSD).</p><p> 在句法糖的主题上：一些助记符只是别名。例如，SAL（移位算术留）是SHL的长期别名（左移）。两者都只是班次; “算术”和“逻辑”左移之间没有区别，如算术和逻辑右移之间的左移，但英特尔手册列表SAL（与SHL发生的编​​码相同）和我的所有X86汇编者曾经使用过接受它。在官方英特尔语法中，我们同时沿另一个方向错误地错误，因为至少两个助记符被分配了两次：我们已经看到了MOVSD的“复制”变体（它没有明确的操作数），但也有MOVSD “移动标量双”（始终有两个显式操作数），这是一个完全不同的指令（XED调用它movsd_xmm来消除歧义，并且CMPSD发生同样的问题）。</p><p> There’s also SSE compares like  CMPSD (the two-operand one!) and  CMPPS. XED counts these as one instruction each. But they have an 8-bit immediate constant byte that specifies what type of comparison to perform. But disassemblers usually won’t produce the hard-to-read  CMPSD xmm0, xmm1, 2; they’ll disassemble that instruction as the pseudo-instruction  CMPLESD (compare scalar doubles for lesser-than-or-equal) instead. So is  CMPSD one instruction (just the base opcode with an immediate operand), is it 8 (for the 8 different standard compare modes), or something else?</p><p> 还有SSE比较cmpsd（两个操作数！）和CMPPS。 XED将它们计数为每个指令。但它们有一个8位立即常量字节，指定要执行的比较类型。但是拆卸通常不会产生难以读取的CMPSD XMM0，XMM1,2;它们将拆卸作为伪指令CMPLESD的指令（将标量与较小或相等的比较）相反。所以cmpsd一个指令（只有带有立即操作数的基本操作码），它是8（对于8种不同的标准比较模式），或其他东西？ </p><p> This is getting messy. AT&amp;T syntax to the rescue? Well, it solves some of our problems but also introduces new ones. For example, AT&amp;T adds suffixes to the mnemonics to distinguish different operation widths. What Intel calls just  ADD turns into  ADDB (8-bit bytes),  ADDW (16-bit “words”),  ADDL (32-bit “long words”) and  ADDQ (64-bit “quadwords”) in x86-64 AT&amp;T syntax. Do we count these as separate? As per Intel syntax, no. As per XED instruction classes, also no. But maybe we consider these distinct enough to count separately after all? Or maybe we decide that if our definition depends on the choice of assembly syntax, of which there are several, then maybe it’s not a very natural one. What does the machine do?</p><p>这令人凌乱。 ＆amp; t语法对救援？嗯，它解决了我们的一些问题，但也引入了新的问题。例如，AT＆amp; T将后缀添加到助记符中以区分不同的操作宽度。仅添加到x86-64 AT＆amp的addb（16位“单词”），addl（32位“长字”）和AddQ（64位“Quadwords”）和ADDL（32位“长字”）和ADDQ（64位“Quadwords”）和AddQ（64位“Quadwords”）和AddQ（34位“Quadwords”）中的内容。 ; t语法。我们是否将这些单独算作？根据英特尔语法，没有。根据XED指令类，也没有。但也许我们认为这些明显足以毕竟分别计算？或者我们决定如果我们的定义取决于组装语法的选择，那么有几个，那么也许它不是一个非常自然的。机器做了什么？</p><p>  Note I haven’t specified what part of the machine yet. This is thorny too. We’ll get there in a bit.</p><p>  注意我还没有指定机器的哪个部分。这也是棘手的。我们会在那里有一点。</p><p> But first, instruction bytes. Let’s look at the aforementioned manual entry for real now: “MOV—Move”. If you check that page out in the current Intel Architecture Software Developer’s Manual, you’ll find it lists no less than  thirty-four encodings (not all of them distinct; I’ll get to that). Some of these are more special, privileged operations with special encodings (namely, moves to and from segment registers). This time, XED doesn’t seem to consider segment register loads and stores to be special and lumps them into plain old  MOV, but I consider them distinct, and the machine considers them distinct enough to give them a special opcode byte in the encoding that’s not used for anything else, so let’s call those distinct.</p><p> 但是，首先，指令字节。让我们来看看现在真实的手动输入：“mov-move”。如果您在当前的英特尔架构软件开发人员手册中检查页面，您将发现它列出不少于三十四个编码（并非所有这些编码;我会到达那个）。其中一些是具有特殊编码的更特殊的，特权操作（即，往返段寄存器）。这一次，XED似乎没有考虑分部寄存器加载和商店要特别，并将它们陷入普通的旧MOV，但我认为它们是不同的，机器认为它们足以在编码中提供特殊的OPCODE字节不用于其他任何东西，所以让我们称之为那些不同的东西。</p><p> That leaves us with 30 “regular” moves. Which are… somewhat irregular: 10 of them are doing their own thing and involve moves between memory and different parts of the  RAX (in 64-bit mode) register, all with a special absolute addressing mode (“moffs”) that shows up in these instructions and, to my knowledge, nowhere else. These instructions exist, and again, pretty much nothing uses them. They were useful on occasion in 16-bit mode but not anymore.</p><p> 这让我们留下了30“常规”的动作。哪些不规则：其中10个是在进行自己的事情，涉及在rax（64位模式下）寄存器的内存和不同部分之间移动，所有这些都具有特殊的绝对寻址模式（“Moffs”），它显示在内这些指示和我的知识无处可去。这些指令存在，并且再次存在，几乎没有任何使用它们。它们在16位模式下有机有用，但不再有用。</p><p> This specialness of the accumulator register is a recurring theme in x86. “ op (AL/AX/EAX/RAX), something” has its own encoding (usually smaller) and various quirks for a lot of the instructions that go back to the 8086 days. So even though an asssembly programmer might consider say  TEST ebx, 128 and  TEST eax, 128 the same instruction (and the XED instruction class list agrees here!), these have different opcodes and different sizes. So a lot of things that look the same in an assembly listing are actually distinct for this fairly random reason. Keep that in mind. But back to our MOV!</p><p> 累加器寄存器的这种特殊性是X86中的重复主题。 “OP（AL / AX / EAX / RAX），某些东西”有自己的编码（通常是较小的）和各种怪癖，可以回到8086天的许多说明。因此，即使Asssembly程序员可能会考虑在测试EBX，128和Test EAX，128同一指令（以及XED指令类列表上的同一指令！），这些具有不同的操作码和不同的尺寸。因此，在装配列表中看起来相同的很多东西实际上是为了这种相当随机的原因。记在脑子里。但回到我们的mov！</p><p> The remaining 20 listed MOV variants fall into four distinct categories, each of which has 5 entries. These four categories are:</p><p> 其余20个列出的MOV变体分为四个不同的类别，每个类别有5个条目。这四类是：</p><p> “Load-ish” – move from memory or another same-sized register to a 8/16/32/64-bit register.</p><p> “Load-ISH” - 从内存或其他相同大小的寄存器移动到8/16 / 32/64位寄存器。 </p><p> “Store-ish” – move from a 8/16/32/64-bit register to either another register of the same size, or memory.</p><p>“Store-ISH” - 从8/16/32/64位寄存器移动到相同尺寸或​​内存的另一个寄存器。</p><p>  “Store-immediate-ish” – store an integer constant to either a 8/16/32/64-bit memory location, or a register.</p><p>  “存储 - 立即-ISH” - 将整数常数存储为8/16 / 32/64位存储器位置或寄存器。</p><p> All processor have some equivalent of the first three (the “store immediate” exists in some CPU architectures, but there’s also many that don’t have it). Load/store architectures generally have explicit load and store instructions (hence the name), and everyone has some way to load immediates (large immediate constants often require multiple instructions, but not on x86) and to move the content of one register to another. (Though the latter is not always a dedicated instruction.) So other than the fact that our “load-ish” and “store-ish” instructions also support “storing to” and “loading from” a register (in particular, there’s two distinct ways to encode register-register MOVs), this is not that remarkable. It does explain why MOVs are so common in x86 code: “load”, “store” and “load immediate” in particular are all very common instruction, and MOV subsumes all of them, so of course you see plenty of them.</p><p> 所有处理器都有一些相当于前三个（“存储立即”存在于某些CPU架构中，但也有许多没有它）。加载/存储体系结构通常具有显式加载和存储指令（因此名称），并且每个人都有某种方式加载立即加载（大型立即常量通常需要多个指令，但不在x86上）并将一个寄存器的内容移动到另一个寄存器。 （虽然后者并不总是一个专用的指示。）除了我们的“负载ISH”和“存储-ISH”指令也支持“存储到”和“从”寄存器（特别是有两个编码寄存器寄存器movs的鲜明方法），这并不是那么显着。它确实解释了为什么MOV在X86代码中如此常见：“加载”，“存储”和“加载立即”是所有非常常见的指令，而且MOV归载全部，所以您当然可以看到它们的所有信息。</p><p> Anyway, we have four operand sizes, and four categories. So why are there  five listed encodings per category? Okay, so this is a bit awkward. x86-64 has 16 general-purpose registers. You can access them as 16 full 64-bit registers. For all 16 registers, you can read from (or write to) their low 32-bit halves. Writing to the low 32-bit half zero-extends (i.e. it sets the high half to zero). For all 16 register, you can read from (or write to) their low 16-bit quarter. Writing to the low 16-bit quarter of a register does  not zero-extend; the remaining bits of the register are preserved, because that’s what 32-bit code used to do and AMD decided to preserve that behavior when they specced 64-bit x86 for some reason. And for all 16 registers, you can read from (or write to) their low 8-bit eighth (the lowest byte). Writing the low byte again preserves all the higher bytes, because that’s what 32-bit mode did. With me so far? Great. Because now is when it gets weird. In 16-bit and 32-bit mode, you can also access bits 8 through 15 of the A, B, C and D registers as  AH,  BH,  CH and  DH. And x86-64 mode still lets you do that! But due to a quirk of the encoding, that works only if there’s no REX prefix (which is the prefix that is used to extend the addressable register count from 8 to 16) on the instruction.</p><p> 无论如何，我们有四个操作数大小和四个类别。那么为什么每个类别有五个列出的编码？好的，所以这有点尴尬。 X86-64有16个通用寄存器。您可以访问它们为16个完整的64位寄存器。对于所有16个寄存器，您可以从（或写入）其低32位半部读取。写入低32位半零点（即它将高距离设置为零）。对于所有16个寄存器，您可以从（或写入）其低16位季度。写入寄存器的低16位四分之一的寄存器不会零延伸;寄存器的剩余位保存，因为这是用于执行的32位代码，并且AMD决定在某种原因被指定为64位X86时保留该行为。并且对于所有16个寄存器，您可以从（或写入）其低8位八（最低字节）读取。编写低字节再次保留所有更高的字节，因为这是32位模式所做的。到目前为止和我在一起？伟大的。因为现在是奇怪的时候。在16位和32位模式中，您还可以访问A，B，C和D寄存器的位8到15作为AH，BH，CH和DH。和x86-64模式仍然让你这样做！但由于编码的频闪，只有在指令上只有在没有rex前缀（它是用于将可寻址寄存器计数从8到16扩展到的前缀）上的rex前缀。</p><p> So x86-64 actually has a total of 20 addressable 8-bit registers, in 3 disjoint sets:  AL through  DL, which can be used in any encoding.  AH through  DH, which can only be accessed if no REX prefix is present on the instruction. And the low 8 bits of the remaining 12 registers, which can only be accessed if a REX prefix is present.</p><p> 因此，X86-64实际上具有共有20个可寻址的8位寄存器，在3个不相交的集合中：AL通过DL，可用于任何编码。 AH到DH，只有在指令上没有REX前缀，只能访问它。剩余的12寄存器的低8位，只有在存在REX前缀时才能访问。</p><p> This quirk is why Intel lists all 8-bit variants twice: once without REX and one with REX, because they can access slightly different parts of the register space! Alright, but surely, other than that, we must have 4 different opcodes, right? One each for move byte, word, doubleword, quadword?</p><p> 这个Quirk是为什么英特尔列出了两次的所有8位变体：一次没有rex和一个带有rex的rex，因为它们可以访问寄存器空间略微不同的部分！好吧，但肯定的是，除此之外，我们必须有4个不同的操作码，对吗？一个用于移动字节，单词，双字，quadword？</p><p> Nope. Of course not. In fact, in each of these categories, there are two different opcode bytes: one used for 8-bit accesses, and one for “larger than 8-bit”. This dates back to the 8086, which was a 16-bit machine: “8-bit” and “16-bit” was all the distinction needed. Then the 386 came along and needed a way to encode 32-bit destinations, and we got the already mentioned operand size prefix byte. In 32-bit mode (handwaving here, the details are a bit more complicated), the instructions that  used to mean 16-bit now default to 32-bit, and getting actual 16-bit instrutions requires an operand size prefix. And I already mentioned that 64-bit mode added its own set of prefixes (REX), and this REX prefix is used to upgrade the now default-32-bit “word” instructions to 64-bit width.</p><p> 不。当然不是。实际上，在每个类别中，有两个不同的操作码字节：一个用于8位访问的，一个用于“大于8位”。这可以回到8086，这是一个16位机器：“8位”和“16位”都是所需的所有区别。然后，386伴随着，需要一种编码32位目的地的方法，我们已经提到了已经提到的操作数大小前缀字节。在32位模式（在此处手中，细节有点复杂），用于表示16位现在默认为32位的指令，并且获取实际16位笔记需要操作数大小前缀。我已经提到了64位模式添加了自己的一组前缀（rex），并且该rex前缀用于将现在的默认值-32位“字”指令升级到64位宽度。 </p><p> So even though Intel lists 5 different encodings of the instructions in each group, all of which have somewhat different semantics, there’s only 2 opcodes each associated to them: “8-bit” or “not 8-bit”. The rest is handled via prefix bytes. And as we (now) know, there’s lots of different types of MOVs that do very different things, all of which fall under the same XED “instruction class”.</p><p>因此，即使英特尔列出了每个组中的指令的5种不同的编码，所有这些都具有稍微不同的语义，只有2个操作码与它们相关联：“8位”或“不是8位”。其余部分通过前缀字节处理。正如我们（现在）所知，那么有很多不同类型的MOV，这些MOV都有非常不同的东西，所有这些都在XED“指令类”下落下。</p><p> Maybe instruction classes is the wrong metric to use? XED has another, finer-grained thing called “iforms” that considers the different subtypes of instructions separately. For example, for the just-discussed MOV, we get this list:</p><p> 也许指令类是使用错误的指标？ Xed有另一个，叫做“iforms”的更精细的东西，它分别考虑了不同的指令子类型。例如，对于刚刚讨论的MOV，我们得到了这个列表：</p><p> XED_IFORM_MOV_AL_MEMb=804, XED_IFORM_MOV_GPR8_GPR8_88=805, XED_IFORM_MOV_GPR8_GPR8_8A=806, XED_IFORM_MOV_GPR8_IMMb_C6r0=807, XED_IFORM_MOV_GPR8_IMMb_D0=808, XED_IFORM_MOV_GPR8_MEMb=809, XED_IFORM_MOV_GPRv_GPRv_89=810, XED_IFORM_MOV_GPRv_GPRv_8B=811, XED_IFORM_MOV_GPRv_IMMv=812, XED_IFORM_MOV_GPRv_IMMz=813, XED_IFORM_MOV_GPRv_MEMv=814, XED_IFORM_MOV_GPRv_SEG=815, XED_IFORM_MOV_MEMb_AL=816, XED_IFORM_MOV_MEMb_GPR8=817, XED_IFORM_MOV_MEMb_IMMb=818, XED_IFORM_MOV_MEMv_GPRv=819, XED_IFORM_MOV_MEMv_IMMz=820, XED_IFORM_MOV_MEMv_OrAX=821, XED_IFORM_MOV_MEMw_SEG=822, XED_IFORM_MOV_OrAX_MEMv=823, XED_IFORM_MOV_SEG_GPR16=824, XED_IFORM_MOV_SEG_MEMw=825,</p><p> XED_IFORM_MOV_AL_MEMb = 804，XED_IFORM_MOV_GPR8_GPR8_88 = 805，XED_IFORM_MOV_GPR8_GPR8_8A = 806，XED_IFORM_MOV_GPR8_IMMb_C6r0 = 807，XED_IFORM_MOV_GPR8_IMMb_D0 = 808，XED_IFORM_MOV_GPR8_MEMb = 809，XED_IFORM_MOV_GPRv_GPRv_89 = 810，XED_IFORM_MOV_GPRv_GPRv_8B = 811，XED_IFORM_MOV_GPRv_IMMv = 812，XED_IFORM_MOV_GPRv_IMMz = 813，XED_IFORM_MOV_GPRv_MEMv = 814，XED_IFORM_MOV_GPRv_SEG = 815，XED_IFORM_MOV_MEMb_AL = 816，XED_IFORM_MOV_MEMb_GPR8 = 817，XED_IFORM_MOV_MEMb_IMMb = 818，XED_IFORM_MOV_MEMv_GPRv = 819，XED_IFORM_MOV_MEMv_IMMz = 820，XED_IFORM_MOV_MEMv_OrAX = 821，XED_IFORM_MOV_MEMw_SEG = 822，XED_IFORM_MOV_OrAX_MEMv = 823，XED_IFORM_MOV_SEG_GPR16 = 824，XED_IFORM_MOV_SEG_MEMw = 825，</p><p> As you can see, that list basically matches the way the instruction encoding works, where 8-bit anything is considered a separate instruction, but size overrides by way of prefixes are not. So that’s basically the rule for XED iforms: if it’s a separate instruction (or a separate encoding), it gets a new iform. But just modifying the size of an existing instruction (for example, widening MMX instructions to SSE, or changing the size of a MOV via prefix bytes) doesn’t.</p><p> 正如您所看到的，该列表基本上与指令编码的方式匹配，其中8位任何内容被视为单独的指令，但是通过前缀的大小覆盖。因此，基本上是XED IFORMS的规则：如果它是一个单独的指令（或单独的编码），它会得到一个新的iform。但只需修改现有指令的大小（例如，将MMX指令扩展到SSE，或者通过前缀字节更改MOV的大小）。</p><p> So how many x86 instructions are there if we count distinct iforms as distinct? Turns out, an even 6000. Is that all of them? No. There are some undocumented instructions that XED doesn’t include (in addition to the several formerly undocumented instructions that Intel at some point just decided to make official). If you look at the Intel manuals, you’ll find the curious “UD2”, the defined “Undefined instruction” which is architecturally guaranteed to produce an “invalid opcode” exception. As the name suggests, it’s not the first of its kind. Its older colleague “UD1” half-exists, but not officially so. Since the semantics of UD1 are exactly the same as if it was never defined to begin with. Does a non-instruction that is non-defined and unofficially guaranteed to non-execute exactly as if it had never been in the instruction set to begin with count as an x86 instruction? For that matter, does UD2 itself, the defined undefined instruction, count as an instruction?</p><p> 那么如果我们将不同的iforms视为截然不同？事实证明，偶数6000。是所有这些吗？不可以。XED不包括一些无证指示（除了刚刚决定制作官方的英特尔的几个未记录的指示）。如果您查看英特尔手册，您将找到好奇的“UD2”，所定义的“未定义的指令”，该“未定义的指令”在架构上保证生成“无效的操作码”异常。顾名思义，这不是第一个。它的老同事“UD1”的一半存在，但不是正式的。由于UD1的语义与从未被定义的开始完全相同。是否是非定义和非正式地保证的非指令，因为它从未处于从未处于指令集中以x86指令开始的情况下的那样依赖于指令？就此而言，UD2本身是否自身，定义的未定义指令，算作指令？</p><p>  But back to those iforms: 6000 instructions, huh? And these must all be handled in the decoder? That must be  terrible.</p><p>  但回到那些IFORMS：6000指令，呵呵？这些都必须在解码器中处理？这一定是可怕的。</p><p> Well, no. Not really. I mean, it’s not pleasant, but it’s not the end of the world.</p><p> 好吧，没有。并不真地。我的意思是，这并不愉快，但这不是世界的尽头。 </p><p> First off, let’s talk about how x86 is decoded in the first place: all x86 CPUs you’re likely to interact with can decode (and execute) multiple instructions per cycle. Think about what that means: we have an (aggressively!) variable-length encoding, and we’re continually fetching instructions. These chips can decode (given the right code) 4 instructions per clock cycle. How does that work? They’re variable-length! We may know where the first instruction we’re looking at in this cycle starts, but how does the CPU know where to start decoding the second, third, and fourth instructions? That’s straightforward when your instructions are fixed-size, but for x86 they are most certainly not. And we  do need to decide this quickly (within a single cycle), because if we take longer, we don’t know where the last instruction in our current “bundle” ends, and we don’t know where to resume decoding in the  next cycle!</p><p>首先，让我们谈谈X86首先被解码：所有x86 CPU，你可能会与每循环进行交互（和执行）多个指令进行交互。想想这意味着什么：我们有一个（积极的！）可变长度编码，我们连续获取指令。这些芯片可以解码（给定正确的代码）每个时钟周期的指令。这是如何运作的？它们是可变的长度！我们可能知道我们在此循环中查看的第一个指令的位置开始，但CPU如何知道开始解码第二个，第三和第四个指令的位置？当您的指示是固定的大小时，这很简单，但对于x86，它们肯定不是。我们确实需要快速决定（在一个周期内），因为如果我们需要更长时间，我们不知道我们当前的“捆绑”结束的最后一个指令，我们不知道在哪里恢复解码下一个周期！</p><p> You do not have enough time in a 4GHz clock cycle (all 0.25ns of it) to fully decode 4 x86 instructions. For that matter, you don’t even have close to enough time to “fully decode” (what exactly that means is fuzzy, and I won’t try to make it precise here) one. Two basic ways to proceed: the first is simply, don’t do that! Try to avoid it at all cost. Keep extra predecoding information (such as marking the locations where instructions start) in your instruction cache, or keep a separate decoded cache altogether, like Intels uOp caches. This works, but it doesn’t help you the first time round when you’re running code that isn’t currently cached.</p><p> 您在4GHz时钟周期（其所有0.25ns）中没有足够的时间来完全解码4 x86指令。就此而言，您甚至没有接近足够的时间来“完全解码”（究竟是什么意思是模糊的，我不会试图在这里精确地）。进行两种基本方法：第一个是简单的，不要这样做！尽量避免所有费用。保留额外的预涂层信息（例如在指令缓存中标记指令的位置），或者完全保留单独的解码缓存，例如Intels UOP缓存。这有效，但在运行当前缓存的代码时，它并没有帮助您。</p><p> Which brings us to option two:  deal with it. And the way to do it is pretty much brute force. Keep a queue of upcoming instruction bytes (this ties in with branch target prediction and other things). As long as there’s enough space in there, you just keep fetching another 16 (or whatever) instruction bytes and throw them into the queue.</p><p> 这将我们带来了两个：处理它。而这样做的方式是非常蛮力。保持即将到来的指令字节的队列（这与分支目标预测和其他事物有关）。只要那里有足够的空间，你就只需继续为另外的16（或任何其他）指令字节并将它们扔进队列中。</p><p> Then,  for every single byte position in that queue, you pretend that an x86 instruction starts at that byte, and determine how long it is. Just the length. No need to know what the instruction is. No need to know what the operands are, or where the bytes denoting these operands are stored, or whether it’s an invalid encoding, or if it’s a privileged instruction that we’re not allowed to execute. None of that matters at this stage. We just want to know “supposing that this is a valid instruction, what is it’s length?”. But if we add 16 bytes per cycle to the queue, we need 16 of these predecoders in parallel to make sure that we keep up and get an instruction length for every single possible starting location. We can pipeline these predecoders over multiple cycles if necessary; we just keep fetching ahead.</p><p> 然后，对于该队列中的每个字节位置，您假装x86指令在该字节上开始，并确定它是多长时间的。只是长度。无需知道指令是什么。无需知道操作数是什么，或者存储所赋予这些操作数的字节，或者是否是无效的编码，或者如果它是我们不允许执行的特权指令。这个阶段没有这么重要。我们只是想知道“假设这是一个有效的指示，它的长度是多少？”。但是，如果我们向队列添加16个字节，我们需要16个并行需要16个，以确保我们跟上并获得每个可能的起始位置的指令长度。如有必要，我们可以在多个周期中送出这些预涂层;我们只是继续提前提出。</p><p> Once our queue is sufficiently full and we know that size estimate for every single location in it,  then we decide where the instruction boundaries are. That’s the stage that keeps track. It grabs 16 queue entries (or whatever) starting at the location for the current instruction, and then it just needs to “switch through”. “First instruction says size starting from there is 5 bytes, okay; that means second instruction is at byte 5, and the queue entry says that one’s 3 bytes; okay, third instruction starts at byte 8, 6 bytes”. No computation in that stage, just “table lookups” in the small size table we just spent a few cycles computing.</p><p> 一旦我们的队列充分满足，我们知道它的大小估计了每个位置，那么我们决定了指令边界的位置。这是跟踪的舞台。它抓住了从当前指令的位置开始的16个队列条目（或其他），然后只需“通过”。 “第一条指令表示从有5个字节开始的大小，好的;这意味着第二条指令在字节5，队列条目表明一个人的3个字节;好的，第三条指令以字节8，6字节开始“。在该阶段没有计算，只需在小尺寸表中的“表查找”，我们只是花了几个循环计算。</p><p> That’s one way to do it. As said, very much brute force, but it works. However, if you need 16 predecoders (as you do to sustain a fetch rate of 16 bytes/cycle), then you really want these to be as dumb and simple as you can possibly get away with. These things most certainly don’t care about 6000 different iforms. They just squint at the instruction  just enough to figure out the size, and leave the rest for later.</p><p> 这是这样做的方式。如上所述，非常严厉的力量，但它有效。但是，如果您需要16个Predecoders（当您确实维持16个字节/循环的获取率），那么您真的希望这些是愚蠢和简单，因为您可能会逃脱。这些东西肯定不关心6000个不同的imorms。他们只是眯着眼睛，足以弄清楚尺寸，然后留下剩下的时间。</p><p> Luckily, if you look at the actual  opcode map, you’ll see that this is not all that bad. There’s large groups of opcodes that all have basically the same size and operands, just with different operations – which we don’t care about at this stage at all.</p><p> 幸运的是，如果你看看实际的Opcode地图，你会看到这并不是那么糟糕。有大量的操作码，所有这些都基本上是相同的大小和操作数，只有不同的操作，我们根本不关心这个阶段。 </p><p> And this kind of pattern exists pretty much everywhere. For example, look at that conspicuous, regular block of integer ALU instructions near the top of the opcode map. These all look (and work) pretty similar to the CPU. Most of them have essentially the same encodings (except for a few opcode bits that are different) and the same operand patterns. In fact, the decoder really doesn’t care whether it’s an  OR, an  ADD, a  CMP, or a  XOR. To an assembly-language programmer, a compiler, or a disassembler, these are very different instructions. To the CPU instruction decoder, these are all pretty much the same instruction: “ALU something-or-other mumble-mumble don’t care”. Which one of these gets performed will only be decided way later (and probably only after that operation make it to the ALU itself). What the decoder cares about is whether it’s an ALU instruction with an immediate operand, or if it has a memory operand, and what that memory operand looks like. And the instructions are conveniently organized in groups where the answers to these questions are always the same. With plenty of exceptions of course, because this is still x86, but evidently it can be made to work.</p><p>这种模式几乎存在。例如，查看Opcode映射顶部附近的常规整数的常规整数的常规块。这些都看起来（和工作）非常相似于CPU。其中大多数具有基本相同的编码（除了几个不同的Opcode位除外）和相同的操作数模式。事实上，解码器真的不关心它是否是一个或，添加，CMP或XOR。对于装配语言编程器，编译器或反汇编程序，这些是非常不同的指令。对于CPU指令解码器，这些都是相同的指示：“Alu的东西 - 或者 - 其他犬歌不在乎”。其中哪一个执行将仅在稍后决定（并且可能只在该操作使其到ALU本身之后）。解码器关注的是，它是否是一个具有直接操作数的ALU指令，或者如果它有内存操作数，以及内存操作数看起来像什么样的。这些说明在这些问题的答案总是相同的中，方便地组织。当然，由于这仍然是x86，但显然它可以工作。</p><p>  Instructions really don’t get decoded all at once, in one big “switch statement”, and after that they go to disjoint parts of the chip never to meet again. That’s not how these things are built. There’s plenty of similarity between different instructions, and the “understanding” of what an instruction does is distributed, not centralized.</p><p>  说明实际上没有一次性地解码，在一个大的“切换语句”，之后，他们转到不相交的芯片从来没有再次见面。这不是这些东西的建造。在不同的指令之间存在大量相似性，并且“了解指令”的“理解”是分发的，而不是集中的。</p><p> For example, for the purposes of most of the instruction decoder, the SSE2 instructions  ADDPS,  SUBPS,  MULSD and  DIVPD are all pretty much the same thing. They’re FP ALU instructions, they accept the same types of operands, all of which are in the same place.</p><p> 例如，出于大多数指令解码器的目的，SSE2指令ADDPS，SUBP，MUSDD和DIVPD都与之相同。它们是FP ALU指令，它们接受相同类型的操作数，所有这些都在同一个地方。</p><p> Some of these instructions are so similar that they’re almost certain to never fully get “decoded”. For example, for IEEE floats, a subtraction is literally just an addition where the sign bit of the second operand is flipped. If you look at the opcode tab</p><p> 其中一些说明是如此类似的是，它们几乎肯定永远不会完全得到“解码”。例如，对于IEEE浮点数，减法实际上只是添加第二操作数的符号位的添加。如果您查看操作码选项卡</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fgiesen.wordpress.com/2016/08/25/how-many-x86-instructions-are-there/">https://fgiesen.wordpress.com/2016/08/25/how-many-x86-instructions-are-there/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/x86/">#x86</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>