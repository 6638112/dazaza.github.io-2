<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>更喜欢Linux而不是Windows的客观原因</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">更喜欢Linux而不是Windows的客观原因</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-16 07:21:39</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/3b9e4376b8ac7010ce269de6c68d019e.png"><img src="http://img2.diglog.com/img/2020/11/3b9e4376b8ac7010ce269de6c68d019e.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Clichés like these are vague and wishy-washy,and they are founded on anecdotes and hearsay.They cause  endless, unnecessary debates and make a muddle of the facts.</p><p>诸如此类的陈词滥调是含糊其辞的，是建立在轶事和传闻之上的。它们会引起没完没了的、不必要的争论，把事实搞得一团糟。</p><p> It&#39;s easy to opine about one&#39;s preferred operating system,but harder to give objective, concrete examples.</p><p>评论一个人喜欢的操作系统很容易，但给出客观、具体的例子却很难。</p><p> With the caveat that both Windows and Linux are moving targets,this document describes some specific technical reasonsto prefer using Linux as a desktop operating system.</p><p>在警告Windows和Linux都在移动目标的同时，本文档描述了更倾向于使用Linux作为桌面操作系统的一些具体技术原因。</p><p> These reasons are not exhaustive—and not meant to be—but aim to be representative.</p><p>这些理由不是详尽的--也不是故意的--但旨在具有代表性。</p><p>  This document will not cover closed vs. open source development,but will instead focus on functionality.There is plenty of discussionof the advantages and disadvantages of open source elsewhere.</p><p>本文档不会讨论封闭与开放源码的开发，而是将重点放在功能性上。其他地方有很多关于开放源码的优点和缺点的讨论。</p><p> (Besides, what is there to discusswhen we now know that  even Microsoft loves open source?)</p><p>(此外，既然我们现在知道连微软都喜欢开源了，还有什么好讨论的呢？)。</p><p> This discussion will only mention Microsoft and other companiesin so far as their actions are directly relevantto the technically capabilities of Windows and Linux.</p><p>这次讨论只会提到微软和其他公司，只要他们的行为与Windows和Linux的技术能力直接相关。</p><p> (As an aside, Microsoft gets a lot of guff in the open-source world,but its behavior is typical for a corporationwhose a bottom line relies on sales of proprietary software and devices.It&#39;s economics, not malice.)</p><p>(顺便说一句，微软在开源世界里得到了很多废话，但对于一家利润依赖于专有软件和设备销售的公司来说，它的行为是典型的。这是经济上的，而不是恶意的。)</p><p> The discussion is intended to be as accurate as possible,at the cost of possible dryness due to technical detail.</p><p>讨论的目的是尽可能准确，但代价是技术细节可能导致干燥。</p><p> I am most familiar with the Debian-based family of Linux distributions,so my remarks will necessarily touch on these more,but I have tried to include other distributions when possible.</p><p>我最熟悉的是基于Debian的Linux发行版系列，所以我的评论必然会更多地涉及这些发行版，但我已经尝试在可能的情况下包括其他发行版。</p><p> In this document, the term &#34;Linux&#34; is shorthand for the entire distribution,including bootloader, kernel, shell, window manager, package manager, etc.Similarly, the term &#34;Windows&#34;refers to all default components of modern versions of Microsoft Windows NT,including Windows XP, Windows Vista, Windows 7, and Windows 8.</p><p>在本文档中，术语Linux是整个发行版的缩写，包括引导加载程序、内核、外壳、窗口管理器、包管理器等。同样，术语Windows指的是Microsoft Windows NT现代版本的所有默认组件，包括Windows XP、Windows Vista、Windows 7和Windows 8。</p><p> Many of the same arguments in favor of Linuxalso apply to the BSD family of operating systems(and POSIX-compliant operating systems in general),but unfortunately I am not familiar enough with any of themto comment specifically.</p><p>支持Linux的许多相同论点也适用于BSD系列操作系统(以及总体上与POSIX兼容的操作系统)，但不幸的是，我对它们中的任何一个都不够熟悉，无法具体评论。</p><p>   Most people use Windows on the desktop because it&#39;s the default.Few are aware of the benefits of switching to another operating system,and even fewer are willing to put in the effort to do so.</p><p>大多数人在桌面上使用Windows，因为它是默认的。很少有人意识到切换到另一个操作系统的好处，愿意为此付出努力的人就更少了。</p><p> A Windows user interested in trying Linuxwill probably have difficulty finding a coherent reason to do so,since comparisons of operating systemstend to be vague, uninformed, or opinion-based.</p><p>有兴趣尝试Linux的Windows用户可能很难找到一个连贯的理由这样做，因为对操作系统的比较往往是模糊的、不知情的或基于观点的。</p><p> Even people who know and use Linux by choicemay not do a good job of explaining its benefits to their colleaguesespecially without putting down Windows usersor Windows applications in general.</p><p>即使是那些了解并选择使用Linux的人也无法很好地向他们的同事解释它的好处，尤其是在不放下Windows用户或Windows应用程序的情况下。</p><p> Also, there are many open source alternatives to Linux on the desktop,including a binary-compatible clone of Windows called  ReactOS.If it were just a matter of being open source,why bother with the additional effort to learn Linux?</p><p>此外，桌面上还有许多Linux的开源替代品，包括名为ReactOS的Windows的二进制兼容克隆。如果只是开源的问题，为什么要费心去学习Linux呢？</p><p> Even if you don&#39;t use Linux or Windows,it&#39;s useful to know where Linux has an edge,since these issues are relevant to all operating systems.</p><p>即使你不使用Linux或Windows，知道Linux的优势在哪里也是很有用的，因为这些问题与所有操作系统都相关。</p><p> If you are a new Linux user,this document is intended to inform youabout some of the benefits of Linux you may not be aware of,and to dig deeper if you are interested.</p><p>如果您是Linux的新用户，本文档旨在告诉您一些您可能不知道的Linux的好处，如果您感兴趣，还可以深入挖掘。</p><p> If you are an experienced Linux user,this document is a test of the theory that the fastest way to get feedbackis to be publically wrong about something people care about.Corrections and additions are welcome.</p><p>如果你是一名经验丰富的Linux用户，本文档是对这样一种理论的检验，即获得反馈的最快方式是在人们关心的事情上公开犯错。欢迎更正和补充。</p><p>  This document does not claim that Windows is inferior in every way,or even that it is inferior overall.</p><p>本文档并不是说Windows在所有方面都是劣势的，甚至不是说它整体上是劣势的。</p><p> Instead, this is meant to provide insightinto why some people choose to use Linux as a desktop operating system,despite its shortcomings,and possibly to challenge some misconceptionsthat people have about Linux and Windows.</p><p>相反，这是为了让人们了解为什么有些人选择使用Linux作为桌面操作系统，尽管它有缺点，也可能是为了挑战人们对Linux和Windows的一些误解。</p><p> Corrections and additions are, of course, welcome.Windows developers are ones who know the most about its flaws and strengths.</p><p>当然，我们欢迎对其进行修改和添加。Windows开发人员最了解它的缺陷和优点。</p><p> Finally, definitions of better and worse are necessarily subjective,despite the title&#39;s claim of objectivity.You may heartily disagree with substantial parts of what follows,but perhaps it may be useful to you, even so.</p><p>最后，更好和更差的定义必然是主观的，尽管书名声称是客观的。你可能会由衷地不同意下面的大部分内容，但即使如此，它也可能对你有用。</p><p>   This is a list of examples of specific limitationsthat are the result of the Windows kernel or API.</p><p>以下是Windows内核或API导致的特定限制的示例列表。</p><p>    For example,  until Windows 8, desktop versions of Windowscould not boot from a USB.(And while running a live USB of Windows 8,it is still not possible to mount internal hard disks.)</p><p>例如，在Windows 8之前，桌面版本的Windows不能从USB启动。(在运行Windows 8的实时USB时，仍然不能挂载内部硬盘。)。</p><p> The  BartPE LiveCD building programis 3rd party software that will run on any version of Windows,but it is  only able to make a LiveCDfor Windows XP or Windows Server 2003.</p><p>BartPE LiveCD构建程序是第三方软件，可以在任何版本的Windows上运行，但它只能为Windows XP或Windows Server 2003制作LiveCD。</p><p> There is also the  WinBuilder project,which is the closest to a fully-functional LiveCD of modern Windows versions,but installing software and drivers is still sometimes a challenge.</p><p>还有WinBuilder项目，它最接近于现代Windows版本的全功能LiveCD，但安装软件和驱动程序有时仍是一个挑战。</p><p> If the Virtual Machine fails don’t worry too much. Just because the VirtualMachine fails to boot right does not mean your boot media won’t work, I’veseen odd results depending on the amount of memory the VM has and whatdrivers I load.</p><p>如果虚拟机出现故障，也不用太担心。仅仅因为虚拟机无法正确引导并不意味着您的引导介质不能工作，我看到了一些奇怪的结果，这取决于VM拥有的内存量和我加载的驱动程序。</p><p>  The absence of fully functional live versions of Windowsmakes it difficult to use for, e.g,determining if a bug is due to hardware or software problems,recovering data from a machine with filesystem corruption or bad disk sectors,and testing out different versions of an OSwithout making a new hard drive partition.</p><p>由于缺少功能齐全的Windows实时版本，因此很难用于确定错误是由硬件还是软件问题引起的，从文件系统损坏或磁盘扇区损坏的机器恢复数据，以及在不创建新硬盘驱动器分区的情况下测试不同版本的OS。</p><p> Live versions of Linux are full operating systems,able to mount and repartition disks,connect to the internet and run a web browser,and even retain settings and data on the next boot-up(for  persistent live USB flash drives).This makes live versions of Linux useful forrecovering files from damaged hard drives,making bootable backups of an entire drive,scanning a disk for malwarewithout loading a potentially compromised operating system,distinguishing hardware problems from software problems,and other tasks requiring a temporary operating system.</p><p>实时版本的Linux是完整的操作系统，能够挂载和重新分区磁盘、连接到互联网并运行Web浏览器，甚至可以在下次启动时保留设置和数据(对于永久的实时USB闪存驱动器)。这使得实时版本的Linux对于从损坏的硬盘驱动器恢复文件、对整个驱动器进行可引导备份、在不加载潜在受损操作系统的情况下扫描磁盘上的恶意软件、区分硬件问题和软件问题以及其他需要临时操作系统的任务非常有用。</p><p> Some live Linux distributions, such as  Puppy Linux,are lightweight enough that they default to  running from a RAM disk,and consequently have much faster disk I/Othan an OS that must access a spinning hard drive.(This comes at the cost of disk space being limited by RAM.There&#39;s no reason you can&#39;t mount an internal or external driveto store files, though.)</p><p>有些Linux发行版(如Puppy Linux)非常轻量级，它们默认从RAM磁盘运行，因此磁盘I/O比必须访问旋转硬盘的操作系统快得多。(这是以磁盘空间受RAM限制为代价的。不过，没有理由不能挂载内部或外部驱动器来存储文件。)。</p><p> Very little hardware comes with a  desktop version of Linux pre-installed,so live versions of Linux tend to work very well,since that is almost always the way it is installed.</p><p>很少有硬件预装Linux的桌面版本，所以Linux的实时版本往往工作得很好，因为它几乎总是这样安装的。</p><p>   Similar to live booting,Linux is often run as a virtual machine,and consequently it is well-adapted to changes in hardware.</p><p>与实时引导类似，Linux通常作为虚拟机运行，因此它能够很好地适应硬件的变化。</p><p> An existing Linux partition on a physical hard drivecan, with some care, be virtualized and run on another machine,a virtue which Windows does not share.</p><p>物理硬盘上现有的Linux分区可以被虚拟化并在另一台机器上运行，这是Windows所不具备的优点。</p><p> Windows installations, unlike Linux, cannot easily be moved from onehardware to another. This is not just due to Microsoft&#39;s activationmechanism but the fact that the installed kernel and drivers depend on theactual hardware.</p><p>与Linux不同，Windows安装不能轻易地从一个硬件迁移到另一个硬件。这不仅是因为微软的激活机制，而且是因为安装的内核和驱动程序依赖于实际的硬件。</p><p>  The problem lies with Windows, in that its driver settings, particularlyfor storage devices, are not portable. Unless you modify the Windowsregistry to force start storage drivers for both the physical and virtualmachines, you will mostly likely end up with a  0x0000007B STOP bluescreen error each time which will require a restore or modifying theregistry to fix.</p><p>问题出在Windows，因为它的驱动程序设置，特别是存储设备的驱动程序设置，是不可移植的。除非修改Windows注册表以强制启动物理机和虚拟机的存储驱动程序，否则每次都很可能会出现0x0000007B停止蓝屏错误，需要恢复或修改注册表才能修复。</p><p>  It&#39;s even possible to transfer a Linux install to a USB enclosureand boot it directly on another machine of the same architecture,although the kernel will lack proprietary drivers (e.g. some wifi cards).</p><p>尽管内核没有专有驱动程序(例如一些WiFi卡)，但它甚至可以将Linux安装转移到USB机箱，然后直接在同一架构的另一台机器上引导它。</p><p>   Windows path lengths  are limited to 260 characters, including filename.(In practice, it is often more like  199 characters.)This is  not a flaw in NTFS or Windows per se,but in the  non-Unicode version of the Windows API.</p><p>Windows路径长度限制为260个字符，包括文件名。(实际上，它通常更像199个字符。)这不是NTFS或Windows本身的缺陷，而是Windows API的非Unicode版本中的缺陷。</p><p> This problem can be avoided by using Unicode versions of the API calls,but many applications(e.g.  Windows Explorer,  .NET and  consequently Powershell)have not done so.</p><p>这个问题可以通过使用Unicode版本的API调用来避免，但许多应用程序(例如Windows资源管理器、.NET以及随后的PowerShell)都没有这样做。</p><p> Of course, most OS restrictions are  not an issue in well-written software.Maybe Windows paths  are long enough.Is  MAX_PATH an actual problem in real software?</p><p>当然，在编写良好的软件中，大多数操作系统限制都不是问题。也许Windows路径足够长。MAX_PATH在真正的软件中真的存在问题吗？</p><p>   But the bigger issueis that many Windows developers are  so used to  working around the problemthat it has become deeply entrenched and may  never be fixed.</p><p>但更大的问题是，许多Windows开发者太习惯于解决这个问题，以至于这个问题已经根深蒂固，可能永远不会得到解决。</p><p> The Linux kernel does have an adjustable pathname length limit;it&#39;s  4096 chars in typical kernels and filesystems.You can check it by running:</p><p>Linux内核确实有一个可调整的路径名长度限制；它在典型的内核和文件系统中有4096个字符。您可以通过运行以下命令来检查它：</p><p>  However,  this limit is not enforcedby any filesystems that Linux runs on,and consequently some  libc implementationswere for a while  susceptible to buffer overflowwhen trying to resolve canonical file paths.</p><p>但是，Linux在其上运行的任何文件系统都不会强制执行此限制，因此在尝试解析规范文件路径时，一些libc实现一度容易受到缓冲区溢出的影响。</p><p> The 2008 POSIX revision has  addressed the issue, but prior to thisthe Linux kernel had to make non-standard modifications to avoid overflow,and  warned about the problem in the  realpath (3) man pageof the Linux Programmer&#39;s Manual.</p><p>2008年的POSIX修订版已经解决了这个问题，但在此之前，Linux内核不得不进行非标准修改以避免溢出，并在Linux程序员手册的realpath(3)手册页中警告了这个问题。</p><p> This illustrates that while the Linux kernel developersscrupulously avoid breaking external compatibility,they also intentionally expose false assumptions,since false assumptions tend to cause hard-to-fix bugs.This is why Linus Torvalds chose an unusually high timer interrupt frequency for Linux:</p><p>这说明，虽然Linux内核开发者小心翼翼地避免破坏外部兼容性，但他们也故意暴露错误的假设，因为错误的假设往往会导致难以修复的错误。这就是为什么Linus Torvalds为Linux选择了异常高的定时器中断频率：</p><p> I chose 1000 originally partly as a way to make sure that people thatassumed HZ was 100 would get a swift kick in the pants. That meant makinga _big_ change, not a small subtle one. For example, people tend to reactif &#34;uptime&#34; suddenly says the machine has been up for a hundred days (evenif it&#39;s really only been up for ten), but if it is off by just a factor oftwo, it might be overlooked.</p><p>我选择1000的部分原因是为了确保那些认为HZ是100的人会被迅速踢到裤子里。这意味着要做出巨大的改变，而不是微妙的小改变。例如，人们往往会突然说机器已经开机100天了(即使它真的只开机了10天)，但如果它只停机了两倍，这一点可能会被忽视。</p><p>   Linux uses case-sensitive filenamesbecause Unix used case-sensitive filenames.Unix was case-sensitive because Multics was case-sensitive.Multics was case-sensitive because the ASCII standardincluded both an uppercase and a lowercase alphabet.  [1]</p><p>Linux使用区分大小写的文件名，因为Unix使用区分大小写的文件名。Unix区分大小写，因为Multics区分大小写。Multics区分大小写，因为ASCII标准既包括大写字母，也包括小写字母。[1]。</p><p>  Telegraphy codes used uppercase only,or at least did not distinguish upper and lowercase.Even ITA2, an international standard from 1930,used a 5-bit code with a shift to switch between letters and figures,but not upper and lowercase.  [2]Similarly, punched cards used uppercase letters only.</p><p>电报代码只使用大写字母，或者至少不区分大写和小写。即使是1930年的国际标准ITA2，也使用了一个5位代码，可以在字母和数字之间切换，但不能大写和小写。[2]同样，穿孔卡片只使用大写字母。</p><p> Encodings with different bit patterns for uppercase and lowercasehad been proposed as early as 1959,  [3]though they were not widely implemented.For example, the IBM 7030 &#34;Stretch&#34; supercomputer,first installed at Los Alamos National Laboratory in 1961,had an 8-bit encoding that interleaved uppercase and lowercase alphabets. [4]However, the 7030&#39;s character encoding did not catch on.</p><p>早在1959年，人们就提出了大小写不同位模式的编码方案[3]，但并未得到广泛应用。例如，1961年首次安装在洛斯阿拉莫斯国家实验室的IBM7030超级计算机采用的是交错大小写字母的8位编码。[4]然而，7030的字符编码并没有流行起来。</p><p> Early on, ASCII committee concluded that 6-bit encodings (64 bit patterns)were insufficient to include both control characters and special charactersin addition to the required 26 alphabetics and 10 numerics,so they decided to use a 7-bit code.However, ASCII was designed to include a useful 6-bit subset,which could only fit a single alphabet.</p><p>早些时候，ASCII委员会得出结论，6位编码(64位模式)除了需要26个字母和10个数字之外，不足以同时包括控制字符和特殊字符，因此他们决定使用7位编码。然而，ASCII被设计为包括一个有用的6位子集，它只能容纳一个字母表。</p><p> The consideration of a 6-bit, 64-character graphic subset was important tothe standards committee. If the ultimate decision was that columns 6 and 7would be for graphics, then columns 2 through 7 would contain Space, 94graphics, and Delete. But, even with the code providing 94 graphics, amajor assumption of the standards committee was that data processingapplications would, for the foreseeable future, be satisfied with amonocase alphabet (that is, a 64- or less graphic subset) as they had inthe past---that 64-character printers would predominate. So it wasimportant to be able to derive a 64-character, monocase alphabet, graphicsubset from the code by simple, not complex, logic.</p><p>对于标准委员会来说，考虑6位、64字符的图形子集是很重要的。如果最终决定列6和列7用于图形，那么列2到列7将包含空间、94图形和删除。但是，即使代码提供了94个图形，标准委员会的一个主要假设是，在可预见的将来，数据处理应用程序将满足于一个单一的字母表(即64个或更少的图形子集)，就像它们过去所做的那样-64个字符的打印机将占主导地位。因此，能够通过简单(而不是复杂)的逻辑从代码中推导出64个字符的单一字母表图形子集是非常重要的。</p><p> In fact, the some of the committee memberswanted to reserve the remaining space for control characters.</p><p>事实上，一些委员想把剩下的空间留给控制角色。</p><p> The conclusion of the preceding paragraph is based on the assumptionthat two alphabets, small letters and capital letters, would be includedin the 7-bit code and that decision had not yet been made. If thedecision was ultimately made that columns 6 and 7 would would containcontrols, then small letters would not be included in the 7-bit code.  *</p><p>上一段的结论是基于这样的假设，即7位代码中将包括两个字母，即小写字母和大写字母，而这一决定尚未做出。如果最终决定第6列和第7列将包含控件，那么7位代码中将不包含小写字母。*。</p><p> * If the committee did decide for controls in columns 6 and 7, it isstill likely that they would have wanted an alphabet of small letters to beprovided. Presumably, the small letter alphabet would then have beenprovided by a caseshift approach.</p><p>*如果委员会真的决定对第6栏和第7栏进行控制，他们仍然很可能希望提供一个小写字母表。据推测，小写字母表可能是通过替换大小写的方法提供的。</p><p> Though the comittee first formed in 1961,it wasn&#39;t until late 1963that they finally agreed to include a lowercase alphabet,largely because of the influence of theInternational Telegraph and Telephone Consultative Committee (CCITT).</p><p>虽然该委员会最初成立于1961年，但直到1963年末，他们才最终同意采用小写字母，这在很大程度上是由于国际电报和电话咨询委员会(CCITT)的影响。</p><p> At the first meeting of ISO/TC97/SC2 in 1963 October 29-31, a resolutionwas passed that the lower-case alphabet should be assigned tocolumns 6 and 7.</p><p>在1963年10月29-31日召开的ISO/TC97/SC2第一次会议上，通过了一项决议，将小写字母分配到第6列和第7列。</p><p> The ISO proposal, though, did not include the lower case alphabet and thefive accent marks that the CCITT considered essential.</p><p>然而，国际标准化组织的提案没有包括CCITT认为必不可少的小写字母和五个重音符号。</p><p>  It can make filenames more intelligible,such as distinguishing betweenthe abbreviation for United State (&#34;US&#34;)and the first-person plural objective pronoun (&#34;us&#34;)in paths such as  /usr/share/X11/locale/en_US.UTF-8/.</p><p>它可以使文件名更容易理解，例如区分路径/usr/share/X11/Locale/en_US.UTF-8/中的United States缩写(&#34；US&34；)和第一人称复数宾语代词(&#34；us&34；)。</p><p> It also allows more possibilities for filenames,and makes filename comparisons simpler and fasterbecause they don&#39;t have to occasionally convertto uppercase or lowercase.</p><p>它还允许文件名有更多的可能性，并使文件名比较更简单、更快，因为它们不必偶尔转换为大写或小写。</p><p> Bear in mind that it&#39;s MUCH more work for a filesystem to becase-insensitive than -sensitive. A filesystem is case-sensitive bydefault, in the simplest case; it can only be made case-INsensitive througha lot of extra engineering. In UNIX, all the system has to do is sort onthe ASCII values of the first letters of the filenames. In the Mac OS andWindows, the filesystem has to be smart enough to create synonyms ofvarious letters — A for a, and so on — and sort accordingly. That takes aLOT of code. It&#39;s a testament to the completeness of the original Mac OSthat in 1984 this was all handled properly, before Windows even broughtlower-case letters to the PC side.</p><p>请记住，文件系统对大小写不敏感比对大小写敏感的工作要多得多。默认情况下，文件系统区分大小写，在最简单的情况下，只能通过大量额外的工程使其不区分大小写。在UNIX中，系统所要做的就是对文件名的前几个字母的ASCII值进行排序。在Mac OS和Windows中，文件系统必须足够智能，能够创建各种字母的同义词--A代表a，以此类推--并进行相应的排序。这需要大量的代码。1984年，在Windows向PC端提供小写字母之前，所有这些都得到了正确的处理，这证明了最初的Mac OS的完备性。</p><p>  However, there is also no shortage of opinionsthat enforcing filename case-sensitivity-- and even case-sensitivity in general --was a bad decision.  [5]</p><p>然而，也不乏观点认为，强制文件名区分大小写--甚至通常区分大小写--是一个糟糕的决定。[5]。</p><p>   Strictly speaking, modern Windows filenames could be case-sensitive,but they aren&#39;tbecause the  Windows API for opening files  is not case-sensitive,i.e. the  default call to  CreateFiledoes not enable the  FILE_FLAG_POSIX_SEMANTICS option.</p><p>严格地说，现代Windows文件名可能区分大小写，但它们不区分大小写，因为用于打开文件的Windows API不区分大小写，即对CreateFiles的默认调用不会启用FILE_FLAG_POSIX_SEMANTICS选项。</p><p> However, Windows&#39; own NTFS filesystem is  case-preserving.This means that it is possible to mount an NTFS partition with Linuxand make a file called &#34;Myfile.txt&#34; in the same directory as &#34;MYFILE.TXT&#34;,but it will  not be possible to read or modify both of those files,at least not with standard Windows software.</p><p>但是，Windows自己的NTFS文件系统是保留大小写的。这意味着可以使用Linux挂载NTFS分区，并在与MYFILE.TXT&34；相同的目录下创建名为Myfile.txt&34；的文件，但不能读取或修改这两个文件，至少不能使用标准Windows软件读取或修改这两个文件。</p><p> This API behavior exists to maintain compatibility with MS-DOS filesystems.  [7]MS-DOS was built on Tim Paterson&#39;s 86-DOS (released in 1980)and Marc McDonald&#39;s FAT filesystem,which were designed for compatibility with CP/M.  [8]  [9]CP/M was created in 1973 by Gary Kildall,and also used case-insensitive filenames.  [12]</p><p>此API行为的存在是为了维护与MS-DOS文件系统的兼容性。[7]MS-DOS是在Tim Paterson的86-DOS(1980年发布)和Marc McDonald的FAT文件系统上构建的，旨在与CP/M兼容。[8][9]CP/M是由Gary Kildall于1973年创建的，也使用不区分大小写的文件名。[12]</p><p> Lower case ASCII alphabetics are internally translated to uppercase to be consistent with CP/M file and device name conventions.</p><p>小写ASCII字母在内部转换为大写，以符合CP/M文件和设备命名约定。</p><p>  The CP/M manual does not state explicitly why it uses these conventions,but Gary Kildall wrote CP/M on a  DEC  PDP-10 mainframerunning the  TOPS-10 operating systemwhen he was working at Intel.  [10]Consequently, there are many similarities between CP/M and TOPS-10,including filename case-insensitivity.</p><p>CP/M手册没有明确说明使用这些约定的原因，但Gary Kildall在英特尔工作时，在一台运行TOPS-10操作系统的DEC PDP-10上编写了CP/M。[10]因此，CP/M和TOPS-10之间有许多相似之处，包括文件名不区分大小写。</p><p> (It should be noted that CP/M has also been compared to RT-11,a DEC operating system for the PDP-11 minicomputerthat is closely related to TOPS-10,  [11]although the influence may not have been as direct.)</p><p>(应该指出的是，CP/M也与RT-11相提并论，RT-11是一种用于PDP-11小型机的DEC操作系统，与TOPS-10密切相关[11]，尽管其影响可能没有那么直接。)。</p><p> Why did TOPS-10 use case-insensitive names?Because the DEC SIXBIT encoding used for filenameswas optimized for its architecture.</p><p>为什么TOPS-10使用不区分大小写的名称？因为用于文件名的DEC SIXBIT编码针对其架构进行了优化。</p><p> RAD50 was used in FILES-11 and RT-11 disks. It was used to store 3characters in a 16 bit word. SIXBIT was used on TOPS-10 36bit systems tostore 6 characters in a word. It also allowed for a fast file name searchsince the names were all on word boundaries (full filename compair took 2compair, and 1 mask operation 6+3 file names).</p><p>在FILES-11和RT-11磁盘中使用Rad50。它用于存储16位字中的3个字符。在TOPS-10 36位系统上使用SIXBIT在一个字中存储6个字符。它还允许快速搜索文件名，因为所有名称都在单词边界上(完整文件名CompAir需要2compair，1次掩码操作需要6+3个文件名)。</p><p>  (CP/M was written for an eight-bit architecture,which is presumably why it used an 8.3 filenameinstead of a 6.3 filename.)  [13]</p><p>(CP/M是为8位体系结构编写的，这大概就是它使用8.3文件名而不是6.3文件名的原因。)[13]。</p><p> Similarly, the RT-11 didn&#39;t use ASCII for filenames,but rather an encoding called RADIX-50,which helped to save memory.  [14]</p><p>同样，RT-11没有使用ASCII作为文件名，而是使用了一种名为Radix-50的编码，这有助于节省内存。[14]。</p><p> Neither of these encodings are used much anymore,but their case-insensitivity,a useful optimization on 1970s hardware,endures to this day.</p><p>这两种编码都不再经常使用，但它们不区分大小写，这是对20世纪70年代硬件的有用优化，一直延续到今天。</p><p> The lack of agreement on filename case-sensitivity may seem insignificant,but it has caused persistent difficultiesin cross-platform development.  [15]  [16]  [17]</p><p>在文件名区分大小写方面缺乏一致意见似乎无关紧要，但这给跨平台开发带来了持续的困难。[15][16][17]。</p><p> Developers of cross-platform software try to  avoid making assumptions about filename case-sensitivity,but problems of this ilk crop upwhen porting from Windows to Linux or vice-versa.  [18]</p><p>跨平台软件的开发人员试图避免假设文件名区分大小写，但当从Windows移植到Linux或从Linux移植到Windows时，这类问题就会出现。[18]。</p><p>  Unity does not properly run on a case-sensitive file system (which issomething that Unity users have discovered if they’ve tried to install andrun Unity on a case-sensitive HFS+ file system). This is primarily due toUnity’s asset database, and how it stores paths to map them to GUID values.Of course we tried to be smart in the early days, but if you don’t set up away to actually verify that what you’re doing works on a case-sensitivefile system, then it will never fail that some well-intentioned programmerthrows a toLower() in somewhere and ruins the party.</p><p>Unity无法在区分大小写的文件系统上正常运行(Unity用户如果试图在区分大小写的HFS+文件系统上安装和运行Unity，就会发现这一点)。这主要归功于Unity的资产数据库，以及它如何存储将它们映射到GUID值的路径。当然，在早期我们试图变得聪明一些，但如果您没有设置好实际验证您所做的操作在区分大小写的文件系统上是否有效，那么一些好心的程序员在某个地方抛出一个Tolower()并毁掉聚会是不会失败的。</p><p> Everything in Multics is case sensitive; Multics permits use of the fullupper and lower case ASCII character set.</p><p>Multics中的所有内容都区分大小写；Multics允许使用全大写和小写ASCII字符集。</p><p> Multics command names and programming languages use lowercase byconvention, but users are free to use uppercase letters in path names,identifiers, user names, etc.</p><p>多语言命令名和编程语言使用小写旁路约定，但用户可以在路径名、标识符、用户名等中自由使用大写字母。</p><p>    Obviously, BCD had no lower-case characters, and Multics did not use BCDat all, except to output log and crash and tape mount messages from ring0 to the primitive Selectric operator&#39;s console.</p><p>显然，BCD没有小写字符，Multics根本没有使用BCD，只是将日志、崩溃和磁带挂载消息从ring0输出到原始SElectric操作员的控制台。</p><p>  Since the Multics file system distinguished between upper and lower case,external names had to be case sensitive, and without much discussion wechose to have all variable names be case sensitive.</p><p>由于Multics文件系统区分大小写，外部名称必须区分大小写，并且在没有太多讨论的情况下，我们选择让所有变量名称区分大小写。</p><p>  Simple pattern of correspondence should exist between codes assigned toupper and lower case alphabetic characters.</p><p>分配给触摸者的代码和小写字母字符之间应该存在简单的对应模式。</p><p> From page 20 of &#34;A proposal for a generalized card code for 256 characters&#34;,Communications of the ACM, Volume 2 Issue 9, Sept. 1959.</p><p>摘自第#34；页《256个字符的通用卡片码的建议》，《ACM通讯》，第2卷，第9期，9月1日。1959年。</p><p>  Mac ＆ Windows users have to have filenames read to them over the phoneby support techs. They have to be able to write little sticky notes totheir mothers about how to open up the mail program, without worryingabout how the filenames are capitalized. Haven&#39;t you ever fumed over aURL with initial-caps in the folder names in the path, having to fiddlewith capitalization until you get a response that&#39;s anything but a 404?Haven&#39;t you ever been secretly pleased that e-mail addresses aren&#39;tcase-sensitive?</p><p>Mac和Windows用户必须让技术支持人员通过电话向他们朗读文件名。他们必须能够给他们的母亲写一些关于如何打开邮件程序的便条，而不用担心文件名是如何大写的。难道你从来没有对路径中文件夹名称首字母大写的URL感到恼火吗？在得到一个绝对不是404个避风港的回复之前，你难道没有因为电子邮件地址区分大小写而暗地里感到高兴吗？</p><p>  Anecdotally, case sensitivity in programs is known to be error-prone forboth beginners and experienced users. Bob Frankston, a Multics alumnusand the co-inventor of VisiCalc, once said it was the biggest mistakethat Multics had inflicted on the world.</p><p>众所周知，无论是初学者还是有经验的用户，程序中区分大小写都很容易出错。Bob Frankston是Multics的校友，也是VisiCalc的共同发明人，他曾经说过这是Multics给世界造成的最大错误。</p><p>  One of the most pernicious problems with C-based languages is thatthey&#39;re case-sensitive. While this decision may have made sense in 1972when the language was created, one wonders why the sins of Kernighan andRitchie have been blindly perpetuated for the last thirty-three years.</p><p>基于C的语言最有害的问题之一是它们区分大小写。虽然这个决定在1972年这种语言诞生的时候可能是有意义的，但人们想知道为什么克奈根和里奇的罪行在过去的33年里一直被盲目地延续下去。</p><p>  Unless you have extremely compelling reasons to make somethingcase-sensitive, case insensitivity is a much more human being friendlydesign choice. Designing software that&#39;s easier for machines isquestionable at best.</p><p>除非你有非常令人信服的理由让某些东西区分大小写，否则不区分大小写是一个更人性化的设计选择。设计对机器来说更容易的软件充其量也是有问题的。</p><p>  There is no longer any excuse for making humans learn and handle thequirks of the way computers store upper- and lower-case characters.Instead, software should handle the quirks of human language.</p><p>让人类学习和处理计算机存储大小写字符的方式不再有任何借口。取而代之的是，软件应该处理人类语言的奇特之处。</p><p>  Since it appears to have manifested out of opinion rather thannecessity, it could be said case-sensitivity is the worst way thatmodern technology sucks.</p><p>既然它似乎是出于观点而不是必要性的表现，可以说区分大小写是现代技术最糟糕的表现方式。</p><p>  This is really stupid, it causes a ton of problems and there is nolonger any good reason to have case sensitivity in </p><p>这真的很愚蠢，它会导致大量的问题，而且再也没有什么好的理由来区分大小写了。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/nbeaver/why-linux-is-better">https://github.com/nbeaver/why-linux-is-better</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/喜欢/">#喜欢</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/reasons/">#reasons</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1035136.html"><img src="http://img2.diglog.com/img/2020/11/thumb_33afbd1c2fd02e0ab550abf151ef6af9.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035136.html">万劫不复-适用于DOS 6和Windows 95至Windows 10的单个EXE</a></div><span class="my_story_list_date">2020-11-14 23:44</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034700.html"><img src="http://img2.diglog.com/img/2020/11/thumb_d353fde42d10c082b8b3a6b01c748198.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034700.html">Windows终端预览版1.5版</a></div><span class="my_story_list_date">2020-11-12 9:58</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033938.html"><img src="http://img2.diglog.com/img/2020/11/thumb_65fe1ac55cb547c52b4d5798dd332b64.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033938.html">Windows中不可原谅的不安全感</a></div><span class="my_story_list_date">2020-11-9 6:29</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033802.html"><img src="http://img2.diglog.com/img/2020/11/thumb_dc1fad55ea711afc952976f650d78b78.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033802.html">WinApps：在Linux上运行Windows应用程序，就像它们是原生操作系统的一部分一样</a></div><span class="my_story_list_date">2020-11-8 12:57</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>