<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用TLS转到HTTPS服务器 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">使用TLS转到HTTPS服务器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-11 23:53:44</div><div class="page_narrow text-break page_content"><p>此帖子是运行HTTPS服务器和客户端的基本介绍TLS。它假设一些熟悉公钥加密。随时可以免费攻击我的早期关于RSA和Diffie-Hellman密钥交换的帖子; TLS USESTHE椭圆曲线版本的Diffie-Hellman。我赢得了＆＃39; T＆＃39; Protocol本身如何详细介绍，但如果你＆＃39;遗嘱感兴趣，我建议在这个主题上toread。</p><p>  TLS（传输层安全性）是一种协议，该协议旨在以防止窃听，TamperingAnd伪造的方式启用Internet的客户端 -  ServerConcunication。它＆＃39;在RFC 8446中描述。</p><p> TLS依赖于最先进的密码学;这也是为什么它＆＃39; S推荐最新版本的TLS可用的TLS，这是1.3（截至2021年初）.TLS协议的重新分析潜在的不安全的角落案例，删除了eChryption算法，并且通常尝试更多地使协议更新安全的。</p><p> 当客户端连接到具有普通HTTP的服务器时，它开始在完成标准TCP握手（SYN-＆GT; SYN-ACK  - ＆GT）后立即将包裹在TCP数据包中的PLAINTEXTDATA发送。使用TLS，情况有点复杂[1]：</p><p>  完成TCP握手后，服务器和客户端执行TLShandshake以同意共享秘密，＆＃39;唯一的独特秘密（在此目的）。然后使用此共享秘密来安全地加密在它们之间交换的Alldata。虽然有很多事情在这里，它＆＃39; ssomething tls层的图层为我们。我们只需正确设置TLS服务器（或客户）; HTTP和HTTPS服务器之间的实际差异在GOI最小。</p><p> 在我们跳转到展示如何设置HTTPS服务器的代码之前，请展示证书。在上图中，您＆＃39; ll注意到服务器将证书发送给客户端作为其第一个serverhello消息的一部分。正式这些称为X.509证书，由RFC 5280描述。</p><p> 公钥加密播放TLS的主要部分。证书是将服务器包装的标准道，以及公钥，以及其身份和签名BYA可信任权限（通常是证书颁发机构）。假设您想要ToTalk to https://bigbank.com;你怎么知道它＆＃39;真正的大银行那里要求你的密码？如果有人坐在电缆连接，拦截所有流量并假装是大银行（古典Mitm-Man-In-中攻击）的话。 </p><p>证书流程旨在防止这种情况。当您的客户端＆＃39; sunderlying tls实现访问https://bigbank.com，它希望Bigbank＆＃39; s证书与公钥，由可信证书颁发机构（CA）签名。证书签名可以形成一棵树（由a由b签名的bank＆＃39; s键，由c等），但在链条的末尾，它弥漫了您的客户信赖的一些证书颁发机构。现代浏览器的alist of Pre Trusted CA（以及他们自己的证书）内置。由于yourcable snooper无法伪造可信证书＆＃39; s签名，他们不能签名大银行。自证书携带银行＆＃39; s合法的publickey，当您使用它来生成您的共享秘密时，银行将是ableto解密。</p><p> 对于本地测试，它往往能够与自我遗传的人一起工作非常有用。自签名证书是一些实体E与公钥P的证书，但关键字不由已知证书颁发机构签名，并通过P本身绑定。虽然自签名证书有一些额外的用途，但我们＆＃39; LL专注于他们在此测试中的测试。</p><p> Go＆＃39; S标准库对与Crypto，TLS和证书相关的所有内容具有出色的支持。 Let＆＃39; S看如何在GO上生成自签名证书！</p><p> privatekey，错误：= ecdsa。 Generatekey（椭圆形。P256（），兰德。如果err！= nil {log。 Fatalf（＆＃34;未能生成私钥：％v＆＃34;，err）}</p><p> 此代码使用Crypto / ECDSA，Crypto / Elliptic和Crypto / RandPackages使用P-256椭圆曲线生成新的密钥对[2]，这是TLS 1.3中的允许曲线之一。</p><p>  serialnumberlimit：=新（大。int）。 LSH（大。纽丁（1），128）SerialNumber，Err：= Rand。 int（rand。读者，serialnumberlimit）如果err！= nil {log。 Fatalf（＆＃34;未能生成序列号：％v＆＃34;，err）}模板：= x509。证书{SerialNumber：SerialNumber，主题：PKIX。姓名{组织：[]字符串{＆＃34;我的corp＆＃34; }，}，dnsnames：[]字符串{＆＃34; localhost＆＃34; }，ofebreor：时间。现在（），未出现：时间。现在 （）。添加（3 *时间。小时），keyusage：x509。 KeyUsagedIgitalSignature，ExtKeyusage：[] X509。 extkeyusage {x509。 extkeyusageserverauth}，BasicConstraintSvalid：True，}</p><p> 每个证书都需要一个唯一的序列号;通常，认证授权将使这些数据库存储在某些数据库中，但对于我们的本地需求，Arandom 128位数将执行。这就是Snippetare的前几行。 </p><p>接下来是x509.certificate模板。有关菲尔德的意思，请参阅Crypto / X509软件包文档以及RFC 5280.WE＆＃39; LL只是注意到证书有效期为3小时，并且仅适用于LocalHost域。</p><p>  derbytes，err：= x509。 CreateCertificate（Rand。读者，＆amp;模板，＆amp;模板，＆amp; private。Publickey，privateKey）如果err！= nil {log。 Fatalf（＆＃34;未能创建证书：％v＆＃34;，err）}</p><p> 该证书是从模板创建的，并与私钥键签名＆＃39; ve先前生成。请注意，＆amp;模板在CreateCertificate的模板和父参数中传递。后者是让这个证书自签名的。</p><p> 这是它，我们拥有我们的服务器及其证书的私钥（其中公钥，以及其他信息）。现在留下的所有＆＃39;现在将它们分为文件。一，证书：</p><p> pemcert：= PEM。 EncopeTomeMory（＆amp; pem。块{类型：＆＃34;证书＆＃34;，字节：derbytes}）如果pemcert == nil {log。致命（＆＃34;未能将证书编码为PEM＆＃34;）}如果ERR：= OS。 writefile（＆＃34; cert.pem＆＃34;，pemcert，0644）; err！= nil {log。致命（错误）}日志。打印（＆＃34;写ict.pem \ n＆＃34;）</p><p>  privbytes，err：= x509。 Marshalpkcs8privatekey（privateKey）如果err！= nil {log。 FATALF（＆＃34;无法进行编组私钥：％v＆＃34;，err）} pemkey：= pem。 EncodeTomeMory（＆amp; PEM。块{类型：＆＃34;私钥＆＃34;，字节：bytes：privbytes}）如果pemkey == nil {log。致命（＆＃34;未能对PEM＆＃34编码键进行键，如果err：=操作系统。 writefile（＆＃34; key.pem＆＃34;，pemkey，0600）; err！= nil {log。致命（错误）}日志。打印（＆＃34;写key.pem \ n＆＃34;）</p><p> 我们将证书和密钥序列化为PEM文件，它看起来像这样（对于证书）： </p><p>如果你有没有设置SSH键，则格式应该看起来很熟悉。我们可以使用openssl命令行工具来显示其内容：</p><p> $ openssl x509 -in cert.pem -textCertificate：数据：版本：3（0x2）序列号：B0：42：06：02：E1：0F：52：3F：E1：2D：1F：45：9B：FA： C9：F7签名算法：ECDSA-WITH-SHA256发行者：O =我的公司有效性不是之前：3月27日14:25:49 2021 GMT不是以下：3月27日17:25:49 2021 GMT主题：o =我的CORP主题公众关键信息：公钥算法：ID-ECPUBLICKEY公钥：（256位）酒吧：04：9F：C0：D4：A2：7C：1D：8B：58：37：9B：EB：15：00：59：59：59： BC：27：05：0D：AB：69：24：13：AA：AA：5A：5A：47：50：B5：78：48：B2：E9：C8：2A：52：28：8E：96：是： 23：50：30：E2：14：29：72：F8：04：BD：A4：D3：5E：F2：8E：B7：FC：66：9B：FF：DF：1D：C0：53：50Asn1 oid：prime256v1 nist曲线：p-256 x509v3扩展：x509v3键使用：x509v3键使用：关键数字签名x509v3扩展键使用：tls web服务器身份验证x509v3基本约束：严重ca：false x509v3主题备用名称：dns：localhost签名算法：ECDSA -SHA256 30：45：02：20：62：52：58：18：8C：12：BC：0F：80：9A：C1：DE：F0：FD：F8：07：9F：A1：95：F5： 84：2B：8F：A4：06：6C：9D：27：AE：57：25：93：02：21：00：B3：83：96 ：A2：85：45：E1：ED：19：B4：2F：52：B7：26：B1：BB：79：1B：93：B8：54：A4：1E：80：21：CE：4E：1C ：CB：A1：6A：7D</p><p> 现在我们在手中拥有证书和私钥，我们已准备好运行ANHTTPS服务器！再次，标准库使其非常容易，虽然它＆＃39;类似提到安全性是一个非常棘手的问题。在将您的服务器暴露给公共互联网之前，请考虑与安全工程交流最佳实践以及要知道的配置选项的咨询[3]。</p><p>  func main（）{addr：=标志。字符串（＆＃34; addr＆＃34;，＆＃34;：4000＆＃34;，＆＃34; https网络地址＆＃34;）certfile：=标志。字符串（＆＃34; certfile＆＃34;，＆＃34; cert.pem＆＃34;，＆＃34;证书pem文件＆＃34;）keyfile：=标志。字符串（＆＃34; keyfile＆＃34;，＆＃34; key.pem＆＃34;，＆＃34;关键pem文件＆＃34;）标志。 parse（）mux：= http。 newservemux（）mux。 hangefunc（＆＃34; /＆＃34; func（wthitch。remptingwriter，req * http.receque）{如果需要。url。路径！=＆＃34; /＆＃34; {http。notfound（w， req）return} fmt。fpptf（w，＆＃34;自豪地与go和https！＆＃34;）}）srv：=＆amp; http。服务器{addr：* addr，handler：mux，tlsconfig：＆amp; TLS。配置{Minversion：TLS。 VersionTLS13，PreferSerciphersuites：True，}，}日志。 Printf（＆＃34;％s＆＃34上的启动服务器;，* addr）err：= srv。 listendservetls（* certfile，* keyfile）日志。致命（错误）}</p><p> 它在根路径上为单个处理程序提供服务。有趣的部分是Thetl配置，以及ListendServetls调用，它将路径带到证书文件和私钥文件（以PEM格式为单位，刚刚为我们生成的。 TLS配置有许多可能的字段;这里，我选择了一个相对严格的迫使TLS 1.3的协议.TLS 1.3附带了强有力的安全性，所以这是一个很好的选择如果您可以确保所有客户都了解此版本（并且在2021年，他们应该！）</p><p> 来自普通HTTP服务器的差异不到10行代码！服务器＆＃39; s代码（特定路由的处理程序）完全忘记了禁止的协议，并赢得了＆＃39; t的变化。</p><p> 使用此服务器本地运行（默认为端口4000上），ChromeWill最初在访问它时最初是Balk： </p><p>默认情况下，＆＃39; s是因为Web浏览器不会接受一个自映号的自映号。如上所述，浏览器附带一个硬编码的Casthey信任列表，我们的自签名证书显然不是其中之一。 WeCan仍然通过单击高级然后允许Chromoco继续进行服务器，明确接受风险。然后它将向我们展示网站，尽管勉强（带红色＆＃34;不可求和＃34;登录地址栏）。</p><p>  $ curl -lv https：// localhost：4000 *尝试127.0.0.1：4000...* tcp_nodelay set *连接到localhost（127.0.0.1）端口4000（＃0）* ALPN，提供H2 * ALPN，提供HTTP / 1.1 *成功设置证书验证位置：* cafile：/etc/sl/certs/ca-certificates.crt capath：/ etc / ssl / certs * tlsv1.3（Out），TLS握手，客户端Hello（1）：* TLSv1 .3（in），tls握手，服务器hello（2）：* tlsv1.3（in），tls握手，加密扩展（8）：* tlsv1.3（in），tls握手，证书（11）：* tlsv1 .3（OUT），TLS警报，UNKNOWN CA（560）：* SSL证书问题：无法获取本地发行人证书*结束连接0Curl：（60）SSL证书问题：无法在此处获取本地发行者认证信息详细信息：https：/ /curl.haxx.se/docs/slcerts.htmlcurl无法验证服务器的合法性，因此可以不会建立到它的安全连接。要了解有关此情况的更多信息，请访问它，请访问上面提到的网页。</p><p> 通过阅读文档，我们可以发现可以使卷曲信任我们的服务器，并将其提供给服务器和＃39; s证书到--cacert标志。如果我们试试：</p><p> $ curl -lv --cacert＆lt; path / to / cert.pem＆gt; https：// localhost：4000 *尝试127.0.0.1:4000...* tcp_nodelay设置*连接到localhost（127.0.0.1）端口4000（＃0）* ALPN，提供H2 * ALPN，提供HTTP / 1.1 *成功设置证书验证位置：* cafile：/ home/eliben/eli/private-code-for-blog/2021/tls/cert.pem capath：/ etc / ssl / certs * tlsv1.3（出），tls握手，客户招呼（1）：* TLSV1.3（IN），TLS握手，服务器Hello（2）：* TLSv1.3（IN），TLS握手，加密扩展（8）：* TLSv1.3（IN），TLS握手，证书（11）：* tlsv1.3（in），tls握手，证书验证（15）：* tlsv1.3（in），tls握手，完成（20）：* tlsv1.3（out），tls更改密码，更改密码规格（1）：* TLSv1.3（OUT），TLS握手，完成（20）：* SSL连接使用TLSv1.3 / TLS_AES_128_GCM_SHA256 * ALPN，服务器被接受使用H2 *服务器证书：*主题：o =我的corp *开始日期：3月29日13:30:25 2021 GMT *过期日期：3月29日16:30:25 2021 GMT * SoberAstname：主机＆＃34; localhost＆＃34;匹配的证书＆＃39; s＆＃34; localhost＆＃34; *发行人：o = my corp * ssl证书验证确定。*使用http2，服务器支持多用途*连接状态已更改（HTTP / 2确认）*复制http / 2在升级后流缓冲区中的数据流缓冲区：LEN = 0 *使用流ID：1（简易处理0x557103006E10）＆gt; get / http / 2＆gt;主持人：localhost：4000＆gt;用户代理：CURL / 7.68.0＆gt;接受：* / *＆gt; * tlsv1.3（in），tls握手，newsession票（4）：*连接状态已更改（max_concurrent_streams == 250）！＆lt; http / 2 200＆lt;内容类型：文本/平原; charset = UTF-8＆lt;内容长度：33＆lt;日期：Mon，29 Mar 2021 3月29日13:31:34 GMT＆lt; *连接＃0到主机localhost左转and https！</p><p>  我们还可以使用常用的自定义HTTPS客户端与我们的服务器交谈。这里＆＃39;代码：</p><p> func main（）{addr：=标志。字符串（＆＃34; addr＆＃34;，＆＃34; localhost：4000＆＃34;，＆＃34; https服务器地址＆＃34;）certfile：=标志。字符串（＆＃34; certfile＆＃34;，＆＃34; cert.pem＆＃34;，＆＃34;服务器证书＆＃34;）标志。 parse（）cert，err：=操作系统。 ReadFile（* Certfile）如果err！= nil {log。致命（错误）} certpool：= x509。 newcertpool（）如果确定：= certpool。 Appendcertsfrompem（证书）; ！！好的{log。 Fatalf（＆＃34;无法解析％s＆＃34;，* certfile）}客户端：=＆amp; http。客户{Transport：＆amp; http。运输{tlsclientconfig：＆amp; TLS。配置{rootcas：certpool，}，}，} r，err：= client。获取（＆＃34; https：//＆＃34; + * addr）如果err！= nil {log。致命（错误）}推迟r。身体 。关闭（）HTML，ERR：= IO。如果err！= nil {log。 FAGAL（ERR）} FMT。 Printf（＆＃34;％v \ n＆＃34;，r。状态）fmt。 printf（字符串（html））}</p><p> 与标准HTTP客户端不同的唯一部分是TLSSetup。重要位是设置TLS.config结构的rootcas字段。这是告诉我们客户昏昏欲睡的证书。 </p><p>您可能不知道Go附带一个工具，可以在标准安装中生成自签名状态证书。如果您有Go SimiteAt / USR / Local / Go，则可以使用以下工具运行：</p><p>  通常，它完成了与ThisPost中的第一个代码片段相同的目标，而我的代码段对其进行了一些有关的决策，则将Generate_Cert配置有关标志并支持几个选项。</p><p> 正如我们所看到的，虽然自签名证书可以用于测试，但他们＆＃39;重新判断所有情景。例如，它难以使浏览器Trustthem＆＃39;即使那么用户体验也不完全复制＆＃34;现实世界＆＃34;一个。</p><p> 生成用于测试的本地证书的另一个选项是MKCert工具。它创建了一个LocalCertificate权限（CA），并将其添加到您的系统＆＃39; S受信任的CAS的可信列表。然后，为您生成由此权限签名的证书，因此在浏览器的威胁中，他们＆＃39;重新获得完全信任。</p><p> 如果我们使用MKCert生成的证书/键运行我们的简单HTTPS服务器，Chrome将愉快地访问它而不进行警告;我们还可以在开发人员工具的“安全”选项卡中进行详细信息：</p><p>  卷曲还将成功联系服务器而无需CACERT标志，因为它已经检查了系统＆＃39; S值得信赖的CAS。</p><p> 如果您＆＃39;重新查找真实证书，Let＆＃39; S加密当然是NationalOption，使用Certbot客户端或某些内容。在Go中，像CertMagic这样的图书馆可以自动化与服务器加密的交互和＃39; s加密。 </p><p>到目前为止我们看到的例子是我们看到的服务器向客户提供了（CA-签名的）证书，以证明服务器合法地索赔者（例如您的银行＆＃39; s网站，在您同意提供之前你的密码）。</p><p> 这个想法很容易扩展到相互身份验证，客户端也是签名证书以证明其身份。在TLS的世界中，这种ISCalled MTLS（用于相互TLS），并且在许多设置中都有用的是，有时候服务必须安全地互相通信。公共keycrypto通常被认为比密码更安全。</p><p> 这里＆＃39; s具有客户端身份验证的简单HTTPS服务器。从早期的HTTPS服务器突出显示的线条：</p><p> func main（）{addr：=标志。字符串（＆＃34; addr＆＃34;，＆＃34;：4000＆＃34;，＆＃34; https网络地址＆＃34;）certfile：=标志。字符串（＆＃34; certfile＆＃34;，＆＃34; cert.pem＆＃34;，＆＃34;证书pem文件＆＃34;）keyfile：=标志。字符串（＆＃34; keyfile＆＃34;，＆＃34; key.pem＆＃34;，＆＃34; key pem文件＆＃34;）clientCertfile：=标志。字符串（＆＃34; clientcert＆＃34;，＆＃34; clientcert.pem＆＃34;，＆＃34;客户身份验证和＃34的证书pem;）标志。 parse（）mux：= http。 newservemux（）mux。 hangefunc（＆＃34; /＆＃34; func（wthitch。remptingwriter，req * http.receque）{如果需要。url。路径！=＆＃34; /＆＃34; {http。notfound（w， REQ）返回} FMT。FPRINGF（W，＆＃34;自豪地与GO和HTTPS服务！＆＃34;）}）//受信任的客户证书。 ClientCert，Err：= OS。 ReadFile（* ClientCertFile）如果Err！= nil {log。致命（错误）} clientCertPool：= x509。 newcertpool（）clientcertpool。 Appendcertsfrompem（ClientCert）SRV：=＆amp; http。服务器{addr：* addr，handler：mux，tlsconfig：＆amp; TLS。配置{Minversion：TLS。 VersionTLS13，PreferServiphersuites：True，ClientCas：ClientCertPool，ClientAuth：TLS。 REALEANDVERIFYCLIENTCERT，}，}日志。 Printf（＆＃34;在％s＆＃34上启动服务器;，* addr）err = srv。 listendservetls（* certfile，* keyfile）日志。致命（错误）}</p><p> 这些变化几乎是什么＆＃39; d期待;除了设置Itnown证书，键和TLS Config之外，服务器还加载客户端证书，并支持TLSConfig以信任它。当然，这也可以是签署客户证书的本地受信任的CA的证书。</p><p> 这是一个HTTPS客户端，它在连接到Aserver时攻击自己;再次，从前（非MTLS）客户端更改的行是highlighted：</p><p> func main（）{addr：=标志。字符串（＆＃34; addr＆＃34;，＆＃34; localhost：4000＆＃34;，＆＃34; https服务器地址＆＃34;）certfile：=标志。字符串（＆＃34; certfile＆＃34;，＆＃34; cert.pem＆＃34;，＆＃34;服务器证书＆＃34;）clientCertfile：=标志。字符串（＆＃34; clientcert＆＃34;，＆＃34; clientcert.pem＆＃34;，＆＃34;客户端＆＃34的证书pem; clientKeyFile：=标志。字符串（＆＃34; clientkey＆＃34;，＆＃34; clientkey.pem＆＃34;，＆＃34;客户端＆＃34的关键pem; parse（）//加载我们的客户端证书和密钥。 ClientCert，Err：= TLS。 loadx509keypair（* clientcertfile，* clientKeyfile）如果err！= nil {log。致命（错误）} //受信任的服务器证书。 CERT，ERR：= OS。 ReadFile（* Certfile）如果err！= nil {log。致命的 （ </p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://eli.thegreenplace.net/2021/go-https-servers-with-tls/">https://eli.thegreenplace.net/2021/go-https-servers-with-tls/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/tls/">#tls</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/servers/">#servers</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/证书/">#证书</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1057632.html"><img src="http://img2.diglog.com/img/2021/4/thumb_4942344c5e5eba2b63948d5800e01e7b.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1057632.html">TLS掌握 </a></div><span class="my_story_list_date">2021-4-11 20:14</span></div><div class="col-sm"><div><a target="_blank" href="/story/1047324.html"><img src="http://img2.diglog.com/img/2021/2/thumb_3a1e7bf200479f8190c7d627b2637e27.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1047324.html">“扩展随机”的奇怪故事 </a></div><span class="my_story_list_date">2021-2-6 22:58</span></div><div class="col-sm"><div><a target="_blank" href="/story/1047114.html"><img src="http://img2.diglog.com/img/2021/2/thumb_e0786af6f999c11d16f5c5415b86d2aa.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1047114.html">Signal的TLS代理无法进行探测 </a></div><span class="my_story_list_date">2021-2-6 19:59</span></div><div class="col-sm"><div><a target="_blank" href="/story/1018669.html"><img src="http://img.diglog.com/img/2020/8/thumb_dacd258d21013f8eb89b7fc2146fec28.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1018669.html">加州在TLS证书到期后统计不到新冠肺炎的案件</a></div><span class="my_story_list_date">2020-8-17 23:28</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>