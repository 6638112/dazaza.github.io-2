<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>您想了解的有关终端的所有信息(2018)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">您想了解的有关终端的所有信息(2018)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-09-11 21:26:38</div><div class="page_narrow text-break page_content"><p>所以这里是一个关于ANSI转义代码和终端控制的简短教程，因为你们非利士人不会停止使用ncurse，哦，我的上帝，为什么我们还在使用ncurses？这他妈的已经是二十一世纪了。</p><p>终端仿真器处理颜色和光标形状等奇特东西的方式并不是某种神秘的、不透明的黑匣子，您只能通过库才能访问它。访问这些功能实际上非常简单；甚至可以将它们硬编码到文本文件中，并用cat或更少的代码显示。或者甚至卷曲！实现这一点的方法是使用一种称为ANSI转义序列的方法。</p><p>终端中几乎所有的UI更改都是通过带内信令完成的。这些信号由ASCII/UTF-8字符&lt;ESC&gt;(0x1B或27)触发。它与您按键盘上的Esc键或涉及Alt键的键序列时发送到终端的&lt;Esc&gt;字符相同。(例如，键入将非常快速地连续发送字符；这就是为什么在您按下退出键之后，您会注意到某些终端程序会出现延迟-它正在等待尝试确定用户是按Escape键还是按Alt键和弦。)。</p><p>对于这些转义，我们能做的最简单的事情就是将文本设置为粗体(或明亮)。为此，我们向终端发送&lt;Esc&gt;字符，后跟[1M。[是向终端指示我们要发送的转义类型的字符，1表示粗体/明亮模式，m是格式化转义的控制字符。</p><p>在此转义序列之后发送的所有文本都将是粗体的，直到我们再次显式地将其关闭(即使您的程序终止)。有两种方法可以关闭明亮模式：完全清除格式化，使用不带参数或参数0的m格式命令，或者更具体地说，使用21m命令清除粗体位。(您会注意到，通常可以通过在同一数字前面加上2来关闭模式。)。</p><p>#include&lt；unistd.h&gt；#定义szstr(Str)str，sizeof(Str)int main(){write(1，szstr(&#34；纯文本-\x1b[1mboltext\x1b[0m-纯文本&#34；))；}此处的\x1b转义是将十六进制字符0x1B(&lt;Esc&gt;)插入字符串的C字符串转义。如果你不习惯于阅读带有显式转义的源代码，它就有点难看和不可读。不过，你可以通过几个定义让事情变得不那么可怕：</p><p>#include&lt；unistd.h&gt；#定义szstr(Str)str，sizeof(Str)#定义纯文字&#34；0&#34；/*或&#34；&#34；*/#定义无&#34；2&#34；#定义亮线&#34；1&#34；#定义暗&#34；2&#34；#定义斜体&#34；3&#34；#定义下划线&#34；4&。#DEFINE WITH&#34；；&#34；#DEFINE ANSI_ESC&#34；\x1b&#34；#DEFINE FMT(STYLE)ANSI_ESC&#34；[&#34；STYLE&#34；m&#34；INT Main(){WRITE(1，SZSTR(&#34；纯文本-&#34；FMT(BIGHT)&#34；BIGHT TEXT&#34；FMT(NOW BIGHT)&#34；-&#34；FMT(NOW BIGHT)&#34；-&#34；FMT(BIGHT)&#34。FMT(无暗色)&#34；-&#34；FMT(斜体)&#34；斜体文本&#34；FMT(无斜体)&#34；-&#34；FMT(反转)&#34；反转视频&#34；FMT(纯色)&#34；-&#34；FMT(下划线)&#34；带下划线文本&#34；FMT(无下划线))；}这种方法的美妙之处在于，所有正确的序列都是在编译时生成的，这意味着编译器会将所有这些都转换为使用原始转义进行插值的单个字符串。它为编码器提供了更多的可读性，而对最终用户来说是零成本。</p><p>但是等一下，那个分号是从哪里来的？结果是，ANSI转义代码允许您为每个序列指定多个格式。您可以用；分隔每个命令。这将允许我们编写像fmt这样的格式化命令(用明亮的下划线，不加斜体)，它在编译时转换为\x1b[4；1；23m。</p><p>当然，能够设置文本样式是远远不够的。我们还需要能够给它上色。颜色命令有两个组成部分：我们正在尝试更改的颜色以及我们要将其更改为什么颜色。前景和背景都可以单独指定颜色-无论Ncurses希望您相信什么，您都不必为要使用的每个前景-背景对定义颜色对。(#34；&#34；&#34；&#34；&#34；&#34；##34；&#34；##34；&#34；##34；##34；&#34；##34；##34；&#34；##34；&#34；)。这是一个荒谬的陈词滥调，他妈的21世纪的任何人都不应该受到限制。</p><p>要定位前景，我们发送字符3表示正常颜色或发送9表示明亮颜色；要定位背景，我们发送4表示正常或10表示明亮。然后是选择传统8种终端颜色之一的色码。</p><p>请注意，这里的明亮模式与我们前面提到的明亮模式既有相同之处，也有不同之处。在打开亮色模式时，如果将其设置为传统的8种颜色中的一种，则会自动将文本转换为亮色。如果将亮色设置为9或10，则不会自动将文本设置为粗体。</p><p>#include&lt；unistd.h&gt；#定义szstr(Str)str，sizeof(Str)#定义FG&#34；3&#34；#定义br_fg&#34；9&#34；#定义bg&#34；4&#34；#定义br_bg&#34；10&#34；#定义&#34；；&#34；#定义纯文本&#34；&#34；#定义黑色&#。#定义绿色&#34；2&#34；#定义黄色&#34；3&#34；#定义蓝色&#34；4&#34；#定义洋红色&#34；5&#34；#定义青色&#34；6&#34；#定义白色&#34；7&#34；#定义ansi_esc&#34；\x1b&#34；#定义fmt(Style)ansi_esc&#34；[&#34；style&#34；Int main(){write(1，szstr(&#34；纯文本-&#34；fmt(FG蓝)&#34；蓝色文本&#34；fmt(纯)&#34；-&#34；fmt(br_fg蓝)&#34；亮蓝色文本&#34；fmt(纯)&#34；-&#34；fmt(br_bg红)&#34；亮红色背景&#34；fmt(纯)&#34。Fmt(带有br_bg洋红色的fg红色)&#34；可怕的红色文本&#34；fmt(普通))；}当我们调用fmt(带有br_bg洋红色的fg红色)时，编译器会将其转换为命令字符串\x1b[31；105m。请注意，我们正在使用FMT(普通)(\x1b[m)清除此处的颜色；这是因为如果您尝试使用例如FMT(FG黑和BG白)重置颜色，您将覆盖将其终端配色方案设置为除该精确配色之外的任何颜色的用户的首选项。此外，如果用户碰巧有一个透明背景的终端，设置的背景颜色将在文本周围创建难看的色块，而不是让窗口后面的任何东西正确显示。</p><p>现在，虽然使用调色板颜色更有礼貌，因为它们是最终用户可以轻松配置的调色板(她可能比默认的严苛纯色版本更喜欢柔和的颜色，或者更改饱和度和亮度以更好地适应她的终端背景)，但如果你正在做一些稍微有趣的UI方面的事情，你很快就会遇到这个限制。(如果你正在做一些稍微有趣的UI调色板，那么你很快就会遇到这个限制。)，如果你正在做一些稍微有趣的UI调色板，最终用户可能会很容易地配置(她可能会比默认的严酷纯色版本更喜欢柔和的颜色，或者改变饱和度和亮度以更好地适应她的终端背景)。虽然您可以通过将颜色与样式命令混合使用来获得更多里程，但如果您希望在配色方案方面为用户提供任何可配置性(正如您应该做的那样)，那么您将需要访问更广泛的调色板。</p><p>要从256色调色板中拾取，我们使用略有不同的转义方式：\x1b[38；5；(Color)m设置前景，\x1b[48；5；(Color)m设置背景，其中(Color)是我们要寻址的调色板索引。这些转义甚至比8+8颜色选择器更笨拙，所以拥有良好的抽象更加重要。</p><p>#include&lt；unistd.h&gt；#定义szstr(Str)str，sizeof(Str)#使用&#34；；&#34；#定义纯文本&#34；；&#34；#定义WFG(颜色)&#34；38；5；&#34；#color#定义wbg(颜色)&#34；48；5；&#34；#color#定义ansi_esc&#34；\x1b&#34。Style&#34；m&#34；int main(){write(1，szstr(&#34；纯文本-&#34；fmt(WFG(198)with WBG(232))&#34；fmt(纯文本)&#34；-&#34；fmt(wfg(232)with wbg(248))&#34；浅灰色&#34；fmt(纯文本)&#34；-&。Fmt(wfg(248)with wbg(232))&#34；浅灰色在深灰色上&#34；fmt(平坦))；}这里，节fmt(wfg(248)with wbg(232))翻译为\x1b[38；5；248；48；5；232m。为了简单起见，我们在这里对数字进行了硬编码，但经验法则是，任何时候您在终端中使用8位颜色时，都应该始终使其可由用户配置。</p><p>看起来不透明的指数实际上是非常系统的，您可以使用公式16+36*r+6*g+b来计算对特定颜色使用哪个指数，其中r、g和b是0到5之间的整数。指数232到255是从暗(232)到亮(255)的灰度渐变。</p><p>当然，这仍然是相当有限制性的。对于Windows上90年代的CD-ROM游戏来说，8位色可能已经足够了，但它早已过了有效期。使用真彩色要灵活得多。我们可以通过转义序列\x1b[38；2；(R)；(G)；(B)m来实现这一点，其中每个分量都是0到255之间的整数。</p><p>不幸的是，许多终端都不支持真彩色，不幸的是，urxvt也包括在内。因此，您的程序永远不应该依赖它，并将这些设置抽象出来由用户进行配置。默认为8位颜色是一个很好的选择，因为现在每个合理的现代终端都已经支持它很长一段时间了。</p><p>但是，对于基于XTerm、Kitty、Konsole和libVTE的终端模拟器(如GNOME终端、Mate终端和白蚁)的用户来说，使用24位颜色模式是礼貌的。例如：</p><p>#include&lt；stdio.h&gt；#include&lt；stdint.h&gt；#include&lt；stdbool.h&gt；struct color{enum color_mode{trad，trad_bright，b8，b24}mode；Union{uint8_t color；struct{uint8_t，g，b；}；}}；struct style{unsign char粗体：1；unsign char下划线：1。结构颜色fg，bg；}；结构格式fmt_menu={{0，0，0，0，0}，{trad，7}，{trad，4}}，fmt_menu_hl={{1，0，0，0，0}，{trad_bright，7}，{trad_bright，4}，}；void application_color(bool bg，struct color c){switch(c.mode){case trad：printf(&#。，bg？&#39；4&#39；：&#39；3&#39；，c.color)；Break；case trad_bright：printf(&#34；%s%u&#34；，bg？&#34；9&#34；：&#34；10&#34；，c.color)；Break；案例b8：printf(&#34；%c8；5；%u&#34；，bg？&#39；4&#39；：3和#39；，c.color)；Break；case B24：printf(&#34；%c8；2；%u；%u&#34；，bg？&#39；4&#39；：&#39；3&#39；，C.R，C.b，C.g)；}}void fmt(Struct Format F){printf(&#34；\x1b[&#34；)；f.加粗&amp；&amp；printf(&#34；F.下划线&amp；&amp；printf(&#34；；4&#34；)；f.斜体&amp；&amp；printf(&#34；；3&#34；)；f.反向&amp；&amp；printf(&#34；；7&#34；)；f.dim&amp；&amp；printf(&#34；；2&#34；)；application_color(false，f.fg)；application_color(true，f.bg)。}int Main(){…。If(is_conf(&#34；style/menu/color&#34；)){if(strcmp(conf(&#34；style/menu/color&#34；，0)，&#34；rgb&#34；)==0){fmt_menu.mode=b24；fmt_menu.r=atoi(conf(&#34；style/Menu/color&#34；，1))；fmt_menu.g=atoi(conf，2))；Fmt_menu.b=atoi(conf(&#34；style/menu/color&#34；，3))；}false if(conf(conf(&#34；style/menu/color&#34；，0))&gt；8){fmt_menu.mode=b8；fmt_menu.color=atoi(conf(&#34；style/menu.color&#34；，1))；}false{fmt_menu.color=att。，1))；}}…。}这种基础结构为您提供了非常灵活的格式化系统，它可以优雅地降级，而不会将您绑定到庞大的古旧的库中，也不会用数百个愚蠢的函数和宏污染全局名称空间(当然，这是完全无法区分的)。</p><p>但是，如果您想要的不仅仅是格式化，那该怎么办呢？如果您想要一个真正的TUI，该怎么办？</p><p>根据您想要的TUI类型，您实际上可以使用普通的老式ASCII。例如，如果您只是尝试绘制进度条，则可以(并且应该)使用ASCII控制字符回车(在C中，\r)：</p><p>#include&lt；unistd.h&gt；#include&lt；stdlib.h&gt；#include&lt；stdint.h&gt；#include&lt；time.h&gt；#定义条宽25#定义szstr(Str)str，sizeof(Str)tyecif uint8_t bar_t；int main(){srand(time(Null))；bar_t prmax=-1；size。)){Write(1，&#34；\r&#34；，1)；size_t barlen=进度/比率；for(size_t i=0；i&lt；barwidth；++i){size_t barlen=进度/比率；if(i&lt；=barlen)write(1，szstr(&#34；█&#34；))；否则write(1，szstr(&#34；░&#34；))；}fsync。//否则，终端只会在换行符size_tincr=rand()%(prmax/10)；if(prmax-Progress&lt；incr)Break；//避免溢出进度+=incr；SLEEP(1)；}}上更新。当然，如果我们真的想要美观一些，我们可以使用上面描述的转义序列用ANSI颜色装饰进度条。这将留给读者作为练习。</p><p>这对于基本的应用程序来说已经足够了，但是最终，我们将达到我们真正需要寻址和绘制终端的各个单元的地步。或者，如果我们希望根据终端窗口的大小动态调整进度条的大小，该怎么办？现在是再次打破ANSI转义序列的时候了。</p><p>编写TUI应用程序时，您应该始终做的第一件事是发送TI或smcup转义。这会通知终端切换到TUI模式(备用缓冲区)，保护现有缓冲区，使其不会被覆盖，并且用户可以在应用程序关闭时返回到它。</p><p>在ANSI中，我们使用序列&lt;ESC&gt;[？1049H(或者，作为C字符串，&#34；\x1b[？1049H&#34；])来实现这一点。</p><p>(注：还有另一个转义，它的效果看起来与1049类似，但它的行为在某些终端(如xterm)上被微妙地破坏了，而且它在其他终端(如kitty)上完全不起作用。(&#34；\x1b[？1049H&#34；在支持备用缓冲区的任何地方都有正确的效果。)。</p><p>一旦您切换到备用缓冲区，您要做的第一件事就是清除屏幕并将光标放回原处，以清除以前应用程序可能留下的任何碎片。为此，我们使用序列&lt;Esc&gt;[2j，它清除屏幕并停止回滚。(我们不能使用终端重置序列c，因为它不仅会影响活动缓冲区，而且会影响整个终端会话，并且会破坏当前显示的所有内容！)。</p><p>同样，就在退出之前，您需要发送TE或rmcup转义符。这通知终端切换回先前模式。此序列作为C字符串，是&#34；\x1b[？1049l&#34；。为了礼貌起见，在发送这个换码之前，您应该自己清理一下，像以前一样清除回滚。</p><p>(在这些转义中，h和l似乎代表硬件IO线，其中高电流通常对应于1位，低电流通常对应于0位，实质上表示开和关。在过去的EON硬件终端中，像这样可能的程序可配置模式是通过将离散输出线设置到特定级别来实现的；也有可能ANSI转义代码设计者只是在布尔还不流行的时代找到了一个方便的比喻。如果任何人碰巧发现了这件事背后的真实故事，请务必让我知道)。</p><p>一旦我们进入备用缓冲区，我们就可以安全地开始抛出转义序列，将光标移动到任意位置。但是，在执行此操作之前，我们需要知道终端实际有多大，以便我们可以适当地布局UI。</p><p>有一个名为resize()的函数或类似的函数是很好的形式，您可以在程序启动时以及以后调整终端窗口大小时运行该函数。虽然有一种可怕的方法可以用ANSI转义来做到这一点，但最好还是咬紧牙关，学习如何使用ioctls和termios。</p><p>Termios是一个POSIX接口，允许您发现和设置当前终端的属性。这是一种邪恶的混乱，但幸运的是，我们只需要使用它的一个很小的角落就可以获得我们需要的信息。</p><p>我们从导入&lt；sys/ioctl.h&gt；头开始。这为我们提供了设置ioctls所需的函数和结构。Termios在名为struct winsize的结构中返回窗口的大小。(比你在咒骂中找到的任何东西都要理性得多，不是吗？)。此结构使用函数调用ioctl(1，TIOCGWINSZ，&amp；ws)填充，其中ws是结构的名称(1是标准输出的文件描述符)。然后可以在字段ws_ol(表示宽度)和ws_row(表示高度)中访问端子宽度和高度。</p><p>当然，当终端大小更改时，我们需要使这些值保持最新。这就是为什么resize()需要是它自己的函数-每当我们的程序收到SIGWINCH信号时都需要调用它。无论何时重塑窗口，控制终端仿真器都会将SIGWINCH自动发送给子进程。</p><p>#include&lt；sys/ioctl.h&gt；；#include&lt；signal.h&gt；；uint16_t width；uint16_t Height；void resize(Int I){//所需的伪参数，以便//函数签名与Signal(3)期望的struct winsize ws；ioctl(1，TIOCGWINSZ，&amp；ws)；width=ws.ws_ol；high=ws.ws_row；/。\x1b[2j&#34；)}int main(Void){Signal(SIGWINCH，RESIZE)；RESIZE(0)；//此处等待用户输入}在整个过程中，您可能已经注意到一件事：尽管我们试图创建干净、光滑的TUI，但光标本身仍然顽固地显示在屏幕上。不过，别担心，我们可以解决这个问题。</p><p>显示和隐藏光标的转义序列与切换到备用缓冲区和从备用缓冲区切换的转义序列非常相似，不同之处在于它的数字是25，而不是1049。因此，我们可以通过打印字符串&#34；\x1b[？25L&#34；来隐藏光标，并使用字符串&#34；\x1b[？25H&#34；再次显示光标。</p><p>不过，重要的是要跟踪您如何更改终端的行为，并在程序退出时将其恢复。否则，用户将不得不自己重置终端，而许多人甚至不知道该怎么做(根据记录，这是$RESET或$ECHO-NE&34；\EC&34；)。由于您不一定能够控制程序如何退出，因此使用atexit(3)和Signal(3)函数设置退出处理程序非常重要。这样，即使进程使用SIGTERM或SIGINT终止，它仍然会将终端恢复到其原始状态。</p><p>(当然，在SIGKILL的情况下，它不会做千斤顶拉屎，但在这一点上，无论如何它都是用户的责任。)。</p><p>#include&lt；stdlib.h&gt；#include&lt；unistd.h&gt；#include&lt；signal.h&gt；；#定义say(Str)write(1，str，sizeof(Str))void清理(Void){//清理备用缓冲区say(&#34；\x1b[2J&#34；)；//切换回正常缓冲区say(&#34；\x1b[？\x1b[？25h&#34；)；}void CLEANUP_DIE(Int I){EXIT(1)；}int main(Void){//输入备用缓冲区SAY(&#34；\x1b[？1049H&34；)；//在EXIT(CLEANUP)；SIGNAL(SIGTERM，CLEANUP_DIE)；SIGINT(SIGINT，CLEANUP_DIE)；//清理缓冲区SAY(&#34；\x1\x1b[？25L&#34；)；睡眠(10)；返回0；}</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://xn--rpa.cc/irl/term.html">https://xn--rpa.cc/irl/term.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/了解/">#了解</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/wanted/">#wanted</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/终端/">#终端</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1022830.html"><img src="http://img2.diglog.com/img/2020/9/thumb_a4192af9f9d3d9608433ebec74dc57f9.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1022830.html">
注册以了解IFundWomen团队的资金选项</a></div><span class="my_story_list_date">2020-9-9 6:38</span></div><div class="col-sm"><div><a target="_blank" href="/story/1019871.html"><img src="http://img.diglog.com/img/2020/8/thumb_be970f21223af9cf2788cfb344bc4b0e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1019871.html">Python哈希表：了解字典</a></div><span class="my_story_list_date">2020-8-23 10:28</span></div><div class="col-sm"><div><a target="_blank" href="/story/1019859.html"><img src="http://img.diglog.com/img/2020/8/thumb_2516c748eae85b158b2ba0d7015b339d.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1019859.html">世界首次了解有关核风险的真相</a></div><span class="my_story_list_date">2020-8-23 7:5</span></div><div class="col-sm"><div><a target="_blank" href="/story/1019741.html"><img src="http://img.diglog.com/img/2020/8/thumb_8080c410f5abdd2233a800b46b2dab9d.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1019741.html">
您需要了解的关于SPAC的几乎所有内容</a></div><span class="my_story_list_date">2020-8-22 14:4</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>