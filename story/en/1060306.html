<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>红色和蓝色功能是一件好事 Red and blue functions are a good thing</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Red and blue functions are a good thing<br/>红色和蓝色功能是一件好事 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-26 17:46:43</div><div class="page_narrow text-break page_content"><p>By avoiding effect aware functions a language hobbles engineers and makes programs sloppier than they could be.</p><p>通过避免效果意识，职业职业工程师，并使节目比它们更滑坡。</p><p>  Most in the tech world are now familiar with the post describing  red/blue functions       (opens new window) and their downsides, especially in the context of asynchrony. Many people have joined in, usually to extol Go or Elixir or Erlang. Despite the meme spreading far and wide, many languages use the  async/await syntax in their language to handle asynchrony, introducing red/blue functions into the language. Rust is one notable and recent example.</p><p>  大多数技术世界现在熟悉描述红色/蓝色函数（打开新窗口）及其缺点的帖子，特别是在异步的背景下。许多人已经加入，通常是颂扬或酏剂或erlang。尽管MEME扩展了远远广泛，但许多语言在他们的语言中使用异步/等待语法来处理异步，将红色/蓝色函数引入语言。锈是一个值得注意的且最近的例子。</p><p>  My position when discussing this has long been that red/blue functions are a good design choice that should be used in basically all statically typed languages (I also happen to feel that  basically all languages should be statically typed       (opens new window), but that&#39;s a topic for another day). A mature and serious language such as Rust chosing to adopt them made me feel vindicated that my position was generally accepted, and I didn&#39;t worry much about it.</p><p>  我的职位在讨论时长期以来一直是红色/蓝色函数是一个很好的设计选择，应该在基本上所有静态类型的语言中使用（我也碰巧觉得基本上所有语言都应该静态键入（打开新窗口），但是＃39;另一天的SA主题）。一种成熟和严重的语言，如铁锈切选，让我感到觉得我的立场普遍被接受，我没有担心它。</p><p>  However I keep running into posts reviving the same talking points, and I finally couldn&#39;t stand by any longer when I encountered  this post stating that Rust is colored, &#34;and that&#39;s not a big deal&#34;       (opens new window).</p><p>  但是我一直跑进帖子恢复相同的谈话点，当我遇到这篇文章时，我终于不能待命，当我遇到这个帖子是彩色的，而＃34;那个＆＃39;不是一个大交易＆＃ 34; （打开新窗口）。</p><p>  I don&#39;t think this position is nearly strong enough! Not only are red/blue functions tolerable and a good design choice,  but the only benefit gained from avoiding them is convenience, and the consequences outweigh that benefit. By hiding important information about the real nature of the program, many unnecessary potential pitfalls are opened up. Certainly some languages can still make that choice, but I think they do their users a disservice. I personally will only use such languages for unimportant programs, or not use them at all.</p><p>  我不认为这个职位足够强大！不仅是红色/蓝色功能可以容忍和良好的设计选择，但避免它们的唯一效益是方便，并且其后果超过了这种好处。通过隐藏有关该计划的真实性质的重要信息，打开了许多不必要的潜在陷阱。当然，某些语言仍然可以做出这种选择，但我认为他们是他们的用户陷入困境。我个人只会为不重要的程序使用这样的语言，或者根本不使用它们。</p><p>    Colored functions reveal important realities of a program. Colored functions are essentially a type-system manifestation of program effects, all of which can have dramatic consequences on performance (unorganized io calls can be a latency disaster), security (io can touch the filesystem or the network and open security gaps), global state consistency (async functions often mutate global state, and the filesystem isn&#39;t the only example), and correctness/reliability (thrown exceptions are a program effect too, and a  Result function is another kind of color). Colored functions don&#39;t &#34;poison&#34; your program, they inform you of the  reality that your program itself has been poisoned by these effects.</p><p>    彩色功能揭示了一个计划的重要现实。彩色函数本质上是一个类型系统的程序效果，所有这些都可以对性能的巨大后果（未组织的IO调用可以是延迟灾难），安全性（IO可以触摸文件系统或网络和开放安全差距），全局状态一致性（异步函数经常变异全局状态，文件系统也是唯一的示例）和正确性/可靠性（抛出异常也是一个程序效果，结果函数是另一种颜色）。彩色功能Don＆＃39; T＆＃34;毒药＆＃34;您的计划，他们通知您您的计划本身已被这些效果中毒的现实。</p><p>  Sanely designed type systems always have escape hatches to make a program more convenient when it makes sense, such as  Future blocking functions or  unwrap() in Rust. These functions essentially throw away the program effect information, but do so obviously and consciously. Programmers can choose to do this when they feel it justified, while keeping the option to change their mind later. When the program starts performing pathologically or becoming unreliable, it remains clear where to start looking.</p><p>  Sandely设计的系统始终具有逃生舱口，以使程序更方便，如未来阻塞功能或rust包装（）。这些功能基本上丢弃了程序效果信息，但显然和有意识地这样做。程序员可以选择在他们觉得它有理由时这样做，同时保持选择后来改变主意。当程序开始在病理上进行病理或不可靠时，它仍然可以清楚地开始寻找。 </p><p>  The most obvious and trivial example of effect aware functions encouraging a better program is when several asynchronous actions can be dispatched at the same time. Let&#39;s say we have some silly function where asynchrony is handled in the &#34;go-routine&#34; fashion:</p><p>效果意识功能最明显和琐碎的例子，鼓励更好的程序是当可以同时调度几个异步动作时。假设我们有一些愚蠢的功能，在＆＃34中处理了异步;去常规＆＃34;时尚：</p><p>  fn  bundle_letters ( )  -&gt;    {	 // each of these functions performs an async action	 // internally creating a green-thread	 // and coordinating with it using channels or mutexes	 let a  =  fetch_a ( ) ;	 let b  =  fetch_b ( ) ;	 let c  =  fetch_c ( ) ;	   { a , b , c  } }</p><p>  fn bundle_letters（） - ＆gt; {//每个函数中的每一个都在内部创建绿色线程//并使用频道或互斥锁定与它协调，让a = fetch_a（）;设b = fetch_b（）;让c = fetch_c（）; {A，B，C}}</p><p> Note that without adding more code it is absolutely impossible to make those  fetch calls truly concurrent. Since languages like Go can&#39;t guarantee a green-thread won&#39;t introduce synchronization bugs, the programmer has to synchronize manually with channels or mutexes. Functions you can &#34;just call&#34; like those above must necessarily suspend if they are going to remain safe. Without adding a  WaitGroup and creating new green-threads for each  fetch, then the above code is equivalent to this:</p><p> 请注意，如果不添加更多代码，则绝对无法使这些获取调用真正并发。由于像Go＆＃39一样的语言。它保证了绿色线程won＆＃39; t引入同步错误，程序员必须用频道或互斥锁手动同步。你可以＆＃34的功能;只需打电话＆＃34;就像上面的那些必须暂停，如果他们将保持安全。如果没有添加待存组并为每个获取创建新的绿色线程，那么上面的代码等同于此：</p><p>  async  fn  bundle_letters ( )  -&gt;    {	 let a  =  fetch_a ( ) . await ;	 let b  =  fetch_b ( ) . await ;	 let c  =  fetch_c ( ) . await ;	   { a , b , c  } }</p><p>  async fn bundle_letters（） - ＆gt; {让a = fetch_a（）。等待;设b = fetch_b（）。等待;让c = fetch_c（）。等待; {A，B，C}}</p><p> Importantly, the language itself  does nothing to inform us this is the case. We merely miss out on the opportunity for real concurrency if we aren&#39;t sufficiently familiar with these specific  fetch functions.</p><p> 重要的是，语言本身无需通知我们这就是这种情况。如果我们aren＆＃39; t熟悉这些特定的获取功能，我们只会错过真正的并发的机会。</p><p>  But with the naive  await code glaring at us, we only have to understand the  language to understand we&#39;re leaving performance on the table. The refactor is obvious:</p><p>  但是，随着天真的等待代码在我们身上，我们只需要了解语言以了解我们＆＃39;重新留下表现。重构是显而易见的：</p><p>  async  fn  bundle_letters ( )  -&gt;    {	 let  (a , b , c )  =   join! (		 fetch_a ( ) ,  fetch_b ( ) ,  fetch_c ( ) ,	 ) . await ;	   { a , b , c  } }</p><p>  async fn bundle_letters（） - ＆gt; {让（a，b，c）=加入！ （fetch_a（），fetch_b（），fetch_c（），）。等待; {A，B，C}} </p><p> (PS, in typescript a fully typesafe function equivalent to  futures::join can be made with  a generic tuple       (opens new window))</p><p>（PS，在TypeScript中，可以使用通用元组（打开新窗口）使用相当于期货::加入的完全排版功能）</p><p>  Elixir seems to put us in a similar situation. We have to use   Task.await       (opens new window), but nothing in the (dynamic) type system requires that any function using  Task.await has to be marked. This again invites the same kind of inefficient sequential waiting when other programmers use our  await calling function without being aware.</p><p>  Elixir似乎让我们处于类似的情况。我们必须使用task.await（打开新窗口），但（动态）类型系统中没有任何内容需要使用任意任意函数.Await必须标记。当其他程序员使用我们的等待呼叫功能而不知道时，这再次邀请了相同的效率顺序等待。</p><p>  Any code that &#34;feels synchronous&#34; necessarily makes you pay for that feeling by stealing true concurrency away from you. It may seem more convenient at first, but the second you need more control you have to use much clunkier abstractions.</p><p>  ＆＃34的任何代码;感觉同步＆＃34;必须通过偷窃你的真正并发来为您支付这种感觉。它起初可能似乎更方便，但第二个你需要更多的控制，你必须使用太多的笨蛋抽象。</p><p>  The only way to gain both the apparent simplicity of the go-routine style of asynchrony along with the efficiency of aligned await points is to build a very sophisticated optimizing compiler that can track the liveness of asynchronously fetched values and reorder or even insert operations. Even in this situation the programmer is still potentially oblivious to the underlying asynchrony.</p><p>  获得异步的常规风格的明显简单的唯一方法以及对齐的等待点的效率是构建一个非常复杂的优化编译器，可以跟踪异步获取值的活力和重新排序甚至插入操作。即使在这种情况下，程序员仍然可能对底层的异步感到沮丧。</p><p>  Rust has proven that with clever compiler design a  Future based system can give us both clean syntax and incredible performance. Rust async isn&#39;t completely finished, but the price of real innovation is temporary pain. Once the innovation has been done we&#39;ll have all the benefits with very few real tradeoffs.</p><p>  Rust已经证明，通过Clever Compiler设计，基于未来的系统可以为我们提供干净的语法和令人难以置信的性能。 Rust Async ISN＆＃39; T完全完成，但实际创新的价格是暂时的痛苦。一旦创新完成了我们＆＃39; LL非常少的实际权衡。</p><p>    Programs can essentially always be structured as a  functional core with impure io wrappers       (opens new window). Doing so is better in many more ways than merely allowing code reuse across sync/async functions. Allowing programmers to write blended sync/async code that&#39;s all the &#34;same color&#34; inevitably invites poor structure.</p><p>    程序基本上可以始终构造为具有纯IO包装的功能核心（打开新窗口）。这样做比允许跨同步/异步函数的代码重复使用更好的方式更好。允许程序员编写混合同步/异步代码，＆＃39; s所有＆＃34;相同的颜色＆＃34;不可避免地邀请了差的结构。</p><p>  Awareness of effect boundaries between functions allows you to improve the clarity of your design, and punishes you for a sloppy one. This is almost always a good thing, and engineers who routinely have to deliver robust, performant, correct programs should prefer their language be a careful partner who holds them accountable for their design decisions.</p><p>  职能之间的效果边界的认识允许您提高您设计的清晰度，并惩罚您的邋..这几乎总是一件好事，并且通常必须提供强大，表演，正确的程序的工程师更喜欢他们的语言是一个谨慎的合作伙伴，他们认为他们对他们的设计决策负责。 </p><p>  Feel free to create and use languages with invisible program effects or asynchrony, and I&#39;ll feel free to not pay any attention when you do.</p><p>随意创建和使用具有隐形程序效果或异步的语言，我＆＃39;当你这样做时，我会随意不关注。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blainehansen.me/post/red-blue-functions-are-actually-good/">https://blainehansen.me/post/red-blue-functions-are-actually-good/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/蓝色/">#蓝色</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/blue/">#blue</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>