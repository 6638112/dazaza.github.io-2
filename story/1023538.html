<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我的MMIO抽象历险记</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我的MMIO抽象历险记</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-09-12 15:48:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/9/b5d0f1167a86fdbbb8945644fc4c54f6.png"><img src="http://img2.diglog.com/img/2020/9/b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>几年前，我在Reddit上看到一个简单的流氓游戏，叫做coreRR。它非常简单；关卡只是一个有两面墙的盒子，只有一个敌人类型，有基本的人工智能，没有健康或性格属性，唯一的目标是看看你在死之前能走多远。由于没有更好的事情可做，我想为Arduino Nano编写一个端口会是一个有趣的小项目。所需的唯一输入是四个移动键，显示器可以只是一个基本的SSD1306驱动的128x64 OLED面板。</p><p>当然，我可以用C++来做这件事。语言是为Arduino Nano提供动力的ATmega328P的已知数量，工具链已经成熟，用于与板载外围设备交互的抽象也是成熟的。还有用于SSD1306驱动显示器的库。这是显而易见的选择。我真正要做的就是写游戏逻辑。</p><p>要真正做任何有用的事情，微控制器需要与外部世界交互。ATmega328P有四个我将在这个项目中使用的外设：IO端口、定时器、双线接口(TWI)总线和用于将调试信息发送回我的PC的USART。</p><p>它们由操作内存映射IO(MMIO)寄存器使用。通常，当你读或写记忆地址时，你是在访问某种，嗯……。记忆。内存映射IO顾名思义就是：它是映射到内存地址的一块硬件，因此您可以访问连接的硬件，而不是简单地访问内存中的值。具体是如何实现的取决于所讨论的硬件。例如，写入IO端口只需设置几个触发器。但其他设备将更加复杂。</p><p>为了说明如何使用这些，我将从微控制器的问候世界开始：打开LED。ArduinoNano有一个LED连接到PB5针脚。名称告诉我们操作哪组寄存器以及需要操作的位：端口B，位5。328P上的IO端口非常简单：使用DDRn寄存器设置数据方向(将一位设置为0表示输入，将位设置为1表示输出)，而输出电平由PORTn寄存器控制(将一位设置为0表示低电平，将位设置为1表示高电平)。</p><p>我们需要端口B，因此这将是DDRB和PORTB寄存器。其地址为：</p><p>然而，这一部分让拉斯特感到有点尴尬。生锈是非常..。这里的问题是，对拉斯特来说，这些是我凭空变出来的任意内存地址。它对它们一无所知，当然也不知道它们是IO外围设备。这意味着我需要将它们作为原始指针访问。操纵原始指针需要不安全。此外，为了防止过度热心的优化器删除我们(显然)未使用的内存访问，您需要使用易失性读写。在C++中，这很简单：您只需将整个指针类型标记为易失性，并且每个访问都被正确处理。铁锈是不同的。在Rust中，访问是否是易失性的取决于访问的站点，而不是指针的类型。</p><p>因此，考虑到这一点，下面是我如何打开LED的方法。我首先定义一些常量：</p><p>常量PORTB：*MUT U8=0x25 AS*MUT_；常量DDRB：*MUT U8=0x24 AS*MUT_；常量PB5：U8=5；</p><p>这显然会很快变得非常混乱。所有这些围绕内存访问的噪音将最终导致与寄存器交互的代码难以读取。难以阅读的代码是很难理解的、有缺陷的代码。如果您只想设置一个位而不更改其他任何位，情况会变得更糟：</p><p>我想要做的是隐藏位的闲置细节，只留给我更高级别的概念。为此，我考虑了这些寄存器将具有哪些通用功能：</p><p>有几种方法可以做到这一点，但我最终确定的是这一特点：</p><p>PUB特征寄存器{const ADDR：*MUT U8；不安全的FN SET_VALUE(VAL：U8){SELF：：Addr.。Write_Volatile(Val)；}不安全的FN GET_VALUE()-&gt；U8{Self：：Addr.。Read_volatile()}不安全的FN get_bit(bit：u8)-&gt；bool{let bit=1&lt；&lt；bit；(self：：get_value()&amp；bit)！=0}不安全的fn set_bit(bit：u8){let bit=1&lt；&lt；bit；let val=self：：get_value()；self：：set_value(val|bit)；}不安全的FN CLEAR_BIT(BIT：U8){let bit=1&lt；&lt；bit；let val=self：：get_value()；self：：set_value(val&amp；！bit)；}}。</p><p>每个寄存器的函数实现都是相同的，所以我只有一个默认实现。这些功能应该是不安全的，因为这里没有办法证明我们正在做的事情实际上是正确的。这将取决于打电话的人。有了这个抽象，我就可以将我的寄存器定义更改为：</p><p>Struct PORTB；用于PORTB的IMPL寄存器{const ADDR：*MUT U8=0x25 AS*MUT_；}struct DDRB；IMPL寄存器用于DDRB{const ADDR：*MUT U8=0x24 AS*MUT_；}。</p><p>目前的实现有两个问题，虽然不是很严重，但确实困扰着我。首先，没有任何寄存器是8位的；有些寄存器是16位的。现在，我只需分别定义寄存器的高字节和低字节，这就是AVR C标头所做的工作，但我更希望能够在一次操作中对其进行寻址。</p><p>第二，位操作的所有输入都是纯U8。这意味着我可以执行PORTB：：SET_BIT(30)，并让编译器接受不正确的输入。现在也不清楚我是应该传入一个位ID值，还是应该传递一个预移位值。还有一个额外的问题：并不是寄存器中的所有位都有意义。例如，TWI控制寄存器(TWCR)位1没有任何功能。不过，我可以不出问题地将1传递给set_bit函数。这可能是文档的一部分，但如果我一开始就不能做错，不是更好吗？</p><p>第一个比较容易处理，所以我会先做这件事。我需要寄存器在其存储类型上是通用的。这相当简单：只需引入一个泛型类型T，并将U8的所有实例替换为T。如果这样做，您将会遇到一系列编译错误，如下所示：</p><p>错误[E0277]：没有实现`{INTEGER}&lt；&lt；T`--&gt；src\register.rs：16：21|16|let bit=1&lt；&lt；bit；|^^没有实现`{INTEGER}&lt；&lt；T`|=Help：特性`core：：ops：：shl&lt；T&gt；`没有实现`{INTEGER}`。</p><p>我需要约束T。编译器错误告诉我们需要什么特性：Shl、BitAnd、BitOr、Not和Eq。我还应该将其限制为寄存器可以是的类型：u8和u16。它也应该是复制的，首先是因为我们正在隐式复制值，但也是因为我正在进行指针读写，这与丢弃实现和与之相关的健壮性不能很好地配合，所以它应该强制不存在复杂的丢弃行为。Copy也可以做到这一点，因为不能对实现Drop的类型实现Copy。</p><p>除此之外，我还使用了两个常量：0和1。编译器在这些函数实现中不知道0和1的文字是t。我需要关联的常量。</p><p>为了满足这些要求，我引入了另一个特征RegisterType，它需要上面列出的类型，并在u8和u16中实现它：</p><p>Pub特征寄存器类型：Copy+BitAnd&lt；Output=Self&&gt;；+BitOr&lt；Output=Self&&gt;；+Not&lt；Output=Self&&gt;；+Eq+PartialEq{Const Zero：Self；Const One：Self；}U8的Impl寄存器类型{Const Zero：Self=0；Const One：Self=1；}Impll RegisterType for U8{Const Zero：Self=0；Const One：Self=1；}Impll RegisterType for U8{Const Zero：Self=0；Const One：Self=1；}Impll RegisterType。</p><p>现在来解决另一个问题。可以和不能使用的位是特定于寄存器的，也有名称(例如，TWCR寄存器的位5称为TWSTA)。因此，我们所拥有的是一组固定的特定的、命名的值。枚举非常适合于此。我们可以这样表示TWCR的有效位：</p><p>然后，我想确保位翻转函数只能接受表示该寄存器位的枚举。因为我需要在Register特征上有一个关联的类型，所以我可以在函数签名中对其进行命名：</p><p>Pub特征寄存器&lt；T：RegisterType&gt；{const addr：*mut T；type BitType；...。不安全的FN GET_BIT(BIT：Self：：BitType)-&gt；bool{...}不安全的FN SET_BIT(BIT：Self：：BitType){...}不安全的FN CLEAR_BIT(BIT：Self：：BitType){...}}。</p><p>因为这里的所有逻辑都是基于移位的，所以我需要能够从BitType中获得一个T，告诉我们变量代表的是哪一位。所以BitType需要实现一个返回该值的函数。此函数还需要返回u8或u16，具体取决于寄存器。输入NamedBits特征：</p><p>然后，我在Register中更改关联的类型，以便将位类型适当地限制为仅实现NamedBits的位类型，并更新位缠绕函数以在其输入上调用bit_id函数：</p><p>Pub特征寄存器&lt；T：RegisterType&gt；{const addr：*mut T；type BitType：NamedBits&lt；dataType=T&gt；；...。不安全的fn get_bit(bit：self：：BitType)-&gt；bool{let bit=T：：one&lt；&lt；bit。Bit_id()；(self：：get_value()&amp；bit)！=T：：Zero}不安全的FN set_bit(bit：self：：BitType){let bit=T：：one&lt；&lt；bit。Bit_id()；let val=self：：get_value()；self：：set_value(val|bit)；}不安全的FN Clear_bit(bit：self：：BitType){let bit=T：：one&lt；&lt；bit。Bit_id()；let val=self：：get_value()；self：：set_value(val&amp；！bit)；}}。</p><p>#[派生(复制，克隆)]枚举PortBits{PB0，PB1，PB2，PB3，PB4，PB5，PB6，PB7，}为PortBits实施命名位{type dataType=U8；fn bit_id(Self)-&gt；self：：dataType{use PortBits：：*；Match Self{PB0=&gt；0，PB1=&gt；1，PB2=&gt；6，Pb7=&gt；7，}针对PORTB的struct PORTB；实施寄存器U8&&gt;{const ADDR：*mut U8=0x25 as*mut_；type BitType=PortBits；}struct DDRB；Iml Register&lt；U8&&gt;；for DDRB{const ADDR：*mut U8=0x24 as*mut_；type BitType=PortBits；}。</p><p>无论输入是不是预移位值，都不再有任何模棱两可的地方，我也不能像以前那样随意输入数字。</p><p>还有最后一个问题：有些寄存器只是数据存储。这方面的一个例子是USART的UDR0寄存器，它存储通过总线发送或接收的字节。在这种情况下，寄存器是一个字节的数据，而不是控制位的集合，所以能够设置特定的位没有意义。然而，抽象在这里需要表示位的类型。</p><p>我的解决方案是创建一个名为NoBits的结构，它有一个私有字段，这样它就不能在其父模块之外构造：</p><p>#[派生(复制，克隆)]pub struct NoBits&lt；T&gt；(PhantomData&lt；T&gt；)；Iml&lt；T：RegisterType&gt；NamedBits for NoBits&lt；T&gt；{type dataType=T；fn bit_id(Self)-&gt；self：：dataType{T：：Zero}}。</p><p>我之所以选择结构而不是没有变体的枚举，是因为它需要对8位和16位寄存器都可用，这意味着它确实需要是泛型的，而不使用泛型类型参数是编译错误。这意味着我现在可以定义UDR0寄存器，并且仍然使用GET_VALUE和SET_VALUE函数，但不使用与位相关的函数：</p><p>用于UDR0的struct UDR0；Iml寄存器&lt；U8&gt；{const ADDR：*mut U8=0xC6 as*mut_；type BitType=NoBits&lt；U8&gt；；}。</p><p>在这一点上，那些患有锈病的朋友可能会想，为什么不直接使用Corelib的FROM或INTO特征来将位枚举转换为T呢？起初我确实尝试过这些方法，但很快就发现，由于某些原因，它们并不能很好地进行优化。即使所有的输入在编译时都是已知的，它最终也不会内联into调用，因此您将在最终的二进制文件中得到一个不必要的函数调用。定义我自己的特定转换特性导致了内联的位置，这意味着整个事情都得到了优化。</p><p>好的，我可以用一种容易阅读、更难出错的方式来润色一下。但我也希望在一次操作中设置(或清除)多个位。我可以通过连续调用set_bit(或clear_bit)来做到这一点，但是易失性访问开始成为一个问题。到目前为止，根据我所拥有的，将PORTB的PB5位设置为以下优化：</p><p>因为访问是易失性的，所以编译器不知道它是否可以将所有位收集在一起并一次设置所有位，所以我需要自己来做这件事。和前面一样，我不想暴露手动的位旋转，所以我将实现两个函数(set_bits和clear_bits)来为我做这件事。铁锈没有各种各样的功能，但它确实有切片，所以我会让它们取一片：</p><p>酒吧特性寄存器&lt；T：RegisterType&gt；{...。不安全的FN SET_BITS(BITS：&AMP；[Self：：BitType]){//通过将移位的位一起或来构造最终的位模式。设BITS=BITS。ITER()。已复制()。Map(NamedBits：：bit_id)。Fold(T：：Zero，|acc，b|acc|(T：：one&lt；&lt；b))；let val=self：：get_value()；self：：set_value(val|bits)；}不安全的FN CLEAR_BITS(BITS：&amp；[Self：：BitType]){let Bits=BITS。ITER()。已复制()。Map(NamedBits：：bit_id)。Fold(T：：零，|acc，b|acc|(T：：one&lt；&lt；b))；let val=self：：get_value()；self：：set_value(val&amp；！bits)；}}</p><p>并将其优化为单个操作(0xEC是将以上位进行或运算后得到的结果)：</p><p>到目前为止，我所得到的在一次操作中就可以很好地进行设置或清除。但有一件事经常出现，那就是当您想要替换某些位的值，但保持其他位的值不变时。这可以通过连续调用CLEAR_BITS，然后调用SET_BITS来完成，但这会遇到我们之前遇到的易失性寄存器问题，因为实际清除寄存器中的位可能会对更复杂的外设造成意外情况。</p><p>LET BITS_TO_REPLACE=(1&lt；&lt；2)|(1&lt；&lt；4)|(1&lt；&lt；7)；LET_REPLACE_VAL=(1&lt；&lt；2)|(1&lt；&lt；7)；LET_VAL=REG：：GET_VALE()；LET MASTED=REG_VAL&AMP；！BITS_TO_REPLACE；LET NEW_REG=。Reg：：set_value(Reg_Val)；</p><p>但是有一个为我做这件事的函数会让这件事变得更容易，并减少出错的机会。这里的逻辑是SET_BITS和CLEAR_BITS函数的组合，所以就让我们这样做吧。它将需要两组位：一组表示要替换的位，另一组表示用来替换它们的值。</p><p>不安全的FN REPLACE_BITS(掩码：&amp；[Self：：BitType]，值：&amp；[Self：：BitType]){let MASK=MASK。ITER()。已复制()。Map(NamedBits：：bit_id)。Fold(T：：Zero，|acc，b|acc|(T：：one&lt；&lt；b))；let value=value。ITER()。已复制()。Map(NamedBits：：bit_id)。Fold(T：：Zero，|acc，b|acc|(T：：one&lt；&lt；b))；let masked_value=value&amp；ask；let masked_reg=self：：get_value()&amp；ask；self：：set_value(mask_reg|masked_value)；}。</p><p>这里我们应该注意的一件事是确保传入的值也被屏蔽(但不是用反转的屏蔽！)，这样它就不会损坏屏蔽区域之外的位。所以现在我可以这样做：</p><p>到目前为止，这看起来还可以用于比特闲置。需要获取多位操作的切片并不重要，还有一个事实是，我还需要显式地导入位枚举，并知道它的名称。这两件事都有点让人恼火，但不是什么大问题。然而，这些问题是可以解决的。第一个问题，我们稍后再来讨论，但第二个问题很容易处理。</p><p>解决方案非常简单：关联常量。我们只需在寄存器上声明一组关联常量，它们指向枚举变量：</p><p>Pub struct TWCR；Iml TWCR{pub const twie：：twie；pub const TWEN：TWCRBits=TWCRBits：：TWen；pub const TWWC：TWCRBits=TWCRBits：：TWWC；pub const TWSTO：TWCRBits=TWCRBits：：TWSTO；pub const TWSTA。</p><p>现在，当我想对TWCR寄存器进行位旋转时，只需通过寄存器本身获取位名：</p><p>当涉及到设置寄存器值时，还有另一个更大的问题。目前，我只能用原始整数设置寄存器值。但是，想要根据一组位来设置值是完全合理的。例如，在配置TWI总线时。有几个点需要替换整个值；例如，在仲裁失败后释放总线时，当前如下所示：</p><p>当我们回到那个问题上时，做所有这些抽象有什么意义呢？我可以让set_value函数接受一些位，比如set_bits等函数，但是仍然有需要设置整数值的情况。我选择的方法是另一个特点：</p><p>然后，我为所有寄存器类型和寄存器位片段实现了它，并更新了set_value函数：</p><p>实施&lt；T：RegisterType&gt；SetValueType&lt；T&gt；for T{fn as_value(Self)-&gt；T{self}}实施&lt；T：NamedBits&gt；SetValueType&lt；T：：DataType&gt；for&amp；[T]{FN AS_Value(Self)-&gt；T：：DataType{sel.。ITER()。已复制()。Map(NamedBits：：bit_id)。Fold(T：：DataType：：Zero，|acc，b|acc|(T：：DataType：：one&lt；&lt；b))}}Pub特征寄存器&lt；T：RegisterType&gt；{...。不安全的FN SET_VALUE&lt；V：SetValueType&lt；T&gt；&gt；(val：v){设val=val。As_value()；self：：addr。Write_Volatile(Val)；}...}。</p><p>这允许我以两种方式设置值(尽管在这里传入切片需要as_ref，这不是很好)：</p><p>我不喜欢所有这些切片。他们看起来既怪异又笨拙。在操作TWI总线时，IF语句的两个分支都替换了TWCR寄存器，但差别只有一位。例如，在处理数据包时，您需要配置寄存器，但可能不想发送ACK信号。目前您需要这样做：</p><p>如果我可以构建该值，选择性地设置TWEA位，然后设置寄存器，那就太好了。事实上，如果我能做这样的事情，同时还能保留一定程度的白痴保护，那就太好了：</p><p>你可能会注意到，我想要做的事情和我开始时相当难看的烂摊子很相似：</p><p>所以我需要的是用某种方式来做同样的事情，但是要保留关于它们来自哪个寄存器的信息。我的解决方案是BitBuilder。它应该保留有关它用于哪种位类型的信息，因此它需要是泛型的。因为位类型现在是整体类型的一部分，所以我们可以使内部字段成为寄存器的数据类型。我们将使该字段成为私有字段，这样它就不能被任意值替换。</p><p>#[派生(复制，克隆)]pub struct BitBuilder&lt；T：NamedBits&gt；(T：：DataType)；Iml&lt；T：NamedBits&gt；BitBuilder&lt；T&gt；{pub FN new()-&gt；self{BitBuilder(T：：DataType：：Zero)}fn set_bit(&amp；mut self，b：t)。0=自我。0|(T：：dataType：：one&lt；&lt；B.bit_id())；}}。</p><p>现在，要获得我想要的ORing行为，我可以简单地实现BitOr和BitOrAssign特征，用于当右侧都与BitBuilder的位类型有点相同时，以及当它是同一位类型上的另一个BitBuilder时：</p><p>对于BitBuilder&lt；T&gt；实施&lt；T：NamedBits&gt；BitOr&lt；Self&gt；{type output=BitBuilder&lt；T&gt；；FN BITOR(mut Self，RHS：Self)-&gt；Self：：Output{Self.。0=自我。0|RHS。0；Self}}实施&lt；T：NamedBits&gt；Bito。</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gist.github.com/Measter/2108508ba25ebe3978a6c10a1e01b9ad">https://gist.github.com/Measter/2108508ba25ebe3978a6c10a1e01b9ad</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/抽象/">#抽象</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/mmio/">#mmio</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1018459.html"><img src="http://img.diglog.com/img/2020/8/thumb_29c4b75e65a5558c8c577617238647d5.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1018459.html">当干的不起作用时，去湿的</a></div><span class="my_story_list_date">2020-8-16 14:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1008721.html"><img src="http://img.diglog.com/img/2020/6/thumb_99194f67e5542018f2c1c325832cade0.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1008721.html">抽象出正确性</a></div><span class="my_story_list_date">2020-6-28 21:48</span></div><div class="col-sm"><div><a target="_blank" href="/story/life_other_359752.html"><img src="http://img.diglog.com/img/2010/7/thumb_b736215a6f564cba9b9f56cda45d2a60.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/life_other_359752.html">20个绝妙的极简抽象广告欣赏</a></div><span class="my_story_list_date">2010-7-2 14:26</span></div><div class="col-sm"><div><a target="_blank" href="/story/technology_design_113124.html"><img src="http://img.diglog.com/img/2008/12/thumb_add803d9f8504e4aa1e02e5e28598fbe.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/technology_design_113124.html">抽象派时尚落地灯</a></div><span class="my_story_list_date">2008-12-19 13:16</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>