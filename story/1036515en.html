<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Janki方法–使用SRS改进编程（2011）Janki Method – Using SRS to Improve Programming (2011)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Janki Method – Using SRS to Improve Programming (2011)<br/>Janki方法–使用SRS改进编程（2011）</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-25 20:52:34</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/980f61f89ec336262cc0122fee98aa8a.jpg"><img src="http://img2.diglog.com/img/2020/11/980f61f89ec336262cc0122fee98aa8a.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>EDIT: Update To JANKI Method For nearly four years after I wrote this post I have continued to use flashcards to learn and have made a number of refinements to my recommendations. I summarised these points in  Janki Method Refined, part 2 of a separate article,  Guide to Autodidactism, and, in 2020, within a series of YouTube vides:</p><p>编辑：更新为JANKI方法在撰写本文后的近四年中，我继续使用抽认卡进行学习，并对我的建议进行了许多改进。我在另一篇文章《自编指南指南》的第二部分Janki Method Refined中总结了这些观点，并在2020年通过一系列YouTube影片总结了这些观点：</p><p> This is a guide to becoming a productive programmer quickly. In his book  Outliers, Malcolm Gladwell told the world it takes 10,000 hours to master something. Practice three hours a day, and you will shine in ten short years. Millions of readers felt inspired since they too could become the next Bill Gates, if only they put in the hours. As the days turned to months we discovered that 10,000 hours was a lot longer than we anticipated. Limitless potential transformed into fantasy about what might have been.</p><p> 这是快速成为有生产力的程序员的指南。马尔科姆·格拉德威尔（Malcolm Gladwell）在他的书《离群值》中告诉世界，掌握某些东西需要10,000个小时。每天练习三个小时，十年之内就会发光。数以百万计的读者感到鼓舞，因为他们只要投入大量时间就可以成为下一个比尔·盖茨。随着时间的推移，我们发现10,000小时比我们预期的要长得多。无限的潜力变成了幻想。</p><p> Janki Method is an attempt to shorten the time needed to learn programming. It grew out of my impatient dream to build an automated web business that would free me financially, geographically and temporally. I didn’t want to wait 10,000 hours. I suspect you don’t either.</p><p> Janki方法是为了缩短学习编程所需的时间。建立一个自动化的网络业务使我在财务上，地理上和时间上都可以自由，这源于我的不耐烦梦想。我不想等待10,000个小时。我怀疑你也没有。</p><p>  Well-intentioned learners don’t always learn quickly, despite their smarts and enthusiasm. For most, eventual ability is determined by the volume of time expended. Malcolm’s 10k sounds about right.</p><p>  志向高尚的学习者尽管聪明才智和热情，但他们并不总是很快学习。对于大多数人来说，最终的能力取决于所花费的时间。马尔科姆（Malcolm）的10k听起来不错。</p><p> You’ve read that learning by doing is better than passive reading; that expressing ideas in writing forces understanding; that knowledge needs constant revision to stay fresh; that creativity comes from linking disparate ideas; and that your past mistakes are your best teachers. How many of these ideas do you apply to your learning efforts?</p><p> 您已经读到边干边学比被动阅读要好；以书面表达思想会加深理解；需要不断修改知识以保持新鲜感；创造力来自将不同的想法联系在一起；并且您过去的错误是您最好的老师。您将其中哪些想法应用到学习中？</p><p> Janki Method is built on the suspicion that Malcolm’s 10k to mastery can be hastened if you take a focused approach to learning. The core of Janki Method is the use of a spaced repetition flashcard system,  Anki, programmed by the brilliant Damien Elmes.</p><p> 扬基方法（Janki Method）的基础是，如果您采取专注的学习方法，可以加快马尔科姆（Malcolm）的10k掌握水平。 Janki方法的核心是使用由出色的Damien Elmes编程的间隔重复抽认卡系统Anki。</p><p> By following my approach, I believe that any intelligent and disciplined reader can achieve proficiency* in a given field of programming (e.g. web applications, iPhone applications) in less than 12 months.</p><p> 通过遵循我的方法，我相信任何精通纪律的读者都可以在不到12个月的时间里在给定的编程领域（例如Web应用程序，iPhone应用程序）达到熟练程度*。</p><p>    Have you ever spent a week studying for an exam, only to forget 90% of what you learned within 2 months and everything else within a year?</p><p>您是否曾经花一个星期学习考试，却忘记了在两个月内学到的90％以及一年内所学的所有其他知识？</p><p> Forgetting impedes learning knowledge-intensive skills such as programming. You need to remember various languages, solutions, libraries and gotchas if you want to build large applications. Because technical material can be so abstract and dry, you forget particularly quickly.</p><p> 忘记阻碍学习诸如编程之类的知识密集型技能。如果要构建大型应用程序，则需要记住各种语言，解决方案，库和陷阱。因为技术材料可能是如此抽象和枯燥，所以您会很快忘记。</p><p> The first rule of  Janki boosts your memory:  “Every time you learn something new create a question and answer flashcard and add this card to Anki.”</p><p> Janki的第一条规则可以提高您的记忆力：“每次学习新知识时，都会创建一个问答卡片，并将其添加到Anki中。”</p><p> Anki is a Spaced Repetition System. Most algorithms make computers efficient; Anki makes you efficient. Using the minimal number of repetitions necessary for permanent retention, Anki drills flashcards into your long-term memory.</p><p> Anki是一个间隔重复系统。大多数算法使计算机高效。 Anki使您高效。通过使用永久保留所需的最少重复次数，Anki可以将抽认卡钻入您的长期记忆中。</p><p> Begin by creating a deck of flashcards called, say, computer science. A deck contains many cards, and each card consists of a question and an answer. You tag these cards with the categories that best describe their contents. For example, one card might be tagged with ‘Rails’, and another with ‘SQL’. Each card can have numerous tags, something useful given how technologies frequently overlap.</p><p> 首先创建一组称为计算机科学的抽认卡。卡片组包含许多卡，每个卡包含一个问题和一个答案。您用最能描述其内容的类别标记这些卡。例如，一张卡可能被标记为“ Rails”，另一张卡被标记为“ SQL”。每张卡可以具有许多标签，鉴于技术如何频繁重叠，这很有用。</p><p> Over time you will build up a repository of knowledge on programming, cleanly categorized, easily searchable and regularly backed up in the cloud. Keeping a repository like this is useful, but it doesn’t do anything to help you keep the knowledge inside your head. The key to this is doing your Ankis.</p><p> 随着时间的流逝，您将建立一个有关编程的知识库，该库具有清晰的分类，易于搜索的功能，并定期在云中备份。保持这样的存储库很有用，但是它并不能帮助您将知识保持在头脑中。这样做的关键是做Ankis。</p><p> Every morning Anki calculates which cards you risk forgetting, and then prompts you to review these cards. Doing your Ankis only takes a few minutes per day, since you only need to review a fraction of your deck on any given day.</p><p> 每天早上，Anki都会计算出您可能会忘记的卡，然后提示您检查这些卡。每天只需要花费几分钟的时间进行Ankis，因为您只需要在给定的一天中检查甲板的一小部分即可。</p><p>  For every card you review, Anki shows you the question side with the answer side initially blocked out. Your job is to answer the question in your head, and then reveal the answer and check whether you got it right. After you answer, four buttons appear at the bottom of the screen: “again”, “good”, “easy” and “very easy”. Assess how easily you could recall that card and then press the appropriate button. Based on which button you press, Anki determines when next to show you that card, so answering honestly is crucial if you want the algorithm to work.</p><p>对于您审阅的每张卡片，Anki会向您显示问题面，而答案面最初被遮挡。您的工作是在脑海中回答问题，然后揭示答案并检查您是否正确。回答后，屏幕底部将出现四个按钮：“再次”，“良好”，“简单”和“非常简单”。评估召回该卡的难易程度，然后按相应的按钮。根据您按下的按钮，Anki会确定下一次向您显示该卡片的时间，因此，如果您希望算法有效，那么诚实回答至关重要。</p><p>    Most people fail to learn programming for the same reason they don’t get good at playing guitar: they give up too soon. Although they practice hard for the first few weeks, they soon lose motivation, and give up before they get results.</p><p>    大多数人由于不擅长弹吉他的相同原因而无法学习编程：他们放弃得太早。尽管他们在开始的几周内都很努力，但很快就会失去动力，并在获得结果之前就放弃了。</p><p> Trying to learn using a rhythm of intense activity over short periods of time followed by long pauses is problematic. Your mind needs time to absorb what it learns, so learning skills cannot be condensed into a weekend. By accepting this reality and using a learning approach that emphasizes incremental daily effort, you will be less likely to burn out and more likely to succeed.</p><p> 尝试在短时间内使用激烈的运动节奏学习，然后长时间停顿是有问题的。您的大脑需要时间来吸收所学内容，因此学习技巧不能凝结到周末。通过接受这种现实并使用强调每天增加工作量的学习方法，您将更不会感到筋疲力尽，更可能成功。</p><p> The second rule of  Janki encourages a commitment to daily learning:  “You must use Anki every single day - including weekends and holidays - and commit to doing so indefinitely.”</p><p> Janki的第二条规则鼓励对日常学习的承诺：“您必须每天（包括周末和节假日）每天使用Anki，并无限期地这样做。”</p><p> Doing your Ankis must hold the same force of habit as brushing your teeth, and you should feel naughty if you ever miss your Ankis.</p><p> 做Ankis必须保持与刷牙相同的习惯力，如果您想念Ankis，应该感到调皮。</p><p> Rule 2 isn’t as demanding as it might at first seem. After a few months of practice you will be able do your Ankis in 5-8 minutes. Finding that time shouldn’t be a problem either, since Anki is available on smart-phone, meaning you can review while you walk to work, sit in the bus or have a spare minute at the office. Anki even synchronizes the state of your decks across all your devices, so changes to your desktop deck will be reflected across all of your devices.</p><p> 规则2并不像乍看起来那样苛刻。经过几个月的练习，您将可以在5-8分钟内完成Ankis。由于Anki可在智能手机上使用，因此找到时间也不是问题，这意味着您可以在上班，坐公交车或在办公室空闲时进行检查。 Anki甚至可以在所有设备上同步存储卡状态，因此对桌面存储卡的更改将反映在所有设备上。</p><p>  Learning out of context is wasteful. Reading a textbook from cover to cover may be interesting, but if those concepts are not relevant to the technical problems you currently face, then you will lack the mental context needed to assimilate that knowledge effectively. Incomplete understanding and wasted effort ensues.</p><p>  脱离上下文学习是浪费的。从头到尾阅读一本教科书可能会很有趣，但是如果这些概念与您当前面临的技术问题不相关，那么您将缺乏有效吸收该知识所需的心理环境。随之而来的是不完全的理解和浪费的精力。</p><p> The third rule of  Janki keeps you focused on what is important in the moment:  “Learn in context. Pick a project, and learn only what you need to get it done.”</p><p>Janki的第三条规则使您专注于当前重要的事情：“在上下文中学习。选择一个项目，然后仅了解完成任务所需要的内容。”</p><p> When I was writing this blog post I didn’t know how to add images in the Textile language.</p><p> 当我写这篇博客文章时，我不知道如何用纺织语言添加图像。</p><p>     Step 3: After checking that it worked, I added my new technique to my Anki Deck.</p><p>     第3步：检查它是否有效后，我将新技术添加到了Anki Deck。</p><p>   “I learned about sex the hard way – from a book.”  Eddie Izzard</p><p>   “我从书本上很难学到性。”埃迪·伊扎德（Eddie Izzard）</p><p> Like sex, programming is better and more enjoyably mastered through practice. Learning without practice insulates you from reality.</p><p> 像性一样，编程可以更好地通过练习来掌握。没有实践的学习会使您与现实隔离。</p><p> When you read about programming without trying out the code, you form an internal representation that is incomplete, poorly understood, and difficult to apply practically.</p><p> 当您在不尝试代码的情况下阅读有关编程的内容时，您会形成一个内部的表示形式，该表示形式是不完整的，难以理解的并且难以实际应用。</p><p> You will fail to notice critical details. Many things may seem trivial when you first read about them in a textbook. Maybe it’s the placing of quotations around a parameter to a function, or rules about where whitespace is allowed. These overlooked points can often be critical in practice, and anything less than complete understanding will cripple your productivity. It is only by trying code out that you will notice the nuances of these rules, and really understanding the language, techniques, and commands in question.</p><p> 您将不会注意到关键细节。当您第一次在教科书中阅读许多内容时，它们似乎显得微不足道。也许是引号放在函数的参数周围，或者是关于允许空格的规则。这些被忽略的观点在实践中通常很关键，而任何不完全理解的事情都会削弱您的生产力。仅通过尝试编写代码，您将注意到这些规则的细微差别，并真正理解了所涉及的语言，技术和命令。</p><p> The fourth rule of  Janki grounds knowledge in reality:  “Only add a card to your deck after having tried to use the item of knowledge therein.”</p><p>Janki的第四条规则基于现实中的知识：“只有在尝试使用其中的知识项目后，才能在卡片组中添加卡片。”</p><p> Say you are working on an application powered by an SQL database. To build it you will need to refer to literature on database design and SQL (a query language for selecting records from database tables). As you work on the application you will be exposed to new concepts. Try out each new nugget of knowledge before adding it to your Anki deck. If, for example, you read about how to delete a row in a database table, then you should try deleting an actual row in your database before creating the Anki card detailing that SQL query.</p><p> 假设您正在使用由SQL数据库驱动的应用程序。要构建它，您将需要参考有关数据库设计和SQL（用于从数据库表中选择记录的查询语言）的文献。在处理应用程序时，您将接触到新概念。在将其添加到Anki平台之前，请尝试每种新知识。例如，如果您了解如何删除数据库表中的行，那么在创建详细说明该SQL查询的Anki卡之前，应尝试删除数据库中的实际行。</p><p>  Our past mistakes serve as excellent memory aids. This is a major reason why we learn by doing. That said, not all past mistakes are equally effective at teaching us lessons; there is a correlation between the emotional impact of an error and the length of time that lesson will remain in memory.</p><p>  我们过去的错误是出色的记忆帮助。这是我们边做边学的主要原因。也就是说，并非所有过去的错误都能同样有效地教给我们教训。错误的情感影响与课程在记忆中保留的时间长度之间存在相关性。</p><p> Say you make a big mistake. You accidentally push incomplete code to a live server, taking your app down for 12 hours. You panic to fix it, and as the customer complaints flood in, you feel stupid and embarrassed. This emotional punishment serves as a strong reminder of your error, and you will be more careful when pushing code to a server in future.</p><p> 假设您犯了一个大错误。您不小心将不完整的代码推送到了活动的服务器，从而使应用程序停机了12个小时。您可能会对此加以恐慌，随着客户投诉的泛滥，您会感到愚蠢和尴尬。这种情感上的惩罚可以强烈提醒您错误，将来在将代码推入服务器时，您将更加小心。</p><p> Errors with emotional impact are, thankfully, rare, and you are unlikely to need  Janki Method to learn from these. But what about the rest of the mistakes we make, where the emotional element is diminished or even absent? We may need to make these mistakes many times before eventually learning our lesson.</p><p> 幸运的是，带有情感影响的错误很少见，您不太可能需要Janki方法来学习这些错误。但是，我们犯下的其他错误呢？在这些错误中，情感因素被减少甚至消失了？在最终学习我们的课程之前，我们可能需要多次犯这些错误。</p><p> Mistake repetition is the number of times you need to commit a particular mistake over a lifetime before learning a permanent lesson. Because mistakes are costly, embarrassing and potentially career threatening, it is sensible to minimize their occurrence. Bosses, customers and co-workers understand a first time mistake, and all but the most unreasonable will forgive you. They will not, however, feel so forgiving the second or third time you get the same thing wrong.</p><p> 错误重复是您在学习永久性课程之前在一生中犯特定错误的次数。由于错误代价高昂，令人尴尬并可能威胁职业生涯，因此将错误的发生率降到最低是明智的。老板，客户和同事都理解第一次犯错，除了最不合理的情况外，其他所有人都会原谅您。但是，他们不会觉得您第二次或第三次弄错同一件事是那么宽容。</p><p> The fifth rule of  Janki method minimizes mistake repetition.  “Every time you make a mistake carry out a post-mortem and try to figure out the lessons in the experience. Think about what you would need to know to prevent that mistake from occurring again, and turn this insight into new flashcards.”</p><p> Janki方法的第五条规则最大程度地减少了错误重复。 “每次您犯错时，都要进行一次验尸，然后尝试找出经验教训。考虑一下您需要了解的信息，以防止再次发生该错误，并将这种见解转化为新的抽认卡。”</p><p> By applying this rule you will substitute real world mistakes with Janki reviews, and you will consequently learn from your mistakes more quickly and with less embarrassment and real world error.</p><p>通过应用此规则，您将用Janki评论代替现实中的错误，因此，您将更快地从错误中学习，并减少尴尬和现实世界中的错误。</p><p> Ankifying your past failures doesn’t just prevent their repetition. It also helps you understand your domain, since the act of performing a post-mortem analysis and examining the underlying causes of your error encourages deep thought. Instead of just creating the cards you need to prevent that particular error, you might immunize yourself against that entire class of error.</p><p> 提醒您过去的失败并不仅仅是防止它们重复发生。它也可以帮助您了解自己的领域，因为执行事后分析和检查错误的根本原因会鼓励您进行深入思考。您不仅可以制作防止发生特定错误的卡片，还可以使自己免受整个错误类别的影响。</p><p> Every mistake becomes a learning experience. Messing up still sucks, but you feel a small sense of victory knowing that you’ve just found a way to improve, and you will feel assured by the certainty that you will never make that mistake again.</p><p> 每个错误都会成为学习经验。一团糟仍然很糟糕，但是您知道自己已经找到了一种改进的方法，就会感到有点胜利感，并且您将确信自己将永远不会再犯该错误。</p><p>  By following the initial five rules of  Janki Method you will quickly become proficient with the low level details of programming: the name and use cases of functions and commands, their expected inputs and expected outputs, solutions to common bugs, and techniques for keeping your code organised.</p><p>  通过遵循Janki Method的前五个规则，您将很快精通编程的底层细节：函数和命令的名称和用例，它们的预期输入和预期输出，常见错误的解决方案以及用于保留代码的技术有条理。</p><p> As your experience grows you will be faced with bigger questions, such as structural decisions about your application, techniques to minimize complexity, workflows for managing simultaneous versions of your code, and the tradeoff between code performance and elegance. Answering these questions requires deep knowledge and sizable experience, and for this reason you must never miss an opportunity to grow your knowledge in these overarching issues.</p><p> 随着经验的增长，您将面临更大的问题，例如有关应用程序的结构决策，使复杂性降至最低的技术，用于管理代码同时版本的工作流以及代码性能与优雅之间的权衡。回答这些问题需要深厚的知识和丰富的经验，因此，您绝不能错过在这些首要问题上发展知识的机会。</p><p> The sixth rule of  Janki method encourages regular critical reflection:  “At the end of every project ask yourself what lessons you learned and what you would do differently if you were to repeat the project with the benefit of hindsight.”</p><p> Janki方法的第六条规则鼓励定期进行批判性反思：“在每个项目结束时，都要问自己自己，如果从后见之明的角度重复该项目，你会学到什么教训，以及会做些什么。”</p><p> After a large project, such as completion of a new app, take some time to reflect. Ask yourself big questions, such as:</p><p> 在完成一个大型项目（例如完成一个新应用程序）之后，需要一些时间来进行反思。问自己一些大问题，例如：</p><p> Did I waste time going down any dead ends? Is there anything I could do in future to help me foresee these, and prevent them from happening again?</p><p>我是否浪费时间去解决任何死胡同？我将来有什么办法可以帮助我预见这些情况，并防止它们再次发生？</p><p>  Did I choose the right technologies? Can I come up with a schema to help me make the right choices next time?</p><p>  我选择了正确的技术吗？我可以提出一个方案来帮助我下次做出正确的选择吗？</p><p>      Can I create a checklist to ease development of that kind of feature in future?</p><p>      我可以创建清单以简化将来开发该功能的情况吗？</p><p> Some of these questions will be difficult to answer because you have to run through alternatives in your head, thinking about the benefits and tradeoffs of each. This effort is worthwhile since sensible architectural decisions prevent wasted effort. Without active reflection you will be less likely to notice these project level patterns, and so your wisdom will grow more slowly than it otherwise would.</p><p> 其中一些问题将很难回答，因为您必须反复思考各种选择，并思考每个选择的好处和取舍。明智的架构决策可避免浪费精力，因此这项工作值得。没有积极的思考，您将不太可能注意到这些项目级别的模式，因此您的智慧将比其他情况增长得慢。</p><p>  Like a front lawn left idle, your Anki decks can grow ugly. Perhaps one of the programming languages you previously learned has changed dramatically in version 2.0 and now a percentage of your cards are invalid. Perhaps some of your cards are no longer worthy of keeping in periodic review – their usefulness doesn’t justify the cumulative revision time needed.</p><p>  就像闲置的前草坪一样，您的Anki甲板会变得难看。您以前学习的一种编程语言可能在2.0版中已发生了巨大变化，现在您的卡中有一部分无效。也许您的某些卡不再值得定期检查-它们的用处并不能证明所需的累积修订时间是合理的。</p><p> As you learn, you will discover simpler ways to understand concepts; without updating your cards to reflect these improved paradigms you risk losing these insights forever. Often a group of cards can be replaced with a single card on a higher order concept.</p><p> 随着学习的进行，您将发现更简单的理解概念的方法。如果不更新您的名片以反映这些改进的范例，您可能会永远失去这些见识。通常，在更高级别的概念上，一组卡可以用一张卡代替。</p><p> Sometimes you will see links between cards in your deck. If you note the connection between these cards you create multiple neural paths to the same item of knowledge. If one path were to fail, you could still arrive at and trigger that knowledge from another route. The ability of mind maps to help you remember works using a similar idea. By looking for and noting these connections in your decks you add a layer of redundancy to your knowledge representation that further insures against future forgetting,</p><p> 有时，您会看到卡组中卡之间的链接。如果您注意到这些卡之间的连接，则会为同一知识项创建多个神经路径。如果一条路径失败了，您仍然可以到达另一条路径并触发该知识。思维导图可以帮助您记住类似想法的作品。通过寻找并注意甲板上的这些连接，您可以为知识表示增加一层冗余，从而进一步确保将来不会遗忘，</p><p> The seventh rule of  Janki keeps your decks in shape.  “Delete or modify any incorrect, outdated, difficult to remember, incomplete or unnecessary cards. Update existing cards as improved understanding dawns.”</p><p>Janki的第七条规则使您的牌组保持身材。 “删除或修改任何错误，过时，难以记住，不完整或不必要的卡片。更新现有卡片，以提高了解的曙光。”</p><p>    Graphic designers, artists, architects and other creatives keep scrapbooks of designs they like. Later, when working on a project, they draw inspiration from these same scrapbooks.</p><p>    平面设计师，艺术家，建筑师和其他创意人员保留自己喜欢的设计的剪贴簿。后来，在进行项目工作时，他们从这些相同的剪贴簿中汲取了灵感。</p><p> As a programmer, your primary source of inspiration will be other people’s code. Download open source projects (e.g. on  Github) and read through the code. Look up parts you don’t understand, and create new cards as necessary. Get a pen and paper, and sketch out the paths through the program. What are the inputs, and what are the expected outputs? What happens to the data as it moves through the program? Why was it designed in this way? What techniques were used?</p><p> 作为程序员，您的主要灵感来源将是其他人的代码。下载开源项目（例如在Github上）并阅读代码。查找您不了解的部分，并根据需要创建新卡片。得到一支笔和纸，并勾画出程序的路径。输入是什么，预期输出是什么？数据在程序中移动时会发生什么？为什么这样设计？使用了哪些技术？</p><p> By reading code you will be exposed to various styles of programming and solutions to programming problems. You will see things you like, and lots of things you don’t like. With time you will find your own style.</p><p> 通过阅读代码，您将了解各种编程风格和编程问题的解决方案。您会看到自己喜欢的事物，以及很多自己不喜欢的事物。随着时间的流逝，您将找到自己的风格。</p><p> The eighth rule of  Janki encourages you to use your readings of other people’s code as a source of learning:  “Read code regularly. If you come across something interesting – be that an algorithm, a hack, or an architectural decision - create a card detailing the technique and showing the code.”</p><p> Janki的第八条规则鼓励您使用他人代码的阅读作为学习的来源：“定期阅读代码。如果您遇到有趣的事情-是算法，黑客或体系结构决策-请创建一张详细说明技术并显示代码的卡片。”</p><p>  My initial goal with using Anki to learn was to stop myself from forgetting, and Anki delivered on this promise. What I wasn’t expecting was the secondary advantages that emerged through long term daily use.</p><p>  使用Anki进行学习的最初目标是阻止自己遗忘，Anki兑现了这一诺言。我没想到的是长期日常使用所带来的次要优势。</p><p>  Knowing thousands of commands saves time otherwise spent looking up reference materials. You instantly recall previous solutions when faced with a problem, and dozen of possibilities spring to mind when architecting a system. You will read other people’s code rapidly, confident in your understanding. The closest analogy is fluency in a natural language. You will speak code.</p><p>  知道数千个命令可以节省时间，而不必花费大量时间查找参考资料。遇到问题时，您会立即想起以前的解决方案，而在构架系统时会想到许多可能性。您将快速阅读他人的代码，并对自己的理解充满信心。最接近的类比是自然语言的流利程度。您将说出代码。</p><p> Most of the time I spend programming is spent debugging, that is fixing errors in your code or in the code of other programmers. This is where a deep knowledge of the platform will speed you up the most. Debugging consists chiefly of gathering information. What was the system supposed to do? What data was in the system when we saw the error? What could have gone wrong? Frequently a single delinquent line of code can be the cause of a bug that takes down an entire site. The hard part is figuring out which of the thousands of lines of logic caused the issue.</p><p>我花在编程上的大部分时间都花在了调试上，即修复您的代码或其他程序员的代码中的错误。在这里，对平台的深入了解将最大程度地提高您的速度。调试主要包括收集信息。该系统应该做什么？当我们看到错误时，系统中有什么数据？可能出了什么问题？通常，一条拖欠的代码行可能是导致整个网站崩溃的错误的原因。困难的部分是找出数千行逻辑中的哪一条导致了该问题。</p><p> Let’s take an example. Say your program uses 100 functions and 70 of these are built into the language. That means that there were 30 custom defined functions. If you know with confidence the inputs and outputs of the 70 built-in functions, then debugging is simplified, since you will only need to figure out how the remaining 30 custom functions work. Considering that custom functions are themselves defined in terms of built-ins, this task should not take too long either. Total certainty about the syntax, inputs, outputs, and uses of the built-in functions lets you quickly isolate unknowns and bring the bug to surface.</p><p> 让我们举个例子。假设您的程序使用了100个函数，而其中的70个已内置到该语言中。这意味着有30个自定义函数。如果您满怀信心地知道70个内置函数的输入和输出，那么调试将得到简化，因为您只需要弄清楚其余30个自定义函数是如何工作的。考虑到自定义函数本身是根据内置函数定义的，因此此任务也不应该花费太长时间。关于内置函数的语法，输入，输出和使用的完全确定性，使您可以快速隔离未知内容并将错误暴露出来。</p><p> Brainstorming ability is improved through  Janki Method. Deep knowledge in mind means you can try out alternatives on paper rapidly and so increase your chances of coming across a cheeky non-obvious solution to your problem.</p><p> 通过Janki方法提高了头脑风暴的能力。深入的知识意味着您可以在纸上快速尝试替代方案，从而增加遇到麻烦的，显而易见的解决方案的机会。</p><p> You might argue that you will get the same speed boost with knowledge earned through experience. That is true, but this argument misses the point. Janki enables you to gain that same knowledge faster, and retain it for longer. If you’ve ever forgotten how to do something after leaving it aside for a few months, then Anki is for you.</p><p> 您可能会争辩说，通过经验获得的知识将使您获得同样的速度提升。没错，但是这种说法没有讲到重点。 Janki使您可以更快地获得相同的知识，并将其保留更长的时间。如果您忘了几个月后却忘记了如何做某事，那么Anki就是您的最佳选择。</p><p>  Skill in a technical field is the product of your intelligence and your knowledge. Weakness in one can be overshadowed by strength in another. Bright yet inexperienced can perform on par with dull yet experienced.</p><p>  技术领域的技能是您的才智和知识的产物。一个人的弱点可能被另一个人的力量所掩盖。聪明但经验不足的人可以和乏味而经验丰富的人相提并论。</p><p> This point is best illustrated by example. Let’s multiply 130 by 30 using two approaches.</p><p> 最好通过示例说明这一点。让我们使用两种方法将130乘以30。</p><p> Approach 1: You know that multiplication is repeated addition, and so the problem becomes 130 + 130 + 130… and so on. Applying the rules of addition you arrive at 3900 - eventually. Let’s call intelligence your ability to carry out these individual calculations quickly.</p><p> 方法1：您知道乘法是重复加法，因此问题变为130 + 130 + 130…依此类推。应用加法规则，您最终将获得3900。让我们将智慧称为快速执行这些单独计算的能力。</p><p> Approach 2: Perhaps you remember from your multiplication tables in school that 13 X 3 is 39. You might also remember that the commutative and associative properties of multiplication let you simplify 130 X 30 to 10 X 13 X 3 X 10 and finally to 39 X 100, which can be calculated trivially as 3900. Your intelligence, or speed of addition here, is irrelevant since domain knowledge let you simplify the problem dramatically.</p><p>方法2：也许您在学校的乘法表中还记得13 X 3是39。您可能还记得，乘法的可交换和关联属性使您可以将130 X 30简化为10 X 13 X 3 X 10并最终简化为39 X 100，可以将其简单地计算为3900。由于领域知识可让您显着简化问题，因此您的智能或添加速度无关紧要。</p><p> In approach 1, the problem was labour intensive because you did not use knowledge to ease your calculation. This wasn’t the case in approach 2, where you reasoned using higher order chunks of knowledge, so solving an otherwise lengthy problem with ease. The application of remembered chunks of knowledge to problems at hand is called  chunking.</p><p> 在方法1中，该问题是劳动密集型的，因为您没有使用知识来简化计算。方法2并非如此，在这种情况下，您会推理使用更高阶的知识块，因此可以轻松解决原本冗长的问题。将记住的知识块应用于眼前的问题称为块化。</p><p> If you remember the answer to a question, you have no need to deduce it in the moment, and so your mind is free to deduce more abstract concepts. This is the value of chunking.</p><p> 如果您记得一个问题的答案，则无需立即推断出它，因此您可以自由地推断出更多抽象的概念。这就是分块的价值。</p><p> Janki Method encourages chunking. This was an unexpected benefit, yet ultimately the most useful to me. After six months of daily application you will reason about programming concepts using mental shortcuts equivalent to those used to simplify the multiplication problem in approach 2. Maximize chunking by adding increasingly abstract rules and concepts to your decks, and making an effort to draw on these ideas when solving problems.</p><p> Janki方法鼓励分块。这是意想不到的好处，但最终对我来说最有用。每天应用六个月后，您将使用与简化方法2中的乘法问题等效的思维捷径来对概念进行编程。通过在平台上添加越来越抽象的规则和概念，并尽量利用这些想法，可以最大程度地实现分块。解决问题时。</p><p>  Has your computer ever spat out an error message and, although you remember seeing it before, you don’t remember how to fix it? Before I started  Janki Method this would happen to me a lot.</p><p>  您的计算机是否发出过错误消息，并且尽管您记得曾经看过它，但是却不记得如何解决它？在我开始使用Janki Method之前，这会在我身上发生很多。</p><p> The first time I saw the issue I would spend half a day solving the problem. Six months later the problem would happen again, perhaps in a slightly different form. Even though I was vaguely aware of having seen it before, I’d forgotten how to fix it.</p><p> 我第一次看到该问题时，会花半天时间解决问题。六个月后，问题可能再次发生，可能形式有所不同。即使我隐约意识到以前已经看过它，但我还是忘记了如何修复它。</p><p> This felt wasteful and I didn’t like it. I don’t like having to solve the same problem twice.  Janki Method helps prevent this from happening.</p><p> 这感觉很浪费，我不喜欢它。我不想两次解决相同的问题。 Janki方法有助于防止这种情况的发生。</p><p> Anki has a search feature that finds all matching cards in your deck. You can even filter by</p><p>Anki具有搜索功能，可以找到您牌组中所有匹配的牌。您甚至可以过滤</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.jackkinsella.ie/articles/janki-method">https://www.jackkinsella.ie/articles/janki-method</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/方法/">#方法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/method/">#method</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/学习/">#学习</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>