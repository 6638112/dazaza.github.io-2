<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Tezos的Merkle树存储量提高了六倍A six-fold improvement in the Merkle tree storage for Tezos</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A six-fold improvement in the Merkle tree storage for Tezos<br/>Tezos的Merkle树存储量提高了六倍</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-25 08:18:08</div><div class="page_narrow text-break page_content"><p>Improving the storage is one of the most effective ways of improving a blockchain node’s overall performance. Blockchain nodes must regularly and continuously access the storage that contains the  blockchain state (also known in Tezos as the  context). The speed at which a node can access this storage affects block application time — a slower storage module will slow down block application, thus constituting a bottleneck for the overall speed and stability of the node.</p><p>改善存储是提高区块链节点整体性能的最有效方法之一。区块链节点必须定期、持续地访问包含区块链状态的存储（在Tezos中也称为上下文）。节点访问该存储的速度会影响块应用时间——较慢的存储模块会降低块应用的速度，从而对节点的整体速度和稳定性构成瓶颈。</p><p> If the storage is not available for some reason, then the application of blocks cannot proceed and the node ‘freezes’. When such freezes happen (which can last many minutes), the node gets stuck until the storage has finished performing its maintenance tasks. If block application takes more than 30 seconds (the time currently allowed for block creation, also known as the  block time), then the baker might not be able to bake the block and they can lose their reward for baking or endorsing.</p><p>如果由于某种原因存储不可用，则块的应用无法继续，节点“冻结”。当发生此类冻结（可能持续数分钟）时，节点会被卡住，直到存储完成其维护任务。如果块应用程序需要超过30秒（当前允许创建块的时间，也称为块时间），那么面包师可能无法烘焙块，他们可能会失去烘焙或背书的奖励。</p><p>  Until now TezEdge supported two different implementations of the context storage, the Octez v11 implementation, and our own Rust-based implementation of a garbage-collected in-memory storage that only keeps the data from the latest 7 cycles.</p><p>到目前为止，TezEdge支持两种不同的上下文存储实现，Octez v11实现，以及我们自己的基于Rust的实现，即只保留最近7个周期的数据的内存中垃圾收集存储。</p><p> Now there is a third option. We’ve developed a persisted context storage that saves the entire Tezos blockchain state on-disk and we have named it the TezEdge v1.15 context storage. This has translated into a major improvement in performance when compared to the Octez v11 implementation:</p><p>现在还有第三种选择。我们开发了一种持久化上下文存储，将整个Tezos区块链状态保存在磁盘上，我们将其命名为Tezos Edge v1。15上下文存储。与Octez v11实现相比，这已经转化为性能上的重大改进：</p><p> The TezEdge v1.15 context storage performs a little over half as much reads (input) and less than a third of writes (outputs) into the disk compared to the Octez v11 implementation. It also has minimum variance, meaning that there are no spikes in reads/writes. You can jump to the section titled  Advanced tracing tool for context storage to see the full details.</p><p>TezEdge v1。15与Octez v11实现相比，上下文存储在磁盘中执行的读取（输入）量略多于一半，写入（输出）量不足三分之一。它还具有最小方差，这意味着读/写没有峰值。您可以跳转到标题为“上下文存储高级跟踪工具”的部分，以查看完整的详细信息。</p><p> Additionally, our implementation does not suffer from the aforementioned freezes. This increases the probability of being able to successfully bake or endorse a block and obtain the reward.</p><p>此外，我们的实现不会受到上述冻结的影响。这增加了成功烘焙或背书一块砖并获得奖励的可能性。</p><p> The next version of  Octez (v13) will feature an improved storage implementation that addresses the issues we have discussed in this article. We are looking forward to working the team behind Octez to publish an updated version of our benchmarks once it is released.</p><p>Octez（v13）的下一个版本将采用改进的存储实现，解决我们在本文中讨论的问题。我们期待着与Octez背后的团队合作，发布我们基准测试的更新版本。</p><p>  If we want to perform any kind of work with a Tezos node, we need to first bootstrap it, meaning that we need to re-process every block of operations, starting with the genesis block and finishing with the block at the head of the chain.</p><p>如果我们想对Tezos节点执行任何类型的工作，我们需要首先引导它，这意味着我们需要重新处理每个操作块，从genesis块开始，以链头的块结束。</p><p> We launched two instances of the TezEdge node while using 16GB of RAM and allowing a maximum storage bandwidth of 300MB/s for both. The only difference between the two instances was that one used our new and improved TezEdge v1.15 storage, while the other used the Octez v11 storage.</p><p>我们启动了TezEdge节点的两个实例，同时使用16GB的RAM，并允许两个节点的最大存储带宽均为300MB/s。这两个实例之间唯一的区别是其中一个使用了我们新的和改进的TezEdge v1。15个存储空间，而另一个使用Octez v11存储空间。</p><p> Bootstrapping a node is limited by two constraints: the Tezos economic protocol and the storage of the node that is being bootstrapped. The  TezEdge v1.15 storage required  44,131 seconds to complete the processing of over 2 million blocks (95.1% bootstrapped). Meanwhile, the  Octez v11 storage needed  295,756 seconds to perform just 75.4% of the storage part of the bootstrapping (1.6 million)</p><p>引导节点受到两个约束：Tezos经济协议和被引导节点的存储。TezEdge v1。15存储需要44131秒才能完成200多万个数据块的处理（95.1%为自举）。同时，Octez v11存储只需要295756秒就可以执行引导过程中75.4%的存储部分（160万）</p><p>       On the right side of the  STORAGE tab you can find the full statistics. Scroll down to the bottom to find the total time, which is the important value here. It is much less in the new TezEdge v1.15 storage, mostly thanks due to its avoidance of freezes. Additionally, one of the reasons the Octez v11 storage implementation spends so much on reads is that it also needs to wait for merges</p><p>在存储选项卡的右侧，您可以找到完整的统计信息。向下滚动至底部以查找总时间，这是此处的重要值。在新的TezEdge v1中，它要少得多。15.储存，主要是因为它避免了冰冻。此外，Octez v11存储实现在读取上花费如此之多的原因之一是它还需要等待合并</p><p> Since our project is developing a Tezos node shell, our focus is on every module that is a part of it. This includes the storage, and optimizing it greatly affects the speed of bootstrapping. The reason why our storage performs so well is that we not only reduced the size of the data necessary for bootstrapping, but we also sped up the rate at which it is processed.</p><p>因为我们的项目是开发一个Tezos节点外壳，所以我们的重点是它的每个模块。这包括存储，优化存储会极大地影响引导速度。我们的存储性能如此之好的原因是，我们不仅减少了引导所需的数据大小，而且还加快了数据的处理速度。</p><p>  In the TezEdge v1.15 context storage, our data files are  append-only, meaning new data can be appended to the storage, but existing data is immutable. Ordinarily, finding values within an unordered data file is done via a linear scan (sequentially checking each value in the list until a match is found or the whole list has been searched). However, such scans tend to be quite expensive for large datasets. Databases usually avoid that by using  indexes.</p><p>在TezEdge v1中。15上下文存储，我们的数据文件仅附加，这意味着新数据可以附加到存储中，但现有数据是不变的。通常，在无序数据文件中查找值是通过线性扫描完成的（顺序检查列表中的每个值，直到找到匹配项或搜索整个列表）。然而，对于大型数据集来说，这种扫描往往相当昂贵。数据库通常通过使用索引来避免这种情况。</p><p> Database indexes are special lookup tables consisting of two columns. The first column is the search key, and the second one is the data pointer. The keys are the values you want to search and retrieve from your database table, and the pointer or reference stores the disk block address in the database for that specific search key. The key fields are sorted so that it accelerates the data retrieval operation for all your queries.</p><p>数据库索引是由两列组成的特殊查找表。第一列是搜索键，第二列是数据指针。键是要从数据库表中搜索和检索的值，指针或引用在数据库中存储特定搜索键的磁盘块地址。对关键字段进行排序，以便加速所有查询的数据检索操作。</p><p> These indexes often are just a sequence of ordered entries, but new entries are added in random order. This means that from time to time, you need to sort the index. This type of maintenance work takes some time, and in some cases, will leave the storage unavailable until it is complete.</p><p>这些索引通常只是一系列有序的条目，但新条目是以随机顺序添加的。这意味着您需要不时地对索引进行排序。这种类型的维护工作需要一些时间，在某些情况下，在完成之前，存储将不可用。</p><p> In the current Octez v11 context storage (Irmin 2.9 for Octez v11) , there is an index that can be used to address any stored object by its hash. This index can grow very big (larger than 70GB for a node containing all the mainnet history right now), which makes its maintenance very costly.</p><p>在当前的Octez v11上下文存储中（对于Octez v11，Irmin 2.9），有一个索引可用于通过散列对任何存储对象进行寻址。这个索引可能会变得非常大（对于一个包含所有mainnet历史记录的节点来说，现在的索引大于70GB），这使得它的维护成本非常高。</p><p> The indexes we use in the TezEdge v1.15 only store references to the commits special objects in the storage that contain information about specific versions of the Merkle tree that represents the blockchain state, making them much smaller. They are small enough to be completely loaded and sorted in-memory when the node starts — for instance, the commit index, which is our main one, has less than 100 MB. Such small indexes do not require regular maintenance — the on-disk indexes do not have to be sorted. For this reason, the TezEdge v1.15 storage is not susceptible to freezes. Additionally, storing the indexes in-memory improves performance.</p><p>我们在TezEdge v1中使用的索引。15只在存储中存储对提交特殊对象的引用，这些对象包含有关表示区块链状态的Merkle树的特定版本的信息，从而使它们小得多。它们足够小，可以在节点启动时在内存中完全加载和排序——例如，提交索引（我们的主索引）的大小不到100 MB。这样的小索引不需要定期维护——磁盘上的索引不需要排序。由于这个原因，TezEdge v1。15.储存不易结冰。此外，将索引存储在内存中可以提高性能。</p><p> This works because in Tezos, the storage objects are never addressed directly, but instead are reached by traversing a  Merkle tree that begins at the commit object. In addition to this, objects in the tree always reference other objects by their offsets in the database file, not by their hash. This avoids one costly indirection when trying to find objects in the store.</p><p>这是因为在Tezos中，存储对象从不直接寻址，而是通过遍历从提交对象开始的Merkle树来访问。除此之外，树中的对象总是根据其在数据库文件中的偏移量而不是哈希值来引用其他对象。这避免了在商店中查找对象时进行一次代价高昂的间接操作。</p><p> The next version of the Octez context storage (Irmin 3.0) will also implement a solution to the big indexes problem similar to what we described here.</p><p>Octez上下文存储的下一个版本（Irmin 3.0）也将实现一个解决大索引问题的解决方案，类似于我们在这里描述的。</p><p> Tracing and preventing high latency calls that threaten baking rewards by reducing latencies in the context storage</p><p>通过减少上下文存储中的延迟来跟踪和防止威胁存储回报的高延迟调用</p><p> Since blocks in Tezos have to be baked within 30 seconds, bakers may lose out on the baking or endorsement reward if a call (such as a commit) takes too much time. This tends to happen when the storage suffers from the spikes we discussed earlier in the article.</p><p>由于Tezos的积木必须在30秒内烘焙，如果一个电话（如提交）花费太多时间，面包师可能会失去烘焙或代言奖励。当存储遇到本文前面讨论的峰值时，就会发生这种情况。</p><p> This is why our primary goal is to reduce the latency of calls — so that no individual call causes bakers to lose their reward by taking too much time. Our secondary goal is to reduce the total time these calls take so that the node’s storage performs better.</p><p>这就是为什么我们的主要目标是减少通话延迟——这样就不会有个别通话导致面包师因为花费太多时间而失去奖励。我们的第二个目标是减少这些调用所需的总时间，以便节点的存储性能更好。</p><p> We’ve developed an advanced tracing tool for calls made in the storage. We can use this tool to compare storage implementations and we can even select any past or current protocol.</p><p>我们开发了一种先进的跟踪工具，用于跟踪存储中的通话。我们可以使用这个工具来比较存储实现，甚至可以选择任何过去或当前的协议。</p><p>     From the top downwards, underneath the highlighted  STORAGE tab, you can first see that the Current context is  irmin, meaning that the statistics displayed are for the Octez v11 context storage.</p><p>从顶部向下，在突出显示的存储选项卡下方，您首先可以看到当前上下文是irmin，这意味着显示的统计信息是针对Octez v11上下文存储的。</p><p> Underneath that is a list of all Tezos protocols. Let’s select Hangzhou, the latest protocol, because that is what bakers are currently using.</p><p>下面是所有Tezos协议的列表。让我们选择杭州，最新的协议，因为这是面包师目前正在使用的。</p><p>  From left to right, first, we see the name for the type of action, this graph is for all  COMMIT calls.</p><p>从左到右，首先，我们看到操作类型的名称，这个图代表所有提交调用。</p><p>        The graph is organized into vertical rows of blocks. Each vertical row represents calls made within a specific range of time as described in the x axis titled  Duration of call.</p><p>图形被组织成垂直的块行。每个垂直行表示在特定时间范围内进行的通话，如标题为“通话持续时间”的x轴所述。</p><p>    The grey squares denote that the calls have an adequate duration. Orange squares denote durations that are longer than usual, and red squares denote that the duration is too long and will pose a risk to baking rewards.</p><p>灰色方块表示通话有足够的持续时间。橙色方块表示持续时间比平时长，红色方块表示持续时间太长，会给烘焙奖励带来风险。</p><p>  In this screenshot, we can see that there are 82 calls that are in the &gt;100 second range. Since block creation has a 30 second constraint, such a large number of &gt;100s calls will prevent blocks from being applied, which means baking and endorsement rewards will be lost.</p><p>在这个屏幕截图中，我们可以看到&gt；100秒射程。由于块创建有30秒的限制，因此；100秒呼叫将阻止应用区块，这意味着烘焙和背书奖励将丢失。</p><p>  As described previously, we have not only significantly sped up the rate at which the data is read and written, but we have also reduced the amount of data that has to be read from or written into the node’s hard disk.</p><p>如前所述，我们不仅大大加快了数据的读取和写入速度，而且还减少了必须从节点硬盘读取或写入的数据量。</p><p> Reducing the amount of data that has to be written and read is particularly valuable for major baking services who use enterprise-level SSDs in the servers on which they run their nodes.</p><p>对于在运行节点的服务器中使用企业级SSD的大型烘焙服务公司来说，减少必须写入和读取的数据量尤其有价值。</p><p> SSDs have a limited lifespan that is further shortened by storing data onto them, with the reduction in lifespan being proportionate to the volume of data stored. Therefore reducing the amount of data that has to be written onto the hard disks used in baking allows them to last longer.</p><p>SSD的寿命有限，通过将数据存储到SSD上，寿命会进一步缩短，寿命的缩短与存储的数据量成正比。因此，减少在烘焙过程中必须写入硬盘的数据量可以延长硬盘的使用时间。</p><p> This will become even more important in the future as the size of blockchain data and the requirements for storage will exponentially grow.</p><p>随着区块链数据的规模和存储需求将呈指数增长，这在未来将变得更加重要。</p><p>  We’ve launched two instances of the TezEdge node, one using the Octez v11 storage implementation while the other uses the new TezEdge v1.15 context storage. You can view each instance via the in-browser TezEdge explorer:</p><p>我们已经发布了两个TezEdge节点实例，一个使用Octez v11存储实现，另一个使用新的TezEdge v1。15上下文存储。您可以通过浏览器中的Edge explorer查看每个实例：</p><p>      The node running with the  the Octez v11 context storage used by Octez has processed  1620147 blocks and has applied  75.4% of operations.</p><p>运行Octez v11上下文存储的节点已处理1620147个块，并应用了75.4%的操作。</p><p> The node running with the  TezEdge v1.15 context storage has processed  2039622 blocks and applied  95.1% of operations</p><p>与边缘v1一起运行的节点。15上下文存储处理了2039622个块，并应用了95.1%的操作</p><p> Although the system overview tab begins with a graph for CPU and then RAM, in this article, we begin with a comparison of  STORAGE I/O, because this is the most important graph in terms of the storage’s overall performance, and how much it affects successful baking and endorsing.</p><p>虽然system overview（系统概述）选项卡以CPU和RAM的图表开始，但在本文中，我们首先比较存储I/O，因为这是存储整体性能方面最重要的图表，以及它对成功烘焙和认可的影响程度。</p><p>      Please note that here the cursor is intentionally placed on a spike in both graphs. Additionally, the y axis of the Octez v11 storage chart stops at 400MB while the TezEdge v1.15 storage stops at 200MB.</p><p>请注意，在这两个图中，光标都是故意放在尖峰上的。此外，Octez v11存储图表的y轴停止在400MB，而边缘v1。15个存储站的容量为200MB。</p><p> The  input/output of the TezEdge v1.15 storage is significantly lower than that of the old version of the storage. The important values here are:</p><p>边缘v1的输入/输出。15存储空间明显低于旧版本的存储空间。这里的重要价值是：</p><p> Validators — read per second, which in the TezEdge v1.15 storage is a bit more than half of what it is in the Octez v11 storage, and</p><p>验证器-每秒读取，这在TezEdge v1中。15存储空间是Octez v11存储空间的一半多一点</p><p> Validators — written per second, which is less than a third of what it is in the Octez v11 storage.</p><p>验证器——每秒写入，不到Octez v11存储中的三分之一。</p><p> While there are a few spikes, they are much less frequent and they never reach the same heights as those in the graph from the Octez v11 storage. The cause of such spikes in Octez v11 storage implementation is the merging of the index, which grows bigger as more blocks are processed.</p><p>虽然有一些尖峰，但它们的频率要低得多，而且它们从未达到Octez v11存储中图表中的高度。Octez v11存储实现中出现这种峰值的原因是索引的合并，随着处理的块越来越多，索引变得越来越大。</p><p>     The value to watch here is the green line marked as  VALIDATORS. Here you can see that the new TezEdge v1.15 storage uses less memory and it also has much less variance — it does not go through ‘spikes’, sudden rises in the use of memory, which, as you can see in the first graph, are very frequent in the Octez v11 storage implementation.</p><p>这里要注意的值是标记为验证器的绿线。在这里你可以看到新的TezEdge v1。15存储使用的内存更少，变化也小得多——它不会出现“峰值”，内存使用量会突然增加，正如您在第一张图中看到的，在Octez v11存储实现中，这种情况非常常见。</p><p> Please note that the large spike in the TezEdge v1.15 RAM graph is caused by the update to protocol 011 Hangzhou. This included a major restructuring of the context tree, which is a very expensive operation. While the new representation of the context tree is better, it takes a while to migrate the past version’s tree to the new one.</p><p>请注意，边缘v1中的大尖峰。15 RAM图是由协议011更新引起的。这包括对上下文树进行重大重组，这是一项非常昂贵的操作。虽然上下文树的新表示形式更好，但将过去版本的树迁移到新版本需要一段时间。</p><p>      Here we can see that the  COMMIT time is faster in the TezEdge v1.15 storage. This is because, during the previously-discussed storage freezes in the Octez v11 storage, actions slow down considerably. Freezes are caused by index maintenance tasks, which do not happen in the TezEdge v1.15 storage. These freezes lead to spikes in latency, which means certain calls can take too long and cause bakers to miss out on their reward for baking or endorsing.</p><p>在这里我们可以看到，在TezEdge v1中提交时间更快。15.储存。这是因为，在之前讨论的Octez v11存储冻结期间，操作会大大减慢。冻结是由索引维护任务引起的，这些任务不会在TezEdge v1中发生。15.储存。这些冻结会导致延迟峰值，这意味着某些呼叫可能会花费太长时间，导致面包师错过烘焙或代言的奖励。</p><p>     Similarly to  COMMIT and  CHECKOUT, the actions  MEM,  MEM TREE and  FIND as well as several others in this row are significantly slower in the Octez v11 storage.</p><p>与提交和签出类似，在Octez v11存储中，MEM、MEM TREE和FIND以及这一行中的其他几个操作的速度要慢得多。</p><p>  You can see the improvement in the performance of the TezEdge v1.15 storage by running two instances of the TezEdge Explorer, one for the node with the Octez v11 storage implementation and the other for the node with the TezEdge v1.15 storage implementation.</p><p>您可以看到TezEdge v1的性能有所改善。15通过运行TezEdge Explorer的两个实例来存储，一个用于使用Octez v11存储实现的节点，另一个用于使用TezEdge v1的节点。15存储实现。</p><p>            In our next release, users will be able to load the in-memory storage that we described in our  past article from a persisted version, which means you won’t have to start processing the entire chain from the beginning each time you start the node. We will also include support for making  snapshots of the Tezos blockchain for quicker bootstrapping. However, please note that our snapshots are not compatible with Octez snapshots.</p><p>在我们的下一个版本中，用户将能够从持久化版本加载我们在上一篇文章中描述的内存存储，这意味着您不必在每次启动节点时从头开始处理整个链。我们还将支持制作Tezos区块链的快照，以便更快地引导。但是，请注意，我们的快照与Octez快照不兼容。</p><p> We hope you have enjoyed our article about the new and improved storage. Feel free to contact me by  email, I look forward to receiving your questions, comments and suggestions. To read more about Tezos and the TezEdge node, please visit our  documentation, subscribe to our  Medium, follow us on  Twitter or visit our  GitHub.</p><p>我们希望您喜欢我们关于新的和改进的存储的文章。请随时通过电子邮件与我联系，我期待收到您的问题、意见和建议。要阅读更多关于Tezos和TezEdge节点的信息，请访问我们的文档、订阅我们的媒体、在Twitter上关注我们或访问我们的GitHub。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/merkle/">#merkle</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/存储/">#存储</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>