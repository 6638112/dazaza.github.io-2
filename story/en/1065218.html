<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们如何用yjs制作jupyter笔记本电脑 How we made Jupyter Notebooks collaborative with Yjs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How we made Jupyter Notebooks collaborative with Yjs<br/>我们如何用yjs制作jupyter笔记本电脑 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-12 06:17:12</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/8618e4a0457814b50011eaa6d27e8dc2.gif"><img src="http://img2.diglog.com/img/2021/6/8618e4a0457814b50011eaa6d27e8dc2.gif" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Collaborative editing —  à la Google Docs — is a feature that you still rarely find in applications. One of the few good things that came out of this pandemic is that more people seem to care about making their applications fit for remote collaboration. Of course, they always cared about real-time collaboration. It’s just a very hard feature to add to your application. It took the Jupyter project several years to land this feature. Finally, they ended up with a solution that is based on the  Yjs Framework which I authored. This article gives an overview of all the work that was put into Jupyter Notebooks and finally describes how we want to make even more components collaborative.</p><p>协作编辑 - àLaGoog文档 - 是一个您仍然很少在应用程序中找到的功能。这种大流行中出现的少数好事之一是，更多的人似乎关心他们的应用程序适合远程协作。当然，他们总是关心实时合作。它只是添加到应用程序的一个非常硬的功能。 jupyter项目几年才占据了这一功能。最后，他们最终获得了一种基于我撰写的YJS框架的解决方案。本文概述了将所有工作放入Jupyter笔记本电脑的工作，最后描述了如何进行更多组件协作。</p><p> Jupyter Notebooks  started in 2011 (back then IPython Notebook) as an effort to make data science reproducible and more accessible by visualizing data dynamically in a notebook. Basically, it allows you to write markdown and code directly in a document. The code can be executed interactively directly from the notebook and shows the result immediately below the code. This is great for data scientists that want to share their research with others. But it’s also a great tool for learning programming because it doesn’t require setting up a programming environment.</p><p> Jupyter笔记本始于2011年（后台，那么iPython Notebook）作为使数据科学可重现的努力，通过在笔记本上动态可视化数据。基本上，它允许您直接在文档中编写Markdown和代码。代码可以直接从笔记本交互方式执行，并在代码下方显示结果。这对于想要与他人分享研究的数据科学家非常棒。但它也是学习编程的一个很好的工具，因为它不需要设置编程环境。</p><p>  Right from the beginning, collaborative editing was on the agenda for Jupyter Notebooks. In 2012, core Jupyter contributor and creator/lead of JupyterHub, @minrk, wrote in the GitHub issue tracker:</p><p>  从一开始，协作编辑是关于Jupyter笔记本的议程。 2012年，Jupyter贡献者和jupyterhub的核心贡献者和创造者/领导，@minrk在github问题跟踪器中写道：</p><p> [..] This will finally make decent live collaboration feasible, which is our  single most-requested and highest-priority new feature.  (source)</p><p> [..]这最终将成为可行的实时合作可行的，这是我们最令人要求的最优先的新功能。 （来源）</p><p> Back then, everyone tried to replicate Google Docs’ collaborative editing functionality. Google Docs was released in 2006 and was the first web application that supported collaborative editing on rich text. In many ways, Google Docs was ahead of its time. It will take years for others to reproduce this functionality. Even today, collaborative editing is far from being ubiquitously available, even though the technology has been available since the ‘80s.</p><p> 然后，每个人都试图复制Google文档的协作编辑功能。 Google文档于2006年发布，是第一个支持丰富文本协作编辑的Web应用程序。在许多方面，谷歌文件在其时间之前。其他人需要数年来复制这个功能。即使在今天，协同编辑也远未普遍可用，即使这项技术已经获得80年代以来。</p><p> No wonder, that the first collaborative Jupyter Notebook implementation,  Colaboratory (or  Colab), was created by Google engineers. They rewrote the UI for Jupyter Notebooks and gave it a collaborative notebook model via Google’s Realtime API, which was  deprecated in 2017. This history underscores how challenging it is to build real-time collaboration into applications: when the Google Realtime API was deprecated, Colab lost its real-time collaboration capabilities, a gap which continues to this day.</p><p> 难怪，第一个协作jupyter笔记本实现，思考人士（或Colab）是由谷歌工程师创建的。他们为Jupyter笔记本重写了UI，并通过Google的RealTime API为它提供了一个协作笔记本模型，它在2017年被推翻了。该历史强调了将实时协作建立到应用程序中的挑战性：当谷歌实时API被弃用时，COLAB失去了实时协作能力，这是一个持续到这一天的差距。</p><p> In 2013 William Stein launched  CoCalc, a Jupyter notebook service with collaborative editing support right from the beginning. Like Colaboratory, CoCalc wrote a new UI for Jupyter Notebooks, while reusing other parts of the Jupyter architecture. They made different choices and implemented a custom solution for conflict resolution. I highly recommend watching the below talk where William Stein shared his experience about the state-of-the-art solutions for shared editing back then.</p><p> 2013年，威廉斯坦·斯坦伊·一家jupyter笔记本服务启动了Cocalc，从一开始就具有协作编辑支持。像Cocalc一样，Cocalc为Jupyter笔记本写了一个新的UI，同时重用了Jupyter架构的其他部分。他们制作了不同的选择，并为冲突解决了定制解决方案。我强烈建议观看下面的谈话，威廉斯坦威廉斯坦分享了他对近期共享编辑的最先进解决方案的经验。 </p><p>  Still, the open-source JupyterLab project didn’t include collaborative editing. What follows is  a series of discussions about the best shared-editing solution to integrate into Jupyterlab to make collaborative editing available to the users of the open-source project. In 2017 Brian Granger, Chris Colbert, and Ian Rose shared their work that integrated the Google Realtime API into the existing JupyterLab project, where they showed  an awesome demo of what collaborative editing could become.</p><p>仍然，开源jupyterlab项目不包括协作编辑。以下是一系列关于集成到jupyterlab的最佳共享编辑解决方案的一系列讨论，以对开源项目的用户提供协作编辑。 2017年Brian Granger，Chris Colbert和Ian Rose分享了他们的工作，将Google Realtime API集成到现有的Jupyterlab项目中，在那里他们表现出一个很棒的演示，可以成为协作的编辑可能成为什么。</p><p>  During my research, I found several PRs by Ian Rose that separated the view (how the Jupyter editor is rendered) from the model (how the data is represented). I haven’t talked to him, but I assume what he found is that it is helpful to have observable data structures that can be synced using some framework for conflict resolution. In this case, he just happened to use the Google Realtime API for synchronization. His work included the abstract factory  IModelDB for creating observable data structures that are used to this day. In theory, one just needs to implement the IModelDB interface with observable data structures that synchronize automatically through some real-time API.</p><p>  在我的研究期间，我发现Ian Rose的几个PRS分开了视图（如何如何从模型中渲染Jupyter编辑器）（如何表示数据）。我没有跟他说过话，但我认为他发现的是，具有可以使用一些冲突解决框架同步的可观察数据结构是有助于的。在这种情况下，他刚刚碰巧使用Google Realtime API进行同步。他的工作包括抽象的工厂iModeldB，用于创建习惯的可观察数据结构。理论上，只需要使用一些实时API自动同步的可观察数据结构来实现IModeldB接口。</p><p> But the provided solution was still based on a proprietary API that requires you to hand over your data to Google services. So the Jupyter community was looking into implementing their own solution for conflict resolution. Different people started to explore Concurrent Replicated Data Types (“CRDTs”) for automatic conflict resolution on their observable data structures. This technology has become very popular in recent years as a solution to synchronize data that can be manipulated by many peers at the same time. If you are interested in the topic, I recommend reading some introductory material on  https://crdt.tech/.</p><p> 但是，提供的解决方案仍然基于专有的API，要求您将数据交给Google服务。因此，Jupyter社区正在研究实施自己的冲突解决方案。不同的人开始探索同时复制的数据类型（“CRDT”），以在其可观察数据结构上自动冲突解决方案。近年来，这项技术变得非常受欢迎，作为同时同时由许多同行设备操纵的数据的解决方案。如果您对该主题感兴趣，我建议在https://crdt.tech/上读取一些介绍材料。</p><p> Lumino (formerly PhosphorJS) is a JS toolkit that underlies the JupyterLab IDE, by providing a rich toolkit of widgets, layouts, events, data structures, and a plugin system at the foundation of the JupyterLab extension system. Specifically for our use-case, it provides observable data structures that are used as a model for all Jupyter packages. In 2017, Chris Colbert started the ambitious endeavor to build high-performance CRDT data structures that can be used as an observable data model. In theory, we could have used that to make any application, that is based on Jupyter data structures, collaborative. Although the Lumino CRDT is little known, to this day it remains the second-fastest CRDT implementation that works on the web.</p><p> Lumino（以前磷光体）是一个JS工具包，它通过在Jupyterlab扩展系统的基础上提供富有小部件，布局，事件，数据结构和插件系统的富有窗口小部件，布局，事件，数据结构和插件系统来提升Jupyterlab IDE。专为我们的用例而言，它提供了可观察数据结构，该结构用作所有Jupyter包的型号。 2017年，Chris Colbert开始雄心勃勃的努力来构建可用作可观察数据模型的高性能CRDT数据结构。从理论上讲，我们可以使用它来制作任何应用程序，这是基于Jupyter数据结构的协作。虽然Lumino CRDT很少知道，但到这一天它仍然是在网上工作的第二最快的CRDT实现。</p><p>  In 2019, Vidar Tonaas Fauske, Ian Rose, and Saul Shanabrook started work to integrate the Lumino CRDT into JupyterLab. Their work lived for a time in  JupyterLab#6871 and has later been moved to a separate repository  JupyterLab/rtc.</p><p>  2019年，Vidar Tonaas Fauske，Ian Rose和Saul Shanabrook开始工作，将Lumino CRDT融入Jupyterlab。他们的工作在Jupyterlab＃6871中居住了一段时间，后来已被移动到单独的存储库Jupyterlab / RTC。</p><p> This is basically where I come in. While the Lumino CRDT is pretty awesome, in 2020 Brian Granger created a  Lumino CRDT performance benchmark that revealed critical performance and algorithm issues (such as the so-called  interleaving anomoly). In the process, Brian discovered my CRDT implementation Yjs and the two of us began to discuss CRDT implementations and Yjs in particular.</p><p> 这基本上是我进来的地方。虽然Lumino CRDT非常令人敬畏，但在2020年，Brian Granger创建了一种亮相CRDT性能基准，揭示了关键的性能和算法问题（例如所谓的交织Anomoly）。在这个过程中，Brian发现了我的CRDT实现YJS，我们两个人开始讨论CRDT实现和YJS。</p><p> To add collaborative editing functionality rivaling Google Docs, we need a bunch of features aside from automatic conflict resolution. For example, we expect that we never revert changes from other users when we hit the undo button. So we need a selective undo-manager that somehow ignores changes from remote users. Something like this is really hard to implement correctly on top of a CRDT.</p><p> 要添加对竞争对手的协作编辑功能，我们需要一堆功能，除了自动冲突解决方案。例如，我们预计我们在撤消撤消按钮时我们从未恢复其他用户的变更。因此，我们需要一个选择性撤消管理器，以某种方式忽略远程用户的变化。这样的东西真的很难在CRDT之上正确实施。 </p><p> Brian eventually asked me to work with  QuantStack to bring collaborative editing to JupyterLab. Yjs has ready-to-use solutions for most problems related to building collaborative applications and is the only CRDT implementation that beats the Lumino CRDT in performance.</p><p>布莱恩最终让我与QuantStack一起使用，为Jupyterlab带来合作编辑。 YJS拥有现成的解决方案，适用于与构建协作应用有关的大多数问题，并且是唯一的CRDT实现，可在性能中击败Lumino CRDT。</p><p>  When I heard that JupyterLab was pushing for collaborative editing for 8 years, I was determined to produce results as fast as possible. I appreciate all the work that came before me because the codebase was already clearly separating the view from the model. My work was just to exchange the existing observable data structures with Yjs’ shared types (which is a fairly similar concept). After one month of work, I was able to produce the first prototype.</p><p>  当我听说Jupyterlab推动了8年来推动合作编辑时，我决定尽可能快地生产结果。我很欣赏我面前的所有工作，因为CodeBase已经清楚地将视图与模型分开。我的工作只是为了用YJS的共享类型（这是一个相当类似的概念）交换现有的可观察数据结构。在一个月的工作之后，我能够生产第一个原型。</p><p>  But there was a problem. Another group, led by Eric Charles, also acquired funding to work on collaborative editing and they chose another approach. While I simply replaced the existing observable data structures, they were trying to reuse the existing data structures. I wanted to make full use of Yjs’ features and didn’t want to build extra abstraction layers just to be able to switch to another CRDT implementation. For some time, it seemed we could not reconcile our approaches.</p><p>  但有一个问题。另一组由Eric Charles领导，也获得了在协作编辑上工作的资金，并选择另一种方法。虽然我简单地替换了现有的可观察数据结构，但他们试图重用现有的数据结构。我想充分利用YJS的功能，不想建立额外的抽象层，以便能够切换到另一个CRDT实现。有一段时间，似乎我们无法调和我们的方法。</p><p> After many discussions with Eric, we finally came up with a compromise that I’m now really excited about. Yjs and ModelDB only provide raw data structures to build collaborative applications. Our plan was to build a notebook model with an easy-to-use API to manipulate, observe, and synchronize changes on the notebook. This would make it possible for other applications to keep compatibility with JupyterLab without forking the whole JupyterLab repository. My hope is that other notebook-related products like CoCalc or VSCode will eventually use this collaborative model to provide cross-compatibility with other Jupyter services. Everything collaborative, of course.</p><p> 经过许多与埃里克讨论后，我们终于提出了一个妥协，即我现在真的很兴奋。 YJS和ModeldB仅提供原始数据结构来构建协作应用程序。我们的计划是建立一个笔记本模型，易于使用的API来操作，观察和同步笔记本电脑上的更改。这将使其他应用程序可以保持与JupyterLab的兼容性，而不会刻到整个Jupyterlab存储库。我的希望是，像Cocalc或Vscode这样的其他笔记本相关的产品最终将使用该协作模型与其他Jupyter服务提供交叉兼容性。当然，一切协作。</p><p> Since February Eric Charles, Carlos Herrero, Jeremy Tuloup, and I have been working on designing and integrating this collaborative model into JupyterLab. Others can use the  @jupyterlab/shared-models package from the npm registry to build their own interfaces for Jupyter Notebooks using the same shared editing technology. Our changes have finally been merged into JupyterLab and are already available in the alpha releases of JupyterLab v3.1.0. Simply start JupyterLab with the  --collaborative flag to enable collaborative editing.</p><p> 自2月Eric Charles，Carlos Herrero，Jeremy Tuloup，我一直在努力设计和将这种协作模型集成到Jupyterlab中。其他人可以使用NPM注册表中的@ jupyterlab / shared模型包，使用相同的共享编辑技术为Jupyter笔记本电脑构建自己的接口。我们的更改终于合并为Jupyterlab，并且已经在jupyterlab v3.1.0的Alpha版本中提供。只需启动jupyterlab与--collaborative标志即可启用协作编辑。</p><p>  Making the separation between model and shared data structure has been quite a revelation for me. Yjs’ shared types are very powerful and allow you to make any kind of application collaborative. But shared models that define an application-specific API make it easier for developers to manipulate the data without understanding how the data is represented in the CRDT. This is particularly relevant because CRDT implementations are almost always schemaless ( Cambria being the exception). A well-maintained model could ensure that the model is compatible with previous versions. In the future, I want to define more shared models for things that are not trivial to represent in Yjs like calendars, contacts, drawings, and graphs.</p><p>  使模型与共享数据结构之间的分离对我来说是一个令人兴奋的。 YJS的共享类型非常强大，并允许您制作任何类型的应用程序协作。但是，定义特定于应用程序的API的共享模型使开发人员更容易操作数据而不了解数据如何在CRDT中表示数据。这尤其相关，因为CRDT实现几乎总是概要（坎布里亚是例外）。维护良好的模型可以确保模型与以前的版本兼容。在未来，我想为在YJS，与日历，联系人，图纸和图表中表示不普通的事情定义更多共享模型。</p><p>  I’m currently working with  Bartosz Sypytkowski on a Rust implementation of Yjs. The Rust implementation will be the baseline for all other ports of the Yjs CRDT to other languages. Thanks to Pierre-Olivier Simonard and  PyO3 we already have the template to create language bindings from the Yrs CRDT to a Python package “y-py”. In the coming months, we will implement a Python CRDT that is fully compatible with the web-based CRDT that is used in JupyterLab. This will allow for backends and frontends to efficiently exchange data that can be manipulated simultaneously.</p><p>  我目前正在使用Bartosz Sypytkowski对YJS的生锈实施。生锈实现将是YJS CRDT对其他语言的所有其他港口的基线。感谢Pierre-Olivier Simonard和Pyo3，我们已经拥有模板，以从YRS CRDT创建语言绑定到Python封装“Y-PY”。在未来几个月内，我们将实现一个Python CRDT，它与Jupyterlab中使用的基于Web的CRDT完全兼容。这将允许后端和前端能够有效地交换可以同时操纵的数据。 </p><p>  Currently, we still send HTTP PUT requests to save a document to the file system via the Jupyter Server. Once we have the Yjs CRDT working in Python, we will create a Python implementation of the shared notebook model which will allow the Jupyter Server to directly access the collaborative state and synchronize that with the file system. Moreover, this will finally resolve a long-awaited issue that allows the kernel to write the output directly to the notebook without first connecting to a client. Why is that important? This will enable you to run a notebook and then close the browser to run your computations overnight. The kernel will compute the output in the background, and write it to the shared model which is then saved to the filesystem by Jupyter Server.</p><p>目前，我们仍然通过Jupyter Server发送HTTP PRO请求以将文档保存到文件系统。一旦我们在Python工作的YJS CRDT，我们将创建一个Python实现的共享笔记本模型，这将允许Jupyter Server直接访问协作状态并将其与文件系统同步。此外，这将最终解决一段时间已久的问题，允许内核将输出直接写入笔记本，而无需先连接到客户端。为什么这重要？这将使您能够运行笔记本，然后关闭浏览器以运行计算过夜。内核将计算背景中的输出，并将其写入共享模型，然后通过Jupyter Server保存到文件系统。</p><p> We want to provide more than a collaborative text editing experience. Yjs provides the data structures to make any kind of application collaborative. Users of Yjs use it to build collaborative drawing-, and diagraming- solutions.  Relm.us, for example, uses the collaborative data structures that Yjs provides for modeling a 3D world that thousands of users can visit to work together. We are exploring heavily how we can make Jupyter widgets collaborative using the same technology.</p><p> 我们希望提供不仅仅是一种合作的文本编辑体验。 YJS提供数据结构，以制作任何类型的应用程序协作。 YJS的用户使用它来构建协作绘图和图解解决方案。例如，relm.us使用YJS为建模3D世界提供建模的协作数据结构，其中数以千计的用户可以访问一起工作。我们正在探索我们如何使用相同技术使Jupyter小部件进行协作。</p><p> Carlos Herrero is working on a  drawio widget for JupyterLab that automatically synchronizes using a custom shared model that he developed. We want to produce documentation on how you can create custom collaborative widgets for JupyterLab. Jupyter widgets will be able to leverage the rich ecosystem of the Yjs CRDT to create widgets. You want, for example, to add a WYSIWYG rich-text editor widget? Sure, just add the awesome  TipTap editor to your widget, as it already uses Yjs as the default shared editing technology.</p><p> Carlos Herrero正在研究Jupyterlab的Drawio小部件，它使用他开发的自定义共享模型自动同步。我们要生成关于如何为jupyterlab创建自定义协作小部件的文档。 Jupyter小部件将能够利用YJS CRDT的丰富生态系统来创建小部件。例如，您想要添加WYSIWYG Rich-Text Editor小部件？当然，只需将Awesome Tiptap编辑器添加到窗口小部件，因为它已经使用YJS作为默认共享编辑技术。</p><p>  Jeremy Tuloup is working on a WASM-powered JupyterLab distribution that I’m particularly excited about.  JupyterLite runs entirely in the browser using only static assets. The code cells are executed using a WebAssembly-based Python runtime. This is already awesome mad science. Now he integrated our collaborative editing approach but uses WebRTC to synchronize peers without the need to set up a central server for conflict resolution. This gives you an offline-ready, collaborative editing experience without setting up any server. Pretty cool!</p><p>  Jeremy Tuloup正在努力追踪jupyterlab发行版，我特别兴奋。 Jupyterlite仅使用静态资产在浏览器中运行。使用基于WebasseMbly的Python运行时执行代码单元格。这已经很棒了疯狂的科学。现在他整合了我们的协作编辑方法，但使用WebRTC同步对等体，而无需设置冲突解决中的中央服务器。这为您提供了一个离线准备好的协作编辑体验，而无需设置任何服务器。非常酷！</p><p>  I hope this got you excited about the future of Jupyter. For sure, I am.</p><p>  我希望这让你对Jupyter的未来感到兴奋。肯定，我是。</p><p> At last, I hope we can appreciate the amazing open-source work that so many people put into this project. I’m looking forward to a future where people take collaborative editing for granted. It has been a rough road and we all needed to learn our lessons to arrive at a solution that works.</p><p> 最后，我希望我们能够欣赏这么多人进入这个项目的惊人的开源工作。我期待着人们采取合作编辑理所当然的未来。它一直是一条艰难的道路，我们都需要学习我们的课程来达到工作的解决方案。</p><p> Funding acknowledgement: My work on this effort at QuantStack has been funded by Schmidt Futures and the Alfred P. Sloan Foundation through grants to Cal Poly San Luis Obispo.</p><p> 资金承认：我对Quantstack的这项努力的工作已由Schmidt期货和Alfred P. Sloan基金会资助Cal Poly San Luis ObiSpo资助。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.jupyter.org/how-we-made-jupyter-notebooks-collaborative-with-yjs-b8dff6a9d8af">https://blog.jupyter.org/how-we-made-jupyter-notebooks-collaborative-with-yjs-b8dff6a9d8af</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/电脑/">#电脑</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/制作/">#制作</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/notebooks/">#notebooks</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>