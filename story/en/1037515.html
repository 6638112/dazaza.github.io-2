<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Bloom过滤器有效地同步哈希图 Using Bloom filters to efficiently synchronise hash graphs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Using Bloom filters to efficiently synchronise hash graphs<br/>使用Bloom过滤器有效地同步哈希图 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-04 20:58:13</div><div class="page_narrow text-break page_content"><p>This blog post uses  MathJax to render mathematics. You need JavaScript enabled for MathJax to work.</p><p>这篇博客文章使用MathJax渲染数学。您需要启用JavaScript才能使MathJax正常工作。</p><p> In some recent research,  Heidi and I needed to solve the following problem.Say you want to sync a hash graph, such as a Git repository, between two nodes.In Git, each commit is identified by its hash, and a commit may include the hashes of predecessor commits (a commit may include more than one hash if it’s a merge commit).We want to figure out the minimal set of commits that the two nodes need to send to each other in order to make their graphs the same.</p><p> 在最近的一些研究中，海蒂和我需要解决以下问题：假设您要在两个节点之间同步哈希图，例如Git存储库。在Git中，每个提交都由其哈希标识，并且一个提交可能包括以前的提交的哈希值（如果是合并提交，则一个提交可能包含多个哈希）。我们想弄清楚两个节点相互发送的最小提交集，以使它们的图相同。</p><p> You might wonder: isn’t this a solved problem?Git has to do this every time you do  git pull or  git push!You’re right, and some cases are easy, but other cases are a bit trickier.What’s more, the algorithm used by Git is not particularly well-documented, and in any case we think that we can do better.</p><p> 您可能会想：这不是一个解决的问题吗，每次执行git pull或git push时，Git都必须执行此操作！是的，有些情况很简单，但有些情况则比较棘手。 Git使用的算法并不是特别有据可查，无论如何我们都认为我们可以做得更好。</p><p> For example, say we have two nodes, and each has one of the following two hash graphs (circles are commits, arrows indicate one commit referencing the hash of another).The blue part (commit A and those to the left of it) is shared between the two graphs, while the dark grey and light grey parts exist in only one of the two graphs.</p><p> 例如，假设我们有两个节点，每个节点都有以下两个哈希图之一（圆圈是提交，箭头表示一个提交引用了另一个哈希），蓝色部分（提交A及其左侧的提交）是这两个图之间共享，而暗灰色和浅灰色部分仅存在于两个图之一。</p><p>  We want to reconcile the two nodes’ states so that one node sends all of the dark-grey-coloured commits, the other sends all of the light-grey-coloured commits, and both end up with the following graph:</p><p>  我们要协调两个节点的状态，以便一个节点发送所有深灰色的提交，另一个节点发送所有浅灰色的提交，并且最后都得到下图：</p><p>  How do we efficiently figure out which commits the two nodes need to send to each other?</p><p>  我们如何有效地找出两个节点需要发送给彼此的提交？</p><p>  First, some terminology.Let’s say commit A is a  predecessor of commit B if B references the hash of A, or if there is some chain of hash references from B leading to A.If A is a predecessor of B, then B is a  successor of A.Finally, define the  heads of the graph to be those commits that have no successors.In the example above, the heads are B, C, and D.(This is slightly different from how Git defines  HEAD.)</p><p>  首先，用一些术语来说，如果B引用了A的哈希，或者如果B的哈希引用链通向A，则提交A是提交B的前身。如果A是B的前身，那么B是a最后，将图的标头定义为没有后继的提交。在上面的示例中，标头是B，C和D（这与Git定义HEAD的方式略有不同）。 </p><p> The reconciliation algorithm is easy if it’s a “fast-forward” situation: that is, if one node’s heads are commits that the other node already has.In that case, one node sends the other the hashes of its heads, and the other node replies with all commits that are successors of the first node’s heads.However, the situation is tricker in the example above, where one node’s heads B and C are unknown to the other node, and likewise head D is unknown to the first node.</p><p>如果是“快进”情况，对帐算法很容易：也就是说，如果一个节点的头提交了另一个节点已经拥有的提交。在这种情况下，一个节点向另一个节点发送其头的哈希，而另一个节点向另一个节点发送答复所有作为第一个节点头的后继对象的提交。但是，在上面的示例中，情况更加棘手，另一个节点不知道一个节点的头B和C，而第一个节点同样不知道头D。</p><p> In order to reconcile the two graphs, we want to figure out which commits are the latest common predecessors of both graphs’ heads (also known as  common ancestors, marked A in the example), and then the nodes can send each other all commits that are successors of the common predecessors.</p><p> 为了调和两个图，我们想弄清楚哪些提交是两个图的头的最新公共先行者（在示例中也称为公共祖先，在示例中标记为A），然后节点可以相互发送所有是共同的前任的继任者。</p><p> As a first attempt, we can try this: the two nodes send each other their heads; if those contain any unknown predecessor hashes, they request those, and repeat until all hashes resolve to known commits.Thus, the nodes gradually work their way from the heads towards the common predecessors.This works, but it is slow if your graph contains long chains of commits, since the number of round trips required equals the length of the longest path from a head to a common predecessor.</p><p> 第一次尝试，我们可以尝试：两个节点互相发送自己的头；如果那些包含任何未知的前任哈希值，它们会请求这些哈希值并重复执行，直到所有哈希值都解析为已知的提交为止。这样，节点逐渐从头到通用的前任工作，这是可行的，但是如果图形包含很长的图则速度很慢提交链，因为所需的往返次数等于从头到共同的前任的最长路径的长度。</p><p> The “smart” transfer protocol used by Git essentially  works like this, except that it sends 32 hashes at a time in order to reduce the number of round trips.Why 32? Who knows.It’s a trade-off: send more hashes to reduce the number of round trips, but each request/response is bigger.Presumably they decided that 32 was a reasonable compromise between latency and bandwidth.</p><p> Git使用的“智能”传输协议本质上是这样工作的，只是它一次发送32个散列以减少往返次数。为什么32？谁知道。这是一个折衷方案：发送更多的哈希值以减少往返次数，但每个请求/响应都更大。大概他们认为32是延迟和带宽之间的合理折衷。</p><p> Recent versions of Git also support an experimental  “skipping” algorithm, which can be enabled using the   fetch.negotiationAlgorithm config option.Rather than moving forward by a fixed number of predecessors in each round trip, this algorithm allows some commits to be skipped, so that it reaches the common predecessors faster.The skip size grows similarly to the Fibonacci sequence (i.e. exponentially) with each round trip.This reduces the number of round trips to \(O(\log n)\), but you can end up overshooting the common predecessors, and thus the protocol may end up unnecessarily transmitting commits that the other node already has.</p><p> 最新版本的Git还支持实验性的“跳过”算法，可以使用fetch.negotiationAlgorithm配置选项启用该算法。该算法允许跳过某些提交，而不是在每次往返过程中前进一定数量的前任程序。每次往返的跳跃大小都类似于斐波那契数列（即成指数增长）。这将往返次数减少为\（O（\ log n）\），但最终超越了通用的前任，因此协议可能最终不必要地传输了另一个节点已经拥有的提交。</p><p>  In our new paper draft, which we are  making available on arXiv today, Heidi and I propose a different algorithm for performing this kind of reconciliation.It is quite simple if you know how  Bloom filters work.</p><p>  在我们今天可以在arXiv上提供的新论文草案中，我和海蒂（Heidi）提出了另一种算法来执行这种调节，如果您知道Bloom过滤器的工作原理，这很简单。</p><p> In addition to sending the hashes of their heads, each node constructs a Bloom filter containing the hashes of the commits that it knows about.In our prototype, we allocate 10 bits (1.25 bytes) per commit.This number can be adjusted, but note that it is a lot more compact than sending the full 16-byte (for SHA-1, used by Git) or 32-byte (for SHA-256, which is more secure) hash for each commit.Moreover, we keep track of the heads from the last time we reconciled our state with a particular node, and then the Bloom filter only needs to include commits that were added since the last reconciliation.</p><p> 除了发送其头部的哈希值之外，每个节点还构造一个Bloom过滤器，其中包含它知道的提交哈希值。在我们的原型中，我们为每个提交分配10位（1.25字节）。这个数字可以调整，但是请注意与每次提交都发送完整的16字节（对于SHA-1，由Git使用）或32字节（对于SHA-256，这是更安全的）哈希相比，它要紧凑得多。从上次协调状态到特定节点的时间开始，然后Bloom过滤器仅需要包含自上次协调以来添加的提交。 </p><p> When a node receives such a Bloom filter, it checks its own commit hashes to see whether they appear in the filter.Any commits whose hash does not appear in the Bloom filter, and its successors, can immediately be sent to the other node, since we can be sure that the other node does not know about those commits.For any commits whose hash does appear in the Bloom filter, it is likely that the other node knows about that commit, but due to false positives it is possible that the other node actually does not know about those commits.</p><p>当一个节点收到这样的Bloom过滤器时，它会检查自己的提交哈希，以查看它们是否出现在过滤器中。任何哈希没有出现在Bloom过滤器中的提交及其后继，都可以立即发送到另一个节点，因为我们可以确保其他节点不知道这些提交，对于哈希确实出现在Bloom筛选器中的任何提交，其他节点很可能知道该提交，但是由于误报，其他节点很有可能节点实际上不知道那些提交。</p><p> After receiving all the commits that did not appear in the Bloom filter, we check whether we know all of their predecessor hashes.If any are missing, we request them in a separate round trip using the same graph traversal algrorithm as before.Due to the way the false positive probabilities work, the probability of requiring n round trips decreases exponentially as n grows.For example, you might have a 1% chance of requiring two round trips, a 0.01% chance of requiring three round trips, a 0.0001% chance of requiring four round trips, and so on.Almost all reconciliations complete in one round trip.</p><p> 收到所有未在Bloom筛选器中出现的提交后，我们检查是否知道其所有前任哈希值，如果缺少，则使用与之前相同的图遍历算法在单独的往返中请求它们。假阳性概率的工作方式，需要n次往返的概率随n的增长呈指数下降。例如，您可能有1％的机会需要两次往返，有0.01％的机会需要三次往返，有0.0001％的机会需要进行四次往返，等等。几乎所有对帐都在一次往返中完成。</p><p> Unlike the skipping algorithm used by Git, our algorithm never unnecessarily sends any commits that the other side already has, and the Bloom filters are very compact, even for large commit histories.</p><p> 与Git使用的跳过算法不同，我们的算法永远不会不必要地发送另一端已经拥有的任何提交，并且即使对于较大的提交历史记录，Bloom过滤器也非常紧凑。</p><p>  In the paper we also prove that this algorithm allows nodes to sync their state even in the presence of arbitrarily many malicious nodes, making it immune to  Sybil attacks.We then go on to prove a theorem that shows which types of applications can and cannot be implemented in this Sybil-immune way, without requiring any Sybil countermeasures such as  proof-of-work or the centralised control of  permissioned blockchains.</p><p>  在本文中，我们还证明了该算法即使在任意数量的恶意节点存在的情况下也允许节点同步其状态，从而使其不受Sybil攻击的影响，然后继续证明一个定理，该定理表明了哪些类型的应用程序可以和不可以以Sybil免疫方式实施，而无需任何Sybil对策，例如工作量证明或对许可区块链的集中控制。</p><p> All of this is directly relevant for  local-first peer-to-peer applications in which apps running on different devices need to sync up their state without necessarily trusting each other or relying on any trusted servers.I assume it’s also relevant for  blockchains that use hash graphs, but I don’t know much about them.So, syncing a Git commit history is just one of many possible use cases – I just used it because most developers will be at least roughly familiar with it!</p><p> 所有这些都与本地优先点对点应用程序直接相关，在这些应用程序中，运行在不同设备上的应用程序需要同步其状态，而不必彼此信任或依赖任何受信任的服务器。我认为这也与使用哈希图，但我对此并不了解。因此，同步Git提交历史只是许多可能的用例之一–我刚刚使用了它，因为大多数开发人员至少会对它有所了解！</p><p> The details of the algorithm and the theorems are in the  paper, so I won’t repeat them here.Instead, I will briefly mention a few interesting things that didn’t make it into the paper.</p><p> 该算法和定理的详细信息在论文中，因此在这里我不再赘述。相反，我将简要提及一些未纳入论文的有趣事情。</p><p>  One thing you might be wondering: rather than creating a Bloom filters with 10 bits per commit, can we not just truncate the commit hashes to 10 bits and send those instead?That would use the same amount of network bandwidth, and intuitively it may seem like it should be equivalent.</p><p>  您可能会想知道一件事：我们不能只将提交哈希值截断为10位并发送，而不是创建每个提交10位的Bloom过滤器，这将使用相同数量的网络带宽，并且看起来像它应该是等效的。 </p><p> However, that is not the case: Bloom filters perform vastly better than truncated hashes.I will use a small amount of probability theory to explain why.</p><p>但是，事实并非如此：Bloom过滤器的性能远优于截断的哈希值。我将使用少量概率论来解释原因。</p><p> Say we have a hash graph containing \(n\) distinct items, and we want to use \(b\) bits per item (so the total size of the data structure is \(m=bn\) bits).If we are using truncated hashes, there are \(2^b\) possible values for each \(b\)-bit hash.Thus, given two independently chosen, uniformly distributed hashes, the probability that they are the same is \(2^{-b}\).</p><p> 假设我们有一个包含\（n \）个不同项的哈希图，并且我们希望每个项目使用\（b \）位（因此数据结构的总大小为\（m = bn \）位）。使用截断的哈希，每个\（b \）位哈希有\（2 ^ b \）个可能值，因此，给定两个独立选择的，均匀分布的哈希，它们相同的概率为\（2 ^ {-b} \）。</p><p> If we have \(n\) uniformly distributed hashes, the probability that they are all different from a given \(b\)-bit hash is \((1-2^{-b})^n\).The false positive probability is therefore the probability that a given \(b\)-bit hash equals one or more of the \(n\) hashes:</p><p> 如果我们有\（n \）个均匀分布的哈希，则它们与给定的\（b \）位哈希值都不同的概率为\（（1-2 ^ {-b}）^ n \）。因此，正概率是给定\（b \）位哈希等于一个或多个\（n \）哈希的概率：</p><p>  On the other hand, with a Bloom filter, we start out with all \(m\) bits set to zero, and then for each item, we set \(k\) bits to one.After one uniformly distributed bit-setting operation, the probability that a given bit is zero is \(1 - 1/m\).Thus, after \(kn\) bit-setting operations, the probability that a given bit is still zero is \((1 - 1/m)^{kn}\).</p><p>  另一方面，使用布隆（Bloom）过滤器时，首先将所有\（m \）位设置为零，然后对于每个项目，将\（k \）位设置为1。 ，给定位为零的概率为\（1-1 / m \）。因此，在执行\（kn \）位设置操作后，给定位仍为零的概率为\（（1-1 // m）^ {kn} \）。</p><p> A Bloom filter has a false positive when we check \(k\) bits for some item and they are all one, even though that item was not in the set.The probability of this happening is</p><p> 当我们检查某个项目的\（k \）位并且它们全为1时，布隆过滤器的误报为肯定，即使该项目不在集合中也是如此。</p><p>  It’s not obvious from those expressions which of the two is better, so I plotted the false positive probabilities of truncated hashes and Bloom filters for varying numbers of items \(n\), and with parameters \(b=10\), \(k=7\), \(m=bn\):</p><p>  从这些表达式中并不能看出这两者中哪个更好，所以针对不同数量的项\（n \）和参数\（b = 10 \），\（ k = 7 \），\（m = bn \）：</p><p>  For a Bloom filter, as long as we grow the size of the filter proportionally to the number of items (here we have 10 bits per item), the false positive probability remains pretty much constant at about 0.8%.But truncated hashes of the same size behave much worse, and with more than about 1,000 items the false positive probability exceeds 50%.</p><p>  对于布隆（Bloom）过滤器，只要我们根据项目数量成比例地增加过滤器的大小（此处每个项目有10位），假阳性概率就几乎保持恒定在0.8％左右。尺寸的行为会更糟，并且，如果出现超过1,000个项目，则误报率超过50％。 </p><p> The reason for this: with 10-bit truncated hashes there are only 1,024 possible hash values, and if we have 1,000 different items, then most of those 1,024 possible values are already taken.With truncated hashes, if we wanted to keep the false positive probability constant, we would have to use more bits per item as the number of items grows, so the total size of the data structure would grow faster than linearly in the number of items.</p><p>这样做的原因是：使用10位截断的散列只有1,024个可能的哈希值，如果我们有1,000个不同的项，则已经采用了1,024个可能的值中的大多数。概率常数，随着项目数的增加，我们将不得不为每个项目使用更多的位，因此数据结构的总大小将比项目数的线性增长快。</p><p> Viewing it like this, it is quite remarkable that Bloom filters work as well as they do, using only a constant number of bits per item!</p><p> 如此看来，Bloom过滤器的工作原理与它们一样出色，每项仅使用固定位数！</p><p>  The Bloom filter false positive formula given above is the one that is commonly quoted, but it’s actually not quite correct.To be precise, it is a  lower bound on the exact false positive probability ( open access paper).</p><p>  上面给出的Bloom过滤器误报公式是经常被引用的公式，但实际上并不完全正确。确切地说，这是确切的误报概率的下限（开放获取论文）。</p><p> Out of curiosity I wrote a  little Python script that calculates the false positive probability for truncated hashes, Bloom filters using the approximate formula, and Bloom filters using the exact formula.Fortunately, for the parameter values we are interested in, the difference between approximate and exact probability is very small.The  gist also contains a  Gnuplot script to produce the graph above.</p><p> 出于好奇，我写了一个Python脚本来计算被截断的哈希的误报概率，使用近似公式的Bloom过滤器和使用精确公式的Bloom过滤器。幸运的是，对于我们感兴趣的参数值，近似值和精确概率很小。要点还包含一个Gnuplot脚本来生成上面的图。</p><p> Peter suggested that a  Cockoo filter may perform even better than a Bloom filter, but we haven’t looked into that yet.To be honest, the Bloom filter approach already works so well, and it’s so simple, that I’m not sure the added complexity of a more sophisticated data structure would really be worth it.</p><p> Peter建议Cockoo过滤器的性能可能比Bloom过滤器更好，但我们尚未对此进行研究。说实话，Bloom过滤器方法已经可以很好地工作了，而且它是如此简单，以至于我不确定增加更复杂的数据结构的复杂性确实是值得的。</p><p> That’s all for today.Our paper is at  arxiv.org/abs/2012.00472.Hope you found this interesting, and please let us know if you end up using the algorithm!</p><p> 今天就这些了。我们的论文在arxiv.org/abs/2012.00472。希望您发现这很有趣，如果您最终使用该算法，请告诉我们！</p><p>  To get notified when I write something new,  follow me on Twitter or enter your email address:</p><p>  要在我写新东西时得到通知，请在Twitter上关注我或输入您的电子邮件地址： </p><p>    I won&#39;t give your address to anyone else, won&#39;t send you any spam, and you can unsubscribe at any time.</p><p>我不会将您的地址提供给其他任何人，不会向您发送任何垃圾邮件，您可以随时退订。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/bloom/">#bloom</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/filters/">#filters</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/提交/">#提交</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>