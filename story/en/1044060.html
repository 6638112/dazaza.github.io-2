<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>不太可能的数据库迁移 An Unlikely Database Migration</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">An Unlikely Database Migration<br/>不太可能的数据库迁移 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-15 19:55:36</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/f60ab32f0e4a82c00c7f32f6b1d09492.png"><img src="http://img2.diglog.com/img/2021/1/f60ab32f0e4a82c00c7f32f6b1d09492.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>When I first joined  Tailscale almost a yearago, one of the first things I asked Crawshaw was, “So, what database do youuse? MySQL, PostgreSQL, SQLite maybe?”, knowing that he loved SQLite.</p><p>当我差不多一年前刚加入Tailscale时，我问Crawshaw的第一件事就是：“那么，您使用哪个数据库？知道他喜欢SQLite，是MySQL，PostgreSQL，还是SQLite？”。</p><p>     “Yeah, whenever something changes, we grab a lock in our singleprocess and rewrite out the file!” he chuckled with glee.</p><p>     “是的，每当发生更改时，我们都会在单进程中获取一个锁并重写文件！”他高兴地笑了起来。</p><p> It sounded insane. It  was insane. Sure, it was easily testable, butit didn’t scale. We both knew that. But it worked.</p><p> 听起来很疯狂。太疯狂了。当然，它易于测试，但无法扩展。我们俩都知道。但这行得通。</p><p>  Even with fast NVMe drives and splitting the database into two halves(important data vs. ephemeral data that we could lose on a tmpfs),things got slower and slower. We knew the day would come. The filereached a peak size of 150MB and we were writing it as quickly as thedisk I/O would let us. Ain’t that just peachy?</p><p>  即使有了快速的NVMe驱动器并将数据库分成两半（重要数据与临时数据，我们在tmpfs上可能会丢失），事情变得越来越慢。我们知道这一天将会到来。该文件的峰值大小达到了150MB，我们正在以磁盘I / O允许的速度对其进行写入。那不是桃子吗？</p><p>    Tailscale’s coordination server, our “control plane”, has become knownas  CONTROL. It’s currentlya single Go process on a single VM. The very earliest prototypes forCONTROL used SQLite. Our original designs were very different fromwhat we ended up with, involving configuration databases synchronizedonto client machines and all sorts of other concepts we ended up notneeding. Through this process we would do major reorganizations of ourSQL data model every week, which required an astonishing amount oftyping. SQL is widely used, durable, effective, and requires anannoying amount of glue to bring into just about any programminglanguage. (Attempts to avoid this with ORMs usually replace anannoying amount of typing with an annoying amount of magic and loss ofefficiency.)</p><p>    Tailscale的协调服务器，即我们的“控制平面”，被称为CON​​TROL。目前，它是单个VM上的单个Go进程。 CONTROL的最早原型使用SQLite。我们最初的设计与最终设计有很大不同，涉及到与客户端计算机同步的配置数据库以及最终不需要的各种其他概念。通过此过程，我们每周都会对SQL数据模型进行重大重组，这需要大量惊人的键入。 SQL被广泛使用，持久，有效，并且需要消耗大量胶水才能将其引入几乎任何编程语言。 （尝试使用ORM避免这种情况通常用烦人的魔术和效率降低来代替烦人的打字。）</p><p> One day, fed up with the refactorings, I threw it all out and built anin-memory data model for experimentation. That made iteratingmuch faster. A couple of weeks later, a customer wanted to try itout. I wasn’t ready to commit to the data model yet and do it properlyin SQL, so I took a shortcut: the object holding all the data waswrapped in a  sync.Mutex, all accesses went through it, and on edit thewhole structure was passed to  json.Marshal and written to disk. Thisgave us data model persistence in ~20 lines of Go.</p><p> 有一天，我厌倦了重构，将其全部扔掉，并建立了一个用于实验的内存数据模型。这使得迭代快得多。几周后，一位客户想试用一下。我还没有准备好提交数据模型并在SQL中正确执行它，所以我采取了一条捷径：保存所有数据的对象被同步包装了.Mutex，所有访问都通过了它，并在编辑时传递了整个结构到json.Marshal并写入磁盘。这使我们的数据模型在Go的约20行中具有持久性。</p><p> The plan was always to migrate to something else but, uh, we got busywith other stuff and kinda forgot.</p><p> 计划总是要迁移到其他地方，但是，我们忙于其他东西，有点忘了。 </p><p>  The obvious next step to take was to move to SQL. My favorite is stillSQLite, but I couldn’t bring myself to make an argument for migratinga rapidly growing service to it. It certainly could work, especiallyas the design of our control plane doesn’t require the highavailability of typical web services: the result of a short outage isthat new nodes can’t log in; working networks continue to work.</p><p>显而易见的下一步是转向SQL。我最喜欢的仍然是SQLite，但我无法说服自己为快速增长的服务迁移。它当然可以工作，特别是因为我们控制平面的设计不需要典型Web服务的高可用性：短暂中断的结果是新节点无法登录；工作网络继续工作。</p><p> MySQL (or PostgreSQL) would come next. I’m not particularly familiarwith anything MySQL post 1998, but I’m sure it would work. The HAstory for open source databases is somewhat surprising, though: youcan either have traditional lagging replicas, or commit tono-primary-replica clusters that have very surprising transactionsemantics. I wasn’t excited about trying to design a stable API orgood network graph calculations on top of those semantics. CockroachDBlooked very promising, and indeed still does! But it’s relatively newfor a database and I was a little concerned about getting attached tofeatures in a fresh DBMS that would be hard to migrate away from if weneeded to.</p><p> MySQL（或PostgreSQL）将紧随其后。我对1998年以后的MySQL没有特别的了解，但是我敢肯定它会起作用。但是，开放源数据库的HAstory有点令人惊讶：您可以具有传统的滞后副本，也可以提交具有非常令人惊讶的事务语义的tono主副本群集。我对在这些语义之上尝试设计稳定的API或良好的网络图计算并没有感到兴奋。 CockroachDB看起来非常有前途，而且的确如此！但这对于数据库来说是一个相对较新的事物，我有点担心如何在新的DBMS中附加功能，如果需要，这些功能很难迁移。</p><p> Making our control server depend on MySQL or PostgreSQL also means ourcontrol server’s testing story gets slow &amp; ugly. Brad had fought thatbattle with  Perkeep and previously written perkeep.org/pkg/test/dockertestwhich works but isn’t something we wanted to subject future employeesto. It requires Docker on your machine and it’s not particularly fast.</p><p> 使我们的控制服务器依赖于MySQL或PostgreSQL，也意味着我们的控制服务器的测试过程变慢了，丑陋。布拉德曾与Perkeep进行过战斗，之前曾写过perkeep.org/pkg/test/dockertest可以正常工作，但我们不想让未来的员工参加。它需要在您的计算机上使用Docker，而且速度不是特别快。</p><p> Then one day we saw a  Jepsen report onetcd. Unlike the usualless-than-satisfying Jepsen reports to which we’d become accustomed,this one said  good things about  etcd.Combined with some positive experiences  Dave Andersonhad with it, we started thinking about whether we could just use etcd directly.Being written in Go, we could just link it into our tests and use itdirectly. No Docker, no mocks, testing what we’d actually use inproduction.</p><p> 然后有一天，我们看到一份关于Jepsen的报告onetcd。与我们习惯的通常不尽人意的Jepsen报告不同，该报告对etcd表示好话。结合Dave Anderson的一些积极经验，我们开始考虑是否可以直接使用etcd。继续，我们可以将其链接到我们的测试中并直接使用它。没有Docker，没有模拟，没有测试我们实际在生产中使用的东西。</p><p> It turned out that the core data model we were writing to disk closelyfollowed the pattern:</p><p> 事实证明，我们正在写入磁盘的核心数据模型紧随该模式：</p><p>  This maps surprisingly well onto a KV-store. So this led us to etcd asa “minimally-viable database”. It does the critical things we needednow, which was 1) breaking the BigLock into something more akin to a sync.RWMutex, and 2) reducing our I/O to only write the changed data,not the whole world on any write.</p><p>  这出奇地映射到了KV商店。因此，这导致我们将etcd视为“最低可行的数据库”。它完成了我们现在需要的关键任务，这是1）将BigLock分解为更类似于sync.RWMutex的事物，以及2）减少我们的I / O以仅写入更改的数据，而不是整个写入。</p><p> (We are careful not to use any etcd features that would be hard to map onto CockroachDB.)</p><p> （我们非常小心，不要使用任何难以映射到CockroachDB的etcd功能。） </p><p> The downside of this is that etcd, while popular in Kubernetes, hasrelatively few users for a database system. As a company, Tailscale isspending an  innovationtoken on it. But thedatabase is conceptually small enough that we don’t have to treat itas a black box. When we ran into a surprisingly slow key paginationedge case in etcd 3.4, I was able to read my way through its sourcesand write a fix for it in an hour. (I then discovered an  equivalentfixhad already been applied to the next version of etcd, so we backportedthat instead.)</p><p>不利的一面是etcd虽然在Kubernetes中很流行，但是相对来说数据库系统的用户却很少。作为一家公司，Tailscale在它上面花了一个创新代币。但是数据库在概念上足够小，因此我们不必将其视为黑匣子。当我们在etcd 3.4中遇到一个令人惊讶的缓慢的paginationedge案例时，我能够从源代码中读取自己的方式，并在一小时内为它编写了修复程序。 （然后，我发现等效的修补程序已被应用于下一版的etcd，因此我们将其反向移植了。）</p><p>  The client we use for etcd is open source at github.com/tailscale/tailetc. Itis built around two concepts: 1) the total data in the DB is smallenough to fit into the server’s memory and 2) reads are far morecommon than writes. Given that, we want to make reads cheap.</p><p>  我们用于etcd的客户端在github.com/tailscale/tailetc是开源的。它基于两个概念构建：1）数据库中的总数据量很小，无法容纳到服务器的内存中； 2）读取比写入更为常见。鉴于此，我们希望使读取便宜。</p><p> The way we do that is by registering a watch against etcd. Everychange is sent to the client, which maintains an enormous cache map[string]interface{} behind a  sync.RWMutex. When you create a Txand do a Get, the value is read out of this cache (which may be behindetcd, but is kept transactionally consistent by tracking the modrev: aglobal incrementing ID that etcd uses to define revisions of key-valuepairs.). To avoid aliasing bugs with the cache, we copy the objectout, but avoid JSON decoding on each Get by implementing a moreefficient Clone call on objects in the cache.</p><p> 我们这样做的方法是通过在etcd上注册一个手表。 Everychange被发送到客户端，客户端在sync.RWMutex后面维护着巨大的缓存映射[string] interface {}。创建Txand执行Get时，将从该缓存中读取值（该值可能在backetcd中，但通过跟踪modrev：etcd用于定义键-值对的修订版的全局增量ID，在事务上保持一致）。为了避免在缓存中混叠错误，我们复制了对象输出，但是通过对缓存中的对象实施更有效的Clone调用来避免对每个Get进行JSON解码。</p><p>  This is one of those few times writing Go that I felt the limitationsof its type system as I was designing a package. If I were working ina language with all the bells and whistles, there would be some kindof const qualifier I could place on objects leaving the cache andavoid cloning the memory. That said, running profiles on our servershow the copying is not a performance issue, so perhaps this is anexample of where I feel the pull towards a more complex type systemwithout actually having a real need for them. As is so often the case,assumptions are dangerous, profiling is enlightening.</p><p>  这是编写Go的那几次，我在设计包装时就感受到了它的类型系统的局限性。如果我用一种语言处理所有问题，那么我可以在离开缓存的对象上放置某种const限定符，并避免克隆内存。就是说，在我们的服务器上运行配置文件表明复制不是性能问题，所以也许这是我觉得向更复杂的类型系统的牵引力的一个示例，而实际上并不需要它们。通常情况下，假设是危险的，剖析是有启发性的。</p><p>  The biggest problem with choosing a minimal viable “nosql” is the lackof the wonderful index system every standard SQL DBMS supplies. We arestuck with either storing indexes inside etcd, or managing them inmemory in our client.</p><p>  选择最小可行的“ nosql”的最大问题是缺少每个标准SQL DBMS提供的出色的索引系统。我们对将索引存储在etcd中或在客户端中管理它们的内存感到困惑。</p><p> With JSONMutexDB we generated them in memory, because it’s much easierto make data model changes. The easy option with etcd would have beenwriting them to the database, but that would have really complicateddata models. Unfortunately, if we want to move to running more thanone CONTROL process simultaneously for high-availability and betterrelease management, that means we no longer have exactly one processmanaging the data, so our indexes need to be transaction (androllback) aware. So we invested what probably amounts to two or threeweeks of engineering time into designing in-memory indexes that aretransactionally consistent. This gets a bit tricky to describe, sowe’ll save that for a future blog post (and hopefully we can clean upthe code enough to open source it some day).</p><p> 使用JSONMutexDB，我们可以在内存中生成它们，因为更改数据模型更加容易。 etcd的简单选项将把它们写入数据库，但是那样的话，它们的数据模型就会非常复杂。不幸的是，如果我们要同时运行多个CONTROL进程以实现高可用性和更好的发行版管理，则意味着我们不再只有一个进程来管理数据，因此我们的索引需要了解事务（和回滚）。因此，我们投入了大约两到三周的工程时间来设计事务上一致的内存索引。描述起来有些棘手，所以我们将其保存在以后的博客文章中（希望我们有足够的时间清理代码以便有一天将其开源）。</p><p>  The migration wasn’t very notable, which is always a good thing. Weran both systems in parallel for a while and at some point stoppedusing the old one. The most exciting thing was that our commit latencydropped a bunch when we turned off the JSON writes. This was mostnoticeable when editing networks in the admin panel. We’d includepretty Grafana graphs here but the cut-over predates us changing ourPrometheus config to keep more history. In any case, writes went fromnearly a second (sometimes worse!) to milliseconds. When we’d started,writes weren’t a second of course. Never underestimate how long your“temporary” hack will stay in production!</p><p>  迁移不是很明显，这总是一件好事。并行运行两个系统一段时间，并在某个时候停止使用旧系统。最令人兴奋的是，当我们关闭JSON写操作时，提交延迟下降了很多。在管理面板中编辑网络时，这一点最为明显。我们将在此处包含漂亮的Grafana图，但是在过渡之前，我们更改了Prometheus配置以保留更多历史记录。无论如何，写入时间从近一秒（有时更糟！）到毫秒。当我们开始时，写作当然不是一秒钟的事情。永远不要低估您的“临时” hack会持续生产多久！ </p><p>  The most exciting thing about this work, besides ensuring theTailscale control plane can scale out for the foreseeable future, isimproving our release process. A consistent database we can easilyattach multiple control plane instances to means we can move to blue-green deployment.This will let Tailscale engineers experiment with deploying featureswith the confidence that the worst-case outcome of a change islimited. The goal is to keep development speed as close to the earlydays of JSONMutexDB, when you could recompile and run locally in afraction of a second and deploy ten times a day.</p><p>这项工作最令人兴奋的事情，除了确保尾标控制平面可以在可预见的将来进行扩展外，还改善了我们的发布流程。 一个一致的数据库使我们可以轻松地将多个控制平面实例连接起来，这意味着我们可以进行蓝绿色部署。这将使Tailscale工程师能够以有限的最坏情况所带来的信心来尝试部署功能。 目标是使开发速度保持接近JSONMutexDB的早期，那时您可以在一秒钟内重新编译并在本地运行，每天部署十次。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://tailscale.com/blog/an-unlikely-database-migration/">https://tailscale.com/blog/an-unlikely-database-migration/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/database/">#database</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/etcd/">#etcd</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>