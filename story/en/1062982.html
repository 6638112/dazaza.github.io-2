<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从跟踪设备中提取数据 Extracting Data from Tracking Devices</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Extracting Data from Tracking Devices<br/>从跟踪设备中提取数据 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-16 13:56:30</div><div class="page_narrow text-break page_content"><p>Many consumer personal tracking devices seem to have a shelf life of only a couple of years. So if you&#39;re interested in keeping a long-term history of your progress, you have to figure out how to work around their apps to get your own data back from their servers. Otherwise, the day their app or servers stop working, your data will simply disappear.</p><p>许多消费者个人跟踪设备似乎只有几年的保质期。所以，如果你＆＃39;遗嘱有兴趣保持你的进步的长期历史，你必须弄清楚如何在他们的应用程序中努力从他们的服务器上获取自己的数据。否则，当天他们的应用程序或服务器停止工作，您的数据将简单地消失。</p><p> I&#39;ve used two tracking devices where data was not easily exportable, the  Microsoft Band ( shut down May 2019), and the  Hello Sense ( shut down June 2017, and never sent the data export instructions that they said was forthcoming), so I&#39;m documenting the process I went through to retrieve my own data in hopes it may be useful for others trying to do the same for other devices.</p><p> 我使用了两个跟踪设备，其中数据不易出口，Microsoft Band（2019年5月）和Hello Sense（2017年6月关闭，而且从未发送他们所说的数据导出说明即将到来的数据，所以我记录了我通过的过程来检索我自己的数据，希望其他人试图为其他设备做同样的操作。</p><p>   When the Microsoft Band was announced, I was thrilled to discover the first wrist-worn device to have both a heart-rate sensor and GPS, plus a slew of other sensors. My Ph.D. student Alexandra managed to snag a Band when they were hard to find, but I was disappointed to learn that it suffered from the same problem that plagued so many promising wearable devices: the inability to export my own minute-by-minute data.</p><p>   当宣布微软乐队时，我很激烈地发现第一个拧紧设备，以便拥有心率传感器和GPS，以及其他传感器。我的博士学位。学生Alexandra在很难找到时，我会陷入乐队，但我很失望的是，了解它遭受了相同的问题，困扰了这么多有前途的可穿戴设备：无法导出自己的分钟数据。</p><p>  The Band syncs to its own smartphone app called Microsoft Health, but was clear after a bit of searching online that no one knew a way to get their data out. I asked someone who worked on the Band at Microsoft Research whether he knew of a creative way to get data out of it, and he challenged, &#34;You&#39;re right that we don&#39;t expose raw data at this point, but looking forward to seeing what you come up with... :)&#34;</p><p>  乐队同步到自己的智能手机应用程序，称为Microsoft Health，但在网上搜索后很清楚，没有人知道他们的数据。我问了在微软研究中致力于乐队的人，他是否知道一种创造性的方式来获取它的数据，并且他挑战，＆＃34;你＆＃39;我们没有曝光原始数据这一点，但期待着看到你想出的东西...... :)＆＃34;</p><p>  I asked Alexandra to dump out the data from the phone app to find out how the data was stored. She managed to export a bunch of files, but after digging around, we found cached data with daily summaries, but not the raw minute-by-minute values I knew was being stored somewhere because the sleep chart in the Microsoft Health app showed finer-grained data (left screenshot below).</p><p>  我请亚历山德拉从手机应用中转储数据，以了解如何存储数据。她设法出口一堆文件，但在挖掘之后，我们发现了每日摘要的缓存数据，但不是我知道的原始分钟值是在某处存储的，因为Microsoft Health App中的睡眠图表显示更精细 - 粒度数据（下面的左屏幕截图）。</p><p>  I decided to dig further and decompiled the app to understand where the data went by reading the app code. I used an app on my phone called ES File Explorer to get the application package (the apk file) from the phone to my computer (right screenshot above).</p><p>  我决定进一步挖掘并分解应用程序以了解数据通过阅读应用程序代码的位置。我在手机上使用了一个名为es文件资源管理器的应用程序将应用程序包（apk文件）从手机中获取到我的计算机（上面的右屏幕截图）。</p><p> An apk is just a zip file, and here&#39;s what the Microsoft Health apk file looked like when unzipped.</p><p> APK只是一个zip文件，这里和＃39; s microsoft health apk文件在解压缩时看起来像什么。 </p><p>  The main code for the app is in a file called classes.dex which is a Dalvik Executable file, basically a compiled Java binary. The file format is fairly  well defined and I was lucky to find an open source tool called  jadx to decompile the source code.</p><p>应用程序的主要代码是一个名为classes.dex的文件，它是dalvik可执行文件，基本上是一个被编译的java二进制文件。文件格式定义得很好，我很幸运能找到一个名为Jadx的开源工具来分解源代码。</p><p> After decompiling the classes.dex file, I browsed through a few folders and came across this in the &#34;microsoft/&#34; folder, which seemed like the root directory for the Microsoft Health app.</p><p> 在分解Classes.dex文件后，我浏览了几个文件夹，并在＆＃34;微软/＆＃34;文件夹，似乎像Microsoft Health应用程序的根目录。</p><p> $ ls -ltotal 0drwxr-xr-x 18 jeff staff 612 Dec 9 17:14 cargodrwxr-xr-x 3 jeff staff 102 Dec 9 17:14 exceptionsdrwxr-xr-x 3 jeff staff 102 Dec 9 17:14 instrumentationdrwxr-xr-x 199 jeff staff 6766 Dec 9 17:14 kappdrwxr-xr-x 5 jeff staff 170 Dec 9 17:14 krestsdk</p><p> $ ls -ltotal 0drwxr-xr-x 18杰夫工作人员612年12月9日17:14 Cargodrwxr-xr-x 3杰夫工作人员102 12月9日17:14 Expectionsdrwxr-xr-x 3杰夫工作人员102 dec 9 17:14 instrumentationdrwxr-xr- x 199杰夫工作人员6766 12月9日17:14 kappdrwxr-xr-x 5杰夫工作人员170年12月9日17:14 Krestsdk</p><p> There were hundreds of files inside each of these folders, so I grepped for keywords like &#34;sleep&#34;, and then &#34;sleepEvents&#34; when I noticed that was a frequently occurring term.</p><p> 这些文件夹中有数百个文件，所以我可以获得像＆＃34的关键字;睡眠＆＃34;，然后＆＃34; leepevents＆＃34;当我注意到这是一个经常发生的术语。</p><p>  public void getSleepEvents(LocalDate localdate, LocalDate localdate1, Callback callback){ if (localdate.isAfter(localdate1)) { throw new IllegalArgumentException(&#34;startDayId cannot be after endDayId.&#34;); } else { ODataRequest odatarequest = new ODataRequest(&#34;/v1/Events&#34;); odatarequest.addArgumentQuotes(&#34;eventType&#34;, EventType.Sleeping.toString()); Object aobj[] = new Object[2]; aobj[0] = KRestServiceUtils.formatDate(localdate); aobj[1] = KRestServiceUtils.formatDate(localdate1); odatarequest.setFilter(&#34;DayId ge datetime&#39;%s&#39; and DayId le datetime&#39;%s&#39;&#34;, aobj); odatarequest.addParameter(&#34;expand&#34;, &#34;Sequences,Info&#34;); NetworkProvider networkprovider = mNetworkProvider; CredentialStore credentialstore = mCredentialStore; CacheService cacheservice = mCacheService; String as[] = new String[3]; as[0] = &#34;SYNC&#34;; as[1] = &#34;EVENTS&#34;; as[2] = CacheUtils.getEventTypeTag(EventType.Sleeping.toString()); (new KRestQueryOData(networkprovider, credentialstore, cacheservice, Arrays.asList(as), CUSTOM_GSON_DESERIALIZER, odatarequest, new TypeToken() { final KRestServiceV1 this$0; { this$0 = KRestServiceV1.this; super(); } }, callback)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, new String[0]); return; }}</p><p>  public void getslepevents（localdate localDate，localDate localDate1，Callback Callback）{if（localDate.IsAfter（localDate1））{抛出新的IllegalArgumentException（＆＃34; Startdayid不能在neydayid之后。＆＃34;）; } else {odatarequest odatarequest = new odatarequest（＆＃34; / v1 / events＆＃34;）; odatarequest.addargumentquotes（＆＃34; enventype＆＃34;，eventtype.sleeping.tostring（））;对象Aobj [] =新对象[2]; Aobj [0] = Krestserviceutils.Formatdate（局部）; Aobj [1] = Krestserviceutils.Formatdate（LocalDate1）; odatarequest.setfilter（＆＃34;白天ge datetime＆＃39;％s＆＃39;和白天Le DateTime＆＃39;％s＆＃39;＆＃34;，aobj）; odatarequest.addparameter（＆＃34;展开＆＃34;＆＃34;序列，信息＆＃34;）; NetworkProvider NetworkProvider = MnetworkProvider; CredentialStore CredentialStore = McredentialStore; cacheservice cacheservice = mcacheservice;字符串为[] =新字符串[3];作为[0] =＆＃34; sync＆＃34 ;;作为[1] =＆＃34;事件＆＃34 ;;作为[2] = cacheutils.geteventTypeag（EventType.sleeping.tostring（））; （New Krestqueryodata（NetworkProvider，Credendstore，Cacheservice，Arrays.aslist（AS），Custom_gson_Deserializer，OdatareQuest，New TypeToken（）{Final KrestServicev1这¥40; {此$ 0 = Krestservicev1.this; super（）;}}，回调）。 ExecudeOnexecutor（Asynctask.thread_pool_executor，new String [0]）;返回; }}</p><p> Clearly, to get sleep events, the app is constructing a REST call. So what must be happening is the Band syncs with the app on the phone, which syncs with some servers that Microsoft owns. This explained why we were not able to find the raw data in the file dump of the app, as only the cached data was stored locally.</p><p> 显然，要获取睡眠事件，该应用程序正在构建REST呼叫。因此，必须发生的是与手机上的应用程序的乐队同步，它与Microsoft拥有的一些服务器同步。这解释了为什么我们无法在文件转储中找到原始数据，因为只有在本地存储缓存的数据。</p><p>  My next intuition was to try and intercept the data between the app on my phone and the Microsoft server to see what was being transmitted. This is usually done by using a proxy in an application, so I first tried enabling the proxy on my Android phone (left screenshot below).</p><p>  我的下一个直觉是在手机和Microsoft服务器上尝试拦截应用程序之间的数据，以查看正在传输的内容。这通常是通过在应用程序中使用代理完成的，因此我首先尝试在我的Android手机上启用代理（下面的左屏幕截图）。 </p><p>  After a bit of testing, it was clear that the proxy feature in Android only affects the web browser, and not the Microsoft Health app. So I tried a different trick: setting the gateway (i.e., router) for the phone&#39;s wifi to be my computer instead of using DHCP, so that all the network data would be sent to my computer. I edited this setting (right screenshot above) and enabled IP forwarding so network packets could still reach the Internet instead of hitting my computer and getting lost.</p><p>经过一点测试，显然Android中的代理功能仅影响Web浏览器，而不是Microsoft Health应用程序。所以我尝试了一个不同的技巧：将网关（即路由器）设置为手机＆＃39; s wifi是我的电脑而不是使用dhcp，以便将所有网络数据发送到我的计算机。我编辑了这个设置（上面的右屏幕截图）并启用了IP转发，因此网络数据包仍然可以到达Internet而不是击中我的计算机并丢失。</p><p>  Next I checked that the browser was still working on my phone, and it was so that was a good sign. Then the tricky part; I set up a packet filter to forward the incoming packets to a different port on my computer. In a new .conf file,</p><p>  接下来我检查了浏览器仍在手机上工作，这是一个很好的标志。然后是棘手的部分;我设置了一个数据包过滤器，以将传入的数据包转发到计算机上的其他端口。在一个新的.conf文件中，</p><p>   $ sudo pfctl -f pf.confpfctl: Use of -f option, could result in flushing of rulespresent in the main ruleset added by the system at startup.See /etc/pf.conf for further details.$ sudo pfctl -epf enabled</p><p>   $ sudo pfctl -f pf.confpfctl：使用-f选项，可能会导致系统在startup.see /etc/pf.conf添加的主要规则集中刷新规则预分器，以获取更多详细信息。$ sudo pfctl -epf启用</p><p> Then I installed a traffic inspector (an open source tool called  mitmproxy) and fiddled with the flags until I figured out how to activate the transparent proxy mode.</p><p> 然后我安装了一个流量检查员（一个名为mitmproxy的开源工具），并摆弄标志，直到我弄清楚如何激活透明代理模式。</p><p>  So this basically simulates a  man-in-the-middle attack to intercept the data. Note that this is only capturing the data sent and received by my phone, so it&#39;s not really an attack in the usual sense but just a way for me to view the data my phone is already dealing with.</p><p>  因此，这基本上模拟了一个中间人攻击以拦截数据。请注意，这只是捕获我手机发送和接收的数据，所以它＆＃39;不是通常意义上的攻击，但只是一种方法可以查看我的手机已经在处理的数据。</p><p> I was reassured to see traffic being routed through my mitmproxy console when I visited websites. However, when I started up my Microsoft Health app, it wouldn&#39;t start at all (left screenshot below).</p><p> 当我访问网站时，我被放心，以查看通过MITMPROXY控制台路由的流量。但是，当我启动我的Microsoft Health应用程序时，它会在所有（下面的截图截图）开始。</p><p>  Eventually I figured out it was using HTTPS, which was running on a different port. So I made some changes. First, I installed an SSL certificate on my phone so that my phone would trust my computer which was intercepting the messages (right screenshot above). Then I added a line to my packet filter to also forward packets on the HTTPS port, by adding an extra line below to the .conf file and re-running the pfctl commmands.</p><p>  最终我认为它是使用HTTPS，它在不同的端口上运行。所以我做了一些改变。首先，我在手机上安装了一个SSL证书，以便我的手机相信我的电脑正在拦截邮件（右上屏幕截图）。然后我将一条线添加到我的数据包过滤器中，也将在HTTPS端口上转发数据包，通过将下面的额外行添加到.conf文件并重新运行PFCTL Commmands。 </p><p>  Basically, instead of the Microsoft Health app communicating with the Microsoft server over HTTPS, all communication is routed through my computer. The mitmproxy tool intercepts the SSL keys and injects its own, so it can decrypt and re-encrypt messages that go through it.</p><p>基本上，而不是通过HTTPS与Microsoft Server通信的Microsoft Health应用程序，所有通信都通过我的计算机进行路由。 MITMProxy工具拦截SSL键并注入自己的键，因此可以解密并重新加密通过它的消息。</p><p> At last, I was able to see the traffic from the Microsoft Health app. Fortunately, the requests were easy to figure out, and data was simple to understand.</p><p> 最后，我能够看到来自Microsoft Health应用程序的流量。幸运的是，请求很容易弄清楚，数据很容易理解。</p><p>  Notice that to request the data, the phone issues a REST GET request to a URL like https://prodphseus.dns-cargo.com/v1/Events(eventId=&#39;1234567890&#39;)?$expand=Sequences,</p><p>  请注意，要申请数据，手机发出休息请求，以https://prodphseus.dns-cargo.com/v1/events（epentid=&#39; 1234567890&#39 ;)?:Lexpand=序列那</p><p> If you are just interested in data from one event (like last night&#39;s sleep), then you would be satisfied at this point so you can just save the response from the Microsoft prodphseus.dns-cargo.com server and be happy. To get a few more events, you can simply click through every sleep (left screenshot), exercise (right screenshot), or other type of event until your phone (and your computer intercepting the messages) receives all the data. Then you save them to a file and you can view it in your favorite text editor and process it using a script.</p><p> 如果您对来自一个活动的数据感兴趣（如昨晚＆＃39;睡眠），那么您就会满意，因此您可以保存来自Microsoft ProdPhseus.DNS-Cargo.com服务器的响应并快乐。要获得更多活动，您只需单击每一个睡眠（左屏幕截图），锻炼（右屏幕截图）或其他类型的事件，直到您的手机（以及您的计算机拦截消息）接收所有数据。然后您将它们保存到文件中，您可以在您喜欢的文本编辑器中查看并使用脚本进行处理。</p><p>   But what if you don&#39;t want to manually go through every entry on your phone to have it transmit the data? Basically, to get the data over the entire time when you had the Band instead of individual events. Then recall the decompiled Java code at the beginning of this article containing:</p><p>   但是如果你不想手动通过手机上的每一个条目来传播数据怎么办？基本上，在您拥有频段而不是单个事件时，在整个时间内获得数据。然后在本文开头召回包含的分解Java代码：</p><p>  which provides a clue that to retrieve the full set of data without having to select each entry on the phone, you could edit the URL to:</p><p>  它提供了一个线索，用于检索全套数据而无需在手机上选择每个条目，可以编辑URL：</p><p>  Simply pasting the URL into a browser wouldn&#39;t work because you have to reuse the same authentication token the Microsoft Health app is using, but editing a prior request should let you retrieve your entire raw data stream without retrieving each event one by one.</p><p>  简单地将URL粘贴到浏览器中＆＃39; t工作，因为您必须重用相同的身份验证令牌Microsoft Health应用程序使用，但编辑先前请求应允许您检索整个原始数据流，而无需将每个事件逐个检索每个事件。 </p><p> To summarize how the Band works, some data is cached on the phone app while the rest is stored on Microsoft servers in the &#34;cloud&#34;. By intercepting the phone app&#39;s requests to the server, you can download the raw data being sent or retrieve your entire historical data like heart-rate, gps, step count, etc. down to the minute level. Happy tracking!</p><p>为了总结乐队的工作原理，一些数据在手机应用程序上缓存，而其余的存储在＆＃34中的Microsoft服务器上;云＆＃34;。通过拦截手机应用程序和＃39; s对服务器的请求，您可以下载要发送的原始数据，如心率，GPS，步数等。快乐追踪！</p><p>   I was excited about the Hello Sense, a popular Kickstarter project whose mantra is &#34;Know More. Sleep Better.&#34; It&#39;s a beautifully-designed globe packed with sensors to tell you about your sleep environment, and a movement-tracking clip for your pillow. I was working with my Ph.D. student Nedi on  automatically generating sleep recommendations, so we wanted to learn how this device measured up.</p><p>   我对Hello Sense感到兴奋，一个受欢迎的球员项目，其Mantra是＆＃34;了解更多。睡得更好。＆＃34;它＆＃39;是一款精美设计的地球，与传感器包装，告诉您睡眠环境，以及枕头的运动跟踪夹。我正在与我的博士合作。学生NEDI自动生成睡眠建议，所以我们想要了解该设备的测量方式。</p><p>  We ordered two Hello Sense devices from their website to use for a few months, but alas it was again disappointing that we could not access the data from the sensors. Instead, we could only view the charts that it generated, and were limited by what the Hello Sense app allowed us to see. To tease us, the Kickstarter page promised,  &#34;We are building tools to allow you to export, use or delete your data. Press a button and your data will be exported or deleted. It is entirely up to you. These tools will be available on our website. [..] You will be able to download a complete archive of your data.&#34; (spoiler: this never happened).</p><p>  我们从他们的网站订购了两个Hello Sense设备即可使用几个月，但是唉，它再次令人失望，我们无法从传感器中访问数据。相反，我们只能查看它生成的图表，并且受到Hello Sense应用程序允许我们看到的限制。挑逗我们，kickstarter页面承诺，＆＃34;我们正在构建工具，以允许您导出，使用或删除数据。按一个按钮，您的数据将被导出或删除。这完全取决于你。这些工具将在我们的网站上提供。 [..]您将能够下载数据的完整存档。＆＃34; （扰流板：这从未发生过）。</p><p> The Hello Sense syncs to its own smartphone app called Sense, but it was clear that there wasn&#39;t a way to export this data. In fact, after searching for solutions, all I could find were other users lamenting the lack of data exportability.</p><p> 您好感觉同步到自己的智能手机应用程序称为感觉，但很清楚没有导出此数据的方法。事实上，在寻找解决方案之后，我可以找到的所有用户都哀叹缺乏数据排出性。</p><p>  I took this as a challenge, and wanted to try the same procedure to intercept messages as the Microsoft Band. Many apps will use a REST call to request a certain slice of the data, so knowing how to do that lets you talk to the server holding your data. Basically, I would intercept the messages between the Sense app and its servers to watch how they authenticated and transmitted my data to the app to make the charts. Then I could learn the &#34;language&#34; and mimic the app to ask for my own data from the servers.</p><p>  我认为这是一个挑战，并希望尝试将消息拦截作为Microsoft乐队的相同过程。许多应用程序将使用REST调用来请求某个数据的数据，因此知道如何执行此操作，允许您与持有数据的服务器交谈。基本上，我会拦截感觉应用程序和其服务器之间的消息，以观看他们如何认证并将我的数据传输到应用程序以进行图表。然后我可以学习＆＃34;语言＆＃34;并模仿应用程序从服务器询问自己的数据。</p><p> As before, I first enabled the proxy on my Android phone (left screenshot below) to my Macbook was that set as the gateway. And again set up a packet filter to forward the incoming packets to a different port on my computer. In a new .conf file,</p><p> 如前所述，我首先在我的android手机上启用了代理（下面的左屏幕截图）到我的MacBook被设置为网关。并再次设置数据包过滤器以将传入数据包转发到计算机上的其他端口。在一个新的.conf文件中，</p><p> rdr on en4 inet proto tcp to any port 80 -&gt; 127.0.0.1 port 2300rdr on en4 inet proto tcp to any port 443 -&gt; 127.0.0.1 port 2300</p><p> 在EN4 INET PROTO TCP上RDR上的任何端口80  - ＆gt; 127.0.0.1 EN4 INET PROTO TCP的端口2300RDR到任何端口443  - ＆gt; 127.0.0.1端口2300. </p><p> And then running pfctl like before, and starting mitmproxy in transparent proxy mode to intercept the data.</p><p>然后以前地运行PFCTL，并在透明代理模式下启动MITMProxy以拦截数据。</p><p>  Finally, I installed an SSL certificate on my phone from http://mitm.it, so that it could intercept the messages sent over https (port 443).</p><p>  最后，我从http://mitm.it安装了我的手机上的SSL证书，以便它可以拦截通过HTTPS发送的消息（端口443）。</p><p> Traffic was correctly routed through my mitmproxy console when visiting websites (see the screenshot above on the right, where I eavesdrop on the phone&#39;s Chrome browser navigation). However, when I started up my Hello Sense app, it didn&#39;t connect to the server properly, &#34;There was a problem securely connecting to the server.&#34;</p><p> 访问网站时，通过我的Mitmproxy控制台正确地路由了流量（请参阅右侧上面的屏幕截图，其中我在电话上窃听＆＃39; s chrome浏览器导航）。但是，当我启动了我的Hello Sense应用程序时，它就＆＃39; t正确连接到服务器，＆＃34;有问题安全连接到服务器。＆＃34;</p><p>   I wanted to get a better sense of what was going on in the app that caused the error to come up. I extracted the apk file from my phone using the  Android Debug Bridge this time. As with the Microsoft Ban app, the main code is inside the apk in a file called classes.dex.</p><p>   我想在应用程序上造成更好的应用程序，了解导致错误的内容。我使用这次Android Debug桥从手机中提取了APK文件。与Microsoft Ban应用一样，主代码位于一个名为classes.dex的文件中的APK内。</p><p> After poking around the code, it was clear that the app used a library called OkHttp that did some sort of certificate pinning. Basically, there was code in there that checked whether the SSL certificate was the right one, and threw an exception if it wasn&#39;t. At this point, there were a couple of options: I could disassemble the app (note that the decompiled Java can&#39;t simply be recompiled into an app, so instead it needs to be disassembled into smali and edited) and remove the certificate pinning checks.</p><p> 在播放代码之后，很明显，该应用程序使用了一个名为Okhttp的库，该库与某种证书固定。基本上，有的代码在那里检查了SSL证书是否是正确的代码，如果它是NANN＆＃39; t的例外。此时，有几个选项：我可以拆卸应用程序（请注意，不编译的Java可以＆＃39; t简单地被重新编译到应用程序中，因此它需要被拆卸到Smali并编辑）并删除证书固定检查。</p><p> But while I was looking into the source code, I came across a file called ApiService.java that showed the REST API queries that the app was making to retrieve data from the server. So theoretically, all we had to do was issue the same queries as if we were the app, and the server would send us the raw data back!</p><p> 但是，虽然我正在研究源代码，但我遇到了一个名为apiservice.java的文件，该文件显示了应用程序正在从服务器检索数据的REST API查询。因此，理论上，我们所要做的就是发出与我们是应用程序相同的查询，服务器会向我们发送原始数据！</p><p>  Notice that to request the data, the phone uses links like /v2/timeline/{date}/events/{type}/{timestamp}. The timeline is in fact exactly what we want to get all the events that happened during a night of sleep for a particular date.</p><p>  请注意，要申请数据，手机使用类似/ v2 / timeline / {date} / {type} / {timestamp}的链接。事实上，时间线确实是我们想要在特定日期睡眠期间发生的所有事件。 </p><p> But before we can send our own REST queries, the server asks for authentication using the OAuth protocol. OAuth authentication is done with a client ID and secret. So I searched the source tree for this, and luckily found it in a simple configuration file.</p><p>但在我们可以发送自己的REST查询之前，服务器要求使用OAuth协议进行身份验证。使用客户端ID和秘密完成OAuth身份验证。所以我搜索了这个源树，幸运的是在一个简单的配置文件中找到它。</p><p>  I highlighted the two lines that specify the client ID and secret. This file also tells us the base URL for the REST server, which is https://api.hello.is so we now have all the pieces we need: the hostname of the REST service, the format of the requests, and the client ID and secret. Note there are also a few lines blacked out that I think are secret keys that should probably not be made public.</p><p>  我突出显示指定客户ID和秘密的两行。此文件还告诉我们RET服务器的基本URL，即https://api.hello.is，因此我们现在拥有我们需要的所有作品：REST服务的主机名，请求的格式和客户端id和秘密。注意，还有几条线解冻了，我认为可能不会公开的秘密密钥。</p><p>  Sending a GET request is easy with any web browser by just typing in the right URL. But crafting a POST request which is what we needed to do requires using a command line tool like curl or finding an application to take care of the annoying bits. I used  Postman which is free and simply designed (and I love application names that are puns).</p><p>  只需在正确的URL中键入，使用任何Web浏览器即可发送Get请求。但是，制作一个邮政请求，这是我们需要使用卷曲等命令行工具所需的要求，或者找到应用程序以照顾令人讨厌的比特。我使用邮递员是免费的，简单地设计（我喜欢作为双关语的应用程序名称）。</p><p> So I entered the appropriate fields into the POST request, using a pretty standard OAuth format. The URL is https://api.hello.is/v1/oauth2/token based on what we found in the source code.</p><p> 因此，我使用漂亮的标准OAuth格式将相应的字段输入到POST请求中。基于我们在源代码中找到的，URL是https://api.hello.is/v1/oauth2/token。</p><p> One thing that tripped me up for a bit was the Content-Type header in the request needs to be set to &#34;application/x-www-form-urlencoded&#34; or the request will be rejected. Once that is set, the result of the POST request is the access_token which provides us access to the rest of the data that we can get using other queries. In the screenshot below, I covered part of my access token to prevent people from snooping on my sleep data.</p><p> 一件事绊倒了一下，请求的内容类型标题需要设置为＆＃34;应用程序/ X-www-form-ullencoded＆＃34;或者请求将被拒绝。一旦设置了，POST请求的结果是Access_Token，它提供了我们访问我们可以使用其他查询的其余数据的访问。在下面的屏幕截图中，我涵盖了我访问令牌的一部分，以防止人们在睡眠数据上窥探。</p><p>  Now the fun part. I use the access token in the header as the Authorization field (the word &#34;Bearer&#34; needs to be prepended to it to indicate that it&#39;s a Bearer token type). And now I can change the URL to what I want, in this case to http://api.hello.is/v1/room/current to see my current room conditions from anywhere.</p><p>  现在是有趣的部分。我使用标题中的访问令牌作为授权字段（Word＆＃34;持票人＆＃34;需要预先准备它，以表明它＆＃39;持票牌类型）。现在我可以将URL更改为我想要的内容，在这种情况下到http://api.hello.is/v1/room/current从任何地方查看我当前的房间条件。</p><p>  If you really wanted to do something with your data, you could write your own script to automatically authenticate and then grab several days of data, maybe to create an online dashboard or send yourself sleep recommendations.</p><p>  如果您真的想用数据做点什么，可以写自己的脚本来自动验证，然后抓住几天的数据，也许可以创建在线仪表板或发送自己的睡眠建议。 </p><p> Probably the most detailed data the Hello Sense stores is how it classifies my time during the night, as awake, medium sleep, sound sleep, etc. This is the timeline that is shown as bar charts in the app, but now we have access to the actual data to generate our own visualizations, or do comparisons and analyses. There are quite a few events during one night, but here&#39;s what it looks like.</p><p>可能是你好感觉商店最详细的数据是它如何在夜间分类我的时间，如清醒，中睡眠，声音睡眠等。这是作为应用程序中的条形图所示的时间表，但现在我们可以访问生成自己的可视化或进行比较和分析的实际数据。在一晚，但这里有很多事件，但它看起来像什么。</p><p>  So the good news is that the Hello Sense did have sort of an API already for data export. It took a bit of sleuthing to figure out how to get access to the data, but I imagine they never released this publicly yet because they wanted to provide a nicer interface to the API.</p><p>  所以好消息是，你好的感觉已经有一个已经用于数据导出的API。弄清楚如何获得数据访问数据，但我想象他们从来没有公开发布这个，因为他们想要为API提供更好的接口。</p><p> Anyways, I hope this documentation is useful for someone trying to export their data from whatever wearable or tracking app is available now. If you want to know what we did with the data, my student  Jina Yoon wrote an article comparing 10 different sleep tracking devices and apps. But for the time being, I&#39;m going to stick with tracking apps that are more open.</p><p> 无论如何，我希望这个文档对于尝试从现在可以使用的可穿戴或跟踪应用程序出口数据来有用。如果您想知道我们对数据所做的内容，我的学生Jina Yoon写了一篇关于10种不同睡眠跟踪设备和应用程序的文章。但是，暂时，我将坚持使用更开放的跟踪应用程序。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://jeffhuang.com/extracting_data_from_tracking_devices/">https://jeffhuang.com/extracting_data_from_tracking_devices/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/跟踪/">#跟踪</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/data/">#data</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>