<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>结构平等以获得更好的测试 Structural Equality for Better Tests</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Structural Equality for Better Tests<br/>结构平等以获得更好的测试 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-05 20:58:44</div><div class="page_narrow text-break page_content"><p>If you&#39;ve read a bit about unit testing, test-driven development, or other kinds of developer testing, you&#39;ve probably come across a phrase like this:		 		It&#39;s often taken to mean something like  behaviour-driven development (BDD), and that&#39;s certainly one interpretation. I&#39;ve no problem with that. My own Pluralsight course  Outside-In Test-Driven Development shows a similar technique.</p><p>如果你＆＃39; ve读了一点关于单元测试，测试驱动的开发或其他类型的开发人员测试，你可能会遇到这样的短语：它常常认为是行为的意思 - 驱动的发展（BDD），而且＆＃39;肯定是一个解释。我没有问题。我自己的Pluralsight课程在测试驱动的发展中显示出类似的技术。</p><p>  It&#39;d be a logical fallacy, however, to thereby conclude that you can only apply that ideal in the large, but not in the small. That it&#39;s only possible to do it with coarse-grained tests at the boundary of the system, but not with unit testing.</p><p>  然而，它是一个逻辑谬误，从而得出结论，你只能在大的情况下应用理想，但不是小。它＆＃39才能在系统的边界处用粗粒测试，但没有单位测试。</p><p>  It may be harder to do at the unit level, since when writing unit tests, you&#39;re closer to the implementation, so to speak. Writing the test before the implementation may, however, help</p><p>  在单位级别可能更难以做，因为写入单元测试时，＆＃39;重新靠近实施，所以说话。但是，在实施之前写测试可以帮助</p><p>      [Theory][InlineData( &#34;Home&#34;)][InlineData( &#34;Calendar&#34;)][InlineData( &#34;Reservations&#34;)] public  void  WithControllerHandlesSuffix( string  name){     var  sut =  new UrlBuilder();      var  actual = sut.WithController(name +  &#34;Controller&#34;);      var  expected = sut.WithController(name);    Assert.Equal(expected, actual);}</p><p>      [理论] [inlinedata（＆＃34;家庭＆＃34;）] [inlinedata（＆＃34;日历＆＃34;）] [inlinedata（＆＃34;预留和＃34;）] public void withcontrollanduffix（字符串名称）{ var sut = new urlbuilder（）; var实际= sut.withcontroller（名称+＆＃34;控制器＆＃34;）; var预期= sut.withcontroller（name）;断言（预期，实际）;}</p><p>  It tests an  ASP.NET Core URL Builder; particular how it deals with the  Controller  suffix issue I ran into last year.</p><p>  它测试了ASP.NET核心URL Builder;特别是如何处理我遇到去年的控制器后缀问题。</p><p>    It describes an equality relation between two individual projections of an initial  UrlBuilder object ( sut).</p><p>    它描述了初始URLBuilder对象（SUT）的两个单独投影之间的平等关系。</p><p>  First of all, with a  Mutable Fluent Builder the test would produce a  false negative because  aliasing would make the assertion a  tautological assertion. Using an  Immutable Fluent Builder, however, elegantly dodges that bullet:  expected and  actual are two separate objects.</p><p>  首先，使用可变的流畅生成器，测试会产生假阴性，因为别名会使断言是一个重叠的主张。然而，使用不可变的流利的建筑商，优雅地躲避了这个弹子：预期和实际是两个单独的物体。 </p><p>        [Theory][InlineData( &#34;Home&#34;)][InlineData( &#34;Calendar&#34;)][InlineData( &#34;Reservations&#34;)] public  void  WithControllerHandlesSuffix( string  name){     var  sut =  new UrlBuilder();      var  actual = sut.WithController(name +  &#34;Controller&#34;);      var  expected = sut.WithController(name);    Assert.Equal(expected.Controller, actual.Controller);}</p><p>[理论] [inlinedata（＆＃34;家庭＆＃34;）] [inlinedata（＆＃34;日历＆＃34;）] [inlinedata（＆＃34;预留和＃34;）] public void withcontrollanduffix（字符串名称）{ var sut = new urlbuilder（）; var实际= sut.withcontroller（名称+＆＃34;控制器＆＃34;）; var预期= sut.withcontroller（name）; assert.equal（预期.Controller，实际.Controller）;}</p><p>  Instead of comparing two whole objects, this variation compares the  Controller property values from two objects. In order for this to compile, you have to expose an implementation detail: that the class has a class field (here exposed as an  automatic property) that keeps track of the Controller name.</p><p>  此变更而不是比较两个整个对象，而不是比较两个对象的控制器属性值。为了使这是为了编译，您必须公开一个实现细节：该类具有级别字段（此处公开为自动属性），可跟踪控制器名称。</p><p>  I think that most object-oriented programmers&#39; default habit is to write assertions that compare properties or class fields because in both C# and Java, objects by default only have reference equality. This leads to  primitive obsession, this time in the context of test assertions.</p><p>  我认为大多数面向对象的程序员＆＃39;默认习惯是编写比较属性或类字段的断言，因为在C＃和Java中，默认情况下对象仅具有参考平等。这导致原始的痴迷，这次在测试断言的背景下。</p><p>  Structural equality, on the other hand, makes it much easier to write concise and meaningful assertions. Just compare  expected with  actual.</p><p>  另一方面，结构平等使得简化和有意义的断言更容易。只是使用实际比较。</p><p>      public  override  bool  Equals( object?  obj){     return obj  is UrlBuilder  builder &amp;&amp;           action == builder.action &amp;&amp;           controller == builder.controller &amp;&amp;           EqualityComparer&lt; object?&gt;.Default.Equals(values, builder.values);}  public  override  int  GetHashCode(){     return HashCode.Combine(action, controller, values);}</p><p>      公共覆盖Bool等于（对象？obj）{return obj是UrlBuilder Builder＆amp;＆amp; action == builder.action＆amp;＆amp; Controller == Builder.Controller＆amp;＆amp;平等偏差者＆lt;对象？＆gt; .default.equals（值，builder.values）;}公共覆盖int gethashcode（）{return hashcode.com净（动作，控制器，值）;}</p><p>    You may think that it&#39;s an odd choice to give a Fluent Builder structural equality, but why not? Since it&#39;s immutable, it&#39;s perfectly safe, and it makes things like testing much easier.</p><p>    你可能会认为它是一个奇怪的选择，给出流利的建筑物结构平等，但为什么不呢？自It＆＃39; s不可变，它完全安全，它使测试更容易。</p><p>  I rarely see people do this. Even programmers experienced with functional programming often seem to categorise structural equality as something associated exclusively with  algebraic data types (ADTs). The  UrlBuilder class, on the other hand, doesn&#39;t look like an ADT. After all, its public API exposes only behaviour, but no data:</p><p>  我很少看到人们这样做。甚至具有功能编程的程序员甚至似乎似乎似乎将结构相等分类为完全与代数数据类型（ADTS）相关的东西。另一方面，UrlBuilder类没有看起来像ADT。毕竟，其公共API仅暴露行为，但没有数据： </p><p>  public  sealed  class  UrlBuilder{     public  UrlBuilder()      public UrlBuilder  WithAction( string  newAction)      public UrlBuilder  WithController( string  newController)      public UrlBuilder  WithValues( object  newValues)      public Uri  BuildAbsolute(IUrlHelper  url)      public  override  bool  Equals( object?  obj)      public  override  int  GetHashCode()}</p><p>公共密封类URLBuilder {公共URLBuilder（）公共URLBuilder （）}</p><p>  On the other hand, my threshold for when I give an immutable class structural equality is  monotonically decreasing. Structural equality just makes things easier. The above test is just one example. Structural equality enables you to test behaviour instead of implementation details. In this example, the behaviour can be expressed as an equality relation between two different inputs.</p><p>  另一方面，当我给予不可变类结构平等时，我的门槛是单调的。结构平等只是让事情变得更容易。上述测试只是一个示例。结构平等使您可以测试行为而不是实现细节。在该示例中，行为可以表示为两个不同输入之间的平等关系。</p><p>    While it may seem odd or surprising to give a Fluent Builder structural equality, it&#39;s really isomorphic to a simple record type equipped with a few  endomorphisms. (After all, we already know that  the Builder pattern is isomorphic to the endomorphism monoid.) Let&#39;s make this explicit with  F#.</p><p>    虽然它看起来很奇怪或令人惊讶地提供流利的建造者结构平等，它真正同性恋到配备有几个基因族的简单记录类型。 （毕竟，我们已经知道生成器模式对子宫内膜的同构。）让＆＃39; s明确使用f＃。</p><p>    type UrlBuilder =  private { Action : string option; Controller : string option; Values : obj option }</p><p>    键入URLBuilder = private {action：string选项;控制器：字符串选项;值：obj选项}</p><p>  While its definition is  private, it&#39;s still an algebraic data type. Records in F# automatically have structural equality, and so does this one.</p><p>  虽然其定义是私人的，但它仍然是代数数据类型。 F＃中的记录自动具有结构平等，也是如此。</p><p>  Since it&#39;s  private, client code can&#39;t use the normal language constructs to create instances. Instead, the module that defines the type must supply an API that client code can use:</p><p>  自IT＆＃39; s私有，客户端代码可以＆＃39; t使用普通语言构造来创建实例。相反，定义类型的模块必须提供客户端代码可以使用的API：</p><p>  let emptyUrlBuilder = { Action = None; Controller = None; Values = None }  let withAction action ub = { ub  with Action = Some action }  let withController (controller : string) ub =     let index = controller.LastIndexOf ( &#34;controller&#34;, StringComparison.OrdinalIgnoreCase)     let newController =  if 0 &lt;= index  then controller.Remove(index)  else controller    { ub  with Controller = Some newController }  let withValues values ub = { ub  with Values = Some values }</p><p>  让extucturlbuilder = {action = none;控制器=无; value = none}让Firection action UB = {UB With Action = Some Action}允许使用控制器（Controller：String）UB = Let index = Controller.LastIndexOf（＆＃34;控制器＆＃34; stringcomparison.ordinalignoreCase）Let NewController =如果0＆lt; index然后controller.remove（索引）else controller {ub withcler =一些newController}让假设值UB = {UB具有值=某些值} </p><p>    [&lt;Theory&gt;][&lt;InlineData( &#34;Home&#34;)&gt;][&lt;InlineData( &#34;Calendar&#34;)&gt;][&lt;InlineData( &#34;Reservations&#34;)&gt;] let ``withController handles suffix`` name =     let sut = emptyUrlBuilder      let actual = sut |&gt; withController (name +  &#34;Controller&#34;)      let expected = sut |&gt; withController name    expected =! actual</p><p>[＆lt;理论＆gt;] [＆lt; inlinedata（＆＃34;家庭＆＃34;）＆gt;] [＆lt; inlinedata（＆＃34;日历＆＃34;）＆gt;] [＆lt; inlinedata（＆＃34;保留和＃34;）＆gt;]让``withcontroller处理后缀withcontroller（名称+＆＃34;控制器＆＃34;）让预期= sut |＆gt; withcontroller名称预计=！实际的</p><p>    Even though  UrlBuilder has no externally visible data, it automatically has structural equality.  Functional programming is, indeed, more test-friendly than object-oriented programming.</p><p>    尽管URLBuilder没有外部可见数据，但它会自动具有结构平等。功能规划，实际上，比面向对象的编程更具测试友好。</p><p>      You can safely give immutable objects structural equality. Besides other advantages, it makes it easier to write tests. With structural equality, you can express a relationship between the expected and actual outcome using high-level language.</p><p>      您可以安全地给出不可变的物体结构平等。除其他优点外，它可以更轻松地编写测试。通过结构平等，您可以使用高级语言表达预期和实际结果之间的关系。</p><p>  These days, I don&#39;t really care if the type in question is a &#39;proper&#39; algebraic data type. If it&#39;s immutable, I don&#39;t have to think much about it before giving it structural equality.</p><p>  这些天，我不太关心问题是＆＃39;正确的＆＃39;代数数据类型。如果它＆＃39;我不可变，我不必在提供结构平等之前思考它。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.ploeh.dk/2021/05/03/structural-equality-for-better-tests/">https://blog.ploeh.dk/2021/05/03/structural-equality-for-better-tests/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/结构/">#结构</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/equality/">#equality</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>