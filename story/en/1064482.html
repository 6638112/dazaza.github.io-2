<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在C ++中嵌入LISP  - 一种食谱 Embedding Lisp in C++ – A Recipe</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Embedding Lisp in C++ – A Recipe<br/>在C ++中嵌入LISP  - 一种食谱 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-09 13:30:13</div><div class="page_narrow text-break page_content"><p>Lisp may be said to be simultaneously the most common and near enough most uncommon programming language in the world. We can quantify this. Head over to the  Tiobe Index of Programming Languages at  http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html .</p><p>可以称，Lisp可以同时成为世界上最常见的最常见的最罕见的编程语言。我们可以量化这一点。在http://www.tiobe.com/index.php/content/papfo/tpci/index.html中掌舵编程语言的Tiobe指数。</p><p> As of August 2014, the lead of the pack is populated by the usual suspects…  C, Java, Objective-C &amp; C++</p><p> 截至2014年8月，包装的主要嫌疑人居住...... C，Java，Objective-C＆amp; C ++</p><p>    This of course proves nothing besides popularity. A single lens reflex camera, while infinitely more useful for photography, is still less common than cameras built into smart phones.</p><p>    除了普及，这当然没有任何人证明。单镜头反射相机，而对于摄影无限更有用，仍然不如智能手机内置的相机常见。</p><p>  When I say Lisp is more common than any other programming language, I mean this: No matter if you are programming in Python or C++, Lisp is invariably what holds up the scaffolding behind the scenes. This is true because Lisp is the Lingua Franca of your compiler. Your compiler does not work with the syntax that you see, semicolons in C++ or significant white space in Python. Rather it discards this at the earliest possible moment and converts your code into an  abstract syntax tree or  AST. That AST is composed of lists of lists containing statements and expressions. Your compiler prefers this format for working with your code because it needs a format that is suitable for representing code as data, one of the core tenets of Lisp. It needs this because it must be able to both transform and optimise your code. For example, it may want to elide, re-arrange, or parallelize. Yet it must reason about the equivalence of the transformations it makes. In other words,   your compiler needs to “calculates code,” precisely what Lisp is great at by way of its  homoiconic syntax. So your compiler borrows this concept to build one or more  Intermediate Representations ( IR) using abstract syntax trees.  Being a List Processor and working with Abstract Syntax Trees, your compiler may essentially be regarded as a Lisp engine. We can extract this intermediate representation from compilers like GCC and CLANG.</p><p>  当我说Lisp比任何其他编程语言更常见时，我的意思是：无论你在Python或C ++中编程，Lisp都是总是阻止幕后脚手架的内容。这是真的，因为Lisp是您编译器的Lingua Franca。您的编译器不适用于您在Python中看到的C ++或大量空白空间中看到的语法。相反，它在最早的时刻丢弃了这一点，并将代码转换为抽象语法树或AST。 AST由包含陈述和表达式的列表列表组成。您的编译器更喜欢使用代码的这种格式，因为它需要一种适合代表代码作为数据的格式，Lisp的一个核心原则。它需要这是因为它必须能够转换和优化代码。例如，它可能希望ELINE，重新安排或并行化。然而，它必须推理它所做的转换的等价。换句话说，您的编译器需要“计算代码”，精确地通过其谐波语法来完善。因此，您的编译器借此概念来使用抽象语法树构建一个或多个中间表示（IR）。作为列表处理器并使用抽象语法树，您的编译器本质上可能被视为LISP引擎。我们可以从GCC和Clang等编译器中提取此中间表示。</p><p> Let’s take the very trivial example of a C++ function square() being called from a function main.</p><p> 让我们拍摄来自函数主的C ++函数方形（）的非常简单的示例。</p><p>  CLANG generates this AST for the function square() using the command “  clang++ -cc1 -ast-dump hellofun.cpp”</p><p>  clang使用命令“clang ++ -cc1-ast-dump hellofun.cpp”来为函数方形（）生成此AST</p><p>    Immediately clear is the canonically correct Lisp indentation and code layout. This format is actually very illuminating because it makes it obvious, for example, where type casts have been inferred by the compiler.  Similarly, we may elicit our AST from GCC as shown below. We use “  g++ -fdump-rtl-dfinish hello fun.cpp“.</p><p>    立即明确是Cononally正确的Lisp缩进和代码布局。此格式实际上非常亮起，因为它使得它可以显而易见，其中编译器推断出类型。同样，我们可能会引起来自GCC的AST，如下所示。我们使用“g ++ -fdump-rtl-dfinish hello fun.cpp”。 </p><p>  Returning to our analogy from photography, less capable cameras built into smart phones are more common than professional single lens reflex cameras. But for the average professional photographer this is of no consequence. A professional wedding photographer capturing life’s shiny moments in glamorous portraits will not find himself compelled to reach for a smart phone camera.  But how would this be different if wedding photography took months and could avail itself of pre-existing work done by multitudes of  smart phone users the world over ? Assume further that re-use depended on compatibility of  the photographic material.  And here lies the problem of programming languages like Haskell, OCaml &amp; Lisp. They are extremely expressive. But they require certain a mathematical acumen, that eludes mainstream IT. Consequently the majority of problems solved in IT are expressed in less expressive languages. So while Haskell, OCaml &amp; Lisp are more expressive, what is the use of being more expressive if you have to express most everything yourself? Being pragmatic means realising that re-using the wealth of very mature Java, C++ &amp; Python libraries can be just as or more useful than writing such library support yourself in a more expressive language.  Of course this consideration is subject to other factors, such as whether you require proof of correctness, or the ability to evolve third-party libraries yourself. Understanding your requirements will go a long way here.</p><p>从摄影中返回我们的类比，内置于智能手机中的机会较低的摄像机比专业的单镜头反射相机更常见。但对于平均专业摄影师来说，这无关紧要。专业的婚礼摄影师捕捉生活在迷人的肖像中的闪亮时刻不会发现自己被迫到达智能手机相机。但是，如果婚纱摄影需要数月，这会如何不同，并且可以利用世界过度的智能手机用户多级的现有工作？进一步假设重新使用依赖于摄影材料的兼容性。在这里介绍了哈斯克尔，OCAML＆amp等编程语言的问题;丽斯普。它们非常表达。但是他们需要某些数学敏锐，将其主流主流。因此，它在其上解决的大多数问题以较少的表达语言表示。所以，虽然Haskell，Ocaml＆amp; Lisp更具表现力，如果你必须表达最大部分的一切，所以更具表现力是什么？务实意味着实现重新使用非常成熟的Java，C ++和amp的财富; Python库可以与编写此类图书馆以一种更具表现性语言写入此类图书馆等级，也可以更有用。当然，这种考虑因素受其他因素，例如您是否需要证明正确性，或者自己宣传第三方图书馆的能力。了解您的要求将在这里走很长的路。</p><p>  What trend can be expected in the future? We have highlighted a  convergence of C++ on Lisp as well as the  emergence of functional programming in C++ in previous articles.  For C++ this is new.  In Java this trend is old and open by admission. Guy Steele, co-author of the Java language specification at Sun Microsystems  is quoted as saying “  We were after the C++ programmers. We managed to drag a lot of them about halfway to Lisp.” The original quote can be read in context here  http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg04045.html. Guy Steele is also known as the author of the Lisp dialect Scheme. Yet the irony is this: Each time another programming language adopts yet more features from Lisp — the same is true for functional programming and Haskell, OCaml etc. — this detracts from Lisp itself, or Haskell or OCaml. Why ? Because the cost benefit analysis tips in favour of the less expressive, more mainstream language. This is true because the mainstream language will always have superior library support, yet the list of benefits bestowed exclusively by features exclusive to Lisp ( or Haskell, OCaml, etc. ) has just diminished. So rather than being a case of advocacy, the trend becomes self-defeating. Programming languages are most often thought of as a man-machine interface. They are just as much a medium of communication between programmers and software engineers. It stands to reason then that the trend will always be towards mainstream. As university curricula target a wider audience, and IT becomes less a matter for computer scientists and mathematicians, so too mainstream IT will trend towards programming languages that require less mathematical acumen than is demanded by languages such as OCaml, Haskell or Lisp.</p><p>  未来可以预期哪些趋势？我们强调了LISP上C ++的融合以及以前文章中的C ++中的功能规划的出现。对于C ++这是新的。在Java中，这种趋势是旧的，通过入场开放。 Guy Steele，Sun Microsystems的Java语言规范的共同作者被引用如同说“我们在C ++程序员之后。我们设法拖累了大约一半到丽斯普。“可以在上下文中阅读原始报价http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg04045.html。 Guy Steele也被称为Lisp方言计划的作者。然而，讽刺是：每次另一个编程语言都采用Lisp的更多功能 - 功能规划和Haskell，OCAML等的相同都是如此 - 这减少了Lisp本身，或Haskell或Ocaml。为什么 ？因为成本效益分析提示，支持较低的表现力，更多的主流语言。这是真的，因为主流语言将始终拥有卓越的图书馆支持，但专门由Lisp（或Haskell，OCAML等）专门赋予的优势列表刚刚减少。所以而不是作为倡导的情况，趋势变得彻底挫败。编程语言通常被认为是男机界面。它们只是程序员和软件工程师之间的沟通媒介。它受到推理，那么趋势将永远是主流。随着大学课程的目标是更广泛的受众，计算机科学家和数学家仍然是一个问题，所以太主流它将朝着规划语言的趋势趋势，这些语言需要较少的数学敏感，而不是由OCAML，HASKELL或LISP所要求的数学敏谱。</p><p> Rich Hickey understood this when he devised Clojure. Because there is only one thing more powerful than having extreme expressiveness OR mature library re-use at your fingertips: and that is to have them both. Yet again, there is precedent. Common Lisp has been embeddable in C for some time by way of ECL,  Embedded Common Lisp. ECL has traditionally focused on embedding in C, but less well-known also works with C++, including the more recent C++11. Coincidentally, as C++ tends more towards modelling state in closures and functions, the lack of emphasis on object orientation in ECL will become less of an issue.</p><p> 当他设计的Clojure时，富豪的HICKEY了解这一点。因为只有一件事比在你的指尖中重新使用的极端表达力或成熟的图书馆，所以这就是让它们都有。再次，有先例。常见的LISP通过ECL，嵌入式常见的LISP嵌入了一段时间内嵌入了C. ECL传统上专注于嵌入C中，但不太众所周知的也适用于C ++，包括最近的C ++ 11。巧合，随着C ++在封闭和功能中趋于建模状态，缺乏强调ECL中的对象方向将变得越来越少。</p><p>    2) “Live programming” via a Python style REPL directly in a C++ process</p><p>    2）通过Python样式直接在C ++进程中进行“现场编程”</p><p>   5) The ability to re-use not only C++ libraries from Lisp but also re-use all of Lisp’s libraries</p><p>   5）重新使用的能力不仅从LISP中使用C ++库，还重新使用所有Lisp的库</p><p>    If you are building ECL from source, make sure you are building with C++ support. See screenshot below for an example.</p><p>    如果您从来源构建ECL，请确保使用C ++支持。有关示例，请参阅下面的屏幕截图。</p><p>   Show below is the C++ source code for our recipe.  Assuming your ECL installation is to be found under the /usr/local prefix and further assuming you have saved the source code in the single file main.cpp,  you might compile this example as follows :</p><p>   以下是我们配方的C ++源代码。假设您在/ usr / local prefix下找到ECL安装，并且在进一步假设您在单个文件Main.cpp中保存了源代码，您可能会按如下方式编译此示例： </p><p>  Note that this example assumes OSX and g++ with an LLVM backend that requires the  -stdlib=libstdc++ flag. On Linux, this would not be required.  Please refer to comments in the code for explanations.</p><p>请注意，此示例假定具有LLVM后端的OSX和G ++，该后端需要-stdlib = libstdc ++标志。在Linux上，这是不需要的。请参阅代码中的注释以获取解释。</p><p>      If you ran the above g++ command line, you will have a binary called  a.out.  Let’s start this.</p><p>      如果您运行上述G ++命令行，则将有一个名为a.out的二进制文件。让我们开始这个。</p><p>  So what happened ? We initialised our Lisp engine within C++, the performed any relevant initialization via initrc.lisp. This will prove incredibly useful later.  We then evaluated a Lisp function (makeanumber) and streamed its output to cout. Noteworthy here is that C++11 was happy to infer the type from ECLs eco_to_float() function, eliminating any redundancy in type declarations. Incidentally (makeanumber) has been  byte-compiled. Subsequently we entered our program’s main loop.</p><p>  所以发生了什么事 ？我们在C ++中初始化了我们的LISP引擎，通过initrc.lisp执行了任何相关的初始化。这将在以后非常有用。然后，我们评估了一个LISP函数（Makeanumber）并将其输出流式传输到COUT。值得注意的是，C ++ 11很乐意推断从ECLS ECO_TO_FLOAT（）函数的类型，从而消除了类型声明中的任何冗余。顺便提及（MakeAnumber）已被编译。随后我们进入了我们的程序的主循环。</p><p>   We now have a  REPL inside our C++ process using Lisp’s excellent exception handling and restarts system. Restarts are one of the finer points of Lisp, one yet to find its way into C++.  Having a REPL means we can go an poke around.  Whatever we do here will be   interpreted. One of the functions we defined was (runtime) it denotes our loop variable. Let’s try that.</p><p>   我们现在使用LISP的优秀异常处理和重新启动系统，在C ++进程内有一个Repl。重新启动是LISP的粮食点之一，一个人尚未找到它进入C ++的方式。有一个答案意味着我们可以捅一下。无论我们在这里做什么都将被解释。我们定义的函数之一是（运行时）它表示我们的循环变量。让我们试试吧。</p><p>  Ok, so our C++ loop variable has the value 6. But really we can run anything that Lisp has scope to… arithmetic, anything.  This is really useful, because we might, for example, interactively redefine a Lisp function subsequently called as part of the regular execution of our C++ program.  This gives rise to an entire style of programming otherwise alien to C++:  Live Programming.</p><p>  好的，所以我们的C ++循环变量具有值6.但是真的我们可以运行Lisp具有范围的任何东西...算术，任何内容。这真是个有用的，因为我们可以例如交互地重新定义LISP函数随后称为我们的C ++程序的定期执行的一部分。这会引发整个编程风格，否则外星为C ++：现场编程。</p><p> In fact, lets do this right-now. The Lisp function (makeanumber) we called from C++ evaluates to the constant 3.2. We can verify this by re-evaluating it in the REPL.  Let’s change it.  We’ll redefine the function to return something else: 6.4.</p><p> 事实上，让我们现在做到这一点。我们从C ++调用的LISP函数（Makeanumber）评估到常量3.2。我们可以通过在REPT中重新评估它来验证这一点。让我们改变它。我们将重新定义返回其他内容的功能：6.4。</p><p>  There is nothing inherent about using constants here. This could be an arbitrarily complex operation. Indeed we might find other ways to inject the operation into our program, apart from hitting CTRL-C and getting a REPL. We might, for instance, inject this logic via something like  Zero-MQ, a popular message bus technology that abstracts a range of  architectural patterns.  Of course, our C++ program, does not call (makeanumber) again, but if it did, you get the idea … immediate feedback without the edit-compile-debug cycle. Hence the name   Live Programming.</p><p>  在这里使用常量没有任何固有的。这可能是任意复杂的操作。事实上，我们可能会发现其他方法可以将操作注入我们的程序，除了击中Ctrl-C并获取求助。例如，我们可以通过Zero-MQ的一些流行的消息总线技术来注入此逻辑，这是一种绘图一系列架构模式。当然，我们的C ++程序，不再调用（MakeAnumber），但如果它确实如此，你就会得到这个想法...立即反馈而没有编辑编译-调试周期。因此，名称直播编程。 </p><p> Now let’s confuse our C++ runtime a bit. Say we want our loop variable to assume the value 60 instead and proceed from there.  Remember those restarts? Exceptions such as CTRL-C are “restartable.”  Just tell Lisp to (continue).</p><p>现在让我们将C ++运行时间困惑一下。假设我们希望我们的循环变量遵守值60，然后从那里开始。还记得那些重启吗？诸如Ctrl-C等异常“重新启动”。只是告诉LISP（继续）。</p><p>   Beyond  Live-Programming and the  REPL, it is easy to see how this paradigm might be extended to provide configuration management. If we can set application parameters and script this in a file without having to compile and link a new C++ binary, then we can provide a means of configuration management. But don’t we have XML for this today? We do. And a one-on-one comparison of XML vs Lisp based configuration could fill pages and start several flame wars. Yet this is not the goal.  We do observe that we have included but one single header file,   ecl.h,  and in turn ended up with a REPL in C++, Live Programming and Configuration Management — all in one. A key aim of software engineering is to manage and reduce complexity. The astute reader will observe that all our boiler plate code so far fits in about 50 lines of code — excluding comments. A paradigm that solves a problem in 500 lines of code is the lesser of a paradigm that solves the same problem in 50 lines of code. A paradigm that solves 3 or more problems in 50 lines of code…</p><p>   超出实时编程和REPT，很容易看出如何扩展此范例以提供配置管理。如果我们可以在文件中设置应用程序参数和脚本，而无需编译并链接新的C ++二进制文件，那么我们可以提供配置管理的手段。但我们今天没有XML吗？我们的确是。并且XML与LISP基础配置的一对一比较可以填充页面并启动几种火焰战争。然而这不是目标。我们会观察到我们已包括一个单个标题文件，ECL.H，并在C ++中的REPT结束，直播编程和配置管理 - 全部。软件工程的一个关键目标是管理和降低复杂性。 Astute Reader将观察到所有锅炉板代码到目前为止，符合大约50行的代码 - 不包括评论。解决500行代码中的问题的范式是解决方法的较小范式，该范式可以解决50行代码中的相同问题。在50行代码中解决3个或更多问题的范式......</p><p> More than just a REPL, this so called BREAK-LOOP hides a full featured symbolic debugger.</p><p> 不仅仅是一个求助，这就是所谓的断裂循环隐藏了一个完整的符号调试器。</p><p>  Just to recap, so far we have seen C++ calling in-line Lisp; Lisp calling C++; a Lisp REPL inside of a C++ process; a full symbolic Lisp debugger inside of C++; byte compiled and interpreted mode of execution; as well as trivial Live-Programming. We are yet to see full integration with Lisp’s package management system and fully compiled Lisp code inside of C++.</p><p>  只是为了回顾，到目前为止，我们已经看到了C ++呼叫在线Lisp; Lisp呼叫C ++;在C ++进程内部的LISP求页; C ++内部完整的符号LISP调试器;字节编译和解释的执行方式;以及琐碎的实时编程。我们尚未与LISP的包管理系统完全集成，并在C ++内完全编译的LISP代码。</p><p> For more information about package management, you might wish to read up on  ASDF and  Quicklisp.  There are some 1000+ libraries available under Quicklisp. We will skip the detail, but think   cmake-and-Python-PIP combined. Imagine I wanted to use  sqlite – how would I make this available to my application ?  Like so:</p><p> 有关包管理的更多信息，您可能希望在ASDF和QuickLisp上读取。在QuickLisp下有一些1000多个库。我们将跳过细节，但认为cmake-yobon-pip组合。想象一下，我想使用sqlite  - 我如何将其申请可用？喜欢：</p><p>   This achieves the equivalent of Python’s PIP install.  How do we make this available within a Lisp application? We “require” it.</p><p>   这实现了相当于Python的PIP安装。我们如何在LISP应用程序中提供此功能？我们“要求”它。</p><p>  Pythonistas know this as “ import.” But this is fully compiled code. No interpreter, no GIL ( Python global interpreter lock limiting concurrency ). Just the same convenience as Python.</p><p>  Pythonistas知道这是“导入”。但这是完全编译的代码。没有翻译，没有GIL（Python全球解释器锁定并发）。与Python一样方便。 </p><p>  The real question is: how do I make this available inside of C++ ? Well, essentially the same way we demonstrated above in the REPL. What works in the REPL, works the same if byte-compiled or fully compiled. When ECL starts, it loads a bootstrap file called  .eclrc from the user’s home directory . My .eclrc file has three lines. The first two are:</p><p>真正的问题是：我如何在C ++内部提供此功能？嗯，基本上与我们在求助中展示的方式相同。什么在REPT中有效，如果BYTE编译或完全编译，则相同的工作。当ECL启动时，它会从用户的主目录中加载名为.eclrc的引导文件。我的.eclrc文件有三行。前两个是：</p><p>  The first imports  ASDF, the second imports  Quicklisp.  An embedded ECL instance does not load  .eclrc by default since there is an expectation that the application might be deployed outside of the context of the developer’s home directory. But our recipe already envisages its own bootstrap file called  initrc.lisp — associated specifically with our C++ application .  Loading sqlite support from within our embedded Lisp C++ application is thus essentially reduced to :</p><p>  第一个进口ASDF，第二个进口QuickLisp。默认情况下，嵌入的ECL实例不加载.eclrc，因为期望应用程序可能会部署在开发人员主目录的上下文之外。但我们的配方已经设想了自己的引导文件，称为initrc.lisp  - 与我们的C ++应用程序一起关联。从我们的嵌入式LISP C ++应用程序中加载SQLite支持，因此基本上还减少了：</p><p>   This brings us to our final point: fully compiling our Lisp code for better performance inside of our C++ application. What we are after is the expressiveness of Python without its lacklustre performance. To make this a little more interesting, we will inline C++ directly inside Lisp.  Matthias Benkard’s journal has a great post on how to inline C++ in ECL.  The  (c-inline) macro can be persuaded to inline C++ as well as C. What is not immediately obvious from the posting is that the code presented is not immediately usable. Rather inlining C++ presumes static compilation.  Matthias gives the following example:</p><p>   这将我们带来了最后一点：完全编制我们的LISP代码，以便在C ++应用程序内更好地表现。我们之后的是Python的表现因表现没有巨大的表现。要使这一点更有趣，我们将直接在Lisp内联机C ++。 Matthias Benkard的期刊在ECL中如何在C ++方面有一个很好的帖子。 （C-Inline）宏可以被说服为内联C ++以及C.从发布中没有立即显而易见的是，所呈现的代码不是立即使用的代码。相反，不含C ++假定静态编译。 Matthias提供以下示例：</p><p>  To use Matthias’ code we must first compile it — as we might rather expect with any C++ source. We do this simply via  (compile-file) and  (load) directly from within Lisp. Now executing the function  (c++hex) works as expected.</p><p>  要使用Matthias的代码，我们必须首先编译它 - 正如我们可能希望与任何C ++源都希望。我们通过直接从Lisp内直接通过（编译文件）和（加载）来执行此操作。现在正在执行函数（C ++ HEX）按预期工作。</p><p>  Here again, if we want to avail ourselves of this technique in our C++ recipe, we require but one small modification to our initialize() function – two lines of code.  We replace  (load) with  (compile-file) and a subsequent  (load) with the latter eliding the file name extension.</p><p>  如果我们希望在我们的C ++配方中利用这种技术，我们需要对我们的初始化（）函数进行一次小修改 - 两行代码。我们用（Compile-File）替换（加载）和后续（加载），后者闪烁文件名扩展。</p><p>  This produces an interesting  JIT style behaviour when running our C++ application.  We can even observe the system  CLANG compiler doing it’s magic because  CLANG warning are finding their way to standard out.</p><p>  运行C ++应用程序时，这会产生有趣的JIT样式行为。我们甚至可以观察系统Clang编译器，以魔术为代表，因为Clang警告正在寻找标准化的方式。</p><p>  To conclude, we have changed but one line of Lisp code and added another to our C++ recipe and have in effect added both  Lisp JIT and  C++ JITcapabilities — prototyped and demonstrated working all in  under one minute of coding. Solving complexity with the smallest number of moving parts: this is what software engineering is all about!</p><p>  要得出结论，我们已经改变了一行LISP代码，并为我们的C ++配方添加了另一行，并生效地添加了Lisp JIT和C ++ JitCapabilities  - 原型和在编码一分钟内完成工作。解决复杂性与最小的移动部件：这是软件工程的全部！ </p><p> Like Clojure to Java, ECL can be used to host Lisp within C++.  Head over to  Meta-Circular Adventures in Functional Abstraction on how to leverage this capability for full featured functional programming. One key difference with ECL and C++ is that we have simple yet effective control over the AOT of our JIT process. We may chose to interpret, byte-compile or fully AOT/JIT compile at a point of our choosing.</p><p>像Clojure到Java一样，ECL可用于在C ++中托管Lisp。 在如何利用这种功能的功能抽象中，在功能抽象中转到Meta循环冒险经历。 与ECL和C ++的一个关键区别是我们对我们的JIT过程的AOT有效而有效地控制。 我们可能选择在我们选择的点时解释，字节编译或完全AOT / JIT编译。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://lambdafaktorie.com/embedding-lisp-in-c-a-recipe/">https://lambdafaktorie.com/embedding-lisp-in-c-a-recipe/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/嵌入/">#嵌入</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>