<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用锈病写的锈病 Writing Pong in Rust for My OS Written in Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Writing Pong in Rust for My OS Written in Rust<br/>用锈病写的锈病 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-15 13:16:36</div><div class="page_narrow text-break page_content"><p>We last left off writing a graphics driver and an event driver for our operating system. We also added several system calls to handle drawing primitives as well as handling keyboard and mouse inputs. We are now going to use those to animate the simple game of  pong. Just like hello world is the test of every programming language, pong is a test of all of our graphics and event systems.</p><p>我们持续为我们的操作系统写入图形驱动程序和事件驱动程序。我们还添加了几个系统调用来处理绘图基元以及处理键盘和鼠标输入。我们现在将使用那些动作乒乓球的简单游戏。就像Hello World是每个编程语言的测试，Pong都是我们所有的图形和事件系统的考验。</p><p>   Since we’re writing in user space, we need to use the system calls we developed to (1) enumerate the framebuffer, (2) invalidate sections of the framebuffer, (3) read keyboard/click events, and (4) read motion events–mouse or tablet.</p><p>   由于我们在用户空间中编写，我们需要使用我们开发的系统调用（1）枚举帧缓冲器，（2）无效的帧缓冲器的部分，（3）读取键盘/单击事件，（4）读取动作事件 - 鼠标或平板电脑。</p><p> For Rust, we are still using the riscv64gc-unknown-none-elf target, which doesn’t contain a runtime. Now, riscv64gc-unknown-linux-gnu does exist, however it uses Linux system calls, which we haven’t implemented, yet. So, we are required to create our own system call interface as well as runtime!</p><p> 对于Rust，我们仍在使用RISCV64GC-Unknown-None-Elf目标，其不包含运行时。现在，RISCV64GC-Unknown-Linux-GNU确实存在，但它使用Linux系统调用，我们还没有实现。因此，我们需要创建自己的系统调用界面以及运行时！</p><p>   Many programmers know that ELF allows our entry point to start anywhere. However, most linkers will look for a symbol called _start. So, in Rust, we have to create this symbol. Unfortunately, after many attempts, I could not get it to work fully in Rust. So, instead, I used the global_asm! macro to import an assembly file. All it does is call main and invokes the  exit system call when main returns.</p><p>   许多程序员知道ELF允许我们的入口点开始任何地方。但是，大多数链接器都会查找称为_start的符号。所以，在Rust中，我们必须创建这个符号。不幸的是，经过多次尝试，我无法让它完全锈蚀。所以，相反，我使用了global_asm！宏导入汇编文件。所有它所做的就是调用Main并在主返回时调用退出系统调用。</p><p> .section .text.init.global _start_start:.option push.option norelax	la	gp, __global_pointer$.option pop	li		a0, 0	li		a1, 0	call	main	# Exit system call after main	li	a7, 93	ecall.type _start, function.size _start, .-_start</p><p> .text.init.global _start_start：.option push.option norelax la gp，__global_pointer $ .option pop li a0,0 li a1，0致电主＃退出系统调用主li a7,93 ecall.type _start，function .size _start，。-_开始</p><p> I did fail to mention about the global pointer. Since global variables can be stored far away, we use a register to store the top of this location. Luckily, most linkers have a symbol called __global_pointer$ (yes, even with the $) that we put into the gp (global pointer) register. I’m not going to cover relaxation, but this is necessary.</p><p> 我没有提到全球指针。由于全局变量远处存储，因此我们使用寄存器来存储此位置的顶部。幸运的是，大多数链接器都有一个名为__global_pointer $的符号（是的，即使是$ $），我们投入GP（全局指针）寄存器。我不会覆盖放松，但这是必要的。</p><p> This is all that we need to get into Rust. However, since we’re still in baremetal Rust, we have to define the same symbols we did for our OS, including the panic and abort handlers.</p><p> 这就是我们需要进行生锈的全部。但是，由于我们仍处于公理生锈，我们必须定义我们为OS为OS的相同符号，包括恐慌和中止处理程序。 </p><p> #![no_std]#![feature(asm, panic_info_message, lang_items, start, global_asm)]#[lang = &#34;eh_personality&#34;]extern &#34;C&#34; fn eh_personality() {}#[panic_handler]fn panic(info: &amp;core::panic::PanicInfo) -&gt; ! {	print!(&#34;Aborting: &#34;);	if let Some(p) = info.location() {		println!(&#34;line {}, file {}: {}&#34;, p.line(), p.file(), info.message().unwrap());	} else {		println!(&#34;no information available.&#34;);	}	abort();}#[no_mangle]extern &#34;C&#34; fn abort() -&gt; ! {	loop {		unsafe {			asm!(&#34;wfi&#34;);		}	}}</p><p>＃！[no_std]＃！[功能（asm，panic_info_message，lang_items，start，global_asm）]＃[lang =＆＃34; eh_personality＆＃34;] extern＆＃34; c＆＃34; fn eh_personality（）{}＃[panic_handler] fn panic（信息：＆amp; core :: panic :: panicinfo） - ＆gt; ！！ {打印！（＆＃34;中止：＆＃34;）;如果让某些（p）= info.location（）{println！（＆＃34; line {}，文件{}：{}}＆＃34; p.line（），p.file（），info.message （）.unwrap（））; } else {println！（＆＃34;没有信息。＆＃34;）; abort（）;}＃[no_mangle] extern＆＃34; c＆＃34; Fn abort（） - ＆gt; ！！ {循环{不安全{ASM！（＆＃34; WFI＆＃34;）; }}}</p><p> This allows our code to at least compile, but as you can see we need to import the assembly file as well as define a main.</p><p> 这允许我们的代码至少编译，但尽可能看到我们需要导入程序集文件以及定义主要。</p><p>  Now we have an entry point for Rust. Now, we can create the println and print macros to make Rust be more Rusty for us.</p><p>  现在我们有一个生锈的入学点。现在，我们可以创建Println和打印宏以使我们生锈更生锈。</p><p> #[macro_export]macro_rules! print{	($($args:tt)+) =&gt; ({			use core::fmt::Write;			let _ = write!(crate::syscall::Writer, $($args)+);			});}#[macro_export]macro_rules! println{	() =&gt; ({		 print!(&#34;\r\n&#34;)		 });	($fmt:expr) =&gt; ({			print!(concat!($fmt, &#34;\r\n&#34;))			});	($fmt:expr, $($args:tt)+) =&gt; ({			print!(concat!($fmt, &#34;\r\n&#34;), $($args)+)			});}</p><p> ＃[宏_export] macro_rules！打印{（$（$（$ args：tt）+）=＆gt; （{使用核心:: fmt ::写;让_ =写！（箱子:: syscall :: writer，$（$ args）+）;}）;}＃[宏_export]宏_rules！ println {（）=＆gt; （{打印！（＆＃34; \ r \ n＆＃34;）}）; （$ fmt：expr）=＆gt; （{打印！（concat！（$ fmt，＆＃34; \ r \ n＆＃34;））; （$ fmt：expr，$（$ args：tt）+）=＆gt; （{打印！（concat！（$ fmt，＆＃34; \ r \ n＆＃34;），$（$ args）+）}）;}</p><p>   We need to create an API for system calls, since that will be how we get and put certain data to our operating system. Generally, the runtime will establish this for us, but again, we’re in baremetal Rust.</p><p>   我们需要为系统调用创建一个API，因为这将是我们如何获得和将某些数据放到我们的操作系统。一般来说，运行时将为我们建立这个，但再次，我们在aremetal生锈中。</p><p> use core::fmt::{Write, Error};use crate::event::Event;pub struct Writer;impl Write for Writer {	fn write_str(&amp;mut self, out: &amp;str) -&gt; Result&lt;(), Error&gt; {		for c in out.bytes() {			putchar(c);		}		Ok(())	}}pub fn putchar(c: u8) -&gt; usize { syscall(2, c as usize, 0, 0, 0, 0, 0, 0)}pub fn sleep(tm: usize) { let _ = syscall(10, tm, 0, 0, 0, 0, 0, 0);}pub fn get_fb(which_fb: usize) -&gt; usize { syscall(1000, which_fb, 0, 0, 0, 0, 0, 0)}pub fn inv_rect(d: usize, x: usize, y: usize, w: usize, h: usize) { let _ = syscall(1001, d, x, y, w, h, 0, 0);} pub fn get_keys(x: *mut Event, y: usize) -&gt; usize {	 syscall(1002, x as usize, y, 0, 0, 0, 0, 0)}pub fn get_abs(x: *mut Event, y: usize) -&gt; usize {	 syscall(1004, x as usize, y, 0, 0, 0, 0, 0)}pub fn get_time() -&gt; usize { syscall(1062, 0, 0, 0, 0, 0, 0, 0)}pub fn syscall(sysno: usize, a0: usize, a1: usize, a2: usize, a3: usize, a4: usize, a5: usize, a6: usize) -&gt; usize { let ret; unsafe { asm!(&#34;ecall&#34;, in (&#34;a7&#34;) sysno, in (&#34;a0&#34;) a0, in (&#34;a1&#34;) a1, in (&#34;a2&#34;) a2, in (&#34;a3&#34;) a3, in (&#34;a4&#34;) a4, in (&#34;a5&#34;) a5, in (&#34;a6&#34;) a6, lateout(&#34;a0&#34;) ret); } ret}</p><p> 使用核心:: fmt :: {write，错误};使用crate :: event ::事件; Pub struct作家; ichrit for Writer {fn write_str（＆amp; mut self，Out：＆amp; str） - ＆gt;结果＆lt;（），错误＆gt; {for c out.bytes（）{PUTCHAR（C）; } OK（（））}} PUB FN PUTCHAR（C：U8） - ＆gt; USIZION {SYSCALL（2，C为USIZE，0,0,0,0,0,0）} PUB FN睡眠（TM：USIZE）{LET _ = SYSCALL（10，TM，0,0,0,0,0,0 ，0）; PUB FN GET_FB（哪个_FB：USIZIZE） - ＆gt; USIZIZE {SYSCALL（1000个，哪一个，0,0,0,0,0,0,0）} PUB FN INV_RECT（D：USIZE，X：USIZE，Y：USIZE，W：USIZE，H：USIZIZE）{LET _ = SYSCALL （1001，d，x，y，w，h，0,0）; pub fn get_keys（x：* mut事件，y：me：measize） - ＆gt; Usize {Syscall（1002，x为Usize，Y，0,0,0,0,0）} Pub Fn Get_abs（x：* mut事件，Y：USIZE） - ＆gt; USIZION {SYSCALL（1004，X为USIZE，Y，0,0,0,0,0）} PUB FN GET_TIME（） - ＆gt; Usize {Syscall（1062,0,0,0,0,0,0,0,0）} Pub Fn Syscall（Sysno：Usize，A0：Usize，A1：Usize，A2：Usize，A3：Usize，A4：USIZE，A5：USIZE，A5 ：Usize，A6：Usize） - ＆gt; USIZIZE {让RET;不安全{asm！（＆＃34; ecall＆＃34;（＆＃34; a7＆＃34;）sysno，在（＆＃34; a0＆＃34;）a0，在（＆＃34; a1＆＃34; ）A1，IN（＆＃34; A2＆＃34;）A2，IN（＆＃34; A3＆＃34;）A3，IN（＆＃34; A4＆＃34;）A4，IN（＆＃34; A5＆＃ 34;）A5，IN（＆＃34; A6＆＃34;）A6，乳顿（＆＃34; A0＆＃34;）RET）; } ret}</p><p> MAN, I love the new Rust asm! It is very clear what’s happening when you look at it. Usually when I use inline assembly, register selection is extremely important. This makes it rather foolproof–dare I actually say that?</p><p> 男人，我喜欢新的铁锈ASM！很明显，当你看着它时发生了什么。通常在我使用内联组合时，寄存器选择非常重要。这使它变得相当万无一失 - 我真的这么说吗？ </p><p> Just like we did for our operating system, we use the Write trait to hook into the format macro that is given to us by Rust.</p><p>就像我们为我们的操作系统所做的那样，我们使用写性特性来钩住ruct给我们给我们的格式宏。</p><p>   Ok, with the system calls and the startup code in start.S, we now have everything we need to start programming the game. So, let’s make some drawing primitives. Since this is pong, we only really care about drawing rectangles.</p><p>   好的，通过系统调用和启动代码开始，我们现在拥有开始编程游戏所需的一切。所以，让我们制作一些绘图原语。由于这是乒乓球，我们真的非常关心绘图矩形。</p><p> #[repr(C)]#[derive(Clone,Copy)]pub struct Pixel { pub r: u8, pub g: u8, pub b: u8, pub a: u8,}pub type Color = Pixel;impl Pixel { pub fn new(r: u8, g: u8, b: u8) -&gt; Self { Self { r, g, b, a: 255 } }}pub struct Vector { pub x: i32, pub y: i32}impl Vector { pub fn new(x: i32, y: i32) -&gt; Self { Self { x, y } }}pub struct Rectangle { pub x: i32, pub y: i32, pub width: i32, pub height: i32,}impl Rectangle { pub fn new(x: i32, y: i32, width: i32, height: i32) -&gt; Self { Self { x, y, width, height } }}pub struct Framebuffer { pixels: *mut Pixel}impl Framebuffer { pub fn new(pixels: *mut Pixel) -&gt; Self { Self { pixels } } pub fn set(&amp;mut self, x: i32, y: i32, pixel: &amp;Pixel) { unsafe { if x &lt; 640 &amp;&amp; y &lt; 480 { let v = (y * 640 + x) as isize; self.pixels.offset(v).write(*pixel); } } } pub fn fill_rect(&amp;mut self, rect: &amp;Rectangle, color: &amp;Pixel) { let row_start = rect.y; let row_finish = row_start + rect.height; let col_start = rect.x; let col_finish = col_start + rect.width; for row in row_start..row_finish { for col in col_start..col_finish { self.set(col, row, color); } } }}pub fn lerp(value: i32, mx1: i32, mx2: i32) -&gt; i32 { let r = (value as f64) / (mx1 as f64);	return r as i32 * mx2;}</p><p> ＃[ReP（c）]＃[派生（克隆，复制）] Pub结构像素{Pub R：U8，Pub G：U8，Pub B：U8，Pub A：U8，} Pub类型Color = Pixel; iclilc映像{ PUB FN NEW（R：U8，G：U8，B：U8） - ＆gt;自我{self {r，g，b，a：255}} pub struct矢量{pub x：i32，pub y：i32} isc矢量{pub fn new（x：i32，y：i32） - ＆gt;自我{self {x，y}}} pub struct矩形{pub x：i32，pub y：i32，pub宽度：i32，pub height：i32，} iscland矩形{pub fn new（x：i32，y：i32，宽度：i32，高度：i32） - ＆gt; self {self {x，y，宽度，高度}}} pub struct framebuffer {pixels：* mut pixel} impl framebuffer {pub fn new（像素：* mut pixel） - ＆gt; self {self {pixels}} pub fn set（＆amp; mut self，x：i32，y：i32，pixel：＆amp; pixel）{不安全{如果x＆lt; 640＆amp;＆amp; y＆lt; 480 {让v =（y * 640 + x）如isize; self.pixels.offset（v）.write（* pixel）; PUB FN Fill_Rect（＆amp; mut self，rect：＆amp;矩形，颜色：＆amp; pixel）{let row_start = rect.y;让Row_Finish = Row_Start + Rect.Height;让Col_Start = Rect.x;让col_finish = col_start + rect.width;在row_start的行。{col_start的{for col .col_finish {self.set（col，行，颜色）; PUB FN LERP（值：I32，MX1：I32，MX2：I32） - ＆gt; i32 {设r =（值为f64）/（mx1作为f64）;返回r为i32 * mx2;}</p><p> Now we have a pixel structure, a vector, a rectangle, and a framebuffer. The pixel comes from the operating system, so it is important that we control that structure, which necessitates #[repr(C)].</p><p> 现在我们有一个像素结构，矢量，矩形和帧缓冲。像素来自操作系统，因此我们控制该结构是重要的，这需要＃[Recon（c）]。</p><p>   We can draw, so now we need to be able to handle input. We can create an event structure to handle this.</p><p>   我们可以画出，所以现在我们需要能够处理输入。我们可以创建一个事件结构来处理此功能。</p><p> #[repr(C)]#[derive(Copy, Clone)]pub struct Event { pub event_type: u16,	pub code: u16,	pub value: u32} impl Event {	pub fn empty() -&gt; Self {		Self {			event_type: 0,			code: 0,			value: 0		}	}	pub fn new(event_type: u16, code: u16, value: u32) -&gt; Self {		Self {			event_type,			code,			value		}	}}// Key codespub const KEY_RESERVED: u16 = 0;pub const KEY_ESC: u16 = 1;pub const KEY_1: u16 = 2;pub const KEY_2: u16 = 3;// ... CLIP ...pub const KEY_END: u16 = 107;pub const KEY_DOWN: u16 = 108;// mouse buttonspub const BTN_MOUSE: u16 = 0x110;pub const BTN_LEFT: u16 = 0x110;pub const BTN_RIGHT: u16 = 0x111;pub const BTN_MIDDLE: u16 = 0x112;// mouse movementpub const ABS_X: u16 = 0x00;pub const ABS_Y: u16 = 0x01;pub const ABS_Z: u16 = 0x02;</p><p> ＃[RePr（c）]＃[派生（复制，克隆）] Pub struct事件{Pub Event_type：U16，Pub代码：U16，Pub值：U32} Alcm Event {Pub Fn空（） - ＆gt; self {self {event_type：0，代码：0，值：0}} PUB FN New（event_type：U16，代码：U16，Value：U32） - ＆gt; self {self {event_type，code，value}}}} //键码码}}}} //键码码ucont key_reserved：u16 = 0; pub const key_esc：u16 = 1; pub const key_1：u16 = 2; pub const key_2：u16 = 3; //。 ..剪辑... Pub Const Key_end：Pub Const Key_down：U16 = 108; //鼠标按钮Pub Const BTN_Mouse：U16 = 0x110; Pub Const BTN_LEFT：U16 = 0x110; PUB CONST BTN_RIGHT：U16 = 0x111; PUB const btn_middle：u16 = 0x112; //鼠标移动pubs cand abs_x：u16 = 0x00; pub consac abs_y：u16 = 0x01; pub const abs_z：u16 = 0x02;</p><p> Many of the constants came from libevdev’s input-event-codes.h. Unfortunately, that’s in C, so a little Python script could make it Rust.</p><p> 许多常量来自Libevdev的输入-iffic-codes.h。不幸的是，这是在c中，所以一点python脚本可以使它生锈。 </p><p> Just like the Pixel structure, the Event structure is defined by our operating system, so we are required to control it ourselves (hence #[repr(C)]).</p><p>就像像素结构一样，事件结构由我们的操作系统定义，因此我们必须自己控制它（因此＃[Repre（C）]）。</p><p>   const MAX_EVENTS: usize = 25;const GAME_FRAME_TIMER: usize = 1000;#[start]fn main(_argc: isize, _argv: *const *const u8) -&gt; isize {	use drawing::Framebuffer;	use drawing::Pixel;	let ufb = syscall::get_fb(6) as *mut Pixel;	let mut fb = Framebuffer::new(ufb);	let background_color = drawing::Pixel::new(25, 36, 100);	let mut event_list = [event::Event::empty(); MAX_EVENTS];	let event_list_ptr = event_list.as_mut_ptr();	let player_color = drawing::Pixel::new(255, 0, 0);	let npc_color = drawing::Pixel::new(0, 255, 0);	let ball_color = drawing::Pixel::new(255, 255, 255);	let mut game = pong::Pong::new(player_color, npc_color, ball_color, background_color);	// GAME LOOP HERE	println!(&#34;Goodbye :)&#34;);	0}</p><p>   const max_events：musize = 25; const game_frame_timer：measize = 1000;＃[开始] fn main（_argc：isize，_argv：* const * const u8） - ＆gt; isize {使用绘图:: FrameBuffer;使用绘图:: pixel;让UFB = SYSCALL :: GET_FB（6）作为* mut像素;让MUT FB = FrameBuffer :: New（UFB）;让Backgrounds_color =绘图:: Pixel :: New（25,36,100）;让mut event_list = [事件:: event :: fight（）; max_events];让event_list_ptr = event_list.as_mut_ptr（）;让玩家_color =绘图:: pixel :: new（255,0,0）;让npc_color =绘图:: pixel :: new（0,255,0）;让Ball_Color =绘图:: Pixel :: New（255,255,255）;让mut游戏= pong :: pong :: new（player_color，npc_color，ball_color，background_color）; //游戏循环在这里println！（＆＃34;再见：）＆＃34;）; 0}</p><p> You can see the first thing we do is grab a framebuffer. If you recall from the operating system tutorial, our operating system will map the pixels into our application’s memory space. We can update the pixels as we see fit, but to actually realize it on the screen, we must  invalidate the given pixels, which is a separate system call in our OS.</p><p> 你可以看到我们所做的第一件事是抓取框架缓冲。如果您从操作系统教程中记得，我们的操作系统将将像素映射到我们的应用程序的内存空间中。我们可以在屏幕上实际实现它时更新像素，但要在屏幕上实现它，我们必须使给定的像素无效，这是我们操作系统中的单独系统调用。</p><p> You can see we have a structure called Pong. This structure contains the routines we need to make this somewhat a game. We have a timing function called advance_frame, and we have a way to get the game onto the screen using the draw function.</p><p> 你可以看到我们有一个名为pong的结构。这种结构包含我们需要做到这一点的例程。我们有一个名为authand_frame的时序函数，我们有一种方法可以使用绘制功能将游戏获取到屏幕上。</p><p> This is pretty gross, but here’s the Pong structure’s advance frame and draw routines (the rest can be found on GitHub):</p><p> 这是非常粗糙的，但这是Pong Sristure的提前框架和绘制例程（其余的可以在GitHub上找到）：</p><p> impl Pong {	pub fn advance_frame(&amp;mut self) {		if !self.paused { self.move_ball(self.ball_direction.x, self.ball_direction.y);			let miss = 			if self.ball.location.x &lt; 40 {				// This means we&#39;re in the player&#39;s paddle location. Let&#39;s				// see if this is a hit or a miss!				let paddle = (self.player.location.y, self.player.location.y + self.player.location.height);				let ball = (self.ball.location.y, self.ball.location.y + self.ball.location.height);				if paddle.0 &lt;= ball.0 &amp;&amp; paddle.1 &gt;= ball.0 {					false				}				else if paddle.0 &lt;= ball.1 &amp;&amp; paddle.1 &gt;= ball.1 {					false				}				else {					true				}			}			else {				false			};			if miss {				self.reset();				self.paused = true;			}			else {				if self.ball.location.x &lt; 40 || self.ball.location.x &gt; 580 {					self.ball_direction.x = -self.ball_direction.x;				}				if self.ball.location.y &lt; 20 || self.ball.location.y &gt; 430 {					self.ball_direction.y = -self.ball_direction.y;				}				let new_loc = self.ball.location.y - self.npc.location.height / 2;				self.npc.location.y = if new_loc &gt; 0 { new_loc } else { 0 };			}		}	}	pub fn draw(&amp;self, fb: &amp;mut Framebuffer) {		fb.fill_rect(&amp;Rectangle::new(0, 0, 640, 480), &amp;self.bgcolor);		fb.fill_rect(&amp;self.player.location, &amp;self.player.color);		fb.fill_rect(&amp;self.npc.location, &amp;self.npc.color);		fb.fill_rect(&amp;self.ball.location, &amp;self.ball.color);	}}</p><p> icharm pong {pub fn advance_frame（＆amp; mut self）{if！self.paused {self.ball_direction.x，self.ball_direction.y）;让小姐=如果self.ball.location.x＆lt; 40 {//这意味着我们＆＃39;重新参加玩家＆＃39;桨位置。让＆＃39; s //看看这是一个打击还是错过了！让Paddle =（self.player.location.y，self.player.location.y + self.player.location.height）;让ball =（self.ball.location.y，self.ball.location.y + self.ball.location.height）;如果paddle.0＆lt; = ball.0＆amp;＆amp; Paddle.1＆gt; = ball.0 {false}如果paddle.0＆lt; ball.1＆amp;＆amp;＆amp; Paddle.1＆gt; = ball.1 {false} else {true}} else {false};如果小姐{self.reset（）; self.paused = true; } else {如果self.ball.location.x＆lt; 40 || self.ball.location.x＆gt; 580 {self.ball_direction.x = -self.ball_direction.x;如果self.ball.ball.location.y＆lt; 20 || self.ball.location.y＆gt; 430 {self.ball_direction.y = -self.ball_direction.y; Let new_loc = self.ball.location.y  -  self.npc.location.height / 2; self.npc.location.y =如果new_loc＆gt; 0 {new_loc} else {0}; PUB FN Draw（＆amp; self，fb：＆amp; mut framebuffer）{fb.fill_rect（＆amp; rectangle :: new（0,0,640,480），＆amp; self.bgcolor）; fb.fill_rect（＆amp; self.player.location，＆amp; self.player.color）; fb.fill_rect（＆amp; self.npc.location，＆amp; self.npc.color）; fb.fill_rect（＆amp; self.ball.location，＆amp; self.ball.color）; }}</p><p> So our game will move the ball given the direction vector every frame due to advance_frame being called from our game loop. We also have the ability to pause the game (or unpause). Finally, we have very basic collision detection for the player’s paddle.</p><p> 所以我们的游戏将把球移动到每个框架的指导矢量，因为从我们的游戏循环调用了admain_frame。我们还有能力暂停游戏（或暂停）。最后，我们对玩家的桨具有非常基本的碰撞检测。 </p><p>   Now we need to put all of this together using a  game loop, which will handle input events as well as advance the animation.</p><p>现在我们需要使用游戏循环将所有这一切放在一起，这将处理输入事件以及提前动画。</p><p> // GAME LOOP gameloop: loop {		// handle mouse buttons and keyboard inputs		// println!(&#34;Try get keys&#34;);		let num_events = syscall::get_keys(event_list_ptr, MAX_EVENTS);		for e in 0..num_events {			let ref ev = event_list[e];			// println!(&#34;Key {} Value {}&#34;, ev.code, ev.value);			// Value = 1 if key is PRESSED or 0 if RELEASED			match ev.code {				event::KEY_Q =&gt; break &#39;gameloop,				event::KEY_R =&gt; game.reset(),				event::KEY_W | event::KEY_UP =&gt; game.move_player(-20),				event::KEY_S | event::KEY_DOWN =&gt; game.move_player(20),				event::KEY_SPACE =&gt; if ev.value == 1 { 					game.toggle_pause();					if game.is_paused() {						println!(&#34;GAME PAUSED&#34;);					}					else {						println!(&#34;GAME UNPAUSED&#34;)					}				},				_ =&gt; {}			}		}		game.advance_frame();		game.draw(&amp;mut fb);		syscall::inv_rect(6, 0, 0, 640, 480);		syscall::sleep(GAME_FRAME_TIMER);	}</p><p> //游戏循环游戏弹灵木：循环{//处理鼠标按钮和键盘输入// println！（＆＃34;尝试获取钥匙＆＃34;）;假设num_events = syscall :: get_keys（event_list_ptr，max_events）;在0中为e .NUM_Events {让REF EV = EVEN_LIST [E]; // println！（＆＃34; key {}值{}＆＃34;，ev.code，ev.value）; // value = 1如果按下键或0如果发布匹配ev.code {event :: key_q =＆gt;休息＆＃39; gameloop，event :: key_r =＆gt; Game.Reset（），事件:: key_w |事件:: key_up =＆gt; Game.move_Player（-20），Event :: Key_s |事件:: key_down =＆gt; game.move_player（20），事件:: key_space =＆gt;如果ev.Value == 1 {game.toggle_pause（）;如果game.is_paused（）{println！（＆＃34;游戏暂停＆＃34）; } else {println！（＆＃34;游戏未授予＆＃34;）}，_ =＆gt; game.advance_frame（）; Game.draw（＆amp; mut fb）; syscall :: inv_rect（6,0,0,640,480）; syscall ::睡眠（game_frame_timer）; }</p><p>   Our event loop uses W to move the paddle up or D to move the paddle down. Space toggles the pause and R resets the game.</p><p>   我们的事件循环使用W移动划桨或D移动拨片。空间切换暂停，R重置游戏。</p><p> Hmmm. When I started writing this, it seemed more impressive in my mind. Oh well, have fun!</p><p> 嗯。当我开始写这篇文章时，我的脑海似乎更令人印象深刻。哦，好吧，玩得开心！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.stephenmarz.com/2021/02/22/writing-pong-in-rust/">https://blog.stephenmarz.com/2021/02/22/writing-pong-in-rust/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/锈病/">#锈病</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pub/">#pub</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012 - 2021 diglog.com </div></div></body></html>