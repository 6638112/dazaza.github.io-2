<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>jq实用入门（及更多） A Practical Introduction to jq (and more)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A Practical Introduction to jq (and more)<br/>jq实用入门（及更多） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-22 04:44:10</div><div class="page_narrow text-break page_content"><p>Published December 21, 2020 jq is a command line tool for parsing and modifying JSON. It is useful for extracting relevant bits of information from tools that output JSON, or REST APIs that return JSON. Mac users can install  jq using homebrew ( brew install jq); see  here for more install options.</p><p>2020年12月21日发布jq是用于解析和修改JSON的命令行工具。这对于从输出JSON的工具或返回JSON的REST API中提取相关的信息位很有用。 Mac用户可以使用自制软件来安装jq（brew install jq）；有关更多安装选项，请参见此处。</p><p> In this post we&#39;ll examine a couple &#34;real world&#34; examples of using  jq, but let&#39;s start with...</p><p> 在这篇文章中，我们将研究一对夫妇的真实世界。使用jq的示例，但让我们从...开始</p><p>     {  :  &#34;duchess&#34;,  :  &#34;Toronto&#34;,  : [ {  :  &#34;x&#34;,  :  10 }, {  :  &#34;y&#34;,  :  15 } ]}</p><p>     {：＆＃34; duchess＆＃34 ;,：＆＃34; Toronto＆＃34 ;,：：[{：＆＃34; x＆＃34 ;,：10}，{：＆＃34; y＆＃34 ;,： 15}]}</p><p> I like this pretty-printing/formatting capability so much, I have an alias that formats JSON I&#39;ve copied (in my OS &#34;clipboard&#34;) &amp; puts it back in my clipboard:</p><p> 我非常喜欢这种漂亮的打印/格式化功能，我有一个别名可以格式化已复制的JSON（在我的OS＆＃34; clipboard＆＃34;中）并且把它放回我的剪贴板中：</p><p>  The  &#39;.&#39; in the  jq &#39;.&#39; command above is the simplest jq &#34;filter.&#34; The dot takes the input JSON and outputs it as is. You can read more about filters  here, but the bare minimum to know is that  .keyname will filter the result to a property matching that key, and  [index] will match an array value at that index:</p><p>  ＆＃39;。＆＃39;在jq＆＃39;。＆＃39;中上面的命令是最简单的jq＆＃34; filter。该点接受输入的JSON并按原样输出。您可以在此处阅读有关过滤器的更多信息，但最基本的了解是.keyname会将结果过滤到与该键匹配的属性，而[index]将与该索引处的数组值匹配：</p><p> $  echo  $USERX | jq  &#39;.name&#39; &#34;duchess&#34;$  echo  $USERX | jq  &#39;.orders[0]&#39;{  &#34;id&#34;:  &#34;x&#34;,  &#34;qty&#34;: 10}</p><p> $ echo $ USERX | jq＆＃39; .name＆＃39; ＆＃34; duchess＆＃34; $ echo $ USERX | jq＆＃39; .orders [0]＆＃39; {＆＃34; id＆＃34 ;:＆＃34; x＆＃34 ;,＆＃34; qty＆＃34 ;: 10}</p><p>   Filtering output by value is also handy! Here we use  | to output the result of one filter into the input of another filter and  select(.qty&gt;10) to select only orders with  qty value greater than 10:</p><p>   按值过滤输出也很方便！在这里我们使用|将一个过滤器的结果输出到另一个过滤器的输入中，然后选择（.qty＆gt; 10）仅选择qty值大于10的订单： </p><p>   $ ORDER= &#39;{&#34;user_id&#34;:123,&#34;user_name&#34;:&#34;duchess&#34;,&#34;order_id&#34;:456,&#34;order_status&#34;:&#34;sent&#34;,&#34;vendor_id&#34;:789,&#34;vendor_name&#34;:&#34;Abe Books&#34;}&#39;$  echo  $ORDER | jq  &#39;.&#39;{  &#34;user_id&#34;: 123,  &#34;user_name&#34;:  &#34;duchess&#34;,  &#34;order_id&#34;: 456,  &#34;order_status&#34;:  &#34;sent&#34;,  &#34;vendor_id&#34;: 789,  &#34;vendor_name&#34;:  &#34;Abe Books&#34;}$  echo  $ORDER | jq  &#39;with_entries(select(.key|match(&#34;order_&#34;)))&#39;{  &#34;order_id&#34;: 456,  &#34;order_status&#34;:  &#34;sent&#34;}</p><p>$ ORDER =＆＃39; {＆＃34; user_id＆＃34;：123，＆＃34; user_name＆＃34;：＆＃34; duchess＆＃34;，＆＃34; order_id＆＃34;：456，＆＃ 34; order_status＆＃34;：＆＃34; sent＆＃34;，vendor_id＆＃34;：789，＆＃34; vendor_name＆＃34;：＆＃34; Abe Books＆＃34;}＆＃39; $ echo $ ORDER | jq＆＃39;。＆＃39; {123，user_name＆＃34 ;:＆＃34;公爵夫人＆＃34 ;,＆＃34; order_id＆＃34 ;: 456 ，＆＃34; order_status＆＃34 ;：＆＃34; sent＆＃34 ;、＆＃34; vendor_id＆＃34 ;： 789，＆＃34; vendor_name＆＃34 ;：＆＃34; Abe Books＆＃34;} $ echo $ ORDER | jq＆＃39; with_entries（select（.key | match（＆＃34; order _＆＃34;）））＆＃39; {＆＃34; order_id＆＃34 ;： 456，＆＃34; order_status＆＃34 ;： ＆＃34;发送＆＃34;}</p><p>      The fact that the  task_name value is a  filename is a red flag– it&#39;s bad to have labels with high cardinality and I&#39;m not sure how many of these there are. I want to find out:</p><p>      task_name值是文件名的事实是一个危险信号-具有高基数的标签很不好，而且我不确定其中有多少个标签。我想找出：</p><p>   At my company there is a  CLI tool we&#39;ll call  pquery that allows prometheus metrics to be queried from the command line, and it outputs JSON–how conventient! I use this tool in the following examples. You don&#39;t have this tool, but fear not:  this wonderful post explains how to query prometheus using  curl which is essentially what  pquery does.</p><p>   在我公司，有一个CLI工具，我们将调用pquery，该工具允许从命令行查询prometheus度量标准，并且它输出JSON，这是多么方便！在以下示例中，我将使用此工具。您没有此工具，但不要担心：这篇精彩的文章解释了如何使用curl查询普罗米修斯，这实际上是pquery的工作。</p><p> Using  pquery we can view prometheus metrics from our various clusters. But even if we filter for this exact metric name, it&#39;s more data than we can easily look at. We&#39;ll use  wc -l (wordcount: count lines) to get a rough idea of how much data we&#39;re working with:</p><p> 使用pquery，我们可以查看来自各个集群的Prometheus指标。但是，即使我们过滤了这个确切的指标名称，它的数据也比我们容易看到的更多。我们将使用wc -l（wordcount：计数行）来大致了解我们正在处理的数据量：</p><p>  316,117 lines of JSON! Oof! We want to iterate over the metrics. But what jq filter do we need to access the array of metrics? I find  head useful for figuring out what the top level keys are for a large json structure:</p><p>  316,117行JSON！钱币！我们要遍历指标。但是，我们需要什么jq过滤器来访问指标数组？我发现对于确定大型json结构的顶级键是有用的：</p><p> $ pquery  &#39;async_task_total&#39; | head -n 20{  &#34;data&#34;: {  &#34;result&#34;: [ {  &#34;metric&#34;: {  &#34;__name__&#34;:  &#34;async_task_total&#34;,  &#34;app&#34;:  &#34;toodle-app-alpha&#34;,  &#34;instance&#34;:  &#34;10.55.55.55:9393&#34;,  &#34;job&#34;:  &#34;toodle-app-alpha&#34;,  &#34;kubernetes_pod_name&#34;:  &#34;toodle-app-b446b7ccd-6mls6&#34;,  &#34;namespace&#34;:  &#34;noweb&#34;,  &#34;netpol&#34;:  &#34;toodle-app&#34;,  &#34;node_name&#34;:  &#34;gke-production-04-3455c6df-j526&#34;,  &#34;release&#34;:  &#34;toodle-app&#34;,  &#34;task_name&#34;:  &#34;/charmoffensive/toodle-app/pkg/core/user/user.go(67):GetAccountDetails&#34; },  &#34;value&#34;: [ 1600981630.344,  &#34;2&#34;</p><p> $ pquery＆＃39; async_task_total＆＃39; |头-n 20 {＆＃34; data＆＃34 ;: {＆＃34; result＆＃34 ;: [{＆＃34; metric＆＃34 ;: {＆＃34; __ name __＆＃34 ;:＆＃34; async_task_total＆ ＃34 ;、＆＃34; app＆＃34 ;：＆＃34; toodle-app-alpha＆＃34 ;、＆＃34; instance＆＃34 ;：＆＃34; 10.55.55.55：9393＆＃34 ;、＆＃ 34; job＆＃34;：＆＃34; toodle-app-alpha＆＃34;，＆＃34; kubernetes_pod_name＆＃34;：＆＃34; toodle-app-b446b7ccd-6mls6＆＃34;，＆＃34;命名空间＆＃ 34 ;：＆＃34; noweb＆＃34 ;，＆＃34; netpol＆＃34 ;：＆＃34; toodle-app＆＃34 ;，＆＃34; node_name＆＃34 ;：＆＃34; gke-production-04 -3455c6df-j526＆＃34 ;,＆＃34; release＆＃34 ;:＆＃34; toodle-app＆＃34 ;,＆＃34; task_name＆＃34 ;:＆＃34; / charmoffensive / toodle-app / pkg / core / user / user.go（67）：GetAccountDetails＆＃34; }，＆＃34; value＆＃34 ;： [1600981630.344，＆＃34; 2＆＃34;</p><p>   Anyway we can see from above that  .data.result is the &#34;filter&#34; path for the metrics themselves. Let&#39;s get the  first result ( [0]) of this array so we can see what one metric looks like:</p><p>   无论如何，我们可以从上方看到.data.result是＆＃34; filter＆＃34;指标本身的路径。让我们获取此数组的第一个结果（[0]），以便我们可以看到一个度量标准： </p><p> $ pquery  &#39;async_task_total&#39; | jq  &#39;.data.result[0]&#39;{  &#34;metric&#34;: {  &#34;__name__&#34;:  &#34;async_task_total&#34;,  &#34;app&#34;:  &#34;toodle-app-alpha&#34;,  &#34;instance&#34;:  &#34;10.55.55.55:9393&#34;,  &#34;job&#34;:  &#34;toodle-app-alpha&#34;,  &#34;kubernetes_pod_name&#34;:  &#34;toodle-app-b446b7ccd-6mls6&#34;,  &#34;namespace&#34;:  &#34;noweb&#34;,  &#34;netpol&#34;:  &#34;toodle-app&#34;,  &#34;node_name&#34;:  &#34;gke-production-04-3455c6df-j526&#34;,  &#34;release&#34;:  &#34;toodle-app&#34;,  &#34;task_name&#34;:  &#34;/charmoffensive/toodle-app/pkg/core/user/user.go(67):GetAccountDetails&#34; },  &#34;value&#34;: [ 1600981906.069,  &#34;2&#34; ]}</p><p>$ pquery＆＃39; async_task_total＆＃39; | jq＆＃39; .data.result [0]＆＃39; {＆＃34; metric＆＃34 ;: {＆＃34; __ name __＆＃34 ;:＆＃34; async_task_total＆＃34 ;,＆＃34; app＆ ＃34 ;:＆＃34; toodle-app-alpha＆＃34;，＆＃34; instance＆＃34 ;：＆＃34; 10.55.55.55：9393＆＃34 ;、＆＃34; job＆＃34 ;：＆＃ 34; toodle-app-alpha＆＃34 ;,＆＃34; kubernetes_pod_name＆＃34 ;:＆＃34; toodle-app-b446b7ccd-6mls6＆＃34 ;,＆＃34; namespace＆＃34 ;:＆＃34; noweb＆＃ 34;，netpol＆＃34;：＆＃34; toodle-app＆＃34;，＆＃34; node_name＆＃34;：＆＃34; gke-production-04-3455c6df-j526＆＃34;，＆ ＃34; release＆＃34 ;:＆＃34; toodle-app＆＃34 ;,＆＃34; task_name＆＃34 ;:＆＃34; /charmoffensive/toodle-app/pkg/core/user/user.go（67 ）：GetAccountDetails＆＃34; }，＆＃34; value＆＃34 ;： [1600981906.069，＆＃34; 2＆＃34; ]}</p><p> Oops! That  app value ( toodle-app-alpha) indicates a mistake: I&#39;m only interested in results from the  toodle-app app,  not from other apps that may also emit this metric (such as the  alpha deployment we see here). We could  select for this using jq, but   promql already lets us filter by metric names so we&#39;ll do that instead:  pquery &#39;async_task_total{app=&#34;toodle-app&#34;}&#39;.</p><p> 糟糕！该应用程序的值（sodle-app-alpha）表示一个错误：我只对sodled-app应用程序的结果感兴趣，而对可能发出此指标的其他应用程序不感兴趣（例如，我们在此处看到的alpha部署） 。我们可以使用jq进行选择，但是promql已经允许我们按指标名称进行过滤，因此我们将改为：pquery＆＃39; async_task_total {app =＆＃34; toodle-app＆＃34;}＆＃39 ;。</p><p> We&#39;re interested in the  task_name value in the  metric object, so let&#39;s pluck that from  each item in the array above:</p><p> 我们对度量对象中的task_name值感兴趣，因此，请从上面数组中的每个项目中得出以下结论：</p><p>  Eighteen thousand values for that label!? That&#39;s bad!! But wait a tic–if other labels are varying, some of these may actually be duplicates. Let&#39;s sort them and see:</p><p>  该标签的一万八千个值！不好！！但是请稍候-如果其他标签有所不同，则其中一些实际上可能是重复的。让我们对它们进行排序，然后查看：</p><p>    Now I&#39;ve got a full list of all the  distinct values for this label, which answers my first question.</p><p>    现在，我已经获得了该标签所有不同值的完整列表，可以回答我的第一个问题。</p><p>    Ninety-two! Not so bad. Mystery solved, and I can say with reasonable confidence &#34;the cardinality of these labels isn&#39;t terribly high, I&#39;m leaving this alone 😅&#34;</p><p>    九十二！还不错谜团解决了，我可以放心地说＆＃34;这些标签的基数不是很高，我就别说了。</p><p>     $ kubectl get deployments toodle-app -o json \| jq &#39;.status.conditions[]|(.reason + &#34;: &#34; + .message)&#39; -rNewReplicaSetAvailable: ReplicaSet &#34;toodle-app-545b65cfd4&#34; has successfully progressed.MinimumReplicasAvailable: Deployment has minimum availability.</p><p>     $ kubectl获取部署toodle-app -o json \ | jq＆＃39; .status.conditions [] |（.reason +＆＃34 ;:＆＃34; + .message）＆＃39; -rNewReplicaSetAvailable：ReplicaSet＆＃34; toodle-app-545b65cfd4＆＃34; MinimumReplicasAvailable：部署具有最低可用性。 </p><p>  $ kubectl get service toodle-app -o json \| jq  &#39;.metadata.annotations | with_entries(select(.key|match(&#34;prometheus&#34;)))&#39;{  &#34;prometheus.io/path&#34;:  &#34;/varz&#34;,  &#34;prometheus.io/port&#34;:  &#34;9393&#34;,  &#34;prometheus.io/scrape&#34;:  &#34;true&#34;}</p><p>$ kubectl获取服务toodle-app -o json \ | jq＆＃39.metadata.annotations | with_entries（select（.key | match（＆＃34; prometheus＆＃34;））））＆＃39; {＆＃34; prometheus.io/path&#34 ;:＆＃34; / varz＆＃34 ;,＆＃ 34; prometheus.io/port&#34 ;：＆＃34; 9393＆＃34 ;，＆＃34; prometheus.io/scrape&#34 ;：＆＃34; true＆＃34;}</p><p>  $ cat cronjob.yamlapiVersion: batch/v1beta1kind: CronJobspec: schedule:  &#34;*/1 * * * *&#34;  # once per minute jobTemplate: spec: template: spec: containers: - name: deployment-scanner image: deployment-scanner:38$ brew install yq$ yq  &#39;.spec.jobTemplate.spec.template.spec.containers[0].image&#39; cronjob.yaml &#34;deployment-scanner:38&#34;</p><p>  $ cat cronjob.yamlapiVersion：batch / v1beta1kind：CronJobspec：schedule：＆＃34; * / 1 * * * *＆＃34; ＃每分钟一次jobTemplate：规格：模板：规格：容器：-名称：部署扫描器图像：部署扫描器：38 $ brew install yq $ yq＆＃39; .spec.jobTemplate.spec.template.spec.containers [ 0] .image＆＃39; cronjob.yaml＆＃34; deployment-scanner：38＆＃34;</p><p> I used this to build a new docker image tag each time I incremented the image value in cronjob.yaml, before applying the configuration (while I was developing a kubernetes cronjob locally):</p><p> 每次在应用配置之前（当我在本地开发kubernetes cronjob时），每次在cronjob.yaml中增加图像值时，我都会使用它来构建新的docker图像标签：</p><p>   ➜ curl  -sL https://postmates.com/feed | pup  &#39;head title&#39;&lt;title&gt; postmates: Food Delivery, Groceries, Alcohol - Anything from Anywhere&lt;/title&gt;➜ curl  -sL https://postmates.com/feed | pup  &#39;head meta[charset]&#39;&lt;meta charset= &#34;UTF-8&#34;&gt;➜ curl  -sL https://postmates.com/feed | pup  &#39;head meta[charset] json{}&#39;[ {  &#34;charset&#34;:  &#34;UTF-8&#34;,  &#34;tag&#34;:  &#34;meta&#34; }]</p><p>   ➜curl -sL https://postmates.com/feed | pup＆＃39;＆lt; title＆gt; postmates：送餐，杂货，酒精-随处可见＆lt; / title＆gt;➜curl -sL pup＆＃39; head meta [charset]＆lt; meta charset =＆＃34; UTF-8＆＃34;＆gt; curl -sL https://postmates.com/feed | pup＆＃39; head meta [charset] json {}＆＃39; [{＆＃34; charset＆＃34 ;:＆＃34; UTF-8＆＃34 ;,＆＃34; tag＆＃34 ;:＆＃ 34; meta＆＃34; }]</p><p>  What do you use  jq or  yq for? Will you be adding  pup to your workflow? Sound off in the comments, which is to say &#34;drop me a line!&#34;</p><p>  您将jq或yq用于什么？您会在工作流程中添加小狗吗？在评论中听起来很响，就是说“给我下一行！”</p><p>    📝 Comments? Please email them to my  protonmail.com address, username  sequoiam</p><p>    📝评论？请通过电子邮件将它们发送到我的protonmail.com地址，用户名sequoiam </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://sequoia.makes.software/parsing-json-at-the-cli-a-practical-introduction-to-jq-and-more/">https://sequoia.makes.software/parsing-json-at-the-cli-a-practical-introduction-to-jq-and-more/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/实用/">#实用</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/json/">#json</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>