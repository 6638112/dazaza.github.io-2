<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Ext4的快速提交 Fast Commits for Ext4</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Fast Commits for Ext4<br/>Ext4的快速提交 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-30 21:51:26</div><div class="page_narrow text-break page_content"><p>The API should not be more fine-grained. It should be easier to use. Even changing a simple config file in a consistent way is horrible in POSIX. With transactions this would look like: start_transaction() open() write() close() commit_transaction(). This looks much more intuitive to me than the POSIX way, where you need to take care of creating a new file, renaming it afterwards, and issuing the right fsync calls at the right times.   And now try to imagine dependent changes in two different files. With POSIX this requires you to implement some journaling on the app level, as there is no way of renaming two files atomically.  &gt; Or maybe, if with “fast transactions” we can ensure that misuse if that API would be visible to developers then it&#39;s time to introduce it and ask developers to test apps with it.  This is the wrong way to go. To detect misuse will only be possible if the system crashes in the right moment. And of course also &#34;fast transactions&#34; have implementation specific behavior. This is inherent to the current API. If you want to test apps for compliance with this API, you will need some kind of fuzzer that randomly reorders everything to the extend allowed by POSIX and then crashing at some random point of time.   &gt; But please don&#39;t introduce API misuse of which developers couldn&#39;t easily detect. Fsync story is problematic enough as it is. Don&#39;t make it worse.  Ordering issues in parallelism are always hard to detect. Not only for fs writes but also for multiple threads. If you want to avoid that entirely, then you need to use an implementation that is strictly ordered (and by no means parallel). I doubt that many people are willing to pay that price.   The current API is horrible for app developers. Let&#39;s create an API that is easier to get right. And yes this means it has to be harder for the fs developers.</p><p>API不应更细粒度。它应该更易于使用。甚至以一致的方式更改简单的配置文件在POSIX中也是可怕的。对于事务，它看起来像：start_transaction（）open（）write（）close（）commit_transaction（）。对我而言，这比POSIX方法直观得多，在POSIX方法中，您需要注意创建一个新文件，事后重命名以及在正确的时间发出正确的fsync调用。现在尝试想象两个不同文件中的相关更改。使用POSIX，这需要您在应用程序级别上实现一些日记功能，因为无法自动重命名两个文件。 ＆gt;或者，也许，如果使用“快速交易”，我们可以确保该API对于开发人员来说是否可见，那么就该引入它并要求开发人员使用它测试应用程序了。这是错误的方法。仅当系统在正确的时间崩溃时，才能检测到误用。当然，还可以“快速交易”具有特定于实现的行为。这是当前API固有的。如果要测试应用程序是否符合此API的要求，则将需要某种模糊测试工具，将所有内容随机重新排序为POSIX允许的扩展范围，然后在某个随机时间点崩溃。 ＆gt;但是请不要介绍滥用开发人员无法轻易发现的API。 Fsync的故事本身就存在问题。不要让情况变得更糟。并行性中的排序问题始终很难发现。不仅适用于fs写入，而且适用于多个线程。如果要完全避免这种情况，则需要使用严格排序的实现（绝不能并行执行）。我怀疑许多人是否愿意为此付出代价。当前的API对于应用程序开发人员来说太可怕了。让我们创建一个更容易正确使用的API。是的，这意味着对于fs开发人员而言，它必须更难。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://lwn.net/Articles/842385/">https://lwn.net/Articles/842385/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ext4/">#ext4</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/commits/">#commits</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/api/">#api</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>