<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Goodbye Mongodb，Hello PostgreSQL（2015） Goodbye MongoDB, Hello PostgreSQL (2015)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Goodbye MongoDB, Hello PostgreSQL (2015)<br/>Goodbye Mongodb，Hello PostgreSQL（2015） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-11 14:33:29</div><div class="page_narrow text-break page_content"><p>Olery was founded almost 5 years ago. What started out as a single product( Olery Reputation) developed by a Ruby development agencygrew into a set of different products and many different applications as theyears passed. Today we have not only Reputation as a product but also  OleryFeedback, the  Hotel Review Data API, widgets that can be embedded on a website and more products/servicesin the near future.</p><p>奥林近5年前成立。由Ruby开发仪库制定的单一产品（Olery信誉）成为一组不同的产品和许多不同的应用程序，因为它们通过了许多不同的应用。今天，我们不仅是作为产品的声誉，还具有奥雷弗雷德，酒店评价数据API，小部件，可以嵌入网站和更多产品/服务不久的将来。</p><p> We’ve also grown considerably when it comes to the amount of applications. Todaywe deploy over 25 different applications (all Ruby), some of these are webapplications (Rails or Sinatra) but most are background processing applications.</p><p> 当涉及到申请量时，我们也会大大增加。今天我们部署了超过25种不同的应用程序（所有Ruby），其中一些是界面（轨道或SINATRA），但大多数是后台处理应用程序。</p><p> While we can be extremely proud of what we have achieved so far there was alwayssomething lurking in the dark: our primary database. From the start of Olerywe’ve had a database setup that involved MySQL for crucial data (users,contracts, etc) and MongoDB for storing reviews and similar data (essentiallythe data we can easily retrieve in case of data loss). While this setup servedus well initially we began experiencing various problems as we grew, inparticular with MongoDB. Some of these problems were due to the way applicationsinteracted with the database, some were due to the database itself.</p><p> 虽然我们对到目前为止我们所达到的东西非常自豪地，但是在黑暗中总是潜伏的潜伏：我们的主要数据库。从Olerywe的开始，有一个数据库设置，涉及MySQL的MySQL，用于储存评论和类似数据的重要数据（用户，合同等）和MongoDB（基本上我们可以在数据丢失的情况下轻松检索数据）。虽然这个设置很好，最初我们开始遇到各种各样的问题，因为我们的成长，不包括MongoDB。其中一些问题是由于与数据库的应用程序协议的方式，有些问题是由于数据库本身。</p><p> For example, at some point in time we had to remove about a million documentsfrom MongoDB and then re-insert them later on. The result of this process wasthat the database went in a near total lockdown for several hours, resulting indegraded performance. It wasn’t until we performed a database repair (usingMongoDB’s  repairDatabase command). This repair itself also tookhours to complete due to the size of the database.</p><p> 例如，在某个时间点，我们必须从MongoDB中删除大约一百万个文档，然后稍后重新插入它们。这个过程的结果是数据库的近几个小时的近锁定，导致了对抗性能。直到我们执行数据库修复（使用蒙版的ReveionDatabase命令）。由于数据库的大小，此修复本身也占用了完成。</p><p> In another instance we noticed degraded performance of our applications andmanaged to trace it to our MongoDB cluster. However, upon further inspectionwe were unable to find the actual cause of the problem. No matter what metricswe installed, tools we used or commands we ran we couldn’t find the cause. Itwasn’t until we replaced the primaries of the cluster that performance returnedback to normal.</p><p> 在另一个例子中，我们注意到我们的应用程序的性能劣化，并追溯到追溯到我们的MongoDB集群。然而，在进一步检查我们无法找到问题的实际原因。无论安装METRICSWE，我们使用的工具或命令我们都找不到原因。在我们替换群体的初始返回到正常的群集的初始之前，ITWAS不是。</p><p> These are just two examples, we’ve had numerous cases like this over time. Thecore problem here wasn’t just that our database was acting up, but also thatwhenever we’d look into it there was absolutely no indication as to what wascausing the problem.</p><p> 这些只是两个例子，我们在随着时间的推移时有许多情况。在这里，Thecore问题不仅仅是我们的数据库表演，而且我们还考虑到它，绝对没有迹象表明是什么都是为了解决问题。</p><p>   Another core problem we’ve faced is one of the fundamental features of MongoDB(or any other schemaless storage engine): the lack of a schema. The lack of aschema may sound interesting, and in some cases it can certainly have itsbenefits. However, for many the usage of a schemaless storage engine leads tothe problem of implicit schemas. These schemas aren’t defined by your storageengine but instead are defined based on application behaviour and expectations.</p><p>   另一个我们面临的核心问题是MongoDB（或任何其他概要存储引擎）的基本特征之一：缺乏模式。缺乏芦荟清马可能听起来很有意思，在某些情况下，它肯定会有它的束缚。然而，对于许多方法的使用情况，可以引发隐式模式的问题。这些模式没有由您的StorageEngine定义，而是根据应用程序行为和期望来定义。 </p><p> For example, you might have a  pages collection where your application expectsa  title field with a type of  string. Here the schema is very much present,although not explicitly defined. This is problematic if the data’s structurechanges over time,  especially if old data is not migrated to the new structure(something that is quite problematic in schemaless storage engines). Forexample, say you have the following Ruby code:</p><p>例如，您可能有一个页面集合，其中应用程序期望具有类型字符串的标题字段。在这里，架构非常出现，尽管未明确定义。如果数据的结构是随着时间的推移的，则这是有问题的，特别是如果没有将旧数据迁移到新结构（在Smancealess Storage发动机中非常有问题）。 forexample，假设您有以下Ruby代码：</p><p>  This will work for every document that has a  title field that returns a String. This will break for documents that use a different field name(e.g.  post_title) or simply don’t have a title-like field. To handle such acase you’d need to adjust the code as following:</p><p>  这将适用于具有返回字符串的标题字段的每个文档。这将突破使用不同字段名称（例如post_title）或根本没有标题的字段。要处理此类ACase，您需要调整代码如下：</p><p>  Another way of handling this is defining a schema in your models. For example, Mongoid, a popular MongoDB ODM for Ruby, lets you do just that.However, when defining a schema using such tools one should wonder why theyaren’t defining the schema in the database itself. Doing so would solve anotherproblem: re-usability. If you only have a single application then defining aschema in the code is not really a big deal. However, when you have dozens ofapplications this quickly becomes one big mess.</p><p>  另一种处理方式是在模型中定义架构。例如，Mongoid是一个受欢迎的MongoDB ODM for Ruby，让您这样做。然而，当使用这样的工具定义模式时，应该想知道为什么不在数据库本身中定义架构。这样做会解决另一个问题：重新使用。如果您只有单个应用程序，那么在代码中定义aschema并不是一个很大的交易。但是，当你有很多缺陷时，这很快就会成为一个大混乱。</p><p> Schemaless storage engines promise to make your life easier by removing the needto worry about a schema. In reality these systems simply make it your ownresponsibility to ensure data consistency. In certain cases this might work out,but I’m willing to bet that for most this will only backfire.</p><p> 概要存储引擎承诺通过删除担心架构来使您的生活更轻松。实际上，这些系统只是使其成为确保数据一致性的所有权。在某些情况下，这可能会锻炼，但我愿意为大多数人打赌，这将只有反馈。</p><p>   This brings me to the requirements of a good database, more specifically therequirements Olery has. When it comes to a system, especially a database, wevalue the following:</p><p>   这为我带来了一个好的数据库的要求，更具体地说，奥雷尔有。涉及系统，尤其是数据库，Wevalue以下内容：</p><p>  Consistency is important as it helps setting clear expectations of a system. Ifdata is always stored in a certain way then systems using this data become muchsimpler. If a certain field is required on database level an application doesn’tneed to check for the existence of such a field. A database should also be ableto guarantee the completion of certain operations, even under high pressure.There’s nothing more frustrating than inserting data only for it not to appearuntil after a few minutes.</p><p>  一致性很重要，因为它有助于确定对系统的清晰期望。 IFData始终以某种方式存储，然后使用此数据的系统变得很多。如果在数据库级别需要某个字段，则无法检查此类字段的应用程序。一个数据库也应该是ableto保证完成某些操作，即使在高压下也没有比点开数据更令人沮丧，因为它不会在几分钟之后暂停。</p><p> Visibility applies to two things: the system itself and how easy it is to getdata out of it. If a system misbehaves it should be easy to debug. In turn, ifa user wants to query data this should be easy too.</p><p> 可见性适用于两件事：系统本身以及将其纳入它的容易程度。如果一个系统不端行为，它应该易于调试。反过来，IFA用户想要查询数据，这也应该很容易。 </p><p> Correctness means that a system behaves as expected. If a certain field isdefined as an numeric value one shouldn’t be able to insert text into the field.MySQL is notoriously bad at this as it lets you do exactly that and as a resultyou can end up with bogus data.</p><p>正确性意味着系统按预期行为。如果某个字段作为数字值isdefined，则应该不能将文本插入字段中.Mysql臭名昭着的是，因为它允许您完成那个，并且随着结果，您可以最终与虚假数据结束。</p><p> Scalability applies to not only performance, but also the financial aspect andhow well a system can deal with changing requirements over time. A system mightperform extremely well, but not at the cost of large quantities of money or byslowing down the development cycle of systems depending on it.</p><p> 可扩展性不仅适用于性能，还适用于财务方面，并且系统可以通过时间处理更改的要求。一个系统的变得非常好，但不是大量金钱的成本，或者根据它来阻碍系统的开发周期。</p><p>   With the above values in mind we set out to find a replacement for MongoDB. Thevalues noted above are often a core set of features of traditional RDBMS’ and sowe set our eyes on two candidates: MySQL and PostgreSQL.</p><p>   考虑到上述价值，我们向MongoDB寻找替代品。上面指出的高价值通常是传统RDBMS的核心特征集，并且Sowe将我们的眼睛放在两种候选人身上：MySQL和PostgreSQL。</p><p> MySQL was the first candidate as we were already using it for some small chunksof critical data. MySQL however is not without its problems. For example, whendefining a field as  int(11) you can just happily insert textual data and MySQLwill  try to convert it. Some examples:</p><p> MySQL是我们已经将其使用它的第一个候选人，因为我们已经为一些严重的数据提供了一些关键数据。然而，MySQL并非没有问题。例如，将一个字段作为int（11），您可以愉快地插入文本数据，MySQLWill尝试转换它。一些例子：</p><p> mysql&gt; create table example ( `number` int(11) not null );Query OK, 0 rows affected (0.08 sec)mysql&gt; insert into example (number) values (10);Query OK, 1 row affected (0.08 sec)mysql&gt; insert into example (number) values (&#39;wat&#39;);Query OK, 1 row affected, 1 warning (0.10 sec)mysql&gt; insert into example (number) values (&#39;what is this 10 nonsense&#39;);Query OK, 1 row affected, 1 warning (0.14 sec)mysql&gt; insert into example (number) values (&#39;10 a&#39;);Query OK, 1 row affected, 1 warning (0.09 sec)mysql&gt; select * from example;+--------+| number |+--------+| 10 || 0 || 0 || 10 |+--------+4 rows in set (0.00 sec)</p><p> mysql＆gt;创建表格示例（`Number` int（11）不是null）;查询OK，0行影响（0.08秒）MySQL＆GT;插入示例（数字）值（10）;查询OK，1行受影响（0.08秒）mysql＆gt;插入示例（数字）值（＆＃39; Wat＆＃39;）;查询OK，1行受影响，1个警告（0.10秒）mysql＆gt;插入示例（数字）值（＆＃39;这10个废话和＃39;）;查询确定，1行受影响，1个警告（0.14秒）mysql＆gt;插入示例（数字）值（＆＃39; 10 a＆＃39;）;查询确定，1行受影响，1条警告（0.09秒）mysql＆gt;选择*从示例; + -------- + |号码| + -------- + | 10 || 0 || 0 || 10 | + -------- + + 4行集（0.00秒）</p><p> It’s worth noting that MySQL  will emit a warning in these cases. However,since warnings are just warnings they are often (if not almost always) ignored.</p><p> 值得注意的是，MySQL将在这些情况下发出警告。然而，由于警告只是警告，他们经常（如果不是几乎总是总是）忽略了。</p><p> Another problem with MySQL is that any table modification (e.g. adding a column)will result in the table being locked for  both reading and writing. This meansthat  any operation using such a table will have to wait until the modificationhas completed. For tables with lots of data this could take hours to complete,possibly leading to application downtime. This has lead companies such asSoundCloud to develop tools such as  lhm to deal with this.</p><p> MySQL的另一个问题是任何表修改（例如，添加列）将导致表格锁定以供阅读和写入。这意味着使用这种表的任何操作都必须等到修改后完成。对于具有大量数据的表格，这可能需要数小时才能完成，可能导致应用程序停机时间。这具有索引公司此类Assoudcloud来开发诸如LHM等工具来处理此功能。 </p><p> With the above in mind we started looking into PostgreSQL. PostgreSQL does a lotof things well that MySQL doesn’t. For example, you can’t insert textual datainto a numeric field:</p><p>考虑到上面，我们开始研究PostgreSQL。 PostgreSQL MySQL没有。例如，您无法插入文本Datainto一个数字字段：</p><p> olery_development=# create table example ( number int not null );CREATE TABLEolery_development=# insert into example (number) values (10);INSERT 0 1olery_development=# insert into example (number) values (&#39;wat&#39;);ERROR: invalid input syntax for integer: &#34;wat&#34;LINE 1: insert into example (number) values (&#39;wat&#39;); ^olery_development=# insert into example (number) values (&#39;what is this 10 nonsense&#39;);ERROR: invalid input syntax for integer: &#34;what is this 10 nonsense&#34;LINE 1: insert into example (number) values (&#39;what is this 10 nonsen... ^olery_development=# insert into example (number) values (&#39;10 a&#39;);ERROR: invalid input syntax for integer: &#34;10 a&#34;LINE 1: insert into example (number) values (&#39;10 a&#39;);</p><p> Olery_development =＃创建表示例（number int not null）;创建rabentolery_development =＃插入到示例（数字）值（10）;插入0 1oleRy_development =＃插入到示例（数字）值（＆＃39; wat＆＃39;） ;错误：整数的输入语法无效：＆＃34; wat＆＃34;第1行：插入示例（数字）值（＆＃39; wat＆＃39;）; ^ oleery_development =＃插入到示例（数字）值（＆＃39;这10个废话和＃39;）;错误：整数的输入语法：＆＃34;这10个废话和＃34;第1行：插入进入示例（数量）值（＆＃39;这10个nonsen ... ^ oleery_development =＃插入到示例（数字）值（＆＃39; 10 a＆＃39;）;错误：整数的输入语法无效： ＆＃34; 10 A＆＃34;第1行：插入示例（数字）值（＆＃39; 10 a＆＃39;）;</p><p> PostgreSQL also has the capability of altering tables in various ways  withoutrequiring to lock it for every operation. For example, adding a column that doesnot have a default value and can be set to  NULL can be done quickly withoutlocking the entire table.</p><p> PostgreSQL还具有以各种方式更改表格的功能，无需锁定每次操作。例如，添加一个未使用默认值的列，可以设置为NULL可以快速完成，无锁整个表。</p><p> There are also various other interesting features available in PostgreSQL suchas: trigram based indexing and searching, full-text search, support for queryingJSON, support for querying/storing key-value pairs, pub/sub support and more.</p><p> PostgreSQL Suchas还提供各种其他有趣的功能：Trigram基于索引和搜索，全文搜索，支持QueryingJSON，支持查询/存储键值对，PUB /子支持等。</p><p>    In the end we decided to settle with PostgreSQL for providing a balance betweenthe various subjects we care about. The process of migrating an entire platformfrom MongoDB to a vastly different database is no easy task. To ease thetransition process we broke this process up in roughly 3 steps:</p><p>    最后，我们决定与PostgreSQL定居，以便在我们关心的各种科目之间提供平衡。将整个平台从MongoDB迁移到巨大不同数据库的过程并不容易。为了缓解切换过程，我们将在大约3个步骤中突破此过程：</p><p> Update all applications that rely on MongoDB to use PostgreSQL instead, alongwith whatever refactoring is required to support this.</p><p> 更新依赖MongoDB以使用PostgreSQL的所有应用程序，而不是需要重构来支持此操作。</p><p>   Before we would even consider migrating all our data we needed to run testsusing a small subset of the final data. There’s no point in migrating if youknow that even a small chunk of data is going to give you lots of trouble.</p><p>   在我们甚至考虑迁移我们所需的所有数据之前，我们需要运行测试最终数据的小子集。如果你知道即使是一小块的数据，那么迁移就没有意义会给你带来很多麻烦。 </p><p> While there are existing tools that can handle this we also had to transformsome data (e.g. fields being renamed, types being different, etc) and as suchhad to write our own tools for this. These tools were mostly one-off Rubyscripts that each performed specific tasks such as moving over reviews, cleaningup encodings, correcting primary key sequences and so on.</p><p>虽然存在可以处理此操作的现有工具，但我们也必须转换数据（例如，被重命名的字段，类型不同，等等），并如此为此编写自己的工具。这些工具大多是一次性的Rubyscript，每个工具都执行了特定的任务，例如移动过度评论，清理编码，纠正主键序列等。</p><p> The initial testing phase didn’t reveal any problems that might block themigration process, although there were some problems with some parts of ourdata. For example, certain user submitted content wasn’t always encodedcorrectly and as a result couldn’t be imported without being cleaned up first.Another interesting change that was required was changing the language names ofreviews from their full names (“dutch”, “english”, etc) to language codes as ournew sentiment analysis stack uses language codes instead of full names.</p><p> 初始测试阶段没有揭示任何可能阻止分组过程的问题，尽管Oudata的某些部分存在一些问题。例如，某些用户提交的内容并非总是被编码，并且由于不得不进行清除，因此无法导入结果。需要的其他有趣的更改正在从全名（“荷兰语”，“英语”中更改为浏览的语言名称语言代码作为OURNEW情绪分析堆栈使用语言代码而不是全名。</p><p>   By far most time was spent in updating applications, especially those thatrelied heavily on MongoDB’s aggregation framework. Throw in a few legacy Railsapplications with low test coverage and you have yourself a few weeks worth ofwork. The process of updating these applications was basically as following:</p><p>   到目前为止，在更新申请时花在更新的应用程序中，特别是那些对MongoDB的聚合框架大量的人。抛出一些具有低测试覆盖率的遗留轨道应用，并且您拥有几周的工作。更新这些应用程序的过程基本上如下：</p><p>  For non Rails applications we settled on using  Sequel while we stuckwith ActiveRecord for our Rails applications (at least for now). Sequel is awonderful database toolkit, supporting most (if not all) PostgreSQL specificfeatures that we might want to use. Its query building DSL is also  much morepowerful compared to ActiveRecord, although it can be a bit verbose at times.</p><p>  对于非Rails应用程序，我们在使用续集时解决了续集，而我们追溯到Activerecord用于我们的Rails应用程序（至少现在）。续集是令人醒来的数据库工具包，支持我们可能想要使用的大多数（如果不是全部）PostgreSQL SpecialFeatures。与Activerecord相比，它的查询构建DSL也是我们的推动力，尽管它有时会有点冗长。</p><p> As an example, say you want to calculate how many users use a certain localealong with the percentage of every locale (relative to the entire set). In plainSQL such a query could look like the following:</p><p> 例如，假设您想计算有多少用户使用某个LocalAlong，其中每个区域设置的百分比（相对于整个集合）。在PlainsQL中，这样的查询可能如下所示：</p><p> #!sqlSELECT locale,count(*) AS amount,(count(*) / sum(count(*)) OVER ()) * 100.0 AS percentageFROM usersGROUP BY localeORDER BY percentage DESC;</p><p> ＃！sqlselect语言环境，计数（*）为金额，（count（*）/ sum（count（*））over（））* 100.0用localeorder百分比代表的用户组成百分比;</p><p>  locale | amount | percentage--------+--------+-------------------------- en | 2779 | 85.193133047210300429000 nl | 386 | 11.833231146535867566000 it | 40 | 1.226241569589209074000 de | 25 | 0.766400980993255671000 ru | 17 | 0.521152667075413857000 | 7 | 0.214592274678111588000 fr | 4 | 0.122624156958920907000 ja | 1 | 0.030656039239730227000 ar-AE | 1 | 0.030656039239730227000 eng | 1 | 0.030656039239730227000 zh-CN | 1 | 0.030656039239730227000(11 rows)</p><p>  区域设置|金额|百分比-------- + -------- + ----------------------- 2779 | 85.193133047210300429000 nl | 386 | 11.83231146535867566000它| 40 | 1.226241569589209074000 de | 25 | 0.766400980993255671000 ru | 17 | 0.521152667075413857000 | 7 | 0.214592274678111588000 fr | 4 | 0.122624156958920907000 ja | 1 | 0.030656039239730227000 AR-AE | 1 | 0.030656039239730227000 eng | 1 | 0.030656039239730227000 ZH-CN | 1 | 0.030656039239730227000（11行） </p><p> Sequel allows you to write the above query using plain Ruby  without the needof string fragments (as ActiveRecord often requires):</p><p>续集允许您使用普通Ruby在没有串片段的情况下使用普通Ruby（astiverecord通常需要）编写上述查询：</p><p> #!rubystar = Sequel.lit(&#39;*&#39;)User.select(:locale) .select_append { count(star).as(:amount) } .select_append { ((count(star) / sum(count(star)).over) * 100.0).as(:percentage) } .group(:locale) .order(Sequel.desc(:percentage))</p><p> ＃！rubystar = sequel.lit（＆＃39; *＆＃39;）user.select（：locale）.select_append {count（star）.as（：computa）} .select_append {（（star）/ sum （计数（星））。over）* 100.0）.as（：百分比）} .group（：locale）.order（sequel.desc（：百分比））</p><p> If you don’t like using  Sequel.lit(&#39;*&#39;) you can also use the following syntax:</p><p> 如果您不喜欢使用sequel.lit（＆＃39; *＆＃39;）您也可以使用以下语法：</p><p> #!rubyUser.select(:locale) .select_append { count(users.*).as(:amount) } .select_append { ((count(users.*) / sum(count(users.*)).over) * 100.0).as(:percentage) } .group(:locale) .order(Sequel.desc(:percentage))</p><p> ＃！rubyuser.select（：locale）.select_append {count（用户。*）。作为（：金额）} .select_append {（count（用户。*）/ sum（count（用户。*）计数（count（用户。）。结束）* 100.0）.as（：百分比）} .group（：locale）.order（sequel.desc（：百分比））</p><p> While perhaps a bit more verbose both of these queries make it easier to re-useparts of them,  without having to resort to string concatenation.</p><p> 虽然可能有点冗长，但这两个查询都使得重新使用它们更容易，而无需诉诸字符串连接。</p><p> In the future we might also move our Rails applications over to Sequel, butconsidering Rails is so tightly coupled to ActiveRecord we’re not entirely sureyet if this is worth the time and effort.</p><p> 在未来，我们也可能将我们的Rails应用程序转移到续集上，但是，如果这是值得的时间和精力，但是如果值得的时间和努力，那么我们的铁路轨道就会如此紧密耦合。</p><p>   Which finally brings us to the process of migrating the production data. Thereare basically two ways of doing this:</p><p>   这最终为我们带来了迁移生产数据的过程。 Athereare基本上是两种方式： </p><p> Shut down the entire platform and bring it back online once all data has beenmigrated.</p><p>关闭整个平台并在所有数据已被迁移后在线备份。</p><p> Option 1 has one obvious downside: downtime. Option 2 on the other hand doesn’trequire downtime but can be quite difficult to deal with. For example, in thissetup you’d have to take into account any data being added  while you’remigrating data as otherwise you’d lose data.</p><p> 选项1有一个明显的下行：停机。选项2另一方面不会停机，但可能很难处理。例如，在此功能中，您必须考虑在您丢失数据的情况下使用数据时添加的任何数据。</p><p> Luckily Olery has a rather unique setup in that most write operations to ourdatabase only happen at fairly regular intervals. The data that  does changemore often (e.g. user and contract information) is a rather small amount ofdata meaning it costs far less time to migrate compared to our review data.</p><p> 幸运的是，奥林有一个相当独特的设置，因为它对我们的大多数写作操作仅以相当规则的间隔发生。经常（例如用户和合同信息）的数据是一个相当少量的数量，这意味着与我们的审核数据相比迁移的时间越来越少。</p><p>  Migrate critical data such as users, contracts, basically all the data thatwe can not afford to lose in any way.</p><p>  迁移用户，合同的关键数据，基本上所有的数据都无法以任何方式丢失。</p><p>        Re-migrate the data of step 1, ensuring data that was created in the meantime is not lost.</p><p>        重新迁移步骤1的数据，确保在与此同时创建的数据不会丢失。</p><p> Step 2 took the longest by far, roughly 24 hours. On the other hand, migratingthe data mentioned in steps 1 and 5 only took about 45 minutes.</p><p> 步骤2到迄今为止，大约24小时的时间迈出了最长。另一方面，迁移步骤1和5中提到的数据只花了大约45分钟。</p><p>   It’s now been almost a month ago since we completed our migration and we areextremely satisfied so far. The impact so far has been nothing but positive andin various cases even resulted in drastically increased performance of ourapplications. For example, our  Hotel Review Data API (running onSinatra) ended up having even lower response timings than before thanks to themigration:</p><p>   自从我们完成迁移并迄今为止，我们已经完成了几个月前几个月前。到目前为止的影响甚至是积极的，甚至导致了甚至导致了腹部申请的性能急剧增加。例如，我们的酒店评论数据API（正在运行Onsinatra）最终有甚至较低的响应时间，而不是Fhen Fhen Factor： </p><p>  The migration took place on the 21st of January, the big peak is simply theapplication performing a hard restart (leading to slightly slower responsetimings during the process). After the 21st the average response time was nearlycut in half.</p><p>迁移发生在1月21日，大峰值只是进行硬重启的拍摄性（导致过程中稍微较慢的响应）。在第21次之后，平均响应时间为近一半。</p><p> Another case where we saw a big increase in performance was what we call the“review persister”. This application (running as a daemon) has a rather simplepurpose: to save review data (reviews, review ratings, etc). While we ended upmaking some pretty big changes to this application for the migration the resultwas very rewarding:</p><p> 另一种案例，我们看到表现的大幅增加是我们称之为“审查私人”。此应用程序（作为守护程序运行）具有相当简单的素质：保存审核数据（评论，评论，评分等等）。虽然我们最新着原地，但对迁移的迁移时，迈出了一些非常大的变化，结果是结果非常有益：</p><p>    The difference isn’t as extreme as with the review persister, but since thescrapers only use a database to check if a review exists (a relatively fastoperation) this isn’t very surprising.</p><p>    与审查普遍存在的差异并不像极端，但由于该折叠者只使用数据库检查存在审查（相对速度），这不是很令人惊讶。</p><p> And last the application that schedules the scraping process (simply called the“scheduler”):</p><p> 最后暂整安排刮擦进程的应用程序（简称“调度程序”）：</p><p>  Since the scheduler only runs at certain intervals the graph is a little bithard to understand, but nevertheless there’s a clear drop in the averageprocessing time after the migration.</p><p>  由于调度程序仅以某些间隔运行，因此图形是一个小型Bithard来理解，但迁移后的平均处理时间内有明显的下降。</p><p> In the end we’re very satisfied with the results so far and we certainly won’tmiss MongoDB. The performance is great, the tooling surrounding it pales otherdatabases in comparison and querying data is  much more pleasant compared toMongoDB (especially for non developers). While we do have one service ( OleryFeedback) still using MongoDB (albeit a separate, rather smallcluster) we intend to also migrate this to PostgreSQL in the future.</p><p> 最后，我们到目前为止，我们对结果非常满意，我们肯定不会MongoDB。性能很大，围绕它的植物围绕着比较和查询数据的工具更令人愉快（特别是对于非开发人员）更令人愉快。虽然我们有一个服务（OleryFeedback）仍然使用MongoDB（尽管是一个单独的，而不是一个单独的，而不是一个渺小的聚集），我们打算在将来迁移到PostgreSQL。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://developer.olery.com/blog/goodbye-mongodb-hello-postgresql/">http://developer.olery.com/blog/goodbye-mongodb-hello-postgresql/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/mongodb/">#mongodb</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>