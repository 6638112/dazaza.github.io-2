<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>MinisSelect：实用和通用的选择算法</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">MinisSelect：实用和通用的选择算法</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-12 04:59:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/e4f9124f2ea9fec53ac26d7acba0b222.png"><img src="http://img2.diglog.com/img/2020/11/e4f9124f2ea9fec53ac26d7acba0b222.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Today I present a big effort from my side to publish  miniselect — generic C++ library to support multiple selection and partial sorting algorithms. It is already  used in  ClickHouse with huge performance benefits. Exact benchmarks and results will be later in this post and now let’s tell some stories about how it all arose. I publish this library under Boost License and any contributions are highly welcome.</p><p>今天，我在发布迷你选择泛型C++库方面做了很大的努力，以支持多重选择和部分排序算法。它已经在ClickHouse中使用，带来了巨大的性能优势。确切的基准和结果将在这篇文章的后面介绍，现在让我们来讲述一些关于这一切是如何发生的故事。我在Boost许可下发布了这个库，任何贡献都是非常受欢迎的。</p><p>  While reading lots of articles, papers, and posts from Hacker News, I found it pretty funny each several months new “shiny”, “fastest”, “generic” sorting algorithms to come or remembered from old papers such as the recent paper on  learned sorting,  Kirkpatrick-Reisch sort or  pdqsort. It is that we are essentially 65+ years into writing sorting algorithms, and we still find improvements. Shouldn’t sorting items be a “solved” problem by now? Unfortunately, not. New hardware features come, we find that sorting numbers can be actually done faster than best comparison   time complexity and we still find improvements in sorting algorithms like avoiding  branches in partitions and trying to find good pivots as pdqsort does. Also, there are many open questions in that area as “what is the minimum number of comparisons needed?”.</p><p>在阅读Hacker News的大量文章、论文和帖子时，我发现每隔几个月就会有新的“闪亮”、“最快”、“通用”的排序算法从旧报纸上出现或记住，比如最近发表的关于学习排序、Kirkpatrick-Reisch排序或pdqort的论文。那就是我们基本上已经花了65年以上的时间来编写排序算法，而且我们仍然在寻找改进之处。分拣物品现在不应该是一个“解决”的问题吗？不幸的是，没有。新的硬件特性出现后，我们发现对数字进行排序实际上可以比最佳比较时间复杂度更快，我们仍然发现排序算法的改进，比如避免分区中的分支，以及像pdqsort那样试图找到好的轴心点。此外，在这一领域还有许多悬而未决的问题，比如“需要进行的最小比较次数是多少？”</p><p> Huge competition is still going on in sorting algorithms and I believe we are not near the optimal sorting and learned sorting looks like the next step. But it uses the fundamental fact that no one expects sorting to be completed in a couple of passes and we can understand something about data during first array passes. We will understand why it matters later.</p><p>排序算法方面的激烈竞争仍在继续，我相信我们还没有达到最佳排序，而习得排序看起来是下一步。但它使用的基本事实是，没有人期望在几次数组遍历中完成排序，并且我们可以在第一次数组遍历期间理解一些关于数据的内容。我们稍后会明白为什么这很重要。</p><p> My favorite general sorting is  pdqsort, it proves to be currently the best general sorting algorithm and it shows a significant boost over all standard sorts that are provided in C++. It is also  used in Rust.</p><p>我最喜欢的通用排序是pdqort，它被证明是目前最好的通用排序算法，而且它比C++提供的所有标准排序都有很大的提升。它也被用在生锈中。</p><p>  Nearly a couple of months ago I started thinking about a slightly different approach when it comes to sorting — partial sorting algorithms. It means that you don’t need to sort all   elements but only find   smallest and sort them. For example, it is widely used in SQL queries when you do  ORDER BY LIMIT N and  N is often small, from 1-10 to ideally couple of thousands, bigger values still happen but rare. And, oh god, how little engineering and theoretical research has been done there compared to full sorting algorithms. In fact, the question of specifically finding  th order statistics when   is small is open and no good solution is presented. Also, partial sorting is quite easy to obtain after that, you need to sort the first   elements by some sorting algorithm to get optimal   comparisons and we will look at only one example when it is not the case. Yes, there are a bunch of median algorithms that can be generalized to find the  th smallest element. So, what are they? Yeah, you may know some of them but let’s revise, it is useful to know your enemies.</p><p>大约几个月前，我开始考虑一种略微不同的排序方法--部分排序算法。这意味着您不需要对所有元素进行排序，只需找到最小的元素并对其进行排序。例如，它在SQL查询中被广泛使用，当您执行ORDER BY LIMIT N时，N通常很小，从1-10到理想的几千，更大的值仍然会出现，但很少出现。而且，天哪，与全排序算法相比，在那里做的工程和理论研究是多么的少。事实上，在小的情况下具体寻找顺序统计量的问题一直是一个未解决的问题，也没有很好的解决方案。此外，部分排序在此之后非常容易获得，您需要通过某种排序算法对第一个元素进行排序，以获得最佳比较，如果不是这样，我们将只看一个例子。是的，有很多中值算法可以推广到寻找第几个最小的元素。那么，它们是什么呢？是的，你可能知道其中的一些，但让我们复习一下，了解你的敌人是有用的。</p><p>  This is almost the very first algorithm for finding the  th smallest element, just do like  QuickSort but don’t go recursively in two directions, that’s it. Pick middle or even random element and partition by this element, see in which of two parts   is located, update the one of the borders, voila, after maximum of   partitions you will find  th smallest element. Good news that on average it takes   comparisons if we pick random pivot. That is because if we define   is the expected number of comparisons for finding  th element in   elements and  , then during one stage we do   comparisons and uniformly pick any pivot, then even if we pick the biggest part on each step</p><p>这几乎是第一个找到第几个最小元素的算法，就像快速排序一样，但不要在两个方向递归，仅此而已。选取中间甚至随机的元素并按此元素进行划分，看看两个部分中的哪一个位于其中，更新其中一个边界，瞧，在最大的划分之后，您将找到最小的元素。好消息是，平均而言，如果我们选择随机轴心，就需要进行比较。这是因为，如果我们定义的是在元素中查找元素的预期比较次数，然后在一个阶段中，我们进行比较并统一选择任何轴心，那么即使我们在每一步中选择最大的部分。</p><p>     Bad news is that the worst case will still be   if we are unfortunate and always pick the biggest element as a pivot, thus partitioning .</p><p>坏消息是，最坏的情况仍然是，如果我们很不幸，总是选择最大的元素作为支点，从而进行分割。</p><p> In that sense that algorithm provides lots of pivot “strategies” that are used nowadays, for example, picking pivot as a   element of the array or picking pivot from 3 random elements . Or do like  std::nth_element from libcxx — choose the middle out out of  .</p><p>从这个意义上说，该算法提供了许多现在使用的枢轴“策略”，例如，选取枢轴作为数组的一个元素，或者从3个随机元素中选取枢轴。或者像libcxx中的std：：nth_element一样-从中选择中间部分。</p><p> I decided to visualize all algorithms I am going to talk about today, so quickselect with a median of 3 strategy on random input looks something like this:</p><p>我决定将我今天要讨论的所有算法可视化，所以随机输入策略中值为3的QuickSelect如下所示：</p><p>    For a strategy like  libcxx (C++ llvm standard library) does, there are quadratic counterexamples that are pretty easy to detect, such patterns also appear in real data. The counterexample looks like that:</p><p>对于像libcxx(C++llvm标准库)这样的策略，有一些很容易检测到的二次型反例，这样的模式也出现在实际数据中。反例如下：</p><p>   This is definitely quadratic. By the way, this is perfectly ok with the C++ standard wording as it says:</p><p>这绝对是二次曲线。顺便说一句，这与C++标准措辞完全一致，因为它是这样写的：</p><p>   For a long time, computer scientists thought that it is impossible to find medians in worst-case linear time, however, Blum, Floyd, Pratt, Rivest, Tarjan came up with BFPRT algorithm or like sometimes it is called, median of medians algorithm.</p><p>长期以来，计算机科学家认为不可能在最坏的线性时间内找到中值，然而，Blum，Floyd，Pratt，Rivest，Tarjan等人提出了BFPRT算法或类似的算法，有时被称为中值算法。</p><p>  Group the array into   groups of size 5 and find the median of each group. (For simplicity, we will ignore integrality issues.)</p><p>将数组分成大小为5的组，并求出每组的中位数。(为简单起见，我们将忽略完整性问题。)。</p><p> When we find the median   of   groups, at least   of them have at least 3 out of 5 elements that are smaller or equal than  , that said the biggest out of 2 partitioned chunks have size   and we have the reccurence</p><p>当我们找到群的中位数时，至少其中至少有3/5的元素小于或等于，也就是说，2个分割的块中最大的有大小，我们有重现性。</p><p>     Actually, this constant 10 is really big. For example, if we look a bit closer,   is at least 1 because we need to partition the array, then finding median out of 5 elements cannot be done in less than 6 comparisons (can be proven by only brute-forcing) and in 6 comparisons it can be done in the following way</p><p>实际上，这个常数10真的很大。例如，如果我们看得更近一点，至少是1，因为我们需要对数组进行分区，那么在少于6次比较(只能通过暴力强制)中找出5个元素中的中位数是不可能的，并且在6次比较中可以通过以下方式来完成。</p><p> If  , then the problem is fairly easy. If  , the median value is the smaller of   and  . If not, the median value is the smaller of   and  .</p><p>如果是的话，那么问题就相当简单了。如果是，则中值为和的较小值。如果不是，则中值为和中的较小值。</p><p> So  . If  , then the solution is the smaller of   and  . Otherwise, the solution is the smaller of   and  .</p><p>所以。如果是，则解是和中较小的一个。否则，解是和中较小的一个。</p><p> So that maximum   can be   and it gives us the upper bound   comparisons which looks like it can be achieved. Some other tricks can be done in place to achieve a bit lower constants like   (for example, sorting arrays of 5 and comparing less afterwards). In practice, the constant is really big and you can see it from the following demonstration which was even fastened because it took quite a few seconds:</p><p>所以最大值是可以的，它给了我们上界的比较，看起来它是可以达到的。还可以使用其他一些技巧来实现更低的常量，例如，对5的数组进行排序，然后比较更少的数组(例如，对5的数组进行排序，然后进行更少的比较)。在实践中，这个常量真的很大，你可以从下面的演示中看到它，它甚至被固定住了，因为它花了相当多的时间：</p><p>   Another approach to finding  th element is to create a  heap on an array of size   and push other   elements into this heap. C++  std::partial_sort works that way (with additional heap sorting of the first heap). It shows good results for very small   and random/ascending arrays, however starts to significantly degrade with growing   and becomes impractical. Best case  , worst  , average  .</p><p>找到该元素的另一种方法是在一个大小数组上创建一个堆，并将其他元素推入该堆中。C++std：：Partial_Sort以这种方式工作(对第一堆进行额外的堆排序)。它对非常小的随机/上升阵列显示出很好的效果，但是随着增长开始显著下降，变得不切实际。最好的，最坏的，一般的。</p><p>   As the previous algorithm is not very much practical and QuickSelect is really good on average, in 1997  “Introspective Sorting and Selection Algorithms” from David Musser came out with a sorting algorithm called “IntroSelect”.</p><p>由于以前的算法不是很实用，QuickSelect的平均表现也很好，1997年David Musser的“内省排序和选择算法”提出了一种名为“IntroSelect”的排序算法。</p><p> IntroSelect works by optimistically starting out with QuickSelect and only switching to MedianOfMedians if it recurses too many times without making sufficient progress. Simply limiting the recursion to constant depth is not good enough, since this would make the algorithm switch on all sufficiently large arrays. Musser discusses a couple of simple approaches:</p><p>IntroSelect的工作原理是乐观地从QuickSelect开始，只有在它循环太多次而没有取得足够进展的情况下才切换到MedianOfMedians。简单地将递归限制为恒定深度是不够的，因为这会使算法切换到所有足够大的数组上。马塞尔讨论了几种简单的方法：</p><p> Keep track of the list of sizes of the subpartitions processed so far. If at any point   recursive calls have been made without halving the list size, for some small positive  , switch to the worst-case linear algorithm.</p><p>跟踪到目前为止已处理的子分区的大小列表。如果在任何时候，在没有将列表大小减半的情况下进行递归调用，对于一些小的正数，请切换到最坏情况线性算法。</p><p> Sum the size of all partitions generated so far. If this exceeds the list size times some small positive constant  , switch to the worst-case linear algorithm.</p><p>求出到目前为止生成的所有分区的大小之和。如果超过列表大小乘以某个小的正常量，则切换到最坏情况线性算法。</p><p> This algorithm came into  libstdcxx and guess which strategy was chosen? Correct, none of them. Instead, they try   QuickSelect steps and if not successful, fallback to HeapSelect algorithm. So, worst case  , average</p><p>这个算法进入libstdcxx，猜猜选择了哪种策略？没错，都不是。相反，他们尝试QuickSelect步骤，如果不成功，则退回到HeapSelect算法。所以，最坏的情况，平均而言</p><p>   Now that most of the known algorithms come to an end 😈, we can start looking into something special and extraordinary. And the first one to look at is pdqselect which comes pretty straightforward from  pdqsort, the algorithm is basically QuickSelect but with some interesting ideas on how to choose an appropriate pivot:</p><p>现在大多数已知的算法都结束了😈，我们可以开始研究一些特别和非凡的东西了。第一个要看的是pdqselect，它非常简单地来自pdqort，算法基本上是QuickSelect，但有一些关于如何选择适当的轴心点的有趣想法：</p><p> If there are   elements, use  insertion sort to partition or even sort them. As insertion sort is really fast for a small amount of elements, it is reasonable</p><p>如果有元素，可以使用插入排序对其进行分区甚至排序。由于插入排序对于少量元素来说非常快，所以它是合理的。</p><p> If it is more, choose   — pivot: If there are less or equal than 128 elements, choose pseudomedian (or “ninther”, or median of medians which are all them same) of the following 3 groups:</p><p>如果大于，则选择-Pivot：如果少于或等于128个元素，则从以下3组中选择伪中值(或“九”，或全部相同的中值的中位数)：</p><p> If there are more than 128 elements, choose median of 3 from begin, mid, end</p><p>如果超过128个元素，则从开始、中间、结束选择3的中位数。</p><p> Partition the array by the chosen pivot with avoiding  branches: If the total number of bad partitions exceeds  , use  std::nth_element or any other fallback algorithm and return</p><p>使用避免分支的所选透视对数组进行分区：如果坏分区总数超过，请使用std：：nth_element或任何其他后备算法并返回。</p><p> Otherwise, try to defeat some patterns in the partition by (sizes are l_size and r_size respectively):</p><p>否则，尝试通过以下方式击败分区中的某些模式(大小分别为l_SIZE和r_SIZE)：</p><p>   For a long time, there were no practical improvements in finding  th element, and only in 2017 very well recognized among C++ community Andrei Alexandrescu published a paper on  Fast Deterministic Selection where worst case median algorithm becomes practical and can be used in real code.</p><p>在很长一段时间里，在寻找第th个元素方面没有实际的改进，直到2017年，C++社区非常认可Andrei Alexandresu发表了一篇关于快速确定性选择的论文，其中最坏情况中值算法变得实用，并可以在真实代码中使用。</p><p>  We now find the pseudomedian (or ninther, or median of medians which are all the same) of 9 elements as it was done similarly in pdqsort. Use that partition when</p><p>我们现在找到了9个元素的伪中值(或9个相同中值的中位数)，这与在pdq排序中类似。在以下情况下使用该分区</p><p>  Introduce MedianOfMinima for  . MedianOfMedians computes medians of small groups and takes their median to find a pivot approximating the median of the array. In this case, we pursue an order statistic skewed to the left, so instead of the median of each group, we compute its minimum; then, we obtain the pivot by computing the median of those groupwise minima.</p><p>介绍MedianOfMinima for。MedianOfMedians计算小组的中位数，并取其中位数来找到近似数组中值的轴心点。在这种情况下，我们追求一个向左倾斜的顺序统计量，所以我们不计算每个组的中位数，而是计算它的最小值；然后，我们通过计算这些GroupWise最小值的中位数来获得枢轴。</p><p>  is not chosen arbitrarily because in order to preserve the linearity of the algorithm we need to make sure that while recursing on   elements we partition more than   elements and thus  . MedianOfMaxima is done the same way and for  . The resulting algorithm turns out to be the following</p><p>不是任意选择的，因为为了保持算法的线性，我们需要确保在对元素进行递归时，我们划分的元素多于元素，因此。MedianOfMaxima的实现方式与For相同。最终得到的算法如下所示。</p><p>  Turns out it is a better algorithm than all above (except it did not know about pdqselect) and shows good results. My advice that if you need a deterministic worst-case linear algorithm this one is the best (we will talk about a couple of more randomized algorithms later).</p><p>事实证明，这是一个比上面所有算法都更好的算法(除了它不知道pdqselect)，并且显示了很好的结果。我的建议是，如果您需要确定性的最坏情况线性算法，这个算法是最好的(我们稍后将讨论几个更随机化的算法)。</p><p>   All these algorithms are good and linear but they require lots of comparisons, like, minimum   for all  . However, I know a good algorithm for   which requires only   comparisons (I am also not going to prove it is minimal but it is). Let’s quickly revise how it works.</p><p>所有这些算法都是好的和线性的，但它们需要进行大量的比较，比如，对所有人来说都是最低限度的比较。然而，我知道一个好的算法，它只需要比较(我也不打算证明它是最小的，但它是最小的)。让我们快速修改一下它的工作原理。</p><p> For finding a minimum you just compare linearly the winner with all others and basically the second place can be anyone who lost to the winner, so we need to compare them within each other. Unfortunately, the winner may have won linear number of others and we will not get the desired amount of comparisons. To mitigate this, we need to make a knockout tournament where the winner only plays   games like that:</p><p>为了找到最小值，你只需将获胜者与所有其他获胜者进行线性比较，基本上第二名可能是任何输给获胜者的人，所以我们需要将它们相互比较。不幸的是，获胜者可能赢得了线性数量的其他人，我们不会得到想要的比较数量。为了缓解这种情况，我们需要举办一场淘汰赛，获胜者只玩这样的游戏：</p><p>  And all we need to do next is to compare all losers to the winner</p><p>我们下一步要做的就是把所有输家和赢家进行比较。</p><p>  And any of them can be the second. And we use only   comparisons for that.</p><p>他们中的任何一个都可能是第二个。我们只对此进行比较。</p><p> What can we do to find the third and other elements? Possibly not optimal in comparison count but at least not so bad can follow the strategy:</p><p>我们能做些什么来找到第三个元素和其他元素呢？在比较计数上可能不是最优的，但至少不是那么糟糕，可以遵循这样的策略：</p><p> First set up a binary tree for a knockout tournament on   items. (This takes   comparisons.) The largest item is greater than   others, so it can’t be  th largest. Replace it, where it appears at an external node of the tree, by one of the   elements held in reserve, and find the largest element of the resulting  ; this requires at most   comparisons because we need to recompute only one path in the tree. Repeat this operation   times in all, for each element held in reserve.</p><p>首先建立项目淘汰赛的二叉树。(这需要进行比较。)。最大的项目比其他项目更大，所以它不可能是第三大项目。当它出现在树的外部节点时，用保留的元素之一替换它，并找到结果中最大的元素；这至多需要比较，因为我们只需要重新计算树中的一条路径。对于保留的每个元素，总共重复此操作次数。</p><p> It will give us the estimation of   comparisons. Assume you need to find top 10 out of millions of long strings and this might be a good solution to this instead of comparing at least   times.  However, it requires additional memory to remember the path of the winner and I currently do not know how to remove it thus making the algorithm impractical because of allocations or additional level of indirections.</p><p>它将给我们提供比较的估计。假设您需要从数百万个长字符串中找到前10个，这可能是一个很好的解决方案，而不是至少比较时间。然而，它需要额外的内存来记住获胜者的路径，而我目前不知道如何删除它，因此由于分配或额外级别的间接性，使得该算法不切实际。</p><p> At that time my knowledge of selection algorithms ended and I decided to address one known guy.</p><p>那时，我对选择算法的了解结束了，我决定向一个知名的人发表演讲。</p><p>  In The Art of Computer Programming, Volume 3, Sorting and Searching I read almost 100-150 pages in order to understand what the world knows about minimal comparison sorting and selection algorithms and found a pretty interesting one called Floyd-Rivest algorithm. Actually, even Alexandrescu paper cites it but in an unusual way:</p><p>在《计算机编程艺术》(The Art of Computer Programming，第三卷，Sorting and Search)一书中，我读了近100到150页，以便了解全世界对最小比较排序和选择算法的了解，发现了一个非常有趣的算法，名为弗洛伊德-里维斯特算法(Floyd-Rivest Algorithm)。实际上，就连亚历山大·雷斯库的论文也引用了这句话，但引用的方式不同寻常：</p><p>     From  , recursively select two elements,   and  , such that   (essentially they take   and  ). These two elements will be the  pivots for the partition and are expected to contain the   th smallest element of the entire list between them.</p><p>从中递归地选择两个元素：和，这样(本质上它们取和)。这两个元素将是分区的第二个轴心点，预计它们之间将包含整个列表中的第几个最小元素。</p><p>  Partition the remaining elements in  the array by comparing them to  u or  v and placing them into the appropriate set. If   is smaller than half the number of the elements in the array, then the remaining elements should be compared to   first and then only to   if they are smaller than  . Otherwise, the remaining elements should be compared to   first and only to   if they are greater than  .</p><p>通过将数组中剩余的元素与u或v进行比较，并将它们放入适当的集合中，对数组中的其余元素进行分区。如果小于数组中元素数量的一半，则应先将剩余元素与进行比较，然后再与小于的元素进行比较。否则，其余的元素应该首先与进行比较，如果它们大于，则只与进行比较。</p><p> Apply the algorithm recursively to the appropriate set to select the  th smallest in the array.</p><p>将该算法递归地应用于适当的集合，以选择数组中的第十个最小的。</p><p> Then in 2004 it was  proven that this method (slighly modified in bound selection) will have   comparisons with probability at least   (and the constant in the power can be tuned).</p><p>然后在2004年证明了这种方法(在界限选择上稍作修改)至少可以与概率进行比较(并且幂中的常数是可以调节的)。</p><p> This algorithm tries to find the appropriate subsamples and proves that the  th element will be there with high probability.</p><p>该算法试图找到合适的子样本，并证明第th个元素存在的概率很大。</p><p>   Yet the worst case of the algorithm is still   but it tries to optimize the minimum amount of comparisons on average case, not the worst case.</p><p>然而，该算法的最坏情况仍然是，但它试图优化平均情况下的最小比较次数，而不是最坏情况下的最小比较次数。</p><p> For small   it is really good as it only used   comparisons which is significantly better than all “at least   comparisons” algorithms and even for median it is   which is significantly better.</p><p>对于小的，它真的很好，因为它只使用比较，这比所有“至少比较”的算法都要好得多，甚至对于中位数，它也是明显更好的。</p><p>  So I decided to code all these algorithms with the C++ standard API and to test against each other and possibly submit to something performance heavy as DBMS for ORDER BY LIMIT N clauses.</p><p>因此，我决定用C++标准API对所有这些算法进行编码，并对它们进行相互测试，可能还会提交一些性能较高的东西，比如DBMS来执行ORDER BY LIMIT N子句。</p><p> I ended up doing  miniselect library. For now, it is header-only but I don’t guarantee that in the future, it contains almost all algorithms except the tournament one which is very hard to do in the general case.</p><p>我最终做了迷你精选图书馆。目前，它只是头球，但我不能保证在未来，它包含了除了锦标赛以外的几乎所有算法，这在一般情况下是很难做到的。</p><p> I tested on  Intel(R) Core(TM) i5-4200H CPU @ 2.80GHz (yeah, a bit old, sorry). We are going to find median and 1000th elements out of   and   arrays. Benchmark data:</p><p>我在2.80 GHz的英特尔(R)酷睿(TM)i5-4200H CPU上进行了测试(是的，有点旧，对不起)。我们将从和数组中找出中位数和第1000个元素。基准数据：</p><p>    As you see, Floyd-Rivest outperforms in time all other algorithms and even Alexandrescu in most of the cases. One downside is that Floyd-Rivest performs worse on data where there are many equal elements, that is expected and probably can be fixed as it is pointed out in  Kiwiel’s paper.</p><p>如你所见，Floyd-Rivest在时间上优于所有其他算法，甚至在大多数情况下优于Alexandresu。一个缺点是，Floyd-Rivest在有许多相等元素的数据上表现较差，这是意料之中的，正如Kiwiel的论文中指出的那样，这可能是可以修复的。</p><p>  This effort also resulted in a  patch to  ClickHouse where we got the following  benchmarks:</p><p>这一努力还导致了ClickHouse的补丁，我们在该补丁中获得了以下基准：</p><p>  As you see, most of the queries have ORDER BY LIMIT N. Topmost queries were significantly optimized because  std::partial_sort works worst when the data is descending, real-world usage as you can see in string_sort benchmarks was optimized by 10-15%. Also, there were many queries that have been optimized by 5% where sorting is not the bottleneck but still, it is nice. It ended up with a  2.5% overall performance boost across all queries.</p><p>如您所见，大多数查询都有ORDER BY LIMIT N。最顶层的查询得到了显著优化，因为STD：：PARTIAL_SORT在数据下降时工作最差，实际使用情况(如您在STRING_SORT基准测试中看到的)优化了10-15%。此外，有许多查询已经优化了5%，其中排序不是瓶颈，但仍然很不错。最终，所有查询的整体性能提升了2.5%。</p><p> Other algorithms showed worse performance and you can see it from the benchmarks above. So, now Floyd-Rivest is used in production, and for a good reason. But, of course, it does not diminish the results of Mr. Alexandrescu and his contributions are very valuable when it comes to determinism and worst case.</p><p>其他算法的性能较差，您可以从上面的基准测试中看出这一点。因此，现在弗洛伊德-里维斯特被用于生产，而且有一个很好的理由。但是，当然，这并不会削弱亚历山德雷斯库先生的成果，在决定论和最坏的情况下，他的贡献是非常宝贵的。</p><p>  I publish  miniselect under Boost License for everybody to use and adjust to the projects. I spent several days in the last week trying to make it work everywhere (except Windows for now but it should be good). We support C++11 and further with GCC 7+ and Clang 6+. We carefully test the algorithms for standard compliance, with fuzzing, sanitizers, etc. Fuzzing managed to find bugs that I thought only at the last moment so it really helps.</p><p>我在Boost许可证下发布迷你精选，供每个人使用和调整以适应项目。上周，我花了几天时间，试图让它在所有地方都能运行(目前除了Windows，但它应该是好的)。我们支持C++11以及GCC 7+和Clang 6+。我们仔细地测试了算法的标准符合性，使用了模糊、消毒剂等。模糊成功地找到了我在最后一刻才想到的错误，所以它真的很有帮助。</p><p> If you want to use it, please read the API but it should be an easy  sed/ perl/ regex replacement with zero issues except for the ties between elements might resolve in a different way, however, C++ standard says it is ok and you should not rely on that.</p><p>如果你想使用它，请阅读API，但它应该是一个简单的sed/perl/regex替代品，没有任何问题，除了元素之间的联系可能会以不同的方式解决之外，然而，C++标准说它是可以的，你不应该依赖它。</p><p> Any contributions and other algorithms that I might miss are highly welcome, I intend to get this library as a reference to many implementations of selection algorithms so that the users can try and choose the best options for them. (Should I do the same for sorting algorithms?)</p><p>任何我可能错过的贡献和其他算法都是非常受欢迎的，我打算将这个库作为选择算法的许多实现的参考，以便用户可以尝试为他们选择最好的选项。(我应该对排序算法做同样的事情吗？)。</p><p>  This was a long story of me trying to find the solutions to the problems that were puzzling me for the past month or so. I probably read 300+ pages of math/algorithms/discussions/forums to finally find everything that the world knows about it and to make it work for real-world applications with huge performance benefits. I think I can come up with something better in a long term after researching this stuff for a while longer but I will let you know in this blog if anything arises 🙂</p><p>这是一个很长的故事，我试图找到解决问题的办法，这些问题在过去一个月左右的时间里一直困扰着我。我可能阅读了300多页的数学/算法/讨论/论坛，以最终找到世界所知道的关于它的一切，并使其适用于具有巨大性能优势的真实世界的应用程序。我想在长期研究这个东西之后，我可以想出更好的东西，但是如果有什么事情发生，我会在这个博客里告诉你的。🙂。</p><p>  Selection Algorithms with Small Groups where the Median of Medians algorithms are a little bit twisted for groups of size 3 and 4 with linear time worst-case guarantee</p><p>具有小群体的选择算法，其中中值算法的中位数对于大小为3和4的群体在线性时间最坏情况下是有点扭曲的。</p><p>   The Art of Computer Programming, Volume 3, Sorting and Searching, Chapter about Minimum-Comparison Sorting and Selection</p><p>计算机编程艺术，第三卷，排序和搜索，关于最小比较排序和选择的章节</p><p>    An efficient algorithm for the approximate median selection problem by S. Battiato, D. Cantone, D. Catalano and G. Cincotti</p><p>S.Battiato，D.Canone，D.Catalano和G.Cincotti提出的近似中值选择问题的一个有效算法。</p><p> Today I present miniselect — generic C++ library for various selection algorithms  https://t.co/NAJmqMOE8a. Aaand post about my efforts and research in that area  https://t.co/YrNgZshrAJ. Many insights and gifs are included!</p><p>今天，我将介绍用于各种选择算法https://t.co/NAJmqMOE8a.的迷你选择通用C++库。我在这方面所做的努力和研究的帖子https://t.co/YrNgZshrAJ.。其中包含了许多见解和gif！</p><p>— Danila Kutenin (@Danlark1)  November 11, 2020</p><p>--Danila Kutenin(@Danlark1)2020年11月11日</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://danlark.org/2020/11/11/miniselect-practical-and-generic-selection-algorithms/">https://danlark.org/2020/11/11/miniselect-practical-and-generic-selection-algorithms/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/算法/">#算法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/实用/">#实用</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/practical/">#practical</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033773.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c080a81f8785ce41c9fcfedc4efe020b.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033773.html">Synerise推出AI Cleora算法作为开源</a></div><span class="my_story_list_date">2020-11-8 9:40</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033755.html"><img src="http://img2.diglog.com/img/2020/11/thumb_68eaef96ef90392715a86ab4529d5a51.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033755.html">费曼、算法编排和基于节点的编程</a></div><span class="my_story_list_date">2020-11-8 9:34</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032980.html"><img src="http://img2.diglog.com/img/2020/11/thumb_5ea50c11e87601962553e2d5ad6a8d28.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032980.html">应该允许受人工智能决策影响最大的人在塑造关于算法治理和监管的对话中发挥核心作用</a></div><span class="my_story_list_date">2020-11-3 22:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032364.html"><img src="http://img2.diglog.com/img/2020/10/thumb_358ec8b565c36520433f972ae2130006.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032364.html">
根据欧盟计划，大型科技公司的“黑匣子”算法面临监管监督</a></div><span class="my_story_list_date">2020-10-31 3:34</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>