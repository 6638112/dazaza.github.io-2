<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何成为10倍开发人员 How to Be a 10x Developer</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to Be a 10x Developer<br/>如何成为10倍开发人员 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-22 05:07:54</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/cda6af8cc4b99a02554768b18435d86c.png"><img src="http://img2.diglog.com/img/2020/12/cda6af8cc4b99a02554768b18435d86c.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>It’s not a clickbait title, but I understand why it looks that way.</p><p>它不是clickbait标题，但我知道为什么看起来像这样。</p><p> I’ve made my thoughts about the 10x developer trope  extremely clear. I think that someone who produces 10x as much code as someone else has left a wake of destruction that will slow down other developers. I don’t think 10x counts if you achieve it by slowing down everyone else. I think 10x has to take into account how you impact other people.</p><p> 我已经非常清楚地表达了对10x开发人员的想法。我认为，某个人的代码生成量是其他人的10倍，这已经使人望而却步，这会拖慢其他开发人员的速度。我认为，如果您通过减慢其他所有人的速度来实现这一目标，那么10倍的收益并不重要。我认为10倍必须考虑您如何影响他人。</p><p> And  that, paradoxically, suggests a path for how to become a 10x developer: empower and enable other people such that nine additional developers’ worth of work gets done. You can do that by making nine other developers’ workflows 2x smoother. You can also do that by making 18 other developers’ workflows 50% smoother, or 90 other developers’ workflows 10% smoother.</p><p> 矛盾的是，这为如何成为10倍开发人员提供了一条途径：授权和支持其他人，以便完成另外9名开发人员的工作。您可以通过使其他九个开发人员的工作流程平滑2倍来实现。您还可以通过使其他18个开发人员的工作流程平滑50％，或使其他90个开发人员的工作流程平滑10％来做到这一点。</p><p>  At some point, your biggest gains in your X are gonna be in improving the ecosystem for other developers. On occasions when I have succeeded at that, from  driving workplace changes to  teaching computer science classes, I have noticed that I’m using one or more of three techniques. So I thought I’d list them here.</p><p>  在某个时候，您在X中最大的收获就是可以改善其他开发人员的生态系统。有时候，我成功的时候（从推动工作场所变化到教授计算机科学课程），我注意到我正在使用三种技术中的一种或多种。所以我想在这里列出他们。</p><p>  Learning is work. Sometimes, it’s boring or difficult work. Folks don’t undertake that kind of work unless they understand why they should. That’s not as simple as  telling them why. Understanding comes from engaging with the material.</p><p>  学习是工作。有时候，这很无聊或困难。除非他们明白为什么要这么做，否则人们不会从事这种工作。这不只是告诉他们为什么那么简单。理解来自与材料的接触。</p><p> Suppose you want to make a major code change that affects your team’s workflow. If you blaze forward and do that without buy-in, the team will resent it ( as we’ve discussed in more detail here). So I recommend starting with individual conversations about the reasons for the change:</p><p> 假设您想对代码进行重大更改，从而影响团队的工作流程。如果您勇往直前而没有买入，那么团队会对此表示不满（正如我们在此处详细讨论的那样）。因此，我建议从有关更改原因的对话开始：</p><p> What is bothering you about your team’s current workflow that motivates you to push your solution? Are you annoyed at having to write the same code over and over in different places? Are you tired of trying to poke your way around an opaque tool? Are you losing track of things that cost you time and money? Before you  push  your solution,  pull  your coworkers to it by making sure they feel the pain that you feel.</p><p> 是什么困扰着您团队当前的工作流程，从而促使您推动解决方案？您是否不得不在不同的地方一遍又一遍地编写相同的代码而感到烦恼？您是否厌倦了尝试使用不透明工具的方式？您是否正在失去花费时间和金钱的事物？在您推您的解决方案之前，请确保您的同事感受到您的痛苦，将其拉到那里。 </p><p> Before I do a major refactor, I’ll deliberately pair program with key people on my team on the kind of problems that my refactor would solve. I want them to experience the pain firsthand; I want to hear them say ‘oh my  god this is annoying.’ After I have that admission of pain from a critical mass of people on my team, I’ll propose my solution, and I’ll offer to spearhead the refactor. I will craft a concise explanation of how our workflow changes after the refactor, and I’ll point out why I think the new way is nicer for us than the way we’re doing it now.  I have ‘negative testimonials’ about the old way, which I can whip out to capture the attention and agreement of others on my team. This approach allows me to muster support for my refactor and then, in spearheading the refactor, look like I’m taking one for the team.</p><p>在进行大型重构之前，我将与团队中的关键人员故意进行配对，以解决重构所能解决的问题。我希望他们亲身经历痛苦；我想听听他们说“噢，天哪，这很烦人。”在我承认团队中绝大部分人都感到痛苦之后，我会提出我的解决方案，并提议率先进行重构。我将就重构后我们的工作流程如何变化做出简明的解释，并指出为什么我认为新方法比我们现在做的更好。我有关于旧方法的“负面评价”，可以用它来吸引其他人对我团队的关注和同意。这种方法使我能够为重构提供支持，然后在引领重构的过程中，看起来就像我要为团队工作一样。</p><p> Imagine the same scenario, same refactor, but instead of socializing my solution, I go off on my own, do the refactor, and push. My team didn’t understand the pain that the refactor solved, so all they’re seeing is the pain of learning the  new way to do things. To them, it looks like I made a unilateral decision that screwed them over—the  opposite of what a team player would do. Keep in mind, in both circumstances, I wrote the  same code. The only difference is how I introduced it.</p><p> 想象一下相同的场景，相同的重构，但是我没有独自社交解决方案，而是独自一人去执行重构并进行推送。我的团队不了解重构所解决的痛苦，因此他们所看到的只是学习新的做事方式的痛苦。在他们看来，我似乎是单方面决定将他们搞砸了-与团队成员所做的相反。请记住，在两种情况下，我都编写了相同的代码。唯一的区别是我如何介绍它。</p><p>  How do we know what the right code changes are? This one is tricky, but one guiding principle has helped me out a lot:</p><p>  我们如何知道正确的代码更改是什么？这很棘手，但其中一项指导原则对我有很大帮助：</p><p>  Michael Feathers talks a great deal about this in his various discussions on edge-free programming ( here’s a more detailed look at some of those principles). But for exemplary purposes, here are a few simple solutions to complex problems that I’m especially proud of:</p><p>  迈克尔·费瑟斯（Michael Feathers）在有关无边缘编程的各种讨论中对此进行了大量讨论（这里对其中一些原理进行了更详细的介绍）。但出于示例目的，这里有一些简单的解决方案，它们使我特别感到骄傲的是复杂的问题：</p><p> I solved a thorny issue with a sometimes camouflaged, sometimes unreliable delete button by ripping it out ( Here’s the PR if you want more details)</p><p> 我通过删除某些有时被伪装，有时不可靠的删除按钮解决了一个棘手的问题（如果您需要更多详细信息，请点击此处是PR）</p><p> I resolved the issue of a laggy metronome in React-Native, where computationally expensive operations can result in delays for scheduled tasks. The app happened to also need to play back tracks at various multiples of their original speed. So I recorded a sound file of a metronome at 120 BPM, calculated what speed to play it by dividing the BPM the musician requested by 120, and wrote one method that shelled out to  expo-av to play accurate-to-tempo sound files for both the metronome and the backtracks.</p><p> 我解决了React-Native中节拍器延迟的问题，该问题中计算量大的操作可能导致计划任务的延迟。该应用碰巧还需要以原始速度的各种倍数播放曲目。因此，我以120 BPM的速度录制了节拍器的声音文件，通过将音乐家请求的BPM除以120来计算播放该速度的速度，并编写了一种方法，将其封装到expo-av上以播放准确的节奏声音文件。节拍器和回音。</p><p> I resolved an issue of regulating how often a person should be allowed to log their mood by realizing the issue was fake (assumed foil to “let’s make sure they log it at least this often”) and letting them log as often as they want ( more details here).</p><p> 我解决了一个问题，即通过意识到一个问题是假的来调节一个人应该多久记录一次情绪（假设阻止“让我们确保他们至少经常记录一次”），并让他们尽可能多地记录他们的情绪（详情请点击这里。 </p><p> Each of these solutions made the code cleaner and eliminated  multiple problems with the product. But they were not genius solutions. In fact, they were easy to miss precisely because complex problems don’t scream “I have a bonehead solution.”</p><p>这些解决方案均使代码更整洁，并消除了产品的多个问题。但是它们不是天才的解决方案。实际上，正是由于复杂的问题并没有尖叫“我有一个脑袋解决方案”，他们才容易被错过。</p><p>    One drawback: the tech industry generally rewards churning out tons of code  over elegant solutions. Chen Lin recently  tweeted about his experience with this at Uber. Chen is responding to  this commentary, which starts out salty but goes on to articulate a rarely-discussed element of how the tech industry functions: tech executives  have to make their work appear innovative in order to secure VC funding. So they’re forced to artificially “make it innovative” by filing patents or hopping on the latest trends. In the case of Uber and iOS development, that imperative  burned them badly.</p><p>    缺点之一：科技行业通常会因采用优雅的解决方案而浪费大量代码而获得奖励。陈琳最近在推特上发布了他在优步的经历。 Chen对此评论的回应是，该评论起初有些咸，但随后却明确阐明了技术行业如何运作的一个要素：为了获得风险投资，技术主管必须使他们的工作显得创新。因此，他们被迫通过申请专利或跳上最新趋势来人为地“使其具有创新性”。就Uber和iOS开发而言，当务之急是烧毁了它们。</p><p> Academia is similar:  Dr. Jeremy Watt, author of   Machine Learning Refined, articulates how academics  have to make their work appear novel in order to get published, and they have to get published to keep their jobs, so they’re forced to artificially differentiate similar concepts—to convolute rather than simplify.</p><p> 学术界是相似的：《机器学习精炼》的作者杰里米·瓦特（Jeremy Watt）博士阐明了学者们如何使其作品显得新颖才能被发表，为了保持工作而必须被发表，因此他们被迫人为地区分类似的概念-而不是简单地进行卷积。</p><p> There’s a great  explanation from Mekka Okereke about how to counteract some of this as an engineer. It shares a lot with our “first establish the motivation” approach—namely, by starting from the  problem, not the solution.</p><p> 梅卡·奥克雷克（Mekka Okereke）有一个很好的解释，说明如何抵消一些工程师的责任。它与我们的“首先建立动力”方法有很多共同之处，即从问题开始，而不是解决方案。</p><p>  One of my Mobile Software Development students asked me what frameworks he should consider for testing a Python app he’s working on. Here’s what I said:</p><p>  我的一位移动软件开发专业的学生问我，在测试正在开发的Python应用程序时应该考虑使用哪些框架。我是这样说的：</p><p> In Python there are two leading options: unittest and pytest. Both work fine. When I’m working on teams, I tend to go with pytest because the output is a little nicer.   But…when I’m  teaching Python, I don’t use a testing framework at all. I write methods that call the method I’m testing, and then I use Python’s  built in assert keyword to check the state of the modified objects or return values. Reason being, I don’t want to jump into the complexity of all the different stuff you can use to test until students understand  why we test. I try to use the minimum toolset that gets the point across.</p><p> 在Python中，有两个主要选项：unittest和pytest。两者都工作正常。在团队中工作时，我倾向于使用pytest，因为输出更好。但是...当我教Python时，我根本不使用测试框架。我编写了调用正在测试的方法的方法，然后使用Python的内置assert关键字来检查修改后的对象的状态或返回值。原因是，在学生理解我们为什么测试之前，我不想跳入可以用来测试的所有不同内容的复杂性。我尝试使用可以理解这一点的最小工具集。</p><p> One of the big things that educational approaches manage to screw up, in my view, is to introduce prerequisites that make the topic in question  harder instead of  easier. Fluent Forever founder Gabriel Wyner  articulates how language learning often depends on translation—which is a whole, separate,  difficult skill. So when I’m trying to help someone build intuition, I’ll try to eliminate as many dependencies as possible.</p><p> 我认为，教育方法要解决的一大问题是引入先决条件，使所讨论的主题更难而不是更容易。 Fluent Forever创始人Gabriel Wyner阐明了语言学习通常如何依赖翻译-这是一项整体，独立且困难的技能。因此，当我尝试帮助某人建立直觉时，我将尝试消除尽可能多的依赖关系。 </p><p> I’ll show you an example for teaching testing in Python. I pulled this example out of a notebook that I share with my  Emergent Works and  Justice Through Code mentee. She was working on writing a Sudoku solver. Of course, to solve a Sudoku, it helps to know when a Sudoku is solved.</p><p>我将向您展示一个使用Python进行测试教学的示例。我从与《紧急工作与司法通过法》的学员分享的笔记本中取出了此示例。她正在编写Sudoku求解器。当然，要解决数独问题，它有助于知道何时解决数独问题。</p><p> Suppose we start with a similar but simpler puzzle; each row and each column must each possess one copy of each number, like this:</p><p> 假设我们从一个类似但更简单的难题开始；每行和每一列必须每个数字都拥有一个副本，如下所示：</p><p> puzzle = [ [1, 2, 3, 4], [2, 1, 4, 3], [3, 4, 1, 2], [4, 3, 2, 1],]</p><p> 拼图= [[1,2,3,4]，[2，1，4，3]，[3，4，1，2]，[4，3，2，1]，]</p><p>  It shows a way of  representing our problem space—a list of lists. We could make a  Puzzle class for this, with all kinds of methods on it. I’m not doing that yet. I’m doing the  minimum thing that gets the point across: we need a way to represent our data. Here is a way to represent our data with minimal dependencies and indirection.</p><p>  它显示了一种表示问题空间的方式-列表列表。我们可以为此创建一个Puzzle类，其中包含各种方法。我还没有这样做。我正在做的事情很简单，可以说明要点：我们需要一种表示数据的方法。这是一种以最小的依赖性和间接性表示数据的方法。</p><p> We’re gonna do the same thing for the test, no test framework involved (yet!):</p><p> 我们将为测试做同样的事情，不涉及测试框架（还！）：</p><p> def valid_puzzle(puzzle): try: # Python is duck-typed, so here we check that the input is the type we expect is_a_list = type(puzzle).__name__ == &#34;list&#34; assert(is_a_list) # Check that the puzzle is a square number_of_rows = len(puzzle) number_of_columns = len(puzzle[0]) assert(number_of_rows == number_of_columns) # Same width and height assert(len(set([len(row) for row in puzzle])) == 1) # Every row has same length # Check the numbers used for the solution for row in puzzle: assert(len(set(row)) == len(row)) # Only one of any given number in the row #Numbers range from 1 to however big the row is assert(max(row) == len(row)) # In a 4-item row, the biggest number is 4, etc assert(min(row) == 1) # The smallest number is always 1 # Since we checked the maximum and minimum number for the rows, # and since we checked that the data is a square, # we can assume the max number in the columns and don&#39;t have to check it. # Check that there&#39;s only one of any given number in the column for index, item in enumerate(puzzle): column = [] for row in puzzle: column.append(row[index]) assert(len(set(column)) == len(column)) return &#34;This solution is valid!&#34; except: return &#34;Sorry! Not a valid puzzle solution.&#34;</p><p> def valid_puzzle（puzzle）：尝试：＃Python是鸭子类型的，因此在这里我们检查输入是否是我们期望的类型is_a_list = type（puzzle）。__name__ ==＆＃34; list＆＃34; assert（is_a_list）＃检查拼图是否为正方形number_of_rows = len（puzzle）number_of_columns = len（puzzle [0]）assert（number_of_rows == number_of_columns）＃宽度和高度相同assert（len（set（[len（row））对于拼图中的行]））== 1）＃每行的长度都相同＃检查用于拼图中行的解决方案的数字：assert（len（set（row））== len（row））＃仅以下一项行中的任何给定数字＃数字的范围是1到行的大小，但assert（max（row）== len（row））＃在4个项目的行中，最大数字是4，以此类推assert（min（row（row） ）== 1）＃最小的数字始终为1＃由于我们检查了行的最大和最小数目，＃并且由于我们检查了数据是正方形，所以＃我们可以假设列中的最大数目和don＆＃ 39; t不必检查。 ＃检查索引列中是否只有给定数字之一，枚举（拼图）中的项：column = []拼图中的行：column.append（row [index]）assert（len（set （column））== len（column））返回＆＃34;此解决方案有效！＆＃34;除外：对不起！这不是有效的难题解决方案。＆＃34;</p><p> What  don’t we care about? We don’t want to assert that the puzzle is 9×9 (and in fact in our current representation is too simple to pass if we assert that). So instead we make the checker work for any size of puzzle:</p><p> 我们不在乎什么？我们不想断言这个谜题是9×9（实际上，如果我们断言这一难题，那么当前的表示方法太简单了，难以通过）。因此，我们可以使检查器适用于任何大小的谜题： </p><p> bigger_puzzle = [ [1, 2, 3, 4, 5, 6, 7], [1, 2, 3, 4, 5, 6, 7], [1, 2, 3, 4, 5, 6, 7], [1, 2, 3, 4, 5, 6, 7], [1, 2, 3, 4, 5, 6, 7], [1, 2, 3, 4, 5, 6, 7], [1, 2, 3, 4, 5, 6, 7],]valid_puzzle(bigger_puzzle)&gt;&gt; Sorry! Not a valid puzzle solution.</p><p>Greater_puzzle = [[1、2、3、4、5、6、7]，[1、2、3、4、5、6、7]，[1、2、3、4、5、6、7] ，[1、2、3、4、5、6、7]，[1、2、3、4、5、6、7]，[1、2、3、4、5、6、7]，[ 1、2、3、4、5、6、7]，] valid_puzzle（bigger_puzzle）＆gt;抱歉!这不是有效的拼图解决方案。</p><p>  ninex9_puzzle = [ [3, 1, 6, 5, 7, 8, 4, 9, 2], [5, 2, 9, 1, 3, 4, 7, 6, 8], [4, 8, 7, 6, 2, 9, 5, 3, 1], [2, 6, 3, 4, 1, 5, 9, 8, 7], [9, 7, 4, 8, 6, 3, 1, 2, 5], [8, 5, 1, 7, 9, 2, 6, 4, 3], [1, 3, 8, 9, 4, 7, 2, 5, 6], [6, 9, 2, 3, 5, 1, 8, 7, 4], [7, 4, 5, 2, 8, 6, 3, 1, 9] ]valid_puzzle(ninex9_puzzle)&gt;&gt; This solution is valid!</p><p>  ninex9_puzzle = [[3，1，6，5，7，8，4，9，2]，[5，2，9，1，3，4，7，6，6，8]，[4，8，7， 6，2，9，9，5，3，1]，[2，6，3，4，1，5，9，8，8，7]，[9，7，4，8，6，3，1，2， 5]，[8、5、1、7、9、2、6、4、3]，[1、3、8、9、4、7、2、5、6]，[6、9、2 3、5、1、8、7、4]，[7、4、5、2、8、6、3、1、9]] valid_puzzle（ninex9_puzzle）此解决方案有效！</p><p> So we have a solution. Now, let’s talk about the  problems with our solution. What sucks about it?</p><p> 因此，我们有一个解决方案。现在，让我们谈谈我们解决方案的问题。有什么不好的呢？</p><p> Well, if a solution isn’t valid, the error message doesn’t tell you which assertion failed or why.</p><p> 好吧，如果解决方案无效，则错误消息不会告诉您哪个断言失败或原因。</p><p>  Once we have  defined our  assert_solved method, we have to explicitly  call it somewhere to get it to run.</p><p>  定义assert_solved方法后，必须在某处显式调用它才能使其运行。</p><p> This  is where I introduce the idea of a test framework. Pytest and unittest both include features to:</p><p> 这是我介绍测试框架的思想的地方。 Pytest和unittest都包含以下功能：</p><p> Explain, if the test fails, what the test was looking for, and what it got instead</p><p> 解释一下，如果测试失败，那么测试要寻找什么，取而代之的是 </p><p>  To automatically run all the methods in a test class, we can use one of Python’s data model methods to get the list of methods and attributes, filter out the attributes with another data model method, then call every method.  Here’s a blog post that demonstrates  almost that exact operation. But wait! We don’t want to call  every method on the class—that would include all the special methods! How do we get around that? Well, one way to do it is put the same prefix at the start of every method signature, and filter for that.  Now students understand why a test framework might require a test method name to start with “test!”</p><p>为了自动运行测试类中的所有方法，我们可以使用Python的一种数据模型方法获取方法和属性的列表，使用另一种数据模型方法过滤掉属性，然后调用每个方法。这是一篇博文，几乎演示了该操作。可是等等！我们不想调用类中的每个方法，因为它会包含所有特殊方法！我们如何解决呢？嗯，一种实现方法是在每个方法签名的开头都放置相同的前缀，并对其进行过滤。现在，学生了解了为什么测试框架可能需要以“ test！”开头的测试方法名称。</p><p> To bubble up the exception, we’d have to catch  specifically  AssertionErrors in that except block up there. Then, we could either handle any other errors with a second  except block, or we could just re-throw all the other errors.</p><p> 为了使异常冒泡，我们必须专门捕获其中的AssertionErrors，但要在那里阻止。然后，我们可以用第二个除外块来处理任何其他错误，或者我们可以重新抛出所有其他错误。</p><p> To provide clearer output, we’d need to get creative with how we store the variables we pass into the  asserts such that they could be fished back out and printed in the  AssertionError capture.</p><p> 为了提供更清晰的输出，我们需要在如何存储传递到断言中的变量方面发挥创意，以便可以将它们找回并打印在AssertionError捕获中。</p><p> This is where I can introduce testing libraries. Because we have taken time to develop intuition around how these libraries work, they no longer sound like magic. Students understand how they work because they  implemented a simple one and then, at a minimum, talked through how a  real one would need to work. PyTest is no longer some kind of enigmatic genius box. I find that this approach doesn’t just transfer knowledge—it helps new Python developers build their confidence and their skills.</p><p> 这是我可以介绍测试库的地方。因为我们花了一些时间来了解这些库的工作原理，所以它们不再听起来像魔术。学生了解他们的工作方式，因为他们实施了一个简单的方法，然后至少讨论了一个真正的人如何工作。 PyTest不再是某种神秘的天才盒子。我发现这种方法不仅可以转移知识，还可以帮助新Python开发人员树立信心和技能。</p><p> Whatever multiplier I have as a developer, I think I get from doing these three things.</p><p> 无论我作为一名开发人员拥有什么乘数，我都认为我从做这三件事中得到了收益。</p><p> I sell my solutions by engaging with others  first on the motivation for them. I try to find bonehead solutions to convoluted issues. And I try to eliminate barriers to entry when I’m helping others build intuition.</p><p> 我通过与他人互动来激发他们的动力，从而出售自己的解决方案。我试图找到解决棘手问题的解决方案。当我帮助他人建立直觉时，我会尝试消除进入障碍。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://chelseatroy.com/2020/12/18/how-to-be-a-10x-developer/">https://chelseatroy.com/2020/12/18/how-to-be-a-10x-developer/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/成为/">#成为</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/developer/">#developer</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/方法/">#方法</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>