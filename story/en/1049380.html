<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>证据应自行修复 Proofs Should Repair Themselves</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Proofs Should Repair Themselves<br/>证据应自行修复 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-25 23:17:12</div><div class="page_narrow text-break page_content"><p>In his 1900 book  The Wonderful Wizard of Oz, L. Frank Baum tells a story that will resonate with any software engineer. A woodman by the name of Nick Chopper suffers a series of workplace accidents. In turn, his arms, legs, body, and even his head are replaced by metal prosthetics. Eventually, what remains is an entirely different man made of tin.</p><p>弗兰克·鲍姆（L. Frank Baum）在1900年出版的《绿野仙踪》中讲述了一个会引起任何软件工程师共鸣的故事。一名名叫尼克·克珀（Nick Chopper）的wood夫遭受了一系列的工作场所事故。反过来，他的手臂，腿部，身体，甚至他的头部都被金属假肢代替。最终，剩下的是一个完全不同的锡制男人。</p><p> Like Baum’s Tin Man, all software projects are repaired and reconfigured, and a project can transform by degrees into something entirely unlike its starting point. As software engineers have long known, this shift of code and specification is the norm. Studies have shown that maintenance consumes the majority of resources in large-scale projects 1, and many systems are built on the bones of previous projects.</p><p> 像鲍姆（Baum）的《锡曼》（Tin Man）一样，所有软件项目都经过修复和重新配置，并且一个项目可以按度数转换为完全不同于其起点的项目。正如软件工程师早就知道的那样，这种代码和规范的转变是常态。研究表明，维护消耗了大型项目1中的大部分资源，许多系统建立在以前项目的基础上。</p><p> In recent years, many companies have begun to use formal proofs to provide assurance for software. For example, AWS now formally verifies significant portions of its  s2n  library, which provides cryptographic security for Amazon.com, Alexa, and more. Proofs are used for assurance at Facebook, Google, Intel, Apple, and others. For these companies,  proof engineering is software engineering. As software evolves, proofs of that software must evolve in kind.</p><p> 近年来，许多公司已开始使用形式证明来为软件提供保证。例如，AWS现在正式验证其s2n库的重要部分，该库为Amazon.com，Alexa等提供了加密安全性。证明用于Facebook，Google，Intel，Apple和其他公司的保证。对于这些公司，证明工程就是软件工程。随着软件的发展，该软件的证明也必须以实物形式发展。</p><p> A key method for success at these companies has been a close alignment between proof tools and continuous integration (CI) development environments. This linkage between proofs and code means that edits to the code can be rechecked within seconds in order to re-establish assurance of the software as it changes. However, experience shows this linkage is fragile. Automated tools can often re-establish a proof if code changes are small. But if the code is restructured beyond a certain point, proof tools are typically unable to re-establish a proof of correctness, even if the software contains no defects. Instead, the internal scaffolding of the proof must be rebuilt by hand by a formal methods expert. Consequently, proofs are tended and maintained by embedded proof experts who work alongside regular software engineers.</p><p> 这些公司成功的关键方法是证明工具与持续集成（CI）开发环境之间的紧密结合。证明与代码之间的这种联系意味着可以在几秒钟内重新检查对代码的编辑，以便在软件更改时重新建立对软件的保证。但是，经验表明这种联系是脆弱的。如果代码更改很小，自动化工具通常可以重新建立证明。但是，如果将代码重组到一定程度之外，即使软件不包含任何缺陷，证明工具也通常无法重新建立正确性证明。取而代之的是，证明的内部支架必须由正式的方法专家手动重建。因此，与常规软件工程师一起工作的嵌入式证明专家将维护和维护证明。</p><p> This approach cannot scale, and therefore proof repair is a scalability issue. If proofs require regular repair by experts, there is an inherent limit on how widely they can be deployed. Formal methods experts are in short supply, and the time and cost involved in the manual reconstruction of proofs is considerable. For the foreseeable future, human expertise will continue to be necessary in constructing formal proofs, but we should aim for the effort of maintaining a proof to be comparable to the effort of maintaining the software. If we are to reach a world where proofs are a routine part of software engineering, then moderate code changes should result in moderate — and automated — proof repairs.</p><p> 这种方法无法扩展，因此，证据修复是可伸缩性问题。如果证据需要专家定期修理，则对证据的部署范围有固有的限制。形式方法专家供不应求，手动重建证据所需的时间和成本相当可观。在可预见的将来，构建正式的证明将继续需要人类的专业知识，但是我们应该将维护证明的努力与维护软件的努力相提并论。如果我们要达到一个证明是软件工程的常规组成部分的世界，那么适度的代码更改应会导致适度（自动）的证据修复。</p><p> We have reason to think such proof repair is tractable. Rather than trying to synthesize a complete proof from nothing — a problem known to be immensely difficult — we start from a correct proof of fairly similar software. We will be attempting proof reconstruction within a known neighborhood.</p><p> 我们有理由认为这样的证据修复是很容易的。与其尝试从无到有综合一个完整的证明（众所周知的难题，这是非常困难的），不如从一个相当相似的软件的正确证明开始。我们将尝试在已知邻域内进行证明重建。</p><p>  Local repair search. Many properties in a proof are local to a particular piece of code, meaning that a code change may only invalidate a small portion of the proof. Often, proof tools do not consider this locality and perform a potentially exponential analysis of all the code. By the same token, when proofs fail, current proof tools do not do a good job of localizing the source of the failure in the program. In many cases, it will be possible to adapt proof tools to search locally for repairs to existing proofs. When a proof requires repair, the tool would identify the minimal slice of code and proof affected and then search for a local fix to re-establish assurance.</p><p>  本地维修搜索。证明中的许多属性仅适用于特定代码段，这意味着代码更改可能只会使一小部分证明无效。证明工具通常不考虑这种局部性，而是对所有代码执行可能的指数分析。同样，当证明失败时，当前的证明工具不能很好地在程序中定位失败源。在许多情况下，将有可能使证明工具适应本地搜索现有证明的修复。当证明需要维修时，该工具将识别受影响的代码和证明的最小片段，然后搜索本地修正以重新建立保证。 </p><p> Change-resistant proofs. Formal proofs represent two kinds of properties: fundamental properties necessary to assert correct behavior, and accidental properties that reflect the structure of the code. Most current proofs intermingle these concerns and become inflexible in the face of changes in the code. Proofs should be designed reducing the coupling between the fundamental properties and the accidental. When proofs express such distinctions, it will be more feasible to identify opportunities for repair in the structure of the proof itself.</p><p>耐变化的证明。形式上的证明代表两种属性：断言正确行为所必需的基本属性，以及反映代码结构的偶然属性。当前最新的证明将这些问题混合在一起，并且面对代码的更改变得僵化。应设计校样以减少基本特​​性和偶然性之间的耦合。当证明表达了这样的区别时，在证明本身的结构中确定修复机会将更为可行。</p><p> Transfer learning between proofs. Proofs, like programs, are very diverse, but repairs often follow a small set of patterns. Current proof tools operate on the current code alone, independent of any other patterns. The new research area of Big Code has identified approaches for applying machine learning to code updates by observing code use patterns and corresponding properties. Where such patterns arise again, even in quite different applications, the proof tool will obtain guidance (akin to human insight) regarding techniques to try to affect the proof repair. Learning from other uses creates a virtuous cycle, where successful proof repairs add to the examples driving learning.</p><p> 在证明之间转移学习。证明与程序一样，证明也很多样化，但是维修通常遵循一小组模式。当前证明工具仅对当前代码进行操作，而与其他任何模式无关。大代码的新研究领域已经确定了通过观察代码使用模式和相应属性，将机器学习应用于代码更新的方法。在这种模式再次出现的地方，即使在完全不同的应用程序中，证明工具也将获得有关试图影响证明修复的技术的指导（类似于人类的洞察力）。从其他用途中学习会产生一个良性循环，成功的证据修复会为推动学习的示例增添色彩。</p><p> Understandable proof repairs. Some repairs can be applied automatically, but some will require input from humans even with local code changes. Currently, proof tools require formal methods expertise. We believe it is possible to create a path whereby the software developers — who intuitively understand the intent of their code — can interact with the proof repair tools. Tools should propose possible repairs in terms that make sense to software developers, including explanations of the ramifications of change for the overall assurance results. The tools may go as far as to demonstrate that a proof cannot be repaired, and suggest possible program repairs instead.</p><p> 可以理解的维修。有些维修可以自动进行，但有些维修甚至需要更改本地代码，也需要人工输入。当前，证明工具需要正式的方法专业知识。我们认为，有可能创建一条途径，使直观地了解其代码意图的软件开发人员可以与证明修复工具进行交互。工具应以对软件开发人员有意义的方式提出可能的维修建议，包括对总体保证结果的变更后果的说明。这些工具可能会尽可能地证明无法修复证明，并建议可能的程序修复。</p><p> An increasing number of real-world software projects now have accompanying proofs. Some of these proofs are already integrated into software engineering pipelines. This represents both a risk and an opportunity for proof engineering as a field. No matter the assurance gains that are possible from proofs, if they can’t be maintained, they will quickly be set aside. We must quickly develop techniques that can deal with change, which is ubiquitous in real software.</p><p> 现在，越来越多的实际软件项目具有随附的证明。其中一些证明已经集成到软件工程管道中。这既是证明工程作为一个领域的风险也是机会。不管从证明中获得的保证收益如何，如果它们无法保持，它们将很快被搁置。我们必须迅速开发可以应对变化的技术，这在实际软件中是无处不在的。</p><p> Nonetheless, there is reason for optimism. Automated proof repair is little studied, and (as I have laid out above) there are several possible avenues for success. Many of the current commercial proofs are open source, with complete changelogs stored in their repositories. This represents a rich set of test data with which we can refine our ideas. The time is right for ambitious research to solve this problem, and we are just getting started.</p><p> 尽管如此，仍有理由感到乐观。自动化证明修复的研究很少，并且（如上所述），有几种可能的成功途径。当前许多商业证明都是开源的，完整的变更日志存储在其存储库中。这代表了一组丰富的测试数据，通过这些数据我们可以完善我们的想法。现在该进行雄心勃勃的研究来解决这个问题的时候了，我们才刚刚开始。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://galois.com/blog/2020/12/proofs-should-repair-themselves/">https://galois.com/blog/2020/12/proofs-should-repair-themselves/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/证据/">#证据</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/proofs/">#proofs</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/证明/">#证明</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>