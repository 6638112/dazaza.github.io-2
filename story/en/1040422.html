<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>幻觉：赛博朋克2077的渲染 Hallucinations re: the rendering of Cyberpunk 2077</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Hallucinations re: the rendering of Cyberpunk 2077<br/>幻觉：赛博朋克2077的渲染 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-18 16:05:54</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/dc874cec072f16ad4b8f29405e483d23.png"><img src="http://img2.diglog.com/img/2020/12/dc874cec072f16ad4b8f29405e483d23.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Two curses befall rendering engineers. First, we lose the ability to look at reality without being constantly reminded of how fascinatingly hard it is to solve light transport and model materials.</p><p>两个诅咒降临渲染工程师。首先，我们失去了看待现实的能力，而没有不断地提醒人们解决光传输和模型材料的难易程度。</p><p> Second, when you start playing any game, you cannot refrain from trying to reverse its rendering technology (which is particularly infuriating for multiplayer titles - stop shooting at me, I&#39;m just here to look how rocks cast shadows!).</p><p> 其次，当您开始玩任何游戏时，您都不能避免尝试颠倒其渲染技术（对于多人游戏而言，这尤其令人生气-停止向我射击，我就在这里看着石头如何投射阴影！）。</p><p> So when I bought Cyberpunk 2077 I had to look at how it renders a frame. It&#39;s very simple to take RenderDoc captures of it, so I had really no excuse.</p><p> 因此，当我购买《赛博朋克2077》时，我不得不研究一下它如何渲染框架。用RenderDoc捕获它非常简单，所以我真的没有任何借口。</p><p> The following are speculations on its rendering techniques, observations made while skimming captures, and playing a few hours.</p><p> 以下是有关其渲染技术的推测，在掠过捕获并玩了几个小时的观察结果。</p><p> It&#39;s by no means a serious attempt at reverse engineering.  For that, I lack both the time and the talent. I also rationalize doing a bad job at this by the following excuse: it&#39;s actually better this way.</p><p> 这绝不是对逆向工程的认真尝试。为此，我缺乏时间和才华。我还通过以下借口合理化了做不好的事情：这样实际上更好。</p><p> I think it&#39;s better to dream about how rendering (or anything really) could be, just with some degree of inspiration from external sources (in this case, RenderDoc captures), rather than exactly knowing what is going on.</p><p> 我认为最好是从外部来源（在这种情况下，是RenderDoc捕获）中获得某种程度的灵感，然后再幻想渲染（或任何东西）的真实状态，而不是确切地知道发生了什么。</p><p> If we know, we know, there&#39;s no mystery anymore. It&#39;s what we do not know that makes us think, and sometimes we exactly guess what&#39;s going on, but other times we do one better, we hallucinate something new... Isn&#39;t that wonderful?</p><p> 如果我们知道，我们就不再有神秘感。这是我们不知道的，这使我们思考，有时我们确切地猜测正在发生什么，但是有时候我们做得更好，我们会产生新的幻觉...不是那么美妙？ </p><p> The following is mostly a read-through of a single capture. I did open a second one to try to fill some blanks, but so far, that&#39;s all.</p><p>以下内容主要是对单个捕获的通读。我确实打开了第二个，试图填补一些空白，但是到目前为止，仅此而已。</p><p> I made the captures at high settings, without RTX or DLSS as RenderDoc does not allow these (yet?). I disabled motionblur and other uninteresting post-fx and made sure I was moving in all captures to be able to tell a bit better when passes access previous frame(s) data.</p><p> 我在没有RTX或DLSS的情况下在高设置下进行了捕获，因为RenderDoc不允许这样做（还可以吗？）。我禁用了Motionblur和其他无用的post-fx，并确保我在所有捕获中都移动了，以便能够更好地告知传递过去访问前一帧数据的时间。</p><p> I am also not relying on insider information for this. Makes everything easier and more fun.</p><p> 我也不依赖内部信息。使一切变得更加轻松有趣。</p><p>  At a glance, it doesn&#39;t take long to describe the core of Cyberpunk 2077 rendering. It&#39;s a classic deferred renderer, with a fairly vanilla g-buffer layout. We don&#39;t see the crazy amount of buffers of say, Suckerpunch&#39;s PS4 launch Infamous:Second Son, nor complex bit-packing and re-interpretation of channels.</p><p>  一目了然，很快就可以描述Cyber​​punk 2077渲染的核心。它是经典的延迟渲染器，具有相当不错的g缓冲区布局。我们看不到Suckerpunch的PS4推出了Infamous：Second Son之类的疯狂缓冲区，也没有看到复杂的位打包和通道重新解释。</p><p>   10.10.10.2 Albedo. Not clear what the alpha is doing here, it seems to just be set to one for everything drawn, but it might be only the captures I got</p><p>   10.10.10.2反照率。还不清楚Alpha在这里做什么，它似乎只是为所有绘制的内容设置为一个，但可能仅仅是我得到的捕获</p><p>  Z-buffer and Stencil. The latter seems to isolate object/material types. Moving objects are tagged. Skin. Cars. Vegetation. Hair. Roads. Hard to tell / would take time to identify the meaning of each bit, but you get the gist...</p><p>  Z缓冲区和模具。后者似乎隔离了对象/材料类型。移动对象被标记。皮肤。汽车。植被。头发。道路。很难说出来/需要花费时间来识别每个位的含义，但是要点...</p><p>  If we look at the frame chronologically, it starts with a bunch of UI draws (that I didn&#39;t investigate further), a bunch of copies from a CPU buffer into VS constants, then a shadowmap update (more on this later), and finally a depth pre-pass.</p><p>  如果我们按时间顺序查看框架，则从一堆UI绘制（我没有进一步研究）开始，从CPU缓冲区到VS常数的一堆副本，然后是阴影映射更新（稍后将对此进行详细介绍） ，最后进行深度预传。 </p><p>   This depth pre-pass is partial (not drawing the entire scene) and is only used to reduce the overdraw in the subsequent g-buffer pass.</p><p>此深度预传递是局部的（不绘制整个场景），仅用于减少后续g缓冲区传递中的透支。</p><p> Basically, all the geometry draws are using instancing and some form of bindless textures. I&#39;d imagine this was a big part of updating the engine from The Witcher 3 to contemporary hardware.</p><p> 基本上，所有几何图形绘制都使用实例化和某种形式的无绑定纹理。我想这是将引擎从The Witcher 3更新为现代硬件的重要组成部分。</p><p> Bindless also makes it quite annoying to look at the capture in renderDoc unfortunately - by spot-checking I could not see too many different shaders in the g-buffer pass - perhaps a sign of not having allowed artists to make shaders via visual graphs?</p><p> 不幸的是，Bindless也使查看renderDoc中的捕获变得很烦人-通过抽查，我在g缓冲区传递中看不到太多不同的着色器-也许这是不允许艺术家通过视觉图形制作着色器的信号吗？</p><p> Other wild guesses: I don&#39;t see any front-to-back sorting in the g-buffer, and the depth prepass renders all kinds of geometries, not just walls, so it would seem that there is no special authoring for these (brushes, forming a BSP) - nor artists have hand-tagged objects for the prepass, as some relatively &#34;bad&#34; occluders make the cut. I imagine that after culling a list of objects is sorted by shader and from there instanced draws are dynamically formed on the CPU.</p><p> 其他大胆的猜测：我看不到g缓冲区中的任何从前到后的排序，并且深度预传递呈现了各种几何形状，而不仅仅是壁，因此似乎没有针对这些的特殊创作（画笔，形成BSP）-艺术家也没有为手动过关设计的带有手动标签的对象，因为有些相对较差的＆＃34;封堵器使削减。我想象在剔除对象列表之后，将按着色器对对象进行排序，然后在CPU上动态形成实例化的绘制。</p><p> The opening credits do not mention Umbra (which was used in The Witcher 3) - so I guess CDPr rolled out their own visibility solution. Its effectiveness is really hard to gauge, as visibility is a GPU/CPU balance problem, but there seem to be quite a few draws that do not contribute to the image, for what&#39;s worth. It also looks like that at times the rendering can display &#34;hidden&#34; rooms, so it looks like it&#39;s not a cell and portal system - I am guessing that for such large worlds it&#39;s impractical to ask artists to do lots of manual work for visibility.  Lastly, I didn&#39;t see any culling done GPU side, with depth pyramids and so on, no per-triangle or cluster culling or predicated draws, so I guess all frustum and occlusion culling is CPU-side.</p><p> 开场白没有提到Umbra（在《巫师3》中使用过），因此我想CDPr推出了自己的可视性解决方案。由于可见性是GPU / CPU平衡的问题，因此它的有效性确实很难评估，但是对于价值多少，似乎有很多平局对图像没有贡献。看起来有时渲染可以显示＆＃34; hidden＆＃34;房间，所以它看起来不是一个单元格和门户系统-我猜想对于如此大的世界，要求艺术家做大量的手工工作以提高知名度是不切实际的。最后，我没有看到在GPU端进行任何剔除，包括深度金字塔等，没有按三角形或簇剔除或谓词绘制，因此我猜所有平截头体和遮挡剔除都是在CPU端进行的。</p><p> Note: people are asking if &#34;bad&#34; culling is the reason for the current performance issues, I guess meaning on ps4/xb1. This inference cannot be done, nor the visibility system can be called &#34;bad&#34; - as I wrote already. FWIW - it seems mostly that consoles struggle with memory and streaming more than anything else. Who knows...</p><p> 注意：人们在问&&＃34; bad＆＃34;剔除是当前性能问题的原因，我想这对ps4 / xb1有意义。无法进行这种推断，也不能将可见性系统称为＆＃34; bad＆＃34; -正如我已经写的。 FWIW-在大多数情况下，控制台在内存和流媒体方面的挣扎比其他任何事情都多。谁知道...</p><p> Let&#39;s keep going... After the main g-buffer pass (which seems to be always split in two - not sure if there&#39;s a rendering reason or perhaps these are two command buffers done on different threads), there are other passes for moving objects (which write motion vectors - the motion vector buffer is first initialized with camera motion).</p><p> 让我们继续...在主要的g缓冲区传递之后（似乎总是一分为二-不知道是否存在渲染原因，或者也许这是在不同线程上完成的两个命令缓冲区），还有其他用于移动对象的通道（写入运动矢量-首先通过摄像机运动初始化运动矢量缓冲区）。 </p><p> This pass includes avatars, and the shaders for these objects do not use bindless (perhaps that&#39;s used only for world geometry) - so it&#39;s much easier to see what&#39;s going on there if one wants to.</p><p>此阶段包括化身，并且这些对象的着色器不使用无边界（也许仅用于世界几何）-因此，如果需要，可以更容易地看到那里发生了什么至。</p><p> Finally, we&#39;re done with the main g-buffer passes, depth-writes are turned off and there is a final pass for decals. Surprisingly these are pretty &#34;vanilla&#34; as well, most of them being mesh decals.</p><p> 最后，我们完成了主要的g缓冲区传递，深度写入已关闭，并且贴花有最后传递。令人惊讶的是，它们很漂亮。同样，它们大多数是网状贴花。</p><p> Decals bind depth-stencil as input as well, hard to tell if to read the depth part, the stencil, or both, but as most decals are mesh-based, depth should not be needed, so let&#39;s guess stencil is what&#39;s used here...</p><p> 贴图也将深度模板绑定为输入，很难分辨是否读取深度部分，模板或两者，但是由于大多数贴图是基于网格的，因此不需要深度，所以让我们猜测模板是这里使用了什么...</p><p>    It looks like only triangles carrying decals are rendered, using special decal meshes, but other than that everything is remarkably simple. At the end of the decal pass we see sometimes projected decals as well, I haven&#39;t investigated dynamic ones created by weapons, but the static ones on the levels are just applied with tight boxes around geometry, I guess hand-made, without any stencil-marking technique (which would probably not help in this case) to try to minimize the shaded pixels.</p><p>    看起来只有使用特殊贴花网格渲染了带有贴花的三角形，但除此之外，其他一切都非常简单。在贴图传递的末尾，我们有时还会看到投影的贴图，我没有研究过由武器创建的动态贴图，但是在关卡上的静态贴图只是在几何体周围使用了紧密的盒子，我想是手工制作的，没有任何模版标记技术（在这种情况下可能无济于事）来尝试最小化阴影像素。</p><p>    As for the main g-buffer draws, many of the decals might end up not contributing at all to the image, and I don&#39;t see much evidence of decal culling (as some tiny ones are draws) - but it also might depend on my chosen settings.</p><p>    至于主要的g缓冲区平局，很多贴花可能最终对图像完全没有贡献，我看不到有很多证据表明进行了贴花剔除（因为一些微小的平局是平局），但它也可能取决于我选择的设置。</p><p> The g-buffer pass is quite heavy, and the end results are fantastic. E.g. look at the normal, everything has patterns, and in general, the detail is quite high frequency.</p><p> g缓冲区传递非常重，最终结果非常出色。例如。看正常，一切都有图案，一般来说，细节频率很高。</p><p> Note also the speckles in the normal buffer. These are likely an artifact of best-fit normal encoding, as they don&#39;t seem to map to speckles in the final image.</p><p> 注意正常缓冲区中的斑点。这些可能是最适合常规编码的伪像，因为它们似乎没有映射到最终图像中的斑点。 </p><p>     Obviously, no deferred rendering analysis can stop at the g-buffer, we split shading in two, and we have now to look at the second half, how lighting is done.</p><p>显然，没有任何延迟的渲染分析可以在g缓冲区处停止，我们将阴影一分为二，现在我们要看一下下半部分，照明是如何完成的。</p><p> Here things become a bit dicier, as in the modern age of compute shaders, everything gets packed into structures that we cannot easily see. Even textures can be hard to read when they do not carry continuous data but pack who-knows-what into integers.</p><p> 在这里，事情变得有些杂乱无章，因为在现代的计算着色器中，一切都被打包到了我们不容易看到的结构中。当纹理不携带连续数据而是将谁知道的内容打包为整数时，甚至很难读取。</p><p>    Regardless, it&#39;s pretty clear that after all the depth/g-buffer work is said and done, a uber-summarization pass kicks in taking care of a bunch of depth-related stuff.   It first packs normal and roughness into a RGBA8 using Crytek&#39;s lookup-based best-fit normal encoding, then it creates a min-max mip pyramid of depth values.</p><p>    无论如何，很显然，在说完所有深度/ g缓冲区工作之后，就需要进行超级摘要传递来处理一堆与深度有关的东西。它首先使用Crytek基于查找的最佳拟合法向编码将法线和粗糙度打包到RGBA8中，然后创建深度值的最小-最大mip金字塔。</p><p>    The pyramid is then used to create what looks like a volumetric texture for clustered lighting.</p><p>    金字塔然后用于为群集照明创建看起来像体积纹理的外观。</p><p>    So - from what I can see it looks like a clustered deferred lighting system.   The clusters seem to be 32x32 pixels in screen-space (froxels), with 64 z-slices. The lighting though seems to be done at a 16x16 tile granularity, all via compute shader indirect dispatches.</p><p>    所以-从我所看到的来看，它看起来像一个群集的延迟照明系统。群集在屏幕空间（像素）中似乎是32x32像素，带有64个z切片。虽然照明似乎是通过16x16的图块粒度完成的，但全部都是通过计算着色器间接调度完成的。</p><p> I would venture this is because CS are specialized by both the materials and lights present in a tile, and then dispatched accordingly - a common setup in contemporary deferred rendering systems (e.g. see Call of Duty Black Ops 3 and Uncharted 4 presentations on the topic).</p><p> 我敢说这是因为CS通过瓷砖中存在的材料和灯光进行专业化处理，然后进行相应的调度-这是当代延迟渲染系统中的常见设置（例如，请参见“使命召唤：黑色行动3”和“神秘海域4”主题演讲） 。</p><p> Analytic lighting pass outputs two RGBA16 buffers, which seems to be diffuse and specular contributions. Regarding the options for scene lights, I would not be surprised if all we have are spot/point/sphere lights and line/capsule lights. Most of Cyberpunk&#39;s lights are neons, so definitely line light support is a must.</p><p> 解析光照通过输出两个RGBA16缓冲区，这似乎是漫反射和镜面反射的贡献。关于场景灯的选项，如果我们只有点/点/球面灯和线/胶囊灯，我不会感到惊讶。赛博朋克的大多数灯光都是霓虹灯，因此绝对需要线灯支持。 </p><p> You&#39;ll also notice that a lot of the lighting is unshadowed, and I don&#39;t think I ever noticed multiple shadows under a single object/avatar. I&#39;m sure that the engine does not have limitations in that aspect, but all this points at lighting that is heavily &#34;authored&#34; with artists carefully placing shadow-casting lights. I would also not be surprised if the lights have manually assigned bounding volumes to avoid leaks.</p><p>您还会注意到很多光线都没有阴影，而且我不认为我曾经在单个对象/化身下看到多个阴影。我确定引擎在这方面没有任何限制，但是所有这些都指向大量的灯光。与艺术家一起精心放置阴影投射灯。如果灯已经手动分配了边界体积以避免泄漏，我也不会感到惊讶。</p><p>      Lighting part 2: Shadows  But what we just saw does not mean that shadows are unsophisticated in Cyberpunk 2077, quite the contrary, there are definitely a number of tricks that have been employed, most of them not at all easy to reverse!</p><p>      照明第2部分：阴影但是，我们所看到的并不意味着在《赛博朋克2077》中阴影并不复杂，相反，绝对有很多技巧可以运用，其中绝大部分都不容易逆转！</p><p> First of all, before the depth-prepass, there are always a bunch of draws into what looks like a shadowmap. I suspect this is a CSM, but in the capture I have looked at, I have never seen it used, only rendered into. This points to a system that updates shadowmaps over many frames, likely with only static objects?</p><p> 首先，在深度预先通过之前，总是会有很多绘制成类似阴影贴图的图形。我怀疑这是CSM，但是在我看过的捕获中，我从未见过使用过的捕获，只是渲染了。这是否指向一个可以在许多帧上更新阴影贴图的系统，可能仅使用静态对象？</p><p>    These multi-frame effects are complicated to capture, so I can&#39;t say if there are further caching systems (e.g. see the quadtree compressed shadows of Black Ops 3) at play.</p><p>    这些多帧效果很难捕获，因此我不能说是否还有其他缓存系统（例如，请参阅《黑色行动3》的四叉树压缩阴影）。</p><p> One thing that looks interesting is that if you travel fast enough through a level (e.g. in a car) you can see that the shadows take some time to &#34;catch up&#34; and they fade in incrementally in a peculiar fashion. It almost appears like there is a depth offset applied from the sun point of view, that over time gets reduced. Interesting!</p><p> 一件有趣的事是，如果您在关卡中行驶得足够快（例如，在汽车中），您会发现阴影需要一些时间来“赶上”。并且它们以独特的方式逐渐消失。从太阳角度看，似乎几乎应用了深度偏移，随着时间的推移，深度偏移会减少。有趣！</p><p>    Sun shadows are pre-resolved into a screen-space buffer prior to the lighting compute pass, I guess to simplify compute shaders and achieve higher occupancy. This buffer is generated in a pass that binds quite a few textures, two of which look CSM-ish. One is clearly a CSM, with in my case five entries in a texture array, where slices 0 to 3 are different cascades, but the last slice appears to be the same cascade as slice 0 but from a slightly different perspective.   There&#39;s surely a lot to reverse-engineer here if one was inclined to do the work!</p><p>    我将在照明计算通过之前将太阳阴影预先解析到屏幕空间缓冲区中，我想可以简化计算着色器并获得更高的占用率。该缓冲区是通过绑定许多纹理的遍历生成的，其中两个看上去类似于CSM。一个显然是CSM，在我的情况下，在纹理数组中有五个条目，其中切片0到3是不同的级联，但是从切片角度来看，最后一个切片似乎与切片0相同的级联。如果有人愿意做这项工作，肯定会有很多逆向工程！</p><p>     All other shadows in the scene are some form of VSMs, computed again incrementally over time. I&#39;ve seen 512x512 and 256x256 used, and in my captures, I can see five shadowmaps rendered per frame, but I&#39;m guessing this depends on settings. Most of these seem only bound as render targets, so again it might be that it takes multiple frames to finish rendering them. One gets blurred (VSM) into a slice of a texture array - I&#39;ve seen some with 10 slices and others with 20.      Finally, we have what the game settings call &#34;contact shadows&#34; - which are screen-space, short-range raymarched shadows. These seem to be computed by the lighting compute shaders themselves, which would make sense as these know about lights and their directions...  Overall, shadows are both simple and complex. The setup, with CSMs, VSMs, and optionally raymarching is not overly surprising, but I&#39;m sure the devil is in the detail of how all these are generated and faded in. It&#39;s rare to see obvious artifacts, so the entire system has to be praised, especially in an open-world game!</p><p>     场景中的所有其他阴影都是某种形式的VSM，会随着时间的推移再次递增地计算。我已经看到使用了512x512和256x256，并且在我的捕获中，我可以看到每帧渲染了五个阴影贴图，但是我猜测这取决于设置。其中大多数似乎仅作为渲染目标绑定，因此再次可能是需要多个帧才能完成渲染。一个被模糊化（VSM）到纹理阵列的一个切片中-我已经看到一些切片包含10个切片，另一些切片包含20个切片。最后，我们有了游戏设置所称的“接触阴影”。 -是屏幕空间的短距离射线网格阴影。这些似乎是由照明计算着色器本身计算出来的，因为这些人知道有关灯光及其方向的知识，这才有意义。总的来说，阴影既简单又复杂。带有CSM，VSM和可选的光线行进的设置并不令人感到意外，但是我确信魔鬼的细节在于如何生成和淡入所有这些细节。很少见到明显的工件，因此整个系统必须受到称赞，尤其是在开放世界的游戏中！ </p><p>  Since booting the game for the first time I had the distinct sense that most lighting is actually not in the form of analytic lights - and indeed looking at the captures this seems to not be unfounded. At the same time, there are no lightmaps, and I doubt there&#39;s anything pre-baked at all. This is perhaps one of the most fascinating parts of the rendering.</p><p>自从首次启动游戏以来，我有一种明显的感觉，即大多数照明实际上都不是以分析照明的形式出现的-实际上，从捕捉的角度来看，这似乎并非没有根据。同时，没有光照贴图，我怀疑是否有任何预先烘焙的东西。这也许是渲染中最迷人的部分之一。</p><p>    First of all, there is a very good half-res SSAO pass. This is computed right after the uber-depth-summarization pass mentioned before, and it uses the packed RGBA8 normal-roughness instead of the g-buffer one.   It looks like it&#39;s computing bent normals and aperture cones - impossible to tell the exact technique, but it&#39;s definitely doing a great job, probably something along the lines of HBAO-GTAO. First, depth, normal/roughness, and motion vectors are all downsampled to half-res. Then a pass computes current-frame AO, and subsequent ones do bilateral filtering and temporal reprojection. The dithering pattern is also quite regular if I had to guess, probably Jorge&#39;s Gradient noise?</p><p>    首先，有一个很好的半分辨率SSAO通行证。这是在前面提到的uber-depth-summary传递之后立即计算的，它使用打包的RGBA8正常粗糙度而不是g缓冲区。它看起来像是在计算弯曲的法线和光圈圆锥体-不能说出确切的技术，但它确实做得很好，可能与HBAO-GTAO相似。首先，深度，法线/粗糙度和运动矢量都被下采样到半分辨率。然后，通过计算当前帧的AO，随后的一次进行双边滤波和时间重投影。如果我不得不猜测，抖动模式也很规则，也许是豪尔赫（Jorge）的梯度噪声？</p><p> It&#39;s easy to guess that the separate diffuse-specular emitted from the lighting pass is there to make it easier to occlude both more correctly with the cone information.</p><p> 很容易猜到，从照明通道发出的单独的漫反射镜面使它更容易更正确地用视锥信息遮挡两者。</p><p>     Second, we have to look at indirect lighting. After the light clustering pass there are a bunch of draws that update a texture array of what appear to be spherically (or dual paraboloid?) unwrapped probes. Again, this is distributed across frames, not all slices of this array are updated per frame. It&#39;s not hard to see in captures that some part of the probe array gets updated with new probes, generating on the fly mipmaps, presumably GGX-prefiltered.      The source of the probe data is harder to find though, but in the main capture I&#39;m using there seems to be something that looks like a specular cubemap relighting happening, it&#39;s not obvious to me if this is a different probe from the ones in the array or the source for the array data later on.</p><p>     其次，我们必须考虑间接照明。轻聚类通过之后，将进行一堆绘制，以更新似乎是球形（或双抛物面形？）未包裹探针的纹理阵列。同样，这是跨帧分布的，并不是每个帧都更新此数组的所有切片。在捕获中不难看出，探针阵列的某些部分已被新探针更新，这些探针是在动态Mipmap上生成的，大概是GGX预过滤的。虽然很难找到探测数据的来源，但是在我使用的主要捕获中，似乎有些东西看起来像是在反射镜面反射的立方图，对于我来说，这不是很明显与阵列中的探针或阵列数据源不同的探针。</p><p> Also, it&#39;s hard to say whether or not these probes are hand placed in the level, if the relighting assumption is true, then I&#39;d imagine that the locations are fixed, and perhaps artist placed volumes or planes to define the influence area of each probe / avoid leaks.</p><p> 另外，很难说这些探针是否是手动放置在水平仪上的，如果重新照明的假设是正确的，那么我会想象这些位置是固定的，也许艺术家将体积或平面放置在定义每个探针的影响区域/避免泄漏。</p><p>     We have your &#34;standard&#34; volumetric lighting, computed in a 3d texture, with both temporal reprojection. The raymarching is clamped using the scene depth, presumably to save performance, but this, in turn, can lead to leaks and reprojection artifacts at times. Not too evident though in most cases.     Now, things get very interesting again. First, we have an is an amazing Screen-Space Reflection pass, which again uses the packed normal/roughness buffer and thus supports blurry reflections, and at least at my rendering settings, is done at full resolution.</p><p>     我们有您的＆＃34; standard＆＃34;体积照明，以3d纹理计算，具有两个时间重投影。光线行进是使用场景深度进行钳位的，大概是为了节省性能，但这反过来有时会导致泄漏和重新投影伪影。虽然在大多数情况下不太明显。现在，事情再次变得非常有趣。首先，我们有一个了不起的“屏幕空间反射”通道，它再次使用压缩的法线/粗糙度缓冲区，因此支持模糊反射，并且至少在我的渲染设置下以全分辨率完成。</p><p> It uses previous-frame color data, before UI compositing for the reflection (using motion vectors to reproject). And it&#39;s quite a lot of noise, even if it employs a blue-noise texture for dithering!</p><p> 在UI合成进行反射之前（使用运动矢量进行重新投影），它使用前一帧的颜色数据。即使它使用蓝噪声纹理来抖动，它还是有很多噪音！ </p><p>     Then, a indirect diffuse/ambient GI. Binds the g-buffer and a bunch of 64x64x64 volume textures that are hard to decode. From the inputs and outputs one can guess the volume is centered around the camera and contains indices to some sort of computed irradiance, maybe spherical harmonics or such.   The lighting is very soft/low-frequency and indirect shadows are not really visible in this pass. This might even by dynamic GI!</p><p>然后是间接的扩散/环境GI。绑定g缓冲区和一堆难以解码的64x64x64卷纹理。从输入和输出中，您可以推测出该体积是在相机周围居中并包含某种计算辐照度的索引，例如球形谐波等。光照非常柔和/低频，在此过程中间接阴影并不真正可见。这甚至可以通过动态GI实现！</p><p> Certainly is volumetric, which has the advantage of being &#34;uniform&#34; across all objects, moving or not, and this coherence shows in the final game.</p><p> 当然是体积的，它的优点是“均匀”。跨越所有对象（无论是否移动），这种连贯性在最终游戏中得以体现。</p><p>    And finally, everything gets composited together: specular probes, SSR, SSAO, diffuse GI, analytic lighting. This pass emits again two buffers, one which seems to be final lighting, and a second with what appears to be only the specular parts.  And here is where we can see what I said at the beginning. Most lighting is not from analytic lights! We don&#39;t see the usual tricks of the trade, with a lot of &#34;fill&#34; lights added by artists (albeit the light design is definitely very careful), instead indirect lighting is what makes most of the scene. This indirect lighting is not as &#34;precise&#34; as engines that rely more heavily on GI bakes and complicated encodings, but it is very uniform and regains high-frequency effects via the two very high-quality screen-space passes, the AO and reflection ones.</p><p>    最后，所有东西组合在一起：镜面探头，SSR，SSAO，漫射GI和分析照明。这一遍再次发出两个缓冲区，一个似乎是最终照明，而另一个则只是镜面反射。在这里，我们可以看到我一开始所说的话。大多数照明不是来自分析灯！我们看不到交易的惯用技巧，因为大量的交易填补了交易中的空白。由艺术家添加的灯光（尽管灯光设计绝对是非常谨慎的），相反，间接照明是构成场景的主要部分。这种间接照明效果不及“精确”。作为更依赖GI烘焙和复杂编码的引擎，但它非常统一，并通过两个非常高质量的屏幕空间通道（AO和反射通道）获得了高频效果。</p><p>     The screen-space passes are quite noisy, which in turn makes temporal reprojection really fundamental, and this is another extremely interesting aspect of this engine. Traditional wisdom says that reprojection does not work in games that have lots of transparent surfaces. The sci-fi worlds of Cyberpunk definitely qualify for this, but the engineers here did not get the news and made things work anyway!</p><p>     屏幕空间通道非常嘈杂，这反过来又使时间重影变得非常重要，这是此引擎另一个非常有趣的方面。传统观点认为，重投影在具有很多透明表面的游戏中不起作用。赛博朋克的科幻世界绝对有资格满足此要求，但是这里的工程师们没有得到消息，反正一切正常！</p><p> And yes, sometimes it&#39;s possible to see reprojection artifact, and the entire shading can have a bit of &#34;swimming&#34; in motion, but in general, it&#39;s solid and coherent, qualities that even many engines using lightmaps cannot claim to have. Light leaks are not common, silhouettes are usually well shaded, properly occluded.</p><p> 是的，有时可能会看到重投影伪像，并且整个阴影可能会有一些“游泳”的现象。在运动中，但总的来说，它具有连贯的，连贯的特质，甚至许多使用光照贴图的引擎也无法声称具有。漏光并不常见，轮廓通常阴影良好，遮挡适当。</p><p>  There are lots of other effects in the engine we won&#39;t cover - for brevity and to keep my sanity. Hair is very interesting, appearing to render multiple depth slices and inject itself partially in the g-buffer with some pre-lighting and weird normal (fake anisotropic?) effect. Translucency/skin shading is surely another important effect I won&#39;t dissect.</p><p>  为了简洁并保持理智，我们将不介绍引擎中的许多其他影响。头发非常有趣，看起来可以渲染多个深度切片，并将自身部分注入g缓冲区中，并具有一些预照明和怪异的法线（假各向异性）效果。半透明/皮肤阴影无疑是我不会剖析的另一个重要效果。</p><p>   Before the frame is over though, we have to mention transparencies - as more magic is going on here for sure. First, there is a pass that seems to compute a light chart, I think for all transparencies, not just particles.</p><p>   在框架结束之前，我们必须提到透明胶片-肯定会在这里进行更多的魔术操作。首先，我认为有一张通行证似乎可以计算出光明图表，我认为对于所有透明胶片，不仅是粒子。 </p><p> Glass can blur whatever is behind them, and this is done with a specialized pass, first rendering transparent geometry in a buffer that accumulates the blur amount, then a series of compute shaders end up creating three mips of the screen, and finally everything is composited back in the scene.</p><p>Glass可以模糊其背后的任何内容，这需要通过专门的遍历才能完成，首先在缓冲区中渲染透明的几何体，以累积模糊量，然后一系列计算着色器最终创建三个mips屏幕，最后将所有内容合成回到现场。</p><p>    After the &#34;glass blur&#34;, transparencies are rendered again, together with particles, using the lighting information computed in the chart. At least at my rendering settings, everything here is done at full resolution.      Finally, the all-mighty temporal reprojection. I would really like to see the game without this, the difference before and after the temporal reprojection is quite amazing. There is some sort of dilated mask magic going on, but to be honest, I can&#39;t see anything too bizarre going on, it&#39;s astonishing how well it works.   Perhaps there are some very complicated secret recipes lurking somewhere in the shaders or beyond my ability to understand the capture.</p><p>    在“玻璃模糊”之后，使用图表中计算的照明信息再次将透明胶片与粒子一起渲染。至少在我的渲染设置下，此处的所有操作均以全分辨率完成。最后，全能的时间投影。我真的很想看看没有此功能的游戏，时间重投影前后的差异非常惊人。发生了某种膨胀的面具魔术，但是老实说，我看不到任何奇怪的事情在发生，这真是令人惊讶。也许有一些非常复杂的秘密配方潜伏在着色器中某处，或者超出了我理解捕捉的能力。</p><p>       I wrote &#34;finally&#34; because I won&#39;t look further, i.e. the details of the post-effect stack, things here are not too surprising. Bloom is a big part of it, of course, almost adding another layer of indirect lighting, and it&#39;s top-notch as expected, stable, and wide.    Depth of field, of course, tone-mapping and auto-exposure... There are of course all the image-degradation fixings you&#39;d expect and probably want to disable: film grain, lens flares, motion blur, chromatic aberration... Even the UI compositing is non-trivial, all done in compute, but who has the time... Now that I got all this off my chest, I can finally try to go and enjoy the game! Bye!</p><p>       我最后写了因为我不会进一步看，即后效果堆栈的细节，所以这里的内容并不令人惊讶。当然，Bloom占了很大一部分，几乎增加了另一层间接照明，它是预期中的，稳定且宽广的顶级产品。景深，当然是色调映射和自动曝光...当然，您可能希望并且可能要禁用所有的图像退化修正：胶片颗粒，镜头光晕，运动模糊，色差...甚至UI合成也不是一件容易的事，所有事情都是在计算上完成的，但是谁有时间...既然我已经掌握了所有这些知识，那么我终于可以尝试玩游戏了！再见！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://c0de517e.blogspot.com/2020/12/hallucinations-re-rendering-of.html">http://c0de517e.blogspot.com/2020/12/hallucinations-re-rendering-of.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/赛博/">#赛博</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rendering/">#rendering</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>