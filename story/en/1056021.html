<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在postgreSQL中设置流复制 Setting up Streaming replication in PostgreSQL</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Setting up Streaming replication in PostgreSQL<br/>在postgreSQL中设置流复制 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-04 06:48:13</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/49c0a87eefb656e23ab769682171ad81.png"><img src="http://img2.diglog.com/img/2021/4/49c0a87eefb656e23ab769682171ad81.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>While migrating to PostgreSQL, some of the users may be curious about the type of replication offered by PostgreSQL. Some might want to know if they have to pay any additional enterprise license in order to achieve this requirement. This is because, a few commercial databases require a customer to take an enteprise license to setup replication. But, PostgreSQL, like advanced Open Source databases, automatically offers several types of replication methods built-in. This means, we never have to consider taking any additional license or an enterprise solution and stay away from vendor lock-in while using PostgreSQL. In this Article, we shall discuss the streaming replication internals and also see the detailed steps involved in setting up Streaming Replication in PostgreSQL 13.</p><p>在迁移到PostgreSQL时，一些用户可能很好奇PostgreSQL提供的复制类型。有些人可能想知道他们是否必须支付任何额外的企业许可证以实现这一要求。这是因为，一些商业数据库需要客户拍摄entepise许可证来设置复制。但是，PostgreSQL（如高级开源数据库）自动提供内置多种类型的复制方法。这意味着，我们从未考虑过任何额外的许可或企业解决方案，并在使用PostgreSQL时远离供应商锁定。在本文中，我们将讨论流媒体复制内部，并查看PostgreSQL 13中设置流复制所涉及的详细步骤。</p><p>    Streaming replication may also be referred to as physical replication. One would generally hear the terms master and standby in postgres. A master is a server that accepts writes and streams changes to a standby. It can be compared with a primary database in some of the database technologies. Whereas, a standby replicates changes from a master and accepts only reads. It may be called a replica in some of the database technologies.</p><p>    流复制也可以称为物理复制。人们通常会听到Postgres中的术语主人和待机。主人是一个接受写入的服务器，并将流式传输到待机状态。它可以与一些数据库技术中的主数据库进行比较。虽然，备用备用复制来自主设备的更改，只接受读取。它可以在一些数据库技术中称为副本。</p><p>  To understand the internals of how streaming replication works, we need to start from ACID properties. The letter D in ACID means durability. Durability is said to be achieved when a relational database ensures that a committed transaction is never lost, even upon a crash. In general, anything in memory (or RAM) can be lost upon a crash but not anything on the disk.</p><p>  要了解流式复制工作原理的内部，我们需要从酸属性开始。酸中的字母D意味着耐用性。当关系数据库确保承诺的交易永远不会丢失，即使在崩溃时，也可以实现耐久性。通常，内存（或RAM）中的任何东西都可以丢失在崩溃时，但在磁盘上没有任何内容。</p><p> Considering this fact, there exists a background utility process in PostgreSQL called WAL Writer that continuously writes the WAL records from memory to WAL (Write-Ahead logs) segments on the disk.  The backend may also flush the WAL buffers to WAL segments. What this means is that a transaction is said to be successful only when it is written to a WAL segment on the disk. Of course, this default behavior can always be altered.</p><p> 考虑到这一事实，PostgreSQL中存在后台实用程序进程，称为WAL Worker，其连续将WAL记录从内存写入磁盘上的WAL（注册日志）段。后端也可以将WAL缓冲区刷新到WAL段。这意味着只有在将其写入磁盘上的WAL段时，才会才能成功进行交易。当然，始终可以更改此默认行为。</p><p> In the following Streaming Replication Architecture diagram, we see an example of how some blocks/buffers have become dirty blocks because of an UPDATE statement. Dirty buffers or dirty blocks are the modified buffers due to the changes to the tuples (or records) in that block.</p><p> 在以下Streaming Replication架构图中，我们会看到由于更新语句，某些块/缓冲区已成为脏块的示例。由于该块中的元组（或记录）的变化，脏缓冲区或脏块是修改缓冲区。</p><p> As seen in the Streaming Replication Architecture diagram above, A WAL segment contains WAL records that include the changes done to data blocks (in the form of DML or DDL).</p><p> 如上面的Streaming Replication架构图所示，WAL段包含包含对数据块（以DML或DDL的形式）所做的更改的沃尔记录。</p><p> When we setup streaming replication, a new background process called WAL sender is started on the master. This process accepts requests from a standby and streams the WAL records continuously to its standby. Similarly, a background process called WAL receiver is started on the standby, that receives and applies these changes. More internals on Streaming Replication protocol can be seen here.</p><p> 当我们设置流复制时，在主站上启动名为Wal Sender的新后台进程。此过程接受来自备用备用的请求，并将WAL记录持续向其备用流。类似地，在待机上启动名为WAL接收器的后台过程，其接收并应用这些更改。这里可以看到更多关于流复制协议的内部结构。 </p><p>   Step 1 :  Create a replication user who has a replication role.  (Step to be executed on the master)</p><p>步骤1：创建具有复制角色的复制用户。 （在主人身上执行的步骤）</p><p>  Step 2 :  Allow the standby’s replication user to connect to the Primary. See this documentation on  pg_hba.conf more details.  (Step to be executed on the master)</p><p>  步骤2：允许备用的Replication用户连接到主要。请参阅pg_hba.conf的文档更多详细信息。 （在主人身上执行的步骤）</p><p>  Replace 192.169.12.1 with the IP address of the standby that should be allowed to make replication connections to the master.</p><p>  替换192.169.12.1与待机的IP地址允许允许复制连接到主设备。</p><p> Step 3 :  Perform a reload to get the changes into effect.  (Step to be executed on the master)</p><p> 第3步：执行重新加载以使变化生效。 （在主人身上执行的步骤）</p><p>  Step 4 :  Following are the list of configuration parameters that enable us to perform a robust replication setup for production databases. (Step to be executed on the master)</p><p>  步骤4：以下是配置参数列表，使我们能够为生产数据库执行强大的Replication Setup。 （在主人身上执行的步骤）</p><p> Please Note : Some of these parameters are not mandatory for streaming replication but only for a good setup.</p><p> 请注意：其中一些参数不是用于流式复制的强制性，但仅用于良好的设置。</p><p> max_wal_senders : Number of WAL sender processes that can be started on the master. One for each replica. pg_basebackup may use one or 2 Wal senders which will be discussed later in a separate blog post. max_wal_senders generally defaults to 10 on all distributions. So, this parameter need not be modified unless we set up more than 5 standby to a master.</p><p> max_wal_senders：可以在主设备上启动的WAL发件人进程数。每个复制品一个。 PG_BASEBACKUP可以使用一个或2个WAL发件人，这将在单独的博客文章中稍后讨论。 MAX_WAL_SENDERS通常默认为所有分布到10。因此，除非我们将超过5个待机到主站设置超过5个待机，否则不需要修改此参数。 </p><p>  listen_addresses : This parameter determines the IP interfaces through which the connections are allowed. It defaults to localhost. It may be set to the public or a private IP interface or through everything using (*).</p><p>listent_addresses：此参数确定允许连接的IP接口。它默认为localhost。它可以设置为公共IP接口或使用（*）的所有内容。</p><p>  archive_mode : This parameter must be set to ‘ON’ to enable archiving. When archiving is enabled, the WAL segments are copied to the archive location, before getting recycled.    (archive_mode is not a mandatory parameter but suggested for production databases)</p><p>  archive_mode：必须将此参数设置为“on”以启用存档。启用归档后，将在回收之前将WAL段复制到存档位置。 （archive_mode不是必需参数，但建议生产数据库）</p><p>  archive_command : The shell command or a script using which the archiver should perform archiving of a full WAL segment. Following is an example setting that uses the   cp command in linux.     For example,</p><p>  archive_command：shell命令或归档者应执行全WAL段的存档的脚本。以下是使用Linux中的CP命令的示例设置。例如，</p><p>  %p is substituted by postgres with the path to the actual WAL segment.   %f  is substituted by postgres with the WAL file name.</p><p>  ％P由Postgres代替与实际WAL段的路径。 ％F用WAL文件名代替postgres。</p><p> (archive_command is not a mandatory parameter but suggested for production databases).     This parameter has no effect on standby unless archive_mode is set to ‘always’.</p><p> （archive_command不是必需参数，但建议生产数据库）。除非Archive_Mode设置为“始终”，否则此参数对待机没有影响。</p><p> restore_command : The shell command or a script using which a standby copies a WAL segment from the archive location, when the WAL segment is not available with master (when a WAL segment is recycled upon its retention on the master). This parameter has no effect on master.  This is only required on a standby or while performing a point-in-time recovery using a full backup and archives.    For example,</p><p> restore_command：shell命令或使用哪个备用备用备份从存档位置复制WAL段的脚本，当WAL段没有主机（当WAL段在其保留在主设备上时）。此参数对Master没有影响。只有在待机状态或使用完整备份和归档执行时间点恢复时才需要。例如，</p><p>  wal_keep_size : Amount of WAL segments that are to be at least retained in the pg_wal directory before getting recycled.</p><p>  wal_keep_size：在获得回收之前至少在PG_WAL目录中保留的WAL段数量。 </p><p>  wal_compression : This is not a mandatory parameter but when it is set to ‘ON’, every full page before being written to a WAL segment will be compressed. This reduces the WAL writes and saves some IOPS on the disk.</p><p>wal_compression：这不是必需参数，但是当它设置为“开”时，将压缩将其写入WAL段之前的每一个完整页面。这会减少WAL写入并保存磁盘上的一些IOPS。</p><p>  Step 5 :  Reload or restart as necessary, upon the parameter changes. (Step executed on master)</p><p>  步骤5：根据参数更改时根据需要重新加载或重新启动。 （在主站上执行的步骤）</p><p> $ psql -p 5432 -c &#34;select pg_reload_conf()&#34; $ psql -p 5432 -c &#34;select name, setting, pending_restart from pg_settings where pending_restart IS true&#34;</p><p> $ psql -p 5432 -c＆＃34;选择pg_reload_conf（）＆＃34; $ psql -p 5432 -c＆＃34;从pg_settings中选择名称，设置，pending_restart，其中pending_restart为true＆＃34;</p><p>   Step 6 :  Take a full backup of the master to create a copy of the data directory on the standby. Replace the IP address with the IP or hostname of master as applicable. (Step to be executed on the standby, if backup of the master is being taken remotely from the standby server)</p><p>   步骤6：拍摄主设备的完整备份以在备用备用备用备用内部创建数据目录的副本。用主机的IP或主机名替换为适用的IP地址。 （在待机上执行的步骤，如果从备用服务器远程拍摄主站的备份）</p><p>  -Xs : Using a separate channel/process, stream ongoing changes (WAL records) from master to standby, while the backup is in progress.</p><p>  -XS：使用单独的通道/进程，从主站到备用流的持续更改（WAL记录），而备份正在进行中。</p><p>  -c fast : This flag may be used to perform fast checkpoint and to avoid waiting until the lazy  checkpoint is completed.</p><p>  -c fast：此标志可用于执行快速检查点，并避免等待直到延迟检查点完成。</p><p> Step 7 :  Validate if the following parameters are set. Else, set them appropriately on the standby. (Validation to be performed on the standby)</p><p> 步骤7：如果设置了以下参数，则验证。否则，在待机状态下适当地设置它们。 （在待机上执行验证） </p><p> primary_conninfo : When the backup is taken with -R flag as seen in step 6, primary_conninfo parameter is automatically added to the postgresql.auto.conf file in the data directory (seen in following log). A parameter set in this file is considered by postgres over postgresql.conf or other configuration files as part of include_dir.</p><p>primary_conninfo：使用步骤6中的-R标志拍摄备份时，主_conninfo参数会自动添加到数据目录中的postgresql.auto.conf文件（在以下日志中看到）。 postgresql.conf或其他配置文件作为includ_dir的一部分，由postgres考虑在此文件中设置的参数。</p><p> $ cd $PGDATA$ grep primary_conninfo postgresql.auto.conf primary_conninfo = &#39;user=replicator password=secret channel_binding=prefer host=192.169.12.1 port=5432 sslmode=prefer sslcompression=0 ssl_min_protocol_version=TLSv1.2 gssencmode=prefer krbsrvname=postgres target_session_attrs=any&#39;</p><p> $ cd $ pgdata $ grep primary_conninfo postgresql.auto.conf primary_conninfo =＆＃39; user = replicator password = secretconal_binding = preferent host = 192.169.12.1端口= 5432 sslmode = preplet sslcomplession = 0 ssl_min_protocol_version = tlsv1.2 gssencmode = lover krbsrvname = postgres target_session_attrs =任何＆＃39;</p><p> This parameter helps standby with the connection details of its master. Standby uses the user, host, port and other details added to this configuration parameter to start streaming WAL records from its master over the streaming replication protocol.</p><p> 此参数有助于备用其主设备的连接详细信息。待机使用“添加到此配置”参数的用户，主机，端口和其他详细信息，以在Streaming Replication协议上从其主站开始流媒体记录。</p><p> restore_command : This is the command used by the standby to restore a WAL segment from the archives, when the required WAL segment was not available with its master. This generally happens when the WAL segment has not been streamed by standby but the WAL segment has been recycled by the master. We could also use  physical replication slots to avoid the master from recycling a WAL segment unless it was confirmed to be received by the standby. We need to ensure that the archive directory or server is accessible by the standby using the shell command or the script specified to the restore_command.</p><p> restore_command：这是备用备用备用备件，从档案中恢复WAL段的命令，当时所需的WAL段没有其主机。当沃尔段未被待机流留出时，这通常会发生，但沃尔段已被主人回收。我们还可以使用物理复制插槽来避免主人回收WAL段，除非被确认待机收到。我们需要确保使用shell命令或指定给RESTORE_COMMAND的脚本来访问存档目录或服务器。</p><p>  We can see more details on the above parameters in this documentation on  configuration parameters for postgres streaming replication.</p><p>  我们可以在本文档中查看关于Postgres Streaming Replication的配置参数的上述参数的更多详细信息。</p><p> Step 8 :  Create a signal file to mention that the server is a standby server. The standby.signal file must be created inside the data directory of the standby. (Step to be executed on the standby)</p><p> 步骤8：创建一个信号文件以提及服务器是备用服务器。备用备用文件必须在待机的数据目录中创建。 （在待机上执行的步骤）</p><p>  Step 9 :  Start the standby to enable replication. (Step to be executed on the standby)</p><p>  步骤9：启动备用才能启用复制。 （在待机上执行的步骤） </p><p>  Step 10 :  Validate replication between master and standby using the following command on the master. (Validation to be performed on the master)</p><p>步骤10：使用主机上的以下命令验证Master和Standby之间的复制。 （在主机上执行验证）</p><p>   $ psql -x -c &#34;select * from pg_stat_replication&#34;-[ RECORD 1 ]----+------------------------------pid | 28435usesysid | 16384usename | replicatorapplication_name | walreceiverclient_addr | 192.169.12.1client_hostname | client_port | 49806backend_start | 2021-03-31 12:39:22.876997+00backend_xmin | state | streamingsent_lsn | 0/3000148write_lsn | 0/3000148flush_lsn | 0/3000148replay_lsn | 0/3000148write_lag | 00:00:00.126533flush_lag | 00:00:00.127325replay_lag | 00:00:00.127386sync_priority | 0sync_state | asyncreply_time | 2021-03-31 12:39:23.021395+00</p><p>   $ psql -x -c＆＃34;从pg_stat_replication＆＃34中选择*;  -  [记录1] ---- + -------------------- ------- pid | 28435USSYSID | 16384Usename | replicatorapplication_name | walreceiverclient_addr | 192.169.12.1client_hostname | client_port | 49806Backend_start | 2021-03-31 12：39：22.876997 + 00 Backend_xmin |国家| Streamingsent_lsn | 0 / 3000148WRITE_LSN | 0 / 3000148FLUSH_LSN | 0 / 3000148REPLAY_LSN | 0 / 3000148WRITE_LAG | 00：00：00：00.126533FLUSH_LAG | 00：00：00：00.127325RAPLE_LAG | 00：00：00.127386Sync_priority | 0sync_state | asyncreply_time | 2021-03-31 12：39：23.021395 + 00</p><p> So far, we have seen the steps involved in setting up Streaming Replication in PostgreSQL 13. In our future blogs, we shall see how to set up Synchronous replication and also see how we can perform a failover and a rewind of the demoted master to add it back to replication from the new master. Subscribe to our blog posts to stay up-do-date.    Contact us  to know more about how we can help you tune and set up a robust PostgreSQL production environment to help you    migrate to PostgreSQL .</p><p> 到目前为止，我们已经看到了在PostgreSQL 13中建立流复制所涉及的步骤。在我们未来的博客中，我们将看到如何设置同步复制，并了解我们如何执行故障转移和倒带的Demoted Master的倒带以添加它返回新大师的复制。订阅我们的博客文章，以保持最新的日期。联系我们了解更多信息如何帮助您调整和设置强大的PostgreSQL生产环境，以帮助您迁移到PostgreSQL。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.migops.com/blog/2021/03/31/setting-up-streaming-replication-in-postgresql-13-and-streaming-replication-internals">https://www.migops.com/blog/2021/03/31/setting-up-streaming-replication-in-postgresql-13-and-streaming-replication-internals</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设置/">#设置</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/streaming/">#streaming</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/wal/">#wal</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>