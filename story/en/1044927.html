<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>嵌入式YouTube播放器告诉我您正在看什么 The Embedded YouTube Player Told Me What You Were Watching</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Embedded YouTube Player Told Me What You Were Watching<br/>嵌入式YouTube播放器告诉我您正在看什么 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-19 02:00:40</div><div class="page_narrow text-break page_content"><p>2019, October 11, 00:16:  I finish the cold frozen pizza that I made hours before but forgot to eat, finally write the report, press submit on the Google security bug submission form, and see the classic,  Thanks! We received your report. message. That feeling is hard to beat.</p><p>2019年10月11日，00：16：我完成了几个小时前做的但没吃的冷冻比萨饼，最后写了报告，在Google安全漏洞提交表上按提交，然后看看经典的，谢谢！我们收到了您的报告。信息。这种感觉很难被击败。</p><p> I just submitted a bug, using which, I could simply send a link to someone, and when they click on it and visit my website, I could  steal their YouTube watch history, the  links to watch all of their unlisted videos, their  Watch Later playlist, the list of  videos they’ve liked, and more. It was pretty damn cool.</p><p> 我只是提交了一个错误，使用该错误，我可以简单地向某人发送链接，当他们单击该链接并访问我的网站时，我可以窃取他们的YouTube观看记录，观看他们所有未公开视频的链接，他们的稍后观看播放列表，他们喜欢的视频列表等等。真是太酷了。</p><p>    This issue requires a little bit of understanding about the inner-workings of YouTube. Most importantly, about these four interesting playlists:</p><p>    这个问题需要对YouTube的内部运作有一点了解。最重要的是，关于以下四个有趣的播放列表：</p><p> Since YouTube is made up of videos, a bunch of internal stuff in YouTube is made up of  playlists. Everybody has a few of them, even if they have never created one. I knew about these from previous research I have done ( by previous research, I just mean trying every feature and trying to understand how they work), before finding this bug. Let’s look at these playlists one-by-one because they will be important later.</p><p> 由于YouTube由视频组成，因此YouTube中的许多内部内容都由播放列表组成。每个人都有几个，即使他们从未创造过一个。在发现此错误之前，我已经从以前的研究中了解了这些信息（通过先前的研究，我只是意味着尝试每个功能并试图理解它们的工作原理）。让我们一一看一下这些播放列表，因为它们在以后会变得很重要。</p><p>  At the time of finding this bug, every YouTube user had a playlist with the ID  HL, which stands for “History List” (I assume). This list contained every video you previously watched on YouTube.</p><p>  发现此错误时，每个YouTube用户都有一个ID为HL的播放列表，它代表“历史记录列表”（我假设）。此列表包含您以前在YouTube上观看的每个视频。</p><p>  You have probably seen the little  clock icon everywhere on YouTube, which when pressed, adds the video to your “Watch Later”. This is also just a special playlist internally, with the ID  WL.</p><p>  您可能已经在YouTube上到处看到小时钟图标，按下该按钮会将视频添加到“稍后观看”中。这也是内部带有ID WL的特殊播放列表。</p><p>  This is a tricky one. At the time of finding the bug, I was a bit confused about how this works, so I had to use a little bit of guessing. All I knew, that it was constructed by somehow modifying your channel ID, which is a 24 char long string, and can be found by going to your channel page, and looking at the URL:</p><p>  这是一个棘手的问题。在发现错误时，我对它的工作方式有些困惑，因此我不得不多做一些猜测。我所知道的是，它是通过某种方式修改您的频道ID（长度为24个字符）构成的，可以通过进入频道页面并查看URL来找到它： </p><p>  After a bit of trial and error, and by looking at the playlists of my testing/personal accounts, I figured out a way to “guess” the special “Liked Videos” playlist. You just had to replace the first 3 characters of the channel ID with  LLD or  LLB:</p><p>经过一番尝试和错误之后，通过查看测试/个人帐户的播放列表，我找到了一种“猜测”特殊“喜欢的视频”播放列表的方法。您只需要用LLD或LLB替换频道ID的前三个字符：</p><p> // one of them will be the “Liked Videos” playlist of the given channel “ UCBvX9uEO0a3fZNCK12MAgug ”  -&gt;  “ LLDvX9uEO0a3fZNCK12MAgug ” “ UCBvX9uEO0a3fZNCK12MAgug ”  -&gt;  ” LLBvX9uEO0a3fZNCK12MAgug ”</p><p> //其中之一将是给定频道“ UCBvX9uEO0a3fZNCK12MAgug”的“喜欢的视频”播放列表-＆gt; “ LLDvX9uEO0a3fZNCK12MAgug”“ UCBvX9uEO0a3fZNCK12MAgug”-＆gt; ” LLBvX9uEO0a3fZNCK12MAgug”</p><p>  This special playlist contains  all of your videos. It has everything in it, regardless of the video’s privacy setting. So all  Public,  Unlisted and  Private videos you have ever uploaded, are in your special “Uploads” playlist.</p><p>  这个特殊的播放列表包含您所有的视频。无论视频的隐私设置如何，它都应有尽有。因此，您上载的所有公开，不公开和私有视频都在您的特殊“上传”播放列表中。</p><p> At the time of finding the bug, the same guessing thing had to be used as for the “Liked Videos” playlist, but this time first 3 characters of the channel ID had to be  UUD or  UUB:</p><p> 发现错误时，必须使用与“喜欢的视频”播放列表相同的猜测，但是这次，频道ID的前3个字符必须为UUD或UUB：</p><p> // one of them will be the “Uploads” playlist of the given channel “ UCBvX9uEO0a3fZNCK12MAgug ”  -&gt;  “ UUDvX9uEO0a3fZNCK12MAgug ” “ UCBvX9uEO0a3fZNCK12MAgug ”  -&gt;  ” UUBvX9uEO0a3fZNCK12MAgug ”</p><p> //其中之一将是给定频道“ UCBvX9uEO0a3fZNCK12MAgug”的“上传”播放列表-＆gt; “ UUDvX9uEO0a3fZNCK12MAgug”“ UCBvX9uEO0a3fZNCK12MAgug”-＆gt; ” UUBvX9uEO0a3fZNCK12MAgug”</p><p> Or, if you don’t want to do any of that, you can just go to the channel’s page, click the  Videos tab, and click  Play All. But only if that button is visible, which is unfortunately not always the case.</p><p> 或者，如果您不想执行任何操作，则可以转到频道页面，单击“视频”标签，然后单击“全部播放”。但是仅当该按钮可见时，不幸的是并非总是如此。</p><p> If you are interested in the details about how these playlists have changed since 2019, and how they work today at the time of writing this post, you can check out  this Gist I made.</p><p> 如果您对这些播放列表自2019年以来如何变化以及它们在撰写本文时的今天的工作方式方面的细节感兴趣，可以查看我撰写的这份Gist。 </p><p> So now you know about these special playlists every YouTube user has. Now, you might think that we should just open for example someone’s “Uploads” playlist like you would open any other playlist, and simply leak all of their unlisted videos:</p><p>现在，您了解了每个YouTube用户拥有的这些特殊播放列表。现在，您可能会认为我们应该像打开其他任何播放列表一样打开某人的“上传”播放列表，而只是泄漏他们所有未列出的视频：</p><p>  Unfortunately, it’s not that easy. These playlists are special in another way too, which is that  different users will see different videos in them. If the channel owner opens his/her “Uploads” playlist, she will see all of her videos, regardless of the privacy setting. If an attacker tries to open the victim’s “Uploads” playlist,  only the  Public videos will be shown, any other  Unlisted and  Private videos the victim has will just not be there.</p><p>  不幸的是，这并不容易。这些播放列表也有另一种特殊之处，那就是不同的用户会在其中看到不同的视频。如果频道所有者打开他/她的“上传”播放列表，则无论隐私设置如何，她都将看到她的所有视频。如果攻击者试图打开受害者的“上传”播放列表，则只会显示“公开”视频，而受害者没有看到的其他任何“不公开”和“私有”视频。</p><p> As an attacker, we can clearly see that these playlists can contain very sensitive information about the users. We would like to steal these. But unfortunately, they seem to be well protected…</p><p> 作为攻击者，我们可以清楚地看到这些播放列表可能包含有关用户的非常敏感的信息。我们想偷这些。但不幸的是，它们似乎受到了良好的保护……</p><p>  If you have a website and want to have a little YouTube player inside it, there is an app for that. And it’s called the  YouTube IFrame Player. Embedding this player into your website is quite easy, you just have to copy some HTML code with an  iframe tag, and paste it into your site’s source:</p><p>  如果您有一个网站，并希望其中包含一个小型YouTube播放器，那么可以使用一个应用程序。它被称为YouTube IFrame Player。将此播放器嵌入您的网站非常容易，您只需复制带有iframe标签的HTML代码，然后将其粘贴到您网站的源代码中：</p><p>  But today websites are rarely that simple, so you might wonder, what if I want to dynamically create a YouTube player with JavaScript? What if I want to automatically pause the video? These problems would seem quite hacky, or even impossible in some cases, due to the rules of the  Same-origin Policy, and other protections modern browsers provide.</p><p>  但是如今的网站很少这么简单，所以您可能想知道，如果我想使用JavaScript动态创建YouTube播放器怎么办？如果我想自动暂停视频怎么办？由于同源策略的规则以及现代浏览器提供的其他保护，这些问题似乎非常棘手，甚至在某些情况下甚至是不可能的。</p><p> Thankfully, YouTube has a solution for this as well, the  YouTube Player API. This API allows you to just add a JS library to your site, and then simply create/modify/control the YouTube players on your site however you’d like, using JavaScript. For example, if you want to pause a video, you can just call  player.pauseVideo().</p><p> 值得庆幸的是，YouTube还有一个解决方案，即YouTube Player API。使用此API，您只需将JS库添加到您的网站，然后就可以使用JavaScript在您想要的网站上随意创建/修改/控制YouTube播放器。例如，如果要暂停视频，则可以仅调用player.pauseVideo（）。</p><p> Hm.. This is pretty interesting, but how does it work? The answer might be obvious if you have previously worked with cross-origin (iframe) communication. The YouTube player uses the browser’s  PostMessage API, which allows different origins (in our case your site and the YouTube iframe), to send each other little messages over a secure channel. So the YouTube player has a  postMessage listener where it listens to commands, and the JS library you put into your site sends messages to it when you want to perform some action, like pausing the video. Actually, the YouTube player is talking a lot, even if you don’t ask it anything. It immediately tells the JS library on your site if anything happens with the player. This makes it possible for your site to add event listeners, which get called when for example the user skips into a currently playing video.</p><p> 嗯..这很有趣，但是它如何工作？如果您以前使用跨域（iframe）通信，则答案可能很明显。 YouTube播放器使用浏览器的PostMessage API，该API允许不同的来源（在我们的情况下为您的网站和YouTube iframe）通过安全通道互相发送小消息。因此，YouTube播放器具有一个postMessage侦听器，可在其中侦听命令，并且您要执行一些操作（如暂停视频）时，放入站点的JS库会向其发送消息。实际上，即使您什么都没问，YouTube播放器都会说话很多。如果播放器发生任何变化，它会立即告诉您站点上的JS库。这使您的站点可以添加事件侦听器，例如当用户跳入当前正在播放的视频时会被调用。 </p><p> Let’s see a quick example of how this communication works under the hood:</p><p>让我们看一个简单的例子，说明这种交流是如何进行的：</p><p> // this postMessage is sent from your site to the iframe under the hood when you call “player.playVideo()” -&gt;   { &#34; event &#34; : &#34; command &#34; , &#34; func &#34; : &#34; playVideo &#34; , &#34; args &#34; :[], &#34; id &#34; : 1 , &#34; channel &#34; : &#34; widget &#34; } // the iframe sends a lot of stuff back, here are some examples &lt;-  { &#34; event &#34; : &#34; infoDelivery &#34; , &#34; info &#34; :{ &#34; playerState &#34; : - 1 , &#34; currentTime &#34; : 0 , &#34; duration &#34; : 1344 , &#34; videoData &#34; :{ &#34; video_id &#34; : &#34; M7lc1UVf-VE &#34; , &#34; author &#34; : &#34;&#34; , &#34; title &#34; : &#34; YouTube Developers Live: Embedded Web Player Customization &#34; }, &#34; videoStartBytes &#34; : 0 , &#34; videoBytesTotal &#34; : 1 , &#34; videoLoadedFraction &#34; : 0 , &#34; playbackQuality &#34; : &#34; unknown &#34; , &#34; availableQualityLevels &#34; :[], &#34; currentTimeLastUpdated_ &#34; : 1610191891.79 , &#34; playbackRate &#34; : 1 , &#34; mediaReferenceTime &#34; : 0 , &#34; videoUrl &#34; : &#34; https://www.youtube.com/watch?v=M7lc1UVf-VE &#34; , &#34; playlist &#34; : null , &#34; playlistIndex &#34; : - 1 }, &#34; id &#34; : 1 , &#34; channel &#34; : &#34; widget &#34; } &lt;-  { &#34; event &#34; : &#34; onStateChange &#34; , &#34; info &#34; : - 1 , &#34; id &#34; : 1 , &#34; channel &#34; : &#34; widget &#34; }</p><p> //当您调用“ player.playVideo（）”时，此postMessage从您的网站发送到引擎盖下的iframe-> {＆＃34;事件＆＃34; ：＆＃34;命令＆＃34; ，＆＃34; func＆＃34; ：＆＃34; playVideo＆＃34; ，＆＃34; args＆＃34; ：[]，＆＃34; ID＆＃34; ：1，＆＃34;频道＆＃34; ：＆＃34;小部件＆＃34; } // iframe传回了很多东西，下面是一些示例＆lt;-{＆＃34;事件＆＃34; ：＆＃34; infoDelivery＆＃34; ，＆＃34;信息＆＃34; ：{＆＃34; playerState＆＃34; ：-1，＆＃34;当前时间＆＃34; ：0，＆＃34;持续时间＆＃34; ：1344，＆＃34; videoData＆＃34; ：{＆＃34; video_id＆＃34; ：＆＃34; M7lc1UVf-VE＆＃34; ，＆＃34;作者＆＃34; ：＆＃34;＆＃34; ，＆＃34;标题＆＃34; ：＆＃34; YouTube Developers Live：嵌入式Web Player自定义＆＃34; }，＆＃34; videoStartBytes＆＃34; ：0，＆＃34; videoBytesTotal＆＃34; ：1，＆＃34; videoLoadedFraction＆＃34; ：0，＆＃34;播放质量＆＃34; ：＆＃34;未知＆＃34; ，＆＃34; availableQualityLevels＆＃34; ：[]，＆＃34; currentTimeLastUpdated_＆＃34; ：1610191891.79，＆＃34;播放率＆＃34; ：1，＆＃34; mediaReferenceTime＆＃34; ：0，＆＃34; videoUrl＆＃34; ：＆＃34; https://www.youtube.com/watch?v=M7lc1UVf-VE＆＃34; ，＆＃34;播放列表＆＃34; ：null，＆＃34;播放列表索引＆＃34; ：-1}，＆＃34; ID＆＃34; ：1，＆＃34;频道＆＃34; ：＆＃34;小部件＆＃34; }＆lt;-{＆＃34;事件＆＃34; ：＆＃34; onStateChange＆＃34; ，＆＃34;信息＆＃34; ：-1，＆＃34; ID＆＃34; ：1，＆＃34;频道＆＃34; ：＆＃34;小部件＆＃34; }</p><p> Just a reminder, I was often confused about this, but the “under-the-hood” commands I just showed an example of are sent  by your site. By “under-the-hood”, I just mean that developers usually include YouTube’s library, to make communication easier, and that library simply abstracts the details away, so you can just call  pauseVideo(), without worrying about anything else. But of course, if you would want, you could manually send these  postMessages to the player, via plain old vanilla JavaScript, and it would work in the exact same way as using the fancy JS library. So just think of it as an abstraction layer, which you have full control of.</p><p> 提醒一下，我对此经常感到困惑，但是我刚刚展示的“幕后”命令是由您的站点发送的。所谓“幕后”，是指开发人员通常包括YouTube的库，以便于交流，而该库只是将细节抽象出来，因此您可以调用pauseVideo（）而不用担心其他任何问题。但是，当然，如果愿意，您可以通过普通的旧式JavaScript将这些postMessage手动发送到播放器，并且其工作方式与使用高级JS库的方式完全相同。因此，可以将其视为完全控制的抽象层。</p><p> If you want to see what  postMessages a page receives, you could just add an event listener to the page which prints every message to the console:</p><p> 如果要查看页面收到的postMessages，可以将事件侦听器添加到页面，该事件侦听器将每条消息打印到控制台：</p><p> // listen for all “message” events and log them to the console: &gt;  window . addEventListener ( &#34; message &#34; ,  function ( event ){ console . log ( event . data )})</p><p> //侦听所有“消息”事件并将其记录到控制台：＆gt;窗口。 addEventListener（＆＃34;消息＆＃34 ;，函数（事件）{控制台。日志（事件。数据）}）</p><p> Okay, so we can play and pause the player with JavaScript. That’s nothing crazy, but it’s cool. Is there anything else we can do? Yes, there is. Actually, if you read the documentation, there is a bunch of stuff we can do using this Player API. Let’s see some of them that might look interesting to us:</p><p> 好的，我们可以使用JavaScript播放和暂停播放器。没什么疯狂的，但是很酷。我们还有什么可以做的吗？就在这里。实际上，如果您阅读了文档，则可以使用Player Player做很多事情。让我们来看一些对我们来说可能有趣的东西：</p><p>  If you want to embed a playlist into your site, you can use the  player.loadPlaylist(playlist_id) method of the library to load a playlist into an existing embedded player. After this, you could call  playVideo(), and start playing the first video, after which, the next one from the playlist will automatically start playing, and so on. So we have playlist support.</p><p>  如果要将播放列表嵌入到站点中，则可以使用库的player.loadPlaylist（playlist_id）方法将播放列表加载到现有的嵌入式播放器中。之后，您可以调用playVideo（），并开始播放第一个视频，然后，播放列表中的下一个视频将自动开始播放，依此类推。因此，我们有播放列表支持。 </p><p> Now, what if you want to embed a playlist into your site, but want to know what videos are in it? There is a  function for that as well. Calling  player.getPlaylist(), on a player that has a playlist currently loaded, will return  an array of the video IDs in the playlist as they are currently ordered:</p><p>现在，如果您想将播放列表嵌入网站，又想知道其中包含哪些视频，该怎么办？也有一个功能。在当前已加载播放列表的播放器上调用player.getPlaylist（），将按当前顺序返回播放列表中的视频ID数组：</p><p> &gt;  player . getPlaylist () Array ( 20 )  [  &#34; KxgcVAuem8g &#34; ,  &#34; U_OirTVxiFE &#34; ,  &#34; rbez_1MEhdQ &#34; ,  &#34; VpC9qeKUJ00 &#34; ,  &#34; LnDjm9jhkoc &#34; ,  &#34; BQIOEdkivao &#34; ,  &#34; layKyzA1ABc &#34; ,  &#34; -Y9gdQnt7zs &#34; ,  &#34; U_OX5vQ567Y &#34; ,  &#34; ghOqpVet1uQ &#34; ,  …  ]</p><p> ＆gt;播放器。 getPlaylist（）数组（20）[＆＃34; KxgcVAuem8g＆＃34; ，＆＃34; U_OirTVxiFE＆＃34; ，＆＃34; rbez_1MEhdQ＆＃34; ，＆＃34; VpC9qeKUJ00＆＃34; ，＆＃34; LnDjm9jhkoc＆＃34; ，＆＃34; BQIOEdkivao＆＃34; ，＆＃34; layKyzA1ABc＆＃34; ，＆＃34; -Y9gdQnt7zs＆＃34; ，＆＃34; U_OX5vQ567Y＆＃34; ，＆＃34; ghOqpVet1uQ＆＃34; ，…]</p><p>   If you look at the raw  postMessage communication, often you can see an object named  videoData being sent by the iframe to the page. This object contains a bunch of stuff about the currently playing video, including its title.</p><p>   如果查看原始的postMessage通信，通常可以看到iframe将一个名为videoData的对象发送到页面。该对象包含一堆有关当前播放的视频的内容，包括其标题。</p><p> &gt;  player . getVideoData () Object  {  video_id :  &#34; KxgcVAuem8g &#34; ,  author :  &#34; LiveOverflow2 &#34; ,  title :  &#34; Astable 555 timer - Clock Module &#34; ,  video_quality :  &#34; medium &#34; ,  video_quality_features :  [],  list :  &#34; PLGPckJAmiZCTyI72iI2KaJxkp-vUKBlTi &#34;  }</p><p> ＆gt;播放器。 getVideoData（）对象{video_id：＆＃34; KxgcVAuem8g＆＃34; ，作者：＆＃34; LiveOverflow2＆＃34; ，标题：＆＃34;不稳定555计时器-时钟模块＆＃34; ，video_quality：＆＃34;中＆＃34; ，video_quality_features：[]，列表：＆＃34; PLGPckJAmiZCTyI72iI2KaJxkp-vUKBlTi＆＃34; }</p><p> This function is not listed in the official YouTube documentation, supposedly it got removed a few years ago, but as a fellow Stack Overflow member  pointed out:</p><p> 此功能未在YouTube的官方文档中列出，据说几年前已被删除，但正如Stack Overflow的一位同僚指出：</p><p>  (Even if the  getVideoData() function would be fully removed from the library, as I said before, as long as the iframe sends that object to your page, you could access it.)</p><p>  （即使正如我之前所说，即使将getVideoData（）函数从库中完全删除了，只要iframe将对象发送到您的页面，您也可以访问它。）</p><p>   If you are logged in to YouTube, the embedded player is also “logged in”. Videos you watch in the player will get added to your Watch History. There is always a little  clock icon in the player using which you can add the video to your account’s watch later. So, we could say that if you are logged in to YouTube, the player is also logged in, and it has “full-access” to your account, just like the main YouTube site has.</p><p>   如果您登录到YouTube，则嵌入式播放器也将“登录”。您在播放器中观看的视频将被添加到您的观看记录中。播放器中总是有一个小时钟图标，您可以使用它在以后将视频添加到帐户的手表中。因此，可以说，如果您已登录YouTube，则播放器也会登录，并且您的帐户具有“完全访问权”，就像YouTube的主要网站一样。 </p><p>  I really like this bug because of how it didn’t need any fancy “hacking techniques”. Actually, I wasn’t even at a computer when I found this bug, so to say..</p><p>我真的很喜欢这个错误，因为它不需要任何花哨的“黑客技术”。可以这么说，实际上，当我发现此错误时，我甚至都没有在计算机上。</p><p> You might already put the two things together, and also found the bug, just by reading the first two chapters of this writeup.</p><p> 仅通过阅读本文的前两章，您可能已经将这两件事放在一起，并且还发现了错误。</p><p> At the time, I was looking at YouTube for a while already, testing the playlists separately, and later, testing the embedded player. I wasn’t able to find any bugs. Then, one day, I remember, I was standing on a tram, probably on my way to school, (probably late, as always  :( ), and I had this idea:</p><p> 当时，我已经看过YouTube一段时间了，分别测试播放列表，然后再测试嵌入式播放器。我找不到任何错误。然后，有一天，我记得我当时正站在电车上，可能正在去学校的路上（可能一如既往地晚了:(），我有了这个主意：</p><p> “Wait a second. Only the owner can see her playlist’s contents. I have the tools to play any playlist in the name of the owner (since the embedded player is also “logged in” to YouTube), and I also have the tools to get the videos from the currently playing playlist.  What? Is it this easy?”</p><p> “等一等。只有拥有者才能看到她的播放列表的内容。我拥有以拥有者的名义播放任何播放列表的工具（因为嵌入式播放器也已“登录”到YouTube），并且我也具有从当前播放的播放列表中获取视频的工具。什么？这容易吗？”</p><p> Turns out it was that easy. Later, at home, I made a page where I embedded a YouTube player and instructed it to play the playlist  HL (the one with your Watch History), and once it loaded, I called  player.getPlaylist(), and I think I just printed the result to the console.</p><p> 原来那是那么容易。后来，在家里，我制作了一个页面，其中嵌入了YouTube播放器，并指示它播放播放列表HL（带有您的观看记录的播放列表），加载后，我调用了player.getPlaylist（），我想将结果打印到控制台。</p><p> I opened the page with my test account  and saw the test account’s watch history get printed to the console.</p><p> 我使用测试帐户打开了该页面，看到该测试帐户的观看记录已打印到控制台。</p><p> Boom! We have a bug! You visit my page, I steal your Watch History! Not bad.</p><p> 繁荣！我们有一个错误！您访问我的页面，我窃取了您的观看记录！不错。 </p><p>  I got to work to make a pretty epic POC, which demonstrated everything an attacker could do using this bug. Here are all of the exploits I was able to pull off using this issue, other than stealing your Watch History:</p><p>我必须做一个漂亮的史诗般的POC，以证明攻击者可以使用此bug进行的所有操作。除了窃取您的观看记录，以下是利用此问题我能够进行的所有利用：</p><p>  Similarly to the  HL playlist, we could just embed the  WL playlist, and steal the contents of the victim’s Watch Later using  player.getPlaylist().</p><p>  与HL播放列表类似，我们可以嵌入WL播放列表，然后使用player.getPlaylist（）窃取受害者的“稍后观看”的内容。</p><p>  These next exploits will require a targeted attack since the IDs we will be requesting will be based on the victim’s channel ID. Stealing the  HL and the  WL playlist does not require any victim-specific setup, since everyone has those same IDs.</p><p>  接下来的这些攻击将需要有针对性的攻击，因为我们将要求的ID将基于受害者的通道ID。窃取HL和WL播放列表不需要任何特定于受害者的设置，因为每个人都有相同的ID。</p><p> I have previously explained how to get the playlist ID of the “Liked Videos” playlist. If I knew the victim’s channel ID previously, I could set up a page that loads both of the victim’s possible playlist IDs, and tries to list them using  player.getPlaylist(). One of the tries will succeed, and I will have a list of all of the videos the victim has previously liked.</p><p> 前面我已经解释了如何获取“喜欢的视频”播放列表的播放列表ID。如果我以前知道受害者的频道ID，则可以设置一个页面来加载受害者的两个可能的播放列表ID，然后尝试使用player.getPlaylist（）列出它们。尝试之一将成功，并且我将列出受害者以前喜欢的所有视频。</p><p>  Since we are playing these playlists “in the name of the victim”, if the victim has any custom-made private playlists, and we somehow already know it’s ID (this would be pretty hard, so the impact of this is quite low), we could just embed it, and as before, just use  getPlaylist() to steal the contents.</p><p>  由于我们以“受害者的名义”播放这些播放列表，因此，如果受害者有任何定制的私人播放列表，并且我们已经知道它的ID（这将非常困难，因此影响很小），我们可以将其嵌入，并且像以前一样，只需使用getPlaylist（）来窃取内容。</p><p>  For this, again, we would have to know the ID of the victim’s private video we want to target, which would be pretty hard and would probably require a different bug.</p><p>  同样，我们还必须知道我们要定位的受害者的私人视频的ID，这很困难，并且可能需要其他错误。</p><p> But if we know an ID for a victim’s private video, we could embed that private video to the malicious site, and use  player.getVideoData() to steal its title, and some other extra information about it, like the list of available caption languages.</p><p> 但是，如果我们知道受害者的私有视频的ID，则可以将该私有视频嵌入到恶意网站中，并使用player.getVideoData（）来窃取其标题以及其他一些有关其的其他信息，例如可用的字幕语言列表。 </p><p>  I like this the most since a lot of people use unlisted videos to share personal/not-public videos with only specific people. I’m also doing this, all of the POC videos I send to Google are unlisted videos, and I would consider them pretty sensitive.</p><p>我最喜欢这种方式，因为许多人使用不公开的视频仅与特定的人共享个人/非公开视频。我也在这样做，我发送给Google的所有POC视频都是不公开的视频，我认为它们非常敏感。</p><p> So I have previously explained how to get the ID of the “Uploads” playlist for a given channel, and as you might already expect, we could simply embed that playlist into our malicious site.</p><p> 因此，我之前已经解释了如何获取给定频道的“上传”播放列表的ID，并且正如您可能已经期望的那样，我们可以将该播放列表简单地嵌入到我们的恶意站点中。</p><p> At the time of finding this bug, embedding the “Uploads” playlist as an owner worked a little bit differently than I expected. Previously I have said that the owner can see all of the videos in this playlist, despite the privacy settings. This is still almost the case, but when an “Uploads” playlist was embedded, the owner only saw the  Public and the  Unlisted videos in it, the  Private videos were omitted. This is perfectly fine for the current attack, but this was a limitation that didn’t allow us to leak all of the  Private video IDs, and steal all of the private titles (using the previous attack). Or, stealing all of the private videos altogether, using the bug from my  previous writeup.</p><p> 发现此错误时，以所有者身份嵌入“上传”播放列表的工作与我预期的有所不同。之前我曾说过，尽管设置了隐私设置，所有者仍可以查看此播放列表中的所有视频。几乎仍然是这种情况，但是当嵌入“上载”播放列表时，所有者只能看到其中的公开和不公开视频，而私有视频则被忽略。对于当前的攻击来说，这很好，但这是一个限制，不允许我们泄漏所有的私有视频ID，并窃取所有私有标题（使用上次攻击）。或者，使用我以前的文章中的错误来窃取所有私人视频。</p><p> Anyways, we had the ID of the “Uploads” playlist, we could embed it into our site, and then use the  player.getPlaylist() function to list all of video IDs inside.</p><p> 无论如何，我们都有“上传”播放列表的ID，可以将其嵌入到我们的网站中，然后使用player.getPlaylist（）函数列出其中的所有视频ID。</p><p> If a video is  Unlisted, the only thing which keeps it secret is its video ID.  Now, because we stole all of the unlisted video ID’s, we could watch all of the victim’s unlisted videos!</p><p> 如果某个视频不公开，则唯一使该视频保密的是其视频ID。现在，因为我们偷走了所有不公开的视频ID，所以我们可以观看受害者的所有不公开的视频！</p><p> Here is  the POC I have sent to Google. At the time, I, unfortunately, did not make a POC video, and since the issue is now fixed, I made some screenshots to show you how it looked like.</p><p> 这是我发送给Google的POC。不幸的是，当时我没有制作POC视频，并且由于此问题现已解决，因此我制作了一些屏幕截图以向您展示它的外观。</p><p> Opening the POC HTML automatically embedded 2 playlists,  HL and  WL, and displayed the contents as two lists under the players:</p><p> 打开POC HTML会自动嵌入2个播放列表HL和WL，并将内容显示为播放器下方的两个列表： </p><p>  Scrolling down a bit, you can see the “targeted attacks” section. After entering your channel ID, it listed your “Liked videos” and your “Uploaded videos”,  including your unlisted videos. Under that, you could enter a private video ID you had access to, and it displayed the video’s title and listed the available caption languages:</p><p>向下滚动，您可以看到“针对性攻击”部分。输入频道ID后，它会列出您的“喜欢的视频”和“上传的视频”，包括未列出的视频。在此之下，您可以输入有权访问的私有视频ID，它会显示视频的标题并列出可用的字幕语言：</p><p>   2019, October 11, 01:15:  My part is done, I go to sleep. But not before refreshing my email one last time, hoping that I might have already got a response. The chances of that are almost zero, but the excitement makes me do this every time I send in a bug.</p><p>   2019，十月11，01:15：我的部分做完了，我去睡觉。但是在上一次刷新我的电子邮件之前，希望我可能已经收到回复。这样的机会几乎为零，但是每次我发送错误时，激动的心情使我这样做。</p><p> After two weeks, and a bit of misunderstanding, the bug gets triaged with “At first glance, this might not be severe enough to qualify for a reward”. This hits me quite hard since back then, all of my previous bugs got this same triage message, and after finding this one, I got really excited and was pretty sure to get the mighty “Nice catch! I’ve filed a bug based on your report.” for the first time. But I didn’t. I was tweeting quite frequently at the time, so I  let out my frustration a little bit:</p><p> 经过两周的时间，以及一些误解之后，该错误被分类为“乍看之下，可能不够严重，无法获得奖励”。从那时起，这对我造成了很大的打击，我以前的所有错误都得到了相同的分类信息，找到这个信息后，我感到非常兴奋，并且非常肯定会获得强大的“不错的收获！我根据您的报告提出了一个错误。”首次。但是我没有。当时我经常发推文，所以让我有点沮丧：</p><p>  I was feeling a little down, since I have been hacking on Google VRP for two months already, and all of my bugs got the  might not be severe enough message. But most of them were still waiting for the  VRP Panel decision about the reward, so not all hope was lost.  Yet.</p><p>  我感到有些沮丧，因为我已经在Google VRP上进行了两个月的黑客攻击，而我的所有错误都得到了可能不够严重的信息。但是他们中的大多数仍在等待VRP小组关于奖励的决定，因此并非所有希望都丧失了。然而。</p><p> Almost a month later, I get a new email from  buganizer-system@google.com. As a Google VRP bug hunter, these are the emails you are looking for. I open it, and I see that this bug got rewarded with a bounty of  $1,337. This was my first “leet” reward. I  tweeted a gif of a dancing parrot. I like to use that gif for such occasions:</p><p> 大约一个月后，我收到了来自buganizer-system@google.com的新电子邮件。作为Google VRP错误猎人，这些是您正在寻找的电子邮件。我打开它，发现这个错误得到了$ 1,337的赏金。这是我的第一个“领导”奖赏。我发了一条跳舞鹦鹉的gif推文。我喜欢在这种情况下使用该gif：</p><p>  At the time I also found it a bit weird, but looking back at it, I still think that the impact of this bug was higher than the issued reward. Just thinking about my personal use case, stealing all of the POC videos of potentially unfixed Google bugs from someone (since I am uploading them to YouTube as  Unlisted videos) feels pretty high impact for me. Not even talking about the Watch History.</p><p>  当时我也觉得它很奇怪，但回头看，我仍然认为此错误的影响大于所颁发的奖励。仅考虑我的个人用例，从某人那里窃取所有可能未修复的Google bug的POC视频（因为我将其作为Unlisted video上传到YouTube）对我来说影响很大。甚至没有谈论观看历史。</p><p> I did not get back to Google about my feelings regarding the impact, so it is possible that if I tell them the reasons why I think it deserves a bigger bounty, they might re-consider the reward decision. If you are in a similar situation, don’t be afraid to ask.</p><p> 我没有再与Google交流一下有关影响的感受，因此，如果我告诉他们我认为应该得到更多赏金的原因，他们可能会重新考虑奖励决定。如果您遇到类似情况，也不要害怕问。 </p><p>  16 days after getting the reward email, I get a new email, saying that the issue is fixed. I check out what they did.</p><p>收到奖励电子邮件后的16天，我收到一封新电子邮件，说问题已解决。我看看他们做了什么。</p><p> When the embedded player loads a playlist, it get’s the contents using the  /list_ajax?list=[playlist-id] endpoint. Now, if you give any private/special playlist to this endpoint, it will return an error. Because of this, embedding any of the previously mentioned playlists will just fail, and the player will display an error.</p><p> 嵌入式播放器加载播放列表时，会使用/ list_ajax？list = [playlist-id]端点获取内容。现在，如果您将此端点提供任何专用/特殊播放列表，它将返回错误。因此，嵌入任何前面提到的播放列表将失败，并且播放器将显示错误。</p><p> This seemed to be implemented correctly, but one issue was still working, and it was the leaking of the  videoData object on a private video, which included the title, and some other information. I ping the bug, saying that this issue still works. For some reason, I do not receive a reply. I ping Google once again, and I get a reply saying that they will let the product team know.</p><p> 这似乎已正确实现，但一个问题仍然存在，这是私有数据中videoData对象的泄漏，其中包括标题和一些其他信息。我ping了这个错误，说这个问题仍然有效。由于某些原因，我没有收到回复。我再次对Google进行ping操作，并得到答复说他们将使产品团队知道。</p><p> I got back to this bug now, in 2021, and I wanted to re-test the fixes before starting to work on a writeup. Turns out, they also fixed the  videoData leak now. If a video is private, you can still embed it, but the  videoData that the player sends to your site will just be an empty object.</p><p> 现在，在2021年，我回到了这个错误，并且我想在开始编写文章之前重新测试这些修复程序。事实证明，他们现在还修复了videoData泄漏。如果视频是私有的，您仍然可以嵌入它，但是播放器发送到您的站点的videoData只是一个空对象。</p><p>  What I like about this bug is that proves what I always say when someone asks me how I hunt for bugs, or how they should hunt for bugs. I even said it in my  previous writeup:</p><p>  我喜欢这个错误的原因是，当有人问我如何寻找错误，或者他们应该如何寻找错误时，我总是会怎么说。我什至在之前的文章中说过：</p><p> “In my opinion, the more you understand a system, the more ideas about how to break it will just naturally come to mind.”</p><p> “我认为，您对系统的了解越多，自然就会想到有关如何破解该系统的更多想法。”</p><p>   [Oct 11, 2019] - Bug reported  [Oct 11, 2019] - Initial triage  [Oct 24, 2019] - Bug accepted (P4 -&gt; P2)  [Nov 14, 2019] - Reward of  $1337 issued  [Nov 30, 2019] - First part of the bug</p><p>   [2019年10月11日]-报告了错误[2019年10月11日]-初步分类[2019年10月24日]-接受了错误（P4-> P2）[2019年11月14日]-发放了$ 1337的奖励[2019年11月30日] ]-错误的第一部分 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bugs.xdavidhu.me/google/2021/01/18/the-embedded-youtube-player-told-me-what-you-were-watching-and-more/">https://bugs.xdavidhu.me/google/2021/01/18/the-embedded-youtube-player-told-me-what-you-were-watching-and-more/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/youtube/">#youtube</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/播放列表/">#播放列表</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>