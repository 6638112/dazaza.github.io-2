<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在GitHub上提高大型Monorepo性能 Improving large monorepo performance on GitHub</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Improving large monorepo performance on GitHub<br/>在GitHub上提高大型Monorepo性能 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-17 00:45:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/168d96f0ae8d4bb3192916eaadbfd312.png"><img src="http://img2.diglog.com/img/2021/3/168d96f0ae8d4bb3192916eaadbfd312.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Every day, GitHub serves the needs of over 56M developers, working on over 200M code repositories. All but a tiny fraction of those repositories are served with amazing performance, for customers from around the world.</p><p>每天，GitHub都服务于超过56米的开发人员，工作超过200M的代码存储库。除了来自世界各地的客户，所有这些存储库的一小部分都是具有惊人的表现。</p><p> Like any system as large as GitHub, some of the gaps in our coding and architecture are only discovered when they’re pushed to their limits—like having thousands of developers updating the same repo every day—and GitHub received feedback from a handful of our largest monorepo customers that they were seeing performance problems that were impacting their ability to complete push operations.</p><p> 与GitHub一样大的系统，我们的编码和架构中的一些差距仅在他们被推到他们的限制时被推到了许多开发人员每天更新相同的回购 - 而GitHub从少数人收到反馈最大的Monorepo客户，他们看到了影响他们完成推送操作能力的性能问题。</p><p> And so was GitHub.  github/github is  our monorepo, and we were experiencing occasional push failures ourselves.</p><p> GitHub也是如此。 github / github是我们的monorepo，我们偶尔会偶尔推动自己。</p><p> To start our investigation, we worked with internal teams, and engaged with customers, to understand and optimize their usage of GitHub, including coalescing multiple pushes into single pushes, which reduced the number of locking write transactions they were incurring, and even helping with reworking some of their DevOps processes to eliminate unnecessary push operations. Still, we were seeing unusual levels of push failure.</p><p> 要开始调查，我们与内部团队合作，并与客户一起参与，了解和优化他们对GitHub的使用，包括合并多次推动单一推动，这减少了他们所产生的锁定写作交易的数量，甚至有助于重新加工他们的一些DevOps流程来消除不必要的推动操作。尽管如此，我们仍然看到了不寻常的推动失败水平。</p><p> In response to this, GitHub Engineering created Project Cyclops. Project Cyclops has been a multi-month effort across our Git Systems org (which includes our Git Storage, Git Protocols, and Git Client teams), working with GitHub’s upstream Git contributors and engineers in our Web front-end teams, to find solutions to these problems. After a lot of collaboration and hard work, and multiple improvements,  we’ve driven push errors down to nearly zero, even for our largest monorepo customers with thousands of contributors.</p><p> 响应于此，Github Engineering创建了Project Cyclops。 Project Cyclops在我们的Git Systems Org（包括我们的Git Storage，Git协议和Git Clients团队）中一直是一个多月份的努力，与GitHub的上游GIT贡献者和工程师在我们的网络前端团队中使用，找到解决方案这些问题。经过大量的协作和努力工作，以及多次改进，我们已经将错误误差下降到近零，即使是我们最大的Monorepo客户拥有数千名贡献者。</p><p>  Project Cyclops resulted in many different approaches to improving our monorepo push performance. Together, they improved our ability to handle push traffic by at least an order of magnitude.</p><p>  Project Cyclops导致了许多不同的方法来提高我们的MONOREPO推送性能。它们在一起，改善了我们以至少一个数量级地处理推送流量的能力。</p><p>  By default, GitHub runs a repository maintenance routine after every 50  git push operations, or after we receive 40MB of unpacked files, which makes sure we have up-to-date packfiles for great clone/fetch performance, and which cleans up and de-duplicates data in the repo. Depending on the size of the repository, maintenance takes anywhere from a few seconds to a few minutes.</p><p>  默认情况下，GitHub在每50个Git推送操作之后运行存储库维护例程，或者在我们收到40MB的未包装文件后，这使我们确保我们有最新的包装文件，可用于巨大的克隆/获取性能，并清理和解重复回购中的数据。根据存储库的大小，维护从几秒到几分钟的任何地方需要。 </p><p> For large monorepos, with a lot of developers, 50 push operations doesn’t take long to accumulate, and therefore maintenance gets scheduled frequently, while developers are still pushing changes to the repo. We had a number of those repos failing to complete maintenance within our maximum time window. When a repo fails maintenance, performance for both push and reference updates suffers, which can lead to manual toil for our engineers to sort out those repositories again.  We’ve reduced those maintenance failures to nearly zero. Specifically, we made improvements in  git repack, and in how we schedule maintenance retries.</p><p>对于大型MONOREPOS，具有大量开发人员，50个推送操作不需要长时间累积，因此频繁调度维护，而开发人员仍在推动回购变更。我们有许多在我们的最大时间窗口中无法完成维护的那些repos。当REPO失败维护时，推送和参考更新的性能会遭受，这可能导致我们的工程师手动劳动，以便再次整理这些存储库。我们将这些维护失败降低到近零。具体而言，我们改进了Git Repack，以及我们如何安排维护重试。</p><p>  During repo maintenance, we run  git repack to compress loose objects and prepare for fast clones and fetches.</p><p>  在回购维护期间，我们运行git重新包装以压缩松散的物体，并为快速克隆准备并提取。</p><p> To compress a set of objects into a single pack, Git tries to find pairs of objects which are related to one another. Instead of storing all of the object’s contents verbatim, some objects are stored as deltas against other related ones. Finding these deltas takes time, and comparing every object to every other object gets infeasible quickly. Git solves this problem by searching for delta/base pairs within a sliding window over an array of all objects being packed.</p><p> 要将一组对象压缩到单个包中，Git尝试查找彼此相关的对象。而不是将所有对象的内容逐字存储，而某些对象将作为ΔStrtas存储为Deltas。找到这些增德拉斯需要时间，并将每个对象与每个其他对象进行比较可行。 Git通过搜索滑动窗口中的Delta / Base对来解决这个问题，通过包装的所有对象的数组。</p><p> Some delta candidates within the window can be rejected quickly by heuristics, but some require CPU-intensive comparisons.</p><p> 窗户内的一些三角洲候选人可以通过启发式迅速拒绝，但有些需要CPU密集的比较。</p><p> We’ve implemented a parameter to limit the number of expensive comparisons we’re willing to make. By tuning this value, we’ve reduced the CPU time we spend during  git repack, while only marginally increasing the resulting packfile size. This one change  eliminated nearly all of our maintenance failures.</p><p> 我们已经实施了一个参数，以限制我们愿意制作的昂贵比较数量。通过调整此值，我们降低了在GIT重新包中花费的CPU时间，而仅略微增加生成的PackFile大小。这一变化消除了我们几乎所有的维护失败。</p><p>  Before Project Cyclops, when a repo failed maintenance for any reason, we wouldn’t schedule it to run again for seven days. For many years, this rhythm served our customers well enough, but monorepos today can’t wait that long. We introduced a new  spurious-failure state for specific repository maintenance failures—the ones that generally come from lots of push traffic happening during maintenance—that allows us to retry maintenance every four hours, up to three times. This means that we’ll get to retry during a customer’s off-hours, when many fewer pushes are happening. This change  eliminated the remaining maintenance failures, and therefore eliminated more toil from our on-call engineers.</p><p>  在Project Cyclops之前，当由于任何原因的repo维护失败时，我们不会安排它再次运行七天。多年来，这种节奏为客户提供了足够的服务，但今天的Monorepos等不及了这一点。我们为特定的存储库维护失败引入了新的虚假失败状态 - 通常来自维护期间发生的大量推送流量 - 这使我们可以每四个小时重试维护，最多三次。这意味着我们会在客户的离线时间内重试，当时更少的推动。这一变化消除了剩余的维护失败，因此从我们的接听工程师中取消了更多的劳动。</p><p>  On our file servers—the servers that actually hold git repositories—we have had a parameter in place for years that slowed down the rate of push operations we processed on each one. GitHub is a multi-tenant service, and, originally, this parameter was meant to ensure that writes from one customer won’t monopolize resources on a server, which would interfere with traffic from all of the other customers on that server. In effect, this was an  artificial cap on the amount of work our servers could do.</p><p>  在我们的文件服务器上 - 实际上持有Git存储库的服务器 - 我们已经有一个参数到位，减慢了我们在每个处理的推送操作速率下减慢了。 GitHub是一个多租户服务，而且，此参数旨在确保从一个客户写入，不会垄断服务器上的资源，这会干扰来自该服务器上所有其他客户的流量。实际上，这是我们服务器可以做的工作量的人为帽。 </p><p> After an investigation where we slowly raised the value of this parameter to allow 100% of push operations to run immediately, we found that performance with our current architecture was more than good enough, and not only did we raise the limit, we  removed the parameter from our code. This immediately improved our monorepo performance and  eliminated many push-related errors.</p><p>在调查后，我们慢慢提出了这个参数的价值，允许100％的推送操作立即运行，我们发现使用我们当前的架构的性能超过了足够好的，而且不仅我们提高了限制，我们删除了参数来自我们的代码。这立即改善了我们的MONOREPO性能，并消除了许多与之相关的错误。</p><p>  GitHub, by default, writes five replicas of each repository across our three data centers to protect against failures at the server, rack, network, and data center levels. When we need to update Git references, we briefly take a lock across all of the replicas in all of our data centers, and release the lock when our  three-phase-commit (3PC) protocol reports success.</p><p>  默认情况下，GitHub将每个存储库的五个副本写入我们的三个数据中心，以防止服务器，机架，网络和数据中心级别的故障。当我们需要更新GIT引用时，我们在所有数据中心都短暂地锁定所有副本，并在我们的三相提交（3PC）协议报告成功时释放锁定。</p><p> During that lock, we compute a checksum on each replica, to ensure that they match and that all replicas are in sync. We use incremental checksums to make this faster, and during normal operation, this takes less than 50ms, but during repair operations, where we recompute the checksum from scratch, it takes longer. For large monorepos,  the lock was held for 20-30 seconds.</p><p> 在该锁期间，我们在每个副本上计算校验和，以确保它们匹配，并且所有副本都处于同步状态。我们使用增量校验和更快，在正常操作期间，这需要小于50ms，但在维修操作期间，我们在从头开始重新计算校验和，需要更长时间。对于大型MONOREPOS，锁定了20-30秒。</p><p> We made a change to compute these replica checksums prior to taking the lock. By precomputing the checksums, we’ve been able to  reduce the lock to under 1 second, allowing more write operations to succeed immediately.</p><p> 我们在锁定之前进行了更改以计算这些副本校验和。通过预先计算校验和，我们已经能够将锁将锁定到1秒以下，允许更多的写入操作立即成功。</p><p>  One of our large monorepo customers keeps their own internal metrics on git performance, and their numbers show what ours do: their push operations have shown no failures for months.</p><p>  我们的一个大型Monorepo客户可以在Git性能上保留自己的内部指标，他们的号码显示我们的所作所为：他们的推送操作已经显示出几个月的故障。</p><p> Another monorepo customer who was experiencing too many failures was planning a migration to start with a fresh repository, minimizing the number of references in the repo, in an attempt to improve push success. After these changes, our metrics showed their push failures at nearly zero, and a survey of their developers in December found no reports of recent push failures at all. They cancelled the migration, and continue running with great performance.</p><p> 另一个正在遇到太多失败的Monorepo客户计划迁移以用新鲜的存储库开始，从而最大限度地减少回购中的参考数量，以提高推动成功。在这些变化之后，我们的指标显示了他们的推动失败，近零，并在12月对他们的开发商进行了调查，没有关于最近推动失败的报道。他们取消了迁移，并继续以良好的表现运行。</p><p> Want graphs? Here are graphs from these customers showing push failures dropping to nearly zero as we rolled out fixes.</p><p> 想要图表？以下是这些客户的图表显示推出修复的推出近零的推送失败。 </p><p>    Like we said, we’ve got push failures down to  nearly zero. Some of those failures are caused by random Internet networking issues, and are beyond our control. As for the rest, we’re looking at ways to eliminate those last annoying failures where we can, and to continue to make GitHub faster.</p><p>就像我们说的那样，我们已经将失败降到了近零。其中一些失败是由随机互联网网络问题引起的，并且超出了我们的控制。至于其余的，我们正在寻找消除我们可以在那里的最后一个恼人的失败，并继续更快地制作github。</p><p> In the Git Systems world, we’re refreshing our storage hardware to make it faster. We’re also in the middle of a significant refactoring effort, doing our part to decompose GitHub’s famous Ruby monolith, and writing a new microservice in Go that will improve repository performance for every single user on GitHub.</p><p> 在Git Systems World中，我们正在刷新我们的存储硬件，以使其更快。我们也在中间的重构努力中，我们可以分解Github着名的Ruby Monolith，并在GO中编写一个新的微服务，这将提高GitHub上每个用户的存储库性能。</p><p>  Project Cyclops has led to better performance and the elimination of failures for customers with large monorepos, less wasted CPU cycles on our fleet of file servers, and has significantly improved the experience of using GitHub for thousands of developers at some of our largest customers, including our customers using GitHub Enterprise Server.</p><p>  Project Cyclops导致具有大型Monorepos的客户的性能和消除失败的故障，我们在文件服务器的船队上浪费了浪费的CPU周期，并且在其中一些最大的客户中使用GitHub以上使用Github的经验，包括我们的客户使用GitHub Enterprise Server。</p><p>  We’ve improved single-repository update traffic rates by at least an order of magnitude. We now have years of headroom on our current architecture to handle the growth of even the largest monorepos.</p><p>  我们至少将单次存储库更新流量提高至少一个级别。我们现在有多年的余规是我们目前的架构，以处理甚至最大的Monorepos的增长。</p><p>  We want to say how incredibly grateful 💚 we are to our monorepo customers who have collaborated with us to make GitHub better. Their help in reporting, and sometimes even diagnosing, problems was instrumental to addressing them. ✨ Sparkles all around! ✨</p><p>  我们想说有多令人难以置信的♥我们是我们与我们合作的Monorepo客户，以便更好地制作GitHub。他们在报告中的帮助，有时甚至诊断，问题都是有助于解决这些问题。 ✨周围闪耀！ ✨ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.blog/2021-03-16-improving-large-monorepo-performance-on-github/">https://github.blog/2021-03-16-improving-large-monorepo-performance-on-github/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/github/">#github</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/monorepo/">#monorepo</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/large/">#large</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012 - 2021 diglog.com </div></div></body></html>