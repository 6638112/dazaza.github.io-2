<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>按键BCS2KEYBCS2</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">KEYBCS2<br/>按键BCS2</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 11:55:38</div><div class="page_narrow text-break page_content"><p>After writing about the likely origins of  IBM code page 852, I thought I should revisit the homegrown Czech alternative solution, the Kamenický brothers encoding and their keyboard driver. Its existence is well documented, and the so-called (somewhat misnamed)  KEYBCS2 encoding even has its own Wikipedia article. The encoding itself lives on in various conversion tables, and utilities to convert text to or from the Kamenický encoding are easy enough to locate.</p><p>在写了IBM code page 852的可能起源之后，我想我应该重温一下捷克本土的替代解决方案，Kamenickýbrothers编码和他们的键盘驱动程序。它的存在有很好的文档记录，所谓的（有点命名错误）KEYBCS2编码甚至有自己的维基百科文章。编码本身存在于各种转换表中，将文本转换为Kamenický编码或从Kamenický编码转换文本的实用程序很容易找到。</p><p> But finding the actual KEYBCS2 utility turned out to be ridiculously difficult. I scoured the Internet for it. I could not find it. At all. I found a fair amount of text  talking about it, but not the actual utility.</p><p>但事实证明，找到真正的KEYBCS2实用程序非常困难。我在网上搜寻它。我找不到。完全我发现有相当多的文字在谈论它，但不是实际的用途。</p><p> In desperation, I started searching my NAS. I must have had the utility in the early 1990s, but after I switched to primarily using OS/2 in the mid-1990s, the DOS keyboard driver wasn’t all that useful, and OS/2 had its own reasonably well functioning support using CP852 compatible with the built-in DOS support.</p><p>在绝望中，我开始搜索我的NAS。我肯定在20世纪90年代初就有了这个实用程序，但在20世纪90年代中期我主要使用OS/2之后，DOS键盘驱动程序并没有那么有用，OS/2也有自己的功能良好的支持，使用CP852与内置的DOS支持兼容。</p><p> After much searching, I found an archive with KEYBCS2.EXE dated 07/27/90 on my NAS. Sadly, all my attempts to run it ended up in failure:</p><p>经过多次搜索，我找到了一个带有KEYBCS2的档案。90年7月27日在我的NAS上执行。可悲的是，我所有的尝试都以失败告终：</p><p>  Obviously I was not  trying to debug the program, but I was  forced to do so.</p><p>显然，我并没有试图调试程序，但我是被迫这么做的。</p><p>  Looking at KEYBCS2.EXE in a hex editor showed no obvious strings; in fact it all looked pretty random. But examining the memory of a VM showing the silly error message revealed a suspicious looking string:  Program LOCK Version 1.10 (C) 1989 J.Belonoznik. Okay, some daft anti-debugging program wrapper, but why does it think I’m debugging it when I’m not?</p><p>看看键盘。十六进制编辑器中的EXE没有显示明显的字符串；事实上，这一切看起来都很随机。但检查一个显示愚蠢错误消息的虚拟机的内存时，发现了一个看起来可疑的字符串：Program LOCK Version 1.10（C）1989 J.Belonoznik。好吧，一些愚蠢的反调试程序包装器，但为什么它认为我在调试它，而我没有？</p><p>  After analyzing the “program lock”, I discovered that it inadvertently prevents “locked” programs from running on any halfway modern CPU. The last processor generation it worked on is the 486, but on a Pentium or newer it always fails with a “Debugging is not allowed” message.</p><p>在分析了“程序锁”之后，我发现它无意中阻止了“锁定”程序在任何一半的现代CPU上运行。它使用的上一代处理器是486，但在奔腾或更高版本上，它总是会失败，并显示“不允许调试”消息。</p><p> The reason for that is (unsurprisingly) debugger detection. The lock code detects modifications to itself, which presumably catches any INT3 breakpoints. And it detects single-stepping by using self-modifying code. It looks approximately (not exactly) like this:</p><p>原因是（不出所料）调试器检测。锁代码检测对自身的修改，这可能会捕获任何INT3断点。通过使用自修改代码检测单步。它看起来大致（不完全）像这样：</p><p> xor ax, ax lea bx, mod_code mov byte ptr [bx], 90h ; NOP opcode jmp short $+2 mov byte ptr [bx], 40h ; INC AX opcodemod_code: nop ; Modified instruction cmp ax, 1 ; Is AX zero or one?</p><p>异或ax，ax lea bx，模码mov字节ptr[bx]，90h；NOP操作码jmp short$+2 mov字节ptr[bx]，40h；INC AX opcodemod_代码：nop；修改指令cmp-ax，1；斧头是零还是一？</p><p> This code relies on the existence of a software-visible prefetch queue on old x86 CPUs. Up to and including the Intel 486, the code will execute a NOP instruction. The second MOV overwrites the instruction in memory, but the next instruction is already in the prefetch queue and will be executed as it was after the jump which flushed the prefetch queue.</p><p>这段代码依赖于旧x86 CPU上是否存在软件可见的预取队列。在英特尔486之前（含），该代码将执行NOP指令。第二个MOV覆盖内存中的指令，但下一条指令已经在预取队列中，并将在刷新预取队列的跳转之后按原样执行。</p><p> On the Pentium and later CPUs, the processor detects a write to code which is currently in the prefetch queue, flushes the queue, and executes the modified code. With effort, the detection could be fooled on a Pentium (not Pentium Pro), because it goes by linear rather than physical address, but it’s quite good enough to detect this instance of self-modifying code.</p><p>在奔腾和更高版本的CPU上，处理器检测到当前在预取队列中的写入代码，刷新队列，并执行修改后的代码。经过努力，在奔腾（而非奔腾Pro）上检测可能会被愚弄，因为它使用的是线性地址，而不是物理地址，但它足够好，可以检测到这种自我修改代码的实例。</p><p> As a consequence, the “debugger detection” is guaranteed to fail on Pentium and later processors. Obviously the code was written in 1989, if not earlier, and its author merely failed to predict the future.</p><p>因此，“调试器检测”在奔腾和更高版本的处理器上肯定会失败。显然，该代码是1989年编写的，如果不是更早的话，其作者只是未能预测未来。</p><p> The upshot is that the “anti-debugging” code serves as a rather effective timebomb which can not be worked around by simply setting the clock back.</p><p>结果是，“反调试”代码充当了一个相当有效的定时炸弹，不能通过简单地将时钟向后拨来解决。</p><p>  I considered various approaches to making the protected KEYBCS2.EXE run on systems with CPUs newer than a 486. The protection is good enough that patching the protected executable is difficult. It checks its own integrity and uses XOR chains to decrypt the executable, which means that patching a byte here and there is quite involved.</p><p>我考虑了制作受保护密钥BCS2的各种方法。EXE在CPU比486新的系统上运行。保护足够好，因此修补受保护的可执行文件非常困难。它会检查自身的完整性，并使用XOR链对可执行文件进行解密，这意味着需要在这里和那里修补一个字节。</p><p> I considered writing some kind of a TSR that works around the protection by intercepting the INT 21h calls printing the error message, or a timer hook watching for the case where the code hangs itself. It didn’t seem worth the effort.</p><p>我考虑编写某种TSR，通过截取打印错误消息的INT 21h调用，或者一个计时器挂钩，监视代码挂起的情况，从而围绕保护工作。这似乎不值得努力。</p><p> So… I considered the likelihood that the original protected program was a DOS .COM file (quite high). In that case, maybe after after the “program lock” shell is done, it reconstructs the original .COM image in memory. So I ran KEYBCS2.EXE, saved the memory contents, chopped off what didn’t seem to belong, and re-saved what was left as KEYBCS2.COM. It worked.</p><p>所以…我考虑了原始受保护程序是DOS的可能性。COM文件（相当高）。在这种情况下，可能在“程序锁”shell完成后，它会重建原始的。内存中的COM图像。所以我运行了KEYBCS2。EXE，保存内存内容，切掉似乎不属于的内容，并将剩下的内容重新保存为KEYBCS2。通用域名格式。成功了。</p><p>  But first I manually got past the debugger checks. Ironically, using a debugger. All I needed to do was to let the program execute a  JMP $ instruction to hang itself, patch it to change to  JMP $+2 (by simply setting the second byte to zero), and continue. There were two instances of those jumps, each being hit several times; that is why the message was printed five times total:</p><p>但首先我手动通过了调试器检查。讽刺的是，使用调试器。我所需要做的就是让程序执行一条JMP$指令来挂起自己，将其修补为JMP$+2（只需将第二个字节设置为零），然后继续。有两次这样的跳跃，每次都被击中几次；这就是为什么这条信息总共打印了五倍：</p><p>  As it turns out, KEYBCS2 is a fairly fancy keyboard driver, and it takes up 10KB memory–not an insignificant amount. One reason for the relatively high memory usage is a nifty configuration menu that can be popped up with Ctrl+Shift+F1:</p><p>事实证明，KEYBCS2是一个相当花哨的键盘驱动程序，它占用了10KB的内存——这不是一个微不足道的数字。内存使用率相对较高的一个原因是，使用Ctrl+Shift+F1可以弹出一个漂亮的配置菜单：</p><p>  The KEYBCS2 utility can dynamically switch between several possible keyboard layouts. “Standard” is untranslated BIOS input, while “national” is Czech or Slovak keyboard layout. But there is also a “combined” layout, really two layouts at once with the Ctrl key shifting to the “other” layout. There’s even a dedicated keyboard layout for drawing “graphics”:</p><p>KEYBCS2实用程序可以在几种可能的键盘布局之间动态切换。“标准”是未翻译的BIOS输入，“国家”是捷克或斯洛伐克键盘布局。但也有一个“组合”布局，实际上是两个布局同时按下Ctrl键切换到“其他”布局。甚至还有一个专门用于绘制“图形”的键盘布局：</p><p>    The whole time I kept thinking, was there ever KEYBCS1? I found the answer in the online help for a KEYBDEF.EXE utility (found in the same archive as KEYBCS2.EXE) which allows users to define their own keyboard layouts for the KEYBCS2 driver:</p><p>我一直在想，有没有钥匙？我在KEYBDEF的在线帮助中找到了答案。EXE实用程序（与KEYBCS2.EXE位于同一档案中），允许用户为KEYBCS2驱动程序定义自己的键盘布局：</p><p>  Indeed there was a KEYBCS1 utility. It was the same as KEYBCS2 but without the pop-up configuration screen, and therefore presumably smaller. There was also a corresponding KEYBSL1 and KEYBSL2 utility which used the Slovak keyboard layout by default.</p><p>确实有一个KEYBCS1实用程序。它与KEYBCS2相同，但没有弹出的配置屏幕，因此可能更小。还有一个对应的KEYBSL1和KEYBSL2实用程序，默认情况下使用斯洛伐克键盘布局。</p><p> It is clear that calling the Kamenický encoding “KEYBCS2” is a bit silly because it is equally the KEYBCS1, KEYBSL1, and KEYBSL2 encoding. Note that the utility in fact refers to itself as “KEYBxxy” in its online help.</p><p>显然，将Kamenický编码称为“KEYBCS2”有点愚蠢，因为它同样是KEYBCS1、KEYBSL1和KEYBSL2编码。请注意，该实用程序实际上在其联机帮助中称自己为“KEYBxxy”。</p><p> Also note that some sources incorrectly claim that KEYBCS2 was a newer version of a supposed KEYBCS utility; it was not, because KEYBCS1 and KEYBCS2 were different variants of the same utility.</p><p>还要注意的是，一些消息来源错误地宣称KEYBCS2是假定的KEYBCS实用程序的更新版本；事实并非如此，因为KEYBCS1和KEYBCS2是同一实用程序的不同变体。</p><p>  The way the Kamenický encoding was designed was far from random. It was first put together circa 1986, in an era when VGA did not yet exist and EGA was a high-end adapter. Most PCs used MGA, CGA, or Hercules cards.</p><p>Kamenický编码的设计方式远非随机。它最早是在1986年左右组装起来的，当时VGA还不存在，EGA是一种高端适配器。大多数电脑使用MGA、CGA或Hercules卡。</p><p> The problem with those adapters was that apart from the Hercules Plus (only released in 1986), they all had fixed fonts in ROM. While replacing the character generator EPROM was often possible with many of those cards, it wasn’t always an option for end users, and not everyone had the required equipment to begin with.</p><p>这些适配器的问题在于，除了Hercules Plus（仅于1986年发布）之外，它们在ROM中都有固定的字体。虽然用这些卡中的许多卡替换字符生成器EPROM通常是可能的，但它并不总是最终用户的选项，而且不是每个人都有所需的设备。</p><p> The Kamenický encoding was therefore chosen such that national characters were placed in locations where they more or less closely corresponded to visually similar glyphs in the standard IBM PC code page 437. That has two practical advantages: First, Czech or Slovak language text is legible (if ugly) even without customized fonts. Second, the Kamenický encoding preserves all of the the CP437 line drawing characters, unlike CP852.</p><p>因此，选择了Kamenický编码，以便将国家字符放置在与标准IBM PC代码第437页中视觉相似的字形大致对应的位置。这有两个实际优势：第一，即使没有定制字体，捷克语或斯洛伐克语文本也清晰易读（尽管很难看）。其次，和CP852不同，Kamenický编码保留了所有CP437线描字符。</p><p> Compare this screenshot of the once hugely popular Norton Commander when run with the Kamenický encoding</p><p>将这张曾经大受欢迎的诺顿指挥官的截图与Kamenický编码进行比较</p><p>  with a screenshot of the same Norton Commander running with PC Latin 2 (CP852) encoding:</p><p>使用PC Latin 2（CP852）编码的同一名诺顿指挥官的屏幕截图：</p><p>  CP852 sacrificed some of the line-drawing characters in order to cover more languages. While that is a very reasonable compromise, most users only cared about a single language and preferred undisturbed line graphics instead.</p><p>为了覆盖更多的语言，CP852牺牲了一些线描字符。虽然这是一个非常合理的折衷方案，但大多数用户只关心一种语言，而更喜欢不受干扰的线条图形。</p><p> The encoding design also made sorting and case changes somewhat more difficult, because there was no simple algorithmic ordering of the national characters. But that was a problem solvable in software, whereas getting the right characters displayed in the first place wasn’t necessarily just a question of software.</p><p>编码设计也使排序和大小写更改变得更加困难，因为国家字符没有简单的算法排序。但这是一个在软件中可以解决的问题，而首先显示正确的字符不一定只是软件的问题。</p><p> The same kind of approach of minimally modifying CP437 was also (independently?) used by the Hungarian  CWI-1/CWI-2 encoding, and to a lesser extent by the Polish  Mazovia encoding.</p><p>同样的最小修改CP437的方法也是（独立地？）用于匈牙利CWI-1/CWI-2编码，在较小程度上用于波兰马佐维亚编码。</p><p>  An important point to note is that KEYBCS2 (indeed the entire KEYBxxy family) makes no attempt to do anything with screen fonts; it in fact does not necessarily require national screen fonts at all, as explained above.</p><p>需要注意的一点是，KEYBCS2（实际上是整个KEYBxxy系列）没有试图对屏幕字体做任何事情；事实上，正如上面所解释的，它根本不一定需要全国性的屏幕字体。</p><p> Then again, users with EGA or VGA hardware would have obviously  wanted to use proper fonts. Since KEYBCS2 offers no help, they must have used something else.</p><p>同样，使用EGA或VGA硬件的用户显然希望使用正确的字体。由于KEYBCS2没有提供帮助，他们肯定使用了其他东西。</p><p> In an old document, I found a mention of an EGASET utility that was reportedly used together with KEYBCS2. I quickly discovered that EGASET is not a terribly unique name. Then I found the right one in a  most unexpected place, in an archive called CZHPFNT.ZIP.</p><p>在一份旧文档中，我发现了一个EGASET实用程序，据报道它与KEYBCS2一起使用。我很快发现EGASET并不是一个非常独特的名字。然后我在一个最意想不到的地方，在一个名为CZHPFNT的档案中找到了正确的一个。拉链</p><p> It is a mystery where the CZHPFNT archive originated, but it’s pretty clear when: April 1989. Imagine my surprise when I found an utility called KEYBCS3.COM included:</p><p>CZHPFNT档案的起源是一个谜，但很清楚是在1989年4月。想象一下，当我发现一个名为KEYBCS3的实用程序时，我会有多么惊讶。COM包括：</p><p>  It is obviously an older version (the file timestamp is July 1987, the program itself indicates May 1987) of my KEYBCS2. I have no idea why it is called KEYBCS3, but it’s not just a renamed file; the utility clearly calls itself KEYBCS3.</p><p>这显然是我的KEYBCS2的旧版本（文件时间戳是1987年7月，程序本身表明是1987年5月）。我不知道为什么它被称为KEYBCS3，但它不仅仅是一个重命名的文件；该实用程序显然称自己为KEYBCS3。</p><p> I could not find any mention of KEYBCS3 anywhere. It is also unclear what the ‘3’ means; it presumably means something, but the newer online help from 1990 only mentions KEYBCS1 and KEBYCS2 and the KEYBCS3 utility itself offers no hints.</p><p>我在任何地方都找不到提到KEYBCS3的地方。也不清楚“3”是什么意思；它可能意味着什么，但1990年更新的在线帮助只提到KEYBCS1和KEBYCS2，而KEYBCS3实用程序本身没有提供任何提示。</p><p> But that wasn’t the only surprise in the CZHPFNT archive. When I ran the actual EGASET utility that I had been searching for, it showed  Copyright IBM Roece Inc. 1986 — that is the same IBM ROECE (Regional Office for Europe Central and East) mentioned in a  previous post:</p><p>但这并不是CZHPFNT档案中唯一的惊喜。当我运行我一直在搜索的实际EGASET实用程序时，它显示了IBM Roece Inc.1986的版权，这与之前一篇帖子中提到的IBM Roece（欧洲中部和东部地区办事处）相同：</p><p>  Here’s a menu that the EGASET utility pops up in response to an Alt + Right Shift key combination:</p><p>下面是一个菜单，EGASET实用程序会弹出，以响应Alt+右移键组合：</p><p>  It appears that EGASET is really a generic EGA tweaking utility which happens to allow loading fonts. IBM ROECE probably ended up using it because that was the first thing they found, not because it’s the most obvious method of overriding EGA fonts.</p><p>看来，EGASET真的是一个通用的EGA调整工具，它恰好允许加载字体。IBM ROECE最终使用它可能是因为这是他们发现的第一件事，而不是因为它是覆盖EGA字体的最明显的方法。</p><p> For something with an IBM name on it, the EGASET utility is rather mysterious. Then again, if it was only distributed by IBM ROECE, it probably ended up almost exclusively behind the Iron Curtain where most of the circa pre-1991 computing history almost completely vanished.</p><p>对于上面有IBM名称的东西，EGASET实用程序相当神秘。然而，如果它只是由IBM ROECE发布的话，它可能最终几乎完全落在铁幕后面，大约1991年以前的大部分计算历史几乎完全消失了。</p><p> The supplied CSEGA14.FNT font is dated January 1988. The CZHPFNT archive very strongly suggests that IBM ROECE did offer some sort of national language support for at least some countries of the Eastern Bloc, although what  exactly that support looked like is very unclear. It is not even clear if IBM ROECE had anything to do with the CZHPFNT archive beyond being involved with the EGASET utility. The included font only contains raw font data, and the archive’s README.TXT offers no clues either.</p><p>提供的CSEGA14。FNT字体日期为1988年1月。CZHPFNT档案非常有力地表明，IBM ROECE确实为至少一些东欧国家提供了某种形式的国家语言支持，尽管这种支持到底是什么样子尚不清楚。除了参与EGASET实用程序之外，IBM ROECE是否与CZHPFNT归档文件有任何关系甚至尚不清楚。包含的字体仅包含原始字体数据和存档的自述文件。TXT也没有提供任何线索。</p><p>  Because finding the KEYBCS2 utility was so insanely difficult, I made it available, together with several others,  here. The original no-longer-working KEYBCS2.EXE is included, together with my “unlocked” KEYBCS2.COM. Several alternative keyboard and/or display drivers are included; of those CZECH.EXE is the newest and fanciest, with minimal conventional memory footprint and keyboard/display support for Kamenický, CP852, CP1250, and ISO 8859-2 encodings.</p><p>因为找到KEYBCS2实用程序非常困难，所以我和其他几个人一起在这里提供了它。原来的键盘BCS2不再工作。包括EXE和我的“解锁”键BCS2。通用域名格式。包括几个可选的键盘和/或显示驱动程序；那些捷克人。EXE是最新、最新奇的，它的传统内存占用最小，并且支持Kamenický、CP852、CP1250和ISO 8859-2编码的键盘/显示器。</p><p> Although DOS 5.0 and later came with perfectly functional built-in keyboard and font support, it was limited to CP852; the third-party utilities tend to be significantly more capable and flexible while needing less memory.</p><p>尽管DOS 5.0及更高版本提供了功能完善的内置键盘和字体支持，但它仅限于CP852；第三方实用程序往往更强大、更灵活，同时需要更少的内存。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/按键/">#按键</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/keybcs2/">#keybcs2</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>