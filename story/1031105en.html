<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ARM32页表</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">ARM32页表</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-25 23:05:31</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/680f5e4423334778ce83f02918d29139.jpg"><img src="http://img2.diglog.com/img/2020/10/680f5e4423334778ce83f02918d29139.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>As I continue to describe in different postings how the ARM32 start-up sequence works, it becomes necessary to explain in-depth the basic kernel concepts around page tables and how it is implemented on ARM32 platforms.</p><p>随着我继续在不同的帖子中描述ARM32启动序列是如何工作的，有必要深入解释有关页表的基本内核概念以及它是如何在ARM32平台上实现的。</p><p> To understand the paging setup, we need to repeat and extend some Linux paging lingo. Some good background is to read  Mel Gormans description of the Linux page tables from his book “Understanding the Linux Virtual Memory Manager”. This book was published in 2007 and is based on Mel’s PhD thesis from 2003. Some stuff has happened in the 13 years since then, but the basics still hold. It is necessary to also understand the new layers in the page tables such as the  five layers of page tables currently used in the Linux kernel.</p><p>要理解分页设置，我们需要重复和扩展一些Linux分页行话。一些很好的背景知识是阅读Mel Gorman在他的“理解Linux虚拟内存管理器”一书中对Linux页表的描述。本书出版于2007年，基于梅尔2003年的博士论文。在那之后的13年里，发生了一些事情，但基本情况仍然存在。还有必要了解页表中的新层，例如Linux内核中当前使用的五层页表。</p><p> First a primer: the ARM32 architecture with a  classic MMU has 2 levels page tables and the more recent LPAE (Large Physical Address Extension) MMU has 3 levels of page tables.</p><p>首先介绍一下入门知识：采用经典MMU的ARM32架构有2级页表，而最新的LPAE(大型物理地址扩展)MMU有3级页表。</p><p> Only some of the ARMv7 architectures have LPAE, and it is only conditionally enabled, i.e. the machines can also use the classic MMU if they want, they have both. It is not enabled by default on the  multi_v7 configuration: your machine has to explicitly turn it on during compilation. The layout is so different that the same binary image can never support both classic and LPAE MMU in the same kernel image.</p><p>只有一些ARMv7架构有LPAE，而且它是有条件启用的，也就是说，如果机器愿意，也可以使用经典的MMU，它们两者都有。默认情况下，在multiv7配置上没有启用它：您的机器必须在编译期间显式打开它。布局非常不同，同一个二进制映像永远不能在同一内核映像中同时支持经典和LPAE MMU。</p><p> Early implementations of ARMv7-A such as Cortex A8 and Cortex A9 do not support LPAE, rather it was introduced during the lifetime of this architecture. Since this is a compile-time setting, the default configuration for ARMv7 cannot enable it by default, or the older implementations would break. ARMv8 implementations all have LPAE enabled by default.</p><p>ARMv7-A的早期实现(如Cortex A8和Cortex A9)不支持LPAE，而是在此体系结构的生命周期中引入的。由于这是编译时设置，默认情况下ARMv7的默认配置不能启用它，否则旧的实现会中断。默认情况下，所有ARMv8实现都启用了LPAE。</p><p>    Abstract page tables in the Linux kernel proceed from the PGD (page global directory) thru the P4D (fourth level directory), PUD (page upper directory), PMD (page middle directory) and down to the actual page table entries (PTEs) that maps individual pages pages of memory from virtual to physical address space.</p><p>Linux内核中的抽象页表从PGD(页面全局目录)开始，经过P4D(第四级目录)、PUD(页面上层目录)、PMD(页面中间目录)，再向下到将内存的各个页面从虚拟地址空间映射到物理地址空间的实际页表条目(PTE)。</p><p>  pgd, pgd_t, pgdval_t =  Page Global Directory – the Linux kernel main page table handling the PGD for the kernel memory is found in symbol  swapper_pg_dir</p><p>Pgd，pgd_t，pgdval_t=页面全局目录-在符号swapper_pg_dir中可以找到为内核内存处理PGD的Linux内核主页表。</p><p> p4d, p4d_t, p4dval_t =  Page Level 4 Directory was introduced to handle 5-level page tables after the pud was introduced. Now it was clear that we need to replace pgd, pmd, pud with a figure indicating the directory level and we cannot go on with natural names any more. This is unused on ARM32.</p><p>在引入PUD之后，引入了p4d，p4d_t，p4dval_t=Page Level 4 Directory来处理5级页表。现在很明显，我们需要用指示目录级别的数字替换PGD、PMD、PUD，我们不能再使用自然名称。这在ARM32上未使用。</p><p> pud, pud_t, pudval_t =  Page Upper Direcory was introduced after the other abstractions to deal with 4-level page tables. Like p4d, this is unused on ARM32.</p><p>PUD，PUD_t，pudval_t=Page UpDirecory是在其他抽象概念之后引入的，用于处理4级页表。与P4D一样，这在ARM32上没有使用。</p><p>   pfn =  Page Frame Number each page in physical memory has a unique number, address  0x00000000 is page 0, address  0x00001000 is page 1 etc (see   include/asm-generic/memory_model.h)</p><p>Pfn=页帧编号物理内存中的每一页都有一个唯一的编号，地址0x00000000是第0页，地址0x00001000是第1页，依此类推(请参阅include/asm-Generic/Memory_Model.h)。</p><p> First and foremost notice that these are all except PTE named something-directory. This is because they  all contain several pointers down to objects of the next level. Like any directory. So each PGD, P4D … etc is an  array of pointers. The PTE despite having a singular form  also contain several pointers.</p><p>首先也是最重要的注意，除了名为Something-directory的PTE之外，所有这些都是。这是因为它们都包含指向下一层对象的几个指针。就像任何目录一样。所以每个Pgd，P4D…。Etc是一个指针数组。PTE尽管有一个单数形式，但也包含几个指针。</p><p> The Linux kernel will act as if 5 levels of page tables exist. This is of course grossly over-engineered for ARM32 which has 2 or 3 levels of page tables, but we need to cater for the rest of the world. One size fits all. In practice, the code is organized such that these page tables “fold” and we mostly skip over the intermediate translation steps when possible.</p><p>Linux内核将表现为存在5级页表。当然，这对于ARM32来说是过度设计的，因为ARM32有2到3个页表级别，但是我们需要迎合世界其他地方的需要。一个尺码适合所有人。实际上，代码的组织方式是使这些页表“折叠”，我们在可能的情况下通常会跳过中间翻译步骤。</p><p> The other thing you need to know about the page table hierarchy is that each level contains a number of pointers, which are translation chunks. On ARM32, on the PTE level we always have 512 pointers per PTE, and each pointer translates one 4KB page (0x1000) of memory.</p><p>关于页表层次结构，您需要知道的另一件事是，每个级别都包含许多指针，这些指针是转换块。在ARM32上，在PTE级别上，每个PTE总是有512个指针，每个指针转换一个4KB页(0x1000)的内存。</p><p> A PTE on ARM32 contains 512 pointers, i.e. translations between physical and virtual pages. From the generic kernel virtual memory management it is not important how this translation actually happens in hardware, all it needs to know is that a page of size  0x1000 (4KB) is translated by a single PTE pointer entry. This way a PTE is a directory, just like everything else in the page hierarchy. In the example the first pointer in the PTE translates physical address  0x10000000 to virtual address  0xC0000000.</p><p>ARM32上的PTE包含512个指针，即物理页和虚拟页之间的转换。从通用内核虚拟内存管理来看，这种转换实际上如何在硬件中进行并不重要，它需要知道的是大小为0x1000(4KB)的页面是由单个PTE指针条目转换的。这样，PTE就是一个目录，就像页面层次结构中的其他所有内容一样。在本例中，PTE中的第一个指针将物理地址0x10000000转换为虚拟地址0xC0000000。</p><p> On the PMD level the classic ARM32 MMU has one pointer per PMD and 2048 pointers per PGD. The P4D and PUD levels are “folded” i.e. unused. Having one pointer per PMD seems vaguely pointless: we have level-1 in the 2048 pointers in the PGD and level-2 in the 512 pointers in the PTE. You rightfully ask what the point is to have a “three level” hierarchy with the middle directory having one pointer per PMD. This is a way of fitting the Linux idea about page hierarchy with the actual ARM32 architecture, and will be explained shortly.</p><p>在PMD级别，经典的ARM32 MMU每个PMD有一个指针，每个PGD有2048个指针。P4D和PUD级别是“折叠”的，即未使用。每个PMD有一个指针似乎没有什么意义：我们在PGD的2048个指针中有级别1，在PTE的512个指针中有级别2。您理所当然地会问，拥有一个“三级”层次结构(中间目录每个PMD有一个指针)有什么意义。这是一种将Linux关于页面层次的思想与实际的ARM32体系结构相匹配的方法，稍后将对其进行说明。</p><p> The classic ARM32 paging setup in Linux folds P4D and PUD, providing 2048 pointers per PGD, 1 pointer per PMD and 512 pointers per PTE. It uses 3 levels of the hierarchy while ARM32 hardware only has two. This is however a good fit, as we shall see. To the left the object relations, to the right an illustration of the tables.</p><p>Linux中的经典ARM32分页设置折叠P4D和PUD，每个PGD提供2048个指针，每个PMD提供1个指针，每个PTE提供512个指针。它使用层次结构的3个级别，而ARM32硬件只有两个级别。然而，正如我们将看到的，这是一个很好的契合。左边是对象关系，右边是表格的插图。</p><p> On LPAE the story is simpler: each PGD has 4 pointers covering 1GB each (for a total of 4GB of memory) and 512 pointers per PMD dividing each 1GB into 2MB chunks, then 512 pointers per PTE dividing the 2MB chunks into 4KB chunks (pages). The math should match up. The LPAE MMU can of course put more pointers into the PGD to cover up to 1TB of memory. Currently no ARM32 architectures need this so we just hammer it down to 4GB maximum for kernelspace. 4GB of kernelspace memory should be enough for everyone. Userspace is another story.</p><p>在LPAE上，情况更简单：每个PGD有4个指针，每个指针覆盖1 GB(总共4 GB内存)，每个PMD有512个指针，将每个1 GB分成2MB块，然后每个PTE有512个指针，把2MB块分成4KB块(页)。数学上应该是吻合的。当然，LPAE MMU可以将更多指针放入PGD，以覆盖高达1TB的内存。目前没有ARM32架构需要这个，所以我们将内核空间限制到最大4 GB。4 GB的内核空间内存应该足够每个人使用。用户空间则是另一回事。</p><p> The LPAE page table also folds P4D and PUD but has something meaningful on the PMD level: 4 PGD entries covering 1 GB each covers the whole 32bit address space, then there are 512 pointers per PMD and 512 pointers per PTE. Each PTE entry translate 4KB of physical memory to virtual memory. If we would fill the PGD with all the 512 available entries it would span exactly 1 TB of memory.</p><p>LPAE页表还折叠了P4D和PUD，但在PMD级别上有一些意义：4个PGD条目，每个条目覆盖1 GB，覆盖整个32位地址空间，那么每个PMD有512个指针，每个PTE有512个指针。每个PTE条目将4KB的物理内存转换为虚拟内存。如果我们用所有512个可用条目填充PGD，它将正好跨越1TB的内存。</p><p> So when we say that the classic ARM32 MMU has 2 levels of page tables, we are presenting this to Linux in a peculiar way as “3 levels” where the middle one is a single pointer, whereas the LPAE MMU actually has 3 levels. We are sorry for the confusion.</p><p>因此，当我们说经典的ARM32 MMU有2级页表时，我们以一种特殊的方式将其呈现给Linux，即“3级”，其中中间的一个是单指针，而LPAE MMU实际上有3级。给您带来的混乱，我们深表歉意。</p><p>  The pointer to an index in a directory is obtained with special inlined accessors that take a virtual address as parameter named for example  pmd_off() and those traverse the whole hierarchy to get to the offset of the right element in hierarchy:</p><p>指向目录中索引的指针是通过特殊的内联访问器获得的，这些内联访问器将虚拟地址作为名为pmd_off()的参数，并遍历整个层次结构以获得层次结构中右侧元素的偏移量：</p><p> static inline pmd_t *pmd_off(struct mm_struct *mm, unsigned long va){ return pmd_offset(pud_offset(p4d_offset(pgd_offset(mm, va), va), va), va);}</p><p>静态内联pmd_t*pmd_off(struct mm_struct*mm，unsign long va){pmd_offset(pud_offset(p4d_offset(pgd_offset(mm，va)，va)；}。</p><p> On ARM32 the P4D and PUD parts of this ladder will resolve to nothing, get “folded” and optimized out at compile-time. The  struct mm_struct *mm argument is the actual memory manager context (for the kernel this is  init_mm) which stores the pointer to the memory where the page global directory (PGD) actually resides. And that will the the symbol  swapper_pg_dir if we are running kernel code. This is how it actually happens in   include/linux/pgtable.h;</p><p>在ARM32上，这个梯子的P4D和PUD部分将解析为零，在编译时进行“折叠”和优化。Struct mm_struct*mm参数是实际的内存管理器上下文(对于内核，这是init_mm)，它存储指向页面全局目录(PGD)实际驻留的内存的指针。如果我们运行的是内核代码，这将是符号swapper_pg_dir。这就是include/linux/pgtable.h中实际发生的情况；</p><p> #define pgd_offset(mm, address) pgd_offset_pgd((mm)-&gt;pgd, (address))(...)static inline pgd_t *pgd_offset_pgd(pgd_t *pgd, unsigned long address){ return (pgd + pgd_index(address));};</p><p>#DEFINE PGD_OFFSET(mm，address)PGD_OFFSET_PGD((Mm)-&gt；pgd，(Address))(...)static inline pgd_t*pgd_Offset_pgd(pgd_t*pgd，无符号长地址){return(pgd+pgd_index(Address))；}；</p><p> In kernelspace mode the  mm argument is  init_mm and the  -&gt;pgd pointer points to  swapper_pg_dir, the kernel memory space root page table and equal to the location in virtual memory of the actual physical global page table. All index pointer accessors operate on this principle.</p><p>在内核空间模式中，mm参数是init_mm，-&gt；pgd指针指向swapper_pg_dir，这是内核内存空间根页表，等于实际物理全局页表在虚拟内存中的位置。所有索引指针访问器都按照这一原则操作。</p><p>  The virtual address for the page directory is  PAGE_OFFSET+0x3000 or  PAGE_OFFSET+0x4000 and  PAGE_OFFSET depends on the kernel VMSPLIT, but is typically  0xC0000000, kernel memory from  0xC0000000..0xFFFFFFFF. On ARM32 this base address, in physical memory, is set in  TTBR0 (Translation Table Base Register). Linux uses the symbol  swapper_pg_dir for this address. This is  0x5000 bytes in size for LPAE and  0x4000 bytes in size for the classic ARM MMU. If the kernel starts at the physical address  0xnnnn8000 it is at  0xnnnn8000-PG_DIR_SIZE so at  0xnnnn3000..0xnnnn7FFF for LPAE and  0xnnnn4000..0xnnnn7FFF for any other ARM. The most common location is at  0xC0004000..0xC0007FFF in virtual memory.</p><p>页面目录的虚拟地址是PAGE_OFFSET+0x3000或PAGE_OFFSET+0x4000，PAGE_OFFSET取决于内核VMSPLIT，但通常是0xC0000000，即来自0xC0000000..0xFFFFFFFF的内核内存。在ARM32上，物理内存中的此基址设置在TTBR0(转换表基址寄存器)中。Linux对此地址使用符号swapper_pg_dir。LPAE的大小为0x5000字节，传统ARM MMU的大小为0x4000字节。如果内核从物理地址0xnnnn8000开始，则它位于0xnnnn8000-PG_DIR_SIZE，因此对于LPAE为0xnnn3000..0xnnn7FFF，对于任何其他ARM为0xnnn4000..0xnnn7FFF。最常见的位置是虚拟内存中的0xC0004000..0xC0007FFF。</p><p> PTE page table entries and the associated types  pte_t and  pteval_t is of course purely a Linux concept. And that shows. Because what ARM32 MMUs are thinking about is not PTEs but coarse 2- or 3-level page tables of 4KB pages. It would be neat if Linux was engineered in a more flexible way to allow for a coarse page table to be  ONE PTE but it isn’t always the case, for old ARM32 systems it definitely is not.</p><p>PTE页表项和相关联的类型PTE_t和PTEVAL_t当然纯粹是一个Linux概念。这就说明了这一点。因为ARM32 MMU考虑的不是PTE，而是4KB页的粗糙2级或3级页表。如果Linux以一种更灵活的方式设计成允许一个粗页表为一个PTE，那将是很好的，但情况并不总是这样，对于旧的ARM32系统来说肯定不是这样的。</p><p> “Coarse” in this context means we start at a level-1 descriptor and see that for this 1MB of virtual memory we are using some smaller 4K pages so we have to look further: go and walk the page table ladder using the modified virtual address I give you here. ARM MMUs also have a concept of “fine” pages of just 1K. Linux does not use these. Yet.</p><p>在此上下文中的“粗略”意味着我们从1级描述符开始，并看到对于这1MB的虚拟内存，我们使用的是一些较小的4K页面，因此我们必须看得更远：使用我在这里给出的修改后的虚拟地址遍历页表阶梯。ARM MMU也有一个只有1K的“精细”页面的概念。Linux不使用这些。现在还不行。</p><p> We are here dealing with  PAGE_SIZE granularity, and Linux memory manager expects a PTE to be one page big and full of pointers so we will for example call  arm_pte_alloc() to allocate a new level-2 page (or level-3 on LPAE) table of  0x1000 (4096) bytes. That much is simple.</p><p>我们在这里处理page_size粒度，而Linux内存管理器期望PTE是一个页面大小且充满指针的页面，因此，例如，我们将调用arm_pte_alloc()来分配0x1000(4096)字节的新的2级页(或LPAE上的3级)表。这一点很简单。</p><p> The world is also reasonably simple on LPAE systems, because there the PTE is indeed one page, and it is populated by 512 entries of 64 bits / 8 bytes each, meaning we have 512 * 8 = 4096 bytes and it is a perfect match. Also these 64 bits fulfils the contract between Linux’ memory manager and the architecture of providing some MMU facilities such as a “dirty” bit. One PTE on a LPAE MMU is one page full of these coarse third level descriptors (remember that LPAE has three levels of pages). This nice fit will also be the case on the ARM64 / Aarch64 platform. End of story. Good for them!</p><p>在LPAE系统上也相当简单，因为PTE确实只有一页，并且由512个条目填充，每个条目64位/8字节，这意味着我们有512*8=4096字节，它是完美匹配的。此外，这64位还满足了Linux的内存管理器和提供一些MMU功能(如“脏”位)的体系结构之间的合同。LPAE MMU上的一个PTE是充满这些粗略的第三级描述符的一页(请记住，LPAE有三个级别的页)。这种良好的适应性在ARM64/Aarch64平台上也是如此。故事结束了。对他们来说太好了！</p><p> What is not so simple is how Linux utilize these 4096 bytes on the classic oldschool ARM MMU, which is described in   include/asm/pgtable-2level.h.</p><p>不是那么简单的是Linux如何在传统的ARM MMU上利用这4096个字节，这在include/asm/pgtable-2level.h中有描述。</p><p> What is done on the classic MMU is that we put the course page table index into the modified virtual address (MVA) field of the level-1 descriptor. This “coarse page table index” is in bits 10-31 of the level-1 descriptor (which is half a PGD entry, more about that later) and that corresponds to the highest 21 bits of the physical address of the level-2 page table. What is peculiar about the course page table index is that it does not correspond to a page in memory. Instead it corresponds to a quarter of a page. This is logical because level-2 page tables are 32 bit / 4 bytes and we need 256 of them to cover 1MB which is the coarseness of the level-1 descriptor, thus we need 256 * 4 = 1024 = 0x400 bytes. That’s one quarter of a 4KB page. So the coarse page table index points to a location in virtual memory indexed by the 0x400:th chunk. Which is mildly confusing.</p><p>在经典的MMU上所做的是，我们将课程页表索引放入1级描述符的修改的虚拟地址(MVA)字段中。该“粗页表索引”在1级描述符(其是半个PGD条目，稍后详述)的位10-31中，并且其对应于2级页表的物理地址的最高21位。课程页表索引的特殊之处在于它与内存中的页面不对应。相反，它相当于四分之一的页面。这是合乎逻辑的，因为2级页表是32位/4字节，我们需要其中的256个来覆盖1MB，这是1级描述符的粗细，因此我们需要256*4=1024=0x400字节。这是4KB页面的四分之一。因此，粗页表索引指向虚拟内存中由0x400：th块索引的位置。这有点让人困惑。</p><p> Further we have the following problem: ARMs classic MMU does not have all the “dirty” and “accessed”/”young” bits that the generic Linux virtual memory manager presuppose to exist in the architecture.</p><p>此外，我们还有以下问题：ARM经典MMU没有通用Linux虚拟内存管理器预先假定存在于体系结构中的所有“脏的”和“被访问的”/“年轻的”位。</p><p> One could imagine telling the Linux virtual memory manager that we have only 256 pointers per PTE, put some metadata in the remainder but end up using only half a page and waste lots of memory for the PTEs.</p><p>您可以想象一下，告诉Linux虚拟内存管理器，我们每个PTE只有256个指针，在剩余的指针中放入一些元数据，但最终只使用了半个页面，并且为PTE浪费了大量内存。</p><p> The actual solution, as implemented on ARM32 (I think this was invented by Russell King), is to squeeze in as much as possible in a page as follows:</p><p>在ARM32上实现的实际解决方案(我认为这是由Russell King发明的)是在一个页面中尽可能多地挤进去，如下所示：</p><p> Tell the Linux virtual memory manager that we have 512 page descriptors, which Linux calls “pointers” in a PTE, even though we know very well that the hardware has 256 of them. This is done by setting  PTRS_PER_PTE to 512 in   include/asm/pgtable-2level.h</p><p>告诉Linux虚拟内存管理器，我们有512个页描述符，Linux将其称为PTE中的“指针”，尽管我们很清楚硬件有256个。这是通过在include/asm/pgtable-2level.h中将PTRS_PER_PTE设置为512来实现的。</p><p> Tell it that we map 2 MB of memory in a PMD. This is done by defining  PMD_SHIFT to 21 in  include/asm/pgtable-2level.h. This is done despite the fact that we know very well that a level-1 descriptor maps 1 MB and not 2 MB of memory. We also make the page middle directory into a 1-to-1 directory with just one pointer per PMD:  PTRS_PER_PMD is set to 1.</p><p>告诉它我们在PMD中映射了2MB的内存。这是通过在include/asm/pgtable-2level.h中将pmd_shift定义为21来实现的。尽管我们非常清楚1级描述符映射的是1MB而不是2MB的内存，但我们还是这样做了。我们还将页面中间目录设置为1对1目录，每个pmd只有一个指针：ptrs_per_pmd设置为1。</p><p> Tell it that the PGD contains 2048 pointers (setting  PTRS_PER_PGD to 2048), while in fact the  0x4000 bytes of level-1 descriptors have 4096 pointers, that we just group in pairs.</p><p>告诉它PGD包含2048个指针(将PTRS_PER_PGD设置为2048)，而实际上0x4000字节的1级描述符有4096个指针，我们只是将它们成对分组。</p><p> Whenever the generic memory manager asks for a PGD entry we reference a PMD pointer with two level-1 page table descriptors.</p><p>每当通用内存管理器请求PGD条目时，我们都会引用具有两个1级页表描述符的PMD指针。</p><p> Whenever the generic memory manager asks for a PMD entry we reference a 1-to-1 entity.</p><p>每当通用内存管理器请求PMD条目时，我们都会引用1对1实体。</p><p> Whenever the generic memory manager asks for a PTE entry we reference two level-2 page table descriptors and two metadata entries of 32 bits each.</p><p>每当通用内存管理器请求PTE条目时，我们都会引用两个2级页表描述符和两个各32位的元数据条目。</p><p> We then occupy half a page with these two sets of level-2 descriptors. To solve the mapping problem for different “accessed” or “young” bits, we use the half page that is left to hold some metadata about what Linux has requested so we can do a bit of back-and-forward emulation of the features that Linux virtual memory manager wants.</p><p>然后，我们使用这两组2级描述符占据半个页面。为了解决不同“访问的”或“年轻的”位的映射问题，我们使用剩下的半页来保存一些关于Linux请求的元数据，这样我们就可以对Linux虚拟内存管理器需要的特性进行一些前后模拟。</p><p> We have effectively posed to the kernel virtual memory manager that we have an MMU with three levels of page tables: PGD (2048 pointers), PMD (one pointer) and PTE (512 pointers), while in fact we have two, and then behind the back of the generic virtual memory manger we do this optimization to adjust the map to reality.</p><p>我们已经有效地向内核虚拟内存管理器提出，我们有一个具有三个页表级别的MMU：PGD(2048个指针)、PMD(一个指针)和PTE(512个指针)，而实际上我们有两个，然后在通用虚拟内存管理器后面，我们进行此优化以使映射符合实际情况。</p><p> This is not so bad: the virtual memory manager is well aware that not the whole world uses all five levels of page tables it supports, so it has been written to “fold” levels like our artificial PMD already. This will work just fine.</p><p>这并不是很糟糕：虚拟内存管理器很清楚，并不是整个世界都使用它支持的所有五个级别的页表，所以它已经被写入到“折叠”级别，就像我们的人造PMD一样。这个会工作得很好的。</p><p> Alas, this is not a very simple solution. But it is very efficient, counterintuitive and complicated. Since operating system development can be pretty hard in the details, this is what we can expect.</p><p>唉，这不是一个非常简单的解决方案。但它非常高效，违反直觉，而且很复杂。由于操作系统开发在细节上可能相当困难，这是我们可以预期的。</p><p> The classic ARM32 MMU page table layout uses 32bit descriptors in two levels: two level-1 descriptors in the global page table (TTB, what Linux calls PGD, page global directory) are grouped into one PMD (page middle directory). There are 4096 level-1 descriptors grouped in pairs to form a PMD so there are 2048 PMDs. Then 256 + 256 = 512 level-1 page table pointers are grouped into one PTE (page table entry) with some metadata right above it. What Linux sees is a PMD managing 2MB and a PTE managing 256 4K pages which is also 2 MB. This way a PTE fills exactly one page of memory, which simplifies things. The 4K level-2 descriptors are referred to as “coarse”.</p><p>经典的ARM32 MMU页表布局在两个级别使用32位描述符：全局页表(TTB，Linux称之为PGD，页面全局目录)中的两个一级描述符被分组到一个PMD(页面中间目录)中。有4096个1级描述符成对分组以形成PMD，因此有2048个PMD。然后，256+256=512个一级页表指针被分组到一个PTE(页表条目)中，其正上方有一些元数据。Linux看到的是一个管理2MB的PMD和一个管理256个4K页面的PTE，也就是2MB。这样一来，PTE正好填满了一页内存，从而简化了事情。4K级别-2描述符被称为“粗略”。</p><p> An LPAE page table set-up on the other hand is simpler and deeper than the classic MMU: the descriptors are 64bit wide and include all the bits that Linux needs. A 64bit PUD entry covering the first 4GB of physical memory ( 0x00000000-0xFFFFFFFF) at typically at  0xC0003000 points to the PMD entries at  0xC0004000 and these are 64bit but cover 2MB each so they cover the same amount of virtual memory space as the classic MMU: instead of 1024 32 bit “coarse” entries covering 1MB each, we have 512 64bit entries covering 2MB each. This makes 1 PMD entry correspond to one level-2 page descriptor.</p><p>另一方面，LPAE页表设置比传统的MMU更简单、更深入：描述符是64位宽，并且包含Linux需要的所有位。覆盖第一个4 GB物理内存(0x00000000-0xFFFFFFFF)的64位PUD条目通常位于0xC0003000，指向位于0xC0004000的PMD条目，这些条目是64位的，但每个条目覆盖2MB，因此它们覆盖与经典MMU相同的虚拟内存空间量：我们有512个64位条目，而不是1024个32位“粗略”条目，每个条目覆盖1MB，每个条目覆盖2MB。这使得1个PMD条目对应于一个2级页面描述符。</p><p> The level-2 descriptor points to a level-3 descriptor which is also 64bits wide and covers 4KB. At the third level, 512 4KB descriptors cover 2MB and perfectly fill out exactly one 4KB page of memory. This descriptor layout fits hand-in-glove with Linux’ idea about PUD, PMD and PTE and makes things more intuitive. ARM64/Aarch64 also uses this style of page descriptors.</p><p>2级描述符指向3级描述符，该描述符也是64位宽，覆盖4KB。在第三级，512个4KB的描述符覆盖2MB，并且恰好填满了一个4KB的内存页。这种描述符布局符合Linux关于PUD、PMD和PTE的想法，并使事情更直观。ARM64/Aarch64也使用这种风格的页面描述符。</p><p> The LPAE page table layout is simpler and more intuitive than the classic MMU. 64bit pointers on each level in three levels, where one descriptor corresponds to one PUD, one PMD has 512 pointers to PTEs, and one PTE consists of exactly 512 translation pointers.</p><p>LPAE页表布局比传统的MMU更简单、更直观。在三个级别中的每个级别上的64位指针，其中一个描述符对应于一个PUD，一个PMD具有512个指向PTE的指针，并且一个PTE正好由512个翻译指针组成。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://people.kernel.org/linusw/arm32-page-tables">https://people.kernel.org/linusw/arm32-page-tables</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/arm32/">#arm32</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/page/">#page</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pgd/">#pgd</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>