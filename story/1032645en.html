<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在没有码头工人的情况下建造集装箱</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在没有码头工人的情况下建造集装箱</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-02 01:02:54</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/e2d2cb3132e376fe7f69d08d8c3d8a92.jpg"><img src="http://img2.diglog.com/img/2020/11/e2d2cb3132e376fe7f69d08d8c3d8a92.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In this post I&#39;ll outline several ways to build containers without the need for Docker itself. I&#39;ll use  OpenFaaS as the case-study, which uses OCI-format container images for its workloads. The easiest way to think about OpenFaaS is as a CaaS platform for  Kubernetes which can run microservices, and add in FaaS and event-driven tooling for free.</p><p>在这篇文章中，我将概述几种无需Docker本身即可构建容器的方法。我将使用OpenFaaS作为案例研究，它使用OCI格式的容器图像作为其工作负载。考虑OpenFaaS最简单的方式是将其作为Kubernetes的CaaS平台，它可以运行微服务，并免费添加FAAS和事件驱动工具。</p><p>  The first option in the post will show how to use the built-in buildkit option for Docker&#39;s CLI, then  buildkit stand-alone (on Linux only), followed by Google&#39;s container builder,  Kaniko.</p><p>帖子中的第一个选项将展示如何使用Docker的CLI的内置内置工具包选项，然后是独立构建工具包(仅限Linux)，然后是谷歌的容器构建器Kaniko。</p><p> Note: this post covers tooling which can build an image from a Dockerfile, and so anything which limits the user to only Java or Go for instance is out of scope.</p><p>注意：这篇文章介绍了可以从Dockerfile构建映像的工具，因此任何将用户限制为只能使用Java或Go的工具都不在讨论范围之内。</p><p> I&#39;ll then wrap things up and let you know how to get in touch with suggestions, feedback and your own stories around wants and needs in container tooling.</p><p>然后我会把事情做个总结，让你知道如何获得建议，反馈，以及你自己关于容器工具的需求和需求的故事。</p><p>  Nothing as such, Docker runs well on armhf, arm64, and on  x86_64. The main Docker CLI has become a lot more than build/ship/run, and also lugs around several years of baggage, it now comes bundled with Docker Swarm and EE features.</p><p>事实并非如此，Docker在armhf、arm64和x86_64上运行良好。主要的Docker CLI已经不仅仅是构建/装运/运行，而且还拖着几年的包袱，它现在捆绑了Docker Sarm和EE功能。</p><p> There are a few efforts that attempt to strip &#34;docker&#34; back to its component pieces, the original UX we all fell in love with:</p><p>有一些努力试图将Dock带回它的组件，我们都爱上了最初的UX：</p><p> Docker - docker itself now uses containerd to run containers, and has support for enabling buildkit to do highly efficient, caching builds.</p><p>Docker-docker本身现在使用tainerd来运行容器，并支持使buildkit执行高效的缓存构建。</p><p> Podman and  buildah combination - RedHat / IBM&#39;s effort, which uses their own OSS toolchain to generate OCI images. Podman is marketed as being daemonless and rootless, but still ends up having to mount overlay filesystems and use a UNIX socket.</p><p>Podman和buildah的结合-RedHat/IBM的努力，使用他们自己的OSS工具链来生成OCI图像。Podman的市场定位是无守护程序和无根目录，但最终仍必须挂载覆盖文件系统并使用UNIX套接字。</p><p> pouch - from Alibaba, pouch is billed as &#34;An Efficient Enterprise-class Container Engine&#34;. It uses containerd just like Docker, and supports both container-level isolation with  runc and &#34;lightweight VMs&#34; such as  runV. There&#39;s also more of a  focus on image distribution and strong isolation.</p><p>邮袋-来自阿里巴巴的邮袋被标榜为高效的企业级集装箱引擎。它和Docker一样使用了tainerd，并且既支持runc的容器级隔离，也支持像runV这样的轻量级VM。也有更多的重点放在形象传播和强烈的隔离上。</p><p> Stand-alone buildkit - buildkit was started by  Tõnis Tiigi from Docker Inc as a brand new container builder with caching and concurrency in mind. buildkit currently only runs as a daemon, but you will hear people claim otherwise. They are forking the daemon and then killing it after a build.</p><p>独立的buildkit-buildkit是由Docker Inc的Tónis Tiigi启动的，它是一家全新的容器生成器，考虑到了缓存和并发性。Buildkit目前只作为守护进程运行，但您会听到人们的说法并非如此。他们分叉守护进程，然后在构建后将其杀死。</p><p> img - img was written by  Jess Frazelle and is often quoted in these sorts of guides and is a wrapper for buildkit. That said, I haven&#39;t seen traction with it compared to the other options mentioned. The project was quite active  until late 2018 and has only received a few patches since. img claims to be daemonless, but it uses buildkit so is probably doing some trickery there. I hear that  img gives a better UX than buildkit&#39;s own CLI  buildctr, but it should also be noted that img is only released for  x86_64 and there are no binaries for armhf / arm64.</p><p>Img-img是由Jess Frazelle编写的，经常在这类指南中被引用，并且是构建工具包的包装器。这就是说，与提到的其他选择相比，我还没有看到它的吸引力。该项目在2018年底之前相当活跃，此后只收到了几个补丁。Img声称是无守护程序的，但它使用的是buildkit，所以很可能在那里做了一些诡计。我听说img提供了比buildkit自己的CLI buildctr更好的用户体验，但也应该注意到img只针对x86_64发布，并且没有针对armhf/arm64的二进制文件。</p><p> An alternative to  img would be  k3c which also includes a runtime component and plans to support ARM architectures.</p><p>Img的一个替代方案是k3c，它还包括一个运行时组件，并计划支持ARM架构。</p><p> k3c - Rancher&#39;s latest experiment which uses containerd and buildkit to re-create the original, classic, vanilla, lite experience of the original Docker version.</p><p>K3C-Rancher的最新实验，它使用容器和构建套件来重新创建原始的、经典的、香草的、轻便的原始Docker版本的体验。</p><p> Out of all the options, I think that I like k3c the most, but it is very nascient and bundles everything into one binary which is likely to conflict with other software, at present it runs its own embedded containerd and buildkit binaries.</p><p>在所有选项中，我认为我最喜欢k3c，但它非常新奇，将所有东西捆绑到一个二进制文件中，这可能会与其他软件冲突，目前它运行自己的嵌入式容器和构建工具包二进制文件。</p><p> Note: If you&#39;re a RedHat customer and paying for support, then you really should use their entire toolchain to get the best value for your money. I checked out some of the examples and saw one that used my &#34;classic&#34; blog post on multi-stage builds. See for yourself which style you prefer  the buildah example vs.  Dockerfile example.</p><p>注意：如果您是RedHat的客户并为支持付费，那么您真的应该使用他们的整个工具链来让您的钱物有所值。我查看了一些示例，看到其中一个使用了我关于多阶段构建的经典博客文章。自己看看您更喜欢buildah示例还是Dockerfile示例。</p><p> So since we are focusing on the &#34;build&#34; piece here and want to look at relativelt stable options, I&#39;m going to look at:</p><p>因此，由于我们这里的重点是构建部分，并且希望查看相对稳定的选项，因此我将介绍以下内容：</p><p>  All of the above and more are now possible since the OpenFaaS CLI can output a standard &#34;build context&#34; that any builder can work with.</p><p>由于OpenFaaS CLI可以输出任何构建器都可以使用的标准构建上下文，因此现在可以实现以上所有功能。</p><p>  Let&#39;s start with a Golang HTTP middleware, this is a cross between a function and a microservice and shows off how versatile OpenFaaS can be.</p><p>让我们从Golang HTTP中间件开始，这是函数和微服务的结合，展示了OpenFaaS的多功能性。</p><p>    ./├── build-test│ └── handler.go└── build-test.yml1 directory, 2 files</p><p>./├──Build-测试│└──处理程序.go└──Build-test.yml1目录，2个文件。</p><p> The handler looks like this, and is easy to modify. Additional dependencies can be added through vendoring or  Go modules.</p><p>处理程序看起来像这样，并且很容易修改。可以通过供应商或GO模块添加其他依赖项。</p><p> package functionimport (	&#34;fmt&#34;	&#34;io/ioutil&#34;	&#34;net/http&#34;)func Handle(w http.ResponseWriter, r *http.Request) {	var input []byte	if r.Body != nil {		defer r.Body.Close()		body, _ := ioutil.ReadAll(r.Body)		input = body	}	w.WriteHeader(http.StatusOK)	w.Write([]byte(fmt.Sprintf(&#34;Hello world, input was: %s&#34;, string(input))))}</p><p>包函数import(&#34；fmt&#34；&#34；io/ioutil&#34；&#34；net/http&#34；)函数句柄(w http.ResponseWriter，r*http.Request){var input[]byte if r.Body！=nil{defer r.Body.Close()Body，_：=ioutil.ReadAll(r.Body)input=body}w.WriteHeader(http.StatusOK)w.Write([]byte(fmt.Sprintf(&34；Hello world，输入为：%s&#34；，String(输入)}。</p><p>        The wait a few moments and you&#39;re done, we now have that image in our local library.</p><p>稍等片刻，你就完成了，现在我们当地的图书馆里有了这张照片。</p><p>    This is the easiest change of all to make, and gives a fast build too.</p><p>这是所有更改中最容易进行的，而且构建速度也很快。</p><p>  We&#39;ll see that with this approach, the Docker daemon automatically switches out its builder for buildkit.</p><p>我们将看到，使用这种方法，Docker守护进程会自动关闭buildkit的构建器。</p><p>  Running later instructions first, when possible - i.e. downloading the &#34;runtime&#34; image, before the build in the &#34;sdk&#34; layer is even completed</p><p>如果可能，请先运行后面的指令-即，甚至在SDK层中的构建完成之前下载运行时映像。</p><p> With buildkit, all of the base images can be pulled in to our local library at once, since the FROM (download) commands are not executed sequentially.</p><p>使用buildkit，可以一次将所有基本映像放入我们的本地库中，因为FROM(下载)命令不是按顺序执行的。</p><p>  This option works even on a Mac, since buildkit is proxied via the Docker daemon running in the VM.</p><p>即使在Mac上也可以使用此选项，因为buildkit是通过虚拟机中运行的Docker守护进程代理的。</p><p>   To build with Buildkit in a stand-alone setup we need to run buildkit separately on a Linux host, so we can&#39;t use a Mac.</p><p>要在独立设置中使用Buildkit进行构建，我们需要在Linux主机上单独运行Buildkit，因此我们不能使用Mac。</p><p> faas-cli build would normally execute or fork  docker, because the command is just a wrapper. So to bypass this behaviour we should write out a build context, that&#39;s possible via the following command:</p><p>Faas-cli build通常会执行或派生docker，因为命令只是一个包装器。因此，要绕过此行为，我们应该写出构建上下文，这可以通过以下命令实现：</p><p> faas-cli build -f build-test.yml --shrinkwrap[0] &gt; Building build-test.Clearing temporary build folder: ./build/build-test/Preparing ./build-test/ ./build/build-test//functionBuilding: alexellis2/build-test:latest with golang-middleware template. Please wait..build-test shrink-wrapped to ./build/build-test/[0] &lt; Building build-test done in 0.00s.[0] Worker done.Total build time: 0.00</p><p>Faas-cli build-f build-test.yml--reshrap[0]&gt；Building build-test.清除临时构建文件夹：./build/build-test/preparing./build-test/./build/build-test//function Building：alexellis2/build-test：最新的Golang中间件模板。请稍候..生成测试收缩包装到./build/build-test/[0]&lt；生成生成-测试在0.00s内完成。[0]个工作人员完成。总生成时间：0.00。</p><p> Our context is now available in the  ./build/build-test/ folder with our function code and the template with its entrypoint and Dockerfile.</p><p>我们的上下文现在位于./build/build-test/文件夹中，其中包含我们的函数代码以及模板及其入口点和Dockerfile。</p><p> ./build/build-test/├── Dockerfile├── function│ └── handler.go├── go.mod├── main.go└── template.yml1 directory, 5 files</p><p>./BUILD/BUILD-TEST/├──Dockerfile├──Function│└──Handler.go├──go.mod├──main.go└──template.yml1目录，5个文件</p><p> Now we need to run buildkit, we can build from source, or grab upstream binaries.</p><p>现在我们需要运行buildkit，我们可以从源代码构建，或者获取上游二进制文件。</p><p>  If you checkout the releases page, you&#39;ll also find buildkit available for armhf and arm64, which is great for multi-arch.</p><p>如果您查看发行版页面，您还会发现适用于armhf和arm64的构建工具包，这对于多拱门非常有用。</p><p>  sudo buildkitd WARN[0000] using host network as the default INFO[0000] found worker &#34;l1ltft74h0ek1718gitwghjxy&#34;, labels=map[org.mobyproject.buildkit.worker.executor:oci org.mobyproject.buildkit.worker.hostname:nuc org.mobyproject.buildkit.worker.snapshotter:overlayfs], platforms=[linux/amd64 linux/386] WARN[0000] skipping containerd worker, as &#34;/run/containerd/containerd.sock&#34; does not exist INFO[0000] found 1 workers, default=&#34;l1ltft74h0ek1718gitwghjxy&#34; WARN[0000] currently, only the default worker can be used. INFO[0000] running server on /run/buildkit/buildkitd.sock</p><p>SUDO buildkitd warn[0000]使用主机网络作为默认信息[0000]找到Worker&#34；l1ltft74h0ek1718gitwghjxy&#34；，labels=map[org.mobyproject.buildkit.worker.executor:oci org.mobyproject.buildkit.worker.hostname：nuc org.mobyproject.buildkit.worker.snapshotter:overlayfs]，Platforms=[Linux/AMD64Linux/386]warn[0000]正在跳过容器d Worker，因为&#34；/Run/Containerd/Containerd.sock&#34；不存在信息[0000]找到1个Worker，默认值=&#34；l1ltft74ek0gitwghjxy&#34；WARN[0000]目前，只能使用默认工人。INFO[0000]在/run/buildkit/buildkitd.sock上运行服务器。</p><p> Now let&#39;s start a build, passing in the shrink-wrapped location as the build-context. The command we want is  buildctl, buildctl is a client for the daemon and will configure how to build the image and what to do when it&#39;s done, such as exporting a tar, ignoring the build or pushing it to a registry.</p><p>现在，让我们开始一个构建，将收缩包装的位置作为构建上下文传入。我们需要的命令是buildctl，buildctl是守护进程的客户端，它将配置如何构建映像以及完成后要执行的操作，例如导出tar、忽略构建或将其推送到注册表。</p><p> buildctl build --helpNAME: buildctl build - buildUSAGE: To build and push an image using Dockerfile: $ buildctl build --frontend dockerfile.v0 --opt target=foo --opt build-arg:foo=bar --local context=. --local dockerfile=. --output type=image,name=docker.io/username/image,push=true OPTIONS: --output value, -o value Define exports for build result, e.g. --output type=image,name=docker.io/username/image,push=true --progress value Set type of progress (auto, plain, tty). Use plain to show container output (default: &#34;auto&#34;) --trace value Path to trace file. Defaults to no tracing. --local value Allow build access to the local directory --frontend value Define frontend used for build --opt value Define custom options for frontend, e.g. --opt target=foo --opt build-arg:foo=bar --no-cache Disable cache for all the vertices --export-cache value Export build cache, e.g. --export-cache type=registry,ref=example.com/foo/bar, or --export-cache type=local,dest=path/to/dir --import-cache value Import build cache, e.g. --import-cache type=registry,ref=example.com/foo/bar, or --import-cache type=local,src=path/to/dir --secret value Secret value exposed to the build. Format id=secretname,src=filepath --allow value Allow extra privileged entitlement, e.g. network.host, security.insecure --ssh value Allow forwarding SSH agent to the builder. Format default|&lt;id&gt;[=&lt;socket&gt;|&lt;key&gt;[,&lt;key&gt;]]</p><p>Buildctl build--help名称：buildctl build-buildUSAGE：使用Dockerfile构建和推送映像：$buildctl build--front dockerfile.v0--opt target=foo--opt build-arg：foo=bar--local context=。--本地dockerfile=。--output type=image，name=docker.io/username/image，ush=true选项：--output value，-o value定义构建结果的导出，例如--output type=image，name=docker.io/username/image，ush=true--进度值设置进度类型(auto、Plan、tty)。使用PLAN显示容器输出(默认值：&#34；auto&#34；)--跟踪文件的跟踪值路径。默认为无跟踪。--本地值允许构建访问本地目录--前端值定义用于构建的前端--opt值定义前端的自定义选项，例如--opt target=foo--opt build-arg：foo=bar--no-cache禁用所有顶点的缓存--export-cache值导出构建缓存，例如--export-cache type=register，ref=example.com/foo/bar，或-export-cache type=local，est=path/to/dir-import-cache value Import build cache，例如-import-cache type=Registry，ref=example.com/foo/bar，或者--import-cache type=local，src=path/to/dir--向构建公开的保密值Secret值。Format id=Secretname，src=filepath--allow值允许额外的特权授权，例如network.host、security.insecure--ssh值允许将SSH代理转发到构建器。格式化default|&lt；id&gt；[=&lt；socket&gt；|&lt；key&gt；[，&lt；键&gt；]]。</p><p> Here&#39;s what I ran to get the equivalent of the Docker command with the  DOCKER_BUILDKIT override:</p><p>下面是我运行以获取带有DOKER_BUILDKIT覆盖的DOKER命令的等价物：</p><p> sudo -E buildctl build --frontend dockerfile.v0 \ --local context=./build/build-test/ \ --local dockerfile=./build/build-test/ \ --output type=image,name=docker.io/alexellis2/build-test:latest,push=true</p><p>SUDO-E buildctl build--前端dockerfile.v0\--本地上下文=./build/build-test/\--local dockerfile=./build/build-test/\--output type=image，name=docker.io/alexellis2/build-test：Latest，Push=true。</p><p> Before running this command, you&#39;ll need to run  docker login, or to create $HOME/.docker/config.json` with a valid set of unencrypted credentials.</p><p>在运行此命令之前，您需要运行docker login，或者使用一组有效的未加密凭据创建$HOME/.docker/config.json`。</p><p>    Since I&#39;ve never used  img and haven&#39;t really heard of it being used a lot with teams vs the more common options I thought I&#39;d give it a shot.</p><p>因为我从来没有用过img和apper，也没有听说过它在团队中经常被使用，而不是更常见的选择，我想我会试一试的。</p><p> First impressions are that multi-arch is not a priority and given the age of the project, may be unlikely to land. There is no binary for armhf or ARM64.</p><p>第一印象是，多拱不是优先考虑的，考虑到项目的年龄，可能不太可能落地。没有用于ARMF或ARM64的二进制文件。</p><p> For  x86_64 the latest version is  v0.5.7 from 7 May 2019, built with Go 1.11, with Go 1.13 being the current release:</p><p>对于x86_64，最新版本是2019年5月7日发布的v0.5.7，使用GO 1.11构建，GO 1.13是当前版本：</p><p>   img build --helpUsage: img build [OPTIONS] PATHBuild an image from a Dockerfile.Flags: -b, --backend backend for snapshots ([auto native overlayfs]) (default: auto) --build-arg Set build-time variables (default: []) -d, --debug enable debug logging (default: false) -f, --file Name of the Dockerfile (Default is &#39;PATH/Dockerfile&#39;) (default: &lt;none&gt;) --label Set metadata for an image (default: []) --no-cache Do not use cache when building the image (default: false) --no-console Use non-console progress UI (default: false) --platform Set platforms for which the image should be built (default: []) -s, --state directory to hold the global state (default: /home/alex/.local/share/img) -t, --tag Name and optionally a tag in the &#39;name:tag&#39; format (default: []) --target Set the target build stage to build (default: &lt;none&gt;)</p><p>Img build--help用法：img build[Options]PATH从Dockerfile构建映像。标志：-b，--快照后端([auto ative overlayfs])(默认值：AUTO)--build-arg设置构建时间变量(默认值：[])-d，--debug enable debug log(默认值：false)-f，--Dockerfile的文件名(默认值为&#39；path/Dockerfile&39；)(默认值：&lt；None&gt；)--映像的标签集元数据(默认值：[])--no-缓存在构建映像时不使用缓存(默认值：false)--no-控制台使用非控制台进度UI(默认值：false)--应为其构建映像的平台设置平台(默认值：[])-s，--保存全局状态的状态目录(默认值：/home/alex/.local/share/img)-t，--标记名和&#39中的标记(可选)；名称：tag&#39；Format(默认值：[])--target将目标构建阶段设置为Build(默认值：&lt；None&gt；)。</p><p>   Now for one reason or another,  img actually failed to do a successful build. It may be due to some of the optimizations to attempt to run as non-root.</p><p>现在，由于这样或那样的原因，img实际上未能成功构建。这可能是由于尝试以非root用户身份运行的一些优化所致。</p><p>  fatal error: unexpected signal during runtime execution[signal SIGSEGV: segmentation violation code=0x1 addr=0xe5 pc=0x7f84d067c420]runtime stack:runtime.throw(0xfa127f, 0x2a)	/home/travis/.gimme/versions/go1.11.10.linux.amd64/src/runtime/panic.go:608 +0x72runtime.sigpanic()	/home/travis/.gimme/versions/go1.11.10.linux.amd64/src/runtime/signal_unix.go:374 +0x2f2goroutine 529 [syscall]:runtime.cgocall(0xc9d980, 0xc00072d7d8, 0x29)	/home/travis/.gimme/versions/go1.11.10.linux.amd64/src/runtime/cgocall.go:128 +0x5e fp=0xc00072d7a0 sp=0xc00072d768 pc=0x4039eeos/user._Cfunc_mygetgrgid_r(0x2a, 0xc000232260, 0x7f84a40008c0, 0x400, 0xc0004ba198, 0xc000000000)</p><p>致命错误：运行时执行期间出现意外信号[信号SIGSEGV：分段违规代码=0x1Addr=0xe5 pc=0x7f84d067c420]运行时堆栈：runtime.jo(0xfa127f，0x2a)/home/travis/.gimme/versions/go1.11.10.linux.amd64/src/runtime/panic.go:608+0x72runtime.sigPanic()/home/travis/.gimme/versions/go1.11.10.linux.amd64/src/runtime/signal_unix.go:374+0x2f2goroutine529[syscall]：runtime.cgocall(0xc9d980，0xc00072d7d8，0x29)/home/travis/.gimme/versions/go1.11.10.linux.amd64/src/runtime/cgocall.go:128+0x5e fp=0xc00072d7a0 sp=0xc00072d768 pc=0x4039eeos/user._cfunc_mygetgrgid_r(0x2a，0xc000232260，0x7f84a40008c0，0x400，0xc0004ba198，0xc000000000)。</p><p>   Kaniko is Google&#39;s container builder which aims to sandbox container builds. You can use it as a one-shot container, or as a stand-alone binary.</p><p>Kaniko是Google的容器建造者，其目标是沙箱容器构建。您可以将其用作一次性容器，也可以用作独立的二进制文件。</p><p>  docker run -v $PWD/build/build-test:/workspace \ -v ~/.docker/config.json:/kaniko/config.json \ --env DOCKER_CONFIG=/kaniko \ gcr.io/kaniko-project/executor:latest \ -d alexellis2/build-test:latest</p><p>Docker run-v$pwd/build/build-test：/workspace\-v~/.docker/config.json：/kaniko/config.json\--env docker_config=/kaniko\gcr.io/kaniko-project/Executor：Latest\-d alexellis2/build-test：Latest</p><p> The  -v flag is bind-mounting the current directory into the Kaniko container, it also adds your  config.json file for pushing to a remote registry.</p><p>V标志将当前目录绑定挂载到Kaniko容器中，它还会添加您的config.json文件以推送到远程注册表。</p><p>  There is some support for caching in Kaniko, but it needs manual management and preservation since Kaniko runs in a one-shot mode, rather than daemonized like Buildkit.</p><p>Kaniko中有一些对缓存的支持，但它需要手动管理和保存，因为Kaniko以一次性模式运行，而不是像Buildkit那样以守护方式运行。</p><p>  Installing Docker can be heavy-weight and add more than expected to your system. The builder is the oldest and slowest, but gets the job done. Watch out for the networking bridge installed by Docker, it can conflict with other private networks using the same private IP range.</p><p>安装Docker可能会很繁重，并且会给您的系统添加比预期更多的内容。建筑工人年纪最大，速度最慢，但却能完成工作。注意Docker安装的网桥，它可能会与使用相同内网网段的其他内网冲突。</p><p> This is the fastest option with the least amount of churn or change. It&#39;s simply enabled by prefixing the command  DOCKER_BUILDKIT=1</p><p>这是最快的选择，也是最少的改动。只需为命令DOKER_BUILDKIT=1添加前缀即可启用它。</p><p> This option is great for in-cluster builds, or a system that doesn&#39;t need Docker such as a CI box or runner. It does need a Linux host and there&#39;s no good experience for using it on MacOS, perhaps by running an additional VM or host and accessing over TCP?</p><p>此选项对于群集内构建或不需要Docker的系统(如CI Box或Runner)非常有用。它确实需要一台Linux主机，而且在MacOS上使用它没有很好的体验，也许是通过运行额外的虚拟机或主机并通过TCP访问？</p><p> I also wanted to include a presentation by [Akihiro Suda]( https://twitter.com/@ AkihiroSuda /), a buildkit maintainer from NTT, Japan. This information is around 2 years old but provides another high-level overview from the landscape in 2018  Comparing Next-Generation Container Image Building Tools</p><p>我还想加入[Akihiro Suda](https://twitter.com/@AkihiroSuda/)的演示文稿，他是来自日本ntt的构建工具包维护员。此信息已有2年的历史，但提供了2018年比较下一代容器映像构建工具的另一个高级概述。</p><p> This is the best option for  faasd users, where users rely only on containerd and CNI, rather than Docker or Kubernetes.</p><p>对于faasd用户来说，这是最好的选择，因为他们只依赖tainerd和cni，而不是docker或kubernetes。</p><p> The way we used Kaniko still required Docker to be installed, but provided another option.</p><p>我们使用Kaniko的方式仍然需要安装Docker，但提供了另一种选择。</p><p>  You can either use your normal container builder with OpenFaaS, or  faas-cli build --shrinkwrap and pass the build-context along to your preferred tooling.</p><p>您可以将普通容器构建器与OpenFaaS一起使用，也可以使用faas-cli build--definsprap并将构建上下文传递给您的首选工具。</p><p>   In  OpenFaaS Cloud. we provide a complete hands-off CI/CD experience using the shrinkwrap approach outlined in this post and the buildkit daemon. For all other users I would recommend using Docker, or Docker with buildkit. For faasd, use buildkit daemonized.</p><p>在OpenFaaS云中。我们使用本文中概述的包络处理方法和buildkit守护程序提供完全不干预的CI/CD体验。对于所有其他用户，我建议使用Docker，或者使用Docker with buildkit。对于faasd，使用buildkit daemonized。</p><p> We did miss out one of the important parts of the workflow in this post, the deployment. Any OCI container can be deployed to the OpenFaaS control-plane on top of Kubernetes as long as its  conforms to the serverless workload definition. If you&#39;d like to see the full experience of build, push and deploy, check out the  OpenFaaS workshop.</p><p>在这篇文章中，我们确实遗漏了工作流的一个重要部分，即部署。任何OCI容器都可以部署到Kubernetes之上的OpenFaaS控制平面，只要它符合无服务器工作负载定义。如果您想了解构建、推送和部署的完整体验，请访问OpenFaaS研讨会。</p><p>   Let me know what you think to the post and what tooling you are most excited about for 2020  on Twitter @alexellisuk.</p><p>在twitter@alexellisuk上让我知道你对这篇帖子的看法，以及你在2020年最感兴趣的工具是什么。</p><p> Hire me for Cloud Native / Docker / Go / CI &amp; CD or Kubernetes</p><p>聘用我购买Cloud Native/Docker/Go/CI&amp；CD或Kubernetes。</p><p> Could you use some help with a difficult problem, an external view on a new idea or project? Perhaps you would like to build a technology proof of concept before investing more? Get in touch via  alex@openfaas.com or book a session with me on  calendly.com/alexellis.</p><p>你是否需要一些帮助来解决一个难题，一个新想法或项目的外部观点？也许您想在进行更多投资之前建立一个技术概念验证？请通过alex@openfaas.com与我联系，或在calendly.com/alexellis上预订与我的会议。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.alexellis.io/building-containers-without-docker/">https://blog.alexellis.io/building-containers-without-docker/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/docker/">#docker</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/码头工人/">#码头工人</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/构建/">#构建</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>