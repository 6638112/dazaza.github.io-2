<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>将Webhook建立在您的应用程序中：指南和最佳实践（2020） Building Webhooks into Your Application: Guidelines and Best Practices (2020)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Building Webhooks into Your Application: Guidelines and Best Practices (2020)<br/>将Webhook建立在您的应用程序中：指南和最佳实践（2020） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-11 00:41:05</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/12b288ce3a9b2c5eabad7b2be634cd22.png"><img src="http://img2.diglog.com/img/2021/3/12b288ce3a9b2c5eabad7b2be634cd22.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>If your application is generating data that’s of interest to your customers (i.e. you’re doing something right), you’re going to get requests for webhooks at some point. But there’s not a ton of standard guidance for how to build them, especially on the security side. This post will walk through the basics of how to send out webhooks from your app, manage authentication, handle security, and provide a smooth developer experience to your customers. ‍</p><p>如果您的申请正在生成您的客户感兴趣的数据（即，您正在做正确的事情），您将在某些时候为Webhooks获取Lequeed。但是如何建立它们的标准指导，特别是在安全方面。此帖子将通过如何从应用程序发送Webhooks的基础知识，管理身份验证，处理安全性，并为您的客户提供平滑的开发人员体验。</p><p> Webhooks are reverse APIs, so they need non-standard infrastructureThe starting point for building webhooks is that your app is generating data that your customers want. Generally, you’d expose that via an API, authenticate your users with an API key, etc. - but the difference with webhooks is that your customers want to be  proactively notified of what’s happening in your app. Your API is built to  receive and respond to requests, while webhooks  actively send out data to other systems based on internal triggers. That requires you to persist information on where you’re supposed to be sending data to, and the status of those endpoints.</p><p> Webhooks是反向API，因此他们需要非标基础设施的基础设施用于构建Webhooks的起点是您的应用程序正在生成客户想要的数据。通常，您可以通过API公开，使用API​​密钥等对您的用户进行身份验证 - 但与Webhooks的差异是您的客户希望主动通知您的应用程序中发生的事情。您的API是为了接收和响应请求，而Webhooks积极向基于内部触发的其他系统发送数据。这需要您持续有关您应该将数据发送到数据的信息以及那些端点的状态。</p><p>  A database to store endpoints (and associated metadata) that your webhook sends data to [backend]</p><p>  数据库以存储Webhook将数据发送到[后端]的端点（和关联元数据）</p><p> As with anything, this can get as complicated (a Kafka topic with a webhook consumer) or as simple (Lambda) as you want it to be. More on that later.</p><p> 与任何东西一样，这可以像你想要的那样复杂（带有Webhook消费者的Kafka主题）或简单（Lambda）。更稍后的更多信息。</p><p> Finally, before we dive in, it’s important to define terminology, since things can get confusing:</p><p> 最后，在我们潜入之前，重要的是要定义术语，因为事情可能会令人困惑：</p><p> Your app is the webhook  provider - you are sending out POST requests triggered by events in your system</p><p> 您的应用程序是Webhook Provider  - 您正在发送由系统中的事件触发的POST请求</p><p> Other developers and their apps are  consumers - they are  receiving your webhooks at their endpoints</p><p> 其他开发人员及其应用是消费者 - 他们正在收到您的终点 </p><p> Slack uses the “outgoing” vs. “incoming” terminology, but the idea is the same.</p><p>松弛使用“传出”与“传入”术语，但这个想法是一样的。</p><p>  Handling authentication with webhooks is slightly trickier than with an API, because you’re sending data to an endpoint without receiving anything back - there are a lot of ways that can go wrong (spoofing the endpoint, infiltrating the network, etc.). That’s just from your end - the  consumer also needs to verify that the data coming into  their webhook endpoint (the accepts webhook events) is actually from your app, and hasn’t been spoofed / corrupted in transit.</p><p>  使用Webhooks处理身份验证比使用API​​略微棘手，因为您正在向端点发送数据而不接收任何回报 - 有很多方法可能出错（欺骗端点，渗透网络等）。这只是你的最终 - 消费者还需要验证进入其WebHook端点的数据（接受Webhook事件）实际上来自您的应用程序，并且在运输过程中尚未被欺骗/损坏。</p><p> The first thing you need to do is  verify that the developer signing up to subscribe to your webhook actually owns the endpoint they’re giving to you. Standard practice is to send a test event to the endpoint, and ask the developer to verify they’ve received it - either by returning a 200, or by including a “challenge” that the endpoint needs to echo back. For example,  Dropbox verifies webhook endpoints by sending a GET request with a “challenge” param (a random string) encoded in the URL, which your endpoint is required to echo back as a response.</p><p> 您需要做的第一件事是验证登录以订阅WebHook的开发人员实际上拥有他们给您的端点。标准做法是将测试事件发送到端点，并要求开发人员验证他们是否通过返回200，或者包括“挑战”，即端点需要回音。例如，DropBox通过在URL中编码的“挑战”Param（一个随机字符串）发送Get请求来验证WebHook端点，您的端点需要将其作为响应回应。</p><p> But verifying the endpoint doesn’t solve the whole problem, because endpoints can still be spoofed, networks are uncertain, etc. There are basically two ways to tackle the auth problem: ‍</p><p> 但是验证端点无法解决整个问题，因为端点仍然可以欺骗，网络不确定等等，基本上有两种方法来解决AUTH问题：</p><p>  This is the easiest way to avoid problems, and is the approach that Dropbox takes. When an event happens in their system (e.g. a document gets updated), they’ll send out a webhook that says something along the lines of “the document with an ID of 1234 has been updated by user 1234” - this information is completely useless by itself, so you’ll need to follow up by making requests to the API that translate those IDs into whatever information you need to take action on the webhook’s information. But it also means that if a third party gets ahold of the webhook’s payload, they can’t do anything with it.</p><p>  这是避免问题的最简单方法，是Dropbox所需的方法。当一个事件发生在他们的系统中（例如，文档变得更新）时，他们会发出一个Webhook，它沿着“用户1234更新了ID为1234的文档的文档” - 此信息完全无用本身，因此您需要通过对API的请求进行跟进，以将这些ID转换为您需要在Webhook的信息中采取行动的任何信息。但它也意味着如果第三方获得网络哈克的有效载荷，他们就无法做到任何事情。</p><p>   The other more labor intensive way to handle auth is to actually... handle auth. You need to approach this from two ways: authenticating  yourself as the sender, and authentication the  consumer (endpoint) you’re sending data to. ‍</p><p>   其他更多的劳动密集型来处理验证就是实际上......处理验证。您需要从两种方式接近这一点：将自己验证为发件人，并认证您将数据发送到的消费者（端点）。</p><p>  ‍To verify to your webhook consumers that you indeed are who you say you are (and the data you’re sending via your webhook is legit), you can sign your webhook payload with a secret key. It’s easiest to do this symmetrically, but you can also use public/private encryption if you want. Stripe  signs their webhook payloads with a symmetrical secret key in the request header, and gives users access to that key in their dashboard so they can verify the signature at their endpoint.  ‍</p><p>  要验证您的WebHook消费者，您确实是您所说的是谁（以及您通过Webhook发送的数据是合法的），您可以使用秘密密钥签署Webhook有效载荷。它最容易对称这样做，但如果您愿意，您也可以使用公共/私人加密。条纹在请求标题中使用对称秘密密钥签署其Webhook有效载荷，并使用户在仪表板中访问该键，以便它们可以在其端点验证签名。 </p><p>  Once you’ve verified yourself to your consuming endpoints, you’ll want to think about how to verify the consuming endpoints themselves, and that the sensitive data you’re sending in your webhook payload isn’t susceptible to hacking. There are two ways to approach this: ‍</p><p>一旦您验证了您的消费端点，您将想考虑如何验证消费的端点本身，并且您在WebHook有效载荷中发送的敏感数据并不容易被黑客攻击。有两种方法可以解决这个问题：</p><p>  This is fairly uncommon among major webhook providers (Dropbox, Stripe, Twilio, etc.) and requires some extra work on both your and your consumers’ end; but it ensures pretty tight security. ‍</p><p>  这在主要的Webhook提供商（Dropbox，Stripe，Twilio等）中相当不常见，并且需要在您和您的消费者结束时进行一些额外的工作;但它确保安全性密切紧张。</p><p>  This is the most common way to handle payload security: only send data over HTTPS (this should be obvious by now), and require your consumer to provide the specific certificate they’re using. For example, Twilio  won’t send webhook data to HTTPS endpoints with self signed certificates.</p><p>  这是处理有效载荷安全性最常见的方法：只通过HTTPS发送数据（即现在应该是显而易见的），并要求您的消费者提供他们使用的特定证书。例如，Twilio不会将Webhook数据发送到HTTPS端点，使用自签名证书。</p><p> You’ve probably realized by now that there’s an impossible tradeoff here between developer experience and security. Sending no useful information in webhooks minimizes security risk, but requires a lot more work for the consumer. Including info in the webhook payload makes for a smooth developer experience, but is hard to do perfectly securely. That, and the fact that security  is part of the developer experience, means you’ll need to weigh the risks and choose what’s best for your application.</p><p> 你现在可能意识到，在开发人员体验和安全之间存在不可能的权衡。在Webhook中发送没有有用的信息可最大限度地减少安全风险，但需要对消费者进行更多的工作。包括Webhook有效载荷的信息，可以实现平滑的开发人员体验，但很难完全安全。这样，安全是开发人员体验的一部分，意味着您需要权衡风险并选择最适合您的应用程序。</p><p>  Your webhook system will  not be a perfect message queue, and you shouldn’t try to make it one - even  companies like Stripe guarantee almost no integrity around ordering, number of events sent, and other ergonomics that you’d expect as a consumer. The general rule - and expectation from your consuming developers - is that you’ll send events  at least once, but that’s about it. ‍</p><p>  您的Webhook系统不会是一个完美的消息队列，您不应该尝试使其成为一个 - 偶数公司，如条纹的保证几乎没有完整的订单，发送的事件数量以及您作为消费者所期望的其他人体工程学。普遍规则 - 以及您消费开发人员的期望 - 是您至少会发出一次活动，但这是关于它的。</p><p>  When you send your POST requests to the endpoints in your database, some of them will inevitably fail (DNS issues, incorrect routing, etc.). You want to retry to some degree, but not constantly and not forever. General best practices:</p><p>  当您将POST请求发送到数据库中的端点时，其中一些将不可避免地失败（DNS问题，不正确的路由等）。你想在某种程度上重试，但不是不断而不是永远。一般性最佳实践：</p><p> Use exponential backoff to slowly increase the time between your retries. To avoid laughably large wait periods, set a maximum backoff time (usually once a day) via  truncated exponential backoff (this is, coincidentally,  how GCP handles their Pubsub topics).</p><p> 使用指数退避以慢慢增加重试之间的时间。为了避免大大的等待时间，通过截短的指数退避设置最大的退避时间（通常每天一次）（这是巧合，GCP如何处理其Pubsub主题）。 </p><p> If an endpoint hasn’t been responding for a while, mark it as “broken” in your endpoints database and stop sending requests to it.</p><p>如果端点尚未响应一段时间，请将其标记为端点数据库中的“已损坏”并停止向其发送请求。</p><p> Once you’ve marked an endpoint as broken, send an email to the developer notifying them that you’ve been unable to reach the endpoint and they need to fix it.</p><p> 一旦您将端点标记为损坏，请向开发人员发送电子邮件，通知他们您无法到达端点，并且他们需要修复它。</p><p> Ideally, all of your consuming endpoints should be returning 200s to all of your POST requests. If they’re not, that’s what you can use to determine retries / failure.  ‍</p><p> 理想情况下，您的所有消费端点都应该向所有帖子请求返回200多岁。如果他们不是，那就是你可以用来确定重试/失败的东西。</p><p>  Webhook providers typically do not guarantee that events will make it to consuming endpoints in order. See, for example,  Stripe:</p><p>  Webhook提供商通常不会保证事件将其符合终点。请参阅，例如，stripe：</p><p>   Webhook providers typically also do not guarantee how  many events they’ll send via webhooks, so consumers will need to make their endpoints idempotent to some degree. See, for example,  Dropbox:</p><p>   Webhook提供商通常也不保证他们将通过Webhook发送多少事件，因此消费者需要在某种程度上宽容地估中其终点。请参阅，例如，Dropbox：</p><p>  There’s overlap between events being out of order, concurrency, and duplicates (as you can see in the above screenshot). In general, you  can spend time on improving your webhook system to try and avoid some of these issues, but it’s pretty rare to see in the wild.</p><p>  事件之间存在无序，并发和重复之间的事件之间存在重叠（如上可以在上面的屏幕截图中看到）。一般来说，您可以花时间在改进Webhook系统上尝试避免这些问题，但在野外看起来很罕见。</p><p>  As you start working on building a webhooks system, there are a couple of things you can set up early that will make things smoother (beyond your fancy Vim setup). ‍</p><p>  当您开始在构建Webhooks系统时，您可以提前设置一些事情，这将使事情更顺畅（超出您的花哨的Vim设置）。 </p><p>  Sending POST requests locally - especially as you’re debugging auth - won’t work, as a local dev server isn’t available to the public internet, and so it won’t be able to receive webhooks from the provider service. You’ll need to test against a public URL – you can set up a simple server as a test endpoint, or just use something like  ngrok to tunnel to your localhost. ‍</p><p>在本地发送POST请求 - 尤其是您正在调试AUTH  - 不起作用，因为公共互联网无法使用本地DEV服务器，因此它将无法从提供商服务接收Webhooks。您需要对公共URL进行测试 - 您可以将简单的服务器设置为测试端点，或者只使用NGROK等内容到隧道到您的localhost。</p><p>  It’s worth investing time up front to build a library of sample events you’d want to send out via webhooks. Otherwise you’ll get stuck needing to trigger things in your app, or worse, via external providers like Okta (if you want to send out a webhook when a user authenticates, etc.).</p><p>  值得注意的是，前面建立一个你想通过Webhook发出的样本事件库。否则，您将通过像OKTA这样的外部提供商触发应用程序中的东西或更糟糕的是，如果您想在用户身份验证等时发送Webhook等），则需要触发应用程序。</p><p>   As mentioned above, you’ll need some sort of database to store all of the endpoints you’re sending webhooks out to. The schema should look something like:</p><p>   如上所述，您需要某种数据库来存储您将Webhooks发送到的所有端点。架构应该看起来像：</p><p>  There’s really no good reason to use anything other than a simple relational database for this to start, as it’s unlikely this table will scale to anything that will give you problems. ‍</p><p>  除了一个简单的关系数据库之外，真的没有充分的理由以此为此开始，因为这张表不太可能会扩展到会给你有问题的任何东西。</p><p>  It’s helpful to log every time a webhook gets sent out (along with the payload, time sent, etc.) for debugging (and compliance) purposes down the road.  ‍</p><p>  每当Webhook被发送（以及有效载荷，时间发送等）时，它都会有助于调试（和遵守）目的。</p><p>  This is more of a high level architectural note, but it’s worth nothing that there should be a layer of separation between what’s happening in your business systems (&#34;an event&#34;) and the actions that you take based on that event (like sending out a webhook). If something goes wrong with your webhooks, you don’t want that to impact other pieces of your application.</p><p>  这更像是一个高级架构音符，但它的业务系统发生在发生的情况（＆＃34;事件＆＃34;）以及您根据该事件所采取的行为之间应该有一层分离。 （就像发出Webhook）。如果您的Webhooks出现问题，您不希望将其影响您的其他应用程序。</p><p>  Stripe provides webhooks whenever an event happens (customer created, card charged, etc.). You can add your endpoint(s) via the UI (below), or through  Stripe’s webhooks API (yes, an API for configuring Stripe webhooks).</p><p>  条纹在发生事件时提供Webhooks（客户创建，卡收费等）。您可以通过UI（下面）或通过条带的Webhooks API（是的，用于配置条带Webhook的API）添加您的端点。 </p><p>  If you’re a consumer, you can accept all of these webhooks on one endpoint, or set up multiple endpoints (one for each event) - in the latter case, the API is probably more useful. Here’s what a sample POST request to add a new webhook endpoint looks like (from  Stripe’s docs):</p><p>如果您是消费者，您可以在一个端点上接受所有这些WebHooks，或者设置多个端点（每个事件一个） - 在后一种情况下，API可能更有用。以下是添加新的Webhook端点的样本发布请求看起来像（来自Stripe的Docs）：</p><p>  Like we covered above, Stripe does  not guarantee ordering of events, and events may show up in duplicates as well.  Their system expects your endpoint to return a 2xx  when the webhook gets sent out - if it doesn’t, they’ll retry in increasingly sparse increments until they eventually mark your endpoint as broken, and email you about it.</p><p>  就像我们上面覆盖的那样，条纹不保证对事件的排序，以及事件也可能出现在重复上。当WebHook发送出来时，他们的系统期望您的端点返回2xx  - 如果没有，它们会以越来越稀疏的增量重试，直到他们最终将终端标记为破坏，并向您发送电子邮件。</p><p>   We’ve outlined a few of the best practices for implementing your own webhook sending system, but as you grow, the work doesn’t stop here. As your service gets more popular and more and more users consume your webhooks, you’ll likely need to find ways to scale and deliver more and more events without additional latency.</p><p>   我们已经概述了实现自己的Webhook发送系统的一些最佳实践，但随着您的增长，工作不会在此处停止。由于您的服务获得更多流行且越来越多的用户消耗了Webhooks，您可能需要找到扩展和提供越来越多的事件的方法，而无需额外延迟。</p><p> A good start is taking a look at streaming event-based databases like  Kafka (well, technically a pub / sub system) or  AWS Kinesis with multiple worker processes doing the actual webhook sending. If you’re on the other side running a system that is consuming webhooks, you can scale your webhook ingestion the same way you’d horizontally scale for regular web traffic — by using a load balancer or reverse-proxy in front of your web servers. And if you eventually grow past  that, you may even want to investigate a non-webhook based event streaming solution like  AMQP or  Tibco.</p><p> 一个良好的开始是看看像Kafka（井，技术上是PUB / SUB系统）这样的基于事件的数据库，或者具有多个工人进程的AWS Kinesis进行实际的Webhook发送。如果您正在运行正在消耗Webhooks的系统的另一侧，则可以通过使用Web服务器前面的负载均衡器或反向代理来扩展Webhook摄取。如果您最终增长过去，您甚至可能想要调查基于非WebHook的事件流解决方案，如AMQP或TIBCO。</p><p> In the meanwhile, check out the  WorkOS Docs to see how we implement common payloads and event types for making your app enterprise-ready.</p><p> 同时，查看Workos文档以查看我们如何实现常用有效负载和事件类型，以使您的应用程序就绪。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://workos.com/blog/building-webhooks-into-your-application-guidelines-and-best-practices?src=hn">https://workos.com/blog/building-webhooks-into-your-application-guidelines-and-best-practices?src=hn</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/建立/">#建立</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/webhooks/">#webhooks</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/端点/">#端点</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>