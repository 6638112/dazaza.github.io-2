<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Bash陷阱Bash Pitfalls</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Bash Pitfalls<br/>Bash陷阱</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 14:06:11</div><div class="page_narrow text-break page_content"><p>Or, y&#39;know, stop using  expr. You can do everything  expr does by using  Parameter Expansion. What&#39;s that thing up there trying to do? Remove the first letter of a word? That can be done in POSIX shells using PE or Substring Expansion:    Seriously, there&#39;s no excuse for using  expr unless you&#39;re on Solaris with its non-POSIX-conforming  /bin/sh. It&#39;s an external process, so it&#39;s much slower than in-process string manipulation. And since nobody uses it, nobody understands what it&#39;s doing, so your code is obfuscated and hard to maintain.    In general: Unix UTF-8 text does not use BOM. The encoding of plain text is determined by the locale or by mime types or other metadata. While the presence of a BOM would not normally damage a UTF-8 document meant only for reading by humans, it is problematic (often syntactically illegal) in any text file meant to be interpreted by automated processes such as scripts, source code, configuration files, and so on. Files starting with BOM should be considered equally foreign as those with MS-DOS linebreaks.    In shell scripting: &#39;Where UTF-8 is used transparently in 8-bit environments, the use of a BOM will interfere with any protocol or file format that expects specific ASCII characters at the beginning, such as the use of &#34;#!&#34; of at the beginning of Unix shell scripts.&#39;  http://unicode.org/faq/utf_bom.html#bom5    There isn&#39;t anything wrong with this expression, but you should be aware that command substitutions (all forms:  `...`,  $(...),  $(&lt;file),  `&lt;file`, and  ${ ...; } (ksh)) remove any trailing newlines. This is often inconsequential or even desirable, but if you must preserve the literal output including any possible trailing newlines, it gets tricky because you have no way of knowing whether the output had them or how many. One ugly but usable workaround is to add a postfix inside the command substitution and remove it on the outside:    A less portable but arguably prettier solution is to use  read with an empty delimiter.    # Ksh (or bash 4.2+ with lastpipe enabled) readlink -fn -- &#34;$dir_path&#34; | IFS= read -rd &#39;&#39; absolute_dir_path</p><p>或者，y&#39；知道吗，停止使用expr。通过使用参数展开，您可以完成expr所做的一切。什么&#39；上面那东西想干什么？删除单词的第一个字母？这可以在POSIX shell中使用PE或子字符串扩展来实现：说真的，有&#39；除非你&#39；我们在Solaris上安装了不符合POSIX的/bin/sh.It&#39；这是一个外部过程，所以它&#39；它比进程中的字符串操作慢得多。因为没有人使用它，所以没有人知道它是什么&#39；这样一来，你的代码就变得很模糊，很难维护。一般来说：Unix UTF-8文本不使用BOM。纯文本的编码由语言环境、mime类型或其他元数据决定。虽然BOM的存在通常不会损坏仅用于人类阅读的UTF-8文档，但在任何旨在通过脚本、源代码、配置文件等自动化过程进行解释的文本文件中，BOM都是有问题的（通常在语法上是非法的）。以BOM开头的文件应与以MS-DOS换行符开头的文件一样被视为外来文件。在shell脚本中：&#39；当UTF-8在8位环境中透明使用时，BOM的使用将干扰任何协议或文件格式，这些协议或文件格式在开始时需要特定的ASCII字符，例如使用&#34；#&#34; 在Unix shell脚本的开头&#39;  http://unicode.org/faq/utf_bom.html#bom5没有&#39；这个表达式没有任何错误，但是您应该知道命令替换（所有形式：`，$（…）$（&lt；文件），`&lt；文件`，和${。。。；}（ksh））删除所有尾随的换行符。这通常是无关紧要的，甚至是可取的，但是如果您必须保留文字输出，包括任何可能的尾随换行符，这会变得很棘手，因为您无法知道输出中是否有它们或有多少。一个丑陋但可用的解决方法是在命令替换中添加后缀，并在外部删除它：一个可移植性较差但可以说更漂亮的解决方案是使用带空分隔符的读取Ksh（或启用lastpipe的bash 4.2+）readlink-fn--34$迪鲁路&#34；|IFS=read-rd&#39&#39; 绝对路径</p><p>  The downside to this method is that the  read will always return false unless the command outputs a NUL byte causing only part of the stream to be read. The only way to get the exit status of the command is through  PIPESTATUS. You could also intentionally output a NUL byte to force  read to return true, and use  pipefail.    set -o pipefail { readlink -fn -- &#34;$dir_path&#34; &amp;&amp; printf &#39;\0&#39;; } | IFS= read -rd &#39;&#39; absolute_dir_path set +o pipefail</p><p>这种方法的缺点是，除非命令输出一个NUL字节，导致只读取部分流，否则读取总是返回false。获取命令退出状态的唯一方法是通过PIPESTATUS。您还可以故意输出一个NUL字节，强制read返回true，并使用pipefail。set-o pipefail{readlink-fn--&#34；$dir#u path&#34；&amp；printf&#39；\0&#39；}IFS=read-rd&#39&#39; 绝对路径设置+o管道故障</p><p>  This is somewhat of a portability mess, as Bash supports both  pipefail and  PIPESTATUS, ksh93 supports  pipefail only, and only recent versions of mksh support  pipefail, while earlier versions supported  PIPESTATUS only. Additionally, a bleeding-edge ksh93 version is required in order for  read to stop at the NUL byte.    One way to prevent programs from interpreting filenames passed to them as options is to use pathnames (see  pitfall #3 above). For files under the current directory, names may be prefixed with a relative pathname  ./.    In the case of a pattern like  *.* however, problems can arise because it matches a string of the form  ./filename. In a simple case, you can just use the glob directly to generate the desired matches. If however a separate pattern-matching step is required (e.g. the results have been preprocessed and stored in an array, and need to be filtered), it could be solved by taking the prefix into account in the pattern:  [[ $file != ./*.* ]], or by stripping the pattern from the match.    # Bash shopt -s nullglob for path in ./*; do  [[ ${path##*/} != *.* ]] &amp;&amp; rm &#34;$path&#34; done  # Or even better for file in *; do  [[ $file != *.* ]] &amp;&amp; rm &#34;./$file&#34; done  # Or better still for file in *.*; do  rm &#34;./$file&#34; done</p><p>这在一定程度上是一个可移植性混乱，因为Bash同时支持pipefail和PIPESTATUS，ksh93只支持pipefail，只有mksh的最新版本支持pipefail，而早期版本只支持PIPESTATUS。此外，为了使读取停止在NUL字节，需要一个前沿ksh93版本。防止程序将传递给它们的文件名解释为选项的一种方法是使用路径名（参见上面的陷阱3）。对于当前目录下的文件，名称的前缀可以是相对路径名。/。对于像**这样的图案然而，问题可能会出现，因为它与表单的字符串匹配/文件名。在一个简单的情况下，您可以直接使用glob来生成所需的匹配项。但是，如果需要单独的模式匹配步骤（例如，结果已预处理并存储在数组中，需要进行过滤），可以通过在模式中考虑前缀：[[$file！=./*.]]或从匹配中剥离模式来解决Bash shopt-s nullglob表示路径in./*；执行[${path##*/}！=*.]&amp&amp；rm&#34$路&#34；完成#或者更好地归档*；执行[[$file！=*.]]&amp&amp；rm&#34/$文件&#34；完成#或更好地在*中归档；做rm&#34/$文件&#34；完成</p><p>  Another possibility is to signal the  end of options with a  -- argument. (Again, covered in  #pf3).    shopt -s nullglob for file in *; do  [[ $file != *.* ]] &amp;&amp; rm -- &#34;$file&#34; done</p><p>另一种可能是用一个参数来表示选项的结束。（同样，请参见#pf3）。shopt-s nullglob，用于*中的文件；执行[[$file！=*.]]&amp&amp；rm--&#34$文件&#34；完成</p><p>  This is by far the most common mistake involving redirections, typically performed by someone wanting to direct both stdout and stderr to a file or pipe will try this and not understand why stderr is still showing up on their terminal. If you&#39;re perplexed by this, you probably don&#39;t understand how  redirections or possibly  file descriptors work to begin with. Redirections are evaluated left-to-right before the command is executed. This semantically incorrect code essentially means: &#34;first redirect standard error to where standard out is currently pointing (the tty), then redirect standard out to logfile&#34;. This is backwards. Standard error is already going to the tty. Use the following instead:    See  a more in-depth explanation,  Copy descriptor explained, and  BashGuide - redirection.    $? is only required if you need to retrieve the exact status of the previous command. If you only need to test for success or failure (any non-zero status), just test the command directly. e.g.:    Checking an exit status against a list of alternatives might follow a pattern like this:    cmd status=$? case $status in  0)  echo success &gt;&amp;2  ;;  1)  echo &#39;Must supply a parameter, exiting.&#39; &gt;&amp;2  exit 1  ;;  *)  echo &#34;Unknown error $status, exiting.&#34; &gt;&amp;2  exit &#34;$status&#34; esac</p><p>这是迄今为止最常见的涉及重定向的错误，通常由希望将stdout和stderr都指向文件或管道的人执行，他们会尝试这样做，但不理解为什么stderr仍然出现在他们的终端上。如果你&#39；如果你对此感到困惑，你可能不会&#39；我不明白重定向或文件描述符是如何工作的。在执行命令之前，将从左向右计算重定向。这个语义不正确的代码本质上意味着：&#34；首先将标准错误重定向到标准输出当前指向的位置（tty），然后将标准输出重定向到日志文件&#34；。这是倒退。标准错误已经发送到tty。改为使用以下内容：请参阅更深入的解释、已解释的复制描述符和BashGuide-重定向。$？仅当需要检索上一个命令的确切状态时才需要。如果只需要测试成功或失败（任何非零状态），只需直接测试命令即可。e、 g:对照备选方案列表检查退出状态可能遵循如下模式：cmd status=$？案例$status in 0）echo success&gt&amp；2.1） echo和#39；必须提供一个参数，正在退出&#39; &gt&amp；2出口1；；*）echo和#34；未知错误$状态，正在退出&#34; &gt&amp；2出口&#34$地位&#34；以撒</p><p>  The code given to an arithmetic expansion or compound command undergoes an initial pass of expansions and substitutions to generate the text to be parsed and evaluated as an  arithmetic expression.  This must be handled carefully.    For example, this expression is stitched together by expanding one code fragment into another.    $ x=&#39;$(date &gt;&amp;2)&#39; # redirection is just so we can see everything happen $ y=$((array[&#34;$x&#34;])) # Quotes don&#39;t help. The array doesn&#39;t even have to exist Mon Jun 2 10:49:08 EDT 2014</p><p>给定给算术展开或复合命令的代码经过初始的展开和替换过程，以生成要作为算术表达式进行分析和计算的文本。这件事必须小心处理。例如，通过将一个代码片段扩展为另一个代码片段，将此表达式缝合在一起。$x=&#39$（日期&gt；&amp；2）和#39；#重定向只是为了让我们可以看到一切发生的情况$y=$（数组[&#34；$x&#34；]）#引用don&#39；我帮不上忙。阵列没有&#39；甚至不必存在2014年6月2日星期一10:49:08美国东部夏令时</p><p>   Next, the expanded string is passed to the arithmetic processor, which will need to get a reference to the array variable in the shell&#39;s internal symbol table using a lookup function to resolve variable&#39;s &#34;name&#34;. This name resolver takes a string -  array[$(date &gt;&amp;2)] - consisting of the name, including the index and all literal code within brackets, just like e.g.  read or  printf -v do with variable names passed as arguments. The variable resolver performs expansions,  including command substitution, to resolve the index.    Most of the time, there is no need to use any kind of expansion within an arithmetic expansion. Use variable names directly in the expression (no  $) wherever possible (i.e. except for positional parameters and POSIX &#34;special variables&#34;). Validate variables before using them and assure no expansion generates anything but a numeric literal - most issues are automatically avoided.    Escape any expansions to pass them into the expression without expanding them first:    # Typical task reading some columns into an associative array. typeset -A arr printf -v offset &#39;%(%s)T&#39; -1  while IFS=&#39; &#39; read -r x y; do  [[ $x $y == +([0-9]) +([0-9]) ]] # validate input (see next pitfall)  (( arr[\$(date -d &#34;@$x&#34; +%F)] = y - offset )) # Escaped substitution passes the entire expression literally. done</p><p>接下来，将扩展字符串传递给算术处理器，算术处理器需要获取shell中数组变量的引用&#39；使用查找函数解析变量&#39；s&#34；姓名&#34；。这个名称解析程序采用一个字符串数组[$（date&gt；&amp；2）]，由名称组成，包括索引和括号内的所有文字代码，就像read或printf-v do一样，变量名作为参数传递。变量解析器执行扩展，包括命令替换，以解析索引。大多数情况下，在算术展开中不需要使用任何类型的展开。尽可能直接在表达式中使用变量名（no$）（即位置参数和POSIX&#34；特殊变量&#34；）除外）。在使用变量之前验证变量，并确保扩展只生成数字文本——大多数问题都会自动避免。转义任何展开式，将其传递到表达式中，而不首先展开：#典型任务是将某些列读入关联数组。排版-A arr printf-v偏移量#39；%（%s）T&#39-1而IFS=&#39&#39; read-rxy；执行[$x$y==+（[0-9]）+（[0-9]）]]#验证输入（请参见下一个陷阱）（（arr[\$（date-d&#34；@$x&#34；+%F）]=y-offset））#转义替换逐字传递整个表达式。完成</p><p>  Another option is to use  let with single-quoted arguments.  ((expr)) is equivalent to  let &#34;expr&#34; (double-quoted args).    Always validate your input (see  BashFAQ/054) before using num in an arithmetic context as it allows code injection.    Unbelievable as it may seem, POSIX requires the treatment of  IFS as a field  terminator, rather than a field  separator. What this means in our example is that if there&#39;s an empty field at the end of the input line, it will be discarded:    Where did the empty field go? It was eaten for historical reasons (&#34;because it&#39;s always been that way&#34;). This behavior is not unique to bash; all conformant shells do it. A non-empty field is properly scanned:    So, how do we work around this nonsense? As it turns out, appending an IFS character to the end of the input string will force the scanning to work. If there was a trailing empty field, the extra IFS character &#34;terminates&#34; it so that it gets scanned. If there was a trailing non-empty field, the IFS character creates a new, empty field that gets dropped.    $ input=&#34;a,b,&#34; $ IFS=, read -ra fields &lt;&lt;&lt; &#34;$input,&#34; $ declare -p fields declare -a fields=&#39;([0]=&#34;a&#34; [1]=&#34;b&#34; [2]=&#34;&#34;)&#39;</p><p>另一种选择是将let与单引号参数一起使用。（（expr））相当于let&#34；expr&#34；（双引号args）。在算术上下文中使用num之前，请始终验证您的输入（请参阅BashFAQ/054），因为它允许代码注入。尽管看起来难以置信，POSIX要求将IFS作为字段终止符，而不是字段分隔符来处理。在我们的例子中，这意味着如果有&#39；如果输入行末尾有一个空字段，它将被丢弃：空字段去了哪里？它之所以被食用是因为历史原因（因为它一直都是这样的）。这种行为不是bash独有的；所有共形壳都能做到这一点。一个非空字段被正确地扫描：那么，我们如何处理这些废话呢？事实证明，在输入字符串的末尾附加一个IFS字符将迫使扫描工作。如果有尾随的空字段，则额外的IFS字符&#34；终止&#34；这样就可以扫描了。如果有尾随的非空字段，IFS字符将创建一个新的空字段，该字段将被删除。$输入=&#34；a、 b和#34；$如果s=，则读取-ra字段&lt&lt&lt&#34;$输入，&#34；$declare-p字段declare-a字段=&#39；（[0]=&#34；a&#34；[1]=&#34；b&#34；[2]=&#34；&#34；）&#39;</p><p>  Do not export CDPATH.    Setting CDPATH in .bashrc is not an issue, but exporting it will cause any bash or sh script you run, that happen to use  cd, to potentially change behaviour.    There are two problems. A script that does the following:    may change directory to  ~/myProject/some/dir instead of  ./some/dir, depending on what directories exist at the time. So the  cd may succeed and take the script to the wrong directory, with potentially harmful effects of the following commands which now run in a different directory than intended.    The second problem is when  cd is run in a context where the output is captured:    As a side-effect when CDPATH is set,  cd will output something like  /home/user/some/dir to stdout to indicate that it found a directory through CDPATH, which in turn will end up in the output variable along with the intended output of  some command.    A script can make itself immune to a CDPATH inherited from the environment by always prepending  ./ to relative paths, or run  unset CDPATH at the start of the script, but don&#39;t assume every scripter has taken this pitfall into account, so don&#39;t export CDPATH.    Directly assigning a variable&#39;s value to a temporary variable isn&#39;t alone enough to restore its state. The assignment will always result in a  set but  empty temporary variable even if the initial variable was unset. This is a particular problem for IFS because an  empty IFS has a completely different meaning from an  unset IFS, and setting IFS to a temporary value for a command or two is a common requirement.    An easy workaround is to designate a prefix to distinguish set from unset vars, then strip it when finished.    A local variable is usually preferable when possible.    Subshells are another possibility.    It is not safe to populate an array with a raw  $(...)  CommandSubstitution. The output of the command undergoes word splitting (on  all whitespace, even ones that are inside quotes) and then  globbing. If there&#39;s a word like  * or  eh? or  [abc] in the result, it will be expanded based on filenames in the current working directory.    To select a replacement, you need to know whether the command writes its output on a single line, or multiple lines. If it&#39;s a single line:    If it&#39;s multiple lines (and you&#39;re targeting bash 4.0 or later):    If it&#39;s multiple lines (and you want compatibility with bash 3.x,  or want your command&#39;s exit status to be reflected in success or failure of the  read operation without depending on behavior only available in bash 4.4 and newer):    This will prevent globbing. It still won&#39;t help you if you needed to avoid splitting on quoted whitespace, but unfortunately  nothing bash can do handles that case. For generalized CSV (comma-separated value) file handling, you really need to switch to a language that has a dedicated CSV input library.    GNU  xargs supports running multiple jobs in parallel.  -P n where  n is the number of jobs to run in parallel.    seq 100 | xargs -n1 -P10 echo &#34;$a&#34; | grep 5 seq 100 | xargs -n1 -P10 echo &#34;$a&#34; &gt; myoutput.txt</p><p>不要导出CDPATH。在中设置CDPATH。bashrc不是问题，但导出它将导致您运行的任何bash或sh脚本（碰巧使用cd）可能会改变行为。有两个问题。执行以下操作的脚本：可以将目录改为~/myProject/some/dir，而不是/some/dir，具体取决于当时存在的目录。因此，cd可能会成功，并将脚本带到错误的目录，以下命令现在运行在与预期不同的目录中，可能会产生有害影响。第二个问题是，当cd在捕获输出的上下文中运行时：作为设置CDPATH的副作用，cd将向stdout输出类似于/home/user/some/dir的内容，以指示它通过CDPATH找到了一个目录，而CDPATH反过来将与某个命令的预期输出一起出现在输出变量中。脚本可以通过总是预加前缀使自己不受从环境继承的CDPATH的影响。/到相对路径，或在脚本开头运行unset CDPATH，但不要&#39；不要以为每个编剧都考虑过这个陷阱，所以不要&#39；t导出CDPATH。直接分配一个变量&#39；临时变量的s值为&#39；光靠它还不足以恢复它的状态。即使初始变量未设置，赋值始终会产生一个集合但为空的临时变量。对于IFS来说，这是一个特殊的问题，因为空IFS与未设置IFS的含义完全不同，将IFS设置为一个或两个命令的临时值是一个常见要求。一个简单的解决方法是指定一个前缀来区分set和unset VAR，然后在完成时将其剥离。如果可能的话，通常最好使用局部变量。次壳是另一种可能性。使用原始$（…）填充数组是不安全的命令替换。该命令的输出将经历分词（在所有空格上，甚至在引号内的空格上），然后进行全局搜索。如果有&#39；这是一个像*或者呃？或[abc]在结果中，它将根据当前工作目录中的文件名展开。要选择替换，您需要知道该命令是将其输出写入单行还是多行。如果是&#39；只有一行：如果是&#39；它有多行（而且你的目标是bash 4.0或更高版本）：如果它&#39；s多行（并且您希望与bash 3.x兼容，或者希望您的命令的退出状态反映在读取操作的成功或失败中，而不依赖于仅在bash 4.4及更新版本中可用的行为）：这将防止全局绑定。它仍然赢了&#39；如果需要避免在引用的空格上拆分，则无法提供帮助，但不幸的是，bash无法处理这种情况。对于通用CSV（逗号分隔值）文件处理，您确实需要切换到具有专用CSV输入库的语言。GNU xargs支持并行运行多个作业-其中n是并行运行的作业数。seq 100 | xargs-n1-P10回波和#34$a&#34；|grep 5 seq 100 | xargs-n1-P10 echo和#34$a&#34&gt；我的输出。txt</p><p>  This will work fine for many situations but has a deceptive flaw: If  $a contains more than 8192 characters (the limit depends on platform and version), the  echo may not be atomic (it may be split into multiple  write() calls), and there is a risk that two lines will be mixed.    $ perl -e &#39;print &#34;a&#34;x10000, &#34;\n&#34;&#39; &gt; foo $ strace -e write bash -c &#39;read -r foo &lt; foo; echo &#34;$foo&#34;&#39; &gt;/dev/null write(1, &#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#34;..., 8192) = 8192 write(1, &#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#34;..., 1809) = 1809 +++ exited with 0 +++</p><p>这在许多情况下都可以正常工作，但有一个欺骗性的缺陷：如果$a包含超过8192个字符（限制取决于平台和版本），回送可能不是原子的（它可能被拆分为多个write（）调用），并且存在两行混合的风险。$perl-e&#39；打印和#34；a&#34；x10000和#34；\n&#34&#39; &gt；foo$strace-e write bash-c&#39；read-r foo&lt；傅；echo和#34$34岁&#39; &gt/dev/null write（1，&#34；aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa+++</p><p>  Obviously the same issue arises if there are multiple calls to  echo or  printf:    slowprint() {  printf &#39;Start-%s &#39; &#34;$1&#34;  sleep &#34;$1&#34;  printf &#39;%s-End\n&#39; &#34;$1&#34; } export -f slowprint seq 10 | xargs -n1 -I {} -P4 bash -c &#34;slowprint {}&#34; # Compare to no parallelization seq 10 | xargs -n1 -I {} bash -c &#34;slowprint {}&#34; # Be sure to see the warnings in the next Pitfall!</p><p>显然，如果有多个对echo或printf的调用，就会出现同样的问题：slowprint（）{printf&#39；Start-%s&#39；&#34；$1&#34；sleep&#34；$1&#34；printf&#39；%s-End\n&#39；&#34；$1&#34；}export-f slowprint seq 10 | xargs-n1-I{}-P4 bash-c&#34；慢打印{}&#34；#与没有并行化相比，seq 10 | xargs-n1-I{}bash-c&#34；慢打印{}&#34；#确保在下一个陷阱中看到警告！</p><p>  Outputs from the parallel jobs are mixed together, because each job consists of two (or more) separate  write() calls.    If you need the outputs unmixed, it is therefore recommended to use a tool that guarantees output will be serialized (such as GNU Parallel).    For further details see  a demonstration of the mixing problem.    This command contains a  CodeInjection vulnerability. The filename that is found by  find is injected into a shell command and parsed by  sh. If the filename contains shell metacharacters like  ; or  $( ... ) then the filename may be  executed as code by `sh&#39;.    The &#34;slowprint&#34; example in the previous Pitfall would have been a  CodeInjection bug if the input weren&#39;t guaranteed to be integers.    To be more precise,  POSIX find does not specify whether an argument which contains  more than just  {} is expanded. GNU  find allows this  CodeInjection to occur. Other implementations choose a safer path:    # uname -a HP-UX imadev B.10.20 A 9000/785 2008897791 two-user license # find /dev/null -exec sh -c &#39;echo {}&#39; \; {}</p><p>并行作业的输出混合在一起，因为每个作业由两个（或更多）单独的write（）调用组成。如果您需要不混合的输出，因此建议使用确保输出序列化的工具（例如GNU Parallel）。有关更多详细信息，请参阅混合问题的演示。此命令包含代码注入漏洞。find找到的文件名被注入shell命令并由sh解析；或美元（。。。）然后文件名可以由`sh&#39；作为代码执行；。34岁；慢打印&#34；前一个陷阱中的例子是，如果输入不是&#39；t保证是整数。更准确地说，POSIX find并没有指定是否扩展包含多于{}的参数。GNU find允许这种代码注入发生。其他实现选择了更安全的路径：#uname-a HP-UX imadev B.10.20 a 9000/785 2008897791双用户许可证#find/dev/null-exec sh-c&#39；回声{}&#39；\；{}</p><p>  The correct approach is to  separate the filename argument from the script argument:    Redirection is done  before the command is executed. Usually that doesn&#39;t matter, but with  sudo we have a command being executed as a different user than the redirection.    If the redirection must be executed with  sudo-granted privileges, then you need a wrapper:    Instead of a wrapper you can use  tee:    This may be easier to write if  mycmd has a lot of quoting.    This is very similar to the previous pitfall.  Globbing is also done  before the command is executed. If the directory isn&#39;t readable by your normal user privileges, then you may need the globbing to be done in a shell that has the  sudo-granted privileges:    Do not close stdin, stdout or stderr as a &#34;shorthand&#34; for redirecting to  /dev/null. Write it out correctly.    Why? Consider what happens when your program tries to write an error message to stderr. If stderr has been redirected to  /dev/null, the write succeeds, and your program is free to carry on, secure in the knowledge that it has diligently reported the error condition.    But if stderr has been  closed, then the write will fail. At that point, your program may do something unpredictable. It may carry on and ignore the failure, or it may immediately exit, considering the execution environment so broken that it cannot safely continue. Or whatever else the programmer decided the program should do when its world has become a dystopian hell.    All programs are assured that stdin, stdout and stderr will  exist and will be readable/writable in an appropriate and reasonable manner. By closing one of them, you have violated your promise to this program. This is not acceptable.    Of course, an even better solution would be to actually log the errors somewhere, so you can go back and read them and figure out what&#39;s wrong.    xargs splits on whitespace. This is unfortunate because whitespace is allowed in filenames and commonly used by GUI users.  xargs also treats  &#39; and  &#34; specially, which can also lead to problems:    Here  xargs warns:    # Do not do this $ find . -type f | xargs wc xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option</p><p>正确的方法是将filename参数与script参数分开：在执行命令之前执行重定向。通常情况下，这并不意味着&#39；没关系，但是对于sudo，我们有一个命令是作为不同于重定向的用户执行的。如果重定向必须以sudo授予的权限执行，那么您需要一个包装器：而不是一个可以使用tee的包装器：如果mycmd有很多引用，这可能更容易编写。这与之前的陷阱非常相似。Globbing也在命令执行之前完成。如果目录不是&#39；如果您的普通用户权限无法读取，那么您可能需要在具有sudo授权权限的shell中完成全局绑定：不要将stdin、stdout或stderr作为&#34关闭；速记&#34；用于重定向到/dev/null。正确地写出来。为什么？考虑当程序试图向STDRR写入错误消息时会发生什么。如果stderr已被重定向到/dev/null，那么写操作将成功，并且您的程序可以自由地继续运行，因为它已经认真地报告了错误情况。但是如果stderr已经关闭，那么写操作将失败。在这一点上，你的程序可能会做一些不可预测的事情。它可能会继续并忽略故障，或者考虑到执行环境已被破坏，无法安全地继续，它可能会立即退出。或者当程序的世界变成反乌托邦地狱时，程序员决定程序应该做的任何事情。所有程序都应确保stdin、stdout和stderr将存在，并以适当和合理的方式可读写。关闭其中一个，就违反了你对这个项目的承诺。这是不可接受的。当然，一个更好的解决方案是将错误记录在某个地方，这样你就可以返回并阅读它们，找出什么&#39；这是不对的。xargs在空白处拆分。这是不幸的，因为文件名中允许空白，GUI用户通常使用空白。xargs还治疗&#39；和&#34；特别是，这也可能导致问题：这里xargs警告：#不要做这个$find-f | xargs wc xargs类型：不匹配的单引号；默认情况下，除非使用-0选项，否则引号对xargs是专用的</p><p>  Here  xargs does not warn at all:    # Do not do this echo * | xargs wc find *famous* -type f | xargs wc find *4* -type f | xargs wc</p><p>在这里，xargs根本没有警告：#不要这样回显*|xargs wc find*著名*-类型f | xargs wc find*4*-类型f | xargs wc</p><p>  Instead use  xargs -0:    # Do this instead printf &#39;%s\0&#39; * | xargs -0 wc find . -type f -name &#39;*famous*&#39; -print0 | xargs -0 wc find . -type f -name &#39;*4*&#39; -exec wc {} +</p><p>而是使用xargs-0:#这样做而不是printf&#39；%s\0&#39；*|xargs-0wc-find-f型——名称和#39*著名的*&#39-打印0 | xargs-0 wc查找-f型——名称和#39*4*&#39; -exec wc{}+</p><p>  If using  -0 is not simple, an alternative is to use GNU Parallel, which splits on \n. And while \n is also allowed in filenames they never occur unless your users are malicious. In any case:  If you use  xargs without  -0 put a comment in your code explaining why that is safe in your particular situation.    When passing an  indexed array element to  unset, it needs to be quoted. Otherwise, it may be treated as a  glob, and expanded against the files in the current directory. If there happens to be a file named  a0 then the glob is expanded to  a0 and you end up executing  unset a0.    Calling  date multiple times is a bad idea. Imagine what happens if the first call occurs a millisecond before midnight on April 30, and the second call occurs a millisecond after midnight on May 1. You would end up with month=04 and day=01.    It&#39;s better to call date  one time, retrieving all of the fields you want in a single invocation.    A common idiom for that:    Or with bash&#39;s (4.2 or above)  printf builtin:    Remember things like month or day names are locale-dependent, hence the quotes around  %A or  %B to avoid problems in locales where day or month names contain spaces or other special characters for the shell.    Or, you may retrieve a timestamp in epoch format (seconds since the start of 1970), and then use that to generate human-readable date/time fields as needed.    # Requires bash 4.2 or above printf -v now &#39;%(%s)T&#39; -1 # Or now=$EPOCHSECONDS in bash 5.0  # -1 may be omitted in 4.3 or above printf -v month &#39;%(%m)T&#39; &#34;$now&#34; printf -v day &#39;%(%d)T&#39; &#34;$now&#34;</p><p>如果使用-0并不简单，另一种方法是使用GNU Parallel，它会在\n上拆分。虽然文件名中也允许使用\n，但除非您的用户是恶意的，否则它们永远不会出现。在任何情况下：如果使用不带-0的xargs，请在代码中添加注释，解释为什么在特定情况下这样做是安全的。将索引数组元素传递给unset时，需要将其引用。否则，它可能会被视为glob，并根据当前目录中的文件展开。如果碰巧有一个名为a0的文件，那么glob将扩展为a0，最后执行unset a0。多次给date打电话是个坏主意。想象一下，如果第一次通话发生在4月30日午夜前一毫秒，而第二次通话发生在5月1日午夜后一毫秒，会发生什么。最终的结果是月=04，日=01。它&#39；最好只调用一次date，在一次调用中检索所有需要的字段。一个常见的习语是：或与bash&#39；s（4.2或更高版本）printf builtin：记住，月或日的名称是依赖于区域设置的，因此在%A或%B附近加引号是为了避免日或月的名称包含空格或其他特殊字符的区域设置出现问题。或者，您可以检索历元格式的时间戳（自1970年初起的秒数），然后根据需要使用该时间戳生成人类可读的日期/时间字段现在需要bash 4.2或更高版本printf-v&#39；%（%s）T&#39-1#Or now=$EPOCHSECONDS在bash 5.0中#-1可以在4.3或更高版本的printf-v month&#39；%中省略（%m）T&#39&#34;$现在&#34；printf-v day&#39；%（%d）T&#39&#34;$现在&#34；</p><p>  If your system&#39;s  strftime() doesn&#39;t support  %s, you can get the epoch time with:    Forced base 10 interpretation only works with signless numbers. As long as  $i contains a string of digits with no leading  - or  +, everything is fine. But if  $i might be negative, this conversion could fail, either noisily (with an error message), or even worse, silently (simply yielding the wrong result).    If there&#39;s any chance  $i could be negative, use this instead:    For explanations, please see  ArithmeticExpression.    There are many pitfalls to enabling these options at the start of a script.    errexit (set -e) tries to abort the script when an error occurs, which sounds  like a good idea at first, but it has very intricate rules regarding when to  abort on error or not. Some of the main problems with errexit are    It&#39;s not actually possible for the shell to detect errors. All it has to go on is a command&#39;s exit status. When commands fail, they normally return a non-zero exit status, but many commands also use the exit status to convey a true/false value. Examples of such commands are  test,  [,  [[ ... ]],  ((...)), and  grep.</p><p>如果你的系统&#39；s strftime（）不&#39；如果不支持%s，您可以使用以下命令获得大纪元时间：强制基数10解释仅适用于无符号数字。只要$i包含一个没有前导或+的数字串，一切都很好。但是，如果$i可能是负数，那么这种转换可能会失败，要么是响亮地（带有错误消息），要么更糟，是无声地（只是产生错误的结果）。如果有&#39；如果$i有可能是负数，请用这个来代替：有关解释，请参阅算术表达式。在脚本开始时启用这些选项有很多缺陷。errexit（set-e）尝试在发生错误时中止脚本，这一点一开始听起来不错，但它有非常复杂的规则来决定何时在发生错误时中止。errexit的一些主要问题是&#39；shell实际上不可能检测到错误。它只需要一个命令&#39；s退出状态。当命令失败时，它们通常返回非零退出状态，但许多命令也使用退出状态来传递真/假值。此类命令的示例有test、[、[。。。 ]],  ((...)), 还有格雷普。</p><p> When a command you test with  if or  &amp;&amp; or  || is a function, set -e ignores  non-zero exit statuses of commands in that function. Consider a function like            If that  cd command fails, you definitely don&#39;t want that  rm command to run,  and with a simple use of the function when errexit is enabled, that happens to  be the case:            set -e cleanup() {  cd &#34;$1&#34;  printf &#39;Oops!\n&#39; } cleanup /no/longer/there # scriptname: cd: /no/longer/there: No such file or directory</p><p>当使用if或&amp&amp；或者| |是一个函数，set-e忽略该函数中命令的非零退出状态。考虑一个函数，比如如果CD命令失败，你肯定不知道39。我不想让rm命令运行，在启用errexit时只需简单地使用该函数，情况正好是这样的：set-e cleanup（）{cd&#34；$1&#34；printf&#39；Oops！\n&#39；}cleanup/no/more/there#scriptname:cd:/no/more/there:没有这样的文件或目录</p><p>  But then later you decide to add a custom error message           cleanup /no/longer/there || {  printf &gt;&amp;2 &#39;Cleanup failed\n&#39</p><p>但后来您决定添加一条自定义错误消息cleanup/no/more/there | |{printf&gt；&amp；2&#39；cleanup failed\n&#39</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/bash/">#bash</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>