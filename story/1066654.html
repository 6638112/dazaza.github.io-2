<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在铁锈中重写GNU Coreutils </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在铁锈中重写GNU Coreutils </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-18 13:59:16</div><div class="page_narrow text-break page_content"><p>LWN订阅者订阅LWN的主要福利有助于让我们出版，但是，超出该订户可以立即访问所有网站内容并访问多个额外站点功能。请立即注册！</p><p>   作为对存储器安全语言的运动，特别是RUDE，继续剧集，值得寻找对DECADESTO RUST存在的C代码的更大规模努力。 UUTILS项目旨在托管GNU Coreutils项目冻结中包含的所有个人公用事业。最初由2013年由Jordiboggiano创建，该项目旨在为Coreutils计划提供掉落，添加Rust提供的数据竞争保护和内存安全性。</p><p> 许多读者将熟悉Coreutils项目。 IINCLUDES在每个基于GNU的操作系统上都存在于存在的基本文件，过程和文本操作程序。 CoreutilsProject是创建的，以巩固以前提供的三组工具，以前提供的Fileutils，Textutils和Shultutils以及一些其他的实用程序。许多在项目中被列入的项目，例如RM，DU，LS和CAT，几十年来，虽然存在其他实现，但是智能行为不适用于其原始形式的窗口等平台。</p><p> 总的来说，Coreutils计划被视为低悬挂的水果，可以在合理的时间内生产基于Rust的版本。每用公用事业的要求都很清楚，它们的许多它们被抑制了直接，虽然不是建议工作容易的工作。虽然已经取得了很大的进步来获得UUTILSINTO一个可用的国家，但它需要一些时间来达到Coreutils的灵感和成熟。</p><p> Fore for TheProject的使用将有助于加速这一过程，因为巨大的斯科什的内存错误和其他未定义的行为是消除的。它还打开了使用高效，种族 - 弗解的门，这有可能加快某些条件下的一些程序。 UUTILS重写还提供了不提供JustreImplement Coreutils的机会，而是还可以增强一些公用事业公司的功能，以产生更好的用户体验，同时维护与GNU版本的载玻片。例如，Hond Lended in Coreutils项目的功能请求，例如添加像MV和CP这样的进度条选项特性，当前正在娱乐Inthis Rust Rewrite。</p><p>  在项目中＆＃39; s githubpage，一张表可以向公用事业分为三列：＆＃34; DONE＆＃34;，＆＃34;半完成＆＃34;和＆＃34; to-do＆＃ 34;在这份写作时，只有23个工作中的23个尚未在＆＃34中工作; Done＆＃34;列，有16个标记为＆＃34;半完成＆＃34;和＃34下的七个;待办事项＆＃34;柱子。 ＆＃34下的实用程序;待办事项＆＃34;完全没有工作或目前正在接受自动化实施（如PR和CHCON）。那些＆＃34;半成品＆＃34;列是缺少尚未实现的选项，或者它们的行为与某些情况下的GNucounterPart略有不同。例如：</p><p> 几个实用程序不支持非UTF-8参数，尽管通过从Getopts迁移到Comment-Line ArgumentParsing的拍摄时，这是可缓解的。 </p><p>重要的是要记住，只是因为程序被标记为＆＃34; Done＆＃34; DON＆＃39; t意味着所有测试都通过或者将实用程序ISAS执行或记忆效率为GNU版本。例如，临时开放问题以改善因子（大约5倍较慢）和排序（1.5倍至6倍）的性能。在其他某些情况下，UUTILS版本将更加迅速为其GNU等价物。一个例子是报告了可测量的性能改进的CP实用程序，主要是由于使用SendFile（）和Copy_file_Range（）系统调用，这在GNU版本中不在GNU版本中进行了几个提案。</p><p> 目前，在Coreutils测试套件中只有142个测试套件与GNU版本的约546个测试相比。但是，应该指出的是，许多错误都是命令输出中的到来的atfferents。</p><p> 存在一个单独的TableAlems，以显示UutilsProject当前支持的所有平台和架构。主要的操作系统（Linux，MacOS，AndWindows）很好地占各种架构，但是几个实用程序目前无法在Windows上构建。 FreeBSD，NetBSD和Android还编译大多数二进制文件，除了包括Chroot，正常运行时间，统一，统计数据，谁，andothers等少数公用事业。 redox操作系统，solaris，webassembly和fuchsia的行常常所有空白，这反映了目前分配给OpenPlatforms的较低优先级。</p><p> 目前在0.0.6版本的Uutils项目已经包装了各种Linux发行版和Packagingsystems的储藏库。值得注意的是，Mozilla和Debian和Ubuntu项目的Devian和Propioxtributor的董事Sylvestre Ledru导致了让Debian的项目作为Analternation ove GNU Coreutils。它的当前状态被视为好的enugeNo获得一个带有Gnome的系统，始终安装了一千个大多数Debian包，并建立Firefox，Linux内核，Andllvm / clang。此外，UUTILS存在于archlinux（社区），rewbel的ke和exherbolinux分布的存储库中。</p><p>  UUTILS项目的一个重要方面要意识到是它的兴奋。该项目中的所有实用程序都是许可的许可，而是允许麻省理工学院许可证，而不是GNUcoreutils的GPLv3许可证。这可能使它在利用在彼此的限制性统一化而没有采用GPLV3许可的地方使用更具吸引力。使用麻省理工学院执照的决定并非没有批评者;有些关于选择的GitHub问题评论了，宁可看到应用于该项目的项目的Copyleft许可证。</p><p> 主要批评过去呼应了对福斯许可的论据过去：非Copyleft许可证对最终用户的自由有害它允许一个人或组织将任何部分纳入设备或其他软件的分发而没有提出源代码所以这是不可能的扭曲，改变或改善它。也令人担忧了许可选择，无需其他效果就可以获得最大化的使用;在一个更宽容的许可证下，用一些逐步倒退，在更加允许的许可证下替换GPL-许可的工具。</p><p>  遵循Uutils项目的开发的最佳方法是贯通GitHub存储库andofficial discord server.deTails如何在文档中找到如何在RocuiteThat中找到贡献。 </p><p>很多工作仍有待完成，以便将UUTILS进入淡化就绪状态。该项目已定位为一种良好的方式进入RustDevelopment，并且新人作为开始的地方有一个问题。该项目的焦点似乎与GNUcoreutils完全兼容，并在解决其他问题之前提高测试覆盖范围。在兼容性问题熨烫之后，删除不必要的依赖关系，改进性能和降低内存使用的东西更适合在兼容。</p><p>     （ 登录后发表评论）</p><p>  一件事，我喜欢新的更现代的内核：IO_调节到处都是支持。已经有一个cp fork的cp fork，据说是很棒的（https://wheybags.com/blog/wcp.html），但是当在硬盘上的一个bazillion文件时，它尖叫用于io_uring才进入头部那个电梯算法。同样的焦油！ （即使是Coreutils的Tar ISN＆＃39;）</p><p> IO_调节到处都在照顾ASYNC I / O，以及每个用于计算的循环的工作窃取线程池。现在，像生锈这样的语言实际上是默认的，它有点愚蠢地迭代，只有一个核心迭代，而另一个核心在其他7或15手表中。目前，遗留工具与两者都非常融入。甚至git甚至是犯罪的核心，通常在序列I / O上阻塞。虽然这一点慢慢得到改善，但该软件并没有与硅保持一致，这是因为我们已经让它变得太难了。欢呼新语言和像Tokio这样的臃肿的库。他们编制了统计链接副本的兆字节，但男孩很高兴在下面拥有现代和快速的运行时，而不是所有的勉强重击 - 半时间，绝对阻止POSIX遗产！</p><p> 在LS中，执行所有这些stat（）和systemcalls比任何CPU处理都重视。您可以使用多个线程，但它们互相阻止以访问相同的硬件资源，并记住切换线程根本不便宜，所以最终您可能最终有一个多芯版本的LS较慢，并且具有更多复杂的代码，也容易出错。</p><p> 我认为使用IO_调节的点不是尝试在用户空间中使用Mulitiple核心，而是允许内核并行执行STAT IO操作。在SSD和HDD上，它应该更快地为10倍。</p><p>  ＆gt;请记住，在这一天和年龄的时代，切换线程并不便宜。它曾经是相当昂贵的，但它不再是这种情况（在常见的情况下）。当然它＆＃39; s还比不做的更贵（假设你不能用那个并行性做出任何提高的东西），但这既不是在这里也没有。无论如何，IO_uring的点避免了遍历userland＆lt;  - ＆gt;内核边界，除非是绝对需要的，因为* *昂贵。更一般地，我也挑战了您以多线程时尚访问硬件的断言，并在多线程中获得了收益。当然，纺丝生锈可能无法做些多数人，但SSD肯定可以处理多个无干扰的I / O操作。 </p><p>（为自我回复道歉。）还要注意，并行化I / O实际上还可以帮助使用屏幕域和实际设备延迟之间产生的延迟。您可以提前排队的命令越多，即使在设备本身上没有发生实际并行捕获/写入的情况下，设备可以通过快速消防方式越多。</p><p> 如果您在一个硬盘上散射10请求，内核将尝试重新定位它们以最小化整个时间 - 如果两个靠近一起，则应该点击它们，并以正确的顺序等地读取它们。</p><p> 不仅仅是内核 - 所有现代存储设备还会重新排序请求以最小化整个时间。堆栈中的每个级别低于申请的效益都有深队员;不发布所有I / O的唯一原因是您可以立即发出所有I / O的原因是您可能无法在进入时尽可能快地处理响应。否则，您可能会像可以保留的那样队列踪迹;内核将重新订购，设备可以从31个命令向上重新排序，以最大化吞吐量。</p><p>  ＆gt;无论如何，IO_uring的点避免了遍历userland＆lt;  - ＆gt;内核边界，除非是绝对需要的，因为* *昂贵。这肯定是一部分的一部分，但不是整个点。可能更重要的是能够并行地发出许多I / O，即。，它最终提供Linux可用，表演异步I / O.如果您想快速驱动现代SSD，也需要在HDD上驾驶现代SSD。当我在庞大中实施了IO_调整的支持时，这是大杀手;能够立即发出256个stat（）s，并观看内核将它们重新排序到一个大头扫描中，而不是在磁盘上来回抖动。 （你＆＃39; ll在ls-ing或cp-ing许多（小）文件时看到类似的东西。）Syscall开销并没有参加它;事实上，几乎所有的收益都是在原型实现中实现的，其中我叫做IO_URAP_ENTER（）一次，即每个数据，即。，根本没有减少SYSCALL开销。</p><p> 你＆＃39;右转。我认为我是有点斜的......其中一个优点是避免所有SELECT（），ePOLL（）等的SYSCALL开端的能力。这意味着它＆＃39; SA LOT更便宜队列up io。 :)</p><p>  在其他7或15手表中，只有一个核心迭代物品，迭代物品正在愚蠢。</p><p> 只有那个程序是唯一运行的进程！特别是与这样的公用事业，您可能不会以为您自己拥有整个CPU。有时它是真的，通常不是。 </p><p>真实，但可以＆＃39; t该实用程序还增加了CPU很好的价值，同时保持I / O质量低，以反映并行性主要是关于I / O而不是CPU利用率？</p><p> 为什么一个I / O绑定的实用程序，只使用最小的CPU时间增加CPU很好的值？这样的实用程序应该具有低CPU  - 漂亮的价值，以便在它需要CPU（非常短的时间）以发出下一个IO操作，它可以这样做，并最有效地使用可用的IO带宽。对于其他任务，无论需要的CPU时间的少数款待是不好的，但对于该实用程序，但它肯定是它是否必须等待CPU而不是。当然，高漂亮的值是用于用户不等待输出的背景任务。如果我从shell运行核心实用程序，我现在想要得到结果，我不关心背景任务是否必须等待。</p><p>  发表于2021年6月9日，2011年18:09 UTC（周三）由Cyber​​ax（✭支持者✭，＃52523）[链接]</p><p>  添加交换机或环境变量应该非常琐碎，以限制您不希望它的情况的案例并发。</p><p> 除了你和＃39;重新改变默认API。您需要添加一个交换机以启用并发性。然后你＆＃39;重新倾倒这个新功能的所有成本，他们想要改善性能（细腻），但可能赢得了＆＃39; t意识到这个选项可用... :-)</p><p> 这是有趣的，据说CPU设计的进步袭击了墙壁。您可以＆＃39; t增加时钟频率，并且挤出CPU更多计算电源的唯一方法是增加核心的数量。但这是一个很大的问题，因为它需要重写软件来增加并行性，我们都知道软件行业内置的大型惯性。现在，当有人出现真正的改进时（一种宣传内置线程安全的语言），人们开始抱怨程序患上CPU。</p><p> 这不是一个可忽略的区别。同样，RURD不会陷入整数溢出（在非发布构建中的签名类型除外，即单元测试），因此不会阻止此类错误。虚张全满来围绕错误，通过忽视作为圣使命的一部分，以促进普通企业使用的一部分，鼓励生锈编译允许。 （＆＃34;在Rust＆＃34中重写它;最近被拒绝为Rust倡导的官方政策，因为原因，但Uutils似乎错过了备忘录。）当错误做陷阱时，例如数组索引错误，所产生的恐慌在退出前不能被假定正确清理。这种事情很难正确，只有成熟。 Coreutils可能仍然有自己的错误，但他们表明我们发现我们可以忍受的错误。所有核心实用程序以及许多其他核心实用程序都可以转换为使用C ++编译器构建，然后随着批发重写而逐渐变小的努力逐渐变得越来越多，在介绍新错误的风险，并且在不放弃那些目标LLVM的情况下的风险。没有神圣的使命推动了这样的活动，因此我们看到它发生在GCC和GDB中的响亮成功，但尚未在不太活动的项目中，或者在Posgresql，SQLite，Git，Systemd，BSD或Linux中的更多隐藏项目中。在不影响性能的情况下，有多种方法可以获得内存安全。铁锈提供一种方式。现代C ++练习，在一个抽象水平上写作，将危险的操作限制在信任库中，是另一个。无论如何需要这种图书馆，成本很小。实际上，一个在这些库中的信任居住在他们的编译器中和审计＆＃34中生锈的用户的数据库;不安全＆＃34;它们相应的库中的块。它可以被视为悲剧，当时的新项目，如pipewire，vulkan和wayland，都是在古代的，错误的错误中被编码，无可辩驳的原因;但是，无论如何，他们可以以1行的改变开始兑换到他们的构建脚本。 </p><p>也许如果你花了尽可能多的时间做这项工作，你声称是如此微不足道，而不是脱离我可以使用的运输代码的人，你＆＃39; d更多的情况。</p><p> 谢谢，对任何人脱离任何人，谢谢。不幸的选择是不幸的，包括产生不必要的额外工作的选择;但由于他们都没有为我做出额外的工作，我很高兴共存。你？</p><p>  ＆gt; （＆＃34;在Rust＆＃34中重写它;最近被视为官方宣传的官方政策，原因，但Uutils似乎错过了备忘录。）或者他们发现无论宣传如何，他们都发现了不值得的生锈利益。你的蔑视是无人责任的。</p><p> 如果你读得以蔑视，你读错了。对于任何用途，Rust表现出比C更好的语言。但这不是唯一的，通常足够最聪明的选择。每个人都选择他们自己的原因，智慧可能会太晚，但晚来比从未好。</p><p> ＆gt;如果你读得以蔑视，你读错了。我不是那样读它的唯一读它。几个例子：＆＃34;围绕错误的自满来忽略漏洞的漏洞编译允许作为圣务任务的一部分，以便驾驶普通企业使用＆＃34;听起来像阴谋，没有证据。 ＆＃34;没有神圣的使命驱动此类活动＆＃34;听起来很嘲笑我。如果你没有打算阅读那样，你应该改写这些。</p><p>  ＆gt;但这不是唯一的，通常足够最聪明的选择。可悲的是，他们正是一种适合写入安全低级代码的一种语言。嗯......一个半，基本上：生锈和“GCC”和第39页; S C一套Linus Linus被坚持被添加到GCC“。 C ++净空不合适。</p><p> 一？每个人都突然忘记了Ada，它正在沉没火花吗？这两者已经在关键经济作品中使用了几十年。 </p><p>您是我遇到的第一个同时锈的启动子和C人体医师。你可能是世界各地的。</p><p> 发表于6月12日，2021 23:22 UTC（SAT）由Cyber​​ax（✭支持者✭，＃52523）[链接]</p><p>  为什么？ C是一个事实上的系统语言（DUH），RUDR是唯一的现代替代品。我相信也可以使用C ++，但它有太多的缺点来证明在C ++中的低级系统的重写。</p><p>  ＆gt;所有核心实用程序以及许多其他核心实用程序都可以转换为使用C ++编译器构建，然后随着批发重写，纸上的巨大计划逐渐变得越来越努力。在实践中不起作用的原因是众所周知的，并详述了关于生锈的每篇文章。 - 虽然比c更安全，甚至是＆＃34;最现代化的＆＃34; C ++与Rust [1]一样安全[1]  - 不同的C ++程序员似乎有不同的意见＆＃34;现代性＆＃34; （以及一切c ++？）＆＃34;有多种方式来做它＆＃34;着名的最后一句话。 - 类似地，没有简单的工具或一组规则来检测不安全/旧的c，并告诉何时这样的安全努力＆＃34;完成＆＃34;通过Rust，您知道在编译时，安全完成安全性，所有不安全的块都非常仔细地审查。在C / C ++中，还有外部检查器[2]的拼凑而成，具有不同且重叠的覆盖范围，规则和误报。 - 为了上述原因，</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://lwn.net/Articles/857599/">https://lwn.net/Articles/857599/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gnu/">#gnu</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>