<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#并发</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#并发</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1049568.html">我们如何在Kotlin协程中测试并发基元 </a></div><div class="item_title_en"><a target="_blank" href="https://blog.jetbrains.com/kotlin/2021/02/how-we-test-concurrent-primitives-in-kotlin-coroutines/">How We Test Concurrent Primitives in Kotlin Coroutines</a><span>(blog.jetbrains.com)</span></div><span class="my_story_list_date">2021-2-26 10:18</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1049568.html"><img src="http://img2.diglog.com/img/2021/2/thumb_72fe2387ca31a2e5c578b720ebeb5caa.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我们的许多用户对使用协程编写异步代码的经验感到高兴。这不足为奇，因为使用协程，我们能够编写简单易懂的代码，而几乎所有异步都在后台进行。为简单起见，我们可以将Kotlin中的协程视为具有某些附加功能的超轻量级线程，例如可取消性和结构化并发。但是，协程也使代码更安全。传统的并发编程涉及操纵一个共享的可变状态，这可以说是容......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1048033.html">Python并发：棘手的问题 </a></div><div class="item_title_en"><a target="_blank" href="https://python.hamel.dev/concurrency/">Python Concurrency: The Tricky Bits</a><span>(python.hamel.dev)</span></div><span class="my_story_list_date">2021-2-18 0:18</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1048033.html"><img src="http://img2.diglog.com/img/2021/2/thumb_6918498342594768ae11fe74de076e85.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">探索Python中的线程，进程和协程，并提供一些有趣的示例，阐明它们之间的差异。
   作为在软件工程上花费更多时间的数据科学家，我最近被迫面对我在Python知识方面的一个丑陋鸿沟：并发性。老实说，我从未完全理解异步，线程，池和协程这两个术语的区别，以及这些机制如何协同工作。每次我尝试学习该主题时，这些示例对我来说......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1043683.html">Ruby 3，并发与生态 </a></div><div class="item_title_en"><a target="_blank" href="https://kirshatrov.com/2021/01/06/ruby-concurrency-and-ecosystem/">Ruby 3, Concurrency and the Ecosystem</a><span>(kirshatrov.com)</span></div><span class="my_story_list_date">2021-1-9 14:11</span><div class="my_story_list_item_desc">在Ruby 3.0版本中，关于并发性，并行性和异步IO的讨论很多。
 就我自己的看法，我想写下这对应用程序的性能和容量/成本意味着什么，以及对Ruby生态系统的影响。
 我将假定读者已经知道UNIX中的线程与进程模型之间的差异以及《利特尔定律》。
  借鉴其他语言总是很好的。 Cal Paterson撰写了一篇出色的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1042857.html">Concurrencpp –一个C ++并发库 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/David-Haim/concurrencpp">Concurrencpp – A C++ concurrency library</a><span>(github.com)</span></div><span class="my_story_list_date">2021-1-2 8:21</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1042857.html"><img src="http://img2.diglog.com/img/2021/1/thumb_ef812e52d976fb74194da576eed9833d.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">concurrencpp是C ++的任务库，允许开发人员通过使用任务，执行程序和协程轻松安全地编写高度并发的应用程序。使用concurrencpp应用程序可以将需要异步处理的大型过程分解为可并行运行并可以在内部运行的较小任务。合作的方式来达到所需的结果。concurrencpp还允许应用程序使用并行协程轻松编写并行算......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/任务/">#任务</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1034170.html">为什么并发性很难</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/oreillymedia/why-concurrency-is-hard-f93104cad54b">Why Concurrency Is Hard</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-11-10 7:38</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1034170.html"><img src="http://img2.diglog.com/img/2020/11/thumb_56a05dc5c975233a30baf94faf5b2661.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">编者按：对于许多开发人员来说，并发性是最难掌握的概念之一，但在现代软件开发中，它是一个需要掌握的重要概念。凯瑟琳·考克斯-布代(Katherine Cox-Buday)在她的《围棋中的并发性》(Conency In Go)一书的第一章中，讨论了并发编程中最常见的问题之一：竞争条件。
并发代码是出了名的难以正确编写。通......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1032482.html">Java并发性-了解线程的基础知识</a></div><div class="item_title_en"><a target="_blank" href="https://turkogluc.com/java-concurrency-basics-of-threads/">Java Concurrency – Understanding the Basics of Threads</a><span>(turkogluc.com)</span></div><span class="my_story_list_date">2020-10-31 21:1</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1032482.html"><img src="http://img2.diglog.com/img/2020/10/thumb_443fb78166cd1e98f75aed69f8d85206.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Java Thread对象允许我们在单独的线程中运行代码。当应用程序启动时，JVM创建名为main的初始线程。Main方法在主线程上运行。在应用程序内部，我们可以创建新线程，以便与主线程并行执行其他任务。
Java使用本机操作系统线程。因此，一个操作系统线程映射一个Java线程。
Thread类的构造函数接受一个Ru......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1032359.html">SWIFT并发路线图</a></div><div class="item_title_en"><a target="_blank" href="https://forums.swift.org/t/swift-concurrency-roadmap/41611">Swift Concurrency Roadmap</a><span>(forums.swift.org)</span></div><span class="my_story_list_date">2020-10-31 3:28</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1032359.html"><img src="http://img2.diglog.com/img/2020/10/thumb_24f5ee8e405405bddf4968b8e8e78fd6.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在这里可以找到包含此文档的公关SWIFT并发路线图我们的目标是让SWIFT中的并发编程变得方便、高效和安全。本文档概述了通过实现异步函数和参与者对语言进行的一些建议的添加和更改，以实现这一点。这些增加将单独提出，但在许多情况下它们将相互依赖。本文档用于将它们结合在一起。与宣言不同的是，宣言可能会描述..。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文档/">#文档</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1030438.html">当过多的并发性降低您的速度时(Golang)</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/@_orcaman/when-too-much-concurrency-slows-you-down-golang-9c144ca305a">When Too Much Concurrency Slows You Down (Golang)</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-10-22 9:37</span><div class="my_story_list_item_desc">合并排序是您在CS课程大一学习的经典“分而治之”算法之一，对我来说，它是培养对递归和O(nlog(N))复杂性的直观感觉的最佳工具之一。
在这篇文章中，我们将检查Go中MergeSort的一个简单的并发版本，然后使用Go的简单基准测试工具，我们将查看它的问题所在，然后应用一个简单的修复。
如果你不熟悉这个算法，在哈佛......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/降低/">#降低</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/slows/">#slows</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1029810.html">SQLite开始并发</a></div><div class="item_title_en"><a target="_blank" href="https://sqlite.org/src/doc/begin-concurrent/doc/begin_concurrent.md">SQLite Begin Concurrent</a><span>(sqlite.org)</span></div><span class="my_story_list_date">2020-10-19 22:56</span><div class="my_story_list_item_desc">通常，SQLite最多允许一个编写器并发进行。如果数据库处于&#34；wal&34；或&#34；wal2&34；模式，则BEGIN并发增强功能允许多个编写器同时处理写事务，尽管系统仍会序列化COMMIT命令。
当使用&#34；BEGIN CONTRENT&#34；打开写事务时，实际锁定数据库将推迟到执行COMMIT之......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/sqlite/">#sqlite</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021383.html">并发PASCAL-S</a></div><div class="item_title_en"><a target="_blank" href="http://pascal.hansotten.com/niklaus-wirth/pascal-s/pascal-s-copascal/">Concurrent Pascal-S</a><span>(pascal.hansotten.com)</span></div><span class="my_story_list_date">2020-8-31 13:10</span><div class="my_story_list_item_desc">Pascal-S是Pascal的一个子集，最初由Niklaus Wirth编写。Moti Ben-Ari在他的并发编程原则中将Pascal-S建立在PASCAL-S之上，从而产生了并发PASCAL-S。
与Wirth版本的PASCAL-S相比，本版PASCAL-S中的CASE语句、记录和实数都被刷掉了。M.Ben-A......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1008642.html">Wren是一种小型、快速、基于类的并发脚本语言</a></div><div class="item_title_en"><a target="_blank" href="https://wren.io/">Wren is a small, fast, class-based concurrent scripting language</a><span>(wren.io)</span></div><span class="my_story_list_date">2020-6-28 3:26</span><div class="my_story_list_item_desc">想想Smalltalk，它封装在Lua大小的包中，带有少量Erlang，并以熟悉的现代语法进行包装。
System.print(&#34；Hello，world！&#34；)class Wren{flyTo(City){System.print(&#34；Fly to%(City)&#34；)}}var形容词=Fib......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/small/">#small</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/wren/">#wren</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1007627.html">铁锈并发：消息传递错误的原型</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/@polyglot_factotum/rust-concurrency-the-archetype-of-a-message-passing-bug-817b60efd8f8">Rust concurrency: the archetype of a message-passing bug</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-6-22 19:52</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1007627.html"><img src="http://img.diglog.com/img/2020/6/thumb_18a8af18d4312ae59b37a266c79db1ba.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">只要有机会，我就会赞扬消息传递和事件循环在Rust中构建并发工作流的优点。然而，在我睁大眼睛的热情中，我会让它听起来几乎不会出错。
所以今天，让我们来了解一些关于错误消息传递代码原型的细节。
我认为这个错误适用于几乎所有的消息传递代码(例外情况可能是使用同步绑定通道)。
尽管我认为原生线程和横梁通道比异步/未来生态系......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1001998.html">在优化并发时比较BEAM Erlang VM和JVM的博客</a></div><div class="item_title_en"><a target="_blank" href="https://www.erlang-solutions.com/blog/optimising-for-concurrency-comparing-and-contrasting-the-beam-and-jvm-virtual-machines.html">Blog comparing the BEAM Erlang VM and JVM when optimising for concurrency</a><span>(www.erlang-solutions.com)</span></div><span class="my_story_list_date">2020-5-14 1:31</span><div class="my_story_list_item_desc">Erlang生态系统中任何编程语言的成功都可以分为三个紧密耦合的组件。它们是：1)Erlang编程语言的语义，在此基础上实现其他语言；2)用于构建可伸缩和弹性并发系统的OTP库和中间件；3)与语言语义和OTP紧密耦合的BEAM虚拟机。
把这些组件中的任何一个单独拿出来，你就会获得亚军。但是，将这三者放在一起，您就会在......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/comparing/">#comparing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/进程/">#进程</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1000602.html">铁锈并发：流工作流，有一定的反压力</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/@polyglot_factotum/rust-concurrency-a-streaming-workflow-served-with-a-side-of-back-pressure-955bdf0266b5">Rust concurrency: a streaming workflow, served with a side of back-pressure</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-5-4 23:14</span><div class="my_story_list_item_desc">作为探索Rust中的一些基本并发工作流的上一篇文章的后续文章，现在让我们探索一种稍微更高级的模式：工作从一个阶段流到下一个阶段的并发管道，以及在该上下文中发出背压信号的方法。我们还将查看流数据的“推”和“拉”源之间的区别。
让我们从初始代码开始，与前一篇文章不同的是，该代码示例非常庞大和复杂，出乎意料：
我们有三个不......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/work/">#work</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1000386.html">并发哈希表</a></div><div class="item_title_en"><a target="_blank" href="https://dl.acm.org/doi/pdf/10.1145/3309206">Concurrent Hash Tables</a><span>(dl.acm.org)</span></div><span class="my_story_list_date">2020-5-3 1:21</span><div class="my_story_list_item_desc">为了帮助支持我们的社区在COVID-19期间远程工作，我们将在2020年6月30日之前免费访问ACM在我们的数字图书馆中发布的所有作品。了解更多。
我们使用饼干，以确保我们给你最好的经验，在我们的网站。
您的浏览器似乎不支持它们，这会影响网站功能。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hash/">#hash</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ensure/">#ensure</a></button></div></div></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>