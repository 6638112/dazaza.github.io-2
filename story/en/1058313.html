<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用LLVM机器外侧的代码大小在32位ARM目标上 Reducing code size with LLVM Machine Outliner on 32-bit Arm targets</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Reducing code size with LLVM Machine Outliner on 32-bit Arm targets<br/>使用LLVM机器外侧的代码大小在32位ARM目标上 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-14 21:19:13</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/c2b6a0994c4f4c443957d7674c31e9e2.jpg"><img src="http://img2.diglog.com/img/2021/4/c2b6a0994c4f4c443957d7674c31e9e2.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>With the upcoming release of LLVM 12.0.0, 32-bit Arm targets have gained the full support of the Machine Outliner code size optimization for Arm and Thumb-2 instruction sets. The expected code size gain provided by this optimization is around 5% on average (you can jump straight to the results part for more details). It is not turned on by default (see How to use it section) but our goal is to have it enabled under -Oz for all Arm cores inside LLVM 13.0.0.</p><p>随着LLVM 12.0.0的即将发布，32位ARM目标已获得机器外侧型代码大小优化的全部支持，用于ARM和Thumb-2指令集。通过此优化提供的预期代码大小增益平均约为5％（您可以跳转到结果部分以获取更多详细信息）。默认情况下未打开（请参阅如何使用IT部分），但我们的目标是使其在LLVM 13.0.0内的所有ARM核心下启用它。</p><p>  Function outlining is a compilation process which consists of replacing a chunk of consecutive statements with a call to a new function containing those statements. In a nutshell, it is the inverse of the well known inlining optimization. It is used in different areas of compilation to achieve various goals such as code refactoring or kernel extraction in source to source compilers, shrinking large functions to reduce compile time in JIT compilers, or performance improvement by splitting hot and cold regions of a function and performing partial inlining as presented in [1].</p><p>  函数概述是一个编译过程，它包括用呼叫替换连续语句的块，调用包含这些语句的新函数。简而言之，它是众所周知的内联优化的反比力。它用于不同的编译领域，以实现源代码重构或内核提取的各种目标，源代码编译器，缩小了大功能以减少JIT编译器中的编译时间，或通过分离函数的热和冷区域和执行性能改进[1]中提出的部分内向。</p><p>  As mentioned above, the Machine Outliner objective is code size reduction, close to what Identical Code Folding (ICF) at link time is doing [2]. It is an interprocedural optimization (i.e not tied to function boundaries) which operates on LLVM machine specific intermediate representation (a.k.a MIR) at the last step in the optimization pipeline, right before code emission (code selection, register allocation, instruction scheduling, etc. are already done).</p><p>  如上所述，机器外侧目标是代码大小减少，接近链路时间的相同代码（ICF）正在进行[2]。它是在优化管道的最后一步，在代码发射之前的最后一步（代码选择，寄存器分配，指令调度等）在LLVM机器特定的中间表示（AKA MIR）上运行在LLVM机器特定的中间表示（AKA MIR）上运行的进一步优化（即未绑定到功能边界）。已经完成了）。</p><p>             In the Arm assembly generated for this C code, we can see (on the left side) that the highlighted instructions on lines &lt;3,4,5&gt;, &lt;9,10,11&gt; and &lt;15,16,17&gt; are exactly the same, and thus candidates for being outlined. The Machine Outliner will identify this redundancy, extract the code into a new function, and replace it by calls to this function as can be seen below:</p><p>             在为此C代码生成的ARM组件中，我们可以看到（在左侧），突出显示的线条＆lt; 3,4,5＆gt;，＆lt; 9,10,11＆gt;和＆lt; 15,16,17＆gt;完全相同，因此候选人概述。机器oudLiner将识别此冗余，将代码提取为新功能，然后通过对此功能的调用替换它，如下所示：</p><p>             Machine outlining optimization pass was originally developed by Jessica Paquette from Apple in 2016 [3] and presented at the LLVM developers’ meeting [4]. It was primarily developed for AArch64 (with a minimal support for X86_64 as well) and firstly available in the LLVM 5.0.0 release. It was later extended for RISC-V targets and included in the LLVM 10.0.0 release in 2019. For 32-bit Arm, we have made an initial version available in LLVM 11.0.0 and we have continued to improve it in order to deliver complete support in LLVM 12.0.0.</p><p>             机器概述优化通行证最初由2016年从Apple的Jessica Paquette开发[3]，并在LLVM开发人员会议上呈现[4]。它主要为AARCH64开发（对于X86_64的最小支持），首先在LLVM 5.0.0释放中提供。它后来延长了RISC-V目标，并在2019年的LLVM 10.0.0发布中延伸。对于32位ARM，我们在LLVM 11.0.0中提供了初始版本，我们继续改进它以便提供在LLVM 12.0.0中完全支持。</p><p>        This is done by walking through all the basic blocks of the program to find the longest repeated sequences of MIR instructions, which can be reduced to the longest common substring problem [5] where basic blocks are the strings, and instructions the characters.This class of problems can be solved efficiently with a generalized suffix tree representation [6].</p><p>        这是通过步行完成程序的所有基本块来完成的，以找到MIR指令的最长重复序列，这可以减少到最长的公共子字符串问题[5]，其中基本块是字符串，以及指令字符。本类可以使用通用后缀树表示有效地解决问题[6]。</p><p>  In the example below, the two functions calc_1 and calc_2 can be represented by strings ABABC and AABC respectively. A generalized suffix tree is built after padding these strings with a unique terminator (# and $). The depth of an internal node of this tree represents the length of a candidate and the number of leaf nodes reachable from it, the number of times it is repeated. Looking for repeated substrings which have a minimum length of two in our example will give us BC which is repeated two times, AB repeated three times and ABC repeated two times.</p><p>  在下面的示例中，两个函数calc_1和calc_2可以分别由字符串ABABC和AABC表示。填充具有唯一终止符（＃和$）后填充这些字符串之后的广义后缀树。该树的内部节点的深度表示候选的长度和从中到达的叶节点的数量，重复的次数。在我们的示例中寻找具有最小两个长度的重复的子字符串将为我们提供两次重复的BC，AB重复三次，ABC重复两次。 </p><p>             Now that we have a list of candidates, we have to take care that outlining these pieces of code will not break the program behavior and will actually reduce its size. Indeed not all instructions can be safely extracted. Conditional branches are part of the instructions or sequences which can’t be safely outlined, like when an operand is an index of a constant pool or jumptable for instance or if the sequence contains a label which is used to compute an offset position-independent code (PIC) mode, etc… Thus, such candidates are removed from the list. See below a slightly modified example:</p><p>现在我们有一个候选人列表，我们必须小心概述这些代码不会破坏程序行为，实际将减少其大小。实际上并非所有指示都可以安全地提取。条件分支是无法安全概述的指令或序列的一部分，就像操作数是常量池的索引或例如常用池或常青或者序列包含用于计算偏移位置独立的代码的标签（PIC）模式等......因此，从列表中删除此类候选者。请参阅以下略微修改示例：</p><p>           We have two candidates on lines &lt;2,3,4&gt; and &lt;10,11,12&gt; and two more on lines &lt;6,7&gt; and &lt;14,15&gt; which would, once outlined, give the code below which is broken. Indeed the return instruction outlined on line 14 is predicated and is only executed if r0 is lower or equal to r1, which means that if it is not the case when OUTLINED_FUNCTION_0 is called on line 2, the program will not come back to perform the subtraction on line 3 as it should do, but fallthrough and execute the multiplication on line 17 which is not the correct behaviour of the program.</p><p>           我们有两条候选人在线＆lt 2,3,4＆gt;和＆lt; 10,11,12＆gt;和在线＆lt; 6,7＆gt;和＆lt; 14,15＆gt;一旦概述，这会给下面的代码会破坏。实际上，在线14上概述的返回指令是预测的，并且仅执行R0较低或等于R1，这意味着如果在第2行中调用outcleined_function_0时，程序不会重新开始执行减法在第3行，因为它应该这样做，但是在第17行上执行并执行乘法，这不是程序的正确行为。</p><p>           Let’s continue with our example, now that unsafe candidates have been removed, we only have two instructions from two call sites outlined into one function, the size of our binary file is 28 bytes (12 instructions of 4 bytes: 5 in calc_1, 5 in calc_2 and 2 in OUTLINED_FUNCTION_1) which is the same size as the file obtained without outlining, so there is no point in doing it in such cases. To guarantee that the code size is reduced when a candidate is outlined, we need to check that this inequality is true, and remove the candidates otherwise:</p><p>           让我们继续使用我们的例子，现在已经删除了不安全的候选者，我们只有两个指令从两个呼叫站点丢弃到一个函数中，我们的二进制文件的大小是28字节（12个指令4个字节：5在Calc_1，5中的12个指令Calc_2和2中的outcleind_function_1），它与未在不概述的文件中获得的文件相同，因此在这种情况下没有点钟。为了保证概述候选者时代码大小减少，我们需要检查此不平等是否为真，否则删除候选者：</p><p>    Where: N is number of candidate occurrences Cs is the size in byte of a candidate Co is the overhead (added instructions) in byte at call site Fo is the overhead (added instructions) in byte in the outlined function</p><p>    其中：n是候选事项的数量cs是候选co的字节字节的大小是呼叫站点的字节的开销（添加的指令）是概述函数中的字节的开销（添加的指令）</p><p>    Once we have a safe list of candidates, it remains to actually transform the code, by creating the new functions and replacing each candidate by calls. But given the nature of the instructions which compose a candidate, or their context, it is not always as straightforward as what we have seen in previous examples.</p><p>    一旦我们有一个安全的候选人列表，它仍然是通过创建新功能并通过调用替换每个候选人来实际转换代码。但是，鉴于撰写候选人的指示的性质，或他们上下文，它并不总是直接的，就像我们在前面的例子中看到的那样直截了当。</p><p>             In calc_1 the outlined region is not a tail-call or a return instruction this time, thus it is needed to insert one (line 14) and a Branch with Link (bl) is used to call the outlined function (which will save the return address into the link register lr). It is the same thing for calc_2, but it is also needed to save and restore lr around the call (lines 2 and 4) to preserve the return address used on line 6, it can be done either by using a spare register (like r4 in our case) or by pushing it on the stack if none are available. The last case adds another constraint, because the region outlined from calc_3 contains a call to another function (line 15), lr needs to be saved and restored (lines 9 and 17) in order to jump back to the correct address. As it is done on top of the stack, the offsets of the instructions which are accessing it must be changed accordingly (line 12).</p><p>             在CALC_1中，概述区域不是尾呼叫或返回指令此时间，因此需要插入一个（第14行），并且使用链路（BL）的分支来调用概述函数（这将节省返回地址进入链接寄存器LR）。它是CALC_2的相同的事情，但还需要在呼叫（第2行和4）周围保存和恢复LR以保留第6行中使用的返回地址，可以通过使用备用寄存器来完成（如R4在我们的情况下）或者如果没有可用的话，通过将其推在堆栈上。最后一个例例增加了另一个约束，因为CALC_3中概述的区域包含对另一个函数（第15行）的呼叫，需要保存并恢复（第9行和17行）以跳回正确的地址。当它在堆栈顶部完成时，必须相应地改变访问它的指令的偏移（第12行）。</p><p>    The Machine Outliner pass is enabled by default inside the aggressive code size optimization level -Oz for AArch64 and M-profile cores for 32-bit Arm, but it can also be invoked manually or disabled with the -moutline/-mno-outline flags.</p><p>    默认情况下，机器outliner通过默认情况下启用了用于32位ARM的AARCH64和M-Profile Cores的攻击性代码大小优化级别-OZ，但也可以用-moutline / -mno-utline标志手动调用或禁用它。 </p><p>           It is also possible to get information about the transformation made by the pass, by using LLVM remarks for it with flag -Rpass=machine-outliner, for instance in our first example it will give:</p><p>通过使用标志-rpass = machine-utliner使用LLVM备注，还可以获得有关通过的转换所做的转换的信息，例如在我们的第一个示例中它将给出：</p><p>             As we have seen, Machine Outlining is always a win-win for code size optimization, in the worst case your code will not be touched at all, but on average the expected code size reduction on top of the existing aggressive code size optimization level -Oz is ~5% for Arm mode and ~4% for Thumb-2. If we look at a benchmark suite such as SPEC CPU 2017, we see that we obtain the best results on large benchmarks (up to 14% on parest for instance) which is expected since there are better chances to find repeated sequences of instructions in a large code base than in tiny tuned mathematical libraries for instance. It is also very beneficial when combined with Link Time Optimization (LTO) which operates on the whole program and not per files and already provides some very good results. The Machine Outliner can go further as we can see on blender (-14% in LTO and -23% with the Outliner) or gcc (-8.5% in LTO and -18.7% with the Outliner) for instance.</p><p>             正如我们所看到的，机器概述始终是代码大小优化的双赢，在最坏的情况下，您的代码根本不会被触摸，但平均预期的代码大小减少了现有的攻击代码大小优化级别 - ARM模式为〜5％，拇指-2为〜4％。如果我们查看诸如SPEM CPU 2017等基准套件，我们会看到我们在大型基准上获得最佳结果（例如，帕拉斯特最多14％），这是预期的，因为有可能在a中找到重复的指令序列例如，大的代码基础比微小的调谐数学库。与链路时间优化（LTO）结合在整个程序上运行而不是每个文件，并且已经提供了一些非常好的结果时，它也是非常有益的。例如，当我们可以在Blender（-14％和Outliner中的-23％）或GCC（LTO和-18.7％的LTO和-18.7％，与outliner中的-23％和-18.7％）进行进一步。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.linaro.org/blog/reducing-code-size-with-llvm-machine-outliner-on-32-bit-arm-targets/">https://www.linaro.org/blog/reducing-code-size-with-llvm-machine-outliner-on-32-bit-arm-targets/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/llvm/">#llvm</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/arm/">#arm</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>