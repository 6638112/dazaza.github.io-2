<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>QuickCheck基于属性的测试简介 An introduction to property-based testing with QuickCheck</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">An introduction to property-based testing with QuickCheck<br/>QuickCheck基于属性的测试简介 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-18 15:38:13</div><div class="page_narrow text-break page_content"><p>In February, I will be teaching a new course on Functional Programming at TU Delft. The course will mostly cover Haskell using  Graham Hutton’s excellent book, though there will be a part on basic usage of dependent types in Agda towards the end as well. For the exercises, we will use the Delft-grown  Weblab platform for letting the students code and run the automated tests using QuickCheck. Unfortunately for me, the book does not talk about QuickCheck at all. Fortunately for you, that means I decided to write a tutorial myself, which you can read here.</p><p>2月，我将在TU Delft教授函数编程的新课程。该课程将主要使用格雷厄姆·赫顿（Graham Hutton）的绝妙著作涵盖Haskell，尽管最后还将介绍有关在Agda中依赖类型的基本用法的部分内容。对于练习，我们将使用由Delft开发的Weblab平台，让学生编写代码并使用QuickCheck运行自动化测试。对我来说不幸的是，这本书根本没有谈论QuickCheck。对您来说幸运的是，这意味着我决定亲自编写一个教程，您可以在这里阅读。</p><p> Of course there are many excellent QuickCheck tutorials out there already. However I found all of them either assumed too much Haskell knowledge (since I want to introduce QuickCheck as early as possible), skipped out on interesting parts (such as conditional and quantified properties), or were just not up-to-date with the latest version of QuickCheck (such as the new approach for generating random functions using  Fun). So I hope this post closes a gap in the current menu of tutorials for at least a few people.</p><p> 当然，已经有许多出色的QuickCheck教程。但是，我发现他们要么都假设了太多的Haskell知识（因为我想尽早引入QuickCheck），或者跳过了有趣的部分（例如条件和量化属性），或者只是不了解最新知识。最新版本的QuickCheck（例如使用Fun生成随机函数的新方法）。因此，我希望这篇文章能弥补当前教程菜单中至少有几个人的空白。</p><p> If you spot any errors or opportunities for improvement, please let me know. The students at TU Delft will be grateful!</p><p> 如果您发现任何错误或改进的机会，请告诉我。代尔夫特理工大学的学生将不胜感激！</p><p>  When you were first learning to program, at some point you were probably told about the importance of writing  unit tests: small test cases that each test a small piece of functionality of your code. And while it is true that writing unit tests is important, it is also at the same time  boring and  difficult. It is boring because you need to write many separate unit tests for each piece of functionality, which all look more or less the same. And it is difficult because it is very easy to miss a certain combination of inputs for which the program crashes. Would it not be nice if we could just write down how the program should behave and have the test cases be generated automatically? That is precisely the approach of  property-based testing.</p><p>  当您第一次学习编程时，有时会被告知编写单元测试的重要性：小型测试用例，每个用例都测试代码的一小部分功能。尽管编写单元测试确实很重要，但同时也很无聊且困难。这很无聊，因为您需要为每个功能编写许多单独的单元测试，这些功能看起来或多或少都是相同的。这很困难，因为很容易错过程序崩溃的某些输入组合。如果我们只需写下程序的行为方式并自动生成测试用例，那会不好吗？这正是基于属性的测试方法。</p><p> In short, property-based testing is an approach to testing where you as the programmer write down properties that you expect to hold of your program. When running the tests, the test runner will generate a lot of different random input values, and then check that the property holds for all these (combinations of) input values. Compared to writing individual unit tests, property-based testing has several advantages:</p><p> 简而言之，基于属性的测试是一种测试方法，您作为程序员可以写下您希望保留程序的属性。在运行测试时，测试运行程序将生成许多不同的随机输入值，然后检查该属性对于所有这些（输入值）组合是否成立。与编写单个单元测试相比，基于属性的测试具有以下优点：</p><p> You spend  less time writing test code: a single property can often replace many hand-written test cases.</p><p> 您可以减少编写测试代码的时间：单个属性通常可以替换许多手写的测试用例。</p><p> You get  better coverage: by randomly generating inputs, QuickCheck will test lots of combinations you’d never test by hand.</p><p> 您可以获得更好的覆盖范围：通过随机生成输入，QuickCheck可以测试许多您不会手工测试的组合。 </p><p> You spend  less time on diagnosis of errors: if a property fails to hold, QuickCheck will automatically produce a minimized counterexample.</p><p>您可以花更少的时间诊断错误：如果某个属性无法保留，QuickCheck将自动产生一个最小化的反例。</p><p> QuickCheck is a tool for property-based testing of Haskell code. Since its introduction for Haskell in 1999, QuickCheck has become very popular as a testing framework and has been ported to many other programming languages such as C, C++, Java, JavaScript, Python, Scala, and many others (see  https://en.wikipedia.org/wiki/QuickCheck for a more complete list). However, QuickCheck really benefits from the fact that Haskell is a pure language, so that is where the approach continues to be the most powerful.</p><p> QuickCheck是用于对Haskell代码进行基于属性的测试的工具。自1999年在Haskell推出以来，QuickCheck作为一种测试框架已经非常流行，并且已移植到许多其他编程语言中，例如C，C ++，Java，JavaScript，Python，Scala以及许多其他语言（请参见https：// en .wikipedia.org / wiki / QuickCheck获取更完整的列表）。但是，QuickCheck确实得益于Haskell是一种纯语言这一事实​​，因此，该方法仍然是最强大的方法。</p><p> This introduction will show you the basic usage of QuickCheck for testing properties of Haskell code, as well as how to use alternative random generators. All the functions that are used come from the module  Test.QuickCheck from the QuickCheck package. This package can be installed using the Cabal package manager for Haskell by issuing the following command:</p><p> 本简介将向您展示QuickCheck用于测试Haskell代码属性的基本用法，以及如何使用替代随机生成器。使用的所有功能均来自QuickCheck软件包中的Test.QuickCheck模块。可以使用Cabal软件包管理器为Haskell安装此软件包，方法是发出以下命令：</p><p>   To write a QuickCheck test case, all you have to do is define a Haskell function that defines a  property of your program that you expect to hold. In the simplest case, a property is just a value of type  Bool. For example, suppose we have written a simple Haskell function to calculate the distance between two integers:</p><p>   要编写QuickCheck测试用例，您所要做的就是定义一个Haskell函数，该函数定义您希望保留的程序属性。在最简单的情况下，属性只是Bool类型的值。例如，假设我们编写了一个简单的Haskell函数来计算两个整数之间的距离：</p><p>  We can then express the property that the distance between  3 and  5 equals  2:</p><p>  然后我们可以表示3和5之间的距离等于2的性质：</p><p>  By convention, names of QuickCheck properties always start with  prop_. We can express more general properties by defining a function that returns a  Bool:</p><p>  按照约定，QuickCheck属性的名称始终以prop_开头。我们可以通过定义一个返回布尔值的函数来表达更一般的属性：</p><p> -- The distance between any number and itself is always 0   prop_dist_self ::  Int  -&gt;  Bool  prop_dist_self x  = distance x x  ==  0     -- The distance between x and y is equal to the distance between y and x   prop_dist_symmetric ::  Int  -&gt;  Int  -&gt;  Bool  prop_dist_symmetric x y  = distance x y  == distance y x</p><p> -任何数字与其自身之间的距离始终为0 prop_dist_self :: Int-> Bool prop_dist_self x =距离x x == 0-x和y之间的距离等于y和x之间的距离prop_dist_symmetric :: Int->整数->布尔prop_dist_symmetric x y =距离x y ==距离y x </p><p> When testing a property that takes one or more inputs, QuickCheck will randomly generate several inputs (100 by default) and check that the function returns  True for all inputs.</p><p>测试带有一个或多个输入的属性时，QuickCheck将随机生成多个输入（默认为100个），并检查该函数是否对所有输入都返回True。</p><p> The main function used to call QuickCheck is  quickCheck, which is defined in the module  Test.QuickCheck. To import it, you can either add  import Test.QuickCheck at the top of your file or import it manually if you are working from GHCi. Assuming you have installed the QuickCheck package, you can then load the file and run tests by calling  quickCheck:</p><p> 用于调用QuickCheck的主要功能是quickCheck，它在Test.QuickCheck模块中定义。要导入它，您可以在文件顶部添加import Test.QuickCheck，如果您使用的是GHCi，则可以手动导入。假设您已经安装了QuickCheck软件包，则可以通过调用quickCheck来加载文件并运行测试：</p><p> &gt; ghci   GHCi, version  8.10 . 2 : https ://www .haskell .org /ghc /  :? for help   Loaded package environment from  ~/.ghc /x86_64 -linux - 8.10 . 2 /environments /default   &gt;  :l QuickCheckExamples.hs   &gt; quickCheck prop_dist35   +++  OK, passed  1 test .</p><p> ＆gt; ghci GHCi，版本8.10。 2：https：//www.haskell.org/ghc/ ：？获得帮助从〜/ .ghc / x86_64 -linux-8.10加载程序包环境。 2 /环境/默认＆gt; ：l QuickCheckExamples.hs＆gt; quickCheck prop_dist35 +++ OK，通过了1个测试。</p><p> QuickCheck tells us that everything is as it should be: it ran the test and got the result  True. Since there are no inputs to the test, it is run only once. Let us try out some more properties!</p><p> QuickCheck告诉我们一切都应该是应有的：它运行了测试并得到了结果为True。由于没有测试输入，因此只能运行一次。让我们尝试更多属性！</p><p>  Huge success! For each of the tests, QuickCheck has generated 100 random inputs and verified that for each one the property returns  True.</p><p>  巨大的成功！对于每个测试，QuickCheck都生成了100个随机输入，并验证了该属性对于每个测试都返回True。</p><p> To get more information about the test inputs that are generated by QuickCheck, you can replace the function  quickCheck with  verboseCheck. This will print out each individual test case as it is generated. Try it out for yourself!</p><p> 要获取有关QuickCheck生成的测试输入的更多信息，可以将函数quickCheck替换为verboseCheck。这将在生成每个测试用例时将其打印出来。自己试试吧！</p><p>  What happens if there’s a mistake in our code? Say we forgot to write  abs in the definition of  distance?</p><p>  如果我们的代码有误怎么办？说我们忘了在距离的定义中写腹肌吗？ </p><p>  QuickCheck has found a counterexample: if the first input  x is 0 and the second input  y is 1, then  y-x is not equal to  x-y.</p><p>QuickCheck找到了一个反例：如果第一个输入x为0，第二个输入y为1，则y-x不等于x-y。</p><p> When QuickCheck finds a counterexample, it will not always return the first one it encounters. Instead, QuickCheck will look for the smallest counterexample it can find. As an example, let us try to run QuickCheck on the (false) property stating that every list is sorted.</p><p> 当QuickCheck找到一个反例时，它不会总是返回遇到的第一个反例。而是，QuickCheck将查找它可以找到的最小的反例。例如，让我们尝试在（false）属性上运行QuickCheck，声明每个列表都已排序。</p><p> sorted ::  Ord a  =&gt; [a]  -&gt;  Bool   sorted (x :y :ys)  = x  &lt;= y  &amp;&amp; sorted (y :ys)  sorted _  =  True     -- A (false) property stating that every list is sorted   prop_sorted :: [ Int]  -&gt;  Bool  prop_sorted xs  = sorted xs</p><p> 排序:: Ord a =＆gt; [a]-＆gt;布尔排序（x：y：ys）= x＆lt; = y＆amp;＆amp; sorted（y：ys）sorted _ = True-一个（false）属性，说明每个列表都已排序prop_sorted :: [Int]-＆gt; Bool prop_sorted xs =排序的xs</p><p> &gt; verboseCheck prop_sorted   Passed :   []     Passed :   []     Passed :   [ 0]     Failed :   [ 2, 1, 3]     Passed :   []     Passed :   [ 1, 3]     Passed :   [ 2, 3]     Failed :   [ 2, 1]     ...     ***  Failed !  Falsified (after  4 tests  and  3 shrinks) :   [ 1, 0]</p><p> ＆gt; verboseCheck prop_sorted已通过：[]已通过：[]已通过：[0]失败：[2，1，3]已通过：[]已通过：[1，3]已通过：[2，3]已失败：[2，1]。 .. ***失败！伪造的（经过4次测试和3次收缩）：[1，0]</p><p> The first list that is generated that is not sorted is  [2,1,3]. Note that this will be a different list every time we run QuickCheck since it is randomly generated. However, QuickCheck does not stop there and instead tries smaller and smaller lists until it converges to a minimal counterexample:  [1,0]. This process is called  shrinking.</p><p> 生成的第一个未排序的列表是[2,1,3]。请注意，由于它是随机生成的，因此每次运行QuickCheck时，它都会是一个不同的列表。但是，QuickCheck并不止于此，而是尝试越来越小的列表，直到收敛到最小的反例：[1,0]。此过程称为收缩。</p><p> It is worth noting that despite the inherent randomness of QuickCheck, shrinking will often converge to one of a small set of minimal counterexamples. For example, if we run  quickCheck many times on  prop_sorted, we always end up with either  [1,0] or  [-1,0] as a counterexample.</p><p> 值得注意的是，尽管QuickCheck具有固有的随机性，但缩小通常会收敛到少数最小反例中的一个。例如，如果我们对prop_sorted多次运行quickCheck，则总是以[1,0]或[-1,0]作为反例。</p><p> The precise strategy that QuickCheck uses for shrinking counterexamples depends on the type of the counterexample:</p><p> QuickCheck用于缩小反例的精确策略取决于反例的类型： </p><p> For numeric types such as  Int, QuickCheck will try a random number that is smaller in absolute value (i.e. closer to 0).</p><p>对于Int这样的数字类型，QuickCheck将尝试使用绝对值较小的随机数（即接近0）。</p><p>   For list types, QuickCheck will try to either delete a random element from the list, or try to shrink one of the values in the list.</p><p>   对于列表类型，QuickCheck将尝试从列表中删除随机元素，或尝试缩小列表中的值之一。</p><p>  Instead of running individual tests from GHCi, you can also combine all your tests in a  main function:</p><p>  除了可以从GHCi运行单个测试之外，您还可以将所有测试合并到一个主要函数中：</p><p>  This code makes use of Haskell  do keyword that we will study in the chapter on monads. Once you have defined this  main function, you can invoke it by calling  runghc from the command line:</p><p>  该代码利用了我们将在有关monads的章节中研究的Haskell do关键字。一旦定义了这个主要功能，就可以通过从命令行调用runghc来调用它：</p><p> &gt; runghc QuickcheckExamples.hs   +++  OK, passed  1 test .   +++  OK, passed  100 tests .   +++  OK, passed  100 tests .</p><p> ＆gt; runghc QuickcheckExamples.hs +++确定，通过了1个测试。 +++ OK，通过了100次测试。 +++ OK，通过了100次测试。</p><p> Note that a file may only contain a single  main function. In a realistic project, we would instead create a separate file that just defines all QuickCheck properties and puts them together in a  main function.</p><p> 请注意，一个文件只能包含一个主要功能。在实际的项目中，我们将创建一个单独的文件，该文件仅定义所有QuickCheck属性并将它们放到主函数中。</p><p> Remark. When you are writing code in the WebLab instance for this course, you do not need to write a main function for QuickCheck tests: WebLab will automatically collect all functions in the  Test tab whose name starts with  prop_ and run  quickCheck on each one.</p><p> 备注。在本课程的WebLab实例中编写代码时，无需编写QuickCheck测试的主要功能：WebLab将自动在“测试”选项卡中收集所有功能，其名称以prop_开头，并在每个功能上运行quickCheck。 </p><p>  The biggest challenge in making effective use of QuickCheck lies in coming up with good properties to test. So let us take a look at some examples of good properties to test.</p><p>有效使用QuickCheck的最大挑战在于提供良好的属性进行测试。因此，让我们看一些要测试的良好属性的示例。</p><p>  When one function is an inverse to another function, we can create a property test for that. For example, we can test that reversing a list is its own inverse:</p><p>  当一个函数与另一个函数相反时，我们可以为此创建一个属性测试。例如，我们可以测试反向列表是其自身的逆：</p><p>  As another example, we can test that inserting an element into a list and then deleting it again results in the same list:</p><p>  再举一个例子，我们可以测试将一个元素插入到列表中，然后再次删除它会得到相同的列表：</p><p> insert ::  Int  -&gt; [ Int]  -&gt; [ Int]  insert x []  = [x]  insert x (y :ys)  | x  &lt;= y  = x :y :ys    |  otherwise  = y :insert x ys     delete ::  Int  -&gt; [ Int]  -&gt; [ Int]  delete x []  = []  delete x (y :ys)  | x  == y  = ys    |  otherwise  = y :delete x ys     prop_insert_delete :: [ Int]  -&gt;  Int  -&gt;  Bool  prop_insert_delete xs x  = delete x (insert x xs)  == xs</p><p> 插入:: Int-＆gt; [Int]-＆gt; [Int]插入x [] = [x]插入x（y：ys）| x＆lt; = y = x：y：ys |否则= y：insert x ys delete :: Int-＆gt; [Int]-＆gt; [Int]删除x [] = []删除x（y：ys）| x == y = ys |否则= y：删除x ys prop_insert_delete :: [Int]-＆gt;整数-> Bool prop_insert_delete xs x =删除x（插入x xs）== xs</p><p> In general, it might take more than two functions to get back to the point where we started from. Any property of the form  f (g (... (h x))) == x is called a  roundtrip property.</p><p> 通常，可能需要两个以上的函数才能回到我们的起点。 f（g（...（h x）））== x形式的任何属性都称为往返属性。</p><p>  When we have two functions that should be functionally equivalent but have a different implementation, we can test that this is indeed the case. For example, we can test that a function  qsort :: Ord a =&gt; [a] -&gt; [a], we can define a property that tests it has the same behaviour as the builtin Haskell function  sort:</p><p>  当我们有两个在功能上应该等效但具有不同实现的函数时，我们可以测试确实如此。例如，我们可以测试函数qsort :: Ord a =＆gt; [a]-＆gt; [a]，我们可以定义一个属性来测试它具有与内置的Haskell函数sort相同的行为：</p><p>  If there is an alternative implementation available, defining a property of this kind is usually a very good idea since it can catch a broad range of errors in the implementation.</p><p>  如果有可供选择的实现，则定义此类属性通常是一个好主意，因为它会在实现中捕获大量错误。 </p><p> Another variant of this technique can be applied when you replace the implementation of a function with a new version (perhaps because it is more efficient or more general). In that case, you can keep the old code under a different name and add a property to test that both implementation produce the same result. This way you can make sure that the behaviour of the program has not changed by accident!</p><p>当您用新版本替换函数的实现时（可能是因为它更有效或更通用），可以应用此技术的另一种变体。在这种情况下，可以将旧代码保留为不同的名称，并添加一个属性以测试两个实现产生相同的结果。这样，您可以确保程序的行为没有意外更改！</p><p> Warning. When testing a polymorphic function such as  qsort, it seems attractive to also define a polymorphic test case:</p><p> 警告。在测试诸如qsort之类的多态函数时，定义一个多态测试用例似乎很有吸引力：</p><p> prop_qsort_sort&#39; ::  Ord a  =&gt; [a]  -&gt;  Bool  prop_qsort_sort&#39; xs  = qsort xs  ==  sort xs</p><p> prop_qsort_sort＆＃39; :: Ord a =＆gt; [a]-＆gt;布尔prop_qsort_sort＆＃39; xs = qsort xs ==排序xs</p><p> However, this does not work as you might expect: by default,  quickCheck will instantiate all type parameters to the empty tuple type  (). So the property that  quickCheck will actually test is  prop_qsort_sort&#39;&#39; :: [()] -&gt; Bool. Since a list of empty tuples  [(),(),...,()] is always sorted, this test will always return  True even if the function  qsort does nothing! So in general it is a good idea to  always give a concrete type (without type parameters) to property tests.</p><p> 但是，这并不像您期望的那样起作用：默认情况下，quickCheck会将所有类型参数实例化为空元组类型（）。因此quickCheck将实际测试的属性是prop_qsort_sort＆＃39;＆＃39; :: [（）]-＆gt;布尔由于空元组[[），（），...，（）]的列表总是被排序的，因此即使函数qsort不执行任何操作，此测试也将始终返回True！因此，总的来说，始终向属性测试提供具体类型（不带类型参数）是一个好主意。</p><p>  When we have a function that implements a certain idea from algebra, we can use the  algebraic laws as inspiration for property tests. For example, suppose we have a function  vAdd :: (Int,Int) -&gt; (Int,Int) -&gt; (Int,Int) that defines addition on two-dimensional vectors, we can test that it is commutative, associative, and has a neutral element:</p><p>  当我们有一个函数可以实现代数中的某个特定概念时，我们可以使用代数定律作为属性测试的灵感。例如，假设我们有一个函数vAdd ::（Int，Int）-＆gt; （Int，Int）-> （Int，Int）定义二维向量上的加法，我们可以测试它是可交换的，关联的并且具有中性元素：</p><p> prop_vAdd_commutative :: ( Int, Int)  -&gt; ( Int, Int)  -&gt;  Bool  prop_vAdd_commutative v w  = vAdd v w  == vAdd w v     prop_vAdd_associative :: ( Int, Int)  -&gt; ( Int, Int)  -&gt; ( Int, Int)  -&gt;  Bool  prop_vAdd_associative u v w  = vAdd (vAdd u v) w  == vAdd u (vAdd v w)     prop_vAdd_neutral_left :: ( Int, Int)  -&gt;  Bool  prop_vAdd_neutral_left u  = vAdd ( 0, 0) u  == u     prop_vAdd_neutral_right :: ( Int, Int)  -&gt;  Bool  prop_vAdd_neutral_right u  = vAdd u ( 0, 0)  == u</p><p> prop_vAdd_commutative ::（Int，Int）-＆gt; （Int，Int）->布尔prop_vAdd_commutative v w = vAdd v w == vAdd w v prop_vAdd_associative ::（Int，Int）-＆gt; （Int，Int）-> （Int，Int）-> Bool prop_vAdd_associative u v w = vAdd（vAdd v）w == vAdd u（vAdd v w）prop_vAdd_neutral_left ::（Int，Int）-＆gt; Bool prop_vAdd_neutral_left u = vAdd（0，0）u == u prop_vAdd_neutral_right ::（Int，Int）-＆gt;布尔prop_vAdd_neutral_right u = vAdd u（0，0）== u</p><p> As another example, some functions such as sorting functions are  idempotent: applying them twice produces the same result as applying them just once.</p><p> 再举一个例子，诸如排序函数之类的某些函数是幂等的：两次应用它们产生与一次应用相同的结果。 </p><p>   Often we want to test a certain property but it does not hold for all possible inputs. For example, let us try to test that each element in the result of  replicate n x is equal to  x (the function  replicate :: Int -&gt; a -&gt; [a] is defined in the standard prelude).</p><p>通常，我们想测试某个属性，但它并不适用于所有可能的输入。例如，让我们尝试测试复制n x的结果中的每个元素是否等于x（在标准序言中定义了函数copy :: Int-> a-> [a]）。</p><p> prop_replicate ::  Int  -&gt;  Int  -&gt;  Int  -&gt;  Bool  prop_replicate n x i  =  replicate n x  !! i  == x</p><p> prop_replicate :: Int-＆gt;整数->整数->布尔prop_replicate n x i =复制n x !! i == x</p><p>   Oh no! QuickCheck generated a list of length 0, which means any index  i is out of bounds. To resolve this problem, we could change the property so it always evaluates to  True in case the index is out of bounds:</p><p>   不好了！ QuickCheck生成了一个长度为0的列表，这意味着任何索引i都超出范围。要解决此问题，我们可以更改属性，以便在索引超出范围的情况下始终将其评估为True：</p><p> prop_replicate ::  Int  -&gt;  Int  -&gt;  Int  -&gt;  Bool  prop_replicate n x i  = i  &lt;  0  || i  &gt;= n  ||  replicate n x  !! i  == x</p><p> prop_replicate :: Int-＆gt;整数->整数->布尔prop_replicate n x i = i＆lt; 0 ||我＆gt; = n ||复制n x！ i == x</p><p>   However, this actually gives us a false sense of security: in the vast majority of the test cases that are generated, the index is out of bounds and thus nothing about the behaviour of  replicate is tested. You can verify this by running  verboseCheck on this property and counting the cases where  i is in between  0 and  n. In effect much fewer than 100 inputs are tested, so there is a high chance that mistakes go undetected.</p><p>   但是，这实际上给了我们一种错误的安全感：在生成的绝大多数测试用例中，索引超出范围，因此没有测试任何有关复制行为的内容。您可以通过在此属性上运行verboseCheck并计算i在0到n之间的情况来验证这一点。实际上，要测试的输入少于100个，因此很可能会发现错误。</p><p> We could try to counteract this by running more test cases. However, how many test cases is enough? Do we need 1000? 10000? What about if we want to test a property where it is even rarer that we generate a valid input, for example when a property only holds for sorted lists?</p><p> 我们可以尝试通过运行更多的测试用例来抵消这种情况。但是，多少个测试用例就足够了？我们需要1000吗？ 10000？如果我们要测试一个属性（如果该属性仅适用于已排序的列表），而该属性甚至很少会生成有效的输入，该怎么办？</p><p> Instead of running more test cases, we can make sure that the test cases we generate are always valid. We will discuss two methods provided by the QuickCheck library that allow us to do this:  conditional properties and  quantified properties.</p><p> 我们可以确保生成的测试案例始终有效，而不是运行更多的测试案例。我们将讨论QuickCheck库提供的两种方法，它们可以使我们做到这一点：条件属性和定量属性。 </p><p>  The first way we can restrict the inputs that QuickCheck uses is by using a conditional property of the form</p><p>我们可以限制QuickCheck使用的输入的第一种方法是使用表单的条件属性</p><p>   prop_replicate ::  Int  -&gt;  Int  -&gt;  Int  -&gt;  Property  prop_replicate n x i  =    (i  &gt;=  0  &amp;&amp; i  &lt; n)  ==&gt;  replicate n ( x ::  Int)  !! i  == x</p><p>   prop_replicate :: Int-＆gt;整数->整数->属性prop_replicate n x i =（i＆gt; = 0＆amp; i＆lt; n）==＆gt;复制n（x :: Int）!! i == x</p><p> Notice that the return type is no longer  Bool but  Property, a new type that is introduced by QuickCheck. Luckily we do not need to know much about this type in order to use QuickCheck; all we need to know is that we can use  quickCheck to test functions that return a  Property just like functions that return a  Bool!</p><p> 请注意，返回类型不再是Bool而是Property，这是QuickCheck引入的新类型。幸运的是，使用QuickCheck不需要对这种类型了解太多。我们需要知道的是，我们可以使用quickCheck来测试返回属性的函数，就像返回布尔的函数一样！</p><p>  What just happened? QuickCheck tests the property  replicate n (x :: Int) !! i == x as before, but now it discards all test cases that do not satisfy the condition  i &gt;= 0 &amp;&amp; i &lt; n. In the output, we can see that it generated a total of 795 test cases, of which 695 were discarded and the remaining 100 passed successfully.</p><p>  刚刚发生了什么？ QuickCheck测试属性复制n（x :: Int）！ i == x像以前一样，但是现在它丢弃了不满足条件i＆gt; = 0＆amp;＆amp;的所有测试用例。我＆lt; 。在输出中，我们可以看到它总共生成了795个测试用例，其中695个被丢弃，其余100个成功通过。</p><p> Conditional properties work well when there is a reasonable chance that a randomly generated input will satisfy the condition. However, it breaks down when valid inputs are very rare. For example, let us try to test that inserting an element into an ordered list again results in an ordered list:</p><p> 当随机生成的输入有可能满足条件时，条件属性会很好地起作用。但是，当有效输入很少时，它就会崩溃。例如，让我们尝试测试将元素再次插入有序列表会导致有序列表：</p><p> prop_insert_sorted ::  Int  -&gt; [ Int]  -&gt;  Property  prop_insert_sorted x xs  = sorted xs  ==&gt; sorted (insert x xs)</p><p> prop_insert_sorted :: Int-＆gt; [Int]-＆gt;属性prop_insert_sorted x xs =排序的xs ==＆gt;排序（插入x xs）</p><p>   The lesson here is that we should not use conditional properties when the condition is very unlikely to be satisfied.</p><p>   这里的教训是，当极不可能满足条件时，我们不应使用条件属性。 </p><p>  Instead of first generating random values and then filtering out the ones that are not valid, we can instead use a different random generator that only generates valid inputs in the first place. For this purpose, QuickCheck allows us to define  quantified properties by using custom random generators of type  Gen a. For example, we can use the generator  orderedList to generate a random ordered list. We can use random generators to define properties by using the function  forAll:</p><p>代替先生成随机值然后过滤掉无效的值，我们可以使用其他随机生成器，该生成器仅首先生成有效输入。为此，QuickCheck允许我们使用Gen a类型的自定义随机数生成器来定义量化属性。例如，我们可以使用生成器orderedList生成随机的有序列表。我们可以使用forAll函数使用随机数生成器来定义属性：</p><p> prop_insert_sorted ::  Int  -&gt;  Property  prop_insert_sorted x  = forAll orderedList (\xs  -&gt; sorted (insert x xs))</p><p> prop_insert_sorted :: Int-＆gt;属性prop_insert_sorted x = forAllorderedList（\ xs-＆gt;已排序（插入x xs））</p><p> The first argument of  forAll is the random generator. The second argument is a  function that maps the result of the generator to the property we want to test (in other words,  forAll is a  higher-order function). Here we have given the function as a lambda expression  \xs -&gt; sorted (insert x xs). Note that the list  xs is no longer an input to the overall property  prop_insert_sorted, as it is already an argument to the lambda expression. Now if we run  quickCheck again, we see that the tests now pass:</p><p> forAll的第一个参数是随机生成器。第二个参数是一个将生成器的结果映射到我们要测试的属性的函数（换句话说，forAll是一个高阶函数）。在这里，我们以lambda表达式\ xs-＆gt;的形式给出了该函数。排序（插入x xs）。请注意，列表xs不再是整体属性prop_insert_sorted的输入，因为它已经是lambda表达式的参数。现在，如果再次运行quickCheck，我们将看到测试通过：</p><p>  You can also use  verboseCheck to verify that all the generated lists are indeed sorted (do it!)</p><p>  您还可以使用verboseCheck来验证所有生成的列表是否确实已排序（执行！）。</p><p> QuickCheck provides a long list of random generators that we can use to test our properties. Here are a few useful examples:</p><p> QuickCheck提供了一长串随机生成器，我们可以使用它们来测试属性。以下是一些有用的示例：</p><p> The generator  choose will choose a random elements between two bounds. For example,  choose (1,6) will generate a random number between 1 and 6 (both bounds included).</p><p> 生成器选择将在两个边界之间选择一个随机元素。例如，选择（1,6）将生成一个介于1和6之间的随机数（包括两个边界）。</p><p> The generator  elements will choose a random element from a given list of values. For example,  elements [&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;] will generate a random vowel.</p><p> 生成器元素将从给定的值列表中选择一个随机元素。例如，元素[＆＃39; a＆＃39;，＆＃39; e＆＃39;，＆＃39; i＆＃39;，＆＃39; o＆＃39;，＆＃39; u＆＃39;]将生成一个随机的元音。 </p><p> The generator  frequency works like  elements but allows you to give a weight to each option determining how likely it is that it is generated. For example,  frequency [(99,True),(1,False)] will generate  True 99% of the time and  False 1% of the time.</p><p>发生器频率就像元素一样工作，但是允许您权衡每个选项，确定它产生的可能性。例如，频率[（99，True），（1，False）]将产生99％的时间为True，而1％的时间为False。</p><p> The generator  vector generates lists of a given length. For example,  vector 42 generates random lists of length 42.</p><p> 生成器矢量生成给定长度的列表。例如，向量42生成长度为42的随机列表。</p><p> The generator  shuffle generates lists with the same elements as a given list but in a random order. For example,  shuffle [1..10] generates random lists containing the numbers  1 to  10.</p><p> 生成器混洗生成具有与给定列表相同元素的列表，但顺序随机。例如，shuffle [1..10]生成包含数字1到10的随机列表。</p><p> You can find many other generators by looking at the module  Test.QuickCheck. In addition, it is possible to define your own random generators, but this goes beyond the scope of this introduction.</p><p> 您可以通过查看模块Test.QuickCheck找到许多其他生成器。另外，可以定义自己的随机生成器，但这超出了本介绍的范围。</p><p> If you want to play around with these random generators, you can use the function  sample from GHCi to generate a couple of random values with the given generator:</p><p> 如果您想使用这些随机生成器，可以使用GHCi中的函数样本通过给定的生成器生成几个随机值：</p><p>   In addition of being able to generate values of basic types such as integers, booleans, and lists, QuickCheck can also generate random  functions that you can use to write tests. However, for technical reasons related to shrinking, QuickCheck cannot directly generate an element of type, say,  String -&gt; Bool. Instead, QuickCheck introduces a new (generic) type  Fun a b with two parameters  a and  b, as well as a function  applyFun :: Fun a b -&gt; a -&gt; b.</p><p>   除了能够生成基本类型（例如整数，布尔值和列表）的值之外，QuickCheck还可以生成可用于编写测试的随机函数。但是，由于与收缩有关的技术原因，QuickCheck无法直接生成类型为String-> gt;的元素。布尔取而代之的是，QuickCheck引入了具有两个参数a和b的新（通用）类型Fun a b，以及函数applyFun :: Fun a b->。 -＆gt; b。</p><p> For example, we can test that for any function  p :: Int -&gt; Bool, we have that  p x == True for all elements of the list  [ x | x &lt;- xs , p x ]:</p><p> 例如，我们可以测试任何函数p :: Int-＆gt;布尔，对于列表[x | x＆lt;-xs，p x]： </p><p> prop_filter ::  Fun  Int  Bool  -&gt; [ Int]  -&gt;  Property  prop_filter p xs  =     -- Filter elements not satisfying p.    let ys  = [ x  | x  &lt;- xs , applyFun p x ]    -- If any elements are left...     in ys  /= []  ==&gt;     -- ...generate a random index i...    forAll (choose ( 0, length ys - 1))    -- ...and test if p (ys!!i) holds.    (\i  -&gt; applyFun p (ys !!i))</p><p>prop_filter :: Fun Int Bool-＆gt; [Int]-＆gt;属性prop_filter p xs =-不满足p的过滤元素。令ys = [x | x＆lt;-xs，applyFun p x]-如果在ys中遗留了任何元素... / = [] ==＆gt; -...生成一个随机索引i ... forAll（选择（0，长度ys-1））-...并测试p（ys !! i）是否成立。 （\ i-＆gt; applyFun p（ys !! i））</p><p>  As another (silly) example, let us try to test the property that each function of type  String -&gt; Int produces the same result on at least two out of three values of  &#34;banana&#34;,  &#34;monkey&#34;, and  &#34;elephant&#34;:</p><p>  作为另一个（愚蠢的）示例，让我们尝试测试类型为String-> gts的每个函数的属性。 Int在＆＃34; banana＆＃34 ;、＆＃34; monkey＆＃34;和＆＃34; elephant＆＃34;的三个值中的至少两个值上产生相同的结果：</p><p> prop_bananas ::  Fun  String  Int  -&gt;  Bool  prop_bananas f  =    applyFun f  &#34;banana&#34;  == applyFun f  &#34;monkey&#34;  ||   applyFun f  &#34;banana&#34;  == applyFun f  &#34;elephant&#34;  ||   applyFun f  &#34;monkey&#34;  == applyFun f  &#34;elephant&#34;</p><p> prop_bananas :: Fun String Int-＆gt; Bool prop_bananas f = applyFun f＆＃34; banana＆＃34; == applyFun f＆＃34; monkey＆＃34; || applyFun f＆＃34;香蕉＆＃34; == applyFun f＆＃34; elephant＆＃34; || applyFun f＆＃34; monkey＆＃34; == applyFun f＆＃34; elephant＆＃34;</p><p>  The function  {&#34;banana&#34;-&gt;0, &#34;elephant&#34;-&gt;1, _-&gt;2} generated by QuickCheck maps  &#34;banana&#34; to  0,  &#34;elephant&</p><p>  由QuickCheck映射＆＃34; banana＆＃34;生成的函数{＆＃34; banana＆＃34;-＆gt; 0，＆＃34; elephant＆＃34;-＆gt; 1，_-＆gt; 2}到0，＆elephant＆</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://jesper.sikanda.be/posts/quickcheck-intro.html">https://jesper.sikanda.be/posts/quickcheck-intro.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/property/">#property</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>