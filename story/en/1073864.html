<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Pure Bash Bible–外部进程的纯Bash替代方案的集合Pure Bash Bible – A collection of pure bash alternatives to external processes</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Pure Bash Bible – A collection of pure bash alternatives to external processes<br/>Pure Bash Bible–外部进程的纯Bash替代方案的集合</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 16:15:30</div><div class="page_narrow text-break page_content"><p>The goal of this book is to document commonly-known and lesser-known methods of doing various tasks using only built-in  bash features. Using the snippets from this bible can help remove unneeded dependencies from scripts and in most cases make them faster. I came across these tips and discovered a few while developing  neofetch,  pxltrm and other smaller projects.</p><p>本书的目标是记录只使用内置bash特性来完成各种任务的常见方法和鲜为人知的方法。使用本《圣经》中的片段有助于从脚本中删除不必要的依赖项，并且在大多数情况下使它们更快。我在开发neofetch、pxltrm和其他较小的项目时遇到了这些技巧，并发现了一些。</p><p> The snippets below are linted using  shellcheck and tests have been written where applicable. Want to contribute? Read the  CONTRIBUTING.md. It outlines how the unit tests work and what is required when adding snippets to the bible.</p><p>下面的代码片段是使用shellcheck编写的，并在适用的情况下编写了测试。想要贡献吗？阅读投稿。它概述了单元测试是如何工作的，以及在圣经中添加代码片段时需要做什么。</p><p> See something incorrectly described, buggy or outright wrong? Open an issue or send a pull request. If the bible is missing something, open an issue and a solution will be found.</p><p>看到一些描述错误的东西了吗，有问题还是完全错了？打开问题或发送请求。如果圣经遗漏了什么，打开一个问题，就会找到解决办法。</p><p>         A collection of pure  bash alternatives to external processes and programs. The  bash scripting language is more powerful than people realise and most tasks can be accomplished without depending on external programs.</p><p>纯bash替代外部进程和程序的集合。bash脚本语言比人们意识到的强大，大多数任务都可以在不依赖外部程序的情况下完成。</p><p> Calling an external process in  bash is expensive and excessive use will cause a noticeable slowdown. Scripts and programs written using built-in methods ( where applicable) will be faster, require fewer dependencies and afford a better understanding of the language itself.</p><p>在bash中调用外部进程代价高昂，过度使用会导致明显的速度减慢。使用内置方法（如果适用）编写的脚本和程序将更快，需要更少的依赖性，并更好地理解语言本身。</p><p> The contents of this book provide a reference for solving problems encountered when writing programs and scripts in  bash. Examples are in function formats showcasing how to incorporate these solutions into code.</p><p>本书的内容为解决在bash中编写程序和脚本时遇到的问题提供了参考。函数格式的示例展示了如何将这些解决方案合并到代码中。</p><p>   This is an alternative to  sed,  awk,  perl and other tools. Thefunction below works by finding all leading and trailing white-space andremoving it from the start and end of the string. The  : built-in is used in place of a temporary variable.</p><p>这是sed、awk、perl和其他工具的替代品。下面的函数通过查找所有前导和尾随空格，并将其从字符串的开头和结尾移动来工作。：内置变量用于替代临时变量。</p><p>  trim_string() {   # Usage: trim_string &#34; example string &#34;  :   &#34; ${1 #  &#34; ${1 %%[![:space:]] *} &#34;} &#34;  :   &#34; ${_ %  &#34; ${_ ##*[![:space:]]} &#34;} &#34;  printf   &#39;%s\n &#39;   &#34; $_ &#34;}</p><p>trim#string（）{#用法：trim#string&#34；示例string&#34；：&#34；${1#&#34；${1%[！[：space:]*}&#34；}&#34;  :   &#34; ${{uz%&#34；${u##*[！[：空格：]}&#34；}&#34;  printf&#39；%s\n和#39&#34; $_ &#34;}</p><p>    This is an alternative to  sed,  awk,  perl and other tools. Thefunction below works by abusing word splitting to create a new stringwithout leading/trailing white-space and with truncated spaces.</p><p>这是sed、awk、perl和其他工具的替代品。下面的函数通过滥用分词来创建一个没有前导/尾随空格和截断空格的新字符串。</p><p>  # shellcheck disable=SC2086,SC2048 trim_all() {   # Usage: trim_all &#34; example string &#34;  set -f  set --  $*  printf   &#39;%s\n &#39;   &#34; $* &#34;  set +f}</p><p>#shellcheck disable=SC2086，SC2048 trim#all（）{用法：trim#all&#34；示例字符串&#34；set-f set--$*printf&#39；%s\n&#39；&#34；$*&#34；set+f}</p><p>  $ trim_all   &#34; Hello, World  &#34;Hello, World$ name=  &#34; John Black is my name.  &#34;$ trim_all   &#34; $name &#34;John Black is my name.</p><p>$trim_all&#34；你好，世界&#34；你好，World$name=&#34；约翰·布莱克是我的名字&#34;$ 修剪全部&#34$姓名&#34；约翰·布莱克是我的名字。</p><p>  The result of  bash&#39;s regex matching can be used to replace  sed for alarge number of use-cases.</p><p>bash的结果&#39；s regex匹配可以用于替换大量用例中的sed。</p><p> CAVEAT: This is one of the few platform dependent  bash features. bash will use whatever regex engine is installed on the user&#39;s system.Stick to POSIX regex features if aiming for compatibility.</p><p>警告：这是少数依赖于平台的bash特性之一。bash将使用用户安装的任何regex引擎&#39；s系统。如果以兼容性为目标，请坚持使用POSIX正则表达式功能。</p><p> CAVEAT: This example only prints the first matching group. When usingmultiple capture groups some modification is needed.</p><p>注意：本例仅打印第一个匹配组。当使用多个捕获组时，需要进行一些修改。</p><p>  regex() {   # Usage: regex &#34;string&#34; &#34;regex&#34; [[  $1  =~  $2 ]]  &amp;&amp;  printf   &#39;%s\n &#39;   &#34; ${BASH_REMATCH[1]} &#34;}</p><p>regex（）{#用法：regex&#34；string&#34；&#34；regex&#34；[$1=~$2]]和printf&#39；%s\n&#39；&#34；${BASH#u重新匹配[1]&#34；}</p><p>  $   # Trim leading white-space.$ regex   &#39; hello &#39;   &#39;^\s*(.*) &#39;hello$   # Validate a hex color.$ regex   &#34;#FFFFFF &#34;   &#39;^(#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3}))$ &#39;  #FFFFFF$   # Validate a hex color (invalid).$ regex   &#34;red &#34;   &#39;^(#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3}))$ &#39;  # no output (invalid)</p><p>$#修剪前导空白。$正则表达式&#39；你好&#39&#39;^\s*（*）和#39；你好$#验证十六进制颜色。$正则表达式&#34#FFFFFF&#34&#39;^（#？（[a-fA-F0-9]{6}|[a-fA-F0-9]{3}））$&#39#FFFFFF$#验证十六进制颜色（无效）。$正则表达式&#34；红色和#34&#39;^（#？（[a-fA-F0-9]{6}|[a-fA-F0-9]{3}））$&#39；#无输出（无效）</p><p>  is_hex_color() {  if [[  $1  =~ ^(  #?([a-fA-F0-9]{6}|[a-fA-F0-9]{3}))$ ]]; then  printf   &#39;%s\n &#39;   &#34; ${BASH_REMATCH[1]} &#34;  else  printf   &#39;%s\n &#39;   &#34;error:  $1 is an invalid color. &#34;  return 1  fi} read -r coloris_hex_color   &#34; $color &#34;  || color=  &#34;#FFFFFF &#34;  # Do stuff.</p><p>是_hex_color（）{if[$1=~^（#？（[a-fA-F0-9]{6}}|[a-fA-F0-9]{3}]）$]；然后printf&#39；%s\n和#39&#34; ${BASH_重赛[1]}&#34；else printf&#39；%s\n和#39&#34;错误：$1是无效颜色&#34;  返回1 fi}read-r coloris_hex_color&#34$颜色&#34；|124;颜色=&#34#FFFFFF&#34；#做事。</p><p>     split() {   # Usage: split &#34;string&#34; &#34;delimiter&#34; IFS=  $&#39; \n &#39;  read -d   &#34; &#34; -ra arr  &lt;&lt;&lt;   &#34;${1//$2/$&#39;\n&#39;} &#34;  printf   &#39;%s\n &#39;   &#34; ${arr[@]} &#34;}</p><p>split（）{#用法：split&#34；string&#34；delimiter&#34；IFS=$&#39；\n&#39；read-d&#34；&ra arr&lt；&lt；&lt；&lt；&gt；&34；$1/$2/$&39；\n&#39；]&#34;  printf&#39；%s\n和#39&#34; ${arr[@]}&#34；}</p><p>  $ split   &#34;apples,oranges,pears,grapes &#34;   &#34;, &#34;applesorangespearsgrapes$ split   &#34;1, 2, 3, 4, 5 &#34;   &#34;,  &#34;12345  # Multi char delimiters work too!$ split   &#34;hello---world---my---name---is---john &#34;   &#34;--- &#34;helloworldmynameisjohn</p><p>$split和#34；苹果、橙子、梨、葡萄和#34&#34;, &#34;AppleSRangeSpearsgraps$split和#34；1, 2, 3, 4, 5 &#34;   &#34;,  &#34;12345#多字符分隔符也有效！$分裂和#34；你好---世界---我的---名字---是---约翰&#34&#34;--- &#34;我的名字是约翰</p><p>                            $ strip_all   &#34;The Quick Brown Fox &#34;   &#34;[aeiou] &#34;Th Qck Brwn Fx$ strip_all   &#34;The Quick Brown Fox &#34;   &#34;[[:space:]] &#34;TheQuickBrownFox$ strip_all   &#34;The Quick Brown Fox &#34;   &#34;Quick  &#34;The Brown Fox</p><p>$strip#all&#34；敏捷的棕色狐狸&#34&#34;[aeiou]和#34；Th Qck Brwn外汇$strip#u all和#34；敏捷的棕色狐狸&#34&#34;[：空格：][]和#34；QuickBrownFox$strip#all&#34；敏捷的棕色狐狸&#34&#34;快&#34；棕色狐狸</p><p>     $ strip   &#34;The Quick Brown Fox &#34;   &#34;[aeiou] &#34;Th Quick Brown Fox$ strip   &#34;The Quick Brown Fox &#34;   &#34;[[:space:]] &#34;TheQuick Brown Fox</p><p>$strip&#34；敏捷的棕色狐狸&#34&#34;[aeiou]和#34；第四快棕色狐狸$strip&#34；敏捷的棕色狐狸&#34&#34;[：空格：][]和#34；敏捷的棕色狐狸</p><p>             urlencode() {   # Usage: urlencode &#34;string&#34;  local LC_ALL=C  for   (( i  =  0; i  &lt;  ${ #1}; i ++  )) ;  do  :   &#34; ${1 :i :1} &#34;  case   &#34; $_ &#34;  in [a-zA-Z0-9.~_-])  printf   &#39;%s &#39;   &#34; $_ &#34; ;;  *)  printf   &#39;%%%02X &#39;   &#34;&#39; $_ &#34; ;;  esac  done  printf   &#39;\n &#39;}</p><p>urlencode（）{#用法：urlencode&#34；string&#34；local LC#u ALL=C for（（i=0；i&lt；${#1}；i++）；do:&#34${1:i:1}&#34；案例&#34；$#&#34;  在[a-zA-Z0-9.~-]）printf和#39；%s&#39&#34; $_ &#34; ;;  *)  printf&#39；%%02X和#39&#34;&#39; $_ &#34; ;;  esac完成了打印F和#39；\n&#39；}</p><p>          if [[  $var  ==  *sub_string * ]] ;  then  printf   &#39;%s\n &#39;   &#34;sub_string is in var. &#34; fi  # Inverse (substring not in string). if [[  $var  !=  *sub_string * ]] ;  then  printf   &#39;%s\n &#39;   &#34;sub_string is not in var. &#34; fi  # This works for arrays too! if [[  ${arr[*]}  ==  *sub_string * ]] ;  then  printf   &#39;%s\n &#39;   &#34;sub_string is in array. &#34; fi</p><p>如果[[$var==*sub_string*]；然后printf&#39；%s\n和#39&#34;子字符串在变量和34中；fi#逆（子字符串不在字符串中）。如果[$var！=*sub_string*]；然后printf&#39；%s\n和#39&#34;子#u字符串不在变量&#34中；fi#这也适用于阵列！如果[${arr[*]}==*子字符串*]；然后printf&#39；%s\n和#39&#34;子字符串在数组中&#34; 菲</p><p>  case   &#34; $var &#34;  in  *sub_string *)   # Do stuff ;;  *sub_string2 *)   # Do more stuff ;;  *)   # Else ;; esac</p><p>34例$var&#34；在*sub_string*）#做事*sub_string2*）#做更多的事；*）#其他的以撒</p><p>  if [[  $var  == sub_string * ]] ;  then  printf   &#39;%s\n &#39;   &#34;var starts with sub_string. &#34; fi  # Inverse (var does not start with sub_string). if [[  $var  != sub_string * ]] ;  then  printf   &#39;%s\n &#39;   &#34;var does not start with sub_string. &#34; fi</p><p>如果[[$var==sub_string*]；然后printf&#39；%s\n和#39&#34;var以sub_字符串开头&#34; fi#逆（var不以sub#u字符串开头）。如果[[$var！=sub_string*]；然后printf&#39；%s\n和#39&#34;var不以sub_字符串开头&#34; 菲</p><p>  if [[  $var  ==  *sub_string ]] ;  then  printf   &#39;%s\n &#39;   &#34;var ends with sub_string. &#34; fi  # Inverse (var does not end with sub_string). if [[  $var  !=  *sub_string ]] ;  then  printf   &#39;%s\n &#39;   &#34;var does not end with sub_string. &#34; fi</p><p>如果[$var==*sub_string]]；然后printf&#39；%s\n和#39&#34;var以sub_字符串结尾&#34; fi#逆（var不以sub_字符串结尾）。如果[$var！=*子字符串]]；然后printf&#39；%s\n和#39&#34;var不以sub_字符串结尾&#34; 菲</p><p>   Enabling  extdebug allows access to the  BASH_ARGV array which storesthe current function’s arguments in reverse.</p><p>启用extdebug允许访问BASH_ARGV数组，该数组反向存储当前函数的参数。</p><p>   reverse_array() {   # Usage: reverse_array &#34;array&#34;  shopt -s extdebug  f()(printf   &#39;%s\n &#39;   &#34; ${BASH_ARGV[@]} &#34;); f   &#34; $@ &#34;  shopt -u extdebug}</p><p>reverse#array（）{#用法：reverse#array&#34；array&#34；shopt-s extdebug f（）（printf&#39；%s\n&#39；&#34；${BASH#ARGV[@]&#34；）；f&#34；$@&#34;  shopt-u extdebug}</p><p>    Create a temporary associative array. When setting associative arrayvalues and a duplicate assignment occurs, bash overwrites the key. Thisallows us to effectively remove array duplicates.</p><p>创建临时关联数组。当设置关联ArrayValue并发生重复赋值时，bash会覆盖该键。这使我们能够有效地删除重复的阵列。</p><p>    remove_array_dups() {   # Usage: remove_array_dups &#34;array&#34;  declare -A tmp_array  for  i  in   &#34; $@ &#34; ;  do [[  $i ]]  &amp;&amp; IFS=  &#34;  &#34; tmp_array[  &#34; ${i :- } &#34;]=1  done  printf   &#39;%s\n &#39;   &#34; ${ !tmp_array[@]} &#34;}</p><p>remove_array_dups（）{#用法：remove_array_dups&#34；array&#34；declare-tmp_array for i in&#34；$@&#34；do[$i]]和IFS=&#34；&#34；tmp#u array[&#=1完成打印F&#39；%s\n和#39&#34; ${！tmp_数组[@]}&#34；}</p><p>  $ remove_array_dups 1 1 2 2 3 3 3 3 3 4 4 4 4 4 5 5 5 5 5 512345$ arr=(red red green blue blue)$ remove_array_dups   &#34; ${arr[@]} &#34;redgreenblue</p><p>$remove_array_dups 1 1 2 2 3 3 3 3 3 4 4 5 5 5 5 512345$arr=（红-红-绿-蓝）$remove_array_dups和#34${arr[@]}&#34；红绿蓝</p><p>     $ array=(red green blue yellow brown)$ random_array_element   &#34; ${array[@]} &#34;yellow  # Multiple arguments can also be passed.$ random_array_element 1 2 3 4 5 6 73</p><p>$array=（红绿蓝黄棕色）$random_array_element&#34${array[@]}&#34；黄色#也可以传递多个参数。$随机数组元素12345673</p><p>  Each time the  printf is called, the next array element is printed. Whenthe print hits the last array element it starts from the first elementagain.</p><p>每次调用printf时，都会打印下一个数组元素。当打印到达最后一个数组元素时，它会再次从第一个元素开始。</p><p>               arr=(apples oranges tomatoes)  # Elements and index. for  i  in   &#34; ${ !arr[@]} &#34; ;  do  printf   &#39;%s\n &#39;   &#34; ${arr[i]} &#34; done  # Alternative method. for   ((i = 0;i &lt; ${ #arr[@]};i ++ )) ;  do  printf   &#39;%s\n &#39;   &#34; ${arr[i]} &#34; done</p><p>arr=（苹果橙子番茄）#元素和索引。因为我在&#34${！啊[@]}&#34；打印F&#39；%s\n和#39&#34; ${arr[i]}&#34；完成#替代方法。对于（（i=0；i&lt；${#arr[@]}；i++）；打印F&#39；%s\n和#39&#34; ${arr[i]}&#34；完成</p><p>     # Greedy example. for  file  in  * ;  do  printf   &#39;%s\n &#39;   &#34; $file &#34; done  # PNG files in dir. for  file  in  ~/Pictures/ *.png ;  do  printf   &#39;%s\n &#39;   &#34; $file &#34; done  # Iterate over directories. for  dir  in  ~/Downloads/ */ ;  do  printf   &#39;%s\n &#39;   &#34; $dir &#34; done  # Brace Expansion. for  file  in /path/to/parentdir/{file1,file2,subdir/file3} ;  do  printf   &#39;%s\n &#39;   &#34; $file &#34; done  # Iterate recursively. shopt -s globstar for  file  in  ~/Pictures/ **/ * ;  do  printf   &#39;%s\n &#39;   &#34; $file &#34; done shopt -u globstar</p><p>#贪婪的例子。存档*；打印F&#39；%s\n和#39&#34; $文件&#34；完成#在dir中保存PNG文件。用于~/Pictures/*中的文件。巴布亚新几内亚；打印F&#39；%s\n和#39&#34; $文件&#34；完成#遍历目录。对于~/Downloads/*/中的dir；打印F&#39；%s\n和#39&#34; $署长&#34；完成#支架扩展。对于/path/to/parentdir/{file1，file2，subdir/file3}中的文件；打印F&#39；%s\n和#39&#34; $文件&#34；完成#递归迭代。shopt-s globstar用于~/Pictures/***中的文件；打印F&#39；%s\n和#39&#34; $文件&#34；完成shopt-u globstar</p><p>        # Bash &lt;4 (discarding empty lines).IFS=  $&#39; \n &#39;  read -d   &#34; &#34; -ra file_data  &lt;   &#34;file &#34;  # Bash &lt;4 (preserving empty lines). while  read -r line ;  do file_data+=(  &#34; $line &#34;) done  &lt;   &#34;file &#34;  # Bash 4+mapfile -t file_data  &lt;   &#34;file &#34;</p><p>#Bash&lt；4（丢弃空行）。IFS=$和#39；\n&#39；阅读-d&#34&#34; -ra文件_数据&lt&#34;文件&#34；#Bash&lt；4（保留空行）。而read-r行；do file_data+=（&#34；$line&#34；）完成&lt&#34;文件&#34；#Bash 4+mapfile-t file_data&lt&#34;文件&#34；</p><p>     head() {   # Usage: head &#34;n&#34; &#34;file&#34; mapfile -tn   &#34; $1 &#34; line  &lt;   &#34; $2 &#34;  printf   &#39;%s\n &#39;   &#34; ${line[@]} &#34;}</p><p>head（）{用法：head&#34；n&#34；file&#34；mapfile-tn&#34；$1&#34；line&lt；&#34；$2&#34；printf&#39；%s\n&#39；&#34$#line[@]</p><p>       tail() {   # Usage: tail &#34;n&#34; &#34;file&#34; mapfile -tn 0 line  &lt;   &#34; $2 &#34;  printf   &#39;%s\n &#39;   &#34; ${line[@] : - $1} &#34;}</p><p>tail（）{用法：tail&#34；n&#34；&#34；file&#34；mapfile-tn 0行&lt；&#34；$2&#34；printf&#39；%s\n&#39；&#34；${line[@]：$1&#34；]</p><p>  $ tail 2  ~/.bashrc  # Enable tmux.  # [[ -z &#34;$TMUX&#34; ]] &amp;&amp; exec tmux$ tail 1  ~/.bashrc  # [[ -z &#34;$TMUX&#34; ]] &amp;&amp; exec tmux</p><p>$tail 2~/。bashrc#启用tmux。#[-z&#34；$TMUX&#34；]]&amp&amp；exec tmux$tail 1~/。bashrc#[-z&#34；$TMUX&#34；]]&amp&amp；执行官tmux</p><p>    lines() {   # Usage: lines &#34;file&#34; mapfile -tn 0 lines  &lt;   &#34; $1 &#34;  printf   &#39;%s\n &#39;   &#34; ${ #lines[@]} &#34;}</p><p>lines（）{用法：lines&#34；file&#34；mapfile-tn 0 lines&lt；&#34；$1&#34；printf&#39；%s\n&#39；&#34；${#lines[@]}&#34；}</p><p>  This method uses less memory than the  mapfile method and works in  bash 3 but it is slower for bigger files.</p><p>该方法使用的内存比mapfile方法少，在bash 3中也可以使用，但对于较大的文件，它的速度较慢。</p><p> lines_loop() {   # Usage: lines_loop &#34;file&#34; count=0  while IFS=  read -r _ ;  do   ((count ++ ))  done  &lt;   &#34; $1 &#34;  printf   &#39;%s\n &#39;   &#34; $count &#34;}</p><p>lines_loop（）{用法：lines_loop&#34；file&#34；count=0，而IFS=read-r#do（（count++）done&lt；&#34；$1&#34；printf&#39；%s\n&#39；&#34；$count 34；}</p><p>    This works by passing the output of the glob to the function and then counting the number of arguments.</p><p>其工作原理是将glob的输出传递给函数，然后计算参数的数量。</p><p>    # Count all files in dir.$ count  ~/Downloads/ *232  # Count all dirs in dir.$ count  ~/Downloads/ */45  # Count all jpg files in dir.$ count  ~/Pictures/ *.jpg64</p><p>#计算目录中的所有文件。$count~/Downloads/*232#计算目录中的所有目录。$count~/Downloads/*/45#计算目录中的所有jpg文件。$计数~/Pictures/*。jpg64</p><p>      extract() {   # Usage: extract file &#34;opening marker&#34; &#34;closing marker&#34;  while IFS=  $&#39; \n &#39;  read -r line ;  do [[  $extract  &amp;&amp;  $line  !=   &#34; $3 &#34; ]]  &amp;&amp;  printf   &#39;%s\n &#39;   &#34; $line &#34; [[  $line  ==   &#34; $2 &#34; ]]  &amp;&amp; extract=1 [[  $line  ==   &#34; $3 &#34; ]]  &amp;&amp; extract=  done  &lt;   &#34; $1 &#34;}</p><p>extract（）{用法：extract file&#34；opening marker&#34；&#34；closing marker&#34；而IFS=$&#39；\n&#39；read-r line；do[$extract&amp；$line！=&#34；$3&#34；]&amp&amp；printf&#39；%s\n和#39&#34; $第34行；[$line==&#34；$2&#34；]&amp&amp；摘录=1[$line==&#34；$3&#34；]]&amp&amp；提取=完成&lt&#34; $1 &#34;}</p><p>       dirname() {   # Usage: dirname &#34;path&#34;  local tmp= ${1 :-.} [[  $tmp  !=  *[ !/] * ]]  &amp;&amp; {  printf   &#39;/\n &#39;  return } tmp= ${tmp %%  &#34; ${tmp ##*[!/]} &#34;} [[  $tmp  !=  */ * ]]  &amp;&amp; {  printf   &#39;.\n &#39;  return } tmp= ${tmp %/*} tmp= ${tmp %%  &#34; ${tmp ##*[!/]} &#34;}  printf   &#39;%s\n &#39;   &#34; ${tmp :-/} &#34;}</p><p>dirname（）{#用法：dirname&#34；path&#34；local tmp=${1:-.}[[$tmp！=*[！/]*]&amp&amp；{printf&#39；/\n&#39；return}tmp=${tmp%%&#34；${tmp###*[！/]}&#34；}[$tmp！=*/*]&amp&amp；{printf&#39；\n&#39；return}tmp=${tmp%/*}tmp=${tmp%&#34；${tmp###*[！/]}&#34；}printf&#39；%s\n和#39&#34; ${tmp:-/}&#34；}</p><p>      basename() {   # Usage: basename &#34;path&#34; [&#34;suffix&#34;]  local tmp tmp= ${1 %  &#34; ${1 ##*[!/]} &#34;} tmp= ${tmp ##*/} tmp= ${tmp %  &#34; ${2 /  &#34; $tmp &#34;} &#34;}  printf   &#39;%s\n &#39;   &#34; ${tmp :-/} &#34;}</p><p>basename（）{用法：basename&#34；path&#34；[&#34；后缀&#34；]本地tmp tmp=${1%&#34；${1##*[！/]}&#34；}tmp=${tmp##*/}tmp=${tmp%&#34；${2/&#34；$tmp&#34；}&#34;}  printf&#39；%s\n和#39&#34; ${tmp:-/}&#34；}</p><p>     $ hello_world=  &#34;value &#34;  # Create the variable name.$ var=  &#34;world &#34;$ ref=  &#34;hello_ $var &#34;  # Print the value of the variable name stored in &#39;hello_$var&#39;.$  printf   &#39;%s\n &#39;   &#34; ${ !ref} &#34;value</p><p>$hello_world=&#34；价值&#34；#创建变量名。$var=&#34；世界&#34；美元ref=&#34；你好，$var&#34；#打印存储在&#39中的变量名的值；你好$var&#39；$printf&#39；%s\n和#39&#34; ${！ref}&#34；价值</p><p>      Contrary to popular belief, there is no issue in utilizing raw escape sequences. Using  tput abstracts the same ANSI sequences as if printed manually. Worse still,  tput is not actually portable. There are a number of  tput variants each with different commands and syntaxes ( try  tput setaf 3 on a FreeBSD system). Raw sequences are fine.</p><p>与普遍的看法相反，利用原始逃逸序列没有问题。使用tput提取与手动打印相同的ANSI序列。更糟糕的是，tput实际上并不便携。有很多tput变体，每个都有不同的命令和语法（在FreeBSD系统上尝试tput setaf 3）。原始序列很好。</p><p>     NOTE: Prepend 2 to any code below to turn it&#39;s effect off(examples: 21=bold text off, 22=faint text off, 23=italic text off).</p><p>注意：在下面任何代码前加上2，将其变成&#39；s效果关闭（示例：21=粗体文本关闭，22=模糊文本关闭，23=斜体文本关闭）。</p><p>        Expand to  IFS separated list of variable names starting with  VAR. If double-quoted, each variable name expands to a separate word.</p><p>展开到以VAR开头的变量名的IFS分隔列表。如果双引号，每个变量名将展开到一个单独的单词。</p><p>      Get substring from  N character to  N character.   ( ${VAR:10:10}: Get sub-string from char  10 to char  20)</p><p>从N个字符到N个字符获取子字符串。（${VAR:10:10}：从char 10到char 20获取子字符串）</p><p>       # Syntax: {&lt;START&gt;..&lt;END&gt;}  # Print numbers 1-100. echo {1..100}  # Print range of floats. echo 1.{1..9}  # Print chars a-z. echo {a..z} echo {A..Z}  # Nesting. echo {A..Z}{0..9}  # Print zero-padded numbers.  # CAVEAT: bash 4+ echo {01..100}  # Change increment amount.  # Syntax: {&lt;START&gt;..&lt;END&gt;..&lt;INCREMENT&gt;}  # CAVEAT: bash 4+ echo {1..10..2}   # Increment by 2.</p><p>#语法：{&lt；开始&gt；.&lt；结束&gt；}打印数字1-100。echo{1..100}#打印浮动范围。回声1。{1..9}#打印字符a-z.echo{a..z}echo{a..z}#嵌套。echo{A..Z}{0..9}#打印零填充数字。#警告：bash4+echo{01..100}#更改增量金额。#语法：{&lt；开始&gt；.&lt；结束&gt；&lt；递增&gt；}警告：bash4+echo{1..10..2}#增加2。</p><p>       If  file is newer than  file2 ( uses modification time) or  file exists and  file2 does not.</p><p>如果文件比文件2新（使用修改时间），或者文件存在而文件2不存在。</p><p> If  file is older than  file2 ( uses modification time) or  file2 exists and  file does not.</p><p>如果文件早于文件2（使用修改时间），或者文件2存在而文件不存在。</p><p>                    # Set the value of var to var2 if var2 is greater than var.  # var: variable to set.  # var2&gt;var: Condition to test.  # ?var2: If the test succeeds.  # :var: If the test fails.  ((var =var 2 &gt;var ?var 2 :var ))</p><p>#如果var2大于var，则将var的值设置为var2。#var:要设置的变量。#var2&gt；var：要测试的条件。#？var2：如果测试成功。#如果测试失败。（（var=var 2&gt；var？var 2:var））</p><p>  Traps allow a script to execute code on various signals. In  pxltrm ( a pixel art editor written in bash) traps are used to redraw the user interface on window resize. Another use case is cleaning up temporary files on script exit.</p><p>陷阱允许脚本在各种信号上执行代码。在pxltrm（一个用bash编写的像素艺术编辑器）中，陷阱用于在调整窗口大小时重新绘制用户界面。另一个用例是在脚本退出时清理临时文件。</p><p> Traps should be added near the start of scripts so any early errors are also caught.</p><p>应该在脚本开始附近添加陷阱，以便捕获任何早期错误。</p><p>              If unicode is not required, it can be disabled for a performance increase. Results may vary however there have been noticeable improvements in  neofetch and other programs.</p><p>如果不需要unicode，可以禁用它以提高性能。结果可能会有所不同，但是neofetch和其他程序已经有了明显的改进。</p><p>      NOTE: There are times when one may have a good reason for using  #!/bin/bash or another direct path to the binary.</p><p>注意：有时人们可能有充分的理由使用#/bin/bash或二进制文件的另一个直接路径。</p><p>                  &#34; $HOSTNAME &#34;  # NOTE: This variable may be empty.  # Optionally set a fallback to the hostname command.  &#34; ${HOSTNAME :-$(hostname)} &#34;</p><p>&#34; $主机名&#34；#注意：此变量可能为空。#（可选）将回退设置为hostname命令&#34; ${HOSTNAME:-$（HOSTNAME）}&#34；</p><p>    This can be used to add conditional support for different OperatingSystems without needing to call  uname.</p><p>这可以用于为不同的操作系统添加条件支持，而无需调用uname。</p><p>        Each time  $RANDOM is used, a different integer between  0 and  32767 is returned. This variable should not be used for anything related to security ( this includes encryption keys etc).</p><p>每次使用$RANDOM时，都会返回一个介于0和32767之间的不同整数。此变量不应用于任何与安全性相关的内容（包括加密密钥等）。</p><p>    This is handy when writing scripts in pure bash and  stty/ tput can’t becalled.</p><p>在纯bash和stty/tput中编写脚本时，这很方便。</p><p>  get_term_size() {   # Usage: get_term_size   # (:;:) is a micro sleep to ensure the variables are   # exported immediately.  shopt -s checkwinsize ; (: ;:)  printf   &#39;%s\n &#39;   &#34; $LINES  $COLUMNS &#34;}</p><p>get_term_size（）{#用法：get_term_size#（：：）是一个微睡眠，以确保变量立即导出。shopt-s checkwinsize；（：：：）printf&#39；%s\n&#39；&#34；$LINES$COLUMNS&#34；}</p><p>      get_window_size() {   # Usage: get_window_size  printf   &#39;%b &#39;   &#34; ${TMUX :+ \\ePtmux; \\e} \\e[14t ${TMUX :+ \\e \\\\} &#34; IFS=  &#39;;t &#39;  read -d t -t 0.05 -sra term_size  printf   &#39;%s\n &#39;   &#34; ${term_size[1]}x ${term_size[2]} &#34;}</p><p>用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：用法：获取窗户尺寸图尺寸印刷F和39；%b和39；b和[35；39；b和[35；34；b和39；b和39；阅读-t-t-t-t 0.05-sra术语t t t-t-t 0.05-sra术语t-t-0.05-sra术语（sra术语）t-t-t-sra术语）t-t-t-t-0.05-sra术语（sra术语）t-t-t-t-t）t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-t-#34；}</p><p>      get_cursor_pos() {   # Usage: get_cursor_pos IFS=  &#39;[; &#39;  read -p   $&#39; \e[6n &#39; -d R -rs _ y x _  printf   &#39;%s\n &#39;   &#34; $x  $y &#34;}</p><p>get_cursor_pos（）{#用法：get_cursor_pos IFS=&#39；[#&#39；read-p$&#39；\e[6n&#39；-dr-rs y x#printf 39；%s\n&#39；&#34；$x$y&#34；]</p><p>      hex_to_rgb() {   # Usage: hex_to_rgb &#34;#FFFFFF&#34;   # hex_to_rgb &#34;000000&#34;  :   &#34; ${1 / \#} &#34;   ((r = 16# ${_ :0 :2} ,g = 16# ${_ :2 :2} ,b = 16# ${_ :4 :2} ))  printf   &#39;%s\n &#39;   &#34; $r  $g  $b &#34;}</p><p>hex_to_rgb（）{用法：hex_to_rgb&#34；#FFFFFF&#34；#hex_to_rgb&#34；000000&#34；：&#34；${1/\\\\}34；（r=16#${0:2}，g=16#${2:2}，b=16#${4:2}）printf&#39；%s\n和#39&#34; $r$g$b&#34；}</p><p>          # Tiny C Style.for  ((;i ++&lt; 10; )){  echo   &#34; $i &#34; ;}  # Undocumented method. for  i  in {1..10} ;{  echo   &#34; $i &#34; ;}  # Expansion. for  i  in {1..10} ;  do  echo   &#34; $i &#34; ;  done  # C Style.for  ((i = 0;i &lt;= 10;i ++ )) ;  do  echo   &#34; $i &#34; ;  done</p><p>#小C风格。对于（；i++&lt；10；））{echo&#34；$i&#34；}未记录的方法。因为{1..10}中的i；{echo&#34；$i&#34；}膨胀因为{1..10}中的i；做回声&#34$我&#34；完成#C风格。（i=0；i&lt；=10；i++）；做回声&#34$我&#34；完成</p><p>    # Normal method f(){  echo hi;}  # Using a subshell f()(echo hi)  # Using arithmetic  # This can be used to assign integer values.  # Example: f a=1  # f a++ f()  (( $1 ))  # Using tests, loops etc.  # NOTE: ‘while’, ‘until’, ‘case’, ‘(())’, ‘[[]]’ can also be used. f()if  true;  then  echo   &#34; $1 &#34; ;  fi f()for i  in   &#34; $@ &#34;;  do  echo   &#34; $i &#34; ;  done</p><p>#正规方法f（）{echo hi；}#使用子shell f（）（echo hi）#使用算术#这可以用来分配整数值。#示例：fa=1 35; fa++f（）（$1））#使用测试、循环等#注意：'while'、'until'、'case'、'（（））'、'[[]）也可以使用。f（）如果为真；然后是回声&#34$1 &#34; ;  fi f（）代表i in&#34；$@&#34;;  做回声&#34$我&#34；完成</p><p>  # One line  # Note: The 3rd statement may run when the 1st is true[[  $var  == hello ]]  &amp;&amp;  echo hi  ||  echo bye[[  $var  == hello ]]  &amp;&amp; {  echo hi ;  echo there ; }  ||  echo bye  # Multi line (no else, single statement)  # Note: The exit status may not be the same as with an if statement[[  $var  == hello ]]  &amp;&amp;  echo hi  # Multi line (no else)[[  $var  == hello ]]  &amp;&amp; {  echo hi   # ...}</p><p>#一行#注意：第三条语句可能会在第一条语句为真时运行[$var==hello]]&amp&amp；echo hi | | echo bye[$var==你好]]&amp&amp；{echo hi；echo那里；}||echo bye#多行（无其他，单语句）#注意：退出状态可能与if语句[[$var==hello]]不同&amp&amp；echo hi#多行（无其他）[$var==hello]]&amp&amp；{echo hi#..}</p><p>  The  : built-in can be used to avoid repeating  variable= in a case statement. The  $_ variable stores the last argument of the last command.  : always succeeds so it can be used to store the variable value.</p><p>：内置可用于避免在case语句中重复变量=。$变量存储最后一个命令的最后一个参数：始终成功，以便可以使用它存储变量值。</p><p> # Modified snippet from Neofetch. case   &#34; $OSTYPE &#34;  in   &#34;darwin &#34; *)  :   &#34;MacOS &#34; ;;   &#34;linux &#34; *)  :   &#34;Linux &#34; ;;  *  &#34;bsd &#34; * |   &#34;dragonfly &#34; |   &#34;bitrig &#34;)  :   &#34;BSD &#34; ;;   &#34;cygwin &#34; |   &#34;msys &#34; |   &#34;win32 &#34;)  :   &#34;Windows &#34; ;;  *)  printf   &#39;%s\n &#39;   &#34;Unknown OS detected, aborting... &#34;  &gt;&amp;2  exit 1 ;; esac  # Finally, set the variable.os=  &#34; $_ &#34;</p><p>#修改了Neofetch中的代码片段。34例$OSTYPE&#34；在&#34；达尔文&#34；*）：&#34;马科斯&#34&#34;linux&#34；*）：&#34;Linux&#34；；*&#34;bsd&#34；*|&#34;蜻蜓&#34；|&#34;比特瑞格（bitrig&#34；）：&#34;BSD&#34&#34;西格温&#34；|&#34;msys&#34；|&#34;win32&#34；）：&#34;窗户&#34；；*）printf&#39；%s\n和#39&#34;检测到未知操作系统，正在中止&#34;  &gt&amp；2.出口1；；esac#最后，设置变量。os=&#34；$\U&#34;</p><p>      read_sleep() {   # Usage: read_sleep 1   # read_sleep 0.2  read -rt   &#34; $1 &#34;  &lt;&gt;   &lt;(: )  ||  :}</p><p>read#u sleep（）{#用法：read#u sleep 1#read#u sleep 0.2 read-rt&#34；$1&#34；&lt；&gt；&lt；（：）|：}</p><p>   For performance-critical situations, where it is not economic to open and close an excessive number of file descriptors, the allocation of a file descriptor may be done only once for all invocations of  read:</p><p>对于性能关键的情况，如果打开和关闭过多的文件描述符是不经济的，那么对于所有读取调用，文件描述符的分配只能进行一次：</p><p>  exec {sleep_fd} &lt;&gt;   &lt;(: ) while some_quick_test ;  do   # equivalent of sleep 0.001  read -t 0.001 -u  $sleep_fd done</p><p>执行{sleep_fd}&lt&gt&书信电报；（：）而一些快速测试；do#相当于sleep 0.001 read-t0.001-u$sleep#u fd done</p><p>  # There are 3 ways to do this and either one can be used. type -p executable_name  &amp; &gt;/dev/null hash executable_name  &amp; &gt;/dev/null command -v executable_name  &amp; &gt;/dev/null  # As a test. if  type -p executable_name  &amp; &gt;/dev/null ;  then   # Program is in PATH. fi  # Inverse. if  !  type -p executable_name  &amp; &gt;/dev/null ;  then   # Program is not in PATH. fi  # Example (Exit early if program is not installed). if  !  type -p convert  &amp; &gt;/dev/null ;  then  printf   &#39;%s\n &#39;   &#34;error: convert is not installed, exiting... &#34;  exit 1 fi</p><p>#有三种方法可以做到这一点，任何一种都可以使用。类型-p可执行文件名称&amp&gt/dev/null哈希可执行文件\u name&amp&gt/dev/null命令-v可执行文件名称&amp&gt/dev/null#作为测试。如果类型为-p可执行文件名称&amp&gt/dev/null；然后#程序进入路径。fi#逆。如果类型-p可执行文件名称&amp&gt/dev/null；那么#程序不在路径中。fi#示例（如果未安装程序，请提前退出）。如果类型-p转换&amp&gt/dev/null；然后printf&#39；%s\n和#39&#34;错误：未安装转换，正在退出&#34;  1号出口</p><p>  Bash’s  printf has a built-in method of getting the date which can be used in place of the  date command.</p><p>Bash的printf有一个获取日期的内置方法，可以用来代替date命令。</p><p>   date() {   # Usage: date &#34;format&#34;   # See: &#39;man strftime&#39; for format.  printf   &#34;%( $1)T \\n &#34;   &#34;-1 &#34;}</p><p>date（）{用法：date&#34；format&#34；#参见：&#39；man strftime&#39；获取format.printf&#34；（$1）T\\n&#34；&#34；-1&#34；}</p><p>  # Using above function.$ date   &#34;%a %d %b - %l:%M %p &#34;Fri 15 Jun - 10:00 AM  # Using printf directly.$  printf   &#39;%(%a %d %b - %l:%M %p)T\n &#39;   &#34;-1 &#34;Fri 15 Jun - 10:00 AM  # Assigning a variable using printf.$  printf -v date   &#39;%(%a %d %b - %l:%M %p)T\n &#39;   &#39;-1 &#39;$  printf   &#39;%s\n &#39;   &#34; $date &#34;Fri 15 Jun - 10:00 AM</p><p>#使用上述功能。$日期&#34；%a%d%b-%l:%M%p&#34；6月15日星期五上午10:00#直接使用printf。$printf&#39；%（%a%d%b-%l:%M%p）T\n和#39&#34;-1 &#34;6月15日星期五上午10:00#使用printf分配变量。$printf-v日期和#39；%（%a%d%b-%l:%M%p）T\n和#39&#39;-1 &#39;$  printf&#39；%s\n和#39&#34; $日期&#34；6月15日星期五上午10:00</p><p>   $  :  \\u  # Expand the parameter as if it were a prompt string.$  printf   &#39;%s\n &#39;   &#34; ${_ @P} &#34;black</p><p>$：\\u#展开参数，就像它是一个提示字符串一样。$printf&#39；%s\n和#39&#34; ${@P}&#34；黑色</p><p>    uuid() {   # Usage: uuid C=  &#34;89ab &#34;  for   ((N = 0;N &lt; 16; ++N )) ;  do B=  &#34;  $((RANDOM % 256 )) &#34;  case   &#34; $N &#34;  in 6)  printf   &#39;4%x &#39;   &#34;  $((B % 16 )) &#34; ;; 8)  printf   &#39;%c%x &#39;   &#34; ${C : $RANDOM % ${ #C} :1} &#34;   &#34;  $((B % 16 )) &#34; ;; 3|5|7|9)  printf   &#39;%02x- &#39;   &#34; $B &#34; ;;  *)  printf   &#39;%02x &#39;   &#34; $B &#34; ;;  esac  done  printf   &#39;\n &#39;}</p><p>（N=0；N&lt；16；N&lt；16；N；N&lt；16；N；N&lt；16；N；N；N&lt；16；N+N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N）N（N）34；N）34；N（N（N（N（N（N（N）N；N）N（N）N；N）N；N；N）N；N；N；N；N；N）N）N）N）N；N）N）N）N）N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N；N）34；N）%${#C}:1}&#34&#34;  $（（B%16））和#34；；3 | 5 | 7 | 9）打印和#39；%02x-#39&#34; $B&#34；；*）printf&#39；%02x和#39&#34; $B&#34；；esac完成了打印F和#39；\n&#39；}</p><p>    This is a simple way of drawing progress bars without needing a for loopin the function itself.</p><p>这是一种绘制进度条的简单方法，无需函数本身中的for循环。</p><p>  bar() {   # Usage: bar 1 10   # ^----- Elapsed Percentage (0-100).   # ^-- Total length in chars.   ((elapsed = $1 * $2 / 100 ))   # Create the bar with spaces.  printf -v prog   &#34;% ${elapsed}s &#34;  printf -v total   &#34;%  $(( $2 -elapsed ))s &#34;  printf   &#39;%s\r &#39;   &#34;[ ${prog //  /-}${total}] &#34;}</p><p>bar（）{#用法：bar 1 10#^--经过的百分比（0-100）。#^--以字符为单位的总长度。（（经过的=$1*$2/100））#用空格创建条形图；printf-v总计和#34；%$（（$2-已逝））s和#34；printf&#39；%s\r&#39&#34;[${prog//-}${total}]&#34；}</p><p>  for   ((i = 0;i &lt;= 100;i ++ )) ;  do   # Pure bash micro sleeps (for the example). (: ;:)  &amp;&amp; (: ;:)  &amp;&amp; (: ;:)  &amp;&amp; (: ;:)  &amp;&amp; (: ;:)   # Print the bar. bar   &#34; $i &#34;   &#34;10 &#34; done printf   &#39;\n &#39;</p><p>（i=0；i&lt；=100；i++）；do#Pure bash micro sleeps（例如）。（：；：）&amp&amp；（：；：）&amp&amp；（：；：）&amp&amp；（：；：）&amp&amp；打印条。酒吧&#34$我&#34&#34;10 &#34; 完成打印F和#39；\n&#39；</p><p>  get_functions() {   # Usage: get_functions IFS=  $&#39; \n &#39;  read -d   &#34; &#34; -ra functions  &lt;   &lt;(declare -F )  printf   &#39;%s\n &#39;   &#34; ${functions[@] //declare -f } &#34;}</p><p>get#u functions（）{#用法：get#u functions IFS=$&#39；\n&#39；read-d&#34；&#34；&#ra functions&lt；；（declare-F）printf&#39；%s\n&#39；&#34；${functions[@]//declare-F}&#34；}</p><p>      This will run the given command and keep it running, even after the terminal or SSH connection is terminated. All output is ignored.</p><p>这将运行给定的命令并保持其运行，即使在终端或SSH连接终止后也是如此。所有输出都被忽略。</p><p> bkr() { (nohup   &#34; $@ &#34;  &amp; &gt;/dev/null  &amp;)}bkr ./some_script.sh   # some_script.sh is now running in the background</p><p>bkr（）{（nohup&#34；$@&#34；&amp；&gt；/dev/null&amp；）}bkr/一些剧本。sh#一些脚本。sh现在正在后台运行</p><p>   This uses local namerefs to avoid using  var=$(some_func) style command substitution for function output captu</p><p>它使用本地namerefs来避免使用var=$（some_func）样式的命令替换函数输出captu</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/bash/">#bash</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/用法/">#用法</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>