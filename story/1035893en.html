<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>您最喜欢的C编程技巧是什么？What is your favorite C programming trick?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What is your favorite C programming trick?<br/>您最喜欢的C编程技巧是什么？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-22 20:18:10</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/ff0287210796737fd34a6056d629fa7a.png"><img src="http://img2.diglog.com/img/2020/11/ff0287210796737fd34a6056d629fa7a.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>So, in your code, if you have some structure which must be, say a multiple of 8 bytes in size, maybe because of some hardware constraints, you can do:</p><p>因此，在您的代码中，如果您具有某种必须为8个字节大小的倍数的结构，可能由于某些硬件限制，您可以执行以下操作：</p><p>  and it won&#39;t compile unless the size of struct mystruct is a multiple of 8, and if it is a multiple of 8, no runtime code is generated at all.</p><p>  除非struct mystruct的大小是8的倍数，否则它不会编译；如果它是8的倍数，则根本不会生成任何运行时代码。</p><p> Another trick I know is from the book &#34;Graphics Gems&#34; which allows a single header file to both declare and initialize variables in one module while in other modules using that module, merely declare them as externs.</p><p> 我知道的另一个技巧是《图形宝石》一书，它允许单个头文件在一个模块中声明和初始化变量，而在其他使用该模块的模块中，仅将其声明为externs。</p><p> #ifdef DEFINE_MYHEADER_GLOBALS#define GLOBAL#define INIT(x, y) (x) = (y)#else#define GLOBAL extern#define INIT(x, y)#endifGLOBAL int INIT(x, 0);GLOBAL int somefunc(int a, int b);</p><p> #ifdef DEFINE_MYHEADER_GLOBALS＃定义GLOBAL＃定义INIT（x，y）（x）=（y）＃else＃定义GLOBAL extern＃定义INIT（x，y）#endifGLOBAL int INIT（x，0）; GLOBAL int somefunc（int a，int b）;</p><p>     So you get one header file that declares both instances of globals and function prototypes where they are needed, and the corresponding extern declarations.</p><p>     因此，您将获得一个头文件，该头文件声明需要它们的全局实例和函数原型的实例，以及相应的extern声明。</p><p>    void func(type* values) { while(*values) { x = *values++; /* do whatever with x */ }}func((type[]){val1,val2,val3,val4,0});</p><p>    void func（type * values）{while（* values）{x = * values ++; / *使用x * /}} func（（type []）{val1，val2，val3，val4,0}）进行任何操作；</p><p>  int main() { struct llist { int a; struct llist* next;}; #define cons(x,y) (struct llist[]){{x,y}} struct llist *list=cons(1, cons(2, cons(3, cons(4, NULL)))); struct llist *p = list; while(p != 0) { printf(&#34;%d\n&#34;, p-&gt;a); p = p-&gt;next; }}</p><p>  int main（）{struct llist {int a; struct llist * next;}; #define cons（x，y）（struct llist []）{{x，y}} struct llist * list = cons（1，cons（2，cons（3，cons（4，NULL）））））; struct llist * p =列表； while（p！= 0）{printf（“％d \ n”，p-> a）; p = p->下一个； }}</p><p>  I believe your first example can also be written as  &amp;(int){1}, if you want to make it slightly more clear what your intent here is. –  Lily Ballard</p><p>我相信您的第一个示例也可以写为＆（int）{1}，如果您想使其更清楚地说明您的意图。 –莉莉·巴拉德</p><p>      Since then, a new world of creative use of the preprocessor opened in front of my eyes. I no longer include just headers, but entire chunks of code now and then (it improves reusability a lot) :-p</p><p>      从那时起，对预处理器进行创造性使用的新世界在我眼前张开。我不再仅包含标题，而是不时地包含整个代码块（它大大提高了可重用性）：-p</p><p>  You can&#39;t say carmack in an optimization thread without mentioning the fast inverse sqrt that was in the quake source.  en.wikipedia.org/wiki/Fast_inverse_square_root –  pg1989</p><p>  您不能在优化线程中说出carmack，而不必提及地震源中的快速逆平方根。 zh.wikipedia.org/wiki/Fast_inverse_square_root – pg1989</p><p>    @RoryHarvey: From what I could find when looking it up, it seems it was purely empirical. Some studies (I don&#39;t remember where I saw them) demonstrated that it was close to optimal, but not fully optimal. Likewise, it seems that for 64bits the value was discovered, rather than computing. –  Matthieu M.</p><p>    @RoryHarvey：从查找时可以发现，似乎纯粹是经验性的。一些研究（我不记得我在哪里看到过）表明它接近最佳，但不是完全最佳。同样，对于64位，似乎发现了该值，而不是计算出来的值。 –马提厄M.</p><p>    This will initialize all of the members of the struct (or array) to zero (but not any padding bytes - use memset if you need to zero those as well).</p><p>    这会将结构（或数组）的所有成员初始化为零（但不会填充任何填充字节-如果您也需要将其填充为零，请使用memset）。</p><p>  Not needed for  static variables. Global variables may be zeroed, but it&#39;s not a requirement. –  Jamie</p><p>  静态变量不需要。全局变量可能为零，但这不是必需的。 -  杰米</p><p>  I sometimes extend this to:  const struct something zero_something = { 0 }; and then I can reset a variable on the fly with  struct something X = zero_something; or part-way through a routine I can use &#39;X = zero_something;&#39;. The only possible objection is that it involves reading data from somewhere; these days, a &#39;memset()&#39; might be quicker - but I like the clarity of the assignment, and it is also possible to use other-than-zero values in the initializer too (and memset() followed by tweaks to individual member may be slower than a simple copy). –  Jonathan Leffler</p><p>  有时我将其扩展为：const struct something zero_something = {0};然后我可以使用结构X = zero_something即时重置变量；或者在例行程序中我可以使用'X = zero_something;'。唯一可能的反对意见是，它涉及从某处读取数据。如今，“ memset（）”可能会更快-但我喜欢赋值的清晰性，也可以在初始化器中使用非零值（和memset（），然后对单个成员进行调整）可能比简单副本要慢）。 –乔纳森·莱夫勒</p><p>      If we are talking about c tricks my favourite has to be  Duff&#39;s Device for loop unrolling! I&#39;m just waiting for the right opportunity to come along for me to actually use it in anger...</p><p>如果我们在谈论c技巧，我最喜欢的必须是Duff的用于循环展开的设备！我只是在等待正确的机会，让我真正地在愤怒中使用它...</p><p>  I&#39;ve used it once to produce a measurable performance gain, but these days it&#39;s not useful on a lot of hardware. Always profile! –  Dan Olson</p><p>  我曾经用它来产生可衡量的性能提升，但是如今，它在很多硬件上都没有用。一律剖析！ –丹·奥尔森</p><p>  Yeah, the sort of people who don&#39;t understand the context Duff&#39;s device was created in: &#34;code readability&#34; is useless if the code is not fast enough to work. Probably none of the people who downvoted you have ever had to code for hard realtime. –  Rob K</p><p>  是的，那种不了解上下文的人是由Duff的设备创建的：如果代码不够快，无法正常工作，那么“代码可读性”就没用了。几乎没有人为您投票，而不必为硬实时编写代码。 –罗布K</p><p>  +1, I have actually needed to use Duff&#39;s device a few times. The first time was a loop that basically just copied stuff and did some small transformation on the way. It was much, much faster than a simple memcpy() in that architecture. –  Makis</p><p>  +1，我实际上需要使用Duff的设备几次。第一次是一个循环，该循环基本上只是复制内容，并在此过程中进行了一些小的转换。它比该体系结构中的简单memcpy（）快得多。 – Makis</p><p>  The anger will be from your colleagues and successors who have to maintain your code after you. –  Jonathan Leffler</p><p>  愤怒来自于您的同事和继任者，他们必须在您之后维护您的代码。 –乔纳森·莱夫勒</p><p>  As I said, I am still waiting for the right opportunity - but no one has annoyed me enough yet. I have been writing C for about 25 years now, I think I first came across Duff&#39;s device in the early 90s and I have not had to use it yet. As others have commented this kind of trick is less and less useful now as compilers get better at this kind of optimization. –  Jackson</p><p>  就像我说的那样，我仍在等待合适的机会-但没有人使我感到烦恼。我已经写了25年的C语言，我想我是90年代初第一次接触Duff的设备，而我还没有使用过它。正如其他人所评论的那样，由于编译器在这种优化上变得更好，因此这种技巧现在越来越少了。 杰克逊</p><p>    __FUNCTION__is just an alias for  __func__, and  __func__ is in c99. Quite handy.  __PRETTY_FUNCTION__ in C (GCC) is just another alias for  __func__, but in C++ it will get you the full function signature. –  sklnd</p><p>    __FUNCTION__只是__func__的别名，而__func__在c99中。非常方便。 C（GCC）中的__PRETTY_FUNCTION__只是__func__的另一个别名，但是在C ++中，它将为您提供完整的函数签名。 – sklnd</p><p>    typedef struct{ int value; int otherValue;} s;s test = {.value = 15, .otherValue = 16};/* or */int a[100] = {1,2,[50]=3,4,5,[23]=6,7};</p><p>typedef struct {int value; int otherValue;} s; s test = {.value = 15，.otherValue = 16}; / *或* / int a [100] = {1,2，[50] = 3,4,5，[23] = 6,7};</p><p>    Once a mate of mine and I redefined return to find a tricky stack corruption bug.</p><p>    有一次，我和我重新定义了伙伴关系，找到了一个棘手的堆栈损坏错误。</p><p>  Hopefully that was #define&#39;d in the function body and #undefine&#39;d at the end! –  strager</p><p>  希望这是在函数体中＃define'd并在末尾＃undefine'd！ –更强</p><p>  Not very fond of that - first thing that comes to my mind is that DoSomeStackCheckStuff screws up memory because of some bug and whoever is reading the code is not aware of the redefinition of return and is wonders what the /hell/ is going on. –  gilligan</p><p>  我不太喜欢这一点-我想到的第一件事是DoSomeStackCheckStuff由于某些错误而占用了内存，而谁在读取代码的人都不知道return的重新定义，并且想知道/ hell /会发生什么。 –吉利根</p><p>  @strager But that would make it basically useless. The whole point is to add some tracing to  every function call. Otherwise you would just add a call to  DoSomeStackCheckStuff to the functions you wanted to trace. –  Clueless</p><p>  @strager但这会使它基本上无用。重点是在每个函数调用中添加一些跟踪。否则，您只需将对DoSomeStackCheckStuff的调用添加到要跟踪的函数即可。 –无知</p><p>  @gilligan I don&#39;t think this is the type of thing you leave enabled all the time; it seems pretty handy for one-shot debugging work. –  sunetos</p><p>  @gilligan我认为这不是您一直都启用的功能；一键式调试工作似乎非常方便。 – sunetos</p><p>  does that really work? :) I would have written  #define return if((DoSomeStackCheckStuff) &amp;&amp; 0) ; else return... just as crazy I guess! –  Paolo Bonzini</p><p>  这真的有效吗？ :)我会写#define return if（（DoSomeStackCheckStuff）&& 0）;否则返回...我猜就像疯了一样！ – Paolo Bonzini</p><p>    I like the &#34;struct hack&#34; for having a dynamically sized object.  This site explains it pretty well too (though they refer to the C99 version where you can write &#34;str[]&#34; as the last member of a struct). you could make a string &#34;object&#34; like this:</p><p>我喜欢具有动态大小的对象的“结构黑客”。该站点也对此进行了很好的解释（尽管它们引用的是C99版本，您可以在其中编写“ str []”作为结构的最后一个成员）。您可以像这样创建一个字符串“对象”：</p><p> struct X { int len; char str[1];};int n = strlen(&#34;hello world&#34;);struct X *string = malloc(sizeof(struct X) + n);strcpy(string-&gt;str, &#34;hello world&#34;);string-&gt;len = n;</p><p> 结构X {int len; char str [1];}; int n = strlen（“ hello world”）; struct X * string = malloc（sizeof（struct X）+ n）; strcpy（string-> str，“ hello world”）; string- > len = n;</p><p> here, we&#39;ve allocated a structure of type X on the heap that is the size of an int (for len), plus the length of &#34;hello world&#34;, plus 1 (since str 1 is included in the sizeof(X).</p><p> 在这里，我们在堆上分配了一个类型X的结构，该结构是一个int的大小（对于len），加上“ hello world”的长度，再加上1（因为str1包含在sizeof（X）中）。</p><p> It is generally useful when you want to have a &#34;header&#34; right before some variable length data in the same block.</p><p> 当您想在同一块中的某些可变长度数据之前紧跟着一个“标题”时，它通常很有用。</p><p>  I personally find it easier to just malloc() and realloc() myself and use strlen() whenever I need to find the length, but if you need a program that never knows the length of the string and will likely need to find it many times, this is probably the better road. –  Chris Lutz</p><p>  我个人发现自己自己更容易malloc（）和realloc（），并在需要查找长度时使用strlen（）容易，但是如果您需要一个永远不知道字符串长度并且可能需要查找很多字符串的程序，时代，这可能是更好的路。 –克里斯·卢茨（Chris Lutz）</p><p>  &#34;... the C99 version where you can write &#34;str[]&#34;&#34; I&#39;ve seen zero sized arrays in such a context, like str[0]; fairly often. I think it&#39;s C99. I know older compilers complain about zero sized arrays though. –  smcameron</p><p>  “ ...您可以在其中编写” str []“的C99版本。在这种情况下，我看到了零大小的数组，例如str [0];相当频繁。我认为是C99。我知道老的编译器抱怨零大小的数组。 – smcameron</p><p>  I like this one as well, however, you should use something like  malloc(offsetof(X, str) + numbytes) otherwise things will go wrong because of padding and alignment issues. E.g. sizeof(struct X) might be 8, not 5. –  Fozi</p><p>  我也喜欢这一点，但是，您应该使用malloc（offsetof（X，str）+ numbytes）之类的东西，否则由于填充和对齐问题会出错。例如。 sizeof（结构X）可能是8，而不是5。 –佛子</p><p>  @Fozi: I actually don&#39;t think that would be a problem. Since this version has  str[1] (not  str[]) the 1 byte of str is included in the  sizeof(struct X). This  includes any padding between  len and  str. –  Evan Teran</p><p>@Fozi：我实际上认为这不是问题。由于此版本具有str [1]（不是str []），因此sizeof（struct X）中包含str的1个字节。这包括len和str之间的任何填充。 –埃文·特兰（Evan Teran）</p><p>  @Rusky: How would that negatively effect anything? Suppose there is &#34;padding&#34; after  str. OK, When I allocate  sizeof(struct X) + 10 Then this makes  str effectively  10 - sizeof(int) (or more, since we said there is padding) big. This  overlays  str and any padding after it. The only way that it would have  any difference, is if there were a member after  str which breaks the whole thing anyway, flexible members must be the last. Any padding at the end will only possibly cause too much to be allocated. Please provide a specific example of how it could actually go wrong. –  Evan Teran</p><p>  @Rusky：那会对什么产生负面影响？假设在str之后有“填充”。好的，当我分配sizeof（struct X）+ 10时，这将使str有效地变为10-sizeof（int）（或更多，因为我们说有填充）。这将覆盖str及其后面的任何填充。唯一有区别的方法是，如果在str之后有一个无论如何都会破坏整个事物的成员，则灵活成员必须是最后一个成员。最后的任何填充都只会导致分配过多。请提供一个具体示例，说明它实际上可能如何出错。 –埃文·特兰（Evan Teran）</p><p>    Simply create a struct and a set of functions that take a pointer to that struct as a first parameter.</p><p>    只需创建一个结构和一组函数，并将指向该结构的指针作为第一个参数即可。</p><p>  Is there still something out there that translates C++ into C, like cfront used to? –  MarkJ</p><p>  是否还有某种东西可以像以前的cfront一样将C ++转换为C？ – MarkJ</p><p>  This is hardly object orientation. For OO with inheritance, you&#39;ll need to add some kind of virtual function table to your object struct, which can be overloaded by &#34;subclasses&#34;. There are lots of half-baked &#34;C with classes&#34; -style frameworks out there for this purpose but I recommend staying out of it. –  exDM69</p><p>  这几乎不是面向对象的。对于具有继承的OO，您需要在对象结构中添加某种虚拟函数表，而“子类”可能会重载该表。为此，有很多半熟的“带有类的C”风格的框架，但是我建议不要使用。 – exDM69</p><p>    @exDM69, object orientation is as much a way of thinking about a problem as it is a coding paradigm; you can do it successfully without inheritance. I did this on a few projects before jumping full bore into C++. –  Mark Ransom</p><p>    @ exDM69，面向对象既是一种思考问题的方式，又是一种编码范例；您无需继承即可成功完成此操作。在深入研究C ++之前，我在几个项目上做了这个。 –马克·兰索姆（Mark Ransom）</p><p>        #define COLUMNS(S,E) [(E) - (S) + 1]typedef struct{ char studentNumber COLUMNS( 1, 9); char firstName COLUMNS(10, 30); char lastName COLUMNS(31, 51);} StudentRecord;</p><p>        #define COLUMNS（S，E）[（E）-（S）+ 1] typedef struct {char studentNumber COLUMNS（1，9）; char firstName COLUMNS（10，30）; char lastName COLUMNS（31，51）;} StudentRecord;</p><p>    For creating a variable which is read-only in all modules except the one it&#39;s declared in:</p><p>为了创建一个变量，该变量在除声明的变量之外的所有模块中都是只读的：</p><p>   // Source1.c:#define SOURCE1_C#include Header1.h // MyVar isn&#39;t seen in the headerint MyVar; // Declared in this file, and is writeable</p><p>   // Source1.c：#define SOURCE1_C＃include Header1.h // MyVar在headerint MyVar中看不到； //在此文件中声明，并且可写</p><p>  This feels dangerous. These are declaration and definition that do not match. While compiling  Source2.c, the compiler might assume that  MyVar does not change, even across a function call to  Source1.c. (Note that this, as an actual const variable, differs from a pointer to const. In the latter case, the pointed-to object might still be modified via a different pointer.) –  jilles</p><p>  感觉很危险。这些是不匹配的声明和定义。在编译Source2.c时，编译器可能会假设MyVar不会更改，即使在对Source1.c的函数调用中也是如此。 （请注意，作为一个实际的const变量，它与指向const的指针不同。在后一种情况下，指向的对象仍可以通过其他指针进行修改。） –吉尔</p><p>  This does not produce variable that is readonly only in some compilation units. This produces undefined behavior (see p. 6.2.7.2 of ISO 9899 and also p. 6.7.3.5). –  Ales Hakl</p><p>  这不会产生仅在某些编译单元中为只读的变量。这会产生不确定的行为（请参见ISO 9899的第6.2.7.2页和第6.7.3.5页）。 –艾尔斯·哈克尔</p><p>    Bit-shifts are only defined up to a shift-amount of 31 (on a 32 bit integer)..</p><p>    移位最多只能定义为31（32位整数）上的移位量。</p><p> What do you do if you want to have a computed shift that need to work with higher shift-values as well? Here is how the Theora vide-codec does it:</p><p> 如果要计算移位也需要使用较高的移位值，该怎么办？这是Theora视频编码解码器的工作方式：</p><p>   unsigned int shiftmystuff (unsigned int a, unsigned int v){ unsigned int halfshift = v&gt;&gt;1; unsigned int otherhalf = (v+1)&gt;&gt;1; return (a &gt;&gt; halfshift) &gt;&gt; otherhalf; }</p><p>   unsigned int shiftmystuff（unsigned int a，unsigned int v）{unsigned int halfshift = v >> 1; unsigned int otherhalf =（v + 1）>> 1;返回（a >> halfshift）>> otherhalf; }</p><p> Performing the task the way shown above is a good deal faster than using a branch like this:</p><p>与使用这样的分支相比，以上述方式执行任务要快得多：</p><p> unsigned int shiftmystuff (unsigned int a, unsigned int v){ if (v&lt;=31) return a&gt;&gt;v; else return 0;}</p><p> unsigned int shiftmystuff（unsigned int a，unsigned int v）{如果（v > v;否则返回0；}</p><p>  On my machine, gcc-4.3.2 gets rid of the branch in the second one by using a cmov instruction (conditional move) –  Adam Rosenfield</p><p>  在我的机器上，gcc-4.3.2通过使用cmov指令（条件移动）摆脱了第二个分支 –·亚当·罗森菲尔德</p><p>  &#34;a good deal faster than using a branch&#34;: the difference being that the branch is correct for all values of  v, whereas the  halfshift trick only doubles the allowable range to 63 on a 32-bit architecture, and 127 on a 64-bit one. –  Pascal Cuoq</p><p>  “比使用分支要快得多”：区别在于分支对于v的所有值都是正确的，而Halfshift技巧仅将允许范围加倍到32位体系结构上的63和127。一。 – Pascal Cuoq</p><p>    The most pleasing advantage is that it is simple to force each stimulus/state to check all code paths.</p><p>    最令人高兴的优点是，强制每个刺激/状态检查所有代码路径很简单。</p><p> In an embedded system, I&#39;ll often map an ISR to point to such a table and revector it as needed (outside the ISR).</p><p> 在嵌入式系统中，我经常映射一个ISR以指向这样的表，并根据需要对其进行重新引导（在ISR之外）。</p><p>  One technique I like with this is, if you have a function that requires initialization, you initialize the pointer with a call to the initialization routine. When that runs, the last thing it does is replace the pointer with a pointer to the actual function, then call that function. That way, the initializer automatically gets called the first time the function is called, and the real function gets called every subsequent time. –  TMN</p><p>  我喜欢的一种技术是，如果您有一个需要初始化的函数，则可以通过调用初始化例程来初始化指针。运行该命令时，最后要做的是将指针替换为指向实际函数的指针，然后调用该函数。这样，在第一次调用该函数时会自动调用初始化程序，然后在以后每次调用实函数。 – TMN</p><p>    Another nice pre-processor &#34;trick&#34; is to use the &#34;#&#34; character to print debugging expressions. For example:</p><p>另一个不错的预处理器“技巧”是使用“＃”字符来打印调试表达式。例如：</p><p> #define MY_ASSERT(cond) \ do { \ if( !(cond) ) { \ printf(&#34;MY_ASSERT(%s) failed\n&#34;, #cond); \ exit(-1); \ } \ } while( 0 )</p><p> ＃定义MY_ASSERT（cond）\ do {\ if（！（cond））{\ printf（“ MY_ASSERT（％s）失败\ n”，#cond）; \ exit（-1）; \} \} while（0）</p><p>  The COMPILE_ASSERT macro can&#39;t be used twice though, as it pollutes the namespace with a typedef, and the 2nd usage gets: error: redefinition of typedef ‘__compile_time_assert’ –  smcameron</p><p>  不过，COMPILE_ASSERT宏不能使用两次，因为它会用typedef污染名称空间，而第二种用法是：error：typedef'__compile_time_assert'的重新定义 – smcameron</p><p>  Did you actually try this? You can &#34;typedef foo;&#34; as many times as you like. That&#39;s how you do predeclarations. I&#39;ve used it for 2.5 years now on several compilers, both gcc, VC and a compiler for an embedded environment, and never encountered any difficulties. –  Gilad Naor</p><p>  您真的尝试过吗？您可以“ typedef foo;”尽可能多的次数。这就是您进行预声明的方式。我已经在gcc，VC和嵌入式环境的多个编译器上使用了2.5年，并且从未遇到过任何困难。 –吉拉德·纳尔</p><p>    Yes, I tried it. I cut and pasted the error message from the compiler, which was gcc. –  smcameron</p><p>    是的，我尝试过。我剪切并粘贴了来自gcc编译器的错误消息。 – smcameron</p><p>  @Gilad: it is legal in c++ to have redundant typedefs, but not in c. –  Evan Teran</p><p>  @Gilad：在c ++中拥有冗余的typedef是合法的，但在c中则不行。 –埃文·特兰（Evan Teran）</p><p>    I wouldn&#39;t really call it a favorite trick, since I&#39;ve never used it, but the mention of Duff&#39;s Device reminded me of  this article about implementing Coroutines in C. It always gives me a chuckle, but I&#39;m sure it could be useful some time.</p><p>    因为我从未使用过它，所以我不会真的把它称为最喜欢的把戏，但是提到Duff的设备使我想起了这篇关于用C实现协程的文章。它总是给我带来欢笑，但是我敢肯定有用一些时间。</p><p>  I have actually used this technique in practice to make the code driving a sequence of dependent asynchronous I/O vaguely human-readable. The main difference is that I don&#39;t store the coroutine state in a  static variable but instead allocate a struct dynamically and pass a pointer to that into the coroutine function. A bunch of macros make this more palatable. It&#39;s not nice but better than the async/callback version that jumps all over the place. I&#39;d use green threads (via  swapcontext() on *nixes) if I could though. –  pmdj</p><p>实际上，我实际上已经使用了这种技术，以使驱动一系列相关的异步I / O的代码几乎可以被人类阅读。主要区别在于，我不将协程状态存储在静态变量中，而是动态分配结构，并将指向该结构的指针传递到协程函数中。一堆宏使它更加美味。它不是很好，但是比跳转到各处的异步/回调版本更好。如果可以的话，我会使用绿色线程（通过* nixes上的swapcontext（））。 – pmdj</p><p>    The while(0); has no effect on the program, but the compiler will issue a warning about &#34;this does nothing&#34;, which is enough to get me to go look at the offending line and then see the real reason I wanted to call attention to it.</p><p>    while（0）;对程序没有影响，但是编译器将发出有关“此操作无效”的警告，这足以使我了解有问题的行，然后查看我想引起注意的真正原因。</p><p>  Apparently, I could. It&#39;s not completely standard, but it worked in the compilers that I use. Interestingly, the embedded compiler translated a #define, while gcc did not. –  gbarry</p><p>  显然，我可以。它不是完全标准，但是可以在我使用的编译器中使用。有趣的是，嵌入式编译器翻译了#define，而gcc却没有。 – gbarry</p><p>    Each node in the linked list is the Xor of the previous node and the next node. To traverse forward, the address of the nodes are found in the following manner :</p><p>    链表中的每个节点都是上一个节点和下一个节点的Xor。为了遍历，可以通过以下方式找到节点的地址：</p><p> LLNode * first = head;LLNode * second = first.linked_nodes;LLNode * third = second.linked_nodes ^ first;LLNode * fourth = third.linked_nodes ^ second;</p><p> LLNode *第一=头; LLNode *第二= first.linked_nodes; LLNode *第三= second.linked_nodes ^第一; LLNode *第四= Third.linked_nodes ^第二;</p><p>   LLNode * last = tail;LLNode * second_to_last = last.linked_nodes;LLNode * third_to_last = second_to_last.linked_nodes ^ last;LLNode * fourth_to_last = third_to_last.linked_nodes ^ second_to_last;</p><p>   LLNode * last =尾巴; LLNode * second_to_last = last.linked_nodes; LLNode * third_to_last = second_to_last.linked_nodes ^ last; LLNode * third_to_last = third_to_last.linked_nodes ^ second_to_last;</p><p>  While not terribly useful (you can&#39;t start traversing from an arbitrary node) I find it to be very cool.</p><p>  虽然不是很有用（您不能从任意节点开始遍历），但我发现它非常酷。</p><p>    The statement will only be printed if &#39;-D RELEASE&#39; flag for compiler is not used.</p><p>仅当不使用编译器的-D RELEASE标志时，才会打印该语句。</p><p>  You might want to expand D(x) to {} when RELEASE is defined, so that it plays nice with if statements. Otherwise &#34;if (a) D(x);&#34; will expand to just &#34;if (a)&#34; when you have RELEASE defined. That will give you some nice bugs in the RELEASE verison –  MarkJ</p><p>  定义RELEASE时，您可能想将D（x）扩展为{}，以便它与if语句配合使用。否则为“如果（a）D（x）;”当您定义了RELEASE时，它将扩展为“ if（a）”。这将在RELEASE版本中给您一些不错的错误 – MarkJ</p><p>  @MarkJ: NO. The way it is, &#34;if(a) D(x);&#34; expands to &#34;if(a);&#34; which is perfectly fine. If you had D(x) expand to {}, then &#34;if(a)if(b)D(x);else foo();&#34; would INCORRECTLY expand to &#34;if(a)if(b){};else foo();&#34;, causing the &#34;else foo()&#34; to match with the second if instead of the first if. –  Adam Rosenfield</p><p>  @MarkJ：不。它的方式是“ if（a）D（x）;”扩展为“ if（a）;”很好。如果您将D（x）扩展为{}，则为“ if（a）if（b）D（x）; else foo（）;”会不正确地扩展为“ if（a）if（b）{}; else foo（）;”，从而导致“ else foo（）”与第二个if而不是第一个if匹配。 –·亚当·罗森菲尔德</p><p>  To be honest i mostly use this macro for testing print statements, or if i had a conditional statement i would enclose it all eg. D(if(a) foo();); –  Simon Walker</p><p>  老实说，我主要使用此宏来测试打印语句，或者如果我有条件语句，则将其全部括起来。 D（if（a）foo（）;）; –西蒙·沃克</p><p>  @AdamRosenfield: Using  #define D(x) do { } while(0) instead handles that case (and can be applied to the branch that inserts  x as well for consistency) –  rpetrich</p><p>  @AdamRosenfield：使用#define D（x）做{} while（0）处理这种情况（并且可以应用于插入x的分支以保持一致性） – rpetrich</p><p>    Rusty actually produced a whole set of build conditionals in  ccan, check out the build assert module:</p><p>    Rusty实际上在ccan中生成了一整套构建条件，请查看build assert模块：</p><p> #include &lt;stddef.h&gt;#include &lt;ccan/build_assert/build_assert.h&gt;struct foo { char string[5]; int x;};char *foo_string(struct foo *foo){ // This trick requires that the string be first in the structure BUILD_ASSERT(offsetof(struct foo, string) == 0); return (char *)foo;}</p><p> #include  #include  struct foo {char string [5]; int x;}; char * foo_string（struct foo * foo）{//此技巧要求字符串在结构BUILD_ASSERT（offsetof（struct foo，string）== 0）中位于第一return（char *）foo;}</p><p> There are lots of other helpful macros in the actual header, which are easy to drop into place.</p><p>实际的标头中还有许多其他有用的宏，这些宏很容易就位。</p><p> I try, with all of my might to resist the pull of the dark side (and preprocessor abuse) by sticking mostly to inline functions, but I do enjoy clever, useful macros like the ones you described.</p><p> 我尽一切努力通过主要坚持使用内联函数来抵制黑暗面（和预处理程序滥用），但是我确实喜欢像您所描述的那样聪明，有用的宏。</p><p>  Yeah, I recently came across ccan, and was considering contributing some code, but haven&#39;t yet wrapped my head around the &#34;ccan way.&#34; Thanks for the link though, more motivation to look into ccan, which I really hope gets some traction. –  smcameron</p><p>  是的，我最近遇到了ccan，并正在考虑提供一些代码，但还没有完全按照“ ccan方式”来做。不过，感谢您提供的链接，希望能有更多的动力去研究ccan，我真的希望能引起大家的注意。 – smcameron</p><p>  Well, I would not get too concerned on the &#39;ccan way&#39; until its more established ... right now ccan-lint is being proposed as a GSOC project. Its a small and rather friendly group .. and a great place to dump snippets :) –  Tim Post</p><p>  好吧，我不会太在意“ cancan方法”，直到它更加成熟为止……目前，有人提议将ccan-lint作为GSOC项目。这是一个很小而相当友好的团体..也是丢弃片段的好地方:) – Tim Post</p><p>  BTW, I noticed Rusty&#39;s BuILD_ASSERT is just like the macro from the linux kernel (unsurprising) but lacking one of the &#34;nots&#34; (or bangs, or !&#39;s) and noticing that, I think my example usage of the macro I posted is not correct. Should have been: &#34;BUILD_BUG_ON((sizeof(struct mystruct) % 8))&#34; –  smcameron</p><p>  顺便说一句，我注意到Rusty的BuILD_ASSERT就像Linux内核中的宏（毫不奇怪）一样，但是缺少“ nots”（或刘海或！）之一，并且注意到，我认为我发布的宏的示例用法是不正确。应该是：“ BUILD_BUG_ON（（（sizeof（struct mystruct）％8））” – smcameron</p><p>    Two good source books for this sort of stuff are  The Practice of Programming and  Writing Solid Code. One of them (I don&#39;t remember which) says: Prefer enum to #define where you can, because enum gets checked by the compiler.</p><p>    关于这类东西的两本很好的参考书是《编程和编写固态代码的实践》。其中一个（我不记得是哪个）说：最好在可能的地方使用#define枚举，因为枚举由编译器检查。</p><p>  AFAIK, in C89/90 there is NO typechecking for enums. enums are just somehow more convenient #defines. –  cschol</p><p>  AFAIK，在C89 / 90中没有枚举的类型检查。枚举只是某种程度上更方便#defines。 – cschol</p><p>  Bottom of page 39, 2nd ED K&amp;R. There is at least the opportunity for checking. –  Jonathan Watmough</p><p>第二版ED K＆R，第39页底部。至少有机会进行检查。 –乔纳森·沃特莫夫</p><p>    Not specific to C, but I&#39;ve always liked the XOR operator. One cool thing it can do is &#34;swap without a temp value&#34;:</p><p>    不特定于C，但我一直很喜欢XOR运算符。它可以做的一件很酷的事情是“没有临时值的交换”：</p><p> int a = 1;int b = 2;printf(&#34;a = %d, b = %d\n&#34;, a, b);a ^= b;b ^= a;a ^= b;printf(&#34;a = %d, b = %d\n&#34;, a, b);</p><p> int a = 1; int b = 2; printf（“ a =％d，b =％d \ n”，a，b）; a ^ = b; b ^ = a; a ^ = b; printf（“ a =％d，b =％d \ n“，a，b）;</p><p>  a = 1; b = 2; a = a+b; b = a-b; a = a-b; gives the same result too –  Grambot</p><p>  a = 1； b = 2； a = a + b; b = a-b； a = a-b;也给出相同的结果 – Grambot</p><p>  This will also swap a and b: a ^= b ^= a ^= b; –  vikhyat</p><p>  这也将交换a和b：a ^ = b ^ = a ^ = b; – vikhyat</p><p>        I like the concept of   container_of used for example in lists. Basically, you do not need to specify  next and  last fields for each structure which will be in the list. Instead, you append the list structure header to actual linked items.</p><p>        我喜欢在列表中使用例如container_of的概念。基本上，您不需要为将在列表中的每个结构指定下一个和最后一个字段。而是将列表结构标头附加到实际的链接项。</p><p>    I think the use of  userdata pointers is pretty neat. A fashion losing ground nowdays. It&#39;s not so much a C feature but is pretty easy to use in C.</p><p>    我认为userdata指针的使用非常简洁。如今，时尚正在逐渐失控。它不是C功能，而是在C中非常容易使用。</p><p>  I wish that I understood what you meant here. Could you explain more? What is a userdata pointer? –  Zan Lynx</p><p>我希望我能理解您的意思。您能解释更多吗？什么是userdata指针？ – Zan Lynx</p><p>    it&#39;s primarily for callbacks. It is some data you would like to be given back to you each time the callback is fired. Particularly useful for passing a C++ this pointer to a callback so you can tie an object to an event. –  Evan Teran</p><p>    它主要用于回调。您希望每次触发回调时都将这些数据还给您。对于将C指针传递给回调函数特别有用，因此您可以将对象绑定到事件。 –埃文·特兰（Evan Teran）</p><p>  Ah, yes. Thanks. I use this a lot, but I have never called it that. –  Zan Lynx</p><p>  是的。谢谢。我经常使用它，但我从未这样称呼过。 – Zan Lynx</p><p>    I use  X-Macros to to let the pre-compiler generate code. They are especially useful for defining error values and associated error strings in one place, but they can go far beyond that.</p><p>    我使用X-Macros来让预编译器生成代码。它们对于在一处定义错误值和相关的错误字符串特别有用，但是它们可以远远超出此范围。</p><p>    #ifdef DEBUG#define my_malloc(amt) my_malloc_debug(amt, __FILE__, __LINE__)void * my_malloc_debug(int amt, char* file, int line)#elsevoid * my_malloc(int amt)#endif{ //remember file and line no. for this malloc in debug mode}</p><p>    #ifdef DEBUG＃定义my_malloc（amt）my_malloc_debug（amt，__FILE__，__LINE __）void * my_malloc_debug（int amt，char *文件，int行）#elsevoid * my_malloc（int amt）#endif {//记住文件和行号。在调试模式下为此malloc}</p><p> which allows for the tracking of memory leaks in debug mode. I always thought this was cool.</p><p> 它允许在调试模式下跟踪内存泄漏。我一直认为这很酷。</p><p>    #define SOME_ENUMS(F) \ F(ZERO, zero) \ F(ONE, one) \ F(TWO, two)/* Now define the constant values. See how succinct this is. */enum Constants {#define DEFINE_ENUM(A, B) A, SOME_ENUMS(DEFINE_ENUMS)#undef DEFINE_ENUM};/* Now a function to return the name of an enum: */const char *ToString(int c) { switch (c) { default: return NULL; /* Or whatever. */#define CASE_MACRO(A, B) case A: return #b; SOME_ENUMS(CASE_MACRO)#undef CASE_MACRO }}</p><p>    ＃定义SOME_ENUMS（F）\ F（零，0）\ F（一，一）\ F（二，二）/ *现在定义常数值。看看这有多简洁。 * /枚举常量{#define DEFINE_ENUM（A，B）A，SOME_ENUMS（DEFINE_ENUMS）#undef DEFINE_ENUM}; / *现在返回一个枚举名称的函数：* / const char * ToString（int c）{switch（ c）{默认值：返回NULL; /* 管他呢。 * /＃定义CASE_MACRO（A，B）情况A：返回#b; SOME_ENUMS（CASE_MACRO）#undef CASE_MACRO}}</p><p>    Here is an example how to make C code completly unaware about what is actually used of HW for running the app. The main.c does the setup and then the free layer can be implemented on any compiler/arch. I think it is quite neat for abstracting C code a bit, so it does not get to be to spesific.</p><p>这是一个示例，该示例如何使C代码完全不了解硬件在运行该应用程序时实际使用了什么。 main.c进行设置，然后可以在任何编译器/架构上实现自由层。我认为稍微抽象一下C代码是很整洁的事情，所以不要太专一了。</p><p>  /* free.h */#ifndef _FREE_H_#define _FREE_H_#include &lt;stdio.h&gt;#include &lt;string.h&gt;typedef unsigned char ubyte;</p><p>  / * free.h * /＃ifndef _FREE_H_＃定义_FREE_H_＃include  #include  typedef unsigned char ubyte;</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://stackoverflow.com/questions/599365/what-is-your-favorite-c-programming-trick">https://stackoverflow.com/questions/599365/what-is-your-favorite-c-programming-trick</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>