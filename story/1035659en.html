<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Linux内核黑客的SQLite简介SQLite briefing for Linux kernel hackers</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">SQLite briefing for Linux kernel hackers<br/>Linux内核黑客的SQLite简介</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-21 22:53:59</div><div class="page_narrow text-break page_content"><p>This is a briefing on SQLite intended for Linux kernel hackers,and especially those working on Linux filesystems.</p><p>这是针对Linux内核黑客（尤其是那些在Linux文件系统上工作的黑客）的SQLite的简介。</p><p>   SQLite is not a separate process or thread. SQLite is a subroutine. SQLite is embedded in the application and uses the same heap and stack.</p><p>SQLite不是独立的进程或线程。 SQLite是一个子例程。 SQLite嵌入在应用程序中，并使用相同的堆和堆栈。</p><p> Because no IPC is involved, SQLite has low latency. Reading or writing many small blobs using SQLite is faster than reading/writing those blobs from separate files on disk.  [1]  [2]</p><p>由于不涉及IPC，因此SQLite具有低延迟。使用SQLite读取或写入许多小Blob比从磁盘上的单独文件读取/写入这些Blob更快。 [1] [2]</p><p> An additional transient journal file may appear from time to time to help implement transactions that are atomic across crashes and power failures.</p><p>可能会不时出现一个额外的暂态日志文件，以帮助实现在崩溃和电源故障时至关重要的事务。</p><p> Database sizes can range from 512 bytes up to 140,735,340,740,610 bytes. Most databases are a few megabytes to a few gigabytes in size, though terabyte-sized SQLite databases are known to be used in production.</p><p>数据库大小范围从512字节到140,735,340,740,610字节。大多数数据库的大小从几兆字节到几千兆字节，尽管已知在生产中使用的是TB级的SQLite数据库。</p><p> The database file format is stable, well-defined, well-documented, and cross-platform. SQLite databases are commonly used as storage containers for sending structured content across the internet.</p><p>数据库文件格式稳定，定义明确，文档齐全且跨平台。 SQLite数据库通常用作通过互联网发送结构化内容的存储容器。</p><p> Other database engines are usually found in the datacenter. SQLite is more commonly seen at the edge of the network.</p><p>通常在数据中心中可以找到其他数据库引擎。 SQLite在网络边缘更为常见。</p><p> Because the network edge is so broad, there are a vast number SQLite databases in active use - probably over one trillion (1e12).</p><p>由于网络边缘是如此广泛，因此有大量正在使用的SQLite数据库-可能超过一万亿（1e12）。</p><p> A typical Android phone has hundreds of SQLite databases and does more than 5 gigabytes of database I/O per day.</p><p>典型的Android手机具有数百个SQLite数据库，每天执行超过5 GB的数据库I / O。</p><p>  SQLite works unsupervised, in whatever environment it is handed.SQLite does not get to choose a particular filesystem type or specificmount options. There is no configuration file available to tell SQLite aboutthe capabilities of system on which it is running. SQLite needs to workwell on a USB memory stick with a DOS filesystem up toan enterprise-class SSD with battery back-up and the latest filesystem,and everything in between.</p><p>SQLite可以在任何环境下不受监督地工作。SQLite无法选择特定的文件系统类型或specificmount选项。没有可用的配置文件来告诉SQLite它正在运行的系统的功能。 SQLite需要在具有DOS文件系统的USB记忆棒上工作良好，再到具有电池备份和最新文件系统的企业级SSD，以及介于两者之间的所有内容。</p><p> To help it work most efficiently, SQLite needs to know attributes of theenvironment in which it is running. And because it lacks a configurationfile, SQLite needs to discover these attributes on its own, at run-time.Some attributes of the system that SQLite would like to know about include:</p><p>为了帮助它最有效地工作，SQLite需要知道它所运行的环境的属性。而且由于缺少配置文件，SQLite需要在运行时自行发现这些属性.SQLite想了解的系统某些属性包括：</p><p> If a power loss occurs at about the same time that a file is being extended with new data, will the file be guaranteed to contain valid data after reboot, or might the extended area of the file contain all zeros or all ones or arbitrary content? In other words, is the file data always committed to disk ahead of the file size?</p><p>如果在用新数据扩展文件的同时发生断电，重新启动后是否可以保证文件包含有效数据，或者文件的扩展区可能包含全零或全1或任意内容？换句话说，文件数据是否总是在文件大小之前提交到磁盘？</p><p> If a power loss occurs at about the same time as a file truncation, is it possible that the truncated area of the file will contain arbitrary data after reboot? In other words, is the file size guaranteed to be committed to disk before the data sections are released?</p><p>如果在文件截断的大约同一时间发生断电，重新启动后文件的截断区域是否可能包含任意数据？换句话说，在释放数据段之前，是否保证文件大小已提交到磁盘？</p><p>  Can a mmap() of the file be used for shared memory by all processes that have access to the file. (This is false for network filesystems. So the question is approximately the same as &#34;is the file on a network filesystem?&#34;)</p><p>可以访问该文件的所有进程是否可以将文件的mmap（）用于共享内存。 （对于网络文件系统这是错误的。因此，问题与“网络文件系统上的文件是否存在？”大致相同）</p><p> If a write occurs on one or two bytes of a file at about the same time as a power loss, are other bytes of the file guaranteed to be unchanged after reboot? Or might some other bytes within the same sector have been modified as well?</p><p>如果在断电的同时在文件的一个或两个字节上进行写操作，重新启动后是否保证文件的其他字节不变？还是同一扇区内的其他一些字节也可能被修改？</p><p> When you create a new file, write to it, and fdatasync() successfully, is it also necessary to open and fsync() the containing directory in or to ensure that the file will still be there following reboot from a power loss?</p><p>创建新文件时，成功写入文件，并成功执行fdatasync（），是否还需要在包含电源的目录中打开并对其进行fsync（）或确保断电重启后该文件仍然存在？</p><p> Has a file been unlinked or renamed since it was opened? (SQLite accomplishes this now by remembering the device and inode numbers obtained from fstat() and comparing them against the results of subsequent stat() calls against the original filename. Is there a more efficient way to do this?)</p><p>自打开文件以来，文件是否已取消链接或重命名？ （SQLite现在通过记住从fstat（）获得的设备和inode编号，并将它们与后续stat（）调用的结果与原始文件名进行比较，来完成此操作。是否有更有效的方法？</p><p>  Is it possible (or helpful) to tell the filesystem that the content of a particular file does not need to survive reboot?</p><p>是否有可能（或有帮助）告诉文件系统特定文件的内容不需要重新启动就可以生存？</p><p> Is it possible (or helpful) to tell the filesystem that a particular file can be unlinked upon reboot?</p><p>是否有可能（或有帮助）告诉文件系统特定文件可以在重新启动后取消链接？</p><p> Is it possible (or helpful) to tell the filesystem about parts of the database file that are currently unused and that the filesystem can zero-out without harming the database?</p><p>是否有可能（或有帮助）告知文件系统有关当前未使用的数据库文件部分，并且文件系统可以归零而不损害数据库？</p><p>  Like all relational databases, SQLite needs to implement transactionsthat are ACID (Atomic, Consistent, Isolated, and Durable) even if theapplication crashes (for example by SIGKILL) or if thereis an unexpected power loss. This is achieved in one of three ways:</p><p>与所有关系数据库一样，即使应用程序崩溃（例如SIGKILL）或发生意外断电，SQLite也需要实现ACID（原子，一致性，隔离和持久）的事务。这可以通过以下三种方式之一来实现：</p><p>  The rollback journal approach is the slowest, but also the mostlikely to work on any filesystem. Rollback is therefore the default.The write-ahead log (WAL mode) is faster, but only works on systems forwhich either (1) only a single process accesses the database at a time or(2) a mmap()-ed file can be used as shared memory.</p><p>回滚日志方法是最慢的方法，但也最适用于任何文件系统。因此，默认设置为“回滚”。“预写日志”（WAL模式）更快，但仅适用于以下系统：（1）一次只有单个进程访问数据库，或者（2）可以通过mmap（）编辑文件用作共享内存。</p><p> The third option is the fastest but is currently only supportedfor the F2FS filesystem on Linux.</p><p>第三个选项是最快的，但目前仅Linux上的F2FS文件系统支持。</p><p> Each database file is either in rollback-mode or in WAL-mode.All processes access the database file according to its defined mode.Changing the mode of a database requires exclusive access to the database.The F2FS atomic write capability (option 3) is an extension of rollback mode (option 1).</p><p>每个数据库文件都处于回滚模式或WAL模式，所有进程均按其定义的模式访问数据库文件。更改数据库的模式需要对数据库的独占访问权限.F2FS原子写入功能（选项3）为回滚模式的扩展（选项1）。</p><p>  An SQLite database is a sequence of one or more &#34;pages&#34;.All pages in the same database file are the same size.But for different databases, the page size can be anypower of two between 512 and 65536. A single change to the databasetypically involves modifications to multiple pages. This is doneatomically as follows:</p><p>一个SQLite数据库是一个或多个“页面”的序列。同一数据库文件中的所有页面都具有相同的大小。但是对于不同的数据库，页面大小可以是512到65536之间的任何2的幂。通常，对数据库的单个更改涉及对多个页面的修改。从根本上讲，这是如下所示：</p><p> Creating a rollback journal file in the same directory as the database and having the same name except with the &#34; -journal&#34; extension added.</p><p>在与数据库相同的目录中创建回滚日志文件，并具有相同的名称，只是添加了“ -journal”扩展名。</p><p> The original content of any database page that is to be modified is written into the rollback journal.</p><p>任何要修改的数据库页面的原始内容都会写入回滚日志中。</p><p>  Open the directory that contains the rollback journal and fdatasync() that directory, to ensure that the filename will exist following a power loss</p><p>打开包含回滚日志的目录和该目录的fdatasync（），以确保断电后文件名仍然存在</p><p>    Call fdatasync() on the database file. If the database file decreases in size, also call ftruncate().</p><p>在数据库文件上调用fdatasync（）。如果数据库文件的大小减小，则也调用ftruncate（）。</p><p>  On step (1), the rollback journal and the database file are kept in the same directory in order to ensure that they are on the same volume, and thus do not become separated from one another following a reboot.</p><p>在步骤（1）中，回滚日志和数据库文件保留在同一目录中，以确保它们位于同一卷上，因此在重新引导后不会彼此分离。</p><p> At step (10), SQLite implicitly assumes that each of the three commit operations (unlink, truncate, or header-overwrite) are atomic.</p><p>在步骤（10），SQLite隐式假定三个提交操作（取消链接，截断或标头覆盖）中的每一个都是原子的。</p><p> All writes to the database file are an integer number of pages and are page-aligned.</p><p>对数据库文件的所有写操作都是整数页，并且页对齐。</p><p> Writes to the rollback journal are appends or linear overwrites, except for overwriting the header at step 10c.</p><p>对回滚日志的写入是追加或线性覆盖，除了在步骤10c覆盖标头。</p><p>  When initially opening the database file, check for the presence of a well-formed rollback journal. If not found → Done.</p><p>最初打开数据库文件时，请检查是否存在格式正确的回退日志。如果未找到→完成。</p><p>  Append modified pages to the write-ahead log file (the &#34;WAL file&#34;). The WAL file is a file in the same directory as the database and with the same name as the database but with &#34;-wal&#34; appended.</p><p>将修改后的页面追加到预写日志文件（“ WAL文件”）中。 WAL文件是与数据库位于同一目录中的文件，名称与数据库相同，但附加了“ -wal”。</p><p>  Step 3 can be omitted with the consequence that transactions are no longer durable. In other words, a transaction that was reported as having committed might rollback following a power failure. Most applications are cool with losing the last few transactions on a power loss as long as the database is still well-formed and consistent following reboot.</p><p>可以省略步骤3，结果是事务不再持久。换句话说，据报告已提交的事务可能会在电源故障后回滚。只要数据库在重新启动后仍保持格式良好且一致，大多数应用程序都会掉电而丢失最后几笔事务，这很酷。</p><p>  A separate &#34;-shm&#34; file is mmap()-ed by all processes that want to access the database. The &#34;-shm&#34; file contains a hash table used to quickly locate pages previously written into the &#34;-wal&#34; file.</p><p>想要访问数据库的所有进程都将mmap（）-ed为单独的“ -shm”文件。 “ -shm”文件包含一个哈希表，用于快速查找先前写入“ -wal”文件中的页面。</p><p> The last process to close its connection to the database will automatically run a checkpoint, then unlink the WAL file and the &#34;-shm&#34; file, assuming the last process shuts down cleanly. If the last process accessing the database simply exit()s without invoking sqlite3_close() or if the process crashes or if there is a power loss, the &#34;-wal&#34; and &#34;-shm&#34; files are left lingering on disk. The left-over &#34;-wal&#34; and &#34;-shm&#34; files will be cleaned up by the next process to open the database.</p><p>假设最后一个进程完全关闭，则最后一个关闭其与数据库的连接的进程将自动运行检查点，然后取消链接WAL文件和“ -shm”文件。如果最后一个访问数据库的进程只是退出（）而没有调用sqlite3_close（），或者该进程崩溃或断电，则“ -wal”和“ -shm”文件会留在磁盘上。剩下的“ -wal”和“ -shm”文件将在下一步打开数据库的过程中清除。</p><p>  Wait for all concurrent readers to stop using pages in the main database that have changes in the WAL file.</p><p>等待所有并发阅读器停止使用主数据库中WAL文件中已更改的页面。</p><p> Barrier - All of the writes to the WAL file must complete before any subsequent writes to the database file.</p><p>屏障-必须先完成对WAL文件的所有写入，然后再进行对数据库文件的任何写入。</p><p> Write the most recent change for every page in the WAL file back into the database file.</p><p>将WAL文件中每个页面的最新更改写回到数据库文件中。</p><p> Pages are sorted so that they are written in increasing order. → Is this helpful on Linux? Or can we just as well skip the sort and write the pages in any arbitrary order?</p><p>页面被排序，以便它们以递增顺序写入。 →这在Linux上有帮助吗？还是我们可以跳过排序并以任意顺序编写页面？</p><p>   Truncate the WAL file, or otherwise cause the WAL file to start over again at the beginning.</p><p>截断WAL文件，否则以其他方式使WAL文件从头开始。</p><p> We have seen that overwriting an existing file is faster than truncating and appending. Is that always the case?</p><p>我们已经看到，覆盖现有文件比截断和追加速度更快。总是这样吗？</p><p>  The default action is that the first process that runs a commit that causes the WAL file to grow beyond 1000 pages runs a checkpoint. However, this behavior can be changed by the application. The &#34;auto-checkpoint&#34; threshold can be raised or lowered. Or a system can dedicate a separate thread or process to run periodic checkpoints.</p><p>默认操作是运行导致WAL文件超过1000页的提交的第一个进程运行一个检查点。但是，此行为可以由应用程序更改。可以提高或降低“自动检查点”阈值。或者，系统可以指定一个单独的线程或进程来运行定期检查点。</p><p> Checkpoints can block on step 2. Or, then can return early, having only done a subset of their work. Non-blocking is the default.</p><p>检查点可能会阻塞到步骤2。或者，如果只完成了一部分工作，然后可以提早返回。非阻塞是默认设置。</p><p>    F2FS is a log-structured filesystem for Linux that has (limited) atomicwrite capabilities. SQLite is able to use the atomic write capabilitiesof F2FS to bypass the rollback journal. Anecdotal reports are that anAndroid phone that is reformatted to use F2FS is noticeably faster. F2FSmake an old tired phone feel like a perky new phone.</p><p>F2FS是Linux的日志结构文件系统，具有（有限的）atomicwrite功能。 SQLite能够使用F2FS的原子写入功能来绕过回滚日志。有传闻称，重新格式化为使用F2FS的Android手机的速度明显更快。 F2FS使旧的旧电话感觉像新电话一样。</p><p>  F2FS_IOC_ABORT_VOLATILE_WRITE (hereafter &#34;F2FS-ROLLBACK&#34;) - rollback all changes for the transaction and restore the file descriptor to the state it was in prior to F2FS-BEGIN.</p><p>F2FS_IOC_ABORT_VOLATILE_WRITE（以下称“ F2FS-ROLLBACK”）-回滚事务的所有更改，并将文件描述符恢复到F2FS-BEGIN之前的状态。</p><p> The F2FS atomic write capability is only useful for databases that wouldotherwise be in rollback mode. The atomic write capability is not helpfulfor WAL-mode databases.</p><p>F2FS原子写入功能仅对否则将处于回滚模式的数据库有用。原子写入功能对WAL模式数据库没有帮助。</p><p>  Start a new transaction by invoking F2FS-BEGIN. If that ioctl() fails, fallback to using a rollback journal.</p><p>通过调用F2FS-BEGIN开始新事务。如果该ioctl（）失败，则回退到使用回滚日志。</p><p> Write changes directly into the database file. If any write fails, SQLite will abort the transaction by invoking F2FS-ROLLBACK and restart the transaction using a rollback journal.</p><p>将更改直接写入数据库文件。如果任何写入失败，SQLite将通过调用F2FS-ROLLBACK终止事务，并使用回滚日志重新启动事务。</p><p> If the application requests a transaction abort by issuing an SQL &#34;ROLLBACK&#34; statement, then SQLite aborts the atomic write by invoking the F2FS-ROLLBACK ioctl().</p><p>如果应用程序通过发出SQL“ ROLLBACK”语句来请求事务中止，则SQLite通过调用F2FS-ROLLBACK ioctl（）来中止原子写入。</p><p> Commit the transaction by invoking the F2FS-COMMIT ioctl(). If that ioctl() fails, SQLite will retry the transaction using a traditional rollback journal.</p><p>通过调用F2FS-COMMIT ioctl（）提交事务。如果该ioctl（）失败，SQLite将使用传统的回滚日志重试该事务。</p><p>  Writes issued on a file descriptor for which a transaction has been started using F2FS-BEGIN must never be visible on any other file descriptor prior to F2FS-COMMIT.</p><p>在使用F2FS-BEGIN启动了事务的文件描述符上发出的写入，在F2FS-COMMIT之前的任何其他文件描述符上都不得可见。</p><p> If there is a power loss or other system crash prior to F2FS-COMMIT, then none of the uncommitted changes should appear in the file after reboot.</p><p>如果在F2FS-COMMIT之前断电或其他系统崩溃，那么重新启动后文件中所有未提交的更改都不会出现。</p><p> If the file descriptor on which the F2FS-BEGIN was issued closes before F2FS-COMMIT, then all changes on that file descriptor since the last F2FS-BEGIN are discarded.</p><p>如果发出F2FS-BEGIN的文件描述符在F2FS-COMMIT之前关闭，则自上一个F2FS-BEGIN以来，该文件描述符上的所有更改都将被丢弃。</p><p> The kernel can fail any operation after an F2F2-BEGIN and SQLite will recover gracefully by cancelling the transaction (using F2FS-ROLLBACK) and restarting the transaction using a traditional rollback journal.</p><p>F2F2-BEGIN和SQLite通过取消事务（使用F2FS-ROLLBACK）并使用传统的回滚日志重新启动事务后，内核可以使所有操作失败。</p><p> The application can abort a transaction at any time. SQLite will invoke F2FS-ROLLBACK and expect the system to forget any changes from writes to that file descriptor back through the most recent F2FS-BEGIN.</p><p>应用程序可以随时中止事务。 SQLite将调用F2FS-ROLLBACK，并期望系统忘记通过最新的F2FS-BEGIN对该文件描述符的写操作所做的任何更改。</p><p> The result of write() calls must be visible to subsequent read() calls on the same file descriptor that issued F2FS-BEGIN. But those writes must be invisible to read()s from separate file descriptors until after F2FS-COMMIT.</p><p>发出F2FS-BEGIN的同一文件描述符上的write（）调用结果必须对随后的read（）调用可见。但是，直到从F2FS-COMMIT之后，这些写入对于从单独的文件描述符进行的read（）都必须不可见。</p><p> Following F2FS-ROLLBACK, all read() calls must return the same data that they would have returned if none of the write() calls back to the most recent F2FS-BEGIN had never occurred.</p><p>在F2FS-ROLLBACK之后，如果从未发生对最近F2FS-BEGIN的write（）调用，则所有read（）调用都必须返回与返回的数据相同的数据。</p><p>  Performance of SQLite on Linux is already very fast. However, it mightbe improved further with new Kernel interfaces.</p><p>Linux上SQLite的性能已经非常快。但是，可能会通过新的内核接口进一步加以改进。</p><p>  SQLite uses fsync() or fdatasync() to ensure I/O operations are complete.However, if an application is willing to forego Durability (The &#34;D&#34; in&#34;ACID&#34;) following a power loss then many of these fdatasync() calls couldbe replaced by a hypothetical fbarrier(). This would be useful in eachspot marked above by &#34; Barrier&#34;.</p><p>SQLite使用fsync（）或fdatasync（）来确保I / O操作完成。但是，如果应用程序在断电后愿意放弃耐久性（“ ACID”中的“ D”），则许多fdatasync（）调用可以由假设的fbarrier（）代替。这在上面用“障碍”标记的每个位置中将很有用。</p><p>  Sequence operations on at least two file descriptors. For example, writes to the rollback journal must be complete before any writes to the database begin.</p><p>对至少两个文件描述符进行序列操作。例如，对回滚日志的写操作必须在对数据库的任何写操作开始之前完成。</p><p>  When an application deletes content from an SQLite database, SQLite doesnot normally overwrite the deleted content, but merely remembers that thespace is available for reuse. This avoids unnecessary writes. (Exception: Sometimes an application actually wantscontent to be overwritten to avoid forensic traces, and SQLite supportsthis upon request. For example, Firefox puts SQLite into the mode whereit overwrites deleted content with zeros when you clear your search history.)</p><p>当应用程序从SQLite数据库删除内容时，SQLite通常不会覆盖已删除的内容，而只是记住该空间可供重用。这样可以避免不必要的写入。 （例外：有时，应用程序实际上实际上希望覆盖内容以避免法医跟踪，而SQLite可以根据要求支持此内容。例如，Firefox将SQLite置于一种模式，当您清除搜索历史记录时，它将用零覆盖已删除的内容。</p><p> SQLite could tell the filesystem about regions of the file that are unusedand do not need to be preserved.</p><p>SQLite可以告知文件系统有关文件中未使用且不需要保留的区域。</p><p> Read()s from regions designated as unused may return all-zeros, or all-ones, or arbitrary bits, and SQLite will not care.</p><p>来自指定为未使用区域的read（）可能返回全零，全1或任意位，而SQLite不会在意。</p><p> The first write() to an unused region will repeal the &#34;unused&#34; status of that region.</p><p>对未使用区域的第一个write（）将废除该区域的“未使用”状态。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://sqlite.org/lpc2019/doc/trunk/briefing.md">https://sqlite.org/lpc2019/doc/trunk/briefing.md</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/黑客/">#黑客</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sqlite/">#sqlite</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内核/">#内核</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/briefing/">#briefing</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>