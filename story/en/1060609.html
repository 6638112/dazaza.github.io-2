<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用qemu-user仿真到反向工程二进制文件 Using QEMU-user emulation to reverse engineer binaries</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Using QEMU-user emulation to reverse engineer binaries<br/>使用qemu-user仿真到反向工程二进制文件 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-05 20:59:21</div><div class="page_narrow text-break page_content"><p>QEMU is primarily known as the software which provides full system emulation under Linux’s KVM.  Also, it can be used without KVM to do full emulation of machines from the hardware level up.  Finally, there is  qemu-user, which allows for emulation of individual programs.  That’s what this blog post is about.</p><p>QEMU主要被称为在Linux的KVM下提供完整的系统仿真的软件。此外，它可以在没有KVM的情况下使用，可以从硬件级别完全仿真机器。最后，有qemu-user，它允许仿真各个程序。这就是这个博客的帖子。</p><p> The main use case for  qemu-user is actually  not reverse-engineering, but simply running programs for one CPU architecture on another.  For example, Alpine developers leverage  qemu-user when they use  dabuild(1) to cross-compile Alpine packages for other architectures:  qemu-user is used to run the configure scripts, test suites and so on.  For those purposes,  qemu-user works quite well: we are even considering using it to build the entire  riscv64 architecture in the 3.15 release.</p><p> Qemu-user的主要用例实际上不是逆向工程，而是仅在另一个CPU架构上运行程序。例如，Alpine开发人员利用QEMu-user，当他们使用dabuild（1）来交叉编译其他架构的Alpine软件包：qemu-user用于运行配置脚本，测试套件等。对于那些目的而言，QEMU-User非常好：我们甚至考虑使用它来建立3.15发布中的整个RISCV64架构。</p><p> However, most people don’t realize that you can run a  qemu-user emulator which targets the same architecture as the host.  After all, that would be a little weird, right?  Most also don’t know that you can control the emulator using  gdb, which is possible and allows you to debug binaries which detect if they are being debugged.</p><p> 但是，大多数人都没有意识到您可以运行一个qemu-user仿真器，该模拟器将与主机相同的架构。毕竟，这将是一个有点奇怪的，对吗？最多也不知道您可以使用GDB控制模拟器，这是可能的，并且允许您调试检测的二进制文件，如果正在调试。</p><p> You don’t need  gdb for this to be a powerful reverse engineering tool, however.  The emulator itself includes many powerful tracing features.  Lets look into them by writing and compiling a sample program, that does some recursion by  calculating whether a number is even or odd inefficiently:</p><p> 但是，您不需要GDB，这是一个强大的逆向工程工具。仿真器本身包括许多强大的跟踪功能。让我们通过写作和编译示例程序来查看它们，通过计算数字是偶数还是奇数的方法来进行一些递归：</p><p> #include &lt;stdbool.h&gt; #include &lt;stdio.h&gt; bool isOdd(int x); bool isEven(int x); bool isOdd(int x) {    return x != 0 &amp;&amp; isEven(x - 1); } bool isEven(int x) {    return x == 0 || isOdd(x - 1); } int main(void) {    printf(&#34;isEven(%d): %d\n&#34;, 1025, isEven(1025));    return 0; }</p><p> #include＆lt; stdbool.h＆gt;#include＆lt; stdio.h＆gt;BOOL ISODD（int x）;BOOL ISEVEN（int x）;BOOL ISODD（int x）{返回x！= 0＆amp;＆amp; Iseven（x  -  1）;}BOOL ISEVEN（int x）{返回x == 0 || ISODD（X  -  1）;}int main（void）{printf（＆＃34; iseven（％d）：％d \ n＆＃34;，1025，Iseven（1025））;返回0;}</p><p>  The next step is to install the  qemu-user emulator for your architecture, in this case we want the  qemu-x86_64 package:</p><p>  下一步是为您的体系结构安装QEMU用户仿真器，在这种情况下我们想要Qemu-x86_64包：</p><p>  Normally, you would also want to install the  qemu-openrc package and start the  qemu-binfmt service to allow for the emulator to handle any program that couldn’t be run natively, but that doesn’t matter here as we will be running the emulator directly.</p><p>  通常，您还需要安装QEMU-OPENRC包并启动QEMU-BINFMT服务，以允许模拟器处理任何无法自然运行的程序，但这在这里无关紧要直接仿真器。 </p><p> The first thing we will do is check to make sure the emulator can run our sample program at all:</p><p>我们将要做的第一件事是检查以确保仿真器可以运行我们的示例程序：</p><p>  Alright, all seems to be well.  Before we jump into using  gdb with the emulator, lets play around a bit with the tracing features.  Normally when reverse engineering a program, it is common to use tracing programs like  strace.  These tracing programs are quite useful, but they suffer from a design flaw: they use  ptrace(2) to accomplish the tracing, which can be detected by the program being traced.  However, we can use qemu-user to do the tracing in a way that is transparent to the program being analyzed:</p><p>  好吧，一切似乎都很好。在我们使用模拟器使用GDB之前，请通过跟踪功能播放稍微播放。通常在逆向工程一个程序时，通常使用像符号这样的跟踪程序。这些追踪程序非常有用，但它们遭受了设计漏洞：他们使用Ptrace（2）来完成跟踪，可以通过追踪的程序来检测。但是，我们可以使用qemu-user以对正在分析的程序透明的方式进行跟踪：</p><p> $ qemu-x86_64 -d strace ./example 22525 arch_prctl(4098,274903714632,136818691500777464,274903714112,274903132960,465) = 0 22525 set_tid_address(274903715728,274903714632,136818691500777464,274903714112,0,465) = 22525 22525 brk(NULL) = 0x0000004000005000 22525 brk(0x0000004000007000) = 0x0000004000007000 22525 mmap(0x0000004000005000,4096,PROT_NONE,MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,-1,0) = 0x0000004000005000 22525 mprotect(0x0000004001899000,4096,PROT_READ) = 0 22525 mprotect(0x0000004000003000,4096,PROT_READ) = 0 22525 ioctl(1,TIOCGWINSZ,0x00000040018052b8) = 0 ({55,236,0,0}) isEven(1025): 0 22525 writev(1,0x4001805250,0x2) = 16 22525 exit_group(0)</p><p> $ qemu-x86_64 -d strace ./表达22525 arch_prctl（4098,274903714632,136818691500777464,274903714112,274903132960,465）= 022525 SET_TID_ADDRESS（274903715728,274903714632,136818691500777490314632,1368186915007774464,4632,1368186903777490314632,1368186915007774464,4632,136818691500777414,274903774112,0,4632,1112,0,465）= 2252522525 BRK（NULL）= 0x000000400000500022525 BRK（0x0000004000007000）= 0x000000400000700022525 MMAP（0x0000004000005000,4096，PROT_NONE，MAP_PRIVATE | MAP_ANONOMOUSS | MAP_FIXED，-1,0）= 0x000000400000500022525 MPROTECT（0x0000004001899000,4096，prot_read）= 022525 MPROTECT（0x0000004000003000,4096，prot_read）= 022525 IOCTL（1，Tiocgwinsz，0x00000040018052B8）= 0（{55,236,0,0}）ISEVEN（1025）：022525 WRITEV（1,0x4001805250,0x2）= 1622525 Exit_Group（0）</p><p> But we can do even more.  For example, we can learn how a CPU would break a program down into translation buffers full of micro-ops:</p><p> 但我们可以做更多。例如，我们可以了解CPU如何将程序破坏到完整的Micro-Ops的翻译缓冲区：</p><p> $ qemu-x86_64 -d op ./exampleOP: ld_i32 tmp11,env,$0xfffffffffffffff0 brcond_i32 tmp11,$0x0,lt,$L0 ---- 000000400185eafb 0000000000000000 discard cc_dst discard cc_src discard cc_src2 discard cc_op mov_i64 tmp0,$0x0 mov_i64 rbp,tmp0 ---- 000000400185eafe 0000000000000031 mov_i64 tmp0,rsp mov_i64 rdi,tmp0 ---- 000000400185eb01 0000000000000031 mov_i64 tmp2,$0x4001899dc0 mov_i64 rsi,tmp2 ---- 000000400185eb08 0000000000000031 mov_i64 tmp1,$0xfffffffffffffff0 mov_i64 tmp0,rsp and_i64 tmp0,tmp0,tmp1 mov_i64 rsp,tmp0 mov_i64 cc_dst,tmp0 ---- 000000400185eb0c 0000000000000019 mov_i64 tmp0,$0x400185eb11 sub_i64 tmp2,rsp,$0x8 qemu_st_i64 tmp0,tmp2,leq,0 mov_i64 rsp,tmp2 mov_i32 cc_op,$0x19 goto_tb $0x0 mov_i64 tmp3,$0x400185eb11 st_i64 tmp3,env,$0x80 exit_tb $0x7f72ebafc040 set_label $L0 exit_tb $0x7f72ebafc043[...]</p><p> $ qemu-x86_64 -d op ./表达op：ld_i32 tmp11，env，$ 0xfffffffffffffffff0brcond_i32 tmp11，$ 0x0，lt，$ l0---- 000000400185AFB 000000000000000000丢弃CC_DST.丢弃CC_SRC.丢弃CC_SRC2.丢弃CC_OP.mov_i64 tmp0，$ 0x0MOV_I64 RBP，TMP0---- 000000400185叶0000000000000031.mov_i64 tmp0，rspMOV_I64 RDI，TMP0 -  000000400185CYB01 0000000000000031.mov_i64 tmp2，$ 0x4001899dc0MOV_I64 RSI，TMP2 -  000000400185CYB08 000000000000000031.mov_i64 tmp1，$ 0xfffffffffffffffff0mov_i64 tmp0，rspAND_I64 TMP0，TMP0，TMP1mov_i64 rsp，tmp0mov_i64 cc_dst，tmp0---- 000000400185EB0C 0000000000000019.MOV_I64 TMP0，$ 0x400185EB11Sub_i64 TMP2，RSP，$ 0x8qemu_st_i64 tmp0，tmp2，leq，0MOV_I64 RSP，TMP2mov_i32 cc_op，$ 0x19goto_tb $ 0x0.MOV_I64 TMP3，$ 0x400185EB11ST_I64 TMP3，ENV，$ 0x80EXIT_TB $ 0x7F72EBAFC040set_label $ l0.EXIT_TB $ 0x7f72ebafc043[...]</p><p> If you want to trace the actual CPU registers for every instruction executed, that’s possible too:</p><p> 如果要对每个执行的指令追踪实际的CPU寄存器，也是可能的：</p><p> $ qemu-x86_64 -d cpu ./exampleRAX=0000000000000000 RBX=0000000000000000 RCX=0000000000000000 RDX=0000000000000000 RSI=0000000000000000 RDI=0000000000000000 RBP=0000000000000000 RSP=0000004001805690 R8 =0000000000000000 R9 =0000000000000000 R10=0000000000000000 R11=0000000000000000 R12=0000000000000000 R13=0000000000000000 R14=0000000000000000 R15=0000000000000000 RIP=000000400185eafb RFL=00000202 [-------] CPL=3 II=0 A20=1 SMM=0 HLT=0 ES =0000 0000000000000000 00000000 00000000 CS =0033 0000000000000000 ffffffff 00effb00 DPL=3 CS64 [-RA] SS =002b 0000000000000000 ffffffff 00cff300 DPL=3 DS   [-WA] DS =0000 0000000000000000 00000000 00000000 FS =0000 0000000000000000 00000000 00000000 GS =0000 0000000000000000 00000000 00000000 LDT=0000 0000000000000000 0000ffff 00008200 DPL=0 LDT TR =0000 0000000000000000 0000ffff 00008b00 DPL=0 TSS64-busy GDT=     000000400189f000 0000007f IDT=     000000400189e000 000001ff CR0=80010001 CR2=0000000000000000 CR3=0000000000000000 CR4=00000220 DR0=0000000000000000 DR1=0000000000000000 DR2=0000000000000000 DR3=0000000000000000 DR6=00000000ffff0ff0 DR7=0000000000000400 CCS=0000000000000000 CCD=0000000000000000 CCO=EFLAGS EFER=0000000000000500[...]</p><p> $ qemu-x86_64 -d cpu ./表达RAX = 000000000000000000 RBX = 000000000000000000 RBX = 000000000000000000RSI = 000000000000000000 rbp = 0000000000000000000000000000000000000000000000000000000000 rsp = 0000004001805690R8 = 000000000000000000 R11 = 000000000000000000 r11 = 000000000000000000R12 = 000000000000000000 R14 = 000000000000000000 R14 = 000000000000000000RIP = 000000400185AFB RFL = 00000202 [-------] CPL = 3 II = 0 A20 = 1 SMM = 0 HLT = 0ES = 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CS = 0033 000000000000000000 FFFFFFFF 00EFFB00 DPL = 3 CS64 [-RA]SS = 002B 000000000000000000000000000000000000000000000000000000000000 DPL = 3 DS [-wa]DS = 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FS = 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000GS = 000000000000000000000000000000000000LDT = 00000000000000000000000000000000000000000000000000000000 0000000000000000 00008200 DPL = 0 LDTTR = 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 00008B00 DPL = 0 TSS64忙GDT = 000000400189F000 0000007FIDT = 000000400189E000 000001FFCR0 = 80010001 CR2 = 000000000000000000CR3 = 000000000000000000 CR4 = 00000220DR0 = 0000000000000000 DR1 = 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 DR3 = 000000000000000000DR6 = 00000000FFFF0FF0 DR7 = 0000000000000400CCS = 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 CCO = EFLAGSEFER = 0000000000000500.[...] </p><p>  $ qemu-x86_64 -d in_asm ./example---------------- IN:  0x000000400185eafb:  xor    %rbp,%rbp 0x000000400185eafe:  mov    %rsp,%rdi 0x000000400185eb01:  lea    0x3b2b8(%rip),%rsi        # 0x4001899dc0 0x000000400185eb08:  and    $0xfffffffffffffff0,%rsp 0x000000400185eb0c:  callq  0x400185eb11 ---------------- IN:  0x000000400185eb11:  sub    $0x190,%rsp 0x000000400185eb18:  mov    (%rdi),%eax 0x000000400185eb1a:  mov    %rdi,%r8 0x000000400185eb1d:  inc    %eax 0x000000400185eb1f:  cltq    0x000000400185eb21:  mov    0x8(%r8,%rax,8),%rcx 0x000000400185eb26:  mov    %rax,%rdx 0x000000400185eb29:  inc    %rax 0x000000400185eb2c:  test   %rcx,%rcx 0x000000400185eb2f:  jne    0x400185eb21[...]</p><p>$ qemu-x86_64 -d in_asm ./表达-----------------在：0x000000400185AFB：XOR％RBP，％RBP0x000000400185 efe：mov％rsp，％rdi0x000000400185EB01：LEA 0x3B2B8（％RIP），％RSI＃0x4001899DC00x000000400185eb08：$ 0xfffffffffffffff0，％rsp0x000000400185EB0C：CallQ 0x400185EB11-----------------在：0x000000400185EB11：Sub $ 0x190，％RSP0x000000400185EB18：MOV（％RDI），％EAX0x000000400185EB1A：MOV％RDI，％R80x000000400185EB1D：INC％EAX0x000000400185EB1F：CLTQ.0x000000400185EB21：MOV 0x8（％r8，％rax，8），％rcx0x000000400185EB26：MOV％rax，％rdx0x000000400185EB29：Inc％Rax0x000000400185EB2C：TEST％RCX，％RCX0x000000400185EB2F：JNE 0x400185EB21[...]</p><p> All of these options, and more, can also be stacked.  For more ideas, look at  qemu-x86_64 -d help.  Now, lets talk about using this with  gdb using qemu-user’s gdbserver functionality, which allows for  gdb to control a remote machine.</p><p> 所有这些选项以及更多，也可以堆叠。有关更多想法，请查看qemu-x86_64 -d帮助。现在，允许使用GDB使用QEMU-User的GDBServer功能讨论此，它允许GDB控制远程计算机。</p><p> To start a program under gdbserver mode, we use the  -g argument with a port number.  For example,  qemu-x86_64 -g 1234 ./example will start our example program with a gdbserver listening on port 1234.  We can then connect to that gdbserver with  gdb:</p><p> 要在GDBSERVER模式下启动程序，我们将使用端口号的-g参数使用。例如，qemu-x86_64-g 1234 ./表达将使用端口1234上的gdbserver启动我们的示例程序。然后，我们可以将该GDBerver连接到GDB：</p><p> $ gdb ./example[...]Reading symbols from ./example... (gdb) target remote localhost:1234 Remote debugging using localhost:1234 0x000000400185eafb in ?? ()(gdb) br isEven Breakpoint 1 at 0x4000001233: file example.c, line 12.(gdb) c Continuing. Breakpoint 1, isEven (x=1025) at example.c:12 12          return x == 0 || isOdd(x - 1);(gdb) bt full #0  isEven (x=1025) at example.c:12 No locals. #1  0x0000004000001269 in main () at example.c:16 No locals.</p><p> $ gdb ./表达[...]阅读符号./表达......（GDB）目标远程localhost：1234使用localhost远程调试：12340x000000400185处理？ （）（GDB）BR ISEVEN断点1在0x4000001233：文件example.c，第12行。（GDB）C继续。断点1，ISEVEN（x = 1025）在example.c：1212返回x == 0 || ISODD（X  -  1）;（gdb）bt full＃0 ISeven（x = 1025）在example.c：12没有当地人。＃1 0x0000004000001269在main（）在example.c：16没有当地人。</p><p> All of this is happening without any knowledge or cooperation of the program.  As far as its concerned, its running as normal, there is no ptrace or any other weirdness.</p><p> 所有这些都在没有任何知识或合作的情况下发生。至于其关注，它作为正常运行，没有Ptrace或任何其他怪异。</p><p> However, this is not 100% perfect: a program could be clever and run the  cpuid instruction and check for  GenuineIntel or  AuthenticAMD and crash out if it doesn’t see that it is running on a legitimate CPU.  Thankfully, qemu-user has the ability to spoof CPUs with the  -cpu option.</p><p> 但是，这不是100％完美：一个程序可能是聪明的，运行CPUID指令并检查正版或验证，如果它没有看到它在合法的CPU上运行，则崩溃。值得庆幸的是，Qemu-user有能力使用-cpu选项来欺骗CPU。</p><p> If you find yourself needing to spoof the CPU, you’ll probably have the best results with a simple CPU type like  -cpu Opteron_G1-v1 or similar.  That CPU type spoofs an Opteron 240 processor, which was one of the first x86_64 CPUs on the market.  You can get a full list of CPUs supported by your copy of the qemu-user emulator by doing  qemu-x86_64 -cpu help.</p><p> 如果您发现自己需要欺骗CPU，那么您可能会使用简单的CPU类型，如-CPU Opteron_g1-V1或类似的结果。 CPU类型欺骗Opteron 240处理器，这是市场上第一个X86_64 CPU之一。您可以通过执行qemu-x86_64 -cpu帮助，获得QEMU-User Emulator副本支持的CPU列表。 </p><p> There’s a lot more qemu-user emulation can do to help with reverse engineering, for some ideas, look at  qemu-x86_64 -h or similar.</p><p>有很多qemu  - 用户仿真可以做到帮助逆向工程，对于一些想法，看看qemu-x86_64-h或类似。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ariadne.space/2021/05/05/using-qemu-user-emulation-to-reverse-engineer-binaries/">https://ariadne.space/2021/05/05/using-qemu-user-emulation-to-reverse-engineer-binaries/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/qemu/">#qemu</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/user/">#user</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>