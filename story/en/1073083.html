<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>CSS层叠层CSS Cascade Layers</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">CSS Cascade Layers<br/>CSS层叠层</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-14 15:41:10</div><div class="page_narrow text-break page_content"><p>One of the most common causes of confusion in CSS is facing specificity while writing styles. For example, changing the  display value for an element never works because another element in the cascade overrides it due to having a higher specificity. Or when another element has  !important That usually happens when the codebase is growing and we’re not organizing CSS in a way that prevents (or reduces) such problems.</p><p>CSS中最常见的混乱原因之一是在书写风格时面临特殊性。例如，更改某个元素的显示值永远不会起作用，因为级联中的另一个元素由于具有更高的特定性而覆盖它。或者当另一个元素出现时！重要的是，当代码库不断增长，而我们没有以防止（或减少）此类问题的方式组织CSS时，通常会发生这种情况。</p><p> To overcome the fights with the cascade and specificity issues, we need to be careful about where to write a specific CSS block. In small projects, this can be okay, but for large ones, it’s a time-consuming task. As a result, we started to see different methods to help us organize our CSS better and thus reducing the cascade issues. The first three that came to my mind are the  BEM (Block, Element, Modifier),  Smacss by Jonathan Snook and  Inverted Triangle CSS by Harry Roberts.</p><p>为了克服层叠和特殊性问题的困扰，我们需要注意在哪里编写特定的CSS块。在小项目中，这是可以的，但对于大项目来说，这是一项耗时的任务。因此，我们开始看到不同的方法来帮助我们更好地组织CSS，从而减少级联问题。我想到的前三个是边界元法（Block，Element，Modifier），乔纳森·斯努克（Jonathan Snook）的Smacss和哈利·罗伯茨（Harry Roberts）的倒三角形CSS。</p><p> In this article, we’ll explore how cascade layers work, and how they will help us write CSS with more confidence, along with use-cases and examples.</p><p>在本文中，我们将探索级联层是如何工作的，它们将如何帮助我们更加自信地编写CSS，以及用例和示例。</p><p>     The main problem cascade layers solve is providing a guaranteed way to write CSS without worrying about specificity and source order. Let’s take an example to illustrate the problem.</p><p>级联层解决的主要问题是提供一种有保证的方式来编写CSS，而不必担心特定性和源代码顺序。让我们举个例子来说明这个问题。</p><p>  We have a button with two styles, the default and the ghost ones. In HTML, here how we will use them:</p><p>我们有一个有两种风格的按钮，默认的和幽灵的。在HTML中，我们将如何使用它们：</p><p>  The above work great in that case. But what if we need to have a third variation for the button but we can’t write it right after the  .button declaration?</p><p>在这种情况下，上述方法非常有效。但是，如果我们需要第三个按钮的变体，但我们不能在之后立即编写它呢。按钮声明？</p><p>  The  .button is coming after the  .button--facebook. As a result, it will override it. In that case, we might workaround this by increasing the specificity for  .button-facebook like:</p><p>这个按钮在后面。按钮——facebook。因此，它将覆盖它。在这种情况下，我们可以通过增加特定性来解决这个问题。点击facebook，比如：</p><p>    Either solution isn’t that good. The best one is to write them in the correct place, right after the  .button declaration. It’s not an easy job to do that without getting help from a CSS pre-processor (like Sass, for example) to help in dividing the CSS files into partials and components.</p><p>两种解决方案都不是那么好。最好的办法是把它们写在正确的地方，就在后面。按钮声明。如果没有CSS预处理器（比如Sass）的帮助，将CSS文件划分为部分和组件，那么要做到这一点并不容易。</p><p>  Cascade layers is a new CSS feature that will help us developers gain more control when we write CSS for large projects. According to the  the spec author, Miriam Suzanne:</p><p>Cascade layers是一个新的CSS特性，它将帮助我们开发人员在为大型项目编写CSS时获得更多控制。根据规范作者Miriam Suzanne的说法：</p><p> Cascade Layers will allow authors to manage their internal cascade logic, without relying entirely on the specificity heuristic or source order.</p><p>级联层允许作者管理其内部级联逻辑，而不完全依赖于特定性启发或源顺序。</p><p>  The first thing to do is to define a layer. To do that, we write  @ followed by the layer name.</p><p>首先要做的是定义一个图层。为此，我们在图层名后面写@。</p><p>  I defined a layer called  components. Within that layer, I need to add the default button styles.</p><p>我定义了一个叫做组件的层。在该层中，我需要添加默认的按钮样式。</p><p>   @layer  components  {  .button  {  color :  #fff ;  background-color :  #d73a7c ;  } } @layer  variations  {  .button--ghost  {  background-color :  transparent ;  color :  #474747 ;  border :  2px  solid  #e0e0e0 ;  } }</p><p>@图层组件{.按钮{颜色：#fff；背景色：#d73a7c；}@图层变化{.button--ghost{背景色：透明；颜色：#474747；边框：2px实心#e0e0；}</p><p> Here is a visualization of the layers. There are similar to Photoshop layers since what’s defined last in CSS, will be the first in the list of layers in the visual.</p><p>下面是图层的可视化。有类似于Photoshop的图层，因为CSS中最后定义的图层将是视觉系统中图层列表的第一个。</p><p>  In our example, the  variation layer is the last defined one, so it will have more priority over the  components layer.</p><p>在我们的示例中，变体层是最后定义的一层，因此它比组件层具有更高的优先级。</p><p> There is also another way to organize which layer override another, which is by defining the layers at once.</p><p>还有另一种方法可以组织哪一层覆盖另一层，即立即定义层。</p><p>  Back to our example. The initial problem was that we needed to create another variation of the button but we added it in a place that makes the variation button have less specificity. With Cascade layers, we can add the CSS in the  variations layer.</p><p>回到我们的例子。最初的问题是，我们需要创建按钮的另一个变体，但我们将其添加到了一个使变体按钮具有较少特异性的位置。通过级联层，我们可以在变体层中添加CSS。</p><p> @layer  components ,  variations ; @layer  components  {  .button  {  color :  #fff ;  background-color :  #d73a7c ;  } } @layer  variations  {  .button--ghost  {  background-color :  transparent ;  color :  #474747 ;  border :  2px  solid  #e0e0e0 ;  }  .button--facebook  {  background-color :  var ( --brand-fb );  } }</p><p>@层组成、变化@图层组件{.按钮{颜色：#fff；背景色：#d73a7c；}@图层变化{.button--ghost{背景色：透明；颜色：#474747；边框：2px实心#e0；}。按钮--facebook{背景颜色：var（--brand fb）；}</p><p> That way, we can always ensure that the component variation will  always take priority over the base styles. Let’s explore the explanation above visually.</p><p>这样，我们就可以确保组件的变化总是优先于基本样式。让我们以直观的方式探索上面的解释。</p><p> In the layers panel, notice how each button lives in a layer. The order is per the  @layer definition at the top.</p><p>在“层”面板中，请注意每个按钮如何位于一个层中。顺序根据顶部的@layer定义确定。</p><p>  When the order of layers is changed, the  components layer will override the  variations one. As a result, the default button style will win.</p><p>更改图层顺序时，“组件”图层将覆盖其中一个。因此，默认按钮样式将获胜。</p><p>   In cascade layers, the browser combines styles from the same  @layer definitions and reads them at once, as per their order.</p><p>在层叠层中，浏览器将来自相同@layer定义的样式组合在一起，并根据它们的顺序立即读取它们。</p><p>  @layer  components ,  variations ; @layer  components  {  .button  { .. } } @layer  variations  {  .button--ghost  { .. } } /* 500 lines later */ @layer  variations  {  .button--facebook  { .. } }</p><p>@层组成、变化@图层组件{.button{..}@图层变体{.button--ghost{..}/*500行之后*/@layer variations{.button--facebook{..}</p><p> The browser will add the  .button--facebook right after the  .button--ghost in the variations layer. Here is a visual for more clarity:</p><p>浏览器将添加。按钮——facebook就在那之后。按钮——变体层中的幽灵。以下是更清晰的视觉效果：</p><p>   This is the most important question to think about for a new CSS feature. As per  Can I Use and at the time of writing this article, it’s supported in Firefox, Chrome, Safari TP.</p><p>这是一个新的CSS特性需要考虑的最重要的问题。正如我可以使用的，在撰写本文时，Firefox、Chrome、Safari TP都支持它。</p><p> Can we use them as an enhancement? No, we can’t. Unless we use a Javascript polyfill (which isn’t there yet).</p><p>我们可以用它们来增强功能吗？不，我们不能。除非我们使用Javascript polyfill（目前还没有）。</p><p>     Consider the following figure. The thicker the line, the more priority the style has in the cascade.</p><p>考虑下面的图，线条越粗，级联中样式的优先级越高。</p><p>   The origin and importance of a style rule are two different (but related) things, so I will explain each one below.</p><p>风格规则的起源和重要性是两个不同（但相关）的东西，所以我将在下面逐一解释。</p><p> A style rule origin can come from one of the following, in descending order of priority:</p><p>样式规则的来源可以按优先级降序来自以下之一：</p><p>  That means the CSS that a developer wrote will always win over the user and browser styles.</p><p>这意味着开发人员编写的CSS将始终赢得用户和浏览器样式。</p><p>   If a user tried to change their browser’s default font size, the above CSS rule will override the user’s preference (since developer styles win over the user’s one).</p><p>如果用户试图更改浏览器的默认字体大小，上述CSS规则将覆盖用户的首选项（因为开发人员的样式胜过用户的样式）。</p><p>  That’s a bad practice for accessibility. Please don’t do this in real-life projects. I just added it for the sake of explaining the origin of styles.</p><p>这是一个糟糕的可访问性实践。请不要在现实生活中这样做。我添加它只是为了解释风格的起源。</p><p> Regarding browser styles, they are for the  user agent stylesheets. For example, the default  &lt;button&gt; style differs from one browser to another. We can override the default style, you guessed it because the  developer styles wins over the browser ones.</p><p>关于浏览器样式，它们适用于用户代理样式表。例如，默认值&lt；按钮&gt；不同浏览器的样式不同。我们可以覆盖默认样式，你猜到了，因为开发者的样式胜过浏览器的样式。</p><p> If you inspect the default button, you will notice  user agent stylesheet, which shows all the default styles that the button has.</p><p>如果你检查默认按钮，你会注意到用户代理样式表，它显示了按钮的所有默认样式。</p><p>  All the above was  normal rules. This means they don’t have the  !important keyword. In case it’s there, then the order will be:</p><p>所有这些都是正常的规则。这意味着他们没有！重要的关键词。如果它在那里，那么顺序将是：</p><p>   If an element has an inline style, then it will have the highest specificity among its siblings with the same importance.</p><p>如果一个元素具有内联样式，那么它在同等重要性的同级元素中具有最高的特异性。</p><p> In the following example, the  &lt;button&gt; color will be  #fff since inline styles take precedence.</p><p>在下面的示例中，&lt；按钮&gt；颜色将为#fff，因为内联样式优先。</p><p>    Oh, hello layers! This is the new guest in the cascade. Cascade layers have more priority over the specificity of a selector. In the following example, can you guess the font size of the  p element in the  custom layer?</p><p>哦，你好！这是cascade的新客人。级联层的优先级高于选择器的特殊性。在下面的示例中，您能猜出自定义层中p元素的字体大小吗？</p><p> @layer  base ,  custom ; @layer  base  {  #page  .prose  p  {  font-size :  1rem ;  } } @layer  custom  {  p  {  font-size :  2rem ;  } }</p><p>@层底，定制@层基{#页面.散文p{font size:1rem；}@图层自定义{p{font size:2rem；}</p><p> The font size is  2rem. In cascade layers, no matter the element specificity, it will be ignored if the element is being overridden in the next layer.</p><p>字体大小为2rem。在级联层中，无论元素的特殊性如何，如果元素在下一层中被重写，它都将被忽略。</p><p>  After layers, the browser looks at the CSS rules and decides which one wins over the other based on its selector specificity.</p><p>在图层之后，浏览器会查看CSS规则，并根据其选择器特性决定哪一个优于另一个。</p><p> Here is a simple example. The  button within a newsletter has a higher specificity than the  .button. As a result, the first rule will be overridden.</p><p>下面是一个简单的例子。新闻稿中的按钮比。按钮因此，第一条规则将被覆盖。</p><p>   Finally, the order of appearance takes action. When two elements have the same specificity, then their order in the CSS document will determine which one wins.</p><p>最后，外观的顺序起作用。当两个元素具有相同的特性时，它们在CSS文档中的顺序将决定哪一个元素获胜。</p><p>   Both of the above rules have the same specificity. The latter wins because it came after the first rule.</p><p>上述两条规则具有相同的特殊性。后者获胜是因为它在第一条规则之后。</p><p> Now that you have an idea about where layers live in the cascade, let’s get into some use cases.</p><p>现在，您已经了解了层在级联中的位置，让我们进入一些用例。</p><p>  I tried to look at current projects and see where cascade layers will shine, and I came up with the following use uses.</p><p>我试着看看当前的项目，看看层叠层将在哪里发光，我想出了以下用法。</p><p>  For a project I’m working on, using cascade layers for theming the UI will be the perfect solution. The problem it solves here is to allow me as a developer to switch between themes without changing the CSS or reorder it in one way or another.</p><p>对于我正在从事的一个项目来说，使用层叠层对UI进行主题化将是一个完美的解决方案。它解决的问题是，作为一名开发人员，我可以在不改变CSS或以某种方式重新排序的情况下切换主题。</p><p>  I have different layers, and the last one is  themes. The layer themes can contain multiple layers (Yes, cascade layers support nesting).</p><p>我有不同的层次，最后一个是主题。图层主题可以包含多个图层（是的，层叠图层支持嵌套）。</p><p> Notice at the top, I defined  @layer custom, default. The default theme will override the custom one.</p><p>请注意，在顶部，我定义了@layer custom，默认值。默认主题将覆盖自定义主题。</p><p> @layer  base ,  elements ,  objects ,  components ,  pages ,  themes ; @layer  themes  {  @layer  custom ,  default ;  @layer  default  {  :root  {  --color-primary :  #1877f2 ;  }  }  @layer  custom  {  :root  {  --color-primary :  #d73a7c ;  }  } }</p><p>@层基础、元素、对象、组件、页面、主题@图层主题{@layer custom，default；@layer default{:root{--color primary:#1877f2；}@图层自定义{：根{--主颜色：#d73a7c；}}</p><p> If you want to switch themes, you can just  reorder the layers in the first definition inside  @layer themes.</p><p>如果你想切换主题，你可以在@layer themes中重新排列第一个定义中的层。</p><p> @layer  base ,  elements ,  objects ,  components ,  pages ,  themes ; @layer  themes  {  /* Custom is active */  @layer  default ,  custom ;  @layer  default  {  :root  {  --color-primary :  #1877f2 ;  }  }  @layer  custom  {  :root  {  --color-primary :  #d73a7c ;  }  } }</p><p>@层基础、元素、对象、组件、页面、主题@图层主题{/*自定义处于活动状态*/@layer default，自定义；@layer default{：根{--color primary:#1877f2；}@图层自定义{：根{--主颜色：#d73a7c；}}</p><p>   .flickity-page-dots  {  bottom :  20px  !important ; } .flickity-page-dots  .dot  {  background :  #fff  !important ;  opacity :  0.35  !important ; } .flickity-page-dots  .dot.is-selected  {  opacity :  1  !important ; }</p><p>.flickity页面点{底部：20px！重要；}。flickity页面点。dot{背景：#fff！重要；不透明度：0.35！重要；}。flickity页面点。点已选中{不透明度：1！重要；}</p><p> With the cascade layers, we can add the third-party CSS before the components layer. We can import an external CSS file and assign it to a layer.</p><p>通过级联层，我们可以在组件层之前添加第三方CSS。我们可以导入一个外部CSS文件并将其分配给一个层。</p><p> @layer  base ,  vendors ,  components ; @layer  base  {  /* Base styles */ } /* Import a .css file and assign it to a layer */ @import  url(flickity.css)  layer ( vendors ); @layer  components  {  .flickity-page-dots  {  bottom :  20px ;  }  .dot  {  background :  #fff ;  opacity :  0.35 ;  }  .dot.is-selected  {  opacity :  1 ;  } }</p><p>@层基础、供应商、组件@图层基础{/*基础样式*/}/*导入。css文件，并将其分配到一个层*/@import url（flickity.css）层（供应商）@图层组件{.flickity页面点{bottom:20px；}。dot{背景：#fff；不透明度：0.35；}。点已选中{opacity:1；}</p><p>  Say we have a listing component, and we need a variation where the list has a smaller margin.</p><p>假设我们有一个列表组件，我们需要一个列表边距较小的变体。</p><p>  Since the  :not pseudo selector gives the element more specificity, it can’t be overridden without reusing  :not. Consider the following:</p><p>由于：not伪选择器为元素提供了更多的特殊性，因此在不重用：not的情况下无法重写该元素。考虑以下事项：</p><p> /* This wins */ .list__item :not ( :last-child )  {  margin-bottom :  2rem ;  outline :  solid  1px  #222 ; }  .list__item--compact  {  margin-bottom :  1rem ; }</p><p>/*这个赢了*/。列表项：not（：last child）{margin bottom:2rem；outline:solid 1px#222；}。列表项--压缩{margin bottom:1rem；}</p><p> The  .list__item--compact won’t override the  .list__item, because the latter has more specificity due to using  :not. To make it work, we need to do the following:</p><p>这个list__项——compact不会覆盖。列出__项，因为后者由于使用：not而具有更高的特异性。为了让它发挥作用，我们需要做以下几点：</p><p>   Consider the following where the  @layer list contains  base and  overrides layer. In the  overrides, I wrote the variation class, and it worked as expected since the  overrides is the last layer.</p><p>考虑下面的层，其中@层列表包含基础层和覆盖层。在overrides中，我编写了variation类，由于overrides是最后一层，所以它按预期工作。</p><p> @layer  list  {  @layer  base ,  overrides ;  @layer  base  {  .list__item :not ( :last-child )  {  margin-bottom :  2rem ;  }  }  @layer  overrides  {  .list__item--compact  {  margin-bottom :  1rem ;  }  } }</p><p>@图层列表{@layer base，overrides；@layer base{.list__项：not（：last child）{margin bottom:2rem；}@图层覆盖{.list__item--compact{margin bottom:1rem；}}</p><p>   In this example, we have a list of actions (like, comment) for the main social feed item, and another list per each comment.</p><p>在这个例子中，我们有一个主要社交提要项的操作列表（比如评论），每个评论都有一个列表。</p><p> The icon in the feed item has a size of  24px. In the comment component, the size is smaller.</p><p>提要项中的图标大小为24px。在注释组件中，大小较小。</p><p> @layer  feed ,  comments ; @layer  feed  {  .feed-item  .c-icon  {  width :  24px ;  height :  24px ;  } } @layer  comments  {  .comment__icon  {  width :  18px ;  height :  18px ;  } }</p><p>@层饲料，评论@层馈送{.feed item.c图标{宽度：24px；高度：24px；}@图层注释{.comment__图标{宽度：18px；高度：18px；}</p><p> Notice that  .feed-item .c-icon has more specificity than  .comment__icon, but that’s the benefit of using cascade layers!</p><p>注意。饲料项目。c-icon比c-icon更具特异性。注释图标，但这就是使用层叠层的好处！</p><p>  We’ve gotten used to adding  !important to utility CSS classes to ensure that they will always  apply to the element. With cascade layers, we can place the utility in the last year.</p><p>我们已经习惯了添加！重要的是实用CSS类，以确保它们始终应用于元素。通过级联层，我们可以将实用程序放置在去年。</p><p> Consider the following example. We have a page header with a utility class  p-0. We want to reset the padding to  0.</p><p>考虑下面的例子。我们有一个带有实用程序类p-0的页眉。我们要将填充重置为0。</p><p>   @layer  base ,  vendors ,  components ,  utils ; @layer  components  {  @layer  page-header  {  .c-page-header  {  padding :  1rem  2rem ;  }  } } @layer  utils  {  .px-0  {  padding-left :  0 ;  padding-right :  0 ;  } }</p><p>@层库、供应商、组件、UTIL@层组件{@layer-page-header{.c-page-header{padding:1rem 2rem；}}}@层utils{.px-0{左填充：0；右填充：0；}</p><p>   If there are CSS styles that aren’t assigned to a layer, then we will be added to an implicit  final layer.</p><p>如果有CSS样式没有指定给一个层，那么我们将被添加到一个隐式的最终层。</p><p>  .button  {  border :  2px  solid  lightgrey ; } @layer  base ,  components ; @layer  base  { /* Base styles */ } @layer  components  {  .button  {  border :  0 ;  } }</p><p>.按钮{边框：2px实心浅灰色；}@基层、构件@图层基础{/*基础样式*/}@layer components{.button{border:0；}</p><p> In this example, the  .button rule is defined without a  @layer, but for the browser, this will place the rule in an implicit layer.</p><p>在本例中。按钮规则的定义没有@层，但对于浏览器，这将把规则放在隐式层中。</p><p> @layer  base ,  components ; @layer  base  { /* Base styles */ } @layer  components  {  .button  {  border :  0 ;  } } /* Implicit layer */ @layer  {  .button  {  border :  2px  solid  lightgrey ;  }  }</p><p>@基层、构件@图层基础{/*基础样式*/}@layer components{.button{border:0；}}/*隐式层*/@layer{.button{border:2px solid lightgrey；}</p><p>  Cascade layers are an exciting CSS feature, and as you’ve seen in the examples, it can be quite useful. The only limitation for me is that we won’t be able to use it as an enhancement with CSS alone. That might slow down the adoption of layers a bit in the web community.</p><p>层叠层是一个令人兴奋的CSS特性，正如您在示例中看到的，它非常有用。对我来说，唯一的限制是，我们不能将其单独用作CSS的增强功能。这可能会降低网络社区中层的采用速度。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/css/">#css</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cascade/">#cascade</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>