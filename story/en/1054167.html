<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Erlang垃圾收集细节及其原因（2015） Erlang Garbage Collection Details and Why It Matters (2015)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Erlang Garbage Collection Details and Why It Matters (2015)<br/>Erlang垃圾收集细节及其原因（2015） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-23 17:05:13</div><div class="page_narrow text-break page_content"><p>One of the main problems that Erlang tried to solve was creating a platform for implementing  Soft Realtime systems with a high level of responsiveness. Such systems require a fast  Garbage Collection mechanism that doesn’t stop the system from responding in a timely manner. On other hand Garbage Collection gets more importance when we consider Erlang as an  Immutable language with  Non-destructive Update property, because there is a high rate of producing garbage in such languages.</p><p>Erlang尝试解决的主要问题之一是创建一个实现具有高响应级别的软实时系统的平台。这种系统需要快速的垃圾收集机制，不能停止系统及时响应。当我们认为Erlang作为一种不可变形的语言时，垃圾收集更加重要，因为具有非破坏性更新属性，因为这些语言具有很高的生产垃圾。</p><p>  Before digging into GC, it is essential to inspect the memory layout of an Erlang process which can be divided into three main parts: Process Control Block, Stack and Heap. It is so similar to Unix process memory layout.</p><p>  在挖掘GC之前，必须检查Erlang进程的内存布局，可分为三个主要部分：过程控制块，堆栈和堆。它与UNIX进程内存布局类似。</p><p> Shared Heap Erlang Process Memory Layout +----------------------------------+ +----------------------------------+ | | | | | | | PID / Status / Registered Name | Process | | | | Control | | | Initial Call / Current Call +----&gt; Block | | | | (PCB) | | | Mailbox Pointers | | | | | | | +----------------------------------+ | | | | | | | Function Parameters | | | | | Process | | | Return Addresses +----&gt; Stack | | | | | +--------------+ | | Local Variables | | | | | | | | | +------------+--+ | +-------------------------------+--+ | | | | | | | | | | | +-------------+--+ | | ^ v +----&gt; Free | | | | | | | | | Space | | | | +--------------+-+ | +--+-------------------------------+ | +-+ | | | | | | | +-+ | Refc Binary | | | Mailbox Messages (Linked List) | | +-+ | | |   | | +------^---------+ | | Compound Terms (List, Tuples) | Process | | | | +----&gt; Private | | | | Terms Larger than a word | Heap | | | | | | +--+ ProcBin +-------------+ Pointers to Large Binaries | | | | | +----------------------------------+ +----------------------------------+</p><p> 共享堆erlang过程内存布局+ ---------------------------------------- ------------------------- + | | | | | | | PID /状态/注册名称|过程| | | |控制| | |初始呼叫/当前呼叫+ ----＆gt;块| | | | （PCB）| | |邮箱指针| | | | | | | + ------------------------------- + | | | | | | |功能参数| | | | |过程| | |返回地址+ ----＆gt;堆栈| | | | | + -------------- + | |局部变量| | | | | | | | | + ------------ +  -  + | + ---------------------------- +  -  + | | | | | | | | | | | + ------------- +  -  + | | ^ V + ----＆gt;自由| | | | | | | | |空间| | | | + -------------- +  -  + | +  -  + ---------------------------- + | +  -  + | | | | | | | +  -  + | REFC二进制| | |邮箱消息（链接列表）| | +  -  + | | | | | + ------ ^ ---------- + | |复合术语（名单，元组）|过程| | | | + ----＆gt;私人| | | |术语大于单词|堆| | | | | | +  -  + procbin + ------------- +指向大型二进制文件| | | | | + --------------------------------------------- --------------------</p><p> PCB: Process Control Block holds some information about the process such as its identifier (PID) in Process Table, current status (running, waiting), its registered name, the initial and current call, and also PCB holds some pointers to incoming messages which are members of a  Linked List that is stored in heap.</p><p> PCB：Process Control块在过程表中包含有关其标识符（PID）等过程的一些信息，当前状态（运行，等待），其注册名称，初始和当前呼叫以及PCB对传入消息的指向是存储在堆中的链接列表的成员。</p><p>  Stack: It is a downward growing memory area which holds incoming and outgoing parameters, return addresses, local variables and temporary spaces for evaluating expressions.</p><p>  堆栈：是一个向下生长的内存区域，它包含传入和传出参数，返回地址，局部变量和用于评估表达式的临时空间。</p><p>  Heap: It is an upward growing memory area which holds physical messages of process mailbox, compound terms like  Lists,  Tuples and  Binaries and objects which are larger than a machine word such as floating point numbers. Binary terms which are larger than 64 bytes are not stored in process private heap. They are called  Refc Binary (Reference Counted Binary) and are stored in a large  Shared Heap which is accessible by all processes who have the pointer of that Refc Binaries. That pointer is called  ProcBin and is stored in process private heap.</p><p>  堆：它是一个向上生长的内存区域，它包含流程邮箱的物理信息，比如列表，元组和二进制文件，如诸如浮点数的机器单词的列表，元组和二进制文件和对象。大于64字节的二进制术语不存储在进程私有堆中。它们被称为Refc二进制（参考计数二进制），并存储在一个大的共享堆中，该堆可通过具有该Refc二进制文件指针的所有进程访问。该指针称为ProcBin，并存储在进程私有堆中。</p><p>  In order to explain current default Erlang’s GC mechanism concisely we can say; it is a  Generational Copying garbage collection that runs inside each Erlang process private heap independently, and also a  Reference Counting garbage collection occurs for global shared heap.</p><p>  为了简明扼要地解释当前默认的erlang的GC机制;它是一个世代复制垃圾收集，可以独立地在每个erlang进程私有堆内运行，并且还针对全局共享堆出现引用计数垃圾收集。 </p><p>  The GC for private heap is generational. Generational GC divides the heap into two segments: young and old generations. This separation is based on the fact that if an object survives a GC cycle the chances of it becoming garbage in short term is low. So the young generation is for newly allocated data, and old generation is for the data that have survived an implementation specific number of GC. This separation helps the GC to reduce its unnecessary cycles over the data which have not become garbage yet.In context of Erlang garbage collection there are two strategies;  Generational (Minor) and  Fullsweep (Major). The generational GC just collects the young heap, but fullsweep collect both young and old heap. Now lets review the GC steps in private heap of a newly started Erlang process:</p><p>私人堆的GC是世代的。世代GC将堆分为两段：年轻人和旧代。这种分离是基于这样一个事实：如果物体存活到GC循环，它在短期内将成为垃圾的可能性很低。因此，年轻一代是用于新分配的数据，旧一代是幸存于实施特定数量的GC的数据。这种分离有助于GC减少其在没有成为垃圾的数据上的不必要的周期。在Erlang垃圾收集的背景下有两种策略;世代（次要的）和古代（专业）。世代GC只收集了年轻的堆，但填充了旧堆。现在让我们在新开始的Erlang进程的私人堆中查看GC步骤：</p><p>   No GC occurs in a short-lived process which doesn’t use heap more that  min_heap_size and then terminates. This way the whole memory used by process is collected.</p><p>   没有GC在短期过程中发生，该过程不再使用min_heap_size然后终止堆。这样收集过程中使用的整个内存。</p><p>   A newly spawned process whose data grows more that  min_heap_size uses fullsweep GC, obviously because no GC has occurred yet and so there is no separation between objects as young and old generations. After that first fullsweep GC, the heap is separated into young and old segments and afterward the GC strategy switches to generational and remains on it until the process terminates.</p><p>   一种新生产的进程，其数据增加了Min_heap_size使用FullSweep GC，显然是因为尚未发生GC，因此对Offer和Old TewNations的对象之间没有分离。之后，首次全普通GC之后，堆分为年轻人和旧段，然后将GC策略交换为代理，并在进程终止之前保持在其上。</p><p>   There are cases in a process lifetime when GC strategy switches from generational back to fullsweep again. First case is after certain number of generational GC occurs. This certain number can be specified globally or per process with  fullsweep_after flag. Also the counter of generational GC per process and its upper bound before fullsweep GC are  minor_gcs and  fullsweep_after properties respectively, and can be seen in return value of  process_info(PID, garbage_collection). Second case is when the generation GC cannot collect enough memory and the last case is when the  garbage_collect(PID) function is called manually. After these cases the GC strategy reverts again from fullsweep to generational and remains on it until aforementioned cases occurs.</p><p>   当GC策略再次从代域切换到Fullsweep时，有一个过程寿命。第一个案例是经过一定数量的世代GC。该某个号码可以全局或使用FullSweep_After标志指定或每个进程指定。此外，Foursweep GC之前的世代GC的计数器和其上限分别是Minor_GCS和Fullsweep_After属性，并且可以在Process_Info（PID，Garbage_Collection）的返回值中看到。第二种情况是当生成GC不能收集足够的内存并且最后一个情况是手动调用垃圾箱（PID）函数时。在这些情况之后，GC策略再次从FullSweep再次恢复到生成，并留在上面发生的情况下。</p><p>  Spawn &gt; Fullsweep &gt; Generational &gt; Fullsweep &gt; Increase Heap &gt; Fullsweep &gt; ... &gt; Terminate</p><p>  Spawn＆gt; Fullsweep＆gt;世代＆gt; Fullsweep＆gt;增加堆和gt; Fullsweep＆gt; ...＆gt;终止</p><p> In scenario 3 if the second fullsweep GC cannot collect enough memory, then the heap size is increased and the GC strategy switches to fullsweep again, like a newly spawned process, and all these four scenarios can be occurred again and again.</p><p> 在方案3中，如果第二次_ ullsweep gc无法收集足够的内存，则堆大小增加，GC策略再次切换到ullsweep，如新生生成的过程，并且可以再次又一次地发生所有这四种情况。</p><p> Now the question is why it matters in an automatic garbage collected language like Erlang.Firstly this knowledge can help you to make your system go faster by tuning the GC occurrence and strategy globally or per process. Secondly this is where we can understand one of the main reasons that makes Erlang a soft realtime platform from its garbage collection point of view. This is because each process has its own private heap and its own GC, so each time GC occurs inside a process it just stops the Erlang process which is being collected, but doesn’t stop other processes, and this is what a soft realtime system needs.</p><p> 现在，问题是为什么它在自动垃圾收集的语言中很重要，就像Erlang一样。过度地，这种知识可以帮助您通过调整全球范围或每个过程的GC发生和策略来使您的系统变得更快。其次，我们可以理解从其垃圾收集的角度来使Erlang成为软实时平台的主要原因之一。这是因为每个进程都有自己的私人堆和自己的GC，所以每次GC都会发生在一个过程中它只是停止了被收集的Erlang进程，但不会停止其他进程，这是一个软实时系统需要。 </p><p>  The GC for shared heap is reference counting. Each object in shared heap (Refc) has a counter of references to it held by other objects (ProcBin) which are stored inside private heap of Erlang processes. If an object’s reference counter reaches zero, the object has become inaccessible and will be destroyed. Reference counting GC is so cheap and helps the system to avoid unexpected long time pauses and boosts the system responsiveness. But being unaware of some well-known anti-patterns in designing your actor model system could make troubles in case of memory leak.</p><p>共享堆的GC是参考计数。共享堆（REFC）中的每个对象都具有由存储在Erlang进程的私有堆内的其他对象（Procbin）所持的IT引用的反击。如果对象的参考计数器达到零，则对象已无法访问，并将被销毁。 Count Counting GC非常便宜，有助于系统避免意外的长时间停顿并提高系统响应性。但是，在设计演员模型系统时不知道一些着名的反模式可能会在内存泄漏时发出麻烦。</p><p> First when a Refc is splitted into a  Sub-Binary. In order to be cheap; a sub-binary is not a new copy of splitted part of original binary, but just a reference into that part. However this sub-binary counts as a new reference in addition to the original binary, and you know, it can cause problem when the original binary must hang around for its sub-binary to be collected.</p><p> 首先，当REFC分成分二进制时。为了便宜;子二进制文件不是原始二进制文件的拆分部分的新副本，但只是参考该部分。然而，除了原始二进制文件之外，这个子二进制数量还是一个新的参考，而且你知道，当原始二进制文件必须挂起时，它可能会导致问题才能收集其子二进制。</p><p>  The other known problem is when there is a sort of long-lived middleware process acting as a request controller or message router for controlling and transferring large Refc binary messages. As this process touches each Refc message, the counter of them increments. So collecting those Refc messages depends on collecting all ProcBin objects even ones that are inside the middleware process. Unfortunately because ProcBins are just a pointer hence they are so cheap and it could take so long to happen a GC inside the middleware process. As a result the Refc messages remain on shared heap even if they have been collected from all other processes, except the middleware.</p><p>  其他已知问题是当存在一种用于控制和传送大型REFC二进制消息的请求控制器或消息路由器时的一种长寿命的中间件进程。由于此过程触及每个REFC消息，因此它们的计数器增量。因此，收集这些REFC消息取决于收集中间件内部的所有PROCBIN对象。不幸的是，因为普罗氏只是一个指针，因此它们非常便宜，可能需要很长时间才能发生中间件进程内的GC。因此，即使从中间件从所有其他进程收集，REFC消息也保持在共享堆上。</p><p> Shared heap matters because it reduces the IO of passing large binary messages between processes. Also creating sub-binaries are so fast because they are just pointers to another binary. But as a rule of thumb using shortcuts for being faster has cost, and its cost is well architecting your system in a way that doesn’t become trapped in bad conditions. Also there are some well-known architectural patterns for Refc binary leak issues which  Fred Hebert explains them in his free ebook;  Erlang in Anger, and I think that I cannot explain it better than him. So I strongly recommend you to read it.</p><p> 共享堆重要事项，因为它会减少在进程之间传递大型二进制消息的IO。创建子二进制文件也很快，因为它们只是指向另一个二进制文件的指针。但是，由于拇指的规则，使用快捷方式更快地拥有成本，其成本是以不困在不良条件的方式陷入困境的方式。还有一些众所周知的建筑模式，用于REFC二进制泄漏问题，FRED Hebbert在他的免费电子书中解释了它们; Erlang愤怒，我认为我无法比他更好地解释它。所以我强烈建议你读它。</p><p>  Even if we are using a language that manages memory itself like Erlang, nothing prevents us from understanding how memory is allocated and deallocated. Unlike  Go Language Memory Model Documentation Page that advices “ If you must read the rest of this document to understand the behavior of your program, you are being too clever. Don’t be clever.”, I believe that we must be clever enough to make our system faster and safer, and sometimes it doesn’t happen unless we dig deeper into what is going on.</p><p>  即使我们使用像Erlang这样的内存本身的语言，也没有任何东西可以防止我们了解如何分配和删除的内存。与Go Language Memory Model文档页面不同，“如果您必须阅读本文档的其余部分以了解程序的行为，您将太聪明。不要聪明。“，我相信我们必须聪明地使我们的系统更快，更安全，有时它不会发生，除非我们深入进入发生的事情。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html">https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/垃圾/">#垃圾</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/garbage/">#garbage</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gc/">#gc</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>