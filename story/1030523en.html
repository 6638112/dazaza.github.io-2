<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>自PostgreSQL 8.3以来的TPC-H性能</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">自PostgreSQL 8.3以来的TPC-H性能</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-22 20:49:05</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/201285ce3299b458b607b1e1c0b9f4d5.png"><img src="http://img2.diglog.com/img/2020/10/201285ce3299b458b607b1e1c0b9f4d5.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In the  first part of this blog series, I’ve presented a couple of benchmark results showing how PostgreSQL OLTP performance changed since 8.3, released in 2008. In this part I plan to do the same thing but for analytical / BI queries, processing large amounts of data.</p><p>在本博客系列的第一部分中，我展示了两个基准测试结果，展示了PostgreSQL OLTP自2008年发布的8.3以来的性能变化。在这一部分中，我计划做同样的事情，但对于分析/BI查询，处理大量数据。</p><p> There’s a number of industry benchmarks for testing this workload, but probably the most commonly used one is TPC-H, so that’s what I’ll use for this blog post. There’s also TPC-DS, another TPC benchmark for testing decision support systems, which may be seen as an evolution or replacement of TPC-H. I’ve decided to stick to TPC-H for a couple of reasons.</p><p>测试此工作负载有许多行业基准，但最常用的可能是TPC-H，因此我将在这篇博客文章中使用TPC-H。还有TPC-DS，另一个用于测试决策支持系统的TPC基准，它可以被视为TPC-H的演变或替代。出于几个原因，我决定坚持使用TPC-H。</p><p> Firstly, TPC-DS is much more complex, both in terms of schema (more tables) and number of queries (22 vs. 99). Tuning this properly, particularly when dealing with multiple PostgreSQL versions, would be much harder. Secondly, some of the TPC-DS queries use features that are not supported by older PostgreSQL versions (e.g. grouping sets), making those queries irrelevant for some versions. And finally, I’d say people are much more familiar with TPC-H compared to TPC-DS.</p><p>首先，TPC-DS在模式(更多的表)和查询数量(22对99)方面都要复杂得多。正确地调优这一点会困难得多，尤其是在处理多个PostgreSQL版本时。其次，一些TPC-DS查询使用较早的PostgreSQL版本不支持的功能(例如分组集)，使得这些查询与某些版本无关。最后，我想说，与TPC-DS相比，人们对TPC-H更加熟悉。</p><p> The goal of this is not to allow comparison to other database products, only to provide a reasonable long-term characterization on how PostgreSQL performance evolved since PostgreSQL 8.3.</p><p>这样做的目的不是为了与其他数据库产品进行比较，而是提供一个合理的长期特征，说明PostgreSQL自PostgreSQL8.3以来的性能是如何演变的。</p><p> Note: For a very interesting analysis of TPC-H benchmark, I strongly recommend the “ TPC-H Analyzed: Hidden Messages and Lessons Learned from an Influential Benchmark” paper from Boncz, Neumann and Erling.</p><p>注：要对TPC-H基准进行非常有趣的分析，我强烈推荐Boncz、Neumann和Erling的“TPC-H分析：隐藏的信息和从有影响力的基准中吸取的教训”的论文。</p><p>   Most of the results in this blog post come from the “bigger box” I have in our office, which has these parameters:</p><p>这篇博客文章中的大部分结果来自我办公室里的“更大的盒子”，它有以下参数：</p><p>  I’m sure you can buy significantly beefier machines, but I believe this is good enough to give us relevant data. There were two configuration variants – one with parallelism disabled, one with parallelism enabled. Most of the parameter values are the same in both cases, tuned to available hardware resources (CPU, RAM, storage). You can find a more detailed information about the configuration at the end of this post.</p><p>我相信你能买到更强壮的机器，但我相信这足以给我们提供相关数据。有两种配置变体-一种禁用了并行度，另一种启用了并行度。在这两种情况下，大多数参数值都是相同的，并根据可用的硬件资源(CPU、RAM、存储)进行调整。您可以在本帖子的末尾找到有关配置的更详细信息。</p><p>  I want to make it very clear that it’s not my goal to implement a valid TPC-H benchmark that could pass all the criteria required by the TPC. My goal is to evaluate how the performance of different analytical queries changed over time, not chase some abstract measure of performance per dollar or something like that.</p><p>我想非常清楚地说明，我的目标不是实现一个可以通过TPC要求的所有标准的有效TPC-H基准。我的目标是评估不同分析查询的性能是如何随时间变化的，而不是追求某种抽象的性能度量单位或类似的东西。</p><p> So I’ve decided to only use a subset of TPC-H – essentially just load the data, and run the 22 queries (same parameters on all versions). There are no data refreshes, the data set is static after the initial load. I’ve picked a number of scale factors, 1, 10 and 75, so that we have results for fits-in-shared-buffers (1), fits-in-memory (10) and more-than-memory (75). I’d go for 100 to make it a “nice sequence”, that wouldn’t fit into the 280GB storage in some cases (thanks to indexes, temporary files, etc.). Note that scale factor 75 is not even recognized by TPC-H as a valid scale factor.</p><p>因此，我决定只使用TPC-H的一个子集-本质上只是加载数据，然后运行22个查询(所有版本上的参数都相同)。没有数据刷新，数据集在初始加载后是静态的。我选择了一些比例因子，1、10和75，这样我们就可以得到适合共享缓冲区的结果(1)、适合内存的结果(10)和大于内存的结果(75)。我会选择100来使其成为一个“好的序列”，这在某些情况下不适合280 GB的存储(这要归功于索引、临时文件等)。请注意，TPC-H甚至不会将比例因子75识别为有效的比例因子。</p><p> But does it even make sense to benchmark 1GB or 10GB data sets? People tend to focus on much larger databases, so it might seem a bit foolish to bother with testing those. But I don’t think that’d be useful – the vast majority of databases in the wild is fairly small, in my experience And even when the whole database is large, people usually only work with a small subset of it – recent data, unresolved orders, etc. So I believe it makes sense to test even with those small data sets.</p><p>但是，对1 GB或10 GB数据集进行基准测试有意义吗？人们倾向于关注更大的数据库，所以费心去测试这些数据库似乎有点愚蠢。但我不认为这是有用的--根据我的经验，野外的绝大多数数据库都相当小，即使整个数据库很大，人们通常也只处理其中的一小部分-最近的数据、未解决的订单等。所以我认为，即使使用这些小的数据集进行测试也是有意义的。</p><p>  First, let’s see how long it takes to load data into the database – without and with parallelism. I’ll only show results from the 75GB data set, because the overall behavior is almost the same for the smaller cases.</p><p>首先，让我们看看将数据加载到数据库中需要多长时间-没有并行和有并行。我将只显示75 GB数据集的结果，因为对于较小的情况，总体行为几乎相同。</p><p>  You can clearly see there’s a steady trend of improvements, shaving off about 30% of the duration merely by improving efficiency in all four steps – COPY, creating primary keys and indexes, and (especially) setting up foreign keys. The “alter” improvement in 9.2 is particularly clear.</p><p>您可以清楚地看到改进的趋势是稳定的，仅通过提高所有四个步骤(复制、创建主键和索引，以及(特别是)设置外键)的效率，就可以减少大约30%的持续时间。9.2中的“Alter”改进尤为明显。</p><p>  Now, let’s see how enabling parallelism changes the behavior. The following chart compares results with parallelism enabled – marked with “(p)” – to results with parallelism disabled.</p><p>现在，让我们看看启用并行性是如何改变行为的。下图将启用并行度(标记为“(P)”)的结果与禁用并行度的结果进行比较。</p><p>  Unfortunately, it seems the effect of parallelism is very limited in this test – it does help a bit, but the differences are fairly small. So the overall improvement remains about 30%.</p><p>不幸的是，在这个测试中，并行性的效果似乎非常有限-它确实有一点帮助，但差异相当小。所以总体改善幅度保持在30%左右。</p><p>   Now we can take a look at queries. TPC-H has 22 query templates – I’ve generated one set of actual queries, and ran them on all versions twice – first after dropping all caches and restarting the instance, then with the warmed-up cache. All of the numbers presented in the charts are the best of these two runs (in most cases it’s the second one, of course).</p><p>现在我们可以看一下查询。TPC-H有22个查询模板-我已经生成了一组实际查询，并在所有版本上运行了它们两次-第一次是在删除所有缓存并重启实例之后，然后是使用预热的缓存。图表中显示的所有数字都是这两次运行中最好的(当然，在大多数情况下，这是第二次运行)。</p><p>  Without parallelism, the results on the smallest data set are pretty clear – each bar is split into multiple parts with different colors for each of the 22 queries. It’s hard to say which part maps to which exact query, but it’s sufficient for identifying cases when one query improves or gets much worse between two runs. For example in the first chart it’s very clear Q21 got much faster between 8.3 and 8.4.</p><p>在没有并行性的情况下，在最小的数据集上的结果非常清楚-对于22个查询中的每个查询，每个条形图都被分成多个部分，具有不同的颜色。很难说哪个部分映射到哪个确切的查询，但当一个查询在两次运行之间改善或变得更差时，它足以识别情况。例如，在第一张图表中，很明显，Q21在8.3到8.4之间的速度要快得多。</p><p>  For the 10GB scale, the results are somewhat hard to interpret, because on 8.3 one of the queries (Q21) takes so much time to execute that it dwarfs everything else.</p><p>对于10 GB的规模，结果有点难以解释，因为在8.3上，有一个查询(Q21)执行起来花费了太多时间，使其他所有查询都相形见绌。</p><p>    OK, that’s easier to read. We can clearly see that most of the queries (up to Q17) got faster, but then two of the queries (Q18 and Q20) got somewhat slower. We will see a similar issue on the largest data set, so I’ll discuss what might be the root cause then.</p><p>好的，这样就更容易读了。我们可以清楚地看到，大多数查询(直到Q17)都变得更快了，但随后有两个查询(Q18和Q20)变得稍微慢了一些。我们将在最大的数据集上看到类似的问题，所以我将讨论可能的根本原因。</p><p>  Again, we see a sudden increase for one of the queries in 9.3 – this time it’s Q2, without which the chart looks like this:</p><p>同样，我们看到9.3中的一个查询突然增加-这一次是第二季度，如果没有它，图表看起来如下所示：</p><p>  That’s a pretty nice improvement in general, speeding up the whole execution from ~2.7 hours to only ~1.2h, merely by making the planner and optimizer smarter, and by making the executor more efficient (remember, the parallelism was disabled in these runs).</p><p>总的来说，这是一个相当不错的改进，仅通过使计划器和优化器更智能，以及通过使执行器更高效(请记住，在这些运行中禁用了并行性)，就可以将整个执行速度从大约2.7小时加快到大约1.2小时。</p><p> So, what could be the problem with Q2, making it slower in 9.3? The simple answer is that every time you make the planner and optimizer smarter – either by constructing new types of paths / plans, or by making it dependent on some statistics, it also means new mistakes can be made when the statistics or estimates are wrong. In Q2, the WHERE clause references an aggregate subquery – a simplified version of the query might look like this:</p><p>那么，第二季度会有什么问题，让它在9.3中变得更慢呢？简单的答案是，每次您使计划器和优化器变得更智能-无论是通过构建新类型的路径/计划，还是通过使其依赖于某些统计数据，也意味着当统计数据或估计出错时，可能会出现新的错误。在第二季度中，WHERE子句引用聚合子查询-该查询的简化版本可能如下所示：</p><p> select    1from    partsuppwhere ps_supplycost = (        select            min(ps_supplycost)        from            partsupp,            supplier,            nation,            region        where            p_partkey = ps_partkey            and s_suppkey = ps_suppkey            and s_nationkey = n_nationkey            and n_regionkey = r_regionkey            and r_name = &#39;AMERICA&#39;    );</p><p>从部分补给中选择1，其中ps_Supplyost=(补给成本)从补给中选择补给，最小补给(Ps_Supplyost)：补给，从补给中选择，补给中选择。*区域*及s_suppkey=s_suppkey*及r_name=&#39；及n_regionkey=r_regionkey=r_regionkey*及r_name=#39；美国(美国)；</p><p> The problem is that we don’t know the average value at planning time, making it impossible to compute sufficiently good estimates for the WHERE condition. The actual Q2 contains additional joins, and planning those fundamentally depends on good estimates of the joined relations. In older versions the optimizer seems to have been doing the right thing, but then in 9.3 we made it smarter in some way, but with the poor estimate it fails to make the right decision. In other words, the good plans in older versions were just luck, thanks to the planner limitations.</p><p>问题是我们不知道计划时的平均值，因此不可能为WHERE条件计算足够好的估计值。实际的Q2包含额外的联接，而计划这些联接从根本上取决于对联接关系的良好估计。在旧版本中，优化器似乎一直在做正确的事情，但在9.3中，我们在某种程度上使其更智能，但由于估计不佳，它无法做出正确的决策。换句话说，由于计划者的限制，旧版本中的好计划只是运气而已。</p><p> I’d bet the regressions of Q18 and Q20 on the smaller data set are also caused by something similar, although I haven’t investigated those in detail.</p><p>我敢打赌，Q18和Q20在较小数据集上的回归也是由类似的原因造成的，尽管我没有详细调查这些原因。</p><p> I believe some of those optimizer issues might be fixed by tuning the cost parameters (e.g. random_page_cost etc.) but I haven’t tried that because of time constraints. It does however show that upgrades don’t automatically improve all queries – sometimes an upgrade may trigger a regression, so appropriate testing of your application is a good idea.</p><p>我相信其中一些优化器问题可以通过调优成本参数(例如，RANDOM_PAGE_COST等)来解决。但由于时间限制，我还没有试过。但是，它确实表明升级不会自动改进所有查询-有时升级可能会触发回归，因此对应用程序进行适当的测试是一个好主意。</p><p>  So let’s see how much query parallelism changes the results. Again, we’ll only look at results from releases since 9.6 labeling results with “(p)” where parallel query is enabled.</p><p>那么，让我们看看查询并行性在多大程度上改变了结果。同样，我们将只查看9.6版本的结果，因为在启用并行查询的情况下，使用“(P)”标记结果。</p><p>  Clearly, parallelism helps quite a bit – it shaves off about 30% even on this small data set. On the medium data set, there’s not much difference between regular and parallel runs:</p><p>显然，并行性有相当大的帮助-即使在这个很小的数据集上，它也减少了大约30%。在中等数据集上，常规运行和并行运行没有太大区别：</p><p>  This is yet another demonstration of the already discussed issue – enabling parallelism allows considering additional query plans, and clearly the estimates or costing do not match the reality, resulting in poor plan choices.</p><p>这是已经讨论过的问题的又一例证-启用并行性允许考虑额外的查询计划，而且很明显，估计或成本计算与实际不符，导致糟糕的计划选择。</p><p>   Here enabling the parallelism works in our advantage – the optimizer manages to build a cheaper parallel plan for Q2, overriding the poor plan choice introduced in 9.3. But just for completeness, here are the results without Q2.</p><p>在这里，启用并行性是我们的优势-优化器设法为第二季度构建了一个更便宜的并行计划，覆盖了9.3中引入的糟糕的计划选择。但为了完整起见，以下是不含Q2的结果。</p><p>  Even here you can spot some poor parallel plan choices – for example the parallel plan for Q9 is worse up until 11 where it gets faster – likely thanks to 11 supporting additional parallel executor nodes. On the other hand some parallel queries (Q18, Q20) get slower on 11, so it’s not just rainbows and unicorns.</p><p>即使在这里，您也可以发现一些糟糕的并行计划选择-例如，Q9的并行计划在11之前更差，而11的并行计划变得更快-这可能要归功于11支持额外的并行执行器节点。另一方面，一些并行查询(Q18、Q20)在第11天会变慢，因此不仅仅是彩虹和独角兽。</p><p>  I think these results nicely demonstrate the optimizations implement since PostgreSQL 8.3. The tests with parallelism disabled illustrate improvements in efficiency (i.e. doing more with the same amount of resources) – the data loads got ~30% faster and queries got ~2x faster. It’s true I’ve ran into some issues with inefficient query plans, but that’s an inherent risk when making the query planner smarter. We’re continuously working on making the results more reliable, and I’m sure I could mitigate most of these issues by tuning the configuration a bit.</p><p>我认为这些结果很好地说明了从PostgreSQL8.3开始实现的优化。禁用并行性的测试表明效率提高了(即使用相同数量的资源做更多事情)-数据加载速度提高了约30%，查询速度提高了约2倍。我确实遇到了一些低效查询计划的问题，但这是使查询规划器变得更智能时的固有风险。我们一直在努力使结果更可靠，我确信我可以通过稍微调优配置来缓解这些问题中的大多数。</p><p> The results with parallelism enabled show that we can utilize extra resources effectively (CPU cores in particular). The data loads don’t seem to benefit from this very much – at least not in this benchmark, but the impact on query execution is significant, resulting in ~2x speedup (although different queries are affected differently, of course).</p><p>在启用并行性的情况下，结果表明我们可以有效地利用额外的资源(特别是CPU内核)。数据加载似乎并没有从中获益很多-至少在这个基准测试中没有，但是对查询执行的影响是显著的，导致大约2倍的加速(当然，不同的查询受到不同的影响)。</p><p> There are many opportunities to improve this in future PostgreSQL versions. For example there’s a patch series implementing  parallelism for COPY, speeding up the data loads. There are various patches improving execution of analytical queries – from small localized optimizations to big projects like columnar storage and execution, aggregate push-down, etc. A lot can be gained by using declarative partitioning too – a feature I mostly ignored while working on this benchmark, simply because it would increase the scope way too much. And I’m sure there are many other opportunities that I can’t even imagine, but smarter people in the PostgreSQL community are already working on them.</p><p>在未来的PostgreSQL版本中有很多机会来改进这一点。例如，有一个补丁系列实现了复制的并行性，从而加快了数据加载速度。有各种补丁可以改进分析查询的执行-从小的本地化优化到列存储和执行、聚合下推等大项目。使用声明性分区也可以获得很多好处-这是我在进行此基准测试时几乎忽略的一个特性，原因很简单，因为它会以太大的方式扩大范围。我相信还有很多其他的机会是我无法想象的，但是PostgreSQL社区中更聪明的人已经在努力了。</p><p>     shared_buffers = 4GBwork_mem = 128MBvacuum_cost_limit = 1000max_wal_size = 24GBcheckpoint_timeout = 30mincheckpoint_completion_target = 0.9# logginglog_checkpoints = onlog_connections = onlog_disconnections = onlog_line_prefix = &#39;%t %c:%l %x/%v &#39;log_lock_waits = onlog_temp_files = 1024# parallel querymax_parallel_workers_per_gather = 0max_parallel_maintenance_workers = 0# optimizerdefault_statistics_target = 1000random_page_cost = 60effective_cache_size = 32GB</p><p>Shared_Buffers=4GBwork_mem=128MB VACKUP_COST_LIMIT=1000max_WAL_SIZE=24GB CHECKPOINT_TIMEOUT=30min CHECKPOINT_COMPLETION_TARGET=0.9#LOGGING LOG_CHECKPOINTS=onlog_CONNECTIONS=onlog_DISCONSIONS=onlog_line_prefix=&#39；%t%c：%l%x/%v&#39；log_lock_waits=onlog_temp_files=1024#并行查询max_Parallel_Worker_Per_Gather=0max_Parallel_Maintenance_Worker=0#Optimizerdefault_Statistics_target=1000随机_PAGE_COST=60有效缓存大小=32 GB。</p><p>    shared_buffers = 4GBwork_mem = 128MBvacuum_cost_limit = 1000max_wal_size = 24GBcheckpoint_timeout = 30mincheckpoint_completion_target = 0.9# logginglog_checkpoints = onlog_connections = onlog_disconnections = onlog_line_prefix = &#39;%t %c:%l %x/%v &#39;log_lock_waits = onlog_temp_files = 1024# parallel querymax_parallel_workers_per_gather = 16max_parallel_maintenance_workers = 16max_worker_processes = 32max_parallel_workers = 32# optimizerdefault_statistics_target = 1000random_page_cost = 60effective_cache_size = 32GB</p><p>Shared_Buffers=4GBwork_mem=128MB Vacuum_Cost_Limit=1000max_WAL_SIZE=24GB CHECKPOINT_TIMEOUT=30min CHECKPOINT_COMPLETION_TARGET=0.9#LOGGING LOG_CHECKPOINTS=onlog_CONNECTIONS=onlog_DISCONNECTIONS=onlog_line_prefix=&#39；%t%c：%l%x/%v&#39；LOG_LOCK_WAITS=onlog_temp_files=1024#并行查询max_Parallel_Worker_Per_Gather=16max_Parallel_Maintenance_Worker=16max_Worker_Processing=32max_Parallel_Worker=32#优化器DEFAULT_STATISTICS_TARGET=1000 RANDOM_PAGE_COST=60Effect_CACHE_SIZE=32 GB</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.2ndquadrant.com/en/blog/tpc-h-performance-since-postgresql-8-3/">https://www.2ndquadrant.com/en/blog/tpc-h-performance-since-postgresql-8-3/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tpc/">#tpc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/查询/">#查询</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1030389.html"><img src="http://img2.diglog.com/img/2020/10/thumb_c1481866f8ac975e5bd0efeda6491de0.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030389.html">HPE表示，它已获得1.6亿美元的欧盟资金，用于在芬兰建造一台超级计算机，理论上最高性能为550千万亿次浮点运算</a></div><span class="my_story_list_date">2020-10-22 9:10</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030198.html"><img src="http://img2.diglog.com/img/2020/10/thumb_77e67b9c577f57adddd96d1254075163.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030198.html">亚马逊的露娜在早期接入：没有强大的连接，流媒体性能可能参差不齐，iOS网络应用支持还不错，频道组竖井游戏选择</a></div><span class="my_story_list_date">2020-10-21 7:6</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030065.html"><img src="http://img2.diglog.com/img/2020/10/thumb_391944c6fc1dec30cf240953a4bb7542.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030065.html">中等大小文本对PostgreSQL性能的惊人影响</a></div><span class="my_story_list_date">2020-10-20 22:47</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030012.html"><img src="http://img2.diglog.com/img/2020/10/thumb_42e038d4da6cbd3c20497e67c458c1e8.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030012.html">IPhone 12 Pro评测：拥有出色的摄像头和性能，Dolby Vision视频非常棒，5G可以非常快，但续航时间不如iPhone 11 Pro</a></div><span class="my_story_list_date">2020-10-20 22:8</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>