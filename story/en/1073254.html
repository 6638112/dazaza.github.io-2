<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Web浏览器工程：调度任务和线程Web Browser Engineering: Scheduling tasks and threads</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Web Browser Engineering: Scheduling tasks and threads<br/>Web浏览器工程：调度任务和线程</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 04:19:27</div><div class="page_narrow text-break page_content"><p>Modern browsers must run sophisticated applications while stayingresponsive to user actions. Doing so means choosing which of its manytasks to prioritize and which to delay until later—tasks like JavaScriptcallbacks, user input, and rendering. Moreover, browser work must besplit across multiple threads, with different threads running events inparallel to maximize responsiveness.</p><p>现代浏览器必须运行复杂的应用程序，同时保持对用户操作的响应。这样做意味着选择要优先处理的众多任务中的哪些任务，以及将哪些任务推迟到以后的任务，如JavaScriptcallbacks、用户输入和呈现。此外，浏览器工作必须跨多个线程进行，不同的线程并行运行事件，以最大限度地提高响应能力。</p><p>  So far, most of the work our browser’s been doing has come from useractions like scrolling, pressing buttons, and clicking on links. But asthe web applications our browser runs get more and more sophisticated,they begin querying remote servers, showing animations, and prefetchinginformation for later. And while users are slow and deliberative,leaving long gaps between actions for the browser to catch up,applications can be very demanding. This requires a change inperspective: the browser now has a never-ending queue of tasks todo.</p><p>到目前为止，我们的浏览器所做的大部分工作都来自用户的操作，比如滚动、按下按钮和点击链接。但随着浏览器运行的web应用程序越来越复杂，它们开始查询远程服务器，显示动画，并为以后预取信息。虽然用户速度慢且考虑周全，在操作之间留下了很长的差距，以便浏览器跟上，但应用程序可能要求很高。这就需要在视角上做出改变：浏览器现在有一个永无止境的任务队列。</p><p> Modern browsers adapt to this reality by multitasking, prioritizing,and deduplicating work. Every bit of work the browser might do—loadingpages, running scripts, and responding to user actions—is turned into a task, which can be executed later, where a task is just afunction (plus its arguments) that can be executed:  By writing  *argsas an argument to  Task, we indicate that a Task can be constructed with any number of arguments, whichare then available as the list  args. Then, calling afunction with  *args unpacks the list back into multiplearguments.</p><p>现代浏览器通过多任务、优先排序和重复数据消除工作来适应这种现实。浏览器加载页面、运行脚本和响应用户操作所做的每一点工作都会转化为一个任务，可以在以后执行，其中一个任务只是一个可以执行的函数（加上它的参数）：通过将*args作为参数写入任务，我们表明一个任务可以用任意数量的参数构造，然后可以在列表args中使用。然后，使用*args调用函数将列表解压回多个元素。</p><p> class Task:    def  __init__( self, task_code,  *args):    self.task_code  = task_code    self.args  = args    self. __name__  =  &#34;task&#34;      def run( self):    self.task_code( * self.args)    self.task_code  =  None    self.args  =  None</p><p>类任务：def__init_________;（self，任务代码，*args）：self。任务代码=任务代码自身。args=args self__姓名_=&#34；任务34；def run（self）：self。任务代码（*self.args）self。任务代码=无自身。args=None</p><p> The point of a task is that it can be created at one point in time,and then run at some later time by a task runner of some kind, accordingto a scheduling algorithm.  The event loops we discussed in  Chapter 2 and  Chapter 11 aretask runners, where the tasks to run are provided by the operatingsystem. In our browser, the task runner will store tasksin a first-in first-out queue:</p><p>任务的意义在于，根据调度算法，它可以在某个时间点创建，然后由某种类型的任务运行程序在稍后的某个时间运行。我们在第2章和第11章讨论的事件循环是任务运行程序，其中要运行的任务由操作系统提供。在我们的浏览器中，任务运行程序将任务存储在先进先出队列中：</p><p>  When the time comes to run a task, our task runner can just removethe first task from the queue and run it:  First-in-first-out is asimplistic way to choose which task to run next, and real browsers havesophisticated  schedulers which consider  manydifferent factors.</p><p>当运行一个任务的时候，我们的任务运行器可以从队列中移除第一个任务并运行它：先入先出是一种简单的方式来选择接下来要运行的任务，而真正的浏览器有许多考虑不同因素的调度程序。</p><p>  To run those tasks, we need to call the  run method onour  TaskRunner, which we can do in the main event loop:</p><p>要运行这些任务，我们需要在我们的TaskRunner上调用run方法，我们可以在主事件循环中这样做：</p><p> class Tab:    def  __init__( self):    self.task_runner  = TaskRunner()     if  __name__  ==  &#34;__main__&#34;:    while  True:    # ...   browser.tabs[browser.active_tab].task_runner.run()</p><p>类选项卡：def_____;init（self）：self。task_runner=TaskRunner（）如果_name_==&#34__主要内容&#34；：尽管如此：#。。。浏览器选项卡[浏览器.活动选项卡]。任务跑者。跑（）</p><p> Here I’ve chosen to only run tasks on the active tab, which meansbackground tabs can’t slow our browser down.</p><p>在这里，我选择只在活动选项卡上运行任务，这意味着后台选项卡不能降低浏览器的速度。</p><p> With this simple task runner, we can now queue up tasks and executethem later. For example, right now, when loading a web page, our browserwill download and run all scripts before doing its rendering steps. Thatmakes pages slower to load. We can fix this by creating tasks forrunning scripts:</p><p>有了这个简单的任务运行程序，我们现在可以将任务排队并在以后执行。例如，现在，当加载网页时，我们的浏览器将下载并运行所有脚本，然后再执行呈现步骤。这使得页面加载速度变慢。我们可以通过为运行脚本创建任务来解决这个问题：</p><p> class Tab:    def run_script( self, url, body):    try:    print( &#34;Script returned: &#34;,  self.js.run(body))    except dukpy.JSRuntimeError  as e:    print( &#34;Script&#34;, url,  &#34;crashed&#34;, e)      def load( self):    for script  in scripts:    # ...   header, body  = request(script_url, url)   task  = Task( self.run_script, script_url, body)    self.task_runner.schedule_task(task)</p><p>class选项卡：def run_script（self，url，body）：try:print（&#34；脚本返回：&#34；，self.js.run（body））dukpy除外。JSRuntimeError as e:print（&#34；Script&#34；，url，&#34；crash&#34；，e）def load（self）：对于脚本中的脚本：#。。。标题，正文=请求（脚本url，url）任务=任务（self.run_脚本，脚本url，正文）self。任务跑者。计划任务（任务）</p><p> Now our browser will not run scripts until after  loadhas completed and the event loop comes around again.</p><p>现在，我们的浏览器将不会运行脚本，直到加载完成，事件循环再次出现。</p><p> JavaScript is also structured around a task-based  eventloop, even when it’s  not embeddedin a browser. It allows messages to be passed to event loops, usesrun-to-completion semantics, and generally speaking uses a lot of  asynchronouscallbacks and events. JavaScript’s programming model is anotherimportant reason to architect a browser in the same way.</p><p>JavaScript也是围绕基于任务的eventloop构建的，即使它没有嵌入浏览器中。它允许将消息传递给事件循环，使用run to completion语义，一般来说，它使用大量异步回调和事件。JavaScript的编程模型是以同样的方式构建浏览器的另一个重要原因。</p><p>  Tasks are  also a natural way to support several JavaScriptAPIs that ask for a function to be run at some point in the future. Forexample,   setTimeoutlets you run a JavaScript function some number of milliseconds from now.This code prints “Callback” to the console one second from now:</p><p>任务也是支持多个JavaScriptAPI的自然方式，这些API要求函数在将来的某个时间运行。例如，setTimeoutlets可以在几毫秒后运行JavaScript函数。这段代码在一秒钟后将“回调”打印到控制台：</p><p>  We can implement  setTimeout using the   Timerclass in Python’s   threadingmodule. You use the class like this:  An alternative approach would be to record when each Task is supposed to occur, and compare against the currenttime in the event loop. This is called  polling, and is what,for example, the SDL event loop does to look for events and tasks.However, that can mean wasting CPU cycles in a loop until the task isready, so I expect the  Timer to be moreefficient.</p><p>我们可以在Python的threadingmodule中使用Timerclass实现setTimeout。您可以这样使用该类：另一种方法是记录每个任务应该发生的时间，并与事件循环中的currenttime进行比较。这称为轮询，例如，SDL事件循环用于查找事件和任务。然而，这可能意味着在循环中浪费CPU周期，直到任务完成，所以我希望计时器更高效。</p><p>  This runs  callback one second from now on a new Pythonthread. Simple! But it’s going to be a little tricky to use Timer to implement  setTimeout because multiplethreads will be involved.</p><p>这将在一秒钟后的新蟒蛇上运行回调。易于理解的但使用定时器来实现setTimeout会有点棘手，因为会涉及多个线程。</p><p> As with  addEventListener in  Chapter 9, the call to setTimeout will save the callback in a JavaScript variableand create a handle by which the Python-side code can call it:</p><p>与第9章中的addEventListener一样，对setTimeout的调用将回调保存在JavaScript变量中，并创建一个句柄，Python端代码可以通过该句柄调用它：</p><p> SET_TIMEOUT_REQUESTS  = {}     function  setTimeout(callback , time_delta) {    var handle  =  Object . keys(SET_TIMEOUT_REQUESTS) . length ;   SET_TIMEOUT_REQUESTS[handle]  = callback ;    call_python( &#34;setTimeout&#34; , handle , time_delta)  }</p><p>SET_TIMEOUT_REQUESTS={}函数setTimeout（callback，time_delta）{var handle=Object.keys（SET_TIMEOUT_REQUESTS）.length；SET_TIMEOUT_REQUESTS[handle]=callback；call_python（&#34；setTimeout&#34；，handle，time#delta）}</p><p> The exported  setTimeout function will create a timer,wait for the requested time period, and then ask the JavaScript runtimeto run the callback. That last part will happen via __runSetTimeout:  Note that we never remove  callback from the SET_TIMEOUT_REQUESTS dictionary. This could lead to amemory leak, if the callback it holding on to the last reference to somelarge data structure. We saw a similar issue in  Chapter 9. In general, avoiding memory leakswhen you have data structures shared between the browser and the browserapplication takes a lot of care.</p><p>导出的setTimeout函数将创建一个计时器，等待请求的时间段，然后要求JavaScript运行时运行回调。最后一部分将通过_runSetTimeout实现：请注意，我们从未从SET_TIMEOUT_请求字典中删除回调。如果回调函数保留对某个大型数据结构的最后一个引用，这可能会导致amemory泄漏。我们在第九章看到了类似的问题。一般来说，在浏览器和浏览器应用程序之间共享数据结构时，避免内存泄漏需要非常小心。</p><p>  The Python side, however, is quite a bit more complex, because threading.Timer executes its callback  on a new Pythonthread. That thread can’t just call  evaljs directly:we’ll end up with JavaScript running on two Python threads at the sametime, which is not ok.  JavaScript is not a multi-threaded programming language.It’s possible on the web to create  workersof various kinds, but they all run independently and communicate onlyvia special message-passing APIs. Instead, the timer willhave to merely add a new  Task to the task queue for ourprimary thread will execute later:  This code has a  very subtle bug, wherein a pagemight create a  setTimeout, an then have that timer triggerlater, when a user is visiting another web page. In our browser, thatwould allow one page to run JavaScript that modifies a different page—ahuge security vulnerability! I  think you can avoid this byresetting  self.js.tab when you navigate to a new page, butideally you’d do something more careful, like keeping track of all thechild threads spawned by a  JSContext and ending all of thembefore navigating. As our browser gets more complex, our bugs, and theirassociated fixes, get more complex too!</p><p>然而，Python方面要复杂得多，因为线程。计时器在一个新的Pythonthread上执行其回调。该线程不能直接调用evaljs：我们将在同一时间在两个Python线程上运行JavaScript，这是不好的。JavaScript不是一种多线程编程语言。在网络上创建各种各样的工作人员是可能的，但它们都是独立运行的，只通过特殊的消息传递API进行通信。相反，计时器只需向任务队列中添加一个新任务，我们的主线程将在稍后执行：这段代码有一个非常微妙的错误，其中一个页面可能会创建一个setTimeout，然后在用户访问另一个网页时触发该计时器。在我们的浏览器中，这将允许一个页面运行JavaScript来修改另一个页面，这将导致巨大的安全漏洞！我认为你可以通过自我保护来避免这种情况。js。当你导航到一个新页面时，你应该做一些更仔细的事情，比如跟踪JSContext产生的所有子线程，并在导航之前结束所有子线程。随着我们的浏览器变得越来越复杂，我们的bug和相关修复也变得越来越复杂！</p><p> SETTIMEOUT_CODE  =  &#34;__runSetTimeout(dukpy.handle)&#34;     class JSContext:    def  __init__( self, tab):    # ...    self.interp.export_function( &#34;setTimeout&#34;,    self.setTimeout)      def dispatch_settimeout( self, handle):    self.interp.evaljs(SETTIMEOUT_CODE, handle =handle)      def setTimeout( self, handle, time):    def run_callback():   task  = Task( self.dispatch_settimeout, handle)    self.tab.task_runner.schedule_task(task)   threading.Timer(time  /  1000.0, run_callback).start()</p><p>SETTIMEOUT_CODE=&#34__runSetTimeout（dukpy.handle）和#34；类JSContext:def _uinit__________;（self，tab）：#。。。自己interp。export_函数（&#34；setTimeout&#34；self.setTimeout）def dispatch#u setTimeout（self，handle）：self。interp。evaljs（SETTIMEOUT_CODE，handle=handle）def SETTIMEOUT（self，handle，time）：def run_callback（）：task=task（self.dispatch_SETTIMEOUT，handle）self。标签。任务跑者。计划_任务（任务）线程。计时器（time/1000.0，运行_回调）。开始（）</p><p> This way it’s ultimately the primary thread that calls evaljs. That’s good, but now we have two threads accessingthe  task_runner: the primary thread, to run tasks, and thetimer thread, to add them. This is a  race conditionthat can cause all sorts of bad things to happen, so we need to makesure only one thread accesses the  task_runner at atime.</p><p>这样，调用evaljs的最终是主线程。这很好，但现在我们有两个线程访问task_runner：运行任务的主线程和添加任务的时间线程。这是一个竞争条件，可能会导致各种不好的事情发生，所以我们需要确保一次只有一个线程访问task_runner。</p><p> To do so we use a  Lock object, which can only held byone thread at a time. Each thread will try to acquire the lock beforereading or writing to the  task_runner, avoidingsimultaneous access:  The blocking parameter to  acquire indicateswhether the thread should wait for the lock to be available beforecontinuing; in this chapter you’ll always set it to  True.(When the thread is waiting, it’s said to be blocked.)</p><p>为此，我们使用一个锁对象，它一次只能由一个线程持有。每个线程将在读取或写入任务运行程序之前尝试获取锁，以避免同时访问：获取的阻塞参数指示线程在继续之前是否应等待锁可用；在本章中，你将始终将其设置为真。（当线程正在等待时，据说它被阻塞了。）</p><p> class TaskRunner:    def  __init__( self):    # ...    self.lock  = threading.Lock()      def schedule_task( self, task):    self.lock.acquire(blocking = True)    self.tasks.add_task(task)    self.lock.release()      def run( self):    self.lock.acquire(blocking = True)   task  =  None    if  len( self.tasks)  &gt;  0:   task  =  self.tasks.pop( 0)    self.lock.release()    if task:   task.run()</p><p>类任务运行程序：def _________________。。。自己锁=穿线。Lock（）def schedule_task（self，task）：self。锁获得（阻碍=真正的）自我。任务。添加任务（task）self。锁release（）定义运行（self）：self。锁如果len（self.tasks）&gt；0:task=self。任务。pop（0）self。锁如果任务：task，则释放（）。跑（）</p><p> When using locks, it’s super important to remember to release thelock eventually and to hold it for the shortest time possible. The codeabove, for example, releases the lock before running the task. That’s because after the task has been removed fromthe queue, it can’t be accessed by another thread, so the lock does notneed to be held while the task is running.</p><p>在使用锁时，记住最终释放锁并尽可能短地保持它是非常重要的。例如，上面的代码在运行任务之前释放锁。这是因为任务从队列中移除后，其他线程无法访问它，因此在任务运行时不需要持有锁。</p><p> Unfortunately, Python currently has a  globalinterpreter lock (GIL), so Python threads don’t truly run inparallel. This is an unfortunate limitation of Python that doesn’taffect real browsers, so in this chapter just try to pretend the GILisn’t there. Despite the global interpreter lock, we still need locks.Each Python thread can yield between bytecode operations, so you canstill get concurrent accesses to shared variables, and race conditionsare still possible. And in fact, while debugging the code for thischapter, I often encountered this kind of race condition when I forgotto add a lock; try removing some of the locks from your browser to seefor yourself!</p><p>不幸的是，Python目前有一个globalinterpreter锁（GIL），因此Python线程不能真正并行运行。这是Python的一个不幸的局限性，它不会影响真正的浏览器，所以在本章中，试着假装它不存在。尽管有全局解释器锁，我们仍然需要锁。每个Python线程都可以在字节码操作之间进行转换，因此您仍然可以获得对共享变量的并发访问，竞争条件仍然是可能的。事实上，在调试本章的代码时，当我忘记添加锁时，我经常遇到这种竞争条件；尝试从浏览器中移除一些锁，以便自己查看！</p><p>  Threads can also be used to add browser multitasking. For example, in Chapter 10 weimplemented the  XMLHttpRequest class, which lets scriptsmake requests to the server. But in our implementation, the wholebrowser would seize up while waiting for the request to finish. That’sobviously bad.  For thisreason, the synchronous version of the API that we implemented inChapter 10 is not very useful and a huge performance footgun. Somebrowsers are now moving to deprecate synchronous XMLHttpRequest.</p><p>线程还可以用于添加浏览器多任务处理。例如，在第10章中，我们实现了XMLHttpRequest类，它允许脚本向服务器发出请求。但在我们的实现中，整个浏览器会在等待请求完成时阻塞。那太糟糕了。因此，我们在第10章中实现的API的同步版本不是很有用，而且性能也很高。一些浏览器现在开始反对同步XMLHttpRequest。</p><p>   creates a new thread that runs the  callback function.Importantly, this code returns right away, and  callbackruns in parallel with any other code. We’ll implement asynchronous XMLHttpRequest calls using threads. Specifically, we’llhave the browser start a thread, do the request and parse the responseon that thread, and then schedule a  Task to send theresponse back to the script.</p><p>创建一个运行回调函数的新线程。重要的是，此代码立即返回，回调与任何其他代码并行运行。我们将使用线程实现异步XMLHttpRequest调用。具体来说，我们将让浏览器启动一个线程，对该线程执行请求并解析响应，然后安排一个任务将响应发送回脚本。</p><p> Like with  setTimeout, we’ll store the callback on theJavaScript side and refer to it with a handle:</p><p>与setTimeout一样，我们将回调存储在JavaScript端，并用句柄引用它：</p><p>  When a script calls the  open method on an XMLHttpRequest object, we’ll now allow the is_async flag to be true:  In browsers, the default for  is_async is true, which the code below does notimplement.</p><p>当脚本在XMLHttpRequest对象上调用open方法时，我们现在允许is_async标志为true：在浏览器中，is_async的默认值为true，下面的代码没有实现。</p><p> XMLHttpRequest . prototype . open  =  function(method , url , is_async) {    this . is_async  = is_async    this . method  = method ;    this . url  = url ;  }</p><p>XMLHttpRequest。原型open=function（method，url，is_async）{this.is_async=is_async this.method=method；this.url=url；}</p><p>   On the browser side, the  XMLHttpRequest_send handlerwill have three parts. The first part will resolve the URL and dosecurity checks:</p><p>在浏览器端，XMLHttpRequest_send Handler将由三部分组成。第一部分将解析URL和dosecurity检查：</p><p> class JSContext:    def XMLHttpRequest_send( self, method, url, body, isasync, handle):   full_url  = resolve_url(url,  self.tab.url)    if  not  self.tab.allowed_request(full_url):    raise  Exception( &#34;Cross-origin XHR blocked by CSP&#34;)    if url_origin(full_url)  != url_origin( self.tab.url):    raise  Exception(    &#34;Cross-origin XHR request not allowed&#34;)</p><p>类JSContext:def XMLHttpRequest_send（self、方法、url、body、isasync、handle）：如果不是self，则full_url=resolve_url（url、self.tab.url）。标签。允许的请求（完整url）：引发异常（&#34；跨源XHR被CSP阻止&#34；）如果url_来源（完整url）！=url_origin（self.tab.url）：引发异常（&#34；不允许跨源XHR请求&#34；）</p><p> Then, we’ll define a function that makes the request and enqueues atask for running callbacks:</p><p>然后，我们将定义一个函数，使请求和队列成为用于运行回调的任务：</p><p> class JSContext:    def XMLHttpRequest_send( self, method, url, body, isasync, handle):    # ...    def run_load():   headers, response  = request(   full_url,  self.tab.url, payload =body)   task  = Task( self.dispatch_xhr_onload, response, handle)    self.tab.task_runner.schedule_task(task)    if  not isasync:    return response</p><p>类JSContext:def XMLHttpRequest_send（self、方法、url、body、isasync、handle）：#。。。def run_load（）：标题，响应=请求（完整url，self.tab.url，有效负载=正文）任务=任务（self.dispatch_xhr_onload，响应，句柄）self。标签。任务跑者。计划任务（任务）如果不是isasync：返回响应</p><p>  Finally, depending on the  is_async flag the browser willeither call this function right away, or in a new thread:</p><p>最后，根据is_async标志，浏览器将立即调用此函数，或在新线程中调用：</p><p> class JSContext:    def XMLHttpRequest_send( self, method, url, body, isasync, handle):    # ...    if  not isasync:    return run_load()    else:   threading.Thread(target =run_load).start()</p><p>类JSContext:def XMLHttpRequest_send（self、方法、url、body、isasync、handle）：#。。。如果不是isasync：返回run_load（），否则：线程。线程（目标=运行\加载）。开始（）</p><p> Note that in the async case, the  XMLHttpRequest_sendmethod starts a thread and then immediately returns. That thread willrun in parallel to the browser’s main work until the request isdone.</p><p>注意，在异步情况下，XMLHttpRequest_sendmethod启动一个线程，然后立即返回。该线程将与浏览器的主要工作并行运行，直到请求结束。</p><p>  XHR_ONLOAD_CODE  =  &#34;__runXHROnload(dukpy.out, dukpy.handle)&#34;     class JSContext:    def dispatch_xhr_onload( self, out, handle):   do_default  =  self.interp.evaljs(   XHR_ONLOAD_CODE, out =out, handle =handle)</p><p>XHR_ONLOAD_CODE=&#34__runXHROnload（dukpy.out，dukpy.handle）和#34；类JSContext:def dispatch_xhr_onload（self、out、handle）：do_default=self。interp。evaljs（XHR_ONLOAD_代码，out=out，handle=handle）</p><p>  function  __runXHROnload(body , handle) {    var obj  = XHR_REQUESTS[handle] ;    var evt  =  new  Event( &#39;load&#39;) ;   obj . responseText  = body ;    if (obj . onload)   obj . onload(evt) ;  }</p><p>函数#u runXHROnload（body，handle）{var obj=XHR_REQUESTS[handle]；var evt=new Event（&#39；load&#39；）；obj。responseText=身体；如果（obj.onload）obj。加载（evt）；}</p><p> As you can see, tasks allow not only the browser but alsoapplications running in the browser to delay tasks until later.</p><p>如您所见，任务不仅允许浏览器，还允许浏览器中运行的应用程序将任务延迟到以后。</p><p> XMLHttpRequest played a key role in helping the webevolve. In the 90s, clicking on a link or submitting a form requiredloading a new pages. With  XMLHttpRequest web pages wereable to act a whole lot more like a dynamic application; GMail was onefamous early example.  GMail dates from April 2004,  soonafter enough browsers finished adding support for the API. The firstapplication to use  XMLHttpRequest was  Outlook WebAccess, in 1999, but it took a while for the API to make it intoother browsers. Nowadays, a web application that uses DOMmutations instead of page loads to update its state is called a  single-pageapp. Single-page apps enabled more interactive and complex web apps,which in turn made browser speed and responsiveness more important.</p><p>XMLHttpRequest在帮助Web发展方面发挥了关键作用。在90年代，点击一个链接或提交一个表格需要加载一个新页面。有了XMLHttpRequest，网页的行为就更像一个动态应用程序；GMail是早期一个著名的例子。GMail可以追溯到2004年4月，在足够多的浏览器完成添加对API的支持后不久。1999年，第一个使用XMLHttpRequest的应用程序是Outlook WebAccess，但API花了一段时间才进入其他浏览器。如今，一个使用DOMS而不是页面加载来更新其状态的web应用程序被称为单页面应用程序。单页应用程序实现了更具交互性和复杂性的web应用程序，这反过来又使浏览器的速度和响应能力变得更加重要。</p><p>  There’s more to tasks than just implementing some JavaScript APIs.Once something is a  Task, the task runner controls when itruns: perhaps now, perhaps later, or maybe at most once a second, oreven at different rates for active and inactive pages, or according toits priority. A browser could even have multiple task runners, optimizedfor different use cases.</p><p>任务不仅仅是实现一些JavaScript API。一旦某件事成为一项任务，任务运行者就可以控制它运行的时间：可能是现在，可能是以后，或者最多每秒一次，或者甚至是以不同的速率运行活动页面和非活动页面，或者根据其优先级。浏览器甚至可以有多个任务运行程序，针对不同的用例进行优化。</p><p> Now, it might be hard to see how the browser can prioritize whichJavaScript callback to run, or why it might want to execute JavaScripttasks at a fixed cadence. But besides JavaScript the browser also has torender the page, and as you may recall from  Chapter 2, we’d like the browser torender the page exactly as fast as the display hardware can refresh. Onmost computers, this is 60 times per second, or 16ms per frame.</p><p>现在，浏览器可能很难确定运行哪个JavaScript回调的优先级，或者为什么它可能希望以固定的节奏执行JavaScripttasks。但是除了JavaScript之外，浏览器还必须读取页面，正如您在第2章中所回忆的，我们希望浏览器能够以显示硬件刷新的速度读取页面。在大多数计算机上，这是每秒60次，或每帧16毫秒。</p><p> Let’s establish 16ms our ideal refresh rate:  16 milliseconds isn’t thatprecise, since it’s 60 times 16.66666…ms that is just about equal to 1second. But it’s a toy browser!</p><p>让我们建立16ms我们的理想刷新率：16毫秒不是那么精确，因为它是16.66666…ms的60倍，大约等于1秒。但它是一个玩具浏览器！</p><p>  Now, there’s some complexity here, because we have multiple tabs. Wedon’t need  each tab redrawing itself every 16ms, because theuser only sees one tab at a time. We just need the  active tabredrawing itself. Therefore, it’s the  Browser that shouldcontrol when we update the display, not individual Tabs.</p><p>现在，这里有一些复杂性，因为我们有多个标签。我们不需要每16毫秒重新绘制一个标签，因为用户一次只能看到一个标签。我们只需要重新绘制活动选项卡本身。因此，应该由浏览器来控制何时更新显示，而不是单个选项卡。</p><p> Let’s make that happen. First, let’s write a schedule_animation_frame method  It’s called an “animationframe” because sequential rendering of different pixels is an animation,and each time you render it’s one “frame”—like a drawing in a pictureframe. on  Browser that schedules a render task to run the  Tab half of therendering pipeline:</p><p>让我们实现这一点。首先，让我们编写一个schedule_animation_frame方法，它被称为“animationframe”，因为不同像素的顺序渲染是一个动画，每次渲染它都是一个“帧”——就像pictureframe中的一幅画。在计划渲染任务以运行渲染管道一半选项卡的浏览器上：</p><p> class Browser:    def schedule_animation_frame( self):    def callback():   active_tab  =  self.tabs[ self.active_tab]   task  = Task(active_tab.render)   active_tab.task_runner.schedule_task(task)   threading.Timer(REFRESH_RATE_SEC, callback).start()</p><p>类浏览器：def schedule_animation_frame（self）：def callback（）：active_tab=self。tabs[self.active_tab]task=task（active_tab.render）active_tab。任务跑者。计划_任务（任务）线程。计时器（刷新速率秒，回调）。开始（）</p><p> Note how every time a frame is scheduled, we set up a timer toschedule the next one. We can kick off the process when we start theBrowser:</p><p>请注意，每次安排一帧时，我们都会设置一个计时器来安排下一帧。我们可以在启动浏览器时启动该过程：</p><p>  Next, let’s put the rastering and drawing tasks that the Browser does into their own method:</p><p>接下来，让我们将浏览器执行的光栅和绘图任务放入它们自己的方法中：</p><p>  In the top-level loop, after running a task on the active tab thebrowser will need to raster-and-draw, in case that task was a renderingtask:</p><p>在顶层循环中，在活动选项卡上运行任务后，浏览器将需要光栅和绘制，如果该任务是渲染任务：</p><p>  Now we’re scheduling a new rendering task every 16 milliseconds, justas we wanted to.</p><p>现在我们正计划每16毫秒执行一次新的渲染任务，正如我们所希望的那样。</p><p> There’s nothing special about 60 frames per second. Some displaysrefresh 72 times per second, and displays that  refresheven more often are becoming more common. Movies are often shot in24 frames per second (though  somedirectors advocate 48) while television shows traditionally use 30frames per second. Consistency is often more important than the actualframe rate: a consistant 24 frames per second can look a lot smootherthan a varying framerate between 60 and 24.</p><p>每秒60帧没有什么特别的。有些显示器每秒刷新72次，刷新频率更高的显示器越来越常见。电影通常以每秒24帧的速度拍摄（尽管一些导演提倡48帧），而电视节目通常以每秒30帧的速度拍摄。一致性通常比实际帧速率更重要：一致的每秒24帧比在60到24帧之间变化的帧速率看起来更平滑。</p><p>  If you run this on your computer, there’s a good chance your CPUusage will spike and your batteries will start draining. That’s becausewe’re calling  render every frame, which means our browseris now constantly styling elements, building layout trees, and paintingdisplay lists. Most of that work is wasted, because on most frames, theweb page will not have changed at all, so the old styles, layout trees,and display lists would have worked just as well as the new ones.</p><p>如果你在你的电脑上运行这个程序，你的CPU很有可能会出现峰值，电池也会开始耗尽。这是因为我们正在调用render every frame，这意味着我们的浏览器现在不断地为元素设计样式、构建布局树和绘制显示列表。大部分工作都被浪费了，因为在大多数框架上，网页根本不会改变，所以旧的样式、布局树和显示列表会和新的一样工作。</p><p> Let’s fix this using a  dirty bit, a piece of state thattells us if some complex data structure is up to date. Since we want toknow if we need to run  render, let’s call our dirty bit needs_render:</p><p>让我们用一个脏点来解决这个问题，这个状态告诉我们一些复杂的数据结构是否是最新的。既然我们想知道是否需要运行render，我们就把脏的部分称为needs_render：</p><p> class Tab:    def  __init__( self, browser):    # ...    self.needs_render  =  False      def set_needs_render( self):    self.needs_render  =  True      def render( self):    if  not  self.needs_render:  return    # ...    self.needs_render  =  False</p><p>类选项卡：def _uinit________________。。。自己needs_render=False def set_needs_render（self）：self。需要_render=True def render（self）：如果不是self。需要渲染：返回#。。。自己需要_render=False</p><p> One advantage of this flag is that we can now set needs_render when the HTML has changed instead of calling render directly. The  render will still happen,but later. This makes scripts faster, especially if they modify the pagemultiple times. Make this change in  innerHTML_set, load,  click, and  keypress. Forexample, in  load, do this:</p><p>这个标志的一个优点是，我们现在可以在HTML发生更改时设置Requireds_render，而不是直接调用render。渲染仍将进行，但将在稍后进行。这使得脚本速度更快，尤其是当脚本多次修改页面时。在innerHTML_集合、加载、单击和按键中进行此更改。例如，在load中，执行以下操作：</p><p>     Another problem with our implementation is that the browser is nowdoing  raster_and_draw every time the active tab runs atask. But sometimes that task is just running JavaScript that doesn’ttouch the web page, and the  raster_and_draw call is awaste.</p><p>我们的实现中的另一个问题是，浏览器现在在每次活动选项卡运行atask时都会进行光栅_和_绘制。但有时，该任务只是运行JavaScript，而JavaScript不会触及网页，raster_和_draw调用是awaste。</p><p> We can avoid this using another dirty bit, which I’ll call needs_raster_and_draw:  The  needs_raster_and_draw dirty bit doesn’tjust make the browser a bit more efficient. Later in this chapter, we’lladd multiple browser threads, and at that point this dirty bit isnecessary to avoid erratic behavior when animating. Try removing itlater and see for yourself!</p><p>我们可以使用另一个脏位来避免这种情况，我将其称为“需要”“光栅”“和”“绘制脏位”：需要”“光栅”“和”“绘制脏位并不会让浏览器更高效。在本章的后面，我们将添加多个浏览器线程，在这一点上，这个脏的部分是必要的，以避免动画时的不稳定行为。试着把它移到水里，自己看看！</p><p> class Browser:    def  __init__( self):    self.needs_raster_and_draw  =  False      def set_needs_raster_and_draw( self):    self.needs_raster_and_draw  =  True      def raster_and_draw( self):    if  not  self.needs_raster_and_draw:  return    # ...    self.needs_raster_and_draw  =  False</p><p>类浏览器：def____;init（self）：self。needs_raster_and_draw=False def set_needs_raster_and_draw（self）：self。需要_光栅_和_绘图=真实的定义光栅_和_绘图（self）：如果不是self。需要_光栅_和_绘制：返回#。。。自己需要光栅和画图=假</p><p> We will need to call  set_needs_raster_and_draw everytime either the  Browser changes something about the browserchrome, or any time the  Tab changes its rendering. Thebrowser chrome is changed by event handlers:</p><p>每次浏览器更改浏览器浏览器的某些内容，或者选项卡更改其渲染时，我们都需要调用set_needs_raster_和_draw。浏览器chrome由事件处理程序更改：</p><p> class Browser:    def handle_click( self, e):    if e.y  &lt; CHROME_PX:    # ...    self.set_needs_raster_and_draw()      def handle_key( self, char):    if  self.focus  ==  &#34;address bar&#34;:    # ...    self.set_needs_raster_and_draw()      def handle_enter( self):    if  self.focus  ==  &#34;address bar&#34;:    # ...    self.set_needs_raster_and_draw()</p><p>类浏览器：def handle_click（self，e）：如果e.y&lt；CHROME_PX:#。。。自己set_needs_raster_and_draw（）def handle_key（self，char）：如果self。焦点==&#34；地址栏&#34；：#。。。自己set_needs_raster_and_draw（）def handle_enter（self）：如果self。焦点==&#34；地址栏&#34；：#。。。自己设置需要光栅和绘图（）</p><p>  class Tab:    def  __init__( self, browser):    # ...    self.browser  = browser       def render( self):    # ...    self.browser.set_needs_raster_and_draw()</p><p>类选项卡：def _uinit________________。。。自己browser=浏览器def render（self）：#。。。自己浏览器设置需要光栅和绘图（）</p><p>   Now the rendering pipeline is only run if necessary, and the browsershould have acceptable performance again.</p><p>现在，渲染管道仅在必要时运行，浏览器应该再次具有可接受的性能。</p><p> It was not until the second decade of the 2000s that all modernbrowsers finished adopting a scheduled, task-based approach torendering. Once the need became apparent due to the emergence of complexinteractive web applications, it still took years of effort to safelyrefa</p><p>直到21世纪的第二个十年，所有的现代研究者都完成了采用一种有计划的、基于任务的研究方法。随着复杂的交互式web应用程序的出现，这种需求变得明显，但安全性仍然需要多年的努力</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/浏览器/">#浏览器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/browser/">#browser</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>