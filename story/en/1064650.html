<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为JavaScript实现私有字段 -  Mozilla Implementing Private Fields for JavaScript – Mozilla</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Implementing Private Fields for JavaScript – Mozilla<br/>为JavaScript实现私有字段 -  Mozilla </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-10 03:49:27</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/f1a1c1ba48af768cd873f209c55bdff6.png"><img src="http://img2.diglog.com/img/2021/6/f1a1c1ba48af768cd873f209c55bdff6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>When implementing a language feature for JavaScript, an implementer must make decisions about how the language in the specification maps to the implementation. Sometimes this is fairly simple, where the specification and implementation can share much of the same terminology and algorithms. Other times, pressures in the implementation make it more challenging, requiring or pressuring the implementation strategy diverge to diverge from the language specification.</p><p>在实现JavaScript的语言功能时，实施者必须决定规范中的语言如何映射到实现。有时这相当简单，规范和实现可以分享大部分相同的术语和算法。其他时间，实施中的压力使得它更具挑战性，需要或迫使实施策略分歧与语言规范不同。</p><p> Private fields is an example of where the specification language and implementation reality diverge, at least in  SpiderMonkey– the JavaScript engine which powers Firefox. To understand more, I’ll explain what private fields are, a couple of models for thinking about them, and explain why our implementation diverges from the specification language.</p><p> 私有字段是规范语言和实现现实分歧的示例，至少在SpiderMoNkey- Powers Firefox的JavaScript引擎。要了解更多，我将解释一下私有字段，这是一个用于思考它们的模型，并解释为什么我们的实现从规范语言发出。</p><p>  Private fields are a language feature being added to the JavaScript language through the  TC39  proposal process, as part of the  class fields proposal, which is at Stage 4 in the TC39 process. We will ship private fields and private methods in Firefox 90.</p><p>  私有字段是通过TC39提议进程添加到JavaScript语言的语言功能，作为类字段的一部分，其在TC39过程中的阶段4。我们将在Firefox 90中运送私人字段和私人方法。</p><p> The private fields proposal adds a strict notion of ‘private state’ to the language. In the following example,  #x may only be accessed by instances of class  A:</p><p> 私有字段提议对语言的“私有状态”的严格概念增加了严格的概念。在以下示例中，#x只能由A类的实例访问：</p><p>  This means that outside of the class, it is impossible to access that field. Unlike public fields for example, as the following example shows:</p><p>  这意味着在类之外，无法访问该字段。例如，与公共字段不同，如以下示例显示：</p><p> class A { #x = 10; // Private field y = 12; // Public Field}var a = new A();a.y; // Accessing public field y: OKa.#x; // Syntax error: reference to undeclared private field</p><p> A类{#X = 10; //私人字段Y = 12; //公共字段} var a = new a（）; a.y; //访问公共字段Y：OKA。＃x; //语法错误：引用undeclared私有字段</p><p> Even various other tools that JavaScript gives you for interrogating objects are prevented from accessing private fields (e.g.  Object.getOwnProperty{Symbols,Names} don’t list private fields; there’s no way to use  Reflect.get to access them).</p><p> 甚至可以阻止JavaScript为您提供询问对象的各种其他工具访问私人字段（例如，object.getownProperty {符号，名称}不列出私人字段;没有办法使用reflect.get访问它们）。 </p><p>  When talking about a feature in JavaScript, there are often three different aspects in play: the mental model, the specification, and the implementation.</p><p>在谈论JavaScript中的功能时，播放中通常有三个不同的方面：心理模型，规范和实现。</p><p> The mental model provides the high-level thinking that we expect programmers to use mostly. The specification in turn provides the detail of the semantics required by the feature. The implementation can look wildly different from the specification text, so long as the specification semantics are maintained.</p><p> 心理模型提供了高级思维，我们希望程序员主要使用。该规范依次提供特征所需的语义的详细信息。只要维持规范语义即可，实现就会看起来与规范文本不同。</p><p> These three aspects shouldn’t produce different results for people reasoning through things (though, sometimes a ‘mental model’ is shorthand, and doesn’t accurately capture semantics in edge case scenarios).</p><p> 这三个方面不应该对人们推理的不同结果（尽管，有时，“心理模型”是简写的，并且在边缘案例场景中没有准确地捕获语义）。</p><p>   The most basic mental model one can have for private fields is what it says on the tin:  fields, but private. Now, JS fields become properties on objects, so the mental model is perhaps ‘properties that can’t be accessed from outside the class’.</p><p>   最基本的心理模型可以为私人领域拥有，是它在TIN：字段中所说的，但私有。现在，JS字段成为对象的属性，因此心理模型可能是无法从类外部访问的属性。</p><p> However, when we encounter proxies, this mental model breaks down a bit; trying to specify the semantics for ‘hidden properties’ and proxies  is challenging (what happens when a Proxy is trying to provide access control to properties, if you aren’t supposed to be able see private fields with Proxies? Can subclasses access private fields? Do private fields participate in prototype inheritance?) . In order to preserve the desired privacy properties an alternative mental model became the way the committee thinks about private fields.</p><p> 但是，当我们遇到代理时，这种心理模型会稍微崩溃;尝试指定“隐藏属性”和代理的语义是具有挑战性的（当您尝试为属性提供访问控制时会发生什么，如果您不应该看到具有代理的私人字段？可以子类访问私人字段吗？私人字段是否参与原型继承？）。为了保留所需的隐私权，替代的精神模型成为委员会对私人领域的看法。</p><p> This alternative model is called the ‘WeakMap’ model. In this mental model you imagine that each class has a hidden weak map associated with each private field, such that you could hypothetically  ‘desugar’</p><p> 该替代模型称为“弱势地图”模型。在这个心理模型中，你想象每个班级都有一个隐藏的弱点地图与每个私人领域相关联，这样你就可以假设'desugar'</p><p>   class A_desugared { static InaccessibleWeakMap_x = new WeakMap(); constructor() { A_desugared.InaccessibleWeakMap_x.set(this, 15); } g() { return A_desugared.InaccessibleWeakMap_x.get(this); }}</p><p>   class a_desugared {static inaccessibleweakmap_x = new devemap（）;构造函数（）{a_desugared.inaccessibleweakmap_x.set（此，15）; } g（）{return a_desugared.inaccessibleweakmap_x.get（这）; }} </p><p> The  WeakMap model is, surprisingly, not how the feature is written in the specification, but is an important part of the design intention is behind them. I will cover a bit later how this mental model shows up in places later.</p><p>令人惊讶的是，弱势模型不是如何在规范中编写的功能，而是设计意图的重要组成部分。我会稍后介绍这个心理模型在后面的地方出现。</p><p>  The actual specification changes are provided by the  class fields proposal, specifically the  changes to the specification text. I won’t cover every piece of this specification text, but I’ll call out specific aspects to help elucidate the differences between specification text and implementation.</p><p>  实际规范更改由类字段提案提供，特别是调整文本的更改。我不会涵盖每一块规范文本，但我会呼吁特定方面来帮助阐明规范文本和实施之间的差异。</p><p> First, the specification adds the notion of   [[PrivateName]], which is a globally unique field identifier. This global uniqueness is to ensure that two classes cannot access each other’s fields merely by having the same name.</p><p> 首先，规范添加了[[privateName]]的概念，它是全局唯一的字段标识符。这种全局唯一性是确保通过具有相同名称，确保两个类无法仅访问彼此的字段。</p><p> function createClass() { return class { #x = 1; static getX(o) { return o.#x; } };}let [A, B] = [0, 1].map(createClass);let a = new A();let b = new B();A.getX(a); // Allowed: Same classA.getX(b); // Type Error, because different class.</p><p> function createClass（）{return类{#x = 1;静态getx（o）{返回o。＃x; }};} Let [A，B] = [0,1] .map（CreateClass）;让= new a（）;设b = new b（）; a.getx（a）; //允许：相同的classa.getx（b）; //类型错误，因为不同的类。</p><p> The specification also adds a new  ‘internal slot’, which is a specification level piece of internal state associated with an object in the spec, called   [[PrivateFieldValues]] to all objects.  [[PrivateFieldValues]] is a list of records of the form:</p><p> 该规范还添加了一个新的“内插槽”，它是与SPEG中的对象相关联的规范级别的内部状态，称为[privateFieldValues]]到所有对象。 [[PrivateFieldValues]]是表单的记录列表：</p><p>    These algorithms largely work as you would expect:  PrivateFieldAdd appends an entry to the list (though, in the interest of trying to provide errors eagerly, if a matching Private Name already exists in the list, it will throw a  TypeError. I’ll show how that can happen later).  PrivateFieldGet retrieves a value stored in the list, keyed by a given Private name, etc.</p><p>    这些算法在很大程度上工作，就像你期望的那样：privateFieldAdd将一个条目附加到列表（尽管如此，如果在列表中存在匹配的私有名称，则尝试急切地提供错误，但它将抛出TypeError。我会展示那可以发生如何发生）。 PrivateFieldGet检索存储在列表中的值，由给定的私有名称等键入。</p><p>  When I first started to read the specification, I was surprised to see that  PrivateFieldAdd could throw. Given that it was only called from a constructor on the object being constructed, I had fully expected that the object would be freshly created, and therefore you’d not need to worry about a field already being there.</p><p>  当我第一次开始阅读规范时，我惊讶地看到PrivateFieldAdd可以抛出。鉴于它仅从构造的对象上的构造函数调用，我完全预计该对象将是新创建的，因此您不需要担心已经存在的领域。 </p><p> This turns out to be possible,  a side effect of some of the specification’s handling of constructor return values. To be more concrete, the following is an example provided to me by André Bargull, which shows this in action.</p><p>这结果是可能的，一些规范的构造函数返回值的副作用。更具体地，以下是AndréBargull提供给我的一个例子，它在行动中表明了这一点。</p><p> class Base { constructor(o) { return o; // Note: We are returning the argument! }}class Stamper extends Base { #x = &#34;stamped&#34;; static getX(o) { return o.#x; }}</p><p> 类基础{构造函数（o）{return o; //注意：我们正在返回争论！ }}类压模延伸基础{#x =＆＃34;盖章＆＃34 ;;静态getx（o）{返回o。＃x; }}</p><p> Stamper is a class which can ‘stamp’ its private field onto any object:</p><p> Stamper是一个可以在任何对象上'邮戳'私有字段的类：</p><p> let obj = {};new Stamper(obj); // obj now has private field #xStamper.getX(obj); // =&gt; &#34;stamped&#34;</p><p> 让obj = {};新的压模（obj）; // obj现在有私有字段＃xstamper.getx（obj）; // =＆gt; ＆＃34;盖章＆＃34;</p><p> This means that when we add private fields to an object we cannot assume it doesn’t have them already. This is where the pre-existence check in  PrivateFieldAdd comes into play:</p><p> 这意味着当我们向一个对象添加私人字段时，我们无法假设它没有它们已经存在。这是PrivateFieldAdd中存在的预存检查中的位置：</p><p> let obj2 = {};new Stamper(obj2);new Stamper(obj2); // Throws &#39;TypeError&#39; due to pre-existence of private field</p><p> 让obj2 = {};新的压模（obj2）;新的压模（obj2）; //抛出＆＃39; typeerror＆＃39;由于私人领域的预先存在</p><p> This ability to stamp private fields into arbitrary objects interacts with the WeakMap model a bit here as well. For example, given that you can stamp private fields onto any object, that means you could also stamp a private field onto a sealed object:</p><p> 这种将私有字段列入任意物体的能力与此处的弱势模型相互作用。例如，鉴于您可以将私有字段标记到任何对象上，这意味着您也可以将私有字段标记到密封对象上： </p><p>  If you imagine private fields as properties, this is uncomfortable, because it means you’re modifying an object that was sealed by a programmer to future modification. However, using the weak map model, it is totally acceptable, as you’re only using the sealed object as a key in the weak map.</p><p>如果将私有字段视为属性，则这是不舒服的，因为它意味着您可以修改由程序员密封的对象，以便将来修改密封。但是，使用弱图模型，它是完全可以接受的，因为您只使用密封对象作为弱图中的键。</p><p> PS: Just because you  can stamp private fields into arbitrary objects, doesn’t mean you  should: Please don’t do this.</p><p> PS：只是因为你可以将私有字段映射到任意对象中，并不意味着你应该：请不要这样做。</p><p>  When faced with implementing the specification, there is a tension between following the letter of the specification, and doing something different to improve the implementation on some dimension.</p><p>  当面对实施规范时，在规范的字母之间存在紧张，并在某些维度上做出不同的事情以改善实现。</p><p> Where it is possible to implement the steps of the specification directly, we prefer to do that, as it makes maintenance of features easier as specification changes are made. SpiderMonkey does this in many places. You will see sections of code that are transcriptions of specification algorithms,  with step  numbers for comments. Following the exact letter of the specification can also be helpful where the specification is highly complex and small divergences can lead to compatibility risks.</p><p> 在可以直接实现规范的步骤的情况下，我们更愿意这样做，因为它使特征的维护更容易，因为规范变化更改。 Spidermonkey在很多地方做到这一点。您将看到代码的代码部分，这些代码是规范算法的转录，具有评论的步骤编号。在规范的确切字母之后，在规范高度复杂并且小的分歧可能导致兼容性风险的情况下，也有助于。</p><p> Sometimes however, there are good reasons to diverge from the specification language. JavaScript implementations have been honed for high performance for years, and there are many implementation tricks that have been applied to make that happen. Sometimes recasting a part of the specification in terms of code already written is the right thing to do, because that means the new code is also able to have the performance characteristics of the already written code.</p><p> 然而，有时，有很好的理由从规范语言中分歧。 JavaScript实现已经磨练了几年的高性能，并且有许多实施技巧已应用于发生这种情况。有时在已经写入的代码中重新定位规范的一部分是正确的事情，因为这意味着新代码也能够具有已经写入代码的性能特征。</p><p>  The specification language for Private Names already almost matches the semantics around   Symbols, which already exist in SpiderMonkey. So adding  PrivateNames as a special kind of  Symbol is a fairly easy choice.</p><p>  私有名称的规范语言已经与符号周围的语义相匹配，这些语义已经存在于spidermonkey中。因此，将私有名添加为特殊类型的符号是一个相当简单的选择。</p><p>  Looking at the specification for private fields, the specification implementation would be to add an extra hidden slot to every object in SpiderMonkey, which contains a reference to a list of  {PrivateName, Value} pairs. However, implementing this directly has a number of clear downsides:</p><p>  查看私有字段的规范，规范实现将是向SpiderMoNkey中的每个对象添加额外的隐藏插槽，该对象包含对{privateName，value}对的列表的引用。但是，实现这一点直接有许多清晰的缺点： </p><p> It requires invasive addition of either new bytecodes or complexity to performance sensitive property access paths.</p><p>它需要侵入性添加新的字节码或复杂性对性能敏感的属性访问路径。</p><p> An alternative option is to diverge from the specification language, and implement only the semantics, not the actual specification algorithms. In the majority of cases, you really  can think of private fields as special properties on objects that are hidden from reflection or introspection outside a class.</p><p> 另一种选择是从规范语言分歧，仅实现语义，而不是实际规范算法。在大多数情况下，您真的可以将私有字段视为隐藏在课外反射或内省的物体上的特殊属性。</p><p> If we model private fields as properties, rather than a special side-list that is maintained with an object, we are able to take advantage of the fact that property manipulation is already extremely optimized in a JavaScript engine.</p><p> 如果我们将私有字段塑造为属性，而不是用对象维护的特殊侧面列表，我们能够利用属性操作在JavaScript引擎中非常优化。</p><p> However, properties are subject to reflection. So if we model private fields as object properties, we need to ensure that reflection APIs don’t reveal them, and that you can’t get access to them via Proxies.</p><p> 但是，属性受到反射。因此，如果将私有字段模拟为对象属性，我们需要确保反射API不会显示它们，并且您无法通过代理访问它们。</p><p> In SpiderMonkey, we elected to implement private fields as hidden properties in order to take advantage of all the optimized machinery that already exists for properties in the engine. When I started implementing this feature André Bargull – a SpiderMonkey contributor for many years – actually handed me a series of patches that had a good chunk of the private fields implementation already done, for which I was hugely grateful.</p><p> 在Spidermonkey中，我们选择将私有字段实施为隐藏属性，以便利用引擎中已存在的所有优化机器。当我开始实施这个功能AndréBargull时 - 蜘蛛侠贡献者多年来 - 实际上递给了一系列有很好的私人领域实现的补丁，所以已经完成了，我非常感激。</p><p>     Private fields have slightly different semantics than properties however. They are designed to issue errors on patterns expected to be programming mistakes, rather than silently accepting it. For example:</p><p>     然而，私有字段的语义略有不同。它们旨在为预期编程错误的模式发出错误，而不是默默地接受它。例如：</p><p> Accessing an a property on an object that doesn’t have it returns  undefined. Private fields are specified to throw a  TypeError, as a result of the   PrivateFieldGet algorithm.</p><p> 访问一个属性的对象中没有返回的对象未定义。由于PrivateFieldGet算法，指定私有字段以抛出TypeError。 </p><p> Setting a property on an object that doesn’t have it simply adds the property. Private fields will throw a  TypeError in   PrivateFieldSet.</p><p>在没有具有它的对象上设置属性只是添加属性。私有字段将在PriveyFieldSet中抛出TypeError。</p><p> Adding a private field to an object that already has that field also throws a  TypeError in   PrivateFieldAdd. See “The Constructor Override Trick” above for how this can happen.</p><p> 将私有字段添加到已有该字段的对象也将在PriveyFieldAdd中抛出TypeError。有关如何发生这种情况，请参阅上面的“构造函数覆盖技巧”。</p><p> To handle the different semantics, we modified the bytecode emission for private field accesses. We added a new bytecode op,  CheckPrivateField which verifies an object has the correct state for a given private field. This means throwing an exception if the property is missing or present, as appropriate for Get/Set or Add.  CheckPrivateField is emitted just before using the regular ‘computed property name’ path (the one used for  A[someKey]).</p><p> 要处理不同的语义，我们修改了私人实地访问的字节码发射。我们添加了一个新的字节码op，checkprivatefield，验证对象具有给定私有字段的正确状态。这意味着如果属性丢失或呈现，则抛出异常，适用于获取/设置或添加。在使用常规“计算属性名称”路径之前（用于[某些键]）的路径，请刚刚发出CheckPrivateField。</p><p> CheckPrivateField is designed such that we can easily implement an  inline cache using  CacheIR. Since we are storing private fields as properties, we can use the Shape of an object as a guard, and simply return the appropriate boolean value. The Shape of an object in SpiderMonkey determines what properties it has, and where they are located in the storage for that object. Objects that have the same shape are guaranteed to have the same properties, and it’s a perfect check for an IC for  CheckPrivateField.</p><p> CheckPrivateField是设计，使我们可以使用CacheIR轻松实现内联高速缓存。由于我们将私有字段存储为属性，因此我们可以使用对象的形状作为警卫，并且只需返回适当的布尔值。 spidermonkey中的对象的形状确定它具有哪些属性，并且它们位于该对象的存储器中。保证具有相同形状的对象具有相同的属性，并且对CheckPrivateField的IC完美检查。</p><p> Other modifications we made to make to the engine include omitting private fields from the property enumeration protocol, and allowing the extension of sealed objects if we are adding private field.</p><p> 我们对引擎进行的其他修改包括从属性枚举协议中省略私有字段，并允许如果我们添加私人字段，则允许密封对象的扩展。</p><p>  Proxies presented us a bit of a new challenge. Concretely, using the  Stamper class above, you can add a private field directly to a Proxy:</p><p>  代理给我们呈现了一些新挑战。具体地，使用上面的压模类，您可以直接添加私人字段到代理：</p><p> let obj3 = {};let proxy = new Proxy(obj3, handler);new Stamper(proxy)Stamper.getX(proxy) // =&gt; &#34;stamped&#34;Stamper.getX(obj3) // TypeError, private field is stamped // onto the Proxy Not the target!</p><p> 让obj3 = {};留言=新代理（obj3，处理程序）;新的压模（代理）stamper.getx（代理）// =＆gt; ＆＃34; Stamped＆＃34; stamper.getx（obj3）// typearror，私有字段被冲压//在代理上而不是目标！ </p><p> I definitely found this surprising initially. The reason I found this surprising was I had expected that, like other operations, the addition of a private field would tunnel through the proxy to the target. However, once I was able to internalize the WeakMap mental model, I was able to understand this example much better. The trick is that in the WeakMap model, it is the  Proxy, not the target object, used as the key in the  #x WeakMap.</p><p>我绝对发现了这个令人惊讶的最初。我发现这个令人惊讶的原因是我预期，就像其他操作一样，私有字段的添加将通过代理到目标隧道。但是，一旦我能够内化弱势地区精神模型，我就能更好地理解这个例子。诀窍在于，在弱势模型中，它是代理，而不是目标对象，用作#x弱模型中的键。</p><p> These semantics presented a challenge to our implementation choice to model private fields as hidden properties however, as SpiderMonkey’s Proxies are highly specialized objects that do not have room for arbitrary properties. In order to support this case, we added a new reserved slot for an ‘expando’ object. The expando is an object allocated lazily that acts as the holder for dynamically added properties on the proxy. This pattern is used already for DOM objects, which are typically implemented as C++ objects with no room for extra properties. So if you write  document.foo = &#34;hi&#34;, this allocates an expando object for  document, and puts the  foo property and value in there instead. Returning to private fields, when  #x is accessed on a Proxy, the proxy code knows to go and look in the expando object for that property.</p><p> 这些语义向我们的实施选择提出了一个挑战，以将私有字段模拟为隐藏属性，因为SpiderMoNkey的代理是高度专业化的对象，这些对象没有任意属性的空间。为了支持这种情况，我们为“Expando”对象添加了一个新的保留插槽。扩展是懒惰地分配的对象，其充当持有者，用于在代理上动态地添加属性。此模式已用于DOM对象，通常使用++对象，没有额外属性的空间。所以，如果你写文档.Foo =＆＃34;嗨＆＃34;，这为文档分配了一个拓拓对象，并在那里施加foo属性和值。返回私有字段，当代理上访问#x时，代理代码知道要去查看该属性的Expando对象。</p><p>  Private Fields is an instance of implementing a JavaScript language feature where directly implementing the specification as written would be less performant than re-casting the specification in terms of already optimized engine primitives. Yet, that recasting itself can require some problem solving not present in the specification.</p><p>  私有字段是实现JavaScript语言功能的实例，在那里直接实现所写的规范，而不是在已经优化的发动机基元方面重新施加规范。然而，重铸本身可能需要一些问题不存在于规范中。</p><p> At the end, I am fairly happy with the choices made for our implementation of Private Fields, and am excited to see it finally enter the world!</p><p> 最后，我非常满意对我们实施私人领域的选择，我很高兴看到它最终进入世界！</p><p>  I have to thank, again, André Bargull, who provided the first set of patches and laid down an excellent trail for me to follow. His work made finishing private fields much easier, as he’d already put a lot of thought into decision making.</p><p>  我要再次感谢，andréBargull，谁提供了第一套补丁并为我奠定了一个优秀的小道。他的工作使私人田地更加容易，因为他已经思考了决策。</p><p> Jason Orendorff has been an excellent and patient mentor as I have worked through this implementation, including two separate implementations of the private field bytecode, as well as two separate implementations of proxy support.</p><p> jason orendorff是一位优秀的患者的导师，因为我通过这个实现工作，包括私有字段字节码的两个单独实现，以及两个单独的代理支持实现。</p><p> Thanks to Caroline Cullen, and Iain Ireland for helping to read drafts of this post, and to Steve Fink for fixing many typos.</p><p> 感谢Caroline Cullen，以及Iain爱尔兰帮助阅读这篇文章的草案，并向史蒂夫·芬克修复许多拼写错误。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hacks.mozilla.org/2021/06/implementing-private-fields-for-javascript/">https://hacks.mozilla.org/2021/06/implementing-private-fields-for-javascript/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/private/">#private</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>