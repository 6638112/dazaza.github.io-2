<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>卷积就是花式乘法Convolution Is Fancy Multiplication</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Convolution Is Fancy Multiplication<br/>卷积就是花式乘法</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-24 05:27:13</div><div class="page_narrow text-break page_content"><p>Like making engineering students squirm? Have them explain convolution and (if you&#39;re barbarous) the convolution theorem. They&#39;ll mutter something about sliding windows as they try to escape through one.</p><p>喜欢让工程专业的学生蠕动吗？让他们解释卷积和（如果您是野蛮的）卷积定理。当他们试图通过一个滑动窗口逃脱时，他们会喃喃地谈论滑动窗口。</p><p>       A treatment plan:  [3] Every patient gets 3 units of the cure on their first day.</p><p>       一个治疗计划：[3]每位患者在第一天就会得到3单位的治疗。</p><p> A list of patients:  [1 2 3 4 5] Your patient schedule for the week (1 person Monday, 2 on Tuesday, etc.).</p><p> 患者列表：[1 2 3 4 5]您本周的患者时间表（周一1人，周二2人，等等）。</p><p> Question: How much medicine do you use each day? Well, that&#39;s just a quick multiplication:</p><p> 问题：您每天使用多少药？好吧，那只是一个快速的乘法：</p><p> Plan * Patients = Daily Usage[3] * [1 2 3 4 5] = [3 6 9 12 15]</p><p> 计划*患者=每日使用量[3] * [1 2 3 4 5] = [3 6 9 12 15]</p><p> Multiplying the plan by the patient list gives the usage for the upcoming days:  [3 6 9 12 15]. Everyday multiplication ( 3 x 4) means susing the plan with a single day of patients:  [3] * [4] = [12].</p><p> 将计划乘以患者清单可得出未来几天的使用情况：[3 6 9 12 15]。每天相乘（3 x 4）意味着对一天的患者使用计划：[3] * [4] = [12]。</p><p>  Let&#39;s say the disease mutates and requires a multi-day treatment. You create a new plan:  Plan: [3 2 1]</p><p>  假设该疾病发生变异，需要进行多日治疗。您创建一个新计划：计划：[3 2 1]</p><p> That means 3 units of the cure on the first day, 2 on the second, and 1 on the third. Ok. Given the same patient schedule (  [1 2 3 4 5]), what&#39;s our medicine usage each day?</p><p>这意味着第一天需要3个单位的固化时间，第二天需要2个单位，第三天需要1个单位。好。给定相同的患者时间表（[1 2 3 4 5]），我们每天的药物使用量是多少？</p><p>  On Monday, 1 patient comes in. It&#39;s her first day, so she gets 3 units.</p><p>  星期一，一位病人来了。这是她的第一天，所以她得到了3个病房。</p><p> On Tuesday, the Monday gal gets 2 units (her second day), but two new patients arrive, who get 3 each (2 * 3 = 6). The total is 2 + (2 * 3) = 8 units.</p><p> 在星期二，星期一的gal获得2个单位（她的第二天），但是有两名新患者到达，每人获得3个（2 * 3 = 6）。总计为2 +（2 * 3）= 8个单位。</p><p> On Wednesday, it&#39;s trickier: The Monday gal finishes (1 unit, her last day), the Tuesday people get 2 units (2 * 2), and there are 3 new Wednesday people... argh.</p><p> 在星期三，这比较棘手：星期一gal（她最后一天的1个单位）完工，星期二的人得到2个单位（2 * 2），并且星期三有3个新的人... argh。</p><p> The patients are overlapping and it&#39;s hard to track. How can we organize this calculation?</p><p> 患者重叠，很难追踪。我们如何组织这种计算？</p><p> An idea: imagine  flipping the patient list, so the first patient is on the right:</p><p> 一个想法：想象一下翻转患者列表，那么第一个患者在右边：</p><p>    On your first day, you walk into the first room and get 3 units of medicine. The next day, you want into room #2 and get 2 units. On the last day, you walk into room #3 and get 1 unit. There&#39;s no rooms afterwards, and you&#39;re done.</p><p>    在您的第一天，您走进第一个房间并获得3单位药物。第二天，您要进入2号房间并获得2个单位。在最后一天，您走进3号房并获得1个单元。之后没有房间了，您就完成了。</p><p> To calculate the total medicine usage, line up the patients and walk them through the rooms:</p><p>要计算总的药物使用量，请排队患者并带领他们走入房间：</p><p>  On Monday (our first day), we have a single patient in the first room. She gets 3 units, for a total usage of 3. Makes sense, right?</p><p>  在星期一（我们的第一天），我们的第一个房间只有一名患者。她得到3个单位，总共使用3个。有意义吗？</p><p>  Tuesday ---------------------------- Rooms 3 2 1 Patients -&gt; 5 4 3 2 1 Usage 6 2 = 8</p><p>  星期二----------------------------房间3 2 1患者-> 5 4 3 2 1用法6 2 = 8</p><p> The first patient is now in the second room, and there&#39;s 2 new patients in the first room. We multiply each room&#39;s dose by the patient count, then combine.</p><p> 现在，第一个病人在第二个房间里，第一个房间里有两个新病人。我们将每个房间的剂量乘以患者人数，然后合并。</p><p>  Wednesday ---------------------------- Rooms 3 2 1 Patients -&gt; 5 4 3 2 1 Usage 9 4 1 = 14 Thursday ----------------------------- Rooms 3 2 1 Patients -&gt; 5 4 3 2 1 Usage 12 6 2 = 20 Friday ----------------------------- Rooms 3 2 1 Patients -&gt; 5 4 3 2 1 Usage 15 8 3 = 26</p><p>  星期三----------------------------房间3 2 1患者-> 5 4 3 2 1用法9 4 1 = 14星期四- ---------------------------房间3 2 1患者-> 5 4 3 2 1用法12 6 2 = 20 Friday ---- -------------------------房间3 2 1患者-> 5 4 3 2 1用法15 8 3 = 26</p><p> Whoa! It&#39;s intricate, but we figured it out, right? We can find the usage for any day by reversing the list, sliding it to the desired day, and combining the doses.</p><p> 哇！错综复杂，但我们想通了，对吧？我们可以通过将列表反转，将其滑动到所需的日期并组合剂量来找到任何一天的用法。</p><p> The total day-by-day usage looks like this (don&#39;t forget Sat and Sun, since some patients began on Friday):</p><p> 每天的总使用量如下所示（别忘了Sat和Sun，因为有些病人从星期五开始）：</p><p> Plan * Patient List = Total Daily Usage[3 2 1] * [1 2 3 4 5] = [3 8 14 20 26 14 5] M T W T F M T W T F S S</p><p>计划*患者名单=每日总使用量[3 2 1] * [1 2 3 4 5] = [3 8 14 20 26 14 5] M T W T F F M T W T F S S</p><p> This calculation is the  convolution of the plan and patient list. It&#39;s a fancy multiplication between a set of a numbers and a &#34;program&#34;.</p><p> 此计算是计划和患者清单的卷积。这是一组数字和一个“程序”之间的奇特乘法。</p><p>  Here&#39;s a  live demo. Try changing  F (the plan) or  G (the patient list). The convolution $c(t)$ matches our manual calculation above.</p><p>  这是现场演示。尝试更改F（计划）或G（患者清单）。卷积$ c（t）$与我们上面的手动计算匹配。</p><p> (We define functions $f(x)$ and $g(x)$ to pad each list with zero, and adjust for the list index starting at 1).</p><p> （我们定义函数$ f（x）$和$ g（x）$将每个列表填充为零，并调整从1开始的列表索引）。</p><p>  ListConvolve[{3, 2, 1}, {1, 2, 3, 4, 5}, {1, -1}, 0]{3, 8, 14, 20, 26, 14, 5}</p><p>  ListConvolve [{3，2，1}，{1，2，3，4，5}，{1，-1}，0] {3，8，14，20，26，14，5}</p><p>   I started this article 5 years ago (intuition takes a while...), but unfortunately the analogy is relevant to today.</p><p>   我5年前开始写这篇文章（直觉需要一段时间...），但不幸的是，类比与今天有关。</p><p>  Set $f(x)$ as the percent of patients needing ventilators. For example,  [.05 .03 .01] means 5% of patients need ventilators the first week, 3% the second week, and 1% the third week.</p><p>  将$ f（x）$设置为需要呼吸机的患者百分比。例如，[。05 .03 .01]表示第一周有5％的患者需要呼吸机，第二周需要3％，第三周需要呼吸机1％。</p><p>  The convolution $c(t) = f * g$, shows how many ventilators are needed each week (in thousands). $c(5)$ is how many ventilators are needed 5 weeks from now.</p><p>卷积$ c（t）= f * g $，显示每周需要多少台呼吸机（以千计）。 $ c（5）$是从现在开始的5周内需要多少台呼吸机。</p><p>  G = [10, 20, 30, 20, 10, 10, 10], is the incoming hospitalized patients. It starts at 10k per week, rises to 30k, then decays to 10k.</p><p>  G = [10，20，30，20，10，10，10]，是入院患者。它从每周10k开始，上升到30k，然后下降到10k。</p><p>   The convolution drops to 0 after 9 weeks because the patient list has run out. In this example, we&#39;re interested in the peak value the convolution hits, not the long-term total.</p><p>   9周后卷积下降为0，因为患者名单用完了。在此示例中，我们对卷积达到的峰值感兴趣，而不是长期总计。</p><p> Other plans to convolve may be drug doses, vaccine appointments (one today, another a month from now), reinfections, and other complex interactions.</p><p> 其他可能涉及的计划可能是药物剂量，疫苗预约（今天一次，从现在开始一个月），再感染以及其他复杂的相互作用。</p><p> The hospital analogy is the mental model I wish I had when learning. Now that we&#39;ve tried it with actual numbers, let&#39;s pour in the Math Juice and turn the analogy into calculus.</p><p> 医院类比是我希望在学习时拥有的心理模型。现在我们已经用实际数字进行了尝试，让我们倒入Math Juice，然后将类比转换为微积分。</p><p>  So, what happened in our example? We had a list of patients and a plan. If the plan were simple (single day  [3]), regular multiplication would have worked. Because the plan was complex, we had to &#34;convolve&#34; it.</p><p>  那么，在我们的示例中发生了什么？我们有一个病人清单和一个计划。如果计划很简单（单日[3]），则定期乘法就可以了。因为该计划很复杂，所以我们不得不“卷积”它。</p><p>  Convolution is written $f * g$, with an asterisk. Yes, an asterisk usually indicates multiplciation, but in advanced calculus class, it indicates a convolution. Regular multiplication is just implied ($fg$).</p><p>  卷积记为$ f * g $，并带有星号。是的，星号通常表示复数，但在高级微积分类别中，它表示卷积。只是隐含了常规乘法（$ fg $）。</p><p> The result of a convolution is a new  function that gives the total usage for any day (&#34;What was the total usage on day $t=3$?&#34;). We can graph the convolution over time to see the day-by-day totals.</p><p>卷积的结果是一个新函数，该函数给出了一天的总使用量（“一天$ t = 3 $的总使用量是多少？”）。我们可以绘制随时间变化的卷积，以查看每天的总数。</p><p>   The list of patients (inputs) is $g(x)$. However, we need to  reverse this list as we slide it, so the earliest patient (Monday) enters the hospital first (first in, first out). This means we need to use $g(-x)$, the horizontal reflection of $g(x)$.  [1 2 3 4 5] becomes  [5 4 3 2 1].</p><p>   患者（输入）列表为$ g（x）$。但是，我们在滑动列表时需要反转此列表，以便最早的患者（星期一）首先进入医院（先进先出）。这意味着我们需要使用$ g（-x）$，即$ g（x）$的水平反射。 [1 2 3 4 5]变为[5 4 3 2 1]。</p><p> Now that we have the reversed list, pick a day to compute ($t = 0, 1, 2...$). To slide our patient list by this much, we use: $g(-x + t)$. That is, we reverse the list ($-x$) and jump to the correct day ($+t$).</p><p> 现在我们有了反向列表，选择一天进行计算（$ t = 0，1，2 ... $）。为了使我们的患者列表如此滑动，我们使用：$ g（-x + t）$。也就是说，我们反转列表（$ -x $）并跳转到正确的日期（$ + t $）。</p><p>  $g(-x + t)$ is the list of inputs (flipped and slid to the right day).</p><p>  $ g（-x + t）$是输入清单（翻转并滑动到正确的日期）。</p><p> To get the total usage on day $t$, we multiply each patient with the plan, and sum the results (an integral). To account for any possible length, we go from -infinity to +infinity.</p><p> 为了获得第t天的总使用量，我们将每个患者乘以该计划，然后将结果相加（一个整数）。为了说明任何可能的长度，我们从-infinity到+ infinity。</p><p>     We use a dummy variable $\tau$ (tau) for the intermediate computation. Imagine $\tau$ as knocking on each room ($\tau={0, 1, 2, 3...}$), finding the dosage [$f(\tau)$], the number of patients [$g(t - \tau)$], multiplying them, and totaling things in the integral. Yowza. The so-called &#34;dummy&#34; variable $\tau$ is like  i in a  for loop: it&#39;s temporary, but does the work. (By analogy, $t$ is a global variable has a fixed value during the loop.)</p><p>     我们使用虚拟变量$ \ tau $（tau）进行中间计算。想象$ \ tau $敲每个房间（$ \ tau = {0，1，2，3 ...} $），找到剂量[$ f（\ tau）$]，病人数[$ g （t-\ tau）$]，将它们相乘，然后求和。哇所谓的“虚拟”变量$ \ tau $就像我在for循环中一样：它是临时的，但是可以工作。 （以此类推，$ t $是一个全局变量，在循环期间具有固定值。）</p><p> In the official definition, you&#39;ll see $g(t - \tau)$ instead of $g(- \tau+ t)$. The second version shows the flip ($-\tau$) and slide ($+t$). Writing $g(t - \tau)$ makes it seem like we&#39;re interested in the difference between the variables, which confused me.</p><p> 在正式定义中，您会看到$ g（t-\ tau）$而不是$ g（-\ tau + t）$。第二个版本显示翻转（$-\ tau $）和幻灯片（$ + t $）。写$ g（t-\ tau）$似乎使我们对变量之间的差异感兴趣，这使我感到困惑。</p><p> The treatment plan (program to run) is called the  kernel: you convolve a kernel with an input.</p><p>处理计划（要运行的程序）称为内核：将内核与输入进行卷积。</p><p>   We can&#39;t discover a new math operation without taking it for a spin. Let&#39;s see how it behaves.</p><p>   如果不尝试，便无法发现新的数学运算。让我们看看它的行为。</p><p>  In our computation, we flipped the patient list and kept the plan the same. Could we have flipped the plan instead?</p><p>  在我们的计算中，我们翻转了患者清单，并使计划保持不变。我们可以改写计划吗？</p><p> You bet. Imagine the patients are immobile, and stay in their rooms:  [1 2 3 4 5]. To deliver the medicine, we have 3 medical carts that go to each room and deliver the dose. Each day, they slide forward one position.</p><p> 你打赌想象一下病人是不动的，呆在自己的房间里：[1 2 3 4 5]。为了运送药物，我们有3个医疗推车，可以运送到每个房间并运送剂量。每天，他们向前滑动一个位置。</p><p>  As before, though our plan is written  [3 2 1] (3 units on the first day), we flip the order of the carts to [1 2 3]. That way, a patient gets 3 units on their first day, as we expect. Checking with Wolfram Alpha, the  calculation is the same.</p><p>  和以前一样，尽管我们的计划写为[3 2 1]（第一天为3个单位），但我们将购物车的订单翻转为[1 2 3]。这样，患者就可以像我们期望的那样在第一天获得3个单位。使用Wolfram Alpha进行检查，计算结果相同。</p><p> ListConvolve[{1, 2, 3, 4, 5}, {3, 2, 1}, {1, -1}, 0]{3, 8, 14, 20, 26, 14, 5}</p><p> ListConvolve [{1、2、3、4、5}，{3、2、1}，{1，-1}，0] {3、8、14、20、26、14、5}</p><p>   and we can decide to flip either $f$ or $g$ when calculating the integral. Surprising, right?</p><p>   并且我们可以决定在计算积分时翻转$ f $或$ g $。令人惊讶，对不对？</p><p>  When all treatments are finished, what was the  total medicine usage? This is the  integral of the convolution. (A few minutes ago, that phrase would have you jumping out of a window.)</p><p>完成所有治疗后，总药物用量是多少？这是卷积的一部分。 （几分钟前，该短语会让您跳出窗口。）</p><p> But it&#39;s a simple calculation. Our plan gives each patient  sum([3 2 1]) = 6 units of medicine. And we have  sum([1 2 3 4 5]) = 15 patients. The total usage is just  6 x 15 = 90 units.</p><p> 但这是一个简单的计算。我们的计划为每个患者求和（[3 2 1]）= 6单位药物。我们有sum（[1 2 3 4 5]）= 15位患者。总使用量仅为6 x 15 = 90单位。</p><p> Wow, that was easy: the usage for the  entire convolution is just the product of the subtotals!</p><p> 哇，那很简单：整个卷积的用法只是小计的乘积！</p><p>  I hope this clicks intuitively. Note that this trick works for convolution, but not integrals in general. For example:</p><p>  我希望这会直观地点击。请注意，此技巧适用于卷积，但通常不适用于积分。例如：</p><p>    and those aren&#39;t the same. (Calculus would be much easier if we could split apart integrals like this.) It&#39;s strange, but $\int (f * g)$ is probably simpler to work out than $\int (fg)$.</p><p>    和那些不一样。 （如果我们可以像这样拆分积分，微积分会容易得多。）这很奇怪，但是$ \ int（f * g）$可能比$ \ int（fg）$更容易计算。</p><p>  What happens if we sent a single patient through the hospital? The convolution would just be that day&#39;s plan.</p><p>  如果我们将一名患者送往医院怎么办？卷积只是那一天的计划。</p><p>   In calculus terms, a spike of  [1] (and 0 otherwise) is the  Dirac Delta Function. In terms of convolutions, this function acts like the number 1 and returns the original function:</p><p>   用微积分术语，峰值[1]（否则为0）是狄拉克三角函数。就卷积而言，此函数的作用类似于数字1并返回原始函数：</p><p>  We can delay the delta function by T, which delays the resulting convolution function too. Imagine a patient shows up a week late, so no medicine us used for a week:</p><p>我们可以将增量函数延迟T，这也会延迟结果卷积函数。想象一个病人迟到一周，所以我们一周都没有用药：</p><p>   The  Fourier Transform (written with a fancy $\mathscr{F}$) converts a function $f(t)$ into a list of cyclical ingredients $F(s)$:</p><p>   傅立叶变换（用花哨的$ \ mathscr {F} $编写）将函数$ f（t）$转换为周期性成分$ F（s）$的列表：</p><p>   In our analogy, we convolved the plan and patient list with a fancy multiplication. Since the Fourier Transform gives us lists of ingredients, could we get the same result by mixing the  ingredient lists?</p><p>   以此类推，我们通过花式乘法对计划和患者列表进行卷积。由于傅立叶变换为我们提供了成分列表，因此我们可以通过混合成分列表来获得相同的结果吗？</p><p> Yep, we can:  Fancy multiplication in the regular world is  regular multiplication in the fancy world.</p><p> 是的，我们可以：常规世界中的幻想乘法是幻想世界中的常规乘法。</p><p> In math terms, &#34;Convolution in the time domain is multiplication in the frequency (Fourier) domain.&#34;</p><p> 用数学术语来说，“时域的卷积就是频率（傅立叶）域的乘法”。</p><p>      We can  prove this theorem with advanced calculus, that uses theorems I don&#39;t quite understand, but let&#39;s think through the meaning.</p><p>      我们可以使用高级演算来证明该定理，该演算使用的是我不太了解的定理，但让我们仔细考虑一下它的含义。</p><p> Because $F(s)$ is the Fourier Transform of $f(t)$, we can ask for a specific frequency ($s = 2\text{Hz}$) and get the  combined interaction of every data point with that frequency. Let&#39;s suppose:</p><p> 因为$ F（s）$是$ f（t）$的傅立叶变换，所以我们可以要求一个特定的频率（$ s = 2 \ text {Hz} $）并获得每个数据点与该频率的组合交互作用。让我们假设：</p><p>  That means after every data point has been multiplied against the 2Hz cycle, the result is $3 + i$. But we could have kept each interaction separate:</p><p>这意味着在将每个数据点乘以2Hz周期后，结果为$ 3 + i $。但是我们可以将每种交互方式分开：</p><p>  Where $c_t$ is the contribution to the 2Hz frequency from datapoint $t$. Similarly, we can expand $G(s)$ into a list of interactions with the 2Hz ingredient. Let&#39;s suppose $G(2) = 7 - i$:</p><p>  其中$ c_t $是数据点$ t $对2Hz频率的贡献。同样，我们可以将$ G（s）$扩展为与2Hz成分进行交互的列表。假设$ G（2）= 7-i $：</p><p>    Our convolution in the regular domain involves a lot of cross-multiplications. In the fancy frequency domain, we  still have a bunch of interactions, but $F(s)$ and $G(s)$ have consolidated them. We can just multiply $F(2)G(2) = (3 + i)(7-i)$ to find the 2Hz ingredient in the convolved result.</p><p>    我们在规则域中的卷积涉及很多交叉乘法。在花式频率域中，我们仍然有很多交互，但是$ F（s）$和$ G（s）$已合并它们。我们可以将$ F（2）G（2）=（3 + i）（7-i）$乘以在卷积结果中找到2Hz成分。</p><p>   It&#39;s a lot of work to cross-multiply every term: $(1 \cdot 5) + (1\cdot 6) + (1\cdot 7) + ...$</p><p>   每个术语都需要相乘很多工作：$（1 \ cdot 5）+（1 \ cdot 6）+（1 \ cdot 7）+ ... $</p><p> It&#39;s better to consolidate the groups into $(1 + 2 + 3 + 4) = 10$ and $(5 + 6 + 7 + 8) = 26$, and  then multiply to get $10 \cdot 26 = 260$.</p><p> 最好将组合并为$（1 + 2 + 3 + 4）= 10 $和$（5 + 6 + 7 + 8）= 26 $，然后相乘得到$ 10 \ cdot 26 = 260 $。</p><p> This nuance caused me a lot of confusion. It seems like $FG$ is a single multiplication, while $f * g$ involves a bunch of intermediate terms. I forgot that $F$ already did the work of merging a bunch of entries into a single one.</p><p> 这种细微差别使我感到困惑。好像$ FG $是一个乘法，而$ f * g $涉及许多中间项。我忘记了$ F $已经完成了将一堆条目合并为一个条目的工作。</p><p> Now, we aren&#39;t  quite done. We can convert $f * g$ in the time domain into $FG$ in the frequency domain, but we probably need it back in the time domain for a usable result:</p><p> 现在，我们还没有完成。我们可以将时域中的$ f * g $转换为频域中的$ FG $，但我们可能需要时域中的$ fGg才能获得可用的结果：</p><p>  You have a riddle in English ($f * g$), you translate it to French ($FG$), get your smart French friend to work out that calculation, then convert it back to English ($\mathscr{F}^{-1}$).</p><p>您有一个英文谜语（$ f * g $），将其翻译成法语（$ FG $），找一个聪明的法国朋友算算，然后将其转换回英语（$ \ mathscr {F} ^ {-1} $）。</p><p>     Cool, eh? Instead of multiplying two functions like some cave dweller, put on your monocle, convolve the Fourier Transforms, and and convert to the time domain:</p><p>     酷吧？不用像像洞穴居民那样将两个函数相乘，而是戴上单片眼镜，对傅立叶变换进行卷积，然后转换为时域：</p><p>  I&#39;m not saying this is fun, just that it&#39;s possible. If your French friend has a gnarly calculation they&#39;re struggling with, it might look like arithmetic to you.</p><p>  我并不是说这很有趣，只是有可能。如果您的法国朋友在计算时费力，那对您来说似乎算术。</p><p>  Remember how we said the integral of a convolution was a multiplication of the individual integrals?</p><p>  还记得我们怎么说卷积的积分是单个积分的乘积吗？</p><p>    So (handwaving), it seems we could swap the general-purpose integral $\int$ for $\mathscr{F}$ and get</p><p>    因此，（手动）似乎可以将通用积分$ \ int $交换为$ \ mathscr {F} $并获得</p><p>  which is the convolution theorem. I need a deeper intuition for the  proof, but this helps things click.</p><p>  这就是卷积定理。我需要更深入的直觉来证明，但这可以帮助事情解决。</p><p>  The trick with convolution is finding a useful &#34;program&#34; (kernel) to apply to your input. Here&#39;s a few examples.</p><p>  卷积的窍门是找到一个有用的“程序”（内核）以应用于您的输入。这里有几个例子。</p><p>  Let&#39;s say you want a moving average between neighboring items in a list. That is half of each element, added together:</p><p>假设您要在列表中相邻项目之间移动平均值。这是每个元素的一半，加在一起：</p><p>   ListConvolve[{1, 4, 9, 16, 25}, {0.5, 0.5}, {1, -1}, 0] {0.5, 2.5, 6.5, 12.5, 20.5, 12.5}</p><p>   ListConvolve [{1，4，9，16，25}，{0.5，0.5}，{1，-1}，0] {0.5，2.5，6.5，12.5，20.5，12.5}</p><p>  A 3-element moving average would be  [.33 .33 .33], a weighted average could be  [.5 .25 .25].</p><p>  3个元素的移动平均值为[.33 .33 .33]，加权平均值为[.5 .25 .25]。</p><p>   ListConvolve[{1, 2, 3, 4, 5}, {1, -1}, {1, -1}, 0] {1, 1, 1, 1, 1, -5} // -5 since we ran out of entriesListConvolve[{1, 4, 9, 16, 25}, {1, -1}, {1, -1}, 0] {1, 3, 5, 7, 9, -25} // discrete derivative is 2x + 1</p><p>   ListConvolve [{1，2，3，4，5}，{1，-1}，{1，-1}，0] {1，1，1，1，1，-5} // -5用完条目ListConvolve [{1，4，9，16，25}，{1，-1}，{1，-1}，0] {1，3，5，7，9，-25} //离散导数是2x +1</p><p> With a simple kernel, we can find a useful math property on a discrete list. And to get a second derivative, just apply the derivative convolution twice:</p><p> 使用简单的内核，我们可以在离散列表中找到有用的数学属性。要获得第二个导数，只需对导数卷积应用两次：</p><p>  As a shortcut, we can precompute the final convolutions ( [1 -1] * [1 -1] ) and get:</p><p>  作为快捷方式，我们可以预先计算最终的卷积（[1 -1] * [1 -1]）并得到：</p><p>  Now we have a  single kernel  [1, -2, 1] that gets the second derivative of a list:</p><p>  现在，我们有一个内核[1，-2，1]，它获得列表的二阶导数：</p><p> ListConvolve[{1,4, 9, 16, 25}, {1, -2, 1}, {1, -1}, 0] {1, 2, 2, 2, 2, -34, 25}</p><p>ListConvolve [{1,4,9,16,25}，{1，-2，1}，{1，-1}，0] {1,2,2,2,2，-34,25}</p><p>        Can we undo the blur? Yep! With our friend the Convolution Theorem, we can do:</p><p>        我们可以消除模糊吗？是的和我们的朋友卷积定理一起，我们可以做：</p><p>      Whoa! We can recover the original image by dividing out the blur. Convolution is a simple multiplication in the frequency domain, and  deconvolution is a simple division in the frequency domain.</p><p>      哇！我们可以通过划分模糊来恢复原始图像。卷积在频域中是一个简单的乘法，而反卷积在频域中是一个简单的除法。</p><p>  A short while back, the concept of &#34;deblurring by dividing Fourier Transforms&#34; was gibberish to me. While it can be daunting mathematically, it&#39;s getting simpler conceptually.</p><p>  不久前，“通过划分傅立叶变换进行去模糊”的概念对我来说是胡说八道。尽管它在数学上令人生畏，但从概念上讲它变得越来越简单。</p><p>     1234 = 1000 + 200 + 30 + 4 = [1000 200 30 4]5678 = 5000 + 600 + 70 + 8 = [5000 600 70 8]</p><p>     1234 = 1000 + 200 + 30 + 4 = [1000 200 30 4] 5678 = 5000 + 600 + 70 + 8 = [5000 600 70 8]</p><p> And what is regular, grade-school multiplication? A digit-by-digit convolution! We sweep one list of digits by the other, multiplying and adding as we go:</p><p> 什么是常规的小学乘法？逐位数的卷积！我们将一个数字列表彼此扫一扫，然后进行相乘和相加：</p><p>    ListConvolve[{1000, 200, 30, 4}, {8, 70, 600, 5000}, {1, -1}, 0]{8000, 71600, 614240, 5122132, 1018280, 152400, 20000}sum {8000, 71600, 614240, 5122132, 1018280, 152400, 20000}7006652</p><p>    ListConvolve [{1000，200，30，4}，{8，70，600，5000}，{1，-1}，0] {8000，71600，614240，5122132，1018280，152400，20000}和{8000， 71600、614240、5122132、1018280、152400、20000} 7006652</p><p> Note that we pre-flip one of the lists (it gets swapped in the convolution later), and the intermediate calculations are a bit different. But, combining the subtotals gives the expected result.</p><p>请注意，我们预先翻转了其中一个列表（稍后会在卷积中交换），并且中间计算有些不同。但是，将小计组合起来可以得到预期的结果。</p><p>  Why convolve instead of doing a regular digit-by-digit multiplication? Well, the convolution theorem lets us substitute convolution with Fourier Transforms:</p><p>  为什么要卷积而不是进行常规的逐位乘法？好吧，卷积定理让我们用傅立叶变换代替卷积：</p><p>  The convolution ($f * g$) has complexity $O(n^2)$. We have $n$ positions to process, with $n$ intermediate multiplications at each position.</p><p>  卷积（$ f * g $）具有复杂度$ O（n ^ 2）$。我们有$ n $个头寸需要处理，每个头寸都有$ n $个中间乘法。</p><p>  Two Fourier Transforms, which are normally $O(n^2)$. However, the Fast Fourier Transform (a  divide-and-conquer approach) makes them $O(n\log(n))$.</p><p>  两个傅立叶变换，通常是$ O（n ^ 2）$。但是，快速傅立叶变换（分治法）使它们成为$ O（n \ log（n））$。</p><p> Pointwise multiplication of the final result of the transforms ($\sum a_n \cdot b_n$), which is $O(n)$</p><p> 转换的最终结果（$ \ sum a_n \ cdot b_n $）的逐点乘法，即$ O（n）$</p><p>  Regular multiplication in the fancy domain is  faster than a fancy multiplication in the regular domain. Our French friend is no slouch. ( More)</p><p>  幻想域中的规则乘法比常规域中的幻想乘法快。我们的法国朋友不随便。 （ 更多）</p><p>  Machine learning is about discovering the math functions that transform input data into a desired result (a prediction, classification, etc.).</p><p>  机器学习涉及发现将输入数据转换为所需结果（预测，分类等）的数学函数。</p><p>   Given that convolution can do complex math (moving averages, blurs, derivatives...), it seems  some combination of kernels should turn our input into something useful, right?</p><p>鉴于卷积可以完成复杂的数学运算（移动平均值，模糊，导数...），看来内核的某种组合应该可以将我们的输入变成有用的东西，对吗？</p><p> Convolutional Neural Nets (CNNs) process an input with layers of kernels, optimizing their weights (plans) to reach a goal. Imagine tweaking the treatment plan to keep medicine usage below some threshold.</p><p> 卷积神经网络（CNN）处理带有内核层的输入，优化其权重（计划）以达到目标。想象一下，调整治疗计划以使药物使用量保持在一定阈值以下。</p><p>     Time invariant: Outputs depend on relative time, not absolute time. You get 3 units on  your first day, and it doesn&#39;t matter if it&#39;s Wednesday or Thursday.</p><p>     时间不变：输出取决于相对时间，而不是绝对时间。您在第一天就会获得3个单位，这与星期三或星期四无关。</p><p> A fancy phrase is &#34;A LTI system is characterized by its impulse response&#34;. Translation: If we a  single patient through the hospital  [1], we&#39;ll discover the treatment plan. Then we can predict the usage for  any sequence of patients by convolving it with the plan.</p><p> 一个恰当的说法是“ LTI系统的特点是其脉冲响应”。翻译：如果我们只有一名患者通过医院[1]，我们将发现治疗计划。然后，通过将其与计划进行卷积，可以预测任何患者序列的使用情况。</p><p>  If the system isn&#39;t LTI, we can&#39;t extrapolate based on a  single person&#39;s experience. Scaling the inputs may not scale the outputs, and the actual calendar day (not relative day) may impact the result.</p><p>  如果系统不是LTI，则无法基于一个人的经验进行推断。缩放输入可能不会缩放输出，并且实际日历天（而非相对日期）可能会影响结果。</p><p>  From  David Greenspan: &#34;Suppose you have a special laser pointer that makes a star shape on the wall. You tape together a bunch of these laser pointers in the shape of a square. The pattern on the wall now is the convolution of a star with a square.&#34;</p><p>  来自大卫·格林斯潘（David Greenspan）的话：“假设您有一个特殊的激光指示器，它在墙上形成星形。您将一束这些激光指示器用正方形胶带绑在一起。墙上的图案现在是一个星形的卷积，一个正方形。”</p><p> Regular multiplication gives you a single scaled copy of an input. Convolution creates multiple overlapping copies that follow a pattern you&#39;ve specified.</p><p> 常规乘法为您提供输入的单个缩放副本。卷积会按照您指定的模式创建多个重叠的副本。</p><p> Real-world systems have squishy, not instantaneous, behavior: they ramp up, peak, and drop down. The convolution lets us model systems that echo, reverb and overlap.</p><p>现实世界中的系统具有不稳定的行为，而不是瞬时的行为：它们会逐渐上升，达到峰值和下降。卷积使我们可以对回声，混响和重叠的系统进行建模。</p><p> Now it&#39;s time for the famous sliding window example. Think of a pulse of inputs (red) sliding through a system (blue), and having a combined effect: the convolution (yellow).</p><p> 现在是著名的滑动窗口示例的时候了。想一想输入脉冲（红色）在系统中滑动（蓝色）并产生综合效果：卷积（黄色）。</p><p>    Convolution has an advanced technical definition, but the basics can be understood with the right analogy.</p><p>    卷积具有先进的技术定义，但是可以用正确的类比来理解基础知识。</p><p> Quick rant: I study math for fun, yet it took years to find a satisfying intuition for:</p><p> 快速咆哮：我学习数学很有趣，但是花了好几年的时间才能找到令人满意的直觉：</p><p>  Why&#39;d it take so long? Imagine learning multiplication with $f \times g = z$ instead of $3 \times 5 = 15$. Without an example I can explore  in my head, I could only memorize results, not intuit them. Hopefully this analogy can save you years of struggle.</p><p>  为什么要花这么长时间？想象一下用$ f \ times g = z $而不是$ 3 \ times 5 = 15 $来学习乘法。没有一个例子，我就无法思考，我只能记住结果，而不是直觉。希望这种类比可以节省您多年的努力。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://betterexplained.com/articles/intuitive-convolution/">https://betterexplained.com/articles/intuitive-convolution/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/花式/">#花式</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fancy/">#fancy</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/卷积/">#卷积</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>