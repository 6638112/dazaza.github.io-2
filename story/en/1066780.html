<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>巧妙的树木 Verkle Trees</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Verkle Trees<br/>巧妙的树木 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-19 06:02:24</div><div class="page_narrow text-break page_content"><p>Verkle trees are shaping up to be an important part of Ethereum&#39;s upcoming scaling upgrades. They serve the same function as Merkle trees: you can put a large amount of data into a Verkle tree, and make a short proof (&#34;witness&#34;) of any single piece, or set of pieces, of that data that can be verified by someone who only has the root of the tree. The key property that Verkle trees provide, however, is that they are  much more efficient in proof size. If a tree contains a billion pieces of data, making a proof in a traditional binary Merkle tree would require about 1 kilobyte, but in a Verkle tree the proof would be  less than 150 bytes - a reduction sufficient to make  stateless clients finally viable in practice.</p><p>Verkle树是塑造的，成为Ethereum的重要组成部分＆＃39;升级升级。它们与merkle树相同的功能：您可以将大量数据放入Verkle树中，并制作该数据的任何单件或一组碎片的短缺（＆＃34;证人＆＃34;）可以由只有树根的人验证。然而，Verkle Tree提供的关键属性是它们在证明尺寸方面更有效。如果一棵树包含十亿条数据，则在传统的二进制Merkle树中呈现验证需要大约1千字节，但在Verkle树中，证据将小于150字节 - 减少足以使无国籍客户在实践中最终可行的减少。</p><p> This post will explain what Verkle trees are and how the cryptographic magic behind them works. The price of their short proof size is a higher level of dependence on more complicated cryptography. That said, the cryptography still much simpler, in my opinion, than the advanced cryptography found in  modern ZK SNARK  schemes. In this post I&#39;ll do the best job that I can at explaining it.</p><p> 这篇文章将解释验尸树是什么以及它们背后的加密魔法。它们的短尺寸的价格是对更复杂的密码学的依赖程度更高。也就是说，在我看来，密码术仍然比现代ZK Snark方案中发现的高级密码更简单。在这篇文章中我＆＃39; ll做到最好的工作，我可以在解释它。</p><p>  In terms of the  structure of the tree (how the nodes in the tree are arranged and what they contain), a Verkle tree is very similar to the  Merkle Patricia tree currently used in Ethereum. Every node is either (i) empty, (ii) a leaf node containing a key and value, or (iii) an intermediate node that has some fixed number of children (the &#34;width&#34; of the tree). The value of an intermediate node is computed as a hash of the values of its children.</p><p>  就树的结构（树中的节点被安排的节点以及它们包含的东西）而言，Verkle树非常相似于当前在Ethereum中使用的Merkle Patricia树。每个节点都是（i）空，（ii）包含键和值的叶节点，或（iii）具有一些固定数量的儿童的中间节点（＆＃34;宽度＆＃34;树的宽度＆＃34）。中间节点的值被计算为其子子的值的哈希值。</p><p> The location of a value in the tree is based on its key: in the diagram below, to get to the node with key  4cc, you start at the root, then go down to the child at position  4, then go down to the child at position  c (remember:  c = 12 in hexadecimal), and then go down again to the child at position  c. To get to the node with key  baaa, you go to the position- b child of the root, and then the position- a child of  that node. The node at path  (b,a) directly contains the node with key  baaa, because there are no other keys in the tree starting with  ba.</p><p> 树中值的位置基于其密钥：在下图中，要使用键4cc到达节点，从根开始，然后向下到第4位的子项，然后向下到孩子在位置C（记住：C = 12在十六进制中），然后再次下降到位置C。要使用key baaa到达节点，请转到根的位置 -  b子项，然后是该节点的位置。路径（b，a）处的节点直接包含带有key baaa的节点，因为树中没有其他键在ba开始。</p><p>           The only real difference in the  structure of Verkle trees and Merkle Patricia trees is that Verkle trees are wider in practice.  Much wider. Patricia trees are at their most efficient when  width = 2 (so Ethereum&#39;s hexary Patricia tree is actually quite suboptimal). Verkle trees, on the other hand, get shorter and shorter proofs the higher the width; the only limit is that if width gets  too high, proofs start to take too long to create. The  Verkle tree proposed for Ethereum has a width of 256, and some even favor raising it to 1024 (!!).</p><p>           Verkle树和Merkle Patricia树结构的唯一真正差异是验证树在实践中更广泛。更宽。当宽度= 2（因此Evereum＆＃39; Seexary Patricia树实际上非常次优）时，帕特里夏树是最有效的。另一方面，Verkle树越来越短，较短的证据越高，宽度越高;唯一的限制是，如果宽度变得太高，则证明开始花费太长以创建。为Etereum提出的Verkle树的宽度为256，有些人甚至有利于将其提升到1024（!!）。</p><p>  In a Merkle tree (including Merkle Patricia trees), the proof of a value consists of the entire set of  sister nodes: the proof must contain all nodes in the tree that  share a parent with any of the nodes in the path going down to the node you are trying to prove. That may be a little complicated to understand, so here&#39;s a picture of a proof for the value in the  4ce position. Sister nodes that must be included in the proof are highlighted in red.</p><p>  在Merkle树（包括Merkle Patricia树）中，值的证明包括整套姐妹节点：证明必须包含树中的所有节点，该节点与路径中的路径中的任何节点共享一个父节点您正在尝试证明的节点。这可能是一个很复杂的理解，所以这里＆＃39;＆＃39; s的校样在4CE位置的迹象。必须包含在证明中的姐妹节点以红色突出显示。</p><p>         That&#39;s a lot of nodes! You need to provide the sister nodes at each level, because you need the entire set of children of a node to compute the value of that node, and you need to keep doing this until you get to the root. You might think that this is not that bad because most of the nodes are zeroes, but that&#39;s only because this tree has very few nodes. If this tree had 256 randomly-allocated nodes, the top layer would almost certainly have all 16 nodes full, and the second layer would on average be ~63.3% full.</p><p>         那个节点＆＃39;很多节点！您需要在每个级别提供姐妹节点，因为您需要节点的整套子组来计算该节点的值，并且您需要继续执行此操作，直到您到达root。您可能会认为这并不糟糕，因为大多数节点都是零，但是＆＃39;■仅是因为这棵树的节点很少。如果此树有256个随机分配的节点，则顶层几乎肯定会有所有16个节点满16个节点，并且第二层平均将平均为〜63.3％。 </p><p> In a Verkle tree, on the other hand, you do not need to provide sister nodes; instead, you just provide the path, with a little bit extra as a proof. This is why Verkle trees benefit from greater width and Merkle Patricia trees do not: a tree with greater width leads to shorter paths in both cases, but in a Merkle Patricia tree this effect is overwhelmed by the higher cost of needing to provide all the  width - 1 sister nodes per level in a proof. In a Verkle tree, that cost does not exist.</p><p>另一方面，在Verkle树中，您不需要提供姐妹节点;相反，您只需提供路径，稍微替代证明。这就是为什么Verkle树从更大的宽度和Merkle Patricia树中受益于：一棵树宽度更大的树导致两种情况下的较短路径，但在Merkle Patricia树中，这种效果被需要提供所有宽度的更高成本所淹没 - 凭证中的1个姐妹节点。在Verkle树中，该成本不存在。</p><p> So what is this little extra that we need as a proof? To understand that, we first need to circle back to one key detail: the hash function used to compute an inner node from its children is not a regular hash. Instead, it&#39;s a  vector commitment.</p><p> 那么我们需要作为证据的额外额外的额外是什么？要了解到，我们首先需要圈回一个关键细节：用于从其子节点计算内部节点的哈希函数不是常规哈希。相反，它＆＃39;是矢量承诺。</p><p> A vector commitment scheme is a special type of hash function, hashing a list  \(h(z_1, z_2 ... z_n) \rightarrow C\). But vector commitments have the special property that for a commitment  \(C\) and a value  \(z_i\), it&#39;s possible to make a short proof that  \(C\) is the commitment to some list where the value at the i&#39;th position is  \(z_i\). In a Verkle proof, this short proof replaces the function of the sister nodes in a Merkle Patricia proof, giving the verifier confidence that a child node really is the child at the given position of its parent node.</p><p> 矢量承诺方案是一种特殊类型的哈希函数，散列列表\（h（z_1，z_2 ... z_n）\ lightarrow c \）。但是矢量承诺具有承诺\（c \）和一个值\（z_i \），它和＃39; s的特殊属性，＆＃39; s可能做出\（c \）是对某些列表的承诺I＆＃39的值; Th位置是\（z_i \）。在Verkle验证中，此简短的证明替换了Merkle Patricia证明中的姐妹节点的功能，使验证者信心为子节点确实是其父节点的给定位置的子节点。</p><p>           In practice, we use a primitive even more powerful than a vector commitment, called a  polynomial commitment. Polynomial commitments let you hash a polynomial, and make a proof for the evaluation of the hashed polynomial at  any point. You can use polynomial commitments as vector commitments: if we agree on a set of standardized coordinated  \((c_1, c_2 ... c_n)\), given a list  \((y_1, y_2 ... y_n)\) you can commit to the polynomial  \(P\) where  \(P(c_i) = y_i\) for all  \(i \in [1..n]\) (you can find this polynomial with  Lagrange interpolation). I talk about polynomial commitments at length  in my article on ZK-SNARKs. The two polynomial commitment schemes that are the easiest to use are  KZG commitments and  bulletproof-style commitments (in both cases, a commitment is a single 32-48 byte elliptic curve point). Polynomial commitments give us more flexibility that lets us improve efficiency, and it just so happens that the simplest and most efficient vector commitments available  are the polynomial commitments.</p><p>           在实践中，我们使用比矢量承诺更强大的原始，称为多项式承诺。多项式承诺让您散列多项式，并在任何时候进行评估散列多项式的证据。您可以使用多项式承诺作为矢量承诺：如果我们同意一组标准化协调\（（C_1，C_2 ... C_N），则给出列表\（（y_1，y_2 ... y_n）\）您可以提交多项式\（p \），其中\（p（c_i）= y_i \）所有\（i \在[1..n] \中）（您可以使用Lagrange插值找到此多项式）。我谈论我关于ZK-Snark的文章中的长度的多项式承诺。这两个多项式承诺方案是最容易使用的是KZG承诺和防弹式承诺（在这两种情况下，承诺是一个32-48字节椭圆曲线点）。多项式承诺给了我们更多的灵活性，让我们提高效率，就是这样，它就会发生最简单，最有效的矢量承诺是多项式承诺。</p><p> This scheme is already very powerful as it is:  if you use a KZG commitment and proof, the proof size is 96 bytes per intermediate node, nearly 3x more space-efficient than a simple Merkle proof if we set width = 256. However, it turns out that we can increase space-efficiency even further.</p><p> 这个方案已经非常强大，因为它使用KZG承诺和证明，证明尺寸为96个字节，如果我们设置宽度= 256，则比简单的Merkle验证更高3倍。但是，它事实证明，我们可以进一步提高空间效率。</p><p>        Instead of requiring one proof for each commitment along the path,  by using the extra properties of polynomial commitments we can make a single fixed-size proof that proves  all parent-child links between commitments along the paths for an unlimited number of keys. We do this using a  scheme that implements multiproofs through random evaluation.</p><p>        通过使用多项式承诺的额外属性，我们可以通过使用多项式承诺的额外属性，而不是要求对路径的每个承诺进行一个证据。我们可以在沿着无限数量密钥的路径之间证明承诺之间的所有父子链接。我们使用通过随机评估实现多体的方案来执行此操作。</p><p> But to use this scheme, we first need to convert the problem into a more structured one. We have a proof of one or more values in a Verkle tree. The main part of this proof consists of the intermediary nodes along the path to each node. For each node that we provide, we also have to prove that it actually is the child of the node above it (and in the correct position). In our single-value-proof example above, we needed proofs to prove:</p><p> 但要使用此方案，我们首先需要将问题转换为更具结构化的问题。我们在Verkle树中有一个或多个值的证明。此证明的主要部分包括沿每个节点的路径的中间节点组成。对于我们提供的每个节点，我们还必须证明它实际上是它上方的节点的子节点（以及在正确的位置）。在上面的单值防范示例中，我们需要证明证明： </p><p> That the  key: 4ce node actually is the position- e child of the  prefix: 4c intermediate node.</p><p>关键：4CE节点实际上是前缀：4C中间节点的位置 -  e子节点。</p><p> That the  prefix: 4c intermediate node actually is the position- c child of the  prefix: 4 intermediate node.</p><p> 前缀：4C中间节点实际上是前缀的位置：4中间节点。</p><p> If we had a proof proving multiple values (eg. both  4ce and  420), we would have even more nodes and even more linkages. But in any case,  what we are proving is a sequence of statements of the form &#34;node A actually is the position-i child of node B&#34;. If we are using polynomial commitments, this turns into equations:  \(A(x_i) = y\), where  \(y\) is the hash of the commitment to  \(B\).</p><p> 如果我们有一个证明多个值的证据（例如，4CE和420），我们将具有更多节点甚至更多的链接。但在任何情况下，我们证明是一系列表单＆＃34的陈述;节点A实际上是节点B＆＃34的位置-I孩子;如果我们正在使用多项式承诺，则这变成了方程式：\（a（x_i）= y \），其中\（y \）是对\（b \）的承诺的哈希。</p><p> The details of this proof are technical and better  explained by Dankrad Feist than myself. By far the bulkiest and time-consuming step in the proof generation involves computing a polynomial  \(g\) of the form:</p><p> 这个证据的细节是由Dankrad Feist的技术和更好的解释。到目前为止，证明生成中最粗壮和耗时的步骤涉及计算形式的多项式\（g \）：</p><p> \(g(X) = r^0\frac{A_0(X) - y_0}{X - x_0} + r^1\frac{A_1(X) - y_1}{X - x_1} + ... + r^n\frac{A_n(X) - y_n}{X - x_n}\)</p><p> \（g（x）= r ^ 0 \ frac {a_0（x） -  y_0} {x  -  x_0} + r ^ 1 \ frac {a_1（x） -  y_1} {x  -  x_1} + ... + r ^ n \ frac {a_n（x） -  y_n} {x  -  x_n} \）</p><p> It is only possible to compute each term  \(r^i\frac{A_i(X) - y_i}{X - x_i}\) if that expression is a polynomial (and not a fraction). And that requires  \(A_i(X)\) to equal  \(y_i\) at the point  \(x_i\).</p><p> 如果该表达式是多项式（而不是分数），则只能计算每个术语\（r ^ i \ frac {a_i（x） -  y_i} {x-x_i} \）。并且在点\（x_i \）处需要\（a_i（x）\）到等于\（y_i \）。</p><p>  We are proving for  \((x_i = 2, y_i = 9)\).  \(A_i(2)\) does equal  \(9\) so this will work.</p><p>  我们正在证明\（（x_i = 2，y_i = 9）\）。 \（a_i（2）\）等于\（9 \）所以这将有效。 </p><p> \(A_i(X) - 9 = X^2 + X - 6\), and  \(\frac{X^2 + X - 6}{X - 2}\) gives a clean  \(X - 3\). But if we tried to fit in  \((x_i = 2, y_i = 10)\), this would not work;  \(X^2 + X - 7\)  cannot be cleanly divided by  \(X - 2\) without a fractional remainder.</p><p>\（a_i（x） -  9 = x ^ 2 + x-6 \），\（\ frac {x ^ 2 + x  -  6} {x  -  2} \）给出一个clean \（x  -  3 \） 。但如果我们尝试适合\（（x_i = 2，y_i = 10）\），这将无法正常工作; \（x ^ 2 + x-7 \）无法干净地除以\（x  -  2 \）而没有分数余数。</p><p> The rest of the proof involves providing a polynomial commitment to  \(g(X)\) and then proving that the commitment is actually correct. Once again, see  Dankrad&#39;s more technical description for the rest of the proof.</p><p> 其余证据涉及为\（g（x）\）提供多项式承诺，然后证明承诺实际上是正确的。再次，见Dankrad＆＃39;对剩下的证据进行了更多技术描述。</p><p>             Dankrad&#39;s multi-random-evaluation proof allows the prover to  prove an arbitrary number of evaluations  \(A_i(x_i) = y_i\), given commitments to each  \(A_i\) and the values that are being proven.  This proof is constant size (one polynomial commitment, one number, and two proofs; 128-1000 bytes depending on what scheme is being used).</p><p>             Dankrad＆＃39; S多随机评估证明允许先驱证明任意数量的评估\（a_i（x_i）= y_i \），给定每个\（a_i \）的承诺以及被证明的值。此证明是恒定尺寸（一个多项式承诺，一个数字和两个证据;根据正在使用的方案，128-1000字节）。</p><p> The  \(y_i\) values do not need to be provided explicitly, as they can be directly computed from the other values in the Verkle proof: each  \(y_i\) is itself the hash of the next value in the path (either a commitment or a leaf).</p><p> 不需要显式提供\（y_i \）值，因为它们可以从Verkle校样中的其他值直接计算：每个\（y_i \）本身是路径中下一个值的散列（无论是承诺或叶子）。</p><p> The  \(x_i\) values also do not need to be provided explicitly, since the paths (and hence the  \(x_i\) values) can be computed from the keys and the coordinates derived from the paths.</p><p> 也不需要明确地提供\（x_i \）值，因为可以从键和从路径派生的坐标计算路径（并且因此\（x_i \）值）。</p><p> Hence,  all we need is the leaves (keys and values) that we are proving, as well as the commitments along the path from each leaf to the root.</p><p> 因此，我们所需要的只是我们证明的叶子（键和值），以及沿着每个叶子到根的路径的承诺。</p><p> Assuming a width-256 tree, and  \(2^{32}\) nodes, a proof would require the keys and values that are being proven, plus (on average)  three commitments for each value along the path from that value to the root.</p><p> 假设宽度-256树和\（2 ^ {32} \）节点，证明需要被证明的键和值，以及沿着该值的路径的每个值的三个承诺根。 </p><p> If we are proving many values, there are further savings: no matter how many values you are proving, you will not need to provide more than the 256 values at the top level.</p><p>如果我们证明许多值，还节省了进一步的节省：无论您证明多少值，都不需要在顶级提供超过256个值。</p><p>   Assuming width 256, and 48-byte KZG commitments/proofs. Note also that this assumes a maximally even tree; for a realistic randomized tree, add a depth of ~0.6 (so ~30 bytes per element). If bulletproof-style commitments are used instead of KZG, it&#39;s safe to go down to 32 bytes, so these sizes can be reduced by 1/3.</p><p>   假设宽度256和48字节KZG承诺/证明。还要注意，这假定了最大的树木;对于一个真实的随机树，深度为〜0.6（每个元素所以〜30个字节）。如果使用防弹式承诺而不是KZG，它的安全性将降至32字节，因此这些尺寸可以减少1/3。</p><p>  The bulk of the  cost of generating a proof is computing each  \(r^i\frac{A_i(X) - y_i}{X - x_i}\) expression. This requires roughly four field operations (ie. 256 bit modular arithmetic operations) times the width of the tree. This is the main constraint limiting Verkle tree widths. Fortunately, four field operations is a small cost: a single elliptic curve multiplication typically takes hundreds of field operations. Hence, Verkle tree widths can go quite high; width 256-1024 seems like an optimal range.</p><p>  生成证据的大部分是计算每个\（r ^ i \ frac {a_i（x） -  y_i} {x-x_i} \）表达式。这需要大致四个现场操作（即256位模块化算术运算）树的宽度。这是主要约束限制Verkle树宽度。幸运的是，四个现场操作是一种小成本：单个椭圆曲线乘法通常需要数百个现场操作。因此，Verkle树宽可以很高;宽度256-1024似乎是一个最佳范围。</p><p> To  edit the tree, we need to &#34;walk up the tree&#34; from the leaf to the root, changing the intermediate commitment at each step to reflect the change that happened lower down. Fortunately, we don&#39;t have to re-compute each commitment from scratch. Instead, we take advantage of the homomorphic property: given a polynomial commitment  \(C = com(F)\), we can compute  \(C&#39; = com(F + G)\) by taking  \(C&#39; = C + com(G)\). In our case,  \(G = L_i * (v_{new} - v_{old})\), where  \(L_i\) is a pre-computed commitment for the polynomial that equals 1 at the position we&#39;re trying to change and 0 everywhere else.</p><p> 要编辑树，我们需要＆＃34;走上树＆＃34;从叶子到根部，改变每个步骤的中间承诺，反映发生较低的变化。幸运的是，我们不必重新计算从头开始重新计算每个承诺。相反，我们利用了同性恋性质：给定多项式承诺\（c = com（f）\），我们可以通过\（c＆＃39来计算\（c＆＃39; = com（f + g）\） ; = C + COM（g）\）。在我们的情况下，\（g = l_i *（v_ {new}  -  v_ {old}）\），其中\（l_i \）是对多项式的预先计算的承诺，其在我们＆＃39的位置等于1; Re试图在其他地方改变和0。</p><p> Hence, a single edit requires ~4 elliptic curve multiplications (one per commitment between the leaf and the root, this time including the root), though these can be sped up considerably by pre-computing and storing  many multiples of each  \(L_i\).</p><p> 因此，单个编辑需要〜4个椭圆曲线乘法（叶片之间的每个承诺，这次包括根），但是通过预先计算和存储每个\（L_I \的许多倍数，它们可以大大加速这些时间）。</p><p> Proof verification is quite efficient. For a proof of N values, the verifier needs to do the following steps, all of which can be done within a hundred milliseconds for even thousands of values:</p><p> 证明验证非常有效。对于N值的证明，验证者需要执行以下步骤，所有这些步骤都可以在数千毫秒内完成，以便数千个值：</p><p> A small constant amount of work that does not depend on the size of the proof</p><p> 不依赖于证明的规模的小持续工作量 </p><p> Note also that, like Merkle Patricia proofs, a Verkle proof gives the verifier enough information to  modify the values in the tree that are being proven and compute the new root hash after the changes are applied. This is critical for verifying that eg. state changes in a block were processed correctly.</p><p>另请注意，与Merkle Patricia证明一样，Verkle凭证为验证者提供了足够的信息以修改在应用更改后被证明的树中的值并计算新的根哈希值。这对于验证例如。正确处理块的状态变化。</p><p>  Verkle trees are a powerful upgrade to Merkle proofs that allow for much smaller proof sizes. Instead of needing to provide all &#34;sister nodes&#34; at each level, the prover need only provide a single proof that proves  all parent-child relationships between all commitments along the paths from each leaf node to the root. This allows proof sizes to decrease by a factor of ~6-8 compared to ideal Merkle trees, and by a factor of over 20-30 compared to the hexary Patricia trees that Ethereum uses today (!!).</p><p>  Verkle树是一个强大的升级到Merkle证据，允许更小的校样尺寸。而不是需要提供所有＆＃34;姐妹节点＆＃34;在每个级别，PROVER仅需要提供一个单一的证据，这些证明证明了沿着每个叶节点的路径到根目录的所有承诺之间的所有父子关系。与理想的Merkle树相比，这允许证明尺寸减小〜6-8倍，与Ethereum使用今天（!!）相比，相比之下超过20-30倍。</p><p> They do require more complex cryptography to implement, but they present the opportunity for large gains to scalability. In the medium term, SNARKs can improve things further: we can either SNARK the already-efficient Verkle proof verifier to reduce witness size to near-zero, or switch back to SNARKed Merkle proofs if/when SNARKs get much better (eg.  through GKR, or very-SNARK-friendly hash functions, or ASICs). Further down the line, the rise of quantum computing will force a change to STARKed Merkle proofs with hashes as it makes the linear homomorphisms that Verkle trees depend on insecure. But for now, they give us the same scaling gains that we would get with such more advanced technologies, and we already have all the tools that we need to implement them efficiently.</p><p> 他们确实需要更复杂的加密来实现，但它们呈现出大量增长的机会。在中期，Snarks可以进一步改进内容：我们可以将已经有效的Verkle验证验证者扩展到接近零的证人大小，或者如果/当SNARKS更好时，请切换回SNARKED Merkle校样（例如，通过GKR ，或非常狡猾的哈希函数或asics）。进一步下行，量子计算的兴起将迫使改变与哈里斯的哈尔克勒证据的变化，因为它使得Verkle树取决于不安全的线性同态。但是，现在，他们向我们提供了我们将获得这种更先进的技术的相同缩放增益，我们已经拥有了所有的工具，我们需要有效地实现它们。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://vitalik.ca/general/2021/06/18/verkle.html">https://vitalik.ca/general/2021/06/18/verkle.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/树木/">#树木</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/verkle/">#verkle</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/证明/">#证明</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>