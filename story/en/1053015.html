<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在数据库建模中擦除 Erasure in Database Modeling</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Erasure in Database Modeling<br/>在数据库建模中擦除 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-17 22:48:18</div><div class="page_narrow text-break page_content"><p>Before we can continue the discussion of physical representation of either/or data, we need to discuss the idea of  erasure.  In computer science you most often hear about the “ type erasure”.  If you write a program in the programming language with stronger compile-time type checking, the resulting program would often contain no type information (it is erased). We can find interesting parallels between this process and the process of data modeling.</p><p>在我们继续讨论任何/或数据的物理表征之前，我们需要讨论擦除的想法。在计算机科学中，您最常听到“类型擦除”。如果在具有更强的编程语言中在编程语言中编写程序，则结果程序通常不包含类型信息（它被删除）。我们可以在此过程与数据建模过程之间找到有趣的相似之处。</p><p> NB: the field of type checking is extremely complicated and normally requires a lot of precision in reasoning.  However, our real goal here is to establish the idea of erasure in database modeling.  We use type erasure just to illustrate that concept.</p><p> NB：类型检查领域非常复杂，通常在推理中需要大量的精确度。然而，我们这里的真实目标是在数据库建模中建立擦除的概念。我们使用类型擦除只是为了说明这种概念。</p><p>   We’re going to use JavaScript as example.  Thankfully, the most trivial examples are enough for our purpose, so the following text requires zero experience with JavaScript.</p><p>   我们将用JavaScript用作示例。值得庆幸的是，最琐碎的例子足以介绍我们的目的，因此以下文本需要与JavaScript的零体验。</p><p> JavaScript is a dynamically typed programming language.  There is also a more advanced extension of JavaScript called TypeScript.  TypeScript is a statically typed programming language.  Static type-checking helps the compiler to find many categories of bugs in our code.  Let’s write  a trivial function in TypeScript that calculates the sum of array elements:</p><p> JavaScript是一种动态类型的编程语言。还有一个更高级的JavaScript扩展名为TypeScript。 TypeScript是一种静态类型的编程语言。静态类型检查有助于编译器在我们的代码中查找许多类别的错误。让我们在输入的类型中编写一个微不足道的函数，以计算数组元素的总和：</p><p> // File: sum_arr.tsfunction sum_arr(arr  : number[])  : number {    let result = 0;    arr.forEach((num) =&gt; result += num);    return result;}console.log(sum_arr([2, 3, 5, 7]));// prints 17, which is 2 + 3 + 5 + 7</p><p> // file：sum_arr.tsfunction sum_arr（arr：number []）：number {let结果= 0; arr.foreach（（num）=＆gt;结果+ = num）;返回结果;} console.log（sum_arr（[2,3,5,7]））; //打印17，它是2 + 3 + 5 + 7</p><p> The first line is the most important for our discussion.  It declares that the function takes an array of numbers (the “: number[]” part) and it returns a number.  With the help of type declarations the compiler is able to find many different bugs in our code.   For example, if we accidentally use some function that is supposed to work with text strings and not with numbers, the compiler will complain and refuse to compile this program.</p><p> 第一行对我们的讨论最重要。它声明该函数占据数组（“：number []”部分），它返回一个数字。借助类型声明的帮助，编译器能够在代码中查找许多不同的错误。例如，如果我们不小心使用应该使用文本字符串而不是数字使用的一些函数，则编译器将抱怨并拒绝编译此程序。</p><p> The funny thing about TypeScript is that if you delete all the type declarations, what is left would be  valid code in JavaScript:</p><p> TypeScript有趣的是，如果删除所有类型的声明，则剩余的内容将是JavaScript中的有效代码： </p><p> // File: sum_arr.jsfunction sum_arr(arr) {    let result = 0;    arr.forEach((num) =&gt; result += num);    return result;}console.log(sum_arr([2, 3, 5, 7]));// prints 17</p><p>// file：sum_arr.jsfunction sum_arr（arr）{let结果= 0; arr.foreach（（num）=＆gt;结果+ = num）;返回结果;} console.log（sum_arr（[2,3,5,7]））; //打印17</p><p> It is a perfectly valid program, and if you did not use TypeScript, you could write exactly this in JavaScript and it would be correct code.  Thousands of people write in JavaScript every day.</p><p> 这是一个完美有效的程序，如果您没有使用打字签，则可以在JavaScript中完全写入，它将是正确的代码。成千上万的人每天都在javascript中写下。</p><p> So, TypeScript programs could be converted to JavaScript by removing the type declaration: that is, by  type erasure.  Your browser could not execute the TypeScript program directly, so it needs this sort of preprocessing.  Or, you could write a program directly in JavaScript and then run it in the browser directly.</p><p> 因此，可以通过删除类型声明来转换为JavaScript的打字程序：即按类型擦除。您的浏览器无法直接执行打字程序，因此它需要这种预处理。或者，您可以直接在JavaScript中编写一个程序，然后直接在浏览器中运行它。</p><p> So, why do we need TypeScript?  Because when we change something in our program we could make a mistake.  TypeScript compiler then would be able to catch some of those mistakes because the type declarations are still there.</p><p> 那么，我们为什么需要打字签字？因为当我们在我们的计划中改变某些东西时，我们可能会犯错误。类型签字编译器将能够捕获其中一些错误，因为类型声明仍然存在。</p><p> If you change JavaScript code, those mistakes could only be found by other means: automated and manual testing, thinking hard, reviewing code, or running your code in production and waiting for complaints from users.   There is nothing wrong with all those approaches, really: your other engineering practices might help you mitigate the consequences of potential errors.</p><p> 如果更改JavaScript代码，则只能通过其他方式找到这些错误：自动化和手动测试，思考难，审阅代码，或在生产中运行代码并等待用户的投诉。所有这些方法都没有错，真的：您的其他工程实践可能会帮助您减轻潜在错误的后果。</p><p> If we would lose the original TypeScript source of this program, we could continue changing the JavaScript code directly, just with less help from the compiler and with all associated risks in understanding the original code.</p><p> 如果我们将丢失此程序的原始版本源，我们可以继续直接更改JavaScript代码，只需在编译器中的帮助下，并且在了解原始代码中的所有相关风险。</p><p>    Often we think about database schemas in terms of tables, fields, primary keys, normal forms etc.  Many of us learned this approach when we were learning database programming.  But there is certainly a level above this one.  We can see that because  there is more than one way to represent many data structures via tables.</p><p>    我们经常在表格，字段，主要键，正常形式等方面考虑数据库模式等。我们在学习数据库编程时，我们中的许多人都学到了这种方法。但肯定是一个高于这个水平。我们可以看到，因为有多种方式通过表来表示许多数据结构。 </p><p> We saw that in the previous posts: you can put a “has_symptoms” attribute either in the main table, in the side table or in the per-attribute table.  However, our pseudo-code higher-level representation (logical schema) stays the same:</p><p>我们在上一篇文章中看到了：您可以在主表中放置一个“has_symptoms”属性，侧表或每个属性表中。但是，我们的伪代码更高级别表示（逻辑架构）保持不变：</p><p>  The number of possible logical schemas is less than the number of possible physical tables schemas, as we saw above: there are three physical schemas for one logical schema, and that’s only for one of the concerns of physical representation.</p><p>  如上所述，可能的逻辑模式的数量小于可能的物理表模式的数量：一个逻辑架构存在三种物理模式，这仅适用于物理表示的关切之一。</p><p> There is a parallel with the type erasure example:  the number of possible TypeScript programs is less than the number of possible JavaScript programs.  First, we can write JavaScript programs with bugs that would have been caught by the TypeScript compiler, and those programs would be valid (albeit buggy) programs in JavaScript.  Second, the TypeScript compiler can reorganize the code in different ways for the sake of optimization, so the same function can be represented in JavaScript in many ways, depending on our optimization needs.</p><p> 擦除替换示例有一个并行：可能的缩写程序的数量小于可能的JavaScript程序的数量。首先，我们可以编写包含缩写编译器所捕获的错误的JavaScript程序，并且这些程序将在JavaScript中有效（虽然是错误的）程序。其次，根据我们的优化需求，可以以不同方式重新组织代码以不同方式重新组织代码，因此可以在许多方面以javascript表示相同的功能。</p><p> Another parallel is that often you do not have access to the logical schema of your database: you only have the physical table schema, fields, primary keys and indexes. And you could go quite a long way if you just work at this level: adding or removing a field, adding or removing a table, etc.  Thousands of people execute SQL ALTER operators every day, there is absolutely nothing wrong with that!</p><p> 另一个并行是，通常您无权访问数据库的逻辑架构：您只有物理表架构，字段，主键和索引。如果你只是在这个级别工作，你就可以走了很长的路法：添加或删除字段，添加或删除表。成千上万的人每天执行SQL ALTER ORPerators，绝对没有错！</p><p> Of course there is a reason, an idea behind every physical schema.  It may not be explicitly documented, but you can gather it from various cues by looking at the structure of the table, at the code that works with those tables, and even at the data that is stored in those tables.  Also, you could read old documentation or talk with people who joined your company before you and remember more history.</p><p> 当然有一个原因，每个物理模式背后的想法。它可能无法明确记录，但是您可以通过查看表的结构，在与这些表一起使用的代码中，甚至处于存储在这些表中的数据中，您可以从各种提示中收集它。此外，您可以阅读旧文件或与在您之前加入贵公司的人交谈并记住更多历史。</p><p> The same way, if you look at the JavaScript code above, you can quickly assume that this function accepts an array of numbers from various cues: the name of the function is “ sum”, so it’s probably not strings; and the fact that the code uses  forEach function suggests that  arr is an array (also, the argument name probably means “array”).  But if you had an original TypeScript code you could be absolutely sure, and you wouldn’t have to guess.</p><p> 同样的方式，如果您查看上面的JavaScript代码，您可以快速假设此功能从各种提示中接受一系列数字：函数的名称是“SUM”，因此它可能不是字符串;并且代码使用foreach函数的事实表明，ARR是数组（此外，参数名称可能意味着“array”）。但是，如果你有一个原始的打字代码，你可能会绝对确定，你不必猜测。</p><p>  A lot of database modeling advice on the Internet and elsewhere talks about database normalization as a guiding principle.  But what if normal forms are erasable, too?  In the previous section we made a hypothesis that the level of physical tables may not be the only level to think on about database modeling.   Normal forms though are properties of physical tables: we say that they are in this or that normal form.</p><p>  互联网和其他地方的大量数据库建模建议讨论了数据库标准化作为指导原则。但如果正常形式也是可擦除的，那么怎么样？在上一部分中，我们提出了一个假设，即物理表的水平可能不是思考数据库建模的唯一级别。正常形式虽然是物理表的属性：我们说他们处于这或正常形式。 </p><p> Does it mean that normal forms do not exist at the level above the physical tables, whatever that level is?</p><p>无论哪种级别是什么，正常形式都不存在于物理表上方的水平上吗？</p><p> If we look at all the tables that we  proposed in two  previous posts, we’ll see that they are really pretty well normalized!  All of them are at least in third normal form; if we use per-attribute tables they would probably even be in the sixth normal form.  Yet nowhere in this substack did we even mention the normal forms until now.</p><p> 如果我们看看我们在上一篇文章中提出的所有表，我们会看到他们真的很常见化！所有这些至少是第三正常形式;如果我们使用每个属性表，他们甚至可能处于第六正常形式。然而，在这个时尚中我们甚至提到了正常形式。</p><p> Does it mean that there is a useful higher level of modeling representation where normal forms are not needed?  Or did we actually use the idea of normalization without realizing it?  Or we just got lucky, the same way that you can accidentally write a JavaScript program without bugs?</p><p> 是否意味着存在不需要正常形式的更高水平的建模表示？或者我们实际上使用了正常化的想法而不意识到它？或者我们刚刚幸运，同样的方式可以不小心写一个没有错误的JavaScript程序？</p><p> Also, if we think through our either/or example keeping normalization in mind, we would see that normalization does not help us in maintaining our invariant: we want to store  either the list of the symptoms in “have symptoms” case,  or the PCR test results in “no symptoms” case, but having  both of them or  none of them is incorrect.  Table normalization allows us to prevent many data issues, but can it maintain this particular invariant? The answer is not clear.  Are there alternative ways to maintain this invariant?  How are they related to normalization?  Which invariants, generally, can and cannot be maintained by normalization?</p><p> 此外，如果我们通过我们的任何一个/或例子来保持正常化，我们会看到正常化并没有帮助我们维护我们的不变性：我们想存储“有症状”案例的症状列表，或者PCR测试结果在“无症状”案例中，但是既有它们又有两个都是不正确的。表规范化允许我们防止许多数据问题，但它可以维护这种特定的不变吗？答案尚不清楚。是否有维护这种不变的方式？他们如何与规范化相关？通常，哪些不变性可以且不能通过归一化维护？</p><p> Oh and by the way: why do we even want to find the logical schema?  Our answer is that reason is that we are guided by  the principle of minimality.</p><p> 哦，顺便说一句：为什么我们甚至想找到逻辑模式？我们的答案是，理性是我们被最小地的原则为指导。</p><p> There are many questions in this section: we have no answers at the moment, really, just a hunch that this may be an interesting direction.</p><p> 本节有很多问题：我们目前没有答案，真的，只是一个亨希，这可能是一个有趣的方向。</p><p>  But to find some additional arguments, we shall continue our long journey towards database representation of either/or data.  In the next post we’ll discuss how to actually write either/or data values, using the tables that we’ve proposed in the previous posts.</p><p>  但要找到一些额外的论点，我们将继续我们的长途旅程来朝着或数据的数据库表示。在下一个帖子中，我们将使用我们在上一篇文章中提出的表来讨论如何实际编写/或数据值。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://minimalmodeling.substack.com/p/erasure">https://minimalmodeling.substack.com/p/erasure</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/database/">#database</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/可能/">#可能</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012 - 2021 diglog.com </div></div></body></html>