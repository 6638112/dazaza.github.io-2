<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Java并发性-了解线程的基础知识</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Java并发性-了解线程的基础知识</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-31 21:01:35</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/443fb78166cd1e98f75aed69f8d85206.jpeg"><img src="http://img2.diglog.com/img/2020/10/443fb78166cd1e98f75aed69f8d85206.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Java  Thread objects allow us to run our code in separate threads. When an application starts JVM creates the initial thread named  main. The main method is run on the main thread. Inside the application we can create new threads to execute other tasks in parallel with the main thread.</p><p>Java Thread对象允许我们在单独的线程中运行代码。当应用程序启动时，JVM创建名为main的初始线程。Main方法在主线程上运行。在应用程序内部，我们可以创建新线程，以便与主线程并行执行其他任务。</p><p> Java uses native operating system threads. So one java thread is mapped by one OS thread.</p><p>Java使用本机操作系统线程。因此，一个操作系统线程映射一个Java线程。</p><p>  The constructor of the  Thread class takes a  Runnable object. Runnable interface has an abstract  run method which is called by  Thread#start() method. It object can be instantiated by a lambda, anonymous class or a class which implements Runnable method.</p><p>Thread类的构造函数接受一个Runnable对象。Runnable接口有一个抽象的run方法，该方法由Thread#start()方法调用。IT对象可以由lambda、匿名类或实现Runnable方法的类实例化。</p><p>    Thread lives as long as the its run hook method has not returned. The scheduler can suspend and run the Thread many times. For a thread to execute forever, it needs an infinite loop that prevents it from returning.</p><p>只要线程的Run钩子方法没有返回，线程就会存活。调度程序可以挂起并多次运行线程。为了让线程永远执行，它需要一个无限循环来防止它返回。</p><p> Join method allows one thread to wait for the completion of another. This is a simple form of barrier synchronisation.</p><p>Join方法允许一个线程等待另一个线程的完成。这是屏障同步的一种简单形式。</p><p>   When JVM start it contains a single User thread, named Main thread. The main difference between User and Daemon threads are what happens when they exit.</p><p>当JVM启动时，它包含名为主线程的单个用户线程。用户线程和守护进程线程之间的主要区别在于它们退出时会发生什么。</p><p>  Thread class contains boolean  daemon field to specify whether the thread is daemon. It can be set at the time of creation by the constructor or by setter method.</p><p>线程类包含布尔型守护程序字段，用于指定线程是否为守护程序。它可以在创建时由构造函数或setter方法设置。</p><p>  By default daemon field is false, so most of the Threads that we generate is a User Thread. Threads copy the  isDaemon status of the parent threat if it is not specified. Java uses Daemon thread in some places such as  ForkJoinPool and  Timer. To illustrate we can use the following example:</p><p>默认情况下，守护程序字段为false，因此我们生成的大多数线程都是用户线程。如果未指定，线程将复制父威胁的isDaemon状态。Java在某些地方使用守护程序线程，比如ForkJoinPool和Timer。为了说明这一点，我们可以使用以下示例：</p><p> public class Main { public static void main(String[] args) throws InterruptedException, ExecutionException {// runDeamonThread(); runUserThread(); System.out.println(getCurrentThreadName() + &#34; exits&#34;); } private static void runDeamonThread() throws ExecutionException, InterruptedException { ExecutorService executorService = Executors.newWorkStealingPool(10); executorService.execute(getRunnable()); } private static void runUserThread() { Thread thread = new Thread(getRunnable()); thread.start(); } private static Runnable getRunnable() { return () -&gt; { for (int i = 0; i &lt;= 200; i++) { System.out.print(&#34;.&#34;); Thread.yield(); } System.out.println(getCurrentThreadName() + &#34; exits. isDeamon: &#34; + isDaemon()); }; } private static boolean isDaemon() { return Thread.currentThread().isDaemon(); } private static String getCurrentThreadName() { return Thread.currentThread().getName(); }}</p><p>Public class main{public static void main(String[]args)Thws InterruptedException，ExecutionException{//runDeamonThread()；runUserThread()；System.out.println(getCurrentThreadName()+&#34；exits&#34；)；}私有静态void runDeamonThread()抛出ExecutionException，InterruptedException{ExecutorService ExecutorService=Executors.newWorkStealingPool(10)；ecutorService.Execue.Exception()；}Private static void runrunRserThread()；{Thread=new Thread(getthread.start()；}private static runnable Runnable()；{return()&gT；T；{for(int i=0；i&lt；=200；i++){System.out.print(&#34；.&#34；)；Thread.Year()；}System.out.println(getCurrentThreadName()+&#34；退出。IsDeamon：&#34；+isDaemon())；}；}私有静态布尔isDaemon(){return Thread.currentThread().isDaemon()；}私有静态字符串getCurrentThreadName(){return Thread.currentThread().getName()；}}。</p><p>   The second case is invoking the  runDeamonThread which uses  ForkJoinPool as an example of Daemon Threads. I could simply use  setDaemon(true) method, but wanted to give an example usage. Output:</p><p>第二种情况是调用runDeamonThread，它使用ForkJoinPool作为守护程序线程的示例。我可以简单地使用setDaemon(True)方法，但是我想给出一个用法示例。产出：</p><p>  So when the main method exits, all the user threads are terminated and JVM exits and kills all daemon threads, so that we did not even have a chance to see output from daemon threads.</p><p>因此，当main方法退出时，所有用户线程都将终止，JVM将退出并终止所有守护进程线程，因此我们甚至没有机会看到守护进程线程的输出。</p><p>  Compared to creating, stopping a thread is quite hard thing. Once thread starts running it diverges from the caller and it has it is own lifecycle anymore. It can either complete the task and exits or if it does a long running operation it can work forever. Java does not provides us a method (non-deprecated) to stop the thread voluntarily.</p><p>与创建相比，停止线程是一件相当困难的事情。一旦线程开始运行，它就脱离了调用方，它就有了自己的生命周期。它可以完成任务并退出，或者如果它执行长时间运行的操作，它可以永远工作。Java没有为我们提供自愿停止线程的方法(非弃用的)。</p><p>  volatile boolean isStopped = false;public void test() { new Thread(() -&gt; { while (!isStopped) { System.out.print(&#34;.&#34;); } System.out.println(&#34;Child Exits&#34;); }).start(); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } isStopped = true; System.out.println(&#34;Main exits&#34;);}</p><p>易失性布尔isStoped=false；public void test(){new Thread(()-&gt；{while(！isStoped){System.out.print(&#34；.&#34；)；}System.out.println(&#34；子出口&#34；)；}).start()；try{Thread.sleep(100)；}catch(InterruptedException E){e.printStackTrace()；}isStoped=true；System.out.println(&#34；main exits&#34；)；</p><p> Note that the flag is  volatile in order to make its up-to-date value visible for both threads. However this approach fails if the thread is doing blocking operations such as  sleep,  wait,  join or blocking I/O operations.</p><p>请注意，该标志是易失性的，以便使其最新值对两个线程都可见。但是，如果线程正在执行休眠、等待、联接或阻塞I/O操作等阻塞操作，则此方法会失败。</p><p> 2. Another way to stop the tread is to use  interrupt() method of the thread.</p><p>2.另一种停止踏步的方法是使用线程的interrupt()方法。</p><p> An interrupt request to a thread is an indication that it should stop what it is doing and do something else. It is up to the programmer to decide exactly how a thread responds to an interrupt but it is very common for the tread to terminate.</p><p>对线程的中断请求是它应该停止正在做的事情并做其他事情的指示。线程如何响应中断是由程序员来决定的，但是线程终止是很常见的。</p><p> For the interrupt mechanism to work correctly, the interrupted thread must support its own interruption mechanism. There are 2 cases we can examine for interruption:</p><p>要使中断机制正常工作，被中断的线程必须支持其自己的中断机制。我们可以检查两种情况是否中断：</p><p>  In this case calling the  thread.interrupt() method will set the interrupt flag of the that thread but if the task itself does not check the status of the interrupted flag it will not have any impact. For example:</p><p>在这种情况下，调用thread.interrupt()方法将设置该线程的中断标志，但如果任务本身不检查中断标志的状态，则不会产生任何影响。例如：</p><p> public void test() throws InterruptedException { Thread thread = new Thread(() -&gt; { System.out.println(&#34;Child Starts&#34;); while (true) { System.out.print(&#34;.&#34;); } }); thread.start(); thread.interrupt(); thread.join(); System.out.println(&#34;Main exits&#34;);}</p><p>Public void test()抛出InterruptedException{ThreadThread=new Thread(()-&gt；{System.out.println(&#34；Child Start&#34；)；While(True){System.out.print(&#34；.&#34；)；}})；thread.start()；thread.interrupt()；thread.join()；System.out.println(&#34；main exits&#34；)；}。</p><p> In order for the thread to catch the interrupt, it should iteratively check the status of the interrupt flag so that it can understand if there are any pending interruption request and handle the request accordingly.</p><p>为了让线程捕获中断，它应该反复检查中断标志的状态，以便了解是否有任何挂起的中断请求，并相应地处理该请求。</p><p> So we can check the flag in our while loop in if it is true we can return or break the loop. In the lambda expression it is not possible to throw an exception but in appropriate places we can throw  InterruptedException as well.</p><p>因此，我们可以检查WHILE循环中的标志，如果为真，我们可以返回或中断循环。在lambda表达式中，不可能抛出异常，但是在适当的位置，我们也可以抛出InterruptedException。</p><p> public void test() throws InterruptedException { Thread thread = new Thread(() -&gt; { System.out.println(&#34;Child Starts&#34;); while (true) { if (Thread.interrupted()) { break; } System.out.print(&#34;.&#34;); } System.out.println(&#34;Child exits&#34;); }); thread.start(); thread.interrupt(); thread.join(); System.out.println(&#34;Main exits&#34;);}</p><p>Public void test()抛出InterruptedException{ThreadThread=new Thread(()-&gt；{System.out.println(&#34；Child Start&#34；)；While(True){if(Thread.interrupted(){Break；}System.out.print(&#34；.&#34；)；}System.out.println(&#34；Child Exits&#34；)；})；thread.start()；thread.interrupt()；thread.join()；System.out.println(&#34；主要出口)；}。</p><p> Note the  Thread.interrupted() method returns the value of the flag and clears it if it has been true. So if we want to keep the state of the Thread as interrupted for the upper level of stack, we can set it back with  Thread.currentThread().interrupt();</p><p>注Thread.interrupted()方法返回标志的值，如果为真，则将其清除。因此，如果我们希望在堆栈的上层保持Thread的状态为中断，可以使用Thread.currentThread().interrupt()将其设置回去；</p><p>  If a thread frequently calls the blocking methods such as  wait,  join,  sleep,  blocking I/O which are all run interruptively, these methods internally check if they have been interrupted and if so they automatically throw  InterruptedException. This exception should be caught and handled in the appropriate context. The following example uses the interruption to break the loop in a blocking  sleep operation:</p><p>如果线程频繁调用所有都以中断方式运行的阻塞方法(如等待、联接、睡眠、阻塞I/O)，则这些方法会在内部检查它们是否已被中断，如果已中断，它们将自动抛出InterruptedException。应该在适当的上下文中捕获和处理此异常。以下示例在阻塞休眠操作中使用中断来中断循环：</p><p> public void test() throws InterruptedException { Thread thread = new Thread(() -&gt; { System.out.println(&#34;Child Starts&#34;); try { while (true) { Thread.sleep(10000); } } catch (InterruptedException e) { System.out.println(&#34;Thread interrupted: &#34; + e.getMessage()); } System.out.println(&#34;Child Exits&#34;); }); thread.start(); thread.interrupt(); thread.join(); System.out.println(&#34;Main exits&#34;);}</p><p>Public void test()抛出中断异常{ThreadThreadThread=new Thread(()-&gt；{System.out.println(&#34；Child Start&#34；)；try{While(True){线程睡眠(10000)；}}catch(InterruptedException E){System.out.println(&#34；线程中断：&#34；+e.getMessage())；}System.out.println(&#34；Child Exits&#34；)；})；thread.start()；thread.interrupt()；Thread.join()；System.out.println(&#34；Main Exits&#34；)；}。</p><p>  One approach is propagating the exception to the callers, so higher layer would be responsible.</p><p>一种方法是将异常传播给调用方，因此将由较高层负责。</p><p>  If it is not possible to re-throw, we can set the interrupted status to true again with  Thread.currentThread().interrupt() to preserve the evidence if the higher layers want to check it.</p><p>如果不能重新抛出，我们可以使用Thread.currentThread().interrupt()再次将中断状态设置为true，以便在较高层希望检查证据时保留证据。</p><p> So as a conclusion if we want to implement cancellable tasks we need to periodically check the status of the interrupt status and handle the interruption in a way that thread will exit.</p><p>因此，总而言之，如果我们想要实现可取消的任务，我们需要定期检查中断状态的状态，并以线程将退出的方式处理中断。</p><p>  In order to simplify thread management, multiple threads  can be organised with  java.lang.ThreadGroup objects that group related threads. Each Thread Group needs to have a parent group. In the hierarchy, there is the  Main group which is the parent of the other groups or threads we create in the program. We can create  ThreadGroup by calling its constructor with a parent group and/or name. To add the Threads in a group we need to specify the group in the Thread&#39;s constructor.</p><p>为了简化线程管理，可以使用对相关线程进行分组的java.lang.ThreadGroup对象来组织多个线程。每个线程组都需要有一个父组。在层次结构中，有一个主组，它是我们在程序中创建的其他组或线程的父组。我们可以通过使用父组和/或名称调用ThreadGroup的构造函数来创建ThreadGroup。要将Thread添加到组中，我们需要在Thread的构造函数中指定该组。</p><p> public void test() { ThreadGroup tg1 = new ThreadGroup(&#34;Thread-group-1&#34;); ThreadGroup tg2 = new ThreadGroup(tg1, &#34;Thread-group-2&#34;); Thread thread1 = new Thread(tg1,&#34;thread-1&#34;); Thread thread2 = new Thread(tg2,&#34;thread-2&#34;); Thread thread3 = new Thread(tg2,&#34;thread-3&#34;); thread1.start(); thread2.start(); thread3.start(); Thread[] threads = new Thread[tg2.activeCount()]; tg2.enumerate(threads); Arrays.asList(threads).forEach(t -&gt; System.out.println(t.getName())); tg1.list();}</p><p>Public void test(){ThreadGroup TG1=new ThreadGroup(&#34；Thread-group-1&#34；)；ThreadGroup TG2=new ThreadGroup(TG1，&#34；Thread-group-2&#34；)；Thread thread1=new Thread(TG1，&#34；Thread-1&#34；)；Thread Thread2=new Thread(TG2，&#34；Thread-2&#34；)；Thread Thread3=new Thread(TG2，&#34；Thread-3&#34；)；thread1.start()；thread2.start()；Thread3.start()；Thread[]Thread=new Thread[tg2.activeCount()]；tg2.枚举(线程)；Arrays.asList(线程).forEach(t-&gt；System.out.println(t.getName()；tg1.list()；}。</p><p> We can iterate over the threads by calling the  enumerate method, which fills the given array with the thread references of the group.</p><p>我们可以通过调用枚举方法迭代线程，该方法用组的线程引用填充给定数组。</p><p>  public class ThreadPool { // Create a thread group field private final ThreadGroup group = new ThreadGroup(&#34;ThreadPoolGroup&#34;); // Create a LinkedList field containing Runnable private final List&lt;Runnable&gt; tasks = new LinkedList&lt;&gt;(); public ThreadPool(int poolSize) { // create several Worker threads in the thread group for (int i = 0; i &lt; poolSize; i++) { var worker = new Worker(group, &#34;worker-&#34; + i); worker.start(); } } private Runnable take() throws InterruptedException { synchronized (tasks) { // if the LinkedList is empty, we wait while (tasks.isEmpty()) tasks.wait(); // remove the first job from the LinkedList and return it return tasks.remove(0); } } public void submit(Runnable job) { // Add the job to the LinkedList and notifyAll synchronized (tasks) { tasks.add(job); tasks.notifyAll(); } } public int getRunQueueLength() { // return the length of the LinkedList // remember to also synchronize! synchronized (tasks) { return tasks.size(); } } public void shutdown() { // this should stop all threads in the group group.interrupt(); } private class Worker extends Thread { public Worker(ThreadGroup group, String name) { super(group, name); } public void run() { // we run in an infinite loop: while(true) { // remove the next job from the linked list using take() // we then call the run() method on the job try { take().run(); } catch (InterruptedException e) { e.printStackTrace(); break; } } } }}</p><p>Public class ThreadPool{//创建线程组字段Private Final ThreadGroup group=new ThreadGroup(&#34；ThreadPoolGroup&#34；)；//创建包含可运行私有最终列表&lt；Runnable&gt；Tasks=new LinkedList&lt；&gt；()；public ThreadPool(Int PoolSize){//为(int i=0；i&lt；poolSize；i++){var worker=new worker(group，&#34；worker-#34；+i)；worker.start()；在线程组中创建多个工作线程。}}Private Runnable Take()抛出InterruptedException{Synchronized(Tasks){//如果LinkedList为空，我们等待(tasks.isEmpty())tasks.wait()；//从LinkedList中移除第一个作业并返回任务。remove(0)；}}public void mit(Runnable Job){//将作业添加到LinkedList并通知所有同步(Tasks){tasks.add(Job)；tasks.notfyAll()；}}public int getRunQueueLength(){//返回LinkedList的长度//记得也要同步！Synchronized(Tasks){return tasks.size()；}}public void shutdown(){//这将停止组中的所有线程。interrupt()；}私有类worker扩展Thread{public worker(ThreadGroup group，String name){Super(group，name)；}public void run(){//我们在无限循环中运行：while(True){//使用take()从链表中删除下一个作业//然后对作业try{take().run()；调用run()方法；}catch(InterruptedException E){e.printStackTrace()；Break；}</p><p>  Java  ThreadLocal class can be used to create variables whose value can be accessible by only the same thread. So, even if two threads are executing the same code, and the code has a reference to the same  ThreadLocal variable, the two threads cannot see each other&#39;s  ThreadLocal variables.</p><p>Java ThreadLocal类可用于创建其值只能由同一线程访问的变量。因此，即使两个线程正在执行相同的代码，并且代码引用了相同的ThreadLocal变量，这两个线程也无法看到对方的ThreadLocal变量。</p><p> public class Main { public static class ThreadLocalStorage { private static final ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void setName(String name) { threadLocal.set(name); } public static String getName() { return threadLocal.get(); } } public static void main(String[] args) { ThreadLocalStorage.setName(&#34;Main thread&#34;); Runnable runnable = () -&gt; { ThreadLocalStorage.setName(getCurrentThreadName()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&#34;Thread: [&#34; + getCurrentThreadName() + &#34;] &#34; + &#34;- value: [&#34; + ThreadLocalStorage.getName() + &#34;]&#34;); }; Thread thread1 = new Thread(runnable); Thread thread2 = new Thread(runnable); thread1.start(); thread2.start(); System.out.println(&#34;Main exits&#34;); } private static String getCurrentThreadName() { return Thread.currentThread().getName(); }}</p><p>公共类Main{public static class ThreadLocalStorage{private static inal ThreadLocal&lt；String&gt；threadLocal=new ThreadLocal&lt；&gt；()；public static void setName(String Name){threadLocal.set(Name)；}public static string getName(){return threadLocal.get()；}}public static void main(String[]args){ThreadLocalStorage.setName(&#34；main thread&#34；)；runnable runnable=()-&gt；{ThreadLocalStorage.setName(getCurrentThreadName())；try{Thread.Slear(1000)；}catch(InterruptedException E){e.printStackTrace()；}System.out.println(&#34；Thread：[&#34；+getCurrentThreadName()+&#34；]&#34；+&#34；-value：[&#34；+ThreadLocalStorage.getName()+&#34；]&#34；)；}；Thread thread1=new Thread(Runnable)；Thread thread2=new Thread(Runnable)；thread1.start()；thread2.start()；Systemout.println(&#34；main exits&#34；)；}；Thread thread1=new Thread(Runnable)；Thread thread2=new Thread(Runnable)；thread1.start()；thread2.start()；Systemout.println(&#34；main exits&#34；)。)；}私有静态字符串getCurrentThreadName(){return Thread.currentThread().getName()；}}。</p><p> If we run the code we can see that each thread has its own copy of the ThreadLocal object.</p><p>如果我们运行代码，我们可以看到每个线程都有自己的ThreadLocal对象副本。</p><p>  Instead of each thread having its own value inside a  ThreadLocal, the  InheritableThreadLocal grants access to values to a thread and all child threads created by that thread.</p><p>InheritableThreadLocal不是每个线程在ThreadLocal内都有自己的值，而是将值的访问权限授予一个线程和该线程创建的所有子线程。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://turkogluc.com/java-concurrency-basics-of-threads/">https://turkogluc.com/java-concurrency-basics-of-threads/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031970.html"><img src="http://img2.diglog.com/img/2020/10/thumb_4d2b600d2de85507ff91c336b79c432a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031970.html">新兴的JavaScript模式：多个返回值</a></div><span class="my_story_list_date">2020-10-29 18:29</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031619.html"><img src="http://img2.diglog.com/img/2020/10/thumb_99f2142c0124e0d0a756ac05f1257d4d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031619.html">Eslisp-ECMAScript/JavaScript的S表达式语法，带有类似Lisp的宏</a></div><span class="my_story_list_date">2020-10-28 5:7</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031253.html"><img src="http://img2.diglog.com/img/2020/10/thumb_3135a88f5c95852430c2739231b50a1f.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031253.html">我们选择Java作为高频交易应用程序</a></div><span class="my_story_list_date">2020-10-26 23:54</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030931.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b6d2f44664370d45e7761c500cdb97d3.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030931.html">对159个国家的17K名开发人员的调查：JavaScript是最受欢迎的语言，有1240万活跃开发人员，紧随其后的是Python，有900万，然后是Java，有820万</a></div><span class="my_story_list_date">2020-10-24 14:8</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>