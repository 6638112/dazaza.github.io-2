<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>关于消息传递的一些注意事项 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">关于消息传递的一些注意事项 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-22 06:19:38</div><div class="page_narrow text-break page_content"><p>消息传递一直是erlang的核心，虽然合理威尔记录了，但我们已经避免进入太多细节，以在实施时给我们更多的血统。没有什么可以阻止我们在博客帖子中描述它，所以让我们仔细看看！</p><p> Erlang流程通过发送彼此信号（不与Unix信号混淆）相互通信。有许多不同的种类和消息是最常见的。实际上，涉及更多进程的一切都在内部使用信号：例如，通过使所涉及的流程来回通信，直到它们在链接上缩短，链接/ 1函数。</p><p> 这有助于我们避免大量的锁，并且可以自己制作一个有趣的博客，但现在我们只需要留意两件事：持续收到和处理allsignals（包括消息）后面，他们有一个定义的命令：</p><p> 保证两个进程之间的信号才能按照他们的顺序到达。换句话说，如果处理A发送信号1，然后将2发送到处理B，则保证信号1以在信号2之前到达。</p><p>  %%将监控信号发送到“PID”，请求A＆＃39;下降＆＃39;消息%%当`PID`死亡时。 MREF =监视器（进程，PID），%%向“PID”发送消息信号以及我们的“请求”PID！ {self（），mref，请求}，接收{mref，response}  - ＆gt; %%将噬魔仪信号发送给`pid`，然后删除%%对应＆＃39;下降＆＃39;可能具有%%的消息在此期间到达。 erlang：魔法员（MREF，[FLUSH]），{OK，RESPORTAY}; {＆＃39;下降＆＃39; ，mref，_，_，原因}  - ＆gt; {错误，原因}结束</p><p> 由于死亡进程无法发送消息，我们知道响应必须达到任何最终＆＃39;下降＆＃39;消息，但没有保证订单＆＃39;下降＆＃39;消息可能会在响应之前到达，我们不知道是否响应是否已经到来，这将是非常讨厌的。</p><p> 拥有一个定义的顺序节省了很多麻烦，并且不会出现成本，但保证在那里停止。如果多个进程为共同进程发送时，即使您将首先发送信号之一，它们也可以按任何顺序到达。例如，这一序列是法律和完全可能的： </p><p>幸运的是，全球订单很少需要，很容易强加自己（在分布式案例外）：只需让所有涉及的各方都与Acommon进程同步。</p><p>  发送消息很简单：我们尝试找到与进程标识符相关联的进程，如果存在一个，则将消息插入其信号队列。</p><p> 在插入队列之前，始终复制消息。由于浪费的哮喘可能会听到它大大减少了垃圾收集（GC）延迟，因为GCNEver必须超越单一过程。 Hastbeen的非复制实现在过去尝试过，但它们结果是一个不好的契合，因为低延迟比纯粹的吞吐量重要的是，对于那种软实时系统来说，旨在构建。</p><p> 默认情况下，消息将直接复制到接收过程中堆，但是当不可能的（或期望 - 请参阅Message_queue_data标志），而是veallocate在堆之外的消息。</p><p> 内存分配使得这种“离堆”消息稍微昂贵，但对于接收大量消息的进程非常简洁。在复制消息时，我们不需要与接收器进行交互 - 只有在将其添加到队列时 - 而且由于进程唯一的方法可以看到消息是在接收表达式中呈映射时，GC不需要考虑诸多邮件进一步减少延迟。</p><p> 向其他Erlang节点上的进程发送消息以相同的方式工作，尽管现在存在丢失消息的风险。只要编号为主动之间的分发链接，才能传递邮件“是要传递的，但是当链接下降时它会变得棘手。</p><p> 在远程过程（或节点）上使用监视器/ 2将告诉您当此表达时，表现得好像过程已死（具有原因与Noconnection），但随着该消息并不总是有帮助：链接可能已在邮件已收纳后已死亡另一端，我们所知道的是，在我们之前，链接往往有任何最终的回应。 </p><p>与其他一切都没有免费午餐，并且您需要决定您的应用方式如何处理这些方案。</p><p>  人们可能猜测进程通过接收表达式接收消息，但接收是一个错误的一点。与所有其他信号一样，过程即原地处理它们在后台中，从信号队列移动到消息队列的接收消息。</p><p> 接收搜索消息队列中的匹配消息（OrderThee到达），或者如果未找到NONE，则等待新消息。搜索消息队列而不是信号队列意味着它不必担心发送消息的进程，这大大提高了性能。</p><p> 这种“选择性地接收”特定消息的能力非常方便：我们并不总是在我们可以决定与一条消息和围绕所有未处的消息手动凸出的信息，这肯定会令人讨厌。</p><p>   如果queuematcheses {回复，结果}中的下一个消息，但如果没有匹配的消息，则立即完成，但如果没有匹配的消息，则必须在放弃之前全部行进。当有很多用于服务器的进程常见的众多常见的人时，这是昂贵的，因为接收表达式可以匹配，只需几乎可以完成以优化搜索本身即可匹配。</p><p> 我们目前唯一的优化是为什么当我们知道在某个点之前无法存在的消息时，标志着研究.Let的Revisit Request-responatioom：</p><p> MREF =监视器（进程，PID），PID！ {self（），mref，请求}，接收{mref，response}  - ＆gt; erlang：魔法员（MREF，[FLUSH]），{OK，RESPORTAY}; {＆＃39;下降＆＃39; ，mref，_，_，原因}  - ＆gt; {错误，原因}结束 </p><p>由于Monitor / 2创建的引用是全局唯一的，并且不能存在于此呼叫，并且接收仅匹配包含该reference的消息，我们不需要查看之前接收的任何消息。</p><p> 这使得即使在具有荒谬LongMessage队列的进程中也使成语有效，但不幸的是，它不是我们在通用箱中可以做的事情。虽然您作为程序员可以确定，即使在没有参考的情况下，也必须遵循某个响应，例如通过使用您的序列号，编译器无法读取您的意图，并且必须假设您希望任何匹配的消息。</p><p> 弄清楚上述优化是否已踢出令人讨厌。它需要检查光束组件，即使是你尚未假定它将由于一些恼人的限制而工作：</p><p> 我们只支持一个消息位置一次：一个创建发布的函数，调用使用此优化的另一个函数，然后使用第一个引用接收到的另一个函数，最终将通过整个消息队列进行搜索。</p><p>  它只在单个函数子句内工作：参考创建和接收需要彼此旁边，并且您不能调用通用接收助手的多功能。</p><p> 我们已经在即将到来的OTP 24发行版中解决了这些缺点，并且凭借编译器选项可以帮助您发现它的应用位置：</p><p>    - 模块（示例）。 - 导出（[T / 2]）。 T（PID，请求） - ＆gt; %% example.erl：5：优化：参考标记%%消息队列位置MREF =监视器（进程，PID），PID！ {self（），mref，请求}，%% example.erl：7：Info：在example.erl中的%% monitor / 2创建的传递引用.erl：5 await_result（mref）。 await_result（mref） - ＆gt; %% example.erl：10：优化：所有子句匹配功能参数1在功能参数1中获得{MREF，响应}  - ＆gt; erlang：魔法员（MREF，[FLUSH]），{OK，RESPORTAY}; {＆＃39;下降＆＃39; ，mref，_，_，原因}  - ＆gt; {错误，原因}结束。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://blog.erlang.org/message-passing/">http://blog.erlang.org/message-passing/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/消息传递/">#消息传递</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/message/">#message</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/消息/">#消息</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>