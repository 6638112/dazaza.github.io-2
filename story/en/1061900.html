<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Swift演员：一个实际的例子，第1部分 Swift Actors: A practical example, part 1</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Swift Actors: A practical example, part 1<br/>Swift演员：一个实际的例子，第1部分 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-11 16:52:38</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/e50174eb64b66ff7bd2aab261afb4765.png"><img src="http://img2.diglog.com/img/2021/5/e50174eb64b66ff7bd2aab261afb4765.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I’ve been re-reading the Swift  structured concurrency roadmap and the Swift  actors proposal and noticed a note on the latter saying:</p><p>我一直在重新阅读Swift结构化并发路线图和Swift演员提案，并注意到后者的一份说明：</p><p>  So, naturally 🤓, I downloaded the  latest snapshot from Swift.org and took it for a spin to try out some actor code!</p><p>  所以，自然🤓，我从swift.org下载了最新的快照，并将其旋转旋转以尝试一些演员代码！</p><p>  Huge disclaimer: this is all experimental experience using a trunk code not cut into a release.</p><p>  巨大的免责声明：这是使用未切割成释放的中继码的所有实验经验。</p><p> I grabbed a May 4th  trunk snapshot of the swift toolchain, installed it on my machine, and activated it in my Xcode 12.5 beta via the Xcode/Toolchains… menu. Now I have Xcode running with Swift 5.5 💪🏼:</p><p> 我抓住了Swift Toolchain的5月第4个中继快照，在我的机器上安装它，并通过Xcode / Toolchains中将其激活在我的Xcode 12.5 Beta中...菜单。现在我有Xcode运行，swift 5.5💪🏼：</p><p>  Next, I needed a project with enabled experimental concurrency support so I created an app from the command line:</p><p>  接下来，我需要一个具有启用的实验并发支持的项目，因此我从命令行创建了一个应用程序：</p><p>  Then I cleaned up the  Package.swift file and added the swift compiler flag that was mentioned in the actors proposal:</p><p>  然后我清理了包裹.swift文件并添加了演员提议中提到的Swift编译器标志：</p><p> // swift-tools-version:5.4 import  PackageDescription let  package = Package( name:  &#34;ActorTest&#34;, platforms: [.macOS(.v11)], targets: [ .executableTarget( name:  &#34;ActorTest&#34;, swiftSettings: [ .unsafeFlags([  &#34;-Xfrontend&#34;,  &#34;-enable-experimental-concurrency&#34; ]) ] ) ])</p><p> // swift-tools-version：5.4导入packageedescription让包=包裹（名称：＆＃34; actortest＆＃34;，平台：[.macos（.v11）]，targets：[.executableTarget（名称：＆＃34; Scatortest＆＃34;，SwiftSettings：[.Unsafeflags（[＆＃34; -Xfrontend＆＃34;＆＃34; -Enable-Deparical-mancurrency＆＃34;]）]）]）]）） </p><p> ⌘+B to check if the projects builds fine and that’s all -  ActorsTest is now an app sporting experimental Swift concurrency with actors!</p><p>⌘+ b检查项目是否罚款，这一切都是 -  Actorstest现在是一个应用运动实验迅速并发与演员！</p><p>  I’ve read few times the various Swift concurrency effort proposals and I’ll try to summarize my understanding of what actors solve (so far).</p><p>  我已经读过几次各种快速并发努力提案，我会尽力总结我对演员解决的理解（到目前为止）。</p><p> Note: I might be wrong about some points or things might change considerably later on.</p><p> 注意：我可能是错误的一些点，或者在以后可能会发生变化。</p><p>   Is  Person thread-safe 🤔? In other words, will your app –&gt; ever&lt;– crash inside  Person?</p><p>   人是线程安全的吗？换句话说，你的应用程序会 - ＆gt;永远＆lt;  - 里面的崩溃？</p><p> The answer is: “it depends”. It depends how your or others&#39; code uses  Person. If two pieces of code, running concurrently, update  Person.name at the same time - your app will crash. 🌋</p><p> 答案是：“这取决于”。这取决于你或他人的方式如何＆＃39;代码使用人员。如果两条代码，同时运行，请同时更新person.name  - 您的应用程序将崩溃。 🌋</p><p> Even if you make  Person.name private, in order to protect it from concurrent reads/writes from outside the class, you can still concurrently read/write from  within the class which is also going to crash your app.</p><p> 即使您制作人物。私人私有，为了从类外部保护它，您仍然可以在类内同时读/写，该类也将崩溃您的应用。</p><p> At present, if you are writing concurrent code, you are probably using Swift’s thread sanitizer to detect data races like the one I’m talking about above.</p><p> 目前，如果您正在编写并发代码，您可能正在使用Swift的线程Sunitizer来检测像上面我谈论的那样的数据比赛。 </p><p>  This is extremely useful but the problem is that this way you  still can write unsafe code. Crashes might still happen at runtime. You just hope you’ll discover and fix all the issues by using the Thread sanitizer. (And won’t introduce new issues later on.)</p><p>这是非常有用的，但问题是这种方式，您仍然可以编写不安全的代码。崩溃可能仍然发生在运行时。您只希望使用Thread Sacitizer发现并修复所有问题。 （并且稍后不会引入新问题。）</p><p>  Actors offer data isolation within a type in such way that the code you write cannot create data races. In other words, thread-safety is built into the type system. Similarly to how mutability is - you simply cannot compile code that mutates immutable data.</p><p>  Actors以一种类型的数据隔离提供，以便您编写的代码无法创建数据比赛。换句话说，线程安全内置于类型系统中。类似于可变性如何 - 您根本无法编译突变不可变数据的代码。</p><p> Let’s compare a class versus an actor. The  class below  is not thread safe and whether is crashes or not depends on the way other code uses it:</p><p> 让我们比较课程与演员。下面的课程不是线程安全，是否崩溃或不依赖于其他代码使用它的方式：</p><p>  In contrast, the following  actor type  is safe to use concurrently. Thanks to the work-in-progress actors feature your code accesses the  name-property memory in a safe way. It’s guaranteed by the actor type:</p><p>  相比之下，以下演员类型可以安全使用。由于工作中的工作方式，您的代码可以安全地访问名称 - 属性内存。它由演员类型保证：</p><p>  I haven’t delved into the implementation details but from what I’ve read so far in the proposal - actors transparently implement the following compile-time rules:</p><p>  我还没有登录到实施细节，但到目前为止我在提案中读到的内容 - 演员透明地实施以下编译时间规则：</p><p> Allow only asynchronous access to the actor’s members from any asynchronous context, and</p><p> 仅允许对来自任何异步上下文的Actoror的成员的异步访问，</p><p> This way the actor itself accesses its data synchronously, but any other code from outside is required asynchronous access (with implicit synchronization) to prevent data races.</p><p> 这样，演员本身同步访问其数据，但是外部的任何其他代码都是必需的异步访问（具有隐式同步）以防止数据比赛。 </p><p>    Going back to my  ActorTest app, I’ll first try some concurrent code that crashes before I add in an actor to solve the crash.</p><p>返回我的Actortest App，我将首先尝试一些并发代码，在我添加演员以解决崩溃之前崩溃。</p><p> I’ll start with a cache type that computes SHA512 hashes of numbers (a silly example that requires just few lines of Swift to demonstrate the idea):</p><p> 我将首先计算Sha512哈希数的缓存类型（一个只需要几行SWIFT的愚蠢示例来演示这个想法）：</p><p> import  CryptoKit class  HashCache {  private( set)  var  hashes = [ Int:  String]()  func  addHash( for number:  Int) {  let  string = SHA512.hash(data: Data( String(number).utf8) ).description hashes[number] = string }  func  compute() { DispatchQueue.concurrentPerform(iterations:  15000, execute: addHash( for:)) }}</p><p> 导入cryptokit类hashcache {private（set）var hasish = [int：string]（）func addhash（for number：int）{let string = sha512.hash（数据：数据（字符串（字符串）.utf8））.description散列[number] = string} func compute（）{dissatchqueue.concurrentperform（迭代：15000，执行：AddHash（for :)）}}</p><p> addHash(for:) takes a number and adds its text representation’s hash to  hashes, and</p><p> AddHash（for :)采取一个数字，并将其文本表示的哈希添加到哈希和</p><p> If you’ve done something along these lines before, you instantly see the issue in this code. When you call  HashCache.compute() you’ll have a crash because multiple threads are calling  addHash(for:) and trying to mutate  hashes at the same time. 💥</p><p> 如果您之前已经完成了这些行，则立即查看此代码中的问题。当您调用hashcache.compute（）时，您将崩溃，因为多个线程正在调用AddHash（for :)并尝试同时变异哈希。 💥</p><p>  So again,  hashes and  addHash(for:) aren’t unsafe per sè - especially if your app is generally running on the main thread. But as soon as some code calls  addHash(for:) from a non-main thread the app becomes prone to data-race crashes.</p><p>  所以再次，哈希和地址（for :)并不是每sè不安全 - 特别是如果您的应用程序通常在主线程上运行。但是一旦一些代码调用AddHash（for :)来自非主线程，该应用程序变为易于数据竞争。</p><p> At present, to solve this issue, you would add locking around your mutable state or use a serial queue to synchronize data-access but that often requires a lot of boilerplate code. 🙃</p><p> 目前，要解决此问题，您将在可变状态下添加锁定或使用串行队列来同步数据访问，但通常需要大量的样板代码。 🙃 </p><p> Let’s rewrite  HashCache as an  actor and get rid of that crash for good.</p><p>让我们将Hashcache重写为演员并摆脱该崩溃。</p><p>  So I’m just going to replace the keyword  class with an  actor and …</p><p>  所以我只是要用演员和...替换关键字类。</p><p> import  CryptoKitactor HashCache {  private( set)  var  hashes = [ Int:  String]()  func  addHash( for number:  Int) {  let  string = SHA512.hash(data: Data( String(number).utf8) ).description hashes[number] = string }  func  compute() { DispatchQueue.concurrentPerform(iterations:  15000, execute: addHash( for:)) }}</p><p> 导入Cryptokitactor Hashcache {private（set）var hasish = [int：string]（）func addhash（for number：int）{let string = sha512.hash（数据：数据（字符串（字符串）.utf8））.description hashes [ number] = string} func compute（）{dissatchqueue.concurrentperform（迭代：15000，执行：AddHash（for :)）}}</p><p> It works - the project compiles fine. Running the app though hits the same crash. Don’t forget this feature is work-in-progress. 🤷🏽‍♂️</p><p> 它有效 - 项目编译得很好。运行该应用程序虽然同样崩溃了。不要忘记此功能是正在进行的工作。 🤷🏽♂️</p><p> It looks at the moment the compiler doesn’t quite catch that the  execute parameter of  DispatchQueue.concurrentPerform(...) needs to be synchronized.</p><p> 它似乎暂时编译器不完全捕获dispatchqueue.concurrentperform（...）的执行参数。</p><p> But the compiler catches data-race code if you provide a closure instead! Changing  compute() to:</p><p> 但如果您提供关闭，编译器会捕获数据竞争代码！将compute（）更改为：</p><p>    The closure in  concurrentPerform(...) is called asynchronously so you are not allowed to synchronously access an actor member because it needs to be synchronized to prevent data races. Awesome!</p><p>    ConcurrentPerform（...）中的闭合被异步调用，因此您不允许同步地访问actor构件，因为需要同步以防止数据比赛。惊人的！ </p><p> I won’t try making the code work with  DispatchQueue because at this point it’d be much more fun to try the new  Task-based (and also work-in-progress) concurrency. Let’s replace the  DispatchQueue code with a task group:</p><p>我不会尝试使用DispatchQueue进行代码工作，因为此时，尝试基于任务（以及正在进行的工作）并发等等，它会更有乐趣。让我们用任务组替换DispatchQueue代码：</p><p>  This is more sample code from the actor proposal that I mentioned above but on the surface it looks like it just creates a concurrent group that you can add tasks to. A neat detail is that  withTaskGroup(...) waits until all tasks in the group complete.</p><p>  这是我在上面提到的actor提案的更多示例代码，但它看起来它只是创建了一个可以添加任务的并发组。一个简洁的细节是，使用托斯群（...）等待，直到组中的所有任务完成。</p><p> I checked for a way to create tasks that don’t return anything but couldn’t find one, so my tasks in this group will return a  Bool which I’m gonna discard.</p><p> 我检查了一种创建不返回任何东西的任务，但无法找到一个的方法，因此我在这个小组中的任务将返回一个我会丢弃的BOOL。</p><p>   Since  withTaskGroup(...) needs to wait for all tasks to complete it is, of course, asynchronous. Swift complains that the context in which I call  withTaskGroup(...) is not asynchronous so let’s fix that:</p><p>   由于哈顿群组（...）需要等待所有任务来完成它，当然是异步。 Swift抱怨我呼叫的上下文（......）不是异步，所以让我们修复：</p><p>  I made  compute() async and also used  await when calling  withTaskGroup(...). That clears up the previous error message but I get a new one:</p><p>  我制作了compute（）async，并且在调用withtaskgroup时使用等待等待（...）。清除之前的错误消息，但我得到一个新的错误：</p><p>  If you ⌘+Click on  withTaskGroup(...) you’ll find that the experimental features have a distant future availability:</p><p>  如果您⌘+点击使用托斯群（...），您会发现实验功能具有遥远的未来可用性：</p><p>  In any case clicking the third suggested solution makes  HashCache available on macOS 9999 or newer and everything compiles OK.</p><p>  在任何情况下，单击第三个建议的解决方案使HashCache在MacOS 9999或更新中提供，并且一切都可以编译确定。 </p><p> Next, I want to create a task for each hash I’m about to compute. I found this to work and it looks pretty simple (again, I don’t really use the returned boolean).</p><p>接下来，我想为每个即将计算的哈希创建任务。我发现这个可以工作，看起来很简单（再次，我真的没有使用返回的布尔值）。</p><p> func  compute() async { await withTaskGroup(of:  Bool. self) { group  in  for number  in  0 ...  15_000 { group.spawn { await  self.addHash( for: number)  return  true } } }}</p><p> func compute（）async {await withtaskgroup（：bool。self）{group for number in 0 ... 15_000 {group.spawn {await self.addhash（for：number）return true}}}</p><p> Reading up the group API it sounds really great - you can treat it as a lazy sequence and control the tasks execution to batch tasks, cancel one or more tasks, emit progress as tasks complete, and more.</p><p> 读取组API听起来真的很棒 - 您可以将其视为懒惰的序列并控制任务执行到批处理任务，取消一个或多个任务，作为任务完整的进度发出进度，更多。</p><p> But I won’t go into all that right now as all I want now is to concurrently compute the hashes and be done.</p><p> 但是，我现在不会进入所有这些，因为我现在想要的只是同时计算哈希和完成。</p><p>  If you scroll waaay up you’ll notice that  addHash(for:) isn’t an  async function at all. But calling  addHash(for:) synchronously from an asynchronous task might cause a data-race and a crash. That’s why the compiler requires you to use  await so that it can synchronize your access to the actor’s internals:</p><p>  如果滚动waaay向上，您会注意到AddHash（for :)根本不是异步功能。但是从异步任务同步调用AddHash（for :)可能会导致数据竞争和崩溃。这就是编译器要求您使用等待的原因，以便它可以同步您对Actor内部的访问：</p><p>  THIS is what I’m talking about. The 3 simple rules we spelled out in the beginning are so clever that simply prevent you from writing bad code.</p><p>  这就是我所说的。我们在开始时拼写出的3个简单规则是如此聪明，只需阻止您编写不良代码。</p><p>  There is, however, no need to convert  addHash(for:) to an  async function altogether. You still might want to call it synchronously when the context permits it.</p><p>  但是，没有必要将AddHash（for :)转换为Async函数。当上下文允许时，您仍然可能希望同步调用它。 </p><p> Now I’m super curious to try how that works. Let’s add one more hash to the lot that  compute() caches:</p><p>现在，我非常好奇，尝试如何运作。让我们将一个哈希添加到Compute（）缓存的批次：</p><p> func  compute() async { addHash( for:  42) await withTaskGroup(of:  Bool. self) { group  in  for number  in  0 ...  15_000 { group.spawn { await  self.addHash( for: number)  return  true } } }}</p><p> func compute（）async {addhash（for：42）等待用托斯群（以下是：bool。self）{group in 0 ... 15_000 {group.spawn {await self.addhash（for：number）return true}} }}</p><p>  I didn’t read in detail what’s the annotation that makes the task closure give that actor isolation error but it’s on my todo.</p><p>  我没有详细阅读，这使得任务闭合使演员隔离错误的注释是什么，但它在我的Todo上。</p><p>  The last few use-cases to verify have to do with accessing actor members from outside of the actor, regardless whether from an asynchronous context or not.</p><p>  验证是否必须使用从演员的外部访问演员成员，而是无论是否来自异步上下文，都必须执行。</p><p>     addHash() is a “vanilla” function but for all purposes it’s treated like an  async when called from outside the actor, and finally</p><p>     AddHash（）是一个“香草”功能，但是对于所有目的，它在演员外部调用时会像异步一样处理，最后</p><p> hashes also needs to be synchronized when accessed outside the actor so you also need to use  await here.</p><p> 在Actor外面访问时，哈希也需要同步，因此您还需要在此处使用等待。</p><p> The actors implementation design and the experience when writing this code makes me very happy. Having thread-safety checked at compiled time will make Swift apps generally safer, less crash-prone, and hopefully more people will be embracing concurrent programming.</p><p> 演员实施设计和写作此代码的体验让我非常开心。在编译时间检查的线程安全将使SWIFT应用程序一般更安全，越来越容易发生，希望更多的人将拥抱并发编程。 </p><p>   import  Foundation import  CryptoKit@available(macOS  9999, *)@main struct  App {  static  let  cache = HashCache()  static  func  main() async { await cache.addHash( for:  7778) await cache.compute() await print(cache.hashes[ 34]!) }}@available(macOS  9999, *)actor HashCache {  private( set)  var  hashes = [ Int:  String]()  func  addHash( for number:  Int) {  let  string = SHA512.hash(data: Data( String(number).utf8) ).description hashes[number] = string }  func  compute() async { addHash( for:  42) await withTaskGroup(of:  Bool. self) { group  in  for number  in  0 ...  15_000 { group.spawn { await  self.addHash( for: number)  return  true } } } } }</p><p>导入基础导入cryptokit @可用（macos 9999，*）@ main struct app {static let cache = hashcache（）静态func main（）async {await cache.addhash（for：7778）等待cache.compute（）等待打印（缓存.hashes [34]！）}} @可用（macos 9999，*）演员hashcache {private（set）var hasish = [int：string]（）func addhash（for number：int）{let string = sha512.hash（数据：数据（字符串（数字）.utf8））.description hashes [number] = string} func compute（）async {addhash（for：42）等待用托斯群（以下是：self）{group in for of no.0。 ..15_000 {group.spawn {await self.addhash（for：number）return true}}}}}</p><p> Final disclaimer: Developed using a Swift toolchain from the Swift.org trunk branch. The concurrency feature is a work-in-progress. This code might not work at a later moment.</p><p> 最终免责声明：使用Swift.org Trunk Branch的Swift Toolchain开发。并发功能是一个过程。此代码可能在以后的时刻无法正常工作。</p><p>   Update: After wrapping up this post I started thinking about mixing up Swift actors and Combine. Expect a follow-up post coming out in couple of days.</p><p>   更新：在包装此帖后，我开始考虑混合迅速的演员并结合。期待几天后出来的后续帖子。</p><p> All of the concurrency features in Swift are still work in progress. You don’t need to be learning them as of right now as syntax or behavior might change, so I hope this post  does not put any unnecessary pressure on you.</p><p> SWIFT中的所有并发功能都在进行中。您现在不需要依赖于现在，因为语法或行为可能会改变，所以我希望这篇文章对你没有任何不必要的压力。</p><p> That’s also the reason why I’ve also put so many disclaimers in the post - this write-up is purely exploratory.</p><p> 这也是为什么我在帖子中放置了这么多免责声明的原因 - 这篇文章纯粹是探索性的。</p><p> But the next time anyone tells you that concurrent code is bad because it crashes with strange errors and the best way is to only use the main thread, you’ll know that’s not true if you use the new structured concurrency in Swift :)</p><p> 但下次有人告诉你并发代码不好，因为它崩溃了奇怪的错误，最好的方法是只使用主线程，如果您在SWIFT中使用新的结构化并发时，您将知道这不是真的:)</p><p>   To learn about all Combine check  Combine: Asynchronous programming with Swift - this is where you can see all updates, discuss in the website forums, and more.</p><p>   要了解所有组合检查组合：Swift的异步编程 - 这是您可以看到所有更新的地方，在网站论坛中讨论。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://trycombine.com/posts/swift-actors/">https://trycombine.com/posts/swift-actors/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/swift/">#swift</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/actors/">#actors</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>