<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Erlang垃圾收集细节及其原因（2015） </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Erlang垃圾收集细节及其原因（2015） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-23 17:05:13</div><div class="page_narrow text-break page_content"><p>Erlang尝试解决的主要问题之一是创建一个实现具有高响应级别的软实时系统的平台。这种系统需要快速的垃圾收集机制，不能停止系统及时响应。当我们认为Erlang作为一种不可变形的语言时，垃圾收集更加重要，因为具有非破坏性更新属性，因为这些语言具有很高的生产垃圾。</p><p>  在挖掘GC之前，必须检查Erlang进程的内存布局，可分为三个主要部分：过程控制块，堆栈和堆。它与UNIX进程内存布局类似。</p><p> 共享堆erlang过程内存布局+ ---------------------------------------- ------------------------- + | | | | | | | PID /状态/注册名称|过程| | | |控制| | |初始呼叫/当前呼叫+ ----＆gt;块| | | | （PCB）| | |邮箱指针| | | | | | | + ------------------------------- + | | | | | | |功能参数| | | | |过程| | |返回地址+ ----＆gt;堆栈| | | | | + -------------- + | |局部变量| | | | | | | | | + ------------ +  -  + | + ---------------------------- +  -  + | | | | | | | | | | | + ------------- +  -  + | | ^ V + ----＆gt;自由| | | | | | | | |空间| | | | + -------------- +  -  + | +  -  + ---------------------------- + | +  -  + | | | | | | | +  -  + | REFC二进制| | |邮箱消息（链接列表）| | +  -  + | | | | | + ------ ^ ---------- + | |复合术语（名单，元组）|过程| | | | + ----＆gt;私人| | | |术语大于单词|堆| | | | | | +  -  + procbin + ------------- +指向大型二进制文件| | | | | + --------------------------------------------- --------------------</p><p> PCB：Process Control块在过程表中包含有关其标识符（PID）等过程的一些信息，当前状态（运行，等待），其注册名称，初始和当前呼叫以及PCB对传入消息的指向是存储在堆中的链接列表的成员。</p><p>  堆栈：是一个向下生长的内存区域，它包含传入和传出参数，返回地址，局部变量和用于评估表达式的临时空间。</p><p>  堆：它是一个向上生长的内存区域，它包含流程邮箱的物理信息，比如列表，元组和二进制文件，如诸如浮点数的机器单词的列表，元组和二进制文件和对象。大于64字节的二进制术语不存储在进程私有堆中。它们被称为Refc二进制（参考计数二进制），并存储在一个大的共享堆中，该堆可通过具有该Refc二进制文件指针的所有进程访问。该指针称为ProcBin，并存储在进程私有堆中。</p><p>  为了简明扼要地解释当前默认的erlang的GC机制;它是一个世代复制垃圾收集，可以独立地在每个erlang进程私有堆内运行，并且还针对全局共享堆出现引用计数垃圾收集。 </p><p>私人堆的GC是世代的。世代GC将堆分为两段：年轻人和旧代。这种分离是基于这样一个事实：如果物体存活到GC循环，它在短期内将成为垃圾的可能性很低。因此，年轻一代是用于新分配的数据，旧一代是幸存于实施特定数量的GC的数据。这种分离有助于GC减少其在没有成为垃圾的数据上的不必要的周期。在Erlang垃圾收集的背景下有两种策略;世代（次要的）和古代（专业）。世代GC只收集了年轻的堆，但填充了旧堆。现在让我们在新开始的Erlang进程的私人堆中查看GC步骤：</p><p>   没有GC在短期过程中发生，该过程不再使用min_heap_size然后终止堆。这样收集过程中使用的整个内存。</p><p>   一种新生产的进程，其数据增加了Min_heap_size使用FullSweep GC，显然是因为尚未发生GC，因此对Offer和Old TewNations的对象之间没有分离。之后，首次全普通GC之后，堆分为年轻人和旧段，然后将GC策略交换为代理，并在进程终止之前保持在其上。</p><p>   当GC策略再次从代域切换到Fullsweep时，有一个过程寿命。第一个案例是经过一定数量的世代GC。该某个号码可以全局或使用FullSweep_After标志指定或每个进程指定。此外，Foursweep GC之前的世代GC的计数器和其上限分别是Minor_GCS和Fullsweep_After属性，并且可以在Process_Info（PID，Garbage_Collection）的返回值中看到。第二种情况是当生成GC不能收集足够的内存并且最后一个情况是手动调用垃圾箱（PID）函数时。在这些情况之后，GC策略再次从FullSweep再次恢复到生成，并留在上面发生的情况下。</p><p>  Spawn＆gt; Fullsweep＆gt;世代＆gt; Fullsweep＆gt;增加堆和gt; Fullsweep＆gt; ...＆gt;终止</p><p> 在方案3中，如果第二次_ ullsweep gc无法收集足够的内存，则堆大小增加，GC策略再次切换到ullsweep，如新生生成的过程，并且可以再次又一次地发生所有这四种情况。</p><p> 现在，问题是为什么它在自动垃圾收集的语言中很重要，就像Erlang一样。过度地，这种知识可以帮助您通过调整全球范围或每个过程的GC发生和策略来使您的系统变得更快。其次，我们可以理解从其垃圾收集的角度来使Erlang成为软实时平台的主要原因之一。这是因为每个进程都有自己的私人堆和自己的GC，所以每次GC都会发生在一个过程中它只是停止了被收集的Erlang进程，但不会停止其他进程，这是一个软实时系统需要。 </p><p>共享堆的GC是参考计数。共享堆（REFC）中的每个对象都具有由存储在Erlang进程的私有堆内的其他对象（Procbin）所持的IT引用的反击。如果对象的参考计数器达到零，则对象已无法访问，并将被销毁。 Count Counting GC非常便宜，有助于系统避免意外的长时间停顿并提高系统响应性。但是，在设计演员模型系统时不知道一些着名的反模式可能会在内存泄漏时发出麻烦。</p><p> 首先，当REFC分成分二进制时。为了便宜;子二进制文件不是原始二进制文件的拆分部分的新副本，但只是参考该部分。然而，除了原始二进制文件之外，这个子二进制数量还是一个新的参考，而且你知道，当原始二进制文件必须挂起时，它可能会导致问题才能收集其子二进制。</p><p>  其他已知问题是当存在一种用于控制和传送大型REFC二进制消息的请求控制器或消息路由器时的一种长寿命的中间件进程。由于此过程触及每个REFC消息，因此它们的计数器增量。因此，收集这些REFC消息取决于收集中间件内部的所有PROCBIN对象。不幸的是，因为普罗氏只是一个指针，因此它们非常便宜，可能需要很长时间才能发生中间件进程内的GC。因此，即使从中间件从所有其他进程收集，REFC消息也保持在共享堆上。</p><p> 共享堆重要事项，因为它会减少在进程之间传递大型二进制消息的IO。创建子二进制文件也很快，因为它们只是指向另一个二进制文件的指针。但是，由于拇指的规则，使用快捷方式更快地拥有成本，其成本是以不困在不良条件的方式陷入困境的方式。还有一些众所周知的建筑模式，用于REFC二进制泄漏问题，FRED Hebbert在他的免费电子书中解释了它们; Erlang愤怒，我认为我无法比他更好地解释它。所以我强烈建议你读它。</p><p>  即使我们使用像Erlang这样的内存本身的语言，也没有任何东西可以防止我们了解如何分配和删除的内存。与Go Language Memory Model文档页面不同，“如果您必须阅读本文档的其余部分以了解程序的行为，您将太聪明。不要聪明。“，我相信我们必须聪明地使我们的系统更快，更安全，有时它不会发生，除非我们深入进入发生的事情。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html">https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/垃圾/">#垃圾</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/garbage/">#garbage</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gc/">#gc</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1050977.html"><img src="http://img2.diglog.com/img/2021/3/thumb_b7c361cdc85b1267bf1c86434b8fc4e3.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1050977.html">联邦调查局瞄准约翰麦克菲的加密货泵和垃圾欺诈 </a></div><span class="my_story_list_date">2021-3-7 10:34</span></div><div class="col-sm"><div><a target="_blank" href="/story/1050738.html"><img src="http://img2.diglog.com/img/2021/3/thumb_70f903fca7d8f23b1f30a0c79bdfb0d4.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1050738.html">看着你的``LitterCam''-AI软件现在可以匹配驾驶者向其车牌上扔垃圾的镜头并自动处以9英镑的罚款 </a></div><span class="my_story_list_date">2021-3-4 2:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1045210.html"><img src="http://img2.diglog.com/img/2021/1/thumb_80b7d7f0a6af56bfd3d7494b02a6aeb1.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1045210.html">新技术将垃圾变成有价值的石墨烯 </a></div><span class="my_story_list_date">2021-1-20 4:58</span></div><div class="col-sm"><div><a target="_blank" href="/story/1041085.html"><img src="http://img2.diglog.com/img/2020/12/thumb_5935b0be431cc8b9acefa66c0c88c93a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1041085.html">3名风险投资人讨论太空垃圾以及他们现在还赌什么 </a></div><span class="my_story_list_date">2020-12-22 2:20</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>