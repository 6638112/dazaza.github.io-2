<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用锈病的划痕（计算机视觉教程）相机校准 Camera Calibration from Scratch Using Rust (Computer Vision Tutorial)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Camera Calibration from Scratch Using Rust (Computer Vision Tutorial)<br/>使用锈病的划痕（计算机视觉教程）相机校准 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-04 01:41:17</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/e886513cb16e43a22e1b701db2ad1425.png"><img src="http://img2.diglog.com/img/2021/6/e886513cb16e43a22e1b701db2ad1425.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Camera calibration is generally understood to be the process of estimating the characteristics of a camera that affect the formation of images of real 3D scenes. Principle among these is the effective focal length of the lens which gives images a wide-angle or telescopic character for a given camera position and scene-being-image. There are a wide range of models used to describe a camera’s image formation behavior. Some are relatively simple with mostly-linear equations of few components and are only adequate to describe simple camera systems.  Others are highly non-linear, featuring high-degree polynomials with many coefficients. Regardless of the camera model, one can use the techniques in this article to calibrate their camera.</p><p>相机校准通常被理解为估算影响真实3D场景图像的相机的特性的过程。其中的原理是透镜的有效焦距，其给定相机位置和场景图像的图像提供广角或伸缩性。有多种型号用于描述相机的图像形成行为。有些是具有少数组件的大多数线性方程相对简单，并且仅适用于描述简单的相机系统。其他是高度非线性的，具有具有许多系数的高度多项式。无论相机模型如何，人们都可以使用本文中的技术来校准其相机。</p><p> Creating a calibration module is no small task; therefore, we&#39;ll be splitting this blog post into three parts. This first part will focus on the theory behind calibration. The  second part will reveal the mathematics, and principles behind calibration, and present a roadmap on creating your own approach. Finally, the  third part will show the results from a self-built calibration module, describing how the module arrives at useful results. For code, you can follow along here, or access the full codebase for this tutorial at the  Tangram Visions Blog repository. With that said, let&#39;s dive in.</p><p> 创建校准模块不是小任务;因此，我们＆＃39; ll将此博客贴在三个部分中。第一个部分将专注于校准背后的理论。第二部分将揭示数学，校准背后的原则，并展示了创造自己的方法的路线图。最后，第三部分将显示自式校准模块的结果，描述模块如何到达有用的结果。对于代码，您可以在此处遵循，或者在Tangram Visions博客存储库中访问本教程的完整代码库。戴着说，让＆＃39;潜水。</p><p>  There are many existing tools one can use to calibrate a camera. These exist both as standalone programs and SDK libraries. Given this, why would you want to write your own camera calibration module? There are some real reasons to do so e.g.: the existing tools may not support the hardware platform or parametric camera models you want to use. Aside from any practical motivations, it’s useful to work through the process of camera calibration to gain a better understanding of what’s happening when you use a tool like  OpenCV. This is especially useful when trying to understand why one of these tools may not be producing a suitable calibration.</p><p>  有许多现有工具可以用于校准相机。这些都存在作为独立程序和SDK库。鉴于此，为什么要写自己的相机校准模块？有一些真正的理由这样做，例如：现有工具可能不支持您要使用的硬件平台或参数相机型号。除了任何实用的动机之外，通过相机校准过程是有用的，以便更好地了解当您使用OpenCV等工具时发生的事情。当试图了解为什么这些工具中的一个可能不产生合适的校准时，这尤其有用。</p><p> Camera calibration is built on a foundation of linear algebra, 3D geometry and non-linear least squares optimization. One need not be an expert in all of these areas, but a basic understanding is necessary. To keep the blog post a reasonable length, some knowledge of linear algebra, the construction and use of 3D transformations, multivariable calculus and optimization (being able to understand a cost function should suffice) techniques is assumed for the result of the article.</p><p> 相机校准基于线性代数，3D几何和非线性最小二乘优化的基础。人们不必成为所有这些领域的专家，但是必要的基本理解。为了保持合理的长度，3D变换的一些知识，3D变换，多变量的微积分和优化（能够理解成本函数的优化（能够理解成本函数）的技术是为了制品的结果。</p><p> The code snippets (largely in Part II) will be in Rust and we’ll be using the  NAlgebra linear algebra crate and the  argmin optimization crate.  The entire example can be found here.</p><p> 代码片段（主要部分在第二部分）将在RERR中，我们将使用Nalgebra Linear代数箱和argmin优化板条箱。这里可以找到整个例子。</p><p>  To begin, we need a mathematical model of the formation of images. This provides a compact formula which approximately describes the relationship of 3D points in the scene to their corresponding 2D pixels in the image, aka  image formation or  projection. Projection is generally thought of in the following way:</p><p>  首先，我们需要一个图像形成的数学模型。这提供了一种紧凑的公式，其大致描述了场景中的3D点与图像中的相应的2D像素，AKA图像形成或投影的关系。预测通常以下列方式思考：</p><p> If a lens is present, the lens will refract (i.e. redirect) the light rays directing them to various pixels which measure the light incident to them during the exposure period.</p><p> 如果存在镜头，镜头将折射（即重定向）将它们指向的光线引导到在曝光时段期间测量入射到它们的光的各种像素。 </p><p> One such model is called the  pinhole model which describes image formation for  pinhole cameras and  camerae obscurae. We will use this model for this post due to its simplicity.</p><p>一种这样的模型被称为针孔模型，该模型描述针孔摄像机和Camerae Obsolae的图像形成。由于其简单性，我们将为这篇文章使用此模型。</p><p> The pinhole model can work for cameras with simple lenses provided they’re highly  rectilinear, but most cameras exhibit some sort of lens distortion which isn’t captured in a model like this. It&#39;s worth noting that most camera models ignore a lot of the real-life complexity of a lens (focus, refraction, etc).</p><p> 针孔模型可以为具有简单镜头的摄像机工作，提供它们的高度直线，但大多数摄像机展示了某种镜头失真，在这样的模型中未被捕获。值得注意的是，大多数相机型号忽略了很多镜头的真实寿命复杂性（焦点，折射等）。</p><p>  In the pinhole model, the camera is said to be at the origin of a camera coordinate system shown in the diagram below. To image a 3D point, you draw a line between the point in question and the camera and see where that line intersects the virtual image plane, which is a model stand-in for the camera&#39;s physical sensor. This  intersection point is then shifted and scaled according to the sensor&#39;s resolution into a pixel location. In the model, the image plane is set in front of the camera (i.e. along the +Z axis) at a distance called the  focal length.</p><p>  在针孔模型中，据说相机位于下图中显示的相机坐标系的起源。要以图像为3D点，您可以在问题和相机之间绘制一条线，并查看该线的位置与虚拟映像平面相交，这是相机＆＃39; S物理传感器的模型站立。然后将该交叉点切换并根据传感器分辨率转换并缩放到像素位置。在该模型中，在称为焦距的距离处，在相机（即沿+ Z轴）的前面设置的图像平面。</p><p>   The trick to deriving the formula for the intersection point from this diagram is to consider just two dimensions at a time. Doing this exposes a  similar triangles relationship between points on the plane and points in the scene.</p><p>   从该图中导出交叉点的公式的技巧是一次考虑两个维度。这样做暴露了平面上的点之间的类似三角形关系和场景中的点。</p><p>      The image plane is not an entirely abstract concept. It represents the actual CMOS sensor or piece of film of the camera. The intersection point is a point on this physical sensor; \\(u_{plane}\\) and \\(v_{plane}\\) are thus described in units of distance from a point on this sensor (e.g. meters). A further transformation which maps this plane location to actual pixels is required.</p><p>      图像平面不是完全抽象的概念。它代表了相机的实际CMOS传感器或薄膜。交叉点是该物理传感器上的一个点;因此，从该传感器上的点（例如米）的距离为单位以距离为单位来描述\\（U_ {平面} \\）和\\（v_ {平面} \\）。需要将该平面位置映射到实际像素的进一步转换。</p><p>  The  principal point: the pixel location that any point on the camera’s Z-axis maps to. The principal point (\(c_x, c_y\)) is usually in the center of the image (e.g. at pixel 320, 240 for a 640x480 image) but often deviates slightly because of small imperfections.</p><p>  主点：像素的Z轴映射上任何点的像素位置。主要点（\（c_xx，c_y \））通常位于图像的中心（例如，用于640x480图像的像素320,240），但由于小的缺陷，通常略微偏离。</p><p> The principal point accounts for the discrepancy between the pixel-space origin and the intersection point. An intersection point on the Z axis will have zero X and Y components and thus projects to \\( (u_{plane}, v_{plane}) = (0,0)\\). Meanwhile, the origin in pixel-space is the upper left hand corner of the sensor.</p><p> 主要点占像素空间原点和交叉点之间的差异。 z轴上的交叉点将具有零x和y组件，因此将项目项目投影到\\（（u_ {plane}，v_ {pherl}）=（0,0）\\）。同时，像素空间中的原点是传感器的左上角。 </p><p>   It’s common in computer vision parlance to group the focal length and pixel pitch terms into one pixel-unit focal length term since they’re usually fixed for a given camera (assuming the lens cannot zoom). It’s also very common to see distinct focal length parameters for the X and Y dimensions \\((f_x, f_y)\\). Historically, this was to account for non-square pixels or for exotic lenses (e.g. anamorphic lenses), but in many scenarios having two focal length parameters isn’t well-motivated and can even be detrimental. This results in the pinhole model in its most common form:</p><p>它在计算机视觉缩略图中是常见的，以将焦距和像素间距术语分组为一个像素单元焦距项，因为它们通常为给定的相机（假设镜头无法缩放）固定。对于x和y尺寸的不同的焦距参数也很常见，\\（（f_x，f_y）\\）。从历史上看，这是为了解释非方形像素或外来镜片（例如变形镜片），但在许多情况下，具有两个焦距参数并不是很好的动机，甚至可以是有害的。这导致针孔模型最常见的形式：</p><p> $$\begin{bmatrix}u_{pix} \\\ v_{pix}\end{bmatrix} =P(\bar{X}; \{ f_x, f_y,c_x,c_y \} )=\begin{bmatrix}f_x \frac{X}{Z} + c_x \\\ f_y \frac{Y}{Z} + c_y\end{bmatrix} $$</p><p> $$ \ begin {bmatrix} u_ {pix} \\\ v_ {pix} \ neg {bmatrix} = p（\ bar {x}; \ {f_x，f_y，c_x，c_y \}）= \ begin {bmatrix} f_x \ frac {x} {z} + c_x \\\ f_y \ frac {y} {z} + c_y \ end {bmatrix} $$</p><p> It is the coefficients \\(f_x, f_y, c_x, c_Y\\) that we hope to estimate using camera calibration, as we will show in the next two parts of this series.</p><p> 我们希望使用相机校准估计的系数\\（f_x，f_y，c_x，c_y \\），因为我们将在本系列的接下来的两个部分中显示。</p><p>  fn project(     params: &amp;na::Vector4&lt;f64&gt;, /*fx, fy, cx, cy*/     pt: &amp;na::Point3&lt;f64&gt;, ) -&gt; na::Point2&lt;f64&gt; {     na::Point2::&lt;f64&gt;::new(         params[0] * pt.x / pt.z + params[2], // fx * x / z + cx         params[1] * pt.y / pt.z + params[3], // fy * y / z + cy     ) }</p><p>  FN项目（参数：＆amp; Na :: Vector44＆lt; / * fx，Fy，Cx，Cy * / Pt：＆amp; na :: point3＆lt; f64＆gt;） - ＆gt; na :: point2＆lt; f64＆gt; {na :: point2 ::＆lt; f64＆gt; :: new（params [0] * pt.x / pt.z + params [2]，// fx * x / z + cx params [1] * pt.y / pt.z + params [3]，// fy * y / z + cy）}</p><p>    At this point, we&#39;ve explained the theory behind camera calibration. We&#39;ll take a break here, and return with the  second part where we dive into the principles, much of the math, and some of the code required to understand creating a calibration module.</p><p>    此时，我们解释了相机校准后的理论。我们＆＃39; ll在这里休息一下，并返回第二部分，我们潜入原则，大部分数学，以及了解创建校准模块所需的一些代码。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.tangramvision.com/blog/calibration-from-scratch-using-rust-part-1-of-3">https://www.tangramvision.com/blog/calibration-from-scratch-using-rust-part-1-of-3</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/相机/">#相机</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/教程/">#教程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/锈病/">#锈病</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>