<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Ky是一个基于浏览器获取API的小巧优雅的HTTP客户端Ky is a tiny and elegant HTTP client based on the browser Fetch API</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Ky is a tiny and elegant HTTP client based on the browser Fetch API<br/>Ky是一个基于浏览器获取API的小巧优雅的HTTP客户端</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-25 15:16:46</div><div class="page_narrow text-break page_content"><p>Ky targets  modern browsers and  Deno. For older browsers, you will need to transpile and use a   fetch polyfill and   globalThis polyfill. For Node.js, check out  Got. For isomorphic needs (like SSR), check out   ky-universal.</p><p>Ky的目标是现代浏览器和Deno。对于较旧的浏览器，您需要传输并使用fetch polyfill和globalThis polyfill。用于节点。js，看看我有什么。对于同构需求（如SSR），请查看ky universal。</p><p>           import  ky  from  &#39;ky&#39; ; const  json  =  await  ky . post ( &#39;https://example.com&#39; ,  { json:  { foo:  true } } ) . json ( ) ; console . log ( json ) ; //=&gt; `{data: &#39;🦄&#39;}`</p><p>从&#39进口ky；肯塔基州；const json=wait ky。帖子（&#39；https://example.com&#39; ,  {json:{foo:true}}）。json（）；安慰日志（json）//=&gt`{数据：&#39；🦄&#39;}`</p><p>  class  HTTPError  extends  Error  { } const  response  =  await  fetch ( &#39;https://example.com&#39; ,  {	 method:  &#39;POST&#39; ,	 body:  JSON . stringify ( { foo:  true } ) ,	 headers:  {		 &#39;content-type&#39;:  &#39;application/json&#39;	 } } ) ; if  ( ! response . ok )  {	 throw  new  HTTPError ( `Fetch error:   ${ response . statusText }` ) ; } const  json  =  await  response . json ( ) ; console . log ( json ) ; //=&gt; `{data: &#39;🦄&#39;}`</p><p>类HTTPError扩展了错误{}const response=wait fetch（&#39；https://example.com&#39; ,  {method:&#39；POST&#39；，body:JSON.stringify（{foo:true}），headers:{&#39；content type&#39；：&#39；application/JSON&#39；}）；如果（！response.ok）{throw new HTTPError（`Fetch error:${response.statusText}`）；}const json=等待响应。json（）；安慰日志（json）//=&gt`{数据：&#39；🦄&#39;}`</p><p> If you are using  Deno, import Ky from a URL. For example, using a CDN:</p><p>如果您使用的是Deno，请从URL导入Ky。例如，使用CDN：</p><p>     The  credentials option is  same-origin by default, which is the default in the spec too, but not all browsers have caught up yet.</p><p>默认情况下，credentials选项是同源的，这也是规范中的默认选项，但并非所有浏览器都能跟上。</p><p> Returns a   Response object with   Body methods added for convenience. So you can, for example, call  ky.get(input).json() directly without having to await the  Response first. When called like that, an appropriate  Accept header will be set depending on the body method used. Unlike the  Body methods of  window.Fetch; these will throw an  HTTPError if the response status is not in the range of  200...299. Also,  .json() will return an empty string if the response status is  204 instead of throwing a parse error due to an empty body.</p><p>返回一个响应对象，为方便起见添加了Body方法。例如，您可以调用ky.get（输入）。直接使用json（），而不必先等待响应。当这样调用时，将根据所使用的body方法设置适当的Accept头。与窗口的主体方法不同。取来如果响应状态不在200。。。299.此外。如果响应状态为204，json（）将返回一个空字符串，而不是由于正文为空而引发解析错误。</p><p>        When using a  Request instance as  input, any URL altering options (such as  prefixUrl) will be ignored.</p><p>当使用请求实例作为输入时，任何URL更改选项（如prefixUrl）都将被忽略。</p><p>      Internally, the standard methods ( GET,  POST,  PUT,  PATCH,  HEAD and  DELETE) are uppercased in order to avoid server errors due to case sensitivity.</p><p>在内部，标准方法（GET、POST、PUT、PATCH、HEAD和DELETE）是大写的，以避免因区分大小写而导致服务器错误。</p><p>   Shortcut for sending JSON. Use this instead of the  body option. Accepts any plain object or value, which will be  JSON.stringify()&#39;d and sent in the body with the correct header set.</p><p>发送JSON的快捷方式。使用此选项而不是body选项。接受任何简单的对象或值，即JSON。stringify（）&#39；d，并以正确的标题集发送到正文中。</p><p>  Type:  string | object&lt;string, string | number | boolean&gt; | Array&lt;Array&lt;string | number | boolean&gt;&gt; | URLSearchParams Default:  &#39;&#39;</p><p>类型：字符串|对象&lt；字符串，字符串|数字|布尔值&gt；|阵列&lt；阵列&lt；字符串|数字|布尔值&gt&gt；|URLSearchParams默认值：&#39&#39;</p><p> Search parameters to include in the request URL. Setting this will override all existing search parameters in the input URL.</p><p>搜索要包含在请求URL中的参数。设置此选项将覆盖输入URL中的所有现有搜索参数。</p><p>    A prefix to prepend to the  input URL when making the request. It can be any valid URL, either relative or absolute. A trailing slash  / is optional and will be added automatically, if needed, when it is joined with  input. Only takes effect when  input is a string. The  input argument cannot start with a slash  / when using this option.</p><p>发出请求时在输入URL前加前缀。它可以是任何有效的URL，无论是相对的还是绝对的。尾随斜杠/是可选的，如果需要，将在与输入连接时自动添加。仅当输入为字符串时生效。使用此选项时，输入参数不能以斜杠/开头。</p><p>  import  ky  from  &#39;ky&#39; ; // On https://example.com const  response  =  await  ky ( &#39;unicorn&#39; ,  { prefixUrl:  &#39;/api&#39; } ) ; //=&gt; &#39;https://example.com/api/unicorn&#39; const  response2  =  await  ky ( &#39;unicorn&#39; ,  { prefixUrl:  &#39;https://cats.com&#39; } ) ; //=&gt; &#39;https://cats.com/unicorn&#39;</p><p>从&#39进口ky；肯塔基州&#39；；//在…上https://example.comconst response=wait ky（&#39；unicorn&#39；，{prefixUrl:&#39；/api&#39；}）//=&gt&#39;https://example.com/api/unicorn&#39; const response2=wait ky（&#39；独角兽&#39；，{prefixUrl:&#39；https://cats.com&#39; } ) ; //=&gt&#39;https://cats.com/unicorn&#39;</p><p>  After  prefixUrl and  input are joined, the result is resolved against the  base URL of the page (if any).</p><p>prefixUrl和input连接后，根据页面的基本URL（如果有）解析结果。</p><p> Leading slashes in  input are disallowed when using this option to enforce consistency and avoid confusion about how the  input URL is handled, given that  input will not follow the normal URL resolution rules when  prefixUrl is being used, which changes the meaning of a leading slash.</p><p>如果使用此选项来增强一致性并避免对输入URL的处理方式产生混淆，则不允许在输入中使用前导斜杠，因为在使用prefixUrl时，输入不会遵循正常的URL解析规则，这会更改前导斜杠的含义。</p><p>    An object representing  limit,  methods,  statusCodes and  maxRetryAfter fields for maximum retry count, allowed methods, allowed status codes and maximum   Retry-After time.</p><p>表示最大重试次数、允许的方法、允许的状态代码和最大重试时间的限制、方法、状态代码和maxRetryAfter字段的对象。</p><p> If  retry is a number, it will be used as  limit and other defaults will remain in place.</p><p>如果retry是一个数字，它将被用作限制，其他默认值将保持不变。</p><p> If  maxRetryAfter is set to  undefined, it will use  options.timeout. If   Retry-After header is greater than  maxRetryAfter, it will cancel the request.</p><p>如果maxRetryAfter设置为undefined，它将使用选项。暂停。如果Retry After标头大于maxRetryAfter，它将取消请求。</p><p> Delays between retries is calculated with the function  0.3 * (2 ** (retry - 1)) * 1000, where  retry is the attempt number (starts from 1).</p><p>使用函数0.3*（2**（retry-1））*1000计算重试之间的延迟，其中retry是尝试次数（从1开始）。</p><p>  import  ky  from  &#39;ky&#39; ; const  json  =  await  ky ( &#39;https://example.com&#39; ,  {	 retry:  {		 limit:  10 ,		 methods:  [ &#39;get&#39; ] ,		 statusCodes:  [ 413 ]	 } } ) . json ( ) ;</p><p>从&#39进口ky；肯塔基州；const json=wait ky（&#39；https://example.com&#39; ,  {重试：{limit:10，methods:[&#39；get&#39；]，状态代码：[413]}）。json（）；</p><p>   Timeout in milliseconds for getting a response, including any retries. Can not be greater than 2147483647.If set to  false, there will be no timeout.</p><p>获取响应（包括重试）的超时（毫秒）。不能大于2147483647。如果设置为false，则不会超时。</p><p>   Hooks allow modifications during the request lifecycle. Hook functions may be async and are run serially.</p><p>钩子允许在请求生命周期中进行修改。钩子函数可以是异步的，并且可以串行运行。</p><p>   This hook enables you to modify the request right before it is sent. Ky will make no further changes to the request after this. The hook function receives  request and  options as arguments. You could, for example, modify the  request.headers here.</p><p>这个钩子使您能够在发送请求之前修改请求。在这之后，Ky不会对请求做进一步的更改。钩子函数接收请求和选项作为参数。例如，您可以修改请求。这里是标题。</p><p> The hook can return a   Request to replace the outgoing request, or return a   Response to completely avoid making an HTTP request. This can be used to mock a request, check an internal cache, etc. An  important consideration when returning a request or response from this hook is that any remaining  beforeRequest hooks will be skipped, so you may want to only return them from the last hook.</p><p>钩子可以返回一个请求来替换传出的请求，或者返回一个响应来完全避免发出HTTP请求。这可以用来模拟请求、检查内部缓存等。从这个钩子返回请求或响应时，一个重要的考虑因素是，将跳过所有剩余的beforeRequest钩子，因此您可能只希望从最后一个钩子返回它们。</p><p> import  ky  from  &#39;ky&#39; ; const  api  =  ky . extend ( {	 hooks:  {		 beforeRequest:  [			 request  =&gt;  {				 request . headers . set ( &#39;X-Requested-With&#39; ,  &#39;ky&#39; ) ;			 }		 ]	 } } ) ; const  response  =  await  api . get ( &#39;https://example.com/api/users&#39; ) ;</p><p>从&#39进口ky；肯塔基州；常数api=ky。扩展（{hooks:{beforeRequest:[request=&gt；{request.headers.set（&#39；X-request-With&#39；，&#39；ky&#39；）；			 }		 ]	 } } ) ; const response=等待api。获得（&#39；https://example.com/api/users&#39; ) ;</p><p>   This hook enables you to modify the request right before retry. Ky will make no further changes to the request after this. The hook function receives an object with the normalized request and options, an error instance, and the retry count. You could, for example, modify  request.headers here.</p><p>这个钩子允许您在重试之前修改请求。在这之后，Ky不会对请求做进一步的更改。钩子函数接收一个带有规范化请求和选项的对象、一个错误实例和重试计数。例如，您可以修改请求。这里是标题。</p><p> If the request received a response, the error will be of type  HTTPError and the  Response object will be available at  error.response. Be aware that some types of errors, such as network errors, inherently mean that a response was not received. In that case, the error will not be an instance of  HTTPError.</p><p>如果请求收到响应，则错误类型为HTTPError，并且响应对象在出现错误时可用。回答请注意，某些类型的错误（如网络错误）本质上意味着未收到响应。在这种情况下，错误将不是HTTPError的实例。</p><p> You can prevent Ky from retrying the request by throwing an error. Ky will not handle it in any way and the error will be propagated to the request initiator. The rest of the  beforeRetry hooks will not be called in this case. Alternatively, you can return the   ky.stop symbol to do the same thing but without propagating an error (this has some limitations, see  ky.stop docs for details).</p><p>您可以通过抛出错误来防止Ky重试请求。Ky不会以任何方式处理它，错误将传播到请求发起方。在这种情况下，不会调用beforeRetry钩子的其余部分。或者，您可以返回ky.stop符号来执行相同的操作，但不会传播错误（这有一些限制，请参阅ky.stop docs了解详细信息）。</p><p> import  ky  from  &#39;ky&#39; ; const  response  =  await  ky ( &#39;https://example.com&#39; ,  {	 hooks:  {		 beforeRetry:  [			 async  ( {request , options , error , retryCount } )  =&gt;  {				 const  token  =  await  ky ( &#39;https://example.com/refresh-token&#39; ) ;				 request . headers . set ( &#39;Authorization&#39; ,  `token   ${ token }` ) ;			 }		 ]	 } } ) ;</p><p>从&#39进口ky；肯塔基州；const response=wait ky（&#39；https://example.com&#39; ,  {hooks:{beforetry:[async（{request，options，error，retryCount}）=&gt；{const token=wait ky（&#39；https://example.com/refresh-token&#39; ) ;要求标题。set（&#39；Authorization&#39；，`token${token}`）；			 }		 ]	 } } ) ;</p><p>   This hook enables you to modify the  HTTPError right before it is thrown. The hook function receives a  HTTPError as an argument and should return an instance of  HTTPError.</p><p>这个钩子允许您在抛出HTTPError之前修改它。钩子函数接收HTTPError作为参数，并应返回HTTPError的实例。</p><p> import  ky  from  &#39;ky&#39; ; await  ky ( &#39;https://example.com&#39; ,  {	 hooks:  {		 beforeError:  [			 error  =&gt;  {				 const  {response }  =  error ;				 if  ( response  &amp;&amp;  response . body )  {					 error . name  =  &#39;GitHubError&#39; ;					 error . message  =  `  ${ response . body . message } (  ${ response . statusCode })` ;				 }				 return  error ;			 }		 ]	 } } ) ;</p><p>从&#39进口ky；肯塔基州；等待ky（&#39；https://example.com&#39; ,  {hooks:{beforeError:[error=&gt；{const{response}=error；if（response&amp；response.body）{error.name=&#39；GitHubError&#39；error.message=`response.body.message}（${response.statusCode}）`return error；}）；</p><p>   This hook enables you to read and optionally modify the response. The hook function receives normalized request, options, and a clone of the response as arguments. The return value of the hook function will be used by Ky as the response object if it&#39;s an instance of   Response.</p><p>这个钩子使您能够读取并有选择地修改响应。钩子函数接收规范化的请求、选项和响应的克隆作为参数。Ky将使用钩子函数的返回值作为响应对象，如果它&#39；这是一个回应的例子。</p><p> import  ky  from  &#39;ky&#39; ; const  response  =  await  ky ( &#39;https://example.com&#39; ,  {	 hooks:  {		 afterResponse:  [			 ( _request ,  _options ,  response )  =&gt;  {				 // You could do something with the response, for example, logging.				 log ( response ) ;				 // Or return a `Response` instance to overwrite the response.				 return  new  Response ( &#39;A different response&#39; ,  { status:  200 } ) ;			 } ,			 // Or retry with a fresh token on a 403 error			 async  ( request ,  options ,  response )  =&gt;  {				 if  ( response . status  ===  403 )  {					 // Get a fresh token					 const  token  =  await  ky ( &#39;https://example.com/token&#39; ) . text ( ) ;					 // Retry with the token					 request . headers . set ( &#39;Authorization&#39; ,  `token   ${ token }` ) ;					 return  ky ( request ) ;				 }			 }		 ]	 } } ) ;</p><p>从&#39进口ky；肯塔基州；const response=wait ky（&#39；https://example.com&#39; ,  {hooks:{afterResponse:[（_-request，_-options，response）=&gt；{//您可以对响应执行一些操作，例如logging.log（response）；//或者返回一个'response'实例来覆盖响应。返回新的响应（&#39；另一个响应&#39；，{status:200}） ;}、//或在403错误异步（请求、选项、响应）=&gt；{if（response.status==403）{//Get a fresh token const token=wait ky（&#39；https://example.com/token&#39; ) . 文本（）；//使用令牌请求重试。标题。set（&#39；Authorization&#39；，`token${token}`）；返回ky（请求）；				 }			 }		 ]	 } } ) ;</p><p>   Throw an  HTTPError when, after following redirects, the response has a non-2xx status code. To also throw for redirects instead of following them, set the   redirect option to  &#39;manual&#39;.</p><p>在执行重定向后，如果响应具有非2xx状态代码，则抛出HTTPError。要同时抛出重定向而不是跟随重定向，请将重定向选项设置为&#39；手册&#39；。</p><p> Setting this to  false may be useful if you are checking for resource availability and are expecting error responses.</p><p>如果您正在检查资源可用性，并且希望得到错误响应，那么将此设置为false可能会很有用。</p><p> Note: If  false, error responses are considered successful and the request will not be retried.</p><p>注意：如果为false，则错误响应被视为成功，请求将不会重试。</p><p>     The  progress object contains the following elements:  percent,  transferredBytes and  totalBytes. If it&#39;s not possible to retrieve the body size,  totalBytes will be  0.</p><p>progress对象包含以下元素：percent、transferredBytes和totalBytes。如果是&#39；如果无法检索正文大小，则totalBytes将为0。</p><p> import  ky  from  &#39;ky&#39; ; const  response  =  await  ky ( &#39;https://example.com&#39; ,  {	 onDownloadProgress:  ( progress ,  chunk )  =&gt;  {		 // Example output:		 // `0% - 0 of 1271 bytes`		 // `100% - 1271 of 1271 bytes`		 console . log ( `  ${ progress . percent  *  100 }% -   ${ progress . transferredBytes } of   ${ progress . totalBytes } bytes` ) ;	 } } ) ;</p><p>从&#39进口ky；肯塔基州；const response=wait ky（&#39；https://example.com&#39; ,  {onDownloadProgress:（progress，chunk）=&gt；{//示例输出：//`0%-0/1271字节`/`100%-1271字节`控制台.log（${progress.percent*100}%-${progress.transferredBytes}的${progress.totalBytes}字节`）；	 } } ) ;</p><p>      import  ky  from  &#39;ky&#39; ; import  bourne  from  &#39;@hapijs/bourne&#39; ; const  json  =  await  ky ( &#39;https://example.com&#39; ,  {	 parseJson:  text  =&gt;  bourne ( text ) } ) . json ( ) ;</p><p>从&#39进口ky；肯塔基州；从&#39进口伯恩@哈皮克斯/伯恩&#39；const json=wait ky（&#39；https://example.com&#39; ,  {parseJson:text=&gt；伯恩（text）}）。json（）；</p><p>           You can remove a header with  .extend() by passing the header with an  undefined value.Passing  undefined as a string removes the header only if it comes from a  Headers instance.</p><p>可以使用删除标题。extend（）通过传递带有未定义值的标头。仅当头来自Headers实例时，以字符串形式传递undefined会移除头。</p><p> import  ky  from  &#39;ky&#39; ; const  url  =  &#39;https://sindresorhus.com&#39; ; const  original  =  ky . create ( {	 headers:  {		 rainbow:  &#39;rainbow&#39; ,		 unicorn:  &#39;unicorn&#39;	 } } ) ; const  extended  =  original . extend ( {	 headers:  {		 rainbow:  undefined	 } } ) ; const  response  =  await  extended ( url ) . json ( ) ; console . log ( &#39;rainbow&#39;  in  response ) ; //=&gt; false console . log ( &#39;unicorn&#39;  in  response ) ; //=&gt; true</p><p>从&#39进口ky；肯塔基州；const url=&#39；https://sindresorhus.com&#39; ; const original=ky。创建（{headers:{rainbow:&#39；rainbow&#39；，unicorn:&#39；unicorn&#39；}）；常量扩展=原始。扩展（{headers:{rainbow:undefined}}）；const response=await extended（url）。json（）；安慰日志（&#39；彩虹&#39；回应）//=&gt；假控制台。日志（&#39；独角兽&#39；回应）//=&gt；符合事实的</p><p>   import  ky  from  &#39;ky&#39; ; // On https://my-site.com const  api  =  ky . create ( { prefixUrl:  &#39;https://example.com/api&#39; } ) ; const  response  =  await  api . get ( &#39;users/123&#39; ) ; //=&gt; &#39;https://example.com/api/users/123&#39; const  response  =  await  api . get ( &#39;/status&#39; ,  { prefixUrl:  &#39;&#39; } ) ; //=&gt; &#39;https://my-site.com/status&#39;</p><p>从&#39进口ky；肯塔基州&#39；；//在…上https://my-site.com常数api=ky。创建（{prefixUrl:&#39；https://example.com/api&#39; } ) ; const response=等待api。获取（&#39；用户/123&#39；）//=&gt&#39;https://example.com/api/users/123&#39; const response=等待api。get（&#39；/status&#39；，{prefixUrl:&#39；&#39；}）//=&gt&#39;https://my-site.com/status&#39;</p><p>    A  Symbol that can be returned by a  beforeRetry hook to stop the retry. This will also short circuit the remaining  beforeRetry hooks.</p><p>可由beforeRetry挂钩返回以停止重试的符号。这也会在重试前使剩余的挂钩短路。</p><p> Note: Returning this symbol makes Ky abort and return with an  undefined response. Be sure to check for a response before accessing any properties on it or use  optional chaining. It is also incompatible with body methods, such as  .json() or  .text(), because there is no response to parse. In general, we recommend throwing an error instead of returning this symbol, as that will cause Ky to abort and then throw, which avoids these limitations.</p><p>注意：返回此符号将导致Ky中止，并返回未定义的响应。在访问响应上的任何属性或使用可选链接之前，请确保检查响应。它也与身体方法不兼容，例如。json（）或。text（），因为没有解析响应。通常，我们建议抛出一个错误，而不是返回这个符号，因为这将导致Ky中止，然后抛出，从而避免这些限制。</p><p> A valid use-case for  ky.stop is to prevent retries when making requests for side effects, where the returned data is not important. For example, logging client activity to the server.</p><p>ky.stop的一个有效用例是防止在请求副作用时重试，因为返回的数据并不重要。例如，将客户端活动记录到服务器。</p><p> import  ky  from  &#39;ky&#39; ; const  options  =  {	 hooks:  {		 beforeRetry:  [			 async  ( {request , options , error , retryCount } )  =&gt;  {				 const  shouldStopRetry  =  await  ky ( &#39;https://example.com/api&#39; ) ;				 if  ( shouldStopRetry )  {					 return  ky . stop ;				 }			 }		 ]	 } } ; // Note that response will be `undefined` in case `ky.stop` is returned. const  response  =  await  ky . post ( &#39;https://example.com&#39; ,  options ) ; // Using `.text()` or other body methods is not supported. const  text  =  await  ky ( &#39;https://example.com&#39; ,  options ) . text ( ) ;</p><p>从&#39进口ky；肯塔基州；const options={hooks:{beforeRetry:[async（{request，options，error，retryCount}）=&gt；{const shouldStopRetry=wait ky（&#39；https://example.com/api&#39; ) ;if（shouldStopRetry）{return ky.stop；}}}]}；//请注意，如果返回'ky.stop'，响应将为'undefined'。const response=wait ky。帖子（&#39；https://example.com&#39; ,  选项）；//使用`。text（）`或其他正文方法不受支持。const text=wait ky（&#39；https://example.com&#39; ,  选项）。文本（）；</p><p>  Exposed for  instanceof checks. The error has a  response property with the   Response object,  request property with the   Request object, and  options property with normalized options (either passed to  ky when creating an instance with  ky.create() or directly when performing the request).</p><p>暴露在检查的瞬间。该错误具有响应对象的response属性、请求对象的request属性和规范化选项的options属性（在使用ky.create（）创建实例时传递给ky，或者在执行请求时直接传递给ky）。</p><p>  The error thrown when the request times out. It has a  request property with the   Request object.</p><p>请求超时时引发的错误。它具有请求对象的请求属性。</p><p>   Sending form data in Ky is identical to  fetch. Just pass a   FormData instance to the  body option. The  Content-Type header will be automatically set to  multipart/form-data.</p><p>以Ky格式发送表单数据与获取相同。只需将FormData实例传递给body选项。内容类型标题将自动设置为多部分/表单数据。</p><p> import  ky  from  &#39;ky&#39; ; // `multipart/form-data` const  formData  =  new  FormData ( ) ; formData . append ( &#39;food&#39; ,  &#39;fries&#39; ) ; formData . append ( &#39;drink&#39; ,  &#39;icetea&#39; ) ; const  response  =  await  ky . post ( url ,  { body:  formData } ) ;</p><p>从&#39进口ky；肯塔基州&#39；；//`多部分/表单数据`const formData=new formData（）；formData。附加（&#39；食物&#39；，&#39；薯条&#39；）；formData。追加（&#39；饮料&#39；，&#39；冰茶&#39；）；const response=wait ky。post（url，{body:formData}）；</p><p> If you want to send the data in  application/x-www-form-urlencoded format, you will need to encode the data with   URLSearchParams.</p><p>如果要以application/x-www-form-urlencoded格式发送数据，则需要使用urlsearchparms对数据进行编码。</p><p> import  ky  from  &#39;ky&#39; ; // `application/x-www-form-urlencoded` const  searchParams  =  new  URLSearchParams ( ) ; searchParams . set ( &#39;food&#39; ,  &#39;fries&#39; ) ; searchParams . set ( &#39;drink&#39; ,  &#39;icetea&#39; ) ; const  response  =  await  ky . post ( url ,  { body:  searchParams } ) ;</p><p>从&#39进口ky；肯塔基州&#39；；//`application/x-www-form-urlencoded`const searchParams=new URLSearchParams（）；搜索参数。套餐（&#39；食物&#39；&#39；薯条&#39；）；搜索参数。套餐（&#39；饮料&#39；&#39；冰茶&#39；）；const response=wait ky。post（url，{body:searchParams}）；</p><p>  Fetch (and hence Ky) has built-in support for request cancellation through the   AbortController API.  Read more.</p><p>Fetch（因此也是Ky）通过AbortController API内置了对请求取消的支持。阅读更多。</p><p>  import  ky  from  &#39;ky&#39; ; const  controller  =  new  AbortController ( ) ; const  {signal }  =  controller ; setTimeout ( ( )  =&gt;  {	 controller . abort ( ) ; } ,  5000 ) ; try  {	 console . log ( await  ky ( url ,  {signal } ) . text ( ) ) ; }  catch  ( error )  {	 if  ( error . name  ===  &#39;AbortError&#39; )  {		 console . log ( &#39;Fetch aborted&#39; ) ;	 }  else  {		 console . error ( &#39;Fetch error:&#39; ,  error ) ;	 } }</p><p>从&#39进口ky；肯塔基州；const controller=new AbortController（）；const{signal}=控制器；设置超时（（）=&gt；{controller.abort（）；}，5000 ) ; 尝试{console.log（等待ky（url，{signal}）。text（）；}catch（error）{if（error.name==&#39；abortror&#39；）{console.log（&#39；Fetch aborted&#39；）；}else{console.error（&#39；Fetch error:&#39；error）；}</p><p>    How do I use this with a web app (React, Vue.js, etc.) that uses server-side rendering (SSR)?</p><p>如何将其用于使用服务器端渲染（SSR）的web应用程序（React、Vue.js等）？</p><p>   Either use a test runner that can run in the browser, like Mocha, or use  AVA with  ky-universal.  Read more.</p><p>要么使用可以在浏览器中运行的测试运行程序，比如Mocha，要么使用AVA和ky universal。阅读更多。</p><p>  Make sure your code is running as a JavaScript module (ESM), for example by using a  &lt;script type=&#34;module&#34;&gt; tag in your HTML document. Then Ky can be imported directly by that module without a bundler or other tools.</p><p>确保代码作为JavaScript模块（ESM）运行，例如使用&lt；脚本类型=&#34；模块34&gt；在HTML文档中添加标签。然后，该模块可以直接导入Ky，而无需绑定器或其他工具。</p><p>         It&#39;s just a random short npm package name I managed to get. It does, however, have a meaning in Japanese:</p><p>它&#39；这只是我设法得到的一个随机简短的npm包名。然而，它在日语中有一个含义：</p><p> A form of text-able slang, KY is an abbreviation for 空気読めない (kuuki yomenai), which literally translates into “cannot read the air.” It&#39;s a phrase applied to someone who misses the implied meaning.</p><p>KY是一种可用于文本的俚语，是空気読めない （kuuki yomenai），字面意思是“看不见空气”它&#39；这是一个短语，用来形容没有领会其中隐含的意思的人。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/获取/">#获取</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tiny/">#tiny</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/请求/">#请求</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>