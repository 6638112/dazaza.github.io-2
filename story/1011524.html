<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>“元循环评估者”(1998)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">“元循环评估者”(1998)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-07-13 23:25:26</div><div class="page_narrow text-break page_content"><p>我们将接受迟交的习题集，不加分(就像你在5月1日之前交上一样)，直到5月8日(星期五)下午4点。</p><p>注：本作业中涉及的概念和问题实际上是保证会出现在第二次初稿和期末考试中的那类东西。确保你理解每个问题--现在不是过度依赖合作伙伴的时候。</p><p>在新的NOODLLE中，评估(加载ps6)。为了熟悉习题集，请尝试在解释器中计算(+12)。请阅读下面提供的特殊形式和原语的列表。</p><p>在本习题集中，您将修改一个用类似Dylan的语言计算表达式的程序。为了使评估器编写时使用的语言和评估器评估的语言保持不同，我们将其称为解释型语言布伦达(Brenda)。求值器重复从用户读入表达式，根据Brenda编程语言的规则对表达式求值，并打印出求值的表达式。我们称此循环为读取-求值-打印循环。以下是Brenda解释器中读取-求值-打印循环的Dylan代码：</p><p>(定义read-eval-print-loop(method()(bind((raw(Read))(result(brenda-eval raw*brenda-global-Environment*)(print&#34；brenda？&#34；raw)(print&#34；brenda==&gt；&#34；result)(read-eval-print-loop)。</p><p>在这个级别上，解释器非常容易理解，但是要更详细地理解它，我们需要了解两件事：brenda-eval泛型函数和*brenda-global-Environment*的结构。</p><p>brenda-eval泛型函数提供了元循环计算器的大部分功能。正如您从表达式求值的环境模型中回忆的那样，不同类型的对象以不同的方式求值。大多数对象都对自身求值，如&lt；String&gt；s、&lt；number&gt；s、&lt；Empty-list&gt；s和&lt；Boolean&gt；s，无论它们在什么环境中求值。当评估&lt；符号&gt；对象时，解释器会在评估它们的环境中查找它们的值。最后，通过计算组合的第一个元素并将函数应用于组合中的其余元素来计算&lt；对&gt；对象(组合或非空列表)。此功能由Brenda-Apply处理。以下是brenda.dyl中brenda-eval的代码。</p><p>(Define-Generic-Function Brenda-eval((obj&lt；object&gt；)(env&lt；brenda-frame&gt；)；；大多数类型的对象都会自我求值。(add-method brenda-eval(method((obj&lt；object&gt；)(env&lt；brenda-frame&gt；)obj))；；评估符号会导致查找其关联值。(Add-Method Brenda-eval(Method((obj&lt；Symbol&&gt;)(env&lt；Brenda-Frame&gt；))(查找obj env)；；评估一对调用brenda-Apply。(add-method brenda-eval(method((obj&lt；air&gt；)(env&lt；brenda-frame&gt；))(brenda-Apply(brenda-eval(Head Obj)env)(Ail Obj)env))</p><p>如您所见，brenda-eval的代码非常短。请注意，调用brenda-Apply时使用了一系列未计算的参数！(这是为了让我们可以正确地实现特殊表单。)。</p><p>无论何时评估组合，brenda-Apply泛型函数都会由brenda-eval调用。在Brenda中，就像在Dylan中一样，有三种对象可以位于组合的开头：用户定义的方法、特殊形式和原始方法。我们将用Dylan类在Brenda中表示这些不同类型的函数。以下是这些对象的类型定义：</p><p>；所有可以应用参数的对象都是函数(DEFINE-CLASS&lt；Brenda-Function&gt；(&lt；object&gt；))；方法具有固定数量的类型化参数并计算它们的参数(DEFINE-CLASS&lt；Brenda-Method&gt；(&lt；Brenda-Function&gt；)(params&lt；list&gt；))；；用户方法是使用方法特殊形式(DEFINE-CLASS&lt；brt；brt；)创建的方法。)(Body&lt；list&gt；)(env&lt；brenda-frame&gt；)。</p><p>；；基元是用户不能用布伦达表达的低级功能。(定义类&lt；brenda-primitive&gt；(&lt；brenda-method&gt；)(调用&lt；函数&gt；)。</p><p>；特殊表格(如DEFINE)不遵循正常评估规则。(定义类&lt；布伦达-特殊表单&gt；(&lt；布伦达-函数&gt；)(调用&lt；函数&gt；)。</p><p>请注意，&lt；brenda-primitive&gt；s和&lt；brenda-user-method&gt；都必须是&lt；brenda-method&gt；的实例，因为它们都计算其参数。作为&lt；brenda-method&gt；实例的对象有一个params槽，它是该方法具有的参数列表。用Dylan代码对原语方法进行了模拟。&lt；brenda-primitive&gt；的调用槽是一个可以模拟特定原语功能的Dylan函数。因为基元总是计算它们的参数，所以我们使用计算过的Brenda参数调用Dylan函数。a&lt；brenda-Special-form&gt；对象有一个类似于&lt；brenda-primitive&gt；的调用槽。此槽引用模拟特殊表单功能的Dylan函数。使用未计算的Brenda参数调用此Dylan函数。</p><p>a&lt；brenda-user-method&gt；是我们在环境模型中使用的闭包对象的Dylan实现。它们有三个插槽：参数、主体和环境。params只是该方法具有的参数列表。Body是应用方法时要计算的表达式列表。环境是定义方法的环境。下面将讨论操纵环境的方式。</p><p>Brenda-Apply Then是一个具有三种主要情况的泛型函数，分别对应于Brenda中的每种函数对象类型。以下是Brenda-Apply每种情况的代码：</p><p>(Define-Generic-Function Brenda-Apply((obj&lt；object&&gt;)(args&lt；list&&gt;)(env&lt；brenda-frame&&gt;)；；默认情况是错误(add-method brenda-Apply(method((obj&lt；object&&gt;)(args&lt；list&&gt;)(env&lt；Brenda-frame&&gt;))(Brenda。OBJ)；；原语；；评估原语所在环境中的参数；；调用。应用执行原语工作的Dylan函数；；仅在验证参数满足；；参数的类型约束之后。(add-method brenda-Apply(method((obj&lt；brenda-primitive&gt；)(args&lt；list&gt；)(env&lt；brenda-frame&gt；))(bind((Evaluated-args&lt；list&gt；)(map(method(X)(brenda-eval xenv))args)(args-params-Match？(Params Obj)Evaluated-args)(Apply(Call Obj)Evaluated-args)；；特殊表单；；仅应用执行特殊表单工作的Dylan函数；；不计算参数。假定特殊表单将执行；；类型检查。(add-method brenda-Apply(method((obj&lt；brenda-Special-form&gt；)(args&lt；list&gt；)(env&lt；brenda-frame&gt；)((Call Obj)args env)；；User Methods；；使用包含；；参数绑定的自变量的框架扩展定义方法的环境。在这个新的环境中评估身体。(Add-Method Brenda-Apply(Method((obj&lt；Brenda-user-method&gt；)(args&lt；list&gt；)(e&lt；brenda-frame&gt；))(bind(Evaluated-args&lt；list&gt；)(map(method(X)(brenda-eval xe))args)(args-params-Match？(Params Obj)Evaluated-args)(bind((new-env(Expand-Environment(Params Obj)Evaluated-args(Env Obj)(eval-equence(Body Obj)new-env)。</p><p>除了应用用户定义的方法之外，每个Brenda-Apply案例都非常简单。用户方法的应用分两个步骤执行。首先，使用包含绑定到参数的变量的新框架扩展定义该方法的环境。然后在这个新环境中对方法体进行评估。brenda-Apply代码利用了一些帮助器函数，如在brenda.dyl中定义的eval-equence、brenda-error和args-params-match？</p><p>在环境模型中，环境被定义为帧的有序列表。框架被定义为一组无序的绑定，而绑定是名称(符号)和值(对象)的关联。根据这些定义，我们可以使用classes.dyl中的以下代码提供相当自然的环境实现：</p><p>(定义类&lt；布伦达-帧&&gt;(&lt；对象&&gt;)(绑定&lt；列表&&gt;))(定义类&lt；布伦达-本地-帧&&gt;(&lt；布伦达-帧&&gt;)(前&lt；布伦达-帧&&gt;))(定义-类&lt；布伦达-全局-帧&&gt;(&lt；布伦达-帧&&gt;；)(变量&lt；符号&gt；)(值&lt；对象&gt；)。</p><p>虽然我们对帧的定义很简单，但是我们希望在环境结构上执行许多操作，例如查找绑定、查找名称和更改绑定的值。在文件frames.dyl中，有许多定义和帮助器函数提供此功能。以下是frames.dyl中为您提供的功能摘要：</p><p>在环境结构中查找具有给定名称的&lt；Brenda-binding&gt；对象。如果未找到，则返回#f。</p><p>在环境结构中查找与给定名称关联的值。如果未找到，则生成错误。</p><p>给定环境、参数列表和参数列表，将返回在给定环境之上构建的新环境，并将参数绑定到参数。</p><p>在解释器内部，我们必须有一种方法来强制方法、定义和绑定语句中的类型约束。不幸的是，解释器中的一些对象用其对应的Dylan对象表示，而另一些则使用Dylan结构更抽象地表示。例如，Brenda中的符号用Dylan&lt；符号&gt；对象表示。Brenda方法不是用Dylan&lt；方法&gt；对象表示的；它是用&lt；brenda-user-method&gt；实例表示的。</p><p>因为我们在解释器中有用不同种类的Dylan对象(一些本地数据、一些Dylan结构)表示的对象，所以我们将把每种类型的对象映射到一个关联的Brenda类对象。Brenda类对象将用Dylan结构表示，并且将有一个槽：超类，它将引用其超类：</p><p>我们将在Dylan中为Brenda中需要的每种类定义全局变量：</p><p>(定义Brenda-Object-class(make-Brenda-class()；；Type&lt；object&gt；(定义Brenda-type-class(make-Brenda-class；；Type&lt；type&gt；(list Brenda-object-class)(定义Brenda-class-class(make-Brenda-class；；Type&lt；class&gt；(list Brenda-type-class))。</p><p>；；Number Class(定义Brenda-Number-class(make-Brenda-class；；Type&lt；Number&gt；(list Brenda-object-class)(定义Brenda-Integer-class(make-Brenda-class；；Type&lt；Integer&gt；(list Brenda-Number-class)(定义Brenda-Float-class(make-Brenda-class；；Type&lt；Float&gt；(list Brenda-Number-class))。</p><p>；方法类(定义Brenda-function-class(make-Brenda-class；；Type&lt；function&gt；(list Brenda-object-class)(定义Brenda-Method-class(make-Brenda-class；；Type&lt；method&gt；(list Brenda-function-class))。</p><p>；；List Class(定义Brenda-List-class(make-Brenda-class；；Type&lt；list&gt；(list Brenda-object-class)(定义Brenda-Pair-class(make-Brenda-class；；Type&lt；Pair&gt；(list Brenda-list-class)(定义Brenda-Empty-List-class(make-Brenda-class；；Type&lt；Empty-List&gt；(list Brenda-List-class))。</p><p>；；String class(定义Brenda-String-class(make-Brenda-class；；Type&lt；String&gt；(list Brenda-object-class)(定义Brenda-character-class(make-Brenda-class；；Type&lt；character&gt；(list Brenda-object-class))</p><p>然后，我们将有一个泛型函数brenda-get-class来告诉我们上面的哪些类应该与解释器使用的每种数据相关联。例如，brenda-function-class将是与&lt；brenda-Special-form&gt；关联的Brenda类，而brenda-symbol-class将是与&lt；符号&gt；关联的Brenda类。</p><p>(定义-泛型函数brenda-get-class(Obj))(add-method brenda-get-class(method((obj&lt；object&gt；)brenda-object-class)(add-method brenda-get-class(method((obj&lt；brenda-class&&gt;))brenda-class-class))(add-method brenda-get-class(method(obj&lt；brenda-primitive&gt；))。Brenda-Special-Form&&gt;))Brenda-function-class))(add-method brenda-get-class(method((obj&lt；brenda-user-method&gt；))brenda-method-class))(add-method brenda-get-class(method((obj&lt；boolean&&gt;))brenda-boolean-class))(add-method brenda-get-class(method((obj&lt；boolean&&gt;))(add-method brenda-get-class(method((obj&lt；boolean&&gt;)(add-method brenda-get-class(method((obj&lt；boolean&&gt;)。Pair&gt；))Brenda-Pair-class))(add-method brenda-get-class(method((obj&lt；Empty-list&gt；))brenda-Empty-list-class))(add-method brenda-get-class(method((obj&lt；Float&&gt;))Brenda-Float-class))(add-method Brenda-get-class(method(obj&lt；Integer&&gt;t；))Brenda-Integer。))brenda-string-class))(add-method brenda-get-class(method((obj&lt；Symbol&gt；))brenda-Symbol-class)。</p><p>现在，给定解释器中的任何对象，我们都可以找出它与哪个&lt；brenda-class&gt；相关联。在我们了解类型检查的工作原理之前，我们需要定义另一个称为subclass？的帮助器函数。子类？取两个&lt；Brenda-class&gt；ES，并确定第一个是否是第二个的子类。</p><p>(定义子类？；；B是A的子类吗？(method((a&lt；Brenda-class&&gt;))(b&lt；Brenda-class&&gt;))(if(id？a b)#t(orn(map(方法(A1)(子类？a1b))(超类a)。</p><p>现在，为了确定解释器中的对象o是否是某个&lt；brenda-class&gt；x的实例，我们找到对象o的类，并检查o的类是否是x的子类：</p><p>我们用布伦达-实例？在解释器中强制类型约束。我们不必强制使用单例类型，因为Brenda不支持它们。</p><p>有七个不同的源文件，您需要更改哪些源文件才能在Brenda中实现一些新功能，这可能会让人感到困惑。以下是每个文件中内容的快速摘要：</p><p>请确保您已经阅读了源代码！通常情况下，您只需编写一小段代码，这些代码以新的方式组合了我们提供给您的功能。如果您让解释器进入无法加载的状态，请查看启动期间打印的诊断消息，这样您就可以大致找出问题所在。如果这对您没有帮助，可以介绍您自己的brenda-debug-print行，这样您就可以改进问题所在。</p><p>虽然这很耗时，但每次在新的NOODLLE中进行重大更改时都要重新加载整个解释器。这将防止重复的类定义发生冲突，并将减少您通常遇到的问题。Brenda解释器加载可能会很慢，因此请尝试在可用的最快系统上工作。</p><p>最重要的是，在你潜心解决问题之前，想一想你将如何解决它。在这个问题集上比以往任何时候都做这件事会更好地服务于你。</p><p>在执行任何操作之前，请将堆栈限制更改为5000。除非你这么做，否则你连一个加分都过不了。</p><p>对于此问题，您将向解释器添加特殊形式的引号(&#39；)。QUOTE应该接受一个参数，并简单地返回它而不计算。(提示：这几乎是现有的最容易定义的特殊形式。这应该不需要太多代码。)。</p><p>布伦达？(引用)布伦达=&gt；布伦达？(报价3)布伦达==&gt；3布伦达？(引号foo条)引号：仅接受1个参数。</p><p>对于此问题，您将向解释器添加特殊的表单定义。定义应该有两个参数：变量说明符和表达式。变量说明符的形式应为符号或(符号&lt；类型&gt；)。表达式应该在全局环境中求值，并且应该破坏性地修改全局环境以包含新的绑定。如果绑定存在，则应将其重置。如果存在可选类型，则应检查表达式的求值结果是否满足类型约束。如果没有，您应该发出错误信号。</p><p>布伦达？(定义x 12)布伦达==&gt；x布伦达？(定义(y&lt；整数&gt；)(+1(*x x)布伦达==&gt；y布伦达？(定义(z&lt；number&gt；)&#34；hello&#34；)参数不符合类型。布伦达？X布伦达==&gt；12布伦达？Y布伦达==&gt；145布伦达？(定义x)定义：参数太少。布伦达？(定义x 2 3)定义：参数太多。布伦达？(是否定义NULL？(method((x&lt；list&gt；))(=x(QUOTE()Brenda==&gt；NULL？布伦达？(空？(引用(1))布伦达==&gt；#f布伦达？(空？(引号())Brenda==&gt；#t。</p><p>对于此问题，您将向Brenda添加绑定方法特殊形式。bind-method应该接受两个或多个参数；第一个参数应该是方法绑定列表，其余参数应该是一系列一个或多个Brenda表达式。每个绑定的格式应为(名称参数正文)。名称应该是一个符号。您应该检查方法特殊形式的代码。使用提供的帮助器函数，您应该解析每个方法绑定，并从每个方法绑定构造&lt；brenda-user-method&gt；。然后将每个方法绑定到一个框架中，并将它们与它们的名称相关联。您的代码应该处理相互递归的函数，即相互调用的函数。所有方法都必须在同一框架中定义，以便支持相互递归的函数。</p><p>布伦达？(绑定方法((f(X)(+x2)(F 3))brenda==&gt；5 brenda？(bind-method((f x(+x 2)(F 3))bind-method：参数列表格式错误。布伦达？(bind-Methods((f(X)(if(=x0)1(g(-x1)(g(Y)(*2(F Y)(G3))brenda==&gt；16 brenda？(bind-Methods((g((y&lt；Integer&gt；))(*2(+1 y)(g 3.4))参数不符合类型。布伦达？(bind-Methods((f(X)39x6)；提示：请确保将其与；；(39x6)区别对待--在这种情况下，39x6也很容易做到。(g(Y)(*2y)(+(G3)(F 42)Brenda==&gt；12。</p><p>在本问题中，您将在Brenda中实现STREAMS，其中STREAMS的行为与课程中介绍的完全相同。有很多方法可以做到这一点，但我们要选择的一种方法是在语言中添加一种特殊的形式。实现特殊形式的cons-stream、Head-Stream和Tail-Stream。这些函数的契约与cons、head和ail完全相同。然而，与常规的旧列表不同，流可以是无限长的。</p><p>要做这道题，你需要有一些延迟求值的方法。这类似于特殊形式的情况，例如，第二个或第三个参数在第一个参数之后求值。然而，在这种情况下，我们需要一种更通用的方法来实现这一点。延迟计算可以通过多种方式实现：我们可以使用宏，也可以使用称为thunks的概念。它们基本上是等价的，但是由于您以前见过宏，所以我们将使用thunk。</p><p>thunk是一个有四个槽的类--它存储稍后要求值的表达式，并存储表达式求值的环境、指示表达式是否已经求值的布尔标志以及值(如果已经求值)。</p><p>对于此问题，您需要执行以下操作：将新的特殊表单或函数cons-stream添加到Brenda。(提示：这不需要太多代码。)。</p><p>增列。</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.cs.cornell.edu/courses/cs212/1998sp/psets/ps6/ps6.html">http://www.cs.cornell.edu/courses/cs212/1998sp/psets/ps6/ps6.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/循环/">#循环</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/circular/">#circular</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/brenda/">#brenda</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1011273.html"><img src="http://img.diglog.com/img/2020/7/thumb_f1785908a9aac49cabbff329367644cb.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1011273.html">可移植的C库，支持易于使用的异步事件循环和协同程序</a></div><span class="my_story_list_date">2020-7-12 6:36</span></div><div class="col-sm"><div><a target="_blank" href="/story/1011272.html"><img src="http://img.diglog.com/img/2020/7/thumb_1fbecf1e4288a2fcaf5d15022c9b25f5.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1011272.html">评论：棕榈泉是对时间循环比喻的一个新鲜的，狡猾的自我意识的补充</a></div><span class="my_story_list_date">2020-7-12 6:15</span></div><div class="col-sm"><div><a target="_blank" href="/story/1000368.html"><img src="http://img.diglog.com/img/2020/5/thumb_c898d9a4962d6476dce03b83d46acd8e.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1000368.html">汇编语言循环的工作原理[视频]</a></div><span class="my_story_list_date">2020-5-2 23:28</span></div><div class="col-sm"><div><a target="_blank" href="/story/technology_internet_2355.html"><img src="http://img.diglog.com/img/2006/4/thumb_3feec609-1139-4ee8-8c7f-6b1062363bc1.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/technology_internet_2355.html">无限循环的Flash</a></div><span class="my_story_list_date">2006-4-29 10:38</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>