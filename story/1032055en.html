<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>TimscaleDB 2.0发布，现在是分布式多节点</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">TimscaleDB 2.0发布，现在是分布式多节点</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-30 00:38:10</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/3279b46982adfeb4e87cd98d41d83e12.jpg"><img src="http://img2.diglog.com/img/2020/10/3279b46982adfeb4e87cd98d41d83e12.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>After two years of dedicated engineering and user feedback, TimescaleDB 2.0 is finally here, setting a new bar for time-series databases – and it’s completely free.</p><p>经过两年的专门设计和用户反馈，TimscaleDB 2.0终于问世了，它为时间序列数据库树立了一个新的标杆-而且它是完全免费的。</p><p> Time-series data is everywhere. Whether you are monitoring your software stack, users, manufacturing line, home, vehicle, stock and cryptocurrency portfolio, air quality in your house, or just your health in the middle of a pandemic, you are collecting time-series data. As software continues to relentlessly penetrate our lives and businesses, time-series data is becoming even more ubiquitous and mission-critical.</p><p>时间序列数据无处不在。无论您是在监控您的软件堆栈、用户、生产线、家庭、车辆、股票和加密货币组合、您家中的空气质量，还是只是在大流行期间监测您的健康状况，您都在收集时间序列数据。随着软件继续无情地渗透到我们的生活和业务中，时间序列数据正变得更加无处不在，而且对任务至关重要。</p><p> At the same time, relational databases, that old stalwart, are making a comeback as the database of choice for software applications. Despite years of NoSQL hype, the  top 4 databases in use today are all relational databases. In addition, PostgreSQL is the  fastest growing database over the last year (yes, growing faster than even MongoDB).</p><p>与此同时，关系数据库这一古老的坚定不移的数据库正在卷土重来，成为软件应用程序的首选数据库。尽管多年来一直在炒作NoSQL，但目前使用最多的4个数据库都是关系数据库。此外，PostgreSQL是去年增长最快的数据库(是的，甚至比MongoDB还快)。</p><p> What developers need is a new kind of database, purpose-built for time-series workloads while fully embracing the relational model. After all, your time-series data doesn’t exist in a vacuum. Being able to correlate it with technical metadata, business data, and outcomes is critical to understanding how your software, systems, operations, and business changes over time.</p><p>开发人员需要的是一种新的数据库，专为时间序列工作负载而构建，同时完全采用关系模型。毕竟，你的时间序列数据并不存在于真空中。能够将其与技术元数据、业务数据和结果相关联，对于了解您的软件、系统、运营和业务如何随时间变化至关重要。</p><p> Building that database has always been our mission: to help developers store and analyze time-series data in a fast, reliable, and cost-effective way, so that they can focus on their core application and delight their users.</p><p>构建该数据库一直是我们的使命：帮助开发人员以快速、可靠和经济高效的方式存储和分析时间序列数据，以便他们可以专注于核心应用程序并取悦他们的用户。</p><p> Since launching 3.5 years ago, TimescaleDB has proven itself as the leading relational database for time-series data, engineered on top of PostgreSQL, and offered  via free software or as a fully-managed service on AWS, Azure, and GCP.</p><p>自3.5年前推出以来，TimscaleDB已证明自己是领先的时序数据关系数据库，基于PostgreSQL进行设计，并通过免费软件或作为AWS、Azure和GCP上的完全托管服务提供。</p><p> In that time, the TimescaleDB community has become the largest developer community for time-series data: tens of millions of downloads; over 500,000 active databases; organizations like AppDynamics, Bosch, Cisco, Comcast, Credit Suisse, DigitalOcean, Dow Chemical, Electronic Arts, Fujitsu, IBM, Microsoft, Rackspace, Schneider Electric, Samsung, Siemens, Uber, Walmart, Warner Music, WebEx, and thousands of others; all in addition to the PostgreSQL community and ecosystem.</p><p>在此期间，TimscaleDB社区已成为最大的时序数据开发者社区：数千万下载量；超过500,000个活动数据库；AppDynamics、博世、思科、康卡斯特、瑞士信贷、DigitalOcean、陶氏化学、艺电、富士通、IBM、微软、Rackspace、施耐德电气、三星、西门子、优步、沃尔玛、华纳音乐、WebEx等数以千计的组织；所有这些都是PostgreSQL社区和生态系统之外的。</p><p>  With this 2.0 release, TimescaleDB is now a distributed, multi-node, petabyte-scale relational database for time-series.  And, we are making everything in this release completely free. This is the culmination of two years of dedicated engineering effort, as well as significant user feedback on several previous betas.</p><p>在此2.0版本中，TimscaleDB现在是用于时间序列的分布式、多节点、PB级关系数据库。而且，我们在这个版本中的所有内容都是完全免费的。这是两年来专心致志的工程努力的结果，也是用户对之前几个测试版的重要反馈。</p><p> In fact, users have already been running multi-node TimescaleDB in continuous daily use for many months, including a 22-node cluster by a Fortune 100 tech company ingesting more than a billion rows per day:</p><p>事实上，用户在连续日常使用中运行多节点TimscaleDB已经有好几个月了，包括一家财富100强科技公司每天吞噬超过10亿行的22节点集群：</p><p> &#34;We continuously ingest telemetry events into TimescaleDB 2.0 to monitor and analyze huge numbers of sessions.  We&#39;ve been running TimescaleDB multi-node across 22 servers for almost the past year, ingesting more than a billion rows of data per day. TimescaleDB&#39;s performance, scale, relational and SQL capabilities, and ability to handle complex data have been a real winner.&#34; – Rahul, Technical Leader at Fortune 100 tech company</p><p>我们不断地将遥测事件接收到TimscaleDB 2.0中，以监控和分析大量会话。在过去的几乎一年里，我们一直在22台服务器上运行TimscaleDB多节点，每天接收超过10亿行数据。TimscaleDB的性能、规模、关系和SQL功能，以及处理复杂数据的能力一直是真正的赢家。&拉胡尔，财富100强科技公司的技术主管。</p><p> “Netskope prides itself on speed and scalability, and we rely heavily on time-series data to plan, monitor, and troubleshoot our global network of thousands of servers. With TimescaleDB, we tap into the ubiquitous PostgreSQL ecosystem and use TimescaleDB&#39;s continuous aggregates and other built-in time-series functions for real-time analytics and advanced historical analysis. Now  with multi-node TimescaleDB, we get the horizontal scalability and rapid ingest throughput we need to monitor and manage our systems at scale, now and in the future.” – Mark S. Reibert, Ph.D., Systems Architect at  Netskope, Inc.</p><p>Netskope以速度和可扩展性而自豪，我们严重依赖时间序列数据来计划、监控和排除我们由数千台服务器组成的全球网络的故障。有了TimscaleDB，我们可以利用无处不在的PostgreSQL生态系统，并使用TimscaleDB的连续聚合和其他内置的时间序列功能进行实时分析和高级历史分析。现在有了多节点TimscaleDB，我们获得了我们现在和将来大规模监控和管理我们的系统所需的水平可扩展性和快速吞吐能力。“-Netskope公司的系统架构师马克·S·雷伯特博士(Mark S.Reibert，Ph.D.)。</p><p>  Updated, more permissive licensing: making all of our enterprise features free and granting more rights to users.</p><p>更新、更宽松的许可：使我们所有的企业功能都是免费的，并向用户授予更多权限。</p><p> Substantial improvements to Continuous Aggregates: improving APIs and giving users greater control over the process.</p><p>对连续聚合的实质性改进：改进API并让用户更好地控制流程。</p><p> User-Defined Actions (new feature!): users can now define custom behaviors inside the database and schedule them using our job scheduling system.</p><p>用户自定义操作(新功能！)：用户现在可以在数据库中定义自定义行为，并使用我们的作业调度系统对其进行调度。</p><p> The TimescaleDB 2.0 Release Candidate is available immediately for self-managed software installations, with General Availability expected in late 2020. TimescaleDB 2.0 will be available on our hosted time-series services at that time. If you’re already using TimescaleDB, we’ve created detailed documentation to simplify and speed up your migration.</p><p>TimscaleDB 2.0候选版本立即可用于自我管理软件安装，预计在2020年后期全面上市。届时，TimscaleDB 2.0将在我们的托管时间系列服务上提供。如果您已经在使用TimscaleDB，我们已经创建了详细的文档来简化和加速您的迁移。</p><p>  We also encourage you to  join our 5,000+ member Slack community for any questions, to learn more, and to meet like-minded developers – we’re active in all channels and here to help.</p><p>我们也鼓励您加入我们5,000+会员的Slake社区，有任何问题，了解更多，并与志同道合的开发人员会面-我们在所有渠道都很活跃，并在此提供帮助。</p><p> (While Ajay and Mike are listed as authors of this post, full credit and a big round of applause goes to members of the Timescale database team for their hours, weeks, and months of dedication and commitment to shipping high quality code:   Erik Nordström ,   Gayathri Ayyappan ,   Ruslan Fomkin ,   Mats Kindahl,    Sven Klemm ,   Brian Rowe , and   Dmitry Simonenko .)</p><p>(虽然Ajay和Mike被列为这篇文章的作者，但Timescale数据库团队的成员在几个小时、几周和几个月的时间里一直致力于交付高质量的代码：Erik Nordström、Gayathri Ayyappan、Ruslan Fomkin、Mats Kindahl、Sven Klemm、Brian Rowe和Dmitry Simonenko，这是他们的全部荣誉和热烈的掌声。)。</p><p> We’d like to give a massive thank you to all of our beta testers; from reporting issues to sharing feedback and suggesting features, you all played a big role in making TimescaleDB 2.0 the best possible experience for developers.</p><p>我们非常感谢我们所有的测试版测试人员；从报告问题到分享反馈和建议特性，你们都为使TimscaleDB 2.0成为开发人员最好的体验发挥了重要作用。</p><p> To learn more about TimescaleDB 2.0, time-series data, and why we believe relational databases are the past and future of software development, please read on.</p><p>要了解有关TimscaleDB2.0、时间序列数据的更多信息，以及为什么我们认为关系数据库是软件开发的过去和未来，请继续阅读。</p><p>  For about 30 years, from the mid-1970s to the mid-2000s, if you were developing software, you used a relational database. From System R ( 1974) to Oracle (1979), SQL Server (1989), and later open-source options like MySQL (1995) and PostgreSQL (1996), relational databases were the standard for any new application.</p><p>大约30年来，从20世纪70年代中期到2000年代中期，如果您在开发软件，您使用的是关系数据库。从System R(1974)到Oracle(1979)、SQL Server(1989)，再到后来的开源选项，如MySQL(1995)和PostgreSQL(1996)，关系数据库是任何新应用程序的标准。</p><p> About 15 years ago, this all changed. Non-relational databases, sometimes also called “NoSQL” databases, became fashionable. A lot of this usage was legitimately necessary. New Internet giants built new systems to handle data volumes that were previously unfathomable, e.g., Google with MapReduce ( 2004) and Bigtable ( 2006); Amazon with Dynamo ( 2007). But a lot of NoSQL adoption was a knee-jerk reaction, along the lines of, “ relational databases don’t scale, so I need a NoSQL database.”</p><p>大约15年前，这一切都改变了。非关系数据库，有时也称为“NoSQL”数据库，变得流行起来。很多这样的用法都是合法必要的。新的互联网巨头建造了新的系统来处理以前深不可测的数据量，例如，谷歌(Google)推出了MapReduce(2004年)和Bigtable(2006年)；亚马逊(Amazon)推出了Dynamo(2007年)。但是，大量采用NoSQL是下意识的反应，大致是这样的：“关系数据库不能伸缩，所以我需要一个NoSQL数据库。”</p><p> Yet most companies are not Google or Amazon. And it turns out the ability to store data in a way that preserves the relationships in your dataset is valuable. After decades of usage in production, most relational databases are battle-hardened and typically more reliable than their NoSQL cousins. SQL has also re-emerged as the  universal language for data analysis, and is the  third most widely used language today (after JavaScript and HTML/CSS).</p><p>然而，大多数公司都不是谷歌或亚马逊。事实证明，以保留数据集中关系的方式存储数据的能力很有价值。在生产中使用了几十年之后，大多数关系数据库都是经久耐用的，通常比它们的NoSQL表亲更可靠。SQL也重新成为数据分析的通用语言，是当今第三广泛使用的语言(仅次于JavaScript和HTML/CSS)。</p><p> Today, the  top 4 databases in use are still all relational databases. In particular, PostgreSQL is the  fastest growing database over the last year (yes, growing faster than even MongoDB). Some of this is from developers switching back; some from developers who never left relational databases. So don’t call it a comeback - relational databases have been here for years (h/t  James Todd Smith).</p><p>今天，使用最多的4个数据库仍然都是关系数据库。特别值得一提的是，PostgreSQL是去年增长最快的数据库(是的，甚至比MongoDB还快)。其中一些来自改换过来的开发人员；另一些来自从未离开关系数据库的开发人员。所以不要称它为卷土重来-关系数据库已经在这里存在了很多年了(h/t James Todd Smith)。</p><p> Most importantly, relational databases can, in fact, scale. We see this in the more recent wave of “NewSQL” databases. Google again led the way almost a decade ago, with a geo-replicated relational database announced in their first Spanner paper  (2012) (whose authors include the original MapReduce authors), followed by other pioneers like CockroachDB ( 2014) and Yugabyte ( 2016). And with TimescaleDB ( 2017), we have built a relational database that scales for time-series data.</p><p>最重要的是，关系数据库实际上可以伸缩。我们在最近的“NewSQL”数据库浪潮中看到了这一点。近十年前，谷歌再次走在了前列，在他们的第一篇Spanner论文(2012年)(作者包括MapReduce的原始作者)中宣布了一个地理复制的关系数据库，紧随其后的是其他先驱，如CockroachDB(2014)和Yuabyte(2016)。有了TimscaleDB(2017)，我们已经建立了一个可针对时间序列数据进行缩放的关系数据库。</p><p>  Simply put, time-series is the measurement of something across time. But, to dig a little deeper,  time-series data is the measurement of how something changes.</p><p>简而言之，时间序列是跨越时间的事物的度量。但是，更深入地挖掘，时间序列数据是对事物如何变化的度量。</p><p>  If I send you $10, then a traditional bank database would atomically debit my account and credit your account. Then, if you send me $10, the same process happens in reverse.</p><p>如果我寄给你10美元，那么一个传统的银行数据库会自动记入我的账户的借方，并记入你的账户的贷方。然后，如果你寄给我10美元，同样的过程会发生相反的情况。</p><p> At the end of this process, our bank balances would look the same, so the bank might think, “Oh, nothing happened.” And that’s what a traditional database would show you.</p><p>在这个过程结束时，我们的银行余额看起来是一样的，所以银行可能会想，“哦，什么都没发生。”这就是传统数据库会向你展示的。</p><p> But, with a time-series database, the bank could see, “Hey, these two people keep sending each other $10 - maybe they’re friends, maybe they’re roommates, maybe there’s something else going on.” That level of granularity,  the measurement of how something changes, is what time-series enables.</p><p>但是，有了时间序列数据库，银行可以看到，“嘿，这两个人一直在互相寄10美元--也许他们是朋友，也许他们是室友，也许有其他事情发生。”这种粒度水平，即对事物如何变化的度量，正是时间序列所能实现的。</p><p> In other words, time-series datasets track changes to the overall system as INSERTs, not UPDATEs, to capture more information of what is happening.</p><p>换句话说，时间序列数据集以插入(而不是更新)的形式跟踪对整个系统的更改，以捕获有关正在发生的事情的更多信息。</p><p> Time-series used to be niche, isolated to industries like finance, process manufacturing (e.g., oil and gas, chemicals, plastics), or power and utilities. But in the last few years, time-series workloads have exploded (the  fastest growing category in the past 24 months). This is partly due to the growth in IT monitoring and IoT, but there are also many other new sources of time-series data: cryptocurrencies, gaming, machine learning, and more.</p><p>时间序列过去是小众的，孤立于金融、流程制造(例如，石油和天然气、化工、塑料)或电力和公用事业等行业。但在过去几年中，时间序列工作负载呈爆炸式增长(这是过去24个月中增长最快的类别)。这在一定程度上是由于IT监控和物联网的增长，但也有许多其他新的时间序列数据来源：加密货币、游戏、机器学习等。</p><p> What is happening is that everyone wants to make better data-driven decisions faster, which means collecting data at the highest fidelity possible.  Time-series is the highest fidelity of data you can capture, because it tells you exactly how things are changing over time. While traditional datasets give you static snapshots, time-series data provides the dynamic movie of what’s happening across your system: e.g., your software, your physical power plant, your game, your customers inside your application.</p><p>正在发生的情况是，每个人都希望更快地做出更好的数据驱动决策，这意味着以尽可能高的保真度收集数据。时间序列是您可以捕获的最高保真度的数据，因为它准确地告诉您事情是如何随着时间的推移而变化的。传统数据集为您提供静态快照，而时间序列数据则提供整个系统中正在发生的事情的动态电影：例如，您的软件、物理发电厂、游戏、应用程序中的客户。</p><p> Time-series is no longer some niche workload. It’s everywhere. In fact, all data is time-series data - if you are able to store it at that fidelity. Of course, that’s the problem with collecting time-series data: it’s relentless. By performing all these inserts, as opposed to updates, you end up with a lot more data, at higher volumes and velocities than ever before. You quickly get to tables in the billions of rows. For a traditional database, this creates challenges around performance and scalability.</p><p>时间序列不再是一些小众的工作负荷。它无处不在。事实上，所有数据都是时间序列数据-如果您能够以这种保真度存储它的话。当然，这就是收集时间序列数据的问题：它是无情的。通过执行所有这些插入，而不是更新，您最终会以比以往更高的容量和速度获得更多的数据。您很快就会看到数十亿行中的表。对于传统数据库来说，这在性能和可伸缩性方面带来了挑战。</p><p>   TimescaleDB is the leading relational database for time-series data. Engineered on top of PostgreSQL, Timescale is available  via free software or as a fully-managed service on AWS, Azure, and GCP.</p><p>TimscaleDB是领先的时间序列数据关系数据库。Timescale基于PostgreSQL设计，可以通过免费软件获得，也可以作为AWS、Azure和GCP上的完全托管服务使用。</p><p> TimescaleDB is purpose-built for time-series workloads, so that you can get orders of magnitude better performance at a fraction of the cost, along with a much better developer experience. This means massive scale (100s billions of rows and millions of inserts per second on a single server),  94%+ native compression, 10-100x faster queries than  PostgreSQL,  InfluxDB,  Cassandra, and  MongoDB – all while maintaining the reliability, ease-of-use, SQL interface, and overall goodness of PostgreSQL.</p><p>TimscaleDB是专门为时间序列工作负载构建的，因此您可以以极少的成本获得数量级的性能提升，以及更好的开发体验。这意味着巨大的规模(单个服务器上每秒数千亿行和数百万次插入)、94%以上的本机压缩、比PostgreSQL、InfluxDB、Cassandra和MongoDB快10-100倍的查询速度-所有这些都保持了PostgreSQL的可靠性、易用性、SQL接口和整体优势。</p><p> Today, there are several options for storing time-series data. However, most are non-relational systems that are essentially glorified metric stores, focused on storing numerical data and not the broad spectrum of  data types (nor the rich representation of relationships between datasets) that time-series workloads need.</p><p>如今，存储时间序列数据有几种选择。然而，大多数是非关系系统，本质上是美化的度量存储，专注于存储数字数据，而不是时间序列工作负载所需的广泛的数据类型(也不是数据集之间关系的丰富表示)。</p><p> In April 2017, we launched TimescaleDB into this world full of non-relational metric stores as the  first time-series database that supported full SQL. Since then, many others have copied our SQL approach to time-series (including some that are very suspiciously named, *cough*  Amazon Timestream *cough*), but no one has been able to replicate the true relational foundation and community of TimescaleDB.</p><p>2017年4月，我们将TimscaleDB作为第一个支持全SQL的时序数据库，进入了这个充斥着非关系型指标存储的世界。从那时起，其他许多人已经将我们的SQL方法复制到时间序列中(包括一些名称非常可疑的方法，*咳嗽*Amazon Time Stream*咳嗽*)，但没有人能够复制TimscaleDB的真正关系基础和社区。</p><p> As a result, in just 3.5 years, TimescaleDB has come a long way, now with tens of millions of downloads and over 500,000 active databases. The TimescaleDB developer community includes organizations like AppDynamics, Bosch, Cisco, Comcast, DigitalOcean, Dow Chemical, Electronic Arts, Fujitsu, IBM, Microsoft, Rackspace, Schneider Electric, Samsung, Siemens, Uber, Walmart, Warner Music, WebEx, and thousands of others.</p><p>因此，在短短3.5年的时间里，TimscaleDB已经取得了长足的进步，现在已经有了数千万的下载量和超过50万个活动数据库。TimscaleDB开发人员社区包括AppDynamics、博世、思科、康卡斯特、DigitalOcean、陶氏化学、电子艺界、富士通、IBM、微软、Rackspace、施耐德电气、三星、西门子、优步、沃尔玛、华纳音乐、WebEx等数以千计的组织。</p><p> In addition to this dedicated community, we also benefit from the vast PostgreSQL community and ecosystem.  Altogether, the TimescaleDB community is the largest developer community for time-series data.</p><p>除了这个专门的社区，我们还受益于庞大的PostgreSQL社区和生态系统。总而言之，TimscaleDB社区是最大的时间序列数据开发社区。</p><p>  Ever since we launched TimescaleDB, we’ve met skepticism. After all, building a time-series database on PostgreSQL is a non-obvious, somewhat heretical decision. Yet with each release, we continue to disprove our haters and delight our users. Because, as it turns out, building a scalable relational database for time-series isn’t impossible – it’s just hard. But, with our talented team and passionate users, we’re doing it.</p><p>自从我们推出TimscaleDB以来，我们就遇到了质疑。毕竟，在PostgreSQL上构建时间序列数据库是一个不明显的、有点异端的决定。然而，随着每一次发布，我们继续反驳我们的仇恨者，并取悦我们的用户。因为，事实证明，为时间序列构建一个可伸缩的关系数据库并不是不可能的-只是很难。但是，凭借我们才华横溢的团队和热情的用户，我们正在做这件事。</p><p> Myth 1: A relational database can’t scale as well as a non-relational database</p><p>误区1：关系型数据库不能像非关系型数据库那样具有伸缩性</p><p> Fact: We outperform non-relational (and other relational) databases for time-series data.  Versus Cassandra, 10x higher inserts, 1000x faster queries.  Versus Mongo, 20% higher inserts, 1400x faster queries.  Versus InfluxDB, higher inserts, faster queries, and better reliability. (Unlike all of these options, we also support full SQL, which allows users to run complex analysis on their data using a programming language and the tools they already know.)</p><p>事实：对于时间序列数据，我们的性能优于非关系(和其他关系)数据库。与Cassandra相比，插入速度提高了10倍，查询速度提高了1000倍。与Mongo相比，插入速度提高了20%，查询速度提高了1400倍。与InfluxDB相比，插入更多、查询更快、可靠性更高。(与所有这些选项不同，我们还支持完整的SQL，这允许用户使用编程语言和他们已经知道的工具对其数据运行复杂的分析。)。</p><p> Myth 2: Relational databases take up too much disk space (or, row-oriented databases can’t compress as well as columnar databases)</p><p>误区2：关系数据库占用太多磁盘空间(或者，面向行的数据库不能像列式数据库那样压缩)。</p><p> Fact: It is possible to build columnar compression in a row-oriented database,  which is what we have done. TimescaleDB employs several  best-in-class compression algorithms, including delta-delta, Gorilla, and Simple-8b RLE, allowing us to achieve 94%+ native compression.</p><p>事实：可以在面向行的数据库中构建列压缩，这正是我们所做的。TimscaleDB采用了几种同类最佳的压缩算法，包括Delta-Delta、Gorilla和SIMPLE-8bRLE，使我们能够实现94%以上的本机压缩。</p><p>  Fact: Every database, relational or non-relational, uses a schema to store data. The only difference is whether you have the ability to modify that schema and optimize it for your use. However, having a schema automatically generated for you is useful. We are already exploring automatic schemas: e.g., see  Promscale, our new analytical platform for Prometheus built on TimescaleDB, which stores data in a dynamically auto-generated schema highly optimized for metrics. More to come.</p><p>事实：每个数据库，无论是关系数据库还是非关系数据库，都使用模式来存储数据。唯一的区别是您是否有能力修改该模式并根据您的使用对其进行优化。但是，自动为您生成模式是很有用的。我们已经在探索自动模式：例如，请参阅Promscale，这是我们为普罗米修斯构建的基于TimscaleDB的新分析平台，它将数据存储在针对指标高度优化的动态自动生成模式中。还会有更多。</p><p>  Fact: NewSQL databases (mentioned above) are disproving this myth for transactional workloads. And today, we are disproving this myth for time-series workloads, with TimescaleDB 2.0.</p><p>事实：NewSQL数据库(如上所述)驳斥了事务性工作负载的这一神话。今天，我们将用TimscaleDB 2.0为时间序列工作负载驳斥这一神话。</p><p>  As mentioned above, customers have already been running multi-node TimescaleDB in continuous daily use for many months, including a 22-server cluster by a Fortune 100 tech company ingesting more than a billion rows per day.</p><p>如上所述，客户在连续的日常使用中运行多节点TimscaleDB已经有好几个月了，其中包括一家财富100强科技公司每天吞噬超过10亿行的包含22台服务器的集群。</p><p>   A regular   hypertable, one of our original innovations, is a virtual table in TimescaleDB that automatically partitions data into many sub-tables (“chunks”) on a single machine, continuously creating new ones as necessary, yet provides the illusion of a single continuous table across all time.</p><p>常规超级表是我们的原创性创新之一，它是TimscaleDB中的一个虚拟表，它自动将数据分区到单个机器上的多个子表(“块”)中，根据需要不断创建新的子表，同时始终提供单个连续表的错觉。</p><p> A   distributed hypertable is a hypertable that automatically partitions data into chunks  across multiple machines, while still maintaining the illusion (and user-experience) of a single continuous table across all time.</p><p>分布式超级表是一个超级表，它自动跨多台机器将数据分区为块，同时始终保持单个连续表的错觉(和用户体验)。</p><p> The architecture consists of an access node (AN), which stores metadata for the distributed hypertable and performs query planning across the cluster, and a set of data nodes (DN), which store subsets of the distributed hypertable dataset and execute queries locally.  TimescaleDB remains a single piece of software for operational simplicity; these roles as described are established by executing database commands within TimescaleDB (e.g., on a server that should act as an access node, you   add_data_node pointing to the hostnames of the data nodes, and then   create_distributed_hypertable.)</p><p>该体系结构由一个访问节点(AN)和一组数据节点(DN)组成，前者存储分布式超级表的元数据并跨集群执行查询规划，后者存储分布式超级表数据集的子集并在本地执行查询。*为简化操作，TimscaleDB仍然是一个单一软件；上述角色是通过在TimscaleDB内执行数据库命令来建立的(例如，在应该充当访问节点的服务器上，添加指向数据节点主机名的_DATA_NODE，然后添加_Distributed_HYPERTABLE。)。</p><p>  Currently, you can add any number of data nodes for horizontal scalability, as well as leverage existing Postgres physical replication on data nodes for fault tolerance (we are also working on more native replication for future releases; see below).</p><p>目前，您可以添加任意数量的数据节点以实现水平可伸缩性，还可以利用数据节点上现有的Postgres物理复制来实现容错(我们还在为将来的版本开发更多本机复制；请参见下文)。</p><p> The access node can also be physically replicated for high availability, and future releases will focus on further scaling out the read and write paths for TimescaleDB multi-node.</p><p>访问节点还可以进行物理复制以实现高可用性，未来的版本将侧重于进一步扩展TimscaleDB多节点的读写路径。</p><p>  As a result, while a traditional hypertable scales to 1-2 million metrics per second and 100 terabytes of data, a distributed hypertable scales to ingest 10+ million metrics per second and store petabytes of data:</p><p>因此，传统的超级表格可以扩展到每秒100-200万个指标和100 TB的数据，而分布式超级表格则可以扩展到每秒接收1000多万个指标并存储PB级的数据：</p><p>  Distributed hypertables also take advantage of query parallelization, employing full/partial aggregates and push-downs, to achieve much faster queries:</p><p>分布式超表还利用查询并行化，采用完全/部分聚合和下推，以实现更快的查询：</p><p>   We are already hard at work improving upon this initial release of  distributed hypertables with the next series of features:</p><p>我们已经在努力改进这个分布式超级表的初始版本，并提供以下一系列功能：</p><p> Replication: Currently every node needs its own replication (using primary/backup physical replication). Cluster-wide replication across data nodes, built natively for TimescaleDB, is in development.</p><p>复制：目前每个节点都需要自己的复制(使用主/备份物理复制)。针对TimscaleDB本机构建的跨数据节点的群集范围复制正在开发中。</p><p> Rebalancing:  Currently when new data nodes are elastically added to an existing distributed hypertables, new chunks are created across the available nodes, and queries are  routed accordingly to be repartitioning-aware.  But related to native replication, existing chunks are not currently rebalanced across nodes, which is also in development.</p><p>重新平衡：目前，当新数据节点灵活地添加到现有分布式超级表中时，会跨可用节点创建新的区块，并相应地路由查询以识别重新分区。但与本机复制相关，现有区块目前没有跨节点重新平衡，这也在开发中。</p><p> Backup: Each node can be backed up and restored, but there is currently no consistent restore-point snapshot across the whole cluster. Cluster-wide backup is also in development.</p><p>备份：每个节点都可以备份和还原，但目前在整个群集上没有一致的还原点快照。群集范围的备份也在开发中。</p><p> Compression: Compression currently must be performed on a per-chunk basis. In the future, compression policies on the access node, which then propagate to each data node, will be possible.</p><p>压缩：当前必须以块为单位执行压缩。将来，访问节点上的压缩策略，然后传播到每个数据节点将成为可能。</p><p> Some features, such as continuous aggregates and  time_bucket_gapfill, do not currently work on distributed hypertables. Those are also in development.</p><p>一些功能，如连续聚合和TIME_BUCK_GAPFILL，目前不适用于分布式超级表。这些也在开发中。</p><p> Check out the below explainer video for a breakdown of how distributed hypertables work, when and why you&#39;d use them, best practices, and more.</p><p>请查看下面的讲解视频，了解分布式超级表格的工作原理、何时以及为什么要使用它们、最佳实践等详细信息。</p><p>    Updated, more permissive licensing: making all of our enterprise features free and granting more rights to users.</p><p>更新、更宽松的许可：使我们所有的企业功能都是免费的，并向用户授予更多权限。</p><p> Substantial improvements to Continuous Aggregates:   improving APIs and giving users greater control over the process.</p><p>对连续聚合的实质性改进：改进API并让用户更好地控制流程。</p><p> User-Defined Actions (new feature!): users can now define custom behaviors inside the database and schedule them using our job scheduling system.</p><p>用户自定义操作(新功能！)：用户现在可以在数据库中定义自定义行为，并使用我们的作业调度系统对其进行调度。</p><p>  TimescaleDB 2.0 introduces an update to the Timescale License, our source-available license that governs most of our advanced capabilities, including native compression, multi-node, continuous aggregations, and more.</p><p>TimscaleDB 2.0引入了Timescale许可证的更新，这是我们的源代码可用许可证，用于管理我们的大多数高级功能，包括本机压缩、多节点、连续聚合等。</p><p> This update makes all of our enterprise features free, and provides expanded rights to users, reinforcing our commitment to our community. Notably, this update adds the “right-to-repair”, the “right-to-improve”, and eliminates the paid enterprise tier and usage limits altogether (thus establishing that all of our software will be available for free). ( More in this announcement.)</p><p>此更新使我们所有的企业功能都是免费的，并为用户提供了扩展的权限，加强了我们对社区的承诺。值得注意的是，此更新增加了“维修权”、“改进权”，并完全取消了付费企业层和使用限制(从而确定我们所有的软件都将是免费的)。(更多信息请参见本公告。)。</p><p>  Continuous Aggregates are an existing capability ( introduced 1.5 years ago with TimescaleDB 1.3) that automatically calculates the results of a query in the background and materializes the results, leading to vastly faster query times. They are somewhat similar to PostgreSQL materialized views, but unlike a materialized view, Continuous Aggregates do not need to be refreshed manually; views are automatically refreshed in the background as new data is added, or old data is modified. ( See our Continuous Aggregates documentation for more details.)</p><p>连续聚合是一项现有功能(1.5年前在TimscaleDB 1.3中引入)，它可以在后台自动计算查询结果并将结果具体化，从而大大加快查询速度。它们与PostgreSQL实体化视图有点类似，但与实体化视图不同的是，连续聚集不需要手动刷新；视图在添加新数据或修改旧数据时会在后台自动刷新。(有关更多详细信息，请参阅我们的连续聚集文档。)。</p><p> TimescaleDB 2.0 includes substantial improvements (and, as a result, some breaking API changes) to Continuous Aggregates:</p><p>TimscaleDB 2.0包括对连续聚集的实质性改进(因此，还包括一些突破性的API更改)：</p><p> Updated APIs that separate function and policies, giving users greater control of the Continuous Aggregation process. For example, a Continuous Aggregate can now be manually refreshed over a given range. One common user request has been to materialize recent data but leave historical data to manual refreshes. Now that is possible.</p><p>更新了将功能和策略分开的API，让用户可以更好地控制连续聚合过程。例如，现在可以在给定范围内手动刷新连续聚合。一个常见的用户请求是物化最新数据，但将历史数据留给手动刷新。现在这是可能的。</p><p> The separation of function and policies also makes this feature more amenable to distributed operation in the future (e.g., multinode). For instance, a policy on an Access Node can trigger refreshes on Data Nodes.</p><p>功能和策略的分离也使得此功能在将来更适合分布式操作(例如，多节点)。例如，访问节点上的策略可以触发数据节点上的刷新。</p><p>  As a result, there are some breaking API changes to Continuous Aggregates ( highlighted</p><p>因此，对连续聚集(突出显示)进行了一些突破性的API更改。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.timescale.com/blog/timescaledb-2-0-a-multi-node-petabyte-scale-completely-free-relational-database-for-time-series/">https://blog.timescale.com/blog/timescaledb-2-0-a-multi-node-petabyte-scale-completely-free-relational-database-for-time-series/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/现在/">#现在</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031899.html"><img src="http://img2.diglog.com/img/2020/10/thumb_80014e616500c8966353726512bbacb4.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031899.html">AMD将于11月18日发布RADEON RX 6000系列</a></div><span class="my_story_list_date">2020-10-29 10:38</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031586.html"><img src="http://img2.diglog.com/img/2020/10/thumb_1a7043e793fc66b6b19c490439b68d22.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031586.html">随CUDA 11发布PyTorch 1.7，FFT新API，赢得分布式培训</a></div><span class="my_story_list_date">2020-10-28 3:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031577.html"><img src="http://img2.diglog.com/img/2020/10/thumb_75e60354f9d7216fe8ff99728318d528.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031577.html">Ubuntu Groovy Gorilla将Raspberry Pi添加为“一等公民”</a></div><span class="my_story_list_date">2020-10-28 2:52</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031540.html"><img src="http://img2.diglog.com/img/2020/10/thumb_9c4390135e7f62612d01cfd4298fd889.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031540.html">Feddora 33已发布</a></div><span class="my_story_list_date">2020-10-28 1:8</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>