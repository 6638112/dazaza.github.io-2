<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Phoenix LiveView如何运作 How Phoenix LiveView Works</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How Phoenix LiveView Works<br/>Phoenix LiveView如何运作 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-25 19:11:11</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/f2e6d3ea08ee529a5146ee9ecd4db897.jpeg"><img src="http://img2.diglog.com/img/2021/6/f2e6d3ea08ee529a5146ee9ecd4db897.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In the  previous lesson we got a taste of the LiveView’s magic! In this lesson we are going to see how LiveView really works and what happens behind the scenes when a user connects.</p><p>在上一课中，我们有一种LiveView的魔力！在本课程中，我们将看到LiveView如何真正有效，并且在用户连接时幕后会发生什么。</p><p> Let’s start with a  simplified version of our dashboard, a view that renders only the Coinbase BTC-USD trades.</p><p> 让我们从仪表板的简化版本开始，这是一个只渲染Coinbase BTC-USD交易的视图。</p><p>  defmodule PoeticoinsWeb.CryptoDashboardLive do use PoeticoinsWeb, :live_view alias Poeticoins.Product def mount(_params, _session, socket) do IO.inspect(self(), label: &#34;MOUNT&#34;) product = Product.new(&#34;coinbase&#34;, &#34;BTC-USD&#34;) trade = Poeticoins.get_last_trade(product) # if socket.connected? do # Poeticoins.subscribe_to_trades(product) # end socket = assign(socket, :trade, trade) {:ok, socket} end def render(assigns) do IO.inspect(self(), label: &#34;RENDER&#34;) ~L&#34;&#34;&#34; &lt;p&gt;&lt;b&gt;Product&lt;/b&gt;: &lt;%= @trade.product.exchange_name %&gt; - &lt;%= @trade.product.currency_pair %&gt; &lt;/p&gt; &lt;p&gt;&lt;b&gt;Traded at&lt;/b&gt;: &lt;%= @trade.traded_at %&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;Price&lt;/b&gt;: &lt;%= @trade.price %&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;Volume&lt;/b&gt;: &lt;%= @trade.volume %&gt;&lt;/p&gt; &#34;&#34;&#34; end def handle_info({:new_trade, trade}, socket) do socket = assign(socket, :trade, trade) {:noreply, socket} endend</p><p>  defmodule poeticoinsweb.cryptodashboard do使用poeticoinsweb，：live_view alias poeticoins.product def mount（_params，_session，socket）do io.inspect（self（），标签：＆＃34; mount＆＃34;）产品= product.new（＆ ＃34;乐队＆＃34;，＆＃34; btc-usd＆＃34;）trade = poeticoins.get_last_trade（产品）＃if socket.connection？ do＃poeticoins.subscribe_to_trades（产品）＃结束socket =分配（插座，：贸易，贸易）{：确定，套接字}结束def渲染（分配）do io.inspect（self（），标签：＆＃34; render＆＃34; render＆＃34; render＆＃34; 34;）〜L＆＃34;＆＃34;＆＃34; ＆lt; p＆gt;＆lt; b＆gt;产品＆lt; / b＆gt ;:＆lt;％= @ trade.product.exchange_name％＆gt; - ＆lt;％= @ trade.product.currency_pair％＆gt; ＆lt; / p＆gt; ＆lt; p＆gt;＆lt; b＆gt;在＆lt; / b＆gt ;:＆lt;％= @ trade.traded_at％＆gt;＆lt; / p＆gt; ＆lt; p＆gt;＆lt; b＆gt;价格＆lt; / b＆gt ;:＆lt;％= @ trade.price％＆gt;＆lt; / p＆gt; ＆lt; p＆gt;＆lt; b＆gt;体积＆lt; / b＆gt ;:＆lt;％= @ trade.volume％＆gt;＆lt; / p＆gt; ＆＃34;＆＃34;＆＃34; End Def Handle_Info（{：new_trade，trade}，插座）do socket =分配（插座，：贸易，贸易）{：noreply，socket}结束</p><p> By calling  IO.inspect(self(), label: &#34;...&#34;) in both  mount/3 and  render/1 we see when these callbacks are invoked and what is the process  PID.</p><p> 通过调用io.inspect（self（），标签：＆＃34; ...＆＃34;）在inst / 3和render / 1中，我们看到何时调用这些回调以及进程PID是什么时候。</p><p> Let’s also temporarily comment the the  Poeticoins.subscribe_to_trades(product) line in  mount/3, in this way we’ll not get any new trade message, so we can better focus just on the first part of the life-cycle.</p><p> 让我们还暂时评论诗歌/ 3中的诗歌ins.subscribe_to_trades（产品）行，以这种方式我们不会得到任何新的贸易信息，因此我们可以更好地关注生命周期的第一部分。</p><p>  Let’s start by doing a simple HTTP GET request to the   live &#34;/&#34; route, with a tool like  curl</p><p>  让我们首先对Live＆＃34做一个简单的HTTP GET请求; /＆＃34;路线，使用卷曲等工具</p><p> $ curl -v &#34;http://localhost:4000&#34;&lt;!DOCTYPE html&gt;&lt;html lang=&#34;en&#34;&gt;&lt;head&gt; &lt;meta charset=&#34;UTF-8&#34; content=&#34;DCcYcUw3OzEsC2ISVAkUTDkgHydfAkZrakIC6mpGVj7YyFXaQUTbis48&#34; csrf-param=&#34;_csrf_token&#34; method-param=&#34;_method&#34; name=&#34;csrf-token&#34;&gt; &lt;script defer phx-track-static type=&#34;text/javascript&#34; src=&#34;/js/app.js&#34;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div data-phx-main=&#34;true&#34; data-phx-session=&#34;SFMyNTY...&#34; data-phx-static=&#34;SFMyNTY...&#34; data-phx-view=&#34;CryptoDashboardLive&#34; id=&#34;phx-FlYt1v20d4jiJQBG&#34;&gt; &lt;main role=&#34;main&#34; class=&#34;container&#34;&gt; &lt;p class=&#34;alert alert-info&#34; role=&#34;alert&#34; phx-click=&#34;lv:clear-flash&#34; phx-value-key=&#34;info&#34;&gt;&lt;/p&gt; &lt;p class=&#34;alert alert-danger&#34; role=&#34;alert&#34; phx-click=&#34;lv:clear-flash&#34; phx-value-key=&#34;error&#34;&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;Product&lt;/b&gt;: coinbase - BTC-USD &lt;/p&gt; &lt;p&gt;&lt;b&gt;Traded at&lt;/b&gt;: 2021-01-01 18:05:18.124448Z&lt;/p&gt; &lt;p&gt;&lt;b&gt;Price&lt;/b&gt;: 29315.3&lt;/p&gt; &lt;p&gt;&lt;b&gt;Volume&lt;/b&gt;: 0.00673002&lt;/p&gt; &lt;/main&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</p><p> $ curl -v＆＃34; http：// localhost：4000＆＃34;＆lt;！doctype html＆gt;＆lt; html lang =＆＃34; en＆＃34;＆gt;＆gt;＆gt; ＆lt; meta charset =＆＃34; UTF-8＆＃34;内容=＆＃34; dccycuw3ozesc2isvakutdkghydfakzrakic6mpgvj7yyfxaqutbis48＆＃34; csrf-param =＆＃34; _csrf_token＆＃34;方法 -  param =＆＃34; _method＆＃34;名称=＆＃34; CSRF-token＆＃34;＆gt; ＆lt; script defer phx-track-static类型=＆＃34; text / javascript＆＃34; src =＆＃34; /js/app.js& n34;＆gt;＆lt; / script＆gt;＆lt; / head＆gt;＆lt;主体＆gt; ＆lt; div data-phx-main =＆＃34;真＆＃34; data-phx-session =＆＃34; sfmynty ...＆＃34; data-phx-static =＆＃34; sfmynty ...＆＃34; data-phx-view =＆＃34; CryptodashboardLive＆＃34; id =＆＃34; phx-flyt1v20d4jijqbg＆＃34;＆gt; ＆lt;主要角色=＆＃34;主要＆＃34; Class =＆＃34;容器＆＃34;＆gt; ＆lt; p class =＆＃34;警报提醒信息＆＃34;角色=＆＃34;警报＆＃34; PHX点击=＆＃34; LV：清除闪存＆＃34; phx-value-key =＆＃34;信息＆＃34;＆gt;＆lt; / p＆gt; ＆lt; p class =＆＃34;警报警报 - 危险＆＃34;角色=＆＃34;警报＆＃34; PHX点击=＆＃34; LV：清除闪存＆＃34; phx-value-key =＆＃34;错误＆＃34;＆gt;＆lt; / p＆gt; ＆lt; p＆gt;＆lt; b＆gt;产品＆lt; / b＆gt; coinbase  -  btc-usd＆lt; / p＆gt; ＆lt; p＆gt;＆lt; b＆gt;在＆lt; / b＆gt; 18：05：18.124448z＆lt; / b＆gt; ＆lt; p＆gt;＆lt; b＆gt;价格＆lt; / b＆gt ;:29315.3＆lt; / p＆gt; ＆lt; p＆gt;＆lt; b＆gt;体积＆lt; / b＆gt; 0.00673002＆lt; / p＆gt; ＆lt; / main＆gt; ＆lt; / div＆gt;＆lt; / body＆gt;＆lt; / html＆gt; </p><p> We immediately notice that the app answers to our HTTP GET request with a fully rendered page! This means that we can support clients that do not necessarily run JavaScript, which makes LiveView also great for SEO.</p><p>我们立即注意到应用程序答案我们的HTTP获取请求与完全呈现的页面！这意味着我们可以支持不一定运行JavaScript的客户端，这使LiveView也非常适合SEO。</p><p>  We made a normal HTTP GET request,  mount/3 is called to initialize the data to be rendered, then  render/1 returns the rendered content.</p><p>  我们进行了一个正常的HTTP GET请求，调用挂载/ 3初始化要呈现的数据，然后呈现/ 1返回呈现的内容。</p><p>  [info] GET /[debug] Processing with Phoenix.LiveView.Plug.Elixir.PoeticoinsWeb.CryptoDashboardLive/2 Parameters: %{} Pipelines: [:browser]MOUNT: #PID&lt;0.462.0&gt;RENDER: #PID&lt;0.462.0&gt;[info] Sent 200 in 40ms</p><p>  [info] get / [debug]使用phoenix.liveview.plug.elixir.poeticoinsweb.cryptodashlower / 2参数：％{}管道：[：浏览器]挂载：＃pID＆lt; 0.462.0＆gt;渲染：＃pID＆lt; 0.462。 0＆gt; [info]在40ms中发送200</p><p>  By opening the  http://localhost:4000 page with a browser, we see that  mount/3 and  render/1 are called two times.</p><p>  通过打开http：// localhost：4000页使用浏览器，我们看到inst / 3和render / 1称为两次。</p><p> MOUNT: #PID&lt;0.599.0&gt;RENDER: #PID&lt;0.599.0&gt;[info] Sent 200 in 2ms[info] CONNECTED TO Phoenix.LiveView.Socket in 73µs Transport: :websocket Serializer: Phoenix.Socket.V2.JSONSerializer Parameters: %{&#34;_csrf_token&#34; =&gt; &#34;GQclPRUJPykADko2AgcBKDMPSSRUN2YSUbsGs1lb-gzixvqfUlyv5nPw&#34;, &#34;_mounts&#34; =&gt; &#34;0&#34;, &#34;_track_static&#34; =&gt; %{&#34;0&#34; =&gt; &#34;http://localhost:4000/css/app.css&#34;, &#34;1&#34; =&gt; &#34;http://localhost:4000/js/app.js&#34;}, &#34;vsn&#34; =&gt; &#34;2.0.0&#34;}MOUNT: #PID&lt;0.612.0&gt;RENDER: #PID&lt;0.612.0&gt;</p><p> 挂载：＃pID＆lt; 0.599.0＆gt;渲染：＃pID＆lt; 0.599.0＆gt; [info]在2ms [info]中发送了200个连接到Phoenix.liveview.socket在73μs传输：websocket serializer：phoenix.socket.v2.jsonserializer参数：％{＆＃34; _csrf_token＆＃34; =＆gt; ＆＃34; gqclprujpykadko2agcbkdmpssrun2ysubsgs1lb-gzixvqfulyv5npw＆＃34 ;,＆＃34; _mounts＆＃34; =＆gt; ＆＃34; 0＆＃34;＆＃34; _track_static＆＃34; =＆gt; ％{＆＃34; 0＆＃34; =＆gt; ＆＃34; http：// localhost：4000 / css / app.css＆＃34 ;,＆＃34; 1＆＃34; =＆gt; ＆＃34; http：// localhost：4000 / js / app.js＆＃34;}，＆＃34; vsn＆＃34; =＆gt; ＆＃34; 2.0.0＆＃34;}安装：＃pID＆lt; 0.612.0＆gt;渲染：＃pid＆lt; 0.612.0＆gt;</p><p> The first time is to answer to the HTTP GET request, with the fully rendered html page that we saw in the previous example. When the browser receives the HTML content, it loads the   app.js application’s JS.</p><p> 第一次是回答HTTP GET请求，使用我们在上一个示例中看到的完全呈现的HTML页面。当浏览器接收到HTML内容时，它会加载App.js应用程序的JS。</p><p> //app.jsimport {Socket} from &#34;phoenix&#34;import {LiveSocket} from &#34;phoenix_live_view&#34;let csrfToken = document.querySelector(&#34;meta[name=&#39;csrf-token&#39;]&#34;).getAttribute(&#34;content&#34;)let liveSocket = new LiveSocket(&#34;/live&#34;, Socket, {params: {_csrf_token: csrfToken}})// connect if there are any LiveViews on the pageliveSocket.connect()</p><p> //app.jsimport {socket} from＆＃34;凤凰＆＃34;从＆＃34导入{livesoction} from＆＃34; phoenix_live_view＆＃34; let csrftoken = document.querySelector（＆＃34; meta [name =＆＃39; csrf -Token＆＃39;]＆＃34;）。getAttribute（＆＃34;内容＆＃34;）让livesocket =新的livesocket（＆＃34; / live＆＃34; ocket，{params：{_csrf_token：csrftoken}} ）// connect如果pagelivesocket.connect（）上有任何LiveViews（） </p><p> Running this script, the browser connects again to the server, this time opening a websocket connection, passing the  csrf-token, rendered in the  &lt;meta&gt; tag in the header. Once connected, the server starts a stateful LiveView process and calls for the second time  mount/3 and  render/1, pushing the new rendered page via the websocket connection.</p><p>运行此脚本，浏览器再次连接到服务器，此时打开WebSocket连接，传递CSRF-令牌，在＆lt; meta＆gt中呈现。标记在标题中。连接后，服务器启动状态LiveView进程并呼叫第二次时间挂载/ 3并渲染/ 1，通过WebSocket连接按下新呈现页面。</p><p>  This new stateful LiveView process runs as long as the user stays connected, keeping the state in memory, listening to events from the browser and sending rendered changes to the browser, every time we update the  socket.assigns values.</p><p>  这一新的有状态LiveView流程只要用户保持连接，将状态保持在内存中，从浏览器中侦听事件并向浏览器发送渲染更改，每次更新套接字时都会。</p><p> To better understand what happens over the WebSocket connection, we can use the browser inspector to see the exchanged messages.</p><p> 为了更好地了解通过WebSocket连接发生的事情，我们可以使用浏览器检查器来查看交换消息。</p><p> In the inspector, going under the  Network tab and refreshing the page, we see a list of requests</p><p> 在“检查员”中，在“网络”选项卡下，刷新页面，我们会看到一个请求列表</p><p>  First we see the GET request to localhost and the full html in the server response.</p><p>  首先，我们将Get请求与服务器响应中的LocalHost和完整的HTML看。</p><p> Then, the browser loads the  app.js javascript and connects to LiveView via WebSocket. Once the websocket connection is established, the browser immediately sends a  phx_join message.</p><p> 然后，浏览器加载App.js JavaScript并通过WebSocket连接到LiveView。建立WebSocket连接后，浏览器立即发送PHX_JOIN消息。</p><p>  LiveView replies with a  phx_reply message containing the rendered view. In this message we don’t find the simple view’s html, instead we find the dynamic values and the static parts of our template. The static parts are kept in the browser’s memory and only the dynamic changes are sent to the browser from LiveView.</p><p>  LiveView使用包含呈现视图的PHX_REPLY消息回复。在此消息中，我们找不到简单的视图的HTML，而是我们找到了动态值和模板的静态部分。静态部件保持在浏览器的内存中，并且只将动态更改从LiveView发送到浏览器。 </p><p> [ ... &#34;phx_reply&#34;, {&#34;response&#34;: ... { &#34;0&#34;: &#34;coinbase&#34;, &#34;1&#34;: &#34;BTC-USD&#34;, &#34;2&#34;: &#34;2021-01-01 21:48:39.473797Z&#34;, &#34;3&#34;: &#34;29265.33&#34;, &#34;4&#34;: &#34;0.35729453&#34;, &#34;s&#34;: [ &#34;&lt;p&gt;&lt;b&gt;Product&lt;/b&gt;:\n &#34;, &#34; -\n &#34;, &#34;\n&lt;/p&gt;\n&lt;p&gt;&lt;b&gt;Traded at&lt;/b&gt;: &#34;, &#34;&lt;/p&gt;\n&lt;p&gt;&lt;b&gt;Price&lt;/b&gt;: &#34;, &#34;&lt;/p&gt;\n&lt;p&gt;&lt;b&gt;Volume&lt;/b&gt;: &#34;, &#34;&lt;/p&gt;\n&#34; ] } }]</p><p>[...＆＃34; phx_reply＆＃34;，{＆＃34;响应＆＃34 ;: ... {＆＃34; 0＆＃34 ;:＆＃34;冰纳和＃34 ;,＆＃34; 1＆ ＃34 ;:＆＃34; BTC-USD＆＃34 ;,＆＃34; 2＆＃34 ;:＆＃34; 2021-01-01 21：48：39.473797z＆＃34 ;,＆＃34; 3＆＃34 ;：＆＃34; 29265.33＆＃34 ;,＃34; 4＆＃34 ;:＆＃34; 0.35729453＆＃34 ;,＆＃34; s＆＃34 ;: [34;＆lt; p＆lt; p＆lt; ; B＆gt;产品＆lt; / b＆gt;：\ n＆＃34 ;,＆＃34; -  \ n＆＃34;＆＃34; \ n＆lt;＆lt; p＆gt;＆lt; b＆gt;＆lt; / b＆gt ;:＆＃34;，＆＃34;＆lt; / p＆＃34;＆＃34;＆＃34;＆lt; / p＆＃34;＆lt; / p＆＃34; ; p＆gt;＆lt; b＆gt;价格＆lt; / b＆gt ;:＆＃34;＆＃34;＆lt; / p>＆lt; b＆gt;体积＆lt; / b＆gt ;:＆＃34 ;,＆＃34 ;＆lt; / p＆gt; \ n＆＃34; ]}}]</p><p> To properly render this view, the LiveView JS code running on the browser, simply interpolates the dynamic values with the static parts:</p><p> 要正确呈现此视图，请在浏览器上运行的LiveView JS代码只需用静态部分内插动态值：</p><p> &#34;&lt;p&gt;&lt;b&gt;Product&lt;/b&gt;:\n &#34; + &#34;coinbase&#34; + &#34; -\n &#34; +&#34;BTC-USD&#34; + &#34;\n&lt;/p&gt;\n&lt;p&gt;&lt;b&gt;Traded at&lt;/b&gt;: &#34; + &#34;2021-01-01 21:48:39.473797Z&#34; + ...</p><p> ＆＃34;＆lt; p＆gt;＆lt; b＆gt;产品＆lt; / b＆gt;：\ n＆＃34; +＆＃34;斗鸡队和＃34; +＆＃34; -  \ n＆＃34; +＆＃34; BTC-USD＆＃34; +＆＃34; \ n＆lt; / p＆gt;＆lt; p＆gt;＆lt; b＆gt;＆lt; / b＆gt ;:＆＃34; +＆＃34; 2021-01-01 21：48：39.473797Z＆＃34; + ......</p><p>  Let’s remove the comments in  mount/3, so that the LiveView process subscribes to get new trades and we can see what happens when  socket.assigns is updated.</p><p>  让我们删除Mount / 3中的注释，以便LiveView Process订阅获取新交易，我们可以看到套接字时会发生什么。更新了。</p><p> def mount(_params, _session, socket) do IO.inspect(self(), label: &#34;MOUNT&#34;) product = Product.new(&#34;coinbase&#34;, &#34;BTC-USD&#34;) trade = Poeticoins.get_last_trade(product) if socket.connected? do Poeticoins.subscribe_to_trades(product) end socket = assign(socket, :trade, trade) {:ok, socket}end</p><p> def mount（_params，_session，socket）do io.inspect（self（），标签：＆＃34; mount＆＃34; support＆＃34;）产品= product.new（＆＃34; coinbase＆＃34;和＃34; btc- USD＆＃34;）Trade = poeticoins.get_last_trade（产品）如果socket.connected？ do poeticoins.subscribe_to_trades（产品）结束socket =分配（插座，：贸易，贸易）{：确定，套接字}结束</p><p> We now have all the elements to understand why we used the  if socket.connected? condition.   socket.connected? is  false during the initial HTTP GET request, in this case we don’t want to subscribe to get new trades because the process is not meant to live after the response; we just want to render the view with the most recent trade and close the connection.</p><p> 我们现在拥有所有元素来理解为什么我们使用if socket.Connection？状况。 socket.Connected？在初始HTTP GET请求期间是假的，在这种情况下，我们不想订阅获取新交易，因为该过程并不意味着在响应之后生活;我们只想用最近的交易渲染视图并关闭连接。</p><p> When the browser connects, through a WebSocket, to a stateful LiveView,  socket.connected? is  true and it’s now time to subscribe the LiveView process to the PubSub topic.</p><p> 当浏览器通过WebSocket连接到有状态LiveView，Socket.Connected？是真的，现在是时候为Pubsub主题订阅LiveView进程。 </p><p> def handle_info({:new_trade, trade}, socket) do IO.inspect(self(), label: &#34;NEW TRADE&#34;) socket = assign(socket, :trade, trade) {:noreply, socket}end</p><p>def handle_info（{：new_trade，trade}，socket）do io.inspect（self（），标签：＆＃34;新贸易＆＃34;）socket =分配（插座，：贸易，贸易）{：noreply，socket}结尾</p><p> handle_info/2 is called every time the process receives a  {:new_trade, trade} message. We print the PID and  assign/3 the  :trade in the  socket. The view gets re-rendered, calling  render/1, and the changes are pushed to the browser.</p><p> 每次进程接收到{：new_trade，trade}消息时调用handle_info / 2。我们在套接字中打印PID并分配/ 3：交易。该视图重新呈现，调用Render / 1，并将更改推送到浏览器。</p><p> By refreshing the page on the browser we see that, as expected, the view is now correctly updated every time there is a new trade. With the browser inspector we can see the messages sent by LiveView process running on the server.</p><p> 通过刷新浏览器上的页面，我们看到，正如所预期的那样，每次都有新贸易时，视图现在就正确更新。使用浏览器检查器，我们可以看到在服务器上运行的LiveView进程发送的消息。</p><p> After the initial  phx_join and  phx_reply, we find  diff messages, which are the changes sent from the server every time a new trade is received.</p><p> 在初始PHX_JOIN和PHX_REPLY之后，我们发现DIFF消息，每次收到新交易时从服务器发送的更改。</p><p>  LiveView is able to track the changes and send only the changed values to the browser.</p><p>  LiveView能够跟踪更改，并仅将更改的值发送到浏览器。</p><p> Looking into one of the diff messages, we don’t see any static part, only the dynamic values that changed in  socket.assigns. In this way the payload is super compact: we just have the  trade.traded_at (position number  2 in the  diff message), the  trade.price (position number  3) and  trade.volume (position number  4).</p><p> 调查其中一个差异消息，我们没有看到任何静态部分，只有套接字中更改的动态值。通过这种方式，有效载荷是超级紧凑的：我们只需具有Trade.TraD_AT（Diff消息中的位置2），Trade.price（位置3）和交易.Volume（位置编号4）。</p><p> Each dynamic part has it’s own position number and LiveView uses this positions to know which element needs to be updated in the DOM. The JS code running on the browser applies these changes using a library called  Morphdom.</p><p> 每个动态部分都有自己的位置编号，LiveView使用此职位了解DOM中需要更新哪个元素。在浏览器上运行的js代码使用名为mphor的库应用这些更改。 </p><p> In the terminal we see that each new trade is handled by  handle_info/2 which updates the socket, then  render/1 is called to re-render the view and send the changes to the browser.</p><p>在终端中，我们看到每个新的交易由Supper_Info / 2处理，该套接字更新套接字，然后调用Retains / 1以重新渲染视图并将更改发送到浏览器。</p><p>  We also see that the LiveView process, which serves our browser, is always the same (one process for each connected user). It’s a single stateful LiveView process, that keeps its state in memory and tracks the changes, as long as we stay connected.</p><p>  我们还看到，服务我们浏览器的LiveView进程始终相同（每个连接用户的一个过程）。这是一个单一的LiveView进程，它在内存中保持状态并跟踪更改，只要我们保持连接。</p><p>   Our browser initially connects to the server making a simple HTTP GET request to the  live route. The server calls  mount/3 and  render/1 callbacks to initialize the data and answer with a fully rendered HTML page. The browser loads the html and the application javascript in  app.js, and it connects via WebSocket to the server. Once connected, the server spawns a stateful LiveView process which stays alive as long as we are connected. In  mount/3 the LiveView process subscribes to get trade messages.</p><p>   我们的浏览器最初连接到服务器，使一个简单的HTTP获取到Live Route。服务器调用inst / 3并渲染/ 1回调，以初始化数据并使用完全呈现的HTML页面答案。浏览器在App.js中加载HTML和应用程序JavaScript，它通过WebSocket连接到服务器。一旦连接，服务器就会产生一个状态的LiveView进程，只要我们连接就会保持活力。在Mount / 3中LiveView流程订阅以获取交易消息。</p><p>  The browser sends a  phx_join message and LiveView answers with a  phx_reply message in which there is the rendered view, with dynamic and static parts. Each dynamic part has a position.</p><p>  浏览器使用PHX_REPLY消息发送PHX_JOIN消息和LIVEVIEW答案，其中有呈现视图，具有动态和静态部分。每个动态部分都有一个位置。</p><p>  Every time the LiveView process receives a new trade from PubSub, it  assign/3 the new trade to the  socket and LiveView re-renders the view calling  render/1. Only the dynamic values that change are sent to the browser with a  diff message, in this way the payload stays super compact. The LiveView JS code running in the browser takes these new values and patches the DOM using the  Morphdom library.</p><p>  每次LiveView进程从Pubsub接收新的交易时，它将它分配/ 3套接字和LiveView的新交易重新渲染呼叫渲染/ 1。只有随着Diff消息发送到浏览器的动态值，以这种方式，有效载荷保持超级紧凑。在浏览器中运行的LiveView JS代码将采用这些新值并使用形体库修补DOM。</p><p>  At the moment this view is passive, it only receives new values from the server without any user interaction. In the coming lessons we’ll see how to send events from the browser to the server using buttons, bindings and forms.</p><p>  此视图是被动的，它只接收来自服务器的新值，而无需任何用户交互。在即将到来的课程中，我们将看到如何使用按钮，绑定和表单将事件从浏览器发送到服务器。</p><p>  Packed with hours of in-depth tutorials, tips and app development.  Learn how to build a true real-time application, getting the most from Elixir and Phoenix LiveView!</p><p>  包装有小时的深入教程，提示和应用程序开发。了解如何构建真正的实时应用程序，从Elixir和Phoenix LiveView中获得最大的实时应用程序！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.poeticoding.com/how-phoenix-liveview-works/">https://www.poeticoding.com/how-phoenix-liveview-works/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/liveview/">#liveview</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>