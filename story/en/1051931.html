<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>KK计算机：激进的6502 Redesign（2018） The KK Computer: A Radical 6502 Redesign (2018)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The KK Computer: A Radical 6502 Redesign (2018)<br/>KK计算机：激进的6502 Redesign（2018） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-12 12:58:25</div><div class="page_narrow text-break page_content"><p>The mainfeature is fast access to a flat, 24-​bitaddress space. Although there are many ways to retrofit a &#39;C02 withexpanded memory, AFAIK none can touch this implementation for speed.  Givenany random address in the 16 megabyte space, KK can fetch that byte in6-8 cyles.It&#39;sfast because:</p><p>主要的功能快速访问平坦，24位地址空间。虽然有很多方法可以改装A＆＃39; C02扩展内存，AFAIK无可以触摸此实现以获得速度。给予16兆字节空间中的任何随机地址，KK可以获取该字节6-8个气缸。它＆＃39; s快速，因为：</p><p>  Units of 64K make it easy to treat the entire memory as a linear, 16megabyte space. That&#39;s because the results of address arithmetic— a24-bit addition, for example — are directly acceptable by themachine. The most-significant byte  isthe block address. This is far more efficient than a scheme using, say,16Kblocks because a 16K-block system needsto mask and shift the addition result to isolate the blockaddress before itcan be passed to the hardware.Efficient linear addressingopens the door to a modest range of &#34;big data&#34; applications—tasks which would causemost expanded-​memory 8-bit machines to hit the wall. They suffer anorder-​of-​magnitudespeed disadvantage simulating a linear space.    Mostof the controlsignals originate as  microcodefetched from an EPROM array.The microcode runs on a state machine that&#39;s clocked in lock-​step withthe CPU. (One state machine cycle = one CPU/bus cycle.)The CPU directs instruction fetching. Simultaneous execution by it andthe state machine determines the result.</p><p>  64K单位使整个内存易于将整个内存视为线性，16兆字节空间。那个＆＃39; s是地址算术的结果- 一种例如，24位添加 - 直接接受机器。最重要的字节是块地址。这比使用计划更有效，比如说，16K.块由于16k块系统需求掩盖并转移添加结果以隔离块之前的地址可以传递给硬件。高效的线性寻址打开大门的＆＃34;大数据＆＃34;应用程序 - 将导致的任务最扩展的内存8位机器击中墙壁。他们遭受了一个阶数级数速度缺点模拟线性空间。    最多控制信号源自微码从EPROM阵列中获取。微码在＆＃39; s时钟的状态机上运行CPU。 （一个状态机周期=一个CPU /总线循环。）CPU指示指令获取。同时执行它和状态机确定结果。</p><p>  Block (aka bank)addresses arestored in Register FileA, whose read section (at the top of the diagram) feeds A23-​A16. Thesenewaddress lines — and A15-​A0 directly from the 65C02— arewhat address the 16 megabyte space. (You&#39;ll see there&#39;s asecondregister file which shadows the first. This makes it possibleto readback the stored bank addresses when necessary.)  A single instruction isall that&#39;s required to load a new bank address.That&#39;s considerably simpler thanI/O operations on an MMU. And, in contrast to an MMU manipulation, there&#39;s no need tosave then later restore A, X, Y or P. These registers remain undisturbed.</p><p>  块（又名银行）地址是存储在寄存器文件中A，其读取部分（图的顶部）馈送A23-A16。这些新的地址行 - 直接从65C02的A15-A0- 是什么地址为16兆字节的空间。 （你＆＃39; ll看到那里＆＃39; s a第二注册文件哪个阴影第一个。这使得它成为可能读书必要时返回存储的银行地址。）单个指令是所有那个＆＃39;要求加载新的银行地址。那个＆＃39; s的比较简单MMU上的I / O操作。而且，与MMU操纵相比，没有必要另保存然后稍后还原A，X，Y或P.这些寄存器仍未受到干扰。</p><p>  Thecoprocessor acts as  anexo-​skeleton forthe 65C02.Devices such as the register files connect to the data bus and receivemicrocoded cues to update themselves from it.Some­times they  drivethe bus when the CPU thinks it&#39;sreading data, instruction opcodes or instruction operands frommemory. Some ofthe 46 undefined (aka illegal) 65C02opcodes get aliased by the 32 x 8 PROM before they reachthe CPU. Others are used &#34;as is.&#34; In fact, some of the 65C02&#39;sso-called NOPs actually generatean address and use the bus, even though the data is discarded. This oddbehavior turns out to presentimportant opportunities. But all these details are invisible; theprogrammersimply has 44 new inst­ructions available (for a total of 254).</p><p>  这协处理器充当exo-骨架65C02。寄存器文件等设备连接到数据总线并接收微透模提示从中更新自己。有时他们开车当CPU认为它＆＃39; s时的公共汽车读取数据，指令操作码或指令操作数记忆。一些46未定义（AKA非法）65C02在他们到达之前，Opcodes在32 x 8副舞会上获得别名CPU。其他人使用＆＃34;和＃34一样。＆＃34;事实上，其中一些65c02＆＃39; s所谓的nop实际生成即使数据被丢弃，也可以使用总线并使用总线。这个奇怪的行为原因出现在场重要的机会。但所有这些细节都是看不见的;这程序员只需44项新指令（共254个）。</p><p>    instructionsthat load and save the bankaddressescued up in the register file (K0, K1, K2 &amp; K3)</p><p>    指示加载并保存银行地址在注册文件（K0，K1，K2＆amp; K3）中提示</p><p>  instructionsthat actually  outputa bankaddress ontoA23-​A16 (usually on a transient basis)</p><p>  指示实际上输出一个银行地址到A23-A16（通常在短暂的基础上）</p><p>  K0 is presentedalmost continuously on address lines A23-​A16, as it&#39;s usedfor all code fetches. K0 is also the defaultfor data accesses. In the absence of a specificationfor K1, K2 or K3, it will be K0 that&#39;s used, which means thedata access willoccur in the same bank as the currently-executing code. (A exceptionapplies when stack and zero-page address modes are used. Such accessesalways usebank $00 —not to be confused with K0).</p><p>  提出了K0.几乎连续地在地址线A23-A16上，作为它的使用＆＃39;使用对于所有代码提取。 k0也是默认值用于数据访问。在没有规范的情况下对于K1，K2或K3，它将是k0＆＃39; s使用，这意味着数据访问将是在与当前执行代码的同一银行发生。 （一个例外使用堆栈和零页地址模式时适用。这样的访问始终使用银行$ 00  - 不要与k0混淆）。 </p><p>  Three single-​byte  prefixinstructions areassociated with registers K1, K2 and K3. Use of a prefix is one way tospecify a &#34;Far&#34; data access — that is, one whose bank addressisindependent of where the currently-executing code resides. Theprefix is followed by and acts upon any typical 65C02instruction such as INCAbsolute, CMP Indirect,Y etc.Here&#39;s the sequence. At run-​time the CPU fetches the prefix byte butignores it. Even thecoprocessor takes no immediate action. Next comes the targetinstruction, and, as usual, off-​chip logic co-​executes every cycle.This includesthe extra cycles for zero-​page indirection and other variations.Then  K1,K2or K3 is read out &#34;on cue&#34; for the data transfer which is the finalcycleof theinstruction (final  threecycles forRead-​Modify-​Write). Allof the CPU&#39;s 64K possible addresses are re-​mapped by the bank switch.Then K0 isre-​selected for A23-​A16, an opcode fetch occurs, and the programproceeds without missing a beat. (The only added delay was one cyclefor the prefix.) Many combinationsof instructions and address modes can use the prefixes andthus becomeFar. Considering all the combinations, youcould say there are  hundredsof new inst­ructions,notjust 44.</p><p>三个单字节前缀说明是与寄存器K1，K2和K3相关联。使用前缀是一种方式指定A＆＃34; FAR＆＃34;数据访问 - 即，其中一个银行地址是独立于当前执行的代码所在的位置。这前缀后跟并作用于任何典型的65c02诸如公司绝对，CMP间接，y等这里＆＃39;序列。在运行时，CPU获取前缀字节但是忽略它。即便是协处理器没有立即采取行动。接下来是目标指令，以及通常的异室逻辑执行每个周期。这包括零页间接和其他变体的额外周期。然后k1，K2或K3被读出＆＃34;在提示和＃34上;对于最终的数据传输循环的教学（最终三个循环读取 - 修改 - 写）。全部CPU＆＃39; S 64K可能的地址被银行交换机重新映射。然后k0是重新选择为A23-A16，发生操作码获取，并发生程序没有错过节拍的收益。 （唯一的延迟是一个循环对于前缀。）许多组合说明和地址模式可以使用前缀和从而成为远的。考虑到所有组合，你可以说有数百人新指令，不是只是44。</p><p>  Because they open a&#34;Far&#34; dimension for so many 65c02 instructions, theprefixes are very general in their applicability. But, as noted, a onecyclepenalty applies. Even this can be avoided, albeit with a lossofgenerality. Theseparateprefix may be omitted for six specific casesinvolving LDA and STA, since six specific, &#34;all-in-one&#34;opcodesareprovided. Specificopcodes are also provided for  JMP_K3,  JSR_K3 and  RTS_K3.Theseinstructions include an operation that  exchangesK3 and K0—and, because K0 is updated, a new 64K bank becomes the default.(Happily, this does not imply alternative zero-​pages and stacks!Recall thataccesses using stack and zero-​page address modesalways use bank zero, regardless of what K0 may contain.)</p><p>  因为他们打开一个＆＃34; far＆＃34;适用于这么多65C02的尺寸前缀在适用性方面非常一般。但是，如上所述，一个循环罚款适用。即便如此，也可以避免，尽管造成损失的概论。这分离对于六种特定情况，可以省略前缀涉及LDA和STA，自六个特定的，＆＃34;一体化＆＃34;opcodes.是假如。具体的还为JMP_K3提供操作码，  JSR_K3和rts_k3。这些说明包括交换的操作K3和K0. - 并且，因为k0更新，新的64k银行成为默认值。（愉快地，这并不意味着替代零页和堆栈！回顾使用堆栈和零页地址模式访问始终使用银行零，无论k0可能包含什么。）</p><p>  Bank-addressregisters K1, K2 and K3 loadthemselves in the samemanner that X,Y and A load themselves — that is, withspecific opcodes provided for the purpose. The availableaddress modes are Immediate, Absolute, Zero-pg and Zero-pg, X. Thesethreeregisters can also be pushed and pulled from stack, and K0can bepushed.Altogether there are 34 instructions for performing Far jumps, Far dataaccesses, and for loading and saving bankaddresses.</p><p>  银行地址寄存器K1，K2和K3负载他们自己在一起x，y和一个加载自己 - 即为此目的提供了特定的操作码。可用地址模式是立即的，绝对的，零pg和零pg，x。这些三寄存器也可以从堆栈中推动和拉动，而k0可推。完全有34条执行跳跃的指令，远程数据访问，加载和保存银行地址。</p><p>    A few highlightsfrom this disparate group are asfollows. The SCAN_K3instruction forces theCPU to rapidly read a long string of bytes from memory, as part of aprogram thatoutputs video.</p><p>    一些亮点来自这个不同的组是跟随。 scan_k3.教学迫使CPU从内存中快速读取长长的字节字节，作为a的一部分计划输出视频。</p><p>  W is a 16-​bitregister readable in zero-​page, one ofwhose functions is  double-​indexedaddressing. This is atwo-stepprocess that starts withan instruction coded to use (Z-​pg,X) mode. The cpu does the indexaddition then fetches a two-byte pointer from zero-page asit completes the instruction. KK copies the two-bytepointer on the fly, making it subsequentlyavailable in Z-pg at W (with no need to repeat the indexaddition). If asubsequent instructionis coded to use (W),Y then the result of the two-instructionsequence is (Z-pg,X),Y mode. It&#39;sequivalent to using X to index to apointer,fetching the pointer, then indexing again into a data array. This isnot so unusual, given that even a 16-bit word (two bytes) constitutesanarray.Double-​indexed addressing accelerates Forth mainstays such as @ and !(fetch and store).</p><p>  w是一个16位寄存在零页中的读数，其中一个其功能是双重索引的解决。这是一个两步开始的过程编码为使用的指令（z-pg，x）模式。 CPU是索引添加然后从零页获取一个双字节指针它完成了指令。 kk复制了双字节指针在飞行中，随后使它成为在w的z-pg中使用（无需重复索引添加）。如果一个后续教学被编码为使用（w），y然后是双指令的结果序列是（z-pg，x），y模式。它＆＃39; s等同于将x索引到a指针，获取指针，然后再次索引到数据阵列中。这是没有那么异常，鉴于即使是一个16位字（两个字节）构成一个大批。双重索引的寻址加速了@和！（获取和存储）。</p><p>  IP is a16-​bit register whose most notable functionis as a pointerfor the JMP((IP++)) instruction. This double-​indirect jumpwith post-​incrementis a hardware realization of Forth&#39;s ubiquitous NEXToperation.  HardwareNEXT has quadruplethe speed of the code sequence it replaces.Overall Forth program speed increasesby about 90%.</p><p>  IP是A.16位寄存器，其最值得注列的功能是一个指针对于JMP（（IP ++））指令。这种双关联跳跃递增是一个硬件实现＆＃39;普遍存在的下一个手术。硬件接下来有四边形它替换的代码序列的速度。总体上行程序速度增加大约90％。</p><p>    KimKlone&#39;s CPU andthe off-​chip accessories function as a unifiedwhole, much the same as a monolithic device created in awafer fab. The design is notable for introducing major featuresdespite the limitations of a legacy Programming Model and even legacysilicon.</p><p>    kimklone＆＃39; c cpu和片外配件函数是统一的整体，与在a中创建的单片设备相同晶圆厂。该设计非常适合引入主要功能尽管传统编程模型甚至遗产的局限性局限性硅。 </p><p>  The linear memoryorganization allows efficientmanipulation of objects larger than 64K —  acapability which is absentfrom commercial 6502 microcomputers and from microprocessors such asthe MOS 6509 and the Hudson Soft 6280and which, in retrospect, is more suggestiveof the WDC 65816.(The KK was created shortly after but without any influence from the65816.)</p><p>线性内存  组织允许高效  操纵大于64k的物体 -  a  缺席的能力  从商业6502微型计算机和微处理器如  MOS 6509和Hudson Soft 6280  回想起来，哪些暗示  WDC 65816。  （KK是在不久之后创造的，但没有任何影响  65816.） </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://laughtonelectronics.com/Arcana/KimKlone/Kimklone_short_summary.html">http://laughtonelectronics.com/Arcana/KimKlone/Kimklone_short_summary.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/计算机/">#计算机</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/computer/">#computer</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/地址/">#地址</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>