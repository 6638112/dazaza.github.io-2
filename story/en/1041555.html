<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Linux用户命名空间发展容器安全性 Evolving Container Security with Linux User Namespaces</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Evolving Container Security with Linux User Namespaces<br/>使用Linux用户命名空间发展容器安全性 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-24 21:26:47</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/9d05edcef6860b246bf6467cd0e70536.png"><img src="http://img2.diglog.com/img/2020/12/9d05edcef6860b246bf6467cd0e70536.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>By  Fabio Kung,  Sargun Dhillon,  Andrew Spyker,  Kyle, Rob Gulewich,  Nabil Schear,  Andrew Leung, Daniel Muino, and Manas Alekar</p><p>孔碧波（Fabio Kung），萨贡·迪伦（Sargun Dhillon），安德鲁·史派克（Andrew Spyker），凯尔（Kyle），罗伯·古列维奇（Rob Gulewich），纳比尔·谢尔（Nabil Schear），梁安德（Andrew Leung），丹尼尔·穆伊诺（Daniel Muino）和玛纳斯·阿莱卡尔（Manas Alekar）</p><p> As previously discussed on the Netflix Tech Blog,  Titus is the Netflix container orchestration system. It runs a wide variety of workloads from various parts of the company — everything from the frontend API for netflix.com, to machine learning training workloads, to video encoders. In Titus, the hosts that workloads run on are abstracted from our users. The Titus platform maintains large pools of homogenous node capacity to run user workloads, and the Titus scheduler places workloads. This abstraction allows the compute team to influence the reliability, efficiency, and operability of the fleet via the scheduler. The hosts that run workloads are called Titus “agents.” In this post, we describe how Titus agents leverage  user namespaces to improve the overall security of the Titus agent fleet.</p><p> 如之前在Netflix Tech Blog上讨论的那样，Titus是Netflix容器编排系统。它运行着公司各个部门的各种工作负载-从netflix.com的前端API到机器学习培训工作负载到视频编码器，应有尽有。在Titus中，运行负载的主机是从我们的用户中抽象出来的。 Titus平台维护着大量的同构节点容量池来运行用户工作负载，而Titus调度程序则放置了工作负载。这种抽象使计算团队可以通过调度程序影响机队的可靠性，效率和可操作性。运行工作负载的主机称为Titus“代理”。在本文中，我们描述了Titus代理如何利用用户名称空间来提高Titus代理团队的整体安全性。</p><p>  The Titus agent fleet appears to users as a homogenous pool of capacity. Titus internally employs a cellular  bulkhead architecture for scalability, so the fleet is composed of multiple cells. Many bulkhead architectures partition their cells on tenants, where a tenant is defined as a team and their collection of applications. We do not take this approach, and instead, we partition our cells to balance  load. We do this for reliability, scalability, and efficiency reasons.</p><p>  Titus代理团队在用户看来是同质的能力库。 Titus在内部采用蜂窝式隔板结构来实现可扩展性，因此，舰队由多个单元组成。许多隔板架构将其单元划分为租户，其中租户被定义为一个团队及其应用程序集合。我们不采用这种方法，而是对单元进行分区以平衡负载。我们这样做是出于可靠性，可伸缩性和效率的原因。</p><p>  Titus is a multi-tenant system, allowing multiple teams and users to run workloads on the system, and ensuring they can all co-exist while still providing guarantees about security and performance. Much of this comes down to isolation, which comes in multiple forms. These forms include performance isolation (ensuring workloads do not degrade one another’s performance), capacity isolation (ensuring that a given tenant can acquire resources when they ask for them), fault isolation (ensuring that the failure of a part of the system doesn’t cause the whole system to fail), and security isolation (ensuring that the compromise of one tenant’s workload does not affect the security of other tenants). This post focuses on our approaches to security isolation.</p><p>  Titus是一个多租户系统，允许多个团队和用户在系统上运行工作负载，并确保它们可以共存，同时仍提供有关安全性和性能的保证。其中大部分归结为隔离，形式多种多样。这些形式包括性能隔离（确保工作负载不会降低彼此的性能），容量隔离（确保给定的租户在需要时可以获取资源），故障隔离（确保系统的一部分故障不会造成损害）。导致整个系统发生故障），安全隔离（确保一个租户的工作负荷受到损害不会影响其他租户的安全）。这篇文章重点介绍我们的安全隔离方法。</p><p>  One of Titus’s biggest concerns with multi-tenancy is security isolation. We want to allow different kinds of containers from different tenants to run on the same instance. Security isolation in containers has been a  contentious topic. Despite the risks, we’ve chosen to leverage containers as part of our security boundary. To offset the risks brought about by the container security boundary, we employ some additional protections.</p><p>  Titus对多租户的最大担忧之一是安全隔离。我们希望允许来自不同租户的不同种类的容器在同一实例上运行。容器中的安全隔离一直是一个有争议的话题。尽管存在风险，我们还是选择利用容器作为安全边界的一部分。为了抵消集装箱安全边界带来的风险，我们采用了一些附加保护措施。</p><p> The building blocks of multi-tenancy are  Linux namespaces, the very technology that makes LXC, Docker, and other kinds of containers possible. For example, the PID namespace makes it so that a process can only see PIDs in its own namespace, and therefore cannot send kill signals to random processes on the host. In addition to the default Docker namespaces (mount, network, UTS, IPC, and PID), we employ user namespaces for added layers of isolation. Unfortunately, these default namespace boundaries are not sufficient to prevent container escape, as seen in CVEs like  CVE-2015–2925. These vulnerabilities arise due to the complexity of interactions between namespaces, a large number of historical decisions during kernel development, and leaky abstractions like the proc filesystem in Linux. Composing these security isolation primitives correctly is difficult, so we’ve looked to other layers for additional protection.</p><p> 多租户的构建块是Linux名称空间，这是使LXC，Docker和其他类型的容器成为可能的技术。例如，PID名称空间可以使进程只能在其自己的名称空间中看到PID，因此不能向主机上的随机进程发送终止信号。除了默认的Docker名称空间（挂载，网络，UTS，IPC和PID），我们还使用用户名称空间来增加隔离层。不幸的是，如CVE-2015–2925这样的CVE中所见，这些默认的名称空间边界不足以防止容器转义。这些漏洞的出现是由于名称空间之间的交互的复杂性，内核开发过程中的大量历史决策以及诸如Linux中的proc文件系统之类的泄漏抽象所致。正确组合这些安全隔离原语很困难，因此我们已经寻求其他层的额外保护。</p><p> Running many different workloads multi-tenant on a host necessitates the prevention lateral movement, a technique in which the attacker compromises a single piece of software running in a container on the system, and uses that to compromise other containers on the same system. To mitigate this, we run containers as unprivileged users — making it so that users cannot use “root.” This is important because, in Linux, UID 0 (or root’s privileges), do not come from the mere fact that the user is root, but from  capabilities. These capabilities are tied to the current process’s credentials. Capabilities can be added via privilege escalation (e.g., sudo, file capabilities) or removed (e.g., setuid, or switching namespaces). Various capabilities control what the root user can do. For example, the CAP_SYS_BOOT capability controls the ability of a given user to reboot the machine. There are also more common capabilities that are granted to users like CAP_NET_RAW, which allows a process the ability to open raw sockets. A user can automatically have capabilities added when they execute specific files via file capabilities. For example, on a stock Ubuntu system, the ping command needs CAP_NET_RAW:</p><p> 在主机上多租户运行许多不同的工作负载，需要进行横向移动预防，这种技术是攻击者破坏了在系统容器中运行的单个软件，并利用该软件破坏了同一系统上的其他容器。为了减轻这种情况，我们将容器作为非特权用户运行-使其无法使用“ root”用户。这一点很重要，因为在Linux中，UID 0（或root的特权）并非仅来自用户是root的事实，而是来自功能。这些功能与当前流程的凭据有关。可以通过权限升级（例如sudo，文件功能）来添加功能，也可以通过移除（例如setuid或切换名称空间）来删除功能。各种功能控制着root用户可以做什么。例如，CAP_SYS_BOOT功能控制给定用户重新启动计算机的能力。还授予用户更常见的功能，例如CAP_NET_RAW，它使进程能够打开原始套接字。用户通过文件功能执行特定文件时可以自动添加功能。例如，在现有的Ubuntu系统上，ping命令需要CAP_NET_RAW： </p><p>  One of the most powerful capabilities in Linux is CAP_SYS_ADMIN, which is effectively equivalent to having superuser access. It gives the user the ability to do everything from mounting arbitrary filesystems, to accessing tracepoints that can expose vital information about the Linux kernel. Other powerful capabilities include CAP_CHOWN and CAP_DAC_OVERRIDE, which grant the capability to manipulate file permissions.</p><p>CAP_SYS_ADMIN是Linux中最强大的功能之一，实际上等效于具有超级用户访问权限。它使用户能够执行所有操作，从装入任意文件系统到访问可以公开有关Linux内核重要信息的跟踪点。其他强大的功能包括CAP_CHOWN和CAP_DAC_OVERRIDE，它们可以操纵文件权限。</p><p> In the kernel, you’ll often see capability checks spread throughout the code, which looks something like this:</p><p> 在内核中，您经常会看到功能检查遍及整个代码，如下所示：</p><p>  Notice this function doesn’t check if the user is root, but if the task has the CAP_SYS_ADMIN capability before allowing it to execute.</p><p>  请注意，该函数不会检查用户是否是root用户，而是会在允许任务执行之前检查该任务是否具有CAP_SYS_ADMIN功能。</p><p> Docker takes the approach of using an allow-list to define which capabilities a container  receives. These can be extended or attenuated by the user. Even the default capabilities that are defined in the Docker profile can be abused in certain situations. When we looked into running workloads as unprivileged users without many of these capabilities, we found that it was a non-starter. Various pieces of software used elevated capabilities for FUSE, low-level packet monitoring, and performance tracing amongst other use cases. Programs will usually start with capabilities, perform any activities that require those capabilities, and then “drop” them when the process no longer needs them.</p><p> Docker采用允许列表定义容器接收哪些功能的方法。这些可以由用户扩展或减弱。在某些情况下，甚至Docker概要文件中定义的默认功能也可能被滥用。当我们以没有这些功能中许多功能的非特权用户身份查看正在运行的工作负载时，我们发现它不是一个入门者。各种软件都在FUSE，低级数据包监视和性能跟踪等其他用例中使用了增强的功能。程序通常从功能开始，执行任何需要这些功能的活动，然后在流程不再需要它们时“删除”它们。</p><p>  Fortunately, Linux has a solution — User Namespaces. Let’s go back to that kernel code example earlier. The  pcrlock function called the capable function to determine whether or not the task was  capable. This function is defined as:</p><p>  幸运的是，Linux有一个解决方案-用户命名空间。让我们回到前面的内核代码示例。 pcrlock函数调用有能力的函数来确定任务是否有能力。此函数定义为：</p><p>  This checks if the task has this capability relative to the  init_user_ns. The  init_user_ns is the namespace that processes are initialially spawned in, as it’s the only user namespace that exists at kernel startup time. User namespaces are a mechanism to split up the  init_user_ns UID space. The interface to set up the mappings is via a “uid_map” and “gid_map” that’s exposed via /proc. The mapping looks something like this:</p><p>  这将检查任务相对于init_user_ns是否具有此功能。 init_user_ns是最初产生进程的名称空间，因为它是内核启动时存在的唯一用户名称空间。用户名称空间是一种用于分割init_user_ns UID空间的机制。设置映射的接口是通过/ proc显示的“ uid_map”和“ gid_map”。映射如下所示：</p><p>  This allows UIDs in user-namespaced containers to be mapped to host UIDs. A variety of translations occur, but from the container’s perspective, everything is from the perspective of the UID ranges (otherwise known as extents) that are mapped. This is powerful in a few ways:</p><p>  这允许将用户命名空间容器中的UID映射到主机UID。发生了各种翻译，但是从容器的角度来看，所有内容都是从映射的UID范围（也称为范围）的角度来看的。这在几个方面都很强大： </p><p> It allows you to make certain UIDs off-limits to the container — if a UID is not mapped in the user namespace to a real UID, and you try to examine a file on disk with it, it will show up as  overflowuid / overflowgid, a UID and GID specified in /proc/sys to indicate that it cannot be mapped into the current working space. Also, the container cannot setuid to a UID that can access files owned by that “outside uid.”</p><p>它允许您对容器设置某些UID禁区-如果未在用户名称空间中将UID映射到真实的UID，并且您尝试使用它检查磁盘上的文件，则该文件将显示为overflowuid / overflowgid， / proc / sys中指定的UID和GID，以指示无法将其映射到当前工作空间中。此外，容器不能将setuid设置为可以访问该“外部uid”拥有的文件的UID。</p><p> From the user namespace’s perspective, the container’s root user appears to be UID 0, and the container can use the entire range of UIDs that are mapped into that namespace.</p><p> 从用户名称空间的角度来看，容器的根用户似乎是UID 0，并且容器可以使用映射到该名称空间的整个UID范围。</p><p> Kernel subsystems can then proceed to call ns_capable with the specific user namespace that is tied to the resource. Many capability checks are now done to a user namespace that is relative to the resource being manipulated. This, in turn, allows processes to exercise certain privileges without having any privileges in the init user namespace. Even if the mapping is the same across many different namespaces, capability checks are still done relative to a specific user namespace.</p><p> 然后，内核子系统可以继续使用绑定到资源的特定用户名称空间来调用ns_capable。现在，相对于要处理的资源，对用户名称空间进行了许多功能检查。反过来，这允许进程行使某些特权，而在初始化用户名称空间中没有任何特权。即使在许多不同的名称空间上映射是相同的，功能检查仍相对于特定的用户名称空间进行。</p><p> One critical aspect of understanding how permissions work is that every namespace belongs to a specific  user namespace. For example, let’s look at the UTS namespace, which is responsible for controlling the hostname:</p><p> 理解权限如何工作的一个关键方面是每个名称空间都属于一个特定的用户名称空间。例如，让我们看一下负责控制主机名的UTS命名空间：</p><p>  The namespace has a relationship with a particular user namespace. The ability for a user to manipulate the hostname is based on whether or not the process has the appropriate capability in that user namespace.</p><p>  命名空间与特定的用户命名空间有关系。用户操作主机名的能力取决于该进程在该用户名称空间中是否具有适当的能力。</p><p>   We can examine how the interaction of namespaces and users work ourselves. To set the hostname in the UTS namespace, you need to have CAP_SYS_ADMIN in its  user namespace. We can see this in action here, where an unprivileged process doesn’t have permission to set the hostname:</p><p>   我们可以检查名称空间和用户之间的交互作用。要在UTS命名空间中设置主机名，您需要在其用户命名空间中使用CAP_SYS_ADMIN。我们可以在这里看到这一点，其中无特权的进程没有权限设置主机名：</p><p>  The reason for this is that the process does not have CAP_SYS_ADMIN. According to /proc/self/status, the effective capability set of this process is empty:</p><p>  这样做的原因是该进程没有CAP_SYS_ADMIN。根据/ proc / self / status，此过程的有效功能集为空： </p><p>  Now, let’s try to set up a user namespace, and see what happens:</p><p>现在，让我们尝试设置用户名称空间，然后看看会发生什么：</p><p>  Immediately, you’ll notice the command prompt says the current user is root, and that the id command agrees. Can we set the hostname now?</p><p>  马上，您会注意到命令提示符说当前用户是root用户，并且id命令同意。现在可以设置主机名吗？</p><p>  We still cannot set the hostname. This is because the process is still in the initial UTS namespace. Let’s see if we can unshare the UTS namespace, and set the hostname:</p><p>  我们仍然无法设置主机名。这是因为该过程仍在初始UTS名称空间中。让我们看看是否可以取消共享UTS名称空间，并设置主机名：</p><p>  This is now successful, and the process is in an isolated UTS namespace with the hostname “foo.” This is because the process now has all of the capabilities that a traditional root user would have, except they are relative to the new user namespace we created:</p><p>  现在已成功完成，并且该过程位于主机名为“ foo”的隔离UTS名称空间中。这是因为该过程现在具有传统root用户将拥有的所有功能，除了它们相对于我们创建的新用户名称空间而言：</p><p>  If we inspect this process from the outside, we can see that the process still runs as the unprivileged user, and the hostname in the original outside namespace hasn’t changed:</p><p>  如果我们从外部检查此过程，则可以看到该过程仍以非特权用户身份运行，并且原始外部名称空间中的主机名未更改：</p><p>  From here, we can do all sorts of things, like mount filesystems, create other new namespaces, and in fact, we can create an entire container environment. Notice how no privilege escalation mechanism was used to perform any of these actions. This approach is what some people refer to as “ rootless containers.”</p><p>  从这里，我们可以做各种事情，例如挂载文件系统，创建其他新的名称空间，实际上，我们可以创建整个容器环境。请注意，没有任何特权升级机制用于执行任何这些操作。这种方法被某些人称为“无根容器”。</p><p>  We began work to enable user namespaces in early 2017. At the time we had a naive model that was simpler. This simplicity was possible because we were running without user namespaces:</p><p>  我们从2017年初开始启用用户名称空间。当时，我们有一个更简单的天真模型。之所以如此简单是因为我们在没有用户名称空间的情况下运行： </p><p>  This approach mirrored the process layout and boundaries of contemporary container orchestration systems. We had a shared metrics daemon on the machine that reached in and polled metrics from the container. User access was done by exposing an SSH daemon, and automatically doing nsenter on the user’s behalf to drop them into the container. To expose files to the container we would use bind mounts. The same mechanism was used to expose configuration, such as secrets.</p><p>这种方法反映了现代容器编排系统的过程布局和边界。我们在机器上有一个共享的度量标准守护程序，该守护程序到达了容器并从容器中轮询了度量标准。用户访问是通过公开SSH守护程序并代表用户自动执行nsenter并将其放入容器中来完成的。要将文件暴露给容器，我们将使用绑定安装。使用相同的机制来公开配置，例如机密。</p><p> This had the benefit that much of our software could be installed in the host namespace, and only manage files in the that namespace. The container runtime management system (Titus) was then responsible for configuring Docker to expose the right files to the container via bind mounts. In addition to that, we could use our standard metrics daemons on the host.</p><p> 这样做的好处是，我们的许多软件都可以安装在主机名称空间中，并且仅管理该名称空间中的文件。然后，容器运行时管理系统（Titus）负责配置Docker，以通过绑定安装将正确的文件公开给容器。除此之外，我们可以在主机上使用我们的标准指标守护程序。</p><p> Although this model was easy to reason about and write software for, it had several shortcomings that we addressed by shifting everything to running inside of the container’s unprivileged user namespace. The first shortcoming was that all of the host daemons now needed to be aware of the UID translation, and perform the proper setuid or chown calls to transition across the container boundary. Second, each of these transitions represented a security risk. If the SSH daemon only partially transitioned into the container namespace by changing into the container’s pid namespace, it would leave its /proc accessible. This could then be used by a malicious attacker to escape.</p><p> 尽管此模型易于推理和编写软件，但它存在一些缺点，我们通过将所有内容转移到在容器的非特权用户名称空间中运行来解决。第一个缺点是现在所有主机守护程序都需要了解UID转换，并执行适当的setuid或chown调用以跨容器边界过渡。其次，这些过渡中的每一个都存在安全风险。如果SSH守护程序仅通过更改为容器的pid名称空间而部分过渡到了容器名称空间，它将使其/ proc可访问。然后，恶意攻击者可以使用它来逃脱。</p><p> With user namespaces, we can improve our security posture and reduce the complexity of the system by running those daemons  in the container’s unprivileged user namespace, which removes the need to cross the namespace boundaries. In turn, this removes the need to correctly implement a cross-namespace transition mechanism thus, reducing the risk of introducing container escapes.</p><p> 借助用户名称空间，我们可以通过在容器的非特权用户名称空间中运行这些守护程序来改善我们的安全状况并降低系统的复杂性，从而无需跨越名称空间边界。反过来，这消除了正确实现跨命名空间过渡机制的需要，从而减少了引入容器转义符的风险。</p><p>  We did this by moving aspects of the container runtime environment into the container. For example, we run an SSH daemon per container and a metrics daemon per container. These run inside of the namespaces of the container, and they have the same capabilities and lifecycle as the workloads in the container. We call this model “System Services” — one can think of it as a primordial version of pods. By the end of 2018, we had moved all of our containers to run in unprivileged user namespaces successfully.</p><p>  为此，我们将容器运行时环境的各个方面移入了容器。例如，我们为每个容器运行一个SSH守护程序，并为每个容器运行一个指标守护程序。它们在容器的名称空间内运行，并且具有与容器中的工作负载相同的功能和生命周期。我们称此模型为“系统服务”-可以将其视为Pod的原始版本。到2018年底，我们已经将所有容器移至可在非特权用户名称空间中成功运行的位置。</p><p>  This may seem like another level of indirection that just introduces complexity, but instead, it allows us to leverage an extremely useful concept — “unprivileged containers.” In unprivileged containers, the root user starts from a baseline in which they don’t automatically have access to the entire system. This means that DAC, MAC, and seccomp policies are now an extra layer of defense against accessing privileged aspects of the system — not the only layer. As new privileges are added, we do not have to add them to an exclusion list. This allows our users to write software where they can control low-level system details in their own containers, rather than forcing all of the complexity up into the container runtime.</p><p>  看起来这似乎是间接的另一层次，它引入了复杂性，但相反，它允许我们利用一个极其有用的概念-“无特权的容器”。在无特权的容器中，root用户从一个基准开始，在该基准下，他们无法自动访问整个系统。这意味着DAC，MAC和seccomp策略现在是防止访问系统特权方面的额外防御层-而不是唯一的一层。添加新特权后，我们不必将其添加到排除列表中。这使我们的用户可以编写软件，在其中可以控制自己容器中的低级系统详细信息，而不必将所有复杂性强加到容器运行时中。</p><p>  Netflix internally uses a purpose built FUSE filesystem called  MezzFS. The purpose of this filesystem is to provide access to our content for a variety of encoding tools. Most of these encoding tools are designed to interact with the POSIX filesystem API. Our Media Cloud Engineering team wanted to leverage containers for a new platform they were building, called  Archer. Archer, in turn, uses MezzFS, which needs FUSE, and at the time, FUSE required that the user have CAP_SYS_ADMIN in the initial user namespace. To accommodate the use case from our internal partner, we had to run them in a dedicated cluster where they could run privileged containers.</p><p>  Netflix内部使用了专门构建的名为MezzFS的FUSE文件系统。该文件系统的目的是为各种编码工具提供对我们内容的访问。这些编码工具中的大多数旨在与POSIX文件系统API进行交互。我们的媒体云工程团队希望利用容器构建他们正在构建的名为Archer的新平台。反过来，Archer使用需要FUSE的MezzFS，并且当时FUSE要求用户在初始用户名称空间中具有CAP_SYS_ADMIN。为了适应内部合作伙伴的用例，我们必须在专用集群中运行它们，在这些集群中它们可以运行特权容器。 </p><p> In 2017, we worked with our partner,  Kinvolk, to have patches added to the Linux kernel that allowed users to safely use FUSE from non-init user namespaces. They were able to successfully upstream these  patches, and we’ve been using them in production. From our user’s perspective, we were able to seamlessly move them into an unprivileged environment that was more secure. This simplified operations, as this workload was no longer considered exceptional, and could run alongside every other workload in the general node pool. In turn, this allowed the media encoding team access to a massive amount of compute capacity from the shared clusters, and better reliability due to the homogeneous nature of the deployment.</p><p>2017年，我们与合作伙伴Kinvolk合作，将补丁添加到Linux内核中，使用户可以安全地从非初始用户名称空间使用FUSE。他们能够成功地将这些补丁上传到上游，并且我们一直在生产中使用它们。从用户的角度来看，我们能够将它们无缝地移动到更安全的非特权环境中。由于不再将这种工作负载视为例外，因此可以简化操作，并且可以与常规节点池中的所有其他工作负载一起运行。反过来，由于部署的同质性，这使媒体编码团队可以从共享群集访问大量计算能力，并提高可靠性。</p><p>  Many CVEs related to granting containers unintended privileges have been released in the past few years:</p><p>  在过去的几年中，已经发布了许多与授予容器意外特权有关的CVE：</p><p>    There will certainly be more vulnerabilities in the future, as is to be expected in any complex, quickly evolving system. We already use the default settings offered by Docker, such as AppArmor, and seccomp, but by adding user namespaces, we can achieve a superior defense-in-depth security model. These CVEs did not affect our infrastructure because we were using user namespaces for all of our containers. The attenuation of capabilities in the init user namespace performed as intended and stopped these attacks.</p><p>    就像在任何复杂，快速发展的系统中所预期的那样，将来肯定会存在更多漏洞。我们已经使用了Docker提供的默认设置，例如AppArmor和seccomp，但是通过添加用户名称空间，我们可以实现高级的深度防御安全模型。这些CVE不会影响我们的基础架构，因为我们正在为所有容器使用用户名称空间。初始化用户名称空间中的功能衰减已按预期执行，并阻止了这些攻击。</p><p>  There are still many bits of the Kernel that are receiving support for user namespaces or enhancements making user namespaces easier to use. Much of the work left to do is focused on filesystems and container orchestration systems themselves. Some of these changes are slated for upcoming kernel releases. Work is being done to add  unprivileged mounts to overlayfs allowing for nested container builds in a user namespace with layers.  Future work is going on to make the Linux kernel VFS layer natively understand ID translation. This will make user namespaces with different ID mappings able to access the same underlying filesystem by shifting UIDs through a bind mount. Our partners at Kinvolk are also working on bringing user namespaces to  Kubernetes.</p><p>  内核中仍有许多部分正在获得对用户名称空间或增强功能的支持，从而使用户名称空间更易于使用。剩下要做的许多工作都集中在文件系统和容器编排系统本身上。其中一些更改将在即将发布的内核版本中发布。正在完成将无特权的挂载添加到overlayfs的工作，以允许在具有层的用户命名空间中构建嵌套容器。未来的工作将使Linux内核VFS层本身了解ID转换。这将使具有不同ID映射的用户名称空间能够通过在绑定安装中移动UID来访问同一基础文件系统。我们在Kinvolk的合作伙伴还致力于将用户名称空间引入Kubernetes。</p><p> Today, a variety of container runtimes support user namespaces. Docker can set up machine-wide UID mappings with separate user namespaces per container, as outlined in their  docs. Any  OCI compliant runtime such as Containerd / runc, Podman, and systemd-nspawn support user namespaces. Various container orchestration engines also support user namespaces via their underlying container runtimes, such as Nomad and Docker Swarm.</p><p> 如今，各种容器运行时都支持用户名称空间。 Docker可以按照其文档中的概述，为每个容器使用单独的用户名称空间设置机器范围的UID映射。任何符合OCI的运行时，例如Containerd / runc，Podman和systemd-nspawn，都支持用户名称空间。各种容器编排引擎还通过其基础容器运行时来支持用户名称空间，例如Nomad和Docker Swarm。</p><p> As part of our move to Kubernetes, Netflix has been working with Kinvolk on getting user namespaces to work under Kubernetes. You can follow this work via the KEP discussion  here, and Kinvolk has more information about running user namespaces under Kubernetes  on their blog. We look forward to evolving container security together with the Kubernetes community.</p><p> 作为我们迁移到Kubernetes的一部分，Netflix一直在与Kinvolk合作，以使用户名称空间在Kubernetes下工作。您可以通过此处的KEP讨论来跟踪此工作，并且Kinvolk在其博客上的Kubernetes下具有有关运行用户名称空间的更多信息。我们期待与Kubernetes社区一起发展容器安全性。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://netflixtechblog.com/evolving-container-security-with-linux-user-namespaces-afbe3308c082">https://netflixtechblog.com/evolving-container-security-with-linux-user-namespaces-afbe3308c082</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/container/">#container</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/容器/">#容器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>