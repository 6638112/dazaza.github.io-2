<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>将编程语言作为自然界中的对象 Programming Languages as Objects in Nature</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Programming Languages as Objects in Nature<br/>将编程语言作为自然界中的对象 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-25 13:11:58</div><div class="page_narrow text-break page_content"><p>In the early 1990s, the programming languages research community was in anoptimistic mood. In the recent past, two of its paradigmatic languages— Schemeand ML— had formalized their semantics. For ML, it took the form of a wholebook by Milner, et al. Scheme provided a denotational semantics in itsstandard. Surely, it seemed, it was only a matter of time before all languageswent in this direction.</p><p>在1990年代初，编程语言研究界处于乐观状态。在最近的过去，它的两种范式语言（Scheme和ML）已将其语义正式化。对于ML，它采用了Milner等人的全书形式。 Scheme在其标准中提供了指称语义。当然，所有语言朝着这个方向迈进只是时间问题。</p><p>  If you’re a working programmer without a theoretical background, you mightwonder why a formal semantics matters at all. It’s actually for reasons you canunderstand easily. When you write programs against code that someone elsewrote, you like having an interface, or  , to program against. It mediatesyour conversation with the remote code, and anchors conversations about whom toblame if something doesn’t work as expected.</p><p>  如果您是一个没有理论背景的工作程序员，那么您可能会奇怪，为什么正式的语义至关重要。实际上是出于您容易理解的原因。当您针对别人编写的代码编写程序时，您喜欢使用一个接口或进行编程。它将您的对话与远程代码进行中介，并在某些问题无法按预期进行时锚定有关应归咎于谁的对话。</p><p> The formal semantics of a language does exactly the same thing. The languageitself is the “remote code” you’re programming against. What it does shouldbe pinned down as precisely as possible— but also as understandably aspossible!— for you to work with.</p><p> 语言的形式语义做的完全相同。语言本身就是您要编程的“远程代码”。您应该尽可能精确地确定它所做的工作，但也应尽可能理解它！</p><p> The semantics isn’t just an interface for the user of a language. It’s also acrucial interface for tool authors, who must (also) otherwise guess at thebehavior of the language. If you want an example of how even the relativelysimple act of a variable rename refactoring can go wrong, see Appendix 2 ofour  Python semantics. A semanticsdoesn’t guarantee those kinds of errors won’t occur, but its absence makes themfar more likely to.</p><p> 语义不仅仅是语言用户的界面。它也是工具作者的重要界面，他们必须（也）必须猜测语言的行为。如果想要一个示例，说明即使变量重命名重构的相对简单的操作也可能出错，请参阅Python语义的附录2。语义并不能保证不会发生这类错误，但是缺少它会使它们更可能发生。</p><p> For many researchers, it’s a given that programming languages are mathematical objects. This is a natural and attractive view. Languagesare formal objects, after all; they are therefore amenable to codification byeverything from logic to topology and more. (Formal) Specification is a naturalconsequence of this worldview.</p><p> 对于许多研究人员来说，编程语言是数学对象。这是自然而迷人的观点。毕竟，语言是形式对象。因此，它们适用于从逻辑到拓扑等所有方面的编纂。 （正式）规范是这种世界观的自然结果。</p><p> The world, however, is full of programming languages that do not fit thismodel.   Some may even have been created by programming languagesemanticists, which is worth pondering. Created by the ostensibly unwashed,they rudely announce their arrival with nothing more than animplementation. People pick them up, find them useful, do worthwhile thingswith them, and a million lines later, the next big “scripting language” isborn. Let’s call these  informal languages.</p><p> 但是，世界上充满了不适合该模型的编程语言。有些甚至是由编程语言学家创建的，这值得深思。由表面上未洗的东西创建，他们毫不客气地宣布它们的到来只是实现。人们拾起它们，发现它们有用，与他们一起做有价值的事情，一百万行之后，下一个主要的“脚本语言”诞生了。我们称之为非正式语言。</p><p> Informal languages are, of course, also amenable to formal specification. However,a crucial difference governs these two types of languages. Suppose we observe adifference between what the specification says and what the implementationdoes. In the case of Standard ML, for instance, one can approach theimplementor, walk through the reasoning in the specification, and explain whythe implementation is wrong. If the implementor agrees with your reasoning, nomatter how unhappy this makes them, they must admit to and eventually fix theirimplementation.</p><p> 非正式语言当然也符合正式规范。但是，这两种类型的语言存在重大差异。假设我们观察到规范说明与实现之间存在差异。例如，在使用标准ML的情况下，可以接近实现者，逐步了解规范中的推理，并解释实现错误的原因。如果实施者同意您的推理，即弄不清这使他们感到不满意，他们必须承认并最终确定其实现。 </p><p> The implementor of an informal language faces no such constraint. Faced with amismatch between an ostensible specification and their implementation, they arefree to simply laugh, question the specification’s parentage, and exit stageright. The specification can  at best track what “the language isdoing”, not really dictate its behavior.</p><p>非正式语言的实现者没有这种限制。面对表面上的规范与其实现之间的不匹配，他们可以随意大笑，质疑规范的血统，并退出舞台。该规范最多只能跟踪“语言在做什么”，而不能真正决定其行为。</p><p> Serve all the other uses of a specification, such as serving as a basisfor building tools.</p><p> 服务于规范的所有其他用途，例如作为构建工具的基础。</p><p> To do all these things  usefully, however, the specification must takesignificant steps to show its conformance to the reality of the informallanguage, such as by running the same test suites as the implementations.</p><p> 为了有效地完成所有这些工作，该规范必须采取重要步骤以表明其符合非正式语言的实际情况，例如通过运行与实现相同的测试套件。</p><p>   We can push at it, poke it, and prod it, and hope that it will yield itssecrets. But we can never be certain— without the help of theimplementors— that we have properly characterized all of it.</p><p>   我们可以推，戳，刺它，并希望它会产生秘密。但是，在没有执行者的帮助下，我们永远不能确定我们已经对所有特征进行了适当的描述。</p><p> That doesn’t mean we can’t approach the problem systematically. Geologists,confronted with a rock, don’t flail helplessly. In high-school chemistry, I wastaught to approach unknown substances with the   test: check for itsstate, color, odor, density, and solubility.   They never included a letterfor “taste”, a reflection perhaps more of their aspiration than of thereality in a high school chemistry lab. That is, we identify some ofdimensions of classification, and proceed along the principal axes.</p><p> 这并不意味着我们无法系统地解决问题。面对岩石的地质学家不会无助地扑朔迷离。在高中化学领域，我被教导要通过测试来接近未知物质：检查其状态，颜色，气味，密度和溶解度。他们从来没有写过“品味”这封信，反映出他们的愿望比在高中化学实验室中的真实感更重要。也就是说，我们确定了一些分类维度，并沿着主轴进行。</p><p> We have these axes for programming languages, too. We can talk about theirscope rules, their evaluation semantics, their type system, and so on. Indeed,because so much of a programmer’s career will be spent confronting informallanguages and having to rapidly make sense out of them, I’ve long felt that howwe  teach programming languages should also be divided along thesedimensions.</p><p> 我们也有用于编程语言的这些轴。我们可以讨论他们的范围规则，他们的评估语义，他们的类型系统等等。的确，由于程序员的职业生涯中有很多时间都花在对抗非正式语言上，并且不得不从它们中迅速理解，所以我长期以来一直认为，我们如何教授编程语言也应按照这些维度来划分。</p><p> The problem of informal languages will not go away, so long as a dedicatedamateur can scare up a new language’s implementation. Indeed, the size of ourinformal language space grows ever-bigger, and vastly so, than that ofmathematical languages. In 2015, I made this slide:</p><p> 只要敬业的业余爱好者可以吓a一种新语言的实施，非正式语言的问题就不会消失。的确，我们的非正式语言空间的规模比数学语言要大得多。在2015年，我制作了这张幻灯片： </p><p>  It shows the stack atop which a typical client-side Web program of the dayresided. What it actually shows is something much more subtle and important:</p><p>它显示了一个堆栈，上面是典型的当今客户端Web程序所在的堆栈。它实际显示的是更加微妙和重要的东西：</p><p>  Rather, they program in some complex combination of languages, libraries,frameworks (which can impose their own operational behavior— e.g., seeminglyturn a call-by-value language into a reactive one), and more. What a programmerneeds is a semantics not just for the language sitting near the bottom, butrather for the mountain on top of which their program resides.</p><p>  而是，它们以语言，库，框架（可以强加自己的操作行为，例如，似乎将按值调用语言转换为响应式语言）等某种复杂的组合进行编程。程序员需要的不仅是语义的语义，而且还在于他们程序所在的山峰的语义。</p><p> For illustrative examples of what such semantics might look like, see our workon the  operational semantics ofthe   (it’s a giant control operator, y’all!), and the type structure of jQuery. Butthese are just a tiny sliver of a tiny sliver. How do we make real progress upthe mountain and keep our position there as it keeps thrusting further out ofthe ground?</p><p> 有关此类语义可能是什么样的说明性示例，请参见我们关于（它是一个巨大的控件运算符）的操作语义以及jQuery的类型结构的文章。但是这些只是细小条子中的细小条子。我们如何在山上取得真正的进步，并在山上不断前进时保持自己的位置？</p><p> We can’t expect the date-picker library’s author to also be a semanticist. Butwe shouldn’t therefore resignedly conclude that we can never get there. Rather,we should acknowledge that there are useful divisions of labor. Instead ofscolding informal language designers for their practices, semanticists need tofind methods to bridge that gap, keeping in mind:</p><p> 我们不能指望日期选择器库的作者也是语义学家。但是，我们不应该因此而得出这样的结论：我们永远无法到达那里。相反，我们应该承认存在有用的分工。语义学家不必寻找非正式语言设计师的实践方法，而需要找到一种弥合这种差距的方法，请牢记：</p><p> One can’t proceed from the informal to the formal by formal means.Alan Perlis</p><p> 不能通过正式手段从非正式到正式。AlanPerlis</p><p> One especially good intermediate proxy is a test suite of some sort. Testsdon’t always get the respect they deserve, but they too are a form ofspecification. I like to call them “specifications from below”, preciselydefining what should happen in individual cases, whereas the typical formalspecification is “specification from above”, defining what happens across afamily of cases. Ultimately, of course, we need specifications “from above”,but it’s worth noting that specifications “from below” are both useful todevelopers and something they are skilled at producing. The recent trend inlanguages of producing “confirmance suites” or “litmus tests” is especiallypromising in this regard. (Our work on formalizing the strict mode of of ECMAScript 5.1,for instance, made use of the ECMAScript conformance suite.)</p><p> 一个特别好的中间代理是某种测试套件。测试并不一定总是得到应有的尊重，但它们也是一种形式。我喜欢称它们为“自下而上的规范”，精确地定义了个别情况下应该发生的情况，而典型的形式化规范是“自上而下的规范”，定义了整个案例家族中发生的事情。最终，当然，我们需要“从上方”的规范，但值得注意的是，“从下方”的规范既对开发人员有用，又对他们熟练地生产。在这方面，最近产生“确认套件”或“石蕊测试”的趋势语言尤其有希望。 （例如，我们在规范ECMAScript 5.1严格模式方面的工作使用了ECMAScript一致性套件。）</p><p> How we use them remains a little bit of an open question. The most obvious useis to test our semantics: what  Arjun Guha and I, to perhaps the horrorof some, called a  tested semantics. But we might also be able togeneralize these tests, from “below” to “above”, i.e., it’s a synthesisproblem. This requires some structure to produce a semantics that is alsomeaningful. Our paper on  The Next 700Semantics describes some of the contours for this line of work to consider.</p><p> 我们如何使用它们仍然是一个悬而未决的问题。最明显的用途是测试我们的语义：Arjun Guha和我（也许有些恐惧）称为测试语义。但是我们也许还可以概括这些测试，从“下面”到“上面”，即这是一个综合问题。这就需要某种结构来产生有意义的语义。我们关于“下一个700语义学”的论文描述了要考虑的这一工作线的一些轮廓。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://parentheticallyspeaking.org/articles/pls-nature/">https://parentheticallyspeaking.org/articles/pls-nature/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编程语言/">#编程语言</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/languages/">#languages</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>