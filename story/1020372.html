<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>动手WebAssembly：尝试基础知识</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">动手WebAssembly：尝试基础知识</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-08-26 14:04:01</div><div class="story_img_container"><a href="http://img.diglog.com/img/2020/8/3854a6e6be498977acc7634e16462191.png"><img src="http://img.diglog.com/img/2020/8/3854a6e6be498977acc7634e16462191.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>通过我们简单的实践教程开始学习WebAssembly，该教程假定您只具备Web开发方面的一般知识。要通过可运行的代码示例领略Wasm的滋味，您只需要使用以下工具：代码编辑器、任何现代浏览器，以及本文附带的带有C和Rust工具链的Docker容器。</p><p>WebAssembly已经存在三年了。它适用于所有现代浏览器，甚至一些公司有足够的勇气在实际生产中使用它(脱帽，菲格玛)。它背后有严肃的智力：Mozilla，微软，谷歌，苹果，英特尔，红帽-这些公司最好的工程师中的一些人，以及其他人，不断为WebAssembly做出贡献。它被普遍认为是互联网技术的下一个大事件，但更广泛的前端社区并不急于采用它。我们都知道HTML、CSS和JavaScript是互联网站稳脚跟的三大大象，而且需要三年多的时间才能真正改变一个人的世界观。特别是当你在谷歌上快速搜索一下就会得到这样的结果时：</p><p>WebAssembly是一种先进的虚拟指令集体系结构，并为基于堆栈的虚拟机提供了一种先进的二进制指令格式。</p><p>如果你不能立即与上面的声明产生共鸣-放弃也太容易了。</p><p>发布这篇文章的目的是用一种更容易理解的方式来解释WebAssembly，并向你介绍在一个新的网页上使用它的具体例子。如果你是一名软件开发人员，对WebAssembly一直很好奇，而且从来没有机会尝试一下-这篇文章很适合你。特别是如果你喜欢龙的话。</p><p>在我自己潜入这个主题之前，我对WebAssembly的最好的心理模型是第一条巨龙：一种强大、快速、危险的有吸引力的东西，但也是神秘的，可能是致命的。而在我心目中的网络技术地图上，WebAssembly也落入了“这里是龙”的类别：去探索，风险自负。</p><p>事实证明，这些担忧可能是没有根据的。前端发展的主要比喻仍然存在。WebAssembly仍然属于开发客户端应用程序的应用领域，所以它仍然运行在您的浏览器所在的应用程序沙箱中。它仍然依赖于我们熟悉的JavaScript API。它还通过允许您直接为二进制文件提供服务，极大地扩展了在客户端可以执行哪些操作的限制。</p><p>请收看WebAssembly，看看它是如何工作的，您如何编译代码来创建Wasm，以及何时在您的项目中使用WebAssembly是有意义的。</p><p>在WebAssembly投入使用之前，JavaScript作为唯一由浏览器执行的全功能编程语言享有垄断地位。为互联网编写代码的人知道如何在JS中更好地表达自己，并信任其他客户端机器能够正确运行他们的代码。</p><p>任何几乎没有编程经验的人都会理解以下几行代码的真正含义。即使这个代码“解决”的任务是相当没有意义的：把一个随机数除以2，然后把它加到后面的数组11,088次。</p><p>函数div(){返回数学。Random()/2；}const arr=[]；for(设i=0；i&lt；11088；i++){arr[i]=div()；}。</p><p>这段代码对人类来说是完全可读的，但对于通过互联网收到这段代码的客户端机器的主CPU来说，它没有任何意义，现在必须重新运行它。CPU理解机器指令，这些指令编码了处理器必须采取的复杂(相当乏味)的步骤序列，才能产生更好的结果。</p><p>要运行我们的小代码片段，我的CPU(Intel x86-64)需要516条指令。以下是这些指令在汇编语言中显示时的外观，汇编语言是机器代码的简单文本表示。这些指令名称很隐晦，要想弄清楚它们的意思，你需要一本厚厚的手册，它附带了一个高级处理器。</p><p>在每个时钟周期(2 GHz意味着每秒20亿个周期)上，处理器将尝试提取一条或多条指令并执行它们。通常，同时携带多条指令(也称为指令级并行)。</p><p>为了尽可能快地运行代码，处理器使用流水线、分支预测、推测执行、预取等技巧。处理器有一个非常复杂的高速缓存系统，可以尽可能快地获取所有指令(以及指令本身)的原始数据。从主存中获取数据的速度比从缓存中获取数据的速度慢几十倍。</p><p>不同的CPU实施不同的指令集架构(ISA)，因此您PC中的第一个CPU(很可能基于Intel x86)不会理解您智能手机中第一个CPU(很可能是ARM架构之一)中的第一个CPU的机器代码。</p><p>好消息是-如果你为互联网编写代码，你就不必在意处理器架构之间的巨大差异。现代浏览器是高效的编译器，它会很高兴地将您的代码转换为客户端机器的主CPU可以理解的东西。</p><p>要理解WebAssembly是如何发挥作用的，我们必须稍微讨论一下编译器。高级编译器的工作就是将人类可读的源代码(JavaScript、C、Rust，诸如此类)转换成一套完整的指令，让目标处理器无法理解。在发出源代码之前，高级编译器将首先将您的代码翻译成高级中间表示(IR)-这是对您的程序进行准确的“重写”，而不依赖于源代码和目标语言。</p><p>编译器将查看新的IR，并查看如何对其进行进一步优化，可能会生成另一个IR，然后再生成另一个-直到它确定不能再进行进一步的优化。因此，您在编辑器中编写的代码可能与普通计算机执行的代码非常不同。</p><p>为了向你展示它的意思，这里有一个很小的C代码片段，它可以将数字进行加法和乘法运算。</p><p>#include&lt；stdio.h&gt；int main(){int result=0；for(int i=0；i&lt；100；++i){if(i&gt；10){result+=i*2；}Else{result+=i*11；}}printf(&#34；%d\n&#34；，result)；返回0；}。</p><p>下面是它的内部表示，它使用最广泛使用的LLVM IR格式，由一个高级编译器生成。</p><p>定义隐藏的I32@Main()LOCAL_UNNAME_ADDR#0{条目：%0=尾部调用I32(I8*，...)@iprintf(…。)，I32 10395)ret I32 0}。</p><p>LLVM是一个编译器基础设施项目的别名，这个项目过去常常是“低级虚拟机”的缩写，但从那时起，它变得如此之多。</p><p>这里的要点是，在执行优化时，编译器得到的是最新的计算结果-而不是让处理器在最新的运行时进行最新的数学计算。因此出现了I32 10395部分，这恰恰是上面的C代码最终输出的数字。</p><p>编译器有一整袋的魔术：尽量避免在运行时执行“低效”的人工代码，并用更加优化的机器版本替换它。</p><p>大多数现代编译器也有一个强大的“中间端”，在后端和前端之间执行优化。</p><p>编译器流水线是一头非常复杂的野兽，但我们可以将其分为两个截然不同的部分：前端和后端。编译器前端对目标代码进行解析、解析，并将其转换成目标IR，然后编译器后端针对目标优化目标IR，生成目标代码。</p><p>然后我们可以将其作为程序编译的主要目标，而不必担心与其他客户端的系统之间的兼容性。我们现在还可以用任何语言编写程序；我们不再专门与JavaScript结婚。然后，客户端浏览器将获取我们的代码的中间表示，并执行其后端魔术：将IR转换为用于客户端体系结构的机器指令。</p><p>为了实现一个梦想，即提供一种简单的单一格式来交换用任何语言编写的代码，WebAssembly的开发人员不得不做出一些战略性的架构选择。</p><p>对于浏览器来说，要想在尽可能短的时间内读取源代码，其格式需要非常紧凑。二进制可能是你能得到的最紧凑的。</p><p>为了更高效地编译，我们需要尽可能接近机器指令的东西，而不牺牲可移植性。由于所有的指令集架构都依赖于硬件，而且不可能为所有浏览器可以运行的系统量身定做，WebAssembly的主要创建者选择了真正的虚拟ISA：一套简单的抽象机指令集。它不对应于任何现实世界的CPU，但可以在软件中高效地进行处理。</p><p>虚拟ISA的级别非常低，很容易翻译成特定的机器指令。与现实世界的CPU不同，WebAssembly的高级抽象机不依赖于寄存器-现代处理器在对其进行操作之前将数据放在这些寄存器上的位置。取而代之的是，它使用了堆栈数据结构：例如，一条加法指令将从堆栈中弹出两个最上面的数字，将它们相加，然后将结果推回到堆栈的顶部。</p><p>现在，随着我们终于明白了什么叫“虚拟指令集架构”，以及“基于堆栈的虚拟机的二进制格式”意味着什么，是时候释放WebAssembly的强大威力了！</p><p>现在是我们从实践中学习的时候了。我们要实现一个非常简单的算法，用来画一条非常简单的分形曲线，叫做龙形曲线。上面的源代码并不是这里最重要的部分：我们将向您展示如何创建一个完整的WebAssembly模块，并在浏览器中运行它。</p><p>我们不会直接投入到像Emscripten这样可以让我们的生活变得更容易的高级工具中，而是从直接使用具有LLVM WebAssembly后端的Clang编译器开始。</p><p>我们将在画布上从一个新的起点画一条分数线，然后执行左转和右转的顺序，最终达到理想的分形形状。</p><p>我们计划的目标是为我们的线路生成一系列可供我们遵循的地理坐标。这将是美国JavaScript的工作，也就是把这一切变成一幅新的图景。执行第二代的代码也是用很好的旧C编写的。</p><p>不要担心，您不需要花费数小时来设置软件开发环境，因为我们已经将您可能需要的所有软件工具都烘焙到了Docker映像中。在你的电脑上，你唯一需要的就是Docker本身，所以如果你以前没有用过它-现在是重新安装它的时候了，只需按照你喜欢的操作系统的以下步骤操作即可。</p><p>一句话警告：命令行示例假设您使用的是Linux或Mac。要使其在Windows上正常工作，您可以使用WSL(我们建议升级到WSL2)，也可以将其语法更改为“支持Power Shell：使用反号而不是换行符”和“${pwd}：/temp”而不是“$(Pwd)：$(Pwd)”。</p><p>现在打开您最喜欢的文本编辑器，将以下代码放入新创建的文件中：</p><p>//drag-curve-llvm/gon-curve.c#ifndef Dragon_curve#定义Dragon_curve//用于从&#34；TURES&#34；INT SIGN(INT X){RETURN(x%2)*(2-(x%4))；}//用于生成&#34；TURES&#34；//改编自https://en.wikipedia.org/wiki/Dragon_curve#[Un]folding_the_dragon int getTurn(Int N){int turFlag=(n+1)&amp；-(n+1))&lt；&lt；1)&amp；(n+1)；return turFlag！=0？-1：1；//-1表示左转，1表示右转}//用x和y点填充源代码[x0，y0，x1，y1，...]//第一个参数是指向将在运行时提供的数组第一个元素的指针。Void dragonCurve(Double source[]，int size，int len，Double x0，Double Y0){int angle=0；Double x=x0，y=y0；for(int i=0；i&lt；size；i++){int Turn=getTurn(I)；angle=angle+Turn(I)；angle=x-len*sign(Angle)；y=y-len*sign(angle+1)；source[2*i]=x；Source[2*i+1]=y；}}#endif。</p><p>现在我们需要使用LLVM的Clang将其编译成WebAssembly，并使用它的WebAssembly后端和链接器。运行此命令可以让我们的Docker容器执行后续工作。这只是一个简单的调用，可以使用一组新的标志来执行clang二进制。</p><p>Docker run--rm-v$(Pwd)：$(Pwd)-w$(Pwd)zloymult/wasm-build-kit\clang--target=wasm32-O3-nostdlib-wl，--no-entry-wl，--export-all-o gon-curve.wasm draoncurve.c。</p><p>-nostdlib告诉我们不要使用系统库，因为它们在开发浏览器的环境中是毫无用处的。</p><p>-wl、--no-entry-wl、--export-都是告诉链接器重新导出我们从WebAssembly模块定义的所有C函数的标志，并且不会忽略不存在的main()。</p><p>因此，您将看到一个完整的gon-curve.wasm文件出现在您的文件夹中。不出所料，它是一个包含我们程序全部1530字节的二进制文件！您可以这样检查它：</p><p>我们可以使用一个名为Bynarien的非常棒的工具来减少我们的二进制文件的大小，该工具也是我们WebAssembly工具链的一部分。</p><p>这使得我们可以从最终得到的文件中削减大约100个字节。</p><p>二进制文件令人沮丧的一点是，人类无法阅读它们。幸运的是，WebAssembly有两种格式：二进制和纯文本。因此，您可以使用WebAssembly二进制工具包在这两者之间进行翻译。尝试运行：</p><p>这些有趣的括号被称为s表达式(就像在很好的旧Lisp中一样)。它们被用来表示树状结构。所以我们的WASM文件是一棵树。这棵树的根是一个模块。它的工作原理与您所知道的JavaScript模块非常相似。它有进口和出口。</p><p>您可能会看到散布在代码周围的if、Else和Else循环语句，以及WebAssembly最引人注目的功能之一：通过使用所谓的结构化控制流，就像其他高级语言一样，它避免了Goto跳转，并且允许在一次通过中快速解析源代码。</p><p>现在，让我们一起来看看我们输出的功能标志，看看基于堆栈的虚拟ISA是如何工作的。</p><p>还有另一个重要的实体叫Table。表是线性数组，与内存一样，但它们只存储函数引用。它们用于间接调用函数，无论它们是否属于WebAssembly模块的一部分。</p><p>我们的函数接受一个整数参数(参数I32)，然后返回一个整数结果(结果I32)。所有的事情都是在新的堆栈上完成的。首先，我们推送值：整数2，然后是第二个函数的第一个参数(local.get 0)，然后是整数4。然后，我们应用从第二个堆栈中删除两个值(第一个函数参数和第二个整数4)的i32.rem_s指令，将第一个值除以第二个值，然后将第二个余数推回到第一个堆栈中。现在，最上面的值是第二个余数，第二个数字是2.i32.sub，从第一个堆栈中弹出它们，从另一个堆栈中减去一个，然后推送第二个结果。前五条指令相当于1(2-(x%4))。</p><p>WASM使用非常简单的线性内存模型：您可以将WebAssembly内存视为非常简单的字节数组。</p><p>在我们的.wat文件中，使用(EXPORT MEMORY(MEMORY 0))从输出模块导出。这意味着我们可以从外部对我们的WebAssembly程序的基本记忆进行操作，这也是我们下面要做的事情。</p><p>让我们放入一些带有一个空画布标签的样板，并重新初始化我们的初始值：Size是我们曲线的第一个步长，len是每一步的第二个长度，而Y0的X0设置了第一个起始坐标。</p><p>&lt；！--drag-curve-llvm/index.html--&gt；&lt；！DOCTYPE html&gt；&lt；html&gt；&lt；head&gt；&lt；title&gt；Dragon Curve from WebAssembly&lt；/title&gt；&lt；/head&gt；&lt；body&gt；&lt；canvas id=&#34；canvas&#34；&lt；script&gt；const size=2000；const len=10；const X0=500；const Y0=500；&lt；/script&gt；&lt；/body&gt；&lt；/html&gt；</p><p>现在我们需要重新加载我们的.wasm文件，并实例化一个新的WebAssembly模块。与JavaScript不同的是，我们不需要等待整个模块加载后才能使用它-WebAssembly是动态编译和执行的，因为它的字节源源不断地涌入。</p><p>我们使用标准的FETCH API来重新加载我们的模块，并使用我们内置的WebAssembly JavaScript API来重新实例化它。WebAssembly.instantiateStreaming返回一个新的承诺，该承诺使用一个新的模块对象进行解析，该对象包含我们的模块的一个新实例。我们的C函数现在可以作为实例的导出使用，因此我们可以随心所欲地从JavaScript中使用它们。</p><p>&lt；！--drag-curve-llvm/index.html--&gt；&lt；！DOCTYPE html&gt；&lt；html&gt；&lt；head&gt；&lt；title&gt；Dragon Curve from WebAssembly&lt；/title&gt；&lt；/head&gt；&lt；body&gt；&lt；canvas id=&#34；canvas&#34；&lt；script&gt；const size=2000；const len=10；const X0=500；const Y0=500；WebAssembly。InstantiateStreaming(FETCH(&#34；/gon-curve.wasm&#34；)，{//对于本例，我们不导入任何导入：{}，})。则((Obj)=&gt；{const{memory，__heap_base，dragonCurve}=obj.。实例。导出；dragonCurve(__HEAP_BASE，SIZE，LEN，X0，Y0)；常量坐标=new Float64Array(内存。缓冲区，__HEAP_BASE，大小)；常量画布=文档。QuerySelector(&#34；canvas&#34；)；const ctx=canvas。GetContext(&#34；2d&#34；)；ctx。EginPath()；ctx。Moveto(X0，Y0)；[...。Array(Size)]。For Each((_，i)=&gt；{CTX.。LineTo(坐标[2*i]，坐标[2*i+1])；})；CTX。笔划()；//如果要设置曲线动画，请将最后四行更改为//[...Array(Size)].forEach((_，i)=&gt；{//setTimeout(()=&gt；{//requestAnimationFrame(()=&gt；{//ctx.lineTo(坐标[2*i]，坐标[2*i+1])；//ctx.strok()；//})。})；&lt；/script&gt；&lt；/body&gt；&lt；/html&gt；</p><p>现在让我们更仔细地看看我们的例子。出口。除了生成我们的坐标的dragonCurve C函数之外，我们还获得了一个内存对象，该对象表示我们的WebAssembly模块的线性内存。我们需要对它格外小心，因为它可能包含重要的东西，比如我们为新的虚拟机提供的堆栈指令。</p><p>从技术上讲，我们需要一个新的内存分配器，以避免把事情搞得一团糟。尽管如此，对于这个简单的示例，我们将不读取内部的__heap_base属性，该属性为我们提供了一个安全内存区域的偏移量，该区域对于我们的使用(堆)来说是非常安全的。</p><p>我们将参数偏移量放入函数“Good”内存中，以调用我们的dragonCurve函数，并调用该函数，然后将填充有坐标的函数堆的参数内容提取出来，作为一个函数Float64Array。</p><p>本章的灵感来自于苏尔玛那篇令人惊叹的“Compiling C to the WebAssembly Without Emscripten”文章。</p><p>其余的只是根据从我们的Wasm模块提取的坐标在画布上画一条直线。现在，我们要做的就是在本地为我们的HTML提供更好的服务。我们需要一个基本的Web服务器；否则，我们将无法从客户端直接获取Wasm模块。幸运的是，我们的Docker映像已经做好了一切准备：</p><p>上面的“纯LLVM”方法故意过于简约；我们编译程序时没有系统库。我们还使用最残暴的方法来管理内存：通过计算内存偏移量来访问内存堆。这使我们能够更好地揭开WebAssembly的记忆模型的神秘面纱。在现实世界的应用中，我们想要正确分配内存，使用系统库，而系统库在我们的浏览器中：WebAssembly仍然在我们的沙箱中运行，并且没有直接访问您的操作系统的权限。</p><p>Emscripten先于WebAssembly：首先，它用于将C/C++代码编译成JavaScript和JASM.js。而且它现在仍然可以！</p><p>所有这一切都可以在Emscripten的帮助下完成：这是一个用于编译WebAssembly的高级工具链，负责在Web浏览器中模拟许多系统的功能：使用STDIN、STDOUT和文件系统，甚至是自动转换为WebGL的OpenGL图形。它还集成了我们用来瘦身的Bynarien，所以我们不必再担心额外的优化。</p><p>是时候做好WebAssembly了！我们的C代码将保持不变。让我们创建一个单独的文件夹，这样您可以稍后比较代码，并复制我们的源代码。</p><p>我们为您解决了将包装ecmsrim转换为Docker映像的最大麻烦，因此您无需在系统上安装任何东西即可直接运行以下命令：</p><p>Docker run--rm-v$(Pwd)：$(Pwd)-w$(Pwd)zloymult/wasm-build-kit\emcc gon-curve.c-os-o。</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://evilmartians.com/chronicles/hands-on-webassembly-try-the-basics">https://evilmartians.com/chronicles/hands-on-webassembly-try-the-basics</a></div><div class="story_tags page_narrow"></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>