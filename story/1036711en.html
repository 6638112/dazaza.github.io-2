<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>存在的HaskellExistential Haskell</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Existential Haskell<br/>存在的Haskell</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-26 22:06:43</div><div class="page_narrow text-break page_content"><p>The majority of software engineering literature portrays object-oriented programming as distinct from, and often irreconcilable with, functional programming. This is, of course, a false dichotomy, as the techniques encouraged by functional programming are applicable in even the most object-oriented languages. Yet object-orientation, being perhaps history’s most popular software paradigm, has popularized its tenets, and occasionally we can see them show up even in programming languages like Haskell, a language about as antithetical to the object-oriented philosophy as possible.</p><p>大多数软件工程文献将面向对象的编程描绘为与功能编程不同，并且常常与功能编程不相容。当然，这是错误的二分法，因为函数式编程所鼓励的技术甚至适用于大多数面向对象的语言。然而，面向对象（可能是历史上最受欢迎的软件范例）已经普及了其宗旨，有时甚至可以看到它们出现在像Haskell这样的编程语言中，该语言与面向对象的哲学尽可能地对立。</p><p> In this piece, I’ll describe a common example of  information hiding in ALGOL-style languages like Java, then express that in terms compatible with Haskell. We’ll then use this technique to port a  responder chain to Haskell, demonstrating how Haskell supports dynamic function dispatch in the presence of hidden type information. I write this not because I expect to break any new ground—all the techniques I use here are long-documented in the literature, and Haskell veterans will probably find little new in this post    Those familiar with the care and feeding of existential types may wish to skip to the penultimate section, which contains a couple useful data types that I haven’t yet seen in the wild.  —but because the existing resources are scattered, perhaps oddly so given how central dynamic dispatch is to most programming languages that aren’t Haskell, and because exploring the edge cases in the design illustrates the compromises inherent in language and library design.</p><p> 在本篇文章中，我将描述一个使用Java等ALGOL风格语言隐藏信息的常见示例，然后以与Haskell兼容的术语来表达这一信息。然后，我们将使用此技术将响应程序链移植到Haskell，以说明Haskell如何在存在隐藏类型信息的情况下支持动态函数分派。我写这篇文章并不是因为我希望突破任何新领域-我在这里使用的所有技术在文献中都有很长的文献记载，并且Haskell退伍军人在这篇文章中可能会发现很少的新知识。跳到倒数第二部分，其中包含一些我还没有见过的有用的数据类型。 —但是由于现有资源分散，考虑到对大多数非Haskell编程语言的中央动态分配的影响，这也许很奇怪，并且由于探索设计中的极端情况说明了语言和库设计固有的折衷。</p><p>  Most of the world’s statically-typed programming languages allow their users to write code resembling the following Java:</p><p>  世界上大多数静态类型的编程语言都允许其用户编写类似于以下Java的代码：</p><p>  Syntactically, this code is uncontroversial: it’s a function that returns a value. Its only interesting aspect lies in the function signature−even though the function body returns a value of type  String, its return type is declared to be   Comparable, which is not a concrete data type, but a Java  interface. As such, we cannot treat the result of this function call as the  String it actually is; we can only interact with it via the methods defined on the  Comparable interface. This application of the  rule of least power is a useful one, even in a strongly-typed language like Haskell: sometimes we want to hide the implementation details of a function’s return type.</p><p>  从语法上讲，这段代码没有争议：它是一个返回值的函数。它唯一有趣的方面是函数签名-即使函数主体返回String类型的值，其返回类型也声明为Comparable，这不是具体的数据类型，而是Java接口。因此，我们不能将此函数调用的结果视为实际的String；我们只能通过Comparable接口上定义的方法与其进行交互。即使在像Haskell这样的强类型语言中，这种最小功耗规则的应用也是一种有用的方法：有时我们想隐藏函数返回类型的实现细节。</p><p>    &lt;interactive&gt;:3:27: error: • Couldn&#39;t match expected type ‘a’ with actual type ‘[Char]’ ‘a’ is a rigid type variable bound by the type signature for: someComparableValue :: forall a. Ord a =&gt; Int -&gt; a</p><p>    ：3：27：错误：•无法将预期类型'a'与实际类型'[Char]'相匹配'a'是一个刚性类型变量，受以下类型签名的约束：someComparableValue :: forall a。 Ord a => Int-> a</p><p> Haskell’s typechecker looks at the body of this function and says “hey, man, you’re returning a concrete string value here, not ’any type that is  Ord–erable.’” Though this is a valid notion in Java, it’s not valid in Haskell. Another perspective on this is that Java allows a value to have more than one type: we can treat a Java string literal as a value of type  java.lang.String, or of type    even though  Comparable is an interface, not a concrete type    Comparable, or of its superclass  java.lang.Object. However, since Haskell doesn’t support inheritance, Haskell treats its values as having one, and only one, type. Working around this takes a judicious application of an existential type.</p><p> Haskell的类型检查器查看此函数的主体并说：“嘿，伙计，您在这里返回一个具体的字符串值，而不是'任何可Ord的类型。'尽管这在Java中是一个有效的概念，但它不是有效的在Haskell。关于此的另一种观点是Java允许值具有多个类型：我们可以将Java字符串文字视为类型java.lang.String或类型的值，即使Comparable是接口，也不是具体类型Comparable ，或其超类java.lang.Object。但是，由于Haskell不支持继承，因此Haskell将其值视为只有一种类型。解决此问题需要明智地使用存在类型。</p><p>  In Haskell, an  existential data type is one that is defined in terms not of a concrete type, but in terms of a quantified type variable, introduced on the right-hand side of the data declaration. This is, as is the case for so many Haskell concepts, not a particularly helpful definition in the abstract. It’s easier to show than to tell, so let’s take a look at one of the canonical examples of an existential type: a  Showable type that wraps any type that implements the  Show interface.</p><p>  在Haskell中，存在性数据类型不是根据具体类型定义的，而是根据在数据声明的右侧引入的量化类型变量定义的。就像许多Haskell概念一样，这并不是抽象中特别有用的定义。显示起来比说起来容易，所以让我们看一个存在类型的规范示例之一：Showable类型，它包装了实现Show接口的任何类型。</p><p>  There are several interesting things about this data type. Firstly, it uses the  forall keyword to introduce the  a type variable: given that we’re dealing with  exist-ential types, it threw me for a loop that there wasn’t an  exists keyword.    Scala reserves a  forSome keyword for this purpose, which I think reads a little more accurately in terms of the intent of introducing this type variable: using the phrase “for all” is a bit inapposite given that the  Showable constructor is applied to single values at a time.   Considering the constructor of  Showable is perhaps more enlightening:</p><p>关于此数据类型，有一些有趣的事情。首先，它使用forall关键字引入一个type变量：鉴于我们正在处理存在潜在类型，因此让我陷入一个循环，即没有存在关键字。 Scala为此保留了一个forSome关键字，就引入此类型变量的目的而言，我认为它读得更准确：使用短语“ for all”有点不合适，因为Showable构造函数应用于一个时间。考虑Showable的构造函数可能会更具有启发性：</p><p>  We can read this as “ Showable is a constructor that takes, for all types  a such that  a implements  Show, an  a value, and returns a value of type  Showable, the internal  a value of which is no longer visible to the world once it’s been applied.”</p><p>  我们可以将其理解为“ Showable是一个构造函数，它对于实现了Show的所有类型a都采用一个值，并返回Showable类型的值，一旦其内部的值便不再对世界可见。已被应用。”</p><p> Secondly, we can’t use a  newtype to declare an existential. Attempting to write the following:</p><p> 其次，我们不能使用新类型来声明存在。尝试编写以下内容：</p><p>   • A newtype constructor cannot have a context in its type Showable :: forall a. Show a =&gt; a -&gt; Showable• In the definition of data constructor ‘Showable’ In the newtype declaration for ‘Showable’</p><p>   •newtype构造函数的类型Showable :: forall a不能具有上下文。显示=> a-> Showable•在数据构造函数“ Showable”的定义中在“ Showable”的新类型声明中</p><p> When we consider typeclasses as  dictionaries, this restriction makes more sense: in GHC Core, this  Show a constraint will be represented as a hypothetical  ShowDict data type containing implementations for the  show,  showsPrec, and  showList functions. In this light, we can see that  Showable takes  two parameters, not one: an  a value to wrap, as well as the  ShowDict dictionary associated with that value’s type. Newtypes exist to wrap single values, and here we’re wrapping both a datum and its associated  Show dictionary: as a result, here we need a  data declaration, even though the associated  Showable constructor takes only one value (in Haskell surface syntax). This is an understandable limitation, though it would be cool if existential values of this sort could opt into the  deriving mechanism in the manner of newtypes.</p><p> 当我们将类型类视为字典时，此限制更有意义：在GHC Core中，此Show约束将表示为假设的ShowDict数据类型，该数据类型包含show，showsPrec和showList函数的实现。因此，我们可以看到Showable接受两个参数，而不是一个：一个要包装的值，以及与该值的类型关联的ShowDict字典。存在新类型来包装单个值，并且这里我们同时包装了一个数据及其相关的Show字典：因此，即使相关的Showable构造函数仅接受一个值（在Haskell表面语法中），这里我们也需要一个数据声明。这是可以理解的限制，但是如果这种存在性值可以以新类型的方式加入派生机制中，那将很酷。</p><p> A third interesting thing: we can’t write a function that unwraps this data type. What might seem like an intuitive type for the function is rejected:</p><p> 第三个有趣的事情是：我们无法编写解包此数据类型的函数。看起来像函数的直观类型被拒绝了：</p><p> -- GHC will reject this.   unwrapShowable ::  Showable  -&gt; ( forall a  .  Show a  =&gt; a)  unwrapShowable ( Showable a)  = a</p><p> -GHC将拒绝这一点。 unwrapShowable :: Showable->（forall a。Show a => a）unwrapShowable（Showable a）= a</p><p> We can see this explained a little more closely if we use the record selector syntax.</p><p>如果我们使用记录选择器语法，我们可以更详细地了解这一点。</p><p> data  Showable  =  forall a  .  Show a  =&gt;  Showable {  getShowable :: a }</p><p> 数据可显示=全部a。显示=>可显示{getShowable :: a}</p><p> Attempting to use  getShowable as a function that extracts some arbitrary  Show–inhabiting type produces a well-explained error messages:</p><p> 尝试将getShowable用作提取某些任意Show-inhabiting类型的函数会产生一个很好的解释错误消息：</p><p> &lt;interactive&gt;:1:1: error: • Cannot use record selector ‘getShowable’ as a function due to escaped type variables Probable fix: use pattern-matching syntax instead • In the expression: getShowable</p><p> ：1：1：错误：•由于转义了类型变量而无法将记录选择器“ getShowable”用作函数可能的解决方法：改用模式匹配语法•在表达式中：getShowable</p><p> The mental model I use here is that applying a constructor of an existential type serves as a sort of  event horizon for type information. In other languages we can assemble heterogenous lists natively; in Haskell, by contrast, we have to opt into it explicitly: applying the  Showable constructor to a value swallows its type information. We can’t write a function, whether the hand-written  unwrapShowable or descending from our  getShowable record selector, that unwraps some arbitrary type out of an existential. All that is retained is the ability, given a proper  case statement to unwrap the value within the existential, to  Show the value contained therein: it cannot  escape its scope, as the error message above explains    We can, however, use the  getShowable record selector to update the wrapped value present in a  Showable.  .</p><p> 我在这里使用的思维模型是，应用存在类型的构造函数充当类型信息的事件范围。在其他语言中，我们可以本机地组装异构列表。相比之下，在Haskell中，我们必须明确选择加入它：将Showable构造函数应用于值会吞噬其类型信息。我们无法编写一个函数，无论是手写的unwrapShowable还是从我们的getShowable记录选择器派生的函数，都可以从一个存在的类型中解包出任意类型。保留的全部能力是，给定适当的case语句，可以解开存在对象中的值，以显示其中包含的值：如上面的错误消息所述，它无法逃脱其范围，但是，我们可以使用getShowable记录选择器更新显示值中的包装值。 。</p><p> We can, as I mentioned above, cross the event horizon with a  case statement, binding the  Show–conforming contents to a variable name:</p><p> 正如我上面提到的，我们可以使用case语句来跨越事件范围，将符合Show的内容绑定到变量名称：</p><p>  Inside the right-hand-side of this  case statement, we have a value  x in scope. A quick inquiry with type holes reveals the type we expect:</p><p>  在此case语句的右侧，我们在范围内有一个值x。快速查询类型孔可以发现我们期望的类型：</p><p> • Relevant bindings include x :: a (bound at &lt;interactive&gt;:28:15) Constraints include Show a (from &lt;interactive&gt;:28:11-15)</p><p>•相关绑定包括x :: a（绑定到：28：15）约束包括Show a（来自：28：11-15）</p><p> All we know about this value  x is that we can call  Show on it. Other than passing it to the basic combinators ( id and  const), that’s  all we can do with this value. Any bit of type information has been lost, replaced instead with  capabilities, via typeclasses. Again, when we consider typeclasses as dictionary parameters, we can visualize how this works on a core-calculus level: we discard type information, including only the relevant dictionaries provided by the context of the  forall.</p><p> 我们只知道这个值x就是我们可以调用Show。除了将其传递给基本的组合器（id和const）之外，我们只能使用此值。类型信息的任何一点都已丢失，而是通过类型类替换为功能。同样，当我们将类型类视为字典参数时，我们可以在核心演算级别上可视化它的工作方式：我们丢弃类型信息，仅包括forall上下文提供的相关字典。</p><p> A fourth and final interesting thing about this type is that you can write it, using the  GADTs GHC extension, without an explicit  forall keyword:</p><p> 关于此类型的第四个也是最后一个有趣的事情是，您可以使用GADTs GHC扩展来编写它，而无需使用显式的forall关键字：</p><p>  This stems from the fact that GADTs allow us to introduce per-constructor type variables and associated constraints, even if the type variable is not visible externally. Another thing to note is that data declarations containing existential values don’t have to be limited to a single value: they can hold concrete values, or values expressed with more  forall–introduced type variables.</p><p>  这是因为GADT允许我们引入每个构造函数的类型变量和相关的约束，即使类型变量在外部不可见。需要注意的另一件事是，包含存在性值的数据声明不必限于单个值：它们可以包含具体值，也可以使用由更多引入的类型变量表示的值。</p><p>  Being able to hide implementation details of a function’s return type is all well and good, but many users are going to need to convert (or attempt to convert) from an existential type back into a concrete type. Java provides this functionality with the  instanceof operator and its cast syntax:</p><p>  能够隐藏函数的返回类型的实现细节很好，但是许多用户将需要从存在类型转换回（或尝试转换）回具体类型。 Java通过instanceof运算符及其强制转换语法提供此功能：</p><p> Comparable c =  someFn();   if c  instanceof  String {    System. out. println( &#34;Got a string: &#34; + ( String)c);  }  else {    System. out. println( &#34;Casting to a String here would raise a ClassCastException&#34;);  }</p><p> 可比的c = someFn（）;如果c instanceof String {系统。出来。 println（“得到一个字符串：” +（String）c）; } else {系统。出来。 println（“在此处铸造为String会引发ClassCastException”）； }</p><p> This is a consequence of all Java objects descending from  java.lang.Object, and the ability of the  instanceof operator to query the type of an object at runtime. Though this style of programming isn’t hugely popular in Haskell, it’s not unheard of, and Haskell indeed supports it: this is where the   Typeable typeclass comes in. It’s most prominently at work in  base, under  Control.Exception:</p><p> 这是所有Java对象都源自java.lang.Object的结果，也是instanceof运算符在运行时查询对象类型的能力的结果。尽管这种编程风格在Haskell中并不是很流行，但是它并不是闻所未闻的，Haskell确实支持它：这是Typeable类型类的用处。在Control.Exception的基础上，它是最显着的基础。</p><p> class ( Typeable a,  Show e)  =&gt;  Exception e     data  SomeException  =  forall e  .  Exception e  =&gt;  SomeException e</p><p>class（可键入a，Show e）=>异常e data SomeException = forall e。异常e => SomeException e</p><p> This code begins with the declaration of a new typeclass,  Exception, that inherits from both  Typeable and  Show. The fact that the  Exception typeclass inherits from  Typeable means that we can use  cast, the fundamental  Typeable primitive, to do safe casting to concrete values, accounting for the possibility of failure.</p><p> 此代码以新的类型类Exception的声明开头，该类继承自Typeable和Show。 Exception类型类从Typeable继承而来的事实意味着，我们可以使用基本的Typeable基本类型cast来对具体值进行安全的转换，从而考虑了失败的可能性。</p><p> Let’s take an example, in the lowly (or perhaps mighty, depending on how you look at it)  IO monad, of using Haskell’s dynamically-typed exception hierarchy:</p><p> 让我们举个例子，在IO monad的最低级（或也许强大，取决于您的外观）上，使用Haskell的动态类型化异常层次结构：</p><p> cautiouslyPrint ::  Show a  =&gt;  IO a  -&gt;  IO ()  cautiouslyPrint go  = Control.Exception.catch (go  &gt;&gt;=  print) handler    where    handler ::  SomeException  -&gt;  IO ()   handler ( SomeException e)  =  case cast e  of    Just  DivideByZero  -&gt;  putStrLn  &#34;divide by zero&#34;    Nothing  -&gt;  putStrLn ( &#34;Some other exception: &#34;  &lt;&gt;  show e)</p><p> cautiouslyPrint ::显示a => IO a-> IO（）cautiouslyPrint go = Control.Exception.catch（go >> = print）处理程序，其中处理程序:: SomeException-> IO（）处理程序（SomeException e）= Just DivideByZero-> putStrLn“被零除”无-> putStrLn（“其他异常：” <> show e）</p><p> Here we use the  catch function to evaluate the provided  go argument, invoking  handler should a runtime exception be thrown. We’re only handling one possible error type:  DivideByZero, one of the constructors of  ArithException. However, we are doing so via a checked cast, courtesy of the  cast function, because we’re not recognizing  ArithException values directly:  handler will be invoked on  any exception, because  SomeException, to  catch, means “this catch statement should handle any and all exceptions thrown by its body.” Looking at the type of  cast can be illuminating:</p><p> 在这里，我们使用catch函数来评估提供的go参数，并在抛出运行时异常时调用处理程序。我们仅处理一种可能的错误类型：DivideByZero，ArithException的构造函数之一。但是，我们是通过检查是否经过强制转换而实现的，这取决于转换函数，因为我们无法直接识别ArithException值：处理程序将在任何异常上调用，因为SomeException要捕获，意味着“此catch语句应处理任何且它的身体抛出的所有异常。”看看演员的类型可以说明：</p><p>  cast, perhaps unsurprisingly, is defined to return  Just a value when the types  a and  b line up. This is done dynamically, at runtime, thanks to the Typeable class, which is a special typeclass indeed: it’s one of only two typeclasses that GHC  explicitly prohibits any user-specified instances. Try it; you’ll get your hand slapped:</p><p>  当类型a和b对齐时，强制类型转换（可能并不奇怪）被定义为仅返回一个值。这要归功于Typeable类，它是在运行时动态完成的，它确实是一个特殊的类型类：它是GHC明确禁止任何用户指定实例的仅有的两个类型类之一。尝试一下;您会被打耳光：</p><p> &lt;interactive&gt;:4:10: error: • Class ‘Typeable’ does not support user-specified instances • In the instance declaration for ‘Typeable Foo’</p><p> ：4：10：错误：•类'Typeable'不支持用户指定的实例•在'Typeable Foo'的实例声明中</p><p> GHC is right to prohibit this: because  Typeable is concerned with the internal representation of Haskell types in memory, it’s GHC’s responsibility to implement it for you. And indeed it does: all types implement  Typeable, for free. Note that  cast takes all type information into account, not just structure: in practice, this means that you can’t cast a  Nothing value of type  Maybe Int to a  Nothing value of type  Maybe Char, even though the standalone  Nothing identifier can be implicitly cast to a value of  Maybe Char, or  Maybe Int, or  Maybe String.</p><p>GHC禁止这样做是正确的：因为Typeable与内存中Haskell类型的内部表示有关，因此GHC有责任为您实现它。确实如此：所有类型都是免费实现Typeable的。请注意，强制转换要考虑所有类型信息，而不仅仅是结构：实际上，这意味着您不能将Maybe Int类型的Nothing值转换为Maybe Char类型的Nothing值，即使独立的Nothing标识符可以隐式地强制转换为Maybe Char，Maybe Int或String的值。</p><p>   handler ::  SomeException  -&gt;  IO ()  handler ( SomeException e)  =  case cast e  of    Just  DivideByZero  -&gt;  putStrLn  &#34;divide by zero&#34;    Nothing  -&gt;  putStrLn ( &#34;Some other exception: &#34;  &lt;&gt;  show e)</p><p>   handler :: SomeException-> IO（）handler（SomeException e）= Just DivideByZero的大小写转换e-> putStrLn“被零除”无-> putStrLn（“其他异常：” <> show e）</p><p> As I mentioned, we’re only handling one possible error case: though  handler will be invoked for all exception types, our  cast operation only handles  DivideByZero exceptions (of type  ArithException). We can add new  ArithException cases without difficulty:</p><p> 如前所述，我们仅处理一种可能的错误情况：尽管将为所有异常类型调用处理程序，但我们的转换操作仅处理DivideByZero异常（ArithException类型）。我们可以毫不费力地添加新的ArithException案例：</p><p> Just  DivideByZero  -&gt;  putStrLn  &#34;divide by zero&#34;   Just  Underflow  -&gt;  putStrLn  &#34;floating point shenanigans&#34;   Nothing  -&gt;  putStrLn ( &#34;Some other exception: &#34;  &lt;&gt;  show e)</p><p> Just DivideByZero-> putStrLn“被零除” Just Underflow-> putStrLn“浮点数”没什么-> putStrLn（“其他异常：“ <> show e）</p><p> However, the problem becomes thornier when we want to handle disjoint  Exception-conformant types. A naïve encoding of the problem will not work, as in the following    Note that this syntax  Just (e :: ArithException), in which we annotate a value with an indicated type without pattern matching on it, requires the  ScopedTypeVariables extension to be enabled.  ScopedTypeVariables should  always be enabled: it does the right and obvious thing.  , where we try to handle  ArithExceptions and  ArrayExceptions:</p><p> 但是，当我们要处理不相交的符合异常的类型时，问题将变得更加棘手。问题的简单编码将不起作用，如下面的注释所示，该Just（e :: ArithException）语法（其中我们注释了具有指定类型且没有模式匹配的值）要求启用ScopedTypeVariables扩展。 ScopedTypeVariables应该始终启用：它做对了并且很明显。 ，我们尝试处理ArithExceptions和ArrayExceptions：</p><p> Just ( arith ::  ArithException)  -&gt;  putStrLn ( &#34;arithmetic: &#34;  &lt;&gt;  show arith)   Just ( array ::  ArrayException)  -&gt;  putStrLn ( &#34;array: &#34;  &lt;&gt;  show array)</p><p> Just（arith :: ArithException）-> putStrLn（“ arithmetic：” <> show arith）Just（array :: ArrayException）-> putStrLn（“ array：” <> show array）</p><p> This will produce a compiler error, because all the values on the left-hand-sides of a  case statement’s branches must have the same type! A corrected version might read:</p><p> 这将导致编译器错误，因为case语句分支的左侧的所有值都必须具有相同的类型！更正的版本可能显示为：</p><p> handler ( SomeException e)  =  case cast e  of    Just ( arith ::  ArithException)  -&gt;  putStrLn ( &#34;arith: &#34;  &lt;&gt;  show arith)    Nothing  -&gt;  case cast e  of    Just ( array ::  ArrayException)  -&gt;  putStrLn ( &#34;array: &#34;  &lt;&gt;  show array)    Nothing  -&gt;  putStrLn ( &#34;Some other exception: &#34;  &lt;&gt;  show e)</p><p>handler（SomeException e）= Just（arith :: ArithException）-> putStrLn（“ arith：” <> show arith）的大小写转换e-Just（array :: ArrayException）-> putStrLn（“ ：“ <>显示数组）无-> putStrLn（”其他一些例外：“ <>显示e）</p><p> To work around the fact that the first  cast expression limits its result type to values of type  ArithException, we have to call  cast again: this time, the  Typeable value is pinned to  ArrayException, which lets us handle successful casts in the  Just clause and failure in the  Nothing clause.</p><p> 要解决第一个强制类型转换表达式将其结果类型限制为ArithException类型的值这一事实，我们必须再次调用强制类型转换：这一次，Typeable值固定到ArrayException，这使我们可以在Just子句中处理成功的强制类型转换和失败在Nothing子句中。</p><p> There is a grave issue with the above pattern: it’s clunky as hell with only two cases, and gets even clunkier as you add more possible types. A more modern approach is to use GHC’s  MultiwayIf, in a manner that can be surprising for newcomers.  if statements are usually concerned with boolean values, but this one won’t be: instead, we’re going to call  cast, using the  guard syntax to discriminate between cases. By guarding (with  |) on  Just values returned from  cast, we can have something akin to a polytypic  case statement:</p><p> 上面的模式存在一个严重的问题：只有两种情况，它就像笨拙的地狱一样，随着添加更多可能的类型而变得笨拙。一种更现代的方法是使用GHC的MultiwayIf，这对于新来者来说可能是令人惊讶的。 if语句通常与布尔值有关，但不会这样：相反，我们将使用保护语法区分大小写来调用强制类型转换。通过保护（使用|）从强制转换返回的Just值，我们可以得到类似于多型case语句的内容：</p><p> if    |  Just ( arith ::  ArithException)  &lt;- cast e  -&gt;  putStrLn ( &#34;arith: &#34;  &lt;&gt;  show arith)    |  Just ( array ::  ArrayException)  &lt;- cast e  -&gt;  putStrLn ( &#34;array: &#34;  &lt;&gt;  show array)    |  otherwise  -&gt;  putStrLn ( &#34;Something else: &#34;  &lt;&gt;  show e)</p><p> 如果| Just（arith :: ArithException） putStrLn（“ arith：” <> show arith）|只是（array :: ArrayException） putStrLn（“ array：” <>显示数组）|否则-> putStrLn（“其他：” <> show e）</p><p> This is arguably a bastardization of the spirit of  MultiWayIf, which is ostensibly about simplifying large systems of boolean equations. Here, the only  Bool value involved is  otherwise, defined by the Prelude to be  True. Because  True is always, well,  True, its position as the last branch will mean that it is always matched, unless matched by a previous case (that is, a successful  Just value). Yet the  otherwise is readable in context, the code’s intent is clear, and its one flaw—the repeated work associated with the multiple calls to  cast—can be remedied with a simple  let binding:</p><p> 可以说，这是MultiWayIf精神的混蛋，表面上是关于简化布尔方程组的大型系统。此处，否则涉及的唯一布尔值（由前奏定义为True）是其他情况。因为True永远都是True，所以它作为最后一个分支的位置将意味着它总是匹配的，除非与先前的情况（即成功的Just值）匹配。但是上下文中的其他内容是可读的，代码的意图很明确，并且它的一个缺陷（与多次调用关联的重复工作）可以通过简单的let绑定来解决：</p><p> if    |  Just ( arith ::  ArithException)  &lt;- cast e  -&gt;  putStrLn ( &#34;arith: &#34;  &lt;&gt;  show arith)    |  Just ( array ::  ArrayException)  &lt;- cast e  -&gt;  putStrLn ( &#34;array: &#34;  &lt;&gt;  show array)    |  otherwise  -&gt;  putStrLn ( &#34;Something else: &#34;  &lt;&gt;  show e)</p><p> 如果| Just（arith :: ArithException） putStrLn（“ arith：” <> show arith）|只是（array :: ArrayException） putStrLn（“ array：” <>显示数组）|否则-> putStrLn（“其他：” <> show e）</p><p> Though this kind of runtime polymorphism isn’t enormously common in Haskell–we usually resolve polymorphism at compile-time—it’s not unheard of, and, as mentioned above, is provided as part of the  Control.Exception interface to GHC’s hierarchy of exceptions. This Haskell design pattern—an existential data type that inherits from  Typeable—is as close to dynamic dispatch as Haskell gets. Though it’s not common, neither is it invalid: sometimes what’s needed is an event horizon, that hides the concrete representation of a datum but provides, via polymorphism, the chance to reconstitute itself into a concrete type with  Typeable.</p><p> 尽管这种运行时多态在Haskell中并不是很普遍-我们通常在编译时解决多态-这并不是闻所未闻的，并且如上所述，它是GHC异常层次结构的Control.Exception接口的一部分。这种Haskell设计模式（一种从Typeable继承的现有数据类型）与Haskell获得的动态调度一样接近。尽管不常见，但也不是无效的：有时需要的是事件范围，它隐藏了基准的具体表示，但通过多态性提供了使用Typeable将其自身重新构造为具体类型的机会。</p><p>  Essential to most GUI programming is the notion of what macOS and iOS call the  responder chain. The responder chain is responsible for passing events—key presses, mouse clicks, device motions—through the hierarchy of a user interface. For example, shaking one’s device in iOS produces an undo event, if the user has a text field selected. The responder chain is responsible for passing shake events down the window hierarchy, eventually settling on the text field; were it not selected, the rest of the UI would have a chance to intercept and interpret this event.</p><p>对于大多数GUI编程而言，至关重要的是macOS和iOS称为响应者链的概念。响应者链负责通过用户界面的层次结构传递事件，例如按键，鼠标单击，设备运动。例如，如果用户选择了文本字段，则在iOS中摇晃设备会产生撤消事件。响应者链负责将摇动事件向下传递到窗口层次结构中，最终在文本字段上建立。如果未选择，则UI的其余部分将有机会拦截和解释此事件。</p><p> Implementing a responder chain is fairly straightforward in an object-oriented view of the world: there is some superclass that all user interface elements extend, and this interface provides a lingua franca for events to be dynamically dispatched. It becomes somewhat more intricate, at least on the face of it, in a strongly-typed world sans subtyping. Indeed, this was  one of the qualms expressed by the Objective-C community in response to the emergence of Swift. While Swift is  perfectly capable of expressing a fluent, idiomatic responder chain, the lesson is more broadly applicable. Indeed, we can envision a UI framework that implemented this behavior in Haskell:</p><p> 从世界的面向对象的角度来看，实现响应者链非常简单：所有用户界面元素都可以扩展一些超类，并且该接口为动态分配事件提供了通用语言。至少从表面上看，它在没有分型的强类型世界中变得更加复杂。实际上，这是Objective-C社区对Swift的出现表达的忧虑之一。尽管Swift完全有能力表达流畅，惯用的响应者链，但该课程的适用范围更广。实际上，我们可以设想一个在Haskell中实现此行为的UI框架：</p><p> data  Response a  where    Accept  :: a  -&gt;  Response a    Finish  :: a  -&gt;  Response ()    Defer  ::  Response a     class ( Typeable a,  Show a)  =&gt;  Responder a  where    respond ::  Event  -&gt;  Response a     data  SomeResponder  =  forall a  .  Responder a  =&gt;  SomeResponder a     newtype  Chain  =  Chain [ SomeResponder]     -- Dirt-simple imperative implementation with the ST monad.   -- An implementation with a fold could do this all purely   -- but the accumulator is a little fiddly   propagate ::  Responder a  =&gt; (a  -&gt; a)  -&gt;  Chain  -&gt;  Chain  propagate fn ( Chain c)  = runST  do    -- We need a signaling variable in case something in the chain    -- wants to abort the traversal.   abort  &lt;- newSTRef  False    -- Iterate through the responder chain...   result  &lt;- for c \( SomeResponder item)  -&gt;  do    -- attempting to apply the function at each item    let given  =  fmap fn (cast item)    -- but first checking to see if we&#39;ve aborted in prior iterations   done  &lt;- readSTRef abort    if    -- A prior Finish result means we no-op    | done  -&gt;  pure item    -- Return a new value while writing to the signal variable.    |  Just ( Finish a)  &lt;- given  -&gt; a  &lt;$ writeSTRef abort  True    -- Just return the new value.    |  Just ( Accept a)  &lt;- given  -&gt;  pure a    -- No match? Continue onward    | _  -&gt;  pure item    pure ( Chain result)</p><p> 数据响应a where接受:: a->响应完成Finish :: a-> Response（）Defer ::响应一个类（可键入a，显示a）=>响应a where响应::事件->响应数据SomeResponder =永远一个。响应者a => SomeResponder一个新类型Chain = Chain [SomeResponder]-用ST monad实现简单的污垢命令式实现。 -带有折叠的实现可以完全做到这一点-但是累加器稍微有点传播::响应者a =>（a-> a）->链->链传播fn（链c）= runST做- -我们需要一个信号变量，以防万一链中有东西-要中止遍历。中止 do-尝试在给定= fmap fn（cast item）的每个项目上应用该功能-但首先检查是否在先前的迭代中中止完成纯项目-写入信号变量时返回新值。 |只需（完成a）一个纯a-没有匹配项？继续前进| _-> pure item pure（连锁结果）</p><p> Similarly to the  Exception class, we define a  Responder typeclass that implements the interface common to all UI elements that can respond to some hypothetical  Event type. This inherits both from  Show and from  Typeable, in order to admit the  c</p><p> 与Exception类类似，我们定义一个Responder类型类，该类实现了所有可以响应某种假设事件类型的UI元素所共有的接口。为了继承c，它同时继承自Show和Typeable。</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.sumtypeofway.com/posts/existential-haskell.html">https://blog.sumtypeofway.com/posts/existential-haskell.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/存在/">#存在</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>