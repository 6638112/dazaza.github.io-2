<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>状态机状态 The State of State Machines</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The State of State Machines<br/>状态机状态 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-20 02:21:04</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/228ff837052f5704113df87da7478ffa.jpg"><img src="http://img2.diglog.com/img/2021/1/228ff837052f5704113df87da7478ffa.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>On January 29, 2019, a serious   vulnerability  was discovered in Group FaceTime which allowed an attacker to call a target and force the call to connect without user interaction from the target, allowing the attacker to listen to the target’s surroundings without their knowledge or consent. The bug was remarkable in both its impact and mechanism. The ability to force a target device to transmit audio to an attacker device without gaining code execution was an unusual and possibly unprecedented impact of a vulnerability. Moreover, the vulnerability was a logic bug in the FaceTime calling state machine that could be exercised using only the user interface of the device. While this bug was soon fixed, the fact that such a serious and easy to reach vulnerability had occurred due to a logic bug in a calling state machine -- an attack scenario I had never seen considered on any platform -- made me wonder whether other state machines had similar vulnerabilities as well. This post describes my investigation into calling state machines of a number of messaging platforms, including Signal, JioChat, Mocha, Google Duo, and Facebook Messenger.</p><p>2019年1月29日，在FaceTime组中发现了一个严重漏洞，攻击者可以通过该漏洞调用目标并强制呼叫进行连接，而无需用户与目标之间的交互，从而使攻击者无需他们的知情或同意即可收听目标的周围环境。该错误在影响和机制上都非常出色。强制目标设备在不获得代码执行的情况下将音频传输到攻击者设备的能力是此漏洞的异常影响，并且可能是前所未有的影响。此外，该漏洞是FaceTime调用状态机中的逻辑错误，可以仅使用设备的用户界面来执行。尽管此错误很快得到修复，但由于调用状态机中的逻辑错误（这种情况我从未在任何平台上考虑过），因此发生了这样一个严重且易于实现的漏洞，这一事实使我感到奇怪。状态机也有类似的漏洞。这篇文章描述了我对许多消息传递平台（包括Signal，JioChat，Mocha，Google Duo和Facebook Messenger）的呼叫状态机的调查。</p><p>   The majority of video conferencing applications are implemented using   WebRTC , which I’ve discussed in several past   blog    posts .  WebRTC connections are created by exchanging call set-up information in Session Description Protocol (SDP) between peers, a process which is called signalling. Signalling is not implemented by WebRTC, which allows peers to exchange SDP in whatever secure communication message is available to them, usually WebSockets for web applications, and secure messaging for messaging applications.</p><p>   大多数视频会议应用程序都是使用WebRTC实现的，我在过去的几篇博客文章中都对此进行了讨论。通过在对等方之间的会话描述协议（SDP）中交换呼叫建立信息来创建WebRTC连接，此过程称为信令。信令不是由WebRTC实现的，WebRTC允许对等方以对他们可用的任何安全通信消息交换SDP，通常是Web应用程序的WebSockets，以及消息传递应用程序的安全消息传递。</p><p>  There are a few types of SDP that can be exchanged by WebRTC peers. In a typical connection, the caller starts off by sending an SDP offer, and then the callee responds with an SDP answer. These messages contain most information that is needed to transmit and receive media, including codec support, encryption keys and much more. After the offer/answer exchange, peers can send SDP candidates to other peers. Candidates are potential network paths that the two peers can use to connect to each other, and SDP candidates contain information such as IP addresses and TURN servers. Peers usually send more than one candidate to a peer, and candidates can be sent at any time during a connection.</p><p>  WebRTC对等方可以交换几种SDP。在典型的连接中，呼叫者通过发送SDP报价开始，然后被叫方以SDP答复进行响应。这些消息包含传输和接收媒体所需的大多数信息，包括编解码器支持，加密密钥等等。交换报价/答案后，对等方可以将SDP候选者发送给其他对等方。候选对象是两个对等方可以用来相互连接的潜在网络路径，而SDP候选对象包含诸如IP地址和TURN服务器之类的信息。对等方通常会向一个对等方发送多个候选人，并且可以在连接期间的任何时间发送候选人。</p><p>  WebRTC connections maintain an internal state related to whether an offer or answer has been received and processed, however, applications that use WebRTC usually have to maintain their own state machine to manage the user state of the application. How the user state maps to the WebRTC state is a design choice made by the WebRTC integrator, which has both security and performance consequences. For example, some applications do not exchange any SDP until the callee user has interacted with the application to answer the call, meanwhile others set up the peer-to-peer connection, and start sending audio and video from caller to callee before the callee is even notified of the call.</p><p>  WebRTC连接维护一个内部状态，该内部状态与是否已接收或处理要约或答复有关，但是，使用WebRTC的应用程序通常必须维护自己的状态机，以管理应用程序的用户状态。用户状态如何映射到WebRTC状态是WebRTC集成商做出的设计选择，这对安全性和性能都有影响。例如，某些应用程序不交换任何SDP，直到被叫方用户与该应用程序进行交互以接听电话，与此同时，其他一些应用程序则建立对等连接，并在被叫方被呼叫之前开始从主叫方向被叫方发送音频和视频。甚至接到电话通知。</p><p>  Regardless of design, transmitting audio or video from an input device must be directly enabled by application code using WebRTC. This is usually done using a feature called tracks. Every input device is considered a ‘track’, and each specific track must be added to a specific peer connection by calling  addTrack  (or language equivalent) before audio or video is transmitted. Tracks can also be disabled, which is useful for implementing mute and camera-off features. Each track also has an  RTPSender  property that can be used to fine-tune the properties of transmission, which can also be used to disable audio or video transmission.</p><p>  无论设计如何，都必须使用WebRTC由应用程序代码直接启用从输入设备传输音频或视频的功能。通常使用称为轨道的功能来完成此操作。每个输入设备都被视为一个“轨道”，并且在传输音频或视频之前，必须通过调用addTrack（或等效语言）将每个特定轨道添加到特定对等连接。也可以禁用音轨，这对于实现静音和关闭摄像头功能很有用。每个音轨还具有RTPSender属性，可用于微调传输属性，也可用于禁用音频或视频传输。</p><p>  Theoretically, ensuring callee consent before audio or video transmission should be a fairly simple matter of waiting until the user accepts the call before adding any tracks to the peer connection. However, when I looked at real applications they enabled transmission in many different ways. Most of these led to vulnerabilities that allowed calls to be connected without interaction from the callee.</p><p>  从理论上讲，在音频或视频传输之前确保被叫方同意应该是一个相当简单的问题，即等到用户接受呼叫后再向对等连接添加任何曲目。但是，当我查看实际应用程序时，它们以许多不同的方式启用了传输。其中大多数导致了漏洞，这些漏洞使呼叫得以连接而无需被叫者进行交互。</p><p>   I looked at   Signal  in September 2019, and at that time, the application had a calling setup that is very similar to what is recommended in WebRTC documentation.</p><p>   我在2019年9月查看了Signal，当时该应用程序的调用设置与WebRTC文档中所建议的非常相似。 </p><p>      A peer-to-peer connection is established, and then the callee&#39;s audio track is added to the connection when the callee accepts the call by interacting with the user interface. Then a message is sent to the caller via the peer-to-peer connection, telling it to also move to the connected state and add the track.</p><p>建立对等连接，然后当被呼叫者通过与用户界面交互接受呼叫时，将被呼叫者的音轨添加到该连接。然后，一条消息通过对等连接发送给呼叫者，告诉它也移至连接状态并添加曲目。</p><p>  Unfortunately, the application didn’t check that the device receiving the connect message was the caller device, so it was possible to send a connect message from the caller device to the callee. This caused the audio call to connect, allowing the caller to hear the callee’s surroundings. I tested this bug by changing Signal’s open-source code to send the message and recompiling the attacking client.</p><p>  不幸的是，应用程序没有检查接收连接消息的设备是否是呼叫者设备，因此可以将连接消息从呼叫者设备发送到被呼叫者。这导致了音频呼叫的连接，从而使呼叫者能够听到被呼叫者的周围环境。我通过更改Signal的开源代码以发送消息并重新编译攻击的客户端来测试了此错误。</p><p>  This   vulnerability  was fixed in the client in September 2019, and since then, Signal’s signalling code has been replaced by the ringrtc project, which uses a more conservative state machine.</p><p>  此漏洞已于2019年9月在客户端中修复，此后，Signal的信令代码已被ringrtc项目所取代，该项目使用了更为保守的状态机。</p><p>  This bug was purely in Signal’s code, and was not due to a misunderstanding of WebRTC functionality. The state machine design was largely effective requiring user consent to transmit audio, but a specific check was not implemented.</p><p>  该错误纯属Signal的代码，并非由于对WebRTC功能的误解。状态机设计在很大程度上有效，需要用户同意才能传输音频，但未执行特定检查。</p><p>   I accidentally found two very similar vulnerabilities in   JioChat  and   Mocha  messengers in July 2020 while   testing  whether a WebRTC exploit would work on them. They both had a similar signalling design, which was server-mediated.</p><p>   我在2020年7月偶然发现了WebRTC漏洞是否适用于JioChat和Mocha Messenger中的两个非常相似的漏洞。他们都有类似的信令设计，这是服务器介导的。</p><p>     The offer and answer are exchanged via the server, and then both the caller and the callee send their candidates to the server. The server then stores them until the callee interacts with their device and accepts the call. Then the peer-to-peer connection is created, and when WebRTC enters into its internal connected state, the track is added, causing audio and video to be transmitted.</p><p>     通过服务器交换要约和答案，然后呼叫者和被呼叫者都将其候选者发送到服务器。然后，服务器将它们存储起来，直到被呼叫者与他们的设备进行交互并接受呼叫为止。然后，创建对等连接，当WebRTC进入其内部连接状态时，将添加轨道，从而导致音频和视频被传输。</p><p>  This design has a fundamental problem, as candidates can be optionally included in an SDP offer or answer. In that case, the peer-to-peer connection will start immediately, as the only thing preventing the connection in this design is the lack of candidates, which will in turn lead to transmission from input devices. I tested this by using Frida to add candidates to the offers created by each of these applications. I was able to cause JioChat to   send audio  without user consent, and Mocha to   send audio and video . Both of these vulnerabilities were fixed soon after they were filed by filtering SDP on the server.</p><p>  这种设计有一个根本性的问题，因为可以选择将候选人包含在SDP报价或答案中。在这种情况下，对等连接将立即开始，因为在此设计中唯一阻止该连接的原因是缺少候选对象，这反过来又导致从输入设备进行传输。我通过使用Frida将候选人添加到这些应用程序创建的报价中进行了测试。我能够导致JioChat未经用户同意发送音频，而使Mocha发送音频和视频。这两个漏洞在通过过滤服务器上的SDP提交后很快就得到修复。 </p><p>  These issues were caused by a misunderstanding of how WebRTC works coupled with an attempt to improve WebRTC performance with an unusual signalling design. Normally, WebRTC integrators have to decide whether to wait until the callee has answered the call to set up the peer-to-peer connection. Setting the connection up early improves performance and prevents the user from having to wait when they answer a call, but also greatly increases the remote attack surface of WebRTC. These applications tried to improve performance without the security cost with this design, but didn’t consider all the ways that WebRTC can start a peer-to-peer connection.</p><p>这些问题是由于对WebRTC的工作方式的误解以及试图通过不寻常的信号设计来提高WebRTC性能的原因所致。通常，WebRTC集成商必须决定是否等待被叫方应答呼叫以建立对等连接。尽早建立连接可以提高性能，并防止用户在接听电话时不得不等待，但同时也大大增加了WebRTC的远程攻击面。这些应用程序通过这种设计试图在不增加安全性成本的情况下提高性能，但并未考虑WebRTC可以启动对等连接的所有方式。</p><p>  It is generally not a good idea for integrators to gate audio or video transmission on any WebRTC feature that is not adding or enabling tracks. To start, many WebRTC features are complex, so it is easy to make a mistake that allows audio or video to be transmitted. Also, if the feature that is gated on is not commonly-used or not a security feature, it could be poorly tested or changed in the future.</p><p>  对于集成商来说，在不添加或启用轨道的任何WebRTC功能上控制音频或视频传输通常不是一个好主意。首先，许多WebRTC功能都很复杂，因此很容易犯错误，使音频或视频得以传输。同样，如果门控的功能不是常用功能也不是安全功能，则将来可能会对其进行不良测试或更改。</p><p>  I looked at   Google Duo  in September 2020. Duo’s signalling methodology is somewhat different from a lot of messengers because it supports a feature that allows the callee to preview the caller’s video before answering. So a one-way video stream needs to be set up before the call is answered.</p><p>  我在2020年9月查看了GoogleDuo。Duo的信令方法与许多Messenger有所不同，因为它支持一项功能，该功能允许被叫方在应答前预览呼叫者的视频。因此，需要在接听电话之前设置单向视频流。</p><p>     The image above shows the setup of the one-way video stream. Dotted lines represent asynchronous calls made using Java executors. The lack of transmission from callee to caller is enforced by two methods. First, the SDP offer contains the property  a=sendonly  for video, which causes video to only be transmitted in one direction. Also, when the callee receives the offer from the caller,  it adds the video track  to the peer connection, but then disables it using the  RTPSender  property of the track (the audio track is not added or enabled until the user accepts the call).</p><p>     上图显示了单向视频流的设置。虚线表示使用Java执行程序进行的异步调用。从被叫方到主叫方的传输不足是由两种方法引起的。首先，SDP报价包含视频的属性a = sendonly，这导致视频仅在一个方向上传输。同样，当被叫方收到来自呼叫方的报价时，它将视频轨道添加到对等连接，然后使用该轨道的RTPSender属性将其禁用（在用户接受呼叫之前不会添加或启用音频轨道）。</p><p>  Neither of these methods effectively prevents video from being transmitted from callee to caller. The SDP property is easy to get around because the caller provides the SDP to the callee, so it can be easily altered. Disabling the video track as soon as the offer is processed should work, except for the asynchronous design. Normally, the  setLocalDescription  method (which processes the SDP offer) calls the callback  onSetSuccess , and then sets up the peer-to-peer connection after the callback has finished. However, if the callback makes another asynchronous call, the guarantee that  onSetSuccess  finishes before the connection is set up no longer holds, because the  setLocalDescription  method only waits for the  onSetSuccess  thread to finish. This creates a race between disabling the video and setting up the connection, so in some situations, the callee could transmit a few video frames to the caller before transmission is disabled.</p><p>  这些方法均不能有效地防止视频从被呼叫者传输到呼叫者。 SDP属性很容易解决，因为调用方将SDP提供给被调用方，因此可以轻松更改它。处理报价后，立即禁用视频轨道应该可以工作，但异步设计除外。通常，setLocalDescription方法（处理SDP报价）将调用回调onSetSuccess，然后在回调完成后建立对等连接。但是，如果回调进行了另一个异步调用，则将不再保持onSetSuccess在建立连接之前完成的保证，因为setLocalDescription方法仅等待onSetSuccess线程完成。这在禁用视频和建立连接之间造成了竞争，因此在某些情况下，被叫方可以在禁用传输之前向呼叫者发送一些视频帧。</p><p>  I tested this by using Frida to alter the SDP sent by the callee, and then I tried many methods to win the race. It turned out to be fairly hard to win, and I spent roughly two weeks trying to figure out how to slow down the video disable call enough to give the connection time to set up. I ended up sending multiple offers and adding candidates to the offers, which decreased the connection time, as the network connection was already established. Then I sent many messages that take a long time to process through the data channel of the peer-to-peer connection to slow down the disabling of the video track. Data messages are processed on the same thread queue as disabling the video track in Duo, so sending data messages filled up the queue that was needed to disable video with many other entries, delaying the track being disabled.</p><p>  我通过使用Frida更改被叫方发送的SDP进行了测试，然后尝试了多种方法来赢得比赛。事实证明，这很难取胜，我花了大约两个星期的时间来弄清楚如何放慢视频禁用呼叫的速度，以腾出时间来建立连接。我最终发送了多个要约，并向要约中添加了候选者，这减少了连接时间，因为已经建立了网络连接。然后，我通过对等连接的数据通道发送了许多消息，这些消息需要很长时间才能处理，从而减慢了视频轨道的禁用速度。数据消息的处理与在Duo中禁用视频轨道的线程队列相同，因此发送数据消息会填满队列，而该队列需要禁用具有许多其他条目的视频，从而延迟了轨道的禁用。</p><p>  This   bug  was fixed in December 2020 by removing the asynchronous call from  onSetSuccess . While Duo generally designed signalling in a way that is effective in preventing video transmission from callee to caller, implementing the design asynchronously introduced problems. Asynchronous signalling implementations are becoming more common on mobile applications, as there are many unpredictable situations in which WebRTC needs to wait on the network or a peer, and separating function calls into different threads means a delay in one call won’t affect unrelated functionality. However, asynchronous calls make it more difficult to model how a state machine will behave in all situations, so it is important to be cautious about adding asynchronous calls to WebRTC signalling. In this case, the asynchronous call to disable the video track added nothing in terms of performance, as there is no reason any of the calls made to disable the track could block, and  onSetSuccess  already runs in its own thread and can yield to higher priority threads. It’s important to balance the risk and benefit of asynchronous calls and not indiscriminately include them in an application.</p><p>  该错误已于2020年12月通过从onSetSuccess中删除异步调用而得到修复。虽然Duo通常以有效防止从被呼叫者到呼叫者的视频传输的方式设计信令，但是实现该设计异步引入了问题。在许多不可预测的情况下，WebRTC需要在网络或对等点上等待，并且将函数调用分为不同的线程意味着一个调用的延迟不会影响不相关的功能，因此异步信令实现在移动应用程序上变得越来越普遍。但是，异步调用使建模状态机在所有情况下的行为变得更加困难，因此在向WebRTC信令添加异步调用时务必谨慎。在这种情况下，禁用视频轨道的异步调用在性能方面没有增加任何内容，因为没有理由禁用轨道的任何调用都可以阻塞，并且onSetSuccess已经在其自己的线程中运行并且可以产生更高的优先级线程。重要的是要平衡异步调用的风险和收益，并且不要不加选择地将它们包含在应用程序中。 </p><p>    I looked at Facebook Messenger in October 2020. It was a fairly challenging target because of the amount of reverse engineering required.  Stepping back  a bit, WebRTC has bindings in several programming languages which allow it to be integrated into applications using that language. Most Android applications that integrate WebRTC use the Java bindings. This makes investigating signalling state machines fairly straightforward, as important Java functions, such as setLocalDescription (which processes offers and answers), addRemoteIceCandidate (which processes candidates) and addTrack (which adds tracks to connections) can be hooked in Frida and logged for analysis. It is also reasonably straightforward to change the behavior of the attacker device using these calls.</p><p>我在2020年10月查看了Facebook Messenger。由于需要大量的逆向工程，因此这是一个颇具挑战性的目标。退一步，WebRTC具有几种编程语言的绑定，使它可以使用该语言集成到应用程序中。集成WebRTC的大多数Android应用程序都使用Java绑定。这使调查信号状态机变得相当简单，因为重要的Java函数（例如setLocalDescription（处理提供和答复），addRemoteIceCandidate（处理候选对象）和addTrack（将连接添加轨迹）可以挂接到Frida中并记录下来进行分析。使用这些调用更改攻击者设备的行为也相当简单。</p><p>  Facebook Messenger does not use Java bindings to integrate WebRTC, instead it uses C++ bindings. Moreover, it statically links WebRTC to a larger library (librtcR20.so, which is likely the rsys library mentioned in this   article ), so the symbols for calls to bindings get stripped, making them difficult to hook. In addition, Facebook Messenger serializes SDP into another format before it is transmitted, so it is difficult to determine how signalling works by monitoring traffic.</p><p>  Facebook Messenger不使用Java绑定来集成WebRTC，而是使用C ++绑定。而且，它静态地将WebRTC链接到一个更大的库（librtcR20.so，这很可能是本文中提到的rsys库），因此，用于绑定的调用的符号被剥离，从而使其难以挂接。此外，Facebook Messenger在传输SDP之前将其串行化为另一种格式，因此很难通过监视流量来确定信令的工作方式。</p><p>  I eventually realized that the only reasonable way to figure out how Facebook Messenger signalling works was to figure out its network protocol. Thankfully, Facebook has publicly   stated  that they use   fbthrift , a branch of thrift. I loaded the librtcR20.so library into IDA to see if I could find where it called into the thrift library, but while there were a few calls, it looked like the code was mostly statically linked. I eventually figured out that this is because thrift generates serialization code for every protocol implemented, so most of the serialization and deserialization code ends up compiled with the protocol processing code. So I decided to compile fbthrift, make a sample serializer and look at it in IDA, so I could get an impression of what compiled fbthrift serializers look like. I noticed that during serialization, members of an object are serialized by calling a method called  writeFieldBegin . I also noticed that when this method is called, the field name is required, even though it is usually not included in the serialized output. So I looked for a function in librtcR20 that was very frequently called with different string parameters that seemed reasonable for field names. Not very many functions fulfilled that criteria, so I was able to identify  writeFieldBegin .</p><p>  我最终意识到，弄清Facebook Messenger信号工作方式的唯一合理方法是弄清其网络协议。值得庆幸的是，Facebook公开表示他们使用了Thrbift的分支fbthrift。我将librtcR20.so库加载到IDA中，以查看是否可以在thrift库中找到它调用的位置，但是尽管有几次调用，但看起来代码大部分是静态链接的。我最终发现这是因为thrift为实现的每个协议生成序列化代码，因此大多数序列化和反序列化代码最终都使用协议处理代码进行了编译。因此，我决定编译fbthrift，制作一个示例序列化程序，并在IDA中对其进行查看，以便对编译后的fbthrift序列化程序的外观有一个印象。我注意到在序列化过程中，对象的成员通过调用称为writeFieldBegin的方法进行序列化。我还注意到，调用此方法时，即使通常不将其包含在序列化输出中，该字段名称也是必需的。因此，我在librtcR20中寻找了一个函数，该函数经常用不同的字符串参数调用，这对于字段名来说似乎是合理的。满足该条件的功能不是很多，因此我能够确定writeFieldBegin。</p><p>      At this point, I could find many places where objects are serialized, and needed to identify which one was the message used to set up WebRTC calls.</p><p>      在这一点上，我可以找到许多对象被序列化的地方，并且需要确定用于设置WebRTC调用的消息是哪一个。</p><p>  Earlier, I’d noticed a method in the library called  P2PCall::OnP2PMessageFromPeer  (note that the symbol for this method is stripped, but the method name is logged when it is called). This seemed a likely place that a deserialized message would be processed. Searching for the string “P2PMessage”, I found the serialization code for a type called  P2PMessageRequest . I assumed that this was where call setup messages were created.</p><p>  早些时候，我注意到库中有一个称为P2PCall :: OnP2PMessageFromPeer的方法（请注意，该方法的符号已被删除，但调用该方法时会记录该方法的名称）。这似乎是处理反序列化消息的地方。搜索字符串“ P2PMessage”，我找到了名为P2PMessageRequest的类型的序列化代码。我以为这是创建呼叫建立消息的地方。</p><p>  Thrift serialization code is generated based on class definitions in a thrift definition file. Based on the field names and types passed to  writeFieldBegin , I was able to slowly reverse engineer the complete thrift definition for this type. It was tedious work, because the definition was fairly long, and the code is obfuscated in a way that makes register use inconsistent, so I wasn’t confident that any automated approach would be accurate.</p><p>  节俭序列化代码是根据节俭定义文件中的类定义生成的。基于传递给writeFieldBegin的字段名称和类型，我能够对这种类型的完整节俭定义进行缓慢的反向工程。这是繁琐的工作，因为定义时间很长，并且代码的混淆方式使寄存器的使用不一致，因此我不相信任何自动方法都是准确的。</p><p>       Notice that it writes two fields from an object of type  Extmap . The first, named  id , is a mandatory field. The function that writes the code is as follows.</p><p>       请注意，它从类型为Extmap的对象写入两个字段。第一个名为id，是必填字段。编写代码的功能如下。 </p><p>     The field identifier written is 1, and the field type is 8, which translates to i32 (32-bit integer). The second field is an optional field, and the registers to write it are set in the following code.</p><p>写入的字段标识符为1，字段类型为8，它转换为i32（32位整数）。第二个字段是一个可选字段，用于编写它的寄存器在以下代码中设置。</p><p>     This sets the field name to  uri , the field identifier to 2, and the field type to 8 (also i32). All together, this code can be represented by the following thrift definition.</p><p>     这会将字段名称设置为uri，将字段标识符设置为2，并将字段类型设置为8（也为i32）。总之，此代码可由以下节俭定义表示。</p><p>         After similarly reverse engineering every field of the  P2PMessageRequest  type, I had a complete thrift definition, available   here .</p><p>         在对P2PMessageRequest类型的每个字段进行类似的反向工程之后，我有了一个完整的节俭定义，可以在这里找到。</p><p>  I did two things with this thrift definition.  First, I used it to determine the layout of the  P2PMessageRequest  type in C++. This was extremely valuable, as it allowed me to load the struct definition into IDA with every single field named correctly. This made it much easier to understand how incoming messages are handled in  P2PCall::OnP2PMessageFromPeer . This ended up being a bit of a process. fbthrift can generate C++ header files directly from a thrift definition, but these are very long and contain a lot of unnecessary definitions, and can not be processed by IDA. So I ended up compiling the generated source and loading it into IDA, and then exporting the structure definitions and importing them into another IDA instance where librtcR20.so was already loaded. A few fields had different sizes in my compilation versus Facebook’s, but it was close enough that I could get it to work with a few modifications.</p><p>  我用这个节俭的定义做了两件事。首先，我用它来确定C ++中P2PMessageRequest类型的布局。这非常有价值，因为它允许我使用正确命名的每个字段将结构定义加载到IDA中。这使得了解P2PCall :: OnP2PMessageFromPeer如何处理传入消息变得更加容易。最终这只是一个过程。 fbthrift可以直接从Thrift定义生成C ++头文件，但是它们很长，并且包含许多不必要的定义，因此IDA无法对其进行处理。因此，我最终编译了生成的源并将其加载到IDA中，然后导出结构定义并将其导入到已经加载librtcR20.so的另一个IDA实例中。我编辑的几个字段的大小与Facebook的大小不同，但是由于距离足够近，我可以对其进行一些修改。</p><p>  Below is an example of code decompiled in IDA with the thrift definition imported, to give an idea of how much easier it makes it to understand the processing of the message object.</p><p>  下面是在IDA中使用节俭定义导入的反编译代码示例，以使它更容易理解消息对象的处理。</p><p>     I was also able to decode and generate messages sent over the network. To do this, I generated the serialization code from the thrift definition in Python, as thrift supports code generation in many languages. Then, I was able to import this code when using Frida Python to hook functions in Facebook Messenger.</p><p>     我还能够解码并生成通过网络发送的消息。为此，我从Python中的Thrift定义生成了序列化代码，因为Thrift支持多种语言的代码生成。然后，当使用Frida Python挂钩Facebook Messenger中的函数时，我能够导入此代码。</p><p>  Then I needed to find the code that handled incoming  P2PMessageRequest  messages. Since these messages are handled by native code, meanwhile most Facebook messages are handled by Java code, I looked for a native call with an appropriate name. I found  com.facebook.webrtc.WebrtcEngine.onThriftMessageFromPeer . I hooked this method with Frida, and fed its byte array parameter in the generated deserializer, and it decoded incoming messages.</p><p>  然后我需要找到处理传入的P2PMessageRequest消息的代码。由于这些消息是由本机代码处理的，而大多数Facebook消息是由Java代码处理的，因此我寻找了一个具有适当名称的本机调用。我发现com.facebook.webrtc.WebrtcEngine.onThriftMessageFromPeer。我将这种方法与Frida挂钩，并将其字节数组参数输入生成的解串器中，然后对传入的消息进行解码。 </p><p>  I found a similar method used to send thrift messages,  sendThriftToPeer  (this method’s class name is obfuscated and changes in every version of Facebook Messenger, but it can be found by grepping the application’s smali). I was also able to hook this method, and alter its byte array parameter, to change a  P2PMessageRequest  message sent by Facebook Messenger.</p><p>我发现了一种用于发送节俭消息的类似方法sendThriftToPeer（该方法的类名被混淆，并且在每个版本的Facebook Messenger中都进行了更改，但是可以通过grep应用程序的smali来找到）。我还可以挂钩此方法并更改其字节数组参数，以更改Facebook Messenger发送的P2PMessageRequest消息。</p><p>  Now, I was able to understand Facebook Messenger’s signalling state machine. There are two different ways that signalling can occur, depending on where the user is signed into Facebook Messenger. If the user is signed in on multiple devices or browsers, very little happens before the callee interacts with their device.  The offer, answer and candidates are exchanged, but they are stored by the callee device and not processed until the callee user answers the call.  This makes sense, because Facebook Messenger doesn’t know what device to connect to otherwise.</p><p>  现在，我能够理解Facebook Messenger的信号状态机。发生信号的方式有两种，具体取决于用户在何处登录Facebook Messenger。如果用户在多个设备或浏览器上登录，那么在被呼叫者与其设备进行交互之前，几乎不会发生任何事情。报价，答案和候选者被交换，但是它们由被叫设备存储并且在被叫用户应答呼叫之前不被处理。这是有道理的，因为Facebook Messenger不知道要连接哪个设备。</p><p>  If the callee is only signed in on a single device, the state machine is more interesting.</p><p>  如果被叫方仅在单个设备上登录，则状态机会更有趣。</p><p>     In this case, Facebook Messenger enables the track as soon as an offer is received, but alters the offer so that all outgoing streams are inactive. It then replaces the offer with one where they are active when the user interacts with the device.</p><p>     在这种情况下，Facebook Messenger会在收到要约后立即启用跟踪，但会更改要约，以使所有传出流都处于非活动状态。然后，当用户与设备进行交互时，它会用一个激活的提议来代替。</p><p>  I was concerned that there might be a way to bypass the alteration of the offer, but I looked at how this was done, and while I generally don’t recommend using anything other than adding or disabling tracks to disable input device transmission, it was fairly robust. The offer is altered after the SDP is decoded into an internal WebRTC object, and the changes are made directly to this object, which eliminates the possibility of parsing errors.</p><p>  我担心可能有一种绕过要约变更的方法，但我研究了这样做的方法，尽管我一般不建议使用添加或禁用轨道来禁用输入设备传输的其他方法，但是相当强大。在将SDP解码为内部WebRTC对象之后，更改要约，并直接对此对象进行更改，从而消除了解析错误的可能性。</p><p>  However, looking at how incoming messages are handled, I noticed that many message types other than offers, answers and candidates are processed before the call is answered. One type that stood out was called  SdpUpdate . When an  SdpUpdate  message is received, the local offer or answer is updated by calling  setLocalDescription .</p><p>  但是，在查看传入消息的处理方式时，我注意到在应答呼叫之前，除了要约，答案和候选者之外还处理了许多消息类型。一种突出的类型称为SdpUpdate。收到SdpUpdate消息后，将通过调用setLocalDescription更新本地要约或答案。</p><p>  This message type didn’t do anything when sent to the state machine above, as it is already storing SDP and waiting to call  se</p><p>  发送到上述状态机时，此消息类型没有任何作用，因为它已经存储了SDP，正在等待调用 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://googleprojectzero.blogspot.com/2021/01/the-state-of-state-machines.html">https://googleprojectzero.blogspot.com/2021/01/the-state-of-state-machines.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/状态机/">#状态机</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/state/">#state</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/调用/">#调用</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>