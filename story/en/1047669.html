<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Mozilla的浏览器模糊测试 Browser Fuzzing at Mozilla</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Browser Fuzzing at Mozilla<br/>Mozilla的浏览器模糊测试 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-10 03:21:38</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/9b909e36a7cb4c9894a5304da0c9af4f.jpg"><img src="http://img2.diglog.com/img/2021/2/9b909e36a7cb4c9894a5304da0c9af4f.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Mozilla has been  fuzzing Firefox and its underlying components for a while. It has proven to be one of the most efficient ways to identify quality and security issues. In general, we apply fuzzing on  different levels: there is fuzzing the browser as a whole, but a significant amount of time is also spent on  fuzzing isolated code (e.g. with  libFuzzer) or whole components such as the  JS engine using separate shells. In this blog post, we will talk specifically about  browser fuzzing only, and go into detail on the pipeline we’ve developed. This single pipeline is the result of years of work that the fuzzing team has put into aggregating our browser fuzzing efforts to provide consistently actionable issues to developers and to ease integration of internal and external fuzzing tools as they become available.</p><p>Mozilla一直在模糊Firefox及其底层组件。它已被证明是识别质量和安全问题的最有效方法之一。通常，我们在不同级别上应用模糊测试：浏览器作为一个整体进行模糊测试，但也需要花费大量时间来对孤立的代码（例如使用libFuzzer）或整个组件（例如使用单独的外壳的JS引擎）进行模糊测试。在此博客文章中，我们将只讨论浏览器模糊问题，并详细介绍我们开发的管道。这条单一的管道是模糊测试团队经过多年努力的结果，聚集了我们的浏览器模糊测试工作，以向开发人员提供一致可行的问题，并在可用时简化内部和外部模糊工具的集成。</p><p>   To be as effective as possible we make use of different methods of detecting errors. These include sanitizers such as  AddressSanitizer (with LeakSanitizer),  ThreadSanitizer, and  UndefinedBehaviorSanitizer, as well as using debug builds that enable assertions and other runtime checks. We also make use of debuggers such as  rr and  Valgrind. Each of these tools provides a different lens to help uncover specific bug types, but many are incompatible with each other or require their own custom build to function or provide optimal results. Besides providing debugging and error detection, some tools cannot work without build instrumentation, such as code coverage and  libFuzzer. Each operating system and architecture combination requires a unique build and may only support a subset of these tools.</p><p>   为了尽可能有效，我们使用了多种错误检测方法。这些工具包括诸如AddressSanitizer（带有LeakSanitizer），ThreadSanitizer和UndefinedBehaviorSanitizer之类的清理器，以及使用启用断言和其他运行时检查的调试版本。我们还使用了rr和Valgrind等调试器。这些工具中的每一个都提供了不同的视角来帮助发现特定的错误类型，但是许多工具彼此不兼容，或者需要使用自己的自定义版本才能发挥作用或提供最佳结果。除了提供调试和错误检测之外，某些工具如果没有构建工具也无法工作，例如代码覆盖率和libFuzzer。每个操作系统和体系结构的组合都需要唯一的构建，并且可能仅支持这些工具的一部分。</p><p> Last, each variation has multiple active branches including Release, Beta, Nightly, and Extended Support Release (ESR). The  Firefox CI Taskcluster instance builds each of these periodically.</p><p> 最后，每个变体都有多个活动分支，包括发行版，Beta版，每夜版和扩展支持版本（ESR）。 Firefox CI Taskcluster实例会定期构建每个实例。</p><p>  Taskcluster makes it easy to find and download the latest build to test. We discussed above the number of variants created by different instrumentation types, and we need to fuzz them in automation. Because of the large number of combinations of builds, artifacts, architectures, operating systems, and unpacking each, downloading is a non-trivial task.</p><p>  Taskcluster使查找和下载最新版本进行测试变得容易。上面我们讨论了由不同仪器类型创建的变体的数量，我们需要对它们进行自动化模糊处理。由于构建，工件，体系结构，操作系统以及每个软件包的大量组合，因此下载是一项艰巨的任务。</p><p> To help reduce the complexity of build management, we developed a tool called  fuzzfetch. Fuzzfetch makes it easy to specify the required build parameters and it will download and unpack the build. It also supports downloading specified revisions to make it useful with bisection tools.</p><p> 为了帮助降低构建管理的复杂性，我们开发了一个名为fuzzfetch的工具。 Fuzzfetch使您可以轻松指定所需的构建参数，并将下载并解压缩该构建。它还支持下载指定的修订版，以使其可用于二等分工具。</p><p>  As the goal of this blog post is to explain the whole pipeline, we won’t spend much time explaining fuzzers. If you are interested, please read  “Fuzzing Firefox with WebIDL” and the  in-tree documentation. We use a combination of publicly available and custom-built fuzzers to generate test cases.</p><p>  由于此博文的目的是解释整个流程，因此我们不会花太多时间来解释模糊测试。如果您有兴趣，请阅读“使用WebIDL使Firefox模糊”和树状文档。我们结合使用公共可用的和定制的模糊测试器来生成测试用例。</p><p>  For fuzzers that target the browser,  Grizzly manages and runs test cases and monitors for results.  Creating an adapter allows us to easily run existing fuzzers in Grizzly.</p><p>  对于针对浏览器的模糊器，Grizzly管理和运行测试用例并监视结果。创建适配器可以使我们轻松地在Grizzly中运行现有的模糊测试器。 </p><p>  To make full use of available resources on any given machine, we run multiple instances of Grizzly in parallel.</p><p>为了充分利用任何给定机器上的可用资源，我们并行运行多个Grizzly实例。</p><p> For each fuzzer, we create containers to encapsulate the configuration required to run it. These exist in the  Orion monorepo. Each fuzzer has a configuration with deployment specifics and resource allocation depending on the priority of the fuzzer. Taskcluster continuously deploys these configurations to distribute work and manage fuzzing nodes.</p><p> 对于每个模糊器，我们创建容器来封装运行它所需的配置。这些存在于Orion monorepo中。每个模糊器都有一个配置，该配置具有部署细节和资源分配，具体取决于模糊器的优先级。 Taskcluster持续部署这些配置以分配工作并管理模糊测试节点。</p><p> Grizzly Target handles the detection of issues such as hangs, crashes, and other defects. Target is an interface between Grizzly and the browser. Detected issues are automatically packaged and reported to a  FuzzManager server. The FuzzManager server provides automation and a UI for triaging the results.</p><p> Grizzly Target处理诸如挂起，崩溃和其他缺陷之类的问题。目标是Grizzly与浏览器之间的接口。检测到的问题将自动打包并报告给FuzzManager服务器。 FuzzManager服务器提供自动化和用于对结果进行分类的UI。</p><p> Other more targeted fuzzers use  JS shell and  libFuzzer based targets use the  fuzzing interface. Many third-party libraries are also fuzzed in  OSS-Fuzz. These deserve mention but are outside of the scope of this post.</p><p> 其他更具针对性的模糊器使用JS Shell，基于libFuzzer的目标使用模糊接口。 OSS-Fuzz中也模糊了许多第三方库。这些值得一提，但不在本文讨论范围之内。</p><p>  Running multiple fuzzers against various targets at scale generates a large amount of data. These crashes are not suitable for direct entry into a bug tracking system like  Bugzilla. We have tools to manage this data and get it ready to report.</p><p>  针对多个目标大规模运行多个模糊测试器会生成大量数据。这些崩溃不适用于直接进入Bugzilla等Bug跟踪系统。我们有工具来管理这些数据并准备报告。</p><p> The  FuzzManager client library filters out crash variations and duplicate results before they leave the fuzzing node. Unique results are reported to a FuzzManager server. The FuzzManager web interface allows for the creation of signatures that help group reports together in buckets to aid the client in detecting duplicate results.</p><p> FuzzManager客户端库可以过滤崩溃变化和重复结果，然后再离开模糊测试节点。唯一结果将报告给FuzzManager服务器。 FuzzManager Web界面允许创建签名，以帮助在存储桶中将报告分组在一起，以帮助客户端检测重复的结果。</p><p> Fuzzers commonly generate test cases that are hundreds or even thousands of lines long. FuzzManager buckets are automatically scanned to queue reduction tasks in Taskcluster. These reduction tasks use  Grizzly Reduce and  Lithium to apply different reduction strategies, often removing the majority of the unnecessary data. Each bucket is continually processed until a successful reduction is complete. Then an engineer can do a final inspection of the minimized test case and attach it to a bug report. The final result is often used as a crash test in the Firefox test suite.</p><p> 模糊测试器通常会生成长达数百甚至数千行的测试用例。 FuzzManager存储桶将自动进行扫描，以在Taskcluster中进行队列减少任务。这些还原任务使用Grizzly Reduce和Lithium来应用不同的还原策略，通常会删除大多数不必要的数据。每个铲斗都会不断进行处理，直到成功完成还原。然后，工程师可以对最小化的测试用例进行最终检查，并将其附加到错误报告中。最终结果通常用作Firefox测试套件中的崩溃测试。 </p><p>  Code coverage of the fuzzer is also measured periodically. FuzzManager is used again to collect code coverage data and generate coverage reports.</p><p>还定期测量模糊器的代码覆盖率。 FuzzManager再次用于收集代码覆盖率数据并生成覆盖率报告。</p><p>  Our goal is to create actionable bug reports to get issues fixed as soon as possible while minimizing overhead for developers.</p><p>  我们的目标是创建可行的错误报告，以尽快解决问题，同时最大程度地减少开发人员的开销。</p><p>   Grizzly Replay is a tool that forms the basic execution engine for Bugmon and  Grizzly Reduce, and makes it easy to collect  rr traces to submit to Pernosco. It makes re-running browser test cases easy both in automation and for manual use. It simplifies working with stubborn test cases and test cases that trigger multiple results.</p><p>   Grizzly Replay是形成Bugmon和Grizzly Reduce的基本执行引擎的工具，它使收集rr痕迹提交到Pernosco变得容易。它使重新运行浏览器测试用例在自动化和手动使用方面都很容易。它简化了处理顽固的测试用例和触发多个结果的测试用例的工作。</p><p> As mentioned, we have also been making use of Pernosco. Pernosco is a tool that provides a web interface for rr traces and makes them available to developers without the need for direct access to the execution environment. It is an amazing tool developed by a company of the same name which significantly helps to debug massively parallel applications. It is also very helpful when test cases are too unreliable to reduce or attach to bug reports. Creating an rr trace and uploading it can make stalled bug reports actionable.</p><p> 如前所述，我们还一直在使用Pernosco。 Pernosco是一个为rr跟踪提供Web界面的工具，使开发人员可以使用它们，而无需直接访问执行环境。它是由同名公司开发的了不起的工具，可以极大地帮助调试大规模并行应用程序。当测试用例过于不可靠而无法减少或附加到错误报告时，它也非常有用。创建rr跟踪并上载它可以使停滞的错误报告具有可行性。</p><p> The combination of Grizzly and Pernosco have had the added benefit of making infrequent, hard to reproduce issues, actionable. A test case for a very inconsistent issue can be run hundreds or thousands of times until the desired crash occurs under rr. The trace is automatically collected and ready to be submitted to Pernosco and fixed by a developer, instead of being passed over because it was not actionable.</p><p> Grizzly和Pernosco的结合还具有使不经常发生，难以重现的问题变得可行的额外好处。一个非常不一致的问题的测试用例可以运行数百或数千次，直到在rr下发生所需的崩溃为止。跟踪将自动收集并准备提交给Pernosco并由开发人员修复，而不是因为无法执行而被传递。</p><p>  To request new features get a proper assessment, the fuzzing team can be reached at  fuzzing@mozilla.com or on  Matrix. This is also a great way to get in touch for any reason. We are happy to help you with any fuzzing related questions or ideas. We will also reach out when we receive information about new initiatives and features that we think will require attention. Once fuzzing of a component begins, we communicate mainly via Bugzilla. As mentioned, we strive to open actionable issues or enhance existing issues logged by others.</p><p>  要请求新功能获得适当的评估，可以通过fuzzing@mozilla.com或通过Matrix与Fuzzing团队联系。这也是任何原因联系的好方法。我们很高兴为您提供任何令人困惑的相关问题或想法。当我们收到有关我们认为需要关注的新计划和功能的信息时，我们也会伸出援手。组件开始模糊化之后，我们主要通过Bugzilla进行通信。如前所述，我们努力解决可解决的问题或增强他人记录的现有问题。</p><p> Bugmon is used to automatically bisect regression ranges. This notifies the appropriate people as quickly as possible and verifies bugs once they are marked as FIXED. Closing a bug automatically removes it from FuzzManager, so if a similar bug finds its way into the code base, it can be identified again.</p><p> Bugmon用于自动平分回归范围。这会尽快通知适当的人员，并在将错误标记为“已修复”后验证错误。关闭错误会自动将其从FuzzManager中删除，因此，如果类似的错误进入了代码库，则可以再次对其进行识别。 </p><p> Some issues found during fuzzing will prevent us from effectively fuzzing a feature or build variant. These are known as  fuzz-blockers, and they come in a few different forms. These issues may seem benign from a product perspective, but they can block fuzzers from targeting important code paths or even prevent fuzzing a target altogether. Prioritizing these issues appropriately and getting them fixed quickly is very helpful and much appreciated by the fuzzing team.</p><p>模糊测试期间发现的一些问题将阻止我们有效地模糊功能或构建变体。这些被称为模糊阻止程序，它们以几种不同的形式出现。从产品的角度来看，这些问题看起来似乎是无害的，但是它们可以阻止模糊测试程序针对重要的代码路径，甚至完全阻止目标模糊测试。适当地对这些问题进行优先级排序并快速将其修复是非常有用的，并且受到模糊测试团队的赞赏。</p><p> PrefPicker manages the set of Firefox preferences used for fuzzing. When adding features behind a pref, consider adding it to the PrefPicker fuzzing template to have it enabled during fuzzing. Periodic audits of the PrefPicker  fuzzing template can help ensure areas are not missed and resources are used as effectively as possible.</p><p> PrefPicker管理用于模糊测试的Firefox首选项集。在首选项之后添加功能时，请考虑将其添加到PrefPicker模糊模板中以在模糊期间启用它。对PrefPicker模糊模板的定期审核可以帮助确保不遗漏区域，并尽可能有效地利用资源。</p><p>  As in other fields, measurement is a key part of evaluating success. We leverage the meta bug feature of Bugzilla to help us keep track of the issues identified by fuzzers. We strive to have a meta bug per fuzzer and for each new component fuzzed.</p><p>  与其他领域一样，衡量是评估成功的关键部分。我们利用Bugzilla的meta bug功能来帮助我们跟踪由模糊器识别的问题。我们努力使每个模糊器和每个模糊的新组件都有一个元错误。</p><p> For example, the  meta bug for Domino lists all the issues (over 1100!) identified by this tool. Using this Bugzilla data, we are able to show the impact over the years of our various fuzzers.</p><p> 例如，Domino的元错误列出了此工具标识的所有问题（超过1100个！）。使用此Bugzilla数据，我们可以显示多年来各种模糊测试的影响。</p><p>    There are many components in the fuzzing pipeline. These components are constantly evolving to keep up with changes in debugging tools, execution environments, and browser internals. Developers are always adding, removing, and updating browser features. Bugs are being detected, triaged, and logged. Keeping everything running continuously and targeting as much code as possible requires constant and ongoing efforts.</p><p>    模糊测试管道中有许多组件。这些组件在不断发展，以适应调试工具，执行环境和浏览器内部的变化。开发人员总是在添加，删除和更新浏览器功能。正在检测，分类和记录错误。要使所有内容连续运行并针对尽可能多的代码，需要不断不断的努力。</p><p> If you work on Firefox, you can help by keeping us informed of new features and initiatives that may affect or require fuzzing, by prioritizing  fuzz-blockers, and by curating  fuzzing preferences in PrefPicker. If fuzzing interests you, please take part in the  bug bounty program. Our  tools are available publicly, and we encourage bug hunting.</p><p> 如果您使用Firefox，可以通过使我们了解可能会影响或需要进行模糊检测的新功能和计划，对模糊阻止程序进行优先级排序以及在PrefPicker中整理模糊检测首选项来提供帮助。如果您对模糊测试感兴趣，请参加Bug赏金计划。我们的工具是公开可用的，我们鼓励寻找错误。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hacks.mozilla.org/2021/02/browser-fuzzing-at-mozilla/">https://hacks.mozilla.org/2021/02/browser-fuzzing-at-mozilla/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/mozilla/">#mozilla</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fuzzing/">#fuzzing</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>