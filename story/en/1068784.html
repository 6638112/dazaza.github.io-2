<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Linux 文件系统层中的 size_t-to-int 漏洞size_t-to-int vulnerability in Linux’s filesystem layer</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">size_t-to-int vulnerability in Linux’s filesystem layer<br/>Linux 文件系统层中的 size_t-to-int 漏洞</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-07-22 21:43:31</div><div class="page_narrow text-break page_content"><p>Date: Tue, 20 Jul 2021 12:36:11 +0000From: Qualys Security Advisory &lt;qsa@...lys.com&gt;To: &#34;oss-security@...ts.openwall.com&#34; &lt;oss-security@...ts.openwall.com&gt;Subject: CVE-2021-33909: size_t-to-int vulnerability in Linux&#39;s filesystem layerQualys Security AdvisorySequoia: A deep root in Linux&#39;s filesystem layer (CVE-2021-33909)========================================================================Contents========================================================================SummaryAnalysisExploitation overviewExploitation detailsMitigationsAcknowledgmentsTimeline========================================================================Summary========================================================================We discovered a size_t-to-int conversion vulnerability in the Linuxkernel&#39;s filesystem layer: by creating, mounting, and deleting a deepdirectory structure whose total path length exceeds 1GB, an unprivilegedlocal attacker can write the 10-byte string &#34;//deleted&#34; to an offset ofexactly -2GB-10B below the beginning of a vmalloc()ated kernel buffer.We successfully exploited this uncontrolled out-of-bounds write, andobtained full root privileges on default installations of Ubuntu 20.04,Ubuntu 20.10, Ubuntu 21.04, Debian 11, and Fedora 34 Workstation; otherLinux distributions are certainly vulnerable, and probably exploitable.Our exploit requires approximately 5GB of memory and 1M inodes; we willpublish it in the near future. A basic proof of concept (a crasher) isattached to this advisory and is available at: https://www.qualys.com/research/security-advisories/To the best of our knowledge, this vulnerability was introduced in July2014 (Linux 3.16) by commit 058504ed (&#34;fs/seq_file: fallback to vmallocallocation&#34;).========================================================================Analysis========================================================================The Linux kernel&#39;s seq_file interface produces virtual files thatcontain sequences of records (for example, many files in /proc areseq_files, and records are usually lines). Each record must fit into aseq_file buffer, which is therefore enlarged as needed, by doubling itssize at line 242 (seq_buf_alloc() is a simple wrapper aroundkvmalloc()):------------------------------------------------------------------------ 168 ssize_t seq_read_iter(struct kiocb *iocb, struct iov_iter *iter) 169 { 170 struct seq_file *m = iocb-&gt;ki_filp-&gt;private_data; ... 205 /* grab buffer if we didn&#39;t have one */ 206 if (!m-&gt;buf) { 207 m-&gt;buf = seq_buf_alloc(m-&gt;size = PAGE_SIZE); ... 210 } ... 220 // get a non-empty record in the buffer ... 223 while (1) { ... 227 err = m-&gt;op-&gt;show(m, p); ... 236 if (!seq_has_overflowed(m)) // got it 237 goto Fill; 238 // need a bigger buffer ... 240 kvfree(m-&gt;buf); ... 242 m-&gt;buf = seq_buf_alloc(m-&gt;size &lt;&lt;= 1); ... 246 }------------------------------------------------------------------------This size multiplication is not a vulnerability in itself, becausem-&gt;size is a size_t (an unsigned 64-bit integer, on x86_64), and thesystem would run out of memory long before this multiplication overflowsthe integer m-&gt;size.Unfortunately, this size_t is also passed to functions whose sizeargument is an int (a signed 32-bit integer), not a size_t. For example,the show_mountinfo() function (which is called at line 227 to format therecords in /proc/self/mountinfo) calls seq_dentry() (at line 150), whichcalls dentry_path() (at line 530), which calls prepend() (at line 387):------------------------------------------------------------------------135 static int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)136 {...150 seq_dentry(m, mnt-&gt;mnt_root, &#34; \t\n\\&#34;);------------------------------------------------------------------------ 523 int seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc) 524 { 525 char *buf; 526 size_t size = seq_get_buf(m, &amp;buf); ... 529 if (size) { 530 char *p = dentry_path(dentry, buf, size);------------------------------------------------------------------------380 char *dentry_path(struct dentry *dentry, char *buf, int buflen)381 {382 char *p = NULL;...385 if (d_unlinked(dentry)) {386 p = buf + buflen;387 if (prepend(&amp;p, &amp;buflen, &#34;//deleted&#34;, 10) != 0)------------------------------------------------------------------------ 11 static int prepend(char **buffer, int *buflen, const char *str, int namelen) 12 { 13 *buflen -= namelen; 14 if (*buflen &lt; 0) 15 return -ENAMETOOLONG; 16 *buffer -= namelen; 17 memcpy(*buffer, str, namelen);------------------------------------------------------------------------As a result, if an unprivileged local attacker creates, mounts, anddeletes a deep directory structure whose total path length exceeds 1GB,and if the attacker open()s and read()s /proc/self/mountinfo, then:- in seq_read_iter(), a 2GB buffer is vmalloc()ated (line 242), and show_mountinfo() is called (line 227);- in show_mountinfo(), seq_dentry() is called with the empty 2GB buffer (line 150);- in seq_dentry(), dentry_path() is called with a 2GB size (line 530);- in dentry_path(), the int buflen is therefore negative (INT_MIN, -2GB), p points to an offset of -2GB below the vmalloc()ated buffer (line 386), and prepend() is called (line 387);- in prepend(), *buflen is decreased by 10 bytes and becomes a large but positive int (line 13), *buffer is decreased by 10 bytes and points to an offset of -2GB-10B below the vmalloc()ated buffer (line 16), and the 10-byte string &#34;//deleted&#34; is written out of bounds (line 17).========================================================================Exploitation overview========================================================================1/ We mkdir() a deep directory structure (roughly 1M nested directories)whose total path length exceeds 1GB, we bind-mount it in an unprivilegeduser namespace, and rmdir() it.2/ We create a thread that vmalloc()ates a small eBPF program (viaBPF_PROG_LOAD), and we block this thread (via userfaultfd or FUSE) afterour eBPF program has been validated by the kernel eBPF verifier butbefore it is JIT-compiled by the kernel.3/ We open() /proc/self/mountinfo in our unprivileged user namespace,and start read()ing the long path of our bind-mounted directory, therebywriting the string &#34;//deleted&#34; to an offset of exactly -2GB-10B belowthe beginning of a vmalloc()ated buffer.4/ We arrange for this &#34;//deleted&#34; string to overwrite an instruction ofour validated eBPF program (and therefore nullify the security checks ofthe kernel eBPF verifier), and transform this uncontrolled out-of-boundswrite into an information disclosure, and into a limited but controlledout-of-bounds write.5/ We transform this limited out-of-bounds write into an arbitrary readand write of kernel memory, by reusing Manfred Paul&#39;s beautiful btf andmap_push_elem techniques from: https://www.thezdi.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification6/ We use this arbitrary read to locate the modprobe_path[] buffer inkernel memory, and use the arbitrary write to replace the contents ofthis buffer (&#34;/sbin/modprobe&#34; by default) with a path to our ownexecutable, thus obtaining full root privileges.========================================================================Exploitation details========================================================================a/ We create a directory whose total path length exceeds 1GB: in theory,we need to create over 1GB/256B=4M nested directories (NAME_MAX is 255);in practice, show_mountinfo() replaces each &#39;\\&#39; character in our longdirectory with the 4-byte string &#34;\\134&#34;, and we therefore need tocreate only 1M nested directories.b/ We fill all large vmalloc holes: we bind-mount (MS_BIND) variousparts of our long directory in several unprivileged user namespaces andvmalloc()ate large seq_file buffers by read()ing /proc/self/mountinfo.For example, we vmalloc()ate 768MB of large buffers in our exploit.c/ We vmalloc()ate two 1GB buffers and one 2GB buffer (by bind-mountingour long directory in three different user namespaces, and by read()ing/proc/self/mountinfo), and we check that &#34;//deleted&#34; is indeed writtento an offset of -2GB-10B below the beginning of our 2GB buffer (i.e.,8182B above the beginning of our first 1GB buffer -- the &#34;XXX&#34;s areguard pages): &#34;//deleted&#34; | 4KB v 1GB 4KB 1GB 4KB 2GB-----|---|---+-------------|---|-----------------|---|-----------------| ... |XXX| seq_file buffer |XXX| seq_file buffer |XXX| seq_file buffer |-----|---|---+-------------|---|-----------------|---|-----------------| | | | | \----&lt;----&lt;----&lt;----&lt;----&lt;----&lt;----&lt;----/ 8182B -2GB-10Bd/ We fill all small vmalloc holes: we vmalloc()ate various small socketbuffers by send()ing numerous NETLINK_USERSOCK messages. For example, wevmalloc()ate 256MB of small buffers in our exploit.e/ We create 1024 user-space threads; each thread starts loading an eBPFprogram into the kernel, but (via userfaultfd or FUSE) we block everythread in kernel space (at line 2101), before our eBPF programs areactually vmalloc()ated (at line 2162):------------------------------------------------------------------------2076 static int bpf_prog_load(union bpf_attr *attr, union bpf_attr __user *uattr)2077 {....2100 /* copy eBPF program license from user space */2101 if (strncpy_from_user(license, u64_to_user_ptr(attr-&gt;license),....2161 /* plain bpf_prog allocation */2162 prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER);------------------------------------------------------------------------f/ We vfree() our first 1GB seq_file buffer (where &#34;//deleted&#34; waswritten out of bounds), and we immediately unblock all 1024 threads; oureBPF programs are vmalloc()ated into the 1GB hole that we just vfree()d: 4KB 1GB 4KB 1GB 4KB 2GB-----|---|-----------------|---|-----------------|---|-----------------| ... |XXX| eBPF programs |XXX| seq_file buffer |XXX| seq_file buffer |-----|---|-----------------|---|-----------------|---|-----------------|g/ Next, (again via userfaultfd or FUSE) we block one of our threads (atline 12795) after its eBPF program has been validated by the kernel eBPFverifier but before it is JIT-compiled by the kernel:------------------------------------------------------------------------12640 int bpf_check(struct bpf_prog **prog, union bpf_attr *attr,12641 union bpf_attr __user *uattr)12642 {.....12795 print_verification_stats(env);------------------------------------------------------------------------h/ Last, we overwrite an instruction of this eBPF program with anout-of-bounds &#34;//deleted&#34; string (again via our 2GB seq_file buffer),and therefore nullify the security checks of the kernel eBPF verifier: &#34;//deleted&#34; | 4KB v 1GB 4KB 1GB 4KB 2GB-----|---|---+-------------|---|-----------------|---|-----------------| ... |XXX| eBPF programs |XXX| seq_file buffer |XXX| seq_file buffer |-----|---|---+-------------|---|-----------------|---|-----------------| | | | | \----&lt;----&lt;----&lt;----&lt;----&lt;----&lt;----&lt;----/ 8182B -2GB-10BFirst, we transform this uncontrolled eBPF-program corruption into aninformation disclosure. Our first, uncorrupted eBPF program is deemedsafe by the kernel eBPF verifier (&#34;storage&#34; and &#34;control&#34; are two basicBPF_MAP_TYPE_ARRAYs, readable and writable from user space viaBPF_MAP_LOOKUP_ELEM and BPF_MAP_UPDATE_ELEM):- BPF_LD_IMM64_RAW(BPF_REG_2, BPF_PSEUDO_MAP_VALUE, storage) loads the address of our storage map (which resides in kernel space and whose address is unknown to us) into the eBPF register BPF_REG_2;- BPF_MOV64_IMM(BPF_REG_2, 0) immediately replaces the contents of BPF_REG_2 (the address of our storage map) with the constant value 0;- BPF_LD_IMM64_RAW(BPF_REG_3, BPF_PSEUDO_MAP_VALUE, control) loads the address of our control map into BPF_REG_3;- BPF_STX_MEM(BPF_DW, BPF_REG_3, BPF_REG_2, 0) stores the contents of BPF_REG_2 (the constant value 0) into our control map.However, our eBPF-program corruption overwrites the instructionBPF_MOV64_IMM(BPF_REG_2, 0) with the 8-byte string &#34;deleted&#34;, whichtranslates into the instruction BPF_ALU32_IMM(BPF_LSH, BPF_REG_5, 0x74):a NOP (&#34;no operation&#34;), because our program does not use BPF_REG_5. As aresult, we do not store the constant value 0 into our control map:instead, we store and disclose the address of our storage map.(This information disclosure allowed us to greatly reduce the number ofhardcoded kernel offsets in our exploit: our Ubuntu 20.04 exploit workedout of the box on Ubuntu 20.10, Ubuntu 21.04, Debian 11, and Fedora 34.)Second, we transform our uncontrolled eBPF-program corruption into alimited but controlled out-of-bounds write. Our second, uncorrupted eBPFprogram is also deemed safe by the kernel eBPF verifier (&#34;corrupt&#34; is a3*64KB BPF_MAP_TYPE_ARRAY):- BPF_LD_IMM64_RAW(BPF_REG_4, BPF_PSEUDO_MAP_VALUE, corrupt) loads the address of our corrupt map into BPF_REG_4;- BPF_ALU64_IMM(BPF_ADD, BPF_REG_4, 3*64KB/2) points BPF_REG_4 to the middle of our corrupt map;- BPF_ALU64_IMM(BPF_SUB, BPF_REG_4, 3*64KB/4) points BPF_REG_4 to the first quarter of our corrupt map;- BPF_LD_IMM64_RAW(BPF_REG_3, BPF_PSEUDO_MAP_VALUE, control) loads the address of our control map into BPF_REG_3;- BPF_LDX_MEM(BPF_H, BPF_REG_7, BPF_REG_3, 0) loads a variable 16-bit offset from our control map into BPF_REG_7;- BPF_ALU64_REG(BPF_ADD, BPF_REG_4, BPF_REG_7) adds BPF_REG_7 (our variable 16-bit offset) to BPF_REG_4, which therefore points safely within the bounds of our corrupt map (because BPF_REG_7 is in the [0,64KB] range).However, our eBPF-program corruption overwrites the instructionBPF_ALU64_IMM(BPF_ADD, BPF_REG_4, 3*64KB/2) with the string &#34;deleted&#34;,which translates into BPF_ALU32_IMM(BPF_LSH, BPF_REG_5, 0x74) (a NOP).As a result, the following BPF_ALU64_IMM(BPF_SUB, BPF_REG_4, 3*64KB/4)points BPF_REG_4 out of bounds and allows us to read from and write tothe struct bpf_map that precedes our corrupt map in kernel space.Finally, we transform this limited out-of-bounds read and write into anarbitrary read and write of kernel memory, by reusing Manfred Paul&#39;s btfand map_push_elem techniques:- With the arbitrary kernel read we locate the symbol &#34;__request_module&#34; and hence the function __request_module(), disassemble this function, and extract the address of modprobe_path[] from the instructions for &#34;if (!modprobe_path[0])&#34;.- With the arbitrary kernel write we overwrite the contents of modprobe_path[] (&#34;/sbin/modprobe&#34; by default) with a path to our own executable, and call request_module() (by creating a netlink socket), which executes modprobe_path, and hence our own executable, as root.========================================================================Mitigations========================================================================Important note: the following mitigations prevent only our specificexploit from working (but other exploitation techniques may exist); tocompletely fix this vulnerability, the kernel must be patched.- Set /proc/sys/kernel/unprivileged_userns_clone to 0, to prevent an attacker from mounting a long directory in a user namespace. However, the attacker may mount a long directory via FUSE instead; we have not fully explored this possibility, because we accidentally stumbled upon CVE-2021-33910 in systemd: if an attacker FUSE-mounts a long directory (longer than 8MB), then systemd exhausts its stack, crashes, and therefore crashes the entire operating system (a kernel panic).- Set /proc/sys/kernel/unprivileged_bpf_disabled to 1, to prevent an attacker from loading an eBPF program into the kernel. However, the attacker may corrupt other vmalloc()ated objects instead (for example, thread stacks), but we have not investigated this possibility.========================================================================Acknowledgments========================================================================We thank the PaX Team for answering our many questions about the Linuxkernel. We also thank Manfred Paul, Jann Horn, Brandon Azad, SimonScannell, and Bruce Leidl for their exploits and write-ups: https://www.thezdi.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification https://googleprojectzero.blogspot.com/2016/06/exploiting-recursion-in-linux-kernel_20.html https://googleprojectzero.blogspot.com/2020/12/an-ios-hacker-tries-android.html https://scannell.io/posts/ebpf-fuzzing/ https://github.com/brl/grlhWe thank Red Hat Product Security and the members oflinux-distros@...nwall and security@...nel for their work on thiscoordinated disclosure. We also thank Mitre&#39;s CVE Assignment Team.Finally, we thank Marco Ivaldi for his continued support.========================================================================Timeline========================================================================2021-06-09: We sent our advisories for CVE-2021-33909 and CVE-2021-33910to Red Hat Product Security (the two vulnerabilities are closely relatedand the systemd-security mailing list is hosted by Red Hat).2021-07-06: We sent our advisories, and Red Hat sent the patches theywrote, to the linux-distros@...nwall mailing list.2021-07-13: We sent our advisory for CVE-2021-33909, and Red Hat sentthe patch they wrote, to the security@...nel mailing list.2021-07-20: Coordinated Release Date (12:00 PM UTC).  View attachment &#34; CVE-2021-33909-crasher.c &#34; of type &#34;text/plain &#34; (6904 bytes)</p><p>日期：2021 年 7 月 20 日，星期二 12:36:11 +0000 发件人：Qualys 安全咨询 &lt;qsa@...lys.com&gt;致：“oss-security@...ts.openwall.com”&lt;oss-security@。 ..ts.openwall.com&gt;主题：CVE-2021-33909：Linux 文件系统层中的 size_t-to-int 漏洞Qualys 安全公告红杉：Linux 文件系统层的深层根源 (CVE-2021-33909)======== ================================================== ================内容================================== ======================================总结分析利用概览利用细节缓解确认时间线========== ================================================== ==============总结==================================== ==================================我们在 Linux 内核的文件系统中发现了 size_t-to-int 转换漏洞layer：通过创建、挂载和删除总路径长度超过1GB的deepdirectory结构，非特权本地攻击者可以将10字节的字符串“//deleted”写入exac的偏移量tly -2GB-10B 在 vmalloc()ated 内核缓冲区的开头下方。我们成功地利用了这种不受控制的越界写入，并在 Ubuntu 20.04、Ubuntu 20.10、Ubuntu 21.04、Debian 11 和Fedora 34 工作站；其他 Linux 发行版肯定是易受攻击的，并且很可能被利用。我们的利用需要大约 5GB 的内存和 1M 的 inode；我们将在不久的将来发布它。此公告附有一个基本的概念证明（崩溃程序），可从以下网址获得：https://www.qualys.com/research/security-advisories/ 据我们所知，此漏洞于 2014 年 7 月引入（Linux 3.16 ) 通过提交 058504ed (&quot;fs/seq_file: fallback to vmallocallocation&quot;).================================== ======================================分析========== ================================================== ============Linux 内核的seq_file 接口产生包含记录序列的虚拟文件（例如，/proc areseq_files 中有很多文件，记录通常是行）。每个记录必须适合 aseq_file 缓冲区，因此可以根据需要通过在第 242 行将其大小加倍（seq_buf_alloc() 是 kvmalloc() 的简单包装器）来扩大该缓冲区：---------------- -------------------------------------------------- ------ 168 ssize_t seq_read_iter(struct kiocb *iocb, struct iov_iter *iter) 169 { 170 struct seq_file *m = iocb-&gt;ki_filp-&gt;private_data; ... 205 /* 抓取缓冲区，如果我们没有缓冲区 */ 206 if (!m-&gt;buf) { 207 m-&gt;buf = seq_buf_alloc(m-&gt;size = PAGE_SIZE); ... 210 } ... 220 // 获取缓冲区中的非空记录 ... 223 while (1) { ... 227 err = m-&gt;op-&gt;show(m, p); ... 236 if (!seq_has_overflowed(m)) // 得到它 237 goto Fill; 238 // 需要更大的缓冲区... 240 kvfree(m-&gt;buf); ... 242 m-&gt;buf = seq_buf_alloc(m-&gt;size &lt;&lt;= 1); ... 246 }-------------------------------------------- ---------------------------这种大小乘法本身并不是漏洞，因为m-&gt;size 是一个size_t（一个无符号的64 位整数，在 x86_64 上），并且系统会在乘法溢出整数 m-&gt;size 之前很久就耗尽内存。不幸的是，这个 size_t 也被传递给 size 参数是 int（有符号的 32 位整数）而不是 size_t 的函数.例如，show_mountinfo() 函数（在第 227 行调用以格式化 /proc/self/mountinfo 中的记录）调用 seq_dentry()（在第 150 行），它调用 dentry_path()（在第 530 行），它调用 prepend( )（在第 387 行）：------------------------------------------- -----------------------------135 static int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)136 {...150 seq_dentry(m, mnt-&gt;mnt_root, &quot; \t\n\\&quot;);------------------------------ ----------------------------------------- 523 int seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc) 524 { 525 char *buf; 526 size_t size = seq_get_buf(m, &amp;buf); ... 529 if (size) { 530 char *p = dentry_path(dentry, buf, size);--------------------------- ---------------------------------------------380 char *dentry_path( struct dentry *dentry, char *buf, int buflen)381 {382 char *p = NULL;...385 if (d_unlinked(dentry)) {386 p = buf + buflen;387 if (prepend(&amp;p, &amp;buflen, &quot; //deleted&quot;, 10) != 0)-------------------------------------- --------------------------------- 11 static int prepend(char **buffer, int *buflen, const char * str, int namelen) 12 { 13 *buflen -= namelen; 14 if (*buflen &lt; 0) 15 返回 -ENAMETOOLONG; 16 *缓冲区-=名称长度； 17 memcpy(*buffer, str, namelen);--------------------------------------- ---------------------------------结果，如果无特权的本地攻击者创建、挂载和删除深层目录总路径长度超过 1GB 的结构，如果攻击者 open()s 和 read()s /proc/self/mountinfo，则：- 在 seq_read_iter() 中，vmalloc() 化了 2GB 缓冲区（第 242 行），并且show_mountinfo() 被调用（第 227 行）；- 在 show_mountinfo() 中，seq_dentry() 用空的 2GB 缓冲区调用（第 150 行）；- 在 seq_dentry() 中，dentry_path() 用 2GB 大小调用（第 530 行） ;- 在 dentry_path() 中，因此 int buflen 为负（INT_MIN，-2GB），p 指向 vmalloc()ated 缓冲区下方 -2GB 的偏移量（第 386 行），并调用 prepend()（第 387 行） ;- 在 prepend() 中，*buflen 减少了 10 个字节，变成了一个大但正整数（第 13 行），*buffer 减少了 10 个字节并指向 vmalloc()ated 缓冲区下方 -2GB-10B 的偏移量（第 16 行），10 字节字符串“//deleted”是 wri tten 越界（第 17 行）。========================================== ==============================开发概述================ ================================================== ======1/ 我们mkdir() 一个总路径长度超过1GB 的深层目录结构（大约1M 个嵌套目录），我们将它绑定挂载到一个非特权用户命名空间，然后rmdir() 它。2/ 我们创建一个线程vmalloc() 生成一个小的 eBPF 程序（viaBPF_PROG_LOAD），在我们的 eBPF 程序通过内核 eBPF 验证程序验证之后，但在内核进行 JIT 编译之前，我们阻塞了这个线程（通过 userfaultfd 或 FUSE）。3/ 我们打开（ ) /proc/self/mountinfo 在我们的非特权用户命名空间中，并开始 read() 我们的绑定挂载目录的长路径，从而将字符串“//deleted”写入到 a 开头下方恰好 -2GB-10B 的偏移量vmalloc()ated buffer.4/ 我们安排这个“//deleted”字符串覆盖我们经过验证的 eBPF 程序的指令（从而使安全 c hecks of the kernel eBPF verifier)，并将这种不受控制的越界写入转换为信息披露，并转换为有限但受控的越界写入。5/我们将这种有限的越界写入转换为任意读写内核内存，通过重用 Manfred Paul 漂亮的 btf andmap_push_elem 技术：https://www.thezdi.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper- ebpf-program-verification6/ 我们使用这个任意读取来定位 modprobe_path[] 缓冲区内核内存，并使用任意写入将这个缓冲区的内容（默认为“/sbin/modprobe”）替换为我们自己的可执行文件的路径，从而============================================================================================================================================================================================ ==========================开发细节====================== ================================================== =a/ 我们创建一个总路径长度超过1GB的目录：理论上，我们需要创建超过1GB/256B=4M的嵌套目录tories（NAME_MAX 为 255）；实际上，show_mountinfo() 将我们长目录中的每个 &#39;\\&#39; 字符替换为 4 字节字符串“\\134”，因此我们只需要创建 1M 嵌套目录。b/ 我们填充所有大 vmalloc 漏洞：我们在几个非特权用户命名空间中绑定挂载 (MS_BIND) 长目录的各个部分，并且 vmalloc() 通过 read()ing /proc/self/mountinfo 消耗大 seq_file 缓冲区。例如，我们 vmalloc() 消耗了 768MB我们的exploit.c/中的大缓冲区我们 vmalloc() 使用了两个 1GB 缓冲区和一个 2GB 缓冲区（通过在三个不同的用户命名空间中绑定挂载我们的长目录，以及通过 read()ing/proc/self/mountinfo），我们检查“//deleted”确实写入了我们 2GB 缓冲区开头下方的 -2GB-10B 偏移量（即，我们第一个 1GB 缓冲区开头上方的 8182B——“XXX”的保护页）：“//deleted &quot; | 4KB v 1GB 4KB 1GB 4KB 2GB-----|---|---+-------------|---|----------- ------|---|-----------------| ... |XXX| seq_file 缓冲区 |XXX| seq_file 缓冲区 |XXX| seq_file 缓冲区 |-----|---|---+-------------|---|--------------- --|---|-----------------| | | | | \----&lt;----&lt;----&lt;----&lt;----&lt;----&lt;----&lt;----/ 8182B -2GB-10Bd/ 我们都填小的 vmalloc 漏洞：我们 vmalloc() 通过发送 () 大量 NETLINK_USERSOCK 消息来处理各种小套接字缓冲区。例如，wevmalloc() 在我们的exploit.e/中占用了256MB 的小缓冲区。我们创建了1024 个用户空间线程；每个线程开始将 eBPF 程序加载到内核中，但是（通过 userfaultfd 或 FUSE）我们阻止内核空间中的每个线程（在第 2101 行），在我们的 eBPF 程序实际上被 vmalloc() 化之前（在第 2162 行）：------ -------------------------------------------------- ----------------2076 static int bpf_prog_load(union bpf_attr *attr, union bpf_attr __user *uattr)2077 {....2100 /* 从用户空间复制 eBPF 程序许可证 */ 2101 if (strncpy_from_user(license, u64_to_user_ptr(attr-&gt;license),....2161 /* 简单的 bpf_prog 分配 */2162 prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt)-------GFP_USER); -------------------------------------------------- ---------------f/ 我们 vfree() 我们的第一个 1GB seq_file 缓冲区（其中“//deleted”被写入越界），我们立即解除对所有 1024 个线程的阻塞；我们的 BPF 程序是vmalloc() 插入我们刚刚 vfree()d 的 1GB 孔中： 4KB 1GB 4KB 1GB 4KB 2GB-----|---|-----------------| ---|-----------------|---|-----------------| ... |XXX| eBPF 程序|XXX| seq_file 缓冲区 |XXX| seq_file 缓冲区 |-----|---|-----------------|---|--------------- --|---|-----------------|g/ 接下来，（再次通过 userfaultfd 或 FUSE）我们在 eBPF 程序之后阻塞我们的一个线程（atline 12795）已通过内核 eBPFverifier 验证，但在内核 JIT 编译之前：-------------------------------- ----------------------------------------12640 int bpf_check(struct bpf_prog **prog, union bpf_attr *attr,12641 union bpf_attr __user *uattr)12642 {.....12795 print_verification_stats(env);------------------------ -----------------------------------------------h/ 最后，我们用一个越界的“//deleted”字符串（再次通过我们的2GB seq_file缓冲区）覆盖了这个eBPF程序的一条指令，因此使内核eBPF验证器的安全检查无效：“//deleted”| 4KB v 1GB 4KB 1GB 4KB 2GB-----|---|---+-------------|---|----------- ------|---|-----------------| ... |XXX| eBPF 程序 |XXX| seq_file 缓冲区 |XXX| seq_file 缓冲区 |-----|---|---+-------------|---|--------------- --|---|-----------------| | | | | \----&lt;----&lt;----&lt;----&lt;----&lt;----&lt;----&lt;----/ 8182B -2GB-10B 首先，我们改造这个不受控制的 eBPF 程序损坏为信息泄露。我们的第一个未损坏的 eBPF 程序被内核 eBPF 验证器认为是安全的（“storage”和“control”是两个基本的 BPF_MAP_TYPE_ARRAY，通过 BPF_MAP_LOOKUP_ELEM 和 BPF_MAP_UPDATE_ELEM 从用户空间可读和可写）：- BPF_LD_IMM64_RAW，加载我们的存储地址存储映射（驻留在内核空间中，我们不知道其地址）到 eBPF 寄存器 BPF_REG_2；- BPF_MOV64_IMM(BPF_REG_2, 0) 立即将 BPF_REG_2 的内容（我们存储映射的地址）替换为常量值 0；- BPF_LD_IMM64_RAW(BPF_REG_3, BPF_PSEUDO_MAP_VALUE, control) 将我们控制映射的地址加载到 BPF_REG_3 中；- BPF_STX_MEM(BPF_DW, BPF_REG_3, BPF_REG_2, 0) 将 BPF_REG_2 的内容存储到我们的控制映射中（我们的常量值 eBPF.0）程序损坏用 8 字节字符串“已删除”覆盖指令 BPF_MOV64_IMM(BPF_REG_2, 0)，该字符串转换为指令 BPF_ALU32_IMM(BPF_LSH, BPF_REG_5, 0x74):a NO P（“无操作”），因为我们的程序没有使用 BPF_REG_5。因此，我们没有将常量值 0 存储到我们的控制映射中：相反，我们存储并公开了存储映射的地址。（此信息公开使我们能够大大减少我们的漏洞利用中硬编码内核偏移量的数量：我们的 Ubuntu 20.04在 Ubuntu 20.10、Ubuntu 21.04、Debian 11 和 Fedora 34 上开箱即用。）其次，我们将不受控制的 eBPF 程序损坏转化为有限但受控的越界写入。我们的第二个未损坏的 eBPF 程序也被内核 eBPF 验证器认为是安全的（“损坏”是 a3*64KB BPF_MAP_TYPE_ARRAY）：- BPF_LD_IMM64_RAW(BPF_REG_4, BPF_PSEUDO_MAP_VALUE,corruption) 将我们损坏的映射的地址加载到 BPF_REGADD_4_BPF_4BPF_4BPF_4BPF_4B , 3*64KB/2) 将 BPF_REG_4 指向我们损坏映射的中间；- BPF_ALU64_IMM(BPF_SUB, BPF_REG_4, 3*64KB/4) 将 BPF_REG_4 指向我们损坏映射的第一季度；- BPF_LD_IMM64_RAW(BPF_REG_3, BPF_REG_3, BPF_MAPF_MAP)将我们的控制映射的地址加载到 BPF_REG_3；- BPF_LDX_MEM(BPF_H, BPF_REG_7, BPF_REG_3, 0) 从我们的控制映射加载一个变量 16 位偏移到 BPF_REG_7；- BPF_ALU64_REG(BPF_ADD, BPF_REG_4, 添加 BPF_REG_7) -bit 偏移）到 BPF_REG_4，因此它安全地指向我们损坏的映射的边界内（因为 BPF_REG_7 在 [0,64KB] 范围内）。但是，我们的 eBPF 程序损坏覆盖了指令 BPF_ALU64_IMM(BPF_ADD, BPF_REG_4, 3*64KB /2) 与 str ing &quot;deleted&quot;, 翻译成 BPF_ALU32_IMM(BPF_LSH, BPF_REG_5, 0x74) (a NOP). 因此，下面的 BPF_ALU64_IMM(BPF_SUB, BPF_REG_4, 3*64KB/4) 指向 BPF_REG_4 并允许我们从边界读取并写入内核空间中损坏映射之前的结构 bpf_map。最后，我们通过重用 Manfred Paul 的 btfand map_push_elem 技术，将这种有限的越界读写转换为内核内存的任意读写：- 使用任意内核读取我们找到符号“__request_module”，因此找到函数 __request_module()，反汇编这个函数，并从“if (!modprobe_path[0])”的指令中提取 modprobe_path[] 的地址。 - 使用任意内核编写我们用我们自己的可执行文件的路径覆盖 modprobe_path[]（默认为“/sbin/modprobe”）的内容，并调用 request_module()（通过创建一个 netlink 套接字），它以 root 身份执行 modprobe_path，从而执行我们自己的可执行文件.================================ ========================================缓解措施========== ================================================== ==============重要提示：以下缓解措施仅阻止我们特定的漏洞利用（但可能存在其他漏洞利用技术）；要彻底修复此漏洞，必须修补内核。- 将 /proc/sys/kernel/unprivileged_userns_clone 设置为 0，以防止攻击者在用户命名空间中挂载长目录。但是，攻击者可能会通过 FUSE 挂载一个长目录；我们还没有完全探索这种可能性，因为我们无意中在 systemd 中偶然发现了 CVE-2021-33910：如果攻击者 FUSE-mount 一个长目录（超过 8MB），那么 systemd 会耗尽其堆栈，崩溃，从而导致整个操作崩溃系统（内核崩溃）。- 将 /proc/sys/kernel/unprivileged_bpf_disabled 设置为 1，以防止攻击者将 eBPF 程序加载到内核中。然而，攻击者可能会破坏其他 vmalloc() 化对象（例如，线程堆栈），但我们尚未调查这种可能性。====================== ================================================== =鸣谢================================================ ========================我们感谢 PaX 团队回答了我们关于 Linux 内核的许多问题。我们还要感谢 Manfred Paul、Jann Horn、Brandon Azad、SimonScannell 和 Bruce Leidl 的利用和文章：https://www.thezdi.com/blog/2020/4/8/cve-2020-8835-linux -kernel-privilege-escalation-via-improper-ebpf-program-verification https://googleprojectzero.blogspot.com/2016/06/exploiting-recursion-in-linux-kernel_20.html https://googleprojectzero.blogspot.com /2020/12/an-ios-hacker-tries-android.html https://scannell.io/posts/ebpf-fuzzing/ https://github.com/brl/grlh 感谢红帽产品安全部和linux的成员-distros@...nwall 和 security@...nel 在此协调披露方面的工作。我们还要感谢 Mitre 的 CVE 分配团队。最后，我们感谢 Marco Ivaldi 的持续支持。================================ ==========================================时间线======== ================================================== ==============2021-06-09：我们将针对 CVE-2021-33909 和 CVE-2021-33910 的建议发送给 Red Hat 产品安全（这两个漏洞密切相关，并且 systemd-安全邮件列表由 Red Hat 托管。2021-07-06：我们发送了我们的建议，Red Hat 将他们编写的补丁发送到了 linux-distros@...nwall 邮件列表。2021-07-13：我们发送了我们针对 CVE-2021-33909 的建议和 Red Hat 将他们编写的补丁发送到 security@...nel 邮件列表。2021-07-20：协调发布日期（UTC 时间下午 12:00）。查看“text/plain”类型的附件“CVE-2021-33909-crasher.c”（6904 字节）</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.openwall.com/lists/oss-security/2021/07/20/1">https://www.openwall.com/lists/oss-security/2021/07/20/1</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/漏洞/">#漏洞</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/int/">#int</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bpf/">#bpf</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>