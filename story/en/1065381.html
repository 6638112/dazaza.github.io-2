<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>将Quake 3翻译成锈病（2020） Translating Quake 3 into Rust (2020)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Translating Quake 3 into Rust (2020)<br/>将Quake 3翻译成锈病（2020） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-13 02:52:48</div><div class="page_narrow text-break page_content"><p>By  Andrei Homescu &amp;  Stephen Crane &amp;  Miguel Saldivar  The Rust-loving team at Immunant has been hard at work on C2Rust, a migration framework that takes the drudgery out of migrating to Rust. Our goal is to make safety improvements to the translated Rust automatically where we can, and help the programmer do the same where we cannot. First, however, we have to build a rock-solid translator that gets people up and running in Rust. Testing on small CLI programs gets old eventually, so we decided to try translating Quake 3 into Rust. After a couple of days, we were likely the first people to ever play Quake3 in Rust!</p><p>由Andrei Homescu＆amp; Stephen Crane＆amp; Miguel Saldivar Imgunant的耐热队在C2RUST上努力工作，这是一个迁移框架，将欺凌手机迁移到锈蚀。我们的目标是自动对翻译铁锈进行安全改进，并帮助程序员在我们不能的地方做同样的事情。首先，我们必须建立一个摇滚固体翻译，让人们陷入困境。关于小型CLI程序的测试最终变老，因此我们决定尝试将Quake 3转换为Rust。几天后，我们可能是第一个在锈病中玩Quake3的人！</p><p>  After looking at the original Quake 3 source code and various forks, we settled on  ioquake3. It is a community fork of Quake 3 that is still maintained and builds on modern platforms.</p><p>  在查看原始地震3源代码和各种叉子之后，我们在Ioquake3上解决了。它是一个Quake 3的社区叉，仍然保持在现代平台上。</p><p>    $ tree --prune -I missionpack -P &#34;*.so|*x86_64&#34;.└── build └── debug-linux-x86_64 ├── baseq3 │ ├── cgamex86_64.so # client │ ├── qagamex86_64.so # game server │ └── uix86_64.so # ui ├── ioq3ded.x86_64 # dedicated server binary ├── ioquake3.x86_64 # main binary ├── renderer_opengl1_x86_64.so # opengl1 renderer └── renderer_opengl2_x86_64.so # opengl2 renderer</p><p>    $树 - 攻击-i missionpack -p＆＃34; *。所以| * x86_64＆＃34;。└─构建└──debug-linux-x86_64──baseq3│───cgamex86_64.so＃client│ ├──qagamex86_64.so＃游戏服务器│└──uix86_64.so＃ui├──1-10qded.x86_64#dedicated服务器二进制├──ioquake3.x86_64＃main二进制├──renderer_opengl1_x86_64.so＃opengl1渲染器└──renderer_opengl2_x86_64 .so＃OpenGL2渲染器</p><p> Of these libraries, the UI, client, and server libraries can be built as either  Quake VM assembly or native X86 shared libraries. We opted to use the native versions of these libraries for our project. Translating just the VM into Rust and using the QVM versions would have been significantly simpler but we wanted to thoroughly test out C2Rust.</p><p> 这些库，UI，客户端和服务器库可以作为Quake VM程序集或本机X86共享库构建。我们选择为我们的项目使用这些库的本机版本。将VM转换为RUDER和使用QVM版本的显着更简单，但我们希望彻底测试C2rust。</p><p> We focused on the UI, game, client, OpenGL1 renderer and main binary for our translation. It would be possible to translate the OpenGL2 renderer as well, but we chose to skip it as it makes significant use of  .glsl shader files which the build system embeds as literal strings in C source code. While we could add custom build script support for embedding the GLSL code into Rust strings after we transpile, there’s not a good automatic way to transpile these autogenerated, temporary files  1. We instead just translated the OpenGL1 renderer library and forced the game to use it instead of the default renderer. Finally, we decided to skip the dedicated server and mission pack files, as they wouldn’t be hard to translate but were also not necessary for our demonstration.</p><p> 我们专注于UI，游戏，客户，OpenGL1渲染器和主要二进制我们的翻译。也可以转换OpenGL2渲染器，但我们选择跳过它，因为它可以大量使用构建系统在C源代码中嵌入为文字字符串。虽然我们可以添加自定义构建脚本支持在我们转换后将GLSL代码嵌入到生锈字符串中，但没有一个良好的自动方法来转换这些自动化的，临时文件1.我们刚才翻译了OpenGL1渲染器库并强制游戏使用它而不是默认渲染器。最后，我们决定跳过专用的服务器和任务包文件，因为他们不会难以翻译，但也没有必要的演示。</p><p>  To preserve the directory structure used by Quake 3 and not need to change its source code, we needed to produce exactly the same binaries as the native build, meaning four shared libraries and one executable.Since C2Rust produces Cargo build files, each binary needs its own Rust crate with a corresponding  Cargo.toml file.For C2Rust to produce one crate per output binary, it would need a list of the binaries along with their corresponding object or source files, and linker invocation used to produce each binary (used to determine other details like library dependencies).</p><p>  要保留Quake 3所使用的目录结构，无需更改其源代码，我们需要生成与本机构建完全相同的二进制文件，这意味着四个共享库和一个可执行文件.SINCE C2Rust生成货物构建文件，每个二进制需要它拥有相应的Cargo.Toml文件的锈帽。对于每个输出二进制文件生成一个箱子，它需要一副箱子以及它们的相应对象或源文件，以及用于生成每个二进制的链接器调用（用于确定其他细节等图书馆依赖项）。</p><p> However, we quickly ran into one limitation with the way C2Rust intercepts the native build process: C2Rust takes a  compilation database file as an input, which contains a list of compilation commands executed during the build.However, this database  only contains compilation commands, and not any linker invocations.Most tools that produce this database have this intentional limitation, e.g.,  cmake with  CMAKE_EXPORT_COMPILE_COMMANDS,  bear and  compiledb.To our knowledge, the only tool that does include linking commands is   build-logger from  CodeChecker, which we didn’t use because we only learned about it after writing our own wrappers (described below).This meant that we couldn’t use a  compile_commands.json file produced by any of the common tools to transpile a multi-binary C program.</p><p> 但是，我们快速耗尽了C2rust拦截本机构建过程的方式一个限制：C2rust将编译数据库文件作为输入，其中包含在构建期间执行的编译命令列表。但是，此数据库仅包含编译命令，并且不是任何链接器调用。生成此数据库的最具工具具有此故意的限制，例如CMake_export_compile_Commands，Bear和CompiledB.to的CMake，唯一包含链接命令的工具是来自CodeChecker的构建记录器，我们没有使用，因为我们在编写自己的包装器之后才能学习（下面描述）。这意味着我们无法使用任何常用工具生成的compile_commands.json文件来转换多二进制C程序。 </p><p> Instead, we wrote our own  compiler and  linker wrapper scripts that dump out all compiler and linker invocations to a database, and then convert that into an extended  compile_commands.json. Instead of the normal build using a command like:</p><p>相反，我们编写了自己的编译器和链接包包装脚本，将所有编译器和链接器调用转储到数据库，然后将其转换为扩展的compile_commands.json。使用命令代替正常构建，如：</p><p>    The wrappers produce a directory full of JSON files, one per invocation.A second  script aggregates all of them into a new  compile_commands.json file that contains both compilation and linking commands.We then extended C2Rust to read the linking commands from the database, and produce a separate crate per linked binary.Additionally, C2Rust now also reads the library dependencies of each binary and automatically adds them to that crate’s  build.rs file.</p><p>    包装器生成一个充满JSON文件的目录，每个调用一个目录。第二个脚本将所有这些脚本聚合到包含编译和链接命令的新编译_commands.json文件中。然后，然后扩展C2才能从数据库中读取链接命令，以及每个链接二进制生成单独的箱子.Aditionally，C2Rust现在还读取每个二进制文件的库依赖性，并自动将它们添加到该箱的构建文件中。</p><p> As a quality of life improvement, all of the binaries can be built all at once by having them within a  workspace.C2Rust produces a top-level workspace  Cargo.toml file, so we can build the project with a single  cargo build command in the  quake3-rs directory:</p><p> 作为一种生活质量改进，所有二进制文件都可以通过在Workspace.c2中使它们产生一个顶级工作空间Cargo.toml文件，因此我们可以使用单个货物构建命令构建项目Quake3-RS目录：</p><p> $ tree -L 1.├── Cargo.lock├── Cargo.toml├── cgamex86_64├── ioquake3├── qagamex86_64├── renderer_opengl1_x86_64├── rust-toolchain└── uix86_64$ cargo build --release</p><p> $树-11.├──载荷兰───cargo.toml├── -  qagamex86_64──qagamex86_64├──renderer_opengl1_x86_64──锈 - 工具挂接</p><p>  When we first tried to build the translated code, we hit a couple of issues with the Quake 3 sources, hitting corner cases that C2Rust couldn’t handle (correctly or at all).</p><p>  当我们第一次尝试构建翻译代码时，我们用Quake 3来击中了几个问题，击中了C2Rust无法处理的角壳体（正确或根本）。</p><p>  In a few places, the original source code contains expressions that point one past the last element of an array. Here is a simplified example of the C code:</p><p>  在几个地方，原始源代码包含表达式，该表达式指向阵列的最后一个元素。这是C代码的简化示例：</p><p>  The C standard (see e.g.  C11, Section 6.5.6) allows pointers to an element one past the end of the array. However, Rust forbids this, even if we are only taking the address of the element. We found examples of this pattern in the   AAS_TraceClientBBox function.</p><p>  C标准（参见例如C11，第6.5.6节）允许指向指向阵列结束的元素。但是，即使我们只占用元素的地址，RUDES禁止这一点。我们发现AAS_TRACECLIENDBBOX功能中此模式的示例。 </p><p> The Rust compiler also flagged a similar but actually buggy example in   G_TryPushingEntity where the conditional is  &gt;, not  &gt;=. The out of bounds pointer was then dereferenced after the conditional, which is an actual memory safety bug.</p><p>Rust编译器还在G_TRYPUSHINGINGY中标记了类似但实际的错误示例，其中条件是＆gt;而不是> =。然后在条件后解除界限指针，这是一个实际的内存安全错误。</p><p> To avoid this issue in the future, we fixed the C2Rust transpiler to use pointer arithmetic to calculate the address of an array element instead of using an array indexing operation. With this fix, code that uses this “address of element past the array end” pattern will now correctly translate and run with no modifications necessary.</p><p> 为了避免将来避免这个问题，我们修复了C2Rust Transpiler以使用指针算法来计算数组元素的地址而不是使用数组索引操作。使用此修复程序，使用此“元素地址越过阵列结束”模式的代码现在将正确转换和运行，无需修改。</p><p>  We started up a game to test things out and immediately got a panic from Rust:</p><p>  我们启动了一个游戏来测试事物，并立即从Rust恐慌：</p><p> thread &#39;main&#39; panicked at &#39;index out of bounds: the len is 4 but the index is 4&#39;, quake3-client/src/cm_polylib.rs:973:17</p><p> 线程＆＃39;主要＆＃39;闹剧＆＃39;索引超出界限：LEN为4但索引是4＆＃39 ;,Quake3-Client / SRC / CM_Polylib.rs：973：17</p><p> Taking a look at  cm_polylib.c, we noticed that it was dereferencing the  p field in the following struct:</p><p> 看看CM_Polylib.c，我们注意到它在以下结构中取消了P字段：</p><p>  The  p field in this struct is a pre-C99 non-compliant version of a  “flexible array member” which is still accepted by  gcc.C2Rust recognizes flexible array members with the C99 syntax ( vec3_t p[]) and implements simple  heuristics to also detect some pre-C99 versions of this pattern (0- and 1-sized arrays at the end of structures; we also found a few of those in the ioquake3 source code).</p><p>  该结构中的P个字段是C99仍然接受的“灵活阵列成员”的PE99的非兼容版本，其使用C99语法（VEC3_T P []）识别灵活的阵列成员，并实现简单的启发式检测某些PRE-C99版本的这种模式（结构结束时的0和1大阵列;我们也发现了IOQuake3源代码中的一些。</p><p>   Trying to automatically fix this pattern in the general case (arrays of sizes other that 0 or 1) would be extremely difficult, since we would have to distinguish between regular arrays and flexible array members of arbitrary sizes.Instead, we recommend that the original C code is fixed manually — just like we did for ioquake3.</p><p>   试图在常规情况下自动修复此模式（尺寸为0或1的尺寸阵列）是非常困难的，因为我们必须区分常规阵列和灵活的任意尺寸的阵列成员.Instead，我们建议原始的c代码是手动修复 - 就像我们为Ioquake3做过的那样。 </p><p>  Another source of crashes was this C inline assembly code from the  /usr/include/bits/select.h system header:</p><p>来自/usr/include/bits/select.h系统标题的另一个崩溃源是此C的内联汇编代码：</p><p> # define __FD_ZERO(fdsp) \ do { \ int __d0, __d1; \ __asm__ __volatile__ (&#34;cld; rep; &#34; __FD_ZERO_STOS \ : &#34;=c&#34; (__d0), &#34;=D&#34; (__d1) \ : &#34;a&#34; (0), &#34;0&#34; (sizeof (fd_set) \ / sizeof (__fd_mask)), \ &#34;1&#34; (&amp;__FDS_BITS (fdsp)[0]) \ : &#34;memory&#34;); \ } while (0)</p><p> ＃定义__fd_zero（fdsp）\ do {\ int __d0，__d1; \ __asm___volatile__（＆＃34; cld; rep;＆＃34; __fd_zero_stos \：＆＃34; = c＆＃34;（__d0），＆＃34; = d＆＃34;（__d1）\：＆＃34; A＆＃34;（0），＆＃34; 0＆＃34;（sizeof（fd_set）\ / sizeof（__fd_mask）），\＆＃34; 1＆＃34;（＆amp; __ fds_bits（fdsp）[0]）\ ：＆＃34;记忆＆＃34;）; \}虽然（0）</p><p> which defines the internal version of the  __FD_ZERO macro.This definition hits a rare corner case of  gcc inline assembly:  tied input/output operands with different sizes.The  &#34;=D&#34; (__d1) output operand binds the  edi register to the  __d1 variable as a 32-bit value, while  &#34;1&#34; (&amp;__FDS_BITS (fdsp)[0]) binds the same register to the address of  fdsp-&gt;fds_bits as a 64-bit pointer. gcc and  clang fix this mismatch by using the 64-bit register  rdi instead and then truncating its value before the assignment to  __d1, while Rust defaults to LLVM’s semantics which leave this case undefined.What we saw happening for debug builds (but not release builds, which behaved correctly) was that both operands would be assigned to the  edi register, causing the pointer to be truncated to 32 bits before the inline assembly, which would cause crashes.</p><p> 它定义了__fd_zero宏的内部版本。这个定义命中了gcc内联装配的稀有角色情况：用不同的大小绑定输入/输出操作数。＆＃34; = d＆＃34; （__d1）输出操作数将EDI寄存器绑定到__d1变量作为32位值，而＃34; 1＆＃34; （＆amp; __ fds_bits（fdsp）[0]）将相同的寄存器绑定到fdsp-＆gt的地址; fds_bits作为64位指针。 GCC和Clang通过使用64位寄存器RDI修复此不匹配，然后在分配到__d1之前致致突出其值，而rust默认为LLVM的语义，则将这种情况置于未定义。我们在发生调试构建时看到发生什么（但不是发布构建（表现正确）的是，这两个操作数都将被分配给EDI寄存器，导致指针在内联组合之前将指针截断为32位，这会导致崩溃。</p><p> Since  rustc passes Rust inline assembly to LLVM with very few changes, we decided to fix this particular case in C2Rust.We implemented a new   c2rust-asm-casts crate that fixes the issue above via the Rust type system using a  trait and some helper functions that automatically extend and truncate the values of tied operands to an internal size that is large enough to hold both operands. The code above correctly transpiles to the following:</p><p> 由于Rustc通过很少的变化将Rust Inline汇编程序传递给LLVM，因此我们决定在C2Rust中修复此特殊情况.WE实现了一种新的C2Rust-ASM投递箱，该箱将上面修复上面的问题，使用特征和一些辅助功能将上面的问题修复上面的问题它会自动扩展并截断将绑定操作数的值截断到一个足够大的内部大小，以持有两个操作数。上面的代码正确转换为以下内容：</p><p> let mut __d0: c_int = 0;let mut __d1: c_int = 0;// Reference to the output value of the first operandlet fresh5 = &amp;mut __d0;// The internal storage for the first tied operandlet fresh6;// Reference to the output value of the second operandlet fresh7 = &amp;mut __d1;// The internal storage for the second tied operandlet fresh8;// Input value of the first operandlet fresh9 = (::std::mem::size_of::&lt;fd_set&gt;() as c_ulong).wrapping_div(::std::mem::size_of::&lt;__fd_mask&gt;() as c_ulong);// Input value of the second operandlet fresh10 = &amp;mut *fdset.__fds_bits.as_mut_ptr().offset(0) as *mut __fd_mask;asm!(&#34;cld; rep; stosq&#34; : &#34;={cx}&#34; (fresh6), &#34;={di}&#34; (fresh8) : &#34;{ax}&#34; (0), // Cast the input operands into the internal storage type // with optional zero- or sign-extension &#34;0&#34; (AsmCast::cast_in(fresh5, fresh9)), &#34;1&#34; (AsmCast::cast_in(fresh7, fresh10)) : &#34;memory&#34; : &#34;volatile&#34;);// Cast the operands out (types are inferred) with truncationAsmCast::cast_out(fresh5, fresh9, fresh6);AsmCast::cast_out(fresh7, fresh10, fresh8);</p><p> 让mut __d0：c_int = 0;让mut __d1：c_int = 0; //引用第一个Operandlet的输出值Fresh5 =＆amp; mut __d0; //第一个绑定的操作数的内部存储器为nuckment6; //引用第二个操作数的输出值Fresh7 =＆amp; mut __d1; //第二个绑定的Outmandlet的内部存储Nuckle8; // Fresh_（:: std :: mem :: size_of ::＆lt; fd_set＆gt;（）作为c_ulong）.wrapping_div（:: std :: mem :: size_of ::＆lt; __ fd_mask＆gt; //作为c_ulong）; //第二operandlet的输入值新鲜10 =＆amp; mut * fdset .__ fds_bits.as_mut_ptr （）.offset（0）为* mut__fd_mask; asm！（＆＃34; cld; rep; stosq＆＃34;：＆＃34; = {cx}＆＃34;（fresh6），＆＃34; = { di}＆＃34;（Fresh8）：＆＃34; {ax}＆＃34;（0），//将输入操作数投入内部存储类型//，其中可选的零点或签名 - 扩展＆＃34; 0＆＃34;（ASMcast :: Cast_in（Fresh5，Fresh9）），＆＃34; 1＆＃34;（ASMcast :: Cast_in（Fresh7，Fresh10））：＆＃34;记忆＆＃34;：＆＃34;挥发性＆ ＃34;）; //施放操作数（类型是Infulre d）带TruncationAsmcast :: Cast_out（Fresh5，Fresh9，Fresh6）; AsCascast :: Cast_out（Fresh7，Fresh10，Fresh8）;</p><p> Note that the code above does not require the types for any input or output values in the assembly statement, relying instead on Rust’s type inference to resolve those types (mainly the types of  fresh6 and  fresh8 above).</p><p> 请注意，上面的代码不需要装配声明中的任何输入或输出值的代码，而依赖于RUST的类型推断，以解决这些类型（主要是新鲜的类型和上面的新鲜类型8）。</p><p>  The final source of crashes we encountered was the following global variable that stores a SSE constant:</p><p>  我们遇到的崩溃的最终来源是以下全局变量，存储SSE常量： </p><p>  Rust currently supports the alignment attribute on structure types, but not on global variables, i.e.,  static items.We are looking into ways to solve this in the general case in either Rust or C2Rust, but have decided to fix this issue manually for ioquake3 with a short  patch file for now.This patch file replaces the Rust equivalent of  ssemask with:</p><p>Rust目前支持结构类型上的对齐属性，但不是全局变量，即静态项目。我们正在研究在RUST或C2RUST中的一般情况下解决此问题，但已决定为IOQuake3手动修复此问题现在是一个短补丁文件。此修补程序文件替换SSEMASK的RUST等效项：</p><p> #[repr(C, align(16))]struct SseMask([u8; 16]);static mut ssemask: SseMask = SseMask([ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0,]);</p><p> ＃ ，255,255,0,0,0,0，]）;</p><p>  Running  cargo build --release emits the binaries, but they are all emitted under  target/release using a directory structure that the  ioquake3 binary does not recognize. We wrote a  script that creates symbolic links in the current directory to replicate the correct directory structure (including links to the  .pk3 files containing the game assets):</p><p>  运行Cargo Build --Release发出二进制文件，但它们都使用IoQuake3二进制未识别的目录结构来排除目标/释放。我们写了一个脚本，它在当前目录中创建符号链接以复制正确的目录结构（包括包含游戏资产的.pk3文件的链接）：</p><p>   Now let’s run the game! We need to pass  +set vm_game 0, etc., so that we load these modules as Rust shared libraries instead of QVM assembly, and  cl_renderer to use the OpenGL1 renderer.</p><p>   现在让我们跑游戏！我们需要通过+设置vm_game 0等，以便我们将这些模块加载为生锈共享库而不是QVM程序集，而CL_RENTERER使用OpenGL1渲染器。</p><p> $ ./ioquake3 +set sv_pure 0 +set vm_game 0 +set vm_cgame 0 +set vm_ui 0 +set cl_renderer &#34;opengl1&#34;</p><p> $ ./ioquake3 + set sv_pure 0 + set vm_game 0 + set vm_cgame 0 + set vm_ui 0 + set cl_renderer＆＃34; OpenGL1＆＃34;</p><p>       Here is a video of us transpiling Quake 3, loading the game and playing for a bit:</p><p>       这是我们替代地震3的视频，加载游戏并播放一下：</p><p>  You may browse the  transpiled sources in the  transpiled branch of our repository.We also provide the  refactored branch containing the same  sources with some refactoring commands pre-applied.</p><p>  您可以浏览存储库的转帐分支中的转帐源。我们还提供包含与预先应用的一些重构命令相同的源的重构分支。 </p><p>  If you want to try translating Quake 3 and run it yourself, please be aware that you will need to own the original Quake 3 game assets or download the demo assets from the web. You’ll also need to install C2Rust (the required Rust nightly version at the time of writing is  nightly-2019-12-05, but we recommend you check the C2Rust  repository or  crates.io for the latest one):</p><p>如果您想尝试翻译Quake 3并自己运行它，请注意您需要拥有原始的Quake 3游戏资产或从Web下载演示资产。您还需要安装C2Rust（写作时所需的Rust夜间版本是2019-12-05夜间，但我们建议您查看最新的C2Rust存储库或箱子。</p><p>    As an alternative to installing  c2rust with the command above, you may build C2Rust manually using  cargo build --release. In either case, the C2Rust repository is still required as it contains the compiler wrapper scripts that are required to transpile ioquake3.</p><p>    作为使用上述命令安装C2Rust的替代方案，您可以使用货物构建手动构建C2Rust。在任何一种情况下，仍然需要C2Rust存储库，因为它包含要转换IoQuake3所需的编译器包装脚本。</p><p> We provide a  script that automatically transpiles the C code and applies the  ssemask patch. To use it, run the following command from the top level of the  ioq3 repository:</p><p> 我们提供了一个自动转换C代码并应用SSemask修补程序的脚本。要使用它，请从IOQ3存储库的顶级运行以下命令：</p><p>  This command should produce a  quake3-rs subdirectory containing the Rust code, where you can subsequently run  cargo build --release and the rest of the steps described earlier.</p><p>  此命令应生成包含生锈代码的Quake3-RS子目录，其中您可以随后运行Cargo Build  - 释放和其余步骤。</p><p>  As we continue to develop C2Rust, we’d love to hear what you want to see translated next. Drop us a line at   [email protected] and let us know! If you have legacy C code you need modernized and translated, the team here at Immunant is here to help. We are available for consulting and contracting engagements ranging from one-time support to full-service code modernization.</p><p>  随着我们继续开发C2Rust，我们很乐意听到你想看到的内容。在[电子邮件受保护]下给我们一条线，让我们知道！如果您有传统的C代码，您需要现代化和翻译，则此处的团队在此处都是帮助。我们可用于从一次性支持到全方位服务代码现代化的一次咨询和签订订婚。</p><p> Thanks to David Dubois for correcting our understanding of the GLSL build process.  ↩︎</p><p> 感谢David Dubois来纠正我们对GLSL构建过程的理解。 ↩︎ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://immunant.com/blog/2020/01/quake3/">https://immunant.com/blog/2020/01/quake3/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/翻译成/">#翻译成</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/quake/">#quake</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>