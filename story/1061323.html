<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>x86堆栈是钟乳石 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">x86堆栈是钟乳石 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-08 00:17:30</div><div class="page_narrow text-break page_content"><p>一旦一些程序员对堆在x86上的方向混淆了，我不止一次注意到＆＃34;堆栈＆＃34的顶部;和＃34;堆栈的底部＆＃34;吝啬的。看来，这种混乱是由人们习惯于思考堆栈的基本不匹配引起的，并且在X86上的堆栈实际上表现出[1]。</p><p>  回到基础知识。堆栈类比有时会向新生用一堆板计算。您将板推到堆栈上并从堆叠中弹出一盘。堆栈的顶部是推动时的下一盘的位置，以及在弹出时拍板的地方。</p><p> 在计算机中，堆栈通常是特殊处理的内存区域。在抽象的意义上，类比适用 - 通过将数据放在堆栈的顶部，并通过从堆栈的顶部置于堆栈的顶部来推送数据。请注意，此并不是解决堆栈顶部位于内存中的问题的问题。</p><p> 这里介绍了混乱的来源。英特尔＆＃39; s x86架构将其堆栈＆＃34置于＆＃34;它从某些地址开始，并将降至较低的地址。在这里＆＃39;它看起来如何：</p><p>  所以，当我们说＆＃34;堆栈的顶部＆＃34;在X86上，我们实际上是堆栈占用的内存区域中的最低地址。这对某些人来说可能是不自然的[2]。只要我们坚定地保持上面的图表，我们应该没问题。</p><p> 虽然我们＆＃39;在它，让＆＃39; s看x86装配编程映射的一些常见习语如何在该图形表示。</p><p> X86架构保留一个用于使用堆栈 -  ESP（扩展堆栈指针）的特殊寄存器。按定义，eSP始终指向堆栈的顶部： </p><p>在此图中，地址0x9080abcc是堆栈的顶部。位于它的词是一些＆＃34; foo＆＃34;而esp包含0x9080abcc的地址 - 换句话说，指向它。</p><p> 要将新数据推到堆栈上，我们使用推送指令[3]。什么推动是第一次递减4，然后将其操作数存储在eSP点。所以这：</p><p>    以前的图表作为起点，并假设EAX保持尊重0xdeadbeef，推动堆栈后将如下所示：</p><p>  同样，POP指令取下堆叠顶部的值，并将其放置在其操作数中，然后增加堆栈指针。换句话说，这是：</p><p>    因此，再次，以前的图表（按下推送后）作为起点，Pop EAX将执行以下操作：</p><p>  值0xdeadbeef将被写入EAX。请注意，0xDeadBeef还留在地址0x9080abc8，因为我们没有什么可以覆盖它。</p><p> 在从C生成的汇编代码时，您会发现很多有趣的模式。也许最识别的模式是参数使用堆栈传递到函数的方式，局部变量在堆栈上分配的方式[4]。 </p><p>int foobar（int a，int b，int c）{int xx = a + 2; int yy = b + 3; int zz = c + 4; int = xx + yy + zz;返回xx * yy * zz + sum;} int main（）{返回foobar（77,88,99）;}</p><p> 传递给Foobar的参数和该功能的局部变量以及一些其他数据，当调用foobar时，将存储在堆栈上。堆栈上的这组数据被称为此功能的帧。就在返回声明之前，foobar的堆栈框如下所示：</p><p>  通过呼叫功能将绿色数据按压到堆叠上，并通过Foobar本身推出蓝色。</p><p>   为Foobar生成以下装配列表。我评论了很容易理解：</p><p> _Foobar：; EBP必须在呼叫中保留。自从  ;这个功能改变了它，它必须是;保存。 ;推ebp;从现在开始，EBP指向当前堆栈;函数的框架; MOV EBP，ESP;为局部变量置于堆栈上的空间; Sub ESP，16; eax＆lt; a。 EAX + = 2.然后在XX中存储EAX; MOV EAX，DWORD PTR [EBP + 8]添加EAX，2 MOV DWORD PTR [EBP-4]，EAX; eax＆lt; b。 eax + = 3.然后在yy储存eax; MOV EAX，DWORD PTR [EBP + 12]添加EAX，3 MOV DWORD PTR [EBP-8]，EAX; eax＆lt; c。 EAX + = 4.然后在ZZ存储EAX; MOV EAX，DWORD PTR [EBP + 16]添加EAX，4 MOV DWORD PTR [EBP-12]，EAX;添加xx + yy + zz并存放在一起; MOV EAX，DWORD PTR [EBP-8] MOV EDX，DWORD PTR [EBP-4] LEA EAX，[EDX + EAX] ADD EAX，DWORD PTR [EBP-12] MOV DWORD PTR [EBP-16]，EAX;将最终结果计算为EAX;留在那里直到回来; MOV EAX，DWORD PTR [EBP-4] IMUL EAX，DWORD PTR [EBP-8] IMUL EAX，DWORD PTR [EBP-12]添加EAX，DWORD PTR [EBP-16];这里的假说明等同于：; ; MOVES ESP，EBP; POP EBP; ;它清理分配的当地人并恢复; ebp。 ;离开et.</p><p> 由于ESP随着函数执行而导致的，因此使用EBP（基本指针，也称为其他架构中的帧指针）用作相对于哪个函数参数和当地人可以找到的方便锚。参数在堆栈中的EBP上方（因此访问它们时的正偏移），而当地人在堆栈中的EBP下方。</p><p>  它不应帮助一些在线资源错误地称之为堆栈的顶部＆＃34;底部＆＃34;。此处呈现的版本是X86中的正确之一，因为它依赖于英特尔＆＃39; s x86架构手册中定义的术语。 </p><p>您可以尝试通过查看内存以底部顶部和高地址的低地址查看内存来解决混淆。 虽然这确实使堆叠运动更加自然，但它也意味着增加一些内存地址将在图形表示中将其缩小，这可能更加反向直观。  有几条指令x86在＆＃34中定义;推动家庭＆＃34; 我＆＃39; m展示推动以来是最简单，最普遍适用的推动。  当然，这仅适用于某些呼叫约定和架构。 在其他方面，一些参数在寄存器中传递。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://eli.thegreenplace.net/2011/02/04/where-the-top-of-the-stack-is-on-x86/">https://eli.thegreenplace.net/2011/02/04/where-the-top-of-the-stack-is-on-x86/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/堆栈/">#堆栈</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/stack/">#stack</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1060507.html"><img src="http://img2.diglog.com/img/2021/5/thumb_f68bed3394fe51807012b5c95649c3d4.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1060507.html">堆栈预算 - 一系列服务与自由级 </a></div><span class="my_story_list_date">2021-5-5 20:26</span></div><div class="col-sm"><div><a target="_blank" href="/story/1053037.html"><img src="http://img2.diglog.com/img/2021/3/thumb_34f9fe32ee0842459ccae0f130cd6af5.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1053037.html">团队的堆栈溢出现在是最多50个用户的自由 </a></div><span class="my_story_list_date">2021-3-17 23:54</span></div><div class="col-sm"><div><a target="_blank" href="/story/1048228.html"><img src="http://img2.diglog.com/img/2021/2/thumb_3701861af2c7e4c6db920260ca476daa.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1048228.html">堆栈谬误-在堆栈上进行创新更容易 </a></div><span class="my_story_list_date">2021-2-18 17:50</span></div><div class="col-sm"><div><a target="_blank" href="/story/1048041.html"><img src="http://img2.diglog.com/img/2021/2/thumb_d618bd3a6ae46434d0bdb855ad53fe1b.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1048041.html">Forth：黑客的语言（2017） </a></div><span class="my_story_list_date">2021-2-18 0:44</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>