<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Futhark和Dex的比较 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Futhark和Dex的比较 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-29 01:52:11</div><div class="page_narrow text-break page_content"><p>Dex是Google的一组研究人员开发的一种功能数组编程语言。最近，我重新阅读了他们的论文，这让我很兴奋，想仔细看看。 Dex和Futhark或多或少地针对相同类型的问题，因此我对Dex的解释植根于它与Futhark的不同之处。在这篇文章中，我将基于将五个Dex示例程序翻译为Futhark来描述一些有趣的区别。我不是敏捷专家，所以也许我错过了这里或那里的东西。</p><p> Futhark最初并不是设计成面向用户的编程语言。我们正在针对并行计算机的编译器优化进行研究，而该语言只是一件简陋的小事，因此我们可以编写程序供优化器使用。随着时间的流逝，语言逐渐发展起来，最终变得相当令人愉悦（此处为全文），但它仍然从未被设计为结合或新颖的数组编程方法。这也意味着，随着函数式语言的发展，它已经相当传统甚至过时了。相比之下，Dex的作者具有更多的想象力，并从一开始就用新颖的想法设计了他们的语言，其主要思想是将索引集视为类型。为了说明这一点，这里是如何计算Dex中所有对L₁距离的方法：</p><p> pairwiseL1 :: n =＆gt; d =＆gt; Real-＆gt; n => n => RealpairwiseL1 x =对于i j.sum（对于k。abs（x.i.k-x.j.k））</p><p> n ＝＞ d ＝＞ Real是n乘d的实数数组的类型。 Dex在很大程度上依赖于数组和函数之间的类比，因为数组可以看作仅仅是从索引到值的函数。在Futhark中，我们将此类型写为[n] [d] Real。请注意，在Dex中，n和d是完全抽象的类型参数，而在Futhark中，它们是术语级变量。</p><p> Dex方法的真正优点是它允许对索引空间使用非常轻量级的符号。例如，对于i j，e生成一个二维数组，其中每个元素都由表达式e给出，类型检查器根据上下文确定i和j的范围。例如，在for k中，Dex指出k必须是索引集d的一部分，因为它用于索引x的最内维度。太酷了！</p><p>  让pairwiseL1 [n] [d]（x：[n] [d] f64）=表格2d nn（\ ij-> f64.sum（表格d（\ k-> x [i，k]-x [ j，k]）））</p><p> 请注意，制表函数需要显式的大小传递，并且索引仅是整数-如果我们不小心沿错误的维度使用k，则类型检查器将无济于事。 </p><p>当然，以上并不是您实际在Futhark中编写此程序的方式。相反，您首先要定义一个用于计算L₁距离的函数：</p><p> 令L1 [n]（xs：[n] f64）（ys：[n] f64）：f64 ＝ map2（-）xsys |＞。映射f64.abs |＆gt; f64.sum</p><p>  让pairwiseL1 [n] [m]（xss：[n] [m] f64）：[n] [n] f64 = map（\ a-> map（\ b-> L1 a b）xss）xss</p><p> 我认为该程序说明了Dex和Futhark之​​间在哲学上的主要区别。尽管Dex使用依赖类型来保护基于索引的表示法，但Futhark鼓励使用无索引编程。我怀疑这两种方法在根本上是等效的，但是我认为这是一个有趣的对比，原因是两种语言的背景不同。 Dex专为实现科学的代码和公式而设计，而科学的代码和公式在传统上非常面向索引。 Futhark的主要目的是支持基于“传统”组合器的函数式编程风格，但仅仅是使其运行速度更快。您可以将Futhark视为数据并行ML，而Dex是高阶依赖类型的爱因斯坦求和。</p><p> 我也怀疑这种对索引的关注是因为Dex作者的背景是对NumPy风格的编程感到沮丧，在这种情况下，缺乏有效的索引可能会造成很大的限制。他们甚至在论文中将L₁距离的NumPy实现用作动机：</p><p>    将两行Dex程序移植到Futhark足以在哲学上修饰一两段，但这仍然是一个比较浅的比较。因此，我还移植了五个Dex示例程序，以及在此过程中需要的所有Dex前奏。我不会声称我已移植了五个最困难的程序，但其中至少有一个非常复杂。 Futhark程序总共约450行代码（不包括注释和空格）。</p><p> 我的总体印象是，在表达并行性时，Dex和Futhark差不多。 Dex的索引符号更简洁，但我个人认为它更易于理解和分解Futhark表达式。例如，此Dex函数计算矩阵的协方差： </p><p>def covariance（n：Type）？-> （d：Type）？-＆gt; （xs：n =＆gt; d =＆gt; Float）：（d =＆gt; d =＆gt; Float）= xsMean：d =＆gt; Float =（对于i。j。 n）xsCov：d =＆gt; d =＆gt; Float =（对于i i＆＃39; .j的总和（xs.j.i＆＃39;-xsMean.i＆＃39;）*（xs.ji-xsMean .i））/ IToF（大小n-1）xsCov</p><p>  让covariance0 [n]（xs：[n] f64）（xsm：f64）（ys：[n] f64）（ysm：f64）= f64.sum（map2（\ xy-＆gt;（x-xsm）*（ y-ysm））xs ys）/ f64.i64（n -1）让协方差[n] [d]（xs：[n] [d] f64）=让xsT =转置xs让均值=地图均值map2中的xsT （\ a a_mean-> map2（\ b b_mean-> covariance0 a a_mean b b_mean）xsT表示）xsT表示</p><p> 当然，它比较冗长，但是我必须仔细阅读Dex函数才能理解索引的含义，而我却更容易理解Futhark公式的计算结构。当然，与Dex相比，我在Futhark方面也有多年的经验。</p><p> 大多数翻译非常简单，例如Mandelbrot集，Monte Carlo pi和Brownian运动程序。让我感到非常嫉妒的一个区别是，dex脚本命令还能够生成令人愉悦的报告，其中包含代码以及各种值的可视化效果和图形。我们绝对需要这样的工具才能用于Futhark！</p><p> Sierpinski三角程序在Dex中有一个有趣的小细节，那就是randIdx函数使用Dex类型系统来确定所生成索引的范围。尽管randIdx函数本身仍然可能是错误的，但这使得难以正确使用它。 randIdx的Futhark转换要求用户显式传递范围，并且仅返回整数。</p><p>  到目前为止，最大的移植示例是光线跟踪器。它使用带有标志距离函数的光线行进来描述对象。 Dex程序相当随意地使用grad运算符应用自动微分（AD）来从距离函数计算表面法线。这是一种非常优雅的技术，但是Futhark（尚未！）没有Grad运算符。在Futhark中，明智的做法是对三种不同类型的对象的梯度函数进行硬编码，因此，我当然使用通过Futhark模块系统实现的具有双数的正向模式AD。最终的代码最终使我确信，内置AD是现代数字语言的必要条件。以前，我一直处于困境，因为我担心做得好对语言和编译器都具有侵入性，但是我再也不想写这种样板了。</p><p> 射线追踪器的其余部分非常容易实现。 Dex使用其效果系统来实现循环，其中场景中的灯光将其贡献应用于给定点，这在我在Futhark中基本上是折叠的。实际上，我还没有找到Dex的示例，该示例中的效果系统不仅仅是一个小的符号上的便利。我敢肯定有一个！效果系统不是您刚刚添加的东西。 </p><p>最初有一部分让我感到困惑，但是回想起来，这很有意义。光线追踪器会根据平均强度（我认为是异常，但很好）对所有像素（三重浮子）的强度进行归一化。在Dex中，这样做是这样的：</p><p>  初读这篇文章时，我无法弄清楚它是否对每个频道都正常。当涉及到这样的重载运算符时，我总是会有些警惕。当然，该表达式是一个单一索引，而该索引恰好是三重索引，然后使用该索引的组件对三维图像阵列进行索引。它实际上只是使数组变平，并且类型检查器使各个i，j和ks取适当的值。</p><p>  关于表达并行性，Dex和Futhark在表达能力上似乎是等效的，但是Dex在简洁方面具有优势。我很好奇，反而将一些原始的Futhark基准程序移植到Dex，例如本地体积校准。</p><p> 与Futhark相比，Dex有几个小方便之处：虽然效果系统对我看过的示例并没有多大影响，但Dex的类型类和广播运营商确实在使事情变得更简洁方面有所帮助。</p><p> 如果您需要AD，那么Dex比Futhark领先几英里。当我设法在光线跟踪器中实现表面法线时，我放弃了移植mcmc.dx，因为它包含将grad运算符应用于函数自变量的高阶函数。这必须使用更高阶的参数模块来实现（我不久前写的没用），但我只是没有心。我将在适当实施AD时将其作为用例。</p><p> 我对性能没什么要求，因为Dex的文档很少，基准测试工具似乎主要供内部使用。我对光线追踪器的顺序执行进行了大致计时，其中Futhark和Dex版本的速度差不多。 Dex还具有多线程和CUDA后端，但是我没有尝试。</p><p> 说到稀疏的文档，Dex还很年轻，并且似乎经常变化。我的理解是基于本文的内容，阅读示例程序，并浏览了一些实现。我可能错过了重要的细节，并且在您阅读本文时，该帖子甚至可能已过时。 </p><p>我认为无需花费太多精力让Futhark在尺寸方面更加隐性。一个简单的开始就是允许返回大小的多态性，这将使我们编写具有以下类型的表格函数：</p><p>  当前，Futhark类型检查器禁止仅在负位置使用尺寸参数。这种限制主要是因为我自己实现了大小类型系统，并且由于我几乎没有实现依赖类型系统的经验，所以我担心无意间接受了不合理的结构（更实际的是，我担心实现中的错误）。我将其锁定的程度超出了绝对必要的范围。如果我们想支持这种结果大小推断，那么我们确实需要弄清楚如何处理像</p><p>  在此，表格的大小必须是filter返回的数组的大小，该数组是存在的。据我所知，Dex不允许上述表达式，因为它以常规和显式的方式处理存在性：</p><p>  大概是由用户根据需要对存在的上下文进行解包。在Futhark中，我想保留“直接样式”编程，因此您可以编写诸如map f（过滤器p xs）之类的表达式，在该表达式中编译器会为您隐式解压缩存在的上下文，但代价可能会太大。</p><p> 我认为某种程度的Dex的类型安全索引几乎可以在Futhark中实现，特别是如果我们放松了上述限制，即必须在参数中使用大小参数。我们已经有一个示例，其中“幻像大小”用于实现三角形阵列。也许Futhark应该在依赖类型的方向上走得更多？不幸的是，我们是一个小团队，因为花费大量时间来撰写有关使该语言逐渐发展的论文。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://futhark-lang.org/blog/2020-12-28-futhark-and-dex.html">https://futhark-lang.org/blog/2020-12-28-futhark-and-dex.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/futhark/">#futhark</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>