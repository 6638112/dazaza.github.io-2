<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用C++作为脚本语言：静态类型检查函数</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">使用C++作为脚本语言：静态类型检查函数</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-12 04:58:41</div><div class="page_narrow text-break page_content"><p>If you’re wondering what’s going on here, check out my previous musings on this subject:  Using Fast Virtual Machines In A Game Engine</p><p>如果你想知道这里发生了什么，看看我之前对这个主题的思考：在游戏引擎中使用快速虚拟机。</p><p> These writings have continously gotten more and more complex, so I don’t blame anyone for getting lost in the sea of words down below.</p><p>这些文字不断地变得越来越复杂，所以我不会责怪任何人迷失在下面的文字海洋中。</p><p>  If we are going to add a group of functions to   a guest dynamically, we will have to make sure that the overhead is low and that there is no room for collisions with other functionality. So, if you want to extend the guest environment by adding a new system call, then the system call number you choose must be unique each time, and both sides have to know about this number somehow. You also have to permanently use that number for this feature now, forever. Except, what if you could just pick any free system call number, and both sides would just use that, unknowingly?</p><p>如果我们要向来宾动态添加一组功能，则必须确保开销较低，并且不存在与其他功能冲突的空间。因此，如果您希望通过添加新的系统调用来扩展来宾环境，那么您选择的系统调用号每次都必须是唯一的，并且两端都必须以某种方式知道该编号。您还必须从现在到永远永久使用该号码才能使用此功能。除了，如果你可以选择任何免费的系统呼叫号码，而双方都会在不知情的情况下使用这个号码，那会怎么样？</p><p> While this is possible, and I did implement a solution that took free system call numbers and wrote them into guest memory, forming trampoline functions for this new functionality, it actually turns out that simply using one system call backed by a hash map is faster. Oh well. The reason is fairly straight-forward: When you assign a memory range to a certain purpose, and then group it into group ids and indexes within that again, you have to do a lookup. Might as well just look up a hash.</p><p>虽然这是可能的，而且我确实实现了一个解决方案，将免费的系统调用号写入客户内存，为这个新功能形成蹦床函数，但事实证明，简单地使用一个有散列映射支持的系统调用会更快。哦，好吧。原因相当简单：当您将一个内存范围分配给某个特定用途，然后再次将其分组为组ID和其中的索引时，您必须进行查找。还不如直接查个哈希表。</p><p> So, let’s have a look at the feature itself. We need to be able to define a function by type, and give it a name. Let’s look at the simplest example:  Stopping a timer.</p><p>那么，让我们来看看这个功能本身。我们需要能够按类型定义函数，并为其命名。让我们看一个最简单的例子：停止计时器。</p><p>  We define a function stop_timer which performs the dynamic call named “timer_stop”. It has the function type given by the template parameter, and the instantiation creates a callable object. Calling it with an integer will stop the given timer, provided there is a handler for “ timer_stop” in the game engine.</p><p>我们定义了一个函数Stop_Timer，它执行名为“Timer_Stop”的动态调用。它具有由模板参数指定的函数类型，并且实例化创建了一个可调用对象。如果游戏引擎中有“TIMER_STOP”的处理程序，用整数调用它将停止给定的计时器。</p><p> On the host side we hook up a handler for “ timer_stop” like so:</p><p>在主机端，我们为“Timer_Stop”连接了一个处理程序，如下所示：</p><p>  Notice the capturing of  timers by reference. The sysargs template call takes each template argument and figures out which register it must come from based on the C calling convention, and puts it into the correct tuple index in the return value. Zero overhead, of course.</p><p>请注意通过引用捕获计时器。Sysargs模板调用获取每个模板参数，并根据C调用约定确定它必须来自哪个寄存器，然后将其放入返回值中正确的元组索引中。当然是零开销。</p><p> This system uses CRC32 checksums of strings to avoid string comparisons. We can do those at compile-time in the script using C++. When the hashes are being added we also check for collisions, removing a potential headache that way, however unlikely it is. The polynomial used for checksumming is a template parameter on both sides, so if a collision actually happens, simply changing it can resolve it.</p><p>该系统使用字符串的CRC32校验和来避免字符串比较。我们可以在编译时使用C++在脚本中完成这些操作。当添加散列时，我们还会检查冲突，这样就消除了一个潜在的麻烦，尽管这不太可能。用于校验和的多项式是两侧的模板参数，因此如果实际发生冲突，只需更改它即可解决问题。</p><p> template &lt;typename Func&gt; struct Call {  const uint32_t hash;  constexpr Call(const char* f) : hash(crc32(f)) {}  constexpr Call(uint32_t h) : hash(h) {}  template &lt;typename... Args&gt;  auto operator() (Args... args) const {  static_assert( std::is_invocable_v&lt;Func, Args...&gt; );  using Ret = typename std::invoke_result&lt;Func, Args...&gt;::type;  using FCH = Ret(*)(uint32_t, Args...);  auto fch = reinterpret_cast&lt;FCH&gt; (&amp;dyncall_helper);  return fch(hash, args...);  } };</p><p>模板&lt；TypeName函数&&gt;结构调用{const uint32_t hash；stexpr调用(const char*f)：hash(crc32(F)){}stexpr调用(Uint32_T H)：hash(H){}模板&lt；typeName...。参数&&gt;自动操作员()(参数...。Args)const{Static_Assert(std：：is_invocable_v&lt；Func，args...&gt；)；Using Ret=TypeName std：：Invoke_Result&lt；Func，args...&gt；：：type；Using Fch=Ret(*)(uint32_t，args...)；AUTO FCH=重新解释_CAST&lt；FCH&gt；(&amp；dyncall_helt；(&amp；dyncall_helg；)。</p><p> The actual implementation is fairly voodoo. We create a callable object with the function type as template argument. The callable makes sure that the arguments passed to it matches the function type, which serves as static type checking. Then, we create a C function call that has our hash baked into it, feeding it into a trampoline function. On the host side we are then able to read these same arguments out, as if it was a C function call. Fairly neat, actually.</p><p>实际的实施相当像巫毒。我们使用函数类型作为模板参数创建一个可调用对象。Callable确保传递给它的参数与函数类型匹配，这用作静态类型检查。然后，我们创建一个C函数调用，其中包含我们的散列，并将其提供给蹦床函数。然后，在主机端，我们可以读出这些相同的参数，就好像它是一个C函数调用一样。实际上，相当整洁。</p><p>  Using a shared system call number for all dynamic calls, backed by a CRC32 hash value yielded decent results: The median call was effectively 13ns, on my machine. There is performance overhead associated with using std::function and a hash lookup, however implementors always have the option of using system calls directly, which has a fixed 3ns overhead.</p><p>在CRC32散列值的支持下，对所有动态调用使用一个共享的系统调用编号可以得到不错的结果：在我的机器上，调用的中位数实际上是13 ns。使用std：：Function和散列查找存在相关的性能开销，但是实现者总是可以选择直接使用系统调用，这具有固定的3 ns开销。</p><p>  A remote call is just one virtual machine calling into another, more or less directly.</p><p>远程调用只是一个虚拟机或多或少直接调用另一个虚拟机。</p><p> When you execute a function remotely (in another machine) it’s not without caveats. For example, you can’t pass a reference to a local object without it being accessible through a shared memory area. That requires coordination and helper tools. It also means recursive remote calls will not work. It can be bearable, but what if there was a way to mount the stack of one machine into another just for a remote call?</p><p>当您远程(在另一台机器上)执行一个函数时，也不是没有注意事项。例如，如果不能通过共享内存区访问本地对象，则不能传递对该对象的引用。这需要协调和辅助工具。这也意味着递归远程调用将不起作用。这是可以忍受的，但如果有一种方法可以仅仅为了远程调用而将一台机器的堆栈挂载到另一台机器上，情况会怎样呢？</p><p> If the remote machine is running the same binary as in the caller you can also use read-only static data and code: Strings, constants, functions etc.</p><p>如果远程计算机运行的是与调用方相同的二进制文件，则还可以使用只读静态数据和代码：字符串、常量、函数等。</p><p> It is possible to make the stack from one machine available in another provided they lie in different places in memory. So, when you make a remote call, all you have to do is mount the stack of the caller machine into the remote machine for the duration of the call. Except, that you don’t have to mount all of it. The stack pointer tells you where the current “top” is, and not only that, but you only need the mount the stack if one of the integer registers passed to the remote machine contains a value that is within that area.</p><p>如果堆栈位于内存中的不同位置，则可以使来自一台计算机的堆栈在另一台计算机上可用。因此，当您进行远程调用时，您所要做的就是在调用期间将调用方机器的堆栈挂载到远程机器中。只是，你不需要把所有的东西都装上。堆栈指针告诉您当前的“顶部”在哪里，不仅如此，而且仅当传递到远程机器的一个整数寄存器包含位于该区域内的值时，才需要挂载堆栈。</p><p> Using these ideas we can put together direct C++ function calls from one machine and into a remote machine, with very low overhead. No copying, no extra cost when the stack isn’t in use. Using the same things we learned from dynamic function calls we can make farcalls type-safe too:</p><p>使用这些想法，我们可以将来自一台机器的直接C++函数调用整合到远程机器中，并且开销非常低。当堆栈不使用时，无需复制，无需额外费用。使用我们从动态函数调用中学到的相同内容，我们也可以使FarCall成为类型安全的：</p><p>  In the example above we had to specify the type of the function, for type safety and using the correct ABI when making the call. There’s an optimization for when you are running the same binary, which allows you to avoid having to specify the function type as well:</p><p>在上面的例子中，为了类型安全和调用时使用正确的ABI，我们必须指定函数的类型。当您运行相同的二进制文件时，有一个优化，使您不必同时指定函数类型：</p><p>  The difference is that we point to the function directly, and from that we can see the return value and arguments, as well as the address. We don’t have to lookup the functions address when we already have it. The name  gameplay2 dynamically refers to a machine. Another difference, and potential benefit, is not having to use the C calling convention. The call will be invoked as a regular C++ function call.</p><p>不同之处在于我们直接指向该函数，从中我们可以看到返回值和参数以及地址。当我们已经拥有函数地址时，我们不必查找它。名称Gameplay2动态地指的是机器。另一个不同之处和潜在的好处是不必使用C调用约定。该调用将作为常规的C++函数调用来调用。</p><p>  constexpr ExecuteRemotely somefunc(&#34;gameplay2&#34;, some_function); SomeStruct some {  .string = &#34;Hello 123!&#34;,  .value = 42 }; int r = somefunc(1234, some);</p><p>Constexpr Execute Remotely Somefunc(&#34；Gameplay2&34；，Some_Function)；SomeStruct{.string=&#34；Hello 123！&#34；，.value=42}；int r=Somefunc(1234，Some)；</p><p>  long some_function(int value, SomeStruct&amp; some) {  print(&#34;Hello Remote World! value = &#34;, value, &#34;!\n&#34;);  print(&#34;Some struct string: &#34;, some.string, &#34;\n&#34;);  print(&#34;Some struct value: &#34;, some.value, &#34;\n&#34;);  return value; }</p><p>Long Some_Function(int value，SomeStruct&amp；Some){Print(&#34；Hello Remote World！)。Value=&#34；，value，&#34；！\n&#34；)；print(&#34；，ome.string，&#34；；\n&#34；)；print(&#34；，ome struct value：&#34；，ome.value，&#34；\n&#34；)；返回值；}。</p><p> And that data will be visible as-is on the remote machine, as seen in the logs:</p><p>该数据将在远程计算机上按原样显示，如日志中所示：</p><p> &gt;&gt;&gt; [gameplay2] says: Hello Remote World! value = 1234! &gt;&gt;&gt; [gameplay2] says: Some struct string: Hello 123! &gt;&gt;&gt; [gameplay2] says: Some struct value: 42</p><p>&gt；&gt；&gt；[gameplay2]说：你好，远程世界！Value=1234！&gt；&gt；&gt；[gameplay2]表示：某个结构字符串：Hello 123！&gt；&gt；&gt；[gameplay2]表示：某个结构值：42。</p><p> Because the function is directly referenced in the code it does not need to be made a public function, nor does it need to be added to the file containing public symbols.</p><p>因为该函数是在代码中直接引用的，所以不需要将其设置为公共函数，也不需要将其添加到包含公共符号的文件中。</p><p> There is one huge gotcha with the remote function calls that reference a function directly: We do  NOT cast the trampoline function to a C function call. It is still a C++ function call. That means you cannot remotely call a C function, unless you perhaps added a template argument like  bool cxx = true. I don’t know if you can actually determine the calling convention of a function you are referencing. That said, when referencing a function by string name, the function name must not be mangled, and we can assume it’s a C function call.</p><p>直接引用函数的远程函数调用有一个巨大的缺陷：我们不会将蹦床函数强制转换为C函数调用。它仍然是一个C++函数调用。这意味着您不能远程调用C函数，除非您添加了类似bool cxx=true的模板参数。我不知道您是否真的能确定您引用的函数的调用约定。也就是说，当通过字符串名引用函数时，函数名不能被损坏，我们可以假定这是一个C函数调用。</p><p> That is all I have, for now. I recently tried to compare some of these modern interpreted languages and web assembly emulators, and I noticed that the APIs you are forced to deal with to build your own APIs between the host and guest is simply horrid. Hopefully this will give some ideas to the implementors out there of these well known projects.</p><p>就目前而言，这就是我的全部。我最近试着比较了一些现代解释语言和Web汇编仿真器，我注意到你不得不处理的在主机和来宾之间构建自己的API的API实在是太可怕了。希望这能为这些知名项目的实现者提供一些想法。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fwsgonzo.medium.com/using-c-as-a-scripting-language-part-3-b8f92206ef94">https://fwsgonzo.medium.com/using-c-as-a-scripting-language-part-3-b8f92206ef94</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/scripting/">#scripting</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/调用/">#调用</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033142.html"><img src="http://img2.diglog.com/img/2020/11/thumb_ad5dde69220f35f61644221576412388.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033142.html">亲爱的ImGUI-C++的无膨胀图形用户界面库</a></div><span class="my_story_list_date">2020-11-4 15:53</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031721.html"><img src="http://img2.diglog.com/img/2020/10/thumb_aba3b14cf0884d71ae87f3d037c7a5ba.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031721.html">.NET比C++快，在GRPC_BENCH中下围棋</a></div><span class="my_story_list_date">2020-10-28 15:33</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031196.html"><img src="http://img2.diglog.com/img/2020/10/thumb_a905b29390816d4809e71e71b22214a4.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031196.html">Single_file_libs：单文件C/C++库列表</a></div><span class="my_story_list_date">2020-10-26 12:54</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031179.html"><img src="http://img2.diglog.com/img/2020/10/thumb_3884453f3945027ebd4444634fa4c369.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031179.html">不，C++仍然不支持</a></div><span class="my_story_list_date">2020-10-26 10:56</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>