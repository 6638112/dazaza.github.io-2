<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>systemd：引导加载程序规范 systemd: Boot Loader Specification</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">systemd: Boot Loader Specification<br/>systemd：引导加载程序规范 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-26 06:27:13</div><div class="page_narrow text-break page_content"><p>TL;DR: Currently there’s no common boot scheme across architectures andplatforms for open-source operating systems. There’s also little cooperationbetween multiple distributions in dual-boot (or triple, … multi-boot)setups. We’d like to improve this situation by getting everybody to commit to asingle boot configuration format that is based on drop-in files, and thus isrobust, simple, works without rewriting configuration files and is free ofnamespace clashes.</p><p>TL; DR：目前，针对开源操作系统的体系结构和平台还没有通用的启动方案。在双启动（或三重启动，…多重启动）设置中，多个发行版之间也几乎没有合作。我们希望通过使每个人都致力于基于嵌入式文件的单一引导配置格式来改善这种情况，从而使鲁棒，简单，无需重写配置文件即可工作，并且不会出现命名空间冲突。</p><p> The Boot Loader Specification defines a scheme how different operating systemscan cooperatively manage a boot loader configuration directory, that acceptsdrop-in files for boot menu items that are defined in a format that is sharedbetween various boot loader implementations, operating systems, and userspaceprograms. The same scheme can be used to prepare OS media for cases where thefirmware includes a boot loader. The target audience for this specification is:</p><p> 引导加载程序规范定义了一种方案，该模式如何不同的操作系统如何协同管理引导加载程序配置目录，该目录接受用于以各种引导加载程序实现，操作系统和用户空间程序之间共享的格式定义的引导菜单项的插入文件。对于固件包括引导加载程序的情况，可以使用相同的方案来准备OS介质。该规范的目标受众是：</p><p> Boot loader developers, to write a boot loader that directly reads its configuration at runtime from these drop-in snippets</p><p> 引导加载程序开发人员，编写了一个引导加载程序，该引导加载程序在运行时直接从这些插入式片段中读取其配置</p><p>    Distribution and Core OS developers, in order to create these snippets at OS/kernel package installation time</p><p>    发行版和Core OS开发人员，以便在OS /内核软件包安装时创建这些代码段</p><p>    OS Installer developers, to prepare their installation media and for setting up the initial drop-in directory</p><p>    OS Installer开发人员，准备他们的安装介质并设置初始插入目录</p><p>  Of course, without this specification things already work mostly fine. But here’s why we think this specification is needed:</p><p>  当然，没有此规范，大多数情况下就可以正常工作。但是，这就是我们认为需要此规范的原因：</p><p> To make the boot more robust, as no explicit rewriting of configuration files is required any more</p><p> 为了使启动更加可靠，因为不再需要显式重写配置文件 </p><p>  To allow an out of the box boot experience on any platform without the need of traditional firmware mechanisms (e.g. BIOS calls, UEFI Boot Services)</p><p>无需传统固件机制（例如BIOS调用，UEFI引导服务）即可在任何平台上实现开箱即用的引导体验</p><p>  To improve dual-boot scenarios. Currently, multiple Linux installations tend to fight over which boot loader becomes the primary one in possession of the MBR, and only that one installation can then update the boot loader configuration of it freely. Other Linux installs have to be manually configured to never touch the MBR and instead install a chain-loaded boot loader in their own partition headers. In this new scheme as all installations share a loader directory no manual configuration has to take place, and all participants implicitly cooperate due to removal of name collisions and can install/remove their own boot menu entries at free will, without interfering with the entries of other installed operating systems.</p><p>  改善双启动方案。当前，多个Linux安装趋向于争夺哪个引导装载程序成为MBR拥有的主要引导装载程序，并且只有一个安装程序才能自由更新它的引导装载程序配置。必须手动配置其他Linux安装，以使其永不接触MBR，而应在其自己的分区头中安装链加载的引导加载程序。在这种新方案中，由于所有安装都共享一个加载程序目录，因此无需进行手动配置，并且由于消除了名称冲突，所有参与者都暗含合作，并且可以随意安装/删除自己的引导菜单项，而不会干扰它们的条目。其他已安装的操作系统。</p><p>  Drop-in directories are otherwise now pretty ubiquitous on Linux as an easy way to extend configuration without having to edit, regenerate or manipulate configuration files. For the sake of uniformity, we should do the same for extending the boot menu.</p><p>  否则，插入目录现在在Linux上无处不在，这是扩展配置而无需编辑，重新生成或操作配置文件的简便方法。为了统一起见，我们应该对扩展启动菜单进行相同的操作。</p><p>  Userspace code can sanely parse boot loader configuration which is essential with modern BIOSes which do not necessarily initialize USB keyboards anymore during boot, which makes boot menus hard to reach for the user. If userspace code can parse the boot loader configuration, too, this allows for UIs that can select a boot menu item to boot into, before rebooting the machine, thus not requiring interactivity during early boot.</p><p>  用户空间代码可以合理地解析引导加载程序配置，这对于现代BIOS是必不可少的，而现代BIOS不必在引导过程中再次初始化USB键盘，这使得引导菜单对于用户而言很难实现。如果用户空间代码也可以解析引导加载程序配置，则这将允许UI在重新引导计算机之前可以选择要引导进入的引导菜单项，因此不需要在早期引导期间进行交互。</p><p>  To unify and thus simplify configuration of the various boot loaders around, which makes configuration of the boot loading process easier for users, administrators and developers alike.</p><p>  为了统一并简化各种引导加载程序的配置，这使得用户，管理员和开发人员都可以更轻松地配置引导加载过程。</p><p>  For boot loaders with configuration  scripts such as grub2, adopting this spec allows for mostly static scripts that are generated only once at first installation, but then do not need to be updated anymore as that is done via drop-in files exclusively.</p><p>  对于带有配置脚本（例如grub2）的引导加载程序，采用此规范可允许大多数静态脚本，这些脚本在首次安装时仅生成一次，但随后无需再进行更新，因为这完全是通过插入文件来完成的。</p><p>  EFI is not ubiquitous, especially not in embedded systems. If you have an EFIsystem, it provides a boot options logic that can offer similarfunctionality. Here’s why we think that it is not enough for our uses:</p><p>  EFI并非无处不在，尤其是在嵌入式系统中。如果您有EFI系统，它会提供可以提供相似功能的启动选项逻辑。这就是为什么我们认为不足以用于我们的用途： </p><p> The various EFI implementations implement the boot order/boot item logic to different levels. Some firmware implementations do not offer a boot menu at all and instead unconditionally follow the EFI boot order, booting the first item that is working.</p><p>各种EFI实现将启动顺序/启动项逻辑实现到不同的级别。某些固件实现根本不提供启动菜单，而是无条件地遵循EFI引导顺序，从而引导正在运行的第一项。</p><p>  If the firmware setup is used to reset all data usually all EFI boot entries are lost, making the system entirely unbootable, as the firmware setups generally do not offer a UI to define additional boot items. By placing the menu item information on disk, it is always available, regardless if the BIOS setup data is lost.</p><p>  如果使用固件设置来重置所有数据，则通常所有EFI引导项都会丢失，从而使系统完全无法引导，因为固件设置通常不提供用于定义其他引导项的UI。通过将菜单项信息放置在磁盘上，无论BIOS设置数据是否丢失，该信息始终可用。</p><p>  Harddisk images should be movable between machines and be bootable without requiring explicit EFI variables to be set. This also requires that the list of boot options is defined on disk, and not in EFI variables alone.</p><p>  硬盘映像应可在机器之间移动并且可引导，而无需设置显式的EFI变量。这还要求引导选项列表在磁盘上定义，而不是仅在EFI变量中定义。</p><p>  EFI is not universal yet (especially on non-x86 platforms), this specification is useful both for EFI and non-EFI boot loaders.</p><p>  EFI还不是通用的（特别是在非x86平台上），该规范对于EFI和非EFI引导加载程序均有用。</p><p>  Many EFI systems disable USB support during early boot to optimize boot times, thus making keyboard input unavailable in the EFI menu. It is thus useful if the OS UI has a standardized way to discover available boot options which can be booted to.</p><p>  许多EFI系统会在早期启动期间禁用USB支持以优化启动时间，从而使键盘输入在EFI菜单中不可用。因此，如果OS UI具有标准化的方式来发现可以引导到的可用引导选项，则将很有用。</p><p>  Everything described below is located on a placeholder file system  $BOOT. The installer program should pick  $BOOT according to the following rules:</p><p>  下文所述的所有内容均位于占位符文件系统$ BOOT上。安装程序应根据以下规则选择$ BOOT：</p><p> On disks with an MBR partition table:  If the OS is installed on a disk with an MBR partition table, and a partition with the type id of 0xEA already exists it should be used as  $BOOT.</p><p> 在具有MBR分区表的磁盘上：如果操作系统安装在具有MBR分区表的磁盘上，并且类型ID为0xEA的分区已存在，则应将其用作$ BOOT。 </p><p>  Otherwise, if the OS is installed on a disk with an MBR partition table, a new partition with type id of 0xEA shall be created, of a suitable size (let’s say 500MB), and it should be used as  $BOOT.</p><p>否则，如果操作系统安装在具有MBR分区表的磁盘上，则应创建一个ID为0xEA的新分区，其大小合适（例如500MB），并应用作$ BOOT。</p><p>  On disks with GPT (GUID Partition Table)  If the OS is installed on a disk with GPT, and an Extended Boot Loader Partition or XBOOTLDR partition for short, i.e. a partition with GPT type GUID of  bc13c2ff-59e6-4262-a352-b275fd6f7172, already exists, it should be used as  $BOOT.</p><p>  在具有GPT（GUID分区表）的磁盘上如果操作系统安装在具有GPT的磁盘上，并且简称为扩展引导加载程序分区或XBOOTLDR分区，即GPT类型GUID为bc13c2ff-59e6-4262-a352-b275fd6f7172的分区，已经存在，应将其用作$ BOOT。</p><p>  Otherwise, if the OS is installed on a disk with GPT, and an EFI System Partition or ESP for short, i.e. a partition with GPT type UID of  c12a7328-f81f-11d2-ba4b-00a0c93ec93b) already exists and is large enough (let’s say 250MB) and otherwise qualifies, it should be used as  $BOOT.</p><p>  否则，如果操作系统安装在具有GPT的磁盘上，并且简称为EFI系统分区或ESP，即GPT类型UID为c12a7328-f81f-11d2-ba4b-00a0c93ec93b的分区已经存在并且足够大（比如说） 250MB），如果没有其他资格，则应将其用作$ BOOT。</p><p>  Otherwise, if the OS is installed on a disk with GPT, and if the ESP partition already exists but is too small, a new suitably sized (let’s say 500MB) XBOOTLDR partition shall be created and used as  $BOOT.</p><p>  否则，如果操作系统安装在具有GPT的磁盘上，并且如果ESP分区已经存在但太小，则应创建一个合适大小的新XBOOTLDR分区并将其用作$ BOOT。</p><p>  Otherwise, if the OS is installed on a disk with GPT, and no ESP partition exists yet, a new suitably sized (let’s say 500MB) ESP should be created and used as  $BOOT.</p><p>  否则，如果操作系统安装在具有GPT的磁盘上，并且尚不存在ESP分区，则应创建一个新的适当大小（例如500MB）的ESP并将其用作$ BOOT。</p><p> This placeholder file system shall be determined during  installation time, and an fstab entry may be created. It should be mounted to either  /boot/ or  /efi/. Additional locations like  /boot/efi/, with  /boot/ being a separate file system, might be supported by implementations. This is not recommended because the mounting of  $BOOT is then dependent on and requires the mounting of the intermediate file system.</p><p> 此占位符文件系统应在安装期间确定，并可以创建fstab条目。应该将其安装到/ boot /或/ efi /。实现可能支持其他位置，例如/ boot / efi /，其中/ boot /是一个单独的文件系统。不建议这样做，因为$ BOOT的安装取决于并且需要安装中间文件系统。</p><p> Note:   $BOOT should be considered  shared among all OS installations of a system. Instead of maintaining one  $BOOT per installed OS (as  /boot/ was traditionally handled), all installed OS share the same place to drop in their boot-time configuration.</p><p> 注意：应将$ BOOT视为在系统的所有OS安装之间共享。与其为每个已安装的操作系统维护一个$ BOOT（传统上是按/ boot /来处理），所有已安装的OS共享一个相同的位置来放置其启动时配置。 </p><p> For systems where the firmware is able to read file systems directly,  $BOOTmust be a file system readable by the firmware. For other systems and genericinstallation and live media,  $BOOT must be a VFAT (16 or 32) filesystem. Applications accessing  $BOOT should hence not assume that fancierfile system features such as symlinks, hardlinks, access control or casesensitivity are supported.</p><p>对于固件能够直接读取文件系统的系统，$ BOOT必须是固件可读的文件系统。对于其他系统以及常规安装和实时媒体，$ BOOT必须是VFAT（16或32）文件系统。因此，访问$ BOOT的应用程序不应假定支持fancierfi​​le系统功能，例如符号链接，硬链接，访问控制或区分大小写。</p><p> This specification defines two types of boot loader entries. The first type istext based, very simple and suitable for a variety of firmware, architectureand image types (“Type #1”). The second type is specific to EFI, but allowssingle-file images that embed all metadata in the kernel binary itself, whichis useful to cryptographically sign them as one file for the purpose ofSecureBoot (“Type #2”).</p><p> 该规范定义了两种类型的引导加载程序条目。第一种是基于文本的，非常简单，适用于各种固件，体系结构和映像类型（“类型＃1”）。第二种类型专用于EFI，但允许将所有元数据嵌入内核二进制文件本身的单文件图像，这对于以SecureBoot的形式将它们作为一个文件进行密码签名非常有用（“ Type＃2”）。</p><p> Not all boot loader entries will apply to all systems. For example, Type #1entries that use the  efi key and all Type #2 entries only apply to EFIsystems. Entries using the  architecture key might specify an architecture thatdoesn’t match the local one. Boot loaders should ignore all entries that don’tmatch the local platform and what the boot loader can support, and hide themfrom the user. Only entries matching the feature set of boot loader and systemshall be considered and displayed. This allows image builders to put togetherimages that transparently support multiple different architectures.</p><p> 并非所有引导加载程序条目都将适用于所有系统。例如，使用efi密钥的类型1条目和所有类型2条目仅适用于EFIsystem。使用架构密钥的条目可能指定的架构与本地架构不匹配。引导加载程序应忽略所有与本地平台不匹配的条目以及引导加载程序可以支持的内容，并向用户隐藏它们。仅考虑和显示与引导加载程序和系统功能集匹配的条目。这允许图像构建者将透明地支持多种不同体系结构的图像放在一起。</p><p> Note that the  $BOOT partition is not supposed to be exclusive territory ofthis specification. This specification only defines semantics of the  /loader/directory inside the file system (see below), but it doesn’t intend to defineownership of the whole file system exclusively. Boot loaders, firmware, andother software implementing this specification may choose to place otherfiles and directories in the same file system. For example, boot loaders thatimplement this specification might install their own boot code into the  $BOOTpartition. On systems where  $BOOT is the ESP this is a particularly commonsetup. Implementations of this specification must be able to operate correctlyif files or directories other than  /loader/ are found in the top leveldirectory. Implementations that add their own files or directories to the filesystems should use well-named directories, to make name collisions betweenmultiple users of the file system unlikely.</p><p> 注意，$ BOOT分区不应视为该规范的排他性领土。该规范仅定义文件系统内/ loader /目录的语义（请参见下文），但无意专门定义整个文件系统的所有权。引导加载程序，固件和实现此规范的其他软件可以选择将其他文件和目录放置在同一文件系统中。例如，实现此规范的引导加载程序可能会将其自己的引导代码安装到$ BOOTpartition中。在$ BOOT是ESP的系统上，这是一个特别常见的设置。如果在顶级目录中找到/ loader /以外的文件或目录，则此规范的实现必须能够正确运行。将自己的文件或目录添加到文件系统的实现应使用命名良好的目录，以免文件系统的多个用户之间发生名称冲突。</p><p>   $BOOT/loader/entries/ is the directory containing the drop-in snippets. This directory contains one  .conf file for each boot menu item.</p><p>   $ BOOT / loader / entries /是包含插入代码段的目录。该目录为每个引导菜单项包含一个.conf文件。</p><p> Note:  In all cases the  /loader/ directory should be located directly in the root of the file system. Specifically, if  $BOOT is the ESP, then  /loader/ directory should be located directly in the root directory of the ESP, and not in the  /EFI/ subdirectory.</p><p> 注意：在所有情况下，/ loader /目录都应直接位于文件系统的根目录中。具体来说，如果$ BOOT是ESP，则/ loader /目录应该直接位于ESP的根目录中，而不是/ EFI /子目录中。</p><p> Inside the  $BOOT/loader/entries/ directory each OS vendor may drop one ormore configuration snippets with the suffix “.conf”, one for each boot menuitem. The file name of the file is used for identification of the boot item butshall never be presented to the user in the UI. The file name may be chosenfreely but should be unique enough to avoid clashes between OSinstallations. More specifically it is suggested to include the machine ID( /etc/machine-id or the D-Bus machine ID for OSes that lack /etc/machine-id), the kernel version (as returned by  uname -r) and an OSidentifier (The ID field of  /etc/os-release). Example: $BOOT/loader/entries/6a9857a393724b7a981ebb5b8495b9ea-3.8.0-2.fc19.x86_64.conf.</p><p> 在$ BOOT / loader / entries /目录中，每个操作系统供应商都可以放置一个或多个带有后缀“ .conf”的配置片段，每个引导菜单项一个。该文件的文件名用于标识启动项，但永远不要在UI中向用户显示。可以自由选择文件名，但文件名应足够唯一以避免操作系统安装之间发生冲突。更具体地说，建议包括机器ID（/ etc / machine-id或缺少/ etc / machine-id的OS的D-Bus机器ID），内核版本（由uname -r返回）和OSidentifier。 （/ etc / os-release的ID字段）。例如：$ BOOT / loader / entries / 6a9857a393724b7a981ebb5b8495b9ea-3.8.0-2.fc19.x86_64.conf。 </p><p> In order to maximize compatibility with file system implementations andrestricted boot loader environments, and to minimize conflicting character usewith other programs, file names shall be chosen from a restricted character set:ASCII upper and lower case characters, digits, “+”, “-“, “_” and “.”. Also, thefile names should have a length of at least one and at most 255 characters(including file name suffix).</p><p>为了最大程度地与文件系统实现和受限制的引导加载程序环境兼容，并最大程度地减少与其他程序的字符冲突，应从受限制的字符集中选择文件名：ASCII大写和小写字母，数字，“ +”，“-” ， “_“ 和 ”。”。另外，文件名的长度至少应为255个字符（包括文件名后缀）。</p><p> These configuration snippets shall be Unix-style text files (i.e. line separation with a single newline character), in the UTF-8 encoding. The configuration snippets are loosely inspired on Grub1’s configuration syntax. Lines beginning with ‘#’ shall be ignored and used for commenting. The first word of a line is used as key and shall be separated by one or more spaces from its value. The following keys are known:</p><p> 这些配置摘要应为Unix样式的文本文件（即，以单个换行符分隔的行），并采用UTF-8编码。这些配置摘要是从Grub1的配置语法中大致得到启发的。以“＃”开头的行将被忽略并用于注释。一行的第一个字用作键，并且应与值分开一个或多个空格。已知以下密钥：</p><p> title shall contain a human readable title string for this menu item. This will be displayed in the boot menu for the item. It is a good idea to initialize this from the  PRETTY_NAME of  /etc/os-release. This name should be descriptive and does not have to be unique. If a boot loader discovers two entries with the same title it is a good idea to show more than just the raw title in the UI, for example by appending the  version field. This field is optional. Example: “Fedora 18 (Spherical Cow)”.</p><p> 标题应包含此菜单项的可读标题字符串。这将显示在该项目的启动菜单中。从/ etc / os-release的PRETTY_NAME初始化它是一个好主意。此名称应具有描述性，不必唯一。如果引导加载程序发现两个具有相同标题的条目，则最好在UI中显示不仅仅是原始标题的内容，例如，通过附加version字段。该字段是可选的。示例：“ Fedora 18（球形牛）”。</p><p>  version shall contain a human readable version string for this menu item. This is usually the kernel version and is intended for use by OSes to install multiple kernel versions at the same time with the same  title field. This field shall be in a syntax that is useful for Debian-style version sorts, so that the boot loader UI can determine the newest version easily and show it first or preselect it automatically. This field is optional. Example:  3.7.2-201.fc18.x86_64.</p><p>  版本应包含此菜单项的人类可读版本字符串。这通常是内核版本，供操作系统使用，以使用相同的标题字段同时安装多个内核版本。该字段应采用对Debian样式版本排序有用的语法，以便引导加载程序UI可以轻松确定最新版本并首先显示它或自动对其进行预选择。该字段是可选的。示例：3.7.2-201.fc18.x86_64。</p><p>  machine-id shall contain the machine ID of the OS  /etc/machine-id. This is useful for boot loaders and applications to filter out boot entries, for example to show only a single newest kernel per OS, or to group items by OS, or to maybe filter out the currently booted OS in UIs that want to show only other installed operating systems. This ID shall be formatted as 32 lower case hexadecimal characters (i.e. without any UUID formatting). This key is optional. Example:  4098b3f648d74c13b1f04ccfba7798e8.</p><p>  machine-id必须包含操作系统/ etc / machine-id的机器ID。这对引导加载程序和应用程序过滤掉引导项很有用，例如，仅显示每个OS的单个最新内核，或按OS分组项目，或者在只想显示其他信息的UI中过滤掉当前引导的OS。已安装的操作系统。该ID的格式应为32个小写的十六进制字符（即不使用任何UUID格式）。该键是可选的。例如：4098b3f648d74c13b1f04ccfba7798e8。</p><p>  linux refers to the Linux kernel to spawn and shall be a path relative to the  $BOOT directory. It is recommended that every distribution creates a machine id and version specific subdirectory below  $BOOT and places its kernels and initial RAM disk images there. Example:  /6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/linux.</p><p>  linux是指要生成的Linux内核，并且应是相对于$ BOOT目录的路径。建议每个发行版在$ BOOT下创建一个计算机ID和特定于版本的子目录，并将其内核和初始RAM磁盘映像放在此处。示例：/6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/linux。</p><p>  initrd refers to the initrd to use when executing the kernel. This also shall be a path relative to the  $BOOT directory. This key is optional. This key may appear more than once in which case all specified images are used, in the order they are listed. Example:  6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.x86_64/initrd.</p><p>  initrd是指执行内核时要使用的initrd。这也应该是相对于$ BOOT目录的路径。该键是可选的。该键可能会出现多次，在这种情况下，将使用所有指定的图像（按照它们列出的顺序）。例如：6a9857a393724b7a981ebb5b8495b9ea / 3.8.0-2.fc19.x86_64 / initrd。 </p><p>  efi refers to an arbitrary EFI program. This also takes a path relative to  $BOOT. If this key is set, and the system is not an EFI system this entry should be hidden.</p><p>efi是指任意EFI程序。这也采用相对于$ BOOT的路径。如果设置了此密钥，并且系统不是EFI系统，则该条目应被隐藏。</p><p>  options shall contain kernel parameters to pass to the Linux kernel to spawn. This key is optional and may appear more than once in which case all specified parameters are used in the order they are listed.</p><p>  选项应包含传递给Linux内核以产生的内核参数。该键是可选的，可能会出现多次，在这种情况下，所有指定的参数都将按照其列出的顺序使用。</p><p>  devicetree refers to the binary device tree to use when executing thekernel. This also shall be a path relative to the  $BOOT directory. Thiskey is optional. Example:  6a9857a393724b7a981ebb5b8495b9ea/3.8.0-2.fc19.armv7hl/tegra20-paz00.dtb.</p><p>  devicetree是指执行内核时要使用的二进制设备树。这也应该是相对于$ BOOT目录的路径。此项是可选的。例如：6a9857a393724b7a981ebb5b8495b9ea / 3.8.0-2.fc19.armv7hl / tegra20-paz00.dtb。</p><p>  devicetree-overlay refers to a list of device tree overlays that should beapplied by the boot loader. Multiple overlays are separated by spaces andapplied in the same order as they are listed. This key is optional but dependson the  devicetree key. Example: /6a9857a393724b7a981ebb5b8495b9ea/overlays/overlay_A.dtbo/6a9857a393724b7a981ebb5b8495b9ea/overlays/overlay_B.dtbo</p><p>  devicetree-overlay是引导加载程序应应用的设备树覆盖列表。多个叠加层之间用空格隔开，并按照列出的顺序应用。该密钥是可选的，但取决于devicetree密钥。例如：/6a9857a393724b7a981ebb5b8495b9ea/overlays/overlay_A.dtbo/6a9857a393724b7a981ebb5b8495b9ea/overlays/overlay_B.dtbo</p><p>  architecture refers to the architecture this entry is defined for. The argument should be an architecture identifier, using the architecture vocabulary defined by the EFI specification (i.e.  IA32,  x64,  IA64,  ARM,  AA64, …). If specified and this does not match (case insensitively) the local system architecture this entry should be hidden.</p><p>  体系结构是指为此条目定义的体系结构。参数应为架构标识符，使用EFI规范定义的架构词汇表（即IA32，x64，IA64，ARM，AA64等）。如果指定并且与本地系统体系结构不匹配（不区分大小写），则该条目应被隐藏。</p><p> Each configuration drop-in snippet must include at least a  linux or an  efi key and is otherwise not valid. Here’s an example for a complete drop-in file:</p><p> 每个配置插入代码段都必须至少包含linux或efi密钥，否则无效。以下是完整的嵌入式文件的示例：</p><p>  On EFI systems all Linux kernel images should be EFI images. In order toincrease compatibility with EFI systems it is highly recommended only toinstall EFI kernel images, even on non-EFI systems, if that’s applicable andsupported on the specific architecture.</p><p>  在EFI系统上，所有Linux内核映像都应该是EFI映像。为了增强与EFI系统的兼容性，强烈建议仅在特定体系结构上适用且受支持的情况下，即使在非EFI系统上也要安装EFI内核映像。 </p><p> Conversely, in order to increase compatibility it is recommended to installgeneric kernel images that make few assumptions about the firmware they run on,i.e. it is a good idea that both images shipped as UEFI PE images and thosewhich are not don’t make unnecessary assumption on the underlying firmware,i.e. don’t hard depend on legacy BIOS calls or UEFI boot services.</p><p>相反，为了提高兼容性，建议安装通用内核映像，这些映像很少假设它们运行的​​固件。最好将作为UEFI PE映像提供的映像和未作为映像的映像都不要对基础固件进行不必要的假设，即不必依赖传统的BIOS调用或UEFI引导服务。</p><p> Note that these configuration snippets may only reference kernels (and EFI programs) that reside on the same file system as the configuration snippets, i.e. everything referenced must be contained in the same file system. This is by design, as referencing other partitions or devices would require a non-trivial language for denoting device paths. If kernels/initrds are to be read from other partitions/disks the boot loader can do this in its own native configuration, using its own specific device path language, and this is out of focus for this specification. More specifically, on non-EFI systems configuration snippets following this specification cannot be used to spawn other operating systems (such as Windows).</p><p> 请注意，这些配置代码段只能引用与配置代码段位于同一文件系统上的内核（和EFI程序），即，所引用的所有内容都必须包含在同一文件系统中。这是设计使然，因为引用其他分区或设备将需要非平凡的语言来表示设备路径。如果要从其他分区/磁盘读取内核/初始值，则引导加载程序可以使用其自身的特定设备路径语言以其自身的本机配置来执行此操作，因此在本规范中没有重点介绍。更具体地说，在非EFI系统上，不能使用遵循此规范的配置片段来生成其他操作系统（例如Windows）。</p><p>  A unified kernel image is a single EFI PE executable combining an EFI stubloader, a kernel image, an initramfs image, and the kernel command line. Seethe description of the  --uefi option in dracut(8). Such unifiedimages will be searched for under  $BOOT/EFI/Linux/ and must have theextension  .efi. Support for images of this type is of course specific tosystems with EFI firmware. Ignore this section if you work on systems notsupporting EFI.</p><p>  统一内核映像是单个EFI PE可执行文件，它结合了EFI存根加载器，内核映像，initramfs映像和内核命令行。请参阅dracut（8）中--uefi选项的说明。此类统一映像将在$ BOOT / EFI / Linux /下进行搜索，并且必须具有扩展名.efi。当然，对这种类型的图像的支持特定于具有EFI固件的系统。如果您在不支持EFI的系统上工作，请忽略本节。</p><p> Type #2 file names should be chosen from the same restricted character set asType #1 described above (but use a different file name suffix of  .efi insteadof  .conf).</p><p> 类型2的文件名应从与上述类型1相同的受限字符集中选择（但使用.efi的不同文件名后缀代替.conf）。</p><p> Images of this type have the advantage that all metadata and payload that makesup the boot entry is monopolized in a single PE file that can be signedcryptographically as one for the purpose of EFI SecureBoot.</p><p> 这种类型的映像的优势在于，构成引导项的所有元数据和有效负载都被垄断在一个PE文件中，该文件可以被加密签名，以用于EFI SecureBoot。</p><p>   The  PRETTY_NAME= and  VERSION_ID= fields in the embedded os-release file are used the same as  title and  version in the “boot loader specification” entries. The  .cmdline section is used instead of the  options field.  linux and  initrd fields are not necessary, and there is no counterpart for the  machine-id field.</p><p>   嵌入式操作系统发行版文件中的PRETTY_NAME =和VERSION_ID =字段与“引导程序规范”条目中的标题和版本相同。使用.cmdline部分代替选项字段。 linux和initrd字段不是必需的，并且machine-id字段没有对应的字段。</p><p> On EFI, any such images shall be added to the list of valid boot entries.</p><p> 在EFI上，任何此类映像都应添加到有效启动项列表中。 </p><p>  Note that these configurations snippets do not need to be the only configuration source for a boot loader. It may extend this list of entries with additional items from other configuration files (for example its own native configuration files) or automatically detected other entries without explicit configuration.</p><p>请注意，这些配置摘要不必是引导加载程序的唯一配置源。它可以使用其他配置文件（例如其自身的本机配置文件）中的其他项来扩展此条目列表，也可以在没有显式配置的情况下自动检测到其他条目。</p><p> To make this explicitly clear: this specification is designed with “free” operating systems in mind, starting Windows or MacOS is out of focus with these configuration snippets, use boot-loader specific solutions for that. In the text above, if we say “OS” we hence imply “free”, i.e. primarily Linux (though this could be easily be extended to the BSDs and whatnot).</p><p> 为了明确说明这一点：设计此规范时考虑的是“免费”操作系统，使用这些配置摘要无法启动Windows或MacOS，请为此使用引导加载程序专用的解决方案。在上面的文本中，如果我们说“ OS”，则意味着“免费”，即主要是Linux（尽管可以轻松地将其扩展到BSD或其他方面）。</p><p> Note that all paths used in the configuration snippets use a Unix-style “/” as path separator. This needs to be converted to an EFI-style “&#34; separator in EFI boot loaders.</p><p> 请注意，配置片段中使用的所有路径都使用Unix样式的“ /”作为路径分隔符。这需要转换为EFI样式的“＆＃34; EFI引导加载程序中的分隔符。</p><p>  A  boot loader needs a file system driver to discover and read  $BOOT, thensimply reads all files  $BOOT/loader/entries/*.conf, and populates its bootmenu with this. On EFI, it then extends this with any unified kernel imagesfound in  $BOOT/EFI/Linux/*.efi. It may also add additional entries, forexample a “Reboot into firmware” option. Optionally it may sort the menu basedon the  machine-id and  version fields, and possibly others. It uses the filename to identify specific items, for example in case it supports storing awaydefault entry information somewhere. A boot loader should generally not modifythese files.</p><p>  引导加载程序需要文件系统驱动程序来发现和读取$ BOOT，然后仅读取所有文件$ BOOT / loader / entries / *。conf，并以此填充其引导菜单。然后，在EFI上，它使用$ BOOT / EFI / Linux / *。efi中找到的任何统一内核映像对其进行扩展。它还可能添加其他条目，例如“ Reboot into firmware”选项。可选地，它可以根据计算机ID和版本字段以及其他可能的字段对菜单进行排序。它使用文件名来标识特定项目，例如，如果它支持将默认条目信息存储在某个地方。引导加载程序通常不应修改这些文件。</p><p> For “Boot Loader Specification Entries” (Type #1), the  kernel packageinstaller installs the kernel and initrd images to  $BOOT (it is recommendedto place these files in a vendor and OS and installation specific directory)and then generates a configuration snippet for it, placing this in $BOOT/loader/entries/xyz.conf, with xyz as concatenation of machine id andversion information (see above). The files created by a kernel package areprivate property of the kernel package and should be removed along with it.</p><p> 对于“ Boot Loader规范条目”（类型1），内核软件包安装程序将内核和initrd映像安装到$ BOOT（建议将这些文件放置在供应商和OS以及特定于安装的目录中），然后为其生成配置摘要，将其放置在$ BOOT / loader / entries / xyz.conf中，其中xyz是计算机ID和版本信息的串联（请参见上文）。内核软件包创建的文件是内核软件包的private属性，应与之一起删除。</p><p> For “EFI Unified Kernel Images” (Type #2), the vendor or kernel packageinstaller creates the combined image and drops it into  $BOOT/EFI/Linux/. Thisfile is also private property of the kernel package and should be removed alongwith it.</p><p> 对于“ EFI统一内核映像”（类型2），供应商或内核软件包安装程序将创建组合映像并将其放入$ BOOT / EFI / Linux /中。该文件也是内核包的私有属性，应与该文件一起删除。</p><p> A  UI application intended to show available boot options shall operate similar to a boot loader, but might apply additional filters, for example by filtering o</p><p> 旨在显示可用引导选项的UI应用程序应类似于引导加载程序，但可能会应用其他过滤器，例如通过过滤o </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://systemd.io/BOOT_LOADER_SPECIFICATION/">https://systemd.io/BOOT_LOADER_SPECIFICATION/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/引导/">#引导</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/boot/">#boot</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>