<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>让我们停止在网络黑客附近建造API（2017） Let's stop building APIs around a network hack (2017)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Let's stop building APIs around a network hack (2017)<br/>让我们停止在网络黑客附近建造API（2017） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-26 10:34:37</div><div class="page_narrow text-break page_content"><p>JSON:API has been one of the most popular standards forAPI development for a while now. It was conceived in 2013, battled through somerather different RC versions (changing drastically as it went), finallystabilizing with v1.0 back in mid-2015.</p><p>JSON：API现在是一段时间最受欢迎的标准之一。它是在2013年构思的，通过萨伯特不同的RC版本（随着它的急剧改变），最终在2015年中期与V1.0返回。</p><p> My interest in JSON:API has changed substantially over the years. Initially Iavoided it like the plague, later I recommending it, and now I generally suggestfolks skip it if at all possible.</p><p> 我对JSON的兴趣：多年来，API已经改变了。最初的是，它就像瘟疫一样，我稍后推荐它，现在我一般建议服用它，如果可能的话，跳过它。</p><p> Besides trying to standardize how you represent items, collections, meta dataand errors (an excellent goal!), it sets out to solve a lot of problems such as Compound Documents.</p><p> 除了尝试标准化如何代表物品，集合，元数据和出现优异的目标！），它就列出了解决大量问题，如复合文档。</p><p> The concept of a &#34;compound document&#34; — in the API world at least — is the art ofsquashing related data into the main requested resources. This is done to reducethe number of HTTP calls a client has to make.</p><p> A＆＃34的概念;复合文件＆＃34; - 至少在API世界中至少 - 是艺术相关数据的艺术，进入主要请求的资源。这是为了缩写客户端必须制作的HTTP调用数量。</p><p> Clients have for a long time been very unhappy making multiple HTTP/1.1 calls,especially over mobile networks. That concern has had a noticeable impact on howwe design APIs. Multiple calls is considered a point of bad design, to the pointwhere fetching a user will include the companies they work for, and thatincludes the locations a company might have, and that includes something else...</p><p> 客户长期以来一直非常不满意多次HTTP / 1.1呼叫，尤其是在移动网络上。这令人担忧对Whewe设计API有一个明显的影响。多个呼叫被认为是一个不好的设计点，到获取用户的位置将包括他们为他们工作的公司，并且该公司可能拥有的位置，并且包括其他内容......</p><p> That was a bit of a mess, so conventions and standards were invented to makethose includes optional, and JSON:API was one of the main contenders.</p><p> 这是一点混乱，所以将惯例和标准发明为Makethose包括可选，json：API是主要竞争者之一。</p><p> Somewhere in 2013 I also released a tool called Fractal, which was based off of code I&#39;dbeen running in production since early 2013. The goal there (other thanserialization) was the same thing, to facilitate embedding and nesting includesoptionally.</p><p> 2013年的某个地方我还发布了一个名为分数维的工具，该工具是基于代码I＆＃39;自2013年初以来在生产中运行的DBEEN。（其他题联）的目标是相同的，便于嵌入和筑巢。 </p><p> In 2013 this all made sense. Multiple calls were bad, so we had to reduce those,without assuming too much and making our requests slower than they should be.This continued to be valid for a long time, even in 2015 when JSON:API wasfinalized.</p><p>2013年这一切都有道理。多个电话很糟糕，所以我们不得不减少那些，而不假设太多并使我们的要求比他们应该慢。这一持续有效，即使是2015年杰森：API被吓坏了。</p><p> Guess what else was released in May 2015? RFC 7540, otherwise known as HTTP/2. In retrospect this seems highlypoetic, as HTTP/2 kinda makes the compound document aspect of JSON:API a littlebit pointless, and compound documents to me go hand in hand with what JSON:APIis as a standard.</p><p> 猜猜2015年5月还有什么释放？ RFC 7540，否则称为HTTP / 2。回想起来，这似乎是高度的，因为HTTP / 2有点使得JSON的复合文件方面：API是一个小点毫无意义的，而复合文件与我携手共同用JSON：APIIS作为标准携手回发。</p><p> Not to just pick on JSON:API, the same can be said about HAL, OData, and it alsomakes Fractal&#39;s nesting/embedding feel silly, like it should be ripped out in afuture version.</p><p> 不要挑选json：api，同样可以说hal，odata和它植物分形和＃39; s筑巢/嵌入感到愚蠢，就像它应该在充满活力的版本中被扯掉。</p><p>  There are plenty of resources out there explaining the differences betweenHTTP/1.1 and HTTP/2, so I&#39;ll  let them cover it.</p><p>  在那里有大量的资源解释了HTTP / 1.1和HTTP / 2之间的差异，所以我＆＃39; LL让它们覆盖它。</p><p> The main point here is that HTTP/1.0 forces you to handle DNS, HTTP handshakes,SSL negotiation, etc., on every single call, and if your homepage wants 10things from the API then it&#39;s doing all of that junk 10 times... HTTP/1.1 actuallysolved this with Connection: keep-alive, but not many people seem to use that. Whenwe enabled it at WeWork it sped up HTTP interactions by around ~10%, which was nice.</p><p> 这里的主要点是HTTP / 1.0迫使您在每一个呼叫中处理DNS，HTTP握手，SSL协商等，以及您的主页想要从API中的10个，那么＆＃39;做所有的垃圾10时间... HTTP / 1.1实际上是用连接的：保持活力，但没有许多人似乎使用了这一点。当我们在Wewore启用它时，它会加速HTTP交互约〜10％，这很好。</p><p> HTTP/2 not only maintains a single connection per domain for reuse, but these callscan be handled asynchronously. You could requests all the A&#39;s, then the callback for that asyncrequest asks for some B&#39;s as and when the A&#39;s respond. And C and D.</p><p> HTTP / 2不仅维护每个域的单个连接以进行重用，但这些CallScan是异步处理的。您可以要求所有A＆＃39; s，那么asyncrequest的回调要求一些b＆＃39; s＆＃39; s回应。和C和D.</p><p> If you can use  ServerPush then youdon&#39;t have to wait for the A&#39;s to respond before you can request the B&#39;s. Theserver will just start sending you the B&#39;s!</p><p> 如果您可以使用serverpush然后youdon＆＃39; t必须等待A＆＃39;在您申请B＆＃39之前要回复。 TheServer将开始向您发送B＆＃39; s！ </p><p>   To me JSON:API has always mainly been about reducing the size of a payloadresponse via network hacks like compound documents, but there is anotherstrategy used.  SparseFieldsets — an ideafairly fundamental to GraphQL also — lets clients specify the fields they&#39;reinterested in, so the API can send only those fields.</p><p>对我来说：API一直主要是通过网络黑客减少薪酬载荷的大小，如复合文件，但是使用了anothertrategy。 SparseFieldSets  -  GraphQL的IdeaFairly基础 - 允许客户指定它们的字段＆＃39;重新接触，因此API只能发送这些字段。</p><p>  Whilst sparse fieldsets can save a few kbs, there are plenty of other ways oftrimming down the size of the response.</p><p>  虽然稀疏的Firstalset可以节省几kbs，但有很多其他方式抵消的尺寸。</p><p> The entire mindset of &#34;more handshakes = bad&#34; has forced us to shove fields intothe same resource to avoid making new resources, or sub-resources. Now that wedon&#39;t need to be scared of it, we can stop using hacks like  the partialsrade-offI recently proposed, and move towards having more resources that are a bit moretargeted in scope.</p><p> 整个心态＆＃34;更多握手=坏＆＃34;已迫使我们将字段推开相同的资源，以避免进行新的资源或子资源。现在，WEDON＆＃39; T需要害怕它，我们可以停止像最近提出的Partialsrade-Offi这样的黑客，并朝着更多的资源迈进，在范围内有点繁殖。</p><p> Invoices don&#39;t need payment status, or an array of order items, so we don&#39;t needto worry about trimming down the response at the field level, they can just betheir own related resources, discoverable with hypermedia controls.</p><p> 发票Don＆＃39; t需要付款状态，或订单项数组，所以我们不需要担心修剪现场级别的响应，他们只能拥有拥有的相关资源，可发现超媒体控制。</p><p> If splitting up resources sounds like a big change and you want to just squashthat actual response, HTTP/2 has your back there too. Headers are compressedwith HPACK, which is similar to GZIP but a little better, and its something Cloudflare are pretty excitedabout.</p><p> 如果拆分资源听起来像是一个大的变化，你想要的是强阵的实际响应，HTTP / 2也有你的背部。标题是压缩的，HPACK类似于Gzip，但稍微好一点，它的东西是CloudFlare的漂亮兴奋。</p><p> That&#39;s not to mention that the whole protocol is binary instead of plain-text,which gets you another nice boost. If you&#39;re still sad about JSON being slow,you can use content-negotiation to add BSON or Protobuff to your REST API, whichis a large part of whats getting people so excited about gRPC.</p><p> 那个＆＃39;＆＃39是不提的整个协议是二进制而不是纯文本，这让你成为另一个漂亮的提升。如果你＆＃39;仍然悲伤的json缓慢，你可以使用内容协商将bson或protobuff添加到您的休息API，这是一个很大一部分让人们对Grpc感到如此兴奋的事情。</p><p> In general, once again, the potential speed benefit of skipping a bit of thatJSON coming back using sparse fieldsets, seems to be lost in the idea of makingyour API be less variable, having more targeted resources, which are drasticallymore cacheable at the network level.</p><p> 一般来说，再一次，跳过一点使用稀疏的Firstalset跳过一点点的潜在速度效益似乎丢失了制作的Makeyour API的想法减少了变量，具有更多有针对性的资源，这些资源在网络级别可持续缓存。 </p><p>  NGINX already supports HTTP/2. Someprogramming languages like  Go have built-in HTTP/2support, so you can enjoy the full benefits ofHTTP/2 like Server Push.  NodeJS too.</p><p>nginx已经支持http / 2。 Go的一些人的语言具有内置HTTP / 2SUPPORT，因此您可以享受像服务器推送的HTTP / 2的全部优势。 nodejs也是。</p><p> Everyone else can at least leverage multiplexing byslapping Cloudflare, Fastly, etc., in front of their HTTP/1.1 setup.</p><p> 其他人至少可以在HTTP / 1.1设置前面杠杆效率使用CloudFlare，速度等。</p><p>  Currently not 100% of browsers support HTTP/2 in it&#39;s entirety, but the situation is pretty good. [Modern browsers support HTTP/2](http://caniuse.com/#feat=http2), and these browsers are used by 88% of users. If your API is predominantly web-based, and older browser support is important,or you have  no idea which browsers are going to be hitting it, then maybe youneed to continue worrying about network hacks like compound documentation.</p><p>  目前禁止100％的浏览器支持它的HTTP / 2＆＃39;完整，但情况非常好。 [现代浏览器支持http / 2]（http://caniuse.com/#feat=http2），这些浏览器由88％的用户使用。如果您的API主要是基于Web的，并且旧的浏览器支持很重要，或者您不知道哪些浏览器会击中它，然后也许您可以继续担心像复合文档等网络黑客。</p><p>  Combining HTTP/2 with targeted, network cached endpoints (via Fastly, Varnish,Squid, etc), makes Hypermedia Controls (HATEOAS) seem waaaaaaaay less silly.</p><p>  将HTTP / 2与目标，网络缓存端点（通过速溶，清漆，鱿鱼等）结合，使得超媒体控制（Hateoas）看起来Waaaaaaaay少愚蠢。</p><p> I&#39;m not waiting for a response before I see what actions I can take next,that&#39;s slow!  — Fictional Narrative Device</p><p> 我在看看我明白的行动之前，我不等待回复，那个＆＃39; s慢！ - 虚构的叙事设备</p><p> No longer! HTTP clients  net-http2 inRuby make asyncing up your calls nice and easy, so you can run actions incallbacks as soon as the responses come in.</p><p> 不再！ HTTP客户端Net-Http2 Inuruby使您的呼叫变得不错，方便，因此您可以在响应进入时立即运行incallbacks。</p><p> Hypermedia in general seems a lot more viable when you&#39;re not terrified of thetransportation layer being slow.</p><p> 超媒体一般似乎在你＆＃39;重新吓坏了TheTronsportation层时更加可行。 </p><p> It also means you&#39;re not going to be scared of making a sub resource. At workright now we have  GET /users and they want to shove  &#34;locations&#34; in there(every WeWork location that a user has access to).</p><p>它也意味着你＆＃39;重复不会害怕制作子资源。在工作台现在我们有/用户，他们想要推动＆＃34;位置＆＃34;在那里（用户可以访问的每个Wewore位置）。</p><p> That would be how you&#39;d want to do it in 2014, but in 2017 that should be  GET/users/123/locations or  GET /locations?user_uuid=123, or  who cares. It justdoesn&#39;t need to be jammed up in there, slowing everyone down, just  in casesomebody needs it.</p><p> 这将是你的方式如何在2014年在2014年进行，但在2017年，应该是GET / USE / 123 /位置或获取/位置？USER_UUID = 123，或者谁关心。它只是在那里猛扑猛扑，慢慢放缓，只是在案例中需要它。</p><p> Includes,  partials,etc., can all graduate to being actual brand new requests, instead of being someweird network hack because we were scared of handshake time.</p><p> 包括，部分等等，可以毕业为实际的全新请求，而不是成为某种覆盖的网络黑客，因为我们害怕握手时间。</p><p>  Folks often say &#34;Why would I want to waste time making a REST API do this when Icould just use X.&#34;</p><p>  人们经常说＆＃34;为什么我想浪费时间让一个休息的api在刚刚使用x时做到这一点。＆＃34;</p><p> In the same way that JSON:API feels a little silly to me now, it makes GraphQLfeel substantially less useful... Anything designed around this network hack nolonger feels as useful as it once was.</p><p> 与JSON：API现在对我感到有点愚蠢，它使GraphQLFeel显着更少有用......在这个网络围绕这个网络破解NOLONGER设计的东西是有用的。</p><p> Well, GraphQL is the king of all glorified network hacks, and gRPC is literallyjust HTTP/2 + Protobuff, I&#39;m left realizing these little niche API setups arenot quite as useful as their marketing sites are making out.</p><p> 嗯，GraphQL是所有美味的网络黑客之王，GRPC就是HTTP / 2 + Protobuff，I＆＃39; M Left意识到这些小利基API设置，因为他们的营销网站正在制定。</p><p> If you already have a REST(ish) API, you can just start using HTTP/2 right nowand get half the benefits of gRPC, and no longer care about many of thebenefits of GraphQL (which are  mostly available for HTTP APIs anyway).</p><p> 如果您已经休息了（ISH）API，则可以从Nowand开始使用HTTP / 2，获得GRPC的一半好处，并且不再关心GraphQL的许多键（无论如何都适用于HTTP API）。 </p><p> Maybe you can remove the &#34;ish&#34; from your RESTish APIs by focusing more on yourAPI as a state machine now that you&#39;re not quite as scared of making more HTTPcalls.</p><p>也许你可以删除＆＃34; ish＆＃34;通过重点在您的RESAPI作为状态机现在，您现在的机器＆＃39;重新害怕制作更多Httpcalls。</p><p>  These previous solution were far from perfect, and I&#39;m going to write aboutreal-world issues I&#39;ve struggled through with compound documents in the nextarticle( done!)I don&#39;t think anyone should rush out and change everything right now, butrecognize the changing environment around the web.</p><p>  这些前面的解决方案远非完美，我将在Nextarticle中的复合文件（完成！）我在努力写下大量的世界问题，我不在Nuttallicle（完成！）我不觉得任何人都应该匆匆忙忙立即更改一切，拒绝Web周围的更改环境。</p><p> As the web evolves the standards evolve to meet changing requirements, and asthey evolve we no longer need as many hacks to get the job done. Frontend developers aren&#39;t make CSS image spritesanymore,and JS/CSS combination is going away too.</p><p> 随着网络发展的发展，以满足更改的要求，Asthey Evolve我们不再需要尽可能多的黑客完成工作。前端开发人员aren＆＃39; t制作css图像spriteSanore，js / css组合也会消失。</p><p> HTTP/2 is a representation of what developers needed, and now we can use HTTP inits entirety, without needing so many network hacks to make it performant enoughto get the job done.</p><p> HTTP / 2是所需的开发人员的表示，现在我们可以全部使用HTTP INITS，而无需如此多的网络黑客攻击使其表现为eNuardo获得作业。</p><p> Using JSON:API/HAL/OData is a fine way to go about building HTTP/1.1-based APIs,and it&#39;s better than inventing your own approach to compound documents, but doyou really need to building HTTP/1.1-based APIs, or is it just inertia?</p><p> 使用JSON：API / HAL / ODATA是一个精致的方法，可以走出基于HTTP / 1.1的API，而不是发明自己的复合文件方法，但DOYOU真的需要建立一个基于HTTP / 1.1的API，还是它只是惯性？ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://apisyouwonthate.com/blog/lets-stop-building-apis-around-a-network-hack">https://apisyouwonthate.com/blog/lets-stop-building-apis-around-a-network-hack</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/黑客/">#黑客</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/网络/">#网络</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/building/">#building</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/http/">#http</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>