<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>7GUI</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">7GUI</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-01 21:42:15</div><div class="page_narrow text-break page_content"><p>The tasks were selected by the following criteria. The task set should be as small as possible yet reflect as many typical (or fundamental or representative) challenges in GUI programming as possible. Each task should be as simple and self-contained as possible yet not too artificial. Preferably, a task should be based on existing examples as that gives the task more justification to be useful and there already will be at least one reference implementation.</p><p>这些任务是根据以下标准选择的。任务集应该尽可能小，但应尽可能多地反映GUI编程中的典型(或基本的或代表性的)挑战。每项任务都应该尽可能简单和自给自足，但又不能过于人为。最好是，任务应该基于现有的示例，因为这使任务更有理由是有用的，并且至少已经有一个参考实现。</p><p> Below, a description of each task highlighted with the challenges it reflects and a screenshot of the resulting GUI application in Java/Swing is given.</p><p>下面给出了每个任务的描述，其中突出显示了它所反映的挑战，并给出了用Java/Swing生成的GUI应用程序的屏幕截图。</p><p>      The task is to build a frame containing a label or read-only textfield  T and a button  B. Initially, the value in  T is “0” and each click of  B increases the value in  T by one.</p><p>任务是构建一个包含标签或只读文本字段T和按钮B的框架。最初，T中的值是“0”，每次单击B都会将T中的值加1。</p><p> Counter serves as a gentle introduction to the basics of the language, paradigm and toolkit for one of the simplest GUI applications imaginable. Thus, Counter reveals the required scaffolding and how the very basic features work together to build a GUI application. A good solution will have almost no scaffolding.</p><p>Counter是对语言、范例和工具包的基础知识的简单介绍，用于可以想象到的最简单的GUI应用程序之一。因此，COUNTER揭示了所需的搭建，以及最基本的功能如何协同工作来构建GUI应用程序。一个好的解决方案几乎不需要脚手架。</p><p>      The task is to build a frame containing two textfields  T C and  T F representing the temperature in Celsius and Fahrenheit, respectively. Initially, both  T C and  T F are empty. When the user enters a numerical value into  T C the corresponding value in  T F is automatically updated and vice versa. When the user enters a non-numerical string into  T C the value in  T F is  not updated and vice versa. The formula for converting a temperature  C in Celsius into a temperature  F in Fahrenheit is  C = (F - 32) * (5/9) and the dual direction is  F = C * (9/5) + 32.</p><p>任务是构建一个包含两个文本字段TC和TF的框架，它们分别以摄氏度和华氏度表示温度。最初，TC和TF都是空的。当用户在TC中输入数值时，TF中的相应值会自动更新，反之亦然。当用户在TC中输入非数字字符串时，TF中的值不会更新，反之亦然。将摄氏温度C转换成华氏温度F的公式是C=(F-32)*(5/9)，双向是F=C*(9/5)+32。</p><p> Temperature Converter increases the complexity of Counter by having bidirectional data flow between the Celsius and Fahrenheit inputs and the need to check the user input for validity. A good solution will make the bidirectional dependency very clear with minimal boilerplate code.</p><p>温度转换器在摄氏和华氏输入之间有双向数据流，并且需要检查用户输入的有效性，从而增加了计数器的复杂性。一个好的解决方案将用最少的样板代码使双向依赖非常清晰。</p><p> Temperature Converter is inspired by the  Celsius/Fahrenheit converter from the book  Programming in Scala. It is such a widespread example—sometimes also in the form of a currency converter—that one could give a thousand references. The same is true for the Counter task.</p><p>温度转换器的灵感来自“用Scala编程”一书中的摄氏度/华氏度转换器。这是一个如此广泛的例子-有时也以货币转换器的形式-以至于人们可以给出一千个参考。计数器任务也是如此。</p><p>      The task is to build a frame containing a combobox  C with the two options “one-way flight” and “return flight”, two textfields  T 1 and  T 2 representing the start and return date, respectively, and a button  B for submitting the selected flight.  T 2 is enabled iff  C’s value is “return flight”. When  C has the value “return flight” and  T 2’s date is strictly before  T 1’s then  B is disabled. When a non-disabled textfield  T has an ill-formatted date then  T is colored red and  B is disabled. When clicking  B a message is displayed informing the user of his selection (e.g. “You have booked a one-way flight on 04.04.2014.”). Initially,  C has the value “one-way flight” and  T 1 as well as  T 2 have the same (arbitrary) date (it is implied that  T 2 is disabled).</p><p>该任务是构建一个框架，其中包含具有两个选项“单向飞行”和“返回航班”的组合框C、分别表示开始日期和返回日期的两个文本字段T1和T2，以及用于提交所选航班的按钮B。如果C的值是“返回飞行”，则启用T2。当C具有值“返回航班”并且T2的日期严格在T1之前时，则B被禁用。当未禁用的文本字段T具有格式错误的日期时，T将显示为红色，而B将被禁用。当点击B时，会显示一条消息通知用户他的选择(例如。您已经预订了2014年4月4日的单程机票。最初，C的值为“单向飞行”，T1和T2的日期相同(任意)(暗示T2被禁用)。</p><p> The focus of Flight Booker lies on modelling constraints between widgets on the one hand and modelling constraints within a widget on the other hand. Such constraints are very common in everyday interactions with GUI applications. A good solution for Flight Booker will make the constraints clear, succinct and explicit in the source code and not hidden behind a lot of scaffolding.</p><p>Flight Booker的重点在于一方面对小部件之间的约束进行建模，另一方面对小部件内的约束进行建模。这种约束在与GUI应用程序的日常交互中非常常见。一个好的Flight Booker解决方案将使源代码中的约束清晰、简洁和显式，而不是隐藏在大量的脚手架后面。</p><p> Flight Booker is directly inspired by the  Flight Booking Java example in Sodium with the simplification of using textfields for date input instead of specialized date picking widgets as the focus of Flight Booker is not on specialized/custom widgets.</p><p>Flight Booker的灵感直接来自于Sodium中的Flight Bookking Java示例，它简化了使用文本字段进行日期输入，而不是专门的日期挑选小部件，因为Flight Booker的重点不是专门的/自定义的小部件。</p><p>      The task is to build a frame containing a gauge  G for the elapsed time  e, a label which shows the elapsed time as a numerical value, a slider  S by which the duration  d of the timer can be adjusted while the timer is running and a reset button  R. Adjusting  S must immediately reflect on  d and not only when  S is released. It follows that while moving  S the filled amount of  G will (usually) change immediately. When  e ≥ d is true then the timer stops (and  G will be full). If, thereafter,  d is increased such that  d &gt; e will be true then the timer restarts to tick until  e ≥ d is true again. Clicking  R will reset  e to zero.</p><p>任务是构建一个框架，该框架包含用于经过的时间e的量规G、将经过的时间显示为数值的标签、在定时器运行时可以通过其调整定时器的持续时间d的滑块S、以及复位按钮R。调整S必须立即反映在d上，而不仅仅是当S被释放时。由此推论，当移动S时，G的填充量(通常)会立即改变。当e_≥_d为真时，定时器停止(并且G将满)。此后，如果d增加，使得d&gt；e将为真，则计时器重新开始滴答，直到e_≥_d再次为真。单击R会将e重置为零。</p><p> Timer deals with concurrency in the sense that a timer process that updates the elapsed time runs concurrently to the user’s interactions with the GUI application. This also means that the solution to competing user and signal interactions is tested. The fact that slider adjustments must be reflected immediately moreover tests the responsiveness of the solution. A good solution will make it clear that the signal is a timer tick and, as always, has not much scaffolding.</p><p>计时器处理并发性，因为更新运行时间的计时器进程与用户与GUI应用程序的交互同时运行。这也意味着对竞争的用户和信号交互的解决方案进行了测试。此外，必须立即反映滑块调整这一事实测试了解决方案的响应性。一个好的解决方案将清楚地表明，该信号是计时器滴答声，并且一如既往地没有太多的脚手架。</p><p> Timer is directly inspired by the timer example in the paper  Crossing State Lines: Adapting Object-Oriented Frameworks to Functional Reactive Languages.</p><p>Timer的灵感直接来自论文“跨越状态线：使面向对象的框架适应函数式反应语言”中的Timer示例。</p><p>      The task is to build a frame containing the following elements: a textfield  T prefix, a pair of textfields  T name and  T surname, a listbox  L, buttons  B C,  B U and  B D and the three labels as seen in the screenshot.  L presents a view of the data in the database that consists of a list of names. At most one entry can be selected in  L at a time. By entering a string into  T prefix the user can filter the names whose surname start with the entered prefix—this should happen immediately without having to submit the prefix with enter. Clicking  B C will append the resulting name from concatenating the strings in  T name and  T surname to  L.  B U and  B D are enabled iff an entry in  L is selected. In contrast to  B C,  B U will not append the resulting name but instead replace the selected entry with the new name.  B D will remove the selected entry. The layout is to be done like suggested in the screenshot. In particular,  L must occupy all the remaining space.</p><p>任务是构建一个包含以下元素的框架：一个文本字段T前缀、一对文本字段T姓名和T姓氏、一个列表框L、按钮B C、B U和B D，以及屏幕截图中所示的三个标签。L显示数据库中数据的视图，该视图由名称列表组成。在L中一次最多只能选择一个条目。通过在T前缀中输入一个字符串，用户可以过滤姓氏以输入的前缀开头的姓名-这应该立即发生，而不必使用Enter提交前缀。单击B、C将把T name和T surname中的字符串连接到L后追加结果名称。如果选择了L中的条目，则启用B U和B D。与B-C相反，B-U不会附加结果名称，而是用新名称替换所选条目。B D将删除所选条目。布局将按照截图中的建议进行。特别地，L必须占据所有剩余空间。</p><p> CRUD (Create, Read, Update and Delete) represents a typical graphical business application. The primary challenge is the separation of domain and presentation logic in the source code that is more or less forced on the implementer due to the ability to filter the view by a prefix. Traditionally, some form of MVC pattern is used to achieve the separation of domain and presentation logic. Also, the approach to managing the mutation of the list of names is tested. A good solution will have a good separation between the domain and presentation logic without much overhead (e.g. in the form of toolkit specific concepts or language/paradigm concepts), a mutation management that is fast but not error-prone and a natural representation of the layout (layout builders are allowed, of course, but would increase the overhead).</p><p>CRUD(Create，Read，Update and Delete，创建、读取、更新和删除)代表了一个典型的图形业务应用程序。主要的挑战是源代码中的域逻辑和表示逻辑的分离，由于能够按前缀过滤视图，这或多或少地强制实现者做到了这一点。传统上，使用某种形式的MVC模式来实现域和表示逻辑的分离。此外，还测试了管理姓名列表突变的方法。一个好的解决方案将在域和表示逻辑之间有很好的分离，没有太多开销(例如，以特定于工具包的概念或语言/范例概念的形式)、快速但不容易出错的突变管理和布局的自然表示(当然，允许布局构建器，但会增加开销)。</p><p> CRUD is directly inspired by the crud example in the blog post  FRP - Three principles for GUI elements with bidirectional data flow.</p><p>CRUD的灵感直接来自博客文章FRP中的CRUD示例-双向数据流的GUI元素的三个原则。</p><p>      The task is to build a frame containing an undo and redo button as well as a canvas area underneath. Left-clicking inside an empty area inside the canvas will create an unfilled circle with a fixed diameter whose center is the left-clicked point. The circle nearest to the mouse pointer such that the distance from its center to the pointer is less than its radius, if it exists, is filled with the color gray. The gray circle is the selected circle  C. Right-clicking  C will make a popup menu appear with one entry “Adjust diameter..”. Clicking on this entry will open another frame with a slider inside that adjusts the diameter of  C. Changes are applied immediately. Closing this frame will mark the last diameter as significant for the undo/redo history. Clicking undo will undo the last significant change (i.e. circle creation or diameter adjustment). Clicking redo will reapply the last undoed change unless new changes were made by the user in the meantime.</p><p>任务是构建一个包含撤消和重做按钮的框架，以及下面的画布区域。在画布内的空白区域内单击鼠标左键将创建一个直径固定的未填充圆圈，其中心为左击点。距离鼠标指针最近的圆(如果存在)从其中心到指针的距离小于其半径，则用灰色填充。灰色圆圈是选定的圆圈C。右击C将出现一个弹出菜单，其中包含一个条目“调整直径..”。单击此条目将打开另一个带有滑块的帧，其中的滑块可调整C的直径。更改将立即应用。关闭此帧将把最后一个直径标记为对撤消/重做历史有重要意义。单击撤消将撤消上一次重要更改(即创建圆或调整直径)。单击重做将重新应用上次撤消的更改，除非用户在此期间进行了新的更改。</p><p> Circle Drawer’s goal is, among other things, to test how good the common challenge of implementing an undo/redo functionality for a GUI application can be solved. In an ideal solution the undo/redo functionality comes for free resp. just comes out as a natural consequence of the language / toolkit / paradigm. Moreover, Circle Drawer tests how dialog control*, i.e. keeping the relevant context between several successive GUI interaction steps, is achieved in the source code. Last but not least, the ease of custom drawing is tested.</p><p>Circle Drawer的目标之一是测试如何很好地解决为GUI应用程序实现撤消/重做功能这一常见挑战。在理想的解决方案中，撤消/重做功能是免费提供的。只是作为语言/工具箱/范例的自然结果出现。此外，Circle Draker测试了如何在源代码中实现对话框控制*，即在几个连续的GUI交互步骤之间保持相关上下文。最后但并非最不重要的一点是，测试了自定义绘图的易用性。</p><p>       The task is to create a simple but usable spreadsheet application. The spreadsheet should be scrollable. The rows should be numbered from 0 to 99 and the columns from A to Z. Double-clicking a cell  C lets the user change  C’s formula. After having finished editing the formula is parsed and evaluated and its updated value is shown in  C. In addition, all cells which depend on  C must be reevaluated. This process repeats until there are no more changes in the values of any cell (change propagation). Note that one should not just recompute the value of every cell but only of those cells that depend on another cell’s changed value. If there is an already provided spreadsheet widget it should not be used. Instead, another similar widget (like JTable in Swing) should be customized to become a reusable spreadsheet widget.</p><p>任务是创建一个简单但可用的电子表格应用程序。电子表格应该是可滚动的。行的编号应该从0到99，列的编号应该从A到Z。双击单元格C可以让用户更改C的公式。完成编辑后，将解析并计算公式，其更新值以C显示。此外，所有依赖于C的单元格都必须重新计算。重复此过程，直到任何单元格的值不再发生更改(更改传播)。请注意，不应该只重新计算每个单元格的值，而应该只重新计算那些依赖于另一个单元格的更改值的单元格的值。如果已经提供了电子表格小部件，则不应使用它。相反，应该定制另一个类似的小部件(如Swing中的JTable)，使其成为可重用的电子表格小部件。</p><p> Cells is a more authentic and involved task that tests if a particular approach also scales to a somewhat bigger application. The two primary GUI-related challenges are intelligent propagation of changes and widget customization. Admittedly, there is a substantial part that is not necessarily very GUI-related but that is just the nature of a more authentic challenge. A good solution’s change propagation will not involve much effort and the customization of a widget should not prove too difficult. The domain-specific code is clearly separated from the GUI-specific code. The resulting spreadsheet widget is reusable.</p><p>Cells是一个更真实、更复杂的任务，它测试特定的方法是否也可以扩展到更大的应用程序。与GUI相关的两个主要挑战是更改的智能传播和小部件定制。诚然，有很大一部分不一定与GUI相关，但这正是更真实挑战的本质。一个好的解决方案的更改传播不会涉及太多的工作，并且小部件的定制应该不会太困难。特定于域的代码与特定于GUI的代码明显分开。生成的电子表格小部件是可重用的。</p><p> Cells is directly inspired by the  SCells spreadsheet example from the book  Programming in Scala. Please refer to the book (or the implementations in this repository) for more details especially with respect to the not directly GUI-related concerns like parsing and evaluating formulas and the precise syntax and semantics of the spreadsheet language.</p><p>Cells的灵感直接来自“用Scala编程”一书中的SCells电子表格示例。请参考本书(或此存储库中的实现)了解更多详细信息，特别是关于与GUI无关的问题，如解析和计算公式以及电子表格语言的精确语法和语义。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://eugenkiss.github.io/7guis/tasks/">https://eugenkiss.github.io/7guis/tasks/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/gui/">#gui</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/guis/">#guis</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>