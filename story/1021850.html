<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>关于编译器警告设计的两点思考</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">关于编译器警告设计的两点思考</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-09-03 08:58:47</div><div class="page_narrow text-break page_content"><p>今天，我终于写下了一些关于编译器诊断设计的两个外围方面的思考，我认为这两个方面对某些类型的警告非常重要，我的第一个思考是关于修复程序，第二个是关于抑制机制。</p><p>现在大多数C++编译器并不只是告诉你发生了问题(就像ed的有名的？提示符)，以及问题是什么(例如，“预期标识符”)，他们会试图告诉您如何解决问题。</p><p>将GCC 4.1的错误消息与GCC 4.6的错误消息进行比较。(Godbol.)对于此输入：</p><p>GCC 4.1只是抱怨您在一个声明中放入了多个类型，而GCC4.6更有帮助的是抱怨它应该在结构定义之后，并指出它认为应该插入分号的确切位置。</p><p>GCC 7更进一步，他建议了一个补丁--一个机器可读的“拼写检查建议”，一些IDE只需点击一下就可以应用。</p><p>用医学术语来说，编译器已经从简单地检测症状(“这个声明似乎包含两种类型，这不是有效的C++”)变成了对疾病的诊断(“我打赌您把分号忘在什么地方了”)；而支持修复的编译器实际上是在开一个治疗计划。这些步骤中的每一个在用户友好性和实现复杂性方面都比前一个步骤有了质的飞跃。</p><p>每个主流编译器都会对这个可疑的代码发出警告(GCC和碰壁；msvc带-W4)。以下是GCC的诊断：</p><p>警告：建议使用圆括号将赋值用作真值[-Wparenths]4|IF(argc=1)|~^~~</p><p>请注意，GCC甚至没有费心解释它的真正诊断是什么；它发出了一个被动的、攻击性的警告信息，除了建议如何关闭自己之外，什么也做不了！</p><p>当然，诊断结果是人们经常想写if(argc==1)，但是他们的手指滑倒了，他们改写if(argc=1)，不幸的是，这也是有效的C++代码。每个主流编译器都发展了相同的方法来处理这一问题：如果您真的想要=，那么您可以在表达式两边多加一对括号，如下所示：</p><p>额外的一对括号就是我所说的“抑制机制”，它只是一种使警告诊断静音的任意方式-告诉编译器“不，我真的想要编写这个合法但不寻常的构造。”</p><p>另一种众所周知的抑制机制是在未使用的结果前面写入(Void)，以使Wunused值和WunusedResult警告(Godbolt)静音：</p><p>在这里，编译器只想让您添加一对括号，以便为读者阐明优先顺序。</p><p>冥想：单个补丁必须保留(实际的)行为或(可能的)意图，但不能两者兼而有之。</p><p>程序员很容易“修复”像-Wunuse-result和-Wlogic-op-括号这样的诊断，因为他们只是要求程序员澄清已经非常清楚的意图：是的，我的意思是丢弃这个结果。是的，我是指评估(a&amp；&amp；b)||c。</p><p>更有趣的诊断是编译器认为它发现了代码的实际行为和程序员的意图之间的不匹配。我们上面的if(argc=1)示例是这样的。一个更现实的例子可能是这样的</p><p>当编译器为此警告建议修复程序时，它必须做出选择：我们是应该建议将代码的行为更改为您可能想要键入的修复程序-“拼写检查”选项？还是应该演示如何在保持现有代码行为的同时使警告静默-如果您愿意，还可以使用“添加到字典”选项？(或者，继续我们的医学类比，有“治疗”选项和“DNR”选项。)。</p><p>仅显示“Treatment”选项会使编译器陷入“建议”更改代码行为的尴尬境地，毕竟，这是完全合法的C++代码；盲目地将修复程序应用于正常工作的代码可能会破坏该代码。但是，仅显示“抑制”选项可能会鼓励程序员盲目地将修复程序应用于损坏的代码，从而保留错误，但使其更难在未来检测到。</p><p>对于某些类型的警告，Clang会同时显示两种修复程序。在Clang 10are(Godbolt)中有两个这样的示例：</p><p>警告：使用赋值结果作为不带括号的条件[-Wparenters]if(x=foo())~~^~注意：如果(x=foo())^()注意：如果(x=foo())^==，则使用括号将此赋值转换为相等比较。注意：如果(x=foo())^==，则使用&#39；==&#39；将此赋值转换为相等比较。</p><p>警告：&amp；的优先级低于！=；！=将首先计算[-Wparenology]return(foo()&amp；ask！=0)；^~注意：将圆括号放在&#39；！=&#39；表达式周围以使此警告返回静音(foo()&amp；ask！=0)；^()注意：将括号放在&amp；表达式两边以首先计算它的返回(foo()&amp；掩码！</p><p>请注意，在这两种情况下，Clang决定先打印“抑制”选项，然后再打印“治疗”选项。但有时Clang会先打印“治疗”选项，然后再打印“抑制”选项：</p><p>警告：&#39；strncmp&#39；调用中的大小参数是比较[-Wmemsize-比较]返回strncmp(a，b，len&lt；0)；~^~~注意：您是否想要比较&#39；strncmp&#39；的结果？Return strncmp(a，b，len&lt；0)；^~)备注：将参数显式强制转换为size_t，以使此警告保持静音。return strncmp(a，b，len&lt；0)；^(Size_T)()。</p><p>警告：Logical NOT仅应用于此比较的左侧[-Wlogic-NOT-PARROLATES]return x==y&amp；&amp；！x==z；^~~注意：在&#39；！&#39；之后添加括号以计算比较第一个返回x==y&amp；&amp；！x==z；^()注意：在左侧表达式两边添加括号以使此警告返回x==y&amp；&amp；！x==z；</p><p>当然，还有更多的情况下，Clang只发出“抑制”选项作为修复，让程序员自己解决“处理”问题。(GCC 10.2只为这四个示例中的最后一个发出了修复程序；它是“抑制”选项。)。</p><p>即使在没有任何机器可读的固定装置的情况下，警告信息本身的措辞也可以诱导人类读者从抑制或治疗的角度进行思考。警告消息可以表示为“请确认您的意思是X”；或者“您做了X；您的意思是Y吗？”；甚至可以说是“您尝试做Y的尝试失败了”。</p><p>我们在这里讨论的那种编译器警告基本上是这样的：“您写的是X，但我想您的意思是Y。”只有当X和Y在某种意义上接近时，才会发生这种情况。有时“接近”是语义上的，而不是语法上的(比如程序员想调用复制省略，但是编写代码返回std：：move(X))，但是为了我们今天的目的，让我们只考虑语法上的接近。你想写Y，但是一个小小的印刷错误导致你写了X。在上面的例子中，这些错误是类似于“省略1=”、“省略一对括号”或“把&lt；0放在括号内而不是放在括号外”之类的东西。</p><p>以X=“相等-比较！a到b”和Y=“否定a==b的意义”为例。有一些代码明显想要表达X，比如(！a)==(B)。有些代码明显想要表达Y，比如a！=b。但是您写的(！a==b)属于灰色区域：不清楚您真正想要表达的是X和Y中的哪一个。</p><p>编译器诊断开发人员的工作是在编译器认为“明确的X”的输入空间和认为“明确的Y”的输入空间之间创建一些分隔。本质上，我们通过故意增加不等价的C++程序对之间的编辑距离来创建纠错代码-故意增加程序员必须搞砸的键数，以便将正在工作(并且没有警告)的C++程序转换成不等价的(但没有警告的)C++程序。</p><p>此外，在Y比X更常用的情况下，编写Y应该比编写X相对容易。在我们的示例中，即使在核心语言级别也是如此：a！=b已经比！a==b更容易编写。但是，当我们增加X空间和Y空间之间的距离时，我们收缩X空间的幅度要大于收缩Y空间的程度。如果您真的想要表达！a==b，我们将强制您一直退回到(！a)==b。这有点类似于经济学或进化生物学中的信号传递原则：基本上，如果您希望编译器接受您的意图，那么您的代码必须采用一些繁琐且明显不适应的修饰，以证明其对编译器的价值。</p><p>根据动物界流行的性选择理论，当一只孔雀决定是否接受某一只孔雀时，她会用它的装饰尾巴来代表它的成功。一只尾巴又大又笨重的孔雀必须是健康和成功的，因此是孔雀的好配偶。一只尾巴不起眼的孔雀不值得与之交配。</p><p>当C++编译器决定是否无怨无悔地接受特定程序时，它会使用某些装饰性的语法花饰作为代码意图的代理。采用这些花饰的可疑代码段-比如说，带有额外括号的if((argc=1))，或(Void)x；，或strncmp(a，b，size_t(len&lt；0))-一定是故意的，因此对编译器来说是一个很好的匹配。缺少任何花边的有问题的代码段-例如，if(argc=1)或x；或strncmp(a，b，len&lt；0)-不值得取消警告。</p><p>这种沉思的好处是：在决定是否对粗略的构造发出警告时，先对绝对规则进行编码，比如“如果它被一对括号括起来，就不要发出警告(argc=1)。”但是，我们应该从相对规则的角度来思考--这些规则将程序员实际编写的代码的“装饰程度”与没有(假设)打字错误的代码的“装饰程度”进行比较。请注意：</p><p>截至2020年9月，朗和GCC都没有发现这种单字打字错误。他们看到子表达式(argc=2)用圆括号括起来，这足以抑制他们的警告。</p><p>我认为他们应该做的是将编写的程序与“已更正打字”的程序进行比较。</p><p>这显然是一个似是而非、平淡无奇的程序，所以程序员很有可能确实打错了=for==。如果程序员真的想在这种情况下使警告静音，我认为应该强迫程序员编写。</p><p>这是值得注意的，也是不可信的-它显然有过多的括号装饰！</p><p>换一种说法：编译器应该将可接受程序的空间分成“那些使用=且括号数量非常多的程序”和“那些使用==但括号数量不多的程序”。然后，出于警告诊断的目的，编译器应该实质上将=和==视为同义词；它可以依靠括号的数量来指示程序员的意图。</p><p>X==2；//哎呀，可能表示x=2bool help 1=argc=1；//oops，可能表示argc==1，因为这是合理的bool help 2=(argc=1)；//oops，可能表示(argc==1)bool help 3=((argc=1))；//OK：显然不是指((argc==1))int i1=(argc=1)？1：2；//OK：显然不是这个意思((argc==1))。</p><p>截至2020年9月，浪10.1和GCC 10.2在这些测试用例上表现不是很好。</p><p>这篇帖子的灵感来自于邮件列表帖子“[CFE-dev]括号旗帜警告”(2020年5月)。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://quuxplusone.github.io/blog/2020/09/02/wparentheses/">https://quuxplusone.github.io/blog/2020/09/02/wparentheses/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/警告/">#警告</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/design/">#design</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1020193.html"><img src="http://img.diglog.com/img/2020/8/thumb_9bd778cfcc328679893c549d5c444b89.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1020193.html">BPF可移植性和CO-Re(随处运行一次编译)</a></div><span class="my_story_list_date">2020-8-25 21:5</span></div><div class="col-sm"><div><a target="_blank" href="/story/1018508.html"><img src="http://img.diglog.com/img/2020/8/thumb_a498557a343dfd09fe4bac13a5a04699.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1018508.html">具有强类型的类NIM-Python编译语言</a></div><span class="my_story_list_date">2020-8-17 0:10</span></div><div class="col-sm"><div><a target="_blank" href="/story/1016549.html"><img src="http://img.diglog.com/img/2020/8/thumb_fe137f795d7a9df985fdb60dd4d99242.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1016549.html">编译器/ISA资源管理器：请参阅不同编译器的ARM、RISCV、x86输出</a></div><span class="my_story_list_date">2020-8-6 7:42</span></div><div class="col-sm"><div><a target="_blank" href="/story/1014241.html"><img src="http://img.diglog.com/img/2020/7/thumb_d762b13b874e4d5d38cd413d83c5baec.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1014241.html">Langcraft：将LLVM IR编译为“我的世界”数据包</a></div><span class="my_story_list_date">2020-7-26 17:8</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>