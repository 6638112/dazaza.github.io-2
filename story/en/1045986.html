<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Baleen Analytics：大规模数据过滤会带来意外的惊喜 Baleen Analytics: Large-scale filtering of data provides serendipitous surprises</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Baleen Analytics: Large-scale filtering of data provides serendipitous surprises<br/>Baleen Analytics：大规模数据过滤会带来意外的惊喜 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-23 18:47:19</div><div class="page_narrow text-break page_content"><p>January 7, 2021   Volume 18, issue 6        Baleen is a substance found in the mouths of the largest whales in the ocean. Similar to fingernails in its construction, baleen is used as a giant filter that allows these whales to scoop up vast amounts of seawater, while keeping the nutritious krill and other sea life as food. Krill are small crustaceans similar to shrimp. I think of them as &#34;shrimpy&#34; shrimp, yet they provide a large portion of the food consumed by the largest animals on earth.</p><p>2021年1月7日，第18卷，第6期在海洋中最大的鲸鱼的嘴中发现了Baleen。与构造中的指甲类似，baleen用作巨型过滤器，可使这些鲸鱼sc起大量海水，同时保持营养丰富的磷虾和其他海洋生物作为食物。磷虾是类似于虾的小型甲壳类动物。我认为它们是＆＃34; shrimpy＆＃34;虾，但是它们提供了地球上最大的动物消耗的大部分食物。</p><p>  Like these whales, data analytics is increasingly hoovering up anything it can find without regard to shape, form, or schema. By ingesting anything and everything, oblivious to its provenance or hygiene, we are finding patterns and insights that weren&#39;t available before. This is greatly accommodated by keeping the data in JSON, XML, Avro, or other semi-structured forms.</p><p>  像这些鲸鱼一样，数据分析越来越多地徘徊在它可以找到的所有内容上，而与形状，形式或模式无关。通过摄取任何事物，不管其来源或卫生状况如何，我们正在寻找以前无法获得的模式和见解。通过将数据保留为JSON，XML，Avro或其他半结构形式，可以极大地适应这种情况。</p><p> This article explores the implications of this &#34;late-bound&#34; schema for both data analytics and for messaging between services and microservices. It seems that a pretty good understanding among many different sources allows more flexibility and interconnectivity. Increasingly, flexibility dominates perfection.</p><p> 本文探讨了此“后期绑定”的含义。数据分析以及服务和微服务之间的消息传递的架构。似乎许多不同来源之间的很好理解可以提供更大的灵活性和互连性。灵活性越来越主导着完美。</p><p>   In the mid-&#39;90s, I helped build the architecture for the world&#39;s first transactional N-tier application platform.  It was a fantastic team and one of the highlights of my career.  Application developers created components and interfaces to them. Components were deployed across multiple servers with dynamic activation and load balancing as work flowed across clients, servers, and multiple databases with well-defined transactional behavior. RPCs (remote procedure calls) were based on the method calls in the interfaces, which were defined in advance.</p><p>   在90年代中期，我帮助构建了世界上第一个事务性N层应用程序平台的体系结构。这是一支出色的团队，是我职业生涯的亮点之一。应用程序开发人员创建了组件和它们的接口。随着工作跨客户端，服务器和具有明确定义的事务行为的多个数据库之间的工作流，组件可以动态激活和负载平衡地跨多个服务器部署。 RPC（远程过程调用）基于预先定义的接口中的方法调用。</p><p> We had many raucous and lively debates about the tradeoffs between early- and late-bound interfaces.   Early-bound interfaces are defined in advance. They specify the set of methods, access-control policies, and all that is needed to invoke a persnickety service that must have everything perfect to process a remote method call. Early-bound interfaces are kept in some form of shared repository where they may be sucked up by potential clients that will ensure perfect compliance. In many ways, this mirrored how components are used to compose monolithic single-process applications. Many of us thought that early binding was the ultimate evolutionary step for interfaces, providing the most intimate semantics for interchange.</p><p> 关于早绑定接口和后绑定接口之间的折衷，我们进行了许多激烈而生动的辩论。提前绑定的接口是预先定义的。它们指定方法集，访问控制策略以及调用持久性服务所需的所有内容，这些服务必须具有完美的一切来处理远程方法调用。早期绑定的接口以某种形式的共享存储库保存，潜在的客户端可能会将它们吸收，以确保完全合规。在许多方面，这反映了如何使用组件来组成整体式单进程应用程序。我们中的许多人认为，早期绑定是接口的最终进化步骤，为交互提供了最紧密的语义。</p><p> In contrast,  late-bound interfaces are far more loosey-goosey. A target service may document the approximate formats required in the semi-structured messages sent to a service. The service will take this information and figure out what it can, well, figure out. Usually, this works pretty well. Frequently, the target service is gradually enhanced to do a better job of scratching its head to make the most of the barely understandable garbage it receives from callers. Both SOAP (Simple Object Access Protocol) in its earliest incarnation and REST (Representational State Transformation) are examples of late-bound interface mechanisms.</p><p> 相反，后期绑定的接口要松散得多。目标服务可以记录发送给服务的半结构化消息中所需的近似格式。该服务将获取此信息并找出可以解决的问题。通常，这很好。通常，逐渐增强目标服务，以更好地发挥作用，以充分利用从调用方收到的几乎难以理解的垃圾。 SOAP（简单对象访问协议）最早的体现和REST（表示状态转换）都是后期绑定接口机制的示例。</p><p> In many ways, the difference between early- and late-bound interfaces is one of vision and goals. Early-bound offers a crispness and clarity of purpose. You are much more confident of the semantic tightness of the caller and the callee. This makes a lot of sense in a relatively small world where the combinatorics of interaction are relatively small; it can assist in debugging the interaction of the two components. On the other hand, when the set of called and calling components gets large, this same semantic tightness causes big challenges as components evolve over time. When the called and calling components are in different departments or even companies, the friction imposed on changes can be overwhelming.</p><p> 在许多方面，早期和晚期绑定界面之间的差异是愿景和目标之一。早期绑定提供清晰明了的目的。您对调用方和被调用方的语义紧密性更有信心。在相对较小的世界中，交互作用的组合相对较小，这很有意义。它可以帮助调试两个组件的交互。另一方面，当一组被调用和被调用的组件变大时，随着组件随着时间的发展，这种相同的语义紧密性会带来很大的挑战。当被叫方和主叫方位于不同部门甚至公司内时，施加于更改的摩擦可能会变得不堪重负。 </p><p> Early distributed systems were evolving forward from single-server mainframes and minicomputers. The vision was an extension of the centralized machine to leverage the compute capabilities of multiple computers in a single data center under a single trust domain for one organization. Over the years, this has evolved toward a cacophony of loosely coupled services in different trust environments, each of which is moving forward at its own pace.  The ability to successfully interoperate has proven to be more valuable than crisp and clear semantics as components work together. While I didn&#39;t see this coming at first, it is obvious in the rear-view mirror.</p><p>早期的分布式系统正在从单服务器大型机和小型计算机发展而来。该愿景是对集中式计算机的扩展，以在一个组织的单个信任域下利用单个数据中心中的多台计算机的计算功能。多年来，这已演变为在不同信任环境中松散耦合服务的喧嚣，每种服务都以自己的步伐向前发展。当组件协同工作时，成功互操作的能力比清晰明了的语义更有价值。虽然我最初没有看到这种情况，但在后视镜中很明显。</p><p>   SQL is the dominant relational database language. Relational systems are brilliant, powerful, and used to hold and process a great deal of essential data, especially the data used to run companies. Relational algebra (the theoretical backbone of SQL) needs to have its schema well defined to describe how the data is structured into tables, rows, and columns. The schema is captured with DDL (Data Definition Language) in the database.</p><p>   SQL是主要的关系数据库语言。关系系统功能强大，功能强大，用于保存和处理大量基本数据，尤其是用于运营公司的数据。关系代数（SQL的理论主干）需要定义好其架构，以描述如何将数据构造为表，行和列。该模式是通过数据库中的DDL（数据定义语言）捕获的。</p><p> SQL&#39;s schema is early-bound. It is declared and may be transactionally updated. If the DDL is changed in the database using a transaction, a new DDL is used to define the behavior of queries after the change. The old DDL was in effect before the change. At any point in time, there is a single structure for the DDL that defines the shape and form of the database and how to query it.</p><p> SQL模式是早期绑定的。它已声明，并且可以进行事务更新。如果使用事务在数据库中更改了DDL，则使用新的DDL定义更改后查询的行为。旧的DDL在更改之前生效。在任何时间点，DDL都有一个单一的结构，它定义了数据库的形状和形式以及如何查询它。</p><p> SQL has excelled at OLTP (online transaction processing). This supports active online updates from thousands of concurrent users. Many systems also excel at OLAP (online analytical processing), in which complex and frequently large queries are processed against large collections of data. Systems are getting better at processing OLAP queries against rapidly changing OLTP data, but it is a difficult challenge.</p><p> SQL在OLTP（在线事务处理）方面表现出色。这支持来自数千个并发用户的活动在线更新。许多系统在OLAP（在线分析处理）方面也很出色，其中针对大型数据集处理复杂且频繁的大型查询。系统在针对快速变化的OLTP数据处理OLAP查询方面变得越来越好，但这是一个艰巨的挑战。</p><p> One approach to meet this challenge is to move data out of the OLTP system to somewhere where it may be more easily processed without interfering with the online transaction work. A common technique is to process the transaction system&#39;s logs as they flow to the storage used by the database. In this fashion, a slightly lagging analytical system may be kept. The shape and form of the schema for that slightly old data are captured in the DDL as of the point in time when the updates were performed. To understand this data properly, you must understand the point-in-time schema.</p><p> 应对这一挑战的一种方法是将数据移出OLTP系统，移至可以更轻松地处理而又不影响在线交易工作的地方。一种常见的技术是在交易系统日志流到数据库使用的存储时对其进行处理。以这种方式，可以保持稍微落后的分析系统。从执行更新的时间点开始，在DDL中捕获了稍旧数据的架构的形状和形式。为了正确理解此数据，您必须了解时间点模式。</p><p> Interpreting the dynamic SQL as a point-in-time SQL leads to capturing the image of the data and its schema together. As time goes on, you have many sets of data, each with its own schema, and you want to analyze these together. It is not uncommon to project this data as semi-structured objects in JSON derived from the database data. 1 This is especially convenient since the semantics of the projected semi-structured objects contain their own schemas, which are meaningful as of the time the data was modified. They are self-describing. This is what I call  descriptive metadata. 2,4</p><p> 将动态SQL解释为时间点SQL会导致同时捕获数据映像及其架构。随着时间的流逝，您将拥有许多数据集，每组数据都有其自己的架构，并且您希望一起分析这些数据。将此数据投影为从数据库数据派生的JSON中的半结构化对象并不少见。 1这特别方便，因为投影的半结构化对象的语义包含它们自己的模式，这些模式在修改数据时就有意义。他们是自我描述的。这就是我所说的描述性元数据。 2,4</p><p>   Typically, a SQL database is not the only source of data. Nowadays, there are sensors, camera feeds, event streams, uploads from who knows where, change data from partners, analyses of customer trends, newsfeeds, and much, much more. There is an onslaught of new data as a company rolls out more servers to hold the data, either virtual or physical. All of this data has some form of metadata describing what it means. The metadata may be on the objects or events, or it may be on a data set or event stream. Still, without metadata, it&#39;s likely you&#39;ll fire up some software to discern patterns and then attach metadata.</p><p>   通常，SQL数据库不是唯一的数据源。如今，有传感器，摄像机供稿，事件流，从谁知道哪里的上传，来自合作伙伴的数据更改，客户趋势分析，新闻供稿等等。随着公司推出更多的服务器来保存虚拟或物理数据的新数据激增。所有这些数据都具有描述其含义的某种形式的元数据。元数据可以在对象或事件上，也可以在数据集或事件流上。不过，如果没有元数据，您可能会启动一些软件来识别模式，然后附加元数据。 </p><p> As machine learning has advanced, it is getting more practical to find patterns by examining the raw data. Semi-structured data objects generally have a hierarchy, and each node in the hierarchy is labeled. Even when different objects have different metadata, and come from different sources, we are finding more and more success by comparing and contrasting these different objects and labeling similar things. Semantically, this can be thought of as decorating the individual objects with new attributes as patterns are detected. While learning, this is an iterative process where the patterns emerge after correlating attributes added to new data with attributes on old data. After a while, the machine learning becomes proficient enough to do pretty well as new data arrives.</p><p>随着机器学习的发展，通过检查原始数据来找到模式变得越来越实用。半结构化数据对象通常具有层次结构，并且该层次结构中的每个节点都被标记。即使不同的对象具有不同的元数据并且来自不同的来源，我们也可以通过比较和对比这些不同的对象并标记相似的事物来找到越来越多的成功。在语义上，这可以被认为是在检测到模式时用新属性装饰单个对象。在学习时，这是一个反复的过程，其中模式是在将添加到新数据的属性与旧数据的属性相关联之后出现的。一段时间后，随着新数据的到来，机器学习变得足够熟练，可以做得很好。</p><p>   ETL (extract, transform, and load) is a venerable mechanism for downloading data from a system with a well-established schema and converting the data to a target schema. Sometimes this loses some of the knowledge because the schema mappings aren&#39;t perfect. 3,4 For decades, this has been the tried-and-true mechanism for sharing data across independent systems.</p><p>   ETL（提取，转换和加载）是一种古老的机制，用于从具有完善模式的系统中下载数据并将数据转换为目标模式。有时，这会丢失一些知识，因为架构映射不是很完美。 3,4数十年来，这一直是在独立系统之间共享数据的久经考验的机制。</p><p> ELT (extract, load, and transform) is somewhat different. In this scheme, the target system sucks up the data even without the schema. Typically, there&#39;s some subset of the needed schema in the semi-structured object, but not always. By examining the data in the object and looking for patterns, the system can assign an interpretation.</p><p> ELT（提取，加载和转换）有所不同。在这种方案中，即使没有模式，目标系统也会吸收数据。通常，半结构化对象中有一些所需模式的子集，但并非总是如此。通过检查对象中的数据并查找模式，系统可以分配解释。</p><p> ELT, with its deferred metadata assignment, has advantages and disadvantages. Like late binding on procedure calls across services, ELT is much more adaptive and accepting of differences and evolution. Also, like late binding, it may not perfectly match the semantics but rather give &#34;good enough&#34; answers.</p><p> ELT及其延迟的元数据分配具有优点和缺点。像延迟绑定跨服务的过程调用一样，ELT更具适应性，可以接受差异和演进。此外，就像后期绑定一样，它可能无法完全匹配语义，而是会给与“足够好”的提示。答案。</p><p>   When you think about shredding documents, you think about ensuring the paper is in tiny pieces that are impossible to understand. In complex analytic environments, it&#39;s the other way around. You can find attributes of data with the same metadata as those in other documents. By finding commonality, or pretty good commonality, you can group together the values of these attributes from many documents. Separating a document into its constituent attributes and storing them separately is called  shredding.</p><p>   当您考虑分解文档时，您会考虑确保将纸张分成无法理解的细小片段。在复杂的分析环境中，反之亦然。您可以找到具有与其他文档相同的元数据的数据属性。通过找到通用性或相当好的通用性，可以将许多文档中的这些属性的值组合在一起。将文档分成其组成属性，然后分别存储它们称为切碎。</p><p> Sometimes, all the attributes in a document are shredded into these groupings. Other times, some attributes don&#39;t fit well with others and are left in their original document. Depending on the content of the document, the shredded representation may be complete enough to reconstitute the original document if needed. In this case, you can discard the original without losing data.</p><p> 有时，文档中的所有属性都被分解为这些分组。有时，某些属性与其他属性不太匹配，因此保留在原始文档中。根据文档的内容，切细的表示可能足够完整，可以根据需要重新构成原始文档。在这种情况下，您可以丢弃原始文件而不会丢失数据。</p><p> By putting these related attributes next to each other, it is possible to view them as a column and create super-fast, column-oriented analytics. When this happens, the system is scooping up data, organizing it by inferred relation, and creating fast analytic capacity. As more data is ingested, it is reorganized to support fast queries. Additional information is continuously merged into the old. Now, very fast analytics can be performed over the shredded input documents.</p><p> 通过将这些相关属性并排放置，可以将它们视为一列，并创建超快速的，面向列的分析。发生这种情况时，系统将收集数据，通过推断的关系对其进行组织，并创建快速的分析能力。随着吸收更多数据，将对其进行重组以支持快速查询。附加信息将不断合并到旧的文件中。现在，可以对切碎的输入文档执行非常快速的分析。 </p><p>   Data lakes are centralized repositories for structured, unstructured, and semi-structured data. For many companies, public clouds make data lakes possible. These clouds require a lot of technology to build and operate. The collections of disparate data can be big, ginormous, or relatively small. Nowadays, it is not too complex to gather the data, name it, and provide read access. What  is complex, independent of size, is reasoning about all the different schema and data contained within.</p><p>数据湖是用于结构化，非结构化和半结构化数据的集中存储库。对于许多公司而言，公共云使数据湖成为可能。这些云需要大量技术来构建和运行。完全不同的数据集合可能很大，庞大或相对较小。如今，收集数据，命名和提供读取访问权限并不太复杂。复杂的，不受大小限制的是对其中包含的所有不同架构和数据的推理。</p><p> We are progressing beyond expecting that everything is in a single database. Rather, we see an out-of-tune chorus of different representations, sources, and metadata. It is no longer possible to expect a tight understanding of all the details and nuances of the combined data. Increasingly, getting &#34;pretty good&#34; insights across these many disparate sources is valuable. Indeed, frequently it is vital.</p><p> 我们的进展超出了预期，一切都在一个数据库中。而是，我们看到了不同表示形式，来源和元数据的不合时宜的合唱。不再期望对合并数据的所有细节和细微差别有深入的了解。越来越多地变得“很好”。对许多不同来源的见解是有价值的。确实，这经常是至关重要的。</p><p> Blue whales are believed to be the largest animals to have ever lived on Earth. Some humongous blue whales have been known to engulf up to 220 tons of krill-laden seawater at a time and filter it through the baleen in their mouths. In this way, they can keep only the best stuff to be swallowed and processed, and to enrich the ocean water with the output.</p><p> 蓝鲸被认为是地球上曾经生活过的最大的动物。已知一些巨大的蓝鲸一次吞噬多达220吨的磷虾海水，并通过口中的鲸蜡过滤。这样，他们只能保留最好的东西被吞咽和加工，并用产出物丰富海水。</p><p> In the newly emerging data lakes, data ponds, and data oceans, it is incredibly valuable to have systems that ingest, analyze, and label data with meaningful (or partly meaningful) metadata. Recent advances in pattern matching and machine learning are now creating surprisingly useful output. Just like blue whales.</p><p> 在新兴的数据湖，数据池和数据海洋中，拥有使用有意义的（或部分有意义的）元数据来摄取，分析和标记数据的系统非常有价值。模式匹配和机器学习的最新进展现在正在产生令人惊讶的有用输出。就像蓝鲸。</p><p>   1. Helland, P. 2005. Data on the outside vs. data on the inside.  Proceedings of the Conference on Innovative Data Systems Research (CIDR);  http://cidrdb.org/cidr2005/papers/P12.pdf.</p><p>   1. Helland，P.2005。外部数据与内部数据的比较。创新数据系统研究会议（CIDR）会议录； http://cidrdb.org/cidr2005/papers/P12.pdf。</p><p> 2. Helland, P. 2011. If you have too much data, then &#34;good enough&#34; is good enough.  acmqueue 9(5);  https://queue.acm.org/detail.cfm?id=1988603.</p><p> 2. Helland，P.2011。如果您有太多数据，则表示“足够好”。足够好排队9（5）; https://queue.acm.org/detail.cfm?id=1988603。</p><p>    Pat Helland has been implementing transaction systems, databases, application platforms, distributed systems, fault-tolerant systems, and messaging systems since 1978. For recreation, he occasionally writes technical papers. He works at Salesforce. Pat&#39;s blog is at  pathelland.substack.com</p><p>    自1978年以来，Pat Helland一直在实施事务处理系统，数据库，应用程序平台，分布式系统，容错系统和消息传递系统。出于娱乐目的，他偶尔撰写技术论文。他在Salesforce工作。 Pat的博客位于pathelland.substack.com </p><p>   Originally published in Queue vol. 18, no. 6— see this item in the  ACM Digital Library</p><p>最初发表于Queue vol。 18号6-请参阅ACM数字图书馆中的此项</p><p> Related: Pat Helland -   Data on the Outside vs. Data on the Inside This article describes the impact of services and trust on the treatment of data. It introduces the notions of inside data as distinct from outside data. After discussing the temporal implications of not sharing transactions across the boundaries of services, the article considers the need for immutability and stability in outside data. This leads to a depiction of outside data as a DAG of data items being independently generated by disparate services.</p><p> 相关信息：Pat Helland-外部数据与内部数据本文描述了服务和信任对数据处理的影响。它介绍了内部数据与外部数据不同的概念。在讨论了不跨服务边界共享事务的时间含义之后，本文考虑了外部数据不变性和稳定性的需求。这导致将外部数据描述为由不同服务独立生成的数据项的DAG。</p><p>  Kate Matsudaira -   The Science of Managing Data Science What are they doing all day? When I first took over as VP of Engineering at a startup doing data mining and machine learning research, this was what the other executives wanted to know. They knew the team was super smart, and they seemed like they were working really hard, but the executives had lots of questions about the work itself. How did they know that the work they were doing was the &#34;right&#34; work? Were there other projects they could be doing instead? And how could we get this research into the hands of our customers faster?</p><p>  Kate Matsudaira-管理数据科学的科学他们整天在做什么？当我第一次在一家从事数据挖掘和机器学习研究的初创公司担任工程副总裁时，这就是其他高管想要知道的。他们知道团队非常聪明，他们似乎在努力工作，但是高管们对工作本身有很多疑问。他们怎么知道他们正在做的工作是正确的＆＃34;工作？他们还有其他项目可以代替吗？怎样才能使这项研究更快地掌握在客户手中？</p><p>  Lucian Carata, Sherif Akoush, Nikilesh Balakrishnan, Thomas Bytheway, Ripduman Sohan, Margo Seltzer, Andy Hopper -   A Primer on Provenance Assessing the quality or validity of a piece of data is not usually done in isolation. You typically examine the context in which the data appears and try to determine its original sources or review the process through which it was created. This is not so straightforward when dealing with digital data, however: the result of a computation might have been derived from numerous sources and by applying complex successive transformations, possibly over long periods of time.</p><p>  Lucian Carata，Sherif Akoush，Nikilesh Balakrishnan，Thomas Bytheway，Ripduman Sohan，Margo Seltzer和Andy Hopper-来源入门评估数据质量或有效性通常不是孤立进行的。通常，您会检查数据出现的上下文，并尝试确定其原始来源或查看创建数据的过程。但是，在处理数字数据时，这并不是那么简单：计算的结果可能来自许多来源，并且可能需要很长时间才能应用复杂的连续变换。</p><p>  Zachary Hensley, Jibonananda Sanyal, Joshua New -   Provenance in Sensor Data Management In today’s information-driven workplaces, data is constantly being moved around and undergoing transformation. The typical business-as-usual approach is to use e-mail attachments, shared network locations, databases, and more recently, the cloud. More often than not, there are multiple versions of the data sitting in different locations, and users of this data are confounded by the lack of metadata describing its provenance or in other words, its lineage. The ProvDMS project at the Oak Ridge National Laboratory (ORNL) described in this article aims to solve this issue in the context of sensor data.</p><p>  Zachary Hensley，Jibonananda Sanyal，Joshua New-传感器数据管理的起源在当今信息驱动的工作场所中，数据不断地移动和转换。通常的常规做法是使用电子邮件附件，共享的网络位置，数据库，以及最近使用的云。通常，数据的多个版本位于不同的位置，并且由于缺乏描述其出处或换句话说沿袭的元数据而使该数据的用户感到困惑。本文所述的Oak Ridge国家实验室（ORNL）的ProvDMS项目旨在解决传感器数据方面的此问题。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://queue.acm.org/detail.cfm?id=3446917">https://queue.acm.org/detail.cfm?id=3446917</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/过滤/">#过滤</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/analytics/">#analytics</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>