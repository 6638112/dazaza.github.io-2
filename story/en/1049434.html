<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>XSS攻击示例和缓解措施 XSS Attack Examples and Mitigations</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">XSS Attack Examples and Mitigations<br/>XSS攻击示例和缓解措施 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-26 02:35:30</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/b8c8aecbdbcbb5d67099db3dc96d8041.png"><img src="http://img2.diglog.com/img/2021/2/b8c8aecbdbcbb5d67099db3dc96d8041.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Cross-site scripting (XSS) is an attack that allows JavaScript from one site to run on another. XSS is interesting not due to the technical difficulty of the attack but rather because it exploits some of the core security mechanisms of web browsers and because of its sheer pervasiveness. Understanding XSS and its mitigations provides substantial insight into how the web works and how sites are safely (and unsafely) isolated from each other.</p><p>跨站点脚本（XSS）是一种攻击，它允许一个站点中的JavaScript在另一站点上运行。 XSS之所以有趣，并不是因为攻击的技术难度，而是因为它利用了Web浏览器的某些核心安全机制，并且由于其无处不在。了解XSS及其缓解措施可提供有关Web如何工作以及站点如何安全（和不安全地）彼此隔离的大量见解。</p><p>  Initially the web was a collection of static HTML documents that the browser would render for users to view. As the web grew, demands for richer documents grew, which led to the development of JavaScript and cookies: JavaScript to make documents interactive and cookies to allow browsers to save the state of a document.</p><p>  最初，网络是静态HTML文档的集合，浏览器将呈现这些HTML文档供用户查看。随着网络的发展，对更丰富的文档的需求也在增长，这导致了JavaScript和cookie的发展：使文档具有交互性的JavaScript和允许浏览器保存文档状态的cookie。</p><p> The advent of these features led to browsers not only rendering HTML documents, but also providing an in-memory representation of the document called the Document Object Model (DOM) as an API to the document for developers. The DOM gave developers a tree-based representation of the HTML tags of a document and also access to cookies to retrieve the state of the document. As time went on, the DOM went from a largely read-only structure to a read-write structure where updating the DOM would lead to re-rendering of the document.</p><p> 这些功能的出现导致浏览器不仅呈现HTML文档，而且还提供文档的内存表示形式，称为文档对象模型（DOM），作为开发人员文档的API。 DOM为开发人员提供了文档HTML标签的基于树的表示形式，并且还可以访问cookie来检索文档的状态。随着时间的流逝，DOM从基本上是只读的结构变成了读写结构，在这种结构中，更新DOM将导致文档的重新呈现。</p><p> Once documents gained the ability to execute code, browsers needed to define the execution context for JavaScript programs. The policy that was developed is called the Same-Origin policy and is still one of the fundamental security primitives of browser security. Originally, the Same-Origin policy stated that JavaScript within one document can only access its own DOM and the DOMs of other documents with the same origin. Later when  XMLHttpRequest (and now  Fetch) were added, a modified version of the same origin policy followed. These APIs could issue requests to any origin, they could only read the response to requests from the same origin.</p><p> 一旦文档具有执行代码的能力，浏览器​​就需要为JavaScript程序定义执行上下文。所开发的策略称为“同源策略”，仍然是浏览器安全性的基本安全性原语之一。最初，Same-Origin策略指出，一个文档中的JavaScript只能访问其自己的DOM以及具有相同来源的其他文档的DOM。后来，当添加XMLHttpRequest（和现在的Fetch）时，紧接着是同一原始策略的修改版本。这些API可以向任何来源发出请求，它们只能读取对来自相同来源的请求的响应。</p><p> What exactly is an origin? It’s the tuple of protocol, hostname, and port of a document.</p><p> 原产地到底是什么？它是协议，主机名和文档端口的元组。</p><p>  Figure 1: Scheme, host, and port of this url is the tuple that composes a browser origin.</p><p>  图1：此URL的方案，主机和端口是组成浏览器起源的元组。</p><p>  Figure 2: An illustration of the Same-Origin in action. JavaScript running on www.evil.com is unable to access the DOM of www.example.com.</p><p>  图2：实际中的“同源源”示意图。在www.evil.com上运行的JavaScript无法访问www.example.com的DOM。 </p><p> The Same-Origin policy has been great in mitigating attacks on static sites as illustrated in Figure (2). However, attacks on dynamically generated sites that accept user input have been quite difficult because the web allows mixing of code and data. Mixing code and data allows attacker-controlled input to execute within the origin of the document.</p><p>如图2所示，Same-Origin策略在缓解对静态站点的攻击方面非常有用。但是，对动态生成的接受用户输入的站点进行攻击非常困难，因为Web允许混合代码和数据。混合代码和数据使攻击者控制的输入可以在文档的原点内执行。</p><p>  Reflected and stored XSS attacks are fundamentally the same, as they both rely on malicious input being sent to the backend server and the server (at some point) presenting that input to the user. Reflected XSS occurs immediately, usually in the form of a maliciously crafted link by the attacker that the victim then clicks. Stored XSS occurs when the attacker uploads malicious input that is later displayed to the user. DOM-based attacks are different in that they occur purely client-side and involve malicious input manipulating the DOM.</p><p>  反射和存储的XSS攻击在本质上是相同的，因为它们都依赖于将恶意输入发送到后端服务器以及服务器（在某个时候）将输入呈现给用户。反射的XSS会立即发生，通常以攻击者恶意点击的链接的形式出现，然后受害者单击。当攻击者上传恶意输入并随后向用户显示时，就会发生存储的XSS。基于DOM的攻击的不同之处在于，它们仅在客户端发生，并且涉及操纵DOM的恶意输入。</p><p> If you didn’t fully grasp the forms above, don’t worry, they’ll make more sense as we cover some examples below.</p><p> 如果您不完全掌握上面的表格，请放心，我们在下面介绍一些示例时，它们会更有意义。</p><p>   Below you can see a simple Go-based web application that “reflects” its input (even if it’s a malicious script) back to the user. You can run this application by saving it in a file called  xss1.go and then typing  go run xss1.go.</p><p>   在下面，您可以看到一个简单的基于Go的网络应用程序，该应用程序会将其输入（即使是恶意脚本）“反射”回用户。您可以通过以下方式运行该应用程序：将其保存在名为xss1.go的文件中，然后键入go runxss1.go。</p><p> package  main import (  &#34;fmt&#34;  &#34;log&#34;  &#34;net/http&#34;) func  handler( w  http. ResponseWriter,  r  * http. Request) {  w. Header(). Set( &#34;X-XSS-Protection&#34;,  &#34;0&#34;)  messages,  ok  :=  r. URL. Query()[ &#34;message&#34;]  if ! ok {  messages = [] string{ &#34;hello, world&#34;} }  fmt. Fprintf( w,  &#34;&lt;html&gt;&lt;p&gt;%v&lt;/p&gt;&lt;/html&gt;&#34;,  messages[ 0])} func  main() {  http. HandleFunc( &#34;/&#34;,  handler)  log. Fatal( http. ListenAndServe( &#34;127.0.0.1:8080&#34;,  nil))}</p><p> 包主要导入（＆＃34; fmt＆＃34;＆＃34; log＆＃34;＆＃34; net / http＆＃34;）func handler（w http.ResponseWriter，r * http.Request）{w。标头（）。设置（＆＃34; X-XSS-Protection＆＃34 ;,＆＃34; 0＆＃34;）消息，确定：= r。网址。 Query（）[＆＃34; message＆＃34;]如果！好的{消息= []字符串{＆＃34; hello，world＆＃34;}} fmt。 Fprintf（w，＆＃34;＆lt; p＆gt;％v＆lt; / p＆gt;＆lt; / html＆gt;＆＃34 ;, messages [0]）} func main（）{http。 HandleFunc（＆＃34; /＆＃34 ;, handler）日志。致命的（http。ListenAndServe（＆＃34; 127.0.0.1：8080＆＃34 ;, nil））}</p><p> Figure 3: An example of a web application with a reflected XSS attack in it.</p><p> 图3：其中包含反射的XSS攻击的Web应用程序示例。</p><p>   Take a look at the source, and you’ll see the server returned a document that looks something like the one in Figure (4). Note how the mixing of code and data allowed this attack to occur.</p><p>   看一下源代码，您将看到服务器返回了一个文档，该文档看起来类似于图（4）中的文档。请注意，代码和数据的混合是如何使这种攻击发生的。 </p><p>   Admittedly, this may seem like a somewhat contrived example because XSS protection was explicitly disabled. However this form of XSS protection has always been heuristic-based with a variety of workarounds for different browsers. It was disabled to create simple cross-browser examples that illustrate the core concepts of XSS attacks. Furthermore, some browsers are removing these heuristic-based XSS protections, for  example if you are running Chrome 78 or above, you don’t need to include the  w.Header().Set(&#34;X-XSS-Protection&#34;, &#34;0&#34;) line for this attack to work.</p><p>不可否认，由于XSS保护已被明确禁用，因此这似乎是一个有些人为的例子。但是，这种形式的XSS保护始终基于启发式，并针对不同的浏览器提供了多种解决方法。禁止创建简单的跨浏览器示例来说明XSS攻击的核心概念。此外，某些浏览器正在删除这些基于启发式的XSS保护，例如，如果您运行的是Chrome 78或更高版本，则无需包含w.Header（）。Set（＆＃34; X-XSS-Protection＆＃ 34;，＆＃34; 0＆＃34;）行才能使此攻击起作用。</p><p>  Stored XSS attacks are fundamentally similar to reflected attacks, the main difference being the attack payload comes from a datastore instead of directly from the input. For example, an attacker will upload the payload to the web application which will then be shown to every logged in user.</p><p>  存储的XSS攻击从根本上类似于反射式攻击，主要区别在于攻击有效载荷来自数据存储，而不是直接来自输入。例如，攻击者会将有效负载上传到Web应用程序，然后将其显示给每个登录的用户。</p><p> Below is a simple chat application written in Go that illustrates a stored XSS attack. You can run this application by saving it in a file called  xss2.go and then typing  go run xss2.go.</p><p> 以下是用Go语言编写的简单聊天应用程序，它说明了存储的XSS攻击。您可以通过以下方式运行该应用程序：将其保存在名为xss2.go的文件中，然后键入go runxss2.go。</p><p> package  main import (	 &#34;fmt&#34;	 &#34;log&#34;	 &#34;net/http&#34;	 &#34;strings&#34;	 &#34;sync&#34;) var  db [] string var  mu  sync. Mutex var  tmpl =  ` &lt;form action=&#34;/save&#34;&gt;  Message: &lt;input name=&#34;message&#34; type=&#34;text&#34;&gt;&lt;br&gt;  &lt;input type=&#34;submit&#34; value=&#34;Submit&#34;&gt; &lt;/form&gt; %v ` func  saveHandler( w  http. ResponseWriter,  r  * http. Request) {	 mu. Lock()	 defer  mu. Unlock()	 r. ParseForm()	 messages,  ok  :=  r. Form[ &#34;message&#34;]	 if ! ok {		 http. Error( w,  &#34;missing message&#34;,  500)	}	 db = append( db,  messages[ 0])	 http. Redirect( w,  r,  &#34;/&#34;,  301)} func  viewHandler( w  http. ResponseWriter,  r  * http. Request) {	 w. Header(). Set( &#34;X-XSS-Protection&#34;,  &#34;0&#34;)	 w. Header(). Set( &#34;Content-Type&#34;,  &#34;text/html; charset=utf-8&#34;)	 var  sb  strings. Builder	 sb. WriteString( &#34;&lt;ul&gt;&#34;)	 for  _,  message  :=  range  db {		 sb. WriteString( &#34;&lt;li&gt;&#34;  +  message  +  &#34;&lt;/li&gt;&#34;)	}	 sb. WriteString( &#34;&lt;/ul&gt;&#34;)	 fmt. Fprintf( w,  tmpl,  sb. String())} func  main() {	 http. HandleFunc( &#34;/&#34;,  viewHandler)	 http. HandleFunc( &#34;/save&#34;,  saveHandler)	 log. Fatal( http. ListenAndServe( &#34;127.0.0.1:8080&#34;,  nil))}</p><p> 包主要导入（＆＃34; fmt＆＃34;＆＃34; log＆＃34;＆＃34; net / http＆＃34;＆＃34; strings＆＃34;＆＃34; sync＆＃34;）var db [ ]字符串var mu sync。互斥变量var tmpl =`＆lt; form action =＆＃34; / save＆＃34;＆gt;消息：＆lt;输入名称=＆＃34;消息＆＃34; type =＆＃34; text＆＃34;＆lt; br＆gt; ＆lt;输入类型=＆＃34;提交＆＃34;值=＆＃34;提交＆＃34;＆gt; ＆lt; / form＆gt; ％v`func saveHandler（w http。ResponseWriter，r * http。Request）{mu。 Lock（）延迟亩。解锁（）r。 ParseForm（）消息，好的：= r。填写[＆＃34; message＆＃34;]如果！好的{http。错误（w，＆＃34;缺少消息＆＃34 ;, 500）} db = append（db，messages [0]）http。重定向（w，r，＆＃34; /＆＃34 ;, 301）} func viewHandler（w http。ResponseWriter，r * http。Request）{w。标头（）。设置（＆＃34; X-XSS-Protection＆＃34 ;,＆＃34; 0＆＃34;）w。标头（）。设置（＆＃34; Content-Type＆＃34 ;,＆＃34; text / html; charset = utf-8＆＃34;）var sb字符串。建造者_，消息：= range db {sb。）的WriteString（＆＃34;＆lt; ul＆gt;＆＃34;）。 WriteString（＆＃34;＆lt; li＆gt;＆＃34; +消息+＆＃34;＆lt; / li＆gt;＆＃34;）} sb。 WriteString（＆＃34;＆lt; / ul＆gt;＆＃34;）fmt。 Fprintf（w，tmpl，sb。String（））} func main（）{http。 HandleFunc（＆＃34; /＆＃34 ;, viewHandler）http。 HandleFunc（＆＃34; / save＆＃34 ;, saveHandler）日志。致命的（http。ListenAndServe（＆＃34; 127.0.0.1：8080＆＃34 ;, nil））}</p><p> Figure 5: An example of a web application with a stored XSS attack in it.</p><p> 图5：其中存储了XSS攻击的Web应用程序示例。</p><p>  The attack occurs in two phases. First, the attack payload is saved to the datastore in the  storeHandler function. Next, when the page is rendered in  viewHandler, the attack payload is directly added to the output.</p><p>  攻击分为两个阶段。首先，将攻击有效负载保存到storeHandler函数中的数据存储中。接下来，当页面在viewHandler中呈现时，攻击有效负载将直接添加到输出中。</p><p> Once again, the culprit is the allowing of mixing of data and code. The browser has no way to tell if the payload was intentional or malicious.</p><p> 再次，罪魁祸首是允许数据和代码混合。浏览器无法判断有效载荷是故意的还是恶意的。 </p><p>  DOM-based XSS attacks don’t involve the backend and occur purely client-side. They’re also quite interesting because modern web applications are moving logic to the client. DOM- based XSS attacks occur when user input is allowed to directly manipulate the DOM in unsafe ways. The good news for attackers is that the DOM has a wide variety of ways it can be abused, the most popular being  innerHTML and  document.write.</p><p>基于DOM的XSS攻击不涉及后端，而仅发生在客户端。它们也很有趣，因为现代的Web应用程序正在将逻辑转移到客户端。当允许用户输入以不安全的方式直接操作DOM时，就会发生基于DOM的XSS攻击。对于攻击者而言，好消息是DOM有多种可被滥用的方式，其中最流行的是innerHTML和document.write。</p><p> Below is an example of a web application that serves static content. It’s fundamentally the same as the reflected XSS example, but here the attack will occur entirely client- side. You can run this application by saving it in a file called  xss3.go and then typing  go run xss3.go.</p><p> 以下是提供静态内容的Web应用程序的示例。它与所反映的XSS示例基本相同，但此处的攻击将完全在客户端进行。您可以通过将其保存在名为xss3.go的文件中，然后键入go run xss3.go来运行该应用程序。</p><p> package  main import (  &#34;fmt&#34;  &#34;log&#34;  &#34;net/http&#34;) const  content =  `  &lt;html&gt;  &lt;head&gt;  &lt;script&gt;  window.onload = function() {  var params = new URLSearchParams(window.location.search);  p = document.getElementById(&#34;content&#34;)  p.innerHTML = params.get(&#34;message&#34;) 	 };  &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;p id=&#34;content&#34;&gt;&lt;/p&gt;  &lt;/body&gt; &lt;/html&gt; ` func  handler( w  http. ResponseWriter,  r  * http. Request) {  w. Header(). Set( &#34;X-XSS-Protection&#34;,  &#34;0&#34;)  fmt. Fprintf( w,  content)} func  main() {  http. HandleFunc( &#34;/&#34;,  handler)  log. Fatal( http. ListenAndServe( &#34;127.0.0.1:8080&#34;,  nil))}</p><p> 包主要导入（＆＃34; fmt＆＃34;＆＃34; log＆＃34;＆＃34; net / http＆＃34;）const content =`＆lt; html＆gt; ＆lt; head＆gt; ＆lt; script＆gt; window.onload = function（）{var params = new URLSearchParams（window.location.search）; p = document.getElementById（＆＃34; content＆＃34;）p.innerHTML = params.get（＆＃34; message＆＃34;）}; ＆lt; / script＆gt; ＆lt; / head＆gt; ＆lt;身体＆gt; ＆lt; p id =＆＃34; content＆＃34;＆gt;＆lt; / p＆gt; ＆lt; / body＆gt; ＆lt; / html＆gt; `func handler（w http。ResponseWriter，r * http。Request）{w。标头（）。设置（＆＃34; X-XSS-Protection＆＃34 ;,＆＃34; 0＆＃34;）fmt。 Fprintf（w，content）} func main（）{http。 HandleFunc（＆＃34; /＆＃34 ;, handler）日志。致命的（http。ListenAndServe（＆＃34; 127.0.0.1：8080＆＃34 ;, nil））}</p><p> Figure 6: An example of a web application with a DOM-based XSS attack in it.</p><p> 图6：其中包含基于DOM的XSS攻击的Web应用程序的示例。</p><p> To see this attack, navigate to  http://localhost:8080/?message=&#34;&lt;img src=1 onerror=alert(1);/&gt;&#34;. Note that the attack vector is slightly different, and the XSS sink  innerHTML won’t execute a script directly; however, it will add HTML elements which will then execute JavaScript. In the example given, an image element is added that executes JavaScript when an error occurs. The error always occurs because the attacker conveniently always provides an invalid source.</p><p> 要查看此攻击，请导航至http：// localhost：8080 /？message =＆＃34;＆lt; img src = 1 onerror = alert（1）; /＆gt;＆＃34;。请注意，攻击向量略有不同，并且XSS接收器innerHTML不会直接执行脚本。但是，它将添加HTML元素，然后将执行JavaScript。在给出的示例中，添加了一个图像元素，该图像元素在发生错误时执行JavaScript。由于攻击者总是方便地提供无效来源，因此总是会发生错误。</p><p> If you want to directly add a script element, you’ll have to use a different XSS sink. As we mentioned, you’re in luck because the DOM provides a wide variety of dangerous sinks. Replace the script element in Figure (6) with the script element in Figure (7) and navigate to the following URL  http://localhost:8080/?message=&#34;&lt;script&gt;alert(1);&lt;/script&gt;&#34;. This attack works because  document.write accepts script elements directly.</p><p> 如果要直接添加脚本元素，则必须使用其他XSS接收器。如前所述，您很幸运，因为DOM提供了多种危险的接收器。将图（6）中的脚本元素替换为图（7）中的脚本元素，并导航到以下URL http：// localhost：8080 /？message =＆＃34;＆lt; script＆gt; alert（1）;＆lt; / script＆gt;＆＃34;。发生这种攻击是因为document.write直接接受脚本元素。</p><p>    While not typically referred to as XSS attacks, a few related avenues exist that are worth mentioning.</p><p>    尽管通常不称为XSS攻击，但是存在一些值得一提的相关途径。 </p><p>  A related avenue of attack is incorrectly setting the  Content-Type of HTTP responses. This can occur both at the backend level (response has incorrect Content-Type header set) or if the browser tries to sniff the MIME type. Internet Explorer was particularly susceptible to this, with the classic example being an image upload service where an attacker uploads JavaScript instead. The browser sees the Content-Type was set to  image/jpg, but the payload contains JavaScript and executes JavaScript turning it into a XSS attack.</p><p>一种相关的攻击途径是错误地设置了HTTP响应的Content-Type。无论是在后端级别（响应设置了错误的Content-Type标头），还是在浏览器尝试嗅探MIME类型时，都可能发生这种情况。 Internet Explorer尤其容易受此影响，经典示例是图像上传服务，攻击者改为使用JavaScript上传服务。浏览器看到Content-Type设置为image / jpg，但是有效负载包含JavaScript，并执行JavaScript将其转变为XSS攻击。</p><p>  Another related avenue of attack is through URLs whose scheme is JavaScript. For example, imagine a website which allows the user to control the target of a link as in Figure (8). If the attacker can control the target, the attacker can provide a URL that executes JavaScript by using the JavaScript scheme.</p><p>  另一个相关的攻击途径是通过使用JavaScript方案的URL。例如，想象一个允许用户控制链接目标的网站，如图（8）所示。如果攻击者可以控制目标，则攻击者可以提供一个使用JavaScript方案执行JavaScript的URL。</p><p> To see this type of attack in action, you can run this application by saving it in a file called  xss4.go and then typing  go run xss4.go. To see the XSS attack, navigate to  http://localhost:8080?link=javascript:alert(1).</p><p> 要查看这种攻击的实际效果，您可以通过将应用程序保存在名为xss4.go的文件中，然后键入go run xss4.go来运行该应用程序。要查看XSS攻击，请导航至http：// localhost：8080？link = javascript：alert（1）。</p><p> package  main import (  &#34;fmt&#34;  &#34;log&#34;  &#34;net/http&#34;) func  handler( w  http. ResponseWriter,  r  * http. Request) {  w. Header(). Set( &#34;X-XSS-Protection&#34;,  &#34;0&#34;)  links,  ok  :=  r. URL. Query()[ &#34;link&#34;]  if ! ok {  messages = [] string{ &#34;example.com&#34;} }  fmt. Fprintf( w,  `&lt;html&gt;&lt;p&gt;&lt;a href=&#34;%v&#34;&gt;Next&lt;/p&gt;&lt;/html&gt;`,  links[ 0])} func  main() {  http. HandleFunc( &#34;/&#34;,  handler)  log. Fatal( http. ListenAndServe( &#34;127.0.0.1:8080&#34;,  nil))}</p><p> 包主要导入（＆＃34; fmt＆＃34;＆＃34; log＆＃34;＆＃34; net / http＆＃34;）func handler（w http.ResponseWriter，r * http.Request）{w。标头（）。设置（＆＃34; X-XSS-Protection＆＃34 ;,＆＃34; 0＆＃34;）链接，确定：= r。网址。 Query（）[＆＃34; link＆＃34;]如果！ ok {消息= []字符串{＆＃34; example.com＆＃34;}} fmt。 Fprintf（w，`＆lt; html＆gt;＆lt; p＆gt;＆lt; a href =＆＃34;％v＆＃34;＆gt; Next＆lt; / p＆gt;＆lt; / html＆gt;`，links [0]）} func main（ ）{http。 HandleFunc（＆＃34; /＆＃34 ;, handler）日志。致命的（http。ListenAndServe（＆＃34; 127.0.0.1：8080＆＃34 ;, nil））}</p><p>   Unfortunately, no single mitigation for XSS exists. If it did, XSS would not be the widespread and pervasive issue that it is. As seen in the previous section, the fundamental problem of XSS is caused by the lack of separation between code and data. Mitigations for XSS typically involve sanitizing data input (to make sure input does not contain any code), escaping all output (to make sure data is not presented as code), and re-structuring applications so code is loaded from well-defined endpoints.</p><p>   不幸的是，没有XSS的单一缓解措施。如果确实如此，那么XSS就不会成为普遍存在的问题。从上一节可以看出，XSS的根本问题是由于代码和数据之间缺乏分隔而引起的。 XSS的缓解措施通常包括清理数据输入（以确保输入不包含任何代码），转义所有输出（以确保数据不以代码形式显示）以及重新构造应用程序，以便从定义明确的端点加载代码。</p><p>  The first line of defense against XSS is input sanitization. Whenever accepting any data, ensure the format of the data is what you expect. In effect, this whitelists data to ensure that the application does not accept any code.</p><p>  抵御XSS的第一道防线是输入清理。每当接受任何数据时，请确保数据格式符合您的期望。实际上，此操作将数据列入白名单，以确保应用程序不接受任何代码。</p><p> Unfortunately, input sanitization is a hard problem. No general tooling or technique exists for all situations and all applications. The best bet is to structure your application such that it requires developers to think about the type of data that is being accepted and provide a convenient location where sanitization can not only be placed, but expected.</p><p> 不幸的是，输入清理是一个难题。对于所有情况和所有应用程序，都没有通用的工具或技术。最好的选择是对应用程序进行结构设计，使其要求开发人员考虑接受的数据类型，并提供一个方便的位置，不仅可以放置消毒，而且可以预期进行消毒。 </p><p> A good pattern when writing Go applications is to not have any of your application logic within your HTTP request handlers and to instead use your HTTP request handlers to parse and validate input, which is then sent off to some other package (or struct) that handles application logic. The request handlers become not only dead simple, but provide a convenient centralized location to look during code reviews to make sure input is being correctly sanitized.</p><p>编写Go应用程序时，一个好的模式是不要在HTTP请求处理程序中包含任何应用程序逻辑，而应使用HTTP请求处理程序来解析和验证输入，然后将其发送给其他可处理的包（或结构）应用逻辑。请求处理程序不仅变得非常简单，而且还提供了一个方便的集中位置，可以在代码检查期间进行查看，以确保正确地清理了输入。</p><p> Figure (9) shows how we could rewrite the saveHandler to work with the limitation that only ASCII characters  [A-Za-z\.] should be accepted.</p><p> 图（9）显示了我们如何重写saveHandler以限制仅应接受ASCII字符[A-Za-z \。]的工作。</p><p> func  saveHandler( w  http. ResponseWriter,  r  * http. Request) {	 r. ParseForm()	 messages,  ok  :=  r. Form[ &#34;message&#34;]	 if ! ok {		 http. Error( w,  &#34;missing message&#34;,  500)	}	 re  :=  regexp. MustCompile( `^[A-Za-z\\.]+$`)	 if  re. Find([]byte( messages[ 0])))  ==  &#34;&#34; {		 http. Error( w,  &#34;invalid message&#34;,  500)	} 	 db. Append( messages[ 0])	 http. Redirect( w,  r,  &#34;/&#34;,  301)}</p><p> func saveHandler（w http。ResponseWriter，r * http。Request）{r。 ParseForm（）消息，好的：= r。填写[＆＃34; message＆＃34;]如果！好的{http。 Error（w，＆＃34; missing message＆＃34 ;, 500）} re：= regexp。如果重新编译，则必须填写（`^ [A-Za-z \\。] + $`）。 Find（[] byte（messages [0]）））==＆＃34;＆＃34; {http。错误（w，＆＃34;无效的消息＆＃34 ;, 500）} db。附加（邮件[0]）http。重定向（w，r，＆＃34; /＆＃34 ;, 301）}</p><p>  While this may seem somewhat contrived, after all, a chat application typically has to accept much more than the limited characters in Figure (9). However, it should be noted that a lot of data that applications accept is quite structured. Addresses, phone numbers, zip codes, and much more haves inherent structure that can be validated.</p><p>  毕竟，尽管这看起来有些人为设计，但聊天应用程序通常必须接受的字符数量远远超过图（9）中的有限字符。但是，应该注意，应用程序接受的许多数据都是相当结构化的。地址，电话号码，邮政编码等都具有可以验证的固有结构。</p><p>  The next line of defense is output escaping. To continue with the example of a chat application, it had a telltale sight of an XSS bug: HTML was handwritten. In the case of the chat application, whatever was extracted from the database was injected directly into the output document.</p><p>  下一道防线是输出转义。继续以聊天应用程序为例，它清楚地看到了XSS错误：HTML是手写的。对于聊天应用程序，将从数据库中提取的所有内容直接注入到输出文档中。</p><p> The same application could be made substantially safer (even if code was injected into it) by escaping all unsafe output. In fact, this is exactly what the html/template package in Go does. Instead of handwriting the output document, using a templating language and using a contextually aware parser to escape data before it’s rendered will reduce the chances of malicious data being executed.</p><p> 通过转义所有不安全的输出，可以使同一应用程序实质上更安全（即使已将代码注入其中）。实际上，这正是Go中html / template包所做的。使用模板语言和上下文相关的解析器在呈现数据之前转义数据，而不是手写输出文档，这将减少执行恶意数据的机会。</p><p> Below is an example that uses the  html/template package. You can run this application by saving it in a file called  xss5.go and then typing  go run xss5.go.</p><p> 下面是使用html / template包的示例。您可以通过以下方式运行该应用程序：将其保存在名为xss5.go的文件中，然后键入go runxss5.go。 </p><p> package  main import (	 &#34;bytes&#34;	 &#34;html/template&#34;	 &#34;io&#34;	 &#34;log&#34;	 &#34;net/http&#34;	 &#34;sync&#34;) var  db [] string var  mu  sync. Mutex var  tmpl =  ` &lt;form action=&#34;/save&#34;&gt;  Message: &lt;input name=&#34;message&#34; type=&#34;text&#34;&gt;&lt;br&gt;  &lt;input type=&#34;submit&#34; value=&#34;Submit&#34;&gt; &lt;/form&gt; &lt;ul&gt;  {{ range  . }}   &lt;li&gt; {{ . }} &lt;/li&gt;  {{ end }}  &lt;/ul&gt;` func  saveHandler( w  http. ResponseWriter,  r  * http. Request) {	 mu. Lock()	 defer  mu. Unlock()	 r. ParseForm()	 messages,  ok  :=  r. Form[ &#34;message&#34;]	 if ! ok {		 http. Error( w,  &#34;missing message&#34;,  500)	}	 db = append( db,  messages[ 0])	 http. Redirect( w,  r,  &#34;/&#34;,  301)} func  viewHandler( w  http. ResponseWriter,  r  * http. Request) {	 w. Header(). Set( &#34;X-XSS-Protection&#34;,  &#34;0&#34;)	 w. Header(). Set( &#34;Content-Type&#34;,  &#34;text/html; charset=utf-8&#34;)	 t  :=  template. New( &#34;view&#34;)	 t,  err  :=  t. Parse( tmpl)	 if  err  !=  nil {		 http. Error( w,  err. Error(),  500)		 return	}	 var  buf  bytes. Buffer	 err =  t. Execute( &amp; buf,  db)	 if  err  !=  nil {		 http. Error( w,  err. Error(),  500)		 return	}	 io. Copy( w,  &amp; buf)} func  main() {	 http. HandleFunc( &#34;/&#34;,  viewHandler)	 http. HandleFunc( &#34;/save&#34;,  saveHandler)	 log. Fatal( http. ListenAndServe( &#34;127.0.0.1:8080&#34;,  nil))}</p><p>包主要导入（＆＃34; bytes＆＃34;＆＃34; html / template＆＃34;＆＃34; io＆＃34;＆＃34; log＆＃34;＆＃34; net / http＆＃34;＆＃ 34; sync＆＃34;）var db []字符串var mu sync。互斥变量var tmpl =`＆lt; form action =＆＃34; / save＆＃34;＆gt;消息：＆lt;输入名称=＆＃34;消息＆＃34; type =＆＃34; text＆＃34;＆lt; br＆gt; ＆lt;输入类型=＆＃34;提交＆＃34;值=＆＃34;提交＆＃34;＆gt; ＆lt; / form＆gt; ＆lt; ul＆gt; {{ 范围  。 }}＆lt; li＆gt; {{。 }}＆lt; / li＆gt; {{end}}＆lt; / ul＆gt;`func saveHandler（w http。ResponseWriter，r * http。Request）{mu。 Lock（）延迟亩。解锁（）r。 ParseForm（）消息，好的：= r。填写[＆＃34; message＆＃34;]如果！好的{http。错误（w，＆＃34;缺少消息＆＃34 ;, 500）} db = append（db，messages [0]）http。重定向（w，r，＆＃34; /＆＃34 ;, 301）} func viewHandler（w http。ResponseWriter，r * http。Request）{w。标头（）。设置（＆＃34; X-XSS-Protection＆＃34 ;,＆＃34; 0＆＃34;）w。标头（）。设置（＆＃34; Content-Type＆＃34 ;,＆＃34; text / html; charset = utf-8＆＃34;）t：=模板。 New（＆＃34; view＆＃34;）t，err：= t。如果err！= nil {http。 Error（w，err。Error（），500）返回} var buf字节。缓冲区err = t。如果err！= nil {http，则执行（＆amp; buf，db）。 Error（w，err。Error（），500）返回} io。复制（w，＆buf）} func main（）{http。 HandleFunc（＆＃34; /＆＃34 ;, viewHandler）http。 HandleFunc（＆＃34; / save＆＃34 ;, saveHandler）日志。致命的（http。ListenAndServe（＆＃34; 127.0.0.1：8080＆＃34 ;, nil））}</p><p>  Try the XSS attack used previously by navigating to  http://localhost:8080 and typing in  &lt;script&gt;alert(1);&lt;/script&gt; to the input box. Notice that the alert was not triggered.</p><p>  通过导航到http：// localhost：8080并输入＆lt; script＆gt; alert（1）;＆lt; / script＆gt ;，尝试使用以前使用的XSS攻击。到输入框。请注意，未触发警报。</p><p> To see what’s happening, open your browser console and take a look at the  li element in the DOM. Two properties are of interest:  innerHTML and  innerText.</p><p> 要查看发生了什么，请打开浏览器控制台并查看DOM中的li元素。有两个属性值得关注：innerHTML和innerText。</p><p>   Notice how using output escaping, we were able to cleanly separate code and data mitigating an XSS attack?</p><p>   请注意，如何使用输出转义，我们能够干净地分离代码和数据，从而减轻XSS攻击？</p><p>  Content Security Policy (CSP) allows web applications the ability to define a set of whitelisted sources to load content from (like scripts from). CSP can be leveraged to separate code and data by denying inline scripts and only loading scripts from certain sources.</p><p>  内容安全策略（CSP）允许Web应用程序定义一组白名单源，以从中加载内容（例如来自的脚本）。通过拒绝内联脚本并仅从某些来源加载脚本，可以利用CSP分离代码和数据。</p><p> Writing a CSP for small self-contained applications is straightforward — start with a policy that denies all sources by default then allow in a small set of trusted sources. However, writing an effective CSP for large sites has always been difficult. Once a site starts loading content from external sources, like embedding a Tweet, the CSP becomes large and unwieldy. Some developers give up entirely and include the  unsafe-inline directive, defeating the purpose of CSP altogether.</p><p> 为小型自包含应用程序编写CSP很简单-从默认情况下拒绝所有源的策略开始，然后允许一小部分受信任的源。但是，为大型站点编写有效的CSP一直很困难。一旦网站开始从外部源加载内容（例如嵌入Tweet），CSP就会变得庞大而笨拙。一些开发人员完全放弃了包含unsafe-inline指令，从而完全违反了CSP的目的。</p><p> To simplify writing a CSP, CSP3 introduced the  strict-dynamic directive. Instead of maintaining a large whitelist of trusted sources, applications generate a random number (nonce) each time a page is requested. This nonce is sent along with the headers of the page and embedded into  script tags. This directs browsers to trust those scripts with the matching nonce as well as any scripts they may load. This means instead of whitelisting the scripts and trying to find out what other scripts they load and then whitelisting them, and doing this recursive pattern over and over, you only have to whitelist the top-level script you are importing.</p><p> 为了简化编写CSP的过程，CSP3引入了严格动态指令。每次维护页面时，应用程序都会生成一个随机数（即刻），而不是维护大量的受信任源白名单。该随机数与页面的标题一起发送，并嵌入到脚本标记中。这指示浏览器信任具有匹配随机数的脚本以及它们可能加载的任何脚本。这意味着不必将脚本列入白名单并尝试找出它们加载了哪些其他脚本，然后将其列入白名单，并一遍又一遍地执行此递归模式，而只需将要导入的顶级脚本列入白名单。 </p><p> Google maintains an excellent resource on how to write an effective CSP using the strict-dynamic directive. Using the “Strict CSP” approach suggested by Google, let’s take a look at what a simple application that accepts user input and also embeds a tweet would look like. You can run this application by saving it in a file called  xss6.go and then typing  go run xss6.go.</p><p>对于如何使用strict-dynamic指令编写有效的CSP，Google拥有出色的资源。使用Google建议的“严格CSP”方法，让我们看一个接受用户输入并嵌入推文的简单应用程序的外观。您可以通过将其保存在名为xss6.go的文件中，然后键入go run xss6.go来运行该应用程序。</p><p> package  main import (	 &#34;bytes&#34;	 &#34;crypto/rand&#34;	 &#34;encoding/base64&#34;	 &#34;fmt&#34;	 &#34;html/template&#34;	 &#34;log&#34;	 &#34;net/http&#34;	 &#34;strings&#34;) const  scriptContent =  ` document.addEventListener(&#39;DOMContentLoaded&#39;, function () {  var updateButton = document.getElementById(&#34;textUpdate&#34;);  updateButton.addEventListener(&#34;click&#34;, function() {  var p = document.getElementById(&#34;content&#34;);  var message = document.getElementById(&#34;textInput&#34;).value;  p.innerHTML = message;  }); }; ` const  htmlContent =  ` &lt;html&gt;  &lt;head&gt;  &lt;script src=&#34;script.js&#34; nonce=&#34; {{  .  }} &#34;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;p id=&#34;content&#34;&gt;&lt;/p&gt;   &lt;div class=&#34;input-group mb-3&#34;&gt;  &lt;input type=&#34;text&#34; class=&#34;form-control&#34; id=&#34;textInput&#34;&gt;  &lt;div class=&#34;input-group-append&#34;&gt;  &lt;button class=&#34;btn btn-outline-secondary&#34; type=&#34;button&#34; id=&#34;textUpdate&#34;&gt;Update&lt;/button&gt;  &lt;/div&gt;  &lt;/div&gt;   &lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;en&#34;&gt;  &lt;a href=&#34;https://twitter.com/jack/status/20?ref_src=twsrc%5Etfw&#34;&gt;March 21, 2006&lt;/a&gt;  &lt;/blockquote&gt;  &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34;  nonce=&#34; {{  .  }} &#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt; ` func  generateNonce() ( string,  error) {	 buf  := make([] byte,  16)	 _,  err  :=  rand. Read( buf)	 if  err  !=  nil {		 return  &#34;&#34;,  err	}	 return  base64. StdEncoding. EncodeToString( buf),  nil} func  genera</p><p> 包主要导入（＆＃34; bytes＆＃34;＆＃34; crypto / rand＆＃34;＆＃34; encoding / base64＆＃34;＆＃34; fmt＆＃34;＆＃34; html / template＆＃34; ＆＃34; log /＃34;＆net / http＆＃34;＆＃34; strings＆＃34;）const scriptContent =`document.addEventListener（＆＃39; DOMContentLoaded＆＃39 ;, function（）{var updateButton = document.getElementById（＆＃34; textUpdate＆＃34;）; updateButton.addEventListener（＆＃34; click＆＃34 ;, function（）{var p = document.getElementById（＆＃34; content＆＃34;）; var message = document.getElementById（＆＃34; textInput＆＃34;）。value; p.innerHTML = message;}）;};`const htmlContent =`＆lt; html＆gt;＆lt; head＆gt;＆lt; script src =＆＃34 ; script.js＆＃34; nonce =＆＃34; {{。}}＆＃34;＆gt;＆lt; / script＆gt;＆lt; / head＆gt;身体＆lt; p id =＆＃34; content＆＃34 ;＆lt; / p＆gt;＆lt; div class =＆＃34; input-group mb-3＆＃34;＆gt;＆lt; input type =＆＃34; text＆＃34; class =＆＃34; form-control＆ ＃34; id =＆＃34; textInput＆＃34;＆gt;＆div; div class =＆＃34; input-group-append＆＃34;＆gt;＆lt; button class =＆＃34; btn btn-outline-secondary＆＃ 34 ;类型=＆＃34;按钮＆＃34; id =＆＃34; textUpdate＆＃34;＆gt; Update＆lt; / button＆gt; ＆lt; / div＆gt; ＆lt; / div＆gt; ＆lt; blockquote class =＆＃34; twitter-tweet＆＃34; data-lang = en＆＃34;＆gt; ＆lt; a href =＆＃34; https：//twitter.com/jack/status/20？ref_src = twsrc％5Etfw＆＃34;＆gt; 2006年3月21日＆lt; / a＆gt; ＆lt; / blockquote＆gt; ＆lt;脚本异步src =＆＃34; https：//platform.twitter.com/widgets.js&#34;随机数=＆＃34; {{。 }}＆＃34; charset =＆＃34; utf-8＆＃34;＆lt; / script＆gt; ＆lt; / body＆gt; ＆lt; / html＆gt; `func generateNonce（）（字符串，错误）{buf：= make（[] byte，16）_，err：= rand。如果err！= nil {return＆＃34;＆＃34 ;, err}返回base64，则读取（buf）。 StdEncoding。 EncodeToString（buf），nil}函数属</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://goteleport.com/blog/xss-attacks/">https://goteleport.com/blog/xss-attacks/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/攻击/">#攻击</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/attack/">#attack</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/xss/">#xss</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>