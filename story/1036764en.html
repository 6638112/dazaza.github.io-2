<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用Chez方案重建球拍编译器Rebuilding the Racket Compiler with Chez Scheme</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rebuilding the Racket Compiler with Chez Scheme<br/>用Chez方案重建球拍编译器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-27 03:44:59</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/6bbe240f837263559f0d1e1c66d69cb6.png"><img src="http://img2.diglog.com/img/2020/11/6bbe240f837263559f0d1e1c66d69cb6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Racket flaunts the title of being  the programmable programming language. With extensibility at its core, it takes metaprogramming to the next level by encouraging developers to implement their own DSLs to solve the problem at hand.</p><p>Racket标榜了可编程语言的名称。它以可扩展性为核心，通过鼓励开发人员实现自己的DSL来解决当前的问题，将元编程提升到一个新的水平。</p><p> Following this same principle, its development team attacks the complexity of writing a compiler by stacking layers of DSLs to implement many of its components.</p><p> 遵循相同的原则，其开发团队通过堆叠DSL层来实现其许多组件，从而攻击了编写编译器的复杂性。</p><p> On the other hand, the project had many legacy components written in C that became a development bottleneck, so in 2017, Matthew Flatt made an announcement on a Racket Developers group:</p><p> 另一方面，该项目有许多用C编写的遗留组件成为开发瓶颈，因此在2017年，Matthew Flatt在Racket Developers小组中宣布：</p><p>  Chez is  a Scheme implementation which was open sourced by Cisco in 2016. Its performance has no match among other schemes and it has a long history of being used in production.</p><p>  Chez是Scheme实施，由Cisco在2016年开源。Chez的性能在其他计划中无与伦比，并且在生产中使用已久。</p><p> To learn more about this endeavor, we contacted Gustavo Massaccesi, and Matthew Flatt, who were part of what is now called the  Racket CS project. In this interview, they explain the background and details of this project.</p><p> 要了解有关此工作的更多信息，我们联系了Gustavo Massaccesi和Matthew Flatt，他们是现在所谓的Racket CS项目的一部分。在这次采访中，他们解释了该项目的背景和细节。</p><p> We&#39;re big fans of Matthew Flatt&#39;s work and of the Racket endeavor. For further reading we recommend reading Flatt&#39;s article  Creating languages in Racket,  this book that interviews 38 Racket programmers, and the book  Beautiful Racket, which Flatt prologued.</p><p> 我们是Matthew Flatt的工作和球拍事业的忠实拥护者。为了进一步阅读，我们建议阅读Flatt的文章“在Racket中创建语言”，对38位Racket程序员进行访谈的书以及Flatt所著的《 Beautiful Racket》一书。</p><p>  Join the Not a Monad Tutorial Telegram   group  or   channel  to talk about programming, computer science and papers. See you there!</p><p>  加入“非Monad教程电报”小组或频道，讨论编程，计算机科学和论文。到时候那里见！</p><p>  If you are looking for good engineers send me an email to mail@fcarrone.com or you can also reach me via twitter at   @federicocarrone .</p><p>如果您正在寻找优秀的工程师，请给我发送电子邮件至mail@fcarrone.com，或者也可以通过Twitter @federicocarrone与我联系。</p><p>  Let’s distinguish “Racket the language” and “Racket the project”.</p><p>  让我们区分“用语言拍”和“用项目拍”。</p><p> The Racket language is a general-purpose, Scheme-like language with an especially rich set of constructs for extending the language — even by Scheme standards. Racket includes support for writing quick-and-dirty macros, but it also supports nice macros with a good error checking that avoid surprising errors created in the expanded code. The close integration of macros and modules, an enforced phase separation between run-time and compile-time code, and the `#lang` mechanism for selecting the surface syntax all distinguish Racket from other Lisp variants.</p><p> Racket语言是一种通用的，类似于Scheme的语言，具有一组特别丰富的构造来扩展该语言-即使按照Scheme标准。 Racket包括对编写快速脏宏的支持，但它也支持带有良好错误检查的漂亮宏，可以避免在扩展代码中创建令人惊讶的错误。宏和模块的紧密集成，运行时代码与编译时代码之间的强制相分离以及用于选择表面语法的`＃lang`机制，都使Racket与其他Lisp变体区分开来。</p><p> Even the main language Racket is written in a simpler language, and that is written in an even more simple language. This tower of languages makes development easier. You can look under the hood and see all the internal languages, or just ignore all of them and get a nice high level language.</p><p> 甚至主要语言Racket都是用一种更简单的语言编写的，也就是用一种甚至更简单的语言编写的。语言之塔使开发更加容易。您可以深入了解所有内部语言，或者只是忽略所有内部语言而获得不错的高级语言。</p><p> Less prominent, but also as important in practice for building language abstractions and composing them into large systems, are Racket’s run-time constructs: first-class control with continuation marks, custodians for simple and reliable task termination, reachability-based memory accounting, message-based parallelism via places, and Concurrent ML-style constructs for event-driven programs. Many of these constructs need support at lower levels of the runtime system, but then they can be used to build a wide variety of languages and libraries that mesh well.</p><p> Racket的运行时结构不那么突出，但在实践中对于构建语言抽象并将它们组成大型系统也很重要：带有连续标记的一流控制，用于简单可靠的任务终止的管理员，基于可达性的内存记帐，消息基于位置的并行性，以及事件驱动程序的并发ML样式构造。这些构造中的许多构造都需要在运行时系统的较低级别上提供支持，但随后可以将它们用于构建各种可以很好地啮合的语言和库。</p><p> The Racket project synthesizes research, production, and education efforts toward the overall language-building goal. The idea of “A Programmable Programming Language” serves along those directions, from building student-friendly learning environments to domain-specific languages in application to pushing the frontiers of language design and implementation.</p><p> Racket项目将研究，生产和教育工作综合起来，以实现总体语言建设目标。 “建立一种可编程的编程语言”的理念沿这些方向服务，从构建对学生友好的学习环境到应用中特定领域的语言，再到推动语言设计和实现的前沿。</p><p>   For example, when you install Racket, it comes with 20 or 30 additional languages. (I’m not sure if someone has counted all of them.)</p><p>   例如，当您安装Racket时，它附带20或30种其他语言。 （我不确定是否有人把它们都数了。）</p><p> There are a few “Student” languages that are designed for students. They are less powerful but have more compile time checks to detect common errors in beginners. And they have different levels so once you master one, you can use the next one that includes more features.</p><p>有一些为学生设计的“学生”语言。它们的功能较弱，但具有更多的编译时间检查功能，可以检测初学者中的常见错误。它们具有不同的级别，因此一旦您掌握了一个级别，就可以使用包含更多功能的下一个级别。</p><p> Another language is Typed Racket, that adds types to the Racket expressions, so it refuses to compile unless the types check. And it also uses the type information to optimize the code, so the compilation is slower, but the generated code can be faster.</p><p> 另一种语言是Typed Racket，它向Racket表达式添加类型，因此除非类型检查，否则它拒绝编译。并且它还使用类型信息来优化代码，因此编译速度较慢，但​​是生成的代码可以更快。</p><p> There are languages that implement the version of Scheme in R5RS and R6RS and many of the SRFI. And you can install a package that adds the version in the R7RS-small.</p><p> 有一些语言可以在R5RS和R6RS以及许多SRFI中实现Scheme版本。而且，您可以安装一个在R7RS-small中添加版本的软件包。</p><p> And there are also more different languages with a very different syntax like a complete implementation of Algol 60.</p><p> 此外，还有更多语法不同的语言，例如Algol 60的完整实现。</p><p> All these languages share the same backend and you can call the libraries written in one language from any of the other languages that are included in the distribution, the additional languages you can download as packages, or the languages you create.</p><p> 所有这些语言都共享同一个后端，您可以从发行版中包含的任何其他语言，可以打包下载的其他语言或创建的语言中调用用一种语言编写的库。</p><p>  Racket started out as a Scheme implementation, and we would still call it “a Scheme.” Even though it does not fit a Scheme standard, it’s obviously derived from Scheme. There are many specific differences, such as the fact that `cons` always creates an immutable pair in Racket, but the main difference is philosophy: Scheme is meant to be a small language that gives you just enough to express lots of things. Racket is meant to be a big language, and while it gives you the same core pieces (and more) that can express lots of things, it also codifies the way many things are done to enable more cooperating libraries and languages.</p><p>  Racket最初是作为Scheme实施而来的，我们仍称其为“ Scheme”。即使不符合Scheme标准，也显然是从Scheme派生的。有很多特定的区别，例如，cons总是在Racket中创建一个不变的对，但主要区别是哲学：Scheme是一种很小的语言，足以让您表达很多东西。球拍本来是一门大语言，虽然它为您提供了可以表达很多内容的相同（甚至更多）核心片段，但它也使许多事情得以完成，从而实现了更多协作的库和语言。</p><p>  Chez Scheme is one of the oldest Scheme implementations, and its evolution informed many parts of the Scheme standard through R6RS. (Racket’s influence on the Scheme standard, in contrast, is limited to aspects of the R6RS library design.) Chez Scheme is a relatively small language, but like all instantiations of Scheme, the implementation provides a lot more than the standard specifies.</p><p>  Chez Scheme是最古老的Scheme实施方案之一，它的演变通过R6RS通知了Scheme标准的许多部分。 （相比之下，Racket对Scheme标准的影响仅限于R6RS库设计的各个方面。）Chez Scheme是一种相对较小的语言，但与Scheme的所有实例化一样，实现所提供的功能远远超出标准规定。</p><p> Chez Scheme’s biggest claim to fame is its performance. It has always been among the best-performing Scheme implementations. Its object-tagging and allocation regime, its hybrid stack–heap implementations of continuations, and its compiler structure all remain state-of-the-art, even in 2020.</p><p>切斯计划（Chez Scheme）最著名的成就就是表现。它一直是性能最佳的Scheme实施方案之一。即使在2020年，它的对象标记和分配机制，混合堆栈的延续实现以及其编译器结构仍保持最先进的状态。</p><p> For most of its existence, Chez Scheme was a proprietary, closed-source implementation, but it became open source in mid-2016. As it happens, we started considering a new Racket reimplementation around the start of 2017.</p><p> Chez Scheme在其大部分时间内都是专有的，封闭源代码的实施，但于2016年中期成为开源。碰巧的是，我们开始考虑在2017年初左右重新实施球拍。</p><p>  The biggest weakness of the Racket BC (“before Chez”) implementation are its back-end compiler structure, its inefficient internal calling conventions (over-adapted to C), and its poor implementation of first-class continuations. Those are exactly the strengths of Chez Scheme. Furthermore, Racket’s evaluation model was always closely aligned with Chez Scheme, such as the emphasis on interactive evaluation and compilation.</p><p>  Racket BC（“ Chez之前”）实现的最大弱点是其后端编译器结构，低效的内部调用约定（过度适应C）以及对一流延续的糟糕实现。这些正是Chez Scheme的优势。此外，Racket的评估模型始终与Chez Scheme紧密结合，例如强调交互式评估和编译。</p><p> It was clear up front that Chez Scheme lacked significant features that Racket needs, such as support for continuation marks and reachability-based memory accounting. However, the high quality of the Chez Scheme design and implementation, in contrast to old Racket’s implementation, made adapting Chez Scheme more appealing than retrofitting Racket’s old implementation further.</p><p> 很明显，Chez Scheme缺少Racket所需的重要功能，例如对连续标记的支持和基于可达性的内存记帐。但是，与旧版Racket的实施方式相比，Chez方案的设计和实施的高质量使适应Chez方案的吸引力远胜于对Racket的旧实施例的改进。</p><p> Why reimplement with Chez Scheme to reduce the C part instead of implementing the C stuff in Racket?</p><p> 为什么用Chez Scheme重新实现以减少C部分，而不是在Racket中实现C语言？</p><p> Mostly, we did reimplement the C stuff in Racket. The I/O subsystem, the concurrency subsystem (which includes the scheduler for “green” threads, Concurrent ML-style events, and custodians), and the regexp matcher were all rewritten in Racket. Those pieces followed the rewrite of the macro expander in Racket. Other things that needed to be moved out of C, such as the compiler and the extensive support for numbers that Racket inherited from Scheme, were already written in Scheme in Chez Scheme’s implementation.</p><p> 通常，我们确实在Racket中重新实现了C语言。 I / O子系统，并发子系统（包括“绿色”线程的调度程序，并发ML风格的事件和保管人）以及正则表达式匹配器均已在Racket中重写。这些部分是在Racket中重写宏扩展器之后进行的。 Chez Scheme的实现中已经在Scheme中编写了其他需要移出C的内容，例如编译器和对Racket从Scheme继承的数字的广泛支持。</p><p> A big part of the process was to understand what to implement in Racket, what in Chez Scheme, and what new layers to introduce in translation. This work and reorganization benefits other Racket implementation efforts, such as Pycket and RacketScript.</p><p> 该过程的很大一部分是了解要在Racket中实施什么，在Chez Scheme中实施什么以及在翻译中引入哪些新层。这项工作和重组有益于其他Racket实施工作，例如Pycket和RacketScript。</p><p>  With the exception of the garbage collector and similar low-level parts of the runtime system, much of Racket’s implementation benefits from higher-level abstractions. Writing a macro expander in C was a particularly poor choice, since higher-level abstractions obviously make tree manipulations easier, but the same reasons apply for the I/O layer or numeric primitives. Even the garbage collector in [the Racket variant of] Chez Scheme is now half implemented by a specification and compiler that are written in Scheme.</p><p>除了垃圾收集器和运行时系统的类似低级部分外，Racket的许多实现都受益于更高级别的抽象。用C语言编写宏扩展器是一个特别糟糕的选择，因为更高级别的抽象显然使树的操作更加容易，但是同样的原因也适用于I / O层或数字原语。现在，甚至Chez Scheme的[Racket变体]中的垃圾收集器也由用Scheme编写的规范和编译器实现了一半。</p><p> The other big advantage is that the Racket community has a lot of Racket programmers, not C programmers. It’s easier to convince a fan of Racket to look at some code in Racket or Chez Scheme and try to find some bug or a new feature to contribute. The people that like to read and write code in C are probably making contributions to a C compiler.</p><p> 另一个重要的优点是Racket社区中有很多Racket程序员，而不是C程序员。说服Racket爱好者看一下Racket或Chez Scheme中的某些代码，并尝试找出一些漏洞或新功能来进行贡献，会更容易。喜欢用C语言读写代码的人可能在为C编译器做出贡献。</p><p>  The most challenging part is not really one part, but the overall scale. Racket is a big language, and it all has to work the same in the new implementation. That means not just getting the right result and/or a specific kind of error message, but getting results with the same or better performance characteristics. For example, if a macro generates a giant expansion that nevertheless compiles in reasonable time in Racket BC, then it needs to compile in reasonable time in Racket CS.</p><p>  最具挑战性的部分不是真正的一部分，而是整体规模。球拍是一门重要的语言，在新的实现中，球拍都必须具有相同的功能。这意味着不仅获得正确的结果和/或特定类型的错误消息，而且获得具有相同或更好性能特征的结果。例如，如果一个宏生成了一个巨大的扩展，但仍然在合理的时间内在Racket BC中进行了编译，则它需要在合理的时间内在Racket CS中进行编译。</p><p> When it comes to specific pieces that we had to implement, perhaps the most challenging were adding type reconstruction to the compiler, adding support for continuation marks, allowing record values to act as procedures, reimplementing Racket’s I/O, and upgrading Chez Scheme’s garbage collector to support memory accounting, in-place marking for large heaps, and parallelism.</p><p> 对于我们必须实现的特定部分，也许最具挑战性的是向编译器添加类型重建，增加对连续标记的支持，允许记录值充当过程，重新实现Racket的I / O以及升级Chez Scheme的垃圾收集器支持内存记帐，大堆的就地标记和并行性。</p><p>  There have been a lot of fixes of small bugs and incompatibilities between Racket BC and Racket CS. Also the performance of Racket CS has improved, and now both variants have a more consistently similar end-to-end performance. The speed of generated code was rarely the problem with Chez Scheme as a backend, but the layers newly implemented in Racket needed lots of tuning. So, the things that used to be faster in BC are now generally about as fast in CS, while things that have been faster in CS are even faster.</p><p>  Racket BC和Racket CS之间已经有很多小错误和不兼容的修复程序。同时，Racket CS的性能也得到了改善，现在这两个变体的端到端性能都更加一致。 Chez Scheme作为后端，生成代码的速度很少出现问题，但是在Racket中新实现的层需要大量调整。因此，以前在BC中更快的事物现在在CS中通常差不多，而在CS中更快的事物甚至更快。</p><p> One of the most important improvements at the Chez Scheme level is flunum unboxing. Until recently, the floating-point numbers were stored in a box-like object under the hood, so they can be used in a vector or other container that expects a reference to an object. Now, in many cases, the compiler detects that the box is not necessary and skips it. That reduces the number of allocations and increases the speed of programs that use a lot of floating-point numbers.</p><p> 在Chez Scheme级别上最重要的改进之一是发烟盒拆箱。直到最近，浮点数都存储在引擎盖下的盒子状对象中，因此可以将它们用于期望引用对象的向量或其他容器中。现在，在许多情况下，编译器会检测到不需要该框并跳过它。这减少了分配数量，并提高了使用大量浮点数的程序的速度。</p><p> The other big area of improvement was in the garbage collector. When we started Racket CS, Chez Scheme had an admirably simple collector that performed very well on traditional Scheme programs. But Racket needed a lot more functionality from the collector. We’ve improved support for large heaps, for GUI and game-like situations that benefit from incremental collection, and for programs with parallelism.</p><p> 另一个大的改进领域是垃圾收集器。当我们启动Racket CS时，Chez Scheme拥有一个非常出色的收藏家，在传统Scheme程序上表现非常出色。但是Racket需要收集器提供更多功能。我们已经改进了对大堆，从增量收集中受益的GUI和类似游戏的情况以及具有并行性的程序的支持。</p><p>  You can download Racket CS from the download page and it is a drop down replacement of the current version of Racket BC. Both the Racket BC and Racket CS include all the libraries and the IDE that is also written in Racket. All the code written in Racket should run without changes in the BC or CS versions, except for some corners of the foreign-function interface.</p><p>您可以从下载页面下载Racket CS，它是当前版本Racket BC的下拉替代品。 Racket BC和Racket CS都包含所有库和同样用Racket编写的IDE。除外部功能界面的某些角落外，用Racket编写的所有代码都应在BC或CS版本中运行，而无需更改。</p><p> Gustavo used it in the university to edit an move quiz from a Moodle server to another. The mdz files are like .tar.gz files, so you can use the standard libraries in Racket to uncompress them, edit the xml files that are inside and then repackage the result in a new mdz file. (Does this count as “outside academia”?)</p><p> Gustavo在大学里用它来编辑从Moodle服务器到另一个Moodle服务器的移动测验。 mdz文件就像.tar.gz文件一样，因此您可以使用Racket中的标准库来解压缩它们，编辑其中的xml文件，然后将结果重新打包为新的mdz文件。 （这算作“外部学术界”吗？）</p><p> The biggest site that is using Racket is Hacker News  https://news.ycombinator.com, that is a forum about programming and related topics. It is programmed in their own language called Arc that is programmed in Racket. They have more than 5.5M hits a day and something between 4M and 5M unique visitors a month. They are using the BC version anyway.</p><p> 正在使用Racket的最大站点是Hacker News https://news.ycombinator.com，这是一个有关编程和相关主题的论坛。它是用自己的称为Arc的语言编程的，该语言在Racket中编程。他们每天的点击量超过550万，每月的独立访问者介于4百万至5百万之间。他们仍然使用BC版本。</p><p>  To target CS, you ended up patching the language to accommodate its differences with Racket, was that the intention from the beginning? What was the biggest difference between the two languages?</p><p>  为了瞄准CS，您最终修补了该语言以适应与Racket的差异，这是从一开始的目的吗？两种语言之间的最大区别是什么？</p><p> This possibility was considered from the beginning. There are some differences of opinion between Racket and Chez Scheme, so sooner or later some change that is useful for Racket would not be useful in Chez Scheme.</p><p> 从一开始就考虑了这种可能性。球拍和Chez计划之间存在一些意见分歧，因此早晚要对球拍有用的一些更改不会在Chez计划中有用。</p><p> For example, Racket is more strict in checking that a function returns a single value in positions that expect a single value. This is an undefined case in the Scheme standard, so Chez Scheme sometimes ignores it. In the common case that the function actually returns a single value, Chez Scheme may be slightly faster, and in the other cases Racket may report a better error. It’s a design decision, and each team has different preferences. So the version of CS in Racket has some additional checks to track the single return expression and avoid the unnecessary checks when possible.</p><p> 例如，在检查函数是否在期望单个值的位置返回单个值时，Racket更为严格。在Scheme标准中这是未定义的情况，因此Chez Scheme有时会忽略它。在函数实际返回单个值的常见情况下，Chez Scheme可能会更快一些，而在其他情况下，Racket可能会报告更好的错误。这是设计决定，每个团队都有不同的偏好。因此，Racket中的CS版本具有一些附加检查来跟踪单个返回表达式，并在可能时避免不必要的检查。</p><p>  It would be fair to say that the Chez Scheme runtime system is optimized for functional programming. There’s a write barrier on object modifications, for example, and the compiler is happier when variables are not mutated. It would also be fair to say that it’s designed for settings with plenty of memory and computing power, and not more constrained, embedded settings.</p><p>  可以公平地说，Chez Scheme运行时系统针对功能编程进行了优化。例如，在对象修改上存在写障碍，并且当变量不突变时，编译器会更快乐。可以公平地说，它是为具有足够的内存和计算能力的设置而设计的，而不是受更多限制的嵌入式设置。</p><p>  Gustavo’s contributions in this rewrite has been in a type recovery pass for the patched version of Chez Scheme used in Racket. It reduces the number of run time checks of the types, so the final code is faster. There is still a lot of room to make the translation from Racket to Chez Scheme more optimizer friendly, and the optimization pass more translation friendly, so I expect a gain of performance in this area next year. Also, we can improve the cooperation with the high level parts of Racket that use types, like the contract system and Typed Racket.</p><p>Gustavo在这次改写中的贡献在于为Racket中使用的Chez Scheme补丁版提供了类型恢复通道。它减少了类型的运行时检查的次数，因此最终代码更快。仍然有很大的空间可以使从Racket到Chez Scheme的翻译更加优化器友好，并且优化通过的翻译也更加友好，因此我希望明年在该领域的表现有所提高。此外，我们可以改善与球拍的高级部分（如合同系统和类型球拍）使用类型的合作。</p><p> Writing the optimizations steps in Chez Scheme opens a lot of possibilities, for example Gustavo wanted to add some escape analysis to use that information to avoid copies, or the creation of temporal struct, and other similar reductions. It was too scary to try that in C, but it looks more possible to write it in Chez Scheme. [Probably in 2022.]</p><p> 在Chez Scheme中编写优化步骤会打开很多可能性，例如Gustavo希望添加一些转义分析以使用该信息来避免复制或创建时间结构，以及其他类似的简化方法。在C中尝试使用它太可怕了，但是用Chez Scheme编写它似乎更有可能。 [大概在2022年。]</p><p> Matthew has run out of immediate tasks, and he is hoping to spend less time at the level of the compiler and runtime system. Now that Racket CS has generally caught up and stabilized, he hopes to go back more to language design via the Rhombus project.</p><p> Matthew已经用完了眼前的任务，他希望在编译器和运行时系统级别上花费更少的时间。既然Racket CS总体上已经赶上并稳定下来了，他希望通过Rhombus项目进一步回到语言设计上。</p><p> Are there plans to expand Racket? in which areas? Where would you like to see Racket in 5 years?</p><p> 有扩展Racket的计划吗？在哪些地区？您想在5年后在哪里看球拍？</p><p> The Rhombus project is an experiment at starting fresh with the surface language and library design while preserving all of the language-building constructs, compilation pipeline, and runtime system that we now have in place in Racket. It’s still early — and still earlier than we thought it might be, since Racket CS development continued to dominate our efforts — but if this design succeeds, then we expect that to be the next direction for Racket.</p><p> Rhombus项目是一个实验，首先从表面语言和库设计开始，同时保留了我们现在在Racket中拥有的所有语言构建结构，编译管道和运行时系统。由于Racket CS的开发继续主导着我们的努力，现在还为时过早，并且比我们想象的要早。但是，如果这种设计成功，那么我们希望这将成为Racket的下一个方向。</p><p>  Initially, some people were afraid of the performance drop for adding a new layer between Racket and the hardware. The initial version was slower, but the current version has a similar speed, and in many benchmarks it’s faster. Most likely, the January release of Racket will be version 8.0 with Racket CS (based on Chez Scheme) as the default implementation.</p><p>  最初，有些人担心在Racket和硬件之间添加新层会降低性能。初始版本的速度较慢，但​​当前版本的速度类似，在许多基准测试中，速度更快。最有可能的是，一月份的Racket版本将是8.0版，默认版本为Racket CS（基于Chez Scheme）。</p><p> Other people were worried because the development of the low level part of Racket would be slowed down for some time, while making the new version. Now that the CS version has an almost equivalent performance, so hopefully the increase of the development speed in the CS version will compensate for the delay. Anyway, Racket is a big project so while the CS version was developed other areas had a lot of improvement, like new libraries or a more efficient contract system, and all of these new features are available in both versions.</p><p> 其他人担心，因为在制作新版本的同时，Racket的低级部分的开发会放慢一段时间。现在CS版本几乎具有等效的性能，因此希望CS版本中开发速度的提高将弥补延迟。无论如何，Racket是一个很大的项目，因此在开发CS版本时，其他领域也有了很大的改进，例如新的库或更有效的合同系统，并且所有这些新功能在两个版本中都可用。</p><p>  We’d certainly recommend  How to Design Programs ( https://htdp.org). While it’s mainly intended for beginning programmers, it can also provide a crash course in functional programming for programmers who do not already have a lot of experience with it.  Essentials of Programming Languages by Dan Friedman and Mitch Wand is a classic for learning about programming languages from the same perspective that informs HtDP.</p><p>我们当然会推荐“如何设计程序”（https://htdp.org）。尽管它主要是针对初级程序员的，但它也可以为还没有丰富经验的程序员提供函数式编程速成课程。 Dan Friedman和Mitch Wand撰写的《编程语言要点》是从与HtDP相同的角度学习编程语言的经典著作。</p><p> While it’s not about programming directly, Matthew recommends  Working in Public: The Making and Maintenance of Open Source Software by Nadia Eghbal. The book is a lucid reflection on the history and state of open-source software — partly the idea of open source, but especially how that idea has played out in practice.</p><p> Matthew不建议直接编程，但建议使用Nadia Eghbal的《公开工作：开源软件的制作和维护》。该书对开放源代码软件的历史和状态进行了清醒的反映-部分是开放源代码的概念，但特别是该想法在实践中如何发挥作用。</p><p> Gustavo wants to recommend  Gödel, Escher, Bach: an Eternal Golden Braid. It is not related to Racket, but it has a few nice discussions about the transforming formulas/code to numbers/data, that is one of the main ideas behind the macros in the LISP family.</p><p> 古斯塔沃（Gustavo）想推荐巴赫（Gödel），埃舍尔（Escher），巴赫（Bach）：永恒的金色辫子。它与Racket无关，但是它对将公式/代码转换为数字/数据进行了一些不错的讨论，这是LISP系列宏背后的主要思想之一。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://notamonadtutorial.com/rebuilding-the-racket-compiler-with-chez-scheme-210e23a69484">https://notamonadtutorial.com/rebuilding-the-racket-compiler-with-chez-scheme-210e23a69484</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/chez/">#chez</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/racket/">#racket</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>