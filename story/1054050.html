<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ZGC  -  JDK 16中的新功能 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">ZGC  -  JDK 16中的新功能 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-23 03:15:41</div><div class="page_narrow text-break page_content"><p>JDK 16出局，并且像往常一样，每个新版本都有一堆新功能，增强功能和错误修复。 ZGC收到了46个增强功能和25错误修复。我将涵盖一些更有趣的增强功能。</p><p>   当我们开始ZGC项目时，我们的目标是从未有过GC暂停时间超过10ms。当时，10毫秒似乎很雄心勃勃的目标。热点中的其他GCS通常提供最大暂停时间，几个大于那个大小，特别是在使用大堆时。达到这个目标是在很大程度上在很大程度上完成所有真正的繁重工作，这样的途径，参考处理和级别卸载，并在并发阶段，而不是在停止世界阶段。然后，热点缺乏很多基础设施，需要同时做到这一点，因此需要几年的发展来到达那里。</p><p> 在达到最初的10毫秒目标后，我们重新瞄准并将我们的目标设置在更雄心勃勃的事情上。即GC Pausehkoull永远不会超过1ms。从JDK 16开始，我很高兴地报告我们也达到了这个目标。 ZGC现在有O（1）暂停时间。换句话说，它们以恒定的时间执行，并且不会随着堆，实时设置或根定型（或其他任何东西）的增加而增加。当然，我们仍然掌握了操作系统调度程序来提供GC ThreadSCPU时间。但只要您的系统并不重新配置，您可以期望看到大约0.05ms（50μs）和大约0.5ms（500μs）的最大暂停时间的平均GC暂停时间。</p><p> 那么，我们做了什么来到这里？嗯，在JDK 16之前，ZGC暂停时间仍然缩放root-set的大小（root）的大小。要更精确，我们仍然扫描了世界阶段的线程堆栈。这意味着如果Java应用程序具有Alarge数字线程，则暂停时间将增加。如果这些线程有Deepcall堆栈，则暂停时间会增加。从JDK 16开始，扫描线程堆栈同时完成，即，java应用程序继续运行。</p><p> 正如您可以想象的那样，在线程堆栈中戳出来，而线程正在运行，则需要一些魔法。这是成功的，其中涉及堆栈水印屏障。简而言之，这是一种阻止Java线程返回到堆栈帧的机制，而无需先检查它是安全的。这是一个廉价的检查，折叠成在方法返回时折叠成已存在的点检查。概念上，您可以将其视为堆栈帧的负载障碍，如果需要，将强制Java线程采用某种形式的操作，以将堆栈帧返回到返回之前将堆栈帧置于安全状态。移居java线程有一个或者更多的堆栈水印，这告诉屏障沿着堆栈的距离，安全地走路了，不要特别行动。要走过水印，慢速路径将一个或多个框架带入当前安全的状态，并更新水印。将所有线程堆栈带入安全状态的工作通常由一个或多个GCTHREADS处理，但由于这同时完成，Java线程有时必须修复一些自己的帧，如果它需要返回到帧中GC还没有得到。如果您对更多详细信息感兴趣，请查看Jep 376：ZGC：并发线程堆栈处理，介绍这项工作。</p><p> 凭JEP 376到位，ZGC现在扫描了世界上的停止 - 世界阶段的零根源。对于许多工作负载，即使在JDK 16之前，您也看到了真正的LowMax暂停时间。但是如果您在大型计算机上运行，​​并且您的工作量有大量线程，则仍然可以看到超过1ms的最大暂停时间。为了可视化改进，这是一个比较JDK 15 ANDJDK 16，在一个具有几千个Java线程的大型计算机上运行SpecJBB®2015的示例。</p><p>  在JDK 16中，ZGC得到了就地重新定位的支持。此功能有助于避免OutofMemoryError在GCNEEDS在堆已经填充到边缘时收集垃圾的情况。通常，ZGC通过将物体从稀疏填充的堆地区移动到一个或多个空堆区域中，将堆压缩（从而释放的内存），其中这些物体可以密集地包装。这策略简单且简单，并且非常适合并行处理非常好。但是，它有一个缺点。它需要一定量的空闲内存（每个尺寸类型的至少一个空堆区域）来获取重定位进程已启动。如果堆已满，即所有堆区域已在使用中，那么我们无处可移动对象。 </p><p>在JDK 16之前，ZGC通过堆积储备解决了这一点。此堆保留是一组堆地区，留出了java线程的正常分配不可用。而是只允许GC本身使用堆储备在octocating对象时。这确保了空堆区域可用，即使堆从Java线程的角度普及，即可启动重定位过程。堆储备通常是堆的一小部分。在以前的博客文章中，我写了关于我们如何在JDK 14中改进它以更好地支持微小的堆。</p><p>  尽管如此，堆保护方法有一些问题。例如，由于Java线程无法使用Java线程，因此无法努力保证搬迁过程可以完成，因此GC无法回收（足够的）内存。这是基本上所有正常工作负载的非问题但是，我们的测试显示，有可能构建一个众所周置的程序，这反过来又导致了外部的oveofMemoryError。此外，除了在重新安置期间需要的情况下，将抛开一些（虽然小）部分，以防万一，对于大多数工作负载是浪费的内存。</p><p> 释放连续块的内存的另一种方法是紧凑堆。当他们执行所谓的完整GC时，其他热点收集器（例如G1，并行和串行）执行一些版本。这种方法的主要优点是它不需要内存提高内存。换句话说，它会令人愉快地紧凑一堆，而不需要某种堆储备。</p><p>  然而，压实堆积也具有一些挑战，通常具有开销。例如，当您否则风险覆盖未尚未移动的对象时，此时，它的顺序现在很重要。这需要在GC之间的GC线程之间进行更多协调，也不会借助并行处理，并且还会影响Java线程可以的内容并且无法代表GC重新定位对象时。</p><p> 总之，两种方法都具有优势。当空堆区域可用时，未迁移就是更好的，同时迁移就可以保证即使没有空堆区域也可以成功完成。</p><p> 从JDK 16开始，ZGC现在使用两种方法来获得两个世界的最佳。这允许我们摆脱对堆保护储备的需求，同时在常见的情况下保持良好的重定位性能，并保证重新定位始终在确ch案例中完成。默认情况下，只要有可用于将对象移动到的空堆区域，ZGC就不会重新定位。应该是这种情况，ZGC将切换到就地重新分配。一旦空堆地区变得可用，ZGC将再次切换回旋转定位。</p><p>  在这些重定位模式之间来回切换，无缝地发生，如果需要，在相同的GC周期中多次。但是，大多数工作负载永远不会陷入一个情况下首先发生切换的情况。但是，通过很好地了解这些情况的ZGC WillCope，而且由于未能紧凑堆，因此永远不会扔过早的OutofMemoryError，应该给予一定的心灵。 </p><p>还扩展了ZGC日志记录以显示每个尺寸组（小/中/大）的堆区域（Zpages）是重新安置的地方。这是一个例子，其中54MB的小物体在其中重新安置，3个小页需要被取代。</p><p> ... GC（15）小页：120 / 240M，空：0M，重新安置：54M，就地：3 GC（15）中等页数：2 / 64M，空：0M，重新安置：0M，就地： 0 GC（15）大页：1 / 4M，空：0M，重新安置：0M，就地：0 ...</p><p>  当ZGC重新定位一个对象时，该对象的新地址被记录在转发表中，该数据结构分配在Java堆之外。选择的每个堆区域都是重定位集的一部分（堆积集合到紧凑的存储器）Getsa转发表与它相关联。</p><p> 在JDK 16之前，转发表的分配和初始化可以采取整个GC循环时间的重要部分，而重定位集非常大。重定位集的大小与在重定位期间移动的对象数相关联。例如，如果是，A＆gt; 100GB堆和工作量会导致大量碎片，小孔均匀分布在堆上，那么重定位集将大而分配/初始化它可能需要一段时间。当然，这项工作始终在一个康提门中完成，因此它从未影响过GC暂停时间。尽管如此，这里还有改进的空间。</p><p> 在JDK 16中，ZGC现在分配了批量的转发表。为每个表进行Malloc / New Toallocate内存而不是使众多呼叫（可能是数千个），而是一次呼叫以一次性地分配所有表所需的所有内存。这有助于避免促进突起和潜在的锁争用，并显着减少分配这些表所需的时间。</p><p> 这些表的初始化是另一个瓶颈。转发表是哈希表，因此初始化它意味着设置小头头并归零出（潜在大的）转发表条目数组。从JDK 16开始，ZGC现在可以使用多个线程而不是单个线程重新平行此初始化。</p><p> 总之，这些变化显着降低了分配和初始化转发表的时间，特别是当收集稀疏填充的大堆时，减少可以大约一个或两个大的量级。 </p><p>通过并发线程堆栈扫描，ZGC现在在微秒域中具有暂停时间，平均暂停〜500μs的最大暂停次数为〜500μs。 暂停时间不受堆，Live-Set和Root-Set大小的影响。  堆储备现已走了，ZGC将在需要时进行就地重新定位。 这节省了内存，但也保证了堆可以在所有情况下成功压缩。  转发表现在可以更有效地分配和初始化，这缩短了完成GC周期所需的时间，特别是在收集稀疏填充的大堆时。  有关ZGC的更多信息，请参阅Java内部的OpenJDK Wiki，GC部分或此博客。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://malloc.se/blog/zgc-jdk16">https://malloc.se/blog/zgc-jdk16</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/zgc/">#zgc</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>