<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Rust脚本–将Rust文件和表达式作为脚本运行，无需任何设置或配合Rust-script – Run Rust files and expressions as scripts without any setup or co</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rust-script – Run Rust files and expressions as scripts without any setup or co<br/>Rust脚本–将Rust文件和表达式作为脚本运行，无需任何设置或配合</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-23 04:03:09</div><div class="page_narrow text-break page_content"><p>With  rust-script Rust files and expressions can be executed just like a shell or Python script. Features include:</p><p>使用rust-script脚本，可以像Shell或Python脚本一样执行Rust文件和表达式。功能包括：</p><p>        The primary use for  rust-script is for running Rust source files as scripts. For example:</p><p>        rust-script的主要用途是将Rust源文件作为脚本运行。例如：</p><p> $  echo  &#39;println!(&#34;Hello, World!&#34;);&#39;  &gt; hello.rs $ rust-script hello.rsHello, World! $ rust-script hello  # you can leave off the file extensionHello, World!</p><p> $ echo'println！（“ Hello，World！”）;' > hello.rs $锈脚本hello.rs您好，世界！ $ rust-script hello＃您可以不使用文件扩展名了，世界！</p><p> Under the hood, a Cargo project will be generated and built (with the Cargo output hidden unless compilation fails or the  -o/ --cargo-output option is used). The first invocation of the script will be slower as the script is compiled - subsequent invocations of unmodified scripts will be fast as the built executable is cached.</p><p> 在后台，将生成并构建一个Cargo项目（除非编译失败或使用-o / --cargo-output选项，否则隐藏Cargo输出）。脚本被编译时，脚本的首次调用会变慢-缓存已构建的可执行文件时，未修改脚本的后续调用将很快。</p><p> As seen from the above example, using a  fn main() {} function is not required. If not present, the script file will be wrapped in a  fn main() { ... } block.</p><p> 从上面的示例可以看出，不需要使用fn main（）{}函数。如果不存在，脚本文件将包装在fn main（）{...}块中。</p><p> rust-script will look for embedded dependency and manifest information in the script as shown by the below two equivalent  now.rs variants:</p><p> rust-script将在脚本中查找嵌入式依赖关系和清单信息，如以下两个等效的now.rs变体所示：</p><p> # !/ usr / bin / env  rust - script //! This is a regular crate doc comment, but it also contains a partial //! Cargo manifest. Note the use of a *fenced* code block, and the //! `cargo` &#34;language&#34;. //! //! ```cargo //! [dependencies] //! time = &#34;0.1.25&#34; //! ``` fn  main ()  {  println! ( &#34;{}&#34; ,  time :: now () .rfc822z ()); }</p><p> ＃！/ usr / bin / env rust-脚本//！这是一个常规的板条箱文档注释，但也包含部分// !！货物舱单。注意使用* fenced *代码块和//!。 `cargo`“语言”。 //！ //！ ```货物//！ [依赖项] //！时间=“ 0.1.25” //！ ```fn main（）{println！ （“ {}”，时间::现在（）.rfc822z（））; }</p><p> // cargo-deps: time=&#34;0.1.25&#34; // You can also leave off the version number, in which case, it&#39;s assumed // to be &#34;*&#34;. Also, the `cargo-deps` comment *must* be a single-line // comment, and it *must* be the first thing in the file, after the // hashbang. // Multiple dependencies should be separated by commas: // cargo-deps: time=&#34;0.1.25&#34;, libc=&#34;0.2.5&#34; fn  main ()  {  println! ( &#34;{}&#34; ,  time :: now () .rfc822z ()); }</p><p>// cargo-deps：time =“ 0.1.25” //您也可以省略版本号，在这种情况下，假定版本号为“ *”。同样，`cargo-deps`注释*必须*是单行//注释，并且*必须*是文件中//在hashbang之后的第一件事。 //多个依存关系应以逗号分隔：// cargo-deps：time =“ 0.1.25”，libc =“ 0.2.5” fn main（）{println！ （“ {}”，时间::现在（）.rfc822z（））; }</p><p>    --force: Force the script to be rebuilt. Useful if you want to force a recompile with a different toolchain.</p><p>    --force：强制重建脚本。如果要使用其他工具链强制重新编译，则很有用。</p><p>  --gen-pkg-only: Generate the Cargo package, but don’t compile or run it. Effectively “unpacks” the script into a Cargo package.</p><p>  --gen-pkg-only：生成Cargo软件包，但不编译或运行它。有效地将脚本“解包”到Cargo包中。</p><p>  On Unix systems, you can use  #!/usr/bin/env rust-script as a shebang line in a Rust script. This will allow you to execute a script files (which don’t need to have the  .rs file extension) directly.</p><p>  在Unix系统上，您可以在Rust脚本中使用＃！/ usr / bin / env rust-script作为shebang行。这样一来，您就可以直接执行脚本文件（无需扩展名为.rs）。</p><p> If you are using Windows, you can associate the  .ers extension (executable Rust - a renamed  .rs file) with  rust-script. This allows you to execute Rust scripts simply by naming them like any other executable or script.</p><p> 如果使用Windows，则可以将.ers扩展名（可执行的Rust-重命名的.rs文件）与rust-script关联。这使您只需像其他任何可执行文件或脚本一样命名Rust脚本即可执行Rust脚本。</p><p> This can be done using the  rust-script --install-file-association command. Uninstall the file association with  rust-script --uninstall-file-association.</p><p> 这可以使用rust-script --install-file-association命令完成。使用rust-script --uninstall-file-association卸载文件关联。</p><p> If you want to make a script usable across platforms, use  both a hashbang line  and give the file a  .ers file extension.</p><p> 如果要使脚本可跨平台使用，请同时使用hashbang行并为文件指定.ers文件扩展名。</p><p>  Using the  -e/ --expr option a Rust expression can be evaluated directly, with dependencies (if any) added using  -d/ --dep:</p><p>使用-e / --expr选项，可以直接评估Rust表达式，并使用-d / --dep添加依赖项（如果有）：</p><p> $ rust-script  -e  &#39;1+2&#39;3 $ rust-script  --dep  time  --expr  &#34;time::OffsetDateTime::now_utc().format(time::Format::Rfc3339).to_string()&#34; ` &#34;2020-10-28T11:42:10+00:00&#34; $  # Use a specific version of the time crate (instead of default latest): $ rust-script  --dep  time =0.1.38  -e  &#34;time::now().rfc822z().to_string()&#34; &#34;2020-10-28T11:42:10+00:00&#34;</p><p> $ rust-script -e'1 + 2'3 $ rust-script --dep time --expr“ time :: OffsetDateTime :: now_utc（）。format（time :: Format :: Rfc3339）.to_string（）”` “ 2020-10-28T11：42：10 + 00：00” $＃使用特定版本的时间箱（而不是默认的最新版本）：$ rust-script --dep time = 0.1.38 -e“ time :: now（）。rfc822z（）。to_string（）“” 2020-10-28T11：42：10 + 00：00“</p><p> The code given is embedded into a block expression, evaluated, and printed out using the  Debug formatter ( i.e.  {:?}).</p><p> 给定的代码被嵌入到一个块表达式中，使用调试格式化程序（即{：？}）进行评估并打印出来。</p><p>  You can use  rust-script to write a quick filter, by specifying a closure to be called for each line read from stdin, like so:</p><p>  您可以使用rust-script编写快速过滤器，方法是为从stdin读取的每一行指定一个闭包，如下所示：</p><p> $  cat now.ers | rust-script  --loop  \  &#34;let mut n=0; move |l| {n+=1; println!( \&#34; {:&gt;6}: {} \&#34; ,n,l.trim_right())}&#34; 1: // cargo-deps:  time = &#34;0.1.25&#34; 3: fn main ()  { 4: println! ( &#34;{}&#34;,  time::now ().rfc822z ()) ; 5:  }</p><p> $ cat now.ers | rust-script --loop \“ let mut n = 0; move | l | {n + = 1; println！（\” {：> 6}：{} \“，n，l.trim_right（））}” 1 ：// cargo-deps：time =“ 0.1.25” 3：fn main（）{4：println！ （“ {}”，time :: now（）.rfc822z（））; 5：}</p><p> You can achieve a similar effect to the above by using the  --count flag, which causes the line number to be passed as a second argument to your closure:</p><p> 您可以使用--count标志来实现与上述类似的效果，该标志会使行号作为第二个参数传递给您的闭包：</p><p> $  cat now.ers | rust-script  --count  --loop  \  &#34;|l,n| println!( \&#34; {:&gt;6}: {} \&#34; , n, l.trim_right())&#34; 1: // cargo-deps:  time = &#34;0.1.25&#34; 2: fn main ()  { 3: println! ( &#34;{}&#34;,  time::now ().rfc822z ()) ; 4:  }</p><p> $ cat now.ers | rust-script --count --loop \“ | l，n | println！（\” {：> 6}：{} \“，n，l.trim_right（））” 1：//货物下降：时间=“ 0.1.25” 2：fn main（）{3：println！ （“ {}”，time :: now（）.rfc822z（））; 4：}</p><p>    RUST_SCRIPT_BASE_PATH: the base path used by  rust-script to resolve relative dependency paths. Note that this is  not necessarily the same as either the working directory, or the directory in which the script is being compiled.</p><p>RUST_SCRIPT_BASE_PATH：rust-script用于解析相对依赖性路径的基本路径。请注意，这不一定与工作目录或在其中编译脚本的目录相同。</p><p>    RUST_SCRIPT_SAFE_NAME: the file name of the script (sans file extension) being run. For scripts, this is derived from the script’s filename. May also be  &#34;expr&#34; or  &#34;loop&#34; for those invocations.</p><p>    RUST_SCRIPT_SAFE_NAME：正在运行的脚本的文件名（没有文件扩展名）。对于脚本，这是从脚本的文件名派生的。对于这些调用，也可能是“ expr”或“ loop”。</p><p>  RUST_SCRIPT_PATH: absolute path to the script being run, assuming one exists. Set to the empty string for expressions.</p><p>  RUST_SCRIPT_PATH：假设脚本存在，则为正在运行的脚本的绝对路径。设置为表达式的空字符串。</p><p>  You can use templates to avoid having to re-specify common code and dependencies. You can find out the directory where templates are store and view a list of your templates by running  rust-script --list-templates.</p><p>  您可以使用模板来避免重新指定通用代码和依赖项。您可以通过运行rust-script --list-templates找出存储模板的目录并查看模板列表。</p><p> Templates are Rust source files with two placeholders:  #{prelude} for the auto-generated prelude (which should be placed at the top of the template), and  #{script} for the contents of the script itself.</p><p> 模板是具有两个占位符的Rust源文件：＃{prelude}用于自动生成的前奏（应放置在模板的顶部），而＃{script}用于脚本本身的内容。</p><p> For example, a minimal expression template that adds a dependency and imports some additional symbols might be:</p><p> 例如，添加依赖项并导入一些其他符号的最小表达式模板可能是：</p><p> // cargo-deps: itertools=&#34;0.6.2&#34; #![allow(unused_imports)] # { prelude } use  std :: io :: prelude :: * ; use  std :: mem ; use  itertools :: Itertools ; fn  main ()  {  let  result  =  {  # { script }  };  println! ( &#34;{:?}&#34; ,  result ); }</p><p> // // cargo-deps：itertools =“ 0.6.2”＃！[allow（unused_imports）]＃{prelude} use std :: io :: prelude :: *;使用std :: mem;使用itertools :: Itertools; fn main（）{让结果= {＃{脚本}}; println！ （“ {：？}”，结果）； }</p><p> If stored in the templates folder as  grabbag.rs, you can use it by passing the name  grabbag via the  --template option, like so:</p><p>如果将其作为grabbag.rs存储在模板文件夹中，则可以通过--template选项传递名称grabbag来使用它，如下所示：</p><p>  In addition, there are three built-in templates:  expr,  loop, and  loop-count. These are used for the  --expr,  --loop, and  --loop --count invocation forms. They can be overridden by placing templates with the same name in the template folder.</p><p>  此外，还有三个内置模板：expr，loop和loop-count。这些用于--expr，-loop和--loop --count调用形式。可以通过将相同名称的模板放置在template文件夹中来覆盖它们。</p><p>   If relevant, run with the  RUST_LOG=rust_script=trace environment variable set to see verbose log output and attach that output to an issue.</p><p>   如果相关，请在设置RUST_LOG = rust_script = trace环境变量的情况下运行，以查看详细的日志输出并将该输出附加到问题上。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://rust-script.org/">https://rust-script.org/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/脚本/">#脚本</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>