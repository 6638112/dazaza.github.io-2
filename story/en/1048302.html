<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Ruby垃圾收集深潜：三色标记和扫描 Ruby Garbage Collection Deep Dive: Tri-Color Mark and Sweep</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Ruby Garbage Collection Deep Dive: Tri-Color Mark and Sweep<br/>Ruby垃圾收集深潜：三色标记和扫描 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-19 01:57:05</div><div class="page_narrow text-break page_content"><p>In the  first post in the Ruby Garbage Collection Deep Dive series, we went through a few definitions to give us a picture of how Ruby stores values in memory. If you haven’t read it yet,  read it first! We’ll build on those definitions in this post. Particularly, we’ll talk more about the Ruby Heap, Pages, Slots and RVALUES.</p><p>在Ruby Garbage Collection Deep Dive系列的第一篇文章中，我们经历了一些定义，以使我们了解Ruby如何在内存中存储值。如果您尚未阅读，请先阅读！在本文中，我们将基于这些定义。特别是，我们将更多地讨论Ruby Heap，Pages，Slot和RVALUES。</p><p> Okay, now that we have those baseline definitions out of the way, this post is going to explain the algorithm Ruby’s garbage collector uses to determine which objects it can collect: the Tri-Color Mark and Sweep algorithm. There are two phases to this algorithm. You guessed it: marking and sweeping. In the marking phase, the garbage collector marks all slots which contain accessible RVALUES. In the sweeping phase, the garbage collector clears the RVALUES out of all slots which are not marked. Let’s dig in!</p><p> 好的，既然我们已经有了这些基线定义，那么这篇文章将解释Ruby的垃圾收集器用来确定它可以收集哪些对象的算法：三色标记和清除算法。该算法分为两个阶段。您猜对了：标记和清除。在标记阶段，垃圾收集器标记所有包含可访问RVALUES的插槽。在清除阶段，垃圾收集器从所有未标记的插槽中清除RVALUES。让我们深入探讨！</p><p>   We’ll start off by discussing the marking phase. This is most straightforward to understand if we imagine the  Ruby ObjectSpace to be a directed graph with root nodes. All of the nodes in the graphs are RVALUES. All of the edges in the graph are references from one RVALUE to another.</p><p>   我们将从讨论标记阶段开始。如果我们将Ruby ObjectSpace想象成是带有根节点的有向图，这是最容易理解的。图中的所有节点均为RVALUES。图中的所有边都是从一个RVALUE到另一个RVALUE的引用。</p><p> Ruby’s garbage collector starts at the root nodes and traces every edge it can access from these root nodes, marking every RVALUE it sees through this process. At the end, any RVALUE which was not traced, and therefore not accessible from a root RVALUE will be garbage collected.</p><p> Ruby的垃圾收集器从根节点开始，并跟踪它可以从这些根节点访问的每个边缘，并标记在此过程中看到的每个RVALUE。最后，所有未被跟踪的RVALUE都将被垃圾回收，因此无法从根RVALUE访问。</p><p>  Okay, but the algorithm Ruby uses for garbage collection is called a Tri-Color Mark and Sweep algorithm, so what’s the Tri-Color part all about? The Tri-Color algorithm is a model we can use to understand what Ruby’s garbage collector is doing, and how tracks its progress. The three colors in the Tri-Color algorithm (three shades, really) are white, black and grey.</p><p>  好的，但是Ruby用于垃圾收集的算法称为“三色标记和扫描”算法，那么“三色”部分是什么呢？我们可以使用Tri-Color算法模型来了解Ruby的垃圾收集器在做什么，以及如何跟踪其进度。三色算法中的三种颜色（实际上是三种阴影）是白色，黑色和灰色。</p><p> At the beginning of garbage collection, every slot in the Ruby Heap is white. Then, as part of the initial setup, all slots which contain root RVALUEs are marked as grey.</p><p> 在垃圾回收开始时，Ruby Heap中的每个插槽都是白色的。然后，作为初始设置的一部分，所有包含根RVALUE的插槽都标记为灰色。</p><p> Root RVALUES are all of the RVALUES that a Ruby program knows it will need to run. Examples of these are RVALUES that exist on the stack of instructions that the program is following, or protected global variables.</p><p> 根RVALUES是Ruby程序知道将需要运行的所有RVALUES。这些示例包括存在于程序所遵循的指令堆栈中的RVALUES或受保护的全局变量。 </p><p> With all root slots grey, and all other slots white, we then get to the crux of the algorithm:</p><p>在所有根插槽为灰色而所有其他插槽为白色的情况下，我们进入了算法的关键：</p><p>  We iterate over all grey slots, coloring the slots that their RVALUES reference grey, and coloring themselves black. The algorithm continues until there are no grey slots left. At this point, any black slots contain RVALUES which were reachable by the RVALUEs in the root slots, and any white slots do not contain RVALUES which were reachable so can be swept away!</p><p>  我们遍历所有灰色插槽，将其RVALUES引用的插槽着色为灰色，并将其自身着色为黑色。该算法继续进行，直到没有剩余的灰色插槽为止。此时，任何黑色插槽都包含根插槽中的RVALUE可以到达的RVALUES，任何白色插槽都不包含可以到达的RVALUES，因此可以将其扫除！</p><p> For the visual learners, here’s a gif of what the algorithm is doing:</p><p> 对于视觉学习者来说，这是该算法的效果的图像：</p><p>   There is one detail which needs further explanation here: how does an RVALUE know which other RVALUES it references?</p><p>   这里有一个细节需要进一步解释：RVALUE如何知道它引用的其他RVALUE？</p><p> It depends on the type of object. For Ruby builtins, tracing the references are just baked into the garbage collector code itself. For example, to find all references from an array RVALUE, the collector iterates each element in the array and finds its references. For a hash, it will do this for both the keys and the values. This all happens in the garbage collector’s   mark_children method.</p><p> 这取决于对象的类型。对于Ruby内置函数，跟踪引用只是烘焙到垃圾收集器代码本身中。例如，要从数组RVALUE中查找所有引用，收集器将迭代数组中的每个元素并找到其引用。对于哈希，它将对键和值都执行此操作。这一切都发生在垃圾收集器的mark_children方法中。</p><p> But, when objects are defined by C extensions, the C extensions must mark all child objects on their own. We’ll dive more into this in a future C extensions post (which I’ll backlink here).</p><p> 但是，当对象由C扩展定义时，C扩展必须自己标记所有子对象。我们将在以后的C扩展文章（我将在此处反向链接）中进一步介绍这一点。</p><p> Okay, so now that we understand how we find all accessbile objects, we need to learn how to dispose of all unaccessible objects.</p><p> 好的，现在我们了解了如何找到所有可访问对象，我们需要学习如何处理所有不可访问对象。 </p><p>  At this point, we have two sets: black slots and white slots. Internally, these are represented as a  marked bitmap. Every Page on the Ruby Heap has its own  marked bitmap with one bit per slot. A  1 bit means the slot is accessible, or Black in our Tri-Color scheme. A  0 bit means that the slot is no longer accessible, or White in our Tri-Color scheme.</p><p>此时，我们有两组：黑色插槽和白色插槽。在内部，这些表示为标记的位图。 Ruby Heap上的每个页面都有其自己的标记位图，每个插槽一位。 1位表示该插槽可访问，或者在我们的三色方案中为黑色。 0位表示该插槽不再可用，或者在我们的三色方案中为白色。</p><p> In addition to holding this  marked bitmap, each page also has a  freelist which represents slots on that page which do not have live objects. The garbage collector iterates over all pages, finding all slots which are not marked. Where applicable, the garbage collector then adds the unmarked slots to each page’s freelist. If the RVALUES which were occupying these slots are also taking up space in the operating system heap, it also frees this memory.</p><p> 除了保存该标记的位图之外，每个页面还具有一个空闲列表，该列表表示该页面上没有活动对象的插槽。垃圾收集器遍历所有页面，找到所有未标记的插槽。然后，垃圾收集器将未标记的位置添加到每个页面的空闲列表中（如果适用）。如果占用这些插槽的RVALUES也占用了操作系统堆中的空间，则它还将释放此内存。</p><p> Once pages have been swept, there might be pages which are now completely unallocated; they have no slots which contain RVALUES. These pages are referred to as “Tomb Pages.” Tomb pages have their memory completely returned to the operating system’s heap. This is really helpful for memory management. It means that sweeping can result in freeing memory, or diminishing the overall size of the Ruby Heap.</p><p> 扫描完页面后，可能会有一些页面现在完全未分配。它们没有包含RVALUES的插槽。这些页面称为“ Tomb页面”。坟墓页面的内存已完全返回到操作系统的堆。这对于内存管理确实很有帮助。这意味着清除可能会导致释放内存或减小Ruby Heap的整体大小。</p><p> Any pages with at least one occupied slot are called “Eden Pages”. The sweeping phase might reduce the number of occupied slots in an Eden Page. The garbage collector will use the freelists from Eden Pages for future object allocations. That is to say, if you instantiate an object, the garbage collector will look for one of these free slots in an Eden Page and place the RVALUE representing your object in there.</p><p> 任何具有至少一个占用插槽的页面都称为“ Eden页面”。扫描阶段可能会减少Eden Page中占用的插槽数。垃圾收集器将使用Eden Pages的空闲列表进行将来的对象分配。也就是说，如果实例化一个对象，则垃圾收集器将在Eden页面中查找这些空闲插槽之一，并将代表您的对象的RVALUE放置在其中。</p><p>  There is one more nuance here. As of Ruby 3.0, if auto-compaction is enabled, compaction will actually happen as part of the sweeping phase. A more in depth explanation of how and why this happens will follow in a later post about compaction in this Garbage Collection Deep Dive Series.</p><p>  这里还有一个细微差别。从Ruby 3.0开始，如果启用了自动压缩，则压缩实际上将作为清除阶段的一部分进行。关于此情况发生的方式和原因的更深入说明，将在此垃圾收集深潜系列中有关压缩的后续文章中进行。</p><p>  The Tri-Color mark and sweep algorithm is what Ruby’s garbage collector uses to determine which slots hold objects which no longer have accessible references. It marks all of the slots it has references to by following the Tri-Color algorithm in which it follows all references from root RVALUES. Once the garbage collector knows which objects are accessible from the roots, it can begin the sweep phase, where it will add the unoccupied slots to each page’s freelist, and release any operating system memory those RVALUES held. This enables the slots to be reused for new object allocation.</p><p>  Ruby的垃圾收集器使用三色标记和清除算法来确定哪些插槽中保存了不再具有可访问引用的对象。它遵循三色算法（它遵循根RVALUES的所有引用）来标记它引用的所有插槽。垃圾收集器知道从根目录可以访问哪些对象后，便可以开始清除阶段，在此阶段将未占用的插槽添加到每个页面的空闲列表中，并释放所有保留了RVALUES的操作系统内存。这使插槽可以重新用于新的对象分配。</p><p>   And that’s it for this post! I’m going to continue writing blog posts in this series, and am also writing a book about managed garbage collection, with a focus on Ruby. If this interests you, join the newsletter below or follow me  on twitter for updates!</p><p>   就是这个帖子！我将继续在本系列文章中撰写博客文章，并且还将撰写一本有关托管垃圾收集的书，重点是Ruby。如果您对此感兴趣，请加入下面的新闻通讯或在Twitter上关注我以获取更新！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://jemma.dev/blog/gc-mark-and-sweep">https://jemma.dev/blog/gc-mark-and-sweep</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/垃圾/">#垃圾</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/garbage/">#garbage</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/插槽/">#插槽</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>