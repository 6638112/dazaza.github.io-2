<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>持续数十年的代码</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">持续数十年的代码</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-09-02 16:43:35</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/9/416653cb43f788b833a8f352288bd11b.png"><img src="http://img2.diglog.com/img/2020/9/416653cb43f788b833a8f352288bd11b.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>在与快速发展的编程语言接触了几年之后，我开始欣赏稳定性。我想让我的程序只需最少的调整就可以轻松地构建在各种各样的系统上。我希望随着环境的变化，他们能在未来很长一段时间内继续工作。</p><p>为了更清楚地考虑稳定性，让我们将一个正常运行的程序分成几个层。然后，我们可以一层一层地检查开发选择。</p><p>程序需要的功能越多，它就必须通过各层延伸到更远的地方。</p><p>每种语言都必须从某个地方开始，通常是作为单个人或小团队的实现。在这个阶段，语言发展迅速，公平地说，正是这个阶段推动了艺术的发展。</p><p>然而，在语言的单一实现阶段使用它意味着您将一定比例的精力投入到该语言本身的“研究项目”中。您将处理破坏性更改(包括工具)和实验死胡同。</p><p>如果你喜欢一门新语言背后的想法，或者相信它是赢家，相信你早期的熟悉会有回报，那么就去做吧！否则，请使用已超越单一实现的高级语言。这样你就可以专注于你的专业领域，而不是紧跟语言研究议程。</p><p>当一群人为新的情况和体系结构分叉语言时，语言就会进入下一个阶段。一些人添加了功能，另一些人发现了他们环境中的困难。然后，利益相关者通过标准化过程进行辩论并达成共识。最终结果是标准而不是特定的软件工件定义语言并拥有最终决定权。</p><p>当然，整个过程需要一段时间。标准化语言将变得相当陈旧。他们会错过最新的想法，但会被很好地理解。以下是一些具有标准的成熟语言：</p><p>我最近一直在使用C，因为它的可移植性、简单(但富有表现力)的抽象机器模型，以及与POSIX和基础库的深度兼容。</p><p>如果您使用的是一种有标准的语言，请充分利用它。首先，选择标准的特定版本。旧版本通常得到更广泛的支持，但功能较少。在C世界中，我通常选择C99，因为与C89相比，它有一些便利，而且几乎所有地方都支持C99(尽管只有部分在Windows上)。</p><p>请查阅编译器文档，了解编译器是否可以捕获非标准行为的意外使用。在clang或GCC中，将以下标志添加到生成文件中：</p><p>根据需要用另一个版本替换“C99”。Pedtic标志拒绝所有使用禁用扩展的程序，以及其他一些不遵循ISO C的程序。</p><p>如果您确实想要使用编译器扩展(如GCC或clang中的那些)，请将它们包装在您自己的宏中，以便代码保持可移植性。PostgreSQL项目在C.H中做这类事情。下面是一个随机的例子：</p><p>/**对于我们*希望强制内联的函数，使用&#34；PG_Attribute_Always_Inline&#34；代替&#34；INLINE&#34；，即使编译器的启发式方法会*选择不这样做。但是，如果可能的话，不要在未经优化的*调试版本中强制内联。*/#IF(Defined(__GNUC__)&amp；&amp；__Gnuc__&gt；3&amp；&amp；Defined(__Optimize__))||Defined(__SUNPRO_C)||Defined(__IBMC__)/*GCC&gt；3、Sunpro和XLC通过__ATTRIBUTE__*/#DEFINE PG_ATTRIBUTE_ALWAYS_INLINE_ATTRIBUTE__((ALWAYS_INLINE))INLINE#ELIF DEFINED(_MSC_VER)/*MSVC为此提供了一个特殊的关键字*/#DEFINE PG_ATTRIBUTE_ALWAYS_INLINE__FORCES#ELSE/*，否则，我们最多只能说&#34；INLINE&#34；*/#DEFINE PG_ATTRIBUTE_ALWAYS_INLINE。</p><p>请注意它们如何适应各种编译器并提供最终的后备。当然，在可能的情况下，首先避免扩展是最简单的选择。</p><p>花点时间学习您的语言标准库。这是免费的，无论你的程序走到哪里，你都可以得到它。阅读语言标准中的库函数，因为将在那里介绍它们。</p><p>无论何时在C标准库之外使用系统调用，都要检查它们是否属于POSIX，以及它们的官方描述是否与本地手册页不同。Open Group提供POSIX.1的免费可搜索HTML版本。在撰写本文时，它是POSIX.1-2017(即POSIX.1-2008加上两个技术勘误)。</p><p>还有一个更复杂的问题：POSIX.1-2008(又名“问题7”)并不是所有地方都完全支持。(例如，我发现MacOS不支持pthread障碍、信号量或异步线程取消。)。我认为根本原因是2008需要线程和实时功能，而这在以前是可选的扩展。如果您坚持使用POSIX.1-2001(也就是第6版)中的功能，那么在所有相当新的平台上都应该是安全的。</p><p>要调用POSIX函数，必须在包含头文件之前定义_POSIX_C_SOURCE“功能测试”宏。使用下列值之一选择特定的POSIX版本：</p><p>头文件根据功能测试宏隐藏或显示功能。例如，第7期中的getline()函数分配内存并读取一行。</p><p>/*line.c*/#include&lt；stdio.h&gt；#include&lt；stdlib.h&gt；#include&lt；sys/tyes.h&gt；/*ssize_t*/int main(Void){char*line=null；size_t len=0；ssize_t read；while((read=getline(&amp；line，&amp；len，stdin))！=-1)printf(&。，读取，行)；释放(行)；返回0；}。</p><p>$cc-std=c99-pedtic-Werror-D_POSIX_C_SOURCE=200112L line e.c-o line line。c：10：17：错误：在C99[-Werror，-WImplative-Function-Designation]While((read=getline(&amp；line，&amp；len，stdin))！=-1)^1中，函数&#39；getline&#39；的隐式声明无效。</p><p>重要注意事项：设置_POSIX_C_SOURCE将在标准标头中隐藏非POSIX操作系统附加文件。最佳实践是将源文件分为符合POSIX的源文件和不符合POSIX的源文件(希望不太多)，编译后的源文件不带特性宏，最后将它们链接在一起。</p><p>POSIX不仅为前面讨论的库函数定义了接口，还为shell和常用工具定义了接口。如果您使用这些工具进行构建，则不需要在目标计算机上安装任何额外的软件来编译您的项目。</p><p>意外锁定的最常见来源可能是要进行的bashism和GNU扩展。对于脚本，请使用sh，并使用(POSIX)make for Makefiles。太多项目不必要地使用GNU特性。事实上，学习make特性的可移植子集会带来更干净、更可靠的构建。</p><p>这是一整篇文章的主题。克里斯·韦隆(Chris Wellons)就此写了一篇很好的教程。安德鲁·奥拉姆的“用Make管理项目”(ISBN0-937175-90-0)也是一本小书，里面有很多好的建议。</p><p>操作系统包含POSIX之外的有用功能。例如对PTHREADS的扩展(设置读取器-写入器偏好或线程处理器亲和性)、对专用硬件(如音频或图形)的访问、替代I/O接口和语义、以及诸如StrcPy或保证的安全功能。</p><p>构建静态填充库(“libcompat”)作为项目的一部分，以便在缺少功能时使用，或者。</p><p>我们稍后将讨论第三方库。现在让我们来看一下选项一。</p><p>考虑一下生成随机数据的示例。它需要操作系统的帮助，因为POSIX只提供伪随机数。</p><p>我们将使用配置脚本生成config.mk。开发人员将在第一次构建之前运行该脚本以检测环境选项。要使Configure正常工作，最原始的方法是尝试解析、未命名，并根据它看到的操作系统或发行版做出决定。更准确的方法是尝试直接探测所需的OS C函数。</p><p>要查看是否存在C函数，我们只需尝试编译测试代码片段，看看它们是否成功。您可能认为这很笨拙，或者需要用测试代码将您的项目搞得乱七八糟，但实际上它相当优雅。</p><p>编译(){Stage=&#34；$(mktemp-d)&#34；ECHO&#34；$2&#34；&gt；&#34；$Stage/test.c&#34；(cc-Werror&#34；$1&#34；-o&#34；$Stage/test&#34；&#34；$Stage/test.c&#34；&gt；/dev/null 2&gt；&amp；1)cc_SUCCESSRM-RF&#34；$Stage&#34；返回$cc_SUCCESS}。</p><p>函数的作用是：接受两个参数：一个可选的编译器标志和要尝试编译的源代码。</p><p>让我们使用帮助器来检查操作系统随机数生成器。BSD世界提供arc4Random_buf来获取随机字节，而Linux提供getRandom。配置脚本可以检查每个功能，如下所示：</p><p>如果编译&#34；&#34；&#include&lt；stdint.h&gt；#include&lt；stdlib.h&gt；int main(Void){void(*p)(void*，size_t)=arc4dom_buf；return(Intptr_T)p；}&#34；则ECHO&#34；CFLAGS+=-DHAVE_ARC4RANDOM&#34；&gt&#34；#include&lt；stdint.h&gt；#include&lt；sys/tyes.h&gt；#include&lt；sys/随机.h&gt；int main(Void){ssize_t(*p)(void*，size_t，unsign int)=getRandom；return(Intptr_T)p；}&#34；然后ECHO&#34；CFLAGS+=-DHAVE_GETRANDOM&#34；&。</p><p>看见?。还不算太糟。这些代码片段不仅测试函数是否存在，还检查它们的类型签名。注意第二个示例是如何使用ssize_t类型的POSIX编译的，而第一个示例故意没有标记为符合POSIX，因为这样做会隐藏BSD放在stdlib.h中的额外函数arc4Random_buf。</p><p>将不可移植功能的使用隔离在不同的翻译单元中，并在上面导出您自己的接口是很有帮助的。这样一来，在一个地方设置条件编译或在将来重构就更简单了。</p><p>让我们继续上一节生成随机字节的示例。有了操作系统功能检测的辛勤工作，我们可以将不同的操作系统接口封装在我们自己的函数后面：</p><p>#include&lt；stdint.h&gt；#include&lt；stdlib.h&gt；#ifdef Have_GETRANDOM#include&lt；sys/随机性.h&gt；#endif void get_Random_bytes(void*buf，size_t n){#if Defined Have_ARC4RANDOM/*BSD*/arc4Random_BuF(BUF，n)；#Elif Defined Have_GUF</p><p>当相应的函数存在时，Makefile使用CFLAGS定义HAVE_ARC4RANDOM或HAVE_GETRANDOM。代码只能使用ifdefs。请注意#Else案例中的#错误，即在不支持的平台上编译失败，并显示一条清晰的消息。</p><p>我们努力实现的可移植性程度导致了权衡。示例：我们可以向read/dev/Random添加一个后备。上一节中的配置脚本可以检查设备是否存在：</p><p>使用该信息，我们可以在GET_RANDOM_BYTES()中添加另一个#elif，这样它就可以潜在地在更多的系统上工作。然而，在这种情况下，增加的可移植性将需要更改界面。由于/dev/Random上的fopen()或fread()可能会失败，因此我们的函数需要返回bool。目前，我们调用的操作系统函数不会失败，所以返回一个void就可以了。</p><p>当然，对可移植性的真正测试是在多个操作系统、编译器和硬件体系结构上构建和运行。看看这能揭示出什么假设，可能会让人感到惊讶。及早测试可移植性，通常会使保持程序井然有序变得更容易。</p><p>例如，PostgreSQL项目维护一系列被称为“构建场”的完全不同的机器。构建场成员每个都有自己的操作系统、编译器和体系结构。该团队编译了这些机器上的每一个新功能，并在那里运行测试套件。</p><p>即使您不打算在这些架构上运行，在那里进行测试也会产生更好的代码。(请参阅我的文章C“来自怪异机器的可移植性课程”。)。</p><p>许多语言都有自己的应用级包管理器，但C语言没有专有的包管理器。这门语言有太多的历史，跨越了太多的环境，不可能锁定在那里。取而代之的是，人们从源代码构建依赖项，或者使用操作系统包管理器。</p><p>链接到库需要知道它们的路径、名称和编译器设置。此外，我们还想知道安装的是哪个版本，以及它是否在边界内。因为C没有应用程序级的包管理器，所以我们需要使用另一个工具来发现已安装的库。</p><p>查找和构建依赖性库的最具跨平台的方式是pkg-config。该工具允许您查询系统包，而不管它们是如何安装的。为了与pkg-config兼容，每个库foo都提供一个包含如下键和值的libfoo.pc文件：</p><p>Pkg-config可执行文件可以查询元数据并为Makefile提供标志。从您的配置脚本调用它，如下所示：</p><p>#检查是否安装了足够的版本pkg-config--print-error&#39；libfoo&gt；=1.0&#39；#将标志保存到config.mk cat&gt；&gt；config.mk&lt；&lt；-EOF CFLAGS+=$(pkg-config--cflag libfoo)LDFLAGS+=$(pkg-config--libs-only-L libfoo)LDLIBS。</p><p>请注意LDLIBS与LDFLAGS的区别。LDLIB是需要放在构建行的最后的选项。默认的POSIX make后缀规则没有提到LDLIBS，但是您可以使用下面的规则：</p><p>有时，操作系统会包含额外的功能，并将其打包为可在其他操作系统上使用的便携程序库。在这种情况下，您可以有条件地使用pkg-config。</p><p>例如，OpenBSD剥离了LibreSSL项目(一个更易用的OpenSSL)。OpenBSD在内部包含该功能。在配置脚本中，只需执行操作系统检查：</p><p>操作系统ECHO&#39；LDLIBS+=-ltls&#39；&gt；config.mk；*)#附带的#LibreSSL case&#34；$(uname-s)&34；#需要软件包pkg-config--print-error&#39；libtls&gt；=2.5.0&#39；cat&gt；config.mk&lt；&lt；-EOF CFLAGS+=$(pkg-config--cflag libtls)LDFLAGS+=$(pkg-config--libs-only-L libtls)LDLIBS+=$(pkg-config--libs-only-l libtls)EOFesac。</p><p>C标准库没有泛型集合。您必须编写自己的链表、树和哈希表。真正的程序员™可能会喜欢这样，但我不喜欢。</p><p>二叉搜索树。虽然twalk()不包含将辅助数据传递给回调的参数，但这个接口对我来说是有效的。为此，回调需要咨询全局或线程局部变量。实施的质量也可能有所不同，可能与树的平衡方式/是否平衡有关。</p><p>排队。从双向链接(可能是循环)列表中插入或删除的非常基本的功能。它接受void*，但需要一个结构，该结构的前两个成员是指向相同结构类型(向前和向后指针)的指针。</p><p>哈希表。不必要的限制接口。它在隐藏内存中创建单个哈希表。您可以销毁该表，然后再创建另一个表，但在调用堆栈中的任何位置，一次都不能有多个活动的表。显然不是线程安全的，但这似乎是它最小的问题。</p><p>要超越这一点，您必须使用第三方库。许多知名的库看起来相当臃肿(Glib、Tbox、Apache Portable Runtime)。我发现了一个更小、更干净的库，名为简单的C算法。虽然还没有在项目中使用过，但是它看起来很稳定并且经过了很好的测试。我也在本地构建了这个库，添加了迂腐的C99标志，没有收到任何警告。</p><p>另外两个稳定的库(代码片段？)。这些年来得到了大量使用的是Uthash和BSD的Queue(3)(从OpenBSD浏览Quee.h，或者FreeBSD变体)。</p><p>任何C结构都可以使用uthash存储在哈希表中。只需将UT_HASH_HANDLE添加到结构中，然后在结构中选择一个或多个字段作为键即可。然后使用这些宏来存储、检索或删除哈希表中的项目。</p><p>BSD队列代码早在20世纪90年代就一直在使用和改进。它提供用于创建和操作单链接列表、简单队列、列表和尾部队列的宏。手册页相当不错。</p><p>OpenBSD和FreeBSD的代码库功能不同。我使用的是OpenBSD版本，但是它的功能稍少一些。特别是，FreeBSD添加了STAILQ(单链接尾队列)和列表交换操作。曾经有一个用于循环队列的CIRCLEQ，但它使用了不可靠的编码实践，并被删除。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://begriffs.com/posts/2020-08-31-portable-stable-software.html?hn=3">https://begriffs.com/posts/2020-08-31-portable-stable-software.html?hn=3</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/持续/">#持续</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lasts/">#lasts</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1021534.html"><img src="http://img2.diglog.com/img/2020/9/thumb_14fcb2271a8ed870369c59a03c081a8c.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1021534.html">
多里安为其无代码的交互式讲故事平台筹集了325万美元</a></div><span class="my_story_list_date">2020-9-1 5:55</span></div><div class="col-sm"><div><a target="_blank" href="/story/1021351.html"><img src="http://img.diglog.com/img/2020/8/thumb_732890bf3b6e44fee33f7d833c8c3cff.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1021351.html">如何编写不可维护的代码</a></div><span class="my_story_list_date">2020-8-31 6:11</span></div><div class="col-sm"><div><a target="_blank" href="/story/1021112.html"><img src="http://img.diglog.com/img/2020/8/thumb_4d5651aa098ff22d48c18f6b2de4f288.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1021112.html">松弛桌面应用程序中的远程代码执行</a></div><span class="my_story_list_date">2020-8-29 15:47</span></div><div class="col-sm"><div><a target="_blank" href="/story/1020759.html"><img src="http://img.diglog.com/img/2020/8/thumb_a4cb83a876517bf250cd11f96e468efd.gif" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1020759.html">文明VI UI，但在WebFlow(一个无代码工具)中制作</a></div><span class="my_story_list_date">2020-8-28 3:3</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>