<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>关于命名变量的思考 Thoughts Around Naming Variables</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Thoughts Around Naming Variables<br/>关于命名变量的思考 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-02 16:28:05</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/6ec41efe658e1ee86eb30ba5b69bcd8d.png"><img src="http://img2.diglog.com/img/2021/3/6ec41efe658e1ee86eb30ba5b69bcd8d.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I don&#39;t remember when I heard that, but it stuck. When a quip &#34;clicks&#34; for me, I can&#39;t rest until I find a framing in which it&#39;s disproved. But it&#39;s been 6 years now, and I&#39;m still unable to muster a reply to the above other than &#34;Yeah, yeah, it seems so&#34;.</p><p>我不记得什么时候听到的，但它卡住了。当打趣的＆＃34;点击＆＃34;对我来说，我无法休息直到找到一个被驳斥的框架。但这已经有6年了，除了是，是的，我仍然无法回答上述问题。</p><p> I&#39;m pretty sure cache invalidation is the harder of the two, because of some underlying OCD most of us have about picking two arbitrary constants that dictate sweep frequency and TTL. I&#39;d even go as far as to speculate most of the evolution of programming has been a weird spiritual exercise around trying not to pick those two arbitrary numbers. Functional programming as a whole can even be understood as a set of taboos around this, because what good is shared OCD if it doesn&#39;t lead to religion.</p><p> 我可以肯定的是，缓存失效是这两者中比较难的一件事，因为某些底层的OCD，我们大多数人都会选择两个任意的常数来决定扫描频率和TTL。我什至推测，编程的大部分演变都是围绕不尝试选择这两个任意数字的怪异的精神实践。整体上，函数式编程甚至可以理解为与此相关的一系列禁忌，因为共享的OCD如果没有引发宗教的好处。</p><p> I digress, I&#39;m neither old, wise nor crazy enough to talk about cache invalidation, so I&#39;ll talk about the second hardest thing in programming instead, naming things.</p><p> 我离题，我既不老，也不明智，也不疯狂谈论缓存无效，所以我将谈论编程中第二难的事情，命名。</p><p>  Maybe I&#39;m being vague here, but please bear with me, I am trying to introduce the practice that leads to the creation of civilization and distinguishes us from apes</p><p>  也许我在这里含糊不清，但请忍受我，我正在尝试介绍导致创造文明并使我们与猿类区分开的做法</p><p>   In theory, names could be arbitrary, at the ASM level it&#39;s more than reasonable to replace names with addresses. Yet names are so useful, that they persist even when code is compiled, presumably because they help preserve sanity when one is forced to look at the generate ASM.</p><p>   从理论上讲，名称可以是任意的，在ASM级别上，用地址替换名称是合理的。然而，名称是如此有用，以至于即使在编译代码时它们也可以保留下来，这大概是因为当人们被迫查看生成的ASM时，它们有助于保持理智。</p><p> In so far as names help make sense of code, they operate at different levels.</p><p> 就名称有助于使代码有意义而言，它们在不同的级别上运行。</p><p> Names help connect the developer with the end goal of the software. I think the main reason OO became popular as a paradigm for teaching was a culture of example programs that used names referencing the &#34;real world&#34;. Using words like &#34;Shop&#34; and &#34;Transaction&#34; and &#34;buy&#34; and &#34;transfer_to&#34;, that give the student&#39;s bored brain some bit of reality to hang on to.</p><p> 名称有助于将开发人员与软件的最终目标联系起来。我认为OO成为教学范式受欢迎的主要原因是一种示例程序的文化，这种程序使用了引用“真实世界”的名称。使用＆＃34; Shop＆＃34;之类的字词和＆＃34; Transaction＆＃34;和＆＃34;购买＆＃34;和“转移到”，这使学生的无聊大脑有了一些可以依靠的现实。 </p><p> Names help in building a mental map of software. In this regard, names function much like  any other arbitrary category we instil upon the world, be it those that we use to refer to animals, other people, the night&#39;s sky or, to make the similarity to code more obvious, the content of one&#39;s bowel movement. In this sense, names should optimize for a map of the code that makes sense to the one writing it, you.</p><p>名称有助于构建软件的思维导图。在这方面，名称的功能与我们向世界注入的任何其他任意类别的功能非常相似，无论是我们用来指动物，其他人，夜晚的天空，还是使代码的相似性更加明显，排便的内容。从这个意义上说，名称应优化代码映射，这对于编写该代码的人是有意义的。</p><p> I&#39;m just kidding though, the &#34;you&#34; here is really &#34;a team&#34; and the &#34;a team&#34; here is really &#34;a team with people coming and going, people which have imperfect memory and ever-changing minds with which they read that map&#34;.</p><p> 不过，我只是在开玩笑，这真的是一个团队＆＃34;和一个团队这是一个真正的团队，人们来来往往，记忆力不佳且思想变化的人们阅读地图。</p><p> We can already see some tradeoffs here. Names that will help you now are not necessarily ones that will help the team 5 years from now. Maybe  let IHateThisFingLoop is a useful outlet for one&#39;s anger or  val steves_moms = FAT32() provided some much needed comedic relief. But naming for the moment can often backfire. Not only when naming for catharsis. We have such a good map of the code we&#39;re working on  now that an &#34;obvious&#34; name can be a horrible choice in hindsight. Depending on our mental context, the name  trx might be a much-welcomed shorthand for  write_new_credentials_transaction, or it might be the cause of a security error that makes the news.</p><p> 我们已经可以在这里看到一些折衷。现在对您有所帮助的名称不一定会在5年后对团队有所帮助。也许让IHateThisFingLoop是一个愤怒的出口，或者提供一些必要的喜剧性救济，例如val steves_moms = FAT32（）。但是，暂时命名经常会适得其反。不仅在命名导尿时。现在，我们正在开发的代码有一个很好的映射，一个明显的＆＃34;在事后看来，名字可能是一个可怕的选择。根据我们的思想背景，trx名称可能是write_new_credentials_transaction的受欢迎的缩写，或者它可能是引起新闻的安全性错误的原因。</p><p> Names aren&#39;t there just to express the concepts we already have, once a name is chosen, if encountered often enough, it becomes its own concept. One need only looks at the old sciences to see arbitrary variable names that are now rooted in people&#39;s mindsdb as describing the fundamental nature of reality in an irreducible way.  pi and  e as representations of the circle,  x as describing the concept of unkown,  c as describing the maximum speed an object can travel with if Maxwell&#39;s equations are to hold... etc).</p><p> 名称并不是仅仅用来表达我们已经拥有的概念，一旦选择了一个名称，如果经常遇到它，它就会变成它自己的概念。只需查看一下古老的科学，便可以看到现在植根于人们的心智数据库中的任意变量名称以一种不可简化的方式描述了现实的基本本质。 pi和e表示圆，x表示未知的概念，c表示如果麦克斯韦方程式成立时物体可以行进的最大速度等）。</p><p> If a perfectly-named codebase were to exist, it would provide the reader with an amazing understanding of the things it&#39;s used for, in addition to being easy to grok. The sad thing is that &#34;perfectly-named&#34; is something that varies between people and even within people (over time).</p><p> 如果存在一个完美命名的代码库，那么除了易于理解之外，它还可以为读者提供对其用途的惊人理解。令人遗憾的是，＆＃34;完美地命名了＆＃34;人与人之间甚至人与人之间（随着时间的流逝）都会有所不同。</p><p> I also think that the &#34;experience&#34; people have with names might vary greatly based on the codebases they worked on. Working in a large codebase with loads of existing names and naming standards provides a completely different naming-experience from building something from scratch.</p><p> 我也认为＆＃34; Experience＆＃34;人们使用的名称可能会因他们使用的代码库而有很大差异。在具有大量现有名称和命名标准的大型代码库中工作，与从头开始构建代码提供了完全不同的命名体验。</p><p> Indeed, understanding a codebase or even a language can probably be boiled down to being familiar with all of its names and naming convention.</p><p> 确实，了解代码库甚至某种语言可能可以归结为熟悉其所有名称和命名约定。 </p><p> There might be a type of person that can remember all the names of the functions in a stdlib and yet know nothing about a language. But, in spite of our education system trying to optimize for the psychiatric illness which would allow this, for the vast majority of people understanding a language still boils down to knowing the vocabulary.</p><p>可能有一种人可以记住stdlib中所有函数的名称，但对语言一无所知。但是，尽管我们的教育系统试图针对可能导致的精神疾病进行优化，但对于绝大多数了解语言的人来说，仍然可以归结为了解词汇。</p><p>  The foreplay to naming things is coming up with conventions about naming things. A convention dictates the boundaries of what names one can give in various situations. For example, the conventions I usually impose are:</p><p>  命名事物的前戏是关于命名事物的约定。约定规定了在各种情况下可以给出的名称的界限。例如，我通常强加的约定是：</p><p> If the type of a variable is not obvious from usage, have a name that implies the type (e.g.  customer_arr,  equation_dict)</p><p> 如果变量的类型在用法上不明显，请使用暗示该类型的名称（例如customer_arr，equation_dict）</p><p> None of it is written down in our coding guidelines, people just sort of &#34;catch onto it&#34;, even first-time contributors, I find this fascinating.</p><p> 我们的编码指南中都没有写下来，甚至只是初次贡献者，人们都对此有所了解，我对此感到着迷。</p><p> There are many things new people seem to miss that I have to re-iterate time and time again, but naming is never one of them. Nor was it ever a problem for me when joining a new team to pick up on their conventions.</p><p> 新人们似乎想念很多事情，我不得不一次又一次地重申，但命名从来都不是其中之一。加入一个新团队参加他们的会议对我来说也从来没有问题。</p><p> Though maybe this ease of adoption would disappear if the conventions were too niche or too many?</p><p> 尽管如果公约太小众或太多，这种采用的便利性可能会消失吗？</p><p>   If you want to understand naming go digging for conventions, but due to the above issue (people catch onto them instinctively), good conventions are hard to find. Some conventions were so good they got codified into language syntax.</p><p>   如果您想了解命名，请挖掘约定，但是由于上述问题（人们本能地抓住它们），很难找到好的约定。一些约定非常好，它们被编入语言语法中。 </p><p> Did you know  const (i.e. immutability) wasn&#39;t a thing in any popular programming language until the early 80s when C++ came along? People (presumably) used to write it as part of variable names and hope that it would be respected by convention.</p><p>您是否知道const（即不变性）在80年代初C ++出现之前在任何流行的编程语言中都是没有意义的？人们（大概）曾经将它写为变量名的一部分，并希望它能被惯例所尊重。</p><p> The idea of objects and classes are essentially a mix of naming and file-placement conventions that got mixed, at least in imperative land.</p><p> 对象和类的概念本质上是命名约定和文件放置约定的混合，至少在必要的情况下，它们混合在一起。</p><p> Even more so, one suspects that &#34;types&#34; were originally a mere naming convention, though the asteroid destroyed most of the evidence that could be used to conclude that with certainty. But nowadays &#34;types&#34; seem to be used as part of names in language lacking a type system.</p><p> 甚至更令人怀疑的是，＆＃34;键入＆＃34;最初只是一个命名约定，尽管小行星摧毁了可以用来确定结论的大多数证据。但是如今，类型似乎在缺乏类型系统的语言中用作名称的一部分。</p><p>  But, asks the reader of 2050, I heard that back in your days there as a field called &#34;mathematics&#34;, a thing humans did before computers, where they tried (and often failed miserably) to  use their brains to execute formal logic.</p><p>  但是，问到2050年的读者时，我听说在您的时代曾经是一个称为“数学”的领域，这是人类在计算机之前所做的事情，他们尝试（而且经常惨败）使用大脑进行执行形式逻辑。</p><p> You are quite perceptive in remaking that, and I agree we can&#39;t understand naming in programming while ignoring 3000 years of naming in mathematics. The most basic names in programming, those shared between most languages, those of the operators (+,-,*,/,^,&amp; ...etc) are pulled out or inspired from math.</p><p> 您在重塑时非常有洞察力，并且我同意我们不能理解编程中的命名，而忽略了3000年的数学命名。编程中最基本的名称，大多数语言之间共享的名称，运算符的名称（+，-，*，/，^，＆amp; ...等）是从数学中提取出来的或从中得到启发的。</p><p> In my arbitrarily chosen view of the world, mathematics was an imperfect tool with imperfect creators built in a time before modern brains and modern machines, thus it&#39;s riddled with  flaws and limitations. One of the most obvious flaws in the way things were named.</p><p> 在我任意选择的世界观中，数学是一个不完善的工具，在现代人的大脑和现代机器出现之前的某个时间里，不完美的创造者就建立了数学，因此它充满了缺陷和局限性。事物命名方式中最明显的缺陷之一。</p><p> When using &#34;math notation&#34; people tended to prefer very short names, namely 1 symbol long. A programmer might write something akin to:</p><p> 当使用＆＃34;数学符号＆＃34;时人们倾向于使用非常短的名称，即1个符号长。程序员可能会写类似于以下内容的内容： </p><p>    However, in math notation, it would be considered bad form to write anything longer or more expressive than</p><p>但是，以数学符号表示，写任何比</p><p>   Reducing the amount of writing in materials like sand or clay, which are cheap and easy to erase, but difficult to write in.</p><p>   减少诸如沙子或黏土之类的材料上的书写量，这些材料便宜且易于擦除，但难以书写。</p><p> This didn&#39;t cause many issues because our brains are not very good at executing formal logic. So a given mathematical construct might have included 2, 3, 5 maybe 10 entities playing around. But to postulate an equation with thousands of variable probably seemed like madness even to a genius like Euler or grand curator like Euclid.</p><p> 这并不会引起很多问题，因为我们的大脑不太擅长执行形式逻辑。因此，给定的数学构造可能包括2个，3个，5个或10个实体。但是，即使对像欧拉这样的天才或像欧几里得这样的大策展人来说，假设一个具有数千个变量的方程式似乎也很疯狂。</p><p> Of course, we live in an age where a mildly talented 8-year-old can pick up a toy language like Scratch and construct such an equation incidentally while writing a web app. Nowadays we need only write the equations, historically our brains were also responsible for executing them. This restricted the realm of possibilities to one so tiny I shudders to think about the lamentable condition of the poor souls that helped us get to where we could build computers.</p><p> 当然，我们生活在一个年龄适中，才华横溢的8岁小孩子可以学习像Scratch这样的玩具语言并在编写Web应用程序时偶然构造这样的方程式的时代。如今，我们只需要编写方程式，从历史上看，我们的大脑也负责执行这些方程式。这将可能性的范围限制在一个如此微小的范围内，我颤抖着去思考那些可怜的灵魂的悲惨状况，它们帮助我们到达了可以建造计算机的地方。</p><p> Still, the reason why the previously mentioned interest computing function would work is that the writer could simply specify beforehand: &#34;p stands for principal, r for rate, q for number of quarters&#34;.</p><p> 仍然，前面提到的兴趣计算功能起作用的原因是作者可以简单地预先指定：＆＃34; p代表本金，r代表利率，q代表季度数＆＃34;。</p><p> This is a practice that remained with us until the 80s in a weird way, the name of variables used to be declared at the beginning of a file before they were initialized. Though it may seem crazy to you, C and C++ allow you to compile the following code:</p><p> 直到80年代，这种做法一直在我们中间保持着一种怪异的方式，即变量名通常在文件初始化之前就在文件的开头声明。尽管对您来说似乎很疯狂，但是C和C ++允许您编译以下代码：</p><p>    This used to be the preferred way to initialize things in ancient times, or so I&#39;m told, and one has to think it might have, in a twisted way, arisen from the way mathematics separated &#34;definition&#34; from &#34;usage&#34; for its variables.</p><p>    有人告诉我，这曾经是古代人初始化事物的首选方式，而且人们不得不认为它可能以一种扭曲的方式产生于数学将“定义”分离的方式。 ;来自＆＃34;用法＆＃34;对于它的变量。 </p><p> Maybe I&#39;m being a bit droll here, so let&#39;s move the example to a function that computes savings with compounded interest:</p><p>也许我在这里有点笨拙，所以让我们将示例移至一个函数，该函数可计算复利：</p><p>  Here we see an interesting quirk that greatly influences how we name things, reassigning values to a variable.</p><p>  在这里，我们看到了一个有趣的怪癖，它极大地影响了我们如何命名事物，将值重新分配给变量。</p><p> I must confess that I&#39;m unsure why this isn&#39;t done in. It seems like a potentially good practice, but I&#39;m surprised it&#39;s so good that people stumbled upon it 3000 years ago and it stuck.</p><p> 我必须承认我不确定为什么没有这样做。这似乎是一种潜在的好习惯，但是我很惊讶它如此好，以至于3000年前人们偶然发现了它它卡住了。</p><p> Either way, this does seem to have some remarkable effects upon the way we name things, consider the above function but written as:</p><p> 无论哪种方式，这似乎对我们命名事物的方式都产生了显着影响，考虑上述功能，但写为：</p><p> function calc_quarterly_compounded_savings(principal, rate, quarters): let gains = 0 for i in 0..quarters: gains += (principal+gains)*rate return principal+gains</p><p> 函数calc_quarterly_compounded_savings（本金，利率，季度）：让0中的i的收益= 0..quarters：收益+ =（本金+收益）*收益率本金+收益</p><p>  Another could argue that by adding  gains to the above we moved from an abstract function to an intuitive explanation of one of the fundamental concepts behind modern monetary systems.</p><p>  另一个人可能会争辩说，通过在上述内容上增加收益，我们从抽象的功能转向了对现代货币体系背后的基本概念之一的直观解释。</p><p> All of this because we sacrificed some simplicity (added a variable) but gained a concept (gains). We may also postulate some middle ground such as:</p><p> 所有这些都是因为我们牺牲了一些简单性（添加了一个变量）但获得了一个概念（收益）。我们还可以假设一些中间立场，例如： </p><p> function calc_quarterly_compounded_savings(principal, rate, quarters): let accumulated = principal for i in 0..quarters: accumulated = accumulated*rate return accumulated</p><p>函数calc_quarterly_compounded_savings（本金，利率，季度）：让累加= 0中i的本金。季度：累加=累加*累加的收益率</p><p> The above maintains a distinction between the idea of &#34;principal&#34; and &#34;gains&#34; presented in the second implementation while preserving the elegant logic of the first.</p><p> 上面在“原理”和“原理”之间保持了区别。和＆＃34;获得＆＃34;在第二种实现中展示，同时保留了第一种实现的优雅逻辑。</p><p> But that &#34;pointless&#34; assignment  let accumulated = principal, interestingly enough, seems closely related to what I described before as the staple of mathematical notation, separation of definition and usage, but with a twist.</p><p> 但这是毫无意义的有趣的是，赋值让“累加=主体”似乎与我之前所说的数学符号，定义和用法的分离密切相关，但有一点曲折。</p><p> As an aside, mathematics would, of course, elegantly solve this problem by introducing another layer of abstraction (powers) and saying:</p><p> 顺便说一句，数学当然可以通过引入另一层抽象（幂）并说出：</p><p>  Though in practice this approach seems to often come up against limits (see early 20th century).</p><p>  尽管在实践中，这种方法似乎经常遇到限制（请参阅20世纪初）。</p><p> Once again, I digress, can we attribute the distinction between mathematics and programming to be in part that programming grew up with &#34;free&#34; paper while math&#39;s infancy was in a time where paper was expensive? Not fully I think, but it&#39;s a factor we shouldn&#39;t overlook.</p><p> 我再说一遍，我们能否将数学和编程之间的区别归因于部分原因在于编程是随着“免费”而长大的？还是数学的婴儿期是纸很贵的时代？我认为并不完全，但这是我们不容忽视的一个因素。</p><p> I find it interesting that, now that Rust and Scala have become a thing, functional languages have (mainly) migrated from motivating their choices with safety to motivating them purely on an aesthetic basis.</p><p> 我发现有趣的是，既然Rust和Scala已经成为一件事，功能语言（主要）已经从安全地激励他们的选择过渡到纯粹在美学基础上激励它们。 </p><p>  I don&#39;t want to dig too deep into the whole math/functional aesthetic, but in terms of naming, I think they are quite different. Mathematics ended up tabooing names longer than one symbol, and thus found itself with hundreds of weird signs, each of which might have dozens or even hundreds of different definitions depending on the field it was used in.</p><p>我不想深入研究整个数学/函数美学，但就命名而言，我认为它们是完全不同的。数学最终禁忌使用超过一个符号的名称，因此发现自己有数百个怪异的符号，根据使用的领域，每个符号可能具有数十个甚至数百个不同的定义。</p><p> If I am to judge functional programming by the standard libraries and software written in Haskell, Clojure and Elixir, I could easily claim their names are often quite expressive and fairly long.</p><p> 如果我要通过使用Haskell，Clojure和Elixir编写的标准库和软件来判断函数式编程，我可以轻松地断言它们的名称通常具有很强的表达力和较长的名称。</p><p> Surprisingly, short names are more often than not found in imperative code, just look up a few C++ or C codebases at random and you&#39;re bound to see a slew of 1-3 character entities harkening your confusion.</p><p> 令人惊讶的是，短名称在命令性代码中经常找不到，只是随机查找几个C ++或C代码库，您一定会看到大量1-3个字符的实体，这使您感到困惑。</p><p> Might there be a reason for this? Probably not, but allow me to speculate one:</p><p> 可能有原因吗？可能不是，但是让我推测一下：</p><p> Short names require us to have a &#34;mental map&#34; of each variable inside a &#34;working cache&#34; or sort, you have to be able to instantly map  p to  principal in one context, to  prediction in another and to  partition in yet another.</p><p> 简短的姓名要求我们拥有＆＃34; mental map＆＃34;在＆＃34;工作缓存＆＃34;中的每个变量或排序，您必须能够在一个上下文中立即将p映射到主体，在另一个上下文中进行预测，并在另一个上下文中进行分区。</p><p> So in that sense, short-names might serve as a safeguard for limiting the size of a given block of logic, after all, this temporary mental map can only hold a few symbols and still be efficient.</p><p> 因此，从这个意义上说，短名称可能是限制给定逻辑块大小的一种保障措施，毕竟，此临时思维导图只能容纳几个符号并且仍然有效。</p><p> On the other hand, especially when on a flow, we may be tempted to use expressive names in order to write monstrously sized blocks of logic. Functional programming seems to have other ways of safeguarding against this style, so that may have caused short names to be more a staple of imperative languages?</p><p> 另一方面，尤其是在流程中，我们可能会倾向于使用表达性名称来编写大小庞大的逻辑块。函数式编程似乎还有其他方法可以防止这种风格出现，因此可能导致短名称更成为命令式语言的主要内容？ </p><p> Another interesting thing about short names is that, due to the aforementioned mental map required to work with them, they may serve as an interesting way of switching between mental modes of operations.</p><p>关于短名称的另一件有趣的事情是，由于需要与它们一起使用的上述思维导图，它们可能成为在思维的思维方式之间进行切换的一种有趣方式。</p><p> Personally, when some piece of logic becomes too complex, the steps I go through are:</p><p> 就个人而言，当某些逻辑变得过于复杂时，我要经过的步骤是：</p><p>  I think there  might be some strength to the idea that short notations are better for thinking about algorithmic problem-solving.</p><p>  我认为，短符号更适合于考虑算法问题的解决方案，这一观点可能有一定的优势。</p><p> It might also be that they so often get used in more &#34;traditional&#34; and &#34;mathematically related&#34; areas of CS (as well as physics) due to habit or  math-envy.</p><p> 也可能是因为它们经常被更多的＆＃34; raditional＆＃34;使用。和＆＃34;与数学相关的＆＃34;由于习惯或数学嫉妒而导致CS领域（以及物理领域）出现的情况。</p><p> The answer may also lie at the border of habit and intrinsic quality, most people might be taught to separate verbal communication and logic at a young age (for obvious reasons) and certain queues (e.g. seeing 1-letter variables) may inclined one towards thinking logically/mathematically while others (e.g. seeing distinguishable words) might invoke a more prosaic mood.</p><p> 答案可能还在于习惯和内在素质的边界，大多数人可能被教导要在年轻时将言语交流和逻辑分开（出于明显的原因），并且某些队列（例如，看到1个字母的变量）可能会使人倾向于思考在逻辑/数学上，而其他人（例如，看到可区分的单词）可能会引起平淡无奇的情绪。</p><p>  But, assume for a second that, for whatever reason, shorthand names allowed for more clever code. Should we use them?</p><p>  但是，考虑一下，无论出于何种原因，速记名称都允许使用更聪明的代码。我们应该使用它们吗？</p><p> I don&#39;t think so. Whoever will have to read those afterwards will have the extra difficult job of having to be in a special &#34;state of mind&#34; to make sense of the code, a state of mind that might be difficult or annoying to attain.</p><p> 我不这么认为。以后必须阅读这些内容的人都会面临额外的困难，即必须处于一种特殊的“心态”中。使代码有意义，这是一种可能难以实现或烦人的心态。 </p><p> That&#39;s not to mention that you yourself might be forced to read that code, and the you of the future might be dumber, more tired or just lack the time or excitement.</p><p>更不用说您自己可能被迫阅读该代码，而未来的您可能会变得笨拙，更加疲倦，或者只是缺乏时间或兴奋。</p><p> Actually, it&#39;s rather curious to see how names differ depending on the kind of team working on a codebase. This might be a sweeping generalization, but I tend to see longer and more detailed names in more &#34;enterprisey&#34; environments and shorter ones in more &#34;hobbyistic&#34; or &#34;startupy&#34; environments.</p><p> 实际上，很奇怪地看到名称如何根据在代码库上工作的团队的类型而有所不同。这可能是一个笼统的概括，但是我倾向于在更多的＆enterprisey＆＃34;中看到更长，更详细的名称。环境，而在更多＆＃34; hobbyistic＆＃34;中较短的环境或＆＃34; startupy＆＃34;环境。</p><p> Someone writing:  purchase_customer_transaction_instantiation.CollectAllInventoryFromCustomerShoppingCart versus  buy_trx.get_cart_content is a fairly reliable indicator as to whether they are working in a tiny company or a publically traded behemoth.</p><p> 有人写道：purchase_customer_transaction_instantiation.CollectAllInventoryFromCustomerShoppingCart与buy_trx.get_cart_content是一个相当可靠的指标，可以确定它们是在小型公司中还是在公开上市的庞然大物中工作。</p><p> Larger teams and larger companies usually operate within harder constraints. The codebases tend to be more complex and older, there&#39;s a lot of people working on them and they&#39;ve likely passed through many pairs of hands to reach this point. The employees usually cover a more diverse spectrum in terms of backgrounds and skills. Refactoring becomes harder to do, regardless of complexity, because of within-company dependencies and the need to update the mental model of the codebase for a larger team.</p><p> 较大的团队和较大的公司通常在更严格的约束下运作。代码库往往更复杂和更老，有很多人在使用它们，而他们很可能经过许多双手才能达到这一点。员工通常在背景和技能方面涵盖范围更加广泛。由于公司内部的依赖性以及需要为更大的团队更新代码库思维模型的需要，无论复杂程度如何，重构都变得更加困难。</p><p> Long names help with all of those things. As I hinted at before, &#34;knowing&#34; a codebase is akin to knowing all the names. More verbose names seem like a wonderfully obvious ways of making sure everyone is &#34;on the same page&#34; in regards to what something is doing.</p><p> 长名可以帮助所有这些事情。正如我之前所暗示的，＆＃34;知道＆＃34;代码库类似于知道所有名称。更冗长的名称似乎是确保每个人都在同一页面上的一种非常明显的方式。关于正在做什么。</p><p>  I can&#39;t point to one, but it rubs me the wrong way. On a surface level, it feels patronizing. The names of things are os &#34;obvious&#34; that it in part takes away the fun of &#34;getting&#34; the context I&#39;m in or the challenge of coming up with expressive (i.e. small size, high information) names.</p><p>  我不能指着一个，但是用错误的方式使我感到困惑。从表面上看，它让人感到光顾。事物的名称是os＆＃34; obvious＆＃34;从而部分抵消了“获取”的乐趣我所处的环境或提出具有表现力（即小尺寸，高信息量）名称的挑战。</p><p> Shorter names allow for more efficient operation, provided that you have a context-appropriate mapping cached in working memory.</p><p> 如果您在工作内存中缓存了上下文相关的映射，则较短的名称可以提高操作效率。 </p><p> Even so, shorter names have the downside of requiring to be familiar with the potential &#34;contexts&#34; inside a codebase and how they interact in order to build this map.</p><p>即使这样，短名称也有要求熟悉潜在的＆contexts＆＃34;的缺点。代码库内部以及它们如何交互以构建此地图。</p><p>  From a felt and aesthetic point of view, I want the answer to be no. From a reductionist point of view, I can see a lot of good straightforward arguments for longer names and just a bunch of fuzzy reasons for preferring short ones.</p><p>  从感觉和美学的角度来看，我希望答案是否定的。从简化派的角度来看，我可以看到很多关于长名称的简单明了的论据，而只是一堆模糊的原因，他们更喜欢短名称。</p><p>   I&#39;ve explored a few things regarding names here, but overall I&#39;m more confused than when I started writing this. The only thing I can say with certainty is:</p><p>   我在这里探讨了一些有关名称的事情，但总的来说，与我开始撰写本文时相比，我更加困惑。我唯一可以肯定地说的是：</p><p>   Every codebase has naming conventions and they are often implicit, people have little problem picking up on them.</p><p>   每个代码库都有命名约定，并且它们通常是隐式的，人们在选择它们时几乎没有问题。</p><p> Context is very important for determining a good name, and the ability of your team to &#34;context switch&#34; might lead to widely different naming schemas.</p><p> 上下文对于确定好名字非常重要，这对于您的团队具有“进行上下文切换”的能力非常重要。可能导致命名模式大不相同。</p><p>  Longer names seem, on the surface, superior. But ( something  something) short names might help with problem-solving and code partitioning.</p><p>  从表面上看，较长的名称似乎比较好。但是（某些东西）短名称可能有助于解决问题和代码分区。</p><p> The best naming practices already made it into a language, if you have a naming practice you always use it might be a good guide for languages you might like.</p><p> 最佳的命名惯例已经将其变成一种语言，如果您经常使用命名惯例，那么它可能是您喜欢的语言的一个很好的指南。 </p><p>  I think there are four topics that I&#39;d be interested in exploring more in a followup to this post.</p><p>我认为在这篇文章的后续文章中，我有四个主题有兴趣进一步探讨。</p><p> One is the link between IDE-like tooling and names. For example, could emojis and colours be used when naming? I&#39;m thinking, for example, having short yet expressive names that don&#39;t trigger a &#34;verbal reasoning mode&#34; via emojis. Or demarcating context or certain properties via colour (in part IDEs already do this with their highlighting). Is anyone experimenting with this? If so, please let me know.</p><p> 一种是类似IDE的工具和名称之间的链接。例如，命名时可以使用表情符号和颜色吗？我在想，例如，具有简短而富有表现力的名字，不会触发“语言推理模式”。通过表情符号。或通过颜色划分上下文或某些属性（部分IDE已经通过突出显示来做到这一点）。有人在尝试这个吗？如果是这样，请告诉我。</p><p> Secondly, I&#39;d be curious to run a name-analysis on popular open-source codebases and try to gather some aggregate statistics as well as look for patterns... maybe even find a fun way to use some hugging face models to extract some insight out of them.</p><p> 其次，我很想对流行的开源代码库进行名称分析，并尝试收集一些汇总统计数据以及寻找模式...甚至可能找到一种有趣的方法来使用一些拥抱的面孔模型来从他们那里提取一些见识。</p><p> Third, I&#39;d like to run a temporal change analysis on various codebases with a long git history to see how names progress as the codebase and number of maintainers grow.</p><p> 第三，我想对具有较长git历史的各种代码库进行时间变化分析，以了解名称如何随着代码库和维护者数量的增长而发展。</p><p> Fourth, I&#39;ve been curious for a while to try an experiment where I provide a &#34;math&#34; and a &#34;code&#34; version of the same function to a bunch of people that are used to working with both representation and asking a few basic questions about it (how would you make it more efficient/shorter, how would you modify it to do x... etc). But I&#39;m afraid selecting the demographic here is difficult and expensive (math undergrads that went into a master/PhD program in CS or ML might work...).</p><p> 第四，我很奇怪地尝试了一个实验，该实验提供了一个数学工具。和一个＆＃34;代码＆＃34;一群人习惯使用相同功能的版本，并且习惯于同时使用两种表示形式并询问一些基本问题（如何使它更高效/更短，如何对其进行修改以执行x ...等） 。但是我担心在这里选择人口是困难且昂贵的（进入CS或ML的硕士/博士学位课程的数学本科生可能会工作...）。</p><p> I&#39;m awfully sorry for naming some of the elephants in the room without providing proper closure, but I&#39;m afraid doing so is nigh on impossible for a topic as global as naming.</p><p> 对于在房间中给某些大象命名而没有提供适当的封闭性，我深感抱歉，但是对于像命名这样的全球性话题，我恐怕这样做几乎是不可能的。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://cerebralab.com/The_second_hardest_thing_in_programming_-_Part_1">https://cerebralab.com/The_second_hardest_thing_in_programming_-_Part_1</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/变量/">#变量</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/naming/">#naming</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/名称/">#名称</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>