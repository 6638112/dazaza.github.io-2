<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>组合器带来的乐趣</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">组合器带来的乐趣</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-18 23:11:34</div><div class="page_narrow text-break page_content"><p>There are a bunch of “minimal” computational models out there: Turing machines, lambda calculus, PowerPoint  (Wildenhain  2017), etc. These are radically simple languages which are nonetheless Turing complete, so theoretically “as powerful” as each other. Of those, lambda calculus is without question my favourite to actually write programs in: it’s the one which is closest to crawling out of the  Turing tarpit.</p><p>市面上有一堆“最小”的计算模型：图灵机、λ微积分、PowerPoint(Wildenhain 2017)等。这些都是非常简单的语言，但图灵是完全的，理论上彼此“一样强大”。其中，lambda演算无疑是我最喜欢用来实际编写程序的演算：它是最接近从图灵油罐中爬出来的演算。</p><p> In terms of implementation, though, it is  far from simple. Lambda calculus has  variables, which introduce huge complexity into the interpreter: especially if you want to do any kind of formal reasoning about programs, this complexity is a problem. We might want to reach for something even lower-level than lambda calculus: this is where combinator calculi come in.</p><p>然而，就实现而言，这远不是一件简单的事情。Lambda演算有变量，这给解释器带来了巨大的复杂性：特别是如果你想对程序进行任何形式的推理，这种复杂性是一个问题。我们可能想要研究一些比λ微积分更低层次的东西：这就是组合子微积分的用武之地。</p><p> You may have heard of SKI combinator calculus: it’s the “simplest” of the calculi, but it’s not actually very easy to understand, and it’s absolute murder to try use. So we’re going to start with  BCKW, a more obscure calculus, actually invented by Haskell Curry.</p><p>您可能听说过ski Combinator微积分：它是微积分中“最简单的”，但实际上并不是很容易理解，尝试使用绝对是谋杀。所以我们将从BCKW开始，这是一种更为晦涩难懂的微积分，实际上是由哈斯克尔·库里(Haskell Curry)发明的。</p><p> There are 4 combinators in  BCKW:  B,  C,  K, and  W (shocking, I know). You can think about these combinators as functions which manipulate the beginning of strings:</p><p>BCKW中有4个组合符：B、C、K和W(令人震惊，我知道)。您可以将这些组合符视为操作字符串开头的函数：</p><p>  Let’s work with some examples to get a sense for how these combinators work.</p><p>让我们使用一些示例来了解这些组合符是如何工作的。</p><p> Upper case letters are combinators, lower-case are variables. Yes, yes, I know I said that combinator calculi didn’t need variables, and it doesn’t! I’m just using them here to explain how each of the combinators work. If you really want to be pedantic you can think of the lower case letters as notational placeholders meaning “any given combinator”. They won’t exist in any actual programs we write.</p><p>大写字母是组合符，小写字母是变量。是的，是的，我知道我说过组合演算不需要变量，现在也不需要！我在这里只是用它们来解释每个组合子是如何工作的。如果你真的想变得书生气十足，你可以把小写字母想象成符号占位符，意思是“任何给定的组合符”。它们不会存在于我们编写的任何实际程序中。</p><p> The simplest combinator is  K: it’s actually equivalent to the  const function from Haskell. It discards its second argument, and returns the first. If you give a combinator more arguments than it usually accepts, you just keep the extra arguments in the output:</p><p>最简单的组合符是K：它实际上等同于来自Haskell的const函数。它丢弃第二个参数，并返回第一个参数。如果为组合器提供的参数比它通常接受的参数多，则只需在输出中保留额外的参数即可：</p><p>      Next we have  C: this is equivalent to the Haskell function  flip. It swaps the second and third arguments:</p><p>接下来我们有C：，这相当于Haskell函数的翻转。它交换了第二个和第三个参数：</p><p>  Here’s a small little evaluator for expressions which use  C,  K, and  W. You can edit the expression, and press enter to step through it.</p><p>下面是一个使用C、K和W的表达式的小型求值器。您可以编辑表达式，然后按Enter键逐步执行。</p><p>    You can write parentheses yourself: implicitly, all expressions are left-associative. That means that the following are all equal:</p><p>您可以自己编写括号：隐式地说，所有表达式都是左关联的。这意味着以下各项都是相等的：</p><p>   And here’s a puzzle to start flexing your combinator skills: one of the combinators in SKI combinator calculus is  I, which is the identity function.</p><p>这里有一个开始展示你的组合器技能的难题：SKI组合器演算中的一个组合子是i，它是恒等式函数。</p><p>  Try write an expression which functions the same way as  I, using only the  BCKW combinators. Use the following evaluator to try and figure out how to do it: write an expression after  λ&gt; which functions the same as  I.</p><p>尝试仅使用BCKW组合符编写一个功能与I相同的表达式。使用以下求值器尝试并弄清楚如何执行此操作：在λ&gt；之后编写一个表达式，其功能与I相同。</p><p>      Each of the combinators we’ve defined so far work a little weird: they seem to skip over their first argument, and work on their second. Indeed, there is another, equivalent combinator calculus which doesn’t have this peculiarity:</p><p>到目前为止，我们定义的每个组合子的工作方式都有些奇怪：它们似乎跳过了第一个参数，而在第二个参数上工作。事实上，还有另一种等价的组合子演算没有这种特性：</p><p>  B stays the same in this calculus, but the rest of the combinators get switched out for seemingly simpler versions.  K goes to  A  1:</p><p>在这个微积分中B保持不变，但是其余的组合子被换成了看似更简单的形式。K转到A1：</p><p>  Which isn’t a huge change. It’s the other two where we see the real difference.  W has been swapped out for  M:</p><p>这并不是一个巨大的变化。我们看到真正不同之处的是另外两个。W已替换为M：</p><p>  As you can see  W basically does the same thing as  M, but while passing through its first argument. The difference between  T and  C is similar:</p><p>你们可以看到，W基本上和M做了同样的事情，但是通过了它的第一个参数。T和C之间的区别相似：</p><p>  So, first of all, it is pretty simple to show that  BCKW contains all of the  BAMT combinators. Try find a way to write  T using only  BCKW combinators (hint: you might want to use your previous answer for writing  I using  BCKW).</p><p>所以，首先，很简单地证明BCKW包含所有的BAMT组合子。尝试找到一种仅使用BCKW组合符来编写T的方法(提示：您可能希望使用BCKW编写I时使用先前的答案)。</p><p>   So in fact all of the changed  BAMT combinators can be encoded using  BCKW by putting  I (or  CKC or what have you) after the corresponding  BCKW combinator. In other words:</p><p>因此，实际上，所有更改后的BAMT组合符都可以使用BCKW进行编码，方法是在相应的BCKW组合符后面加上i(或CKC或其他任何内容)。换言之：</p><p>  It’s pretty easy to go from  BCKW to  BAMT, then. However, it’s  extremely difficult to go the other way. Here, try to write  K in terms of  BAMT (this is quite difficult, do not expect to get it!):</p><p>那么，从BCKW到BAMT相当容易。然而，要走另一条路是极其困难的。在这里，试着用BAMT来写K(这相当困难，不要指望能得到它！)：</p><p>     So this is why we will stick to  BCKW for the time being:  BAMT is just too painful to use.</p><p>因此，这就是我们暂时坚持使用BCKW的原因：BAMT使用起来太痛苦了。</p><p>  One of the things  BCKW has over  SKI is that each combinator represents a concrete capability.  K and  W especially: without these combinators, we can neither duplicate nor discard variables. This makes the languages without one or both of these interesting (albeit not Turing-complete).</p><p>BCKW拥有的关于SKI的一件事是，每个组合器代表一种具体的功能。特别是K和W：没有这些组合子，我们既不能复制变量，也不能丢弃变量。这使得没有其中一种或两种都没有的语言变得有趣(尽管不是完全的图灵)。</p><p> If we say that we can’t use  W, we know that the will not duplicate any input. In fact, encoded appropriately, we know that the program can only decrease its size through execution. The  BCK system is in fact an encoding of  affine logic, which is all the rage nowadays. Rust uses affine types to guarantee memory safety: by preventing duplication of references, you can know that whenever you’re looking at a variable you’re free to modify it, or destroy it if necessary (obviously Rust is a bit more complex than what I’ve described here, but  BCK is indeed the fundamental basis for the system in the same way that  SK can be the basis for any programming language).</p><p>如果我们说我们不能使用W，我们知道不会重复任何输入。事实上，如果编码得当，我们知道程序只能通过执行来减小其大小。BCK系统实际上是当今流行的仿射逻辑的编码。Rust使用仿射类型来保证内存安全：通过防止重复引用，您可以知道，无论何时查看变量，您都可以自由地修改它，或者在必要时销毁它(显然，Rust比我在这里描述的稍微复杂一些，但是BCK确实是系统的基本基础，就像SK可以作为任何编程语言的基础一样)。</p><p> If we remove  K as well we have a  linear language. This is even more restrictive, but is also quite actively researched at the moment: linear types have been used to construct languages for differential privacy, for instance.</p><p>如果我们去掉K，我们就得到了线性语言。这方面的限制甚至更多，但目前的研究也相当活跃：例如，线性类型已被用来构造用于不同隐私的语言。</p><p> There’s one small issue with  BC: it doesn’t (strictly speaking) have an equivalent to  I. You can write an expression which is  close, but it will only actually compute when applied to at least 3 arguments. See if you can find it.</p><p>BC有一个小问题：它没有(严格地说)等同于I。您可以编写一个接近的表达式，但它只有在应用于至少3个参数时才能实际计算。看看你能不能找到。</p><p>       S is the only combinator we haven’t seen yet. It’s kind of a combination of  B,  C, and  W:</p><p>%s是我们还没有见过的唯一一个Combinator。它有点像是B、C和W的组合：</p><p>  It does parenthesising, reordering,  and duplication. This allows it to be powerful to be Turing complete only with the addition of  K. Try first to construct  I given only  S and  K:</p><p>它可以插入、重新排序和复制。这使得它可以是强大的，只有在添加K的情况下才能完成图灵。尝试首先构造I，仅给出S和K：</p><p>          Of course, to show that  SK is universal we’d need to show that it contains one of the other universal systems. We won’t do that exhaustively here, but first just try to figure out  B and  W:</p><p>当然，要证明SK是通用的，我们需要证明它包含其他通用系统之一。我们不会在这里详细说明，但首先试着找出B和W：</p><p>          The next task is to encode the  Y combinator. This is a combinator that evaluates to the following:</p><p>下一个任务是对Y组合符进行编码。这是一个合并器，计算结果如下：</p><p>  As you can see, it encodes  recursion. Like the  fix function in Haskell, this combinator allows us to do recursion without explicit self-reference. And, of course, we can define this combinator using the combinators we’ve seen before, since our language is Turing complete. One encoding is  BM(CBM):</p><p>如您所见，它对递归进行编码。与Haskell中的FIX函数一样，此组合器允许我们在没有显式自引用的情况下进行递归。当然，我们可以使用我们以前见过的组合子来定义这个组合子，因为我们的语言是图灵完成的。一种编码是BM(CBM)：</p><p>  As you can see,  BM(CBM), when applied to  f, yields  f(M(CBMf)), which is equivalent to  f(BM(CBM)f) (the  B just hasn’t been applied inside the  f). So this is indeed a proper recursion combinator.</p><p>如您所见，bm(Cbm)，当应用于f时，产生f(M(Cbmf))，相当于f(bm(Cbm)f)(B只是没有在f中应用)。所以这确实是一个合适的递归组合器。</p><p>   In the lambada calculus, to encode numbers we often use the  church numerals: that’s what we’re going to do here, too. A church numeral representing some number    n n is a function which takes two arguments, and applies the first argument to the second    n n times. Here are some church numerals in Haskell:</p><p>在lambada演算中，为了编码数字，我们通常使用教会数字：这也是我们在这里要做的。表示某个数字n n的教会数字是一个函数，它接受两个参数，并将第一个参数应用于第二个n次。以下是哈斯克尔的一些教会数字：</p><p> zero :: (a -&gt; a) -&gt; a -&gt; azero f x = xone :: (a -&gt; a) -&gt; a -&gt; aone f x = f xtwo :: (a -&gt; a) -&gt; a -&gt; atwo f x = f (f x)three :: (a -&gt; a) -&gt; a -&gt; athree f x = f (f (f x))</p><p>零：：(a-&gt；a)-&gt；a-&gt；Azerfx=xone：：(a-&gt；a)-&gt；a-&gt；aone f x=f xTwo：：(a-&gt；a)-&gt；a-&gt；atwo f x=f(Fx)三：：(a-&gt；a)-&gt；a-&gt；atrifx=f(f(Fx))</p><p> Encoding these numerals in combinators is a little more difficult. Zero and one are obvious: they are  A and  I, respectively. Try to figure out two and three:</p><p>在组合符中对这些数字进行编码稍微困难一些。0和1是显而易见的：它们分别是A和I。试着算出2和3：</p><p>    WB    SB(WB) It turns out that it’s pretty easy to encode numbers in a relatively small amount of space, using a binary encoding. First, multiplication on Church numerals is simply composition: so that’s  B on our combinators. We already have 2 defined, so the next thing we need for a binary encoding is a successor function. And we know what  that is, from the answer to 3!</p><p>WB SB(WB)事实证明，使用二进制编码，在相对较小的空间内对数字进行编码是相当容易的。首先，教会数字上的乘法就是简单的合成：所以这就是我们的合并器上的B。我们已经定义了2，所以二进制编码的下一件事是后继函数。我们知道这是什么，从答案到3！</p><p> This means we can encode normal number in      𝒪 ( log n ) \mathcal{O}(\log n) space (although it still takes linear time to evaluate). The following repl allows for numbers:</p><p>这意味着我们可以在𝒪(Logn)\数学{O}(\logn)空间中编码正态数(尽管计算仍然需要线性时间)。下面的repl允许使用数字：</p><p>  We could take up even less space if we allowed for non-normal forms. 4, for instance, could be encoded like so:</p><p>如果我们考虑非正规形，我们可以占用更少的空间。例如，4可以这样编码：</p><p>  But we generally prefer to keep our encodings in normal form: otherwise there’s some extra evaluation we have to pay for when we go to use them.</p><p>但是我们通常更喜欢将我们的编码保持在标准形式：否则，当我们使用它们时，我们必须支付一些额外的评估费用。</p><p>  Once upon a time SKI combinators were used as a target for functional compilers: Miranda, Haskell’s precursor, compiled down to a set of combinators which included  SKI. Nowadays, Haskell is compiled to the “spineless tagless G-machine”: its compilation technique took over from combinators in the late 80s, and has been the dominant form since. Apparently the reason is that, on the current architecture of most computers, combinator-based compilation targets just aren’t fast enough. They generate too much garbage: as a result, switching to the STG yielded about a 40% speedup.</p><p>曾几何时，SKI组合器被用作函数编译器的目标：Haskell的前身Miranda被编译成一组包含SKI的组合器。如今，Haskell被编译成“无刺无标记的G-机器”：它的编译技术在80年代末取代了组合器，从那以后一直是主导形式。显然，原因在于，在当前大多数计算机的体系结构上，基于组合器的编译目标不够快。它们会产生太多的垃圾：因此，切换到STG会带来大约40%的加速。</p><p>  An Introduction to Combinator Compilers and Graph Reduction Machines, by  David Graunke  ( 2016), which goes through a high-level history and explanation of combinator compilers and why we switched away from them. A very interesting tidbit in this talk was that some people started making custom hardware to handle combinator calculi a little better. Even more interesting is the fact that these days we have FPGAs all over the place, so maybe combinator compilers are ripe for reintroduction?</p><p>David Graunke(2016)的“Combinator编译器和图形缩减机简介”(A Introduction To Combinator Compilers And Graph Reducing Machines)，它回顾了Combinator编译器的高级历史和解释，以及我们为什么放弃它们。这次演讲中一个非常有趣的花絮是，一些人开始制作定制的硬件来更好地处理组合子演算。更有趣的是，这些天我们到处都是FPGA，所以也许重新引入组合器编译器的时机已经成熟了？</p><p> Combinators Revisited, by  Edward Kmett  ( 2018), which goes through a little more of the details of the problems with combinator compilers, and mentions some of the places in which we’re tantalisingly close to making combinator compilation work.</p><p>Edward Kmett(2018)的“Combinator Revisked”一书更详细地介绍了Combinator编译器的问题，并提到了一些我们非常接近使Combinator编译工作的地方。</p><p> So compilation to combinators was once upon a time an extremely active area of research, but it has since fallen by the wayside a little because our current hardware is unable to evaluate it efficiently. What this means for us, though, is that there’s a large body of work on how to compile lambda terms to combinators!</p><p>因此，合并器的编译曾经是一个非常活跃的研究领域，但后来由于我们目前的硬件无法有效地评估它，它已经有点半途而废了。不过，这对我们来说意味着有大量的工作是关于如何将lambda术语编译成组合子的！</p><p> We use the following basic combinator set for compilation:  SKIBC.  S is really the most important one here: of course we only need it and  K, but we use  I because it dramatically simplifies the expressions we generate, and we use  B and  C because they are special cases of  S, as we’ll see in a second. The translation works like so:</p><p>我们使用以下基本组合器集进行编译：SKIBC。S在这里是最重要的：当然我们只需要它和K，但是我们使用i是因为它极大地简化了我们生成的表达式，我们使用B和C是因为它们是S的特例，我们稍后会看到。翻译是这样进行的：</p><p> \x. e1 e2 -&gt; S (\x. e1) (\x. e2)\x. x -&gt; I\x. e -&gt; K e</p><p>\x.e1 e2-&gt；S(\x.e1)(\x.E2)\x.x-&gt；i\x.e-&gt；K e。</p><p> The translation works bottom-up. We’re only interested in removing the lambdas: combinator calculus does have application, after all, so there’s nothing we need to do in that case. For that reason, the algorithm is often called “abstraction elimination”, and it’s the one the  pointfree.io uses to automatically pointfree Haskell expressions.</p><p>翻译工作是自下而上的。我们只对删除lambdas感兴趣：毕竟Combinator演算确实有应用程序，所以在这种情况下我们不需要做任何事情。因此，该算法通常被称为“抽象消除”，并且它也是无点.io用来自动执行无点Haskell表达式的算法。</p><p> There are three forms of abstraction: abstraction into an expression which is an application, abstraction which returns its argument, and abstraction which returns something other than its argument. In the first case, we use  S to pass the argument down each branch of the abstraction. In the second, we just use  I. And in the third case, we use  K to just ignore the argument. We won’t ever get  \x. \y. e, since the algorithm works bottom-up, so the  \y. e is eliminated before looking at the  \x. \y. e.</p><p>抽象有三种形式：抽象为表达式(即应用程序)、抽象(返回其参数)和抽象(返回参数以外的内容)。在第一种情况下，我们使用S向下传递抽象的每个分支的参数。在第二种情况下，我们只使用I，在第三种情况下，我们使用K来忽略参数。我们永远得不到\x\y，因为算法是自下而上工作的，所以在查看\x\y之前，\y会被去掉。</p><p> B and  C work like special cases of  S: when we pass  x down both branches of the application in the first case, sometimes that work is unnecessary. Sometimes one of the branches doesn’t use the passed variable: in this case, we use  B or  C, depending on which branch ignores the variable.</p><p>B和C的工作方式类似于S的特殊情况：当我们在第一种情况下向应用程序的两个分支传递x时，有时这项工作是不必要的。有时其中一个分支不使用传递的变量：在本例中，我们使用B或C，具体取决于哪个分支忽略该变量。</p><p> \x. e1 e2, x ∉ e1 -&gt; B e1 (\x. e2)\x. e1 e2, x ∉ e2 -&gt; C (\x. e1) e2</p><p>\x.e1 e2，x∉e1-&gt；B e1(\x.E2)\x.e1 e2，x∉e2-&gt；C(\x.e1)e2。</p><p> There is one issue with this approach: it produces combinator expressions which are of order      𝒪 (  n 3 ) \mathcal{O}(n^3) larger than the corresponding lambda expression. With some tricks (like our usage of  C and  B) we can get that down to      𝒪 (  n 2 ) \mathcal{O}(n^2), but that’s still a pretty unpleasant size increase.</p><p>这种方法有一个问题：它产生的组合子表达式的阶为𝒪(N3)\mathcal{O}(n^3)，比相应的lambda表达式大。通过一些技巧(比如我们使用C和B)，我们可以将其简化为𝒪(N2)\mathcal{O}(n^2)，但这仍然是一个非常令人不快的大小增加。</p><p> The issue is that we’re basically passing the arguments as a singly-linked list, where naive access is     𝒪 (  𝓃 2 ) \mathcal{O(n^2)}, and more sophisticated access is      𝒪 ( n ) \mathcal{O}(n).</p><p>问题是我们基本上将参数作为单链表传递，其中简单的访问是𝒪(𝓃2)\mathcal{O(n^2)}，而更复杂的访问是𝒪(N)\mathcal{O}(N)。</p><p> Oleg Kiselyov wrote a  paper  ( 2018) on getting this down to      𝒪 ( n ) \mathcal{O}(n), with some memoisation. There’s also a blog post  (Lynn  2018), describing how to get that conversion without memoisation in      𝒪 ( n log n ) \mathcal{O}(n \log n) time, and an online implementation  here.</p><p>奥列格·基塞廖夫(Oleg Kiselyov)写了一篇论文(2018年)，内容是将这一点归结为𝒪(N)\Mathcal{O}(N)，并附上了一些备忘录。还有一篇博客文章(Lynn2018)，描述了如何在𝒪(Nlogn)\Mathcal{O}(n\logn)时间内获得转换而不需要记忆，并在这里提供了一个在线实现。</p><p>  That’s all for this post! I’ll probably write more about combinators in the future: they’re an extremely interesting subject, and a lot of fun as puzzles to mess around with. One thing that I haven’t mentioned is the connection between combinators and concatenative languages: it turns out that these two things are pretty much the same thing! Maybe I’ll look at it in a future post.</p><p>这就是这篇文章的全部内容！将来我可能会写更多关于组合子的文章：它们是一个非常有趣的主题，像拼图一样非常有趣。有一件事我没有提到，那就是组合符和串联语言之间的联系：事实证明，这两件事几乎是一回事！也许我会在以后的帖子里看看。</p><p>  Graunke, David. 2016. “An Introduction to Combinator Compilers and Graph Reduction Machines.” St. Louis.  https://www.youtube.com/watch?v=GawiQQCn3bk.</p><p>格朗克，大卫。2016年。“组合器编译器和图形缩减机简介。”圣路易斯。Https://www.youtube.com/watch?v=GawiQQCn3bk.。</p><p> Kiselyov, Oleg. 2018. “   λ \lambda to SKI, Semantically.” In  Functional and Logic Programming, ed by. John P. Gallagher and Martin Sulzmann, 33–50. Lecture Notes in Computer Science. Cham: Springer International Publishing. doi: 10.1007/978-3-319-90686-7_3.  http://okmij.org/ftp/tagless-final/ski.pdf.</p><p>基塞廖夫，奥列格。2018年。“从语义上讲，λ\lambda表示滑雪。”在函数式和逻辑程序设计中，由。约翰·P·加拉格尔和马丁·苏兹曼，33胜50负。计算机科学讲义。查姆：斯普林格国际出版社。网址：90686-7_3.http://okmij.org/ftp/tagless-final/ski.pdf.。</p><p>  Lynn, Ben. 2018. “Ben Lynn’s Online Garbage: Lambda the Penultimate.”  Ben Lynn’s Online Garbage.  https://benlynn.blogspot.com/2018/11/lambda-penultimate_16.html.</p><p>林恩，这是本。2018年。“本·林恩的网上垃圾：倒数第二个兰姆达。”本·林恩的网上垃圾。Https://benlynn.blogspot.com/2018/11/lambda-penultimate_16.html.。</p><p> If you want to look up these combinators elsewhere, this is the only one you won’t be able to find: it’s much less common than  K, and where I have found it people just call it  K, so I had to pick a different letter to distinguish it ↩︎</p><p>如果你想在其他地方查找这些组合符，这是你唯一找不到的：它比K少见得多，在我发现它的地方，人们只叫它K，所以我不得不选一个不同的字母来区分它↩︎</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://doisinkidney.com/posts/2020-10-17-ski.html">https://doisinkidney.com/posts/2020-10-17-ski.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/组合/">#组合</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fun/">#fun</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>