<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>学习使用过多的链接列表（2019年）Learning rust with entirely too many linked lists (2019)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Learning rust with entirely too many linked lists (2019)<br/>学习使用过多的链接列表（2019年）</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 02:21:29</div><div class="page_narrow text-break page_content"><p>Got any issues or want to check out all the final code at once? Everything&#39;s on Github!</p><p>有什么问题吗，或者想立刻查看所有最终代码？一切&#39；在Github上！</p><p> NOTE: The current edition of this book is written against Rust 2018,which was first released with rustc 1.31 (Dec 8, 2018). If your rust toolchainis new enough, the Cargo.toml file that  cargo new creates should contain theline  edition = &#34;2018&#34; (or if you&#39;re reading this in the far future, perhapssome even larger number!). Using an older toolchain is possible, but unlocksa secret  hardmode, where you get extra compiler errors that go completelyunmentioned in the text of this book. Wow, sounds like fun!</p><p>注：本书的最新版本是针对Rust 2018编写的，该版本首次与rustc 1.31一起发布（2018年12月8日）。如果你的铁锈工具链足够新，货物。cargo new创建的toml文件应该包含Line edition=&#34；2018&#34; （或者如果你&#39；在遥远的未来重读这篇文章，也许会有更多的人！）。使用一个旧的工具链是可能的，但是解锁一个秘密的硬模式，在那里你会得到额外的编译器错误，这些错误在本书的正文中完全没有提到。哇，听起来很有趣！</p><p> I fairly frequently get asked how to implement a linked list in Rust. Theanswer honestly depends on what your requirements are, and it&#39;s obviously notsuper easy to answer the question on the spot. As such I&#39;ve decided to writethis book to comprehensively answer the question once and for all.</p><p>我经常被问到如何在Rust中实现链表。答案实际上取决于你的要求是什么，它&#39；很明显，当场回答这个问题并不容易。因此我&#39；I’我决定写这本书是为了一劳永逸地全面回答这个问题。</p><p> In this series I will teach you basic and advanced Rust programmingentirely by having you implement 6 linked lists. In doing so, you shouldlearn:</p><p>在本系列中，我将通过让您实现6个链表来教您基本和高级的Rust编程。这样做，你应该学会：</p><p>  Yes, linked lists are so truly awful that you deal with all of these concepts inmaking them real.</p><p>是的，链表真的很糟糕，以至于你要处理所有这些概念，把它们变成现实。</p><p> Everything&#39;s in the sidebar (may be collapsed on mobile), but for quickreference, here&#39;s what we&#39;re going to be making:</p><p>一切&#39；侧边栏中的s（在移动设备上可能会折叠），但为了快速参考，这里&#39；这就是我们&#39；我们要做的是：</p><p>  Just so we&#39;re all the same page, I&#39;ll be writing out all the commands that Ifeed into my terminal. I&#39;ll also be using Rust&#39;s standard package manager, Cargo,to develop the project. Cargo isn&#39;t necessary to write a Rust program, but it&#39;s so much better than using rustc directly. If you just want to futz around youcan also run some simple programs in the browser via  play.rust-lang.org.</p><p>就这样我们&#39；我们都是同一页，我&#39；我会把输入终端的所有命令都写出来。我&#39；我们还将使用锈#39；s标准包装经理Cargo负责开发该项目。货物不是&#39；没有必要编写一个Rust程序，但它&#39；这比直接使用rustc要好得多。如果你只是想玩，你也可以通过play在浏览器中运行一些简单的程序。rust-lang.org。</p><p> In later sections, we&#39;ll be using &#34;rustup&#34; to install extra Rust tooling.I strongly recommend  installing all of your Rust toolchains using rustup.</p><p>在后面的章节中，我们&#39；将使用&#34；生锈&#34；安装额外的防锈工具。我强烈建议您使用Rustop安装所有防锈工具链。</p><p>   We&#39;ll put each list in a separate file so that we don&#39;t lose any of our work.</p><p>我们&#39；我会把每一份清单放在一个单独的文件里，这样我们就不会&#39；不要丢掉我们的工作。</p><p> It should be noted that the  authentic Rust learning experience involveswriting code, having the compiler scream at you, and trying to figure outwhat the heck that means. I will be carefully ensuring that this occurs asfrequently as possible. Learning to read and understand Rust&#39;s generallyexcellent compiler errors and documentation is  incredibly important tobeing a productive Rust programmer.</p><p>需要注意的是，真正的生锈学习体验包括编写代码、让编译器对你大喊大叫，以及试图弄清楚这到底意味着什么。我将认真确保这种情况尽可能频繁地发生。学习阅读和理解锈迹&#39；对于一个高效的程序员来说，优秀的编译器错误和文档非常重要。</p><p> Although actually that&#39;s a lie. In writing this I encountered  way morecompiler errors than I show. In particular, in the later chapters I won&#39;t beshowing a lot of the random &#34;I typed (copy-pasted) bad&#34; errors that youexpect to encounter in every language. This is a  guided tour of having thecompiler scream at us.</p><p>尽管事实上&#39；这是谎言。在写这篇文章时，我遇到了比我所展示的更多的编译器错误。尤其是在后面的章节中，我赢得了&#39；展示了很多随机的#34；我打字（复印粘贴）不好&#34；你可能会在每种语言中遇到的错误。这是一个有导游带领的旅行，让公司向我们尖叫。</p><p> We&#39;re going to be going pretty slow, and I&#39;m honestly not going to be veryserious pretty much the entire time. I think programming should be fun, dang it!If you&#39;re the type of person who wants maximally information-dense, serious, andformal content, this book is not for you. Nothing I will ever make is for you.You are wrong.</p><p>我们&#39；我们会走得很慢，而我&#39；老实说，我不会一直非常认真。我觉得编程应该很有趣，该死！如果你&#39；你是那种想要信息密度最大化、内容严肃正式的人，这本书不适合你。我不会为你做任何事。你错了。</p><p>  Just so we&#39;re totally 100% clear: I hate linked lists. Witha passion. Linked lists are terrible data structures. Now of course there&#39;sseveral great use cases for a linked list:</p><p>就这样我们&#39；你完全清楚：我讨厌链表。带着激情。链表是糟糕的数据结构。现在当然有了&#39；S链接列表的几个重要用例：</p><p> You want to do  a lot of splitting or merging of big lists.  A lot.</p><p>你需要对大列表进行大量拆分或合并。很多</p><p>   You&#39;re using a pure functional language and the limited semantics and absenceof mutation makes linked lists easier to work with.</p><p>你&#39；重新使用纯函数式语言，以及有限的语义和不存在变异，使得链表更容易使用。</p><p> But all of these cases are  super rare for anyone writing a Rust program. 99%of the time you should just use a Vec (array stack), and 99% of the other 1%of the time you should be using a VecDeque (array deque). These are blatantlysuperior data structures for most workloads due to less frequent allocation,lower memory overhead, true random access, and cache locality.</p><p>但所有这些情况对于编写Rust程序的人来说都是极为罕见的。99%的时间你应该只使用Vec（数组堆栈），99%的时间你应该使用VecDeque（数组堆栈）。由于分配频率较低、内存开销较低、真正的随机访问和缓存局部性，这些数据结构对于大多数工作负载来说都是明显的优越数据结构。</p><p> Linked lists are as  niche and  vague of a data structure as a trie. Few wouldbalk at me claiming a trie is a niche structure that your average programmercould happily never learn in an entire productive career -- and yet linked listshave some bizarre celebrity status. We teach every undergrad how to write alinked list. It&#39;s the only niche collection I couldn&#39;t kill from std::collections. It&#39;s  the list in C++!</p><p>链表和trie一样，在数据结构中是小众和模糊的。几乎没有人会因为我声称trie是一个小众结构而感到不安，你的普通程序在整个富有成效的职业生涯中都不会愉快地学习到这一点——但链接列表却有一些奇怪的名人身份。我们教每一个本科生如何写一份清单。它&#39；这是我唯一看不到的利基系列&#39；从std:：collections中杀人。它&#39；是C++中的列表！</p><p> We should all as a community say  no to linked lists as a &#34;standard&#34; datastructure. It&#39;s a fine data structure with several great use cases, but thoseuse cases are  exceptional, not common.</p><p>作为一个社区，我们所有人都应该拒绝链表作为&#34；标准&#34；数据结构。它&#39；这是一个很好的数据结构，有几个很好的用例，但这些用例都是例外，并不常见。</p><p> Several people apparently read the first paragraph of this PSA and then stopreading. Like, literally they&#39;ll try to rebut my argument by listing one of thethings in my list of  great use cases. The thing right after the firstparagraph!</p><p>有几个人显然读了这篇PSA的第一段，然后停止了阅读。就像，字面上他们&#39；I’我试着通过列出我的优秀用例列表中的一个内容来反驳我的论点。就在第一段之后！</p><p> Just so I can link directly to a detailed argument, here are several attemptsat counter-arguments I have seen, and my response to them. Feel free to skipto  the first chapter if you just want to learn some Rust!</p><p>为了让我能直接链接到一个详细的论点，这里有几个我见过的反论点，以及我对它们的回应。如果你只是想学习一些知识，请随意跳过第一章！</p><p>  Yes! Maybe your application is I/O-bound or the code in question is in somecold case that just doesn&#39;t matter. But this isn&#39;t even an argument for usinga linked list. This is an argument for using  whatever at all. Why settle fora linked list? Use a linked hash map!</p><p>对也许您的应用程序是I/O绑定的，或者所讨论的代码是在某种冷情况下不&#39；没关系。但这不是&#39；甚至连使用链表的理由都没有。这是一个使用任何东西的论点。为什么要建立一个链表？使用链接的哈希映射！</p><p> If performance doesn&#39;t matter, then it&#39;s  surely fine to apply the naturaldefault of an array.</p><p>如果表现不佳&#39；没关系，那么它&#39；应用数组的自然错误当然没问题。</p><p>  Yep! Although as  Bjarne Stroustrup notes  this doesn&#39;t actuallymatter if the time it takes to get that pointer completely dwarfs thetime it would take to just copy over all the elements in an array (which isreally quite fast).</p><p>是的！尽管正如比亚恩·斯特劳斯鲁普所指出的那样，这并不意味着&#39；实际上，如果获取指针所需的时间完全超过了在数组中复制所有元素所需的时间（这真的很快），那么我就不在乎了。</p><p> Unless you have a workload that is heavily dominated by splitting and mergingcosts, the penalty  every other operation takes due to caching effects and codecomplexity will eliminate any theoretical gains.</p><p>除非您的工作负载主要由拆分和合并成本控制，否则由于缓存效果和编解码器复杂性，每一个其他操作都会受到惩罚，这将消除任何理论收益。</p><p> But yes, if you&#39;re profiling your application to spend a lot of time insplitting and merging, you may have gains in a linked list.</p><p>但是是的，如果你&#39；重新分析应用程序以花费大量时间进行拆分和合并，在链表中可能会有所收获。</p><p>  You&#39;ve already entered a pretty niche space -- most can afford amortization.Still, arrays are amortized  in the worst case. Just because you&#39;re using anarray, doesn&#39;t mean you have amortized costs. If you can predict how manyelements you&#39;re going to store (or even have an upper-bound), you canpre-reserve all the space you need. In my experience it&#39;s  very common to beable to predict how many elements you&#39;ll need. In Rust in particular, alliterators provide a  size_hint for exactly this case.</p><p>你&#39；我已经进入了一个相当小的领域——大多数人都负担得起摊销。不过，阵列在最坏的情况下也会摊销。就因为你&#39；重复使用anarray，不&#39；这并不意味着你已经摊销了成本。如果你能预测你有多少人&#39；如果你要储存（甚至有一个上限），你可以预先预订所有你需要的空间。以我的经验来看&#39；这是很常见的能够预测多少元素你&#39；我需要。尤其是铁锈，头韵为这种情况提供了一个大小提示。</p><p> Then  push and  pop will be truly O(1) operations. And they&#39;re going to be considerably faster than  push and  pop on linked list. You do a pointeroffset, write the bytes, and increment an integer. No need to go to any kind ofallocator.</p><p>然后推送和弹出将是真正的O（1）操作。他们&#39；我们将比链表上的推送和弹出要快得多。执行pointeroffset，写入字节，然后递增一个整数。不需要去找任何分配者。</p><p>  But yes, if you can&#39;t predict your load, there are worst-caselatency savings to be had!</p><p>但是是的，如果你能&#39；Don’不要预测你的工作量，最糟糕的情况是节省时间！</p><p>  Well, this is complicated. A &#34;standard&#34; array resizing strategy is to growor shrink so that at most half the array is empty. This is indeed a lot ofwasted space. Especially in Rust, we don&#39;t automatically shrink collections(it&#39;s a waste if you&#39;re just going to fill it back up again), so the wastagecan approach infinity!</p><p>这很复杂。A&#34；标准&#34；调整数组大小的策略是增大或缩小数组，使其最多有一半为空。这确实是浪费了很多空间。尤其是在生锈的时候，我们不&#39；t自动缩小收藏（如果你再把它填满，那就是浪费），所以wastagecan接近无穷大！</p><p> But this is a worst-case scenario. In the best-case, an array stack only hasthree pointers of overhead for the entire array. Basically no overhead.</p><p>但这是最坏的情况。在最好的情况下，一个数组堆栈对于整个数组只有三个开销指针。基本上没有开销。</p><p> Linked lists on the other hand unconditionally waste space per element.A singly-linked lists wastes one pointer while a doubly-linked list wastestwo. Unlike an array, the relative wasteage is proportional to the size ofthe element. If you have  huge elements this approaches 0 waste. If you havetiny elements (say, bytes), then this can be as much as 16x memory overhead(8x on 32-bit)!</p><p>另一方面，链表无条件地浪费每个元素的空间。单链表浪费一个指针，而双链表浪费两个指针。与阵列不同，相对损耗与元素的大小成正比。如果你有巨大的元素，这接近零浪费。如果你有很小的元素（比如字节），那么这可能是16倍的内存开销（32位上是8倍）！</p><p> Actually, it&#39;s more like 23x (11x on 32-bit) because padding will be addedto the byte to align the whole node&#39;s size to a pointer.</p><p>实际上是&#39；s更像23x（32位上的11x），因为填充将被添加到字节以对齐整个节点&#39；它的大小是指针的大小。</p><p> This is also assuming the best-case for your allocator: that allocating anddeallocating nodes is being done densely and you&#39;re not losing memory tofragmentation.</p><p>这也是为您的分配器假设的最佳情况：分配和释放节点是密集进行的，而您&#39；我们不会因为破碎而失去记忆。</p><p> But yes, if you have huge elements, can&#39;t predict your load, and have adecent allocator, there are memory savings to be had!</p><p>但是是的，如果你有巨大的元素，可以&#39；不要预测你的负载，并有一个合适的分配器，有节省内存！</p><p>  Great! Linked lists are super elegant to use in functional languagesbecause you can manipulate them without any mutation, can describe themrecursively, and also work with infinite lists due to the magic of laziness.</p><p>太棒了链表在函数式语言中使用起来非常优雅，因为你可以在不进行任何变异的情况下对它们进行操作，可以递归地描述它们，而且由于懒惰的魔力，它还可以处理无限多的列表。</p><p> Specifically, linked lists are nice because they represent an iteration withoutthe need for any mutable state. The next step is just visiting the next sublist.</p><p>具体来说，链表很好，因为它们代表了一个迭代，不需要任何可变状态。下一步就是访问下一个子列表。</p><p> Rust most does this kind of thing with  iterators. They can be infinite and you can map, filter, reverse, and concatenate them just like a functional list,and it will all be done just as lazily!</p><p>Rust大多数都使用迭代器来完成这类工作。它们可以是无限的，你可以像一个函数列表一样映射、过滤、反转和连接它们，而这一切都将同样缓慢地完成！</p><p> Rust also lets you easily talk about sub-arrays with   slices. Your usualhead/tail split in a functional language is  just  slice.split_at_mut(1).For a long time, Rust had an experimental system for pattern matching onslices which was super cool, but the feature was simplified when it wasstabilized. Still,  basic slice patterns are neat! And of course,slices can be turned into iterators!</p><p>Rust还可以让您轻松谈论带有切片的子阵列。在函数式语言中，通常的头/尾分割只是切片。在_mut（1）处拆分。很长一段时间以来，Rust有一个在芯片上进行模式匹配的实验系统，这个系统非常酷，但是当它稳定下来后，这个特性就被简化了。不过，基本的切片图案还是很整洁的！当然，切片可以变成迭代器！</p><p>  Note that I&#39;m not saying that functional programming is necessarily weak orbad. However it  is fundamentally semantically limited: you&#39;re largely onlyallowed to talk about how things  are, and not how they should be  done. Thisis actually a  feature, because it enables the compiler to do tons of  exotictransformations and potentially figure out the  best way to do thingswithout you having to worry about it. However this comes at the cost of being able to worry about it. There are usually escape hatches, but at some limityou&#39;re just writing procedural code again.</p><p>注意我&#39；我并不是说函数式编程一定很弱。然而，它在语义上是有限的：you&#39；我们基本上只被允许谈论事情是怎样的，而不是应该怎样做。这实际上是一个特性，因为它使编译器能够进行大量的Exotic转换，并可能找出最好的方法来完成这些工作，而无需担心。然而，这是以能够担心它为代价的。通常会有逃生舱口，但在一定程度上你&#39；我们又在写程序代码了。</p><p> Even in functional languages, you should endeavour to use the appropriate datastructure for the job when you actually need a data structure. Yes,singly-linked lists are your primary tool for control flow, but they&#39;re areally poor way to actually store a bunch of data and query it.</p><p>即使在函数式语言中，当您实际需要数据结构时，也应该努力为工作使用适当的数据结构。是的，单链表是控制流程的主要工具，但它们&#39；实际上，存储和查询大量数据的方法非常糟糕。</p><p>  Yes! Although writing a concurrent data structure is really a whole differentbeast, and isn&#39;t something that should be taken lightly. Certainly not somethingmany people will even  consider doing. Once one&#39;s been written, you&#39;re also notreally choosing to use a linked list. You&#39;re choosing to use an MPSC queue orwhatever. The implementation strategy is pretty far removed in this case!</p><p>对尽管编写并发数据结构实际上是一个完全不同的东西，而且不是&#39；这不是一件应该掉以轻心的事情。当然也不是很多人会考虑做的事情。一次&#39；已经写好了，你&#39；我们也不是真的选择使用链表。你&#39；重新选择使用MPSC队列或其他什么。在这种情况下，实施策略相去甚远！</p><p>   It&#39;s niche. You&#39;re talking about a situation where you&#39;re not even usingyour language&#39;s  runtime. Is that not a red flag that you&#39;re doing somethingstrange?</p><p>它&#39；这是一个利基市场。你&#39；你说的是一种你&#39；你甚至不用你的语言&#39；它的运行时间。这不是你&#39；你在做什么奇怪的事？</p><p>    That&#39;s a delicate dance you&#39;re playing. Especially if you don&#39;t havea garbage collector. I might argue that your control flow and ownershippatterns are probably a bit too tangled, depending on the details.</p><p>那&#39；这是一支精致的舞蹈，你&#39；我们在玩。尤其是如果你没有&#39；我没有垃圾收集器。我可能会说，根据细节，您的控制流和所有者模式可能有点太复杂了。</p><p>   Well, yeah. You&#39;re reading a book dedicated to that premise.Well, singly-linked lists are pretty simple. Doubly-linked listscan get kinda gnarly, as we&#39;ll see.</p><p>嗯，是的。你&#39；重新阅读一本关于这个前提的书。单链表非常简单。双链接列表会变得有点粗糙，就像我们&#39；我看看。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1072687.html"><img src="http://img2.diglog.com/img/2022/1/thumb_fce16028afb0f29cca60b950bde96b7c.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072687.html">不相信平均值：如何评估和加强业务的健康</a></div><span class="my_story_list_date">2022-1-11 7:11</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072666.html"><img src="http://img2.diglog.com/img/2022/1/thumb_85b9057458b3e0928e2830e0081133ad.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072666.html">看看联邦调查局越来越多的面部承认使用，包括来自FBI和冰等机构的最近合同，ClearView AI，信任邮票和其他人</a></div><span class="my_story_list_date">2022-1-11 3:39</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072564.html"><img src="http://img2.diglog.com/img/2022/1/thumb_6003c74de391823d5141a450b25fecf9.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072564.html">史前雨林的化石在澳大利亚生锈的岩石里藏起来</a></div><span class="my_story_list_date">2022-1-10 5:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072557.html"><img src="http://img2.diglog.com/img/2022/1/thumb_d33f0fc4936d2e42636ddd12ed07947d.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072557.html">印度的反托拉斯看门狗在新闻出版商投诉后订购了谷歌的调查，该公司正在滥用其新闻汇总统治</a></div><span class="my_story_list_date">2022-1-10 4:40</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>