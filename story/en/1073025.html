<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>2022年的异步生锈Async Rust in 2022</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Async Rust in 2022<br/>2022年的异步生锈</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-14 11:29:06</div><div class="page_narrow text-break page_content"><p>Almost a year ago, the Async Working Group  1  embarked on a collaborative effort to write a  shared async vision document. As we enter 2022, we wanted to give an update on the results from that process along with the progress we are making towards realizing that vision.</p><p>大约一年前，Async Working Group 1开始合作编写一份共享的Async vision文档。在我们进入2022年之际，我们希望提供这一过程的最新结果，以及我们在实现这一愿景方面取得的进展。</p><p>  To set the scene, imagine it&#39;s Rust 2024, and you&#39;ve decided to build your first project in Rust. You&#39;re working on a project that uses GitHub and you&#39;d like a tool that will walk over all the issues on your repository and do some automatic triage. You decide to use async Rust for this. You pull out the Rust book and thumb over to the Async I/O section. In there, it shows you the basic structure of an async Rust application. Like any Rust program, it begins with  main, but this time with an  async fn...</p><p>要设置场景，请想象一下&#39；s Rust 2024，而你&#39；我决定在Rust建造你的第一个项目。你&#39；我们正在做一个使用GitHub的项目，而你&#39；I’我想要一个工具，它可以遍历存储库中的所有问题，并进行一些自动分类。您决定为此使用async Rust。你拿出锈迹斑斑的书，用拇指指向异步I/O部分。在这里，它向您展示了异步应用程序的基本结构。和任何Rust程序一样，它从main开始，但这次是异步fn。。。</p><p>  Thumbing over to crates.io, you search for &#34;github&#34; and find that there is a nifty crate  crabbycat for navigating github issues. You import it and sit down to work. The first thing you need to do is to to iterate over all the issues:</p><p>翻到板条箱上。io，你搜索&#34；github和#34；并发现有一个漂亮的板条箱螃蟹猫导航github的问题。你导入它，然后坐下来工作。您需要做的第一件事是反复讨论所有问题：</p><p> async fn main() { for await? issue in crabbycat::issues(&#34;https://github.com/rust-lang/rust&#34;) { if meets_criteria(&amp;issue) { println!(&#34;{issue:?}&#34;); } }}</p><p>async fn main（）{用于crabbycat:：issues（&#34；https://github.com/rust-lang/rust&#34;) {如果符合(发布){println！（&#34；{发布：？}&#34;); } }}</p><p> Your crate seems to be working well and you happily tweet about it. Soon enough you find yourself with some users and one of them opens a PR to extend it to to support GitLab. To do this, they introduce a trait that allows you to write code that is generic over the issue provider. This trait has one method,  issues which returns an iterator (in this case, an async iterator):</p><p>你的板条箱似乎工作得很好，你很高兴地发推特。很快，你发现自己和一些用户在一起，其中一个用户打开了一个PR，将其扩展到支持GitLab。为了做到这一点，它们引入了一种特性，允许您编写针对问题提供程序的通用代码。这个特性有一个方法，它返回一个迭代器（在本例中是一个异步迭代器）：</p><p> trait IssueProvider { async fn issues(&amp;mut self, url: &amp;str) -&gt; impl AsyncIterator&lt;Item = Result&lt;Issue, Err&gt;&gt;;}#[derive(Debug)]struct Issue { number: usize, header: String, assignee: String,}</p><p>trait IssueProvider{async fn issues（&amp；mut self，url:&amp；str）->impl asyncierator&lt；Item=Result&lt；Issue，Err&gt；}#[派生（调试）]结构问题{number:usize，header:String，assignment:String，}</p><p> Now they are able to refactor the main loop into a function that is generic over the  IssueProvider. They decide to use a  dyn trait to avoid monomorphizing many times.</p><p>现在，他们能够将主循环重构为一个在IssueProvider上通用的函数。他们决定使用dyn性状来避免多次单形性。</p><p> fn process_issues(provider: &amp;mut dyn IssueProvider) { for await? issue in provider.issues(&#34;https://github.com/rust-lang/rust&#34;) { if meets_criteria(&amp;issue) { println!(&#34;{issue:?}&#34;); } }}</p><p>fn流程问题（提供者：&amp；mut-dyn IssueProvider）{for await？提供者中的问题。问题（&34；https://github.com/rust-lang/rust&#34;) {如果符合(发布){println！（&#34；{发布：？}&#34;); } }}</p><p> You happily hit merge on the PR and everything works great. Later on, somebody wants to port your system to run on the Chartreuse operating system. Chartreuse is based on an actor model and uses its own custom async runtime -- but luckily for you, you don&#39;t care. All your code is seamlessly able to switch the underlying runtime implementation over to the Chartreuse async runtime.</p><p>你在公关上很开心地点击了merge，一切都很好。后来，有人想把你的系统移植到Chartreuse操作系统上运行。Chartreuse基于一个actor模型，并使用自己的自定义异步运行时——但幸运的是，您没有&#39；我不在乎。所有代码都能够无缝地将底层运行时实现切换到Chartreuse异步运行时。</p><p>  Of course, the year is still 2022, and the vision we just painted is not reality -- at least not yet. There is a lot of work to do yet in terms of RFCing and implementing the features that will let us write the code we talked about:</p><p>当然，这一年仍然是2022年，我们刚刚描绘的愿景不是现实——至少现在还不是。在RFCing和实现特性方面，还有很多工作要做，这些特性将让我们编写我们所讨论的代码：</p><p> Taking an  &amp;mut dyn IssueProvider argument requires supporting dynamic dispatch in traits that have async functions</p><p>采取一个&amp；mut dyn IssueProvider参数要求在具有异步函数的traits中支持动态调度</p><p> The code used a  for await? loop, which permitted easy iteration over iterators in async code.</p><p>用于等待的代码？循环，允许在异步代码中通过迭代器轻松迭代。</p><p> The trait for async iteration in the standard library ( Stream) has a different name and is not stabilized; its definition is likely to change, too, once we have strong support for async fns in traits.</p><p>标准库（流）中异步迭代的特征具有不同的名称，并且不稳定；一旦我们在traits中强烈支持异步fns，它的定义也可能会改变。</p><p> As this work proceeds we can expect plenty of changes in the details along the way, and we might decide some pieces aren&#39;t worth it; if nothing else, the syntax for generators is a hotly contested topic.  What won&#39;t change is the the overall vision: that writing async Rust code should be as easy as writing sync code, apart from the occasional  async and  await keyword.</p><p>随着这项工作的进行，我们可以预期在过程中的细节会有很多变化，我们可能会决定一些细节不是&#39；不值得；如果没有其他问题的话，生成器的语法是一个备受争议的话题。什么赢了&#39；t change是总体愿景：除了偶尔使用async和await关键字之外，编写异步代码应该和编写同步代码一样简单。</p><p>  We&#39;ve organized the Async working group into a number of distinct initiatives, each of which is pursuing one part of the vision. What follows is a list of the currently active groups and some of the things they&#39;ve done over the last few months since they got up and running.</p><p>我们&#39；我们将异步工作组组织成了许多不同的计划，每个计划都在追求愿景的一部分。以下是当前活跃群体的列表，以及他们&#39；自从他们开始运营以来，我已经在过去的几个月里做了很多。</p><p>   We have also landed the  static async fn in traits RFC and  drafted an RFC for return position impl trait (which still needs a few tweaks before it&#39;s ready to land).</p><p>我们还在traits RFC中实现了静态异步fn，并为return position impl trait起草了一份RFC（在准备好着陆之前，它还需要一些调整）。</p><p> We&#39;ve been working on a design for dynamic dispatch, the most recent iteration of which is described in  this blog post.</p><p>我们&#39；我一直在为动态调度设计，最近的一次迭代在这篇博客文章中进行了描述。</p><p> We&#39;ve also been spinning off efforts, such as the proposal for  context and capabilities that tmandry blogged about.</p><p>我们&#39；我也一直在努力，比如tmandry在博客上提到的关于上下文和功能的建议。</p><p>   Estebank has  prototyped a procedural macro for generators and put out a call for discussion about the syntax and other details.</p><p>Estebank为生成器制作了一个程序宏原型，并呼吁大家讨论语法和其他细节。</p><p>  Led by  nrc, exploring what it takes to make code easily portable across runtimes, beginning with standardized traits for things like  AsyncRead and  AsyncWrite.</p><p>由nrc领导，探索如何使代码易于跨运行时移植，从AsyncRead和AsyncWrite之类的标准化特性开始。</p><p>   Led by  eholk, focused on improving the existing capabilities via smaller changes that collectively make a big difference.</p><p>由eholk领导，专注于通过较小的变化来改善现有能力，这些变化共同带来了巨大的变化。</p><p> We&#39;ve got a  pending PR that will improve the generator&#39;s capture analysis when variables are moved before a yield point, as well as  another PR that tightens temporary scopes to further avoid unnecessary generator captures.</p><p>我们&#39；我们有一个待定的PR，它将改进生成器#39；当变量移动到屈服点之前时，进行捕获分析，以及另一个PR，它收紧了临时范围，以进一步避免不必要的生成器捕获。</p><p> Gus Wynn made significant progress towards a   must_not_suspend lint that catches cases where values are live across an await point that should not be.</p><p>古斯·韦恩（Gus Wynn）在“必须”而不是“暂停”皮棉（suspend lint）方面取得了重大进展，这种皮棉可以捕捉到值在不应该存在的等待点上存在的情况。</p><p> We are starting to look at ways to make  async stack traces more readable and helpful.</p><p>我们开始研究如何使异步堆栈跟踪更具可读性和帮助性。</p><p>  Led by  pnkfelix, working to support folks in the async ecosystem who are building interesting tooling to support async Rust others.</p><p>由pnkfelix领导，致力于支持异步生态系统中的人员，他们正在构建有趣的工具来支持异步生态系统。</p><p> Michael Woerister is exploring  async crashdump recovery, offering a mechanism to recover and inspect the state of an async Rust program based on a crashdump.</p><p>Michael Woerister正在探索异步崩溃转储恢复，提供了一种机制来恢复和检查基于崩溃转储的异步生锈程序的状态。</p><p> Eliza Weisman and  many others recently  announced their 0.1 release of  tokio console. Tokio Console is a diagnostics and debugging tool for asynchronous Rust programs. It gives you a live view onto the state of the async runtime, and can also signal warnings when it detects suspicious behavior that might indicate a bug or performance problem.</p><p>伊丽莎·魏斯曼和其他许多人最近宣布了他们0.1版的东京控制台。Tokio Console是一种用于异步程序的诊断和调试工具。它可以让您实时查看异步运行时的状态，还可以在检测到可能表明存在错误或性能问题的可疑行为时发出警告。</p><p> You can find the complete set of work that we have planned on our  roadmap page, which also links to various deliverables we&#39;re working toward.</p><p>你可以在我们的路线图页面上找到我们计划的整套工作，该页面还链接到我们&#39；我们正在努力。</p><p>  If you&#39;re interested in helping out, a good place to start is the  How to help section of the polish initiative page. There is also a weekly  polish triage meeting which you may want to attend.</p><p>如果你&#39；如果你对帮助感兴趣，一个好的开始是波兰倡议页面的“如何帮助”部分。还有一个每周波兰分诊会议，你可能想参加。</p><p> We used to be called the Async Foundations Working Group, or wg-async-foundations. wg-async is much easier to type. The  focus of the working group being on the &#34;foundations&#34; of async, namely the language and standard library, hasn&#39;t changed.  ↩</p><p>我们过去被称为异步基金会工作组，或wg Async Foundation。wg async更容易输入。工作组的重点是&#34；基金会和#34；异步的，即语言和标准库，没有&#39；没有改变。↩</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/生锈/">#生锈</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/async/">#async</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1072687.html"><img src="http://img2.diglog.com/img/2022/1/thumb_fce16028afb0f29cca60b950bde96b7c.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072687.html">不相信平均值：如何评估和加强业务的健康</a></div><span class="my_story_list_date">2022-1-11 7:11</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072666.html"><img src="http://img2.diglog.com/img/2022/1/thumb_85b9057458b3e0928e2830e0081133ad.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072666.html">看看联邦调查局越来越多的面部承认使用，包括来自FBI和冰等机构的最近合同，ClearView AI，信任邮票和其他人</a></div><span class="my_story_list_date">2022-1-11 3:39</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072564.html"><img src="http://img2.diglog.com/img/2022/1/thumb_6003c74de391823d5141a450b25fecf9.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072564.html">史前雨林的化石在澳大利亚生锈的岩石里藏起来</a></div><span class="my_story_list_date">2022-1-10 5:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072557.html"><img src="http://img2.diglog.com/img/2022/1/thumb_d33f0fc4936d2e42636ddd12ed07947d.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072557.html">印度的反托拉斯看门狗在新闻出版商投诉后订购了谷歌的调查，该公司正在滥用其新闻汇总统治</a></div><span class="my_story_list_date">2022-1-10 4:40</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>