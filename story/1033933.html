<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ZIG 0.7.0发布</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">ZIG 0.7.0发布</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-09 05:17:46</div><div class="page_narrow text-break page_content"><p>没有隐藏的控制流，没有隐藏的内存分配，没有预处理器，也没有宏。如果Zig代码看起来不像是跳过去调用函数，那么它就不是。这意味着您可以确保下面的代码只调用foo()，然后调用bar()，这是可以保证的，而不需要知道任何东西的类型：</p><p>D有@Property函数，这些方法看起来像是通过字段访问来调用的，所以在上面的例子中，C.D可能会调用一个函数。</p><p>C++、D和Rust具有运算符重载，因此+运算符可以调用函数。</p><p>C++、D和Go都有抛出/捕捉异常，因此foo()可能会抛出异常，并阻止调用bar()。</p><p>Zig通过使用语言关键字和函数调用来独占地管理所有控制流，从而提高了代码的可维护性和可读性。</p><p>Zig有四种构建模式，它们都可以混合和匹配，一直到作用域的粒度。</p><p>下面是Integer溢出在编译时的样子，与构建模式无关：</p><p>编译时测试&#34；整数溢出&#34；{const x：u8=255；const y=x+1；}</p><p>$zig test test.zig./docgen_tmp/test.zig：3：17：错误：操作导致溢出const y=x+1；^。</p><p>$zig test test.zig1/1test&#34；运行时整数溢出&#34；...测试&#34；整数溢出/home/andy/dev/www.ziglang.org/docgen_tmp/test.zig:3:7：0x204e00；运行时整数溢出&#34；(测试)x+=1；std.Special.main(测试)}ELSE TEST_fn.func()；^/home/andy/Downloads/zig/lib/std/special/test_runner.zig:48:28：0x2308d5；Std.start.posxCallMainAndExit(测试)中的^/home/andy/Downloads/zig/lib/std/start.zig:252:37：0x205c4d Const Result=root.main()Catch|err|{^/home/andy/Downloads/zig/lib/std/start.zig:123:5：0x20598f in std.star._start(TEST)@Call(.{.Modify=.Never_Inline}，PoxCallMainAndExit，.{})；^测试失败。使用以下命令重现failure:/home/andy/dev/www.ziglang.org/docgen_tmp/test。</p><p>使用Zig，人们可以依赖于启用安全的构建模式，并有选择地在性能瓶颈处禁用安全性。例如，可以这样修改前面的示例：</p><p>测试&#34；实际未定义的行为&#34；{@setRune meSafety(False)；var x：u8=255；x+=1；//XXX未定义的行为！}。</p><p>Zig使用未定义的行为作为一种锋利的工具，既可以预防漏洞，又可以提高性能。</p><p>对于本机目标，由于交叉编译是一流的用例，因此启用了高级CPU特性(-march=ative)。</p><p>精心挑选的未定义行为。例如，在Zig中，有符号整数和无符号整数在溢出时都有未定义的行为，而在C中只有有符号整数。这有助于优化C语言中没有的优化。</p><p>ZIG直接公开了SIMD向量类型，使得编写可移植的向量化代码变得容易。</p><p>请注意，Zig不是一种完全安全的语言。对于那些对关注Zig的安全故事感兴趣的人，请订阅以下几期：</p><p>Zig标准库与libc集成，但不依赖于libc。以下是《Hello World》：</p><p>当使用--Release-Small、调试符号剥离、单线程模式进行编译时，这将为x86_64-Linux目标生成9.8 KiB的静态可执行文件：</p><p>$zig build-exe hello.zig--发布-小--条带--单线程$wc-c hello9944 hello$ldd Hello不是动态可执行文件。</p><p>$zig build-exe hello.zig--版本-小--条带--单线程目标x86_64-windows$wc-c hello.exe4096 hello.exe$file hello.exehello.exe：PE32+可执行文件(控制台)x86-64，适用于MS Windows。</p><p>顶级声明(如全局变量)是独立于顺序的，并且分析迟缓。全局变量的初始化值在编译时计算。</p><p>Var y：i32=add(10，x)；const x：i32=add(12，34)；test&#34；全局变量&#34；{assert(x==46)；assert(y==56)；}fn add(a：i32，b：i32)I32{return a+b；}const std=@import(&#34；std&#34；)；const assert=std.debug.assert；</p><p>在其他编程语言中，空引用是许多运行时异常的根源，甚至被指责为计算机科学中最严重的错误。</p><p>$zig test test.zig./docgen_tmp/test.zig：2：17：错误：指针类型&#39；*I32&#39；不允许地址为零常量PTR=@intToPtr(*I32，0x0)；^。</p><p>但是，任何类型都可以作为可选类型，只需在其前面加上？：</p><p>Const std=@import(&#34；std&#34；)；const assert=std.debug.assert；test&#34；null@intToPtr&#34；{const ptr=@intToPtr(？*I32，0x0)；assert(ptr==NULL)；}。</p><p>//包含的用于参考外部FN Malloc的Malloc原型(大小：Size_t)？*U8；FN doATing()？*foo{const PTR=Malloc(1234)orelse return NULL；//...}。</p><p>Fn doATing(OPTIONAL_FOO：？*FOO)void{//如果(OPTIONAL_FOO)|foo|{doSomethingWithFoo(Foo)；}//做一些事情}。</p><p>Const std=@import(&#34；std&#34；)；pub fn main()void{const msg=&#34；hello this is dog&#34；；var it=std.mem.tokenize(msg；&#34；&#34；)；While(it.next())|Items|{std.debug.print(&#34；{}\n&#34；，.{Item})；}}。</p><p>为了实现这一点，Zig程序员必须管理他们自己的内存，并且必须处理内存分配失败。</p><p>Zig标准库也是如此。任何需要分配内存的函数都接受一个分配器参数。因此，Zig标准库甚至可以用于独立的目标。</p><p>除了全新的错误处理方式外，Zig还提供了延迟和错误延迟功能，使所有资源管理(不仅仅是内存)变得简单且易于验证。</p><p>有关延迟的示例，请参见在没有FFI/绑定的情况下与C库集成。以下是使用errdefer的示例：</p><p>Const device=struct{name：[]u8，fn create(allocator：*allocator，id：u32)！device{const device=try allocator.create(Device)；errdeer allocator.destect(Device)；device.name=try std.fmt.allocPrint(allocator，&#34；device(id={})&#34；，id)；errer allocator.free(device.name)；if(id==。</p><p>Const std=@import(&#34；std&#34；)；pub fn main()void{const file=std.fs.cwd().openFile(&#34；do_not_exist/foo.txt&#34；，.{})Catch|err|Label：{std.debug.print(&#34；Unable to open file：{}\n&#34；，.{err})；const stderr=std.ior。File.WriteAll(&#34；您的所有代码库都属于我们\n&34；)Catch Return；}。</p><p>$zig build-exe catch.zig$./catch无法打开文件：error.FileNotFound您的所有代码库都属于我们。</p><p>Const std=@import(&#34；std&34；)；pub fn main()！Void{const file=try std.fs.cwd().openFile(&#34；do_not_exist/foo.txt&#34；，.{})；推迟file.lose()；try file.WriteAll(&#34；您所有的代码库都属于我们\n&#34；)；}。</p><p>$zig build-exe try.zig$./try Error：std.os.openatZ(Try)中的FileNotFound/home/andy/Downloads/zig/lib/std/os.zig:1167:23：0x22a73b，enOENT=&gt；返回错误。FileNotFound，std.fs.Dir.openFileZ(Try)中的^/home/andy/Downloads/zig/lib/std/fs.zig:711:13：0x20c93a尝试os.openatZ(self.fd，Sub_Path，os_FLAGS，0)；Std.fs.Dir.openFile(Try)中的^/home/andy/Downloads/zig/lib/std/fs.zig:651:9：0x20a93f返回self.openFileZ(&amp；路径_c，标志)；主(Try)常量文件中的^/home/andy/dev/www.ziglang.org/docgen_tmp/try.zig:4:18：0x22f4b8=Try std.fs.cwd().openFile(&#34；does_not_exist/foo.txt&#34；，。{})；^。</p><p>请注意，这是错误返回跟踪，而不是堆栈跟踪。该代码没有付出展开堆栈的代价来得出该跟踪。</p><p>Const std=@import(&#34；std&#34；)；test&#34；Switch on Error&#34；{const Result=parseInt(&#34；hi&#34；，10)Catch|err|Switch(Err){}；}fn parseInt(buf：[]const U8，基：U8)！U64{var x：u64=0；for(Buf)|c|{const digit=try charToDigit(C)；if(digit&gt；=基){return error.DigitExceedsRadix；}x=try std.math.mul(U64，x，基)；x=try std.math.add(U64，x，digit)；}return x；}fn charToDigit(c：u8)！U8{Const Value=Switch(C){&#39；0&#39；...&#39；9&#39；=&gt；c-#39；0&#39；...&#39；Z&#39；=&gt；c-#39；A&#39；+10，&#39；a&#39；...&#39；z&#39；=&gt；c-&#39；A&#39；+10，否则=&gt；返回错误。InvalidCharacter，}；返回值；}。</p><p>$zig test test.zig./docgen_tmp/test.zig：4：51：Error：error.Overflow Not Handling in Switch Const Result=parseInt(&#34；hi&#34；，10)Catch|err|Switch(Err){}；^./docgen_tmp/test.zig：3：24：注意：引用的heretest&#34；打开错误&#34；{^./docgen_tmp/test.zig：嗨&#34；，10)Catch|err|Switch(Err){}；^./docgen_tmp/test.zig：4：51：错误：error.InvalidCharacter未在Switch Const Result=parseInt(&#34；hi&#34；，10)Catch|err|Switch(Err){}；^中处理。</p><p>Const std=@import(&#34；std&#34；)；pub fn main()void{const file=std.fs.cwd().openFile(&#34；do_not_exist/foo.txt&#34；，.{})Catch Unreacable；file.WriteAll(&#34；您的所有代码库都属于我们\n&#34；)Catch Unreacable；}。</p><p>$zig build-exe unachable.zig$./unachable尝试解包错误：std.os.openatZ(不可访问)中的FileNotFound/home/andy/Downloads/zig/lib/std/os.zig:1167:23：0x22a56b(不可访问)ENOENT=&gt；返回错误。FileNotFound，std.fs.Dir.openFileZ(不可访问)中的^/home/andy/Downloads/zig/lib/std/fs.zig:711:13：0x20c76a尝试os.openatZ(self.fd，SUB_PATH，os_。标准文件目录中的^/home/andy/Downloads/zig/lib/std/fs.zig:651:9：0x20a76f返回self.openFileZ(&amp；路径_c，标志)；^？：0x206b6c in？(？)/home/andy/dev/www.ziglang.org/docgen_tmp/unreachable.zig:4:71：0x22f325 in Main(Unreacable)const file=std.fs.cwd().openFile(&#34；Do_NOT_EXIST/foo.txt&#34；，.{})Catch Unreacable；^/home/andy/Downloads/zig/lib/std/start.zig:242:22：0x2049ef in std.start.posxCallMainAndExit(Unreacable)root.main()；^/home/andy/Downloads/zig/lib/std/start.zig:123:5：0x2047cf in std.star._start(Unreacable)@Call(.{.Modify=.Never_Inline}，position xCallMainAndExit，.{})；^(进程由信号终止。</p><p>这会在不安全的生成模式中调用未定义的行为，因此请确保只有在保证成功的情况下才使用它。</p><p>此页上显示的堆栈跟踪和错误返回跟踪适用于所有第1层支持和某些第2层支持目标。甚至是独立式的！</p><p>此外，标准库能够在任何时候捕获堆栈跟踪，然后将其转储为标准错误：</p><p>Const std=@import(&#34；std&#34；)；const Builtin=@import(&#34；Builtin&#34；)；var地址缓冲区：[8]usize=未定义；var trace1=builtin.StackTrace{.Instructions_Addresses=Address_Buffer[0.。4]，.index=0，}；var trace2=builtin.StackTrace{.Instruction_Addresses=Address_Buffer[4.]，.index=0，}；pub fn main()void{foo()；bar()；std.debug.print(&#34；第一个：\n&#34；，.{})；std.debug.umpStackTrace(Trace1)；std.debug.print(&#34；\n\n第二个Std.debug.ump pStackTrace(Trace2)；}fn foo()void{std.debug.captureStackTrace(NULL，&amp；trace1)；}fn bar()void{std.debug.captureStackTrace(NULL，&amp；trace2)；}</p><p>$zig build-exe STACK_Traces.zig$./STACK_TRACE第一个：/home/andy/Downloads/zig/lib/std/debug.zig:183:29：0x236d14 in std.debug.captureStackTrace(STACK_TRACE)add.*=it.next()orelse{^/home/andy/dev/www.ziglang.org/docgen_tmp/stack_traces.zig:27:32：0x23486c in foo(STACK_TRACE)std.debug.captureStackTrace(NULL，&amp；trace1)；主(STACK_TRACE)foo()中的^/home/andy/dev/www.ziglang.org/docgen_tmp/stack_traces.zig:17:8：0x22f278；std.start.posxCallMainAndExit(STACK_TRACE)root.main()中的^/home/andy/Downloads/zig/lib/std/start.zig:242:22：0x2049cf；^第二个：/home/andy/Downloads/zig/lib/std/debug.zig:183:29：0x236d14 in std.debug.captureStackTrace(Stack_Traces)add.*=it.next()orrelse{^/home/andy/dev/www.ziglang.org/docgen_tmp/stack_traces.zig:31:32：0x23488c in bar(STACK_TRACE)std.debug.captureStackTrace(NULL，&amp；trace2)；主(Stack_Traces)栏中的^/home/andy/dev/www.ziglang.org/docgen_tmp/stack_traces.zig:18:8：0x22f27d()；std.start.posxCallMainAndExit(Stack_Traces)根中的^/home/andy/Downloads/zig/lib/std/start.zig:242:22：0x2049cf()；^。</p><p>Const std=@import(&#34；std&#34；)；const assert=std.debug.assert；test&#34；类型为&#34；{const t1=u8；const t2=bool；assert(t1！=t2)；const x：t2=true；assert(X)；}。</p><p>Const std=@import(&#34；std&34；)；fn list(comptime T：type)type{return struct{Items：[]T，len：usize，}；}pub FN main()void{var Buffer：[10]I32=未定义；var List=List(I32){.Items=&amp；Buffer，.len=0，}；std.debug.print(&#34；{}\n&#34；，.{list。</p><p>Const std=@import(&#34；std&#34；)；const Header=struct{Magic：u32，name：[]const U8，}；pub FN main()void{printInfoAboutStruct(Header)；}fn printInfoAboutStruct(comptime T：type)void{const info=@typeInfo(T)；inline for(info.Struct.field)|field|{std.debug.。，.{@typeName(T)，field.name，@typeName(field.field_type)，}，)；}}。</p><p>$zig build-exe refection.zig$./refectionHeader有一个名为Magic的字段，类型为u32Header有一个名为Name的字段，类型为[]const U8。</p><p>Zig标准库使用这种技术来实现格式化打印。尽管Zig是一种小而简单的语言，但Zig的格式化打印完全是用Zig实现的。同时，在C中，printf的编译错误被硬编码到编译器中。类似地，在Rust中，格式化的打印宏被硬编码到编译器中。</p><p>Zig还可以在编译时评估函数和代码块。在某些上下文中(如全局变量初始化)，表达式在编译时隐式求值。否则，可以在编译时使用comptime关键字显式计算代码。当与断言结合使用时，这会特别强大：</p><p>Const std=@import(&#34；std&34；)；const assert=std.debug.assert；fn Fibonacci(x：u32)u32{if(x&lt；=1)return x；return Fibonacci(x-1)+Fibonacci(x-2)；}test&#34；编译时求值&#34；{var数组：[Fibonacci(6)]I32=未定义；comptime{assertime</p><p>$zig测试测试。zig/home/andy/Downloads/zig/lib/std/debug.zig:223:14：错误：如果(！OK)无法访问，则无法计算常量表达式；//断言失败^./docgen_tmp/test.zig：13：15：注意：从此处调用断言(array.len==12345)；^./docgen_tmp/test.zig：9：32：注意：从此处调用&#34；编译时评估&#34；{^./docgen_tmp/test.zig：13：15：注意：此处引用断言(array.len==12345)；^。</p><p>@cImport直接导入类型、变量、函数和简单宏，以便在Zig中使用。它甚至将内联函数从C转换为Zig。</p><p>Const c=@cImport(@cInclude(&#34；soundio/soundio.h&34；))；const std=@import(&#34；std&#34；)；fn sio_err(err：c_int)！Void{switch(@intToEnum(c.SoundIoError，Err)){.None=&gt；{}，.NoMem=&gt；return error.NoMem，.InitAudioBackend=&gt；return error.InitAudioBackend=&gt；return error.SystemResources，.OpeningDevice=&gt；return error.OpeningDevice，.NoSuchDevice。返回错误。流，.InpatibleDevice=&gt；返回错误。不兼容设备，.NoSuchClient=&gt；返回错误。NoSuchClient，.InpatibleBackend=&gt；返回错误。不兼容后端，.BackendDisConnected=&gt；返回错误。BackendDisConnected，.Interrupted=&gt；返回错误。中断，.Underflow=&gt；返回错误。Fn WRITE_CALLBACK(可能_outstream：？[*]c.SoundIoOutStream，Frame_count_min：c_int，Frame_count_max：c_int，)callconv(.c)void{const outstream=@ptrCast(*c.SoundIoOutStream，可能_outstream)；const Layout=&amp；outStre.layout；const Float_Sample_Rate=outStre.Sample_rate；const Second_per_Frame=1.0/@。而(FRAMES_LEFT&GT；0){var FRAME_COUNT=FRAMES_LEFT；var Area：[*]c.SoundIoChannelArea=未定义；SIO_ERR(c.soundio_outstream_egin_write(大概_outstream，@ptrCast([*]？[*]c.SoundIoChannelArea，&amp；Area)，&amp；Frame_count，))Catch|err|std.debug.Panic(&#34；IF(FRAME_COUNT==0)Break；Const Pitch=440.0；Const Radians_Per_Second=Pitch*2.0*std.math.pi；var Frame：C_int=0；While(Frame&lt；Frame_Count)：(Frame+=1){const Sample=std.math.sin((Second_Offset+@intToFloat(F32，Frame)*Second_Per_Frame)*RADIANS_Per_Second)*RADIANS_Per_Second)；{var Channel：usize=0。@intCast(usize，layout.Channel_count))：(Channel+=1){const CHANNEL_PTR=Areas[Channel].ptr；const Sample_PTR=&amp；Channel_ptr[@intCast(usize，Area[Channel].Step*Frame)]；@ptrCast(*F32，@alignCast(@alignOf(F32)，Sample_Ptr))。*=Sample；}Second_Offset+=(*F32，@alignCast(@alignOf(F32)，Sample_Ptr))。*=Sample；}Second_Offset+=。Sio_err(c.soundio_outstream_end_write(maybe_outstream))Catch|err|std.debug.Panic(&#34；结束写入失败：{}&#34；，@errorName(Err))；FRAMES_LEFT-=FRAME_COUNT；}}pub FN Main()！C.soundio_default_output_device_index(soundio)；{const soundio=c.soundio_create()；推迟c.soundio_DESTORE(Soundio)；尝试sio_err(c.soundio_connect(Soundio))；c.soundio_flush_events(Soundio)；const DEFAULT_OUTPUT_INDEX=c.soundio_default_output_device_index(soundio)；if(DEFAULT_OUTPUT_INDEX&lt；0)返回错误。NoOutputDeviceFound；const device=c.soundio_get_Output_device(soundio，默认。Defer c.soundio_device_unref(Device)；std.debug.print(&#34；输出设备：{s}\n&#34；，.{([*]const U8)(device.*.name)})；const outstream=c.soundio_outstream_create(Device)或返回错误.OutOfMemory；deferc.soundio_outstream_DESTORY(Outstream)；outstream.*.format=c.SoundIo.*.格式=c.SoundIo.。尝试sio_err(c.soundio_outstream_start(outstream))；While(True)c.Soundio_Wait_Events(Soundio)；}。</p><p>这个Zig代码比同等的C代码简单得多，并且有更多的安全保护，所有这些都是通过直接导入C头文件来实现的--没有API绑定。</p><p>$zig build-exe--c-source hello.c--库c--Verbose-cczig cc-MD-mv-mf zig-cache/tmp/42zL6fBH8fSO-hello.o.d-nostdinc-fno拼写检查-issystem/home/andy/dev/zig/build/lib/zig/Include-issystem/home/andy/dev/zig/build/lib/zig/libc/include/x86_64-linux-gnu-issystem/home/andy/dev/zig/build/lib/zig/libc/include/generic-glibc。-issystem/home/andy/dev/zig/build/lib/zig/libc/include/x86_64-linux-any-issystem/home/andy/dev/zig/build/lib/zig/libc/include/any-linux-any-march=Native-g-f栈保护器-STRONG--param ssp-Buffer-Size=4-fno-omit-Frame-POINTER-o zig-cache/tmp/42zL6fBH8fSo-hello.o-c hello.c-fPic。</p><p>请注意，如果我再次运行该命令，则没有输出，并且</p><p>Zig的主要用例之一是用C ABI导出库，供其他编程语言调用。函数、变量和类型前面的EXPORT关键字会使它们成为库API的一部分：</p><p></p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ziglang.org">https://ziglang.org</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/zig/">#zig</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/const/">#const</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033856.html"><img src="http://img2.diglog.com/img/2020/11/thumb_a91d0b07ecb5b7de6f8846453eab9f45.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033856.html">直播博客：苹果11月10日“再来一件事”发布会的所有新闻</a></div><span class="my_story_list_date">2020-11-8 23:12</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033572.html"><img src="http://img2.diglog.com/img/2020/11/thumb_db724ba69a6fae0b9b98a714984f62ec.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033572.html">谷歌悄悄地在Play Store发布了一款名为Device Lock Controller的应用程序，如果债权人没有付款，该应用程序可以让债权人远程锁定设备</a></div><span class="my_story_list_date">2020-11-7 7:3</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033546.html"><img src="http://img2.diglog.com/img/2020/11/thumb_6414234e500d3d5f0f477a4ab75f89b5.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033546.html">索尼确认PS5在发布时不支持SSD存储扩展</a></div><span class="my_story_list_date">2020-11-7 6:16</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033472.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c1acc44b2ae98fc9049497a4b03751c8.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033472.html">据称，A14X Bionic在Apple Silicon Mac发布会前几天进行了基准测试</a></div><span class="my_story_list_date">2020-11-6 8:3</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>