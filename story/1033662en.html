<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么输入Erlang很难：标准Erlang</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">为什么输入Erlang很难：标准Erlang</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-07 14:13:56</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/76fee038427af967d4a62ff40c6ab0a4.png"><img src="http://img2.diglog.com/img/2020/11/76fee038427af967d4a62ff40c6ab0a4.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I heard before that Erlang and the BEAM did not pack a static type systembecause their creators  “couldn’t build it”.</p><p>我之前听说过Erlang和BEAM没有打包静态类型系统，因为他们的创建者“无法构建它”。</p><p>  While building a sophisticated, reliable and scalable type checker isabsolutely not a walk in the park, building one that works is not that hard.</p><p>虽然构建一个复杂、可靠和可伸缩的类型检查器绝对不是在公园里散步，但构建一个工作正常的类型检查器并不难。</p><p> If it could have been done, it would’ve been done, and it would’ve beenhardened by the same process OTP was hardened and turned into what it is today:a reliability gold standard.</p><p>如果这是可以做到的，它就会被完成，而且它会通过与OTP强化相同的过程来强化，并变成今天的样子：可靠性黄金标准。</p><p> So I decided to write an Erlang type-checker to really understand what is hardabout typing Erlang. I know Dialyzer exists, and its great, I just wanted toget a good understanding from scratch.</p><p>因此，我决定编写一个Erlang类型检查器来真正理解输入Erlang的困难之处。我知道透析器的存在，这太棒了，我只是想从零开始对它有一个更好的理解。</p><p> It hit me that there is a split in here, that is sometimes hard to notice andit makes a world of a difference. There is  an Erlang language, calledStandard Erlang, and there is  an Erlang Runtime, the BEAM. Along the samelines as there is a Java language, and then there’s the JVM.</p><p>我突然意识到，这里有一个分裂，有时很难注意到，这让世界变得截然不同。有一种名为Standard Erlang的Erlang语言，还有一种Erlang运行时，即BEAM。沿着相同的路线，首先是Java语言，然后是JVM。</p><p> We tend to speak of these 2 things as if they were one, but if we isolate thelanguage from the runtime, we find that they exhibit very different behaviors.</p><p>我们倾向于把这两件事当作一件事来谈论，但是如果我们把语言从运行时中分离出来，我们会发现它们表现出非常不同的行为。</p><p> In particular the runtime brings to the table  distribution and  hot codereloading, which makes typing things a distributed-systems problem. Fun, yes,but very impractical.</p><p>特别是，运行库给表分配和热代码加载带来了麻烦，这使得输入内容成为分布式系统的问题。是的，很有趣，但非常不切实际。</p><p> On following essays I’ll do a more thorough and formal treatise of theoperational semantics of the language and how to go about implementing your owntype-checker for it, the distributed and dynamic nature of the runtime, and howthey interact with each other.</p><p>在接下来的文章中，我将对该语言的操作语义、如何实现您自己的类型检查器、运行库的分布式和动态特性以及它们如何相互交互做一个更全面、更正式的论述。</p><p> Here I’ll go over what I’ve learned takes to type the Standard Erlang in a moresuperficial way, and what are some thorny parts that we will encounter.</p><p>在这里，我将回顾一下我所学到的用更表面的方式输入Standard Erlang所需的知识，以及我们将会遇到的一些棘手的部分。</p><p>   Erlang is a dynamically, strongly typed language. It includes just a littleextra over your typical functional programming language. Overall, Erlang isn’t that big alanguage.</p><p>Erlang是一种动态的强类型语言。它只比典型的函数式编程语言多了一点内容。总体而言，Erlang不是那么大的语言。</p><p> My eye-ball estimation is that it is about a 3rd of the size of OCaml, andabout a 5th of the size of Java.</p><p>我的粗略估计是它大约是OCaml的三分之一大小，大约是Java的五分之一大小。</p><p>  % an erlang module-module(hello_world).-export([hi/1]). % &lt;-- this a compiler annotationhi(noone) -&gt; sad;hi(Name) -&gt; &lt;&lt;&#34;Hello, &#34;, (Name)/binary, &#34;!&#34;&gt;&gt;.</p><p>%an Erlang模块-模块(HELLO_WORLD).-EXPORT([hi/1])。%&lt；--这是一个编译器注释hi(Noone)-&gt；ad；hi(Name)-&gt；&lt；&#34；Hello，&#34；，(Name)/inary，&#34；！&#34；&gt；&gt；。</p><p> An Erlang program consists of a number of  modules, each module is just a filewith a bunch of  functions in it and a few  annotations used to tell thecompiler what’s exported, who the module author is, what a function type issupposed to be, etc.</p><p>一个Erlang程序由许多模块组成，每个模块只是一个文件，其中包含一系列函数和一些注释，这些注释用于告诉编译器导出了什么、模块作者是谁、函数类型应该是什么等等。</p><p> There’s quite a few things you can write in Erlang that are relatively common:</p><p>在Erlang中可以编写很多相对常见的内容：</p><p>  And then there’s a few things that aren’t common at all:</p><p>还有一些事情根本就不常见：</p><p>  But in general, the language expressivity comes from it being rather simple.Most problems are solved by making functions that call each other, mostfunctions pattern match on exactly the data they need, loops are achievedthrough recursion, and we’re done.</p><p>但总的来说，语言的表现力来自于它相当简单。大多数问题都是通过使函数相互调用来解决的，大多数函数模式与它们需要的数据完全匹配，循环是通过递归实现的，然后我们就完成了。</p><p> Exceptions are very common, since failing to pattern match will result in anexception. For this the language supports the  catch, and  try..catch..afterexpressions, but it is highly unidiomatic to use them.</p><p>异常非常常见，因为模式匹配失败将导致异常。为此，该语言支持CATCH和Try..Catch..After表达式，但是使用它们是非常简单的。</p><p> The superb uptime through supervision that Erlang is known for is actuallybaked into the runtime, not the language. The language itself has no notion ofprocesses, links, or sending messages. The only thing it does have is  receiveexpressions for  consuming messages.</p><p>Erlang以监控而闻名的卓越正常运行时间实际上包含在运行时中，而不是语言中。语言本身没有进程、链接或发送消息的概念。它唯一拥有的就是用于消费消息的ReceiveExpression。</p><p>   In writing the type-checker, I’ve found a few things that are worth bringing up:</p><p>在编写类型检查器的过程中，我发现了一些值得提出来的事情：</p><p>  There may be other language constructs that are not friendly to staticanalysis. I’ll try to write and cover more in the future.</p><p>可能还有其他语言结构对静态分析不友好。以后我会试着写更多的文章和报道更多的内容。</p><p>  An Erlang value can have a single type but we expect that type to be known onlyat runtime. This means that both the input and returning types of a functionare actually unknown  until we run the function.</p><p>一个Erlang值可以有一个类型，但我们希望该类型只在运行时才知道。这意味着在我们运行函数之前，函数的输入类型和返回类型实际上都是未知的。</p><p> So whenever you see a function like  hi/1 above, calling it could actuallyreturn a value of different types, depending on how the function was written.</p><p>因此，无论何时您看到类似于上述hi/1的函数，调用它实际上都可能返回不同类型的值，这取决于函数是如何编写的。</p><p> For example, calling  hi(noone) returns the atom  sad. Instead, calling hi(&lt;&lt;&#34;Joe&#34;&gt;&gt;) returns the string  &lt;&lt;&#34;Hello, Joe!&#34;&gt;&gt;. The atom  sad and thestring have different types. Calling  hi(0) will result in an exception.</p><p>例如，呼叫hi(Noone)将返回原子悲伤。相反，调用hi(&lt；&lt；&34；&gt；&gt；)会返回字符串&lt；&lt；&34；Hello，Joe！&gt；。原子Sad和弦有不同的类型。调用hi(0)将导致异常。</p><p> If we were to write down the type of this function we’d have to say somethinglike:</p><p>如果我们要写下这个函数的类型，我们必须这样写：</p><p>  This is present in every other dynamic language: Lisp, Lua, Javascript, Python,Ruby, Smalltalk, you name it.</p><p>这在所有其他动态语言中都存在：LISP、Lua、Javascript、Python、Ruby、Smalltalk，应有尽有。</p><p> Writing a type-checker that deals with this is certainly possible, as it hasbeen done before in tools like  Flow and  TypeScript,but it certainly isn’t obvious how to.</p><p>编写一个处理这个问题的类型检查器当然是可能的，就像以前在Flow和TypeScrip这样的工具中做过的那样，但是如何做当然不是很明显。</p><p> To better understand how this can be dealt with, we need to talk about  UnionTypes.</p><p>为了更好地理解如何处理这个问题，我们需要谈谈UnionTypes。</p><p> Union types allow us to express that a value may belong to one of manydifferent types at the same time. E.g,  1 is a  number, but it is also a (number | bool). In the same way,  true is a  bool, but it is also a (number | bool).</p><p>联合类型允许我们表示一个值可以同时属于多个不同类型中的一个。例如，1是一个数字，但它也是一个(数字|bool)。同样，True是bool，但它也是(number|bool)。</p><p>  The key here is that the value itself doesn’t have explicit information aboutwhich type from the union it actually belongs to, and we’re bound to find thisout through  refinements.</p><p>这里的关键是，值本身并没有关于它实际属于联合的类型的显式信息，我们一定会通过改进来发现这一点。</p><p> We can do these refinements in 2 ways through the use of guards and patternmatching.</p><p>通过使用守卫和模式匹配，我们可以通过两种方式进行这些细化。</p><p>  Through the use of guards we can refine the actual type of a value into asingle type. For example:</p><p>通过使用保护，我们可以将值的实际类型细化为单一类型。例如：</p><p> % the infamous left_pad functionleft_pad(A, B) when is_binary(A) -&gt; &lt;&lt;(A)/binary, (B)/binary&gt;&gt;;left_pad(A, B) when is_number(A) -&gt; left_pad(binary:copy(&lt;&lt;&#34; &#34;&gt;&gt;, A), B).</p><p>%the臭名昭著的Left_Pad函数Left_Pad(A，B)When is_Binary(A)-&gt；&lt；(A)/Binary，(B)/Binary&gt；&gt；；Left_Pad(A，B)When is_Number(A)-&gt；Left_Pad(Binary：Copy(&lt；&lt；&#34；&#34；&&gt;；&&gt;；A)，B)。</p><p>   But it is thanks to the guards  is_binary/1 and  is_number/1 that we  refinethe type of the inputs to be just  string or just  number.</p><p>但多亏了IS_BINARY/1和IS_NUMBER/1保护，我们才能将输入类型细化为字符串或数字。</p><p> This makes it possible to say that  binary:copy(&lt;&lt;&#34; &#34;&gt;&gt;, A) is safe, becauseat that point we know that  is_number(A) was true, and so  A’s type has beenrefined from  string | number to just  number. Otherwise the guard would havebeen false.</p><p>这使得可以说BINARY：COPY(&lt；&lt；&#34；&gt；&gt；，A)是安全的，因为在这一点上我们知道is_number(A)是真的，因此A的类型已经从字符串|Number改进为只有Number。否则守卫就会是假的。</p><p> However, we can’t use any function as a guard. We must use only built-infunctions that already come with the Erlang runtime.</p><p>然而，我们不能使用任何功能作为警卫。我们只能使用Erlang运行时附带的内置函数。</p><p>   Through pattern matching we can do something very similar, and establishour expectations of the values. For example:</p><p>通过模式匹配，我们可以做一些非常相似的事情，并建立我们对价值观的期望。例如：</p><p> % a good old list length countercount(A=[_|_]) -&gt; count(A, 0).count([], C) -&gt; C;count([_|T], C) -&gt; count(T, C+1).</p><p>%a旧的列表长度计数(A=[_|_])-&gt；count(A，0).count([]，C)-&gt；C；count([_|T]，C)-&gt；count(T，C+1)。</p><p> In this case, we are guaranteed that if our function pattern matches, then  Awill be a list.</p><p>在这种情况下，我们可以保证，如果我们的函数模式匹配，那么它将是一个列表。</p><p> We don’t really know what the list elements are, but of course we can try andcontinue pattern matching and using guards until we refine it “enough”.</p><p>我们真的不知道List元素是什么，但我们当然可以尝试继续模式匹配和使用保护，直到我们对其进行“足够”的提炼。</p><p> These two approaches, while composable, have the unfortunate property that theydon’t generalize to all kinds of data. They should work well tho for: atoms,literals, and anything that there is a guard available for.</p><p>这两种方法虽然可以组合在一起，但它们有一个不幸的特性，它们不能推广到所有类型的数据。尽管如此，它们应该能够很好地工作：原子、文字，以及任何有警卫可用的东西。</p><p>  Maps, tuples, and records can work with this, but it doesn’t scale very well.You essentially have to add the new map/tuple/record name to the union everytime you want it supported. Even if you need a single field out of them.</p><p>地图、元组和记录可以使用它，但是它的伸缩性不是很好。实际上，每次需要支持新的地图/元组/记录名称时，都必须将其添加到联合中。即使你只需要他们中的一个领域。</p><p> In the next section we’ll see a different approach for dealing with this datathat scales much better.</p><p>在下一节中，我们将看到一种处理这些数据的不同方法，这种方法的可扩展性要好得多。</p><p>  When working with functions that take as inputs many values packed into one, beit with records, maps, or tuples, we’re faced with a different issue: we don’tcare what the input type is  as long as it has what we need in it.</p><p>在使用将多个值打包为一个值的函数(与记录、映射或元组绑定)作为输入时，我们面临着一个不同的问题：只要输入类型中包含我们需要的内容，我们就不关心输入类型是什么。</p><p> For example, if we have two possible maps that share some things, both of themcould be thought of as their own separate type, and these 2 types would havesomething in common.</p><p>例如，如果我们有两个共享某些东西的可能地图，它们都可以被认为是各自独立的类型，而这两种类型会有一些共同之处。</p><p> % this has type &#39;character&#39;Character = #{ name =&gt; &#34;Alexander Hamilton&#34;, play =&gt; &#34;Hamilton&#34; }.% this has type &#39;performer&#39;Performer = #{ name =&gt; &#34;Lin-Manuel Miranda&#34; }.</p><p>%This的类型为&#39；Character&#39；Character=#{Name=&&gt;；&34；Alexander Hamilton&#34；，Play=&&gt;34；Hamilton&#34；}。%This的类型为&#39；Performer&#39；Performer=#{Name=&&gt;；&#34；Lin-Manuel Miranda&#34；}。</p><p>       In fact, I’d say that it will work just fine for any map  as long as it has aname key that is a string.</p><p>事实上，我想说它对于任何映射都可以很好地工作，只要它有一个字符串的命名键。</p><p> So the type of our function isn’t quite  (character | performer). It actuallyis “Any map as long as it has a name key that is a string”. I’ll use thisnotation for that:  #{ name }</p><p>所以我们的函数类型不完全是(Character|Performer)。它实际上是“任何地图，只要它有一个名称键是一个字符串”。为此，我将使用此符号：#{name}。</p><p>  Some type-systems support this with Structural Subtyping, some others use RowPolymorphism. The main difference isn’t obvious in this getter function, butbecomes obvious in the next one, a setter:</p><p>一些类型系统通过结构子类型来支持这一点，而另一些类型系统则使用行多态性。主要区别在这个getter函数中并不明显，但在下一个函数setter中变得很明显：</p><p>  The structural subtyping approach would say that whatever you put in, it isnow known to only have a  name key. So all your other keys have disappeared(to the eyes of the type-system) and if you want to recover them you have to dosome sort of casting. This is due to a subtyping behavior called  subsumptionand its the way that TypeScript handles this.</p><p>结构子类型化方法会说，无论您放入什么，现在都知道它只有一个名称键。因此，您的所有其他键都消失了(在类型系统的眼中)，如果您想恢复它们，就必须进行某种强制转换。这要归因于一种称为包容的子类型行为，以及TypeScrip处理这一问题的方式。</p><p> The row polymorphic approach has no information loss, and instead carriesaround the rest of the fields that  M had. This is how OCaml and PureScripthandles this. In PureScript this works for record types and in OCaml this isimplemented for the object-oriented system.</p><p>行多态方法没有信息丢失，而是携带M拥有的其余字段。这就是OCaml和PureScripths.com如何处理这个问题。在PureScript中，这适用于记录类型，而在OCaml中，这适用于面向对象系统。</p><p> Either one of this approaches extends to the case where we use  all of thefields of the input tuple, record, or map.</p><p>这两种方法中的任何一种都适用于使用输入元组、记录或映射的所有字段的情况。</p><p>     This is an easier thing to deal with than #1, because now we have moreinformation to know what is the actual type of the value: the tag.</p><p>这比#1更容易处理，因为现在我们有了更多的信息来知道值的实际类型：标记。</p><p>    % the type of our work functionwork( atom(&#34;ok&#34;) | atom(&#34;not_ok&#34;) ) -&gt; { atom(&#34;ok&#34;), atom(&#34;success&#34;) } | { atom(&#34;error&#34;), string }</p><p>%我们工作函数的类型(ATOM(&#34；OK&#34；)|ATOM(&#34；NOT_OK&34；))-&gt；{ATOM(&#34；OK&#34；)，ATOM(&#34；成功&#34；)}|{ATOM(&#34；错误&#34；)，字符串}。</p><p> Which now has these constant values ( ok,  error) on the left side of thetuple, which we can use to further narrow down what the expected types shouldbe.</p><p>它现在在四元组的左侧有这些常量值(ok，error)，我们可以用它来进一步缩小预期类型的范围。</p><p> This is a well established pattern in the Erlang ecosystem, where mostfunctions that can fail return this result tuples with either an  ok or an error tag.</p><p>这是Erlang生态系统中的一种成熟模式，大多数可能失败的函数都会返回带有ok或error标签的结果元组。</p><p> To be fair, this still suffers from the problems of #1. We can make a functionthat returns an ok-tagged value that is an untagged union of types as well.</p><p>公平地说，这仍然存在#1的问题。我们可以创建一个函数，返回一个ok标记的值，该值也是类型的无标记联合。</p><p> % a more complex version of our work functionwork(ok) -&gt; {ok, go_on};work(done) -&gt; {ok, &lt;&lt;&#34;great job!&#34;&gt;&gt;};work(not_ok) -&gt; {error, &lt;&lt;&#34;something went wrong&#34;&gt;&gt;}.</p><p>%a我们工作功能的更复杂版本work(Ok)-&gt；{ok，go_on}；work(Done)-&gt；{ok，&lt；&gt；&#34；伟大的工作！&#34；&gt；&gt；}；work(Not_Ok)-&gt；{错误，&lt；&34；出现问题&#34；&gt；&gt；}。</p><p>  % we&#39;re omitting the In type because we&#39;re focusing on the output typeswork(In) -&gt; { atom(&#34;ok&#34;), atom(&#34;go_on&#34;) | string } | { atom(&#34;error&#34;), string }</p><p>%我们将忽略In类型，因为我们将重点放在输出类型(In)-&gt；{ATOM(&#34；OK&#34；)，ATOM(&#34；GO_ON&#34；)|STRING}|{ATOM(&#34；Error&#34；)，STRING}。</p><p> If you get an  {ok, Value}, typing  Value has the exact same issues wediscussed above.</p><p>如果您得到的是{ok，value}，则键入value的问题与我们上面讨论的完全相同。</p><p> However, this pattern helps us in typing things because we can always tag ourdata all the way down:</p><p>但是，此模式有助于我们输入内容，因为我们始终可以一直向下标记数据：</p><p> % same as last work function but with tags!work(ok) -&gt; {ok, go_on};work(done) -&gt; {ok, {message, &lt;&lt;&#34;great job!&#34;&gt;&gt;}};work(not_ok) -&gt; {error, &lt;&lt;&#34;something went wrong&#34;&gt;&gt;}.</p><p>%与上一个工作函数相同，但带有标签！Work(Ok)-&gt；{ok，go_on}；Work(Done)-&gt；{ok，{Message，&lt；&lt；&#34；Good Job！&#34；&gt；&&gt;；}；Work(Not_OK)-&gt；{错误，&lt；&lt；&#34；&&gt;出现问题。</p><p> Which is a little more verbose, but a lot more amenable to type-checking too,since the type-checker can associate a specific tag with a specific type.</p><p>这有点繁琐，但也更易于进行类型检查，因为类型检查器可以将特定的标记与特定的类型相关联。</p><p>  There is an asymmetry in the language: at the language level we can onlyreceive messages. There is no special constructs for sending messages. To senda message we just use the  erlang:send/2 function, or its operator version !.</p><p>语言中存在一种不对称性：在语言层面上，我们只能接收信息。没有用于发送消息的特殊构造。要发送消息，我们只需使用Erlang：Send/2函数或其操作员版本！</p><p> So in any function, when we encounter a  receive expression we are reallysaying 2 things:</p><p>因此，在任何函数中，当我们遇到接收表达式时，我们实际上是在说两件事：</p><p> Here be  side-inputs — this function will receive a value that isnot a direct argument, and it can use it as if it was one.</p><p>下面是辅助输入--这个函数将接收一个不是直接参数的值，它可以像使用一个参数一样使用它。</p><p> If there is a timeout (the  after part), then there is also a  deadline.Literally, since if this was a process, it’d be killed.</p><p>如果有超时(后面的部分)，那么也有一个截止日期。从字面上讲，因为如果这是一个进程，它就会被扼杀。</p><p> We won’t bother too much with the deadline right now, but we’ll look into theseside-inputs we receive as messages. Here’s an example of this expressions:</p><p>我们现在不会太在意截止日期，但我们会看看我们收到的这些信息。以下是此表达式的一个示例：</p><p>  We are very interested in the pattern matching that just happened up there,since that pattern matching essentially tells us what messages we can receive.</p><p>我们对刚刚发生的模式匹配非常感兴趣，因为模式匹配本质上告诉我们可以接收什么消息。</p><p> So much so, that we could think of this  receive expression as a functionbuilt into the language that we can call with a function of our own.</p><p>如此之多，以至于我们可以将这个RECEIVE表达式看作是内置于语言中的一个函数，我们可以用自己的函数来调用它。</p><p> % transforming a receive, into a function calladder() -&gt; receive {X, Y} -&gt; X + Y end .adder() -&gt; receive(fun ({X, Y}) -&gt; X + Y end).</p><p>%将RECEIVE转换为函数调用器()-&gt；Receive{X，Y}-&gt；X+Y End。Adder()-&gt；Receive(Fun({X，Y})-&gt；X+Y End)。</p><p> And now we can analyze this internal function in the same ways we analyzedpoints 1, 2, and 3 above.</p><p>现在我们可以用分析上面的点1、点2和点3的相同方式来分析这个内部函数。</p><p> This reframing of receive expressions was actually key for the type-checker I’mwriting to be able to understand what messages a process could receive, if weused the  adder/0 to start it.</p><p>如果我们使用加法器/0来启动进程，那么重新构造接收表达式实际上是让类型检查器能够理解进程可以接收到什么消息的关键。</p><p>   Another beast entirely is the dynamic parts of the language that allow us tomake decisions at runtime about what code to run, through special syntax.</p><p>另一个完全不同的地方是语言的动态部分，它允许我们在运行时通过特殊的语法来决定要运行什么代码。</p><p> Erlang supports specifying what module, and what function you want to call inthat module, completely dynamically.</p><p>Erlang支持完全动态地指定要在该模块中调用的模块和函数。</p><p> % M is our module nameM = hello.% F is our function nameF = world.M:F() =:= hello:world().</p><p>%M是我们的模块名称em=Hello。%F是我们的函数名称F=world。M：F()=：=Hello：world()。</p><p> But how can we tell what type will  M:F() have here if we don’t keep track of exactly what the value of  M and  F are?</p><p>但是，如果我们不准确跟踪M和F的值，我们怎么知道M：F()在这里会是什么类型呢？</p><p> We’d have to  evaluate  M to pick up the actual module name, and evaluate  Fto know what function to look up, and then look up the actual type of thefunction.</p><p>我们必须计算M以获取实际的模块名称，并计算FT值以了解要查找的函数，然后查找该函数的实际类型。</p><p> If  M is anything slightly more complex than just a variable binding like inthe example above, we may just not be able to know what it is. Imagine thefollowing scenario:</p><p>如果M比上例中的变量绑定稍微复杂一些，我们可能无法知道它是什么。想象一下下面的场景：</p><p> % We will receive the module name as a messageM = receive Name when is_atom(Name) -&gt; Name end.M:run().</p><p>%当IS_ATOM(名称)-&gt；名称结束时，我们将以MessageM=接收名称的形式接收模块名称。M：Run()。</p><p> We’d need to wait on  receiving a message to know what module to look up. Thisjust isn’t plausible because we can’t even tell who is sending the message, orwhether a message will be sent at all.</p><p>我们需要等待收到消息后才能知道要查找哪个模块。这是不可信的，因为我们甚至不知道是谁在发送信息，也不知道信息是否会被发送。</p><p> Of course Real World Erlang tends to rely on  behaviors to ensure that certaintypes are there, so perhaps annotating what the expected module behavior iswould help:</p><p>当然，现实世界中的Erlang倾向于依靠行为来确保某些类型存在，因此注释预期的模块行为可能会有所帮助：</p><p> % Same as above, but with a type-annotationM : runnable behavior = receive Name when is_atom(Name) -&gt; Name end.M:run().</p><p>%同上，但类型-注解M：Runnable Behavior=Receive Name When is_atom(Name)-&gt；name end.M：run()。</p><p> This way we’d be able to analyze this and know what type  run should have, orcomplain immediately that  run isn’t actually implemented in that behavior andthus can’t be guaranteed to exist.</p><p>这样，我们就能够分析这一点，并知道Run应该具有什么类型，或者立即抱怨Run实际上没有在该行为中实现，因此不能保证存在。</p><p>   I hope these few things I managed to cover today give you an idea of what arethe hard parts of typing the Erlang language. It is not impossible, in factsome parts are rather straightforward to type, but its definitely got somethorny bits that we should address with care.</p><p>我希望我今天讨论的这几件事能让您了解输入Erlang语言的困难之处。这并不是不可能的，事实上，有些部分的打字相当简单，但它肯定有一些棘手的部分，我们应该小心处理。</p><p> In the future I’ll write more about typing the language, in particular partslike binary string pattern matching, and the runtime and its properties, suchas hot-code reloading, figuring out process types, and how to check fortype-safe message passing.</p><p>在未来，我将写更多关于语言类型的内容，特别是像二进制字符串模式匹配这样的部分，以及运行库及其属性，例如热代码重载、确定进程类型以及如何检查类型安全的消息传递。</p><p>     Thanks to Pontus Nagy, Manuel Rubio,Malcolm Matalka,and  Calin Capitanufor taking the time to review earlier drafts of this essay.</p><p>感谢Pontus Nagy、Manuel Rubio、Malcolm Matalka和Calin Capitanu抽出时间审阅本文的早期草稿。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://abstractmachines.dev/posts/am012-why-typing-erlang-is-hard.html">https://abstractmachines.dev/posts/am012-why-typing-erlang-is-hard.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/erlang/">#erlang</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>