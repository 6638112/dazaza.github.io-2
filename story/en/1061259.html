<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>具有归纳逻辑编程的知识图表 Knowledge Graphs with Inductive Logic Programming</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Knowledge Graphs with Inductive Logic Programming<br/>具有归纳逻辑编程的知识图表 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-07 16:19:21</div><div class="page_narrow text-break page_content"><p>If it is the first time you read about the term Inductive Logic Programming (ILP), don’t be worried, you are in good company. I came across this paradigm recently when I started to investigate viable solutions to inject common-sense in eCommerce systems, and despite its potential, ILP is one the most under-appreciated branch of research in AI. I believe it is incredibly useful in many areas and I’m confident that you will recognize the advantages this paradigm will bring to your solutions.</p><p>如果是您第一次读取术语归纳逻辑编程（ILP），请不要担心，您就在良好的公司中。我最近遇到了这个范式，我开始调查电子商务系统中的可行解决方案，尽管有潜力，但ILP是AI中最不受欢迎的研究分支。我相信在许多领域是非常有用的，我有信心您将认识到这条范例将带来解决方案的优势。</p><p> I will talk about ILP in  “Just a bit of Logic: a Socratic way to Win Customer” in CML21 on Tue 11 May 15:15 (CET)</p><p> 我将在CML21上午15:15（CET）在CML21中讨论“只有一点逻辑：赢得客户的苏赢得赢得客户”的ILP</p><p> I will introduce the topic with an example. John is content editor of ACME GmbH and he got a brilliant idea that might boost the sales. He wants to adapt the eCommerce content to the consumer’s profile – the so-called personalization that you might have heard from us. John needs to insert the latest item bought by influencers living in the same consumer’s neighborhood, in the homepage. He wants to have this change now so he can show the results by the next sales meeting, at the end of the week. Moreover, John has little familiarity with the exhausting query grid in Backoffice, and he’s not very willing to engage with the data science team. Impatientness and laziness are not the most wanted styles of work, but a new tool has been just released.</p><p> 我将以一个例子介绍主题。约翰是Acme GmbH的内容编辑，他有一个辉煌的想法，可能会提高销售。他希望将电子商务内容调整到消费者的个人资料 - 所谓的个性化您可能已经从我们这里听到的。约翰需要在主页中插入生活在同一消费者社区中的影响者购买的最新物品。他现在想要实现这一变化，所以他可以在本周末显示下一个销售会议的结果。此外，约翰几乎没有熟悉后退的排气查询网格，他并不愿意与数据科学团队合作。不耐烦和懒惰不是最想要的工作风格，但新工具刚刚发布。</p><p> John knows what he means as “influencers” but is he able to explain that to the system? Well, apparently this is not necessary. With few clicks on the panel John has already instructed the system on what to do. John specifies a couple of samples and see the simulation in real-time. At the first toss the results look not so bad. He wipes out some unwanted results and add the other case he remembers from yesterday, a fancy customer in Munich. The tool creates on the fly the outcome John was looking for, enough accurate to be deployed immediately. John is happy, he did it online and without support.</p><p> 约翰知道他的意思是“影响者”，但他能够向系统解释吗？好吧，显然这不是必需的。只需点击几下面，教面板已经指示了系统要做的事情。 John指定了几个样本，并实时查看模拟。在第一次折腾，结果看起来不那么糟糕。他擦掉了一些不需要的结果，并在慕尼黑的一个花哨的客户中添加了他记得的其他案件。该工具在飞行中创建了结果John正在寻找，足够准确地立即部署。约翰很开心，他在线做了它，没有支持。</p><p> John was right. His idea significantly increased sales and that feature is going to be included among the supported ones and it will follow the company’s standards on development and maintenance. The lead developer inspects the generated program – code is human readable and understandable – and he edits it manually because there was some unharmful non-sense to drop away (the graphical no-code editor is on the way, promise!).</p><p> 约翰是对的。他的想法显着提高了销售额，该功能将包括在支持的那些中，它将遵循公司的开发和维护标准。铅开发人员检查生成的程序 - 代码是人类可读和可理解的 - 他手动编辑它，因为有一些不安的无意义删除（图形的没有代码编辑器正在路上，承诺！）。</p><p> This story brings some important advantages like small dataset, online fast training, and Explainability that can be brought by ILP. They are not all of course; I list them here:</p><p> 这个故事带来了小型数据集，在线快速训练和可解释性等一些重要的优势，可以通过ILP提出。他们不是当然都是如此;我在这里列出它们：</p><p> Explainability. Logic models are inspectable, editable, interpretable, justifiable. No need of interpreters like neural network (non-logic) models.</p><p> 解释性。逻辑模型是可防止的，可编辑，可解释的，合理的。不需要像神经网络（非逻辑）模型等口译员。 </p><p>     Training Data. Very few positive and negative samples. F1 score (precision/recall) wary based on quantity and quality of samples.</p><p>培训数据。非常少数正面和阴性样品。 F1评分（精密/召回）官力基于样品的数量和质量。</p><p> Roses come with thorns and ILP is not flawless. Since ILP is not based on statistical processes, it is not tolerant to noise or wrong data. For such a case, it will be interesting to merge the advantages of  neural networks with those reported above, from logic programming. I hope to keep you up to date on that soon, but this is just an introduction. let’s keep things simple, we see now what ILP is.</p><p> 玫瑰带有荆棘，ilp并非完美无瑕。由于ILP不是基于统计过程，因此它不容忍噪声或错误的数据。对于这种情况，将神经网络与上面报告的那些合并，从逻辑编程合并神经网络的优点。我希望很快能保持最新状态，但这只是一个介绍。让我们保持简单，我们现在看到了什么ILP是什么。</p><p> The part of the acronym with LP is  Logic Programming. It is a declarative language for defining composable rules and generate new desirable information out of a knowledge base. The first term of ILP is Inductive. Induction is the process of generating hypothesis from observable evidence. If we start from the specific case, induction is the way for generalizing the rules that can justify such case. ILP creates models that generalize the training samples. Yes, it is. It is exactly what you think, it is machine learning.</p><p> 与LP的缩写的部分是逻辑编程。它是一个用于定义可协商规则的声明性语言，并从知识库中生成新的可取信息。 ILP的第一项是归纳。归纳是从可观察证据产生假设的过程。如果我们从特定情况开始，归纳是概括可以证明这种情况的规则的方式。 ILP创建概括培训样本的模型。是的。正是你认为的，它是机器学习。</p><p> Unlike of what you might know of machine learning, here there is no statistics, no gradient descent, no error loss and indeed, no backpropagation. How can it work then? There are dozens of algorithms and their common denominator is combinatorial search on solutions. If you are worried of exponential complexity and combinatorial explosion, I ensure you this is not exactly the case. The algorithm I setup in my research is a guided search and it is particularly efficient. The system does not fetch the entire solution space but starts from the easiest solutions first from the provided samples. Have a look into  Answer Set Programming, it is essential for unfolding the capabilities of ILP. But let’s see a concrete example, this is the knowledge base:</p><p> 与您可能知道机器学习的内容不同，这里没有统计数据，没有梯度下降，没有错误丢失，实际上没有反向突破。它怎样才能工作？有几十个算法，它们的共同分母是解决方案的组合搜索。如果您担心指数复杂性和组合爆炸，我确保您不完全是这种情况。我在我的研究中设置的算法是指导搜索，它特别有效。系统不会提取整个解决方案空间，但首先从提供的样本开始从最简单的解决方案开始。调查答案集编程，展开ILP的功能至关重要。但是让我们看看一个具体的例子，这是知识库：</p><p>  And I want the system to create new relations:  grandfather and  grandmother. I provide what it is right as output, and what it is wrong:</p><p>  我希望该系统创造新的关系：祖父和祖母。我提供它正确的输出是正确的，什么是错误的：</p><p>    grandfather(X, Y) :- ( parent(X, Z),  parent(Z, Y), isA(X, male))grandmother(X, Y) :- ( parent(X, Z),  parent(Z, Y), isA(X, female))</p><p>    祖父（x，y）： - （父（x，z），父（z，y），isa（x，男性））祖母（x，y）： - （父（x，z），父（z，y），isa（x，女））</p><p> ILP is not just for querying or classifying data, it could be used to generate real programs that implement algorithms you normally create by coding. Consider generating a sorting algorithm. Suppose we have the `sort` relation where the unsorted input in the first argument and the expected sorted output in the second:</p><p> ILP不仅仅用于查询或分类数据，可用于生成通过编码来实现通常创建的算法的真实程序。考虑生成排序算法。假设我们有“排序”关系，其中第一个参数中的未反对输入和第二个参数中的预期排序输出： </p><p>  Let’s assume the system has already learned some basic predicates for list operations such as empty, head, tail, partition, append:</p><p>让我们假设系统已经学习了列表操作的一些基本谓词，例如空，头部，尾部，分区，附加：</p><p> empty( X)  // matches if X is an empty listhead([ 3, 4, 5],  X)  // head([3,4,5], 3)tail([ 3, 4, 5], X)  // tail([3,4,5], [4,5]) partition( 3, [ 5, 6, 7, 8],  X,  Y )  // partition(3, [5,6,7,8], [5,6], [7,8])append[ 1, 2, 3], [ 4, 5],  X)  // append([1,2,3], [4,5], [1,2,3,4,5])</p><p> 如果x是空列表，则为空（x）//匹配头部（[3,4,5]，x）//头（[3,4,5]，3）尾部（[3,4,5]，x）//尾部（[3,4,5]，[4,5]） 分区（3，[5,6,7,8]，X，Y）//分区（3，[5,6,7,8]，[5,6]，[7,8]）附录[1,2,3]，[4,5]，x）//附加（[1,2,3]，[4,5]，[1,2,3,4,5]）</p><p>   If this method is applied to  Knowledge Graph (KG) something very interesting might happen. I like the metaphor of the climber (ILP) that climbs the mountain by leveraging all the asperities (KG) for reaching the peek, the program. In a smooth wall the climber can’t go anywhere, therefore information is vital, but it is not enough for reaching the peek. At the time of writing this post, I see a lot of hype around KGs like the panacea for any kind of problem, but at the end, KGs are just databases of incomplete, sometimes wrong, and usually contradictory information that require proper methods for extracting sense out of them. One of those is ILP.  I will talk about it and how to make use of Knowledge Graphs for solving business cases in eCommerce with Logic Programming.</p><p>   如果此方法应用于知识图（kg）可能会发生非常有趣的东西。我喜欢登山者（ILP）的隐喻，通过利用所有粗糙（kg）来抵达偷看，该计划。在一个光滑的墙壁中，登山者不能去任何地方，因此信息是至关重要的，但它不足以到达偷看。在撰写本篇文章时，我看到很多炒作在KG上的炒作，就像有任何问题的Panacea，但最后，KGS只是不完整的数据库，有时错误，通常是需要正确提取方法的矛盾信息感觉出来。其中一个是ILP。我将讨论它以及如何利用知识图表来解决电子商务案例的逻辑编程。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blogs.sap.com/2021/05/06/knowledge-graphs-with-inductive-logic-programming-on-cml21/">https://blogs.sap.com/2021/05/06/knowledge-graphs-with-inductive-logic-programming-on-cml21/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/归纳/">#归纳</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/graphs/">#graphs</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ilp/">#ilp</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>