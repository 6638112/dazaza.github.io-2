<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>小林寺丸比较日期和时间The Kobayashi Maru of comparing dates with times</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Kobayashi Maru of comparing dates with times<br/>小林寺丸比较日期和时间</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 00:51:13</div><div class="page_narrow text-break page_content"><p>We just had a lengthy, one hour discussion with  @leoeuclids and  @uibreakfast in the  @userlist Slack about comparing dates with times… 🙈  Does anyone have opinions on this? 🤪  pic.twitter.com/G0muPbOhS9</p><p>我们刚刚在@userlist Slack中与@leoeuclids和@UIBreaken就比较日期和时间进行了一个长时间的一小时讨论…🙈  有人对此有意见吗？🤪  照片。啁啾com/G0muPbOhS9</p><p>— Benedikt Deicke (@benediktdeicke)  February 11, 2022</p><p>-Benedikt Deicke（@benediktdeicke）2022年2月11日</p><p>   At a minimum, one hundred replies in a Slack thread is the going rate for asking a question about an edge case about times and dates in programming. Just for future reference.</p><p>在一个松弛线程中，至少有100个回复是询问关于编程中时间和日期的边缘案例的现行速率。仅供将来参考。</p><p> Since Twitter embedding crops things a bit aggressively, here’s the image in the tweet directly:</p><p>由于Twitter的嵌入有点咄咄逼人，下面是推文中的图片：</p><p>  Immediately, the tweet replies were chaos. The answers included “Yes/Yes/No”, “No/No/No” (which was my initial response, but I’ve also chaotically changed my mind since then), “No/No/Yes”, “Dates are the worst”, and “Have you tried using 🍺? Maybe lots and lots of 🍻 and then maybe just like pretending this never happened?”</p><p>推特上的回复立刻变得混乱。答案包括“是/是/否”、“否/否”（这是我最初的回答，但从那时起我也混乱地改变了主意）、“否/否/是”、“日期最糟糕”和“你试过使用🍺? 也许很多很多🍻 然后就好像假装没发生过一样？"</p><p> As someone who wrote  entirely too much about dates and times and edge cases, I found this discussion to be an exciting, total waste of time, and I really couldn’t wait to dig into it some more.</p><p>作为一个写了太多关于日期、时间和边缘案例的人，我发现这次讨论令人兴奋，完全是浪费时间，我真的迫不及待地想再深入探讨一下。</p><p>  If you find yourself in this position, clearly something has gone wrong. And I say this without judgement, because unless you work in a clean room on a product that has no users and the code is no more than one hour old, you’re going to have issues with inconsistent data, and inconsistent storage of datestamps and timestamps is incredibly common. I ran into a similar problem this  just this week with a multitude of inconsistent datestamps and timestamps I had inherited.</p><p>如果你发现自己处于这种状态，很明显出了问题。我这样说是不加评判的，因为除非你在一个没有用户的洁净室里开发一个产品，而且代码的使用时间不超过一个小时，否则你会遇到数据不一致的问题，而且不一致的日期戳和时间戳存储是非常常见的。就在本周，我遇到了一个类似的问题，我继承了大量不一致的邮戳和时间戳。</p><p>   These are inputs from the user interface and data from a database. So it’s also very much about what (both technical and non-technical) people expect to happen.</p><p>这些是来自用户界面的输入和来自数据库的数据。因此，这也很大程度上取决于人们期望发生什么（技术和非技术）。</p><p>— Benedikt Deicke (@benediktdeicke)  February 12, 2022</p><p>-Benedikt Deicke（@benediktdeicke）2022年2月12日</p><p>   What’s more, there’s an additional issue in the original question that was left out, which astute readers of  UTC is Enough for Everyone, Right? might have picked up on already: there’s no timezone data! That’s fairly understandable for the date values, since timezones don’t tend to be needed (which, like most things in this realm, is not always true), but it would be needed for the time values to ensure a valid comparison (conceivably a comparison of  00:00:00 and  12:00:00 on the same “day” could be off by as much as a couple of actual days, depending on the timezone). And, of course, you’d need to store  more than just the offset if you properly wanted to account for historical daylight saving time.</p><p>更重要的是，原始问题中还有一个被遗漏的问题，UTC的哪些精明读者对每个人来说都足够了，对吗？可能已经注意到了：没有时区数据！对于日期值来说，这是可以理解的，因为时区通常是不需要的（这和这个领域的大多数事情一样，并不总是正确的），但是，需要时间值来确保有效的比较（可以想象，同一“天”的00:00:00和12:00:00的比较可能会中断几天，具体取决于时区）。当然，如果你想正确地计算历史夏令时，你需要存储的不仅仅是偏移量。</p><p>  So this is kind of a no-win solution. I can make a valid argument for pretty much every answer in the tweet replies (especially the one about beer). The reason why it’s particularly frustrating is because we make these snap decisions all the time in our day-to-day lives, and it’s pretty easy. When I tell you to meet me for lunch at noon today, there’s a highly likely possibility that we’re talking about being in the same place, the same timezone, and the same day as each other, so we don’t have to spend a lot of time thinking about this.</p><p>所以这是一个没有双赢的解决方案。我可以为推特回复中的几乎每一个答案（尤其是关于啤酒的答案）提供有效的论据。之所以特别令人沮丧，是因为我们在日常生活中总是做出这些仓促的决定，而且非常容易。当我告诉你们今天中午和我共进午餐时，很可能我们谈论的是彼此在同一个地方、同一时区、同一天，所以我们不必花太多时间思考这个问题。</p><p> The issue is that dates and times are kind of supersets of each other. Which is a bit of a paradox. But let’s look at it further:</p><p>问题是日期和时间是彼此的超集。这有点自相矛盾。但让我们进一步看一下：</p><p> A  Date can be thought of a superset of a  Time, because all hours and minutes and seconds naturally belong to a certain day.</p><p>一个日期可以被认为是一个时间的超集，因为所有的小时、分、秒自然都属于某一天。</p><p>  A  Time can be thought of a superset of a  Date, if you consider timespans to be an extention of a particular  Time. Noon to noon spans two separate days. Or, well, just one day, if it’s a 24 hour day instead of calendar day. Even my paradox explanations have paradoxes in them.</p><p>如果你认为时间是一个特定时间的扩展，那么时间可以被认为是一个日期的超集。从正午到正午跨越两个不同的日子。或者，只要一天，如果是24小时制而不是日历日。就连我对悖论的解释也有悖论。</p><p> Both of these are kind of wrong definitions, and also kind of right, which is why you can make these justifications for so many answers here. It really comes down to  what you value.</p><p>这两种定义都是错误的，也都是正确的，这就是为什么你可以在这里为这么多答案辩护。这实际上取决于你的价值。</p><p>  This is the crux of why I find this stuff so fucking fascinating. We programmers famously tend to view the world in a real binary sense: the code runs or it doesn’t. The tests pass or they don’t. The record is valid or it isn’t. It’s a very helpful way of looking at the world… until it isn’t. Usually it’s not baked directly into the system, though.</p><p>这就是为什么我觉得这些东西如此迷人的关键。众所周知，我们程序员倾向于以真正的二元意义来看待世界：代码运行或不运行。测试通过或不通过。记录有效或无效。这是一种非常有用的看待世界的方式……直到它不存在。不过，通常它不会直接烘焙到系统中。</p><p> There are certain examples where inherently correct answers don’t exist. My favorite example of this — and yes, I have favorite examples of time issues — is recurring events over a location-dependent daylight saving boundary.</p><p>有些例子根本不存在正确的答案。我最喜欢的例子——是的，我也最喜欢时间问题的例子——是在依赖于位置的夏令时边界上重复发生的事件。</p><p> Say you have a weekly 10am Pacific Time recurring calendar event with the rest of your dev team. Like a proper remote-first company, you’re  broadly distributed instead of just having a main team in one city and one rando working “remote”. That’s great, but it also increases the odds of having one city or region or country having different daylight saving policies than the others (if they even have one at all).</p><p>假设您与开发团队的其他成员每周在太平洋时间上午10点举行一次定期日历活动。就像一家真正的远程第一公司一样，你的公司分布广泛，而不仅仅是一个主要团队在一个城市，一个兰多在“远程”工作。这很好，但它也增加了一个城市、地区或国家与其他城市、地区或国家（如果它们甚至有一个夏令时政策的话）有不同夏令时政策的可能性。</p><p> You keep having your 10am call for a few months, and then Virginia, who lives in West Virginia, starts her daylight saving time in March. So now the 10am Pacific meeting time, which was 1pm her time, would still be 1pm for her since Pacific time always follows DST, too (except for Yukon, in Canada, which decided in 2020 to stop following DST, of course). But your teammate Brooklyn, who lives in Phoenix, doesn’t have daylight saving time because she lives in Arizona, which doesn’t follow daylight saving time (but don’t forget that the Navajo Nation in the northern part of Arizona  does follow DST, so be sure to keep that in mind, too).</p><p>几个月来，你一直在打上午10点的电话，然后住在西弗吉尼亚州的维吉尼亚在3月份开始夏令时。所以现在上午10点的太平洋会议时间，也就是她下午1点的时间，对她来说仍然是下午1点，因为太平洋时间也总是遵循DST（加拿大育空地区除外，该地区在2020年决定停止遵循DST）。但你的队友布鲁克林住在凤凰城，她没有夏令时，因为她住在亚利桑那州，那里不遵循夏令时（但别忘了，亚利桑那州北部的纳瓦霍民族也遵循DST，所以一定要记住这一点）。</p><p> So: does Brooklyn keep at her normal 11am meeting time, or does she move forward with Brooklyn and have to start meeting at noon? Nothing in her life changed. It’s weird for a meeting to suddenly span her lunch break when it didn’t before.</p><p>那么：布鲁克林是否保持正常的上午11点会议时间，或者她是否继续与布鲁克林会面，必须在中午开始开会？她的生活没有任何改变。一次会议突然在她的午餐休息时间结束，而之前没有，这是很奇怪的。</p><p> The answer is: there is no answer. We’re just making it up. And  that’s the answer. Google has a writeup on their  developer API docs for Calendar broadly talking about how recurring events interact with invited attendees. One aspect:</p><p>答案是：没有答案。我们只是在弥补。这就是答案。谷歌在其开发者API文档中有一个关于日历的书面文件，广泛讨论了重复事件如何与受邀参与者互动。一个方面：</p><p>  This is really the only reasonable approach that can be taken here. They decided that the creator of the original event wins out, and the effects of that permeate out to attendees as well.</p><p>这是唯一合理的方法。他们认为，最初活动的创造者获胜，其影响也渗透到与会者身上。</p><p>  * The “DTSTART” and the “TZOFFSETFROM” properties MUST be used when generating the onset DATE-TIME values (instances) from the “RRULE”.</p><p>*从“RRULE”生成起始日期时间值（实例）时，必须使用“DTSTART”和“TZOFFSETFROM”属性。</p><p> (RFC 5545 is a great, titillating read, too. Thought I was reading a Harlequin romance novel with how vividly they describe all the  RRULE specifications and permutations.)</p><p>（RFC 5545也是一本很棒的、令人兴奋的书。我还以为我在读一本小丑的爱情小说，书中生动地描述了所有的规则和排列。）</p><p>  So: bringing it back to the original topic at hand… I think this is a case where we get to just make the arbitrary decision. There’s no “right” or “wrong” answer.</p><p>所以：回到手头的原始话题……我认为这是一个我们可以随意做出决定的案例。没有“对”或“错”的答案。</p><p> I was curious how others broadly thought about the question, so I looked into it some more.</p><p>我很好奇其他人是如何广泛地思考这个问题的，所以我进一步研究了一下。</p><p> Ruby has a  lovely treatise about Shakespeare while they discuss using  Time versus  DateTime which touch on some of these issues- it’s worth reading the whole section, but this part is most relevant here:</p><p>Ruby有一篇关于莎士比亚的可爱论文，他们讨论了使用时间与日期时间的关系，这涉及到了其中一些问题——值得阅读整个章节，但这一部分在这里最相关：</p><p> So when should you use  DateTime in Ruby and when should you use  Time? Almost certainly you’ll want to use  Time since your app is probably dealing with current dates and times. However, if you need to deal with dates and times in a historical context you’ll want to use DateTime to avoid making the same mistakes as UNESCO. If you also have to deal with timezones then best of luck - just bear in mind that you’ll probably be dealing with local solar times, since it wasn’t until the 19th century that the introduction of the railways necessitated the need for Standard Time and eventually timezones.</p><p>那么什么时候应该在Ruby中使用DateTime，什么时候应该使用Time呢？几乎可以肯定的是，你会想使用时间，因为你的应用程序可能正在处理当前的日期和时间。然而，如果你需要在历史背景下处理日期和时间，你会希望使用DateTime来避免犯与UNESCO相同的错误。如果你还需要处理时区问题，那么祝你好运——请记住，你可能会处理当地的太阳时，因为直到19世纪，铁路的引入才需要标准时间，最终需要时区。</p><p> .NET also kind of goes with a  “oh god just try to avoid any of this type of thing” philosophy:</p><p>NET也有一种“哦，上帝，尽量避免任何这类事情”的理念：</p><p> To determine the relationship of  t1 to  t2, the Compare method compares the Ticks property of  t1 and  t2 but ignores their  Kind property. [Ed. note:  Kind here is effectively timezone-related data.] Before comparing  DateTime objects, ensure that the objects represent times in the same time zone.</p><p>为了确定t1和t2之间的关系，比较方法会比较t1和t2的滴答声特性，但会忽略它们的种类特性。[Ed.注：这里的Kind实际上是与时区相关的数据。]在比较DateTime对象之前，请确保这些对象代表同一时区中的时间。</p><p>  The method still works if the date/times are more than 14 hours apart, but if they are less than 14 hours apart, the result is deemed to be indeterminate.</p><p>如果日期/时间间隔超过14小时，该方法仍然有效，但如果间隔小于14小时，则结果被视为不确定。</p><p>  As the second parameter determines the precision, and not just a single value to check, using day will check for year, month and day. [Ed. note: this basically means you have to choose which precision to decide- in the case of the original tweet, you’d pick either days or seconds.]</p><p>由于第二个参数决定精度，而不仅仅是要检查的单个值，因此使用day将检查年、月和日。[Ed.注：这基本上意味着你必须选择要决定的精度——对于原始推文，你可以选择几天或几秒钟。]</p><p>    If the two moments have different timezones, the timezone of the first moment will be used for the comparison.</p><p>如果两个时刻的时区不同，则将使用第一个时刻的时区进行比较。</p><p>  This whole post is basically a long-winded way of reiterating that humans create some very weird scenarios when it comes to dates and times. Raphael Schaad, founder of the fantastic  Cron calendar, has a  long-running thread on broken assumptions of calendaring that, frankly, don’t always have logical solutions. It’s all a bunch of trade-offs.</p><p>这篇文章基本上是一种冗长的方式，重申人类在日期和时间上创造了一些非常奇怪的场景。Raphael Schaad是神奇的Cron日历的创始人，他有一个长期运行的思路，关于日历的错误假设，坦率地说，并不总是有合乎逻辑的解决方案。这都是一系列的权衡。</p><p> And that’s why I found the original tweet so interesting. We’ve all had situations where the data wasn’t consistent, or a third party munged data incorrectly for us, or where we’ve inherited data that was saved under incorrect assumptions (correct as they might have been at the time). The thought process can lead to a hundred-reply Slack thread. Or an entirely too-long and too-detailed Saturday morning post about dates and times.</p><p>这就是为什么我发现原来的推特如此有趣。我们都遇到过数据不一致的情况，或者第三方为我们错误地屏蔽了数据，或者我们继承了在错误假设下保存的数据（尽管当时可能是正确的）。思考的过程可能会导致100条线索。或者一篇关于日期和时间的太长太详细的周六早报。</p><p>  Just kidding. I know some of you are on to Sunday already. And some of you will — gasp — read it years from now! Pretty sure no one read this a week ago, though. If you did, please remind me a few days ago that I will need to write this a few hours ago from now.</p><p>开玩笑。我知道你们有些人已经到星期天了。你们中的一些人几年后会读到它！不过，我敢肯定一周前没人读过这篇文章。如果你写了，请几天前提醒我，从现在起，我需要在几个小时前写这篇文章。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/小林/">#小林</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/maru/">#maru</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/时间/">#时间</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>