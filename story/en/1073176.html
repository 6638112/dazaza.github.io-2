<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>你好，瓦拉的GTK世界Hello, World in GTK with Vala</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Hello, World in GTK with Vala<br/>你好，瓦拉的GTK世界</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-14 23:06:18</div><div class="page_narrow text-break page_content"><p>We&#39;ll continue our journey with writing the hello, world program in Vala but this time with GTK(4) library.</p><p>我们&#39；我将继续我们的旅程，在瓦拉编写hello，world程序，但这次是GTK（4）库。</p><p>      Let&#39;s create two new files with name  Hello.vala and  main.vala. Yes, the plan is to continue from where we end in the  previous article and then slowly build the working version of hello, world using GTK.</p><p>让&#39；让我们创建两个名为Hello的新文件。瓦拉和梅因。瓦拉。是的，我们的计划是从上一篇文章的结尾继续，然后使用GTK慢慢构建hello，world的工作版本。</p><p>    Open this newly created  main.vala and  copy write the same code we wrote previously in  hello/main.vala file. In other words,  main() method.</p><p>打开这个新创建的main。vala和copy编写的代码与我们之前在hello/main中编写的代码相同。瓦拉档案。换句话说，main（）方法。</p><p>  int main(string[] args) { string name = &#39;world&#39;; var hello = new Hello(name); hello.greet(); return 0;}</p><p>int main（string[]args）{string name=&#39；world&#39；var hello=new hello（name）；hello.greet（）；return 0；}</p><p>  Next, open that newly created  Hello.vala and  copy write the same code we wrote previously in  hello/Hello.vala file. In other words,  Hello class.</p><p>接下来，打开新创建的Hello。vala和copy编写的代码与我们之前在hello/hello中编写的代码相同。瓦拉档案。换句话说，大家好。</p><p>  public class Hello { public string name; public Hello(string name) { this.name = name; } public void greet() { stdout.printf(&#34;hello, %s\n&#34;, this.name); }}</p><p>公共类Hello{public string name；public Hello（string name）{this.name=name；}public void greet（）{stdout.printf（&#34；你好，%s\n&#34；，this.name）；}</p><p>  Let&#39;s extend this  Hello class by   Gtk.Application class as we&#39;re now creating the GTK application! This  extending is done via  : operator.</p><p>让&#39；让我们通过Gtk扩展这个Hello类。应用类如我们&#39；我们现在正在创建GTK应用程序！此扩展通过：operator完成。</p><p>  public class Hello : Gtk.Application { public string name; public Hello(string name) { this.name = name; } public void greet() { stdout.printf(&#34;hello, %s\n&#34;, this.name); }}</p><p>公共课你好：Gtk。应用程序{public string name；public Hello（string name）{this.name=name；}public void greet（）{stdout.printf（&#34；你好，%s\n&#34；，this.name）；}</p><p>  We do not needed this  greet() method anymore as we&#39;re interested in displaying the hello, world in window (or in application) and not in terminal!</p><p>我们不再需要这个greet（）方法，因为我们&#39；We’我们对在窗口（或应用程序）而不是终端中显示hello，world感兴趣！</p><p>  public class Hello : Gtk.Application { public string name; public Hello(string name) { this.name = name; }}</p><p>公共课你好：Gtk。应用程序{public string name；public Hello（string name）{this.name=name；}</p><p>  We created the  name variable specially to print the value of it in  greet() method. As we do not have  greet() method now, I don&#39;t think we now need any code that is associated with  name variable. But, yes, we surely need that public method. So, let&#39;s have the empty public method for further usage.</p><p>我们专门创建了name变量，以便在greet（）方法中打印它的值。因为我们现在没有greet（）方法，所以我没有&#39；我不认为我们现在需要任何与name变量关联的代码。但是，是的，我们确实需要这种公开的方法。那么，让&#39；s有空的public方法供进一步使用。</p><p>    As per documentation, we need to call the  Object() method from this public method. This  Object() method accepts two arguments -  application_id, unique  application id in reverse domain name notation or RDNS and   flags with one of the predefined values and   ApplicationFlags.FLAGS_NONE value in our case. All in all, you need to type something like this. If you have GitHub/GitLab account, change the value of  application_id based on your preference.</p><p>根据文档，我们需要从这个公共方法调用Object（）方法。这个Object（）方法接受两个参数——application_id、反向域名表示法中的唯一应用程序id或RDN，以及带有其中一个预定义值和ApplicationFlags的标志。在我们的情况下没有任何价值。总之，你需要输入这样的内容。如果您有GitHub/GitLab帐户，请根据您的偏好更改应用程序id的值。</p><p>  public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}</p><p>  We&#39;ll talk about this  application_id and  flags in future. For now, you need to type couple of things for GTK to properly initialize and run the application.  It&#39;s like  framework, write this and that for us to call properly!</p><p>我们&#39；我将在将来讨论这个应用程序的id和标志。现在，您需要输入一些东西，以便GTK正确初始化和运行应用程序。它&#39；它就像一个框架，写下这个和那个，让我们正确地调用！</p><p>    public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } void activate() { }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}void activate（）{}</p><p>  This  activate() method already existing in  Gtk.Application and what we actually need to do is, to  override using  override keyword.</p><p>Gtk中已存在此activate（）方法。应用程序，我们实际上需要做的是，使用override关键字重写。</p><p>  public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } override void activate() { }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}重写void activate（）{}</p><p>  I assume you don&#39;t forget the rule about access modifiers. In this  activate() method case, we&#39;ll go with  protected access modifier as that&#39;s what we ask for us!</p><p>我想你不会&#39；不要忘记访问修饰符的规则。在这个activate（）方法的例子中，我们&#39；我将使用受保护的访问修饰符，如下所示&#39；这就是我们的要求！</p><p>  public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } protected override void activate() { }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}受保护的覆盖无效激活（）{}</p><p>  And this method  activates the application. Again, it might possible that you get confused with this code. But, this is something you need to type as its like framework (I know library, whatever)!</p><p>这个方法会激活应用程序。同样，您可能会对这段代码感到困惑。但是，这是您需要键入的类似于框架的内容（我知道库，随便什么）！</p><p>  If the application is activated, we need to do something. How about displaying an application widow? That&#39;s what you&#39;re suppose to do with desktop application, right!</p><p>如果应用程序被激活，我们需要做些什么。显示一个应用程序怎么样？那&#39；这就是你&#39；我们应该使用桌面应用程序，对吗！</p><p>  Within this  activate() method, let&#39;s create a window. In GTK,  window is  widget. I mean everything that is a graphical component is widget including menu, button, label, checkbox, list, and so on. These all are widgets in GTK and GTK has separate class(es) for each of these widgets!</p><p>在这个activate（）方法中，让&#39；让我们创建一个窗口。在GTK中，窗口是小部件。我的意思是，所有图形组件都是小部件，包括菜单、按钮、标签、复选框、列表等等。这些都是GTK中的小部件，GTK对每个小部件都有单独的类！</p><p>  Let&#39;s create a  window widget using   ApplicationWindow class. This  ApplicationWindow class accepts the  application as the argument which is  this or class itself as that is the application (remember, we extend the  Gtk.Application to make  Hello as application).</p><p>让&#39；s使用ApplicationWindow类创建窗口小部件。这个ApplicationWindow类接受这个应用程序作为参数，这个参数就是这个类，或者这个类本身就是那个应用程序（记住，我们扩展了Gtk.application，将Hello作为应用程序）。</p><p>  public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } protected override void activate() { var window = new Gtk.ApplicationWindow(this); }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}protected override void activate（）{var window=new Gtk.ApplicationWindow（this）；}</p><p>  We just created the window for the application. We now need to invoke the  .show() method on this  window object to actually display it when  activate() method executes.</p><p>我们刚刚为应用程序创建了一个窗口。我们现在需要调用。在这个窗口对象上显示（）方法，以便在activate（）方法执行时实际显示它。</p><p>  public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } protected override void activate() { var window = new Gtk.ApplicationWindow(this); window.show(); }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}protected override void activate（）{var window=new Gtk.ApplicationWindow（this）；window.show（）；}</p><p>  This is our simple window application! Before we go further and run the application, we need to do some minor modifications in  main.vala as the current code create an instance of  Hello class and run the  greet() method which is not valid anymore.</p><p>这是我们的简单窗口应用程序！在我们继续运行应用程序之前，我们需要在main中做一些小的修改。vala作为当前代码，创建Hello类的实例并运行greet（）方法，该方法不再有效。</p><p>    int main(string[] args) { string name = &#39;world&#39;; var hello = new Hello(name); return 0;}</p><p>int main（string[]args）{string name=&#39；world&#39；var hello=new hello（name）；返回0；}</p><p>  We also not need  name variable and also remove it as argument being passed while creating an instance.</p><p>我们也不需要name变量，也不需要在创建实例时将其作为参数传递。</p><p>    On this  hello object, we need to call  .run() method to actually run the application instance. This method accepts  args as argument.</p><p>在这个hello对象上，我们需要打电话。方法来实际运行应用程序实例。此方法接受args作为参数。</p><p>    This  .run() method returns an integer that we can directly return instead of returning the explicit  0.</p><p>这run（）方法返回一个整数，我们可以直接返回该整数，而不是返回显式的0。</p><p>          I copied this command from  previous article and you know that this will print the  hello, world as output based on code we wrote in those files.</p><p>我从上一篇文章中复制了这个命令，您知道这将根据我们在这些文件中编写的代码将hello，world打印为输出。</p><p>  This is correct! But, we need to do one more modification to this command as we&#39;re now using GTK library. We need to inform Vala compiler to use GTK library while compiling the programs using  --pkg flag followed by the library name or  gtk4 (installed name of the GTK library) in our case. Putting all these together, following is the command we need to run.</p><p>这是正确的！但是，我们需要对这个命令再做一次修改，因为我们&#39；我们现在正在使用GTK库。在本例中，我们需要通知Vala编译器在编译程序时使用--pkg标志，后跟库名或gtk4（GTK库的安装名）。把所有这些放在一起，下面是我们需要运行的命令。</p><p>      After running this command, you should see the default 200x200 window with title as application name e.g.  Hello. But, this is not the hello, world program as we&#39;re not seeing hello, world at any place within the application.</p><p>运行此命令后，您应该会看到默认的200x200窗口，其标题为应用程序名，例如Hello。但是，这不是我们所说的hello，world节目&#39；你在应用程序中的任何地方都看不到hello，world。</p><p>  Let&#39;s print  hello, world instead of  Hello as title. This can be done via updating the  attribute value of  window widget.  window has many attributes including  title (for title of the window),  default_width (for default width of window),  default_height (for default height of window), and so on.</p><p>让&#39；让我们打印hello，world而不是hello作为标题。这可以通过更新窗口小部件的属性值来实现。窗口有很多属性，包括title（窗口的标题）、default_width（窗口的默认宽度）、default_height（窗口的默认高度）等等。</p><p>  We&#39;re now going to assign  hello, world to  window&#39;s  title and  300 to both  default_width and  default_height to create 300x300 window in dimension.</p><p>我们&#39；我们现在将把hello，world分配给window&#39；s title和300设置为默认宽度和默认高度，以创建尺寸为300x300的窗口。</p><p>  public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } protected override void activate() { var window = new Gtk.ApplicationWindow(this); window.title = &#34;hello, world&#34;; window.default_height = 300; window.default_width = 300; window.show(); }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}protected override void activate（）{var window=new Gtk.ApplicationWindow（this）；window.title=&#34；hello，world&#34；window.default#height=300；window.default#width=300；window.show（）}</p><p>        This is the first version of the hello, world program using GTK library. We can go further and display the hello, world text within application&#39;s window.</p><p>这是使用GTK库的hello，world程序的第一个版本。我们可以更进一步，在应用程序&#39；这是窗户。</p><p>  To display the text in window, we need to create a  label widget using  Gtk.Label class just like we created  window using  Gtk.ApplicationWindow class. While creating a  label widget, we need to pass the text which is  hello, world in our case.</p><p>要在窗口中显示文本，我们需要使用Gtk创建一个标签小部件。标签类，就像我们使用Gtk创建窗口一样。应用程序窗口类。在创建标签小部件时，我们需要传递文本，在我们的例子中是hello，world。</p><p>  public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } protected override void activate() { var window = new Gtk.ApplicationWindow(this); window.title = &#34;hello, world&#34;; window.default_height = 300; window.default_width = 300; var label = new Gtk.Label(&#34;hello, world&#34;); window.show(); }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}protected override void activate（）{var window=new Gtk.ApplicationWindow（this）；window.title=&#34；hello，world&#34；window.default#u height=300；window.default#u width=300；var label=new Gtk.label（&#34；hello，world&#34；）；窗show（）；}</p><p>  The label is created. We now need to add this label in  window to display on the screen. We can do it using  set_child() method of  window and passing  label as argument to it.</p><p>标签已创建。我们现在需要在窗口中添加这个标签，以便在屏幕上显示。我们可以使用window的set_child（）方法并将label作为参数传递给它。</p><p>  public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } protected override void activate() { var window = new Gtk.ApplicationWindow(this); window.title = &#34;hello, world&#34;; window.default_height = 300; window.default_width = 300; var label = new Gtk.Label(&#34;hello, world&#34;); window.set_child(label); window.show(); }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}protected override void activate（）{var window=new Gtk.ApplicationWindow（this）；window.title=&#34；hello，world&#34；window.default#u height=300；window.default#u width=300；var label=new Gtk.label（&#34；hello，world&#34；）；窗设置子项（标签）；窗show（）；}</p><p>  Running this program should display the hello, world text on both window&#39;s title and window&#39;s area.</p><p>运行此程序应在两个窗口&#39；标题和窗口&#39；s区。</p><p>      Let&#39;s even go further and add button that will have the hello, world text on it. To add a  button widget, we need to use  Gtk.Button class. Then we need use  set_label() method on created  button to set the label or the text of the  button.</p><p>让&#39；让我们更进一步，添加一个按钮，上面会有hello，world文本。要添加按钮小部件，我们需要使用Gtk。按钮类。然后我们需要对创建的按钮使用set_label（）方法来设置按钮的标签或文本。</p><p>  public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } protected override void activate() { var window = new Gtk.ApplicationWindow(this); window.title = &#34;hello, world&#34;; window.default_height = 300; window.default_width = 300; var label = new Gtk.Label(&#34;hello, world&#34;); window.set_child(label); var button = new Gtk.Button(); button.set_label(&#34;hello, world&#34;); window.show(); }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}protected override void activate（）{var window=new Gtk.ApplicationWindow（this）；window.title=&#34；hello，world&#34；window.default#u height=300；window.default#u width=300；var label=new Gtk.label（&#34；hello，world&#34；）；窗设置子项（标签）；var按钮=新Gtk。按钮（）；按钮设置标签（&#34；你好，世界&#34；）；窗show（）；}</p><p>    public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } protected override void activate() { var window = new Gtk.ApplicationWindow(this); window.title = &#34;hello, world&#34;; window.default_height = 300; window.default_width = 300; var label = new Gtk.Label(&#34;hello, world&#34;); window.set_child(label); var button = new Gtk.Button(); button.set_label(&#34;hello, world&#34;); window.set_child(button); window.show(); }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}protected override void activate（）{var window=new Gtk.ApplicationWindow（this）；window.title=&#34；hello，world&#34；window.default#u height=300；window.default#u width=300；var label=new Gtk.label（&#34；hello，world&#34；）；窗设置子项（标签）；var按钮=新Gtk。按钮（）；按钮设置标签（&#34；你好，世界&#34；）；窗设置孩子（按钮）；窗show（）；}</p><p>  Let&#39;s run this program to confirm the output. We should now see the button below the hello, world text (hint: it&#39;ll not work).</p><p>让&#39；让我们运行这个程序来确认输出。我们现在应该看到hello，world文本下面的按钮（提示：它将不起作用）。</p><p>      It is not working as expected and the reason is,  window can only hold one child or widget whereas we&#39;re trying to add two widgets -  label and  button. Because of this,  window object holding first passed widget and ignoring others. To resolve this problem, we need to use  container widget that act as container and hold as many widgets as we want. Then we&#39;ll set this container widget as child of  window using  set_child() method. There are many container widgets in GTK such as box, table, grid, and so on.</p><p>它没有按预期工作，原因是，窗口只能容纳一个子项或小部件，而我们&#39；我们正在尝试添加两个小部件——标签和按钮。因此，窗口对象持有第一个传递的小部件，而忽略其他小部件。为了解决这个问题，我们需要使用容器小部件作为容器，并容纳我们想要的尽可能多的小部件。然后我们&#39；我将使用set_child（）方法将此容器小部件设置为窗口的子窗口。GTK中有很多容器小部件，比如box、table、grid等等。</p><p>  For the purpose of the demonstration, we&#39;re going to use  Gtk.Grid to create a  grid container widget.</p><p>为了演示的目的，我们&#39；我们将使用Gtk。Grid创建网格容器小部件。</p><p>  public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } protected override void activate() { var window = new Gtk.ApplicationWindow(this); window.title = &#34;hello, world&#34;; window.default_height = 300; window.default_width = 300; var label = new Gtk.Label(&#34;hello, world&#34;); window.set_child(label); var button = new Gtk.Button(); button.set_label(&#34;hello, world&#34;); window.set_child(button); var grid = new Gtk.Grid(); window.show(); }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}protected override void activate（）{var window=new Gtk.ApplicationWindow（this）；window.title=&#34；hello，world&#34；window.default#u height=300；window.default#u width=300；var label=new Gtk.label（&#34；hello，world&#34；）；窗设置子项（标签）；var按钮=新Gtk。按钮（）；按钮设置标签（&#34；你好，世界&#34；）；窗设置孩子（按钮）；var grid=新的Gtk。网格（）；窗show（）；}</p><p>  We can now use  .attach() method of grid widget to add or  pack the other widgets inside the  grid container. This  .attach() method accepts five arguments and last two being optional -  widget that we&#39;re interested to add,  column as position from left, and  row as position from top. Last two optional arguments are  width and  height in form of space. 1 is the default values to  height and  width if not passed.</p><p>我们现在可以使用。方法将其他小部件添加或打包到网格容器中。这attach（）方法接受五个参数，最后两个是可选的——我们&#39；我们有兴趣添加，从左开始列为位置，从上开始行为位置。最后两个可选参数是以空格形式表示的宽度和高度。1是高度和宽度的默认值（如果未通过）。</p><p>  To pack the  label, we&#39;re going to write  .attach(label, 0, 0). In other words, we&#39;re going to pack the  label widget at the position of 0 from left and 0 from top. Yes, the position geometry for the grid starts from (0, 0).</p><p>为了包装标签，我们&#39；我们要写信了。附加（标签，0，0）。换句话说，我们&#39；我们将把标签小部件打包在从左到右0和从上到右0的位置。是的，栅格的位置几何图形从（0，0）开始。</p><p>  public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } protected override void activate() { var window = new Gtk.ApplicationWindow(this); window.title = &#34;hello, world&#34;; window.default_height = 300; window.default_width = 300; var label = new Gtk.Label(&#34;hello, world&#34;); window.set_child(label); var button = new Gtk.Button(); button.set_label(&#34;hello, world&#34;); window.set_child(button); var grid = new Gtk.Grid(); grid.attach(label, 0, 0); window.show(); }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}protected override void activate（）{var window=new Gtk.ApplicationWindow（this）；window.title=&#34；hello，world&#34；window.default#u height=300；window.default#u width=300；var label=new Gtk.label（&#34；hello，world&#34；）；窗设置子项（标签）；var按钮=新Gtk。按钮（）；按钮设置标签（&#34；你好，世界&#34；）；窗设置孩子（按钮）；var grid=新的Gtk。网格（）；网格附加（标签，0，0）；窗show（）；}</p><p>  For  button, we&#39;re going to write  .attach(button, 0, 1). In other words, we&#39;re going to pack the  button widget at the position of 0 from the left and 1 from top means in second line.</p><p>对于button，我们&#39；我们要写信了。连接（按钮，0，1）。换句话说，我们&#39；我们将把按钮小部件放在第二行左边0和上面1的位置。</p><p>  public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } protected override void activate() { var window = new Gtk.ApplicationWindow(this); window.title = &#34;hello, world&#34;; window.default_height = 300; window.default_width = 300; var label = new Gtk.Label(&#34;hello, world&#34;); window.set_child(label); var button = new Gtk.Button(); button.set_label(&#34;hello, world&#34;); window.set_child(button); var grid = new Gtk.Grid(); grid.attach(label, 0, 0); grid.attach(button, 0, 1); window.show(); }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}protected override void activate（）{var window=new Gtk.ApplicationWindow（this）；window.title=&#34；hello，world&#34；window.default#u height=300；window.default#u width=300；var label=new Gtk.label（&#34；hello，world&#34；）；窗设置子项（标签）；var按钮=新Gtk。按钮（）；按钮设置标签（&#34；你好，世界&#34；）；窗设置孩子（按钮）；var grid=新的Gtk。网格（）；网格附加（标签，0，0）；网格连接（按钮，0，1）；窗show（）；}</p><p>  Finally, let&#39;s remove the call to  .set_child() for both  label and  button as we&#39;re going to set the  grid as child to  window.</p><p>最后，让&#39；让我们取消通话。将标签和按钮的_child（）设置为&#39；我们将把网格设置为子窗口。</p><p>  public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } protected override void activate() { var window = new Gtk.ApplicationWindow(this); window.title = &#34;hello, world&#34;; window.default_height = 300; window.default_width = 300; var label = new Gtk.Label(&#34;hello, world&#34;); var button = new Gtk.Button(); button.set_label(&#34;hello, world&#34;); var grid = new Gtk.Grid(); grid.attach(label, 0, 0); grid.attach(button, 0, 1); window.set_child(grid); window.show(); }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}protected override void activate（）{var window=new Gtk.ApplicationWindow（this）；window.title=&#34；hello，world&#34；window.default#u height=300；window.default#u width=300；var label=new Gtk.label（&#34；hello，world&#34；）；var按钮=新Gtk。按钮（）；按钮设置标签（&#34；你好，世界&#34；）；var grid=新的Gtk。网格（）；网格附加（标签，0，0）；网格连接（按钮，0，1）；窗设置子对象（网格）；窗show（）；}</p><p>  Now, running this program should display hello, world thrice - title, text and in button.</p><p>现在，运行这个程序应该显示hello，world三次-标题，文本和in按钮。</p><p>      This is good! Let&#39;s even go further and print the hello, world text in terminal when button is clicked! For this we need to use the concept of  signal. We&#39;re going to catch the  clicked signal emitted by  button when button is actually clicked. Catching the signal is done via  .connect() method. Let&#39;s write this in steps.</p><p>这很好！让&#39；当点击按钮时，我们甚至可以在终端上打印hello，world文本！为此，我们需要使用信号的概念。我们&#39；当按钮实际被点击时，我们将捕捉按钮发出的点击信号。捕捉信号是通过。connect（）方法。让&#39；让我们分步写。</p><p>              You can read this as, when  button is clicked, run the code written inside the  connect() method. This  connect() method accepts the anonymous method.</p><p>可以这样理解，当单击按钮时，运行connect（）方法中编写的代码。这个connect（）方法接受匿名方法。</p><p>    Whatever code you write within this anonymous method is going to be executed when button is clicked. In our case, we&#39;re interested to print the hello, world text when the button is clicked.</p><p>在这个匿名方法中编写的任何代码都将在单击按钮时执行。就我们而言，我们&#39；我们有兴趣在点击按钮时打印hello，world文本。</p><p>      Let&#39;s put these three lines in our  Hello.vala program next to the  button related code.</p><p>让&#39；让我们把这三句话写在问候中。vala程序旁边的按钮相关代码。</p><p>  public class Hello : Gtk.Application { public Hello() { Object( application_id: &#34;com.github.chauhankiran.repo&#34;, flags: ApplicationFlags.FLAGS_NONE ); } protected override void activate() { var window = new Gtk.ApplicationWindow(this); window.title = &#34;hello, world&#34;; window.default_height = 300; window.default_width = 300; var label = new Gtk.Label(&#34;hello, world&#34;); var button = new Gtk.Button(); button.set_label(&#34;hello, world&#34;); button.clicked.connect(() =&gt; { stdout.printf(&#34;hello, world\n&#34;); }); var grid = new Gtk.Grid(); grid.attach(label, 0, 0); grid.attach(button, 0, 1); window.set_child(grid); window.show(); }}</p><p>公共课你好：Gtk。应用程序{public Hello（）{Object（Application#u id:&#34；com.github.chauhankiran.repo&#34；，flags:ApplicationFlags.flags_NONE）；}protected override void activate（）{var window=new Gtk.ApplicationWindow（this）；window.title=&#34；hello，world&#34；window.default#u height=300；window.default#u width=300；var label=new Gtk.label（&#34；hello，world&#34；）；var按钮=新Gtk。按钮（）；按钮设置标签（&#34；你好，世界&#34；）；按钮点击。连接（（）=&gt；{stdout.printf（&#34；你好，world\n&#34；）；}）；var grid=新的Gtk。网格（）；网格附加（标签，0，0）；网格连接（按钮，0，1）；窗设置子对象（网格）；窗show（）；}</p><p>        Again, this is ideally a hello, world program in GTK. The idea behind writing this bigger hello, world program is to give a glimpse of some concepts that we&#39;ll use in application development. That being said, in next article, we&#39;ll write the  trivial toy application by continue learning few more concepts and techniques.</p><p>同样，这是一个理想的问候，在GTK的世界计划。写这个更大的hello，world项目的想法是让我们对一些概念一瞥&#39；我们将在应用程序开发中使用。话虽如此，在下一篇文章中，我们&#39；我将通过继续学习更多的概念和技术来编写这个微不足道的玩具应用程序。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/gtk/">#gtk</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/方法/">#方法</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>