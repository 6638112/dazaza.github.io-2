<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>惯用的生锈？ 实施二进制搜索（第2部分） </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">惯用的生锈？ 实施二进制搜索（第2部分） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-13 08:51:23</div><div class="page_narrow text-break page_content"><p>这是原始文章的后续行动，我看几种Wathsto提高了我的二进制搜索的生锈实施 - 重点删除＆＃39;错误＆＃39;并使它成为＆＃39;惯用＆＃39;尽可能。</p><p> 我在第一个与中间值和高/低光标之间的比较相关的第一篇文章中收到的最常见的反馈。</p><p>  在我的原始推文中（甚至在第一篇文章之前）我介绍了通过生锈＆＃39; s匹配构造对此比较的算法的变种。</p><p>  铁锈酒吧fn（k：i32，项目：＆amp; [i32]） - ＆gt;选择＆lt; I32＆gt; {让MUT LOW：I32 = 0;让MUT HIGH：I32 = items.len（）作为i32  -  1;虽然低<lt; =高{让中间=（（（高+低）/ 2）为f64）.floor（）作为i32;匹配项目。重点（中间为大小）{某些（当前）如果* current == k =＆gt;返回一些（中间），如果*当前＆gt; k =＆gt;高=中间 -  1，一些（电流）如果*电流＆lt; k =＆gt;低=中间+ 1，_ =＆gt; {} } }  没有任何}</p><p> 如果我们将第一篇文章的反馈应用于这一实施，我们将＆＃39＆＃39; D结束了以下 - 这只是一个灰尘，因为它可以消除一些铸件以及手册＆＃39;地板＆＃39;我最初在做。</p><p> 铁锈酒吧fn（k：i32，项目：＆amp; [i32]） - ＆gt;选择＆lt; Usize＆gt; {让MUT低：USIZE = 0;让mut高：Usize = items.len（） -  1;虽然低<lt; =高{让中间=（高+低）/ 2;匹配项目。重点（中间）{一些（当前）如果* current == k =＆gt;返回一些（中间），如果*当前＆gt; k =＆gt; {如果中间== 0 {返回无; };高=中间 -  1}如果*电流＆lt; k =＆gt; {Low =中间+ 1; } _ =＆gt; {} } }  没有任何}</p><p>  这是它变得有点复杂的地方。我最初接受了Twitterthat的一些反馈，建议，因为I＆＃39; m不使用任何臂中的匹配块的返回值，以及我＆＃39; m只使用它来突变高/低光标，这这可能被视为不惯然的生锈...... </p><p>我完全明白反馈，并纠正匹配可以写得如此：</p><p> Rust匹配项目。（中间为大小）{一些（当前）如果* Current == k =＆gt; {返回一些（中间）; }，一些（当前）如果*当前＆gt; k =＆gt; {如果中间== 0 {返回无};高=中间 -  1; }，某些（电流）如果*电流＆lt; k =＆gt; {Low =中间+ 1; }，_ =＆gt; {}}</p><p> 现在，每个匹配臂都没有尾随表达式，可能会更清楚我们在那里＆＃39; t打算从匹配块返回这里的值。</p><p>    1：rust致力于使用模式匹配，而匹配在技术上是技术性的（因此可以用作一个值），我不觉得它觉得它＆＃39;如果它并非总是如此用作价值？</p><p> 2：如果匹配的每个ARM具有不同的语义，那似乎会更多的问题。例如，如果Onearm返回一个值，另一个Didn＆＃39; t。这将使实施不一致，并且该观点可以持有更多的水，但是Rust＆＃39; s型系统无论如何都不会允许这种情况，因为匹配的每个arm必须返回相同的值。</p><p> 对于那些两个原因，这篇文章的其余部分将专注于进一步改进我们的算法，充分利用匹配 - 但如果你不同意，我会在Twitter上伸出援手，我＆＃39; D Loveve继续谈话♥</p><p>   我们的算法在I32值的一片中搜索。在每次迭代中，我们正在访问.get（）方法的Slice中的值。这是为了安全完成，因为如果您尝试索引 - 使用缺失的值，可以发生运行时恐慌。 </p><p>rust fn（）{让项目= vec！[10,40,90];让rest_item =项目[3]; println！（＆＃34; {：？}＆＃34;，thath_item）//＃39; main＆＃39; ＆＃39恐慌;索引超出界限：// len是3但索引是3＆＃39;}</p><p> rust fn（）{让项目= vec！[10,40,90];让First_Item = Items.get（0）; println！（＆＃34; {：？}＆＃34;，first_item）; //打印`某些（10）`letth_item = items.get（3）; println！（＆＃34; {：？}＆＃34;，thath_item）//打印`none`}</p><p> 因此，访问值的第二种方式可以更安全，但它以该选项类型的形式的额外层间间接以成本为代价。</p><p> Rust //返回类型是选项＆lt; i32＆gt;让项目= items.get（4）//返回类型是i32，但可能会恐慌让项目=项目[4]</p><p> 这在第一篇文章中影响了我们的算法，因为我们需要使用如果LetExpression通过某些（当前）模式暴露当前值。</p><p> rust //↓↓↓↓↓↓↓↓↓↓↓↓如果让某些（当前）= items.get（中间）{if * current == k {// snip}如果* current＆gt; k {// snip}如果*当前＆lt; k {// snip}}</p><p> 因此，要删除选项，因此还删除了.get（）和一些（当前），我们需要在数学上进行数学上的界限 - 否则我们＆＃39; d and to and and＃39;事实证明，我们的原始算法实际上正在执行我们所需的所有检查 - 它始终确保下一个索引访问高于零，并且低于切片的最大长度。 </p><p>这意味着在原始文章方面，我们可以＆＃39更换了如果让某些（当前）用一个简单的索引传播，这使得解决方案较少嘈杂并且整体更简单。</p><p> 生锈//我们知道这是赢得＆＃39;自从我们控制＆＃39;中间＆＃39; //↓↓↓↓↓↓↓↓↓↓↓↓↓当Current == k {// Snip}</p><p> 现在我们可以相信直接索引访问始终是安全的，因为我们控制了中间价值，但Doesthis如何帮助我们提到的匹配表达式？</p><p>  如果我们所做的一切都从本文的开头取出比赛表达式，并将选项删除为提到的，我们＆＃39; d最终得到了这样的东西</p><p> rust //在匹配项目之前。注（中间）{某些（当前）如果* current == k =＆gt;返回一些（中间），如果*当前＆gt; k =＆gt; {如果中间== 0 {返回无}; HIGH =中间 -  1}，如果*电流＆lt; k =＆gt; {Low =中间+ 1; }，_ =＆gt; {}} //匹配项目[中间] {当前电流== k =＆gt; {返回一些（中间）; }，当前if * current＆gt; k =＆gt; {如果中间== 0 {返回无};高=中间 -  1}，电流IF *电流＆lt; k =＆gt; {Low =中间+ 1; }，_ =＆gt; {}}</p><p> 这几乎甚至是一个改善♥！如果有的话，我＆＃39; d说它＆＃39实际上更难阅读。</p><p> 它缺少下一个大步骤，这也是另一个朝向更惯用的生锈 - 而且达到了ord特征在标准图书馆的i32实施的事实。 </p><p>ord特性有一个.cmp（其他）方法，它返回订购枚举的变体，它＆＃39; s定义列表...</p><p> rust // std :: cmp pub特性：eq + partialord＆lt;自我＆gt; {FN（＆amp;自我，其他：＆amp; self） - ＆gt;订购; // Snip}</p><p>  rust fn（）{让第一：i32 = 1;让第二：i32 = 3;让结果= First.cmp（＆amp;第二）; println！（＆＃34;结果= {}＆＃34;结果）//输出`少，`更大的`或`等于}</p><p> 请注意，如何将3个单独的比较合并为单个方法调用 -  it删除手动检查等于的需要，更大，更少，更低，而是自我们＆＃39以来的更高的声明性;重新确定实际实现。</p><p> 调用后.CMP（其他）我们现在有一个值等于订购的一个值和＃39; S 3 Enum Variantsand，这是与模式匹配的语言非常闪耀，因为我们可以在变体上做匹配，并实现了匹配一点点。</p><p> 锈匹配项目[中间] .cmp（＆amp; k）{订购::等于=＆gt;返回一些（中间），订购::更高=＆gt; {如果中间== 0 {返回无}; high = middle  -  1}，订购::少=＆gt;低=中间+ 1}</p><p> 随着更宣言的风格，它＆＃39; S也远远少得多，令人沮丧地解析。 😇 </p><p>此外，由于订购枚举上的匹配是穷的，因此我们不再需要空_ =＆gt; {}作为最终捕获 - 所有匹配臂。 🙏</p><p> 此处的最后一件事是因为＆＃39;重新调用为ord特征实现的方法，这意味着在将来可以更通用，以便在寻找实现ord的任何类型，而不是i32的算法我们的例子。这将使这是一个伟大的后续博客文章，突出了Rust的特征的力量，如果你喜欢看到这个帖子发生在Twitter上，请在Twitter上发出特征。</p><p>  到目前为止申请两种改进后（去除选项+做单一比较），我们最终得到了以下实现 - 这显然是一个很大的改善♥。</p><p> Rust使用STD :: CMP ::订购; FN（k：I32，项目：＆amp; [I32]） - ＆gt;选择＆lt; Usize＆gt; {如果项目.is_empty（）{return none}让mut低：Usize = 0;让mut高：Usize = items.len（） -  1;虽然低<lt; =高{让中间=（高+低）/ 2;匹配项目[中间] .cmp（＆amp; k）{订购::等于=＆gt;返回一些（中间），订购::更高=＆gt; {如果中间== 0 {返回无}; high = middle  -  1}，订购::少=＆gt; Low = Middle + 1}}无}</p><p>  我们的实施中有2条线条仍然感觉＆＃39;过度设计的＆＃39; - 或者相反，它感觉可能会改善或移除。</p><p> Frose //这是函数中的开头检查如果Items.Is_empty（）{返回None} //部分）需要//确保我们在中间==中的DON＆＃39; T减去低于零点0 {返回none};</p><p> 要解决此问题，我们需要解决核心算法。如果我们将高度定义为独占的上个边界，只需将其重新分配给函数开始时切片的长度，或者到后域值，我们可以确定我们＆＃39; ll永远不会减少它的值零，因此我们可以删除上面提到的检查。 </p><p>我们＆＃39; D是确保没有一个可变的使用光标可以下降到零以下，这将允许我们删除Thosetwo手动检查。</p><p>  这让我们留下了以下内容，其中我开始感到快乐，这两个长的博客帖子＆amp;我在Twitter上收到的反馈🙏</p><p> Rust使用STD :: CMP ::订购; FN（k：I32，项目：＆amp; [I32]） - ＆gt;选择＆lt; Usize＆gt; {让MUT低：USIZE = 0;让mut高：Usize = items.len（）;虽然低＆lt;高{让中间=（高+低）/ 2;匹配项目[中间] .cmp（＆amp; k）{订购::等于=＆gt;返回一些（中间），订购::更高=＆gt;高=中间，订购::少=＆gt; Low = Middle + 1}}无}</p><p>  此处的第一次可视化展示了两个帖子中的所有演示（除了来自The File Change）的所有演示</p><p>  下一个可视化显示，当您高分之类时，一切都变得更加简单，整体上占用了较少的步骤。另请注意HighCursor如何以比列表结尾的1索引开始，而先前则直接植入最后一个元素。</p><p>   感谢Wiebe Cnossen和Pasile Henry for提供激发此后续帖子的反馈。</p><p>  我喜欢听到任何反馈或替代方法来实现这种算法 - 所以如果你有任何想法，请在Twitter上伸出 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://shane-o.dev/blog/binary-search-rust-part-2">https://shane-o.dev/blog/binary-search-rust-part-2</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/二进制/">#二进制</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/binary/">#binary</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/匹配/">#匹配</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>