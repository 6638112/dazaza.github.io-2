<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>迷你编译器：lexing</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">迷你编译器：lexing</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-31 19:54:31</div><div class="page_narrow text-break page_content"><p>I&#39;ve always wanted to make my own compiler. Compilers are an integral part ofmy day to day job and I use the fruits of them constantly. A while ago while Iwas browsing through the TempleOS source code I found MiniCompiler.HC in the  ::/Demos/Lectures folder and I was abit blown away. It implements a two phase compiler from simple math expressionsto AMD64 bytecode (complete with bit-banging it to an array that the code laterjumps to) and has a lot to teach about how compilers work. For those of you thatdon&#39;t have a TempleOS VM handy, here is a video of MiniCompiler.HC in action:</p><p>我一直想做自己的编译器。编译器是我日常工作中不可或缺的一部分，我经常使用它们的成果。不久前，当我浏览TempleOS源代码时，在：：/Demos/Lessons文件夹中发现了MiniCompiler.HC，我有点吃惊。它实现了一个从简单的数学表达式到AMD64字节码的两阶段编译器(完成后将其比特转换为代码稍后跳转到的数组)，并且有很多关于编译器如何工作的内容要教授。对于那些手头没有TempleOS虚拟机的人，这里有一段MiniCompiler.HC运行的视频：</p><p>  You put in a math expression, the compiler builds it and then spits out a bunchof assembly and runs it to return the result. In this series we are going to becreating an implementation of this compiler that targets  WebAssembly.This compiler will be written in Rust and will use only the standard library foreverything but the final bytecode compilation and execution phase. There is alot going on here, so I expect this to be at least a three part series. Thesource code will be in  Xe/minicompiler in case you want to readit in detail. Follow along and let&#39;s learn some Rust on the way!</p><p>您输入一个数学表达式，编译器构建它，然后输出一堆程序集并运行它以返回结果。在本系列中，我们将创建该编译器的一个面向WebAssembly的实现。该编译器将用Rust编写，除了最后的字节码编译和执行阶段外，将只使用标准库。这里发生了很多事情，所以我希望这至少是一个三集的系列。源代码在xe/mini编译器中，如果您想详细了解的话。跟着走，让我们在路上学到一些生锈的东西！</p><p> Compilers for languages like C are built on top of the fundamentals here, butthey are  much more complicated.</p><p>像C这样的语言的编译器是建立在这里的基础之上的，但是它们要复杂得多。</p><p>    Ideally we should be able to nest the parentheses as deep as we want without anyissues.</p><p>理想情况下，我们应该能够将括号嵌套到我们想要的深度，而不会出现任何问题。</p><p> Looking at these values we can notice a few patterns that will make parsing thisa lot easier:</p><p>查看这些值，我们可以注意到一些模式，它们将使解析变得容易得多：</p><p>      This will create a folder called  minicompiler and a file called  src/main.rs.Open that file in your editor and copy the following into it:</p><p>这将创建一个名为minicompiler的文件夹和一个名为src/main.rs的文件。在编辑器中打开该文件，并将以下内容复制到其中：</p><p> // src/main.rs/// Mathematical operations that our compiler can do.#[derive(Debug, Eq, PartialEq)]enum Op { Mul, Div, Add, Sub,}/// All of the possible tokens for the compiler, this limits the compiler/// to simple math expressions.#[derive(Debug, Eq, PartialEq)]enum Token { EOF, Number(i32), Operation(Op), LeftParen, RightParen,}</p><p>//src/main.rs/编译器可以执行的数学运算。#[Derate(Debug，Eq，PartialEq)]枚举Op{Mul，Div，Add，Sub，}/编译器的所有可能令牌，这将编译器限制为/简单的数学表达式。#[Derate(Debug，Eq，PartialEq)]枚举Token{EOF，Number(I32)，Operation(Op)，LeftParen，RightParen，}。</p><p> In compilers, &#34;tokens&#34; refer to the individual parts of the language you areworking with. In this case every token represents every possible part of aprogram.</p><p>在编译器中，标记指的是您正在使用的语言的各个部分。在这种情况下，每个令牌代表程序的每个可能部分。</p><p> And then let&#39;s start a function that can turn a program string into a bunch oftokens:</p><p>然后，让我们启动一个函数，该函数可以将程序字符串转换为一串令牌：</p><p>  Wait, what do you do about bad input such as things that are not math expressions?Shouldn&#39;t this function be able to fail?</p><p>等等，你怎么处理不好的输入，比如不是数学表达式的东西？这个函数不应该失败吗？</p><p> You&#39;re right! Let&#39;s make a little error type that represents bad input. Forcreativity&#39;s sake let&#39;s call it  BadInput:</p><p>你说得对！让我们做一个代表错误输入的小错误类型。看在创造力的份上，让我们称它为BadInput：</p><p> // src/main.rsuse std::error::Error;use std::fmt;/// The error that gets returned on bad input. This only tells the user that it&#39;s/// wrong because debug information is out of scope here. Sorry.#[derive(Debug, Eq, PartialEq)]struct BadInput;// Errors need to be displayable.impl fmt::Display for BadInput { fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result { write!(f, &#34;something in your input is bad, good luck&#34;) }}// The default Error implementation will do here.impl Error for BadInput {}</p><p>//src/main.rsuse std：：Error：：Error；Use std：：fmt；/输入错误时返回的错误。这只会告诉用户它是错误的，因为调试信息不在这里的范围内。抱歉。#[Deriate(Debug，Eq，PartialEq)]struct BadInput；//需要显示错误。Iml fmt：：Display for BadInput{fn fmt(&amp；self，f：&amp；mut fmt：：Formatter)-&gt；fmt：：result{write！(F，&#34；Something is Bad，Good&34；)}}//默认错误实现将在此执行。BadInput{}。</p><p>   So now that we have the function type we want, let&#39;s start implementing  lex()by setting up the result and a loop over the characters in the input string:</p><p>现在我们有了我们想要的函数类型，让我们通过设置结果并对输入字符串中的字符进行循环来开始实现lex()：</p><p> // src/main.rsfn lex(input: &amp;str) -&gt; Result&lt;Vec&lt;Token&gt;, BadInput&gt; { let mut result: Vec&lt;Token&gt; = Vec::new(); for character in input.chars() { todo!(&#34;implement this&#34;); } Ok(result)}</p><p>//src/main.rsfn lex(input：&amp；str)-&gt；result&lt；vec&lt；Token&gt；，BadInput&gt；{let mut result：vec&lt；Token&gt；=vec：：new()；对于input.chars(){TODO！(&#34；Implementate this&#34；)；}OK(Result)}。</p><p> Looking at the examples from earlier we can start writing some boilerplate toturn characters into tokens:</p><p>看一下前面的示例，我们可以开始编写一些样板来将字符转换为标记：</p><p> // src/main.rs// ...for character in input.chars() { match character { // Skip whitespace &#39; &#39; =&gt; continue, // Ending characters &#39;;&#39; | &#39;\n&#39; =&gt; { result.push(Token::EOF); break; } // Math operations &#39;*&#39; =&gt; result.push(Token::Operation(Op::Mul)), &#39;/&#39; =&gt; result.push(Token::Operation(Op::Div)), &#39;+&#39; =&gt; result.push(Token::Operation(Op::Add)), &#39;-&#39; =&gt; result.push(Token::Operation(Op::Sub)), // Parentheses &#39;(&#39; =&gt; result.push(Token::LeftParen), &#39;)&#39; =&gt; result.push(Token::RightParen), // Numbers &#39;0&#39; | &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &#39;6&#39; | &#39;7&#39; | &#39;8&#39; | &#39;9&#39; =&gt; { todo!(&#34;implement number parsing&#34;) } // Everything else is bad input _ =&gt; return Err(BadInput), }}// ...</p><p>//src/main.rs//...对于input.chars(){匹配字符{//跳过空白&#39；&#39；=&&gt;；继续，//结束字符&#39；；&#39；\n&#39；=&gt；{result t.ush(Token：：EOF)；Break；}//数学运算&#39；*&#39；=&gt；result t.ush(Token：：operation(opp：：mul))，&#39；/&#39；=&gt；Result.Push(Token：：Operation(Op：div))，&#39；+&#39；=&gt；Result.Push(Token：：Operation(Op：：Add))，&#39；-&#39；=&gt；Result.Push(Token：：Operation(Op：：Sub))，//括号&#39；(&#39；=&gt；result t.ush(Token：：LeftParen)，&#39；)=&gt；Result t.ush(Token：：RightParen)，//Numbers&#39；0&#39；|&#39；1&#39；|&#39；2&#39；|&#39；3&#39；|&#39；4&#39；|&#39；5&#39；|&#39；6&#39；|&#39；7&#39；|&#39；8&#39；|&#39；9&#39；=&gt；{TODO！(&#34；实现数字解析&#34；)}//其他一切都是错误的input_=&gt；return err(BadInput)，}}//...</p><p>   // src/main.rs// ...use Op::*;use Token::*;match character { // ... // Math operations &#39;*&#39; =&gt; result.push(Operation(Mul)), &#39;/&#39; =&gt; result.push(Operation(Div)), &#39;+&#39; =&gt; result.push(Operation(Add)), &#39;-&#39; =&gt; result.push(Operation(Sub)), // Parentheses &#39;(&#39; =&gt; result.push(LeftParen), &#39;)&#39; =&gt; result.push(RightParen), // ...} // ...</p><p>//src/main.rs//...Use Op：：*；Use Token：：*；Match Character{//...//数学运算&#39；*&#39；=&gt；result t.ush(Operation(Mul))，&#39；/&#39；=&gt；result t.ush(Operation(Div))，&#39；+&#39；=&gt；result t.ush(Operation(Add))，&#39；-&#39；=&gt；Result t.ush(Operation(Sub))，//括号&#39；(&#39；=&gt；result t.ush(LeftParen)，&#39；=&gt；result t.ush(RightParen)，//...}//...。</p><p>  You can use the  use statement just about anywhere in your program. However tokeep things flowing nicer, the  use statement is right next to where it isneeded in these examples.</p><p>您几乎可以在程序中的任何位置使用USE语句。但是，为了保持更好的流畅性，Use语句就在这些示例中需要它的位置旁边。</p><p> Now we can get into the fun that is parsing numbers. When he wrote MiniCompiler,Terry Davis used an approach that is something like this (spacing added for readability):</p><p>现在我们可以开始享受解析数字的乐趣了。在编写MiniCompiler时，Terry Davis使用了类似以下内容的方法(为可读性添加了空格)：</p><p> case &#39;0&#39;...&#39;9&#39;: i = 0; do { i = i * 10 + *src - &#39;0&#39;; src++; } while (&#39;0&#39; &lt;= *src &lt;= &#39;9&#39;); *num=i;</p><p>案例&#39；0&#39；...&#39；9&#39；：i=0；do{i=i*10+*src-&#39；0&#39；；src++；}While(&#39；0&#39；&lt；=*src&lt；=&#39；9&#39；)；*num=i；</p><p> This sets an intermediate variable  i to 0 and then consumes characters fromthe input string as long as they are between  &#39;0&#39; and  &#39;9&#39;. As a neat sideeffect of the numbers being input in base 10, you can conceptualize  40 as  (4 * 10) + 2. So it multiplies the old digit by 10 and then adds the new digit tothe resulting number. Our setup doesn&#39;t let us get that fancy as easily, howeverwe can emulate it with a bit of stack manipulation according to these rules:</p><p>这会将中间变量i设置为0，然后消耗输入字符串中的字符，只要它们介于&#39；0&#39；和&#39；9&#39；之间。作为以10为基数输入的数字的一个巧妙副作用，您可以将40概念化为(4*10)+2。因此，它将旧数字乘以10，然后将新数字与结果数字相加。我们的设置不会让我们那么容易实现，但是我们可以根据以下规则通过一些堆栈操作来模拟它：</p><p> If  last is a number, multiply that number by 10 and add the current numberto it</p><p>如果最后一个是一个数字，则将该数字乘以10，然后将当前数字加到该数字上。</p><p> Otherwise push the node back into  result and push the current number to result as well</p><p>否则，将节点推回RESULT，并将当前数字也推入RESULT。</p><p>  // src/main.rs// ...// Numbers&#39;0&#39; | &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &#39;6&#39; | &#39;7&#39; | &#39;8&#39; | &#39;9&#39; =&gt; { let num: i32 = (character as u8 - &#39;0&#39; as u8) as i32; if result.len() == 0 { result.push(Number(num)); continue; } let last = result.pop().unwrap(); match last { Number(i) =&gt; { result.push(Number((i * 10) + num)); } _ =&gt; { result.push(last); result.push(Number(num)); } }} // ...</p><p>//src/main.rs//...//Numbers&#39；0&#39；|&#39；1&#39；|&#39；2&#39；|&#39；3&#39；|&#39；4&#39；|&#39；5&#39；|&#39；6&#39；|&#39；7&#39；|&#39；8&#39；|&#39；9&#39；=&gt；{let num：I32=(Character as U8-&#39；0&#39；as U8)as I32；if result t.len()==0{result t.ush(number(Num))；Continue；}let last=result t.op().unrapp()；Match last{number(I)=&gt；{result t.ush(number((i*10)+num))；}_=&gt；{result t.ush(Last)；result t.ush(number(Num))；}}//...</p><p> This is not the most robust number parsing code in the world, however it willsuffice for now. Extra credit if you can identify the edgecases!</p><p>这不是世界上最健壮的数字解析代码，但是目前它已经足够了。如果你能辨认出边缘的话就加分！</p><p> This should cover the tokens for the language. Let&#39;s write some tests to be sureeverything is working the way we think it is!</p><p>这应该包括该语言的标记。让我们写一些测试，以确保一切都像我们想象的那样工作！</p><p>  Rust has a  robust testingframework built into thestandard library. We can use it here to make sure we are generating tokenscorrectly. Let&#39;s add the following to the bottom of  main.rs:</p><p>RUST在标准库中内置了一个健壮的测试框架。我们可以在这里使用它来确保我们生成的令牌是正确的。让我们将以下内容添加到main.rs的底部：</p><p> #[cfg(test)] // tells the compiler to only build this code when tests are being runmod tests { use super::{Op::*, Token::*, *}; // registers the following function as a test function #[test] fn basic_lexing() { assert!(lex(&#34;420 + 69&#34;).is_ok()); assert!(lex(&#34;tacos are tasty&#34;).is_err()); assert_eq!( lex(&#34;420 + 69&#34;), Ok(vec![Number(420), Operation(Add), Number(69)]) ); assert_eq!( lex(&#34;(30 + 560) / 4&#34;), Ok(vec![ LeftParen, Number(30), Operation(Add), Number(560), RightParen, Operation(Div), Number(4) ]) ); }}</p><p>#[cfg(Test)]//告诉编译器仅在运行测试时编译此代码{use Super：：{Op：：*，Token：：*，*}；//将以下函数注册为测试函数#[test]FN BASIC_Lexing(){assert！(lex(&#34；420+69&#34；).is_ok())；assert！(lex(&#34；Tacos Are Tavy&#34；).is_err()；assert_eq！(lex(&#34；420+69&#34；).is_err()；assert_eq！(lex(&#34；420+69&#34；).is_err()；assert_eq！(lex(&#34；420+69&#34；)，确定(vec！[number(420)，Operation(Add)，number(69)])；assert_eq！(lex(&#34；(30+560)/4&#34；)，OK(vec！[LeftParen，number(30)，Operation(Add)，number(560)，right Paren，Operation(Div)，number(4)])；}}。</p><p> This test can and probably should be expanded on, but when we run  cargo test:</p><p>这个测试可以而且可能应该扩展，但是当我们运行货物测试时：</p><p> $ cargo test Compiling minicompiler v0.1.0 (/home/cadey/code/Xe/minicompiler) Finished test [unoptimized + debuginfo] target(s) in 0.22s Running target/debug/deps/minicompiler-03cad314858b0419running 1 testtest tests::basic_lexing ... oktest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</p><p>$Cargo测试编译迷你编译器v0.1.0(/HOME/cadey/code/xe/minicompiler)在0.22s内完成测试[未优化+调试信息]目标运行target/debug/deps/minicompiler-03cad314858b0419running 1测试测试：BASIC_LEXING...。OK测试结果：OK。1通过；0失败；0忽略；0测量；0过滤掉。</p><p> And hey presto! We verified that all of the parsing is working correctly. Thosetest cases should be sufficient to cover all of the functionality of thelanguage.</p><p>嘿，马上！我们验证了所有解析都工作正常。最小的用例应该足以涵盖该语言的所有功能。</p><p>  This is it for part 1. We covered a lot today. Next time we are going to run avalidation pass on the program, convert the infix expressions to reverse polishnotation and then also get started on compiling that to WebAssembly. This hasbeen fun so far and I hope you were able to learn from it.</p><p>第一部分就到这里。我们今天讲了很多。下次我们要在程序上运行avalidation pass时，将中缀表达式转换为反向Polishnotation，然后也开始将其编译为WebAssembly。到目前为止，这一直很有趣，我希望你能从中学到东西。</p><p>     This article was posted on M10 29 2020. Facts and circumstances may have changed since publication. Please  contact me before jumping to conclusions if something seems wrong or unclear.</p><p>这篇文章发表在2020年M10 29上。自发表以来，事实和情况可能发生了变化。如果有什么不对劲或不清楚的地方，请在匆忙下结论之前与我联系。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://christine.website/blog/minicompiler-lexing-2020-10-29">https://christine.website/blog/minicompiler-lexing-2020-10-29</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031619.html"><img src="http://img2.diglog.com/img/2020/10/thumb_99f2142c0124e0d0a756ac05f1257d4d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031619.html">Eslisp-ECMAScript/JavaScript的S表达式语法，带有类似Lisp的宏</a></div><span class="my_story_list_date">2020-10-28 5:7</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031022.html"><img src="http://img2.diglog.com/img/2020/10/thumb_6e4f4bad7bb9be861f0eccbbc527e64d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031022.html">罗马工具链：Linter、编译器、绑定器等</a></div><span class="my_story_list_date">2020-10-25 7:32</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030829.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b71f23a653e4ac6df1ae71037508c3c3.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030829.html">我自己的编译器基础结构上的我自己的C编译器</a></div><span class="my_story_list_date">2020-10-24 7:31</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030633.html"><img src="http://img2.diglog.com/img/2020/10/thumb_21054de7abd23919431e2a8a7caa1f96.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030633.html">使用Bakeware将Elixir应用程序编译为单个可执行的二进制文件</a></div><span class="my_story_list_date">2020-10-23 2:54</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>