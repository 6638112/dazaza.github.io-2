<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>漏水抽象 Leaky Abstractions</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Leaky Abstractions<br/>漏水抽象 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-03 23:48:06</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/b92973c94c2b31441d4de3920dafc254.png"><img src="http://img2.diglog.com/img/2021/6/b92973c94c2b31441d4de3920dafc254.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In the late 1990s, the Windows Shell and Internet Explorer teams introduced a lot of brilliant and intricate designs that allowed intricate extension of the shell and the browser to handle scenarios beyond what those built by Microsoft itself. For instance, Internet Explorer supported the notion of pluggable protocols (“ What if some protocol, say, FTPS becomes as important as HTTP?”) and the Windows Shell offered an extremely flexible set of abstract browsing of namespaces, enabling third parties to build browsable “folders” not backed by the file system– everything from WebDAV (“ your HTTP-server is a folder“) to CAB Folders (“ your CAB archive is a folder“). As a PM on the clipart team in 2004, I built a .NET-based application to browse clipart from the Office web services, and I sketched out an initial design for a Windows Shell extension that would make it look like Microsoft’s enormous web-based clipart archive were installed in a local folder on your system.</p><p>在20世纪90年代末，Windows Shell和Internet Explorer团队介绍了许多辉煌和复杂的设计，允许错综复杂的shell和浏览器来处理超出Microsoft本身建造的场景。例如，Internet Explorer支持可插拔协议的概念（如果某些协议，例如，FTPS与HTTP？“变得同样重要的话），并且Windows Shell提供了一个非常灵活的抽象浏览名称空间，使第三方能够构建可浏览“文件夹”未由文件系统备份 - 从WebDAV（“您的HTTP-Server是文件夹”）到CAB文件夹（“您的CAB存档是文件夹”）的所有内容。作为2004年的Clipart团队的PM，我建立了基于.NET的应用程序来从Office Web服务浏览剪贴画，我勾勒出了一个初始设计，以使其看起来像Microsoft的基于Web的Web Clipart存档安装在系统上的本地文件夹中。</p><p> Perhaps the most popular (or infamous) example of a shell namespace extension is the Compressed Folders extension, which handles the exploration of ZIP files. First introduced in the Windows 98  Plus Pack and later included with Windows Me+ directly, Compressed Folders allows billions of Windows users to interact with ZIP files without downloading third-party software. Perhaps surprisingly, the feature was itself was acquired from two third-parties — Microsoft acquired the Explorer integration from  Dave Plummer’s “side project”, while a company called  InnerMedia claims credit for the “DynaZIP” engine underneath.</p><p> 也许最受欢迎的（或臭名昭着）的shell命名空间扩展名称是压缩文件夹扩展，处理ZIP文件的探索。首先在Windows 98 Plus包中引入，后来包含在Windows Me +直接，压缩文件夹允许数十亿个Windows用户与Zip文件进行交互，而无需下载第三方软件。也许令人惊讶的是，该特征本身就是从两个第三方获得的 - 微软从Dave Plummer的“侧面项目”中获得了探险家集成，而一家名为InnerMedia索赔的公司，为下面的“Dynazip”引擎。</p><p> Unfortunately, the code hasn’t really been updated in a while. A long while. The timestamp in the module claims it was last updated on Valentine’s Day 1998, and while I suspect there may’ve been a fix here or there since then (and one feature, extract-only Unicode filename support), it’s no secret that the code is, as  Raymond Chen says: “ stuck at the turn of the century.” That means that it doesn’t support “modern” features like AES encryption, and its performance (runtime, compression ratio) is known to be dramatically inferior to  modern 3rd-party implementations.</p><p> 不幸的是，代码暂时没有更新。很久了。模块中的时间戳声称它最后一次更新了1998年的情人节，而我怀疑在这里或之后可能已经解决了（和一个功能，只有unicode文件名支持），而代码则没有秘密是的，正如Raymond Chen所说：“陷入世纪之交。”这意味着它不支持像AES加密这样的“现代”功能，并且已知其性能（运行时，压缩比）被显着逊于现代的第三方实现。</p><p> So, why hasn’t it been updated? Well, “ if it aint broke, don’t fix it” accounts for part of the thinking– the ZIP Folders implementation has survived in Windows for 23 years without the howling of customers becoming unbearable, so there’s some evidence that users are happy enough.</p><p> 那么，为什么它没有更新？好吧，“如果它是一个破坏，不要修复它”占思考的一部分 -  Zip文件夹的实施已经在Windows中幸存了23年，而没有客户令人难以忍受的嚎叫，因此有一些证据表明用户足够高兴。</p><p> Unfortunately, there are degenerate cases where the ZIP Folders support really  is broken. I ran across one of those  yesterday. I had seen an interesting Twitter thread about  hex editors that offer annotation (useful for exploring file formats) and decided to try a few out (I decided I like   ReHex best). But in the process, I downloaded the portable version of  ImHex and tried to move it to my Tools folder.</p><p> 不幸的是，ZIP文件夹支持真正被破坏的堕落情况。我昨天跑过其中一个。我已经看到了一个关于十六进制编辑的有趣的推特线程，提供注释（有助于探索文件格式）并决定尝试几次（我决定最喜欢Rehex）。但在此过程中，我下载了IMHEX的便携式版本，并试图将其移动到我的工具文件夹中。</p><p> I did so by double-clicking the 11.5mb ZIP to open it. I then hit  CTRL+A to select all of the files within, then crucially ( spoiler alert)  CTRL+X to cut the files to my clipboard.</p><p> 我通过双击11.5MB Zip打开它来完成此操作。然后，我按Ctrl + A选择所有文件，然后粗略（SPOILER ALERT）CTRL + X将文件剪切到我的剪贴板。</p><p>  I then created a new subfolder in my  C:\Tools folder and hit  CTRL+V to paste. And here’s where everything went off the rails– Windows spent well over a minute showing “ Calculating…” with no visible progress beyond the creation of a single subfolder with a single 5k file within:</p><p>  然后，我在C：\ Tools文件夹中创建了一个新的子文件夹，并按住Ctrl + V粘贴。在这里，一切都在轨道上越来越多地在一分钟内花了“计算......”，除了在单个5k文件中创建单个子文件夹之外，没有明显的进展： </p><p>  Huh? I knew that the ZIP engine beneath ZIP Folders wasn’t well-optimized, but I’d never seen anything  this bad before. After waiting a few more minutes, another file extracted, this one 6.5 mb:</p><p>呵呵？我知道拉链文件夹下方的拉链发动机并不优化，但我以前从未见过这么糟糕。等待几分钟后，另一个文件提取，这是6.5 MB：</p><p>  This is bananas. I opened Task Manager, but nothing seemed to be using up much of my 12 thread CPU, my 64gb of memory, or my NVMe SSD. Finally, I opened up  SysInternals’ Process Monitor to try to see what was going on, and the root cause of the problem was quickly seen.</p><p>  这是香蕉。我打开了任务管理器，但似乎没有什么可以使用我的大部分线程CPU，我的64GB内存或我的NVME SSD。最后，我打开了Sysinternals的过程监视器，试图看看发生了什么，并且很快就会看到问题的根本原因。</p><p> After some small reads from the end of the file (where the ZIP file keeps its index), the entire 11 million byte file was being read from disk  a single byte at a time:</p><p> 在文件末尾（ZIP文件保留其索引的位置）之后，一次从磁盘读取整个1100万字节文件：</p><p>  Looking more closely, I realized that the reads were  almost all a single byte, but every now and then, after a specific 1 byte read, a 15 byte read was issued:</p><p>  仔细观察，我意识到读取几乎都是一个字节，但是，现在，然后，在特定的1字节读取之后，发出了15个字节的读取：</p><p>  What’s at those  interesting offsets ( 330,  337)? The byte  0x50, aka the letter  P.</p><p>  那些有趣的抵消是什么（330,337）？字节0x50，AKA字母P.</p><p>  Having written some  trivial ZIP-recovery code in the past, I know what’s special about the character  P in ZIP files– it’s the first byte of the ZIP format’s  block markers, each of which start with  0x50 0x4B. So what’s plainly happening here is that the code is reading the file from start to finish looking for a particular block,  16 bytes in size. Each time it hits a  P, it looks at the next 15 bytes to see if they match the desired signature, and if not, it continues scanning byte-by-byte, looking for the next  P.</p><p>  在过去编写了一些琐碎的拉链恢复代码，我知道zip文件中的字符p的特殊性是什么 - 它是zip格式的块标记的第一个字节，每个字符串都以0x50 0x4b开头。因此，这里显然发生了什么，代码正在从开始读取文件，以完成一个特定的块，大小为16个字节。每次击中P时，它都会查看接下来的15个字节，以查看它们是否与所需的签名匹配，如果没有，它会继续扫描Byte-Byte，查找下一个P.</p><p>  The  ZIP Format consists of a series of file records, followed by a list (“Central Directory”) of those file records.</p><p>  邮政局格式由一系列文件记录组成，然后是这些文件记录的列表（“中央目录”）。 </p><p> Each file record has its own “local file header” which contains information about the file, including its size, compressed size, and CRC-32; the same data is repeated in the Central Directory.</p><p>每个文件记录都有自己的“本地文件标题”，其中包含有关文件的信息，包括其大小，压缩大小和CRC-32;中央目录中重复相同的数据。</p><p> However, the ZIP format allows the local file headers to omit this data and instead write it as a “trailer” after the compressed data, a capability that is useful when  streaming compression– you cannot know the final compressed size until you’ve actually finished compressing the data. Most ZIP files probably don’t make use of this option, but my example download does.   You can see the CRC and sizes are  0‘d in the header and instead appear immediately following the signature  0x08074b50 (  Data Descriptor), just before the next file’s local header:</p><p> 但是，zip格式允许本地文件头省略此数据，而是在压缩数据之后将其写入“挂步”，这是在流式压缩时有用的功能 - 在您实际完成之前，无法知道最终压缩大小压缩数据。大多数zip文件可能不使用此选项，但我的示例下载它是。您可以看到CRC和尺寸在标题中为0'，而是在签名0x08074b50（数据描述符）之后立即显示在下一个文件的本地标题之前：</p><p>  The 0x08 bit in the  General Purpose flag indicates this option; users of 7-Zip can find it mentioned as  Descriptor in the entry’s  Characteristics column:</p><p>  通用标志中的0x08位表示此选项; 7-zip的用户可以在条目特征列中找到它作为描述符：</p><p>  Based on the read size ( 1+15 bytes), I assume the code is groveling for the Data Descriptor blocks.  Why it does that (vs. just reading the same data from the Central Directory) I do not know.</p><p>  基于读取大小（1 + 15个字节），我假设代码是针对数据描述符块的刨花。为什么它这样做（与读取来自中心目录的相同数据）我不知道。</p><p> Making matters worse, this “read the file, byte by byte” crawl through the file doesn’t just happen once– it happens at least once for  every file extracted. Making matters worse, this data is being  read with ReadFile rather than fread().</p><p> 使事情变得更糟，这就是“读取文件，字节”爬行通过文件爬网并不只是发生一次，因为每个文件都至少发生一次。更糟糕的是，使用ReadFile而不是Fread（）读取此数据。</p><p>   After restarting and  configuring Process Monitor with Symbols, we can examine the one-byte reads and get a hint of what’s going on:</p><p>   用符号重新启动和配置进程监视器后，我们可以检查一个字节读取并获得一丝暗示正在进行的内容：</p><p>  The  GetSomeBytes function is getting hammered with calls passing a single byte buffer, in a tight loop inside the  readzipfile function. But look down the stack and the root cause of the mess becomes clear– this is happening because after each file is “moved” from the ZIP to the target folder, the ZIP file must be updated to delete the file that was “moved.” This deletion process is  inherently not fast (because it results in shuffling all of the subsequent bytes of the file and updating the index), and as implemented in the  readzipfile function (with its one-byte read buffer) is atrociously slow.</p><p>  GetSomebytes函数正在击中传递单个字节缓冲区的呼叫，在Readzipfile功能内的紧密循环中。但是瞧不起堆栈，乱七八糟的根本原因变得清晰 - 这发生了，因为在每个文件从zip到目标文件夹后，必须更新zip文件以删除“移动”的文件。此删除过程本质上不是快速（因为它导致将文件的所有后续字节进行洗牌并更新索引），并且如在ReadzzipFile函数中实现（具有其单字节读缓冲区）更慢。 </p><p> Back up in my repro steps, note that I hit  CTRL+X to “Cut” the files, resulting in a Move operation. Had I instead hit  CTRL+C to “Copy” the files, resulting in a Copy operation, the ZIP folder would not have performed a delete operation as each file was extracted. The time required to unpack the ZIP file drops  from over thirty minutes to four seconds. For perspective, 7-Zip unpacks the file in under a quarter of a second, although it  cheats a little.</p><p>备份我的repro步骤，请注意，我按Ctrl + X键“剪切”文件，从而导致移动操作。如果我替代地击中Ctrl + C要“复制”文件，导致复制操作，ZIP文件夹将不执行删除操作，因为提取了每个文件。解压缩ZIP文件所需的时间从30分钟到四秒钟下降。对于透视图，7-zip将文件解压缩在一秒钟内的一秒钟内，尽管它欺骗了一点。</p><p> And here’s where  the abstraction leaks— from a user’s point-of-view, copying files out of a ZIP file (then deleting the ZIP) vs. moving the files from a ZIP file seems like it shouldn’t be very different. Unfortunately, the abstraction fails to fully paper over the reality that deleting from certain ZIP files is an extremely slow operation, while deleting a file from a disk is usually trivial. As a consequence, the Compressed Folder abstraction works well for tiny ZIPs, but fails for the larger ZIP files that are becoming increasingly common.</p><p> 这里是从用户的视图泄露的地方，从zip文件中复制文件（然后删除zip）与zip文件中的文件似乎不应该是非常不同的。遗憾的是，抽象无法通过删除某些ZIP文件的现实中的现实中的完全纸张，同时从磁盘中删除文件通常是微不足道的。因此，压缩文件夹抽象适用于微小的拉链，但失败的较大的ZIP文件变得越来越普遍。</p><p> While it’s relatively easy to think of ways to dramatically improve the performance of this scenario, precedent suggests that the code in Windows is unlikely to be improved anytime soon. Perhaps for its 25th Anniversary? 🤞</p><p> 虽然考虑到大大提高这种情况的性能的方法相对容易，但是先例表明Windows中的代码不太可能随时改善。也许是它的25周年纪念日？ 🤞 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://textslashplain.com/2021/06/02/leaky-abstractions/">https://textslashplain.com/2021/06/02/leaky-abstractions/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/漏水/">#漏水</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/leaky/">#leaky</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>