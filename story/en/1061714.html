<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>生锈1.52.1. Rust 1.52.1</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rust 1.52.1<br/>生锈1.52.1. </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-10 23:06:00</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/10c030b2429f801a5aed8756bdece9d2.jpg"><img src="http://img2.diglog.com/img/2021/5/10c030b2429f801a5aed8756bdece9d2.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The Rust team has prepared a new release, 1.52.1, working around a bug inincremental compilation which was made into a compiler error in 1.52.0. Werecommend all Rust users, including those currently using stable versions priorto 1.52.0, upgrade to 1.52.1 or disable incremental compilation. Guidance on howto do so is available below.</p><p>Rust团队已准备好新版本，1.52.1，围绕一个错误的汇编，在1.52.0中进行了编译错误。 WERECENMEND所有生锈用户，包括目前使用稳定版本的PRIORTO 1.52.0，升级到1.52.1或禁用增量编译。关于HOWTO的指导如下。</p><p> If you have a previous version of Rust installed via rustup, getting Rust1.52.1 is as easy as:</p><p> 如果您有通过Rustup安装的先前版本的RUDE，则rust1.52.1可以轻松：</p><p>  If you don&#39;t have it already, you can  get  rustupfrom the appropriate page on our website.</p><p>  如果您已将其＆＃39;它已经有了它，您可以在我们的网站上使用合适的页面来获得RustUp.</p><p>  This release works around broken builds on 1.52.0, which are caused by newlyadded verification. The bugs this verification detects are present in all Rustversions  1, and can trigger miscompilations in incremental builds, so downgradingto a prior stable version is not a fix.</p><p>  此版本在1.52.0上围绕破碎构建工作，这是由新的验证引起的。此验证检测到所有rustVersions 1中存在错误，并且可以在增量构建中触发MIScompilation，因此下降到先前的稳定版本不是修复。</p><p> Users are encouraged to upgrade to 1.52.1 or disable incremental in their localenvironment if on a prior version: please see the  what you should dosection for details on how to do so.</p><p> 如果在先前版本，则鼓励用户升级到1.52.1或在其LocalEnvironment中禁用增量：请参阅您应该有关如何执行此操作的详细信息。</p><p> Incremental compilation is off by default for release builds, so fewproduction builds should be affected (only for users who have opted in).</p><p> 默认情况下，增量编译默认为发布构建，因此应该影响少量生产库（仅适用于选择的用户）。</p><p> Miscompilations that can arise from the bugs in incremental compilation generate incorrect code in finalartifacts, essentially producing malformed binaries, which means that in theoryany behavior is possible. In practice we are currently only aware of oneparticular known miscompilation, but bugs due to incremental are notoriouslyhard to track down: users frequently simply rebuild after some light editing ifthey see unexpected results from their binaries, and this often causessufficient recompilation to fix the bug(s).</p><p> 从增量编译中的错误可能出现的误解是在基本节省的基本上产生错误的代码，基本上产生格式错误的二进制文件，这意味着在理论中的行为中是可能的。在实践中，我们目前只意识到一个初始的已知的误解，但由于增量导致的错误是令人缺乏追踪的错误：用户经常在一些光线编辑的情况下重建ifthey从他们的二进制文件中看到意外结果，并且这通常会促成修复错误以修复错误）。 </p><p>  Tell you  what you should do if you see an unstable fingerprint on your project,</p><p>如果您在项目上看到不稳定的指纹，请告诉您您应该怎么做，</p><p>  The error message looks something like this, with the key piece being the &#34;foundunstable fingerprints&#34; text.</p><p>  错误消息看起来像这样，钥匙件是＆＃34; foundunstable指纹＆＃34;文本。</p><p> thread &#39;rustc&#39; panicked at &#39;assertion failed: `(left == right)` left: `Some(Fingerprint(4565771098143344972, 7869445775526300234))`, right: `Some(Fingerprint(14934403843752251060, 623484215826468126))`: found unstable fingerprints for &lt;massive text describing rustc internals elided&gt;error: internal compiler error: unexpected panicnote: the compiler unexpectedly panicked. this is a bug.</p><p> 线程＆＃39; rustc＆＃39;恐慌＆＃39;断言失败：`（左==右）`左：`某些（指纹（4565771098143344972,786944575526300234））`，右：`某些（指纹（14934403843752251060,62348415826468126））`：找到了＆lt的不稳定指纹;庞大的文本描述了RustC内部的Elided＆gt;错误：内部编译器错误：意外Panicnote：编译器意外慌乱。这是一个错误。</p><p> This is the error caused by the internal consistency check, and as stated in the diagnostic, it yields an &#34;Internal Compiler Error&#34; (or ICE). In other words, it represents a bug in the internals of the Rust compiler itself. In  this case, the ICE is revealing a bug in incremental compilation that predates the 1.52.0 release and could result in miscompilation if it had not been caught.</p><p> 这是由内部一致性检查引起的错误，如诊断所说，它会产生一个＆＃34;内部编译器错误＆＃34; （或冰）。换句话说，它代表了生锈编译器本身的内部结构中的错误。在这种情况下，ICE正在揭示增量编译中的错误，该错误预测1.52.0释放，如果没有被捕获，可能会导致错误组合。</p><p>  The Rust compiler has support for &#34;incremental compilation&#34;, which has been described in a  2016 blog post. When incremental compilation is turned on, the compiler breaks the input source into pieces, and tracks how those input pieces influence the final build product. Then, when the inputs change, it detects this and reuses artifacts from previous builds, striving to expend effort solely on building the parts that need to respond to the changes to the input source code.</p><p>  Rust编译器支持＆＃34;增量编译＆＃34;已在2016年博客文章中描述。当上打开增量编译时，编译器将输入源打破成碎片，并跟踪这些输入部分如何影响最终的构建产品。然后，当输入更改时，它会检测到此处的伪像并从以前的构建中重复使用伪影，努力支持努力建立需要响应输入源代码的更改的部件。</p><p> Fingerprints are part of our architecture for detecting when inputs change. More specifically, a fingerprint (along with some other state to establish context) is a 128-bit value intended to uniquely identify internal values used within the compiler. Some compiler-internal results are stored on disk (&#34;cached&#34;) between runs. Fingerprints are used to validate that a newly computed result is unchanged from the cached result. (More details about this are available in the  relevant chapter of the rustc dev guide.)</p><p> 指纹是用于检测输入时的架构的一部分。更具体地，指纹（以及建立上下文的一些其他状态）是旨在唯一地识别编译器中使用的内部值的128位值。某些编译器内部结果存储在磁盘上（＆＃34;在运行之间的缓存和＃34;）。指纹用于验证新计算结果是否从缓存的结果中不变。 （有关此内容的更多详细信息，请参阅RustC开发指南的相关章节。）</p><p> The fingerprint stability check is a safeguard asserting internal consistency ofthe fingerprints. Sometimes the compiler is forced to rerun a query, and expectsthat the output is the same as from a prior incremental compilation session. Thenewly enabled verification checks that the value is indeed as expected, ratherthan assuming so. In some cases, due to bugs in the compiler&#39;s implementation,this was not actually the case.</p><p> 指纹稳定性检查是一种安全性断言指纹的内部一致性。有时，编译器被强制重新运行查询，并且最终输出与先前的增量编译会话相同。然后，启用了验证检查该值确实如预期，而不是假设所以。在某些情况下，由于编译器中的错误和实现的错误，这实际上并非如此。 </p><p>  We  initially added these fingerprint checks as a tool to use whendeveloping rustc itself, back in 2017. It was solely provided via an unstable -Z flag, only available to nightly and development builds.</p><p>我们最初将这些指纹检查添加为使用Whendeveloping rustC本身的工具，返回2017年。它仅通过不稳定的-Z标志提供，仅适用于夜间和开发构建。</p><p> More recently, in March, we encountered a  miscompilation that led us to  turn on  verify-ich by default. The Rust compiler team decided it was better to catch fingerprint problems and abort compilation, rather than allow for potential miscompilations (and subsequent misbehavior) to sneak into Rust programmer&#39;s binaries.</p><p> 最近，在3月，我们遇到了一种误解我们，默认情况下导致我们打开验证-Ich。 Rust编译团队决定捕捉指纹问题并中止编译，而不是允许潜在的误解（以及随后的不端行为）潜入铁锈程序员＆＃39;二进制文件。</p><p> When we first turned on the fingerprint checks by default, there was a steadystream of issues filed by users of the nightly (and beta) toolchains, and steadyprogress has been made on identifying fixes, a number of which have alreadylanded.</p><p> 当我们默认第一次打开指纹检查时，夜间（和测试版）工具链提交的问题存在稳定的问题，并且已经在识别修复上进行了稳定的问题，其中许多已经有了Aleadylanded。</p><p> In the past week, we had started  making plans to improve theuser-experience, so that the diagnostic issued by the check would do a betterjob of telling the programmer what to do in response. Unfortunately, this wasdone under the assumption that the new verification would ship in 1.53, not1.52.</p><p> 在过去的一周里，我们开始制定计划来提高观察者体验，以便检查诊断会做一个更好的job，告诉程序员在回应中做些什么。不幸的是，这是在假设新验证的假设下，在1.53，Not1.52中发货。</p><p>  Today&#39;s new release, 1.52.1, works around the breakage caused by the newly addedverification by temporarily changing the defaults in the Rust compiler to disableincremental unless the user knowingly opts in.</p><p>  今天＆＃39;■新版本，1.52.1，通过临时将Rust编译器中的默认值更改为禁用的默认值，除非用户意识到选择。</p><p>  Essentially, for some crates, certain sequences of edit-compile cycles will cause  rustc to hit the &#34;unstable fingerprints&#34; ICE. I showed one example at the start of this blog post.</p><p>  基本上，对于一些条件，某些编辑汇编循环序列将导致RustC击中＆＃34;不稳定的指纹＆＃34;冰。我在这个博客帖子的开始时展示了一个例子。</p><p>  thread &#39;rustc&#39; panicked at &#39;found unstable fingerprints for predicates_of(&lt;massive text describing rustc internals elided&gt;)&#39;, /rustc/.../compiler/rustc_query_system/src/query/plumbing.rs:593:5</p><p>  线程＆＃39; rustc＆＃39; ＆＃39恐慌;找到了regiricates_of的不稳定指纹（＆lt;描述rustc内部的巨型文本＆gt;）＆＃39; /strustc/.../compiler/rustc_query_system/src/query/plumbing.rs:593:5 </p><p> They all arise from inconsistencies when comparing the incremental-compilation cache stored on disk against the values computed during a current  rustc invocation, which means they all arise from using incremental compilation.</p><p>当在将磁盘上的增量编译缓存与在当前rustc调用期间计算的值进行比较时，它们都会因不一致而产生的，这意味着它们都会因使用增量编译而出现。</p><p>  You may be building with the  dev or  test  profiles which default to having incremental compilation enabled.</p><p>  您可以使用DEV或测试配置文件构建，默认为启用增量编译。</p><p> If your project has not adjusted the defaults, then when running  cargo build --release or otherwise in the  release profile configuration incremental isdisabled on all Rust versions  1, and these issues should not affect your releasebuilds.</p><p> 如果您的项目未调整默认值，则在运行Cargo Build  - 释放或以其他方式在所有RUST版本1上的发布配置文件配置中，并且这些问题不应影响您的royefabuilds。</p><p>  The Internal Compiler Error asks you to report a bug, and if you can do so, we still want that information. We  want to know about the cases that are failing.</p><p>  内部编译器错误要求您报告一个错误，如果可以这样做，我们仍然希望该信息。我们想知道对失败的案例。</p><p> But regardless of whether or not you file a bug, the problem can be worked around on your end by either:</p><p> 但是，无论您是否提交错误，都可以通过以下任一终止问题：</p><p> upgrading to 1.52.1, if you have not yet done so (which will disableincremental for you), or</p><p> 升级到1.52.1，如果您还没有这样做（将为您禁用）或</p><p>  forcing incremental compilation to be disabled, by setting  CARGO_INCREMENTAL=0 in your environment or  build.incremental to  false in the  config.toml.</p><p>  通过在环境中设置cargo_incremental = 0或构建，迫使禁用增量编译。在config.toml中，在config.toml中设置为false。 </p><p>  We do  not recommend that users of 1.52.0 downgrade to an earlier version of Rust in response to this problem. As noted above, there is at least one instance of a silent  miscompilation caused by incremental compilation that was not caught until we added the fingerprint checking.</p><p>我们不建议将1.52.0的用户降级到早期版本的RURE，以响应此问题。如上所述，至少在我们添加指纹检查之前没有捕获的增量编译引起的静默错误组合的一个实例。</p><p> If a user is willing to deal with the incremental verification ICE&#39;s, and wishesto opt back into the 1.52.0 behavior, they may set  RUSTC_FORCE_INCREMENTAL to 1 in their environment. The Rust compiler will then respect the -Cincremental option passed by Cargo, and things will work as before, thoughwith the added verification. Note that this flag does not enable incremental ifit has not already been separately enabled (whether by Cargo or otherwise).</p><p> 如果用户愿意处理增量验证ICE＆＃39; s，并且Wellesto选择回到1.52.0行为，他们可以将RustC_Force_incremental设置为1在其环境中。然后，Rust编译器将尊重货物传递的-cinecrenceal选项，并且在添加验证之前，事情将如之前工作。请注意，此标志不会启用增量IFIT尚未单独启用（无论是货物还是其他方式）。</p><p> If you are currently using a toolchain prior to 1.52.0, and wish to continuedoing so, we recommend that you disable incremental compilation to avoid hittingsilent miscompilations.</p><p> 如果您目前在1.52.0之前使用工具箱，并希望继续继续，我们建议您禁用增量编译以避免佩特数错营。</p><p> On all Rust builds since incremental has landed, it has been a majorimprovement to compile times for many users, and has only improved over time. Weacknowledge that the workarounds presented here and recommendations are painful,and will be working hard to ensure the situation is as temporary as possible.</p><p> 在所有Rust构建以来，由于增量降落了，它是许多用户编制时期的主要内容，并且只会随着时间的推移而得到改善。编织此处提出的解决方法和建议是痛苦的，并将努力确保局势尽可能临时。</p><p>    Disables incremental compilation in the Rust compiler (unless asked for by anew environment variable,  RUSTC_FORCE_INCREMENTAL=1).</p><p>    禁用Rust编译器中的增量编译（除非由重建环境变量询问，rustc_force_incremental = 1）。</p><p> Improves diagnostic output for the new verification if incremental compilation is enabled,indicating how to work around the bugs by purging incremental state ordisabling incremental.</p><p> 如果启用了增量编译，请提高新验证的诊断输出，指示如何通过清除增量状态汇总增量来解决错误。</p><p> This is intended to be a mitigation that helps the majority of Rust users havean upgrade path to a safe Rust compiler which does not have the risk ofmiscompiling their code, but also provide the option for users willing to dealwith the errors to do so.</p><p> 这是一种缓解，帮助大多数生锈用户升级到一个安全的生锈编译器的升级路径，这与他们的代码中的风险没有风险，而且还提供愿意处理这么做的用户的选择。 </p><p> We expect to continue to actively invest in fixing the bugs, and depending onour confidence in the fixes, may issue a 1.52.2 point release which backportsthose fixes to the stable channel. Users wishing to help us test can use thenightly channel, and report bugs to rust-lang/rust with any ICEs theyare seeing.</p><p>我们预计将继续积极投资来修复错误，并且根据对修复的信心，可能会发出1.52.2点释放，返回稳定的通道。希望帮助我们测试的用户可以使用hisightly频道，并将错误_ rust-lang / fort报告与他们的任何同幂相似。</p><p> We are also currently not planning to disable incremental on the beta channel,but this decision has not been firmly committed to. A number of fixes areavailable on 1.53 beta today, so users who wish to continue using incrementalmay want to switch to that. Nightly will always have the latest in fixes, ofcourse.</p><p> 我们目前还没有计划在测试渠道上禁用增量，但该决定尚未牢固致力于。今天，许多修复在1.53β今天不可曝光，因此希望继续使用增量的用户想要切换到该用户。每晚都会始终拥有最新的修复。</p><p>  The long-term plan is to fix the bugs! Incremental compilation is the only realistic way for the Rust compiler to be able to provide a fast edit-compile-run cycle for all of its programmers, and so we need to address  all of the issues that have been identified thus far via  verify-ich. (There are 32 such issues as of this writing, though many are duplicates.)</p><p>  长期计划是解决错误！增量编译是生锈编译器能够为所有程序员提供快速编辑编译运行周期的唯一现实方式，因此我们需要解决迄今为止验证的所有问题。 （这份写作中有32个问题，但很多都是重复的。）</p><p> We are actively investing in this, and a number of bugs have already beenidentified and fixed. Depending on the state of the fixes, future stablereleases (1.53 and onwards) will likely re-enable incremental compilation.</p><p> 我们正在积极投资这一点，并且已经存在了许多错误并已修复。根据修复的状态，未来的StableElexaess（1.53和向上）可能会重新启用增量编译。</p><p> The Rust teams will also be developing plans to ensure we have better trackingsystems in place in the future for bugs, both to prevent situations like thisfrom arising again, but also to further increase the stability of our releasesby tracking bugs more accurately as they propagate across channels.</p><p> 生锈团队也将开发计划，以确保我们在未来有更好的跟踪系统，以便在漏洞中防止这样的错误，而且还可以更准确地提高追踪频道的追踪错误的稳定性。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.rust-lang.org/2021/05/10/Rust-1.52.1.html">https://blog.rust-lang.org/2021/05/10/Rust-1.52.1.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/生锈/">#生锈</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>