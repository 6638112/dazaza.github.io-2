<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>三个月的行程(从哈斯克勒的角度看)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">三个月的行程(从哈斯克勒的角度看)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-04 11:30:27</div><div class="page_narrow text-break page_content"><p>This summer I’ve been interning at  Pusher, and have been writing a lot of Go. It’s been a bit of a change coming from a Haskell background, so I decided to write up my thoughts now, at the end.</p><p>这个夏天我一直在Pusher实习，写了很多围棋。哈斯克尔的背景有点改变，所以我决定在最后写下我的想法。</p><p>   There’s not a lot to Go, it’s quite a small language. I had never written a line of it before June, and now I’ve written about 30,000. It’s very easy to get started and become productive.</p><p>没什么可去的，它是一种相当小的语言。在六月之前我一行也没有写过，现在我已经写了大约三万篇了。入门并变得富有成效是非常容易的。</p><p> Haskell, on the other hand, is notorious for being hard to learn ( cough monad tutorials  cough). People often find it really hard to take the step from evaluating pure mathematical expressions to writing actual programs. I experienced no such disconnect in Go.</p><p>另一方面，Haskell以难学而臭名昭著(咳嗽单曲教程咳嗽)。人们经常发现很难从计算纯数学表达式到编写实际的程序。我在围棋中没有经历过这样的脱节。</p><p>  Pusher previously tried to use Haskell for the project I was working on, but eventually had to give up due to unpredictable latency caused by garbage collection pauses. GHC’s garbage collector is  designed for throughput, not latency. It is a generational copying collector, which means that pause times are proportional to the amount of live data in the heap. To make matters worse, it’s also stop-the-world.</p><p>Pusher之前曾试图在我参与的项目中使用Haskell，但最终由于垃圾收集暂停导致的不可预测的延迟而不得不放弃。GHC的垃圾收集器设计用于吞吐量，而不是延迟。它是分代复制收集器，这意味着暂停时间与堆中的实时数据量成正比。更糟糕的是，这也是在阻止世界。</p><p> Go’s garbage collector is a concurrent mark-sweep with very short stop-the-world pauses, and it just seems to  keep getting better. This is definitely a good thing for a garbage collected language. We did have some issues with unacceptable latencies, but were able to work them all out. No such luck with the Haskell project.</p><p>Go的垃圾收集器是一个带有非常短的停止-世界暂停的并发标记-清扫，而且它似乎一直在变得更好。对于垃圾收集语言来说，这绝对是件好事。我们确实有一些延迟无法接受的问题，但我们能够全部解决。哈斯克尔项目就没有这么好的运气了。</p><p>  Say what you like about  gofmt, but it makes arguments over code style almost impossible. Just run it on save, and your code will always be consistently formatted.</p><p>尽管您喜欢gofmt，但它使得围绕代码样式的争论几乎是不可能的。只需在保存时运行它，您的代码将始终保持一致的格式。</p><p> I do find it a little strange that  gofmt has been completely accepted, whereas Python’s significant whitespace (which is there for exactly the same reason: enforcing readable code) has been much more contentious across the programming community.</p><p>我确实觉得有点奇怪，gofmt已经被完全接受，而Python的重要空格(存在的原因完全相同：强制执行可读代码)在编程社区中更具争议性。</p><p>   I am not a huge fan of code generation (and I say this as  the author of a code generation tool). I think it can do good, but it can also obscure what’s actually going on. In every discussion on Go generics, someone will come along and say you can add generics with code generation: that’s true, but at the cost of introducing additional, nonstandard, syntax.</p><p>我不是代码生成的狂热爱好者(我是作为代码生成工具的作者说这番话的)。我认为它可以做好事，但它也可能掩盖实际发生的事情。在每次关于Go泛型的讨论中，都会有人说您可以通过代码生成来添加泛型：这是真的，但代价是引入了额外的非标准语法。</p><p> I suspect the strong culture of code generation is largely because it lets you work around the flaws of the language.</p><p>我怀疑代码生成的强大文化在很大程度上是因为它让您可以绕过语言的缺陷。</p><p>  Strict evaluation is typically better for performance than lazy evaluation (thunks cause allocation, so you’re gambling that  the computation saved offsets the memory cost), but it does make things less composable. There have been a couple of times where I’ve gone to split up a function, only to realise that doing so would require allocating a data structure in memory which before was not needed.</p><p>严格的计算通常比懒惰的计算更有利于性能(块会导致分配，因此您在赌节省的计算会抵消内存成本)，但它确实会降低可组合性。有几次我去拆分一个函数，结果才意识到这样做需要在内存中分配一个以前不需要的数据结构。</p><p> I could trust the compiler to inline things for me, and so optimise away the additional allocations, but in a lazy language you just don’t have that issue at all.</p><p>我可以相信编译器会为我内联程序，从而优化掉额外的分配，但是在懒惰的语言中根本就没有这个问题。</p><p>  If you know me in person, it might seem a little odd that I specifically comment on this. Normally I am all for languages having a small, really well-written, stdlib and everything else provided through libraries. I am picking on Go here a bit because the standard library seems to get a lot of praise, but I was unimpressed.</p><p>如果你了解我本人，我特别评论这件事可能有点奇怪。通常情况下，我完全支持拥有一个很小的、编写得非常好的stdlib的语言，以及通过库提供的所有其他东西。我选择Go Here有点是因为标准库似乎得到了很多赞誉，但我不为所动。</p><p> Parts of it are good, a lot of it is mediocre, and some of it is downright bad (like the  go/ast package documentation). It seems a lot of Go’s use is in webdev, so perhaps those bits of the stdlib (which I haven’t touched at all) are consistently good.</p><p>它有一部分是好的，有很多是平庸的，而有些则是彻头彻尾的糟糕(比如Go/ast包文档)。似乎Go在WebDev中有很多用处，所以也许stdlib的那些部分(我根本没有碰过它)一直都很好。</p><p>  I also agree with this Quora answer by Tikhon Jelvis to  do you feel that golang is ugly?, so have a look at that once you’ve read this section.</p><p>我也同意Tikhon Jelvis的Quora回答，你觉得Golang很丑吗？所以一旦你读完这一节，就来看看这一点。</p><p>  In Go, you import packages by URL. If the URL points to, say, GitHub, then  go get downloads HEAD of master and uses that. There is no way to specify a version, unless you have separate URLs for each version of your library.</p><p>在Go中，您可以通过URL导入包。如果URL指向(比方说)GitHub，那么Go Get将下载主站点的负责人并使用该站点。除非您的库的每个版本都有单独的URL，否则无法指定版本。</p><p>  Go has a very strong culture of backwards compatibility, which I think is largely due to this. Even if you have a flaw in the API of your library, you can’t actually  fix it because that would break all of your reverse-dependencies, unless they do vendoring, or pin to a specific commit.</p><p>围棋有非常强的向后兼容文化，我认为这在很大程度上是因为这一点。即使您的库的API中有一个缺陷，您也不能实际修复它，因为这将打破您所有的反向依赖，除非它们确实提供或固定到特定的提交。</p><p> Coming from the Haskell world, where the attitude is far more towards correctness than compatibility, this was probably the biggest culture shock for me. Things break backwards compatibility in Haskell, and the users just update their code because they  know the library author did it for a reason. In Go, it just doesn’t happen  at all.</p><p>来自哈斯克尔世界，那里的态度更多的是对正确的态度，而不是兼容性，这可能是对我最大的文化冲击。在Haskell中破坏了向后兼容性，用户只是更新他们的代码，因为他们知道库作者这样做是有原因的。在围棋中，这根本不会发生。</p><p>  A common mantra in Haskell is “make illegal states unrepresentable,” which is great. If you’ve never come across it before it means to  choose your types such that an illegal value is a static error. Want to avoid nulls? Use an option type. Want to ensure a list has at least one element? Use a nonempty list type. Use proper enums, not just ints. etc etc</p><p>哈斯克尔的一句俗语是“让非法国家变得不可代表”，这很棒。如果您以前从未遇到过它，那么它意味着选择您的类型，这样非法的值就是静态错误。想要避免空值吗？使用选项类型。想要确保列表至少有一个元素吗？使用非空列表类型。使用正确的枚举，而不仅仅是整数。等，等等。</p><p> In Go you just can’t do that, the type system isn’t strong enough. So a lot of things which are (or can be) a  compile-time error in Haskell are a  runtime error in Go, which is just worse.</p><p>在围棋中你不能这样做，类型系统不够强大。因此，Haskell中的许多事情(或可能是)编译时错误都是Go中的运行时错误，这只是更糟糕的错误。</p><p>  Want to write a tree where every element is statically  guaranteed to be the same type? Well, have fun implementing a “uinttree”, an “inttree”, a “stringtree”, and so on. You can’t just implement a generic tree.</p><p>想要编写一个静态保证每个元素都是同一类型的树吗？那么，享受实现“uinttree”、“inttree”、“string tree”等等的乐趣吧。您不能只实现泛型树。</p><p> But Go  does have generics, for the built-in types. Arrays, channels, maps, and slices all have generic type parameters. So it seems that the Go developers want generics, but they don’t want to bother implementing it properly, so it remains a special case for a few things in the compiler.</p><p>但是Go确实有针对内置类型的泛型。数组、通道、贴图和切片都有泛型类型参数。因此，Go开发人员似乎想要泛型，但他们不想费心正确地实现它，因此它仍然是编译器中一些东西的特例。</p><p> The way in Go to handle possibly-failing functions is to have multiple return values: an actual result, and an error. If the error is  nil, then the actual result is sensible; otherwise the actual result is meaningless.</p><p>在GO中处理可能失败的函数的方法是有多个返回值：实际结果和错误。如果误差为零，则实际结果是合理的；否则，实际结果是没有意义的。</p><p> This means you can forget to check the error and use a bogus result and, because there are no compiler warnings (another wtf), you will know nothing of this until things fail at runtime.</p><p>这意味着您可以忘记检查错误并使用假结果，而且因为没有编译器警告(另一个wtf)，所以在运行时失败之前，您将对此一无所知。</p><p> It is very nice to know, just by looking at the type of a function, that it  cannot perform any side-effects. Go’s type system doesn’t do that.</p><p>仅仅通过查看函数的类型，就可以知道它不能执行任何副作用，这是非常好的。围棋的类型系统不能做到这一点。</p><p>  Haskell gets a lot of criticism for bad tooling, but I think it’s worlds ahead of Go in some cases.</p><p>Haskell因为糟糕的工具而受到很多批评，但我认为在某些情况下这是遥不可及的。</p><p> Godoc groups bindings by type, and then sorts alphabetically. Code is not written like that, code is written with related functions in proximity to each other. The source order is  almost always better than how godoc sorts things.</p><p>Godoc按类型对绑定进行分组，然后按字母顺序排序。代码不是这样写的，代码是用彼此接近的相关函数编写的。源顺序几乎总是比godoc对事物进行排序的方式要好。</p><p>  Previous proposals similar to this have been rejected on grounds that it’s a slippery slope from this to Markdown or worse.</p><p>之前类似的提议都被拒绝了，理由是从这里到降价或更糟的情况很糟糕。</p><p> I think that comment is particularly discouraging. Because the developers don’t like Markdown (and similar languages), they refuse to add even the most basic of formatting to godoc.</p><p>我认为这一评论特别令人沮丧。因为开发人员不喜欢Markdown(以及类似的语言)，他们甚至拒绝向godoc添加最基本的格式。</p><p> Go has a snapshot-based memory profiler. You can take a snapshot at a point in time, and see which functions and types are taking up the heap space. However, there is  nothing like this.</p><p>Go有一个基于快照的内存分析器。您可以在某个时间点拍摄快照，并查看哪些函数和类型占用了堆空间。然而，没有这样的事情。</p><p> Being able to see not only a snapshot, but also how things have changed over time, is incredibly useful for spotting memory leaks. If all you have is a snapshot, all you can really say is “well, the number of allocated  Foos looks a bit high, is that right?” With a graph you can say “the number of allocated  Foos is increasing when it shouldn’t be.”</p><p>不仅可以看到快照，还可以看到事情随着时间的推移发生了怎样的变化，这对于发现内存泄漏非常有用。如果您所拥有的只是一个快照，那么您真正能说的就是“嗯，分配的Foo的数量看起来有点高，对吗？”通过图表，您可以说“分配的foo数量正在增加，而不应该是这样。”</p><p> ThreadScope is a tool for profiling performance of concurrent Haskell programs. It shows which Haskell threads are running on which OS threads, when garbage collection happens, and a bunch of other information.</p><p>ThreadScope是一个分析并发Haskell程序性能的工具。它显示了哪些Haskell线程在哪些操作系统线程上运行，垃圾收集何时发生，以及一系列其他信息。</p><p> If things are slower than expected, it’s great: you can see  exactly how things are executing. Go doesn’t  currently have anything like it, although towards the end of Dave Cheney’s  Seven ways to profile Go applications talk at  GolangUK, he did whip out something which looked rather like ThreadScope (sadly, a video isn’t up at the time of writing, that I can see).</p><p>如果事情比预期的慢，那就太好了：您可以确切地看到事情是如何执行的。Go目前还没有类似的功能，尽管在英国GolangUK的Dave Cheney‘s Seven Ways to Profile Go Applications演讲接近尾声时，他确实拿出了一些看起来很像ThreadScope的东西(遗憾的是，在我写这篇文章的时候，还没有上传一段视频，我可以看到)。</p><p>  Go avoids the issue of uninitialised memory by having “zero values”. If you declare a variable of type  int, but don’t give it a value, it gets the value 0. Simple.</p><p>GO通过使用“零值”避免了未初始化内存的问题。如果您声明了一个int类型的变量，但是没有给它赋值，那么它的值就是0。很简单。</p><p>  What is a sensible default value for a type? Well, it depends on what you’re using it for! Sometimes there isn’t a sensible default, and not initialising a value should be an error. You can’t define a zero value for your own types, so you’re kind of stuck.</p><p>什么是类型的合理默认值？嗯，这取决于你用它做什么！有时没有合理的默认值，不初始化值应该是错误的。你不能为你自己的类型定义一个零值，所以你有点卡住了。</p><p> Zero values caused so many problems over the summer, because everything would  appear to be fine, then it suddenly breaks because the zero value wasn’t sensible for its context of use. Perhaps it’s an unrelated change that causes things to break (like a struct getting an extra field).</p><p>零值在整个夏天造成了很多问题，因为一切看起来都很好，然后它突然崩溃了，因为零值对于它的使用环境来说是不明智的。也许是不相关的更改导致了事情的中断(就像结构获得了额外的字段)。</p><p>     Because you have to check error values, if you want to perform a sequence of possibly-erroring computations, where the successful result of one feeds into the next, there is a lot of typing. In Haskell, you’d just use the  Either monad.</p><p>因为您必须检查错误值，所以如果您想要执行一系列可能出错的计算，其中一个计算的成功结果会输入到下一个计算中，则需要大量键入。在Haskell中，您只需使用任一Monad。</p><p> If you want to sort a slice, because there are no generics, you need to wrap the slice in another type and implement three methods on that type. So that’s four lines of code to sort a slice of uints, four lines to sort a slice of uint8s, four lines to sort a slice of uint16s, and so on. In Haskell, you’d just use the generic  sort.</p><p>如果因为没有泛型而要对切片进行排序，则需要将切片包装在另一个类型中，并在该类型上实现三个方法。这是对一片uint进行排序的四行代码，对一片uint8进行排序的四行代码，对一段uint16进行排序的四行代码，依此类推。在Haskell中，您只需使用泛型排序。</p><p>  I do have one  non-Pusher Go project that I plan to keep developing, as it’s a fun project. I picked Go for it because my initial motivation was to eventually integrate it with what I was doing at work, but that ended up not happening.</p><p>我确实有一个非推手围棋项目，我计划继续发展，因为它是一个有趣的项目。我选择了Go，因为我最初的动机是最终将它与我在工作中所做的事情结合起来，但最终没有实现。</p><p> Other than that, I will probably never choose to use Go for anything ever again, unless I’m being paid for it. Go is just too different to how I think: when I approach a programming problem, I first think about the types and abstractions that will be useful; I think about statically enforcing behaviour; and I don’t worry about the cost of intermediary data structures, because that price is almost never paid in full.</p><p>除此之外，我可能再也不会选择使用Go做任何事情了，除非我为此得到了报酬。GO与我的思考方式完全不同：当我处理编程问题时，我首先考虑的是有用的类型和抽象；我考虑的是静态强制行为；我不担心中间数据结构的成本，因为这个代价几乎从未完全支付过。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://memo.barrucadu.co.uk/three-months-of-go.html">https://memo.barrucadu.co.uk/three-months-of-go.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/行程/">#行程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/haskeller/">#haskeller</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>