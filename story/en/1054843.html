<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>设计编程语言（2015） Designing a Programming Language (2015)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Designing a Programming Language (2015)<br/>设计编程语言（2015） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-28 13:28:44</div><div class="page_narrow text-break page_content"><p>Programming languages come in a variety of different paradigms. Even so, there tend to be two main camps along the language front. There are static languages and there are dynamic languages. To avoid too much history and any sort ofin-depth analysis, this article will simplify things with a number of assumptions. One assumption we will make which might not always hold true is that programs written in static languages are compiled to machine code, while programs that are written in dynamic languages run in an interpreter.</p><p>编程语言来自各种不同的范式。即便如此，往往有两个主要阵营语言前面。有静态语言，有动态语言。避免太多的历史和任何类型的历史深入分析，本文将简化具有许多假设的东西。我们将假设我们将制作可能并不总是保持真实是以静态语言编写的程序编译为机器代码，而以动态语言编写的程序在解释器中运行。</p><p>  Testing the definitions of what makes a language static or dynamic might illustrate this more. In a static language,variables and procedures have rigidly defined types. Attempting to access a value that has not been named in arelevant scope leads to a syntax error issued at compile time. The programming language is organized in such a waythat, when it is analyzed at a source level, the locations of all variables and functions are known by lexicaladdress: i.e. given the relevant scope, a variable can be identified by the order it is defined in.</p><p>  测试语言静态或动态的定义可以更多地说明这一点。用静态语言，变量和过程具有顽固的类型。尝试访问尚未命名的值相关范围导致编译时发出的语法错误。编程语言以这样的方式组织即，在源电平分析它时，所有变量和函数的位置是由词汇知识的地址：即给定相关范围，可以通过定义的顺序来识别变量。</p><p>      This would be the prototype for a static language. When variables are first declared, they must be paired with atype. In order to compare with a dynamically typed language, let&#39;s look at an example from Python.</p><p>      这将是静态语言的原型。当首次声明变量时，它们必须与a配对类型。为了与动态类型的语言进行比较，让＆＃39;查看Python的示例。</p><p>    In this example, no types are declared for these variables. The variable &#39;num1&#39; could be used as any type byassigning any value to it. Additionally, the declaration step is wholly unnecessary. The way that values are storedincludes type information, so declarations are only needed when declaring scope.</p><p>    在此示例中，未对这些变量声明类型。变量＆＃39; num1＆＃39;可以用作任何类型为其分配任何值。此外，声明步骤完全不必要。存储值的方式包括类型信息，因此仅在声明范围时才需要声明。</p><p>  Additional examples of dynamically typed languages besides Python include JavaScript, Ruby, Lua, Clojure, Scheme and Lisp, and a number of others. Aside from the style of syntax and the degree of expressiveness, these programming languagesare largely similar because of their type system. So called dynamically typed languages are sometimes referred to as duck-typed or duck languages.</p><p>  除了Python之外的动态类型语言的其他例子包括JavaScript，Ruby，Lua，Clojure，Scheme和Lisp，以及其他一些。除了语法和表达程度之外，这些编程语言由于它们的类型系统而言，在很大程度上。所以称为动态类型的语言有时被称为鸭子类型或鸭语言。</p><p>  Adopting many of these identifying features, and really as an exercise in constructing a language from basic parts,we will build the  Duck programming language from the ground up. We will explore this process without regard to its pragmatism or practicality. Indeed, any ideas of utility will come only after we have completed the process.</p><p>  采用许多这些识别功能，并且真的作为构建来自基本零件的语言的练习，我们将从地上建造鸭子编程语言。我们将探讨此过程而不考虑其务实或实用性。实际上，在我们完成了这个过程后，才会出现任何效用的想法。</p><p>  As a fair warning, I feel I should mention that the upcoming sections may contain some complex material, even thoughit is presented plainly and simply wherever it can be. For that reason, I would recommend the reader do some researchon the topic of programming language design before embarking on this journey. With that said, we are on our way.</p><p>  作为公平的警告，我觉得我应该提到即将到来的部分可能包含一些复杂的材料，即使是它是明白的，无论何处都是如此。因此，我会推荐读者做一些研究论踏上这一旅程之前编程语言设计的主题。有了那么说，我们正在路上。 </p><p>    At this point it might be easy to scrabble together a document of syntactic expressions, beginner how-to tutorials,Wikis, or grammar guides as an explanation of the language and drop the topic altogether, moving on to moreproductive tasks. Sometimes it seems like the design of a language, down to its true grammar, is something more forliner-notes on a reference manual than something that exists that has been written, crafted, or changed over time.The purpose of this explanation is not to suggest that your programming language should be chiselled into stone andthat that is how great concepts come to fruition. Instead, true to the nature of our task, we will at every step ofthe way look at how things can be changed, expanded, and made to evolve over time. What might be suitable for onetask is not the solution to every problem, and having a way to change things or reuse our efforts is always good.</p><p>此时，它可能很容易拼接在一起句法表达式的文档，初学者如何进行教程，Wiki，或语法指南作为语言的解释，并完全放弃主题，继续前进生产任务。有时它似乎是一种语言的设计，到它的真正的语法，是更多的东西关于参考手册的衬垫笔记而不是存在的东西，这些内容随着时间的推移编写，制作或改变。这种解释的目的不是表明你的编程语言应该被凿成石头和这就是概念如何实现的。相反，忠于我们任务的性质，我们将在每一步看看如何改变，扩展的方式，并随着时间的推移而发展。什么可能适合一个任务不是每个问题的解决方案，并有一种方法来改变事物或重用我们的努力总是很好。</p><p>  With that in mind, we will sort of gloss over what the fundamental mechanics of the  Duck language are at the atomiclevel. Instead, we will explore what the essence is. We want to discover the intention of the language itself.If we can get into the mind, the feng-shui, or the essential attitudes of the programming language, that would beenough. Still, programming languages are systems that we use to express ideas. And for any manner of communication tobe useful, we need to have some common ground.</p><p>  考虑到这一点，我们将对鸭子语言的基本机制处于原子的基本机制的光泽等级。相反，我们将探讨本质是什么。我们希望发现语言本身的意图。如果我们能够进入心灵，风水，或方案语言的基本态度，那将是足够的。尽管如此，编程语言是我们用来表达想法的系统。以及任何通信方式有用，我们需要有一些共同的地面。</p><p>  We will create a language that is very neutral to the background of the programmer. We will also work in animperative style. Although certain ideas of functional nature may seep through eventually, we are trying to build thebasic language for the common programmer.</p><p>  我们将创建一种对程序员背景非常中性的语言。我们也将在一个势在必行的风格。虽然某些功能性质的想法可能会在最终渗透，但我们正试图建立公共程序员的基本语言。</p><p>  To find a root concept we can work from, let&#39;s begin with statements. There are statements that form operations.Given two values, add them together and assign the result. If an expression is true, execute a block of statements.Evaluate expressions and then make a procedure call with arguments. Etcetera. A block of statements will be describedin terms of a statement list. Given a function declaration, a kind of statement, there is a name for the function, alist of parameter names, and a list of statements making up the body. An If/Else statement has a similar nature. Itis a statement that contains additional statements.</p><p>  找到我们可以从中工作的根概念，让＆＃39; s从语句开始。有表明操作的陈述。给定两个值，将它们添加在一起并分配结果。如果表达式为真，请执行一块语句。评估表达式，然后使用参数进行过程调用。等等。将描述陈述块就声明列表而言。鉴于函数声明，一种语句，函数有一个名称，a参数名称列表，以及构成正文的语句列表。如果/ else语句具有类似的性质。它是包含其他陈述的陈述。</p><p>  To provide a little bit of framework to work from, let&#39;s write down what some of these ideas might look like.</p><p>  提供一点点框架来从，写下一些这些想法可能看起来像的东西。</p><p>    This is what our basic if statement looks like. Considering that we will often want to execute statements if ourcondition is false, we better add support for else statements, too.</p><p>    这就是我们的基本情况，如果语句看起来像。考虑到我们经常想要执行陈述条件是假的，我们也更好地为别人的陈述添加支持。</p><p>  if some condition then ; here is a block of statements ; to run if the condition is trueelse ; here is a block of statements ; to run if the condition is falseend</p><p>  如果某些条件那么 ;这是一块陈述 ;如果条件为真，则运行别的 ;这是一块陈述 ;如果条件为假结尾 </p><p>  Looking at the syntax we have, we seem to have borrowed the end-block notation from Lua. I guess this is justcoincidental. We could just as easily have styled our language after BASIC and terminated IF statements with ENDIFrather than simply the keyword  end. I don&#39;t have any real justification for this.</p><p>看着我们所拥有的语法，我们似乎已经借用了Lua的结束块。我想这只是巧合。在基本并终止与结束时的陈述之后，我们可以轻松调整我们的语言而不是简单地关键字结束。我没有对此有任何真正的理由。</p><p>  What I would justify, however, is the use of real words in syntax. I think this is plainer and more easily readableor simpler to understand than using a large amount of syntactic symbols to delineate blocks and other controlstructures. So wherever we can, we will use whole words in our language&#39;s grammar.</p><p>  但是，我将证明是在语法中使用真实单词。我认为这是平淡的，更容易可读或者比使用大量的句法符号更简单到描绘块和其他控制结构。所以无论我们在哪里，我们都会在我们的语言中使用整个单词。</p><p>  As before we introduced the idea of a function definition, or a function declaration, let&#39;s jot down what that lookslike.</p><p>  就像我们在我们介绍了函数定义的想法或函数声明之前，让＆＃39;在那个看起来的东西喜欢。</p><p>  function our_new_function(parameter1, parameters2) ; here we have statements that do work ; if this function returns a value then we might have return ourResult ; at the endend</p><p>  函数us_new_function（参数1，parameter2） ;在这里，我们有工作的陈述 ;如果此函数返回值，那么我们可能会有 返回OuRSult. ;在末尾结尾</p><p>  We won&#39;t put any limitations on the placement of these. Functions can be defined inside of functions. In this casethey will be local to where they are defined. We don&#39;t want to introduce limitations when forming our definitionsfrom the start, because they might be based on expectations that aren&#39;t true. If the limitations we impose onourselves are artificial, then we will be putting time and effort into enforcing artificial limitations, and thatbecomes wasted effort. On functions, the use of  end as a keyword seems more justifiable, as it is much shorterthan  end function. A good middle-ground might be  endf. This depends on if we want to allow END to be aspecific command that terminates the running program. I always thought this might be a useful instruction, but it&#39;snot often included in languages. Instead, we might have a system command for quit() that we can invoke from ourprogram.</p><p>  我们赢得了对这些的局限性的任何限制。可以在功能内定义函数。在这种情况下他们将在定位的地方本地。我们不想在形成我们的定义时介绍局限性从一开始，因为它们可能是基于aren＆＃39; t true的期望。如果我们强加的限制我们自己是人为的，那么我们将使时间和努力实施人工局限性，而且变得浪费了努力。在函数上，使用结束作为关键字似乎更加合理，因为它更短而不是结束功能。一个良好的中间地面可能是Endf。这取决于我们是否希望结束成为一个终止运行程序的特定命令。我一直认为这可能是一个有用的指导，但它＆＃39; s通常不包括在语言中。相反，我们可能有一个可以从我们的quit（）的系统命令程序。</p><p>  Our language must have some common ground with existing languages, so we will use familiar constructs like for loopsand while loops. For loops will use ranges in an explicit way. There will be a beginning value and ending value, andthe loop body will be executed for both of these and every value in between. This is assuming we are starting withintegers, or possibly floating-point numbers, but always increasing by increments of one.</p><p>  我们的语言必须具有现有语言的一些共同点，所以我们将使用熟悉的构造等循环而循环。对于循环将以明确的方式使用范围。将有一个开始值和终点值，而且将为它们两者和每个值执行循环体。这是假设我们从中开始整数，或可能浮点数，但总是通过一个增量增加。</p><p>    for j = 1 to 100 do ; this prints the numbers 1 through 100 println(j)loop</p><p>    对于j = 1到100做 ;这打印了数字1到100 println（j）环形 </p><p>      We will allow all of the basic operations we have come to expect. Namely addition, subtraction, multiplication, anddivision, as well as modulo division (something we could implement ourselves), string concatenation for convenience,negation, not, and Boolean expressions. These are the fundamentals.</p><p>我们将允许我们预期的所有基本操作。即添加，减法，乘法和师，以及模数（我们可以实现自己的东西），为方便起见，串联串联，否定，而不是和布尔表达式。这些是基本面。</p><p>  We are trying to accomplish creating the most flexible and programmable language, so we must also think ofdistinctly dynamic elements that we can add. Arrays are fundamentally useful. Let&#39;s add arrays that allow the use ofany index, without specifying a container size. Let&#39;s expand this array functionality to allow for values of any typeto be used as indices. Furthermore, let&#39;s create dictionary types with a familiar object notation. These will besimilar to classes or structs from related languages. To increase flexibility, these will be the same objectinternally as arrays, and the syntax for each can be used interchangeably.</p><p>  我们正试图完成创造最灵活和最可编程的语言，所以我们还必须想到我们可以添加的明显动态元素。阵列从根本上很有用。让＆＃39;允许使用的阵列任何索引，无需指定容器大小。让＆＃39展开此数组功能以允许任何类型的值用作索引。此外，使用熟悉的对象表示法创建字典类型。这些将是类似于相关语言的类或结构。为了提高灵活性，这些将是相同的对象内部作为阵列，并且每个互换的语法可互换使用。</p><p>  arr1 = [] arr2 = [1, 2, 3, 4] dict2 = {firstArray: arr1, secondArray: arr2} dict1 = {&#34;a&#34;: 1, &#34;b&#34;: 2, &#34;c&#34;: 3} arr2[4] = 5 dict2.arr2[5] = 6 dict1.d = 4</p><p>  arr1 = [] ARR2 = [1,2,3,4] dict2 = {firstarray：arr1，secondarray：arr2} dict1 = {＆＃34; a＆＃34 ;: 1，＆＃34; b＆＃34 ;: 2，＆＃34; c＆＃34 ;: 3} ARR2 [4] = 5 dict2.arr2 [5] = 6 dict1.d = 4.</p><p>    Another feature that increases our flexibility is allowing functions to be first-class objects. This means that wecan use functions as parameters, return them as values, and assign them to named variables. We can rename a functionand use the original name for something else. We can attach functions to objects and use them as classes. Althoughpassing functions as first-class objects is a functional idea, here it overlaps with the ideas of dynamic languagesso we will adopt this feature. In order to keep track of objects and complex types, it makes sense to implementmemory management through garbage collection, instead of passing that large responsibility on to the programmeradapting to use our language.</p><p>    提高灵活性的另一个功能允许函数成为一流的对象。这意味着我们可以使用函数作为参数，将它们作为值返回，并将它们分配给命名变量。我们可以重命名一个函数并使用原始名称进行其他内容。我们可以将函数附加到对象并将其用作类。虽然传递函数作为一流的对象是一个功能的想法，这里它与动态语言的想法重叠所以我们将采用此功能。为了跟踪对象和复杂类型，实现有意义内存管理通过垃圾收集，而不是将大责任传递给程序员适应使用我们的语言。</p><p>      A casual reader following along might not be interested in developing their own language, as of this moment. Theymight be more interested in the mechanics involved. As a rather elaborate exercise, I invite anyone to attempt tocreate their own interpreted programming language. That being said, I am about to outline the processand tools that I used to create the  Duck programming language, even though I recognize there are multiple ways togo about the process.</p><p>      截至目前，可能对休闲读者可能不会有兴趣开发自己的语言。他们可能对所涉及的力学更感兴趣。作为一个相当精致的练习，我邀请任何人试图创建自己的解释编程语言。所说，我即将概述这个过程我曾经创建鸭子编程语言的工具，即使我识别出多种方式走这个过程。</p><p>  For example, I chose to write everything in the C programming language. This is really a more difficult task than ithas to be, but I will explain my decision further on. It might be easier for a developer to go about creating alanguage with any other environment. A truly dedicated engineer might have already targeted a platform and decided tostart from the get-go with handwritten assembly language. This is not a very portable solution. Another endeavoringdeveloper might start with a modern language like Java or C#. These are great choices and I would encourage pickingup whatever tools you are familiar with. For reasons that may or may not be obvious, I would recommend fashioningthis dynamic language we are creating in a static host environment. So, a language like Go would be preferred toScheme. I know that a number of courses teach programming languages by implementing a Scheme or Lisp interpreter.What we are doing is not far off from that except for large differences in style and syntax. And usually thesecourses require writing the language interpreter in the language itself, or involve a similar kind of task. Thereason I would recommend staying away from this course is because it begins to lead to deliberately impracticalsolutions. The performance you can get from a self-hosted environment is really only half-way there, and any of thebenefits of the solution we are creating tend to get taken away. Forging special frontends for a language can be veryuseful, and there are ways to improve productivity and performance by creating a special dialect, but what we aregoing for is an entirely new language.</p><p>  例如，我选择在C编程语言中写一切。这真的比它更艰巨必须是，但我会进一步解释我的决定。开发人员可能更容易创建一个任何其他环境的语言。一个真正专用的工程师可能已经针对平台并决定从get-go与手写汇编语言开始。这不是一个非常便携的解决方案。另一个努力开发人员可能从像Java或C＃这样的现代语言开始。这些是伟大的选择，我会鼓励采摘无论您熟悉的任何工具。出于可能或可能不明显的原因，我建议塑造时尚我们在静态主机环境中创建的这种动态语言。所以，一种像这样的语言将是彼此之一方案。我知道许多课程通过实施方案或LISP解释器来教导编程语言。除了风格和语法的巨大差异，我们所做的就是没有遥远。通常这些课程要求在语言本身中写语言解释器，或涉及类似的任务。这我建议远离本课程的原因是因为它开始刻意不切实际解决方案。您可以从自主托管环境中获得的性能实际上只有在那里的一半，以及任何一个我们正在创造的解决方案的好处往往被带走。用于语言的特殊前端可以非常有用，有些方法可以通过创建一个特殊方言来提高生产力和性能，但我们是什么去是一种完全新的语言。</p><p>  I will note that there is one way that implementing this dynamic language in an interpreted or scripting languagemight be helpful, and that would be in the case of cross-compiling. I.e. having our  Duck code reduced to some otherlanguage, like JavaScript or Python, before being executed. That would be fine but then we are dealing with code compiling and other complexities which are best addressed in section II of this series.</p><p>  我会注意到，以解释或脚本语言实现这种动态语言有一种方法可能会有所帮助，这将在交叉编译的情况下。 IE。让我们的鸭代码减少到其他一些在被执行之前，语言如JavaScript或Python。那没关系，但我们正在处理代码编译和其他复杂性最佳地解决了本系列第II节。 </p><p>    It is portable. A program written in C can be deployed on virtually any operating system. It is easy tocompile for any device and can be executed on almost any microprocessor. Especially when this code is written withthe standards in mind. I would also choose to avoid any new features in the language to maximize compatibility.</p><p>它是便携式的。在几乎任何操作系统上都可以部署在C中编写的程序。它很容易编译任何设备，可以在几乎任何微处理器上执行。尤其是当此代码写入时思想的标准。我还会选择避免语言中的任何新功能，以最大限度地提高兼容性。</p><p>  It is low-level. Without delving into assembly and machine code itself, C represents a close barrier to the targetmachine itself. Not knowing what CPU our code will execute on or the exact layout of registers, we want to be awareof what sort of instructions will be executed and how our program will be laid out in memory.</p><p>  它是低级别的。在不漂亮进入装配和机器代码本身，C代表了目标的近距离机器本身。不知道CPU我们的代码将在寄存器上执行或确切的寄存器布局，我们想知道将执行哪些指令以及我们的程序将如何在内存中奠定。</p><p>  It is not garbage collected. While this point can be debated, the purpose of this project is in ways to createsomething new. So, creating a new language with higher level features, it is easier to feel a sense of accomplishmentwhen we are working on features we didn&#39;t have from the start. This also helps us to have control over the runtimefor our final interpreter, as we are being dealt the responsibility of memory management ourselves.</p><p>  它不是收集的垃圾。虽然这一点可以辩论，但这个项目的目的是以创造的方式新鲜玩意。因此，创建具有更高级别功能的新语言，更容易感受成就感当我们正在研究功能时，我们并从一开始就没有。这也有助于我们控制运行时对于我们的最终口译员，我们正在为自己处理内存管理的责任而。</p><p>  It&#39;s difficult. This hardly qualifies as a reason. I would say that one reason would be &#39; because it is fast,&#39; butknowing how the process of writing has gone, it is neither fast to implement nor necessarily the fastest resultingcode. But true to form, this exercise will be a challenge, so it might as well be a good one.</p><p>  它＆＃39很难。这几乎没有资格作为一个原因。我会说一个原因会是＆＃39;因为它很快，＆＃39;但了解写作过程已经消失，它既不快速实施，也不一定是最快的结果代码。但是，形成这种练习将是一个挑战，所以它也可能是一个好的。</p><p>  Now this doesn&#39;t particularly qualify as a language concern, but as an additional challenge, the project is beingbuilt from the ground-up, in a pulled-up-by-its-own-bootstraps kind of way. That means, as you see the parts ofdevelopment around the parser and lexer coming together, two fundamental components of a language, these will all behand-fashioned parts and tools. The inner workings of the parser generator will be explained. This completelyoverlooks any debates that might be had about tools to use like Bison, Flex, Yacc, or Lex. A number of tools that Iknow very little about.</p><p>  现在，这一并非特别有资格作为一种语言关注，而是作为一个额外的挑战，该项目是存在的从上面建造的，以逐步的自身引导的方式构建。这意味着，如您所见的那样在解析器和Lexer周围的发展融合在一起，两个语言的基本组成部分，这些都将是手工造成的零件和工具。将解释解析器发生器的内部工作。这完全忽略可能有关于使用野牛，Flex，YACC或Lex的工具的任何辩论。我的许多工具很少了解。</p><p>  We are also working from our own frontend and our own backend. That means we aren&#39;t plugging into LLVM or tying inwith Clang or anything like that. We are using an ANSI compiler with a CMake script.</p><p>  我们也从我们自己的前端和我们自己的后端工作。这意味着我们aren＆＃39; t插入llvm或捆绑用克兰或类似的东西。我们正在使用具有CMake脚本的ANSI编译器。</p><p>  If you yourself are developing something in parallel with this project or on your own, I would recommend using all ofthese great tools and resources, which would speed-up your journey significantly and you could be done with yourproject before you finish reading this guide.</p><p>  如果你自己正在与这个项目和自己的项目并行开发一些东西，我会建议使用所有这些伟大的工具和资源，它将显着加速您的旅程，您可以与您的方式完成在完成读取本指南之前的项目。 </p><p>  Even considering our target platform and the technical specs we are about to jump through, there will be very littleactual code provided or directly cited. There may be resources attached, but, in general things will be outlined froman algorithmic approach or described in pseudo-code. There is no reason to go about annotations on a line by linebasis.</p><p>即使考虑到我们的目标平台和我们即将跳过的技术规格，也会很少提供或直接引用的实际代码。可能附加资源，但是，一般情况下，将概述算法方法或在伪代码中描述。逐行上没有理由进行注释基础。</p><p>    The goal of the lexer is to take a target source file and create a stream of lexemes which we will call lexer tokens.Internally, we will represent these as a linked list of elements, each of which tracks an integer identifying whatkind of token it is (symbol, keyword, or identifier as examples), the raw source string and its length, and the linenumber the token appears on in the source file.</p><p>    Lexer的目标是拍摄目标源文件并创建一个我们将调用Lexer令牌的lexemes流。在内部，我们将表示为链接的元素列表，每个元素都跟踪识别内容的整数令牌的种类是（符号，关键字或标识符为示例），原始源字符串及其长度以及行令牌在源文件中显示令牌。</p><p>  Upon taking a source file as input, the lexer will create a new buffer and remove redundant whitespace, single linecomments, and multi-line comments. Successive whitespace characters will be replaced with a single space, unless thatstream includes a newline, in which case a newline will be used. This process is used to &#39; strip clean&#39; the sourcefile until we are dealing with program source directly. Now we will work character by character to isolate andidentify the tokens that make up  Duck source code.</p><p>  将源文件置于输入时，Lexer将创建一个新的缓冲区并删除冗余空格，单行评论和多线评论。连续的空格字符将用一个空间替换，除非Stream包括换行符，在这种情况下，将使用换行符。这个过程用于＆＃39;条带清洁＆＃39;来源在我们直接处理程序源之前的文件。现在，我们将以字符为孤立和孤立的人物识别构成鸭源代码的令牌。</p><p>  At this point, we already have tables of keywords and symbols to begin with, and if we don&#39;t, it is something that wewill generate in one of the next steps that we can save and store for use in the lexer. In any case, we can list offall of the keywords and symbols that we would like to use for our programming language. In this case those keywordsare:</p><p>  在这一点上，我们已经有关键字和符号表开始，如果我们不和谐，这是我们的将生成一个我们可以保存并存储在Lexer中的下一步骤中的一个。无论如何，我们可以列出我们想要用于我们的编程语言的所有关键字和符号。在这种情况下，这些关键字是：</p><p>  import, include, return, break, continue, throw, function, end, if, then, else, for, to, do, loop, step, in, while,let, begin, try, complete, catch, object, static, operator, this, and, or, not, is, mod, new, true, false</p><p>  导入，包括，返回，休息，继续，抛出，函数，结束，如果，否则，否则，do，do，do，循环，步骤，in，让，开始，尝试，填写，捕获，对象，静态，运算符，这，以及，或者，不是，是，新的，true，false</p><p>  Some of these include keywords for features we haven&#39;t discussed implementing. This is fine, we can use them asreserved words while we contemplate the additions we can make to the language down the road.</p><p>  其中一些包括我们尚未讨论实施的特征的关键字。这很好，我们可以用它们保留言语，同时我们考虑添加的添加我们可以在路上的语言。</p><p>  Our lexer will begin by looking at the next input character. Here at the start, we will look at the first non-commented out character in our source file&#39;s source text. It may be a letter, a number, another type of glyphlike parentheses or a plus-sign, a whitespace character, or a newline character. If it is a whitespace character wecan ignore it. At this point, we are only using whitespace as a delimiter. It marks a boundary between tokens thatmust be separated, like keywords and identifier names. Not all tokens will be divided by whitespace, as it ispossible for certain characters to follow each other that form different tokens.</p><p>  我们的Lexer将首先查看下一个输入字符。在这里开始，我们会看看第一个我们的源文件中的非评论字符＆＃39; s源文本。它可能是一封信，一个数字，另一种类型的字形像括号或加号，空白字符或换行符。如果它是我们的空白字符可以忽略它。此时，我们只使用空格作为分隔符。它标志着令牌之间的边界必须分开，如关键字和标识符名称。并非所有代币都将被空格除以某些字符可能遵循彼此形成不同的标记。 </p><p>  Let&#39;s assume that we encounter a character from the alphabet. Then we could be looking at an identifier (something weuse in the program to label a variable, procedure, or field) or a keyword. Following the conventions for naming identifiers in our language, we will allow anything that starts with a letter and continues with any combination of letters, numbers, or underscores to name a variable. So we will continue scanning until we reach a character thatdoes not match or until we reach the end of the input; At this point we will either add an identifier or a keyword toour list of lexemes. We will have to check our list of keywords to see if this identifier is in fact a keyword. Inthat case, our lexer emits a &#39;token&#39; instead and finds the right token constant for this keyword, here its index inour list. Otherwise, we add an identifier token to the lexemes and attach the string literal for the identifier.</p><p>让＆＃39假设我们遇到字母表中的一个字符。然后我们可以看一个标识符（我们的东西在程序中使用以标记变量，过程或字段）或关键字。遵循命名的约定我们语言中的标识符，我们将允许任何以字母开头的东西并继续使用任何组合字母，数字或下划线命名变量。所以我们将继续扫描，直到我们达到一个角色不匹配或直到我们到达输入结束;此时，我们将添加标识符或关键字我们的lexemes列表。我们必须检查我们的关键字列表以查看此标识符是否实际上是关键字。在这种情况，我们的Lexer发出了A＆＃39;令牌＆＃39;相反，找到此关键字的正确令牌常量，其索引我们的名单。否则，我们向Lexemes添加标识符令牌并附上标识符的字符串文字。</p><p>  If we encounter a number, we will continue while we see numbers or decimal points until we see another character or reach the end of the input. If this sequence contains a decimal point, then we will assume this is a real number or afloating-point constant. Otherwise, we will interpret this number as an integer. We add a token for either an integeror a float to our lexer tokens and include the literal string for the sequence to use when we need access to thatvalue.</p><p>  如果我们遇到一个数字，我们将继续在我们看到数字或小数点之前继续，直到我们看到另一个角色或到达输入结束。如果此序列包含小数点，那么我们将假设这是一个实数或者浮点常数。否则，我们将作为整数将此数字解释。我们为整数添加一个令牌或者漂浮到我们的Lexer标记，并包括当我们需要访问该时序列的文字字符串价值。</p><p>  If we hit a symbol glyph, which we will use to unambiguously refer to characters that are not alphanumeric,whitespace, or newlines, then we will find the longest sequence of glyphs that correctly match a preset collection oftokens and add that token to our list of tokens. When I talk about a preset collection of tokens, I refer to thefollowing set, which we will be generating soon in the next step.</p><p>  如果我们达到符号字形，我们将用来明确地指的是不是字母数字的字符，WhiteSpace或Newlines，那么我们将找到正确匹配预设集合的最长序列令牌并将该令牌添加到我们的令牌列表中。当我谈论预设的令牌集合时，我指的是遵循集合，我们将在下一步中尽快生成。</p><p>    , = ( ) [ ] + - * / . == != &lt; &gt; &lt;= &gt;= ! { } :</p><p>    ，=（）[] +  -  * /。 ==！=＆lt; ＆gt; ＆lt;＆gt; =！ {}：</p><p>  Noticing that we notably missed quotation marks, we must go back and add strings to the collection of objects that welex, mainly because we do not want to be lexing what&#39;s on the inside of quoted strings, and we certainly don&#39;t wantto be parsing them, either. So if we encounter a glyph that is a string, or specifically if we encounter a characterthat is an opening quotation mark, so either a single or double-quote, then we must scan the input until we find the matching end quotation. We&#39;ll then a</p><p>  注意到我们显着错过了引号，我们必须返回并将字符串添加到我们的集合Lex，主要是因为我们不想在引用字符串的内部举行＆＃39; s＆＃39;我们当然不想要要解析它们。所以，如果我们遇到一个字符串，或者特别是我们遇到一个字符这是一个打开的引号，所以一个或双引用，然后我们必须扫描输入，直到找到输入匹配结束报价。我们＆＃39;然后是一个</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://ducklang.org/designing-a-programming-language-i">http://ducklang.org/designing-a-programming-language-i</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>