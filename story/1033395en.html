<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我犯的令人困惑的grep错误</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我犯的令人困惑的grep错误</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-06 07:15:40</div><div class="page_narrow text-break page_content"><p>In this article, I&#39;ll discuss 5 very confusing mistakes that have caused me to waste significant amounts of time when using the command-line tool known as &#39;grep&#39; to search for things.  I have chosen to document these mistakes in detail because they are mistakes that beginners are very likely to make at some point, but also to know be able to debug on their own. &amp;nsbpThe root causes of these mistakes are:  Not knowing what flavour of regular expression that grep is currently using (and/or not understanding what features that flavour supports); Not considering the escaping rules of your shell; Issues with character encodings.</p><p>在本文中，我将讨论5个非常令人困惑的错误，这些错误导致我在使用命令行工具(即grep；)搜索内容时浪费了大量时间。我之所以选择详细记录这些错误，是因为它们是初学者在某个时候很可能会犯的错误，也是为了知道能够自己调试。&amp；nsbp这些错误的根本原因是：不知道grep当前使用的正则表达式的风格(和/或不了解该风格支持什么功能)；没有考虑外壳的转义规则；字符编码问题。</p><p>  Here is a file containing a few lines of text that we&#39;ll place inside the file &#39;hello.txt&#39;:</p><p>下面是一个包含几行文本的文件，我们将把它们放在文件hello.txt&#39；中：</p><p>   Let&#39;s say that you wanted to use the &#39;grep&#39; command to find all lines in this file that contain the word &#39;Hello&#39; followed by the word &#39;World&#39;.  You could use a grep command like this:</p><p>假设您想要使用grep&39；命令查找该文件中包含单词##39；Hello；和单词##39；World；的所有行。*您可以使用如下grep命令：</p><p>   and as you expect, this grep command found all of the matches that you expect:</p><p>正如您所期望的那样，此grep命令找到了您期望的所有匹配项：</p><p>   But now you might consider adding the additional requirement that there be at least one character between &#39;Hello&#39; and &#39;World&#39; so that the line with &#39;HelloWorld&#39; is not included in the matches.  Since you know that &#39;*&#39; is a regex pattern for &#39;zero or more&#39; and &#39;+&#39; is a regex pattern for &#39;oen or more&#39;, you decide to try the following:</p><p>但现在您可以考虑添加一个附加要求，即在Hello和World之间至少要有一个字符，这样包含HelloWorld的行就不会包含在匹配项中。因为您知道&#39；*&是零个或多个的正则表达式模式，而&#39；*是一个或多个&#39；的正则表达式模式，所以您决定尝试以下操作：</p><p>   But this doesn&#39;t match anything at all!  What&#39;s going on here?  Isn&#39;t &#39;+&#39; a regular expression symbol for &#39;one or more&#39;?  The answer is related to the default regular expression mode that grep uses.  If you don&#39;t specify any flags to grep, it will use &#39;BRE&#39; or &#39;Basic Regular Expressions&#39; which are very old and quite primitive.  In fact, the official  standard for BRE doesn&#39;t even support the &#39;+&#39; quantifier!  This can lead to very confusing behaviour since you might just try escaping the &#39;+&#39; and find that it gives you the result you expect:</p><p>但这根本不匹配！这是怎么回事？这不是一个代表一个或多个正则表达式的正则表达式符号吗？答案与grep使用的默认正则表达式模式有关。*如果您不为grep指定任何标志，它将使用非常古老且非常原始的基本正则表达式。事实上，BRE的官方标准甚至不支持量词！这可能会导致非常令人困惑的行为，因为你可能只是尝试逃离它，然后发现它会给你带来你所期望的结果：</p><p>      But since we&#39;re still using &#39;BRE&#39; regular expressions, the official standard says that this is actually undefined behaviour!  You can learn more about this in  Undefined Behaviour With Grep -E.</p><p>但由于我们仍在使用正则表达式，官方标准称这实际上是未定义的行为！您可以通过grep-E在未定义的行为中了解更多信息。</p><p>     If you wanted to find all lines in this file that contains the word &#39;date&#39;, you could use this grep command:</p><p>如果要查找该文件中包含单词日期的所有行，可以使用以下grep命令：</p><p>      But now, let&#39;s assume you wanted to use grep to only find the line that contain the backtick characters around the word &#39;date&#39;.  You might try doing the following:</p><p>但现在，让我们假设您想要使用grep只查找单词Date；周围包含反引号字符的行。您可以尝试执行以下操作：</p><p>     grep: Oct: No such file or directory grep:  21: No such file or directory grep:  13: 30: 57: No such file or directory grep: EST: No such file or directory grep:  2020: No such file or directory</p><p>GREP：OCT：没有这样的文件或目录grep：21：没有这样的文件或目录grep：13：30：57：没有这样的文件或目录grep：est：没有这样的文件或目录grep：2020：没有这样的文件或目录。</p><p> You might be thinking, &#34;Oh, no problem, I&#39;ll just use double quotes&#34; and try something like this:</p><p>你可能会想，哦，没问题，我只需要用双引号，然后试试这样的做法：。</p><p>   But that  still doesn&#39;t work (at least not in bash)!  It doesn&#39;t find any matches at all!  The problem in this case is related to the fact that the backtick character has a special meaning in our shell, even when used inside double quotes.  To illustrate this point, we can run the following two echo commands:</p><p>但这仍然不起作用(至少在bash中不起作用)！但它根本找不到任何匹配项！这种情况下的问题与反号字符在我们的Shell中有特殊含义有关，即使用在双引号中也是如此。为了说明这一点，我们可以运行以下两个ECHO命令：</p><p>      So from reading the results above example, you can see why the grep command we last used didn&#39;t find anything: We were literally searching for the current date instead of the word &#39;date&#39; surrounded by backticks!  The solution (in bash shell), is to use single-quotes instead:</p><p>因此，通过阅读上面的示例结果，您可以理解为什么我们上次使用的grep命令没有找到任何结果：我们实际上是在搜索当前日期，而不是用反引号括起来的单词！解决方案(在bash shell中)是使用单引号：</p><p>      This isn&#39;t the only issue that you can encounter where your shell could unexpectedly change the meaning of the search string that you pass into grep.  You can also encounter an issue with  unexpected &#39;globbing&#39; when you attempt to use a regular expression containing the &#39;*&#39; character without using quotes.  For example, consider this simple echo statement that just prints out &#39;asdf&#39;:</p><p>这并不是您可能遇到的唯一问题，您的Shell可能会意外更改传递给grep的搜索字符串的含义。当您尝试在不使用引号的情况下使用包含字符的正则表达式时，也可能会遇到意外的反义字问题。？例如，考虑一下这个简单的ECHO语句，它只打印出以下内容：</p><p>   If you filter this echo statement through a grep search for the character &#39;a&#39; like this:</p><p>如果您通过grep搜索字符过滤此ECHO语句，如下所示：</p><p>   the search will pass the line &#39;asdf&#39; through as expected.  And similarly, if you do a regex search with grep for an &#39;a&#39; followed by any number of other characters like this:</p><p>搜索会如期通过这条线。同样，如果您使用grep进行正则表达式搜索，搜索后跟任意数量的其他字符，如下所示：</p><p>   this will also let the &#39;asdf&#39; through.  However, if you create a new file in the current directory called &#39;a.txt&#39;:</p><p>这也会让这辆车通过。但是，如果您在当前目录中创建一个名为&#39；a.txt&#39；的新文件：</p><p>      What!?  How can creating a new file change how our grep commands run in the shell???  This problem is explained in detail in  this article on shell globbing.</p><p>什么！？？创建一个新文件如何改变我们的grep命令在Shell中运行的方式？这篇关于Shell全局处理的文章详细解释了这个问题。</p><p>  This mistake isn&#39;t specific to grep since it&#39;s really about regular expressions in general, but it&#39;s common enough to include in this article.  Consider a case where you&#39;re trying to use grep to extract all instances of numbers that include a decimal point.  In your search, you&#39;re looking for one or more digits, followed by a period, followed by one or more digits.  You might try writing a grep command like this:</p><p>这个错误并不是grep所特有的，因为它实际上大体上是关于正则表达式的，但它很常见，足以包含在本文中。假设您正在尝试使用grep来提取包含小数点的所有数字实例。在搜索中，您需要查找一个或多个数字，后跟句点，最后是一个或多个数字。您可以尝试编写如下grep命令：</p><p>   which looks like it works just fine because it does match all of the things you do want.  The problem is that is also matches things that you  don&#39;t want:</p><p>它看起来工作得很好，因为它确实符合你想要的所有东西。但问题是，这也与你不想要的东西相匹配：</p><p>   In the above case, our regular expression will match the pattern &#39;234A328&#39; which isn&#39;t a decimal point number.  This case becomes obvious when you point it out, since the &#39;.&#39; character usually represents &#34;any character except for newline&#34; in most regular expressions engines.  In order to match a &#39;literal&#39; period character in a regular expression, you need to escape it:</p><p>在上面的例子中，我们的正则表达式将匹配不是小数点数字的模式&#39；234A328&#39；。当您指出它时，这种情况就会变得显而易见，因为在大多数正则表达式引擎中，字符通常代表除换行符以外的任何字符。*为了匹配正则表达式中的文字句点字符，您需要对其进行转义：</p><p>  # Does not match echo   &#34; 234A328 &#34;  |  grep  -Eo  &#34; [0-9]+ \. [0-9]+ &#34; # Does match echo   &#34; 234.328 &#34;  |  grep  -Eo  &#34; [0-9]+ \. [0-9]+ &#34;</p><p>#与ECHO&#34；234A328&#34；|grep-eo&#34；[0-9]+\不匹配。[0-9]+&#34；#与ECHO&#34；234.328&#34；|grep-eo&#34；[0-9]+\匹配。[0-9]+&#34；</p><p> The lesson is to be careful when using searches that include a &#39;.&#39; character, since it may not always literally mean a period character.</p><p>我们得到的教训是，在使用包含字符的搜索时要小心，因为它可能并不总是字面意思是句点字符。</p><p>  Here is some text that we&#39;ll place inside a file called &#39;animals.txt&#39;.  Take note that the two &#39;columns&#39; in this file are separated with tab (\t) characters:</p><p>下面是我们将放在一个名为Animals.txt；的文件中的一些文本。请注意，此文件中的两列用制表符(\t)分隔：</p><p>   Let&#39;s say that we wanted to write a grep statement to extract the first column from this file.  We could do this quickly and crudely by writing a regular expression that will extract anything up and including the tab character.  Here&#39;s an attempt to do this with the following grep command:</p><p>假设我们想要编写一条grep语句来从该文件中提取第一列。我们可以通过编写一个正则表达式来快速而粗略地实现这一点，该正则表达式将提取所有向上的内容，并包括制表符。以下是使用以下grep命令执行此操作的尝试：</p><p>      The reason is, again, because of grep&#39;s default regular expression mode: BRE or &#39;Basic Regular Expressions&#39;.  However, if we try using the -E flag for &#39;Extended Regular Expressions&#39;, this doesn&#39;t fix the problem:</p><p>原因也是因为Grep的默认正则表达式模式：BRE或基本正则表达式。但是，如果我们尝试对扩展正则表达式使用-E标志，这并不能解决问题：</p><p>      In fact, if you check the  official standard for BRE and ERE, you&#39;ll see that it has no support for matching just a &#39;tab&#39; character!  In POSIX BRE or ERE, there are just a handful of characters that you can escape with a backslash, and they don&#39;t include tab.</p><p>事实上，如果您查看BRE和ERE的官方标准，您会发现它不支持只匹配一个制表符！。在POSIX BRE或ERE中，只有几个字符可以用反斜杠转义，而且它们不包括制表符。</p><p> Confusingly, GNU grep  does support things like &#39;\s&#39; in ERE even though it&#39;s not officially supported by the POSIX standard.</p><p>令人困惑的是，GNU grep确实支持ERE之类的东西，尽管POSIX标准并不正式支持它。</p><p> The solution in our case is to use the -P flag for &#39;Perl-Compatible Regular Expressions&#39;:</p><p>在我们的例子中，解决方案是对与Perl兼容的正则表达式使用-P标志：</p><p>      Unfortunately, the &#39;-P&#39; flag is not supported by all version of grep, so this solution isn&#39;t always available.</p><p>遗憾的是，并非所有版本的grep都支持&#39；-p；标志，因此此解决方案并非始终可用。</p><p>  This issue is one that you won&#39;t encounter every day, but when you do it can be  extremely confusing to figure out what&#39;s going on.  If you ever happen to work with files that are encoded in UTF-16, you&#39;ll have to be mindful of the fact that grep isn&#39;t aware of character encodings, so whatever you grep for will likely only be found if it&#39;s in a character encoding that matches the current encoding of the terminal where you type the grep command.</p><p>这是一个你不会每天都会遇到的问题，但当你遇到这个问题时，你可能会非常困惑，无法弄清楚到底发生了什么。*如果您碰巧使用以UTF-16编码的文件，您必须记住这样一个事实，即grep不知道字符编码，因此，您grep所需的内容可能只有在其字符编码与您键入grep命令的终端的当前编码相匹配的情况下才能被找到。(#xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx。</p><p> For example, imagine that you have two files: the first file encoded in UTF-8 contains this text:</p><p>例如，假设您有两个文件：第一个以UTF-8编码的文件包含以下文本：</p><p>      On my machine, if I do a grep search over both of these files using this grep command:</p><p>在我的机器上，如果我使用以下grep命令对这两个文件执行grep搜索：</p><p>    This fact isn&#39;t too surprising when you know what&#39;s going on, but the difficult part is noticing that you&#39;ve got a file that&#39;s encoded in a different format in the first place.  If you take regular ASCII characters and re-encode them as UTF-16, the file you get will look like regular ASCII encoded text with nulls placed between the characters.  Therefore, if you print the file onto the terminal, the nulls will be ignored and what you see printed will look indistinguishable from regular ASCII text (except for the byte order marker).  Programs like vim will automatically recognize the encoding and display the file as normal text, so you likely won&#39;t notice the encoding.</p><p>当你知道正在发生什么的时候，这一事实并不太令人惊讶，但困难的是注意到你得到的文件一开始就是用不同的格式编码的。如果采用常规ASCII字符并将其重新编码为UTF-16，则得到的文件看起来就像常规ASCII编码文本，在字符之间放置空值。因此，如果您将文件打印到终端上，空值将被忽略，您看到的打印内容将看起来与常规ASCII文本没有区别(字节顺序标记除外)。像vim这样的程序会自动识别编码，并将文件显示为普通文本，所以你很可能不会注意到编码。</p><p>               00000000: fffe 4800 6500 6c00 6c00 6f00 2000 5700 ..H.e.l.l.o. .W.00000010: 6f00 7200 6c00 6400 2000 3400 3500 3600 o.r.l.d. .4.5.6.00000020: 2100 0a00 !...</p><p>00000000：fffe4800 6500 6c00 6c00 6f00 2000 5700.H.E.L.O.。.W.00000010：6f00 7200 6c00 6400 2000 3400 3500 3600 o.r.l.d.。.4.5.6.00000020：2100 0a00！...。</p><p> As you can see, the UTF-16 encoded file looks just like ASCII text with null characters between every character.</p><p>如您所见，UTF-16编码的文件看起来就像ASCII文本，每个字符之间都有空字符。</p><p> So, how do we actually find matches in a UTF-16 encoded file using grep?  Well, this is actually one of the few situations where grep isn&#39;t actually the best tool for the job.  One option would be to normalize your files to UTF-8/ASCII encoding.  You can convert files between different encoding using the &#39;iconv&#39; command:</p><p>那么，我们如何使用grep在UTF-16编码的文件中找到匹配项呢？这实际上是grep实际上不是最好的工具的少数几种情况之一。一种选择是将您的文件标准化为UTF-8/ASCII编码。*您可以使用&#39；iconv&#39；命令在不同编码之间转换文件：</p><p>   Since the file is now encoded as ASCII/UTF-8 in file3.txt, your original grep command should find the expected matches.</p><p>由于该文件现在在file3.txt中被编码为ASCII/UTF-8，因此您最初的grep命令应该会找到预期的匹配项。</p><p> Another less ideal option is to use the &#39;-P&#39; flag with grep and explicitly include the null characters for the UTF-16 encoding in your grep command:</p><p>另一个不太理想的选择是将&#39；-P&P标志与grep一起使用，并在grep命令中显式包含用于UTF-16编码的空字符：</p><p>   This looks quite messy, and since &#39;-P&#39; is not supported by all version of grep, you can&#39;t always use this option.  It also requires you to do a separate search every time you suspect there might be a UTF-16 file present (or more if there are even more encodings present).</p><p>这看起来相当混乱，而且由于并非所有版本的grep都支持&#39；-P；，所以您不能总是使用此选项。它还要求您在每次怀疑可能存在UTF-16文件时进行单独的搜索(如果存在更多编码，则搜索更多)。</p><p> Another thing to note is that the &#39;-a&#39; flag in the command above is necessary, otherwise grep will treat the UTF-16 files as binary data and refuse to search them.</p><p>另一件需要注意的事情是，上述命令中的&#39；-a&a；标志是必需的，否则grep将把UTF-16文件视为二进制数据并拒绝搜索它们。</p><p>  Hopefully, you&#39;ve learned a few things about grep and the shell environment in this article.  I feel like I need to write a conclusion section to avoid ending the article too abrubtly, but there&#39;s really nothing more to say at this point, and if I keep writing then I&#39;ll just be rambling.  I guess we can talk about the weather if you want.  How are things going with you?</p><p>希望您已经在本文中了解了一些关于grep和Shell环境的知识。我觉得我需要写一个结束语，以避免文章结尾过于草率，但在这一点上真的没有什么可说的了，如果我继续写下去，我就会漫无边际了。如果你愿意的话，我想我们可以谈谈天气。你过得怎么样？</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.robertelder.org/top-5-grep-mistakes/">https://blog.robertelder.org/top-5-grep-mistakes/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/令人困惑/">#令人困惑</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/grep/">#grep</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>