<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>你好，hpe. Hello, HPy</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Hello, HPy<br/>你好，hpe. </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-30 03:08:46</div><div class="page_narrow text-break page_content"><p>HPy has been around for a while now. The initial discussion started duringEuroPython 2019, in the good old times when we could still go to conferencesand have real-life meetings. Since then, HPy progressed  a lot from thepoint of view of the actual code, but we have been a bit too silentw.r.t. communicating what we are doing to the external world and to the broaderPython community. Hopefully, now that this blog is online we will do a betterjob at periodically communicating the status of HPy, so make sure to subscribe to the RSS feed.</p><p>HPY现在已经过了一段时间了。初步讨论在2019年期间开始，在好的旧时代，我们仍然可以去会议和有现实生活会议。从那时起，从实际代码的角度来看，HPE展开了很多，但我们有点太静音了。沟通我们在外部世界和广阔的社区所做的事情。希望，现在这篇博客在线我们将在定期传达HPY状态时进行更好的ejob，因此请务必订阅RSS源。</p><p>   HPy provides a new API for extending Python in C. In other words, you use #include &lt;hpy.h&gt; instead of  #include &lt;Python.h&gt;.</p><p>   HPY为在C中扩展Python提供了一个新的API。换句话说，您使用#include＆lt; hpy.h＆gt;而不是#include＆lt; python.h＆gt;</p><p> The official  Python/C API isspecific to the current implementation of CPython: it exposes manyinternal details which makes it hard:</p><p> 官方Python / C API对CPython的当前实施方式：它公开了许多人的细节，这使得它很难：</p><p> to experiment with new things inside CPython itself: e.g. using a GC instead of refcounting, or to remove the GIL.</p><p> 试验CPython本身内的新事物：例如使用GC而不是Refcounting，或删除GIL。</p><p> to correctly check things like refcount handling: the external API gets mixed in with implementation details that should be hidden.</p><p> 要正确检查像Refcount Handling这样的内容：外部API会混合使用应隐藏的实现细节。</p><p> Over the years, it has become evident that emulating the Python/C API in an efficient way is challenging,if not impossible. The main goal of HPy is expose a C API which is possibleto implement in an efficient way on a number of very diverse Pythonimplementations.</p><p> 多年来，明显显然，以有效的方式模仿Python / C API是具有挑战性的，如果不是不可能的话。 HPY的主要目标是公开一个C API，它以有效的方式在许多非常多样化的Pythonimplation上以有效的方式实现。</p><p>  it is possible to compile a single binary which runs unmodified on all supported Python implementations and versions</p><p>  可以在所有支持的Python实现和版本上编译单个二进制文件，该二进制文件在所有支持的Python实现和版本上运行 </p><p>  it provides an improved debugging experience: in &#34;debug mode&#34;, HPy actively checks for many common mistakes such as reference leaks and invalid usage of objects after they have been deleted. It is possible to turn the &#34;debug mode&#34; on at startup time, without needing to recompile Python or the extension itself</p><p>它提供了改进的调试体验：IN＆＃34;调试模式＆＃34 ;,HPE主动检查许多常见错误，例如参考泄漏和无效的对象在删除后的使用情况。可以转动＆＃34;调试模式和＃34;在启动时，不需要重新编译Python或扩展本身</p><p>     #include  &lt;Python.h&gt;  static  PyObject *  add ( PyObject *  self ,  PyObject *  args )  {  long  a ,  b ;  if  ( ! PyArg_ParseTuple ( args ,  &#34;ll&#34; ,  &amp; a ,  &amp; b ))  return  NULL ;  return  PyLong_FromLong ( a + b ); } static  PyMethodDef  HelloMethods []  =  {  { &#34;add&#34; ,  ( PyCFunction ) add ,  METH_VARARGS ,  &#34;add two integers&#34; },  { NULL ,  NULL ,  0 ,  NULL } }; static  struct  PyModuleDef  moduledef  =  {  PyModuleDef_HEAD_INIT ,  &#34;hello_old&#34; ,  &#34;hello example using the old Python/C API&#34; ,  -1 ,  HelloMethods , }; PyMODINIT_FUNC PyInit_hello_old ( void )  {  return  PyModule_Create ( &amp; moduledef ); }</p><p>     #include＆lt; python.h＆gt;静态pyobject *添加（pyobject * self，pyobject * args）{long a，b; if（！pyarg_parsetuple（args，＆＃34; ll＆＃34;＆amp; a，＆amp; b））返回null;返回Pylong_Fromlong（A + B）;静态pymethoddef hellomethods [] = {{＆＃34;添加＆＃34; ，（pycfunction）添加，meth_varargs，＆＃34;添加两个整数＆＃34; }，{null，null，0，null}}; static struct pymoduledef moduledef = {pymoduledef_head_init，＆＃34; hello_old＆＃34; ，＆＃34;你好，使用旧的python / c api＆＃34; ，-1，hellomethods，}; pymodinit_func pyinit_hello_old（void）{return pymodule_create（＆amp; moduledef）; }</p><p>     #include  &lt;hpy.h&gt;  HPyDef_METH ( add ,  &#34;add&#34; ,  add_impl ,  HPyFunc_VARARGS ,  . doc  =  &#34;add two integers&#34; ); static  HPy  add_impl ( HPyContext  ctx ,  HPy  self ,  HPy  * args ,  HPy_ssize_t  nargs )  {  long  a ,  b ;  if  ( ! HPyArg_Parse ( ctx ,  NULL ,  args ,  nargs ,  &#34;ll&#34; ,  &amp; a ,  &amp; b ))  return  HPy_NULL ;  return  HPyLong_FromLong ( ctx ,  a + b ); }</p><p>     #include＆lt; hpy.h＆gt; hpydef_meth（添加，＆＃34;添加＆＃34;，add_impl，hpyfunc_varargs，。doc =＆＃34;添加两个整数＆＃34;）;静态HPY Add_impl（HPyContext CTX，HPY SELF，HPY * ARGS，HPY_SSIZE_T NARGS）{LONG A，B; if（！hpyarg_parse（ctx，null，args，nargs，＆＃34; ll＆＃34;＆amp; a，＆amp; b））返回hpy_null;返回氟氯龙_FROMLONG（CTX，A + B）; }</p><p>  the former  PyObject * is now  HPy, which we call &#34;a handle&#34;. Handles are similar to  PyObject *, but are completely opaque: for more information, see the  official docs.</p><p>  前蟒蛇*现在是HPY，我们调用＆＃34;把手＆＃34;句柄类似于pyobject *，但完全不透明：有关更多信息，请参阅官方文档。</p><p> There is an additional parameter,  HPyContext ctx. One of the problems of the old API is that often it implicitly relies on the existence of a per-thread or per-subinterpreter local state.  HPyContext makes this state explicit. This makes the whole API more regular and makes it possible to develop new interesting features such as the  Universal ABI and the  Debug mode.</p><p> 还有一个附加参数hpycontext ctx。旧API的问题之一是通常它隐含地依赖于存在每线程或每个子际状态的存在。 HPyContext使此状态显式。这使得整个API更加规则并且可以开发新的有趣功能，例如通用ABI和调试模式。</p><p> HPy introduces the concept of  HPyDefs.  HPyDef_METH is a macro which generates the definition of an  HPyDef static constant named  add, which represents the definition of a Python method implemented by the C function  add_impl. In this specific example  HPyDef_METH contains more or less the same informations as the old  PyMethodDef, but  HPyDef are more general. For example, when defining custom types you can use things like  HPyDef_SLOT,  HPyDef_GETSET, etc.</p><p> HPY介绍了HPYDEF的概念。 HPyDef_Meth是一种宏，它生成HPyDef静态常量命名添加的定义，它表示由C函数add_impl实现的python方法的定义。在这个具体的例子中，HPYDEF_METH包含或多或少地包含与旧Pymethoddef相同的信息，但HPYDEF更普遍。例如，当定义自定义类型时，您可以使用像HpyDef_slot，hpydef_getset等的内容使用。</p><p> Notice that we no longer need the cast to  (PyCFunction). One of the biggest advantages of  HPyDef_METH is that since it&#39;s a macro, it can automatically generate a forward declaration for  add_impl, with the correct signature. This means that if you use the wrong number and/or type of parameters, you get a nice compile-time error instead of an obscure crash at runtime.</p><p> 请注意，我们不再需要演员（Pycfunction）。 hpydef_meth的最大优势之一是因为它＆＃39; s宏，它可以自动为add_impl生成前向声明，并具有正确的签名。这意味着如果使用错误的数字和/或参数类型，则会获得一个很好的编译时间错误，而不是在运行时崩溃。 </p><p> The signature corresponding to  HPyFunc_VARARGS is slighly different than the old  METH_VARARGS: we pass positional arguments as a C array instead of a Python tuple. This means that it is possible to call the function without having to allocate a Python tuple, and for example the PyPy implementation of HPy takes advantage of that. This is very similar to CPython&#39;s  VectorCall protocol.</p><p>与HpyFunc_Varargs对应的签名与旧的meth_varargs略有不同：我们将位置参数传递为C阵列而不是Python元组。这意味着可以呼叫该功能而无需分配Python元组，例如HPy的Pypy实现利用了。这与CPython＆＃39; s vectorcall协议非常相似。</p><p> In this post, we are using a slightly old version of HPy. If you try witha newer version you should use  HPyContext *ctx instead of  HPyContext ctx.See also  Issue #150and  PR #182.</p><p> 在这篇文章中，我们正在使用稍旧的HPY版本。如果你尝试使用hpycontext * ctx而不是hpycontext ctx.see也会发出＃150和Pr＃182。</p><p>  static  HPyDef  * hello_defines []  =  {  &amp; add ,  NULL }; static  HPyModuleDef  moduledef  =  {  HPyModuleDef_HEAD_INIT ,  . m_name  =  &#34;hello_old&#34; ,  . m_doc  =  &#34;hello example using the new HPy API&#34; ,  . m_size  =  -1 ,  . defines  =  hello_defines , }; HPy_MODINIT ( hello_new ) static  HPy  init_hello_new_impl ( HPyContext  ctx )  {  return  HPyModule_Create ( ctx ,  &amp; moduledef ); }</p><p>  static hpydef * hello_defines [] = {＆amp;添加，null};静态HPYModuledef Moduledef = {hpymoduledef_head_init，。 m_name =＆＃34; hello_old＆＃34; 。 m_doc =＆＃34;你好，使用新的hpe api＆＃34; 。 m_size = -1，。定义= hello_defines，}; hpy_modinit（hello_new）静态hpe init_hello_new_impl（hpycontext ctx）{return hpymodule_create（ctx，＆amp; moduledef）; }</p><p> This is pretty similar to the old code. The biggest change is that instead ofdeclaring an array of  PyMethodDef, we create an array of  HPyDef asdiscussed above.</p><p> 这与旧代码相似。最大的变化是，而不是指定一系列Pymethoddef，我们创建了上面的HPyDef asdiscussed数组。</p><p> Finally, we need to modify  setup.py. Compiling an HPy extension is as easyas adding  setup_requires=[&#39;hpy.devel&#39;] and use  hpy_ext_modules:</p><p> 最后，我们需要修改setup.py。编译HPY扩展名为Easyas添加setup_requires = [＆＃39; hpy.devel＆＃39;]并使用hpy_ext_modules：</p><p>  from  setuptools  import  setup ,  Extension setup (  name = &#34;hello&#34; ,  ext_modules  =  [  Extension ( &#39;hello_old&#39; ,  [ &#39;hello_old.c&#39; ]),  ],  hpy_ext_modules  =  [  Extension ( &#39;hello_new&#39; ,  [ &#39;hello_new.c&#39; ]),  ],  setup_requires = [ &#39;hpy.devel&#39; ], )</p><p>  来自Setuptools Import Setup，Extension Setup（Name =＆＃34; Hello＆＃34;，ext_modules = [扩展名（＆＃39; hello_old＆＃39;，[＆＃39; hello_old.c＆＃39;]，]，]，]，hpy_ext_modules = [扩展（＆＃39; hello_new＆＃39;，[＆＃39; hello_new.c＆＃39;]，setup_requires = [＆＃39; hpy.devel＆＃39;]，）</p><p>  In this demo, we will show how to setup an environment to try HPy and compileextensions on both CPython and PyPy.</p><p>  在此演示中，我们将展示如何设置一个环境，以在CPython和Pypy上尝试HPY和CompileExtensions。 </p><p> At the moment HPy is still in its early stages and the API is still subject tochange, so we have not done any official release yet. For the same reason, ifyou want to use HPy on PyPy, you need to manually ensure to install a versionwhich is supported. This is just temporary, and this kind of things will besorted out automatically once we start to roll out official releases.</p><p>目前，HPY仍处于早期阶段，API仍然需要进行差异，所以我们还没有完成任何官方发布。出于同样的原因，如果您希望在PYPY上使用HPY，则需要手动确保安装支持版本。这只是暂时的，这一旦开始推出官方版本，这种事情会自动讨厌。</p><p> So, we need to install HPy from the github repo. Moreover, the HPyimplementation inside PyPy is lagging behind a little, so we will install aslightly old revision:</p><p> 因此，我们需要从GitHub repo安装HPY。此外，罗比亚内的HPYIMPLENTIONDATION在一点点后滞后，所以我们将安装浅旧版本：</p><p>    To install a nightly build of PyPy it is enough to unpack the tarball and run -m ensurepip. We can check what is the HPy version supported by PyPy bycalling  hpy.universal.get_version():</p><p>    要安装夜间的小型，它足以解开tarball并运行-M的保证。我们可以查看Pypy bycalling hpy.universal.get_version（）支持的HPY版本是什么：</p><p> $ curl -O http://buildbot.pypy.org/nightly/hpy/pypy-c-jit-101860-a2f7c80062e8-linux64.tar.bz2$ tar xf pypy-c-jit-101860-a2f7c80062e8-linux64.tar.bz2$ ./pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy -m ensurepip$ ./pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy&gt;&gt;&gt;&gt; import hpy.universal&gt;&gt;&gt;&gt; hpy.universal.get_version () ( &#39;0.1.dev959+geb07982&#39;,  &#39;eb07982&#39; )</p><p> $ curl -o http://buildbot.pypy.org/teartly/hpy/pypy-c-jit-101860-a2f7c80062e8-linux64.tar.bz2 / tar xf pypy-c-jit-101860-a2f7c80062e8-linux64.tar。 bz2 $ ./pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy -m searnpip $ ./pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy&g ;&gt ;&gt ;&gt;进口hpy.universal＆gt;＆gt;＆gt;＆gt;＆gt; hpy.universal.get_version（）（＆＃39; 0.1.dev959 + geb07982＆＃39;＆＃39; eb07982＆＃39;）</p><p>  $  cd /path/to/example/$ . /path/to/tryhpy/bin/activate  # activate the venv$ python setup.py build_ext --inplace [... ]$ ls -1 *.sohello_new.cpython-38-x86_64-linux-gnu.sohello_old.cpython-38-x86_64-linux-gnu.so$ python&gt;&gt;&gt; import hello_old, hello_new&gt;&gt;&gt; hello_old.add ( 10,  20 ) 30&gt;&gt;&gt; hello_new.add ( 30,  40 ) 70&gt;&gt;&gt;</p><p>  $ cd / path / to / miffer / $。 / path / to / to-to / toyhpy / bin / sectivate＃激活venv $ python setup.py build_ext --inplace [...] $ ls -1 * .sohello_new.cpython-38-x86_64-linux-gnu.sohello_old.cpython- 38-x86_64-linux-gnu.so $ python＆gt;＆gt;＆gt;进口hello_old，hello_new＆gt;＆gt;＆gt; hello_old.add（10,20）30＆gt;＆gt;＆gt;＆gt; hello_new.add（30,40）70＆gt;＆gt;</p><p> It worked! One important thing to note is the filename of  hello_new: .cpython-38-x86_64-linux-gnu.so is the standard filename for CPython 3.8extension modules. This happens because by default  hpy_ext_modules targetsthe CPython ABI. Assuch, from the point of view of CPython  hello_new is indistinguishable from hello_old. It also means that HPy is required only to compile it but not toimport it later. Finally, we expect the performance to be the very same as theextensions using the old API.</p><p> 有效！要注意的一个重要事项是hello_new的文件名：.cpython-38-x86_64-linux-gnu.so是cpython 3.8extension模块的标准文件名。这发生了，因为默认情况下，hpy_ext_modules toundsthe cpython abi。 assuch，从CPython Hello_New的角度来看，与Hello_old无法区分。这也意味着HPY是只需要编译它而是稍后才能加入它。最后，我们希望性能与使用旧API的extensions相同。</p><p> However, we can also explicitly ask HPy to produce an &#34;universal binary&#34;,which targets the HPy Universal ABI:as the name implies, universal binaries can be imported by CPython, but alsoby alternative implementations such as PyPy. We can build universal binariesby passing  --hpy-abi=universal to  setup.py:</p><p> 但是，我们也可以明确要求HPY生产AN＆＃34;普遍二进制＆＃34;，它针对HPY Universal ABI：顾名思义，可以通过CPython进口通用二进制文件，但诸如PYPY等Alsoby替代实现。我们可以构建通用的binariesby try  -  hpy-abi = posencal to setup.py： </p><p> $  # clean the previous build$ rm -rf build/ *.so$ python setup.py --hpy-abi =universal build_ext --inplace$ ls -1 *.sohello_new.hpy.sohello_old.cpython-38-x86_64-linux-gnu.so</p><p>$＃clean the以前的build $ rm -rf build / * .so $ python setup.py  -  hpy-abi = henseral build_ext --inplace $ ls -1 * .sohello_new.hpy.sohello_old.cpython-38-x86_64-linux -gnu.so.</p><p> Note the filename:  hello_old is still a CPython-specific extension, but hello_new.hpy.so is an universal binary. Once compiled, you can import it asusual:</p><p> 注意文件名：hello_old仍然是一个特定于cpython的扩展，但hello_new.hpy.so是一个通用二进制。编译后，您可以导入热点：</p><p>  At the moment of writing, because of Issue #191 if you try toprint the repr of  hello_new, you see something like this (note the  .pyextension):</p><p>  在写作的那一刻，因为问题＃191如果你尝试翻页hello_new的'pyrint，你会看到这样的东西（注意.pyextension）：</p><p> Note that on its own, CPython does  not know how to import  .hpy.sofiles. The magic is done by the  hello_new.py, which is automaticallygenerated by  setup.py:</p><p> 请注意，在其自己的情况下，CPython不知道如何导入.hpy.sofiles。魔术由hello_new.py完成，由setup.py自动启动：</p><p> $  cat  hello_new . py [ ... ] def  __bootstrap__ ():  [ ... ]  from  hpy.universal  import  load_from_spec  ext_filepath  =  pkg_resources . resource_filename ( __name__ ,  &#39;hello_new.hpy.so&#39; )  m  =  load_from_spec ( Spec ( &#39;hello_new&#39; ,  ext_filepath ))  [ ... ]  sys . modules [ __name__ ]  =  m __bootstrap__ ()</p><p> $ cat hello_new。 py [...] def __bootstrap__（）：从hpy.universal import load_from_spec ext_filepath = pkg_resources。 resource_filename（__name__，＆＃39; hello_new.hpy.so＆＃39;）m = load_from_spec（spec（＆＃39; hello_new＆＃39;，ext_filepath）[...] sys。模块[__name__] = m __bootstrap__（）</p><p>   That&#39;s all you need to get started with HPy. What we presented today is justthe basics, of course: in the next posts we will dig more into the technicaldetails, and show more interesting features than just a hello world.</p><p>   所有你需要从HPY开始的所有＆＃39。我们今天呈现的是基础知识，当然：在下一篇文章中，我们将更多地挖掘技术特征，并显示出比Hello World的更有趣的功能。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hpyproject.org/blog/posts/2021/03/hello-hpy/">https://hpyproject.org/blog/posts/2021/03/hello-hpy/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/你好/">#你好</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hpy/">#hpy</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>