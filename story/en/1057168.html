<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>版本控制数据管道：Metaflow和Dolt Version Controlled Data Pipelines: Metaflow and Dolt</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Version Controlled Data Pipelines: Metaflow and Dolt<br/>版本控制数据管道：Metaflow和Dolt </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-09 06:37:35</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/05a61109c58f8e647679f81f1199c984.png"><img src="http://img2.diglog.com/img/2021/4/05a61109c58f8e647679f81f1199c984.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This post details how to use Metaflow with Dolt.  Metaflow is a framework for defining data science and data engineering workflows with the the ability to define local experiments and scale those experiments to production jobs from a single API.  Dolt is a version controlled relational database. It provides a familiar SQL interface along with Git-like version control features. Each commit corresponds to the state of the database at the time the commit was created. Both Dolt and Metaflow are open source.</p><p>这篇文章详情如何使用Metaflow与DOLT。 Metaflow是定义数据科学和数据工程工作流程的框架，其中能够定义本地实验并将这些实验从单个API进行生产作业。 DOLT是一个版本控制的关系数据库。它提供了熟悉的SQL接口以及类似Git的版本控制功能。每个提交都对应于创建提交时数据库的状态。 DOLT和METAFLOW都是开源的。</p><p> We show how the co mbination of Dolt and Metaflow can be used to address three common challenges in modern data science and data engineering projects and architectures:</p><p> 我们展示了如何使用DOLT和METAFLOW的CO MB，以解决现代数据科学和数据工程项目和架构中的三种共同挑战：</p><p> Reproducibility:  how to make sure that we can repeat past results consistently and improve results incrementally. Disciplined science and engineering requires that goalposts don’t shift unexpectedly, for example due to changes in input data.   Experiment tracking:  how to keep track of all changes and experiments executed. Today, it is hard to imagine software development without a version control like Git — data science needs a similar tool to stay organized.   Lineage and auditing:  finally, when our system is in production, we want to understand the exact model and input data that contribute to the system’s output, for example predictions. This is especially important when results are surprising and we need to understand why.</p><p> 再现性：如何确保我们可以始终如一地重复过去的结果，并逐步改进结果。纪律主题的科学和工程要求守门员不会意外地转移，例如由于输入数据的变化。实验跟踪：如何跟踪执行所有更改和实验。今天，很难想象没有像Git的版本控制的软件开发，数据科学需要一个类似的工具来保持组织。谱系和审计：最后，当我们的系统在生产中，我们希望了解有助于系统输出的确切模型和输入数据，例如预测。当结果令人惊讶时，这尤其重要，我们需要了解原因。</p><p> Both Dolt and Metaflow are built around the idea of strong versioning: Dolt versions data and Metaflow versions code, execution environments, and the state of execution. To illustrate how Metaflow and Dolt work together to solve for these challenges, we use an example Metaflow pipeline to derive results from an input dataset. We read the input data into a Pandas  DataFrame and convert that  DataFrame to permanent storage in Dolt for use with application layer services with an intermediate step. Dolt SQL Server can be used to serve this versioned and reproducible data over MySQL connectors into other parts of the infrastructure.</p><p> DOLT和METAFLOW都是在强大版本控制的思想之外构建的：Dolt版本数据和Metaflow版本代码，执行环境和执行状态。为了说明MetaFlow和Dolt如何一起解决这些挑战，我们使用示例元流量管线来派生输入数据集的结果。我们将输入数据读到Pandas DataFrame中，并将该Dataframe转换为Dolt中的永久存储，以与具有中间步骤的应用层服务一起使用。 Dolt SQL Server可用于通过MySQL连接器提供此版本化和可重复的数据，进入基础架构的其他部分。</p><p>    Our pipeline consists of two flows. One flow consumes the results written by the other. The first flow computes the state level median price for a hospital procedure. The second flow computes the variance of the price for a procedure across states. For input data we chose a new public  dataset of 1400 US hospital prices created using DoltHub  data bounties. Our pipeline will look something like schematic below.</p><p>    我们的管道由两个流动组成。一个流量消耗由另一个的结果。第一个流量计算医院手术的国家级中位数。第二流量计算跨州的过程的价格方差。对于输入数据，我们选择了使用Dolthub数据赏金创建的1400个美国医院价格的新公共数据集。我们的管道看起来像下面的示意图。</p><p>  We will use the end result to illustrate how integrating Dolt and Metaflow provides Metaflow users with the ability to traverse versions of their final data, as well as traceback through the pipeline to examine various stages. Users can do this via the Metaflow API and Dolt integration in a familiar environment like a console or a notebook.</p><p>  我们将使用最终结果来说明Dolt和Metaflow如何为Metaflow用户提供遍历其最终数据版本的能力，以及通过管道进行回溯以检查各个阶段。用户可以通过MetaFlow API和Dolt Integration在熟悉的环境中这样做，如控制台或笔记本。</p><p> All the code from the example pipeline is open source, and can be found in the  dolt-integrations  GitHub repository.</p><p> 示例流水线的所有代码都是开源，可以在Dolt-Integrations Github存储库中找到。 </p><p>  Our design goal with this integration was to give the Metaflow user additional capabilities directly from Metaflow. We wanted to minimize additional API surface area.</p><p>我们的设计目标具有这种集成，是直接从Metaflow提供Metaflow用户额外的功能。我们希望尽量减少额外的API表面积。</p><p> Workflows in Metaflow are called “flows.” Each flow stores metadata about flow execution, referred to as a “run.” Each time a run interacts with Dolt, we capture a small amount of metadata to make that interaction reproducible. We create a mapping between Metaflow runs and Dolt commits to provide users with powerful lineage and reproducibility features.</p><p> Metaflow中的工作流称为“流动”。每个流程存储关于流量执行的元数据，称为“运行”。每次运行与DOLT交互时，我们都会捕获少量元数据以使该交互再现。我们在Metaflow运行和DOLT提交之间创建映射，为用户提供强大的素线和再现性功能。</p><p>   Individual steps of a run can create separate commits that snapshot the state of the database following a write.</p><p>   运行的各个步骤可以创建单独的提交，以后写入写入后的数据库状态。</p><p>  When a flow reads data from Dolt, it records exactly how that data was read inside Metaflow. When a flow writes to Dolt it creates a commit and captures the associated metadata, as well as formatting the commit message. This allows users to browse the inputs and outputs of their flows from the Metaflow API directly without having to know much of anything about Dolt. Furthermore users can retrieve the flow that last touched a table at a given branch or commit, also directly from the Metaflow API.</p><p>  当流程从DOLT读取数据时，它记录了在MetaFlow内部读取数据的准确。当流程写入致命时，它会创建提交并捕获相关元数据，以及格式化提交消息。这允许用户直接浏览它们流量的流量的输入和输出，而无需了解大多数关于DOLT的任何内容。此外，用户可以检索最后从给定分支或提交的表的流程，也可以直接从MetaFlow API进行提交。</p><p> This is all abstract, so let’s install a few dependencies, grab a dataset, and get stuck into running our pipeline.</p><p> 这一切都是抽象的，所以让我们安装一些依赖项，抓住一个数据集，并陷入运行我们的管道。</p><p>  Let’s get the boring stuff out of the way. We need the following:</p><p>  让我们离开乏味的东西。我们需要以下内容：</p><p> - Dolt and   dolt-integrations  installed - Metaflow installed - the sample dataset we will use, which can easily clone from DoltHub</p><p>  - 安装了Dolt和Dolt-Integrations  - 安装了Metaflow  - 我们将使用的示例数据集，这可以轻松从Dolthub克隆 </p><p>      Next let’s install the Metaflow + Dolt integration. It comes packaged with both Metaflow, and Dolt’s Python CLI wrapper, doltcli. It’s easy enough to install via  pip:</p><p>接下来让我们安装MetaFlow + Dolt集成。它与MetaFlow和Dolt的Python Cli包装器一起包装，Doltcli。通过PIP安装很容易：</p><p>   The final step is to acquire the dataset. Recall Dolt is a SQL database with Git-like version control features, and it comes with the ability to clone a remote database to your local machine. We can use that feature to easily acquire a Dolt database:</p><p>   最后一步是获取数据集。调用DOLT是一个带有类似GIT版本控制功能的SQL数据库，它可以克隆远程数据库到本地计算机。我们可以使用该功能来轻松获取DOLT数据库：</p><p>  Note this dataset is nearly 20 gigabytes, and could take a few minutes to clone. Once it’s landed it’s straightforward to jump right into SQL:</p><p>  注意此数据集是近20千兆字节，可能需要几分钟才能克隆。一旦它降落到SQL即将跳转到SQL，这是直接的：</p><p> $ dolt sql # Welcome to the DoltSQL shell. # Statements must be terminated with &#39;;&#39;. # &#34;exit&#34; or &#34;quit&#34; (or Ctrl-D) to exit. hospital_price_transparency&gt; show tables; +-----------+ | Table | +-----------+ | cpt_hcpcs | | hospitals | | prices | +-----------+</p><p> $ dolt sql＃欢迎来到Doltsql shell。 ＃语句必须终止＆＃39 ;;＆＃39; ＃＆＃34;退出＆＃34;或＆＃34; quit＆＃34; （或Ctrl-D）退出。 hospital_price_transparency＆gt;显示表; + ----------- + |表| + ----------- + | cpt_hcpcs | |医院| |价格| + ----------- +</p><p>   Before we get into the details, let’s first produce a run of our pipeline off the latest version of the upstream database. The first flow computes the median cost of a given hospital procedure at the state level:</p><p>   在我们进入详细信息之前，让我们首先在最新版本的上游数据库中产生我们的管道运行。第一个流量在州级计算给定医院手术的中位数：</p><p> $ poetry run python3 hospital_procedure_price_state_medians.py run \   --hospital-price-db path/to/hospital-price-transparency \   --hospital-price-analysis-db path/to/hospital-price-analysis Metaflow 2.2.8 executing HospitalPriceStateMedians for user:oscarbatori Validating your flow...  The graph looks good! 2021-04-07 08:50:36.934 Workflow starting (run-id 1617810636925188): 2021-04-07 08:50:36.941 [1617810636925188/start/1 (pid 21075)] Task is starting. 2021-04-07 09:02:36.095 [1617810636925188/start/1 (pid 21075)] Task finished successfully. 2021-04-07 09:02:36.136 [1617810636925188/end/2 (pid 21257)] Task is starting. 2021-04-07 09:02:37.697 [1617810636925188/end/2 (pid 21257)] Task finished successfully. 2021-04-07 09:02:37.698 Done!</p><p> $诗歌运行python3 hospital_procedure_price_state_medians.py run \ --hosital-price-db路径/到/医院 - 价格 - 透明度\ --hoSital-price-price-dub路径/到/医院 - 价格分析metaflow 2.2.8执行医院PriceStatemedians对于用户：oscarbatori验证您的流程......图表看起来不错！ 2021-04-07 08：50：36.934工作流程开始（Run-ID 1617810636925188）：2021-04-07 08：50：36.941 [16178106369251818 / start / 1（PID 21075）]任务是启动。 2021-04-07 09：02：36.095 [161781063692518188 / Start / 1（PID 21075）]任务成功完成。 2021-04-07 09：02：36.136 [1617810636925188 /端/ 2（PID 21257）]任务开始。 2021-04-07 09：02：37.697 [1617810636925188 / END / 2（PID 21257）]任务成功完成。 2021-04-07 09：02：37.698完成！</p><p>  $ poetry run python3 hospital_procedure_price_variance_by_state.py run \   --hospital-price-analysis-db path/to/hospital-price-analysis Metaflow 2.2.8 executing HospitalProcedurePriceVarianceByState for user:oscarbatori Validating your flow...  The graph looks good! 2021-04-07 09:07:25.262 Workflow starting (run-id 1617811645255563): 2021-04-07 09:07:25.269 [1617811645255563/start/1 (pid 21299)] Task is starting. 2021-04-07 09:08:25.200 [1617811645255563/end/2 (pid 21349)] Task is starting. 2021-04-07 09:08:25.982 [1617811645255563/end/2 (pid 21349)] Task finished successfully. 2021-04-07 09:08:25.983 Done!</p><p>  $诗歌运行python3 hospital_procedure_price_variance_by_state.py run \ --hosital-price-anysis-db路径/到/医院 - 价格分析metaflow 2.2.8执行HospactProcedurepricevarianceByState for User：OSCArbatori验证您的流程......图表看起来很好！ 2021-04-07 09：07：25.262工作流程开始（Run-ID 16178116452555563）：2021-04-07 09：07：25.269 [16178116452659 [1617811645255563 / start / 1（PID 21299）]任务是启动。 2021-04-07 09：08：25.200 [16178116452555563 /端/ 2（PID 21349）]任务开始。 2021-04-07 09：08：25.982 [16178116452555563 / END / 2（PID 21349）]任务成功完成。 2021-04-07 09：08：25.983完成！ </p><p> We now have our first result set computed. Let’s access the computed variances via the integration, using the flow as an entry point. You can execute the following snippet, and subsequent examples, using the Python interpreter on the command line or in a notebook. The snippet uses  Metaflow’s Client API to access results of past runs:</p><p>我们现在拥有我们的第一个结果集。让我们通过集成来访问计算的差异，使用流作为入口点。您可以使用命令行或笔记本中的Python解释器执行以下代码段和后续示例。 Snippet使用Metaflow的客户端API访问过去运行的结果：</p><p>   code price 0 CPT® 86708,72 253.125 1 CPT® 86708,73 253.125 2 CPT® 86708,74 253.125 3 CPT® 86708,75 253.125 4 CPT® 86708,76 253.125  … … 1176694 nan,5 254148.840 1176695 nan,6 326868.470 1176696 nan,7 779888.100 1176697 nan,8 2152957.800 1176698 nan,9 4031522.000 [1176699 rows x 2 columns]</p><p>   代码价格0CPT®86708,72253.125 1CPT®86708,73253.125 2CPT®86708,74253.125 3CPT®86708,45253.1254CPT®86708,762545376695 NaN，7 779888.100 1176697 NaN，8 215298.800 1176698 Nan，9 4031522.000 [1176699行]</p><p> We have seen it’s relatively straightforward to run our pipeline, and access our versioned results via a reference to the flow that produced them. We now dive into some of the capabilities this provides Metaflow users who choose to use Dolt in their data infrastructure.</p><p> 我们已经看到运行我们的管道相对简单，并通过引用生产它们的流程来访问我们的版本化的结果。我们现在潜入其中一些功能，这提供了选择在数据基础架构中使用DOLT的Metaflow用户。</p><p>  In this example our input dataset is stored in Dolt. We used a DoltHub dataset because it’s easy to clone the dataset and get started, and after all this is about integrating Dolt with Metaflow. But having our input dataset in Dolt isn’t just a matter of convenience for this post . Because every Dolt commit represents the complete state of the database at a point in time, we can easily point our pipeline to historical versions of the data. Let’s examine the Dolt commit graph and grab a commit straight from the SQL console:</p><p>  在此示例中，我们的输入数据集存储在DOLT中。我们使用了一个Dolthub数据集，因为它很容易克隆数据集并开始入门，并且毕竟这是关于将Dolt与Metaflow集成。但是，在DOLT中拥有我们的输入数据集只是这篇文章的便利性。因为每个Dolt提交都代表了一个时间点的数据库的完整状态，所以我们可以轻松地将管道指向数据的历史版本。让我们检查DOLT提交图表并从SQL控制台直接抓取提交：</p><p> $ cd path/to/hospital-price-transparency $ dolt sql # Welcome to the DoltSQL shell. # Statements must be terminated with &#39;;&#39;. # &#34;exit&#34; or &#34;quit&#34; (or Ctrl-D) to exit. hospital_price_transparency&gt; select commit_hash, message from dolt_commits where `date` &lt; &#39;2021-02-17&#39; order by `date` desc limit 10; +----------------------------------+------------------------------------------------------------+ | commit_hash | message | +----------------------------------+------------------------------------------------------------+ | f0lecmblorr67rcuhuti6tbkriigh6gt | Updating prices with changes from uwmc_prices.csv | | mj9ce6d8em9avj9ej0pqnaoes4fbglti | Updating cpt_hcpcs with changes from uwmc_cpt_hcpcs.csv | | 2j6ommult20qvbj05j1nq63nkbd5fgdj | Updating prices with changes from prices.csv | | pu8ctvhfcpp83q3iil8trp90vnuesaci | Updating cpt_hcpcs with changes from cpt_hcpcs.csv | | q49l0kgnbbbgkt3imjd57tslbi2iges8 | Updating hospitals with changes from hospitals.csv | | gstcq5loi9ieqdv1elrljab9hcgr090p | Updating hospitals with changes from hospitals.csv | | te6spcqtjk0scose2c45f9t7tpcrt69c | Added hospital WellSpan Surgery &amp; Rehabilitation Hospital. | | bjg3b5lua8omadcl5nr6o7v0nphliqpu | Added hospital WellSpan York Hospital. | | t4js1g5mfvgikqlmqa238it26mg94g5i | Added hospital Children&#39;s of Alabama. | | jsan7p4iad61cjmeti858ebcl4s86vda | Added hospital McLaren Lapeer Region. | +----------------------------------+------------------------------------------------------------+</p><p> $ cd路径/到/医院 - 价格 - 透明度$ dolt sql＃欢迎来到Doltsql shell。 ＃语句必须终止＆＃39 ;;＆＃39; ＃＆＃34;退出＆＃34;或＆＃34; quit＆＃34; （或Ctrl-D）退出。 hospital_price_transparency＆gt;选择commit_hash，来自dolt_comits的消息，其中`日期` ＆＃39; 2021-02-17＆＃39;按“日期”DESC限制10; + ----------------------------------------- ---------------------------------------- + | commit_hash |消息| + ----------------------------------------- ---------------------------------------- + | f0lecmblor67rcuhuti6tbkrigh6gt |从UWMC_PRICES.csv的更新价格更新价格| | mj9ce6d8em9avj9ej0pqnaoes4fbglti |更新CPT_HCPC与UWMC_CPT_HCPCS.csv |更改| 2j6ommult20qvbj05j1nq63nkbd5fgdj |更新价格随房屋的变化.CSV | | pu8ctvhfcppp83q3iil8trp90vnuesaci |使用CPT_HCPCS.csv的更改更新CPT_HCPC | | Q49L0KGNBBBGKT3IMJD57TSLBI2IGES8 |使用Hospitals.csv的更改更新医院| | gstcq5loi9ieqdv1elrljab9hcgr090p |使用Hospitals.csv的更改更新医院| | TE6SPCQTJK0SCOSE2C45F9T7TPCRT69C |添加医院Wellspan外科＆amp;康复医院。 | | bjg3b5lua8omadcl5nr6o7v0nphliqpu |加入医院Wellspan York医院。 | | t4js1g5mfvgikqlmqa238it26mg94g5i | Alabama的医院儿童添加了医院儿童。 | | jsan7p4iad61cjmeti858ebcl4s86vda |添加了医院毛明酸盐区域。 | + ----------------------------------------- ---------------------------------------------</p><p> Suppose we’d like to run our pipeline with input data as of commit  gstcq5loi9ieqdv1elrljab9hcgr090p, the first one labeled  Updating hospitals with changes from hospitals.csv. That’s easy enough, first let’s name the commit with a branch:</p><p> 假设我们希望使用Commit Gstcq5loi9ieqdv1elrljab9hcgr090p的输入数据运行我们的管道，这是第一个标记的医院更新医院.CSV的更改。这很容易，首先让我们用分支命名提交：</p><p>  Before recomputing the medians let’s create a branch in our  hospital-price-analysis database associated with the root commit to store these experiments:</p><p>  在重新计算中位数之前，让我们在与root提交的医院 - 价格分析数据库中创建一个分支，以存储这些实验： </p><p>  Now let’s kick off recomputing the medians. Since we are recomputing our medians from a historical version of the raw pricing data we will write them to a separate experimentation branch:</p><p>现在让我们开始重新计算中位数。由于我们从原始定价数据的历史版本重新计算我们的中位数，我们将把它们写入单独的实验分支：</p><p> $ poetry run python3 hospital_procedure_price_state_medians.py run \   --hospital-price-db path/to/hospital-price-transparency \   --hospital-price-db-branch metaflow-backtest \  --hospital-price-analysis-db path/to/hospital-price-analysis \  --hospital-price-analysis-db-branch metaflow-backtest Metaflow 2.2.8 executing HospitalPriceStateMedians for user:oscarbatori Validating your flow...  The graph looks good! 2021-04-07 09:20:00.883 Workflow starting (run-id 1617812400875290): 2021-04-07 09:20:00.889 [1617812400875290/start/1 (pid 21700)] Task is starting. 2021-04-07 09:20:20.254 [1617812400875290/start/1 (pid 21700)] Task finished successfully. 2021-04-07 09:20:20.264 [1617812400875290/end/2 (pid 21776)] Task is starting. 2021-04-07 09:20:21.422 [1617812400875290/end/2 (pid 21776)] Task finished successfully. 2021-04-07 09:20:21.423 Done!</p><p> $诗歌运行python3 hospital_procedure_price_state_medians.py run \ --hosital-price-db路径/到/医院 - 价格 - 透明度\ --hosital-price-db-branch metaflow-backtest \ --hosital-price-sigent-db路径/到/医院 - 价格分析\  -  HOSPITITITIAL-PRESITIO-DB-BRONG METAFLOW-BROWTEST METAFLOW 2.2.8执行HARMADYPRICESTATEMEDIANS for User：OSCARBatori验证您的流程......图表看起来很好！ 2021-04-07 09：20：00.883工作流程开始（Run-ID 1617812400875290）：2021-04-07 09：20：00.889 [1617812400875290 / start / 1（PID 21700）]任务开始。 2021-04-07 09：20：20.254 [1617812400875290 / Start / 1（PID 21700）]任务成功完成。 2021-04-07 09：20：20.264 [1617812400875290 /端/ 2（PID 21776）]任务开始。 2021-04-07 09：20：21.422 [1617812400875290 /端/ 2（PID 21776）]任务成功完成。 2021-04-07 09：20：21.423完成！</p><p>  $ poetry run python3 hospital_procedure_price_variance_by_state.py run \   --hospital-price-analysis-db path/to/hospital-price-analysis \  --hospital-price-analysis-db-branch metaflow-backtest Metaflow 2.2.8 executing HospitalProcedurePriceVarianceByState for user:oscarbatori Validating your flow...  The graph looks good! 2021-04-07 09:21:12.296 Workflow starting (run-id 1617812472287058): 2021-04-07 09:21:12.303 [1617812472287058/start/1 (pid 21827)] Task is starting. 2021-04-07 09:21:16.321 [1617812472287058/end/2 (pid 21871)] Task is starting. 2021-04-07 09:21:17.283 [1617812472287058/end/2 (pid 21871)] Task finished successfully. 2021-04-07 09:21:17.284 Done!</p><p>  $诗歌运行python3 hospital_procedure_price_variance_by_state.py run \ --hosital-price-project-db路径/到/医院 - 价格分析\ --hosital-price-price-price-db-branch metaflow-backtest metaflow 2.2.8为用户执行HospitalProcedurePriseByState ：Oscarbatori验证你的流程......图表看起来不错！ 2021-04-07 09：21：12.296工作流程开始（运行ID 1617812472287058）：2021-04-07 09：21：12.303 [1617812472287058 / start / 1（PID 21827）]任务是启动。 2021-04-07 09：21：16.321 [1617812472287058 /端/ 2（PID 21871）]任务开始。 2021-04-07 09：21：17.283 [1617812472287058 /端/ 2（PID 21871）]任务成功完成。 2021-04-07 09：21：17.284完成！</p><p>   Since this commit was taken from far earlier in the data gathering process, we can see far fewer unique procedure codes, 21K vs 1.17M:</p><p>   由于此提交所采取的数据收集过程中的较早，我们可以看到唯一的独特程序代码，21k Vs 1.17M：</p><p> code price 0 0001A 184.03088 1 0001M 12250.82000 2 0001U 35871.70000 3 0002A 275.67660 4 0002M 0.00000  ... ... 21332 L1830-00 13.41620 21333 L1830-01 9.24500 21334 L1830-02 20.22480 21335 L1830-03 247.53125 21336 L1830-04 35.70125 [21337 rows x 2 columns]</p><p> 代码价格0 0001A 184.03088 1 0001M 12250.82000 2 0001U 35871.70000 3 0002A 275.67660 4 0002M 0.00000 ...... 21332 L1830-00 13.41620 21333 L1830-01 9.24500 21334 L1830-02 20.22480 21335 L1830-03 247.53125 21336 L1830-04 35.70125 [21337行x 2列]</p><p> Or we can use Dolt SQL’s  AS OF syntax to query the results of our backtest:</p><p> 或者我们可以使用Dolt SQL的语法来查询我们的Extreapt的结果：</p><p> $ cd path/to/hospital-price-analysis $ dolt sql # Welcome to the DoltSQL shell. # Statements must be terminated with &#39;;&#39;. # &#34;exit&#34; or &#34;quit&#34; (or Ctrl-D) to exit. hospital_price_analysis&gt; select * from variance_by_procedure as of &#39;metaflow-backtest&#39; order by price desc limit 10; +-------+---------------+ | code | price | +-------+---------------+ | Q2042 | 5.9482256e+11 | | Q2041 | 5.1718203e+11 | | 216 | 1.2761694e+11 | | J3399 | 9.192812e+10 | | Q4142 | 1.604416e+10 | | 0100T | 1.4931476e+10 | | C9293 | 9.202785e+09 | | 47133 | 8.558203e+09 | | 90288 | 8.4152607e+09 | | J7311 | 8.2143995e+09 | +-------+---------------+</p><p> $ CD路径/到/医院 - 价格 - 分析$ DOLT SQL＃欢迎来到Doltsql shell。 ＃语句必须终止＆＃39 ;;＆＃39; ＃＆＃34;退出＆＃34;或＆＃34; quit＆＃34; （或Ctrl-D）退出。 hospital_price_analysis＆gt;选择* from variance_by_procedure＆＃39; metaflow-backtest＆＃39;订购价格DESC限制10; + ------- + -------------- + |代码|价格| + ------- + -------------- + | Q2042 | 5.9482256E + 11 | | Q2041 | 5.1718203E + 11 | | 216 | 1.2761694E + 11 | | J3399 | 9.192812E + 10 | | Q4142 | 1.604416E + 10 | | 0100T | 1.4931476E + 10 | | C9293 | 9.202785E + 09 | | 47133 | 8.558203E + 09 | | 90288 | 8.4152607E + 09 | | J7311 | 8.2143995E + 09 | + ------- + -------------- + </p><p> In this section we saw how storing flow inputs in Dolt makes back-testing straightforward. This is enabled by how easy Dolt’s commit graph makes it for users specify a historical version of the data.</p><p>在本节中，我们看到了DOLT中的存储流量输入是如何再次测试的。这是通过Easy Dolt的COMMIT图表使其成为用户的历史版本来实现这一点。</p><p>  Our pipeline contains two steps, one computes state procedure price medians, and the second computes procedure price variances across states. Suppose now that we would like to tweak the way we compute variances. We might like to exclude some outliers, or invalid procedure codes. In a production setting we might own the variances computation but not the medians computation, and have stricter criteria for excluding invalid data. Let’s update our variances job and then recompute using an updated flow definition.</p><p>  我们的管道包含两个步骤，一个计算状态程序价格中位数，第二个计算跨州的程序价格差异。现在假设我们想调整我们计算差异的方式。我们可能想排除一些异常值或无效的程序代码。在生产环境中，我们可能拥有差异计算，而不是中位数计算，并且具有更严格的标准，用于排除无效数据。让我们更新variances作业，然后使用更新的流定义重新计算。</p><p>     We use that path as a parameter to  DoltDT, which in turn causes  DoltDT to read data in exactly the same way as the run specified by the provided run path:</p><p>     我们使用该路径作为Doltdt的参数，这又导致Doltdt以与所提供的运行路径指定的运行完全相同的方式读取数据：</p><p>  Looking back to our first run of the flow computing the medians, the run ID was  1617810636925188. We can also see this in Dolt:</p><p>  回顾我们第一次运行计算中位数的流量，运行ID为1617810636925188.我们也可以在DOLT中看到它：</p><p> dolt log commit lmjqpf293qg9ma10r034htt7jhfu5c4f Author: oscarbatori &lt;oscarbatori@gmail.com&gt; Date: Wed Apr 07 09:08:24 -0700 2021   Run: HospitalProcedurePriceVarianceByState/1617811645255563/start/1  commit 3je2okkrig5h3dbmuf8bhmfq0okps3lg Author: oscarbatori &lt;oscarbatori@gmail.com&gt; Date: Wed Apr 07 09:02:21 -0700 2021   Run: HospitalPriceStateMedians/1617810636925188/start/1</p><p> Dolt log commit lmjqpf293qg9ma10r034htt7jhfu5c4f作者：oscarbatori＆lt; oscarbatori@gmail.com& gt;日期：4月07日星期三09:08:24 -0700 2021 run：hospital procedurepricevariancebystate / 1617811645255563 / start / 1 commit 3je2okkrig5h3dbmufuf8bhmfq0okps3lg作者：oscarbatori＆lt; oscarbatori@gmail.com& gt;日期：4月07日星期三09:02:21 -0700 2021运行：HospanitalPriceStatemedians / 1617810636925188 / Start / 1</p><p> Let’s create a branch pinned to the commit we want to reproduce from:</p><p> 让我们创建一个分支固定在我们想要重现的提交中：</p><p>  We can pass this branch straight into our job to achieve the desired data read isolation for testing our code changes:</p><p>  我们可以直接将此分支直接传递给我们的作业，以实现所需的数据读取隔离以进行测试，以便测试我们的代码更改： </p><p> $ poetry run python3 hospital_procedure_price_variance_by_state.py run \  --hospital-price-analysis-db ~/Documents/dolt-dbs/hospital-price-analysis \  --hospital-price-analysis-db-branch metaflow-change Metaflow 2.2.8 executing HospitalProcedurePriceVarianceByState for user:oscarbatori Validating your flow...  The graph looks good! 2021-04-07 15:11:15.634 Workflow starting (run-id 1617833475626845): 2021-04-07 15:11:15.641 [1617833475626845/start/1 (pid 42039)] Task is starting. 2021-04-07 15:12:17.799 [1617833475626845/start/1 (pid 42039)] Task finished successfully. 2021-04-07 15:12:17.808 [1617833475626845/end/2 (pid 42199)] Task is starting. 2021-04-07 15:12:19.046 [1617833475626845/end/2 (pid 42199)] Task finished successfully. 2021-04-07 15:12:19.047 Done!</p><p>$诗歌运行python3 hospital_procedure_price_variance_by_state.py run \ --hosital-price-anysis-db〜/ document / dolt-dbs / hospital-price-price-price-price-anysis-db-branch metaflow-change metaflow 2.2.8执行HosparalProcedurePriceVarianceByState for User：OscarBatori验证您的流程......图表看起来不错！ 2021-04-07 15：11：15.634工作流程开始（Run-ID 1617833475626845）：2021-04-07 15：11：15.641 [1617833475626845 / start / 1（PID 42039）]任务是启动。 2021-04-07 15：12：17.799 [1617833475626845 / start / 1（PID 42039）]任务成功完成。 2021-04-07 15：12：17.808 [1617833475626845 /端/ 2（PID 42199）]任务开始。 2021-04-07 15：12：19.046 [1617833475626845 /端/ 2（PID 42199）]任务成功完成。 2021-04-07 15：12：19.047完成！</p><p> We can now see that our procedure level variances have been filtered appropriately and we no longer have corrupt procedure codes in our dataset, first grabbing it using the run path:</p><p> 我们现在可以看到我们的过程级别差异已被适当过滤，我们在我们的数据集中不再有损坏的程序代码，首先使用运行路径抓取它：</p><p>   index code price 0 679855 CPT® 78710,103 0.000 1 679856 CPT® 78710,104 0.000 2 679857 CPT® 78710,105 0.000 3 679858 CPT® 78710,106 0.000 4 679859 CPT® 78710,107 0.000  ... ... ... 1176681 2190407 HCPCS C1769,15784 5886.125 1176682 2190408 HCPCS C1769,15785 5886.125 1176683 2190409 HCPCS C1769,15786 5886.125 1176684 2190410 HCPCS C1769,15787 5886.125 1176685 2190411 HCPCS C1769,15788 5886.125 [1176686 rows x 3 columns]</p><p>   索引代码价格0 679855CPT®78710,1030.000 1 679856CPT®78710,104 0.000 2 679857CPT®78710,1050.000 3 679858CPT®78710,1060.000 4 679859CPT®78710,1070.000 ......。 .. 1176681 2190407 HCPCS C1769,15784 5886.125 1176682 2190408 HCPCS C1769,15785 5886.125 1176683 2190409 HCPCS C1769,15786 5886.125 1176684 2190410 HCPCS C1769,15787 5886.125 1176685 2190411 HCPCS C1769,15788 5886.125 [1176686行×3列]</p><p> By simply retrieving a run path, and kicking off our variances flow, we were able to reproduce the exact inputs of a historical run.</p><p> 通过简单地检索运行路径，并缩小我们的差异流，我们能够重现历史运行的确切输入。</p><p>  In the previous section we showed how to run one Flow using the inputs of a previous run. We did this to achieve data version isolation for the purposes of testing our code changes. The same mechanism we used for achieving this kind of reproducibility also allows us to track data lineage. Recall that our pipeline has two steps, each a separate flow:</p><p>  在上一部分中，我们展示了如何使用以前运行的输入运行一个流。我们这样做是为了实现数据版本隔离，以便测试我们的代码更改。我们用于实现这种再现性的相同机制也允许我们跟踪数据谱系。回想一下，我们的管道有两个步骤，每个步骤单独的流量：</p><p>  Obviously a real world example might have a much more complicated data dependency graph, making this kind of tracking all the more important. Let’s see how we would trace the lineage of the final variances. The first thing to do is grab the run that created the current production data:</p><p>  显然，一个真实的世界例可能具有更复杂的数据依赖性图表，使这种跟踪更重要。让我们看看我们如何追溯最终差异的血统。首先要做的是创建当前生产数据的运行：</p><p>    We now have the run ID of the flow that produced our variances. We can access the flow that wrote the medians in a similar manner:</p><p>    我们现在拥有生产差异的流的运行ID。我们可以以类似的方式访问写入中位数的流程： </p><p>    As a final step we can pull at the input data, since we stored in Dolt:</p><p>作为最后一步，我们可以在输入数据上提取，因为我们存储在DOLT中：</p><p>   Out[10]:   npi_number ... price 0 1053358010.0 ... 75047.00 1 1336186394 ... 75047.00 2 1003139775.0 ... 457.23 3 1053824292.0 ... 972.00 4 1417901406.0 ... 296.00  ... ... ... 72724847 1184897647 ... 3724.00 72724848 1003858408 ... 96.11 72724849 1003858408 ... 94.53 72724850 1598917866 ... 22.00 72724851 1598917866 ... 15.40 [72724852 rows x 4 columns]</p><p>   [10]：NPI_NUMBER ...价格0.0.0 ... 75047.00 2 1003139775.0 ... 4572775.0 ... 972.00 4 1417901406.0 ... 296.00 ... ... ... 72724847 94.11 72724849 15989178081C ... 15.4015989178601598917860159989178601915989178661/12.1598917866 ... 15.40 [72724866159891786612/12.00</p><p> By storing Metaflow results in Dolt, result sets can be associated with flows and the input datasets. When results from Metaflow are put into other data stores we don’t have a way to trace the table back to flow run that produced it.</p><p> 通过将MetaFlow存储在DOLT中，结果集可以与流和输入数据集相关联。当Metaflow的结果被放入其他数据存储时，我们没有办法将桌面追踪回生成的流程运行。</p><p>  In this post we demonstrated how to use Dolt alongside Metaflow. Metaflow provides a framework for defining data engineering and data science workflows. Using Dolt for inputs and outputs augments pipelines defined in Metaflow with additional capabilities. Users can examine a table in their Dolt database and locate the flow that produced that table, and if that flow used Dolt as an input, locate the flows that rate the input data, and so on. Users can also run a flow pinning a historical version of the data, providing for reproducible runs that use data version isolation to ensure code changes are properly tested. Finally, when Dolt is used as an input the commit graph can be used for back-testing against historical versions of the data.</p><p>  在这篇文章中，我们演示了如何使用MetaFlow的DOLT。 Metaflow提供了一个框架，用于定义数据工程和数据科学工作流程。使用DOLT用于输入和输出增强了MetaFlow中定义的管道，具有额外的功能。用户可以在其DOLT数据库中检查表，并找到产生该表的流程，如果该流量使用DOLT作为输​​入，则定位速率输入数据的流量，等等。用户还可以运行流程钉入数据的历史版本，提供可重复的运行，使用数据版本隔离以确保正确测试代码更改。最后，当DOLT用作输入时，提交图可以用于对数据的历史版本的返回测试。</p><p> If you want to learn more about using Dolt with Metaflow, join the Dolt team on  Discord, or checkout the Metaflow  docs.</p><p> 如果您想了解有关使用MetaFlow的DOLT，请加入Doldord的Dolt团队，或结帐Metaflow Docs。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://dolthub.medium.com/version-controlled-data-pipelines-metaflow-dolt-79faf9eabef1">https://dolthub.medium.com/version-controlled-data-pipelines-metaflow-dolt-79faf9eabef1</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/控制数据/">#控制数据</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>