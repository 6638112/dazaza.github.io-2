<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>GDBWave–一个基于模拟后波形的RISC-V GDB调试服务器GDBWave – A Post-Simulation Waveform-Based RISC-V GDB Debugging Server</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">GDBWave – A Post-Simulation Waveform-Based RISC-V GDB Debugging Server<br/>GDBWave–一个基于模拟后波形的RISC-V GDB调试服务器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-22 11:25:40</div><div class="page_narrow text-break page_content"><p>A small soft core CPU is a great way to add control and management operations to an FPGA design. It’s muchfaster to iterate through different versions of some C code without changing RTL, and not needing to resynthesize can be a big time saver too (if you know  how to update RAM contents efficiently.)That’s why almost all my hobby FPGA projects have a  VexRiscv RISC-V CPU.</p><p>小型软核CPU是将控制和管理操作添加到FPGA设计中的好方法。在不改变RTL的情况下迭代不同版本的C代码是非常容易的，而且不需要重新合成也可以节省大量时间（如果您知道如何高效地更新RAM内容的话）这就是为什么我所有爱好的FPGA项目都有一个VexRiscv RISC-V CPU。</p><p> I recently wrote about how to  connect GDB to a VexRiscv CPU that’s running on the actual hardware by adding a JTAG interface. You can do something similar in simuation, by connectingGDB to OpenOCD which talks to the simulation over a faked JTAG interface. This blog post is not about that.</p><p>我最近写了一篇关于如何通过添加JTAG接口将GDB连接到实际硬件上运行的VexRiscv CPU的文章。您可以在模拟中做类似的事情，将GDB连接到OpenOCD，OpenOCD通过伪造的JTAG接口与模拟对话。这篇博文不是关于这个的。</p><p> Instead, I want to talk about first simulating an RTL design that contains of soft CPU, and debugging the firmware that ran on that soft CPU  after the simulation has completed.</p><p>相反，我想讨论的是，首先模拟一个RTL设计，其中包含一个软CPU，并在模拟完成后调试在该软CPU上运行的固件。</p><p> I usually don’t have a JTAG interface in my designs: I’m often just too lazy to wire up a USB JTAG dongle to the FPGA board. But what I do all the time is to look at simulation waveforms and try to figure out what the CPU was doing at a particular point in the simulation. Or the other way around, I try to figure out what the hardware was doing when the CPU was executing a particular line of code.</p><p>我的设计中通常没有JTAG接口：我常常懒得把USB JTAG加密狗连接到FPGA板上。但我一直在做的是查看模拟波形，并试图找出CPU在模拟中某个特定点的工作。或者反过来说，我试图弄清楚CPU执行特定代码行时硬件在做什么。</p><p>   It’s a tedious process and it’s near impossible to get a bigger view of what’s going on in the CPU because there’s noeasy way to dump the contents of the program call stack, variables, registers etc.</p><p>这是一个乏味的过程，几乎不可能更全面地了解CPU中正在发生的事情，因为没有简单的方法来转储程序调用堆栈、变量、寄存器等的内容。</p><p> I was wondering how others handled this kind of debugging and fired off  the following Tweet:</p><p>我想知道其他人是如何处理这种调试的，并发出了以下推文：</p><p> Question: you are simulating a RISC-V CPU that is running a C program. You are recording a VCD (or FST) trace. How do you correlate between the instruction address in the waveform and the line of C code?</p><p>问题：您正在模拟运行C程序的RISC-V CPU。您正在录制VCD（或FST）跟踪。波形中的指令地址和C代码行之间有什么关联？</p><p>— Tom Verbeure (@tom_verbeure)  November 3, 2021</p><p>- Tom Verbeure（@汤姆维尔贝雷）2021年11月3日</p><p>  Use  addr2line, part of the GCC toolchain, or  llvm-symbolizer to translate the PC value straight to the C source code file and line number.</p><p>使用GCC工具链的一部分addr2line或llvm Symboler将PC值直接转换为C源代码文件和行号。</p><p>  Expand the previous method by creating a GTKWave translate filter so that the file and line numbersare shown as an ASCII-encoded waveform in the waveform viewer itself.</p><p>通过创建GTKWave translate过滤器来扩展前面的方法，以便文件和行号在波形查看器本身中显示为ASCII编码的波形。</p><p>    Somebody pointed out that Quartus’ SignalTap has the option to show the active assembler instruction of a Nios II soft CPU in the waveform. This would definitely have been useful back when I was using Nios CPUs. It’s also something that can be done for RISC-V CPUs with a translate filter, but it’s not exactly what I was looking for.</p><p>有人指出，Quartus的SignalTap可以选择在波形中显示Nios II软CPU的活动汇编指令。这在我使用Nios CPU时肯定很有用。这也是可以为RISC-V CPU做的带有翻译过滤器的事情，但这并不是我想要的。</p><p>  @whitequark suggested adding a GDB serverto a CXXRTL simulation environment. This is a variant of connecting GDB to a live simulation through a simulated JTAG interface, but it still requires an interactive simulation session.</p><p>@whitequark建议将GDB服务器添加到CXXRTL模拟环境中。这是通过模拟JTAG接口将GDB连接到实时模拟的一种变体，但它仍然需要一个交互式模拟会话。</p><p> That last suggestion gave me the idea to  feed the waveform data into a GDB server:</p><p>最后一个建议让我想到将波形数据输入GDB服务器：</p><p> Yes. But the end result of that is the same as using OpenOCD and jtag_vpi, right? How about a GDB server that reads in a VCD file?</p><p>对但最终结果与使用OpenOCD和jtag_vpi是一样的，对吗？一台读取VCD文件的GDB服务器怎么样？</p><p>— Tom Verbeure (@tom_verbeure)  November 3, 2021</p><p>- Tom Verbeure（@汤姆维尔贝雷）2021年11月3日</p><p>  Two months and a good amount of Christmas vacaction hours later, the result is  GDBWave: a post-simulation waveform-based RISC-V GDB debugging server.</p><p>两个月后又过了几个小时，结果是GDBWave：一个基于模拟后波形的RISC-V GDB调试服务器。</p><p>  In my  VexRiscv, OpenOCD, and Traps blog post, I showed all the steps between a debugger IDE and an actual CPU. Let’s just say that for GDBWave the pictureis less complicated:</p><p>在我的VexRiscv、OpenOCD和Traps博客文章中，我展示了调试器IDE和实际CPU之间的所有步骤。让我们只说，对于GDB来说，图片不那么复杂：</p><p>  In a remote debug environment, GDB uses the GDB  Remote Serial Protocol (RSP) to talk to an external entity that is linked to the device under test. This external entity can come in two forms:</p><p>在远程调试环境中，GDB使用GDB远程串行协议（RSP）与链接到被测设备的外部实体进行对话。这种外部实体可以有两种形式：</p><p> A GDB remote stub (or GDB stub) is a piece of debug code that is linked to the program that is under debug. The stub code is usually called when there’s some kind of debug exception, an interrupt, or a trap, at which point it takes over and starts communication with GDB.</p><p>GDB远程存根（或GDB存根）是一段与正在调试的程序链接的调试代码。存根代码通常在出现某种调试异常、中断或陷阱时被调用，此时它接管并开始与GDB通信。</p><p>  This is a common way to debug embedded systems that don’t have an operating system and that don’t have the ability to use hardware in-circuit debugging features of the CPU. (E.g. because the JTAG port of the CPU isn’t available on the PCB.)</p><p>这是调试没有操作系统且无法使用CPU硬件电路调试功能的嵌入式系统的常用方法。（例如，因为CPU的JTAG端口在PCB上不可用。）</p><p>  A GDB server is a separate program that is not linked to be part of the program that must be debugged. It can be an intermediate program like OpenOCD that converts RSP commands to JTAG commands to control the hardware in-circuit debugging logic of the CPU, or it could be a separate process that uses operating system features on the target machine to debug another program. At good example of the latter is the  ptrace functionality in Unix-type operating systems. On these systems, the system native GDB often comes standard with a  gdbserver, which allows you to debug your Unix program remotely.</p><p>GDB服务器是一个独立的程序，没有链接到必须调试的程序的一部分。它可以是像OpenOCD这样的中间程序，将RSP命令转换为JTAG命令，以控制CPU的硬件电路内调试逻辑，也可以是一个单独的进程，使用目标机器上的操作系统功能调试另一个程序。后者的一个好例子是Unix类型操作系统中的ptrace功能。在这些系统上，系统本机GDB通常带有一个标准的gdbserver，它允许您远程调试Unix程序。</p><p> From the point of view of the GDB client, a GDB stub and a GDB server behave identical: they receive high-level RSP requests such as “step”, “continue”, “read CPU registers”, “write to memory”, or “set breakpoint”, adapt these requests to the environment in which the CPU is operating, and return requested data, if any.</p><p>从GDB客户端的角度来看，GDB存根和GDB服务器的行为是相同的：它们接收高级RSP请求，如“step”、“continue”、“read CPU registers”、“write to memory”或“set breakpoint”，使这些请求适应CPU运行的环境，并返回请求的数据（如果有的话）。</p><p> If you want to make GDB believe that your recorded CPU simulation waveform is an actually running CPU under debug, you need write your own GDB server:</p><p>如果您想让GDB相信您记录的CPU模拟波形是调试中实际运行的CPU，您需要编写自己的GDB服务器：</p><p>  There is quite a bit of generic boilerplate in there, and there are tons of open source GDB stubs that you can modify to your taste.  2 I list some of them in the  references below.</p><p>这里有相当多的通用样板，还有大量的开源GDB存根，您可以根据自己的喜好进行修改。2我在下面的参考文献中列出了其中一些。</p><p> GDBWave is written in C++ for a two of reasons: the FST library, written in C, doesn’t have any bindings to popular scripting languages, and I also just wanted to get a taste of some of the new C++ features that have been added to language since I last used it, more than 15 years ago…</p><p>GbWAVE是用C++编写的，原因有两个：FST库，用C编写，没有任何绑定到流行的脚本语言，我也只是想尝尝一些新的C++特性，自从我上次使用它以来，已经添加到语言中了，15多年前…</p><p> I settled on  mborgerson/gdbstub, a lightweight implementation that’s designed to make it easy to support your own CPU architecture. It’s so minimal that it doesn’t even support breakpoints, but those were easy to add.</p><p>我选择了mborgerson/GDBSub，这是一个轻量级的实现，旨在使其易于支持您自己的CPU体系结构。它非常小，甚至不支持断点，但这些断点很容易添加。</p><p>    Simulate a design that contains an embedded soft core RISC-V CPU such as the VexRiscv.</p><p>模拟一个包含嵌入式软核RISC-V CPU的设计，比如VexRiscv。</p><p>    Tell GDBWave which signals in the design can be used to extract the processor state: the CPU program counter, and, optionally, the contents of the CPU register file, and the transactions to memory.</p><p>告诉GDBWave设计中的哪些信号可用于提取处理器状态：CPU程序计数器，以及（可选）CPU寄存器文件的内容，以及到内存的事务。</p><p>  Launch GDBWave as a GDB server that pretends to be a real running CPU system with debug capabilities.</p><p>将GDBWave作为一个GDB服务器启动，它假装是一个真正运行的CPU系统，具有调试功能。</p><p>    Issue GDB commands as if you are dealing with a real CPU: breakpoints, watchpoints, line stepping through thecode, inspecting variables, you name it. You can even go back in time if you like.</p><p>发出GDB命令，就好像你在处理一个真正的CPU：断点、观察点、代码中的行步进、检查变量等等。如果你愿意，你甚至可以回到过去。</p><p> A super nice bonus feature would be link GDBWave to your GTKWave waveform viewer so that when your GDBWave CPU hits a breakpoint, GTKWave automatically jumps to that point in time in the waveform viewer. However, there are no obvious ways to control GTKWave by an external program.</p><p>一个非常好的额外功能是将GDBWave链接到你的GTKWave波形查看器，这样当你的GDBWave CPU遇到断点时，GTKWave会自动跳转到波形查看器中的那个时间点。然而，没有明显的方法可以通过外部程序控制GTKWave。</p><p> Note that all of this is possible without enabling any hardware debugging features in the simulated CPU: you can do this on a  picorv32 or the  award winning bit-serial SERVRISC-V CPUs and it will still work. The only minimum requirement is that you can find the right signalsin the RTL and in the waveform file to extract the program counter value of instructions that havebeen successfully executed and retired.  3</p><p>请注意，在模拟CPU中不启用任何硬件调试功能的情况下，所有这一切都是可能的：您可以在picorv32或获奖的位串行SERVRISC-V CPU上进行调试，它仍然可以工作。唯一的最低要求是，您可以在RTL和波形文件中找到正确的信号，以提取已成功执行和失效指令的程序计数器值。3.</p><p>  You can’t change the flow of the program that’s under debug. This is an obvious first principles consequence of running a debugger on data from a simulation that has already finished.</p><p>无法更改正在调试的程序的流程。这是对已经完成的模拟中的数据运行调试器的一个明显的首要原则结果。</p><p>  GDBWave currently only works with CPUs that have a single instruction, in-order execution pipeline. It’s not difficult to extend GDBWave support to more complex CPU architectures, but that’s outside the scope of this Christmas holiday project.</p><p>GDBWave目前仅适用于具有单个指令的CPU，以便执行管道。将GDBWave支持扩展到更复杂的CPU体系结构并不困难，但这超出了这个圣诞假期项目的范围。</p><p> This blog post talks about processor traces that are extracted from simulation waveforms, but you can also gather this data from real hardware if the CPU system in your design has instruction tracing capabilities such as those described in the  RISC-V Processor Trace specification.</p><p>这篇博客文章讨论了从模拟波形中提取的处理器跟踪，但如果您设计的CPU系统具有RISC-V处理器跟踪规范中描述的指令跟踪功能，那么您也可以从实际硬件中收集这些数据。</p><p>  In the hobby world, almost everybody dumps simulation waveforms as VCD files, a format standardized in theVerilog specification that is supported by nearly all simulation and digital design debugging tools in existence.GDBWave, however, doesn’t support VCD directly.</p><p>在业余爱好中，几乎每个人都将仿真波形作为VCD文件转储，这是Verilog规范中的标准格式，几乎所有现有的仿真和数字设计调试工具都支持这种格式。然而，GDBWave并不直接支持VCD。</p><p> There’s a good reason for that: being universally supported is about the only good characteristic of what is otherwise a terrible waveform format.</p><p>这有一个很好的理由：得到普遍支持是一种糟糕的波形格式的唯一优点。</p><p> It requires you to read in the full file even if you want to extract the values of a signal out of thousands or more signals.</p><p>即使要从数千个或更多信号中提取信号值，也需要读取完整文件。</p><p>  You also can’t extract values for a give time range without first processing the values of all time steps before that.</p><p>如果不先处理之前所有时间步长的值，也无法提取给定时间范围的值。</p><p> When you work for a company that can afford it, you’re probably using Synopsys Verdi to debug digital designs.Verdi comes with the FSDB waveform format which has none of the VCD disadvantages. Unfortunately, that format is proprietary and, to my knowledge, hasn’t been reverse engineered. If you want to write tools that extract data from FSDB files, you need to link a precompiled binary library that comes with the Verdi installation.</p><p>当你在一家负担得起的公司工作时，你可能正在使用Synopsys Verdi调试数字设计。Verdi配备了FSDB波形格式，它没有VCD的缺点。不幸的是，这种格式是专有的，据我所知，还没有经过逆向工程。如果想编写从FSDB文件提取数据的工具，需要链接Verdi安装附带的预编译二进制库。</p><p> Luckily, there’s an open source alternative: the FST format was developed by Tony Bybell, the author of GTKWave. It fixes all the flaws of the VCD format. There is no formal specification of the FST file format, but  “Implementation of an Efficient Method for Digital Waveform Compression”, a paper that is includedin the GTKWave manual, goes a long way to describe the design goals and how they were achieved:</p><p>幸运的是，有一个开源的替代方案：FST格式是由GTKWave的作者Tony Bybell开发的。它修复了VCD格式的所有缺陷。FST文件格式没有正式规范，但GTKWave手册中包含的“数字波形压缩有效方法的实现”一文在很大程度上描述了设计目标及其实现方式：</p><p> This is because it uses a two-stage compression scheme: in the first stage, it encodes signal value changes as delta values. During an optional second stage, the output of the first stage is compressed by the standard LZ4 or GZIP method.</p><p>这是因为它使用了两阶段压缩方案：在第一阶段，它将信号值的变化编码为增量值。在可选的第二阶段，第一阶段的输出通过标准LZ4或GZIP方法进行压缩。</p><p>  If you need to access data somewhere in the middle of a large simulation, it will only read in the chunks that contain the desired data, and skip whatever came before.</p><p>如果需要在大仿真的中间访问数据，它只会读取包含所需数据的块，并且跳过任何以前出现的数据。</p><p>  Compression speed is very fast and slows the simulation down by only a small amount compared to dumping a VCD file. The FST library comes even with multi-threading support. For very large designs that dump a lot of data, multiple chunks can compressed in parallel on different CPU cores. (Note that this is a bit slower on smaller cases. It’s only helpful when you’re dumping hundreds of thousand of signals and more.)</p><p>压缩速度非常快，与转储VCD文件相比，模拟速度只降低了一小部分。FST库甚至支持多线程。对于转储大量数据的超大设计，可以在不同的CPU内核上并行压缩多个数据块。（请注意，在较小的情况下，这会稍微慢一点。只有在转储数十万个或更多信号时，这才有帮助。）</p><p>  You don’t need to process the whole file before you can extract data from it.</p><p>在从中提取数据之前，不需要处理整个文件。</p><p>  This is really useful if you are running a very long running simulation and you want to quickly check if everything is still behaving as planned.</p><p>如果您正在运行一个长时间运行的模拟，并且希望快速检查是否一切仍按计划运行，那么这非常有用。</p><p>  There is no formal format specification, and, based on  a discussion on the GTKWave GitHub project, one shouldn’t expect there to ever be one. Other documentation only exists in the form of comments in the source code, or comments by the author on other GitHub issues.</p><p>没有正式的格式规范，而且，基于对GTKWave GitHub项目的讨论，人们不应该期望有一个正式的格式规范。其他文档仅以源代码中的注释或作者对其他GitHub问题的注释的形式存在。</p><p>  There is a library to read and write FST files, but there’s no documentation on how to use it. You’re expected to figure out how things work  by checking out existing utilities that read and write FST files.</p><p>有一个库可以读取和写入FST文件，但没有关于如何使用它的文档。您需要通过检查读写FST文件的现有实用程序来了解工作原理。</p><p>  In practice, it wasn’t too hard. I created   FstProcess, a C++ class that has the limited functionality that I need to extract data from an FST file.</p><p>实际上，这并不难。我创建了FSTPrPro，一个C++类，它具有有限的功能，我需要从FST文件中提取数据。</p><p>  There’s no stand-alone FST library with individual version tracking etc. You’re supposed to  extract the code from the GTKWave source tree.</p><p>没有一个独立的FST库具有单独的版本跟踪等功能。您应该从GTKWave源代码树中提取代码。</p><p>  Since the relevant code already lives in its own directory, extracting the code is easy. But the lack of versions makes it impossible to keep track of which  bug fixes been applied.</p><p>由于相关代码已经存在于自己的目录中，因此提取代码很容易。但由于缺乏版本，无法跟踪应用了哪些错误修复。</p><p>  Inexplicably, FST doesn’t support vector signals that don’t start with bit 0: a vector that is defined in RTL as  MySignal[31:2] gets saved as  MySignal[29:0]. This is not an issue for the vast majority of designs, but considering that it would take just 1 additional parameter in the signal declaration, this omission annoys me way more that it should.</p><p>令人费解的是，FST不支持不以位0开头的向量信号：在RTL中定义为MySignal[31:2]的向量被另存为MySignal[29:0]。对于绝大多数设计来说，这不是一个问题，但考虑到它只需要在信号声明中增加一个参数，这种省略让我更加恼火。</p><p> Still, the benefits ofu using the FST format far outweigh the disadvantages, especially if you’re dealing with huge waveform databases.</p><p>不过，使用FST格式的好处远远大于缺点，尤其是在处理大型波形数据库时。</p><p> Verilator and Icarus Verilog support FST out of the box. GTKWave does too, of course.If your simulation tool can’t generate FST files, you can always use the  vcd2fst conversion utilitythat comes standard with GTKWave.</p><p>Verilator和Icarus Verilog支持FST开箱即用。当然，GTKWave也是。如果您的模拟工具无法生成FST文件，则始终可以使用GTKWave附带的vcd2fst转换实用程序。</p><p> If you’re using the FST format as part of a Verilator testbench, make sure to NOT call the flush() method on the  VerilatedFstC trace object after each simulation cycle. I did this in one ofmy testbenches and  my simulation speed dropped by a factor of 20compared to using VCD!</p><p>如果您将FST格式用作Verilator测试台的一部分，请确保在每个模拟周期后不要对VerilatedFstC跟踪对象调用flush（）方法。我在我的一个测试台上做了这个，和使用VCD相比，我的模拟速度下降了20倍！</p><p>  This following sections goes into some of the implementation aspects of GDBWave. Some of this is for my own use so thatI don’t forget why things were done a certain way. You can safely skip this if all you’re interested in is using GDBWave for your own projects.</p><p>以下几节将介绍GDBWave的一些实现方面。其中一些是我自己用的，这样我就不会忘记为什么事情是以某种方式进行的。如果您感兴趣的只是在自己的项目中使用GDBWave，那么您可以安全地跳过这一步。</p><p>    As mentioned earlier, I created   FstProcess, a thin C++ wrapper around the native GTKWave  fstapi.h library.</p><p>正如前面提到的，我创建了FSTPrPro，一个围绕本地GTKWAVE FSTAPI的瘦C++包装器。h图书馆。</p><p>  At the very minimum, GDBWave needs to know which instructions have been successfully executed by the CPU.It does so by tracking the program counter.</p><p>GDBWave至少需要知道哪些指令已被CPU成功执行。它通过跟踪程序计数器来实现。</p><p> In the case of the VexRiscv, I use 2 signals that are present in all VexRiscv configurations:</p><p>在VexRiscv的情况下，我使用所有VexRiscv配置中存在的两个信号：</p><p>  When  lastStageIsValid is asserted,  lastStagePc contains the program counter value of an instruction that has completed execution. Perfect!</p><p>断言lastStageIsValid时，LastStageEPC包含已完成执行的指令的程序计数器值。完美的</p><p>  First, I  save the most up-to-date value of these 2 signals as I march through the waveform database:</p><p>首先，当我在波形数据库中行进时，我保存这两个信号的最新值：</p><p> if  ( signal -&gt; handle  ==  cpuTrace -&gt; pcValid . handle ) {  cpuTrace -&gt; curPcValidVal  =  valueInt ;  return ;  }  if  ( signal -&gt; handle  ==  cpuTrace -&gt; pc . handle ) {  cpuTrace -&gt; curPcVal  =  valueInt ;  return ;  }</p><p>if（signal-&gt；handle==cpuTrace-&gt；pcValid.handle）{cpuTrace-&gt；curPcValidVal=valueInt；return；}if（signal-&gt；handle==cpuTrace-&gt；pc.handle）{cpuTrace-&gt；curPcVal=valueInt；return；}</p><p> Second, when I see a falling edge of the clock,  I record the program counter if the  valid signal is asserted.All program counter values are stored in a vector array, along with the time stamp at which they changed.</p><p>其次，当我看到时钟的下降沿时，如果有效信号被断言，我会记录程序计数器。所有程序计数器值都存储在向量数组中，以及它们更改的时间戳。</p><p> if  ( signal -&gt; handle  ==  cpuTrace -&gt; clk . handle  &amp;&amp;  valueInt  ==  0 ) {  if  ( cpuTrace -&gt; curPcValidVal ) {  PcValue  pc  =  {  time ,  cpuTrace -&gt; curPcVal  } ;  cpuTrace -&gt; pcTrace . push_back ( pc );  }  }</p><p>if（signal-&gt；handle==cpuTrace-&gt；clk.handle&amp；valueInt==0）{if（cpuTrace-&gt；curPcValidVal）{PcValue pc={time，cpuTrace-&gt；curPcVal}；cpuTrace-&gt；pcTrace。向后推（pc）；}</p><p> Why the falling edge of the clock? Because in a clean, synchronous design, all regular signals change at the rising edge of the clock and you can be certain that all signals will be stationary at the falling edge. You don’t have toworry about whether or not the clock was rising immediately before or after a functional signal changed. It justmakes things less error prone.</p><p>为什么时钟会下降？因为在一个干净、同步的设计中，所有常规信号都会在时钟的上升沿发生变化，你可以确定所有信号都会在下降沿保持静止。你不必担心时钟是在功能信号改变之前还是之后立即上升。它只是让事情不那么容易出错。</p><p>  Knowledge of CPU register file contents is essential if you want to track the value of local variablesthat are never stored to memory. For example, chances are very high that the counter variable of a tight  for loop only ever lives in a CPU register.</p><p>如果要跟踪从未存储到内存中的局部变量的值，了解CPU寄存器文件内容是必不可少的。例如，紧For循环的计数器变量只存在于CPU寄存器中的可能性非常高。</p><p> To know the state of the register file, it’s sufficient to record only the writes to it, as long asyou know the initial state of the full register file at the start of the simulation. But evennot knowing the initial state is usually not a big deal, because most CPU startup code will initializeits registers by writing an appropriate value.</p><p>要知道寄存器文件的状态，只要在模拟开始时知道完整寄存器文件的初始状态，只记录对它的写入就足够了。但即使不知道初始状态通常也没什么大不了的，因为大多数CPU启动代码都会通过写入适当的值来初始化寄存器。</p><p>   The  code toextract register file writes from the FST waveform is as straightforward as the one to extractprogram counter changes.</p><p>从FST波形中提取寄存器文件写入的代码与提取程序计数器更改的代码一样简单。</p><p>  Finally, there’s the knowledge of the RAM contents on which the CPU operates. GDB issues memory reads for a couple of reasons: to know the value of variables that are stored in RAM, to inspect the call stack of arunning program, and to disassemble the code that it is debugging.</p><p>最后，还有CPU操作的RAM内容的知识。GDB发出内存读取有两个原因：了解存储在RAM中的变量的值，检查arunning程序的调用堆栈，以及分解正在调试的代码。</p><p> Memory contents can also be derived from the writes to memory, but, contrary to the register file, it’s really important to know the initial state of the RAM as well. That’s because the FPGA RAM that’s used tostore the CPU instructions is usually preloaded after powering up and never written.</p><p>内存内容也可以从对内存的写入中派生出来，但是，与寄存器文件相反，了解RAM的初始状态也非常重要。这是因为用于存储CPU指令的FPGA RAM通常在通电后预加载，并且从未写入。</p><p>    To get the initial state of the RAM, my firmware  Makefile  creates a binary filewith the contents of the RAM:</p><p>为了获得RAM的初始状态，我的固件Makefile创建了一个包含RAM内容的二进制文件：</p><p>   if  ( ! memInitFilename . empty ()){  printf ( &#34;Loading mem init file: %s \n &#34; ,  memInitFilename . c_str ());  ifstream  initFile ( memInitFilename ,  ios :: in  |  ios :: binary );  memInitContents  =  vector &lt; char &gt; (( std :: istreambuf_iterator &lt; char &gt; ( initFile )),  std :: istreambuf_iterator &lt; char &gt; ());  }</p><p>if（！memInitFilename.empty（））{printf（&#34；正在加载meminit文件：%s\n&#34；，memInitFilename.c#str（））；ifstream initFile（memInitFilename，ios:：in | ios:：binary）；memInitContents=vector&lt；char&gt；（（std:：istreambuf#迭代器&lt；char&gt；（initFile）），std:：istreambuf迭代器&lt；char&gt；）</p><p> In the future, I might extend GDBWave to read ELF files directly, but the current method works well enough for me.</p><p>将来，我可能会扩展GDBWave来直接读取ELF文件，但目前的方法对我来说已经足够好了。</p><p> Note that it’s also possible to figure out the contents of the program RAM iteratively by observingread transactions on the CPU instruction fetch bus. The only problem is that you can’t disassemble sectionsthat have never been executed by the CPU. In practice, I don’t think this would be a major issue:looking at the low level assembly code in GDB isn’t something I do very often, especially for code that never gets executed. Still, most of the time you’ll have access to the binary file of a program that you’re tryingto debug, so I didn’t go through the trouble, yet, to look at the instruction read transactions…</p><p>注意，也可以通过CPU指令获取总线上的observingread事务来迭代地计算程序RAM的内容。唯一的问题是你不能分解从未被CPU执行过的部分。在实践中，我不认为这是一个主要问题：在GDB中查看低级汇编代码不是我经常做的事情，尤其是对于从未执行过的代码。不过，大多数情况下，你都可以访问你试图调试的程序的二进制文件，所以我没有遇到麻烦，但是，看看指令读取事务…</p><p>   As soon as a TCP/IP connection with the GDB client has been established, the server sends a RSP signal packet to inform the client about the current execution state of the CPU. In GDBWave, that execution state is HALT. Afterthat, GDBWave enters an endless loop where it waits for RSP commands, and executes them as they arrive.</p><p>一旦与GDB客户端建立了TCP/IP连接，服务器就会发送一个RSP信号包，通知客户端CPU的当前执行状态。在GDBWave中，执行状态为暂停。之后，GDBWave进入一个无休止的循环，等待RSP命令，并在它们到达时执行它们。</p><p>  In a GDB client, the “step” command moves to the next C instruction. In the RSP protocol, it executes just 1 assembler instruction.</p><p>在GDB客户机中，“step”命令移动到下一条C指令。在RSP协议中，它只执行一条汇编指令。</p><p>    After receiving this trap, the GDB client always queries the contents of the register file, so it makes sense to already get this data ready during the step operation.</p><p>在收到这个陷阱之后，GDB客户机总是查询寄存器文件的内容，因此在step操作期间准备好这些数据是有意义的。</p><p>  The state of the register file is derived by  replaying the register file write operations up to the point of the current instruction. Right now, this code is super inefficient: after every instruction step, I replay the register writes for all registers from the start, time and time again. It’d be very easy to optimize this code.</p><p>寄存器文件的状态是通过将寄存器文件的写入操作重放到当前指令的点来导出的。现在，这段代码效率非常低：在每一个指令步骤之后，我从一开始就一次又一次地重放所有寄存器的寄存器写入。优化这段代码很容易。</p><p>  After this, the behavior is just like “step”: the state of the register file is updated, and a TRAP is sent upstream to GDB.</p><p>在此之后，行为就像“步骤”：寄存器文件的状态被更新，陷阱被发送到上游的GDB。</p><p>    RSP breakpoints are used for more than just breakpoints that are explicitly set with the GDB breakpoint command. They are also used when you use the  next command: GDB sets a temporary breakpoint at the next line of your program.</p><p>RSP断点不仅仅用于使用GDB breakpoint命令显式设置的断点。在使用下一个命令时也会用到它们：GDB在程序的下一行设置一个临时断点。</p><p>  But even explicit breakpoints are being set and cleared all the time. I’m not really clear why GDB does that, but I assume it has to do with making things work with all kinds of weird embedded system configurations.</p><p>但即使是明确的断点也一直在设置和清除。我不太清楚GDB为什么会这样做，但我认为这与让各种奇怪的嵌入式系统配置都能正常工作有关。</p><p>  GDB makes a distinction between software and hardware breakpoints. Hardware breakpoints are dedicated hardware resources inside the CPU. If any, there are usually only on a few of them, and GDB will only use them if you explicitly ask for it with the “hbreak” command. A software breakpoint is usually achieved by replacing an regular instruction with some kind of trap instruction in the instuction RAM. (In the case of RISC-V, it’s the EBREAK instruction.) Once this trap is triggered, the GDB server is expected to replace the trap instruction with the original instruction, before continuing execution. You can have an unlimited number of software breakpoints. In practice, hardware breakpoints are only used when you’re debugging code that’s located in ROM.</p><p>GDB区分了软件断点和硬件断点。硬件断点是CPU内部的专用硬件资源。如果有的话，通常只有少数几个，只有在您使用“hbreak”命令明确请求时，GDB才会使用它们。软件断点通常是通过在指令RAM中用某种陷阱指令替换常规指令来实现的。（在RISC-V的情况下，它是EBREAK指令。）一旦触发该陷阱，GDB服务器将在继续执行之前用原始指令替换陷阱指令。您可以有无限数量的软件断点。实际上，硬件断点仅在调试ROM中的代码时使用。</p><p>  With all that said, when GDB asks the server to set a software breakpoint, all it cares about is that the breakpoint is dealt with by the server. GDBWave maintains an  associative array, indexed with the program counter, with all active breakpoints.</p><p>综上所述，当GDB要求服务器设置软件断点时，它所关心的只是断点由服务器处理。GDBWave维护一个关联数组，该数组由程序计数器索引，包含所有活动断点。</p><p>  Whenever the CPU comes to a halt, GDB tries to read the CPU registers. The state of the register file was already updated after doing a step or continue operation, so GDBWave needs to do is  return the requested data.</p><p>每当CPU停止时，GDB就会尝试读取CPU寄存器。在执行步骤或继续操作后，寄存器文件的状态已经更新，因此GDBWave需要做的是返回请求的数据。</p><p>  Reading sections of memory is another very popular GDB request: it is used to fetch the value of variables, the call stack, or the assembler instructions of code that’s being disassembled.</p><p>读取内存部分是另一个非常流行的GDB请求：它用于获取变量的值、调用堆栈或正在被反汇编的代码的汇编指令。</p><p>  In GDBWave, getting the value of a memory location at the particular time stamp is implemented very similar to the way it’s done for the register file: starting with the initial value that was loaded from the binary file,  all memory writes are applied up to the time stamp of </p><p>在GDBWave中，获取特定时间戳的内存位置值的实现方式与寄存器文件的实现方式非常相似：从二进制文件加载的初始值开始，所有内存写入都应用到</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/post/">#post</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cpu/">#cpu</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>