<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么并发性很难</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">为什么并发性很难</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-10 07:38:19</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/56a05dc5c975233a30baf94faf5b2661.png"><img src="http://img2.diglog.com/img/2020/11/56a05dc5c975233a30baf94faf5b2661.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Editor’s Note:  Concurrency is one of the hardest concepts for many developers to grasp, but it is an important concept to grasp in modern software development. In this excerpt from the first chapter of her book  Concurrency in Go , Katherine Cox-Buday discusses one of the most common issues with concurrent programming: race conditions.</p><p>编者按：对于许多开发人员来说，并发性是最难掌握的概念之一，但在现代软件开发中，它是一个需要掌握的重要概念。凯瑟琳·考克斯-布代(Katherine Cox-Buday)在她的《围棋中的并发性》(Conency In Go)一书的第一章中，讨论了并发编程中最常见的问题之一：竞争条件。</p><p>  Concurrent code is notoriously difficult to get right. It usually takes a few iterations to get it working as expected, and even then it’s not uncommon for bugs to exist in code for years before some change in timing (heavier disk utilization, more users logged into the system, etc.) causes a previously undiscovered bug to rear its head. Indeed, for this very book, I’ve gotten as many eyes as possible on the code to try and mitigate this.</p><p>并发代码是出了名的难以正确编写。通常需要几次迭代才能使其按预期工作，即便如此，在时间发生变化(更高的磁盘利用率、更多用户登录到系统等)之前，错误在代码中存在多年的情况并不少见。导致一个以前未被发现的虫子抬起头来。事实上，对于这本书，我已经尽可能多地关注代码，试图缓解这种情况。</p><p> Fortunately  everyone runs into the same issues when working with concurrent code. Because of this, computer scientists have been able to label the common issues, which allows us to discuss how they arise, why, and how to solve them.</p><p>幸运的是，每个人在使用并发代码时都会遇到相同的问题。正因为如此，计算机科学家已经能够将常见问题归类，这使我们能够讨论它们是如何产生的、为什么以及如何解决它们。</p><p>  A race condition occurs when two or more operations must execute in the correct order, but the program has not been written so that this order is guaranteed to be maintained.</p><p>当两个或多个操作必须以正确的顺序执行，但尚未编写程序以保证保持此顺序时，就会出现争用情况。</p><p> Most of the time, this shows up in what’s called a  data race, where one concurrent operation attempts to read a variable while at some undetermined time another concurrent operation is attempting to write to the same variable.</p><p>大多数情况下，这表现在所谓的数据竞争中，即一个并发操作试图读取一个变量，而在某个不确定的时间，另一个并发操作试图写入同一变量。</p><p>  1  var data  int 2  go  func() { // In Go, you can use the go keyword to run a  // function concurrently. Doing so creates  // what’s called a  goroutine.   3 data++ 4 }() 5  if data == 0 { 6 fmt.Printf(&#34;the value is %v.\n&#34;, data) 7 }</p><p>1var data int 2go func(){//在go中，您可以使用go关键字并发运行//函数。这样做会产生//所谓的大猩猩。3数据++4}()5如果数据==0{6 fmt.Printf(&#34；值为%v\n&#34；，data)7}。</p><p> Here, lines 3 and 5 are both trying to access the variable data, but there is no guarantee what order this might happen in. There are three possible outcomes to running this code:</p><p>在这里，第3行和第5行都试图访问变量数据，但不能保证访问的顺序。运行此代码有三种可能的结果：</p><p> “the value is 0” is printed. In this case, lines 5 and 6 were executed before line 3.</p><p>打印“the value is 0”(值为0)。在本例中，第5行和第6行在第3行之前执行。</p><p> “the value is 1” is printed. In this case, line 5 was executed before line 3, but line 3 was executed before line 6.</p><p>打印“Value is 1”(值为1)。在本例中，第5行在第3行之前执行，但第3行在第6行之前执行。</p><p> As you can see, just a few lines of incorrect code can introduce tremendous variability into your program.</p><p>正如您所看到的，仅仅几行不正确的代码就会给您的程序带来巨大的可变性。</p><p> Most of the time, data races are introduced because the developers are thinking about the problem sequentially. They assume that because a line of code falls before another that it will run first. They assume the goroutine above will be scheduled and execute before the  data variable is read in the  if statement.</p><p>大多数情况下，引入数据竞争是因为开发人员在按顺序考虑问题。他们认为，因为一行代码先落在另一行代码之前，所以它会先运行。它们假定上面的goroutine将在IF语句中读取DATA变量之前调度和执行。</p><p> When writing concurrent code, you have to meticulously iterate through the possible scenarios. Unless you’re utilizing some of the techniques we’ll cover later in the book, you have no guarantees that your code will run in the order it’s listed in the sourcecode. I sometimes find it helpful to imagine a large period of time passing between operations. Imagine an hour passes between the time when the goroutine is invoked, and when it is run. How would the rest of the program behave? What if it took an hour between the goroutine executing successfully and the program reaching the  if statement? Thinking in this manner helps me because to a computer, the scale may be different, but the relative time differentials are more or less the same.</p><p>在编写并发代码时，您必须仔细地迭代可能的场景。除非您正在使用我们将在本书后面介绍的一些技术，否则您无法保证您的代码将按照源代码中列出的顺序运行。我有时觉得想象两次手术之间有一段很长的时间是有帮助的。想象一下，从调用goroutine到运行Goroutine的时间间隔为一个小时。该程序的其余部分将如何运行？如果从Goroutine成功执行到程序到达if语句需要一个小时呢？这样想对我有帮助，因为对计算机来说，刻度可能不同，但相对时差大致相同。</p><p> Indeed, some developers fall into the trap of sprinkling sleeps throughout their code exactly because it seems to solve their concurrency problems. Let’s try that in the preceding program:</p><p>的确，一些开发人员陷入了在代码中散布休眠的陷阱，因为这似乎解决了他们的并发性问题。让我们在前面的程序中尝试一下：</p><p> 1  var data  int 2  go  func() { data++ }() 3 time.Sleep(1*time.Second)  // This is bad! 4  if data == 0 { 5 fmt.Printf(&#34;the value is %v.\n&#34; data) 6 }</p><p>1var data int 2 go func(){data++}()3次。睡眠(1*时间.秒)//这是错误的！4如果data==0{5 fmt.Printf(&#34；值为%v\n&#34；data)6}。</p><p> Have we solved our data race? No. In fact, it’s still possible for all three outcomes to arise from this program, just increasingly  unlikely. The longer we sleep in between invoking our goroutine and checking the value of data, the closer our program gets to achieving correctness — but this probability asymptotically approaches logical correctness; it will never be logically correct.</p><p>我们的数据竞赛解决了吗？不是的。事实上，这三种结果仍然有可能从这个项目中产生，只是可能性越来越小。我们在调用Goroutine和检查数据值之间停留的时间越长，我们的程序就越接近实现正确性-但这个概率逐渐接近逻辑正确性；它永远不会在逻辑上正确。</p><p> In addition to this, we’ve now introduced an inefficiency into our algorithm. We now have to sleep for one second to make it more likely we won’t see our data race. If we utilized the correct tools, we might not have to wait at all, or the wait could be only a microsecond.</p><p>除此之外，我们现在还在我们的算法中引入了一个低效。我们现在不得不睡一秒钟，这样我们就更有可能看不到我们的数据竞赛了。如果我们使用了正确的工具，我们可能根本不必等待，或者等待可能只有一微秒。</p><p> The takeaway here is that you should always target logical correctness. Introducing sleeps into your code can be a handy way to debug concurrent programs, but they are not a solution.</p><p>这里的要点是，你应该始终以逻辑正确性为目标。在代码中引入休眠可能是调试并发程序的一种便捷方式，但它们不是解决方案。</p><p> Race conditions are one of the most insidious types of concurrency bugs because they may not show up until years after the code has been placed into production. They are usually precipitated by a change in the environment the code is executing in, or an unprecedented occurrence. In these cases, the code seems to be behaving correctly, but in reality, there’s just a very high chance that the operations will be executed in order. Sooner or later, the program will have an unintended consequence.</p><p>争用条件是最隐蔽的并发错误类型之一，因为它们可能要在代码投入生产数年后才会出现。它们通常是由代码执行环境的变化或史无前例的发生引起的。在这些情况下，代码看起来运行正常，但实际上，操作按顺序执行的可能性很高。该计划迟早会产生意想不到的后果。</p><p>  Join the O’Reilly online learning platform. Get a free trial today and find answers on the fly, or master something new and useful.</p><p>加入O‘Reilly在线学习平台。今天就可以免费试用，快速找到答案，或者掌握一些新的有用的东西。</p><p>  Katherine is a computer scientist currently working at DigitalOciean. Her hobbies include software engineering, creative writing, Go (igo, baduk, weiquei), and music, all of which she pursues intermittently and with various levels of dedication.</p><p>凯瑟琳是一名计算机科学家，目前在DigitalOciean工作。她的爱好包括软件工程，创意写作，围棋(围棋，围棋，围棋)和音乐，所有这些她都断断续续地追求，并有不同程度的奉献。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/oreillymedia/why-concurrency-is-hard-f93104cad54b">https://medium.com/oreillymedia/why-concurrency-is-hard-f93104cad54b</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>