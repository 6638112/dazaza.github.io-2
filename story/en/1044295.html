<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>重建拼写检查器 Rebuilding the spellchecker</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rebuilding the spellchecker<br/>重建拼写检查器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-15 21:36:19</div><div class="page_narrow text-break page_content"><p>A few years ago I had a fun idea for a “weekend project”: pure-Ruby spellchecker. Ruby is my language of choice, and no-dependencies spellchecker seemed a small useful tool for the CI environment: for example, to check comments/docs spelling without installing any third-party software. I actually  could’ve pulled out the project in its limited scope (only English, only spot misspelled words without fixing, limited dictionary) with just a flat list of known words, but that’s not what happened.</p><p>几年前，我对“周末项目”有一个有趣的主意：纯Ruby拼写检查器。 Ruby是我选择的语言，对于CI环境，无依赖性拼写检查器似乎是一个有用的小工具：例如，无需安装任何第三方软件即可检查注释/文档的拼写。实际上，我可以在有限的范围内（只有英语，只能发现拼写错误的单词而不需要修复，仅限字典）退出项目，仅列出已知单词，但事实并非如此。</p><p> Back then, I decided to make a moderately generic tool, at least able to work with multiple languages. Fortunately (or so I believed!), there were many already existing and freely available spellchecking dictionaries distributed as LibreOffice and Firefox extensions. All of those dictionaries are in the format defined by the   Hunspell tool/library—which is an open-source library that is used for spellchecking in Libre/OpenOffice, Mozilla products (Firefox, Thunderbird), but also Google Chrome/Chromium, macOS, several Adobe products, and so on.</p><p> 那时，我决定制作一个中等程度的通用工具，至少能够使用多种语言。幸运的是（或者，我相信！），有许多已经存在并且免费提供的拼写检查字典，这些字典作为LibreOffice和Firefox扩展发布。所有这些字典均采用Hunspell工具/库定义的格式，该库是一个开放源代码库，用于Libre / OpenOffice，Mozilla产品（Firefox，Thunderbird）以及Google Chrome / Chromium，macOS，几种Adobe产品，等等。</p><p> The dictionaries looked like easy to reuse text files with some (“insignificant” as it seemed) metadata, and the whole “use Hunspell dictionaries from pure Ruby spellchecker” project  still felt like a “weekend-long” one, for the first few weekends. Only gradually the underwater complexity of the multilanguage word-by-word spellchecking uncovered. Eventually, I was distracted from the project and abandoned it, but I still had the fascination with the seemingly-simple, actually-mind-blowingly-complicated Hunspell, the software everybody used daily and hardly ever notice.</p><p> 字典看起来很容易重用带有某些（看起来“微不足道”）元数据的文本文件，并且整个“使用纯Ruby拼写检查器的Hunspell字典”项目在前几个周末仍然感觉像“周末”。 。逐渐发现了多语言逐字拼写检查的水下复杂性。最终，我从项目中分心了，放弃了它，但是我仍然对看似简单，实际上头脑混乱，非常复杂的Hunspell着迷，该软件是每个人每天都在使用且几乎没有注意到的软件。</p><p> The idea to dig deeper into it, to  understand it and  explain, grew on me and bothered me for quite some time. And what is a better way to understand something, if not to retell it in your own words? After several lazy and not very far-progressed attempts to write something Hunspell-alike (twice in Ruby, once in Rust, once in Python), eventually, in February 2020, the task I settled down to solve is: “explanatory rewrite” of the Hunspell into high-level language with a lot of comments. I achieved this goal by December 2020, with the first release of the  Spylls project:  the port of Hunspell’s core algorithms into modern, well-documented, well-structured Python.</p><p> 深入研究，理解和解释的想法在我心中兴起，并困扰了我一段时间。如果不用自己的话来复述某事，还有什么更好的理解方法呢？经过几次懒惰且进展不大的尝试，编写了类似Hunspell的东西（在Ruby中两次，在Rust中一次，在Python中一次），最终，在2020年2月，我安心解决的任务是： Hunspell变成了高级语言，带有很多注释。到2020年12月，我通过Spylls项目的第一个版本实现了这一目标：将Hunspell的核心算法移植到现代，文档完善，结构良好的Python中。</p><p> And now I want to share some insights of what I uncovered on the road: about spellchecking in general and Hunspell in particular.</p><p> 现在，我想分享一些我在旅途中发现的见解：关于一般的拼写检查，尤其是关于Hunspell的拼写检查。</p><p>  What is Hunspell, why is it significant, and why try to “explain” it (current article)</p><p>  什么是Hunspell，为何如此重要，以及为何尝试“解释”它（当前文章）</p><p>    How lookup (checking if the word is correct) works, and why it could be much more complicated than “just look in the list of the known words”</p><p>    查找（检查单词是否正确）的工作方式，以及为什么查找可能比“仅在已知单词列表中查找”复杂得多 </p><p>  How suggest (proposed fix for the incorrect word) works, and how hard it is to estimate its quality</p><p>建议（建议对不正确单词的修正）如何工作，以及评估其质量的难度</p><p>  A closer look into Hunspell’s dictionary format. It is the most widespread open dictionary format in the world, and we’ll see what linguistic and algorithmic information it  potentially can carry, and what part of it is actually used in existing dictionaries</p><p>  仔细研究Hunspell的字典格式。它是世界上使用最广泛的开放词典格式，我们将看到它可能包含的语言和算法信息，以及现有词典中实际使用的哪一部分</p><p>    Closing thoughts on the big picture of word-by-word spellchecker problem, and Hunspell’s approach to it</p><p>    关于逐字拼写检查器问题的概观的总结思想以及Hunspell的解决方法</p><p>  Note: The information on Hunspell’s origins and history is mostly my guesses, following partial and incomplete sources everywhere.</p><p>  注意：关于Hunspell的起源和历史的信息大部分是我的猜测，部分地方信息来源不完整。</p><p> Hunspell ( ), initially  Hungarian spellchecker, emerged as an alternative for previously existing aspell/ispell/myspell somewhere in 2002 (I guess?). It was created by László Németh, in a need of supporting languages with complicated suffixing/prefixing rules and word compounding (such as Hungarian). Hunspell’s design seemingly proved itself to be flexible enough to support most of the world’s languages, and in a few years, it became the most used spellchecker in the world. You have most probably used it even if you’ve never heard the name before today: Hunspell is the default spellchecking engine in Chrome and Firefox, Libre/OpenOffice, Adobe products, and macOS (not an exhaustive list). Dictionaries in Hunspell format exist for almost all actively used languages for which the concept of word-by-word spellchecking makes sense  1.</p><p> Hunspell（）最初是匈牙利语的拼写检查工具，在2002年替代了以前存在的aspell / ispell / myspell（我猜呢？）。它是由LászlóNémeth创建的，它需要支持具有复杂的后缀/前缀规则和单词复合功能的语言（例如匈牙利语）。 Hunspell的设计似乎证明了自己的灵活性，足以支持世界上大多数语言，并且在短短几年内，它成为了世界上使用最多的拼写检查器。即使您从未听说过这个名称，您也很有可能使用了它：Hunspell是Chrome和Firefox，Libre / OpenOffice，Adobe产品和macOS（不是详尽列表）中的默认拼写检查引擎。 Hunspell格式的字典适用于几乎所有活跃使用的语言，对于这些语言而言，逐字拼写检查的概念有意义。1。</p><p> Currently, Hunspell is maintained  on GitHub (repo has only around 1k stars, will you believe it?). It seems that maintenance is not that easy if you’ll weight the number of open issues and PRs, and the latest commits timeline: at the time of writing it (Jan 2021), the last commit to master was of May 2020, and the last release was 1.7 on Dec 2018. Hunspell’s codebase is mostly “old-school” C++. It is being slowly modernized and it has very few comments; there are thousands of two-branch  ifs to handle non-Unicode and Unicode text separately. There is also an attempt to rewrite Hunspell from scratch in a modern C++, which at some point was developed under the  hunspell GitHub organization. Now it is independent and called  nuspell (and, while not yet supporting all of the Hunspell features, already “achieved” version 4.2.0).</p><p> 目前，Hunspell是在GitHub上维护的（repo只有大约1千颗星，您相信吗？）。如果您要权衡未解决的问题和PR的数量以及最新的提交时间表，似乎维护起来并不容易：在撰写本文时（2021年1月），对master的最后一次提交是2020年5月，最新版本是2018年12月的1.7。Hunspell的代码库主要是“老式” C ++。它正在缓慢地现代化，几乎没有评论。成千上万的两个分支if分别处理非Unicode和Unicode文本。还尝试用现代C ++从头重写Hunspell，该C ++在某些时候是由hunspell GitHub组织开发的。现在，它是独立的，称为nuspell（并且虽然尚未支持所有Hunspell功能，但已经“实现”了4.2.0版）。</p><p> Obviously, there are open-source spellcheckers other than Hunspell. GNU aspell (that at one point was superseded by Hunspell, but still holds its ground in English suggestion quality), to name one of the older ones; but also there are novel approaches, like  SymSpell, claiming to be “1 million times faster” or ML-based  JamSpell, claiming to be much more accurate.</p><p> 显然，除了Hunspell之外，还有开源的拼写检查器。 GNU aspell（曾经被Hunspell取代，但在英语建议质量上仍然保持着自己的地位），以较早的名字命名；但是还有一些新颖的方法，例如SymSpell，声称“快一百万倍”，或者基于ML的JamSpell，声称更加准确。 </p><p> And yet, what makes Hunspell stand out is its coverage of the world’s languages. It is not ideal, but the amount of dictionaries ready to use immediately, and amount of  experience of dealing with typical problems and corner cases, coded into the codebase, is hard to beat.</p><p>然而，使Hunspell脱颖而出的是其对全球语言的报道。这不是理想的方法，但是要立即使用的字典数量以及处理典型问题和极端情况的经验（已编码到代码库中）很难被击败。</p><p>  As I’ve already stated above, the goal of the Spylls project was to create an  explanatory rewrite: E.g., the “retelling” of how Hunspell works in a way that is easy to follow and to play with.</p><p>  正如我上面已经说过的，Spylls项目的目标是创建一个说明性的重写：例如，“重新讲述” Hunspell如何以易于遵循和使用的方式工作。</p><p>  This complexity—and years of human work that was spent growing the project—is notoriously hard to follow through the Hunspell’s codebase and grasp in full.</p><p>  众所周知，这种复杂性以及用于开发该项目的大量人力工作很难遵循Hunspell的代码库并无法完全掌握。</p><p>  The way I have chosen was not, of course, the only one possible. I could’ve just read through the original code and write a series of articles (or, rather, a book?) on how it works. I could’ve thoroughly commented and republished the original source code. But I felt that  reimplementing is the only way of understanding what’s and why’s of the algorithms (at least for somebody not being a Hunspell’s core developer); and that implementation in a high-level language will allow focusing on words and language-related algorithms, not memory management or fighting with Unicode.</p><p>  我选择的方式当然不是唯一的一种可能。我可以通读原始代码，然后撰写一系列有关其工作原理的文章（或者更确切地说，是一本书？）。我可以彻底评论并重新发布原始源代码。但是我觉得重新实现是理解算法的内容和原因的唯一方法（至少对于不是Hunspell核心开发人员的人而言）；而且以高级语言实现的这种方法将允许您专注于单词和与语言相关的算法，而不是内存管理或与Unicode对抗。</p><p> Note that there are also a few “pragmatic” ports of Hunspell into other languages (in order to use it in environments where C++ dependency is undesireable), namely  WeCantSpell.Hunspell in C# and  nspell in JS (very incomplete); and aforementioned  nuspell can also be considered a “port” (from legacy C++ to a modern one).</p><p> 请注意，Hunspell还有一些“实用”的端口可以移植到其他语言中（以便在不希望C ++依赖的环境中使用它），例如C＃中的WeCantSpell.Hunspell和JS中的nspell（非常不完整）。前面提到的nuspell也可以看作是“端口”（从旧版C ++到现代的）。</p><p>  My language of choice is Ruby. It was also the first language that I’ve tried to port Hunspell into. I’d be happy to proceed with Ruby if my goal has been just a “pragmatic” library. And yet, when I decided that my goal is to make the knowledge of Hunspell’s algorithms accessible to a wide audience, I understood that Ruby is not the best choice: language reputation (slightly esoteric and mostly-for-web) would make my project lest noticeable; and my preferred coding style (mix of OO and functional, with lots of small immutable domain objects and fluent chains of iterators), while allowing me to be very effective, would make the code less accessible to other languages users.</p><p>  我选择的语言是Ruby。这也是我尝试将Hunspell移植到的第一语言。如果我的目标只是一个“实用”的库，我很乐意继续使用Ruby。但是，当我确定目标是让广大读者可以访问Hunspell算法的知识时，我知道Ruby不是最好的选择：语言声誉（有点深奥，大多是针对网络的）会使我的项目免于负担显;我偏爱的编码风格（OO和功能的混合，带有许多小的不可变域对象和流畅的迭代器链），虽然使我非常有效，但会使其他语言用户无法访问该代码。</p><p> What I needed was a high-level language, with as low boilerplate as possible; as mainstream as possible; as easy to experiment with and prototype as possible. Without diving into too much argument here, Python and modern JavaScript seemed to be the most suitable options, and, to be honest, Python was just closer to my soul. So, here we are!</p><p> 我需要的是一种高级语言，并尽可能减少样板。尽可能成为主流；尽可能容易地进行实验并制作原型。在这里无需过多讨论，Python和现代JavaScript似乎是最合适的选择，老实说，Python离我的灵魂更近了。所以，我们到了！ </p><p> The code style is mostly imperative (as it corresponds to how Hunspell is structured), with large-ish, but clearly structured methods, and a small number of classes/objects (mostly they are either “whole algorithm as a class” or almost-passive “structs” – or, in Python, dataclasses). I tried to limit myself in the usage of complex Python-specific features (like functools or itertools), but have a decent use of “list comprehensions” (as they are quite readable and Pythonic) and generators (lazy lists). Overall, I wanted the code to be good Python, but not too smart. Whether I succeeded, is up to you to decide.</p><p>代码风格主要是强制性的（因为它与Hunspell的结构相对应），带有大量但结构清晰的方法以及少量的类/对象（大多数是“整个算法作为类”或几乎是-被动的“结构” –或在Python中为数据类）。我试图限制自己使用复杂的特定于Python的功能（例如functools或itertools），但是对“列表理解”（因为它们很易读且Pythonic）和生成器（惰性列表）使用得体。总的来说，我希望代码是好的Python，但又不要太聪明。我是否成功，取决于您的决定。</p><p> Currently,  Spylls has  ≈1.5k lines of library code in 14 files. It conforms (with  some reservations) to all Hunspell’s integrational tests. Those tests look like a set of files each, consisting of “test dictionary + what words should be considered good, what words should be considered bad, what should be suggested instead of the bad words”, and there are  127 of such sets to pass. There are  2 thousand comment lines in the code, explaining thoroughly every detail of the algorithm and rendered at the  Spylls documentation site; note that besides docstrings at the beginning of each class and method, there are also inline comments in code—that’s why the documentation site uses custom theme with inline “Show code” feature.</p><p> 目前，Spylls在14个文件中具有约1.5k行的库代码。它符合（有些保留）所有Hunspell的集成测试。这些测试看起来像一组文件，每个文件包括“测试词典+哪些单词应被认为是好单词，哪些单词应被认为是不好的单词，应该建议什么来代替这些不好的单词”，并且有127种这样的设置可以通过。代码中有2000条注释行，详细解释了算法的每个细节，并在Spylls文档站点上进行了呈现。请注意，除了每个类和方法开头的文档字符串之外，代码中还包含内联注释，这就是文档站点使用具有内联“显示代码”功能的自定义主题的原因。</p><p>   In the  next series: An introduction to Hunspell’s “lookup” and “suggest” concepts; and deeper dive into the lookup.</p><p>   在下一个系列中：对Hunspell的“查找”和“建议”概念的介绍；并进一步深入查找。</p><p> Word-by-word spellchecking makes less sense for hieroghliphic languages like Chinese and Japanese; it is also problematic for languages where words aren’t separated by whitespaces, like Lao or Thai.  ↩</p><p> 逐字拼写检查对于中文和日文等汉字语言没有多大意义；对于单词之间没有空格分隔的语言（例如老挝语或泰语），这也存在问题。 ↩</p><p>  Share on:</p><p>  分享： </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://zverok.github.io/blog/2021-01-05-spellchecker-1.html">https://zverok.github.io/blog/2021-01-05-spellchecker-1.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/检查/">#检查</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hunspell/">#hunspell</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>