<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Überzug：用于在终端上绘制图像的CLI实用程序 Überzug: A CLI utility for drawing images on terminals</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Überzug: A CLI utility for drawing images on terminals<br/>Überzug：用于在终端上绘制图像的CLI实用程序 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-27 07:29:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/f870fef8540cf66a0830aef0cbf944c4.png"><img src="http://img2.diglog.com/img/2020/12/f870fef8540cf66a0830aef0cbf944c4.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Überzug is a command line utilwhich allows to draw images on terminals by using child windows.</p><p>Überzug是一个命令行实用程序，允许使用子窗口在终端上绘制图像。</p><p>           Note: You can improve the performance of image manipulation functionsby using  pillow-simd instead of pillow.</p><p>           注意：您可以通过使用枕头模拟而不是枕头来提高图像处理功能的性能。</p><p>  The communication is realised via stdin. A command is a request to execute a specific action with the passed arguments. (Therefore a command has to contain a key value pair &#34;action&#34;: action_name) Commands are separated with a line break.</p><p>  通过stdin实现通信。命令是使用传递的参数执行特定操作的请求。 （因此命令必须包含键值对＆＃34; action＆＃34 ;: action_name）命令之间用换行符分隔。</p><p>     Name: add Description: Adds an image to the screen. If there&#39;s already an image with the same identifier it will be replaced.</p><p>     名称：添加说明：将图像添加到屏幕。如果已经有一个具有相同标识符的图像，它将被替换。</p><p> Deprecated: replaced by scalers (this behavior is implemented by the default scaler contain) image will be resized (while keeping it&#39;s aspect ratio) if it&#39;s width is bigger than max width</p><p> 不推荐使用：如果缩放器的宽度大于最大宽度，则将被调整为缩放器（此行为由默认缩放器包含实现）将被调整大小（同时保持其宽高比）</p><p> Deprecated: replaced by scalers (this behavior is implemented by the default scaler contain) image will be resized (while keeping it&#39;s aspect ratio) if it&#39;s height is bigger than max height</p><p> 不推荐使用：如果缩放器的高度大于最大高度，则将被调整为缩放器（此行为由默认缩放器包含实现）将被调整大小（同时保持其宽高比）</p><p>    the centered position, if possible Specified as factor of the image size, so it should be an element of [0, 1].</p><p>    中心位置（如果可能）指定为图像大小的因数，因此应为[0，1]的元素。 </p><p>  Resizes the image that either the width matches the maximum width or the height matches the maximum height while keeping the image ratio.</p><p>调整图像的大小，使其宽度与最大宽度匹配或高度与最大高度匹配，同时保持图像比例。</p><p> Resizes the image to a size &lt;= the placement size while keeping the image ratio.</p><p> 在保持图像比例的同时，将图像调整为小于等于放置尺寸的尺寸。</p><p> Resizes the image to cover the entire area which should be filled while keeping the image ratio. If the image is smaller than the desired size it will be stretched to reach the desired size. If the ratio of the area differs from the image ratio the edges will be cut off.</p><p> 调整图像大小以覆盖应填充的整个区域，同时保持图像比例。如果图像小于所需的尺寸，它将被拉伸以达到所需的尺寸。如果面积比例不同于图像比例，则边缘将被切除。</p><p> The same as forced_cover but images won&#39;t be stretched if they are smaller than the area which should be filled.</p><p> 与forced_cover相同，但是如果图像小于应填充的区域，则不会拉伸图像。</p><p>     Just a reminder: This is a GPLv3 licensed project, so if you use any of these libraries you also need to license it with a GPLv3 compatible license.</p><p>     提醒一下：这是GPLv3许可的项目，因此，如果您使用这些库中的任何一个，则还需要使用GPLv3兼容许可证来许可它。</p><p>   First of all the library doesn&#39;t follow the posix standard, so you can&#39;t use it in any other shell than bash.</p><p>   首先，该库不遵循posix标准，因此您不能在bash之外的任何其他shell中使用它。</p><p>   Also there will be a function named  ImageLayer::{action_name} declared for each action.  Each of this function takes the key values pairs of the respective action as arguments.  Every argument of these functions has to be an associative key value pair.   ImageLayer::{action_name} [{key0}]=&#34;{value0}&#34; [{key1}]=&#34;{value1}&#34; ...  Executing such a function builds the desired command string according to the passed arguments and prints it to stdout.</p><p>   此外，还将为每个动作声明一个名为ImageLayer :: {action_name}的函数。每个函数都将各自操作的键值对作为参数。这些函数的每个参数都必须是关联的键值对。 ImageLayer :: {action_name} [{key0}] =＆＃34; {value0}＆＃34; [{key1}] =＆＃34; {value1}＆＃34; ...执行这样的函数会根据传递的参数构建所需的命令字符串，并将其打印到stdout。 </p><p>  First of all everything which isn&#39;t mentioned here isn&#39;t safe to use and won&#39;t necessarily shipped with new coming versions.</p><p>首先，这里没有提到的所有内容都不安全使用，并且不一定会随新的版本一起提供。</p><p>    Every key value pair of the add action is an attribute (except identifier). Changing one of it will lead to building and transmitting an add command  if the placement is visible. The identifier key value pair is implemented as a property and not changeable.</p><p>    添加操作的每个键值对都是一个属性（标识符除外）。如果放置位置可见，则更改其中之一将导致构建并传输添加命令。标识符键值对实现为属性，并且不可更改。</p><p>  the initial visibility state (if it&#39;s VISIBLE every attribute without a default value needs to be set)</p><p>  初始可见性状态（如果需要，则可以设置每个没有默认值的属性）</p><p>  the visibility state of this placement - setting it to VISIBLE leads to the transmission of an add command - setting it to INVISIBLE leads to the transmission of a remove command</p><p>  此放置位置的可见性状态-将其设置为VISIBLE导致发送添加命令-将其设置为INVISIBLE导致发送删除命令</p><p> Warning: The transmission of a command can lead to an IOError. (A transmission happens on assign a new value to an attribute of a visible Placement. The transmission is delayed till leaving a with-statement if lazy_drawing is used.)</p><p> 警告：传输命令可能会导致IOError。 （在向可见的Placement的属性分配新值时发生传输。如果使用lazy_drawing，则传输会延迟到退出with语句为止。）</p><p>  Canvas: Should either be used with a with-statement or with a decorated function. (Starts and stops the ueberzug process)</p><p>  画布：应该与带声明或装饰功能一起使用。 （启动和停止ueberzug进程）</p><p>    prevents the use of the same identifier multiple times, takes the same arguments as the Placement constructor (excluding canvas parameter)</p><p>    防止多次使用相同的标识符，采用与Placement构造函数相同的参数（canvas参数除外） </p><p> Decorator which returns a function which calls the decorated function with the keyword parameter canvas=this_canvas_object. Of course other arguments are also passed through.</p><p>装饰器返回一个函数，该函数使用关键字参数canvas = this_canvas_object调用修饰的函数。当然，其他论点也可以通过。</p><p>  Does the same as lazy_drawing. Additionally forces the redrawing of the windows to happen immediately.</p><p>  与lazy_drawing相同。此外，强制立即重新绘制窗口。</p><p> Transmit commands instantly on changing a placement. If it&#39;s disabled commands won&#39;t be transmitted till a lazy_drawing or synchronous_lazy_drawing with-statement was left or request_transmission(force=True) was called. Default: True</p><p> 在更改展示位置时立即发送命令。如果禁用的命令将不被发送，直到留下lazy_drawing或sync_lazy_drawing带状态语句或调用request_transmission（force = True）为止。默认值：True</p><p>     # process substitution example:ueberzug layer --parser bash  0&lt;   &lt;(   declare -Ap add_command=([action]=  &#34;add &#34; [identifier]=  &#34;example0 &#34; [x]=  &#34;0 &#34; [y]=  &#34;0 &#34; [path]=  &#34;/some/path/some_image0.jpg &#34;)   declare -Ap add_command=([action]=  &#34;add &#34; [identifier]=  &#34;example1 &#34; [x]=  &#34;10 &#34; [y]=  &#34;0 &#34; [path]=  &#34;/some/path/some_image1.jpg &#34;)  sleep 5   declare -Ap remove_command=([action]=  &#34;remove &#34; [identifier]=  &#34;example0 &#34;)  sleep 5  )  # group commands example:{  declare -Ap add_command=([action]=  &#34;add &#34; [identifier]=  &#34;example0 &#34; [x]=  &#34;0 &#34; [y]=  &#34;0 &#34; [path]=  &#34;/some/path/some_image0.jpg &#34;)  declare -Ap add_command=([action]=  &#34;add &#34; [identifier]=  &#34;example1 &#34; [x]=  &#34;10 &#34; [y]=  &#34;0 &#34; [path]=  &#34;/some/path/some_image1.jpg &#34;)  read  declare -Ap remove_command=([action]=  &#34;remove &#34; [identifier]=  &#34;example0 &#34;)  read}  | ueberzug layer --parser bash</p><p>     ＃进程替换示例：ueberzug layer --parser bash 0＆lt; ＆lt;（声明-Ap add_command =（[action] =＆＃34; add＆＃34; [identifier] =＆＃34; example0＆＃34; [x] =＆＃34; 0＆＃34; [y ] =＆＃34; 0＆＃34; [path] =＆＃34; /some/path/some_image0.jpg＆＃34;）声明-Ap add_command =（[action] =＆＃34; add＆＃34 ; [identifier] =＆＃34; example1＆＃34; [x] =＆＃34; 10＆＃34; [y] =＆＃34; 0＆＃34; [path] =＆＃34; / some /path/some_image1.jpg＆＃34;）睡眠5声明-Ap remove_command =（[action] =＆＃34;删除＆＃34; [identifier] =＆＃34; example0＆＃34;）睡眠5）＃组命令示例：{clarify -Ap add_command =（[action] =＆＃34; add＆＃34; [identifier] =＆＃34; example0＆＃34; [x] =＆＃34; 0＆＃34; [y] =＆＃34; 0＆＃34; [path] =＆＃34; /some/path/some_image0.jpg＆＃34;）声明-Ap add_command =（[action] =＆＃34; add＆ ＃34; [identifier] =＆＃34; example1＆＃34; [x] =＆＃34; 10＆＃34; [y] =＆＃34; 0＆＃34; [path] =＆＃34; /some/path/some_image1.jpg＆＃34;）读取声明-Ap remove_command =（[action] =＆＃34; remove＆＃34; [identifier] =＆＃34; example0＆＃34;）read} | ueberzug层--parser bash</p><p>   import  curses  import  time  from  curses. textpad  import  Textbox,  rectangle  import  ueberzug. lib. v0  as  ueberzug  @ ueberzug. Canvas()  def  main( stdscr,  canvas):  demo  =  canvas. create_placement( &#39;demo&#39;,  x = 10,  y = 0)  stdscr. addstr( 0,  0,  &#34;Enter IM message: (hit Ctrl-G to send)&#34;)  editwin  =  curses. newwin( 5,  30,  3,  1)  rectangle( stdscr,  2,  0,  2 + 5 + 1,  2 + 30 + 1)  stdscr. refresh()  box  =  Textbox( editwin)  # Let the user edit until Ctrl-G is struck.  box. edit()  # Get resulting contents  message  =  box. gather()  demo. path  =  &#39;&#39;. join( message. split())  demo. visibility  =  ueberzug. Visibility. VISIBLE  time. sleep( 2)  if  __name__  ==  &#39;__main__&#39;:  curses. wrapper( main)</p><p>   进口诅咒进口时间从诅咒开始。 textpad导入文本框，矩形导入ueberzug。库v0作为ueberzug @ ueberzug。 Canvas（）def main（stdscr，canvas）：演示= canvas。 create_placement（＆demo＆＃39;，x = 10，y = 0）stdscr。 addstr（0，0，＆＃34;输入IM消息：（按Ctrl-G发送）＆＃34;）editwin = curses。 newwin（5，30，3，1）矩形（stdscr，2，0，2 + 5 + 1，2 + 30 +1）stdscr。 refresh（）box = Textbox（editwin）＃让用户进行编辑，直到按下Ctrl-G为止。框。 edit（）＃获取结果内容message = box。 collect（）演示。路径=＆＃39;＆＃39;。 join（message。split（））演示。能见度= ueberzug。能见度。可见的时间。 sleep（2）如果__name__ ==＆＃39; __ main __＆＃39 ;:诅咒。包装器（主）</p><p> general example: import  ueberzug. lib. v0  as  ueberzug import  time if  __name__  ==  &#39;__main__&#39;:  with  ueberzug. Canvas()  as  c:  paths  = [ &#39;/some/path/some_image.png&#39;,  &#39;/some/path/another_image.png&#39;]  demo  =  c. create_placement( &#39;demo&#39;,  x = 0,  y = 0,  scaler = ueberzug. ScalerOption. COVER. value)  demo. path  =  paths[ 0]  demo. visibility  =  ueberzug. Visibility. VISIBLE  for  i  in  range( 30):  with  c. lazy_drawing:  demo. x  =  i  *  3  demo. y  =  i  *  3  demo. path  =  paths[ i  %  2]  time. sleep( 1 / 30)  time. sleep( 2)</p><p> 一般示例：导入ueberzug。库如果__name__ ==＆＃39; __ main __＆＃39 ;：带有ueberzug，则将v0作为ueberzug导入时间。 Canvas（）as c：路径= [＆＃39; /some/path/some_image.png&#39 ;，＆＃39; /some/path/another_image.png&#39;] demo = c。 create_placement（＆demo＆＃39;，x = 0，y = 0，缩放器=ueberzug。ScalerOption。覆盖值）演示。路径=路径[0]演示。能见度= ueberzug。能见度。对于i在范围（30）中可见：带有c。 lazy_drawing：演示。 x = i * 3演示。 y = i * 3个演示。 path = paths [i％2]时间。睡眠（1/30）时间。睡眠（2） </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/seebye/ueberzug">https://github.com/seebye/ueberzug</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/用于/">#用于</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cli/">#cli</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>