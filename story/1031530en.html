<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Next.js 10</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Next.js 10</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-28 00:31:01</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/e8225b4f9f3eb2fbb6ffdf69867f3c29.png"><img src="http://img2.diglog.com/img/2020/10/e8225b4f9f3eb2fbb6ffdf69867f3c29.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Built-in Image Component and Automatic Image Optimization: Automatically optimize images using the new  next/image component</p><p>内置映像组件和自动映像优化：使用新的Next/Image组件自动优化映像。</p><p>      Fast Refresh for MDX: When using  @next/mdx, Fast Refresh is now leveraged to apply changes without full page reloads</p><p>MDX的快速刷新：使用@Next/MDX时，现在可以利用快速刷新来应用更改，而无需重新加载整个页面。</p><p> Importing CSS from Third Party React Components: Importing CSS needed for components from npm is now supported</p><p>从第三方Reaction组件导入CSS：现在支持从NPM导入组件所需的CSS。</p><p>   Blocking Fallback for  getStaticPaths: Wait on pre-rendering when generating new static pages instead of serving a static fallback page</p><p>阻塞getStaticPath的回退：在生成新的静态页面时等待预呈现，而不是提供静态回退页面。</p><p>   This year we&#39;ve already invested heavily in both Developer Experience and improving performance for all Next.js applications. We focused on reducing the amount of JavaScript the browser has to load.</p><p>今年，我们已经在开发人员体验和提高所有Next.js应用程序的性能方面投入了大量资金。我们专注于减少浏览器必须加载的JavaScript数量。</p><p> We introduced over  20 new features that improve performance and developer experience. At the same time, the JavaScript size of the Next.js core has been  reduced by 16%.</p><p>我们引入了20多个改进性能和开发人员体验的新功能。同时，Next.js内核的JavaScript大小减少了16%。</p><p> In January, we introduced a new best-in-class JavaScript code-splitting strategy in collaboration with the Google Chrome team.</p><p>一月份，我们与Google Chrome团队合作，引入了一种新的同类最佳的JavaScript代码拆分策略。</p><p> For example, Barnebys saw a  23% decrease in application size, and Sumup had a  70% decrease in their largest Javascript bundle size. These improvements were achieved  without changing any code in their Next.js applications.</p><p>例如，Barnebys的应用程序大小减少了23%，SumUp的最大Javascript包大小减少了70%。这些改进是在不更改其Next.js应用程序中的任何代码的情况下实现的。</p><p>   While our focus on reducing the amount of JavaScript the browser has to load has paid off, the web is not only Javascript: it&#39;s also markup and images.</p><p>虽然我们对减少浏览器必须加载的JavaScript的关注得到了回报，但Web不仅仅是Javascript：它还包括标记和图像。</p><p>  Images have a big impact on Largest Contentful Paint as they&#39;re often the largest visible element when a page is loaded. Largest Contentful Paint is a Core Web Vital that Google will be using in their search ranking  very soon.</p><p>图片对最大的内容绘画有很大的影响，因为它们通常是页面加载时最大的可见元素。最大的内容绘画是核心网络的关键，谷歌很快就会在他们的搜索排名中使用它。</p><p> Half of all images are over one megabyte in size, which means they aren&#39;t optimized to be displayed on the web.</p><p>所有图片中有一半的大小超过1兆字节，这意味着它们没有经过优化，不适合在网络上显示。</p><p> Nowadays users browse the web using their phones, tablets, and laptops, yet images are still as a one size fits all. For example: sites load a 2000 by 2000 pixel image, but phones are only displaying it as 100 by 100 pixels.</p><p>如今，用户使用手机、平板电脑和笔记本电脑浏览网页，但图像仍然是一刀切的。例如：网站加载的是2000x2000像素的图像，但手机仅将其显示为100x100像素。</p><p> Furthermore, 30% of images on web pages are outside of the initial viewport, meaning the browser loads images that a user does not see until they scroll further down the page.</p><p>此外，网页上30%的图像位于初始视口之外，这意味着浏览器会加载用户在进一步向下滚动页面之前看不到的图像。</p><p> Images often don&#39;t have a  width and  height property, causing them to jump around when the page is loaded. This hurts the Cumulative Layout Shift Core Web Vital.</p><p>图像通常没有宽度和高度属性，导致它们在加载页面时跳来跳去。这对累积布局转变核心网络造成了至关重要的影响。</p><p>  In order to use images on web pages in a performant way a lot of aspects have to be considered: size, weight, lazy loading, and modern image formats.</p><p>为了在网页上高效地使用图像，必须考虑很多方面：大小、重量、延迟加载和现代图像格式。</p><p> Developers have to set up complicated build tooling to optimize images, however those tools usually don&#39;t cover user-submitted images coming from an external data source, making it impossible to optimize all images.</p><p>开发人员必须设置复杂的构建工具来优化图像，但是这些工具通常不包括来自外部数据源的用户提交的图像，因此不可能优化所有图像。</p><p>   We&#39;re excited to announce our solution to performant images on the web: the Next.js Image Component and Automatic Image Optimization.</p><p>我们很兴奋地宣布我们的解决方案，性能图像在网络上：Next.js图像组件和自动图像优化。</p><p> At it&#39;s most basic the Next.js Image Component is just a drop-in replacement for the HTML  &lt;img&gt; element, evolved for the modern web.</p><p>在最基本的情况下，Next.js Image组件只是HTML&lt；img&gt；元素的临时替代品，它是为现代网络而发展起来的。</p><p>   The Google Chrome team helped create this React Component to improve page performance by making best practices the default.</p><p>Google Chrome团队帮助创建了这个Reaction组件，通过将最佳实践作为默认设置来提高页面性能。</p><p> When using the  next/image component, images are automatically lazy-loaded, meaning they&#39;re only rendered when the user is close to seeing the image. This prevents loading that 30% of images outside of the initial viewport.</p><p>当使用Next/image组件时，图像会自动延迟加载，这意味着只有在用户接近看到图像时才会呈现它们。这样可以防止将30%的图像加载到初始视口之外。</p><p> Image dimensions are enforced, allowing browsers to immediately render the space needed for the image instead of having it jump in when loaded, preventing layout shift.</p><p>图像尺寸是强制的，允许浏览器立即呈现图像所需的空间，而不是在加载时跳入，从而防止布局移动。</p><p> While  width and  height on the HTML  &lt;img&gt; element can cause issues with responsive layouts,  this is not the case when using  next/image. When using  next/image the image is automatically made responsive based on the aspect ratio from the provided  width and  height.</p><p>虽然HTML&lt；img&gt；元素上的宽度和高度可能会导致响应布局出现问题，但在使用next/image时情况并非如此。使用NEXT/IMAGE时，图像会根据提供的宽度和高度的纵横比自动响应。</p><p> Developers can mark images that are in the initial viewport, allowing Next.js to automatically preload these images. Preloading images in the initial viewport has shown improvements to the Largest Contentful Paint by up to 50%.</p><p>开发人员可以标记初始视口中的图像，从而允许Next.js自动预加载这些图像。在初始视口中预加载图像对最大的内容绘画进行了高达50%的改进。</p><p>  Even with these improvements compared to the HTML  &lt;img&gt; element, there&#39;s still a major problem. The 2000 by 2000 pixel image is sent to phones that render a smaller image.</p><p>即使与HTML&lt；img&gt；元素相比有了这些改进，仍然存在一个主要问题。2000 x 2000像素的图像被发送到渲染较小图像的手机。</p><p> With Next.js 10 we&#39;re also solving that problem. The  next/image component will automatically generate smaller sizes through built-in Image Optimization.</p><p>随着Next.js10的问世，我们也在解决这个问题。NEXT/IMAGE组件将通过内置的映像优化自动生成较小的尺寸。</p><p> Built-in Image Optimization automatically serves the images in modern image formats like WebP, which is about 30% smaller than JPEG, if the browser supports it. It also allows Next.js to automatically adopt  future image formats and serve them to browsers that support those formats.</p><p>内置图像优化功能会自动以现代图像格式(如WebP)为图像提供服务，如果浏览器支持的话，WebP比JPEG小约30%。它还允许Next.js自动采用未来的图像格式，并将其提供给支持这些格式的浏览器。</p><p> Image Optimization works with any image source. Even if images come from an external data source, like a CMS, they are optimized.</p><p>图像优化适用于任何图像源。即使图像来自外部数据源，如CMS，它们也是经过优化的。</p><p> Instead of optimizing images at build time, Next.js 10 optimizes images on-demand, as users request them. Unlike static site generators and static-only solutions, your build times aren&#39;t increased, whether shipping 10 images or 10 million images.</p><p>Next.js10不是在构建时优化映像，而是在用户请求时按需优化映像。与静态站点生成器和纯静态解决方案不同，无论发送10个映像还是1000万个映像，您的构建时间都不会增加。</p><p>  The new  next/image component and Automatic Image Optimization are powerful new primitives that will massively improve user experience.</p><p>新的Next/Image组件和自动映像优化是功能强大的新原语，将极大地改善用户体验。</p><p> The  next/image component handles automatic lazy-loading, preloading of critical images, correct sizing across devices, and automatically supports modern formats. These features work with images from any source.</p><p>Next/image组件处理自动延迟加载、关键图像的预加载、跨设备正确调整大小，并自动支持现代格式。这些功能适用于任何来源的图像。</p><p> We are looking forward to seeing how much faster your user experience becomes with these new primites.</p><p>我们期待着看到您的用户体验在使用这些新Primite时会变得多快。</p><p>   This year, several businesses and community members helped our team understand how important internationalization is.</p><p>今年，几家企业和社区成员帮助我们的团队理解了国际化的重要性。</p><p> For example, we learned that 72% of consumers are more likely to stay on your site if it&#39;s been translated and 55% of consumers said they only buy from e-commerce sites in their native language.</p><p>例如，我们了解到，如果网站经过翻译，72%的消费者更有可能留在你的网站上，55%的消费者表示他们只从电子商务网站购买本国语言的商品。</p><p> If you plan to go to market in a different country, internationalizing your project is critical for success.</p><p>如果您计划在不同的国家投放市场，将您的项目国际化是成功的关键。</p><p>  Many React libraries prepare applications to be translated, but most of them expect you to handle routing manually, and generally only work with one rendering strategy.</p><p>许多Reaction库准备要翻译的应用程序，但它们中的大多数都希望您手动处理路由，并且通常只使用一种呈现策略。</p><p> That&#39;s why, as part of Next.js 10, we&#39;re releasing built-in support for internationalized routing and language detection.</p><p>这就是为什么，作为Next.js10的一部分，我们将发布对国际化路由和语言检测的内置支持。</p><p> This built-in support for internationalized routing supports Next.js&#39; hybrid strategy, so you can choose between Static Generation or Server-Rendering on a per-page basis.</p><p>这种对国际化路由的内置支持支持Next.js&#39；混合策略，因此您可以在基于每个页面的静态生成或服务器呈现之间进行选择。</p><p>     Generally a Locale Identifier is made up of a language, region, and script separated by a dash:  language-region-script. The region and script are optional. An example:</p><p>通常，区域设置标识符由由破折号分隔的语言、区域和脚本组成：Language-Region-Script。区域和脚本是可选的。例如：</p><p>    Subpath routing puts the locale in the url. This allows all languages to live on a single domain.</p><p>子路径路由将区域设置放在URL中。这使得所有语言都可以存在于单个域中。</p><p>   Domain routing enables you to map a locale to a top level domain. For example   example.nl can be mapped to the  nl locale and   example.com can be mapped to the  en locale.</p><p>域路由使您能够将区域设置映射到顶级域。例如，example.nl可以映射到NL区域设置，example.com可以映射到EN区域设置。</p><p>  // next.config.jsmodule . exports  =  { i18n :  { locales :  [ &#39;en&#39; ,  &#39;nl&#39; ] , domains :  [  { domain :  &#39;example.com&#39; , defaultLocale :  &#39;en&#39;  } ,  { domain :  &#39;example.nl&#39; , defaultLocale :  &#39;nl&#39;  }  ]  } }</p><p>//next.config.jsmodule。Exports={i18n：{locales：[&#39；en&#39；，&#39；nl&#39；]，域名：[{domain：&#39；example.com&#39；，defaultLocale：&#39；en&#39；}，{domain：&#39；example.nl&#39；，defaultLocale：&#39；nl&#39；}]}}。</p><p>  Next.js 10 has built-in language detection on the  / route based on the  Accept-Language header, which all modern browsers support. The configured locales will be matches against the  Accept-Language header and then redirect according to the configured strategy.</p><p>Js10在/route上内置了基于Accept-Language标头的语言检测，所有现代浏览器都支持这一点。配置的区域设置将与Accept-Language标头匹配，然后根据配置的策略进行重定向。</p><p>  Since Next.js knows the language of the page visited by the user, it will automatically add the lang attribute to the  &lt;html&gt; tag.</p><p>因为Next.js知道用户访问的页面的语言，所以它会自动将lang属性添加到&lt；html&gt；标记。</p><p> Next.js doesn&#39;t know about variants of a page so it&#39;s up to you to add the  hreflang meta tags using  next/head. You can learn more about  hreflang in the  Google Webmasters documentation.</p><p>Js并不知道页面的变体，所以是否使用next/head添加hrefang元标记取决于您。您可以在Google网站管理员文档中了解更多关于hrefang的信息。</p><p>  Internationalized Routing is the first in a series of features that will make internationalizing and localizing your project easier. Internationalized Routing allows for integrating with the majority of React internationalization libraries.</p><p>国际化路由是一系列功能中的第一个，这些功能将使您的项目更容易国际化和本地化。国际化路由允许与大多数REACT国际化库集成。</p><p>    Your visitors have grown increasingly sensitive to site performance. More than 50% of them will abandon your website  if it takes more than 3 seconds to load. If you&#39;re in e-commerce, many have found that improving your load time by 1/10th of a second resulted in a  1% increase in conversion.</p><p>您的访问者对站点性能越来越敏感。如果你的网站加载时间超过3秒，超过50%的人会放弃你的网站。如果你从事电子商务，很多人发现，将你的加载时间提高1/10秒，转化率会增加1%。</p><p> Because of how critical performance is to your success, we&#39;re proud to release Next.js Analytics. The solution for tracking real-world performance metrics and feeding those insights back into your development workflow.</p><p>由于性能对您的成功至关重要，我们很自豪地发布Next.js Analytics。用于跟踪真实性能指标并将这些洞察力反馈到您的开发工作流中的解决方案。</p><p>   Instead of measuring on your development device,  measurements will come from the actual devices that your visitors are using.</p><p>度量将来自您的访问者正在使用的实际设备，而不是在您的开发设备上进行测量。</p><p> Next.js Analytics is about focusing on the entire picture, deeply understanding your audience, and how your application performs for your users.</p><p>Next.js Analytics关注整体情况，深入了解您的受众，以及您的应用程序如何为您的用户执行操作。</p><p> We&#39;re so adamant about collecting real data because the causes of poor performance aren&#39;t always the most obvious. Performance regressions can result from a variety of places— third-party scripts and stylesheets, or first-party fonts, images, and videos that are oversized or slow.</p><p>我们对收集真实数据非常坚决，因为业绩不佳的原因并不总是最明显的。性能下降可能由多种原因引起-第三方脚本和样式表，或者第一方字体、图像和视频过大或过慢。</p><p>  Google, in conjunction with the  Web Performance Working Group, have established the set of metrics to accurately measure how users experience the performance of your website: aptly named, Web Vitals. Web Vitals are metrics that track the perceived loading speed, responsiveness, and visual stability of your website—all three essential for website&#39;s overall health!</p><p>Google与Web性能工作组合作，建立了一套准确衡量用户体验网站性能的指标：Web Vitals，这是一个恰当的名称。Web Vitals是跟踪您网站的感知加载速度、响应速度和视觉稳定性的指标-所有这三项对网站的整体健康状况都是必不可少的！</p><p> Perceived loading speed can be measured by Largest Contentful Paint, or when all the page&#39;s content has been displayed. For example, when I open a link to buy a pair sneakers—the amount of time that passes before I see my sneakers, their price, and the add to cart button is LCP.</p><p>感知的加载速度可以通过最大的内容油漆来测量，或者当页面的所有内容都已显示时。例如，当我打开一个购买运动鞋的链接-在我看到我的运动鞋之前的时间，它们的价格，添加到购物车按钮是LCP。</p><p> Page responsiveness can be measured by First Input Delay, which measures how long your users must wait to see the reaction of their first interaction with the page. For example, the amount of time between me clicking Add to Cart and the number of items in my cart incrementing is FID.</p><p>页面响应性可以通过第一次输入延迟来衡量，该延迟衡量用户必须等待多长时间才能看到他们第一次与页面交互的反应。例如，我单击“添加到购物车”和购物车中的物品数量递增之间的时间量是FID。</p><p> Finally, visual stability can be measured by Cumulative Layout Shift, or how much elements move after being displayed to the user. For example, we&#39;ve all experienced the frustration of trying to tap a button that moved because an image loaded late—that&#39;s layout shift.</p><p>最后，视觉稳定性可以通过累计布局移位或元素在显示给用户后的移动量来衡量。例如，我们都经历过因为图像加载晚了而试图点击移动的按钮时的挫折感--这就是布局转移。</p><p> The continuous measurement and conformance around these Web Vitals for your real users is crucial. It&#39;s the only way to truly know how your site performs for your users. The performance of your site can vary dramatically based on a user&#39;s device and their network conditions, or how they&#39;re interacting with the page. Sites that load personalized content or ads may also experience wildly different performance from user to user.</p><p>对于您的实际用户来说，围绕这些Web Vitals的持续测量和一致性是至关重要的。这是真正了解您的站点如何为您的用户服务的唯一途径。根据用户的设备和他们的网络状况，或者他们与页面的交互方式，您网站的性能可能会有很大的不同。加载个性化内容或广告的网站也可能因用户而异。</p><p>  Next.js Analytics allows you to capture real-world insights, instead of synthetic benchmarks. It enables a continuous stream of measurement instead of relying on occasional testing, ensuring it&#39;s part of your developer workflow.</p><p>Next.js Analytics允许您捕获真实世界的洞察力，而不是合成基准。它支持持续的测量流，而不是依赖于不定期的测试，确保它成为您开发人员工作流程的一部分。</p><p> Next.js Analytics allows you to capture  real-world insights, instead of synthetic benchmarks. It enables a  continuous stream of measurement instead of relying on occasional testing,  ensuring it&#39;s part of your developer workflow.</p><p>Next.js Analytics允许您捕获真实世界的洞察力，而不是合成基准。它支持持续的测量流，而不是依赖于不定期的测试，确保它成为您开发人员工作流程的一部分。</p><p>   Ecommerce is one of the most important uses of the web. The new Next.js 10 features are powerful new tools for ecommerce.</p><p>电子商务是网络最重要的用途之一。新的Next.js10特性是强大的电子商务新工具。</p><p> That&#39;s why today, in collaboration with BigCommerce, we released Next.js Commerce, the all-in-one starter kit for ecommerce sites. With a few clicks, Next.js developers can clone, deploy, and fully customize it. Start right now at  nextjs.org/commerce.</p><p>这就是为什么今天，我们与BigCommerce合作，发布了Next.js Commerce，这是电子商务网站的一体机入门套件。只需单击几下，Next.js开发人员就可以克隆、部署和完全定制它。现在就从nextjs.org/Commerce开始。</p><p>  React 17 had no breaking changes for Next.js, however there were some maintenance changes required, for example updating the peer dependencies. The  new JSX transform is automatically enabled when React 17 is used, no configuration changes are needed.</p><p>Reaction 17没有对Next.js进行突破性更改，但是需要进行一些维护更改，例如更新对等依赖项。新的JSX转换在使用REACTION 17时自动启用，不需要更改配置。</p><p> All you have to do to start using React 17 is upgrade Next.js and React:</p><p>要开始使用REACTION 17，您只需升级Next.js并做出反应：</p><p>   When making edits to your  getStaticProps and  getServerSideProps functions Next.js will now automatically re-run the function and apply the new data. This allows you to iterate quicker without having to refresh the page.</p><p>在编辑getStaticProps和getServerSideProps函数时，Next.js现在将自动重新运行该函数并应用新数据。这使您可以更快地迭代，而不必刷新页面。</p><p>   When using Next.js with MDX through  @next/mdx changing the MDX contents will now leverage Fast Refresh, making sure the browser does not have to reload the page on edits.</p><p>当通过@Next/MDX将Next.js与MDX一起使用时，更改MDX内容现在将利用快速刷新，确保浏览器在编辑时不必重新加载页面。</p><p>   You can now import third party css inside of React components. This allows for code-splitting CSS only meant for a single component. For example you can now use the  react-datepicker library without needing to import the CSS in  _app.js:</p><p>现在，您可以在Reaction组件中导入第三方CSS。这允许仅用于单个组件的代码拆分CSS。例如，您现在可以使用Reaction-Datepicker库，而无需导入_app.js中的CSS：</p><p>  You can refer to the  built-in CSS support documentation to learn more about how Next.js handles CSS imports.</p><p>您可以参考内置的CSS支持文档，了解有关Next.js如何处理CSS导入的更多信息。</p><p>  If you&#39;ve used dynamic routes before, you&#39;ve probably ran into a case before where you had to provide both a  href and  as property to  next/link. It would look something like this:</p><p>如果您以前使用过动态路由，那么您以前可能遇到过必须为next/link同时提供href和as属性的情况。它看起来应该是这样的：</p><p>  This allowed Next.js to interpolate the href for the dynamic parameters, however, it caused friction when developers forgot to add the  as or added the  as in  href causing the page transitions to not use client-side routing.</p><p>这允许Next.js插入动态参数的href，但是，当开发人员忘记在href中添加AS或在HREF中添加AS导致页面转换不使用客户端路由时，会造成摩擦。</p><p> We set out to solve this friction for developers a few months ago, with the main goal to improve developer experience and end user experience. We incrementally worked towards a solution that allows for  href to be automatically resolved.</p><p>几个月前，我们开始为开发人员解决这一摩擦，主要目标是改善开发人员体验和最终用户体验。我们渐进式地致力于一种允许自动解析HREF的解决方案。</p><p> We&#39;re excited to announce that as part of Next.js 10 you no longer have to use the  as property for the majority of use-cases. Removing friction from developers and improving the end user experience.</p><p>我们很高兴地宣布，作为Next.js10的一部分，您不再需要在大多数用例中使用as属性。消除开发人员的摩擦，改善最终用户体验。</p><p> This change is fully backwards compatible, if you currently use both  href and  as the existing behavior is preserved.</p><p>如果当前同时使用HREF和，则此更改完全向后兼容，因为保留了现有行为。</p><p> In order to adopt the automatic  href resolving all you have to do is change your usage of  next/link to only use  href holding the value that you previously had in  as property.</p><p>为了采用自动HREF解析，您所要做的就是更改NEXT/LINK的用法，以便只使用HREF来保存您以前在中拥有的值作为属性。</p><p> To learn more about  next/link and client-side routing you can refer to the   next/link documentation.</p><p>要了解有关NEXT/LINK和客户端路由的更多信息，您可以参考NEXT/LINK文档。</p><p>  We&#39;re committed to making sure Next.js upgrades are as smooth as possible through extensive backwards compatibility. This commitment starts with very sparingly deprecating features while introducing new and better solutions in their place. On top of this commitment we have extensive integration tests for all Next.js features, including tests that replicate local development.</p><p>我们致力于通过广泛的向后兼容性来确保Next.js升级尽可能顺利。这一承诺从极少贬低功能开始，同时引入新的、更好的解决方案取而代之。除了这一承诺之外，我们还对所有Next.js功能进行了广泛的集成测试，包括复制本地开发的测试。</p><p> When a feature in Next.js is deprecate and requires large codebase changes our team creates a codemod for it. A codemod is an automated code transformation that you can run over your project to update source code.</p><p>当Next.js中的某个特性被弃用并需要进行大量的代码库更改时，我们的团队会为其创建一个代码库。Codemod是一种自动代码转换，您可以在项目上运行它来更新源代码。</p><p> For example: We released a codemod for updating arrow functions and anonymous functions to named functions.  This transformation is needed because otherwise React Fast Refresh does not detect the function as being a valid React Component. Similarly the React hooks eslint rules would not pick up the function as a React component.</p><p>例如：我们发布了一个用于将箭头函数和匿名函数更新为命名函数的代码。此转换是必需的，因为否则Reaction Fast Refresh不会将该函数检测为有效的Reaction组件。类似地，Reaction钩子的eslint规则不会将函数作为Reaction组件获取。</p><p> With Next.js 10 we&#39;re releasing a new Next.js codemods CLI tool that allows you run a single command to update your application:  npx @next/codemod &lt;transform&gt; &lt;path&gt;.</p><p>对于Next.js 10，我们将发布一个新的Next.js codemods CLI工具，该工具允许您运行单个命令来更新您的应用程序：npx@next/codemod&lt；Transform&gt；&lt；path&gt；。</p><p>   In Next.js 9.3 we introduced  getStaticProps and  getStaticPaths along with the ability to return a  fallback property in  getStaticPaths. The  fallback property allows for generating additional static pages without needing a full rebuild, serving a static HTML file initially that is then replaced by the fully rendered content on subsequent requests. The past few months we&#39;ve received a lot of feedback from companies that wanted a similar but slightly different behavior: a blocking pre-render when a user requests the page for the first time. After that initial render the page would be re-used for subsequent requests.</p><p>在Next.js9.3中，我们引入了getStaticProps和getStaticPath，以及在getStaticPath中返回回退属性的功能。Fallback属性允许在不需要完全重新生成的情况下生成额外的静态页面，最初提供静态HTML文件，然后在后续请求中用完全呈现的内容替换该文件。在过去的几个月里，我们收到了很多公司的反馈，他们想要一种类似但略有不同的行为：当用户第一次请求页面时，进行阻塞预渲染。在初始呈现之后，页面将重新用于后续请求。</p><p>  We&#39;re excited to announce the new  fallback: &#39;blocking&#39; mode for  getStaticPaths that enables the blocking behavior where no static fallback is sent to the browser. Instead the initial request is waited on for pre-rendering.</p><p>我们很高兴地宣布，getStaticPath的新回退：阻塞模式启用了不会向浏览器发送静态回退的阻塞行为。相反，初始请求等待预渲染。</p><p> export  function  getStaticPaths ( )  {  return  {  // enables blocking mode for the fallback behavior fallback :  &#39;blocking&#39;  } }</p><p>导出函数getStaticPath(){return{//启用回退行为回退的阻塞模式：&#39；BLOCKING&#39；}}。</p><p> To learn more about  fallback behavior for incrementally generating additional static pages you can refer to the   fallback documentation.</p><p>要了解有关增量生成附加静态页的后备行为的更多信息，可以参考后备文档。</p><p>   We have had over  1,300 independent contributors, with over  120 new contributors since the 9.5 release</p><p>自从9.5发布以来，我们已经有超过1300个独立贡献者，还有超过120个新贡献者。</p><p> Join the Next.js community on  GitHub Discussions. Discussions is a community space that allows you to connect with other Next.js users and freely ask questions or share your work.</p><p>加入有关GitHub讨论的Next.js社区。讨论是一个社区空间，允许您与其他Next.js用户联系，并自由提问或分享您的工作。</p><p>  We are thankful to our community, including all the external feedback and contributions that helped shape this release.</p><p>我们感谢我们的社区，包括所有帮助塑造此版本的外部反馈和贡献。</p><p> This release was brought to you by the contributions of: @ijjk, @adebiyial, @elliottsj, @saintmalik, @HaNdTriX, @prateekbh, @amirsaeed671, @paambaati, @imagentleman, @gregrickaby, @Janpot, @atcastle, @Kirkhammetz, @remorses, @davidsonsns, @kmkzt, @slawekkolodziej, @Timer, @styfle, @timneutkens, @ykzts, @ashconnell, @orYoffe, @lfades, @justinwhall, @fbaiodias, @ludofischer, @felipeguilhermefs, @gr-qft, @TasukuUno, @YichiZ, @weichienhung, @seosmmbusiness, @HsuTing, @gsimone, @peduarte, @ztanner, @neighborhood999, @chibicode, @merceyz, @opudalo, @lunchboxav, @mohsen1, @akd-io, @justman00, @helloworld, @devknoll, @borekb, @ArthurMaverick, @sakito21, @TrySound, @omBratteng, @svenheden, @hallaji, @kettanaito, @vvo, @m-lautenbach, @jensmeindertsma, @Zeko369, @longlho, @stefanprobst, @laugharn, @sdornan, @daneroo, @mohd-akram, @austingmhuang, @sphilee, @devinekadeni, @Bacher, @nghiepit, @tomasdisk, @leader22, @paulogdm, @284km, @belgattitude, @geritol, @stigkj, @sampoder, @samrobbins85, @Pitasi, @digitalPlayer1125, @timfee, @plug-n-play, @philihp, @leerob, @dylanjha, @Kerumen, @rdimaio, @jorisw, @zerbinidamata, @jamesgeorge007, @Jashnm, and @futantan!</p><p>本新闻稿由以下人员提供给您：@ijjk、@adebiyial、@elliottsj、@saintmalik、@HaNdTriX、@prateekbh、@amirsaeed671、@paambaati、@imagentleman、@gregrickaby、@Janpot、@atCastle、@Kirkhammetz、@remorses、@davidsonsns、@kmkzt、@slwekolziej、@Timer、@styfzle、@timneutkens、@ykzts、@ashell、@oryoffe、@fades、@justinwhall、@fodias、@ludofischer、@Felipegumemefs、@gr-qft、@davidsonsns、@kmkzt、@slwekolziej、@timneutkens、@ykzts、@ashell、@orYoffe、@fades、@justinwhall、@fodias、@ludofischer、@Felipegumemefs、@gr-qft、@davidsonsns。@TasukuUno，@YichiZ，@weichienhung，@seosmmbusiness，@HsuTing，@gsimone，@peduarte，@ztanner，@Neighborhood999，@chibiode，@merceyz，@opudalo，@lunchboxav，@mohsen1，@akd-io，@justman00，@Helloworld，@devnukoll，@borekb，@arthurMaverick，@sakito21，@trySound，@omBrtenaito，@svenheden，@hallaji，@kettanbrtenaito，@vvo，@m-Lautenbach，@jensmeinderta，@Zeloworld，@glo，@stefan prost，@arthurMaverho，@svenheden，@hallaji，@kettanbrtenaito，@vvo，@m-Lautenbach，@jensmeinderta。@Lauharn，@sdornan，@daneroo，@Mohd-Akram，@austingmang，@spHilee，@devinekdeni，@Bacher，@nghiepit，@tomasdisk，@Leader22，@paulogdm，@284 km，@belgatuate，@geritol，@istikj，@sampoder，@samrobbins85，@Pitasi，@digitalPlayer1125，@timfee，@Plug-n-play，@philihp，@leerob，@dylanjjha，@kerumen，@rdimaio，@jorisw，@binidzeramata，@jamesgeorge007，@Jashnm，@Pitasi，@digitalPlayer1125，@timfee，@Plug-n-play，@philihp，@leerob，@dylanjisw，@binidzeramata，@jamesgeorge007。还有“复旦！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://nextjs.org/blog/next-10">https://nextjs.org/blog/next-10</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/js/">#js</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/图像/">#图像</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>