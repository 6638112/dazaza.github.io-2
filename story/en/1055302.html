<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何构建带有Rails库的Web应用程序 How to Build a Web App with and Without Rails Libraries</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to Build a Web App with and Without Rails Libraries<br/>如何构建带有Rails库的Web应用程序 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-01 19:45:47</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/558dbd537ee2e8f66b4258d6680276d4.png"><img src="http://img2.diglog.com/img/2021/4/558dbd537ee2e8f66b4258d6680276d4.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Ruby on Rails is a web framework that contains many libraries you’d need to create and deploy a successful web application. We often take for granted the ability to run  rails new to create a fully functional web application with tons of built-in features. For many of us, that’s good enough since the goal of Rails is to magically have everything work without needing to know what’s happening under the hood.</p><p>Ruby Rails是一个Web框架，包含许多您需要创建和部署成功的Web应用程序的库。我们经常授予Runds New以创建具有大量内置功能的全功能Web应用程序的能力。对于我们许多人来说，这已经足够了，因为铁路的目标是神奇地拥有一切都在不需要知道引擎盖下发生的事情。</p><p> In order to fully appreciate Ruby on Rails in all its glory, we’ll first need to understand the problem it’s trying to solve. Let’s picture a world where Rails doesn’t exist. It’s hard, I know.</p><p> 为了在所有荣耀中完全欣赏Ruby，我们首先需要了解它试图解决的问题。让我们在一个不存在轨道的世界中。我知道，这很难。</p><p> How would we build a web application only using the standard Ruby libraries? In this article, I’ll break down the key foundational concepts of how a web application works while building one from the ground up. If we can build a web application only using Ruby libraries, why would we need web server interfaces like Rack and web applications like Ruby on Rails? By the end of this article, you’ll gain a new appreciation for Rails and its magic.</p><p> 我们如何仅使用标准的Ruby库构建Web应用程序？在本文中，我将分解Web应用程序如何在从地上建造一个的主要基础概念。如果我们只能使用Ruby库构建Web应用程序，为什么我们需要像Ruby在Raby上等机架和Web应用程序这样的Web服务器接口？到本文结束时，您将对Rails及其魔法获得新的欣赏。</p><p>  I’ll cover topics including: network protocols (TCP and HTTP), persistent data stores, web server interface (Rack), and Rails libraries (Action Controller, Action Dispatch, Active Record, and Action View). In the first half of the tutorial, we’ll only be using core Ruby libraries, which is sufficient to learn the key concepts of how a web application works. In the second half, we’ll substitute the code with modules from Rails.</p><p>  我将涵盖主题，包括：网络协议（TCP和HTTP），持久数据存储，Web服务器接口（机架）和Rails库（操作控制器，动作调度，活动记录和操作视图）。在本教程的前半部分，我们只需使用核心Ruby库，这就足以了解Web应用程序如何工作原理的关键概念。在下半场，我们将使用Rails的模块替换代码。</p><p>  My assumption writing is you, dear reader, know how to use a file editor and navigate the terminal. You should also be familiar with terms related to the Internet, like web browsers. Being familiar with Ruby or Ruby on Rails and data structures isn’t a requirement, but it’ll help greatly! Lastly, it’s assumed you’re following along on a computer with MacOS and know how to  install and use Ruby gems.</p><p>  我的假设写作是您，亲爱的读者，知道如何使用文件编辑器并导航终端。您还应该熟悉与Internet相关的条款，如Web浏览器。熟悉Ruby或Ruby在Rails和Data Structures上不是一个要求，但它会有所帮助！最后，假设你在带有麦克斯的计算机上跟随，并知道如何安装和使用Ruby Gems。</p><p> In any case, I highly recommend following along with the code samples and running the code on your computer to get the full learning experience. After all, there’s no learning without experience doing.</p><p> 在任何情况下，我强烈建议使用代码样本并运行计算机上的代码以获得完整的学习体验。毕竟，没有经验没有学习。</p><p>   The web application we’ll be building today is called Mirth, a web application with the functionality for users to see displayed data and enter new data that would persist in the application. How you want the data to look is up to you. The Mirth web application for this tutorial will be a birthday tracker. Instead of relying on a certain social media to inform us of people’s birthdays, you can now ask them, record it, and view it in a list.</p><p>   我们今天将建立的Web应用程序被称为游束，一个Web应用程序，具有用户的功能，以查看显示的数据并输入将在应用程序中持久的新数据。你希望如何看待数据取决于您。本教程的欢乐Web应用程序将是生日跟踪器。而不是依靠某个社交媒体来告知我们人们的生日，你现在可以问他们，记录它并在列表中查看它。 </p><p>  Now that we got everything in order. Let’s start with the basics of how a web application works. How does the web application, or server, talk to the internet? Like humans, networked applications have a specific protocol they use to communicate with each other, called the  Transmission Control Protocol (TCP). You may have already heard of TCP before but what’s the role of TCP in web applications?</p><p>现在我们有序得到了一切。让我们从Web应用程序如何运作的基础。 Web应用程序或服务器如何与互联网交谈？与人类一样，网络应用程序具有他们用于彼此通信的特定协议，称为传输控制协议（TCP）。您可能已经听过TCP之前，但TCP在Web应用程序中的作用是什么？</p><p> To understand what TCP does, we must first understand the  Internet Protocol (IP). You&#39;ll soon find that levels of abstraction is a theme to understanding how this works. TCP is simply an abstraction of IP, a lower level protocol that’s used to transfer individual packets of data.</p><p> 要了解TCP的表现，我们必须先了解互联网协议（IP）。你＆＃39; ll很快发现抽象水平是了解这是如何工作的主题。 TCP只是一种IP的抽象，用于传输数据数据包的较低级别协议。</p><p> Although IP is the basis of how the Internet works, it’s a primitive protocol and therefore unreliable. Using IP poses risks like the wrong order of packet delivery or no delivery at all. TCP is built on top of IP to make the system more reliable with additional features. To solve the issue of out-of-order packet delivery, TCP allows the sender to add an auto-incrementing number inside the packet that is reassembled at the receiver’s end. Another key feature TCP adds is the concept of sockets.</p><p> 虽然IP是互联网如何运作的基础，但它是一个原始协议，因此不可靠。使用IP姿势风险，如错误的数据包交付顺序或根本没有送货。 TCP建于IP顶部，以使系统更可靠，具有附加功能。为解决超出数据包传输的问题，TCP允许发件人在接收器结束中重新组装的数据包内添加自动递增号。另一个关键特征TCP添加是套接字的概念。</p><p>  Sockets are meant to represent a persistent connection between a server and a client. Ruby has a core library called   sockets that builds on top of the TCP implementation from your operating system (which by the way, is yet another abstraction!).</p><p>  套接字意味着表示服务器和客户端之间的持久连接。 Ruby有一个名为套接字的核心库，该套接字从操作系统（顺便说一下，又是另一种抽象！）。</p><p>  The  socket library allows you to create a TCP server socket. In our case, Mirth’s server socket wants to keep an eye out to any incoming connections. But, how would a connection know the application to connect with? TCP creates a socket on a specific port that can be identified as the application that’s using it. In this case, we specify Mirth’s port to be 1337.</p><p>  套接字库允许您创建TCP服务器套接字。在我们的案例中，Lirth的服务器套接字想要留意任何传入连接。但是，连接如何知道应用程序的应用程序？ TCP在特定端口上创建一个套接字，可以标识为使用它的应用程序。在这种情况下，我们指定欢乐的端口为1337。</p><p>  Now that the server socket is created, we decide what we want to give the client when a connection is made. In a loop, we accept any clients through  #accept. Once a client is accepted as a connection, we receive information in a form of an IO object.</p><p>  既然创建了服务器套接字，我们决定在进行连接时要为客户端提供什么。在循环中，我们通过#accept接受任何客户端。一旦客户端被接受为连接，我们就会以IO对象的形式接收信息。</p><p>  Once you’ve accepted the client’s connection, now you can get any input from the client. In this case, we ask the client “What’s your name?”, and retrieve and regurgitate a modified reply.</p><p>  一旦您接受了客户的连接，您现在可以从客户端获取任何输入。在这种情况下，我们询问客户“您的名字是什么？”，并检索并反动修改后的回复。 </p><p>     To run this code on your computer, run the file,  ruby mirth-1.rb. By doing so, you create a server socket. Now you need a client to connect to the server with.</p><p>要在计算机上运行此代码，请运行文件，ruby mirth-1.rb。通过这样做，您可以创建服务器套接字。现在，您需要一个客户端连接到服务器。</p><p> Open a new terminal window and run  nc localhost 1337. You’re now connected to your local server socket at port number 1337 using  netcat. Subsequently, entering any input after the connection is established results in the print statements we have in the code.</p><p> 打开一个新的终端窗口并运行NC LocalHost 1337.您现在在使用NetCAT的端口号1337中连接到本地服务器插座。随后，在连接在代码中的打印语句中建立连接后输入任何输入。</p><p>  Now that you’re able to create a TCP socket, you’re ready to go further up the abstraction. Currently our TCP server still can’t communicate properly with a browser. That’s because the web browser speaks in the language of another protocol called the Hypertext Transfer Protocol (HTTP). TCP is application agnostic so any type of application can use TCP. HTTP, on the other hand, is specific to the web. So, we can actually implement HTTP in Ruby ourselves.</p><p>  既然你能够创建一个TCP套接字，您就可以进一步提升抽象。目前，我们的TCP服务器仍然无法使用浏览器正确通信。这是因为Web浏览器以一个名为Hyper文本传输协议（HTTP）的另一协议的语言说话。 TCP是应用程序不可知论，因此任何类型的应用都可以使用TCP。另一方面，http是特定于网络的。所以，我们可以在Ruby我们自己实施HTTP。</p><p>  There are many types of browsers and servers out in the world and that’s why we have HTTP. The protocol was set up by the  HTTP Working Group so everyone in the world can speak in the same language when it comes to web browsers.</p><p>  世界上有许多类型的浏览器和服务器，这就是我们拥有HTTP的原因。该协议由HTTP工作组设置，因此世界上每个人都可以在Web浏览器中以相同的语言发言。</p><p>   HTTP messages specialize into two types: requests and responses. A web browser can make a request to a server for a page, and the server obliges with the requested page in it’s response. The difference between requests and responses differ only in the  start-line of a HTTP message, where a request has a  request-line and a response has a  status-line. The structure of these requests and responses are specified in detail in a document called RFC.</p><p>   HTTP消息专门为两种类型：请求和响应。 Web浏览器可以向服务器提出请求，并在其响应中使用所请求的页面授权。请求和响应之间的差异仅在HTTP消息的开始行中不同，其中请求具有请求行，响应具有状态行。这些请求和响应的结构在名为RFC的文档中详细说明。</p><p>   From the perspective of the Mirth web application, it wants to be ready to serve the client with the requested information after the connection. Instead of providing a string of your name from the previous example, the client will now make the HTTP request.</p><p>   从Mirth Web应用程序的角度来看，它希望在连接之后准备好在客户端提供所请求的信息。客户端现在将从前面示例中提供一串名称，而不是提供一个字符串，现在将使HTTP请求进行HTTP请求。</p><p> The key component of a HTTP request is the request-line that contains vital information for the web application to act on. These are the method token, target path and HTTP protocol version number. The method token is the type of request from the server, the two common ones being GET (to get data) and POST (to post data to make a change in the server). As you would expect, the method token leads the code down separate paths depending on what’s requested. The target is the path the request is coming from. For example, the target path the server gets from a user requesting info to this webpage,  www.mirth.com/baked-brownies/123 is  baked-brownies/12. Lastly, the version number is the HTTP version the web browser is using, the most common one being   HTTP/1.1.</p><p> HTTP请求的关键组件是包含Web应用程序采取行动的重要信息的请求行。这些是令牌的方法，目标路径和HTTP协议版本号。该方法令牌是来自服务器的请求类型，两个常见的常见版本（以获取数据）和发布（到发布数据以在服务器中进行更改）。正如您所期望的那样，方法令牌将代码下调单独的路径，具体取决于所请求的内容。目标是请求来自的路径。例如，服务器从用户从请求信息向本页提供信息的目标路径，www.mith.com/baked -brownies/123是烘焙棕色/ 12。最后，版本号是Web浏览器正在使用的HTTP版本，最常见的是HTTP / 1.1。 </p><p>  Once the server accepts the client socket, we read the request line of a request. Unlike the # gets method that we’ve used previously,  #readline returns an error if there’s no more input to get.</p><p>一旦服务器接受客户端套接字，我们就会读取请求的请求行。与我们以前使用的＃获取方法不同，#Readline如果没有更多的输入，则会返回错误。</p><p>  We break down the HTTP request into parts, the  method_token, target and  version_number. All these parts are essential information to a server on how to respond to the request. The code simply prints the information we got from the HTTP request and returns it in the body of the HTTP request to display on the web browser page.</p><p>  我们将HTTP请求分解为零件，方法_Token，Target和Version_Number。所有这些部分都是服务器上如何响应请求的重要信息。该代码只需打印来自HTTP请求所获得的信息，并将其返回在HTTP请求正文中以在Web浏览器页面上显示。</p><p>   Instead of making a request from another socket, we make a request directly from the browser. Open your browser and enter  localhost:1337/cakes-and/pies. Your browser won’t have anything displayed because the server hasn&#39;t responded. Instead, make note of the string logged in your output.</p><p>   我们不是从另一个套接字中提出请求，我们直接从浏览器提出请求。打开浏览器并输入localhost：1337 / cakes-and / pies。您的浏览器不会显示任何内容，因为服务器已响应并响应。相反，记下记录在输出中的字符串。</p><p>    The first part of the HTTP response is the status code that represents the start-line. In our case, we want to ensure the browser that all is well, so we make the status code  201 OK. If there are any issues with the server, the browser would then be able to relay that information to the users, which explains the most commonly seen  404 Error status code when you visit a bad webpage.</p><p>    HTTP响应的第一部分是表示启动行的状态代码。在我们的情况下，我们希望确保浏览器一切顺利，所以我们制作状态代码201 OK。如果服务器有任何问题，则浏览器将能够将该信息中继到用户，该信息解释了访问Bad WebPage时最常见的404错误状态代码。</p><p> There are other notable parts of the HTTP response like the header fields. The header fields are lines of key-value pairs, in our case,  Content-Type:text/html. You can find a list of other headers at the RFC documentation page.</p><p> 还有HTTP响应的其他值为标题字段。标题字段是密钥值对的行，在我们的情况下，内容类型：Text / HTML。您可以在RFC文档页面上找到其他标题列表。</p><p> The types of header fields may vary between request and responses, but for responses, the header is where you enter any additional information about the response like path of redirection, caching and cookies, and security-related details. The browser reads the header fields and takes action accordingly, like redirect to the appropriate page, store the appropriate user settings, or secure the webpage.</p><p> 标题字段的类型可能会在请求和响应之间变化，但是对于响应，标题是输入有关重定向，缓存和cookie的路径等响应的任何其他信息，以及与安全相关的详细信息。浏览器读取标题字段并相应地执行操作，例如重定向到相应的页面，存储相应的用户设置，或保护网页。</p><p> The body is where you put the HTML code that’s rendered by the web browser.</p><p> 身体是您将Web浏览器呈现的HTML代码的位置。 </p><p>   Alright, let’s add some complexity to our web application and reply to the web browser with better-formed HTTP responses of our own. We’ll add some mock data to display (in this case birthdates), and two HTTP responses to display data and update the data with new user input.</p><p>好吧，让我们向我们的Web应用程序添加一些复杂性，并回复Web浏览器，具有我们自己的更好的HTTP响应。我们将添加一些模拟数据来显示（在本例中的出生日胎），以及两个HTTP响应以显示数据并使用新用户输入更新数据。</p><p>  Let’s first create some default data. All the birthday data in a hash that’s found right after the server is initialized. Note that the data isn’t persistent, meaning once the server restarts, any objects added to this hash disappears.</p><p>  让我们首先创建一些默认数据。在服务器初始化之后就在哈希中找到的所有生日数据。请注意，数据不持久，含义一旦服务器重新启动，添加到此哈希的任何对象都会消失。</p><p>  Next, we create a case statement in order to separate the different method tokens and path targets. This gives us a clear outline of the three endpoints we have for our little web application. The three endpoints are,  GET/show/birthday, POST /add/birthday and any other generic path. If the request matches any of the endpoints, the code within the block will run.</p><p>  接下来，我们创建一个案例语句，以便分离不同的方法令牌和路径目标。这使我们为我们的小型Web应用程序提供了三个端点的清晰概述。三个端点是，获取/显示/生日，发布/添加/生日和任何其他通用路径。如果请求与任何端点匹配，则块中的代码将运行。</p><p>  Because each endpoint will yield a different HTTP response, we define the following variables,  response_status_code, content_type and  response_message for each of the endpoints.</p><p>  因为每个端点都会产生不同的HTTP响应，所以我们为每个端点定义以下变量，response_status_code，content_type和response_message。</p><p>  As for the POST method, we add some user input to our birthday data hash. For now, it won’t be persistent, but you’re still able to add to the list while the same server is running.</p><p>  至于POST方法，我们将一些用户输入添加到我们的生日数据哈希。目前，它不会持久，但您仍然能够在运行同一服务器时添加到列表中。</p><p> The POST endpoint will look a little different from the GET endpoint. The status code won’t be  “200 OK” this time because instead of just informing the browser that the request has succeeded, we can be more helpful and redirect the user to the  /show/birthdates page using a   “303 See Other” status code.</p><p> 后端点与Get Endpoint看起来有点不同。此时状态代码不会是“200确定”，因为而不是刚通知浏览器该请求成功，我们可以使用“303查看其他”状态更有用的并将用户重定向到/ show /出生日页面代码。</p><p> Next, there’s an important header field needed from the request, the  Content-Length header. The content length header is the size of the body message in the HTTP request in bytes. Once we know how many bytes the message body consists of, we accurately read the body from the client socket’s IO. Lastly, we use Ruby’s built in decoder library called  uri to decode the body of the request into a Ruby hash that we append to the end of our list of birthdays.</p><p> 接下来，请求中需要一个重要的标题字段，Contention-Length标题。内容长度标题是HTTP请求中的主体消息的大小以字节为单位。一旦我们知道邮件正文包含多少字节，我们将从客户端套接字的IO准确读取身体。最后，我们使用Ruby内置的解码器库，称为URI，将请求的身体解码为Ruby Hash，以便在我们的生日列表结束时追加。 </p><p>  Once we’ve successfully determined all the components of the HTTP response based on each of the end points, we reconstruct the response. The response is constructed following HTTP specification: the response start-line contains the version number and response status code, followed by headers, an empty line, and the response body. In the next exercise we accept GET and POST responses from the web browser.</p><p>一旦我们基于每个端点确定了HTTP响应的所有组件，我们都会重建响应。响应在HTTP规范之后构建：响应开始行包含版本号和响应状态代码，然后是标题，空行和响应主体。在下一次练习中，我们接受来自Web浏览器的GET和POST响应。</p><p>   Similar to the previous exercise, we open a browser to the URL, but this time we go to  localhost:1337/show/birthdays that’s the URL to show the birthdates.</p><p>   类似于上一个练习，我们向网址打开浏览器，但这一次我们去LocalHost：1337 / show /生日，是显示出生的网址。</p><p> Add a new birthday information in the form, the page updates with the new data.</p><p> 在表单中添加新的生日信息，页面更新新数据。</p><p> Restart the server by pressing Control-C to close the server and running it with  ruby mirth-3.rb again. Restarting causes the server to start with the default data provided in the code.</p><p> 按Control-C重新启动服务器关闭服务器并再次使用Ruby Mirth-3.RB运行它。重新启动使服务器从代码中提供的默认数据开始。</p><p>   What is a web application without the ability to store data? We easily collect and display some user-submitted data but it won’t stick around once the socket is closed. We need a way to store the data so the next time the server restarts, we can still use the same set of data that was previously saved. But how would we?</p><p>   什么是Web应用程序，没有存储数据的能力？我们轻松收集并显示一些用户提交的数据，但一旦套接字关闭，它就不会粘在一起。我们需要一种方法来存储数据，所以下次服务器重新启动时，我们仍然可以使用先前保存的相同数据集。但我们会怎么样？</p><p> Obviously the answer is to store in a database. A database stores information on physical disks or servers. But pretend we live in an age where databases didn’t exist. What’s the most primitive way to persist some information? We save our data to a file.</p><p> 显然，答案是存储在数据库中。数据库存储有关物理磁盘或服务器的信息。但假装我们生活在一个数据库不存在的时代。持续一些信息的最原始方式是什么？我们将数据保存到文件中。</p><p> We could use a plain text file, but we would have to implement our own format for representing the data in plain text. The good news is that Ruby has a built-in library, PStore, that translates Ruby objects into binary and stores it in a file. Alternatively, PStore is also able to read from the file and translate the binary back into Ruby objects. The serialization and deserialization is the process of marshaling Ruby objects into binary and vice versa.</p><p> 我们可以使用纯文本文件，但我们必须实现自己的格式，以表示纯文本中的数据。好消息是Ruby有一个内置库，PStore，它将Ruby对象转换为二进制文件并将其存储在文件中。或者，PSTORE也能够从文件中读取并将二进制返回转换为Ruby对象。序列化和反序列化是将Ruby对象融入二进制的过程，反之亦然。 </p><p> However, PStore stores the file in binary that’s not readable by us humans. So, we move up the abstraction and use  YAML::Store, which is an implementation of PStore. Instead of serializing the Ruby objects into binary,  YAML::Store serializes into the human readable YAML file format.</p><p>但是，PSTORE以二进制文件存储文件，这些文件不可被美国人类读取。因此，我们向上移动抽象并使用Yaml :: Store，这是一个PSTORE的实现。而不是将Ruby对象序列化为二进制，Yaml :: Store序列化为人类可读的yaml文件格式。</p><p>    Run  ruby mirth-4.rb and go to  localhost:1337/show/birthdays on your browser. You’ll see the default data displayed exactly the same as the previous run.</p><p>    运行Ruby Mirth-4.RB并转到LocalHost：1337 /在浏览器上显示/生日。您将看到显示与上一个运行完全相同的默认数据。</p><p> Input some data and restart the application. You should still see your previously inputted data! The YAML file will be updated to reflect the new input.</p><p> 输入一些数据并重新启动应用程序。您仍然应该看到先前输入的数据！ yaml文件将被更新以反映新输入。</p><p>  Phew, that’s a lot to take in. If there’s a topic you’re interested in learning more about see the Additional Information section at the end of the post.</p><p>  Phew，这是很多需要的。如果有一个主题您对学习更多信息，请参阅帖子末尾的附加信息部分。</p><p> But wait—we have a working web application written fully only with Ruby libraries. It took a lot for us to get here. We needed to understand all the low level details of how TCP runs, what makes HTTP requests and responses, and how to persist data by storing it in a file. I mean… surely there’s a better way to write a Ruby web application but how? Yep—with more abstractions!</p><p> 但是等待 - 我们有一个工作的Web应用程序，只用Ruby库完全写入。我们花了很多时间来到这里。我们需要了解TCP如何运行的所有低级细节，是什么使HTTP请求和响应，以及如何通过将文件存储在文件中。我的意思是......肯定有一个更好的方式来写一个Ruby Web应用程序，但如何？是的，更多的抽象！</p><p>  The code that implements the TCP sockets to create a network connection is generally similar throughout all the types of web applications—the server creates a socket to accept clients. HTTP requests and responses are also standardised across all types of web applications. As we’ve seen above, it takes a lot of time and effort to rewrite the functionality to parse HTTP. A web developer would have to understand intricate details about the network protocols.</p><p>  实现TCP套接字以创建网络连接的代码通常在所有类型的Web应用程序中都相似 - 服务器创建套接字以接受客户端。在所有类型的Web应用程序中也标准化HTTP请求和响应。正如我们上面的看法，它需要很多时间和精力来重写解决HTTP的功能。 Web开发人员必须了解有关网络协议的复杂详细信息。</p><p> There’s an opportunity to abstract these functionality away from the developer who’s just trying to make a web application, reducing the overhead work. Instead of creating a network connection and writing HTTP parsing logic every single time we want to start a new web application, we can use an application server.</p><p> 有机会摘要这些功能远离开发人员，他们只是试图制作Web应用程序，从而减少开销工作。我们可以使用应用程序服务器，而不是每次打开新的Web应用程序创建网络连接并编写HTTP解析逻辑并编写HTTP解析逻辑。 </p><p> An application server is a program that deals with HTTP on behalf of the web application, it accepts and parses requests, and then generates and sends responses. Just like how HTTP has its specifications, application servers too have an agreement on how the server talks to our code.</p><p>应用程序服务器是代表Web应用程序处理HTTP的程序，它接受和解析请求，然后生成并发送响应。就像HTTP具有其规范的情况一样，应用程序服务器也达成协议，就如何与我们的代码交谈。</p><p> Rack is the specification for Ruby application server. If our web application implements the Rack specification, we can then run any application server that supports the Rack specification. There are  many application servers you can use based on your web application’s needs, and we’ll be using   puma as our application server in this tutorial.   A Rack application (or a web application that follows Rack specification) is any Ruby object that responds to the #call message, accepts a hash argument called the environment, and returns a three-element array that contains:</p><p> 机架是Ruby Application Server的规范。如果我们的Web应用程序实现了机架规范，则可以运行支持机架规范的任何应用程序服务器。您可以根据您的Web应用程序的需求使用许多应用服务器，我们将在本教程中使用Puma作为应用程序服务器。机架应用程序（或遵循机架规范的Web应用程序）是任何响应#call消息的Ruby对象，接受称为环境的哈希参数，并返回包含：的三个元素数组</p><p>  It’s similar to how a HTTP message would look like, but instead of a string format, they are Ruby objects.</p><p>  它类似于HTTP消息如何看起来像，而不是字符串格式，它们是Ruby对象。</p><p>  Imagine your web application as a box that takes in an HTTP request and outputs a HTTP response. Rack is a layer on top of the web application that enables Puma, the application server, to intercept the HTTP request on the web application’s behalf and return the three-element array.</p><p>  将您的Web应用程序视为一个框中，它带有HTTP请求并输出HTTP响应。机架是Web应用程序顶部的图层，可启用Puma，应用程序服务器代表Web应用程序上的HTTP请求并返回三个元素数组。</p><p> Once you’ve made your application a Rack application, you can access more functionalities provided by Rack. But first, let’s see how a Rack application looks integrated into our existing application.</p><p> 在您的应用程序应用程序应用程序中，您可以访问机架提供的更多功能。但首先，让我们看看机架应用程序如何将视图集成到我们现有的应用程序中。</p><p>  Instead of instantiating our own TCP socket, we defer it to Puma by following the Rack specification. The first thing our app does is create a   rack::request object with the environment provided. After this, we won’t have to worry about accepting and splitting the HTTP request’s request-line ourselves because it’s provided within the request object.</p><p>  通过遵循机架规范，我们将通过沿着机架规范延迟到PUMA而不是实例化我们自己的TCP插座。我们的应用程序所做的第一件事是使用提供的环境创建一个机架::请求对象。在此之后，我们不必担心接受和拆分HTTP请求的请求行我们，因为它位于请求对象中。</p><p>  This code was previously our case statement that determined which endpoint to lead the request down. Now we use built-in request methods like  #get? and  #path.</p><p>  此代码以前是我们的案例声明，确定导致请求的端点。现在我们使用像#get这样的内置请求方法？和#path。 </p><p> Another notable built-in method is the  #params method, which returns the request’s body and query string decoded into a hash of parameters. We use this in the POST endpoint where we take the parameters from the request, which is the user’s input, and store it in our YAML file.</p><p>另一个值得注意的内置方法是#Params方法，它返回请求的正文和查询字符串解码为参数的散列。我们在帖子端点中使用它在我们从请求中获取参数，该请求是用户的输入，并将其存储在我们的yaml文件中。</p><p>  As outlined in the Rack specification, we need to return a three-element array that consists of the status, headers, and body. Note that the status has to be an integer 200 or larger, the headers has to be a Hash and the body has to be an object that responds to  #each. To make things simple the body object is a Ruby Array in this example.</p><p>  如机架规范所述，我们需要返回一个由状态，标题和身体组成的三个元素数组。请注意，状态必须是整数200或更大，标题必须是哈希，并且身体必须是响应#each的对象。要使事物简单，主体对象是在此示例中的Ruby数组。</p><p>  Lastly we want to make sure to run the application using  Rack::Handler::Puma, which is the Puma API to run a Rack application. Puma goes on to create a TCP socket and handles the networking on the web application’s behalf.</p><p>  最后，我们希望务必使用机架:: parkler :: puma运行应用程序，这是运行机架应用程序的PUMA API。 PUMA继续创建TCP套接字，代表Web应用程序处理网络。</p><p>   Run  ruby mirth-5.rb. Mirth should have the same behaviour as the previous run. Notice how much detail has been removed and replaced with methods from the  rack::request library in the code.</p><p>   运行Ruby Mirth-5.rb。欢乐应具有与以前的运行相同的行为。请注意，在代码中替换了从机架::请求库中的方法替换了多少细节。</p><p>  Now that Mirth is a Rack application using  rack::request, we can now use   rack::response to wrap the HTTP response objects. Similar to how  rack::request worked, we are encapsulating the response logic of the application using  rack::response object. Once the HTTP response object is created and ready to go, Rack will send the response for the application.</p><p>  现在，即将使用Rack :: Request的机架应用程序，我们现在可以使用机架::响应包装HTTP响应对象。类似于Rack :: Request工作原理，我们使用机架::响应对象封装应用程序的响应逻辑。创建HTTP响应对象并准备好进行后，机架将发送应用程序的响应。</p><p>  Similar to how a  rack::request object is created, we create a new  rack::response object to handle the response.</p><p>  类似于如何创建Rack :: Octure对象，我们创建一个新的Rack ::响应对象来处理响应。</p><p>  Again, similar to how you can ask a  rack::request questions about the request, you can now modify the response object to your liking based on the different endpoints. For example, in the GET endpoint, we will use  #write to append a string to the body of the response. This will now be done behind the scenes in the  rack::response library.</p><p>  同样，类似于您如何询问Rack :: Request关于该请求的询问，您现在可以根据不同的端点修改响应对象以对您的喜好。例如，在GET端点中，我们将使用#write将字符串从响应的主体附加。现在将在机架::响应库中的幕后完成。 </p><p> rack::response also takes care of setting the defaults. You won’t have to declare the status as 200 for each endpoint as it’s assumed that 200 is the default code. The content type is set to “text/plain”. If you’d like your response to look differently, you can modify it.</p><p>Rack ::响应也负责设置默认值。对于每个端点，您不必将状态声明为200，因为它假定200是默认代码。内容类型设置为“text / plain”。如果您希望您的回复视为不同，则可以修改它。</p><p> For page redirections, you can now use r ack::response’s  #write method to set the status of redirection and the path to be redirected to. What was previously done in two lines of code is now done in one.</p><p> 对于页面重定向，您现在可以使用R Ack ::响应的#write方法来设置重定向的状态和要重定向的路径。以前在两行代码中完成了什么。</p><p>  Once every single endpoint is done modifying the response object, you can call  #finish in order to send the response through Puma.</p><p>  一旦完成每个单个端点修改响应对象，您可以调用#finish才能通过puma发送响应。</p><p>   1. Run  ruby mirth-6.rb. Notice how different the code looks—most of the manual variable assignment to ensure the proper HTTP response is now gone and taken care of by r ack::response library.</p><p>   1.运行Ruby Mirth-6.RB。请注意代码看起来的大多数手动变量分配有多么不同，以确保正确的HTTP响应现在消失并由R Ack :: response库进行了处理。</p><p>  Clearly, storing our data in a YAML file isn’t scalable with more requests. Plus, once your application has to store more complex data models and it will, YAML file storage becomes problematic. Millions of data it</p><p>  显然，将我们的数据存储在Yaml文件中并不具有更多的请求。此外，一旦您的应用程序必须存储更复杂的数据模型，yaml文件存储就会出现问题。数百万数据</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://shopify.engineering/building-web-app-ruby-rails">https://shopify.engineering/building-web-app-ruby-rails</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/带有/">#带有</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/应用程序/">#应用程序</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>