<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>逐行学习 Julia</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">逐行学习 Julia</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-08-05 20:47:01</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/8/d25e971a608ecc2145b06859f5f7e2c4.png"><img src="http://img2.diglog.com/img/2021/8/d25e971a608ecc2145b06859f5f7e2c4.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Cardsjl 是一个简单的 Julia 包，它展示了 Julia 编程语言的许多有趣的部分。阅读它是一种愉快的体验。我写下的注释在这里： # import base multiply(*), bitwise-or(|), and bitwise-and(&amp;) # # 在 Julia 中，您可以使用 `using` 或 `import` 加载模块。不同之处在于 # * `using` 将加载模块 ** 并** 将加载的模块重新导出到周围的全局 # 命名空间中。 # * `import` 只会加载模块并将模块名称重新导出到作用域。 import Base : *, |, &amp; &quot;&quot;&quot; 将花色编码为 2 位值（`UInt8` 的低位）：- 0 = ♣（俱乐部）- 1 = ♢（钻石）- 2 = ♡（红心) - 3 = ♠ (spades) 花色具有全局常量绑定：`♣`、`♢`、`♡`、`♠`。&quot;&quot;&quot; # 这里我们定义了一个结构体`Suit`。 `Suit` 包含一个类型为`UInt8` 的 `i` 变量 # # 在 Julia 中，类型对象是构造函数。我们可以通过调用函数`suit = Suit(0)`来创建结构体的新实例 # struct Suit i :: UInt8 # 这里，我们定义了一个“内部构造函数方法”来定义构造函数的约束 # # 这也是一个Julia 的 unicode 支持的简洁示例。是的，我们可以将 ≤ 用作 `&lt;=`。西装(s :: Integer) = 0 ≤ s ≤ 3 ? new(s) : throw( ArgumentError( &quot;invalidsuit number: $s &quot;)) end # Julia 的抽象主要由多重分派提供支持。 # 这里我们为 `char()` 函数定义了一个“新调度”来将普通字符转换为 Suit。 # 因此，每当 `char()` 函数与 `Suit` 一起应用时，将使用该调度。char(s :: Suit) = Char( 0x2663 -s .i) # ... 以及其他一些帮助器。它们令人惊讶地不言自明Base .string(s :: Suit) = string(char(s))Base .show(io :: IO, s :: Suit) = print(io, char(s)) # 在一个普通的扑克牌，只有 4 种可能的花色 # 我们可以用 Julia 中的 unicode 符号编写可读代码 const ♣ = Suit( 0) const ♢ = Suit( 1) const ♡ = Suit( 2) const ♠ = Suit( 3) ) constsuits = [♣, ♢, ♡, ♠] &quot;&quot;&quot; 将一张扑克牌编码为 6 位整数（`UInt8` 的低位）： - 低位代表 0 到 15 的等级 - 高位代表花色（♣、♢、♡ 或♠）等级分配如下： - 编号卡（2 到 10）的等级与其号码相同 - 杰克、皇后和国王的等级为 11、12 和 13 - 有低和高 A等级 1 和 14 - 有等级 0 和 15 的低级和高级小丑 这允许通过选择使用哪个 A 或哪个小丑来实现任何标准的纸牌等级排序。总共有 64 种可能的纸牌值这个方案，由`UInt8`值`0x00`到`0x3f`表示。” &quot;&quot; # 卡片是一个结构体，它将花色和等级编码成一个 UInt8 # # 在大多数高级语言中，定义这会有点乏味。 # 然而，Julia 在这里直接展示了它的表现力。 struct Card value :: UInt8 end # 我们为 `Card` 的构造函数创建一个新的 dispatch。 # 它将把秩和花色编码成 UInt8 函数 Card(r :: Integer, s :: Integer) 0 ≤ r ≤ 15 || throw( ArgumentError( &quot;invalid card rank: $r &quot;)) return Card(((s &lt;&lt; 4) % UInt8) | (r % UInt8)) end # 当suitCard( r :: Integer, s :: Suit) = Card(r, s .i) # 这些是用于从 cardsuit 中获取等级或花色的 getter(c :: Card) = Suit(( 0x30 &amp; c .value) &gt;&gt; &gt; 4)rank(c :: Card) = (c .value &amp; 0x0f) % Int8 # 让我们为 Base.show 定义一个新的调度，使其在打印时看起来不错。 function Base .show(io :: IO, c :: Card) r = rank(c) if 1 ≤ r ≤ 14 r == 10 &amp;&amp; print(io, &#39;1&#39;) print(io, &quot;1234567890JQKA&quot;[r] ) else print(io, &#39;\U1f0cf&#39;) end print(io,suit(c)) end # 在 Julia 中，`2 * x` 可以写成 `2x`。 # # 通过为乘法运算符 `*` 创建一个新的调度，我们可以编写 `2♣` # 并且它会自动转换为 `Card(2, ♣)`。哇花哨。 *(r :: Integer, s :: Suit) = Card(r, s) # 然而，“J♣”不会被视为乘法。 # # 这里我们使用`@eval` 宏将这些变量创建为常量。 # 这样的口齿不清。我喜欢。 for s in &quot;♣♢♡♠&quot;, (r,f) in zip( 11 : 14, &quot;JQKA&quot;) ss, sc = Symbol(s), Symbol(&quot; $f$s &quot;) @eval ( export $sc ; const $sc = Card( $r, $ss)) end &quot;&quot;&quot; 使用`UInt64` 位集表示一手（套）牌。&quot;&quot;&quot; # 我们使用`UInt64` 位集来存储什么牌由于一副牌中只有 52 张牌，因此出现在手牌中。 # # 我们使用 `&lt;:` 来表示 `Hand` 是 `AbstractSet{Card}` 的子类型。 # 因此，`Hand` 可以与所有具有可兼容分派到 `AbstractSet` 的函数一起使用。 struct Hand &lt;: AbstractSet{ Card} card :: UInt64 Hand(cards :: UInt64) = new(cards) end # 将卡片值转换为位 set positionbit(c :: Card) = one( UInt64) &lt;&lt; c .value #将西装转换为位集 rangebits(s :: Suit) = UInt64( 0xffff) &lt;&lt; 16(s .i) # 将一组卡片转换为位集的简单构造函数 Hand(cards) hand = Hand(zero( UInt64)) 用于卡中卡卡 is 卡 || throw( ArgumentError( &quot;not a card: $repr (card)&quot;)) i = bit(card) hand .cards &amp; i == 0 || throw( ArgumentError(&quot;不支持重复的卡片&quot;)) hand = Hand(hand .cards | i) end return hand end # 为我们的 Hand typeBase 进行更多调度。 in(c :: Card, h :: Hand) = (bit(c) &amp; h .cards) != 0Base .length(h :: Hand) = count_ones(h .cards)Base .isempty(h :: Hand) = h .cards == 0Base .lastindex(h :: Hand) = length(h) # 为我们的 Hand 定义一个迭代器。 # # 我们可以使用这里介绍的语法定义一个具有默认值的参数 function Base .iterate(h :: Hand, s :: UInt8 = trailing_zeros(h .cards) % UInt8) (h .cards &gt;&gt;&gt; s) == 0 &amp;&amp; 什么都不返回 c = Card(s); s += true c, s + trailing_zeros(h .cards &gt;&gt;&gt; s) % UInt8 end # 从 Hand 函数中获取 Card 的非绑定检查函数 Base .unsafe_getindex(h :: Hand, i :: UInt8 ) card, s = 0x0, 0x5 而真正的 mask = 0xffff_ffff_ffff_ffff &gt;&gt; ( 0x40 - ( 0x1 &lt;&lt;s) - card) card += UInt8(i &gt; count_ones(h .cards &amp; mask) % UInt8) &lt;&lt; ss &gt; 0 || break s -= 0x1 end return Card(card) end # 为了避免不断地从 UInt8 转换为 Integer，# 我们为所有 IntegeresBase 的 unsafe_getindex 创建一个新的 dispatch .unsafe_getindex(h :: Hand, i :: Integer) = Base .unsafe_getindex(h, i % UInt8) # 最后，我们用一个有界检查的 `getindex` 函数来包装我们不那么安全的函数 function Base .getindex(h :: Hand, i :: Integer) # `@ boundscheck` 宏允许使用`@inbound` 宏忽略边界检查@boundscheck 1 ≤ i ≤ length(h) || throw( BoundsError(h,i)) return Base .unsafe_getindex(h, i) end # 使`Hand` 在打印时看起来很好看 function Base .show(io :: IO, hand :: Hand) if isempty(hand) | | !get(io, :compact, false) print(io, &quot;Hand([&quot;) for card in hand print(io, card) (bit(card) &lt;&lt; 1) ≤ hand .cards &amp;&amp; print(io, &quot;, &quot;) end print(io, &quot;])&quot;) else s = hand &amp;suit isempty(s) &amp;&amp; continue show(io,suit) for card in sr = rank(card) if r == 10 print( io, &#39;\u2491&#39;) elseif 1 ≤ r ≤ 14 print(io, &quot;1234567890JQKA&quot;[r]) else print(io, &#39;\U1f0cf&#39;) end end end end # 更多的dispatch让我们可以将两只手与`|`，用`|`a 将一张牌加到手上： :: Hand | b :: Hand = Hand(a .cards | b .cards)a :: Hand | c :: Card = Hand(a .cards | bit(c))c :: Card | h :: 手 = h | c # 用 `&amp;`a 插入两只手 :: Hand &amp; b :: Hand = Hand(a .cards &amp; b .cards) # 用 `&amp;`h 获取花色范围内的牌 :: Hand &amp; s :: Suit = Hand(h .cards &amp; bits(s))s :: Suit &amp; h :: Hand = h &amp; s # 更多新调度Base .intersect(s :: Suit, h :: Hand) = h &amp; sBase .intersect(h : : Hand, s :: Suit) = intersect(s :: Suit, h :: Hand) # 我们的花色和牌的范围运算符 *(rr :: OrdinalRange{ &lt;: Integer}, s :: Suit) = Hand(Card (r,s) for r in rr) ..(r :: Integer, c :: Card) = (r :rank(c)) *suit(c) ..(a :: Card, b :: Card) = 西装(a) == 西装(b) ? rank(a) ..b : throw( ArgumentError( &quot;卡片范围需要匹配的花色：$a vs $b &quot;)) # 最后，我们创建了一副套牌，其中包含 52 张独特的卡片 consteck = Hand(Card(r,s) ) for s insuits for r = 2 : 14) # 空手可以表示为 0Base .empty( :: Type{ Hand}) = Hand(zero( UInt64)) # 使用 `rand` 得到一个随机子集牌组 # 我们使用 @eval 将所有卡片插入到这个表达式中，然后对其求值 @eval Base .rand( :: Type{ Hand}) = Hand( $(deck .cards) &amp; rand( UInt64)) # 在 Julia 中，一个以`!`结尾的函数表示它是一个就地更新函数##这里我们定义了一个`deal!`函数来根据指定的`counts`布局来填充手数 function deal!(counts :: Vector{ &lt;: Integer}, hand :: AbstractArray{ Hand}, offset :: Int = 0) for rank = 2 : 14,suit = 0 : 3 while true hand = rand( 1 : 4) if counts[hand] &gt; 0 counts[hand] -= 1 hand[offset + hand] |= Card(rank,suit) break end end end return hands end # 现在让我们定义我们的 `deal` 函数。它将按照给定的数量向 4 个人发牌 # # 没有参数时的默认调度 provideddeal() = deal!(fill(13, 4), fill(empty(Hand), 4)) # 为 `deal` 调度 when提供了一个 `n` Int 函数 deal(n :: Int) counts = fill( 0x0, 4) hands = fill(empty(Hand), 4, n) for i = 1 :n deal!(fill!(counts, 13), hands, 4(i - 1)) end return permutedims(hands) end # 计算给定手的点数 function points(hand :: Hand) p = 0 for rank = 11 : 14,suit = 0 : 3 card = Card(rank,suit) p += (rank - 10) *(card in hand) end return p end</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/julia/">#julia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/学习/">#学习</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hand/">#hand</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>