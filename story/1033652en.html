<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>开发人员经验在编程语言研究中的作用是什么？</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">开发人员经验在编程语言研究中的作用是什么？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-07 11:26:03</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/e01dca862a9b81e167e32ca15a8281a2.jpg"><img src="http://img2.diglog.com/img/2020/11/e01dca862a9b81e167e32ca15a8281a2.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In 2018, I was two years into a tenure-track junior faculty position at Carnegie Mellon University when I saw what was happening in the world of software. 2018 was when  Cambridge Analytica happened; soon afterward,  GDPR became law. Most academics who start companies in industry do so because they are commercializing a specific project; I left to start  Akita Software because I saw that the timing was right to build the kinds of tools I wanted to build—those that could help improve the quality and security of software. For the last two years, I’ve been working to  build developer tools at the API level for modern web apps.</p><p>2018年，当我在卡内基梅隆大学(Carnegie Mellon University)担任终身教职的两年时，我看到了软件界正在发生的事情。2018年，《剑桥分析》问世；不久之后，GDPR成为法律。大多数在行业中创办公司的学者之所以这样做，是因为他们正在将一个特定的项目商业化；我离开秋田软件公司是因为我看到，现在是构建我想要构建的工具的正确时机-那些可以帮助提高软件质量和安全性的工具。在过去的两年里，我一直致力于为现代网络应用构建API级别的开发工具。</p><p> Because the technical problem was not set in stone at the time I started Akita, I spent the first year of working on the company doing product and user research work. My academic career trained me to   solve problems  in a principled way. Through the process of getting Akita up and running, I learned how to   select problems  in a principled way. This was important because for the first time, the success of my efforts was being defined by how well I solved   problems that people cared about  enough to pay real-world money for. Here are my learnings.</p><p>因为技术问题在我创办秋田的时候还不是板上钉钉的，所以我在公司工作的第一年里一直在做产品和用户研究工作。我的学术生涯训练我有原则地解决问题。在启动和运行秋田的过程中，我学会了如何有原则地选择问题。这一点很重要，因为我的努力的成功第一次被定义为我解决的问题有多好，人们非常关心这些问题，愿意为这些问题付钱。以下是我学到的东西。</p><p>  When I was in research, I spent a lot of time talking to programmers “in the wild,” to understand the problems they had. So I thought I was doing my homework in terms of problem selection. In the last two years, I’ve learned about   user research  and realized that my problem selection in academia could have been much more methodical and principled!</p><p>当我从事研究时，我花了很多时间与程序员“在野外”交谈，以了解他们存在的问题。所以我认为我是在做问题选择方面的功课。在过去的两年里，我了解了用户研究，并意识到我在学术界的问题选择本可以更有条理、更有原则！</p><p> When you are trying to understand the precise problem,  there are principled ways of understanding user pain—even when your users are programmers and you are working on something as complex as programming languages and tools. You can’t prove them using math or measuring them like you do compiler performance, but you can be scientific all the same, e.g., by applying rigorous methods. This is something that the field of HCI has been doing for a long time—and that people have been advocating for merging more with programming tools , but still hasn’t reached most of programming languages research. (For instance, see this paper “ Programmers are Users Too: Human-Centered Methods for Improving Programming Tools” and  Sarah Chasins’s  syllabus for “Building User-Centered Programming Tools.”)</p><p>当您试图了解确切的问题时，有一些原则性的方法可以了解用户的痛苦-即使您的用户是程序员，而您正在处理像编程语言和工具这样复杂的事情。你不能用数学来证明它们，也不能像你对待编译器性能那样测量它们，但你仍然可以是科学的，例如，通过应用严格的方法。这是人机界面领域已经做了很长时间的事情，人们一直在倡导将更多的东西与编程工具相结合，但仍然没有涉及到大多数编程语言的研究。(例如，请参阅本文“程序员也是用户：改进编程工具的以人为本的方法”和Sarah Chasins的“构建以用户为中心的编程工具”的教学大纲。)。</p><p> One of the main things I learned about user research was to  be rigorous about   how   I asked user questions. The most straightforward way is to ask all users the same questions in the same order, under the same conditions. It is also important not to ask leading questions, nor to directly ask users what they want—there’s that famous saying that if Henry Ford had asked people what they wanted, they would have said faster horses. If your hypothesis is that tying one’s shoes is a pain point when trying to leave the house, it is not a good idea to ask directly: “Do you have trouble tying your shoes?” A better way to do this is to ask the user to walk you through what happens when they leave the house and ask them for what the pain points are. (For more on this, you may be interested in “  Principles of Contextual Inquiry .”)</p><p>关于用户研究，我学到的一件主要事情就是严格要求我问用户问题的方式。最直接的方式是在相同的条件下，以相同的顺序问所有用户相同的问题。同样重要的是，不要问引导性问题，也不要直接问用户他们想要什么--有句名言说，如果亨利·福特(Henry Ford)问人们他们想要什么，他们会说马跑得更快。如果你的假设是，系鞋带是出门时的一个痛点，那么直接问：“系鞋带有问题吗？”这不是个好主意。要做到这一点，更好的方法是让用户告诉你当他们离开家时会发生什么，并询问他们的痛点是什么。(有关这方面的更多信息，您可能会对“上下文查询原理”感兴趣。)。</p><p> Another big lesson I learned during user research was to  zoom out. Previously when I had been talking to users when doing programming languages research, my conversations usually centered around the pain developers were having around the specific problem I was working on. What I learned when doing user research was to understand the user as a whole person, complete with greater motivations and incentives, and understand how the problem I solved fit in with their goals, hopes, and dreams. For instance, here are questions I asked   before  learning more about user research:</p><p>我在用户研究中学到的另一个重要经验是缩小。以前，当我在做编程语言研究时与用户交谈时，我的对话通常围绕着开发人员围绕我正在处理的具体问题而感到的痛苦。在做用户研究时，我学到的是将用户作为一个整体来理解，以更大的动机和激励来完成，并理解我解决的问题如何符合他们的目标、希望和梦想。例如，在了解更多关于用户研究的知识之前，我问了以下几个问题：</p><p>  And here are some of the questions we asked dozens of users when I started Akita, that had very little to do with the specific tool we were building at all:</p><p>以下是我创建Akita时我们问了几十个用户的一些问题，这些问题与我们正在构建的特定工具几乎没有什么关系：</p><p> Walk me through a day in your job. What tools are you using? How are you spending your time?</p><p>给我讲讲你工作中的一天。你在用什么工具？你是怎么打发时间的？</p><p>   What are issues that would cause you to stay at work past the usual time?</p><p>什么问题会让你超时工作？</p><p> Tell me about how you interface with the rest of engineering. What frictions do you have there? (This was a question for security engineers.)</p><p>告诉我你是如何与工程学的其他部门打交道的。你们那里有什么摩擦？(这是一个给安全工程师的问题。)。</p><p> As a programming languages researcher, I certainly did not ask these questions in a consistent and disciplined way during problem selection—if at all. From asking these questions, I learned, for instance, that developer adoption impacted the success of a security tool much more than anything security engineers thought about the tool. And that developer adoption often hinged more on actionability than accuracy. These realizations not only led us to completely pivot what we thought our product should be (we started out focused on security/privacy-related usage of APIs, but pivoted to general-purpose use-cases), but also  forever changed my views on building programming languages and tools.</p><p>作为一名编程语言研究人员，我在选择问题的过程中肯定没有以一致和有纪律的方式提出这些问题--如果真的有的话。例如，通过问这些问题，我了解到，开发人员的采用对安全工具成功的影响比安全工程师认为的任何东西都要大得多。而开发者的采用往往更多地取决于可操作性，而不是准确性。这些认识不仅使我们完全改变了我们认为我们的产品应该是什么样子(我们一开始专注于API的安全/隐私相关用法，但后来转向了通用用例)，而且也永远改变了我对构建编程语言和工具的看法。</p><p>  Embracing the approach described above led to important changes in what we were doing. When I started Akita, I thought what we were going to build was the equivalent of an application performance monitoring tool for tracing data, targeted towards security and privacy teams. I had come to this initial conclusion from talking to people at a high level about what they thought the problems were, and what they thought was needed. Through doing user research, we instead decided to build low-friction integration tools targeted at inferring and testing against API specs, and to pivot our solution away from targeting security or privacy specifically. Here are some of the lessons that led to that:</p><p>采用上述方法使我们正在做的事情发生了重大变化。当我开始创建Akita时，我认为我们要构建的是一个相当于应用程序性能监控工具的应用程序性能监控工具，用于跟踪数据，面向安全和隐私团队。我是在与高层人士交谈后得出这个初步结论的，这些人认为问题是什么，以及他们认为需要什么。通过用户研究，我们决定构建低摩擦的集成工具，以针对API规范进行推断和测试，并将我们的解决方案从专门针对安全或隐私的方向转移。以下是导致这种情况的一些教训：</p><p> The most important way a security engineer can spend their time is improving their relationship with software engineering.  When we asked security engineers how they got promoted and/or increased their influence in their organization, it came up over and over again that a security team was only as good as the engineers who listened to them. This gave us confidence that building   developer  tools was the right way to go, since they have much greater influence!</p><p>安全工程师打发时间的最重要方式是改善他们与软件工程的关系。当我们询问安全工程师如何晋升和/或提高他们在组织中的影响力时，我们一遍又一遍地问道，安全团队的好坏取决于听取他们意见的工程师。这让我们相信构建开发人员工具是正确的选择，因为它们的影响力要大得多！</p><p> One of the  biggest challenges security engineers face is getting software engineers to fix their bugs.  When we asked security engineers to walk us through what they ended up spending a lot of time on, it involved convincing engineers to fix things. For instance, one engineer I spoke to spent a lot of his time coming up with examples to convince engineers that something they wrote is insecure. Another team took it one step further and hired penetration testers just to prove out the importance of certain security/privacy controls to their engineering teams. The results of this user research led us to believe that it wasn’t enough to provide reports to security that something was wrong; a more powerful tool would not only help identify possible problems, but also help developers prioritize and fix the problems. (Our findings match those of   this study .) As a developer tools team, this was right up our alley, leading us to start building tools that helped with providing context and reproducibility.</p><p>安全工程师面临的最大挑战之一是让软件工程师修复他们的漏洞。当我们要求安全工程师带领我们完成他们最终花费了大量时间的事情时，这涉及到说服工程师修复问题。例如，与我交谈过的一位工程师花了大量时间想出例子来说服工程师，他们写的东西是不安全的。另一个团队更进一步，雇佣了渗透测试员，只是为了证明某些安全/隐私控制对他们的工程团队的重要性。这项用户研究的结果让我们相信，仅仅向安全部门提供出错的报告是不够的；更强大的工具不仅可以帮助识别可能的问题，还可以帮助开发人员确定问题的优先顺序并进行修复。(我们的发现与这项研究的结果相符。)。作为一个开发工具团队，这正合我们的胃口，引导我们开始构建有助于提供上下文和可重现性的工具。</p><p> Integration friction matters.  When we asked users about what led them to choose the tools that they currently used, ease of integration into existing tool chains came up over and over again, as well as how much configuration the tool needed. This was especially true for security engineers, as they burned social capital whenever they made asks of other teams. We realized if we didn’t make a tool that was easy to integrate, it would be very hard to get adoption.</p><p>一体化摩擦很重要。当我们询问用户是什么原因导致他们选择当前使用的工具时，他们一次又一次地提到集成到现有工具链的简单性，以及该工具需要多少配置。对于安全工程师来说尤其如此，因为每当他们向其他团队提出要求时，他们就会消耗社会资本。我们意识到，如果我们不开发一个易于集成的工具，就很难被采用。</p><p> Building a developer tool for security means  building  for the developer/security gap.  Over the course of the first year of working on our product, we realized that our product design and go-to-market involved straddling the communication and incentive gap between security engineering and software engineering teams. After understanding the point of view of each side and that developers did not actually seem very interested in closing it, we ultimately decided we needed to choose a side. We chose to become a developer tool with a security use case, instead of the reverse. Without having done the user research we had done, the choice would not have been nearly as obvious!</p><p>构建安全的开发人员工具意味着构建开发人员/安全差距。在我们产品的第一年工作过程中，我们意识到我们的产品设计和投放市场需要跨越安全工程团队和软件工程团队之间的沟通和激励差距。在了解了每一方的观点，开发商似乎对关闭它并不是很感兴趣后，我们最终决定需要选择一方。我们选择成为一个有安全用例的开发工具，而不是相反。如果没有做过我们已经做过的用户调查，选择就不会那么明显了！</p><p> Through the process of doing this user research, I also learned to let go of many of the assumptions I had held in academia:</p><p>在做这个用户研究的过程中，我也学会了放弃我在学术界的许多假设：</p><p> Soundness may not be the right goal.  In academia, it is often the goal to make static program analyses   sound : if a bug is not reported, then that bug should not be possible. A common complaint about static analyses is that they aren’t actually that helpful a lot of the time because of the false positives. One reason this is a problem, for instance, is that the more bugs security teams report to developers, the less likely the bugs are to get fixed. In academia, I had thought of false bugs as non-bugs; many industry developers would call a low-priority bug a “false positive.” A surprising (to me) number of engineers said they’d rather not know about all of the bugs, but instead be informed about a subset of bugs that were likely to be fixed. Peter O’Hearn’s “  Incorrectness Logic ” paper is one that addresses this side of the problem.</p><p>健全可能不是正确的目标。在学术界，让静态程序分析变得合理通常是一个目标：如果没有报告一个bug，那么这个bug应该是不可能的。关于静态分析的一个常见抱怨是，由于误报，它们实际上在很多时候都没有多大帮助。例如，这是一个问题的一个原因是，安全团队向开发人员报告的错误越多，修复这些错误的可能性就越小。在学术界，我认为错误错误是非错误的；许多行业开发人员会将低优先级错误称为“假阳性”。数量惊人的工程师(对我来说)表示，他们宁愿不知道所有的错误，而是被告知可能修复的错误子集。彼得·奥赫恩(Peter O‘Hain)的“不正确逻辑”论文就是解决这一问题的一篇论文。</p><p> “Legacy factors” may be more important than guarantees or performance.  More generally, the tradeoffs that people want to make are not what you might expect, so they are worth exploring. When I dug deeper on my problem, for instance, I learned that the barrier to entry was often convincing people to adopt tools, which had more to do with integrations and learning curve than than math or performance. If people never got to the point of appreciating what was good about a tool, they would not appreciate the tool! This is definitely a different point of view than the one I had in academia, where the focus was on building clean versions of new features, leaving adoption as an exercise to the reader. While requiring all academic work to worry about adoption would certainly curb a lot of innovation, viewing adoption as “not academia’s problem” may be be curbing the opportunity for impact. Given that frictionless integration with legacy tool chains yields surprisingly challenging technical problems and can disproportionately affect impact, it should be given more attention in academia.</p><p>“遗产因素”可能比担保或业绩更重要。更广泛地说，人们想要做出的权衡并不是你可能会想到的，所以它们是值得探索的。例如，当我更深入地挖掘我的问题时，我了解到，进入的障碍往往是说服人们采用工具，而这些工具更多地与集成和学习曲线有关，而不是数学或性能。如果人们从来没有意识到一个工具的优点，他们就不会欣赏这个工具！这绝对不同于我在学术界的观点，当时我的重点是构建新功能的干净版本，把采用作为一种练习留给读者。虽然要求所有的学术工作都担心领养问题肯定会抑制很多创新，但将领养视为“不是学术界的问题”可能会抑制产生影响的机会。鉴于与遗留工具链的无摩擦集成会产生令人惊讶的挑战性技术问题，并可能对影响产生不成比例的影响，因此应该在学术界给予更多关注。</p><p>   My experience learning about user research led me to revisit something that I had previously thought a lot about: how should we be evaluating programming languages research papers? While a paper’s Introduction is what gets reviewers interested in a paper in the first place, the evaluation section gives a champion reviewer the necessary ammunition to go to battle at the Program Committee meeting. Because of this power, what shows up in the evaluation section determines what kind of work gets done in entire fields.</p><p>我学习用户研究的经历让我重新审视了我之前思考了很多的问题：我们应该如何评估编程语言研究论文？虽然一篇论文的导言首先会让评审者对论文感兴趣，但评估部分给了冠军评审员必要的弹药，让他可以在项目委员会会议上奋力拼搏。由于这种能力，评估部分中显示的内容决定了在整个领域中需要完成的工作类型。</p><p> My strong belief is that  programming languages research does not value usability because there currently is no satisfying, agreed-upon way of evaluating it.  Semantics evaluations guarantee properties like soundness, completeness, and type safety, but they don’t say anything about whether someone will actually care about the guarantees or the language. Benchmarks determine the tool runs fast according to sample programs. Benchmarks are great for compilers of known languages, but are often not as appropriate for language or tool design papers that do not focus around performance. The hour-long user studies we often see are often inadequate for evaluating complex languages and tools. (Coblenz et al have a   recent TOCHI submission  outlining some existing shortcomings in evaluation processes and proposing a new process.)</p><p>我坚信，编程语言研究并不重视可用性，因为目前还没有令人满意的、达成一致的评估方法。语义评估保证了诸如健全性、完整性和类型安全等属性，但它们并没有说明是否有人会真正关心这些保证或语言。根据样例程序，基准测试决定了工具的运行速度。基准测试对于已知语言的编译器来说是非常好的，但通常不适合不关注性能的语言或工具设计论文。我们经常看到的长达一小时的用户研究常常不足以评估复杂的语言和工具。(Coblenz等人最近提交了一份Tochi报告，概述了评估过程中存在的一些缺陷，并提出了一个新的过程。)。</p><p> The parts of language or tool design that have to do with developer experience—which, for a lot of papers, is a lot of things—end up only in the introduction and in various assumptions throughout the paper. What this means is that these parts are not directly evaluated. And when we don’t directly evaluate usability claims, two things happen. First, work that focuses on improving usability in a thoughtful way does not necessarily have a better chance of getting positively peer-reviewed. Second, usability claims do not get critically reviewed, meaning the field is less likely to move towards solutions that improve developer experience. Right now, when a paper’s main strength is usability, it has a   worse  time getting through peer review because it’s up to the specific reviewers whether they choose to appreciate it or not.</p><p>语言或工具设计中与开发人员经验有关的部分--对于很多论文来说，这是一大堆事情--最终只出现在导言和整篇论文的各种假设中。这意味着这些部分不会被直接评估。当我们不直接评估可用性声明时，会发生两件事。首先，专注于以深思熟虑的方式提高可用性的工作不一定有更好的机会得到积极的同行评议。其次，可用性声明没有得到严格的审查，这意味着该领域不太可能转向改善开发人员体验的解决方案。现在，当一篇论文的主要优势是可用性时，它通过同行评议的时间就更差了，因为这取决于具体的评审者是否欣赏它。</p><p> Here’s a question that I would like to pose to the field:  What would it look like to apply rigorous evaluation to problem selection for PL papers, instead of case studies for the result? For papers that propose things for developer productivity, why not evaluate them against interviews/surveys of where developers are actually struggling? Why not also make the criteria (for instance, soundness or performance) something that needs to be justified by the user research? “Soundness” is a formal statement that an analysis respects semantics according to some semantic property of interest, for instance no run-time failures or no information. What would it look like to justify this property itself, e.g., through user interviews?</p><p>这是一个我想向这个领域提出的问题：在PL论文的问题选择上应用严格的评估，而不是对结果进行案例研究，会是什么样子？对于那些提出提高开发人员生产率的论文，为什么不对照采访/调查来评估它们，看看开发人员到底在哪里苦苦挣扎呢？为什么不让这些标准(例如，健全性或性能)成为需要通过用户研究来证明的东西呢？“Soundness”是一种正式声明，表示分析根据一些感兴趣的语义属性尊重语义，例如没有运行时失败或没有信息。例如，通过用户访谈来证明这一属性本身是合理的，看起来会是什么样子？</p><p> I don’t know the answers, but here is one version of what it could look like. For researchers, understanding that there exists a framework for evaluating usability may change how you decide to pose and evaluate those claims. There is no need to go all-out and do a collaboration with an HCI researcher, though that could be interesting and helpful for the work. Even conducting any interviews is better than nothing. For reviewers, understanding usability evaluation may help you consider it as an acceptable form of evaluation for PL research—and flag when papers make usability claims   without  backing them up rigorously. And the only way we can move towards this is if the leaders of the community support this shift towards rigorous user-centric work.</p><p>I d</p><p> A final word: we should be careful not to let the pursuit of any specific kind of evaluation dominate a field, including user-centric evaluation. On the one hand, I love the idea of adding human-centered evaluation sections to highly technical programming languages paper. I have always thought of programming languages research as combining human factors with math and code—and these evaluation sections would finally reflect this marriage. On the other hand, academia   isn’t  industry for a reason. We need room for the what-ifs. And the more that we require of evaluations, the harder it will be to justify the intuition that accompanies truly novel discoveries. While I believe it would move the field forward to consider human-centered evaluation on a similar footing to semantics-centered or performance-centered evaluations, we should be wary of making any one of these evaluations required.</p><p>最后一句话：我们应该小心，不要让追求任何特定类型的评估主导一个领域，包括以用户为中心的评估。一方面，我喜欢在高度技术性的编程语言论文中增加以人为中心的评估部分的想法。我一直认为编程语言研究是人的因素与数学和代码的结合--这些评估部分最终会反映出这一结合。另一方面，学术界不是行业是有原因的。我们需要为假设提供空间。我们对评估的要求越高，就越难证明伴随着真正新奇发现的直觉是合理的。虽然我认为，在类似于以语义为中心或以绩效为中心的评估的基础上考虑以人为中心的评估将推动该领域向前发展，但我们应该谨慎对待任何一种必需的评估。</p><p> Bio:  Jean Yang is the founder and CEO of  Akita Software, an API tools company. She was previously an Assistant Professor in the Computer Science Department at Carnegie Mellon University.</p><p>简介：Jean Yang是API工具公司Akita Software的创始人兼首席执行官。她之前是卡内基梅隆大学计算机系的助理教授。</p><p> Acknowledgments: Thanks to Will Crichton for comments and suggestions on a draft of this post!</p><p>致谢：感谢威尔·克莱顿对本文草稿的评论和建议！</p><p> Disclaimer:  These posts are written by individual contributors to share their thoughts on the SIGPLAN blog for the benefit of the community. Any views or opinions represented in this blog are personal, belong solely to the blog author and do not represent those of ACM SIGPLAN or its parent organization, ACM.</p><p>免责声明：这些帖子是由个人撰稿人撰写的，目的是为了社区利益在SIGPLAN博客上分享他们的想法。本博客中所代表的任何观点或观点均为个人观点，仅属于博客作者，不代表ACM SIGPLAN或其上级组织ACM的观点或观点。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.sigplan.org/2020/10/27/whats-the-role-of-developer-experience-in-programming-languages-research/">https://blog.sigplan.org/2020/10/27/whats-the-role-of-developer-experience-in-programming-languages-research/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/经验/">#经验</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/developer/">#developer</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033632.html"><img src="http://img2.diglog.com/img/2020/11/thumb_1c73dcb4e8eef769e2d2e29f3add898a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033632.html">迷失的编程方法：Commodore 64 Basic</a></div><span class="my_story_list_date">2020-11-7 11:19</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033536.html"><img src="http://img2.diglog.com/img/2020/11/thumb_037aca4fd4242375cfdc54c66dcb59f0.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033536.html">
Netflix在法国测试编程的线性电视和电影频道</a></div><span class="my_story_list_date">2020-11-6 20:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033316.html"><img src="http://img2.diglog.com/img/2020/11/thumb_21f8be35cef4397449ea9dd55e0aa657.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033316.html">Python取代Java成为第二大最受欢迎的编程语言</a></div><span class="my_story_list_date">2020-11-5 20:25</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033174.html"><img src="http://img2.diglog.com/img/2020/11/thumb_b1db87a8aa18f25398c18443eb064347.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033174.html">异步/等待在编程中的优势</a></div><span class="my_story_list_date">2020-11-4 22:6</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>