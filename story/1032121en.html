<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Ruby on Rails在一周内</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Ruby on Rails在一周内</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-30 04:04:33</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/91253f5412240fbde2f92cc0ec96cb46.jpg"><img src="http://img2.diglog.com/img/2020/10/91253f5412240fbde2f92cc0ec96cb46.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>(Note: this post builds off of my previous post,    Learning to Learn , and references it a few times—however, this post should still make sense if you missed the first one. Also, this is not a tutorial, but rather a log of my experience learning Ruby on Rails.)</p><p>(注：这篇文章是在我上一篇文章“学会学习”的基础上发展起来的，并且引用了几次--不过，如果你错过了第一篇，这篇文章应该还是有意义的。此外，这不是教程，而是我学习Ruby on rails的经验记录。)。</p><p> I recently found myself in a situation where I had 7 days to learn Ruby on Rails. This was mentioned briefly in my  previous blog post, but I wanted to take the time now to elaborate on this experience.</p><p>我最近发现自己有7天的时间学习Ruby on rails。这在我上一篇博客文章中有过简短的提及，但我现在想花点时间详细说明一下这段经历。</p><p> My last blog post was all about how to learn, and taking the best approach to learning. This blog post is about putting those ideas into practice—a case study.</p><p>我上一篇博文都是关于如何学习，以及采取最好的学习方法。这篇博客文章是关于将这些想法付诸实践的-一个案例研究。</p><p>  First things first—I was in the midst of an interview process. It was a Friday afternoon, and next Friday I would be taking part in a live coding exercise. Most of this exercise would involve working on a Ruby on Rails application. This meant that I had a 7 day crunch to learn the framework.</p><p>首先，我正在面试。那是一个星期五的下午，下周五我将参加一个现场编程练习。本练习的大部分内容都涉及到使用Ruby on rails应用程序。这意味着我有7天的时间来学习这个框架。</p><p> You may speculate on how I found myself in this situation. Maybe it was the result of some forgery or deceit. Maybe I had lied about my experience in order to get my foot in the door, and was now left scrambling. But alas, no. It was not all that exciting. There was no dishonesty, and no nefarious behaviors. Instead, it was a shared understanding between me and interviewers that I was bringing no preexisting knowledge of Rails.</p><p>你可以推测一下我是如何发现自己处于这种境地的。也许这是某种伪造或欺骗的结果。也许我谎报了我的经历，好让我的脚踏进这扇门，而现在我只能手忙脚乱了。但是，唉，不是的。这并不是那么令人兴奋。没有不诚实的行为，也没有邪恶的行为。相反，我和面试官之间有一个共同的理解，那就是我没有带来任何预先存在的Rails知识。</p><p> The agreement was that I would learn a new technology, and they would judge me on how well I picked it up. I would learn, but not master, the technology, and they would take my greenness into account while assessing my knowledge.</p><p>协议是我将学习一项新技术，他们会根据我学得有多好来评判我。我会学习，但不会掌握技术，他们会在评估我的知识时考虑我的环保程度。</p><p> As such, I reasoned that I wasn’t really being tested on my knowledge of the Rails framework. Of course, when the time came, I would have to demonstrate some degree of functional knowledge. However if that was all that they were looking for they could have just quizzed me—given me a competency test or something of the like. But instead, they wanted to investigate a much more important skill—they wanted to watch me  learn.</p><p>因此，我推断我对Rails框架的知识并没有真正接受测试。当然，当时机成熟时，我必须表现出一定程度的功能知识。然而，如果这就是他们想要的全部，他们可以直接对我进行测验--给我一次能力测试或类似的东西。但相反，他们想调查一项更重要的技能-他们想看着我学习。</p><p>  Yet, as important as it may be, gauging someone’s ability to learn is difficult! You can’t fully understand an individual or the soft skills they might have from a simple résumé or cover letter. And technical interviews, no matter the rigor, end up missing the point as well.</p><p>然而，尽管它可能很重要，但衡量一个人的学习能力是困难的！从一份简单的简历或求职信中，你不可能完全理解一个人或他们可能拥有的软技能。而技术面试，不管有多严格，最终也没有抓住要点。</p><p>   I’ve never felt represented by technical assessments, or interviews which follow silly methods (like the  STAR method). But by including a learning process in the interview (i.e., learning Ruby on Rails), it gave me a chance to fully represent myself. It benefited both of us. They were able to test me on some very important, yet hard to quantify skills, and I was able to represent myself in a way that I typically would have not been able to.</p><p>我从来没有感觉到自己被技术评估或遵循愚蠢方法(比如明星方法)的采访所代表。但是通过在面试中加入一个学习过程(即学习Ruby on rails)，它给了我一个完全展示自己的机会。这对我们两个都有好处。他们能够测试我一些非常重要但又很难量化的技能，我能够以一种我通常无法做到的方式来表现自己。</p><p>  As I thought about the interview and what I was really being evaluated for, I started to form a strategy—a mind set.</p><p>当我思考面试以及我真正被评估的内容时，我开始形成一种策略--一种思维定势。</p><p>  I set out to take a higher-level approach to the learning, and, throughout the process, remind myself to focus on the concepts, the bigger picture, and how the things I’m learning relate to my existing knowledge. This was new ground for me. For the first time in my career, I was not just aware of what I was learning, but  how I was learning.</p><p>我开始采取更高层次的学习方法，并在整个过程中提醒自己把重点放在概念、更大的图景上，以及我正在学习的东西如何与我现有的知识相联系。这对我来说是新的领域。在我的职业生涯中，我第一次不仅意识到我在学什么，而且意识到我是如何学习的。</p><p>   For example, take the idea of inheritance. Low level thinking might sound like, “All the other classes are adding  &lt; ApplicationController if they want to use this method, so I need to do that too. Otherwise it throws an error.’’</p><p>例如，以继承的想法为例。低级思考听起来可能像是，“所有其他类都在添加&lt；ApplicationController，如果它们想使用这个方法，所以我也需要这样做。否则它会抛出错误。‘’</p><p> But high level thinking might be more like, “I need to access the ApplicationController class’ methods. Ruby supports inheritance, so I’ll add   &lt; ApplicationController to the class definition to let the compiler know that I’m inheriting it.”</p><p>但是高层思考可能更像是，“我需要访问ApplicationController类的方法。Ruby支持继承，所以我将把&lt；ApplicationController添加到类定义中，让编译器知道我在继承它。“。</p><p>  This could be very simple things, like “In Python it’s  None, in Javascript it’s  null, but in Ruby it’s called  nil”, or making connections like “oh, this is like Rail’s version of  pip, or  npm.”</p><p>这可以是非常简单的事情，比如“在Python中是None，在Javascript中是Null，但在Ruby中是Nil”，或者建立连接，比如“哦，这就像Rail版本的pip，或npm”。</p><p>  “I haven’t seen anything about string interpolation, I wonder if Ruby supports some version of that?”</p><p>“我还没有看到任何关于字符串插值的东西，我想知道Ruby是否支持某种版本的字符串插值？”</p><p> “How would I do something like this in Python? Javascript? Would it be easier or harder?”</p><p>“我怎么用Python做这样的事情呢？JavaScript？是更容易还是更难？“</p><p>  “Rails generates a lot of functions and methods for you that aren’t defined in the code—I bet that will be hard to debug.”</p><p>“Rails为您生成了许多代码中没有定义的函数和方法-我打赌这将很难调试。”</p><p>  I like to take handwritten notes to make sure that I’m not daydreaming, or just moving my eyes over words. If I’m being really purposeful, I like to do the little bonus activities and exercises that tutorials or textbooks often include. Sometimes they’re silly, and feel wasteful, but they do force me to be active, to think about, and to use what I’m learning.</p><p>我喜欢做手写笔记，以确保我不是在白日做梦，或者只是将目光移到单词上。如果我真的很有目的，我喜欢做教程或教科书中经常包括的一些额外的活动和练习。有时它们很愚蠢，感觉很浪费，但它们确实迫使我积极、思考和运用我所学到的东西。</p><p>  Everyone has their own pace, and increasing that pace too much can degrade the other aspects of learning. I find that when I speed up too much, I stop taking notes and start skipping over useful activities. I get lazy, and I don’t learn as much. Moving at a healthy pace, and also taking breaks when needed is very important.</p><p>每个人都有自己的节奏，太快的节奏会降低学习的其他方面。我发现当我速度过快时，我就不再做笔记，开始跳过有用的活动。我变得懒惰，学到的东西也不多。以健康的速度运动，并在需要的时候休息是非常重要的。</p><p>  Being able to take a step back and approach a problem at a high-level like this was a significant milestone for me. Simply put, when you’re learning your first programming language, you don’t have anything to compare it to. The only things that you can focus on are the low-level details—things like syntax, iteration, and data structures.</p><p>能够退一步，在这样的高层次上解决问题，对我来说是一个重要的里程碑。简单地说，当您学习您的第一门编程语言时，您没有任何东西可以与之比较。您唯一可以关注的是低级细节-语法、迭代和数据结构等。</p><p> It’s possible, however, that a learner never graduates from this mindset. A developer could know three, four, or more languages on a functional level, but still be unaware of the concepts.</p><p>然而，学习者有可能永远不会从这种心态中毕业。开发人员可以在功能级别上了解三种、四种或更多语言，但仍然不了解这些概念。</p><p> It might be that up until this point, I just didn’t have enough experience to see the bigger picture. Or, though I hate to say, maybe I was the developer who never graduated from the mindset of memorizing low-level details. Or it could’ve been that I  was thinking about concepts, taking apart information, and categorizing knowledge, but I just wasn’t very conscious that the process was taking place.</p><p>可能是到现在为止，我只是没有足够的经验来看到更大的图景。或者，尽管我不愿意说，也许我是一个从来没有从记住低级细节的心态中毕业的开发人员。或者可能是我在思考概念，分解信息，对知识进行分类，但我只是没有非常意识到这个过程正在发生。</p><p> But for whatever reason, when I set out to learn Ruby on Rails, I was acutely aware that I had a new approach to learning. It’s like I had hiked up to a new vantage point. After hacking my way through a forest where all I could see was the vines and foliage, I now stood atop a mountain, with a clear view of where I had been, and the trails I had walked.</p><p>但是无论出于什么原因，当我开始学习Ruby on rails时，我敏锐地意识到我有了一种新的学习方法。就像我徒步走到了一个新的有利位置。在穿过一片森林后，我只能看到藤蔓和树叶，现在我站在一座山顶上，清晰地看到了我去过的地方，以及我走过的小径。</p><p> Armed with my new mindset and approach to learning, I couldn’t wait to start.</p><p>带着我新的学习心态和方法，我迫不及待地想开始学习。</p><p>  Michael Hartl’s   Ruby on Rails Tutorial was the main resource I used when learning Rails. It’s a very impressive learning tool that leads you through building what is essentially a Twitter clone. Unfortunately it’s not free (apparently it used to be—I guess I missed out on that), however I believe that the $31 price tag to gain access to the online version is well worth the investment.</p><p>Michael Hartl的Ruby on rails教程是我学习Rails时使用的主要资源。这是一个非常令人印象深刻的学习工具，它引导你构建本质上是Twitter的克隆。不幸的是，它不是免费的(显然它曾经是免费的--我想我错过了这一点)，但我相信，获得在线版本的31美元标价是非常值得的。</p><p> I also consulted the  Rails API Docs a few times when I was feeling curious, or looking for more specific information on a certain Rails module. Thanks to the tutorial, I didn’t really need to dive too much into the docs, but I think it’s always good to get familiar with the source documentation of any language or framework you’re using.</p><p>当我感到好奇或寻找关于某个Rails模块的更具体信息时，我还查阅了Rails API Docs几次。多亏了本教程，我真的不需要深入研究文档，但我认为熟悉您正在使用的任何语言或框架的源文档总是很好的。</p><p> And of course Google, which led me to Stack Overflow, GitHub issues, and random blog posts.</p><p>当然还有Google，这让我看到了Stack Overflow、GitHub问题和随机的博客帖子。</p><p>   Firstly, I learned that Ruby is a programming language! Well, I sort of already knew this, but before this moment some smooth-talker could have convinced me otherwise. You know when you kind of think you know about something, you’ve heard people talk about it, but you don’t  actually know about it? I had never used Ruby, and I had never really had a reason to. So as elementary as it may sound, this is where I started—with the recognition of Ruby as a language.</p><p>首先，我了解到Ruby是一种编程语言！嗯，我大概已经知道这一点了，但在这之前，一些能言善辩的人可能会说服我不这么认为。你知道吗，当你认为你知道某件事的时候，你听到人们在谈论它，但你实际上并不知道它？我从来没有使用过Ruby，也从来没有真正有理由这样做。因此，尽管听起来很简单，但这就是我开始的地方--将Ruby识别为一种语言。</p><p> Building on that knowledge, I learned that Rails is a web framework that is written in the Ruby programming language.  Now we’re getting somewhere! I’m starting to understand the components that make up Ruby on Rails, and I can relate them to what I already know. Saying Ruby on Rails is  kind of like saying Javascript on React (although that doesn’t quite have the same ring to it, does it?).</p><p>在此基础上，我了解到Rails是一个用Ruby编程语言编写的Web框架。现在我们有进展了！我开始理解组成Ruby on rails的组件了，我可以把它们与我已经知道的联系起来。说Ruby on rails有点像说反应上的Javascript(尽管这听起来不太一样，不是吗？)。</p><p> My next run in with curiosity—is there a version manager I should be using?</p><p>我的下一次怀着好奇心--有没有我应该使用的版本管理器？</p><p> I am familiar with  nvm and  pyenv for managing Node and Python versions, respectively, however the tutorial I was following did not mention any Ruby version manager. I took to the internet and found the highly popular,  rbenv.</p><p>我熟悉分别用于管理Node和Python版本的NVM和pyenv，但是我正在学习的教程没有提到任何Ruby版本管理器。我上网找到了人气很高的rbenv。</p><p>  With  rbenv in hand, installing Rails came easily and generating a project was a breeze. I found the  rails new command to be powerful, automated, and that it gave me everything I needed to get a project up and running in the browser. It’s always nice to see some sort of early success, even if it’s “Hello world!”, or in this case, “Yay! You’re on Rails!”. I likened it to my experience with  npx create-react-app, which generates a simple React application.</p><p>有了rbenv，安装Rails变得很容易，生成一个项目也是轻而易举的事。我发现rails new命令功能强大、自动化，它为我提供了在浏览器中启动和运行项目所需的一切。看到一些早期的成功总是令人高兴的，即使是“你好，世界！”，或者在这种情况下，“耶！你就在轨道上！“。我将其与我使用npx create-action-app的体验相提并论，npx创建-反应-应用程序生成一个简单的反应应用程序。</p><p>  My first impression after generating a project—“There’s a lot going on.”</p><p>我在生成一个项目后的第一印象是--“有很多事情在进行。”</p><p> Generating a Rails application resulted in 46 directories and subdirectories, and 89 files. Some of these files were familiar to me, like a  README.md, and the  public/ folder which holds the standard  404.html and  favicon.ico. But most of everything else was uncharted territory.</p><p>生成Rails应用程序会产生46个目录和子目录，以及89个文件。其中一些文件我很熟悉，比如readme.md，以及包含标准的404.html和folicon.ico的public/文件夹。但其他大部分都是未知领域。</p><p> To make things simpler, we can try and strip down the excess and focus on the core of the app. Arguably the most important directory—where you can find the meat and potatoes of the application—is the  /app directory. But even there it’s hard to get an idea of what’s going on.</p><p>为了让事情变得更简单，我们可以试着去掉多余的部分，专注于应用程序的核心。可以说，最重要的目录-您可以在其中找到应用程序的主要部分-是/app目录。但即使在那里，也很难对正在发生的事情有所了解。</p><p> Here’s what you see in the  /app directory after generating a new application—</p><p>下面是您在生成新应用程序后在/app目录中看到的内容-。</p><p> ├── app  │   ├── assets  │   │   ├── config  │   │   │   └── manifest.js  │   │   ├── images  │   │   ├── javascripts  │   │   │   ├── application.js  │   │   │   ├── cable.js  │   │   │   └── channels  │   │   └── stylesheets  │   │       └── application.css  │   ├── channels  │   │   └── application_cable  │   │       ├── channel.rb  │   │       └── connection.rb  │   ├── controllers  │   │   ├── application_controller.rb  │   │   └── concerns  │   ├── helpers  │   │   └── application_helper.rb  │   ├── jobs  │   │   └── application_job.rb  │   ├── mailers  │   │   └── application_mailer.rb  │   ├── models  │   │   ├── application_record.rb  │   │   └── concerns  │   └── views  │       └── layouts  │           ├── application.html.erb  │           ├── mailer.html.erb  │           └── mailer.text.erb</p><p>├──APP│、├──Assets│、│、├──Config│、└──清单.js│、│、├──Images│、│、├──JavaScript│、├──应用程序.js│、├──cable.js│、└──Channels│、│、└──Style Sheets│。*│└──Application.css│├──Channels││└──APPLICE_CABLE││├──││└──Connection.rb│├──Controlators││├──Application_Controler.rb││└──Concerns│├──Helpers│For│└──Application_Helper。Rb│和├──JOBS│和│└──Application_job.rb│和├──Mailers││和└──Application_mailer.rb│和├──Models││和├──Application_Record.rb│和│└──Concerns││Views│**└──Layout│*│和├──Application.html.erb│。*├──mailer.html.erb│和└──mailer.text.erb。</p><p>  This was the dark side of automation. When the work is done for you, you don’t have to understand it.</p><p>这是自动化的阴暗面。当这项工作为你完成时，你不必理解它。</p><p> But as I followed the tutorial, I began to pick up on some familiarities. I was at first confused by the  .html.erb file extensions littering the project, but then learned that  ERb is an HTML file with Ruby code embedded in it. That makes sense—I’m familiar with the concept from PHP files, or the JSX that’s used in React. And the Gemfile is the equivalent of other manifest/dependency files that I’m used to such as Node’s  package.json and Python’s  requirements.txt.</p><p>但是，当我按照教程学习的时候，我开始学到一些熟悉的东西。起初，我对项目中散布的.html.erb文件扩展名感到困惑，但后来了解到erb是一个嵌入了Ruby代码的HTML文件。这是有道理的-我熟悉PHP文件中的概念，或者Reaction中使用的JSX。Gemfile等同于我习惯的其他清单/依赖文件，比如Node的Package.json和Python的Requirements.txt。</p><p>  There was certainly a learning curve, and it took me a while to get comfortable, but the Rails directories structure began to make sense over time. And (spoiler alert!) it turns out that this standard directory structure is actually one of my favorite things about Rails. It lets you hop into almost any Rails project and quickly get a sense for what’s going on. This seems to be a common theme with Ruby on Rails—something seems very intimidating or confusing at first, but after getting over the learning curve, it becomes a very useful element of the framework.</p><p>当然有一个学习曲线，我花了一段时间才适应，但随着时间的推移，Rails目录结构开始变得有意义了。和(剧透警报！)。事实证明，这种标准目录结构实际上是我最喜欢的Rails特性之一。它允许您进入几乎任何Rails项目，并快速了解正在发生的情况。这似乎是Ruby on rails的一个共同主题--有些东西起初看起来非常吓人或令人困惑，但在克服学习曲线之后，它就变成了框架中一个非常有用的元素。</p><p>  I had never used the Model-View-Controller design pattern before Rails. I had heard of the idea from Android Studio and Android app development, but hadn’t really gotten to know it too well. It can be thought of as—</p><p>在Rails之前，我从未使用过模型-视图-控制器设计模式。我从Android Studio和Android应用程序开发中听说过这个想法，但还没有真正很好地了解它。它可以被认为是-。</p><p>  The  tutorial I was following described MVC as an, “…architectural pattern, which enforces a separation between the data in the application (such as user information) and the code used to display it.”</p><p>我遵循的教程将mvc描述为“…。体系结构模式，它强制将应用程序中的数据(如用户信息)与用于显示数据的代码分开。“。</p><p> Since I was trying to focus on high-level thinking, this high level view of the architecture of Rails applications stuck out as particularly important. This was exactly the type of thing that, if I was being lazy, I could probably skim over and not pay too much attention to. And without ever learning the importance of MVC, I could still probably manage to build Rails applications,  but they would be messy. They wouldn’t work as well, would take longer to develop, and would be harder to maintain.</p><p>由于我试图专注于高层思考，因此Rails应用程序体系结构的这种高级视图显得尤为重要。如果我是懒惰的话，这正是我可能会略过头而不会太在意的那类事情。在没有学习MVC的重要性的情况下，我可能仍然可以设法构建Rails应用程序，但是它们会很混乱。它们不会工作得很好，需要更长的时间来开发，而且更难维护。</p><p> So I took my time, took notes, and I let the MVC knowledge settle in.</p><p>所以我从容不迫地做了笔记，让MVC知识安顿下来。</p><p>  ├── app  │   ├── controllers  │   ├── models  │   └── views  │   └── (several other directories)</p><p>├──APP│、├──Controlders│、├──Models│、└──Views、│和└──(其他几个目录)。</p><p> It would take some actual, hands-on development for me to get a practical understanding of what MVC meant, because abstract knowledge is often different from practical knowledge, but it was now something that I was aware of as I began programming.</p><p>我需要一些实际的动手开发才能实际理解MVC的含义，因为抽象知识通常不同于实际知识，但现在我在开始编程时就意识到了这一点。</p><p> Later on I would learn of the “skinny controller, fat model” mantra, and since I had already been in the MVC mindset, this actually made a lot of sense to me. I adjusted my development strategy accordingly. If I had ignored the high level architecture, I might have just thrown all of the logic into the controller. I wouldn’t have understood what was meant by “skinny controller, fat model”, my projects would have suffered, and perhaps worst of all, I could have embarrassed myself in front of other developers!</p><p>后来我学到了“瘦控制器，胖模特”的口头禅，因为我已经进入了MVC的思维模式，这对我来说实际上是很有意义的。我相应地调整了我的发展战略。如果我忽略了高级体系结构，我可能只会将所有逻辑都放到控制器中。我不会理解“瘦控制器，胖模型”是什么意思，我的项目会受到影响，也许最糟糕的是，我可能会在其他开发人员面前让自己难堪！</p><p>  This has been a topic of great discussion for as long as Rails has been around. Ruby on Rails is confusing to newcomers, and it has been described as, “too magical”. I, too, was confused at first. All over the application, there were references to functions or files that I couldn’t find definitions for.</p><p>自从Rails问世以来，这一直是一个很好的讨论话题。Ruby on rails让新手感到困惑，有人形容它“太神奇了”。我一开始也很困惑。在整个应用程序中，都有对我找不到定义的函数或文件的引用。</p><p> Rails feels magical because it does a lot for you. It imports things, renders things, passes instance variables from the controller to the view, and more. Just adding a resource to the  routes.rb file (i.e.,  resources :users), adds  seven different routes for CRUD operations. There are the reusable  partials, which are special types of views indicated by an underscore at the beginning of their filename. And don’t even get me started on the magic involved when  has_secure_password is added to a model.</p><p>Rails感觉很神奇，因为它为您做了很多事情。它导入对象、呈现对象、将实例变量从控制器传递到视图，等等。只需将一个资源添加到routes.rb文件(即，RESOURCES：USERS)，就会为CRUD操作添加七个不同的路由。有可重用的部分，它们是由文件名开头的下划线指示的特殊类型的视图。甚至不要让我开始讲解向模型添加has_secure_password时所涉及的魔术。</p><p> It’s intimidating! People can, and do, say things like, “if you think Rails is magical, you just haven’t read the documentation.” Kudos to the people who can sit down, read, and understand documentation that easily, but I know that, for me, I had to experience it first hand before it began to make sense.</p><p>太吓人了！人们可以并且确实会说这样的话：“如果您认为Rails很神奇，那么您只是还没有读过文档。”对于那些能够如此轻松地坐下来、阅读和理解文档的人来说，这是值得称赞的，但我知道，对于我来说，在它开始变得有意义之前，我必须亲身体验过它。</p><p> But with practice and research, the magic fades away. All of the implicitness, abstraction, and “magic” in Rails serves a purpose. It’s not just there to be confusing. After becoming comfortable, the payoff is that development is fast, time consuming tasks are lifted away, and the developer’s quality of life is high. Being able to utilize the magic of Rails becomes a sort of superpower.</p><p>但随着实践和研究，魔力会逐渐消失。Rails中的所有含蓄、抽象和“魔力”都是有目的的。这不仅仅是让人困惑的地方。在变得舒适之后，回报是开发速度快，耗时的任务被解除，开发人员的生活质量很高。能够利用Rails的魔力成为一种超级大国。</p><p> That being said, there are potential downsides. Firstly, the steep learning curve is a barrier to entry for those looking to use Rails. There is also the risk, especially when it comes to  metaprogramming, that code can become too complex and errors too hard to trace. Ruby on Rails is a framework where code can do the exact same thing but look so very different, which can make it hard to maintain a project, especially across a development team where multiple individuals are contributing.</p><p>话虽如此，但也有潜在的不利因素。首先，对于那些希望使用Rails的人来说，陡峭的学习曲线是进入的障碍。还存在这样的风险，特别是在元编程方面，代码可能变得太复杂，错误太难跟踪。Ruby on rails是一个框架，其中的代码可以做完全相同的事情，但看起来非常不同，这可能会使维护项目变得困难，特别是在多个人参与的开发团队中。</p><p>  The Ruby language could have its own dedicated post, so I’ll limit myself to the three things that stuck out to me the most.</p><p>Ruby语言可以有自己的专用帖子，所以我将把自己限制在最突出的三个方面。</p><p>  This is not  entirely true, but it’s mostly true. Ruby is extremely object-oriented. Of course there’s exceptions (like  if statements, or flow control keywords such as  break and  continue), but still, mostly everything is an object. And objects have classes. And classes have methods.</p><p>这不完全是真的，但大部分是真的。Ruby是非常面向对象的。当然也有例外(比如if语句，或者诸如Break和Continue这样的流控制关键字)，但是大多数情况下，所有东西都是对象。并且对象有类。并且类有方法。</p><p>  As a fun little experiment, we can inspect the nature of the number 1—</p><p>作为一个有趣的小实验，我们可以检查数字1的性质-。</p><p>           So both the integer, 1, and the nil object,  nil, eventually inherit  BasicObject. And, as it goes, anything that is a subclass of  BasicObject has access to  BasicObject’s methods. I just think that is so cool. Everything has a common ancestor–there’s a sort of  oneness to it all.</p><p>因此，整数1和nil对象nil最终都继承BasicObject。而且，任何属于BasicObject子类的对象都可以访问BasicObject的方法。我只是觉得这太酷了。任何事物都有一个共同的祖先-一切都有一种统一性。</p><p>  In Ruby, you can print to the console using  puts “Hello World!”. This alone isn’t very interesting, but if you inspect the behavior of  puts, it shines a light on the inner machinations of Ruby.</p><p>在Ruby中，您可以使用PUT“Hello World！”打印到控制台。这本身并不是很有趣，但是如果您检查一下看跌期权的行为，就会发现Ruby的内在阴谋。</p><p>  Ruby is strange in this way, and it’s important for a developer to be very aware of this peculiarity. In Ruby,  everything evaluates to a value. The  puts method  must return something, so it returns  nil.</p><p>Ruby在这方面很奇怪，对于开发人员来说，非常清楚这一点很重要。在Ruby中，所有内容的计算结果都是一个值。PUTS方法必须返回一些东西，所以它返回零。</p><p> And in the methods that you’re writing, if there’s not a return call, what ends up being returned will be the  last evaluated piece of code in the method.</p><p>在您正在编写的方法中，如果没有返回调用，那么最终返回的将是该方法中的最后一段计算代码。</p><p> This behavior was very different from other languages I’ve used before, and stuck out to me as very important—it’s a fundamental element of Ruby. Not understanding an aspect of a language such as this could cause lots of frustration and heartache further down the road.</p><p>这种行为与我以前使用过的其他语言非常不同，对我来说非常重要--它是Ruby的一个基本元素。不理解这样一种语言的某一方面可能会在以后的道路上造成很多挫折感和心痛。</p><p>  Blocks are one of the most confusing, yet most powerful elements of Ruby. They allow you to group expressions, save them to a variable, and even pass them to a method. I’m still getting used to blocks and realizing their usefulness, but overall I feel that they condense a lot of code, and also make code more reusable and extensible.</p><p>块是Ruby最令人困惑但功能最强大的元素之一。它们允许您对表达式进行分组，将其保存到变量，甚至将其传递给方法。我还在习惯块，并意识到它们的用处，但总的来说，我觉得它们浓缩了大量代码，也使代码更具可重用性和可扩展性。</p><p>      [‘h’, ‘o’, ‘w’, ‘d’, ‘y’].each do |letter|</p><p>[‘h’，‘o’，‘w’，‘d’，‘y’].每个Do|Letter|。</p><p>    I alluded to this earlier, but one of my favorite things about Ruby on Rails is the directory structure. It was overwhelming at first, but now it reveals itself as one of Rails greatest qualities. There’s a homely consistency across different Rails projects, which is a  huge benefit for developers (especially us consultants), who are frequently hopping between different projects.</p><p>我在前面提到过这一点，但是关于Ruby on rails，我最喜欢的事情之一是目录结构。起初它是压倒性的，但现在它显示出自己是Rails最伟大的品质之一。在不同的Rails项目之间有一个普通的一致性，这对经常在不同项目之间跳跃的开发人员(特别是我们的顾问)来说是一个巨大的好处。</p><p> Another of my favorite aspects of Rails is the passionate community. From such a community stems solid documentation, community support, very good tutorials, and lots of online discussions. The community impact has also seeped into Rails through the form of coding conventions and development styles. These conventions are not required by any means, but they’re so ingrained in Rails as a framework that they can’t help but promote better applications and inspire better development practices. (A lot of the conventions can be found  in this blog post, and they include the DRY principle, test-driven design, and utilizing data migrations.)</p><p>我最喜欢的Rails的另一个方面是充满激情的社区。来自这样一个社区的是坚实的文档、社区支持、非常好的教程和大量的在线讨论。社区的影响也通过编码约定和开发风格的形式渗透到了Rails中。这些约定无论如何都不是必需的，但是它们作为框架在Rails中是如此根深蒂固，以至于它们不能不促进更好的应用程序和激发更好的开发实践。(在这篇博客文章中可以找到许多约定，它们包括Dry原则、测试驱动设计和利用数据迁移。)</p><p> And finally, harnessing the “magic” of Rails has become such a joy during the development process. Developing in Rails now feels faster than any other framework I’ve used before.</p><p>最后，在开发过程中，利用Rails的“魔力”已经成为一种乐趣。现在，在Rails中开发感觉比我以前使用过的任何其他框架都要快。</p><p>  The learning curve. There was a significant learning curve. I did not like this. That being said, once I got over the hump, I appreciated almost everything that was originally difficult (in fact, most of which was difficult is now in the  What I Really Like section above!).</p><p>学习曲线。这是一个重要的学习曲线。我不喜欢这样。话虽如此，一旦我渡过难关，我几乎欣赏到了所有原本困难的东西(事实上，大部分困难现在都在上面的我真正喜欢的那一节中了！)。</p><p> Another thing that I keep finding difficult, which I talked briefly about in the  Magic of Rails section, is that Ruby code can look so different depending on how you choose to write it. There’s optional parenthesis, the option to leave out  return statements, complex blocks, metaprogramming, and more. It’s easy in Ruby on Rails to get a little fancy, and the drawback is that it’s hard to maintain someone else’s code when you see that they got all fancy with things.</p><p>我一直觉得困难的另一件事是，Ruby代码可能看起来非常不同，这取决于您选择如何编写它，这一点我在Rails的魔力一节中简要讨论过。有可选的括号，可以选择省略返回语句、复杂块、元编程等等。在Ruby on rails中很容易产生一些新奇的东西，缺点是当您看到其他人的代码都很奇特时，很难维护他们的代码。</p><p> There are ways to remedy this problem—always aim to do things in the most simple way, use tools like  RuboCop that enforce syntax rules, follow the Rails coding conventions, and you can maybe even go so far as to have standard coding conventions within a company.</p><p>有办法解决这个问题-始终以最简单的方式做事，使用像RuboCop这样的工具来强制执行语法规则，遵循Rails编码约定，甚至可以在公司内拥有标准的编码约定。</p><p>  I’m now a couple months into using Ruby on Rails (thankfully I got the job).</p><p>我现在使用Ruby on rails已经有几个月了(谢天谢地我得到了这份工作)。</p><p> Unsurprisingly, there was so still much more to learn about the framework than what I was able to learn over the course of 7 days. And I’m still learning every day.</p><p>不出所料，与我在7天的课程中所学到的内容相比，关于这个框架还有很多需要学习的东西。我每天都在学习。</p><p> But nowadays, although I don’t have to worry about the time-crunch of an approaching interview, or demonstrating to someone that I know how to learn, I still try to keep the same mindset that I had when I was originally learning Rails—I try to remain aware of </p><p>但是现在，虽然我不必担心即将到来的面试的时间紧迫，也不必向别人展示我知道如何学习，但我仍然试图保持我最初学习Rails时的心态-我试图保持对。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.simplethread.com/ruby-on-rails-in-a-week/">https://www.simplethread.com/ruby-on-rails-in-a-week/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rails/">#rails</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>