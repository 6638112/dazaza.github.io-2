<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Rust中实现类型安全的printf</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在Rust中实现类型安全的printf</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-08-14 23:59:18</div><div class="page_narrow text-break page_content"><p>我将展示如何使用异构列表和特征在Rust中实现类型安全的printf。这些机制可以确保两个可变参数列表共享重要属性，如格式字符串孔的数量与printf参数的数量相匹配。</p><p>关于Rust中的类型级编程的正在进行的系列文章的一部分。考虑先读第一部分！此节点中的所有代码都可以在此要点中找到。</p><p>铁锈有一个很棒的printf功能，println！它有丰富的格式化语言，但也能在编译时捕获错误。例如，println！将检查参数数量是否与格式字符串中的空洞数量匹配：</p><p>错误：格式字符串中有2个位置参数，但有1个参数--&gt；src/printf.rs：36：13|36|println！(&#34；{}{}&#34；，&#34；Hello&#34；)；</p><p>铁锈编译器如何进行此检查？因为格式字符串和参数都在宏中，所以Rust将检查空洞的数量是否与参数的数量匹配。因此，格式字符串必须在宏内。如果我们写道：</p><p>我将向您展示如何在不使用过程性宏的情况下实现类型安全的printf。更一般地，本说明包含函数的锈蚀配方，其中：</p><p>多个可变输入共享一个并行属性，例如，参数的数量应与格式孔的数量匹配。</p><p>首先，我们需要了解主要的类型级机制：异构列表(或H列表)。H列表是潜在不同类型的值序列。例如，[1，&#34；a&#34；，true]是H列表，但不是有效的锈蚀矢量。H列表在Rust中使用链表样式实现：</p><p>Struct HNil；struct HCons&lt；Head，Tail&gt；{Head：Head，Tail：Tail}let示例：HCons&lt；I32，HCons&lt；bool，HNil&gt；&gt；=HCons{Head：1，Tail：HCons{Head：True，Tail：HNil}}；</p><p>关键思想是H列表的类型在您每次对其进行更改时都会更改。相比之下，如果推送到VEC&lt；T&&gt;，矢量的类型保持不变。</p><p>就像铁锈有了vc一样！[]，我们可以用破碎的板条箱来得到一份hlist！宏。</p><p>让我们回到printf的成分上。我们需要格式字符串和参数列表。关键思想是用H列表来表示两者，并仔细使用Rust的特性来确保我们想要的特性：参数的数量应该与空洞的数量相匹配。</p><p>首先，为了表示格式化字符串，我们将使用一系列结构来表示字符串的每个部分。</p><p>Pub struct FString(&amp；#39；static str)；pub struct fvar；//假设我们编译了&#34；Hello{}！代码中的第一个素数是{}&#34；。//这将是一个简单的语法转换。让Example=hlist！[FString(&#34；Hello&#34；)，fvar，FString(&#34；！第一个素数是&#34；)，fvar]；</p><p>这里，self是format指令的H列表，args是可变参数的H列表。Format需要将args作为类型参数，因为当我们从args列表中删除元素时，它的类型将会改变。</p><p>现在，我们继续按案例实现格式特征。首先，到达格式列表HNil末尾的基本情况：</p><p>这个impl说明当我们到达格式列表的末尾时，只需返回空字符串。我们将接受的唯一参数是一个空参数列表。与下一个隐式相结合，这会归纳地确保不接受额外的参数。</p><p>接下来，我们将实现FString。此实现应使用包含在FString结构中的字符串常量，并递归地将其与格式列表的其余部分组合在一起。我们没有对FString使用可变参数，因此它们被传递。在Rust中，此英文规范变为：</p><p>实施&lt；ArgList、FmtList&&gt;；Format&lt；ArgList&&gt;；用于HCons&lt；FString、FmtList&gt；的FmtList：Format&lt；ArgList&gt；其中FmtList：Format&lt；ArgList&gt；{FN Format(&amp；Self，Args：ArgList)-&gt；String{sel.head.。0.To_Owner()+&amp；self.ail.format(Args)}}。</p><p>请注意，我们必须添加FmtList：format&lt；ArgList&gt；以确保对self.tai.format的递归调用正常工作。还要注意，我们不是直接在FString上实现Format，而是在包含FString的H列表上实现Format。</p><p>最后是最复杂的情况，fvar。我们希望这个iml从ArgList中获取一个参数，然后用剩余的参数格式化剩余的格式列表。</p><p>实施&lt；T，ArgList，FmtList&gt；Format&lt；HCons&lt；T，ArgList&gt；对于HCons&lt；fvar，FmtList&gt；，其中FmtList：Format&lt；ArgList&gt；，T：ToString，{FN Format(&amp；self，args：HCons&lt；T，ArgList&Gt；)。Self.ail.format(args.ail)}}。</p><p>注意观察头部和尾部正在访问哪个H列表。这里，args H列表通过args.head提供填补漏洞的数据。</p><p>让Example=hlist！[FString(&#34；Hello&#34；)，fvar，FString(&#34；！第一个素数是&#34；)，fvar]；assert_eq！(示例.format(hlist！[&#34；world&#34；，2])，&#34；Hello world！第一个素数是2&#34；)；</p><p>错误[E0308]：类型不匹配--&gt；src/printf.rs：48：18|48|example.format(hlist。</p><p>虽然错误是神秘的，但我们的错误至少在编译时被正确捕获。这是因为Rust推导出example.format()期望一个形状为HCons&lt；_、HCons&lt；_、HNil&gt；&gt；的H列表，但是它在我们的1元素H列表中发现HNil太快了。当提供太多参数时，也会出现类似的错误。</p><p>现在，我们的format函数只检查格式列表和参数列表是否相同长度。例如，我们可以扩展我们的格式结构，以确保fvar必须是特定类型，或者必须使用Debug vs Display。下面是这样一个战略的草图：</p><p>使用std：：marker：：PhantomData；//为是否使用显示或调试pub struct FDisplay；pub struct FDebug；添加标志//使用带有PhantomData的类型参数来表示所需的类型pub struct fvar&lt；T，Flag&gt；(PhantomData&lt；(T，Flag)&gt；)；//现在，格式列表和参数列表之间的T必须相同//还有，FDisplay。T，ArgList&gt；适用于HCons&lt；fvar&lt；T，FDisplay&gt；，FmtList：Format&lt；ArgList&gt；，T：Display，{FN Format(&amp；self，args：HCons&lt；T，ArgList&gt；)-&gt；string{//使用格式！是作弊，但会得到IDEA格式！(&#34；{}&34；，args)+&amp；self.ail.format(args.ail)}}//使用`FDebug`时，`t：Debug`的IMPL类似。</p><p>Haskell的仆人框架中的这篇博客文章让我开始思考如何将他们的策略应用到Rust中。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://willcrichton.net/notes/type-safe-printf/">https://willcrichton.net/notes/type-safe-printf/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/安全/">#安全</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/type/">#type</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/列表/">#列表</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1017802.html"><img src="http://img.diglog.com/img/2020/8/thumb_c643d180e38c0ecdd8f2041918dc48dc.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1017802.html">吉姆·胡德(Jim Hood)的个人资料，他在担任密西西比州股份公司(密西西比州股份公司)的16年间曾与谷歌发生争执，消息人士称，他现在为AG领导的多州反垄断调查提供建议</a></div><span class="my_story_list_date">2020-8-13 5:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1017650.html"><img src="http://img.diglog.com/img/2020/8/thumb_48db8eb787e01587afbae8abe49292fa.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1017650.html">Bevy：Rust构建的数据驱动游戏引擎和APP框架</a></div><span class="my_story_list_date">2020-8-12 6:17</span></div><div class="col-sm"><div><a target="_blank" href="/story/1017640.html"><img src="http://img.diglog.com/img/2020/8/thumb_769af75dabe542f0b70bf10286381710.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1017640.html">AVR支持合并到Rust Night</a></div><span class="my_story_list_date">2020-8-12 5:50</span></div><div class="col-sm"><div><a target="_blank" href="/story/1017593.html"><img src="http://img.diglog.com/img/2020/8/thumb_b4b73e0c1212ac8a4886f1077a7d32aa.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1017593.html">高通赢得美国反垄断诉讼芯片许可上诉</a></div><span class="my_story_list_date">2020-8-12 2:49</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>