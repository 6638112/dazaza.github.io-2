<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在工作中使用正式方法 Using Formal Methods at Work</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Using Formal Methods at Work<br/>在工作中使用正式方法 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-08 12:13:21</div><div class="page_narrow text-break page_content"><p>A few people have told me that they’ve enjoyed learning formal methods but aren’t sure how to actually use it. They’re mostly doing short sprints at work and aren’t building new systems from scratch. This tells me there’s some confusion about what makes specifications useful, and that we need a resource on applying them in practice. This is a short guide to using specifications at work in a way that’s accessible to beginners, applicable in many contexts, and provides solid business value.</p><p>一些人告诉我，他们享受了学习的正式方法，但并不确定如何实际使用它。他们主要在工作中进行短暂的冲刺，并没有从头开始构建新系统。这告诉我有一些关于使规范有用的东西的困惑，并且我们需要在实践中应用它们的资源。这是一个简短的指南，以便以初学者访问的方式在工作中使用规范，适用于许多上下文，并提供实力业务价值。</p><p> There’s a major disclaimer I have to make here:  I teach formal methods workshops for a living. That makes everything I write on formal methods at least a little bit of an advertisement. I’d rather be up front about that so you know what you’re getting into.</p><p> 我必须在这里制作一个主要免责声明：我教正式的方法是为了生活的讲习班。这使我在正式方法上写的一切至少是一点点的广告。我宁愿站在前面，所以你知道你正在进入什么。</p><p> If this is your first encounter with formal methods, you might be more interested in my essay on its  history and limitations, or my talk on its  practical applications.</p><p> 如果这是您的第一次遇到正式方法，您可能对我的历史和局限性的文章更感兴趣，或者我对其实际应用的谈话。</p><p>  I’m using formal specifications here to mean languages you can express high-level properties in, but formalized enough that you can machine-check them for conformance. This includes languages like  TLA+,    Alloy , and  Event-B, and excludes things like  Coq,  decision tables, and  Gherkin.  1</p><p>  我在这里使用正式规格来表达您可以表达高级属性的语言，但正式化，您可以为其进行计算机检查它们。这包括tla +等语言，   合金 和事件 -  B，并排除如CoQ，决策表和粗眼的东西。 1</p><p> This all assumes you’re writing a “typical” business or infrastructure system, whatever that’s supposed to mean. Some amount of minor bugs are tolerated, but major bugs are to be avoided. These are rough rules of thumb to keep in mind for your specs. Break them as appropriate.</p><p> 这一切都假定您正在编写“典型的”业务或基础设施系统，无论这是什么意思。有量的小错误是容忍的，但要避免重大错误。这些是粗略的拇指规则，以记住你的规格。酌情打破它们。</p><p>  Consider a component that receives a message and does something with it. If there’s a problem with the message, ill-formed, delivered wrong, anything, we instead do something else. The error checking, formatting, auditing, everything can be an entire subsystem, but if it’s not the one we care about we can collapse it all into something like this:</p><p>  考虑收到消息并与之执行某些消息的组件。如果消息有问题，不成熟，交付错误，任何事情，我们都做了别的事情。错误检查，格式化，审核，一切都可以是整个子系统，但如果不是我们关心的那个我们可以将它全部折叠成如此：</p><p>  This corresponds to “every message is good”, “every message is bad”, “the first ten messages are bad and the rest good”, etc. These are all valid paths in the spec, just as they all can happen in the real system. When I run a model checker against it, it will check all of these.</p><p>  这对应于“每条消息都很好”，“每条消息都很好”，“前十条消息很糟糕，其余的好的”等。这些都是规范中的所有有效路径，就像它们都能发生在真实中系统。当我对其运行模型检查器时，它将检查所有这些。 </p><p>  Specs don’t need to describe the total behavior of the system. If your system does A, B, and C, it’s usually much faster to write three different specs, each of which assumes two of the components are already working correctly. A fourth spec might show how all three interact, but with less detail about each component than the specialized specs have.</p><p>规格无需描述系统的总行为。如果您的系统执行A，B和C，则写入三种不同的规格通常会更快，每个规格都假定两个组件已经正常工作。第四个规范可能会展示所有三个交互，但与每个组件的细节更少，而不是专门规范。</p><p> This doesn’t give you as much detail comprehensiveness as modeling everything at once, but it has a lot of benefits. First, each partial spec can focus on what you care about with that component. Second, you can use each partial spec without having to whole system designed out; it’s useful more early. Third, it model checks a lot faster. Four, composing specs is a  lot harder than writing independent specs, and you often have to “weaken” a spec to easily pull off composition.   2</p><p> 这并不会给您带上一切的详细信息，但它有很多好处。首先，每个部分规范都可以关注您对该组件关注的内容。其次，您可以使用每个部分规格而无需整个系统;这更早是有用的。第三，IT模型需要更快地检查。四，编写规格比写独立规格更难，您通常必须“削弱”一种规格，以轻松剥离组成。 2</p><p>  A corollary of the first two. A high level spec can be orders of magnitude smaller than the actual code.</p><p>  前两个的推论。高级规格可以是比实际代码小的数量级。</p><p>  The more time you invest in writing a spec, the more comprehensive it is. But- as with everything- there’s diminishing returns. It requires a lot more work to go from 95% correct to 99% correct than to go from 85% to 95%. I’m staying in that zone of maximal returns, purely because it’s what’s most accessible and pragmatic for most people. Speccing in this style won’t make your software bug-free, but it will make it much higher quality than not speccing at all.</p><p>  您投资编写规格的时间越多，它就越全面。但是 - 与一切一样 - 回报率递减。它需要更多的工作来从95％右转到99％，比率从85％到95％。我住在那个最大回报的区域，纯粹是因为它是大多数人最可靠和务实的。在这种情况下，在这种情况下不会让您的软件无窃听，但它将使得其质量远远高于对其进行投射的。</p><p>  Most formal specification languages cannot be automatically  refined: you can’t easily verify your lines of code match the specification. In some ways this is a problem, but it also has a surprising benefit: the spec exists apart from your code and is not a dependency. This means that trying specifications, unlike trying new languages, does not carry a risk of technical debt or add any maintenance burden. You also don’t have to change the code to make writing specs possible. This all reduces the friction of experimenting with FM. Harder than trying a new monitor setup, but easier than adding Elixir to your tech stack or getting your coworkers to pair program.</p><p>  大多数正式的规范语言不能自动精制：您无法轻松验证您的代码行匹配规范。在某些方面，这是一个问题，但它也有一个令人惊讶的好处：除了你的代码之外，规格也不存在，而不是依赖性。这意味着尝试规格，与尝试新语言不同，不带有技术债务的风险或增加任何维护负担。您也不必更改代码以使编写规范成为可能。这一切都降低了FM试验的摩擦。比尝试新的监视器设置更难，但比将Elixir添加到您的技术堆栈或让您的同事才能配对程序。</p><p>  There are two kinds of system errors:  implementation errors and  design errors. Tests are good for showing your code matches your expectations but very bad for showing your expectations match your needs. Specs are the opposite. You need both. Specs are also not documentation, code review, code static analysis, or post-release analytics. It might make it easier to do all of them, but it does not remove the need for them.</p><p>  系统错误有两种：实现错误和设计错误。测试很好地显示您的代码匹配您的期望，但对您的期望符合您的需求非常糟糕。规格是相反的。你需要两者。规格也不是文档，代码审查，代码静态分析或发布后分析。它可能会更容易完成所有这些，但它不会消除对它们的需求。</p><p> There are cases where specs can remove the need for code testing, but that kind of spec is  much harder to write and useful in a more specialist domain.</p><p> 有些情况下，规格可以消除对代码测试的需要，但是这种规范更难在更专业的域中编写和有用。 </p><p>    (3) is the most  unique benefit and arguably the one that delivers the most  obvious business value. But all of these are very valuable. The easiest ways to start applying specifications mostly give you (1) and (2). Since people don’t notice those benefits as much, it makes them think they have to dive into the deep end to get any use out of specs.</p><p>（3）是最独特的好处，可以说是提供最明显的商业价值的好处。但所有这些都是非常有价值的。开始应用规格的最简单方法主要是给您（1）和（2）。由于人们没有注意到这些利益，因此他们认为他们必须潜入深渊以获得任何用尽规格。</p><p> The following projects are in ascending order of effort/skill. This is a rough guide, not a lesson plan: don’t feel obligated to do them all as “exercises” or anything. You can use this to figure out where you’re most comfortable starting and how you’re most comfortable progressing. This is also not in ascending order of  usefulness. Even documenting your own systems can be very useful.</p><p> 以下项目采用努力/技能的升序顺序。这是一个粗略的指导，而不是一个课程计划：不觉得有义务以“练习”或任何东西都这样做。您可以使用它来弄清楚您最舒适的位置，以及您最舒适的进步。这也不是有用的升序。甚至记录自己的系统也非常有用。</p><p>  Take a system you’ve worked with for a while, that you think you know pretty well. Write a high level specification of the architecture or some of its features. Don’t worry about composing specs, just write disconnected models of various points of interest. You aren’t necessarily looking for errors in the architecture; the goal is to get hands-on practice writing a spec. If your spec shows behavior you don’t see in the existing system, it’s usually a sign that you made a mistake in writing the spec.</p><p>  拿一个你有一段时间的系统，你认为你很好地了解。编写架构的高级规范或其一些功能。不要担心编写规格，只需写出各种兴趣点的断开连接的型号。您不一定正在寻找架构中的错误;目标是让实践练习撰写规格。如果您的规格显示在现有系统中没有看到的行为，则通常是您在编写规范中犯了错误的标志。</p><p> Usually. It’s also possible that you misunderstood some aspect of the system. This is useful to know, but the uncertainty (is it a translation error or an understanding error?) might not be great for improving your modeling skill. That’s why you document a system you know well. It isolates just the modeling practice.</p><p> 通常。您也可能误解了系统的某些方面。这很有用，但不确定性（是翻译错误或理解错误？）可能对提高您的建模技能可能并不重要。这就是为什么你记录一个系统你知道的系统。它只隔离建模实践。</p><p> There’s also a chance that you didn’t make any mistakes and there’s actually a subtle problem with the system. This happens a lot more often than you’d expect. I’d say if you’re just starting out to still consider this a possibility, but not to make it your first assumption.</p><p> 您也有机会犯有任何错误，并且系统实际上是一个微妙的问题。这比你期望的频率更大。我会说如果你刚刚开始仍然考虑这种可能性，而且不是为了使你的第一次假设。</p><p> While doing this focuses on you learning FM, it still produces enough tangible benefits for a business case. First, you have a spec of your system, with the assumptions, behavior, and requirements rigorously stated. I’ve found that this makes a great documentation supplement when explaining something to other engineers. Also if you later need to modify the system, you already have the model part done.</p><p> 在这样做的同时，专注于您的学习FM，它仍然为商业案例产生足够的有形益处。首先，您拥有系统的规范，具有严格陈述的假设，行为和要求。我发现这在向其他工程师解释某些东西时，这使得补充了一个很好的文档补充。此外，如果您稍后需要修改系统，则已完成模型部分。</p><p>  Take a system for which you’ve fixed a complicated bug. Write a model that matches the broken version of the system and show that it catches the same bug. This gives you good practice with writing invariants. It also helps you find invariants for the existing system: what’s the weakest possible property that is violated by the bug?</p><p>  采用您修复了复杂错误的系统。编写一个匹配系统破碎版本的模型，并显示它捕获相同的错误。这为您提供了写作不变性的良好练习。它还可以帮助您找到现有系统的不变性：BUG违反的最薄弱的属性是什么？ </p><p> There’s an ulterior reason to do this, too: it’s great for showing the value of writing specifications. If you have data on how long the bug was present and how long it took to find the bug, you can show the time difference between “catching this bug in production” and “catching this bug in the model”. The difference could very well be something like “several weeks” versus  half an hour.</p><p>还有一个难题的理由，也是如此：它很好地展示了写作规范的价值。如果您有关于出现错误的数据以及查找错误需要多长时间，您可以显示“在生产中捕获此错误”和“在模型中捕获此错误”之间的时间差。差异很可能是“几周”与半小时相比的东西。</p><p>  Take an existing system with an observed bug and write a model that has the bug. This is different from showcasing a bug in that you don’t have full information on the bug, as you haven’t actually localized or fixed it yet. The purpose of the spec is to make it easier to find the bug. If you can accurately reproduce it in the model, it will show you the series of steps that leads to the bug. You can then determine where things start going sideways in the spec, and use that to localize the bug in the code itself.</p><p>  使用观察到的错误拍摄现有系统，并写出具有错误的模型。这与showcasing一个错误不同，因为您没有实际本地化或修复它的错误。规范的目的是让它更容易找到错误。如果您可以在模型中准确地重现它，它将向您展示导致错误的一系列步骤。然后，您可以确定在规范中开始侧向的位置，并使用它来定向代码本身中的错误。</p><p> If you can’t reproduce the bug, it could be from a few common reasons. One is that the spec could be too high level. You might be abstracting the error handling as correct but you actually missed an error case. Another is that the bug could be a  slip: you got some implementation detail wrong. Think something like writing  merge(f, g) instead of  merge(g, f), putting two lines in the wrong order, etc. These are all problems that easily sneak past a spec. Specs are better at reproducing bugs from holes in the design, or when a design has “correct” but unintended behavior.</p><p> 如果您无法重现错误，则可能会从几个常见的原因中。一个是规范可能太高。您可能会抽象正确处理正确处理，但实际上会错过错误情况。另一个是这个错误可能是一个滑块：你有一些实施细节错误。想想写作合并（f，g）而不是合并（g，f），以错误的顺序放置两行等。这些都是容易潜入规格的所有问题。规格在设计中的漏洞中更好，或者当设计有“正确”但意外行为时。</p><p> Sometimes you’ll find the bug because of the model checker. In many cases, though, the spec makes the bug “obvious”. It’s much easier to see a race condition in 10 lines of spec than in 1,000 lines of code. This leads to a common beginner frustration with formal specifications, that they’ve already figured things out before finishing the model. This is actually one of the big benefits of specification: most of the model checking can happen in your head.</p><p> 有时由于模型检查器，您会发现错误。但是，在许多情况下，规范使得错误“显而易见”。在10行的规格中看到比在1,000行代码中更容易。这导致了与正式规格的共同初学者挫折，在完成模型之前已经弄清楚了。这实际上是规范的大益处之一：大多数模型检查都可能发生在你的头脑中。</p><p> One example I worked on: why wasn’t a kill-switch working? After a couple days fruitlessly trying to track it down, I wrote a spec and immediately went “oh right, the kill-switch prevented us  enqueueing jobs, not  processing them.” Obvious in the spec, less so in the codebase.</p><p> 我工作的一个例子：为什么不是杀手切换工作？经过几天的几天毫不含糊地试图跟踪它，我写了一个规格并立即走了“哦，杀手 - 交换机阻止了我们遏制了工作，没有处理它们。”在规范中显而易见，在Codebase中少得多。</p><p>  Take a system you want to understand better and write a model for it. A spec error is much more likely to mean you misunderstood something than a failed spec meant for your own system. But writing the spec will help significantly even before you verify it. You can’t really handwave in a spec: everything you write must be precise and rigorous. This does wonders for understanding something.</p><p>  采取您想要更好地了解的系统并为它写模型。规格错误更有可能意味着您误解了某种东西，而不是为您自己的系统意味着的错误。但是甚至在验证之前，写作规范将有助于帮助。您无法在规范中实际手中：您写的一切都必须精确且严谨。这会让奇迹理解一些事情。</p><p> It also provides a good way to verify your knowledge is correct. You can see what happens when you run it through a model checker and compare it to the behavior of the real system. You can also show the model to a domain expert and see if it matches their understanding of the system.  3 If it does not, you have a precise way of knowing how your understanding diverges.</p><p> 它还提供了验证您的知识的好方法。您可以通过模型检查器运行并将其与真实系统的行为进行比较时，查看会发生什么。您还可以将模型显示为域专家，并查看它是否与其对系统的理解相匹配。 3如果没有，您有一个精确的方式来了解您的理解差异。 </p><p> In my experience you’re also more likely to find critical bugs by modeling unfamiliar systems than ones you’re familiar with. I have no idea why. Regardless if you decide to bring up a bug with someone, remember to be respectful and empathetic. Just as specs don’t replace tests, specs don’t replace social skills.</p><p>在我的经验中，您也更有可能通过模拟不熟悉的系统而不是熟悉的系统来找到关键的错误。我不知道为什么。无论您如何决定与某人带来错误，记得要尊重和善意。正如规格不替代测试，规格不替代社交技能。</p><p>  Take a system, a model of that system, and a new requirement or desired change. Show that it does not satisfy the requirement, and then modify the model until it does.</p><p>  采取系统，该系统的模型，以及新的要求或期望的变化。表明它不满足要求，然后在它确实之前修改模型。</p><p> At least in my experience this ends up being the most regular use of FM on a project. Since the spec is high level, most changes will map to only a few lines of modified spec. Before you make a change, vet that the change you make actually does what you want. This helps you understanding what you’re doing. It also helps a ton with finding bugs, showing how a small change in your system propagates into global invariant violation.</p><p> 至少在我的经历中，这最终是在项目上最常使用FM。由于规范高级别，大多数变化将映射到几行修改规范。在进行更改之前，兽医您认为的变化实际上是您想要的。这有助于您了解您正在做的事情。它还有助于查找错误，显示系统的小型变化如何传播到全局不变的违规状态。</p><p> Another benefit you get here: Writing a spec sanity-checks the requirements. If I say “at least one node must always be online”, do I mean “there is at least one node that is online the entire time” or “at all points in time, there is at least one node online”?  4 It’s a lot easier to see the difference when writing a spec than when knee-deep in the codebase. Sometimes the client will be able to clarify which they meant, and in rare cases the client will realize they don’t actually know what they want.</p><p> 您到达的另一个好处：写真理智 - 检查要求。如果我说“至少一个节点必须始终在线”，我的意思是“至少有一个节点在整个时间在线”或“在所有时间点，至少有一个节点在线”？ 4在编写规格时看到差异比keee-Deeple在码Base中的膝盖时，更容易得多。有时客户将能够澄清他们的意思，并且在极少数情况下，客户将意识到他们实际上并不知道他们想要什么。</p><p>  Make a new system from scratch, using specifications. Alternatively, add a significant new feature to a system using specs. This requires the most skill in both writing specs and knowing when to  stop writing a spec, but it’s actually not that much harder than modeling an existing system. It also has the most drastic benefits, as you’re getting all of the knowledge boosting and model-checking right from the start.</p><p>  使用规范从头开始制作新系统。或者，使用规范向系统添加显着的新功能。这需要编写规范的最多技能，并知道何时停止编写规范，但实际上并没有比建模现有系统更难。它还具有最激烈的好处，因为您从一开始就获得所有知识升高和模型检查。</p><p> A common beginner mistake is trying to model the system in too much detail before you start building it. Remember, the spec is your design. It’s incredibly valuable to have a design, but it’s not the code, and much of the code you write won’t be reflected in the design. It doesn’t matter to the system the specific classes or functions you have, just that there is a behavior they produce.</p><p> 在开始建立它之前，共同初学者错误试图在太多细节中模拟系统。请记住，规格是您的设计。有一个设计是非常有价值的，但这不是代码，您写的大部分代码都不会反映在设计中。对系统无关紧要您拥有的特定类或函数，只是存在他们产生的行为。</p><p>  One of the big things you might notice: these are all iterative. You’re not spending weeks and months writing exhaustive specifications before doing a day of coding. And you’re not blindly following a plan: if reality intervenes you adjust the spec and see what the consequences are. The spec is there to amplify your ability to think through the design, not force you on a rigid path.</p><p>  您可能注意到的大事之一：这些都是迭代的。在做一天的编码之前，您不会花几个星期和几个月写下详尽的规格。而且您并不盲目地在计划之后：如果现实介入您调整规范并查看后果的结果。规范是在有用于通过设计思考的能力放大，而不是强迫您在刚性路径上。 </p><p> The biggest gap here is that this is all individual-based, not team-based. Enterprise FM is still extremely new as a practice, so we don’t have solid information on how it fits into a larger team workflow. There’s a few different companies adopting FM more widely and I’m excited to see how it works out for them.</p><p>这里最大的差距是，这是基于个人的，而不是基于团队的。 Enterprise FM仍然是一种练习，因此我们没有关于它如何适应更大的团队工作流程的扎实信息。有一些不同的公司更广泛地采用FM，我很高兴看到它是如何为他们工作的。</p><p> There are some projects where exhaustive specification makes sense. Most of us aren’t doing those. There are some projects where specs don’t make sense at all. Most of us aren’t doing those, either. We’re in the sweet spot where  some form of specification helps a lot, but the vast majority of us don’t use it.</p><p> 有一些项目，详尽的规格有意义。我们大多数人都没有这样做。有一些项目根本没有意义。我们大多数人都没有这样做。我们在某种形式的规格有助于很多的甜蜜点，但绝大多数我们都不使用它。</p><p> But part of using something well is knowing when it applies. So to make specifications useful, we should also know when they aren’t.</p><p> 但是一些使用的东西的一部分是何时适用。因此，制作规格有用，我们也应该知道它们的时间。</p><p>  You don’t write specs when it’s not worth writing specs. Of course that’s circular, we’re more interested in what makes it not worth writing specs. There’s actually two facets to this question: when not to write specs at all, and when not to add more lower-level detail to an existing spec. Both are driven by the same constraints.</p><p>  当它不值得书写规范时，您不会写规格。当然，这是通函，我们对什么不值得书写规范更感兴趣。实际上有两个方面是这个问题：什么时候不能编写规格，并且当不向现有规范添加更多较低级别的细节时。两者都是由相同的约束驱动。</p><p> There are some things that make specs less useful. Speccing might still be worthwhile even if these hold, but you’d likely be investing less time and effort into it. Also, this is biased towards my experiences with specifications: there could be languages out there that are good for these kinds of problems.</p><p> 有一些东西使规格不太有用。即使这些持有，仍然可能是值得的，但你可能会投入更少的时间和努力。此外，这对我的经验偏见了规格：可以在那里有语言对这些问题有好处。</p><p>  If there’s an error, it’s obvious, easy to isolate, and causes few issues. This doesn’t mean you don’t want errors, it just means that you can quickly find and fix them. One example is a batch job that looks at a low volume of data and constructs a report: most of the errors that a spec would surface would be obvious in production, and once you fix it you can easily rerun on the old data. Ideally. Specs could still help here, but their correctness benefits are less valuable.</p><p>  如果出现错误，很明显，易于隔离，并导致一些问题。这并不意味着您不想要错误，这意味着您可以快速找到并修复它们。一个示例是一个批处理作业，它看起来低量的数据并构建一个报告：大多数错误都会在生产中显而易见的错误，并且一旦您修复它，您就可以轻松地重新运行旧数据。理想情况下。规格仍然可以帮助这里，但它们的正确性效益不太有价值。</p><p>  Not all code is a projection of some abstract design. Sometimes the essential idea lies at the code level, in which case a spec is missing the trees for the forest.</p><p>  并非所有代码都是一些抽象设计的投影。有时，基本理念位于代码级别，在这种情况下，规格缺少森林的树木。 </p><p> A lot of munging and data plumbing is like this. Take a program that hits ten APIs, extracts the information and splices it together. There’s some higher-level design there, with error handling and the retry behavior and all, but the majority of the work lies in the implementation-level transformations of the raw data. Design specs are too far removed from that to be much help; you want something closer.</p><p>很多颈部和数据管道都是这样的。拍摄一个击中十个API的程序，提取信息并将其拼接在一起。那里有一些更高级别的设计，错误处理和重试行为和所有，但大多数工作都在于原始数据的实现级转换。设计规格太远了，从中取消了很多帮助;你想要一些更近的​​东西。</p><p> And any kind of numerical computing is right out. Most specification languages can express integers but very few can actually model-check them. The only tool I’ve seen that can handle any kind of real number is  PRISM, which has… other issues.  5 You will not be verifying your mathematical operations at the design level.</p><p> 任何类型的数值计算都是正确的。大多数规格语言都可以表达整数，但很少有可能模拟 - 检查它们。我看到的唯一工具可以处理任何类型的实数是棱镜，它有......其他问题。 5您将不会在设计级别验证您的数学运算。</p><p>  As the Agile folk are fond of saying, the best way to understand what people need is to see how they interact with an existing system. But that doesn’t necessarily mean the system has to be complete: often a prototype is enough. Requirements change often, and our understanding of what’s needed in the early stages is often minimal. There are some properties a system probably  shouldn’t have, like “crashes randomly” or “explodes”. But these aren’t necessary properties of a prototype! If a person is using a system to understand what they want from the system, then it’s less important that the system “work”. We’re gathering data.</p><p>  随着敏捷的民间喜欢说，了解人们需要的最佳方式是看他们如何与现有系统互动。但这并不一定意味着系统必须完整：通常是原型就足够了。需求经常变化，我们对早期阶段所需的了解通常是最小的。系统可能不应该有一些属性，例如“随机崩溃”或“爆炸”。但这些不是原型的必需属性！如果一个人使用系统来了解他们想要的系统，那么系统“工作”的重要性不太重要。我们正在收集数据。</p><p> In a sense, the prototype takes the place of the spec in this stage: instead of iterating on a spec to find system issues, you’re iterating on a prototype to find client issues.</p><p> 从某种意义上说，原型在这个阶段取代了规范的位置：您可以在迭代原型以查找客户端问题的规范中迭代。</p><p>  This one’s a little messier than the rest. One of my software beliefs is that most programs are either written to  automate something so humans don’t have do to it, or  augment a human so they can do something better. Graydon Hoare calls this the difference between  batch processing and interactive computing. The lines between the two aren’t clear-cut: is a calculator automating away the rote computation or augmenting your ability to do calculations? Little of both, really. But I still find this a useful model.</p><p>  这个比其他人更乱。我的一个软件信念是，大多数程序都是写入自动化的东西，所以人类没有对它做的，或者增加一个人，所以他们可以做得更好。 Graydon Hoare称之为批处理和交互式计算之间的差异。两者之间的线路没有清除：是一个计算器，自动化死记硬背计算或增加您的计算能力吗？一点两人，真的。但我仍然找到这个有用的模型。</p><p> In my experience, specs are much more useful for automations than augmentations. In an automation, a human might start it up but not necessarily do anything afterwards, so it’s more important that it satisfies invariants. Augmented code has a human constantly in the loop, who can adjust the system and self-correct.</p><p> 在我的经验中，对自动化的规格比增强更有用。在自动化中，人类可能会开始它但是之后不一定做任何事情，因此它更重要的是它满足不变性。增强代码在循环中不断地具有人类，谁可以调整系统和自我正确。</p><p>  Okay, you’ve read this far, time for the pitch. Formal methods are an incredibly powerful tool. The biggest barrier to using them, in my opinion, is education. FM requires a different mindset from coding and sometimes people have trouble building the intuition. There’s also an implicitly-assumed set of math skills that are easy to learn but hard to realize you need to learn. I wrote  a book to help people with this, but nothing beats having an experienced teacher.</p><p>  好的，你已经读过这一点，时间的时间。正式方法是一个非常强大的工具。在我看来，使用它们的最大障碍是教育。 FM需要不同的思维思想，有时人们有困难构建直觉。还有一个含有隐含的数学技能集，很容易学习，但很难意识到您需要学习。我写了一本书来帮助人们，但没有任何经验丰富的老师则没有任何措施。 </p><p> You can hire me to do corporate workshops or provide 1-on-1 training to people in your company. I’ve had clients see savings of six-figure savings per year by writing specs, for much the same reasons you save money writing tests. You can contact me  here or read more about my services  here.</p><p>您可以聘请我做公司研讨会，或向您公司人员提供1-ON-1培训。我有客户通过写作规格，每年节省六位数节省，因为您节省了金钱写作测试。您可以在此与我联系或在此处阅读更多关于我的服务。</p><p>  Very briefly: Coq is more for verifying code than designs, which is a more specialist domain. Decision tables are  flyweight methods: easy to learn and use, applicable in focused, narrow contexts. Gherkin is informal and code-level, not design-level.   [return]</p><p>  非常简单：CoQ更多用于验证代码而不是设计，这是一个更专业的域名。决策表是Flyweight方法：易于学习和使用，适用于聚焦，狭窄的上下文。 gherkin是非正式和代码级，而不是设计级别。   [返回]</p><p> There’s lots of reasons for this. One is the  frame problem: X’s doesn’t say what happens to the values in Y’s spec and vice versa, so the composed spec is ill-defined unless you carefully define how they compose.   [return]</p><p> 这有很多原因。一个是框架问题：X没有说y的规范中的值和反之亦然的结果，所以组成的规范是没有定义的，除非你仔细定义它们的编写方式。   [返回]</p><p> This requires them to understand the spec language, of course. But I’ve found if you walk someone through a spec, you can explain exactly as much as they need to know relatively quickly. It’s easier to learn to read specs than learn to write them.   [return]</p><p> 当然，这需要他们了解规范语言。但是我发现了如果您通过规格漫步，您可以完全解释他们需要相对较快的信息。学习读取规格比学习写给它们更容易。   [返回]</p><p> More formally, it’s the difference between  ∃n ∈ Nodes:□ Online(n) and □ ∃ n ∈ Nodes: Online(n).   [return]</p><p> 更正式地，这是∃n∈节点之间的区别：□在线（n）和□∃n∈节点：在线（n）。   [返回]</p><p> Like the lack of arrays. And strings. And functions. PRISM is an interesting but  extremely niche modeling language.   [return]</p><p> 喜欢缺少数组。和字符串。和功能。棱镜是一个有趣但极其利益的建模语言。   [返回] </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.hillelwayne.com/post/using-formal-methods/">https://www.hillelwayne.com/post/using-formal-methods/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/methods/">#methods</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>