<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>半小时学习r A half-hour to learn R</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A half-hour to learn R<br/>半小时学习r </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-22 20:04:00</div><div class="page_narrow text-break page_content"><p>Karolis Koncevičius  This article, inspired by a similar tutorial about Rust  (1), tries to go over the main features of R language in a time-span of 30 minutes.It introduces most of R-specific concepts like vectorisation, recycling, subsetting, matrix and data.frame objects, as well as various built in types.Control statements, and function/object declarations are currently omitted.</p><p>KarolisKoncevičius这篇文章受到类似于Rust（1）的类似教程的启发，试图在30分钟的时间跨度中跨越R语言的主要特征。介绍了vectorisation，回收，子集等大多数R特定概念。矩阵和数据。帧对象以及目前省略了Constrol语句和功能/对象声明的各种构建。</p><p>  R stores data in a number of different object types.Below are some objects of different types:</p><p>  R在多种不同的对象类型中存储数据.Below是不同类型的某些对象：</p><p>   NaN # double &#34;not a number&#34;Inf # double &#34;infinity&#34;-Inf # double &#34;negative infinity&#34;NA # logical &#34;missing&#34; valueNA_integer_ # integer &#34;missing&#34; valueNA_real_ # double &#34;missing&#34; valueNA_complex_ # complex &#34;missing&#34; valueNA_character_ # character &#34;missing&#34; valueNULL # special variable without a type</p><p>   nan＃double＆＃34;不是数字＆＃34; inf＃double＆＃34;无限＆＃34; -inf＃double＆＃34;负无限＆＃34; na＃逻辑＆＃34;缺少＆＃34; valuena_integer_＃整数＆＃34;缺少＆＃34; valuena_real_＃double＆＃34;缺少＆＃34; valuena_complex_＃complex＆＃34;缺少＆＃34; valuena_character_＃字符＆＃34;缺少＆＃34; Valuenull＃特殊变量没有类型</p><p>    + # addition- # subtraction/ # division* # multiplication^ # power** # alternative notation of power! # negation&amp; # logical and| # logical or== # equals!= # not equals&gt; # greater than&gt;= # greater than or equal&lt; # less than&lt;= # less than or equal</p><p>    +＃添加 - ＃减法/＃division *＃乘法^＃POWER **＃替代电力符号！ ＃否定＆amp; ＃逻辑和| ＃逻辑或==＃等于！=＃不是等于＆gt; ＃大于＆gt; =＃大于或等于＆lt; ＃小于＆lt; =＃小于或等于</p><p>  TRUE | FALSE 2 + 2 3 * 103+0i + 0+1i 3 == 10 4 &lt; Inf &#34;a&#34; != &#34;b&#34;</p><p>  真实|假2 + 2 3 * 103 + 0i + 0 + 1i 3 == 10 4＆lt; inf＆＃34; a＆＃34; ！=＆＃34; B＆＃34;</p><p>      10 / 0 # Inf -2 / 0 # -Inf 0 / 0 # NaN-1+0i / 0 # NaN+NaNi</p><p>      10/0＃INF -2 / 0＃-INF 0/0＃NAN-1 + 0i / 0＃nan + nani</p><p>  1^NA # 12^NA # NANA^0 # 1TRUE | NA # TRUETRUE &amp; NA # NAFALSE | NA # NAFALSE &amp; NA # FALSE</p><p>  1 ^ na＃12 ^ na＃nana ^ 0＃1true | na＃truetrue＆amp; na＃nafalse | na＃nafalse＆amp; na＃false. </p><p>   Since the available symbols on the keyboard are not enough to cover all necessary operators, other, lesser used operators are defined by surrounding them with a percent symbol  %:</p><p>由于键盘上的可用符号不足以覆盖所有必要的运算符，因此通过百分比符号％括起来定义了其他使用的运算符：</p><p> %/% # integer division%% # residual after integer division (modulo)27 %/% 24 # result = 127 %% 24 # result = 3</p><p> ％/％＃整数分割%%＃剩余分割后（modulo）27％/％24＃结果= 127 %% 24＃结果= 3</p><p>  Variable names must start with a dot or a letter and contain only letters, numbers, dots, and underscores.They cannot overwrite existing special values like  NA and  TRUE.Three assignment operators can be used to achieve the same thing:</p><p>  变量名称必须以点或字母开头，只包含字母，数字，点和下划线。他们不能覆盖现有的特殊值，如na和true.threve赋值运算符来实现同一件事：</p><p>  In addition R allows to define “non syntactic” identifiers.Standard variable names must follow defined rules but backtick quotation forces any string to be evaluated as an identifier:</p><p>  此外，r允许定义“非语法”标识符。标准变量名称必须遵循定义的规则，但反向点引号强制将任何字符串评估为标识符：</p><p> x &lt;- 12 &lt;- 1 # error`2` &lt;- 1 # bypasses normal evaluation and treats &#34;2&#34; as variable namex # standard way of referring to variable named &#34;x&#34;`x` # refers to the same variable2 # object 2 of type double`2` # refers to non-syntactic variable &#34;2&#34;</p><p> x＆lt;  -  12＆lt;  -  1＃error`2＆lt;  -  1＃绕过正常评估和治疗＆＃34; 2＆＃34;作为可变名称x＃标准方式引用名为＆＃34的变量; x＆＃34;`x`＃是指双层2`＃的相同变量2＃对象2。是指非语法变量＆＃34; 2＆＃ 34;</p><p>  Functions are called by typing the function name and parentheses with a list of passed parameters.Parameters can be specified by either their position or their name.</p><p>  通过用传递的参数列表键入函数名称和括号来调用函数.Parameters可以由其职位或其名称指定。</p><p>  All the operators demonstrated previously are also functions and can be called in the same manner:</p><p>  以前展示的所有运算符也是功能，可以以相同的方式调用： </p><p>          help(Syntax) # to read about precedence levelshelp(Reserved) # R&#39;s list of reserved symbolshelp(NumericConstants) # parser rules for treating numeric constantshelp(Quotes) # parser rules for treating quoted strings</p><p>帮助（语法）＃读取关于优先级别的precequeld leomshelp（保留）＃r＆＃39; s保留symbolshelp（numericConstants）＃解析器规则的r＆＃39;用于处理数字常量shelp（引用）＃解析器规则以处理引用字符串的规则</p><p>    Almost every object in R is vectorized - it can contain multiple elements and has an attribute called “length”.</p><p>    R的几乎每个对象都是矢量化 - 它可以包含多个元素，并且具有称为“长度”的属性。</p><p>     vec1 &lt;- c(1, 2)vec2 &lt;- c(2, 3)c(vec1, vec2)c(c(1,2), c(2,3)) # samec(c(1,2,2,3)) # also samec(1,2,2,3) # same as well</p><p>     Vec1＆lt;  -  c（1,2）vec2＆lt; c（2,3）c（vec1，vec2）c（c（1,2），c（2,3））＃samec（c（1,2 ，2,3））＃也是samec（1,2,2,3）＃也是</p><p>    c(TRUE, 1L) # integerc(TRUE, 1) # doublec(1L, 1+1i) # complexc(TRUE, &#34;A&#34;) # characterc(NA_integer_, NA_real_) # double</p><p>    c（true，1l）＃integerc（true，1）＃doublec（1l，1 + 1i）#creadcc（true，＆＃34; a＆＃34; a＆＃34;）＃characterc（na_integer_，na_real_）＃double</p><p>  x &lt;- c(1, 2, 3)y &lt;- c(0, 10, 1)x + 1 # 2 3 4x + y # 1 12 4x &gt; 2 # FALSE FALSE TRUEx &gt; y # FALSE TRUE FALSE</p><p>  X＆lt; c（1,2,3）y y＆lt; c（0,10,1）x + 1＃2 3 4x + y＃1 12 4x＆gt; 2＃false false truex＆gt; y＃false true false</p><p>  x &lt;- c(1, 2, 3, 4, 5)y &lt;- c(2, 1, 3, 1, 5)mean(x)sum(y)log2(x)cor(x, y)paste(x, y)</p><p>  x＆lt; c（1,2,3,4,5）y y＆lt; c（2,1,3,1，5）平均值（x）和（y）log2（x）cor（x，y）粘贴（x，y）</p><p>        R can apply binary operators on vectors of different lengths.In this case recycling takes place - the shorter vector is extended to match the length of the longer one by recycling its elements starting from the first one:</p><p>        r可以在不同长度的矢量上应用二进制运算符。在这种情况下，发生回收 - 较短的向量扩展到通过从第一个启动的元素回收其元素来延长较短的向量，以匹配较长的矢量： </p><p> x &lt;- c(1, 1, 1, 1)y &lt;- c(0, 1) # original after recylcingx + y # x = 1 1 1 1 x = 1 1 1 1 # y = 0 1 y = 0 1 0 1</p><p>x＆lt; c（1,1,1,1）y y＆lt; c（0,1）＃原始RecyLcingx + Y＃x = 1 1 1 1 1 1 1 x = 1 1 1 1＃y = 0 1 y = 0 1 0 1</p><p>  # subtract 1 from each element in xx &lt;- c(1, 2, 3, 4)x - 1# check which elements of x are greater than 2x &lt;- c(1, 2, 3, 4)x &gt; 2# turn every second element of x to 0x &lt;- c(1, 2, 3, 4)y &lt;- c(0, 1)x * y</p><p>  ＃从XX x的每个元素中减去1（1,2,3,4）x-1＃检查x的哪个元素大于2x＆lt; c（1,2,3,4）x＆gt; 2＃将x到0x的每个第二元素转动，x至0x＆lt; c（1,2,3,4）y < -  c（0,1）x * y</p><p> When the longer vector is not a multiple of the shorter one - recycle takes place but a warning is displayed:</p><p> 当较长的向量不是较短的一个 - 回收的倍数时，会发生警告：</p><p> c(1, 2, 3) - c(0, 1)# Warning message:# In c(1, 2, 3) - c(0, 1) :# longer object length is not a multiple of shorter object length</p><p> c（1,2,3） -  c（0,1）＃警告消息：＃在c（1,2,3） -  c（0,1）中：＃较长的对象长度不是较短的对象长度的倍数</p><p>  A vector can be treated as an array of elements, hence we might want to subset it by selecting only a fraction of those elements.In R this is performed using the  [ operator.</p><p>  矢量可以作为元素数组被视为元素，因此我们可能希望仅通过选择这些元素的一小部分来子集。在使用[运算符。</p><p>  Elements can be selected by specifying the desired positions (numbering in R starts from 1).</p><p>  可以通过指定所需位置来选择元素（R中的编号从1开始）。</p><p> x &lt;- c(10, 20, 30, 40)x[4]x[1:2]x[0] # selects &#34;nothing&#34; - returns an empty vectorx[c(1,1)] # same element can be selected multiple timesx[5] # NA (element with unknown value)</p><p> x＆lt; c（10,20,30,40）x [4] x [1：2] x [0]＃选择＆＃34;没有＃34; - 返回空vectorx [c（1,1）]＃可以选择多个timex [5]＃na（具有未知值的元素） </p><p>  x &lt;- c(10, 20, 30, 40)x[-1]x[c(-1,-3)]x[c(-1,-1)] # same element is &#34;removed twice&#34;x[-5] # doesn&#39;t change x in any way</p><p>x＆lt; c（10,20,30,40）x [-1] x [c（-1，-3）] x [c（-1，-1）]＃相同元素是＆＃34;删除两次＆＃34; x [-5]＃＆＃39; t以任何方式更改x</p><p> Elements can be selected by specifying  TRUE if the element should be returned, and  FALSE otherwise:</p><p> 如果要返回元素，则可以通过指定true来选择元素，否则为false：</p><p> x &lt;- c(10, 20, 30, 40)x[c(TRUE, FALSE, FALSE, FALSE)]x[c(TRUE, TRUE, FALSE, TRUE)]x[c(FALSE, TRUE)] # c(FALSE, TRUE) recycled - returns every second element# one interesting examplex[x &gt; 20] # 1) x &gt; 20 compares each element of x with 20 (20 is recycled) # 2) x &gt; 20 creates indexing vector of TURE/FALSE values for each element in x # 3) the obtained vector is then used for subsetting x # 4) as a result only x elements that are greater than 20 are returned</p><p> x＆lt; c（10,20,30,40）x [c（true，false，false，false）] x [c（true，true，false，true）] x [c（false，true）]＃ c（false，true）回收 - 返回每个第二个元素＃一个有趣的explatex [x＆gt; 20]＃1）x＆gt; 20将X的每个元素与20（20是再循环）＃2）进行比较。 20为X＃3中的每个元素创建所获得的矢量的索引矢量的索引矢量，然后将所获得的向量用于子集x＃4），结果仅返回大于20的x元素</p><p>  x &lt;- c(a=10, b=20, c=30, d=40)x[&#34;a&#34;]x[c(&#34;a&#34;, &#34;b&#34;)]x[c(&#34;e&#34;)] # NA - element with unknown valuex[-c(&#34;a&#34;)] # error - this syntax cannot be used for dropping elements# when names are not unique - first matching element is returnedx &lt;- c(a=10, b=20, b=30, d=40)x[&#34;b&#34;] # 20</p><p>  x＆lt;  -  c（a = 10，b = 20，c = 30，d = 40）x [＆＃34; a＆＃34;] x [c（＆＃34; a＆＃34;＆＃34; B＆＃34;）] x [c（＆＃34; e＆＃34;）]＃na  - 具有未知valuex [-c（＆＃34; a＆＃34;）]＃错误 - 此语法不能用于丢弃元素＃当名称不是唯一 - 第一匹配元素是返回x＆lt;  -  c（a = 10，b = 20，b = 30，d = 40）x [＆＃34; b＆＃34;]＃20</p><p>       x &lt;- c(10, 20, 30, 40)x[4] &lt;- c(51)x[c(1,3)] &lt;- c(12, 32)x[0] &lt;- 0 # doesn&#39;t do anythingx[5] &lt;- 50 # appends &#34;z&#34; to the 5th position of the vectorx[10] &lt;- 100 # appends &#34;z&#34; to the 10th position, adds NA to 6th:9th</p><p>       X＆lt;  -  C（10,20,30,40）X [4]×[4]＆lt;  -  C（51）X [C（1,3）]＆lt; -c（12,32）x [0]＆lt;  - 0＃DON＆＃39; t做任何物品x [5]＆lt;  -  50＃附录＆＃34; z＆＃34;到VectorXX [10]的第五位置＆lt;  -  100＃附录＆＃34; z＆＃34;到第10个位置，增加了第6次：9</p><p>  x &lt;- c(10, 20, 30, 40)x[-c(1,2,3)] &lt;- 41x[-1] &lt;- c(22,32,43)x[-5] &lt;- 100 # will replace every element</p><p>  X＆lt;  -  C（10,20,30,40）X [-C（1,2,3）]＆lt;  -  41×[-1]＆lt;  -  c（22,32,43）x [-5] ＆lt;  -  100＃将替换每个元素</p><p>  x &lt;- c(10, 20, 30, 40)x[c(TRUE, FALSE, TRUE, FALSE)] &lt;- c(11,31)x[c(TRUE, TRUE, TRUE, FALSE)] &lt;- c(11,31) # c(11, 31) will be recycledx[c(FALSE, TRUE)] &lt;- c(22,42) # c(FALSE TRUE) will be recycledx[x &lt; 10] &lt;- NA</p><p>  x＆lt; c（10,20,30,40）x [c（true，false，true，false）]＆lt;  -  c（11,31）x [c（true，true，true，false）]＆lt ;  -  C（11,31）＃C（11,31）将被RECYCLEDX [C（FALSE，TRUE）]＆lt; -c（22,42）#c（false true）将被回收x[x＆lt; 10]＆lt;  -  na </p><p>  x &lt;- c(a=10, b=20, c=30, d=40)x[&#34;b&#34;] &lt;- 21x[c(&#34;a&#34;,&#34;d&#34;)] &lt;- c(11,41)x[&#34;z&#34;] &lt;- 2 # will append a new element named &#34;z&#34;# when names are not unique - first matching element is replacedx &lt;- c(a=10, b=20, b=30, d=40)x[&#34;b&#34;] &lt;- 21 # replaces b=20 element</p><p>X＆lt;  -  C（a = 10，b = 20，c = 30，d = 40）x [＆＃34; b＆＃34;]＆lt;  -  21x [c（＆＃34; a＆＃34;，＆ ＃34; d＆＃34;）]＆lt;  -  c（11,41）x [＆＃34; z＆＃34;]＆lt;  -  2＃将附加一个名为＆＃34; z＆＃34;＃何时的新元素名称不是唯一的 - 第一匹配元素是替换x＆lt; c（a = 10，b = 20，b = 30，d = 40）x [＆＃34; b＆＃34;]＆lt;  -  21＃替换b = 20个元素</p><p>  x &lt;- c(10, 20, 30, 40)x &lt;- 0 # replaces x with 0x[] &lt;- 0 # replaces all elements of x with 0</p><p>  x＆lt; c（10,20,30,40）x＆lt;  -  0＃用0x []＆lt;  -  0＃用0替换x的所有元素</p><p>  x &lt;- c(1, 2, 3, 4) # x is doublex[4] &lt;- &#34;e&#34; # x is now character</p><p>  x＆lt; c（1,2,3,4）＃x是双x [4]＆lt;  - ＆＃34; e＆＃34; ＃x现在是个性</p><p>  In a vector all elements have the same type.List can store multiple elements of different types.</p><p>  在向量中，所有元素都具有相同类型.List可以存储不同类型的多个元素。</p><p>   l &lt;- list(c(&#34;a&#34;,&#34;b&#34;), c(TRUE, FALSE), 1:100)length(l) # length is the nuber of elements in a list: 3</p><p>   l＆lt;列表（C（＆＃34; a＆＃34;＆＃34; b＆＃34; b＆＃34;），c（true，false），1：100）长度（l）＃长度是元素的赘述列表：3</p><p>  list(list(1, 3+0i), list(&#34;a&#34;))list(list(1, 3+0i), &#34;a&#34;) # one list can have both lists and simple vectorslist(list(1, list(&#34;a&#34;))) # lists can be nested more than 2 levels deeplist(a=TRUE, b=1:100) # list elements can have names</p><p>  列表（列表（1,3 + 0i），列表（＆＃34; a＆＃34;）列表（列表（1,3 + 0i），＆＃34; a＆＃34;）＃一个列表可以有两个列表和简单的Vectorslist（列表（1，列表（＆＃34; a＆＃34;）））＃列表可以嵌套两个以上的deeplist（a = true，b = 1：100）＃列表元素可以有名称</p><p>     Special double bracket  [[ operator is used for extracting elements from a list.But it only allows indexing by positive numbers and names:</p><p>     特殊双括号[[操作员用于从列表中提取元素。但它只允许索引正数和名称： </p><p> l &lt;- list(a=TRUE, b=c(&#34;a&#34;,&#34;b&#34;), c=1:100)l[[1]] # first element of a listl[[c(1,2)]] # error - cannot return two objects, without a list to hold theml[[-c(1,2)]] # error - negative indices cannot be used for list elementsl[[c(TRUE,FALSE,TRUE)]] # error - logical indices cannot be usedl[[c(&#34;a&#34;)]]l[[c(&#34;a&#34;,&#34;b&#34;)]]</p><p>l＆lt;列表（a = true，b = c（＆＃34; a＆＃34;和＃34; b＆＃34;），c = 1：100）l [[1] ##的第一元素listl [[c（1,2）]]＃错误 - 无法返回两个对象，而无需列表以保存hemll [[ -  c（1,2）]]＃错误 - 负指数不能用于列表元素[[c （true，false，true）]]＃错误 - 逻辑索引不能使用[[c（＆＃34; a＆＃34;）] l [[c（＆＃34; a＆＃34;＆＃34; B＆＃34;）]]</p><p>  l &lt;- list(list(TRUE), list(list(1, 2:3)))l[[1]] # selects first element - a listl[[1]][[1]] # selects second element from the first element (list)l[[2]][[1]][[1]] # deeper nested selection (hard to describe, sorry!)l[[2]][[1]][[2]][2] # select an element of a deeply nested vector</p><p>  l＆lt;列表（列表（true），列表（列表（1,2：3））l [[1]]＃选择一个元素 -  listl [[1]] [[1]＃选择第二个元素从第一个元素（列表）l [[2]] [[1]] [[1]]＃深度嵌套选择（难以描述，抱歉！）l [[2]] [[1] [2] ] [2]＃选择深度嵌套矢量的元素</p><p>  l &lt;- list(a=TRUE, b=c(&#34;a&#34;,&#34;b&#34;), c=1:100)l[[1]] &lt;- FALSE # replace the first list element with FALSEl[1] &lt;- list(FALSE) # same as abovel[1] &lt;- FALSE # also same as abovel[[1]] &lt;- list(FALSE) # ! replaces first element with a listl[2] &lt;- NULL # removes the second element from the list</p><p>  l＆lt;列表（a = true，b = c（＆＃34; a＆＃34;，＆＃34; b＆＃34;），c = 1：100）l [[1]]＆lt;  -  false＃将第一个列表元素替换为falsel [1]＆lt;列表（false）＃与abovel [1]＆lt; shall＃也与abovel相同[[1]]＆lt; list（false）＃！用listl [2]替换第一个元素＆lt;  -  null＃从列表中删除第二个元素</p><p>  l &lt;- list(list(TRUE), list(list(1, 2:3)))l[[1]][[1]] &lt;- FALSEl[[2]][[1]][[1]] &lt;- 0l[[2]][[1]][[2]][1] &lt;- -1 # replace element of a deeply nested vectorl[[2]][[2]] &lt;- list() # replace a whole nested list</p><p>  l＆lt; list（列表（true），列表（列表（1,2：3））l [[1]] [[1]]＆lt;  -  falsel [[2]] [[1]] [[1]] [[ 1]]＆lt; [2]] [[1]] [[2]] [[2]] [[2]] [[2]] [[2]] [[2]] [[2]] [[2]] [[2]] [[2]]＆lt; -  list（）＃替换整个嵌套列表</p><p> Selecting a single element from a list by name is a frequent procedure, therefore it has a shortcut operator:</p><p> 按名称从列表中选择单个元素是频繁的过程，因此它有一个快捷操作员：</p><p> l &lt;- list(a=TRUE, b=c(&#34;a&#34;,&#34;b&#34;), c=list(c1=1, c2=2))l$a # same as l[[&#34;a&#34;]]l$c # same as l[[&#34;c&#34;]]l$c$c1 # same as l[[&#34;c&#34;]][[&#34;c1&#34;]]</p><p> l＆lt; list（a = true，b = c（＆＃34; a＆＃34;和＃34; b＆＃34;），c = list（c1 = 1，c2 = 2））l $ a＃与l [[＆＃34; a＆＃34;]] l $ c＃与l [＆＃34; c＆＃34;]] l $ c $ c1＃与l [[＆＃34; c＆ ＃34;]] [[＆＃34; c1＆＃34;]]]</p><p>  l &lt;- list(a=TRUE, b=c(&#34;a&#34;,&#34;b&#34;), c=list(c1=1, c2=2))l$a &lt;- FALSE # replace element &#34;a&#34;l$c$c1 &lt;- 0 # replace &#34;c1&#34; element of the list &#34;c&#34;l$c &lt;- NA # replace whole &#34;c&#34; list with an object NA</p><p>  l＆lt;列表（a = true，b = c（＆＃34; a＆＃34;＆＃34; b＆＃34;），c = list（c1 = 1，c2 = 2））l $ a＆lt ;  -  false＃替换元素＆＃34; a＆＃34; l $ c $ c $ c1＆lt;  -  0＃替换＆＃34; c1＆＃34;列表＆＃34; c＆＃34; l $ c＆lt;  -  na＃替换整个＆＃34; c＆＃34;列表与对象na </p><p>  Matrices are vectors with an additional atribute of dimension.Below are multiple equivalent ways of creating matrices:</p><p>矩阵是具有额外的尺寸的载体.Below是创建矩阵的多等同方式：</p><p>    Since matrices are constructed from vectors - any vector type, including a list, can be turned into a matrix:</p><p>    由于矩阵由vector构造 - 可以将包括列表的任何向量类型，可以变成矩阵：</p><p> matrix(c(TRUE, FALSE, TRUE, FALSE), nrow=2, ncol=2)matrix(1:4, nrow=2, ncol=2)matrix(c(&#34;a&#34;,&#34;b&#34;,&#34;c&#34;,&#34;d&#34;), nrow=2, ncol=2)matrix(list(TRUE, 2, &#34;a&#34;, 3+0i), nrow=2, ncol=2)</p><p> 矩阵（c（true，false，true，false），nrow = 2，ncol = 2）矩阵（1：4，nrow = 2，ncol = 2）矩阵（c（＆＃34; a＆＃34;，＆＃ 34; B＆＃34;，＆＃34; C＆＃34;，＆＃34; d＆＃34;），nrow = 2，ncol = 2）矩阵（列表（true，2，＆＃34; a＆＃34; ，3 + 0i），nrow = 2，ncol = 2）</p><p>   Under the hood The matrix is a vector, “folded” into a matrix form by first filling up the first column, then the second column, and so on:</p><p>   在引擎盖下，矩阵是一个向量，通过首先填充第一列，然后第二列，等等，将“折叠”成矩阵形式：</p><p> x &lt;- 1:20matrix(x, ncol=4)# [,1] [,2] [,3] [,4]# [1,] 1 6 11 16# [2,] 2 7 12 17# [3,] 3 8 13 18# [4,] 4 9 14 19# [5,] 5 10 15 20</p><p> x＆lt; 1：20matrix（x，ncol = 4）＃[，1] [，2] [，3] [，4]＃[1，] 1 6 11 16＃[2，] 2 7 12 17＃ [3，] 3 8 13 13 18＃[4，] 4 9 14 19＃[5，] 5 10 15 20</p><p> And all operators that work on vectors treat matrices as a vectors.Here is what happens when a vector is added to a matrix:</p><p> 所有运营商都在向量上处理矩阵作为向量。在向矩阵添加到矩阵时会发生什么：</p><p> X &lt;- matrix(1:8, nrow=4)v &lt;- 1:2X + v # 1) X is flattened out to a vector form 1 2 3 4 5 6 7 8 # 2) v is recycled to match length of X 1 2 1 2 1 2 1 2 # 3) element-wise addition takes place 2 4 4 6 6 8 9 10 # 4) X is re-folded into a matrix again, column by column: # [,1] [,2] # [1,] 2 6 # [2,] 4 8 # [3,] 4 8 # [4,] 6 10</p><p> x＆lt;  - 矩阵（1：8，nrow = 4）v＆lt;  -  1：2x + v＃1）x被夷为载载体1 2 3 4 5 6 7 8＃2）V被再循环以匹配X 1 2 11 2 1 2 1 2 1 2 1 2 1 2＃3）元素的加法24 4 4 6 6 8 9 10＃4）x再次被重新折叠成矩阵，按列列：＃[，1] [，2]＃[1，] 2 6＃[2，] 4 8＃[3，] 4 8＃[4，] 6 10 </p><p>  X &lt;- matrix(1:20, nrow=4)Y &lt;- matrix(runif(20), nrow=4)X + 1 # add an element to each number of a matrixX &gt; 2 # compare each element of a matrix with a numberX / Y # divide elements of one matrix from anotherX &lt; Y # compare two matrices element-wiseX - rowMeans(X) # subtract the mean of each row of a matrix</p><p>x＆lt;  - 矩阵（1:20，nrow = 4）y y＆lt;矩阵（runif（20），nrow = 4）x + 1＃为每个数量的matrixx＆gt添加元素; 2＃将矩阵的每个元素与来自另一个矩阵的NumberX / Y＃划分元素。 Y＃比较两个矩阵元素-Wisex  -  Rowmeans（x）＃减去每行矩阵的平均值</p><p>  X &lt;- matrix(1:20, ncol=4)length(X) # 20sum(X) # sum of all elementssqrt(X) # square root of each element within the matrix</p><p>  x＆lt;  - 矩阵（1:20，ncol = 4）长度（x）＃20sum（x）#muthineSQrt（x）＃的所有元素的＃Square Root</p><p>  X &lt;- matrix(rnorm(20), ncol=4)Y &lt;- matrix(rnorm(20), nrow=4)t(X) # transpose of a matrixdiag(X) # obtain matrix diagonalX %*% Y # matrix multiplicationX %x% Y # kronecker product of two matrices</p><p>  x＆lt;矩阵（rnorm（20），ncol = 4）y y＆lt;矩阵（rnorm（20），nrow = 4）t（x）＃ratixdiag（x）＃的rative矩阵对角线x％*％y ＃矩阵乘法x％x％y＃kronecker乘以两个矩阵</p><p> Elements within a matrix can be subsetted and replaced as if they were in a vector:</p><p> 矩阵内的元素可以分发并替换为它们在向量中：</p><p>     X &lt;- matrix(1:20, ncol=4)X[1:2,] # first two rowsX[,3:4] # 3rd and 4th columnX[1:2, 3:4] # combination of the aboveX[1,] # selecting a single row returns a simple vector (not a matrix)X[,2] # same with columns</p><p>     x＆lt;  - 矩阵（1:20，ncol = 4）x [1：2，]＃前两个Rowsx [，3：4]＃3和第4列[1：2，3：4]＃的上索组合[1，]＃选择单行返回一个简单的向量（不是矩阵）x [，2]＃与列相同</p><p>  X &lt;- matrix(1:20, ncol=4)X[-1,] # drop first rowX[,-c(2,3)] # drop second columnX[-1, -c(2,3)] # combination of the aboveX[-1, c(2,3)] # removal of rows combined with selection of columnsX[,-c(1:3)] # when single row/column is left - a vector is returned</p><p>  x＆lt;  - 矩阵（1:20，ncol = 4）x [-1，]＃drop first rowx [， -  c（2,3）]＃drop第二columnx [-1，-c（2,3）] ＃上一个[-1，c（2,3）]＃删除行与ColumnSX [， -  C（1：3）]＃剩余的选择 - 返回载体时</p><p>  X &lt;- matrix(1:20, ncol=4)X[c(TRUE,FALSE,TRUE,FALSE,FALSE),] # select 1st and 3rd rowsX[,c(TRUE,FALSE,TRUE,FALSE)] # select 1st and 3nd columnsX[c(TRUE,FALSE,TRUE,FALSE,FALSE), c(TRUE,FALSE)] # combination (with recycling)X[,c(TRUE,FALSE,FALSE,FALSE)] # returns a vector# a more practical exampleX[rowMeans(X) &gt; 10,] # all rows with mean above 10</p><p>  x＆lt;矩阵（1:20，ncol = 4）x [c（true，false，true，false，false），]＃选择1st和3rd Rowsx [，c（true，false，true，false）]＃选择1st和3nd columnsx [c（true，false，true，false，false），c（true，false）]＃组合（带回收）x [，c（true，false，false，false）]＃返回向量＃更实用的explatex [reonmeans（x）＆gt; 10，]＃所有行为均高于10 </p><p> Rows and columns of a matrix can also have their own names that can be used for selection:</p><p>矩阵的行和列也可以具有可用于选择的自己的名称：</p><p> X &lt;- matrix(1:20, ncol=4)rownames(X) &lt;- paste0(&#34;r&#34;, 1:5)colnames(X) &lt;- paste0(&#34;c&#34;, 1:4)X[c(&#34;r1&#34;,&#34;r2),] # rows named &#34;r1&#34; and &#34;r2&#34;X[,c(&#34;c1&#34;,&#34;c3)] # columns names &#34;c1&#34; and &#34;c3&#34;X[c(&#34;r1&#34;,&#34;r2&#34;), c(&#34;c1&#34;,&#34;c3)] # combination of the aboveX[,&#34;c4&#34;] # returns a vector</p><p> X＆lt;  - 矩阵（1:20，ncol = 4）rownames（x）＆lt;  -  paste0（＆＃34; r＆＃34; 1：5）colnames（x）＆lt;  -  paste0（＆＃34; c＆ ＃34;，1：4）x [c（＆＃34; r1＆＃34;＆＃34; r2），]＃行命名为＆＃34; r1＆＃34;和＃34; r2＆＃34; x [，c（＆＃34; c1＆＃34;＆＃34; c3）]＃列名称＆＃34; c1＆＃34;和＆＃34; c3＆＃34; x [c（＆＃34; r1＆＃34;＆＃34; r2＆＃34;），c（＆＃34; c1＆＃34;，＆＃34; c3）] ＃上面的组合[，＆＃34; c4＆＃34;]＃返回矢量</p><p>  X &lt;- matrix(1:20, ncol=4)i &lt;- rbind(c(1,2), # element in row 1 column 2 c(2,2), # element in row 2 column 2 c(4,1) # element in row 4 column 1 )X[i] # selects the elements in all the specified positions</p><p>  x＆lt;  - 矩阵（1:20，ncol = 4）i＆lt;  -  rbind（c（1,2），行1列2 c（2,2）中的＃元素，行2列中的＃元素2 c（ 4,1）第4列中的＃元素1）x [i]＃在所有指定位置中选择元素</p><p>  X &lt;- matrix(1:20, ncol=4)rownames(X) &lt;- paste0(&#34;r&#34;, 1:5)colnames(X) &lt;- paste0(&#34;c&#34;, 1:4)i &lt;- rbind(c(&#34;r1&#34;,&#34;c2&#34;), c(&#34;r2&#34;,&#34;c2&#34;), c(&#34;r4&#34;,&#34;c1&#34;) )X[i] # same as before</p><p>  X＆lt;  - 矩阵（1:20，ncol = 4）rownames（x）＆lt;  -  paste0（＆＃34; r＆＃34; 1：5）colnames（x）＆lt;  -  paste0（＆＃34; c＆ ＃34;，1：4）I＆lt;  -  rbind（c（＆＃34; r1＆＃34;，＆＃34; c2＆＃34;），c（＆＃34; r2＆＃34;和＃34; C2＆＃34;），C（＆＃34; r4＆＃34;，＆＃34; c1＆＃34;））x [i]＃与之前相同</p><p> Elements within the matrix can be replaced using all the subsetting examples outline above.But to save time and space these will not be demonstrated further.</p><p> 矩阵内的元素可以使用上面的所有子集示例轮廓替换。但是要节省时间和空间，因此不会进一步说明这些。</p><p>  Dataframes in R are implemented as a class on top of lists, with the restriction of each element within a list having the same length.Such implementation allows to construct tables, where each list element is interpreted as a separate column.As a result, unlike a matrix,  data.frame class can contain columns of different types.</p><p>  R中的Dataframe在列表中实现为类，其中包含相同长度的列表中的每个元素的限制.such实现允许构造表，其中每个列表元素被解释为单独的列。结果矩阵，data.frame类可以包含不同类型的列。</p><p> l &lt;- list(id=1:5, name=c(&#34;a&#34;,&#34;b&#34;,&#34;c&#34;,&#34;d&#34;,&#34;e&#34;), state=c(TRUE,TRUE,FALSE,TRUE,TRUE))as.data.frame(l)# id name state# 1 1 a TRUE# 2 2 b TRUE# 3 3 c FALSE# 4 4 d TRUE# 5 5 e TRUE# same as above:df &lt;- data.frame(id=1:5, name=c(&#34;a&#34;,&#34;b&#34;,&#34;c&#34;,&#34;d&#34;,&#34;e&#34;), state=c(TRUE,TRUE,FALSE,TRUE,TRUE))</p><p> l＆lt; list（id = 1：5，name = c（＆＃34; a＆＃34;和＃34; b＆＃34;，＆＃34; c＆＃34;，＆＃34; d＆＃34 ;，＆＃34; e＆＃34;），state = c（true，true，false，true，true）as.data.frame（l）#id name状态＃1 1 a true＃2 2 b true＃ 3 3 C FALSE＃4 4 D TURE＃5 5 E TRUE＃与上面相同：DF＆lt;  -  data.frame（ID = 1：5，name = c（＆＃34; a＆＃34;和＃34; B＆＃34;，＆＃34; C＆＃34;，＆＃34; D＆＃34;，＆＃34; e＆＃34;），state = c（true，true，false，true，true）） </p><p>  df &lt;- data.frame(id=1:2, name=c(&#34;Albert&#34;,&#34;Bob&#34;))df$objects &lt;- list(c(&#34;key&#34;,&#34;pin&#34;), c(&#34;ball&#34;))# id name objects# 1 1 Albert key, pin# 2 2 Bob ball</p><p>df＆lt;  -  data.frame（id = 1：2，name = c（＆＃34; albert＆＃34;，＆＃34; bob＆＃34;））df $对象＆lt;  -  list（c（＆＃34 ; key＆＃34;，＆＃34; pin＆＃34;），c（＆＃34;球＆＃34;））#id name对象＃1 1 albert key，pin＃2 2 2 bob ball</p><p>  df &lt;- data.frame(id = 1:3, name = c(&#34;Albert&#34;,&#34;Bob&#34;,&#34;Cindy&#34;))df[1] # first list element (first column)df[1:2] # first two list elements (first and second columns)df[-1] # removes first list element (first column)df[[2]][2:3] # second and third vector elements from the second columndf$id # list element (column) by namedf$name[1:2] # first two vector elements of &#34;name&#34; column</p><p>  df＆lt;  -  data.frame（id = 1：3，name = c（＆＃34; albert＆＃34;＆＃34; bob＆＃34;，＆＃34; cindy＆＃34;））df [1] ＃first list元素（第一列）df [1：2]＃前两个列表元素（第一和第二列）df [-1]＃删除第一个列表元素（第一列）df [[2]] [2：3] ＃第二和第三矢量元素来自第二个Columndf $ ID＃列表元素（列）由NamedF $名称[1：2]＃前两个矢量元素＆＃34;姓名＆＃34;柱子</p><p> Equivalent operators can be used for replacement.Here only a few more practical examples are provided:</p><p> 等效运算符可用于替换。提供了一些更实际的例子：</p><p> df &lt;- data.frame(id = 1:3, name = c(&#34;Albert&#34;,&#34;Bob&#34;,&#34;Cindy&#34;))df$name[df$id==&#34;2&#34;] &lt;- &#34;Bobby&#34;df$surname &lt;- c(&#34;Thompson&#34;, NA, &#34;Friedman&#34;)df$surname[df$name==&#34;Bobby&#34;] &lt;- &#34;Smith&#34;</p><p> df＆lt;  -  data.frame（id = 1：3，name = c（＆＃34; albert＆＃34;＆＃34; bob＆＃34;，＆＃34; cindy＆＃34;））df $ name [ DF $ ID ==＆＃34; 2＆＃34;]＆lt;  - ＆＃34; bobby＆＃34; df $姓氏＆lt;  -  c（＆＃34; thompson＆＃34; na，＆＃34;弗里德曼＆＃ 34;）df $姓氏[df $ name ==＆＃34; bobby＆＃34;]＆lt;  - ＆＃34;史密斯＆＃34;</p><p> Since data frame is arranged as a matrix it also allows matrix subset operations, with equivalent forms used for replacement:</p><p> 由于数据帧被排列为矩阵，因此它还允许矩阵子集操作，其具有用于替换的等效表单：</p><p> df &lt;- data.frame(id = 1:3, name = c(&#34;Albert&#34;,&#34;Bob&#34;,&#34;Cindy&#34;))df[,1] # first column (like with a matrix, returns a simple vector)df[1,] # first row of a data frame (returns a data frame)df[df$id==2, ] # all entries for id = 2df[df$id %in% 2:3, ] # all entries for ids 2 and 3</p><p> df＆lt;  -  data.frame（id = 1：3，名称= c（＆＃34; albert＆＃34;＆＃34; bob＆＃34;，＆＃34; cindy＆＃34;））df [，1 ]＃First列（如矩阵，返回一个简单的向量）DF [1，]＃数据帧的第一行（返回数据帧）df [df $ id == 2，]＃id = 2df的所有条目[DF $ ID％IN％2：3，]＃IDS 2和3的所有条目</p><p> Just like a matrix the data frame can have row names, with column names often provided by default.And those names can be used to subset rows and columns in a matrix style:</p><p> 就像矩阵一样，数据帧可以具有行名称，默认情况下通常提供列名称。这些名称可用于在矩阵样式中将行和列子集中为： </p><p> df &lt;- data.frame(id = 1:3, name = c(&#34;Albert&#34;,&#34;Bob&#34;,&#34;Cindy&#34;))rownames(df) &lt;- c(&#34;a&#34;, &#34;b&#34;,&#34;c&#34;)# id name# a 1 Albert# b 2 Bob# c 3 Cindydf[c(&#34;a&#34;,&#34;b&#34;),] # rows named &#34;a&#34; and &#34;b&#34;df[,&#34;name&#34;] # column named &#34;name&#34;df[c(&#34;a&#34;,&#34;b&#34;), &#34;name&#34;] # combination of the two</p><p>df＆lt;  -  data.frame（id = 1：3，name = c（＆＃34; albert＆＃34;＆＃34; bob＆＃34;，＆＃34; cindy＆＃34;））rownames（df） ＆lt; c（＆＃34; a＆＃34; b＆＃34; b＆＃34;，＆＃34; c＆＃34;）#id name＃a 1 albert＃b 2 bob＃c 3 cindydf [c（ ＆＃34; a＆＃34;，＆＃34; b＆＃34;），]＃行命名为＆＃34; a＆＃34;和＃34; B＆＃34; DF [，＆＃34;名称＆＃34;]＃列名为＆＃34;姓名＆＃34; df [c（＆＃34; a＆＃34;＆＃34; b＆ ＃34;），＆＃34;姓名＆＃34;]＃两者的组合</p><p>  df &lt;- data.frame(id = 1:3, name = c(&#34;Albert&#34;,&#34;Bob&#34;,&#34;Cindy&#34;))i &lt;- rbind(c(1,2), # 1st row, 2nd column c(3,1) # 3rd row, 1st column )df[i]</p><p>  df＆lt;  -  data.frame（id = 1：3，名称= c（＆＃34; albert＆＃34;＆＃34; bob＆＃34;，＆＃34; cindy＆＃34;））I＆lt;  - rbind（c（1,2），＃第1行，第2列C（3,1）＃3rd行，第1列）df [i]</p><p> Replacing the whole entry (one row) is an often needed procedure.Since such entries are subsets of the data frame they are data frames themselves and need to be replaced with an equivalent data frame (or a list).Hence the replacement has to use equal element names:</p><p> 替换整个条目（一行）是一个经常需要的过程。这些条目是数据帧的子集，它们是数据帧本身，需要用等效数据帧（或列表）替换。替换必须使用等元素名称：</p><p> df &lt;- data.frame(id = 1:3, name = c(&#34;Albert&#34;,&#34;Bob&#34;,&#34;Cindy&#34;))df[df$id==2, ] &lt;- list(id=2, name=&#34;Bruce&#34;) # new entry for id = 2df[df$id==2, ] &lt;- data.frame(id=2, name=&#34;Bruce&#34;) # same# id name# 1 1 Albert# 2 2 Bruce# 3 3 Cindy</p><p> df＆lt;  -  data.frame（ID = 1：3，名称= C（＆＃34; albert＆＃34;＆＃34;鲍勃＆＃34;，＆＃34; cindy＆＃34;））df [df $ ID == 2，]＆lt;列表（ID = 2，名称=＆＃34; Bruce＆＃34;）#deD = 2df [df $ id == 2，]＆lt;  -  data.frame（ID = 2，名称=＆＃34;布鲁斯＆＃34;）#######Albert＃2 2 Bruce＃3 3 3 Cindy </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://karolis.koncevicius.lt/posts/a_half_hour_to_learn_r/">http://karolis.koncevicius.lt/posts/a_half_hour_to_learn_r/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/学习/">#学习</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hour/">#hour</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/元素/">#元素</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>