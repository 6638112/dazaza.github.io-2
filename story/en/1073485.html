<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>C++模板：如何迭代STD:tuple：STD:应用和更多C++ Templates: How to Iterate through std:tuple: std:apply and More</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">C++ Templates: How to Iterate through std:tuple: std:apply and More<br/>C++模板：如何迭代STD:tuple：STD:应用和更多</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 17:28:27</div><div class="page_narrow text-break page_content"><p>In the previous article on the tuple iteration, we covered the basics. As a result, we implemented a function template that took a tuple and could nicely print it to the output. There was also a version with  operator &lt;&lt;.</p><p>在上一篇关于元组迭代的文章中，我们介绍了基本知识。因此，我们实现了一个函数模板，它接受一个元组，并可以很好地将其打印到输出中。还有一个版本带有operator&lt&书信电报；。</p><p> Today we can go further and see some other techniques. The first one is with  std::apply from C++17, a helper function for tuples. Today’s article will also cover some strategies to make the iteration more generic and handle custom callable objects, not just printing.</p><p>今天我们可以进一步了解其他一些技术。第一个是来自C++17的std:：apply，它是元组的辅助函数。今天的文章还将介绍一些策略，使迭代更通用，并处理定制的可调用对象，而不仅仅是打印。</p><p> This is the second part of the small series. See the first article  here where we discuss the basics.</p><p>这是小系列的第二部分。请参阅本文的第一篇文章，其中我们讨论了基础知识。</p><p>  A handy helper for  std::tuple is the  std::apply function template that came in C++17. It takes a tuple and a callable object and then invokes this callable with parameters fetched from the tuple.</p><p>std:：tuple的一个方便助手是C++17中的std:：apply函数模板。它接受一个元组和一个可调用对象，然后使用从元组中获取的参数调用这个可调用对象。</p><p>  #include  &lt;iostream&gt;  #include  &lt;tuple&gt;    int  sum ( int  a ,  int  b ,  int  c )  {  return  a  +  b  +  c ;  } void  print ( std :: string_view  a ,  std :: string_view  b )  {  std :: cout  &lt;&lt;  &#34;(&#34;  &lt;&lt;  a  &lt;&lt;  &#34;, &#34;  &lt;&lt;  b  &lt;&lt;  &#34;) \n &#34; ; }  int  main ()  {  std :: tuple  numbers  { 1 ,  2 ,  3 };  std :: cout  &lt;&lt;  std :: apply ( sum ,  numbers )  &lt;&lt;  &#39;\n&#39; ;  std :: tuple  strs  { &#34;Hello&#34; ,  &#34;World&#34; };  std :: apply ( print ,  strs ); }</p><p>#包括&lt；iostream&gt#包括&lt；tuple&gt；int sum（int a，int b，int c）{返回a+b+c；}无效打印（std:：string_视图a、std:：string_视图b）{std:：cout&lt；&lt；&lt；&lt；&lt；&lt；a&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；b&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；）\n&#34；；}int main（）{std:：tuple number{1,2,3}；标准：cout&lt&书信电报；标准：：应用（总和、数字）&lt&lt&#39;\n&#39；std：：tuple strs{&#34；Hello&#34；，&#34；World&#34；}；std：：应用（打印，strs）；}</p><p>  As you can see,  std::apply takes  sum or  print functions and then “expands” tuples and calls those functions with appropriate arguments.</p><p>如您所见，std:：apply接受sum或print函数，然后“展开”元组，并使用适当的参数调用这些函数。</p><p>    The critical thing is that  std::apply hides all index generation and calls to  std::get&lt;&gt;. That’s why we can replace our printing function with  std::apply and then don’t use  index_sequence.</p><p>关键是std:：apply隐藏了所有索引生成和对std:：get&lt&gt；。这就是为什么我们可以用std:：apply替换打印函数，然后不使用index_序列。</p><p>  The first approach that came to my mind was the following - create a variadic function template that takes  Args... and pass it to  std::apply:</p><p>我想到的第一种方法是：创建一个变量函数模板，该模板采用Args。。。并将其传递给std:：apply:</p><p> template  &lt; typename ...  Args &gt; void  printImpl ( const  Args &amp; ...  tupleArgs )  {  size_t  index  =  0 ;  auto  printElem  =  [ &amp; index ]( const  auto &amp;  x )  {  if  ( index ++  &gt;  0 )  std :: cout  &lt;&lt;  &#34;, &#34; ;  std :: cout  &lt;&lt;  x ;  };  ( printElem ( tupleArgs ),  ...); } template  &lt; typename ...  Args &gt; void  printTupleApplyFn ( const  std :: tuple &lt; Args ... &gt;&amp;  tp )  {  std :: cout  &lt;&lt;  &#34;(&#34; ;  std :: apply ( printImpl ,  tp );  std :: cout  &lt;&lt;  &#34;)&#34; ; }</p><p>模板&lt；字体名。。。Args&gt；void printImpl（const Args&amp；tupleArgs）{size_t index=0；auto printElem=[&amp；index]（const auto&amp；x）{if（index++&gt；0）std:：cout&lt；&lt；&lt；&lt；&lt；34；&gt；std:：cout&lt；&lt；x；（普列特莱姆（图普里格斯），…）；]模板&lt；字体名。。。Args&gt；void printTupleApplyFn（const std：：tuple&lt；Args…&gt；&gt；&gt；{std：：cout&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&gt；&gt；&gt；&lt；&lt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；[34；]</p><p>      The problem lies in the fact that out  printImpl is a variadic function template, so the compiler has to instantiate it. The instantiation doesn’t happen when we call  std::apply, but inside  std::apply. The compiler doesn’t know how the callable object will be called when we call  std::apply, so it cannot perform the template deduction at this stage.</p><p>问题在于out printImpl是一个可变函数模板，因此编译器必须实例化它。当我们调用std:：apply时，实例化不会发生，而是在std:：apply内部发生。当我们调用std:：apply时，编译器不知道如何调用可调用对象，因此在这个阶段它无法执行模板推导。</p><p>  #include  &lt;iostream&gt;  #include  &lt;tuple&gt;   template  &lt; typename ...  Args &gt; void  printImpl ( const  Args &amp; ...  tupleArgs )  {  size_t  index  =  0 ;  auto  printElem  =  [ &amp; index ]( const  auto &amp;  x )  {  if  ( index ++  &gt;  0 )  std :: cout  &lt;&lt;  &#34;, &#34; ;  std :: cout  &lt;&lt;  x ;  };  ( printElem ( tupleArgs ),  ...); } template  &lt; typename ...  Args &gt; void  printTupleApplyFn ( const  std :: tuple &lt; Args ... &gt;&amp;  tp )  {  std :: cout  &lt;&lt;  &#34;(&#34; ;  std :: apply ( printImpl &lt; Args ... &gt; ,  tp );  // &lt;&lt;   std :: cout  &lt;&lt;  &#34;)&#34; ; } int  main ()  {  std :: tuple  tp  {  10 ,  20 ,  3.14 };  printTupleApplyFn ( tp ); }</p><p>#包括&lt；iostream&gt#包括&lt；tuple&gt；模板&lt；字体名。。。Args&gt；void printImpl（const Args&amp；tupleArgs）{size_t index=0；auto printElem=[&amp；index]（const auto&amp；x）{if（index++&gt；0）std:：cout&lt；&lt；&lt；&lt；&lt；34；&gt；std:：cout&lt；&lt；x；（普列特莱姆（图普里格斯），…）；]模板&lt；字体名。。。Args&gt；void printTupleApplyFn（const std:：tuple&lt；Args…&gt；&gt；tp）{std:：cout&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；34；（&gt；std:：apply（printImpl&lt；Args…&gt；，tp）；/&lt；std:：cout&lt；&lt；&lt；&lt；&lt；&gt；）和int main（）{std:：tuple tp{10,20,3.14}；printTupleApplyFn（tp）；}</p><p>  In the above example, we helped the compiler to create the requested instantiation, so it’s happy to pass it to  std::apply.</p><p>在上面的示例中，我们帮助编译器创建了请求的实例化，因此它很乐意将其传递给std:：apply。</p><p>  struct  HelperCallable  {  template  &lt; typename ...  Args &gt;  void  operator ()( const  Args &amp; ...  tupleArgs )  {  size_t  index  =  0 ;  auto  printElem  =  [ &amp; index ]( const  auto &amp;  x )  {  if  ( index ++  &gt;  0 )  std :: cout  &lt;&lt;  &#34;, &#34; ;  std :: cout  &lt;&lt;  x ;  };  ( printElem ( tupleArgs ),  ...);  } }; template  &lt; typename ...  Args &gt; void  printTupleApplyFn ( const  std :: tuple &lt; Args ... &gt;&amp;  tp )  {  std :: cout  &lt;&lt;  &#34;(&#34; ;  std :: apply ( HelperCallable (),  tp );  std :: cout  &lt;&lt;  &#34;)&#34; ; }</p><p>struct HelperCallable{template&lt；typename…Args&gt；void操作符（）（const Args&amp；tupleArgs）{size_t index=0；auto printElem=[&amp；index]（const auto&amp；x）{if（index++&gt；0）std:：cout&lt；&lt；&lt；&lt；34；&gt；std:：cout&lt；&lt；x；}；（普列特莱姆（图普里格斯），…）；}；模板&lt；字体名。。。Args&gt；void printTupleApplyFn（const std：：tuple&lt；Args…&gt；&gt；&gt；{std：：cout&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&lt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt；&gt</p><p>  Now, what we do, we only pass a  HelperCallable object; it’s a concrete type so that the compiler can pass it without any issues. No template parameter deduction happens. And then, at some point, the compiler will call  HelperCallable(args...), which invokes  operator() for that struct. And it’s now perfectly fine, and the compiler can deduce the types. In other words, we deferred the problem.</p><p>现在，我们所做的，只是传递一个可帮助调用的对象；它是一个具体的类型，因此编译器可以毫无问题地传递它。没有模板参数推导。然后，在某个时刻，编译器将调用HelperCallable（args…），调用该结构的运算符（）。现在一切都很好，编译器可以推断出类型。换句话说，我们推迟了问题的解决。</p><p> So we know that the code works fine with a helper callable type… so how about a lambda?</p><p>因此，我们知道代码可以与助手可调用类型配合使用……那么lambda呢？</p><p> #include  &lt;iostream&gt;  #include  &lt;tuple&gt;   template  &lt; typename  TupleT &gt; void  printTupleApply ( const  TupleT &amp;  tp )  {  std :: cout  &lt;&lt;  &#34;(&#34; ;  std :: apply ([]( const  auto &amp; ...  tupleArgs )  {  size_t  index  =  0 ;  auto  printElem  =  [ &amp; index ]( const  auto &amp;  x )  {  if  ( index ++  &gt;  0 )  std :: cout  &lt;&lt;  &#34;, &#34; ;  std :: cout  &lt;&lt;  x ;  };  ( printElem ( tupleArgs ),  ...);  },  tp  )  std :: cout  &lt;&lt;  &#34;)&#34; ; } int  main ()  {  std :: tuple  tp  {  10 ,  20 ,  3.14 ,  42 ,  &#34;hello&#34; };  printTupleApply ( tp ); }</p><p>#包括&lt；iostream&gt#包括&lt；tuple&gt；模板&lt；typename TupleT&gt；void printtupleappy（const-TupleT&amp；tp）{std：：cout&lt；&lt；&lt；&lt；34；（&#34；std：：apply（[]（const-auto&amp；…tupleArgs）{size_-t index=0；auto-printElem=[&amp；index]（const-auto&amp；x）{if（index++gt；0）std：：cout&lt；&lt；&lt；&lt；&lt；&lt；&gt；34；&gt；&gt；（普列特莱姆（图普里格斯），…）；}，tp）标准：：cout&lt&lt&#34;)&#34; ; } intmain（）{std:：tuple tp{10,20,3.14,42和#34；hello和#34；}；printTupleApply（tp）；}</p><p>   As you can see, we have a lambda inside a lambda. It’s similar to our custom type with  operator(). You can also have a look at the transformation through C++ Insights:  this link</p><p>正如你所看到的，我们在一个lambda中有一个lambda。它类似于我们使用运算符（）的自定义类型。您还可以通过C++透视图来了解转换：这个链接</p><p>  Since our callable object gets a variadic argument list, we can use this information and make the code simpler.</p><p>因为我们的可调用对象得到一个可变参数列表，所以我们可以使用这些信息，使代码更简单。</p><p>  The code inside the internal lambda uses  index to check if we need to print the separator or not - it checks if we print the first argument. We can do this at compile-time:</p><p>内部lambda中的代码使用索引检查是否需要打印分隔符——它检查是否打印第一个参数。我们可以在编译时执行此操作：</p><p> #include  &lt;iostream&gt;  #include  &lt;tuple&gt;   template  &lt; typename  TupleT &gt; void  printTupleApply ( const  TupleT &amp;  tp )  {  std :: apply  (  []( const  auto &amp;  first ,  const  auto &amp; ...  restArgs )  {  auto  printElem  =  []( const  auto &amp;  x )  {  std :: cout  &lt;&lt;  &#34;, &#34;  &lt;&lt;  x ;  };  std :: cout  &lt;&lt;  &#34;(&#34;  &lt;&lt;  first ;  ( printElem ( restArgs ),  ...);  },  tp  );  std :: cout  &lt;&lt;  &#34;)&#34; ; } int  main ()  {  std :: tuple  tp  {  10 ,  20 ,  3.14 ,  42 ,  &#34;hello&#34; };  printTupleApply ( tp ); }</p><p>#包括&lt；iostream&gt#包括&lt；tuple&gt；模板&lt；typename TupleT&gt；void printTupleApply（const-TupleT&amp；tp）{std:：apply（[]（const-auto&amp；first，const-auto&amp；restArgs）{auto-printElem=[]（const-auto&amp；x）{std:：cout&lt；&lt；&lt；&lt；&lt；&lt；&lt；x；}；标准：cout&lt&lt&#34;（&#34；&lt；&lt；第一；（printElem（restArgs），…）；），tp）；标准：cout&lt&lt&#34;)&#34; ; } intmain（）{std:：tuple tp{10,20,3.14,42和#34；hello和#34；}；printTupleApply（tp）；}</p><p>  This code breaks when tuple has no elements - we could fix this by checking its size in  if constexpr, but let’s skip it for now.</p><p>这段代码在元组没有元素时会中断——我们可以通过在if constexpr中检查它的大小来修复这一问题，但现在让我们跳过它。</p><p>  So far we focused on printing tuple elements. So we had a “fixed” function that was called for each argument. To go further with our ideas, let’s try to implement a function that takes a generic callable object. For example:</p><p>到目前为止，我们主要关注打印元组元素。所以我们有一个“固定”函数，每个参数都被调用。为了进一步阐述我们的想法，让我们尝试实现一个接受通用可调用对象的函数。例如：</p><p>   template  &lt; typename  TupleT ,  typename  Fn ,  std :: size_t ...  Is &gt; void  for_each_tuple_impl ( TupleT &amp;&amp;  tp ,  Fn &amp;&amp;  fn ,  std :: index_sequence &lt; Is ... &gt; )  {  ( fn ( std :: get &lt; Is &gt; ( std :: forward &lt; TupleT &gt; ( tp ))),  ...); } template  &lt; typename  TupleT ,  typename  Fn ,  std :: size_t  TupSize  =  std :: tuple_size_v &lt; std :: remove_cvref_t &lt; TupleT &gt;&gt;&gt; void  for_each_tuple ( TupleT &amp;&amp;  tp ,  Fn &amp;&amp;  fn )  {  for_each_tuple_impl ( std :: forward &lt; TupleT &gt; ( tp ),  std :: forward &lt; Fn &gt; ( fn ),  std :: make_index_sequence &lt; TupSize &gt; {}); }</p><p>模板&lt；typename TupleT，typename Fn，std:：size\u t。。。Is&gt；每个元组无效（元组&amp；tp，Fn&amp；Fn，标准：：索引序列&lt；Is…&gt；）{（fn（std：：get&lt；Is&gt；（std：：forward&lt；TupleT&gt；（tp）），…）；}模板&lt；typename TupleT，typename Fn，std:：size\u t TupSize=std:：tuple\u size\u v&lt；标准：：移除_cvref_t&lt；TupleT&gt&gt&gt；对于每个元组无效（TupleT&amp；tp，Fn&amp；Fn）{对于每个元组impl（std:：forward&lt；TupleT&gt；（tp），std:：forward&lt；Fn&gt；（Fn），std:：make_index_sequence&lt；TupSize&gt；{}</p><p>  First, the code uses universal references (forwarding references) to pass tuple objects. This is needed to support all kinds of use cases - especially if the caller wants to modify the values inside the tuple. That’s why we need to use  std::forward in all places.</p><p>首先，代码使用通用引用（转发引用）传递元组对象。这是支持各种用例所必需的，尤其是当调用方想要修改元组中的值时。这就是为什么我们需要在所有地方使用std:：forward。</p><p>     This is a new helper type from the C++20 trait that makes sure we get a “real” type from the type we get through universal reference.</p><p>这是C++20 trait中的一个新助手类型，它确保我们从通过通用引用获得的类型中获得“真实”类型。</p><p>  Here’s a good summary from a question about tuple iteration  link to Stackoverflow:</p><p>下面是一个关于元组迭代链接到Stackoverflow的问题的很好的总结：</p><p> As  T&amp;&amp; is a forwarding reference,  T will be  tuple&lt;...&gt;&amp; or  tuple&lt;...&gt; const&amp; when an lvalue is passed in; but  std::tuple_size is only specialized for  tuple&lt;...&gt;, so we must strip off the reference and possible const. Prior to C++20’s addition of  std::remove_cvref_t, using  decay_t was the easy (if overkill) solution.</p><p>作为T&amp&amp；是转发引用，T将是tuple&lt&gt&amp；或者tuple&lt&gt；康斯特；当左值传入时；但是std:：tuple_size只适用于tuple&lt&gt；，所以我们必须去掉引用和可能的常量。在C++20添加std:：remove_cvref_t之前，使用decation_t是一种简单（如果过度杀戮）的解决方案。</p><p>  We discussed an implementation with index sequence; we can also try the same with std::apply. Can it yield simpler code?</p><p>我们讨论了一个索引序列的实现；我们也可以在std：：apply中尝试同样的方法。它能产生更简单的代码吗？</p><p>  template  &lt; typename  TupleT ,  typename  Fn &gt; void  for_each_tuple2 ( TupleT &amp;&amp;  tp ,  Fn &amp;&amp;  fn )  {  std :: apply  (  [ &amp; fn ]( auto &amp;&amp;  ... args )  {  ( fn ( args ),  ...);  },  std :: forward &lt; TupleT &gt; ( tp )  ); }</p><p>模板&lt；typename TupleT，typename Fn&gt；每一个tuple2（TupleT&amp；amp；tp，Fn&amp；Fn）{std:：apply（[&amp；Fn]（auto&amp；…args）{（Fn（args），…）；}无效，标准：前进&lt；TupleT&gt；（tp）；}</p><p>   template  &lt; typename  TupleT ,  typename  Fn &gt; void  for_each_tuple2 ( TupleT &amp;&amp;  tp ,  Fn &amp;&amp;  fn )  {  std :: apply  (  [ &amp; fn ] &lt; typename  ... T &gt; ( T &amp;&amp;  ... args )  {  ( fn ( std :: forward &lt; T &gt; ( args )),  ...);  },  std :: forward &lt; TupleT &gt; ( tp )  ); }</p><p>模板&lt；typename TupleT，typename Fn&gt；对于每个tuple2（TupleT&amp；tp，Fn&amp；Fn）{std:：apply（[&amp；Fn]&lt；typename…T&gt；（T&amp；…args）{（Fn（std:：forward&lt；T&gt；（args）），…）}，无效，标准：前进&lt；TupleT&gt；（tp）；}</p><p>  Additionally, if you want to stick to C++17, you can apply  decltype on the arguments:</p><p>此外，如果要坚持使用C++17，可以对参数应用decltype：</p><p> template  &lt; typename  TupleT ,  typename  Fn &gt; void  for_each_tuple2 ( TupleT &amp;&amp;  tp ,  Fn &amp;&amp;  fn )  {  std :: apply  (  [ &amp; fn ]( auto &amp;&amp;  ... args )  {  ( fn ( std :: forward &lt; decltype ( args ) &gt; ( args )),  ...);  },  std :: forward &lt; TupleT &gt; ( tp )  ); }</p><p>模板&lt；typename TupleT，typename Fn&gt；每一个tuple2（TupleT&amp；tp，Fn&amp；Fn）{std:：apply（[&amp；Fn]（auto&amp；…args）{（Fn（std:：forward&lt；decltype（args）&gt；（args）），…）；}，标准：前进&lt；TupleT&gt；（tp）；}</p><p>    The background task was to print tuples elements and have a way to transform them. During the process, we went through variadic templates, index sequence, template argument deduction rules and tricks, std::apply, and removing references.</p><p>背景任务是打印元组元素，并找到转换它们的方法。在这个过程中，我们经历了变量模板、索引序列、模板参数推导规则和技巧、std:：apply和删除引用。</p><p> I’m happy to discuss changes and improvements. Let me know in the comments below the article about your ideas.</p><p>我很高兴讨论变化和改进。请在下面的评论中告诉我你的想法。</p><p>   C++ Templates: The Complete Guide (2nd Edition) by David Vandevoorde, Nicolai M. Josuttis, Douglas Gregor</p><p>C++模板：David Vandevoorde、Nicolai M. Josuttis、Douglas Gregor的完整指南（第二版）</p><p>  I&#39;ve prepared a valuable bonus if you&#39;re interested in Modern C++!  Learn all major features of recent C++ Standards! Check it out here:</p><p>我&#39；如果你&#39；对现代C++有兴趣！了解最近C++标准的所有主要特征！看看这里：</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/std/">#std</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>