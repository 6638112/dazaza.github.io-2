<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>响应图像 Responsive Images</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Responsive Images<br/>响应图像 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-12 14:35:53</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/841d8b661adc6250bad0ad5e006ee19c.png"><img src="http://img2.diglog.com/img/2021/6/841d8b661adc6250bad0ad5e006ee19c.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>You should already know the  basics of HTML and how to  add static images to a web page.</p><p>您应该已经知道HTML的基础知识以及如何将静态图像添加到网页。</p><p>  Learn how to use features like   srcset and the   &lt;picture&gt; element to implement responsive image solutions on websites.</p><p>  了解如何使用SRCSet和＆lt;图片＆gt等功能。在网站上实现响应图像解决方案的元素。</p><p>  Let&#39;s examine a typical scenario. A typical website may contain a header image and some content images below the header. The header image will likely span the whole of the width of the header, and the content image will fit somewhere inside the content column. Here&#39;s a simple example:</p><p>  让＆＃39;检查典型的情景。典型的网站可能包含标题下方的标题图像和一些内容图像。标题图像可能会跨越标题的整个宽度，并且内容图像将适合内容列内的某处。在这里＆＃39;＆一个简单的例子：</p><p>  This works well on a wide screen device, such as a laptop or desktop (you can  see the example live and find the  source code on Github.) We won&#39;t discuss the CSS much in this lesson, except to say that:</p><p>  这适用于宽屏设备，例如笔记本电脑或桌面（您可以看到示例Live并查找GitHub上的源代码。）我们赢得了＆＃39; T在本课程中讨论了CSS，除非如此：</p><p> The body content has been set to a maximum width of 1200 pixels — in viewports above that width, the body remains at 1200px and centers itself in the available space. In viewports below that width, the body will stay at 100% of the width of the viewport.</p><p> 身体内容已设置为1200像素的最大宽度 - 在高于该宽度的视口中，身体保持在1200px并在可用空间中居中。在低于该宽度的视口中，身体将保持在视口宽度的100％。</p><p>  The header image has been set so that its center always stays in the center of the header, no matter what width the heading is set at. If the site is being viewed on a narrower screen, the important detail in the center of the image (the people) can still be seen, and the excess is lost off either side. It is 200px high.</p><p>  已经设置了标题图像，使其中心始终保持在标题的中心，无论标题是否设置为何种宽度。如果在较窄的屏幕上被观看了网站，则仍然可以看到图像中心（人）中的重要细节，并且多余的丢失在任何一方。这是200px高。</p><p>  The content images have been set so that if the body element becomes smaller than the image, the images start to shrink so that they always stay inside the body, rather than overflowing it.</p><p>  已经设置了内容图像，使得如果主体元素变得小于图像，则图像开始缩小，使得它们总是留在身体内，而不是溢出它。 </p><p> However, issues arise when you start to view the site on a narrow screen device. The header below looks ok, but it&#39;s starting to take up a lot of the screen height for a mobile device. And at this size, it is difficult to see the people within the first content image.</p><p>但是，当您在狭窄的屏幕设备上查看网站时出现问题。下面的标题看起来正常，但它开始占据了移动设备的大量屏幕高度。并且在这种大小，很难看到第一个内容图像中的人。</p><p>  An improvement would be to display a cropped version of the image which displays the important details of the image when the site is viewed on a narrow screen. A second cropped image could be displayed for a medium width screen device, like a tablet. This is commonly known as the  art direction problem.</p><p>  改进是显示图像的图像的裁剪版本，该图像显示在狭窄屏幕上观看站点时显示图像的重要细节。可以为媒体宽度屏幕设备显示第二裁剪图像，如片剂。这通常被称为艺术方向问题。</p><p> In addition, there is no need to embed such large images on the page if it is being viewed on a mobile screen. And conversely, a small  raster image starts to look grainy when displayed larger than its original size (a raster image is a set number of pixels wide and a set number of pixels tall, as we saw when we looked at  vector graphics). This is called the  resolution switching problem.</p><p> 此外，如果在移动屏幕上查看，则无需在页面上嵌入如此大的图像。并相反，当显示大于其原始尺寸时，小型光栅图像开始看起来颗粒状（光栅图像是宽的一组像素，并且当我们看着矢量图形时，我们看到的一定数量的像素数。这被称为分辨率切换问题。</p><p> Conversely, it is unnecessary to display a large image on a screen significantly smaller than the size it was meant for. Doing so can waste bandwidth; in particular, mobile users don&#39;t want to waste bandwidth by downloading a large image intended for desktop, when a small image would do for their device. Ideally, you would have multiple resolutions available and serve the appropriate size depending upon the device accessing the data on the website.</p><p> 相反，不需要在屏幕上显示大图像明显小于它的尺寸。这样做可以浪费带宽;特别是，移动用户不会通过下载用于桌面的大型图像来浪费带宽，当一个小型图像为他们的设备做。理想情况下，您将有多种可用的分辨率，并根据访问网站上数据的设备提供适当的大小。</p><p> To make things more complicated, some devices have high resolution screens that need larger images than you might expect to display nicely. This is essentially the same problem, but in a slightly different context.</p><p> 为了使事物更复杂，一些设备具有高分辨率屏幕，需要更大的图像，它可能期望显示出很好。这基本上是相同的问题，但在略有不同的背景下。</p><p> You might think that vector images would solve these problems, and they do to a certain degree — they are small in file size and scale well, and you should use them wherever possible. However, they aren&#39;t suitable for all image types. Vector images are great for simple graphics, patterns, interface elements, etc., but it starts to get very complex to create a vector-based image with the kind of detail that you&#39;d find in say, a photo. Raster image formats such as JPEGs are more suited to the kind of images we see in the above example.</p><p> 您可能认为传染媒介图像将解决这些问题，并且他们在一定程度上做到了 - 它们在文件大小和比例中很小，并且您应该尽可能使用它们。但是，它们aren＆＃39; t适用于所有图像类型。矢量图像非常适合简单的图形，模式，接口元素等，但它开始获得非常复杂的，以创建基于向量的图像，其中包含您和＃39的详细信息。一张照片。栅格图像格式（如JPEG）更适合我们在上面示例中看到的图像类型。</p><p> This kind of problem didn&#39;t exist when the web first existed, in the early to mid 90s — back then the only devices in existence to browse the Web were desktops and laptops, so browser engineers and spec writers didn&#39;t even think to implement solutions.  Responsive image technologies were implemented recently to solve the problems indicated above by letting you offer the browser several image files, either all showing the same thing but containing different numbers of pixels ( resolution switching), or different images suitable for different space allocations ( art direction).</p><p> 这种问题没有存在，当网络首次存在时，在90年代早期 - 后退，那么唯一的设备浏览Web是桌面和笔记本电脑，所以浏览器工程师和规范作家没有＆＃39; t甚至认为实施解决方案。最近实施了响应的图像技术来解决上面的问题，通过让您提供多个图像文件，无论是相同的还是包含不同数量的像素（分辨率切换），或适用于不同的空间分配的不同图像（技术方向） ）。 </p><p> Note: The new features discussed in this article —   srcset/  sizes/  &lt;picture&gt; — are all supported in release versions of modern desktop and mobile browsers (including Microsoft&#39;s Edge browser, although not Internet Explorer.)</p><p>注意：本文中讨论的新功能 -  SRCSet /尺寸/＆lt;图片＆gt; - 全部支持现代桌面和移动浏览器的发布版本（包括Microsoft＆＃39; SEDED浏览器，虽然不是Internet Explorer。）</p><p>  In this section, we&#39;ll look at the two problems illustrated above and show how to solve them using HTML&#39;s responsive image features. You should note that we will be focusing on the HTML   &lt;img&gt;s for this section, as seen in the content area of the example above — the image in the site header is only for decoration, and therefore implemented using CSS background images.  CSS arguably has better tools for responsive design than HTML, and we&#39;ll talk about those in a future CSS module.</p><p>  在本节中，我们＆＃39; ll看看上面说明的两个问题，并展示如何使用HTML＆＃39;响应图像特征来解决它们。您应该注意到，我们将关注HTML＆lt; IMG＆gt; s为此部分，如上面示例的内容区域所示 - 站点标题中的图像仅用于装饰，因此使用CSS背景图像实现。 CSS可以说是与HTML的响应性设计有更好的工具，我们＆＃39; LL谈论未来的CSS模块中的工具。</p><p>  So, what is the problem that we want to solve with resolution switching? We want to display identical image content, just larger or smaller depending on the device — this is the situation we have with the second content image in our example. The standard   &lt;img&gt; element traditionally only lets you point the browser to a single source file:</p><p>  那么，我们想用解决方案切换解决的问题是什么？我们想展示相同的图像内容，根据设备略大或更小 - 这是我们在示例中具有第二个内容图像的情况。标准＆lt; img＆gt;元素传统上只允许您将浏览器指向单个源文件：</p><p>  We can however use two new attributes —   srcset and   sizes — to provide several additional source images along with hints to help the browser pick the right one. You can see an example of this in our  responsive.html example on Github (see also  the source code):</p><p>  但是，我们可以使用两个新的属性 -  SRCSet和大小 - 提供几个附加源图像以及提示来帮助浏览器挑选正确的源图像。您可以在Github上的响应中看到此示例。（另请参阅源代码）：</p><p>  The  srcset and  sizes attributes look complicated, but they&#39;re not too hard to understand if you format them as shown above, with a different part of the attribute value on each line. Each value contains a comma-separated list, and each part of those lists is made up of three sub-parts. Let&#39;s run through the contents of each now:</p><p>  SRCSet和尺寸属性看起来很复杂，但它们＆＃39;如果您如上所示格式化它们，则无法理解，在每行上具有不同部分的属性值的不同部分。每个值包含逗号分隔的列表，这些列表的每个部分由三个子部分组成。让＆＃39;■现在贯穿每个人的内容：</p><p> srcset defines the set of images we will allow the browser to choose between, and what size each image is. Each set of image information is separated from the previous one by a comma. For each one, we write:</p><p> SRCSet定义了一组图像，我们将允许浏览器选择，以及每个图像的大小。每组图像信息由逗号与前一个图像信息分开。对于每个人，我们写道：</p><p> The image&#39;s  intrinsic width in pixels ( 480w) — note that this uses the  w unit, not  px as you might expect. This is the image&#39;s real size, which can be found by inspecting the image file on your computer (for example, on a Mac you can select the image in Finder and press  Cmd +  I to bring up the info screen).</p><p> 图像＆＃39; s的内在宽度（480W） - 注意，这将使用W单位，而不是您可能期望的PX。这是图像＆＃39; s实际尺寸，可以通过检查计算机上的图像文件（例如，在Mac上，您可以在Finder中选择图像，然后按CMD + I键调出信息屏幕）。 </p><p> sizes defines a set of media conditions (e.g. screen widths) and indicates what image size would be best to choose, when certain media conditions are true — these are the hints we talked about earlier. In this case, before each comma we write:</p><p>大小定义了一组媒体条件（例如屏幕宽度）并指示当某些媒体条件为真时最好选择的图像大小 - 这些是我们迄今讨论的提示。在这种情况下，在每次逗号之前写：</p><p> A  media condition ( (max-width:600px)) — you&#39;ll learn more about these in the  CSS topic, but for now let&#39;s just say that a media condition describes a possible state that the screen can be in. In this case, we are saying &#34;when the viewport width is 600 pixels or less&#34;.</p><p> 媒体条件（（max-widey：600px）） - 您＆＃39; ll在CSS主题中了解有关这些的更多信息，但现在让＆＃39; s只是说媒体条件描述了屏幕可以的状态在这种情况下，我们正在说＆＃34;当视口宽度为600像素或更少＆＃34;</p><p>    The  width of the slot the image will fill when the media condition is true ( 480px)</p><p>    当媒体条件为真时，图像将填充图像的宽度（480px）</p><p> Note: For the slot width, you may provide an absolute length ( px,  em) or a length relative to the viewport ( vw), but not percentages. You may have noticed that the last slot width has no media condition (this is the default that is chosen when none of the media conditions are true). The browser ignores everything after the first matching condition, so be careful how you order the media conditions.</p><p> 注意：对于插槽宽度，您可以提供相对于视口（VW）的绝对长度（PX，EM）或长度，但不是百分比。您可能已经注意到最后一个插槽宽度没有媒体条件（这是默认情况下选择的默认值为True）。浏览器在第一个匹配条件后忽略所有内容，因此请小心您订购媒体条件。</p><p>  Work out which media condition in the  sizes list is the first one to be true.</p><p>  在尺寸列表中制定哪种媒体条件是第一个是真实的。</p><p>    Load the image referenced in the  srcset list that has the same size as the slot or, if there isn&#39;t one, the first image that is bigger than the chosen slot size.</p><p>    加载具有与插槽相同大小的SRCSet列表中引用的图像，或者如果有一个，则＆＃39; t一个，第一图像大于所选插槽大小。</p><p> And that&#39;s it! At this point, if a supporting browser with a viewport width of 480px loads the page, the  (max-width: 600px) media condition will be true, and so the browser chooses the  480px slot. The  elva-fairy-480w.jpg will be loaded, as its inherent width ( 480w) is closest to the slot size. The 800px picture is 128KB on disk, whereas the 480px version is only 63KB — a saving of 65KB. Now, imagine if this was a page that had many pictures on it. Using this technique could save mobile users a lot of bandwidth.</p><p> 而且它＆＃39;此时，如果具有视口宽度为480px的支持浏览器加载页面，则（max-width：600px）媒体条件将为真，因此浏览器选择480px插槽。 ELVA-FAIRY-480W.jpg将被加载，因为其固有宽度（480W）最接近插槽大小。 800px图片在磁盘上为128KB，而480px版本仅为63KB  - 保存65KB。现在，想象一下，如果这是一个有很多图片的页面。使用此技术可以节省移动用户很多带宽。 </p><p> Note: When testing this with a desktop browser, if the browser fails to load the narrower images when you&#39;ve got its window set to the narrowest width, have a look at what the viewport is (you can approximate it by going into the browser&#39;s JavaScript console and typing in  document.querySelector(&#39;html&#39;).clientWidth). Different browsers have minimum sizes that they&#39;ll let you reduce the window width to, and they might be wider than you&#39;d think. When testing it with a mobile browser, you can use tools like Firefox&#39;s  about:debugging page to inspect the page loaded on the mobile using the desktop developer tools.    To see which images were loaded, you can use Firefox DevTools&#39;s  Network Monitor tab.</p><p>注意：当使用桌面浏览器测试时，如果浏览器无法在当＆＃39; vere将其窗口设置为最小的宽度时加载较窄的图像，请查看视口是什么（您可以通过进入近似浏览器＆＃39; s javascript控制台和键入document.querySelector（＆＃39; html＃39;）。ClientWidth）。不同的浏览器的最小尺寸与它们＆＃39; ll让您减少窗口宽度，并且它们可能比您宽＆＃39;使用移动浏览器测试它时，您可以使用Firefox＆＃39; s的工具，即：调试页面，以检查使用桌面开发人员工具在移动上加载的页面。要查看加载了哪些图像，您可以使用Firefox DevTools＆＃39; s网络监视器标签。</p><p> Older browsers that don&#39;t support these features will just ignore them. Instead, those browsers will go ahead and load the image referenced in the   src attribute as normal.</p><p> Don＆＃39; t支持这些功能的旧浏览器只会忽略它们。相反，这些浏览器将继续加载SRC属性中引用的图像作为正常。</p><p> Note: In the   &lt;head&gt; of the example linked above, you&#39;ll find the line  &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width&#34;&gt;: this forces mobile browsers to adopt their real viewport width for loading web pages (some mobile browsers lie about their viewport width, and instead load pages at a larger viewport width then shrink the loaded page down, which is not very helpful for responsive images or design).</p><p> 注意：在＆lt; head＆gt;在上面链接的示例中，你＆＃39; ll找到线＆lt; meta name =＆＃34; viewport＆＃34;内容=＆＃34;宽度=设备宽度＆＃34;＆gt ;:这强制移动浏览器采用它们的真实视口宽度加载网页（一些移动浏览器介绍它们的视口宽度，而是在更大的视口宽度加载页面然后缩小加载的页面，对响应图像或设计并不是很有用）。</p><p>  If you&#39;re supporting multiple display resolutions, but everyone sees your image at the same real-world size on the screen, you can allow the browser to choose an appropriate resolution image by using  srcset with x-descriptors and without  sizes — a somewhat easier syntax! You can find an example of what this looks like in  srcset-resolutions.html (see also  the source code):</p><p>  如果您＆＃39;重新支持多个显示分辨率，但每个人都在屏幕上以相同的实际尺寸看到图像，可以允许浏览器通过使用X描述符的SRCSet选择适当的分辨率映像，没有大小 -  a有点简单的语法！您可以在srcset-solatutions中找到它的示例.html（另请参阅源代码）：</p><p>  In this example, the following CSS is applied to the image so that it will have a width of 320 pixels on the screen (also called CSS pixels):</p><p>  在该示例中，将以下CSS应用于图像，使得屏幕上的320像素的宽度（也称为CSS像素）：</p><p>  In this case,  sizes is not needed — the browser works out what resolution the display is that it is being shown on, and serves the most appropriate image referenced in the  srcset. So if the device accessing the page has a standard/low resolution display, with one device pixel representing each CSS pixel, the  elva-fairy-320w.jpg image will be loaded (the 1x is implied, so you don&#39;t need to include it.) If the device has a high resolution of two device pixels per CSS pixel or more, the  elva-fairy-640w.jpg image will be loaded. The 640px image is 93KB, whereas the 320px image is only 39KB.</p><p>  在这种情况下，不需要大小 - 浏览器求出显示器的解决方案是它显示的，并且服务于SRCSet中引用的最合适的图像。因此，如果访问页面的设备具有标准/低分辨率显示，则使用表示每个CSS像素的一个设备像素，将加载ELVA-FAIRY-320W.jpg图像（暗示1倍，因此您不需要＆＃39;需要要包括它。）如果设备具有每个CSS像素的两个设备像素的高分辨率，则将加载ELVA-FAIRY-640W.jpg图像。 640px图像为93KB，而320px图像仅为39KB。</p><p>  To recap, the  art direction problem involves wanting to change the image displayed to suit different image display sizes. For example, a web page includes a large landscape shot with a person in the middle when viewed on a desktop browser. When viewed on a mobile browser, that same image is shrunk down, making the person in the image very small and hard to see. It would probably be better to show a smaller, portrait image on mobile, which zooms in on the person. The   &lt;picture&gt; element allows us to implement just this kind of solution.</p><p>  为了回顾，艺术方向问题涉及想要更改显示的图像以适应不同的图像显示大小。例如，网页包括在桌面浏览器上观看时，使用中间的人拍摄大景观。在移动浏览器上查看时，相同的图像缩小，使图像中的人非常小而难以看。在移动设备上显示一个较小的肖像图像可能会更好，这会放弃在人身上。 ＆lt;图片＆gt;元素允许我们仅实现这种解决方案。 </p><p> Returning to our original  not-responsive.html example, we have an image that badly needs art direction:</p><p>返回我们的原始响应.html示例，我们有一个糟糕需要艺术方向的图像：</p><p>  Let&#39;s fix this, with   &lt;picture&gt;! Like   &lt;video&gt; and  &lt;audio&gt;, the  &lt;picture&gt; element is a wrapper containing several   &lt;source&gt; elements that provide different sources for the browser to choose from, followed by the all-important   &lt;img&gt; element. The code in  responsive.html looks like so:</p><p>  让＆＃39; s用＆lt;图片＆gt;！像＆lt;视频＆gt;和＆lt;音频＆gt;，＆lt;图片＆gt;元素是包含多个＆lt;源＆gt的包装器;为浏览器提供不同来源的元素从中选择，然后是全文＆lt; img＆gt;元素。响应中的代码如下所示：</p><p>  The  &lt;source&gt; elements include a  media attribute that contains a media condition — as with the first  srcset example, these conditions are tests that decide which image is shown — the first one that returns true will be displayed. In this case, if the viewport width is 799px wide or less, the first  &lt;source&gt; element&#39;s image will be displayed. If the viewport width is 800px or more, it&#39;ll be the second one.</p><p>  ＆lt;来源＆gt;元素包括包含媒体条件的媒体属性 - 与第一个SRCSet示例一样，这些条件是决定显示的图像的测试 - 将显示返回true的第一个返回的测试。在这种情况下，如果视口宽度为799px宽或更短，则第一个源＆gt;元素＆＃39; S图像将显示。如果视口宽度为800px或更多，则它＆＃39; ll是第二个。</p><p>  The  srcset attributes contain the path to the image to display. Just as we saw with  &lt;img&gt; above,  &lt;source&gt; can take a  srcset attribute with multiple images referenced, as well as a  sizes attribute. So, you could offer multiple images via a  &lt;picture&gt; element, but then also offer multiple resolutions of each one. Realistically, you probably won&#39;t want to do this kind of thing very often.</p><p>  SRCSet属性包含要显示图像的路径。就像我们用＆lt; img＆gt所看到的那样;以上，＆lt;来源＆gt;可以使用多个映像引用的SRCSet属性以及大小属性。因此，您可以通过＆lt;图片和gt提供多个图像。元素，但随后还提供多个分辨率。实际上，你可能会赢得＆＃39;想经常做这种事情。</p><p>  In all cases, you must provide an  &lt;img&gt; element, with  src and  alt, right before  &lt;/picture&gt;, otherwise no images will appear. This provides a default case that will apply when none of the media conditions return true (you could actually remove the second  &lt;source&gt; element in this example), and a fallback for browsers that don&#39;t support the  &lt;picture&gt; element.</p><p>  在所有情况下，必须提供＆lt; img＆gt;元素，具有src和alt，右前＆lt; / picture＆gt;否则不会出现图像。这提供了默认情况下，当媒体条件返回true none时元素。</p><p> This code allows us to display a suitable image on both wide screen and narrow screen displays, as shown below:</p><p> 此代码允许我们在宽屏和窄屏幕显示屏上显示合适的图像，如下所示：</p><p>  Note: You should use the  media attribute only in art direction scenarios; when you do use  media, don&#39;t also offer media conditions within the  sizes attribute.</p><p>  注意：您应该仅在艺术方向方案中使用媒体属性;当您使用媒体时，Don＆＃39; t还提供大小属性内的媒体条件。 </p><p>  When the browser starts to load a page, it starts to download (preload) any images before the main parser has started to load and interpret the page&#39;s CSS and JavaScript. That mechanism is useful in general for reducing page load times, but it is not helpful for responsive images — hence the need to implement solutions like  srcset. For example, you couldn&#39;t load the   &lt;img&gt; element, then detect the viewport width with JavaScript, and then dynamically change the source image to a smaller one if desired. By then, the original image would already have been loaded, and you would load the small image as well, which is even worse in responsive image terms.</p><p>当浏览器开始加载页面时，它开始下载（预加载）在主解析器开始加载和解释页面＆＃39; s css和javascript之前的任何图像。该机制通常用于减少页面加载时间，但对响应图像并不有用 - 因此需要实现SRCSet等解决方案。例如，您可以加载＆＃39; t＆lt; img＆gt;元素，然后用JavaScript检测视口宽度，然后如果需要，然后将源图像动态地将源图像改变为较小的源图像。然后，原始图像已经加载，并且您也可以加载小图像，这在响应图像术语中甚至更差。</p><p>  New image formats like  WebP and  AVIF can maintain a low file size and high quality at the same time. These formats now have relatively broad browser support but little &#34;historical depth&#34;.</p><p>  新的图像格式如WPP和AVIF可以同时保持低文件大小和高质量。这些格式现在具有相对广泛的浏览器支持，但很少＆＃34;历史深度＆＃34;</p><p> &lt;picture&gt; lets us continue catering to older browsers. You can supply MIME types inside  type attributes so the browser can immediately reject unsupported file types:</p><p> ＆lt;图片＆gt;让我们继续迎合旧浏览器。您可以在类型属性中提供MIME类型，因此浏览器可以立即拒绝不受支持的文件类型：</p><p>  In a  &lt;source&gt; element, you can only refer to images of the type declared in  type.</p><p>  在一个＆lt;来源＆gt;元素，您只能参考类型中声明的类型的图像。</p><p>  For this active learning, we&#39;re expecting you to be brave and go it alone ... mostly. We want you to implement your own suitable art directed narrow screen/wide screen shot using  &lt;picture&gt;, and a resolution switching example that uses  srcset.</p><p>  对于这个积极的学习，我们＆＃39;重新期待你勇敢，独自走去......大多是。我们希望您使用＆lt;图片＆gt;和使用SRCSet的分辨率切换示例来实现自己的合适艺术定向屏幕/宽屏镜头。</p><p> Write some simple HTML to contain your code (use  not-responsive.html as a starting point, if you like).</p><p> 写一些简单的HTML来包含代码（如果您喜欢，请使用not-rencorly.html作为起点）。</p><p>  Find a nice wide screen landscape image with some kind of detail contained in it somewhere. Create a web-sized version of it using a graphics editor, then crop it to show a smaller part that zooms in on the detail, and create a second image (about 480px wide is good for this).</p><p>  找到一个漂亮的宽屏景观图像，其中包含某种细节。使用图形编辑器创建一个Web大小的版本，然后裁剪它以显示一个细节缩小的较小部分，并创建第二个图像（约480px宽对此）。 </p><p>      Use  srcset/ size to create a resolution switcher example, either to serve the same size image at different resolutions, or different image sizes at different viewport widths.</p><p>使用SRCSet / Size创建分辨率切换器示例，用于以不同的分辨率的相同尺寸图像，或在不同视口宽度下的不同图像大小。</p><p>  You&#39;ve reached the end of this article, but can you remember the most important information? You can find a detailed assessment that tests these skills at the end of the module; see  Mozilla splash page.</p><p>  你＆＃39; ve达到了本文的末尾，但你还记得最重要的信息吗？您可以找到详细的评估，该评估在模块末尾测试这些技能;请参阅Mozilla Splash页面。</p><p>  That&#39;s a wrap for responsive images — we hope you enjoyed playing with these new techniques. As a recap, there are two distinct problems we&#39;ve been discussing here:</p><p>  这是一个响应图像的包装 - 我们希望您喜欢使用这些新技术。作为回顾，我们在这里讨论了两个不同的问题：</p><p> Art direction: The problem whereby you want to serve cropped images for different layouts — for example a landscape image showing a full scene for a desktop layout, and a portrait image showing the main subject zoomed in for a mobile layout. You can solve this problem using the   &lt;picture&gt; element.</p><p> 艺术方向：您要为不同布局提供裁剪图像的问题 - 例如，显示桌面布局的完整场景的风景图像，以及显示主对象的纵向图像放大了移动布局。您可以使用＆lt;图片和gt来解决这个问题。元素。</p><p>  Resolution switching: The problem whereby you want to serve smaller image files to narrow screen devices, as they don&#39;t need huge images like desktop displays do — and also optionally that you want to serve different resolution images to high density/low density screens. You can solve this problem by using  vector graphics (SVG images) and the   srcset with   sizes attributes.</p><p>  分辨率切换：您希望为狭窄的屏幕设备提供较小的图像文件的问题，因为它们不需要桌面显示，并且还可以选择为高密度/低密度提供不同的分辨率图像屏幕。您可以使用矢量图形（SVG图像）和具有尺寸属性的SRCSet来解决此问题。</p><p> This also draws to a close the entire  Multimedia and embedding module! The only thing to do now before moving on is to try our multimedia assessment, and see how you get on. Have fun!</p><p> 这也绘制了整个多媒体和嵌入模块的关闭！在继续前进之前现在唯一要做的是尝试我们的多媒体评估，并了解您的方式。玩得开心！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/响应/">#响应</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/图像/">#图像</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>