<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Radicle了解对等Git伪造 Understanding Peer-to-Peer Git Forges with Radicle</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Understanding Peer-to-Peer Git Forges with Radicle<br/>使用Radicle了解对等Git伪造 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-07 06:01:24</div><div class="page_narrow text-break page_content"><p>Git is a distributed version control system and does not require a central server. Although repositories are usually published at a well-known location for convenient cloning and fetching of the latest changes, this is actually not necessary. Each clone can have the full commit history and evolve independently. Furthermore, code changes can be exchanged via email or other means. Finally, even the clone itself does not need to be made from a well-known domain that hosts a git repository (see  git-bundle(1)).</p><p>Git是一个分布式版本控制系统，不需要中央服务器。尽管通常将存储库发布在一个众所周知的位置，以便于克隆和获取最新更改，但这实际上不是必需的。每个克隆都可以具有完整的提交历史记录，并且可以独立发展。此外，可以通过电子邮件或其他方式交换代码更改。最后，即使克隆本身也不需要从托管git存储库的知名域中创建（请参阅git-bundle（1））。</p><p> Given that git itself is already fully decentralized one would think there is no further work to do. I came across the  Radicle project and its somewhat psychedelic website. Besides having a website with a wild color scheme, the project aims to offer a social coding experiment or git forge functionality using a peer-to-peer network architecture. According to the  documentation the motivation seems to be that git&#39;s built-in functionality works but is not user-friendly enough to make it accessible. In particular, it lacks social coding features.</p><p> 鉴于git本身已经完全分散，人们会认为没有进一步的工作要做。我遇到了Radicle项目及其迷幻的网站。该项目除了拥有一个带有狂野色彩方案的网站外，还旨在使用对等网络体系结构提供社交编码实验或git forge功能。根据文档，动机似乎是git的内置功能有效，但不够用户友好以使其无法访问。特别是，它缺乏社交编码功能。</p><p> The goal is to add git forge features like project and developer discovery, issue trackers, wikis, etc. Additional, distinctly decentralized functionality, is also touched on involving Ethereum as a way to anchor project metadata, pay contributors, etc. Radicle is still in early development so these features are not yet implemented. Here is my take on the  How it Works documentation, which is a little confusing due to its early stage and some incomplete sentences or typos. I don&#39;t know whether my understanding actually corresponds to the Radicle implementation that exists today or its eventual vision, because I haven&#39;t studied the code or tried running the software. However, the ideas that the documentation has brought up are interesting and fruitful in their own right, so I wanted to share them and explain them in my own words in case you also find them worth exploring.</p><p> 目标是添加git forge功能，例如项目和开发人员发现，问题跟踪器，Wiki等。另外，还涉及明显分散的功能，包括以太坊作为锚定项目元数据，支付贡献者等的方式。Radicle仍然在早期开发，因此尚未实现这些功能。这是我对“工作原理”文档的看法，由于该文档的早期阶段以及某些不完整的句子或错别字，因此有点令人困惑。我不知道我的理解是否实际上对应于今天存在的Radicle实现或其最终愿景，因为我没有研究代码或尝试运行该软件。但是，文档提出的想法本身就很有趣且富有成果，因此我想与大家分享并用自己的语言解释它们，以防您也发现它们值得探索。</p><p>  Let&#39;s quickly review the git data model because it is important for understanding peer-to-peer git forges. A git repository contains a  refs/ subdirectory that provides a namespace for local branch heads ( refs/heads/), local and remotely fetched tags ( refs/tags/), and remotely fetched branches ( refs/remotes/&lt;remote&gt;/). Actually this namespace layout is just a convention for everyday git usage and it&#39;s possible to use the  refs/ namespace differently as we will see. The git client fetches refs from a remote according to a  refspec rule that maps remote refs to local refs. This gives the client the power to fetch only certain refs from the server. The client can also put them in a different location in its local  refs/ directory than the server. For details, see the  git-fetch(1) man page.</p><p>  让我们快速回顾一下git数据模型，因为它对于理解点对点git伪造很重要。 git存储库包含refs /子目录，该目录为本地分支头（refs / heads /），本地和远程获取的标签（refs / tags /）以及远程获取的分支（refs / remotes /＆lt; remote＆gt; /）提供名称空间。实际上，此命名空间布局只是日常使用git的惯例，我们可以看到，可以不同地使用refs /命名空间。 git客户端根据将远程引用映射到本地引用的refspec规则从远程获取引用。这使客户端可以仅从服务器获取某些引用。客户端还可以将它们放置在其本地refs /目录中与服务器不同的位置。有关详细信息，请参见git-fetch（1）手册页。</p><p> Refs files contain the commit hash of an  object stored in the repository&#39;s object database. An object can be a commit, tree (directory), tag, or a blob (file). Branch refs point to the latest commit object. A commit object refers to a tree object that may refer to further tree objects for sub-directories and finally the blob objects that make up the files being stored. Note that a git repository supports  disjoint branches that share no history. Perhaps the most well-known example of disjoint branches are the GitHub Pages and GitLab Pages features where these git forges publish static websites from the HTML/CSS/JavaScript/image files on a specific branch in the repository. That branch shares no version history with other branches and the directories/files typically have no similarity to the repository&#39;s main branch.</p><p> 引用文件包含存储在存储库的对象数据库中的对象的提交哈希。对象可以是提交，树（目录），标签或Blob（文件）。分支引用指向最新的提交对象。提交对象指的是一个树对象，该树对象可以指的是子目录的其他树对象，最后指的是构成要存储文件的blob对象。请注意，git存储库支持不共享历史的不相交分支。脱节分支最著名的例子可能是GitHub Pages和GitLab Pages功能，其中这些git forges通过存储库中特定分支上的HTML / CSS / JavaScript / image文件发布静态网站。该分支与其他分支不共享任何版本历史记录，并且目录/文件通常与存储库的主分支没有相似性。</p><p> Now we have covered enough git specifics to talk about peer-to-peer git forges. If you want to learn more about how git objects are actually stored, check out my article on the  repository layout and pack files.</p><p> 现在，我们已经介绍了足够多的git细节，以讨论点对点git伪造。如果您想了解有关如何实际存储git对象的更多信息，请查看我有关存储库布局和打包文件的文章。</p><p>  Normally a git repository has one or more owners who are allowed to push refs. No one else has permission to modify the refs namespace. What if we tried to share a single refs namespace with the whole world and everyone could push? There would be chaos due to naming conflicts and malicious users would delete or change other users&#39; refs. So it seems like an unworkable idea unless there is some way to enforce structure on the global refs namespace.</p><p>  通常情况下，一个git存储库中有一个或多个所有者，这些所有者可以推送参考。没有其他人有权修改refs名称空间。如果我们尝试与全世界共享一个refs名称空间，并且每个人都可以推送该怎么办？命名冲突会造成混乱，恶意用户会删除或更改其他用户。裁判因此，除非有某种方法可以在全局引用名称空间上强制执行结构，否则这似乎是一个不可行的想法。 </p><p> Peer-to-peer systems have solutions to these problems. First, a unique identity can be created by picking a random number with a sufficient number of bits so that the chance of collision is improbable. That unique identity can be used as a prefix in the global ref namespace to avoid accidental collisions. Second, there needs to be a way to prevent unauthorized users from modifying the part of the global namespace that is owned by other users.</p><p>对等系统可以解决这些问题。首先，可以通过选择具有足够位数的随机数来创建唯一标识，从而避免发生冲突的可能性。该唯一标识可以用作全局ref名称空间中的前缀，以避免意外冲突。其次，需要有一种方法来防止未经授权的用户修改其他用户拥有的全局名称空间部分。</p><p> Public-key cryptography provides the primitive for achieving both these things. A public key or its hash can serve as the unique identifier that provides identity and prevents accidental collisions. Ownership can be enforced by verifying that changes to the global namespace are signed with the private key corresponding to the unique identity.</p><p> 公钥密码学为实现这两个目标提供了原语。公钥或其哈希可以用作提供身份并防止意外冲突的唯一标识符。可以通过验证是否使用与唯一身份相对应的私钥对全局名称空间进行更改来强制实施所有权。</p><p>   This is a simplified example based on the Radicle documentation. Here  identity is the unique identity based on a public key. Remember no one else in the world has the same identity because the chance of generating the same public key is improbable. The  heads/ refs are normal git refs to commit objects - these are published branches. The  signed_refs ref points to an git object that contains a list of commit hashes and a signature generated using the public key. The signature can be verified using the public key.</p><p>   这是基于Radicle文档的简化示例。这里的身份是基于公钥的唯一身份。请记住，世界上没有其他人具有相同的身份，因为不可能生成相同的公共密钥。 head / ref是提交对象的普通git ref-这些是已发布的分支。 signed_refs ref指向一个git对象，该对象包含提交哈希列表和使用公钥生成的签名。可以使用公钥验证签名。</p><p> Next we need to  verify these changes to check that they were created with the private key that is only known to the identity&#39;s owner. First, we check the signature on the object pointed to by the  signed_refs ref. If the signature is not valid we reject these changes and do not store them in our local repository. Next, we look up each ref in  heads/ against the list in  signed_refs. If a ref is missing from the list then we reject these refs and do not allow them into our local repository.</p><p> 接下来，我们需要验证这些更改，以检查它们是否是使用身份所有者专有的私钥创建的。首先，我们检查一下signed_refs ref指向的对象上的签名。如果签名无效，我们将拒绝这些更改，也不会将其存储在本地存储库中。接下来，我们在heads /中的每个ref相对signed_refs中的列表进行查找。如果列表中缺少参考，那么我们将拒绝这些参考，并且不允许它们进入我们的本地存储库。</p><p> This scheme lends itself to peer-to-peer systems because the refs can be propagated (copied) between peers and verified at each step. The identity owner does not need to be present at each copy step since their cryptographic signature is all we need to be certain that they authorized these refs. So I can receive refs originally created by identity A from peer B and still be sure that peer B did not modify them since identity A&#39;s signature is intact.</p><p> 该方案适用于点对点系统，因为ref可以在对等点之间传播（复制）并在每个步骤进行验证。身份所有者不需要在每个复制步骤中都在场，因为我们需要他们的加密签名才能确保他们授权了这些引用。因此，我可以从对等端B接收到由身份A最初创建的引用，并且仍然可以确保对等端B没有修改它们，因为身份A的签名是完整的。</p><p> Now we have a global refs namespace that is partitioned so that each identity is able to publish refs and peers can verify that these changes are authorized.</p><p> 现在，我们有了一个分区的全局引用命名空间，以便每个标识都可以发布引用，同级可以验证这些更改是否得到授权。</p><p>  It may not be clear yet that it&#39;s not necessary to clone the entire global namespace. In fact, it&#39;s possible that no single peer will ever have a full copy of the entire global namespace! That&#39;s because this is a distributed system. Peers only fetch refs that they care about from their peers. Peers fetch from each other and this forms a network. The network does not need to be fully connected and it&#39;s possible to have multiple clusters of peers running without full global connectivity.</p><p>  可能尚不清楚，是否有必要克隆整个全局名称空间。实际上，可能没有任何一个对等实体将拥有整个全局名称空间的完整副本！那是因为这是一个分布式系统。同行仅从同行那里获取他们关心的裁判。同行之间相互取长补短，形成一个网络。网络不需要完全连接，并且有可能在没有完全全局连接的情况下运行多个对等群集。 </p><p> To bootstrap the global namespace there are  seed repositories. Seeds are a common concept in peer-to-peer systems. They provide an entry point for new peers to learn about and start participating with other peers. In BitTorrent this is called a &#34;tracker&#34; rather than a &#34;seed&#34;.</p><p>要引导全局名称空间，有种子存储库。种子是点对点系统中的常见概念。它们为新的同龄人提供了切入点，让他们可以了解并开始与其他同龄人一起参与。在BitTorrent中，这称为＆＃34; tracker＆＃34;而不是＆＃34;种子＆＃34;。</p><p> According to the Radicle documentation it is possible to directly fetch from peers. This probably means a  git-daemon(1) or  git-http-backend(1) needs to be accessible on the public internet. Many peers will not have sufficient network connectivity due to  NAT limitations. I guess Radicle does not expect every user to participate as a repository.</p><p> 根据Radicle文档，可以直接从同级获取。这可能意味着需要在公共Internet上访问git-daemon（1）或git-http-backend（1）。由于NAT限制，许多对等节点将没有足够的网络连接。我猜Radicle并不希望每个用户都参与到存储库中。</p><p> Interestingly, there is a  gossip system for propagating refs through the network. Let&#39;s revisit the refs for an identity in the global namespace:</p><p> 有趣的是，有一个八卦系统可以通过网络传播裁判。让我们回顾一下全局命名空间中的身份引用：</p><p>  We can publish identities that we track in  remotes/. It&#39;s a recursive refs layout. This is how someone tracking our refs can find out about related identities and their refs.</p><p>  我们可以发布在remotes /中跟踪的身份。这是一个递归引用布局。这是跟踪我们的裁判的人可以找到有关相关身份及其裁判的方式。</p><p> Thanks to git&#39;s data model the commit, tree, and blob objects can be shared even though we duplicate refs published by another identity. Since git is a  content-addressable object database the data is stored once even though multiple refs point to it.</p><p> 由于git的数据模型，即使我们复制另一个身份发布的引用，也可以共享提交，树和Blob对象。由于git是一个内容可寻址的对象数据库，因此即使多个引用指向该数据，该数据也只存储一次。</p><p> Now we not only have a global namespace where anyone can publish git refs, but also ways to build a peer-to-peer network and propagate data throughout the network. It&#39;s important to note that data is only propagated if peers are interested in fetching it. Peers are not forced to store data that they are not interested in.</p><p> 现在，我们不仅拥有一个可以在其中发布任何人的git refs的全局名称空间，而且还具有构建对等网络并在整个网络中传播数据的方法。重要的是要注意，仅当对等体有兴趣获取数据时才传播数据。对等方不会被迫存储他们不感兴趣的数据。</p><p>  Let&#39;s bring the pieces together and show how the system stores data. The peer creates a local git repository called the  monorepo for the purpose of storing portions of the global namespace. It fetches refs from seeds or direct peers to get started. Thanks to the  remotes/ refs it also learns about other refs on the network that it did not request directly.</p><p>  让我们将各个部分放在一起，并展示系统如何存储数据。对等方创建一个名为monorepo的本地git存储库，以存储全局名称空间的某些部分。它从种子或直接同伴那里获取引用以开始使用。多亏了远程/引用，它还可以了解网络上其他未直接请求的引用。 </p><p> This git repository is just a data store, it is not usable for normal git workflows. The conventional  git branch and  git tag commands would not work well with the global namespace layout and verification requirements. Instead we can clone a local file:/// repository from the monorepo that fetches a subset of the refs into the conventional git refs layout. The files can be shared because  git-clone(1) supports hard links to local repositories. Thanks to  githooks(5) and/or extensible  git-push(1) remote helper support it&#39;s possible to generate the necessary global namespace metadata (e.g. signatures) when we push from the local clone to the local monorepo. The monorepo can then publish the final refs to other peers.</p><p>该git存储库只是一个数据存储，不适用于常规git工作流。传统的git branch和git tag命令不能与全局名称空间布局和验证要求一起很好地工作。相反，我们可以从monorepo克隆本地file：///存储库，该存储库将ref的子集提取到常规git refs布局中。由于git-clone（1）支持到本地存储库的硬链接，因此可以共享文件。感谢githooks（5）和/或可扩展的git-push（1）远程帮助程序支持，当我们从本地克隆推送到本地monorepo时，可以生成必要的全局名称空间元数据（例如签名）。然后，monorepo可以将最终参考发布给其他同行。</p><p>  There are neat ideas in Radicle and it remains to be seen how well it will grow to support git forge functionality. A number of challenges need to be addressed:</p><p>  Radicle中有一些简洁的想法，它在支持git forge功能方面的发展还有待观察。需要解决许多挑战：</p><p> Usability - Radicle is a middle-ground between centralized git forges and email-based decentralized development. The goal is to be easy to use like git forges. Peer-to-peer systems often have challenges providing a human-friendly interface on top of public key identities (having usernames without centralized user accounts). Users will probably prefer to think in terms of repositories, merge requests, issues, and wikis instead of peers, gossip, identities, etc.</p><p> 可用性-Radicle是集中式git伪造和基于电子邮件的分散式开发之间的中间地带。目标是易于使用，如git Forges。对等系统通常面临挑战，即在公钥身份（提供用户名而没有集中用户帐户）的基础上提供人性化的界面。用户可能更喜欢考虑存储库，合并请求，问题和Wiki，而不是同行，八卦，身份等。</p><p>  Security - The global namespace and peer-to-peer model is a target that malicious users will attack by trying to impersonate or steal identities, flood the system with garbage, game reputation systems with  sockpuppets, etc.</p><p>  安全性-全局名称空间和对等模型是恶意用户攻击的目标，他们试图冒充或窃取身份，向系统中注入垃圾，向游戏信誉系统添加假名，等等。</p><p>  Scalability - Peers only care about certain repositories and don&#39;t want to be slowed down by all the other refs in the global namespace. The recursive refs layout seems like it could cause performance problems and maybe users will configure clients to limit the depth to a low number like 3. At first glance Radicle should be able to scale well since peers only need to fetch refs they are interested in, but it&#39;s a novel way of using git refs, so we can expect scalability problems as the system grows.</p><p>  可伸缩性-对等方只关心某些存储库，并且不希望被全局命名空间中的所有其他引用放慢速度。递归引用布局似乎可能会导致性能问题，也许用户会配置客户端以将深度限制为较低的数字（例如3）。乍一看，Radicle应该能够很好地扩展，因为同级仅需要获取他们感兴趣的引用，但这是使用git refs的一种新颖方法，因此我们可以预期随着系统的增长会出现可伸缩性问题。</p><p>  Data model - How will this data model grow to handle wikis, issue trackers, etc? Issue tracker comments are an example of a data structure that requires conflict resolution in a distributed system. If two users post comments on an issue, how will this be resolved without a conflict? Luckily there is quite a lot of research on distributed data structures such as  Conflict-free Replicated Data Types (CRDTs) and it may be possible to avoid most conflicts by eliminating concepts like linear comment numbering.</p><p>  数据模型-该数据模型将如何增长以处理Wiki，问题跟踪器等？问题跟踪器注释是需要在分布式系统中解决冲突的数据结构的示例。如果两个用户对一个问题发表评论，将如何解决而不会发生冲突？幸运的是，对分布式数据结构（例如无冲突复制数据类型（CRDT））进行了大量研究，并且可以通过消除线性注释编号之类的概念来避免大多数冲突。</p><p>  CI/CD - As mentioned in my blog post about why  git forges are von Neumann machines, git forges are more than just data stores. They also have a computing model, initially used for  Continuous Integration and  Continuous Delivery, but really a general serverless computing platform. This is hard to do securely and without unwanted resource usage in a peer-to-peer system. Maybe Radicle will use Ethereum for compute credits?</p><p>  CI / CD-正如我在博客文章中提到的为什么git伪造是冯·诺依曼机器一样，git伪造不仅仅是数据存储。他们也有一个计算模型，最初用于持续集成和持续交付，但实际上是一个通用的无服务器计算平台。很难安全地做到这一点，并且在对等系统中没有不必要的资源使用。也许Radicle将使用以太坊进行计算积分？ </p><p>  Radicle is a cool idea and I look forward to seeing where it goes. It is still at an early stage but already shows interesting approaches with the global refs namespace and monorepo data store.</p><p>Radicle是一个好主意，我期待看到它的发展。 它仍然处于早期阶段，但是已经显示了使用全局refs名称空间和monorepo数据存储的有趣方法。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://blog.vmsplice.net/2020/12/understanding-peer-to-peer-git-forges.html">http://blog.vmsplice.net/2020/12/understanding-peer-to-peer-git-forges.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/radicle/">#radicle</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/peer/">#peer</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>