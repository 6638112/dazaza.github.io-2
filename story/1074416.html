<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>实时Linux还有一个已知的问题</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">实时Linux还有一个已知的问题</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-21 10:04:56</div><div class="page_narrow text-break page_content"><p>[Date Prev][Date Next][Thread Prev][Thread Next][Date Index][Thread Index]亲爱的RT朋友们！我&#39；我很高兴宣布v5。17-rc3-rt6配线架。自v5以来的变化。17-rc3-rt5:-更新John&#39；s printk系列。它现在支持从irqwork直接打印。-正确访问printk中的变量。约翰·奥格尼斯的补丁。-如果ksoftirqd从空闲状态唤醒，请添加警告。-针对随机子系统的Jason A.Donenfeld补丁更新为v4。顶部还有一个与RT相关的额外变化。-已知问题netconsole会触发警告。已从列表中删除，因为它还使用CONFIG_PREEMPT和v5触发。17-rc3（无抢占补丁）。已知问题-Valentin Schneider报告ARM64上出现了一些飞溅，请参阅https://lkml.kernel.org/r/20210810134127.1394269-1-valentin.schneider@xxxxxxx针对v5的增量补丁。可以在下面找到RC17-5：https://cdn.kernel.org/pub/linux/kernel/projects/rt/5.17/incr/patch-5.17-rc3-rt5-rt6.patch.xzYou可以通过git树获取此版本，网址为：git://git.kernel.org/pub/scm/linux/kernel/git/rt/linux-rt-devel.gitv5。17-rc3-RT6针对v5的RT补丁。17-rc3可在此处找到：https://cdn.kernel.org/pub/linux/kernel/projects/rt/5.17/older/patch-5.17-rc3-rt6.patch.xzThe拆分被子队列可在以下位置使用：https://cdn.kernel.org/pub/linux/kernel/projects/rt/5.17/older/patches-5.17-rc3-rt6.tar.xzSebastiandiff--git a/drivers/char/random。c b/驱动程序/字符/随机。cindex afcedefb0c1c8。。E4BD9C917654 100644---a/drivers/char/random。c++b/驱动程序/字符/随机。c@@@404,7+404,7@@@struct fast_pool{struct work_struct mix；unsigned long last；u32 pool[4]；-atomic_t count；+unsigned int count；u16 reg_idx；}#定义FAST_POOL_MIX_INFLIGHT（1U&lt；&lt；31）@-1045,25+1045,33@@static u32 get_reg（struct FAST_POOL*f，struct pt_regs*regs）static void MIX_interrupt_random（struct work_struct*work）{struct FAST_POOL=container_of（work，struct FAST_POOL，MIX）；+u8 POOL[sizeof（FAST_POOL-&gt；POOL-&gt；last=jiffies；]（不太可能（crng_init==0））{+size_t ret；-/*因为这是通过调度程序执行一次trip的结果，xor in+ret=crng_fast_load（（u8*）fast_pool-&gt；pool，sizeof（fast_pool-&gt；pool））；+if（ret）{+WRITE_ONCE（fast_pool-&gt；count，0）；+fast_pool-&gt；last=jiffies；+return；++/*，因为这是通过调度程序执行一次trip的结果调度程序，循环计数器中的xor。它可以&#39；我不疼，也许会有帮助。*/fast_pool-&gt；pool[3]^=random_get_entropy（）+/*将池复制到堆栈中，以便混合器始终具有一致的视图*/+memcpy（池、快速池-&gt；池、大小池）+/*只有在我们&#39；我们看完泳池了*/+写入一次（快速池-&gt；计数，0）+快速游泳池-&gt；last=jiffies-if（不太可能（crng_init==0）{if（crng_fast_load（（u8*））和fast_pool-&gt；pool，sizeof（fast_pool-&gt；pool））&gt；0-原子集（&amp；fast_pool-&gt；count，0）；-else-原子集和（~fast_pool_MIX飞行中，&amp；fast_pool-&gt；count）；-return；---MIX_pool_字节（&amp；fast_pool-&gt；pool，sizeof-&gt；pool-&gt；&gt；&gt；&gt；&gt；池-原子集（&amp；fast_pool-&gt；count，0）+mix_pool_字节（pool，sizeof（pool））；信用熵位（1）+memzero_explicit（pool，sizeof（pool））；}void add_interrupt_randomanness（intirq）@-1089,15+1097,33@@@void add_interrupt_randomanness（intirq）fast_mix（fast_pool）；添加中断工作台（周期）+新计数=+快速池-&gt；计数-new_count=（unsigned int）原子_inc_return（&amp；fast_pool-&gt；count）-if（new_count&gt；=64&amp；&amp；new_count&lt；FAST_POOL&gt；last+HZ）|124;不太可能（crng_init==0））{+if（不太可能（crng_init==0））{+if（new_count&amp；FAST_POOL&lt；MIX_INFLIGHT）+返回；+if（new_count gt；64）+返回；+FAST_-POOL-&gt；count（不太可能（！fast_pool-&gt；mix.func））初始工作（&amp；fast_pool-&gt；混合、混合、中断\u随机性）-原子或（快速池混合机上和快速池计数）-安排工作（快速组合）+队列工作（原始smp处理器id（）、系统高优先级wq、+&amp；快速游泳池-&gt；混合）+回来}++if（新计数和快速池混合机）+return++如果（新计数&lt；64&amp；！时间&u之后（现在，快速池-&gt；最后+HZ））+返回++如果（不太可能（！fast_pool-&gt；mix.func））+INIT_WORK（&amp；fast_pool-&gt；mix，mix_interrupt_random）+快速游泳池-&gt；计数|=快速_池_混合_机上+队列工作（原始smp处理器id（）、系统高优先级wq等）；快速游泳池-&gt；混合）；}导出符号GPL（添加中断随机性）；@-1881,13+1907,16@@static int__initrandom_sysctls_init（void）device_initcall（random_sysctls_init）#endif/*CONFIG_SYSCTL*/+static atomic_t batch_generation=atomic_INIT（0）；+结构批处理的_熵{union{u64熵64[CHACHA_BLOCK_SIZE/sizeof（u64）]；u32熵_u32[CHACHA_BLOCK_SIZE/sizeof（u32）]；}+本地锁；无符号整数位置-spinlock_u t batch_lock+int generation；}；/*@-1899,7+1928,7@@struct batched_entropy{*point prior.*/static DEFINE_PER_CPU（struct batched_entropy，batched_entropy_u64）={-.batch_lock=u SPIN_lock_unlock（batched_entropy_u64.lock），+.lock=INIT_LOCAL_lock（batched_entropy__64.lock）}；u64 get_random_u64（void）@-1908,67+1937,65@@u64 get_random_u64（void）无符号长标志；结构批处理_熵*批处理；静态无效*先前+int next_gen；警告未种子随机性（&amp；先前）+local_lock_irqsave（&amp；batched_entropy_u64.lock，flags）；批处理=原始cpu ptr（&amp；批处理熵）\u64）-旋转锁定irqsave（批处理-&gt；批处理锁定，标志）-if（批处理-&gt；位置%ARRAY_SIZE（批处理-&gt；熵_u64）==0{++next_gen=原子读取（&gt；批处理生成）；+if（批处理-&gt；位置%ARRAY_SIZE（批处理-&gt；熵_u64）==0 |+next_gen batch-&gt；熵_u64）；批处理-&gt；位置=0；&gt；生成=next_gen ret批次-&gt；熵_u64[批次-&gt；位置++]-旋转解锁irqrestore（&amp；批次-&gt；批次锁定，标志）+本地\u解锁\u irqrestore（&amp；批处理\u熵\u u64.lock，标志）；return ret；}导出_符号（获取_随机_64）；静态定义每个CPU（结构批处理熵，批处理熵uu32）={-.batch_ulock=uu自旋锁u unlock（批处理熵32.lock），+.lock=INIT_局部锁（批处理熵32.lock）}；+u32 get_random_u32（void）{u32 ret；无符号长标志；结构批处理_熵*批处理；静态void*上一个；+int next_gen；warn_Unseedd _randomness（&amp；previous）；+局部_lock _irqsave（&amp；批处理_熵_锁定，标志）；批处理=原始_cpu _ptr（&amp；批处理_熵_u32）；-旋转_锁定_irqsave（&amp；批处理_锁定，标志）；-if（批-&gt；位置%ARRAY_SIZE（批-&gt；熵_u32）==0）{++next_gen=原子读取（&amp；批生成）；+if（批-&gt；位置%ARRAY_SIZE（批-&gt；熵_u32）==0 |+next_gen！=批生成）{extract_crng（（u8*）batch-&gt；熵_u32）；批-&gt；位置=0；&gt；批生成=next_gen ret；熵_u32[批次-&gt；位置++]-旋转解锁irqrestore（&amp；批次-&gt；批次锁定，标志）+本地\u解锁\u irqrestore（&amp；批处理\u熵\u u32.lock，标志）；返回ret；}导出符号（获取随机符号）；/*它&#39；重要的是，要使crng初始化之前可能*存储的所有潜在批处理熵无效，我们可以通过-*简单地将计数器重置为零，使其&#39；在-*下一次使用时重新提取。*/+*碰撞生成计数器。+*/静态void invalidate_batched_entropy（void）{-int-cpu；-无符号长标志；--对于每个可能的_cpu（cpu）{-struct batched_entropy*batched_entropy；--batched_entropy=per_cpu_ptr（&amp；batched_entropy_u32，cpu）；-自旋锁_irqsave（&amp；batched_entropy-&gt；batched_lock，flags）；-批量锁，标志）；-自旋锁（&amp；批量_熵-&gt；批量_锁）--批处理熵=每cpu（和批处理熵64，cpu）-自旋锁（批处理熵-&gt；批处理锁）-批量_熵-&gt；位置=0-spin_unlock_irqrestore（批处理熵-&gt；批处理锁，标志）-}+atomic_inc（&amp；batch_generation）；}/**diff——git a/kernel/printk/printk。cb/kernel/printk/printk。cindex 3bef5100312ea。。ea55bda735dce 100644---a/kernel/printk/printk。c++b/kernel/printk/printk。c@@@404,7+404,7@@@static atomic_t printk_direct=atomic_INIT（0）；/**printk_direct_enter-导致控制台打印在-*printk（）调用者+*printk（）调用者的上下文中发生**这会全局影响所有printk（）调用者。*@-2451,7+2451,9@@static ssize_t msg_print_ext_body（char*buf，size_t size，static void console_lock_spinning_enable（void）{}static int console_lock_spinning_disable_and_check（void）{返回0；}静态无效调用_控制台_驱动程序（结构控制台*con，const char*text，大小_tlen，-char*删除的_文本，bool原子_打印）{}+char*删除的_文本，bool原子_打印）+{++}静态bool抑制_消息_打印（int级别）{return false}静态void printk_delay（int level）{}静态void start_printk_kthread（struct console*con）{}@@@2878,7+2880,7@@static void write_console_seq（struct console*con，u64 val，bool atomic_printing*console_EXT_LOG_MAX.否则@EXT_text必须为空。**如果应该打印丢弃的消息，@drop_text是一个大小为的缓冲区-*drop_text_MAX.其他@drop_text_MAX.否则@drop_text必须为空。**@atomic_printing指定是否使用原子打印。）应使用ing。*@@-3873,6+3875,7@@static void start_printk_kthread（结构控制台*con）*/#define printk_PENDING_WAKEUP 0x01#define printk_PENDING_OUTPUT 0x02+#define printk_DIRECT_OUTPUT 0x04 static define_PER_CPU（int，printk_PENDING）；@-3881,9+3884,15@@static void wake_up_klogd_work_func（struct irq_work*irq_work）int pending=u this_cpu_xchg（printk_pending，0）；if（pending&amp；PRINTK_pending_OUTPUT）{+if（pending&amp；PRINTK_DIRECT_OUTPUT）+PRINTK_DIRECT_enter（）；+/*如果trylock失败，其他人正在打印*/if（console_trylock（））console_unlock（）；+if（pending&PRINTK_DIRECT_OUTPUT）+PRINTK_DIRECT_exit（）}if（pending&PRINTK_PENDIN</p><p>[档案索引][RT Stable][Kernel Newbies][IDE][Security][Git][Netfilter][Bugtraq][Yosemite][Yosemite News][MIPS Linux][ARM Linux][Linux Security][Linux RAID][Linux ATA RAID][Samba][Video 4 Linux][Device Mapper]</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/已知/">#已知</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/void/">#void</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>