<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Performance TypeScript的提示Tips for Performant TypeScript</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Tips for Performant TypeScript<br/>Performance TypeScript的提示</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-24 23:58:21</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/4b7d9ecba1881eda1176c27aaa7da297.png"><img src="http://img2.diglog.com/img/2020/11/4b7d9ecba1881eda1176c27aaa7da297.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>There are easy ways to configure TypeScript to ensure faster compilations and editing experiences.The earlier on these practices are adopted, the better.Beyond best-practices, there are some common techniques for investigating slow compilations/editing experiences, some common fixes, and some common ways of helping the TypeScript team investigate the issues as a last resort.</p><p>配置TypeScript的方法很简单，以确保更快的编译和编辑体验。采用这些实践的越早越好。除最佳实践之外，还有一些调查缓慢的编译/编辑体验的通用技术，一些常见的修复程序以及一些协助TypeScript团队调查问题的常用方法。</p><p>    Much of the time, a simple type alias to an object type acts very similarly to an interface.</p><p>    在大多数情况下，对象类型的简单类型别名的行为与接口非常相似。</p><p>  However, interfaces typically have better properties in type display, and as soon as you need to compose two types, interfaces create a single flat object type that detects property conflicts.This is in contrast with intersection types, where every constituent is checked before checking against the effective type.Type relationships between interfaces are also cached, as opposed to intersection types.</p><p>  但是，接口通常在类型显示中具有更好的属性，并且一旦需要组合两种类型，接口就会创建一个单一的平面对象类型来检测属性冲突，这与交集类型相反，交集类型在检查每个组成部分之前先进行检查与交集类型相反，接口之间的类型关系也将被缓存。</p><p> - type Foo = Bar &amp; Baz &amp; {  - someProp: string;  - }  + interface Foo extends Bar, Baz {  + someProp: string;  + }</p><p> -输入Foo = Bar＆Baz和{-someProp：string; -} +接口Foo扩展了Bar，Baz {+ someProp：string; +}</p><p>  Adding type annotations, especially return types, can save the compiler a lot of work.In part, this is because named types tend to be more compact than anonymous types (which the compiler might infer), which reduces the amount of time spend reading and writing declaration files (e.g. for incremental builds).Type inference is very convenient, so there&#39;s no need to do this universally - however, it can be a useful thing to try if you&#39;ve identified a slow section of your code.</p><p>  添加类型注释，特别是返回类型可以节省编译器大量的工作，部分原因是命名类型比匿名类型（编译器可能会推断出）更紧凑，从而减少了花在阅读和阅读上的时间。编写声明文件（例如，用于增量构建）。类型推断非常方便，因此不需要通用进行此操作-但是，如果您确定了代码的慢速部分，则可以尝试这样做。</p><p> - import { otherFunc } from &#34;other&#34;;  + import { otherFunc, otherType } from &#34;other&#34;;  - export function func() {  + export function func(): otherType { return otherFunc(); }</p><p> -从“其他”导入{otherFunc}； +从“其他”导入{otherFunc，otherType}; -导出函数func（）{+导出函数func（）：otherType {return otherFunc（）; }</p><p>  Union types are great - they let you express the range of possible values for a type.</p><p>  联合类型很棒-它们使您可以表达类型的可能值的范围。</p><p> interface  WeekdaySchedule  {  day:  &#34;Monday&#34; |  &#34;Tuesday&#34; |  &#34;Wednesday&#34; |  &#34;Thursday&#34; |  &#34;Friday&#34; ;  wake:  Time ;  startWork:  Time ;  endWork:  Time ;  sleep:  Time ; } interface  WeekendSchedule  {  day:  &#34;Saturday&#34; |  &#34;Sunday&#34; ;  wake:  Time ;  familyMeal:  Time ;  sleep:  Time ; } declare  function  printSchedule ( schedule:  WeekdaySchedule |  WeekendSchedule ) ;</p><p>界面WeekdaySchedule {day：“ Monday” | “星期二” | “星期三” | “星期四” | “星期五”；唤醒：时间； startWork：时间； endWork：时间；睡觉时间 ; }接口WeekendSchedule {day：“ Saturday” | “周日”；唤醒：时间； familyMeal：时间；睡觉时间 ; }声明函数printSchedule（进度：WeekdaySchedule | WeekendSchedule）；</p><p> However, they also come with a cost.Every time an argument is passed to  printSchedule, it has to be compared to each element of the union.For a two-element union, this is trivial and inexpensive.However, if your union has more than a dozen elements, it can cause real problems in compilation speed.For instance, to eliminate redundant members from a union, the elements have to be compared pairwise, which is quadratic.This sort of check might occur when intersecting large unions, where intersecting over each union member can result in enormous types that then need to be reduced.One way to avoid this is to use subtypes, rather than unions.</p><p> 但是，它们也要付出代价，每次将参数传递给printSchedule时，都必须将其与并集的每个元素进行比较。对于两元素联合，这是微不足道且便宜的，但是，如果您的并集有更多多于十个元素，可能会导致编译速度上的实际问题。例如，要从某个联合中消除冗余成员，必须成对比较这些元素，这是二次的。当与大型联合相交时，这种检查可能会发生每个工会成员上的过度使用可能会导致需要减少大量类型。避免这种情况的一种方法是使用子类型，而不是工会。</p><p> interface  Schedule  {  day:  &#34;Monday&#34; |  &#34;Tuesday&#34; |  &#34;Wednesday&#34; |  &#34;Thursday&#34; |  &#34;Friday&#34; |  &#34;Saturday&#34; |  &#34;Sunday&#34; ;  wake:  Time ;  sleep:  Time ; } interface  WeekdaySchedule  extends  Schedule  {  day:  &#34;Monday&#34; |  &#34;Tuesday&#34; |  &#34;Wednesday&#34; |  &#34;Thursday&#34; |  &#34;Friday&#34; ;  startWork:  Time ;  endWork:  Time ; } interface  WeekendSchedule  extends  Schedule  {  day:  &#34;Saturday&#34; |  &#34;Sunday&#34; ;  familyMeal:  Time ; } declare  function  printSchedule ( schedule:  Schedule ) ;</p><p> 界面Schedule {day：“ Monday” | “星期二” | “星期三” | “星期四” | “星期五” | “星期六” | “周日”；唤醒：时间；睡觉时间 ; }接口WeekdaySchedule扩展了Schedule {day：“ Monday” | “星期二” | “星期三” | “星期四” | “星期五”； startWork：时间； endWork：时间； }接口WeekendSchedule扩展了Schedule {day：“ Saturday” | “周日”； familyMeal：时间； }声明函数printSchedule（schedule：Schedule）;</p><p> A more realistic example of this might come up when trying to model every built-in DOM element type.In this case, it would be preferable to create a base  HtmlElement type with common members, which  DivElement,  ImgElement, etc. extend, rather than to create the exhaustive union  DivElement | /*...*/ | ImgElement | /*...*/.</p><p> 尝试对每种内置DOM元素类型进行建模时，可能会出现一个更现实的示例。在这种情况下，最好创建一个具有常见成员的基本HtmlElement类型，该类型由DivElement，ImgElement等扩展，而不是创建详尽的联盟DivElement | /*...*/ | ImgElement | /*...*/。</p><p>  When building up any codebase of a non-trivial size with TypeScript, it is helpful to organize the codebase into several independent  projects.Each project has its own  tsconfig.json that has dependencies on other projects.This can be helpful to avoid loading too many files in a single compilation, and also makes certain codebase layout strategies easier to put together.</p><p>  当使用TypeScript构建任何大小不小的代码库时，将代码库组织到几个独立的项目中会很有帮助。每个项目都有自己的tsconfig.json文件，该文件依赖于其他项目，这有助于避免加载过多项目文件在一次编译中，并且还使某些代码库布局策略更易于组合在一起。</p><p> There are some very basic ways of  breaking up a codebase into projects.As an example, one might be a program with a project for the client, a project for the server, and a project that&#39;s shared between the two.</p><p> 将代码库分解为项目有一些非常基本的方法，例如，一个程序可能包含一个客户端项目，一个服务器项目以及一个在两者之间共享的项目。</p><p> ------------ | | | Shared | ^----------^ / \ / \------------ ------------| | | || Client | | Server |-----^------ ------^-----</p><p> ------------ | | |共享| ^ ---------- ^ / \ / \ ------------ ------------ | | | ||客户| |服务器| ----- ^ ------ ------ ^ -----</p><p>  ------------ | | | Shared | ^-----^----^ / | \ / | \------------ ------------ ------------| | | Shared | | || Client | | Tests | | Server |-----^------ ------------ ------^----- | | | |------------ ------------| Client | | Server || Tests | | Tests |------------ ------------</p><p>------------ | | |共享| ^ ----- ^ ---- ^ / | \ / | \ ------------ ------------ ------------ || | |共享| | ||客户| |测试|服务器| ----- ^ ------ ------------ ------ ^ ----- | | | | ------------ ------------ ||客户| |服务器||测试|测试| ------------ ------------</p><p> One commonly asked question is &#34;how big should a project be?&#34;.This is a lot like asking &#34;how big should a function be?&#34; or &#34;how big should a class be?&#34; and, to a large extent, it comes down to experience.One familiar way of splitting up JS/TS code is with folders.As a heuristic, if things are related enough to go in the same folder, they belong in the same project.Beyond that, avoid massive or tiny projects.If one project is larger than all the others combined, that&#39;s a warning sign.Similarly, it&#39;s best to avoid having dozens of single-file projects because the overhead adds up.</p><p> 一个常见的问题是“一个项目应该有多大？”，这很像问“一个功能应该有多大？”。或“一个班级应该有多大？”文件夹中的JS / TS代码拆分是一种熟悉的方法，作为一种启发式方法，如果事物相关性足以放入同一文件夹中，则它们属于同一项目。除此之外，避免大型或小型项目。如果一个项目大于所有其他项目的总和，那是一个警告信号。类似地，最好避免拥有多个单文件项目，因为这会增加开销。</p><p>   TypeScript and JavaScript users can always configure their compilations with a  tsconfig.json file.  jsconfig.json files can also be used to configure the editing experience for JavaScript users.</p><p>   TypeScript和JavaScript用户始终可以使用tsconfig.json文件配置其编译。 jsconfig.json文件还可以用于配置JavaScript用户的编辑体验。</p><p>  You should always make sure that your configuration files aren&#39;t including too many files at once.</p><p>  您应该始终确保配置文件一次不包含太多文件。</p><p>   The primary difference between the two is that  files expects a list of file paths to source files, and  include/ exclude use globbing patterns to match against files.</p><p>   两者之间的主要区别在于，文件需要源文件的文件路径列表，并且包含/排除使用通配符模式来与文件匹配。</p><p> While specifying  files will allow TypeScript to quickly load up files up directly, it can be cumbersome if you have many files in your project without just a few top-level entry-points.Additionally, it&#39;s easy to forget to add new files to your  tsconfig.json, which means that you might end up with strange editor behavior where those new files are incorrectly analyzed.All this can be cumbersome.</p><p> 虽然指定文件将允许TypeScript快速直接直接加载文件，但是如果您的项目中有很多文件而没有几个顶级入口点，则可能会很麻烦。此外，很容易忘记将新文件添加到tsconfig中.json，这意味着您可能会以奇怪的编辑器行为结束，从而错误地分析了这些新文件。所有这些都可能很麻烦。</p><p> include/ exclude help avoid needing to specify these files, but at a cost: files must be discovered by walking through included directories.When running through a  lot of folders, this can slow compilations down.Additionally, sometimes a compilation will include lots of unnecessary  .d.ts files and test files, which can increase compilation time and memory overhead.Finally, while  exclude has some reasonable defaults, certain configurations like mono-repos mean that a &#34;heavy&#34; folders like  node_modules can still end up being included.</p><p> include / exclude有助于避免指定这些文件，但是要付出一定的代价：必须通过遍历包含的目录来发现文件。当运行许多文件夹时，这会减慢编译速度。此外，有时编译会包含很多不必要的内容.d.ts文件和测试文件，这可能会增加编译时间和内存开销。最后，尽管exclude具有一些合理的默认值，但某些配置（如mono-repos）意味着仍然可以包含“笨重”的文件夹（如node_modules）。</p><p>  Specify only input folders in your project (i.e. folders whose source code you want to include for compilation/analysis).</p><p>仅指定项目中的输入文件夹（即，要包含其源代码以进行编译/分析的文件夹）。</p><p>  If keeping tests in the same folder as other source files, give them a distinct name so they can easily be excluded.</p><p>  如果将测试与其他源文件放在同一文件夹中，请给它们起一个不同的名称，以便可以轻松将它们排除在外。</p><p> Note: without an  exclude list,  node_modules is excluded by default;as soon as one is added, it&#39;s important to explicitly add  node_modules to the list.</p><p> 注意：没有排除列表时，默认情况下将排除node_modules；添加一个时，将node_modules显式添加到列表中很重要。</p><p>    By default, TypeScript automatically includes every  @types package that it finds in your  node_modules folder, regardless of whether you import it.This is meant to make certain things &#34;just work&#34; when using Node.js, Jasmine, Mocha, Chai, etc. since these tools/packages aren&#39;t imported - they&#39;re just loaded into the global environment.</p><p>    默认情况下，TypeScript会自动包含在node_modules文件夹中找到的每个@types包，无论您是否导入它。这都是为了在使用Node.js，Jasmine，Mocha，Chai等时使某些事情“正常工作”。因为这些工具/软件包没有被导入-它们只是被加载到全局环境中。</p><p> Sometimes this logic can slow down program construction time in both compilation and editing scenarios, and it can even cause issues with multiple global packages with conflicting declarations, causing errors like</p><p> 有时，这种逻辑可能会减慢编译和编辑场景中的程序构建时间，甚至可能导致多个全局包的问题与声明冲突，从而导致诸如</p><p>  In cases where no global package is required, the fix is as easy as specifying an empty field for  the  &#34;types&#34; option in a  tsconfig.json/ jsconfig.json</p><p>  如果不需要全局包，则修复就像在tsconfig.json / jsconfig.json中为“ types”选项指定一个空字段一样容易</p><p> // src/tsconfig.json {  &#34;compilerOptions&#34;:  {  // ...  // Don&#39;t automatically include anything.  // Only include `@types` packages that we need to import.  &#34;types&#34; :  [ ]  } ,  &#34;files&#34;:  [ &#34;foo.ts&#34; ] }</p><p> // src / tsconfig.json {“ compilerOptions”：{// ... //不要自动包含任何内容。 //仅包含我们需要导入的`@ types`软件包。 “ types”：[]}，“ files”：[“ foo.ts”]}</p><p>  // tests/tsconfig.json {  &#34;compilerOptions&#34;:  {  // ...  // Only include `@types/node` and `@types/mocha`.  &#34;types&#34; :  [ &#34;node&#34; ,  &#34;mocha&#34; ]  } ,  &#34;files&#34;:  [ &#34;foo.test.ts&#34; ] }</p><p>// tests / tsconfig.json {“ compilerOptions”：{// ... //仅包含`@ types / node`和`@ types / mocha`。 “ types”：[“ node”，“ mocha”]}，“ files”：[“ foo.test.ts”]}</p><p>  The  --incremental flag allows TypeScript to save state from the last compilation to a  .tsbuildinfo file.This file is used to figure out the smallest set of files that might to be re-checked/re-emitted since it last ran, much like how TypeScript&#39;s  --watch mode works.</p><p>  --incremental标志允许TypeScript将上次编译的状态保存到.tsbuildinfo文件中。此文件用于确定自上次运行以来可能要重新检查/重新发射的最小文件集。 TypeScript的--watch模式如何工作。</p><p> Incremental compiles are enabled by default when using the  composite flag for project references, but can bring the same speed-ups for any project that opts in.</p><p> 在将Composite标志用于项目引用时，默认情况下启用增量编译，但是可以为选择加入的任何项目带来相同的加速。</p><p>  By default, TypeScript performs a full re-check of all  .d.ts files in a project to find issues and inconsistencies; however, this is typically unnecessary.Most of the time, the  .d.ts files are known to already work - the way that types extend each other was already verified once, and declarations that matter will be checked anyway.</p><p>  默认情况下，TypeScript对项目中的所有.d.ts文件进行完全重新检查，以发现问题和不一致之处；但是，通常这是不必要的。在大多数情况下，.d.ts文件已经可以工作-类型彼此之间的扩展方式已经过一次验证，并且无论如何都要检查声明。</p><p> TypeScript provides the option to skip type-checking of the  .d.ts files that it ships with (e.g.  lib.d.ts) using the  skipDefaultLibCheck flag.</p><p> 打字稿提供跳过.d.ts文件，它附带（例如lib.d.ts）使用skipDefaultLibCheck标志的类型检查的选项。</p><p> Alternatively, you can also enable the  skipLibCheck flag to skip checking  all  .d.ts files in a compilation.</p><p> 另外，您还可以启用skipLibCheck标志来跳过检查编译中的所有.d.ts文件。</p><p> These two options can often hide misconfiguration and conflicts in  .d.ts files, so we suggest using them  only for faster builds.</p><p> 这两个选项通常可以隐藏.d.ts文件中的错误配置和冲突，因此我们建议仅将它们用于更快的构建。</p><p>  Is a list of dogs a list of animals?That is, is  List&lt;Dog&gt; assignable to  List&lt;Animals&gt;?The straightforward way to find out is to do a structural comparison of the types, member by member.Unfortunately, this can be very expensive.However, if we know enough about  List&lt;T&gt;, we can reduce this assignability check to determining whether  Dog is assignable to  Animal (i.e. without considering each member of  List&lt;T&gt;).(In particular, we need to know the  variance of the type parameter  T.)The compiler can only take full advantage of this potential speedup if the  strictFunctionTypes flag is enabled (otherwise, it uses the slower, but more lenient, structural check).For this reason, we recommend building with  --strictFunctionTypes (which is enabled by default under  --strict).</p><p>狗列表是动物列表吗？即List 是否可分配给List 吗？找出方法的直接方法是逐个成员对类型进行结构比较。非常昂贵。但是，如果我们对List 的了解足够多，则可以减少此可分配性检查，以确定Dog是否可分配给Animal（即，无需考虑List 的每个成员）。（尤其是，我们需要知道如果启用了strictFunctionTypes标志（仅使用较慢但更宽松的结构检查），则编译器仅可以充分利用这种潜在的加速性能（因此，我们建议使用--strictFunctionTypes（默认在--strict下启用）。</p><p>  TypeScript compilation is often performed with other build tools in mind - especially when writing web apps that might involve a bundler.While we can only make suggestions for a few build tools, ideally these techniques can be generalized.</p><p>  TypeScript编译通常是在考虑其他构建工具的情况下进行的-尤其是在编写可能涉及捆绑程序的Web应用程序时。尽管我们只能对一些构建工具提出建议，但理想情况下可以将这些技术加以推广。</p><p> Make sure that in addition to reading this section, you read up about performance in your choice of build tool - for example:</p><p> 确保除了阅读本节之外，还要阅读有关选择的构建工具的性​​能的信息，例如：</p><p>   Type-checking typically requires information from other files, and can be relatively expensive compared to other steps like transforming/emitting code.Because type-checking can take a little bit longer, it can impact the inner development loop - in other words, you might experience a longer edit/compile/run cycle, and this might be frustrating.</p><p>   类型检查通常需要来自其他文件的信息，并且与诸如转换/发出代码等其他步骤相比可能会相对昂贵。由于类型检查可能会花费更长的时间，因此会影响内部开发循环-换句话说，您可能经历更长的编辑/编译/运行周期，这可能令人沮丧。</p><p> For this reason, some build tools can run type-checking in a separate process without blocking emit.While this means that invalid code can run before TypeScript reports an error in your build tool, you&#39;ll often see errors in your editor first, and you won&#39;t be blocked for as long from running working code.</p><p> 因此，某些构建工具可以在单独的进程中运行类型检查而不会阻止发射。虽然这意味着可以在TypeScript报告构建工具中的错误之前运行无效代码，但通常您会经常首先在编辑器中看到错误，并且只要运行代码，您就不会受到任何阻碍。</p><p> An example of this in action is the   fork-ts-checker-webpack-plugin plugin for Webpack, or  awesome-typescript-loader which also sometimes does this.</p><p> 一个实际的例子是Webpack的fork-ts-checker-webpack-plugin插件，或awesome-typescript-loader，有时也可以这样做。</p><p>  By default, TypeScript&#39;s emit requires semantic information that might not be local to a file.This is to understand how to emit features like  const enums and  namespaces.But needing to check  other files to generate the output for an arbitrary file can make emit slower.</p><p>  默认情况下，TypeScript的发射需要语义信息，这些信息可能不是文件本地的，这是为了了解如何发射诸如const枚举和命名空间之类的功能，但是需要检查其他文件以生成任意文件的输出会导致发射速度变慢。</p><p> The need for features that need non-local information is somewhat rare - regular  enums can be used in place of  const enums, and modules can be used instead of  namespaces.For that reason, TypeScript provides the  isolatedModules flag to error on features powered by non-local information.Enabling  isolatedModules means that your codebase is safe for tools that use TypeScript APIs like  transpileModule or alternative compilers like Babel.</p><p>对需要非本地信息的功能的需求很少见-可以使用常规枚举代替const枚举，并且可以使用模块代替命名空间。因此，TypeScript提供了isolatedModules标志来使由non-powered驱动的功能出错-local信息。启用isolatedModules意味着您的代码库对于使用TypeScript API的工具（例如transpileModule）或其他编译器（例如Babel）是安全的。</p><p> As an example, the following code won&#39;t properly work at runtime with isolated file transforms because  const enum values are expected to be inlined; but luckily,  isolatedModules will tell us that early on.</p><p> 例如，下面的代码无法在运行时与隔离的文件转换一起正常工作，因为期望内联const枚举值。但幸运的是，isolatedModules会在早期告诉我们。</p><p> // ./src/fileA.ts export  declare  const  enum  E  {  A  =  0 ,  B  =  1 , } // ./src/fileB.ts import  {  E  }  from  &#34;./fileA&#34; ; console . log ( E . A ) ; // ~ // error: Cannot access ambient const enums when the &#39;--isolatedModules&#39; flag is provided.</p><p> // ../src/fileA.ts export声明常量枚举E {A = 0，B = 1，} // ./src/fileB.ts import {E} from“ ./fileA”;安慰 。日志（E。A）; //〜//错误：提供'--isolatedModules'标志时，无法访问环境const枚举。</p><p> Remember:  isolatedModules doesn&#39;t automatically make code generation faster - it just tells you when you&#39;re about to use a feature that might not be supported.The thing you&#39;re looking for is isolated module emit in different build tools and APIs.</p><p> 请记住：isolatedModules不会自动使代码生成更快，它只是告诉您何时要使用可能不被支持的功能。您要寻找的是隔离的模块在不同的构建工具和API中发出。</p><p>  babel-loader compiles files in an isolated manner (but does not provide type-checking on its own).</p><p>  babel-loader以一种隔离的方式编译文件（但自身不提供类型检查）。</p><p>    Editor experiences can be impacted by plugins.Try disabling plugins (especially JavaScript/TypeScript-related plugins) to see if that fixes any issues in performance and responsiveness.</p><p>    插件会影响编辑器的使用体验。尝试禁用插件（尤其是与JavaScript / TypeScript相关的插件），看看是否可以解决性能和响应能力方面的任何问题。</p><p> Certain editors also have their own troubleshooting guides for performance, so consider reading up on them.For example, Visual Studio Code has its own page for  Performance Issues as well.</p><p> 某些编辑器也有自己的性能疑难解答指南，因此请仔细阅读它们。例如，Visual Studio Code也有自己的“性能问题”页面。</p><p>  You can run TypeScript with  --extendedDiagnostics to get a printout of where the compiler is spending its time.</p><p>您可以使用带有--extendedDiagnostics的TypeScript来获得编译器花费时间的打印输出。</p><p> Files: 6Lines: 24906Nodes: 112200Identifiers: 41097Symbols: 27972Types: 8298Memory used: 77984KAssignability cache size: 33123Identity cache size: 2Subtype cache size: 0I/O Read time: 0.01sParse time: 0.44sProgram time: 0.45sBind time: 0.21sCheck time: 1.07stransformTime time: 0.01scommentTime time: 0.00sI/O Write time: 0.00sprintTime time: 0.01sEmit time: 0.01sTotal time: 1.75s</p><p> 文件：6行：24906节点：112200标识符：41097符号：27972类型：8298使用的内存：77984KA可分配性缓存大小：33123身份缓存大小：2子类型缓存大小：0I / O读取时间：0.01s解析时间：0.44s编程时间：0.45s绑定时间：0.21s检查时间：1.07 stransformTime时间：0.01scomment时间时间：0.00s I / O写入时间：0.00sprint时间时间：0.01s发射时间：0.01s总时间：1.75s</p><p> Note that  Total time won&#39;t be the sum of all times preceding it, since there is some overlap and some work is not instrumented.</p><p> 请注意，“总时间”将不是它之前所有时间的总和，因为存在一些重叠且未检测到某些工作。</p><p>  the number of files that the program is including (use  --listFiles to see what they are).</p><p>  程序包含的文件数（使用--listFiles查看它们是什么）。</p><p>   combined time spent performing reading from the file system, scanning and parsing the program, and other calculation of the program graph. These steps are intermingled and combined here because files need to be resolved and loaded once they&#39;re included via  imports and  exports.</p><p>   从文件系统读取，扫描和解析程序以及对程序图进行其他计算所花费的总时间。这些步骤在此处混合并合并在一起，因为一旦通过导入和导出将它们包含进来，就需要解析和加载文件。</p><p>   Time spent rewriting TypeScript ASTs (trees that represent source files) into forms that work in older runtimes.</p><p>   将TypeScript AST（代表源文件的树）重写为在较旧的运行时中可以使用的形式所花费的时间。</p><p>   Time spent calculating the string representation of an output file and emitting it to disk.</p><p>   计算输出文件的字符串表示形式并将其发送到磁盘所花费的时间。</p><p>  Does the number of files/number of lines of code roughly correspond to the number of files in your project? Try running  --listFiles if not.</p><p>文件数/代码行数是否大致与项目中的文件数相对应？如果没有，请尝试运行--listFiles。</p><p> Does  Program time or  I/O Read time seem fairly high?  Ensure your  include/ exclude settings are configured correctly.</p><p> 编程时间或I / O读取时间看起来是否很高？确保正确配置了包含/排除设置。</p><p> Do other times seem off?  You might want to file an issue! Things you can do to help diagnose it might be</p><p> 其他时间似乎不对吗？您可能要提出问题！您可以做的有助于诊断的事情可能是</p><p>  It&#39;s not always obvious what settings a compilation is being run with when running  tsc, especially given that  tsconfig.jsons can extend other configuration files. showConfig can explain what  tsc will calculate for an invocation.</p><p>  运行tsc时，运行编译所用的设置并不总是很明显，尤其是考虑到tsconfig.jsons可以扩展其他配置文件时。 showConfig可以解释tsc将为调用计算的内容。</p><p>   Running with  traceResolution can help explain  why a file was included in a compilation.The emit is somewhat verbose, so you might want to redirect output to a file.</p><p>   使用traceResolution运行可以帮助解释为什么文件包含在编译中。emit有点冗长，因此您可能需要将输出重定向到文件。</p><p>  If you find a file that shouldn&#39;t be present, you may need to look into fixing up your  include/ exclude lists in your  tsconfig.json, or alternatively, you might need to adjust other settings like  types,  typeRoots, or  paths.</p><p>  如果找到不应该存在的文件，则可能需要研究修复tsconfig.json中的包含/排除列表，或者，可能需要调整其他设置，如类型，typeRoots或路径。</p><p>  Much of the time, users run into slow performance using 3rd party build tools like Gulp, Rollup, Webpack, etc.Running with  tsc --extendedDiagnostics to find major discrepancies between using TypeScript and the tool can indicate external misconfiguration or inefficiencies.</p><p>  很多时候，用户会使用Gulp，Rollup，Webpack等第三方构建工具来降低性能，而与tsc --extendedDiagnostics一起运行以发现使用TypeScript和该工具之间的主要差异可能表明外部配置错误或效率低下。</p><p>  Is there a major difference in build times between  tsc and the build tool with TypeScript integration?</p><p>tsc和具有TypeScript集成的构建工具之间的构建时间是否存在重大差异？</p><p> If the build tool provides diagnostics, is there a difference between TypeScript&#39;s resolution and the build tool&#39;s?</p><p> 如果构建工具提供了诊断信息，TypeScript的分辨率与构建工具的分辨率之间是否有区别？</p><p>  Does the build tool have configuration  for its TypeScript integration that could be the cause? (e.g. options for ts-loader?)</p><p>  生成工具是否具有可能与其TypeScript集成有关的配置？ （例如ts-loader的选项？）</p><p>  Sometimes TypeScript&#39;s type-checking can be impacted by computationally intensive  .d.ts files.This is rare, but can happen.Upgrading to a newer version of TypeScript (which can be more efficient) or to a newer version of an  @types package (which may have reverted a regression) can often solve the issue.</p><p>  有时TypeScript的类型检查可能会受到计算量大的.d.ts文件的影响，这种情况很少见，但可能会发生。可能已经还原了回归）通常可以解决问题。</p><p>  Once you&#39;ve trouble-shooted, you might want to explore some fixes to common issues.If the following solutions don&#39;t work, it may be worth  filing an issue.</p><p>  故障排除后，您可能想探索一些常见问题的解决方法。如果以下解决方案不起作用，则值得提出问题。</p><p>     If your project is already properly and optimally configured, you may want to  file an issue.</p><p>     如果您的项目已经正确配置并达到最佳配置，则可能要提出问题。</p><p> The best reports of performance issues contain  easily obtainable and  minimal reproductions of the problem.In other words, a codebase that can easily be cloned over git that contains only a few files.They require either no external integration with build tools - they can either be invoked via  tsc or use isolated code which consumes the TypeScript API.Codebases that require complex invocations and setups cannot be prioritized.</p><p> 性能问题的最佳报告包含问题的容易获得和最小程度的重现。换句话说，可以轻松地通过仅包含几个文件的git克隆代码库，它们不需要与构建工具进行外部集成-它们可以是通过tsc调用或使用使用TypeScript API的隔离代码。需要对复杂的调用和设置进行编码的代码库无法确定优先级。</p><p> We understand that this is not always easy to achieve - specifically, because it is hard to isolate the source of a problem within a codebase, and because sharing intellectual property may be an issue.In some cases, the team will be willing to send a non-disclosure agreement (NDA) if we believe the issue is highly impactful.</p><p>我们知道这并不总是容易实现的-特别是因为很难在代码库中隔离问题的根源，并且因为共享知识产权可能是一个问题。在某些情况下，团队将愿意发送保密协议（NDA），如果我们认为此问题影响重大。</p><p> Regardless of whether a reproduction is possible, following these directions when filing issues will help us provide you with performance fixes.</p><p> 无论是否可以复制，在提交问题时遵循以下说明将有助于我们为您提供性能修复。</p><p>  Sometimes you&#39;ll witness performance issues in both build times as well as editing scenarios.In these cases, it&#39;s best to focus on the TypeScript compiler.</p><p>  有时，您会在构建时间和编辑场景中看到性能问题。在这种情况下，最好专注于TypeScript编译器。</p><p> First, a nightly version of TypeScript should be used to ensure you&#39;re not hitting a resolved issue:</p><p> 首先，应该使用每晚版本的TypeScript来确保您没有遇到已解决的问题：</p><p>   The version of TypeScript that was installed (i.e.  npx tsc -v or  yarn tsc -v)</p><p>   已安装的TypeScript版本（即npx tsc -v或yarn tsc -v）</p><p>  It is important to provide the team with diagnostic traces by running Node.js v10+ with the  --trace-ic flag alongside TypeScript with the  --generateCpuProfile flag:</p><p>  重要的是，通过运行带有--trace-ic标志的Node.js v10 +和带有--generateCpuProfile标志的TypeScript，为团队提供诊断跟踪：</p><p>  Here  ./node_modules/typescript/lib/tsc.js can be replaced with any path to where your version of the TypeScript compiler is installed, and  tsconfig.json can be any TypeScript configuration file. profile.cpuprofile is an output file of your choice.</p><p>  在这里./node_modules/typescript/lib/tsc.js可以替换为安装TypeScript编译器版本的任何路径，并且tsconfig.json可以是任何TypeScript配置文件。 profile.cpuprofile是您选择的输出文件。</p><p>  --generateCpuProfile will emit to a file with the name of your choice. In the above example, it will be a file named  profile.cpuprofile.</p><p>--generateCpuProfile将发射到具有您选择的名称的文件。在上面的示例中，它将是一个名为profile.cpuprofile的文件。</p><p> ⚠ Warning: These files may include information from your workspace, including file paths and source code.Both of these files are readable as plain-text, and you can modify them before attaching them as part of a GitHub issue. (e.g. to scrub them of file paths that may expose internal-only information).</p><p> ⚠警告：这些文件可能包含工作空间中的信息，包括文件路径和源代码。这两个文件都可以以纯文本格式读取，并且可以在将它们作为GitHub问题的一部分附加之前对其进行修改。 （例如，为它们清除可能暴露仅供内部使用的信息的文件路径）。</p><p> However, if you have any concerns about posting these publicly on GitHub, let us know and you can share the details privately.</p><p> 但是，如果您有关于在GitHub上公开发布这些内容的任何疑问，请告诉我们，您可以私下共享详细信息。</p><p>  Perceived editing performance is frequently impacted by a number of things, and the only thing within the TypeScript team&#39;s control is the performance of the JavaScript/TypeScript language service, as well as the integration between that language service and certain editors (i.e. Visual Studio, Visual Studio Code, Visual Studio for Mac, and Sublime Text).Ensure that all 3rd-party plugins are turned off in your editor to determine whether there is an issue with TypeScript itself.</p><p>  感知的编辑性能通常受许多因素影响，并且TypeScript团队控制范围内的唯一事情是JavaScript / TypeScript语言服务的性能以及该语言服务与某些编辑器（例如Visual Studio，Visual Studio Studio代码，Visual Studio for Mac和Sublime Text）。确保在编辑器中关闭所有第3方插件，以确定TypeScript本身是否存在问题。</p><p> Editing performance issues are slightly more involved, but the same ideas apply: clone-able minimal repro codebases are ideal, and though in some cases the team will be able to sign an NDA to investigate and isolate issues.</p><p> 涉及性能问题的编辑稍微多一点，但是同样的想法也适用：可克隆的最小repro代码库是理想的，尽管在某些情况下，该团队将能够签署NDA来调查和隔离问题。</p><p> Including the output from  tsc --extendedDiag</p><p> 包括tsc --extendedDiag的输出</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/microsoft/TypeScript/wiki/Performance">https://github.com/microsoft/TypeScript/wiki/Performance</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>