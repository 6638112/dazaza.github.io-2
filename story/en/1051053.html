<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用FFMPEG模拟CRT监视器（PT.1：彩色CRT） Simulating CRT Monitors with FFmpeg (Pt. 1: Color CRTs)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Simulating CRT Monitors with FFmpeg (Pt. 1: Color CRTs)<br/>使用FFMPEG模拟CRT监视器（PT.1：彩色CRT） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-07 11:57:27</div><div class="page_narrow text-break page_content"><p>This is just a fun little experiment which I&#39;ve been tinkering with here and there lately.  You won&#39;t get much serious use out of this, even if we pretend that there  is such a thing as &#34;serious use&#34; for simulating CRT monitors.  That&#39;s mostly due to the speed of doing this all on the CPU.</p><p>这只是一个有趣的小实验，我＆＃39; ve在这里滋补了这里，最近有。你赢了＆＃39;如果我们假装有这样的东西，那么＆＃34是＆＃34;严肃的使用和＃34;用于模拟CRT监视器。那个＆＃39;主要是由于在CPU上做到这一切的速度。</p><p> I&#39;m not kidding about &#34;slow&#34; - if you actually want to apply this to a video of more than a few seconds, in good quality, prepare to be outpaced by a glacier running a marathon through molasses.  Of course, there are a ton of shaders for use in your favorite emulator which do it on the GPU in real-time, but I don&#39;t know of a decent way to just apply them to a stand-alone image or video file without tearing your hair out.</p><p> 我不是在开玩笑＆＃34;慢＆＃34; - 如果您实际上希望将其应用于超过几秒钟的视频，以优良的质量，请准备好通过糖蜜运行马拉松的冰川。当然，有一大吨着色器，用于你最喜欢的仿真器，实时在GPU上做到这一点，但我不知道只需将它们应用于独立形象或视频的方式文件而不撕毁你的发发。</p><p> (FFmpeg can also be told to use the GPU, but not for everything - also, its GPU acceleration isn&#39;t portable and doesn&#39;t seem to make things very much faster, anyway.  If you know of a way around these shortcomings, that&#39;d be nice to know.)</p><p> （FFMPEG也可以被告知使用GPU，但不是所有东西 - 也是它的GPU加速ISN＆＃39; T便携和＃39;无论如何，似乎更快地制造了东西。如果你知道某种方式这些缺点，那个＆＃39; d很高兴知道。）</p><p> This script (a Windows batch file only, at least for now) will let you perform a CRT transform on an image or a video of the original-resolution material.  You can get it at   https://github.com/viler-int10h/FFmpeg-CRT-transform,which includes everything you&#39;ll need, except for FFmpeg itself of course.</p><p> 此脚本（仅适用于Windows批处理文件）将允许您在图像或原始分辨率素材的视频上执行CRT变换。您可以在https://github.com/viler-int10h/ffmpeg-crt-transform中获取它，其中包含您的所有内容和＃39;除了FFMPEG本身之外还有所需的一切。</p><p> The Youtube video sample will show you the effect in motion, but here are a few still-image results at a higher resolution:</p><p> YouTube视频示例将向您展示运动的效果，但这里有一些静止图像结果较高的分辨率：</p><p>   Other than the files included above, you&#39;ll only need to have ffmpeg.exe/ffprobe.exe in your PATH.  There&#39;s one batch file  for still images and another for video which handles both still images and videos; to invoke, just run:</p><p>   除了上面包含的文件之外，您＆＃39; ll只需要在路径中有ffmpeg.exe / ffprobe.exe。 ＆＃39;仍然是静止图像的批量文件，另一个用于播放静止图像和视频的视频;要调用，刚刚运行：</p><p>   If the output filename is omitted, the script will use the same name as the input appended with &#34;_OUT&#34;.</p><p>   如果省略了输出文件名，则脚本将使用与附加的输入相同的名称和＃34; _out＆＃34; </p><p> You&#39;ll see some temporary files being created during the run ( &#34;TMP*&#34;), but unless something goes wrong, the script cleans up after itself when it&#39;s done; in fact all files starting with &#34;TMP&#34; in the current directory will be deleted, so try not to have any.  If FFmpeg returns an error at any point, the script aborts without deleting the temp files, since they may help with debugging.</p><p>您＆＃39; ll查看在运行期间正在创建的一些临时文件（＆＃34; tmp *＆＃34;除非出现问题，除非出现问题，脚本在它所完成后自身清除;事实上所有文件都以＆＃34开头; TMP＆＃34;在当前目录中将被删除，所以尽量不要有任何。如果ffmpeg在任何时候返回错误，则脚本中止而不删除临时文件，因为它们可能会帮助调试。</p><p> For video, keep this in mind: the output will  always be in the RGB colorspace / pixel format, because these scripts assume RGB input and attempt to preserve the color information.  Specifically, the exact FFmpeg parameters are  -c:v libx264rgb -crf 8 (all intermediate steps use  -crf 0 for their temporary files, to keep things lossless).</p><p> 对于视频，请记住这一点：输出将始终处于RGB颜色空间/像素格式，因为这些脚本采用RGB输入并尝试保留颜色信息。具体而言，精确的FFMPEG参数是-c：v libx264rgb -crf 8（所有中间步骤用于其临时文件的-crf 0，以防止无损）。</p><p> For better compatibility with editing apps, and better color reproduction on video sharing and streaming services, you might want to convert the result to a YUV color space yourself.  More info on how to do this  optimally will come in a future post.</p><p> 为了更好地与编辑应用程序兼容，以及在视频共享和流式服务上的更好的色彩再现，您可能希望自己转换成yuv颜色空间。更多信息如何最佳地完成此操作将在未来的帖子中。</p><p>  The  configFile argument specifies the configuration file, which is where you tune the simulation options: scaling, shadow-mask parameters, pixel blur, halation (the diffuse glow caused by scattering/reflection effects), scanline profile, beam bloom (where brighter pixels make the scanline appear wider), surface curvature (convexity), corner radius, and vignette (the darkening towards the edges of the CRT surface).</p><p>  CONFIGFILE参数指定配置文件，该配置文件是调整模拟选项的位置：缩放，阴影屏蔽参数，像素模糊，光晕（由散射/反射效果引起的漫反射发光），扫描线轮廓，梁绽放（其中更明亮的像素扫描线看起来更宽），表面曲率（凸起），角半径和小插图（朝向CRT表面的边缘变暗）。</p><p> All these elements characterize the normal output of a functional tube display -- I tried to stay away from &#34;aesthetic revisionism&#34;, so you won&#39;t find things like noise, chromatic aberration, ghosting, fake flicker/beam trail, sync errors and other &#39;glitch&#39; visuals.  If you like such things, FFmpeg can pull them off quite well, so you can always have a go at adding to the script.</p><p> 所有这些元素都表征了功能管显示的正常输出 - 我试图远离＆＃34;审美修正主义＆＃34;所以你赢了＆＃39; t找到噪音，色差，重影，假闪烁等东西。梁径，同步错误和其他＆＃39;毛刺＆＃39;视觉效果。如果您喜欢这样的事情，FFMPEG可以很好地将它们拉出，因此您可以随时添加到脚本。</p><p> The download includes a few config files to start you out.  Here&#39;s one so you can get a feel for what you can tweak:</p><p> 下载包含一些配置文件以启动您。在这里，＆＃39;＆s一个，所以你可以感受到你可以调整的内容：</p><p> ; FFmpeg CRT script config file (comments start with a semicolon); This example is intended for low-res VGA input which has already been double-; scanned (such as DOSBox produces with machine=vgaonly), e.g. 640x400.; For 1:1 input (e.g. 320x200), double the values for SX and SY, and set; SCAN_FACTOR to double.; Input pre-scaling + aspect ratio adjustment: --------------------------------SX 5 ; Width scale factor (integer)SY 6 ; Height scale factor (integer) ; Larger factors = slower processing, better quality; Final output scaling: -------------------------------------------------------OY 1080 ; Output height (width will be set to height*4/3)OMARGIN 8 ; Minimum width of included margins (edge padding)OFILTER lanczos ; Output scaling filter; recommended: &#39;lanczos&#39; for ; triad shadowmask, &#39;gauss&#39; for slot/grille (reduces ; moire) ; See FFmpeg Scaler Options for all available values; Simulation settings: --------------------------------------------------------OVL_TYPE triad ; Shadow mask (phosphor overlay) type, e.g. triad, ; slot, grille. &#34;_ .png&#34; must exist.OVL_SCALE 0.08 ; Scale factor for shadow mask imageOVL_ALPHA 0.6 ; Shadow mask opacity (0..1)OVL_BRIGHTFIX 2.05 ; Brightness multiplier applied after color overlay - ; compensates for apparent darkeningH_PX_BLUR 50 ; Horizontal pixel blur factor (% of pixel width)V_PX_BLUR 12 ; Vertical pixel blur factor (% of pixel height) - ; should generally be 0 if scanlines are enabledHALATION_ON no ; Add halation?HALATION_RADIUS 30 ; - radiusHALATION_ALPHA 0.12 ; - opacity (0..1)SCANLINES_ON yes ; Add scanlines?SL_ALPHA 0.8 ; - opacity (0..1)SL_WEIGHT 1 ; 0..1 for a slimmer beam, &gt;1 for a fatter beamSCAN_FACTOR single ; Ratio of scanline count to input height: &#39;single&#39;, ; &#39;double&#39;, or &#39;half&#39;BLOOM_ON yes ; Add scanline bloom? (widens brighter scanlines)BLOOM_POWER 0.65 ; - bloom factor: 0 (none) .. 1 (full) ; more noticeable for smaller scanline weightsCORNER_RADIUS 0 ; Radius of rounded bezel corners; 0 to disableCURVATURE 0.04 ; CRT curvature (barrel distortion); 0 to disableVIGNETTE_ON yes ; Add vignette effect? (darkens image towards edge)VIGNETTE_POWER 0.1 ; - amount of darkening; Video only - no effect on still images: -------------------------------------P_DECAY_FACTOR 0 ; Phosphor decay factor (0..1) - exponential: &lt;0.9 is ; very mild, 0.95=heavy, 0.99=very long, 1.0=infiniteP_DECAY_ALPHA 0.5 ; - opacity (0..1) - 0.3 to 0.5 seem realistic</p><p> ; ffmpeg crt脚本配置文件（注释以分号开始）;这个例子适用于已经两倍的低分辨率VGA输入;扫描（如Dosbox通过机器= VGAONLY生产），例如： 640x400;为1：1输入（例如320x200），为SX和SY的值加倍，并设置; scan_factor to double .;输入预缩放+纵横比调整：------------------------------- SX 5;宽度尺度因子（整数）SY 6;高度比例因子（整数）;较大的因素=加工较慢，质量更好;最终输出缩放：------------------------------------------------------------------------------------------------------------------------------------ --------- OY 1080;输出高度（宽度将设置为高度* 4/3）Omargin 8;包括边距的最小宽度（边缘填充）OFILTER LANCZOS;输出缩放滤波器;推荐：＆＃39; lanczos＆＃39;为了 ; Triad Shadowmask，＆＃39;高斯＆＃39;对于槽/格栅（减少;莫尔）;有关所有可用值，请参阅FFMPEG Scarer选项;仿真设置：-------------------------------------- --------- OVL_TYPE三合会;荫罩（磷光体覆盖层）类型，例如三合一，;插槽，格栅。 ＆＃34; _ .png＆＃34;必须存在.ovl_scale 0.08;暗影掩模的规模因子imageovl_alpha 0.6;暗影掩模不透明度（0..1）OVL_BRIGHTFIX 2.05;亮度倍增器在彩色叠加后应用 - ;补偿明显的黑暗_px_blur 50;水平像素模糊因子（像素宽度的百分比）V_PX_BLUR 12;垂直像素模糊因子（像素高度的百分比） - ;如果Scanlines是EnableDhalation_ON NO，通常应该是0;加入下晕？HALATION_RADIUS 30; -  radiushalation_alpha 0.12; - 不透明度（0..1）ScanLines_on是的;添加扫描线？SL_ALPHA 0.8; - 不透明度（0..1）SL_weight 1; 0..1对于纤维梁，＆gt; 1用于静止的beamscan_factor单身;扫描线数与输入高度的比率：＆＃39;单＆＃39;; ＆＃39;双倍＆＃39;，或＆＃39;半＆＃39; bloom_on是的;添加Scanline Bloom？ （扩大较大的扫描线）Bloom_Power 0.65; - 绽放因素：0（无）.. 1（满）;对于较小的扫描线重量_Radius 0更加明显;圆形边框角落的半径; 0以禁用0.04; CRT曲率（桶形变形）; 0到disablevignette_on是的;添加小插图效果？ （使图像变为边缘）Vignette_Power 0.1; - 变暗量;仅限视频 - 对静止图像没有影响：-------------------------------- P_Decay_Factor 0;磷衰减因子（0..1） - 指数：＆lt; 0.9是;非常温和，0.95 =重，0.99 =很长，1.0 = Infinitep_decay_alpha 0.5; - 不透明度（0..1） -  0.3到0.5似乎逼真 </p><p>  I won&#39;t go into what every single line in the batch file is doing (if you look at it, you&#39;ll understand why), but the general flow is this:</p><p>我赢了＆＃39; t进入批处理文件中的每一行正在做什么（如果你看它，你＆＃39; ll明白原因），但一般流程是这样的：</p><p> Setup: Make sure there&#39;s nothing funny with the command line arguments, get the input dimensions (using ffprobe), read config settings.</p><p> 设置：确保在命令行参数中确保没有搞笑，获取输入尺寸（使用ffprobe），阅读配置设置。</p><p> Rounded corners, if enabled: Draw a quarter-circle (using FFmpeg&#39;s   geq filter), scale it down to the desired size (CORNER_RADIUS) w/anti-aliasing, rotate it four ways; create a blank canvas of the same dimensions as the  scaled input, and place the results in the corners.  Apply the   lenscorrection filter with the desired CRT curvature factor (CURVATURE).  The result is a temporary image that will function as a transparent layer, except for the four corners.  You may wonder why we&#39;re already applying the curvature here, when we could just do it in a single pass later, when the layers have already been combined.  That will be answered below, but for now we&#39;re just putting this layer aside for later.</p><p> 圆角，如果启用：绘制四分之一圆圈（使用FFMPEG＆＃39; S GEQ滤波器），将其缩放到所需的尺寸（Corner_Radius）与抗锯齿，四种方式旋转;创建与缩放输入相同尺寸的空白画布，并将结果放在角落中。使用所需的CRT曲率因子（曲率）涂抹透镜粗校滤波器。结果是临时图像，其将用作透明层，除了四个角落。您可能想知道为什么我们已经在这里应用了曲率，当我们稍后可以在单一的通过时，当已经组合时，我们可以在一次通过。这将在下面得到解答，但现在我们＆＃39;重新将这本层放在一边。</p><p> Scanlines, if enabled: Create a greyscale vertical profile of a single scanline, again with the  geq filter: luminance is determined by a sine function (using SL_WEIGHT as a modifier), and height depends on the scaled input dimensions and the SCAN_FACTOR parameter.  This is   tiledvertically to get an alpha map of the scanlines.  Now we add curvature to this image as well - but this time, we pre-scale it by 4x before  lenscorrection, and scale it back down afterwards.  This is necessary because FFmpeg&#39;s lens correction does nearest-neighbor interpolation, and with hi-frequency detail (such as these scanlines),  this creates awful moiré patterns. The 4x oversampling gets around that, but operations at that size cary extreme CPU/RAM expenses, and THAT&#39;s why we separate the curvature passes: we want to do moiré mitigation  only for still-image layers, and  only when strictly necessary.</p><p> 扫描线，如果启用：创建单个扫描线的灰度垂直配置文件，再次使用GEQ过滤器：亮度由正弦函数（使用SL_PEIGHT作为修饰符）确定，高度取决于缩放的输入维度和SCAN_Factor参数。这是为了获得扫描线的alpha地图。现在我们也向该图像添加了曲率 - 但是这次，我们在镜头粗校之前将其预先放置4倍，然后将其放在后面。这是必要的，因为ffmpeg＆＃39; s镜头校正是最近的邻居插值，并且使用高频细节（例如这些扫描线），这会产生可怕的莫尔图模式。 4倍过采样遍及这一点，但该大小的运营是Cary Extreme CPU / RAM费用，以及为什么我们分开曲率通过：我们只想为静止图像层进行莫尔氏缓解，只有在严格必要时。</p><p> Shadowmask: The image of the phosphor overlay is taken from the respective .png file, scaled down by the specified OVL_SCALE factor (w/gamma correction before and after!), then tiled and cropped to fill the &#39;screen&#39;.  This also gets the anti-moiré curvature treatment with 4x oversampling, and is saved as a temporary image.</p><p> ShadowMask：荧光体覆盖的图像从相应的.png文件中取出，由指定的OVL_Scale因子（之前和之后的W / Gamma校正）缩小，然后铺平并裁剪以填充＆＃39;屏幕＆＃39; 。这也使抗Moiré曲率处理有4x过采样，并被保存为临时图像。</p><p> Phosphor decay (video only): If the P_DECAY_FACTOR is nonzero, take the input video and simulate phosphor persistence as an additional stage  before it gets upscaled.  For this we use the   lagfunfilter, with the decay factor as the parameter, and blend the result back with the original using P_DECAY_ALPHA as the opacity factor.</p><p> 磷衰减（仅限视频）：如果p_decay_factor是非零，请将输入视频拍摄，并将磷光体持久性模拟在其上升之前。为此，我们使用LagfunFilter，将衰减因子作为参数，并使用P_Decay_Alpha作为不透明度因子将结果与原始结果融为一。</p><p> Input scaling + pixel blur: Take the original resolution input image (or video - with or without phosphor decay), and upscale it by the configured width/height factors (SX/SY) to get an aspect-corrected version at a much higher resolution: this resolution will be used for all intermediate steps. Then, apply a gaussian pixel blur (  gblur)using the configured PX_BLUR factors, but not before applying a 2.2 gamma transform using   lutrgb,to ensure a  gamma-aware application of the blur effect.</p><p> 输入缩放+像素模糊：拍摄原始分辨率输入图像（或有视频 - 或没有磷光体衰减），并通过配置的宽度/高度因子（SX / SY）高度升级，以获得更高的分辨率：此分辨率将用于所有中间步骤。然后，使用配置的PX_BLUR因子应用高斯像素模糊（GBLUR），但在使用LUTRGB应用2.2伽马变换之前，以确保伽马意识到模糊效果的应用。 </p><p> Halation, if enabled: Split the output of the previous step into two streams; blur one of them even more (using HALATION_RADIUS), to simulate the diffuse glow caused by slight scatter/backscatter of the electron beam and the phosphor light; then mix that with the other unmodified stream (using the   blendfilter in &#39;lighten&#39; mode, with the opacity factor specified by HALATION_ALPHA).</p><p>晕机，如果启用：将上一步的输出分成两个流;将其中一个（使用HALate_radius）模拟，模拟电子束和荧光灯的轻微散射/反向散射引起的漫反射辉光;然后将其与其他未修改的流混合（使用＆＃39中的Blendfilter; Lighen＆＃39;模式，具有Halation_alpha指定的不透明度因子）。</p><p> Surface curvature, if enabled: Now that we&#39;re done with the gamma-senstive blur steps, apply the inverse (0.454545) gamma transform to our image/video; then feed it to the  lenscorrection filter to get the convex effect, this time without the 4x pre-scaling, since moiré is not a real issue here, and oversampling the actual video would be crazy slow anyway.</p><p> 表面曲率，如果启用：现在我们＆＃39;用伽玛长期模糊步骤完成，将逆（0.454545）伽马变换应用于我们的图像/视频;然后将其喂给透镜粗校过滤器以获取凸起效果，这次没有4x预缩放，因为莫尔之神在这里不是真正的问题，并且过采样实际视频就是疯狂慢。</p><p> Beam bloom, if enabled: Create a greyscale version of the previous stage&#39;s output (image/video), so we preserve only the luminance information.  This is done with the   huefilter by setting saturation to 0 - once again using gamma transform before and after.  Now we blend this with the mask of the already-curved scanlines, which we had put aside before, using a custom  geq blending formula to &#34;fatten&#34; the scanline according to the brightness in the greyscale stream we&#39;ve just created.  The result is a video/image stream containing the luminance mask for the scanlines, with &#39;beam bloom&#39; included.</p><p> 梁绽放，如果启用：创建前一级的灰度版本和＃39; S输出（图像/视频），因此我们只保留亮度信息。通过将饱和度设置为0  - 再次使用Gamma Transform在之前和之后再次使用Huefilter完成。现在我们将其与已经曲线的掩码混合在一起，我们之前放在一边，使用自定义Geq混合公式到＆＃34; fatten＆＃34;根据灰度流中的亮度，扫描线。刚刚创造了ve＆＃39;刚刚创造了。结果是包含横向掩模的亮度掩模的视频/图像流，＆＃39;梁绽放＆＃39;包括。</p><p> Blend everything together: Take the image/video which we&#39;ve already scaled up, blurred, halated, and curved; if bleam bloom was enabled - do a &#39;multiple&#39; blend with the result of the previous stage, to add the scanlines with the bloom baked in; if it wasn&#39;t, just do the same with the original scanline mask we made previously.  The SL_ALPHA parameter determines the opacity.  (If scanlines are disabled, do none of the above.)  Then... take the curved-up shadowmask image, do another &#39;multiple&#39; blend (with opacity set by OVL_ALPHA), and add the one with the rounded corners while we&#39;re at it.  Because the scanlines and shadowmask darken the picture quite a bit, we now compensate by multiplying each color channel with the OVL_BRIGHTFIX parameter (clipping the result to 255).</p><p> 混合所有的东西：拍摄我们＆＃39; ve已经缩放，模糊，降临和弯曲的图像/视频;如果启用了Bleam Bloom  -  Do A＆＃39;多个＆＃39;与前一级的结果混合，将扫描线添加到盛开的盛开;如果它不是我们以前做过的原始扫描线面罩也是如此。 SL_ALPHA参数确定不透明度。 （如果禁用Scanlines，则不执行以上。）然后...拍摄曲线遮蔽镜像，做另一个＆＃39;多个＆＃39;融合（ovl_alpha设置的不透明度），并在我们＆＃39;重新上时用圆角添加一个。因为扫描线和ShadowMask使图像变暗了一点，所以我们现在通过将每个颜色通道与OVL_BrightFix参数乘以（将结果削减到255）来补偿。</p><p> Crop to contents: The surface curvature distortion has introduced some superfluous padding around the picture area, so this part uses the   cropdetectfilter to find the dimensions of the actual content, without the extra fluff.  For this, we generate a &#34;dummy&#34; frame with nothing but white, put it through the same distortion, and feed it to the filter (3 times, since that&#39;s the minimum number of frames it needs for a reliable result).  The dummy approach beats examining the actual video, because (1) it&#39;s much faster, and (2) if your video starts with a black frame - or just with any black whatsoever extending to the edge - it&#39;d be worse than useless.</p><p> 作物到内容：表面曲率失真在图像区域周围引入了一些多余的填充，因此该部分使用CropdetectFilter找到实际内容的尺寸，而无需额外的绒毛。为此，我们生成一个＆＃34;假人＆＃34;框架无需白色，使其通过相同的失真，并将其馈送到过滤器（3次，因为它需要可靠结果所需的最小帧数）。虚拟方法击败检查实际视频，因为（1）它＆＃39; s更快，（2）如果您的视频以黑色框架开始 - 或者只是任何黑色，无论是延伸到边缘 - 它＆＃39; d比无用更糟糕。</p><p> Final scaling + vignette: After cropping, the image/video is scaled down to the final desired size while preserving a 4:3 aspect ratio.  This scaling step is  also gamma-corrected, and if you&#39;ve specified a nonzero OMARGIN, it&#39;ll leave room for that.  The scaling filter itself is specified in the configuration (OFILTER) - see   Scaler Optionsfor the list supported by FFmpeg.  All we have to do now is to set the Storage Aspect Ratio (  setsar)to 1:1, since the previous steps have likely mucked it up; apply   vignettefor the edge-darkening effect (using the VIGNETTE_POWER parameter); and pad with the afore-mentioned margins if applicable.</p><p> 最终缩放+ Vignette：裁剪后，图像/视频按照保留4：3宽高比缩小到最终所需尺寸。这种缩放步骤也是伽马纠正的，如果你指定了一个非零汤，它＆＃39; ll离开空间。缩放滤波器本身在配置（OFILTER）中指定 - 请参阅FFMPEG支持的列表中的Scarer选项。我们现在必须做的就是将存储宽高比（SETERAR）设置为1：1，因为前一步可能会击密它;将Vignettefor应用于边缘变暗效果（使用Vignette_Power参数）;如果适用，垫与上述边距。</p><p> If you haven&#39;t expired of natural causes yet, and your CPU hasn&#39;t melted, you will now have the final result!  Was it worth it? - you tell me.  And if you can figure out a way to speed up the process, or to make it more efficient without losing the essentials, or to get the GPU to put in some   real effort, that&#39;d be cool too.</p><p> 如果你还没有到期自然原因，你的CPU Hasn＆＃39; t融化了，你现在有最后的结果！它值得吗？ - 你告诉我。如果你能弄清楚加速这个过程的方法，或者在没有失去必需品的情况下使其更有效，或者让GPU放在一些真正的努力中，那也很酷。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://int10h.org/blog/2021/01/simulating-crt-monitors-ffmpeg-pt-1-color/">https://int10h.org/blog/2021/01/simulating-crt-monitors-ffmpeg-pt-1-color/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/crt/">#crt</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>