<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>兰姆达微积分的乐趣</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">兰姆达微积分的乐趣</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-19 20:31:27</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/e2b8bc38276bc158265a5470ba58d117.png"><img src="http://img2.diglog.com/img/2020/10/e2b8bc38276bc158265a5470ba58d117.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>1935年，一位名叫阿隆佐·丘奇的绅士想出了一个可以计算…的简单方案。几乎什么都行。他的方案被称为兰姆达微积分(Lambda Calculus)。这是一项非凡的创新，因为他甚至没有电脑来测试他的想法。更酷的是，这些想法在今天影响着我们：任何时候你使用一个函数，你都应该向丘奇先生致敬。</p><p>Lambda演算是如此酷，以至于许多黑客将其用作秘密握手--如果你愿意的话，这是一个“谨慎的信号”。当然，最著名的是PG的Y组合器。在这篇文章中，我们将找出它的全部内容，并用我们从未想象过的功能来做一些事情。最后，您将构建几乎所有的编程概念：数字、布尔值，您可以将其命名为…。只需使用函数即可。</p><p>开SUV的城市居民很少认为他们的汽车是穿越多岩石的沙漠和洪水泛滥的河流的凶猛机器。程序员和函数也是如此。下面是我们认为函数的作用：</p><p>安全、干净、有用。我们已经习以为常了，如果我们发现我们可以用无数种方法来弯曲函数来做任何事情，那会让我们大吃一惊。</p><p>让我们到荒野里走一走吧。假设您想为Pair创建一个数据结构：</p><p>你会怎么做呢？使用地图、类或记录来表示一对是明智的。但是…。您也可以使用函数。</p><p>现在我们的前搭档接受一个选择器参数。如果我们用这个选择器运行前任配对会怎么样：</p><p>这正好给我们带来了我们这双鞋的第一个价值！我们可以用它来编写教堂优先函数：</p><p>我们只是用函数来表示对。现在，由于Lisp的语法只是一堆组合在一起的对，这也意味着我们可以表示Lisp…的语法。功能齐全！</p><p>我们刚才所做的类似于一个城市居民驾驶他们的越野车…。在一个下雪的日子里。它变得更疯狂了。</p><p>这就是我们能做的。让我们取一个我们熟悉和喜爱的函数，并在Lambda演算中自上而下地实现它。</p><p>在本文结束时，我们将只使用函数构建阶乘。</p><p>为了做到这一点，我想走到前面说我有一点作弊。在丘奇的Lambda演算中，没有定义，所有函数都有一个参数。以下是他所说的：</p><p>在他的规则中，您通过在前面弹出一个小λ来定义匿名函数。下面是参数，后面跟着一个。.在..之后。是应用程序。</p><p>这非常类似于clojure中的单参数匿名函数：λx.x=&gt；(fn[x]x)。</p><p>我们可以遵循这些规则，但是像那样编写阶乘将很难很快得到推理。让我们稍微调整一下规则。这些更改不会影响Lambda演算的本质，但会使我们更容易考虑代码。它是这样的：</p><p>1)对于单参数函数，(fn[x]x)很好地映射到Church的编码。我们可以继续按原样使用它。</p><p>2)由于Church的lambdas只接受一个参数，要用两个参数表示一个函数，他必须编写两个匿名函数：</p><p>但是，在Clojure 1中，像这样嵌套我们的函数可能会很烦人。为了让我们的工作更轻松，我们将允许使用多参数函数：</p><p>3)最后，除了函数定义提供的变量之外，Church没有变量的概念。</p><p>为了使我们的代码保持正常，我们将允许def，但有一条规则：</p><p>您可以使用def，只要您可以用匿名函数“替换”它并且没有中断。</p><p>这将中断，因为如果我们替换(定义Make-Pair…)。使用匿名函数，将不再有名为Make-Pair的变量！</p><p>就是这样，这是我们的规矩。有了这些，我们就可以做阶乘了！</p><p>我们首先需要的是数字的概念。我们怎么能做到这一点呢？</p><p>丘奇想到了一个很酷的主意。如果是“Numbers”，其中高阶函数有两个参数：函数f和值v，情况会怎样呢？</p><p>(def零(fn[f v]v))(def one(fn[f v](f(零f v)(def Two(fn[f v](f(One F V)。</p><p>我们可以通过“计数”f被合成的次数来计算出每个函数代表的数字。</p><p>例如，0将合成f的次数为零：它只返回v。1，将合成f一次：(Fv)。2将组成两次：(F(f，v))，依此类推。</p><p>为了帮助我们在REPL中查看这些数字，让我们创建一个快速转换器函数：</p><p>因为教堂数字由它被调用的次数组成，其中v是第一个参数，所以我们需要知道它在Clojure中是什么数字，只需提供Inc作为f，提供0作为v！例如，现在2将做(Inc(Inc0))，并为我们获得相应的Clojure编号。</p><p>我们在这里做的是委托f组成前面的数字(在本例中是1)，然后再调用f一次。</p><p>瞧啊。给这个函数一个数字，它将返回一个新的数字，并再次调用f。我们刚刚发现了Inc.！</p><p>现在我们有了这个函数，我们还可以编写一个快速帮助器将Clojure数字转换为这些数字：</p><p>接下来，我们需要一种方法来“递减”一个数字。嗯，使用Inc，我们再一次创建一个组成f的数字。如果我们能少做一次组成f的函数，那么我们就有了dec！</p><p>还记得我们的配对数据结构吗？让我们为它创建一个函数(我们稍后会用到这个函数)：Shift-and-Inc。它所要做的就是取一对数字，并将这对数字“前移”一位：</p><p>例如，对(0 1)应用Shift-and-Inc将生成(1 2)。再一次，它将产生(2 3)，依此类推。</p><p>班姆，我们拿一双。第二件物品被移到第一个位置，并被它的刻痕朋友取代。让我们试试看：</p><p>(设[p(Shift-and-Inc(教堂对一二))](映射教堂数字-&gt；int[(教堂第一个p)(教堂第二个p)]))；=&gt；(23)。</p><p>请记住，我们的教堂数字将调用Shift-and-Inc N次，表示其数值。如果我们从一个对(0，0)开始，那么如果我们将Shift-and-Inc.组合N次，那么结果b会是什么呢？</p><p>我们的结果将是对(N-1，N)。这意味着如果我们把我们对的第一部分取走，我们就有了12月！</p><p>接下来是乘法。假设我们用a乘以b，我们需要产生一个教会数字，组成f，a*b次。要做到这一点，我们可以利用以下想法：</p><p>假设我们做了一个函数g，它组成了f，b次。如果我们把这个函数提供给a，它会调用g，a次。</p><p>如果a是“2”，“b”是3，f会合成几次？嗯，g会组成两次。每次合成g，就合成f 3次。一共出了6次！</p><p>我们有数字，我们有*，我们有12月。Next Up…。布尔人！</p><p>他们接受一个“真”案和一个“假”案。我们的chorge-true函数将返回true case，而chocket-false函数将返回false case。</p><p>就这样。令人惊讶的是，这足以处理布尔值。下面是我们如何将它们转换为Clojure bools。</p><p>我们的教堂-true将返回第一个参数(True)，而我们的教堂-false将返回第二个参数！</p><p>他们看起来眼熟吗？这就是我们教会第一和教会第二的选择器功能！如果我们愿意，我们可以互换它们，😮。</p><p>如果你和我一样，你对那些布尔人有点怀疑。让我们好好利用它们，平息我们的恐惧吧。下面是如何创建If结构的方法：</p><p>我们要做的所有事情就是简单地将事物打乱，并向我们的布尔值提供When-True和When-False的情况！Church-true将返回When-True大小写，而Church-False将返回When-False大小写。</p><p>我们几乎拥有实现阶乘所需的所有构造。少了一块：零块？我们需要一种方法来判断数字何时为零。</p><p>如果一个数字大于零，则会调用f，这会将v替换为chocket-false。否则，我们将返回v的初始值，教堂为真。</p><p>嗯，我们有数字，我们有如果，我们有零？我们有*，我们有12月。我们可以这样翻译：</p><p>(def阶乘-V0(Fn[教会数字-n](教会-IF(教会-零？教堂数字-n)(fn[]one)(fn[](教堂-*教堂数字-n(阶乘-v0(教堂-十二月教堂-数字-n)。</p><p>唯一奇怪的是，我们将WHEN-TRUE和WHEN-FALSE案例包装在一个匿名函数中。这是因为我们的教会IF与Clojure的IF略有不同。Clojure的IF只评估WHEN-TRUE和WHEN-FALSE案例中的一个。我们的方法对这两种情况都求值，这会触发无限递归。我们通过将两种情况都包装在一个lambda中来避免这一点，这会“延迟”我们的评估。2个</p><p>好的，差不多了。我们作弊了。记住我们的规则3：如果我们用匿名函数替换变量，一切都应该正常工作。如果我们将阶乘-V0编写为匿名函数，会发生什么情况？</p><p>(fn[教堂-数字-n]((教堂-IF(教堂-零？教堂数字-n)(fn[]one)(fn[](教堂-*教堂数字-n；：&lt；：&lt；呃oh(factorial-v0(教堂-12月教堂-数字-n)。</p><p>这里有一种我们可以解决的方法。我们可以更新这一点，这样阶乘就可以作为参数提供给它自己。</p><p>(Fn[阶乘-Cb](Fn[教会数字-n])((教会-IF(教会-零？教堂数字-n)(fn[]one)(fn[](教堂-*教堂数字-n(factorial-cb(教堂-12月教堂-数字-n)？)。</p><p>那是可行的，但我们只是把问题轻描淡写。他妈的会怎么做？是吗？我们需要某种方式将阶乘的引用传递给它本身！</p><p>让我们看看我们能不能把这件事办好。首先，让我们编写阶乘，它接受自身的某种“可注入”版本：</p><p>(def可注射-阶乘(Fn[阶乘-Cb](Fn[教会数字-n])((教会-IF(教会-零？教堂数字-n)(fn[]one)(fn[](教堂-*教堂数字-n(阶乘-cb(教堂-十二月教堂-数字-n)。</p><p>好的，我们现在所做的就是将问题转移到这个Make-Recursable函数😅中。请耐心听我说。</p><p>让我们想象一下解决方案需要看起来是什么样子。我们希望使用某个阶乘cb函数调用injectable-f来处理“下一次调用”。</p><p>这似乎是对的。请注意注释递归处理程序。这是针对此表单的：</p><p>如果我们以某种方式访问此表单，我们可以在？！中使用它。好吧，让我们把这个问题再说一遍：</p><p>在这里，我们将递归处理程序包装到一个函数中。如果它能自己复制一份，我们就大功告成了。但这意味着我们又回到了同样的问题上：我们如何才能给递归处理程序一个自身的副本呢？这里有一个想法：</p><p>(def make-recursable(fn[Injectable-f]((fn[递归处理程序](递归处理程序递归处理程序)(fn[递归处理程序](Injectable-f(Fn[Next-Arg]((递归处理程序递归处理程序)Next-Arg)。</p><p>这将最终产生一个具有阶乘CB的新阶乘函数。然后我们就用Next-Arg来称呼它，让派对继续进行下去！</p><p>这个Make-Recursable函数也称为Y组合器。你可能听说过很多关于它的事情，这个例子可能很难效仿。如果你想了解更多，我推荐吉姆的主题演讲。</p><p>哇，我们做到了。我们刚刚编写了阶乘，所有我们使用的都是匿名函数。为了证明这一点，让我们删除一些规则。下面是我们的代码在没有任何变量定义的情况下将如何结束：</p><p>(教堂-数字-&gt；Int(Fn[Injectable-f]((Fn[递归处理程序](递归处理程序递归处理程序)(Fn[递归处理程序](Injectable-f(Injectable-f(Fn[Next-Arg]((递归处理程序递归处理程序)Next-Arg)(Fn[阶乘-Cb](Fn[教堂数字-n](Fn[教堂布尔When-true When-False](教堂布尔When-True-False)。TRUE WHEN-FALSE))((FN[教堂编号](教堂编号(FN[v](Fn[WHEN-TRUE WHEN-FALSE]WHEN-FALSE]WHEN-FALSE))(FN[WHEN-TRUE WHEN-FALSE]WHEN-TRUE)教堂编号-n)(FN[](Fn[](Fn[f v](f((Fn[f v]v)f v)(Fn[]((Fn。[num-a num-b](fn[fv](num-a(部分num-bf)v))教堂数字-n(阶乘-cb((fn[教堂数字]((fn[a b]a)(教堂数字(fn[对](fn[b]a))((fn[b]((fn[a b](fn[选择器](选择器a b)(fn[对。](Pair(Fn[a b]b))Pair)((Fn[教堂数字](Fn[f v](f(教堂数字f v)((Fn[Pair](Pair(Fn[a b]b)((Fn[a b](Fn[选择器](选择器a b)(Fn[f]v)(fn[f]v)(fn[f]。V)教堂编号-n)((fn[教堂编号](fn[f v](f(教堂编号f v)((fn[教堂编号](fn[f v](f(教堂编号f v)((fn[教堂编号](fn[f v](f(教堂编号f v)(fn。[fv](f((fn[fv](f((fn[fv]v)fv)。</p><p>我们刚刚把我们的任务带过了莫哈韦沙漠！我们制作了数字、布尔值、算术和递归…。全部来自匿名函数。希望你玩得开心！如果您想查看完整的代码，请查看GH回购。</p><p>我将带着一些Clojure宏观乐趣离开。当用匿名函数“替换”所有Deff的时候，我们是如何做到的呢？</p><p>在较弱的语言中，我们可能需要手动复制粘贴3。在LISP中，我们可以使用宏。</p><p>首先，让我们重写def。此版本将每个def的源代码“存储”为元数据：</p><p>(def宏def#&#34；`def`周围的轻型包装，用于跟踪此let的每个定义的_source code_后面的us_unwork_all定义：&gt；&#34；[name v]`(do(def~name~v)(alt-meta！(var~name)assoc：source{：name&#39；~name：v&#39；~v})(var~name))。</p><p>然后，我们可以创建一个展开函数，该函数递归地将所有def符号替换为其对应的源代码：</p><p>(Defn Expand&#34；this采用类似于(chorge-numeral-&gt；int(factorial-yc(int-&gt；chetch-numeral 5)的形式，并展开所有函数定义，让我们直观地看到我们的lambda演算方法会是什么样子！&#34；[form](cond(Symbol？Form)(if-let[source(ome-&&gt;；(str*ns*&34；/&#34；form)符号find-var meta：source)](展开(：v source))form)(序号？表单)(地图展开表单)：ELSE表单))</p><p>感谢Alex Reichert，Daniel Woelfel，Sean Grove，Irakli Safareli，Alex Kotliarskyi，Davit Magaltadze，Joe Averbukh审阅本文草稿</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://stopa.io/post/263">https://stopa.io/post/263</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/微积分/">#微积分</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lambda/">#lambda</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>