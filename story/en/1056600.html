<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>BEVY 0.5：数据导向游戏引擎内置锈 Bevy 0.5: data oriented game engine built in Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Bevy 0.5: data oriented game engine built in Rust<br/>BEVY 0.5：数据导向游戏引擎内置锈 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-07 04:13:28</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/48db8eb787e01587afbae8abe49292fa.png"><img src="http://img2.diglog.com/img/2021/4/48db8eb787e01587afbae8abe49292fa.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Thanks to  88 contributors,  283 pull requests, and our   generous sponsors, I&#39;m happy to announce the  Bevy 0.5 release on  crates.io!</p><p>由于88个贡献者，283次拉出请求，以及我们慷慨的赞助商，我很高兴宣布封口的BEVY 0.5释放！</p><p> For those who don&#39;t know, Bevy is a refreshingly simple data-driven game engine built in Rust. You can check out  Quick Start Guide to get started. Bevy is also free and open source forever! You can grab the full  source code on GitHub.</p><p> 对于那些不知道的人来说，Bevy是一款令人耳目无驰的简单数据驱动的游戏引擎。您可以查看快速入门指南即可开始。 Bevy也是免费和开放的源！您可以在GitHub上获取完整的源代码。</p><p> Bevy 0.5 is quite a bit bigger than our past few releases (and took a bit longer) as we have made a number of foundational changes. If you plan on updating your App or Plugin to  Bevy 0.5, check out our  0.4 to 0.5 Migration Guide.</p><p> Bevy 0.5比我们过去的释放（并花费了一些更长），因为我们制作了许多基础变化。如果计划将应用程序或插件更新为Bevy 0.5，请查看我们的0.4到0.5迁移指南。</p><p>     Bevy now uses PBR shaders when rendering. PBR is a semi-standard approach to rendering that attempts to use approximations of real-world &#34;physically based&#34; lighting and material properties. We largely use techniques from the  Filament PBR implementation, but we also incorporate some ideas from  Unreal and  Disney.</p><p>     BEVY现在在渲染时使用PBR着色器。 PBR是一种半标准方法，渲染试图使用现实世界＆＃34的近似;物理基于＆＃34;照明和材料特性。我们在很大程度上利用来自灯丝PBR实施的技术，但我们还从不真实和迪士尼融合了一些想法。</p><p> Bevy&#39;s  StandardMaterial now has  base_color,  roughness,  metallic,  reflection, and  emissive properties. It also now supports textures for  base_color,  normal_map,  metallic_roughness,  emissive, and  occlusion properties.</p><p> BEVY＆＃39; SDARDITEDMATERIAL现在具有Base_COLOR，粗糙度，金属，反射和发光性。它现在还支持Base_color，Normal_map，Metallic_roughness，发射和遮挡属性的纹理。</p><p>      The GLTF loader now supports normal maps, metallic/roughness, occlusion, and emissive textures. Our &#34;flight helmet&#34; gltf example utilizes the new PBR texture support and looks much nicer as a result:</p><p>      GLTF装载机现在支持正常地图，金属/粗糙度，遮挡和发光纹理。我们的＆＃34;飞行头盔＆＃34; GLTF示例利用新的PBR纹理支持，结果如此：</p><p>    Previously it was hard to interact with GLTF assets because scenes / meshes / textures / and materials were only loaded as &#34;sub assets&#34;. Thanks to the new top level   Gltf asset type, it is now possible to navigate the contents of the GLTF asset:</p><p>    以前，很难与GLTF资产互动，因为场景/网格/纹理/和材料仅加载为＆＃34;子资产＆＃34;由于新的顶级GLTF资产类型，现在可以导航GLTF资产的内容： </p><p> // load GLTF asset on startup fn  setup ( mut  commands :  Commands,  assets :  Res &lt; AssetServer &gt;) {  let  handle  =  assets . load (&#34; flight_helmet.gltf &#34;);  commands . insert_resource ( handle );} // access GLTF asset at some later point in time fn  system ( handle :  Res &lt; Handle &lt; Gltf &gt;&gt; ,  gltfs :  Res &lt; Assets &lt; Gltf &gt;&gt; ,  materials :  Res &lt; Assets &lt; StandardMaterial &gt;&gt;) {  let  gltf  =  gltfs . get (&amp; handle ). unwrap ();  let  material_handle  =  gltf . named_materials . get (&#34; MetalPartsMat &#34;). unwrap ();  let  material  =  materials . get ( material_handle ). unwrap ();}</p><p>//在启动时加载gltf资产fn setup（mut命令：命令，资产：res＆lt; assetserver＆gt;）{让掌握=资产。加载（＆＃34; flight_helmet.gltf＆＃34;）;命令。 INSERT_RESOURCE（手柄）;} //在时间稍后的时间点（手柄：res＆lt; gltf＆gt;，gltfs：res＆lt; gltfs＆lt;，GLTF资产，GLTF资产访问GLTF资产res＆lt; squarymaterial＆gt;＆gt;）{令gltf = gltfs。获得（＆amp; handle）。 unwrap（）;让matering_handle = gltf。 named_materials。得到（＆＃34; Metalpartsmat＆＃34;）。 unwrap（）;让材料=材料。得到（Material_Handle）。 unwrap（）;}</p><p>  This release marks a huge step forward for Bevy&#39;s ECS. It has significant implications for how Bevy Apps are composed and how well they perform:</p><p>  此版本标志着Bevy＆＃39; ECS的巨大一步。它对Bevy应用程序的组成以及它们的执行程度有重大影响：</p><p>     Up until this point, Bevy used a heavily forked version of  hecs for our ECS core. Since Bevy&#39;s first release, we&#39;ve learned a lot about Bevy&#39;s ECS needs. We&#39;ve also collaborated with other ECS project leaders, such as  Sander Mertens (lead  flecs developer) and  Gijs-Jan Roelofs (Xenonauts ECS framework developer). As an &#34;ECS community&#34;, we&#39;ve started to zero in on what the future of ECS could be.</p><p>     直到这一点，bevy为我们的ECS核心使用了一系列重叉的HEC。自从Bevy＆＃39;第一个发布，我们学到了很多关于Bevy＆＃39; ECS的需求。我们还与其他ECS项目领导者合作，如桑德·佩佩斯（Lead Flecs Developer）和Gijs-Jan Roelofs（Xenonauts ECS框架开发商）。作为一个＆＃34; ECS社区＆＃34;，我们＆＃39; Ve开始归零ECS的未来。</p><p> Bevy ECS v2 is our first step into that future. It also means that Bevy ECS is no longer a &#34;hecs fork&#34;. We are going out on our own!</p><p> Bevy ECS V2是我们进入该未来的第一步。这也意味着BEVY ECS不再是A＆＃34; HECS FORK＆＃34;我们自己出去了！</p><p>   Archetypal ECS: Stores components in &#34;tables&#34; with static schemas. Each &#34;column&#34; stores components of a given type. Each &#34;row&#34; is an entity.</p><p>   原型ECS：存储＆＃34的组件;表＆＃34;使用静态模式。每个＆＃34;列＆＃34;存储给定类型的组件。每个＆＃34;行＆＃34;是一个实体。</p><p>   Comes at the cost of more expensive add/remove operations for an Entity&#39;s components, because all components need to be copied to the new archetype&#39;s &#34;table&#34;</p><p>   为实体和＃39; S组件的更昂贵的添加/删除操作提供的成本，因为所有组件都需要复制到新的原型＆＃39; s＆＃34;表＆＃34;</p><p> Parallelism-friendly: entities only exist in one archetype at a time so systems that access the same components but in different archetypes can run in parallel</p><p> 友好友好：实体只在一个原型中存在，因此访问相同组件但在不同的原型中可以并行运行 </p><p> Sparse Set ECS: Stores components of the same type in densely packed arrays, which are sparsely indexed by densely packed unsigned integers (entity ids)</p><p>稀疏设置ECS：在密集包装阵列中存储相同类型的组件，这些组件由密集包装的无符号整数（实体ID）稀疏地索引</p><p> Query iteration is slower than Archetypal ECS (by default) because each entity&#39;s component could be at any position in the sparse set. This &#34;random access&#34; pattern isn&#39;t cache friendly. Additionally, there is an extra layer of indirection because you must first map the entity id to an index in the component array.</p><p> 查询迭代比原型ECS慢（默认情况下）慢，因为每个实体＆＃39; S组件可以处于稀疏集中的任何位置。这个＆＃34;随机访问＆＃34;模式isn＆＃39; t缓存友好。此外，有一个额外的间接层，因为您必须首先将实体ID映射到组件数组中的索引。</p><p>  &#34;Component Packs&#34; are used to optimize iteration performance on a case by case basis (but packs conflict with each other)</p><p>  ＆＃34;组件包＆＃34;用于通过案例的基础来优化迭代性能（但包装彼此冲突）</p><p> Less parallelism friendly: systems need to either lock a whole component storage (not granular) or individual entities (expensive)</p><p> 不太平行友好：系统需要锁定整个组件存储（不粒状）或单个实体（昂贵）</p><p> Developers selecting an ECS framework are stuck with a hard choice. Select an &#34;archetypal&#34; framework with &#34;fast iteration everywhere&#34; but without the ability to cheaply add/remove components, or select a &#34;sparse set&#34; framework to cheaply add/remove components but with slower iteration performance or manual (and conflicting) pack optimizations.</p><p> 选择ECS框架的开发人员被困难了。选择一个＆＃34; archetypal＆＃34; ＆＃34的框架;到处快速迭代＆＃34;但没有能力廉价添加/删除组件，或选择A＆＃34;稀疏集合＆＃34;框架可廉价地添加/删除组件，但具有较慢的迭代性能或手动（和冲突）Pack优化。</p><p>  In Bevy ECS V2, we get to have our cake and eat it too. It now has  both of the component storage types above (and more can be added later if needed):</p><p>  在Bevy ECS v2中，我们也可以吃蛋糕并吃它。它现在具有上面的两个组件存储类型（如果需要，可以在稍后添加更多）：</p><p>  These storage types complement each other perfectly. By default Query iteration is fast. If developers know that they want to add/remove a component at high frequencies, they can set the storage to &#34;sparse set&#34;:</p><p>  这些存储类型完全相互补充。默认情况下，查询迭代快。如果开发人员知道他们想要在高频下添加/删除组件，他们可以将存储设置为＆＃34;稀疏集合＆＃34 ;: </p><p>   This benchmark illustrates adding and removing a single 4x4 matrix component 10,000 times from an entity that has 5 other 4x4 matrix components. The &#34;other&#34; components are included to help illustrate the cost of &#34;table storage&#34; (used by Bevy 0.4, Bevy 0.5 (Table), and Legion), which requires moving the &#34;other&#34; components to a new table.</p><p>该基准测试说明了从具有5个其他4x4矩阵组件的实体添加和删除单个4x4矩阵组件10,000次。 ＆＃34;其他＆＃34;包括组件以帮助说明＆＃34;表存储＆＃34; （由Bevy 0.4，Bevy 0.5（表）和军团使用，需要移动＆＃34;其他＆＃34;组件到新表。</p><p>  You may have noticed that  Bevy 0.5 (Table) is also  way faster than  Bevy 0.4, even though they both use &#34;table storage&#34;. This is largely a result of the new  Archetype Graph, which significantly cuts the cost of archetype changes.</p><p>  您可能已经注意到Bevy 0.5（表）也比Bevy 0.4更快，即使它们都使用＆＃34;表存储＆＃34;这主要是新原型图的结果，这显着降低了原型变化的成本。</p><p>   World queries (and other system parameters) are now stateful. This allows us to: Cache archetype (and table) matches This resolves another issue with (naive) archetypal ECS: query performance getting worse as the number of archetypes goes up (and fragmentation occurs).</p><p>   世界查询（和其他系统参数）现在是有状态的。这允许我们：缓存原型（和表）匹配，这可以解决（天真）原型型ECS的另一个问题：查询性能随着原型的数量而越来越差（发生碎​​片）。</p><p> Cache Query Fetch and Filter state The expensive parts of fetch/filter operations (such as hashing the TypeId to find the ComponentId) now only happen once when the Query is first constructed</p><p> 缓存查询获取和筛选状态昂贵的Fetch / Filter操作部分（例如散列TypeId以查找ComponentID），现在只有在首次构造查询时发生一次</p><p> Incrementally build up state When new archetypes are added, we only process the new archetypes (no need to rebuild state for old archetypes)</p><p> 逐步构建状态在添加新原型时，我们只处理新的原型（无需重建旧原型的状态）</p><p>   However for   Systems this is a non-breaking change. Query state management is done internally by the relevant SystemParam.</p><p>   然而，对于系统来说，这是一个不破坏的变化。查询状态管理由相关的SystemParam内部完成。</p><p> We have achieved some pretty significant performance wins as a result of the new Query system.</p><p> 由于新的查询系统，我们已经实现了一些非常重要的性能。 </p><p>  This benchmark runs a query that matches 5 entities within a single archetype and  doesn&#39;t match 100 other archetypes. This is a reasonable test of &#34;real world&#34; queries in games, which generally have many different entity &#34;types&#34;, most of which  don&#39;t match a given query. This test uses &#34;table storage&#34; across the board.</p><p>该基准测试运行一个匹配单个原型和＃39; t匹配的5个实体的查询匹配100匹配100其他原型。这是＆＃34的合理测试;现实世界＆＃34;在游戏中的查询，通常有许多不同的实体＆＃34;类型＆＃34;，大多数Don＆＃39; t匹配给定查询。此测试使用＆＃34;表存储＆＃34;穿过董事会。</p><p>  Bevy 0.5 marks a huge improvement for cases like this, thanks to the new &#34;stateful queries&#34;.  Bevy 0.4 needs to check every archetype each time the iterator is run, whereas  Bevy 0.5 amortizes that cost to zero.</p><p>  Bevy 0.5为像新的案件标志着它的巨大改进，感谢新的＆＃34;有状态疑问＆＃34;每次运行迭代器时，都需要检查每个原型的每个原型，而Bevy 0.5摊销成本为零。</p><p>  This is the  ecs_bench_suite  frag_iter benchmark. It runs a query on 27 archetypes with 20 entities each. However unlike the &#34;Sparse Fragmented Iterator Benchmark&#34;, there are no &#34;unmatched&#34; archetypes. This test uses &#34;table storage&#34; across the board.</p><p>  这是ECS_Bench_Suite frag_iter基准测试。它以27个原型运行查询，每个ISIchetypes都有20个实体。然而，与＆＃34不同;稀疏碎片迭代店基准＆＃34;没有＆＃34;无与伦比的＆＃34;原型。此测试使用＆＃34;表存储＆＃34;穿过董事会。</p><p>  The gains here compared to the last benchmark are smaller because there aren&#39;t any unmatched archetypes. However  Bevy 0.5 still gets a nice boost due to better iterator/query impls, amortizing the cost of matched archetypes to zero, and for_each iterators.</p><p>  这里的收益与最后一个基准相比较小，因为没有任何无与伦比的原型＆＃39;然而，由于更好的迭代器/查询iclip，仍然仍然获得了一个很好的提升，将匹配原型的成本摊销到零，而for_each迭代器。</p><p>  Developers now have the choice to use a fast   Query::for_each() iterator, which yields ~1.5-3x iteration speed improvements for &#34;fragmented iteration&#34;, and minor ~1.2x iteration speed improvements for unfragmented iteration.</p><p>  开发人员现在可以选择使用快速查询:: for_each（）迭代器，从而产生＆＃34的迭代速度改进;碎片迭代＆＃34;，对未经用迭代的次要〜1.2x迭代速度改进。</p><p> fn  system ( query :  Query &lt;(&amp; A,  &amp; mut  B )&gt;) {  // you now have the option to do this for a speed boost  query . for_each_mut (|( a ,  mut b )| { });  // however normal iterators are still available  for  ( a ,  mut  b ) in  query . iter_mut () { }}</p><p> FN系统（查询：查询＆lt;（＆amp; a，＆amp; mut b）＆gt;）{//您现在可以选择为速度提升查询执行此操作。 for_ach_mut（|（a，mut b）| {}）; //然而，普通迭代器仍然可用于查询中的（a，mut b）。 ITER_MUT（）{}}</p><p> We will continue to encourage &#34;normal&#34; iterators as they are more flexible and more &#34;rust idiomatic&#34;. But when that extra &#34;oomf&#34; is needed,  for_each will be there ... waiting for you :)</p><p> 我们将继续鼓励＆＃34;正常＆＃34;迭代器，因为它们更灵活，更多＆＃34;生锈惯用＆＃34;但是当额外的＆＃34; oomf＆＃34;需要，for_each会在那里......等你:) </p><p>    The only way to explicitly define system order was to create new stages. This was both boilerplate-ey and prevented parallelism (because stages run &#34;one by one&#34; in order). We&#39;ve noticed that system ordering is a common requirement and stages just weren&#39;t cutting it.</p><p>明确定义系统顺序的唯一方法是创建新阶段。这两个都是batterplate-ey并防止并行性（因为阶段运行＆＃34;一个逐个＆＃34;按顺序）。我们注意到系统订购是一个常见的要求和阶段只是Weren＆＃39; t切割它。</p><p> Systems had &#34;implicit&#34; orderings when they accessed conflicting resources. These orderings were hard to reason about.</p><p> 系统有＆＃34;隐含的＆＃34;在访问冲突的资源时订购。这些排序很难理由。</p><p> The &#34;implicit orderings&#34; produced execution strategies that often left a lot of parallelism potential on the table.</p><p> ＆＃34;隐式排序＆＃34;产生的执行策略，通常在桌面上留下了很多平行潜力。</p><p> Fortunately @Ratysz has been  doing a lot of  research in this area and volunteered to contribute a new executor. The new executor solves all of the issues above and also adds a bunch of new usability improvements. The &#34;ordering&#34; rules are now dead-simple:</p><p> 幸运的是，@ratysz一直在这一领域做了很多研究，并自愿捐助一个新的执行官。新的执行程序解决了上述所有问题，并添加了一堆新的可用性改进。 ＆＃34;订购＆＃34;规则现在已经死了 - 简单：</p><p>    Systems can now be assigned one or more   SystemLabels. These labels can then be referenced by other systems (within a stage) to run before or after systems with that label:</p><p>    现在可以分配一个或多个SystemLabels。然后可以通过其他系统（阶段内）引用这些标签以在具有该标签的系统之前或之后运行：</p><p>    Any type that implements the   SystemLabel trait can be used. In most cases we recommend defining custom types and deriving   SystemLabel for them. This prevents typos, allows for encapsulation (when needed), and allows IDEs to autocomplete labels:</p><p>    可以使用实现SystemLabel特征的任何类型。在大多数情况下，我们建议为它们定义自定义类型和派生SystemLabel。这可以防止拼写错误，允许封装（在需要时），并允许IDES到AutoComplete标签：</p><p> #[ derive ( Debug ,  Hash ,  PartialEq ,  Eq ,  Clone ,  SystemLabel )] pub enum  PhysicsSystem  {  UpdateVelocity ,  Movement ,} app  . add_system ( update_velocity . system (). label ( PhysicsSystem :: UpdateVelocity )) . add_system ( movement . system () . label ( PhysicsSystem :: Movement ) . after ( PhysicsSystem :: UpdateVelocity ) );</p><p> ＃[派生（调试，散列，零件，eq，clone，systemlabel）] Pub枚举物理系统{UpdateVelocity，Moreforms，Moreforms}应用程序。 add_system（update_velocity。system（）。标签（物理系统:: updatevelocity）））。 add_system（移动。系统（）。标签（物理系统::移动）。之后（物理系统:: UpdateVelocity））; </p><p>  Many-to-many labels is a powerful concept that makes it easy to take a dependency on many systems that produce a given behavior/outcome. For example, if you have a system that needs to run after all &#34;physics&#34; has finished updating (see the example above), you could label all &#34;physics systems&#34; with the same  Physics label:</p><p>多对多标签是一个强大的概念，使得依赖于产生给定行为/结果的许多系统方便。例如，如果您有一个毕竟需要运行的系统＆＃34;物理＆＃34;已经完成更新（见上面的示例），您可以标记所有＆＃34;物理系统＆＃34;使用相同的物理标签：</p><p> #[ derive ( Debug ,  Hash ,  PartialEq ,  Eq ,  Clone ,  SystemLabel )] pub struct  Physics ;#[ derive ( Debug ,  Hash ,  PartialEq ,  Eq ,  Clone ,  SystemLabel )] pub enum  PhysicsSystem  {  UpdateVelocity ,  Movement ,} app  . add_system ( update_velocity . system () . label ( PhysicsSystem :: UpdateVelocity ) . label ( Physics ) ) . add_system ( movement . system () . label ( PhysicsSystem :: Movement ) . label ( Physics ) . after ( PhysicsSystem :: UpdateVelocity ) ) . add_system ( runs_after_physics . system (). after ( Physics ));</p><p> ＃[派生（调试，哈希，零件，eq，克隆，systemlabel）] pub struct物理;＃[派生（调试，散列，偏见，eq，clone，systemlabel）] pub枚举物理系统{updatevelocity，moreform，moreface。 add_system（update_velocity。系统（）。标签（物理系统:: updateVelocity）。标签（物理））。 add_system（移动。系统（）。标签（物理系统::移动）。标签（物理）。（物理系统:: updateVelocity）之后。 add_system（runs_after_physics。系统（）。在（物理）之后）;</p><p> Bevy plugin authors should export labels like this in their public APIs to enable their users to insert systems before/after logic provided by the plugin.</p><p> Bevy Plugin作者应该在其公共API中将标签导出，使其用户能够在插件提供的逻辑之前/之后插入系统。</p><p>   SystemSets are a new way to apply the same configuration to a group of systems, which significantly cuts down on boilerplate. The &#34;physics&#34; example above could be rephrased like this: app  . add_system_set ( SystemSet :: new ()  // this label is added to all systems in the set  . label ( Physics ) . with_system ( update_velocity . system (). label ( PhysicsSystem :: UpdateVelocity )) . with_system ( movement . system () . label ( PhysicsSystem :: Movement ) . after ( PhysicsSystem :: UpdateVelocity ) ) )</p><p>   Systemsets是一种对一组系统应用相同配置的新方法，这显着削减了样板。 ＆＃34;物理＆＃34;上面的示例可以是如下所示的：应用程序。 add_system_set（systemset :: new（）//将此标签添加到集合中的所有系统。标签（物理）。with_system（update_velocity。系统（）。标签（物理系统:: updatevelocity））。with_system（移动。系统（） 。标签（物理系统::运动）。之后（物理系统:: UpdateVelocity））））</p><p> SystemSets can also use  before(Label) and  after(Label) to run all systems in the set before/after the given label.</p><p> Systemsets也可以在（标签）和之后（标签）之前使用，以在给定标签之前/之后的设置中运行所有系统。</p><p> This is also very useful for groups of systems that need to run with the same   RunCriteria.</p><p> 这对于需要运行相同的运行频率的系统组也非常有用。</p><p> app  // all systems in this set will run once every two seconds  . add_system_set ( SystemSet :: new () . with_run_criteria ( FixedTimestep :: step ( 2.0 )) . with_system ( foo . system ()) . with_system ( bar . system ()) )</p><p> APP //此集合中的所有系统都将每两秒运行一次。 add_system_set（systemset :: new（）。with_run_criteria（fixedtimestep :: step（2.0））。with_system（foo。system（））。with_system（bar。system（））） </p><p>  Run Criteria are now decoupled from systems and will be re-used when possible. For example, the FixedTimestep criteria in the example above will only be run once per stage run. The executor will re-use the criteria&#39;s result for both the  foo and  bar system.</p><p>运行标准现在与系统分离，并在可能的情况下重新使用。例如，上面示例中的固定数据项标准只会运行一次运行一次。执行者将重新使用Foo和Bar系统的标准和＃39; S结果。</p><p>  fn  every_other_time ( mut  has_ran :  Local &lt; bool &gt;) -&gt;  ShouldRun  { * has_ran  = !* has_ran ;  if  * has_ran  {  ShouldRun :: Yes  }  else  {  ShouldRun :: No  }} app . add_stage ( SystemStage :: parallel () . with_system_run_criteria ( every_other_time . system (). label (&#34; every_other_time &#34;))) . add_system ( foo . system (). with_run_criteria (&#34; every_other_time &#34;))</p><p>  fn every_other_time（mut has_ran：local＆lt; bool＆gt;） - ＆gt;肩膀{* has_ran =！* has_ran;如果* has_ran {wallrun ::是} els {wallrun :: no}}应用程序。 add_stage（systemstage :: parallel（）。with_system_run_criteria（every_other_time。system（）。标签（＆＃34; every_other_time＆＃34;）））））。 add_system（foo。system（）。with_run_criteria（＆＃34; every_other_time＆＃34;））</p><p> Results from Run Criteria can also be &#34;piped&#34; into other criteria, which enables interesting composed behaviors:</p><p> 运行标准的结果也可以是＆＃34;管道和＃34;进入其他标准，这使得有趣的组成行为：</p><p> fn  once_in_a_blue_moon ( In ( input ) : In &lt; ShouldRun &gt; ,  moon :  Res &lt; Moon &gt;) -&gt;  ShouldRun  {  if  moon . is_blue () {  input  }  else  {  ShouldRun :: No  }} app  . add_system ( foo . with_run_criteria ( &#34; every_other_time &#34;. pipe ( once_in_a_blue_moon . system ()) )</p><p> fn direcle_in_a_blue_moon（In（输入）：在＆lt; antrun＆gt;，moon：res＆lt; moon＆gt;） - ＆gt;杨柳{如果月亮。 is_blue（）{input} else {wallrun :: no}}应用程序。 add_system（foo with_run_criteria（＆＃34; every_other_time＆＃34; pipe（are_in_a_blue_moon。system（）））</p><p>  While the new executor is now much easier to reason about, it does introduce a new class of error: &#34;system order ambiguities&#34;. When two systems interact with the same data, but have no explicit ordering defined, the output they produce is non-deterministic (and often not what the author intended).</p><p>  虽然新的执行程序现在更容易理解，但它确实介绍了一类新的错误：＆＃34;系统订单含糊不清＆＃34;当两个系统与相同的数据交互时，但没有明确的排序定义，它们产生的输出是非确定性的（并且通常不是作者预期的）。</p><p>  fn  increment_counter ( mut  counter :  ResMut &lt; usize &gt;) { * counter  +=  1 ;} fn  print_every_other_time ( counter :  Res &lt; usize &gt;) {  if  * counter  %  2  ==  0  {  println! (&#34; ran &#34;); }} app  . add_system ( increment_counter . system ()) . add_system ( print_every_other_time . system ())</p><p>  fn increntment_counter（mut计数器：Resmut＆lt;）{*计数器+ = 1;} fn print_every_other_time（计数器：res＆lt; Usize＆gt;）{如果*计数器％2 == 0 {println！ （＆＃34; ran＆＃34;）; }} 应用程序  。 add_system（increntment_counter。system（））。 add_system（print_every_other_time。system（））</p><p> The author clearly intended  print_every_other_time to run every other update. However, due to the fact that these systems have no order defined, they could run in a different order each update and create a situation where nothing is printed over the course of two updates:</p><p> 作者清楚地预定print_every_other_time来运行其他更新。但是，由于这些系统没有定义了订单，它们可以以不同的顺序运行每个更新，并在两个更新的过程中打印任何内容的情况： </p><p> UPDATE- increment_counter (counter now equals 1)- print_every_other_time (nothing printed)UPDATE- print_every_other_time (nothing printed)- increment_counter (counter now equals 2)</p><p>更新 -  increment_counter（柜台现在等于1） -  print_every_other_time（没有打印）更新 -  print_very_other_time（没有打印） -  increment_counter（柜台现在等于2）</p><p> The old executor would have implicitly forced  increment_counter to run first because it conflicts with  print_every_other_time and it was inserted first. But the new executor requires you to be explicit here (which we believe is a good thing).</p><p> 旧的executor将隐式强制increntment_counter首先运行，因为它与print_every_other_time冲突，它首先插入。但是新的执行官要求您在此处（我们认为是一件好事）。</p><p> To help detect this class of error, we built an opt-in tool that detects these ambiguities and logs them:</p><p> 为了帮助检测到这类错误，我们构建了一个选择的工具，检测这些含糊不点并记录它们：</p><p>  Then when we run our App, we will see the following message printed to our terminal:</p><p>  然后在我们运行我们的应用程序时，我们将看到打印到我们终端的以下消息：</p><p> Execution order ambiguities detected, you might want to add an explicit dependency relation between some of these systems: * Parallel systems: -- &#34;&amp;app::increment_counter&#34; and &#34;&amp;app::print_every_other_time&#34; conflicts: [&#34;usize&#34;]</p><p> 检测到的执行顺序歧义，您可能希望在其中一些系统之间添加显式依赖关系：*并行系统： - ＆＃34;＆amp;应用程序:: increntment_counter＆＃34;和＃34;＆amp; app :: print_every_other_time＆＃34;冲突：[＆＃34; USIZE＆＃34;]</p><p> The ambiguity detector found a conflict and mentions that adding an explicit dependency would resolve the conflict:</p><p> 歧义探测器发现了一个冲突和提到，添加了显式依赖性将解决冲突：</p><p>  There  are some cases where ambiguities are  not a bug, such as operations on unordered collection like  Assets. This is why we don&#39;t enable the detector by default. You are free to just ignore these ambiguities, but if you want to suppress the messages in the detector (without defining a dependency), you can add your systems to an &#34;ambiguity set&#34;:</p><p>  有一些案例，歧义不是一个错误，例如无序集合的操作等资产。这就是为什么我们不默认启用探测器。您可以自由地忽略这些歧义，但如果要抑制探测器中的消息（无需定义依赖项），则可以将您的系统添加到AN＆＃34; ambiguity集合＆＃34 ;: </p><p>  I want to stress that this is totally optional. Bevy code should be ergonomic and &#34;fun&#34; to write. If sprinkling ambiguity sets everywhere isn&#39;t your cup of tea, just don&#39;t worry about it!</p><p>我想强调这是完全可选的。 Bevy代码应该是符合人体工程学和＆＃34;有趣＆＃34;来写。如果洒在歧义落在任何地方且＃39;你的一杯茶，只是不要担心它！</p><p> We are also actively seeking feedback on the new executor. We believe that the new implementation is easier to understand and encourages self-documenting code. The improved parallelism is also nice! But we want to hear from users (both new users starting fresh and old users porting their codebases to the new executor). This space is all about design tradeoffs and feedback will help us ensure we made the right calls.</p><p> 我们也正在积极寻求关于新执行官的反馈。我们相信新的实施更容易理解并鼓励自我记录代码。改善的并行性也很好！但是我们希望听到用户（新用户都开始新的用户，并将其代码库移植到新的执行程序）。这个空间都是关于设计权衡和反馈，并有助于我们确保我们做出正确的电话。</p><p>   Global change detection, the ability to run queries on the Changed/Added status of any ECS component or resource, just got a major usability boost: changes are now detected across frames/updates:</p><p>   全局变更检测，在任何ECS组件或资源的更改/添加状态下运行查询的能力，刚刚获得了一个重大的可用性提升：现在在帧/更新中检测到更改：</p><p> // This is still the same change detection api we all know and love,// the only difference is that it &#34;just works&#34; in every situation. fn  system ( query :  Query &lt; Entity, Changed &lt; A &gt;&gt;) {  // iterates all entities whose A component has changed since // the last run of this system  for  e  in  query . iter () { }}</p><p> //这仍然是相同的变化检测API我们都知道和爱，//唯一的区别是它＆＃34;只是作品＆＃34;在每种情况下。 FN系统（查询：查询＆lt;实体，已更改为＆gt;）{//迭代所有实体，其组件自//在查询中的e的上次运行此系统的最后运行。 erter（）{}}</p><p> Global change detection was already a feature that set Bevy apart from other ECS frameworks, but now it is completely &#34;fool proof&#34;. It works as expected regardless of system ordering, stage membership, or system run criteria.</p><p> 全局变更检测已经是一个特征，它与其他ECS框架相比设置了BEVY，但现在它是完全＆＃34;傻瓜证明＆＃34;无论系统订购，阶段成员资格或系统运行标准如何，它都可以工作。</p><p> The old behavior was &#34;systems detect changes that ocurred in systems that ran before them this frame&#34;. This was because we used a  bool to track when each component/resource is added/modified. This flag was cleared for each component at the end of the frame. As a result, users had to be very careful about order of operations, and using features like &#34;system run criteria&#34; could result in dropped changes if systems didn&#39;t run on a given update.</p><p> 旧行为是＆＃34;系统检测到在它们之前遇到的系统中的变化＆＃34;这是因为当添加/修改每个组件/资源时，我们使用BOOL跟踪。此标志对于帧结束时的每个组件被清除。因此，用户必须非常谨慎地了解操作顺序，并使用像＆＃34这样的功能;系统运行标准＆＃34;如果系统在给定更新中运行，则可能导致更改删除。</p><p> We now use a clever &#34;world tick&#34; design that allows systems to detect changes that happened at  any point in time since their last run.</p><p> 我们现在使用聪明的＆＃34;世界蜱＆＃34;设计允许系统检测自上次运行以来任何时间点发生的更改。 </p><p>   The  last Bevy release added States, which enabled developers to run groups of ECS systems according to the value of a  State&lt;T&gt; resource. Systems could be run according to &#34;state lifecycle events&#34;, such as on_enter, on_update, and on_exit. States make things like separate &#34;loading screen&#34; and &#34;in game&#34; logic easier to encode in Bevy ECS.</p><p>最后一个Bevy发布添加状态，它使开发人员能够根据状态＆lt; t＆gt的值运行ECS系统组;资源。系统可以根据＆＃34运行系统生命周期事件＆＃34;，例如on_enter，on_update和on_exit。各国像单独的东西一样制造;加载屏幕＆＃34;和＃34;在游戏中＆＃34;在Bevy ECS中更容易编码逻辑。</p><p> The old implementation largely worked, but it had a number of quirks and limitations. First and foremost, it required adding a new  StateStage, which cut down on parallelism, increased boilerplate, and forced ordering where it wasn&#39;t required. Additionally, some of the lifecycle events didn&#39;t always behave as expected.</p><p> 旧的实现在很大程度上工作，但它有很多怪癖和局限性。首先，它需要添加一个新的Statesge，它在并行，增加的样板，并强制订购所需的地方，而且需要。此外，一些生命周期事件没有始终按预期行事。</p><p> The new   State implementation is built on top of the new parallel executor&#39;s SystemSet and RunCriteria features, for a much more natural, flexible, and parallel api that builds on existing concepts instead of creating new ones:</p><p> 新的状态实现是基于新的并行执行程序和＃39; s systemset和runcrieria特征的顶部构建了更自然，灵活的，并行API，这些API在现有概念上构建而不是创建新的：</p><p> #[ derive ( Debug ,  Clone ,  Eq ,  PartialEq ,  Hash )] enum  AppState  {  Menu ,  InGame ,} fn  main () {  App :: build () . add_state ( AppState :: Menu ) . add_system_set ( SystemSet :: on_enter ( AppState :: Menu ). with_system ( setup_menu . system ())) . add_system_set ( SystemSet :: on_update ( AppState :: Menu ). with_system ( menu_logic . system ())) . add_system_set ( SystemSet :: on_exit ( AppState :: Menu ). with_system ( cleanup_menu . system ())) . add_system_set ( SystemSet :: on_enter ( AppState :: InGame ). with_system ( setup_game . system ())) . add_system_set (  SystemSet :: on_update ( AppState :: InGame ) . with_system ( game_logic . system ()) . with_system ( more_game_logic . system ()) ) . run ();}</p><p> ＃[派生（调试，克隆，eq，partialeq，哈希）] enum appstate {menu，ingame，} fn main（）{app :: build（）。 add_state（appstate ::菜单）。 add_system_set（systemset :: on_enter（appstate ::菜单）。with_system（setup_menu。system（）））。 add_system_set（systemset :: on_update（appstate :: menu）。with_system（menu_logic。system（）））。 add_system_set（systemset :: on_exit（appstate ::菜单）。with_system（cleanup_menu。system（）））。 add_system_set（systemset :: On_Enter（AppState :: Invame）。with_system（setup_game。system（）））。 add_system_set（systemset :: on_update（appstate :: gamene）。with_system（game_logic。system（））。with_system（more_game_logic。system（）））。跑步 （）;}</p><p> States now use a &#34;stack-based state machine&#34; model. This opens up a number of options for state transitions:</p><p> 现在使用A＆＃34;基于堆栈的状态机＆＃34;模型。这为州过渡的许多选项打开了：</p><p> fn  system ( mut  state :  ResMut &lt; State &lt; AppState &gt;&gt;) {  // Queues up a state change that pushes a new state on to the // stack (preserving previous states)  state . push ( AppState :: InGame ). unwrap ();  // Queues up a state change that removes the current state on // the stack and reverts to the previous state  state . pop (). unwrap ();  // Queues up a state change that overwrites the current state at // the &#34;top&#34; of the stack  state . set ( AppState :: InGame ). unwrap ();  // Queues up a state change that replaces the entire stack of states  state . replace ( AppState :: InGame ). unwrap ();}</p><p> FN系统（MUT状态：Resmut＆lt;状态＆gt;＆gt;）{//队列向上推出一个状态更改，将新状态推送到//堆栈（保留以前的状态）状态。推（AppState :: Invame）。 unwrap（）; //延出一个状态更改，该更改删除//堆栈上的当前状态并恢复为先前的状态状态。流行音乐 （）。 unwrap（）; //向上延迟覆盖///＃34;顶部＆＃34的当前状态的状态更改;堆栈状态。 SET（AppState :: Invame）。 unwrap（）; //队列替换状态更改的状态更改。替换（AppState :: Invame）。 unwrap（）;}</p><p> Just like the old implementation, state changes are applied in the same frame. This means it is possible to transition from states  A-&gt;B-&gt;C and run the relevant state lifecycle events without skipping frames. This builds on top of &#34;looping run criteria&#34;, which we also use for our &#34;fixed timestep&#3</p><p> 就像旧的实现一样，状态更改应用于同一帧。这意味着可以从状态A-＆gt; b-＆gt; c，并在不跳过框架的情况下运行相关的状态生命周期事件。这是在＆＃34的顶部构建;循环运行标准＆＃34;我们也用于我们的我们的＆＃34;修复了TimeStep＆＃3 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bevyengine.org/news/bevy-0-5/">https://bevyengine.org/news/bevy-0-5/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/导向/">#导向</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/oriented/">#oriented</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/系统/">#系统</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>