<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从Rust中的自定义RISC-V操作系统获取图形输出Getting Graphical Output from Our Custom RISC-V Operating System in Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Getting Graphical Output from Our Custom RISC-V Operating System in Rust<br/>从Rust中的自定义RISC-V操作系统获取图形输出</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-25 17:25:07</div><div class="page_narrow text-break page_content"><p>An operating system is used to make our job easier when using graphics. In our instance, in addition to everything else. In this post, we will be writing a GPU (graphics processing unit) driver using the VirtIO specification. In here, we will allow user applications to have a portion of the screen as RAM–with what is commonly known as a  framebuffer.</p><p>在使用图形时，使用操作系统来简化我们的工作。在我们的实例中，除了其他方面。在本文中，我们将使用VirtIO规范编写GPU（图形处理单元）驱动程序。在这里，我们将允许用户应用程序将屏幕的一部分作为RAM －通常称为帧缓冲区。</p><p>      We command the virtual GPU (virtio-gpu) by sending certain commands to the host (the device). The guest (the OS driver) has an allocation of RAM that becomes the framebuffer. The driver then tells the device, “hey, here’s the RAM that we’re going to use to store pixel information.”</p><p>      我们通过将某些命令发送到主机（设备）来命令虚拟GPU（virtio-gpu）。来宾（操作系统驱动程序）具有分配为帧缓冲区的RAM。然后，驱动程序告诉设备：“嘿，这是我们将用于存储像素信息的RAM。”</p><p> The RAM is contiguous in our OS, but according to the specification, this isn’t strictly required. We will give the driver a rectangle. Everything that falls within that rectangle will be copied to the host. We don’t want to keep copying the entire buffer over and over again.</p><p> RAM在我们的操作系统中是连续的，但是根据规范，这并不是严格要求的。我们将给驱动程序一个矩形。属于该矩形的所有内容都将复制到主机。我们不想一遍又一遍地复制整个缓冲区。</p><p> We will be using the virtio protocol that we used for the block driver here, so I won’t rehash the general virtio protocol. However, the device-specific structures are a bit different, so we’ll cover that part more in depth.</p><p> 我们将在此处使用用于块驱动程序的virtio协议，因此我不会重新介绍通用的virtio协议。但是，特定于设备的结构有些不同，因此我们将更深入地介绍该部分。</p><p>   A framebuffer must be large enough to store \(\text{width}\times\text{height}\times\text{pixel size}\) number of bytes. There are \(\text{width}\times\text{height}\) number of pixels. Each pixel has a 1-byte red, green, blue, and alpha channels. So, each pixel is exactly 4 bytes with the configuration we’re going to specify.</p><p>   帧缓冲区必须足够大以存储\（\ text {width} \ times \ text {height} \ times \ text {pixel size} \）个字节数。有\（\ text {width} \ times \ text {height} \）个像素。每个像素都有一个1字节的红色，绿色，蓝色和alpha通道。因此，按照我们要指定的配置，每个像素正好是4个字节。</p><p> The framebuffer for our junior GPU driver is going to support a fixed resolution of \(640\times 480\). If you’re a child of the 90s, you saw this resolution a lot. In fact, my first computer, a Laser Pal 386, had a 16-color monitor with a resolution of 640 pixels wide with 480 pixels tall.</p><p> 我们的初级GPU驱动程序的帧缓冲区将支持\（640 \ times 480 \）的固定分辨率。如果您是90年代的孩子，那么您会经常看到这种分辨率。实际上，我的第一台计算机Laser Laser 386装有16色监视器，分辨率为640像素，高480像素。</p><p>  There are red, green, and blue pixels so close together that by varying the intensity of these three channels, we can change the color. The closer we get to our monitors, the easier a pixel is to see.</p><p>  红色，绿色和蓝色像素之间的距离非常近，因此可以通过更改这三个通道的强度来更改颜色。我们离显示器越近，像素越容易看到。</p><p>  You can see these little squares. If you squint enough, you can see that they aren’t pure white. Instead, you can see bits of red, blue, and green. That’s because each one of these little squares is subdivided into three colors: yep, red, green, and blue! To make white, these pixels are turned up to 11 (get the joke?). To make black, we turn off all three channels of that pixel.</p><p>您可以看到这些小方块。如果斜视一下，您会发现它们不是纯白色的。相反，您可以看到红色，蓝色和绿色。这是因为这些小方块中的每一个都细分为三种颜色：是，红色，绿色和蓝色！为了产生白色，这些像素最多调到11（开个玩笑？）。要变黑，请关闭该像素的所有三个通道。</p><p> The resolution refers to how many of these squares are on our monitor. This is a 1920×1080 monitor. That means that there are 1920 of these squares going left to right, and there are 1080 of these squares from top to bottom. All in all, we have \(1920\times 1080=2,073,600\) number of pixels. Each one of these pixels is expressed using 4 bytes in the framebuffer, meaning we need \(2,073,600\times 4=8,294,400\) bytes in RAM to store the pixel information.</p><p> 分辨率是指我们的显示器上有多少个正方形。这是1920×1080的显示器。这意味着从左到右有1920个正方形，从上到下有1080个正方形。总共，我们有\（1920 \ times 1080 = 2,073,600 \）像素数。这些像素中的每个像素都使用4个字节表示在帧缓冲区中，这意味着我们需要\（2,073,600 \ times 4 = 8,294,400 \）个字节来存储像素信息。</p><p> You can see why I limited our resolution to 640×480, which only requires \(640\times 480\times 4=1,228,800\) bytes–a bit over a megabyte.</p><p> 您可以看到为什么我将分辨率限制为640×480，它只需要\（640 \ times 480 \ times 4 = 1,228,800 \）个字节-超过了一个兆字节。</p><p>   The GPU device requires us to read a more up-to-date VirtIO specification. I’ll be reading from version 1.1, which you can get a copy here:  https://docs.oasis-open.org/virtio/virtio/v1.1/virtio-v1.1.html. Specifically, chapter 5.7 “GPU Device”. This is an  unaccelerated 2D device, meaning that we must use the CPU to actually form the framebuffer, then we transfer our CPU formulated memory location to the host GPU, which is then responsible for drawing it to the screen.</p><p>   GPU设备要求我们阅读更新的VirtIO规范。我将从1.1版开始阅读，您可以在此处获得副本：https://docs.oasis-open.org/virtio/virtio/v1.1/virtio-v1.1.html。具体来说，第5.7节“ GPU设备”。这是一个未加速的2D设备，这意味着我们必须使用CPU实际形成帧缓冲区，然后将CPU制定的内存位置传输到主机GPU，然后由它负责将其绘制到屏幕上。</p><p> The device uses a request/response system, where we the driver make a command to request something from the host (the GPU). We add a bit of extra memory into our request so that the host can formulate its response. When the GPU interrupts us, we can take a look at this response memory location to see what the GPU told us. This is much like the  status field on the block driver, where the block device tells us the status of our last request.</p><p> 该设备使用请求/响应系统，在该系统中，我们的驱动程序发出命令以从主机（GPU）请求某些内容。我们在请求中添加了一些额外的内存，以便主机可以制定其响应。当GPU中断我们时，我们可以查看此响应内存位置，以了解GPU告诉我们的内容。这很像块驱动程序上的状态字段，块设备在其中告诉我们上一个请求的状态。</p><p>   The header is common for all requests and all responses. We can differentiate by the CtrlType enumeration, which is:</p><p>   标头对于所有请求和所有响应都是通用的。我们可以通过CtrlType枚举来区分，即：</p><p> #[repr(u32)]enum CtrlType {	/* 2d commands */	CmdGetDisplayInfo = 0x0100,	CmdResourceCreate2d,	CmdResourceUref,	CmdSetScanout,	CmdResourceFlush,	CmdTransferToHost2d,	CmdResourceAttachBacking,	CmdResourceDetachBacking,	CmdGetCapsetInfo,	CmdGetCapset,	CmdGetEdid,	/* cursor commands */	CmdUpdateCursor = 0x0300,	CmdMoveCursor,	/* success responses */	RespOkNoData = 0x1100,	RespOkDisplayInfo,	RespOkCapsetInfo,	RespOkCapset,	RespOkEdid,	/* error responses */	RespErrUnspec = 0x1200,	RespErrOutOfMemory,	RespErrInvalidScanoutId,	RespErrInvalidResourceId,	RespErrInvalidContextId,	RespErrInvalidParameter,}</p><p> ＃[repr（u32）]枚举CtrlType {/ * 2d命令* / CmdGetDisplayInfo = 0x0100，CmdResourceCreate2d，CmdResourceUref，CmdSetScanout，CmdResourceFlush，CmdTransferToHost2d，CmdResourceAttachBacking，CmdResourceDetachBacking，CmdGetCapsetd，CmdGetCapsetd，CmdGetCapsetd，CmdGetCapsetd CmdMoveCursor，/ *成功响应* / RespOkNoData = 0x1100，RespOkDisplayInfo，RespOkCapsetInfo，RespOkCapset，RespOkEdid，/ *错误响应* / RespErrUnspec = 0x1200，RespErrOutOfMemory，RespErrInvalidScanoutId，RespErrInvalidValidResp</p><p> I took this directly from the specification, but Rust-ified the names to avoid getting yelled at by the linter.</p><p>我直接从规范中获取了此信息，但是Rust对其名称进行了修饰，以避免被短绒毛大喊大叫。</p><p>  Recall that the framebuffer is just a bunch of bytes in memory. We need to put a structure behind the framebuffer so the host (the GPU) knows how to interpret your sequence of bytes. There are several formats, but all-in-all, they just re-arrange the red, green, blue, and alpha channels. All are exactly 4 bytes, which makes the  stride the same. The stride is the spacing from one pixel to another–4 bytes.</p><p>  回想一下，帧缓冲区只是内存中的一堆字节。我们需要在帧缓冲区后面放置一个结构，以便主机（GPU）知道如何解释字节序列。格式有几种，但总的来说，它们只是重新排列红色，绿色，蓝色和Alpha通道。全部都是4个字节，这使得步幅相同。跨度是从一个像素到另一个4字节的间距。</p><p> #[repr(u32)]enum Formats {	B8G8R8A8Unorm = 1,	B8G8R8X8Unorm = 2,	A8R8G8B8Unorm = 3,	X8R8G8B8Unorm = 4,	R8G8B8A8Unorm = 67,	X8B8G8R8Unorm = 68,	A8B8G8R8Unorm = 121,	R8G8B8X8Unorm = 134,}</p><p> ＃[repr（u32）]枚举格式{B8G8R8A8Unorm = 1，B8G8R8X8Unorm = 2，A8R8G8B8Unorm = 3，X8R8G8B8Unorm = 4，R8G8B8A8Unorm = 67，X8B8G8R8Unorm = 68，A8R8Unorm = 68，A8R8Unorm = 68，A8R8Unorm = 68，A8</p><p> The type,  unorm, is an 8-bit (1-byte) unsigned value from 0 through 255, where 0 represents no intensity and 255 represents full intensity, and a number in between is a linear-interpolation between no and full intensity. Since there are three color (and one alpha), that gives us \(256\times 256\times 256=16,776,216\) different colors or levels of colors.</p><p> 类型unorm是从0到255的8位（1字节）无符号值，其中0表示无强度，255表示全强度，其间的数字是no和全强度之间的线性插值。由于存在三种颜色（和一种Alpha），因此可以为我们提供（256×256乘以256×16,776,216 \）种不同的颜色或颜色级别。</p><p> For this tutorial, I selected  R8G8B8A8Unorm = 67, which has red first, green second, blue third, and alpha fourth. This is a common ordering, so I’ll select it to make it easy to follow along.</p><p> 在本教程中，我选择了R8G8B8A8Unorm = 67，它的第一位为红色，第二位为绿色，第三位为蓝色，第四位为alpha。这是常见的排序方式，因此我将其选中以使其易于遵循。</p><p>   Recall that each individual component R, G, B, and A are each one byte a piece, so each Pixel referred to by (x, y) is 4 bytes. This is why our memory pointer is a Pixel structure instead of a byte.</p><p>   回想一下，每个单独的分量R，G，B和A均为一个字节，因此（x，y）所指的每个Pixel为4字节。这就是为什么我们的内存指针是Pixel结构而不是字节的原因。</p><p>   Just like all other virtio devices, we set up the virtqueues first and then we work on device-specific initialization. In my code, I just directly copied-and-pasted from the block driver into the gpu driver. The only thing I added to the Device structure was the framebuffer and dimensions of the framebuffer.</p><p>   像所有其他virtio设备一样，我们首先设置虚拟队列，然后进行设备特定的初始化。在我的代码中，我只是直接从块驱动程序复制并粘贴到了gpu驱动程序中。我添加到设备结构的唯一一件事是帧缓冲区和帧缓冲区的尺寸。</p><p> pub struct Device {	queue: *mut Queue,	dev: *mut u32,	idx: u16,	ack_used_idx: u16,	framebuffer: *mut Pixel,	width: u32,	height: u32,}</p><p>pub struct Device {队列：* mut队列，开发人员：* mut u32，idx：u16，ack_used_idx：u16，帧缓冲区：* mut像素，宽度：u32，高度：u32，}</p><p> The specification tells us to do the following in order to initialize the device and get things ready to draw. I Rust-ified some of the content to match our enumerations.</p><p> 规范告诉我们执行以下操作以初始化设备并准备绘制东西。我对某些内容进行了锈化处理以匹配我们的枚举。</p><p>  Allocate a framebuffer from guest ram, and attach it as backing storage to the resource just created, using  CmdResourceAttachBacking.</p><p>  从来宾ram分配一个帧缓冲区，并使用CmdResourceAttachBacking将它作为后备存储附加到刚创建的资源上。</p><p>  Recall that our request and response come packaged together. We will put them in separate descriptors, but whenever we get a response back from the device, it is going to be easier if we free just once to free both the request and response. So, in Rust, I created the Request structure to support doing this.</p><p>  回想一下，我们的请求和响应是打包在一起的。我们将它们放在单独的描述符中，但是只要我们从设备获得响应，只要释放一次以释放请求和响应，就会变得更加容易。因此，在Rust中，我创建了Request结构来支持此操作。</p><p> struct Request&lt;RqT, RpT&gt; {	request: RqT,	response: RpT,}impl&lt;RqT, RpT&gt; Request&lt;RqT, RpT&gt; {	pub fn new(request: RqT) -&gt; *mut Self {		let sz = size_of::&lt;RqT&gt;() + size_of::&lt;RpT&gt;();		let ptr = kmalloc(sz) as *mut Self;		unsafe {			(*ptr).request = request;		}		ptr	}}</p><p> struct Request  {请求：RqT，响应：RpT，} impl  Request  {pub fn new（request：RqT）-> * mut Self {let sz = size_of :: （）+ size_of :: （）;让ptr = kmalloc（sz）作为* mut Self;不安全{（* ptr）.request =请求； } ptr}}</p><p>  let rq = Request::new(ResourceCreate2d {	hdr: CtrlHeader {		ctrl_type: CtrlType::CmdResourceCreate2d,		flags: 0,		fence_id: 0,		ctx_id: 0,		padding: 0,	},	resource_id: 1,	format: Formats::R8G8B8A8Unorm,	width: dev.width,	height: dev.height,});let desc_c2d = Descriptor {	addr: unsafe { &amp;(*rq).request as *const ResourceCreate2d as u64 },	len: size_of::&lt;ResourceCreate2d&gt;() as u32,	flags: VIRTIO_DESC_F_NEXT,	next: (dev.idx + 1) % VIRTIO_RING_SIZE as u16,};let desc_c2d_resp = Descriptor {	addr: unsafe { &amp;(*rq).response as *const CtrlHeader as u64 },	len: size_of::&lt;CtrlHeader&gt;() as u32,	flags: VIRTIO_DESC_F_WRITE,	next: 0,};unsafe {	let head = dev.idx;	(*dev.queue).desc[dev.idx as usize] = desc_c2d;	dev.idx = (dev.idx + 1) % VIRTIO_RING_SIZE as u16;	(*dev.queue).desc[dev.idx as usize] = desc_c2d_resp;	dev.idx = (dev.idx + 1) % VIRTIO_RING_SIZE as u16;	(*dev.queue).avail.ring[(*dev.queue).avail.idx as usize % VIRTIO_RING_SIZE] = head;	(*dev.queue).avail.idx = (*dev.queue).avail.idx.wrapping_add(1);}</p><p>  let rq = Request :: new（ResourceCreate2d {hdr：CtrlHeader {ctrl_type：CtrlType :: CmdResourceCreate2d，flags：0，fence_id：0，ctx_id：0，padding：0，}，resource_id：1，format：Formats :: R8G8B8A8Unorm， width：dev.width，height：dev.height，}）;让desc_c2d =描述符{addr：不安全{＆（* rq）.request as * const ResourceCreate2d as u64}，len：size_of :: （）as u32，标志：VIRTIO_DESC_F_NEXT，下一个：（dev.idx + 1）％VIRTIO_RING_SIZE as u16，}; let desc_c2d_resp = Descriptor {addr：unsafe {＆（* rq）.response as * const CtrlHeader as u64}，len：size_of： ：（）为u32，标志：VIRTIO_DESC_F_WRITE，下一个：0，};不安全{让head = dev.idx; （* dev.queue）.desc [dev.idx asize] = desc_c2d; dev.idx =（dev.idx +1）％VIRTIO_RING_SIZE as u16; （* dev.queue）.desc [dev.idx asize] = desc_c2d_resp; dev.idx =（dev.idx +1）％VIRTIO_RING_SIZE as u16; （* dev.queue）.avail.ring [（* dev.queue）.avail.idx，使用率％VIRTIO_RING_SIZE] = head; （* dev.queue）.avail.idx =（* dev.queue）.avail.idx.wrapping_add（1）;}</p><p> All we’re really telling the GPU here is our resolution and the format of the framebuffer. When we create this, the host gets to configure itself, such as allocating an identical buffer to make transfers from our OS.</p><p> 我们真正要告诉GPU的是分辨率和帧缓冲区的格式。当我们创建它时，主机将进行自我配置，例如分配相同的缓冲区以从操作系统进行传输。</p><p>  let rq = Request3::new(AttachBacking {	hdr: CtrlHeader {		ctrl_type: CtrlType::CmdResourceAttachBacking,		flags: 0,		fence_id: 0,		ctx_id: 0,		padding: 0,	},	resource_id: 1,	nr_entries: 1,},MemEntry {	addr: dev.framebuffer as u64,	length: dev.width * dev.height * size_of::&lt;Pixel&gt;() as u32,	padding: 0, });let desc_ab = Descriptor {	addr: unsafe { &amp;(*rq).request as *const AttachBacking as u64 },	len: size_of::&lt;AttachBacking&gt;() as u32,	flags: VIRTIO_DESC_F_NEXT,	next: (dev.idx + 1) % VIRTIO_RING_SIZE as u16,};let desc_ab_mementry = Descriptor {	addr: unsafe { &amp;(*rq).mementries as *const MemEntry as u64 },	len: size_of::&lt;MemEntry&gt;() as u32,	flags: VIRTIO_DESC_F_NEXT,	next: (dev.idx + 2) % VIRTIO_RING_SIZE as u16,};let desc_ab_resp = Descriptor {	addr: unsafe { &amp;(*rq).response as *const CtrlHeader as u64 },	len: size_of::&lt;CtrlHeader&gt;() as u32,	flags: VIRTIO_DESC_F_WRITE,	next: 0,};unsafe {	let head = dev.idx;	(*dev.queue).desc[dev.idx as usize] = desc_ab;	dev.idx = (dev.idx + 1) % VIRTIO_RING_SIZE as u16;	(*dev.queue).desc[dev.idx as usize] = desc_ab_mementry;	dev.idx = (dev.idx + 1) % VIRTIO_RING_SIZE as u16;	(*dev.queue).desc[dev.idx as usize] = desc_ab_resp;	dev.idx = (dev.idx + 1) % VIRTIO_RING_SIZE as u16;	(*dev.queue).avail.ring[(*dev.queue).avail.idx as usize % VIRTIO_RING_SIZE] = head;	(*dev.queue).avail.idx = (*dev.queue).avail.idx.wrapping_add(1);}</p><p>let rq = Request3 :: new（AttachBacking {hdr：CtrlHeader {ctrl_type：CtrlType :: CmdResourceAttachBacking，flags：0，fence_id：0，ctx_id：0，padding：0，}，resource_id：1，nr_entries：1，}，MemEntry {addr：dev.framebuffer as u64，length：dev.width * dev.height * size_of :: （）as u32，padding：0，}）;让desc_ab =描述符{addr：不安全{＆（* rq ）.request为* const AttachBacking as u64}，len：size_of :: （）as u32，标志：VIRTIO_DESC_F_NEXT，下一个：（dev.idx + 1）％VIRTIO_RING_SIZE as u16，}； let desc_ab_mementry =描述符{addr ：不安全{＆（* rq）.mementries为* const MemEntry as u64}，len：size_of :: （）为u32，标志：VIRTIO_DESC_F_NEXT，下一个：（dev.idx + 2）％VIRTIO_RING_SIZE为u16，} ; let desc_ab_resp =描述符{addr：不安全{＆（* rq）。响应为* const CtrlHeader as u64}，len：size_of :: （）as u32，flags：VIRTIO_DESC_F_WRITE，next：0，};不安全{让head = dev.idx; （* dev.queue）.desc [dev.idx asize] = desc_ab; dev.idx =（dev.idx +1）％VIRTIO_RING_SIZE as u16; （* dev.queue）.desc [dev.idx as usize] = desc_ab_mementry; dev.idx =（dev.idx +1）％VIRTIO_RING_SIZE as u16; （* dev.queue）.desc [dev.idx asize] = desc_ab_resp; dev.idx =（dev.idx +1）％VIRTIO_RING_SIZE as u16; （* dev.queue）.avail.ring [（* dev.queue）.avail.idx，使用率％VIRTIO_RING_SIZE] = head; （* dev.queue）.avail.idx =（* dev.queue）.avail.idx.wrapping_add（1）;}</p><p> The backing is exposed to the GPU through the MemEntry structure. This essentially is a physical address in guest RAM. The MemEntry, aside from padding, is just a pointer and a length.</p><p> 支持通过MemEntry结构暴露给GPU。这实际上是来宾RAM中的物理地址。除了填充，MemEntry只是一个指针和一个长度。</p><p> Notice that I created a new structure called Request3. This is because this step requires  three separate descriptors: (1) the header, (2) the mementry, (3) the response, whereas usually we only need two descriptors. Our structure is much like a normal Request, but it includes the mementries.</p><p> 注意，我创建了一个名为Request3的新结构。这是因为此步骤需要三个单独的描述符：（1）标头，（2）内存，（3）响应，而通常我们只需要两个描述符。我们的结构很像普通的Request，但是它包含了内存。</p><p> struct Request3&lt;RqT, RmT, RpT&gt; { request: RqT, mementries: RmT, response: RpT,}impl&lt;RqT, RmT, RpT&gt; Request3&lt;RqT, RmT, RpT&gt; { pub fn new(request: RqT, meminfo: RmT) -&gt; *mut Self { let sz = size_of::&lt;RqT&gt;() + size_of::&lt;RmT&gt;() + size_of::&lt;RpT&gt;(); let ptr = kmalloc(sz) as *mut Self; unsafe { (*ptr).request = request; (*ptr).mementries = meminfo; } ptr }}</p><p> struct Request3  {请求：RqT，内存：RmT，响应：RpT，} impl  Request3  {pub fn new（请求：RqT，meminfo： RmT）-> * mut Self {let sz = size_of :: （）+ size_of :: （）+ size_of :: （）;让ptr = kmalloc（sz）作为* mut Self;不安全{（* ptr）.request =请求； （* ptr）.mementries = meminfo; } ptr}}</p><p>  let rq = Request::new(SetScanout {	hdr: CtrlHeader {		ctrl_type: CtrlType::CmdSetScanout,		flags: 0,		fence_id: 0,		ctx_id: 0,		padding: 0,	},	r: Rect::new(0, 0, dev.width, dev.height),	resource_id: 1,	scanout_id: 0,});let desc_sso = Descriptor {	addr: unsafe { &amp;(*rq).request as *const SetScanout as u64 },	len: size_of::&lt;SetScanout&gt;() as u32,	flags: VIRTIO_DESC_F_NEXT,	next: (dev.idx + 1) % VIRTIO_RING_SIZE as u16,};let desc_sso_resp = Descriptor {	addr: unsafe { &amp;(*rq).response as *const CtrlHeader as u64 },	len: size_of::&lt;CtrlHeader&gt;() as u32,	flags: VIRTIO_DESC_F_WRITE,	next: 0,};unsafe {	let head = dev.idx;	(*dev.queue).desc[dev.idx as usize] = desc_sso;	dev.idx = (dev.idx + 1) % VIRTIO_RING_SIZE as u16;	(*dev.queue).desc[dev.idx as usize] = desc_sso_resp;	dev.idx = (dev.idx + 1) % VIRTIO_RING_SIZE as u16;	(*dev.queue).avail.ring[(*dev.queue).avail.idx as usize % VIRTIO_RING_SIZE] = head;	(*dev.queue).avail.idx = (*dev.queue).avail.idx.wrapping_add(1);}</p><p>  let rq = Request :: new（SetScanout {hdr：CtrlHeader {ctrl_type：CtrlType :: CmdSetScanout，flags：0，fence_id：0，ctx_id：0，padding：0，}，r：Rect :: new（0，0， dev.width，dev.height），resource_id：1，scanout_id：0，}）; let desc_sso =描述符{addr：不安全{＆（* rq）.request as * const SetScanout as u64}，len：size_of :: （）为u32，标志：VIRTIO_DESC_F_NEXT，下一个：（dev.idx + 1）％VIRTIO_RING_SIZE为u16，}; let desc_sso_resp =描述符{addr：不安全{＆（* rq）。以* const CtrlHeader as u64响应} ，len：size_of :: （）as u32，标志：VIRTIO_DESC_F_WRITE，下一个：0，};不安全{让head = dev.idx; （* dev.queue）.desc [dev.idx asize] = desc_sso; dev.idx =（dev.idx +1）％VIRTIO_RING_SIZE as u16; （* dev.queue）.desc [dev.idx asize] = desc_sso_resp; dev.idx =（dev.idx +1）％VIRTIO_RING_SIZE as u16; （* dev.queue）.avail.ring [（* dev.queue）.avail.idx，使用率％VIRTIO_RING_SIZE] = head; （* dev.queue）.avail.idx =（* dev.queue）.avail.idx.wrapping_add（1）;}</p><p> When we want to write to a buffer, we will refer to it by its  scanout number. If we had two scanouts, we could draw on one while the other is displayed to the screen. This is called  double-buffering, but for our purposes, we don’t do this. Instead, we draw on the same framebuffer, then transfer certain portions for the GPU to update the display.</p><p> 当我们要写入缓冲区时，将通过其扫描编号来引用它。如果我们有两个扫描，我们可以画一个，而另一个显示在屏幕上。这称为双重缓冲，但是出于我们的目的，我们不这样做。相反，我们使用相同的帧缓冲区，然后为GPU传输某些部分以更新显示。</p><p> After we signal QueueNotify, the virtio register “GO” button, then the GPU will create a new buffer internally, set the backing store, and set the scanout number to this buffer. We now have an initialized framebuffer!</p><p> 在通知QueueNotify信号后，virtio注册“ GO”按钮，然后GPU将在内部创建一个新缓冲区，设置后备存储，并将扫描输出号设置为此缓冲区。现在，我们有了一个初始化的帧缓冲区！</p><p>   We now have memory that contains pixels. However, we have our own memory, and the GPU has its own memory. So, to get ours to the GPU, it needs to be transferred. We set the backing store during initialization, so we now only have to refer to what we want updated by its scanout number.</p><p>现在，我们有了包含像素的内存。但是，我们有自己的内存，而GPU也有自己的内存。因此，要使用我们的GPU，必须先将其转移。我们在初始化期间设置了后备存储，因此我们现在只需要通过其扫描输出编号来引用我们要更新的内容。</p><p> Invalidation is important, since updating the entire screen every time we make a change is very expensive. In fact, if we transfer our entire screen, we need to transfer \(640\times 480\times 4=1,228,800\) bytes. For framerates, such as 20 or 30 frames per second, we need to transfer this number of bytes 20 or 30 times a second!</p><p> 无效很重要，因为每次更改时都要更新整个屏幕，这非常昂贵。实际上，如果我们传输整个屏幕，则需要传输\（640 \ times 480 \ times 4 = 1,228,800 \）个字节。对于每秒20或30帧的帧速率，我们需要每秒传输此字节数20或30次！</p><p> Instead of transferring everything, we invalidate certain portions of the framebuffer, and the GPU will only copy over those Pixels that fall within the invalidated region, whose coordinates are defined by a Rect structure.</p><p> 而不是传输所有内容，我们使帧缓冲区的某些部分无效，GPU只会复制落在无效区域内的那些像素，这些像素的坐标由Rect结构定义。</p><p> #[repr(C)]#[derive(Clone, Copy)]pub struct Rect {	pub x: u32,	pub y: u32,	pub width: u32,	pub height: u32,}impl Rect {	pub const fn new(x: u32, y: u32, width: u32, height: u32) -&gt; Self {		Self {			x, y, width, height		}	}}</p><p> ＃[repr（C）]＃[derive（Clone，Copy）] pub struct Rect {pub x：u32，pub y：u32，pub width：u32，pub height：u32，} impl Rect {pub const fn new（x ：u32，y：u32，宽度：u32，高度：u32）-> Self {Self {x，y，width，height}}}</p><p> Notice that this Rect is defined by an upper-left coordinate (x, y) and then a width and height. Rectangles can be defined by their coordinates (x 1, y 1), (x 2, y 2) or an initial coordinate and width and height. I don’t see anything in the spec about the former, but when I try to invalidate and transfer, it appears that it’s treating the rectangle as the latter. Oh well, more testing I guess…</p><p> 请注意，此Rect由左上角坐标（x，y）然后由宽度和高度定义。矩形可以通过其坐标（x 1，y 1），（x 2，y 2）或初始坐标以及宽度和高度来定义。我在规范中看不到任何关于前者的内容，但是当我尝试使之无效并转移时，似乎将矩形视为后者。哦，我想还有更多测试……</p><p>  Invalidating is just transferring the data from the guest (driver) to the host (GPU). This just copies the memory, to update the framebuffer, we execute a  flush command.</p><p>  无效只是将数据从来宾（驱动程序）传输到主机（GPU）。这只是复制内存，以更新帧缓冲区，我们执行刷新命令。</p><p> pub fn transfer(gdev: usize, x: u32, y: u32, width: u32, height: u32) { if let Some(mut dev) = unsafe { GPU_DEVICES[gdev-1].take() } { let rq = Request::new(TransferToHost2d { hdr: CtrlHeader {		ctrl_type: CtrlType::CmdTransferToHost2d,		flags: 0,		fence_id: 0,		ctx_id: 0,		padding: 0, },	r: Rect::new(x, y, width, height),	offset: 0,	resource_id: 1,	padding: 0,	});	let desc_t2h = Descriptor {		addr: unsafe { &amp;(*rq).request as *const TransferToHost2d as u64 },		len: size_of::&lt;TransferToHost2d&gt;() as u32,		flags: VIRTIO_DESC_F_NEXT,		next: (dev.idx + 1) % VIRTIO_RING_SIZE as u16,	};	let desc_t2h_resp = Descriptor {		addr: unsafe { &amp;(*rq).response as *const CtrlHeader as u64 },		len: size_of::&lt;CtrlHeader&gt;() as u32,		flags: VIRTIO_DESC_F_WRITE,		next: 0,	};	unsafe {		let head = dev.idx;		(*dev.queue).desc[dev.idx as usize] = desc_t2h;		dev.idx = (dev.idx + 1) % VIRTIO_RING_SIZE as u16;		(*dev.queue).desc[dev.idx as usize] = desc_t2h_resp;		dev.idx = (dev.idx + 1) % VIRTIO_RING_SIZE as u16;		(*dev.queue).avail.ring[(*dev.queue).avail.idx as usize % VIRTIO_RING_SIZE] = head;		(*dev.queue).avail.idx = (*dev.queue).avail.idx.wrapping_add(1);	}	// Step 5: Flush	let rq = Request::new(ResourceFlush {		hdr: CtrlHeader {			ctrl_type: CtrlType::CmdResourceFlush,			flags: 0,			fence_id: 0,			ctx_id: 0,			padding: 0,		},		r: Rect::new(x, y, width, height),		resource_id: 1,		padding: 0,	});	let desc_rf = Descriptor {		addr: unsafe { &amp;(*rq).request as *const ResourceFlush as u64 },		len: size_of::&lt;ResourceFlush&gt;() as u32,		flags: VIRTIO_DESC_F_NEXT,		next: (dev.idx + 1) % VIRTIO_RING_SIZE as u16,	};	let desc_rf_resp = Descriptor {		addr: unsafe { &amp;(*rq).response as *const CtrlHeader as u64 },		len: size_of::&lt;CtrlHeader&gt;() as u32,		flags: VIRTIO_DESC_F_WRITE,		next: 0,	};	unsafe {		let head = dev.idx;		(*dev.queue).desc[dev.idx as usize] = desc_rf;		dev.idx = (dev.idx + 1) % VIRTIO_RING_SIZE as u16;		(*dev.queue).desc[dev.idx as usize] = desc_rf_resp;		dev.idx = (dev.idx + 1) % VIRTIO_RING_SIZE as u16;		(*dev.queue).avail.ring[(*dev.queue).avail.idx as usize % VIRTIO_RING_SIZE] = head;		(*dev.queue).avail.idx = (*dev.queue).avail.idx.wrapping_add(1);	}	// Run Queue	unsafe {		dev.dev		.add(MmioOffsets::QueueNotify.scale32())		.write_volatile(0);		GPU_DEVICES[gdev-1].replace(dev);	}}</p><p> pub fn transfer（gdev：usize，x：u32，y：u32，width：u32，height：u32）{如果让Some（mut dev）=不安全{GPU_DEVICES [gdev-1] .take（）} {让rq = Request :: new（TransferToHost2d {hdr：CtrlHeader {ctrl_type：CtrlType :: CmdTransferToHost2d，flags：0，fence_id：0，ctx_id：0，padding：0，}，r：Rect :: new（x，y，width，height ），偏移量：0，resource_id：1，填充：0，}）； let desc_t2h =描述符{addr：不安全{＆（* rq）.request为* const TransferToHost2d as u64}，len：size_of :: （）as u32，标志：VIRTIO_DESC_F_NEXT，下一个：（dev.idx + 1） ％VIRTIO_RING_SIZE如u16，}； let desc_t2h_resp =描述符{addr：不安全{＆（* rq）.response as * const CtrlHeader as u64}，len：size_of :: （）as u32，flags：VIRTIO_DESC_F_WRITE，next：0，};不安全的{让head = dev.idx; （* dev.queue）.desc [dev.idx asize] = desc_t2h; dev.idx =（dev.idx +1）％VIRTIO_RING_SIZE as u16; （* dev.queue）.desc [dev.idx as usize] = desc_t2h_resp; dev.idx =（dev.idx +1）％VIRTIO_RING_SIZE as u16; （* dev.queue）.avail.ring [（* dev.queue）.avail.idx，使用率％VIRTIO_RING_SIZE] = head; （* dev.queue）.avail.idx =（* dev.queue）.avail.idx.wrapping_add（1）; } //步骤5：刷新let rq = Request :: new（ResourceFlush {hdr：CtrlHeader {ctrl_type：CtrlType :: CmdResourceFlush，flags：0，fence_id：0，ctx_id：0，padding：0，}，r：Rect： ：new（x，y，width，height），resource_id：1，padding：0，}）; let desc_rf =描述符{addr：不安全{＆（* rq）.request为* const ResourceFlush as u64}，len：size_of :: （）as u32，标志：VIRTIO_DESC_F_NEXT，下一个：（dev.idx + 1） ％VIRTIO_RING_SIZE如u16，}； let desc_rf_resp =描述符{addr：不安全{＆（* rq）.response为* const CtrlHeader as u64}，len：size_of :: （）as u32，标志：VIRTIO_DESC_F_WRITE，下一个：0，}；不安全的{让head = dev.idx; （* dev.queue）.desc [dev.idx asize] = desc_rf; dev.idx =（dev.idx +1）％VIRTIO_RING_SIZE as u16; （* dev.queue）.desc [dev.idx asize] = desc_rf_resp; dev.idx =（dev.idx +1）％VIRTIO_RING_SIZE as u16; （* dev.queue）.avail.ring [（* dev.queue）.avail.idx，使用率％VIRTIO_RING_SIZE] = head; （* dev.queue）.avail.idx =（* dev.queue）.avail.idx.wrapping_add（1）; } //运行队列不安全{dev.dev .add（MmioOffsets :: QueueNotify.scale32（））.write_volatile（0）; GPU_DEVICES [gdev-1] .replace（dev）; }}</p><p> So, our transfer first tells the host that we’ve updated a certain portion of the framebuffer, which is specified as x, y, width, and height. Then we do what is called a  resource flush to get the GPU to commit all transfers to the screen.</p><p>因此，我们的传输首先告诉主机我们已经更新了帧缓冲区的特定部分，指定为x，y，宽度和高度。然后，我们进行所谓的资源刷新，以使GPU将所有传输提交到屏幕。</p><p>   This is a fairly easy section. Most of the device responses come in the form of  NODATA, which is just an acknowledgment that it made the request. Also, notice that unlike the block driver, we don’t have watchers here. This allows us to asynchronously update the screen.</p><p>   这是一个相当简单的部分。大多数设备响应都以NODATA的形式出现，这只是对它发出请求的确认。另外，请注意，与块驱动程序不同，我们这里没有观察者。这使我们可以异步更新屏幕。</p><p>   The whole point of this is to get a user space application drawing stuff to the screen. Generally, we wouldn’t give the full framebuffer to any user space application that wants it, but for our purposes, we can live with it for now. Instead, we would have a  window manager delegate certain rectangles of the framebuffer to different applications. The window manager would also be responsible for handling events and sending the appropriate events to the GUI application.</p><p>   这样做的全部目的是使用户空间应用程序将内容绘制到屏幕上。通常，我们不会将完整的帧缓冲区提供给任何需要它的用户空间应用程序，但是出于我们的目的，我们现在可以使用它。相反，我们需要一个窗口管理器将帧缓冲区的某些矩形委托给不同的应用程序。窗口管理器还将负责处理事件并将适当的事件发送到GUI应用程序。</p><p>  To allow our userspace applications to use the GPU, we need two system calls. One to get a pointer to the framebuffer. Recall that we first must map the framebuffer to the userspace’s MMU table. This is why we allocated pages instead of using kmalloc.</p><p>  为了允许我们的用户空间应用程序使用GPU，我们需要两个系统调用。一个获得指向帧缓冲区的指针。回想一下，我们首先必须将帧缓冲区映射到用户空间的MMU表。这就是为什么我们分配页面而不使用kmalloc的原因。</p><p> let dev = (*frame).regs[Registers::A0 as usize];(*frame).regs[Registers::A0 as usize] = 0;if dev &gt; 0 &amp;&amp; dev &lt;= 8 {	if let Some(p) = gpu::GPU_DEVICES[dev - 1].take() {		let ptr = p.get_framebuffer() as usize;		gpu::GPU_DEVICES[dev-1].replace(p);		if (*frame).satp &gt;&gt; 60 != 0 {			let p = get_by_pid((*frame).pid as u16);			let table = ((*p).get_table_address()						 as *mut Table)						.as_mut()						.unwrap(); let num_pages = (p.get_width() * p.get_height() * 4) as usize / PAGE_SIZE;			for i in 0..num_pages {				let vaddr = 0x3000_0000 + (i &lt;&lt; 12);				let paddr = ptr + (i &lt;&lt; 12);				map(table, vaddr, paddr, EntryBits::UserReadWrite as i64, 0);			}		}		(*frame).regs[Registers::A0 as usize] = 0x3000_0000;	}}</p><p> let dev =（* frame）.regs [以usize为单位的Registers :: A0];（* frame）.regs [以usize的形式Registers :: A0 assize] = 0; if dev> 0 && dev > 60！= 0 {让p = get_by_pid（（* frame）.pid as u16）; let table =（（** p..get_table_address（）as * mut Table）.as_mut（）.unwrap（）;让num_pages =（p.get_width（）* p.get_height（）* 4）作为usize / PAGE_SIZE;对于0..num_pages中的i {让vaddr = 0x3000_0000 +（i << 12）;令paddr = ptr +（i << 12）; map（table，vaddr，paddr，EntryBits :: UserReadWrite为i64，0）; }}（* frame）.regs [Registers :: A0 as usize] = 0x3000_0000; }}</p><p> As you can see above, we grab the framebuffer from the GPU device and map it to 0x3000_0000. Currently, I calculate the number of pages for the framebuffer, which is \(\frac{640\times 480\times 4}{4,096}=300\). So, we need exactly 300 pages for this resolution.</p><p> 如您在上面看到的，我们从GPU设备获取帧缓冲区并将其映射到0x3000_0000。当前，我计算帧缓冲区的页数为\（\ frac {640 \ times 480 \ times 4} {4,096} = 300 \）。因此，此分辨率我们需要300页。</p><p> So, now we have a framebuffer, so the userspace application can write what it wants into this memory location. However, a write doesn’t immediately update the screen. Recall that we must transfer and then flush to get the results written to the screen. This is where our second system call comes into play.</p><p> 因此，现在我们有了一个帧缓冲区，以便用户空间应用程序可以将所需内容写入此内存位置。但是，写入操作不会立即更新屏幕。回想一下，我们必须先传输然后刷新才能将结果写入屏幕。这是我们的第二个系统调用起作用的地方。</p><p> let dev = (*frame).regs[Registers::A0 as usize];let x = (*frame).regs[Registers::A1 as usize] as u32;let y = (*frame).regs[Registers::A2 as usize] as u32;let width = (*frame).regs[Registers::A3 as usize] as u32;let height = (*frame).regs[Registers::A4 as usize] as u32;gpu::transfer(dev, x, y, width, height);</p><p>让dev =（* frame）.regs [寄存器:: A0作为usize];让x =（* frame）.regs [寄存器:: A1作为usize]为u32;让y =（* frame）.regs [寄存器： ：A2 as usize]作为u32; let width =（* frame）.regs [Registers :: A3 as usize] as u32; let height =（* frame）.regs [Registers :: A4 as usize] as u32; gpu： ：transfer（dev，x，y，width，height）;</p><p> I showed the transfer function above, which just makes two requests: (1) CmdTransferToHost2d and (2) CmdResourceFlush. When the userspace application makes this system call, the results will be flushed to the screen and hence, it’ll be visible to the user. I don’t error check in the system call itself. The transfer function will error check the device, and the device will error check the x, y, width, and height. So, if this is incorrect, the transfer function will silently fail, and nothing will update to the screen.</p><p> 我在上面显示了传递函数，它仅发出两个请求：（1）CmdTransferToHost2d和（2）CmdResourceFlush。当用户空间应用程序进行此系统调用时，结果将刷新到屏幕上，因此对用户可见。我不会在系统调用本身中进行错误检查。传递函数将错误检查设备，并且设备将错误检查x，y，宽度和高度。因此，如果这是不正确的，则传输功能将静默失败，并且屏幕上将不会更新任何内容。</p><p>   To see something displayed to the screen, we need to be able to draw the simpl</p><p>   要查看屏幕上显示的内容，我们需要能够绘制出简单</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.stephenmarz.com/2020/11/11/risc-v-os-using-rust-graphics/">https://blog.stephenmarz.com/2020/11/11/risc-v-os-using-rust-graphics/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/操作系统/">#操作系统</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/output/">#output</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gpu/">#gpu</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>