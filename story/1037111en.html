<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从Panfrost到生产，都是开源图形的故事From Panfrost to production, a tale of Open Source graphics</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">From Panfrost to production, a tale of Open Source graphics<br/>从Panfrost到生产，都是开源图形的故事</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-29 15:08:35</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/bbaf478fad6f8d298feedd8d696e8277.png"><img src="http://img2.diglog.com/img/2020/11/bbaf478fad6f8d298feedd8d696e8277.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Since our  previous update on Panfrost, the open source stack for Arm&#39;s Mali Midgard and Bifrost GPUs, we&#39;ve focused on taking our driver from its reverse-engineered origins on Midgard to a mature stack. We&#39;ve overhauled both the Gallium driver and the backend compiler, and as a result, Mesa 20.3 -- scheduled for release at the end-of-the-month --  will feature some Bifrost support out-of-the-box.</p><p>自从上次更新Panfrost（用于Arm的Mali Midgard和Bifrost GPU的开源堆栈）以来，我们一直致力于将驱动程序从Midgard的反向工程起源发展到成熟的堆栈。我们已经全面改革了Gallium驱动程序和后端编译器，因此，Mesa 20.3（计划于月底发布）将具有一些Bifrost支持。</p><p>      For the first years of Panfrost, everything we knew about the hardware was from reverse-engineering, an understanding superseded by canonical information on the hardware. For example, we now know canonical names for data structures and instructions for which we had picked names arbitrarily during reverse-engineering. To accelerate driver development, removing unknown magic fields and exposing logical errors, we needed to integrate this new information. Our approach was two prong:</p><p>      在Panfrost成立的头几年，我们对硬件的所有了解都来自于逆向工程，这种理解已被有关硬件的规范信息所取代。例如，我们现在知道数据结构和指令的规范名称，而在逆向工程过程中我们随意选择了它们的名称。为了加速驱动程序开发，删除未知的魔术场并暴露逻辑错误，我们需要集成此新信息。我们的方法有两个方面：</p><p>    GenXML is a tool developed for the open source Intel graphics drivers and modified for use in the VideoCore drivers. For Panfrost, we modified the Broadcom GenXML to produce our own Panfrost flavour of GenXML optimized for Mali GPUs.</p><p>    GenXML是为开源Intel图形驱动程序开发的工具，并经过修改以在VideoCore驱动程序中使用。对于Panfrost，我们修改了Broadcom GenXML，以生成针对Mali GPU优化的我们自己的Panfrost GenXML风格。</p><p>    While reverse-engineering, it was convenient to lay out data structures as ad hoc bitfields in a C header file:</p><p>    在进行逆向工程时，将数据结构布置为C头文件中的临时位域非常方便：</p><p>  struct mali_blend_mode { enum mali_blend_modifier clip_modifier : 2; unsigned unused_0 : 1; unsigned negate_source : 1; enum mali_dominant_blend dominant : 1; enum mali_nondominant_mode nondominant_mode : 1; unsigned unused_1 : 1; unsigned negate_dest : 1; enum mali_dominant_factor dominant_factor : 3; unsigned complement_dominant : 1;} __attribute__((packed));</p><p>  struct mali_blend_mode { 枚举mali_blend_modifier clip_modifier：2; 未签名的unused_0：1； 无符号negate_source：1; 列举mali_dominant_blend优势：1; 枚举mali_nondominant_mode nondominant_mode：1; 未签名的unused_1：1； 无符号negate_dest：1; 枚举mali_dominant_factor relative_factor：3; 无符号complement_dominant：1;} __attribute __（（packed））;</p><p>    &lt;struct name=&#34;Blend Function&#34; no-direct-packing=&#34;true&#34;&gt; &lt;!-- Blend equation: A + (B * C) --&gt; &lt;field name=&#34;A&#34; size=&#34;2&#34; start=&#34;0&#34; type=&#34;Blend Operand A&#34;/&gt; &lt;field name=&#34;Negate A&#34; size=&#34;1&#34; start=&#34;3&#34; type=&#34;bool&#34;/&gt; &lt;field name=&#34;B&#34; size=&#34;2&#34; start=&#34;4&#34; type=&#34;Blend Operand B&#34;/&gt; &lt;field name=&#34;Negate B&#34; size=&#34;1&#34; start=&#34;7&#34; type=&#34;bool&#34;/&gt; &lt;field name=&#34;C&#34; size=&#34;3&#34; start=&#34;8&#34; type=&#34;Blend Operand C&#34;/&gt; &lt;field name=&#34;Invert C&#34; size=&#34;1&#34; start=&#34;11&#34; type=&#34;bool&#34;/&gt;&lt;/struct&gt;</p><p>           </p><p>  Then, instead of directly filling out the bitfield, we can use automatically generated packing macros which are easier to use by abstracting packing details away from the programmer. They are less error prone, as the packing writes to memory contiguously and only once all data is finalized, avoiding subtle errors where bitfields lead to the CPU reading back GPU memory, which is slower than a contiguous write by an order of magnitude due to cache behaviour. They also perform better handling of integer overflow: while bitfields are defined to wrap around (rarely desired behaviour, often hiding bugs, and requiring an extra bitwise-and instruction at run-time), GenXML forbids overflow. As such, debug builds validate the range of integer values, identifying bugs early on, and release builds may omit the checks entirely and come out faster than bitfields. All in all, the direct benefits of GenXML for us are clear.</p><p>  然后，代替直接填充位域，我们可以使用自动生成的打包宏，通过从程序员那里提取打包详细信息，可以更轻松地使用打包宏。它们不易出错，因为打包连续写入存储器，并且仅在所有数据完成后才写入，避免了细微的错误（位域导致CPU回读GPU存储器），这种错误比连续写入慢了一个数量级，原因是缓存行为。它们还可以更好地处理整数溢出：虽然定义了位域来回绕（非常需要的行为，经常隐藏错误，并且在运行时需要额外的按位和指令），但GenXML禁止溢出。这样，调试版本会验证整数值的范围，尽早发现错误，发布版本可能会完全忽略检查，并且比位域的发布速度更快。总而言之，GenXML对我们的直接好处是显而易见的。</p><p>  More importantly, the process of transitioning to GenXML let us revisit every GPU data structure used in the driver, correcting misunderstandings as seen in the above blend function descriptor, which has a ripple effect in correcting long-standing bugs due to misunderstandings of the hardware. As a real example, the above blend function rework fixed a conspicuous bug in the fixed-function blending for subtract and reverse-subtract blend modes, avoiding a needless fallback to the slower &#34;blend shader&#34; path. Indeed, many of the changes necessitated by the GenXML refactor transcended aesthetic concerns and led to optimizations and bug fixes affecting all of our GPUs. That&#39;s a good refactor in my book.</p><p>更重要的是，过渡到GenXML的过程使我们可以重新访问驱动程序中使用的每个GPU数据结构，更正上述混合函数描述符中所看到的误解，这在纠正由于对硬件的误解而导致的长期错误方面具有连锁反应。作为一个真实的示例，上述混合函数重做修复了固定函数混合中用于减法和反向减法混合模式的显着错误，避免了不必要的回退到较慢的“混合着色器”路径。确实，GenXML重构需要进行的许多更改都超出了美学方面的考虑，并导致影响我们所有GPU的优化和错误修复。这是我书中很好的重构。</p><p>    For the Bifrost compiler, we wanted to take a similar approach, auto-generating our handling of instruction encoding to account for new information about the complete Bifrost instruction set. Unfortunately, Bifrost packing is highly irregular, where _every_ instruction can have numerous encodings with no relation to any other instruction. This allows the hardware to perform unique optimizations to reduce code size and improve the instruction cache hit rate, but it complicates the compiler and prevents the use of off-the-shelf tooling like GenXML.</p><p>    对于Bifrost编译器，我们希望采用类似的方法，自动生成指令编码处理，以说明有关完整Bifrost指令集的新信息。不幸的是，Bifrost打包非常不规则，其中_every_指令可以具有许多编码，而与任何其他指令都没有关系。这使硬件可以执行独特的优化以减小代码大小并提高指令缓存命中率，但会使编译器复杂化，并阻止使用GenXML等现成的工具。</p><p>  Our solution was to represent the instruction set with a custom XML-based file format designed to account for Bifrost&#39;s many quirks, serving as ground truth for the machine. The file lists every instruction, with entries like:</p><p>  我们的解决方案是使用基于XML的自定义文件格式来表示指令集，该格式旨在解决Bifrost的许多怪癖，并作为机器的基础。该文件列出了每条指令，并带有以下条目：</p><p>  &lt;ins name=&#34;+LD_CVT&#34; staging=&#34;w&#34; mask=&#34;0xff800&#34; exact=&#34;0xc9000&#34;&gt; &lt;src start=&#34;0&#34;/&gt; &lt;src start=&#34;3&#34;/&gt; &lt;src start=&#34;6&#34; mask=&#34;0xf7&#34;/&gt; &lt;mod name=&#34;vecsize&#34; start=&#34;9&#34; size=&#34;2&#34;&gt; &lt;opt&gt;none&lt;/opt&gt; &lt;opt&gt;v2&lt;/opt&gt; &lt;opt&gt;v3&lt;/opt&gt; &lt;opt&gt;v4&lt;/opt&gt; &lt;/mod&gt;&lt;/ins&gt;</p><p>       无  v2   v3   v4  </p><p>  Notice in particular there is no opcode specified, unlike regular architectures. Instead, the exact and mask fields together specify that specific bits of the instruction must take particular values, acting as a generalized opcode.</p><p>  特别注意，与常规体系结构不同，没有指定操作码。相反，确切字段和掩码字段一起指定了指令的特定位必须采用特定值，用作通用操作码。</p><p>  From the instruction reference, we can autogenerate functions to pack instructions from the compiler&#39;s immediate representation and to disassemble instructions from packed forms in the disassembler. Notice instruction encoding and disassembly are higher-level functions than the simple packs and unpacks handled by GenXML; the irregularity of Bifrost demands such an approach. Nevertheless, we now have a complete Bifrost (architecture version 7) disassembler open source and upstream, and as we&#39;ve extended the compiler, the packing helpers have paid off beautifully.</p><p>  从指令参考中，我们可以自动生成函数以从编译器的即时表示中打包指令，并从反汇编程序中的打包形式中反汇编指令。注意指令的编码和反汇编是比GenXML处理的简单打包和解压缩更高级的功能。 Bifrost的不规则性要求采取这种方法。尽管如此，我们现在已经拥有完整的Bifrost（体系结构版本7）开源和上游反汇编程序，并且随着我们对编译器的扩展，打包帮助者获得了丰厚的回报。</p><p>  With our new infastructure in place, we could iterate quickly on compiler features like nested control-flow, complex texturing including texel fetch support from OpenGL ES 3.0 used in Mesa&#39;s blitter, and basic register spilling. In total, the open source Bifrost compiler can now handle the notorious gradient rendering shaders from glamor, the OpenGL backend for the X server. With these changes, Bifrost can now run X11 desktops like MATE, as well as X applications on Wayland desktops via Xwayland. Never mind _why_ loops and register spilling are used for 2D acceleration.</p><p>  有了新的基础架构，我们就可以快速迭代编译器功能，例如嵌套控制流，复杂的纹理处理，包括Mesa阻击器中使用的OpenGL ES 3.0的texel fetch支持以及基本的寄存器溢出。总体而言，开源Bifrost编译器现在可以处理Glam臭名昭著的渐变渲染着色器，Glamour是X服务器的OpenGL后端。通过这些更改，Bifrost现在可以运行X11桌面（如MATE），以及通过Xwayland在Wayland桌面上运行X应用程序。没关系_why_循环和寄存器溢出用于2D加速。</p><p>    For those of you with GPUs like Mali T860, Panfrost&#39;s support for Midgard has improved as well. Though the Bifrost compiler is a separate code base, the improvements via GenXML benefit Midgard. Beyond that, over the summer we  added support for Arm FrameBuffer Compression (AFBC) as a significant optimization for certain workloads.</p><p>对于使用Mali T860等GPU的人来说，Panfrost对Midgard的支持也得到了改善。尽管Bifrost编译器是单独的代码库，但通过GenXML进行的改进使Midgard受益。除此之外，在夏天，我们增加了对Arm FrameBuffer压缩（AFBC）的支持，这是对某些工作负载的重大优化。</p><p>  Recent builds of Mesa will automatically compress framebuffer objects to save memory bandwidth, improve performance, and reduce power. Panfrost is even smart enough to compress textures as AFBC on the fly when it makes sense to do so, improving texturing performance for applications that do not support compressed texture formats like ETC directly. In the future, Panfrost will be able to compress the framebuffer itself en route to the display if paired with a compatible display controller, further reducing bandwidth on high resolution monitors. AFBC work was conducted on a Midgard GPU, but will be extended to Bifrost in the future.</p><p>  Mesa的最新版本将自动压缩帧缓冲对象，以节省内存带宽，提高性能并降低功耗。 Panfrost甚至足够聪明，可以在需要时动态地压缩纹理作为AFBC，从而为不直接支持压缩纹理格式（例如ETC）的应用程序提高了纹理处理性能。将来，如果与兼容的显示控制器配对使用，Panfrost将能够压缩帧缓冲区本身，以将其传输到显示器，从而进一步减少高分辨率监视器的带宽。 AFBC的工作是在Midgard GPU上进行的，但将来会扩展到Bifrost。</p><p>  The Midgard compiler also saw a flurry of activity, improving its scheduler to optimize for register pressure, supporting atomic operations and atomic counters, and fixing a long-tail of bugs.</p><p>  Midgard编译器还看到了一系列活动，改进了调度程序以优化寄存器压力，支持原子操作和原子计数器，并修复了很多错误。</p><p>    The above work on Bifrost and GenXML has been a collaboration between Collaboran Boris Brezillon and myself. Additionally, our intern, Italo Nicola, has been improving support for compute shaders on Midgard and spearheaded the atomic operation support.</p><p>    以上关于Bifrost和GenXML的工作是Collaboran Boris Brezillon和我本人之间的合作。此外，我们的实习生Italo Nicola一直在改进Midgard上对计算着色器的支持，并带头推动了原子操作支持。</p><p>  I&#39;d like to give a special shoutout to the outstanding Icecream95, who has added features including 16-bit depth buffers, desktop-style occlusion counters, 8 simultaneous render targets, dual-source blending, and framebuffer fetch. Icecream95 has focused on desktop OpenGL support for Midgard GPUs and has made strides here, fixing and optimizing a spectrum of 3D games never thought to run on embedded hardware like ours.</p><p>  我想特别感谢杰出的Icecream95，他添加了包括16位深度缓冲区，桌面样式遮挡计数器，8个同时渲染目标，双源混合和帧缓冲区获取的功能。 Icecream95专注于对Midgard GPU的桌面OpenGL支持，并在此取得了长足的进步，修复和优化了一系列3D游戏，这些游戏从未在像我们这样的嵌入式硬件上运行过。</p><p>  Please tick this box to confirm you have read and accept the terms of our  privacy notice regarding collection/storage and usage of your personal data: *</p><p>  请在此方框中打勾，以确认您已阅读并接受我们的隐私声明中有关收集/存储和使用您的个人数据的条款：*</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.collabora.com/news-and-blog/blog/2020/11/03/from-panfrost-to-production-a-tale-of-open-source-graphics/">https://www.collabora.com/news-and-blog/blog/2020/11/03/from-panfrost-to-production-a-tale-of-open-source-graphics/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/开源/">#开源</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/图形/">#图形</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/genxml/">#genxml</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>