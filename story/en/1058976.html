<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>没有人期待...... Nobody Expects...</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Nobody Expects...<br/>没有人期待...... </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-18 18:25:17</div><div class="page_narrow text-break page_content"><p>Well, that too, but also nobody expects that a bland, run-of-the mill Novell NE2000 NDIS driver would crash/hang just because it runs on 486 or later CPUs.</p><p>好吧，也是没有人预计，磨坊的跑道Novell Ne02000 NDIS驱动程序只会因为它在486或更高版本的CPU上运行而崩溃/挂起。</p><p> I wanted to try the “basic” DOS redirector shipped with Microsoft’s LAN Manager 2.0 (1990) and more or less by a flip of a coin I decided to use the NE2000 NDIS driver that came with the package. Previously I had no trouble with Microsoft’s NE2000.DOS driver shipped with LAN Manager 2.1 and Microsoft’s Network Client 2.0.</p><p> 我想尝试使用Microsoft的LAN Manager 2.0（1990）附带的“基本”DOS重定向器，越来越多的硬币翻转我决定使用包装附带的NE2000 NDIS驱动程序。此前我毫无疑问，Microsoft的NE2000.DOS驱动程序与LAN Manager 2.1和Microsoft网络客户端2.0一起发布。</p><p> But the old LAN Manager NE2000.DOS driver (16,342 bytes, dated 11-19-90, calls itself version 0.31) loaded and then promptly hung as soon as Netbind was started:</p><p> 但旧的LAN经理NE2000.DOS驱动程序（16,342字节，日期为11-19-90，拨打自己版本0.31）加载，然后一旦NetBind启动，就会及时悬挂：</p><p>  At first I naturally suspected some problem with the card configuration or the NIC hardware, but what I found was much more surprising.</p><p>  起初我自然怀疑了卡配置或网卡硬件的一些问题，但我发现的东西更令人惊讶。</p><p> The reason the driver hung actually wasn’t related to networking  at all. The driver hung in a routine that was clearly trying to detect the CPU type. How can someone screw something so simple so badly? Well…</p><p> 驱动程序挂起的原因实际上与网络无关。驾驶员在一个明显试图检测到CPU类型的例程中挂起的例程。有人怎么能如此简单地搞砸？出色地…</p><p>  The problem perhaps illustrates the abusive relationship between Intel and Microsoft. Intel told developers how to detect the CPU generation (before CPUID simplified things). Microsoft went ahead and completely ignored that advice, perhaps feeling safe in the knowledge that Intel wouldn’t dare break Microsoft’s code. Except in this case Intel had no choice.</p><p>  问题可能是说明英特尔与微软之间的滥用关系。英特尔告诉开发人员如何检测CPU生成（在CPUID中简化的东西之前）。微软继续彻底忽略了这一建议，也许在英特尔不敢打破微软的代码的知识中感到安全。除了在这种情况下，英特尔别无选择。</p><p> A bit of background: The NE2000 driver has a good reason to detect whether it’s running on a 286 or later CPU. If it does, it can use REP INSW and REP OUTSW instructions to get data to and from the card. Even if the NE2000 were in an 8-bit slot, the driver could still use REP INSB and REP OUTSB, significantly superior to pushing data one byte at a time in a loop.</p><p> 有点背景：NE2000驱动程序有一个充分的理由检测它是否在286或更高版本的CPU上运行。如果它确实，它可以使用REC INSW和REP OUTSW指令从卡中获取数据。即使NE2000处于8位插槽，驾驶员仍然可以使用REC INSB和REP OutsB，显着优于循环中的时间按下数据一个字节。 </p><p> The driver has a less pressing but still sensible reason to detect a 386 CPU. It can use REP MOVSD for memory copies, which might have some noticeable impact on the network driver performance.</p><p>驾驶员的压力较少但仍然明智的原因来检测386 CPU。它可以使用Rep Movsd用于内存副本，这可能对网络驱动程序性能产生一些显着的影响。</p><p> The driver has in my opinion absolutely no need to detect whether the CPU is a 486, but it does, and that’s where things go wrong. The CPU detection in the driver is interesting and flawed enough that I’ll quote it in full (the labels and comments are mine):</p><p> 司机在我看来绝对无需检测CPU是否为486，但它确实如此，这就是事情的错误。驾驶员中的CPU检测很有意思，并且足够缺陷，我将完整引用它（标签和评论是我的）：</p><p> sgdt_buffer db 6 dup(0FFh)detect_cpu proc near push bp mov bp, sp push sp pop ax cmp sp, ax ; Will be equal on 80186+ jz short not_8086 mov ax, 1 ; Indicate 8086 stc jmp short quitnot_8086: ; 286 won&#39;t write last byte sgdt fword ptr ds:sgdt_buf sar ds:sgdt_buf+5, 1 ; Low bit to carry flag jnc short not_286 ; Will be set on 286 stc mov ax, 11h ; Indicate 286 jmp short quitnot_286: mov ebx, cr0 ; Read CR0, save in EBX mov eax, ebx xor eax, 20000000h ; Try flipping WT bit mov cr0, eax mov eax, cr0 ; Read new CR0 value mov cr0, ebx ; Restore original value cmp eax, ebx ; Did CR0 actually change? jnz cr0_differs clc mov ax, 20h ; CR0 unchanged: 386 jmp short quitcr0_differs: mov ax, 40h ; CR0 changed, must be 486+ clcquit: mov sp, bp pop bp retndetect_cpu endp</p><p> SGDT_BUFFER DB 6 DUP（0FFH）检测_CPU PROP接近推式BP MOV BP，SP POP AX CMP SP，AX;将在80186+ JZ SHORT NOT_8086 MOV AX，1;表示8086 STC JMP短QuitNot_8086：; 286 Won＆＃39; T写下最后一个字节SGDT FWOW PTR DS：SGDT_BUF SAR DS：SGDT_BUF + 5,1;低点携带标志JNC短not_286;将设置在286 STC MOV AX，11h;表示286 JMP短QuitNot_286：MOV EBX，CR0;读取CR0，保存在EBX MOV EAX，EBX XOR EAX，20000000H;尝试翻转WT位MOV CR0，EAX MOV EAX，CR0;阅读新的CR0值MOV CR0，EBX;恢复原始值CMP EAX，EBX; CR0实际上是否改变了？ JNZ CR0_DIFFERS CLC MOV AX，20h; CR0不变：386 JMP短语QuitCr0_differs：Mov Ax，40h; CR0已更改，必须是486+ Clcquit：Mov SP，BP POP BP RetnDetect_CPU ENDP</p><p> The first part of the code is actually quite common and takes advantage of the fact that on the 8086/8088, PUSH SP actually pushed the new value of SP on the stack, while all later CPUs push the old value. The detection code, if anything, demonstrates why the 8086 behavior didn’t make sense: A sequence of PUSH SP / POP SP actually changed SP, and on newer CPUs it does not.</p><p> 代码的第一部分实际上非常常见，并且利用了8086/8088的事实，推动SP实际上将SP的新值推动在堆栈上，而所有后来的CPU都会推动旧值。检测代码（如果有的话）演示8086行为没有意义：一系列推送SP / POP SP实际上改变了SP，并且在较新的CPU上它没有。</p><p> The next part is where things start getting problematic. The code assumes that if the CPU is not an 8086, it must be at least an 80286 and will be able to execute a SGDT instruction. It is true that PCs with 80186 were not at all common, but this code would crash and burn on an 80186 because SGDT does not exist there.</p><p> 下一个部分是事情开始发生问题的地方。代码假定如果CPU不是8086，则它必须至少为80286并且能够执行SGDT指令。确实，具有80186的PC并不常见，但此代码将在80186上崩溃并刻录，因为SGDT不存在。</p><p> On a 286 and later, SGDT will execute happily, and due to rather questionable design, it is  not a privileged instruction. Now, the SGDT instruction is a bit funny, or rather  Intel’s documentation of SGDT/SIDT is. The code is written to assume that a 286 will either store the sixth byte as all ones (which I believe is what happens) or not write it at all. The code also assumes that a 386+ SGDT  will always write six bytes, which in fact happens despite what Intel’s documentation might say.</p><p> 在286及更高版本上，SGDT将愉快地执行，并且由于设计相当可疑，它不是一个特权指令。现在，SGDT指令有点有趣，而不是英特尔的SGDT / SIDT文档是。编写代码以假设286将将第六个字节存储为所有（我相信发生的事情）或根本不写它。代码还假设386+ SGDT将始终写入六个字节，这实际上仍然发生在英特尔的文档可能会说。</p><p> The code further assumes that the high byte of the 32-bit GDT base address won’t have its low bit set. That’s actually a poor assumption, because although it will be true after CPU reset, the CPU might be running in V86 mode or it might have switched to protected mode and back, and there’s no telling what GDTR might contain. Sure, if you are absolutely certain the PC can’t have more than 16 MB RAM, then the high byte of GDTR probably will be clear, but it’s just not a safe assumption.</p><p> 代码进一步假设32位GDT基地址的高字节不会具有其低位集。这实际上是一个糟糕的假设，因为虽然CPU重置后它将是真的，但CPU可能以V86模式运行，或者它可能已切换到受保护模式和后退，并且没有讲述GDTR可能包含的GDR。当然，如果你绝对确定PC不能有超过16 MB的RAM，那么GDTR的高字节可能会很清楚，但这只是一个安全的假设。 </p><p> Using the SIDT instruction would have been slightly better because at least in real mode it has to point at the IVT, but even then it might confuse the detection in V86 mode. In other words… there’s a reason why this method of detecting a 386 isn’t often used.</p><p>使用SIDT指令将稍微更好，因为至少在实模式下它必须指向IVT，但即便如此，它可能会在V86模式下混淆检测。换句话说......有原因是为什么不使用这种检测386的方法。</p><p> That said, the worst that can happen is that the driver thinks it’s running on a 286 when it’s really running on a 386 or newer processor, and it might run a little slower but most likely no one will even notice.</p><p> 也就是说，可能发生的最糟糕的是，当驾驶员在386或更新的处理器上真正运行时，驾驶员会在286上运行，它可能会略微慢，但很可能没有人会注意到。</p><p> But now we get to the real problem, which is 486 detection. Again, I don’t know why the code is even trying to detect a 486, since the NE2000 driver really does not care whether the CPU is a 386 or 486. I can only assume the detection routine was copied and pasted from somewhere else.</p><p> 但现在我们达到真正的问题，这是486检测。同样，我不知道代码甚至试图检测到486，因为NE2000驱动器真的不关心CPU是否是386或486.我只能假设检测例程被复制并从其他地方粘贴。</p><p> At any rate, the detection routine tries to flip the WT bit in the CR0 register; if the bit does not change, the CPU must be a 386, if it does change it’s assumed to be a 486.</p><p> 无论如何，检测程序试图在CR0寄存器中翻转WT位;如果该位不改变，则CPU必须是386，如果它确实将其更改为486。</p><p> This is an ostensibly bad idea because moves to and from CR0 are privileged instructions (unlike SGDT). Such detection would be fine in, say, initialization code for OS/2 or NT, but it’s not that great in a piece of DOS code that may run with a memory manager etc. But that’s not the worst problem with it.</p><p> 这是一个表面上不好的想法，因为往返CR0的移动是特权指令（与SGDT不同）。这种检测对于OS / 2或NT的初始化代码，但是在可能使用内存管理器等中运行的DOS代码中的初始化代码也不伟大，但这不是它最糟糕的问题。</p><p> Now, it is important to underscore that this driver is timestamped November 1990. It could well be a couple of moths older, and almost certainly is. There were not a lot of 486s around in mid-1990, but there were some, and Microsoft certainly would have had a few.</p><p> 现在，强调这个司机是在1990年11月的时间戳中的时间戳。它可能是几个年龄较大的蛾，几乎肯定是。 1990年年中没有很多486岁，但有一些，微软肯定会有一些。</p><p> Whoever wrote the code clearly looked at Intel’s initial i486 datasheet from April 1989, Intel Order Number 240440-001. On page 24, it says that setting the CR0. WT bit will enable internal cache write-through and invalidates. Since the early 486 models had no write-through cache, the bit was actually a no-op but still could be flipped.</p><p> 谁写的代码清楚地看着英特尔的初始I486数据表于1989年4月，英特尔订单号240440-001。在第24页，它说设置CR0。 WT位将启用内部缓存写入并无效。由于486年初的型号没有写入缓存，因此该位实际上是一个无人，但仍然可以翻转。 </p><p> Except… whoops. Intel’s original 486 design was to enable cache by setting the CR0.CE bit (that is bit 30 of CR0), which is perfectly logical, only it turned out to be a really bad idea. Because nearly all existing 386 code then promptly disabled the cache when updating CR0 and clearing the CE bit.</p><p>除...哎呀。英特尔的原版486设计是通过设置CR0.CE位（CR0的位30）来实现缓存，这是完全逻辑的，只有它结果是一个非常糟糕的想法。因为在更新CR0并清除CE位时，几乎所有现有的386代码都会及时禁用缓存。</p><p> Intel therefore revised the 486 such that the CE (Cache Enable) and WT (Write Through) bits were renamed to CD (Cache Disable) and NW (Not Write-Through) and their meaning was inverted. Existing 386 code that wrote those bits as zero would then keep caching and write-through enabled. The new meaning of the bits was well documented on page 18 of the updated i486 datasheet from November 1989 (Intel Order Number 240440-002).</p><p> 因此，Intel修改了486，使得CE（缓存启用）和WT（写入）位重命名为CD（缓存禁用）和NW（未写入），并且它们的含义被反转。现有386个代码，将这些位写为零，然后将启用缓存和写入。从1989年11月（英特尔订单号240440-002）的更新I486数据表中，比特的新含义很好地记录了。</p><p> For the detection code in the NE2000 driver this change had the unfortunate side effect that the bit combination of CD clear, NW set became invalid, while previously CE clear, WT set was valid. In the typical scenario where the CD and WT bits are both clear (i.e. caching and write-through enabled) when the NE2000 driver CPU detection code runs, flipping the WT bit produces an invalid combination and GP-faults when the CR0 register is written. That is exactly why I saw the driver hang.</p><p> 对于NE2000驱动程序中的检测代码，此更改具有不幸的副作用，即CD清除，NW集的比特组合变得无效，而先前CE清除，WT集是有效的。在CD和WT位既清晰的典型方案中，当NE2000驱动器CPU检测码运行时，在编写CR0寄存器时，翻转WT位会在WT位产生无效组合和GP故障。这正是我看到司机挂起的原因。</p><p> Now here’s the weird thing: The combination of cache enabled, write-through disabled was always documented as invalid, even on the earliest i486. Flipping the WT/NW bit only works if the cache is  disabled. Either the detection could crash even on those early 486s (possible) or the invalid combination was actually accepted (also possible).</p><p> 现在这是奇怪的事情：即使是最早的I486，也始终记录了高速缓存的组合，写入禁用禁用。如果缓存禁用，则翻转WT / NW位仅适用。即使在486年代早期（可能）或实际接受无效组合（也可能），也可以崩溃。</p><p> It is very likely that the NE2000.DOS driver shipped with LAN Manager 2.0 saw at best minimal testing on 486 machines. It is possible that it was only tested on early revision 486s, or not at all. The CPU detection code was safe enough on 386 and lower CPUs, only on a 486+ it was prone to crashing.</p><p> NE2000.DOS驱动程序很可能与LAN Manager 2.0发布的486台机器最佳的最低测试。它可能只在早期修订486s，或根本没有测试。 CPU检测码在386和较低的CPU上足够安全，仅在486+上易于崩溃。</p><p> As usual, this shows the danger of knowing too much. If the authors weren’t trying to show how clever they were by trying detect a 486 in (probably) 1989, the code would have worked. If they actually followed Intel’s guidelines and detected a 486 by trying to flip the EFLAGS.AC bit, the code would have worked too.</p><p> 像往常一样，这表明了解太多的危险。如果作者没有试图展示他们在（可能）1989年（可能）1989中检测到486的聪明，则该代码将有效。如果他们实际上遵循英特尔的指导方针并试图翻转EFLAGS.Ac位，则检测到486，该代码也会工作。</p><p> Instead this is another example of poorly tested or perhaps entirely untested code ending up in production software, lying in wait until users upgrade their hardware, and then springing a nasty surprise on them.</p><p> 相反，这是测试软件中最糟糕或完全未经测试的代码的另一个例子，躺在等待之前，直到用户升级他们的硬件，然后在他们身上弹出一个令人讨厌的惊喜。 </p><p> Many programmers didn’t like Intel’s official CPU detection code because it was kind of big and clunky, and  wasn’t always perfect, but at least it worked better than the abomination in the old Microsoft NE2000 driver.</p><p>许多程序员不喜欢英特尔的官方CPU检测代码，因为它有点大而笨重，并不总是完美的，但至少它比旧的Microsoft Ne02000司机的憎恶更好。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.os2museum.com/wp/nobody-expects/">https://www.os2museum.com/wp/nobody-expects/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/expects/">#expects</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/可能/">#可能</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>