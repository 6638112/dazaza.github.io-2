<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>模糊矩阵加密的冒险 Adventures in Fuzzing Matrix’s Encryption</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Adventures in Fuzzing Matrix’s Encryption<br/>模糊矩阵加密的冒险 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-15 03:50:15</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/b4bb4d805a04d5e397636d2c63408754.jpg"><img src="http://img2.diglog.com/img/2021/6/b4bb4d805a04d5e397636d2c63408754.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Hi all! My name is Denis and I&#39;m a  securityresearcher. Six months ago, I started working forElement on doing dedicated security research on important Matrix projects.After some initial focus on Synapse, I decided to take a closer look at libolm. In this entry, I&#39;d like topresent an overview of that work, along with some early fruits that came out ofit.</p><p>大家好！我的名字是丹尼斯和我和第39; m一个securityResearcher。六个月前，我开始努力为重要的矩阵项目进行专用的安全研究。在一些初步关注突触的初步关注时，我决定仔细看看Libolm。在这个条目中，我喜欢topresent概述了那项工作，以及一些早期的水果出来。</p><p> TL;DR: we found some bugs which had crept in since libolm&#39;s original audit in2016, thanks to properly overhauling our fuzzing capability, and we&#39;d like totell you all about it! The bugs were not easily exploitable (if at all), andhave already been fixed.</p><p> TL;博士：我们发现了一些悄悄地利用Libolm＆＃39;原来审计的一些错误，因为正确地改变了我们的模糊能力，我们＆＃39; D喜欢你所有的东西！错误不容易利用（如果根本），并且已经修复了。</p><p> To give a bit of a background, libolm is a cryptographic library implementingthe  Double RatchetAlgorithm pioneered bySignal and it is the cryptographic workhorse behind Matrix. The classicalgorithm is called Olm in Matrix land, but libolm also implements Megolm whichis a variant for efficient encrypted group chats between many participants.</p><p> 为了给出一些背景，Libolm是一个加密库，实现了双重ratchetalgorithm先驱的bysignal，它是矩阵后面的加密工作。在矩阵土地中称为OLM，但Libolm还实现了Megolm，其中许多参与者之间有效的加密组聊天的一个变体。</p><p> Since libolm is currently used in all Matrix clients supporting end-to-endencryption, it makes for a particularly juicy target. The present state oflibolm&#39;s monopoly on Matrix encryption is somewhat unfortunate -- luckily thereare some exciting new developments on the horizon, such as the vodozemacimplementation in Rust. But for now, we&#39;re stuck with libolm.</p><p> 由于Libolm目前用于支持端到endEnclyption的所有矩阵客户端，因此它是特别多汁的目标。目前的州＆＃39;矩阵加密垄断的统一性有点不幸 - 幸运的是，在地平线上有一些令人兴奋的新发展，例如锈病的vodozempacemation。但是现在，我们陷入困境。</p><p> To start, I decided to do a bit of fuzzing. libolm already had a fuzzing setupusing AFL, but it was written a while ago. The state of the art in fuzzing hadadvanced quite rapidly in the last few years, so the setup was missing manymodern features and techniques. As an example, the fuzzing setup was configuredto use the now ancient afl-gcc coverage mode, which can be slower than the moremodern LLVM-based coverage by a factor of 2.</p><p> 要开始，我决定做一些模糊。 Libolm已经有一个模糊套装AFL，但这是在前的写作。在过去几年中，最先进的杰出卓越的速度迅速，所以设置缺少了许多熟悉的特征和技巧。作为示例，模糊设置被配置为使用现在的古代AFL-GCC覆盖方式，这可以比仅基于MoreModern LLVM的覆盖率慢一倍。</p><p> I also noticed that the fuzzing was done with non-hardened binaries (instead ofusing something like ASAN), so many memory errors could&#39;ve gone unnoticed.There were also no corpora available from previous fuzzing runs and some of thenewer code was not covered by the harnesses.</p><p> 我也注意到这种模糊用非硬化二进制文件（而不是像Asan这样的东西），所以很多内存错误都可以＆＃39; vere没有注意到。也没有从以前的模糊运行中提供的集团，那么一些代码没有被用具覆盖。</p><p>  I decided to tackle these one by one, adding ASAN and MSAN builds as a firststep. I took the opportunity to switch to  AFL++ sinceit is a drop-in replacement and contains numerous improvements, notablyimproved coverage modes which are either much faster (e.g. LLVM-PCGUARD) orguaranteed to have no collisions (LTO)  1. AFL++ also optimizes mutationscheduling (by using scheduling algorithms from AFLFast) and mutation operator selection(through  MOpt). All of this makesit much more efficient at discovering bugs.</p><p>  我决定一个接一个地解决这些，添加ASAN和MSAN作为FirstStep。我借此机会切换到AFL ++以来是一个替代品，包含许多改进，值得明显的覆盖方式，这些模式要快得多（例如LLVM-PCGuard）orguarantEED，无法碰撞（LTO）1. AFL ++还优化变形（通过使用来自aflfast的调度算法和突变运算符选择（通过mopt）。所有这些都在发现错误时更有效率。 </p><p> After this, I changed the existing harnesses to use AFL&#39;s persistent mode(which lowers process creation overhead and thus increases fuzzingperformance). This change, combined with the switch to a newer coverage mode,increased the fuzzing exec/s from ~2.5k to ~5.5k on my machine, so this is notan insignificant gain!</p><p>在此之后，我改变了现有的线束来使用AFL＆＃39; s持久模式（降低过程创建开销，从而增加了模糊性能）。这种变化，结合开关到更新的覆盖方式，从我的机器上增加了模糊exec / s到〜5.5k，所以这是诺兰人的收益！</p><p> After this preparatory work, I generated a small initial corpus and ran a smallfleet of fuzzers with varying parameters. Almost immediately, I started gettingheaps of crashes. Luckily, after some investigation, these turned out not to beserious bugs in the library but a double-free in the fuzzing harness! Thedouble-free only got triggered when the input was of size 0. It also onlyhappened with AFL++ and not vanilla AFL, presumably due to differences in inputtrimming logic, which must be the reason no one noticed this earlier. I quicklycame up with a patch and resumed.</p><p> 在这项准备工作之后，我生成了一个小型初始语料库，并用不同参数运行的小型模糊。几乎立即，我开始了撞击的撞击。幸运的是，经过一些调查，这些概述了图书馆中的错误虫，而是在模糊束缚中是一个双重的！只有在输入的大小0时才会触发。它也只有AFL ++而不是香草AFL，可能是由于输入的逻辑差异，这必须是未来没有人注意到的原因。我用修补程序迅速命名并恢复。</p><p>  I let the fuzzers run for a while. Since ASAN introduces a bit of a performanceoverhead, I only run a single AFL instance with ASAN variant of the binary.This is okay because all fuzzer instances actually synchronize their findings,which means every instance gets to see every input which increases coverage.When I came back to check, there was another crash waiting. This time thecrashing input wasn&#39;t being generated continually so it looked much morepromising -- and only the ASAN instance was crashing.  A-ha!</p><p>  我让模糊跑了一段时间。由于ASAN引入了一个Persification头发，因此我只使用二进制文件的ASAN变体运行单个AFL实例。这是可以的，因为所有的模糊实例都实际上会同步他们的发现，这意味着每个实例都会看到增加覆盖的每个输入。当我回来检查，还有另一个碰撞等待。这次蒙古德输入是不断生成的输入，所以它看起来很有妥协 - 并且只有Asan实例正在崩溃。 A-HA！</p><p> Running the offending input on the ASAN variant of the harness revealed it wasan invalid read one byte past the end of a heap buffer. The read was happeningin the base64 decoder:</p><p> 运行在线束的ASAN变体上的违规输入显示它是浪花无效读取堆缓冲区末尾的一个字节。读取的是Base64解码器：</p><p> ❮ ./build/fuzzers/fuzz_group_decrypt_asan &#34;&#34; pickled-inbound-group-session.txt &lt;input===================================================================1838065==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf4a00795 at pc 0x56560660 bp 0xffff9df8 sp 0xffff9de8READ of size 1 at 0xf4a00795 thread T0 #0 0x5656065f in olm::decode_base64(unsigned char const*, unsigned int, unsigned char*) src/base64.cpp:124 #1 0x565607b5 in _olm_decode_base64 src/base64.cpp:165 #2 0x565d5a9e in olm_group_decrypt_max_plaintext_length src/inbound_group_session.c:304 #3 0x56558e75 in main fuzzers/fuzz_group_decrypt.cpp:46 #4 0xf7509a0c in __libc_start_main (/usr/lib32/libc.so.6+0x1ea0c) #5 0x5655a0f4 in _start (/home/dkasak/code/olm/build/fuzzers/fuzz_group_decrypt_asan+0x50f4)0xf4a00795 is located 0 bytes to the right of 5-byte region [0xf4a00790,0xf4a00795)allocated by thread T0 here: #0 0xf7a985c5 in __interceptor_malloc /build/gcc/src/gcc/libsanitizer/asan/asan_malloc_linux.cpp:145 #1 0x56558ce3 in main fuzzers/fuzz_group_decrypt.cpp:32 #2 0xf7509a0c in __libc_start_main (/usr/lib32/libc.so.6+0x1ea0c)SUMMARY: AddressSanitizer: heap-buffer-overflow src/base64.cpp:124 in olm::decode_base64(unsigned char const*, unsigned int, unsigned char*)Shadow bytes around the buggy address: 0x3e9400a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x3e9400b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x3e9400c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x3e9400d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x3e9400e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa=&gt;0x3e9400f0: fa fa[05]fa fa fa 05 fa fa fa fa fa fa fa fa fa 0x3e940100: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x3e940110: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x3e940120: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x3e940130: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x3e940140: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa faShadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb Shadow gap: cc==1838065==ABORTING</p><p> ❮./build/fuzzers/fuzz_group_decrypt_asan＆＃34;＆＃34;腌入机组组会话.txt＆lt;输入====================================== ============================= 1838065 ==错误：addresssanitizer：堆缓冲区溢出在地址0xf4a00795上PC 0x56560660 bp 0xffff9df8 sp 0xffff9de8 read大小1在0xf4a00795线程t0＃0 0x5656065f在olm :: decode_base64（未签名的char const *，unsigned int，unsigned char *）src / base64.cpp：124＃1 0x565607b5 in _olm_decode_base64 src / base64.cpp：165＃2 0x565d5a9e在olm_group_decrypt_max_plaintext_length SRC / inbound_group_session.c：304在主模糊器/ fuzz_group_decrypt.cpp＃3 0x56558e75：46＃4 0xf7509a0c在__libc_start_main（/usr/lib32/libc.so.6+0x1ea0c）＃5 0x5655a0f4在_start（/家/ DKASAK / CODE / OLM / BUID / fuzzers / fuzz_group_decrypt_asan + 0x50f4）0xf4a00795位于5字节区域的右侧的0个字节[0xf4a00790,0xf4a00795）在此处分配：＃0 0xf7a985c5 __interceptor_malloc / build / gcc / src / gcc / libsanitizer / asan / asan_malloc_linux.cpp：145＃1 0x56558Ce3在主模糊物/ fuzz_group_decrypt.cpp： 32＃2 0xf7509a0c在__libc_start_main中（/usr/lib32/libc.so.6+0x1ea0c）summary：addresssanitizer：heap-beaffer-odflow src / base64.cpp：124在olm :: decode_base64中（未签名的char const *，unsigned int，无符号字符*）暗影字节左右的车地址：0x3e9400a0：发发发发发发发发发发发发发发发发0x3e9400b0：发发发发发发发发发发发发发发发发0x3e9400c0：发FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FAF FA FA FA FA FA FA FA FA FA FA FAFA FA =＆GT; 0x3E9400F0：FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FA FAF FA FA FA FA FA FA FA FA FA FA FA FA FA FAF FA FAF FA FAF FA FAF FA FAF FA FAF FA FAF FA FAF FA FA发发发发发发发发发发0x3e940120：发发发发发发发发发发发发发发发发0x3e940130：发发发发发发发发发发发发发发发发0x3e940140：发发FA FA FA FA FA FA FA FA FA FAFAWAD BYTE传奇（一个影子字节代表8个应用程序字节）：可寻址：00 PARII盟友可寻址：01 02 03 04 05 06 07堆左重新释放：FA释放堆区域：FD堆栈左重新滤芯：F1堆栈中间redzone：F2堆栈右重新滤芯：F3堆栈返回后：F8堆栈范围后：F8全局redzone：F9全局init订单：F6由用户中毒：F7集装箱溢出：FC阵列cookie：AC Intra Object Redzone：BB Asan内部：FE Letth Alloca Redzone：CA右类redzone：CB阴影间隙：CC == 1838065 ==中止</p><p> Following the stack trace, I quickly pinpointed the root of the bug: the logicof the decoder was subtly flawed, unconditionally accessing a remainderbyte  2 in the base64 input which might not actually be there.This occurs when the input is 1 (mod 4) in length, which can never happen ina  valid base64 payload, but of course we cannot assume all inputs arenecessarily valid payloads. Specifically, if the payload was not 0 (mod 4) inlength, the code was assuming it was at least 2 (mod 4) or more in length andimmediately read the second byte. This spurious byte was then incorporated intothe output value.</p><p> 在堆栈跟踪之后，我很快就查明了错误的根：解码器的逻辑被细冲探险，无条件地在Base64输入中访问剩余的字节2，这可能并非实际上存在。当输入是1（mod 4）时发生长度，这可能永远不会发生在有效的base64有效载荷中，但当然我们不能假设所有输入都是必需的有效有效载荷。具体地，如果有效载荷不是0（mod 4）的长度，则代码假设它是至少2（mod 4）或更多的长度，并且读取第二字节。然后将这种虚假的字节包含在内的输出值。</p><p> I examined the code in an attempt to find a way to have it leak more thana single byte, but it was impossible. As it turned out, not even the full byteof useful information was encoded into the output -- due to the way the byte isencoded, only about 6 bits of useful information ended up in the output value.</p><p> 我检查了代码试图找到一种方法来泄漏更多单个字节，但这是不可能的。事实证明，由于字节ISENDODED的方式，甚至没有将完整的字节信息编码为输出 - 由于字节ISENSODED的方式，但在输出值中仅最终有6位有用信息。 </p><p> Still, even a single leaked bit is too much in a cryptographic context. Couldwe do some heap hacking so that something of interest is placed there and thenhave it be leaked to us?</p><p>仍然，即使是单个泄漏的位也太多了在加密上下文中。可以做一些堆的黑客，以便在那里放置感兴趣的东西，然后泄露给我们？</p><p> I next tracked down all call sites of the vulnerable function olm::decode_base64. Most of them were immune to the problem since they werepreceded with calls to another function,  olm::decode_base64_length, whichchecks that the base64 payload is of legal length. This left me with only a fewpotentially vulnerable call sites, so I examined where their base64 inputs comefrom. Promisingly, two of them received input from other conversationparticipants, but they either had no way of leaking the information back to theattacker or they hardcoded the number of bytes to be processed, after ensuringthe input was of some minimum length. The output of the remaining function  olm_pk_decrypt is never sent anywhere externally, so therewas again no way of leaking the data to the attacker.</p><p> 我接下来追踪漏洞函数OLM :: Decode_Base64的所有呼叫站点。他们中的大多数都是对这个问题的免疫，因为他们被呼叫到另一个函数，OLM :: Decode_Base64_Length，基本64有效载荷是法律长度的挑选。这只留下了我只有几个易受攻击的呼叫网站，所以我检查了他们的Base64输入Comefrom的位置。承诺，其中两个收到了其他对话术客的输入，但它们要么无法将信息泄回到Theattacker，或者在确保输入的输入之后，它们已经硬结了要处理的字节数。剩余函数OLM_PK_DECRYPT的输出永远不会在外部发送任何地方，因此还没有泄漏数据到攻击者。</p><p> In conclusion, even though this invalid read is a valid bug, I was not able tofind a working exploit for it.</p><p> 总之，即使这个无效的阅读是一个有效的错误，我也无法加以工作的漏斗。</p><p> But wait a second! Something was still bothering me about  olm_pk_decrypt.It&#39;s a fairly complex function,  receives several string inputs from thehomeserver and it itself isn&#39;t tested by any of the harnesses. Furthermore,the reason I started looking at it in the first place is that it was missingthe  olm::decode_base64_length check. Perhaps it warrants a closer look?</p><p> 但等一下！有些东西仍在困扰我的olm_pk_decrypt.it＆＃39; s一个相当复杂的函数，从AhomeServer接收多个字符串输入，它本身是由任何线束测试的ISN＆＃39; t。此外，我首先开始看它的原因是它缺少OLM :: Decode_Base64_Length检查。也许它需要仔细看看？</p><p>  And sure enough, there was something amiss. As  olm_pk_decrypt receives threebase64 inputs from the homeserver: the ciphertext to decrypt, an ephemeralpublic key and a MAC. All three are eventually passed to  olm::decode_base64to be decoded. Yet there was only a single length check there, to ensure thedecrypted ciphertext would fit its output buffer. What would happen if theserver returned a public key that was longer than expected?</p><p>  并肯定，有些不对劲。由于OLM_PK_DECRYPT接收来自Homeserver的三base64输入：要解密的密文，一个短射出的键和MAC。所有三个最终将被解码为OLM :: Decode_Base64。然而，只有一个长度的检查，以确保进入密码的​​密文适合其输出缓冲区。如果Theserver返回超过预期的公钥，会发生什么？</p><p>  As can be seen from the snippet, the decoded version of public key gets writtento  ephemeral.public_key, which is an array allocated on the stack. If theinput is longer than expected, this will become a stack buffer overflow.</p><p>  从代码段可以看出，公钥的解码版本获取Writtento EPhemeral.Public_Key，它是在堆栈上分配的数组。如果inInput比预期的长，则这将成为堆栈缓冲区溢出。</p><p> The purpose of  olm_pk_decrypt is to decrypt secrets previously stored bya Matrix device on the homeserver. The point of encryption is to prevent theserver from learning these secrets since they&#39;re supposed to be known only byyour own devices. One use case for this mechanism is to allow one of yourdevices to store encrypted end-to-end encryption keys on the homeserver. Yourother devices can then retrieve those keys from the homeserver, making itpossible to view all of your private conversations on each of your devices.</p><p> OLM_PK_DECRYPT的目的是解密先前在Homeserver上存储的矩阵设备的秘密。加密点是为了防止他们以来的学习这些秘密，因为它们＆＃39; re应该只知道自己的设备。此机制的一个用例是允许您的其中一个是在Homeserver上存储加密的端到端加密密钥。然后，您的其他设备可以从HomeServer中检索那些键，从而使您可以在每个设备上查看所有私有谈话。 </p><p> I decided to go for an end-to-end test to confirm the bug is triggerable byconnecting with the latest Element Android from my test phone to my homeserver,with  mitmproxy sitting in between. This allowed me towrite a small mitmproxy script which intercepts HTTP calls fetching the E2Eencryption keys from the homeserver and modifies the response so that the keyis longer than expected.</p><p>我决定去结束于结束的测试来确认错误是易于使用我的测试手机到我的主页的最新元素Android的令人触发的错误，用Mitmproxy坐在之间。这使我允许一台小型麻省备注脚本拦截从Homeserver获取e2Eencryption键并修改响应的HTTP调用，以便keys长于预期的键。</p><p> import json from mitmproxy  import ctx , http def  response (flow : http .HTTPFlow )  - &gt;  None :  if  ( &#34;/_matrix/client/unstable/room_keys/keys&#34;  in flow .request .pretty_url  and flow .request .method  ==  &#34;GET&#34; ) : response_body  = flow .response .content .decode ( &#34;utf-8&#34; ) response_json  = json .loads (response_body ) rooms  = response_json [ &#34;rooms&#34; ] room_id  =  list (rooms .keys ( ) ) [ 0 ] sessions  = rooms [room_id ] [ &#34;sessions&#34; ] session  =  list (sessions .keys ( ) ) [ 0 ] session_data  = sessions [session ] [ &#34;session_data&#34; ] ephemeral  = session_data [ &#34;ephemeral&#34; ] ctx .log .info (  f&#34;Replacing ephemeral key &#39;  {ephemeral } &#39; with &#39;  {ephemeral  *  10 } &#39;&#34; ) session_data [ &#34;ephemeral&#34; ]  = ephemeral  *  10 modified_body  = json .dumps (response_json ) .encode ( &#34;utf-8&#34; ) flow .response .content  = modified_body</p><p> 从Mitmproxy导入CTX导入JSON，HTTP DEF响应（flow：http .httpflow） - ＆gt;无：if（＆＃34; / _矩阵/客户/ rustable / room_keys / keys＆＃34;在flow .request .pretty_url和flow .request .method ==＆＃34; get＆＃34;）：response_body = flow .response .content .decode（＆＃34; utf-8＆＃34;）response_json = json .loads（response_body）的房间= response_json [＆＃34;房间＆＃34; ] room_id = list（房间.keys（））[0]会话=房间[room_id] [＆＃34;会话＆＃34; ]会话=列表（会话.keys（））[0] session_data = sessions [session] [＆＃34; session_data＆＃34; ] ephemeral = session_data [＆＃34;星期六; ] CTX .log .info（f＆＃34;取代短信钥匙＆＃39; {ephemeral}＆＃39;＆＃39; {ephemeral * 10}＆＃39;＆＃34;）session_data [＆＃34;短期＆＃34; ] =短暂* 10修改_Body = JSON .dumps（Response_JSON）.encode（＆＃34; UTF-8＆＃34;）流。响应.content = modified_body</p><p> This longer value is then eventually passed by Element Android to libolm&#39;s olm_pk_decrypt, which triggers the buffer overflow. With all of that inplace, I deleted the local encryption key backup on my device and asked for itto be restored from the server:</p><p> 然后，该较长值最终通过元素Android到Libolm＆＃39; s olm_pk_decrypt，它触发缓冲区溢出。使用所有此，我删除了设备上的本地加密密钥备份，并要求从服务器恢复它：</p><p> F libc : stack corruption detected (-fstack-protector)F libc : Fatal signal 6 (SIGABRT), code -6 (SI_TKILL) in tid 24517 (DefaultDispatch), pid 24459 (im.vector.app)F DEBUG : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***F DEBUG : Build fingerprint: &#39;xiaomi/tissot/tissot_sprout:9/PKQ1.180917.001/V10.0.24.0.PDHMIXM:user/release-keys&#39;F DEBUG : Revision: &#39;0&#39;F DEBUG : ABI: &#39;arm64&#39;F DEBUG : pid: 24459, tid: 24517, name: DefaultDispatch &gt;&gt;&gt; im.vector.app &lt;&lt;&lt;F DEBUG : signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr --------F DEBUG : Abort message: &#39;stack corruption detected (-fstack-protector)&#39;F DEBUG : x0 0000000000000000 x1 0000000000005fc5 x2 0000000000000006 x3 0000000000000008F DEBUG : x4 0000000000000000 x5 0000000000000000 x6 0000000000000000 x7 0000000000000030F DEBUG : x8 0000000000000083 x9 7d545b4513138652 x10 0000000000000000 x11 fffffffc7ffffbdfF DEBUG : x12 0000000000000001 x13 0000000060b0f2a9 x14 0022ed916fede200 x15 0000d925cd93f18fF DEBUG : x16 00000079e741b2b0 x17 00000079e733c9d8 x18 0000000000000000 x19 0000000000005f8bF DEBUG : x20 0000000000005fc5 x21 0000007940e3c400 x22 000000000000026b x23 00000000000001d0F DEBUG : x24 000000000000002f x25 000000793d9653f0 x26 0000007948303368 x27 0000007945dd5588F DEBUG : x28 00000000000001d0 x29 0000007945dd37d0F DEBUG : sp 0000007945dd3790 lr 00000079e732e00c pc 00000079e732e034</p><p> f libc：堆栈损坏检测到（-fstack-protector）f libc：致命信号6（sigabrt），tid 24517中的代码-6（si_tkill）（defaultdispatch），pID 24459（im.vector.app）f调试：*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***调试：构建指纹：＆＃39; xiaomi / tissot / tissot_sprout：9 / pkq1.180917.001 / v10.0.24.0.pdhmixm：用户/释放键和＃39; f调试：＆＃39; 0＆＃39; f调试：abi ：＆＃39; arm64＆＃39; f调试：pid：24459，tid：24517，名称：defaultdispatch＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt; im.vector.app＆LT;＆LT;＆LT;˚FDEBUG：信号6（SIGABRT），码-6（SI_TKILL），故障地址--------˚FDEBUG：中止消息：＆＃39;堆栈损坏检测（-fstack保护器）＆＃39;˚FDEBUG：X0 X1 0000000000000000 X2 0000000000005fc5 X3 0000000000000006 DEBUG 0000000000000008F：X4 X5 0000000000000000 0000000000000000 0000000000000000 5233 X7 0000000000000030F DEBUG：X8 0000000000000083 X9 7d545b4513138652 X10 X11 0000000000000000 DEBUG fffffffc7ffffbdfF：X12 X13 0000000000000001 X14 0000000060b0f2a9 X15 0022ed916fede200 0000d925cd93f18fF DEBUG：X16 00000079e74​​1b2b0 X17 X18 00000079e733c9d8 0000000000000000 X19 0000000000005f8bF DEBUG：X20 X21 0000000000005fc5 X22 0000007940e3c400 X23 000000000000026b DEBUG 00000000000001d0F：X24 X25 000000000000002f X26 000000793d9653f0 X27 0000007948303368 DEBUG 0000007945dd5588F：X28 00000000000001d0 X29 0000007945dd37d0F DEBUG：SP 0000007945dd3790 LR 00000079e732e00c PC 00000079e732e034</p><p>   Of course, the largest fear stemming from any remotely controlled stack bufferoverflow is code execution. This is perhaps even doubly so in a cryptographiclibrary, where we have the additional worry of an attacker being able to leakour dearly protected conversations.</p><p>   当然，从任何远程控制的堆栈bufferoverflow源最大的恐惧是代码执行。这甚至可能在加密Library中倍增，我们有额外的担忧攻击者能够泄漏深受保护的对话。</p><p> The federated architecture of Matrix may be somewhat of a mitigatingcircumstance in this case, since users are much more likely to know and trustthe homeserver owner, but we don&#39;t want to have to rely on this trust.</p><p> 在这种情况下，矩阵的联邦架构可能有点有些缓渠，因为用户更有可能知道和信任Homeserver所有者，但我们不想依靠这种信任。</p><p>  Luckily, on its own, this bug is not enough to successfully execute code onnative binaries. By default, libolm is compiled for all supported targets withstack canaries (also called stack protectors or stack cookies), which are magicvalues unknown to the attacker, placed just before the current function&#39;s frameon the stack. This value is checked upon returning from the function -- if itsvalue is changed, the process aborts itself to prevent further damage. This isevident from the  Abort message: &#39;stack corruption detected(-fstack-protector)&#39; message above. Besides canaries, other system-levelprotections exist to make exploiting bugs such as this harder, such as ASLR.</p><p>  幸运的是，自己的错误不足以成功执行代码onnnative二进制文件。默认情况下，为包含Canaries的所有支持的目标（也称为堆栈保护器或堆栈cookie）编译libolm，这是攻击者未知的魔术值，放在当前功能之前＆＃39; s框架堆栈。从函数返回时检查此值 - 如果改变其值，则该过程中止自身以防止进一步损坏。这是从中止消息中的＆＃39;堆栈腐败检测到（-fstack-protector）＆＃39;上面的消息。除了Canaries外，还存在其他系统级别的保护，以使利用诸如此更难的错误，例如ASLR。 </p><p> Therefore, to achieve remote code execution, an attacker would need to findadditional vulnerabilities which would allow him to exfiltrate the stack canaryand addresses of key memory locations from the system.</p><p>因此，为了实现远程代码执行，攻击者需要FindAditional漏洞，这将允许他从系统中删除堆栈CanaryAnd的键存储位置的地址。</p><p>  With WASM, the analysis is much more complicated due to its very differentmemory and execution model. In WASM, the unmanaged stack is generally much morevulnerable due to it missing support for stack canaries. This implies a stackbuffer overflow can not only overwrite the frame of the function in which theoverflow occurred but also  all parent frames.</p><p>  通过WASM，由于其非常不同的和执行模型，分析更加复杂。在WASM中，由于它缺少对堆具公民队员的支持，非托管堆栈通常会更加多样化。这意味着StackBuffer溢出不能仅覆盖overflow发生的函数的帧，还可以覆盖所有父帧。</p><p> On the other hand, due to typed calls and much stronger control-flow integritytechniques, it&#39;s much harder for the attacker to make the code do somethingthat is (maliciously) useful. Notably, return addresses live outside unmanagedmemory and are out of reach to the attacker. Because of this, the primary wayof influencing code execution is by manipulating  call_indirect instructionsin such a way as to call.</p><p> 另一方面，由于键入的呼叫和更强大的控制流程积分技术，它＆＃39;攻击者更难使代码做某事是（恶意地）有用。值得注意的是，返回地址直播在UnmanageMemory之外，并无法访问攻击者。因此，影响代码执行的主要方法是通过操纵Call_Indirect指令呼叫的方式。</p><p> The analysis of the impact of this bug on the WASM binary is thus left as anexercise to the reader. If you&#39;re interested, the 2020 USENIX paper  EverythingOld is New Again: Binary Security of WebAssemblyis a great starting point.</p><p> 因此，对WASM二进制文件的这种错误的影响是向读者的Anexercise留下的。如果你＆＃39; ref感兴趣，2020 usenix纸张evitiledre是新的：webassemblyis的二进制安全性很大的起点。</p><p>  Once the problems were identified,  the patches were  rathertrivial and the issues were promptly resolved. The first libolmrelease that includes the fix is 3.2.3 which was released on 2021-05-25.</p><p>  一旦确定了问题，斑块相实地存在，问题迅速解决。第一种包括修复的血浆是3.2.3，在2021-05-25释放。</p><p> We reached out to all Matrix clients which were determined to be affected. TheElement client versions which first fix the issue are as follows:</p><p> 我们达到了决心受影响的所有矩阵客户。第一次修复此问题的TheElement客户端版本如下：</p><p>  For the mobile clients, these versions are already available in theirrespective application stores at the time of publishing this post. If youhaven&#39;t already, please upgrade.</p><p>  对于移动客户端，在发布此帖子时，这些版本已在其重症应用程序存储中使用。如果你已经，请升级。 </p><p>  Even though the fuzzing setup is in a much better shape now (or rather will be,since I still have some PRs to merge upstream), there&#39;s still a lot that can bedone to further improve it.</p><p>即使模糊设置现在处于更好的形状（或者宁愿是，因为我仍然有一些PRS合并上游），那么它仍然可以替代进一步改善它。</p><p> Right now, there are undoubtedly parts of the codebase that are not fuzzedwell. The reasons for this range from the obvious, like some parts of the codesimply not being called by any the existing harnesses, to more subtle ones suchas the fact that cryptographic operations form a nearly-insurmountable naturalbarrier for naive fuzzing operations  3. Finally, some ofthe existing harnesses accept additional parameters as command-line arguments,meaning we would have to re-run the same harness with different values of thoseparameters in order to reach full coverage of the code. This is suboptimal.</p><p> 现在，毫无疑问的代码库部分不是模糊不清的。这一范围的原因是显而易见的，就像任何现有的线束都不调用的代码中的某些部分，以更加微妙的是，加密操作形成一个朴素的模糊操作的近乎难以克服的自然网络。最后，一些人现有的绑定接受其他参数作为命令行参数，这意味着我们必须重新运行相同的线束，以达到不同的帖子分析值，以便达到代码的完全覆盖范围。这是次优。</p><p>  Write starting corpus generators. These should generate believable, validinput for each of the harnesses. For example, for the decryption harness, weshould generate a variety of encrypted messages: empty, short, long, text,binary, etc.</p><p>  写出启动语料库生成器。这些应该为每个线束产生可信的，validInput。例如，对于解密线束，Weshould生成各种加密消息：空，短，长，文本，二进制等。</p><p> Modify the harnesses so that their extra parameters are determined from thefuzzed input. This will allow the fuzzer to vary these itself, which reducesthe importance of the human in the loop and makes it harder to forget somecombination.</p><p> 修改线束，以便从弹出的输入确定其额外的参数。这将允许模糊物改变这些本身，这将在循环中重新生动人类的重要性，并使忘记分析变得更加困难。</p><p> Fuzz for some time until coverage stops increasing. The corpora generatedshould be saved so that future fuzzing attempts can resume from an earlierpoint so that this work is not wasted.</p><p> FUZZE一段时间，直到覆盖率停止增加。 Corpora Goodce拯救，以便未来的模糊尝试可以从早期的点恢复，以便不浪费这项工作。</p><p> Use afl-cov to investigate which parts of the code are not covered well orat all. This should inform us what further changes are needed.</p><p> 使用AFL-COV来调查代码的哪些部分并不覆盖orat所有。这应该告诉我们需要进一步的更改。</p><p> Write intelligent, custom mutators. These will allow the fuzzer to takea valid input and easily produce another valid input instead of onlycorrupting it with a high probability.</p><p> 写智能，自定义突变者。这些将允许Fuzzer到Takea有效输入，并轻松地产生另一个有效输入，而不是仅具有高概率。 </p><p> It&#39;s very exciting that we&#39;re able to do full-time security research on Matrixthese days (thanks to Element&#39;s funding), and going forwards we&#39;ll publish anyinteresting discoveries for the visibility and education of the whole Matrixcommunity. We&#39;d also like to remind everyone that we run an official  SecurityDisclosure Policy forMatrix.org and we&#39;d welcome other researchers to come join our Hall of Fame!(And hopefully we will get more bounty programmes running in future.)</p><p>它非常令人兴奋的是我们＆＃39;重新能够对Matrixthese的全日制安全研究（感谢元素＆＃39;资金），并前进我们＆＃39; ll发布任何交感器的可见性和全部矩阵中的教育。我们也想提醒大家，我们运行一份官方安全性Disclose策略FormatRix.org和我们＆＃39; D欢迎其他研究人员加入我们的名利堂！（希望我们将来会获得更多的奖励计划。 ）</p><p> In the context of fuzzing, collisions are situations wheretwo different execution paths appear to the fuzzer as the same one due totechnical limitations.Classically, AFL tracks coverage by tracking so-called &#34;edges&#34; (or &#34;tuples&#34;).Edges are really pairs of (A, B), where A and B represent basic blocks. Eachedge is meant to represent a different execution &#34;jump&#34;, but sometimes, asthe number of basic blocks in a program grows, two different execution pathscan end up being encoded as the same edge. LTO mode in AFL++ does some magicso that this is guaranteed not to happen. ↩</p><p> 在模糊的上下文中，碰撞是不同的执行路径，不同的执行路径出现在模糊的情况下，因为它是相同的一个到来的totechnical限制。基本上，通过跟踪所谓的＆＃34来追踪覆盖范围。边缘＆＃34; （或＆＃34;元组＆＃34;）。边缘是（a，b）的成对，其中a和b代表基本块。每个确de都是表示不同的执行＆＃34;跳跃＆＃34;但有时，程序中的基本块数量的数量增长，两个不同的执行路径扫描最终被编码为相同的边缘。在AFL ++中的LTO模式执行了一些Magico，这保证不会发生。 ↩</p><p> By  remainder byte, I mean bytes which are not part ofa group of 4. These can only occur at the end of a base64 payload and they&#39;rethe ones that get suffixed with padding in padded base64. ↩</p><p> 通过剩余的字节，我的意思是非一组的字节，这是4的4.这些只能在Base64有效载荷和它们的结束时出现。在填充Base64中使用填充后缀的RETHE。 ↩</p><p> Classic fuzzers famously have a hard timecircumventing magic values and checksums, and cryptography is full of these.This is further complicated by the fact that the double ratchet algorithm isvery stateful and depends on the two ratchets evolving in lockstep. Thismeans that even if, for example, the decryption harness is supplied witha corpus of valid encrypted messages, the mutations done by the fuzzer wouldonly manage to produce corrupted versions of those messages which will failto decrypt, but it will ~never manage to produce a different  validencrypted message. ↩</p><p> 经典模糊着名具有硬度计的魔法值和校验和，并且密码学完全是其中的。这一事实进一步复杂于Double Ratchet算法isvery状态并且取决于在LockStep中的两种棘轮演变的两个棘轮。即使是解密线束提供有效加密消息的语料库，该突变也不会管理，该突变不会管理将产生将无法解密的这些消息的损坏版本，但它将〜永远不会管理不同albencrypted消息。 ↩ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://matrix.org/blog/2021/06/14/adventures-in-fuzzing-libolm">https://matrix.org/blog/2021/06/14/adventures-in-fuzzing-libolm</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/加密/">#加密</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fuzzing/">#fuzzing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/堆栈/">#堆栈</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>