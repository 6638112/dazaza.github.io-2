<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>普通TCP上的排序数据包 Sequenced Packets over Ordinary TCP</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Sequenced Packets over Ordinary TCP<br/>普通TCP上的排序数据包 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-24 21:24:15</div><div class="page_narrow text-break page_content"><p>This is a rough idea for an admittedly not hugely useful technical hack related to low-level network protocol gubbins. If you don&#39;t want to know about this, look away now.</p><p>对于与低级网络协议gubbins有关的公认的，不是很有用的技术黑客来说，这是一个粗糙的想法。如果您不想知道这一点，请立即移开视线。</p><p> is (oh - i&#39;llwarn you now that i say &#39;packet&#39; instead of &#39;segment&#39; throughout thisdocument; i&#39;m like that). I will assume you know what the  POSIXsocket API almost universally used to access it is. What you may ormay not know about are the two things i&#39;m going to talk about today: thesequenced packet (aka SOCK_SEQPACKET) socket type from the socket APIand the urgent pointer from the TCP specification. The socket API supports sockets of several types; &#39;type&#39; does notrefer to the protocol behind the socket, but rather to the semanticsassociated with the socket. The best-known socket types are stream(SOCK_STREAM) and datagram (SOCK_DGRAM); the former supplies a pair offull-duplex, reliable, ordered, structureless byte streams connected toa single remote socket, while the latter supplies an aperture throughwhich unreliable, unordered, smallish bundles of bytes can be sent tomultiple remote sockets. There are, however, other socket types; the most interesting is the sequenced-packet socket (SOCK_SEQPACKET). The  actual text of the socket API specification says of sequenced packet sockets:</p><p> 是（哦-我会警告您，我在整个文档中说的是包而不是段的意思是这样的）。我将假设您知道几乎普遍使用的POSIXsocket API是什么。您可能会或可能不知道的是我今天要谈论的两件事：套接字API中的这些已排序数据包（aka SOCK_SEQPACKET）套接字类型和TCP规范中的紧急指针。套接字API支持多种类型的套接字。 ＆＃39;类型＆＃39;不是指套接字后面的协议，而是指与套接字关联的语义。最著名的套接字类型是流（SOCK_STREAM）和数据报（SOCK_DGRAM）；前者提供了一对连接到单个远程套接字的全双工，可靠，有序，无结构的字节流，而后者则提供了一个孔，通过该孔可以将不可靠，无序，较小的字节束发送到多个远程套接字。但是，还有其他套接字类型。最有趣的是排序数据包套接字（SOCK_SEQPACKET）。套接字API规范的实际文本中说明了顺序数据包套接字：</p><p> The SOCK_SEQPACKET socket type is similar to the SOCK_STREAMtype, and is also connection-oriented. The only difference between thesetypes is that record boundaries are maintained using the SOCK_SEQPACKETtype. A record can be sent using one or more output operations andreceived using one or more input operations, but a single operationnever transfers parts of more than one record. Record boundaries arevisible to the receiver via the MSG_EOR flag in the received messageflags returned by the recvmsg() function. It is protocol-specificwhether a maximum record size is imposed.</p><p> SOCK_SEQPACKET套接字类型类似于SOCK_STREAM类型，并且也是面向连接的。这些类型之间的唯一区别是使用SOCK_SEQPACKETtype可以维护记录边界。可以使用一个或多个输出操作发送一条记录，并使用一个或多个输入操作接收一条记录，但是单个操作绝不传输多条记录的一部分。接收者可以通过recvmsg（）函数返回的已接收消息标志中的MSG_EOR标志来查看记录边界。是否强加最大记录大小是特定于协议的。</p><p> So basically, it&#39;s either a sequence of packets which are deliveredreliably and in order, or a reliable, ordered stream with recordboundaries in it, depending on how you look at it. Either way, it&#39;sclearly halfway between stream (ie TCP) and datagram (ie UDP) sockets.The stuff about MSG_EOR is how you mark the ends of messages; messagesare read and written like stream data, but with a couple of nuances: tomark the end of a message when sending, set the MSG_EOR flag in the lastsend(), and to detect the end of a message when receiving, use recvmsg()and look for the MSG_EOR flag in the msghdr.msg_flags field.</p><p> 因此，基本上，它要么是一系列可靠且有序地传送的数据包，要么是其中包含记录边界的可靠，有序的流，具体取决于您如何看待它。无论哪种方式，它显然位于流（即TCP）套接字和数据报（即UDP）套接字之间的中间位置。有关MSG_EOR的内容是如何标记消息的结尾；像流数据一样读取和写入消息，但有一些细微差别：在发送时标记消息的结尾，在lastsend（）中设置MSG_EOR标志，并在接收时检测消息的结尾，请使用recvmsg（）和在msghdr.msg_flags字段中查找MSG_EOR标志。</p><p> (Incidentally, that line saying &#34;a record can be sent using one ormore output operations and received using one or more input operations&#34;is a bit weird; the specs for recv() and recvmsg() say &#34;formessage-based sockets such as SOCK_DGRAM and SOCK_SEQPACKET, the entiremessage must be read in a single operation.&#34;. There&#39;s a  poston an Open Group mailing list</p><p> （顺便说一句，说“一条记录可以使用一个或多个输出操作发送并使用一个或多个输入操作接收记录”的行有点奇怪； recv（）和recvmsg（）的规范说＆＃34 ;基于格式的套接字（例如SOCK_DGRAM和SOCK_SEQPACKETET），必须在单个操作中读取整个消息。OpenGroup邮件列表上有一个帖子。</p><p> on the semantics of the MSG_WAITALLflag in the context of sequenced packet sockets which indicates thatmessages on a sequenced packet socket can indeed be delivered throughmultiple recv() calls, which does make more sense; you can then useMSG_WAITALL to force delivery in a single read, although it doesn&#39;t workif the message is bigger than your buffer) Moreover, sequenced packet sockets are probably the mostprogrammer-friendly kind: they have strong reliability and orderingguarantees (like TCP but unlike UDP), and they provide recorddemarcation at the protocol level (like UDP but unlike TCP); they shouldtherefore be a key tool for network programmers. However, as far as ican tell, there is no internet transport-layer protocol in common usewhich has sequenced packet semantics; SOCK_SEQPACKET is therefore not agenerally available socket type! Where it does turn up is when you&#39;rerunning connections straight over ATM or IR or other suitable linklayers, and nobody cares about that.</p><p> 关于MSG_WAITALLflag在序列化数据包套接字的上下文中的语义，这表明序列化数据包套接字上的消息确实可以通过多个recv（）调用来传递，这确实更有意义；然后，您可以使用MSG_WAITALL强制执行一次读取，尽管如果消息大于您的缓冲区则行不通。）此外，排序数据包套接字可能是对程序员最友好的一种：它们具有很强的可靠性和排序保证力（例如TCP但与UDP不同），它们在协议级别（例如UDP，但与TCP不同）提供记录分界；因此，它们应该是网络程序员的关键工具。但是，据我所知，尚无通用的互联网传输层协议对数据包的语义进行排序。因此，SOCK_SEQPACKET不是老旧可用的套接字类型！当您直接在ATM或IR或其他合适的链路层上运行连接时，却没有人关心。</p><p> But all is not lost! I have come up with a way to supply sequencedpacket semantics using entirely normal TCP, by exploiting a little-usedbut historically ancient feature of that protocol which, i think, wasdesigned expressely for that purpose: the urgent pointer.</p><p> 但是，一切都不会丢失！我想出了一种使用完全普通的TCP来提供序列化数据包语义的方法，它利用了该协议的一个很少使用但历史悠久的功能，我认为该功能是专门为该目的而设计的：紧急指针。 </p><p> The TCP spec is pretty brief, so have a read through and see what itsays about the the urgent pointer. Basically, it&#39;s a facility by whichone end of a TCP connection can indicate to the other that there&#39;surgent data somewhere in the stream. From the client (ieapplication-layer protocol) point of view, it looks like there&#39;s abutton next to the output stream of each socket, with a red light nextto the input stream of the other, both labelled &#39;URGENT!!!&#39;; one endwrites some data that it thinks is urgent, then hits the button: thelight at the other end then goes on immediately, and goes off once theclient has read all the data that the sender had written before hittingthe button. The TCP modules handle this by dint of two components oftheir packets: the &#39;urgent pointer field significant&#39; (aka URG) controlbit, and the urgent pointer (UP). The URG bit is set in all packets sentafter the button is pressed, up to and including the one containing thelast byte of urgent data; the presence of a set URG bit in a packettherefore indicates to the receiving TCP module that it should switch onthe urgency light. The UP points to the last byte of the urgent data(RFC 793 is confused about this - see  RFC 1122</p><p>TCP规范非常简短，因此请通读并了解紧急指针的含义。基本上，它是一种设施，TCP连接的一端可以通过该功能向另一端指示在流中某处存在紧急数据。从客户端（即应用程序层协议）的角度来看，每个套接字的输出流旁边都有一个按钮，另一个套接字的输入流旁边有一个红灯，都标记为“ URGENT” !!!＆＃39 ;;一端写一些它认为紧急的数据，然后按一下按钮：另一端的灯立即亮起，并且一旦客户端读取了发件人在按下按钮之前写的所有数据，该灯便熄灭。 TCP模块通过其数据包的两个组件来处理此问题：“紧急指针字段有效”。 （aka URG）控制位和紧急指针（UP）。按下按钮后发送的所有数据包中的URG位置1，直到包含紧急数据的最后一个字节的URG位；数据包中存在设置的URG位，因此向接收方TCP模块指示它应打开紧急灯。 UP指向紧急数据的最后一个字节（RFC 793对此感到困惑-请参阅RFC 1122</p><p>, section4.2.2.4, for the correction); the receiving module can turn off theurgency light once the client has read that byte. For completeness, i should point out that the UP field in the TCPheader is actually only 16 bits long; it expresses the UP as an offsetfrom the sequence number of the packet. RFC 793 is cagey about whathappens when the UP is more than 65535 greater than the current sequencenumber, but  RFC2147 says, inter alia:</p><p>，第4.2.2.4节，进行更正）；客户端读取该字节后，接收模块可以关闭紧急灯。为了完整起见，我应该指出TCPheader中的UP字段实际上只有16位长。它将UP表示为与数据包序列号的偏移量。 RFC 793对UP大于当前序列号大于65535时的情况保持谨慎态度，但RFC2147尤其指出：</p><p> When a TCP packet is to be sent with an Urgent Pointer(i.e., the URG bit set), first calculate the offset from the SequenceNumber to the Urgent Pointer. If the offset is less than 65535, fill inthe Urgent field and continue with the normal TCP processing. If theoffset is greater than 65535, and the offset is greater than or equal tothe length of the TCP data [which it will be, unless you&#39;re dealing withsuper-jumbograms], fill in the Urgent Pointer with 65535 and continuewith the normal TCP processing.</p><p> 当要发送带有紧急指针的TCP数据包时（即设置了URG位），请首先计算从序列号到紧急指针的偏移量。如果偏移量小于65535，请填写“紧急”字段，然后继续进行正常的TCP处理。如果偏移量大于65535，并且偏移量大于或等于TCP数据的长度（除非您正在处理超jumbograms，否则偏移量将为该长度），请用65535填充紧急指针，然后继续正常TCP处理。</p><p> Anyway, i propose abusing the urgent mechanism to mark the ends ofmessages: the urgent pointer simply points to the end of the currentmessage. Rather than connecting this to buttons and lights, theseqpacket-aware TCP module does the right thing with MSG_EOR: MSG_EORbeing set in send() causes the UP to be set, and hitting the UP whendoing recvmsg() causes it to set MSG_EOR. Simple!</p><p> 无论如何，我建议滥用紧急机制来标记消息的结尾：紧急指针只是指向当前消息的结尾。这些支持qqpacket的TCP模块没有将其连接到按钮和指示灯，而是对MSG_EOR进行了正确的处理：在send（）中设置MSG_EOR会导致设置UP，而在执行recvmsg（）时单击UP会导致它设置MSG_EOR。简单！</p><p> There is one little problem, which is that you can&#39;t pack multiplemessages into a single TCP packet, since you wouldn&#39;t be able to havethe UP pointing at the ends of all of them. This is a shame, but notthat big a deal; the whole sequenced packet thing is about reasonablybig packets. If a burning need for multiple messages per packets wasfelt, w e could specify a negotiable TCP option to hold additionalmessage-end pointers.</p><p> 有一个小问题，那就是您不能将多个消息打包到一个TCP数据包中，因为您将无法使UP指向所有消息的末尾。这是一个耻辱，但没什么大不了的。整个排序的数据包是关于相当大的数据包。如果感觉每个数据包急需多个消息，则可以指定一个可协商的TCP选项来保存其他消息末尾指针。</p><p> There is some degree of interaction between the mechanism i describeand TCP&#39;s push function. The push function was specified in part so thatapplications can indicate to the TCP module when they&#39;d got to the endof a block of data, so that it does not waste time waiting for more;with explicit message boundaries, it can work this out itself. TCPmodules should send less-than-MTU packets when and only when a messageend is signalled; the rest of the time, they should wait for enough datafrom the client to fill a complete packet, without any timeout. As wellas rendering the push function obsolete, explicit message boundariesalso make Nagle&#39;s algorithm unnecessary. The push function can, however,be repurposed: explicit pushes can be applied to indicate that a messageshould be delivered as quickly as possible (the push should be signalledin the same send that delivers the end-of-message indication). The TCPmodules should then do everything they can to deliver the messagequickly, and should indicate to the user that the message was pushed. Both these interactions with the user can be mediated by a MSG_PUSH flagin the send() or recvmsg() flags (and perhaps a MSG_PUSH_PENDING flag inrecvmsg(), to indicate that a message somewhere ahead is being pushed).The push would be communicated in the TCP packets by the setting of thePSH flag, as now. We might even enable out-of-order delivery of thepushed message, but that would be very weird. In essence, we&#39;re swappingthe semantics of the push and urgent functions!</p><p> 我描述的机制与TCP的push函数之间存在某种程度的交互作用。推送功能的部分指定是为了使应用程序可以在它们到达数据块末尾时向TCP模块进行指示，从而不会浪费时间等待更多数据；在具有显式消息边界的情况下，它可以正常工作本身。当且仅当发信号通知消息端时，TCP模块才应发送小于MTU的数据包。其余时间，他们应该等待客户端发送足够的数据以填充完整的数据包，而不会发生任何超时。除了使push函数过时之外，显式的消息边界也使Nagle的算法变得不必要。但是，可以重新使用推送功能：可以应用显式推送来指示应该尽快传递消息（应该在传递消息结束指示的同一发送中对推送进行信号通知）。然后，TCP模块应尽其所能快速传递消息，并应向用户指示消息已被推送。与用户的这两种交互都可以通过send（）或recvmsg（）标志中的MSG_PUSH标志（也可能是inrecvmsg（）中的MSG_PUSH_PENDING标志，以指示前面某条消息已被推送）来进行调解。像现在一样，通过PSH标志的设置来传输TCP数据包。我们甚至可以按顺序发送推送的消息，但这将非常奇怪。从本质上讲，我们正在交换push和紧急函数的语义！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://urchin.earth.li/~twic/Sequenced_Packets_Over_Ordinary_TCP.html">http://urchin.earth.li/~twic/Sequenced_Packets_Over_Ordinary_TCP.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/普通/">#普通</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/packets/">#packets</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tcp/">#tcp</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>