<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>可信可否认的加密（2020年）</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">可信可否认的加密（2020年）</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-19 03:44:28</div><div class="page_narrow text-break page_content"><p>可以安全地假设，在任何有用的密码系统中​    至少有一个人可以访问密钥k。具有足够影响力的对手可以通过对此人施加影响绕过常规攻击的计算成本。</p><p>这种技术有时被称为橡皮软管密码分析，它给了对手一些严肃的创作自由。密码系统的安全性现在不依赖于数学陷门函数的假定难度，而是依赖于某些人对身体或心理暴力的容忍度。小偷知道用枪打开保险箱比用钻头快得多。敌对政府同样会使用酷刑和监禁而不是计算能力来获取信息。</p><p>许多国家都有关键披露立法。在英国，RIPA首次被用来对付动物权利活动人士，以解锁在突袭他们家时查获的机器上发现的数据。拒绝交出关键材料的处罚最高可达两年监禁。</p><p>假设爱丽丝有一个密码系统C k CkC k​    其安全属性依赖于密钥k的保密性。为了防御这种形式的攻击，Alice需要某种方法来保密。她可以，</p><p>声称k不为人知。这包括它是否丢失或被遗忘。</p><p>假设马洛里是想要k k k的对手，假设爱丽丝为了避免暴露k k而提出索赔X X X X。定义成功可能很棘手，因为马洛里最终会决定不相信爱丽丝提出的任何索赔。然而，我们只会说，如果Mallory能够展示∗X\neg X∗X，并因此断言Alice能够访问k，并且能够提供它，那么她将获胜。因此，为了让爱丽丝获胜，X必须是不可伪造的，因此是一种合理的防御。</p><p>顺便说一句，如果爱丽丝知道并能证明∗X\neg X∗X，而马洛里却不能，那么很明显她遗漏了一些必要的信息。Kerckhofs原理认为密码系统的安全性​    我们应该完全依赖密钥k的保密性，所以一般来说，我们希望证明-X\neg X-X需要知道k。</p><p>我们将忽略与运营安全或实施相关的弱点。例如，如果马洛里听到爱丽丝向鲍勃承认她在撒谎，或者如果她在记忆中发现了一段明文，那么爱丽丝就输了。然而，这些情况很难用密码保护，因此我们假设在这方面是安全的。</p><p>对Alice来说，辩解对k的无知是一个简单的策略，因为它几乎没有争议的余地，而且几乎可以在任何地方作为一种策略使用。马洛里必须证明k是已知的，如果不真正产生它，这是很难做到的。也许钥匙在一个丢失的USB设备上，或者写在一张纸上，这张纸和爱丽丝的房子一起烧毁了。然而，仅仅是遗忘就意味着数据确实存在，检索数据的唯一障碍是访问爱丽丝的记忆。这可能并不令人满意。</p><p>断言密文不存在（2）等同于声称k不存在，因此不能公开。可信源于密文与随机噪声无法区分的事实。这意味着，给定一些潜在的密文c c，对手不能说c c c是均匀采样的，还是c=eK（m）c=eUK（m）c=eK​    （m）是在某个密钥kk下加密的有效消息m。为了证明c不是随机噪声，Mallory必须生成kk并计算m，这被认为是不可行的。</p><p>TrueCrypt和VeraCrypt允许创建隐藏卷和隐藏操作系统。这个想法是，一个普通的加密卷将在磁盘的未使用区域中填充随机数据，因此可以在不暴露其存在的情况下将一个隐藏卷放置在那里。</p><p>假设我们有一个引导驱动器，其标准卷由密钥K1 k_1 k 1保护​    还有一个被密钥k 2 k_2 k 2保护的隐藏卷​   . 未加密引导加载程序的存在揭示了一个事实，即标准卷存在，因此Mallory可以自信地请求它的密钥。Alice可以安全地为Mallory提供k 1 k_1 k 1​    从而揭示了标准卷中无害的内容。但是当Alice进入K2 k_2K 2​   , 引导加载程序无法解锁标准区域，因此它会尝试在隐藏卷头所在的偏移量处解密。如果隐藏卷存在且提供的密钥正确，则此操作成功，引导加载程序将继续引导隐藏的操作系统。</p><p>这是一个提供诱饵解密（3）的示例，但您可能注意到Alice还必须声明驱动器上剩余的“未使用”空间是随机噪声（2），不是有效的密文。二次索赔的必要性不是特例，而是试图以这种方式提供可否认性的系统的一般属性。</p><p>为剩余数据的存在提供一个合理的理由可能很棘手。VeraCrypt依赖于这样一个事实：在用作加密卷之前，驱动器通常会被随机数据擦除。在其他情况下，我们可能不得不更加狡猾。</p><p>这种策略确实有一些实际的局限性。如果卷承载一个操作系统，那么无害的操作系统必须和隐藏的操作系统一样频繁地使用，以使其看起来合法。例如，如果Alice提供了密钥，Mallory发现最后一次登录是两年前，但她知道Alice在前一天登录，那么Mallory可以非常确定某些东西已关闭。还考虑如果Mallory在隐藏卷中修改某些数据之前和之后看到驱动器的快照会发生什么。然后她知道那里有数据，而不仅仅是早期擦拭的残留物。</p><p>想象一下，在一个巨大的图书馆里，每本书都充满了胡言乱语。图书馆管理员将帮助您在图书馆内存储和检索数据。你给她一堆数据和一把万能钥匙。她使用主密钥导出加密密钥和随机位置。然后，数据被分割成书本大小的部分，每个部分都用派生密钥加密。最后，每本加密书都存储在甲骨文提供的位置。</p><p>更正式地说，假设“库”意味着键值存储。考虑一个密钥推导函数：→ K×K\Phi:K\到K\乘以KΦ：K→    K×K和密钥加密哈希函数H:K×N→ kh:K\times\mathbb{N}\to kh:K×N→    K、 其中K是密钥空间。我们还定义了一个加密函数E:K×M→ C E:K乘以M到C E:K×M→    C和相应的解密函数D:K×C→ md:K\乘以C\到md:K×C→    M、 其中M和C分别是消息空间和密文空间。</p><p>Alice提供了一个密钥k，Faythe使用它来派生子密钥a，b=Φ（k）a，b=\Phi（k）a，b=Φ（k）。Alice然后提供了一些数据p，这些数据被分成块p1、p2、…、pn、p1、p2、\ldots、p1​    ,   第2页​    ,  …  ,   p n​   , 那里的每一个人​    填充到相同的长度。最后，Faythe存储条目{ha（i）：eb（pi）}{ha（i）：eb（pi）\}{ha​    （i）：E b​    （第一页）​    ) } 在键值存储中。</p><p>对于解密，Alice再次提供密钥k，Faythe计算子密钥a，b=Φ（k）a，b=\Phi（k）a，b=Φ（k）。然后她重复了一遍我∈ N i\in\mathbb{N}i∈     N、 检索值ci_i ci​    对应于键ha（i）H_a（i）ha​    （i）计算db（ci）=db（eb（pi））=pidub（cidui）=db（eb（pi））=pidub​    （c）一​    )  =     D b​    （E）b​    （第一页）​    ) )  =     PI​   , 在不存在键值对的i=n+1i=n+1i=n+1处停止。那么明文就是p=p1∥  第2页∥ … ∥  p n p=p_1\mathbin\Vert p_2\mathbin\Vert\ldots\mathbin\Vert p_n p=p 1​      ∥     第2页​      ∥    …   ∥     p n​   , 在取消添加每个PI后​   .</p><p>为了防止攻击，Alice存储的数据不是她从中获取的数据，还需要额外考虑完整性和身份验证。为了简单起见，我们把这个放在这里。</p><p>假设图书馆总共有n本书。Mallory不能对Alice的数据发表任何评论，除了它的总大小小于或等于可以存储在n本书中的数据量。如果迫不得已，爱丽丝被迫露出一把用来拼凑m本书数据的假钥匙，她需要一些方法来解释剩下的n− 男-男−    我没有用过的书。她可以说，</p><p>这看起来很熟悉。爱丽丝试图通过提供一个可以解锁一些无害数据的假钥匙来避免暴露她的实际数据。然后，她必须提出第二个主张，以解释在提供的密钥下未解密的剩余数据。</p><p>声称无知（A）和之前（1）一样有着微不足道的合理性论证和实践局限性。</p><p>断言剩余的书是由随机字节（B）组成，需要解释它们是如何出现的。她可以简单地说，她添加了它们，但这是一个我们想要关闭的蠕虫罐头。如果某个软件实现决定要添加多少诱饵书，它必然会向马洛里泄露有关诱饵预期频率的信息。这个值可以与爱丽丝声称的n相比较− 男-男−    我用诱饵找出爱丽丝是否撒谎的指标。</p><p>如果频率是随机决定的，我们也会遇到同样的问题，因为值必须在某个范围内。我们可以通过让爱丽丝自己决定频率来解决这个问题，但这很混乱，而且人类不擅长不可预测。无论如何，这种策略可以归结为Alice声称“为了解释遗留数据，我明确添加了诱饵条目”，这会让对手非常怀疑。</p><p>利用B的更好方法是让Faythe用随机数据替换要删除的书籍，而不是直接删除它们。然后Alice可以声称剩余的书籍已被删除，因此数据不再存在，无法解密。这样就可以很容易地解释任何数量的剩余书籍，但这确实意味着我们图书馆的规模只会随着时间的推移而增加。</p><p>Claim C是新的，有一些吸引人的特性，但它不能用于像Alice的笔记本电脑硬盘这样的个人存储介质，因为不太可能有合理的理由让其他人的数据出现在那里。相反，想象一下“图书馆”托管在一个由多人共享的服务上。然后，爱丽丝很容易声称剩下的条目不是她的。为了反驳爱丽丝的说法，马洛里需要对使用该服务的所有其他人施加影响。然而，这样的服务必须精心设计。例如，如果它存储了Alice正在使用的空间，那么这个值可以与Alice的声明和Mallory的胜利进行比较。</p><p>这个计划有一些缺点。将数据存储在离散的填充块中会带来开销。以非平凡的方式修改数据可能代价高昂。覆盖条目而不是删除条目会占用存储空间，而这些存储空间是“浪费”的，因为它不能保存任何有用的数据。在设计这个协议时，我发现我们必须非常小心，以避免失去我们的否认能力。必须对任何实施情况进行核查，以确保其在这方面没有不足。</p><p>然而，我们现在有了一种功能，可以让你在众多无法区分的数据包中存储任意数量的独立“文件夹”，对手无法推断出存储数据的最大大小以外的任何信息。这是一个强大的属性，但它应该被视为整体的一部分，包括您的威胁模型和可用性需求。</p><p>这里有一个实验性客户机实现了该协议的精神。截至本文撰写之时，它还没有准备好正式使用。不过，我有一些激动人心的想法，可以在不久的将来（希望如此）将其打造成一个可供生产使用的客户机。</p><p>{home:：使用rss/atom订阅}</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/否认/">#否认</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/deniable/">#deniable</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>