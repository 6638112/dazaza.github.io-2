<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>MCS-48：在不能除法的8位CPU上实现16位除法的探索</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">MCS-48：在不能除法的8位CPU上实现16位除法的探索</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-30 19:58:44</div><div class="page_narrow text-break page_content"><p>Recently while working on my  MCS-48 temperature sensor project I had to confront one of the largest challenges, which is to implement an option where changing a jumper displayed Fahrenheit instead of Celsius. The output from the DS18B10 temperature sensors is Celsius only, as it should be, so a conversion would need to be performed.</p><p>最近，当我在做我的MCS-48温度传感器项目时，我不得不面对最大的挑战之一，那就是实现一个选项，在更换套头衫时显示华氏温度而不是摄氏度。DS18B10温度传感器的输出仅为摄氏度，这是理所当然的，因此需要执行转换。</p><p>  In my case it’s +320 as I’m using fixed point arithmetic i.e. 15.3° = 153. This is a tough conversion to perform on an MCS-48 as we’ve got a bunch of different operations needed here:</p><p>在我的例子中，它是+320，因为我使用的是定点算术，即15.3°=153。在MCS-48上执行这一转换很困难，因为我们这里需要一系列不同的操作：</p><p>  A tall order for a CPU which has just  one math instruction: 8-bit add. To perform all of this, one must sling a long sequence of primitive instructions together. Since this is an assembly language only architecture, I couldn’t cheat by compiling it in C and pinching the resulting instructions as I have done for PIC16 in the past.</p><p>对于只有一条数学指令的CPU来说，这是一个很高的要求：8位加法。要执行所有这些操作，必须将一长串原始指令串在一起。因为这是一个仅限汇编语言的体系结构，所以我不能像过去对PIC16所做的那样，通过用C编译它并压缩生成的指令来欺骗它。</p><p>   (A scan of it can be viewed  here). Everything I needed was in there, except how to divide. There is no mention whatsoever in that manual of how to perform any kind of division operation,  but, tacked in the back of the 1980 edition MCS-48 handbook, I found this:</p><p>(可以在此处查看它的扫描)。我需要的东西都在里面，除了如何分配。手册中没有提到如何执行任何类型除法运算，但是，在1980版MCS-48手册的背面，我发现了以下内容：</p><p>  Unfortunately that routine only has an 8-bit quotient, which isn’t much use for my application because it would overflow in most cases.</p><p>不幸的是，该例程只有一个8位商，这对我的应用程序用处不大，因为它在大多数情况下都会溢出。</p><p>  if (celsius &lt; 0){ // If negative, note it, and make it positive // so we can work with simpler unsigned routines below celsius = -celsius; is_negative = 1;}fahrenheit = multiply_16x8r16(celsius, 9);// Divide by 50 so the result of divide_16x8r8 doesn&#39;t overflowfahrenheit = divide_16x8r8(fahrenheit, 50, &amp;remainder);// Factor remainderremainder = multiply_16x8r16(remainder, 10);// Divide and add remainderfahrenheit += divide_16x8r8(remainder, 50, NULL);if (is_negative){ // Make it negative again, if it was previously is_negative = 1;}// Add 32. Requires a 16-bit add with wrap around to// correctly handle negative temperaturesfahrenheit += 320</p><p>If(摄氏度&lt；0){//如果为负数，请记下，并将其设为正数//这样我们就可以使用低于摄氏度=-摄氏度；IS_负数=1；}华氏温度=Multiply_16x8r16(摄氏度，9)；//除以50，这样Divide_16x8r8的结果不会溢出fahrenheit=Divide_16x8r8(华氏，50，&amp；余数)；//因数剩余余数=Multiply_16x8r16(余数，10)；//并将余数相加fahrenheit+=Divide_16x8r8(余数，50，NULL)；IF(IS_NECTIVE){//再次将其设为负数，如果之前是IS_NECTIVE=1；}//添加32。需要16位加法，绕回以//正确处理负温度fahrenheit+=320。</p><p> While that does the job, it’s poo poo. What I really want is that complicated looking divide routine to have a 16-bit quotient, so I can do the division in a single operation. To help me understand it, I translated it to C code:</p><p>虽然这能起作用，但那是便便。我真正想要的是看起来很复杂的除法例程，它有一个16位的商，这样我就可以在一次操作中完成除法。为了帮助我理解它，我将其翻译成C代码：</p><p> uint8_t mcs48_divide(uint16_t dividend, uint8_t divisor, uint8_t *remainder){ if ((dividend &gt;&gt; 8) &gt;= divisor) goto mcs48_div_exit; // Impossible. Result would // overflow. Bail. for (int i = 0; i &lt; 8; i++) // One pass for each bit of result { uint8_t msb; uint8_t bit15_was_set = 0; if (dividend &amp; 0x8000) bit15_was_set = 1; // Note if this was set, dividend &lt;&lt;= 1; // Next bit msb = (dividend &gt;&gt; 8); if (msb &gt;= divisor || bit15_was_set) { // Subtract remainder from MSB, // preserve and increment quotient dividend = (((msb - divisor) &lt;&lt; 8) | (dividend &amp; 0xFF)) + 1; } }mcs48_div_exit: *remainder = (dividend &gt;&gt; 8); return (dividend &amp; 0xFF);}</p><p>Uint8_t mcs48_divide(uint16_t被除数，uint8_t除数，uint8_t*余数){if((被除数&&gt;；&gt；8)&gt；=除数)转到mcs48_div_exit；//不可能。结果将//溢出。保释。For(int i=0；i&lt；8；i++)//结果的每一位{uint8_tmsb；uint8_tbit15_WAS_set=0；if(红利&amp；0x8000)bit15_WAS_set=1；//注意如果已设置，则红利&lt；&lt；=1；//下一位MSB=(红利&&gt;8)；IF(MSB&&gt;T；=除数||bit15_WAS_SET){//从msb中减去余数，//保增商被除数=(msb-除数)&lt；&lt；&lt；8)|(被除数&amp；0xFF))+1；}}mcs48_div_exit：*剩余数=(被除数；&gt；&gt；8)；RETURN(被除数&amp；0xFF)；}</p><p> It’s immediately clear that it’s a  binary division implementation. What wasn’t immediately clear is how to make the change I wanted. I put the question to  stack overflow, and on the face of it, it looked like a dumb question, i.e. just double the integer type sizes,  stupid. predictably I got punished with a bunch of down-votes.</p><p>很明显，它是一个二进制除法实现。现在还不清楚的是如何做出我想要的改变。我把这个问题放到堆栈溢出上，从表面上看，它看起来像一个愚蠢的问题，即整数类型大小的两倍，愚蠢。不出所料，我受到了一大堆反对票的惩罚。</p><p> Yes we can do that, but it’s not what I want to do to the assembly routine that I’m trying to modify, so perhaps I didn’t quite ask the question as well as I could have done. The answer provided sent me in the right direction, in that the working accumulator needs to be larger, 24-bits in my case, and the 16-bit shift needs to be a 24-bit.</p><p>是的，我们可以这样做，但这不是我想要对汇编例程所做的事情，我正试图修改它，所以也许我没有问得很好，就像我本可以做的那样。提供的答案让我找到了正确的方向，因为工作累加器需要更大，在我的例子中是24位，而16位移位需要是24位。</p><p> uint16_t mcs48_div16(uint16_t dividend, uint8_t divisor, uint8_t *remainder){ uint32_t accumulator = dividend; for (int i = 0; i &lt; 16; i++) // One pass for each bit of result { uint8_t msb; uint8_t bit24_was_set = 0; if (accumulator &amp; 0x800000) bit24_was_set = 1; // Note if this was set, // can&#39;t check if after shift. accumulator &lt;&lt;= 1; // Next bit accumulator &amp;= 0xFFFFFF; // Simulate 24 bit type msb = (accumulator &gt;&gt; 16); if (msb &gt;= divisor || bit24_was_set) { // Subtract remainder from MSB, // preserve and increment quotient accumulator = (((msb - divisor) &lt;&lt; 16) | (accumulator &amp; 0xFFFF)) + 1; } }mcs48_div_ext_exit: *remainder = (accumulator &gt;&gt; 16); return (accumulator &amp; 0xFFFF);}</p><p>Uint16_t mcs48_div16(uint16_t被除数，uint8_t除数，uint8_t*余数){uint32_t累加器=被除数；for(int i=0；i&lt；16；i++)//结果{uint8_t msb；uint8_t bit24_was_set=0；if(累加器&amp；0x800000)bit24_WAS_set=1；//注意如果已设置，//CAN&t检查移位后是否。累加器&lt；&lt；=1；//下一位累加器&amp；=0xffffff；//模拟24位类型msb=(累加器&gt；&gt；16)；if(msb&gt；=除数||bit24_WAS_set){//从msb减去余数，//保增商累加器=(msb-除数)&lt；&lt；16)|(累加器&amp；0xFFFF))+1；}}mcs48_div_ext_exit：*余数=(累加器&gt；&lt；16)；RETURN(累加器&amp；0xFFFF)；}。</p><p> Above is the pseudo code of my routine after the changes. In the final implementation registers A, R1 and R2 hold the 24-bit accumulator, so this doesn’t translate too well to C because there isn’t a 24-bit integer type.</p><p>上面是我的例程修改后的伪代码。在最终实现中，寄存器A、R1和R2保存24位累加器，因此这不能很好地转换为C，因为没有24位整数类型。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://tech.mattmillman.com/mcs-48-the-quest-for-16-bit-division-on-the-8-bit-cpu-which-cant-divide-anything/">http://tech.mattmillman.com/mcs-48-the-quest-for-16-bit-division-on-the-8-bit-cpu-which-cant-divide-anything/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/除法/">#除法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bit/">#bit</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/累加器/">#累加器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>