<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>totally_safe_transmute，逐行 Totally_safe_transmute, Line-by-Line</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Totally_safe_transmute, Line-by-Line<br/>totally_safe_transmute，逐行 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-17 05:07:59</div><div class="page_narrow text-break page_content"><p>The file linked(written by  Benjamin Herr) in the tweet purports to implement aversion of Rust’s   std::mem::transmutewithout any use of  unsafe. If you run it, you’ll find that it does indeed work!</p><p>这些文件链接（由Benjamin Herr编写）在推文的声音中实现厌恶生锈的std :: mem :: mem :: transfultwithout的任何使用不安全。如果你经营它，你会发现它确实有效！</p><p> #[test] fn  main ()  {  let  v :  Vec &lt; u8 &gt;  =  b &#34;foo&#34; .to_vec ();  let  v :  String  =  totally_safe_transmute ( v );  assert_eq! ( &amp; v ,  &#34;foo&#34; ); }</p><p> ＃[test] fn main（）{设v：vec＆lt; U8＆gt; = B＆＃34; foo＆＃34; .to_vec（）;设v：string = totally_safe_transmute（v）; assert_eq！ （＆amp; v，＆＃34; foo＆＃34;）; }</p><p>  $ git clone https://github.com/ben0x539/totally-safe-transmute $ cargo build $ cargo  test Compiling totally-safe-transmute v0.0.3  (/tmp/totally-safe-transmute ) Finished  test  [unoptimized + debuginfo] target (s )  in 0.49s Running target/debug/deps/totally_safe_transmute-be2ea6d9a3f8d258running 1  testtest main ... ok test result: ok. 1 passed ; 0 failed ; 0 ignored ; 0 measured ; 0 filtered out ; finished  in 0.00s Doc-tests totally-safe-transmuterunning 0 tests test result: ok. 0 passed ; 0 failed ; 0 ignored ; 0 measured ; 0 filtered out ; finished  in 0.00s</p><p>  $ git clone https://github.com/ben0x539/totaly- safe-transmute $ cargo build $ cargo测试编译完全安全 - 传输v0.0.3（/ tmp /完全安全传输）完成测试[未通过+ debuginfo] Target（s）在0.49s运行目标/ debug / deps / totally_safe_transmute-be2ea6d9a3f8d258 running 1 testtest main ...确定测试结果：好的。 1通过; 0失败; 0忽略了; 0测量; 0过滤出来;完成在0.00s Doc-Tests完全安全 - 透射术0测试结果：OK。 0通过; 0失败; 0忽略了; 0测量; 0过滤出来;完成0.00秒</p><p> This blog post will go through that implementation, line-by-line, and explainhow it works. Nothing about it is especially complicated; I just got a hugekick out of it and figured I’d provide a detailed explanation. Rust newcomersare the intended audience.</p><p> 此博客文章将通过该实施，逐行，并解释它的工作原理。没有什么特别复杂的;我刚刚出现了一个巨大的东西，想知道我会提供详细的解释。 Rust Newcomearsare预期的受众。</p><p>  Most unsafe languages have mechanisms for  transmuting (or  reinterpreting)the data at some memory address as an  entirely new type. C includesreinterpretation under its casting syntax; C++provides the more explicit  reinterpret_cast&lt;T&gt;(with  plenty of warningsabout  when  reinterpret_cast is well-defined).</p><p>  大多数不安全的语言都有用于在某些内存地址处传输（或重新诠释）数据的机制，作为全新类型。 C在其铸造语法下包括诠释; C ++提供了更明显的重新诠释器＆lt; t＆gt;（当reinterpret_cast熟悉时，有很多警告发布）。</p><p>  C-style “generic” APIs typically produce results in the form of a  void *,with the caller being expected to cast the  void * to a suitable type.Callers are responsible for ensuring that the destination typeis identical to or compatible with the type that was initially cast to  void *.</p><p>  C样式“通用”API通常会产生VOID *的形式产生的结果，呼叫者预计将Void *施放到合适的类型.Callers负责确保目的地类型与类型相同或兼容最初是施加到空白*。</p><p>  C and C++ callback patterns frequently provide a  void * parameter, allowingusers to supply additional data or context between callbacks. Each callbackis then responsible for casting to the appropriate type.</p><p>  C和C ++回调模式经常提供void *参数，允许用户在回调之间提供其他数据或上下文。然后，每个呼叫负责铸造到适当的类型。 </p><p>  Pointer values occasionally need  1 to be round-tripped through anintegral type. C++ specifically allows this, so long as the destination integraltype has at least sufficient width to represent all possible pointer values.</p><p>指针值偶尔需要1通过ANINTEGLAL类型循环。 C ++专门允许这一点，只要目的地积分型至少具有足够的宽度来表示所有可能的指针值。</p><p>  Polymorphism: the  Berkeley sockets APIspecifies   connect(2)as accepting a  struct sockaddr *, which is actually reinterpreted internallyas one of the family-specific  sockaddr structures (like  sockaddr_in for IPv4sockets). C++ also explicitly allows this under its “similarity” rules.</p><p>  多态性：Berkeley套接字Apispecifies Connect（2）接受结构SockAdd *，它实际上是在Internally中重新解释的家庭特定的SockAddr结构之一（例如IPv4Sockets的Sockaddr_in）。 C ++还明确允许在其“相似性”规则下。</p><p>  Cheap object serialization or conversion: related to the above, but slightlydifferent: both C and C++ are okay with you converting pretty much any objectto  char *  2. This allows objects to be treated as  bags of bytes,which is handy when writing a hash table (you don’t care  what the contentsare, you just want to uniquely identify them) or when serializing structuresin a host-specific format  3.</p><p>  廉价的对象序列化或转换：与上面相关，但略微有关：C和C ++与您转换几乎任何ObjectOto Char * 2.这允许对象被视为字节的袋子，这在编写哈希表时是方便的（您不在乎内容内容，您只想唯一地识别它们）或序列化结构在特定于主机的格式3时。</p><p> Each of the above is useful, but  incredibly unsafe: transmutation is notan operation at runtime that turns one type into another, but rather a directive at compile time to treat some position in memory as if its typeis different. The result: most possible transmutations between typesresult in  undefined behavior.</p><p> 以上每个都是有用的，但令人难以置信的不安全：嬗变是在运行时诺兰操作，该运行时将一个类型变为另一个类型，而是在编译时将某些位置视为在内存中的某个位置，就像其类型一样。结果：TypesResult之间的大多数可能是未定义的行为。</p><p>  Rust needs to interface with C, so  4 Rust supports transmutation. It does so via  std::mem::transmute. But transmutationis a fundamentally unsafe operation, so Rust forbids the use of  mem::transmute exceptfor in explicitly  unsafe contexts:</p><p>  Rust需要与C接口，所以4 RUTR支持嬗变。它通过std :: mem :: transtute来实现。但是，转换了一个根本不安全的操作，因此Rust禁止使用MEM :: Transume Event for在明确的不安全上下文中：</p><p> use  std :: mem ; #[repr(C)] pub  struct  Foo  {  pub  a :  u8 ,  pub  b :  u8 ,  pub  c :  u8 ,  pub  d :  u8 } #[repr(C)] pub  struct  Bar  {  pub  a :  u32 } fn  main ()  {  let  foo  =  Foo  {  a :  0xaa ,  b :  0xbb ,  c :  0xcc ,  d :  0xdd  };  let  bar :  Bar  =  unsafe  {  mem :: transmute ( foo )  };  // output (on x86-64): bar.a = 0xddccbbaa  println! ( &#34;bar.a = {:x}&#34; ,  bar .a ); }</p><p> 使用std :: mem; ＃ ）{让foo = foo {a：0xaa，b：0xbb，c：0xcc，d：0xdd};让吧：栏=不安全{MEM :: Transume（Foo）}; //输出（x86-64）：bar.a = 0xddccbbaa println！ （＆＃34; bar.a = {：x}＆＃34;，酒吧.a）; }</p><p>  transmute can, of course, be wrapped into safe contexts. But the underlying operationwill always be fundamentally unsafe, and  should not be possible in otherwise safe Rust code.</p><p>  当然，传输可以包裹到安全的上下文中。但是底层操作总是不安全，不可能在其他安全的铁锈代码中。 </p><p>    #![forbid(unsafe_code)] use  std ::{ io ::{ self ,  Write ,  Seek },  fs }; pub  fn  totally_safe_transmute &lt; T ,  U &gt; ( v :  T )  -&gt;  U  {  #[repr(C)]  enum  E &lt; T ,  U &gt;  {  T ( T ),  #[allow(dead_code)]  U ( U ),  }  let  v  =  E :: T ( v );  let  mut  f  =  fs :: OpenOptions :: new ()  .write ( true )  .open ( &#34;/proc/self/mem&#34; ) .expect ( &#34;welp&#34; );  f .seek ( io :: SeekFrom :: Start ( &amp; v  as  * const  _  as  u64 )) .expect ( &#34;oof&#34; );  f .write ( &amp; [ 1 ]) .expect ( &#34;darn&#34; );  if  let  E :: U ( v )  =  v  {  return  v ;  }  panic! ( &#34;rip&#34; ); }</p><p>＃！[foutbid（不安全_code）]使用std :: {io :: {self，write，seek}，fs}; pub fn totally_safe_transmute＆lt; t，u＆gt; （v：t） - ＆gt; u {＃[R​​epre（c）]枚举e＆lt; t，u＆gt; {t（t），＃[允许（dead_code）] u（u），}让v = e :: t（v）;让mut f = f = fs :: OpenOptions :: new（）.write（true）.open（＆＃34; / proc / self / mem＆＃34;）.expect（＆＃34; welp＆＃34;）; F .seek（IO :: Seekfrom :: start（＆amp; v作为* const _为u64））.expect（＆＃34; Oof＆＃34;）; f .write（＆amp; [1]）.expect（＆＃34; darn＆＃34;）;如果让e :: u（v）= v {return v; }  恐慌！ （＆＃34; RIP＆＃34;）; }</p><p>   forbid is an attribute that controls the  rustc linter (along with  allow,  warn, and  deny).In this case, we’re telling  rustc to forbid anything that trips the  unsafe_code lint,which does exactly what it says on the tin: catches use of  unsafe.</p><p>   禁止是控制RUSTC LINTER（以及允许，警告和拒绝）的属性。在这种情况下，我们会告诉Rustc禁止禁止浏览不安全的嘴唇的任何东西，这正是它在TIN上所说的内容：捕获使用不安全。</p><p> In this case, forbidding use of  unsafe doesn’t do anything: a quick read of the code showsthat  unsafe never shows up. But it’s a top-level proof to the reader that,  if  rustc acceptsthe code (and it does),  then there is no use of  unsafe.</p><p> 在这种情况下，禁止使用不安全不做任何事情：快速阅读代码展示不安全从未显示过。但它是读者的顶级证明，如果rustc接受代码（并且它确实），那么没有使用不安全。</p><p>     It then takes one concrete parameter,  v, which is of type  T. Finally, itreturns a  U.</p><p>     然后它采用一个混凝土参数v，它是T型而最终，ITRETURNS A U.</p><p> We know that the job of a transmutation function is to reinterpret a type of somevalue as some other type, so we can rewrite this signature as:</p><p> 我们知道，嬗变功能的作业是将一种类型的SomeValue重新诠释为其他类型，因此我们可以将此签名重写为：</p><p>   Our next bit is a terse  enum with some funky attributes. Rewritten with our friendly typeparameters:</p><p>   我们的下一点是一个有一些时髦的属性的简洁枚举。用我们友好的typeparameters重写：</p><p>  First, we’re marking  E as  repr(C). This is an  ABI-modifying attribute: it tells rustc to lay  E out using the platform’s C ABI rather than the (intentionally) unstable Rust ABI.</p><p>  首先，我们将E作为ROP（C）标记为Rep（c）。这是ABI-Modify属性：它告诉RustC使用平台的C abi而不是（故意）的不稳定生锈abi。 </p><p> What does this actually  mean? For enums with fields (like this one), Rust uses a “tagged union” representation.In effect,  E becomes something like this (in C syntax):</p><p>这实际上是什么意思？对于具有字段的枚举（如此），RUST使用“标记的Union”表示形式。在效果中，E成为这样的东西（在C语法中）：</p><p>   Next:  E has two variants: the first holds a value of type  SrcTy, and the other holds a valueof  DstTy.</p><p>   下一页：E有两个变体：第一个包含SRCTY类型的值，另一个包含一个值。</p><p> But wait! Another  rustc linter annotation: this time, we’re telling  rustc that it’s okayfor the  U variant to fail the  dead_code lint.Normally,  rustc would warn us upon statically inferring that  U is never used; with dead_code enabled, it silences that warning. Like the ABI layout, we’ll see why that’s importantshortly.</p><p> 可是等等！另一个rustc linter注释：这次，我们告诉Rustc，你的变体无法失败的Dead_code Lint.Normally，RustC会在静态推断上方的情况下警告我们;使用DEAD_CODE启用，它静默警告。像ABI布局一样，我们会看到为什么这是重要的。</p><p> Finally, we shadow our  v parameter with a new binding.  v was already of type  T, socreating an  E::T from it is no problem at all.</p><p> 最后，我们通过新的绑定遮蔽了我们的v参数。 v已经是T型，Socreating e :: t完全没有问题。</p><p>    First, we’re opening a file. Specifically, we’re opening  /proc/self/mem in write mode.</p><p>    首先，我们正在打开一个文件。具体而言，我们在写模式下打开/ proc / self / mem。</p><p> /proc/self/mem is a  very special  5 file: it presents a view of the current process’smemory, sparsely mapped by virtual address ranges.</p><p> / proc / self / mem是一个非常特殊的5个文件：它介绍了当前进程的视图，虚拟地址范围稀疏地映射。</p><p> As a quick hack, we can prove this to ourselves in Python by checking out thein-memory representation of a  str object  6:</p><p> 作为一个快速的黑客，我们可以通过检查str对象6的内存表示来证明这一点在Python中： </p><p> &gt;&gt;&gt;  x  =  &#34;this string is long enough to prevent any string interning&#34; &gt;&gt;&gt;  # in cpython, an object&#39;s id is (usually) its pointer &gt;&gt;&gt;  x_addr  =  id ( x ) &gt;&gt;&gt;  hex ( x_addr ) &#39;0x7ff1bc7cfce0&#39; &gt;&gt;&gt;  mem  =  open ( &#34;/proc/self/mem&#34; ,  mode = &#34;rb&#34; ) &gt;&gt;&gt;  mem . seek ( x_addr ) &gt;&gt;&gt;  mem . read ( len ( x )  *  4 ) b &#39;[SNIP] &#34;thi \x00\x00\x00\x00\x00\x00\x00\x00 this string is long enough to prevent any string interning \x00 e \&#39; [SNIP]&#39;</p><p>＆gt;＆gt;＆gt; x =＆＃34;此字符串足够长，以防止任何字符串互动＆＃34; ＆gt;＆gt;＆gt; ＃在cpython中，对象＆＃39; s id（通常）它的指针＆gt;＆gt;＆gt; x_addr = id（x）＆gt;＆gt;＆gt;十六进制（X_ADDR）＆＃39; 0x7FF1BC7CFCE0＆＃39; ＆gt;＆gt;＆gt; mem =打开（＆＃34; / proc / self / mem＆＃34; mode =＆＃34; rb＆＃34;）＆gt;＆gt; mem。寻求（x_addr）＆gt;＆gt;＆gt; mem。读（Len（x）* 4）B＆＃39; [Snip]＆＃34; thi \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00这个字符串足以阻止任何字符串interning \ x00 e \＆＃39; [Snip]＆＃39;</p><p>   &gt;&gt;&gt;  # using ctypes to avoid the layout muckery we saw above &gt;&gt;&gt;  import  ctypes &gt;&gt;&gt;  cstr  =  ctypes . c_char_p ( b &#34;look ma, no hands&#34; ) &gt;&gt;&gt;  cstr_addr  =  ctypes . cast ( cstr ,  ctypes . c_void_p ). value &gt;&gt;&gt;  hex ( cstr_addr ) &#39;0x7f47f3e9c790&#39; &gt;&gt;&gt;  mem  =  open ( &#34;/proc/self/mem&#34; ,  mode = &#34;r+b&#34; ) &gt;&gt;&gt;  mem . seek ( cstr_addr ) &gt;&gt;&gt;  mem . read ( len ( cstr . value )) b &#39;look ma, no hands&#39; &gt;&gt;&gt;  mem . seek ( cstr_addr  +  5 ) &gt;&gt;&gt;  mem . write ( &#39;p&#39; ) &gt;&gt;&gt;  mem . seek ( cstr_addr ) &gt;&gt;&gt;  mem . read ( len ( cstr . value )) b &#39;look pa, no hands&#39;</p><p>   ＆gt;＆gt;＆gt; ＃使用CTYPE避免我们看到的布局拍白，而GT;＆gt;＆gt;进口ctypes＆gt;＆gt;＆gt; cstr = ctypes。 c_char_p（b＆＃34;看起来ma，没有手和＃34;）＆gt;＆gt; cstr_addr = ctypes。 CAST（CSTR，CTYPES。C_VOID_P）。价值＆gt;＆gt;＆gt;十六进制（CStr_addr）＆＃39; 0x7f47f3e9c7​​90＆＃39; ＆gt;＆gt;＆gt; MEM =打开（＆＃34; / proc / self / mem＆＃34;，mode =＆＃34; r + b＆＃34;）＆gt;＆gt;＆gt; mem。寻求（cstr_addr）＆gt;＆gt;＆gt; mem。读（len（cstr.value））b＆＃39;看起来ma，没有手＆＃39; ＆gt;＆gt;＆gt; mem。寻求（CStr_Addr + 5）＆gt;＆gt;＆gt; mem。写（＆＃39; p＆＃39;）＆gt;＆gt; mem。寻求（cstr_addr）＆gt;＆gt;＆gt; mem。读（Len（CSTR.值））B＆＃39;看PA，没有手和＃39;</p><p> The next two pieces of  totally_safe_transmute should now make sense: we seekto the address of our  v variable (which is now a variant of  E) within  our own running process,and we write a single  u8 to it ( [1]).</p><p> 完全两块完全_safe_transmute现在应该是有意义的：我们在自己的运行过程中寻求我们的V变量（现在是e的变体）的地址，我们为它写了一个U8（[1]）。</p><p> But why  1? Recall our C ABI representation of  E above! The first piece of  E is ourunion discriminator. When  data is  SrcTy,  discriminant is  0. When we forcefullyoverwrite it to  1,  data is now interpreted as  DstTy!</p><p> 但为什么1？回想起上面的e的c abi表示！第一部分是iurunion判别者。当数据是SRCTY时，判别是0.当我们强制性地搬运到1时，数据现在被解释为DSTTY！</p><p>  Okay, so we’ve poked memory and turned our  E::T into an  E::U. Let’s see how we get it out:</p><p>  好的，所以我们已经戳了记忆并将我们的E :: T转变为E :: U。让我们看看我们是如何让它的：</p><p>  At first glance, there’s nothing special about this: we’re simply discarding the enum wrapperthat we added earlier so that we can return our newly-minted value of  DstTy.</p><p>  乍一看，这对此没有什么特别之处：我们只是丢弃了我们之前添加的枚举包装，以便我们可以返回我们的新棉被的dstty值。</p><p>  …but the only way to return a  DstTy is for  v to be an  E::U.</p><p>  ......但是返回dstty的唯一方法是v为e :: u。 </p><p>  … but  v was unconditionally initialized as an  E::T, so that return is never reached.</p><p>......但V无条件初始化为E :: T，因此从未达到过返回。</p><p> This is why we needed  allow(dead_code) earlier: no  E::U is ever constructed in a manner thatcould possibly reach the  return statement, so there’s simply no need for it as a variant.And indeed, we can confirm this by removing the  allow attribute:</p><p> 这就是我们需要允许（Dead_Code）之前的原因：没有E :: U曾经以那种可能达到返回声明的方式构建，因此只不需要它作为一个变种。确实，我们可以通过删除来确认这一点允许属性：</p><p> $ cargo build Compiling totally-safe-transmute v0.0.3  (/tmp/totally-safe-transmute )warning: variant is never constructed:  `U `  -- &gt; src/lib.rs:9:9 |9 | U (U ), | ^^^^ |  = note:  ` #[warn(dead_code)]` on by defaultwarning: 1 warning emitted Finished dev  [unoptimized + debuginfo] target (s )  in 0.15s</p><p> $ Cargo Build Compling完全安全 - 传输V0.0.3（/ TMP /完全安全 - 传输）警告：Variant永远不会构建：`U`  - ＆gt; SRC / lib.rs：9：9 | 9 | U（U），| ^^^^ | =注意：`＃[Warn（Dead_Code）]`On默认运行：1个警告发出的完成Dev [未通过+ DebugInfo]目标0.15s</p><p> But alas: it’s not really dead code: the compiler is “wrong,” and we popan  E::U into existence at runtime by modifying the program’s own memory. We then hitour impossible condition, and return our transmuted value.</p><p> 但是，唉：这不是真正死的代码：编译器是“错误的”，我们通过修改程序自己的内存来在运行时生成存在。然后我们是不可能的条件，并返回我们的传输价值。</p><p>  totally_safe_transmute is a delightful hack that demonstrates a key limitation when reasoningabout a program’s behavior: every behavior model is contingent on an  environmental model andhow the program (or the program’s runtime, or the compiler, or whatever else) chooses (or doesn’tchoose) to handle seemingly impossible conditions in said environment.</p><p>  totally_safe_transmute是一个令人愉快的黑客，演示了当推理程序的行为时的关键限制：每个行为模型都是在环境模型上的偶然，并在程序（或程序的运行时，或编译器，或其他任何其他人）选择（或未切断）在所述环境中处理看似不可能的条件。</p><p> The ability to do this doesn’t reflect fundamental unsafety in Rust, any more than it doesany safe language: from Rust’s perspective, what  totally_unsafe_transmute does is impossibleand therefore undefined; there’s no point in in handling something that cannot happen.</p><p> 这样做的能力不会反映生锈的根本不良，任何不仅仅是它的安全语言：从Rust的角度来看，完全_Unsafe_Transmute是什么，因此undefined是不可义的;处理无法发生的事情。</p><p>  As mentioned previously, this hack only works on Linux due to its dependency on  /proc/self/mem.Other OSes may have similar mechanisms.</p><p>  如前所述，这种黑客仅通过对/proc/self/mem的依赖性作用于Linux。其他操作系统可能具有类似的机制。 </p><p>  I haven’t tested this, but I’m pretty sure it only works on little-endian architectures (like x86).On big-endian architectures, the  write would probably need to be adjusted.</p><p>我没有测试过这个，但我很确定它只适用于小型架构（如x86）.on大endian架构，写入可能需要调整写作。</p><p>  If we’re being extremely pedantic: this  technically isn’t a transmutation. Semantically,transmutation is a operationless change in types at compile time;  totally_safe_transmuterewrites the in-memory representation of the program to accomplish equivalent behavior at runtime.I don’t think this is a distinction that makes a difference.</p><p>  如果我们非常迂腐：这技要技术上不是嬗变。语义上，嬗变是编译时类型的无效变化; totally_safe_transmutewrites程序的内存内存表示，以在运行时完成等效行为。我认为这是一个有区别的区别。</p><p>  Because  totally_safe_transmute relies on undefined behavior (an impossible program state),Rust would be correct in erasing the  E::U branch altogether and reducing the function to anunconditional  panic!. It doesn’t do that in my testing (even in release mode), but there’sabsolutely nothing in the program semantics that prevents it from doing so. But maybeone day it will, and  totally_safe_transmute will stop working!</p><p>  因为Totally_Safe_Transmute依赖于未定义的行为（不可能的程序状态），因此在擦除E :: U分支并将功能缩短到Anuncuditional Punic的功能，Rust将是正确的！它在我的测试中没有这样做（即使在释放模式下），但程序语义中没有任何东西可以防止它这样做。但是，它会的日子，而且完全_safe_transmute会停止工作！</p><p> One of the great sins of application and network programming, and a common source of vulnerabilities.  ↩</p><p> 应用程序和网络编程的巨大罪行之一，以及漏洞的共同来源。 ↩</p><p>  Among other reasons. As mentioned, transmutation  is useful when all of need is a “bag of bytes” view of some object, or when you can guarantee consistent type layouts. It’s also useful for  advanced lifetime hackery.  ↩</p><p>  除其他原因之外。如上所述，当所有需求是某些对象的“一对字节”视图时，嬗变是有用的，或者当您可以保证一致的类型布局时。它对先进的寿命抹布也很有用。 ↩</p><p>  And platform-specific: it’s part of Linux’s procfs. As a result,  totally_safe_transmute won’t work (as-is) on other OSes.  ↩</p><p>  特定于平台：它是Linux的Procfs的一部分。因此，Totally_Safe_Transmute将无法在其他内容上运行（AS-IS）。 ↩</p><p>  Which, as you’ll notice, is not trivial (it’s not just a length-data pair).  unicodeobject.h in the CPython source has the full structure details, which are completely irrelevant to this post.  ↩</p><p>  正如您所明白的那样，它不是微不足道的（它不仅仅是一个长度数据对）。 unicodeObject.h中的CPython源具有完整的结构细节，完全与此帖子无关紧要。 ↩ </p><p>  Reddit discussion</p><p>Reddit讨论 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.yossarian.net/2021/03/16/totally_safe_transmute-line-by-line">https://blog.yossarian.net/2021/03/16/totally_safe_transmute-line-by-line</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/safe/">#safe</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012 - 2021 diglog.com </div></div></body></html>