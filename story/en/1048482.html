<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>关于使用Haskell进行启动的思考 Reflections on Using Haskell for My Startup</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Reflections on Using Haskell for My Startup<br/>关于使用Haskell进行启动的思考 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-19 16:06:37</div><div class="page_narrow text-break page_content"><p>Almost exactly one year ago I quit my job to create a Haskell startup as a solo developer. I had about 20 ideas, but eventually settled on the idea of dependency project health tracking with  Deadpendency.</p><p>几乎恰好一年前，我退出了我的作业，以创建一个哈克尔启动作为独奏开发人员。我有大约20个想法，但最终解决了依赖项目健康跟踪的理念，致命的死亡。</p><p>    Since about 2016 I have had a strong  obsession love of Haskell. Prior to learning Haskell, I was an experienced OO style developer but I didn’t really know how to keep improving my raw programming ability. Haskell introduced me to the world of functional programming (FP) which has an almost infinite depth of concepts to learn, which do actually help improve code quality and application architecture.</p><p>    自从大约2016年以来，我对Haskell有一个强烈的痴迷。在学习Haskell之前，我是一名经验丰富的OO风格的开发人员，但我并不真正知道如何继续提高我的原始编程能力。 Haskell向我推出了功能规划（FP）的世界，它具有几乎无限的概念来学习，其实际上有助于提高代码质量和应用架构。</p><p>  Haskell is challenging to learn, but extremely fun to write. For my own learning and pleasure, if my startup succeeds, I want to be doing Haskell.</p><p>  Haskell挑战了解，但非常有趣。为了我自己的学习和乐趣，如果我的初创公司成功，我想做哈克尔。</p><p> Additionally, I think Haskell is the best general purpose programming language (that you can use in production). In particular, Haskell excels at writing ‘boring’ business applications which is typically what I work on.  ‘Why Haskell For Production’ goes into more detail on the benefits Haskell offers.</p><p> 此外，我认为Haskell是最好的通用编程语言（您可以在生产中使用）。特别是，Haskell擅长写作“无聊”的业务应用程序，通常是我的工作方式。 '为什么Haskell生产'对Haskell优惠的好处有更多细节。</p><p>   Probably the most challenging part was building out a skeleton architecture to hang my business logic on. I decided to go with, even within Haskell, fairly advanced libraries of   servant and   fused-effects.</p><p>   可能是最具挑战性的部分，建立了一个骨架架构，以悬挂我的业务逻辑。我决定在Haskell，公平的仆人和融合效果的公平图书馆。</p><p> I spent a fair amount of time banging my head against a wall trying to get these libraries to work nicely together. This was primarily from a lack of Haskell ability on my part. I had prepared as best I could, but Haskell is deep and I needed to learn more to work day to day with it. I was lucky enough to eventually find  an example that marries these two libraries together, which was a life saver. I’m sure I would have gotten there eventually, but I was in a bit over my head at that point.</p><p> 我花了很少的时间敲击我的脑袋，试图让这些图书馆齐心协力地工作。这主要是缺乏缺乏哈斯克尔能力的能力。我尽我所能准备，但哈斯克尔深处，我需要学习更多的时间来与它一起工作。我很幸运，最终找到一个婚姻与这两个图书馆一起结婚的例子，这是一个救生员。我相信我最终会得到那里的那个，但在那一点上我有点盯着我。</p><p>  Haskell is awesome, but like most languages there is cruft and legacy to be avoided. Haskell has a standard library known as   base which unfortunately has a fair amount of unsafe or unperformant functions included. As such I went with an alternative standard library   relude that builds on and improves  base. On top of this, there are many core libraries that are not part of the standard library I wanted to use and have nice patterns around.</p><p>  Haskell很棒，但与大多数语言一样有Cruft和遗留遗产。 Haskell有一个标准库，称为遗迹，遗憾的是，包括包括的不安全或不规则的功能。因此，我与另类标准库中的替代标准库中建立并改善了基础。在此之上，有许多核心库是我想要使用的标准库的一部分，并且周围有很好的模式。 </p><p> Additionally, I was  deploying to google cloud and so needed to figure out good patterns for that integration from Haskell.</p><p>此外，我正在部署到Google Cloud，因此需要从Haskell找出实现集成的良好模式。</p><p> This setup effort was quite challenging. I spent most of it squinting at compiler errors. Yet it only took about 2 weeks to have a good foundation of code to start building my business logic upon.</p><p> 设置工作非常具有挑战性。我花了大部分时间看着编译器错误。但是，只花了大约2周的时间便有了一个良好的代码基础就可以开始构建我的业务逻辑。</p><p>  This is when it started to get really fun. I had my core patterns set out and I could focus on building a pipeline. The day in day out of writing out my logic as small pure functions that I composed together was very nice.</p><p>  这是开始变得非常有趣的时候。我设定了核心模式，可以专注于建立管道。日复一日地将我的逻辑写成我组成的小型纯函数非常好。</p><p> Haskell has such impressive auto-magic code generation techniques that you spend much more time focused on the interesting logic of your application rather than boilerplate.</p><p> Haskell具有令人印象深刻的自动魔术代码生成技术，以至于您花费更多的时间专注于应用程序有趣的逻辑上，而不是样板上。</p><p> data  HappinessLevel  =  Miserable  |  Sad  |  Average  |  Happy  |  HaskellDeveloper  deriving  ( Show ,  Eq ,  Ord ,  Bounded ,  Enum ,  ToJSON ,  FromJSON )  -- magic code generation -- ok not really magic, think &#39;convention over configuration&#39; -- where you can have generated sane defaults, or customise if you like</p><p> 数据HappinessLevel =悲惨|伤心|平均快乐HaskellDeveloper派生（Show，Eq，Ord，Bounded，Enum，ToJSON，FromJSON）-神奇的代码生成-可以，这不是真正的神奇，请考虑对配置的常规-您可以在其中生成合理的默认值，或者根据需要进行自定义</p><p>   A lot of the logic of Deadpendency is parsing. Either parsing dependency files or parsing various API responses. Haskell has many excellent parsing libraries, most notably   aeson for JSON.</p><p>   Deadpendency的许多逻辑正在解析。解析依赖文件或解析各种API响应。 Haskell有许多出色的解析库，最著名的是aeson for JSON。</p><p> Why is this nice in Haskell? The ‘monad’ abstraction is excellent for dealing with code with a lot of failure conditions (ie. parsing) and avoids ‘pyramid of doom’ type code. Haskell worked out really well in this key area.</p><p> 为什么在Haskell这么好？ “ monad”抽象非常适合处理具有很多失败条件（例如，解析）的代码，并且避免了“金字塔厄运”类型的代码。 Haskell在这一关键领域的表现非常出色。 </p><p>   Another strong positive for writing Deadpendency was testing. Haskell has a lesser-known style of testing libraries that do ‘property based testing’ (PBT).</p><p>编写《 Deadpendency》的另一个强项是测试。 Haskell具有鲜为人知的测试库样式，可以执行“基于属性的测试”（PBT）。</p><p> PBT allows you to write value generators for your data types, which you use to generate 100s or 1000s of test cases. Then, you run these generated values against some function and check that certain properties hold.</p><p> PBT允许您为数据类型编写值生成器，用于生成100或1000s测试用例。然后，对某些函数运行这些生成的值，并检查某些属性是否成立。</p><p> For example, part of the Deadpendency logic is generating an HTML report at the end. I had some  toHtml :: Report -&gt; HTML function that I wanted to test. So I wrote a  fromHtml :: HTML -&gt; Report function where it goes the other way (ok writing that was pretty painful). Then my PBT test will generate 100s of  Report values and check that  report == fromHtml (toHtml report) (this is known as ‘roundtrip testing’). With this single test I was able to find many edge case bugs with my HTML report generation logic.</p><p> 例如，Deadpendency逻辑的一部分是在最后生成HTML报告。我有一些toHtml :: Report->我要测试的HTML函数。所以我写了一个fromHtml :: HTML->报告功能的另一种方式（好的编写很痛苦）。然后，我的PBT测试将生成100个Report值，并检查report == fromHtml（toHtml报告）（称为“往返测试”）。通过此测试，我可以使用HTML报告生成逻辑找到许多边缘案例错误。</p><p>  PBT exists in some other languages, but it originated (I believe?) in Haskell so the libraries are excellent.</p><p>  PBT还存在其他一些语言，但它起源于Haskell（我相信吗？），因此这些库非常出色。</p><p>  A big challenge of working with Haskell was the lack of well-maintained libraries. Ironically, of the 75 (!) packages I depend upon 19 are flagged by Deadpendency as unhealthy (deprecated or inactive). This means I often don’t have the luxury of asking library maintainers to fix bugs. Even if I PR a fix, sometimes that PR will be ignored for months.</p><p>  与Haskell合作的一大挑战是缺少维护良好的库。具有讽刺意味的是，在我依赖的19个75（！）软件包中，Deadpendency将其标记为不健康（已弃用或不活动）。这意味着我经常没有要求图书馆维护者修复错误的奢侈行为。即使我PR了修复程序，有时该PR也将被忽略数月。</p><p> This I think is the reality of using a niche language like Haskell. To be clear, I do not think library developers owe me anything, but it is nonetheless a downside when compared to more popular languages.</p><p> 我认为这是使用像Haskell这样的小众语言的现实。明确地说，我认为图书馆开发人员不欠我任何东西，但是与更流行的语言相比，这是不利的。</p><p>  Thankfully Haskell build tools have good support for loading a package from git. This means you can PR some bug fix or feature and immediately use your fork to work around the problem.</p><p>  值得庆幸的是，Haskell构建工具为从git加载软件包提供了良好的支持。这意味着您可以PR一些错误修复或功能，然后立即使用fork来解决此问题。 </p><p>  I thought I’d call this out as it is a common complaint I see around Haskell. I followed some  good advice which kept compilation fast (aside from  one interesting edge case I resolved).</p><p>我以为可以这样称呼，因为这是我在Haskell周围经常看到的投诉。我遵循了一些很好的建议，这些建议可以使编译保持快速（除了我解决的一个有趣的极端情况）。</p><p> Dell 9570 XPS Laptop - (Hex core - 8th-gen Intel Core i7-8750H CPU), 32GB memory</p><p> Dell 9570 XPS笔记本电脑-（Hex核心-第八代Intel Core i7-8750H CPU），32GB内存</p><p>    This is compiling all application dependencies, which needs to be done before you can compile your application code. Rebuilding all from scratch rarely happens as both my dev machines and CI will cache and only rebuild what has changed.</p><p>    这是在编译所有应用程序依赖项，这需要在编译应用程序代码之前完成。从头开始重建所有内容的情况很少发生，因为我的开发机器和CI都将缓存并且仅重建已更改的内容。</p><p> You do sometimes update a very core package which triggers a lot of dependent packages to recompile which can take a while. Although, I usually do dependency updates at the start of the day while I’m sipping my coffee, so usually don’t notice.</p><p> 有时您确实会更新一个非常核心的软件包，这会触发许多依赖的软件包重新编译，这可能需要一段时间。虽然，我通常在喝咖啡的第一天开始时进行依赖更新，所以通常不会注意到。</p><p>   Likewise, due to caching a full recompilation rarely happens. As such, most code edits do not trigger many modules to be recompiled and it is fast.</p><p>   同样，由于缓存，很少发生完全重新编译。因此，大多数代码编辑不会触发许多模块进行重新编译，而且速度很快。</p><p> Additionally, Haskell has nice ‘continuous compilation’ tools that fire on save. Usually by the time I actually look at my terminal compilation is already done.</p><p> 此外，Haskell具有不错的“连续编译”工具，可在保存时触发。通常，到我实际查看终端编译时为止。</p><p>    This typically runs in CI. It runs in parallel with a host of other checks such as running my tests, which also take a few minutes. Due to this, the time doesn’t really impact the build + deploy time too much.</p><p>    这通常在CI中运行。它与许多其他检查（例如运行我的测试）并行运行，这也需要几分钟。因此，时间并不会真正影响构建和部署时间。 </p><p>   Deadpendency is relatively simple in what it does, but there is a lot of hidden complexity to the problem. Which is to say, it is like 99% of applications 😉. When developing it I was constantly realising I had modelled things a bit too simplistically and would need to refactor.</p><p>暂挂方式的工作相对简单，但是这个问题有很多隐藏的复杂性。也就是说，它占应用程序的99％。在开发它时，我一直在意识到自己对模型的建模过于简单了，需要进行重构。</p><p> Haskell is very safe to refactor thanks to the type safety the compiler brings, which is probably the most important thing. However, Haskell does not have great tools to help with refactoring, at least in terms of the restructuring changes I kept making. The  existing  tools seem more geared towards complex rewriting of common code, not restructuring modules or renaming identifiers.</p><p> 由于编译器具有类型安全性，Haskell的重构非常安全，这可能是最重要的。但是，Haskell并没有强大的工具来帮助重构，至少在我不断进行的重组方面。现有工具似乎更适合于通用代码的复杂重写，而不是重构模块或重命名标识符。</p><p> As such I did it all manually with text search replace, or just change something and fix all the new compiler errors. This was a bit of a grind and it caused me to delay needed refactoring sometimes.</p><p> 这样，我通过替换文本搜索手动完成了所有操作，或者只是更改了某些内容并修复了所有新的编译器错误。这有点费劲，有时使我延迟了所需的重构。</p><p> It’s a pity Haskell doesn’t have the refactoring tools to help in this situation. The dream would be these tools integrated into an IDE.</p><p> 可惜Haskell没有重构工具来解决这种情况。梦想是将这些工具集成到IDE中。</p><p>   Having said that, it should be noted that Haskell does have an excellent IDE now in the form of  Haskell Language Server (HLS). The momentum around the project is insane and I applaud the developers. One fixed pain point from HLS is it does auto imports now, which used to greatly contribute to the friction of working with Haskell. I’m sure Haskell will get there eventually.</p><p>   话虽如此，应该指出的是，Haskell现在确实具有出色的IDE，其形式为Haskell Language Server（HLS）。该项目的发展势头令人发疯，我为开发人员称赞。 HLS的一个固定的痛点是它现在要进行自动导入，这曾经大大加剧了与Haskell合作的麻烦。我确定Haskell最终会到达那里。</p><p>  This is mostly me complaining for the sake of it, but as someone pretty obsessed with both new shiny versions of things and Haskell, waiting for new GHC (GHC is the Haskell compiler) versions to be usable has been painful. There is a long tail of libraries and platforms that need to be updated before I can use a new GHC version. Sometimes these updates can drag a lot.</p><p>  这主要是我为此而抱怨的，但是当某个人非常痴迷于事物的新闪亮版本和Haskell时，等待新的GHC（GHC是Haskell编译器）版本可用一直很痛苦。在使用新的GHC版本之前，需要更新很多库和平台。有时，这些更新可能会拖累很多。</p><p> For example GHC 9 was just released, but I still haven’t been able to upgrade to GHC 8.10 yet which was first released in March 2020.</p><p> 例如，GHC 9刚刚发布，但我仍无法升级到2020年3月首次发布的GHC 8.10。 </p><p>   So after about 8 months of work I was ready to start getting users. I slowly soft launched, promoting it in a few small channels. How did my Haskell fair in prod?</p><p>所以在大约8个月的工作后，我准备开始让用户。我慢慢发射，在几个小渠道中推广它。我的Haskell博览会是如何在刺激？</p><p>  My core Haskell had very few logic bugs. This is because Haskell is very safe by default and I had opted into strict types that help catch edge cases.</p><p>  我的核心Haskell很少有逻辑错误。这是因为默认情况下，Haskell非常安全，我选择了完全的类型，有助于捕获边缘案例。</p><p> For example, I was using a lot of   NonEmpty lists which the compiler will guarantee is not empty. To use them you must specify how to handle the empty case. ie. what do I do if Deadpendency can’t find any dependencies to check?</p><p> 例如，我使用了很多非空的列表，编译器保证不为空。要使用它们，您必须指定如何处理空的情况。 IE。如果死人无法找到任何依赖关系，我该怎么办？</p><p> And of course, I had many tests as the compiler cannot find all the bugs.. yet..</p><p> 当然，我有很多测试，因为编译器找不到所有的错误..还是......</p><p>   A big pain point was the package registry APIs had a lot of inconsistency on how they are structured (especially  NPM). For example, for an  NPM package you can get the latest version by getting  dist-tags -&gt; latest. What about a package that has no release? Well you get  dist-tags: {}, except that it turns out that some packages don’t even have the  dist-tags key at all.</p><p>   一个大的痛点是包注册机器API对它们的结构（特别是NPM）的存在很多不一致。例如，对于NPM包，您可以通过获取DIST标记 - ＆gt来获取最新版本。最新的。那个没有释放的包怎么样？嗯，你得到了dist标签：{}，除了它结果甚至根本没有dist标签键。</p><p> I quickly realised I would need to gracefully handle parse failures like these as there was so much variance in structure.</p><p> 我很快意识到我需要优雅地处理像这样的解析失败，因为结构方差如此多。</p><p> This issue sounds like a classic argument against static typing, but  dynamic type systems are not inherently better at dealing with unexpected data. Dynamically typed languages may more gracefully ignore, or delay the failure, but I prefer the Haskell philosophy of immediately failing when data is an unexpected shape.</p><p> 此问题听起来像对静态键入的经典论点，但是在处理意外数据时，动态类型系统并不更好。动态类型的语言可能更优雅地忽略或延迟失败，但是当数据是意外的形状时，我更喜欢立即失败的Haskell哲学。 </p><p>   The other big pain point was memory usage. I was using  Google Cloud Run which is sort of like AWS Lambda where you can specify how much memory you need. To keep things cheap and to better understand the memory needs of my app, I went with the minimum of 256MB. This amount seemed fine until I went to prod and Deadpendency was trying to check a wider variety of packages.</p><p>另一个大痛点是内存使用率。我使用的是Google Cloud Run，有点像AWS Lambda，您可以在其中指定所需的内存量。为了保持便宜并更好地了解应用程序的内存需求，我至少使用了256MB。直到我去生产并且Deadpendency试图检查更多种类的包装之前，这个数目似乎还不错。</p><p> The core issue was.. NPM again had some rare packages that have huge JSON payloads, the  worst case being 84MB uncompressed. It turns out that   aeson will convert all the JSON into an  AST first, before it then attempts to parse it to your type. This is fine when the JSON is small, or you are loading most of the contents of the JSON. In my case the AST (or the parsing?) apparently took about 20x the amount of memory of the raw JSON, when I only needed a tiny amount of the data.</p><p> 核心问题是.. NPM再次具有一些罕见的程序包，这些程序包具有巨大的JSON有效负载，最坏的情况是未压缩的84MB。事实证明，aeson会先将所有JSON转换为AST，然后再尝试将其解析为您的类型。当JSON小或您正在加载JSON的大部分内容时，这很好。在我的情况下，当我只需要少量数据时，AST（或解析？）的内存显然是原始JSON的20倍。</p><p> Eventually I realised I should use a  library designed to parse in constant memory and all was well. I can parse the 84MB file and only see 84MB used. I could take this even further and stream the response, but for now it is working fine as is.</p><p> 最终，我意识到我应该使用一个旨在解析恒定内存的库，一切都很好。我可以解析84MB的文件，但只能看到使用了84MB。我可以更进一步，流式传输响应，但现在它可以正常工作。</p><p>   As a lazy language, Haskell is known to have memory issues due to unevaluated expressions accumulating in unexpected ways. Thankfully I have avoided these issues so far.</p><p>   作为一种懒惰的语言，Haskell由于未评估的表达式以意外的方式积累而导致内存问题。幸运的是，到目前为止，我已经避免了这些问题。</p><p> I did this by making my types strict by default with the   StrictData extension. Additionally, Haskell has lazy linked lists as the default list type. Instead I used a  strict list type.</p><p> 我通过使用StrictData扩展名将我的类型默认设置为严格来做到这一点。此外，Haskell具有惰性链接列表作为默认列表类型。相反，我使用了严格的列表类型。</p><p>  In a bit over a year I was able to build Deadpendency supporting 11 languages (and set up a bunch of cloud junk around it 😉). At this point I think it is actually pretty stable. I consider the project a big success.</p><p>  在一年多的时间里，我能够构建支持11种语言的Deadpendency（并在它周围设置了许多云垃圾😉）。在这一点上，我认为它实际上是相当稳定的。我认为该项目非常成功。</p><p> A huge part of this has been due to Haskell and its excellent ecosystem. Of course, prior to my startup I spent 4 years dabbling with Haskell to learn it, but once skilled up it is super effective. I do believe any developer can learn Haskell and even learn it quickly in the right environment.</p><p> 其中很大一部分归因于Haskell及其出色的生态系统。当然，在我创业之前，我花了4年的时间与Haskell进行学习，但是一旦熟练了，它就会非常有效。我确实相信任何开发人员都可以学习Haskell，甚至可以在适当的环境中快速学习它。 </p><p> What’s next? I am working on promoting  Deadpendency and I hope to get more users and  feedback. Have I spent too much time geeking out on Haskell and not enough time thinking about the idea? I guess we will see 😊. Either way, I have learnt a lot and had a lot of fun, so I will consider the experience worth it.</p><p>下一步是什么？ 我正在努力推广Deadpendency，并希望获得更多的用户和反馈。 我是否花了太多时间来研究Haskell，而没有足够的时间考虑这个想法？ 我想我们会看到😊。 无论哪种方式，我都学到了很多东西，玩得很开心，所以我认为值得的经历。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://alistairb.dev/reflections-on-haskell-for-startup/">https://alistairb.dev/reflections-on-haskell-for-startup/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/haskell/">#haskell</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>