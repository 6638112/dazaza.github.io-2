<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Kalyn：用于X86-64的自主托管Lisp编译器 Kalyn: A self hosting Lisp compiler for x86-64</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Kalyn: A self hosting Lisp compiler for x86-64<br/>Kalyn：用于X86-64的自主托管Lisp编译器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-08 16:39:30</div><div class="page_narrow text-break page_content"><p>Over the course of my Spring 2020 semester at  Harvey MuddCollege, I developed a self-hosting compilerentirely from scratch. This article walks through many interestingparts of the project. It’s laid out so you can just read frombeginning to end, but if you’re more interested in a particular topic,feel free to jump there. Or, take a look at  the project onGitHub.</p><p>在我的春季2020年春季在Harvey Muddcollege的过程中，我从头开始开发了一个自主托管。本文遍历了该项目的许多兴趣。它被布局了，所以你可以读起来结束，但如果你对一个特定话题更感兴趣，请随时跳到那里。或者，看看Ongithub的项目。</p><p>    Kalyn is a  self-hosting compiler. This means that the compiler isitself written in the language that it knows how to compile, and sothe compiler can compile itself. Self-hosting compilers are common,one reason being that programmers working on a compiler for language Xprobably enjoy writing code in language X and so are inclined toimplement the compiler in language X.</p><p>    Kalyn是一个自主主机编译器。这意味着编译器ISITELESEL以它知道如何编译的语言，而SOTHE编译器可以编译自己。自主托管编译器是常见的，是一个原因是在编译器上用于语言Xprobiby的程序员享受语言X的编写代码，所以倾向于以语言X的编译器倾斜。</p><p> Kalyn compiles a programming language of my own design, also calledKalyn. One obstacle to developing a self-hosting compiler for a newprogramming language is that in order to compile the compiler for thefirst time, you have to already have a compiler: it’s achicken-and-egg problem. The simplest way to solve this problem is tofirst write a simple version of your compiler in a different language,and then use that compiler to compile your real compiler. So there aretwo implementations of the Kalyn compiler: one in Haskell and one inKalyn itself. First I use the Haskell implementation to compile theKalyn implementation, and then after that I can use the Kalynimplementation to compile itself.</p><p> Kalyn编译了一种我自己设计的编程语言，也叫了Kalyn。为新的编程语言开发自托管编译器的一个障碍是为了编制编译器的第一次，您必须有一个编译器：它是ached-and-eg的问题。解决此问题的最简单方法是TofiRST以不同的语言编写一个简单版本的编译器，然后使用该编译器来编译您的真实编译器。因此，Kalyn Compiler的aretwo实现：一个在Haskell和一个Inkalyn本身。首先，我使用Haskell实现来编译Akalyn实现，然后在此之后，我可以使用Kalynimplement进行编译。</p><p> I was inspired to create Kalyn by my Compilers class at  Harvey MuddCollege. In this class, students develop aworking compiler for a simple Swift-like programming languageover the course of the semester. However, I was left wanting more, fora few reasons:</p><p> 我在Harvey Muddcollege的Compilers课程中启发了创造Kalyn。在这一课堂上，学生开发了一个简单的Swift的编程语言转录程序，为学期的过程开发了一个简单的Swift编程。但是，我留下了更多，原因很少：</p><p> Most of the compiler was designed and implemented already, with onlya few parts left as homework. This was probably a great idea formaximizing the ratio of learning to work, but I’m the kind of personwho gets a lot of satisfaction from doing things from scratch.</p><p> 大多数编译器已经设计和实施，只有几个部分作为作业。这可能是一个伟大的想法，形成了学习工作的比率，但我是从头开始做事的人们的态度。</p><p> The language we compiled in class was not really fully-featuredenough to do any serious work. Furthermore, the programming style ofSwift and similar languages does not really “ sparkjoy” forme, even if it’s a good idea for effective software engineering. Iprefer working in more expressive languages like Haskell and Lisp when I’m not on theclock. I did not feel terribly motivated in creating a compiler fora language that I would not actually want to use.</p><p> 我们在课堂上编制的语言并没有真正完全统一，以做任何认真的工作。此外，即使它是有效的软件工程是一个好主意，载体的编程风格和类似语言的编程风格并不真正“SparkJoy”。当我不在Theclock时，Iprefer以更具表现力的语言工作，如Haskell和Lisp。我在创建一个我实际上不想使用的编译器的语言时，我没有感到非常动力。</p><p> The compiler we worked on in class was not truly “full-stack”, as itwere, since it reused a number of existing software components. Forexample, we used the GNU linker and assembler so that we couldgenerate x86-64 assembly code in text format rather than binaryformat, and we took advantage of the C standard library to avoidhaving to implement memory management and input/output primitives.Again, this was probably a good idea from an educationalperspective, but I wanted to take on the entire vertical from sourcecode to assembly opcodes.</p><p> 我们在课堂上工作的编译器并不是真正的“全堆栈”，因为它因为它重复使用了许多现有的软件组件。 forexample，我们使用了GNU链接器和汇编程序，以便我们以文本格式而不是BinaryFormat的X86-64汇编代码，并且我们利用了C标准库来避免实现内存管理和输入/输出原始.AGAIN，这是可能是一个良好的教育袭击的好主意，但我想从Sourcecode到装配Opcodes的整个垂直。 </p><p>  I created  everything from scratch, including the linker, theassembler, and the standard library. Every single byte that ends upin the executable binary is directly generated by my code.</p><p>我从头开始创建了所有内容，包括链接器，TheastSmbler和标准库。结束upin可执行文件的每个字节都是由我的代码直接生成的。</p><p> I designed Kalyn to make it as usable as possible while being aseasy to compile as possible. It has very few core features (forexample, no lists, arrays, maps, or classes), yet is truly ageneral-purpose programming language because these features can beimplemented in user code without needing special compiler support.By aiming for a self-hosting compiler, I forced myself to prioritizelanguage usability, because I needed to write an entire compiler inKalyn.</p><p> 我设计Kalyn尽可能地使其尽可能使用，以尽可能地编译。它具有很少的核心功能（forexample，没有列表，阵列，地图或类），这是真正的ageneral-progperation编程语言，因为这些功能可以在用户代码中掌握，而无需特殊编译器支持。用于针对自主主机编译器，我强迫自己提升先深度的可用性，因为我需要写一个整个编译器Inkalyn。</p><p> I honestly think Kalyn is a good programming language and I enjoywriting code in it. It is similar to Haskell, but uses Lisp syntax,which is something that I have seen  onlyrarely. But since I really likeHaskell  except for the syntax (which I consider an absoluteabomination), Kalyn adds something on top of languages that alreadyexist, so it feels like I am creating value. (Yes, obviously Kalynwon’t be used in any real projects, but it was important to me thatmy language couldn’t be described as “basically the same as X, butit doesn’t work as well”.)</p><p> 老实说，我认为Kalyn是一个很好的编程语言，我在它中享用代码。它类似于Haskell，但使用LISP语法，这是我只看到的东西。但是，因为我真的喜欢除了语法（我认为absoluteabomination），Kalyn在缺乏表达的语言上增加了一些东西，所以它感觉就像我创造价值。 （是的，显然Kalynwon不被用于任何实际项目，但对我来说很重要，但语言不能被描述为“基本上与X相同，但是也不工作”。）</p><p>  So does it actually work? Yes! Kalyn can compile itself. Theperformance is slow enough to be annoying, but not slow enough to be aproblem, when compared with Haskell. Here are the stats:</p><p>  它真的有效吗？是的！ Kalyn可以编译自己。性能速度足够令人讨厌，但与Haskell相比，不足以成为一个足够的速度。以下是统计数据：</p><p>  So we can see that Kalyn runs about 25 times slower than Haskell,which I am pretty satisfied with given that Haskell has been optimizedby experts for decades and for Kalyn I basically threw together thesimplest thing that could possibly work.</p><p>  因此，我们可以看到Kalyn比Haskell慢得多大约25倍，因为鉴于哈斯克尔已经优化了几十年的专家，我基本上扔了可能有效的东西。</p><p> Now here’s a different numerical perspective, the size of the projectas a function of time. The final total is  4,300 lines of Haskellcode across  23 modules and  5,400 lines of Kalyn code across 43 modules. (Why more Kalyn? The syntax is slightly less concise,but mostly it’s because I had to implement the entire Haskell standardlibrary – or at least the part I used in the compiler.) Here’s aregraphs showing lines of code and number of modules over time, fromwhich you can see I definitely left everything to the last minute…</p><p> 现在这是一个不同的数字视角，项目的大小是时间的函数。最终总量是23个模块的4,300行的Haskellcode，43个模块的3,400行Kalyn代码。 （为什么要更多的Kalyn？语法略有简明扼要，但主要是因为我必须实现整个Haskell StandardLibrary  - 或者至少在编译器中使用的部分。你可以看到我绝对把一切都留给了最后一刻......</p><p>   For another perspective on the development process, here is a graph ofthe cumulative total lines of code added and removed (so the projectsize at any given time is the vertical distance between the lines).</p><p>   对于另一个关于开发过程的透视图，这里是添加和删除的累积总行数的图（因此，在任何给定时间的Projectize是线之间的垂直距离）。 </p><p>     Kalyn is a combination of  Haskell and Lisp.Here is an example of some Haskell code that prints out the primenumbers up to 100:</p><p>Kalyn是Haskell和Lisp的组合。这是一些Haskell代码的一个例子，它可以打印出最多100个：</p><p> module  Main  where -- | Check if the number is prime. isPrime  ::  Int  -&gt;  Bool isPrime  num  =  let  factors  =  [ 2  ..  num  -  1 ]  in  all  ( \ factor  -&gt;  num  ` mod `  factor  /=  0 )  factors main  ::  IO  () main  =  let  nums  =  [ 2  ..  100 ]  primes  =  filter  isPrime  nums  in  print  primes</p><p> 模块主要在哪里 -  |检查号码是否是素数。 isprime :: int  - ＆gt; Bool Isprime Num =让因素= [2 .. num  -  1]在所有（\ factor-＆gt; num`mod` factor / = 0）主管主页:: io（）main =让nums = [2 .. 100] Primes = Print Primes中的筛选Isprime数</p><p> Here is the same code in  Clojure, a recentlydeveloped Lisp that runs on the JVM.</p><p> 以下是Clojure中的代码，在JVM上运行的最近开发的Lisp。</p><p> ( ns   hello-world.core )  ( defn   prime?   &#34;Check if the number is prime.&#34;   [ n ]   ( let   [ factors   ( range   2   n )]   ( every?   ( fn   [ factor ]   ( not   ( zero?   ( mod   n   factor ))))   factors )))  ( defn   -main   []   ( let   [ nums   ( range   2   100 )   primes   ( filter   prime?   nums )]   ( println   primes )))</p><p> （NS Hello-World.Core）（Defn Prime？＆＃34;检查号码是否是素数。 （零？（mod n因子））））））））））（defn -main []（let [nums（范围2 100）primes（滤光片Prime？nums）]（println primes））））</p><p> And here is the equivalent Kalyn code, which you can see combines theidea of Haskell with the syntax of Lisp:</p><p> 这里是等效的Kalyn代码，您可以将Haskell的TheIdea与Lisp的语法相结合：</p><p> ( import  &#34;Stdlib.kalyn&#34; ) ( defn  isPrime  ( Func  Int  Bool )  &#34;Check if the number is prime.&#34;  ( num )  ( let  (( factors  ( iterate  ( +  1 )  2  ( -  num  2 ))))  ( all  ( lambda  ( factor )  ( /=Int  0  ( %  num  factor )))  factors ))) ( public  def  main  ( IO  Empty )  ( let  (( nums  ( iterate  ( +  1 )  2  98 ))  ( primes  ( filter  isPrime  nums )))  ( print  ( append  ( showList  showInt  primes )  &#34;\n&#34; ))))</p><p> （进口＆＃34; stdlib.kalyn＆＃34;）（Defn Isprime（Func Int Bool）＆＃34;检查号码是否是素数。 2（ -  num 2）））））（所有（lambda（因素）（/ = int 0（％num因子）））因子））））（公共def main（io空）（设（nums（iterate（+ 1 ）2 98））（PRIMES（筛选isprime数）））（打印（附加（播放显示次摘要）＆＃34; \ n＆＃34;）））））））））））））</p><p> The language is actually quite small, so we can go through all of itpretty quickly. Let’s take a look.</p><p> 语言实际上非常小，所以我们可以快速完成所有ITPRETTY。让我们来看看。 </p><p>      Why only one size of integer? This makes the code generation easierbecause every integer has the same size. In fact, I designed Kalynusing what is called a  boxed memory representation, so that  everydata type has the same size. More on this later.</p><p>为什么只有一个大小的整数？这使得代码生成使得每个整数具有相同的大小。实际上，我设计了Kalynusing所谓的盒装内存表示，因此每个数据类型都具有相同的大小。更稍后的更多。</p><p> What about characters? These are actually just stored as integers.This wastes a lot of space, because 56 bits out of 64 are left unused,but again it makes the implementation much simpler if we don’t have toworry about differently-sized data types.</p><p> 角色怎么样？这些实际上只是作为整数存储。这浪费了很多空间，因为64中的56位留下了未使用，但如果我们没有关于不同的数据类型的拖网，它再次使实现更简单。</p><p>  Kalyn has  first-classfunctions,meaning that code can dynamically create functions at runtime and passthem around just like any other data type. This is required to supportany reasonable  functionalprogramming.Kalyn’s functions have closures,which requires special compiler support. More on that later.</p><p>  Kalyn拥有一流的功能，这意味着代码可以像任何其他数据类型一样动态创建运行时和Passthem的功能。这是支持合理的函数alprogramments.kalyn的函数有封闭，这需要特殊的编译器支持。更稍后的更多信息。</p><p> All functions in Kalyn are automatically curried, like in Haskell.This means that all functions take only a single argument;multiple-argument functions are implemented as a single-argumentfunction that returns another single-argument function that returnsanother function, and so on. I made this decision for two reasons:firstly, because currying is awesome, and secondly, because itsimplifies the type system and code generation if functions all takethe same number of arguments.</p><p> Kalyn中的所有功能都是自动核心的，就像在Haskell中一样。这意味着所有函数只采用一个参数;多参数函数实现为单参数函数，返回返回其他函数的另一个参数函数，返回返回其他函数函数，依据return return and thatter return函数，等等。我做出了这个决定的两个原因：首先，因为咖喱是很棒的，其次是因为它造成了类型的系统和代码生成，如果函数所有曲目相同的参数。</p><p> Because functions are curried, the notation  Func a b c is reallyjust shorthand for  Func a (Func b c), where  a,  b, and  c are type parameters that might stand for things like  Int and  ListString and  Func String Int.</p><p> 由于函数是核发的，所以符号Func A B C对于Func A（Func B C）的简写，其中A，B和C是可能代表INT和LISTSTRING和FUNC String INT等内容的类型参数。</p><p> One thing you might be wondering is how functions of no arguments arehandled. The answer is there is no such thing. Since evaluating afunction has no side effects (see the next section on monadic IO),there’s no difference between a function of no arguments that returnssome expression and just that expression itself.</p><p> 有一件事你可能想知道是如何没有参数的函数。答案是没有这样的东西。由于评估到一定功能没有副作用（请参阅Monadic IO上的下一节），因此没有返回显示器表达式的参数的函数与返回该表达式本身的函数之间没有区别。</p><p>  Kalyn adopts Haskell’s abstraction of monads withyouthful exuberance. Explaining monads is beyond the scope of thisarticle, but the point is that every input/output function in thestandard library ( print,  readFile,  writeFile, etc.) doesn’tactually do IO. Instead, it returns an instance of the IO monad which represents the IO action. These instances can then be chainedtogether using functional programming techniques, and the result isexecuted only if it is returned from the  main function of theprogram.</p><p>  Kalyn采用Haskell的Monads宿币的抽象。解释MONADS超出了本质的范围，但重点是，在文章库中的每个输入/输出函数（打印，readfile，writefile等）并不行为。相反，它返回IO Monad的实例，表示IO操作。然后，这些实例可以使用功能编程技术来勾选，并且才能仅当从Program的主要功能返回时异。 </p><p> Each instance of the IO monad has a return type, as in Haskell, so thetype is denoted  IO Int or  IO (List String) or  IO a in general.</p><p>IO Monad的每个实例都有一个返回类型，如haskell，所以TheType表示为Io Int或IO（列表字符串）或Io A一般。</p><p> You might think that using monadic IO is in conflict with the designgoal of making Kalyn as easy as possible to compile. You would becorrect. But it’s  so cool!</p><p> 您可能会认为使用Monadic IO与制作Kalyn的DesignGoal尽可能轻松地进行冲突。你会因为。但它太酷了！</p><p>  You may have noticed that most useful data types, such as booleans andlists, are absent from Kalyn. This is because you can easily definethem yourself. This is done just as it is in Haskell, with algebraicdata types. Here is how the Kalyn standard library defines some handydata types which will be familiar to the Haskell programmer:</p><p>  您可能已经注意到，缺席Kalyn，您可能已经注意到大多数有用的数据类型，例如布尔斯和列表。这是因为你可以轻松地发现自己。这是按照哈尔克尔的那样完成的，其中包含代数类型。以下是Kalyn标准库如何定义Haskell程序员将熟悉的一些HandyData类型：</p><p> ( public  data  Bool  False  True ) ( public  data  ( Maybe  a )  Nothing  ( Just  a )) ( public  data  ( Either  l  r )  ( Left  l )  ( Right  r )) ( public  data  ( Pair  a  b )  ( Pair  a  b )) ( public  data  ( List  a )  Null  ( Cons  a  ( List  a ))) ( public  alias  Word8  Int ) ( public  data  Char  ( Char  Word8 )) ( public  alias  String  ( List  Char ))</p><p> （公共数据BOOL FALSE）（公共数据（也许a）没有（仅a））（公共数据（lr）（左l）（右r））（公共数据（对ab）（对ab））（公共数据数据（列表a）null（缺点a（列表a）））（公共别名word8 int）（公共数据char（char word8））（公共别名字符串（列表char））</p><p>   By including support for arbitrary algebraic data types, the compilerdoesn’t need any special support for booleans, lists, arrays, maps,pairs, optionals, or anything else that would complicate theimplementation.</p><p>   通过支持对任意代数数据类型的支持，编译器不需要对Booleans，List，阵列，映射，对，选项或将复杂化的其他任何其他复杂的特殊支持。</p><p>  Kalyn consists of declarations and expressions, both of which aresimilar to Haskell except in appearance.</p><p>  Kalyn包括声明和表达式，两者都是与哈斯克尔除外的声明和表达式。</p><p>  First we have function calls, which are lists. Function currying ishandled automatically, so that  (map (+ 1) elts) means we call the + function with the argument  1 and then pass that to the  mapfunction, and take the function returned from  map and pass it theargument  elts.</p><p>  首先，我们有函数调用，这是列出的。功能Currying自动处理，以便（映射（+ 1）elts）表示我们将+函数与参数1称为+函数，然后将其传递给MapFunction，并采取从地图返回的函数并将其传递给它。 </p><p> Next, you can define anonymous functions using  lambda, so a moreexplicit form of the previous code would be:</p><p>接下来，您可以使用lambda定义匿名函数，因此前一段代码的MoreeXplice形式将是：</p><p>  The type checker includes a constraint solver, so it can automaticallyfigure out the types of anonymous functions; there’s no need tospecify that manually (and, for simplicitly, you can’t).</p><p>  类型检查器包括约束求解器，因此它可以自动配置匿名功能的类型;没有必要手动（而且为简单地提供）TOMETCEIFY。</p><p> Lambdas can have multiple arguments, but that just means they areautomatically curried, so that  (lambda (x y) ...) is the same as (lambda (x) (lambda (y) ...)).</p><p> lambdas可以有多个参数，但这只是意味着它们公正的核心，因此（lambda（x y）......）与（lambda（x）（lambda（y）...）））相同。</p><p>  ( let  (( nums  ( iterate  ( +  1 )  2  98 ))  ( primes  ( filter  isPrime  nums )))  ( print  ( showList  showInt  primes )))</p><p>  （设（nums（nums（iterate（+ 1）2 98））（primes（筛选isprime nums）））（打印（Showlist Sprint Primes）））</p><p> Each binding is evaluated in sequence, and it can refer to not onlyprevious bindings but also itself recursively. This allows you todefine recursive anonymous functions:</p><p> 按顺序评估每个结合，并且它可以指不奏的绑定，也可以递归地。这允许您批量递归匿名功能：</p><p>  Mutual recursion isnotably  not supported in  let bindings, because internally a  letform with multiple bindings is translated into a series of nestedsingle-binding  let forms, which makes the code generation easier.</p><p>  Let绑定中不支持的相互递归，因为在具有多个绑定的内部将retform翻译成一系列嵌套绑定的符号，这使得代码生成更容易。</p><p> The last special form is  case, which (as in Haskell) allows you toreturn different values depending on an algebraic data type. Arbitrarypatterns of data constructors and variables can be used on theleft-hand side of each branch. For example, here is Kalyn’simplementation of the classic  unzip function from Haskell:</p><p> 最后一个特殊形式是情况（如haskell）允许您根据代数数据类型连接不同的值。数据构造函数和变量的ArbitraryPatterns可以在每个分支的小兵侧使用。例如，这里是来自Haskell的Classic Unzip函数的Kalyn'Simplation： </p><p> ( public  defn  unzip  ( Func  ( List  ( Pair  a  b ))  ( Pair  ( List  a )  ( List  b )))  ( pairs )  ( case  pairs  ( Null  ( Pair  Null  Null ))  (( Cons  ( Pair  left  right )  pairs )  ( let  ((( Pair  lefts  rights )  ( unzip  pairs )))  ( Pair  ( Cons  left  lefts )  ( Cons  right  rights ))))))</p><p>（公共污染解压缩（Func（parent（对ab））（对（列表a）（list b）））（对）（病例对（null（对null null））（（缺点（左右右）对）（设（（（配对左权限）（解压缩）））（对（缺点左侧）（涉及权利权限））））））））</p><p> You may notice that the  let form employs  destructuring, which isbasically the same as the pattern-matching used in  case branches.This can be done in function arguments as well, and the  @ syntaxfrom Haskell allows you to name a value while simultaneouslydestructuring it:</p><p> 您可能会注意到让表单采用破坏性，这与在案例分支中使用的模式匹配相同。这也可以在函数参数中完成，并且@ syntaxfrom haskell允许您同时命名值：</p><p>   That’s it for the core expression types in Kalyn. There are a few morepieces of syntax, which the parser handles as macros. For example, the if statement</p><p>   这是Kalyn中的核心表达式类型。解析器将介绍一些备注的语法，作为宏。例如，if语句</p><p>       ( Cons  ( Char  72 )  ( Cons  ( Char  101 )  ( Cons  ( Char  108 )  ( Cons  ( Char  108 )  ( Cons  ( Char  111 )  Null )))))</p><p>       （缺点（符号72）（缺点（char 101）（缺点（char 108）（缺点（char 108）（缺点（char 111））））））</p><p> The variadic  and and  or forms translate down to nested  caseforms. And finally, we have the classic  do notation from Haskell,which translates into a sequence of  &gt;&gt;= invocations. Now, as I’lldiscuss later, Kalyn doesn’t have typeclasses, which means there areseparate  &gt;&gt;=IO,  &gt;&gt;=State, etc. functions for each monad. As aresult, you have to specify which monad you’re working with at thestart of the macro. It looks like this:</p><p> Variadic和和和或表单转换为嵌套的硬件表单。最后，我们有来自Haskell的经典符号，它转化为＆gt;＆gt; =调用。现在，正如我的稍后，Kalyn没有类型的类型，这意味着那种又是＆gt;＆gt;＆gt; =状态等。=每个monad的函数。作为aresult，您必须指定您在宏的初合形的Monad。它看起来像这样：</p><p> ( do  IO  ( with  contents  ( readFile  &#34;in.txt&#34; ))  ( let  reversed  ( reverse  contents ))  ( writeFile  &#34;out.txt&#34;  reversed )  ( setFileMode  &#34;out.txt&#34;  0o600 ))</p><p> （DO IO（带内容（READFILE＆＃34; in.txt＆＃34;））（让versefile＆＃34; out.txt＆＃34; reversed）（SetFileMode＆＃34; Out。 TXT＆＃34; 0O600））</p><p> The  with form is equivalent to Haskell’s  &lt;- operator, while the let form is the same as in Haskell. Other forms are assumed to bemonad instances whose return values are ignored (except for the lastform, which determines the return value of the entire  do macro). Theabove code translates like this:</p><p> 以表单相当于Haskell的＆lt;  - 运算符，而令表格与Haskell中的相同。假设其他表单对忽略返回值的虚拟实例（LastForm除，它确定整个DO宏的返回值）。 Theabove代码如下所示： </p><p> ( &gt;&gt;=IO  ( readFile  &#34;in.txt&#34; )  ( lambda  ( contents )  ( let  (( reversed  ( reverse  contents )))  ( &gt;&gt;=IO  ( writeFile  &#34;out.txt&#34;  reversed )  ( lambda  ( _ )  ( setFileMode  &#34;out.txt&#34;  0o600 ))))))</p><p>（＆gt;＆gt; = IO（ReadFile＆＃34;在in.txt＆＃34;）（Lambda（内容）（：（反向（反向内容）））（＆gt;＆gt; = io（writefile＆＃34 ;; .txt＆＃34;逆转）（lambda（_）（setfilemode＆＃34; out.txt＆＃34; 0o600））））））））））））））））））</p><p> By implementing many familiar language features as macros instead oftrue expressions, I was able to greatly simplify the implementation ofthe compiler, since only the parser needs to know about thesefeatures.</p><p> 通过实现许多熟悉的语言功能作为宏而不是usttute表达式，我能够大大简化编译器的实现，因为只有解析器需要了解这些特征。</p><p> You might wonder why  let isn’t implemented as a macro as well, sinceafter all  (let ((foo bar)) ...) is equivalent to  ((lambda (foo)...) bar). The answer is that this would introduce a huge amount ofoverhead, because a  let can be easily translated into just a singlemove instruction in the assembly, whereas a function call (especiallywith proper handling of closures) is much more expensive.</p><p> 您可能想知道为什么让我们没有作为宏实现，此后所有（（foo bar））......）相当于（（lambda（foo（foo）bar）。答案是，这将引入大量的ofomoverhead，因为可以让可以轻松地翻译成组装中的单独指令，而函数调用（尤其适当处理闭包）则更昂贵。</p><p>  First we have  def, which allows you to define the value of a symbol,giving its type and an optional docstring, like:</p><p>  首先，我们有def，它允许您定义符号的值，给出其类型和可选的docstring，如：</p><p>        And we have type aliases. This is the  type keyword from Haskell.(The  newtype keyword is basically the same as  data, and Kalyndoesn’t care about the difference, so it doesn’t have a separatedeclaration type for that.) So, for example,  String can be used as ashorthand for  List Char:</p><p>        我们有型别名。这是来自haskell的类型关键字。（remype关键字与数据基本相同，而Kalyndoes不关心差异，因此它没有分离校准类型。）因此，例如，可以使用字符串作为列出的Ashorthand：</p><p>    Of course, there is only one size of integer, and there is nodistinction between binary and text strings, but using the typealiases is helpful to make the type signatures easier to understand.</p><p>    当然，只有一个尺寸的整数，并且二进制和文本字符串之间存在nodistintepty，但使用类型是有助于使类型签名更容易理解。</p><p>  The Kalyn compiler and standard library is split into many differentfiles. One file is designated by the compiler as the main module, andit can import others, like:</p><p>  Kalyn编译器和标准库分为许多不同的文件。一个文件由编译器指定为主模块，Andit可以导入别人，如： </p><p>  Now each declaration keyword ( def,  defn,  data,  alias) can beoptionally preceded by  public to indicate that the declarationshould be made available to other code that imports the module. As anaside, this solves a big annoyance I have with Haskell, which is thatthere’s no way to specify which functions in a module should be publicwithout having to list all of them at the top of the file.</p><p>现在，每个声明关键字（def，defn，data，alias）可以归功于公共文档，以指示声明可用于导入模块的其他代码。作为匿名，这解决了我与Haskell的一个大烦恼，即没有办法指定模块中的哪个函数应该是公开的，必须在文件顶部列出所有它们。</p><p> Ideally, Kalyn would also have a way to hide or select specificsymbols on an import, but in the interest of simplicity we don’t havethat. Qualified imports would be another useful feature, but in theirabsence we get along fine by just prefixing names to avoid conflicts,like for example  mapInsert versus  setInsert.</p><p> 理想情况下，Kalyn还将有一种方法来隐藏或选择进口的细则，但为了简单，我们没有避免。合格的导入将是另一个有用的功能，但在他们的情况下，只需使用前缀名称来避免冲突，例如MapInsert与setinsert。</p><p> One key feature is that even the  import keyword can be preceded by public to indicate that all the imported symbols should bere-exported. This allows for  Stdlib.kalyn to  public import manysubmodules, so that user code only needs to import  Stdlib.kalyn toget the entire standard library.</p><p> 一个关键特征是即使是导入关键字也可以在公共上之前，以指示所有导入的符号应该弯曲。这允许STDLIB.Kalyn到公共导入ManySubModules，以便用户代码只需要导入stdlib.kalyn来忘记整个标准库。</p><p> The module system in Kalyn is really dirt simple. There’s no conceptof a search path or project root. Kalyn modules are just filescontaining Kalyn source code (even the file extension doesn’t matter),and imports are simply resolved as filenames relative to the directorycontaining the module with the imports. This simplified theimplementation; languages like Python impose stronger conventions onmodule layout but we don’t need that to get a compiler working.</p><p> Kalyn的模块系统真的很简单。搜索路径或项目根目录没有概念。 Kalyn模块只是悬挂的Kalyn源代码（即使是文件扩展名并不重要），而且导入只能通过与导入的模块的DirectoryComent颁发的文件名解析为文件名。这简化了这一自动化;像Python这样的语言强加了更强烈的约定onmodule布局，但我们不需要它来获得编译器工作。</p><p>  You may have noticed the conspicuous absence of one key feature ofHaskell, namely typeclasses. This isbecause it turns out that you don’t need them to get a compiler up andrunning, even though they are really really nice. In Haskell, you candefine a  Show instances like this, for example (if they weren’talready defined in the standard library):</p><p>  您可能已经注意到了Haskell的一个关键特征的显着缺席，即类型刻录物。事实证明，它不需要他们获得编译器，即使它们真的很好。在Haskell，例如，您的百思嘉百姓（例如，如果它们在标准库中定义）：</p><p> instance  Show  Bool  where  show  False  =  &#34;False&#34;  show  True  =  &#34;True&#34; instance  Show  a  =&gt;  Show  ( List  a )  where  show  elts  =  &#34;[&#34;  ++  intercalate  &#34;,&#34;  ( map  show  elts )  ++  &#34;]&#34; show  [ False ,  True ]  -- &#34;[False,True]&#34;</p><p> 实例显示bool，其中显示假=＆＃34;假＆＃34;显示True =＆＃34;真＆＃34;实例显示a =＆gt;展示（列出A）显示elts =＆＃34; [＆＃34; ++ intercalate＆＃34;，＆＃34; （地图显示elts）++＆＃34;]＆＃34;显示[false，true]  - ＆＃34; [false，true]＆＃34;</p><p> In Kalyn, we can do the same thing, we just have to define a differentfunction for each type:</p><p> 在Kalyn，我们可以做同样的事情，我们只需为每种类型定义一个不同的功能： </p><p> ( alias  ( Show  a )  ( Func  a  String )) ( defn  showBool  ( Show  Bool )  ( bool )  ( case  bool  ( False  &#34;False&#34; )  ( True  &#34;True&#34; ))) ( defn  showList  ( Func  ( Show  a )  ( Show  ( List  a )))  ( show  elts )  ( concat  [ &#34;[&#34;  ( intercalate  &#34;, &#34;  ( map  show  elts ))  &#34;]&#34; ] )) showList  showBool  [False,  True]  ; &#34;[False, True]&#34;</p><p>（别名（show a）（func一个字符串））（defn showbool（show bool）（bool）（案例bool（false＆＃34; false＆＃34;）（true＆＃34;真实＆＃34;））（ Defn Showlist（Func（Show A）（显示（列出A）））（显示elts）（concat [＆＃34; [＆＃34;（intercalate＆＃34;＆＃34;（地图显示elts））和＃34;]＆＃34;]））Showlist showbool [false，true]; ＆＃34; [虚假，真实]＆＃34;</p><p> Not ideal, but it kind of looks like the Haskell version if yousquint, and in practice it’s not that big of a pain. What’s moreannoying is that this approach doesn’t work for  higher-kindedtypeclasseslike  Monad. (Try it and see!) So it’s not possible to define afunction after the style of  showList that would act on an arbitrarymonad if you passed it the relevant  &gt;&gt;=Whatever bind operator.Luckily, we only use two monads ( IO and  State) in the compiler, sothat wasn’t too big of a deal.</p><p> 不是理想的，但它看起来像Haskell版本如果你是yousquint，而且实际上它并不是那么大的痛苦。 Moreannoying是什么，这种方法不适用于更高遗传的艺术般的Monad。 （试一试并查看！）因此如果您将其传递给ArbitraryMonad的展示列表的风格，则无法定义一段功能，如果您将其传递给它，并且gt; =无论是什么绑定运算符。卢比，我们只使用两条Monads（IO和州）在编译器中，Sothat并没有太大的交易。</p><p> In retrospect, I’m pretty happy with the result. Extending the typechecker to support typeclasses would be quite complex, so I think thelimited version that I implemented was a good compromise to get aself-hosted compiler initially off the ground.</p><p> 回想起来，我对结果非常满意。扩展TypeChecker以支持TypeClasses将是非常复杂的，因此我认为我实施的Thimited版本是一个很好的妥协，可以让自己托管的编译器从地面上获得。</p><p>  The other major difference from Haskell that’s worth mentioning islaziness. Haskell is very lazy by default, so expressions are onlyevaluated when they need to be. This often wreaks havoc withevaluation order and makes it hard to understand what is running when,although it does enable some neat tricks like being able to manipulateinfinite lists. Kalyn takes a simpler approach and evaluateseverything eagerly. There are two main disadvantages to doing thingsthis way:</p><p>  来自Haskell的其他主要区别，值得一提的是难题。默认情况下，Haskell非常懒惰，因此表达式在需要时唯一评估。这常常以评估顺序造成损坏，并使难以理解正在运行的时间，尽管它确实使一些能够掌握了人身人身统计列表。 Kalyn采取更简单的方法，并急切地评估。做ThingSthis的方式有两个主要缺点：</p><p> You can’t have infinite lists anymore, so idioms like  take 100(iterate (+ 1) 0) don’t work. I made the  iterate function in thestandard library take an extra argument that controls the number ofiterations, so we can write  (iterate (+ 1) 0 100) instead and itworks great. Turns out that laziness isn’t actually needed all thatoften, at least in this kind of project.</p><p> 您不能再现无限列表，所以习语，如拍摄100（迭代（+ 1）0）不起作用。我在TheStandard库中取得了迭代函数，占据了一个额外的论点，可以控制误报的数字，所以我们可以编写（迭代（+ 1）0 100），而是很棒的Itworks。事实证明，懒惰实际上并不需要所有的opropten，至少在这种项目中。</p><p> Normally the way lazy evaluation works is that each expression isturned into a  thunk whosevalue can be computed when needed and then cached. By notimplementing any of this, we lose the caching. That means the valuesof top-level </p><p> 通常情况下，懒惰评估的方式是，每个表达式都isturned inthunk，可以在需要时计算atvalue，然后缓存。通过展备任何此项，我们丢失了缓存。这意味着顶级的值</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://intuitiveexplanations.com/tech/kalyn">https://intuitiveexplanations.com/tech/kalyn</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/用于/">#用于</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hosting/">#hosting</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/haskell/">#haskell</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>