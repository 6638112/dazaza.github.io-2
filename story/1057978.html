<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>gitlet.js  -  git在1k行的JavaScript中实现 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">gitlet.js  -  git在1k行的JavaScript中实现 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-13 10:43:29</div><div class="page_narrow text-break page_content"><p>我写了Gitlet来展示Git如何在封面下工作。我写了很可读。我很大地评论了代码。</p><p>  如果您不熟悉基本Git命令，则可以以六百字（下图）中的阅读。</p><p>  对于六千个单词深入潜入地下室内部，你可以从informout中加入git。</p><p>      想象一下，您有一个名为Alpha的目录。它包含一个包含文件文本的FileCalled Number.txt。</p><p>    您运行git add number.txt以将number.txt添加到索引。 TheIndex是Git跟踪的所有文件的列表。它是文件的文件名到文件的内容。它现在有映射号.txt  - ＆gt;第一的。运行add命令也添加了包含首先到git对象数据库的ablob对象。</p><p>  首先运行git commit -m。这有三件事。首先，它会在对象数据库中进行树对象。此对象代表字母表顶级中的项目列表。此对象具有指向第一个BLOB ObjectThat的指针，当您ran git添加时创建。其次，它创建了代表您刚刚提交的存储库的版本的acmmit对象。这包括指向TreeObject的指针。第三，它指向新ComputObject的主分支。</p><p>  你运行git clone。 ../beta。这会创建一个名为beta的新目录。它将其初始化为Git存储库。它将Alpha对象数据库中的TheObjects复制到Beta ObjectsDatabase。它在Commit ObjectThat在Alpha存储库上的Master分支点处指向Beta上的Master分支。它索引索引索引镜像第一个提交的内容。对您的文件进行itus-number.txt  - 镜像索引。 </p><p>您移动到Beta存储库。您将Number.txt的内容更改为秒。您运行git add number.txt和gitcommit -m。创建的提交对象具有其父父级的porterto。 Commit命令点在第二个提交时分支机构分支。</p><p>  您返回Alpha存储库。你运行git远程添加beta ../ beta。这将beta存储库设置为远程存储库。</p><p>    在封面下，这运行了Git fetch beta master。这会找到第二个提交的主机，并将它们从Betarepository复制到Alpha存储库。它在第二个提交对象中指向Alpha的eta主机的记录。它更新fetch_headto表示从Betarepository获取主分支。</p><p>  在封面下，拉出命令运行git mergefetch_head。这是读取的fetch_head，这表明Beta存储库上的MasterBranch是最近的FetchedBranch。它获得了Alpha的Beta'Smaster记录指向的提交对象。这是第二个提交。 Master Branchon Alpha指向第一个提交，这是第二次提交的祖先。这意味着要完成合并，Themerge命令只能指向第二个Commit的主分支。 Merge命令更新索引以镜像第二项提交的内容。它更新了镜像映射的工作副本。</p><p>  你运行git branch红色。这将在第二个提交对象中创建一个名为红色的分支。</p><p>  你运行git checkout红色。在结账之前，头部指向主分支。它现在指向红色分支。这使得该分支电流分支。</p><p>  您将Number.txt的内容设置为第三，运行git addnumbers.txt并运行git commit -m第三。 </p><p>你运行git push beta红色。这会发现第三个消息的对象，并将它们从Alpha存储库复制到Betarepository。它指向TheThird Commit对象的Beta存储库上的红色分支，就是这样。</p><p>                如果--bare已通过，请写入Git Config，指示存储库裸露。如果没有通过--bare，写入git config说存储库不是裸露的。</p><p>  config：config.objtostr（{core：{＆＃34;＆＃34; {bare：opts.bare === true}}），对象：{}，refs：{heads：{}，}};</p><p>  使用gitletstructure js对象写标准git目录结构。如果存储库不裸露，请将目录放在.gitlet目录中。如果有的话，则将它们放在其中的顶层。</p><p>      if（已添加到文件.Length === 0）{抛出新错误（files.pathfromreporoot（path）+＆＃34;与任何文件不匹配）;</p><p>          }否则if（filestorm.length === 0）{抛出新错误（files.pathfromreporoot（path）+＆＃34;与任何文件不匹配）;</p><p>  }如果是（fs.existssync（path）＆amp;＆amp; fs.statsync（path）.isdirectory（）＆amp;＆amp;！opts.r）{抛出新错误（＆＃34;未删除＆＃34; +路径+＆＃34;递归没有-r＆＃34;）; }  别的 { </p><p>获取要删除的所有文件的列表，并在磁盘上更改了Alsobeen。如果此列表不为空，则中止。</p><p>  var changeStorm = Util.Intersection（Diff.AddedOrmodifiedFiles（），FileStorm）; if（changeStorm.length＆gt; 0）{抛出新错误（＆＃34;这些文件有更改：\ n＆＃34; + changeastorm.join（＆＃34; \ n＆＃34;）+＆＃34; \ n＆ ＃34;）;</p><p>  否则，删除匹配路径的文件。删除磁盘并从索引中删除。</p><p>  } else {filestorm.map（files.workingcopypath）.filter（fs.existssync）.foreach（fs.unlinksync）; filestorm.foreach（函数（p）{gitlet.update_index（p，{demove：true}）;}）; }}}，</p><p>  commit（）创建一个提交的对象，表示索引的当前中心，在提交时向对象attical和point头写入对象。</p><p>    将树对象的哈希与TheWas的顶部的哈希进行比较，只需用头部提交点的树对象的哈希写入。如果他们是一样的，中止就没有新的事情。</p><p>  if（refs.hash（＆＃34; head＆＃34;）！== undefined＆amp;＆amp; treehash ===对象.treehash（objects.read（refs.hash（＆＃34; head＆＃34; head＆＃34;））） ）{抛出新的错误（＆＃34;＃34; + headdesc +＆＃34; \ nnothing致力于提交，工作目录清洁＆＃34;）; }  别的 { </p><p>var conflictpaths = index.conflickspats（）; if（merge.ismergeinprogress（）＆amp;＆amp; conflictpaths.length＆gt; 0）{抛出新的错误（ConflictPaths.map（函数（p）{return＆＃34; u＆＃34; + p;}）。加入（ ＆＃34; \ n＆＃34;）+＆＃34; \ ncannot提交，因为你有未被用的文件\ n＆＃34;）;</p><p>    如果存储库处于合并状态，请使用预编写的提交消息。如果存储库不在主题状态，请使用带有-m的消息。</p><p>      如果存在merge_head，则存储库处于最新状态。删除merge_head和merge_msgto退出Meremblate。报告合并完成。</p><p>  }别的{返回＆＃34; [＆＃34; +头顶+＆＃34; ＆＃34; + Commithash +＆＃34;]＆＃34; + m; }}}}，</p><p>    if（name ===未定义）{return object.keys（refs.localheads（））。映射（函数（分支）{return（branch === refs.headbranchname（）？＆＃34; *＆＃34;： ＆＃34;＆＃34;）+分支;}）。加入（＆＃34; \ n＆＃34;）+＆＃34; \ n＆＃34 ;;</p><p>  头部没有指向一个提交，所以没有新的分支指出。中止。如果存储库没有提交，这最可能是最可能的。</p><p>  }否则如果（refs.hash（＆＃34; head＆＃34;）===未定义）{抛出新错误（refs.heftbranchname（）+＆＃34;不是有效的对象名称＆＃34;）; </p><p>}否则如果（refs.exist（refs.tolocalref（姓名）））{抛出新错误（＆＃34;一个名为＆＃34; +名称+＆＃34的分支;已经存在＆＃34;）;  否则，通过创建名为名称的新文件来创建新分支，该文件包含头指向点的提交的散列。  checkout（）更改索引，工作副本和头部Toreflect的内容。 REF可能是分支名称或acmmit哈希。  if（！Objects.exists（Tohash））{抛出新错误（Ref +＆＃34;与Gitlet＆＃34所知的任何文件不匹配;  中止如果哈希要签出指向Anot Anit的对象。  }否则if（对象.type（objects.read（tohash））！==＆＃34;提交＆＃34;）{抛出新错误（＆＃34;引用不是树：＆＃34; + ref）;  中止如果ref是当前检查出的分支的名称。如果head被分离，则参考是在该哈希上的提交哈希和头部is点。 </p><p>}否则如果（ref === refs.headbranchname（）|| ref === files.read（files.gitletpath（＆＃34;头部＆＃34;））））{返回＆＃34;已经开启＆＃34; + ref; }  别的 {</p><p>  获取工作副本中更改的文件列表。获取头部提交和TheComit中不同的文件的列表以签出。如果任何文件都显示在两个列表中。</p><p>  var paths = diff.changedfilescommitwollwollite（tohash）; if（paths.length＆gt; 0）{抛出新错误（＆＃34;本地变更将丢失\ n＆＃34; + paths.join（＆＃34; \ n＆＃34;）+＆＃34; \ n＆ ＃34;）;</p><p>    如果ref在对象目录中，则必须是一个备用，因此此结帐已拆下头部。</p><p>  获取当前提交和提交签出之间的差异列表。将它们写入工作副本。</p><p>  写下提交被检查到头部。如果头部被分离，则提交哈希是直接写的，是头文件。如果头部未被分离，则被检查出来的Branch被写入头部。</p><p>    返回isdetachinghead？ ＆＃34;注意：检查＆＃34; + tohash +＆＃34; \ nyou是独立的头国家。＆＃34; ：＆＃34;切换到分支＆＃34; + ref; }}}， </p><p>if（ref1！==未定义＆amp;＆amp; refs.hash（ref1）===未定义）{抛出新错误（＆＃34;含糊不清的参数＆＃34; + ref1 +＆＃34 ;:未知修订版＆＃34; ）;</p><p>  }否则如果（ref2！==未定义＆amp;＆amp; refs.hash（ref2）===未定义）{抛出新的错误（＆＃34; ambiguous论点＆＃34; + ref2 +＆＃34 ;:未知修订版＆＃ 34;）;</p><p>    Gitlet仅显示每个已更改的文件的名称，并且是否已添加，修改或删除。为简单起见，未显示TheChanged内容。</p><p>  差异发生在两个版本的存储库之间。 refirst版本是ref1解析为索引或索引的哈希。第二个版本是扫描到或工作副本的哈希值。</p><p>  return object.key.keys（nametostatus）.map（函数（路径）{return nameTostatus [path] +＆＃34;＆＃34; +路径;}）.join（＆＃34; \ n＆＃34;）+＆＃ 34; \ n＆＃34 ;; }}，</p><p>    中止如果命令不是“添加”。仅支持“添加”。</p><p>  }否则if（name in config.read（）[＆＃34;远程＆＃34;]）{抛出新错误（＆＃34; remote＆＃34; +名称+＆＃34;已经存在＆＃34;）; </p><p>fetch（）记录分支在Remote上的提交。它不会更改本地分支。</p><p>    }否则如果（！（远程in config.read（）。远程））{抛出新错误（远程+＆＃34;似乎不是git存储库＆＃34;）; }  别的 {</p><p>      转到远程存储库并获取Committhat分支的哈希值。</p><p>      注意下，提交的散列，此存储库当前查询远程分支已开启。</p><p>  获取远程对象目录中的所有对象并跟踪它们。到本地对象目录。 （这是让所有对象所需的所有物体都是局面的占态度的方式，提交远程分支是开启的。）</p><p>  将文件的内容设置为.gitlet / refs / remotes / [远程] / [branch]到newhash，远程分支正在开启的提交的HASH。</p><p>  录制远程分支on fetch_head的提交的哈希。 （用户可以调用gitlet mergefetch_head来合并分支Intotheir本地分支的远程版本。有关更多详细信息，请参阅Gitlet.Merge（）。） </p><p>返回[＆＃34;来自＆＃34; + RemoteURL，＆＃34; COUNT＆＃34; + remoteObjects.Length，Branch +＆＃34; - ＆gt; ＆＃34; +遥控+＆＃34; /＆＃34; +分支+（merge.isaforcefetch（Oldhash，Newhash）？＆＃34;（强制）＆＃34;：＆＃34;＆＃34;）。加入（＆＃34; \ n＆＃34;）+＆ ＃34; \ n＆＃34 ;; }}}，</p><p>  merge（）查找当前校验的分支的提交之间的差异以及转换为的提交。它发现或创建一个提交的提交，将其应用于已被检查的分支。</p><p>        中止如果ref未解析为哈希值，或者如果该散列是一个提交对象的哈丁。</p><p>  }否则如果（giverhash === undefined || objects.type（objects.read（giverhash））！==＆＃34;提交＆＃34;）{抛出新错误（REF +＆＃34 ;:预期提交类型＆＃ 34;）;</p><p>  如果目前的分支 - 接收者 - 已经合并了 - 已经拥有给予者的变化。如果接收者和智能者是相同的提交，或者给予者是接收器的祖先，这就是这种情况。</p><p>  获取工作副本中更改的文件列表。获取接收者和Giver中不同的文件的列表。 ifany文件在两个列表中出现然后中止。</p><p>  var paths = diff.cangedfilescommitwuldwollite（giverhash）; if（paths.length＆gt; 0）{抛出新错误（＆＃34;本地变更将丢失\ n＆＃34; + paths.join（＆＃34; \ n＆＃34;）+＆＃34; \ n＆ ＃34;）; </p><p>如果接收者是给予者的祖先，则执行快速的转发。这是可能的，因为已经存在所有给予者的改变进入治疗方案。</p><p>  快速转发手段使当前的分支反映了Giverhash点的通知。该分支是Pointedat GiverHash。该索引设置为匹配GiverHash点的提交的内容。工作副本ISSET以匹配该提交的内容。</p><p>  如果接收方不是adviver的祖先，则必须创建一个mergecommit。</p><p>  存储库被投入合并状态。将Merge_Head文件写入并将其内容设置为GiverHash。编写Merge_msg文件，并将其设置为Boilerplate合并提交消息。创建了Amerge Diff，这将使Receiver的内容变为给予者的内容。这包含每个文件的路径，这是不同的，无论是删除，删除或修改，还是在冲突中。添加了FileSare添加到索引和工作副本。从索引和工作副本中删除了areremoved文件。修改文件中修改在索引和工作副本中。 isin冲突的文件写入工作副本以包含Tereceiver和Giver版本。接收器和GiverVersions都写入索引。</p><p>  如果有任何冲突文件，则显示一条消息，即用户必须在合并才能完成之前对其进行调整。</p><p>  如果没有冲突文件，则从合并的更改中创建提交，合并结束。</p><p>  pull（）获取分支在远程处于remote的提交。提交到当前分支的合并。 </p><p>push（）获取在远程提交的远程上的本地回购点分支中分支的提交。</p><p>    }否则如果（！（远程in config.read（）。远程））{抛出新错误（远程+＆＃34;似乎不是git存储库＆＃34;）; } else {var remotepath = config.read（）。远程[遥控] .URL; var remotecall = util.onremote（Remotepath）;</p><p>  if（remotecall（refs.ischeckedout，分支））{抛出新的错误（＆＃34;拒绝更新检查分支和＃34; +分支）; }  别的 {</p><p>      如果远程分支 - 接收者 -  HasalReady纳入Giverhash Pointsto的提交，请不要​​做任何。如果接收者提交和赠送管理器是相同的，或者如果adver提交是接收者提交的祖先，这就是这种情况。</p><p>  中止如果远程上的分支不能快速转发，则提交给予者的指向。如果接收者提交是秘密提交的祖先，则完成快进CONONLY。</p><p>  }否则如果（！opts.f＆amp;＆amp;！merge.canfastword（receiverhash，giverhash））{抛出新错误（＆＃34;未能推动一些refs＆＃34; + remotepath）;</p><p>        设置本地repo的Commit Branch是onat remote到Giverhash的记录（因为它是Nowis的）。 </p><p>返回[＆＃34;＆＃34; + Remotepath，＆＃34; Count＆＃34; + Objects.AllObjects（）。长度，分支+＆＃34; - ＆gt; ＆＃34; +分支] .join（＆＃34; \ n＆＃34;）+＆＃34; \ n＆＃34 ;; }}}}，</p><p>  status（）报告repo的状态：当前分支，未触发的文件，冲突文件，暂整的文件和未暂存的文件。</p><p>    if（remotepath ===未定义|| targetpath ===未定义）{抛出新错误（＆＃34;您必须指定远程路径和目标路径＆＃34;）;</p><p>  }否则如果（！fs.existssync（remotepath）||！util.onremote（remotepath）（files.inrepo））{抛出新错误（＆＃34;存储库＆＃34; + remotepath +＆＃34;不存在＆ ＃34;）;</p><p>  }否则如果（fs.existssync（fs.existsync;＆amp; fs.readdirsync（targetpath）.length＆gt; 0）{抛出新错误（目标路径+＆＃34;已经存在，不是空＆＃34;）;</p><p>              如果远程repo具有任何提交，则将存在该散列。新的存储库记录传递分支在遥控器上的提交。然后它将Master on thalew存储库设置为该提交的点。</p><p>    Update_index（）将文件的内容添加到theIndex的路径上，或从索引中删除文件。 </p><p>update_index：函数（路径，opts）{files.assertinrepo（）; config.assertnotbare（）; 选择= opts || {}; var pathfromroot = files.pathfromreporoot（路径）; var isondisk = fs.existssync（路径）; var isinindex = index.hasfile（路径，0）;  if（isondisk＆amp;＆amp; fs.statsync（path）.isdirectory（））{抛出新错误（pathfromroot +＆＃34;是一个目录 - 在\ n＆＃34内添加文件; }否则如果（opts.remove＆amp;＆amp; isondisk＆amp;＆amp; isinindex）{  中止如果文件被删除并在冲突中。 Gitletdoes不支持这个。  如果正在删除文件，则不在磁盘上且处于TheIndex中，从索引中删除它。  如果正在删除文件，则不在磁盘上而不是索引，没有工作要做。  中止如果文件位于磁盘上而不是索引中，而且未通过。  }否则如果（！opts.add＆amp;＆amp;＆amp;＆amp;＆amp;＆amp; isinindex）{抛出新的错误（＆＃34;不能添加＆＃34; + pathfromroot +＆＃34;到索引 - 使用 -  add选项 \ n＆＃34;）; </p><p>如果文件位于磁盘上，则传递-add或文件是索引，则将文件的当前内容添加到索引中。</p><p>  }否则如果（！opts.remove＆amp;＆amp; isondisk）{抛出新的错误（路径辐射+＆＃34;不存在和 -  rovove未通过\ n＆＃34;）; }}，</p><p>  write_tree（）获取索引的内容，并存储一个treeObject，表示对象目录的该内容。</p><p>  update_ref（）获取ReftoupDateTeTopoints的提交的散列，并将ReftoupDate设置为相同的哈希值。</p><p>        如果哈希指向对象目录中的对象是非提交的，则中止。</p><p>  }否则if（对象.type（objects.read（哈希））！==＆＃34;提交＆＃34;）{var branch = refs.terminalref（Reftoupdate）;抛出新的错误（分支+＆＃34;不能指非提交对象＆＃34; +哈希+＆＃34; \ n＆＃34;）;</p><p>        refs是提交哈希的名称。 ref是文件的名称.SOME REFS表示本地分支，如refs / head / master或refs / head / feats。有些代表远程分支，如refs / remotes / horiz / master。有些代表存储库的重要状态，如头部，merge_head和fetch_head。 reffiles包含哈希或其他参考。 </p><p>ISREF：功能（REF）{RETURN REF！==未定义＆amp;＆amp; （ref.match（＆＃34; ^ refs / heads / [a-za-z  - ] + $＆＃34;）|| ref.match（＆＃34; ^ refs / remotes / [a-za-z - ] + / [a-za-z  - ] + $＆＃34;）|| [＆＃34;头＆＃34 ;,＆＃34; fetch_head＆＃34 ;,＆＃34; merge_head＆＃34;]。索引（参考）！==  -  1）; }，</p><p>    如果ref是“头”，头部指向一个分支，请返回branch。</p><p>    否则，假设ref是一个不合格的本地参考（如掌握），并将其转换为合格的参考（如refs / heads / master）</p><p>  哈希：函数（Reforhash）{if（对象.Exists（Reforhash））{Return Reforhash; }否则{var terminalref = refs.terminalref（Reforhash）; if（terminalRef ===＆＃34; fetch_head＆＃34;）{return refs.fetchheadbranchtomerge（refs.heftbranchname（））; }否则如果（refs.exists（terminalref））{return files.read（files.gitletpath（eriverlerref））; }}}，</p><p>  IsHeadDetached（）如果head包含Commithash，而不是分支的REF，则返回True。</p><p>  ischeckedout（）如果存储库不裸露并且头部指向名为branch的分支，则返回true</p><p>          fetchheadbranchtomerge（）读取fetch_head文件，并留下远程BranchName指向的哈希哈希。有关fetch_head的更多信息，请参阅gitlet.fetch（）。 </p><p>fetchhedbranchtomerge：函数（branchname）{returnuture.lines（files.read（files.gitletpath（＆＃34; fetch_head＆＃34;））.filter（函数（l）  ...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://gitlet.maryrosecook.com/docs/gitlet.html">http://gitlet.maryrosecook.com/docs/gitlet.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/提交/">#提交</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1057975.html"><img src="http://img2.diglog.com/img/2021/4/thumb_f9e82ec730e7f59a82230dd0b29b60cb.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1057975.html">hotwire：没有javascript的反应轨道？ [深潜入热源前锋] </a></div><span class="my_story_list_date">2021-4-13 10:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1057823.html"><img src="http://img2.diglog.com/img/2021/4/thumb_f10794cd0e3e169442e26b7ced11dfee.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1057823.html">使用JavaScript中的交换机（True）模式 </a></div><span class="my_story_list_date">2021-4-12 22:4</span></div><div class="col-sm"><div><a target="_blank" href="/story/1057768.html"><img src="http://img2.diglog.com/img/2021/4/thumb_d2a905bc7906f1d6b94676707a0f2e26.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1057768.html">如果您是JavaScript的新手，请与用户填充物修补 </a></div><span class="my_story_list_date">2021-4-12 15:28</span></div><div class="col-sm"><div><a target="_blank" href="/story/1056865.html"><img src="http://img2.diglog.com/img/2021/4/thumb_e19952915ffec1b8273b2e51977dec85.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1056865.html">Microsoft预览了其开源Java分发，Microsoft OpenJDK </a></div><span class="my_story_list_date">2021-4-8 3:20</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>