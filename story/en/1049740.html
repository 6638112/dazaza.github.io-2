<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>通向Lisp的道路（2018） A Road to Common Lisp (2018)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A Road to Common Lisp (2018)<br/>通向Lisp的道路（2018） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-27 09:58:20</div><div class="page_narrow text-break page_content"><p>I&#39;ve gotten a bunch of emails asking for advice on how to learn Common Lisp inthe present day. I decided to write down all the advice I&#39;ve been givingthrough email and social media posts in the hopes that someone might find ituseful.</p><p>我收到了大量电子邮件，要求提供有关如何学习Common Lisp的建议。我决定写下我通过电子邮件和社交媒体帖子提供的所有建议，希望有人会发现它有用。</p><p> One disclaimer up front: this is  a road to Common Lisp, not  the road toCommon Lisp. It&#39;s what I followed (without some of the dead ends) and hasa  lot of my personal opinions baked in, but it is by no means the only way tolearn the language.</p><p> 前面有一个免责声明：这是通向Lisp的道路，而不是通向Lisp的道路。这是我所遵循的（没有一些死胡同），并且吸收了我很多个人见解，但这绝不是学习语言的唯一方法。</p><p>    I think it&#39;s important to have a sense of where Common Lisp came from and whatkind of a language it is before you start learning it. There are some thingsthat will seem very strange if you&#39;re coming straight from modern languages,but will make more sense if you&#39;ve got a bit of background context.</p><p>    我认为，在开始学习Common Lisp之前，先了解一下Lisp的来历和语言是很重要的。如果您直接来自现代语言，有些事情看起来会很奇怪，但是如果您有一些背景知识，这些事情将变得更加有意义。</p><p>  Common Lisp has a long, deep history. I&#39;m not going to try to cover it all here— if you&#39;re interested you should check out some of the following (in roughlyincreasing order of detail):</p><p>  常见的Lisp有着悠久而深刻的历史。我不会在这里尝试覆盖所有内容-如果您有兴趣，请检查以下内容（按大致递增的顺序）：</p><p>  I realize you probably won&#39;t want to read all of the links above immediately, sohere&#39;s a whirlwind tour of sixty years of Lisp.</p><p>  我知道您可能不想立即阅读上面的所有链接，因此这里是Lisp六十年的旋风之旅。</p><p>  Over the next twenty or so years various versions and dialects of Lisp grew andflourished. Some of the more notable dialects were Maclisp, BBN Lisp/Interlisp,Franz Lisp, Spice Lisp, and Lisp Machine Lisp. There were others too. Thepoint is that there were a  lot of different implementations, all growing,changing, and trying out different things.</p><p>  在接下来的二十年左右的时间里，Lisp的各种版本和方言蓬勃发展。一些比较著名的方言是Maclisp，BBN Lisp / Interlisp，Franz Lisp，Spice Lisp和Lisp Machine Lisp。也有其他人。关键是存在许多不同的实现，所有实现都在不断增长，更改和尝试不同的东西。</p><p> (Scheme also originated in this time frame, but took a very different route anddiverged from the path we&#39;re looking at. I won&#39;t cover Scheme in this post.)</p><p> （该计划也起源于这个时间范围，但采取了截然不同的路线，并且与我们正在寻找的路径有所不同。在这篇文章中，我将不介绍Scheme。） </p><p> In the early 1980s people decided that having a whole slew ofmutually-incompatible dialects of Lisp might be not be ideal. An effort wasmade to take these different languages that had grown organically and produceone common language that would satisfy the needs of everyone (or at leasta reasonable subset of &#34;everyone&#34;). In 1984 the first edition of Guy Steele&#39;s Common Lisp: the Language was published.</p><p>在1980年代初期，人们认为拥有大量互不兼容的Lisp方言可能不是理想的选择。努力采用这些有机增长的不同语言，并产生一种可以满足所有人（或至少是“每个人”的合理子集）需求的通用语言。 1984年，Guy Steele的《共同的Lisp：语言》第一版出版了。</p><p> If you do some math you&#39;ll see that at the time the book was published Lisp hadaround twenty-five years of real-world use, experimentation, experience, andhistory to draw upon. Even so, the book alone didn&#39;t quite satisfy everyone andin 1986 a committee (X3J13) was formed to produce an ANSI specification forCommon Lisp.</p><p> 如果您做一些数学运算，您会发现本书出版时Lisp大约有25年的实际使用，实验，经验和历史可供借鉴。即便如此，仅此本书并不能使所有人都满意，并且在1986年成立了一个委员会（X3J13）来为Common Lisp制定ANSI规范。</p><p> While the committee worked on the standardization process, in 1990 the secondedition of Common Lisp: the Language was published. This was morecomprehensive and contained some of the things the committee was working on(see the comp.lang.lisp FAQ linked above for more on this). At this point theLisp family of languages had over thirty years of experience and history todraw upon. For comparison: Python (a &#34;modern&#34; language many people think of asalso being &#34;kind of old&#34;)  was released for the first time thefollowing year.</p><p> 当委员会致力于标准化过程时，1990年发布了第二版Common Lisp：语言。这更加全面，包含了委员会正在处理的一些事情（有关更多信息，请参见上面链接的comp.lang.lisp常见问题解答）。在这一点上，Lisp语言家族已有30多年的经验和历史可以借鉴。为了进行比较：Python（一种现代语言，许多人认为也是古老的语言）在下一年首次发布。</p><p> In 1992 the X3J13 committee published the first draft of the new Common LispANSI standard for public review (see Pitman&#39;s paper). The draft was approved in1994 and the approved specification was finally published in 1995. At thispoint Lisp was over thirty-five years old. The first version of Ruby  wasreleased in December of that year.</p><p> X3J13委员会在1992年发布了新的Common LispANSI标准的初稿，以供公众审查（请参阅Pitman的论文）。该草案于1994年获得批准，批准的规范最终于1995年发布。在这一点上，Lisp已有35年的历史了。 Ruby的第一个版本于当年12月发布。</p><p> That&#39;s the end of the history lesson. There has not been another revision ofthe ANSI specification of Common Lisp. The version published in 1995 is the onethat is still used today — if you see something calling itself &#34;animplementation of Common Lisp&#34; today, that is the specification it&#39;s referringto.</p><p> 历史课到此结束。尚未对Common Lisp的ANSI规范进行另一修订。如果您看到某个自称为“ Common Lisp的实现”的东西，则该版本于1995年发布，至今仍在使用。今天，这就是它所指的规范。</p><p>  I wanted to give you a quick overview of the history of Common Lisp because Iwant you to know what you&#39;re getting yourself into. I want you to realize thatCommon Lisp is a stable, large, practical, extensible, ugly language.Understanding these characteristics will make a lot of things make more senseas you learn the language, and I want to talk a little bit more about each ofthem before I start offering recommendations.</p><p>  我想向您简要介绍Common Lisp的历史，因为我想让您知道自己正在从事什么。我希望您认识到Common Lisp是一种稳定，庞大，实用，可扩展，丑陋的语言。了解这些特性会使您在学习该语言时很多事情变得更有意义，并且我想在此之前先对它们进行更多的讨论我开始提供建议。</p><p>  If you&#39;re coming from other languages, you&#39;re probably used to things breakingwhen you &#34;upgrade&#34; your language implementation and/or libraries. If you wantto run Ruby code you wrote ten years ago on the latest version of Ruby, it&#39;sprobably going to take some effort to update it. My current day job is in Scala,and if a library&#39;s last activity is more than 2 or 3 years old on Github I justassume it won&#39;t work without a significant amount of screwing around on my part.The Hamster Wheel of Backwards Incompatibility we deal with every day is a factof life in most modern languages, though some are certainly better than others.</p><p>  如果您来自其他语言，则您可能会习惯于在升级时遇到的麻烦。您的语言实现和/或库。如果要运行十年前在最新版本的Ruby上编写的Ruby代码，则可能需要花费一些精力来对其进行更新。我目前的工作是在Scala，如果图书馆的最后一项活动在Github上超过2或3年，我只是假设如果没有很大的麻烦，它就无法工作。在大多数现代语言中，我们每天处理的向后不兼容之轮是生活中的事实，尽管某些语言肯定比其他语言更好。 </p><p> If you learn Common Lisp, this is usually not the case. In the next section ofthis post I&#39;ll be recommending a book written in 1990. You can run its code,unchanged, in a Common Lisp implementation released last month. After years ofjogging on the Hamster Wheel of Backwards Incompatibility I cannot tell you howmuch of a  relief it is to be able to write code and reasonably expect it tostill work in twenty years.</p><p>如果您学习Common Lisp，通常情况并非如此。在这篇文章的下一部分中，我将推荐一本1990年编写的书。您可以在上个月发布的Common Lisp实现中运行其代码，并且保持不变。在经历了向后不兼容的仓鼠滚轮上的多年磨合之后，我无法告诉您能够编写代码并合理地期望它在20年后仍能继续工作是多么的轻松。</p><p> Of course, this is only the case for the language itself — if you depend on anylibraries there&#39;s always the chance they might break when you update them. ButI&#39;ve found the stability of the core language is contagious, and overall theCommon Lisp community seems fairly good about maintaining backwardscompatibility.</p><p> 当然，这仅是语言本身的情况-如果您依赖任何库，那么在更新它们时，它们总是有可能损坏。但是我发现核心语言的稳定性具有传染性，并且总体而言，Common Lisp社区在保持向后兼容性方面似乎还不错。</p><p> I&#39;ll be honest though: there are exceptions. As you learn the language andstart using libraries you&#39;ll start noticing some library authors who don&#39;tbother to document and preserve stable APIs for their libraries, and ifstaying off the Hamster Wheel is important to you you&#39;ll learn to avoid relyingon code written by those people as much as possible.</p><p> 我会说实话：有例外。当您学习语言并开始使用库时，您会开始注意到一些不愿意为它们的库记录和保留稳定的API的库作者，并且如果远离仓鼠轮对您很重要，您将学习到尽可能避免依赖那些人编写的代码。</p><p>  Another thing to understand about Common Lisp is that it&#39;s a large, practicallanguage. The second edition of Common Lisp: the Language (usually abbreviatedas &#34;CLtL2&#34; by Common Lisp programmers) is 971 pages long, not including thepreface, references, or index. You can get a surprising amount done by writingpure Common Lisp without much extra support.</p><p>  关于Common Lisp的另一件需要了解的是，它是一种实用的大型语言。 《 Common Lisp：语言》的第二版（通常由Common Lisp程序员缩写为＆＃34; CLtL2＆＃34;）长971页，不包括前言，参考文献或索引。在没有太多额外支持的情况下，编写纯Common Lisp可以使您获得惊人的收益。</p><p> When programming applications in Common Lisp people will often depend ona small(ish) number of stable libraries, and library writers often try tominimize dependencies by utilizing as much of the core language as possible.I try to stick to fewer than ten or so dependencies for my applications and nomore than two or three for my libraries (preferably zero, if possible), but I&#39;mprobably a bit more conservative than most folks. I  really don&#39;t like theHamster Wheel.</p><p> 在Common Lisp中编程应用程序时，人们通常会依赖少量的稳定库，而库作者经常尝试通过利用尽可能多的核心语言来最大限度地减少依赖关系。我尝试将依赖关系保持在少于十个左右我的应用程序，我的库最多不超过2到3个（如果可能的话，最好是0个），但是我可能比大多数人保守一些。我真的不喜欢仓鼠轮。</p><p> It&#39;s also worth noting that since Common Lisp has been around and stable for solong, it has  libraries older and more stable than many programming languages.For example: Bordeaux Threads (the de-facto threading library for Common Lisp)was first proposed in 2004 and released soon after (2006 at the latest butpossibly earlier, it&#39;s hard to tell because so many links are dead now), whichmakes it about fourteen years old. So yes, threading is handled by a library,but I&#39;m not worried about it breaking my code in the next decade or two.</p><p> 还要注意的是，由于Common Lisp一直存在并且很稳定，所以它的库比许多编程语言都更旧和更稳定，例如：Bordeaux Threads（Common Lisp的事实上的线程库）是第一个它在2004年提出并在不久之后发布（最迟在2006年发布，但可能更早发布了，因为现在已经有很多链接死了，所以很难说），这使得它已经有14年的历史了。所以是的，线程是由一个库处理的，但是我不担心它会在接下来的一两年内破坏我的代码。</p><p> My advice is this: as you learn Common Lisp and look for libraries, try tosuppress the voice in the back of your head that says &#34;This project was lastupdated six years ago? That&#39;s probably abandoned and broken.&#34; The stability ofCommon Lisp means that sometimes libraries can just be  done, not  abandoned,so don&#39;t dismiss them out of hand.</p><p> 我的建议是：当您学习Common Lisp并查找库时，请尝试抑制您脑后的声音，说“＆＃34;该项目的最新更新是六年前？”。那可能是被抛弃和破坏的。 Common Lisp的稳定性意味着有时候可以只完成库，而不是废弃库，所以不要一味地将它们解散。 </p><p>  Part of Common Lisp&#39;s practicality comes from its extensibility. No one hasbeen clamoring for a new version of the specification that adds featuresbecause Common Lisp&#39;s extensibility allows users to add new features to thelanguage as plain old libraries, without having to alter the core language.Macros are what might come to mind when you hear &#34;Lisp extensibility&#34;, and ofcourse that&#39;s part of it. Macros allow users to write libraries that wouldneed to be core language features in other languages.</p><p>Common Lisp实用性的一部分来自其可扩展性。没有人要求新版本的规范增加功能，因为Common Lisp的可扩展性允许用户以普通的旧库的形式向语言添加新功能，而无需更改核心语言。您会听到Lisp的可扩展性，当然这也是其中的一部分。宏允许用户编写可能是其他语言的核心语言功能的库。</p><p> Common Lisp doesn&#39;t include string interpolation. You want it? No problem, youdon&#39;t have to wait for  Scala2.10 or Python 3.6, just  usea library.</p><p> Common Lisp不包括字符串插值。你想要它？没问题，您不必等待Scala2.10或Python 3.6，只需使用一个库即可。</p><p>  Pattern matching syntax can make for some really beautiful, readable code.Common Lisp doesn&#39;t include it, but of course  there&#39;s a library.</p><p>  模式匹配语法可以编写出非常漂亮，可读的代码。CommonLisp不包含它，但是当然有一个库。</p><p>  All of these libraries rely on macros to make using them feel seamless. Ofcourse you could  do all of that without macros, but you&#39;ve have to add a layerof boilerplate to manage evaluation. This:</p><p>  所有这些库都依靠宏来使使用它们变得无缝。当然，您可以不使用宏来完成所有这些操作，但是您必须添加一层样板来管理评估。这：</p><p> (match foo &#39;(list x y z) (lambda (x y z) (+ x y z)) &#39;(vector x y) (lambda (x y) (- x y)))</p><p> （匹配foo＆＃39;（list x y z）（lambda（x y z）（+ x y z））＆＃39;（vector x y）（lambda（x y）（-x y）））</p><p>  (match foo ((list x y z) (+ x y z)) ((vector x y) (- x y)))</p><p>  （匹配foo（（list x y z）（+ x y z））（（vector x y）（-x y）））</p><p> No one&#39;s up in arms trying to get a new revision of the Common Lisp standard toadd pattern matching because you can write it as a library and get 90% or moreof what you&#39;ve get if it were built in. The language gives you enough power toextend it in a way that feels like the extension was there from the beginning.</p><p> 没有人会努力尝试获得Common Lisp标准的新修订版以添加模式匹配，因为您可以将其编写为库，并获得90％或更多的内置代码。该语言为您提供了足够的功能来扩展它，就好像扩展是从一开始就存在的那样。 </p><p> Having things that are core features in other languages be provided by librariesmight seem at odds with the previous section about minimizing dependencies, andto some extent that&#39;s true. But I think there&#39;s a happy medium where you canwrite stable libraries in the core language and then depend on a small number ofthose libraries in your applications to add exactly the features you need forany particular problem.</p><p>由库提供其他语言的核心功能可能与上一章有关最小化依赖关系不一致，并且在某种程度上是正确的。但是，我认为有一种快乐的媒介，您可以用核心语言编写稳定的库，然后依靠应用程序中的少数这些库来添加任何特定问题所需的功能。</p><p>  Macros are one of the things that make Lisp so extensible, because they let youtransform arbitrary code into other arbitrary code. This is true for macros inlanguages like C too, but Common Lisp macros are different because they&#39;re  partof the language.</p><p>  宏是使Lisp如此可扩展的原因之一，因为它们使您可以将任意代码转换为其他任意代码。对于像C这样的宏语言也是如此，但是Common Lisp宏是不同的，因为它们是语言的一部分。</p><p> In C you have a layer of macros on top, written in a preprocessor macrolanguage. The macro layer and the language layer are separate from each other,with the macro layer providing one one extra level of abstractive power (which,don&#39;t get me wrong, is certainly useful).</p><p> 在C语言中，您在顶层有一层宏，这些宏是用预处理程序宏语言编写的。宏层和语言层是相互独立的，宏层提供了一种额外的抽象能力（别误会，这肯定是有用的）。</p><p> In Common Lisp, you write macros  in Common Lisp itself. You can then usethose macros to write functions, and use those functions to write more macros.Instead of two stratified layers it&#39;s a  feedback loop of abstractive power.</p><p> 在Common Lisp中，您可以在Common Lisp本身中编写宏。然后，您可以使用这些宏编写函数，然后使用这些宏编写更多的宏，而不是两个分层的层，而是一个抽象能力的反馈回路。</p><p> But macros aren&#39;t the only thing about Common Lisp that make it so practical andextensible. Something people often don&#39;t realize is that while Common Lisp isan extremely high-level language thanks to macros, it also has plenty oflow-level facilities as part of the language. It&#39;s never going to be aslow-level as something like C, Rust, or Forth, but you might be surprised atsome of the things that the ANSI spec includes.</p><p> 但是，宏并不是Common Lisp唯一使它如此实用和可扩展的东西。人们常常没有意识到的是，尽管Common Lisp由于使用了宏而成为一种非常高级的语言，但它也具有许多作为语言一部分的低级功能。它永远不会像C，Rust或Forth这样低级，但是您可能会对ANSI规范中包含的某些东西感到惊讶。</p><p>   Need arrays of unboxed floats to ship to a graphics card?  The standard allowsfor that.</p><p>   需要将未装箱的浮子阵列运送到图形卡吗？该标准允许这样做。</p><p> Think  GOTO should be considered helpful, not harmful? Well, okay, we&#39;re alladults here.  Good luck, try not to shoot your foot off.</p><p> 认为GOTO应该被认为是有帮助的，不是有害的吗？好吧，我们在这里都是大人。祝你好运，不要脚踩脚。 </p><p> Need to do unsigned 8-bit arithmetic in your Game Boy emulator, but would preferit to compile down to just a machine instruction or two?  It&#39;spossible.</p><p>是否需要在Game Boy模拟器中执行无符号的8位算术运算，但更喜欢将其编译为一两条机器指令？这是可能的。</p><p> Not all Common Lisp implementations actually perform all these optimizations,but the designers of Common Lisp had the foresight to include the languagefeatures needed to support them. You can write vanilla Common Lisp as definedby the standard and trust that it will run everywhere, and implementations that do support these kinds of things will take advantage of the optimizationopportunities.</p><p> 并非所有Common Lisp实现实际上都执行所有这些优化，但是Common Lisp的设计人员具有预见性，需要包括支持它们的语言功能。您可以编写标准定义的普通Common Lisp，并相信它将在任何地方运行，并且支持这些事情的实现将利用优化机会。</p><p> This combination of supporting extremely high-level programming with macros anda reasonable amount of low-level optimization mean that even though thespecification is over twenty years old, it&#39;s still a good solid base to build ontoday. The thirty years of experience and history the designers were drawingfrom allowed them to create a very practical language that has survived fordecades.</p><p> 支持带有宏的极高级编程和合理数量的低级优化的结合意味着，即使规范已经使用了20多年了，它仍然是当今构建的良好基础。设计师从中汲取的30年经验和历史使他们能够创建一种非常实用的语言，并在数十年的历史中幸存下来。</p><p>  It&#39;s also important to realize that while Common Lisp might be very practical,the need to accommodate existing users and dialects means that there are plentyof ugly parts. If you buy a paper copy of the second edition of Common Lisp:the Language and look up &#34;kludges&#34; in the index you&#39;ll find this:</p><p>  同样重要的是要认识到，尽管Common Lisp可能非常实用，但是容纳现有用户和方言的需求意味着有很多丑陋的部分。如果您购买了第二版《 Common Lisp：The Language》的纸质副本，并查找了“ kludges”在索引中，您会发现：</p><p>  Common Lisp is not a beautiful crystal of programming language design. It&#39;sa scruffy workshop with a big pegboard wall of tools, a thin layer of sawdust onthe floor, a filing cabinet in the office with a couple of drawers that openperpendicular to the rest, and there&#39;s a weird looking saw with  RPLACD writtenon the side sitting off in a corner where no one&#39;s touched it for twenty years.</p><p>  Common Lisp并不是编程语言设计的美丽结晶。这是一个sc脚的车间，上面有一堵大钉板墙，地板上有一薄层木屑，办公室里有一个文件柜，柜子里有几个垂直于其余部分的抽屉，还有一个看起来很奇怪的锯子。 RPLACD写在坐在角落的那一侧，二十年来没有人碰过它。</p><p> This historical baggage is a price paid to ensure Common Lisp had a future. Itmade it practical for people using the old dialects to actually adopt CommonLisp with a reasonable amount of effort. If the designers had tried to make itperfect and beautiful this could have made it too different to portimplementations and code to and might have resulted in the language beingignored, instead of being adopted and embraced.</p><p> 此历史包is是为确保Common Lisp拥有未来而付出的代价。这使得使用旧方言的人们以合理的努力实际采用CommonLisp成为现实。如果设计人员试图使其完美，美观，那么可能会使它与端口实现和代码过于不同，并可能导致该语言被忽略，而不是被采用和接受。</p><p>  If all of this hasn&#39;t scared you away from the language, let&#39;s talk about howyou can learn it in 2018.</p><p>  如果所有这些都没有让您害怕该语言，那么让我们来谈谈您如何在2018年学习它。 </p><p> If you search around on the internet for Common Lisp tutorials and guides,you&#39;re not going to find as much as you might expect. This is because a lot ofCommon Lisp reference material was created before or during the infancy of theinternet. There are a  lot of books about Common Lisp out there. Some arebetter than others. I&#39;ll recommend the ones I think are the best, but don&#39;thesitate to browse around and find others.</p><p>如果您在Internet上搜索Common Lisp教程和指南，您将找不到想要的东西。这是因为在Internet诞生之初或之初就创建了许多Common Lisp参考资料。那里有很多有关Common Lisp的书。有些比其他更好。我会推荐我认为最好的那些，但是不要四处浏览并找到其他人。</p><p>  To get started with Common Lisp you&#39;ll need to install a Common Lispimplementation. Common Lisp is an ANSI specification, so there are multipleimplementations of it, which gives you choices. There are a bunch of options,but I&#39;ll make it simple for you:</p><p>  要开始使用Common Lisp，您需要安装Common Lispimplementation。 Common Lisp是ANSI规范，因此它有多种实现，您可以选择。有很多选择，但我将为您简化一下：</p><p> If you&#39;re using MacOS and want a single GUI app you can download from the App Store, choose  ClozureCL (often abbreviated &#34;CCL&#34;).</p><p> 如果您使用的是MacOS，并且希望可以从App Store下载单个GUI应用程序，请选择ClozureCL（通常缩写为＆＃34; CCL＆＃34;）。</p><p> That&#39;s Clozure with a Z. Clojure is something entirely different that justhappens to have a confusingly similar name.</p><p> 那个带Z. Clojure的Clozure是完全不同的东西，只是具有一个令人困惑的相似名称。</p><p> You might also hear of something called CLISP, which sounds like it might bewhat you want. It&#39;s not. CLISP is just another implementation, but it hasn&#39;thad a release in eight years (even though development is still ongoing in itssource repos!) and it&#39;s not as commonly used as CCL or SBCL, so it&#39;ll be harderto find help if you have questions about the installation, etc.</p><p> 您可能还会听到称为CLISP的声音，这听起来像是您想要的。不是。 CLISP只是另一种实现，但是它已经发布了八年（即使其源存储库仍在开发中！），它不像CCL或SBCL那样常用。如果对安装等有疑问，将很难找到帮助。</p><p> You might also hear about something called Roswell. Don&#39;t use Roswell, you don&#39;tneed it (yet (or at all)).</p><p> 您可能还会听到有关Roswell的信息。不要使用Roswell，您不需要（但（或完全没有））。</p><p> Just install SBCL or CCL for now, you can explore the other options once you&#39;vegot your bearings a bit better.</p><p> 现在只需安装SBCL或CCL，一旦您对轴承有了更好的了解，就可以探索其他选择。 </p><p>  You might hear people tell you that you  must learn Emacs before learningCommon Lisp. They&#39;re wrong. You can get started learning the language justfine in whatever text editor you&#39;re comfortable in.</p><p>您可能会听到人们告诉您，在学习Common Lisp之前必须先学习Emacs。他们错了。您可以在任何熟悉的文本编辑器中开始学习justfine语言。</p><p> If you don&#39;t have a preference, CCL itself comes bundled with a text editor onMacOS. That one will work just fine to start.</p><p> 如果您没有偏好，则CCL本身与MacOS上的文本编辑器捆绑在一起。那将开始就好了。</p><p> Emacs, Vim, Sublime Text, Atom, whatever, for now it doesn&#39;t matter. As long asit can balance parentheses, highlight comments and strings, and autoindent Lispcode that&#39;s all you need to start. Worry about shaving the editor yak onceyou&#39;re more comfortable in the language.</p><p> Emacs，Vim，Sublime Text，Atom，无论如何，现在都无关紧要。只要它可以平衡括号，突出显示注释和字符串以及自动缩进Lispcode，那么您就需要开始所有这些操作。一旦您对语言更加满意，就不必担心要编辑编辑牛了。</p><p>  To check that you&#39;ve got everything set up properly, make a  hello.lisp filewith the following contents:</p><p>  要检查所有设置是否正确，请制作一个hello.lisp文件，其内容如下：</p><p> (   defun hello  ( )  ( write-line  &#34;What is your name?&#34;)  (   let  (  ( name  ( read-line)))  ( format t  &#34;Hello, ~A.~%&#34; name)))</p><p> （defun hello（）（写入行＆＃34;您的名字是什么？＆＃34;）（let（（名称（读取行））））（格式t＆＃34; Hello，〜A.〜％＆ ＃34;名称）））</p><p>  Open an SBCL or CCL REPL ( Read/Eval/PrintLoop) andload the file by entering  (load &#34;hello.lisp&#34;), then call the function and makesure it works. It should look something like this if you picked SBCL:</p><p>  打开SBCL或CCL REPL（Read / Eval / PrintLoop）并通过输入（load＆＃34; hello.lisp＆＃34;）来加载文件，然后调用该函数并确保其正常工作。如果选择了SBCL，它应该看起来像这样：</p><p>  Or if you chose CCL but still want to use the command line, rather than theMacOS app (the command line program might be annoyingly named  ccl64 if you&#39;reon a 64-bit system):</p><p>  或者，如果您选择CCL但仍要使用命令行而不是MacOS应用程序（如果您使用64位系统，则命令行程序可能会令人讨厌地命名为ccl64）： </p><p>  If your arrow keys and backspace don&#39;t work in the REPL, use   rlwrapto fix that.  rlwrap sbcl will give you a non-miserable REPL.  rlwrap isa handy tool to have in your toolbox anyway.</p><p>如果您的箭头键和退格键在REPL中不起作用，请使用rlwrap修复该问题。 rlwrap sbcl将为您提供一个不惨的REPL。无论如何，rlwrap是一种方便的工具。</p><p>  The best book I&#39;ve found for getting started in Common Lisp is  Common Lisp:A Gentle Introduction to Symbolic Computation. This book reallydoes strive to be gentle. Even if you&#39;ve programmed before I&#39;d still recommendstarting here because it eases you into the language.</p><p>  我发现在Common Lisp中入门的最好的书是Common Lisp：符号计算的温和介绍。这本书的确努力做到文雅。即使您在开始编程之前也仍然建议从这里开始，因为这样可以使您轻松使用该语言。</p><p> The 1990 edition is available free from the site, and there&#39;s a 2013 reprintwhich fixes some minor errors in the 1990 version. If you can afford it I&#39;drecommend buying the 2013 edition, but the 1990 version will also do fine.</p><p> 您可以从网站上免费获得1990年版，并且在2013年进行了重印，此版本修复了1990年版中的一些小错误。如果您买得起，我建议您购买2013年版，但1990年版也可以。</p><p> Go through the book and  do all the exercises. This will take a while, andis mainly meant to get you started overcoming some of the main obstacles tobeing comfortable in Common Lisp, such as:</p><p> 仔细阅读本书并进行所有练习。这将需要一段时间，并且主要是为了让您开始克服Common Lisp的一些主要障碍，例如：</p><p>  If you find the book is moving too slow, just skim forward a bit. Skimming isa very useful skill to practice as a programmer. I think it&#39;s better forauthors to err on the side of explaining too much when writing books anddocumentation — expert readers should be comfortable skimming if you explain too much, but new users will be stuck wallowing in confusion if you&#39;re too terse.Creating hours of newbie misery and confusion to save a few flicks of anexpert&#39;s scroll wheel is a poor tradeoff to make.</p><p>  如果您发现这本书移动得太慢，则向前略略浏览一下。略读是作为程序员练习的一项非常有用的技能。我认为作者最好在撰写书籍和文档时偏向于过多解释-如果您解释过多，专家读者应该习惯于略读，但是如果您重新解释，那么新用户将陷入困境创建新手的痛苦和困惑的小时数以节省一些专家滚轮的笔势，这是一个很差的折衷选择。</p><p> You should also join the  #clschool channel on the Freenode IRC network so youcan ask questions if you get stuck. For the most part people there are friendlyand helpful, though I&#39;ll warn you in advance that there&#39;s at least one personwho can sometimes be abrasive. There&#39;s also a  #clnoobs channel, but that wasmostly abandoned during the latest wave of Freenode spam because no one had opsto help combat the spam.</p><p> 您还应该加入Freenode IRC网络上的#clschool频道，以便在遇到问题时可以提出问题。在大多数情况下，人们会友好而乐于助人，尽管我会提前警告您至少有一个人有时会磨砺。还有一个#clnoobs频道，但是在最近一波Freenode垃圾邮件浪潮中，这个频道几乎被放弃了，因为没有人愿意帮助打击垃圾邮件。</p><p> If IRC isn&#39;t your thing there&#39;s also a  Discordserver that some of us hang out in. Join the #common-lisp channel there and we&#39;ll be happy to help you.</p><p> 如果IRC并不是您的事，那么我们还有一些Discordserver，您可以在其中闲逛。加入那里的＃common-lisp频道，我们将很乐意为您提供帮助。 </p><p>  Once you&#39;ve finished that book the next one you should attack is  PracticalCommon Lisp. You can get a paper copy if you want, but the full bookis available on the site for free.</p><p>完成那本书后，您应该攻击的下一本书是PracticalCommon Lisp。您可以根据需要获得纸质副本，但完整的书籍可在网站上免费获得。</p><p> You can skip the editor/programming environment part because the environment itrecommends (Lisp in a Box) is abandoned and no longer works. Just keep usingthe programming environment you&#39;re comfortable with for now.</p><p> 您可以跳过编辑器/编程环境部分，因为它所建议的环境（盒中的Lisp）已被放弃并且不再起作用。暂时继续使用您熟悉的编程环境。</p><p> Unfortunately the book doesn&#39;t include exercises. If you  really want to getthe most out of it you can type in all the code as you&#39;re reading it and poke atit, but if you&#39;ve already done the exercises in the previous book it&#39;s probablysafe to just sit down and read the book carefully. Don&#39;t read more thana chapter or two a day. It will take a while for your brain to digest all theinformation.</p><p> 不幸的是，这本书没有练习。如果您确实想充分利用它，则可以在阅读并戳入密码时输入所有代码，但是如果您已经完成了上本书中的练习，则可能很安全只是坐下来仔细阅读这本书。每天不要阅读一两个以上的章节。您的大脑需要一些时间才能消化所有信息。</p><p> Make sure you understand everything as you go through the book. Don&#39;t be afraidto ask questions on IRC or Discord (or email me if you want, I don&#39;t mind) ifsomething&#39;s not clear.</p><p> 阅读本书时，请确保您理解所有内容。如果不清楚，请不要害怕在IRC或Discord上提问（如果需要，也可以给我发电子邮件）。</p><p> You should also begin to get comfortable looking up things in  the Common Lisplanguage specification itself. It&#39;s the ultimate manual for Common Lisp.It can be pretty dense at points, but can answer many questions you might haveif you read it slowly and carefully. You can either use the index page to findwhat you&#39;re looking for or just search on Google for &#34;clhs whatever&#34; (CLHSstands for &#34;Common Lisp HyperSpec&#34;, which is the hyperlinked, HTML version ofthe spec). If you already use the Dash app for MacOS, it has the Common Lispspec available.</p><p> 您还应该开始习惯于在Common Lisplanguage规范本身中查找内容。它是Common Lisp的终极手册。它可能有些密集，但是如果您仔细仔细地阅读它，可能会回答许多问题。您既可以使用索引页找到要查找的内容，也可以在Google上搜索“任何内容”。 （CLHS表示＆＃34; Common Lisp HyperSpec＆＃34 ;，它是该规范的HTML版本的超链接）。如果您已经在MacOS上使用了Dash应用程序，则它具有Common Lispspec。</p><p> (Some people will tell you to learn the language by just reading the spec. That&#39;sridiculous — it&#39;s like trying to learn French by reading a dictionary. It&#39;sa useful tool to have, but not the only one you&#39;ll need.)</p><p> （有些人会告诉您只阅读规范即可学习语言。这太荒谬了-就像试图通过阅读字典来学习法语。这是一个有用的工具，但不是您只需要一个。）</p><p>  Once you&#39;ve got those two books under your belt and some practice using thespec, it&#39;s time to make something without someone holding your hand. It doesn&#39;thave to be</p><p>  一旦掌握了这两本书并进行了一些使用该规范的练习，就可以在没有人牵着手的情况下制作东西了。它不必 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://stevelosh.com/blog/2018/08/a-road-to-common-lisp/">https://stevelosh.com/blog/2018/08/a-road-to-common-lisp/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/common/">#common</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>