<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何用任何编程语言的代码创建最少的音乐</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">如何用任何编程语言的代码创建最少的音乐</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-31 02:38:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/3cd67f8c773c5df13d60d9d2e7f8918c.png"><img src="http://img2.diglog.com/img/2020/10/3cd67f8c773c5df13d60d9d2e7f8918c.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I don’t really draw well, so I used formatted C code instead. That was supposed to be a triangular sound wave written in C. In fact, this very C code plays two-octave melodies written in text notation from stdin.</p><p>我画得不是很好，所以我用了格式化的C代码。这应该是一个用C语言编写的三角形声波。事实上，这段C代码播放的是两个八度的旋律，它们是用标准输入的文本符号写成的。</p><p> It’s only 160 bytes, fits into a modern-day tweet, and the reason it’s there is to show how simple it is to create minimal music with code in any programming language, not just the special languages like  CSound,  ChucK, or  SonicPi.</p><p>它只有160个字节，适合现代的tweet，之所以有它，是为了展示用任何编程语言，而不仅仅是cSound、Chuck或SonicPI这样的特殊语言，用代码创建最低限度的音乐是多么简单。</p><p>    This is sound - something that oscillates and moves the air in time, and the air reaches your ears and you hear it. The wave that goes up and down in the picture illustrates show the air vibrates. To describe this wave in digital terms people came up with an idea to measure the amplitude of the wave at fixed time intervals and use these sampled data points as “digital sound”.</p><p>这就是声音--一种能及时振动和移动空气的东西，空气传到你的耳朵里，你就能听到。图中上下起伏的波浪说明空气在振动。为了用数字来描述这个波，人们提出了一个想法，即以固定的时间间隔测量波的振幅，并将这些采样的数据点用作“数字声音”。</p><p> Two questions arise - how often to sample the sound wave, and how to digitally represent the units of the amplitude range? To answer the first question we should recall that the human ear can not hear anything higher than 20000 Hz, that’s why CD music had a sample rate of 22000 Hz. Modern sound cards however tend to use sampling rates twice as high - 44100 Hz or 48000 Hz or even 96000 Hz. Lo-fi audio devices like Arduino or NES simply could not produce sound at such a high speed, so they used a reasonably low sampling rate, like 8000 Hz, and this is what we will be using in this article.</p><p>出现了两个问题--多久采样一次声波，以及如何以数字方式表示振幅范围的单位？要回答第一个问题，我们应该回想一下，人耳听不到任何高于20000赫兹的声音，这就是为什么CD音乐的采样率是22000赫兹。然而，现代声卡往往使用两倍高的采样率-44100 Hz或48000 Hz，甚至96000 Hz。像Arduino或NES这样的Lo-fi音频设备根本不能以如此高的速度发出声音，所以它们使用了相当低的采样率，比如8000 Hz，这就是我们在本文中将使用的采样率。</p><p> The amplitude quantization is also a matter of compromise. In theory, people can recognize a very subtle change of the amplitude, but computers can’t use infinitely precise numbers for each sample. Instead, they perform quantization - they map the amplitude value into a fixed-width number, like a float or an integer. In the picture above I’ve used +1 and -1 as the minimum and maximum value of the amplitude, assuming the  float data type, but other popular formats are signed  int16, where amplitude changes from -32768 to +32767, or a  uint8, where amplitude changes from 0 to 255. The last one is what we will be using in this article because it’s very easy to understand and brings a few nice tricks.</p><p>幅度量化也是一个折衷的问题。理论上，人们可以识别振幅的非常细微的变化，但计算机不能对每个样本使用无限精确的数字。相反，它们执行量化-它们将振幅值映射到固定宽度的数字，如浮点数或整数。在上面的图片中，我使用+1和-1作为振幅的最小值和最大值，假设是FLOAT数据类型，但是其他流行的格式是带符号的int16，其中振幅从-32768变为+32767，或者uint8，其中振幅从0变为255.。最后一个是我们将在本文中使用的，因为它非常容易理解，并且带来了一些不错的技巧。</p><p> Now, having the sample rate of 8000 and data format of unsigned uint8, digital sound is nothing more nothing less than an array of bytes shifting in time at the speed of 8000 bytes per second.</p><p>现在，有了8000的采样率和无符号uint8的数据格式，数字声音无非就是一个以每秒8000字节的速度在时间上移动的字节数组。</p><p> If our array is all zeros - there will be silence. If our array will be all 255 - there will be silence as well. However, if our array would contain different numbers - that would be a sound wave.</p><p>如果我们的数组全为零-将会静默。如果我们的阵列将全部是255-也将是静默的。然而，如果我们的数组包含不同的数字-那就是声波。</p><p> How can we hear it? One route would be to use native OS APIs, and that would be a route to the cross-platform programming hell because each OS has a different set of APIs, equally complex and unpleasant to use. And this is where UNIX way comes to the rescue. There are small utilities, and if you are lucky - they might even come with your OS - that allows you to play the sound streaming from stdin. On linux that would be  aplay or  pacat, while macOS and Windows users would have to install  SoX and use the  play command.</p><p>我们怎么能听到呢？一种途径是使用原生操作系统API，这将是通向跨平台编程地狱的途径，因为每个操作系统都有一组不同的API，同样复杂，使用起来也不愉快。这就是UNIX Way的用武之地。有一些小的实用程序，如果你幸运的话-它们甚至可能是你的操作系统附带的-允许你播放来自stdin的声音流。在Linux上，这将是aplay或pacat，而MacOS和Windows用户必须安装SOX并使用PLAY命令。</p><p> Here are a few commands that should allow you to play raw unsigned bytes from stdin at the rate of 8000 samples per second:</p><p>以下几个命令应该允许您以每秒8000个样本的速率播放标准输入中的原始无符号字节：</p><p> alias  PLAY = &#39;aplay&#39; alias  PLAY = &#39;pacat --rate 8000 --channels 1 --format u8&#39; alias  PLAY = &#39;play -c1 -b8 -eunsigned -traw -r8k -&#39; alias  PLAY = &#39;mplayer -cache 1024 -quiet -rawaudio samplesize=1:channels=1:rate=8000 -demuxer rawaudio -&#39; alias  PLAY = &#39;ffplay -ar 8000 -ac 1 -f u8 -nodisp -&#39; # Play some white noisecat /dev/urandom  | PLAY</p><p>Alias play=&#39；aplay&#39；alias play=&#39；pacat--rate 8000--channel 1--format u8&#39；alias play-c1-b8-eunsign-traw-r8k-&#39；alias play=&#39；mplayer-cache 1024-Quiet-rawdio samplesize=1：channel=1：rate=8000-demuxer rawdio-&#39；alias play=&#39；ffplay-ar 8000-ac 1-f u8-nodisp-&#39；#play一些白噪音/dev/urandom|play=1：channel=1：rate=8000-demuxer rawdio-&#39；#play-ar 8000-ac 1-f u8-nodisecat/dev/urandom|play。</p><p>  Digital sound is a very simple programming concept, and producing it can be as simple as writing a for-loop. For example, this tiny app should make infinite white noise:</p><p>数字声音是一个非常简单的编程概念，生成它可以像编写一个for循环一样简单。例如，这个小应用程序应该会发出无限的白噪音：</p><p> // cc noise.c -o noise &amp;&amp; ./noise | PLAY  #include  &lt;stdio.h&gt;  #include  &lt;stdlib.h&gt;   int  main ()  {  for  (;;)  putchar ( rand ());  }</p><p>//cc noise.c-o Noise&amp；&amp；./Noise|play#include&lt；stdio.h&gt；#include&lt；stdlib.h&gt；int main(){for(；；)putchar(rand())；}。</p><p> To play a note rather than the noise we should make our sound periodic, the waveform should repeat itself at a certain frequency, and that frequency would define the note pitch. Here are the most common oscillator waveforms:</p><p>为了演奏音符而不是噪音，我们应该使声音具有周期性，波形应该以特定的频率重复，该频率将定义音符的音高。以下是最常见的振荡器波形：</p><p>  The simplest oscillator in C would be the sawtooth wave. C implicitly casts  int to  unsigned char inside  putchar, so if we simply write  for (int t = 0;; t++) putchar(t) - we get a sawtooth wave. It won’t be a note yet, only a low buzzing sound. To play a note we need to know it frequency. For example, the most common “reference” note is A from octave 4, which has the frequency of exactly 440 Hz, and this is what most tuning forks (kamertons) resonate to.</p><p>C语言中最简单的振荡器是锯齿波。C隐式地将int强制转换为putchar内的无符号字符，所以如果我们只写(int t=0；；t++)putchar(T)，我们会得到一个锯齿波。它还不会是音符，只会发出低沉的嗡嗡声。要演奏一个音符，我们需要知道它的频率。例如，最常见的“参考”音符是来自倍频程4的A音符，它的频率正好是440 Hz，这就是大多数音叉(Kamerton)产生共鸣的地方。</p><p> 440 Hz means the oscillator should go from 0 to 255 exactly 440 times per second. We also know that during one second our loop must produce 8000 values because that is our sample rate. So every time the loop iterates we should increase the oscillator counter by  256*440/8000=14.08. Roughly, 14.</p><p>440 Hz意味着振荡器应该从0到255每秒精确440次。我们还知道，在一秒内，我们的循环必须产生8000个值，因为这是我们的采样率。因此，每次循环迭代时，我们应该将振荡器计数器增加256*440/8000=14.08。大概有14个。</p><p> To create a square wave we can simply get the 8th bit of the oscillator counter, it will be 0 for the values 0..127 and 0x80 for the values 127..255. This will result in a square wave of the same frequency as the sawtooth, it will be a bit more quiet, since the amplitude range will be twice as narrow, but still loud enough to hear it.</p><p>要创建方波，我们可以简单地获得振荡器计数器的第8位，对于值0..127，它将是0；对于值127..255，它将是0x80。这将产生一个与锯齿波频率相同的方波，它会稍微安静一些，因为振幅范围会窄一倍，但仍然足够大，可以听到它。</p><p> The sine wave requires the  sin() function, we can use the oscillator counter (phase), divide it by 255, and multiply by 2π. The resulting amplitude should be multiplied by 255 to get it as loud as the other oscillators because  sin() returns the values in the range [-1..1].</p><p>正弦波需要sin()函数，我们可以使用振荡器计数器(相位)，将其除以255，再乘以2π。产生的振幅应该乘以255才能与其他振荡器一样响亮，因为sin()返回范围[-1..1]中的值。</p><p>  /* Sawtooth */ for  ( int  t = 0 ,  osc  =  0 ;  t  &lt;  8000 ;  t ++ ,  osc  =  osc  +  14 )  {  putchar ( osc ); } /* Square */ for  ( int  t = 0 ,  osc  =  0 ;  t  &lt;  8000 ;  t ++ ,  osc  =  osc  +  14 )  {  putchar ( osc  &amp;  0x80 ); } /* Sine wave */ for  ( int  t = 0 ,  osc  =  0 ;  t  &lt;  8000 ;  t ++ ,  osc  =  osc  +  14 )  {  putchar ( 127  *  sin ( osc / 255.0 * 2 * 3.14 )  +  128 ); }</p><p>/*锯齿*/for(int t=0，OSC=0；t&lt；8000；t++，OSC=OSC+14){putchar(OSC)；}/*方形*/for(int t=0，OSC=0；t&lt；8000；t++，OSC=OSC+14){putchar(OSC&amp；0x80)；}/*正弦波*/for(int t=0，OSC=0；t&lt；8000；T++，osc=osc+14){putchar(127×sin(osc/255.0*2*3.14)+128)；}。</p><p> There is one more approach to produce oscillating sound, and it’s a clever one. It is often used to simulate bass or guitar strings. The idea is to fill the array with random data. The length of the array should be equal to the period of the oscillator, in our case for 440 Hz that would be ~18 samples. Then we will “play” bytes from that array, going back to the first item when we reach the end of the buffer. Despite being filled with random bytes, the repeating pattern of that random noise will sound like an oscillator and we will hear a distinctive pitch. But to make it sound like a trick we would have to smooth the data every time we loop over the array - we would replace elements with the average value of the current element and the next one. That’s how with each iteration the random number would become more and more smooth until they are all equal and the oscillator fades out in silence:</p><p>还有一种产生振荡声音的方法，这是一种很聪明的方法。它通常用于模拟低音或吉他弦。其想法是用随机数据填充数组。阵列的长度应该等于振荡器的周期，在我们的例子中，对于440 Hz，这将是~18个样本。然后，我们将“播放”该数组中的字节，在到达缓冲区末尾时返回到第一个项目。尽管充满了随机字节，但随机噪声的重复模式听起来就像振荡器，我们会听到独特的音调。但是，为了让它听起来像个把戏，我们必须在每次循环数组时平滑数据-我们将用当前元素和下一个元素的平均值替换元素。这就是如何在每次迭代中，随机数变得越来越平滑，直到它们全部相等，振荡器在静默中淡出：</p><p> unsigned  char  a [ 18 ]; for  ( int  i  =  0 ;  i  &lt;  sizeof ( a );  i ++ )  a [ i ]  =  rand (); for  ( int  t = 0 ;  t  &lt;  8000 ;  t ++ )  {  int  i  =  t  %  sizeof ( a );  int  j  =  ( t + 1 )  %  sizeof ( a );  putchar ( a [ i ]  =  ( a [ i ]  +  a [ j ]) / 2 ); }</p><p>Unsign char a[18]；for(int i=0；i&lt；sizeof(A)；i++)a[i]=rand()；for(int t=0；t&lt；8000；t++){int i=t%sizeof(A)；int j=(t+1)%sizeof(A)；putchar(a[i]=(a[i]+a[j])/2)；}。</p><p> Try using larger arrays and see how the pitch becomes lower and the duration of the sound gets longer. Doesn’t it resemble the sound of a string or kalimba tines?</p><p>试着使用更大的阵列，看看音调是如何变低的，声音的持续时间是如何变长的。它不是很像弦或卡林巴尖牙的声音吗？</p><p>  Now that we are able to play a single note, how can we play a melody? We need to change the pitch of the notes in time and that is what step sequencers do. We may have a fixed number of steps, each having a fixed duration, we can iterate them in a loop and change the pitch accordingly. Each step may contain the increment of the oscillator phase counter, zero would notate a pause. For example, here’s a familiar riff “E B D E D B A B”. It uses only 4 notes - D and E from one octave and A + B from the other, lower octave. If we look at the  note frequency table, the pitches of those notes in octaves 5 and 4 would be 659.2Hz (E), 587.3Hz (D), 440Hz (A) and 493.8Hz (B).</p><p>既然我们可以演奏一个音符，我们怎么才能演奏旋律呢？我们需要及时改变音符的音高，这就是步长定序器所做的事情。我们可以有固定数量的步长，每个步长都有固定的持续时间，我们可以在循环中重复它们，并相应地改变音调。每一步可以包含振荡器相位计数器的增量，零表示暂停。例如，这里有一个熟悉的即兴小品“E B D E D B B A B”。它只使用了4个音符-一个八度的D和E，另一个较低的八度的A+B。如果我们看音符频率表，这些音符在八度5和4的音高将是659.2赫兹(E)，587.3赫兹(D)，440赫兹(A)和493.8赫兹(B)。</p><p> The oscillator phase increments would then be approximately 21 (E), 19 (D), 14 (A) and 16 (B). Each step may take 2000 samples (1/4 of a second). Then the playback loop could look like:</p><p>振荡器相位增量将约为21(E)、19(D)、14(A)和16(B)。每一步可以采集2000个样本(1/4秒)。则播放循环可能如下所示：</p><p> int  osc  =  0 ; int  melody [ 8 ]  =  { 21 ,  16 ,  19 ,  21 ,  19 ,  16 ,  14 ,  16 }; for  ( int  step  =  0 ;; step  =  ( step  +  1 )  %  8 )  {  int  increment  =  melody [ step ];  for  ( int  t  =  0 ;  t  &lt;  2000 ;  t ++ )  {  osc  =  osc  +  increment ;  putchar ( osc );  } }</p><p>Int OSC=0；int melody[8]={21，16，19，21，19，16，14，16}；for(int step=0；；step=(step+1)%8){int增量=melody[step]；for(int t=0；t&lt；2000；t++){OSC=OSC+Increment；putchar(OSC)；}}</p><p> I guess, now it’s time to deobfuscate the melody player from the very beginning of this post:</p><p>我想，现在是时候从这篇文章的一开始就对旋律播放器进行模糊处理了：</p><p> // play.c  #include  &lt;stdio.h&gt;   int  main ()  {  float  f ;  /* note frequency */  char  c ;  /* &#34;cdefgab&#34; for notes or &#34;pr&#34; for pause */  int  d ,  o ;  /* d = duration, o = octave */  while  ( scanf ( &#34;%d%c%d &#34; ,  &amp; d ,  &amp; c ,  &amp; o )  &gt;  0 )  {  /* convert note to lowercase */  c  &amp;=  31 ;  /* c&gt;&gt;4 is 0 for CDEFGAB and 1 for &#34;PR&#34; */  /* so, for pauses f would be zero, for notes - 55 */  f  =  ! ( c  &gt;&gt;  4 )  *  55 ;  /* a trick we used in Nokia Composer post to conver note letter to note index */  c  =  ( c  *  8  /  5  +  8 )  %  12  +  o  *  12  -  22 ;  /* Note `x` frequency is 2^(x/12), or (2^(1/12))^x */  while  ( c -- )  {  f  *=  1.0595 ;  /* 1.0595 is 2^(1/12) */  }  /* Play sawtooth wave for the given duration with given pitch */  for  ( d  =  16e3  /  d ;  d -- ;  putchar ( d  *  f  *  .032 ));  } }</p><p>//play.c#include&lt；stdio.h&gt；int main(){Float f；/*音符频率*/char c；/*&#34；cdefgab&#34；对于音符或&#34；pr&#34；对于暂停*/int d，o；/*d=持续时间，o=八度*/While(scanf(&#34；%d%c%d&#34；，&amp；d，&amp；c，&amp；O)&gt；0){/*将备注转换为小写*/c&amp；=31；/*c&gt；&gt；4对于CDEFGAB是0，对于&#34；PR&#34；*//*因此，对于停顿，f将是零，对于备注-55*/f=！(C&&gt;；&&gt;4)*55；/*我们在诺基亚Composer帖子中使用的将备注字母转换到备注索引的技巧*/c=(c*8/5+8)%12+o*12-22；/*注意`x`频率为2^(x/12)，或(2^(1/12))^x*/While(c--){f*=1.0595；/*1.0595为2^(1/12)*/}/*以给定的音高播放给定时长的锯齿波*/for(d=16e3/d；d--；putchar(d*f*.032))；}}。</p><p> It plays music in something similar to MML, RTTTL or ABC notation. It expects a sequence of notes coming from stdin. Notes can be separated by whitespace, or commas or any other symbols that scanf would safely ignore. Each note has 3 parts - duration, pitch and octave, for example our loop from above can be written as “8e5 8b4 8d5 8e5 8d5 8b4 8a4 8b4”. Note frequency calculation is taken from  Nokia Composer and note playback is done with the sawtooth oscillator, as been described above.</p><p>它播放类似于MML、RTTTL或ABC表示法的音乐。它期望来自标准输入的一系列注释。注释可以用空格、逗号或scanf安全忽略的任何其他符号分隔。每个音符有3个部分-持续时间、音高和八度，例如，我们上面的循环可以写成“8e5 8b4 8d5 8e5 8d5 8b4 8a4 8b4”。如上所述，音符频率计算来自Nokia Composer，音符回放使用锯齿形振荡器。</p><p> Due to the numerous overflows, there are ASCII symbols beyond CDEFGAB that result in sharp notes:</p><p>由于大量溢出，CDEFGAB之外的ASCII符号会导致尖锐的音符：</p><p>   There is a niche music genre, known as ByteBeat, where music is written as terse C expressions. I hope to cover it in more detail in further articles, because it combines the cleverness of tiny code with the creativity of music composing. It heavily uses bit shifts and bitmasks to juggle notes. Some of the melodies are created by accident, some are carefully composed with some end goal in mind. They tend to sound a bit harsh and maybe slightly off-tune, but their beauty is in their code. A typical example of bytebeat would be:</p><p>有一种名为ByteBeat的小众音乐流派，其中的音乐以简洁的C表达式编写。我希望在以后的文章中更详细地介绍它，因为它结合了微小代码的智慧和音乐创作的创造力。它大量使用位移位和位掩码来变戏法处理音符。有些旋律是偶然创作的，有些是精心创作的，目的是为了达到某个最终目标。他们往往听起来有点刺耳，也许有点跑调，但他们的美丽在于他们的代码。字节跳动的典型示例是：</p><p>  It produces a repetitive melody of the uncertain pitch, that sounds like multiple instruments and has a certain rhythm. You might find a lot more bytebeat examples on the web, if you are interested.</p><p>它产生不确定音高的重复旋律，听起来像多种乐器，有一定的节奏。如果你感兴趣，你可以在网上找到更多字节跳动的例子。</p><p>  The pure oscillating sound is boring. But fortunately, there are a few sound effects that we can apply to it without much of a hassle.</p><p>纯粹的摆动声音令人厌烦。但幸运的是，有一些音效我们可以毫不费力地应用到它上。</p><p> For example, the bytebeat tune above can be passed through some kind of a low-pass filter that would smoothen the high frequencies and leave the low frequencies. The simplest form of a low-pass filter would be approximating the current output value with the previous one stored in the accumulator:</p><p>例如，上面的字节跳动曲调可以通过某种低通滤波器来平滑高频，留下低频。低通滤波器的最简单形式是将当前输出值与存储在累加器中的前一个输出值近似：</p><p> int  main ()  {  int  prev  =  0 ;  for  ( int  t  =  0 ;;  t ++ )  {  int  output  =  t * ( t + ( t &gt;&gt; 9 | t &gt;&gt; 13 )) % 40 &amp; 120 ;  prev  =  prev  *  0.8  +  output  *  0.2 ;  putchar ( prev );  } }</p><p>Int main(){int prev=0；for(int t=0；；t++){int output=t*(t+(t&gt；&gt；9|t&gt；&gt；&gt；13))%40&amp；120；prev=prev*0.8+output*0.2；putchar(Prev)；}}。</p><p> The sound should become more muffled and less high-pitched. If you change 0.8/0.2 to 0.9/0.1 the effect should become even stronger. Try adjusting the coefficients and see how it affects the sound.</p><p>声音应该变得更低沉，更不高音。如果将0.8/0.2更改为0.9/0.1，效果应该会更强。试着调整系数，看看它是如何影响声音的。</p><p> If you want to reduce the low frequencies and leave the high ones - just subtract the filtered low-pass signal from the original signal.</p><p>如果您想要降低低频而保留高频-只需从原始信号中减去滤波后的低通信号即可。</p><p> Another simple affect would be a delay line, which is just another array, storing a few recent signal values. For example, we want to re-play our sound with a 0.1 second delay. At the sampling rate of 8000 Hz we need to store 800 most recent samples and add them to the current output signal with a 800 byte offset:</p><p>另一个简单的影响是延迟线，它只是另一个数组，存储一些最近的信号值。例如，我们希望以0.1秒的延迟重新播放我们的声音。在8000 Hz的采样率下，我们需要存储800个最新样本，并将它们与当前输出信号相加，偏移量为800字节：</p><p> #define N 800  int  main ()  {  int  delay [ N ]  =  { 0 };  for  ( int  t  =  0 ;;  t ++ )  {  int  output  =  (( t * ( 42 &amp; t &gt;&gt; 10 )) &amp; 0xff ) / 2 ;  delay [ t % N ]  =  output ;  /* put current sample into delay line */  putchar ( output  +  delay [( t + 1 ) % N ]);  /* mix current sample with the oldest sample from the delay line */  } }</p><p>#定义N 800 int main(){int delay[N]={0}；for(int t=0；；t++){int output=((t*(42&amp；t&gt；&gt；10))&amp；0xff)/2；延迟[t%N]=输出；/*将当前样本放入延迟线*/putchar(输出+延迟[(t+1)%N])；/*将当前样本与延迟线上最早的样本混合*/}}。</p><p> This should bring a bit of polyphony to the sound and there would be some echo. Delay lines are very easy to implement, and mixed with filters that may result in the reverberation effect.</p><p>这应该会给声音带来一点复调，会有一些回声。延迟线非常容易实现，并且与可能导致混响效果的滤波器混合。</p><p>  There are many more possible effects one could code in C, but the post is long enough and I guess I should stop. Similarly, playing with an oscillator may inspire you to create a sample player, or a granular synthesizer, or a frequency-modulating synthesizer. Of course, sequencers are also an endless area of experimentation - from random music generation and self-evolving melodies to compact sequencers like old mod trackers, that could be used in short demos and games.</p><p>人们可以用C语言编写更多可能的效果，但是这篇文章太长了，我想我应该停止了。类似地，玩振荡器可能会激发您创建样例播放器、颗粒合成器或调频合成器的灵感。当然，音序器也是一个无穷无尽的实验领域-从随机的音乐生成和自我演变的旋律，到像老式mod追踪器这样的紧凑型音序器，可以用在简短的演示和游戏中。</p><p> If you are into music - feel free to share your sound experiments! In the meantime, I’m preparing a post about the elegance of 1-bit sound with a simple tool to create 1-bit music. If there are any other music+programming topic you would like to hear about - just drop me a line.</p><p>如果你喜欢音乐--请随意分享你的声音实验！同时，我正在准备一篇关于1位声音优雅的帖子，用一个简单的工具来制作1位音乐。如果你有任何其他的音乐+节目话题想知道--只要给我写信就行了。</p><p> I hope you’ve enjoyed this article. You can follow – and contribute to – on  Github,  Twitter or subscribe via  rss.</p><p>我希望你喜欢这篇文章。你可以在Github、Twitter或通过RSS订阅，并向其投稿。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://zserge.com/posts/etude-in-c/">https://zserge.com/posts/etude-in-c/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/minimal/">#minimal</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/声音/">#声音</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1032274.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b25bd6c3aa1ce3fe07da872ea5f6a4e0.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032274.html">Value将他们的Linux游戏容器源代码放在GitLab上</a></div><span class="my_story_list_date">2020-10-30 21:27</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032160.html"><img src="http://img2.diglog.com/img/2020/10/thumb_0f8b6a905dc413e0355e6a62ffbfad78.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032160.html">摩根大通和高盛订单软件在选举期间“代码冻结”</a></div><span class="my_story_list_date">2020-10-30 5:46</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032025.html"><img src="http://img2.diglog.com/img/2020/10/thumb_01e8c2de8bb949c7268a12fe83a6d7f5.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032025.html">
Redpoint和Sequoia正在支持一家初创公司复制编辑你的狗屎代码</a></div><span class="my_story_list_date">2020-10-29 22:34</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031871.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b8bda162dc23b87fa3a5b1b4ab6f2a80.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031871.html">有效使用遗留代码的要点</a></div><span class="my_story_list_date">2020-10-29 10:26</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>