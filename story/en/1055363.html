<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Voxel Space：Comanche的地形渲染在少于20行代码（2020） Voxel Space: Comanche's terrain rendering in less than 20 lines of code (2020)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Voxel Space: Comanche's terrain rendering in less than 20 lines of code (2020)<br/>Voxel Space：Comanche的地形渲染在少于20行代码（2020） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-01 20:02:37</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/d834fdeafa72a4e1c2270910fc6e1ba9.jpeg"><img src="http://img2.diglog.com/img/2021/4/d834fdeafa72a4e1c2270910fc6e1ba9.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Let us go back to the year 1992. The CPUs were 1000 times slower than today and the acceleration via a GPU was unknown or unaffordable. 3D games were calculated exclusively on the CPU and the rendering engine rendered filled polygons with a single color.</p><p>让我们回到1992年。CPU比今天慢1000倍，通过GPU的加速度未知或不适算。 3D游戏专门计算在CPU上，渲染引擎呈现填充的多边形，具有单色。</p><p>    The graphics were breathtaking for the time being and in my opinion 3 years ahead of its time. You see many more details such as textures on mountains and valleys, and for the first time a neat shading and even shadows. Sure, it&#39;s pixelated, but all games in those years were pixelated.</p><p>    图形是令人叹为观止的时间，并在我的意见前3年提前。您在山脉和山谷上看到了更多细节，如纹理，并且第一次是一个整洁的着色甚至阴影。当然，它的像素化，但这些年份的所有游戏都是像素化的。</p><p>  Comanche uses a technique called  Voxel Space, which is based on the same ideas like  ray casting. Hence the Voxel Space engine is a 2.5D engine, it doesn&#39;t have all the levels of freedom that a regular 3D engine offers.</p><p>  Comanche使用一种名为Voxel Space的技术，这是基于与Ray Casting的相同想法。因此，体素空间引擎是2.5D发动机，它没有常规3D发动机提供的所有自由度。</p><p>  The easiest way to represent a terrain is through a height map and color map. For the game Comanche a 1024 * 1024 one byte height map and a 1024 * 1024 one byte color map is used which you can download on this site. These maps are periodic:</p><p>  代表地形的最简单方法是通过高度地图和彩色地图。对于游戏Comanche A 1024 * 1024一个字节高度映射和1024 * 1024您可以在本网站上下载一个字节的颜色图。这些地图是定期的：</p><p>  Such maps limit the terrain to &#34;one height per position on the map&#34; - Complex geometries such as buildings or trees are not possible to represent. However, a great advantage of the colormap is, that it already contains the shading and shadows. The Voxel Space engine just takes the color and doesn&#39;t have to compute illumination during the render process.</p><p>  这样的地图将地形限制在地图上的一个高度。地图＆＃34; - 诸如建筑物或树等复杂的几何形状不可能表示。然而，Colormap的一个很大的优点是它已经包含着色和阴影。 Voxel Space Engine只取出颜色，也不需要在渲染过程中计算照明。</p><p>  For a 3D engine the rendering algorithm is amazingly simple. The Voxel Space engine rasters the height and color map and draws vertical lines. The following figure demonstrate this technique.</p><p>  对于3D引擎，渲染算法非常简单。 Voxel Space Engine将高度和颜色图绘制并绘制垂直线路。下图展示了这种技术。</p><p>  To guarantee occlusion start from the back and render to the front. This is called painter algorithm.</p><p>  保证遮挡从后面开始并渲染到前面。这称为画家算法。 </p><p> Determine the line on the map, which corresponds to the same optical distance from the observer. Consider the field of view and the  perspective projection (Objects are smaller farther away)</p><p>确定地图上的线，其对应于与观察者相同的光学距离。考虑视野和透视投影（物体越远较小）</p><p>  Retrieve the height and color from the 2D maps corresponding of the segment of the line.</p><p>  从相对应的2D地图检索高度和颜色。</p><p>  Draw a vertical line with the corresponding color with the height retrieved from the perspective projection.</p><p>  使用相应的颜色绘制垂直线，从透视投影中检索的高度。</p><p> The core algorithm contains in its simplest form only a few lines of code (python syntax):</p><p> 核心算法以最简单的形式包含几行代码（Python语法）：</p><p> def  Render( p,  height,  horizon,  scale_height,  distance,  screen_width,  screen_height):  # Draw from back to the front (high z coordinate to low z coordinate)  for  z  in  range( distance,  1,  - 1):  # Find line on map. This calculation corresponds to a field of view of 90°  pleft  =  Point( - z  +  p. x,  - z  +  p. y)  pright  =  Point(  z  +  p. x,  - z  +  p. y)  # segment the line  dx  = ( pright. x  -  pleft. x)  /  screen_width  # Raster line and draw a vertical line for each segment  for  i  in  range( 0,  screen_width):  height_on_screen  = ( height  -  heightmap[ pleft. x,  pleft. y])  /  z  *  scale_height.  +  horizon  DrawVerticalLine( i,  height_on_screen,  screen_height,  colormap[ pleft. x,  pleft. y])  pleft. x  +=  dx # Call the render function with the camera parameters: # position, height, horizon line position, # scaling factor for the height, the largest distance,  # screen width and the screen height parameter Render(  Point( 0,  0),  50,  120,  120,  300,  800,  600 )</p><p> def渲染（p，高度，地平线，scale_height，距离，screen_width，screen_height）：＃从回到前面（高z坐标为低z坐标），在范围内（距离，1， -  1）：＃查找行在地图上。该计算对应于90°PLEFT = Point（ -  Z + P. x， -  z + p.y）prilight = point（z + p.x， -  z + p.y）＃段的视野DX =（X-PLEFT. x）/ screen_width＃栅格线并为每个段的垂直线绘制IN范围（0，屏幕_WIDTH）：height_on_screen =（高度 - 高度图[Pleft。x，pleft。y]） / z * scale_height。 + Horizo​​ n DrawVerticalline（i，height_on_screen，screen_height，colormap [pleft。x，pleft。y]）pleft。 x + = dx＃用相机参数调用渲染功能：＃位置，高度，地平线位置，＃高度的缩放系数，最大距离，＃屏幕宽度和屏幕高度参数渲染（点（0,0） ，50,120,120,300,800,600）</p><p>  With the algorithm above we can only view to the north. A different angle needs a few more lines of code to rotate the coordinates.</p><p>  通过上面的算法，我们只能查看到北方。不同的角度需要更多的代码行来旋转坐标。</p><p>  def  Render( p,  phi,  height,  horizon,  scale_height,  distance,  screen_width,  screen_height):  # precalculate viewing angle parameters  var  sinphi  =  math. sin( phi);  var  cosphi  =  math. cos( phi);  # Draw from back to the front (high z coordinate to low z coordinate)  for  z  in  range( distance,  1,  - 1):  # Find line on map. This calculation corresponds to a field of view of 90°  pleft  =  Point( ( - cosphi * z  -  sinphi * z)  +  p. x, (  sinphi * z  -  cosphi * z)  +  p. y)  pright  =  Point( (  cosphi * z  -  sinphi * z)  +  p. x, ( - sinphi * z  -  cosphi * z)  +  p. y)  # segment the line  dx  = ( pright. x  -  pleft. x)  /  screen_width  dy  = ( pright. y  -  pleft. y)  /  screen_width  # Raster line and draw a vertical line for each segment  for  i  in  range( 0,  screen_width):  height_on_screen  = ( height  -  heightmap[ pleft. x,  pleft. y])  /  z  *  scale_height.  +  horizon  DrawVerticalLine( i,  height_on_screen,  screen_height,  colormap[ pleft. x,  pleft. y])  pleft. x  +=  dx  pleft. y  +=  dy # Call the render function with the camera parameters: # position, viewing angle, height, horizon line position,  # scaling factor for the height, the largest distance,  # screen width and the screen height parameter Render(  Point( 0,  0),  0,  50,  120,  120,  300,  800,  600 )</p><p>  def渲染（p，phi，高度，地平线，scale_height，距离，screen_width，screen_height）：＃预先平衡视角参数var sinphi = math。罪（PHI）; var cosphi =数学。 cos（phi）; ＃从返回到前部（高Z坐标为低Z坐标），在z范围内（距离，1， -  1）：＃在地图上查找线。该计算对应于90°PLEFT =点的视场（ - （ -  COSPI * Z  -  SINPHI * Z）+ P. x，（SINPHI * Z  -  COSPI * Z）+ P.Y）PRIGHT = POINT（（Cashi * z  -  sinphi * z）+ p。x，（ -  sinphi * z  -  cashi * z）+ p。y）＃段线dx =（斜视。x  -  pleft。x）/ screen_width dy =（pr。y -  pleft。y）/ screen_width＃栅格线并为i的每个段绘制一个垂直线（0，screen_width）：height_on_screen =（高度 - 高度图[pleft。x，pleft。y]）/ z * scale_height。 + Horizo​​ n DrawVerticalline（i，height_on_screen，screen_height，colormap [pleft。x，pleft。y]）pleft。 x + = dx pleft。 y + = dy＃用相机参数呼叫渲染功能：＃位置，查看角度，高度，地平线位置，＃高度的缩放系数，最大距离，＃屏幕宽度和屏幕高度参数呈现（点（0 ，0），0,50,120,120,300,800,600） </p><p>   Instead of drawing from back to the front we can draw from front to back. The advantage is, the we don&#39;t have to draw lines to the bottom of the screen every time because of occlusion. However, to guarantee occlusion we need an additional y-buffer. For every column, the highest y position is stored. Because we are drawing from the front to back, the visible part of the next line can only be larger then the highest line previously drawn.</p><p>而不是从背面绘制我们可以从前面绘制。优点是，我们不必每次由于遮挡时向屏幕底部绘制线条。但是，为了保证闭塞，我们需要额外的Y缓冲液。对于每个列，存储最高的y位置。因为我们从前到后面绘制，所以下一行的可见部分只能较大，然后绘制的最高线。</p><p>  def  Render( p,  phi,  height,  horizon,  scale_height,  distance,  screen_width,  screen_height):  # precalculate viewing angle parameters  var  sinphi  =  math. sin( phi);  var  cosphi  =  math. cos( phi);  # initialize visibility array. Y position for each column on screen   ybuffer  =  np. zeros( screen_width)  for  i  in  range( 0,  screen_width):  ybuffer[ i]  =  screen_height  # Draw from front to the back (low z coordinate to high z coordinate)  dz  =  1.  z  =  1.  while  z  &lt;  distance  # Find line on map. This calculation corresponds to a field of view of 90°  pleft  =  Point( ( - cosphi * z  -  sinphi * z)  +  p. x, (  sinphi * z  -  cosphi * z)  +  p. y)  pright  =  Point( (  cosphi * z  -  sinphi * z)  +  p. x, ( - sinphi * z  -  cosphi * z)  +  p. y)  # segment the line  dx  = ( pright. x  -  pleft. x)  /  screen_width  dy  = ( pright. y  -  pleft. y)  /  screen_width  # Raster line and draw a vertical line for each segment  for  i  in  range( 0,  screen_width):  height_on_screen  = ( height  -  heightmap[ pleft. x,  pleft. y])  /  z  *  scale_height.  +  horizon  DrawVerticalLine( i,  height_on_screen,  ybuffer[ i],  colormap[ pleft. x,  pleft. y])  if  height_on_screen  &lt;  ybuffer[ i]:  ybuffer[ i]  =  height_on_screen  pleft. x  +=  dx  pleft. y  +=  dy  # Go to next line and increase step size when you are far away  z  +=  dz  dz  +=  0.2 # Call the render function with the camera parameters: # position, viewing angle, height, horizon line position,  # scaling factor for the height, the largest distance,  # screen width and the screen height parameter Render(  Point( 0,  0),  0,  50,  120,  120,  300,  800,  600 )</p><p>  def渲染（p，phi，高度，地平线，scale_height，距离，screen_width，screen_height）：＃预先平衡视角参数var sinphi = math。罪（PHI）; var cosphi =数学。 cos（phi）; ＃初始化可见性阵列。 Ybuffer = np上的每列的y位置。 Zeros（screen_width）在范围内（0，screen_width）：Ybuffer [i] =屏幕xheight＃从前面绘制到后面（低z坐标为高z坐标）dz = 1. z = 1.而z＆lt;距离＃在地图上查找行。该计算对应于90°PLEFT =点的视场（ - （ -  COSPI * Z  -  SINPHI * Z）+ P. x，（SINPHI * Z  -  COSPI * Z）+ P.Y）PRIGHT = POINT（（Cashi * z  -  sinphi * z）+ p。x，（ -  sinphi * z  -  cashi * z）+ p。y）＃段线dx =（斜视。x  -  pleft。x）/ screen_width dy =（pr。y -  pleft。y）/ screen_width＃栅格线并为i的每个段绘制一个垂直线（0，screen_width）：height_on_screen =（高度 - 高度图[pleft。x，pleft。y]）/ z * scale_height。 + Horizo​​ n DrawVerticalline（I，Height_on_screen，Ybuffer [I]，ColorMap [Pleft.X，Pleft.y]）如果height_on_screen＆lt; YBUFFER [I]：YBUFFER [I] = HEIGHT_ON_SCREEN PLEFT。 x + = dx pleft。 y + = dy＃转到下一行，增加步长z + = dz dz + = 0.2＃呼叫渲染功能与相机参数：＃位置，观察角度，高度，地平线位置，＃缩放适用于高度，最大距离，＃屏幕宽度和屏幕高度参数渲染（点（0,0），0,50,120,120,300,800,600）</p><p>                                                                   The software part of the repository is under the MIT license. Please read the license file for more information. Please keep in mind, that the Voxel Space technology might be still  patented in some countries. The color and height maps are reverse engineered from the game Comanche and are therefore excluded from the license.</p><p>                                                                   存储库的软件部分在MIT许可证下。请阅读许可证文件以获取更多信息。请记住，Voxel Space技术可能在一些国家仍然专利。颜色和高度图是从游戏Comanche的反向设计，因此被排除在许可证之外。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/s-macke/VoxelSpace">https://github.com/s-macke/VoxelSpace</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/space/">#space</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/高度/">#高度</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>