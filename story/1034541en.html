<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>PyPy：以最小的努力获得更快的Python</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">PyPy：以最小的努力获得更快的Python</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-11 22:42:39</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/f2abb100d5f5c39a9098d80fe8dc6d28.jpg"><img src="http://img2.diglog.com/img/2020/11/f2abb100d5f5c39a9098d80fe8dc6d28.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Python is one of the most popular programming languages among developers, but it has certain limitations. For example, depending on the application, it can be up to  100 times as slow as some lower-level languages. That’s why many companies rewrite their applications in another language once Python’s speed becomes a bottleneck for users. But what if there was a way to keep Python’s awesome features and improve its speed? Enter  PyPy.</p><p>Python是最受开发人员欢迎的编程语言之一，但它有一定的局限性。例如，根据应用程序的不同，它的速度可能是某些低级语言的100倍。这就是为什么一旦Python的速度成为用户的瓶颈，许多公司就会用另一种语言重写他们的应用程序。但是，如果有一种方法可以保持Python令人敬畏的特性并提高它的速度，那会怎样呢？输入PyPy。</p><p> PyPy is a very compliant Python interpreter that is a worthy alternative to CPython 2.7, 3.6, and soon 3.7. By installing and running your application with it, you can gain noticeable speed improvements. How much of an improvement you’ll see depends on the application you’re running.</p><p>PyPy是一个非常兼容的Python解释器，是CPython2.7、3.6以及很快的3.7的一个有价值的替代品。通过使用它安装和运行您的应用程序，您可以获得显著的速度提升。您将看到多大程度的改进取决于您正在运行的应用程序。</p><p>  What PyPy’s  features are and how they make your Python code run  faster</p><p>PyPy的功能是什么，以及它们如何让您的Python代码运行得更快。</p><p> The examples in this tutorial use Python 3.6 since that’s the latest version of Python that PyPy is compatible with.</p><p>本教程中的示例使用的是Python 3.6，因为这是与PyPy兼容的最新版本的Python。</p><p>  The Python  language specification is used in a number of implementations such as  CPython (written in C), Jython (written in Java), IronPython (written for .NET), and PyPy (written in Python).</p><p>许多实现都使用了Python语言规范，例如CPython(用C编写)、Jython(用Java编写)、IronPython(用.NET编写)和PyPy(用Python编写)。</p><p> CPython is the original implementation of Python and is by far the most popular and most maintained. When people refer to Python, they more often than not mean CPython. You’re probably using CPython right now!</p><p>CPython是Python的原始实现，也是迄今为止最受欢迎和维护最多的。当人们提到Python时，他们通常指的是CPython。您现在可能正在使用CPython！</p><p> However, because it’s a high-level interpreted language, CPython has certain limitations and won’t win any medals for speed. That’s where PyPy can come in handy. Since it adheres to the Python language specification, PyPy requires no change in your codebase and can offer significant speed improvements thanks to the features you’ll see below.</p><p>然而，因为CPython是一种高级解释型语言，所以它有一定的局限性，不会在速度方面赢得任何奖牌。这就是PyPy可以派上用场的地方。因为它遵循Python语言规范，所以PyPy不需要更改代码库，并且可以显著提高速度，这要归功于您将在下面看到的特性。</p><p> Now, you may be wondering why CPython doesn’t implement PyPy’s awesome features if they use the same syntax. The reason is that implementing those features would require huge changes to the source code and would be a major undertaking.</p><p>现在，您可能想知道，如果CPython和PyPy使用相同的语法，为什么它们不实现PyPy令人惊叹的特性。原因是，实现这些功能需要对源代码进行巨大的更改，这将是一项重大的任务。</p><p>  Your OS may already provide a PyPy package. On macOS, for example, you can install it with the help of  Homebrew:</p><p>您的操作系统可能已经提供了一个PyPy包。例如，在MacOS上，您可以在Homebrew的帮助下安装它：</p><p>  If not, you can  download a prebuilt binary for your OS and architecture. Once you complete the download, it’s just a matter of unpacking the tarball or ZIP file. Then you can execute PyPy without needing to install it anywhere:</p><p>如果没有，您可以下载适用于您的操作系统和体系结构的预构建二进制文件。下载完成后，只需解压tarball或ZIP文件即可。然后，您可以执行PyPy，而无需将其安装在任何位置：</p><p> $ tar xf pypy3.6-v7.3.1-osx64.tar.bz2 $ ./pypy3.6-v7.3.1-osx64/bin/pypy3 Python 3.6.9 (?, Jul 19 2020, 21:37:06) [PyPy 7.3.1 with GCC 4.2.1] Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.</p><p>$tar xf pypy3.6-v7.3.1-osx64.tar.bz2$./pypy3.6-v7.3.1-osx64/bin/pypy3 Python 3.6.9(？，Jul 19 2020，21：37：06)[带有GCC 4.2.1的PyPy 7.3.1]键入&#34；帮助&#34；，&#34；版权&#34；，&#34；信用&#34；或&#34；许可证&#34；获取更多信息。</p><p> Before executing the code above, you need to be inside the folder where you downloaded the binary. Refer to the  installation documentation for the complete instructions.</p><p>在执行上面的代码之前，您需要位于下载二进制文件的文件夹中。有关完整说明，请参阅安装文档。</p><p> You now have PyPy installed and you’re ready to see it in action! To do that, create a Python file called  script.py and put the following code in it:</p><p>现在，您已经安装了PyPy，并且已经准备好看到它的实际应用了！为此，请创建一个名为script.py的Python文件，并在其中放入以下代码：</p><p> 1 total  =  0  2 for  i  in  range ( 1 ,  10000 ):  3  for  j  in  range ( 1 ,  10000 ):  4  total  +=  i  +  j  5  6 print ( f &#34;The result is  { total } &#34; )</p><p>范围(1,10000)内的i合计=0 2：范围(1,10000)内的j的合计为3：4合计+=i+j 5 6打印(f&#34；结果为{合计}&#34；)。</p><p> This is a script that, in two nested   for loops, adds the numbers from  1 to  9,999, and  prints the result.</p><p>这是一个脚本，在两个嵌套的for循环中，将1到9999之间的数字相加，然后打印结果。</p><p> To see how long it takes to run this script, edit it to add the highlighted lines:</p><p>要查看运行此脚本需要多长时间，请编辑它以添加突出显示的行：</p><p> 1  import  time  2  3  start_time  =  time . time ()  4  5 total  =  0  6 for  i  in  range ( 1 ,  10000 ):  7  for  j  in  range ( 1 ,  10000 ):  8  total  +=  i  +  j  9 10  print ( f &#34;The result is  { total } &#34; ) 11 12  end_time  =  time . time () 13  print ( f &#34;It took  { end_time - start_time : .2f }  seconds to compute&#34; )</p><p>1导入时间2 3开始时间=时间。Time()4 5 Total=06 for i in Range(1,10000)：7 for j in Range(1,10000)：8 Total+=i+j 9 10 print(f&#34；结果为{Total}&#34；)11 12 end_time=time。Time()13打印(f&#34；计算花费了{end_time-start_time：.2f}秒)。</p><p>  Line 13 prints the difference between  start_time and  end_time to show how long it took to run the script.</p><p>第13行打印start_time和end_time之间的差值，以显示运行脚本需要多长时间。</p><p> Try running it with Python. This is what I get on my 2015 MacBook Pro:</p><p>尝试使用Python运行它。这是我在我2015年的MacBook Pro上看到的：</p><p>     For more serious benchmarks, you can take a look at the PyPy  Speed Center, where the developers run nightly benchmarks with different executables.</p><p>对于更严肃的基准测试，您可以看看PyPy Speed Center，在那里开发人员每晚都会使用不同的可执行文件运行基准测试。</p><p> Keep in mind that how PyPy affects the performance of your code depends on what your code is doing. There are some situations in which PyPy is actually slower, as you’ll see later. However, on geometric average, it’s 4.3 times as fast as Python.</p><p>请记住，PyPy如何影响代码的性能取决于您的代码正在做什么。在某些情况下，PyPy实际上速度较慢，稍后您将看到这一点。然而，按几何平均计算，它的速度是Python的4.3倍。</p><p> You’ve already seen the second meaning in action by installing PyPy and running a small script with it. The Python implementation you used was written using a dynamic language framework called  RPython, just like CPython was written in C and Jython was written in Java.</p><p>通过安装PyPy并使用它运行一个小脚本，您已经看到了第二个意义。您使用的Python实现是使用名为RPython的动态语言框架编写的，就像CPython是用C编写的，Jython是用Java编写的。</p><p> But weren’t you told earlier that PyPy was written in Python? Well, that’s a little bit of a simplification. The reason PyPy became known as a Python interpreter written in Python (and not in RPython) is that RPython uses the same syntax as Python.</p><p>但您不是早些时候被告知，PyPy是用Python编写的吗？嗯，这有点简单化了。PyPy之所以以用Python(而不是RPython)编写的Python解释器而闻名，是因为RPython使用与Python相同的语法。</p><p>  The  RPython translation toolchain is applied to the code, which basically makes the code more efficient. It also compiles the code down into machine code, which is why Mac, Windows, and Linux users have to download different versions.</p><p>代码中应用了RPython翻译工具链，这从根本上提高了代码的效率。它还将代码编译成机器码，这就是Mac、Windows和Linux用户必须下载不同版本的原因。</p><p> A binary executable is produced. This is the Python interpreter that you used to run your small script.</p><p>产生一个二进制可执行文件。这是您用来运行小脚本的Python解释器。</p><p> Keep in mind that you don’t need to go through all these steps to use PyPy. The executable is already available for you to install and use.</p><p>请记住，使用PyPy不需要经历所有这些步骤。该可执行文件已可供您安装和使用。</p><p> Also, since it’s very confusing to use the same word for both the framework and the implementation, the team behind PyPy decided to move away from this double usage. Now, PyPy refers only to the Python implementation. The framework is referred to as the  RPython translation toolchain.</p><p>此外，由于使用同一个词来表示框架和实现非常令人困惑，所以PyPy背后的团队决定摒弃这种双重用法。现在，PyPy只指Python实现。该框架被称为RPython翻译工具链。</p><p> Next, you’ll learn about the features that make PyPy better and faster than Python in some cases.</p><p>接下来，您将了解在某些情况下使PyPy比Python更好、更快的特性。</p><p> Before getting into what JIT compilation is, let’s take a step back and review the properties of  compiled languages such as C and  interpreted languages such as JavaScript.</p><p>在讨论什么是JIT编译之前，让我们先退一步，回顾一下C等编译语言和JavaScript等解释语言的属性。</p><p> Compiled programming languages are more performant but are harder to port to different CPU architectures and operating systems.  Interpreted programming languages are more portable, but their performance is much worse than that of compiled languages. These are the two extremes of the spectrum.</p><p>编译的编程语言性能更高，但更难移植到不同的CPU架构和操作系统上。解释型编程语言的可移植性更强，但其性能要比编译语言差得多。这是光谱的两个极端。</p><p> Then there are programming languages such as Python that do a mix of both compilation and interpretation. Specifically, Python is first compiled into an  intermediate bytecode, which is then interpreted by CPython. This makes the code perform better than code written in a purely interpreted programming language, and it maintains the portability advantage.</p><p>还有一些编程语言，比如混合了编译和解释的Python。具体地说，Python首先被编译成中间字节码，然后由CPython进行解释。这使得代码比用纯解释型编程语言编写的代码执行得更好，并且保持了可移植性优势。</p><p> However, the performance is still nowhere near that of the compiled version. The reason is that the compiled code can do a lot of optimizations that just aren’t possible with bytecode.</p><p>然而，性能仍然远远不及编译后的版本。原因是编译后的代码可以进行许多字节码无法实现的优化。</p><p> That’s where the  just-in-time (JIT) compiler comes in. It tries to get the better parts of the both worlds by doing some real compilation into machine code and some interpretation. In a nutshell, here are the steps JIT compilation takes to provide faster performance:</p><p>这就是即时(JIT)编译器的用武之地。它试图通过将一些真正的编译成机器代码和一些解释来获得两个世界的更好的部分。简而言之，以下是JIT编译为提供更快性能所采取的步骤：</p><p> Identify the most frequently used components of the code, such as a function in a loop.</p><p>确定代码中最常用的组件，例如循环中的函数。</p><p> Remember the two nested loops at the beginning of the tutorial? PyPy detected that the same operation was being executed over and over again, compiled it into machine code, optimized the machine code, and then swapped the implementations. That’s why you saw such a big improvement in speed.</p><p>还记得教程开头的两个嵌套循环吗？PyPy检测到重复执行相同的操作，将其编译成机器码，优化机器码，然后交换实现。这就是为什么你看到速度有了这么大的提高。</p><p> Whenever you create variables,  functions, or any other objects, your computer allocates memory to them. Eventually, some of those objects will no longer be needed. If you don’t clean them up, then your computer may run out of memory and crash your program.</p><p>无论何时创建变量、函数或任何其他对象，计算机都会为它们分配内存。最终，这些物品中的一些将不再需要。如果您不清理它们，那么您的计算机可能会耗尽内存并使您的程序崩溃。</p><p> In programming languages such as C and C++, you usually have to deal with this problem manually. Other programming languages such as Python and Java do it for you automatically. This is called  automatic garbage collection, and there are several techniques for accomplishing it.</p><p>在C和C++等编程语言中，通常需要手动处理此问题。其他编程语言(如Python和Java)会自动为您完成此操作。这称为自动垃圾收集，有几种技术可以实现它。</p><p> CPython uses a technique called  reference counting. Essentially, a Python object’s reference count is incremented whenever the object is referenced, and it’s decremented when the object is dereferenced. When the reference count is zero, CPython automatically calls the memory deallocation function for that object. It’s a straightforward and effective technique, but there’s a catch.</p><p>CPython使用一种称为引用计数的技术。从本质上讲，每当对象被引用时，Python对象的引用计数就会递增，而当对象被取消引用时，引用计数就会递减。当引用计数为零时，CPython会自动调用该对象的内存释放函数。这是一种简单有效的技术，但有一个问题。</p><p> When the reference count of a large tree of objects becomes zero,  all the related objects are freed. As a result, you have a potentially long pause during which your program doesn’t progress at all.</p><p>当大型对象树的引用计数变为零时，所有相关对象都会被释放。因此，您可能会有一个很长的暂停，在此期间您的程序根本没有进展。</p><p> Also, there’s a use case in which reference counting simply doesn’t work. Consider the following code:</p><p>此外，还有一个引用计数根本不起作用的用例。请考虑以下代码：</p><p>  In the code above, you define new class. Then, you create an instance of the class and assign it to be a property on itself. Finally, you delete the instance.</p><p>在上面的代码中，您定义了新类。然后，创建类的一个实例，并将其分配为自身的属性。最后，删除该实例。</p><p> At this point, the instance is no longer accessible. However, reference counting doesn’t delete the instance from memory because it has a reference to itself, so the reference count is not zero. This problem is called a  reference cycle, and it can’t be solved using reference counting.</p><p>此时，该实例不再可访问。但是，引用计数不会从内存中删除实例，因为它有对自身的引用，因此引用计数不是零。这个问题叫做参考周期，不能用参考计数来解决。</p><p> This is where CPython uses another tool called the  cyclic garbage collector. It walks over all objects in memory starting from known roots like the  type object. It then identifies all reachable objects and frees unreachable objects since they aren’t alive anymore. This solves the reference cycle problem. However, it can create even more noticeable pauses when there are a large number of objects in memory.</p><p>这就是CPython使用另一个称为循环垃圾收集器的工具的地方。它遍历内存中的所有对象，从已知根(如类型对象)开始。然后，它标识所有可到达的对象，并释放无法到达的对象，因为它们不再处于活动状态。这解决了基准周期问题。但是，当内存中有大量对象时，它可能会产生更明显的暂停。</p><p> PyPy, on the other hand, doesn’t use reference counting. Instead, it uses only the second technique, the cycle finder. That is, it periodically walks over alive objects starting from the roots. This gives PyPy some advantage over CPython since it doesn’t bother with reference counting, making the total time spent in memory management less than in CPython.</p><p>另一方面，PyPy不使用引用计数。取而代之的是，它只使用了第二种技术，即周期搜索器。也就是说，它会定期从根开始遍历活动对象。这给了PyPy相对于CPython的一些优势，因为它不会费心进行引用计数，从而使内存管理所花费的总时间比CPython少。</p><p> Also, instead of doing everything in one major undertaking like CPython, PyPy splits the work into a variable number of pieces and runs each piece until none are left. This approach adds just a few milliseconds after each minor collection rather than adding hundreds of milliseconds in one go like CPython.</p><p>此外，PyPy不是像CPython那样在一个主要任务中完成所有工作，而是将工作分成数量可变的部分，并运行每个部分，直到一个都不剩。这种方法在每次较小的收集后只增加几毫秒，而不是像CPython那样一次增加数百毫秒。</p><p> Garbage collection is complex and has many more details that go beyond the scope of this tutorial. You can find more information about PyPy’s garbage collection in the  documentation.</p><p>垃圾收集非常复杂，并且有更多的细节超出了本教程的范围。您可以在文档中找到有关PyPy的垃圾收集的更多信息。</p><p> PyPy isn’t a silver bullet and may not always be the most suitable tool for your task. It may even make your application perform much slower than CPython. That’s why it’s important that you keep the following limitations in mind.</p><p>PyPy不是灵丹妙药，可能并不总是最适合您任务的工具。它甚至可能使您的应用程序的执行速度比CPython慢得多。这就是为什么你必须牢记以下限制的原因。</p><p> PyPy works best with pure Python applications. Whenever you use a  C extension module, it runs much slower than in CPython. The reason is that PyPy can’t optimize C extension modules since they’re not fully supported. In addition, PyPy has to emulate reference counting for that part of the code, making it even slower.</p><p>PyPy最适合纯Python应用程序。无论何时使用C扩展模块，它的运行速度都比在CPython中慢得多。原因是PyPy不能优化C扩展模块，因为它们不是完全支持的。此外，PyPy还必须模拟该部分代码的引用计数，这会使它变得更慢。</p><p> In such cases, the PyPy team recommends taking out the CPython extension and replacing it with a pure Python version so that JIT can see it and do its optimizations. If that’s not an option, then you’ll have to use CPython.</p><p>在这种情况下，PyPy团队建议去掉CPython扩展并将其替换为纯Python版本，以便JIT可以看到它并进行优化。如果这不是一个选项，那么您将不得不使用CPython。</p><p> With that being said, the core team is working on C extensions. Some packages have already been ported to PyPy and work just as fast.</p><p>话虽如此，核心团队正致力于C扩展。有些包已经移植到了PyPy上，运行速度也一样快。</p><p> Imagine you want to go to a shop that is very close to your home. You can either go on foot or drive.</p><p>想象一下，你想去一家离你家很近的商店。你可以步行去，也可以开车去。</p><p> Your car is clearly much faster than your feet. However, think about what it would require you to do:</p><p>你的车显然比你的脚快得多。但是，想一想这需要您做些什么：</p><p>  There’s a lot of overhead involved in driving a car, and it’s not always worth it if the place you want to go is nearby!</p><p>开车要花很多开销，如果你想去的地方就在附近，这并不总是值得的！</p><p> Now think about what would happen if you wanted to go to a neighboring city fifty miles away. It would certainly be worth it to drive there instead of going on foot.</p><p>现在想一想，如果你想去50英里外的邻近城市会发生什么。开车去那里而不是步行去肯定是值得的。</p><p> Although the difference in speed isn’t quite so noticeable as in the above analogy, the same is true with PyPy and CPython.</p><p>尽管速度上的差异不像上面的类比那样明显，但对于PyPy和CPython也是如此。</p><p> When you run a script with PyPy, it does a lot of things to make your code run faster. If the script is too small, then the overhead will cause your script would run slower than in CPython. On the other hand, if you have a long-running script, then that overhead can pay significant performance dividends.</p><p>当您使用PyPy运行脚本时，它会做很多事情来让您的代码运行得更快。如果脚本太小，那么开销将导致脚本的运行速度比CPython慢。另一方面，如果您有一个长时间运行的脚本，那么这种开销可能会带来显著的性能红利。</p><p>  1 import  time  2  3 start_time  =  time . time ()  4  5 for  i  in  range ( 100 ):  6  print ( i )  7  8 end_time  =  time . time ()  9 print ( f &#34;It took  { end_time - start_time : .10f }  seconds to compute&#34; )</p><p>1导入时间2 3开始时间=时间。在(100)范围内i的time()4 5：6 print(I)7 8 end_time=time。Time()9打印(f&#34；计算&#34；花费了{end_time-start_time：.10f}秒)。</p><p> There’s a small delay at the beginning when you run it with PyPy, while CPython runs it instantly. In exact numbers, it takes  0.0004873276 seconds to run it on a 2015 MacBook Pro with CPython and  0.0019447803 seconds to run it with PyPy.</p><p>当您使用PyPy运行它时，一开始会有一个小小的延迟，而CPython会立即运行它。准确地说，在装有CPython的2015年MacBook Pro上运行它需要0.0004873276秒，而在PYPy上运行它需要0.0019447803秒。</p><p> PyPy is a fast and capable alternative to CPython. By running your script with it, you can get a major speed improvement without making a single change to your code. But it’s not a silver bullet. It has some limitations, and you’ll need to test your program to see if PyPy can be of help.</p><p>PyPy是CPython的快速而强大的替代品。通过使用它运行脚本，您可以在不对代码进行任何更改的情况下获得显著的速度提升。但这不是灵丹妙药。它有一些限制，您需要测试您的程序，看看PyPy是否能提供帮助。</p><p>   If your Python script needs a little boost in speed, then give PyPy a try. Depending on your program, you may get some noticeable speed improvements!</p><p>如果您的Python脚本需要稍微提高速度，那么可以尝试一下PyPy。根据您的程序不同，您可能会获得一些显著的速度提升！</p><p> If you have any questions, then feel free to reach out in the comments section below.</p><p>如果你有任何问题，请随时在下面的评论区联系。</p><p> Get a short &amp; sweet  Python Trick delivered to your inbox every couple of days. No spam ever. Unsubscribe any time. Curated by the Real Python team.</p><p>每隔几天，你就会收到一份简短的、甜蜜的巨蟒小把戏，寄到你的收件箱里。从来没有过垃圾邮件。随时取消订阅。由Real Python团队策划。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://realpython.com/pypy-faster-python/">https://realpython.com/pypy-faster-python/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pypy/">#pypy</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/faster/">#faster</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034012.html"><img src="http://img2.diglog.com/img/2020/11/thumb_a270829c58d97b90ea892ae979fa861b.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034012.html">重头开始的Python并发性(2015)[视频]</a></div><span class="my_story_list_date">2020-11-9 20:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033930.html"><img src="http://img2.diglog.com/img/2020/11/thumb_3a1be40609f8294f8c760a1e36d336a5.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033930.html">避免Bash受挫-将Python用于Shell脚本</a></div><span class="my_story_list_date">2020-11-9 4:51</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033316.html"><img src="http://img2.diglog.com/img/2020/11/thumb_21f8be35cef4397449ea9dd55e0aa657.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033316.html">Python取代Java成为第二大最受欢迎的编程语言</a></div><span class="my_story_list_date">2020-11-5 20:25</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032893.html"><img src="http://img2.diglog.com/img/2020/11/thumb_64d2ec6863c7815afccdaaa0cf416c51.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032893.html">使用VizTracer可视化Python代码执行</a></div><span class="my_story_list_date">2020-11-3 10:14</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>