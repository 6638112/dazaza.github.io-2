<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>面向对象的Amiga Exec（1991） The Object-Oriented Amiga Exec (1991)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Object-Oriented Amiga Exec (1991)<br/>面向对象的Amiga Exec（1991） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-21 07:35:39</div><div class="page_narrow text-break page_content"><p>So what&#39;s missing from the Amiga operating system that makes it so small? How does the Amiga manage to provide multitasking and windowing services in less than one-half tc one-fourth the memory that Apple and IBM computers need? The answer lies in  minimal redandancy.  If you examine the internal structure of many popular operating systems, you&#39;ll discover that it&#39;s &#34;OS versus them.&#34; That is, you have this somewhat monolithic block of stuff that is the core operating system, some additional voodoo acting as device drivers and the like, and applications code--and only an uneasy truce ever lets them meet. Even though the operating system may itself be composed of many components, its appearance to the applications programmer is still essentially as a rather mysterious edifice, beyond which only selected portions of applications software may go.</p><p>那么，使Amiga变得如此小的操作系统缺少什么呢？ Amiga如何在不到苹果公司和IBM计算机所需内存的四分之一的四分之一的时间内提供多任务和窗口服务？答案在于最大程度的裁员。如果检查许多流行的操作系统的内部结构，就会发现它是OS与它们的比较。就是说，您拥有一块有点单片的东西，它是核心操作系统，一些充当设备驱动程序的伏都教等等，以及应用程序代码-只有不轻松的停战才能让他们见面。即使操作系统本身可能由许多组件组成，但对于应用程序程序员来说，它的外观本质上仍然是一个相当神秘的建筑，超出该范围之后，只有应用程序软件的选定部分才可以使用。</p><p> The Amiga operating system is different. Relatively few parts of it are totally opaque; in fact, with later revisions of the operating system, the trend has been to further open its internals for applications use. This is even more surprising considering that, unlike the Macintosh, the Amiga runs its applications in the nonprivileged state.</p><p> Amiga操作系统不同。相对来说，很少部分是完全不透明的；实际上，随着操作系统的更高版本，趋势是进一步开放其内部供应用程序使用。考虑到与Macintosh不同，Amiga在非特权状态下运行其应用程序，这更加令人惊讶。</p><p>  No Magic Most present-day operating systems operate as if the operating system code is &#34;magic&#34;; that is, it spends most of its time running in privileged states, inhibiting interrupts, executing arcane instructions that are incomprehensible to mere mortal applications programmers, and otherwise doing things that are completely outside the scope of applications programming. That isn&#39;t really true.</p><p>  没有魔力当今大多数操作系统都以操作系统代码为＆＃34; magic＆＃34 ;;的方式运行。也就是说，它花费了大部分时间在特权状态下运行，禁止中断，执行普通应用程序程序员难以理解的奥术指令，或者执行完全超出了应用程序编程范围的事情。这不是真的。</p><p> Very little operating-system code is truly magic; most of it deals with managing tables, lists, queues, and other such mundane tasks. However, since these are operating-system tables lists, queues, and so forth, they are generally managed with special routines that run in privileged, noninterruptible, memory-managed, or otherwise arcane environments.</p><p> 很少有操作系统代码是真正的魔术。它大部分处理表，列表，队列和其他此类普通任务的管理。但是，由于这些是操作系统表列表，队列等，因此通常使用在特权，不间断，内存管理或其他神秘环境中运行的特殊例程来管理它们。</p><p> What tends to be overlooked is that it is often possible to take all the &#34;magical&#34; parts of code and separate them from the &#34;nonmagical&#34; parts, resulting in a set of controlling routines to switch modes, and a lot of data-handling routines that look suspiciously similar.</p><p> 往往被忽视的是，通常有可能把所有“魔法”都带走。部分代码，并将其与＆＃34; nonmagical＆＃34;分开部件，从而产生了一组用于切换模式的控制例程，以及许多看起来可疑的数据处理例程。</p><p> This situation means that, first, there exists the possibility that general-purpose versions of some of these routines can be created to replace all these similar-but-not-identical functions; and second, since these routines are no longer magic, they can be accessible to application programs as well, reducing their overall size and complexity, to say nothing of the time saved by using pre-debugged code.</p><p> 这种情况意味着，首先，存在这样的可能性：可以创建其中一些例程的通用版本来替换所有这些相似但不相同的功能；其次，由于这些例程不再是魔术，因此应用程序也可以访问它们，从而减小了它们的整体大小和复杂性，更不用说使用预先调试的代码节省的时间了。</p><p> Using general-purpose code for critical operating-system functions might seem like heresy to some--after all, aren&#39;t &#34;general-purpose&#34; and &#34;efficient&#34; mutually exclusive? The answer appears to be no, or more accurately, &#34;If it&#39;s general-purpose and it&#39;s not efficient, perhaps it&#39;s not general-purpose enough.&#34; What usually wastes time in general-purpose code is all the testing and branching that it has to do to handle the variations of data structures it processes.</p><p> 对某些关键的操作系统功能使用通用代码似乎有些杂乱无章-毕竟，这不是通用的。和＆＃34; efficiency＆＃34;互斥？答案似乎是否定的，或更准确地说，如果它是通用的并且效率不高，那么也许它的通用性还不够。在通用代码中通常会浪费时间的是它为处理其处理的数据结构的变化而必须进行的所有测试和分支。 </p><p> Where does OOP come into all this? The answer lies in the principle of inheritance. By arranging the system data structures much as we did for system code in traditional systems and by placing related data items in a common sequence, we gain two advantages: a reduction in the amount of special-case processing that was so offensive, and the creation of a hierarchy of data object classes. As a side effect, the system becomes easier to understand--there are fewer unique functions.</p><p>OOP会在哪里出现？答案在于继承原则。通过像我们在传统系统中对系统代码所做的那样安排系统数据结构，并将相关数据项放在一个公共序列中，我们获得了两个好处：减少了令人反感的特殊情况处理量，以及创建了数据对象类的层次结构。副作用是，系统变得更易于理解-独特功能更少。</p><p>  An Inside View Exec, as mentioned earlier, is the nucleus (or kernel) of the Amiga operating system, and it is realized in just such a manner. Exec consists of a collection of increasingly complex object classes, as can be seen in figure 1. When a new Exec object class is defined based on a simpler class, it contains all the data objects of the simpler class and also is (usually) valid for not only operations defined for that class, but for all operations pertaining to the simpler class, as well. This is known as function  inheritance.</p><p>  如前所述，Inside View Exec是Amiga操作系统的核心（或内核），可以通过这种方式实现。 Exec由越来越复杂的对象类组成，如图1所示。当基于一个更简单的类定义一个新的Exec对象类时，它包含该更简单类的所有数据对象，并且（通常）有效不仅适用于为该类定义的操作，还适用于与较简单类有关的所有操作。这称为函数继承。</p><p>    Figure 1:  The nucleus of the Amiga&#39;s operating system consists of a collection of increasingly complex object classes. Exec&#39;s heavy reliance on inheritance is what makes it so compact. It does not contain separate sets of routines to manipulate tasks, I/O devices, intertask messages, and so on; instead, it contains basic routines to handle collections of objects--be they task objects, device objects, or whatever--and adds functions only where additional support is required. In contrast, many operating systems contain a collection of task routines (including those required to manage the task table) and a collection of device routines (including those required to manage the device table), and so forth.</p><p>    图1：Amiga操作系统的核心由一系列日益复杂的对象类组成。 Exec对继承的高度依赖使得继承如此紧凑。它不包含用于处理任务，I / O设备，任务间消息等的单独例程集；相反，它包含处理对象集合的基本例程（无论是任务对象，设备对象还是其他对象），并且仅在需要其他支持的情况下才添加功能。相反，许多操作系统包含任务例程的集合（包括管理任务表所需的例程）和设备例程的集合（包括管理设备表所需的例程），等等。</p><p>  There are many ways to represent collections of data internally, each with its own advantages and disadvantages. Exec is based on the doubly linked list. The list elements are allocated dynamically from anywhere in RAM that&#39;s convenient (see the section on memory management); therefore, there are no tables to fill up. On the other hand, access speed is highly dependent on the number of nodes in the list, but there are ways to reduce that problem, as I&#39;ll explain later.</p><p>  有很多内部表示数据收集的方法，每种方法都有其优点和缺点。 Exec基于双向链表。列表元素是从RAM中任何方便的地方动态分配的（请参阅内存管理部分）；因此，没有表格可以填写。另一方面，访问速度高度依赖于列表中的节点数，但是有减少该问题的方法，这将在后面解释。</p><p> The Amiga operating system distinguishes itself in that the operating system itself provides support for doubly linked lists. Exec supports two levels of lists: lists and MinLists. (The Lattice C++ implementation adds two more that are similar to the standard Exec lists, but without automatic initialization.) These are used to define items that the Amiga system software initializes.</p><p> Amiga操作系统与众不同之处在于，操作系统本身为双链表提供了支持。 Exec支持两个级别的列表：列表和MinLists。 （Lattice C ++实现增加了两个与标准Exec列表类似的功能，但没有自动初始化。）它们用于定义Amiga系统软件初始化的项目。</p><p> The MinList is the anchor to a doubly linked list of MinNodes. MinNodes contain next and previous MinNode pointers. The MinList structure contains a pair of dummy MinNodes to simplify processing by reducing special-case logic required to process items at the ends of the list. An empty MinList always consists of two MinNodes--the dummy nodes at the front and the end of the MinList--both of which are contained  within the MinList data structure itself. The dummy front node&#39;s next-node pointer points to the actual first node of the list. Its previous-node pointer is always NULL.</p><p> MinList是MinNodes双向链接列表的锚点。 MinNode包含下一个和上一个MinNode指针。 MinList结构包含一对伪MinNode，以通过减少处理列表末尾项目所需的特殊情况逻辑来简化处理。空的MinList始终由两个MinNode组成-MinList的前端和末尾的虚拟节点-这两个都包含在MinList数据结构本身中。虚拟前节点的下一个节点指针指向列表的实际第一个节点。它的上一个节点指针始终为NULL。</p><p> A similar situation exists in regard to the dummy end node. Since the dummy front node&#39;s previous-node pointer is always NULL and the dummy end node&#39;s next-node pointer is also always NULL, it was possible to save a small amount of memory by making them overlap by sharing the same NULL pointer. Dummy MinNodes do add one complication: The last actual item of the list is not the one with the NULL next-node pointer: That honor belongs to the dummy node.</p><p> 关于虚拟端节点，存在类似情况。由于虚拟前端节点的上一个节点指针始终为NULL，而虚拟末端节点的下一个节点指针也始终为NULL，因此可以通过共享使它们重叠来节省少量内存相同的NULL指针。虚拟MinNode确实增加了一个复杂性：列表的最后一个实际项不是具有NULL下一节点指针的项：该荣誉属于虚拟节点。 </p><p>  A complete set of functions exists to support insertion and deletion of MinNodes at either end--or points in between--of a MinList. By using the proper functions, therefore, a MinList can be used as a first-in/first-out (FIFO) (also known as a queue) or as a last-in/first-out (LIFO) (also known as a stack), as well as a general-purpose list.</p><p>存在一套完整的功能来支持在MinList的两端（或两端）之间插入和删除MinNode。因此，通过使用适当的功能，MinList可以用作先进先出（FIFO）（也称为队列）或先进先出（LIFO）（也称为后进先出）。堆栈），以及通用列表。</p><p>  Once again, note that there is nothing magical about MinLists, MinNodes, or any of the functions that act on them. Although they are extensively used by the Amiga operating system, they can be used just as freely in any application program.</p><p>  再一次，请注意，MinList，MinNode或作用于它们的任何功能都没有神奇之处。尽管它们被Amiga操作系统广泛使用，但它们可以在任何应用程序中自由使用。</p><p>  Friends and Members A note about C++  friend and  member functions. When a class is defined in C++, its internal components are (unless otherwise specified) protected from casual access. This is a strong selling point; it makes it harder for an object&#39;s innards to be corrupted and easier to locate the responsible function. To make practical use of (and to alter) the information within a class object, therefore, some sort of access mechanism is required. C++ provides two: a friend function, which is like a traditional C function, except that by having been declared a friend of one or more classes, it is allowed to directly access the data stored within that class or classes, and a member function which is actually owned by a specific class and therefore has an &#34;invisible&#34; extra parameter passed to it: &#34;this,&#34; which is a pointer to the class object being acted on.</p><p>  朋友和成员关于C ++朋友和成员函数的说明。当用C ++定义一个类时，（除非另外指定）它的内部组件受到保护，以防止随意访问。这是一个很强的卖点。它使对象的内部损坏变得更加困难，并且更容易找到负责的功能。因此，为了实际使用（和更改）类对象中的信息，需要某种访问机制。 C ++提供了两种：朋友函数，类似于传统的C函数，不同之处在于，通过被声明为一个或多个类的朋友，可以直接访问存储在该一个或多个类中的数据，以及成员函数实际上是由特定类别拥有的，因此具有＆＃34; invisible＆＃34;传递给它的额外参数：＆＃34; this，＆＃34;这是作用于该类对象的指针。</p><p> Exec was designed to be used by non-OOP languages; thus the Exec functions are, in effect, friend functions. The  #include files made up by MTS Associates to support C++ on the Amiga generally define them as such. However, to better support Exec in its capacity as an object-oriented system, a number of member functions were also defined. For example, virtually every object in the Amiga is in some sort of list, so most objects have a member function named  next(). No matter what it is, no matter how it&#39;s linked, and no matter what the name or relative location of the object&#39;s next-item pointer, you are thus always guaranteed that you can get a pointer to the next one in the list by using the next ( ) function.</p><p> Exec设计用于非OOP语言；因此，Exec函数实际上是朋友函数。由MTS Associates组成的，用于在Amiga上支持C ++的#include文件通常是这样定义的。但是，为了更好地支持Exec作为面向对象系统，它还定义了许多成员函数。例如，实际上Amiga中的每个对象都在某种列表中，因此大多数对象都有一个名为next（）的成员函数。不管它是什么，无论它是如何链接的，以及该对象的下一个项目指针的名称或相对位置如何，都始终保证可以得到指向该对象的指针。使用next（）函数在列表中的下一个。</p><p>  Lists: MinLists and Then Some A list is an extended MinList, made up of nodes. The nodes are MinNodes plus a 1-byte type field, a 1-byte priority, and a pointer to the node&#39;s name, which is a C-format string. Figure 2 shows the structure of a node. A node incorporates the structure of a MinNode, and thus automatically inherits the properties of a MinList to form a list.</p><p>  列表：MinList，然后是Some列表是扩展的MinList，由节点组成。节点是MinNodes，外加一个1字节的类型字段，一个1字节的优先级和一个指向节点名称的指针，该名称是C格式的字符串。图2显示了节点的结构。节点合并了MinNode的结构，因此自动继承了MinList的属性以形成列表。</p><p> Subsequently, a list can use all the MinList functions. A list can be maintained as a FIFO or LIFO, just like a MinList. However, a list can also be maintained in priority sequence courtesy of the list friend function  Enqueue( ). If the nodes in the list are given names, it is also possible to search the list for the first/next node of that name. This can be very useful, as it&#39;s how Exec locates a number of public objects.</p><p> 随后，列表可以使用所有MinList函数。就像MinList一样，列表可以维护为FIFO或LIFO。但是，也可以通过列表好友函数Enqueue（）优先维护列表。如果为列表中的节点指定了名称，则还可以在列表中搜索该名称的第一个/下一个节点。这可能非常有用，因为这是Exec定位多个公共对象的方式。</p><p>  Signals Signals are represented by a 32-bit word containing a pattern of signal flags. There are 16 that are allocatable to the user and 16 reserved by the operating system. When a task signals another task and the other task is in a signal wait state, the receiving task&#39;s incoming signal information has the incoming signal bits logically ORed in. This is then ANDed with the recipient task&#39;s pattern of signals that it is waiting on. A nonzero result causes the task to become dispatchable.</p><p>  信号信号由包含信号标记模式的32位字表示。用户可以分配16个，操作系统保留16个。当一个任务发出信号通知另一个任务并且另一个任务处于信号等待状态时，接收任务的传入信号信息将传入信号位进行逻辑或运算。然后，将其与接收者任务的模式进行“与”运算表示它正在等待。非零结果导致任务变得可调度。 </p><p> This is an extremely efficient way to activate a sleeping task and it can be done at any system level, including in interrupt routines, which are denied many of the more sophisticated system services.</p><p>这是激活睡眠任务的一种非常有效的方法，可以在任何系统级别（包括在中断例程中完成）执行，许多较复杂的系统服务都无法使用中断例程。</p><p>  Messages Figure 3 shows how a message is constructed from a node. Messages are extremely important in the operation of the Amiga. They are used to pass information from task to task, as the basis for I/O requests, and as the medium of transfer for Intuition&#39;s mouse and window events. Unlike a signal, which can merely give an &#34;I&#39;m here!&#34; indication, a message can have complex information piggybacked on it.</p><p>  消息图3显示了如何从节点构造消息。信息在Amiga的操作中极为重要。它们用于将信息从一个任务传递到另一个任务，作为I / O请求的基础，并作为Intuition鼠标和窗口事件的传输媒介。与信号不同的是，信号只能在此处给出“！”！指示，一条消息可能带有复杂的信息。</p><p> Figure 2:  Nodes can be located by name and arranged in priority order. Nodes are anchored by lists. Since a node incorporates a MinNode, it inherits all the list properties and functions.</p><p> 图2：可以按名称定位节点，并按优先级排列。节点由列表锚定。由于节点包含一个MinNode，因此它将继承所有列表属性和功能。</p><p> Figure 3:  The Amiga operating system uses &#34;messages&#34; to pass information from task to task, as the basis for 1/0 requests, and as the medium of transfer for Intuition &#39;s mouse and window events. A message incorporates a node and therefore inherits all its properties and functions.</p><p> 图3：Amiga操作系统使用＆＃34; messages＆＃34;以将信息从一个任务传递到另一个任务，以此作为1/0请求的基础，并作为Intuition鼠标和窗口事件的传输媒介。消息包含一个节点，因此将继承其所有属性和功能。</p><p> Figure 4:  A message is transmitted to a message port, which contains a list of incoming messages to be serviced, in priority order. Like messages, message ports incorporate a node and therefore inherit all the properties and functions of a node.</p><p> 图4：一条消息按优先级顺序传输到消息端口，该端口包含要服务的传入消息的列表。像消息一样，消息端口包含一个节点，因此继承了节点的所有属性和功能。</p><p> A message is an extended node and is usually transmitted to a message port (MsgPort), another type of node that contains a list of incoming messages to be serviced, in priority order (see figure 4). MsgPorts can be private and anonymous, or they can be added to the system message port list. Frequently, they occur in pairs (one of each), since after a message is serviced, it is common to forward it to a reply MsgPort, where it is generally recycled or discarded--although it is possible to bounce a message through a whole series of ports. There are several different ways to implement a MsgPort, but the most common way is supported by a special C++ class named the StdPort--or standard message port--which can be created and initialized by coding</p><p> 消息是扩展节点，通常以优先级顺序传输到消息端口（MsgPort），这是另一类节点，其中包含要服务的传入消息的列表（请参见图4）。 MsgPorts可以是私有的也可以是匿名的，也可以将它们添加到系统消息端口列表中。通常，它们成对出现（每对一个），因为在处理完一条消息后，通常将其转发到MsgPort答复，在此通常将其回收或丢弃-尽管可以将消息整体退回系列端口。有几种不同的方法来实现MsgPort，但是最常见的方法由名为StdPort的特殊C ++类（或标准消息端口）支持，可以通过编码来创建和初始化</p><p> StdPort *listener = new StdPort ( &#34;I hear you&#34; ) ;  The StdPort constructor takes care of all the details of standard MsgPort initialization. Memory is allocated and initialized, and a signal is acquired on which the listening task can wait. Using the AddPort function, the MsgPort can be put on the system&#39;s public MsgPort list, where it can be found by any task that wishes to send it a message. Because Exec was designed in an object-oriented manner, the new operating-system functions are quite simple. A C++ reconstruction shows the following:</p><p> StdPort *侦听器=新的StdPort（＆＃34;我听到你了＆＃34;）; StdPort构造函数负责标准MsgPort初始化的所有详细信息。内存被分配和初始化，并获取一个信号，监听任务可以等待。使用AddPort函数，可以将MsgPort放置在系统的公共MsgPort列表中，任何希望向其发送消息的任务都可以在该列表中找到该MsgPort。因为Exec是按面向对象的方式设计的，所以新的操作系统功能非常简单。 C ++重构显示以下内容： </p><p>  void AddPort ( MsgPort *mport ) { Forbid( ) ; // disable task-switching  Enqueue ( AbsExecBase-&gt;PortList, mport ) ;  Enable( ) ; // re-enable task-switching }  Here&#39;s a reconstruction of another system function:   MsgPort * FindPort ( const char *portname ) {return ( MsgPort *)     AbsExecBase-&gt;PortList.find ( portname ) ; }   FindPort illustrates another important design feature. If you searched a system list every time you wanted to access an element in that list, system performance would suffer. Instead, the convention is to search and return the object&#39;s address. Thereafter, the object&#39;s address can be used directly (the Amiga does not use Macintosh-style handles, which cause objects to shift about in memory). The downside of that is that you must never move or remove an object that other tasks may be using. Libraries and devices ensure this by maintaining a user count. For simple message ports, the application should either enforce a log-in/log-out facility or else require that all messages be sent on a one-shot basis (i.e.,  FindPort / PutMsg).</p><p>无效AddPort（MsgPort * mport）{Forbid（）; //禁用任务切换入队（AbsExecBase-＆gt; PortList，mport）;使能够（ ） ; //重新启用任务切换}这是另一个系统功能的重构：MsgPort * FindPort（const char * portname）{返回（MsgPort *）AbsExecBase-＆gt; PortList.find（portname）; } FindPort说明了另一个重要的设计功能。如果每次要访问列表中的元素时都搜索系统列表，则系统性能会受到影响。相反，约定是搜索并返回对象的地址。此后，可以直接使用对象的地址（Amiga不使用Macintosh风格的句柄，这会导致对象在内存中移动）。不利的一面是，您绝不能移动或移除其他任务可能正在使用的对象。库和设备通过维护用户数量来确保这一点。对于简单的消息端口，应用程序应强制执行登录/注销功能，或者要求所有消息必须一次性发送（即FindPort / PutMsg）。</p><p> Each task is limited to a maximum of 32 distinct signals but can have an unlimited number of MsgPorts. The same signal can be used by more than one MsgPort, which is what keeps Intuition tasks from being limited to a finite number of open windows.</p><p> 每个任务最多只能有32个不同的信号，但可以有无限数量的MsgPort。同一信号可以被多个MsgPort使用，这使Intuition任务不受限于有限数量的打开窗口。</p><p>  If you examine the  internal structure of many popular  operating systems, you&#39;11 discover  that it&#39;s &#34;0S versus them.&#34;</p><p>  如果检查许多流行的操作系统的内部结构，您会发现它与它们相比是0S。</p><p>  IORequests IORequests are extended messages that include I/O control and transfer information sent to devices. A basic set of commands (read, write, control, and so on) is common to all IORequests; for a given device, additional extensions can be added as needed. A number of special-purpose device IORequest classes have been derived; any device implementer is at liberty to derive his or her own extensions as needed. It&#39;s fairly common to end up with something like the following:</p><p>  IORequests IORequests是扩展的消息，包括I / O控制和传送到设备的传输信息。所有IORequest都具有一组基本的命令（读，写，控制等）。对于给定的设备，可以根据需要添加其他扩展。派生了许多专用设备的IORequest类。任何设备实现者都可以根据需要自由派生自己的扩展。出现类似以下内容的情况很常见：</p><p> MyDeviceRequest is based on:   StdIORequest is based on:   IORequest is based on:   Message is based on:     Node is based on:        MinNode  With each level of inheritance, you gain additional properties and functions. The only new code required is that which supports your own unique class of object.</p><p> MyDeviceRequest是基于：StdIORequest是基于：IORequest是基于：消息是基于：Node是基于：MinNode在继承的每个级别上，您都可以获得其他属性和功能。唯一需要的新代码就是支持您自己独特的对象类的代码。</p><p>  Libraries Another important type of node is the library. It consists of a base structure, preceded by function vectors and followed by optional private storage. There is a set of basic functions (e.g., open, close, and expunge) common to all libraries. Beyond that, the designer is free to add functionality at will.</p><p>  库节点的另一种重要类型是库。它由一个基本结构组成，后面是功能向量，然后是可选的私有存储。所有库都有一组通用的基本功能（例如，打开，关闭和删除）。除此之外，设计人员可以随意添加功能。</p><p>  Unlike most operating systems, the Amiga operating system does not use software interrupts or illegal instruction traps to provide operating-system services. Instead, there is a master library, named exec.library, located in the ROM kernel. All the fundamental system functions--the list primitives, memory management, functions to load and open libraries (the libraries&#39; own internal initialization and open routines are called from this)--are defined here. The only immutable part of the operating system is absolute memory location 4, which points to the Exec library structure (ExecBase). The data portion of ExecBase contains the fundamental Exec structures, including the list definitions for the system message ports, libraries, devices, and tasks.</p><p>  与大多数操作系统不同，Amiga操作系统不使用软件中断或非法指令陷阱来提供操作系统服务。相反，在ROM内核中有一个名为exec.library的主库。此处定义了所有基本系统功能-列表原语，内存管理，加载和打开库的功能（从库中调用内部拥有的内部初始化和打开例程）。操作系统唯一不变的部分是绝对内存位置4，它指向Exec库结构（ExecBase）。 ExecBase的数据部分包含基本的Exec结构，包括系统消息端口，库，设备和任务的列表定义。 </p><p> It&#39;s interesting to compare Exec libraries with the dynamic link libraries used by OS/2 and Microsoft Windows. DLLs support sets of functions, but they provide additional services as well. The Intel 286 and subsequent chips support the concepts of different levels (rings) of security. If you don&#39;t hold the requisite minimum security level, a request will fail. DLL function dispatching can cause security-level switching. The Motorola 68000-series equivalent of this is the Module Call facility. It, however, requires at least a 68020 microprocessor unit and preferably a paged memory management unit. AmigaDOS runs on all 68000s, so the only security levels inherently available are due to the fact that AmigaDOS programs run by the default user state, whereas the operating system runs in supervisor state, as required.</p><p>将Exec库与OS / 2和Microsoft Windows使用的动态链接库进行比较很有趣。 DLL支持功能集，但它们也提供其他服务。英特尔286及后续芯片支持不同级别（环）的安全性概念。如果您不具备必需的最低安全级别，则请求将失败。 DLL函数分派可能导致安全级别切换。相当于Motorola 68000系列的模块调用功能。但是，它至少需要68020微处理器单元，最好是页面存储器管理单元。 AmigaDOS可在所有68000上运行，因此固有的唯一安全级别是由于AmigaDOS程序以默认用户状态运行，而操作系统根据需要以超级用户状态运行。</p><p>  There are pros and cons to both approaches. Since Exec libraries are essentially simple vector tables, the overhead of calling library functions is barely higher than when the function is resident in the calling program (much less than a software interrupt), instead of being shared system code. On the other hand, a carefully designed DLL, while incurring a small speed penalty, is more immune to damage from programs that have run amok.</p><p>  两种方法都各有利弊。由于Exec库本质上是简单的向量表，因此调用库函数的开销仅比驻留在调用程序中的函数（而不是软件中断）多，而不是驻留在共享系统代码中，这仅比后者高。另一方面，精心设计的DLL在造成较小的速度损失的同时，更不会受到已经运行的程序的破坏。</p><p> Note that DLLs are extensions to the Microsoft operating systems; the basic system functions are still software-interrupt driven. Hence, there has to be logic for both kinds of library interfaces. Amiga libraries, however, not only provide a single interface, but they are immune to the problem inherent to all software interrupts--there&#39;s only a finite number of them, which never seems to be enough for practical purposes. Libraries, on the other hand, are not only &#34;infinitely&#34; expandable, but it is a straightforward task to create new ones that are indistinguishable from the built-in ones--or even to completely override a built-in one by inserting a new library of the same name at a higher priority on the system library list.</p><p> 请注意，DLL是Microsoft操作系统的扩展。基本系统功能仍由软件中断驱动。因此，两种库接口都必须具有逻辑。但是，Amiga库不仅提供单个接口，而且不受所有软件中断固有的问题的影响-仅有有限数量的中断，对于实际目的而言似乎还远远不够。另一方面，图书馆不仅是“无限”的。可扩展，但是创建与内置文件没有区别的新文件或通过以更高优先级在系统库上插入同名新库甚至完全覆盖内置文件是一项简单的任务列表。</p><p>    The library concept is itself extended; it forms the basis for an I/O device by adding a few standard functions. Most devices work via extended messages, called IORequests. There are also extensions to these extensions (such as the StdIORequest), as well as customized extensions for specific devices. Devices typically also possess one or more tasks so that I/O can be done asynchronously, although this is not mandatory.</p><p>    图书馆的概念本身得到了扩展。通过添加一些标准功能，它构成了I / O设备的基础。大多数设备通过称为IORequests的扩展消息工作。这些扩展也有扩展（例如StdIORequest），以及针对特定设备的自定义扩展。设备通常还具有一个或多个任务，因此I / O可以异步完成，尽管这不是强制性的。</p><p> There is another, less-understood extension to the library, called the resource. A resource essentially acts as a coordinator for shared resources (generally hardware), such as the different drives on a disk controller, or the serial and parallel I/O ports (whicb are implemented on the same chips).</p><p> 该库还有另一个鲜为人知的扩展，称为资源。资源本质上充当共享资源（通常是硬件）（例如磁盘控制器上的不同驱动器）或串行和并行I / O端口（whicb在同一芯片上实现）的协调器。</p><p>  Tasks The task structure is yet another node. This one contains all the definitions required to make Exec a fully functional, preemptive, priority-driven, multitasking operating system. A task is roughly equivalent to an OS/2 thread. An extended task, known as a process, provides additional information to permit use of the AmigaDOS functions defined in the library named dos.library--chiefly such things as Unix-like I/O services, program loading capabilities, and the like.</p><p>  任务任务结构是另一个节点。这其中包含使Exec成为功能齐全，可抢占，优先级驱动，多任务操作系统的所有定义。任务大致等效于OS / 2线程。扩展的任务（称为进程）提供了附加信息，以允许使用名为dos.library的库中定义的AmigaDOS函数-主要是诸如类Unix的I / O服务，程序加载功能等。</p><p> Exec&#39;s task scheduler is not as elaborate as OS/2&#39;s, which is rumored to have been lifted bodily from IBM&#39;s VM/370 mainframe operating system. The OS/2 dispatcher dynamically adjusts task priorities based on certain algorithms that are in the &#34;magic&#34; part of the operating system. While this is impressive, it&#39;s doubtful</p><p> Exec的任务调度程序不如OS / 2复杂，据传OS / 2是从IBM的VM / 370大型机操作系统上物理提升的。 OS / 2调度程序根据“魔术”中的某些算法动态调整任务优先级。操作系统的一部分。虽然令人印象深刻，但值得怀疑 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://web.archive.org/web/20050528204702/http://www.cunningham-lee.com/misc/amiga_exec.html">http://web.archive.org/web/20050528204702/http://www.cunningham-lee.com/misc/amiga_exec.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/amiga/">#amiga</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/oriented/">#oriented</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/列表/">#列表</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>