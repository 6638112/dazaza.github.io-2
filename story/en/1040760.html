<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>PC引擎/ TurboGrafx-16架构–实用分析 PC Engine / TurboGrafx-16 Architecture – A Practical Analysis</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">PC Engine / TurboGrafx-16 Architecture – A Practical Analysis<br/>PC引擎/ TurboGrafx-16架构–实用分析 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-20 00:44:33</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/412903ab5e56b72e6856860be440e66b.png"><img src="http://img2.diglog.com/img/2020/12/412903ab5e56b72e6856860be440e66b.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Hudson and NEC joined forces to kickstart the 4th generation of consoles. Unfortunately, their efforts will be eventually eclipsed once the competition arrives. Nonetheless, their console will stay on the top as one of the most compact designs in the market.</p><p>哈德森和NEC联手启动了第四代游戏机。不幸的是，一旦比赛到来，他们的努力最终将黯然失色。尽管如此，它们的控制台仍将成为市场上最紧凑的设计之一。</p><p>   Just like the Master system, NEC shipped a lot of revisions and strange variations which can be a bit troubling to follow at first. So, for future reference, here are the most important models:</p><p>   就像Master系统一样，NEC发行了许多修订版和奇怪的变体，一开始可能有些麻烦。因此，以下是最重要的模型，以供将来参考：</p><p> PC Engine: The first console featuring this architecture, but only released in Japan. It looks like a small white box with minimal ports.</p><p> PC引擎：第一个具有此体系结构的控制台，但仅在日本发布。它看起来像一个带有最少端口的白色小盒子。</p><p> TurboGrafx-16: Redesigned PC Engine for the American market. It has the same features with a different external appearance. Reminds me of the  NES/Famicom adaptation.</p><p> TurboGrafx-16：针对美国市场重新设计的PC引擎。它具有相同的功能，但外观不同。让我想起了NES / Famicom改编版。</p><p> Supergrafx: Enhanced version of the PC Engine with a completely different case and new hardware. Its exclusive features are out of the scope of this article.</p><p> Supergrafx：PC引擎的增强版，具有完全不同的外壳和新硬件。它的独有功能不在本文讨论范围之内。</p><p> This article will focus on the PC Engine/TurboGrafx-16, but will also discuss the expansions that led to the release of the PC Engine Duo/TurboDuo.</p><p> 本文将重点讨论PC Engine / TurboGrafx-16，但还将讨论导致PC Engine Duo / TurboDuo发行的扩展。</p><p>   Inside this console, we find the  HuC6280, a chip made by  Hudson Soft that houses two components. One of them is the CPU, which can operate at two speeds:  ~1.79 MHz and  ~7.16 MHz.</p><p>   在此控制台中，我们找到了HuC6280，这是由Hudson Soft生产的芯片，其中包含两个组件。其中之一是CPU，它可以两种速度运行：〜1.79 MHz和〜7.16 MHz。 </p><p> The HuC6280 is not an off-the-shelf component, like the  Z80, but instead a proprietary CPU designed by NEC. After checking out the official docs, it does seem to replicate a lot of behaviour from the famous  MOS 6502 and  Western Digital’s 65C02. That being said, what does all of this mean for the programmer?</p><p>HuC6280不是像Z80那样的现成组件，而是NEC设计的专有CPU。在查看了官方文档后，它似乎确实复制了著名的MOS 6502和Western Digital的65C02的许多行为。话虽如此，这对程序员意味着什么？</p><p> Before we start, we’ve already covered some parts of the MOS 6502  here and also described a 16-bit variant made by Western Digital and Ricoh  here, in case you want to check them out first.</p><p> 在开始之前，我们已经在这里介绍了MOS 6502的某些部分，并在这里介绍了Western Digital和Ricoh制作的16位变体，以防您首先要检查它们。</p><p> The 65C02 is another modified version of the MOS 6502 made by Western Digital, it’s a lot more efficient due to its manufacturing approach (CMOS). From the software side, the 65C02 adds a couple of new instructions and modifies the behaviour of some existing ones.</p><p> 65C02是Western Digital生产的MOS 6502的另一种改进版本，由于其制造方法（CMOS），效率更高。从软件方面来看，65C02添加了一些新指令并修改了一些现有指令的行为。</p><p> We could a lot more about the 65C02, but I think it’s better to focus on the features added by Hudson (complementing the 65C02) because they are critical to efficiently operate this console. Compared to the 65C02, the HuC6280 has:</p><p> 我们可以提供有关65C02的更多信息，但是我认为最好专注于Hudson添加的功能（对65C02的补充），因为它们对于有效操作此控制台至关重要。与65C02相比，HuC6280具有：</p><p> A  timer. It works by counting down from a specified value and when it finishes, it dispatches an interrupt to the CPU.</p><p> 一个计时器。它通过从指定值开始递减计数来工作，完成后它会向CPU分派中断。</p><p>   One thing I didn’t mention  yet is that NEC also added a  Memory Management Unit or ‘MMU’ next to the CPU, allowing to handle  21-bit addresses (remember the original 6502 only has 16-bit addresses). Thus, the amount of memory that can be accessed raises from 64 KB to  2 MB.</p><p>   我还没有提到的一件事是，NEC还在CPU旁边添加了一个内存管理单元或“ MMU”，允许处理21位地址（请记住，原来的6502仅具有16位地址）。因此，可以访问的内存量从64 KB增加到2 MB。</p><p> This MMU is very different from any modern-day MMU. The one found in the PC Engine is composed of  eight 8-bit registers (called  Mapping Register or ‘MPR’) which are combined with the CPU’s 16 address lines to form a 21-bit address bus.</p><p> 该MMU与任何现代MMU都有很大不同。 PC引擎中的一个由8个8位寄存器（称为映射寄存器或“ MPR”）组成，这些寄存器与CPU的16条地址线组合在一起形成21位地址总线。 </p><p>   The CPU can read from and/or write to any MPR using the special  TAM and  TMA instructions, respectively.</p><p>CPU可以分别使用特殊的TAM和TMA指令读取和/或写入任何MPR。</p><p> When physical memory is accessed, the MMU reserves the address lines A13-A16 from the CPU to select one of the eight MPRs.</p><p> 当访问物理内存时，MMU保留来自CPU的地址线A13-A16，以选择八个MPR之一。</p><p> The MMU then combines the CPU lines A0-A12 with the 8-bit value of the selected MPR to set A13-A20. Resulting in a 21-bit address.</p><p> 然后，MMU将CPU行A0-A12与所选MPR的8位值组合在一起以设置A13-A20。结果为21位地址。</p><p> Consequently, this MMU groups physical memory in 8 KB pages (12 CPU lines = 8 KB pages), which is the amount of memory the CPU can access without swapping out the MPR nor altering its value.</p><p> 因此，此MMU将物理内存分为8 KB页（12 CPU行= 8 KB页），这是CPU可以在不交换MPR或更改其值的情况下访问的内存量。</p><p> Anyway, don’t overwhelm yourself if you have trouble understanding it (it’s just an unconventional modus operandi some may find interesting).</p><p> 无论如何，如果您在理解它时遇到困难，不要感到不知所措（这只是一种非常规的操作方式，有些人可能会觉得很有趣）。</p><p>   This is taken care by the  Hudson Soft HuC6270, a separate chip also referred to as the  Video Display Controller or ‘VDC’. The HuC6270 will draw everything that the player will see on the screen and its functionality is very similar to  Sega’s counterpart, so please check out that article beforehand since I’ll focus on what’s different with Hudson’s offering.</p><p>   Hudson Soft HuC6270（这是另一种芯片，也称为视频显示控制器或“ VDC”）会对此加以注意。 HuC6270将绘制播放器在屏幕上看到的所有内容，并且其功能与Sega的同类产品非常相似。因此，请先查看该文章，因为我将重点介绍与Hudson的产品的不同之处。</p><p>  First things first, the VDC is a  tile engine (pretty much the standard until the 5th generation showed up) but notice how the PC Engine includes  64 KB of VRAM which is a significant amount compared to the competition. This may lead to a new type of content, which we’ll check later on.</p><p>  首先，VDC是一个图块引擎（直到第5代出现时才是标准），但请注意PC引擎如何包含64 KB的VRAM，与竞争对手相比，这是一个很大的数目。这可能会导致一种新型的内容，稍后我们将进行检查。 </p><p>  The way graphics data is arranged is a bit confusing: Both CPU and VDC use 16-bit addresses, but while the CPU can only handle 8-bit words, the HuC6270 stores 16-bit words in VRAM. This means that a single address in RAM contains a byte while an address in VRAM stores two bytes, so developers had to watch out for that discrepancy when transferring data to VRAM.</p><p>图形数据的排列方式有点令人困惑：CPU和VDC都使用16位地址，但是CPU仅能处理8位字，而HuC6270在VRAM中存储16位字。这意味着RAM中的单个地址包含一个字节，而VRAM中的地址存储两个字节，因此开发人员在将数据传输到VRAM时必须注意这种差异。</p><p> The reason for this comes down to the way Hudson organised the circuitry: The VDC has a 16-bit address bus but  only the first 15 lines are controlled (the last one is always set to ‘0’), so odd addresses are fetched from the second byte. I don’t know why Hudson went down this path, but I do know that all of this would make better sense if the system had instead 128 KB of VRAM (since a 16-bit address bus can only access up to 64 KB, so by somehow doubling the data bus, up to 128 KB can be retrieved). Maybe that was the original plan for Hudson/NEC?</p><p> 原因归结于哈德森组织电路的方式：VDC具有16位地址总线，但仅控制前15条线（最后一条始终设置为“ 0”），因此从中获取奇数地址第二个字节。我不知道为什么哈德森走这条路，但是我确实知道，如果系统改用128 KB的VRAM，所有这些都会更有意义（因为16位地址总线最多只能访问64 KB，因此通过以某种方式使数据总线加倍，最多可以检索128 KB）。也许那是哈德森/ NEC最初的计划？</p><p>  Aside from the aforementioned granularity oddity, functionality-wise the VDP is very simple. The subsystem has three main components: The  VDC and  VRAM, which we already discussed - and the  video encoder (also called ‘VEC’, we’ll see more about it in due time).</p><p>  除了前面提到的粒度奇数之外，从功能上来说，VDP非常简单。该子系统具有三个主要组件：我们已经讨论过的VDC和VRAM，以及视频编码器（也称为“ VEC”，我们将在适当的时候看到更多信息）。</p><p> The system can use multiple resolutions, this is because the game can alter a set of registers that act as parameters for controlling the display timings, which in turn alter when the CRT starts beaming the frame (as opposed to overscan). The minimum resolution is  256 × 224 pixels, while some homebrew has proved this system can go as high as  512 × 240 pixels.</p><p> 系统可以使用多种分辨率，这是因为游戏可以更改一组寄存器，这些寄存器用作控制显示时间的参数，而当CRT开始对帧进行投影时，这些寄存器又会发生变化（与过扫描相反）。最低分辨率为256×224像素，而一些自制软件证明该系统可以达到512×240像素。</p><p> Now let’s see how a frame is drawn step by step, for this, I’ll borrow  Bonk’s Adventure’s assets.</p><p> 现在，让我们逐步了解如何绘制框架，为此，我将借用Bonk's Adventure的资产。</p><p> As a quick reminder, tiles are just  8x8 pixel bitmaps that the renderer fetches to draw portions of the screen. With the VDC, the frame is composed of two planes: The background layer and the sprite layer.</p><p> 快速提醒一下，图块只是渲染器获取以绘制屏幕部分的8x8像素位图。对于VDC，框架由两个平面组成：背景层和子画面层。</p><p> Inside VRAM there’s an area called  Character generator where tiles exclusive to the background layer are defined. Each pixel of a tile occupies four bits, so it can use up to 16 colours. In theory, up to 4096 background tiles can be defined, but this is less in practice due to VRAM being much smaller.</p><p> 在VRAM内部，有一个称为“角色生成器”的区域，其中定义了背景层专有的图块。图块的每个像素占用4位，因此最多可以使用16种颜色。从理论上讲，最多可以定义4096个背景图块，但是由于VRAM小得多，因此实际上很少。 </p><p> Sprites, on the other hand, are drawn using tiles from a separate memory location in VRAM, this is called  Sprite Generator and differs from the previous Character generator as tiles here are  16x16 pixels wide.</p><p>另一方面，使用来自VRAM中单独存储位置的图块绘制Sprite，这称为Sprite Generator，它与以前的Character生成器不同，因为此处的图块宽16x16像素。</p><p> The video encoder is a separate chip that stores  32 colour palettes (16 for the background and 16 for sprites), each palette stores 16 colours and each colour is 9-bit wide (3 bits for Red + 3 bits for Green + 3 bits for Blue).</p><p> 视频编码器是一个单独的芯片，可存储32个调色板（背景为16个，子画面为16个），每个调色板可存储16种颜色，每种颜色均为9位宽（红色3位，绿色3位，绿色3位）。蓝色）。</p><p> (This section is written for those interested in how Hudson took advantage of 64 KB of VRAM with that 16-bit granularity, but you don’t have to understand it completely to be able to follow the rest of the article).</p><p> （本节是为那些对Hudson如何利用16位粒度的64 KB VRAM感兴趣的人而写的，但您不必完全了解它就可以继续阅读本文的其余部分。）</p><p> So far we’ve discussed that each pixel of a tile is stored using 4 bits (or a half byte, also called a  nibble). Now, Hudson dictates that  tiles are composed of four 8x8 bitmaps (called ‘CH0’, ‘CH1’, ‘CH2’ and ‘CH3’, respectively). Each map is 1-bit wide, but once the four are combined, they form the final tile with 4-bit pixels.</p><p> 到目前为止，我们已经讨论了图块的每个像素都是使用4位（或半字节，也称为半字节）存储的。现在，哈德森指出，图块由四个8x8位图（分别称为“ CH0”，“ CH1”，“ CH2”和“ CH3”）组成。每个贴图的宽度为1位，但是一旦将这四个贴图组合在一起，它们就会形成具有4位像素的最终图块。</p><p> Also, remember the 16-bit alignment on VRAM?  Each 16-bit word stores a single row of two 1-bit bitmaps (8 rows + 8 rows). So, after writing eight entries, two maps will be stored (instead of just one). Please have a look at the diagrams to help understand this better.</p><p> 另外，还记得VRAM上的16位对齐方式吗？每个16位字存储单行的两个1位位图（8行+ 8行）。因此，在写入八个条目之后，将存储两个映射（而不是一个）。请查看图表以更好地理解这一点。</p><p> The same happens with Sprite tiles, but since they are 16x16 bitmaps, each bitmap occupies 16 words. To put it another way, to store a single sprite tile, 64 words are taken (equivalent to 8 bytes in VRAM).</p><p> Sprite切片也会发生同样的情况，但是由于它们是16x16位图，每个位图占用16个字。换句话说，要存储单个Sprite块，将占用64个字（相当于VRAM中的8个字节）。</p><p> The background layer is constructed by filling the  Background Attribute Table with entries in VRAM, the position of each entry defines X/Y coordinate of the tile in the screen. Each entry contains the tile index from the Character Generator and the colour palette.</p><p> 通过在VRAM中的条目填充背景属性表来构造背景层，每个条目的位置定义屏幕中图块的X​​ / Y坐标。每个条目都包含来自字符生成器和调色板的图块索引。 </p><p> The maximum dimension of this layer is  1024 x 512 pixels (128 x 64 tiles), but programmers can set up a 256 x 256 pixels (32 x 32 tiles) layer as the minimum.</p><p>该层的最大尺寸为1024 x 512像素（128 x 64瓦片），但程序员可以将最小层设置为256 x 256像素（32 x 32瓦片）。</p><p> As always, this layer is scrollable by changing the value of some registers in the VDC.</p><p> 与往常一样，可以通过更改VDC中某些寄存器的值来滚动此层。</p><p> The VDC contains an internal memory called  Sprite Attribute Table Buffer where up to 64 sprites can be defined. Each entry of the table stores the independent X/Y position, colour palette, tile index and H/V flip. Furthermore, there’s an attribute allowing to combine a sprite with another one.</p><p> VDC包含一个称为Sprite Attribute Table Buffer的内部存储器，最多可以定义64个Sprite。该表的每个条目均存储独立的X / Y位置，调色板，图块索引和H / V翻转。此外，还有一个属性可以将一个精灵与另一个精灵结合在一起。</p><p> Each entry is 8 bytes long, although some space is wasted due to the 16-bit granularity.</p><p> 每个条目的长度为8个字节，尽管由于16位的粒度会浪费一些空间。</p><p> To top it all off,  the CPU can’t access this table, so it needs to be completed in VRAM and then activate a DMA channel to copy it to the VDC (so the latter can use it).</p><p> 最重要的是，CPU无法访问该表，因此需要在VRAM中完成该表，然后激活DMA通道以将其复制到VDC（以便后者可以使用）。</p><p> Regarding limitations, there can only be up to 16 sprites per scan-line. On the other side, interrupts can be set so the game can be notified when there’s been a case of sprite overflow or  collision.</p><p> 关于限制，每条扫描线最多只能有16个子画面。另一方面，可以设置中断，以便在发生精灵溢出或碰撞的情况时通知游戏。</p><p> So far we’ve seen how the VDC does all the heavy work, but the last task is actually delegated to the  Video Encoder or ‘VCE’. Hudson named this chip  HuC6260 and its basic function is to receive 9-bit data streams from the VDC, apply the colour palettes, and send the result to the TV (in the form of an analogue signal).</p><p> 到目前为止，我们已经了解了VDC如何完成所有繁重的工作，但实际上最后一个任务已委派给视频编码器或“ VCE”。 Hudson将该芯片命名为HuC6260，其基本功能是从VDC接收9位数据流，应用调色板并将结果发送到电视（以模拟信号的形式）。 </p><p> If you read previous articles you may be familiar with the importance of timing. Well, here is no exception: To avoid unwanted artefacts (such as ‘snow’), the VCE can only be updated during a vertical interrupt.</p><p>如果您阅读了以前的文章，您可能会熟悉计时的重要性。好吧，这里也不例外：为了避免出现不必要的伪影（例如“ snow”），只能在垂直中断期间更新VCE。</p><p>  The Video encoder outputs RGB (along with Sync) and YPbPr, this is ideal for use with a SCART cable or component cable, respectively. This looks good so far!&amp;mldr</p><p>  视频编码器输出RGB（以及同步）和YPbPr，分别适合与SCART电缆或分量电缆一起使用。到目前为止看起来不错！＆amp; mldr</p><p> &amp;mldr Unfortunately, Hudson decided to fit an RF modulator as the only way to get video out-of-the-box, so it’s not that great after all. But then again, the PC Engine was designed in the 80s, so this approach guaranteed compatibility with all kinds of TVs (assuming they are from the same region of the console).</p><p> ＆amp; mldr不幸的是，哈德森决定将RF调制器作为开箱即用的视频的唯一方法，因此毕竟不是那么好。但话又说回来，PC引擎是在80年代设计的，因此这种方法保证了与所有类型电视的兼容性（假设它们来自控制台的同一区域）。</p><p> On the bright side, the Expansion Port contains pins that carry RGB video and multiple sync types, but they will need an external accessory to be able to advantage of them.</p><p> 从好的方面来说，扩展端口包含的引脚可以承载RGB视频和多种同步类型，但是它们将需要外部附件才能发挥其优势。</p><p>   The PC Engine contains a  Programmable Sound Generator or ‘PSG’ like many other third-generation consoles analysed in this website. On the other side, this PSG particularly relies on the  waveform memory (also called ‘waveform buffer’) approach to synthesise sound, as opposed to using a pre-defined set of waveforms (i.e. pulse, triangle, etc). Waveform memory enables programmers to define their own waveforms, which gives more flexibility for soundtrack arrangements.</p><p>   与本网站中分析的许多其他第三代控制台一样，PC引擎包含一个可编程声音发生器或“ PSG”。另一方面，此PSG特别依赖于波形存储器（也称为“波形缓冲区”）方法来合成声音，而不是使用一组预定义的波形（即脉冲，三角形等）。波形存储器使程序员可以定义自己的波形，从而为音轨安排提供更大的灵活性。</p><p> There are  six channels in this system, each one is set up by writing to a set of registers, there’s quite a lot of attributes available to customise so here are the most important ones:</p><p> 该系统有六个通道，每个通道都是通过写入一组寄存器来设置的，有很多可自定义的属性，因此以下是最重要的属性：</p><p> Waveform shape: The waveform cycle is generated using thirty-two 5-bit values, each one corresponds to the amplitude of the wave at a particular time.</p><p> 波形形状：使用32个5位值生成波形周期，每个值对应于特定时间的波幅。 </p><p> Frequency control: Two 8-bit registers alter the frequency of the channel to produce different musical notes with the same waveform.</p><p>频率控制：两个8位寄存器更改通道的频率，以产生具有相同波形的不同音符。</p><p> Amplitude level: Four bits of a shared register control how loud the channel will sound.</p><p> 幅度级别：共享寄存器的四位控制通道的声音大小。</p><p>  Some groups of channels have other modes of operations. For instance, the last two channels are connected to a  noise generator. Moreover, the second channel can act as a  Low-frequency oscillator to modulate the first channel, much like  FM synthesis.</p><p>  某些通道组具有其他操作模式。例如，最后两个通道连接到噪声发生器。此外，第二个通道可以充当低频振荡器来调制第一个通道，非常类似于FM合成。</p><p>  The PSG will mix everything and output a stereo signal. But again, unless you find a way to bypass the RF port, you’ll only hear mono from your telly.</p><p>  PSG将混合所有内容并输出立体声信号。但是，除非您找到绕过RF端口的方法，否则您只会从电视中听到单声道。</p><p>   This console had a massive amount of accessories, some of which completely enhanced the console internally (by providing more RAM, for instance) and externally (by adding more ports and/or the possibility to read other storage mediums).</p><p>   该控制台具有大量附件，其中一些附件在内部（例如，通过提供更多的RAM）和在外部（通过添加更多的端口和/或读取其他存储介质的可能性）完全增强了控制台的功能。</p><p> This is greatly attributed to the inclusion of the  Expansion Port on the back of the console, which gave access to the following components:</p><p> 这在很大程度上归功于控制台背面的扩展端口，该端口允许访问以下组件：</p><p> A Voltage input line: To bypass the original PSU and power the console through the accessory.</p><p> 电压输入线：绕过原始PSU并通过附件为控制台供电。 </p><p> Audio Input and Output: Which can receive the stereo audio output and/or send audio from an input line.</p><p>音频输入和输出：可以接收立体声音频输出和/或从输入线路发送音频。</p><p> CPU data and address lines: Enables the CPU to access the accessory and vice versa.</p><p> CPU数据和地址线：使CPU能够访问附件，反之亦然。</p><p> VDC data lines (those that go to the Video encoder): Allows the accessory to tap those lines, I’m not sure what for though.</p><p> VDC数据线（那些连接到视频编码器的数据线）：允许附件点击这些线，但我不确定该怎么做。</p><p> CPU control lines: Reads the HuCard and CD detection flag, speed mode used and also has access to interrupt lines.</p><p> CPU控制线：读取HuCard和CD检测标志，使用的速度模式，还可以访问中断线。</p><p> I’m curious to know to which extent NEC or Hudson envisioned this console, were they trying to build some sort of ‘modular console’ that could be upgraded to step into the next generation?</p><p> 我很好奇，想知道NEC或Hudson在什么程度上设想了此控制台，他们是否正在尝试构建某种可以升级到下一代的“模块化控制台”？</p><p>  I still haven’t mentioned the controller (or Joypad, as some places call it). It’s very similar to the other offerings. The console only allows to connect one of them and games check a single address in memory to get the key presses. That address returns a 4-bit value.</p><p>  我仍然没有提到控制器（或某些地方称其为Joypad）。与其他产品非常相似。控制台仅允许连接其中之一，游戏会检查内存中的单个地址以获取按键。该地址返回一个4位值。</p><p>   There’s no internal ROM or ‘BIOS’ or anything else that runs before the game, thus we don’t have an Operating System here. The reset vector is found at address  $FFFE and  $FFFF (remember that the internal registers are 8-bit but memory addresses are 16-bit, hence we need two words to initialise the program counter) and those addresses point to the game card.</p><p>   游戏前没有内部ROM或'BIOS'或其他任何可运行的东西，因此我们这里没有操作系统。复位向量位于地址$ FFFE和$ FFFF（请记住内部寄存器为8位，而存储器地址为16位，因此我们需要两个字来初始化程序计数器），并且这些地址指向游戏卡。 </p><p> This also means that it’s up to the programmer to take care of ‘housekeeping’ (i.e. initialising memory, set up the MMU and so on&amp;mldr).</p><p>这也意味着程序员要负责“内务处理”（即初始化内存，设置MMU等）。</p><p>   Programs are written in 6502 assembly, spiced with extra 65C02 opcodes and the ones introduced by Hudson.</p><p>   程序以6502汇编语言编写，并带有额外的65C02操作码和Hudson引入的程序码。</p><p>  Instead of relying on those  chunky and boring cartridges everyone else seems to like, NEC/Hudson devised yet another medium, this time with the size of a credit card, called  HuCard. They derive from an older medium called ‘Bee Card’, used by some MSX games.</p><p>  NEC / Hudson不再依赖其他所有人似乎都喜欢的笨拙而乏味的墨盒，而是设计了另一种媒介，这次使用的是信用卡大小的卡片，称为HuCard。它们来自某些MSX游戏使用的称为“蜜蜂卡”的较旧媒体。</p><p> Curiously enough, they are very similar to the  Sega Card but they contain 38 pins instead of 35. Internally, the differences are more significant:</p><p> 奇怪的是，它们与Sega卡非常相似，但它们包含38个引脚而不是35个引脚。在内部，两者之间的差异更为明显：</p><p> The CPU memory map can access up to  1 MB of HuCard memory without a mapper, hence the majority of games stuck with 1 MB ROMs. Meanwhile, games like ‘Street Fighter II’ resided in a 2.5 MB ROM!</p><p> 在没有映射器的情况下，CPU内存映射最多可以访问1 MB的HuCard内存，因此大多数游戏都卡有1 MB ROM。同时，“街头霸王II”之类的游戏驻留在2.5 MB的ROM中！</p><p> There’s an  Audio In pin which seems to allow the card to feed the console an extra audio channel.</p><p> 有一个“音频输入”引脚，似乎可以使卡向控制台提供额外的音频通道。</p><p>  That expansion port opened the door to such a massive amount of accessories and expansion units that they eventually turned a simple PC Engine into something completely different. As if wasn’t enough, the HuCard slot complemented the possibilities of expansion. What I mean to say is that for this article, I’ll have to focus on the notable upgrades (some of which were included in future revisions of the console).</p><p>  那个扩展端口打开了通往大量附件和扩展单元的大门，最终他们将简单的PC引擎变成了完全不同的东西。似乎还不够，HuCard插槽补充了扩展的可能性。我的意思是说，对于本文，我将重点关注显着的升级（其中一些已包含在控制台的未来版本中）。 </p><p> Let’s take a look at the  CD-ROM² expansion, which consists in a CD-ROM reader and a special HuCard called  System Card, the latter acted as a  BIOS to bootstrap the game and provide some routines to interface the reader. Internally, the reader included  64 KB of RAM for general purpose, another  64 KB of RAM to stream ADPCM samples and finally,  2 KB for save data. As you can guess, this enabled game developers to take the advantage of extra storage and CD audio, while giving publishers the economic relief to distribute their games in a non-proprietary medium.</p><p>让我们看一下CD-ROM²扩展，它包含一个CD-ROM读取器和一个特殊的HuCard，称为System Card，后者充当BIOS来引导游戏并提供一些与读取器接口的例程。在内部，读取器包括用于常规用途的64 KB RAM，用于传输ADPCM样本的另一个64 KB RAM和最后用于存储数据的2 KB。如您所料，这使游戏开发人员可以利用额外的存储空间和CD音频，同时为发布商提供经济上的缓解，使其可以通过非专有媒体分发游戏。</p><p> Years later, NEC released another CD module called  Super CD-ROM² and while the reader’s hardware remained mostly the same, its general-purpose RAM was incremented to 256 KB. Customers that already owned a CD-ROM² unit were able to ‘update it’ by purchasing the  Super System Card, which included the extra RAM (and one more I/O routine!). On top of all that, NEC later shipped new BIOS updates called  Arcade Card, which in this case contained  2 MB of RAM.</p><p> 数年后，NEC发布了另一个CD模块，称为SuperCD-ROM²，而阅读器的硬件基本保持不变，但其通用RAM增加到256 KB。已经拥有CD-ROM²单元的客户可以通过购买超级系统卡来对其进行“更新”，其中包括额外的RAM（以及另一个I / O例程！）。最重要的是，NEC后来发布了称为Arcade Card的新BIOS更新，其中包含2 MB的RAM。</p><p> CD-based games strictly depended on the BIOS card they were developed for, although newer cards were backwards compatible (with some exceptions). Thus, the Arcade Card is the preferable choice for users that want to play  almost all CD-ROM based games. I mentioned ‘almost’ since third party companies also released their own BIOS cards (i.e. ‘Games Express CD Card’), and these were required to play games specifically from that studio.</p><p> 基于CD的游戏严格依赖于为其开发的BIOS卡，尽管较新的卡向后兼容（某些例外）。因此，对于想要玩几乎所有基于CD-ROM的游戏的用户而言，Arcade卡是首选。我提到“几乎”是因为第三方公司还发布了自己的BIOS卡（即“ Games Express CD卡”），而这些卡是专门用来播放该工作室中的游戏所必需的。</p><p> With the Super CD-ROM², NEC/Hudson also shipped a new variant of the PC-Engine/TurboGrafx-16 called  Turbo Duo that bundled the console, reader and BIOS card in a single package.</p><p> NEC / Hudson还通过SuperCD-ROM²发行了PC-Engine / TurboGrafx-16的新版本，称为Turbo Duo，将控制台，读取器和BIOS卡捆绑在一个包装中。</p><p>  If you are curious about other expansions released, check out the catalogue link at the ‘Sources’ section (end of the article).</p><p>  如果您对发布的其他扩展版本感到好奇，请查看“来源”部分（本文结尾）中的目录链接。</p><p>   HuCards are region-locked, meaning that a PC-Engine game won’t work on a TurboGrafx-16 (or vice versa) out-of-the-box. This is because the data lines are inverted on the American version. As you can guess, this isn’t something a cheap adapter can’t tackle. However, games may include routines to check the system’s region.</p><p>   HuCard已在区域锁定，这意味着PC-Engine游戏无法在现成的TurboGrafx-16上运行（反之亦然）。这是因为数据线在美国版上是倒置的。如您所料，这不是廉价适配器无法解决的问题。但是，游戏可能包含检查系统区域的例程。</p><p> On the other side, CD-ROM games are neither region-locked nor copy-protected, but bear in mind that they still need a System Card to bootstrap them (which is region-locked).</p><p> 另一方面，CD-ROM游戏既没有区域锁定也没有复制保护，但要记住，它们仍然需要系统卡来引导它们（区域锁定）。 </p><p>     2020 has been an ‘interesting’ year for the website (setting aside all those negative events that have affected all of us). The year started with the  Wii article and then carried on with the  PS2,  Xbox,  Nintendo DS,  Master System and finally, this one.</p><p>2020年对于网站而言是“有趣的一年”（撇开那些影响了我们所有人的负面事件）。这一年从Wii文章开始，然后是PS2，Xbox，Nintendo DS，Master System，最后是这本书。</p><p> A lot has changed in the number of visitors too. It had a slow start at first, but then during the summer, it caught an amazingly high number of visits. I want to thank Hackernews users, OSNews, Reddit, Gigazine, Youtubers, Twitter users and lots of other forums and people for sharing the articles. And of course, a big shoutout to the donors whose generosity helped keep the site afloat!</p><p> 访客数量也发生了很大变化。刚开始时进展缓慢，但随后在夏季，访问量却惊人地高。我要感谢Hackernews用户，OSNews，Reddit，Gigazine，Youtubers，Twitter用户以及许多其他论坛和人们分享文章。当然，向捐助者大声疾呼，捐助者的慷慨帮助使该地点得以持续发展！</p><p>                      This article is part of the  Architecture of Consoles series. If you found it interesting please consider donating, your contribution will be used to get more tools and resources that will help to improve the quality of current articles and upcoming ones.</p><p>                      本文是控制台体系结构系列的一部分。如果您觉得有趣，请考虑捐款，您的捐款将用于获得更多工具和资源，以帮助改善当前文章和即将发表的文章的质量。</p><p>   - Carlos Diaz Navarro - Colin Szechy - David Portillo - Duncan Bayne - Eric Haskins - Grady Haynes - Izsak Barnette - Josh Enders - Olivier Cahagne - Samuel Shieh - Sanqui- Thomas Peter Berntsen</p><p>   -Carlos Diaz Navarro-Colin Szechy-David Portillo-Duncan Bayne-Eric Haskins-Grady Haynes-Izsak Barnette-Josh Enders-Olivier Cahagne-Samuel Shieh-Sanqui- Thomas Peter Berntsen</p><p>     ## 2020-12-18  - Publishing date? ## 2020-12-16  - First draft finished. - Thanks  @dpt for checking out the draft.- Carlos, R-type is very hard.</p><p>     ## 2020-12-18-发布日期？ ## 2020-12-16-第一稿完成。 -感谢@dpt签出草稿。-卡洛斯，R型非常难。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.copetti.org/projects/consoles/pc-engine/">https://www.copetti.org/projects/consoles/pc-engine/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/引擎/">#引擎</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/engine/">#engine</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/控制台/">#控制台</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>