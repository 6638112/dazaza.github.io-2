<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>现代CI太复杂，误导了 Modern CI Is Too Complex and Misdirected</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Modern CI Is Too Complex and Misdirected<br/>现代CI太复杂，误导了 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-08 03:14:31</div><div class="page_narrow text-break page_content"><p>The state of CI platforms is much stronger than it was just a few years ago.Overall, this is a good thing: access to powerful CI platforms enablessoftware developers and companies to ship more reliable software morefrequently, which benefits its users/customers. Centralized CI platformslike GitHub Actions, GitLab Pipelines, and Bitbucket provide benefits ofscale, as the Internet serves as a collective information repository forhow to use them. Do a search for  how to do X on CI platform Y andyou&#39;ll typically find some code you can copy and paste. Nobody wants totoil with wrangling their CI configuration after all: they just wantto ship.</p><p>CI平台的状态比几年前更强大。这是一件好事：访问强大的CI平台，EnableSessware开发人员和公司的推出更加可靠的软件，这使其用户/客户受益。集中式CI平台Like Github动作，Gitlab管道和Bitbucket提供了ofScale的好处，因为互联网用作集体信息存储库，何时使用它们。搜索如何在CI平台上进行X和您和＃39; LL通常会找到您可以复制和粘贴的一些代码。毕竟没有人想要争吵他们的CI配置：他们只是想发货。</p><p>  The advancements in CI platforms have come at a cost: increased complexity.And the more I think about it,  I&#39;m coming around to the belief thatmodern CI systems are too complex. Let me explain.</p><p>  CI平台的进步以成本计算：复杂性增加。我想到的越多，即将到来，即将到来的信仰，即默认的CI系统太复杂了。让我解释。</p><p> At its core, a CI platform is a specialized  remote code execution as aservice (it&#39;s a feature, not a CVE!) where the code being executed isin pursuit of building, testing, and shipping software (unless you abuse it to mine cryptocurrency).So, CI platforms typically throw in a bunch of value-add features to enableyou to ship software more easily. There are vastly different approaches andbusiness models here. (I must tip my hat to GitHub Actions leveraging networkeffects via community maintained  actions: this lowers TCO for GitHub as theydon&#39;t need to maintain many  actions, creates vendor lock-in as users developa dependence on platform-proprietary  actions, all while increasing thevalue of the platform for end-users - a rare product trifecta.) A commonvalue-add property of CI platforms is some kind of configuration file(often YAML) which itself offers common functionality, such as configuringthe version control checkout and specifying what commands to run. This iswhere we start to get into problems.</p><p> 在其核心，CI平台是一款专业的远程代码执行，如Aservice（IT＆＃39; SA功能，不是CVE！），其中代码正在执行建筑，测试和运输软件（除非您将其滥用到我Cryptocurrency）.so，CI平台通常抛出一堆价值 - 添加功能，以使您能够更轻松地运送软件。这里有不同的方法和商业模式。 （我必须把我的帽子提示到Github的动作，利用NetWorkeffects通过社区维持行动：这降低了Github的TCO，因为他们需要维持许多行动，以用户开发依赖于平台专有的行动，创建供应商锁定，所有增加了最终用户平台的Value  - 一种稀有产品三十型。）CI平台的CommonValue-Add属性是某种配置文件（通常是YAML），它本身提供了常用功能，例如配置版本控制结账并指定什么命令跑步。这是我们开始遇到问题的地方。</p><p> (I&#39;m going to focus on GitHub Actions here, not because they are the worst(far from it), but because they seem to be the most popular and readers canrelate more easily. But my commentary applies to other platforms like GitLabas well.)</p><p> （I＆＃39; m将专注于这里的GitHub操作，不是因为它们是最糟糕的（远离它），而是因为它们似乎是最受欢迎的，读者更容易加入。但我的评论适用于Gitlabas这样的其他平台好吧。）</p><p> The YAML configuration of modern CI platforms is... powerful. Here are featurespresent in  GitHub Actions workflow YAML:</p><p> 现代CI平台的YAML配置是...强大的。以下是Github操作的推荐工作流程Yaml：</p><p> An embedded templating system that results in the source YAML being expanded into a final YAML document that is actually evaluated. This includes a custom  expression mini language.</p><p> 嵌入式模板系统，导致源YAML展开到实际评估的最终YAML文档中。这包括自定义表达式迷你语言。</p><p> If we expand scope slightly to include actions maintained by GitHub, we also havesteps/actions features for:</p><p> 如果我们略微扩展范围以包含GitHub维护的操作，我们还存在/操作功能： </p><p>  And then of course there are 3rd party Actions. And there&#39;s a lot of them!</p><p>当然，当然存在第三方行动。和＃39;很多人！</p><p> There&#39;s a lot of functionality here and a lot of it is arguably necessary:I&#39;m hard pressed to name a feature to cut. (Although I&#39;m no fan of using YAMLas a programming language but I concede it use is a fair compromise comparedto forcing people to write code to produce YAML or make equivalent API callsto do what the YAML would do.) All these features seem necessary for asufficiently powerful CI offering. Nobody would use your offering if it didn&#39;toffer turnkey functionality after all.</p><p> 这里有很多功能和很多功能可以说是必要的：我很难命名为削减一个功能。 （虽然我没有使用yamlas一个编程语言的粉丝，但我承认它是一个公平的妥协，使人们迫使人们编写代码来生产yaml或使等效的api callsto做yaml会做的事情。）所有这些功能似乎必要的强大的CI提供。如果它没有DIDAT，没有人会使用您的产品;毕竟提供了补说工具功能。</p><p>  I posit that  a sufficiently complex CI system becomes indistinguishable froma build system. I challenge you: try to convince me or yourself that GitHubActions, GitLab CI, and other CI systems aren&#39;t build systems. The basicprimitives are all there. GitHub Actions Workflows comprised of jobs comprisedof steps are little different from say Makefiles comprised of rules comprisedof commands to execute for that rule, with dependencies gluing everythingtogether. The main difference is the  form factor and the execution model (buildsystems are traditionally local and single machine but CI systems areremote/distributed).</p><p>  我有一个足够复杂的CI系统从构建系统中无法区分。我挑战你：试着说服我或你自己那个Githubation，Gitlab CI和其他CI系统aren＆＃39; t构建系统。基本的东西都在那里。 GitHub操作由由步骤组成的作业组成的工作流程与Say FakeFiles组成的Makefiles与Commented为该规则执行的命令组成的规则组成，具有依赖项胶合致命一切。主要区别是表单因素和执行模型（BuildSystems是传统的本地和单机，但CI系统arereMote /分布式）。</p><p> Then we have a similar conjecture:  a sufficiently complex build system becomesindistinguishable from a CI system. Earlier I said that CI systems are remote code execution as a service. While build systems are historicallythings that run locally (and therefore not a  service), modern build systemslike Bazel (or Buck or Gradle) are completely different animals. For example,Bazel has remote executionand remote caching asbuilt-in features. Hey - those are built-in features of modern CI systems too! So here&#39;s a thought experiment: if I define a build system in Bazel and thendefine a server-side Git push hook so the remote server triggers Bazel to build,run tests, and post the results somewhere, is that a CI system? I think it is!A crude one. But I think that qualifies as a CI system.</p><p> 然后我们有一个类似的猜想：从CI系统中解释了一个足够复杂的构建系统。早些时候我说CI系统是作为服务的远程代码执行。虽然构建系统是在本地运行的历史上（因此不是服务），现代构建系统般的挥之克（或降压或GRADLE）是完全不同的动物。例如，BAZEL具有远程执行和远程缓存的已陷入困境。嘿 - 那些也是现代CI系统的内置功能！所以在这里＆＃39;如果我在Bazel和Thendefine中定义一个构建系统，那么服务器端Git推挂钩，所以远程服务器触发Bazel构建，运行测试并在某处发布结果，就是一个CI系统吗？我想是！一个原始的。但我认为这有资格作为CI系统。</p><p> If you squint hard enough, sufficiently complex CI systems and sufficientlycomplex build systems start to look like the same thing to me. At a very highlevel, both are providing a pool of servers offering general compute/executefunctionality with specialized features in the domain of building/shipping software,like inter-task artifact exchange, caching, dependencies, and a frontend languageto define how everything works.</p><p> 如果您眯起足够努力，足够复杂的CI系统和足够的复杂构建系统开始对我看起来像同样的事情。在一个非常高级别的人中，两者都提供了一个服务器池，该池提供了一般的计算/执行功能，在建筑物/送货软件领域中具有专门的功能，如任务间工件交换，缓存，依赖关系和前端语言，定义了所有工作原理。</p><p> (If you squint really hard you can start to see a value proposition of Kubernetesfor even more general compute scheduling, but I&#39;m not going to go that far in thispost because it is a much harder point to make and I don&#39;t necessarily believe init myself. But I thought I&#39;d mention it as an interesting thought experiment. Butan easier leap to make is to throw batch job execution (as is often found in datawarehouses) in with build and CI systems as belonging in the same bucket: batchjob execution also tends to have dependencies, exchange of artifacts between jobs,and I think can strongly resemble a CI system and therefore a build system.)</p><p> （如果你真的很难你可以开始看到Kubernetes的价值主张更普遍计算调度，但我不会在这个棋子里走到这一点，因为它是一个更难的表现，我不得不必然相信初步。但是我以为我作为一个有趣的思想实验。Butan更轻松地掠夺了批量作业执行（如在数据留置在数据中发现）的构建和CI系统作为归属在相同的桶中：Batchjob执行也倾向于具有依赖性，作业之间的伪影交换，我认为可以强烈地类似于CI系统，因此是一个构建系统。）</p><p> The thing that bugs me about modern CI systems is that I inevitably feel likeI&#39;m reinventing a build system and fragmenting build system logic. Your CIconfiguration inevitably devolves into a bunch of complex YAML with all kinds ofcaching and dependency optimizations to keep execution time low and reliabilityin check - just like your build system. You find yourself contorting yourproject&#39;s build system to work in the context of CI and vice versa. You end upmanaging two complex DAGs and platforms/systems instead of one.</p><p> 关于现代CI系统的错误是我不可避免地感觉到＆＃39; m重新发明一个构建系统和碎片构建系统逻辑。您的CIConfiguration不可避免地将各种复杂的YAML与各种CACHING和依赖性优化一起延伸，以保持执行时间低，可靠性检查 - 就像您的构建系统一样。您发现自己扭曲了yourproject＆＃39; s构建系统，以便在CI的上下文中工作，反之亦然。您结束了两个复杂的DAG和平台/系统而不是一个。 </p><p> Because build systems are more generic than CI systems (I think a sufficientlyadvanced build system can do a superset of the things that a sufficiently complexCI system can do), that means that CI systems are redundant with sufficientlyadvanced build systems. So going beyond the section title: CI systems aren&#39;ttoo complex: they shouldn&#39;t need to exist. Your CI functionality should be anextension of the build system.</p><p>由于构建系统比CI系统更通用（我认为一个足够的构建系统可以做足够复杂的系统可以做的事情的超集，这意味着CI系统具有足够的构建系统冗余。所以超越这一部分标题：CI Systems aren＆＃39; ttoo complex：他们需要存在。您的CI功能应该是构建系统的一个anextension。</p><p> In addition to the redundancy argument, I think unified systems are moreuser friendly. By integrating your CI system into your build system(which by definition can be driven locally as part of regular developmentworkflows), you can expose the full power of the CI system to developersmore easily. Think running ad-hoc CI jobs without having to push your changesto a remote server first, just like you can with  local builds or tests. Thisis huge for ergonomics and can drastically compress the cycle time for changesto these systems (which are often brittle to change/test).</p><p> 除了冗余参数外，我认为统一的系统更友好。通过将CI系统集成到您的构建系统中（根据定义可以作为常规开发工作的一部分驱动），您可以轻松地将CI系统的全部电量暴露给开发人员。想想运行ad-hoc ci作业，而无需首先将常长的服务器推出远程服务器，就像您可以使用本地构建或测试。这是巨大的人体工程学，可以彻底压缩昌粒这些系统的循环时间（通常是易碎的变化/测试）。</p><p> Don&#39;t get me wrong, aspects of CI systems not traditionally found in buildsystems (such as centralized results reporting and a UI/API for (re)triggeringjobs) absolutely need to exist. Instead, it is the remote compute and workdefinition aspects that are completely redundant with build systems.</p><p> 不要让我错了，不传统的CI系统的各个方面在构建系统中发现（例如集中式结果报告和（重新）triggeringjobs的UI / API）。相反，它是与构建系统完全冗余的远程计算和工作的方面。</p><p>   If you assume that build and CI systems can be / are more of the same, then itfollows that many modern CI offerings like GitHub Actions, GitLab CI, andothers are targeting the wrong abstraction: they are defined as domainspecific platforms for running CI systems when instead they should take a stepback and target the broader general compute platform that is also needed forbuild systems (and maybe batch job execution, such as what&#39;s commonly foundin data warehouses/pipelines).</p><p>   如果您认为构建和CI系统可以是/更像，那么它就像GitHub操作一样的许多现代CI产品，Gitlab CI，Andothers正在针对错误的抽象：它们被定义为在代替时运行CI系统的模特特殊平台它们应该采取退台并定位更广泛的一般计算平台，也需要Fulbuild系统（也许批量作业执行，例如＆＃39; s通常发现数据仓库/管道）。</p><p> Every CI offering is somewhere different on the spectrum here. I wouldgo so far as to argue that GitHub Actions is more a  CI product than a platform. Let me explain.</p><p> 每次CI提供都在这里的范围内容不同。我很想争辩说，GitHub动作比平台更具CI产品。让我解释。</p><p> In my ideal  CI platform, I have the ability to schedule an ad-hoc graph oftasks against that platform. I have the ability to hit some APIs with definitionsof the tasks I want that platform to run and it accepts them, executes them,uploads artifacts somewhere, reports task results so dependent tasks can execute,etc.</p><p> 在我理想的CI平台中，我有能力安排针对该平台的特设的Ad-hoc图表。我有能力使用我希望该平台运行的任务的定义拍摄一些API，它接受它们，执行它们，上传某个artifacts，报告任务结果如此依赖任务可以执行等。</p><p> There is a  GitHub Actions APIthat allows you to interact with the service. But the critical feature itdoesn&#39;t let me do is define ad-hoc units of work: the actual  remote executeas a service. Rather, the only way to define units of work is via workflow YAMLfiles checked into your repository. That&#39;s so constraining!</p><p> 有一个github动作允许您与服务交互。但关键特征是它，它让我做的是定义Ad-hoc的工作单位：实际的远程executeas服务。相反，定义工作单位的唯一方法是通过工作流yamlfiles检查到存储库中。那个＆＃39; s如此约束！ </p><p> GitLab Pipelines is a lot better. GitLab Pipelines supports features like parent-child pipelines(dependencies between different pipelines), multi-project pipelines(dependencies between different projects/repos), and dynamic child pipelines(generate YAML files in pipeline job that defines a new pipeline). (I don&#39;tbelieve GitHub Actions supports any of these features.) Dynamic childpipelines are an important feature, as they mostly divorce the checked-in YAMLconfiguration from the  remote execute as a service feature. The main missingfeature here is a generic API that allows you achieve this functionality withouthaving to go through a parent pipeline / YAML first. If that API existed, youcould build your own build/CI/batch execute system on top of GitLab Pipelineswith fewer constraints imposed on you by GitLab Pipeline&#39;s opinionated YAMLconfiguration files and the intended use of its creators. (Generally, I thinka good litmus test for a well-designed platform or tool is when its authorsare surprised by someone&#39;s unintended use for it. Of course this knife cutsboth ways, as sometimes people do undesirable things, like minecryptocurrency.)</p><p>Gitlab管道更好。 Gitlab Poilines支持父子管道（不同管道之间的依赖性），多项目管道（不同项目/ repos之间的依赖性）等功能，以及动态子管道（在流水线作业中生成定义新流水线的yaml文件）。 （我不是＆＃39; tbelieve github操作支持这些功能中的任何一个。）动态育儿是一个重要的功能，因为它们主要从远程执行作为服务功能的远程执行中寄存在yamlconfiguration。以下主要缺失的属性是一款通用API，允许您实现此功能，而无需首先通过父管道/ yaml。如果存在该API，则您可以在Gitlab Pipelines的顶部构建您自己的构建/ CI /批处理系统，这些版本在Gitlab Pipeline＆＃39; S Imporicated Yamlconfiguration文件和创建者的预期用途中施加了更少的限制。 （一般来说，我想到了一个精心设计的平台或工具的好Litmus测试是当其作者们惊讶于某人的意外使用。当然，这把刀切断的方式，因为有时人们会像Minecryptocurr一样做出不良的东西。）</p><p> CI offerings like GitHub Actions and GitLab Pipelines are more productsthan platforms because they tightly couple an opinionated configurationmechanism (YAML files) and web UI (and corresponding APIs) on top of atheoretically generic  remote execute as a service offering. For me toconsider these offerings as platforms, they need to grow the ability toschedule arbitrary compute via an API, without being constrained by theYAML officially supported out of the box. GitLab is  almost there (thecritical missing link is a  schedule an inline-defined pipeline API). Itis unknown if GitHub is - or is even interested in - pursuing thisdirection. (More on this later.)</p><p> 像GitHub操作和Gitlab Pipelines这样的CI产品是更加级数的ProductSthan平台，因为它们在无神论地通用远程执行的顶部将自由的Configuration机制（YAML文件）和Web UI（以及相应的API）紧密地耦合作为服务提供。对于我作为平台进行这些产品，他们需要通过API来增长TOSchedule任意计算的能力，而不会被正式支持的框正式支持。 Gitlab几乎存在（欺诈缺失链接是一个安排内联定义的流水线API）。 ITIS未知，如果github是 - 或甚至感兴趣 - 追求这一方针。 （更多在稍后。）</p><p>  I wanted to just mention Taskcluster in passing as a counterexample to theCI offerings that GitHub, GitLab, and others are pursuing. But I found myselfheaping praises towards it, so you get a full section on Taskcluster. Thiscontent isn&#39;t critical to the overall post, so feel free to skip. But ifyou want to know what a CI platform built for engineers looks like or youare a developer of CI platforms and would like to read about some worthwhileideas to steal, keep reading.</p><p>  我想提到TaskCluster作为一个Consterexample到TheCi提供，即Github，Gitlab和其他人正在追求。但我发现了自己的赞美，所以你可以在TaskCluster上获得完整的部分。 ThisContent ISN＆＃39; t对整个帖子至关重要，所以随意跳过。但是，如果你想知道为工程师建造的CI平台看起来像或youare一个CI平台的开发人员，并希望阅读一些有价值的东西来窃取，继续阅读。</p><p> Mozilla&#39;s  Taskcluster is a generic CIplatform originally built for Firefox. At the time it was conceived andinitially built out in 2014-2015, there was nothing else quite like it.And I&#39;m still not aware of anything that can match its raw capabilities.There might be something proprietary behind corporate walls. But nothingclose to it in the open source domain. And even the proprietary CI platformsI&#39;m aware of often fall short of Taskcluster&#39;s feature list.</p><p> Mozilla＆＃39; s taskcluster是最初为Firefox构建的通用Ciplatform。在2014-2015在2014  -  2015年建立了Anytinitive地建造的时候，仍然没有别的东西。我仍然没有意识到任何可以匹配其原始能力的东西。在公司墙壁后面可能是专有的东西。但是在开源域中的没事。甚至是专有的CI平台＆＃39; M意识到经常倒下TaskCluster＆＃39; S功能列表。</p><p> To my knowledge, Taskcluster is the only publicly available, megaproject scale, true  CI platform in existence.</p><p> 据我所知，TaskCluster是唯一可公开的Megaproject规模，真正的CI平台。</p><p> Germane to this post, one thing I love about Taskcluster is its coreprimitives around defining execution units. The core execute primitive inTaskcluster is a  task.Tasks are connected together to form a DAG. (This is not unlike how abuild system works.)</p><p> Germane对此帖子，我喜欢TaskCluster的一件事是它在定义执行单元周围的CorePrimitive。核心执行原始IntaskCluster是任务。要联系在一起以形成DAG。 （这与Abuild系统如何运作并非不同。）</p><p> A  task is created by issuing an API request to a  queue service. ThatAPI request essentially says  schedule this unit of work.</p><p> 通过向队列服务发出API请求来创建任务。据章节要求基本上说安排这个工作单位。 </p><p> Tasks are definedsomewhat generically, essentially as units of arbitrary compute along with metadata,such as task dependencies, permissions/scopes that task has, etc. That unit of workhas many of the primitives that are familiar to you if you use GitHub Actions,GitLab Pipelines, etc: a list of commands to execute, which Docker image toexecute in, paths to files constituting artifacts, retry settings, etc.</p><p>任务是常工的，基本上是任意计算的单位以及元数据，例如任务依赖性，权限/范围，任务所拥有的。如果您使用GitHub操作，Gitlab Pipelines的许多原语项，则为您熟悉的原语。等：执行要执行的命令列表，occker映像opteecute，构成工件，重试设置等的文件的路径。</p><p>  For example, Taskcluster offers an IAM-like scopes feature thatmoderates access control. Scopes control what actions you can perform, whatservices you have access to, which runner features you can use (e.g. whetheryou can use ptrace), which secrets you have access to, and more. As a concreteexample, Firefox&#39;s Taskcluster settings are such that the cryptographickeys/secrets used to sign Firefox builds are inaccessible to untrusted tasks(like the equivalent of tasks initiated by PRs - the  Try Server in Mozillaspeak). Taskcluster is the only CI platform I&#39;m aware of that has sufficientprotections in place to mitigate the fact that CI platforms are gaping  remotecode execution as a service risks that can and should keep your internalsecurity and risk teams up at night. Taskcluster&#39;s security model makesGitHub Actions, GitLab Pipelines, and other commonly used CI services looklike data exfiltration and software supply chain vulnerability factories bycomparison.</p><p>  例如，TaskCluster提供了IAM类似的示波器功能，即odederates访问控制。范围控制您可以执行的操作，您可以使用的操作，您可以使用哪种跑步者功能（例如，是否可以使用Ptrace），您可以访问的秘密等等。作为一个Concreteexample，Firefox＆＃39; s taskCluster设置是为了签署Firefox构建的加密标记/秘密无法对不受信任的任务无法访问（如PRS启动的等效任务 -  Mozillaspeak中的Try Server）。 TaskCluster是唯一的CI平台I＆＃39; m意识到这有足够的保护，以减轻CI平台距离remotecode执行作为可以并且应该在晚上保持内部安全和风险队伍的服务风险的事实。 TaskCluster＆＃39; S安全模型是制造的，Gitlab管道和其他常用的CI服务Looklike Data Exfiltration和软件供应链漏洞工厂Bycomparison。</p><p> Taskcluster does support adding a YAML file to your repository to define tasks.However, because there&#39;s a generic scheduling API, you don&#39;t need to use it andyou aren&#39;t constrained by its features. You could roll your ownconfiguration/frontend for defining tasks: Taskcluster doesn&#39;t care because it isa true  platform. In fact, Firefox mostly eschews this Taskcluster YAML, insteadbuilding out its own functionality for defining tasks. There&#39;s a pile of codechecked into the Firefox repository that when run will derive the thousands ofdiscrete tasks constituting Firefox&#39;s build and release DAG and will register theappropriate sub-graph as Taskcluster tasks. (This also happens to be a pile of YAML.But the programming primitives and control flow are largely absent from YAML files,making it a bit cleaner than the  YAML DSL that e.g. GitHub and GitLab CIYAML has evolved into.) This functionality is its own mini build system wherethe Taskcluster platform is the execution/evaluation mechanism.</p><p> TaskCluster确实支持将yaml文件添加到存储库以定义任务。无论何种，因为都有一般调度API，您不需要使用它，而且您需要使用它。您可以为定义任务滚动您的自己的配置/前端：TaskCluster不受关心，因为它是真正的平台。实际上，Firefox大多避免了这个TaskCluster Yaml，而是为了定义任务而不是建造自己的功能。在Firefox储存库中有一堆CodeChecked，当运行时，运行将导出成千上万的核糖任务，构成Firefox＆＃39; s构建和释放DAG，并将将TheAppr为TaskCluster任务注册。 （这也恰好是一堆yaml.But，编程原语和控制流程主要来自YAML文件，使其比Github和Gitlab Ciyaml发出的yaml DSL更清晰。）这个功能是它的迷你构建系统，何时任务集团平台是执行/评估机制。</p><p> Taskcluster&#39;s model and capabilities are vastly beyond anything in GitHubActions or GitLab Pipelines today. There&#39;s a lot of great ideas worth copying.</p><p> TaskCluster＆＃39; S模型和功能在今天的Githubation或Gitlab管道中大大超出任何东西。有很多值得复制的很多伟大想法。</p><p> Unfortunately, Taskcluster is very much a power user CI offering. There&#39;s nocentralized instance that anyone can use (unlike GitHub or GitLab). The learningcurve is quite steep. All that power comes at a cost of complexity. I can&#39;t ingood faith recommend Taskcluster to casual users. But if you want to host yourown CI platform, other CI offerings don&#39;t quite cut it for you, and you canafford a few people to support your CI platform on an ongoing basis (i.e. yourtotal cost to operate CI including people and machines is &gt;$1M annually), thenTaskcluster is worth considering.</p><p> 不幸的是，TaskCluster非常有用用户CI产品。有任何人都可以使用的（与GitHub或Gitlab不同）的那些不向下的实例。学习很陡峭。所有权力都以复杂性的成本为止。我可以＆＃39; t indood faith推荐Task Cluster到休闲用户。但如果您想承载您的CI平台，其他CI产品不适合您，您可以在持续的基础上削减少数人支持您的CI平台（即在包括人员和机器的CI营业费用＆gt;每年1美元，ThentaskCluster值得考虑。</p><p>   In my ideal world there exists a single  remote code execution as a serviceplatform purpose built for servicing both near real time and batch/delayedexecution. It is probably tailored towards supporting software development,as those domain specific features set it apart from generic compute as aservice tools like Kubernetes, Lambda, and others. But something moregeneric could potentially work.</p><p>   在我的理想世界中，存在单个远程代码执行作为SerficePlatform目的，用于在近实时和批量/ delayedexecution进行维修。它可能针对支持软件开发来定制，因为这些域特定功能将其与通用计算除以kubernetes，lambda等的仿制工具。但是更多的东西可能是有效的。</p><p> The concept of a DAG is strongly baked into the execution model so you candefine execution units as a graph, capturing dependencies. Sure, you coulddefine isolated, ad-hoc units of work. But if you wanted to define a setof units, you could do that without having to run a persistent agent tocoordinate execution through completion like build systems typically do.(Think of this as  uploading your DAG to an execution service.)</p><p> DAG的概念强烈烘焙到执行模型中，因此您将烛台执行单位作为图形，捕获依赖项。当然，你可以孤立的孤立，ad-hoc单位的工作。但是如果您想定义一个SETOF单元，则可以通过建立系统通常会执行，而无需运行持久代理互象执行。（将此视为将DAG上载到执行服务。） </p><p> In my ideal world, there is a single DAG dictating all build, testing, andrelease tasks. There is no DAG fragmentation at the build, CI, and otherbatch execute boundaries. No N+1 system or configuration to manage andadditional platform to maintain because everything is unified. Economiesof scale applies and overall efficiency improves through consolidation.</p><p>在我理想的世界中，有一个单一的表现，决定了所有构建，测试，andrelease任务。构建，CI和oftroptebatch执行边界中没有DAG碎片。没有n + 1系统或配置来管理AndAditional平台以维护，因为一切都统一。经济尺度适用和整体效率通过整合提高。</p><p> The platform consists of pools of workers running agents capable ofperforming work. There are probably pools for near real time / synchronousRPC style invocations and pools for scheduled / delayed / asynchronousexecution. You can define your own worker pools and bring your own workers.Advanced customers will likely throw autoscaling groups consisting ofhighly ephemeral workers (such as EC2 spot instances) at these pools,scaling capacity to meet demand relatively cheaply, terminating workersand machines when capacity is no longer needed to save on billingcosts (this is what Firefox&#39;s Taskcluster instance has been doing for atleast 6 years).</p><p> 该平台包括运行有能力工作的工人的工人池。可能有可能靠近实时/ Synchronousrpc样式调用和池的池，用于计划/延迟/异步/异步。您可以定义自己的工人池并带来自己的工人。advanced客户可能会在这些池中抛出由高速暂时工作人员（如EC2点实例）组成的自动播放团体，缩放能力相对便宜，终止工人和机器时的需求量在比赛中保存需要更长的是（这是Firefox＆＃39; TaskCluster实例已经至少为6年来做些什么）。</p><p> To end-users, a  local build consists of driving or scheduling the subsetof the complete task graph necessary to produce the build artifacts youneed. A  CI build/test consists of the subset of the task graph necessaryto achieve that (it is probably a superset of the  local build graph). Samefor releasing.</p><p> 对于最终用户，本地构建包括驾驶或安排生成构建工件所需的完整任务图所需的子集。 CI构建/测试由达到的任务图的子集组成（它可能是本地构建图的超集）。与释放相片。</p><p> As for the configuration frontend and how execution units are defined, thisplatform only needs to provide a single thing: an API that can be used toschedule/execute work. However, for this product offering to be user-friendly,it should offer something like YAML configuration files like CI systems dotoday. That&#39;s fine: many (most?) users will stick to using the simplifiedYAML interface. Just as long as power users have an escape/scaling vectorand can use the low-level schedule/execute API to write their own driver.People will write plug-ins for their build systems enabling it to integratewith this platform. Someone will coerce existing extensible build systemslike Bazel, Buck, and Gradle to convert nodes in the build graph tocompute tasks in this platform. This unlocks the unification of the buildand CI systems (and maybe things like data pipelines too).</p><p> 至于配置前端以及执行单位的定义方式，opplatform仅需要提供单件事：可以使用TOSchedule /执行工作的API。但是，对于本产品提供用户友好，它应该提供像CI Systems Dotoday等yaml配置文件等类似的东西。那个＆＃39; s精细：许多（大多数？）用户将坚持使用simpleifiedyaml接口。只要电力用户拥有逃生/缩放vecordand，可以使用低级计划/执行API来编写自己的驱动程序.People将为其构建系统编写插件，使其能够集成该平台。有人将强迫现有的可扩展构建Systemslike Bazel，Buck和Gradle，以将构建图中的节点转换为此平台中的组合任务。这解锁了Buildand CI系统的统一（也可能像数据流水线一样）。</p><p> Finally, because we&#39;re talking about a specialized system tailored forsoftware development, we need robust result/reporting APIs and interfaces.What good is all this fancy distributed remote compute if nobody can seewhat it is doing? This is probably the most specialized service of the bunch,as how you track results is exceptionally domain specific. Power users maywant to build their own result tracking service, so keep that in mind. Butthe platform should provide a generic one (like what GitHub Actions and GitLabPipelines do today) because it is a massive value add and few will useyour product without such a feature.</p><p> 最后，因为我们谈论了一个专门的系统量身定制的专业系统，我们需要强大的结果/报告API和界面。如果没有人可以看到什么，那么这个花哨的分布式远程计算是什么好的。这可能是群体中最专业的服务，以及如何跟踪结果的特定于域。电力用户可能会建立自己的结果跟踪服务，所以请记住这一点。但是，平台应该提供一般的（就像今天的GitHub动作和Gitlabpipelines一样），因为它是一个大幅增加，但很少将使用没有这样的功能。</p><p> Quickly, my proposed unified world will not alleviate the CI complexity concernsraised above: sufficiently large build/CI systems will always have an intrinsiccomplexity to them and possibly require specialists to maintain. However,because a complex CI system is almost always attached to a complex build system,by consolidating build and CI systems, you reduce the surface area of complexity(you don&#39;t have to worry about build/CI interop as much). Lower fragmentationreduces overall complexity, and is therefore a new win. (A similar line ofthinking applies to justifying monorepositories.)</p><p> 迅速，我拟议的统一世界不会缓解上面的CI复杂性：足够大的Build / CI系统将始终对它们具有内在复杂性，并且可能需要专家维护。但是，由于复杂的CI系统几乎总是附加到复杂的构建系统，因此通过整合构建和CI系统，您将减少复杂性的表面积（您不必担心构建/ CI互操作性）。降低碎片化整体复杂性，因此是一个新的胜利。 （类似的线路kinging适用于单机数据库。）</p><p> All of the components for my vision exist in some working form today.Bazel, Gradle Enterprise, and other modern build systems have RPCs forremote execute and/or caching. They are even extensible and you can writeyour own plugins to change core functionality for how the build system runs(to varying degrees of course). CI offerings like Taskcluster and GitLabPipelines support scheduling DAGs of tasks (with Taskcluster&#39;s support farmore suited for the desired end state). There are batch job executionframeworks li</p><p> 我的愿景的所有组件都存在于今天的一些工作形式.Bazel，Gradle Enterprise和其他现代构建系统的RPCS ForRemote执行和/或缓存。它们甚至是可扩展的，您可以撰写自己的插件来更改构建系统如何运行的核心功能（当然不同程度）。 CI产品如TaskCluster和Gitlabpipelines支持安排任务的DAG（具有适合所需末端状态的TaskCluster＆＃39; Suppor Arturore）。有批作业executionframeworks li </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gregoryszorc.com/blog/2021/04/07/modern-ci-is-too-complex-and-misdirected/">https://gregoryszorc.com/blog/2021/04/07/modern-ci-is-too-complex-and-misdirected/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ci/">#ci</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>