<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#类型</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#类型</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1047807.html">打字很难 </a></div><div class="item_title_en"><a target="_blank" href="https://3fx.ch/typing-is-hard.html">Typing Is Hard</a><span>(3fx.ch)</span></div><span class="my_story_list_date">2021-2-17 18:35</span><div class="my_story_list_item_desc">类型检查是使用某种编程语言编写给定程序并确定所有变量和表达式是否具有正确类型的过程，即将字符串分配给字符串，算术表达式仅包含数字等。某些语言还提供类型推断，任务分配编译器的任务是自己找出正确的类型。根据语言的功能，类型检查和类型推断问题的范围从琐碎的到不确定的。
       如果对于任何输入我们都可以计算输入是否可......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/打字/">#打字</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/typing/">#typing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1047799.html">丰托里奥 </a></div><div class="item_title_en"><a target="_blank" href="https://bartoszmilewski.com/2021/02/16/functorio/.">Functorio</a><span>(bartoszmilewski.com)</span></div><span class="my_story_list_date">2021-2-17 18:32</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1047799.html"><img src="http://img2.diglog.com/img/2021/2/thumb_ee4502357b828ede11513e76b9052cb9.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">您可能已经听说过人们说函数式编程更具学术性，而实际的工程则以命令式进行。我将向您展示真正的工程是可行的，并且我将使用由工程师为工程师设计的计算机游戏来说明这一点。这是一个名为Factorio的模拟游戏，在其中您将获得探索，建立处理它们的工厂，创建越来越复杂的系统的资源，直到最终能够发射可能将您带离荒凉星球的太空船。如......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/functorio/">#functorio</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1046174.html">Python类型检查文艺复兴 </a></div><div class="item_title_en"><a target="_blank" href="https://dafoster.net/articles/2021/01/26/python%27s-type-checking-renaissance/">Python's Type Checking Renaissance</a><span>(dafoster.net)</span></div><span class="my_story_list_date">2021-1-28 22:10</span><div class="my_story_list_item_desc">您可能听说过，TypeScript在过去几年中一直席卷Web开发领域，带来了静态类型。我相信，在Python世界中，同样的事情开始发生，在这种世界中，越来越多地使用诸如mypy，Pyre和Pyright之类的类型检查器，至少在公司使用Python编写大型系统的地方。
 对于Python的最后几个发行版，各种PEP向每......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/type/">#type</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1045445.html">动态类型系统甚至没有更简单 </a></div><div class="item_title_en"><a target="_blank" href="https://hisham.hm/2020/01/20/dynamic-type-systems-arent-even-simpler/">Dynamic type systems aren’t even simpler</a><span>(hisham.hm)</span></div><span class="my_story_list_date">2021-1-21 6:4</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1045445.html"><img src="http://img2.diglog.com/img/2021/1/thumb_224804ad769abdd559c7f8dfbe53a170.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">亚历克西斯·金（Alexis King）刚刚发表了一篇很棒的博客文章，标题为“不，动态类型系统本质上并不开放”。
 这让我想起了我去年在FOSDEM上发表的名为“极简主义与类型”的演讲，在该演讲中，我从稍微不同的角度主张静态类型。我试图说服人们，动态类型程序中的类型通常比人们意识到的要复杂。而且通常比典型的静态类型语......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/type/">#type</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1045198.html">螺旋语言v2 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/mrakgr/The-Spiral-Language#12242020">The Spiral Language v2</a><span>(github.com)</span></div><span class="my_story_list_date">2021-1-20 4:7</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1045198.html"><img src="http://img2.diglog.com/img/2021/1/thumb_c5dc5dbeb50a2947118998eb61f26764.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">v0.2现在只是v2.0。这种版本控制方式将与VS Code市场的方式更好地配合使用，即＆lt; major＆gt;。＆lt; minor＆gt;。＆lt; patch＆gt;。我想保留将来升级次要版本的选项。如果0.2冻结了主要和次要字段，那将无法正常工作。
 接下来是文档。实际上，该语言的测试阶段应该花更长的时间......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/language/">#language</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1044758.html">转换运算符名称查找的乐趣 </a></div><div class="item_title_en"><a target="_blank" href="https://quuxplusone.github.io/blog/2021/01/13/conversion-operator-lookup/">Fun with conversion-operator name lookup</a><span>(quuxplusone.github.io)</span></div><span class="my_story_list_date">2021-1-18 2:16</span><div class="my_story_list_item_desc">在撰写本文时（但可能不会持续很长时间！），Godbolt Compiler Explorer的四个主流编译器对此简单的C ++程序给出了四个不同的答案：
 结构A {使用T = T1;使用U = U1;运算符U1 T1 :: *（）;运算符U1 T2 :: *（）;运算符U2 T1 :: *（）;运算符U2 T2 :......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/运算符/">#运算符</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1043996.html">为什么Haskell是我们构建生产软件系统的首选 </a></div><div class="item_title_en"><a target="_blank" href="https://www.foxhound.systems/blog/why-haskell-for-production/">Why Haskell is our first choice for building production software systems</a><span>(www.foxhound.systems)</span></div><span class="my_story_list_date">2021-1-11 20:37</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1043996.html"><img src="http://img2.diglog.com/img/2021/1/thumb_03501e894a662d9cf1fad7029c46919b.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Haskell是我们在构建生产软件系统时使用的第一种编程语言。对于只对该语言有过熟经验的人来说，这似乎很不寻常。 Haskell以其先进的语言和陡峭的学习曲线而闻名。它也经常被认为是一种实用性有限的研究语言。
 虽然Haskell确实具有非常大的表面积，但许多其他语言的程序员可能不熟悉许多概念和语法，但它在开发人员生......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/构建/">#构建</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/choice/">#choice</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1042428.html">R中的Lambda.r函数式编程 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/zatonovo/lambda.r">Lambda.r Functional Programming in R</a><span>(github.com)</span></div><span class="my_story_list_date">2020-12-30 2:10</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1042428.html"><img src="http://img2.diglog.com/img/2020/12/thumb_242536e68901773d70ba63d163290c6d.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">提供用于在R中编写功能程序的语法.Lambda.r具有cleansyntax，用于使用可选的保护语句定义多部分功能。还支持简单模式匹配。可以使用相同的功能符号轻松定义和实例化类型。类型检查是集成的和可选的，从而使程序员在其应用程序或程序包上具有完全的灵活性。
   使用％as％表示法定义功能。函数定义中可以包含任何代......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lambda/">#lambda</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041881.html">在RBS中采用Ruby 3类型 </a></div><div class="item_title_en"><a target="_blank" href="https://evilmartians.com/chronicles/climbing-steep-hills-or-adopting-ruby-types">Adopting Ruby 3 types with RBS</a><span>(evilmartians.com)</span></div><span class="my_story_list_date">2020-12-26 11:21</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1041881.html"><img src="http://img2.diglog.com/img/2020/12/thumb_feb0307586085b572c07461c5885df6e.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">随着Ruby 3.0的发展，我们来看看即将发布的版本的亮点之一：Ruby Type Signatures。是的，类型正在成为我们最喜​​欢的动态语言！让我们看看如何通过将类型添加到现实世界的开源项目中并查看流程的更详细点来利用它们。
 这不是我第一次涉及Ruby类型：大约一年前，我第一次体验了Sorbet，并在同一个......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041808.html">使用类型保证域不变式 </a></div><div class="item_title_en"><a target="_blank" href="https://www.lpalmieri.com/posts/2020-12-11-zero-to-production-6-domain-modelling/">Using Types to Guarantee Domain Invariants</a><span>(www.lpalmieri.com)</span></div><span class="my_story_list_date">2020-12-26 1:54</span><div class="my_story_list_item_desc">在Rust中实现零生产是对Rust后端开发的自以为是的介绍。您可以在zero2prod.com上预订该书。订阅新闻通讯，以在发布新剧集时得到通知。
   我们的新闻通讯API是实时的，托管在Cloud提供商上。我们有一套基本的工具来解决可能出现的问题。有一个公开的端点（POST / subscriptions）可以订......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/guarantee/">#guarantee</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041662.html">在CPython中，用C实现的类型是类型树的一部分 </a></div><div class="item_title_en"><a target="_blank" href="https://utcc.utoronto.ca/~cks/space/blog/python/CPythonCTypesHaveTree">In CPython, types implemented in C are part of the type tree</a><span>(utcc.utoronto.ca)</span></div><span class="my_story_list_date">2020-12-25 0:36</span><div class="my_story_list_item_desc">从理论上讲，在Python中，所有类型都源自对象（它们是对象的直接或间接子类）。多年来，我一直相信（并书面认为）在实现级别上，对于用CPython用本机C代码编写的类型（Python的标准实现以及您可能正在使用的一种）而言，情况并非如此。用Cmight编写的类型的行为就好像它们是对象的后代一样，但是我认为它们的行为实......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/types/">#types</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041417.html">高级TypeScript类型技巧 </a></div><div class="item_title_en"><a target="_blank" href="https://casualdeveloper.net/post/2020-12-21-advanced-typescript-type-tricks/">Advanced TypeScript Type Tricks</a><span>(casualdeveloper.net)</span></div><span class="my_story_list_date">2020-12-23 21:12</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1041417.html"><img src="http://img2.diglog.com/img/2020/12/thumb_ec0ad71bc573ec8f829afc5858c2bb69.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在TypeScript中花了一些时间之后，您可能会开始渴望生活中到处的类型安全。 JavaScript本质上是一种不安全的语言，几乎在每个框架中到处都有龙。大多数框架已被充分介绍，但是如果您在内部设计一个漂亮的API，那么它需要具有令人难以置信的功能丰富和令人难以置信的安全性，但仍需要最好的JavaScript习惯用......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041133.html">龙虾编程语言 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/aardappel/lobster">The Lobster Programming Language</a><span>(github.com)</span></div><span class="my_story_list_date">2020-12-22 5:8</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1041133.html"><img src="http://img2.diglog.com/img/2020/12/thumb_da2f3d93ae3232f1c6fa29c3029b2eb1.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">龙虾（Lobster）是一种静态类型的编程语言，带有Python式语法，通过为您完成大部分繁重的工作，将表现型类型系统和编译时内存管理的优点与非常轻巧，友好而精巧的语法相结合。 </div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/龙虾/">#龙虾</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041035.html">Ruby 3.0.0 RC1发布 </a></div><div class="item_title_en"><a target="_blank" href="https://www.ruby-lang.org/en/news/2020/12/20/ruby-3-0-0-rc1-released/">Ruby 3.0.0 RC1 Released</a><span>(www.ruby-lang.org)</span></div><span class="my_story_list_date">2020-12-21 22:5</span><div class="my_story_list_item_desc">类型检查器（包括TypeProf和其他支持RBS的工具）将通过RBS定义更好地理解Ruby程序。
 您可以写下类和模块的定义：类中定义的方法，实例变量及其类型以及继承/混合关系。
 RBS的目标是支持Ruby程序中常见的模式，它允许编写高级类型，包括联合类型，方法重载和泛型。它还支持带有接口类型的鸭子输入。
 Rub......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rc1/">#rc1</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1040019.html">Foo to Bar：Haskell中的命名约定 </a></div><div class="item_title_en"><a target="_blank" href="https://kowainik.github.io/posts/naming-conventions">Foo to Bar: Naming Conventions in Haskell</a><span>(kowainik.github.io)</span></div><span class="my_story_list_date">2020-12-16 14:53</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1040019.html"><img src="http://img2.diglog.com/img/2020/12/thumb_7aa7350e7964a3de12bc7988c038a9dd.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">开发人员将大部分时间花在阅读，理解和探索使用现有解决方案的其他方式上。坦白说，在我们的职业中，几乎没有时间在现实生活中实际编写新库和创建新接口。因此，在最常见的活动中获得帮助非常重要。命名约定就是这样一种事情，如果达成共识并在全球范围内推广，则可以提高可读性并降低使用成本。
 某些语言具有自己有意义的特殊命名约定。 ......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/bar/">#bar</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1039796.html">Nexus 1.0：类型安全，代码优先GraphQL API的主要版本 </a></div><div class="item_title_en"><a target="_blank" href="https://www.prisma.io/blog/announcing-the-release-of-nexus-schema-v1-b5eno5g08d0b">Nexus 1.0: A Major Release for Type-Safe, Code-First GraphQL APIs</a><span>(www.prisma.io)</span></div><span class="my_story_list_date">2020-12-15 16:44</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1039796.html"><img src="http://img2.diglog.com/img/2020/12/thumb_4fd512bb8fa4e1811cf790f0e93b230e.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Nexus是最初由Tim Griesser创作的库，它使开发人员可以构建代码优先和类型安全的GraphQL API。 Prisma两年来一直是该库的核心贡献者，并帮助塑造了它的发展。
  此版本是杰出社区反馈和贡献的结晶，是Nexus在生产中经过多年的实战测试的结果，也是对为那些为GraphQL API的开发人员创造......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/graphql/">#graphql</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1039356.html">瞄准类型的正确性 </a></div><div class="item_title_en"><a target="_blank" href="https://fasterthanli.me/articles/aiming-for-correctness-with-types">Aiming for Correctness with Types</a><span>(fasterthanli.me)</span></div><span class="my_story_list_date">2020-12-13 6:32</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1039356.html"><img src="http://img2.diglog.com/img/2020/12/thumb_99194f67e5542018f2c1c325832cade0.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">《自然》科学周刊于1869年首次出版。一个半世纪之后，它通过发表一篇有关Rust编程语言的文章，终于完成了一个癌变周期。
  我对本文的喜欢之处在于，它不仅谈论性能，甚至谈论内存安全，还谈论了正确性。
 好吧，它也谈到了多样性和包容性，我认为这也是极其重要的，但这不是语言的内在品质，更不是一种事态-我们不能认为这是人......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1039060.html">夜锈病的单子和GAT </a></div><div class="item_title_en"><a target="_blank" href="https://www.fpcomplete.com/blog/monads-gats-nightly-rust/">Monads and GATs in Nightly Rust</a><span>(www.fpcomplete.com)</span></div><span class="my_story_list_date">2020-12-11 16:15</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1039060.html"><img src="http://img2.diglog.com/img/2020/12/thumb_fa1c37c85d903a06c4e4bfd950f8a48c.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这篇博客文章的灵感完全来自于每晚阅读GAT！ / d / C5H5N5O的Reddit帖子。我只是决定把事情做得有点过头，并认为关于它的博客文章会很有趣。我想从一开始就很清楚：我在这篇文章中介绍了一些高级概念，这些概念依赖于Rust中的不稳定功能。我根本不主张使用它们。我只是在探索GAT可能和不可能的事情。
 Rus......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/锈病/">#锈病</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gats/">#gats</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1038354.html">为什么是可空类型？ </a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/dartlang/why-nullable-types-7dd93c28c87a">Why Nullable Types?</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-12-8 10:58</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1038354.html"><img src="http://img2.diglog.com/img/2020/12/thumb_d0ac1494563e306aafe8b8f3aababd46.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">几周前，我们发布了Dart null安全测试版，这是一项主要的生产力功能，旨在帮助您避免null错误。说到空值，用户最​​近在/ r / dart_lang subreddit中询问：
 但是，为什么我们仍然有/想要空值？为什么不彻底摆脱它呢？我目前也在玩Rust，它根本没有null。因此，似乎没有它就可以生存。
 ......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nullable/">#nullable</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1038121.html">Rust中几何代数的消失零 </a></div><div class="item_title_en"><a target="_blank" href="https://fanf.dreamwidth.org/134024.html">Vanishing zeroes for geometric algebra in Rust</a><span>(fanf.dreamwidth.org)</span></div><span class="my_story_list_date">2020-12-7 3:18</span><div class="my_story_list_item_desc">这些是关于我上周对Rust所做的一些说明，在此过程中，我进行了一些高度实验性的工作，结果很可能会变得过于复杂。 （我很想知道其他编程语言以及Rust的其他实现方法！）但是它涉及一些很酷的想法-抽象解释，Rust中的类型级别编程，自动优化的数据结构以及一些3D图形的几何代数-和我想分享我学到的东西。
  另外：这些注释......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/zeroes/">#zeroes</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037962.html">类型理论和类型检查器的入门指南 </a></div><div class="item_title_en"><a target="_blank" href="https://mukulrathi.co.uk/demystifying-deep-learning/backpropagation-computation-graph-lstm/">An accessible introduction to type theory and implementing a type-checker</a><span>(mukulrathi.co.uk)</span></div><span class="my_story_list_date">2020-12-6 4:31</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1037962.html"><img src="http://img2.diglog.com/img/2020/12/thumb_a75d0dadef02cd93a35dd0af826da56e.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">到目前为止，在本系列文章中，我们已经研究了梯度下降的一般原理，以及如何计算前馈神经网络中每一层的反向传播，然后概括了一下CNN中不同类型层的反向传播。
 现在，我们将退后一步，从更一般的意义上来看反向传播-通过计算图。通过这一过程，我们将大致了解框架如何计算其
 我们将使用LSTM单元作为激励示例-继续对IMDB评论......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/type/">#type</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/计算/">#计算</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037915.html">std :: visit是现代C ++的所有错误（2017） </a></div><div class="item_title_en"><a target="_blank" href="https://bitbashing.io/std-visit.html">std::visit is everything wrong with modern C++ (2017)</a><span>(bitbashing.io)</span></div><span class="my_story_list_date">2020-12-5 22:9</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1037915.html"><img src="http://img2.diglog.com/img/2020/12/thumb_50a96ec38224a65e065993b6f8c5b389.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">一个求和类型，也称为区分联合，可以容纳几种类型的事物中的一种（并且只有一种），例如，考虑类似INI的配置文件中的某些设置，假设每个设置必须是一个字符串，一个整数或布尔值。如果要在C ++中推出自己的解决方案，我们可能会写类似以下内容：
 结构设置{union {字符串str;整数;布尔b; };枚举类型{Str，In......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/visit/">#visit</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037447.html">四种类型的汉字（2019） </a></div><div class="item_title_en"><a target="_blank" href="https://learnjapanesebest.wordpress.com/2019/12/11/the-four-types-of-kanji/">Four Types of Kanji (2019)</a><span>(learnjapanesebest.wordpress.com)</span></div><span class="my_story_list_date">2020-12-4 20:32</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1037447.html"><img src="http://img2.diglog.com/img/2020/12/thumb_9cb818c3665e45455227ccec195377ac.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">构成大部分日语文字的表意文字汉字有四种粗略类型。象形文字，指示符，组合符号以及含义和声音借用者。
 第一种是象形文字，代表它们所代表的实际事物。一些研究人员声称，实际上不到4％的是象形文字。
     人biped（人类）女女人手手田稻田子孩子日日月月门门山山川弓弓（如“弓箭”）火戸日式门口口，入口水水雨雨竹竹木树木......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/types/">#types</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/汉字/">#汉字</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037116.html">Nim编译器— Pascal源代码</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/nim-lang/Nim/tree/ea1f1ec6d4d6c776eb0f81c2bebdd4cb4c817ebe/nim">Nim compiler — Pascal source code</a><span>(github.com)</span></div><span class="my_story_list_date">2020-11-29 16:5</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1037116.html"><img src="http://img2.diglog.com/img/2020/11/thumb_025b67dc2053e70abacf6317da9484ff.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Nim是一种静态类型的编译系统编程语言。它结合了来自成熟语言（如Python，Ada和Modula）的成功概念。其设计注重效率，表达力，...</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036720.html">解析，不进行类型检查</a></div><div class="item_title_en"><a target="_blank" href="https://neilmadden.blog/2020/11/25/parse-dont-type-check/">Parse, Don’t Type-Check</a><span>(neilmadden.blog)</span></div><span class="my_story_list_date">2020-11-26 23:13</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1036720.html"><img src="http://img2.diglog.com/img/2020/11/thumb_7cf484ceeae6bc7fc2161eddc603cd15.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">去年有一篇很棒的文章，标题为Parse，请不要验证。我强烈推荐给任何程序员（以及最近的后续更新，名称不是类型安全的）。基本思想是有两种方法可以检查对函数的某些输入是否有效：
 验证器检查输入是否有效，如果无效，则引发错误。它不会返回任何东西。例如，检查列表是否为空。
 解析器的作用与验证器相同，但是返回输入的更特定的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/don/">#don</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036711.html">存在的Haskell</a></div><div class="item_title_en"><a target="_blank" href="https://blog.sumtypeofway.com/posts/existential-haskell.html">Existential Haskell</a><span>(blog.sumtypeofway.com)</span></div><span class="my_story_list_date">2020-11-26 22:6</span><div class="my_story_list_item_desc">大多数软件工程文献将面向对象的编程描绘为与功能编程不同，并且常常与功能编程不相容。当然，这是错误的二分法，因为函数式编程所鼓励的技术甚至适用于大多数面向对象的语言。然而，面向对象（可能是历史上最受欢迎的软件范例）已经普及了其宗旨，有时甚至可以看到它们出现在像Haskell这样的编程语言中，该语言与面向对象的哲学尽可能......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/存在/">#存在</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036080.html">播放：静态类型的Forth，编译为WASM</a></div><div class="item_title_en"><a target="_blank" href="https://www.play-lang.dev">Play: Statically typed Forth, compiled to WASM</a><span>(www.play-lang.dev)</span></div><span class="my_story_list_date">2020-11-23 22:39</span><div class="my_story_list_item_desc">Play的语法和语义在很大程度上受到了Forth的启发。这意味着语法是干净的，没有许多控制字符，而语义则由少量但功能强大的规则组成。
    无需赘述，Play中的代码由空格分隔的函数组成，这些函数以从左到右的方式调用。函数调用的一个或多个返回值用作下一个函数调用的输入参数。数字是返回自身的函数。从技术上讲，整个段落......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/静态/">#静态</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1035964.html">焦糖色：OCaml到Erlang编译器</a></div><div class="item_title_en"><a target="_blank" href="https://caramel.abstractmachines.dev">Caramel: An OCaml to Erlang Compiler</a><span>(caramel.abstractmachines.dev)</span></div><span class="my_story_list_date">2020-11-23 2:57</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1035964.html"><img src="http://img2.diglog.com/img/2020/11/thumb_15fa78c8d09d8b30e47163ae4b6e977c.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">焦糖具有高表现力，声音类型系统和快速的类型检查器。这使您可以通过使用更接近您的域的类型来排除整个错误类别，并在不牺牲开发速度的情况下毫不费力地重构大量代码。
  为了实现这一目标，Caramel实际上是OCaml编译器的后端，因此，它重用了整个类型检查堆栈，并进行了25年以上的研究和数百万小时的学术研究和工业使用，并......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ocaml/">#ocaml</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1035919.html">流敏感型</a></div><div class="item_title_en"><a target="_blank" href="https://en.wikipedia.org/wiki/Flow-sensitive_typing">Flow-Sensitive Typing</a><span>(en.wikipedia.org)</span></div><span class="my_story_list_date">2020-11-22 23:0</span><div class="my_story_list_item_desc">跳转至导航跳转至搜索在编程语言理论中，流敏感类型（或流类型）是一种类型系统，其中表达式的类型取决于其在控制流中的位置。
 在静态类型语言中，表达式的类型由组成它的子表达式的类型确定。但是，在流敏感类型中，如果表达式的类型遵循验证其类型的语句，则可以将其类型更新为更特定的类型。通过使用类型推断确定类型，并使用代数数据类......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/sensitive/">#sensitive</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1035595.html">TypeScript 4.1</a></div><div class="item_title_en"><a target="_blank" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/">TypeScript 4.1</a><span>(devblogs.microsoft.com)</span></div><span class="my_story_list_date">2020-11-21 18:11</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1035595.html"><img src="http://img2.diglog.com/img/2020/11/thumb_065a3a9a06a786d7328a931d00589001.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">如果您不熟悉TypeScript，那么它是一种通过在JavaScript上添加类型声明和注释的语法而构建的语言。 TypeScript编译器可以使用此语法对我们的代码进行类型检查，然后输出可在许多不同的运行时上运行的清晰可读的JavaScript。由于TypeScript具有跨编辑器的丰富编辑功能，因此静态类型检查可......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="/tag/类型/">0</a></li><li class="page-item active"><a class="page-link" href="/tag/类型/page1.html">1</a></li><li class="page-item"><a class="page-link" href="/tag/类型/page2.html">2</a></li><li class="page-item"><a class="page-link" href="/tag/类型/page3.html">3</a></li><li class="page-item"><a class="page-link" href="/tag/类型/page4.html">4</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>