<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么你不应该使用（f）lex，yacc和野牛 Why you should not use (f)lex, yacc and bison</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why you should not use (f)lex, yacc and bison<br/>为什么你不应该使用（f）lex，yacc和野牛 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-17 04:24:59</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/409dfc56980e9350c88f244389f9afc4.jpg"><img src="http://img2.diglog.com/img/2021/6/409dfc56980e9350c88f244389f9afc4.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Lex and Yacc were the first popular and efficient lexers and parsers generators, flex and Bison were the first widespread open-source versions compatible with the original software. Each of these software has more than 30 years of history, which is an achievement in itself. For some people these are still the first software they think about when talking about parsing. So, why you should avoid them? Well, we found a few reasons based in our experience developing parsers for our clients.</p><p>Lex和Yacc是第一个流行和高效的Lexers和Parsers发电机，Flex和Bison是与原始软件兼容的第一个广泛的开放源版本。这些软件中的每一个都有30多年的历史，这本身就是一项成就。对于一些人来说，这些仍然是他们在谈论解析时考虑的第一个软件。那么，为什么你应该避开它们？嗯，我们在为客户开发解析器的经验中找到了一些原因。</p><p> For example, we had to work with existing lexers in flex and found difficult adding modern features, like Unicode support or making the lexer re-entrant (i.e., usable in many threads). With Bison our clients had trouble organizing large codebases and we found difficult improving the efficiency of a parser without rewriting large part of the grammar. The short version is that there are tools that are more flexible and productive, like ANTLR.</p><p> 例如，我们必须使用Flex中的现有Lexers，发现难以添加现代功能，如Unicode支持或制作Lexer重新参与者（即，在许多线程中使用）。通过北美野牛，我们的客户无法组织大型码级，我们发现难以提高解析器的效率而不重写语法的大部分。简短的版本是有些工具，更灵活和富有成效，如Antlr。</p><p> The first part of this article explains the history of these two software, while the second one analyze their flaws. If you do not care about their history, you can go to the second part using this handy table of contents.</p><p> 本文的第一部分解释了这两个软件的历史，而第二个分析了缺陷。如果您不关心他们的历史，您可以使用此方便的目录前往第二部分。</p><p>  We start from the beginning, of course. We briefly look at the history of these software.</p><p>  当然，我们从一开始就开始。我们简要介绍了这些软件的历史。</p><p>  Both software have an interesting history, although Yacc’s story looks like a soap opera.</p><p>  虽然YACC的故事看起来像肥皂剧，但这两个软件都有一个有趣的历史。</p><p>  Lex is a lexer generator, that is to say a tool to generate lexical analyzers. In case you do not know what a lexer is, these are the basics. A lexer accepts as input normal text and it organize it in corresponding tokens. All you need to have is a grammar that describes the rules to follow. So, for instance you can tell Lex that any grouping of digits (i.e., [0-9]+ characters) should be classified as an INT. A standalone lexer has few uses, because it basically just organize set of characters into categories. It can be used for things like the recognition of elements of a programming language to perform syntax highlighting. You can read more about the basics of parsing in our article:  A Guide to Parsing: Algorithms and Terminology.</p><p>  Lex是一个Lexer生成器，也就是说一个生成词汇分析仪的工具。如果您不知道Lexer是什么，这些是基础知识。 Lexer接受为输入普通文本，它将其组织在相应的令牌中。您需要的只是一个语法，描述了要遵循的规则。因此，例如，您可以告诉LEX，即任何分组数字（即[0-9] +字符）应被分类为int。独立的Lexer很少使用，因为它基本上只是将一组字符组织成类别。它可以用于识别编程语言的元素，以执行语法突出显示的内容。您可以在文章中阅读有关解析的基础知识：解析的指南：算法和术语。</p><p> Mike Lesk and Eric Schmidt (who later became CEO of Google) developed it as proprietary software in 1975 in C. It was an important software, both for its quality and for the needs of development at that time. In fact it became part of the POSIX standard, essentially any respectable OS needed to have a tool like that.</p><p> Mike Lesk和Eric Sc​​hmidt（后来成为谷歌首席执行官）在1975年开发了它作为专有软件在C中。它是一个重要的软件，既有质量，也是当时的发展需求。实际上它成为POSIX标准的一部分，基本上有任何可爱的操作系统需要这样的工具。 </p><p>  Yacc is a parser generator, specifically a tool to generate LALR parsers. Essentially a parser groups tokens (like the ones generated by Lex) into logical structures. Again, all you need to have is a grammar that describes the rules to follow. For example, you can generate a parser that can take a IDENTIFIER (e.g., a variable), a EQUAL token, and a INT token and understand that together they form an assignment. A parser deals with much more complicated problems than that of a lexer.</p><p>YACC是一个解析器生成器，专门用于生成LALR解析器的工具。基本上是一个解析器组（就像Lex生成的那样）进入逻辑结构。同样，您需要的只是一个描述要遵循的规则的语法。例如，您可以生成一个解析器，该解析器可以采用标识符（例如，变量），等于令牌和int令牌，并理解它们在一起形成分配。解析器涉及比Lexer更复杂的问题。</p><p> Stephen Johnson developed Yacc during the early 1970s, writing (and rewriting) it many times between 1973 and 1978 as proprietary software. He wrote the latest version in C, although initially he wrote in  B. It started as a practical tool to help the development of the B Language. It was continually improved, and effectively also helped developing the theory of parsing. Johnson was a computer scientist that make sure that every trick to improve speed was theoretically sound and based in computer science. That is quite the level of dedication that you do not see in contemporary software. Yacc also became part of the POSIX standard.</p><p> 斯蒂芬约翰逊在20世纪70年代初期开发了YACC，在1973年至1978年作为专有软件之间编写（和重写）许多次。他在C中写了最新版本，尽管他在B中写道。它开始作为帮助发展B语言的实用工具。它不断改进，有效地帮助发展了解析的理论。约翰逊是一位计算机科学家，确保每个提高速度的技巧都是理论上的声音，并将在计算机科学中。这是您在当代软件中没有看到的奉献程度。 YACC也成为POSIX标准的一部分。</p><p> Since Lex is used to generate lexers and Yacc to generate parsers, they were complementary and often used together. They were simply the best software available in their respective niches.</p><p> 由于Lex用于生成Lexers和YACC来生成解析器，因此它们是互补的并且通常一起使用。它们只是他们各自的利基中提供的最好的软件。</p><p>  As mentioned, the initial versions were proprietary software. This means that their use was restricted, which left some users dissatisfied. That is why several open source versions of both software were created. These software were often compatible with the grammars of the original software, but also added their own improvements. The Lex-compatible software that gained prominence was  flex, which is still used today. It uses the BSD License and supports also C++. There are also  countless implementations of Lex in different languages.</p><p>  如上所述，初始版本是专有软件。这意味着他们的使用受到限制，这让一些用户不满意。这就是为什么创建了两个软件的几个开源版本。这些软件通常与原始软件的语法兼容，但也增加了自己的改进。 LEX兼容的软件，获得了突出的是Flex，今天仍然使用。它使用BSD许可证并支持C ++。还有不同语言的Lex无数实施。</p><p> There were two major replacements for Yacc, Berkeley Yacc (byacc) and GNU Bison, the first is in the public domain, while the other obviously use the GPL License. The original author of both software was Robert Corbett and, confusingly, byacc was originally called bison. Furthermore Bison was not originally compatible with Yacc, but it was made compatible by Richard Stallman, which brought it in the GNU world. In the meantime, Corbett rewrote byacc from scratch to be compatible with Yacc. Byacc was originally the most popular version of Yacc-compatible software, but now is GNU Bison (byacc is still developed). There are also  ports of Bison in other languages.</p><p> YACC有两个主要的替代品，伯克利YACC（重叠）和GNU野牛，第一是在公共领域，而另一个明显使用GPL许可证。这两个软件的原作者是罗伯特·科特贝特，令人困惑的是，特征最初是被称为野牛。此外，野牛并不是最初与YACC兼容，但它是由Ri​​chard Stallman兼容的，它在GNU世界中带来了它。与此同时，Corbett通过划痕重写CACC以与YACC兼容。该关系是最初是最受欢迎的YACC兼容软件版本，但现在是GNU北美野牛（仍然发展）。还有其他语言的北美野牛。</p><p> In many ways Yacc was an innovative software, because of its impact on development of parser. Lex was less innovative, however it also had a long lasting influence. You will find that many standalone lexer generators are inspired by Lex. This is both because of its quality and because there is less need for standalone lexers. So, lex-inspired lexer generators are still good enough for common uses.</p><p> 在许多方面，YACC是一种创新的软件，因为它对解析器的发展影响。 Lex不那么创新，但它也有很长的影响力。您会发现许多独立的Lexer生成器由Lex启发。这两者都是因为它的质量，因为没有对独立的失败者的需求。因此，Lex-Inspired Lexer Generators仍然足够好以满足常见用途。</p><p> There are even software that are compatible and replace both Lex and Yacc together, like  PLY in Python.</p><p> 甚至存在兼容的软件，并将LEX和YACC替换在一起，如Python。 </p><p>  Now that the introduction is over, we can see why you should avoid these tools, if you have the chance. We want to avoid just talking about what is possible and ideal, to focus on what is really feasible today. That is why we are going to compare Flex and Bison with a modern parser generator: ANTLR.</p><p>现在介绍结束了，如果您有机会，我们可以看到为什么要避免这些工具。我们希望避免谈论最有可能和理想的事情，专注于今天的真正可行的东西。这就是为什么我们将使用现代解析器生成器：ANTLR比较Flex和Bison。</p><p>  Now that we know the history of these software, we can already imagine some of the problems. These are very old software created to be compatible with even older software. Even worse, their design is based on really old principles that are not best practices today. Can you even imagine the quality of code that was written and fixed for 30 years?</p><p>  现在我们知道这些软件的历史，我们已经可以想象一些问题。这些都是非常古老的软件，以与较旧的软件兼容。更糟糕的是，他们的设计是基于真正的旧原则，这些原则不是今天不是最佳实践。你能想象30年写入和修复的代码质量吗？</p><p> Their main point was, and still is, compatibility with an old codebase. In short, there are mainly three cases to consider:</p><p> 他们的要点是，仍然是与旧码比的兼容性。简而言之，主要有三种情况需要考虑：</p><p> if you have existing parsers in maintenance mode using flex and Bison, it makes sense to keep using them;</p><p> 如果您使用Flex和Bison在维护模式下有现有解析器，则继续使用它们是有意义的;</p><p> if you have existing parsers that are actively developed, you should consider porting them to more productive tools, the effort of porting them will be repaid with greater productivity;</p><p> 如果您有积极开发的现有解析器，您应该考虑将它们移植到更高效的工具，将其移植的努力偿还更高的生产力;</p><p> if you need to develop new parsers from scratch, there are too many downsides in using them and you should opt for more productive tools, like ANTLR</p><p> 如果您需要从头开始开发新的解析器，则使用它们的缺点太多，您应该选择更加富有成效的工具，如antlr</p><p>   Stability and Development of New Features flex and Bison are stable and maintained software but there is no active development. C++ support can be of limited quality.</p><p>   新功能的稳定性和开发Flex和Bison是稳定和维护的软件，但没有积极的发展。 C ++支持可以具有有限的质量。 </p><p> Separation between Grammar and Code  ANTLR is a modern parsing generator tool with a design that favors a portable grammar, usable for multiple target languages</p><p>语法和Code Antlr之间的分离是一款现代解析发电机工具，设计了一种设计，可用于便携式语法，可用于多种目标语言</p><p> Unicode Support  ANTLR does support all flavors of Unicode and even makes easy to select Unicode properties (e.g., Emoji)</p><p> Unicode支持Antlr确实支持所有unicode的样本，甚至可以易于选择Unicode属性（例如，表情符号）</p><p> They Use Different Licenses flex uses a BSD license, while Bison uses the GPL. Bison waive the license for most generated parsers, but it can be a problem</p><p> 它们使用不同的许可证Flex使用BSD许可证，而Bison使用GPL。北美野牛放弃了最生成的解析器的许可证，但这可能是一个问题</p><p>  Features of Lexing Algorithms flex supports regular expressions to define rules, which works for most elements, but adds complexity</p><p>  Lexing algIthms Flex的功能支持定期表达式来定义规则，它适用于大多数元素，但增加了复杂性</p><p> Features of parsing algorithms Bison supports two parsing algorithms that cover all ranges of performance and languages. It gives cryptic error messages</p><p> 解析算法博尔的功能支持两个解析算法，涵盖所有性能和语言的范围。它给出了隐秘的错误消息</p><p>  Flex and Bison are very much stable software. They are maintained, but development of new features is limited, if not absent. Furthermore their code is stable, but not always of great quality. This is especially true if you consider that C and C++ are different languages, but they are often considered and used together because of their compatibility. Let me give you an example, this is a comment straight from flex source code:</p><p>  Flex和Bison是非常稳定的软件。他们被维持，但新功能的发展是有限的，如果不是缺席。此外，他们的代码是稳定的，但并不总是质量很大。如果您认为C和C ++是不同的语言，则尤其如此，但由于其兼容性，通常会被考虑并一起使用它们。让我给你一个例子，这是一个从Flex源代码直接评论：</p><p> * We will address this in a future release of flex, or omit the C++ scanner</p><p> *我们将在未来的Flex版本中解决此问题，或省略C ++扫描仪 </p><p>   from  https://github.com/westes/flex/blob/master/src/flex.skl#L127</p><p>来自https://github.com/westes/flex/blob/master/src/flex.skl#l127.</p><p> So, yeah stable code does not mean good quality code. This is nothing unusual for old project, if you change something you break something. So you leave it as it is, but that is exactly why old software does not always have a stellar reputation.</p><p> 所以，是的，稳定的代码并不意味着良好的质量代码。如果你改变了一些你打破的东西，这对旧项目没有任何罕见。所以你离开它，但这正是旧软件并不总是有恒星声誉的原因。</p><p> ANTLR instead is more actively developed. It has been re-written from scratch a few times during the years, so the code is of good quality. Furthermore, new features are added regularly that improves both parsing and supporting features. These features can be small improvements, for example better support for selecting Unicode characters depending on properties. However, they are also features that significantly improves the life of developers, such as robust support for semantic predicates. Other additions are useful for the support of the project, for instance the generation of diagrams of the parse tree for documentation purposes.</p><p> 反而更加积极开发。多年来，它已从划痕重新编写了几次，所以代码质量很好。此外，通常会定期添加新功能，从而提高解析和支持功能。这些特征可以很小改进，例如更好地支持根据属性选择Unicode字符。然而，它们也是显着提高开发人员的使用寿命的功能，例如对语义谓词的强大支持。其他添加对于项目的支持非常有用，例如用于文档目的的解析树的图。</p><p> The design of Flex and Bison is stagnant and antiquated by principle. This is in part because their killer feature is compatibility, so it cannot be changed. It is also due to the fact that they are two different software that must work together, so neither can evolve alone. Instead ANTLR is developed as a whole software that works both as a lexer and a parser, so it has more freedom to change.</p><p> Flex和Bison的设计是停滞不前的并且是原则上的。这部分是因为他们的杀手功能是兼容性，因此无法更改。它也是由于它们是两种不同的软件，必须共同努力，所以既不能单独发展。而是作为一个整体软件开发的Antlr，它们都作为Lexer和解析器工作，因此它有更改的自由。</p><p>  Both Flex and Bison support only a grammar that contains actions (i.e., the code to manipulate the results of parsing is inside the grammar). ANTLR on the other hands allows to separate the definition of the language from the code that handles the results.</p><p>  Flex和Bison都仅支持包含动作的语法（即，用于操纵解析结果的代码在语法内）。另一方面的Antlr允许将语言的定义与处理结果的代码分开。</p><p> A great advantage of this separation between grammar and normal code is that allows to reuse the grammar. You can reuse the grammar with other projects or even with other languages. This is possible because ANTLR supports generating parsers in different languages from the same grammar, as long as the grammar does not contain actions. This is not always possible, since some complex languages requires advanced manipulation to be parsed, but it is usually doable. This means that to parse a real programming language like Java you would probably need to use actions, but you do not need them to parse JSON or an average DSL.</p><p> 这种语法和正常代码之间这种分离的极大优点是允许重复使用语法。您可以使用其他项目重用语法或其他语言。这是可能的，因为只要语法不包含动作，Antlr支持以不同语法生成不同语言的解析器。这并不总是可能的，因为一些复杂的语言需要解析高级操作，但通常是可行的。这意味着要解析像Java这样的真实编程语言，您可能需要使用操作，但您不需要它们来解析JSON或平均DSL。</p><p> ANTLR supports writing a grammar that contains only the description of the language. It is possible to write actions, like in Flex and Bison, but it is recommended to avoid it when it is possible. This allows to write a cleaner and more understandable grammar. There is separation of concerns: the grammar describes the language to parse it, while the code handles the results of the parsing.</p><p> Antlr支持编写一个只包含语言描述的语法。可以在Flex和Bison中写入操作，但建议在可能的时候避免它。这允许编写一个清洁和更可理解的语法。存在关注的关注：语法描述了解析它的语言，而代码处理解析结果。 </p><p> Furthermore, the code embedded inside the grammar lacks context. While a developer is editing the grammar, it is not obvious which arguments can be accessed inside each rule. Writing code in a grammar means also having no support from an IDE: there are no syntax highlighting or autocomplete features. Instead, writing the code apart from the grammar, in a traditional source code file, allows to take advantage of the usual IDE features.</p><p>此外，嵌入在语法内的代码缺少上下文。虽然开发人员正在编辑语法，但它不明显，可以在每个规则中访问哪个参数。在语法手段中编写代码也没有来自IDE的支持：没有语法突出显示或自动完成功能。相反，在传统的源代码文件中，将代码与语法写入，允许利用通常的IDE功能。</p><p>  We are going to show a simple example of a rule written in Bison and ANTLR, to get the feel of how it is working with them.</p><p>  我们将显示一项简单的例子，在北美和安特尔写的规则中，以了解如何与他们合作的感觉。</p><p> This is a typical simple rule written for Bison. The token NUM is defined in Flex (not shown).</p><p> 这是一个为北美野牛编写的典型简单规则。令牌数量在Flex（未示出）中定义。</p><p>  Setting aside that the code is a bit cryptic, the combination of the rule definition and the traditional code is harder to read and understand. Imagine many rules like this one floating together, interspersed with long paragraphs of code. This is even more true when you think that, in real cases the grammar must also includes code to manage the usual includes, namespaces, setting up, etc.</p><p>  抛开代码是一个密码，规则定义的组合和传统代码更难阅读和理解。想象一下，许多规则像这个漂浮在一起，穿插着长期的代码段。当您认为，在实际情况下，语法还必须包括管理通常的代码，名称空间，设置等。</p><p> Bison grammars must obviously also include code to integrate Flex tokens inside Bison, since Flex is a separate software.</p><p> Bison语法必须显然还包括代码来集成北美野牛内部的Flex令牌，因为Flex是一个单独的软件。</p><p> /* Bison setup and linking to Flex tokens */%token NUM// we indicate that the sum uses left associativity%left &#39;+&#39;</p><p> / * Bison设置并链接到Flex令牌* /％令牌Num //我们表示该和使用左联想％左＆＃39; +＆＃39;</p><p> On the other hand with ANTLR you can write simple rules like this one in the grammar.</p><p> 另一方面，与antlr，您可以在语法中编写像这样的简单规则。 </p><p>  Then ANTLR offers two simple ways to manipulate the results of the parsing: a visitor or a listener. These are both patterns that allows to execute code while you traverse the parse tree created by the parser. The difference between the two is that with a listener the tree is traversed automatically: you cannot change its path. Instead with a visitor you can alter the traversal path as you wish.</p><p>然后，Antlr提供了两种简单的方法来操纵解析的结果：访客或侦听器。这些都是允许在遍历解析器创建的解析树时执行代码的模式。两者之间的区别在于，使用侦听器，树将自动遍历：您无法更改其路径。而是使用访问者您可以根据需要更改遍历路径。</p><p>   The code is in a traditional source code file, together with the rest of the program code. So, it is easier to understand it and the IDE can support the developer as usual.</p><p>   代码在传统的源代码文件中，以及程序代码的其余部分。因此，更容易理解它，IDE可以像往常一样支持开发人员。</p><p>  Flex does not natively support Unicode. This is because it can only read 8-bit of input. While this does not make impossible to recognize Unicode characters, it means that Flex does not make it easy. The developer would have to create its own solution to recognize Unicode characters. This would require significant work and the developer would have to maintain it.</p><p>  Flex并未自然支持Unicode。这是因为它只能读取8位的输入。虽然这并不是不可能识别Unicode字符，但这意味着Flex不会简单。开发人员必须创建自己的解决方案来识别Unicode字符。这需要大量工作，开发人员必须维护它。</p><p> ANTLR has full support for Unicode, both the widespread UTF8 encoding and the other ones like UTF16. It also supports properties, that simplify referencing range of characters. For example, the following is valid ANTLR code that creates a lexer rule to match all Emoji characters.</p><p> Antlr全面支持Unicode，既有广泛的UTF8编码和其他与UTF16相同的。它还支持属性，可简化引用字符范围。例如，以下是有效的antlr代码，它创建一个符合所有表情符号字符的列出规则。</p><p>   Flex and Bison are two separate software. Even though they are designed to work together there are compatibility issues and incompatible features. For example, Bison supports the generation of parser in C, C++ and Java, while Flex only supports C well. Flex has a permissive license (BSD), while Bison has a restrictive license (GPL).</p><p>   Flex和Bison是两个单独的软件。即使它们旨在一起工作，也有兼容性问题和功能不兼容。例如，Bison支持C，C ++和Java中的解析器的生成，而Flex仅支持C井。 Flex具有许可证许可证（BSD），而北美野牛则具有限制性许可证（GPL）。</p><p>  In the simplest parsing projects, the restrictions of the GPL license are not relevant, since there is no need to include Bison itself with the generated parser. In addition to that, Bison provides a special exception to the GPL that exclude its applicability in parsers generated by Bison. However, there are some advanced usages that would require the inclusion of the parser generator. For example, an IDE that provided a way to create custom syntax highlighting rules might use a parser generator. In that case the license could be an issue.</p><p>  在最简单的解析项目中，GPL许可证的限制不相关，因为不需要将Bison本身与生成的解析器一起包含。除此之外，北美野牛还为GPL提供了一个特殊的例外，以排除其在北美野牛生成的解析器中的适用性。但是，有一些高级用户需要包含解析器生成器。例如，提供了一种创建自定义语法突出显示规则的IDE可以使用解析器生成器。在这种情况下，许可证可能是一个问题。</p><p>  Bison supports only a BNF-equivalent format to define rules, instead of the more flexible EBNF. You can see our article on  EBNF: How to Describe the Grammar of a Language  to see the main differences. The short version is that the grammar will be more verbose and complicated in Bison than in ANTLR. For example, rules that use list of elements have to be defined in a rather awkward way.</p><p>  北美野牛仅支持BNF等效格式来定义规则，而不是更灵活的EBNF。您可以在EBNF上查看我们的文章：如何描述语言的语法，以查看主要差异。简短的版本是语法在北极野牛中将更加详细和复杂化。例如，使用元素列表的规则必须以相当尴尬的方式定义。 </p><p>  This rule is trying to say that a  lines is a series of one or more  line. However, because of the limitations of the BNF format, it actually saying something much more complicated. It is saying a rule  lines is a set of  lines followed by a line, this in a recursive way until it find the last  line. You can clearly see the issue with the graphical representation of the parsing tree for a simple example.</p><p>这条规则正试图说一条线是一系列或多行。但是，由于BNF格式的局限性，它实际上说了更复杂的东西。它说规则线是一组线，后跟一行，这是一种递归方式，直到找到最后一行。您可以清楚地看到解析树的图形表示，以为一个简单的例子。</p><p>    This rule is actually just saying that a rule  lines is a series of one or more  line. ANTLR supports this format both in the lexer and in the parser.</p><p>    该规则实际上只是说规则线是一系列或多行。 Antlr在Lexer和Parser中支持此格式。</p><p>  Flex supports regular expressions. ANTLR supports context-free expressions in the definition of lexer rules. The difference is that context-free expressions are more powerful and can match more rules.</p><p>  Flex支持正则表达式。 Antlr支持在Lexer规则的定义中提供无系统表达式。不同之处在于无背景表达式更强大，可以匹配更多规则。</p><p> Lexing is generally simpler than the second phase of proper parsing, so it requires less powerful algorithms. This means that flex, a tool dedicated to lexing, is strictly less powerful than ANTLR. That is because ANTLR is one tool that combines lexing and parsing, so it can employ a more powerful algorithm in both phases.</p><p> Lexing通常比正确解析的第二阶段更简单，因此它需要更强大的算法。这意味着Flex是一种专用于LEXING的工具，比ANTLR严格更强大。这是因为Antlr是一个结合Lexing和解析的工具，因此它可以在两个阶段采用更强大的算法。</p><p> In practical terms, it means that it is easier to define complex lexical structures in ANTLR. For example, you can easily define recursive lexer rules in ANTLR.</p><p> 实际上，这意味着它更容易定义ANTLR中的复杂词汇结构。例如，您可以在Antlr中轻松定义递归词汇规则。</p><p> For instance, this is how you define the common programming element language of a string between double quotes in flex.</p><p> 例如，这就是如何定义Flex中双引号之间的字符串的常用编程元素语言。</p><p>  This rule matches a  &#34; (double quotes), any instances of  [^&#34;] (any character that is not a double quote) and finally a  &#34; again.</p><p>  这条规则与A＆＃34匹配; （双引号），任何[^＆＃34;]的任何情况（任何角色不是双引号），最后a＆＃34;再次。 </p><p>    This limitation of flex has an impact of productivity, given that the lexer is where things get trickier to define and it is easier to make mistake. That is because you are working character by character, without any context, so it is more difficult to conceptualize what is going on.</p><p>鉴于Lexer是棘手的情况下，这种柔性的这种限制产生了生产率的影响，并且更容易犯错误。这是因为你是字符的工作角色，没有任何上下文，所以更难以概念化正在发生的事情。</p><p> Both flex and ANTLR supports a feature to activate the recognition of some tokens only in certain conditions. This feature is called  states in flex and  lexical modes in ANTLR. This feature allows to create one lexer to parse multiple languages. For example, it would allow to build one lexer to parse a markup language (e.g., XML, HTML), which contains both free text and markup code.</p><p> Flex和Antlr都支持一个功能，仅在某些条件下激活一些令牌的识别。此功能称为Antlr中的Flex和词汇模式中的状态。此功能允许创建一个解释多种语言的Lexer。例如，它允许构建一个Lexer来解析标记语言（例如，XML，HTML），其中包含免费文本和标记代码。</p><p>  A defining characteristic of a parser generator is what algorithm it uses to create a parser. The theory of parsing has been extensively studied by computer scientists, that developed different parsing algorithms with different strengths and weaknesses.</p><p>  解析器生成器的定义特征是它用于创建解析器的算法。 Parsing的理论被计算机科学家广泛研究，开发了不同的解析算法，具有不同的优点和缺点。</p><p>  ANTLR uses an algorithm developed by its main author Terence Parr. The algorithm is called  ALL(*). This is an improvement over the traditional LL algorithm, which is less powerful. The LL algorithm is easier to implement manually and powerful enough to be useful. So historically many computer languages were purposefully designed to be parsed with an LL algorithm. The ALL(*) variant is more powerful than the basic LL algorithm and can handle most languages you will encounter.</p><p>  Antlr使用其主要作者Terence Parr开发的算法。该算法称为所有（*）。这是对传统LL算法的改进，这不太强大。 LL算法更容易手动和强大的实现，以使其有用。因此，所以历史上，许多计算机语言被故障设计用于用LL算法解析。全（*）变体比基本LL算法更强大，可以处理您将遇到的大多数语言。</p><p> Bison supports the generation of parsers using two algorithms: LALR and GLR. One is quicker and less powerful than the one used by ANTLR, the other is potentially slower, but is slightly more powerful (i.e. it can parse more languages).</p><p> 北美野牛支持使用两种算法的解析器：LALR和GLR。一个比Antlr使用的更快，更强大，另一个可能慢，但稍微强大（即它可以解析更多语言）。</p><p> In practical terms, both ALL(*) and GLR can parse most languages encountered by developers. The only difference is that GLR might allow to write simpler rules in some cases. We are going to see which ones later.</p><p> 实际上，所有（*）和GLR都可以解析开发人员遇到的大多数语言。唯一的区别是GLR可能在某些情况下允许在某些情况下编写更简单的规则。我们稍后会看到哪一个。</p><p> There is no comprehensive performance comparison between ANTLR 4 and flex/Bison, however  there is a scientific paper that compares a few parser generators based on the same algorithms. In the following paragraphs we present these findings.</p><p> Antlr 4和Flex / Bison之间没有全面的性能比较，但是有一个科学纸，可以基于相同的算法比较一些解析器发生器。在以下段落中，我们展示了这些调查结果。 </p><p> According to theoretical analysis, the new algorithm used by ANTLR (i.e., ALL(*)) has as an higher complexity ( O(n 4)) than the GLR algorithm ( O(n 3)). However in practical usage ALL(*) has shown to be quicker than GLR. Testing made on a corpus of Java 6 source files has found that:</p><p>根据理论分析，ANTLR（即，所有（*））使用的新算法具有比GLR算法（O（n 3））更高的复杂性（O（n 4））。但是，在实际使用中，所有（*）都显示出比GLR更快。在Java 6源文件的语料库上进行的测试已发现：</p><p> In practice, we found GLL and GLR to be   ̃135x slower than ALL(*) on a corpus of 12,920 Java 6 library source files (123M) and 6 orders of magnitude slower on a single 3.2M Java file, respectively.</p><p> 在实践中，我们发现GLL和GLR在12,920个Java 6库源文件（123M）的语料库上的所有（*）慢，分别在单个3.2M Java文件中的6个级别的所有（*）上的所有（*）和6个幅度较慢。</p><p> [..] For this experiment, ALL(*) outperforms  the  other  parser generators  and  is  only  about  20%  slower  than  the  hand built parser in the Java compiler itself</p><p> [..]对于这个实验，所有（*）都优于其他解析器发生器，并且比Java编译器本身中的手工构建解析器慢的速度慢约20％</p><p> In any case both algorithms are used extensively in production system, so they are quick enough for everyday use. ALL(*) and LALR parsers have about the same performance.</p><p> 在任何情况下，两种算法都在生产系统中广泛使用，因此它们足够快，以便每天使用。所有（*）和LALR解析器的性能大致相同。</p><p>  Before proceeding with discussing the power of the algorithms, we have to understand one important difference. Namely, the different ways a grammar formats and a parsing algorithm influence how you write a grammar. The format in which you can write a grammar limits the formal rules that you can use to describe your language. It is basically a productivity issue: the more powerful the format, the easier is to write rules (e.g., some formats allows to easily use repetitions). We have already seen the difference of grammar formats between Bison and ANTLR, so this part should be clear. Instead the parsing algorithm determines how you can combine the different rules or their parts. A specific parsing algorithm might make impossible some combinations of rules. I.e., each rule might be formally correct, but the whole grammar might not be valid.</p><p>  在继续讨论算法的力量之前，我们必须了解一个重要的区别。即，语法格式和解析算法的不同方式影响你写作语法的方式。您可以编写语法的格式限制了您可以用来描述您的语言的正式规则。它基本上是一种生产力问题：格式更强大，更容易写规则（例如，某些格式允许轻松使用重复）。我们已经看到了北美和禁区之间语法格式的差异，所以这部分应该清楚。相反，解析算法确定如何组合不同的规则或其部件。特定解析算法可能会产生不可能的规则组合。即，每个规则可能正式正确，但整个语法可能无效。</p><p> In simple terms: a grammar format determines the syntax of a rule (e.g</p><p> 简单来说：语法格式确定规则的语法（例如</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://tomassetti.me/why-you-should-not-use-flex-yacc-and-bison/">https://tomassetti.me/why-you-should-not-use-flex-yacc-and-bison/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/yacc/">#yacc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语法/">#语法</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>