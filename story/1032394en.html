<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何通过不阅读RFC 1034来浪费半天时间</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">如何通过不阅读RFC 1034来浪费半天时间</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-31 06:24:35</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/b28b911cc848b4e0e4f1878e1b55d1db.gif"><img src="http://img2.diglog.com/img/2020/10/b28b911cc848b4e0e4f1878e1b55d1db.gif" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>HEY uses a branch deploy system that I’ve  written about here on SvN and talked about frequently  on Twitter. Plenty of other companies have implemented their own version of branch deploys (typically under a different name), but this was my own implementation, so I’m proud of it. First, a primer on how it works:</p><p>嘿使用了一个分支部署系统，这是我在SVN上写过的，在Twitter上经常被提及。许多其他公司已经实现了他们自己版本的分支部署(通常使用不同的名称)，但这是我自己的实现，所以我为此感到自豪。首先，介绍一下它的工作原理：</p><p> An automated build pipeline run is kicked off by a GitHub webhook. It builds some Docker images and kicks off another build that handles the deploy itself.</p><p>自动构建管道运行由GitHub网络挂钩启动。它构建一些Docker映像，并启动另一个处理部署本身的构建。</p><p> That deploy build, well, it deploys — to  AWS EKS, Amazon’s managed Kubernetes offering, via a Helm chart that contains all of the YAML specifications for deployments, services, ingresses, etc.</p><p>该部署版本通过包含所有YAML部署、服务、入口等规范的Helm图表，部署到Amazon的托管Kubernetes产品AWS EKS。</p><p>   Dev can access their branch from their browser using a special branch-specific URL   This process takes 5-10 minutes for a brand new branch from push to being accessible (typically).</p><p>开发人员可以使用特定于分支机构的特殊URL从浏览器访问其分支机构。从推送到可访问(通常情况下)，这一过程需要5-10分钟才能访问一个全新的分支机构。</p><p>   Each branch needs its own ALB (that’s what is generated by the Ingress resource).</p><p>每个分支都需要自己的ALB(这是由Inress资源生成的)。</p><p> DNS is DNS is DNS and sometimes it takes a while to propagate and requires that we manage a ton of records (3-5 for each branch).</p><p>DNS是DNS，有时需要一段时间才能传播，需要我们管理大量记录(每个分支3-5个)。</p><p> These faults are intertwined: if I didn’t have to give each branch it’s own ALB, I could use a wildcard record and point every subdomain on our branch-deploy-specific-domain to a single ALB and let the ALB route requests to where they belong via host headers. That means I can save money by not needing all of those ALBs and we can reduce the DNS-being-DNS time to zero (and the complexity of external-dns annotations and conditionals spread throughout our YAML).</p><p>这些错误是交织在一起的：如果我不必为每个分支提供自己的ALB，我可以使用通配符记录，并将我们的分支部署特定域上的每个子域指向单个ALB，然后让ALB通过主机标头将请求路由到它们所属的位置。这意味着我可以通过不需要所有的ALB来节省资金，并且我们可以将DNS成为DNS的时间减少到零(以及整个YAML中分布的外部DNS注释和条件的复杂性)。</p><p> (While waiting a few minutes for DNS to propagate and resolve doesn’t sound like a big deal, we shoot ourselves in the foot with the way our deploy flow works by checking that the revision has actually been deployed by visiting an internal path on the new hostname as soon as the deploy build finishes, causing us to attempt to resolve DNS prior to the record being created and your local machine caching that NXDOMAIN response until the TTL expires.)</p><p>(虽然等待DNS传播和解析几分钟听起来不是什么大不了的事，但我们通过在部署构建完成后立即访问新主机名上的内部路径来检查修订版本是否已实际部署，从而在创建记录之前尝试解析DNS，并在TTL到期之前缓存该NXDOMAIN响应，从而对部署流的工作方式进行抨击。)</p><p> Before now, this was doable but required some extra effort that made it not worthwhile — it would likely need to be done through a custom controller that would take care of adding your services to a single Ingress object via custom annotations. This path was Fine™️ (I even made a proof-of-concept controller that did just that), but it meant there was some additional piece of tooling that we now had to manage, along with needing to create and manage that primary Ingress object.</p><p>在此之前，这是可行的，但需要一些额外的工作，这使得它不值得-它可能需要通过一个自定义控制器来完成，该控制器将负责通过自定义注释将您的服务添加到单个Inress对象。这条路径很好(我甚至做了一个概念验证控制器来实现这一点)，但这意味着我们现在必须管理一些额外的工具，以及需要创建和管理主™️对象。</p><p> Enter  a new version of alb-ingress-controller (and it’s new name: aws-load-balancer-controller) that includes a new  IngressGroup feature that does  exactly what I need. It adds a new set of annotations that I can add to my Ingresses which will cause all of my Ingress resources to be routing rules on a single ALB rather than individual ALBs.</p><p>输入一个新版本的alb-inress-Controller(它的新名称是：aws-load-balancer-Controller)，其中包含一个新的IngressGroup特性，该特性完全符合我的需要。它添加了一组新的注释，我可以将其添加到我的Ingresses中，这将导致我的所有Inress资源都是单个ALB上的路由规则，而不是单个ALB上的路由规则。</p><p> “Great!” I think to myself on the morning I start the project of testing the new revision and figuring out how I want to implement this (using it as an opportunity to clean up a bunch of technical debt, too).</p><p>“太好了！”我想，早上我就开始测试新版本的项目，并弄清楚我想要如何实现这一点(利用它作为一个机会，也清理了一大堆技术债务)。</p><p> I get everything in place — I’ve updated aws-load-balancer-controller in my test cluster, deleted all of the branch-specific ALIAS records that existed for the old ALBs, told external-dns not to manage Ingress resources anymore, and setup a wildcard ALIAS pointing to my new single ALB that all of these branches should be sharing.</p><p>我把一切都准备好了-我已经在我的测试集群中更新了AWS-Load-Balizer-Controller，删除了旧ALB存在的所有特定于分支的别名记录，告诉外部DNS不要再管理Inress资源，并设置了一个通配符别名，指向所有这些分支都应该共享的新的单个ALB。</p><p>      I have no clue what is going on. I can clearly see that the record exists in Route53, but I can’t resolve it locally, nor can some DNS testing services (❤️ MX Toolbox).</p><p>我完全不知道发生了什么事。我可以清楚地看到该记录存在于Route53中，但是我不能在本地解析它，一些dns测试服务(❤️MX工具箱)也不能解析它。</p><p> Maybe it’s the “Evaluate Target Health” option on the wildcard record? Disabled that and tried again, still nothing.</p><p>也许是通配符记录上的“评估目标健康”选项？把它弄坏了，又试了一次，还是没有结果。</p><p> I’m thoroughly stumped and start browsing the  Route53 documentation and find this line and think it’s the answer to my problem:</p><p>我完全被难住了，开始浏览Route53文档，找到了这一行，并认为它是我问题的答案：</p><p> If you create a record named *.example.com and there’s no example.com record, Route 53 responds to DNS queries for example.com with  NXDOMAIN (non-existent domain).</p><p>如果您创建了一个名为*.example.com的记录，但没有example.com记录，则路由53将使用NXDOMAIN ID(不存在的域)响应example.com的DNS查询。</p><p> So off I go to create a record for branch-deploy.com to see if maybe that’s it. But that still doesn’t do it. This is when I re-read that line and realize that it doesn’t apply to me anyway — I had read it incorrectly the first time, I’m not trying to resolve branch-deploy.com. (My initial reading was that *.branch-deploy.com wouldn’t resolve without a record for branch-deploy.com existing).</p><p>因此，我开始为Branch-ployment.com创建一条记录，看看是否就是这样。但这仍然不能解决问题。这时我重新阅读了这一行，并意识到它无论如何都不适用于我-我第一次读错了，我不是在尝试解析Branch-ployment.com。(我最初的理解是，如果没有Branch-ployment.com的记录，*.Branch-ployment.com将无法解析)。</p><p> Welp, time to dig into  the RFC, there’s bound to be some obscure thing I’m missing here. Correct that assumption was.</p><p>好了，是时候深入了解一下RFC了，这里肯定有什么我漏掉的难懂的东西。正确的假设是。</p><p> – When the query is in another zone. That is, delegation cancels the wildcard defaults.</p><p>-当查询位于另一个区域时。也就是说，委派取消通配符默认值。</p><p> – When the query name or a name between the wildcard domain and the query name is know to exist. For example, if a wildcard RR has an owner name of “*.X”, and the zone also contains RRs attached to B.X, the wildcards would apply to queries for name Z.X (presuming there is no explicit information for Z.X), but not to B.X, A.B.X, or X.</p><p>-当知道存在查询名称或通配符域和查询名称之间的名称时。例如，如果通配符RR的所有者名称为“*.X”，并且区域还包含附加到B.X的RR，则通配符将应用于名称Z.X的查询(假设没有关于Z.X的显式信息)，但不适用于B.X、A.B.X或X。</p><p> Hmm, that second bullet point sounds like a lead. Let me go back to my Route53 zone and look.</p><p>嗯，第二个要点听起来像是线索。让我回到我的Route53区域看看。</p><p>   One feature of our branch deploy system is that you can also have a functioning mail pipeline that is specific to your branch. To use that feature, you email  yourself@your-branch.branch-deploy.com. To make that work, each branch gets an MX record on your-branch.branch-deploy.com.</p><p>我们的分支机构部署系统的一个功能是，您还可以拥有特定于您的分支机构的正常运行的邮件管道。要使用该功能，您可以通过电子邮件发送电子邮件给您自己@your-brch.Branch-ployment.com。要做到这一点，每个分支都会在您的-Branch ch.Branch-deploy.com上获得一条MX记录。</p><p> Here-in lies the problem. While you can have a wildcard record for branch-deploy.com, if an MX record (or other any record really) exists for a given subdomain and you try to visit your-branch.branch-deploy.com, that A/AAAA/CNAME resolution will not climb the tree to the wildcard. 🙃</p><p>这就是问题所在。虽然您可以拥有BRANCH-Deployment.com的通配符记录，但如果给定子域存在MX记录(或其他任何记录)，并且您尝试访问YOUR-BRANCH.BRANCH-DEPLOY.com，则A/AAAA/CNAME解析不会爬升到通配符。🙃。</p><p> This is likely a well-known quirk (is it even a quirk or is it common sense? it surely wasn’t common sense for me), but I blew half a day banging my head against my desk trying to figure out why this wasn’t working because I made a bad assumption and I really needed to vent about it. Thank you for indulging me.</p><p>这很可能是一个众所周知的怪癖(它甚至是一个怪癖还是常识？这对我来说肯定不是常识)，但我花了半天的时间用头撞桌子，试图弄清楚为什么这不管用，因为我做了一个糟糕的假设，我真的需要发泄一下。谢谢你纵容我。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://m.signalvnoise.com/how-to-waste-half-a-day-by-not-reading-rfc-1034/">https://m.signalvnoise.com/how-to-waste-half-a-day-by-not-reading-rfc-1034/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/阅读/">#阅读</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/day/">#day</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/部署/">#部署</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>