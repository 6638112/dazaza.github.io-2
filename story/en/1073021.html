<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>CVE-2022-0435：自4.8版本以来，Linux内核TIPC模块中的远程堆栈溢出CVE-2022-0435: Remote Stack Overflow in Linux Kernel TIPC Module Since 4.8</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">CVE-2022-0435: Remote Stack Overflow in Linux Kernel TIPC Module Since 4.8<br/>CVE-2022-0435：自4.8版本以来，Linux内核TIPC模块中的远程堆栈溢出</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-14 11:20:01</div><div class="page_narrow text-break page_content"><p>Date: Thu, 10 Feb 2022 14:16:41 +0000From: Samuel Page &lt;samuel.page@...gate.com&gt;To: &#34;oss-security@...ts.openwall.com&#34; &lt;oss-security@...ts.openwall.com&gt;Subject: CVE-2022-0435: Remote Stack Overflow in Linux Kernel TIPC Module since 4.8 (net/tipc)Immunity Security AdvisoryCVE-2022-0435: A Remote Stack Overflow in The Linux Kernel========================================================================Contents========================================================================SummaryAnalysisFurther InformationRemediationAcknowledgementsDisclosure Timeline========================================================================Summary========================================================================We discovered a remotely &amp; locally reachable stack overflow in the Linuxkernel networking module for the Transparent Inter-ProcessCommunication (TIPC) protocol.While the module can be found in most major distributions, it must beloaded in order to be exploited. Furthermore, for remote exploitationthe target would need to have a TIPC bearer set up already i.e.vulnerability extends to systems using TIPC.Exploitation is trivial and can lead to denial of service via kernelpanic. In the absence, or bypass, of stack canaries/KASLR thevulnerability can lead to control flow hijacking with an arbitrarypayload.The vulnerability has been present since the introduction of the TIPCmonitoring framework in kernel version 4.8.- Introduced: commit 35c55c9877f8 (&#34;tipc: add neighbor monitoring framework&#34;)- Fixed:  https://github.com/torvalds/linux/commit/9aa422ad326634b76309e8ff342c246800621216========================================================================Analysis========================================================================Transparent Inter Process Communication (TIPC) is an IPC mechanismdesigned for intra-cluster communication. Cluster topology is managedaround the concept of nodes and the links between these nodes.One of the many features of the TIPC module is its monitoring framework.Introduced into the kernel in June 2016 (commit 35c55c9), the frameworkallows nodes to monitor network topology and share their view with othernodes in the same domain.Peer state is tracked via `struct tipc_peer`:... /* struct tipc_peer: state of a peer node and its domain * @addr: tipc node identity of peer * @head_map: shows which other nodes currently consider peer &#39;up&#39; * @domain: most recent domain record from peer * @hash: position in hashed lookup list * @list: position in linked list, in circular ascending order by &#39;addr&#39; * @applied: number of reported domain members applied on this monitor list * @is_up: peer is up as seen from this node * @is_head: peer is assigned domain head as seen from this node * @is_local: peer is in local domain and should be continuously monitored * @down_cnt: - numbers of other peers which have reported this on lost */ struct tipc_peer { u32 addr; struct tipc_mon_domain *domain; struct hlist_node hash; struct list_head list; u8 applied; u8 down_cnt; bool is_up; bool is_head; bool is_local; };...`struct tipc_mon_domain` referends a domain record, used to define thatpeers view of the TIPC topology:... #define MAX_MON_DOMAIN 64 ... /* struct tipc_mon_domain: domain record to be transferred between peers * @len: actual size of domain record * @gen: current generation of sender&#39;s domain * @ack_gen: most recent generation of self&#39;s domain acked by peer * @member_cnt: number of domain member nodes described in this record * @up_map: bit map indicating which of the members the sender considers up * @members: identity of the domain members */ struct tipc_mon_domain { u16 len; u16 gen; u16 ack_gen; u16 member_cnt; u64 up_map; u32 members[MAX_MON_DOMAIN]; };...These records are transferred between peers, with each node keeping acopy of the most up-to-date domain record received from each of itspeers in the `tipc_peer-&gt;domain` field.Records are processed by the function `tipc_mon_rcv`, which check`STATE_MSG` received from peers, to see if the message body contains avalid `struct tipc_mon_domain`:... /* tipc_mon_rcv - process monitor domain event message * * @data: STATE_MSG body * @dlen: STATE_MSG body size (taken from TIPC header) */ void tipc_mon_rcv(struct net *net, void *data, u16 dlen, u32 addr, struct tipc_mon_state *state, int bearer_id) { ... struct tipc_mon_domain *arrv_dom = data; struct tipc_mon_domain dom_bef; ... /* Sanity check received domain record */ [0] if (dlen &lt; dom_rec_len(arrv_dom, 0)) [1] return; if (dlen != dom_rec_len(arrv_dom, new_member_cnt)) [2] return; if (dlen &lt; new_dlen || arrv_dlen != new_dlen) [3] return; ... /* Drop duplicate unless we are waiting for a probe response */ if (!more(new_gen, state-&gt;peer_gen) &amp;&amp; !probing) [4] return; ... /* Cache current domain record for later use */ dom_bef.member_cnt = 0; dom = peer-&gt;domain; if (dom) [5] memcpy(&amp;dom_bef, dom, dom-&gt;len); [6] /* Transform and store received domain record */ if (!dom || (dom-&gt;len &lt; new_dlen)) { kfree(dom); dom = kmalloc(new_dlen, GFP_ATOMIC); [7] peer-&gt;domain = dom; if (!dom) goto exit; }...The function does some basic sanity checks [0] to make sure that a) themessage body actually contains a domain record and b) does it contain avalid `struct tipc_mon_domain`.Where `data` is the message body and `dlen` is the length of the `data`taken from the message header, the function checks:- the length of `data` is enough to at least hold an empty record [1]- the length of `data` matches the expected size of a domain record given the provided `member_cnt` field [2]- the length of `data` matches the provided `len` field [3]Later we fetch the sending peers `struct peer` to see if we&#39;ve alreadyreceived a domain record from them [5]. If we have, we want totemporarily cache a copy of the old record to do a comparison later [6].Then, satisfied it&#39;s a new and valid record, we&#39;ll update the`struct peer-&gt;domain` field with the new info. If it&#39;s the first domainrecord, we&#39;ll make a new `kmalloc`ation for this [7], or if it&#39;s largerthan the last one we&#39;ll reallocate it.-----------------The Vulnerability-----------------The vulnerability lies in the fact that during the initial sanitychecks, the function doesn&#39;t check that `member_cnt` is belowMAX_MON_DOMAIN which defines the maximum size of the `members` array.By pretending to be a peer node and establishing a link with the target,locally or remotely, we&#39;re able to first submit a malicious domainrecord containing an arbitrary payload; so long as the len/member_cntfields match up for the sanity checks, this will be kmallocated fine.Next, we can send a newer domain record which will cause the previousmalicious record to be memcpy&#39;d into a 272 bytes local`struct tipc_mon_domain` &amp;dom_bef [6] triggering a stack overflow.This allows us to overwrite the contents of the stack following&amp;dom_bef with our arbitrary members buffer from the malicious domainrecord submitted first; the size of which is constrained by the mediaMTU (Ethernet, UDP, Inifiband)========================================================================Further Information========================================================================For a more in-depth analysis, including additional TIPC background, wewill be posting up a follow-up blog to compliment this advisory.Regarding exploitation, after time has been given for patching andremediation we will also release a further post discussing exploitation.Further information will be posted over at  https://twitter.com/immunityinc/========================================================================Remediation========================================================================This vulnerability has been present since the monitoring framework wasfirst introduced in June 2016, impacting versions 4.8 forward.The patch below was introduced in commit 9aa422ad3266, so updating yoursystem to include this patch is the best way to mitigate CVE-2022-0435,including an additional u16 overflow spotted by Eric Dumazet.The TIPC module must be loaded for the system to be vulnerable,furthermore to be targeted remotely the system needs to have a TIPCbearer enabled. If you don&#39;t need to use TIPC or are unsure if you are,you can take the following steps:- `$ lsmod | grep tipc` will let you know if the module is currently loaded,- `modprobe -r tipc` may allow you unload the module if loaded, however you may need to reboot your system- `$ echo &#34;install tipc /bin/true&#34; &gt;&gt; /etc/modprobe.d/disable-tipc.conf` will prevent the module from being loaded, which is a good idea if you have no reason to use itIf you need to use TIPC and can&#39;t immediately patch your system, look toenforce any configurtions that prevent or limit the ability forattackers to imitate nodes in your cluster. Options include TIPCprotocol level encryption, IPSec/MACSec, network seperation etc.It&#39;s also worth noting that the current `CONFIG_FORTIFY_SRC=y` is a hardmitigation to leveraging CVE-2022-0435 for control-flow hijacking, as itdoes a bounds check on the size of the offending memcpy and causes akernel panic.========================================================================Acknowledgements========================================================================I&#39;d like to thank the maintainers of the TIPC module, as well as membersof the security@...nel.org and linux-distros@...openwall.org for theirhelp and work throughout the disclosure process.I would also like to mention the vulnerability research done on TIPCpreviously by SentinelLabs with their work on CVE-2021-43267 and othersecurity researchers for publishing their findings on TIPC exploitation.-  https://www.sentinelone.com/labs/tipc-remote-linux-kernel-heap-overflow-allows-arbitrary-code-execution/-  https://haxx.in/posts/pwning-tipc/========================================================================Disclosure Timeline========================================================================- 27/01/2022: Vulnerability &amp; fix suggestion reported- 05/02/2022: The patch is finalised- 10/02/2022: Coordinated release date (14:00 GMT)The information contained in this electronic mail is confidential information intended only for the use of the individual(s) or entity(s) named. If the reader of the message is not the addressee (or authorized to receive for the addressee), you are hereby notified that any dissemination, distribution or copying of this communication is strictly prohibited. If you have received this communication in error, please immediately notify the sender by reply e-mail and/or by telephone and destroy the original message.</p><p>日期：2022年2月10日星期四14:16:41+0000From:Samuel Page&lt；塞缪尔。page@...gate.com&gt；致&#34；开放源码软件-security@...ts.openwall.com&#34; &书信电报；开放源码软件-security@...ts.openwall.com&gt；主题：CVE-2022-0435：自4.8（net/TIPC）以来Linux内核TIPC模块中的远程堆栈溢出免疫安全警告CVE-2022-0435：Linux内核中的远程堆栈溢出内核=时间线=；透明进程间通信（TIPC）协议的Linuxkernel网络模块中存在本地可访问的堆栈溢出。虽然在大多数主要发行版中都可以找到该模块，但必须将其归类才能加以利用。此外，对于远程攻击，目标需要已经设置TIPC承载，即漏洞扩展到使用TIPC的系统。利用该漏洞的行为微不足道，可能会通过kernelpanic导致拒绝服务。如果没有或绕过stack Canaris/KASLR，该漏洞可能导致利用任意有效载荷劫持控制流。自内核版本4.8中引入TIPCmonitoring框架以来，该漏洞一直存在。-介绍：提交35c55c9877f8（&#34；tipc:添加邻居监控框架&#34；）-固定的：https://github.com/torvalds/linux/commit/9aa422ad326634b76309e8ff342c246800621216========================================================================Analysis========================================================================Transparent进程间通信（TIPC）是为集群内通信而设计的一种IPC机制。集群拓扑是围绕节点的概念以及这些节点之间的链接进行管理的。TIPC模块的众多功能之一是其监控框架。该框架于2016年6月引入内核（commit 35c55c9），允许节点监视网络拓扑并与同一域中的其他节点共享视图。通过'struct tipc_Peer'：…/*StuttTiPCuPeL:对等节点的状态及其域*@ ADDR:对等体*@ Head映射的TIPC节点标识：显示哪些其他节点当前考虑对等体（39）；向上&#39；*@域：来自对等方的最新域记录*@hash:position in hash lookup list*@list:position in linked list，按&#39循环升序排列；地址&#39；*@已应用：在该监视列表上应用的已报告域成员数*@is_up:从该节点上看，对等方已向上*@is_head:从该节点上看，对等方已分配域头*@is_local:对等方在本地域中，应持续监视*@down_cnt:-在丢失的*/struct tipc_peer上报告此情况的其他对等方数{u32 addr；struct tipc_mon_domain*domain；struct hlist_node hash；struct list_head list；u8 applicated；u8 down_cnt；bool is_up；bool is_head；bool is_local；}`struct tipc_mon_domain`引用域记录，用于定义tipc拓扑的对等视图：#定义MAX_MON_域64…/*struct tipc_mon_domain:在对等方之间传输的域记录*@len:域记录的实际大小*@gen:当前一代发送方&#39；s domain*@ack_gen：最新一代的self&#39；s domain acked by peer*@member\u cnt:此记录中描述的域成员节点数*@up\u map:位图，指示发送方认为哪些成员是up*@members:域成员的标识*/struct tipc\u mon\u domain{u16 len；u16 gen；u16 ack\u gen；u16 member\u cnt；u64 up\u map；u32 members[MAX\u mon\u domain]}；。。。这些记录在对等点之间传输，每个节点在“tipc_peer-”中保存从每个对等点接收的最新域记录的副本；域名字段。记录由函数“tipc_mon_rcv”处理，该函数检查从对等方收到的“STATE_MSG”，以查看消息正文是否包含avalid`struct tipc_mon_domain`:…/*tipc_mon_rcv-进程监视器域事件消息**@data:STATE_MSG body*@dlen:STATE_MSG body size（取自tipc头）*/void tipc_mon_rcv（struct net*net，void*data，u16 dlen，u32 addr，struct tipc_mon_STATE*STATE，int bearer\u id）{…struct tipc_mon_domain*arrv_dom=data；struct tipc_mon_domain dom_bef；../*是否检查收到的域记录*/[0]如果（dlen&lt；dom_rec_len（arrv_dom，0））[1]返回；如果（dlen！=dom_rec len（arrv_dom，new_member_cnt））[2]返回；如果（dlen&lt；new|||| arrv dlen！=new|dlen）[3]返回；../*删除复制，除非我们正在等待探测响应*/if（！more（new_gen，state-&gt；peer_gen）&amp&amp！[4]返回；../*缓存当前域记录以备将来使用*/dom_bef。成员_cnt=0；dom=对等-&gt；领域if（dom）[5]memcpy（&amp；dom_bef，dom，dom-&gt；len）；[6] /*转换并存储收到的域记录*/if（！dom | |（dom-&gt；len&lt；new | dlen））{kfree（dom）；dom=kmalloc（new | dlen，GFP|ATOMIC）；[7]peer-&gt；domain=dom；if（！dom）goto exit；]。。。该函数会执行一些基本的健全性检查[0]，以确保a）消息正文实际上包含域记录，b）它是否包含avalid`struct tipc_mon_domain`。其中'data'是消息体，'dlen'是从消息头获取的'data'的长度，函数检查：“'data'的长度足以至少保存一个空记录[1]-“data'的长度与给定的'member_cnt'字段的域记录的预期大小匹配[2]-“data'的长度与提供的'len'字段匹配[3]之后，我们获取发送对等点的'struct peer'，以查看我们是否&#39；我已经收到他们的域记录[5]。如果有，我们希望临时缓存旧记录的副本，以便稍后进行比较[6]。然后，满足它&#39；这是一个新的有效记录，我们&#39；将更新'struct peer-&gt；带有新信息的域字段。如果是&#39；这是第一个域名记录，我们&#39；我会为这个[7]做一个新的'kmalloc'，或者如果它&#39；它比我们上次看到的大&#39；我会重新分配的-----------------漏洞-----------漏洞在于，在初始的健康检查期间，函数不&#39；t检查'member_cnt'是否低于定义'members'数组最大大小的最大MON_域。通过假装是对等节点并在本地或远程与目标建立链接，我们&#39；我们能够首先提交包含任意负载的恶意域名记录；只要len/member_cnt字段与健全性检查匹配，这将是K分配的罚款。接下来，我们可以发送一个新的域记录，这将导致之前的恶意记录为memcpy&#39；d转换为272字节的本地“struct tipc_mon_domain”&amp；dom_bef[6]触发堆栈溢出。这允许我们覆盖以下堆栈的内容&amp；dom_bef与我们的任意成员缓冲区一起从最先提交的恶意域名记录中删除；其大小受mediaMTU（以太网、UDP、Inifiband）的限制==========================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================，我们将发布一个后续博客来赞扬这一建议。关于漏洞利用，在给出修补和调解的时间后，我们还将发布一篇讨论漏洞利用的帖子。更多信息将发布在https://twitter.com/immunityinc/========================================================================Remediation========================================================================This自2016年6月首次引入监控框架以来，该漏洞一直存在，影响到4.8版以后的版本。下面的补丁是在commit 9AA422AD326中引入的，因此更新系统以包含此补丁是缓解CVE-2022-0435的最佳方法，包括Eric Dumazet发现的额外u16溢出。必须加载TIPC模块才能使系统易受攻击，此外，为了实现远程目标，系统需要启用TipBear。如果你没有&#39；如果您不需要使用TIPC或不确定是否需要，您可以采取以下步骤：“$lsmod | grep TIPC`将让您知道模块当前是否已加载，`modprobe-r TIPC`可能允许您在加载时卸载模块，但您可能需要重新启动系统-`echo&#34；安装tipc/bin/true&#34&gt&gt/etc/modprobe。d/禁用tipc。conf`将防止模块被加载，如果您需要使用TIPC和can&#39，那么如果您没有理由使用它，这是一个好主意；不要立即修补您的系统，请查看是否有任何配置阻止或限制攻击者模拟集群中节点的能力。选项包括TIPCprotocol级别的加密、IPSec/MACSec、网络分离等；还值得注意的是，当前的'CONFIG_FORTIFY_SRC=y'是利用CVE-2022-0435进行控制流劫持的一种硬缓解措施，因为它会对违规memcpy的大小进行边界检查，并导致akernel恐慌========================================================================感谢====================================================================================================================================================================================================================================I&#39；I’我要感谢TIPC模块的维护人员，以及security@...nel.org和linux-distros@...openwall.org在整个披露过程中为他们的帮助和工作。我还想提及SentinelLabs之前对TIPC进行的漏洞研究，以及他们在CVE-2021-43267上的工作，以及其他安全研究人员发表的关于TIPC利用的发现。-https://www.sentinelone.com/labs/tipc-remote-linux-kernel-heap-overflow-allows-arbitrary-code-execution/-  https://haxx.in/posts/pwning-tipc/========================================================================Disclosure时间线===================================================================================================================================-2022年1月27日：脆弱性与风险；修复建议报告-2022年2月5日：补丁定稿-2022年2月10日：协调发布日期（格林威治标准时间14:00）</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/堆栈/">#堆栈</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tipc/">#tipc</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>