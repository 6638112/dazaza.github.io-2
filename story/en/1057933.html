<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Tailwind UI的建立反应和VUE支持 Building React and Vue Support for Tailwind UI</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Building React and Vue Support for Tailwind UI<br/>Tailwind UI的建立反应和VUE支持 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-13 04:51:51</div><div class="page_narrow text-break page_content"><p>Hey! We&#39;re getting  really close to releasing React + Vue support for Tailwind UI, so I thought it would be interesting to share some of the behind-the-scenes efforts that have gone into even making it possible.</p><p>嘿！我们＆＃39;重新获得释放React + Vue支持TaiLwind UI，所以我认为分享甚至可能陷入困境的努力将是有趣的。</p><p>   From the day we started working on Tailwind UI somewhere in mid-2019 I knew that ultimately it would be 10x more valuable to people if they could grab fully interactive examples built using their favorite JS framework. Trying to make that happen for the first release was way too ambitious though, so we had to figure out how to get there one step at a time.</p><p>   从2019年中期的某个地方开始工作的那一天，我知道，如果他们可以使用他们最喜欢的JS框架建造的完全互动的例子，那么人们就会更加有价值。试图让第一个发布的事情变得太雄心勃勃，所以我们必须弄清楚如何一次到达一步一步。</p><p> We decided to focus on vanilla HTML first because it&#39;s totally universal, and even if something like JSX would be more helpful for some people, there are lots of existing tools out there for converting HTML to JSX that people could lean on already.</p><p> 我们决定首先关注香草HTML，因为它完全普遍，即使JSX像JSX这样的东西对某些人更有用，那么有很多现有的工具将HTML转换为人们可以依赖的JSX 。</p><p> We also made the hard trade-off not to provide any JS for interactions like toggling a responsive menu or opening and closing a modal dialog in the first version. I felt like anything we provided would just do more harm than good, because there&#39;s no one JS framework that makes up the majority of the Tailwind user base. If we catered to React developers, we&#39;d be making it harder to use for the 70% of people  not using React. If we catered to Vue developers, we&#39;d be making it harder for the 70% of people  not using Vue. If we tried to write it in custom vanilla JS, well we&#39;d be making it harder for literally everyone  (seriously do you have any idea how much code it takes to build a robust enter/leave transition system from scratch in JS?)</p><p> 我们还使硬折衷off-of of提供任何JS进行交互，如在第一个版本中切换响应菜单或打开和关闭模态对话框。我觉得我们提供的任何东西都会做得更弊大于，因为那里没有一个JS框架，可以弥补大部分尾风用户群。如果我们愿意反应开发人员，我们＆＃39如果我们迎合Vue开发人员，我们＆＃39如果我们试图在自定义vanilla js中写它，我们＆＃39; d＆＃39; d＆＃39; d的字面上更难（认真对待建立一个强大的输入/离开转换系统，从js划痕拍摄多少钱？ ）</p><p> So instead I just documented the different states using comments in the HTML, and left it to the end user to wire it up with their favorite JS framework. I know a lot of people love that about  Bulma, and I think it was a great approach for us to start with as well.</p><p> 因此，我刚刚使用HTML中的注释记录了不同的状态，并将其留给最终用户以将其连接到他们最喜欢的JS框架。我知道很多人都喜欢关于宽容的人，我认为我们也是一个很好的方法。</p><p> But once we felt like Tailwind UI was pretty fleshed out with hundreds of great examples, we decided it was time to tackle the JS problem and see what we could do.</p><p> 但是，一旦我们觉得莱德风UI很巧妙地用数百个很棒的例子，我们决定是时候解决了JS问题，看看我们能做什么。</p><p>  As an abstract concept adding &#34;JavaScript support&#34; to Tailwind UI sounds straightforward, but when you dig in to the details it is  not. There are  so many decisions to make about what to even build, and so many trade-offs you have to consider when trying to make something useful for as many people as possible.</p><p>  作为抽象概念添加＆＃34; JavaScript支持＆＃34;到TaiLwind UI声音直截了当，但是当您挖掘详细信息时它不是。有很多决定甚至建立什么，以及在试图为尽可能多的人做出有用的东西时需要考虑许多权衡。 </p><p> I tossed the whole concept around in the back of my head for a full year while working on Tailwind UI before I actually had a plan I was happy with. Ultimately, these are the core values I decided on when designing a solution:</p><p>在我实际上有一个计划之前，我在尾风UI工作时扔了整个概念的整个概念整整一年。最终，这些是在设计解决方案时决定的核心值：</p><p> The promise of Tailwind UI is that it&#39;s just a code snippet — it&#39;s easy to customize and adapt by directly editing the code. Any JS examples we provide need to respect this foundational idea.</p><p> TailWind UI的承诺是它＆＃39; s只是一个代码片段 - 它＆＃39;通过直接编辑代码，易于自定义和调整。我们提供的任何JS示例需要尊重这一基础想法。</p><p> The JS needs to be updateable. Unlike the markup which we expect people to just totally own and edit to their heart&#39;s content, the JS needs to come from  node_modules  somehow, because building these things right is hard, there are going to be bugs, and we want to be able to fix them for people without asking them to copy a new code snippet. On top of that, we don&#39;t want people to have to carefully transport 200 lines of JS they didn&#39;t write around their codebase, and constantly worry about accidentally breaking some small implementation detail by mistake.</p><p> JS需要可更新。与我们希望人们完全拥有和编辑他们的心灵的标记不同，JS需要以某种方式来自Node_Modules，因为建立这些事情是艰难的，我们想要的错误，我们想要能够为人们修复他们，而不要求他们复制新的代码片段。在那之上，我们希望人们必须仔细运送200行的JS，他们在他们的代码库上写下，并不断担心错误地错误地打破了一些小的实施细节。</p><p> It just has to be better than vanilla HTML. At the end of the day, the most important thing is that we make the existing experience  better for people using the JS frameworks we decide to add support for first. Any time I found myself frustrated by two competing trade-offs that made it hard to make something  perfect, asking myself &#34;is this still strictly better and in no ways worse for framework X users than vanilla HTML?&#34; provided a lot of clarity.</p><p> 它只是比香草HTML更好。在一天结束时，最重要的是，我们为使用JS框架的人们提供了更好的经验，我们决定首先添加支持。任何时候我发现自己被两个竞争的权衡沮丧，这使得很难做出完美的东西，问自己和＃34;这仍然是严格的，框架X用户比香草HTML更糟糕的方式更好吗？提供了很多清晰度。</p><p> The other thing that was really important to me is that none of the underlying JS stuff was proprietary or Tailwind UI-specific. To me, Tailwind UI is not a UI kit like Ant Design or Material UI — those are great projects but it&#39;s not what I wanted to build.</p><p> 对我来说非常重要的另一件事是，底层JS的东西都没有专有的或尾风UI特定的。对我来说，Tailwind UI不是像蚂蚁设计或材料的UI套件 - 那些是伟大的项目，但它不是我想建造的。</p><p> To me, Tailwind UI is a collection of  blueprints, showing you how to build awesome stuff using tools that are  already available to you. If you want to use things exactly as they come off the shelf you totally can and you&#39;ll get great results. But you should also be able to use Tailwind UI as a helpful starting point, tweak it to the nines, and end up with something that feels uniquely  yours, even if we gave you a boost at the beginning.</p><p> 对我来说，TaiLwind UI是一系列蓝图，向您展示如何使用已经可用的工具构建令人敬畏的东西。如果你想用完全按照他们从架子上的东西来使用，你完全可以和你＆＃39; ll获得了最佳结果。但是，您还应该能够使用Tailewind UI作为一个有用的起点，将其调整到九个，并最终与您感到独特的东西，即使我们在一开始就提升了升级。</p><p> So before we could add JavaScript support to Tailwind UI, we needed to build some tools.</p><p> 因此，在我们可以为Tailwind UI添加JavaScript支持之前，我们需要构建一些工具。 </p><p>  Years ago I remember seeing Kent C. Dodds&#39;  downshift library and thinking  &#34;man, this is a cool concept — all of the complex behavior is tucked away in the library, but all of the actual markup and styling is left to the user&#34;.</p><p>几年前我记得看到肯特C. Dodds＆＃39; Downswift图书馆和思维＆＃34;男人，这是一个很酷的概念 - 所有复杂的行为都藏起在图书馆里，但所有的实际标记和造型都留给了用户＆＃34;</p><p> This sort of approach is the perfect fit for Tailwind philosophically, because the entire goal of Tailwind is to help you build totally custom designs more quickly. Tailwind + a library of JS components that abstract away all of the keyboard navigation and accessibility logic without including any design opinions would be such a powerful combo — it would let teams building totally custom UIs move almost as fast as teams who were content to use hard-to-customize, opinionated frameworks.</p><p> 这种方法是尾风哲学的完美契合，因为Tailewind的整个目标是帮助您更快地建立完全定制的设计。 Tailwind +一个JS组件库，摘要所有键盘导航和可访问性逻辑，而不包括任何设计意见是如此强大的组合 - 它会让团队建设完全定制的UIS几乎与以满足于努力的团队一样快速地移动 - 定制，自以为是框架。</p><p> We looked to see if there were any other tools out there solving these same problems, and while there were a few awesome projects in the space ( Reach UI and  Reakit especially at the time, and  react-aria since starting on our own library, phenomenal work by all those folks), ultimately we decided that something so important for our company would be best to build and control ourselves.</p><p> 我们看看是否有任何其他工具在那里解决了同样的问题，而在空间中有一些很棒的项目（特别是当时到达UI和reakit，而且自从我们自己的图书馆开始以来的反应 -  aria以来所有这些人的工作），最终我们决定为我们公司这么重要的事情将是最好的建立和控制自己。</p><p>  We wanted the APIs to work well with a class-based styling solution like Tailwind. A lot of the other tools out there expected you to write custom CSS to target the different bits of each component, which is very different than the workflow you use to style things with Tailwind. We wanted to design something that was very class-friendly.</p><p>  我们希望API与像尾风一样的基于类的造型解决方案一起使用。许多其他工具出现在那里期待您编写自定义CSS来定位每个组件的不同位，这与您用来用尾风样式的工作流的工作流相同。我们想设计一下非常级别的友好。</p><p> We wanted to support multiple frameworks using a consistent API. There are React libraries, Vue libraries, Angular libraries, and others, but each one is different, designed by different people with different tastes. We wanted something that would be as consistent as possible from framework to framework, so that the framework-specific examples in Tailwind UI wouldn&#39;t be radically different from each other.</p><p> 我们希望使用一致的API支持多个框架。有反应图书馆，Vue库，角图书馆等，但每个人都不同，由不同的口味设计不同的人。我们想要从框架到框架的框架尽可能一致的东西，以便尾行UI中的框架特定示例＆＃39; t彼此彻底不同。</p><p> I was really excited about what we were going to end up with at the end, but holy crap this was going to be a lot of work.</p><p> 我真的很兴奋到最后，我们将最终结束，但圣洁的废话这将是很多工作。</p><p>  We decided to call this project &#34;Headless UI&#34; and in August of last year  Robin Malfait joined the team to work on it full-time, pretty much exclusively.</p><p>  我们决定打电话给这个项目＆＃34;无头UI＆＃34;并于去年8月罗宾马尔公仔加入球队全职工作，几乎完全。 </p><p> The very first thing he worked on was a  Transition component for React that would allow you to add enter/leave animations to elements, entirely using classes, and was very inspired by the   &lt;transition&gt; component in Vue:</p><p>他工作的第一件事是对反应的过渡组件，可以允许您完全使用类添加Enter / Leave动画，并由＆lt;转换和gt非常启发。 Vue中的组件：</p><p> &lt; Transition  show  = {isOpen }  enter  = &#34;transition-opacity duration-75 &#34;  enterFrom  = &#34;opacity-0 &#34;  enterTo  = &#34;opacity-100 &#34;  leave  = &#34;transition-opacity duration-150 &#34;  leaveFrom  = &#34;opacity-100 &#34;  leaveTo  = &#34;opacity-0 &#34; &gt;  I will fade in and out   &lt;/ Transition &gt;</p><p> ＆lt;转换显示= {ISOpen} Enter =＆＃34;过渡透明度持续时间-75＆＃34; experfrom =＆＃34;透明度-0＆＃34; onerto =＆＃34;透明度-100＆＃34;离开=＆＃34;过渡透明度持续时间-150＆＃34;离开=＆＃34;透明度-100＆＃34; Leaveto =＆＃34;透明度-0＆＃34; ＆gt;我会淡入和换取和效果。/过渡＆gt;</p><p> This is a great example of what I meant earlier when I said we really wanted to design components that were &#34;class-friendly&#34;. This component makes it really easy to style your enter/leave transitions with regular old Tailwind utility classes, so it feels just like styling anything else in your app. It&#39;s also  not coupled to Tailwind in any way though, and you can use whatever classes you want!</p><p> 当我说我们真正想要设计＆＃34;班级友好＆＃34的组件时，这是我之前的意思的一个很好的例子。此组件使您的Enter / Leaving Transitions与常规旧的Tailewind实用程序类风格很容易，因此它感觉就像在您的应用中的其他任何内容一样。它＆＃39;也没有以任何方式耦合到尾风，并且您可以使用您想要的任何类！</p><p> We published the  first public release in October, and it included React and Vue libraries with the first three components:</p><p> 我们在10月份发布了第一个公开发布，其中包括前三个组件的反应和Vue库：</p><p>  We landed on a set of APIs that used &#34;compound components&#34; to abstract away all of the complexity while communicating with each other via  context (or  provide/inject in Vue).</p><p>  我们降落在一组使用的API中使用＆＃34;复合组件＆＃34;通过上下文互相通信（或提供/注入Vue）时摘要所有复杂性。</p><p>  import  {  Menu  }  from  &#39;@headlessui/react&#39; function   MyDropdown ( )  {  return  (    &lt; Menu  as  = &#34;div &#34;  className  = &#34;relative &#34; &gt;     &lt; Menu.Button  className  = &#34;px-4 py-2 rounded bg-blue-600 text-white ... &#34; &gt; Options   &lt;/ Menu.Button &gt;     &lt; Menu.Items  className  = &#34;absolute mt-1 right-0 &#34; &gt;     &lt; Menu.Item &gt;   { (  { active  } )  =&gt;  (    &lt;a  className  = {  `  ${active  &amp;&amp;  &#39;bg-blue-500 text-white&#39; }  ... ` }  href  = &#34;/account-settings &#34; &gt;  Account settings    &lt;/a &gt;  ) }     &lt;/ Menu.Item &gt;     &lt; Menu.Item &gt;   { (  { active  } )  =&gt;  (    &lt;a  className  = {  `  ${active  &amp;&amp;  &#39;bg-blue-500 text-white&#39; }  ... ` }  href  = &#34;/documentation &#34; &gt;  Documentation    &lt;/a &gt;  ) }     &lt;/ Menu.Item &gt;     &lt; Menu.Item  disabled &gt;     &lt;span  className  = &#34;opacity-75 ... &#34; &gt; Invite a friend (coming soon!)   &lt;/span &gt;     &lt;/ Menu.Item &gt;     &lt;/ Menu.Items &gt;     &lt;/ Menu &gt;  ) }</p><p>  从＆＃39导入{菜单}; @ headlessui /反应＆＃39;函数mydropdown（）{return（＆lt;菜单为=＆＃34; div＆＃34; classname =＆＃34;相对＆＃34;＆gt;＆gt;＆gt;＆gt; button classname =＆＃34; px-4 py- 2圆形的bg-blue-600文本白色...＆＃34;＆gt;选项＆lt; / menu.button＆gt;＆lt; menum.items classname =＆＃34; absolute mt-1右 -  0＆＃34; ＆gt;＆lt; menum.item＆gt; {（{artive}）=＆gt;（＆lt; classname = {`$ {active＆amp;＆＃39; bg-blue-500 text-white＆＃39;}。 ..`} href =＆＃34; /账户设置＆＃34;＆gt;帐户设置＆lt; / a＆gt;）}＆lt; / menum.item＆gt;＆gt;＆gt;＆gt; {（{artive} ）=＆gt;（＆lt; classname = {`$ {Active＆amp;＆＃39; bg-blue-500 text-white＆＃39;} ...`} href =＆＃34; / documentation＆＃ 34;＆gt;文档＆lt; / a＆gt;）}＆lt; / menu.item＆gt;＆lt; menum.item disabled＆gt;＆lt;＆gt;＆＃34; opacity-75 ...＆＃34;＆＃34;邀请朋友（即将推出！）＆lt; / span＆gt;＆lt; / menu.item＆gt;＆l lt; / menu .ITEMS＆gt; ＆lt; / menu＆gt; ）}</p><p> You&#39;ll notice that to do things like style the &#34;active&#34; dropdown item, we use a  render prop (or a  scoped slot in Vue):</p><p> 你＆＃39; ll注意到做风格的东西和＃34;活跃＆＃34;下拉项，我们使用Render Prop（或Vue中的范围）： </p><p> &lt; Menu.Item &gt;   { (  { active  } )  =&gt;  (    &lt;a  className  = {  `  ${active  &amp;&amp;  &#39;bg-blue-500 text-white&#39; }  ... ` }  href  = &#34;/documentation &#34; &gt;  Documentation    &lt;/a &gt;  ) }    &lt;/ Menu.Item &gt;</p><p>＆lt; menu.item＆gt; {（{Active}）=＆gt; （＆lt; classname = {`$ {活动＆amp;＆＃39; bg-blue-500 text-white＆＃39;} ...`} href =＆＃34; /文件＆＃34;＆gt;文档＆lt; / a＆gt;）}＆lt; / menu.item＆gt;</p><p> Render props aren&#39;t as common as they used to be because hooks have replaced the need for them in many situations. But for this sort of problem where you need access to internal state that&#39;s managed by the component you&#39;re consuming, they are still the right (only?) solution, and very elegant.</p><p> Render Props Aren＆＃39;它通常是常见的，因为他们曾经是因为钩子在许多情况下取代了他们的需要。但是对于这种问题，您需要访问内部状态，＆＃39;由组件管理的内部状态＆＃39;重新消耗，它们仍然是正确的（仅限）解决方案，非常优雅。</p><p>  After releasing the first version of Headless UI in October, we buckled down for a couple of months to release  Tailwind CSS v2.0, and then spent the last month of the year focused on bug fixes and lots of project house keeping before taking a break for the holidays.</p><p>  在10月份发布第一版本的无头UI后，我们向下扣上了几个月的时间来发布Tailwind CSS v2.0，然后花在最后一个月的时间集中在休息前的错误修复和许多项目房子保持扣押为假期。</p><p> When we came back, we buckled down hard to get to work on actually adding React + Vue support to Tailwind UI itself, and the first thing we needed to was audit all of the interactive behavior we needed for the examples in Tailwind UI and figure out what Headless UI abstractions we needed to design.</p><p> 当我们回来时，我们难以努力完成实际增加反应+ Vue支持，以便我们需要的第一件事是审核我们在Tailwind UI中所需的所有互动行为，并弄清楚我们需要设计的无头UI抽象。</p><p> This was actually a pretty interesting and challenging job, because it&#39;s really not always obvious how a certain design-specific interaction should map to an established UI pattern that has known accessibility expectations.</p><p> 这实际上是一个非常有趣和有挑战性的工作，因为它真的并不总是显而易见的是，某种设计特定的交互应该如何映射到具有已知可访问性期望的建立的UI模式。</p><p>   But some are a lot trickier. For example, what about mobile menus, the kind of thing you open with a hamburger button?</p><p>   但有些人很棘手。例如，移动菜单怎么样，你用汉堡包按钮打开的东西？</p><p>   What if it just opens in place and pushes the rest of the page further down?</p><p>   如果它刚刚打开它，该怎么用下一页又一次地推开？ </p><p> We worked through questions like this regularly, and landing on good solutions took a lot of research and experimentation. We&#39;re lucky to have  David Luhr on the team who has specialized in accessibility for a long time, and with his help we were able to feel really good about the solutions we landed on.</p><p>我们经常这样的问题工作，并在良好的解决方案上降落了很多研究和实验。我们＆＃39;重新幸运地在团队中拥有大卫Luhr，他们一直专注于漫长的可访问性，并在他的帮助下，我们能够觉得我们降落的解决方案真的很好。</p><p> Here&#39;s what we decided we needed in order to support the patterns that already existed in Tailwind UI:</p><p> 在这里，我们决定我们需要的是什么，以支持Tailwind UI已经存在的模式：</p><p> Menu Button. Used for dropdown menus that only contain links or buttons, like a little actions menu at the end of a table row.</p><p> 菜单按钮。用于下拉菜单，只包含链接或按钮，就像表行末尾的小动作菜单一样。</p><p> Listbox. For custom  select implementations where you want to include extra stuff in the  option elements. For example a country picker where you put a flag next to each country.</p><p> 列表框。有关自定义选择要在选项元素中包含额外内容的自定义选择。例如，您将在每个国家/地区放置旗帜的国家选择器。</p><p>  Disclosure. For showing/hiding content in place. Think like collapsable FAQ questions. Also useful for bigger chunks of UI too though, like a mobile menu that opens in place and pushes the rest of the page down.</p><p>  披露。将含量显示/隐藏到位。认为像崩溃的常见问题解答问题一样。对于更大的UI块也很有用，例如，就像一个打开的移动菜单一样打开并按下其余页面。</p><p> Dialog. For, well, modal dialogs! But also for mobile navigation that slides out from the side of the page, and other &#34;take-over&#34;-style UIs, even if they don&#39;t look like a traditional panel-centered-in-the-screen modal.</p><p> 对话。好吧，模态对话！而且对于从页面侧面滑出的移动导航，以及其他＆＃34;即使他们没有看起来像一个传统的面板中心 - 屏幕模态。</p><p> Popover. For panels that pop up on top of the page when you click a button. This is useful for menus where you need lots of custom content that would violate the strictness of regular  role=&#34;menu&#34; menu buttons. We use these for some mobile menus, flyout menus in navigation bars, and other interesting places too. It&#39;s kind of like a menu/disclosure hybrid.</p><p> 弹出窗口。对于单击按钮时弹出页面顶部的面板。这对菜单很有用，您需要大量的自定义内容，这些内容将违反常规角色的严格性=＆＃34;菜单＆＃34;菜单按钮。我们将这些用于一些移动菜单，在导航栏中的弹性菜单以及其他有趣的地方。它＆＃39;那种类似菜单/披露混合。 </p><p> Radio Group. For custom radio selection UIs, like where you want a set of clickable cards instead of a boring little radio circle.</p><p>无线电群。对于自定义无线电选择UI，如您想要一组可点击的卡而不是无聊的小无线电圈。</p><p> We ran into tons of challenges building this stuff, especially around complex stuff like focus management, and  especially around nested focus management.</p><p> 我们遇到了大量的挑战，尤其是焦点管理等复杂的东西，特别是嵌套焦点管理。</p><p> Imaging you have a modal that opens, and inside that modal there&#39;s a dropdown. You open the modal, then open the dropdown, and hit escape. What happens? Well the dropdown should close right, but the modal should stay open.</p><p> 成像你有一个莫代尔，打开，在那里的模态里面有一个下拉列表。你打开模态，然后打开下拉目，然后命中逃生。怎么了？下拉下降应该右转，但模态应该保持开放。</p><p> I guarantee 99% of modals on the internet would close too in this case, even though they aren&#39;t supposed to. But not ours — ours works!</p><p> 我保证在这种情况下，互联网上的99％的模态在这种情况下也会接近，即使他们应该争夺＆＃39; t应该。但不是我们的 - 我们的作品！</p><p> We  (well mostly Robin) spent  months working on little details like this to make everything as bullet-proof as possible, and while I&#39;m sure there have to be bugs hiding in there still somewhere, where we ended up feels  so rock solid compared to almost every UI you encounter day-to-day on the web.</p><p> 我们（主要是罗宾）花了几个月的几个细节，如此，使一切都能尽可能地成为子弹证明，而我肯定必须有臭虫仍然在某个地方藏起，我们最终却被摇滚乐与几乎所有UI相比，您在网络上遇到的几乎所有UI。</p><p> We still have a lot of new patterns we want to add to Headless UI like tabs, accordions, maybe even  gulp a datepicker, and we&#39;re looking forward to exploring other frameworks in the future (Alpine.js is next on our list), but we&#39;re super proud to call what we&#39;re releasing this week Headless UI v1.0 and commit to a stable API going forward.</p><p> 我们仍然有很多新的模式我们想要添加到无头UI，如标签，手风琴，也许甚至是古代古怪的诡辩，我们＆＃39;我们期待着探索未来的其他框架（Alpine.js是我们的名单上的下一个框架）但是，我们＆＃39;重新激动地称之为我们＆＃39;重新发布本周的无头UI v1.0并提交稳定的API。</p><p>   With the Headless UI stuff figured out, the next big problem was figuring out  exactly what a React or Vue version of an existing Tailwind UI example should look like.</p><p>   使用无头UI的ui upost out out，下一个大问题是究竟究竟是一个现有的尾风UI示例的反应或Vue版本应该是什么样的。 </p><p> The examples in Tailwind UI are pure HTML snippets — you find something you like, copy the HTML into your project, then tweak it as much you like, chop it up into individual components, whatever you want. We don&#39;t make any assumptions about how you&#39;re going to use it, what elements you&#39;re going to keep or delete, or how you want to abstract away any duplication with your preferred tools.</p><p>TailWind UI中的示例是纯HTML片段 - 您找到了您喜欢的东西，将HTML复制到您的项目中，然后将其调整为您喜欢的方式，将其切换为单个组件，无论您想要什么。我们不会对你如何使用它，＆＃39做出任何假设</p><p> This is an easy decision when working with pure HTML — what other choice do you really even have? But when offering framework-specific examples, it gets a lot trickier to know exactly what to provide.</p><p> 使用纯HTML时，这是一个轻松的决定 - 您真的有什么选择？但是在提供框架特定的例子时，它会恰好了解所提供的内容。</p><p> The biggest question was how hard should we try to remove any duplication, and what are the right approaches to doing so?</p><p> 最大的问题是我们应该努力消除任何重复，以及做什么方法是什么？</p><p> Both React and Vue are  component frameworks, and the way you reuse code in your projects is by extracting bits of UI into components that you can use over and over again.</p><p> 反应和VUE都是组件框架，以及您在项目中重用代码的方式是通过将UI的位提取到您可以在遍历一遍又一遍地使用的组件。</p><p> The challenge is that creating components like that is always  very project specific. Take this list component for example:</p><p> 挑战是创建像这样的组件，总是是特定的项目。占用此列表组件：</p><p>     For example, it assumes the items are team members. What if you&#39;re building an invoicing app and you want to use this pattern for a list of clients instead? Hell, you might be using this for a sports betting app and these should be baseball teams, not even people!</p><p>     例如，它假设项目是团队成员。如果您＆＃39;重新构建发票应用程序，您希望使用此模式以获取客户的列表吗？地狱，你可能会用这个运动赌注应用程序，这些应该是棒球队，甚至不是人！</p><p> It also makes assumptions about the shape of a  member object. It would have to encode that it&#39;s pulling out a  name and an  email property, even though your data might be different.</p><p> 它还使构件对象的形状做出假设。它必须编码它＆＃39;删除名称和电子邮件属性，即使您的数据可能不同。 </p><p> The other issue is that in frameworks like Vue, you can only have one component per file. This means copying an example that was made up of 4-5 subcomponents would mean you have to copy 4-5 different snippets, create files for each one, and link them all together with the correct names/paths.</p><p>另一个问题是，在像Vue这样的框架中，每个文件只能有一个组件。这意味着复制由4-5个子组件组成的示例意味着您必须复制4-5个不同的片段，为每个播放片段创建文件，并将它们全部与正确的名称/路径一起链接。</p><p> To me, something about doing all of this for people felt like going too far, at least for the problem we&#39;re trying to solve today. When everything is super broken up like that with predefined prop APIs and deliberately chosen component names,  it feels like you aren&#39;t supposed to change it anymore. What I love about Tailwind UI is that clicking the &#34;code&#34; tab feels like opening up some complex piece of electonics and seeing all of the circuitry right there in front of you. It&#39;s a learning opportunity, and you can read the markup and class names and understand how it all works together.</p><p> 对我来说，关于人们对人们觉得这一切的事情感觉太过分了，至少对于我们今天试图解决的问题。当一切都像预定义的道具API一样超级打破，并且故意选择组件名称时，它感觉像你aren＆＃39; t应该知道它了。我对Tailwind UI的热爱是点击＆＃34;代码＆＃34;选项卡感觉就像打开一些复杂的electonics，并在你面前看到所有的电路。它＆＃39;是一个学习机会，你可以阅读标记和类名并了解如何将其工作在一起。</p><p> I wrestled with it for a long time, but ultimately decided that right now we were trying to solve two main problems:</p><p> 我长期以来摔倒了，但最终决定了现在我们试图解决两个主要问题：</p><p> Give people code using the syntax they actually need, like giving React users JSX instead of HTML so they don&#39;t have to manually convert things like  for to  labelFor.</p><p> 使用他们实际需要的语法给予人们代码，例如给出反应用户JSX而不是HTML，所以他们不得不手动将类似于Labelfor的东西转换为Labelpor。</p><p> Make the interactive elements work out of the box, so dropdowns, mobile menus, toggles, and everything else was ready to go, instead of having to write all of that boilerplate JS yourself.</p><p> 让交互式元素开箱即用，所以下拉，移动菜单，切换，以及其他一切都准备好了，而不是必须自己写下所有的样板JS。</p><p> I decided that the right solution was to focus on solving those problems, and be careful not to do anything that would turn Tailwind UI into a different product.</p><p> 我决定的是，正确的解决方案是专注于解决这些问题，并注意不要做任何将尾风U​​I转换为不同产品的任何东西。</p><p> So this is what&#39;s different when you look at a React or Vue example compared to the vanilla HTML version:</p><p> 因此，与Vanilla HTML版本相比，当您查看React或Vue示例时，这是＆＃39; </p><p> Each framework example uses the right syntax — React examples use JSX, and Vue examples are provided in the single-file component syntax.</p><p>每个框架示例使用正确的语法 -  React示例使用JSX，并且在单文件组件语法中提供了VUE示例。</p><p> Transitions are real now — instead of comments telling you what classes to add at each phase of a transition, the transition is just there, using either a Headless UI transition component or Vue&#39;s native transition component.</p><p> 转换现在是真实的 - 而不是评论，而不是在转换的每个阶段添加什么类，转换就在那里，使用无头UI转换组件或Vue＆＃39;原生转换组件。</p><p> Interactive elements are handled by Headless UI — you&#39;ll see a few imports in any example that requires JS where we pull in the required Headless UI components and then those are used directly in the markup.</p><p> 互动元素由无头UI处理 - 您＆＃39; LL在任何示例中看到一些需要js的少数导入，其中我们拉到所需的无需UI组件，然后直接在标记中使用。</p><p> Any repeated chunks of markup have been converted into basic loops — any data-driven loop stuff (like lists of people, or navigation items) are extracted into simple variables right there in the example to reduce duplication but still keep everything together in one place. In your own projects, you&#39;d swap this out with data from an API or database or whatever, but we keep the examples simple and don&#39;t make any assumptions for you.</p><p> 任何重复的标记块已被转换为基本循环 - 任何数据驱动的循环填充（如人员名单或导航项目）都会在示例中提取到简单变量中，以减少复制，但仍将所有内容保持在一个地方。在您自己的项目中，您＆＃39; d与来自API或数据库的数据或任何内容换句话说，但我们保持简单和DON＆＃39; T对您做出任何假设。</p><p> Icons are pulled in from the Heroicons library. Instead of inlining the SVG directly whenever an icon is used, we pull them in from our React/Vue icon libraries instead of keep the markup simpler.</p><p> 图标从海英语库中拉入。只要使用图标，我们从我们的React / Vue图标库中将它们拉到On In而不是保持标记更简单时，而不是将其拉入SVG。</p><p>  import  {  Menu ,  Transition  }  from  &#39;@headlessui/react&#39; import  {  DotsVerticalIcon  }  from  &#39;@heroicons/react/solid&#39; import  {  Fragment  }  from  &#39;react&#39; const people  =  [  { name :  &#39;Calvin Hawkins&#39; , email :  &#39;calvin.hawkins@example.com&#39; , image :  &#39;https://images.unsplash.com/photo-1491528323818-fdd1faba62cc?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=facearea&amp;facepad=2&amp;w=256&amp;h=256&amp;q=80&#39; ,  } ,  { name :  &#39;Kristen Ramos&#39; , email :  &#39;kristen.ramos@example.com&#39; , image :  &#39;https://images.unsplash.com/photo-1550525811-e5869dd03032?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=facearea&amp;facepad=2&amp;w=256&amp;h=256&amp;q=80&#39; ,  } ,  { name :  &#39;Ted Fox&#39; , email :  &#39;ted.fox@example.com&#39; , image :  &#39;https://images.unsplash.com/photo-1500648767791-00dcc994a43e?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=facearea&amp;facepad=2&amp;w=256&amp;h=256&amp;q=80&#39; ,  } , ] export  default  function   Example ( )  {  return  (    &lt;ul  className  = &#34;divide-y divide-gray-200 &#34; &gt;   {people . map ( ( person )  =&gt;  (    &lt;li  key  = {person . email }  className  = &#34;py-4 flex &#34; &gt;     &lt;img  className  = &#34;h-10 w-10 rounded-full &#34;  src  = {person . image }  alt  = &#34; &#34;  /&gt;     &lt;div  className  = &#34;ml-3 &#34; &gt;     &lt;p  className  = &#34;text-sm font-medium text-gray-900 &#34; &gt; {person . name }   &lt;/p &gt;     &lt;p  className  = &#34;text-sm text-gray-500 &#34; &gt; {person . email }   &lt;/p &gt;     &lt;/div &gt;     &lt; Menu  as  = &#34;div &#34;  classN</p><p>  导入{菜单，转换}从＆＃39; @ headlessui /反应＆＃39;从＆＃39导入{dotsverticalicon}; @ hericons /反应/ solid＆＃39;从＆＃39导入{碎片};反应＆＃39; const people = [{name：＆＃39;凯文霍金斯＆＃39; ，电子邮件：＆＃39; calvin.hawkins@example.com&#39; ，图像：＆＃39; https：//images.unsplash.com/photo-1491528323818-fdd1faba62cc？ixlib = rb-1.2.1＆amp; ixid = eyjhchbfawqiojeymdd9＆amp; auto = format＆amp; faceearea＆amp; facepad = 2＆amp; w = 256＆amp; w = 256＆amp; w = 256＆amp; w = 256＆amp; w = 256＆ ; h = 256＆amp; q = 80＆＃39; ，}，{名：＆＃39;克里斯汀·拉莫斯＆＃39; ，电子邮件：＆＃39; kristen.ramos@example.com&#39; ，图像：＆＃39; https：//images.unsplash.com/photo-1550525811-205869dd03032？ixlib = rb-1.2.1＆amp; ixid = eyjhchbfawqiojeymdd9＆amp; auto = format＆amp; facearea＆amp; facepad = 2＆amp; w = 256＆amp; w = 256＆amp; w = 256＆amp; w = 256＆ ; h = 256＆amp; q = 80＆＃39; ，}，{名：＆＃39; ted fox＆＃39; ，电子邮件：＆＃39; ted.fox@example.com&#39;图像：＆＃39; HTTPS：？//images.unsplash.com/photo-1500648767791-00dcc994a43e ixlib = RB-1.2.1＆安培; ixid = eyJhcHBfaWQiOjEyMDd9＆安培;汽车=格式＆安培;配合= facearea＆安培; facepad = 2及W = 256＆安培; h = 256＆amp; q = 80＆＃39; ，}，]导出默认函数示例（）{return（＆lt; ul classname =＆＃34; divide-y divide-gray-200＆＃34; {人。地图（（人）=＆gt;（＆lt; li key = {person。电子邮件} classname =＆＃34; py-4 flex＆＃34;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆gt;＆＃34; h-10 w-10圆满＆＃34; src = {人。Image} Alt =＆＃34;＆＃34; /＆gt;＆gt;＆gt;＆＃34; ml-3＆＃34;＆l lt; p classname =＆＃34; text-sm字体媒体文本-Gray-900＆＃34;＆gt; {人。姓名}＆lt; / p＆gt;＆lt; p classname =＆＃34; text-sm text-gray-500＆＃34;＆gt; {人。电子邮件}＆lt ; / p＆gt;＆lt; / div＆gt;＆lt;菜单AS =＆＃34; div＆＃34; classn</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.tailwindcss.com/building-react-and-vue-support-for-tailwind-ui">https://blog.tailwindcss.com/building-react-and-vue-support-for-tailwind-ui</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ui/">#ui</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/react/">#react</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>