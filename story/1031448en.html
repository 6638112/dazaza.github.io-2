<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Qt 6.0中的图形：QRhi、Qt Quick、Qt Quick 3D</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Qt 6.0中的图形：QRhi、Qt Quick、Qt Quick 3D</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-27 19:49:07</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/b24b72a17475c03d71502f9260c2ad38.png"><img src="http://img2.diglog.com/img/2020/10/b24b72a17475c03d71502f9260c2ad38.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Last year we had a three part blog series about Qt&#39;s new approach to working with 3D graphics APIs and shading languages:  part 1,  part 2,  part 3. For  Qt Quick, an early, opt-in preview of the new rendering architecture was shipped in Qt 5.14, with some improvements in Qt 5.15. With the release of Qt 6.0 upcoming, let&#39;s see what has happened since Qt 5.15. It will not be possible to cover every detail of the graphics stack improvements for Qt Quick here, let alone dive into the vast amount of Qt Quick 3D features, many of which are new or improved in Qt 6.0. Rather, the aim is just to give an overview of what can be expected from the graphics stack perspective when Qt 6.0 ships later this year.</p><p>去年，我们有一个关于Qt使用3D图形API和着色语言的新方法的博客系列，分为三部分：第一部分，第二部分，第三部分。对于Qt Quick，新渲染架构的早期选择加入预览在Qt5.14中发布，在Qt5.15中有一些改进。随着Qt6.0的发布即将到来，让我们看看自Qt5.15以来发生了什么。这里不可能涵盖Qt Quick图形堆栈改进的每一个细节，更不用说深入研究Qt Quick3D的大量特性了，其中许多特性是Qt6.0中的新特性或改进特性。相反，其目的只是为了概述今年晚些时候Qt6.0发布时从图形堆栈的角度可以看到的情况。</p><p> Note that the documentation links refer to the Qt 6 snapshot documentation. This allows seeing the latest C++ and QML API pages, including all changed and new functions, but the content is also not final. These links may also break later on.</p><p>请注意，文档链接引用Qt6快照文档。这允许查看最新的C++和QML API页面，包括所有更改的和新的函数，但内容也不是最终的。这些联系稍后也可能会中断。</p><p>  QRhi, the Qt Rendering Hardware Interface, is Qt&#39;s internal graphics abstraction when 3D APIs, such as OpenGL, Vulkan, Metal, and Direct 3D, are involved. Compared to 5.15, the main improvements in 6.0 are a lot of polishing fixes here and there, and, most importantly, a large set of performance optimizations. While benefitting Qt Quick as well, these become especially important with Qt Quick 3D when complex scenes with many renderable objects are involved.</p><p>QRHI，即Qt渲染硬件接口，当涉及到OpenGL、Vulkan、Metal和Direct 3D等3DAPI时，它是Qt&#39；的内部图形抽象。与5.15相比，6.0的主要改进是这里和那里进行了大量的改进，最重要的是，进行了大量的性能优化。在使Qt Quick受益的同时，当涉及到包含许多可渲染对象的复杂场景时，这些在Qt Quick 3D中变得特别重要。</p><p> With some simplifications, the main layers of the Qt 6.0 graphics stack can be visualized like this:</p><p>通过一些简化，Qt 6.0图形堆栈的主要层可以如下所示：</p><p>   The Qt Shader Tools module is now a selectable module in the installer. For applications this can be relevant because this is the module that provides the  qsb command-line tool (not to be confused with  qbs) and its associated CMake build system integration. In addition, the module is a mandatory dependency for Qt Quick 3D at the moment.</p><p>Qt着色器工具模块现在是安装程序中的可选模块。对于应用程序，这可能是相关的，因为这是提供QSB命令行工具(不要与QB混淆)及其关联的CMake构建系统集成的模块。此外，目前该模块是Qt Quick 3D的强制依赖项。</p><p> Qt 6 no longer uses OpenGL-compatible GLSL source snippets directly. Rather, shaders are all written in Vulkan-style GLSL, then reflected and translated to other shading languages, and finally packaged up into a serializable QShader object that can be consumed by QRhi. The shader preparation pipeline in Qt 6 is the following:</p><p>Qt6不再直接使用与OpenGL兼容的GLSL源代码片段。相反，着色器都是用Vulkan风格的GLSL编写的，然后反射并转换为其他着色语言，最后打包成可序列化的QShader对象，供QRhi使用。Qt 6中的着色器准备管道如下所示：</p><p>  In QML applications using Qt Quick, whenever working with ShaderEffect, or subclassing QSGMaterialShader, the application will need to provide a baked shader pack in form of a .qsb file. These are generated by the  qsb tool. This does not however mean that developers have to start dealing with a new tool directly: with the CMake integration one can easily list the vertex, fragment, and compute shaders in CMakeLists.txt via the qt6_add_shaders() CMake function. Invoking qsb and packing the resulting .qsb files into the Qt resource system is then taken care of by the build system.</p><p>在使用Qt Quick的QML应用程序中，每当使用ShaderEffect或子类化QSGMaterialShader时，应用程序都需要以.qsb文件的形式提供烘焙的着色器包。这些是由QSB工具生成的。但是，这并不意味着开发人员必须直接开始使用新工具：使用CMake集成，可以通过qt6_add_shaders()CMake函数轻松列出CMakeLists.txt中的顶点、碎片和计算着色器。调用QSB并将生成的.qsb文件打包到Qt资源系统中，然后由构建系统负责。</p><p> See  the shadertools documentation for an overview of how graphics and compute shaders are handled in Qt 6 and the details of the qsb tool and its CMake integration.</p><p>有关如何在Qt6中处理图形和计算着色器的概述，以及QSB工具及其CMake集成的详细信息，请参见shadertools文档。</p><p>  In Qt 5.14 and 5.15, Qt Quick shipped with an optional QRhi-based rendering path that could be enabled by setting the environment variable  QSG_RHI. This allowed painless experimenting with the new stack, while keeping the traditional, battle tested direct OpenGL code path the default.</p><p>在Qt 5.14和5.15中，Qt Quick附带了一个可选的基于QRhi的呈现路径，可以通过设置环境变量QSG_RHI来启用该路径。这允许轻松地试验新堆栈，同时保持传统的、经过战斗测试的直接OpenGL代码路径为默认路径。</p><p> In Qt 6.0 all such switches are gone. There is no way get rendering go directly to OpenGL with Qt Quick scenes. Rather, the new default is the QRhi-based rendering path of the Qt Quick scene graph. Other than the defaults changing, the ways to configure what QRhi backend, and so which graphics API to use are mostly unchanged compared to Qt 5.15. See  the documentation for details. One difference is better API naming: in C++ code to request, and so effectively tie the application to, a given QRhi backend (and by extension graphics API) is now done through the  QQuickWindow::setGraphicsApi() function, whereas in 5.15 this task used to be pushed onto an overload of setSceneGraphBackend(), leading to fairly inaccurate naming.</p><p>在Qt6.0中，所有这样的开关都消失了。没有办法获得渲染直接到OpenGL的Qt快速场景。相反，新的默认设置是Qt快速场景图的基于QRHI的渲染路径。与Qt5.15相比，除了更改默认设置之外，配置什么QRhi后端以及使用哪个图形API的方式几乎没有变化。有关详细信息，请参阅文档。一个不同之处在于更好的API命名：在请求的C++代码中，现在通过QQuickWindow：：setGraphicsApi()函数来完成给定的QRhi后端(以及扩展的图形API)，而在5.15中，此任务通常被推到setSceneGraphBackend()的重载上，从而导致相当不准确的命名。</p><p> There are a number of implications, although many applications will not notice any of these. If an application uses neither shader code (ShaderEffect, QSGMaterial) nor does it perform its own rendering with OpenGL directly, there is a very high chance that it will need no migration steps at all. (at least not because of graphics)</p><p>虽然许多应用程序不会注意到其中的任何一个，但这其中有很多含义。如果应用程序既不使用着色器代码(ShaderEffect、QSGMaterial)，也不直接使用OpenGL执行自己的渲染，则很有可能根本不需要迁移步骤。(至少不是因为图形)。</p><p>  What about applications that use OpenGL directly in one way or another, and are not interested in functioning with other graphics APIs? For example, applications that use  QQuickFramebufferObject, or connect to signals like  QQuickWindow::beforeRendering() to inject their own OpenGL rendering under or above the Qt Quick scene. This is when the setGraphicsApi() function mentioned above comes into play for real: if an application wishes, it can always state that it wants OpenGL (or Vulkan, or Metal, or D3D) only, and nothing else. That way it is guaranteed that Qt Quick is going to use the corresponding QRhi backend (or else it will fail to initialize), so the application can safely assume that going directly to OpenGL is safe, because Qt Quick will also end up rendering through OpenGL. Note that this does not exempt the application from having to do other type of porting steps: for example, if it in addition uses ShaderEffect or creates its own custom materials, it will still need to migrate to the new ways of handling shaders and materials.</p><p>如果应用程序以这样或那样的方式直接使用OpenGL，并且对使用其他图形API不感兴趣呢？例如，使用QQuickFrameBufferObject或连接到QQuickWindow：：beforeRending()等信号的应用程序在Qt Quick场景下或之上注入其自己的OpenGL渲染。这就是上面提到的setGraphicsApi()函数真正发挥作用的时候：如果应用程序愿意，它总是可以声明它只需要OpenGL(或Vulkan、Metal或D3D)，而不需要其他任何东西。这样可以保证Qt Quick将使用相应的QRhi后端(否则它将无法初始化)，因此应用程序可以安全地假设直接转到OpenGL是安全的，因为Qt Quick最终也将通过OpenGL呈现。请注意，这并不免除应用程序必须执行其他类型的移植步骤：例如，如果应用程序另外使用ShaderEffect或创建自己的自定义材质，则仍需要迁移到处理着色器和材质的新方法。</p><p>  The API changes mainly fall into 3 categories. This is not going to be an exhaustive list, but rather just a peek at some of the important changes. Detailed change lists and porting guides are expected to be available with the final Qt 6.0 release.</p><p>API的变化主要分为三类。这不会是一个详尽的清单，而只是一些重要变化的一瞥。详细的更改列表和移植指南预计将在最终的Qt6.0版本中提供。</p><p> Different approach to shaders and materials:  QSGMaterialShader received a full revamp (matching more or less what the now-removed QSGMaterialRhiShader used to be in 5.14 and 5.15).  ShaderEffect no longer allows inline shader strings. Rather, the vertexShader and fragmentShader properties are URLs, similarly to  Image.source and others. They can refer to a local .qsb file, or a .qsb file embedded via the Qt resource system (qrc).</p><p>不同的着色器和材质方法：QSGMaterialShader进行了全面更新(与5.14和5.15中已移除的QSGMaterialRhiShader或多或少相同)。ShaderEffect不再允许内联着色器字符串。相反，vertexShader和framentShader属性是URL，类似于image.Source和其他属性。它们可以引用本地.qsb文件，或通过Qt资源系统(QRC)嵌入的.qsb文件。</p><p> Removing OpenGL-specifics from QQuickWindow, QSGTexture, and elsewhere. It should come as no surprise that functions like  GLuint textureId(),  createTextureFromId(GLuint textureId, ...), or  setRenderTarget(GLuint fboId) are now gone. Adopting (wrapping) an existing OpenGL texture, Vulkan image, Metal texture, or D3D11 texture, or accessing the underlying native texture for a QSGTexture is still perfectly possible, but now is done via a different set of APIs, such as  QSGVulkanTexture and the  other similar classes, instances of which are  queryable from QSGTexure.</p><p>从QQuickWindow、QSGTexture和其他地方删除特定于OpenGL的信息。GLuint textureId()、createTextureFromId(GLuint textureId，...)或setRenderTarget(GLuint FboId)等函数现在消失了，这并不奇怪。采用(包装)现有的OpenGL纹理、Vulkan图像、Metal纹理或D3D11纹理，或者访问QSGTexture的底层原生纹理仍然是完全可能的，但现在是通过一组不同的API完成的，例如QSGVulkanTexture和其他类似的类，其实例可从QSGTexure查询。</p><p> Integrating the application&#39;s own custom rendering with the graphics API that Qt Quick renders with is fully supported, not just for OpenGL, but also Vulkan, Metal, and D3D11. Due to their nature however, some of these APIs will need more than connecting to one single signal like beforeRendering() or afterRendering(). For example, we now also have  beforeRenderPassRecording(). See the relevant section in the  scenegraph overview docs for more details and links to examples. Finally, the number of native graphics resources queryable via  QSGRendererInterface has been extended, now covering Vulkan, Metal, and Direct 3D too.</p><p>集成应用程序自己的自定义渲染与Qt Quick渲染使用的图形API完全受支持，不仅适用于OpenGL，还适用于Vulkan、Metal和D3D11。然而，由于它们的性质，其中一些API需要连接到多个单一信号，如beforeRenender()或After Renender()。例如，我们现在还拥有beforeRenderPassRecord()。有关更多详细信息和示例链接，请参阅场景图概述文档中的相关部分。最后，可以通过QSGRendererInterface查询的原生图形资源的数量已经扩展，现在也涵盖了Vulkan、Metal和Direct3D。</p><p> Extending support for redirecting the Qt Quick scene into an offscreen render target.  QQuickRenderControl and the related infrastructure has been heavily enhanced. This was done not just to enable working with graphics APIs other than OpenGL the same way as in Qt 5 (for example, to render a Qt Quick scene into a Vulkan VkImage without an on-screen window), but also to enable integration with AR/VR frameworks and APIs such as  OpenXR (in combination with any of Vulkan, D3D11, or OpenGL). Besides the slightly changed QQuickRenderControl interface, we now have a number of helper classes that improve the configurability of a QQuickWindow:  QQuickRenderTarget,  QQuickGraphicsDevice, and  QQuickGraphicsConfiguration. These are essential in scenarios where a more fine grained control is needed: integrating with APIs like OpenXR is not always straightforward when an existing rendering engine is involved, with a number of potential chicken-egg problems when it comes to the creation, initialization, and ownership of instance, device, and other graphics objects: Which Vulkan instance should Qt Quick use, or should it create a new one upon initializing the scenegraph for the first time? Which Vulkan physical device or DXGI adapter should Qt Quick pick, or just stay with the default? Which VkDevice extensions should be enabled in addition to what Qt itself needs? What 2D image/texture should rendering target, who creates that and when? The expectation is that Qt 6.0 will be well-prepared and providing the foundations for further exploring the world of AR/VR during the rest of the Qt 6.x series.</p><p>扩展对将Qt快速场景重定向到屏幕外渲染目标的支持。QQuickRenderControl和相关的基础设施得到了极大的增强。这样做不仅是为了能够以与Qt5中相同的方式使用OpenGL以外的图形API(例如，在没有屏幕窗口的情况下将Qt Quick场景渲染到Vulkan VkImage中)，而且还为了能够与AR/VR框架和诸如OpenXR的API集成(与Vulkan、D3D11或OpenGL中的任何一个相结合)。除了略微更改的QQuickRenderControl接口之外，我们现在还有许多帮助器类来改进QQuickWindow的可配置性：QQuickRenderTarget、QQuickGraphicsDevice和QQuickGraphicsConfiguration。在需要更细粒度控制的场景中，这些是必不可少的：当涉及到现有的呈现引擎时，与OpenXR这样的API集成并不总是简单的；当涉及到实例、设备和其他图形对象的创建、初始化和所有权时，会有许多潜在的鸡生蛋问题：Qt Quick应该使用哪个Vulkan实例，或者应该在第一次初始化场景图时创建一个新的Vulkan实例？Qt应该快速选择哪个Vulkan物理设备或DXGI适配器，还是只保留默认设置？除了Qt本身需要什么之外，还应该启用哪些VkDevice扩展？渲染应该以什么2D图像/纹理为目标，由谁创建，何时创建？期望Qt6.0做好充分的准备，为在Qt6.x系列的其余部分中进一步探索AR/VR世界奠定基础。</p><p>  A comprehensive example of the new approach to shader code in ShaderEffect is the Qt 6 port of the classic Qt 5 Cinematic Experience demo.  (GitHub repo) This version is ported to CMake and is fully functional with all graphics APIs, including all shader and particle effects.</p><p>ShaderEffect中的着色器代码新方法的一个综合示例是经典的Qt5电影体验演示的Qt6端口。(GitHub Repo)此版本已移植到CMake，并且具有所有图形API的完整功能，包括所有着色器和粒子效果。</p><p>  Looking at the QML source code, for example the code for the  curtain effect shows that indeed it has all inline GLSL strings removed.</p><p>查看QML源代码，例如窗帘效果的代码显示，它确实删除了所有内联GLSL字符串。</p><p>  Instead, the vertex and fragment shaders now live as  ordinary files in the source tree, not bundled with the application executable anymore.</p><p>相反，顶点着色器和碎片着色器现在在源树中作为普通文件存在，不再与应用程序可执行文件捆绑在一起。</p><p>  It is now up to the build system and Qt Shader Tools to compile, reflect, and translate at build time - with the added benefit of shader compilation errors becoming proper build errors instead of obscure runtime problems! - and then bundle the resulting .qsb files with the application. This is what the qt6_add_shaders() function achieves in  the project&#39;s CMakeLists.txt</p><p>现在由构建系统和Qt着色器工具在构建时编译、反射和转换-着色器编译错误成为正确的构建错误而不是模糊的运行时问题！-然后将生成的.qsb文件与应用程序捆绑在一起。这就是qt6_add_shaders()函数在项目的CMakeLists.txt中实现的功能。</p><p>   Those interested in some of the lower level topics, such as working directly with the scenegraph, or integrating 3D rendering code with it, are advised to check out the revised list of scenegraph examples that ship with Qt, see the  Scene Graph section here. All of these have been updated for Qt 6.0, whereas some of them are brand new.</p><p>那些对一些较低级别的主题感兴趣的人，例如直接使用场景图，或将3D渲染代码与其集成，建议查看Qt附带的场景图示例的修订列表，请参阅此处的场景图部分。所有这些都是在Qt6.0中更新的，而其中一些是全新的。</p><p> For instance, the  Custom Material example has been introduced specifically to focus on how a custom QQuickItem using its own material can be implemented.</p><p>例如，专门介绍了自定义材质示例，以关注如何实现使用其自己的材质的自定义QQuickItem。</p><p>  Also noteworthy are the graphics API specific examples, that follow in the vein of Qt 5&#39;s  openglunderqml example, now demonstrating how to achieve the same with Vulkan, Metal, and Direct3D 11. Naturally, these examples are only functional with the graphics API in question. Looking at their main() function will reveal that they all enforce the relevant RHI backend.</p><p>同样值得注意的是特定于图形API的示例，下面是Qt5的openglunderqml示例，现在演示如何使用Vulkan、Metal和Direct3D 11实现相同的功能。当然，这些示例仅适用于相关的图形API。查看它们的main()函数会发现它们都强制执行相关的RHI后端。</p><p> Some of these go further than the classic underlay/overlay approach. For instance, the  metaltextureimport and  vulkantextureimport examples demonstrate adding a QQuickItem to the scene that effectively is a textured quad, being textured with a MTLTexture or VkImage that was created and rendered to outside the Qt Quick Scenegraph&#39;s control.</p><p>其中一些方法比经典的参考底图/覆盖方法走得更远。例如，metaltextureimport和vulkantextureimport示例演示了如何将QQuickItem添加到场景中，该场景实际上是一个带纹理的四边形，使用创建并渲染到Qt Quick Scenegraph控件外部的MTLTexture或VkImage进行纹理处理。</p><p>   In Qt 5.15 the major news was the introduction of  Qt Quick 3D, making the 3D world, 3D models, and PBR materials first class citizens of the Qt Quick world. In many ways this was merely a preview of what is to come in Qt 6.0.</p><p>在Qt5.15中，主要的新闻是Qt Quick3D的引入，使3D世界、3D模型和PBR材料成为Qt Quick世界的头等公民。在很多方面，这仅仅是对Qt6.0即将推出的内容的一个预览。</p><p>  While still tied to OpenGL in Qt 5.15, Qt 6.0 ships with renewed internals for Qt Quick 3D, now based on the QRhi-based infrastructure. As the  documentation pages describe, the configuration options that apply to Qt Quick also apply to Qt Quick 3D implicitly. If Qt Quick is configured to use Vulkan for example, by setting QSG_RHI_BACKEND=vulkan or using the equivalent C++ APIs, the same will apply to Qt Quick 3D too.</p><p>虽然在Qt5.15中仍然与OpenGL捆绑在一起，但Qt6.0发布时更新了Qt Quick3D的内部结构，现在基于基于QRhi的基础设施。正如文档页面所述，适用于Qt Quick的配置选项也隐含地适用于Qt Quick 3D。例如，如果Qt Quick配置为使用Vulkan，则通过设置QSG_RHI_BACKEND=Vulkan或使用等效的C++API，同样的情况也适用于Qt Quick 3D。</p><p> The entire feature set, including materials, lighting, shadows, image-based lighting, the renewed custom material and post-processing effect systems are all fully functional with all supported graphics APIs (OpenGL, Vulkan, Metal, Direct 3D 11).</p><p>整个功能集，包括材质、照明、阴影、基于图像的照明、更新的自定义材质和后处理效果系统，都具有所有支持的图形API(OpenGL、Vulkan、Metal、Direct 3D 11)的完整功能。</p><p> In line with the general renewal of how shaders are handled in Qt, the concept of  custom materials has also undergone a major transformation in Qt 6.0. There is now a whole new extension of the Qt Quick 3D material system that allows creating programmable materials, where the way a mesh is shaded is controlled by application-provided shader code, provided in form of Vulkan-compatible GLSL snippets, going through Qt&#39;s standard shader pipeline described above, thus becoming functional with any of the supported graphics APIs at run time, while still being amended by the engine to perform the all the expected lighting, shadowing, occlusion, and other steps, combining all contributions from the scene environment with the application-provided shading logic.</p><p>随着在Qt中处理着色器的方式的普遍更新，自定义材质的概念在Qt 6.0中也经历了重大变化。现在，Qt Quick 3D材质系统有了一个全新的扩展，它允许创建可编程材质，其中网格着色的方式由应用程序提供的着色器代码控制，这些代码以与Vulkan兼容的GLSL代码片段的形式提供，通过上述Qt的标准着色器管道，从而在运行时与任何支持的图形API一起工作，同时仍由引擎修改以执行所有预期的照明、阴影、遮挡和其他步骤，将来自场景环境的所有贡献与应用程序提供的着色逻辑相结合。</p><p>   Those interested in looking into the details already now are welcome to check out the  CustomMaterial page and the work-in-progress  getting started guide from the snapshot documentation.</p><p>现在对查看细节感兴趣的人，欢迎查看CustomMaterial页面和快照文档中的工作入门指南。</p><p>  The diagram in the QRhi section mentioned Widgets, albeit placed it in a perhaps odd position at first glance, away from QRhi and Qt Quick. What does this try to indicate?</p><p>QRhi部分中的图表提到了窗口小部件，尽管乍一看它的位置可能很奇怪，远离QRhi和Qt Quick。这试图表明什么呢？</p><p> In general everything that worked in Qt 5 can be expected to work in Qt 6, with the exception of deprecated and now-removed functionality, such as all the Qt 4 era classes with the QGL prefix (most notably, QGLWidget). If a Qt 5 application renders its own OpenGL content into a QWindow, or uses QOpenGLWidget, it will all function as before. (in the worst case with some very minor migration steps, e.g. having to update the application project file due to QOpenGLWidget moving to its own module  openglwidgets).</p><p>一般说来，在Qt5中工作的所有东西都可以在Qt6中工作，除了过时的和现在被删除的功能，比如所有带有QGL前缀的Qt4纪元类(最值得注意的是QGLWidget)。如果Qt5应用程序将其自己的OpenGL内容呈现到QWindow中，或者使用QOpenGLWidget，它将像以前一样运行。(在最坏的情况下，使用一些非常小的迁移步骤，例如，由于QOpenGLWidget移动到自己的模块openglwidgets而不得不更新应用程序项目文件)。</p><p> QRhi or the new shader pipeline plays no role here at the moment, in Qt 6.0 at least. The rendering of widgets happens like in Qt 5, whereas OpenGL content in a QOpenGLWindow or QOpenGLWidget continues to use the OpenGL API directly.</p><p>QRhi或新的着色器管道目前在这里没有作用，至少在Qt6.0中是这样。小部件的呈现类似于Qt5，而QOpenGLWindow或QOpenGLWidget中的OpenGL内容继续直接使用OpenGL API。</p><p> QQuickWidget is an interesting hybrid in Qt 6.0, and will require the application to enforce using OpenGL. This is because while Qt Quick could function with other graphics APIs, the composition architecture in widgets (which QOpenGLWidget and QQuickWidget rely on) continues to use OpenGL directly for the time being.</p><p>QQuickWidget是Qt6.0中一个有趣的混合体，需要应用程序强制使用OpenGL。这是因为虽然Qt Quick可以与其他图形API配合使用，但widget(QOpenGLWidget和QQuickWidget所依赖的)中的组合架构暂时继续直接使用OpenGL。</p><p> One notable change is the removal of  ANGLE, meaning ANGLE is no longer bundled with Qt on Windows. This will not affect the vast majority of applications, with the exception of those that in some form rely on ANGLE translating OpenGL ES to Direct 3D under the hood. Depending on the nature and complexity of their dependency, such applications should consider either enabling functioning with OpenGL proper, or investigate moving to using Direct 3D directly. For applications based on Qt Quick and Qt Quick 3D not having ANGLE around will likely not be a problem in practice since Direct3D 11 is now a first-class rendering option in Qt 6.</p><p>一个值得注意的变化是删除了角度，这意味着在Windows上角度不再与Qt捆绑在一起。这不会影响绝大多数应用程序，除了那些在幕后将OpenGL ES角度转换为Direct3D的应用程序。根据其依赖性的性质和复杂性，这类应用程序应该考虑使用OpenGL正确启用功能，或者考虑直接使用Direct3D。对于基于Qt Quick和Qt Quick3D的应用程序来说，没有角度在实践中很可能不是问题，因为Direct3D11现在是Qt6中的一流渲染选项。</p><p> That is all for now. There are plenty of more Qt 6 graphics topics to talk about, but hopefully what we have above provides a good starting point to the changes and new features in Qt 6.0. Expect more posts in the near future, especially in the context of Qt Quick 3D.</p><p>这就是目前的情况。还有更多的Qt6图形主题可以谈论，但希望上面的内容能为Qt6.0中的更改和新特性提供一个很好的起点。期待在不久的将来会有更多的帖子，特别是在Qt Quick3D的背景下。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.qt.io/blog/graphics-in-qt-6.0-qrhi-qt-quick-qt-quick-3d">https://www.qt.io/blog/graphics-in-qt-6.0-qrhi-qt-quick-qt-quick-3d</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/qt/">#qt</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>