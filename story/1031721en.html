<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>.NET比C++快，在GRPC_BENCH中下围棋</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">.NET比C++快，在GRPC_BENCH中下围棋</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-28 15:33:21</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/aba3b14cf0884d71ae87f3d037c7a5ba.png"><img src="http://img2.diglog.com/img/2020/10/aba3b14cf0884d71ae87f3d037c7a5ba.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>gRPC is a modern open source remote procedure call framework. There are many exciting features in gRPC: real-time streaming, client-to-server code generation, and great cross-platform support to name a few. The most exciting to me, and consistently mentioned by developers who are interested in gRPC, is performance.</p><p>GRPC是一个现代的开源远程过程调用框架。GRPC有许多令人兴奋的特性：实时流、客户端到服务器代码生成，以及很好的跨平台支持，仅举几例。对我来说，最令我兴奋的是性能，这也是对GRPC感兴趣的开发人员不断提到的。</p><p> Last year Microsoft contributed a new implementation of gRPC for .NET to the  CNCF. Built on top of Kestrel and HttpClient, gRPC for .NET makes gRPC a first-class member of the .NET ecosystem.</p><p>去年，微软为CNCF贡献了一个新的GRPC for.NET实现。构建在Kestrel和HttpClient之上的GRPC for.NET使GRPC成为.NET生态系统的一流成员。</p><p> In our first  gRPC for .NET release, we focused on gRPC’s core features, compatibility, and stability. In .NET 5, we made gRPC really fast.</p><p>在我们的第一个GRPC for.NET版本中，我们重点介绍了GRPC的核心特性、兼容性和稳定性。在.NET5中，我们让GRPC变得非常快。</p><p>  In a  community run benchmark of different gRPC server implementations, .NET gets the highest requests per second after Rust, and is just ahead of C++ and Go.</p><p>在不同GRPC服务器实现的社区运行基准中，.NET在Rust之后获得每秒最高的请求，并且仅仅领先于C++和Go。</p><p>  This result builds on top of the work done in .NET 5. Our benchmarks show .NET 5 server performance is 60% faster than .NET Core 3.1. .NET 5 client performance is 230% faster than .NET Core 3.1.</p><p>我们的基准测试表明.NET5服务器的性能比.NET Core3.1快60%。.NET 5客户端性能比.NET Core 3.1快230%。</p><p> Stephen Toub discusses  dotnet/runtime changes in his  Performance Improvements in .NET 5 blog post. Check it out to read about improvements in HttpClient and HTTP/2.</p><p>Stephen Toub在他的.NET5博客文章中讨论了DotNet/运行时的变化。请查看它以了解HttpClient和HTTP/2中的改进。</p><p> In the rest of this blog post I’ll talk about the improvements we made to make gRPC fast in ASP.NET Core.</p><p>在这篇博客文章的其余部分，我将谈论我们在ASP.NET Core中为使GRPC更快所做的改进。</p><p>  gRPC uses HTTP/2 as its underlying protocol. A fast HTTP/2 implementation is the most important factor when it comes to performance. Our gRPC server builds on top of Kestrel, a HTTP server written in C# that is designed with performance in mind. Kestrel is a top contender in the  TechEmpower benchmarks, and gRPC benefits from a lot of the performance improvements in Kestrel automatically. However, there are many HTTP/2 specific optimizations that were made in .NET 5.</p><p>GRPC使用HTTP/2作为其底层协议。当涉及到性能时，快速的HTTP/2实现是最重要的因素。我们的GRPC服务器构建在Kestrel之上，Kestrel是用C#编写的HTTP服务器，其设计考虑了性能。Kestrel是TechEmpower基准测试中的顶级竞争者，GRPC自动受益于Kestrel的大量性能改进。但是，.NET5中进行了许多特定于HTTP/2的优化。</p><p> Reducing allocations is a good place to start. Fewer allocations per HTTP/2 request means less time doing garbage collection (GC). And CPU time “wasted” in GC is CPU time not spent serving HTTP/2 requests.</p><p>减少拨款是一个很好的起点。每个HTTP/2请求的分配越少，执行垃圾收集(GC)的时间就越少。而GC中“浪费”的CPU时间是未用于服务HTTP/2请求的CPU时间。</p><p>  The performance profiler above is measuring allocations over 100,000 gRPC requests. The live object graph’s sawtooth shaped pattern indicates memory building up, then being garbage collected. About 3.9KB is being allocated per request. Lets try to get that number down!</p><p>上面的性能分析器正在测量超过100,000个GRPC请求的分配。活动对象图的锯齿状图案表明内存正在积累，然后被垃圾收集。每个请求被分配的大小约为3.9KB。让我们试着把这个数字记下来！</p><p> dotnet/aspnetcore#18601 adds pooling of streams in a HTTP/2 connection. This one change almost cuts allocations per request in half. It enables reuse of internal types like  Http2Stream, and publicly accessible types like  HttpContext and  HttpRequest, across multiple requests.</p><p>Dotnet/aspnetcore#18601在HTTP/2连接中添加了流池。这一更改几乎将每个请求的分配减少了一半。它允许跨多个请求重用内部类型(如Http2Stream)和可公开访问的类型(如HttpContext和HttpRequest)。</p><p>  dotnet/aspnetcore#19356 reuses input and output  Pipe instances.  Pipe is the single biggest contributor to allocations.</p><p>Dotnet/aspnetcore#19356重用输入和输出管道实例。PIPE是分配的最大单一贡献者。</p><p> dotnet/aspnetcore#19431 reuses known header string values. Related to header reuse,  dotnet/aspnetcore#19457 adds HTTP/2 pseudo headers as known headers.  String allocations use the third most bytes.</p><p>Dotnet/aspnetcore#19431重用已知的报头字符串值。与报头重用相关，dotnet/aspnetcore#19457添加了http/2伪报头作为已知报头。字符串分配使用第三大字节。</p><p>  While pooling is great when a server is under load, we want to free up memory that is no longer used.  dotnet/aspnetcore#24767 removes streams from the pool if they haven’t been used by a HTTP request in the last 5 seconds.</p><p>虽然当服务器负载过重时，池化很好，但我们希望释放不再使用的内存。如果流在最近5秒内没有被HTTP请求使用，dotnet/aspnetcore#24767将从池中删除这些流。</p><p> There are many smaller allocation savings.  dotnet/aspnetcore#19783 removes allocations in Kestrel’s HTTP/2 flow control. A resettable  ManualResetValueTaskSourceCore&lt;T&gt; type replaces allocating a new object each time flow control is triggered.  dotnet/aspnetcore#19273 replaces an array allocation with  stackalloc when validating the HTTP request path.  dotnet/aspnetcore#19277 and  dotnet/aspnetcore#19325 eliminate some unintended allocations related to logging.  dotnet/aspnetcore#22557 avoids allocating a  Task&lt;T&gt; if a task is already complete. And finally  dotnet/aspnetcore#19732 saves a string allocation by special casing  content-length of 0. Because every allocation matters.</p><p>还有许多较小的分配节省。Dotnet/aspnetcore#19783删除了Kestrel的HTTP/2流控制中的分配。每次触发流控制时，可重置的ManualResetValueTaskSourceCore&lt；T&gt；类型将替换分配新对象。在验证HTTP请求路径时，dotnet/aspnetcore#19273用stackalloc替换数组分配。Dotnet/aspnetcore#19277和dotnet/aspnetcore#19325消除了一些与日志记录相关的意外分配。如果任务已经完成，dotnet/aspnetcore#22557会避免分配任务。最后，dotnet/aspnetcore#19732通过特殊的大小写内容长度0保存字符串分配。因为每个分配都很重要。</p><p>  Per-request memory in .NET 5 is now just 330 B, a decrease of 92%. The sawtooth pattern has also disappeared. Reduced allocations means garbage collection didn’t run at all while the server processed 100,000 gRPC calls.</p><p>在.NET5中，每个请求的内存现在只有330B，减少了92%。锯齿图案也消失了。减少分配意味着在服务器处理100,000个GRPC调用时根本不运行垃圾收集。</p><p>  A hotpath in HTTP/2 is reading and writing HTTP headers. A HTTP/2 connection supports concurrent requests over a TCP socket, a feature called multiplexing. Multiplexing allows HTTP/2 to make efficient use of connections, but only the headers for one request on a connection can be processed at a time. HTTP/2’s  HPack header compression is stateful and depends on order. Processing HTTP/2 headers is a bottleneck so has to be as fast as possible.</p><p>HTTP/2中的热路径是读写HTTP报头。HTTP/2连接支持TCP套接字上的并发请求，这是一种称为多路复用的功能。多路复用允许HTTP/2有效利用连接，但一次只能处理连接上一个请求的报头。HTTP/2的HPack报头压缩是有状态的，并且取决于顺序。处理HTTP/2报头是一个瓶颈，因此必须尽可能快。</p><p> dotnet/aspnetcore#23083 optimizes the performance of  HPackDecoder. The decoder is a state machine that reads incoming HTTP/2  HEADER frames. The approach here is good, the state machine allows Kestrel to decode frames as they arrive, but the decoder was checking state after parsing each byte. Another problem is literal values, the header names and values, were copied multiple times. Optimizations in this PR include:</p><p>Dotnet/aspnetcore#23083优化了HPackDecoder的性能。解码器是读取传入HTTP/2报头帧的状态机。这里的方法很好，状态机允许Kestrel在帧到达时解码，但解码器在解析每个字节后检查状态。另一个问题是文字值(头名称和值)被多次复制。此PR中的优化包括：</p><p> Tighten parsing loops. For example, if we’ve just parsed a header name then the value must come afterwards. There is no need to check the state machine to figure out the next state.</p><p>收紧解析循环。例如，如果我们刚刚解析了一个头名称，则该值必须在后面。不需要检查状态机来计算出下一个状态。</p><p> Skip literal parsing all together. Literals in HPack have a length prefix. If we know the next 100 bytes are a literal then there is no need to inspect each byte. Mark the literal’s location and resuming parsing at its end.</p><p>一起跳过文字解析。HPack中的文字具有长度前缀。如果我们知道接下来的100个字节是文字，那么就不需要检查每个字节。标记文字的位置，并在其末尾继续解析。</p><p> Avoid copying literal bytes. Previously literal bytes were always copied to an intermediary array before passed to Kestrel. Most of the time this isn’t necessary and instead we can just slice the original buffer and pass a  ReadOnlySpan&lt;byte&gt; to Kestrel.</p><p>避免复制文字字节。以前的文字字节总是在传递给Kestrel之前复制到中间数组。大多数情况下，这并不是必需的，相反，我们可以只对原始缓冲区进行切片，并将ReadOnlySpan&lt；byte&gt；传递给Kestrel。</p><p> Together these changes significantly decrease the time it takes to parse headers. Header size is almost no longer a factor. The decoder marks the start and end position of a value and then slices that range.</p><p>总而言之，这些更改显著减少了解析标头所需的时间。标题大小几乎不再是一个因素。解码器标记值的开始和结束位置，然后对该范围进行切片。</p><p> private HPackDecoder _decoder = CreateDecoder();private byte[] _smallHeader = new byte[] { /* HPack bytes */ };private byte[] _largeHeader = new byte[] { /* HPack bytes */ };private IHttpHeadersHandler _noOpHandler = new NoOpHeadersHandler();[Benchmark]public void SmallDecode() =&gt; _decoder.Decode(_smallHeader, endHeaders: true, handler: _noOpHandler);[Benchmark]public void LargeDecode() =&gt; _decoder.Decode(_largeHeader, endHeaders: true, handler: _noOpHandler);</p><p>Private HPackDecoder_Decoder=CreateDecoder()；private byte[]_simHeader=new byte[]{/*HPack bytes*/}；private byte[]_largeHeader=new byte[]{/*HPack bytes*/}；private IHttpHeadersHandler_noOpHandler=new NoOpHeadersHandler()；[Benchmark]public void SmallDecode()=&gT；_decder.Decode(_SmallHeaders，endHeaders：true，handler：_noOpHandler)；[Benchmark]public LargeDecode()=&GT；_decder.Decode()=&GT(_largeHeader，endHeaders：true，Handler：_OpnoHandler)；[Benchmark]public void SmallDecode()=&GT；[Benchmark]public void LargeDecode()=&GT(_largeHeader，endHeaders：true，Handler：_OpnoHandler)；</p><p>  Once headers have been decoded, Kestrel needs to validate and process them. For example, special HTTP/2 headers like  :path and  :method need to be set onto  HttpRequest.Path and  HttpRequest.Method, and other headers need to be converted to strings and added to the  HttpRequest.Headers collection.</p><p>一旦标题被解码，Kestrel需要验证和处理它们。例如，需要将特殊的HTTP/2标头(如：Path和：Method)设置为HttpRequest.Path和HttpRequest.Method，而其他标头需要转换为字符串并添加到HttpRequest.Headers集合。</p><p> Kestrel has the concept of known request headers. Known headers are a selection of commonly occuring request headers that have been optimized for fast setting and getting.  dotnet/aspnetcore#24730 adds an even faster path for setting HPack static table headers to the known headers. The  HPack static table gives 61 common header names and values a number ID that can be sent instead of the full name. A header with a static table ID can use the optimized path to bypass some validation and quickly be set in the collection based on its ID.  dotnet/aspnetcore#24945 adds extra optimization for static table IDs with a name and value.</p><p>Kestrel具有已知请求头的概念。已知标头是为快速设置和获取而优化的一组常见请求标头。Dotnet/aspnetcore#24730将用于设置HPack静态表头的更快路径添加到已知头。HPack静态表给出了61个常见的报头名称和值，可以发送一个数字ID来代替全名。具有静态表ID的标头可以使用优化路径绕过某些验证，并根据其ID在集合中快速设置。dotnet/aspnetcore#24945为具有名称和值的静态表ID添加了额外的优化。</p><p>  Prior to .NET 5, Kestrel supported reading HPack compressed headers in requests, but it didn’t compress response headers. The obvious advantage of response header compression is less network usage, but there are performance benefits as well. It’s faster to write a couple of bits for a compressed header than it is to encode and write the header’s full name and value as bytes.</p><p>在.NET5之前，Kestrel支持读取请求中的HPack压缩头，但不压缩响应头。响应头压缩的明显优势是网络使用量较少，但也有性能优势。为压缩的报头写入几个比特要比编码和写入报头的全名和值(以字节为单位)要快。</p><p> dotnet/aspnetcore#19521 adds initial HPack static compression. Static compression is pretty simple: if the header is in the  HPack static table then write the ID to identify the header instead of the longer name.</p><p>Dotnet/aspnetcore#19521添加了初始HPack静态压缩。静态压缩非常简单：如果标头在HPack静态表中，则写入ID来标识标头，而不是较长的名称。</p><p> Dynamic HPack header compression is more complicated, but also provides bigger gains. Response header names and values are tracked in a dynamic table and are each assigned an ID. As a response’s headers are written, the server checks to see if the header name and value are in the table. If there is a match then the ID is written. If there isn’t then the full header is written, and it is added to the table for the next response. There is a maximum size of the dynamic table, so adding a header to it may evict other headers with a first in, first out order.</p><p>动态HPack报头压缩更复杂，但也提供了更大的收益。在动态表中跟踪响应标头名称和值，并为每个响应标头分配一个ID。写入响应标头时，服务器会检查标头名称和值是否在表中。如果匹配，则写入ID。如果没有，则写入完整的标头，并将其添加到表中以供下一次响应。动态表的大小是最大的，因此向其添加标题可能会以先进先出的顺序逐出其他标题。</p><p> dotnet/aspnetcore#20058 adds dynamic HPack header compression. To quickly search for headers the dynamic table groups header entries using a basic hash table. To track order and evict the oldest headers, entries maintain a linked list. To avoid allocations, removed entries are pooled and reused.</p><p>Dotnet/aspnetcore#20058增加了动态HP包头压缩。为了快速搜索标题，动态表使用基本哈希表对标题条目进行分组。为了跟踪顺序并逐出最旧的标头，条目维护一个链表。为避免分配，删除的条目将汇集并重复使用。</p><p>  Using Wireshark, we can see the impact of header compression on response size for this example gRPC call. .NET Core 3.x writes 77 B, while .NET 5 is only 12 B.</p><p>使用Wireshark，我们可以看到报头压缩对此示例GRPC调用的响应大小的影响。.NET Core 3.x写了77B，而.NET5只写了12B。</p><p>  gRPC for .NET uses the  Google.Protobuf package as the default serializer for messages. Protobuf is an efficient binary serialization format. Google.Protobuf is designed for performance, using code generation instead of reflection to serialize .NET objects. There are some modern .NET APIs and features that can be added to it to reduce allocations and improve efficiency.</p><p>GRPC for.NET使用Google.Protobuf包作为消息的默认序列化程序。Protobuf是一种高效的二进制序列化格式。Google.Protobuf是为提高性能而设计的，它使用代码生成而不是反射来序列化.NET对象。可以向其添加一些现代的.NETAPI和功能，以减少分配并提高效率。</p><p> The biggest improvement to Google.Protobuf is support for modern .NET IO types:  Span&lt;T&gt;,  ReadOnlySequence&lt;T&gt; and  IBufferWriter&lt;T&gt;. These types allow gRPC messages to be serialized directly using buffers exposed by Kestrel. This saves Google.Protobuf allocating an intermediary array when serializing and deserializing Protobuf content.</p><p>对Google.Protobuf最大的改进是对现代.NET IO类型的支持：span&lt；T&gt；、ReadOnlySequence&lt；T&gt；和IBufferWriter&lt；T&gt；。这些类型允许使用Kestrel公开的缓冲区直接序列化GRPC消息。这节省了Google.Protobuf在序列化和反序列化Protobuf内容时分配中间数组。</p><p> Support for Protobuf buffer serialization was a multi-year effort between Microsoft and Google engineers. Changes were spread across multiple repositories.</p><p>对Protobuf缓冲区序列化的支持是微软和谷歌工程师多年的努力。更改分布在多个存储库中。</p><p> protocolbuffers/protobuf#7351 and  protocolbuffers/protobuf#7576 add support for buffer serialization to Google.Protobuf. This is by far the biggest and most complicated change. Three attempts were made to add this feature before the right balance between performance, backwards compatibility and code reuse was found. Protobuf reading and writing uses many performance oriented features and APIs added to C# and .NET Core:</p><p>协议缓冲区/协议缓冲区#7351和协议缓冲区/协议缓冲区#7576为Google.Protobuf添加了对缓冲区序列化的支持。这是迄今为止最大、最复杂的变化。在找到性能、向后兼容性和代码重用之间的正确平衡之前，我们进行了三次添加此功能的尝试。Protobuf读写使用了许多添加到C#和.NET核心中的面向性能的功能和API：</p><p> Span&lt;T&gt; and C#  ref struct types enables fast and safe access to memory.  Span&lt;T&gt; represents a contiguous region of arbitrary memory. Using span lets us serialize to managed .NET arrays, stack allocated arrays, or unmanaged memory, without using pointers.  Span&lt;T&gt; and .NET protects us against buffer overflow.</p><p>Span&lt；T&gt；和C#ref结构类型支持快速、安全地访问内存。Span&lt；T&gt；表示任意内存的连续区域。使用SPAN允许我们序列化到托管.NET数组、堆栈分配的数组或非托管内存，而无需使用指针。Span&lt；T&&gt;和.NET可保护我们免受缓冲区溢出。</p><p> stackalloc is used to create stack-based arrays.  stackalloc is a useful tool to avoid allocations when a small buffer is required.</p><p>Stackalloc用于创建基于堆栈的数组。当需要较小的缓冲区时，stackalloc是避免分配的有用工具。</p><p> Low-level methods such as  MemoryMarshal.GetReference(),  Unsafe.ReadUnaligned() and  Unsafe.WriteUnaligned() convert directly between primitive types and bytes.</p><p>低级方法(如MemoryMarshal.GetReference()、Unsafe.ReadUnalized()和Unsafe.WriteUnaligned())直接在基元类型和字节之间转换。</p><p> BinaryPrimitives has helper methods for efficiently converting between .NET primitive types and bytes. For example,  BinaryPrimitives.ReadUInt64LittleEndian reads little endian bytes and returns an unsigned 64 bit number. Methods provided by  BinaryPrimitive are heavily optimized and use vectorization.</p><p>BinaryPrimites具有在.NET基元类型和字节之间进行高效转换的帮助器方法。例如，BinaryPrimives.ReadUInt64LittleEndian读取很少的Endian字节并返回一个无符号的64位数字。BinaryPrimitive提供的方法经过了大量优化，并使用了矢量化。</p><p> A great thing about modern C# and .NET is it is possible to write fast, efficient, low-level libraries without sacrificing memory safety. When it comes to performance, .NET lets you have your cake and eat it too!</p><p>现代C#和.NET的一个伟大之处在于，可以在不牺牲内存安全的情况下编写快速、高效、低级的库。当谈到性能时，.NET让您两全其美！</p><p> private TestMessage _testMessage = CreateMessage();private ReadOnlySequence&lt;byte&gt; _testData = CreateData();private IBufferWriter&lt;byte&gt; _bufferWriter = CreateWriter();[Benchmark]public IMessage ToByteArray() =&gt; _testMessage.ToByteArray();[Benchmark]public IMessage ToBufferWriter() =&gt; _testMessage.WriteTo(_bufferWriter);[Benchmark]public IMessage FromByteArray() =&gt; TestMessage.Parser.ParseFrom(CreateBytes());[Benchmark]public IMessage FromSequence() =&gt; TestMessage.Parser.ParseFrom(_testData);</p><p>Private TestMessage_testMessage=CreateMessage()；private ReadOnlySequence&lt；byte&gt；_testData=CreateData()；private IBufferWriter&lt；byte&gt；_BufferWriter=CreateWriter()；[Benchmark]public iMessage ToByteArray()=&gt；_testMessage.ToByteArray()；[Benchmark]public iMessage ToBufferWriter()=&gt；_testMessage.WriteTo(_bufferWriter)；[Benchmark]public iMessage FromByteArray()=&gt；TestMessage.Parser.ParseFrom(CreateBytes())；[Benchmark]public iMessage FromMessage.ParseFrom(__Data)；</p><p>  Adding support for buffer serialization to Google.Protobuf is just the first step. More work is required for gRPC for .NET to take advantage of the new capability:</p><p>向Google.Protobuf添加对缓冲区序列化的支持只是第一步。GRPC for.NET需要做更多工作才能利用新功能：</p><p> grpc/grpc#18865 and  grpc/grpc#19792 adds  ReadOnlySequence&lt;byte&gt; and  IBufferWriter&lt;byte&gt; APIs to the gRPC serialization abstraction layer in Grpc.Core.Api.</p><p>Grpc/Grpc#18865和Grpc/Grpc#19792将ReadOnlySequence&lt；byte&gt；和IBufferWriterbyte&gt；API添加到Grpc.Core.Api中的GRPC序列化抽象层。</p><p>  grpc/grpc-dotnet#376 and  grpc/grpc-dotnet#629 updates gRPC for .NET to use the new serialization abstractions in Grpc.Core.Api. This code is the integration between Kestrel and gRPC. Because Kestrel’s IO is built on top of  System.IO.Pipelines, we can use its buffers during serialization.</p><p>GRPC/GRPC-DotNet#376和GRPC/GRPC-DotNet#629更新GRPC for.NET以使用Grpc.Core.Api中的新序列化抽象。此代码是Kestrel和GRPC之间的集成。因为Kestrel的IO构建在System.IO.Pipeline之上，所以我们可以在序列化期间使用它的缓冲区。</p><p> The end result is gRPC for .NET serializes Protobuf messages directly to Kestrel’s request and response buffers. Intermediary array allocations and byte copies have been eliminated from gRPC message serialization.</p><p>最终结果是GRPC for.NET将Protobuf消息直接序列化到Kestrel的请求和响应缓冲区。中间数组分配和字节副本已从GRPC消息序列化中删除。</p><p>  Performance is a feature of .NET and gRPC, and as cloud apps scale it is more important than ever. I think all developers can agree it is fun to make fast apps, but performance has real world impact. Lower latency and higher throughput means fewer servers. It is an opportunity to save money, reduce power use and build greener apps.</p><p>性能是.NET和GRPC的一个特性，随着云应用的扩展，它比以往任何时候都更加重要。我想所有的开发人员都会同意，开发快速的应用程序很有趣，但性能会对现实世界产生影响。更低的延迟和更高的吞吐量意味着更少的服务器。这是一个省钱、减少用电量和开发更环保应用程序的机会。</p><p>  As is obvious from this tour, a lot of changes have gone into gRPC, Protobuf and .NET aimed at improving performance. Our benchmarks show a 60% improvement in gRPC server RPS and a 230% improvement in gRPC client RPS.</p><p>从这次巡视中可以明显看出，GRPC、Protobuf和.NET中有很多旨在提高性能的更改。我们的基准测试显示，GRPC服务器RPS提高了60%，GRPC客户端RPS提高了230%。</p><p> .NET 5 RC2 is available now, and the official .NET 5 release is in November. To try out the performance improvements and to get started using gRPC with .NET, the best place to start is the  Create a gRPC client and server in ASP.NET Core tutorial.</p><p>.NET5RC2现在可以使用，官方的.NET5发行版将在11月发布。要尝试性能改进并开始在.NET中使用GRPC，最好的起点是在ASP.NET核心中创建GRPC客户端和服务器教程。</p><p> We look forward to hearing about apps built with gRPC and .NET, and to your future contributions in the  dotnet and  grpc repos!</p><p>我们期待着听到关于使用GRPC和.NET构建的应用程序的消息，并期待您将来在DotNet和GRPC Repos中做出的贡献！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://devblogs.microsoft.com/aspnet/grpc-performance-improvements-in-net-5/">https://devblogs.microsoft.com/aspnet/grpc-performance-improvements-in-net-5/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bench/">#bench</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/faster/">#faster</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/grpc/">#grpc</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031196.html"><img src="http://img2.diglog.com/img/2020/10/thumb_a905b29390816d4809e71e71b22214a4.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031196.html">Single_file_libs：单文件C/C++库列表</a></div><span class="my_story_list_date">2020-10-26 12:54</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031179.html"><img src="http://img2.diglog.com/img/2020/10/thumb_3884453f3945027ebd4444634fa4c369.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031179.html">不，C++仍然不支持</a></div><span class="my_story_list_date">2020-10-26 10:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030259.html"><img src="http://img2.diglog.com/img/2020/10/thumb_9777c4662921ff2c4e18742ec7d96b33.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030259.html">使用MESON对C、C++和其他语言进行货运式依赖管理</a></div><span class="my_story_list_date">2020-10-21 14:2</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029622.html"><img src="http://img2.diglog.com/img/2020/10/thumb_3884453f3945027ebd4444634fa4c369.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029622.html">不，C++仍然不支持</a></div><span class="my_story_list_date">2020-10-18 23:53</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>