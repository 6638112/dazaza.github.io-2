<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>2020年Go和C ++中的错误与异常 Errors vs. exceptions in Go and C++ in 2020</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Errors vs. exceptions in Go and C++ in 2020<br/>2020年Go和C ++中的错误与异常 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-20 19:33:43</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/5f63c04a23404eeb4b88f6421ddb2a74.png"><img src="http://img2.diglog.com/img/2021/1/5f63c04a23404eeb4b88f6421ddb2a74.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Back in 2018, we compared empirically the performance overheads of Goand C++ with regards to the low-level calling convention: to  passarguments,to  return multiple values, and when propagating exceptions.</p><p>早在2018年，我们就低级调用约定从经验上比较了Goand C ++的性能开销：传递参数，返回多个值以及传播异常时。</p><p> Those results were obtained with Go 1.10 and Clang 6.0. Since then,compilers have evolved and we are now running with Go 1.15 and Clang11.0. Have the findings changed since then?</p><p> 这些结果是使用Go 1.10和Clang 6.0获得的。从那时起，编译器不断发展，我们现在使用Go 1.15和Clang11.0运行。从那以后发现有变化吗？</p><p>  What is cheaper: handling exceptions via  panic /  recover, orpassing and testing error results with  if err :=  ...; err != nil {return err }?</p><p>  什么是便宜的：通过err：= ...通过panic / recover，通过和测试错误结果来处理异常。 err！= nil {return err}？</p><p> In fact, as we will see below, the conclusions are stronger today thanthey were two years ago.</p><p> 实际上，正如我们将在下面看到的，今天的结论比两年前要强。</p><p> The reader is first invited to familiarize themselves with thediscussion of Go’s low-level calling convention as compared with C++’sin the previous chapters of this series:  as of 2018 and  as of 2020. The 2018analysis is still largely valid in 2020—the C++ calling convention didnot change, and Go introduced a few optimizations on theimplementation of  defer.</p><p> 首先请读者熟悉Go的低级调用约定与本系列前几章中的C ++的讨论：从2018年和2020年开始。2018年的分析在2020年仍然有效-C ++调用约定没有改变，Go对defer的实现进行了一些优化。</p><p>  to measure argument passing and returning multiple values, we willuse exactly the same methodology as the previous two analyses  here and here.</p><p>  为了测量参数传递和返回多个值的方法，我们将在此处和此处使用与前两个分析完全相同的方法。</p><p> These analyses contain their benchmark source code, which is alsoprovided at  github.com/knz/callbench. Thederivation of plots was entirely automated via  Jupyter notebooks,which we can thus re-run.</p><p> 这些分析包含其基准源代码，该源代码也在github.com/knz/callbench中提供。通过Jupyter笔记本可以完全自动化地块的绘制，因此我们可以重新运行它。 </p><p> for the  third analysis,which measures and compares the cost of error returns with that ofthrowing and catching exceptions, we are going to reuse the samemethodology, but a diffence source code for the benchmark. The newsource code has been uploaded to  github.com/knz/callbench aswell. This difference is motivated below.</p><p>对于第三种分析，它测量并比较了错误返回的成本与引发和捕获异常的成本，我们将重用相同的方法，但是使用差异源作为基准。新的源代码也已上传到github.com/knz/callbench。这种差异是由以下原因引起的。</p><p> Here the findings are largely unchanged from 2018: for the selectedbenchmark code, the code generation by our selected compilers has notchanged significantly.</p><p> 从2018年开始，这里的发现基本上没有变化：对于选定的基准代码，我们选定的编译器生成的代码没有显着变化。</p><p> Only the new hardware  CPU influences the measurements: the new  CPU hasa higher clock frequency than previously, so for an equivalentmix of instructions we expect and observe a 10-40% raw performanceimprovement. Additionally, the Ryzen 7 3950X architecture has asomewhat more powerful superscalar execution unit than the 1800X, andis able to detect inter-instruction dependencies across more memoryaccesses. This causes more measurements artifacts when the workload isextremely small, and erases the performance differences between 1 and5 function arguments or return values.</p><p> 只有新的硬件CPU会影响测量：新CPU的时钟频率比以前更高，因此对于相同的指令混合，我们期望并观察到10-40％的原始性能改进。此外，Ryzen 7 3950X架构具有比1800X更强大的超标量执行单元，并且能够检测更多内存访问之间的指令间依赖性。当工作负载极小时，这会导致更多的测量失真，并消除1和5函数参数或返回值之间的性能差异。</p><p>  Go uses memory to pass function arguments and return values. Thismakes Go code perform about twice slower than equivalent C++ code onfunction calls, where C++ compilers use register-based callingconventions instead.</p><p>  Go使用内存传递函数参数并返回值。这使得Go代码在功能调用上的执行速度比等效的C ++代码慢大约两倍，在C ++编译器中，C ++编译器使用基于寄存器的调用约定。</p><p> The particular  CPU we used this year uses a micro-architecture ableto more aggressively optimize memory-heavy code, and so the Goperformance overhead relative to C++ is erased for very smallfunctions; unfortunately, these optimizations become ineffective withmore realistic, wider function bodies.</p><p> 我们今年使用的特定CPU使用的微体系结构能够更积极地优化内存密集型代码，因此对于非常小的功能，可以消除相对于C ++的Goperformance开销。不幸的是，这些优化随着更现实，更广泛的功能主体而变得无效。</p><p> In Go, memory is used for return values even when there is just oneor two words worth of data. In these cases, a C++ compiler alsotypically uses registers. This choice in the Go compiler isunfortunate, as it mandates copying the return values through memoryat every call level when functions return each other’s value in acascade. This cost thus multiplies the overhead of the memory-basedreturn by the call depth, in a way that does not occur, or muchless, with a typical C++ code generator.</p><p> 在Go中，即使只有一个或两个字的数据，内存也用于返回值。在这些情况下，C ++编译器通常还会使用寄存器。 Go编译器的这种选择很不幸，因为当函数在级联中返回彼此的值时，它要求在每个调用级别通过内存复制返回值。因此，这笔费用将基于内存的返回的开销乘以调用深度，这是典型的C ++代码生成器所不会发生的或几乎没有的方式。</p><p> As previously, we can discuss what is the proportion of functioncalls relative to other types of code. Arguably, incomputation-heavy algorithms, functions often get inlined so that callsdisappear. In that case, it is possible for the Go compiler,assisted by the  CPU micro-architecture, to reach similar instructionthroughputs as the equivalent C++ code.</p><p> 如前所述，我们可以讨论函数调用相对于其他类型代码的比例。可以说，运算量大的算法通常会内联函数，从而使调用消失。在这种情况下，在CPU微体系结构的协助下，Go编译器有可能达到与等效C ++代码相似的指令吞吐量。 </p><p> However, we can also point out that Go still promotes the use ofdynamic dispatch (via interface methods) as an idiomatic approach tosoftware design. For example, string composition via bytes.Buffer interfaces with the  fmt packages usinginterface calls ( io.Writer), and the proportion ofcross-interface calls is relatively high in that case compared tothe computation load.</p><p>但是，我们还可以指出，Go仍在推动动态调度（通过接口方法）作为软件设计的惯用方法。例如，通过字节组成字符串。缓冲区使用接口调用（io.Writer）与fmt包进行接口，并且在这种情况下，与计算负载相比，跨接口调用的比例相对较高。</p><p> The reader is invited to review the more detailed summaries from theprevious analyses, where the situation is presented in more detail.</p><p> 邀请读者查看之前的分析中更详细的摘要，其中更详细地介绍了这种情况。</p><p> This analysis calls for a benchmark which performs a “unit of work” ina loop, with the size of the loop configurable as “workload”.</p><p> 该分析需要一个基准，该基准可以在一个循环中执行``工作单元''，并且循环的大小可以配置为``工作量''。</p><p> We are modeling the extremely common case where any error inside aunit of work aborts the entire workload: the error may or may not begenerated inside the unit of work, but needs only be detected once forthe entire outer workload loop.</p><p> 我们正在对一种非常普遍的情况建模，即一个工作单元内的任何错误都将中止整个工作负载：该错误可能会或可能不会在工作单元内生成，但是对于整个外部工作负载循环只需要检测一次即可。</p><p>  //go:noinline func  leafErr ( arg  int )  ( int ,  error )  {  if  arg  ==  0  {  // Unlikely error case.  return  0 ,  errObj  }  // Common non-error case.  return  id ( arg ),  nil } //go:noinline func  workErr ( work  int )  int  {  var  n  int  for  i  :=  0 ;  i  &lt;  work ;  i ++  {  val ,  err  :=  leafErr ( work )  if  err  !=  nil  {  return  42  }  n  +=  val  }  return  n }</p><p>  // go：noinline func leafErr（arg int）（int，error）{如果arg == 0 {// //不太可能出现错误。 return 0，errObj} //常见的非错误情况。 return id（arg），nil} // go：noinline func workErr（work int）int {var n int for i：= 0;我＆lt;工作; i ++ {val，err：= leafErr（work）if err！= nil {return 42} n + = val} return n}</p><p> In this code,  leafErr represents the “unit of work”, where errorscan originate. The  workErr represents the main work computation,where  leafErr is called repeatedly.</p><p> 在此代码中，leafErr代表“工作单元”，可能在其中产生错误。 workErr表示主要的工作计算，其中leafErr被重复调用。</p><p>  In the case where the  error return is used, we need to check the err return on every iteration of the loop. If we used exceptioninstead, we could factor the exception check out of the loop:</p><p>  在使用错误返回的情况下，我们需要在循环的每次迭代中检查err返回。如果我们使用异常代替，我们可以将异常检查从循环中分解出来： </p><p> //go:noinline func  workExc ( work  int )  ( res  int )  {  // Exception check factored out of the loop:  defer  func ()  {  if  r  :=  recover ();  r  !=  nil  {  res  =  42  }  }()  // Main workload follows:  var  n  int  for  i  :=  0 ;  i  &lt;  work ;  i ++  {  n  +=  leafExc ( work  +  1 )  }  return  n } //go:noinline func  leafExc ( arg  int )  int  {  if  arg  ==  0  {  // Unlikely error case.  panic ( errObj )  }  // Common non-error case.  return  id ( arg ) }</p><p>// // go：noinline func workExc（work int）（res int）{//异常检查不在循环中：defer func（）{如果r：= restore（）; r！= nil {res = 42}}（）//主要工作量如下：var n int for i：= 0;我＆lt;工作; i ++ {n + = leafExc（work + 1）}返回n} // go：noinline func leafExc（arg int）int {if arg == 0 {//错误情况。 panic（errObj）} //常见的非错误情况。返回ID（arg）}</p><p> (The accompanying C++ code is implemented similarly, using  std::tuple for error returns and  try/catch/throw for exceptions.)</p><p> （随附的C ++代码以类似的方式实现，使用std :: tuple返回错误并使用try / catch / throw进行异常）。</p><p> Just looking at the shape of the source code, we can already suspectthe findings that follow: there is less work inside the workload loopwhen using exceptions. So as the workload increases, the cost ofsetting up the “catch” logic gets amortized.</p><p> 仅查看源代码的形状，我们就已经可以怀疑接下来的发现：使用异常时，工作负载循环中的工作量将减少。因此，随着工作负载的增加，摊销``捕获''逻辑的成本将摊销。</p><p>  However, when running the same experiment in 2020 on our new testmachine, with Go 1.15, the measurements are all over the place, theresults appear chaotic, and the difference we observed last time isnearly entirely erased. What happened?</p><p>  但是，在2020年使用Go 1.15在我们的新测试机上进行相同的实验时，测量结果到处都是，结果看起来很混乱，并且我们上次观察到的差异几乎没有被完全消除。发生了什么？</p><p> It turns out that the new  CPU used to run the benchmark really has amuch better micro-architecture. It is able to peek through the callfrom the  work function to the  leaf function, analyzeinter-instruction dependencies across the call, and fully pipeline theprocessing of the  leaf function across multiple iterations of the work loop. This effectively invalidates the model we used: in arealistic application, there is enough complexity in the code insidethe “workload”, when it contains function calls, that the  CPU cannotpipeline loop iterations.</p><p> 事实证明，用于运行基准测试的新CPU确实具有更好的微体系结构。它能够浏览从工作函数到叶子函数的调用，分析整个调用之间的指令间依赖性，并在工作循环的多次迭代中完全流水线处理叶子函数。这有效地使我们使用的模型无效：在区域应用程序中，“工作负载”中的代码包含足够的复杂性（当包含函数调用时），CPU无法管道循环迭代。</p><p> To restore a valid model, we should thus tweak the benchmark programby adding just enough additional complexity in the “unit ofwork”. Here, we achieve that by adding just one extra level ofintermediate call:</p><p> 为了恢复有效的模型，我们应该通过在“工作单元”中添加足够的额外复杂性来调整基准程序。在这里，我们通过添加一个额外的中间调用级别来实现这一目标：</p><p> //go:noinline func  leafErr ( arg  int )  ( int ,  error )  {  if  arg  ==  0  {  // Unlikely error case.  return  0 ,  errObj  }  // Common non-error case.  return  id ( arg ),  nil } //go:noinline func  intermediateErr ( arg  int )  ( int ,  error )  {  return  leafErr ( arg ) } //go:noinline func  workErr ( work  int )  int  {  var  n  int  for  i  :=  0 ;  i  &lt;  work ;  i ++  {  val ,  err  :=  intermediateErr ( work )  if  err  !=  nil  {  return  42  }  n  +=  val  }  return  n }</p><p> // go：noinline func leafErr（arg int）（int，error）{如果arg == 0 {// //不太可能出现错误。 return 0，errObj} //常见的非错误情况。 return id（arg），nil} // go：noinline func middleErr（arg int）（int，error）{return leafErr（arg）} // go：noinline func workErr（work int）int {var n int for i： = 0;我＆lt;工作; i ++ {val，err：= middleErr（work）if err！= nil {return 42} n + = val} return n} </p><p>  This program, at least on the  CPU considered, is “complex” enough tostop the superscalar unit from peeking across the function call. Theresulting code then behaves regularly in measurements.</p><p>该程序（至少在所考虑的CPU上）足够“复杂”，可以阻止超标量单元窥视函数调用。结果代码随后在测量中表现正常。</p><p> The Jupiter notebook for this experiment contains the data processing stepsand the logic to generate comparison plots, with some detailed analysisof the intermediate results.</p><p> 该实验的Jupiter笔记本包含数据处理步骤和生成比较图的逻辑，并对中间结果进行了一些详细的分析。</p><p>    For an equivalent workload (e.g. 1000 “units of work”), the Go codeis 40% slower than the equivalent C++ code. This is generallyexpected as Go is much more memory-heavy than C++.</p><p>    对于等效的工作负载（例如1000个“工作单元”），Go代码比等效的C ++代码慢40％。通常预计这是因为Go比C ++占用更多的内存。</p><p> Regardless of the language considered, the cost of setting up anexception “catch” can be reliably amortized across an entireworkload: the performance of code using exception-based errorreporting asymptotically converges to become the same as code usingno error handling whatsoever.</p><p> 无论使用哪种语言，都可以在整个工作量中可靠地摊销设置异常“捕获”的成本：使用基于异常的错误报告的代码性能渐近地收敛到与不使用任何错误处理的代码相同。</p><p> In comparison, code that propagates errors as return values issystematically slower as the workload increases; between 1-3% forC++, up to 4-10% for Go.</p><p> 相比之下，随着工作量的增加，随着返回值传播错误的代码在系统上变慢。 C ++介于1-3％之间，Go高达4-10％之间。</p><p> The cost of setting up an exception “catch” is not entirelynegligible. Back in 2018, the mandatory fixed cost of the  defersetup and testing  recover() in the  work function was 50ns;such that it took about 500 nanoseconds worth of “workload” to fullyoffset this one-time cost.</p><p> 设置例外“捕获”的成本并非可以忽略不计。早在2018年，工作功能中的defersetup和测试restore（）的强制性固定成本为50ns;因此花费约500纳秒的``工作量''来完全抵消这一一次性成本。</p><p> In 2020, thanks to the  defer  optimizations in Go 1.15,the fixed overhead was greatly decreased; down to just a fewinstructions and, on the current test hardware, just 11ns. It nowtakes merely 35 nanoseconds worth of “workload” to fully offset theone-time cost.</p><p> 到2020年，由于Go 1.15中的延迟优化，固定开销大大减少了；只需几条指令，在当前的测试硬件上只有11ns。现在仅需花费35纳秒的“工作量”即可完全抵消一次性成本。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://dr-knz.net/go-errors-vs-exceptions-2020.html">https://dr-knz.net/go-errors-vs-exceptions-2020.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>