<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>BQN：实施订购函数 BQN: Implementation of ordering functions</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">BQN: Implementation of ordering functions<br/>BQN：实施订购函数 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-17 04:23:09</div><div class="page_narrow text-break page_content"><p>The  ordering functions are Sort (  ∧∨), Grade (  ⍋⍒), and Bins (  ⍋⍒). Although these are well-studied—particularly sorting, and then binary search or &#34;predecessor search&#34;—there are many recent developments, as well as techniques that I have not found in the literature. The three functions are closely related but have important differences in what algorithms are viable. Sorting is a remarkably deep problem with different algorithms able to do a wide range of amazing things, and sophisticated ways to combine those. It is by no means solved. In comparison, Bins is pretty tame.</p><p>订购功能是排序（∧∨），等级（⍋⍒）和垃圾箱（⍋⍒）。虽然这些都是很好的研究 - 特别是分类，然后是二进制搜索或＆＃34;前身搜索＆＃34;  - 最近的发展，以及我在文学中找不到的技术。这三个功能密切相关，但在哪些算法中具有重要差异。排序是一种非常深刻的深层问题，不同的算法能够做出广泛的惊人的东西，以及组合那些的精致方式。它绝不是解决的。相比之下，箱子很驯服。</p><p> There&#39;s a large divide between ordering compound data and simple data. For compound data comparisons are expensive, and the best algorithm will generally be the one that uses the fewest comparisons. For simple data they fall somewhere between cheap and extremely cheap, and fancy branchless and vectorized algorithms are the best.</p><p> 在订购复合数据和简单数据之间存在大划分。对于复合数据比较是昂贵的，并且最好的算法通常是使用最少比较的算法。对于简单的数据，他们在便宜且非常便宜之间的某个地方，并且花哨的无分支和矢量化算法是最好的。</p><p>  Merge sort is better. It is deterministic, stable, and has optimal worst-case performance. Its pattern handling is better: while merge sort handles &#34;horizontal&#34; patterns and quicksort does &#34;vertical&#34; ones, merge sort gets useful work out of  any sequence of runs but in-place quicksort will quickly mangle its analogue until it may as well be random.</p><p>  合并排序更好。它是确定性的，稳定的，并且具有最佳的最坏情况性能。它的模式处理更好：合并分类处理＆＃34;横向＆＃34;模式和Quicksort与＃34;垂直＆＃34; Merge Sort会在任何运行顺序中获取有用的工作，但就是Quicksort将快速敲打其模拟，直到它也可以随机。</p><p> But that doesn&#39;t mean merge sort is always faster. Quicksort seems to work a little better branchlessly. For sorting, quicksort&#39;s partitioning can reduce the range of the data enough to use an extremely quick counting sort. Partitioning is also a natural fit for binary search, where it&#39;s mandatory for sensible cache behavior with large enough arguments. So it can be useful. But it doesn&#39;t merge, and can&#39;t easily be made to merge, and that&#39;s a shame.</p><p> 但这并不是卑鄙的合并排序总是更快。 Quicksort似乎有点不合时宜。用于排序，Quicksort＆＃39; s分区可以减少足以使用极其快速的计数排序的数据范围。分区也是一种自然适合二进制搜索，其中＆＃39; s强制性，具有足够大的参数的明智的缓存行为。所以它可以很有用。但它并不合并，并且可以易于融合，并且＆＃39;令人羞耻。</p><p> The same applies to the general categories of partitioning sorts (quicksort, radix sort, samplesort) and merging sorts (mergesort, timsort, multimerges). Radix sorts are definitely the best for some types and lengths, although the scattered accesses make their performance unpredictable and I think overall they&#39;re not worth it. A million uniformly random 4-byte integers is nearly the best possible case for radix sort, so the fact that this seems to be the go-to sorting benchmarks means radix sorting looks better than it is.</p><p> 这同样适用于分区的一般类别（QuickSort，Radix Sort，Samplesort）和合并排序（合并，Timsort，Multimerges）。除了某些类型和长度的虽然分散的访问使其性能不可预测，但是，基拉排序肯定是最佳的，但我认为他们整体思考它们＆＃39;重申不值得。一百万均匀随机的4字节整数几乎是最佳的基数的案例，因此这似乎是进入分拣基准的事实意味着基数排序看起来比它更好。</p><p>  Binary searches are very easy to get wrong. Do not write   ( hi + lo ) / 2: it&#39;s not safe from overflows. I always follow the pattern given in the first code block  here. This code will never access the value   *base, so it should be considered a search on the   n - 1 values beginning at   base + 1 (the perfect case is when the number of values is one less than a power of two, which is in fact how it has to go). It&#39;s branchless and always takes the same number of iterations. To get a version that stops when the answer is known, subtract   n% 2 from   n in the case that   *mid  &lt;  x.</p><p>  二元搜索很容易出错。不要写（嗨+ lo）/ 2：它＆＃39;不受溢出的安全。我始终遵循在此处的第一个代码块中给出的模式。此代码将永远不会访问值*基础，因此应该被视为在基本+ 1开始的n  -  1值上的搜索（完美的情况是当值的数量小于两个时，这是事实是如何要去的）。它＆＃39; scrantless，始终采用相同数量的迭代。要获取已知答案时停止的版本，请在* MID＆lt;的情况下从n中减去n％2。 X。</p><p>  Array comparisons are expensive. The goal here is almost entirely to minimize the number of comparisons. Which is a much less complex goal than to get the most out of modern hardware, so the algorithms here are simpler.</p><p>  阵列比较价格昂贵。这里的目标几乎完全是为了最大限度地减少比较次数。哪个复杂的目标远远不如充分利用现代硬件，因此这里的算法更简单。 </p><p> For  Sort and  Grade, use Timsort. It&#39;s time-tested and shows no signs of weakness (but do be sure to pick up a fix for the bug discovered in 2015 in formal verification). Hardly different from optimal comparison numbers on random data, and outstanding pattern handling. Grade can either by selecting from the original array to order indices or by moving the data around in the same order as the indices. I think the second of these ends up being substantially better for small-ish elements.</p><p>用于排序和等级，使用Timsort。它＆＃39;时间测试并没有显示弱点迹象（但是确实可以在正式验证中拿到2015年发现的错误的修复）。几乎没有与随机数据上的最佳比较编号不同，以及出色的模式处理。等级可以通过从原始阵列中选择来订购指数或通过与指数相同的顺序移动数据。我认为这一部分最终对小型元素来说基本上更好。</p><p> For  Bins, use a branching binary search: see  On binary search above. But there are also interesting (although, I expect, rare) cases where only one argument is compound. Elements of this argument should be reduced to fit the type of the other argument, then compared to multiple elements. For the right argument, this just means reducing before doing whatever binary search is appropriate to the left argument. If the left argument is compound, its elements should be used as partitions. Then switch back to binary search only when the partitions get very small—probably one element.</p><p> 对于箱，使用分支二进制搜索：请参阅上面的二进制搜索。但也有趣（虽然，我期待，罕见）案件，只有一个论据是化合物。应该减少此参数的元素以适合其他参数的类型，然后与多个元素进行比较。对于正确的参数，这只是意味着在做任何二进制搜索都适合左参数之前减少。如果左参数是化合物，则其元素应用作分区。然后仅在分区获得非常小的时间 - 可能是一个元素时才会切换回二进制搜索。</p><p>   Sorting algorithms of interest are counting sort and  pdqsort (some improvements of my own to be described here later). However, these are both unusable for Grade.</p><p>   感兴趣的排序算法正在计算排序和PDQSORT（稍后在此描述我自己的一些改进）。然而，这些既不可用的等级。</p><p> For small-range Grade, counting sort must be replaced with bucket sort, at a significant performance cost. I don&#39;t have any method I&#39;m happy with for other data. Stabilizing pdqsort by sorting the indices at the end is possible but slow.  Wolfsort is a hybrid radix/merge sort that might be better.</p><p> 对于小范围等级，必须以显着的性能成本用桶排序替换计数排序。我没有任何方法i＆＃39; m满意的其他数据。通过在末端排序索引来稳定PDQSORT，但慢速。 Wolfsort是一种混合基数/合并的排序，可能更好。</p><p> IPS⁴o is a horrifyingly complicated samplesort thing. Stable, I think. For very large arrays it probably has the best memory access patterns, so a few samplesort passes could be useful.</p><p> ips⁴o是一个可怕的复杂的样式。稳定，我想。对于非常大的阵列，它可能具有最佳的内存访问模式，因此一些Samplesort通过可能是有用的。</p><p>   Both counting and bucket sort are small-range algorithms that begin by counting the number of each possible value. Bucket sort, as used here, means that the counts are then used to place values in the appropriate position in the result in another pass. Counting sort does not read from the initial values again and instead reconstructs them from the counts. It might be written   ( /≠ ¨ ∘ ⊔ ) ⌾ ( - ⟜ min ) in BQN, with   ≠ ¨ ∘ ⊔ as a single efficient operation.</p><p>   计数和桶排序都是通过计算每个可能值的数量而开始的小型算法。这里使用的铲斗排序意味着当时使用计数来放置在另一个通过的结果中的适当位置。计数排序不再从初始值读取，而是从计数重建它们。它可以在BQN中写入（/≠¨∘⊔）⌾（ - ⟜min），具有≠≠¨∘作为单一的高效操作。</p><p> Bucket sort can be used for Grade or sort-by (  ⍋ ⊸ ⊏), but counting sort only works for sorting itself. It&#39;s not-even-unstable: there&#39;s no connection between result values and the input values except that they are constructed to be equal. But with  fast Indices, Counting sort is vastly more powerful, and is effective with a range four to eight times the argument length. This is large enough that it might pose a memory usage problem, but the memory use can be made arbitrarily low by partitioning.</p><p> 铲斗排序可用于等级或排序（⍋⊸⊏），但计算SORT​​仅用于对本身进行排序。它＆＃39; s not-op-of-unsstable：＆＃39;在结果值和输入​​值之间没有连接，但它们构造为相等。但是通过快速指数，计数排序是非常强大的，并且有效的范围是参数长度的四到八倍。这足够大，它可能会造成内存使用问题，但可以通过分区任意低廉的内存使用。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://mlochbaum.github.io/BQN/implementation/primitive/sort.html">https://mlochbaum.github.io/BQN/implementation/primitive/sort.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/实施/">#实施</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/排序/">#排序</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>