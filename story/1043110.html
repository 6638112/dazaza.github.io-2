<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>适用于Swift开发人员的C ++ </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">适用于Swift开发人员的C ++ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-04 20:03:43</div><div class="page_narrow text-break page_content"><p>从某种意义上讲，Swift非常类似于C ++，当我说C ++时，我的意思是C ++ 11及更高版本。也可能会说Swift是更干净的C ++，或者说C ++没有80年代的向后兼容能力。为了给出一个想法，这里是一个最小的现代C ++代码：</p><p> #include＆lt; iostream＆gt; // 1使用命名空间std; // 2自动main（）-> int {// 3 cout＆lt;＆lt; ＆＃34;你好，世界！＆＃34; ; // 4返回0; // 5}</p><p>   等效的Swift将是import iostream。框架通常带有一个伞头作为单个文件，因此通常我们需要像Swift中那样为每个框架添加一个include语句。但是与Swift不同的是，我们需要为要使用自己的代码使用的每个文件添加include语句。</p><p>   与Swift不同，C ++对名称空间有适当的支持。因此，如果不同框架中的两个类型具有相同的类型名称，则可以使用它们的名称空间来解析它们。例如fwkA :: JSON和fwkB :: JSON。为了获得更像Swift的行为，我们可以添加使用来指示符号不需要每次使用都使用其名称空间。</p><p>  这是用C ++编写函数的现代方式。以经典方式，此函数也可以写成：</p><p>   像Swift一样，我们也可以重写C ++中的运算符。在这种情况下，iostream库提供cout，它是ostream类型的对象，可输出到标准输出流。 iostream还为运算符＆lt;＆lt;用于许多常见类型，例如我们上面使用的字符串。但是，如果我们提供运算符＆lt;＆lt;＆lt;对于我们的类型。与此等效的Swift将是CustomStringConvertible协议。</p><p>  最后，由于我们的函数要求返回类型为int，因此我们必须以return语句结束函数。 </p><p>通过基本介绍，现在让我们从Swift的角度更详细地了解C ++。  就像在Swift中可以由编译器使用auto推导类型一样，但是如果需要，我们也总是可以显式提供类型信息。  与Swift不同，类型转换也可以在C ++中隐式发生。 需要仔细注意这一点，以免难以发现错误。 对于其他情况，我们需要将数据从一种类型显式转换为另一种类型。 例如int到string  让label =＆＃34;宽度为＆＃34; let width = 94let widthLabel =标签+字符串（宽度）  auto label =＆＃34 ;;宽度是＆＃34 ;; auto width = 94; auto widthLabel =标签+ to_string（width）;  C ++中的字符串插值不如Swift插值。 但是尽管如此，我们仍可以使用显式字符串转换来构造字符串，就像我们在上面看到的那样  让苹果= 3let橙= 5let appleSummary =我有\（苹果）苹果。＆＃34; let fruitSummary =＆＃34;我有\（苹果+橙）水果块。＆＃34; </p><p>自动苹果= 3;自动橙子= 5;自动苹果摘要=＆＃34;我有＆＃34; + to_string（苹果）+＆＃34;苹果。自动水果摘要=我有＆＃34; + to_string（苹果+橘子）+＆＃34;块水果。＆＃34 ;;</p><p>  自动苹果= 3; ostringstream ss; ss＆lt;＆lt; ＆＃34;我有＆＃34; ＆lt;＆lt;苹果＆lt;＆lt; ＆＃34;苹果。＆＃34; ; auto str = ss。 str（）;</p><p>   让苹果= 3let橙= 5let appleSummary =我有\（苹果）苹果。＆＃34; let fruitSummary =＆＃34;我有\（苹果+橙）水果块。＆＃34;</p><p> 自动苹果= 3;自动橙子= 5;自动appleSummary =（ostringstream（）＆lt;＆lt;＆＃34;我有＆＃34;＆lt;＆lt;＆lt;＆lt;＆＃34; apples。＆＃34;） .str（）; auto fruitSummary =（ostringstream（）＆lt;＆lt;＆＃34;我有＆＃34;＆lt;（苹果+橘子）＆lt;＆lt;＆＃34;水果块。＆＃34 ;）。str（）;</p><p>      ＆amp;这意味着我们希望以item作为参考。如果我们要使用自动项目，它将始终创建一个新副本。</p><p>     for（auto＆amp; [key，value]：职业）{cout＆lt;＆lt;键＆lt;＆lt; ＆＃34; ：＆＃34; ＆lt;＆lt;值＆lt;＆lt; endl;}</p><p>  Swift开发人员喜欢Optional类型。对我们来说幸运的是，C ++还提供了以c ++ 17开头的可选类型。尽管不像Swift那样花哨，但核心思想是相同的：一种具有值或没有值的类型。这是一个例子： </p><p>func问候（必填_：布尔）-＆gt;串？ {需要退货吗？可选的（＆＃34; Hello＆＃34;）：nil;} func main（）-＆gt; Int {let s = greeting（false）?? ＆＃34;嗨＆＃34; print（s）//如果let str = greeting（true）{print（str）// Hello} return 0}</p><p> 自动问候语（需要布尔）{需要返回吗？可选{＆＃34; Hello＆＃34;}：nullopt;}自动main（）-＆gt; int {auto s = greeting（false）.value_or（＆＃34; Hi＆＃34;）; cout＆lt;＆lt; s＆lt;＆lt;恩德尔//嗨if（auto str = greeting（true））{cout＆lt;＆lt; * str＆lt;＆lt;恩德尔// Hello} return 0;}</p><p> * str可以认为是Swift中的力量展开str!。解引用后，我们可以使用。或方便的-＆gt;操作员访问变量。</p><p>    func greet（_ person：字符串，当天：String）-＆gt;字符串{return＆＃34; Hello \（person），今天是\（day）。＆＃34;}打招呼（＆＃34; John＆＃34 ;，在：＆＃34; Wednesday＆＃34;）</p><p> 自动greetPersonOnDay（字符串人，字符串日）-＆gt; string {return（ostringstream（）＆lt;＆lt;＆＃34; Hello＆＃34;＆lt;＆lt; person＆lt;＆lt;＆＃34 ;，今天是＆＃34;＆lt;＆lt; day＆lt;＆lt;＆＃34 ;。＆＃34;）。str（）;} greetPersonOnDay（＆＃34; John＆＃34 ;,＆＃34; Wednesday＆＃34;）l</p><p> 但是，如果您真的想念命名参数，那么这里有许多各种形状和大小的技巧。最简单的方法是使用结构作为参数</p><p> struct Args {字符串人，天; };自动打招呼（Args args）->字符串{return（ostringstream（）＆lt;＆lt;＃34; Hello＆＃34;＆lt;＆lt; args。person＆lt;＆lt;＆＃34 ;，今天是＆＃34;＆lt;＆lt; args。day＆lt ;＆lt;＆＃34;。＆＃34;）。 str（）; }问候（{。person =＆＃34; John＆＃34;，。day =＆＃34; Wednesday＆＃34;}） </p><p>func hasAnyMatches（list：[Int]，条件：（Int）-＆gt; Bool）-＆gt;布尔{用于列表中的项目{如果condition（item）{return true}}返回false} funless lessThanTen（number：Int）->布尔{返回编号＆lt; 10} var number = [20，19，7，12] hasAnyMatches（列表：数字，条件：lessThanTen）</p><p> 自动hasAnyMatches（vector＆lt; int＆gt;列表，function＆lt; bool（int）＆gt;条件）-＆gt; bool {for（auto item：list）{if（condition（item））{返回true; }} return false;} auto lessThanTen（int number）-＆gt; bool {返回号＆lt; 10;}自动编号= vector＆lt; int＆gt; {20，19，7，12}; hasAnyMatches（numbers，lessThanTen）;</p><p> 也就是说，C ++仍然没有Swift提供的所有精美的功能操作，例如map，filter等，但很快就会在C ++ 20系列中推出。现在，我们可以将transform等同于Swift map</p><p> transform（numbers.begin（），numbers.end（），numbers.begin（），[]（自动编号）-> auto {自动结果= 3 *数字；返回结果；}）；</p><p> 这里的C ++代码实际上会使数字突变。如果我们想要真正的Swift地图等效物，我们将必须创建一个空向量并将数据附加到其中</p><p> 自动映射的数字=向量＆lt;整数＆gt; {};变换（数字。开始（），数字。结束（），back_inserter（mappedNumbers），[]（自动n）{返回3 * n;}）；</p><p>  与C ++中的Swift不同，结构和类之间没有太大区别，唯一的区别是C ++结构默认情况下将所有成员都公开，而类默认情况下将所有成员都私有。实例是否可变取决于实例的声明方式。 </p><p>类Shape {func simpleDescription（）-＆gt;字符串{返回带有\（numberOfSides）边的形状。＆＃34; } var numberOfSides = 0} var shape = Shape（）shape.numberOfSides = 7var shapeDescription = shape.simpleDescription（）</p><p> class Shape {public：auto simpleDescription（）-＆gt;字符串{return（ostringstream（）＆lt;＆＃34;形状为＆＃34;＆lt; numberOfSides＆lt;＆lt;＆＃34;边。＆＃34;）。str（）; } int numberOfSides = 0;};自动整形= Shape（）; shape.numberOfSides = 7;自动shapeDescription = shape.simpleDescription（）;</p><p>  class Shape {init（name：String）{self.name = name} func simpleDescription（）-＆gt;字符串{返回带有\（numberOfSides）边的形状。＆＃34; } var numberOfSides = 0 var名称：String}</p><p> class Shape {public：Shape（string name）：name（name）{} auto simpleDescription（）-＆gt;字符串{return（ostringstream（）＆lt;＆＃34;形状为＆＃34;＆lt; numberOfSides＆lt;＆lt;＆＃34;边。＆＃34;）。str（）; } int numberOfSides = 0;字符串名称；};</p><p>  class Square：Shape {init（sideLength：Double，name：String）{self.sideLength = sideLength super.init（name：name）numberOfSides = 4} func area（）-> Double {return sideLength * sideLength}覆盖func simpleDescription（）->字符串{返回＆＃34;边长为\（sideLength）的正方形。＆＃34; } var sideLength：Double} let shape = Square（sideLength：5.2，name：＆＃34; My square＆＃34;）</p><p> class Square：public Shape {public：Square（double sideLength，string name）：sideLength（sideLength），Shape（name）{numberOfSides = 4; } auto area（）-> double {return sideLength * sideLength; }自动simpleDescription（）-＆gt;字符串{return（ostringstream（）＆lt;＆lt;＆＃34;边长为＆＃34;＆lt; sideLength）的正方形.str（）; } private：double sideLength;};自动形状= Square（5.2，＆＃34; My Square＆＃34;）;</p><p> 在C ++中，方法默认情况下绑定到声明的类型。让我们看一个例子来理解我的意思。 </p><p>自动形状= make_shared＆lt;形状＆gt; （＆＃34;我的形状＆＃34;）; //创建新的Shape cout＆lt;＆lt;形状-＆gt; simpleDescription（）＆lt;＆lt; Endl; //打印：具有0面的形状。形状。重置（新Square（5.2，＆＃34;我的Square＆＃34;））; //释放Shape并创建新的Square cout＆lt;＆lt;形状-＆gt; simpleDescription（）＆lt;＆lt; Endl; //打印：具有4面的形状。</p><p> 在这种情况下，由于shape最初声明为Shape类型，因此即使在将其分配给Square类型之后，simpleDescription仍然会调用Shape :: simpleDescription。为了获得与Swift相同的行为，我们必须将基类simpleDescription（）标记为虚拟的，这样，如果将Square实例分配给Shape，它将在运行时动态调度Square :: simpleDescription。</p><p> 类Shape {虚拟自动simpleDescription（）->字符串{return（ostringstream（）＆lt;＆lt;＆＃34;形状为＆＃34;＆lt;＆lt; numberOfSides＆lt;＆lt;＆lt;＆＃34;）。 str（）; } // ...}; class Square：public Shape {auto simpleDescription（）-＆gt;字符串覆盖{return（ostringstream（）＆lt;＆lt;＆＃34;边长为＆＃34;＆lt;＆lt;＆quot; sideLength的正方形）。 str（）; } // ...};自动形状= make_shared＆lt;形状＆gt; （＆＃34;我的形状＆＃34;）; //创建新的Shape cout＆lt;＆lt;形状-＆gt; simpleDescription（）＆lt;＆lt; Endl; //打印：具有0面的形状。形状。重置（新Square（5.2，＆＃34;我的Square＆＃34;））; //释放Shape并创建新的Square cout＆lt;＆lt;形状-＆gt; simpleDescription（）＆lt;＆lt; Endl; //打印：边长为5.2的正方形</p><p>  Swift具有内置的引用计数机制。 C ++还提供引用计数，但是它不是内置的。为了获得与Swift相同的行为，我们需要使用shared_ptr和weak_ptr。这是C ++的外观</p><p> class MyString {public：MyString（string str）：str（str）{cout＆lt;＆lt; ＆＃34;创建＆＃34; ＆lt;＆lt; Endl; }〜MyString（）{cout＆lt;＆lt; ＆＃34;被摧毁＆＃34; ＆lt;＆lt; Endl; }字符串str; };自动s0 = make_shared＆lt; MyString＆gt; （＆＃34;你好！＆＃34;）; cout＆lt;＆lt; ＆＃34;第一强裁判：＆＃34; ＆lt;＆lt; s0-＆gt; str＆lt;＆lt; ＆＃34; refCount：＆＃34; ＆lt;＆lt; s0 use_count（）＆lt;＆lt; Endl;自动w0 = weak_ptr＆lt; MyString＆gt; （s0）; cout＆lt;＆lt; ＆＃34;第一个弱引用：＆＃34; ＆lt;＆lt; s0-＆gt; str＆lt;＆lt; ＆＃34; refCount：＆＃34; ＆lt;＆lt; s0 use_count（）＆lt;＆lt; Endl;自动s1 = s0; cout＆lt;＆lt; ＆＃34;第二强裁判：＆＃34; ＆lt;＆lt; s1-＆gt; str＆lt;＆lt; ＆＃34; refCount：＆＃34; ＆lt;＆lt; s0 use_count（）＆lt;＆lt; Endl;</p><p>   这里没有什么奇怪的，因为您可以看到仅创建了一个实例，并且两个实例都引用同一事物，只是引用计数增加了。同样，弱引用不会增加引用计数。最后，完成后，实例将自动释放。就像迅速。</p><p>  C ++中的错误处理比Swift更复杂。因此，如果我们想从Swift错误处理的角度看待C ++异常处理，它可能看起来像： </p><p>func send（job：Int，toPrinter printerName：String）抛出-＆gt;字符串{如果printerName ==＆＃34; BadPrinterr＆＃34; {抛出PrinterError.noToner}返回＆＃34;作业已发送＆＃34;}执行{让printerResponse =尝试发送（作业：1040，toPrinter：＆＃34; BadPrinter＆＃34;）print（printerResponse）}捕获让错误{打印（错误说明）}</p><p> 自动sendJobToPrinter（int作业，字符串printerName）-＆gt;字符串{如果（printerName ==＆＃34; BadPrinter＆＃34;）{抛出PrinterError :: noToner（）; }返回＆＃34;作业已发送＆＃34 ;;}尝试{auto printerResponse = sendJobToPrinter（1040，＆＃34; BadPrinter＆＃34;）; cout＆lt;＆lt; printerResponse＆lt;＆lt; endl;} catch（const exception＆amp; error）{cout＆lt;＆lt; error.what（）＆lt;＆lt; endl;}</p><p> 与Swift不同，假定C ++函数总是抛出异常。如果保证它们不会抛出任何异常，那么我们可以将它们标记为noexcept，在这种情况下，如果引发任何异常，应用程序就会崩溃。</p><p> 在Swift中，我们的PrinterError必须符合Error，类似地，在C ++中，我们的自定义异常PrinterError必须将异常子类化。</p><p>  由于C ++枚举不如Swift出色，因此实现PrinterError类型的异常要复杂得多，但是我们可以即兴进行。</p><p> class PrinterError：公共异常{public：静态自动outOfPaper（）-> PrinterError {返回PrinterError（0，＆＃34;缺纸＆＃34;）; }静态自动noToner（）-＆gt; PrinterError {返回PrinterError（1，＆＃34; no墨粉＆＃34;）; }静态自动onFire（）-＆gt; PrinterError {返回PrinterError（2，＆＃34; on fire＆＃34;）; } PrinterError（int errorCode，const std :: string＆amp; message）noexcept：errorCode（errorCode），message（message）{}自动what（）const noexcept-＆gt; const char * {返回消息。 c_str（）; } int errorCode;字符串信息; };</p><p>  如果有C ++击败Swift的一件事，那就是泛型。这是一个通用类在C ++中的外观示例 </p><p>模板＆lt;类型名元素＆gt; class Stack {public：auto push（Element e）{storage。 push_back（e）; }自动弹出（）->可选＆lt;元素＆gt; {if（storage.empty（））{返回nullopt;自动lastEle =存储。背部 （）;储存。 pop_back（）;返回lastEle; } private：vector＆lt;元素＆gt;储存; };</p><p>  func anyCommonElements＆lt; T：序列，U：序列＆gt;（_ lhs：T，_rhs：U）-＆gt;布尔值T.Element：相等，T.Element == U.Element {对于lhs中的lhsItem {对于rhss中的rhsItem {如果lhsItem == rhsItem {return true}}}返回false} anyCommonElements（[1、2、3] ，[3]）</p><p> 模板＆lt; typename T，typename U＆gt;自动anyCommonElements（T lhs，U rhs）-> bool {for（auto lhsItem：lhs）{for（auto rhsItem：rhs）{if（lhsItem == rhsItem）{返回true; }}}返回false;} anyCommonElements（vector＆lt; int＆gt; {1，2，3}，vector＆lt; int＆gt; {3}）;</p><p> 请注意，对Sequence或Equatable的类型没有限制，因为C ++编译器会自动进行处理。如果类型约束失败，例如T.Element没有实现==，则编译器将抛出通常难以破译的错误。如果您喜欢这种控制级别，则c ++ 20提出了有关约束和概念的建议，该建议与Swift所处的位置非常接近。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://whackylabs.com/swift/cpp/languages/2021/01/03/cpp-for-swift-devs/">https://whackylabs.com/swift/cpp/languages/2021/01/03/cpp-for-swift-devs/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/swift/">#swift</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1042857.html"><img src="http://img2.diglog.com/img/2021/1/thumb_ef812e52d976fb74194da576eed9833d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042857.html">Concurrencpp –一个C ++并发库 </a></div><span class="my_story_list_date">2021-1-2 8:21</span></div><div class="col-sm"><div><a target="_blank" href="/story/1042783.html"><img src="http://img2.diglog.com/img/2021/1/thumb_4127c1d751fd486005de4a5a9ebd8340.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042783.html">2020年首创（或C ++的好消息）– Herb Sutter </a></div><span class="my_story_list_date">2021-1-1 9:3</span></div><div class="col-sm"><div><a target="_blank" href="/story/1042200.html"><img src="http://img2.diglog.com/img/2020/12/thumb_13978cda23992f3c036f3b2810e7c91f.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042200.html">Wisp：用C ++编写的轻量级Lisp </a></div><span class="my_story_list_date">2020-12-28 22:47</span></div><div class="col-sm"><div><a target="_blank" href="/story/1042100.html"><img src="http://img2.diglog.com/img/2020/12/thumb_b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042100.html">东正教C ++ </a></div><span class="my_story_list_date">2020-12-28 5:47</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>