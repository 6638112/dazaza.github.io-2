<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么NFS服务器通常具有“回复缓存” Why NFS servers generally have a 'reply cache'</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why NFS servers generally have a 'reply cache'<br/>为什么NFS服务器通常具有“回复缓存” </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-12 04:22:24</div><div class="page_narrow text-break page_content"><p>In the beginning, NFS operated over UDP, with each NFS request andeach NFS reply in a separate UDP packet (possibly fragmented). UDPhas the charming property that it can randomly drop arbitrary packets(and also reorder them). If UDP drops a NFS client&#39;s request to theserver, the NFS client will resent it (a &#39;retransmit&#39; in the jargonof NFS). If UDP drops the server&#39;s reply to a client&#39;s request, theclient will also resend the request, because it can&#39;t really tellwhy it didn&#39;t get a reply; it just knows that it didn&#39;t.</p><p>在开始时，NFS通过UDP运行，每个NFS请求ANDEACH NFS在单独的UDP数据包中回复（可能是碎片化）。 udphas它可以随机删除任意数据包的迷人属性（并且还重新排序）。如果UDP丢弃了NFS客户端＆＃39;请求对Theserver，NFS客户端将怨恨它（A＆＃39;重传＆＃39;在NFS的Jargonof）。如果UDP丢弃服务器＆＃39;我的回复对客户端＆＃39; s请求，Theclient还将重新发送请求，因为它可以＆＃39; t真正告诉他们没有得到回复＆＃39;它只是知道它没有＃39; t。</p><p> (Since clients couldn&#39;t tell the difference between a sufficientlyslow server and packet loss, they also reacted to slow servers byretransmitting their requests.)</p><p> （因为客户无法展示足够的服务器和数据包丢失之间的差异，它们也反应于ByRetransmiting其请求的慢速服务器。）</p><p> A lot of NFS operations are harmless to repeat when the server&#39;sresponse is lost. For instance, repeating any operation that readsor looks up things simply gives the client the current version ofthe state of things; if this state is different than it was before,it&#39;s pretty much a feature that the client gets a more up to dateversion. However, some operations are very dangerous to repeat ifthe server response is lost, because the result changes in a badway. For example, consider a client performing a MKDIR operation that it&#39;s using for locking. The first time,the client succeeds but the server&#39;s reply is lost; the second time,the client&#39;s request fails because the directory now exists, andthe server&#39;s reply reaches the client. Now you have a stuck lock;the client has succeeded in obtaining the lock but thinks it failedand so nothing is ever going to release the lock.</p><p> 当服务器＆＃39时，很多NFS操作都是无害的重复。例如，重复Readsor查找事物的任何操作只是给客户端提供了当前版本的事物;如果这个状态与之前的不同，它几乎是客户端达到监视的功能。但是，如果服务器响应丢失，则重复某些操作非常危险，因为结果在Badway中更改。例如，考虑执行它的MKDIR操作的客户端，它使用锁定＆＃39;第一次，客户端成功，但服务器＆＃39;回复丢失;第二次，客户端＆＃39; s请求失败，因为现在目录存在，服务器＆＃39;回复到达客户端。现在你有一个困难的锁;客户端成功获得了锁定，但认为它失败了，所以没有任何东西可以释放锁定。</p><p>  To try to work around this issue, NFS servers soon introduced theidea of a &#34;reply cache&#34;, which caches the NFS server&#39;s reply tovarious operations that are considered dangerous for clients torepeat. The hope and the idea is that when a client resends such arequest that the server has already handled, the server will findits reply in this cache and repeat it to the client. Of course thisisn&#39;t a guaranteed cure, since the cache has a finite size (and Ithink it&#39;s usually not aware of other operations that might invalidateits answers).</p><p>  为了尝试解决这个问题，NFS服务器很快就引入了A＆＃34;回复缓存＆＃34;，这缓存了NFS服务器＆＃39;对客户拖放而被认为是危险的竞争令人危险的竞争作业。希望和想法是，当客户端重新发送服务器已经处理了这样的东西时，服务器将在此缓存中找到回复并将其重复到客户端。当然是一个保证的治愈，因为缓存有一个有限尺寸（并且它通常不知道可能使答案无效的其他操作）。</p><p> In the days of NFS over UDP and frequent packet loss and retransmits,the reply cache was very important. These days, NFS over TCP usesTCP retransmits below the level that the NFS server and client see,so sent server replies are very hard to lose and actual NFS levelretransmissions are relatively infrequent (and I think they&#39;re moreoften from the client deciding that the server is too slow thanfrom actual lost replies).</p><p> 在UDP的NFS的日子里和频繁的丢包和重传，回复缓存非常重要。如今，NFS通过TCP useStcp重新转发NFS服务器和客户端看到的水平，所以已发送的服务器回复非常难以丢失，并且实际的NFS levelRetransmissions相对罕见（我认为他们从客户决定的客户端＆＃39服务器太慢，超出了实际丢失的回复）。</p><p> In past entries (eg on  how NFS in unreliable for file-based locking), I&#39;ve said that this is done for operations thataren&#39;t  idempotent.This is not really correct. There are very few NFS operations thatare truly idempotent if re-issued after a delay; a READDIR mightsee a new entry, for example, or READ could see updated data in afile. But these differences are not considered dangerous in theway that a MKDIR going from success to failure is, and so they aregenerally not cached in the reply cache in order to leave room forthe operations where it really matters.</p><p> 在过去的条目中（例如，关于基于文件的锁定不可靠的NFS），我说这是为了运营而完成的，＆＃39; t idempotent。这不是真正的正确。如果在延迟之后重新发布，那么很少有NFS操作就是真正的Idempotent;例如，readdir可能会导致新的条目，或者读取可以在afile中看到更新的数据。但是，这些差异在尾随危险的是，MKDIR从成功到失败，所以他们在回复缓存中是不缓存的，以便离开房间，以便在其真正重要的操作中离开房间。</p><p> (Thus,  the list of non-cached NFS v3 operations in the Linuxkernel NFS server mostly isn&#39;tsurprising. I do raise my eyes a little bit at COMMIT, since it mayreturn an error. Hopefully the Linux NFS server insures that arepeated COMMIT gets the same error again.)</p><p> （因此，Linuxkernel NFS服务器中的非缓存NFS V3操作列表主要是ISN＆＃39;鹤望感。我确实在提交时抬起了一点点，因为它可能会出现错误。希望Linux NFS服务器侵蚀了令人难以置信再次获取相同的错误。） </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://utcc.utoronto.ca/~cks/space/blog/unix/NFSServerReplyCacheWhy">https://utcc.utoronto.ca/~cks/space/blog/unix/NFSServerReplyCacheWhy</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/缓存/">#缓存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/回复/">#回复</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/servers/">#servers</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nfs/">#nfs</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>