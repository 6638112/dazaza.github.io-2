<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>D中的编译时排序Compile-Time Sort in D</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Compile-Time Sort in D<br/>D中的编译时排序</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 01:22:49</div><div class="page_narrow text-break page_content"><p>Björn Fahller recently wrote a blog post showing how to implement  a compile-time quicksort in C++17. It’s a skillful demonstration that employs the evolving C++ feature set to write code that, while not quite concise, is more streamlined than previous iterations. He concludes with, “…the usefulness of this is very limited, but it is kind of cool, isn’t it?”</p><p>比约恩·法勒最近写了一篇博客文章，展示了如何在C++17中实现编译时快速排序。这是一个巧妙的演示，它使用不断演进的C++特征集编写代码，虽然不是很简洁，但比以前的迭代更加流线型。他总结道，“……这项技术的实用性非常有限，但有点酷，不是吗？”</p><p> There’s quite a bit of usefulness to be found in evaluating code during compilation. The coolness (of which there is much) arises from the possibilities that come along with it. Starting from Björn’s example, this post sets out to teach a few interesting aspects of compile-time evaluation in the D programming language.</p><p>在编译过程中对代码进行评估是非常有用的。凉爽（有很多）来自于随之而来的可能性。从比约恩的例子开始，这篇文章开始教授D编程语言中编译时评估的几个有趣方面。</p><p> The article came to my attention from Russel Winder’s provocative query in the D forums, “Surely D can do better”, which was quickly resolved with a “No Story”-style answer by Andrei Alexandrescu. “There is nothing to do really. Just use standard library sort,” he quipped, and followed with code:</p><p>这篇文章引起了我的注意，是因为Russel Winder在D论坛上提出了一个挑衅性的问题，“D肯定能做得更好”，安德烈·亚历山德雷斯库（Andrei Alexandrescu）用“没有故事”式的回答很快就解决了这个问题。“真的没什么可做的。只需使用标准的库排序，”他打趣道，接着是代码：</p><p>  void main() { import std.algorithm, std.stdio; enum a = [ 3, 1, 2, 4, 0 ]; static b = sort(a); writeln(b); // [0, 1, 2, 3, 4]}</p><p>void main（）{</p><p> Though it probably won’t be obvious to those unfamiliar with D, the call to  sort really is happening at compile time. Let’s see why.</p><p>虽然对于不熟悉D的人来说，这可能并不明显，但对排序的调用实际上是在编译时发生的。让我们看看原因。</p><p>  It’s true. There are no hurdles to jump over to get things running at compile time in D. Any compile-time function is also a runtime function and can be executed in either context. However, not all runtime functions qualify for CTFE (Compile-Time Function Evaluation).</p><p>这是真的。要在D中的编译时运行，不存在任何障碍。任何编译时函数也是一个运行时函数，可以在任何上下文中执行。然而，并不是所有的运行时函数都符合CTFE（编译时函数评估）的要求。</p><p> The fundamental requirements for CTFE eligibility are that a function must be portable, free of side effects, contain no inline assembly, and the source code must be available. Beyond that, the only thing deciding whether a function is evaluated during compilation vs. at run time is the context in which it’s called.</p><p>CTFE资格的基本要求是，函数必须是可移植的，没有副作用，不包含内联程序集，并且源代码必须可用。除此之外，决定一个函数是在编译时求值还是在运行时求值的唯一因素是调用它的上下文。</p><p>  In order to be executed at compile time, the function must appear in a context where it must be so executed…</p><p>为了在编译时执行，函数必须出现在必须如此执行的上下文中…</p><p> It then lists a few examples of where that is true. What it boils down to is this: if a function can be executed in a compile-time context where it must be, then it will be. When it can’t be excecuted (it doesn’t meet the CTFE requirements, for example), the compiler will emit an error.</p><p>然后列举了几个例子来说明这一点。归根结底是这样的：如果一个函数可以在编译时上下文中执行，那么它就会在编译时上下文中执行。当它不能被超越时（例如，它不满足CTFE要求），编译器将发出一个错误。</p><p>   void main() { import std.algorithm, std.stdio; enum a = [ 3, 1, 2, 4, 0 ]; static b = sort(a); writeln(b);}</p><p>void main（）{</p><p> The points of interest that enable the CTFE magic here are lines 3 and 4.</p><p>在这里，让CTFE神奇的兴趣点是第3行和第4行。</p><p> The  enum in line 3 is a  manifest constant. It differs from other constants in D (those marked  immutable or  const) in that it exists only at compile time. Any attempt to take its address is an error. If it’s never used, then its value will never appear in the code.</p><p>第3行中的枚举是一个清单常量。它不同于D中的其他常量（标记为immutable或const的常量），因为它只在编译时存在。任何试图获取其地址的行为都是错误的。如果它从未被使用过，那么它的值将永远不会出现在代码中。</p><p> When an  enum is used, the compiler essentially pastes its value in place of the symbol name.</p><p>使用枚举时，编译器基本上会粘贴其值来代替符号名。</p><p> enum xinit = 10;int x = xinit;immutable yinit = 11;int y = yinit;</p><p>enum xinit=10；</p><p> Here,  x is initialized to the literal  10. It’s identical to writing  int x = 10. The constant  yinit is initialized with an  int literal, but  y is initialized with the value of  yinit, which, though known at compile time, is not a literal itself.  yinit will exist at run time, but  xinit will not.</p><p>这里，x被初始化为文本10。这和写int x=10是一样的。常量yinit用int-literal初始化，但y用yinit的值初始化，虽然在编译时已知，但yinit本身不是一个literal。yinit将在运行时存在，但xinit不会。</p><p> In  Example 1, the static variable  b is initialized with the manifest constant  a. In  the CTFE documentation, this is listed as an example scenario in which a function must be evaluated during compilation. A static variable declared in a function can only be initialized with a compile-time value. Trying to compile this:</p><p>在示例1中，静态变量b用清单常量a初始化。在CTFE文档中，这是一个示例场景，在该场景中，必须在编译期间对函数进行求值。函数中声明的静态变量只能用编译时值初始化。试图编译以下内容：</p><p>     Using a function call to initialize a static variable means the function must be executed at compile time and, therefore, it will be if it qualifies.</p><p>使用函数调用初始化静态变量意味着该函数必须在编译时执行，因此，如果它符合条件，就会执行。</p><p> Those two pieces of the puzzle, the manifest constant and the static initializer, explain why the call to  sort in  Example 1 happens at compile time without any metaprogramming contortions. In fact, the example could be made one line shorter:</p><p>这两个谜题，manifest常量和静态初始值设定项，解释了为什么示例1中的排序调用发生在编译时，没有任何元编程扭曲。事实上，这个例子可以缩短一行：</p><p>  void main() { import std.algorithm, std.stdio; static b = sort([ 3, 1, 2, 4, 0 ]); writeln(b);}</p><p>void main（）{</p><p> And if there’s no need for  b to stick around at run time, it could be made an  enum instead of a static variable:</p><p>如果不需要在运行时保留b，则可以将其设置为枚举，而不是静态变量：</p><p>  void main() { import std.algorithm, std.stdio; enum b = sort([ 3, 1, 2, 4, 0 ]); writeln(b);}</p><p>void main（）{</p><p> In both cases, the call to  sort will happen at compile time, but they handle the result differently. Consider that, due to the nature of  enums, the change will produce an equivalent of this:  writeln([ 0, 1, 2, 3, 4 ]). Because the call to  writeln happens at run time, the array literal might trigger  a GC allocation (though it could be, and sometimes will be, optimized away). With the static initializer, there is no runtime allocation, as the result of the function call is used at compile time to initialize the variable.</p><p>在这两种情况下，对sort的调用都将在编译时发生，但它们处理结果的方式不同。考虑到，由于枚举的性质，改变将产生一个等价于：WreLeln（[ 0, 1, 2，3, 4 ]）。因为对writeln的调用发生在运行时，所以数组文字可能会触发GC分配（尽管它可能会优化，有时也会优化）。对于静态初始值设定项，没有运行时分配，因为函数调用的结果在编译时用于初始化变量。</p><p> It’s worth noting that  sort isn’t directly returning a value of type  int[]. Take a peek at  the documentation and you’ll discover that what it’s giving back is a   SortedRange. Specifically in our usage, it’s a  SortedRange!(int[], &#34;a &lt; b&#34;). This type, like arrays in D, exposes all of the primitives of a  random-access range, but additionally provides functions that only work on sorted ranges and can take advantage of their ordering (e.g.   trisect). The array is still in there, but wrapped in an enhanced API.</p><p>值得注意的是，sort并不是直接返回int[]类型的值。看一眼文档，你会发现它给你的是一个分类。具体来说，在我们的使用中，它是一个分拣机！（int[]，&#34；a&lt；b&#34；）。这种类型与D中的数组一样，公开了随机访问范围的所有原语，但还提供了只在排序范围内工作的函数，并可以利用它们的排序（例如三等分）。该阵列仍在那里，但被包装在一个增强的API中。</p><p>  I mentioned above that all compile-time functions are also runtime functions. Sometimes, it&#39;s useful to distinguish between the two inside the function itself. D allows you to do that with the  __ctfe variable. Here&#39;s an example from my book, &#39; Learning D&#39;.</p><p>我在上面提到过，所有编译时函数也是运行时函数。有时，它&#39；它有助于区分函数本身内部的这两个方面。D允许您使用_ctfe变量来实现这一点。这里&#39；这是我书中的一个例子，&#39；学习D&#39；。</p><p>  string genDebugMsg(string msg) { if(__ctfe) return &#34;CTFE_&#34; ~ msg; else return &#34;DBG_&#34; ~ msg;}pragma(msg, genDebugMsg(&#34;Running at compile-time.&#34;));void main() { writeln(genDebugMsg(&#34;Running at runtime.&#34;));}</p><p>字符串genDebugMsg（字符串msg）{</p><p> The   msg pragma prints a message to  stderr at compile time. When  genDebugMsg is called as its second argument here, then inside that function the variable  __ctfe will be  true. When the function is then called as an argument to  writeln, which happens in a runtime context,  __ctfe is  false.</p><p>msg pragma在编译时将消息打印到stderr。当genDebugMsg在这里被作为第二个参数调用时，那么在该函数中变量_ctfe将为true。然后，当函数作为writeln的参数调用时（这发生在运行时上下文中），_ctfe为false。</p><p> It&#39;s important to note that  __ctfe is  not a compile-time value. No function knows if it&#39;s being executed at compile-time or at run time. In the former case, it&#39;s being evaluated by an interpreter that runs inside the compiler. Even then, we can make a distinction between compile-time and runtime values inside the function itself. The result of the function, however, will be a compile-time value when it&#39;s executed at compile time.</p><p>它&#39；重要的是要注意_ctfe不是编译时值。没有函数知道它是否&#39；在编译时或运行时执行。在前一种情况下，它是&#39；它由编译器内部运行的解释器进行评估。即使这样，我们也可以在函数本身内部区分编译时和运行时值。然而，函数的结果将是编译时的值，当它&#39；在编译时执行。</p><p>  Now let&#39;s look at something that doesn&#39;t use an out-of-the-box function from the standard library.</p><p>现在让&#39；让我们看一看那些没有&#39；t使用标准库中的现成功能。</p><p> A few years back, Andrei published &#39; The D Programming Language&#39;. In the section describing CTFE, he implemented three functions that could be used to validate the parameters passed to a hypothetical  linear congruential generator. The idea is that the parameters must meet a set of criteria, which he lays out in the book (buy it for the commentary -- it&#39;s well worth it), for generating the largest period possible. Here they are, minus the unit tests:</p><p>几年前，安德烈出版了&#39；D编程语言&#39；。在描述CTFE的部分中，他实现了三个函数，可以用来验证传递给假设的线性同余生成器的参数。他的想法是，这些参数必须满足一系列标准，他在书中列出了这些标准（为评论购买——这很值得），以产生尽可能大的周期。这里是，减去单元测试：</p><p>  // Implementation of Euclid’s algorithmulong gcd(ulong a, ulong b) {  while (b) { auto t = b; b = a % b; a = t; } return a; }ulong primeFactorsOnly(ulong n) { ulong accum = 1; ulong iter = 2; for (; n &gt;= iter * iter; iter += 2 - (iter == 2)) { if (n % iter) continue; accum *= iter; do n /= iter; while (n % iter == 0); } return accum * n;}bool properLinearCongruentialParameters(ulong m, ulong a, ulong c) {  // Bounds checking if (m == 0 || a == 0 || a &gt;= m || c == 0 || c &gt;= m) return false;  // c and m are relatively prime if (gcd(c, m) != 1) return false; // a - 1 is divisible by all prime factors of m if ((a - 1) % primeFactorsOnly(m)) return false; // If a - 1 is multiple of 4, then m is a multiple of 4, too.  if ((a - 1) % 4 == 0 &amp;&amp; m % 4) return false; // Passed all tests return true;}</p><p>//欧几里德算法的实现</p><p> The key point this code was intended to make is the same one I made earlier in this post:  properLinearCongruentialParameters is a function that can be used in both a compile-time context and a runtime context. There&#39;s no special syntax required to make it work, no need to create two distinct versions.</p><p>这段代码的要点与我在本文前面提到的相同：properLinearCongressionalParameters是一个可以在编译时上下文和运行时上下文中使用的函数。那里&#39；它不需要特殊的语法来工作，也不需要创建两个不同的版本。</p><p> Want to implement a linear congruential generator as a templated struct with the RNG parameters passed as template arguments? Use  properLinearCongruentialParameters to validate the parameters. Want to implement a version that accepts the arguments at run time?  properLinearCongruentialParameters has got you covered. Want to implement an RNG that can be used at both compile time and run time? You get the picture.</p><p>要将线性同余生成器实现为模板结构，并将RNG参数作为模板参数传递吗？使用properLinearConcurentialParameters验证参数。想要实现一个在运行时接受参数的版本吗？适当的近似全等参数已经覆盖了你。想要实现一个可以在编译时和运行时使用的RNG吗？你明白了。</p><p>   void main() { enum ulong m = 1UL &lt;&lt; 32, a = 1664525, c = 1013904223; static ctVal = properLinearCongruentialParameters(m, a, c); writeln(properLinearCongruentialParameters(m, a, c));}</p><p>void main（）{</p><p> If you&#39;ve been paying attention, you&#39;ll know that  ctVal must be initialized at compile time, so it forces CTFE on the call to the function. And the call to the same function as an argument to  writeln happens at run time. You can have your cake and eat it, too.</p><p>如果你&#39；我一直在注意，你&#39；我们知道ctVal必须在编译时初始化，因此它会强制CTFE调用函数。对同一函数的调用与对writeln的参数的调用发生在运行时。你也可以吃蛋糕。</p><p>  Compile-Time Function Evaluation in D is both convenient and painless. It can be combined with other features such as  templates (it&#39;s particularly useful with template parameters and constraints),  string mixins and  import expressions to simplify what might otherwise be extremely complex code, some of which wouldn&#39;t even be possible in many languages without a preprocessor. As a bonus, Stefan Koch is currently working on  a more performant CTFE engine for the D frontend to make it even more convenient. Stay tuned here for more news on that front.</p><p>D中的编译时函数求值既方便又无痛。它可以与其他功能相结合，例如模板（它对模板参数和约束特别有用）、字符串混合和导入表达式，以简化可能非常复杂的代码，其中一些代码不会&#39；在许多语言中，没有预处理器是不可能的。作为奖励，Stefan Koch目前正在为D前端开发性能更高的CTFE引擎，使其更加方便。请继续关注这方面的更多新闻。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ctfe/">#ctfe</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>