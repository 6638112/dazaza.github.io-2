<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>检测“ curl – bash”服务器端的使用（2016年） Detecting the use of “curl – bash” server side (2016)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Detecting the use of “curl – bash” server side (2016)<br/>检测“ curl – bash”服务器端的使用（2016年） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-09 19:56:27</div><div class="page_narrow text-break page_content"><p>Installing software by piping from curl to bash is obviously  a bad idea and a knowledgable user will most likely check the content first. So wouldn&#39;t it be great if a malicious payload would only render when piped to bash? A few people have tried this before by checking for the curl user agent which is by no means fail safe - the user may simply curl the url on the commandline revealing your malicious code. Luckily the behaviour of curl (and wget) changes subtely when piped into bash. This allows an attacker to present two different versions of their script depending on the context :)</p><p>通过从curl到bash的管道安装软件显然不是一个好主意，并且知识渊博的用户很可能会首先检查内容。因此，如果恶意有效负载仅在通过管道传输到bash时才会呈现，那不是很好吗？之前有一些人通过检查curl用户代理进行了尝试，但这绝不是故障安全的方法-用户可以简单地在命令行上卷曲url，以显示您的恶意代码。幸运的是，当将其卷曲到bash中时，curl（和wget）的行为会发生细微变化。这使得攻击者可以根据上下文提供两种不同版本的脚本：）</p><p> Its not that the HTTP requests from curl when piped to bash look any different than those piped to stdout, in fact for all intents and purposes they are identical:</p><p> 它并不是通过curl传递到bash时来自curl的HTTP请求看起来与通过stdout传递的HTTP请求看起来有什么不同，实际上，就所有意图而言，它们是相同的：</p><p> # curl -vv http://pluver.xqi.cc/setup.bash* Hostname was NOT found in DNS cache* Trying 69.28.82.189...* Connected to xqi.cc (69.28.82.189) port 80 (#0)&gt; GET /setup.sh HTTP/1.1&gt; User-Agent: curl/7.35.0&gt; Host: xqi.cc&gt; Accept: */*&gt;</p><p> ＃curl -vv http://pluver.xqi.cc/setup.bash*在DNS缓存中找不到主机名*尝试69.28.82.189 ... *已连接到xqi.cc（69.28.82.189）端口80（＃0） ＆gt; GET /setup.sh HTTP / 1.1＆gt;用户代理：curl / 7.35.0＆gt;主持人：xqi.cc＆gt;接受：* / *＆gt;</p><p> The key difference is in time it takes for the contents of large http responses to be ingested by bash.</p><p> 关键的区别在于，bash提取大型http响应的内容所花费的时间。</p><p>  Execution in bash is performed line by line and so the speed that bash can ingest data is limited by the speed of execution of the script. This means if we return a sleep at the start of our script the TCP send stream will pause while we wait for the sleep to execute. This pause can be detected and used to render different content streams.</p><p>  bash中的执行是逐行执行的，因此bash可以吸收数据的速度受到脚本执行速度的限制。这意味着，如果我们在脚本的开头返回睡眠，则在等待睡眠执行时，TCP发送流将暂停。可以检测到此暂停并将其用于呈现不同的内容流。</p><p> Unfortuneatly its not just a simple case of wrapping a socket.send(&#34;sleep 10&#34;) in a timer and waiting for a send call to block. The send and receive TCP streams in linux are buffered on a per socket basis, so we have to fill up these buffers before the call to send data will block. We know the buffer is full when the receiving client to replies to a packet with the Window Size flag set to 0 ( Win=0 in wireshark).</p><p> 不幸的是，这不仅是将socket.send（＆＃34; sleep 10＆＃34;）包装在计时器中并等待发送调用以阻塞的简单情况。 linux中的发送和接收TCP流在每个套接字的基础上进行缓冲，因此在发送数据的调用被阻塞之前，我们必须填充这些缓冲区。我们知道当接收客户端回复窗口大小标志设置为0（wireshark中的Win = 0）时，缓冲区已满。</p><p>  To detect a pause in execution we need to fill all the buffers before the pipe to bash. The flow of data from the HTTP response looks like this:</p><p>  为了检测执行中的暂停，我们需要在bash进行bash之前填充所有缓冲区。来自HTTP响应的数据流如下所示： </p><p>  Both the send and receive buffer sizes on linux are &#34;auto tuned&#34; per socket, this means their size can vary (check /proc/sys/net/ipv4/tcp_rmem and /proc/sys/net/ipv4/tcp_wmem to see just how much). We can control the send buffer as its on the server side but we can&#39;t do anything about the receive buffer. By fixing the size of the send buffer we can reduce the overal variance in the amount of data we need to send before we receive a window size of 0 from the client. A smaller fixed sized send buffer helps to prevent the TCP receive buffer from growing.</p><p>在Linux上，发送和接收缓冲区的大小都是＆＃34;自动调整的＆＃34;每个套接字，这意味着它们的大小可能会有所不同（请检查/ proc / sys / net / ipv4 / tcp_rmem和/ proc / sys / net / ipv4 / tcp_wmem以查看大小）。我们可以在服务器端控制发送缓冲区，但是不能对接收缓冲区做任何事情。通过固定发送缓冲区的大小，我们可以减少从客户端接收到的窗口大小为0之前需要发送的数据量的总体差异。较小的固定大小的发送缓冲区有助于防止TCP接收缓冲区增大。</p><p> The bufer size can be set like so (87380 is the default for Ubunty 14.04 LTS)</p><p> 缓冲区大小可以这样设置（Ubunty 14.04 LTS的默认值为87380）</p><p>  When tested with Ubuntu you need to send about 1mb of data to fill up the receive buffer - remove the restriction on the send buffer and this easily doubles. The question is what to fill the TCP buffer up with as a curl request without a pipe to bash will render in the console.</p><p>  在Ubuntu上进行测试时，您需要发送大约1mb的数据以填充接收缓冲区-取消对发送缓冲区的限制，这很容易加倍。问题是，作为curl请求填充TCP缓冲区的内容是什么，而没有bash管道将在控制台中呈现。</p><p>  The only character you can really use to fill the buffer is a null byte as it won&#39;t render in most consoles. It also wont render in chrome when the charset text/html is specified. As we dont know the content-length data is transfered with  chunked encoding with each chunk being a string of null bytes same size as the TCP send buffer.</p><p>  真正可以用来填充缓冲区的唯一字符是一个空字节，因为在大多数控制台中它不会呈现。当指定字符集text / html时，它也不会在chrome中呈现。我们不知道内容长度数据是通过分块编码传输的，每个分块都是一个空字节字符串，大小与TCP发送缓冲区相同。</p><p>  HTTP / 1 .1  200  OK Host :  xqi .cc Transfer-type :  chunked Content-type :  text / html ;  charset = us-ascii sleep  10  &lt; --  chunk  #1 0x0000000000000000000000000000000000 ...  &lt; --  chunk  #2 0x0000000000000000000000000000000000 ...  &lt; --  chunk  #3 0x0000000000000000000000000000000000 ...  &lt; --  chunk  #4 ...</p><p>  HTTP / 1 .1 200 OK主机：xqi .cc传输类型：分块内容类型：text / html；字符集= us-ascii睡眠10＆lt; -块＃1 0x0000000000000000000000000000000000 ... -块＃2 0x0000000000000000000000000000000000 ... ... -块＃3 0x0000000000000000000000000000000000 ... ... -块＃4 ...</p><p>  If you chart the time between each chunk is sent and do this for both scenarios it becomes easy to determine which outputs were piped through bash. For  curl | bash you can see a clear jump of just under 10 seconds when the sleep command is executed (the exact location varies according to the size of the tcp receive buffer on the client side).</p><p>  如果您绘制每个块之间发送的时间的图表，并针对这两种情况进行此操作，则很容易确定哪些输出通过bash传递。卷曲bash，您可以在执行sleep命令时看到不到10秒的跳跃（确切位置根据客户端tcp接收缓冲区的大小而有所不同）。</p><p>  This works well and as long as the connection between the server and the client are stable you could happily reduce the sleep command to less than a second, you can also disguise the delay as another slow command (ping, find etc..). The exact time the command takes to run doesn&#39;t matter as long as the server is able to detect a sudden jump in the cumulative transmission time.</p><p>  只要服务器和客户端之间的连接稳定，就可以很好地将sleep命令减少到不到一秒，也可以将延迟伪装成另一个慢命令（ping，find等）。只要服务器能够检测到累积传输时间中的突然跳跃，命令运行所需的确切时间就无关紧要。 </p><p> This distinctive pattern can be identified by taking the differences in times between chunk transmissions, finding the maximum value, removing it from the list,  calculating the varience of the remaining data and ensuring that the both the varience is low (this implies a stable connection) and the maximum difference is high. If this pattern is identified you can send another http chunk containing your malicious script.</p><p>可以通过获取块传输之间的时间差异，找到最大值，将其从列表中删除，计算剩余数据的方差并确保两者的方差都很小（这意味着稳定的连接）来识别这种独特的模式。和最大的差异是高的。如果识别出此模式，则可以发送另一个包含恶意脚本的http块。</p><p>  Putting everything together and you end up with a small python based server that can deliver different payloads based on what the content is piped to (this also works with &#34; wget -o /dev/null -O -&#34;). If for some reason the connection is unreliable (the variance is high) or you request the file via a browser the non-malicious payload will display:</p><p>  将所有内容放在一起，最终得到一台基于python的小型服务器，该服务器可以根据传递的内容传递不同的有效负载（这也适用于＆＃34; wget -o / dev / null -O-＆＃34;） 。如果由于某种原因连接不可靠（差异很大）或您通过浏览器请求文件，则非恶意负载将显示：</p><p>    So how do you detect if a server is doing this? If the detection is done via a simple delay then you could try either looking for large scripts containing lots of padding or do:</p><p>    那么，如何检测服务器是否正在执行此操作？如果检测是通过简单的延迟完成的，则可以尝试寻找包含大量填充的大型脚本，或者执行以下操作：</p><p>  However, this is by no means fool proof as an attacker can use other methods (e.g. http/dns callbacks) or set multiple passive delays. The better solution is never to pipe untrusted data streams into bash. If you still want to run untrusted bash scripts a better approach is to pipe the contents of URL into a file, review the contents on disk and only then execute it.</p><p>  但是，这绝不是傻瓜，因为攻击者可以使用其他方法（例如http / dns回调）或设置多个被动延迟。更好的解决方案是永远不要将不受信任的数据流传输到bash中。如果您仍然想运行不受信任的bash脚本，更好的方法是将URL的内容通过管道传输到文件中，检查磁盘上的内容，然后再执行它。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.idontplaydarts.com/2016/04/detecting-curl-pipe-bash-server-side/">https://www.idontplaydarts.com/2016/04/detecting-curl-pipe-bash-server-side/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/curl/">#curl</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bash/">#bash</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>