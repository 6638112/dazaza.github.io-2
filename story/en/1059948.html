<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>提出（1993） Moving Forth (1993)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Moving Forth (1993)<br/>提出（1993） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-23 16:58:18</div><div class="page_narrow text-break page_content"><p>Everyone in the Forth community talks about how easy it is to port Forthto a new CPU. But like many &#34;easy&#34; and &#34;obvious&#34; tasks,not much is written on how to do it! So, when Bill Kibler suggested thistopic for an article, I decided to break with the great oral traditionof Forthwrights, and document the process in black and white.</p><p>四个社区中的每个人都谈到港口的容易程度到一个新的CPU。但像许多＆＃34; Easy＆＃34;和＃34;显而易见的＆＃34;任务，没有太多写的是如何做到！所以，当比尔凯贝尔建议这一点时一篇文章的主题，我决定突破大口头传统怎样，并记录黑白的过程。</p><p>  Over the course of these articles I will develop Forths for the 6809,8051, and Z80. I&#39;m doing the 6809 to illustrate an easy and conventionalForth model; plus, I&#39;ve already published a 6809 assembler [ROD91,ROD92],and I&#39;ll be needing a 6809 Forth for future TCJ projects. I&#39;m doing the8051 Forth for a University project, but it also illustrates some ratherdifferent design decisions. The Z80 Forth is for all the CP/M readers ofTCJ, and for some friends with TRS-80s gathering dust.</p><p>  在这些文章的过程中，我将培养6809，8051和Z80。我在做6809的情况下，我＆＃39;迈将简单而传统模型;加上，我已经发表了一台6809档次[rod91，rod92]，和我＆＃39; ll需要一个6809才能为未来的TCJ项目。我在做的8051年为大学项目，但它也是一些相当的说明不同的设计决策。 Z80是针对所有CP / M读者TCJ，以及一些有关TRS-80S收集灰尘的朋友。</p><p>    You must choose a CPU. I will not delve into the merits of oneCPU over another for Forth, since a CPU choice is usually forced upon youby other considerations. Besides, the object of this article is to showhow to move Forth to  any CPU.</p><p>    您必须选择CPU。我不会深入研究一个CPU超过另一个，因为CPU选择通常被迫在你身上通过其他考虑。此外，本文的对象是展示如何向任何CPU申请。</p><p>  You can expect the usual 16-bit Forth kernel (see below) to occupy about8K bytes of program space. For a full kernel that can compile Forth definitions,you should allow a minimum of 1K byte of RAM. To use Forth&#39;s block-managementsystem for disk storage, you should add 3 Kbytes or more for buffers. Fora 32-bit Forth model, double these numbers.</p><p>  您可以期待通常的16位新内核（见下文）占据8K字节的节目空间。对于可以编译定义的完整内核，您应该允许最少1K字节的RAM。使用＆＃39;块管理用于磁盘存储系统，您应该为缓冲区添加3 kBytes或更多。为了32位模型，双倍这些数字。</p><p>  These are the  minimums to get a Forth kernel up and running.To run an application on your hardware, you should increase PROM and RAMsizes to suit.</p><p>  这些是最低次数和运行的最低限度。要在硬件上运行应用程序，您应该增加舞会和公羊尺寸适合。</p><p>    The word size used by Forth is not necessarily the same as that of theCPU. The smallest practical Forth is a 16-bit model; i.e., one which uses16-bit integers and 16-bit addresses. The Forth community calls this the&#34;cell&#34; size, since &#34;word&#34; refers to a Forth definition.</p><p>    使用的单词尺寸不一定与之相同中央处理器。最小的实际索引是一个16位模型;即，使用一个16位整数和16位地址。四个社区称之为＆＃34;细胞＆＃34;大小，自从＃34; Word＆＃34;指的是第四个定义。</p><p>  8-bit CPUs almost invariably support 16-bit Forths. This usually requiresexplicit coding of double-byte arithmetic, although some 8-bit CPUs dohave a few 16-bit operations.</p><p>  8位CPU几乎总是支持16位。这通常需要双字节算术的显式编码，虽然有一些8位CPU有几个16位操作。 </p><p>  16-bit CPUs commonly run 16-bit Forths, although the same double- precisiontechniques can be used to write a 32-bit Forth on a 16- bit CPU. At leastone 32-bit Forth has been written for the 8086/8088.</p><p>16位CPU通常运行16位，虽然是相同的双精度可以使用技术在16位CPU上写入32位。至少为8086/8088编写了一个32位。</p><p>  32-bit CPUs normally run 32-bit Forths. A smaller Forth model rarelysaves code length or processor time. However, I know of at least one 16-bitForth written for the 68000. This  does shrink application code sizeby a factor of two, since high-level Forth definitions become a stringof 16-bit addresses rather than a string of 32-bit addresses. (This willbecome evident shortly.) Most 68000s, though, have plenty of RAM.</p><p>  32位CPU通常运行32位。较小的模型很少保存代码长度或处理器时间。但是，我知道至少有一个16位为68000编写的。这确实收缩了应用程序代码大小由于两个倍数，因为高级别的定义成为一个字符串16位地址而不是32位地址的字符串。 （这会很快就变得明显。）大多数68000岁，有很多RAM。</p><p>  All of the examples described in this article are 16-bit Forths runningon 8-bit CPUs.</p><p>  本文中描述的所有示例都是16位运行在8位CPU上。</p><p>    &#34;Threaded code&#34; is the hallmark of Forth. A Forth &#34;thread&#34;is just a list of addresses of routines to be executed. You can think ofthis as a list of subroutine calls, with the CALL instructions removed.Over the years many threading variations have been devised, and which oneis best depends upon the CPU and the application. To make a decision, youneed to understand how they work, and their tradeoffs.</p><p>    ＆＃34;线程代码＆＃34;是标志的标志。 Xthapt＆＃34;线程＆＃34;只是要执行的例程的地址列表。你可以想到这是子程序调用列表，删除了呼叫指令。多年来，已经设计了许多穿线变化，哪一个最好取决于CPU和应用程序。做出决定，你需要了解他们的工作方式以及他们的权衡。</p><p>    This is the classical Forth threading technique, used in fig- Forthand F83, and described in most books on Forth. All the other threadingschemes are &#34;improvements&#34; on this, so you need to understandITC to appreciate the others.</p><p>    这是典型的螺纹技术，用于代表和F83，并在大多数书籍中描述。所有其他螺纹方案是＆＃34;改进＆＃34;在这方面，所以你需要了解ITC欣赏他人。</p><p>      In a typical ITC Forth this would appear in memory as shown in Figure1. (The header will be discussed in a future article; it holds housekeepinginformation used for compilation, and isn&#39;t involved in threading.)</p><p>      在典型的ITC中，这将出现在内存中，如图所示1.（标题将在未来的文章中讨论;它持有家务用于编译的信息，以及涉及穿线的ISN＆＃39;）</p><p>    Assume SQUARE is encountered while executing some other Forth word.Forth&#39;s Interpreter Pointer (IP) will be pointing to a cell in memory --contained within that &#34;other&#34; word -- which contains the addressof the word SQUARE. (To be precise, that cell contains the address of SQUARE&#39;sCode Field.) The interpreter fetches that address, and then uses it tofetch the contents of SQUARE&#39;s Code Field. These contents are yet anotheraddress -- the address of a machine language subroutine which performsthe word SQUARE. In pseudo-code, this is:</p><p>    在执行其他一些单词时遇到广场。＆＃39; S解释器指针（IP）将指向内存中的单元格 - 包含在该＆＃34之内;其他＆＃34;单词 - 包含地址字广场。 （要精确，那个细胞包含广场的地址＆＃39; s代码字段。）解释器获取该地址，然后使用它获取Square＆＃39; s代码字段的内容。这些内容又是另一个地址 - 执行的机器语言子程序的地址字广场。在伪代码中，这是： </p><p>  (IP) -&gt; W fetch memory pointed by IP into &#34;W&#34; register ...W now holds address of the Code Field IP+2 -&gt; IP advance IP, just like a program counter (assuming 2-byte addresses in the thread) (W) -&gt; X fetch memory pointed by W into &#34;X&#34; register ...X now holds address of the machine code  JP (X) jump to the address in the X register</p><p>（IP） - ＆gt; w获取IP进入＆＃34; W＆＃34;登记 ... W现在保存代码字段的地址 IP + 2  - ＆gt; IP affign ip，就像一个程序计数器 （假设线程中的2字节地址） （w） - ＆gt; X由W引入＆＃34; x＆＃34;登记 ... x现在包含机器代码的地址 jp（x）跳转到x寄存器中的地址</p><p>  This illustrates an important but rarely-elucidated principle:  theaddress of the Forth word just entered is kept in W. CODE words don&#39;tneed this information, but all other kinds of Forth words do.</p><p>  这说明了重要但很少被阐明的原则：刚输入的第四个词的地址被保存在W.代码词不＆＃39; t需要这些信息，但所有其他类型的词语都这样做。</p><p>  If SQUARE were written in machine code, this would be the end of thestory: that bit of machine code would be executed, and then jump back tothe Forth interpreter -- which, since IP was incremented, is pointing tothe  next word to be executed. This is why the Forth interpreteris usually called NEXT.</p><p>  如果广场是用机器代码编写的，这将是结束故事：将执行那么一点机器代码，然后跳回到第四解释器 - 由于IP递增，所以指向要执行的下一个单词。这就是为什么第四解释器通常被称为下一个。</p><p>  But, SQUARE is a high-level &#34;colon&#34; definition -- it holdsa &#34;thread&#34;, a list of addresses. In order to perform this definition,the Forth interpreter must be re-started at a new location: the ParameterField of SQUARE. Of course, the interpreter&#39;s old location must be saved,to resume the &#34;other&#34; Forth word once SQUARE is finished. Thisis just like a subroutine call! The machine language action of SQUARE issimply to push the old IP, set IP to a new location, run the interpreter,and when SQUARE is done pop the IP. (As you can see, the IP is the &#34;programcounter&#34; of high-level Forth.) This is called DOCOLON or ENTER invarious Forths:</p><p>  但是，广场是一个高级别的＆＃34;冒号＆＃34;定义 - 它持有A＆＃34;线程＆＃34;，地址列表。为了执行这个定义，必须在新位置重新启动第四解释器：参数广场领域。当然，翻译＆＃39;旧位置必须保存，恢复＆＃34;其他＆＃34;一旦Square完成了一个单词。这就像一个子程序电话！方形的机器语言动作是只需将旧IP推动，将IP设置为新位置，运行解释器，当Square完成时，弹出IP。 （正如您所看到的，IP是＆＃34;程序柜台＆＃34;高级别。）这被称为Docolon或进入各种各样的：</p><p>  PUSH IP onto the &#34;return address stack&#34; W+2 -&gt; IP W still points to the Code Field, so W+2 is  the address of the Body! (Assuming a 2-byte address -- other Forths may be different.) JUMP to interpreter (&#34;NEXT&#34;)</p><p>  将IP推入＆＃34;返回地址堆栈＆＃34; W + 2  - ＆gt; IP W仍然指向代码字段，因此W + 2是 身体的地址！ （假设一个2字节 地址 - 其他可能是不同的。） 跳转到翻译（＆＃34;下一个＆＃34;）</p><p>  This identical code fragment is used by all high-level (i.e., threaded)Forth definitions! That&#39;s why a pointer to this code fragment, not thefragment itself, is included in the Forth definition. Over hundreds ofdefinitions, the savings add up! And this is why it&#39;s called Indirect threading.</p><p>  所有高级（即，螺纹）使用该相同的代码片段第四个定义！那个＆＃39;为什么指向这个代码片段的指针，而不是片段本身，包括在第四个定义中。超过数百人定义，储蓄加起来！这就是为什么它＆＃39; s被称为间接线程。</p><p>  The &#34;return from subroutine&#34; is the word EXIT, which getscompiled when Forth sees &#39;;&#39;. (Some Forths call it ;S instead of EXIT.)EXIT just executes a machine language routine which does the following:</p><p>  和＃34;从子程序返回和＃34;是退出这个词，得到了汇编什么时候＆＃39 ;;＆＃39; （有的话称之为; s而不是退出。）退出只执行机器语言例程，执行以下操作： </p><p>    Walk through a couple of nested Forth definitions, just to assure yourselfthat this works.</p><p>走过几个嵌套的定义，只是为了保证自己这是有效的。</p><p>  Note the characteristics of ITC:  every Forth word has a one-cellCode Field. Colon definitions compile one cell for each word used in thedefinition. And the Forth interpreter must actually perform a  doubleindirection to get the address of the next machine code to run (first throughIP, then through W).</p><p>  注意ITC的特征：每一个单词都有一个细胞代码字段。冒号定义编译一个用于每个单词的一个单元格定义。而第四个翻译必须实际执行双重间接获取下一台机器代码的地址运行（首先通过IP，然后通过w）。</p><p>  ITC is neither the smallest nor the fastest threading technique. Itmay be the simplest; although DTC (described next) is really no more complex.So why are so many Forths indirect-threaded? Mainly because  previousForths, used as models, were indirect- threaded. These days, DTC is becomingmore popular.</p><p>  ITC既不是最小，也不是最快的线程技术。它可能是最简单的;虽然DTC（下一个描述）真的没有更复杂。那么为什么这么多的间接线程？主要是因为以前用作模型的索斯是间接的。这几天，DTC正在变成更流行。</p><p>  So when should ITC be used? Of the various techniques, ITC producesthe cleanest and most elegant definitions -- nothing but addresses. Ifyou&#39;re attuned to such considerations, ITC may appeal to you. If your codefiddles around with the insides of definitions, the simplicity and uniformityof the ITC representation may enhance portability. ITC is the classicalForth model, so it may be preferred for education. Finally, on CPUs lackinga subroutine call instruction -- such as the 1802 -- ITC is often moreefficient than DTC.</p><p>  所以应该什么时候使用ITC？各种技术，ITC产生最干净，最优雅的定义 - 除了地址。如果您＆＃39;重新调整此类考虑因素，ITC可能会对您诉争。如果您的代码用定义的内部，简单和均匀的内部摆弄ITC表示可能提高可移植性。 ITC是古典的模型，所以可能是教育的首选。最后，关于CPU缺乏子程序调用指令 - 例如1802  -  ITC通常更多高于DTC。</p><p>    Direct Threaded Code differs from ITC in only one respect: instead ofthe Code Field containing the address of some machine code,  the CodeField contains actual machine code itself.</p><p>    直接线程代码与ITC的不同之处在于一个方面：代替包含某些机器代码的地址，代码的代码字段字段包含实际的机器代码本身。</p><p>  I&#39;m not saying that the complete code for ENTER is contained in eachand every colon definition! In &#34;high-level&#34; Forth words, theCode Field will contain  a subroutine call, as shown in Figure 2.Colon definitions, for instance, will contain a call to the ENTER routine.</p><p>  我并不是说每个输入的完整代码都包含在每个输入和每个冒号定义！ ＆＃34;高级＆＃34;单词，代码字段将包含子程序调用，如图2所示。例如，冒号定义将包含对Enter例程的调用。</p><p>      (IP) -&gt; W fetch memory pointed by IP into &#34;W&#34; register IP+2 -&gt; IP advance IP (assuming 2-byte addresses) JP (W) jump to the address in the W register</p><p>      （IP） - ＆gt; w获取IP进入＆＃34; W＆＃34;登记 IP + 2  - ＆gt; IP affign ip（假设2字节地址） JP（W）跳转到W寄存器中的地址 </p><p>  This gains speed: the interpreter now performs only a  singleindirection. On the Z80 this reduces the NEXT routine -- the most-usedcode fragment in the Forth kernel -- from eleven instructions to seven!</p><p>这个收益速度：翻译现在只表现为单一间接。在z80上，这减少了下一个例程 - 最常用的例程代码片段在第一个内核 - 从11指令到七！</p><p>  This costs space: every high-level definition in a Z80 Forth (for example)is now one byte longer, since a 2-byte address has been replaced by a 3-bytecall. But  this is not universally true. A 32-bit 68000 Forth mayreplace a 4-byte address with a 4-byte BSR instruction, for no net loss.And on the Zilog Super8, which has machine instructions for DTC Forth,the 2-byte address is replaced by a 1-byte ENTER instruction, making aDTC Forth  smaller on the Super8!</p><p>  这个成本空间：Z80中的每个高级定义（例如）现在是一个字节更长的，因为2字节地址已被3字节替换称呼。但这不是普遍的真实。可以是32位68000秒用4字节BSR指令替换4字节地址，无净损耗。在Zilog Super8上，它具有DTC的机器指令，2字节地址由1字节输入指令替换，制作一个字节DTC在Super8上较小！</p><p>  Of course, DTC CODE definitions are two bytes shorter, since they nolonger need a pointer at all!</p><p>  当然，DTC代码定义是两个字节较短，因为它们没有一直需要一个指针！</p><p>  I used to think that high-level definitions in DTC Forths required theuse of a subroutine call in the Code Field. Frank Sergeant&#39;s Pygmy Forth[SER90] demonstrates that a simple jump can be used just as easily, andwill usually be faster.</p><p>  我曾经认为DTC索斯中的高级定义需要在代码字段中使用子程序调用。 Frank Sergeant＆＃39; S Pygmy Forth[SER90]展示了简单的跳跃可以容易地使用通常会更快。</p><p>  Guy Kelly has compiled a superb review of Forth implementations forthe IBM PC [KEL92], which I strongly recommend to  all Forth kernelwriters. Of the 19 Forths he studied, 10 used DTC, 7 used ITC, and 2 usedsubroutine threading (discussed next).  I recommend the use of Direct-ThreadedCode over Indirect-Threaded Code for all new Forth kernels.</p><p>  Guy Kelly已经编制了一个卓越的审查，以实现IBM PC [KEL92]，我强烈推荐全部内核作家。在他学习的19个鼻胎中，10次使用的DTC，7用ITC，2使用子程序线程（接下来讨论）。我建议使用直接线程代码全新内核的间接线程代码。</p><p>    The Forth inner interpreter, NEXT, is a common routine to all CODE definitions.You might keep just one copy of this common routine, and have all CODEwords jump to it. (Note that you Jump to NEXT; a subroutine Call is notnecessary.)</p><p>    Next Inner Interpreter，接下来，是所有代码定义的常用例程。您可能只保留一个常见例程的一份副本，并拥有所有代码单词跳到它。 （请注意，您跳转到下一个;子程序呼叫不是必要的。）</p><p>  However, the speed of NEXT is crucial to the speed of the entire Forthsystem. Also, on many CPUs, the NEXT routine is quite short; often onlytwo or three instructions. So it may be preferable to code NEXT in-line,wherever it is used. This is frequently done by making NEXT an assemblermacro.</p><p>  然而，接下来的速度对整个右的速度至关重要系统。此外，在许多CPU上，下一个例程很短;常有两三个指示。因此，可以更优选地在线编码，无论使用它。这通常是通过使汇编程序进行下一个汇编程序来完成宏。 </p><p>  This is a simple speed vs. space decision: in-line NEXT is always faster,but almost always larger. The total size increase is the number of extrabytes required for in-line expansion, times the number of CODE words inthe system. Sometimes there&#39;s no tradeoff at all: in a 6809 DTC Forth,an in-line NEXT is  shorter than a Jump instruction!</p><p>这是一个简单的速度与空间决定：在线下一步总是更快，但几乎总是更大。总尺寸增加是额外数量在线扩展所需的字节，代码单词的数量系统。有时候＆＃39;＆＃39;否则没有权衡：在6809 dtc，在线接下来比跳跃指令短！</p><p>    A high-level Forth definition is nothing but a list of subroutines tobe executed. You don&#39;t need interpreters to accomplish this; you can getthe same effect by simply stringing a list of subroutine calls together:</p><p>    高级别的定义只不过是子程序列表被执行。你不需要口译员来完成这一点;你可以得到通过简单地串入子程序调用的列表在一起来实现相同的效果：</p><p>    See Figure 3. This representation of Forth words has been used as astarting point to explain Forth threading techniques to assembly languageprogrammers [KOG82].</p><p>    请参见图3.此表示的表示已被用作起点以向汇编语言解释线程技术程序员[Kog82]。</p><p>    STC is an elegant representation; colon definitions and CODE words arenow identical. &#34;Defined words&#34; (VARIABLEs, CONSTANTs, and thelike) are handled the same as in DTC -- the Code Field begins with a jumpor call to some machine code elsewhere.</p><p>    STC是优雅的代表;冒号定义和代码词是现在相同。 ＆＃34;定义的单词＆＃34; （变量，常数和喜欢）处理与DTC中的相同 - 代码字段以跳转开始或致电其他地方的机器代码。</p><p>  The major disadvantage is that subroutine calls are usually larger thansimple addresses. On the Z80, for example, the size of colon definitionsincreases by 50% -- and most of your application is colon definitions!Contrariwise, on a 32-bit 68000 there may be no size increase at all, when4-byte addresses are replaced with 4-byte BSRs. (But if your code sizeexceeds 64K, some of those addresses must be replaced with 6-byte JSRs.)</p><p>  主要缺点是子程序呼叫通常大于简单的地址。例如，在Z80上，冒号定义的大小增加50％ - 您的大部分申请是结肠定义！相反，在32位68000上，可能没有尺寸增加，何时4字节地址用4字节BSR替换。 （但如果您的代码大小超过64K，其中一些地址必须用6字节JSR替换。）</p><p>  Subroutine threading  may be faster than direct threading. Yousave time by not having an interpreter, but you lose time because  everyreference to a Forth word involves a push and pop of a return address.In a DTC Forth, only high-level words cause activity on the return stack.On the 6809 or Zilog Super8, DTC is faster than STC.</p><p>  子程序线程可能比直接线程更快。你通过没有翻译，但你会省时间，但你失去了时间参考题词涉及返回地址的推送和流行。在DTC中，只有高级单词导致返回堆栈的活动。在6809或Zilog Super8上，DTC比STC快。</p><p>  There is another advantage to STC: it dispenses with the IP register.Some processors -- like the 8051 -- are desperately short of addressingregisters. Eliminating the IP can really simplify and speed up the kernel!</p><p>  STC还有另一个优势：它可以使用IP寄存器分配。一些处理器 - 就像8051  - 拼命地缺乏寻址寄存器。消除IP可以真正简化和加速内核！ </p><p>  The only way to know for sure is to write sample code. This isintimately involved with register selection, discussed in the next section.</p><p>知道的唯一方法是编写示例代码。这是密切参与注册选择，在下一节中讨论。</p><p>    On older and 8-bit CPUs, almost every Forth primitive involves severalmachine instructions. But on more powerful CPUs, many Forth primitivesare written in a single instruction. For example, on the 32-bit 68000,DROP is simply</p><p>    在较旧的和8位CPU上，几乎每个迫征原语都涉及几个机器指令。但是在更强大的CPU，许多迫切的原语用单一的指令写。例如，在32位68000上，下降就是简单的</p><p>    In a subroutine-threaded Forth, using DROP in a colon definition wouldresult in the sequence</p><p>    在子程序中，在冒号定义中使用下降导致序列</p><p>    ADDQ is a two-byte instruction. Why write a four-byte subroutine callto a two-byte instruction? No matter how many times DROP is used, there&#39;sno savings! The code is smaller and faster if the ADDQ is coded directlyinto the stream of BSRs. Some Forth compilers do this &#34;in-line expansion&#34;of CODE words [CUR93a].</p><p>    AddQ是一个双字节指令。为什么写一个四字节的子程序调用到一个双字节指令？无论使用多少次下降，那么都有没有储蓄！如果addq直接编码，则代码较小，更快进入BSR的流。一些第四个编译器做到这一点＆＃34;在线扩展＆＃34;代码词[cur93a]。</p><p>  The disadvantage of in-line expansion is that decompiling back to theoriginal source code becomes very difficult. As long as subroutine callsare used, you still have pointers (the subroutine addresses) to the Forthwords comprising the thread. With pointers to the words, you can obtaintheir names. But once a word is expanded into in-line code, all knowledgeof where that code came from is lost.</p><p>  在线扩展的缺点是重复回复原始源代码变得非常困难。只要子程序调用使用，您仍然有指针（子程序地址）到第四个包括螺纹的单词。用指针到单词，你可以获得他们的名字。但是一旦一个词被扩展到英式编码，所有知识在哪里丢失了那个代码。</p><p>  The advantage of in-line expansion -- aside from speed and size -- isthe potential for code optimization. For example, the Forth sequence</p><p>  一线扩展的优势 - 除了速度和尺寸 - 是代码优化的可能性。例如，第四个序列</p><p>          Optimizing Forth compilers is too broad a topic for this article. Thisis an active area of Forth language research; see, for instance, [SCO89]and [CUR93b]. The final culmination of optimized STC is a Forth which compilesto &#34;pure&#34; machine code, just like a C or Fortran compiler.</p><p>          优化编译器对于本文来说太广泛了。这是一个活跃的领域研究;例如，参见[SCO89]和[cur93b]。优化的STC的最终高潮是第四组成的＆＃34;纯＆＃34;机器代码，就像一个c或fortran编译器。 </p><p>    DTC and STC aim to improve the speed of Forth programs, at some costin memory. Now let&#39;s move the  other direction from ITC, toward somethingslower but smaller.</p><p>DTC和STC的旨在提高速度的速度，以某种成本在记忆中。现在让＆＃39; s从ITC的另一个方向移动，朝向某事较慢但更小。</p><p>  The purpose of a Forth thread is to specify a list of Forth words (subroutines)to be performed. Suppose a 16-bit Forth system only had a maximum of 256different words. Then each word could be uniquely identified by an 8-bitnumber. Instead of a list of 16-bit addresses, you would have a list of8-bit identifiers or &#34;tokens,&#34; and the size of the colon definitionswould be halved!</p><p>  第四个线程的目的是指定一个列表（子例程）要进行。假设16位系统最多只有256个不同的单词。然后每个单词都可以唯一地识别8位数字。您将列出列表而不是16位地址列表8位标识符或＆＃34;令牌，＆＃34;和冒号定义的大小会减半！</p><p>  A token-threaded Forth keeps a table of addresses of all Forth words,as shown in Figure 4. The token value is then used to index into this table,to find the Forth word corresponding to a given token. This  addsone level of indirection to the Forth interpreter, so it is slower thanan &#34;address-threaded&#34; Forth.</p><p>  一个令牌线程，保留了一张地址的字样，如图4所示。然后令牌值用于索引到此表中，找到与给定令牌对应的字。这增加了四个间接的间接级别，所以它比慢于一个＆＃34;地址线程和＃34;向前。</p><p>    The principal advantage of token-threaded Forths is small size. TTCis most commonly seen in handheld computers and other severely size-constrainedapplications. Also, the table of &#34;entry points&#34; into all theForth words can simplify linkage of separately-compiled modules.</p><p>    令牌螺纹的主要优点是小尺寸。 TTC.最常见于掌上电脑和其他严重尺寸约束的应用程序。此外，表格＆＃34;入口点＆＃34;进入所有四个词可以简化单独编译模块的链接。</p><p>  The disadvantage of TTC is speed: TTC makes the slowest Forths. Also,the TTC compiler is slightly more complex. If you need more than 256 Forthwords, it&#39;s necessary to have some open-ended encoding scheme to mix 8-bitand larger tokens.</p><p>  TTC的缺点是速度：TTC使得最慢。还，TTC编译器稍微复杂。如果您需要超过256秒单词，它＆＃39;必须具有一些开放式编码方案来混合8位和较大的令牌。</p><p>  I can envision a 32-bit Forth using 16-bit tokens, but how many 32-bitsystems are size-constrained?</p><p>  我可以使用16位令牌设想32位，但是有多少32位系统是尺寸约束的？</p><p>    Since there are so many 8086 derivatives in the world, segment threadingdeserves a brief mention. Instead of using &#34;normal&#34; byte addresseswithin a 64K segment,  paragraph addresses are used. (A &#34;paragraph&#34;is 16 bytes in the 8086.) Then, the interpreter can load these addressesinto segment registers, instead of into the usual address registers. Thisallows a 16- bit Forth model to efficiently access the full megabyte of8086 memory.</p><p>    由于世界上有这么多8086衍生物，段线程值得简要提及。而不是使用＆＃34;正常＆＃34;字节地址在64K段内，使用段落地址。 （A＆＃34;段落＆＃34;在8086中是16个字节。）然后，解释器可以加载这些地址进入段寄存器，而不是进入通常的地址寄存器。这允许16位模型可以有效地访问完整的兆字节8086内存。 </p><p>  The principal disadvantage of segment threading is the 16-byte &#34;granularity&#34;of the memory space. Every Forth word must be aligned to a 16-byte boundary.If Forth words have random lengths, an average of 8 bytes will be wastedper Forth word.</p><p>段线程的主要缺点是16字节＆＃34;粒度＆＃34;记忆空间。每一个字必须与16字节的边界对齐。如果该词具有随机长度，则将浪费平均8个字节过了一词。</p><p>    Next to the threading technique, the usage of the CPU&#39;s registers isthe most crucial design decision. It&#39;s probably the most difficult. Theavailability of CPU registers can determine what threading technique canbe used, and even what the memory map will be!</p><p>    在线程技术旁边，CPU＆＃39;寄存器的使用是最重要的设计决定。它可能是最困难的＆＃39。这CPU寄存器的可用性可以确定哪种线程技术可以使用，甚至存储器地图将是什么！</p><p>    The classical Forth model has five &#34;virtual registers.&#34; Theseare abstract entities which are used in the primitive operations of Forth.NEXT, ENTER, and EXIT were defined earlier in terms of these abstract registers.</p><p>    经典的模型有五个＆＃34;虚拟寄存器。＆＃34;这些是在原始操作中使用的抽象实体。接下来，在这些抽象寄存器方面先定义了输入和退出。</p><p>  Each of these is one cell wide -- i.e., in a 16-bit Forth, these are16-bit registers. (There are exceptions to this rule, as you will see later.)These  may not all be CPU registers. If your CPU doesn&#39;t have enoughregisters, some of these can be kept in memory. I&#39;ll describe them in theorder of their importance; i.e., the bottom of this list are the best candidatesto be stored in memory.</p><p>  这些中的每一个都是一个细胞宽 - 即，在16位，这些是16位寄存器。 （此规则存在异常，正如您稍后会看到的那样。）这些可能并非全部都是CPU寄存器。如果您的CPU没有足够的＆＃39;寄存器，其中一些可以保存在内存中。我＆＃39; ll描述它们他们重要的顺序;即，此列表的底部是最好的候选人存储在内存中。</p><p>  W is the Working register. It is used for many things, includingmemory reference, so it should be an address register; i.e., you must beable to fetch and store memory using the contents of W as the address.You also need to be able to do arithmetic on W. (In DTC Forths, you mustalso be able to jump indirect using W.) W is used by the interpreter  inevery Forth word. In a CPU having only one register, you would useit for W and keep everything else in memory (and the system would be incrediblyslow).</p><p>  w是工作登记册。它用于许多东西，包括内存参考，所以它应该是地址寄存器;即，你必须是能够使用W作为地址的内容来获取和存储内存。您还需要能够在W算术上进行算术。（在DTC中，您必须也能够使用w跳跃间接。）w被解释器使用每一个词。在一个只有一个寄存器的CPU中，您将使用它是w，并在内存中保留其他一切（并且系统将是令人难以置信的慢的）。</p><p>  IP is the Interpreter Pointer. This is used by  every Forthword (through NEXT, ENTER, or EXIT). IP must be an address register.You also need to be able to increment IP. Subroutine threaded Forths don&#39;tneed this register.</p><p>  IP是解释器指针。这是通过电流使用的Word（通过下一个，输入或退出）。 IP必须是地址寄存器。您还需要能够递增IP。子程序穿过右侧＆＃39; t需要这个寄存器。</p><p>  PSP is the Parameter Stack (or &#34;data stack&#34;) Pointer,sometimes called simply SP. I prefer PSP because SP is frequently the nameof a CPU register, and they shouldn&#39;t be confused. Most CODE words usethis. PSP must be a stack pointer, or an address register which can beincremented and decremented. It&#39;s also a plus if you can do indexed addressingfrom PSP.</p><p>  PSP是参数堆栈（或＆＃34;数据堆栈＆＃34;）指针，有时被称为sp。我更喜欢PSP，因为SP经常是名称CPU寄存器，他们应该困惑。大多数代码单词使用这。 PSP必须是堆栈指针，或可以是的地址寄存器递增和递减。它也是一个加号，如果你可以做索引的寻址来自PSP。 </p><p>  RSP is the Return Stack Pointer, sometimes called simply RP.This is used by colon definitions in ITC and DTC Forths, and by  allwords in STC Forths. RSP must be a stack pointer, or an address registerwhich can be incremented and decremented.</p><p>RSP是返回堆栈指针，有时叫做RP。这是由ITC和DTC的冒号定义使用，并通过所有在STC中的单词。 RSP必须是堆栈指针或地址寄存器可以递增和递减。</p><p>  If  at all possible, put W, IP, PSP, and RSP in registers. Thevirtual registers that follow can be kept in memory, but there is usuallya speed advantage to keeping them in CPU registers.</p><p>  如果可能，请在寄存器中放置W，IP，PSP和RSP。这遵循的虚拟寄存器可以保存在内存中，但通常有将它们保持在CPU寄存器中的速度优势。</p><p>  X is a working register,  not considered one of the &#34;classical&#34;Forth registers, even though the classical ITC Forths need it for the secondindirection. In ITC you must be able to jump indirect using X. X may alsobe used by a few CODE words to do arithmetic and such. This is particularlyimportant on processors that cannot use memory as an operand. For example,ADD on a Z80 might be (in pseudo-code)</p><p>  X是一个工作寄存器，不被视为＆＃34;古典＆＃34;即使经典的ITC第四个需要它，即使是第二个间接。在ITC中，您必须能够使用x跳跃间接。x也可以通过几个代码单词使用来执行算术。这是特别的对无法使用内存作为操作数的处理器很重要。例如，添加z80可能是（在伪代码中）</p><p>      UP is the User Pointer, holding the base address of the task&#39;suser area. UP is usually added to an offset, and used by high-level Forthcode, so it can be just stored somewhere. But if the CPU can do indexedaddressing from the UP register, CODE words can more easily and quicklyaccess user variables. If you have a surplus of address registers, useone for UP. Single-task Forths don&#39;t need UP.</p><p>      UP是用户指针，持有任务的基础地址＆＃39; s用户区域。 UP通常被添加到偏移量，并由高级别使用代码，所以它可以刚刚存储在某处。但如果CPU可以索引从向上寄存器寻址，代码词可以更容易且快速访问用户变量。如果您有剩余的地址寄存器，请使用一个人。单项任务第四次不需要＆＃39;</p><p>  X -- if needed -- is more important to keep in register than UP. UPis the easiest of the Forth virtual registers to move into memory.</p><p>  X  - 如果需要 - 更重要的是保持登记。向上是第四个虚拟寄存器中最容易进入内存的寄存器。</p><p>    Most CPUs have a stack pointer as part of their hardware, used by interruptsand subroutine calls. How does this map into the Forth registers? Shouldit be the PSP or the RSP?</p><p>    大多数CPU都有一个堆栈指针作为其硬件的一部分，由中断使用和子程序调用。该地图如何进入Forth寄存器？应该这是PSP还是RSP？</p><p>  The short answer is,  it depends. It is said that the PSP is usedmore than the RSP in ITC and DTC Forths. If your CPU has few</p><p>  短暂的答案是，它取决于。据说使用了PSP超过ITC和DTC的RSP。如果您的CPU很少 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.bradrodriguez.com/papers/moving1.htm">https://www.bradrodriguez.com/papers/moving1.htm</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/提出/">#提出</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/moving/">#moving</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>