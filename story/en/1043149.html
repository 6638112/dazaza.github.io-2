<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么选择Clojure？ （2018） Why Clojure? (2018)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why Clojure? (2018)<br/>为什么选择Clojure？ （2018） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-04 20:45:58</div><div class="page_narrow text-break page_content"><p>Why not the programming language I&#39;m already using or some other language? What makes Clojure uniquely well suited for modern software development?</p><p>为什么不使用我已经在使用的编程语言或其他某种语言？是什么使Clojure特别适合现代软件开发？</p><p> Most &#34;features&#34; from other languages can be added as extensions via macros or in terms of the language itself. Polymorphism, &#34;types&#34;, inheritance, pattern matching, &#34;go channels&#34;</p><p> 大部分功能可以通过宏或语言本身将其他语言的扩展名添加为扩展名。多态性，类型，继承，模式匹配和转到通道</p><p>    Excellent concurrency support: immutability, software transactional memory, &#34;Go Channels&#34; (CSP), agents, everything in the JVM/Java</p><p>    出色的并发支持：不变性，软件事务内存，＆＃34; Go Channels＆＃34; （CSP），代理，JVM / Java中的所有内容</p><p>  Instead of mutating objects, Clojure encourages you to use immutable data structures. In many languages you create a mutable array object and append to it.</p><p>  Clojure鼓励您使用不可变的数据结构，而不是对对象进行突变。在许多语言中，您都会创建一个可变数组对象并将其追加。</p><p>    In Clojure, whenever you &#34;append&#34; to a vector (array) you get a &#34;new&#34; vector and the original does not change. Anyone with a reference to the original can always count on it being the same.</p><p>    在Clojure中，每当您添加＆＃34;到向量（数组），您将得到一个＆＃34; new＆＃34;向量和原件不变。凡提及原件的人都可以始终指望原件相同。</p><p>           This encourages us to use compositions of functions instead of functions that mutate objects. The benefit of this might not be immediately obvious, but this shift encourages writing programs in a way that&#39;s simpler. Programs made up of small reusable components are easier to change later. We just need to focus on the scope of the function, the inputs, and the outputs. We don&#39;t need to worry about prior state.</p><p>           这鼓励我们使用函数的组合，而不是使用变异对象的函数。这样做的好处可能不会立即显现出来，但是这种转变鼓励以更简单的方式编写程序。由小型可重用组件组成的程序以后更易于更改。我们只需要关注函数，输入和输出的范围。我们无需担心先前的状态。</p><p>  The first thing you will notice in Clojure is how many parens there are and how dense the code is. It takes some getting used to, but the parens have a lot of benefits.</p><p>  在Clojure中，您会注意到的第一件事是有多少个paren和代码有多密集。这需要一些时间来适应，但是parens有很多好处。 </p><p> We can always rewrite syntax repetition with macros and there are plenty of techniques for reducing the number of parens including &#34;threading&#34; operators like  -&gt;&gt;. The following is equivalent to the header.</p><p>我们总是可以用宏重写语法重复，并且有很多减少paren数量的技术，包括＆＃34; threading＆＃34; ->＆gt;等运算符。以下等同于标题。</p><p>  Function calls are different in Clojure than most languages. It is represented by a list where the first element is the function and the rest are the arguments to that function.</p><p>  Clojure中的函数调用与大多数语言不同。它由一个列表表示，其中第一个元素是函数，其余元素是该函数的参数。</p><p>    Since all functions including built in functions are called the same way, it&#39;s easy to swap any function out with another, including built-ins.</p><p>    由于包括内置函数在内的所有函数都以相同的方式调用，因此可以轻松地将任何函数与另一个函数（包括内置函数）交换出去。</p><p>   function  myFunction ( arg1 , arg2 )  {   if  (arg1 )  {   return arg1 ;   }  else  {   return arg2 ;   }  }</p><p>   函数myFunction（arg1，arg2）{if（arg1）{return arg1; } else {return arg2; }}</p><p>   Go has support for asynchronous &#34;go channels&#34; due to special syntax baked into the language. Clojure added the same features and syntax as a third party library. In Javascript you have to wait for syntax to be adopted or use a transpiler but in Clojure it could by implemented by anyone as a library.</p><p>   Go支持异步＆＃34; go频道＆＃34 ;；由于语言中包含特殊语法。 Clojure添加了与第三方库相同的功能和语法。在Javascript中，您必须等待语法被采用或使用翻译器，但在Clojure中，任何人都可以将其实现为库。</p><p>    Clojure is really good at extracting data from maps and sequences. It is a really good for &#34;data programs&#34;, that are mostly calling an API, transforming a sequence, and calling another API.</p><p>    Clojure确实擅长从图谱和序列中提取数据。这对于＆＃34;数据程序＆＃34;来说真的很不错，因为它们通常调用一个API，转换一个序列并调用另一个API。</p><p>  ( def large-list &#39; ( 1  2  3  4  5  6  7  8  9  10 ) )  ( let  [ [ a  b  c ] large-list ]   ( str  a  b  c ) )</p><p>  （def large-list＆＃39;（1 2 3 4 5 6 7 8 9 10））（让[[a b c] large-list]（str a b c）） </p><p>  ( defn configure  [ val options ]  ( let  [ { :keys  [debug verbose ]   :or  {debug  false , verbose  false } } options ]  ( str  &#34;val=&#34;  val  &#34; debug=&#34;debug  &#34; verbose=&#34;verbose ) ) )   (configure  &#34;foo!&#34;  { :debug  true } )</p><p>（defn configure [val options]（让[{：keys [debug verbose]：or {debug false，verbose false}} options]（str＆＃34; val =＆＃34; val＆＃34; debug =＆＃ 34; debug＆＃34; verbose =＆＃34; verbose））））（配置＆＃34; foo！＆＃34; {：debug true}）</p><p>  Having a fast feedback loop is crucial to be productive. When I first started programming I would write some code, compile, then manually test my changes, maybe with a debugger. Then I discovered TDD with an auto test runner, which gave me a faster feedback loop, since I could be reasonably confident my program worked without having to recompile for every change. The fastest feedback loop I&#39;ve discovered so far is the Clojure REPL with editor integration. With Emacs and CIDER I can execute code in my editor as I write it. Having a fast feedback loop for exploratory coding before writing tests helps me be a lot more productive and write higher quality code. Other languages also have REPLs but I feel Clojure is uniquely well suited to this workflow because of its immutable functional nature.</p><p>  快速反馈循环对于提高生产力至关重要。刚开始编程时，我会编写一些代码，进行编译，然后手动测试更改（也许使用调试器）。然后，我通过自动测试运行程序发现了TDD，这给了我一个更快的反馈循环，因为我可以确信我的程序可以工作，而不必为每次更改都重新编译。到目前为止，我发现的最快的反馈循环是具有编辑器集成功能的Clojure REPL。使用Emacs和CIDER，我可以在编写代码时在编辑器中执行代码。在编写测试之前拥有用于探索性编码的快速反馈循环有助于我提高工作效率并编写更高质量的代码。其他语言也具有REPL，但是我认为Clojure具有不可更改的功能，因此非常适合此工作流程。</p><p>  Testing is simpler when most things are maps and pure functions. This is an example from the &#34;Gilded Rose Kata&#34;.</p><p>  当大多数事物都是映射和纯函数时，测试会更简单。这是来自'Gilded Rose Kata'的示例。</p><p> @Test  public  void    qualityControl  =  new   ( ) ;    shouldNeverIncreaseQualityToMoreThanFifty ( )  {   backstagePass  =  anItem ( )   . withName (BACKSTAGE_PASS_ITEM_NAME )   . build ( )  backstagePass . setSellIn (FIVE_DAYS ) ;  backstagePass . setQuality ( 50 ) ;   qualityControl . updateQualityFor (backstagePass ) ;    assertThat (backstagePass . getQuality ( ) ,  is ( 50 ) ) ;   }</p><p> @Test公共无效qualityControl = new（）;应该从不增加质量到更多的（）{backstagePass = anItem（）。 withName（BACKSTAGE_PASS_ITEM_NAME）。 build（）backstagePass。 setSellIn（FIVE_DAYS）; backstagePass。 setQuality（50）;质量控制。 updateQualityFor（backstagePass）; assertThat（backstagePass。getQuality（），是（50））; }</p><p> ( def max-quality-pass   { :quality  50   :sell-in  5 } )    (deftest test-backstage-pass-peak   (testing  &#34;Quality never goes over 50&#34;   (is  ( =  50  ( :quality  (i/update-item max-quality-pass ) ) ) ) ) )</p><p> （def max-quality-pass {：quality 50：sell-in 5}）（deftest test-backstage-pass-peak（testing＆＃34; Quality never not over 50＆＃34;（is（= 50（：quality（我/更新项目最大质量通过））））））</p><p>  Clojure has good interop with the worlds most popular languages. You can tap into the Java ecosystem for foundational libraries like the AWS SDK or database clients. Clojurescript has an excellent wrapper around React called Reagent. You can write your entire stack in Clojure, meaning a single person can be extremely productive. The interop story isn&#39;t perfect though: although it works technically, the difference between the programming models does have some friction. This can usually be solved by writing a wrapper.</p><p>  Clojure与世界上最流行的语言有很好的互操作性。您可以利用Java生态系统来获取诸如AWS开发工具包或数据库客户端之类的基础库。 Clojurescript在React周围有一个很好的包装，称为Reagent。您可以用Clojure编写整个堆栈，这意味着一个人可以非常高效。互操作的故事虽然不是很完美：尽管从技术上讲它是可行的，但是编程模型之间的差异确实存在一些摩擦。这通常可以通过编写包装器来解决。</p><p>   Now that Moore&#39;s Law is ending, we can&#39;t rely on speed increases of a single core anymore. We need to write code that can take advantage of multiple cores and that can correctly run in parallel. I don&#39;t feel good about using some languages like Python or Javascript that are single inherently single threaded. Languages like Java or C++, which weren&#39;t designed with concurrency in mind are hard to use correctly. Clojure&#39;s data structures are thread safe by default and it has numerous concurrency primitives. The language design de-emphasis the us of state and emphasizes the use of values instead.</p><p>   既然摩尔定律即将结束，我们就不能再依靠单个内核的速度提高了。我们需要编写可以利用多个内核并且可以正确并行运行的代码。我对使用某些语言（例如Python或Javascript）本质上是单线程的感觉不好。诸如Java或C ++之类的语言在设计时并没有考虑到并发性，因此很难正确使用。 Clojure的数据结构默认情况下是线程安全的，并且具有许多并发原语。语言设计不再强调状态的使用，而是强调使用值。 </p><p>  I initially disliked clojure coming from my semi strongly typed Java and C++. If you use types you have to consider their downsides and the cost of the coupling introduced by type information flowing through your program. After using Clojure, I find things like the &#34;builder pattern&#34; contrived. There is usually only a few types of true &#34;data&#34; and the rest of the program are subsets and combinations of the data, which don&#39;t always deserve an explicit name or type. I feel using languages that encourage classes encourages you to make abstractions too early, and making the wrong abstraction is much worse than repetition. A lot of the &#34;bugs&#34; you catch at compile time are often self inflicted bookeeping mistakes due to the increased complexity. I think testing is a much stronger form of software validation and will catch the errors that types would have.</p><p>我最初不喜欢来自半强类型Java和C ++的clojure。如果使用类型，则必须考虑它们的缺点以及由流经程序的类型信息引入的耦合成本。使用Clojure之后，我发现类似＆＃34; builder模式＆＃34;人为的。通常只有少数几种真实的＆＃34; data＆＃34;程序的其余部分是数据的子集和组合，它们并不总是应使用明确的名称或类型。我觉得使用鼓励类的语言会鼓励您过早地进行抽象，而错误地进行抽象比重复要糟糕得多。很多＆＃34; bug＆＃34;由于复杂性的增加，您在编译时发现的错误常常是自欺欺人的错误。我认为测试是一种更强大的软件验证形式，它将捕获类型可能存在的错误。</p><p>  The design choices and tradeoffs in Clojure were made deliberately. There are much fewer sharp edges and historical accidents in Clojure than any other language I&#39;ve used. Clojure is opinionated on the way you write software but if you buy into that opinion, using pure functions and immutable data structures, the experience is very streamlined.</p><p>  在Clojure中进行了设计选择和折衷。与我使用的任何其他语言相比，Clojure中的锋利边缘和历史事故要少得多。 Clojure对编写软件的方式持坚定态度，但如果您采纳这种观点，则使用纯函数和不可变的数据结构，将使体验大大简化。</p><p> I remember having to learn the difference between comparing primitives and objects in Java. Code like this feels unintuitive.</p><p> 我记得我必须学习比较Java中的原语和对象之间的区别。这样的代码感觉很不直观。</p><p>  a  =  new   ( 1 ) ;   b  =  new   ( 1 ) ;   if  (a  == b ) {    .out . println ( &#34;True&#34; )  }  else  {    .out . println ( &#34;False&#34; )  }   if  (a . equals (b ) ) {    .out . println ( &#34;True&#34; )  }  else  {    .out . println ( &#34;False&#34; )  }</p><p>  一个=新（1）; b =新（1）;如果（a == b）{.out。 println（＆＃34; True＆＃34;）}其他{.out。 println（＆＃34; False＆＃34;）}如果（a。等于（b））{.out。 println（＆＃34; True＆＃34;）}其他{.out。 println（＆＃34; False＆＃34;）}</p><p> Comparing object equality is almost never what I want to do and I don&#39;t think it&#39;s a good default behavior.</p><p> 比较对象相等性几乎从来不是我想要做的，而且我不认为这是一种很好的默认行为。</p><p>  This does what I expect, and I don&#39;t need to know the difference between  =,  equals,  ==,  ===,  deepEqual, and  deepStrictEqual.</p><p>  这确实符合我的期望，并且我不需要知道=，等于，==，===，deepEqual和deepStrictEqual之间的区别。</p><p>  There is only  = for structural equality and no assignment operator. The only  false value is  nil and everything else is  true.</p><p>  对于结构相等，只有=，没有赋值运算符。唯一的假值是nil，其他所有值都是真。 </p><p>  Clojure is described as having &#34;polymorphism a la carte&#34;, which means it has the benefits of inheritance and interface without being forced to use it and without many of the downsides.</p><p>Clojure被描述为具有“点菜”的多态性，这意味着Clojure具有继承和接口的优点，而不必被迫使用它，也没有很多缺点。</p><p> In Java, we could do something like this to represent a shape that can be extended in other areas of the program.</p><p> 在Java中，我们可以执行类似的操作来表示可以在程序其他区域中扩展的形状。</p><p> abstract  class    {   public  double  area ( )  {   return  0 ;   }  }   class    extends    {   protected  int width , height ;    public   ( int width ,  int height )  {   this .width  = width ;  this .height  = height ;   }    public  double  area ( )  {   return width  * height ;   }  }   class    extends    {   protected  int a , b , c ;    public   ( int a ,  int b ,  int c )  {   this .a  = a ;  this .b  = b ;  this .c  = c ;   }    public  double  area ( )  {   double s  =  (a  + b  + c )  /  2 ;   return   . sqrt (s  *  (s  - a )  *  (s  - b )  *  (s  - c ) ) ;   }  }   class    extends    {   protected  int r ;    public   ( int r )  {   this .r  = r ;   }    public  double  area ( )  {   return   .PI  * r  * r ;   }  }</p><p> 抽象类{public double area（）{返回0; }}类扩展{protected int width，height; public（int width，int height）{this.width = width;这个.height = height; } public double area（）{返回宽度*高度； }}类扩展{protected int a，b，c; public（int a，int b，int c）{此.a = a;这个.b = b;这个.c = c; } public double area（）{double s =（a + b + c）/ 2;归还。 sqrt（s *（s-a）*（s-b）*（s-c）））; }}类扩展{protected int r; public（int r）{此.r = r; } public double area（）{return .PI * r * r; }}</p><p> One downside of this approach is we need to think hard ahead of time about the relationship of our data.</p><p> 这种方法的一个缺点是，我们需要提前认真考虑数据之间的关系。</p><p> In Clojure we can start with the data and add multiple dispatch if or when we need it.</p><p> 在Clojure中，我们可以从数据开始，并在需要时或在需要时添加多个调度。</p><p> ( def triangle  { :shape  :triangle  :point-a  1  :point-b  2  :point-c  3 } )  ( def rect  { :shape  :rect  :width  3  :height  4 } )  ( def circle  { :shape  :circle  :radius  5 } )   ( defmulti area  :shape )   ( defmethod area  :rect  [r ]   ( *  ( :width r )  ( :height r ) ) )   ( defmethod area  :circle  [ c ]   ( * Math/PI  ( *  ( :radius  c )  ( :radius  c ) ) ) )   ( defmethod area  :default  [x ]  :error )   (area circle )</p><p> （def三角{：shape：triangle：point-a 1：point-b 2：point-c 3}）（def rect {：shape：rect：width 3：height 4}）（def circle {：shape：circle：半径5}）（defmulti区域：shape）（defmethod区域：rect [r]（*（：width r）（：height r）））（defmethod区域：circle [c]（* Math / PI（*（：radius c）（：radius c））））（defmethod area：default [x]：error）（区域圆） </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://briansunter.com/blog/why-clojure/">https://briansunter.com/blog/why-clojure/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/选择/">#选择</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/clojure/">#clojure</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>