<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>巴顿-纳克曼trick俩的一个例子 An example of the Barton–Nackman trick</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">An example of the Barton–Nackman trick<br/>巴顿-纳克曼trick俩的一个例子 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-16 14:07:13</div><div class="page_narrow text-break page_content"><p>I still need to write the blog post explaining “What is the Hidden Friend Idiom?”;but for now, here’s a practical demonstration of its usefulness that just came upon the cpplang Slack (thanks, Johan Lundberg!).</p><p>我仍然需要写博客文章来解释“什么是隐藏的朋友成语？”；但是现在，这是cpplang Slack上的实用示例的实际演示（感谢Johan Lundberg！）。</p><p> Consider this pair of class templates  Cat&lt;T&gt; and  Dog&lt;T&gt;.  Cat is analogous tothe STL’s container templates, which define  operator&lt; (or in C++20,  operator&lt;=&gt;)as a free function template.</p><p> 考虑这对类别模板Cat＆lt; T＆gt;。和DogT。 Cat与STL的容器模板类似，后者定义了操作符＆lt; （或在C ++ 20中，operator =）作为自由函数模板。</p><p> template&lt;class V&gt;struct Cat { V value_;};template&lt;class V&gt;bool operator&lt;(const Cat&lt;V&gt;&amp; a, const Cat&lt;V&gt;&amp; b) { return a.value_ &lt; b.value_;}</p><p> template＆lt; class V＆gt; struct Cat {V value_;}; template＆lt; class V＆gt; bool运算符＆lt;（const Cat＆lt; V＆amp; a，const cat＆lt; V＆gt;＆amp; b）{返回a.value_＆lt; b.value_;}</p><p>  template&lt;class V&gt;struct Dog { V value_; friend bool operator&lt;(const Dog&amp; a, const Dog&amp; b) { return a.value_ &lt; b.value_; }};</p><p>  模板＆lt; class V＆gt;结构狗{V value_;朋友布尔运算符＆lt;（const Dog＆amp; a，const Dog＆amp; b）{return a.value_＆lt; b.value_; }};</p><p> Now consider the following “ sort_in_place” algorithm, whichuses  reference_wrapper to sort a vector of  handles pointing intoits const argument vector, instead of sorting the argument vectoritself. (I’ve never found this trick useful in practice, but it’sa very cute demonstration of how the different pieces of the STLfit together. I use basically this code in the  reference_wrapperunit of my  “Classic STL” training course.)</p><p> 现在考虑以下“ sort_in_place”算法，该算法使用reference_wrapper对指向其const参数向量的句柄向量进行排序，而不是对参数vector本身进行排序。 （我从来没有发现此技巧在实践中有用，但是非常可爱地展示了STL的各个部分如何组合在一起。我在“经典STL”培训课程的reference_wrapperunit中基本上使用了此代码。）</p><p> template&lt;class T&gt;void sort_in_place(const std::vector&lt;T&gt;&amp; vt) { std::vector&lt;std::reference_wrapper&lt;const T&gt;&gt; vr(vt.begin(), vt.end()); std::sort(vr.begin(), vr.end()); std::transform(vr.begin(), vr.end(), std::ostream_iterator&lt;int&gt;(std::cout), std::mem_fn(&amp;T::value_));}</p><p> 模板＆lt;类T＆gt;无效sort_in_place（const std :: vector＆lt; t＆gt;＆gt; vt）{std :: vector＆lt; std :: reference_wrapper＆lt; const T＆gt; vr（vt.begin（），vt.end（））; std :: sort（vr.begin（），vr.end（））; std :: transform（vr.begin（），vr.end（），std :: ostream_iterator＆lt; int＆gt;（std :: cout），std :: mem_fn（＆amp; T :: value_））;}</p><p>  We observe that  sort_in_place works nicely for  Dog. Whenever  std::sortneeds to compute  a &lt; b, where  a and  b are  reference_wrapper&lt;Dog&lt;int&gt;&gt;,it uses ADL to find our friend as a candidate, and then confirms that  reference_wrapper&lt;Dog&lt;int&gt;&gt;is indeed implicitly convertible to  const Dog&lt;int&gt;&amp; for both arguments.</p><p>  我们观察到sort_in_place对于Dog来说效果很好。每当std :: sort需要计算＆lt; b，其中a和b是reference_wrapper＆lt; Dog＆lt;＆gt;＆gt;＆gt ;，它使用ADL来找到我们的朋友作为候选者，然后确认reference_wrapper＆lt; Dog＆lt; int＆gt;确实可隐式转换为const Dog＆lt; int＆gt; amp ;对于两个参数。 </p><p> But  sort_in_place fails for  Cat! It still uses ADL to find our  operator&lt;template; but then template argument deduction requires that the provided argument typesexactly match the pattern specified by the template, which is not true in this case —there is no  V such that  Cat&lt;V&gt; is  reference_wrapper&lt;Cat&lt;int&gt;&gt;. Deduction fails.</p><p>但是对Cat来说sort_in_place失败了！它仍然使用ADL查找我们的操作符＆lt; template;。但是，模板自变量推导要求提供的自变量类型与模板指定的模式完全匹配，在这种情况下，这是不正确的-没有V使得Cat＆lt; V＆gt;是reference_wrapper＆lt; Cat＆lt; Cat＆gt; int＆gt;。推论失败。</p><p> We can manually call the proper specialization — the one with  V=int — by writing operator&lt; &lt;int&gt;(vr[0], vr[1]). (The space is important there!)But we can’t write simply  vr[0] &lt; vr[1] because of this poor interaction withtemplate argument deduction.</p><p> 我们可以通过写operator＆lt;来手动调用适当的专业化-V = int的专业化。 ＆lt; int＆gt;（vr [0]，vr [1]）。 （那里的空间很重要！）但是我们不能简单地写vr [0]＆lt; vr [1]因为与模板参数推导的这种不良交互作用。</p><p> So  Dog’s  operator&lt; is better-designed than  Cat’s, at least in this respect.</p><p> 因此，Dog的运算符＆lt;至少在这方面比Cat的设计更好。</p><p>   The  main benefits of the hidden friend idiom are that it avoids member operators’asymmetrical treatment of the left and right operands, and that it shrinks overload setsby not dumping free operators directly into the top-level namespace. This blog postdidn’t relate to either of those benefits.</p><p>   隐藏的朋友习语的主要好处是，它避免了成员运算符对左右操作数的不对称处理，并且通过不将自由运算符直接转储到顶级命名空间中来缩小重载集。此博客与以上任何一项都不相关。</p><p> The use of the hidden friend idiom in cases like  Dog — specifically to create aclass template whose instantiations are associated with  non-template friends —is known as the “Barton–Nackman trick.” This blog post showed one way in whichthe Barton–Nackman trick, specifically, provides a subtle benefit.</p><p> 在像Dog这样的情况下使用隐藏的朋友习惯用法（专门用于创建实例化与非模板朋友相关联的类模板）被称为“巴顿-纳克曼技巧”。这篇博客文章显示了Barton-Nackman技巧的一种方式，特别是提供了微妙的好处。</p><p> Even in C++20, STL containers generally use free templates instead of the Barton–Nackman trick,which means that  sort_in_place will, for example,  work when  vt is  vector&lt;int&gt;but  fail when  vt is  vector&lt;string&gt;. ( Godbolt.)</p><p> 即使在C ++ 20中，STL容器通常也使用免费模板而不是Barton-Nackman技巧，这意味着sort_in_place将在vt为vector 时工作，但在vt为vector 时失败。 （天哪。） </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://quuxplusone.github.io/blog/2020/12/09/barton-nackman-in-practice/">https://quuxplusone.github.io/blog/2020/12/09/barton-nackman-in-practice/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/纳克/">#纳克</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nackman/">#nackman</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/模板/">#模板</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>