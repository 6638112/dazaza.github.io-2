<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Malloc打破了Serenity的JPGLoader，或者：如何赢得彩票 Malloc broke Serenity's JPGLoader, or: how to win the lottery</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Malloc broke Serenity's JPGLoader, or: how to win the lottery<br/>Malloc打破了Serenity的JPGLoader，或者：如何赢得彩票 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-03 23:33:05</div><div class="page_narrow text-break page_content"><p>I got the chance to investigate an interesting bug in SerenityOS this week. It was related to the decodingof JPG images in the operating system. For some reason, when a JPG image isviewed, it comes out like this:</p><p>我有机会在本周调查Serenityos的一个有趣的错误。它与操作系统中的JPG图像解码有关。出于某种原因，当jpg图像浏览时，它会如此：</p><p>  Weird, huh? Also seems like a simple confusion of RGB vs. BGR. And sure enough,making the following change on  JPGLoader.cpp:</p><p>  奇怪，呵呵？似乎是RGB与BGR的简单混淆。并熟悉，在jpgloader.cpp上进行以下更改：</p><p> - const Color color { (u8)block.y[pixel_index], (u8)block.cb[pixel_index], (u8)block.cr[pixel_index] };  + const Color color { (u8)block.cr[pixel_index], (u8)block.cb[pixel_index], (u8)block.y[pixel_index] };  context.bitmap-&gt;set_pixel(x, y, color);</p><p>  -  const颜色{（u8）block.y [pixel_index]，（u8）block.cb [pixel_index]，（u8）block.cr [pixel_index]}; + const颜色{（u8）block.cr [pixel_index]，（u8）block.cb [pixel_index]，（u8）block.y [pixel_index]}; context.bitmap-＆gt; set_pixel（x，y，颜色）;</p><p>   The last non-reverted changeto  JPGLoader.cpp is reported by Git to be over a month ago:</p><p>   Git将在一个月前报告最后一个非恢复的changeto jpgloader.cpp：</p><p>  And I remembered very well that JPG images worked just fine about a week or twoago, as I had set a JPG image as my background and would’ve noticed if it lookedwrong.</p><p>  而且我记得JPG的图像在一周或两只星期内工作得很好，因为我已经将JPG图像设置为我的背景，如果它看起来会注意到。</p><p> Well, time to bisect! I didn’t know when to start, so I picked the last 1000commits (where images showed up correctly), and started bisecting.</p><p> 好吧，时间达成一分！我不知道何时开始，所以我选择了最后1000个组合（其中图像正确地显示了），并开始了Boting。</p><p>  Please skip to the next section if you’d like to avoid C++ whining.</p><p>  如果您想避免C ++抱怨，请跳到下一节。 </p><p> SerenityOS, being an operating system project that focuses on doing its ownthing, also has its own standard library called AK (which stands for Agnostic Kit).This library is analogous toC++’s STL, but is more readable due to not having to support a myriad ofdifferent operating systems and not having to contort oneself to conform to hideous coding standards.</p><p>Serenityos是一个专注于做其所有权的操作系统项目，也有自己的标准库，称为AK（代表不可知论者）。这库是类似的TOC ++的STL，但由于不必支持无数的无数而更具可读性操作系统而不必争论自己符合丑陋的编码标准。</p><p> One of the nice things about having the standard library in the same repositoryas its users is that making changes is very easy as the change propagates toeveryone who pulls from master. However, this is a double edged sword when itcomes to C++; because  everyone includes the standard library (even if youdon’t include it, your includes will), and because C++’s template system meansthat everything that’s templated has to include the definitions in the header aswell, this means that  anytime someone touches AK in a commit, the  entireoperating system has to be rebuilt (~3400 files at the time of writing). ccache, while being useful in many situations, cannot handle this case.Additionally, due to the breakneck pace of the SerenityOS project, someone endsup touching AK at least once every 100 commits or so.</p><p> 有一个关于在相同的存储库中拥有标准库的很好的东西，它的用户是制作变化非常简单，因为更改传播到从主人那里拉动。然而，这是一个双刃剑，当时是C ++;因为每个人都包括标准库（即使您没有包含它，您的包含遗嘱），而且因为C ++的模板系统意味着模板所必须在标题中包含定义的所有内容，这意味着随时有人触摸AAK在提交中，必须重建整个操作系统（写入时〜3400个文件）。 CCache，虽然在许多情况下有用，但不能处理这种情况。由于Serenityos项目的Breakneck节奏，因此每100个提交左右，某人会触摸AK。</p><p> As a result, during the 1000 commits I ended up bisecting for, I had to buildSerenityOS from scratch about 4-5 times on a 2011 laptop with Sandy BridgeMobile. While this isn’t the fault of the project, I’m still mad.</p><p> 因此，在1000个提交期间，我最终开始了，我必须在2011年划痕上从划痕到3-5次与沙质桥接电脑上的4-5次。虽然这不是项目的错，但我仍然很生气。</p><p>  So, after bisecting 1000 commits, rebuilding the OS from scratch several timesand pulling my hair out because I didn’t understand how bisect worked, I finally found the commit that broke JPG images. Drumroll please…</p><p>  所以，在Bisecting 1000的提交后，从头开始重建操作系统，几次拉出我的发发，因为我不明白是如何工作的，我终于找到了破坏JPG图像的提交。 Drumroll请...</p><p> f89e8fb71a4893911ee5125f34bd5bbb99327d33Author: Gunnar BeutnerAuthorDate: Sat May 15 10:06:41 2021 +0200AK+LibC: Implement malloc_good_size() and use it for Vector/HashTableThis implements the macOS API malloc_good_size() which returns thetrue allocation size for a given requested allocation size. Thisallows us to make use of all the available memory in a malloc chunk.For example, for a malloc request of 35 bytes our malloc wouldinternally use a chunk of size 64, however the remaining 29 byteswould be unused.Knowing the true allocation size allows us to request more usablememory that would otherwise be wasted and make that available forVector, HashTable and potentially other callers in the future.</p><p> F89E8FB71A4893911EE5125F34BD5BBB99327D33AUTHOR：GUNNAR BEUTNERAUTHORDATE：5月15日10:06:41 2021 + 0200AK + LIBC：实现Malloc_Good_size（）并将其用于向量/ hashtableThis实现accos api malloc_good_size（）返回给定请求的分配大小的返回thetrue分配大小的macos api malloc_good_size（）。这使我们可以使用Malloc Chunk中的所有可用内存。对于35字节的Malloc请求，我们的Malloc可能是大小64的块，但剩下的29个字节将未使用。固定真正的分配大小允许我们要要求更浪费的USAbleMemory，以浪费并使未来可用的前视，哈希表和可能其他呼叫者。</p><p>    Initial discussion with other developers made me think that either  JPGLoaderor something else up the chain is depending on the capacity of a  Vector andwriting directly into it when it really shouldn’t. So I began hunting downpossible causes.</p><p>    与其他开发人员的初步讨论让我认为JPGLoaderOror expe of the Chain的东西取决于向量和直接进入它时的容量。所以我开始狩猎令人沮丧的原因。</p><p>  The commit seemed to touch the two main container types:  HashTable (which HashMap depends on) and  Vector. Both are used in the  JPGLoader code, andeither could be the cause of the problem here.</p><p>  提交似乎触摸了两个主要的容器类型：Hashtable（哪个HashMap取决于）和向量。两者都用于JPGLoader代码，也可能是这里问题的原因。 </p><p>  new_capacity = max(new_capacity, static_cast&lt;size_t&gt;(4)); - new_capacity = kmalloc_good_size(new_capacity * sizeof(Bucket)) / sizeof(Bucket);  auto* old_buckets = m_buckets;</p><p>new_capacity = max（new_capacity，static_cast＆lt; size_t＆gt;（4））; -  new_capacity = kmalloc_good_size（new_capacity * sizeof（桶））/ sizeof（桶）;自动* old_buckets = m_buckets;</p><p> and rebuilt the system, while joking around in chat about how this can’tpossibly be the problem.</p><p> 并重建系统，同时在聊天时开玩笑，关于这是如何无法解的问题。</p><p>  What? How? Why does the  HashTable capacity being different matter?!  HashTableisn’t even a contiguous stream of data you can write to, so you shouldn’t evenbe able to assume its capacity!</p><p>  什么？如何？为什么哈希表的能力是不同的？！ Hashtableis甚至不是您可以写入的连续数据流，所以你也不应该能够承担其容量！</p><p> Before I present the full story to you, I’ll have give a brief background on how JPGLoader used to work.</p><p> 在我向您展示完整故事之前，我将为JPGLoader如何运作，我会简要介绍一个简短的背景。</p><p>   JPGLoader previously would read information about a JPG component from the“Start of Frame” section of the JPG file into a struct called  Component, andthen store that in a  HashTable. Of course, the order in a JPG file for eachcomponent should always be  Y,  Cb and  Cr, so the  Component struct wouldidiosyncratically carry a  serial_id, which was the position of the  Componentwithin the file. The reason the  Components were in a hash table was that theywould then be checked against the component ordering in a “Start of Scan”section to make sure all the components in the SOS section are in the expectedorder. Why this code was written this way instead of just checking against theID by linearly iterating over the  Components, I have no idea.</p><p>   JPGLoader先前会将JPG组件的信息从JPG文件的“开始”部分中的JPG组件读取为名为Component的结构，并在Hashtable中存储。当然，每款Comonent的JPG文件中的顺序应该始终是y，cb和cr，因此组件结构普通同步携带serial_id，这是文件的位置。组件在哈希表中的原因是它们会在“扫描开始”部分中的组件排序时会检查它们，以确保SOS部分中的所有组件都处于预期的顺序中。为什么通过线性地迭代组件来写入这种代码，而不是刚刚检查Actid，而不是攻击对方，我不知道。</p><p> Anyway, these components would then be iterated over during the differentdecoding stages of  JPGLoader, during which the component information would beused to perform transforms on macroblocks.</p><p> 无论如何，在JPGLoader的不同分段期间，这些组件将在JPGLoader的不同分段期间迭代，在此期间组件信息将被禁用以在宏块上执行变换。</p><p>  When I added some debug prints to see how the components were read, I saw thisin the commit with the broken colors:</p><p>  当我添加了一些调试打印时，看看如何阅读组件，我在your back的comput中看到它： </p><p> ImageDecoder(33:33): Looking at component 0ImageDecoder(33:33): Looking at component 2ImageDecoder(33:33): Looking at component 1ImageDecoder(33:33): Looking at component 0ImageDecoder(33:33): Looking at component 2ImageDecoder(33:33): Looking at component 1...</p><p>imagedecoder（33:33）：查看组件0imagedecoder（33:33）：查看组件2imagedeCoder（33:33）：查看组件1ImagedeCoder（33:33）：查看组件0imagedEcoder（33:33）：查看组件2imagedecoder（33:33）：看成分1 ...</p><p>  ImageDecoder(33:33): Looking at component 0ImageDecoder(33:33): Looking at component 1ImageDecoder(33:33): Looking at component 2ImageDecoder(33:33): Looking at component 0ImageDecoder(33:33): Looking at component 1ImageDecoder(33:33): Looking at component 2...</p><p>  imagedecoder（33:33）：查看组件0imagedeCoder（33:33）：查看组件1ImagedeCoder（33:33）：查看组件2imagedeCoder（33:33）：查看组件0imagedeCoder（33:33）：查看组件1imagedecoder（33:33）：看组件2 ...</p><p> The final piece of the puzzle: During the discussion of this bug with CxByte at my wit’s end, we ended upmanually messing with the order of the components to see what would happen, andgot this message:</p><p> 这个拼图的最后一块：在我的机智结束时用Cxbyte讨论这个错误，我们在营造上搞乱了组件的顺序，以查看会发生什么，Andgot此消息：</p><p>     Someone used a  HashTable to store objects that should be ordered, theniterated over it using the basic  HashTable iterator</p><p>     有人使用哈希特可以存储应订购的对象，然后使用基本的Hashtable迭代器</p><p> The hash of the component IDs in the JPG files were passed into  int_hashfor hash table bucket selection</p><p> JPG文件中的组件ID的哈希传递给INT_HASHFOR哈希表桶选择</p><p> Not only did they get  just the right value to be in order, they gotinserted into a HashTable with  just the right amount of buckets to be inthe correct order</p><p> 他们不仅仅是为了秩序的正确价值，他们只需正确的铲斗就可以了解一个哈希表即可正确的订单</p><p> This caused the Huffman stream to be read in the correct order for eachcomponent, thereby masking the bug</p><p> 这导致霍夫曼流以正确的顺序读取每种群体，从而掩盖错误 </p><p> This bug was masked since  JPGLoader’s inception by sheer luck until someonemessed with the size of the  HashTable</p><p>自从JPGLoader的开始以纯粹的运气直到适合哈希表的大小，因此这个错误被屏蔽</p><p>  And finally, at the end of about 10 hours of debugging,  here is thecommitthat fixed this monster of a bug:</p><p>  最后，在大约10个小时的调试结束时，这里是ThecImmitthat修复了这个错误的这个怪物：</p><p> a10ad24c760bfe713f1493e49dff7da16d14bf39Author: sin-ackAuthorDate: Mon May 31 15:22:04 2021 +0000Commit: Linus GrohCommitDate: Mon May 31 17:26:11 2021 +0100LibGfx: Make JPGLoader iterate components deterministicallyJPGLoader used to store component information in a HashTable, indexedby the ID assigned by the JPEG file. This was fine for most purposes,however after f89e8fb7 this was revealed to be a flawed implementationwhich causes non-deterministic iteration over components.This issue was previously masked by a perfect storm of int_hash beingstable for the integer values 0, 1 and 2; and AK::HashTable having justthe right amount of buckets for the components to be ordered correctlyafter being hashed with int_hash. However, after f89e8fb7,malloc_good_size was used for determining the amount of space forallocation; this caused the ordering of the components to change, andimages started showing up with the red and blue channels reversed. Theissue was finally determined to be inconsistent ordering after randomlychanging the order of the components caused Huffman decoding to fail.This was the result of about 10 hours of hair-pulling and repeatedlydoing full rebuilds due to bisecting between commits that touched AK.Gunnar, I like you, but please don&#39;t make me go through this again. :^)Credits to Andrew Kaster, bgianf, CxByte and Gunnar for the debugginghelp.</p><p> a10ad24c760bfe713f1493e49dff7da16d14bf39author：sin-ackauthordate：mon 5月31日15:22:04 2021 + 0000commit：linus grohcommitdate：5月31日星期一17:26:11 2021 + 0100libgfx：make jpgloader迭代组件确定isticalyjpgloader用于存储哈希表中的组件信息，索引索引的ind由JPEG文件分配。对于大多数目的而言，这很好，但在F89E8FB7之后，这被揭示为缺陷的实现，这导致非确定性迭代在组件上。此问题先前被INT_HASH的完美风暴掩盖了整数0，1和2的完美风暴; AK :: Hashtable拥有正确数量的桶，用于使用INT_HASH散列正确的组件。但是，在F89E8FB7之后，Malloc_Good_size用于确定空间丢弃量;这导致组件的排序变为改变，启动与红色和蓝色通道的逆转开始。在随机调整组件的顺序后，最终被确定为不一致的订单导致霍夫曼解码失败。这是大约10小时的毛发拉动，由于触摸Ak.Gunnar之间的提交之间的Botiting而重复的全面重建。我喜欢你，但请不要让我再次经历这一点。 ：^）对Andrew Kaster，BGIANF，CxByte和Gunnar的信用，为DebuggingHelp。</p><p>  Sometimes the simplest problems might point at big mistakes within. I could’veprobably fixed this by just swapping the order of the arguments right then andthere, and it would’ve worked; until someone else came along and changed theorder again. Thankfully, now we will be able to look at tubas with correctcolors in peace.</p><p>  有时最简单的问题可能会在巨大的错误中指出。我可以通过刚刚交换正确的参数的顺序然后左右，我可以保护这个问题;直到别人来到别人并再次改变了这方面。值得庆幸的是，我们将能够在和平中使用正确的彩色查看守基地。</p><p>   Thanks to CxByte, Gunnar, Andrew and Brian for their help with debugging this,and their helpful tips. Gunnar in particular was the one who uncovered this bug,and despite my satirical jab in the commit message helped uncover this veryinteresting bug, so he’s the one who made this post possible.</p><p>   感谢Cxbyte，Gunnar，Andrew和Brian，为他们的帮助调试，他们的乐于助人的提示。特别是Gunnar尤其是发现这个错误的人，尽管我的讽刺Jab在提交消息中有助于揭示这种非常有趣的错误，所以他是一个可能成为这篇帖子的人。</p><p> Also, thanks to the person who introduced this bug (the commit log gets a littlefuzzy, so I’m not quite sure who did) and hope he buys a lottery ticket. :^)</p><p> 另外，感谢介绍这个错误的人（提交日志得到了一个有点措施，所以我不确定谁做了，希望他能买一张彩票。 ：^）</p><p> And thank you for reading. I’ll probably post sometime in the future, but work’sbeen keeping me busy. But maybe I’ll find another bug to suck me into a rabbithole. Stay tuned!</p><p> 并感谢您的阅读。我可能会在未来的某个时间发布，但工作让我忙碌。但也许我会发现另一个臭虫吸入一个rabbithole。敬请关注！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://sin-ack.github.io/posts/jpg-loader-bork/">https://sin-ack.github.io/posts/jpg-loader-bork/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/打破/">#打破</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/broke/">#broke</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/组件/">#组件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>