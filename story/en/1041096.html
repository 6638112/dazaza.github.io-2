<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>2020年顶级Python库 Top Python Libraries of 2020</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Top Python Libraries of 2020<br/>2020年顶级Python库 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-22 02:58:11</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/bf750f6e62db661d87ddc9a9db68c3ef.png"><img src="http://img2.diglog.com/img/2020/12/bf750f6e62db661d87ddc9a9db68c3ef.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Disclaimer: this year, our picks are heavily influenced by machine learning / data science libraries, although some can indeed be very useful for non-data science people. Moreover, although we have  10 main picks — and a bonus — we decided to add a new  “Honorable mentions” section that does justice to other libraries that we found and couldn’t leave out.</p><p>免责声明：今年，我们的选择在很大程度上受机器学习/数据科学图书馆的影响，尽管其中某些确实对非数据科学人士非常有用。此外，尽管我们有10个主要选择（还有奖金），但我们还是决定增加一个新的“荣誉提及”部分，以便对我们发现但不能遗漏的其他图书馆公道。</p><p> The spirit of this post is to give some visibility to these libraries, as well as generate discussion (in the comments or elsewhere) around some other great picks we may have missed — which we are sure there are.</p><p> 这篇文章的精神是使这些图书馆更具可见性，并围绕我们可能已经错过的其他一些绝佳选择引发讨论（在评论中或其他地方）-我们相信确实存在。</p><p>    You don’t always need to write CLI applications, but it better be a hassle-free experience when you do. Following the great success of  FastAPI,  tiangolo used the same principles to bring us Typer: a new library that enables you to write command line interfaces by leveraging the type hinting feature of Python 3.6+.</p><p>    您不一定总是需要编写CLI应用程序，但这样做时最好是没有麻烦的体验。在FastAPI取得巨大成功之后，tiangolo使用了相同的原理为我们带来了Typer：一个新的库，使您可以利用Python 3.6+的类型提示功能来编写命令行界面。</p><p> The design really makes Typer stand out. Apart from making sure your code is properly documented, you get a CLI interface with validations with minimal effort. And by using type hints, you can get autocompletion in your Python editor (like  VSCode), which will boost your productivity.</p><p> 该设计确实使Typer脱颖而出。除了确保代码已正确记录之外，您还可以轻松进行CLI界面的验证。通过使用类型提示，您可以在Python编辑器（如VSCode）中获得自动补全功能，这将提高您的生产率。</p><p> To power its capabilities, Typer internally stands on top of  Click, which is very well-known and battle-tested. This means that it can leverage all its benefits, community and plugins, while starting simple with less boilerplate code and growing more complex as you need.</p><p> 为了增强其功能，Typer在内部位于Click的顶部，而Click则是众所周知的，并且经过了严格的测试。这意味着它可以利用其所有好处，社区和插件，同时以更少的样板代码开始简单，并根据需要变得越来越复杂。</p><p> As always,  the documentation really shines and should be exemplary for other projects. Definitely, one not to miss!</p><p> 与往常一样，该文档确实很有帮助，并且应该成为其他项目的典范。绝对不能错过！</p><p>  Following with CLI’s topic, who said terminal applications have to be monochromatic white, or green if you’re a real hacker, on black?</p><p>  遵循CLI的主题，谁说终端应用程序必须是单色白色，或者如果您是真正的黑客，则必须是绿色，是黑色？ </p><p> Do you want to add color and style to your terminal output? Print complex tables in a heartbeat? Effortlessly display beautiful progress bars? Markdown? Emojis?  Rich checks all the boxes. Look at the sample screenshot for a glimpse of what’s possible:</p><p>是否要在终端输出中添加颜色和样式？脉动地打印复杂表？毫不费力地显示漂亮的进度条？降价？表情符号？ Rich检查所有框。查看示例屏幕快照，以了解可能的情况：</p><p>  Definitely a library that elevates the experience of using a terminal application to a whole new level.</p><p>  绝对可以将使用终端应用程序的体验提升到全新水平的库。</p><p>  Although, as we’ve seen, terminal applications can be beautiful, sometimes it’s not enough and you need a real GUI. For this comes Dear PyGui, the Python port of the popular  Dear ImGui C++ project.</p><p>  尽管如我们所见，终端应用程序可以很漂亮，但有时还不够，您需要一个真正的GUI。为此，流行的Dear ImGui C ++项目的Python端口Dear PyGui。</p><p> Dear PyGui utilizes what’s called the  immediate mode paradigm, popularized in video games. This basically means the dynamic GUI is drawn frame by frame independently, without the need to persist any data. This makes this tool fundamentally different than other Python GUI frameworks. It’s highly performant, and  uses your computer’s GPU to facilitate the construction of highly dynamic interfaces, as is often needed in engineering, simulations, games or data science applications.</p><p> 尊敬的PyGui利用了在视频游戏中广为流行的即时模式范例。这基本上意味着动态GUI是逐帧独立绘制的，无需保留任何数据。这使得该工具与其他Python GUI框架根本不同。它具有很高的性能，并使用计算机的GPU来构建高度动态的界面，这在工程，仿真，游戏或数据科学应用程序中经常需要。</p><p>  Dear PyGui can be used without a steep learning curve, and runs on Windows 10 (DirectX 11), Linux (OpenGL 3) and MacOS (Metal).</p><p>  亲爱的PyGui可以在没有陡峭的学习曲线的情况下使用，并且可以在Windows 10（DirectX 11），Linux（OpenGL 3）和MacOS（Metal）上运行。</p><p>  The joy of simplicity. This is one of the libraries that make you think: how is it that nobody thought about this before?</p><p>  简单的喜悦。这是让您思考的库之一：以前没人想过这是怎么回事？</p><p> PrettyErrors does only one thing and does it well. In terminals that support colored output, it transforms the cryptic stack traces into something that is much better suited for parsing with our puny human eyes. No more scanning the entire screen to find the culprit of your exception… You can now find it at a glance!</p><p> PrettyErrors只做一件事并且做得很好。在支持彩色输出的终端中，它将隐秘的堆栈轨迹转换成更适合用微弱的人眼解析的东西。无需再扫描整个屏幕来查找异常的原因……您现在就可以一目了然！ </p><p>   We programmers like to solve problems and code. But sometimes, we need to explain intricate architectural designs to other colleagues as part of the very much needed project documentation. Traditionally, we have resorted to GUI tools where we can work on diagrams and visualizations to put in presentations and documents. But it’s not the only way.</p><p>我们程序员喜欢解决问题和代码。但是有时，我们需要向其他同事解释复杂的建筑设计，这是非常需要的项目文档的一部分。传统上，我们使用GUI工具，在其中我们可以处理图表和可视化以放入演示文稿和文档。但这不是唯一的方法。</p><p> Diagrams lets you draw the cloud system architecture without any design tools,  directly in Python code. It has icons that will come in handy for several cloud providers, including AWS, Azure, GCP. It makes it dreadfully easy to create arrows and groups. Really, it’s only a few lines of code!</p><p> Diagrams使您无需任何设计工具即可直接在Python代码中绘制云系统架构。它具有的图标对于多个云提供商（包括AWS，Azure，GCP）将派上用场。这使创建箭头和组非常容易。真的，只有几行代码！</p><p>  The best thing of code-based diagrams? You get the ability to  track changes with version control via your standard git! Developers will be happy.</p><p>  基于代码的图表的最好之处是什么？您可以通过标准git使用版本控制来跟踪更改！开发人员会很高兴。</p><p>  When doing research and experimentation on machine learning projects, there’s always a myriad of settings to try out. In non-trivial applications, configuration management can become rather complicated, pretty fast. Wouldn’t it be nice to have a structured way of dealing with this complexity?</p><p>  在进行机器学习项目的研究和实验时，总是有无数的设置可以尝试。在非平凡的应用程序中，配置管理会变得相当复杂，非常快。有一种结构化的方式来处理这种复杂性不是很好吗？</p><p> Hydra is a tool that allows you to build configurations in a composable manner, and override certain parts from the command line or config files.</p><p> Hydra是一种工具，可让您以可组合的方式构建配置，并从命令行或配置文件覆盖某些部分。</p><p> To illustrate some of the common tasks that can be simplified with the library, let’s say there’s a base architecture of a model we’re experimenting on, and multiple variations of it. With Hydra, a base configuration can be defined, and then multiple jobs be run with variations of them:</p><p> 为了说明可以通过该库简化的一些常见任务，假设有一个我们正在尝试的模型的基本体系结构，以及它的多种变体。使用Hydra，可以定义基本配置，然后运行多个作业，并进行以下更改：</p><p>  ├── variation│ ├── option_a.yaml│ └── option_b.yaml├── base.yaml└── train_model.py</p><p>  ├──变化│├──option_a.yaml│└──option_b.yaml├──base.yaml└──train_model.py </p><p> Hydra’s cousin, OmegaConf, provides a consistent API for the base of the hierarchical configuration system, supporting different sources like YAML, config files, objects and CLI arguments.</p><p>Hydra的堂兄OmegaConf为分层配置系统的基础提供了一致的API，并支持YAML，配置文件，对象和CLI参数等不同来源。</p><p>   Every tool that increases the productivity of a data science team is worth gold. There is no reason to make people that work in data science projects re-invent the wheel every time, think over and over again how to better organize the code in their project, use some “PyTorch boilerplate” that is not very well maintained, or trade potential control for using a higher level abstraction.</p><p>   每一种提高数据科学团队生产力的工具都值得金。没有理由让从事数据科学项目的人每次都重新发明轮子，反复思考如何更好地组织其项目中的代码，使用维护得不好的“ PyTorch样板”，或者使用更高级别的抽象的贸易潜力控制。</p><p> Lightning helps boost productivity by  decoupling the science from the engineering. It is sort of like Keras for TensorFlow, in the sense that it makes your code a lot more concise. However, it does not take your control away. It’s still PyTorch, and you have access to all the usual APIs.</p><p> 闪电通过将科学与工程分离而有助于提高生产率。从某种意义上说，它使您的代码更简洁，有点像TensorFlow的Keras。但是，这并不能控制您。它仍然是PyTorch，您可以访问所有常用的API。</p><p> This library helps teams leverage software engineering’s good practices around organization and clear responsibilities of components, to build high quality code  that can easily scale to train on multiple GPUs, TPUs and CPUs.</p><p> 该库可帮助团队利用围绕组织的软件工程的良好实践和明确的组件职责来构建可轻松扩展以在多个GPU，TPU和CPU上进行训练的高质量代码。</p><p>  A library that will help those junior members of the data science team produce better results, but also, more experienced members will love it because of the increase in overall productivity, without giving up control.</p><p>  一个可以帮助数据科学团队的初级成员产生更好结果的库，但是，由于整体生产力的提高，而没有放弃控制权，更有经验的成员会喜欢它。</p><p>   Not all machine learning is deep learning. Very often, your models consist of more  traditional algorithms implemented in  scikit-learn (such as Random Forest), or you use gradient boosting methods like popular  LightGBM and  XGBoost.</p><p>   并非所有的机器学习都是深度学习。通常，您的模型由scikit-learn中实现的更传统的算法（例如，Random Forest）组成，或者您使用诸如流行的LightGBM和XGBoost之类的梯度增强方法。</p><p> However, a lot of advancements are happening in the deep learning field. Frameworks like PyTorch are advancing at a breathtaking pace, and hardware devices are being optimized to run tensor computations faster and with lower power consumption. Wouldn’t it be nice if we could leverage all this work, to run our  traditional methods faster and more efficiently?</p><p> 但是，深度学习领域正在发生许多进步。像PyTorch这样的框架正在以惊人的速度发展，并且硬件设备已经过优化，可以更快地运行张量计算并降低功耗。如果我们可以利用所有这些工作来更快，更高效地运行传统方法，那岂不是很好吗？ </p><p> Here is where Hummingbird comes in. This new library by Microsoft can compile your trained traditional ML models into tensor computations. This is great, because it frees you of the need to re-engineer your models.</p><p>这是Hummingbird的用武之地。微软提供的这个新库可以将训练有素的传统ML模型编译为张量计算。这很棒，因为它使您无需重新设计模型。</p><p> As of now, Hummingbird supports conversion to  PyTorch,  TorchScript,  ONNX, and  TVM, and a variety of ML models and vectorizers. The inference API is also very similar to the Sklearn paradigm, which lets you reuse your existing code but changing your implementation to what’s generated by Hummingbird. This is a tool to keep an eye on, as it gains support for mode models and formats!</p><p> 到目前为止，Hummingbird支持转换为PyTorch，TorchScript，ONNX和TVM，以及各种ML模型和矢量化器。推理API也与Sklearn范例非常相似，后者可让您重用现有代码，但将实现更改为Hummingbird生成的代码。这是一个值得关注的工具，因为它获得了对模式模型和格式的支持！</p><p>  Nearly every data scientist has worked with high dimensional data at some point during their career. Unfortunately, human brains are not adequately wired for dealing with this kind of data intuitively, so we must resort to other techniques.</p><p>  几乎每个数据科学家在职业生涯中的某个时候都曾处理过高维数据。不幸的是，人脑没有足够的连线直观地处理这种数据，因此我们必须求助于其他技术。</p><p> Early this year, Facebook released HiPlot, a library that helps discover correlations and patterns in high-dimensional data using parallel plots and other graphical ways to represent information. The concept is explained in  their launch blog post, but it’s basically a nice and convenient way of visualizing and filtering high dimensional data.</p><p> 今年初，Facebook发布了HiPlot，这是一个库，可使用并行绘图和其他图形方式来表示信息，从而帮助发现高维数据中的相关性和模式。他们的发布博客中对概念进行了说明，但基本上，这是一种可视化和过滤高维数据的好方法。</p><p>  HiPlot is interactive, extensible, and you can use it from your standard Jupyter Notebooks or via it’s own server.</p><p>  HiPlot具有交互性，可扩展性，您可以从标准Jupyter笔记本电脑或通过其自己的服务器使用它。</p><p>  As the ecosystem of Python libraries grows increasingly more complex, we find ourselves writing more and more code that depends on C extensions and multi-threaded code. This becomes a problem when it comes to measuring performance because the profilers built into CPython don’t handle multi-threaded and native code properly.</p><p>  随着Python库生态系统变得越来越复杂，我们发现自己正在编写越来越多的依赖C扩展和多线程代码的代码。在衡量性能时，这成为一个问题，因为CPython内置的探查器无法正确处理多线程和本机代码。</p><p> That’s when Scalene comes to the rescue. Scalene is a CPU and memory profiler for Python scripts capable of correctly handling multi-threaded code and distinguishing between time spent running Python vs. native code. There’s no need to modify your code, you just need to run your script from the command line with scalene and it will generate a text or HTML report for you, showing CPU and memory usage for each line of your code.</p><p> 那就是Scalene进行救援的时候。 Scalene是用于Python脚本的CPU和内存探查器，能够正确处理多线程代码并区分运行Python和本机代码所花费的时间。无需修改代码，只需要在命令行中使用scalene运行脚本，脚本就会为您生成文本或HTML报告，显示代码每一行的CPU和内存使用情况。 </p><p>   We couldn’t finish this list without including our own homegrown baby for video analytics applications.</p><p>如果不包括我们自己的用于视频分析应用程序的本地婴儿，我们将无法完成此列表。</p><p> Norfair is a customizable lightweight Python library for real-time object tracking. In other words, it assigns a unique id to every detected object in different frames, letting you identify them as they move through time. Using Norfair, you can add tracking capabilities to any detector with just a few lines of code. “Any detector”? Yes. No matter what the object representation looks like: a bounding box (4 coordinates), a single point centroid, the output of a human pose estimation system with a variable number of key points above a certain probability threshold, or anything else.</p><p> Norfair是一个可定制的轻量级Python库，用于实时对象跟踪。换句话说，它为不同帧中的每个检测到的对象分配一个唯一的ID，以便您随着时间的推移识别它们。使用Norfair，您只需几行代码就可以为任何检测器添加跟踪功能。 “任何探测器”吗？是。无论对象表示是什么样的：包围盒（4个坐标），单点质心，具有超过一定概率阈值的可变数量关键点的人体姿态估计系统的输出，或其他任何东西。</p><p>  The function used to calculate the distance between tracked objects and detections is defined by the user, making it fully customizable if you need it.</p><p>  用户定义了用于计算跟踪对象与检测之间的距离的功能，可以根据需要完全自定义。</p><p> It’s also fast and it can run real-time. However, the real beauty is that it is very modular, and you can take  your existing detection codebase and add tracking capabilities to it, with only a few lines of code. We are welcoming any comments and suggestions, and work on improving the capabilities of Norfair every day!</p><p> 它也很快，并且可以实时运行。但是，真正的美在于它是非常模块化的，您可以仅使用几行代码就可以使用现有的检测代码库并为其添加跟踪功能。我们欢迎任何意见和建议，并每天努力提高Norfair的功能！</p><p>  quart — an async web framework with Flask-compatible API. Some of the existing Flask extensions will even work!</p><p>  quart-具有Flask兼容API的异步Web框架。一些现有的Flask扩展程序甚至可以使用！</p><p> alibi-detect — monitor outliers and distribution drift in your production models, for tabular data, text, images and time series.</p><p> 不在场检测-监视生产模型中的异常值和分布漂移，以获取表格数据，文本，图像和时间序列。</p><p> einops — popularized in 2020, einops lets you write tensor operations for readable and reliable code, supporting numpy, PyTorch, TensorFlow, and others.  Recommended by Karpathy, do you need anything else?</p><p> einops —在2020年流行，einops可让您编写张量操作以获得可读且可靠的代码，并支持numpy，PyTorch，TensorFlow等。 Karpathy推荐，您还需要其他吗？ </p><p> stanza — accurate natural language processing tools on 60+ languages, from Stanford.  Multiple available pre-trained models for different tasks.</p><p>节-斯坦福提供60多种语言的准确自然语言处理工具。针对不同任务的多个可用的预训练模型。</p><p> datasets — from  HuggingFace, lightweight and extensible library to easily share and access datasets and evaluation metrics for Natural Language Processing (NLP) and more</p><p> 数据集-来自HuggingFace，轻便且可扩展的库，可轻松共享和访问用于自然语言处理（NLP）等的数据集和评估指标</p><p>  sktime — provides dedicated time series algorithms and scikit-learn compatible tools for building, tuning, and evaluating composite models. Also check their companion  sktime-dl package for deep learning based models.</p><p>  sktime-提供专用的时间序列算法和scikit-learn兼容工具，用于构建，调整和评估组合模型。还要检查其配套的sktime-dl软件包，以获取基于深度学习的模型。</p><p> netron — a visualizer for neural network, deep learning and machine learning models. Supports more formats than I even knew existed.</p><p> netron-神经网络，深度学习和机器学习模型的可视化工具。支持的格式比我所知道的还要多。</p><p> pycaret — wraps several common ML libraries and makes you vastly more productive, saving you hundreds of lines of code.</p><p> pycaret —包装了几个常见的ML库，使您的工作效率大大提高，节省了数百行代码。</p><p> tensor-sensor — helps you get the dimensions of your tensor math right, by improving error messages and providing visualizations.</p><p> 张量传感器-通过改善错误消息并提供可视化效果，帮助您正确确定张量数学的尺寸。</p><p> I want to thank  Ian Tayler, Germán Hoffman and Sebastián Sosa for the collaboration on this blog post.</p><p> 我要感谢Ian Tayler，GermánHoffman和SebastiánSosa在此博客文章上的合作。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://tryolabs.com/blog/2020/12/21/top-10-python-libraries-of-2020/">https://tryolabs.com/blog/2020/12/21/top-10-python-libraries-of-2020/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>