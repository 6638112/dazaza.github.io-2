<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>微服务--极简主义服饰中的建筑虚无主义</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">微服务--极简主义服饰中的建筑虚无主义</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-03 02:20:00</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/45741e699eaa130ec5f5391e0c95ce71.png"><img src="http://img2.diglog.com/img/2020/11/45741e699eaa130ec5f5391e0c95ce71.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Some recent  backtracking  from what we have been calling “Microservices” has sparked anew the debate around that software architecture pattern. It turns out that for increasingly more software people, having a backend with ( sometimes several) hundreds of services wasn’t that great an idea after all. The debate has  been going on for a while and much has already been said, but there are still a couple of things I’d like to say.</p><p>最近，我们一直称之为“微服务”的一些倒退再次引发了围绕软件架构模式的辩论。事实证明，对于越来越多的软件人员来说，拥有(有时是几个)数百个服务的后端毕竟不是一个好主意。这场辩论已经进行了一段时间了，已经说了很多，但我还有几件事想说。</p><p> TL;DR “Microservices” was a good idea taken too far and applied too bluntly. The fix isn’t just to dial back the granularity knob but instead to 1) focus on the split-join criteria as opposed to size; and 2) differentiate between the project model and the deployment model when applying them.</p><p>“微服务”博士是一个走得太远、应用得太直率的好主意。修复方法不仅仅是降低粒度旋钮，而是要1)关注拆分-联接标准，而不是大小；2)在应用项目模型和部署模型时区分它们。</p><p>    There were three main reasons for the initial success of  microservices as an architectural pattern for software: 1) forced modularisation, 2) weakened dependencies, and 3) an excuse for having no architecture. In order:</p><p>微服务作为软件体系结构模式最初取得成功的主要原因有三个：1)强制模块化，2)削弱依赖性，3)没有体系结构的借口。按顺序：</p><p> In the monoliths of old, you could in theory enforce module boundaries. You could say that your  acme-helpers or  acme-data-tools could not depend on  acme-domain, say, and you even had some tooling to enforce that, but it was fallible. Especially in big companies where these monoliths spanned more than a team’s cognitive horizon, violations of those boundaries were often a simple  import away, and of course rife. Angry architects saw in microservices the promise of making those a thing of the past: now the developer is forced to only deal with the API. Codebases parted ways and calls were made to go down the network stack and back.</p><p>在过去的铁板一块中，理论上您可以强制模块边界。比方说，您可以说您的acme-helper或acme-data工具不能依赖acme-domain，您甚至可以使用一些工具来强制执行这一点，但这是很容易出错的。特别是在大公司里，这些巨石跨越的范围超出了一个团队的认知范围，打破这些界限往往是一件简单的事情，当然也很普遍。愤怒的架构师在微服务中看到了让这些成为过去的承诺：现在开发人员被迫只处理API。代码库分道扬镳，并进行调用以沿网络堆栈下行并返回。</p><p> So then, one wouldn’t depend on a fellow service at build time, only at runtime. Great. Method calls became http calls. “Now we don’t need to care about dependencies” — actual people said this, as if the dependency wasn’t fundamental and instead just an accidental artifact of the build setup. Everybody brushed up on their HTTP and different server and client implementations, read all about REST and Soap (and RPC, RMI and CORBA while at it) and merrily created a layer of indirection between modules — now  services — that was  very loose. Typed APIs, granular network policies and contract testing came much later.</p><p>因此，人们在构建时不会依赖于其他服务，只有在运行时才会依赖。太棒了。方法调用变成了http调用。“现在我们不需要关心依赖关系了”--实际的人们这样说，好像依赖关系不是基本的，而仅仅是构建设置中的意外产物。每个人都熟悉了他们的HTTP以及不同的服务器和客户端实现，阅读了所有关于REST和SOAP(以及RPC、RMI和CORBA)的内容，并愉快地在模块(现在是服务)之间创建了一个非常松散的间接层。类型化API、精细网络策略和合同测试出现的时间要晚得多。</p><p> It felt liberating until the complexities of API versioning, delivery semantics, error propagation, distributed transaction management and the sprawl of client code in all callers of a service began to show up. This was a gigantic  shift right, but hey, the build process was simpler.</p><p>在API版本控制、交付语义、错误传播、分布式事务管理和服务的所有调用方中的客户端代码蔓延的复杂性开始显现之前，它让人感觉到解放。这是一个巨大的右移，但嘿，构建过程更简单。</p><p> More insidious perhaps was the validation that “doing microservices” brought to organisations that lacked a thesis about how their architecture should be. There was now a sanctioned answer to most architectural dilemmas: another microservice. Another entry in the service catalog for any and all interested parties to call. This ecology of interacting parties, each acting in their own interest for the common good spoke to an underlying, tacit belief that the emergent mesh of services would approximate the latent natural architecture of the domain.</p><p>也许更隐秘的是，“做微服务”给那些缺乏关于其架构应该是怎样的论文的组织带来了认可。现在，对于大多数建筑难题，有了一个得到认可的答案：另一项微服务。服务目录中的另一个条目，供任何和所有相关方呼叫。这种互动方的生态，每个人都为了共同利益而行动，这表明了一种潜在的默契，即新兴的服务网状结构将近似于领域的潜在自然架构。</p><p> So soft and convenient was the lure of not having to draw hard architectural lines that we got lazy where we weren’t and accepted our lazyness where we already were. If you didn’t subscribe to that belief, the problem was you and your lack of understanding of complex systems, you objectivist cretin.</p><p>不需要画硬的建筑界线的诱惑是如此的柔软和方便，以至于我们在没有的地方变得懒惰起来，在我们已经在的地方接受了我们的懒惰。如果你不认同这个信念，问题就出在你和你对复杂系统的缺乏理解上，你这个客观主义的白痴。</p><p> Yes, there was real pain in managing monoliths and sure, many systems were too monolithic (i.e. had deployables too large) but the zealotry of a newfound purity swung the pendulum too far, as they always do. Not only do we not need to run so many services so small, we also don’t benefit from isolating their codebases so much. To summarise:</p><p>是的，管理巨石确实很痛苦，当然，许多系统太巨石了(即可部署的东西太大)，但对新发现的纯洁性的狂热把钟摆摆动得太远了，就像他们总是做的那样。我们不仅不需要运行这么多这么小的服务，而且我们也不会从隔离它们的代码库中获益太多。总结一下：</p><p> weakening dependencies between different parts of our systems is a “shift-right” loan with high interest; and</p><p>削弱我们系统不同部分之间的依赖是一种高息的“右移”贷款；以及。</p><p> having a ready answer when the thinking gets tough is a soothing lie that just moves complexity about. There is no substitute to the effortful application of cognitive power to a problem.</p><p>当思考变得困难时，有一个现成的答案是一个令人宽慰的谎言，它只是在移动复杂性。没有什么可以替代努力地将认知力应用到一个问题上。</p><p>  Two things: focus on the right criteria for splitting a service instead of on its size, and apply those criteria more thoughtfully.</p><p>两件事：关注拆分服务的正确标准，而不是其规模，并更仔细地应用这些标准。</p><p>  The  micro in microservices ought to be at best a prediction, never a goal. We may predict services  will be micro but they don’t  have to be.  Vaugh Vernon is right when he speaks about “cohesion for a reason”.</p><p>微服务中的微观充其量应该是一个预测，而不是一个目标。我们可能会预测服务将是微不足道的，但它们不一定是微不足道的。沃弗农说的“凝聚力是有原因的”是对的。</p><p> There should be no prescribed  a priori granularity of services. There  is no prescribed size of a service. There are instead  good and bad reasons to split parts of a software system.</p><p>不应该有预先规定的服务粒度。服务的大小没有规定。相反，拆分软件系统的各个部分有好的理由，也有不好的理由。</p><p>     There are however different realms in which “software systems” exist: they exist both as artifacts we interact with and as artifacts computers interact with. Code and binary. We organise them in different ways: the  project model (repositories, projects, modules and their dependencies) and the  deployment model (what production environments look like and how deployables run in them).</p><p>然而，“软件系统”存在于不同的领域：它们既作为我们交互的工件存在，也作为计算机交互的工件存在。代码和二进制。我们以不同的方式组织它们：项目模型(存储库、项目、模块及其依赖项)和部署模型(生产环境是什么样子，以及可部署项在其中是如何运行的)。</p><p>  In the process of going from coarse to granular (i.e. from monolith to microservices) however, little attention was paid to the difference — and possible indirection — between those two models. The hammer hit both fairly indiscriminately and made us split codebases because of runtime concerns and split deployables due to project concerns.</p><p>然而，在从粗糙到颗粒(即从整体到微服务)的过程中，很少注意到这两个模型之间的差异-以及可能的间接性。锤子不分青红皂白地敲打着两者，让我们因为运行时的考虑而拆分了代码库，由于项目的考虑而拆分了可部署的代码。</p><p>  Much like stiffness in a part of the human spine can result in pain in another,  stiffness in our build DAGs is causing excessive mirroring between our project and deployment models; between our repositories and our services; between the way we organise our code and the way our services run. That mirroring is on the one hand preventing us from shifting left concerns about the relationships between modules that have often been made weak and fragile runtime dependencies, while on the other hand encouraging us to have more services than what the runtime reality would call for. That brings pain.</p><p>就像人类脊柱的一部分僵硬可能会导致另一部分疼痛一样，构建DAG中的僵硬会导致项目和部署模型之间、存储库和服务之间、我们组织代码的方式和服务运行方式之间的过度镜像。这种镜像一方面阻止我们将对模块之间关系的关注转移到左边，而模块之间的关系通常被设置为弱而脆弱的运行时依赖关系，而另一方面鼓励我们拥有比运行时现实所需要的更多的服务。那会带来痛苦。</p><p>  Central to resolving this stiffness is the realisation that the build flow, at least conceptually, is a DAG – Directed Acyclic Graph – where the nodes are  jobs and  versioned artifacts and the edges connect either a job to a versioned artifact (“produces”) or a versioned artifact to a jobs (“dependency_of”). Deployables are by definition the versioned artifacts that are consumed by the deployment jobs.</p><p>解决这种僵硬的核心是认识到构建流至少在概念上是DAG导向的非循环图-其中节点是作业和版本化的工件，并且边将作业连接到版本化的工件(“Products”)，或者将版本化的工件连接到作业(“Dependency_of”)。根据定义，可部署项是由部署作业使用的版本化构件。</p><p>  For too long we overlooked how much a flexible and frictionless build DAG allows us to improve our architecture on both sides. With moderately rich build patterns we can have our code where its intent is clearer and more constraints can be validated at build time and still have it deployed into its simplest viable form, running where its execution is cheaper, faster and safer.</p><p>很长一段时间以来，我们忽略了灵活和无摩擦的构建DAG可以在多大程度上帮助我们改进两边的架构。使用中等丰富的构建模式，我们可以在构建时让代码的意图更清晰，可以验证更多的约束，并且仍然可以将其部署为最简单可行的形式，在执行成本更低、速度更快、更安全的地方运行。</p><p>   I’m not sure what the historically accurate account is that would explain the excessive simplicity of build patterns across the industry. I do know from experience that too many practices make do with very simple and linear flows where one repository builds independently one and only one service. Regardless of the legitimate argument about code duplication and its tradeoffs, there seems to be an aversion to build-time internal dependencies, even when these bring in clearly desirable data or logic such as message format definitions.</p><p>我不确定历史上准确的描述是什么，可以解释整个行业构建模式的过度简单性。我确实从经验中了解到，太多的实践仅适用于非常简单和线性的流，即一个存储库独立地构建一个且只有一个服务。不管关于代码复制及其权衡的合理争论如何，似乎都不喜欢构建时的内部依赖关系，即使这些依赖关系会带来明显需要的数据或逻辑(如消息格式定义)。</p><p> I suspect it might have something to do with how very few CI tools support composition natively (i.e. the outputs of jobs being able to be the inputs of others), how fallible semantic versioning in practice is and the difficulty of automating deterministic version propagation.</p><p>我怀疑这可能与很少有CI工具本机支持组合有关(即作业的输出能够成为其他人的输入)，语义版本控制在实践中有多容易出错，以及自动化确定性版本传播的难度。</p><p> By that I mean keeping local copies in sync with CI, builds repeatable, and new upstream versions automatically used by their downstream dependents. It isn’t trivial and requires some versioning and build-fu that, to my knowledge, most practices end up shortcutting to either sacrifice repeatability by using  latest or stifling the flow by requiring repeated manual work. Hence the pressure to have a simple build setup.</p><p>我的意思是保持本地副本与CI同步，构建可重复的、由其下游依赖项自动使用的新上游版本。这并不是一件微不足道的事情，需要一些版本控制和构建，据我所知，大多数实践最终要么通过使用最新版本来牺牲可重复性，要么通过需要重复的手工工作来扼杀流程。因此，有一个简单的构建设置的压力。</p><p> The exact cause is unimportant though. What is important is that overcoming this is crucial.</p><p>不过，确切的原因并不重要。重要的是，克服这一点至关重要。</p><p>  Many criteria for splitting or joining software systems, ranging from the social (teams, bounded contexts) to the mechanical (cpu or io boundedness) have been put forth, and they all make some form of sense. However, most of them are either a good reason to split projects or modules, or a good reason to split deployables, rarely both. Keeping that in mind will help us apply them more effectively.</p><p>已经提出了许多拆分或加入软件系统的标准，从社会标准(团队、有界环境)到机械标准(cpu或io有界性)，它们都有一定的意义。然而，它们中的大多数要么是拆分项目或模块的好理由，要么是拆分可部署的好理由，很少两者兼而有之。牢记这一点将有助于我们更有效地应用它们。</p><p> Below are a few possible criteria and some comments about their application. I’m not trying to be exhaustive, just illustrating the kind of reasoning makes sense to me.</p><p>下面是一些可能的标准和关于它们的应用的一些评论。我并不是想要详尽无遗，只是举例说明对我来说有意义的推理。</p><p>  Different Runtime – If a part of the codebase compiles to a different runtime it becomes a different deployable and we call it a different service.</p><p>不同的运行时--如果代码库的一部分编译成不同的运行时，它就变成了不同的可部署组件，我们称之为不同的服务。</p><p> Elasticity Profile – Some parts of the system may have a spikier load profile. It might pay off to have them scale in and out separately from the rest.</p><p>弹性剖面-系统的某些部分可能具有较高的负荷剖面。让它们与其他公司分开扩大和扩大规模，可能会带来回报。</p><p> Load Type – Some parts of a generally latency-oriented io-bound system may generate occasional peaks of cpu-bound load which can hurt response times. It might be better to put them in a different compute infrastructure perhaps more cpu-heavy and oriented for throughput instead.</p><p>负载类型-一般面向延迟的io系统的某些部分可能会偶尔产生CPU负载峰值，这可能会影响响应时间。将它们放在不同的计算基础设施中可能会更好，也许会占用更多CPU资源，并以吞吐量为导向。</p><p> Security – Some parts of the system may deal with more sensitive data or a set of more privileged users, while some others may even be public. If the burden of security for the parts that need it on the parts that do not is considerable (and that includes unknown risk), then it might pay off to have them separate.</p><p>安全性-系统的某些部分可能会处理更敏感的数据或一组更有特权的用户，而其他部分甚至可能是公开的。如果需要的部分在不需要的部分上的安全负担是相当大的(这包括未知的风险)，那么将它们分开可能是值得的。</p><p> Process Disposability – Ideally most parts of our systems would cope well with replicas being terminated in one place and spun up in another. If some parts do not, maybe because they have long-lived transactions that keep unreplicated state, it might pay off to separate them, depending on your reliability profile and your process scheduling churn.</p><p>进程可丢弃-理想情况下，我们系统的大多数部分可以很好地处理在一个地方终止而在另一个地方旋转的副本。如果某些部分没有这样做，可能是因为它们有保持未复制状态的长时间事务，根据您的可靠性配置文件和进程调度混乱情况，将它们分开可能是值得的。</p><p> Availability Requirements – Some parts of the system may be ok with being terminated, either because they’re not time sensitive and can resume or because they’re not that important. It may pay off to have these run on cheaper less reliable infrastructure like spot-instances or on-prem servers.</p><p>可用性要求-系统的某些部分可能可以被终止，要么是因为它们对时间不敏感，可以恢复，要么是因为它们不是那么重要。让它们运行在更便宜、不太可靠的基础设施(如Spot-Instance或本地服务器)上可能是有回报的。</p><p> Process Replication – If some parts of your system cannot function correctly in a distributed way, forcing you into a single-replica active-standby deployment (at best) then you better minimise the amount of logic that sits on that single point of failure.</p><p>流程复制-如果系统的某些部分不能以分布式方式正常运行，迫使您进行单副本主动-备用部署(充其量也就是)，那么您最好将位于单点故障上的逻辑量降至最低。</p><p> Reliability – If an important service has its reliability compromised by one misbehaving module that for whatever reason can’t be easily improved, it might be preferable to split them.</p><p>可靠性-如果一个重要服务的可靠性受到一个行为不端的模块的影响，无论出于什么原因都不能轻易改进，那么将它们分开可能是更可取的做法。</p><p> Blast Radius – Similarly, a service’s surface area might so large that however reliable it may be the impact on availability is too wide.</p><p>爆炸半径-类似地，服务的表面积可能太大，以至于无论它多么可靠，对可用性的影响都太大了。</p><p> Dependency Hell – Some runtimes have a flat address space where all modules are  linked equally regardless of their dependency path (JVM we’re looking at you). When the same module is brought in twice or more, it has to be unique and work for all its dependents, so a single version needs to be chosen. Although keeping up with recent versions, binary compatibility across minor versions of libraries, and tools that namespace different versions of a module do alleviate the burden of solving those version constraints repeatedly, sometimes it might be big enough to warrant splitting the deployable and cut the dependency graph in two.</p><p>依赖地狱-一些运行时有一个扁平的地址空间，其中所有模块都平等链接，而不考虑它们的依赖路径(JVM，我们现在看的是JVM)。当同一模块被引入两次或更多时，它必须是唯一的，并且适用于其所有依赖项，因此需要选择单个版本。虽然与最新版本保持同步，库的次要版本之间的二进制兼容性，以及将模块的不同版本命名为空间的工具确实减轻了重复解决这些版本约束的负担，但有时它可能足够大，足以保证将可部署项拆分并将依赖图一分为二。</p><p> As you can see, these are all about the reality our production processes encounter when actually running, and the tensions radiating from that. Keeping in mind the indirection between the project model and the deployment model the build DAG can give us, we see that in most if not all instances, little reason would there be to split codebases.</p><p>正如你所看到的，这些都是关于我们的生产过程在实际运行时遇到的现实，以及由此产生的紧张局势。牢记构建DAG可以提供给我们的项目模型和部署模型之间的间接性，我们看到，在大多数情况下(如果不是所有情况下)，几乎没有理由拆分代码库。</p><p>  A monolithic setup hammered by deployment-side splits thus results in several services, in an approximately optimal arrangement for their execution, but not necessarily in several independent codebases.</p><p>因此，部署端拆分的整体设置会产生几个服务，为它们的执行提供了近似最佳的安排，但不一定会产生几个独立的代码库。</p><p>  Rate of Change – The more volatile should depend on the least volatile. This is the well known  Stable Dependencies Principle. To “depend in the direction of stability” helps contain the volatility inherent to systems that change.</p><p>变化率-波动性越大应取决于波动性最小的。这就是众所周知的稳定依赖原则。“在稳定的方向上依赖”有助于遏制变化的系统固有的波动性。</p><p> Doing more than one thing – The often evoked adage of “doing one thing and one thing well” is scale-invariant and thus borderline meaningless. The thing can be big or small and still be one. A service can do “billing” or “persist the serialised invoice”: both are one thing. Furthermore, there’s nothing fundamentally wrong with doing more than one thing.</p><p>不只做一件事--经常被提起的格言“做好一件事和一件事”是规模不变的，因此近乎没有意义。这个东西可以是大的，也可以是小的，但仍然是一个。服务可以进行“计费”或“保存序列化发票”：两者是一回事。此外，做一件以上的事情从根本上没有什么错。</p><p> The call graph of a service being partitionable (a workable definition of more than  one thing?) may be a good reason for modularising things on the code side, but no more than a mere sign that valid reasons for splitting the deployable  may exist.</p><p>服务的调用图是可分区的(多个事物的可行定义？)。可能是在代码端模块化的一个很好的理由，但仅仅是拆分可部署的正当原因可能存在的迹象。</p><p> Different bounded contexts – Some parts of your system may solve a different kind of problem and thus require a separate vocabulary. Where these different parts touch there will be translation of data from one domain object to another. None of this implies that both ends of that translation have to be different services. We do it all the time with libraries.</p><p>不同的限定上下文-系统的某些部分可能解决不同类型的问题，因此需要单独的词汇表。在这些不同部分接触的地方，将会将数据从一个域对象转换到另一个域对象。这并不意味着翻译的两端必须是不同的服务。对于图书馆，我们一直都是这样做的。</p><p> Vaughn Vernon suggests starting with bounded contexts, more as a heuristic rather than a definite rule, but I still object on two counts: we shouldn’t aim for a particular ballpark size for services just because it  feels right, nor should we rely on heuristics and “proxy reasons” when we can have hard criteria.</p><p>沃恩·弗农(Vaughn Vernon)建议从有限的上下文开始，更多的是作为一个启发式的，而不是一个明确的规则，但我仍然反对两点：我们不应该仅仅因为感觉正确就为服务设定一个特定的大致规模，也不应该在我们可以有硬标准的时候依赖启发式和“代理理由”。</p><p> Build Times – When too much is part of the same build the inconvenience of building the same modules all over again for any change in others becomes a pain. This is a good reason to split a build, i.e. make some modules build separately from others and have the dependencies between them be version-specific (external) instead of direct (intra build). It is not a good reason to change the way things run. See  Dependency Hell however.</p><p>构建时间-当太多内容是同一构建的一部分时，重新构建相同的模块会带来不便，因为其他模块中的任何更改都会成为一种痛苦。这是拆分构建的一个很好的理由，即使一些模块与其他模块分开构建，并使它们之间的依赖关系是特定于版本的(外部)，而不是直接的(内部构建)。这不是改变事情运行方式的好理由。但是，请参见从属关系地狱。</p><p> Release Size and Cadence – When the integration of changes from different projects and modules delay releases, one has a problem with one’s CD setup (test coverage, dependency direction, semantic versioning, …?), not a problem with one’s architecture. It may be worthwhile to split one or two services to alleviate the pain while the root problem is fixed. But, just like a wound drain is sometimes medically necessary even though it’s not the skin that is lacking an opening, let’s be conscious that splitting deployables for this reason remains only a tactic.</p><p>发布大小和适宜性-当集成来自不同项目和模块的更改延迟发布时，您的CD设置就会出现问题(测试覆盖率、依赖关系方向、语义版本控制、…。？)，这不是一个人的体系结构的问题。在解决根本问题的同时，可能值得拆分一到两个服务来减轻痛苦。但是，就像伤口引流有时在医学上是必要的一样，尽管皮肤并不缺少开口，但我们要意识到，出于这个原因拆分可部署设备仍然只是一种策略。</p><p> Different teams – The relationship between team structure and software architecture is strong. Conway’s law is real, the inverse Conway maneuver works, but they relate patterns of communication among people and groups of people with the boundaries between “systems” taken as things “people work on” or “have concerns over” not necessarily “things that get deployed”.</p><p>不同的团队-团队结构和软件架构之间的关系非常密切。康威定律是真实的，相反的康威策略有效，但它们将人与人之间的沟通模式与“系统”之间的边界联系在一起，“系统”被认为是“人们工作”或“担心”不一定是“被部署的东西”的东西。</p><p> For this one to be a valid deployment-side reason (i.e. “different teams” to imply “different services”), the coordination effort and the added cognitive load due to the shared concerns  that would disappear with a split would have to be high enough to make up for the cost of splitting them. That would typically happen if there are differences on the later stages of testing, deployment, observability and support. Most of those concerns are absorbed by transversal platform teams that provide self-service operations or fall into a support rota that generally is a subset of people dealing with shared operational concerns already anyway. As with all things dealing with humans, add salt.</p><p>要使这一点成为有效的部署端理由(即，“不同的团队”意味着“不同的服务”)，协调工作和由于共同关注而将随着拆分而消失的额外认知负荷必须足够高，以弥补拆分它们的成本。如果在测试、部署、可观察性和支持的后期阶段存在分歧，通常会发生这种情况。这些问题中的大多数都被提供自助式操作的横向平台团队吸收，或者落入支持轮值中，后者通常是已经在处理共享操作问题的人员的子集。就像所有与人类打交道的东西一样，加盐吧。</p><p> Different language – as long as different languages compile satisfactorily to the same runtime (like say, Java and Scala) different modules written with them can be part of the same service. Again, we do it all the time with libraries.</p><p>不同的语言--只要不同的语言能够令人满意地编译到相同的运行时(比如Java和Scala)，用它们编写的不同模块就可以成为同一服务的一部分。同样，对于图书馆，我们一直都在这样做。</p><p> Conversely to previous section, the above are criteria that pertain more to the reality we humans encounter when working on our systems and the tensions radiating from that. Again keeping in mind the project-deployment indirection, we see that little reason would there be to split deployables. Instead, these are criteria for different arrangements of modules, projects, their dependencies and the ways they compose into deployables.</p><p>与上一节相反，上面的标准更符合我们人类在使用我们的系统时所遇到的现实，以及由此产生的紧张局势。再次牢记项目部署的间接性，我们认为没有什么理由拆分可部署的项目。相反，这些是模块、项目、它们的依赖项以及它们组合成可部署的方式的不同排列的标准。</p><p>  A monolithic setup hammered by project-side splits would result in one where repositories, modules and their dependencies are broken down into an arrangement that creates the least tension when operated by humans, without creating unnecessary complexity on the deployment side.</p><p>受到项目端拆分的单一设置将导致存储库、模块及其依赖项被分解成一种安排，这种安排在由人操作时会产生最小的紧张，而不会在部署端造成不必要的复杂性。</p><p> Suffice for this article to consider the project model as whole. I wish to leave the details of the ideal arrangement of repositories, projects, modules and dependencies to another post.</p><p>对于本文来说，将项目模型作为一个整体来考虑就足够了。我希望将存储库、项目、模块和依赖项的理想安排的细节留给另一个帖子。</p><p>  State – If you don’t have state, just pure logic, you probably have a library, not a service.If you have state, but it doesn’t change with user requests what you have is  configuration, either global or environment-specific.If changes to configuration are not time-sensitive, it can be a parameter to the deployment, which gets triggered when it changes. If they are time-sensitive you might need a configuration service that serves them continuously, rarely a bespoke one.If you do have global state that can change with, and across requests, you may have a service.</p><p>状态-如果您没有状态，只有纯逻辑，那么您可能有一个库，而不是服务。如果您有状态，但它不会随着用户请求而更改，则您拥有的是配置，无论是全局的还是特定于环境的。如果对配置的更改不是时间敏感的，则它可以是部署的参数，当更改时会触发该参数。如果它们是时间敏感型的，您可能需要持续为它们提供服务的配置服务，很少是定制的配置服务。如果您确实有可以随请求和跨请求更改的全局状态，则您可能拥有一个服务。</p><p> Cookie Cutter – Having a project template to aid in creating new microservices is indeed helpful. Maybe too helpful.</p><p>Cookie切割器-拥有一个项目模板来帮助创建新的微服务确实很有帮助。也许太有帮助了。</p><p> API Trees – Looking at the call graph, neat trees where the top service gets called by many, and the bottom ones only called by their parents, especially if they’re segmented by some business concept, are a smell that deployables have been split according to a romanticised view of their role instead of hard criteria to do with their computing reality.</p><p>API树-查看调用图，整齐的树中，顶级服务被许多人调用，而最底层的服务只由它们的父级调用，特别是如果它们被某些业务概念分割的话，这是一种气味，表明可部署文件是根据其角色的浪漫化视图划分的，而不是与其计算现实相关的硬性标准。</p><p> These are the easiest to join up. Often their data is related by stable identifiers already so data migration is minimal, easy or unnecessary.</p><p>这些是最容易连接起来的。通常，他们的数据已经与稳定的标识符相关，因此数据迁移是最小的、容易的或没有必要的。</p><p>  As a thought provoker, here are some patterns illustrating how, with some flexibility in the build DAG, we might organise our systems in ways that suit well both humans and machines. I have left out the testing and promotion that happens on the path to production to, maybe, another post.</p><p>作为一个发人深省的例子，这里有一些模式说明了在构建DAG中具有一定的灵活性，我们可以如何以适合人类和机器的方式来组织我们的系统。我省略了在生产过程中发生的测试和升级，也许是在另一个岗位上。</p><p> Policy Plugin pattern – Build flow that supports the strategy pattern, where an algorithm instance has to be chosen at runtime.</p><p>策略插件模式-构建支持策略模式的流程，其中必须在运行时选择算法实例。</p><p> Let’s say we have product a, b, c and billing. At runtime billing gets events from each of the others. It has its own billing cycle and a batch style, throughput-oriented workload. The others are more transactional, always-on and latency-oriented. Billing knows how to issue invoices in general but does not know all the particulars of each product. Each of the others knows all about their product only.</p><p>假设我们有产品a、b、c和帐单。在运行时，帐单从其他每一个获取事件。它有自己的计费周期和批处理风格的、以吞吐量为导向的工作负载。其他的更多是事务性的、始终在线的和面向延迟的。帐单一般知道如何开具发票，但不知道每种产品的所有细节。其他的每个人都只知道他们的产品的全部情况。</p><p>  Based on logic that comes from each of them separately at compile time (i.e. billing has a compile-time dependency on the other projects for the artifacts that define the invoicing logic) it can discharge its duties by calling the right piece of logic at runtime.</p><p>基于编译时分别来自其中每个项目的逻辑(即，对于定义开票逻辑的工件，帐单在编译时依赖于其他项目)，它可以通过在运行时调用正确的逻辑来履行其职责。</p><p> I don’t want to strawman anyone here, but I can see this scenario being implemented in microservice-oriented practices with either:</p><p>我不想在这里对任何人指手画脚，但是我可以看到这个场景正在面向微服务的实践中实现，其中任何一个都有：</p><p> more service calls at the point of product-specific invoice logic, possibly hammering other services during the batch jobs’ execution and creating deployment coupling, or forcing another split because of cycles; or</p><p>在特定于产品的发票逻辑点进行更多服务调用，可能会在批处理作业的执行过程中破坏其他服务并创建部署耦合，或者由于循环而强制进行另一次拆分；或者。</p><p> Server-supplied client libraries – Not exactly about the split-join criteria but a good demonstration of non-linear build flows. Instead of having each caller of a service implementing (a subset of) their interface, keeping that up-to-date, and stub its behaviour in their tests, consider instead having each service providing that as a library: the interface, the client implementation and the test stub.</p><p>服务器提供的客户端库-不完全是关于拆分-联接标准，但很好地演示了非线性构建流。与其让服务的每个调用者实现其接口(子集)，使其保持最新，并在测试中保留其行为，不如考虑将每个服务作为库提供：接口、客户端实现和测试存根。</p><p>  The contract surface becomes compile-time checked, the wire protocol becomes controlled by the called service’s team, there is no duplication of client-side implementations with associated drift or accumulated cruft over time, and we get stubs that actually mimic the service’s behaviour. Rand Davis has been beating this drum ( article,  presentation).</p><p>契约图面变为编译时检查，连接协议由被调用服务的团队控制，客户端实现不存在随时间漂移或累积的重复，我们得到的存根实际上模拟了服务的行为。兰德·戴维斯(Rand Davis)一直在鼓吹(文章，演示文稿)。</p><p> We</p><p>我们。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://vlfig.me/posts/microservices">https://vlfig.me/posts/microservices</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/建筑/">#建筑</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/服务/">#服务</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1032506.html"><img src="http://img2.diglog.com/img/2020/11/thumb_fffc389f176cbe2ef5c428c2633cd8e9.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032506.html">伪装消防喷头喷发保护日本历史村落</a></div><span class="my_story_list_date">2020-11-1 0:34</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031437.html"><img src="http://img2.diglog.com/img/2020/10/thumb_5122d6b7d72e1bc5a4c09573f5d8bfc5.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031437.html">
波哥大Tül筹集400万美元改善拉丁美洲建筑供应链</a></div><span class="my_story_list_date">2020-10-27 18:50</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031250.html"><img src="http://img2.diglog.com/img/2020/10/thumb_bde435abadd7122fc55e487c511e676a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031250.html">这种新型超白涂料可以给建筑物和汽车降温</a></div><span class="my_story_list_date">2020-10-26 22:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030538.html"><img src="http://img2.diglog.com/img/2020/10/thumb_39fba443d017a396979b026bb0f2203c.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030538.html">建筑物更换专有电池组</a></div><span class="my_story_list_date">2020-10-22 21:40</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>