<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>C调试器是如何工作的？</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">C调试器是如何工作的？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-18 11:21:10</div><div class="page_narrow text-break page_content"><p>When you use GDB, you can see that it has a complete control over yourapplication process. Hit  Ctrl- C while theapplication is running and the process execution stops, and GDB showsits current location, stack trace, etc.</p><p>当您使用gdb时，您可以看到它完全控制您的申请流程。在按住Ctrl-C组合键的同时应用程序正在运行，进程执行停止，并且gdb显示其当前位置、堆栈跟踪等。</p><p>      Let&#39;s start first with how it  doesn&#39;t work. It doesn&#39;t simulate theexecution, by reading and interpreting the binary instructions. Itcould, and that would work (that the way  valgrind memory debuggerworks), but that would be too slow. Valgrind slows the application1000x down, GDB doesn&#39;t. That&#39;s also the way virtual machines like Qemu work.</p><p>让我们先从它的工作原理说起。它不能模拟通过读取和解释二进制指令来执行。它可以，这将会起作用(valgrind内存调试器的方式工作)，但那太慢了。Valgrind会降低应用程序的速度降低1000倍，gdb就不会了。这也是虚拟机喜欢的方式。QEMU工作。</p><p>    Another guess? ... ? Hacking! yes, there&#39;s a good deal of that, plushelp from the OS kernel.</p><p>另一种猜测？...？黑客攻击！是的，那里有很多这样的东西，再加上来自操作系统内核的帮助。</p><p>  First of all, there&#39;s one thing to know about Linux processes: parent processes can get additional information about theirchildren, in particular the ability to  ptrace them. And, you canguess, the debugger is the parent of the debuggee process (or itbecomes, processes can adopt a child in Linux :-).</p><p>首先，关于Linux进程，有一件事需要知道：父进程可以获取有关其儿童，特别是追踪他们的能力。而且，您可以我猜，调试器是被调试进程的父进程(或它成为，进程可以在Linux中领养子进程：-)。</p><p>    Linux  ptrace APIallows a (debugger) process to access low-level information aboutanother process (the debuggee). In particular, the debugger can:</p><p>Linux ptrace API允许(调试器)进程访问有关另一个进程(被调试进程)。具体地说，调试器可以：</p><p>  be notified of system events:  PTRACE_O_TRACEEXEC, PTRACE_O_TRACECLONE,  PTRACE_O_EXITKILL,  PTRACE_SYSCALL (youcan recognize the  exec syscall,  clone,  exit, and all the othersyscalls)</p><p>收到系统事件通知：PTRACE_O_TRACEEXEC，Ptrace_O_TRACECLONE、ptrace_O_EXITKILL、ptrace_syscall(您可以识别exec syscall、克隆、退出和所有其他操作系统调用)。</p><p>    Ptrace implementation is outside of the scope of this post, but Idon&#39;t want to move the black-box one step above, so let me explainquickly how it works (I&#39;m no kernel expert, please correct me if I&#39;mwrong and excuse me if I simplify too much :-).</p><p>Ptrace实现不在本文的讨论范围内，但是我我不想把黑匣子移到上面一步，所以让我解释一下快速了解它的工作方式(我不是内核专家，如果我不是内核专家，请纠正我错了，如果我简化得太多，请原谅：-)。</p><p>  Ptrace is part of Linux kernel,so it has access to  all the kernel-level information about theprocess:</p><p>Ptrace是Linux内核的一部分，因此它可以访问所有关于过程：</p><p>  accessingCPU registers? easy with  copy_regset_to/from_user. (Thereis nothing complicated here, as CPU registers are saved somewhere inLinux&#39;s  struct task_struct *scheduler structures, when the process is unscheduled.</p><p>存取CPU寄存器？轻松使用Copy_regset_to/from_user。(在那里这里并不复杂，因为CPU寄存器保存在Linux&#39；sStruct task_struct*调度器结构，当进程未调度时。</p><p>    single-stepping?set the right flag( ARM, x86)on the task structure and, before triggering the execution, on theprocessor.</p><p>一步一个脚印？设置正确的标志(手臂，X86)在任务结构上，并且在触发执行之前，在处理器。</p><p>  Ptrace is also  hooked (search for function  ptrace_event)in many scheduling operations, so that it can send a  SIGTRAP signalto the debugger if requested ( PTRACE_O_TRACEEXEC option and itsfamily).</p><p>Ptrace也是挂钩的(搜索函数Ptrace_event)在许多调度操作中，以便它可以发送SIGTRAP信号如果需要，将其添加到调试器(ptrace_O_TRACEEXEC选项及其家庭)。</p><p>    The explanation above targeted Linux native debugging, but it&#39;s validfor most of the other environments. To get a clue on what GDB asks toits different targets, you can take a look at the operations of its target stack.</p><p>上面的解释针对的是Linux本机调试，但它是有效的对于大多数其他环境。要获得GDB要求的线索，请执行以下操作它的目标不同，你可以看看它的运作目标堆栈。</p><p>  In this target interface, you can see all of the high-level operationsrequired for C debugging:</p><p>在此目标界面中，您可以看到所有高级操作C调试所需：</p><p>  struct target_ops { struct target_ops *beneath; /* To the target under this one. */ const char *to_shortname; /* Name this target type */ const char *to_longname; /* Name for printing */ const char *to_doc; /* Documentation. Does not include trailing newline, and starts with a one-line descrip- tion (probably similar to to_longname). */ void (*to_attach) (struct target_ops *ops, const char *, int); void (*to_fetch_registers) (struct target_ops *, struct regcache *, int); void (*to_store_registers) (struct target_ops *, struct regcache *, int); int (*to_insert_breakpoint) (struct target_ops *, struct gdbarch *, struct bp_target_info *); int (*to_insert_watchpoint) (struct target_ops *, CORE_ADDR, int, int, struct expression *); ...}</p><p>结构target_ops{将target_ops*struct；/*构造到此函数下的目标。*/Const char*TO_SHORTNAME；/*命名该目标类型*/Const char*to_long name；/*打印名称*/Const char*to_doc；/*文档。不包括尾随换行符，并以一行描述开始-(可能类似于TO_LONGNAME)。*/Void(*to_Attach)(struct target_ops*ops，const char*，int)；Void(*to_fetch_registers)(struct target_ops*，struct regcache*，int)；Void(*to_store_registers)(struct target_ops*，struct regcache*，int)；INT(*TO_INSERT_BREAKPOINT)(struct target_ops*，struct gdbarch*，Struct BP_target_info*)；INT(*TO_INSERT_WATCHPOINT)(struct target_ops*，CORE_ADDR，int，int，struct表达式*)；..。}。</p><p>  The generic part of GDB calls these functions, and the target-specificparts implement them. It is (conceptually) shaped as a stack, or apyramid: the top of the stack is quite generic, for instance:</p><p>Gdb的泛型部分调用这些函数，而特定于目标的部件实现它们。它(在概念上)形状为堆栈，或金字塔：堆栈的顶部非常通用，例如：</p><p>    The remotetarget is interesting, as it splits the execution stack between two&#34;computers&#34;, through a communication protocol (TCP/IP, serial port).</p><p>这个远距Target很有趣，因为它将执行堆栈拆分为两个&#34；计算机&#34；，通过通信协议(TCP/IP、串行端口)。</p><p>  The remote part can be  gdbserver, running in another Linux box. Butit can also be an interface to a hardware-debugging port (JTAG) or avirtual machine hypervisor (e.g Qemu), that will play the role ofthe kernel+ptrace. Instead of querying the OS kernel structures, theremote debugger stub will query the hypervisor structures, or directlythe hardware registers of the processor.</p><p>远程部分可以是在另一个Linux机器上运行的gdbserver。但它还可以是硬件调试端口(JTAG)的接口或虚拟机管理程序(例如QEMU)，这将起到内核+ptrace。不是查询操作系统内核结构，而是远程调试器存根将查询虚拟机管理程序结构，或直接查询处理器的硬件寄存器。</p><p>  For further reading about this remote protocol, Embecosm wrote a detail guide about the different messages.  Gdbserver event-processing loopis there, and Qemu gdb-server stubis also online.</p><p>为了进一步了解这个远程协议，Embecosm写了一个有关不同消息的详细指南。Gdbserver事件处理循环有没有，还有QEMU gdb-服务器存根也在网上。</p><p>    We can see here that all the low-level mechanisms required toimplement a debugger are there, provided by this  ptrace API:</p><p>我们在这里可以看到，所有需要的低级机制实现一个调试器，由此ptrace API提供：</p><p>    But is that all a debugger does? no, that just the very low levelparts ... It also deals with symbol handling. That&#39;s link between thebinary code and the program sources. And one thing is still missing,maybe the most important one: breakpoints! I&#39;ll first explain howbreakpoints work as it&#39;s quite interesting and tricky, then I&#39;ll comeback on symbol management.</p><p>但这就是调试器所做的全部工作吗？不，那只是非常低的水平零件..。它还处理符号处理。这是两者之间的联系二进制代码和程序源代码。还有一样东西还没有找到，也许最重要的一点是：断点！我将首先解释一下如何断点的工作原理是非常有趣和棘手的，然后我会来的。回到符号管理上来。</p><p>    As we&#39;ve seen above, breakpoints are not part of  ptrace APIservices. But we can alter the memory, and receive the debugee&#39;ssignals. You can&#39;t see the link? That&#39;s because breakpointimplementation is quite tricky and hacky! Let&#39;s examine how to set abreakpoint at a given address:</p><p>正如我们在上面看到的，断点不是ptrace API的一部分服务。但我们可以更改内存，并接收调试对象的信号。你看不到链接吗？那是因为断点实现起来相当棘手和繁琐！让我们研究一下如何设置一个给定地址处的断点：</p><p>  The debugger reads (ptrace peek) the binary instruction stored atthis address, and saves it in its data structures.</p><p>调试器读取(Ptrace Peek)存储在该地址，并将其保存在其数据结构中。</p><p>  It writes an  invalid instruction at this location. What ever thisinstruction, it just has to be invalid.</p><p>它在此位置写入无效指令。这到底是什么指令，它只需要是无效的。</p><p>  When the debuggee reaches this invalid instruction (or, put morecorrectly, the processor, setup with the debuggee memory context), theit won&#39;t be able to execute it (because it&#39;s invalid).</p><p>当被调试者达到此无效指令时(或，放入更多正确地说，处理器、利用被调试存储器上下文设置)、它将无法执行它(因为它无效)。</p><p>  In modern multitask OSes, an invalid instruction doesn&#39;t crash thewhole system, but it gives the control back to the OS kernel, byraising an  interruption (or a fault).</p><p>在现代多任务操作系统中，无效指令不会使整个系统，但它通过以下方式将控制权交还给操作系统内核引起中断(或故障)。</p><p>  This interruption is translated by Linux into a  SIGTRAP signal,and transmitted to the process ... or to it&#39;s parent, as the debuggerasked for.</p><p>该中断由Linux翻译成SIGTRAP信号，并传送到过程中..。或作为调试器添加到它的父级我要的是。</p><p>  The debugger gets the information about the signal, and checks thevalue of the debuggee&#39;s instruction pointer (i.e.,  where the trapoccurred). If the  IP address is in its breakpoint list, that meansit&#39;s a debugger breakpoint (otherwise, it&#39;s a fault in the process,just pass the signal and let it crash).</p><p>调试器获取有关信号的信息，并检查被调试对象的指令指针的值(即，陷阱发生)。如果IP地址在其断点列表中，这意味着它是调试器断点(否则，它是进程中的错误，只需传递信号并让它崩溃)。</p><p>  Now that the debuggee is stopped at the breakpoint, the debuggercan let its user do what ever s/he wants, until it&#39;s time to continuethe execution.</p><p>既然被调试对象在断点处停止，调试器可以让它的用户做任何他/她想做的事情，直到到了继续的时候行刑。</p><p>  To continue, the debugger needs to 1/ write the correct instructionback in the debuggee&#39;s memory, 2/ single-step it (continue theexecution for one CPU instruction, with ptrace single-step) and 3/write the invalid instruction back (so that the execution can stopagain next time). And 4/, let the execution flow normally.</p><p>要继续，调试器需要1/写入正确的指令回到被调试者的内存中，2/单步执行(继续一条CPU指令的执行，带有ptrace单步)和3/将无效指令写回(以便可以停止执行下次再来一次)。和4/，让执行正常进行。</p><p>  Neat, isn&#39;t it? As a side remark, you can notice that this algorithmwill not work if not  all the threads are stopped at the same time(because running threads may pass the breakpoint when the  validinstruction is in place). I won&#39;t detail the way GDB guys solved it,but it&#39;s discussed in detail this paper: Non-stop Multi-threaded Debugging in GDB. Putbriefly, they write the instruction somewhere else in memory, set theinstruction pointer to that location and single-step theprocessor. But the problem is that some instruction are address-related, for example the jumps and conditional jumps ...</p><p>很整洁，不是吗？顺便说一句，您可以注意到这个算法如果不是所有线程都同时停止，则不会工作(因为当有效的说明已就位)。我不会详细说明GDB的人是如何解决这个问题的，但这篇论文对此进行了详细的讨论：GDB中的不间断多线程调试。放简而言之，它们将指令写入内存中的其他位置，将指向该位置指令指针，并单步执行处理器。但问题是，有些指令是与地址相关，例如跳转和条件跳转...。</p><p>    Now, let&#39;s come back to the symbol and debug information handlingaspect. I didn&#39;t study that part into details, so I&#39;ll only present anoverview.</p><p>现在，让我们回到符号和调试信息处理上来纵横比。我没有详细研究这一部分，所以我将只介绍一个概述。</p><p>  First of all, can we debug  without debug information and symboladdresses? The answer is yes, as, as we&#39;ve seen above, all thelow-level commands deal with CPU registers and memory addresses, andnot source-level information. Hence, the link with the sources areonly for the user&#39;s convenience. Without debug information, you&#39;ll seeyour application the way the processor (and the kernel) see it: asbinary (assembly) instructions and memory bits. GDB doesn&#39;t need anyfurther information to translate binary data into CPU instructions:</p><p>首先，我们可以在没有调试信息和符号的情况下进行调试吗地址呢？答案是肯定的，正如我们在上面看到的，所有的低级命令处理CPU寄存器和内存地址，以及不是源代码级别的信息。因此，与源代码的链接是这只是为了方便用户。如果没有调试信息，您将看到您的应用程序以处理器(和内核)的方式看待它：二进制(汇编)指令和内存位。GDB不需要任何将二进制数据转换为CPU指令的更多信息：</p><p>  (gdb) x/10x $pc # heXadecimal representation0x402c60: 0x56415741 0x54415541 0x55f48949 0x4853fd890x402c70: 0x03a8ec81 0x8b480000 0x8b48643e 0x002825040x402c80: 0x89480000 0x03982484(gdb) x/10i $pc # Instruction representation=&gt; 0x402c60: push %r150x402c62: push %r140x402c64: push %r130x402c66: push %r120x402c68: mov %rsi,%r120x402c6b: push %rbp0x402c6c: mov %edi,%ebp0x402c6e: push %rbx0x402c6f: sub $0x3a8,%rsp0x402c76: mov (%rsi),%rdi</p><p>(Gdb)x/10x$pc#十六进制表示法0x402c60：0x56415741 0x54415541 0x55f48949 0x4853fd890x402c70：0x03a8ec81 0x8b480000 0x8b48643e 0x002825040x402c80：0x89480000 0x03982484(Gdb)x/10i$pc#指令表示法=&gt；0x402c60：推送%r150x402c62：推送%r140x402c64：推送%r130x402c66：推送%r120x402c68：MOV%RSI，%r120x402c6b：推送%RBP0x402c6c：MOV%edi，%ebp0x402c6e：推送%rbx0x402c6f：SUB$0x3a8，%rsp0x402c76：MOV(%RSI)，%RDI。</p><p>          GDB will also be able to display the stack trace (more on that later),but with a limited interest:</p><p>Gdb还将能够显示堆栈跟踪(稍后将详细介绍)，但兴趣有限：</p><p>  (gdb) where#0 write ()#1 0x0000003d492769e3 in _IO_new_file_write ()#2 0x0000003d49277e4c in new_do_write ()#3 _IO_new_do_write ()#4 0x0000003d49278223 in _IO_new_file_overflow ()#5 0x00000000004085bb in print_current_files ()#6 0x000000000040431b in main ()</p><p>(Gdb)其中#0写入()#1 0x0000003d492769e3 in_IO_new_file_write()NEW_DO_WRITE()中的#2 0x0000003d49277e4c#3_IO_NEW_DO_WRITE()#4 0x0000003d49278223 in_IO_new_file_overflow()PRINT_CURRENT_FILES()中的#5 0x00000000004085bbMain()中的#6 0x000000000040431b。</p><p>  We&#39;ve got the PC addresses, the corresponding function, but that&#39;sit. Inside a function, you&#39;ll need to debug in assembly!</p><p>我们已经有了PC地址和相应的函数，但那是它。在函数内部，您需要在汇编语言中进行调试！</p><p>  Now let&#39;s add debug information: that&#39;s the DWARF standard,  gcc -goption. I&#39;m not very familiar with this standard, but I know itprovides:</p><p>现在让我们添加调试信息：这就是侏儒标准，GCC选择。我对这个标准不是很熟悉，但我知道提供：</p><p>    Try  dwarfdump to see the information embedded in youbinaries.  addr2line also uses these information:</p><p>尝试使用dwarfdump查看嵌入您的信息二进制文件。Addr2line还使用以下信息：</p><p>  $ dwarfdump /usr/lib/debug/usr/bin/ls.debug | grep 402ce40x00402ce4 [1289, 0] NS$ addr2line -e /usr/lib/debug/usr/bin/ls.debug 0x00402ce4/usr/src/debug/coreutils-8.21/src/ls.c:1289</p><p>$dwarfdump/usr/lib/debug/usr/bin/ls.debug|grep 402ce40x00402ce4[1289，0]ns$addr2line-e/usr/lib/debug/usr/bin/ls.debug 0x00402ce4/usr/src/debug/coreutils-8.21/src/ls.c：1289。</p><p>  Many source-level debugging commands will rely on these information,like the command  next, that sets a breakpoint at the address of thenext line, the  print command that relies on the types to display thevariables in the right type ( char,  int,  float, instead ofbinary/hexadecimal!).</p><p>许多源代码级调试命令将依赖于这些信息，与命令NEXT一样，该命令在下一行是打印命令，它依赖于类型来显示正确类型的变量(char、int、浮点数，而不是二进制/十六进制！)。</p><p>    We&#39;ve seen many aspects of debugger&#39;s internals, so I&#39;ll just say afew words of the last points:</p><p>我们已经看到了调试器内部的许多方面，所以我只想说一个最后几点的几句话：</p><p>  the stack trace is &#34;unwinded&#34; from the current frame ( $sp and $bp/# fp) upwards, one frame at a time. Functions&#39; name,parameters and local variables are found in the debug information.</p><p>堆栈跟踪是从当前帧($sp和$BP/#FP)向上，一次一帧。函数名称，在调试信息中可以找到参数和局部变量。</p><p>  watchpoints are implemented (if available) with the help of theprocessor: write in its registers which addresses should bemonitored, and it will raise an exception when the memory is read orwritten. If this support is not available, or if you request morewatchpoints than the processor supports ... then the debugger fallsback to &#34;hand-made&#34; watchpoints: execute the application instructionby instruction, and check if the current operation touches awatchpointed address. Yes, that&#39;s very slow!</p><p>观察点在(如果可用)的帮助下实现处理器：在其寄存器中写入哪些地址应该被监视，并且它将在读取内存或读取内存时引发异常写好了。如果此支持不可用，或者如果您请求更多支持超过处理器支持的观察点...。然后调试器将失败回到手工制作的观察点：执行应用程序指令指令，并检查当前操作是否触及有手表的地址。是的，那真是太慢了！</p><p>  Reverse debugging can be done this way too, record the effect ofeach instruction, and apply it backward for reverse execution.</p><p>也可以通过这种方式进行反向调试，记录每条指令，并将其向后应用以进行反向执行。</p><p>  Conditional breakpoints are normal breakpoints, except that,internally, the debugger checks the conditions before giving thecontrol to the user. If the condition is not matched, the executionis silently continued.</p><p>条件断点是正常断点，除了在内部，调试器在给出控件交给用户。如果条件不匹配，则执行默默地继续着。</p><p>  And play with  gdb gdb, or better (way better actually),  gdb --pid $(pidof gdb), because two debuggers in the  same terminal is insane :-). Another great thing for learning is system debugging:</p><p>并使用gdb gdb，或者更好(实际上要好得多)gdb--pid$(Pidof Gdb)，因为同一终端中的两个调试器太疯狂了：-)。另一件值得学习的事情是系统调试：</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.0x972.info/?d=2014/11/13/10/40/50-how-does-a-debugger-work">https://blog.0x972.info/?d=2014/11/13/10/40/50-how-does-a-debugger-work</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/调试器/">#调试器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/debugger/">#debugger</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/推送/">#推送</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>