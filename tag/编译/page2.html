<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#编译</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#编译</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1040856.html">重新启动用D编写的具有15年历史的游戏–第1部分编译 </a></div><div class="item_title_en"><a target="_blank" href="https://speps.fr/articles/torus-trooper-part1/">Rebooting a 15 year-old game written in D – Part 1 Compiling</a><span>(speps.fr)</span></div><span class="my_story_list_date">2020-12-20 14:4</span><div class="my_story_list_item_desc">最近在探索D时，我想起15年前在大学期间玩过的游戏。很长一段时间，我完全忘记了这个名字，只是这个名字来自日本的开发商。经过一番搜寻后，我终于找到了游戏的名称：Torus Trooper！
     用D编写，这是我在忙于学习C ++时根本不了解的语言
 有什么比尝试用现代版本的D编译D v0.110项目更好的项目，并......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编写/">#编写</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/game/">#game</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sdl/">#sdl</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1039350.html">关于编译时函数评估和类型系统的思考 </a></div><div class="item_title_en"><a target="_blank" href="https://www.ralfj.de/blog/2018/07/19/const.html">Thoughts on Compile-Time Function Evaluation and Type Systems</a><span>(www.ralfj.de)</span></div><span class="my_story_list_date">2020-12-13 6:12</span><div class="my_story_list_item_desc">从现在的1.26版本开始，Rust拥有了非常强大的CTFE或编译时函数评估机制，从那时起，人们就CTFE期间应允许哪些操作进行了各种讨论，哪些检查编译器应该做什么，这与促销有什么关系，以及我们在CTFE方面可以期望得到什么样的保证。这篇文章是我对这些主题的看法，而我将采用这样的类型也就不足为奇了：以系统为中心的视图：......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/系统/">#系统</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compile/">#compile</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/const/">#const</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1039308.html">Reddit用户通过反编译修复了Cyberpunk 2077 Steam控制器输入错误 </a></div><div class="item_title_en"><a target="_blank" href="https://www.reddit.com/r/cyberpunkgame/comments/kb73fr/comment/gfht16e">Reddit user fixes Cyberpunk 2077 steam controller input bug through decompiling</a><span>(www.reddit.com)</span></div><span class="my_story_list_date">2020-12-13 3:11</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1039308.html"><img src="http://img2.diglog.com/img/2020/12/thumb_791452ca31139d0845c5b11ef9b3b46a.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我从谷歌搜索方法开始，其中一些游戏（如Valorant）会阻止虚拟输入，并看到很多帖子说您可以将Windows api函数SetWindowsHookEx与WH_KEYBOARD_LL一起使用，以检查确定输入是否为假的LLKHF_INJECTED标志。我在游戏上使用x64dbg调试器在SetWindowsHookEx......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/输入/">#输入</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fixes/">#fixes</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1039109.html">CS 6120：高级编译器：自学在线课程 </a></div><div class="item_title_en"><a target="_blank" href="https://www.cs.cornell.edu/courses/cs6120/2020fa/self-guided/">CS 6120: Advanced Compilers: The Self-Guided Online Course</a><span>(www.cs.cornell.edu)</span></div><span class="my_story_list_date">2020-12-12 0:14</span><div class="my_story_list_item_desc">CS 6120是Adrian Sampson撰写的有关编程语言实现的博士学位级别的Cornell CS课程。它涵盖通用编译器主题，例如中间表示，数据流和“经典”优化，以及更多研究型主题，例如并行化，即时输入。编译和垃圾回收。这项工作包括阅读论文和开源黑客任务，这些任务使用LLVM和为此课程发明的教育IR。
 本页列出......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compilers/">#compilers</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/课程/">#课程</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1038775.html">Deno 1.6支持将TypeScript编译为单个可执行文件 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/denoland/deno/issues/986#issuecomment-740756795">Deno 1.6 supports compiling TypeScript to a single executable</a><span>(github.com)</span></div><span class="my_story_list_date">2020-12-10 7:7</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1038775.html"><img src="http://img2.diglog.com/img/2020/12/thumb_39e5a1a2cf9b16f7d483e691b5369055.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">作为开发人员，我安装deno并使用有用的附加功能（例如doc生成，格式化，整理，捆绑，文件监视，测试等）来开发程序。此Deno版本中包含与程序一旦部署无关的所有内容。在这里，它还将具有deno编译所需的功能。 compile子命令不需要安装Rust工具链即可运行，因为它会破坏使用Deno开发的好处之一，那就是只需要一......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiling/">#compiling</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/deno/">#deno</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1038566.html">Mac / Linux反编译器 </a></div><div class="item_title_en"><a target="_blank" href="https://www.hopperapp.com/">A Mac / Linux Decompiler</a><span>(www.hopperapp.com)</span></div><span class="my_story_list_date">2020-12-9 19:46</span><div class="my_story_list_item_desc">适用于Mac的Hopper Disassembler需要macOS 10.13或更高版本。 用于Linux的Hopper Disassembler需要Ubuntu 18.04，Arch Linux，Fedora 25或更高版本以及64位处理器。  料斗完全适应环境。 macOS版本充分利用了Cocoa框架，Linux......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hopper/">#hopper</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1038110.html">Rust使交叉编译成为儿童游戏 </a></div><div class="item_title_en"><a target="_blank" href="https://www.marcoieni.com/2020/12/rust-makes-cross-compilation-childs-play/">Rust makes cross compilation child's play</a><span>(www.marcoieni.com)</span></div><span class="my_story_list_date">2020-12-7 2:23</span><div class="my_story_list_item_desc">最近，我解决了这个增量问题，维护人员要求将Travis CI切换到GitHub action。
 如果您想看看这次旅程，这些就是我完成的所有提取请求：＃399，＃400，＃409，＃411，＃413，＃417和最后＃418。
 是的。如您所见，我喜欢少量的增量工作和早期反馈，而不是庞大的请求。 😁
 无论如何，del......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/儿童/">#儿童</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cross/">#cross</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1038050.html">基于MIR（中等内部表示）的轻量级JIT编译器 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/vnmakarov/mir">A light-weight JIT compiler based on MIR (Medium Internal Representation)</a><span>(github.com)</span></div><span class="my_story_list_date">2020-12-6 20:1</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1038050.html"><img src="http://img2.diglog.com/img/2020/12/thumb_38ab2f586e1efef00a85f89bcea553e2.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">MIR项目的目标是为实现快速，轻量级的口译员和JIT提供基础
  该代码处于开发的初始阶段。仅用于熟悉项目。绝对没有保证将来不会更改MIR，并且该代码适用于任何测试，除了此处给出的测试以及在x86_64 Linux / OSX和aarch64 / ppc64be / ppc64le / s390x Linux以外的平......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/jit/">#jit</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/weight/">#weight</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/mir/">#mir</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1038019.html">Template Haskell和交叉编译的故事 </a></div><div class="item_title_en"><a target="_blank" href="https://www.tweag.io/blog/2020-11-25-asterius-th/">A tale of Template Haskell and cross compilation</a><span>(www.tweag.io)</span></div><span class="my_story_list_date">2020-12-6 14:57</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1038019.html"><img src="http://img2.diglog.com/img/2020/12/thumb_022ae1f163e3837faf7572f4d1b4761b.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">模板Haskell（TH）是一种广泛使用但有争议的语言扩展。您可能已在自己的代码中使用了它；只需一行拼接代码，您就可以轻松完成诸如派生实例和嵌入文件之类的任务。您可能还听说过人们不喜欢它的原因：它减慢了编译速度，破坏了封装，在编译时任意IO都是有风险的，等等。
 但是鲜为人知的是，模板Haskell也使得与GHC的交......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/haskell/">#haskell</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/template/">#template</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ghc/">#ghc</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037757.html">寓言3（从F＃到JavaScript编译器）发布 </a></div><div class="item_title_en"><a target="_blank" href="https://fable.io/blog/Announcing-Nagareyama-4.html">Fable 3 (F# to JavaScript compiler) released</a><span>(fable.io)</span></div><span class="my_story_list_date">2020-12-5 2:54</span><div class="my_story_list_item_desc">今天是一天，寓言3流山正式发行！这是否意味着最新版本没有错误？可能不是，但是至少安装命令较短。我们还在许多项目中测试了候选版本，并设法解决了所有悬而未决的问题，因此，如果您在升级Fable 2项目时发现问题，您甚至可能会认为自己很幸运（也请报告）。
 首先，我必须感谢所有为该版本做出贡献的人们：从Don Syme本人......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/版本/">#版本</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037697.html">不同的编译器如何处理可证明未使用的实体 </a></div><div class="item_title_en"><a target="_blank" href="https://quuxplusone.github.io/blog/2020/12/02/unused-private-member/">How different compilers deal with provably unused entities</a><span>(quuxplusone.github.io)</span></div><span class="my_story_list_date">2020-12-4 22:49</span><div class="my_story_list_item_desc">前几天，有人问我是否应该担心代码库中未使用的函数所占用的空间。我的回答遵循以下漫漫路径：
 未使用的功能模板甚至都不会实例化，因此它们在链接时实际上不存在。
  可以使用未使用的内联函数进行代码生成，但是如果启用了编译器优化功能，则除非实际调用内联函数，否则您可能看不到任何内联函数的代码源。
  从逻辑上讲，应该对未......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/处理/">#处理</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/deal/">#deal</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037150.html">Richard Miller的RISC-V计划9 C编译器[视频]</a></div><div class="item_title_en"><a target="_blank" href="https://www.youtube.com/watch?v=LHJqdXGb0uc">A Plan 9 C Compiler for RISC-V by Richard Miller [video]</a><span>(www.youtube.com)</span></div><span class="my_story_list_date">2020-11-30 0:30</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1037150.html"><img src="http://img2.diglog.com/img/2020/11/thumb_b5310b7ab14bd3f2dcb5e98a7f9dc32a.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">理查德·米勒（Richard Miller）提出Plan 9 C编译器与Plan 9和Inferno操作系统一起起源于贝尔实验室。这是最初开发的一部分...</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/miller/">#miller</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037116.html">Nim编译器— Pascal源代码</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/nim-lang/Nim/tree/ea1f1ec6d4d6c776eb0f81c2bebdd4cb4c817ebe/nim">Nim compiler — Pascal source code</a><span>(github.com)</span></div><span class="my_story_list_date">2020-11-29 16:5</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1037116.html"><img src="http://img2.diglog.com/img/2020/11/thumb_025b67dc2053e70abacf6317da9484ff.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Nim是一种静态类型的编译系统编程语言。它结合了来自成熟语言（如Python，Ada和Modula）的成功概念。其设计注重效率，表达力，...</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036945.html">AWS聘请Rust编译器团队联合负责人Felix Klock</a></div><div class="item_title_en"><a target="_blank" href="https://www.theregister.com/2020/11/27/aws_hires_rust_compiler_team/">AWS hires Rust compiler team co-lead Felix Klock</a><span>(www.theregister.com)</span></div><span class="my_story_list_date">2020-11-28 7:35</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1036945.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c22dc4656fda92a95b3ba1c933beee0f.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">云巨头对Rust具有浓厚的兴趣，因此需要顶尖人才并希望他们提高语言水平
  亚马逊网络服务公司悄然透露，已聘请了Rust编译器联合负责人费利克斯·克洛克。
  AWS开源团队在星期二发表的一篇文章，表达了对Rust的热情，概述了云计算巨人接受该语言的几种方式。
  AWS的Matt Assay写道，该公司“越来越多地......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/聘请/">#聘请</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hires/">#hires</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036764.html">用Chez方案重建球拍编译器</a></div><div class="item_title_en"><a target="_blank" href="https://notamonadtutorial.com/rebuilding-the-racket-compiler-with-chez-scheme-210e23a69484">Rebuilding the Racket Compiler with Chez Scheme</a><span>(notamonadtutorial.com)</span></div><span class="my_story_list_date">2020-11-27 3:44</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1036764.html"><img src="http://img2.diglog.com/img/2020/11/thumb_6bbe240f837263559f0d1e1c66d69cb6.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Racket标榜了可编程语言的名称。它以可扩展性为核心，通过鼓励开发人员实现自己的DSL来解决当前的问题，将元编程提升到一个新的水平。
 遵循相同的原则，其开发团队通过堆叠DSL层来实现其许多组件，从而攻击了编写编译器的复杂性。
 另一方面，该项目有许多用C编写的遗留组件成为开发瓶颈，因此在2017年，Matthew......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/chez/">#chez</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/racket/">#racket</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036520.html">法国税法的现代编译器</a></div><div class="item_title_en"><a target="_blank" href="https://arxiv.org/abs/2011.07966">A Modern Compiler for the French Tax Code</a><span>(arxiv.org)</span></div><span class="my_story_list_date">2020-11-25 22:0</span><div class="my_story_list_item_desc">下载PDF摘要：在法国，所得税是根据法国公共财政局（DGFiP）创作，设计和维护的，从纳税人的个人收益中计算得出的。该算法依赖于传统的自定义语言和最初于1990年设计的编译器，它与法国葡萄酒不同，没有随着时间的流逝而衰老。由于输入语言的不足和编译器的技术局限性，该算法越来越难以维护，它依靠临时行为和变通办法来实现税法......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/税法/">#税法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036253.html">编译用于高放射性环境的应用程序</a></div><div class="item_title_en"><a target="_blank" href="https://stackoverflow.com/questions/36827659/compiling-an-application-for-use-in-highly-radioactive-environments">Compiling an application for use in highly radioactive environments</a><span>(stackoverflow.com)</span></div><span class="my_story_list_date">2020-11-24 14:39</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1036253.html"><img src="http://img2.diglog.com/img/2020/11/thumb_ff0287210796737fd34a6056d629fa7a.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我们正在编译一个嵌入式C / C ++应用程序，该应用程序部署在受到电离辐射轰击的环境中的屏蔽设备中。我们正在使用GCC并为ARM进行交叉编译。部署后，我们的应用程序会生成一些错误数据，并且崩溃的次数比我们想要的要多。硬件是为此环境设计的，我们的应用程序已在该平台上运行了几年。
 我们可以对代码进行更改吗，还是可以在......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/环境/">#环境</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1036080.html">播放：静态类型的Forth，编译为WASM</a></div><div class="item_title_en"><a target="_blank" href="https://www.play-lang.dev">Play: Statically typed Forth, compiled to WASM</a><span>(www.play-lang.dev)</span></div><span class="my_story_list_date">2020-11-23 22:39</span><div class="my_story_list_item_desc">Play的语法和语义在很大程度上受到了Forth的启发。这意味着语法是干净的，没有许多控制字符，而语义则由少量但功能强大的规则组成。
    无需赘述，Play中的代码由空格分隔的函数组成，这些函数以从左到右的方式调用。函数调用的一个或多个返回值用作下一个函数调用的输入参数。数字是返回自身的函数。从技术上讲，整个段落......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/静态/">#静态</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1035964.html">焦糖色：OCaml到Erlang编译器</a></div><div class="item_title_en"><a target="_blank" href="https://caramel.abstractmachines.dev">Caramel: An OCaml to Erlang Compiler</a><span>(caramel.abstractmachines.dev)</span></div><span class="my_story_list_date">2020-11-23 2:57</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1035964.html"><img src="http://img2.diglog.com/img/2020/11/thumb_15fa78c8d09d8b30e47163ae4b6e977c.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">焦糖具有高表现力，声音类型系统和快速的类型检查器。这使您可以通过使用更接近您的域的类型来排除整个错误类别，并在不牺牲开发速度的情况下毫不费力地重构大量代码。
  为了实现这一目标，Caramel实际上是OCaml编译器的后端，因此，它重用了整个类型检查堆栈，并进行了25年以上的研究和数百万小时的学术研究和工业使用，并......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ocaml/">#ocaml</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1035279.html">为什么Apple Silicon需要开源Fortran编译器</a></div><div class="item_title_en"><a target="_blank" href="https://walkingrandomly.com/?p=6696">Why Apple Silicon Needs an Open Source Fortran Compiler</a><span>(walkingrandomly.com)</span></div><span class="my_story_list_date">2020-11-15 22:54</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1035279.html"><img src="http://img2.diglog.com/img/2020/11/thumb_af8d143b50719ecaa9a259d96854a965.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">本周早些时候，苹果在一次巧妙的营销活动中向世界发布了他们新的基于ARM的“Apple Silicon”机器，我们中的许多人都掏出了信用卡。与此同时，数值算法小组宣布，他们已经将他们的Fortran编译器移植到了新的平台上。在撰写本文时，这是Apple Silicon唯一公开可用的Fortran编译器，不过随着开源Fo......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/开源/">#开源</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/silicon/">#silicon</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fortran/">#fortran</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1034793.html">在锈迹斑斑的情况下编写过多的Brainfuck编译器来学习汇编语言</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/too-many-brainfuck-compilers.md">Learn Assembly by Writing Too Many Brainfuck Compilers in Rust</a><span>(github.com)</span></div><span class="my_story_list_date">2020-11-13 0:36</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1034793.html"><img src="http://img2.diglog.com/img/2020/11/thumb_88fd6ddb8253d4481c2e73bf9c8b9c36.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">嘿，你！你有没有想过成为一名CPU语者？我也是!。我是一名前台网络开发人员，但低级汇编代码和编译器一直让我着迷。我在学习这两个方面都拖延了很长一段时间，但在我最近染上了铁锈，并在很多在线铁锈社区闲逛后，它给了我很大的动力，让我潜入其中。Rustaceans使用奇特的词汇和缩略语，比如自动向量化、内联、对齐、填充、链接......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/汇编/">#汇编</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/brainfuck/">#brainfuck</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/assembly/">#assembly</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1034608.html">铁锈编译程序的PGO探索</a></div><div class="item_title_en"><a target="_blank" href="https://blog.rust-lang.org/inside-rust/2020/11/11/exploring-pgo-for-the-rust-compiler">Exploring PGO for the Rust Compiler</a><span>(blog.rust-lang.org)</span></div><span class="my_story_list_date">2020-11-12 2:30</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1034608.html"><img src="http://img2.diglog.com/img/2020/11/thumb_10c030b2429f801a5aed8756bdece9d2.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">TLDR--PGO使编译器速度更快，但在CI中实现起来并不简单。
在过去的几个月里，Mozilla一直在使用概要引导优化(PGO)来构建他们自己的优化版本Clang，这使得他们的构建基础设施上的Firefox编译时间减少了9%。Rust编译器是否也有同样的可能，也就是说，我们是否可以对rustc本身应用概要引导优化以......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译程序/">#编译程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pgo/">#pgo</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1034422.html">ReactOS最终达到64位(编译ReactOS x86-64和概述)</a></div><div class="item_title_en"><a target="_blank" href="https://www.youtube.com/watch?v=yIwbeO3hh5k">ReactOS finally goes 64 bits (compiling ReactOS x86-64 and overview)</a><span>(www.youtube.com)</span></div><span class="my_story_list_date">2020-11-11 7:1</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1034422.html"><img src="http://img2.diglog.com/img/2020/11/thumb_78bf8eb5520776eb0dc373e25e7916b3.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">如果任何人想尝试在x64上运行ReactOS，这里是我编译的livecd：https://anonfiles.com/n2U1D9ncpa/livecd_iso，另外，我在这个视频中做的可能是一个预告片……</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/reactos/">#reactos</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/livecd/">#livecd</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1034291.html">从内部增强C源代码到源代码的编译器</a></div><div class="item_title_en"><a target="_blank" href="https://hal.inria.fr/hal-02998412">C source-to-source compiler enhancement from within</a><span>(hal.inria.fr)</span></div><span class="my_story_list_date">2020-11-11 0:23</span><div class="my_story_list_item_desc">1加缪-汇编和建筑多核心结构：233382 ICUBE-实验室科学，信息和图像结构：217648 ENGEES-国家学院斯特拉斯堡环境结构：94023；Eau et de l&#39；Eau et de l&39；Eau et de l&39；
Réseau Nanoptonique et Optique Struc......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/源代码/">#源代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/结构/">#结构</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1033846.html">Axelson/dep_viz-了解Elixir重新编译的可视化工具</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/axelson/dep_viz">Axelson/dep_viz – a visual tool to understand Elixir recompilation</a><span>(github.com)</span></div><span class="my_story_list_date">2020-11-8 21:2</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1033846.html"><img src="http://img2.diglog.com/img/2020/11/thumb_555f6e778c18d7acd35491e2d8e5b768.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">其目的是帮助开发人员快速了解他们的项目中有哪些编译依赖项。然后，他们可以采取措施将它们降到最低，以减少编写代码和查看结果之间的反馈循环。
这是否适用于其他图表？答：并非如此，例如，如果起始节点本身是可传递的编译时依赖链的一部分，则图算法需要重新访问起始节点</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/可视化/">#可视化</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/dep/">#dep</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/起始/">#起始</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1033645.html">SQL.js：SQLite编译为JavaScript</a></div><div class="item_title_en"><a target="_blank" href="https://sql.js.org/#/">SQL.js: SQLite Compiled to JavaScript</a><span>(sql.js.org)</span></div><span class="my_story_list_date">2020-11-7 11:23</span><div class="my_story_list_item_desc">Js是一个用于Javascript的SQL库，其中包含为Web编译的SQLite版本。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sqlite/">#sqlite</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1032476.html">迷你编译器：lexing</a></div><div class="item_title_en"><a target="_blank" href="https://christine.website/blog/minicompiler-lexing-2020-10-29">Minicompiler: Lexing</a><span>(christine.website)</span></div><span class="my_story_list_date">2020-10-31 19:54</span><div class="my_story_list_item_desc">我一直想做自己的编译器。编译器是我日常工作中不可或缺的一部分，我经常使用它们的成果。不久前，当我浏览TempleOS源代码时，在：：/Demos/Lessons文件夹中发现了MiniCompiler.HC，我有点吃惊。它实现了一个从简单的数学表达式到AMD64字节码的两阶段编译器(完成后将其比特转换为代码稍后跳转到的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1032053.html">将Lisp编译为x86-64：带标签的过程调用</a></div><div class="item_title_en"><a target="_blank" href="https://bernsteinbear.com/blog/compiling-a-lisp-11/">Compiling a Lisp to x86-64: Labelled procedure calls</a><span>(bernsteinbear.com)</span></div><span class="my_story_list_date">2020-10-30 0:37</span><div class="my_story_list_item_desc">欢迎回到编译Lisp系列。上次，我们学习了智能指令编码。这一次，我们将使用这些知识来编译过程调用。
Lisp中常用的函数表达式是lambda--一个可以接受参数和关闭变量的匿名函数。过程调用不是这样的。它们是更简单的构造，只接受参数并返回值。
我们首先添加过程调用作为完全闭包支持的垫脚石，这将帮助我们建立某种内部调用......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rsp/">#rsp</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1031687.html">每个Brinch Hansen关于编译器的书籍已扫描，页面已更新</a></div><div class="item_title_en"><a target="_blank" href="http://pascal.hansotten.com/per-brinch-hansen/">Per Brinch Hansen books on compilers scanned, page updated</a><span>(pascal.hansotten.com)</span></div><span class="my_story_list_date">2020-10-28 10:6</span><div class="my_story_list_item_desc">布林克·汉森是并发编程和操作系统(内核)的先驱之一。20世纪60年代，布林克·汉森在丹麦计算机公司Regnecentralen工作，最初在Peter Naur和Jørn Jensen领导的编译器小组工作，后来成为RC4000小型机及其著名操作系统内核(RC4000多道编程系统)的首席架构师。1972年，他编写了第一本......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/书籍/">#书籍</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hansen/">#hansen</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1031619.html">Eslisp-ECMAScript/JavaScript的S表达式语法，带有类似Lisp的宏</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/anko/eslisp">Eslisp – An S-expression syntax for ECMAScript/JavaScript, with Lisp-like macros</a><span>(github.com)</span></div><span class="my_story_list_date">2020-10-28 5:7</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1031619.html"><img src="http://img2.diglog.com/img/2020/10/thumb_99f2142c0124e0d0a756ac05f1257d4d.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这并不神奇：它只是estree AST格式的S表达式编码。宏是返回对象的普通JS函数，这些对象只在编译时存在。这意味着宏可以放在NPM上来分发您自己的语言特性，如下所示。
岩心小，靠近JS。此核心eslisp与estree抽象语法树格式紧密对应，因此与输出JSP清晰匹配。除非您使用宏，否则它纯粹是一个语法适配器。
最......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="/tag/编译/">0</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page1.html">1</a></li><li class="page-item active"><a class="page-link" href="/tag/编译/page2.html">2</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page3.html">3</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page4.html">4</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page5.html">5</a></li><li class="page-item"><a class="page-link" href="/tag/编译/page6.html">6</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>