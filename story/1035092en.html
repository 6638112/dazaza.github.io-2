<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>文件充满了危险</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">文件充满了危险</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-14 16:35:24</div><div class="page_narrow text-break page_content"><p>Files are fraught with peril      Let&#39;s talk about files! Most developers seem to think that files are easy. Just for example, let&#39;s take a look at the top reddit r/programming comments from when Dropbox announced that they were only going to support ext4 on Linux (the most widely used Linux filesystem). For people not familiar with reddit r/programming, I suspect r/programming is the most widely read English language programming forum in the world.</p><p>文件充满了危险，让我们来谈谈文件吧！大多数开发人员似乎认为文件很容易。例如，当Dropbox宣布他们只在Linux(最广泛使用的Linux文件系统)上支持ext4时，让我们来看看排名靠前的reddit r/编程评论。对于不熟悉reddit r/编程的人，我怀疑r/编程是世界上阅读量最大的英语编程论坛。</p><p>    I&#39;m a bit confused, why do these applications have to support these file systems directly? Doesn&#39;t the kernel itself abstract away from having to know the lower level details of how the files themselves are stored?</p><p>我有点困惑，为什么这些应用程序必须直接支持这些文件系统？难道内核本身不需要知道文件本身是如何存储的更低层次的细节吗？</p><p>  The only differences I could possibly see between different file systems are file size limitations and permissions, but aren&#39;t most modern file systems about on par with each other?</p><p>我能看到的不同文件系统之间唯一的区别就是文件大小限制和权限，但大多数现代文件系统难道不能相互媲美吗？</p><p>    #2: Shouldn&#39;t that be abstracted as far as &#34;normal apps&#34; are concerned by the OS?</p><p>#2：操作系统关注的普通应用程序不应该抽象吗？</p><p>  Reply: It&#39;s a leaky abstraction. I&#39;m willing to bet each different FS has its own bugs and its own FS specific fixes in the dropbox codebase. More FS&#39;s means more testing to make sure everything works right . . .</p><p>回答：这是一个漏洞百出的抽象概念。我敢打赌，每个不同的文件系统都有自己的缺陷，在Dropbox代码库中有自己的文件系统特定修复程序。更多的文件系统意味着更多的测试，以确保一切正常运行。。。</p><p>  2nd level reply: What are you talking about? This is a dropbox, what the hell does it need from the FS? There are dozenz of fssync tools, data transfer tools, distributed storage software, and everything works fine with inotify. What the hell does not work for dropbox exactly?</p><p>二级回答：你在说什么？这是一个Dropbox，它到底需要从FS那里得到什么？有几十种fssync工具、数据传输工具、分布式存储软件，一切都与intify配合得很好。到底有什么该死的东西对Dropbox不起作用？</p><p>  another 2nd level reply: Sure, but any bugs resulting from should be fixed in the respective abstraction layer, not by re-implementing the whole stack yourself. You shouldn&#39;t re-implement unless you don&#39;t get the data you need from the abstraction. . . . DropBox implementing FS-specific workarounds and quirks is way overkill. That&#39;s like vim providing keyboard-specific workarounds to avoid faulty keypresses. All abstractions are leaky - but if no one those abstractions, nothing will ever get done (and we&#39;d have billions of &#34;operating systems&#34;).</p><p>另一个二级回答是：当然，但是产生的任何错误都应该在各自的抽象层修复，而不是自己重新实现整个堆栈。除非您没有从抽象中获得所需的数据，否则您不应该重新实现。。。。Dropbox实现了特定于文件系统的解决办法和怪癖，这是一种矫枉过正的做法。这就像Vim提供特定于键盘的解决方案来避免错误的按键一样。所有的抽象都是漏洞百出的--但如果没有这些抽象，什么都做不了(我们将拥有数十亿个操作系统)。</p><p>  In this talk, we&#39;re going to look at how file systems differ from each other and other issues we might encounter when writing to files. We&#39;re going to look at the file &#34;stack&#34; starting at the top with the file API, which we&#39;ll see is nearly impossible to use correctly and that supporting multiple filesystems without corrupting data is much harder than supporting a single filesystem; move down to the filesystem, which we&#39;ll see has serious bugs that cause data loss and data corruption; and then we&#39;ll look at disks and see that disks can easily corrupt data at a rate five million times greater than claimed in vendor datasheets.</p><p>在这次演讲中，我们将看看文件系统之间有何不同，以及在写入文件时可能遇到的其他问题。我们将从文件API开始，从顶部开始研究文件堆栈，我们将看到文件API几乎不可能正确使用，支持多个文件系统而不损坏数据要比支持单个文件系统困难得多；向下看文件系统，我们将看到文件系统存在严重的错误，会导致数据丢失和数据损坏；然后我们将查看磁盘，发现磁盘可以轻松地以500万倍的速度损坏数据，这一点我们将会看到，我们将从顶部开始讨论文件API，然后我们将看到，在不损坏数据的情况下支持多个文件系统要比支持单个文件系统困难得多；我们将看到文件系统存在严重的错误，会导致数据丢失和数据损坏；然后我们将查看磁盘，发现磁盘可以轻松地以500万倍的速度损坏数据</p><p>      Let&#39;s say we want to write a file safely, so that we don&#39;t want to get data corruption. For the purposes of this talk, this means we&#39;d like our write to be &#34;atomic&#34; -- our write should either fully complete, or we should be able to undo the write and end up back where we started. Let&#39;s look at an example from Pillai et al., OSDI’14.</p><p>让我们假设我们想要安全地写入文件，这样我们就不会想要数据损坏。就本次演讲而言，这意味着我们希望我们的写入是原子的--我们的写入应该完全完成，或者我们应该能够撤销写入并回到开始的位置。让我们来看看Pillai等人的一个例子，OSDI‘14。</p><p>  We have a file that contains the text  a foo and we want to overwrite  foo with  bar so we end up with  a bar. We&#39;re going to make a number of simplifications. For example, you should probably think of each character we&#39;re writing as a sector on disk (or, if you prefer, you can imagine we&#39;re using a hypothetical advanced NVM drive). Don&#39;t worry if you don&#39;t know what that means, I&#39;m just pointing this out to note that this talk is going to contain many simplifications, which I&#39;m not going to call out because we only have twenty-five minutes and the unsimplified version of this talk would probably take about three hours.</p><p>我们有一个包含文本a foo的文件，我们想用bar覆盖foo，因此我们最终得到了一个bar。我们将做一些简化。例如，您可能应该将我们正在写入的每个字符视为磁盘上的一个扇区(或者，如果您愿意，您可以想象我们正在使用一个假设的高级NVM驱动器)。如果你不知道这是什么意思，不要担心，我只是想指出这一点，我只是想指出，这次演讲将包含许多简化，我不会说出来，因为我们只有25分钟，而这个演讲的简化版本可能需要大约3个小时。</p><p>  To write, we might use the  pwrite syscall. This is a function provided by the operating system to let us interact with the filesystem. Our invocation of this syscall looks like:</p><p>要编写代码，我们可以使用pwrite syscall。这是操作系统提供的让我们与文件系统交互的功能。我们对此系统调用的调用如下所示：</p><p>  pwrite( [file], “bar”, // data to write 3, // write 3 bytes 2) // at offset 2</p><p>PWRITE([文件]，“bar”，//要写入的数据为3，//写入3个字节为2)//偏移量为2。</p><p>  pwrite takes the file we&#39;re going to write, the data we want to write,  bar, the number of bytes we want to write,  3, and the offset where we&#39;re going to start writing,  2. If you&#39;re used to using a high-level language, like Python, you might be used to an interface that looks different, but underneath the hood, when you write to a file, it&#39;s eventually going to result in a syscall like this one, which is what will actually write the data into a file.</p><p>PWRITE采用我们要写入的文件、我们要写入的数据、条形码、我们要写入的字节数、3和要开始写入的偏移量2。如果您习惯于使用高级语言(如Python)，您可能会习惯于一个看起来不同的接口，但在幕后，当您写入一个文件时，它最终会产生一个类似这样的syscall，这就是为什么你会习惯于使用一个看起来不同的接口，但在幕后，当你写入一个文件时，它最终会产生一个类似这样的syscall，这就是为什么你会习惯于使用高级语言(如Python)的接口，但在幕后，当你写到一个文件时，它最终会产生一个类似这样的syscall，这就是为什么。</p><p>  If we just call  pwrite like this, we might succeed and get  a bar in the output, or we might end up doing nothing and getting  a foo, or we might end up with something in between, like  a boo,  a bor, etc.</p><p>如果我们像这样调用pWRITE，我们可能会成功并在输出中得到一条线，或者我们可能什么都不做而得到foo，或者我们可能最终得到介于两者之间的东西，比如boo、bor等等。</p><p>  What&#39;s happening here is that we might crash or lose power when we write. Since  pwrite isn&#39;t guaranteed to be atomic, if we crash, we can end up with some fraction of the write completing, causing data corruption. One way to avoid this problem is to store an &#34;undo log&#34; that will let us restore corrupted data. Before we&#39;re modify the file, we&#39;ll make a copy of the data that&#39;s going to be modified (into the undo log), then we&#39;ll modify the file as normal, and if nothing goes wrong, we&#39;ll delete the undo log.</p><p>这里发生的情况是，当我们写作时，我们可能会崩溃或断电。由于pwrite不能保证是原子的，如果我们崩溃，我们最终可能只完成写入的一小部分，从而导致数据损坏。避免此问题的一种方法是存储撤消日志，这样我们就可以恢复损坏的数据。在我们重新修改文件之前，我们会将要修改的数据复制一份(放入撤消日志中)，然后我们会照常修改文件，如果没有问题，我们会删除撤消日志。</p><p>  If we crash while we&#39;re writing the undo log, that&#39;s fine -- we&#39;ll see that the undo log isn&#39;t complete and we know that we won&#39;t have to restore because we won&#39;t have started modifying the file yet. If we crash while we&#39;re modifying the file, that&#39;s also ok. When we try to restore from the crash, we&#39;ll see that the undo log is complete and we can use it to recover from data corruption:</p><p>如果我们在写入撤消日志时崩溃，那也没问题--我们将看到撤消日志没有完成，我们知道我们不需要还原，因为我们还没有开始修改该文件。(##39；#**$$=“{##**$}”&gt;=。如果我们在修改文件时崩溃，那也没问题。当我们尝试从崩溃中恢复时，我们将看到撤消日志已完成，我们可以使用它从数据损坏中恢复：</p><p>  creat(/d/log) // Create undo logwrite(/d/log, &#34;2,3,foo&#34;, 7) // To undo, at offset 2, write 3 bytes, &#34;foo&#34;pwrite(/d/orig, “bar&#34;, 3, 2) // Modify original file as beforeunlink(/d/log) // Delete log file</p><p>Creat(/d/log)//创建撤消日志写入(/d/log，&#34；2，3，foo&#34；，7)//要撤消，在偏移量2处，写入3个字节，&#34；foo&#34；pwrite(/d/orig，“bar&#34；，3，2)//在取消链接(/d/log)之前修改原始文件(/d/log)//删除日志文件。</p><p>  If we&#39;re using  ext3 or  ext4, widely used Linux filesystems, and we&#39;re using the mode  data=journal (we&#39;ll talk about what these modes mean later), here are some possible outcomes we could get:</p><p>如果我们使用的是广泛使用的ext3或ext4 Linux文件系统，并且我们正在使用模式data=Journal(我们稍后将讨论这些模式的含义)，以下是我们可能得到的一些结果：</p><p>    It&#39;s possible we&#39;ll crash while the log file write is in progress and we&#39;ll have an incomplete log file. In the first case above, we know that the log file isn&#39;t complete because the file says we should start at offset  2 and write  3 bytes, but only one byte,  f, is specified, so the log file must be incomplete. In the second case above, we can tell the log file is incomplete because the undo log format should start with an offset and a length, but we have neither. Either way, since we know that the log file isn&#39;t complete, we know that we don&#39;t need to restore.</p><p>在写入日志文件的过程中，我们可能会崩溃，并且日志文件将不完整。？在上面的第一种情况下，我们知道日志文件没有完成，因为文件说我们应该从偏移量2开始写入3个字节，但只指定了一个字节f，所以日志文件一定是不完整的。在上面的第二种情况下，我们可以看出日志文件是不完整的，因为撤消日志格式应该以偏移量和长度开头，但我们两者都没有。无论哪种方式，因为我们知道日志文件不完整，所以我们知道我们不需要恢复。</p><p>      In the first case, the log file is complete we crashed while writing the file. This is fine, since the log file tells us how to restore to a known good state. In the second case, the write completed, but since the log file hasn&#39;t been deleted yet, we&#39;ll restore from the log file.</p><p>在第一种情况下，日志文件是完整的，我们在写入文件时崩溃了。这很好，因为日志文件告诉我们如何恢复到已知的良好状态。在第二种情况下，写入已完成，但由于日志文件尚未删除，我们将从日志文件恢复。</p><p>      With  data=ordered, there&#39;s no guarantee that the  write to the log file and the  pwrite that modifies the original file will execute in program order. Instesad, we could get</p><p>在DATA=ORDERED的情况下，不能保证对日志文件的写入和修改原始文件的写入将按程序顺序执行。Instesad，我们可以。</p><p>  creat(/d/log) // Create undo logpwrite(/d/orig, “bar&#34;, 3, 2) // Modify file before writing undo log!write(/d/log, &#34;2,3,foo&#34;, 7) // Write undo logunlink(/d/log) // Delete log file</p><p>Creat(/d/log)//创建撤消日志写入(/d/orig，“bar&#34；，3，2)//在写入撤消日志之前修改文件！WRITE(/d/log，&#34；2，3，foo&#34；，7)//写入撤消日志unlink(/d/log)//删除日志文件。</p><p>  To prevent this re-ordering, we can use another syscall,  fsync.  fsync is a barrier (prevents re-ordering) and it flushes caches (which we&#39;ll talk about later).</p><p>为了防止这种重新排序，我们可以使用另一个syscall，fsync。Fsync是一个障碍(防止重新排序)，它会刷新缓存(这一点我们将在后面讨论)。</p><p>  creat(/d/log)write(/d/log, “2,3,foo”, 7)fsync(/d/log) // Add fsync to prevent re-orderingpwrite(/d/orig, “bar”, 3, 2)fsync(/d/orig) // Add fsync to prevent re-orderingunlink(/d/log)</p><p>Creat(/d/log)WRITE(/d/log，“2，3，foo”，7)fsync(/d/log)//添加fsync以防止重新排序pwrite(/d/orig，“bar”，3，2)fsync(/d/orig)//添加fsync以防止重新排序取消链接(/d/log)</p><p>  This works with  ext3 or  ext4,  data=ordered, but if we use  data=writeback, we might see something like:</p><p>这适用于ext3或ext4，data=ordered，但如果我们使用data=Writeback，我们可能会看到类似以下内容：</p><p>    Unfortunately, with  data=writeback, the  write to the log file isn&#39;t guaranteed to be atomic and the filesystem metadata that tracks the file length can get updated before we&#39;ve finished writing the log file, which will make it look like the log file contains whatever bits happened to be on disk where the log file was created. Since the log file exists, when we try to restore after a crash, we may end up &#34;restoring&#34; random garbage into the original file. To prevent this, we can add a checksum (a way of making sure the file is actually valid) to the log file.</p><p>不幸的是，使用DATA=WRITEBACK，不能保证对日志文件的写入是原子的，并且跟踪文件长度的文件系统元数据可以在我们完成日志文件写入之前更新，这将使日志文件看起来像是包含创建日志文件的磁盘上发生的任何位。由于日志文件存在，当我们尝试在崩溃后进行恢复时，我们可能会最终将随机垃圾恢复到原始文件中。为了防止出现这种情况，我们可以向日志文件添加校验和(一种确保文件实际有效的方法)。</p><p>  creat(/d/log)write(/d/log,“…[✓∑],foo”,7) // Add checksum to log file to detect incomplete log filefsync(/d/log)pwrite(/d/orig, “bar”, 3, 2)fsync(/d/orig)unlink(/d/log)</p><p>创建(/d/LOG)写入(/d/LOG，“…。[✓∑]，foo“，7)//向日志文件添加校验和以检测日志文件不完整同步(/d/log)pwrite(/d/orig，”bar“，3，2)fsync(/d/orig)unlink(/d/log)。</p><p>      There&#39;s no log file! Although we created a file, wrote to it, and then fsync&#39;d it. Unfortunately, there&#39;s no guarantee that the directory will actually store the location of the file if we crash. In order to make sure we can easily find the file when we restore from a crash, we need to fsync the parent of the newly created log.</p><p>没有日志文件！尽管我们创建了一个文件，对其进行了写入，然后对其进行了fsync处理。不幸的是，不能保证如果我们崩溃，该目录是否真的会存储文件的位置。为了确保在从崩溃中恢复时可以轻松找到该文件，我们需要同步新创建的日志的父日志。</p><p>  creat(/d/log)write(/d/log,“…[✓∑],foo”,7)fsync(/d/log)fsync(/d) /// fsync parent directorypwrite(/d/orig, “bar”, 3, 2)fsync(/d/orig)unlink(/d/log)</p><p>创建(/d/LOG)写入(/d/LOG，“…。[✓∑]，foo“，7)fsync(/d/log)fsync(/d)/fsync父目录写入(/d/orig，”bar“，3，2)fsync(/d/orig)unlink(/d/log)。</p><p>  There are a couple more things we should do. We shoud also fsync after we&#39;re done (not shown), and we also need to check for errors. These syscalls can return errors and those errors need to be handled appropriately. There&#39;s at least one filesystem issue that makes this very difficult, but since that&#39;s not an API usage thing per se, we&#39;ll look at this again in the  Filesystems section.</p><p>我们还有几件事要做。我们还应该fsync后，我们做了(没有显示)，我们还需要检查错误。这些syscall可能会返回错误，需要适当地处理这些错误。至少有一个文件系统问题使这一点变得非常困难，但由于这本身并不是API使用问题，我们将在文件系统一节中再次讨论这一问题。</p><p>  We&#39;ve now seen what we have to do to write a file safely. It might be more complicated than we like, but it seems doable -- if someone asks you to write a file in a self-contained way, like an interview question, and you know the appropriate rules, you can probably do it correctly. But what happens if we have to do this as a day-to-day part of our job, where we&#39;d like to write to files safely every time to write to files in a large codebase.</p><p>我们现在已经了解了如何安全地编写文件。它可能比我们喜欢的复杂，但它似乎是可行的--如果有人要求您以一种独立的方式(如面试问题)编写文件，并且您知道适当的规则，那么您很可能可以正确地这样做。但是，如果我们必须将此作为日常工作的一部分，每次写入大型代码库中的文件时，我们都希望安全地写入文件，那么会发生什么呢？</p><p>    Pillai et al., OSDI’14 looked at a bunch of software that writes to files, including things we&#39;d hope write to files safely, like databases and version control systems: Leveldb, LMDB, GDBM, HSQLDB, Sqlite, PostgreSQL, Git, Mercurial, HDFS, Zookeeper. They then wrote a static analysis tool that can find incorrect usage of the file API, things like incorrectly assuming that operations that aren&#39;t atomic are actually atomic, incorrectly assuming that operations that can be re-ordered will execute in program order, etc.</p><p>Pillai等人(OSDI‘14)研究了一系列写入文件的软件，包括我们希望安全写入文件的软件，比如数据库和版本控制系统：Leveldb、LMDB、GDBM、HSQLDB、Sqlite、PostgreSQL、Git、Mercurial、HDFS、ZooKeeper。然后，他们编写了一个静态分析工具，可以发现文件API的错误用法，比如错误地假设非原子的操作实际上是原子的，错误地假设可以重新排序的操作将按程序顺序执行，等等。</p><p>  When they did this, they found that every single piece of software they tested except for SQLite in one particular mode had at least one bug. This isn&#39;t a knock on the developers of this software or the software -- the programmers who work on things like Leveldb, LBDM, etc., know more about filesystems than the vast majority programmers and the software has more rigorous tests than most software. But they still can&#39;t use files safely every time! A natural follow-up to this is the question: why the file API so hard to use that even experts make mistakes?</p><p>当他们这样做的时候，他们发现除了SQLite在一种特定模式下测试的每个软件都有至少一个错误。这并不是要打击该软件或该软件的开发人员--从事Leveldb、LBDM等工作的程序员比绝大多数程序员更了解文件系统，而且该软件比大多数软件都有更严格的测试。但他们仍然不能每次都安全地使用文件！一个自然的后续问题是：为什么文件API如此难以使用，以至于连专家都会犯错？</p><p>    There are a number of reasons for this. If you ask people &#34;what are hard problems in programming?&#34;, you&#39;ll get answers like distributed systems, concurrent programming, security, aligning things with CSS, dates, etc.</p><p>造成这种情况的原因有很多。如果你问人们编程中的难题是什么？你会得到诸如分布式系统、并发编程、安全性、与CSS保持一致、日期等方面的答案。</p><p>  And if we look at what mistakes cause bugs when people do concurrent programming, we see bugs come from things like &#34;incorrectly assuming operations are atomic&#34; and &#34;incorrectly assuming operations will execute in program order&#34;. These things that make concurrent programming hard also make writing files safely hard -- we saw examples of both of these kinds of bugs in our first example. More generally, many of the same things that make concurrent programming hard are the same things that make writing to files safely hard, so of course we should expect that writing to files is hard!</p><p>如果我们看看当人们进行并发编程时是什么错误导致错误，我们会发现错误来自于错误地假设操作是原子的，以及错误地假设操作将按程序顺序执行。这些东西使并发编程变得困难，也使编写文件变得安全困难--我们在第一个例子中看到了这两种bug的例子。更广泛地说，使并发编程变得困难的许多事情与使安全地写入文件变得困难的事情是相同的，所以我们当然应该预料到写入文件是困难的！</p><p>  Another property writing to files safely shares with concurrent programming is that it&#39;s easy to write code that has infrequent, non-deterministc failures. With respect to files, people will sometimes say this makes things easier (&#34;I&#39;ve never noticed data corruption&#34;, &#34;your data is still mostly there most of the time&#34;, etc.), but if you want to write files safely because you&#39;re working on software that shouldn&#39;t corrupt data, this makes things more difficult by making it more difficult to tell if your code is really correct.</p><p>对文件的写入与并发编程安全共享的另一个特性是，它很容易编写出现不频繁的、不确定的失败的代码。关于文件，人们有时会说这会让事情变得更容易(我从来没有注意到数据损坏，等等)，但是如果你想安全地写文件，因为你正在使用不应该损坏数据的软件，这会让你更难判断你的代码是否真的正确，所以事情就变得更加困难了。(#34；我从来没有注意到你的数据损坏，你的数据大多数时候仍然在那里，等等)，但是如果你想安全地写文件，因为你正在使用的软件不会损坏数据，这就会让事情变得更加困难，因为它让你的代码更难判断是否真的是正确的。</p><p>    As we saw in our first example, even when using one filesystem, different modes may have significantly different behavior. Large parts of the file API look like this, where behavior varies across filesystems or across different modes of the same filesystem. For example, if we look at mainstream filesystems, appends are atomic, except when using  ext3 or  ext4 with  data=writeback, or  ext2 in any mode and directory operations can&#39;t be re-ordered w.r.t. any other operations, except on  btrfs. In theory, we should all read the POSIX spec carefully and make sure all our code is valid according to POSIX, but if they check filesystem behavior at all, people tend to code to what their filesystem does and not some abtract spec.</p><p>正如我们在第一个示例中看到的，即使使用一个文件系统，不同的模式也可能具有显著不同的行为。文件API的大部分如下所示，其中的行为在不同的文件系统或同一文件系统的不同模式之间有所不同。例如，如果我们查看主流文件系统，则附加是原子的，除非在任何模式下使用ext3或ext4和data=Writeback，或者ext2，并且目录操作不能重新排序。除btrf外的任何其他操作。理论上，我们都应该仔细阅读POSIX规范，并确保我们所有的代码都符合POSIX，但是如果他们检查文件系统的行为，人们倾向于根据他们的文件系统做什么来编码，而不是一些删节的规范。</p><p>  If we look at one particular mode of one filesystem ( ext4 with  data=journal), that seems relatively possible to handle safely, but when writing for a variety of filesystems, especially when handling filesystems that are very different from  ext3 and  ext4, like  btrfs, it becomes very difficult for people to write correct code.</p><p>如果我们看一下一个文件系统的一种特定模式(ext4，data=Journal)，这似乎相对可以安全地处理，但在为各种文件系统编写代码时，特别是在处理与ext3和ext4(如btrf)有很大不同的文件系统时，人们很难编写正确的代码。</p><p>    In our first example, we saw that we can get different behavior from using different  data= modes. If we look at the manpage (manual) on what these modes mean in  ext3 or  ext4, we get:</p><p>在我们的第一个示例中，我们看到使用不同的data=模式可以获得不同的行为。如果我们查看手册页(手册)，了解这些模式在ext3或ext4中的含义，我们会得到：</p><p>  journal: All data is committed into the journal prior to being written into the main filesystem.</p><p>日志：所有数据在写入主文件系统之前都会提交到日志中。</p><p>  ordered: This is the default mode. All data is forced directly out to the main file system prior to its metadata being committed to the journal.</p><p>已订购：这是默认模式。在将所有数据的元数据提交到日志之前，所有数据都会被直接强制传出到主文件系统。</p><p>  writeback: Data ordering is not preserved – data may be written into the main filesystem after its metadata has been committed to the journal.  This is rumoured to be the highest-throughput option. It guarantees internal filesystem integrity, however it can allow old data to appear in files after a crash and journal recovery.</p><p>回写：数据顺序不会保留-数据可能会在其元数据提交到日志后被写入主文件系统。有传言称，这是吞吐量最高的选择。它可以保证内部文件系统的完整性，但它可以允许旧数据在崩溃和日志恢复后出现在文件中。</p><p>  If you want to know how to use your filesystem safely, and you don&#39;t already know what a journaling filesystem is, this definitely isn&#39;t going to help you. If you know what a journaling filesystem is, this will give you some hints but it&#39;s still not sufficient. It&#39;s theoretically possible to figure everything out from reading the source code, but this is pretty impractical for most people who don&#39;t already know how the filesystem works.</p><p>如果你想知道如何安全地使用你的文件系统，而你还不知道什么是日志文件系统，这肯定帮不了你。如果你知道什么是日志文件系统，这会给你一些提示，但这仍然是不够的。从理论上讲，通过阅读源代码就可以弄清楚所有事情，但对于大多数还不知道文件系统如何工作的人来说，这是非常不切实际的。</p><p>  For English-language documentation, there&#39;s lwn.net and the Linux kernel mailing list (LKML). LWN is great, but they can&#39;t keep up with everything, so you LKML is the place to go if you want something comprehensive. Here&#39;s an example of an exchange on LKML about filesystems:</p><p>有关英文文档，请访问LWN.net和Linux内核邮件列表(LKML)。LWN很棒，但他们不能跟上所有的事情，所以如果你想要全面的东西，LKML是你去的地方。以下是LKML上关于文件系统的交流的一个例子：</p><p>  Dev 1: Personally, I care about metadata consistency, and ext3 documentation suggests that journal protects its integrity. Except that it does not on broken storage devices, and you still need to run fsck there.   Dev 2: as the ext3 authors have stated many times over the years, you still need to run fsck periodically anyway.   Dev 1: Where is that documented?   Dev 2: linux-kernel mailing list archives.   FS dev: Probably from some 6-8 years ago, in e-mail postings that I made.</p><p>Dev 1：就我个人而言，我关心元数据的一致性，ext3文档建议日志保护其完整性。不过，它不能在损坏的存储设备上运行，而且您仍然需要在那里运行fsck。Dev 2：正如ext3作者多年来多次声明的那样，无论如何，您仍然需要定期运行fsck。Dev 1：哪里有记录？Dev2：Linux内核邮件列表存档。财政司司长：大概是在6-8年前，在我发的电子邮件帖子里。</p><p>  While the filesystem developers tend to be helpful and they write up informative responses, most people probably don&#39;t keep up with the past 6-8 years of LKML.</p><p>虽然文件系统开发人员往往乐于助人，他们会写出信息量很大的回复，但大多数人可能跟不上过去6-8年的LKML。</p><p>    Another issue is that the file API has an inherent conflict between performance and correctness. We noted before that  fsync is a barrier (which we can use to enforce ordering) and that it flushes caches. If you&#39;ve ever worked on the design of a high-performance cache, like a microprocessor cache, you&#39;ll probably find the bundling of these two things into a single primitive to be unusual. A reason this is unusual is that flushing caches has a significant performance cost and there are many cases where we want to enforce ordering without paying this performance cost. Bundling these two things into a single primitive forces us to pay the cache flush cost when we only care about ordering.</p><p>另一个问题是文件API在性能和正确性之间存在固有的冲突。我们在前面已经注意到，fsync是一个屏障(我们可以用它来强制排序)，它会刷新缓存。如果您曾经从事过高性能缓存(如微处理器缓存)的设计工作，您可能会发现将这两样东西捆绑到一个原语中是不寻常的。这种情况不同寻常的一个原因是，刷新缓存有很大的性能成本，而且在很多情况下，我们希望在不支付此性能成本的情况下强制排序。当我们只关心排序时，将这两件事捆绑到一个原语中会迫使我们支付缓存刷新成本。</p><p>  Chidambaram et al., SOSP’13 looked at the performance cost of this by modifying  ext4 to add a barrier mechanism that doesn&#39;t flush caches and they found that, if they modified software appropriately and used their barrier operation where a full  fsync wasn&#39;t necessary, they were able to achieve performance roughly equivalent to  ext4 with cache flushing entirely disabled (which is unsafe and can lead to data corruption) without sacrificing safety. However, making your own filesystem and getting it adopted is impractical for most people writing user-level software. Some databases will bypass the filesystem entirely or almost entirely, but this is also impractical for most software.</p><p>Chidambaram等人，SOSP‘13通过修改ext4以增加不刷新缓存的屏障机制来研究这一性能代价，他们发现，如果他们适当修改软件，并在不需要完全fsync的情况下使用屏障操作，他们能够在完全禁用缓存刷新的情况下获得与ext4大致相当的性能(这是不安全的，并且可能导致数据损坏)而不牺牲安全性。然而，对于大多数编写用户级软件的人来说，创建自己的文件系统并使其被采用是不切实际的。有些数据库将完全或几乎完全绕过文件系统，但这对大多数软件来说也是不切实际的。</p><p>  That&#39;s the file API. Now that we&#39;ve seen that it&#39;s extraordinarily difficult to use, let&#39;s look at filesystems.</p><p>这就是文件API。既然我们已经了解到它的使用非常困难，那么让我们来看看文件系统的用法吧。</p><p>    If we want to make sure that filessystems work, one of the most basic tests we could do is to inject errors are the layer below the filesystem to see if the filesystem handles them properly. For example, on a write, we could have the disk fail to write the data and return the appropriate error. If the filesystem drops this error or doesn&#39;t handle ths properly, that means we have data loss or data corruption. This is analogous to the kinds of distributed systems faults Kyle Kingsbury talked about in his distributed systems testing talk yesterday (although these kinds of errors are much more straightforward to test).</p><p>如果我们想要确保文件系统正常工作，我们可以做的最基本的测试之一就是在文件系统下面的层注入错误，以查看文件系统是否正确地处理它们。例如，在写入时，我们可能会导致磁盘无法写入数据并返回相应的错误。如果文件系统丢弃了这个错误或者没有正确地处理这个错误，那就意味着我们有数据丢失或数据损坏。这类似于Kyle Kingsbury昨天在他的分布式系统测试演讲中谈到的分布式系统故障(尽管这些类型的错误更容易测试)。</p><p>  Prabhakaran et al., SOSP’05 did this and found that, for most filesystems tested, almost all write errors were dropped. The major exception to this was on ReiserFS, which did a pretty good job with all types of errors tested, but ReiserFS isn&#39;t really used today for reasons beyond the scope of this talk.</p><p>Prabhakaran等人，SOSP‘05做到了这一点，并发现，对于大多数测试的文件系统，几乎所有的写入错误都被删除了。最大的例外是ReiserFS，它在测试所有类型的错误时都做得很好，但ReiserFS现在并没有真正使用，原因超出了本文的讨论范围。</p><p>  We (Wesley Aptekar-Cassels and I) looked at this again in 2017 and found that things had improved significantly. Most filesystems (other than JFS) could pass these very basic tests on error handling.</p><p>我们(韦斯利·阿普特卡-卡塞尔和我)在2017年再次研究了这一点，发现情况有了显著改善。大多数文件系统(JFS除外)都可以通过这些非常基本的错误处理测试。</p><p>  Another way to look for errors is to look at filesystems code to see if it handles internal errors correctly. Gunawai et al., FAST’08 did this and found that internal errors were dropped a significant percentage of the time. The technique they used made it difficult to tell if functions that could return many different errors were correctly handling each error, so they also looked at calls to functions that can only return a single error. In those cases, depending on the function, errors were dropped roughly 2/3 to 3/4 of the time, depending on the function.</p><p>查找错误的另一种方法是查看文件系统代码，看看它是否正确处理内部错误。Gunwai等人，FAST‘08做了这件事，发现内部错误在很大程度上被丢弃了。他们使用的技术使得很难判断可能返回许多不同错误的函数是否正确地处理了每个错误，因此他们还查看了对只能返回单个错误的函数的调用。在这些情况下，根据功能的不同，错误下降的时间大约为2/3到3/4。</p><p>  Wesley and I also looked at this again in 2017 and found significant improvement -- errors for the same functions Gunawi et al. looked at were &#34;only&#34; ignored 1/3 to 2/3 of the time, depending on the function.</p><p>韦斯利和我在2017年也再次研究了这一点，发现了显著的改善--Gunawi等人的相同功能出现了错误。根据功能的不同，只有1/3到2/3的时间被忽略。</p><p>  Gunawai et al. also looked at comments near these dropped errors and found comments like &#34;Just ignore errors at this point. There is nothing we can do except to try to keep going.&#34; (XFS) and &#34;Error, skip block and hope for the best.&#34; (ext3).</p><p>Gunwai等人。我还查看了这些删除的错误附近的评论，发现在这一点上只需忽略错误就可以了。我们无能为力，只能继续前进。犯错误，跳过障碍，抱最好的希望。</p><p>  Now we&#39;ve seen that while filesystems used to drop even the most basic errors, they now handle then correctly, but there are some code paths where errors can get dropped. For a concrete example of a case where this happens, let&#39;s look back at our first example. If we get an  error on  fsync, unless we have a pretty recent Linux kernel (Q2 2018-ish), there&#39;s a pretty good chance that the error will be dropped and it may even get reported to the wrong process!</p><p>现在我们已经看到，尽管文件系统过去甚至可以删除最基本的错误，但它们现在可以正确地处理这些错误，但是有些代码路径可以删除错误。对于发生这种情况的一个具体例子，让我们回顾一下我们的第一个例子。如果我们在fsync上遇到错误，除非我们有一个较新的Linux内核(2018年第二季度)，否则错误很有可能会被删除，甚至可能会被报告给错误的进程！</p><p>  On recent Linux kernels, there&#39;s a good chance the error will be reported (to the corre</p><p>在最新的Linux内核上，很有可能会(向Corre)报告该错误。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://danluu.com/deconstruct-files/">https://danluu.com/deconstruct-files/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fraught/">#fraught</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件系统/">#文件系统</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033508.html"><img src="http://img2.diglog.com/img/2020/11/thumb_34433945ca23b6c223d75f623de56dbc.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033508.html">IBIS-一款PHP工具，可帮助您以标记格式编写电子书并将其转换为PDF</a></div><span class="my_story_list_date">2020-11-6 11:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032532.html"><img src="http://img2.diglog.com/img/2020/11/thumb_67de2ef7326f5b0cfc6201d2a0c3b804.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032532.html">预压缩：进一步压缩已压缩的文件</a></div><span class="my_story_list_date">2020-11-1 3:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031468.html"><img src="http://img2.diglog.com/img/2020/10/thumb_d31768f043a397f45761ccf56624d357.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031468.html">潜入/proc/pid/mem</a></div><span class="my_story_list_date">2020-10-27 21:7</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031258.html"><img src="http://img2.diglog.com/img/2020/10/thumb_2f679d0f803a613d2605ba8877034dec.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031258.html">分布式：将按需文件下载作为文件系统的Torrent客户端</a></div><span class="my_story_list_date">2020-10-26 23:57</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>