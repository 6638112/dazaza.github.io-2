<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>越狱iOS无法运行MacOS应用程序。 我花了一个星期，了解为什么 Jailbroken iOS can't run macOS apps. I spent a week to find out why</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Jailbroken iOS can't run macOS apps. I spent a week to find out why<br/>越狱iOS无法运行MacOS应用程序。 我花了一个星期，了解为什么 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-08 00:20:56</div><div class="page_narrow text-break page_content"><p>I ran command line macOS tools, such as Bash and Geekbench, on a jailbroken iPhone by replacing iOS’s dyld shared cache (all of iOS’s code) with macOS’s. However, graphical apps will never work: macOS’s WindowServer won’t start, since iOS’s drivers are too different.</p><p>我通过替换iOS的Dydd共享缓存（所有IOS的代码）与麦斯科斯队的越野，我在越野的iPhone上运行命令行麦斯科斯工具，如Bash和Geekbench。但是，图形应用程序永远不会有效：麦斯科斯州的Windowserver不会启动，因为iOS的驱动程序太不同了。</p><p>  On the eve of another WWDC, it’s time to reflect on the theme that has linked the past 3 WWDCs: convergence between Apple’s mobile and desktop lines.</p><p>  在另一个WWDC的前夜，是时候反思了与过去3个WWDCS相关的主题：Apple的移动和桌面线之间的融合。</p><p>  design: macOS Big Sur’s iOS-inspired styling, iMacs adopting the iPhone’s square lines and colourful back</p><p>  设计：MacOS Big Sur的IOS启发造型，IMACS采用iPhone的方形线和多彩的背部</p><p> With this unification, many were wondering: if the exact same processor can run macOS and iOS, what’s stopping jailbreakers from running macOS apps on iOS?</p><p> 通过这个统一，许多人想知道：如果完全相同的处理器可以运行麦斯科群岛和iOS，那么停止越狱在iOS上运行麦斯科斯应用程序的越狱？</p><p>  Steve Jobs famously  announced that the iPhone “ran OS X”. After a week’s work,  we determined: that was a lie. While iOS and macOS share a foundation, their driver are different enough to be incompatible.</p><p>  史蒂夫乔布斯着名宣布iPhone“RAN OS X”。经过一周的工作，我们确定：这是一个谎言。虽然iOS和麦克斯共享一个基础，但他们的司机足以不兼容。</p><p> Some part of the iOS kernel/drivers are shared with macOS. For example, both use the same kernel with the same Unix/Darwin foundation.</p><p> iOS内核/驱动程序的某些部分与MACOS共享。例如，两者都使用与同一UNIX / DARWIN基础的相同内核。</p><p> Thus, for running command line apps, all I needed to do was: - replace iOS’s dyld with a patched macOS dyld - replace iOS’s dyld cache with a re-signed macOS dyld cache - hook a few methods in the debugger</p><p> 因此，对于运行命令行应用程序，所有我需要做的是： - 用修补的麦斯科斯骨牌替换iOS的Dydd  - 用重新签名的麦斯科斯芯片缓存替换iOS的Dydd缓存 - 挂钩调试器中的一些方法 </p><p> However, many drivers on iOS and macOS are different, even after Apple Silicon. macOS graphics code doesn’t know how to talk to iOS kernel/drivers, so graphical apps cannot run.</p><p>但是，即使在苹果硅，iOS和摩托斯上的许多驱动程序也是不同的。 MacOS图形代码不知道如何与iOS内核/驱动程序交谈，因此图形应用程序无法运行。</p><p> There’s also no way to replace the iOS kernel and drivers with the macOS equivalents: macOS only supports M1 devices, and no iOS devices past the iPhone X have known bootloader exploits.</p><p> 还没有办法将iOS内核和驱动程序用MacOS等效物替换：麦斯卡斯仅支持M1设备，而iPhone X的IOS设备没有已知的Bootloader漏洞。</p><p> Getting macOS apps to run on iOS would require either a multi-year unification project comparable in scope to Catalyst, or isolate macOS in a VM similar to how Mac OS 9 ran in Classic mode on early OS X.</p><p> 获取IOS上运行的MacoS应用程序将需要一个多年统一项目，其范围与Catalyst的范围相当，或者在VM中隔离MacOS，类似于Mac OS 9在早期OS X上的经典模式中运行的VM中。</p><p> Neither of these options are available for jailbreakers, but they are available for Apple. So the best option is to cross my fingers for macOS-on-iOS in tomorrow’s WWDC.</p><p> 这些选择都没有用于越狱，但它们可供Apple。因此，最好的选择是在明天的WWDC中穿过MacOS-On-iOS的手指。</p><p>  So what happens if I just try to run a macOS application on a jailbroken phone?</p><p>  那么如果我试图在越狱手机上运行麦斯科座应用程序会发生什么？</p><p> All my tests are done on an iPhone 12 running iOS 14.1 and the Taurine (1.0.4) jailbreak. macOS files are taken from macOS 11.4 (although I did early tests with 11.3.1).</p><p> 所有测试都在iPhone 12上运行iOS 14.1和Taurine（1.0.4）越狱。麦斯科斯文件从Macos 11.4获取（尽管我用11.3.1进行了早期测试）。</p><p> If I run a macOS app directly on iOS, such as Geekbench’s command line version, it errors immediately due to missing libraries:</p><p> 如果我直接在iOS上运行麦克斯应用程序，例如geekbench的命令行版本，它会因为缺少的库而立即错误： </p><p> Phone:~ root# /usr/local/zhuowei/geekbench_aarch64dyld: warning: could not load inserted library &#39;/usr/lib/pspawn_payload-stg2.dylib&#39; into hardened process because no suitable image found. Did find:	/usr/lib/pspawn_payload-stg2.dylib: mach-o, but not built for platform macOS	/usr/lib/pspawn_payload-stg2.dylib: mach-o, but not built for platform macOSdyld: Library not loaded: /System/Library/Frameworks/Carbon.framework/Versions/A/Carbon Referenced from: /usr/local/zhuowei/geekbench_aarch64 Reason: image not foundzsh: abort /usr/local/zhuowei/geekbench_aarch64</p><p>电话：〜root＃/ usr / local / lobuowei / geekbench_aarch64ded：警告：无法加载插入的库＆＃39; /usr/lib/pspawn_payload-stg2.dylib&#39;进入硬化过程，因为没有发现合适的图像。确实发现：/usr/lib/pspawn_payload-stg2.dylib：mach-o，但没有为portoon macos / susr/lib/pspawn_payload-stg2.dylib：mack-o构建，但不是用于平台macosdyld：library未加载库： /system/library/frameworks/carbon.framework/versions/a/carbon来自：/ usr / local / zhuowei / geekbench_aarch64原因：图片不是foundzsh：abort / usr / local / zhuowei / geekbench_aarch64</p><p> For apps to run, we need to provide them with all the libraries available on macOS. To do that, we need to load the macOS dyld shared cache.</p><p> 对于运行的应用程序，我们需要为它们提供摩托斯上可用的所有库。为此，我们需要加载MacOS Dyd Shared Cache。</p><p>  The dyld shared cache is a prelinked bundle of all the libraries of on iOS or macOS. It is loaded by  dyld.</p><p>  Dyd Shared Cache是​​IOS或MacOS上所有库的预先链接捆绑包。它由Dyd装载。</p><p> /usr/bin/dyld is the dynamic linker. When a program starts, the kernel loads that program and dyld into memory. dyld then loads all the other libraries needed by a program.</p><p> / usr / bin / dyd是动态链接器。程序启动时，内核将该程序和Dyd加载到内存中。然后，Dyd加载程序所需的所有其他库。</p><p> dyld has multiple debug options documented in  man dyld, and its  source is available online.</p><p> DYLD在MYDLD中有多个调试选项，其源头可在线获取。</p><p> The dyld shared cache is usually shared by all the processes running on a device, but using two dyld flags, we can ask dyld to load our own shared cache file, separate from other processes.</p><p> Dydd共享缓存通常由设备上运行的所有进程共享，但使用两个Dyd标志，我们可以询问Dyd加载自己的共享缓存文件，与其他进程分开。</p><p>  Phone:~ root# DYLD_SHARED_REGION=private DYLD_SHARED_CACHE_DIR=/usr/local/zhuowei /usr/local/zhuowei/geekbench_aarch64 dyld: dyld cache load error: shared cache file is for a different platform</p><p>  手机：〜root＃dyld_shared_region = private dydd_shared_cache_dir = / usr / local / local / local / local / buuowei / geekbench_aarch64 dyld：dyld缓存加载错误：共享缓存文件是针对不同的平台 </p><p> This check is  performed by  validatePlatform: we can bypass it by forcing  MachOFile::currentPlatform to return  Platform::macOS:</p><p>此检查是通过ValidatePlatform执行的：我们可以通过强制Machofile :: CurrentPlatform来绕过它来返回平台:: MacOS：</p><p> I wasn’t able to get my  debugserver to launch an app in suspended mode, so I  made a tiny helper  littlespawn tool which calls  posix_spawn with the suspended flag.</p><p> 我无法让我的debugserver以暂停模式推出一个应用程序，因此我制作了一个小的助手洛提策划工具，呼叫Posix_spawn与暂停的标志。</p><p>    zhuowei-mac:src zhuowei$ lldb /bin/bash(lldb) target create &#34;/bin/bash&#34;Current executable set to &#39;/bin/bash&#39; (x86_64).(lldb) process connect connect://localhost:3335Process 858 stopped* thread #1, stop reason = signal SIGSTOP frame #0: 0x00000001025d5000 dyld`_dyld_startdyld`_dyld_start:-&gt; 0x1025d5000 &lt;+0&gt;: mov x28, sp 0x1025d5004 &lt;+4&gt;: and sp, x28, #0xfffffffffffffff0 0x1025d5008 &lt;+8&gt;: mov x0, #0x0 0x1025d500c &lt;+12&gt;: mov x1, #0x0Target 0: (bash) stopped.(lldb) b dyld`dyld3::MachOFile::currentPlatformBreakpoint 1: where = dyld`dyld3::MachOFile::currentPlatform(), address = 0x00000001025fe01c(lldb) cProcess 858 resumingProcess 858 stopped* thread #1, stop reason = breakpoint 1.1 frame #0: 0x00000001025fe01c dyld`dyld3::MachOFile::currentPlatform()dyld`dyld3::MachOFile::currentPlatform:-&gt; 0x1025fe01c &lt;+0&gt;: mov w0, #0x2 0x1025fe020 &lt;+4&gt;: ret dyld`dyld3::MachOFile::isDylib: 0x1025fe024 &lt;+0&gt;: ldr w8, [x0, #0xc] 0x1025fe028 &lt;+4&gt;: cmp w8, #0x6 ; =0x6 Target 0: (bash) stopped.(lldb) thread return 1</p><p>    Zhuowei-Mac：SRC Zhuowei $ LLDB / BIN / BASH（LLDB）目标创建＆＃34; / BIN / BASH＆＃34;当前可执行文件设置为＆＃39; / bin / bash＆＃39; （x86_64）。（LLDB）进程连接连接：// localhost：3335Process 858停止*线程＃1，停止原因=信号sigstop帧＃0：0x00000001025d5000 dyd`_dyld_startdrddle`_dyld_start： - ＆gt; 0x1025d5000＆lt; + 0＆gt ;: mov x28，sp 0x1025d5004＆lt; sp，x28，＃0xfffffffffffff0 0x1025dffffffff0 0x1025d5008＆lt; mov x0，＃0x0 0x1025d50c＆lt; + 12＆gt ;: mov x1，＃0x0target 0 :( Bash）停止。（LLDB）BYLD`dyld3 :: machofile :: currentplatformbreakpoint 1：其中= dyld`dyld3 :: machofile :: currentplatform（），地址= 0x00000001025fe01c（lldb）cprocess 858 resumingprocess 858停止*线程＃1 ，停止原因=断点1.1帧＃0：0x00000001025fe01c dyld`dyld3 :: machofile :: currentplatform（）dyld`dyld3 :: machofile :: currentplatform： - ＆gt; 0x1025fe01c＆lt; + 0＆gt ;: mov w0，＃0x2 0x1025fe020＆lt; + 4＆gt ;: ret dyld`dyld3 :: machofile :: isdylib：0x1025fe024＆lt; + 0＆gt ;: ldr w8，[x0，＃0xc] 0x1025fe028＆lt; + 4＆gt ;: cmp w8，＃0x6; = 0x6目标0 :( bash）停止。（LLDB）线程返回1</p><p> by returning 1 (Mac) in currentPlatform, the cache passes dyld’s check… but now fails iOS’s code signing check.</p><p> 通过在CurrentPlatform中返回1（Mac），缓存通过Dyd的检查...但是现在失败了iOS的代码签名检查。</p><p>   Phone:~ root# xDYLD_SHARED_REGION=private xDYLD_SHARED_CACHE_DIR=/usr/local/zhuowei/System/Library/Caches/com.apple.dyld ./littlespawn /usr/local/zhuowei/bash dyld: dyld cache load error: code signature registration for shared cache failed</p><p>   电话：〜root #ddyld_shared_region = private xdyld_shared_cache_dir = / usr / local / zhuowei / system / library / caches / com.apple.dyld./littlespawn / usr / local / zhuowei / bash dyld：dyld缓存加载错误：代码签名注册共享缓存失败</p><p>  AMFI: &#39;/private/var/root/osdoubler/macos/System/Library/dyld/dyld_shared_cache_arm64e&#39; is adhoc signed.AMFI: &#39;/private/var/root/osdoubler/macos/System/Library/dyld/dyld_shared_cache_arm64e&#39;: unsuitable CT policy 0 for this platform/device, rejecting signature.</p><p>  AMFI：＆＃39; / private / var / root / osdoubler / macos / system / library / dyld / dyld_shared_cache_arm64e＆＃39;是adhoc签名.amfi：＆＃39; / private / var / root / osdoubler / macos / system / library / dyld / dyld_shared_cache_arm64e＆＃39;：不适合这个平台/设备的CT策略0，拒绝签名。</p><p> An ad-hoc signature is validated entirely in the kernel against a hard-coded list. This means that Taurine, a KPP-less jailbreak, can’t override the signature check.</p><p> ad-hoc签名完全验证在内核中，针对硬编码列表。这意味着牛磺酸，kpp的越狱，不能覆盖签名检查。 </p><p> I needed to re-sign the shared cache with a normal, developer signature. Taurine can then intercept validations and instruct the  amfid daemon to allow the code to execute.</p><p>我需要用正常开发人员签名重新签名共享缓存。然后，牛磺酸可以拦截验证并指示AMFID守护程序允许执行代码。</p><p> To my surprise, Xcode’s  codesign can sign dyld caches, even though this feature is never used: the dyld cache builder always signs its own caches.</p><p> 令我惊讶的是，Xcode的代码可以签署Dyd高速缓存，即使从未使用过此功能：Dydd Cache Builder始终签署自己的缓存。</p><p> I wrote a  script to remove the existing signature and resign the dyld cache. However, loading the new cache causes Taurine’s amfidebilitate to crash while computing the signed dyld cache’s CDHash:</p><p> 我写了一个脚本来删除现有签名并辞职。但是，加载新的缓存导致牛磺琴的大型漏洞在计算签名的Dyld缓存的CDHASH时：</p><p> kernel	EXC_RESOURCE -&gt; amfidebilitate[449] exceeded mem limit: InactiveHard 2098 MB (fatal)kernel	1401.082 memorystatus: killing_specific_process pid 449 [amfidebilitate] (per-process-limit 3) 2331079KB - memorystatus_available_pages: 50117kernel	AMFI: code signature validation failed.osanalyticshelper	Process amfidebilitate [449] killed by jetsam reason per-process-limit</p><p> 内核exc_resource  - ＆gt;大使误合[449]超过MEM限制：InactiveHard 2098 MB（致命）内核1401.082 MemoryStatus：Killing_specific_Process PID 449 [AmfideBilitate]（每次流程限制3）2331079KB  -  MemoryStatus_available_pages：50117Kernel AMFI：代码签名验证失败。由Jetsam原因杀死每次过程限制</p><p> Thankfully, Taurine allows a user to  precompute a file’s CDHash by placing it in  /taurine/cstmp, so I added a step to  extract the CDHash.</p><p> 值得庆幸的是，Taurine允许用户通过将其放入/ Taurine / CSTMP来预先编译文件的CDHASH，因此我添加了一个步骤来提取CDHASH。</p><p> After placing the file, the dyld cache started to load… until the iOS dyld set the wrong memory permission on a section:</p><p> 放置文件后，DYLD缓存已开始加载...直到IOS Dyld设置了一个部分上的错误内存权限：</p><p> Process 974 stopped* thread #1, stop reason = EXC_BAD_ACCESS (code=2, address=0x1f53c8000) frame #0: 0x0000000100e85524 dyld`dyld3::loadDyldCache(dyld3::SharedCacheOptions const&amp;, dyld3::SharedCacheLoadInfo*) + 700dyld`dyld3::loadDyldCache:-&gt; 0x100e85524 &lt;+700&gt;: str x8, [x21] 0x100e85528 &lt;+704&gt;: cbnz x22, 0x100e85500 ; &lt;+664&gt; 0x100e8552c &lt;+708&gt;: b 0x100e85554 ; &lt;+748&gt; 0x100e85530 &lt;+712&gt;: add x9, x24, w8, uxtwTarget 0: (bash) stopped.(lldb) print (void*)$x21(void *) $1 = 0x00000001f53c8000</p><p> 进程974停止*线程＃1，停止原因= exc_bad_access（code = 2，地址= 0x1f53c8000）帧＃0：0x0000000100E85524 Dyld`dyld3 :: loaddyldcache（dyld3 :: sharedcacheOptions contr＆amp; dyld3 :: sharedCacheloadInfo *）+ 700deD`dyld3 :: loaddyldcache： - ＆gt; 0x100e85524＆lt; + 700＆gt; str x8，[x21] 0x100e85528＆lt; + 704＆gt ;: cbnz x22,0x100e85500; ＆lt; + 664＆gt; 0x100e8552c＆lt; + 708＆gt ;: b 0x100e85554; ＆lt; + 748＆gt; 0x100E85530＆lt; + 712＆gt ;:添加x9，x24，w8，uxtwtarget 0 :( bash）停止。（LLDB）打印（VOID *）$ x21（void *）$ 1 = 0x00000001f53c8000 </p><p>   It’s a kludge: we’re going to replace dyld later anyways. For now, this gets us past dyld into a crash in the Objective-C runtime:</p><p>这是一个Kldude：我们以后要更换Dyd。目前，这让我们在Objective-C运行时将DYD陷入了崩溃：</p><p> * thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BAD_ACCESS (code=1, address=0x7c81fb1d9a80) frame #0: 0x000000018fef745c libobjc.A.dylib`addClassTableEntry(objc_class*, bool) + 32libobjc.A.dylib`addClassTableEntry:-&gt; 0x18fef745c &lt;+32&gt;: ldr x8, [x0, #0x20] 0x18fef7460 &lt;+36&gt;: and x8, x8, #0x7ffffffffff8 0x18fef7464 &lt;+40&gt;: ldrh w8, [x8, #0x4] 0x18fef7468 &lt;+44&gt;: adrp x9, 438970Target 0: (bash) stopped.(lldb) bt* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BAD_ACCESS (code=1, address=0x7c81fb1d9a80) * frame #0: 0x000000018fef745c libobjc.A.dylib`addClassTableEntry(objc_class*, bool) + 32 frame #1: 0x000000018fedc5d8 libobjc.A.dylib`_read_images + 2624 frame #2: 0x000000018fedb54c libobjc.A.dylib`map_images_nolock + 2464 frame #3: 0x000000018feecc00 libobjc.A.dylib`map_images + 92 frame #4: 0x0000000100e65b04 dyld`dyld::notifyBatchPartial(dyld_image_states, bool, char const* (*)(dyld_image_states, unsigned int, dyld_image_info const*), bool, bool) + 1672 frame #5: 0x0000000100e65cf0 dyld`dyld::registerObjCNotifiers(void (*)(unsigned int, char const* const*, mach_header const* const*), void (*)(char const*, mach_header const*), void (*)(char const*, mach_header const*)) + 80 frame #6: 0x000000019004e224 libdyld.dylib`_dyld_objc_notify_register + 284</p><p> *线程＃1，队列=＆＃39; com.apple.main-thread＆＃39;，停止原因= exc_bad_access（code = 1，地址= 0x7c81fb1d9a80）帧＃0：0x000000018fef745c libobjc.a.dylib`addclasstableentry（objc_class * ，bool）+ 32libobjc.a.dylib`addclasstableentry： - ＆gt; 0x18fef745c＆lt; + 32＆gt ;: ldr x8，[x0，＃0x20] 0x18fef7460＆lt; x8，x8，＃0x7fffffffff8 0x118fef7464：ldrh w8，[x8，＃0x4] 0x18fef7468＆lt; + 44＆gt ;: ADRP x9,438970target 0 :( bash）停止。（LLDB）BT *线程＃1，队列=＆＃39; com.apple.main-thread＆＃39;，停止原因= exc_bad_access（code = 1，地址= 0x7c81fb1d9a80）*帧＃0：0x000000018fef745c libobjc.a.dylib`addclasstableentry（objc_class *，bool）+ 32帧＃1：0x000000018fedc5d8 libobjc.a.dylib`_read_images + 2624帧＃2：0x000000018fedb54c libobjc.a.dylib`map_images_nolock + 2464帧＃3：0x000000018feeccc00 libobjc.a.dylib`map_images + 92帧＃4：0x0000000100E65b04 dyld`dyld :: notifagatchpartial（dydd_image_states，bool，char const *（*）（dydd_image_states，unsigned int，dyd_image_info const *），bool ，bool）+ 1672帧＃5：0x0000000100e65cf0 dyld`dyld :: greaterobjcnotifiers（void（*）（unsigned int，char const * const *，mach_header const * const *），void（*）（char const *，mach_header const * ），空白（*）（char const *，mach_h eader const *））+ 80帧＃6：0x000000019004e224 libdyld.dylib`_dyld_objc_notify_register + 284</p><p>  The address seems odd:  0x7c81fb1d9a80 is outside of memory, but if we remove the first three digits,  0x1fb1d9a80 is an actual Objective-C class. Where did those digits come from?</p><p>  地址似乎是奇数：0x7c81fb1d9a80在内存之外，但如果我们删除前三位数，0x1fb1d9a80是一个实际的目标-c类。这些数字来自哪里？</p><p> After putting breakpoints, I found that the crashing call is the second (recursive)  addClassTableEntry call that adds the metaclass. To do that, it  fetches the metaclass from the ISA pointer:</p><p> 在放置断点后，我发现崩溃呼叫是添加元类的第二个（递归）addClasstableEntry调用。为此，它从ISA指针获取MetaClass：</p><p>     which is computed at compile time. However,  MACH_VM_MAX_ADDRESS differs on iOS and macOS, since iOS has a smaller address space and uses more bits in the pointer for PAC signatures.</p><p>     这在编译时计算。但是，Mach_VM_MAX_ADDRESS在iOS和MACO上不同，因为IOS具有较小的地址空间，并且在PAC签名中使用指针中的更多位。</p><p> PAC is configured by the kernel, so a macOS app running on an iOS kernel will receive more bits of PAC signature than expected, causing PAC bits to be left over in the pointer after masking.</p><p> PAC由内核配置，因此在iOS内核上运行的MacOS应用程序将收到比预期的更多PAC签名位，导致PAC位在屏蔽后留在指针中。</p><p> The solution was simple:  patch any arm64e apps to launch as arm64 instead, disabling PAC.</p><p> 解决方案简单：修补任何ARM64E应用程序，以便作为ARM64启动，禁用PAC。 </p><p>   (lldb) cProcess 1012 resumingProcess 1012 stopped* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BREAKPOINT (code=1, subcode=0x182700e70) frame #0: 0x0000000182700e70 libsystem_darwin.dylib`_check_internal_content.cold.1 + 24libsystem_darwin.dylib`_check_internal_content.cold.1:-&gt; 0x182700e70 &lt;+24&gt;: brk #0x1libsystem_darwin.dylib`os_variant_has_internal_diagnostics.cold.1: 0x182700e74 &lt;+0&gt;: pacibsp 0x182700e78 &lt;+4&gt;: stp x29, x30, [sp, #-0x10]! 0x182700e7c &lt;+8&gt;: mov x29, spTarget 0: (bash_arm64) stopped.(lldb) bt</p><p>（LLDB）CProcess 1012 Resuming Process 1012停止*线程＃1，队列=＆＃39; com.apple.main-thread＆＃39;，停止原因= exc_breakpoint（code = 1，子码= 0x182700E70）帧＃0：0x0000000182700E70 libsystem_darwin。 dylib`_check_internal_content.cold.1 + 24libsystem_darwin.dylib`_check_internal_content.cold.1： - ＆gt; 0x182700E70＆lt; + 24＆gt ;: brk＃0x1libsystem_darwin.dylib`os_variant_has_internal_diagnostics.cold.1：0x182700e74＆lt; + 0＆gt ;: pacibsp 0x182700e78＆lt; + 4＆gt ;: stp x29，x30，[sp，＃-0x10]！ 0x182700e7c＆lt; + 8＆gt ;: mov x29，sptarget 0 :( bash_arm64）停止。（LLDB）BT</p><p> Turns out macOS and iOS stores  information about build info (beta/internal) in the  kern.osvariant_status sysctl variable. The iOS version has bits set that confused macOS.</p><p> 拒绝MacOS和iOS存储有关在kern.osvariant_status sysctl变量中构建信息（beta /内部）的信息。 iOS版本有位设置困惑的麦克斯。</p><p>   Phone:~ root# xDYLD_SHARED_REGION=private xDYLD_SHARED_CACHE_DIR=/usr/local/zhuowei ./littlespawn /usr/local/zhuowei/bash_arm64dyld: warning: could not load inserted library &#39;/usr/lib/pspawn_payload-stg2.dylib&#39; into hardened process because no suitable image found. Did find:	/usr/lib/pspawn_payload-stg2.dylib: mach-o, but not built for platform macOS	/usr/lib/pspawn_payload-stg2.dylib: mach-o, but not built for platform macOSThe default interactive shell is now zsh.To update your account to use zsh, please run `chsh -s /bin/zsh`.For more details, please visit https://support.apple.com/kb/HT208050.%m%::%~ %n%#</p><p>   手机：〜root＃xdyld_shared_region = private xdyld_shared_cache_dir = / usr / local / local / local / local / local / loce / locawei / bash_arm64ded：警告：无法加载插入的库＆＃39; /usr/lib/pspawn_payload-stg2.dylib&# 39;进入硬化过程，因为没有发现合适的图像。发现：/usr/lib/pspawn_payload-stg2.dylib：mach-o，但不是用于平台macos /usr/lib/pspawn_payload-stg2.dylib：mack-o，但没有为平台macos构建默认交互式shell现在zsh.to更新您的帐户以使用zsh，请运行`chsh -s /bin/zsh`.请访问https://support.apple.com/kb/ht208050.%M%::%〜％ n％＃</p><p> but many other executables still fail to load, because the dyld tries to load iOS libraries from disk:</p><p> 但许多其他可执行文件仍然无法加载，因为DYLD尝试从磁盘加载iOS库：</p><p> xDYLD_SHARED_REGION=private xDYLD_SHARED_CACHE_DIR=/usr/local/zhuowei DYLD_ROOT_PATH=/usr/local/zhuowei ./littlespawn /usr/local/zhuowei/WindowServer_arm64dyld: warning: could not load inserted library &#39;/usr/lib/pspawn_payload-stg2.dylib&#39; into hardened process because no suitable image found. Did find:	/usr/lib/pspawn_payload-stg2.dylib: mach-o, but not built for platform macOS	/usr/lib/pspawn_payload-stg2.dylib: mach-o, but not built for platform macOSdyld: Library not loaded: /usr/lib/libpam.2.dylib Referenced from: /System/Library/Frameworks/Security.framework/Versions/A/Security Reason: no suitable image found. Did find:	/usr/lib/libpam.2.dylib: mach-o, but not built for platform macOS	/usr/lib/libpam.2.dylib: mach-o, but not built for platform macOS	/usr/lib/libpam.2.dylib: mach-o, but not built for platform macOS	/usr/lib/libpam.2.dylib: mach-o, but not built for platform macOS</p><p> xdyld_shared_region = private xdyld_shared_cache_dir = / usr / local / zhuowei dydd_root_path = / usr / local / zhuowei ./littlespawn / usr / local / zhuowei / windowserver_arm64ded：警告：无法加载插入的库＆＃39; / usr / lib / pspawn_payload-stg2 .dylib＆＃39;进入硬化过程，因为没有发现合适的图像。确实发现：/usr/lib/pspawn_payload-stg2.dylib：mach-o，但没有为portoon macos / susr/lib/pspawn_payload-stg2.dylib：mack-o构建，但不是用于平台macosdyld：library未加载库： /usr/lib/libpam.2.dylib来自：/system/library/frameworks/security.framework/versions/a/security原因：未找到合适的图像。确实发现：/usr/lib/libpam.2.dylib：mach-o，但没有为platform macos / susr/lib/libpam2.dylib：mach-o构建，但不是用于平台麦斯科斯/ usr / lib / libpam.2.dylib：mach-o，但不是用于平台麦克斯/ usr/lib/libpam2.dylib：mach-o，但不是为平台麦斯斯建造的</p><p>   It turns out  dyld will always try the  original, unprefixed path as a last resort.</p><p>   它结果将始终尝试原始的，未经配置的路径作为最后的手段。</p><p> To bypass this, I decided to just patch  dyld’s  stat64 method such that, if a path doesn’t begin with  /usr/local/zhuowei, always return file not found.</p><p> 要绕过这一点，我决定只是补丁Dydd的stat64方法，这样，如果路径没有以/ usr / local / zhuowei开始，则始终找不到返回文件。 </p><p> I used a macOS dyld as a base, and added  the extra code on  top of some ClosureWriter stuff that isn’t usually used during app launch.</p><p>我用麦斯科斯骨牌作为基础，并在一些在App Launch期间通常使用的CelutureWriter内容的额外代码添加了额外的代码。</p><p> Since there’s no way to specify which  dyld to use during app launch, I start the app suspended, then run a  tool to replace the dyld in the app’s memory using  vm_remap.</p><p> 由于无法在App Launch期间指定哪个Dyd使用，因此我启动应用程序暂停，然后使用VM_Remap运行一个工具来替换应用程序内存中的Dyd。</p><p>  As a bonus, using a real macOS dyld instead of the iOS one lets us get rid of the  currentPlatform breakpoint and the  mprotect workaround.</p><p>  作为一个奖金，使用真正的麦克斯DYLD而不是iOS一个人让我们摆脱当前平面打破和MProtect解决方法。</p><p>   Phone:~ root# xDYLD_SHARED_REGION=private xDYLD_SHARED_CACHE_DIR=/usr/local/zhuowei ./littlespawn /usr/local/zhuowei/geekbench/Geekbench\ 5.app/Contents/Resources/geekbench_aarch64 dyld: warning: could not load inserted library &#39;/usr/lib/pspawn_payload-stg2.dylib&#39; into hardened process because no suitable image found. Did find:	/usr/lib/pspawn_payload-stg2.dylib: stat() failed with errno=78Geekbench 5.4.1 Tryout : https://www.geekbench.com/Geekbench 5 requires an active Internet connection when in tryout mode and automatically uploads benchmark results to the Geekbench Browser.Buy a Geekbench 5 license from the Primate Labs Store to enable offline use and unlock other features: https://store.primatelabs.com/v5Enter your Geekbench 5 license using the following command line: /usr/local/zhuowei/geekbench/Geekbench 5.app/Contents/Resources/geekbench_aarch64 --unlock &lt;email&gt; &lt;key&gt; Running Gathering system informationSystem Information Operating System macOS 14.1 (Build 18A8395) Model D53gAP Model ID D53gAP Motherboard D53gAP</p><p>   手机：〜root＃xdyld_shared_region = private xdyld_shared_cache_dir = / usr / local / local / local / local / loce / loce / geekbench / geekbench / geekbench \ 5.app/contents/resources/geekbench_aarch64 dyld：警告：无法加载插入的库＆＃ 39; /usr/lib/pspawn_payload-stg2.dylib&#39;进入硬化过程，因为没有发现合适的图像。发现：/usr/lib/pspawn_payload-stg2.dylib：stat（）使用errno = 78geekbench 5.4.1试用：https://www.geekbench.com/geekbench 5在试用模式和自动时需要有效的互联网连接将基准测试结果上传到GeekBench浏览器。宝布从灵长类机Labs商店提供了一个GeekBench 5许可，以启用脱机使用和解锁其他功能：https：//store.primatelabs.com/v5Enter使用以下命令行：/ usr您的GeekBench 5许可证/ local / zhuowei / geekbench / geekbench 5.app/contents/resources/geekbench_aarch64  - 单调＆lt;电子邮件＆gt; ＆lt; key＆gt;运行收集系统信息系统信息操作系统MacOS 14.1（Build 18A8395）型号D53GAP模型ID D53GAP主板D53GAP</p><p> The results were  exactly 30% of a normal iPhone 12 benchmark, likely as a result of iOS throttling background processes.</p><p> 结果恰好是普通iPhone 12基准的30％，可能是iOS限制背景过程的结果。</p><p>  Command line apps run fine on iOS since the Unix API interface between a command line app and the kernel is 30 years old and doesn’t differ from macOS and iOS.</p><p>  命令行应用程序在iOS上运行Fine，因为命令行应用程序和内核之间的UNIX API接口为30岁，并且与MacOS和iOS不同。</p><p> Unfortunately, this doesn’t apply to graphical apps, as iOS’s graphics stack and macOS’s graphics stack were developed separately over a decade.</p><p> 不幸的是，这不适用于图形应用程序，因为iOS的图形堆栈和麦斯科斯群体的图形堆栈在十年上分开开发。 </p><p> Even after macOS adopted some of iOS’s features (eg IOMobileFramebuffer) as part of the Apple Silicon transition, iOS’s graphics and input drivers still present a different interface, and won’t work with a macOS userspace.</p><p>即使在宏之后采用了某些IOS的功能（例如IOMobileFrameBuffer）作为Apple硅转换的一部分，IOS的图形和输入驱动程序仍然存在不同的接口，并且无法与麦斯卡斯空间合作。</p><p> I tried running  WindowServer, responsible for rendering windows on macOS, using my tools. It didn’t work, and shows how much convergence work Apple still needs to do to unify iOS and macOS.</p><p> 我尝试运行Windowserver，负责使用我的工具在麦斯卡斯播放Windows。它不起作用，并显示苹果仍然需要做多少融合工作来统一iOS和麦克斯。</p><p> First, it errored out because  IOHIDSystem, a driver responsible for mouse cursors and keyboard control, is completely missing on iOS. I bypassed that with  -virtualonly, but..</p><p> 首先，它出错的是因为IOHIDSystem，负责鼠标游标和键盘控制的司机在iOS上完全缺少。我用-virtualonly绕过了，但是..</p><p>  IOSurface looks for the  IOSurfaceRoot driver instead of iOS’s  IOCoreSurfaceRoot. Patched that and got…</p><p>  iOSurface寻找iOSurfaceroot驱动程序而不是iOS的Iocoresurfaceroot。修补了......</p><p>  Metal looking for macOS’s  IOAccelerator instead of iOS’s  IOGPU. I tried forcing this, and it didn’t work.</p><p>  金属寻找麦克斯的ioaccelerator而不是ios的iogpu。我试图强迫这个，它没有用。</p><p>  After I set breakpoints to pretend to have 0 screens, skip input initialization, and skip Metal initialization, WindowServer decided to just give up and segfault. (setting  memory debug flags suggest it’s a use-after-free error, since the address is all 0x55s. I guess it didn’t expect 0 screens?)</p><p>  在我设置假装有0个屏幕的断点后，跳过输入初始化，并跳过金属初始化，Windowserver决定放弃和赛格。 （设置内存调试标志表明它是一个使用欠缺错误，因为地址是所有0x55s。我想它不希望0屏幕？）</p><p>     if Apple ever implements reverse-Catalyst, it would probably be in a VM/Classic environment, not seamless: there’s just too many differences and not enough demand to justify another multi-year unification project</p><p>     如果Apple曾经实现了反向催化剂，则可能在VM /经典环境中，而不是无缝：差异太大，需求不足以证明另一个多年统一项目 </p><p>  I should stop doing my research in the last hours before WWDC so I’d have time to revise this post instead of uploading my first draft</p><p>在WWDC之前，我应该停止在最后几个小时内完成研究，所以我有时间修改这篇文章，而不是上传我的第一次草案 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://worthdoingbadly.com/macappsios/">https://worthdoingbadly.com/macappsios/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ios/">#ios</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/macos/">#macos</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/week/">#week</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>