<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>盒子里有什么东西？ </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">盒子里有什么东西？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-19 23:34:10</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/99194f67e5542018f2c1c325832cade0.png"><img src="http://img2.diglog.com/img/2021/4/99194f67e5542018f2c1c325832cade0.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>首先，这一建议很少见到，而且，无论谁说，谁都说它会消失两天，所以胜利，是因为它，编译器可能会在线，如果它想要。</p><p> 第二，如果没有很多背景，如果你没有工作知识，就没有很多背景，这句话是Utternonsense。作为Java开发人员，您可能会想知道我们是否尝试将数字转换为对象（我们的arenot）。事实上，即使是作为铁锈开发商，您也可能刚刚接受了拳击只是一个生命的事实。</p><p> 它＆＃39;只是我们有时要做的一件事，所以编译器停止疯狂的atus，突然开始工作。那个＆＃39;不一定是一个坏话。 ＆＃39; s只是如何良好的编译器诊断，它可以只是tellyou＆＃34;在那里抱着朋友，我真的认为你想要盒子＆＃34;，你可以复制和粘贴解决方案，拼图是破解。</p><p> 但！仅仅因为我们可以在不知道它的情况下获得很长一段时间，而不是意味着我可以抵抗甜蜜的甜蜜诱惑，解释解释的甜蜜甜蜜的细节它实际意味着什么，所以＆＃39;究竟是什么＆＃39 ;重申在这篇文章中。</p><p> 然而，在我们这样做之前，让我们看看一个简单的例子，我们可能会被一位善意的同事们所做的，因为它，＆＃34;只是框＆＃34;</p><p>  每当调用货物新建时，它会生成一个简单的＆＃34;你好世界＆＃34;应用程序，看起来像这样：</p><p>  它是纯洁的，无辜的，没有任何可能失败的东西，这很好。 </p><p>$ Cargo Run编译Whatbox V0.1.0（/ home / amos / ftl / whatbox）完成的dev [未通过+ debuginfo] target 0.47s运行`target / debug / whatbox`hello，world！</p><p>     read_to_string可能会失败！并且它为什么它返回结果＆lt; string，e＆gt;而不仅仅是一个字符串。</p><p> 而且，它也是为什么我们需要调用.unwrap（），从结果＆lt; string，e＆gt;要么：</p><p>  $货物运行--quietthread＆＃39; main＆＃39;闹剧＆＃39;被叫`结果:: unwrap（）`在`err` value：ore {代码：2，种类：notfound，message：＆＃34;没有这样的文件或目录＆＃34; }＆＃39;，src / main.rs：2：59注意：使用`rust_backtrace = 1`环境变量来显示回溯</p><p>   但是，假设我们想在函数内读取一个字符串。我们自己的功能。</p><p>     但它不是我们想要的代码。请参阅，Read_issue函数Feelslike＆＃34;图书馆代码＆＃34;现在，它在我们的应用程序中，但我可以看到函数分成自己的箱子，也许是一个名叫Linux-Info或其他东西的箱子，因为它对其他应用程序有用。</p><p> 所以，即使它在与主要功能相同的箱子中，我也不会在read_issue中引起恐慌的，我在迪斯科舞厅中感到舒适地引起恐慌。 </p><p>相反，我想我也希望read_issue返回结果。因为结果＆lt; t，e＆gt;是一个枚举，可以代表两件事：hassucceeded的操作（我们得到一个t），或者它失败了（我们得到了一个e）。</p><p>  我们知道，当操作成功时，我们得到一个字符串，所以我们知道要选择T.但问题是：我们选择了什么？</p><p> fn main（）{println！ （＆＃34; {}＆＃34;，read_issue（）.unwrap（））} //是什么是`E`应该是什么？ 👇fn read_issue（） - ＆gt;结果＆lt;字符串，E＆gt; {std :: fs :: read_to_string（＆＃34; / etc /问题＆＃34;）}</p><p> 那个问题，那个具体的问题，不是我们真正拥有的一些其他语言的东西，比如...... ECMAScript！我的意思是，javascript！</p><p>  从＆＃34导入{readfilesync}; fs＆＃34; ; function main（）{let问题= readissue（）;安慰 。日志（`$ {问题}`）; }函数readissue（）{readfilesync（＆＃34; / etc / i-do-not-witt-witts＆＃34;）; } 主要的 （ ） ;</p><p> $节点js / index.mjs节点：FS：505 HanderErrorfrombinIning（CTX）; ^错误：Enoent：没有这样的文件或目录，打开＆＃39; / etc / i-do-not-witts＆＃39;在Readfilesync（node：fs：401：35）在Readissue（文件：///home/amos/ftl/whatbox/js/index.mjs：9：5）在主要（文件：//home/amos/ftl/whatbox/js/index.mjs：4：17）文件：///home/amos/ftl/whatbox/js/index.mjs：12：1在modulejob.run（节点：内部/模块/ ESM / module_job：154：23）在Async Loader.import（Neuts：Modules / ESM / Loader：177：24）在Async Object.LoadM中（节点：内部/流程/ ESM_Loader：68：5）{errno：-2，syscall：＆＃39;打开＆＃39;，代码：＆＃39; enoent＆＃39;，路径：＆＃39; / etc / i-do-not-ides＆ ＃39;}</p><p> 我们不必担心阅读是否可以担心阅读可以或不能抛出： </p><p>好吧，也许我们应该！也许我们应该在一个尝试中包装它，只需从任何抛出的任何例外都可以释放。但我们不得不。我们的编程愉快地愉快地散步。</p><p> 在Go，没有例外，但通常有一个指示在其签名中可能会失败。</p><p> 包主要导入（＆＃34; log＆＃34;＆＃34; os＆＃34;）func main（）{问题：= readissue（）日志。 printf（＆＃34;问题=％v＆＃34;问题）} func readissue（）字符串{bs，_：=操作系统。 ReadFile（＆＃34;＆＃34;）返回字符串（BS）}</p><p>   包主要导入（＆＃34; log＆＃34;＆＃34; OS＆＃34;）func main（）{//我们获得了两个值，包括`err`问题，err：= readissue（）// ...如果err！= nil {// ......并处理日志，我们应该检查nil-ness。 Fatalf（＆＃34;致命错误：％+ v＆＃34;，err）}日志。 printf（＆＃34;问题=％v＆＃34;问题）} func Readissue（）（字符串，错误）{bs，err：=操作系统。 ReadFile（＆＃34;＆＃34;）//同样，'readfile`是一个多价值的返回，所以我们需要//首先检查`err`：如果err！= nil {返回＆＃34;＆ ＃34;，err} //只有在这里我们知道读取文件实际上成功：返回字符串（BS），nil}</p><p>  $ go运行go / main.go2021 / 04/17 20:47:37致命错误：打开：没有这样的文件或directoryexit状态1</p><p> 但是，请注意，它没有告诉我们在代码中的何处是错误的，而JavaScript / node.js版本。</p><p> 在那里有一个解决方案，但是bydefault开箱即用，go错误不会捕获堆栈痕迹。 </p><p>然后是那里的生锈，这是三者中最严格的rust，迫使USTO声明一个函数可以失败，强迫我们处理可能在函数中发生的任何错误，但也迫使我们描述＆＃34 ;有可能的错误值是有可能的。</p><p>    $ node js / index.mjsnode：内部/进程/ ESM_LOADER：74内部屏障（＆＃39;错误＆＃39;）。triggerung ackexception（^ woops（使用`node -trace-undaught ...`来显示异常的位置扔了）</p><p> 这不是一个好主意。大多数情况下，因为那么我们不会得到堆栈迹象。</p><p>      $节点js / index.mjs文件：///home/amos/ftl/whatbox/js/index.mjs：7抛出新的错误（＆＃34; Woops＆＃34;）; ^错误：在Readissue（文件：///home/amos/ftl/whatbox/js/index.mms：7：11）在main（文件：///主页/ amos / ftl / whatbox / js / index。 MJS：2：17）AT文件：///home/amos/ftl/whatbox/js/index.mjs：10：1在modulejob.run（节点：内部/ modules / Esm / module_job：154：23）在异步Loader.import（Node：内部/模块/ ESM / LOADER：177：24）在ASYNC Object.LoadMSM（节点：内部/进程/ ESM_Loader：68：5）</p><p> 至于去。你可以＆＃39; t只是说你＆＃39;重新返回一个错误，返回一个字符串。那个＆＃39;好。</p><p>  $ go / main.go＃命令行 -  argipsge / main.go：17：13：不能使用＆＃34; woops＆＃34; （类型字符串）作为返回参数中的类型错误：字符串不实现错误（缺少错误方法）</p><p> 无论你返回什么都是错误的错误，而且有一个替代方案： </p><p>// new返回格式为给定文本的错误。 //即使文本是相同的，每个对新的呼叫也返回一个不同的错误值。 Func new（文本字符串）错误{return＆amp; errorstring {text}}</p><p>   这实现了错误界面。所有接口都要求返回字符串的错误（）方法：</p><p>    这并不是说去的错误处理是在公园散步。</p><p> 几乎所有关于Go的感觉几乎所有文章都指出了这一比特：它＆＃39;虽然太容易忽视了，或者＆＃34;忘记处理＆＃34;去错误：</p><p> Func Readissue（）（字符串，错误）{BS，ERR：= OS。 ReadFile（＆＃34; / etc /问题＆＃34;）err = os。 writefile（＆＃34; / tmp / moss-copy＆＃34; bs，0o644）如果err！= nil {return＆＃34;＆＃34;，err} return字符串（bs），nil}</p><p> Woops！没有警告，没有什么。如果我们无法读取该文件，那么永远错误地错误。这里的问题当然是返回＆＃34;多件事＆＃34;：＆＃34;成功价值＆＃34;和＃34;误差值＆＃34;和它＆＃39;在粉红色发誓不要触摸成功价值，如果你verven＆＃39; t先检查了错误值。</p><p> 并且这个问题并不存在于一种语言中的语言 - 一个生锈结果，结果:: OK（t），或结果:: err（e），从不兼而有之。 </p><p>然后我们可以将其作为错误返回。因为错误是一个接口，而* naugtyerror有一个错误的方法返回一个字符串，一切都很紧身，繁荣，组成，好！</p><p>   但是，如果我们不小心返回了一个类型的* naugtyerror的价值，那么justhappens就是零，好吧......</p><p> 包主要导入（＆＃34; log＆＃34;）func Readissue（）（字符串，错误）{var Err * naughtyError日志。 Printf（＆＃34;（在Readissues中）是错误的吗？％v＆＃34;，err == nil）返回＆＃34;＆＃34;，err} func main（）{问题，err：= readissue（）日志。如果err！= nil {log，printf（＆＃34;（主要）是err nil？％v＆＃34;，err == nil）。 Fatalf（＆＃34;致命错误：％+ v＆＃34;，err）}日志。 printf（＆＃34;问题=％v＆＃34;问题）} //类型naughtyerror struct {} func（ne * naugtyerror）错误（）字符串{return＆＃34; ob no＆＃34;}</p><p> $ go运行go / main.go2021 / 04/17 21:08:08（在Readissue）是错误的吗？ True2021 / 04/17 21:08:08（主要）是错误吗？ False2021 / 04/17 21:08:08致命错误：oh noxit状态1</p><p>   第一个问题，＆＃34;忘记检查nil＆＃34;很容易理解。韦尔托你错误的地方。只是不要忘记检查一下。它易于Fitinto One＆＃39; Go的心理模型，这是真正简单的宣传。</p><p>    我们上次顽皮的示例计划中有两个错误的值。其中一个比例等于nil，另一个没有。</p><p>  包主要导入（＆＃34; log＆＃34;＆＃34;不安全＆＃34;）func readissue（）（字符串，错误）{var err * naughtyerror日志。 printf（＆＃34;（readissuee）nil？％v，size =％v＆＃34;，err == nil，不安全。sizeof（错误））返回＆＃34;＆＃34;，err} func main（ ）{问题，err：= readissue（）日志。 printf（＆＃34;（主要）nil？％v，size =％v＆＃34;，err == nil，不安全。如果err！= nil {log {log。 Fatalf（＆＃34;致命错误：％+ v＆＃34;，err）}日志。 printf（＆＃34;问题=％v＆＃34;问题）} //类型naughtyerror struct {} func（ne * naugtyerror）错误（）字符串{return＆＃34; ob no＆＃34;} </p><p>进口不安全的软件包可能是不可移植的，不受兼容性指南的保护。</p><p> ......但我们在这里做什么是完全无害的。重要的位，正如Iyunderstand，就是作为一个去开发人员，你＆＃39;重申不应该关心。</p><p> 你＆＃39;重申不应该看这些东西。 Go很简单！字节切片arstrings！ Go没有指针算术！谁关心一种类型的态度！</p><p> 直到你照顾，然后，嗯，你自己＆＃39;他们自己。和＃34;使用不安全＆＃34; isexactly在这里自行。但它＆＃39;好吧。我们＆＃39;所有这些都在我们的唯一。</p><p>  $ go运行go / main.go2021 / 04/17 21:19:12（在Readissue）nil？真实的，大小= 82021/04/17 21:19:12（主要）零？ FALSE，SIZE = 162021/04/17 21:19:12致命错误：OH Noxit状态1</p><p>  这是一个示例，给出足够的时间，人们可以自己弄清楚自己的选择。但是当面对面坠落时，当伊萨已经有一段时间时，它就是......令人费解的。</p><p>    指针的零值为nil，所以它等于nil。和我们＆＃39;在64位Linux上（井，i＆＃39; m），因此指针的大小为64位或8个字节。 </p><p>如果你＆＃39;从一台byte isn＆＃39; t 8位的机器读取这一点，请发一张照片。</p><p> 第二行更令人惊讶 - 不仅它不等于零，而且，它也是两倍的两倍。</p><p>  包主要导入（＆＃34; log＆＃34;）func main（）{var err错误err =（* naugtyerror）（nil）日志。 printf（＆＃34;％v＆＃34; err）err =（* niceError）（nil）日志。 printf（＆＃34;％v＆＃34; err）} type naugtyerror struct {} func（ne * naugtyerror）错误（）字符串{return＆＃34; ob＆＃34;} type niceerror struct {} func（ne * niceError）错误（）字符串{返回＆＃34;何浩浩！＆＃34;}</p><p> 多么愉快的假期主题错误。我们有两个零价值观，他们涉现不同的东西！</p><p>    因为这些值都是nil！但是，uhhh充当interfacevalue（对于错误界面），它们的行为方式不同！</p><p>  因此错误界面值的大小是16个字节，因为...有......＆＃39; stwo指针！</p><p>      ＆＃34;悲伤和＃34;它，即。要从界面类型转到混凝土类型： </p><p>包主要导入（＆＃34;错误＆＃34;＆＃34; log＆＃34;）func showtype（错误错误）{//👇越震惊的操作如果_，好的话：= err。（* naughtyerror）;好的{log。 printf（＆＃34;有一个* naugtyerror＆＃34;）}如果_，好的：= err。（* niceError）;好的{log。 printf（＆＃34;得到了一个* niceError＆＃34;）} else {log。 printf（＆＃34;得到了另一种错误＆＃34;）} func main（）{showtype（（* naugtyerror）（nil））showtype（（* niceError）（nil））showtype（错误。新（＆＃ 34;＆＃34;））} type naugtyerror struct {} func（ne * naugtyerror）错误（）字符串{return＆＃34; ob＆＃34;} type nicereror struct {} func（ne * niceError）错误（）字符串{返回＆＃34;何浩浩！＆＃34;}</p><p> $ go / main.go2021 / 04/17 21:33:48 GOT a * naugtyerror2021 / 04/17 21:33:48 GOT A * NiceError2021 / 04/17 21:33:48得到了另一种错误</p><p> 啊，所以神秘解决了！一个指针的值，一个指针为类型：8个字节，每个，一起，16个字节。</p><p>        但是......还有一个标准错误类型。除了生锈，资本化并非意味着＆＃34;私人或公共和＃34; （那里有关键字）。相反，所有类型的所有类型都是大写的，所以它＆＃39; s不是错误，它＆＃39; s错误。</p><p>   //👇我们在这里导入它使用std ::错误::错误; fn main（）{println！ （＆＃34; {}＆＃34;，read_issue（）.unwrap（））} //并使用它👇fn read_issue（） - ＆gt;结果＆lt;字符串，错误＆gt; {std :: fs :: read_to_string（＆＃34; / etc /问题＆＃34;）}</p><p>  $货物跑步 -  Quietwarning：没有明确的“dyn`的特质物品被贬值 - ＆gt; src / main.rs：7：35 | 7 | fn read_issue（） - ＆gt;结果＆lt;字符串，错误＆gt; {| ^^^^^^帮助：使用`dyn`：`dyn错误` =注意：`＃[warn（baren_trait_objects）]`默认情况下（省略休息）</p><p> 哦，不，警告！它说要使用dyn关键字。好吧，谁是ITO对象，让＆＃39; s使用dyn关键字。 </p><p>$ Cargo Run --quieterror [E0277]：类型的大小为`（Dyn STD ::错误:: error +＆＃39;静态）`不能在编译时已知 - ＆gt; src / main.rs：7：20 | 7 | fn read_issue（） - ＆gt;结果＆lt;字符串，dyn error＆gt; {| ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^ ^^ ^^＆＃39; t在编译时已知尺寸| ::: /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:241:20 | 241 | PUB枚举结果＆lt; t，e> {| - 在“STD ::”结果::结果：结果界定的界限= help：trait`大小`未实现`（dyn std :: serrer :: serror +＆＃39;静态）`错误：由于上一个错误而中止</p><p>       使用std ::错误::错误; fn main（）{println！ （＆＃34; {}＆＃34;，read_issue（）.unwrap（））} //👇fn read_issue（） - ＆gt;结果＆lt;字符串，框＆lt; Dyn错误＆gt; ＆gt; {std :: fs :: read_to_string（＆＃34; / etc /问题＆＃34;）}</p><p>  $货物运行 -  quieterror [e0308]：无匹配类型 - ＆gt; src / main.rs：8：5 | 7 | fn read_issue（） - ＆gt;结果＆lt;串，框＆lt; dyn＆gt;＆gt; {| ---------------------------------结果::结果＆lt;串，框＆lt; :: errat +＆＃39;静态）＆gt;＆gt;“因为返回type8 | std :: fs :: read_to_string（＆＃34; / etc /问题＆＃34;）| ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^预计struct`box`，找到struct` std :: io ::错误'| =注意：预期enum`STD ::结果::结果＆lt; _，box＆lt;（dyn std :: serr :: error +＆＃39;静态）＆gt;＆gt;`找到enum` std ::结果::结果＆lt; _，std :: io ::错误＆gt;`错误：由于上一个错误而中止</p><p>    我们走了。现在我们甚至是re。这是最接近的我们＆＃39; ll到来的守则。</p><p>   好吧，暂时，你可以对它作为指针进行思考。</p><p>   struct myereror {value：u32，} fn main（）{让e = myError {value：32};让e_ptr：* const myError =＆amp; e; print_error（e_ptr）;} fn print_error（e：* const myError）{如果e！= std :: ptr :: null（）{println！ （＆＃34; myError（value = {}）＆＃34;，不安全{（* e）.value}; }}</p><p>   fn print_error（e：* const myError）{如果e！= std :: ptr :: null（）{//👇println！ （＆＃34; myError（value = {}）＆＃34;，不安全{（* e）.value}; }} </p><p>为什么取消引用指针不安全？好吧，因为它可能是空！ ORIT可能指向没有落在一个区域内的地址;对于当前正在运行的程序而言，它会导致ASEGING FOURT。</p><p>   struct myereror {value：u32，} fn main（）{让e = myError {value：32};让e_ptr：* const myError =＆amp; e; //👇没有不安全！ DBG！ （std :: mem :: size_of_val（＆amp; e_ptr））; print_error（e_ptr）;} fn print_error（e：* const myError）{如果e！= std :: ptr :: null（）{println！ （＆＃34; myError（value = {}）＆＃34;，不安全{（* e）.value}; }}</p><p>  并且，正如所预期的那样，指针的大小是8字节，因为我＆＃39; m instwriting从linux 64位。</p><p> 但是：如果构建指针值是安全的，请解释它（从它指向的内存读取或写入它）不是。</p><p>   struct myereror {value：u32，} fn main（）{让e = myError {value：32};让e_ref：＆amp; myerror =＆amp; e; DBG！ （std :: mem :: size_of_val（＆amp; e_ref））; print_error（e_ref）;} fn print_error（e：＆amp; myError）{println！ （＆＃34; myError（value = {}）＆＃34;（* e）.value）;}</p><p>   ......但它们也非常安全地对解除引用，因为它可以保证它们指向有效内存：在安全的代码中，无法构建无效的参考，或者在释放估值后保持参考一些值。</p><p> 事实上，它如此安全，我们甚至需要使用*运营商才能使用：我们可以依靠＆＃34; autoderef＆＃34 ;: </p><p>现在，关于安全的快速记录：你＆＃39;请注意，我只是说＆＃34; Insafe代码，无法构建无效的参考文献＆＃34;</p><p>  struct myerror {value：u32，} fn main（）{让e：* const myError = std :: ptr :: null（）; // ooooh否否。犯罪！ 👇让e_ref：＆amp; myerror =不安全{＆amp; * e}; DBG！ （std :: mem :: size_of_val（＆amp; e_ref））; print_error（e_ref）;} fn print_error（e：＆amp; myError）{println！ （＆＃34; myError（value = {}）＆＃34;，e.value）;}</p><p>      这个想法是，如果所有不安全的代码都是声音，那么所有安全的码头都安全。</p><p> 而且你有很多少量＆＃34;不安全＆＃34;代码比你＆＃34;安全＆＃34;代码，这使得审计更容易。它也是非常可见的，具有明确的不安全块，不安全的特征和不安全的函数，所以它＆＃39;很容易静态地确定不安全的码头 - 它＆＃39; s不只是＆＃34;你进口禁止包＆＃34;你进口禁止包＆＃34 ＃34;</p><p> 最后，在那里的工具如miri interpreter，那就帮助了不安全的代码，就像那里的c / c ++的消毒者那里，没有那些安全/ unsafeplit。</p><p>  所以，我们看到两种＆＃34;指针＆＃34;到目前为止，迄今为止：原始指针，AKA * const t（及其兄弟姐妹，* mut t）和参考（＆amp; t和＆amp; mut t）。</p><p>  在Go，当您对对象的指针时，可以使用它。 YouCan只要你想要，你就可以把它推到地图上 - 即使是最初是释放的，你也是，你作为一个函数，你可以伸出一个指向该对象的指针，可以扩展寿命 </p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fasterthanli.me/articles/whats-in-the-box">https://fasterthanli.me/articles/whats-in-the-box</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/盒子/">#盒子</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/box/">#box</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1054013.html"><img src="http://img2.diglog.com/img/2021/3/thumb_a15c83e7e8abc15a76ac2b5c4fb126b3.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1054013.html">来源：盒子正在探索销售，讨论与其他公司和体育股份公司的潜在协议，在对冲基金右舷的压力下，对股票表现的压力 </a></div><span class="my_story_list_date">2021-3-23 0:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1041526.html"><img src="http://img2.diglog.com/img/2020/12/thumb_bc35181bafbde300c0436c56df189da7.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1041526.html">礼品指南：最后一刻订阅，可全年保留礼品 </a></div><span class="my_story_list_date">2020-12-24 7:48</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032352.html"><img src="http://img2.diglog.com/img/2020/10/thumb_ff78cd858b996b6228feb1aaa5d9528b.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032352.html">亚马逊描述警告称，“新”Moto Razr可能会带着指纹到达</a></div><span class="my_story_list_date">2020-10-31 2:52</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032341.html"><img src="http://img2.diglog.com/img/2020/10/thumb_627b4c4ae4f3aa068b3ef536210ba2fb.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032341.html">亚马逊正在打开全新的Razr盒子以折叠手机，以确保运输安全</a></div><span class="my_story_list_date">2020-10-31 2:40</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>