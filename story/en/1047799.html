<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>丰托里奥 Functorio</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Functorio<br/>丰托里奥 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-17 18:32:48</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/ee4502357b828ede11513e76b9052cb9.png"><img src="http://img2.diglog.com/img/2021/2/ee4502357b828ede11513e76b9052cb9.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>You might have heard people say that functional programming is more academic, and real engineering is done in imperative style. I’m going to show you that real engineering is functional, and I’m going to illustrate it using a computer game that is designed by engineers for engineers. It’s a simulation game called Factorio, in which you are given resources that you have to explore, build factories that process them, create more and more complex systems, until you are finally able to launch a spaceship that may take you away from an inhospitable planet. If this is not engineering at its purest then I don’t know what is. And yet almost all you do when playing this game has its functional programming counterparts and it can be used to teach basic concepts of not only programming but also, to some extent, category theory. So, without further ado, let’s jump in.</p><p>您可能已经听说过人们说函数式编程更具学术性，而实际的工程则以命令式进行。我将向您展示真正的工程是可行的，并且我将使用由工程师为工程师设计的计算机游戏来说明这一点。这是一个名为Factorio的模拟游戏，在其中您将获得探索，建立处理它们的工厂，创建越来越复杂的系统的资源，直到最终能够发射可能将您带离荒凉星球的太空船。如果这不是最纯粹的工程，那么我不知道这是什么。然而，玩此游戏时几乎所有您要做的事情都具有与功能编程相对应的功能，并且它可以用来教授编程的基本概念，并且在某种程度上还可以教授类别理论。因此，事不宜迟，让我们开始吧。</p><p>  The building blocks of every programming language are functions. A function takes input and produces output. In Factorio they are called assembling machines, or assemblers. Here’s an assembler that produces copper wire.</p><p>  每种编程语言的构造块都是函数。一个函数接受输入并产生输出。在Factorio中，它们称为组装机或组装机。这是生产铜线的装配工。</p><p>  If you bring up the info about the assembler you’ll see the recipe that it’s using. This one takes one copper plate and produces a pair of coils of copper wire.</p><p>  如果显示有关汇编程序的信息，则会看到其使用的配方。这一个拿一个铜板，并产生一对铜线线圈。</p><p>  This recipe is really a function signature in a strongly typed system. We see two types: copper plate and copper wire, and an arrow between them. Also, for every copper plate the assembler produces a pair of copper wires. In Haskell we would declare this function as</p><p>  该配方实际上是强类型系统中的功能签名。我们看到两种类型：铜板和铜线，以及它们之间的箭头。而且，对于每个铜板，组装人员都会生产一对铜线。在Haskell中，我们将此函数声明为</p><p>  Not only do we have types for different components, but we can combine types into tuples–here it’s a homogenous pair  (CopperWire, CopperWire). If you’re not familiar with Haskell notation, here’s what it might look like in C++:</p><p>  我们不仅具有用于不同组件的类型，而且可以将类型组合成元组-这里是同质对（CopperWire，CopperWire）。如果您不熟悉Haskell表示法，则可能是C ++中的样子：</p><p>    It takes a pair of iron plates and produces an iron gear wheel. We could write it as</p><p>    它需要一对铁板，并产生一个铁齿轮。我们可以写成</p><p>    Many recipes require a combination of differently typed ingredients, like the one for producing red science packs</p><p>    许多食谱需要组合使用不同类型的成分，例如用于生产红色科学包装的成分 </p><p>   Pairs are examples of product types. Factorio recipes use the plus sign to denote tuples; I guess this is because we often read a sum as “this and this”, and “and” introduces a product type. The assembler requires  both inputs to produce the output, so it accepts a product type. If it required either one, we’d call it a  sum type.</p><p>配对是产品类型的示例。 Factorio配方使用加号表示元组；我猜这是因为我们经常将总和读为“ this and this”，而“ and”则介绍了一种产品类型。汇编器需要两个输入才能产生输出，因此它接受产品类型。如果需要两者之一，我们将其称为求和类型。</p><p> We can also tuple more than two ingredients, as in this recipe for producing electronic circuits (or green circuits, as they are commonly called)</p><p> 我们还可以将两种以上的成分进行元组化，如本生产电子电路（或绿色电路，通常称为绿色电路）的配方中所述</p><p>   Now suppose that you have at your disposal the raw ingeredients: iron plates and copper plates. How would you go about producing red science or green circuits? This is where function composition kicks in. You can pass the output of the copper wire assembler as the input to the green circuit assembler. (You will still have to tuple it with an iron plate.)</p><p>   现在假设您拥有原始的成分：铁板和铜板。您将如何生产红色科学或绿色电路？这是功能组合的开始。您可以将铜线组装器的输出作为输入传递给绿色电路组装器。 （您仍将必须用铁板将其记录下来。）</p><p>          You start with one copper plate and two iron plates. You feed the iron plates to the gear assembler. You pair the resulting gear with the copper plate and pass it to the red science assembler.</p><p>          您从一个铜板和两个铁板开始。将铁板送入齿轮装配器。您将生成的齿轮与铜板配对，然后将其传递给红色的科学装配工。</p><p> Most assemblers in Factorio take more than one argument, so I couldn’t come up with a simpler example of composition, one that wouldn’t require untupling and retupling. In Haskell we usually use functions in their curried form (we’ll come back to this later), so composition is easy there.</p><p> Factorio中的大多数汇编程序都采用不止一个参数，因此我无法提出一个更简单的组合示例，而该示例不需要重新组合。在Haskell中，我们通常以咖喱形式使用函数（我们稍后会再介绍），因此在这里编写起来很容易。</p><p> Composition is also a feature of a category, so we should ask the question if we can treat assemblers as arrows in a category. Their composition is obviously associative. But do we have an equivalent of an identity arrow? It is something that takes input of some type and returns it back unchanged. And indeed we have things called inserters that do exactly that. Here’s an inserter between two assemblers.</p><p> 合成也是类别的功能，因此我们应该问一个问题，是否可以将汇编程序视为类别中的箭头。它们的组成显然是缔合的。但是，我们有等同于身份的箭头吗？它需要某种类型的输入并将其返回原样。实际上，确实有一些称为插入程序的东西可以做到这一点。这是两个汇编器之间的插入器。</p><p>  In fact, in Factorio, you have to use an inserter for direct composition of assemblers, but that’s an implementation detail (technically, inserting an identity function doesn’t change anything).</p><p>  实际上，在Factorio中，您必须使用插入程序来直接编写汇编程序，但这只是实现细节（从技术上讲，插入标识函数不会改变任何内容）。 </p><p>    But the Factorio category has more structure. As we have seen, it supports finite products (tuples) of arbitrary types. Such a category is called  cartesian. (We’ll talk about the unit of this product later.)</p><p>但是Factorio类别具有更多结构。如我们所见，它支持任意类型的有限乘积（元组）。这样的类别称为笛卡尔。 （稍后我们将讨论此产品的单位。）</p><p> Notice that we have identified multiple Factorio subsystem as functions: assemblers, inserters, compositions of assemblers, etc. In a programming language they would all be just functions. If we were to design a language based on Factorio (we could call it  Functorio), we would enclose the composition of assemblers into an assembler, or even make an assembler that takes two assemblers and produces their composition. That would be a higher-order assembler.</p><p> 请注意，我们已经将多个Factorio子系统标识为函数：汇编程序，插入程序，汇编程序的组合等。在编程语言中，它们都只是函数。如果我们要设计基于Factorio的语言（我们可以称其为Functorio），则需要将汇编程序的组成部分封装到一个汇编程序中，或者甚至制作一个需要两个汇编程序并产生其组成部分的汇编程序。那将是一个更高阶的汇编器。</p><p>  The defining feature of functional languages is the ability to make functions first-class objects. That means the ability to pass a function as an argument to another function, and to return a function as a result of another function. For instance, we should have a recipe for producing assemblers. And, indeed, there is such recipe. All it needs is green circuits, some gear wheels, and a few iron plates:</p><p>  功能语言的定义特征是使功能成为一流对象的能力。这意味着可以将函数作为参数传递给另一个函数，并可以将结果作为另一个函数的结果返回。例如，我们应该有一个生产汇编器的诀窍。而且确实有这样的配方。它所需要的只是绿色电路，一些齿轮和一些铁板：</p><p>  If Factorio were a strongly typed language all the way, there would be separate recipes for producing different assemblers (that is assemblers with different recipes). For instance, we could have:</p><p>  如果Factorio一直是强类型语言，那么将有单独的配方来生成不同的汇编程序（即具有不同配方的汇编程序）。例如，我们可能有：</p><p>  Instead, the recipe produces a generic assembler, and it lets the player manually set the recipe in it. In a way, the player provides one last ingredient, an element of the enumeration of all possible recipes. This enumeration is displayed as a menu of choices:</p><p>  取而代之的是，配方产生一个通用的汇编程序，它使玩家可以在其中手动设置配方。在某种程度上，玩家提供了最后一种成分，即所有可能配方的枚举元素。该枚举显示为选项菜单：</p><p>   Since we have identified the inserter as the identity function, we should have a recipe for producing it as well. And indeed there is one:</p><p>   由于我们已将插入程序标识为标识函数，因此我们也应该有一个生成它的方法。确实有一个：</p><p>  Do we also have functions that take functions as arguments? In other words, recipes that use assemblers as input? Indeed we do:</p><p>  我们是否还有以函数为参数的函数？换句话说，使用汇编程序作为输入的配方？实际上，我们这样做： </p><p>  Again, this recipe accepts a generic assembler that hasn’t been assigned its own recipe yet.</p><p>同样，此配方接受尚未分配其自己的配方的通用汇编程序。</p><p> This shows that Factorio supports higher-order functions and is indeed a functional language. What we have here is a way of treating functions (assemblers) not only as arrows between objects, but also as objects that can be produced and consumed by functions. In category theory, such objectified arrow types are called exponential objects. A category in which arrow types are represented as objects is called  closed, so we can view Factorio as a cartesian closed category.</p><p> 这表明Factorio支持高阶函数，并且确实是一种功能语言。这里我们所拥有的是一种不仅将函数（汇编器）视为对象之间的箭头，而且还将其视为可以由函数生成和使用的对象的方法。在类别理论中，这样的物化箭头类型称为指数对象。以箭头类型表示为对象的类别称为封闭类别，因此我们可以将Factorio视为笛卡尔封闭类别。</p><p>              There is one important aspect of functional programming that seems to be broken in Factorio. Functions are supposed to be pure: mutation is a no-no. And in Factorio we keep talking about assemblers  consuming resources. A pure function doesn’t consume its arguments–you may pass the same item to many functions and it will still be there. Dealing with resources is a real problem in programming in general, including purely functional languages. Fortunately there are clever ways of dealing with it. In C++, for instance, we can use unique pointers and move semantics, in Rust we have ownership types, and Haskell recently introduced linear types. What Factorio does is very similar to Haskell’s linear types. A linear function is a function that is guaranteed to consume its argument. Functorio assemblers are linear functions.</p><p>              函数编程的一个重要方面似乎在Factorio中已被打破。功能应该是纯净的：变异是禁忌。在Factorio中，我们一直在谈论汇编程序消耗资源。纯函数不会消耗其参数-您可以将相同的项目传递给许多函数，并且仍然存在。在包括纯功能语言在内的一般编程中，处理资源是一个真正的问题。幸运的是，有很多聪明的方法可以处理它。例如，在C ++中，我们可以使用唯一的指针并移动语义，在Rust中，我们拥有所有权类型，Haskell最近引入了线性类型。 Factorio的操作与Haskell的线性类型非常相似。线性函数是保证使用其参数的函数。 Functorio汇编器是线性函数。</p><p> Factorio is all about consuming and transforming resources. The resources originate as various ores and coal in mines. There are also trees that can be chopped to yield wood, and liquids like water or crude oil. These external resources are then consumed, linearly, by your industry. In Haskell, we would implement it by passing a linear function called a continuation to the resource producer. A linear function guarantees to consume the resource completely (no resource leaks) and not to make multiple copies of the same resource. These are the guarantees that the Factorio industrial complex provides automatically.</p><p> Factorio全部涉及消耗和转换资源。资源来自矿山中的各种矿石和煤炭。也有一些树木可以砍成木头，还有诸如水或原油之类的液体。然后，您的行业会线性地消耗这些外部资源。在Haskell中，我们将通过将称为延续的线性函数传递给资源生产者来实现它。线性函数保证完全消耗资源（不泄漏资源），并且不制作同一资源的多个副本。这些是Factorio工业园区自动提供的保证。</p><p>  Of course Factorio was not designed to be a programming language, so we can’t expect it to implement every aspect of programming. It is fun though to imagine how we would translate some more advanced programming features into Factorio. For instance, how would currying work? To support currying we would first need partial application. The idea is pretty simple. We have already seen that assemblers can be treated as first class objects. Now imagine that you could produce assemblers with a set recipe (strongly typed assemblers). For instance this one:</p><p>  当然，Factorio并非被设计为一种编程语言，因此我们不能指望它能够实现编程的各个方面。可以想象我们将如何将一些更高级的编程功能转换为Factorio，这很有趣。例如，curry如何工作？为了支持currying，我们首先需要部分应用。这个想法很简单。我们已经看到汇编程序可以被视为一流的对象。现在想象一下，您可以使用设定的配方来生产汇编程序（强类型汇编程序）。例如这个：</p><p>  It’s a two-input assembler. Now give it a single copper plate, which in programmer speak is called  partial application. It’s partial because we haven’t supplied it with an iron gear. We can think of the result of partial application as a new single-input assembler that expects an iron gear and is able to produce one beaker of red science. By partially applying the function  makeRedScience</p><p>  这是一个两输入的汇编器。现在给它一个铜板，在程序员看来，这叫做部分应用。部分原因是因为我们没有为其提供铁齿轮。我们可以将部分应用的结果视为一种新的单输入装配器，该装配器期望使用铁制齿轮并能够生产一个红色科学烧杯。通过部分应用功能makeRedScience</p><p>    In fact we have just designed a process that gave us a (higher-order) function that takes a copper plate and creates a “primed” assembler that only needs an iron gear to produce red science:</p><p>    实际上，我们刚刚设计了一个过程，该过程赋予了我们一个（高阶）功能，该功能使用一块铜板并创建一个“底涂”组装机，该组装机只需要铁齿轮即可生产红色科学材料： </p><p>    Now we would like to automate this process. We want to have something that takes a two-input assembler, for instance  makeRedScience, and returns a single input assembler that produces another “primed” single-input assembler. The type signature of this beast would be:</p><p>现在，我们想使这个过程自动化。我们想要一个带有两个输入的汇编器的东西，例如makeRedScience，并返回一个单个输入的汇编器，该汇编器会生成另一个“主”单输入器的汇编器。该野兽的类型签名为：</p><p>    Notice that it really doesn’t matter what the concrete types are. What’s important is that we can turn a function that takes a pair of arguments into a function that returns a function. We can make it fully polymorphic:</p><p>    请注意，具体类型是什么都没关系。重要的是，我们可以将带有一对参数的函数转换为返回函数的函数。我们可以使其完全多态：</p><p>  Here, the type variables  a,  b and  c can be replaced with any types (in particular,  CopperPlate,  Gear, and  RedScience). This is a Haskell implementation:</p><p>  在这里，类型变量a，b和c可以替换为任何类型（特别是CopperPlate，Gear和RedScience）。这是一个Haskell实现：</p><p>   So far we haven’t talked about how arguments (items) are delivered to functions (assemblers). We can manually drop items into assemblers, but that very quickly becomes boring. We need to automate the delivery systems. One way of doing it is by using some kind of containers: chests, train wagons, barrels, or conveyor belts. In programming we call these  functors. Strictly speaking a functor can hold only one type of items at a time, so a chest of iron plates should be a different type than a chest of gears. Factorio doesn’t enforce this but, in practice, we rarely mix different types of items in one container.</p><p>   到目前为止，我们还没有讨论过如何将参数（项目）传递给函数（汇编程序）。我们可以手动将项目放入汇编器，但是很快就会变得很无聊。我们需要使交付系统自动化。一种实现方法是使用某种容器：箱子，火车货车，桶或传送带。在编程中，我们称这些函子。严格来说，函子一次只能容纳一种类型的物品，因此，铁皮箱的类型应与齿轮箱的类型不同。 Factorio不会强制执行此操作，但实际上，我们很少在一个容器中混合使用不同类型的物品。</p><p> The important property of a functor is that you can apply a function to its contents. This is best illustrated with conveyor belts. Here we take the recipe that turns a copper plate into copper wire and apply it to a whole conveyor belt of copper (coming from the right) to produce a conveyor belt of copper wire (going to the left).</p><p> 函子的重要属性是可以将函数应用于其内容。最好用传送带来说明。在这里，我们采用将铜板变成铜线的方法，然后将其应用于整个铜输送带（从右至右），以生产铜线输送带（向左）。</p><p>  The fact that a belt can carry any type of items can be expressed as a type constructor–a data type parameterized by an arbitrary type  a</p><p>  皮带可以携带任何类型的物品的事实可以表示为类型构造器-由任意类型a参数化的数据类型</p><p>  You can apply it to any type to get a belt of specific items, as in</p><p>  您可以将其应用于任何类型以获取特定项目的皮带，例如 </p><p>    The fact that it’s a functor is expressed by implementing a polymorphic function  mapBelt</p><p>它是函子的事实通过实现多态函数mapBelt来表达</p><p>  This function takes a function  a-&gt;b and produces a function that transforms a belt of  as to a belt of  bs. So to create a belt of (pairs of) copper wire we’ll map the assembler that implements  makeCoperWire over a belt of  CopperPlate</p><p>  该函数取函数a-＞ b，并产生将as的带转换成bs的带的函数。因此，要创建一条（成对的）铜线带，我们将在铜带上映射实现makeCoperWire的汇编器</p><p>  You may think of a belt as corresponding to a list of elements, or an infinite stream, depending on the way you use it.</p><p>  您可能会认为皮带与元素列表或无限流相对应，这取决于您使用皮带的方式。</p><p> In general, a type constructor  F is called a functor if it supports the mapping of a function over its contents:</p><p> 通常，如果类型构造函数F支持函数在其内容上的映射，则将其称为函子：</p><p>   Uranium ore processing is interesting. It is done in a centrifuge, which accepts uranium ore and produces two isotopes of Uranium.</p><p>   铀矿石加工很有趣。它是在离心机中完成的，该离心机接受铀矿石并产生铀的两个同位素。</p><p>  The new thing here is that the output is probabilistic. Most of the time (on average, 99.3% of the time) you’ll get Uranium 238, and only occasionally (0.7% of the time) Uranium 235 (the glowy one). Here the plus sign is used to actually encode a sum type. In Haskell we would use the  Either type constructor, which generates a sum type:</p><p>  这里的新事物是输出是概率性的。在大多数情况下（平均占99.3％的时间），您会得到铀238，只有偶尔（占时间的0.7％）会得到铀235（发光的）。此处，加号用于实际编码求和类型。在Haskell中，我们将使用Either类型构造函数，该构造函数将生成sum类型：</p><p>   The two alternatives in the output type of the centrifuge require different actions: U235 can be turned into fuel cells, whereas U238 requires reprocessing. In Haskell, we would do it by pattern matching. We would apply one function to deal with U235 and another to deal with U238. In Factorio this is accomplished using filter inserters (a.k.a., purple inserters). A filter inserter corresponds to a function that picks one of the alternatives, for instance:</p><p>   离心机输出类型中的两个替代方案需要不同的动作：U235可以变成燃料电池，而U238需要后处理。在Haskell中，我们将通过模式匹配来实现。我们将应用一个函数处理U235，将另一个函数处理U238。在Factorio中，这是使用过滤器插入程序（也称为紫色插入程序）完成的。过滤器插入器对应于一个选择替代项的函数，例如： </p><p>  The  Maybe data type (or  Optional in some languages) is used to accommodate the possibility of failure: you can’t get  U235 if the union contained  U238.</p><p>Maybe数据类型（或某些语言中为Optional）用于解决发生故障的可能性：如果联合包含U238，则无法获得U235。</p><p> Each filter inserter is programmed for a particular type. Below you see two purple inserters used to split the output of the centrifuge into two different chests:</p><p> 每个过滤器插入器都针对特定类型进行了编程。在下面，您可以看到两个紫色插入器，它们用于将离心机的输出分成两个不同的箱：</p><p>  Incidentally, a mixed conveyor belt may be seen as carrying a sum type. The items on the belt may be, for instance, either copper wire or steel plates, which can be written as  Either CopperWire SteelPlate. You don’t even need to use purple inserters to separate them, as any inserter becomes selective when connected to the input of an assembler. It will only pick up the items that are the inputs of the recipe for the given assembler.</p><p>  附带地，混合传送带可以被视为携带求和类型。皮带上的物品可以是例如铜线或钢板，可以写为CopperWire SteelPlate。您甚至不需要使用紫色插入器将它们分开，因为任何插入器在连接到汇编器的输入端时都具有选择性。对于给定的汇编器，它将仅拾取配方输入的项目。</p><p>  Every conveyor belt has two sides, so it’s natural to use it to transport pairs. In particular, it’s possible to merge a pair of belts into one belt of pairs.</p><p>  每个传送带都有两个侧面，因此很自然地用它来运输成对的皮带。特别是，可以将一对皮带合并为一对皮带。</p><p>  We don’t use an assembler to do it, just some belt mechanics, but we can still think of it as a function. In this case, we would write it as</p><p>  我们不使用汇编程序来执行此操作，仅使用某些皮带机制，但是我们仍然可以将其视为功能。在这种情况下，我们将其写为</p><p>       Since we can apply belt merging to any type, we can write it as a polymorphic function</p><p>       由于我们可以将皮带合并应用于任何类型，因此我们可以将其编写为多态函数</p><p> mergeBelts :: (Belt a, Belt b) -&gt; Belt (a, b)mergeBelts (MakeBelt as, MakeBelt bs) = MakeBelt (zip as bs)</p><p> mergeBelts ::（皮带a，皮带b）->皮带（a，b）mergeBelts（MakeBelt as，MakeBelt bs）= MakeBelt（zip as bs） </p><p> (In our Haskell model, we have to zip two lists together to get a list of pairs.)</p><p>（在Haskell模型中，我们必须将两个列表压缩在一起以获得对的列表。）</p><p> Belt is a functor. In general, a functor that has this kind of merging ability is called a  monoidal functor, because it preserves the monoidal structure of the category. Here, the monoidal structure of the Factorio category is given by the product (pairing). Any monoidal functor  F must preserve the product:</p><p> 贝尔特是个函子。通常，具有这种合并能力的函子称为单面函子，因为它保留了类别的单面结构。此处，乘积因子类别的单项式结构由乘积（配对）给出。任何单向子仿函数F必须保存该产品：</p><p>  There is one more aspect to monoidal structure: the unit. The unit, when paired with anything, does nothing to it. More precisely, a pair  (Unit, a) is, for all intents and purposes, equivalent to  a. The best way to understand the unit in Factorio is to ask the question: The belt of what, when merged with the belt of  a, will produce a belt of  a? The answer is: the belt of nothing. Merging an empty belt with any other belt, makes no difference.</p><p>  单面体结构还有一个方面：单位。该设备与任何东西配对时，不会对其执行任何操作。更准确地说，对（Unit，a）在所有意图和目的上均等同于a。理解Factorio中单位的最好方法是问一个问题：什么皮带，当与a的皮带合并时，会产生a的皮带？答案是：一无所有。将一条空皮带与其他皮带合并在一起没有任何区别。</p><p>    The ability to merge two belts, together with the ability to create an empty belt, makes  Belt a monoidal functor. In general, besides preserving the product, the condition for the functor  F to be monoidal is the ability to produce</p><p>    合并两个皮带的能力以及创建空皮带的能力使Belt成为单向仿函数。通常，除保存产品外，函子F呈单向性的条件是产生能力</p><p>  Most functors, at least in Factorio, are not monoidal. For instance, chests cannot store pairs.</p><p>  至少在Factorio中，大多数函子不是单项的。例如，箱子不能存储货币对。</p><p>  As I mentioned before, most assembler recipes take multiple arguments, which we modeled as tuples (products). We also talked about partial application which, essentially, takes an assembler and one of the ingredients and produces a “primed” assembler whose recipe requires one less ingredient. Now imagine that you have a whole belt of a single ingredient, and you map an assembler over it. In current Factorio, this assembler will accept one item and then get stuck waiting for the rest. But in our extended version of Factorio, which we call Functorio, mapping a multi-input assembler over a belt of single ingredient should produce a belt of “primed” assemblers. For instance, the red science assembler has the signature</p><p>  如前所述，大多数汇编器配方都采用多个参数，我们将其建模为元组（产品）。我们还讨论了部分应用程序，该应用程序本质上需要一个装配器和一种成分，然后生产一种“预涂”装配器，其配方所需的成分更少。现在想象一下，您有一条由单一成分组成的整条皮带，并在其上绘制了一个汇编程序。在当前的Factorio中，该汇编器将接受一项，然后卡住以等待其余项。但是在我们称为Functorio的扩展版本的Factorio中，将多输入汇编器映射到单一成分的传送带上应该会产生“预备”组装器的传送带。例如，红色的科学汇编程序具有签名</p><p>  When mapped over a belt of  CopperPlate it should produce a belt of partially applied assemblers, each with the recipe:</p><p>  将其映射到CopperPlate皮带上时，应产生一部分应用的装配工皮带，每个都有以下配方： </p><p>  Now suppose that you have a belt of gears ready. You should be able to produce a belt of red science. If there only were a way to apply the first belt over the second belt. Something like this:</p><p>现在，假设您已经准备好齿轮。您应该能够产生出红色的科学带。如果只有一种方法可以将第一条皮带套在第二条皮带上。像这样：</p><p>  Here we have a belt of primed assemblers and a belt of gears and the output is a belt of red science.</p><p>  在这里，我们有许多准备好的组装工，还有一些齿轮，其输出是红色的科学带。</p><p> A functor that supports this kind of merging is called an  applicative functor.  Belt is an applicative functor. In fact, we can tell that it’s applicative because we’ve established that it’s monoidal. Indeed, monoidality lets us merge the two belts to get a belt of pairs</p><p> 支持这种合并的函子称为应用函子。皮带是一种实用的函子。实际上，我们可以说它具有适用性，因为我们已经确定它是单项式的。的确，单义性使我们可以合并两条腰带以得到一对腰带</p><p>  We know that there is a way of applying the  Gear-&gt;RedScience assembler to a  Gear resulting in  RedScience. That’s just how assemblers work. But for the purpose of this argument, let’s give this application an explicit name:  eval.</p><p>  我们知道，有一种方法可以将Gear-> RedScience汇编程序应用于产生RedScience的Gear。这就是汇编程序的工作方式。但是出于此参数的目的，让我们为该应用程序指定一个明确的名称：eval。</p><p>  ( gtor gr is just Haskell syntax for applying the function  gtor to the argument  gr). We are abstracting the basic property of an assembler that it can be applied to an item.</p><p>  （gtor gr只是将功能gtor应用于参数gr的Haskell语法）。我们正在抽象可应用于项目的汇编程序的基本属性。</p><p> Now, since  Belt is a functor, we can map  eval over our belt of pairs and get a belt of  RedScience.</p><p> 现在，由于Belt是一个函子，我们可以将eval映射到成对的皮带上，并获得RedScience的皮带。</p><p> apBelt :: (Belt (Gear -&gt; RedScience), Belt Gear) -&gt; Belt RedScienceapBelt (gtors, gear) = mapBelt eval (mergeBelts (gtors, gears))</p><p> apBelt ::（Belt（齿轮-> RedScience），皮带齿轮）-＆gt;地带红色科学apBelt（gtors，gear）= mapBelt eval（mergeBelts（gtors，gears）） </p><p> Going back to our original problem: given a belt of copper plate and a belt of gear, this is how we produce a belt of red science:</p><p>回到我们最初的问题：给定铜板带和齿轮带，这就是我们产生红色科学带的方式：</p><p> redScienceFromBelts :: (Belt CopperPlate, Belt Gear) -&gt; Belt RedScienceredScienceFromBelts (beltCu, beltGear) =  apBelt (mapBelt (curry makeRedScience) beltCu, beltGear)</p><p> redScienceFromBelts ::（皮带铜板，皮带齿轮）->地带红色科学redScienceFromBelts（beltCu，beltGear）= apBelt（mapBelt（curry makeRedScience）beltCu，beltGear）</p><p> We curry the two-argument function  makeRedScience and map it over the belt of copper plates. We get a beltful of primed assemblers. We then use  apBelt to apply these assemblers to a belt of gears.</p><p> 我们使用两个参数的函数makeRedScience并将其映射到铜板带上。我们得到了许多优质的汇编程序。然后，我们使用apBelt将这些装配器应用于齿轮传动带。</p><p> To get a general definition of an applicative functor, it’s enough to replace  Belt with generic functor  F,  CopperPlate with  a, and  Gear with  b. A funtor  F is applicative if there is a polymorphic function:</p><p> 要获得适用函子的一般定义，只需用通用函子F代替Belt，用a代替CopperPlate，用b代替Gear就足够了。如果存在多态函数，则函子F适用：</p><p>    To complete the picture, we also need the equivalent of the monoidal unit law. A function called  pure plays this role:</p><p>    为了使图更完整，我们还需要等分单位律。一个叫做pure的函数扮演着这个角色：</p><p>  This just tell you that there is a way to create a belt with a single item on it.</p><p>  这只是告诉您，有一种方法可以创建带有单个项目的皮带。</p><p>  In Factorio, the nesting of functors is drastically limited. It’s possible to produce belts, and you can put them on belts, so you can have a beltful of belts,  Belt Belt. Similarly you can store chests inside chests. But you can’t have belts of  loaded belts. You can’t pick a belt filled with copper plates and put it on another belt. In other words, you cannot transport beltfuls of stuff. Realistically, that wouldn’t make much sense in real world, but in Functorio, this is exactly what we need to implement monads. So imagine that you have a belt carrying a bunch of belts that are carrying copper plates. If belts were monadic, you could turn this whole thing into a single belt of copper plates. This functionality is called  join (in some languages, “flatten”):</p><p>  在Factorio中，函子的嵌套受到极大的限制。可以生产皮带，也可以将它们放在皮带上，这样您就可以拥有许多皮带，皮带腰带。同样，您可以将箱子存放在箱子中。但是您不能有载重皮带。您不能选择装满铜板的皮带并将其放在另一皮带上。换句话说，您不能运输一大堆东西。实际上，在现实世界中这没有多大意义，但是在Functorio中，这正是我们实现monad所需要的。想象一下，您有一条皮带，上面有一束皮带，这些皮带上都装有铜板。如果皮带是单子带，您可以将整个东西变成一条铜板皮带。此功能称为联接（在某些语言中为“展平”）： </p><p>  This function just gathers all the copper plates from all the belts and puts them on a single belt. You can thing of it as concatenating all the subbelts into one.</p><p>此功能仅收集所有皮带上的所有铜板并将它们放在一条皮带上。您可以将所有子带合并为一个。</p><p> Similarly, if chests were monadic (and there’s no reason they shouldn’t be) we would have:</p><p> 同样，如果箱子是单子的（没有理由不应该这样），我们将有：</p><p>  A monad must also support the applicative  pure (in Haskell it’s called  return) and, in fact, every monad is automatically applicative.</p><p>  一个monad还必须支持可应用的纯正（在Haskell中，它称为return），并且实际上，每个monad都自动适用。</p><p>  There are many other aspects of Factorio that lead to interesting topics in programming. For instance, the train system requires dealing with concurrency. If two trains try to enter the same crossing, we’ll have a data race which, in Functorio, is called a train crash. In programming, we avoid data races using locks. In Factorio, they are called train signals. And, of course, locks lead to deadlocks, which are very hard to debug in Factorio.</p><p>  Factorio的许多其他方面导致了编程中有趣的话题。例如，火车系统需要处理并发性。如果两列火车试图进入同一路口，我们将进行一次数据竞赛，在Functorio中，这称为火车撞车事故。在编程中，我们避免使用锁进行数据争用。在Factorio中，它们称为火车信号。而且，当然，锁会导致死锁，这在Factorio中很难调试。</p><p> In functional programming we might use STM (Software Transactional Memory) to deal with concurrency. A train approaching a crossing would start a  crossing transaction. It would temporarily ignore all other trains and happily make the crossing. Then it would attempt to commit the crossing. The system would then check if, in the meanwhile, another train has successfully commited the same crossing. If so, it would say “oops! try again!”.</p><p> 在函数式编程中，我们可能使用STM（软件事务存储）来处理并发。接近交叉口的火车将开始交叉口交易。它会暂时不理会所有其他火车，并乐于穿越。然后它将尝试实施交叉。然后，系统将检查与此同时是否有另一列火车成功通过了相同的过境点。如果是这样，它将说“哎呀！再试一次！”。</p><p>    This is a nice and super high effort article. I thought there was a funny sentence in the first paragraph, where you mentioned that real engineering is functional, and then used a game set in an imaginary world to illustrate this point. </p><p>    这是一篇不错的文章，内容超赞。我以为在第一段中有一个有趣的句子，您提到真实的工程是功能性的，然后使用一个在虚拟世界中的游戏集来说明这一点。</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bartoszmilewski.com/2021/02/16/functorio/.">https://bartoszmilewski.com/2021/02/16/functorio/.</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/functorio/">#functorio</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>