<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>单原语身份验证加密带来的乐趣 Single-primitive authenticated encryption for fun</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Single-primitive authenticated encryption for fun<br/>单原语身份验证加密带来的乐趣 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-30 15:01:31</div><div class="page_narrow text-break page_content"><p>Just as a fun exercise, I designed and implemented from scratch astandalone, authenticated encryption tool, including key derivation withstretching, using a single cryptographic primitive. Or, more specifically, half of a primitive. That primitive is the encryption function of the XXTEA block cipher. The goal was to pare both design andimplementation down to the bone without being broken in practice —  Ihope — and maybe learn something along the way. This article is the tourof my design. Everything here will be nearly the opposite of the  rightanswers.</p><p>就像一个有趣的练习一样，我从头开始设计和实现了一个独立的，经过身份验证的加密工具，包括使用单个加密原语进行密钥派生和拉伸。或更具体地说，是原语的一半。该原语是XXTEA块密码的加密功能。目标是将设计和实现缩减到最低限度，而在实践中不致被破坏-希望-并可能在此过程中学到一些东西。本文是我的设计之旅。这里的一切将几乎与正确答案相反。</p><p> The  tool itself is named  xxtea (lowercase), and it’s supportedon all unix-like and Windows systems. It’s trivial to compile,  even onthe latter. The code should be easy to follow from top to bottom,with commentary about specific decisions along the way, though I’ll quotethe most important stuff inline here.</p><p> 该工具本身名为xxtea（小写），并且在所有类似Unix和Windows的系统上均受支持。即使在后者上进行编译也很简单。该代码应易于上下左右跟踪，并附有有关具体决策的注释，尽管我会在此内联引用最重要的内容。</p><p> The command line options  follow the usual conventions. The twomodes of operation are encrypt ( -E) and decrypt ( -D). It defaults tousing standard input and standard output so it works great in pipelines.Supplying  -o sends output elsewhere (automatically deleted if somethinggoes wrong), and the optional positional argument indicates an alternateinput source.</p><p> 命令行选项遵循通常的约定。两种操作模式是加密（-E）和解密（-D）。默认情况下使用标准输入和标准输出，因此它在管道中很好地工作。提供-o将输出发送到其他地方（如果出了问题会自动删除），并且可选的position参数指示替代输入源。</p><p> usage: xxtea &lt;-E|-D&gt; [-h] [-o FILE] [-p PASSWORD] [FILE]examples: $ xxtea -E -o file.txt.xxtea file.txt $ xxtea -D -o file.txt file.txt.xxtea</p><p> 用法：xxtea＆lt; -E | -D＆gt; [-h] [-o文件] [-p密码] [文件]示例：$ xxtea -E -o file.txt.xxtea file.txt $ xxtea -D -o file.txt file.txt.xxtea</p><p> If no password is provided ( -p), it prompts for a  UTF-8-encodedpassword. Of course it’s not normally a good idea to supply apassword via command line argument, but it’s been useful for testing.</p><p> 如果未提供密码（-p），则提示输入UTF-8编码的密码。当然，通过命令行参数提供密码通常不是一个好主意，但是对于测试非常有用。</p><p>  TEA stands for  Tiny Encryption Algorithm and XXTEA is the second attemptat fixing weaknesses in the cipher — with partial success. The remainingissues should not be an issue for this particular application. XXTEAsupports a variable block size, but I’ve hardcoded my implementation to a128-bit block size, along with some unrolling. I’ve also discarded theunneeded decryption function. There are no data-dependent lookups orbranches so it’s immune to speculation attacks.</p><p>  TEA代表Tiny Encryption Algorithm，而XXTEA是第二次尝试修复密码中的弱点-部分成功。对于此特定应用程序，其余问题不应该成为问题。 XXTEA支持可变的块大小，但是我已经将实现硬编码为128位的块大小，同时还进行了一些展开。我也放弃了不需要的解密功能。没有依赖于数据的查询或分支机构，因此不受投机攻击的影响。</p><p> XXTEA operates on 32-bit words and has a 128-bit key, meaning both blockand key are four words apiece. My implementation is about a dozen lineslong. Its prototype:</p><p> XXTEA可对32位字进行操作，并具有128位密钥，这意味着block和key均为四个单词。我的实现大约有十几行。它的原型： </p><p>  All cryptographic operations are built from this function. Another way tothink about it is that it accepts two 128-bit inputs and returns a 128-bitresult:</p><p>所有加密操作都是从此功能构建的。考虑它的另一种方法是，它接受两个128位输入并返回一个128位结果：</p><p>    If I tossed the decryption function, how are messages decrypted? I’m suremany have already guessed: XXTEA will be used in  counter mode, or CTRmode. Rather than encrypt the plaintext directly, encrypt a 128-bit blockcounter and treat it like a stream cipher. The message is XORed with theencrypted counter values for both encryption and decryption.</p><p>    如果我放弃了解密功能，如何解密消息？我敢肯定，我已经猜到了：XXTEA将用于计数器模式或CTR模式。与其直接加密明文，不如加密一个128位的块计数器并将其视为流密码。该消息与加密的计数器值进行异或，以进行加密和解密。</p><p> No padding scheme is necessary. With other block modes, if messagelengths may not be exactly a multiple of the block size then you needsome scheme for padding the last block.</p><p> 无需填充方案。在其他块模式下，如果消息长度可能不完全是块大小的倍数，则需要某种方案来填充最后一个块。</p><p>  void increment ( uint32_t  ctr [ 4 ]) {  /* 128-bit increment, first word changes fastest */  if  ( !++ ctr [ 0 ])  if  ( !++ ctr [ 1 ])  if  ( !++ ctr [ 2 ])  ++ ctr [ 3 ]; }</p><p>  无效增量（uint32_t ctr [4]）{/ * 128位增量，第一个单词变化最快* / if（！++ ctr [0]）if（！++ ctr [1]）if（！++ ctr [ 2]）++ ctr [3]; }</p><p> In xxtea, words are always marshalled in little endian byte order (leastsignificant byte first). With the first word as the least significantlimb, the entire 128-bit counter is itself little endian.</p><p> 在xxtea中，单词始终以小尾数字节顺序（最低字节在前）进行编组。将第一个字作为最低有效位，整个128位计数器本身就是小端。</p><p> The counter doesn’t start at zero, but at some randomly-selected 128-bitnonce called the  initialization vector (IV), wrapping around to zero ifnecessary (incredibly unlikely). The IV will be included with the messagein the clear. This nonce allows one key (password) to be used withmultiple messages, as they’ll all be encrypted using different,randomly-chosen regions of an enormous keystream. It also provides semantic security: encrypt the same file more than once and theciphertext will always be completely different.</p><p> 计数器不是从零开始，而是从一些随机选择的128位随机数（称为初始化向量（IV））开始，必要时会回零。消息中将包含IV。此随机数允许将一个密钥（密码）与多封邮件一起使用，因为它们都会使用巨大密钥流的不同，随机选择的区域进行加密。它还提供了语义安全性：对同一文件进行多次加密，密文将始终完全不同。</p><p> for  ( /* ... */ )  {  uint32_t  cover [ 4 ]  =  { ctr [ 0 ],  ctr [ 1 ],  ctr [ 2 ],  ctr [ 3 ]};  xxtea128_encrypt ( key ,  cover );  block [ i + 0 ]  ^=  cover [ 0 ];  block [ i + 1 ]  ^=  cover [ 1 ];  block [ i + 2 ]  ^=  cover [ 2 ];  block [ i + 3 ]  ^=  cover [ 3 ];  increment ( ctr ); }</p><p> for（/ * ... * /）{uint32_t cover [4] = {ctr [0]，ctr [1]，ctr [2]，ctr [3]}； xxtea128_encrypt（key，cover）;块[i + 0] ^ =封面[0];块[i + 1] ^ =封面[1];块[i + 2] ^ =封面[2];块[i + 3] ^ =封面[3]；增量（ctr）; } </p><p>  That’s encryption, but there’s still a matter of  authentication and  keyderivation function (KDF). To deal with both I’ll need to devise a hashfunction. Since I’m only using the one primitive, somehow I need to builda hash function from a block cipher. Fortunately there’s a tool for doingjust that: the  Merkle–Damgård construction.</p><p>这是加密的，但是仍然存在身份验证和密钥派生功能（KDF）的问题。为了解决这两个问题，我需要设计一个哈希函数。由于我只使用一个原语，因此我需要以某种方式从块密码构建哈希函数。幸运的是，有一个可以做到这一点的工具：Merkle–Damgård构造。</p><p> Recall that  xxtea128_encrypt accepts two 128-bit inputs and returns a128-bit result. In other words, it  compresses 256 bits into 128 bits: acompression function. The two 128-bit inputs are cryptographicallycombined into one 128-bit result. I can repeat this operation to fold anarbitrary number of 128-bit inputs into a 128-bit hash result.</p><p> 回想一下xxtea128_encrypt接受两个128位输入并返回一个128位结果。换句话说，它将256位压缩为128位：压缩功能。将两个128位输入加密组合为一个128位结果。我可以重复此操作以将任意数量的128位输入折叠为128位哈希结果。</p><p> uint32_t  * input  =  /* ... */ ; uint32_t  hash [ 4 ]  =  { 0 ,  0 ,  0 ,  0 }; xxtea128_encrypt ( input  +  0 ,  hash ); xxtea128_encrypt ( input  +  4 ,  hash ); xxtea128_encrypt ( input  +  8 ,  hash ); xxtea128_encrypt ( input  +  12 ,  hash ); // ...</p><p> uint32_t *输入= / * ... * /; uint32_t hash [4] = {0，0，0，0}; xxtea128_encrypt（input + 0，hash）; xxtea128_encrypt（input + 4，hash）; xxtea128_encrypt（input + 8，hash）; xxtea128_encrypt（input + 12，hash）; // ...</p><p> Note how the input is the key, not the block. The hash state is repeatedlyencrypted using the hash inputs as the key, mixing hash state and input.When the input is exhausted, that block is the result. Sort of.</p><p> 注意输入是键，而不是块。哈希状态使用哈希输入作为键重复加密，将哈希状态和输入混合在一起，当输入用尽时，该块即为结果。有点。</p><p> I used zero for the initial hash state in my example, but it will be morechallenging to attack if the starting input is something random.  LikeBlowfish, in xxtea I chose the first 128 bits of the decimalsof pi:</p><p> 在示例中，我使用零作为初始哈希状态，但是如果起始输入是随机的，它将更具挑战性。像河豚一样，在xxtea中，我选择了pi的小数点的前128位：</p><p> void xxtea128_hash_init ( uint32_t  ctx [ 4 ]) {  /* first 32 hexadecimal digits of pi */  ctx [ 0 ]  =  0x243f6a88 ;  ctx [ 1 ]  =  0x85a308d3 ;  ctx [ 2 ]  =  0x13198a2e ;  ctx [ 3 ]  =  0x03707344 ; } /* Mix one block into the hash state. */ void xxtea128_hash_update ( uint32_t  ctx [ 4 ],  const  uint32_t  block [ 4 ]) {  xxtea128_encrypt ( block ,  ctx ); }</p><p> void xxtea128_hash_init（uint32_t ctx [4]）{/ * pi的前32个十六进制数字* / ctx [0] = 0x243f6a88; ctx [1] = 0x85a308d3; ctx [2] = 0x13198a2e; ctx [3] = 0x03707344; } / *将一个块混合到哈希状态。 * / void xxtea128_hash_update（uint32_t ctx [4]，const uint32_t block [4]）{xxtea128_encrypt（block，ctx）; }</p><p> There are still a couple of problems. First, what if the input isn’t amultiple of the block size? This time I  do need a padding scheme to fillout that last block. In this case I pad it with bytes where each byte isthe number of padding bytes. For instance,  helloworld becomes, roughlyspeaking,  helloworld666666.</p><p> 仍然有几个问题。首先，如果输入不是块大小的倍数怎么办？这次，我确实需要一个填充方案来填充最后一个块。在这种情况下，我用字节填充它，其中每个字节是填充字节数。例如，helloworld大致说来就是helloworld666666。 </p><p> That creates a different problem: This will have the same hash result asan input that actually ends with these bytes. So the second rule is thatthere is always a padding block, even if that block is 100% padding.</p><p>这就产生了一个不同的问题：这将具有与实际以这些字节结尾的输入相同的哈希结果。因此，第二条规则是，即使该填充块是100％填充，也始终存在一个填充块。</p><p> Another problem is that the Merkle–Damgård construction is prone to length-extension attacks. Anyone can take my hash result and continueappending additional data without knowing what came before. If I’m usingthis hash to authenticate the ciphertext, someone could, for example, usethis attack to append arbitrary data to the end of messages.</p><p> 另一个问题是Merkle–Damgård的结构容易受到长度延伸攻击。任何人都可以获取我的哈希结果并继续追加其他数据，而无需知道之前发生了什么。例如，如果我使用此哈希对密文进行身份验证，则有人可能会使用此攻击将任意数据附加到邮件末尾。</p><p> Some important hash functions, such as the most common forms of SHA-2, arevulnerable to length-extension attacks. Keeping this issue in mind, Icould address it later using HMAC, but I have an idea for nipping this inthe bud now. Before mixing the padding block into the hash state, I swapthe two middle words:</p><p> 一些重要的哈希函数（例如SHA-2的最常见形式）容易受到长度扩展攻击。牢记这个问题，我以后可以使用HMAC来解决，但我现在有个想法可以解决。在将填充块混入哈希状态之前，我交换了两个中间词：</p><p> /* Append final raw-byte block to hash state. */ void xxtea128_hash_final ( uint32_t  ctx [ 4 ],  const  void  * buf ,  int  len ) {  assert ( len  &lt;  16 );  unsigned  char  tmp [ 16 ];  memset ( tmp ,  16 - len ,  16 );  memcpy ( tmp ,  buf ,  len );  uint32_t  k [ 4 ]  =  {  loadu32 ( tmp  +  0 ),  loadu32 ( tmp  +  4 ),  loadu32 ( tmp  +  8 ),  loadu32 ( tmp  +  12 ),  };  /* swap middle words to break length extension attacks */  uint32_t  swap  =  ctx [ 1 ];  ctx [ 1 ]  =  ctx [ 2 ];  ctx [ 2 ]  =  swap ;  xxtea128_encrypt ( k ,  ctx ); }</p><p> / *将最终的原始字节块追加到哈希状态。 * / void xxtea128_hash_final（uint32_t ctx [4]，const void * buf，int len）{断言（len＆lt; 16）; unsigned char tmp [16]; memset（tmp，16-len，16）; memcpy（tmp，buf，len）; uint32_t k [4] = {loadu32（tmp + 0），loadu32（tmp + 4），loadu32（tmp + 8），loadu32（tmp + 12），}; / *交换中间单词以破坏长度扩展攻击* / uint32_t swap = ctx [1]; ctx [1] = ctx [2]； ctx [2] =交换; xxtea128_encrypt（k，ctx）; }</p><p> This operation “ties off” the last block so that the hash can’t beextended with more input.  Or so I hope. This is my own invention, and soit may not actually work right. Again, this is for fun and learning!</p><p> 此操作“绑定”了最后一个块，以使散列无法通过更多输入来扩展。还是我希望。这是我自己的发明，所以soit可能实际上无法正常工作。同样，这是为了娱乐和学习！</p><p>   First, XXTEA was never designed to be used with the Merkle–Damgårdconstruction. I assume attackers can modify files I will decrypt, and sothe hash input is usually and mostly under control of attackers, meaningthey control the cipher key. Ciphers are normally designed assuming thekey is not under hostile control. This might be vulnerable to related-keyattacks.</p><p>   首先，XXTEA从未设计用于Merkle–Damgård构造。我假设攻击者可以修改我将解密的文件，因此哈希输入通常且大部分在攻击者的控制之下，这意味着它们可以控制密码密钥。通常在假定密钥不受敌对控制的情况下设计密码。这可能容易受到相关按键攻击的影响。</p><p> As will be discussed below, I use this custom hash function in two ways.In one the input is not controlled by attackers, so this is a non-issue.In the second, the hash state is completely unknown to the attacker beforethey control the input, which I believe mitigates any issues.</p><p> 如下所述，我以两种方式使用此自定义哈希函数：一种是输入不受攻击者控制，因此这是非问题;第二种是，攻击者在控制哈希值之前完全不知道哈希状态输入，我相信可以减轻任何问题。 </p><p> Second, a 128-bit hash state is a bit small these days. For very largeinputs, the chance of  collision via the birthday paradox is apractical issue.</p><p>其次，如今这些128位的哈希状态有点小。对于非常大的输入，通过生日悖论发生碰撞的可能性是一个实际问题。</p><p> In xxtea, digests are only computed over a few megabytes of input at a timeat most, even when encrypting giant files, so a 128-bit state should befine.</p><p> 在xxtea中，即使在加密巨型文件时，摘要一次最多只能计算几兆字节的输入，因此应该是128位状态。</p><p>  The user will supply a password and somehow I need to turn that into a128-bit key.</p><p>  用户将提供一个密码，而我需要以某种方式将其变成一个128位密钥。</p><p> It’s safer for the cipher if the raw password isn’t used directly.</p><p> 如果不直接使用原始密码，则对于密码来说更安全。</p><p> The first three can be resolved by running the passphrase through the hashfunction, using it as key derivation function. What about the last item?Rather than hash the password once, I concatenate it, including nullterminator, repeatedly until it reaches a certain number of bytes(hardcoded to 64 MiB, see  COST), and hash that. That’s a computationalworkload that attackers must repeat when guessing passwords.</p><p> 前三个可以通过在散列函数中运行密码来解决，并将其用作密钥派生函数。最后一项呢？我将密码（包括nullterminator）重复连接一次，而不是一次哈希密码，直到达到一定数量的字节（硬编码为64 MiB，请参见COST）并将其哈希。这是攻击者在猜测密码时必须重复的计算工作量。</p><p> To avoid timing attacks based on the password length, I precompute allpossible block arrangements before starting the hash — all the differentways the password might appear concatenated across 16-byte blocks. Blocksmay be redundantly computed if necessary to make this part constant time.The hash is fed entirely from these precomputed blocks.</p><p> 为了避免基于密码长度的定时攻击，我在开始哈希之前预先计算了所有可能的块排列-密码可能会以16字节的块连接在一起。如果有必要使该部分保持恒定的时间，则可以冗余地计算块。散列完全由这些预先计算的块提供。</p><p> To defend against rainbow tables and the like — as well as make it harderto attack other parts of the message construction — the initializationvector is used as a salt, fed into the hash before the passwordconcatenation.</p><p> 为了抵御彩虹表等（以及使其更难攻击消息构造的其他部分），将初始化向量用作盐，在密码连接之前将其馈入哈希。 </p><p> Unfortunately this KDF isn’t  memory-hard, and attackers can use economyof scale to strengthen their attacks (GPUs, custom hardware). However, amemory-hard KDF requires lots of memory to compute the key, making memoryan expensive and limiting factor for attackers. Memory-hard KDFs arecomplex and difficult to design, and I made the trade-off for simplicity.</p><p>不幸的是，这种KDF并不是很难存储的，攻击者可以利用规模经济来加强其攻击（GPU，自定义硬件）。但是，难于记忆的KDF需要大量内存来计算密钥，这使得内存成为攻击者的昂贵且受限的因素。难以存储的KDF复杂且难以设计，为简化起见，我进行了权衡。</p><p>  When I say the encryption is  authenticated I mean that it should not bepossible for anyone to tamper with the ciphertext undetected withoutalready knowing the key. This is typically accomplished by computing akeyed hash digest and appending it to the message,  message authenticationcode (MAC). Since it’s keyed, only someone who knows the key can computethe digest, and so attackers can’t spoof the MAC.</p><p>  当我说加密是经过身份验证时，我的意思是说，任何人在不知道密钥的情况下，都不能篡改未检测到的密文。通常，这是通过计算带密钥的哈希摘要并将其附加到消息，消息身份验证码（MAC）来完成的。由于使用了密钥，因此只有知道密钥的人才能计算摘要，因此攻击者无法欺骗MAC。</p><p> This is where length-extension attacks come into play: With an improperlyconstructed MAC, an attacker could append input without knowing the key.Fortunately my hash function isn’t vulnerable to length-extension attacks!</p><p> 这就是长度扩展攻击的作用：如果MAC的结构不正确，攻击者可能会在不知道密钥的情况下追加输入。幸运的是，我的哈希函数不容易受到长度扩展攻击的攻击！</p><p> An alternative is to use an authenticated block mode such as  GCM,which is still CTR mode at its core. Unfortunately, this is complicated,and, unlike plain CTR, it would take me a long time to convince myself Igot it right. So instead I used CTR mode and my hash function in astraightforward way.</p><p> 另一种选择是使用经过身份验证的阻止模式，例如GCM，其核心仍然是CTR模式。不幸的是，这很复杂，而且与普通的点击率不同，我要花很长时间才能说服自己理解正确。因此，我直接使用了CTR模式和哈希函数。</p><p> At this point there’s a question of what exactly you input into the hashfunction. Do you hash the plaintext or do you hash the ciphertext? It’stempting to do the former since it’s (generally) not available toattackers, and would presumably make it harder to attack. This is amistake. Always compute the MAC over the ciphertext, a.k.a. encrypt thenauthenticate.</p><p> 在这一点上，有一个问题是您到底向哈希函数输入了什么。您对纯文本进行哈希处理还是对密文进行哈希处理？由于前者通常无法使用前者，因此它很容易这样做，并且可能会使攻击更加困难。这是个错误。始终在密文上计算MAC，再加密然后进行身份验证。</p><p> This is the called  the Doom Principle. Computing the MAC on theplaintext means that recipients must decrypt untrusted ciphertext beforeauthenticating it. This is bad because messages should be authenticatedbefore decryption. So that’s exactly what xxtea does. It also happens tobe the simplest option.</p><p> 这就是所谓的厄运原理。在纯文本上计算MAC意味着收件人必须在对不可信密文进行身份验证之前对其进行解密。这很不好，因为消息应在解密之前进行身份验证。这就是xxtea所做的。它碰巧也是最简单的选择。</p><p> We have a hash function, but to compute a MAC we need a keyed hashfunction. Again, I do the simplest thing that I believe isn’t broken:concatenate the key with the ciphertext. Or more specifically:</p><p> 我们有一个哈希函数，但是要计算MAC，我们需要一个键控哈希函数。再说一次，我做了我认为不会破坏的最简单的事情：将密钥与密文连接起来。或更具体地说： </p><p>  The counter is because xxtea uses chunked authentication with one megabytechunks. It can authenticate a chunk at a time, which allows it to decrypt,with authentication, arbitrary amounts of ciphertext in a fixed amount ofmemory. The worst that can happen is truncation between chunks — anacceptable trade-off. The counter ensures each chunk MAC is uniquelykeyed, that they appear in order.</p><p>该计数器是因为xxtea使用具有1兆字节块的分块身份验证。它可以一次对一个块进行身份验证，从而可以通过身份验证在固定数量的内存中解密任意数量的密文。可能发生的最坏情况是块之间的截断-可以接受的折衷方案。计数器确保每个块MAC都是唯一的，并按顺序显示。</p><p> It’s also important to note that the counter is appended  after the key.The counter is under hostile control — they can choose the IV — and havingthe key there first means they have no information about the hash state.</p><p> 同样重要的是要注意，计数器是在密钥后面附加的。计数器处于敌对控制之下-他们可以选择IV-并且首先拥有密钥意味着他们没有关于哈希状态的信息。</p><p> All chunks are one megabyte except for the last chunk, which is alwaysshorter, signaling the end of the message. It may even be just a MAC andzero-length ciphertext. This avoids nasty issues with parsing potentiallyunauthenticated length fields and whatnot. Just stop successfully at thefirst short, authenticated chunk.</p><p> 除最后一个块（通常更短）以外，所有块均为一兆字节，表示消息结束。它甚至可能只是MAC和零长度密文。这避免了解析可能未经身份验证的长度字段之类的麻烦问题。只要在第一个经过身份验证的短块成功停止即可。</p><p> Some will likely have spotted it, but a potential weakness is that I’musing the same key for both encryption and authentication. These arenormally two different keys. This is disastrous in certain cases  likeCBC-MAC, but I believe it’s alright here. It would be easy tocompute a separate MAC key, but I opted for simple.</p><p> 有些人可能会发现它，但潜在的缺点是我在加密和身份验证时使用了相同的密钥。这些通常是两个不同的键。在某些情况下，例如CBC-MAC，这是灾难性的，但我相信在这里还可以。计算单独的MAC密钥很容易，但是我选择了简单的方法。</p><p>  In my usual style, encrypted files have no distinguishing headers orfields. They just look like a random block of data. A file begins with the16-byte IV, then a sequence of zero or more one megabyte chunks, endingwith a short chunk. It’s indistinguishable from  /dev/random.</p><p>  按照我惯用的样式，加密文件没有明显的头或字段。它们看起来就像是随机数据块。文件以16字节的IV开头，然后是零个或多个1兆字节的块序列，最后是一小段。与/ dev / random没什么区别。</p><p>  If the user types the incorrect password, it will be discovered whenauthenticating the first chunk (read: immediately). This saves on adedicated check at the beginning of the file, though it means it’s notpossible to distinguish between a bad password and a modified file.</p><p>  如果用户输入了错误的密码，则在对第一个密码进行身份验证时将被发现（立即阅读：）。这样可以节省文件开头的专用检查，尽管这意味着不可能区分错误密码和修改后的文件。</p><p> I know my design has weaknesses as a result of artificial, self-imposedconstraints and deliberate trade-offs, but I’m curious if I’ve made anyglaring mistakes with practical consequences.</p><p> 我知道我的设计由于人为的，自我施加的限制和故意的权衡而存在弱点，但是我很好奇我是否犯了任何明显的错误并带来了实际后果。 </p><p>      Have a comment on this article? Start a discussion in my  public inbox by sending an email to   ~skeeto/public-inbox@lists.sr.ht    [ mailing list etiquette] , or see  existing discussions.</p><p>对这篇文章有评论吗？ 通过发送电子邮件至~skeeto/public-inbox@lists.sr.ht [邮件列表礼节]，在我的公共收件箱中进行讨论，或查看现有讨论。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://nullprogram.com/blog/2021/01/30/">https://nullprogram.com/blog/2021/01/30/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/原语/">#原语</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/primitive/">#primitive</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/密码/">#密码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>