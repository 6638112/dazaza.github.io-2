<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>M1内存和性能</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">M1内存和性能</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-14 09:04:22</div><div class="page_narrow text-break page_content"><p>The M1 Macs are out now, and not only does Apple claim they&#39;re absolutely smokin&#39;, early benchmarksseem to confirm those claims. I don&#39;t find this surprising, Apple has been highly focused on performance ever since Tiger, and as far as I can tell hasn&#39;t let up since. One maybe somewhat surprising aspect of the M1s is the limitation to &#34;only&#34; 16 Gigabytes of memory. As someone who bought a 16  Kilobyte language card to run the Merlin6502 assembler on his Apple ][+ and expanded his NeXT cube, which isn&#39;t  that different froma modern Mac, to a whopping 16  Megabytes, this doesn&#39;t actually seem that much of a limitation, but it didcause a bit of consternation. I have a bit of a theory as to how this &#34;limitation&#34; might tie in to how Apple&#39;s outside-the-boxapproach to memory and performance has contributed to the remarkable achievement that is the M1. The M1 is apparently a multi-die package that contains both the actual processor die and theDRAM. As such, it has a very high-speed interface between the DRAM and the processors.This high-speed interface, in addition to the absolutely humongous caches, is key to keeping the various functionalunits fed. Memory bandwidth and latency are probably  the determining factors for manyof today&#39;s workloads, with a single access to main memory taking easily hundreds of clock cyclesand the CPU capable of doing a good number of operations in each of these clock cycles.As Andrew Black  wrote: &#34;[..] computation is essentially free, because it happens &#39;in the cracks&#39; between data fetch and data store; ..&#34;. The tradeoff is that you can only fit so much DRAM in that package for now, but if it fits,it&#39;s going to be super fast. So how do we make sure it all fits? Well, where Apple might have been &#34;focused&#34; on performancefor the last 15 years or so, they have been completely  anal about memory consumption.When I was there, we were fixing 32  byte memory leaks. Leaks that happened  once.So not an ongoing consumption of 32 bytes again and again, but a one-time leak of 32 bytes. That dedication verging on the obsessive is one of the reasons iPhones have been besting top-of-the-line Android phone that have twice the memory. And not by a little, either. Another reason is the iOS team&#39;s steadfast refusal to adopt tracing garbage collection asmost of the rest of the industry did,and macOS&#39;s later abandonment of that technology in favor of the reference counting (RC) they&#39;vebeen using since NeXTStep 4.0. With increased automation of those reference counting operationsand the addition of weak references, the convenience level for developers is essentially indistinguishable from a tracing GC now. The benefit of sticking to RC is much-reduced memory consumption. It  turns out that fora tracing GC to achieve performance comparable with manual allocation, it needs severaltimes the memory (different studies find different overheads, but at least 4x is a conservativelower bound). While I haven&#39;t seen a study comparing RC, my personal experience is that theoverhead is much lower, much more predictable, and can usually be driven down with littleadditional effort if needed. So Apple can afford to live with more &#34;limited&#34; total memory because they need much lessmemory for the system to be fast. And so they can do a system design that imposes thislimitation, but allows them to make that memory wicked fast.  Nice. Another &#34;well-known&#34; limitation of RC that has made it the second choice compared to tracingGC is the fact that updating those reference counts all the time is expensive, particularlyin a multi-threaded environment where those updates need to be atomic. Well... fun fact: retaining and releasing an NSObject takes ~30 nanoseconds on current gen Intel, and ~6.5 nanoseconds on an M1</p><p>M1 Mac现在已经上市了，苹果不仅声称它们绝对是在冒烟，早期的基准测试似乎也证实了这些说法。我并不觉得这令人惊讶，自从Tiger以来，苹果一直高度关注性能，据我所知，从那以后就没有松懈过。M1的一个可能有点令人惊讶的方面是，它只有16G的内存限制。作为一个购买了16千字节的语言卡以在他的苹果上运行Merlin6502汇编器的人，他把他的下一个立方体(与现代的Mac没有什么不同)扩展到了惊人的16MB，这看起来并不是一个很大的限制，但它确实引起了一些恐慌。关于这种局限性可能与苹果在内存和性能方面的开箱即用方法如何促成了M1的非凡成就，我有一个理论上的解释。M1显然是一个包含实际处理器芯片和DRAM的多芯片封装。因此，它在DRAM和处理器之间有一个非常高速的接口，除了绝对庞大的高速缓存之外，这个高速接口是保持各种功能单元可用的关键。内存带宽和延迟可能是当今许多工作负荷的决定因素，一次访问主存可以轻松地占用数百个时钟周期，而CPU能够在每个时钟周期内执行大量操作。正如安德鲁·布莱克(Andrew Black)所写：[.]。计算基本上是免费的，因为它发生在数据获取和数据存储之间的缝隙中。权衡的是，你目前只能在这个套装中容纳这么多的DRAM，但如果它适合的话，它将会非常快。那么，我们如何确保它们都合身呢？在过去15年左右的时间里，苹果可能一直在关注性能，但在内存消耗问题上，他们却完全闭口不谈。当我在那里的时候，我们正在修复32字节的内存泄漏。这种情况只发生过一次，所以不是一次又一次地持续消耗32字节，而是一次性地泄漏32字节。这种近乎痴迷的奉献精神是iPhone一直击败内存两倍的顶级Android手机的原因之一。而且一点也不。另一个原因是iOS团队坚定不移地拒绝采用跟踪垃圾收集技术，而MacOS后来放弃了这项技术，转而采用他们自NeXT Step 4.0以来一直使用的引用计数(RC)技术。随着引用计数操作自动化程度的提高以及弱引用的添加，开发人员的便利性水平与现在的跟踪GC基本上没有什么区别。坚持使用RC的好处是大大减少了内存消耗。事实证明，要让跟踪GC获得与手动分配相当的性能，它需要几倍的内存(不同的研究发现不同的开销，但至少4倍是保守的下限)。虽然我还没有看到一项比较RC的研究，但我个人的经验是，开销要低得多，更容易预测，如果需要的话，通常只需很少的额外努力就可以降低成本。因此，苹果能够承受更多有限的总内存，因为他们需要更少的内存才能让系统运行得更快。所以他们可以做一个系统设计，强加这个限制，但允许他们让记忆变得非常快。好的。与跟踪GC相比，RC的另一个众所周知的限制使其成为第二选择，那就是总是更新这些引用计数的成本很高，尤其是在多线程环境中，这些更新需要是原子的。嗯..。有趣的事实：保留和释放NSObject在当前一代英特尔上需要大约30纳秒，在M1上需要大约6.5纳秒。</p><p>— David Smith (@Catfish_Man)  November 10, 2020</p><p>-大卫·史密斯(@Catfish_Man)2020年11月10日。</p><p> How? We got that working on x86-64 too :) this further improvement is because uncontended acquire-release atomics are about the same speed as regular load/store on A14</p><p>多么?。我们在x86-64上也实现了这一点：)这一进一步的改进是因为无争用的获取-释放原子库的速度与在A14上的常规加载/存储的速度大致相同。</p><p>— David Smith (@Catfish_Man)  November 10, 2020</p><p>-大卫·史密斯(@Catfish_Man)2020年11月10日。</p><p> Problem solved. I guess it helps if you can make your own Silicon ;-) So Apple&#39;s focus on keeping memory consumption under control, which includes but is not limitedto going all-in on reference counting where pretty much the rest of the industry has adoptedtracing garbage collection, is now paying off in a majory way (&#34;bigly&#34;? Too soon?). They can get away with putting less memory in the system, which makes it possible to make that memory really fast.And that locks in an advantage that&#39;ll be hard to duplicate. It also means that native development will have a bigger advantage compared to web technologies,because native apps benefit from the speed and don&#39;t have a problem with the memory limitations,whereas web-/electron apps will fill up that memory much more quickly.</p><p>问题解决了。我想，如果你能制造自己的硅片，那会有所帮助；-)所以苹果专注于控制内存消耗，包括但不限于全力以赴地引用计数，这一点业内其他公司几乎都采用了跟踪垃圾收集的方式，现在正在以一种重大的方式获得回报。太快了吗？)。他们可以在系统中使用更少的内存，这样就有可能让内存变得非常快。而且这一优势是很难复制的。这也意味着，与网络技术相比，原生开发将拥有更大的优势，因为原生应用从速度上受益，并且不存在内存限制的问题，而网络/电子应用将以更快的速度填满内存。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.metaobject.com/2020/11/m1-memory-and-performance.html">https://blog.metaobject.com/2020/11/m1-memory-and-performance.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1035013.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c3aa51b392e66b73c5cc441f2f873219.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035013.html">WARP：改进了Firefox 83中的JavaScript性能</a></div><span class="my_story_list_date">2020-11-14 9:1</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034815.html"><img src="http://img2.diglog.com/img/2020/11/thumb_a46c9d7cbefaa795c0e1f17be6540c92.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034815.html">FAST UI Draw是一个提供更高性能画布界面的库</a></div><span class="my_story_list_date">2020-11-13 15:13</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034754.html"><img src="http://img2.diglog.com/img/2020/11/thumb_8c211aac604e1466d518d906fef1d40b.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034754.html">使用Erlang/OTP 22进行性能回归</a></div><span class="my_story_list_date">2020-11-12 20:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034750.html"><img src="http://img2.diglog.com/img/2020/11/thumb_531e6f1bdfbafd80056260882331742e.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034750.html">.NET5令人惊叹的性能</a></div><span class="my_story_list_date">2020-11-12 20:15</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>