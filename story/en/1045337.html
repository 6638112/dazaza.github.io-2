<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>带有Rust的QtQuick中的高效自定义形状 Efficient custom shapes in QtQuick with Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Efficient custom shapes in QtQuick with Rust<br/>带有Rust的QtQuick中的高效自定义形状 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-20 21:26:28</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/8a3e6b4d6d5cd5b8195fe0fb8f50901d.png"><img src="http://img2.diglog.com/img/2021/1/8a3e6b4d6d5cd5b8195fe0fb8f50901d.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>One of the advantages of QWidgets when building a Qt application isthe ability to build in a simple way custom widgets with the QPainterAPI. This gives the Qt developer almost total freedom to implementcomplex geometries for their widgets.</p><p>构建Qt应用程序时，QWidgets的优点之一是能够使用QPainterAPI以简单的方式构建自定义窗口小部件。这使Qt开发人员几乎完全可以为其小部件实现复杂的几何形状。</p><p> On the other hands, QML contains by default only rectangles. Theserectangles can change the radius to create circles and rounded rectangles, but morecomplex shapes are more complicated.</p><p> 另一方面，QML默认仅包含矩形。这些矩形可以更改半径以创建圆形和圆形的矩形，但是形状越复杂则越复杂。</p><p>  Fortunally, the Qt API provides multiple ways to implement custom shapes,that depending on the needs might be enough.</p><p>  幸运的是，Qt API提供了多种实现自定义形状的方法，根据需要可能就足够了。</p><p> There is the Canvas API using the same API as the  canvas API on the web butin QML. It’s easy to use but very slow and I wouldn’t recommend it.</p><p> Canvas API使用与Web上的canvas API相同的API，但使用的是QML。它易于使用，但速度很慢，我不建议您这样做。</p><p> Instead of the Canvas API, from the QML side, there is the QtQuick Shapes module.This module allows creating more complex shapes directly from the QMLwith a straightforward declarative API. In many cases, this is good enoughfor the application developer but this module doesn’t offer a public C++API.</p><p> 从QML方面而不是Canvas API，而是QtQuick Shapes模块。该模块允许使用简单的声明性API直接从QML创建更复杂的形状。在许多情况下，这对于应用程序开发人员来说已经足够了，但是此模块不提供公共的C ++ API。</p><p> If you need more controls, using C++ will be required to implement custom QQuickItem. Unfortunately drawingon the GPU using QQuickItem is morecomplex than the QPainter API. You can’t just use commands like  drawRect,but will need to convert all your shapes in triangles first. This involvesa lot of maths like it can be seen in the example from the official documentation or from the KDAB tutorial (Efficient custom shapes in Qt Quick).</p><p> 如果需要更多控件，则需要使用C ++来实现自定义QQuickItem。不幸的是，使用QQuickItem在GPU上绘图比QPainter API更复杂。您不仅可以使用诸如drawRect之类的命令，还需要首先将所有形状转换为三角形。这涉及很多数学运算，例如可以从官方文档或KDAB教程（Qt Quick中的高效自定义形状）的示例中看到。</p><p> A QPainer way is also available with  QQuickPaintedItem,but it is slow because it renders your shape in a textured rectangle in theScene Graph.</p><p> QQuick方法也可用于QQuickPaintedItem，但它很慢，因为它会在“场景图”中的带纹理的矩形中渲染形状。 </p><p>  What if we could transform arbitrary shapes into triangles? We would get ahigh level API but still get great performance. This process is called tessellationand there are a few libraries that implement it. For example in C++, wehave Skia and CGAL. Unfortunatelly, both aren’t easy to use, so I decided to lookat the Rust library ecosystem and in particular at  Lyon,which was designed with performance and compliance to the SVG standard in mindsince the goal is to use it in Servo in the future.</p><p>如果我们可以将任意形状转换为三角形怎么办？我们将获得高级API，但仍然可以获得出色的性能。此过程称为镶嵌细分，并且有一些库可以实现该细分。例如，在C ++中，我们拥有Skia和CGAL。不幸的是，两者都不容易使用，所以我决定研究Rust库生态系统，尤其是在里昂，它的设计目标是性能和符合SVG标准，因为目标是将来在Servo中使用它。</p><p> Lyon doesn’t have any C++ bindings but I got inspired by the recent blog post from Jonahand I need to say the experience of writing bindings was a breeze.</p><p> 里昂（Lyon）没有任何C ++绑定，但是我受到Jonahand最近博客文章的启发，我需要说写绑定的经验是轻而易举的。</p><p> The first step was creating wrapper  structs around theLyon primitives.  LyonPoint,  LyonGeometry and  LyonBuilder willlater be directly usable from the C++ side.</p><p> 第一步是围绕Lyon原语创建包装器结构。 LyonPoint，LyonGeometry和LyonBuilder将在C ++方面直接可用。</p><p> #[cxx::bridge]   mod  ffi   {    pub   struct  LyonPoint   {    x:  f32 ,    y:  f32 ,    }     pub   struct  LyonVector   {    x:  f32 ,    y:  f32 ,    }     pub   struct  LyonGeometry   {    vertices:  Vec &lt; LyonPoint &gt; ,    indices:  Vec &lt; u16 &gt; ,    }     extern   &#34;Rust&#34;   {    type  LyonBuilder ;    fn  new_builder ()  -&gt;  Box &lt; LyonBuilder &gt; ;    fn  move_to ( self:  &amp; mut   LyonBuilder ,   point:  &amp; LyonPoint );    fn  line_to ( self:  &amp; mut   LyonBuilder ,   point:  &amp; LyonPoint );    fn  relative_move_to ( self:  &amp; mut   LyonBuilder ,   to:  LyonVector );    fn  close ( self:  &amp; mut   LyonBuilder );    fn  quadratic_bezier_to ( self:  &amp; mut   LyonBuilder ,   ctrl:  &amp; LyonPoint ,   to:  &amp; LyonPoint );    fn  cubic_bezier_to ( self:  &amp; mut   LyonBuilder ,   ctrl1:  &amp; LyonPoint ,   ctrl2:  &amp; LyonPoint ,   to:  &amp; LyonPoint );    fn  build_fill ( builder:  Box &lt; LyonBuilder &gt; )  -&gt;  LyonGeometry ;    fn  build_stroke ( builder:  Box &lt; LyonBuilder &gt; )  -&gt;  LyonGeometry ;    }   }</p><p> ＃[cxx :: bridge] mod ffi {pub struct LyonPoint {x：f32，y：f32，} pub struct LyonVector {x：f32，y：f32，} pub struct LyonGeometry {顶点：Vec＆lt;里昂点＆gt; ，索引：Vec＆lt; u16＆gt; ，} extern＆＃34; Rust＆＃34; {类型LyonBuilder; fn new_builder（）->框＆lt; LyonBuilder＆gt; ; fn move_to（self：＆amp; mut LyonBuilder，point：＆amp; LyonPoint）; fn line_to（self：＆amp; mut LyonBuilder，point：＆amp; LyonPoint）; fn relative_move_to（self：＆amp; mut LyonBuilder，to：LyonVector）; fn close（self：＆amp; mut LyonBuilder）; fn quadratic_bezier_to（self：＆amp; mut LyonBuilder，ctrl：＆amp; LyonPoint，to：＆amp; LyonPoint）; fncubic_bezier_to（self：＆amp; mut LyonBuilder，ctrl1：＆amp; LyonPoint，ctrl2：＆amp; LyonPoint，to：＆amp; LyonPoint）; fn build_fill（构建器：Box＆lt; LyonBuilder＆gt;）-＆gt;里昂几何; fn build_stroke（构建器：Box＆lt; LyonBuilder＆gt;）-＆gt;里昂几何; }}</p><p> We then need to define the methods we declared above. These are all trivialto implement since they are just wrapping the Lyon API.</p><p> 然后，我们需要定义上面声明的方法。这些都是简单的实现，因为它们只是包装了Lyon API。</p><p> use   ffi: { LyonPoint ,   LyonVector ,   LyonGeometry };    // Create a wrapper arround Lyon svg path. This struct is opaque from // the C++ side so we won&#39;t be able to access the internal object, but // we still can call the methods on it.  pub   struct  LyonBuilder   {    builder:  WithSvg &lt; Builder &gt; ,   }    // Implement wrapping methods  impl   LyonBuilder   {    fn  close ( &amp; mut   self )   {    self . builder . close ();    }     fn  move_to ( &amp; mut   self ,   to:  &amp; LyonPoint )   {    self . builder . move_to ( point ( to . x ,   to . y ));    }     fn  line_to ( &amp; mut   self ,   to:  &amp; LyonPoint )   {    self . builder . line_to ( point ( to . x ,   to . y ));    }     fn  quadratic_bezier_to ( &amp; mut   self ,   ctrl:  &amp; LyonPoint ,   to:  &amp; LyonPoint )   {    self . builder . quadratic_bezier_to ( point ( ctrl . x ,   ctrl . y ),   point ( to . x ,   to . y ));    }     ...   }    // Lyon Builder constructor  pub   fn  new_builder ()  -&gt;  Box &lt; LyonBuilder &gt;   {    return   Box:: new ( LyonBuilder {    builder:  Path:: builder (). with_svg ()    })   }</p><p> 使用ffi：{LyonPoint，LyonVector，LyonGeometry}; //创建一个环绕里昂svg路径的包装器。从C ++端来看，此结构是不透明的，因此我们将无法访问内部对象，但是//我们仍然可以在其上调用方法。 pub struct LyonBuilder {builder：WithSvg＆lt;建造者＆gt; ，} //实现包装方法impl LyonBuilder {fn close（＆amp; mut self）{self。建设者。关 （）; } fn move_to（＆amp; mut self，至：＆amp; LyonPoint）{self。建设者。 move_to（指向（指向。x，指向。y））; } fn line_to（＆amp; mut self，至：＆amp; LyonPoint）{self。建设者。 line_to（点（指向。x，指向。y））; } fn quadratic_bezier_to（＆amp; mut self，ctrl：＆amp; LyonPoint，to：＆amp; LyonPoint）{self。建设者。 quadratic_bezier_to（点（ctrl。x，ctrl。y），点（到。x，到。y））; } ...} // Lyon Builder构造函数pub fn new_builder（）->框＆lt; LyonBuilder＆gt; {return Box :: new（LyonBuilder {builder：Path :: builder（）。with_svg（）}）}</p><p> The next step was to add the  build_fill that will transform theSVG path instructions into a set of vertices and indices. These verticesand indices will be directly available from the C++ side. This is extremelyhandy since this can be directly fed into the  QSGGeometry painting method.</p><p> 下一步是添加build_fill，它将SVG路径指令转换为一组顶点和索引。这些顶点和索引可以从C ++端直接获得。这非常方便，因为它可以直接输入QSGGeometry绘制方法中。 </p><p> pub   fn  build_fill ( builder:  Box &lt; LyonBuilder &gt; )  -&gt;  LyonGeometry   {    let   mut   buffers:  VertexBuffers &lt; Point ,   u16 &gt;   =   VertexBuffers:: new ();    {    let   mut   vertex_builder   =   simple_builder ( &amp; mut   buffers );     // Create the tessellator.    let   mut   tessellator   =   FillTessellator:: new ();     let   path   =   builder . builder . build ();     // Compute the tessellation.    let   result   =   tessellator . tessellate_path (    &amp; path ,    &amp; FillOptions:: tolerance ( 0.01 ),    &amp; mut   vertex_builder    );    assert ! ( result . is_ok ());    }     LyonGeometry   {    // convert_points transform lyon::point to our LyonPoint wrapper    vertices:  convert_points ( buffers . vertices ),     indices:  buffers . indices ,    }   }</p><p>pub fn build_fill（builder：Box＆lt; LyonBuilder＆gt;）-＆gt; LyonGeometry {让mut缓冲区：VertexBuffers＆lt;点，u16＆gt; = VertexBuffers :: new（）; {let mut vertex_builder = simple_builder（＆amp; mut buffers）; //创建镶嵌器。 let mut tessellator = FillTessellator :: new（）;让path = builder。建设者。 build（）; //计算镶嵌。让结果=镶嵌。 tessellate_path（＆amp; path，＆amp; FillOptions ::公差（0.01），＆amp; mut vertex_builder）;断言！ （结果。is_ok（））; } LyonGeometry {// convert_points将lyon :: point转换为我们的LyonPoint包装器顶点：convert_points（buffers。vertices），索引：buffers。索引，}}</p><p> And we are almost done with the Rust side, we still need to create thecargo and corrosion configuration, but I won’t go into details in this post.You can look at how it was done in this  pet project.</p><p> 我们几乎已经完成了Rust方面的工作，我们仍然需要创建货物和腐蚀配置，但是在本文中我将不做详细介绍。您可以了解一下在这个宠物项目中是如何完成的。</p><p>  To make it easy to store and manipulate the path, I create a simple abstractionto the various SVG path instructions.</p><p>  为了简化存储和操作路径，我为各种SVG路径指令创建了一个简单的抽象。</p><p> #include  &lt;QList&gt;  #include  &lt;variant&gt;  #include  &lt;tessellation.rs.h&gt;   /// Move to the point without drawing a line.  struct  MoveTo {  /// The destination.   LyonPoint  to ; }; /// Drawe a line to a specific point.  struct  LineTo {  /// The destination.   LyonPoint  to ; }; /// Draw a cubic bezier curve to the point.  struct  CubicBezierTo {  /// First control point.   LyonPoint  ctrl1 ;  /// Second control point.   LyonPoint  ctrl2 ;  /// The destination.   LyonPoint  to ; }; /// Close a path.  struct  Close {}; /// SVG conform path commands  using  PathSection  =  std :: variant &lt; MoveTo ,  LineTo ,  CubicBezierTo ,  Close &gt; ; template &lt; class ...  Ts &gt;  struct  overloaded  :  Ts ...  {  using  Ts :: operator ()...;  }; template &lt; class ...  Ts &gt;  overloaded ( Ts ...)  -&gt;  overloaded &lt; Ts ... &gt; ; /// The SVG path data. It contains a list of instruction (move to, line to, ...).  using  PathData  =  QList &lt; PathSection &gt; ;</p><p> #include＆lt; QList＆gt; #include＆lt; variant＆gt; #include＆lt; tessellation.rs.h＆gt; ///移动到该点而不画一条线。 struct MoveTo {///目标。里昂点到; }; ///画一条线到特定点。 struct LineTo {///目标。里昂点到; }; ///在该点处绘制三次贝塞尔曲线。 struct CubicBezierTo {///第一个控制点。 LyonPoint ctrl1; ///第二个控制点。 LyonPoint ctrl2; ///目的地。里昂点到; }; ///关闭路径。 struct Close {}; /// SVG使用PathSection = std :: variant＆lt;遵循路径命令MoveTo，LineTo，CubicBezierTo，Close＆gt; ;模板＆lt;类... Ts＆gt;结构重载：Ts ... {使用Ts :: operator（）...; };模板＆lt;类... Ts＆gt;超载（Ts ...）->超载＆lt; Ts ...＆gt; ; /// SVG路径数据。它包含指令列表（移至，行至...）。使用PathData = QList＆lt;路径部分＆gt; ;</p><p> Now let finally use Lyon to generate the geometry primitives. This willneed to be called every time the list of commands is updated. It’s usingthe command abstraction, I build previously, but this could directly callthe LyonBuilder methods.</p><p> 现在，让我们最终使用Lyon生成几何图元。每次更新命令列表时都需要调用此方法。它使用的是我之前构建的命令抽象，但是可以直接调用LyonBuilder方法。</p><p> const  auto  commands  &lt;&lt;  MoveTo  {  LyonPoint { 0.0 ,  0.0 }  }  &lt;&lt;  LineTo  {  LyonPoint { 0.0 ,  40.0 }  }  &lt;&lt;  LineTo  {  LyonPoint { 40.0 ,  40.0 }  }  &lt;&lt;  CubicBezierTo {  LyonPoint { 70.0 ,  40.0 },  LyonPoint { 70.0 ,  0.0 },  LyonPoint {  50.0 ,  20.0 }  }  &lt;&lt;  LineTo  {  LyonPoint { 40.0 ,  0.0 }  }  &lt;&lt;  Close  {}; auto  lyonBuilder  =  new_builder (); for  ( const  auto  &amp; command :  commands )  {  std :: visit ( overloaded  {  [ &amp; lyonBuilder ]( MoveTo  moveTo )  {  lyonBuilder -&gt; move_to ( moveTo . to );  },  [ &amp; lyonBuilder ]( LineTo  lineTo )  {  lyonBuilder -&gt; line_to ( lineTo . to );  },  [ &amp; lyonBuilder ]( CubicBezierTo  cubicBezierTo )  {  lyonBuilder -&gt; cubic_bezier_to ( cubicBezierTo . ctrl1 ,  cubicBezierTo . ctrl2 ,  cubicBezierTo . to );  },  [ &amp; lyonBuilder ]( Close )  {  lyonBuilder -&gt; close ();  },  },  command ); } auto  m_geometry  =  build_fill ( std :: move ( lyonBuilder ));</p><p> const自动命令＆lt;＆lt; MoveTo {LyonPoint {0.0，0.0}}＆lt;＆lt; LineTo {LyonPoint {0.0，40.0}}＆lt;＆lt; LineTo {LyonPoint {40.0，40.0}}}＆lt;＆lt; CubicBezierTo {LyonPoint {70.0，40.0}，LyonPoint {70.0，0.0}，LyonPoint {50.0，20.0}}＆lt;＆lt; LineTo {LyonPoint {40.0，0.0}}}＆lt;＆lt;关  {};自动lyonBuilder = new_builder（）; for（const auto＆amp; command：命令）{std :: visit（重载{[＆amp; lyonBuilder]（MoveTo moveTo）{lyonBuilder-＆gt; move_to（moveTo。to）;}，[＆amp; lyonBuilder]（LineTo lineTo） {lyonBuilder-＆gt; line_to（lineTo。to）;}，[＆lyonBuilder]（CubicBezierTo cubeBezierTo）{lyonBuilder-＆gt; cubic_bezier_to（cubicBezierTo。ctrl1，cubicBezierTo。ctrl2，cubicBezierly，[to]至） （Close）{lyonBuilder-> close（）;}，}，命令）; } auto m_ge​​ometry = build_fill（std :: move（lyonBuilder））;</p><p> And finally here is our  updatePaintNode method. It’s using the  GL_TRIANGLESdrawing mode and the vertices and indices are copied directly from the geometryLyon gave us.</p><p> 最后是我们的updatePaintNode方法。它使用GL_TRIANGLES绘图模式，并且顶点和索引是直接从geometryLyon给我们的几何图形中复制的。 </p><p> QSGNode  * PathItem :: updatePaintNode ( QSGNode  * oldNode ,  UpdatePaintNodeData  * ) {  QSGGeometryNode  * node  =  nullptr ;  QSGGeometry  * geometry  =  nullptr ;  if  ( ! oldNode )  {  node  =  new  QSGGeometryNode ;  geometry  =  new  QSGGeometry ( QSGGeometry :: defaultAttributes_Point2D (),  m_geometry . vertices . size (),  m_geometry . indices . size ());  geometry -&gt; setIndexDataPattern ( QSGGeometry :: StaticPattern );  geometry -&gt; setDrawingMode ( GL_TRIANGLES );  node -&gt; setGeometry ( geometry );  node -&gt; setFlag ( QSGNode :: OwnsGeometry );  QSGFlatColorMaterial  * material  =  new  QSGFlatColorMaterial ;  material -&gt; setColor ( QColor ( 255 ,  0 ,  0 ));  node -&gt; setMaterial ( material );  node -&gt; setFlag ( QSGNode :: OwnsMaterial );  }  else  {  node  =  static_cast &lt; QSGGeometryNode  *&gt; ( oldNode );  geometry  =  node -&gt; geometry ();  geometry -&gt; allocate ( m_geometry . vertices . size (),  m_geometry . indices . size ());  }  QSGGeometry :: Point2D  * points  =  geometry -&gt; vertexDataAsPoint2D ();  std :: size_t  i  =  0 ;  for  ( const  auto  &amp; vertice :  m_geometry . vertices )  {  points [ i ]. set ( vertice . x ,  vertice . y );  i ++ ;  }  quint16 *  indices  =  geometry -&gt; indexDataAsUShort ();  i  =  0 ;  for  ( const  auto  indice :  m_geometry . indices )  {  indices [ i ]  =  indice ;  i ++ ;  }  node -&gt; markDirty ( QSGNode :: DirtyGeometry );  return  node ; }</p><p>QSGNode * PathItem :: updatePaintNode（QSGNode * oldNode，UpdatePaintNodeData *）{QSGGeometryNode * node = nullptr; QSGGeometry *几何= nullptr;如果（！oldNode）{node = new QSGGeometryNode; geometry = new QSGGeometry（QSGGeometry :: defaultAttributes_Point2D（），m_geometry。顶点。size（），m_geometry。index。size（））;几何-＆gt; setIndexDataPattern（QSGGeometry :: StaticPattern）;几何-＆gt; setDrawingMode（GL_TRIANGLES）;节点-＆gt; setGeometry（geometry）;节点-＆gt; setFlag（QSGNode :: OwnsGeometry）; QSGFlatColorMaterial *材质=新的QSGFlatColorMaterial;材料-＆gt; setColor（QColor（255，0，0））;节点-＆gt; setMaterial（material）;节点-＆gt; setFlag（QSGNode :: OwnsMaterial）; } else {node = static_cast＆lt; QSGGeometryNode *＆gt; （oldNode）;几何=节点->几何（）;几何-＆gt;分配（m_geometry。顶点。size（），m_geometry。索引。size（））; } QSGGeometry :: Point2D *点=几何-> vertexDataAsPoint2D（）; std :: size_t i = 0; for（const auto＆amp; vertice：m_geometry。vertices）{点[i]。设置（顶点。x，顶点。y）;我++; } quint16 *索引=几何-> indexDataAsUShort（）;我= 0; for（常量自动索引：m_geometry.indexs）{索引[i] =索引;我++; }节点-＆gt; markDirty（QSGNode :: DirtyGeometry）;返回节点; }</p><p> It is only using Lyon SVG path rendering, but Lyon provides a lot more APIs.For example, there is an abstraction that allows to draw circle, ellipse, roundedrectangle and other basic geometric forms.</p><p> 它仅使用Lyon SVG路径渲染，但是Lyon提供了更多的API，例如，有一个抽象允许绘制圆形，椭圆形，圆角矩形和其他基本几何形式。</p><p> There is also the possibility to add custom attributes for texture coordinateor color coordinate. Depending on your need more part of the API could be wrappedand I might create a small library wrapping most of the API.</p><p> 也可以为纹理坐标或颜色坐标添加自定义属性。根据您的需要，可以包装API的更多部分，我可以创建一个包装大多数API的小型库。</p><p>  I used this technique in a new toy I’m building. I’m not sure where it isgoing, but I currently have this:</p><p>  我在制作的新玩具中使用了这种技术。我不确定要去哪里，但是我现在有这个： </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://carlschwan.eu/2021/01/20/efficient-custom-shapes-in-qtquick-with-rust/">https://carlschwan.eu/2021/01/20/efficient-custom-shapes-in-qtquick-with-rust/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/custom/">#custom</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>