<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用符号执行查找软件错误 Finding Software Bugs Using Symbolic Execution</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Finding Software Bugs Using Symbolic Execution<br/>使用符号执行查找软件错误 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-24 21:34:40</div><div class="page_narrow text-break page_content"><p>The idea of dynamic  symbolic execution is to execute a piece of software on any input.All possible execution paths are explored simultaneously without specifying concrete values.Consider the following example where the input  x is unknown, i.e., symbolic:</p><p>动态符号执行的思想是在任何输入上执行一个软件，在不指定具体值的情况下同时探索所有可能的执行路径，请考虑以下示例，其中输入x是未知的，即符号：</p><p> if  ( x  &lt;  0 )  {  // ...  }  else  if  ( x  &gt;  100 )  {  // ...  }  else  {  assert ( &#34;should not reach this!&#34; ) }</p><p> if（x＆lt; 0）{// ...} else if（x＆gt; 100）{// ...} else {断言（＆＃34;不应达到此值！＆＃34;）}}</p><p> Symbolic execution runs this code on all three  execution paths ( x&lt;0,  x&gt;100,  0&lt;=x&lt;=100) and generates three concrete test cases:  x=-1,  x=101 and  x=23 after hitting the assertion.</p><p> 符号执行在所有三个执行路径（x  100、0 <= x <= 100）上运行此代码，并在命中断言后生成三个具体的测试用例：x = -1，x = 101和x = 23 。</p><p> You don’t need to write test cases manually anymore.You catch assertion failures and memory safety errors along the execution paths.Ok, that is all in theory, but can this approach work for real-world programs in practice?</p><p> 您不再需要手动编写测试用例。您可以沿执行路径捕获断言失败和内存安全错误。好吧，从理论上讲，但是这种方法在实践中是否可以适用？</p><p>  KLEE is a symbolic execution engine that executes unmodified, real-world programs on any input.You compile your program to  LLVM bitcode, mark some inputs as symbolic, and start KLEE.KLEE explores possible execution paths using constraint solving and generates concrete test cases for each of them.In case of a bug, you can replay your program with the input that triggered it.</p><p>  KLEE是一种符号执行引擎，可对任何输入执行未经修改的真实程序，您可以将程序编译为LLVM位码，将某些输入标记为符号后启动KLEE.KLEE使用约束解决方案探索可能的执行路径并生成具体的测试用例如果发生错误，您可以使用触发它的输入来重播程序。</p><p> In November 2019, the seminal  OSDI 2008 paper on KLEE  has been elected to ACM SIGOPS Hall of Fame.Over the past decade, the research and application of KLEE resulted in over 150 scientific publications, dozens of Ph.D. theses, research grants, tools, and security startups.On my behalf, I spent more than five years of my life with KLEE as well and learned a lot along the way.</p><p> 2019年11月，关于KLEE的OSDI 2008开创性论文被选为ACM SIGOPS名人堂。在过去的十年中，KLEE的研究和应用产生了150多种科学出版物，数十种博士学位。这些论文，研究补助金，工具和安全性初创公司。我代表我在KLEE度过了超过五年的生活，并在此过程中学到了很多东西。</p><p>  In 2007, I struggled to find my research thesis until I came across Cristian Cadar’s paper  “EXE: Automatically Generating Inputs of Death”.Inspired by the idea of symbolic execution, I asked myself the following question:  Can I mark the protocol header of an incoming network packet symbolic before passing it to the network stack?If so, can I find protocol specification and implementation bugs with this technique?</p><p>  在2007年，我一直难以找到自己的研究论文，直到遇到Cristian Cadar的论文“ EXE：自动生成死亡输入”。受符号执行概念的启发，我问自己以下问题：我可以标记一个程序的协议头吗？如果传入的网络数据包在传递到网络堆栈之前是符号性的，如果可以，我是否可以使用这种技术找到协议规范和实现错误？ </p><p> I wrote an e-mail to Cristian Cadar and promptly received an answer.Moreover, Cristian and Daniel Dunbar generously sent me the source code of KLEE, a new tool they were working on, even before its official release to the public.</p><p>我写了一封电子邮件给克里斯蒂安·卡达尔（Cristian Cadar），并立即收到了答复。</p><p> In the following five years of my Ph.D. journey, I extended KLEE to execute several protocol stacks that talk to each other.I applied this technique to test sensor networks and found a couple of interesting bugs in the Contiki OS described in my  IPSN 2010 paper.One of them caused a dead-lock of a sensor node inside the TCP/IP stack requiring a hardware reset.It was a real bug observed in sensor network deployments.</p><p> 在接下来的五年博士学位中在旅途中，我扩展了KLEE以执行相互通信的多个协议栈。我将该技术应用于测试传感器网络，并在IPSN 2010论文中描述的Contiki OS中发现了两个有趣的错误，其中一个导致了死锁TCP / IP堆栈中需要硬件重置的传感器节点的数量。这是在传感器网络部署中观察到的真实错误。</p><p> I have not used KLEE actively since 2015 and was curious to give it a try (again).Meanwhile, Contiki OS has been forked to  Contiki-NG.I cloned the repo and compiled the test case called  20-packet-parsing to LLVM bitcode.Inside the test case, I marked the test packet buffer (~1KB) symbolic using KLEE’s  klee_make_symbolic function.</p><p> 自2015年以来，我一直没有积极使用KLEE，并且想再次尝试使用KLEE。同时，Contiki OS已分叉给Contiki-NG，我克隆了repo并将编译成20个数据包的测试用例编译为LLVM位代码在测试用例中，我使用KLEE的klee_make_symbolic函数将测试数据包缓冲区（〜1KB）标记为符号。</p><p> After running for a couple of minutes on my old Mac, KLEE discovered two memory errors (out of bound pointers) while parsing certain protocols&#39; headers.I reported these findings with the concrete test cases to the security team of Contiki-NG for further analysis.To me, this small test is yet another evidence that KLEE remains to be a useful research and test case generation tool.</p><p> 在我的旧Mac上运行了几分钟后，KLEE在解析某些协议时发现了两个内存错误（指针超出范围）。我将这些发现与具体的测试案例一起报告给Contiki-NG的安全团队进行进一步分析。对我来说，这个小测试又证明了KLEE仍然是有用的研究和测试案例生成工具。</p><p>  Applying symbolic execution to arbitrary real-world programs is hard.You often have to model the execution environment and find effective ways to cope with non-determinism and path explosion.Moreover, many of the path constraints are difficult yet intractable to be solved in time with today’s solvers.</p><p>  将符号执行应用于任意现实世界的程序非常困难，您通常必须对执行环境进行建模并找到有效的方法来应对不确定性和路径爆炸问题，而且许多路径约束很难解决但难以及时解决与今天的求解器。</p><p> Nevertheless, studying and applying symbolic execution (using KLEE) opens many opportunities.You will learn about program structure, compilers, SAT/SMT solvers, and how to write other kinds of testing tools.Given this bag of knowledge, I wrote tools to  fuzz Android apps,  superoptimize LLVM IR, and more recently at work, a tool to  fuzz satellite control procedures written in SPELL.</p><p> 尽管如此，学习和应用符号执行（使用KLEE）仍会带来许多机会。您将学习程序结构，编译器，SAT / SMT求解器以及如何编写其他类型的测试工具。鉴于这一系列知识，我编写了模糊测试工具Android应用程序对LLVM IR进行了超优化，最近又投入使用，这是一种使SPELL编写的卫星控制程序模糊化的工具。</p><p> Consider giving symbolic execution a try.If you are a Ph.D. student and struggling to find a thesis topic in this area,  don’t forget the bigger picture and keep pushing.</p><p> 考虑尝试符号执行。如果您是博士学位。的学生并在该领域中努力寻找论文主题，请不要忘记更大的图景并继续努力。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://sasnauskas.eu/finding-software-bugs-using-symbolic-execution/">https://sasnauskas.eu/finding-software-bugs-using-symbolic-execution/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/符号执行/">#符号执行</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/software/">#software</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/klee/">#klee</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>