<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们都不想要在前端使用SQL吗？ Don’t we all just want to use SQL on the front end?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Don’t we all just want to use SQL on the front end?<br/>我们都不想要在前端使用SQL吗？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-16 02:51:16</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/a50cb1135672095796e197b2565c2a17.png"><img src="http://img2.diglog.com/img/2021/4/a50cb1135672095796e197b2565c2a17.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>When we consume REST, GraphQL, or RPC APIs from the frontend, most of the time these api calls just end up being translated into SQL statements on the backend.</p><p>当我们从前端使用REAS，GraphQL或RPC API时，大部分时间都呼叫才会最终转换为后端的SQL语句。</p><p> So why don’t we just write SQL in the frontend to begin with?</p><p> 那么为什么我们不只是在前端写下SQL以开始呢？</p><p>  To ensure a snappy app, we usually need a normalized cac he on the frontend. When we start trying to do optimistic updates is when things get complicated really quickly. Unless our frontend data model maps exactly to our backend model, we have to do a bunch of quirky, manual cache updates. Just check out Apollo’s guide for  optimistic UI — its intense!  Swr and  react-query also leave the manual query invalidation and cache updating to you.</p><p>  为确保Snappy应用程序，我们通常需要正常化的CAC他。当我们开始尝试做乐观的更新时，事情很快就会变得复杂。除非我们的前端数据模型完全映射到我们的后端模型，否则我们必须做一堆Quirky，手动缓存更新。只需查看Apollo的乐观UI指南 - 它的激烈！ SWR和React-查询还将手动查询无效和缓存更新给您。</p><p>  The hard truth is that if we want perfect optimistic UI updates, we are going to need to replicate our backend data model in our frontend. And if we are using an SQL database with relational data, then we should have an SQL database in the frontend. If you can make this work you also get offline support for free.</p><p>  难事位是，如果我们想要完美的乐观UI更新，我们将需要在前端复制我们的后端数据模型。如果我们使用具有关系数据的SQL数据库，那么我们应该在前端中具有SQL数据库。如果您可以进行此工作，您还可以免费获取脱机支持。</p><p> Think about all the code you normally write to process API responses on the frontend. I usually end up with a bunch of Lodash (groupBy, filter, map, reduce) to shape the data I get from the server. This always becomes unwieldy and I always end up wishing I could just use SQL.</p><p> 考虑您通常写入前端的过程API响应的所有代码。我通常最终有一堆Lodash（GroupBy，Filter，Map，Refice）来塑造我从服务器获得的数据。这总是变得笨拙，我总是最终希望我能使用SQL。</p><p> An example might be a task management app like Asana, with a sidebar of Projects, and a list of Tasks next to it, with a task count showing next to each project.</p><p> 一个例子可能是asana等任务管理应用程序，其中包含一个项目侧边栏，以及它旁边的任务列表，任务计数显示在每个项目旁边。</p><p>    If you add a new task to a project, you need to update the project count in the sidebar. Ideally, you simply want to add a new Tasks entity and associate it with a Project. This is one line of SQL.</p><p>    如果向项目添加新任务，则需要更新侧栏中的项目计数。理想情况下，您只想添加新的任务实体并将其与项目相关联。这是SQL的一行。 </p><p>  Then we run all our queries again, and our interface will be automatically consistent with our data model.</p><p>然后我们再次运行所有查询，我们的界面将自动与我们的数据模型一致。</p><p> But if our API is not derived by an underlying relational model, and we want optimistic updates, we have to manually update our local model as seen in the Apollo example above — whereby the new comment is manually added to the cached query response. We also have to be careful to only re-trigger dependent queries because they will result in new fetches.</p><p> 但是，如果我们的API不是由基础关系模型导出，并且我们想要乐观的更新，我们必须手动更新我们的本地模型，如上所述的Apollo示例所示 - 在那里手动添加新的注释到缓存的查询响应中。我们也必须小心只重新触发依赖查询，因为它们会导致新的获取。</p><p> Whenever we render or modify a local entity that exists in one or more places in our UI, we want it to be consistent.</p><p> 每当我们渲染或修改UI中一个或多个地方存在的本地实体时，我们希望它保持一致。</p><p>  We used to be told our APIs must be REST. So that’s what we did.</p><p>  我们曾经被告知我们的API必须休息。所以这就是我们所做的。</p><p> Then GraphQL liberated us from REST, and said: it’s okay to do RPC again over a single endpoint. And the same people had their own protocol, so that’s what we did.</p><p> 然后将GraphQL从休息中解放出来，并说：可以通过单个端点再次执行RPC。而同样的人有自己的协议，所以这就是我们所做的。</p><p> But now that it’s okay to do RPC again, maybe we can complete the loop, and it becomes okay to do…SQL again…just like we did when we built desktop apps.</p><p> 但是现在可以再做一次RPC，也许我们可以完成循环，并且可以做到这一点...... SQL再次......就像我们建立桌面应用时一样。</p><p> Security concerns are probably also a significant reason why people may have brushed it aside. Without built-in safety it can be super dangerous.</p><p> 安全问题可能也是人们可能已经把它刷掉的重要原因。没有内置安全，它可能是超级危险的。 </p><p>  We already have have  SQLite in the browser via wasm that we could use for this. A pure SQLite JS implementation would be cool though.</p><p>我们已经通过WASM在浏览器中拥有SQLite，我们可以使用它。纯SQLite JS实现将很酷。</p><p> We need a restrictive SQL parser to run server-side to restrict what can be run and prevent SQL injection. Maybe we need a query-builder/ORM to generate a safe intermediary SQL language in JSON so that we can validate it. Maybe taking some inspiration from  Prisma’s type-safe data-mapper client could be used to help people write safe queries that won’t fail server-side validation unexpectedly.</p><p> 我们需要一个限制性的SQL解析器来运行服务器端来限制可以运行的内容并防止SQL注入。也许我们需要一个查询库/ orm来在JSON中生成一个安全的中介SQL语言，以便我们可以验证它。也许从prisma的类型安全的数据 - 映射器客户端采取一些启发，可用于帮助人们编写不会意外地失败的安全查询。</p><p> On the server, maybe views and row-level security as  @unodgs has written about  here could help. Don’t forget that GraphQL can also have over-fetching security vulnerabilities if resolvers are not carefully implemented, so its not as crazy as it seems.</p><p> 在服务器上，也许视图和行级安全性，因为@unodgs写了关于此处的帮助。如果没有仔细实施解析器，请不要忘记GraphQL也可以具有过度提取的安全漏洞，因此它似乎并不像似乎一样疯狂。</p><p> For mutations, because they are quite dangerous and require a lot of validation, we could fallback to REST, GraphQL mutations, RPC. Unless there is great value in allowing bulk INSERT/UPDATE as a sub-query of a SELECT, its probably better to avoid sending them server-side, and only use them to update our local data model.</p><p> 对于突变，因为它们是非常危险的并且需要大量的验证，我们可以恢复休息，GraphQL突变，RPC。除非允许批量插入/更新作为选择的子查询有很大的价值，否则它可能最好避免发送服务器端，并仅使用它们来更新我们的本地数据模型。</p><p>  Maybe SQL could be our unified data model if we can get Postgres’ foreign data wrapper extension to work in the browser, wrapping LocalStorage, Chrome Extension APIs, IndexedDB, etc. Even perhaps third-party APIs — in a similar way that GraphQL federation works.</p><p>  如果我们可以获得Postgres的外国数据包装器扩展，可以在浏览器中工作，包装localStorage，Chrome扩展API，IndexedDB等，即使也许是第三方API的统一数据模型，也可以是第三方API的统一数据模型。</p><p> An advantage of a local  effortlessly-normalized cache is we don’t have to worry so much about how we write our queries, because they will most likely hit the cache, and we can rely on some smart logic to retrieve the data that is missing.</p><p> 本地毫不费力的高速缓存的优势是我们不必如此担心我们如何编写查询，因为它们很可能会击中缓存，我们可以依靠一些智能逻辑来检索缺少的数据。</p><p> With the WAL (write ahead log) we also have the ability to time-travel like Redux promised us. This would also come in handy perhaps in efficiently syncing changes, and rolling back optimistic UI updates on server error.</p><p> 随着WAL（写下未来的日志），我们也有时旅行的能力，如REDUX承诺我们。这也可能在有效地同步更改中方便，并在服务器错误中回滚乐观UI更新。 </p><p> Maybe things like SSR and PJAX will mean we rely less on client-side state in the future though, and UI updates will come as HTML over WebSockets or something like that.</p><p>也许SSR和PJAX这样的事情将意味着我们将来的客户端依赖于客户端状态，并且UI更新将在WebSockets或类似的内容中作为HTML。</p><p> Could all a user’s data be represented by a single SQLite database synced frontend/backend that can be downloaded to provide a completely offline experience or data takeout feature?</p><p> 所有用户的数据都可以由单个SQLite数据库同步的前端/后端表示，可以下载以提供完全离线体验或数据摘要功能？</p><p>    There is so much tooling and momentum around GraphQL, it would be good to salvage it. Maybe we could build a local SQL-based cache for GraphQL queries, and use something like  Prisma’s data model definition schema to map our GraphQL queries to our local SQLite database.</p><p>    GraphQL周围有如此多的工具和势头，挽救它会很好。也许我们可以为GraphQL查询构建本地SQL的缓存，并使用Prisma数据模型定义架构等内容来将我们的GraphQL查询映射到本地SQLite数据库。</p><p> Something other than SQLite. It’s sad that  WebSQL disappeared but as I recently heard Jake Archibald mention on  a JS Jabber podcast episode, what would be better is a byte-level storage api so that people can implement their own efficient SQL engines in the browser.</p><p> 除了Sqlite以外的东西。 WebSQL消失了，但随着我最近在JS Jabber Podcast剧集中提到了Jake Archibald，更好的是一个字节级存储API，以便人们可以在浏览器中实现自己的有效的SQL引擎。</p><p>  SQL is everywhere today. No-code tools are all embracing SQL. Google Sheets, Airtable, Retool. The best way to unleash your non-technical employees is to get them access to your data via SQL. Everyone wants it. That’s why there is such a plethora of new tools out there.</p><p>  SQL今天无处不在。没有代码工具都包含SQL。 Google Sheets，Airtable，Retool。释放您的非技术员工的最佳方式是通过SQL获取您的数据。每个人都想要它。这就是为什么那里有这样一个新的工具。</p><p> SQLite is being mentioned a lot too recently, which is one of the reasons I thought about writing this down. If more people are comfortable using it</p><p> SQLite最近被提到了很多，这是我想到这一点的原因之一。如果更多人舒适使用它</p><p>  What am I missing? I’m keen to play around with this to see if it’s workable, because the one thing for sure is that the way we currently do optimistic UI updates with Apollo and react-query is untenable.</p><p>  我错过了什么？我热衷于通过这个玩耍，看看它是否是可行的，因为有一件事是肯定的，我们目前与apollo和反应查询做出乐观的ui更新的方式是站不住脚的。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://vjpr.medium.com/dont-we-all-just-want-to-use-sql-on-the-frontend-6b9d38c08146">https://vjpr.medium.com/dont-we-all-just-want-to-use-sql-on-the-frontend-6b9d38c08146</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/sql/">#sql</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>