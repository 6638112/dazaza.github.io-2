<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#类型</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#类型</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1034611.html">大规模采用打字稿的感悟</a></div><div class="item_title_en"><a target="_blank" href="https://www.techatbloomberg.com/blog/10-insights-adopting-typescript-at-scale/">Insights from Adopting TypeScript at Scale</a><span>(www.techatbloomberg.com)</span></div><span class="my_story_list_date">2020-11-12 2:32</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1034611.html"><img src="http://img2.diglog.com/img/2020/11/thumb_ed4d9f6bb8a5a76b5af188414a92585d.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">几年前，彭博工程(Bloomberg Engineering)决定采用打字稿作为一种一流的支持语言。这篇文章分享了我们在这段旅程中学到的一些见解和教训。
标题是，我们发现打字稿是一个很好的净值！在阅读我们探索的一些令人惊讶的角落时，请记住这一点。作为工程师，我们自然会被发现、解决和分享问题所吸引，即使我们在😉上玩得很......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/采用/">#采用</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/adopting/">#adopting</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1034305.html">F#5</a></div><div class="item_title_en"><a target="_blank" href="https://devblogs.microsoft.com/dotnet/announcing-f-5/">F# 5</a><span>(devblogs.microsoft.com)</span></div><span class="my_story_list_date">2020-11-11 1:46</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1034305.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c048e76e97f37c2c2721591fa63f0f86.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">今天，我们很兴奋地宣布F#5正式发布。它与.NET5一起发布。我们在过去的一年里一直致力于F#5，我们很高兴能与大家分享它。
如果您在Windows上使用Visual Studio，则需要升级到最新的16.8版本。
从F#4.1到F#5，F#的主要关注点一直是对.NET Core(现在是.NET5)的巨大支持。有了F......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1034217.html">使用Scala 3进行显式项推理</a></div><div class="item_title_en"><a target="_blank" href="https://www.scala-lang.org/2020/11/06/explicit-term-inference-in-scala-3.html">Explicit term inference with Scala 3</a><span>(www.scala-lang.org)</span></div><span class="my_story_list_date">2020-11-10 15:24</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1034217.html"><img src="http://img2.diglog.com/img/2020/11/thumb_84e9ef6db136f3fbdf494272e186a3fb.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">对于采用Scala3的开发人员来说，最显著的变化之一是引入了新的语法来取代以前Scala版本中使用的隐式机制。
新语法背后的动机是，相同的隐式关键字用于不同的目的和模式，因此它成为表达如何实现模式的一种方式。这意味着，当用户遇到这个模棱两可的咒语时，需要破译开发者的意图：这是一种转换吗？这是否避免了参数重复？这是类型......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/scala/">#scala</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/term/">#term</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1033662.html">为什么输入Erlang很难：标准Erlang</a></div><div class="item_title_en"><a target="_blank" href="https://abstractmachines.dev/posts/am012-why-typing-erlang-is-hard.html">Why Typing Erlang is Hard: Standard Erlang</a><span>(abstractmachines.dev)</span></div><span class="my_story_list_date">2020-11-7 14:13</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1033662.html"><img src="http://img2.diglog.com/img/2020/11/thumb_76fee038427af967d4a62ff40c6ab0a4.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我之前听说过Erlang和BEAM没有打包静态类型系统，因为他们的创建者“无法构建它”。
虽然构建一个复杂、可靠和可伸缩的类型检查器绝对不是在公园里散步，但构建一个工作正常的类型检查器并不难。
如果这是可以做到的，它就会被完成，而且它会通过与OTP强化相同的过程来强化，并变成今天的样子：可靠性黄金标准。
因此，我决定......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/erlang/">#erlang</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1033308.html">GO类型参数-吃水设计</a></div><div class="item_title_en"><a target="_blank" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md">Go Type Parameters – Draft Design</a><span>(go.googlesource.com)</span></div><span class="my_story_list_date">2020-11-5 20:20</span><div class="my_story_list_item_desc">我们建议扩展Go语言，在类型和函数声明中添加可选的类型参数。类型参数受接口类型的约束。接口类型用作类型约束时，允许列出可能分配给它们的一组类型。在许多情况下，通过统一算法的类型推断允许从函数调用中省略类型参数。该设计完全向后兼容GO 1。
然后，我们从零开始解释整个设计，在需要的时候介绍细节，并用简单的例子介绍它们。......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/参数/">#参数</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1033108.html">三个月的行程(从哈斯克勒的角度看)</a></div><div class="item_title_en"><a target="_blank" href="https://memo.barrucadu.co.uk/three-months-of-go.html">Three Months of Go (From a Haskeller's Perspective)</a><span>(memo.barrucadu.co.uk)</span></div><span class="my_story_list_date">2020-11-4 11:30</span><div class="my_story_list_item_desc">这个夏天我一直在Pusher实习，写了很多围棋。哈斯克尔的背景有点改变，所以我决定在最后写下我的想法。
没什么可去的，它是一种相当小的语言。在六月之前我一行也没有写过，现在我已经写了大约三万篇了。入门并变得富有成效是非常容易的。
另一方面，Haskell以难学而臭名昭著(咳嗽单曲教程咳嗽)。人们经常发现很难从计算纯数......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/行程/">#行程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/haskeller/">#haskeller</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1032706.html">名称不是类型安全的</a></div><div class="item_title_en"><a target="_blank" href="http://lexi-lambda.github.io/blog/2020/11/01/names-are-not-type-safety/">Names are not type safety</a><span>(lexi-lambda.github.io)</span></div><span class="my_story_list_date">2020-11-2 9:23</span><div class="my_story_list_item_desc">Haskell程序员花了大量时间讨论类型安全。程序构造的哈斯克尔学派主张“捕获类型系统中的不变量”和“使非法状态不可表示”，这两个听起来都是令人信服的目标，但在实现这些目标所使用的技术上却相当模糊。几乎就在一年前，我出版了“解析，不要验证”(Parse，Don‘t Validation)一书，作为弥合这一鸿沟的初步尝......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/type/">#type</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1032409.html">我讨厌Python静态类型标注方案</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/@hopro/i-detest-the-python-static-typing-annotation-schemes-fbb0fa9b1f59">I detest the Python static-typing annotation schemes</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-10-31 7:54</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1032409.html"><img src="http://img2.diglog.com/img/2020/10/thumb_2269f52f0eb0ef16935e9b7ae5ee39df.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">基本上。我并不讨厌Python类型的批注-在我看来：int=0没有什么错。但是，每当我不得不看任何给定的冗长的废墟时，这双眼睛确实会有点流血，这就是打字模块鼓励人们写作的那种杂乱无章的东西。
类型模块，以及它最好的Mypy静态分析器和Linter，已经预先劫持了两个看似有用的新的、不可靠的Python类方法：__CL......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1031030.html">“抗锈”的表现型系统</a></div><div class="item_title_en"><a target="_blank" href="https://thefuntastic.com/blog/fighting-rusts-type-system">Fighting Rust's Expressive Type System</a><span>(thefuntastic.com)</span></div><span class="my_story_list_date">2020-10-25 9:1</span><div class="my_story_list_item_desc">在这里，我与大家分享一位经验丰富的开发人员首次涉足现实世界的锈蚀项目。它密切关注类型系统，以及我开始思考铁锈所需要的关键洞察力。它是为那些掌握这门语言的人编写的，如果您的背景不是函数式编程，它将特别有用。
虽然最初设想为第2部分(共2部分)，但可以将其作为独立条目读取。在为普通读者编写的第1部分中，我详细介绍了Mak......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/表现型/">#表现型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1030569.html">镍：以更少的成本实现更好的配置</a></div><div class="item_title_en"><a target="_blank" href="https://www.tweag.io/blog/2020-10-22-nickel-open-sourcing/">Nickel: Better Configuration for Less</a><span>(www.tweag.io)</span></div><span class="my_story_list_date">2020-10-22 23:2</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1030569.html"><img src="http://img2.diglog.com/img/2020/10/thumb_022ae1f163e3837faf7572f4d1b4761b.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我们正在将镍库公之于众。镍是Tweag开发的一种实验配置语言。虽然现在还不是第一次租赁的时候，但这是一个谈论这个项目的机会。这篇文章的目标是对该项目进行一个高层次的概述。如果你的好奇心很强，但你还想学更多，那就不要害怕，因为我们将来会发布更多关于英语具体方面的博客文章。但是现在，让我们来游览一下吧！
[免责声明：Ni......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/成本/">#成本</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nickel/">#nickel</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1030284.html">为什么朱莉娅工作得这么好？</a></div><div class="item_title_en"><a target="_blank" href="https://ucidatascienceinitiative.github.io/IntroToJulia/Html/WhyJulia">Why Does Julia Work So Well?</a><span>(ucidatascienceinitiative.github.io)</span></div><span class="my_story_list_date">2020-10-21 19:9</span><div class="my_story_list_item_desc">它比其他脚本语言更快，使您可以快速开发Python/MATLAB/R，同时生成与C/Fortran一样快的代码。
为什么不干脆让其他脚本语言变得更快呢？如果朱莉娅能做到，为什么其他人做不到呢？
你如何干预朱莉娅基准来证实这一点？(这对许多人来说是出乎意料的困难！)。
许多人认为Julia速度很快，因为它是实时(JIT......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/julia/">#julia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1030271.html">高级GraphQL功能</a></div><div class="item_title_en"><a target="_blank" href="https://www.getcortexapp.com/post/more-sophisticated-schemas-with-advanced-graphql-features">Advanced GraphQL Features</a><span>(www.getcortexapp.com)</span></div><span class="my_story_list_date">2020-10-21 16:44</span><div class="my_story_list_item_desc">在过去的几年里，GraphQL已经成为一个被广泛采用的标准。然而，并不是每个人都在利用该标准的全部功能。在本文中，我将演示创建更具表现力的模式以更好地满足您的数据需求的方法。
让我们从定义一个示例场景开始。我们正在构建一个论坛应用程序，它将拥有几种类型的用户：
管理论坛操作的管理员。例如，处理技术问题、指定版主等。
......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/graphql/">#graphql</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1028427.html">铁锈中1和1=2的证明</a></div><div class="item_title_en"><a target="_blank" href="https://gist.github.com/gretingz/bc194c20a2de2c7bcc0f457282ba2662">Proving that 1 and 1 = 2 in Rust</a><span>(gist.github.com)</span></div><span class="my_story_list_date">2020-10-13 20:7</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1028427.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">1+1等于2这一事实非常明显，可能很难解释为什么。幸运的是，数学家们已经设计出了一种将算术形式化并随后证明1+1=2的方法。自然数是基于皮亚诺公理的。它们是一组简单的规则，定义(与正式系统一起)什么是自然数。因此，为了证明Rust中的1+1=2，我们首先需要一个能够处理逻辑的形式系统。我们将使用的正式系统不是某个随机......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/铁锈/">#铁锈</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/proving/">#proving</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1028278.html">C++中按返回类型重载</a></div><div class="item_title_en"><a target="_blank" href="https://artificial-mind.net/blog/2020/10/10/return-type-overloading">Overloading by Return Type in C++</a><span>(artificial-mind.net)</span></div><span class="my_story_list_date">2020-10-12 21:43</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1028278.html"><img src="http://img2.diglog.com/img/2020/10/thumb_112e8ad687703295c4a6e412456388da.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">//这是OK std：：string to_string(Int I)；std：：string to_string(Bool B)；std：：string si=to_string(0)；std：：string sb=to_string(True)；//这不是OK int from_string(std：：strin......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/return/">#return</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/string/">#string</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1027545.html">WTF MySQL时刻到了</a></div><div class="item_title_en"><a target="_blank" href="https://gbl08ma.com/time-for-a-wtf-mysql-moment/">Time for a WTF MySQL Moment</a><span>(gbl08ma.com)</span></div><span class="my_story_list_date">2020-10-7 13:35</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1027545.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b31e993dcc127739137ad2704ded5b56.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">那么让我们回到MySQL。这样一个有趣的范围背后的原因是什么？MySQL内部手册说，Time类型的存储在版本5.6.4中有所更改，在此版本中获得了对小数秒的支持。对于非小数类型，它使用3个字节。现在，如果他们仅仅使用这3个字节来编码若干秒，他们将能够支持跨越2330小时的间隔，这与当前最多838小时相比已经是相当大的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/mysql/">#mysql</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/wtf/">#wtf</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1027383.html">重温“较小的铁锈”</a></div><div class="item_title_en"><a target="_blank" href="https://without.boats/blog/revisiting-a-smaller-rust/">Revisiting a 'Smaller Rust'</a><span>(without.boats)</span></div><span class="my_story_list_date">2020-10-1 4:8</span><div class="my_story_list_item_desc">一年多前，我写了一些关于“更小的锈”的笔记，这是一种更高级的语言，它将从Rust的一些类型系统创新中获得灵感，但由于针对的领域对用户控制和性能的要求不那么严格，所以会更简单。在今年失业期间，我致力于更详细地勾勒出这样的语言会是什么样子。我想写一点关于在这段时间里我得出了什么新的结论。
重读我的上一篇文章，我惊讶地发现......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/重温/">#重温</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/smaller/">#smaller</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1026938.html">用实例说明类型系统</a></div><div class="item_title_en"><a target="_blank" href="https://thevaluable.dev/type-system-explained/">Type Systems Explained with Examples</a><span>(thevaluable.dev)</span></div><span class="my_story_list_date">2020-9-29 10:37</span><div class="my_story_list_item_desc">“我的语言更好，因为它有很强的类型系统！”你的同事开发人员戴夫(Dave)尖叫着，试图将编程语言Cobol推向你们公司的下一项微服务。
在开发人员中，关于编程语言及其类型系统的讨论可能很快就会变得情绪化。在这些讨论中，我们经常抛出“类型系统”、“数据类型”、“类型推断”、“静态类型”、“弱类型”、“强制”等词。但是，......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/说明/">#说明</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/systems/">#systems</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1026822.html">纯在TypeScript类型批注中实现的SQL数据库</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/codemix/ts-sql">A SQL database implemented purely in TypeScript type annotations</a><span>(github.com)</span></div><span class="my_story_list_date">2020-9-28 19:59</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1026822.html"><img src="http://img2.diglog.com/img/2020/9/thumb_787c67c4523697987b63e54050d62b9e.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">▄▐░▌▀▀▀▀█░█▀▀▀▀▐░。█▀▐░█▀▐░█▀█░▌▐░█▄▐░█▄▐░▌。▐░▌▀█░▌▀█░▌▐░█▄█░▌▐░▌。▐░▌▄█░▌▄█░▌▀█░█▀▀▐░█▄▐░▌▐░。▌▀▀。
这是一个纯粹在TypeScript类型注释中实现的SQL数据库。这意味着它只在类型上操作-您定义了一个数据库(仅仅是一个类型......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/database/">#database</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sql/">#sql</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1026702.html">记录Fastboot OEM命令</a></div><div class="item_title_en"><a target="_blank" href="https://carlo.marag.no/posts/undocumented-fastboot-oem/">Documenting Fastboot OEM Commands</a><span>(carlo.marag.no)</span></div><span class="my_story_list_date">2020-9-27 17:34</span><div class="my_story_list_item_desc">打印机很酷，因为它们很酷，但我有朋友至少每周提醒我黑客攻击打印机是没有用的。每一次几乎都是同样的事情，找一个1990年的类型错误，写一个愚蠢的脚本，完成。几个月前，我开始了一个新的项目，在谷歌庞大的代码库中疯狂地骑行。虽然谷歌的大部分代码，特别是Android，都是开源的，但有些部分不是开源的。我将试着谈谈一个这样的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/fastboot/">#fastboot</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1026695.html">我弄错的地方：类型</a></div><div class="item_title_en"><a target="_blank" href="https://v5.chriskrycho.com/journal/things-i-was-wrong-about/1-types/">Things I Was Wrong About: Types</a><span>(v5.chriskrycho.com)</span></div><span class="my_story_list_date">2020-9-27 16:28</span><div class="my_story_list_item_desc">假定受众：关心实际学习的人(在本例中，尤其是软件开发人员)。而且，我的妻子非常喜欢听我说，我错了。“😂。
认知状态：这些都是我目前认为我错了的地方。但我已经改变主意一次了，所以…。
至少在我的经验中，人们讨论他们过去错误的事情是相当罕见的。甚至当我们发帖子的时候，我也在想这个新东西！“。我们很少确切地说出我们改变主意......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/地方/">#地方</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/wrong/">#wrong</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1026469.html">发布Ruby 3.0.0预览版1</a></div><div class="item_title_en"><a target="_blank" href="https://www.ruby-lang.org/en/news/2020/09/25/ruby-3-0-0-preview1-released/?hn=t">Ruby 3.0.0 Preview 1 Released</a><span>(www.ruby-lang.org)</span></div><span class="my_story_list_date">2020-9-26 3:47</span><div class="my_story_list_item_desc">RBS是一种描述Ruby程序类型的语言，类型检查器(包括类型分析器和其他支持RBS的工具)将通过RBS定义更好地理解Ruby程序。
您可以写下类和模块的定义：类中定义的方法、实例变量及其类型以及继承/混合关系。RBS的目标是支持Ruby程序中常见的模式，并允许编写高级类型，包括联合类型、方法重载和泛型。它还支持具有接......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/preview/">#preview</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1025663.html">排名靠前的.NET 5.0新API</a></div><div class="item_title_en"><a target="_blank" href="https://blog.ndepend.com/top-10-net-5-0-new-apis/">Top .NET 5.0 new APIs</a><span>(blog.ndepend.com)</span></div><span class="my_story_list_date">2020-9-23 2:51</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1025663.html"><img src="http://img2.diglog.com/img/2020/9/thumb_1eff0ce8bb6a7c7c0fafdda8a1ddbf72.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">当一个新的主要.NET版本发布候选版本时，就可以使用NDepend代码审查更改功能来浏览添加了哪些新API。
这是相当直截了当的。启动VisualNDepend.exe；单击“比较代码库的两个版本”；然后选择这两个文件夹中的所有程序集：
单击OK，一分钟后，在分析了两个BCL版本之后，您就可以查看更改和新内容了。我们......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/排名/">#排名</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/top/">#top</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1025622.html">以F#表示的底部类型</a></div><div class="item_title_en"><a target="_blank" href="https://tysonwilliams.coding.blog/2020-09-21_bottom_type_in_fsharp">Bottom Type in F#</a><span>(tysonwilliams.coding.blog)</span></div><span class="my_story_list_date">2020-9-23 0:26</span><div class="my_story_list_item_desc">底部类型是没有值的类型。当每次执行不终止或引发异常时，它作为函数的返回类型很有用。某些语言包括底部类型。F#增加底部类型的建议被拒绝。有趣的是，C#添加底层类型的建议仍然有效。
不过，可以在F#中定义底层类型。这是我会怎么做的。
我最初的想法是省略Bottom，然后在其模块中单独使用此行(这样公共函数就不提供对这个私......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/表示/">#表示</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bottom/">#bottom</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1025580.html">纯Python中的Haskell语言特性和标准库</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/billpmurphy/hask">Haskell language features and standard libraries in pure Python</a><span>(github.com)</span></div><span class="my_story_list_date">2020-9-22 22:38</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1025580.html"><img src="http://img2.diglog.com/img/2020/9/thumb_06fbcba336cdbb52814524f2b061aa00.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Hask是一个纯Python、零依赖的库，它模仿了来自Haskell的大多数核心语言工具，包括：
完整的Hindley-Milner类型系统(带有类型类)，它将对任何装饰有Hask类型签名的函数进行类型检查。
所有您喜欢的语法和控制流工具，包括运算符节、一元错误处理、保护等。
来自Haskell基库的(一些)标准库的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/language/">#language</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1025215.html">CAT：一种静态类型的连接语言</a></div><div class="item_title_en"><a target="_blank" href="https://web.archive.org/web/20150205081218/http://cat-language.com/manual.html">Cat: A statically typed concatenative language</a><span>(web.archive.org)</span></div><span class="my_story_list_date">2020-9-21 2:51</span><div class="my_story_list_item_desc">CAT有三个不同级别的规范：0级、1级和2级。这是为了让工具能够识别它们符合规范的程度。规范的每个级别都指定了许多原语函数。这些函数可以是内置的，也可以在隐式链接的标准库中定义。
核心Cat语言称为0级Cat。核心Cat语言是一种纯函数式语言。

猫的名字(也就是。标识符)类似于Scheme语言。它们由字母、数字和符......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1024795.html">Python 3.8中的类型注记</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/analytics-vidhya/type-annotations-in-python-3-8-3b401384403d">Type Annotations in Python 3.8</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-9-18 16:12</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1024795.html"><img src="http://img2.diglog.com/img/2020/9/thumb_2671e44894df6b9621d0f6ed353eaf42.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Python如此容易入门的原因之一是它具有动态类型。您不必指定变量的类型，只需将变量用作数据容器的标签。但在较大的项目中，拥有类型是有帮助的。如果您有一个没有记录的没有类型的函数，可能还有糟糕的变量命名，新的开发人员将会遇到困难。幸运的是，在带有PEP526🎉的Python3.6中添加了变量注释。
这篇文章的写作方式......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1024367.html">相依型理论的一般定义</a></div><div class="item_title_en"><a target="_blank" href="http://math.andrej.com/2020/09/14/a-general-definition-of-dependent-type-theories/">A general definition of dependent type theories</a><span>(math.andrej.com)</span></div><span class="my_story_list_date">2020-9-17 3:43</span><div class="my_story_list_item_desc">这篇论文的预印本“依赖类型理论的一般定义”终于出现在arxiv上了！三年多前，彼得·拉姆斯丹邀请我研究这一主题，我欣然接受，并把我的学生菲利普·哈塞尔沃特拉了进去。我们开始回答这个问题：
至少对我来说，研究这样一个吃力不讨好的话题的动机来自弗拉基米尔·沃沃茨基(VladimirVoevodsky)，他会向类型理论的观......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/理论/">#理论</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1023522.html">Luau：使用类型增强Lua的语法</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/roblox-tech-blog/how-to-plan-a-luau-augmenting-luas-syntax-with-types-7751a790f0d8">Luau: Augmenting Lua’s Syntax with Types</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-9-12 13:44</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1023522.html"><img src="http://img2.diglog.com/img/2020/9/thumb_5edf5e7dcddd9bceb0b9b13069eeb06d.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在很长一段时间里，Lua5.1一直是Roblox的首选语言。随着我们的发展，对更好的工具支持和更高性能的VM的需求也在增长。为了回答这个问题，我们开始重新构建名为“luau”(发音为/lu-WOW/)的Lua堆栈，目标是包含程序员期望现代语言提供的功能-其中包括类型检查器、新的Linter框架和更快的解释器，仅举几例......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1023405.html">Mypy-Python的可选静态类型</a></div><div class="item_title_en"><a target="_blank" href="http://mypy-lang.org/">Mypy – Optional Static Typing for Python</a><span>(mypy-lang.org)</span></div><span class="my_story_list_date">2020-9-12 2:55</span><div class="my_story_list_item_desc">2019年11月29日：Mypy 0.750发布。此版本对自类型、改进的存根生成器、注释的实验性静态推断以及其他改进和错误修复有更好的支持。请阅读博客帖子以了解更多详细信息。-Ivan Levkivskyi旧新闻def fib(N)：a，b=0，1而a&lt；n：产生a a，b=b，a+b。
Def fib(n：in......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/optional/">#optional</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1022757.html">收集打字稿类型挑战</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/type-challenges/type-challenges">Collection of TypeScript Type Challenges</a><span>(github.com)</span></div><span class="my_story_list_date">2020-9-8 23:29</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1022757.html"><img src="http://img2.diglog.com/img/2020/9/thumb_a82cfebf3ae24d632c7cd4b4bef986e2.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">有一大堆很棒的类型实用程序库可能会提升您在类型方面的工作，比如ts-toolband、实用程序类型、SimplyTyped等等，您已经可以使用它们了。
这个项目的目的是帮助您更好地理解类型系统是如何工作的，或者编写您自己的实用程序，或者只是从挑战中获得乐趣。我们还试图建立一个社区，让你可以提出问题并获得你在现实世界中......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/收集/">#收集</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="/tag/类型/">0</a></li><li class="page-item"><a class="page-link" href="/tag/类型/page1.html">1</a></li><li class="page-item active"><a class="page-link" href="/tag/类型/page2.html">2</a></li><li class="page-item"><a class="page-link" href="/tag/类型/page3.html">3</a></li><li class="page-item"><a class="page-link" href="/tag/类型/page4.html">4</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>