<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我的实习经历：使用精简词典进行Brotli压缩</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我的实习经历：使用精简词典进行Brotli压缩</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-12 02:29:58</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/0611c9e8464ca6fcab2888d15829f679.png"><img src="http://img2.diglog.com/img/2020/11/0611c9e8464ca6fcab2888d15829f679.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Brotli is a state of the art lossless compression format, supported by all major browsers. It is capable of achieving considerably better compression ratios than the ubiquitous gzip, and is rapidly gaining in popularity. Cloudflare uses the Google brotli library to dynamically compress web content whenever possible. In 2015, we took  an in-depth look at how brotli works and its compression advantages.</p><p>Brotli是一种最先进的无损压缩格式，所有主流浏览器都支持它。它能够实现比无处不在的gzip好得多的压缩比，并且正在迅速流行起来。CloudFlare尽可能使用Google brotli库来动态压缩Web内容。2015年，我们深入研究了brotli的工作原理及其压缩优势。</p><p> One of the more interesting features of the  brotli file format, in the context of textual web content compression, is the inclusion of a built-in static dictionary. The dictionary is quite large, and in addition to containing various strings in multiple languages, it also supports the option to apply multiple transformations to those words, increasing its versatility.</p><p>在文本Web内容压缩的上下文中，brotli文件格式的一个更有趣的特性是包含了一个内置的静态词典。该词典相当大，除了包含多种语言的各种字符串外，它还支持对这些单词应用多个转换的选项，从而增加了它的通用性。</p><p> The  open sourced brotli library, that implements an encoder and decoder for brotli, has 11 predefined quality levels for the encoder, with higher quality level demanding more CPU in exchange for a better compression ratio. The static dictionary feature is used to a limited extent starting with level 5, and to the full extent only at levels 10 and 11, due to the high CPU cost of this feature.</p><p>开源的brotli库实现了brotli的编码器和解码器，它为编码器预定义了11个质量级别，更高的质量级别需要更多的CPU来换取更好的压缩比。由于静态字典功能的CPU成本较高，因此从级别5开始有限地使用，并且仅在级别10和11全面使用。</p><p> We improve on the limited dictionary use approach and add optimizations to improve the compression at levels 5 through 9 at a negligible performance impact when compressing web content.</p><p>我们对有限字典使用方法进行了改进，并添加了优化以在压缩Web内容时以可忽略的性能影响改善5到9级的压缩。</p><p>  Brotli primarily uses the LZ77 algorithm to compress its data. Our  previous blog post about brotli provides an introduction.</p><p>Brotli主要使用LZ77算法来压缩其数据。我们之前关于Brotli的博客文章提供了一个介绍。</p><p> To improve compression on text files and web content, brotli also includes a static, predefined dictionary. If a byte sequence cannot be matched with an earlier sequence using LZ77 the encoder will try to match the sequence with a reference to the static dictionary, possibly using one of the multiple transforms. For example, every HTML file contains the opening &lt;html&gt; tag that cannot be compressed with LZ77, as it is unique, but it is contained in the brotli static dictionary and will be replaced by a reference to it. The reference generally takes less space than the sequence itself, which decreases the compressed file size.</p><p>为了改进对文本文件和网页内容的压缩，brotli还包括一个静态的预定义词典。如果字节序列不能与使用LZ77的较早序列匹配，则编码器将尝试通过引用静态字典来匹配该序列，可能使用多个转换中的一个。例如，每个HTML文件都包含不能用LZ77压缩的开始&lt；html&gt；标记，因为它是唯一的，但它包含在brotli静态字典中，并将被替换为对它的引用。引用通常比序列本身占用更少的空间，从而减小压缩文件的大小。</p><p> The dictionary contains 13,504 words in six languages, with lengths from 4 to 24 characters. To improve the compression of real-world text and web data, some dictionary words are common phrases (&#34;The current&#34;) or strings common in web content (‘type=”text/javascript”’). Unlike usual LZ77 compression, a word from the dictionary can only be matched as a whole. Starting a match in the middle of a dictionary word, ending it before the end of a word or even extending into the next word is not supported by the brotli format.</p><p>这部词典收录了6种语言的13504个单词，长度从4到24个字符不等。为了改进对真实文本和Web数据的压缩，一些词典单词是Web内容中常见的短语(当前)或字符串(‘type=“text/javascript”’)。与通常的LZ77压缩不同，字典中的单词只能作为一个整体进行匹配。Brotli格式不支持在词典单词中间开始匹配，在单词结尾之前结束匹配，甚至扩展到下一个单词。</p><p> Instead, the dictionary supports 120 transforms of dictionary words to support a larger number of matches and find longer matches. The transforms include adding suffixes (“work” becomes “working”) adding prefixes (“book” =&gt; “ the book”) making the first character uppercase (&#34;process&#34; =&gt; &#34;Process&#34;) or converting the whole word to uppercase (“html” =&gt; “HTML”). In addition to transforms that make words longer or capitalize them, the cut transform allows a shortened match (“consistently” =&gt; “consistent”), which makes it possible to find even more matches.</p><p>取而代之的是，该词典支持120个词典单词的转换，以支持更大数量的匹配并查找更长的匹配。转换包括添加后缀(“work”变为“work”)，添加前缀(“book”=&&gt;；“the book”)，使第一个字符大写(&#34；process&#34；=&gt；&34；process&#34；)或将整个单词转换为大写(“html”=&&gt;；“HTML”)。除了使单词变长或大写的转换之外，Cut转换还允许缩短匹配(“Consistent”=&gt；“consistent”)，这使得查找更多匹配成为可能。</p><p>  With the transforms included, the static dictionary contains 1,633,984 different words – too many for exhaustive search, except when used with the slow brotli compression levels 10 and 11. When used at a lower compression level, brotli either disables the dictionary or only searches through a subset of roughly 5,500 words to find matches in an acceptable time frame. It also only considers matches at positions where no LZ77 match can be found and only uses the cut transform.</p><p>在包含转换的情况下，静态词典包含1633,984个不同的单词--对于穷举搜索来说太多了，除非使用较慢的brotli压缩级别10和11。当使用较低的压缩级别时，brotli要么禁用词典，要么只搜索大约5500个单词的子集，以便在可接受的时间范围内找到匹配项。它还只考虑无法找到LZ77匹配项的位置的匹配项，并且只使用CUT变换。</p><p> Our approach to the brotli dictionary uses a larger, but more specialized subset of the dictionary than the default, using more aggressive heuristics to improve the compression ratio with negligible cost to performance. In order to provide a more specialized dictionary, we provide the compressor with a content type hint from our servers, relying on the Content-Type header to tell the compressor if it should use a dictionary for HTML, JavaScript or CSS. The dictionaries can be furthermore refined by colocation language in the future.</p><p>我们对brotli字典的方法使用了比默认字典更大但更专业的字典子集，使用更积极的启发式算法来提高压缩比，而性能损失可以忽略不计。为了提供更专业的词典，我们从服务器向压缩器提供了内容类型提示，依靠Content-Type标头告诉压缩器它是否应该使用用于HTML、JavaScript或CSS的词典。未来，词典还可以通过主机代管语言进一步完善。</p><p>  To improve compression without sacrificing performance, we needed a fast way to find matches if we want to search the dictionary more thoroughly than brotli does by default. Our approach uses three data structures to find a matching word directly. The radix trie is responsible for finding the word while the hash table and bloom filter are used to speed up the radix trie and quickly eliminate many words that can’t be matched using the dictionary.</p><p>为了在不牺牲性能的情况下提高压缩性能，如果我们想要比brotli默认情况下更彻底地搜索字典，我们需要一种快速查找匹配的方法。我们的方法使用三种数据结构来直接查找匹配词。基数trie负责查找单词，而哈希表和Bloom filter用于加快基数trie的速度，并快速消除许多使用字典无法匹配的单词。</p><p>  The  radix trie easily finds the longest matching word without having to try matching several words. To find the match, we traverse the graph based on the text at the current position and remember the last node with a matching word. The radix trie supports compressed nodes (having more than one character as an edge label), which greatly reduces the number of nodes that need to be traversed for typical dictionary words.</p><p>基数trie很容易找到最长的匹配词，而不必尝试匹配几个词。为了找到匹配项，我们根据当前位置的文本遍历图表，并记住具有匹配词的最后一个节点。基数trie支持压缩节点(具有多个字符作为边缘标签)，这极大地减少了典型词典单词需要遍历的节点数量。</p><p> The radix trie is slowed down by the large number of positions where we can’t find a match. An important finding is that most mismatching strings have a mismatching character in the first four bytes. Even for positions where a match exists, a lot of time is spent traversing nodes for the first four bytes since the nodes close to the tree root usually have many children.</p><p>我们找不到匹配的大量位置减慢了基数Trie的速度。一个重要的发现是，大多数不匹配的字符串在前四个字节中都有一个不匹配的字符。即使对于存在匹配的位置，也会花费大量时间遍历前四个字节的节点，因为靠近树根的节点通常有很多子节点。</p><p> Luckily, we can use a  hash table to look up the node equivalent to four bytes, matching if it exists or reject the possibility of a match. We thus look up the first four bytes of the string, if there is a matching node we traverse the trie from there, which will be fast as each four-byte prefix usually only has a few corresponding dict words. If there is no matching node, there will not be a matching word at this position and we do not need to further consider it.</p><p>幸运的是，我们可以使用哈希表查找相当于四个字节的节点，如果存在则进行匹配，或者拒绝匹配的可能性。因此，我们查找字符串的前四个字节，如果有匹配节点，我们将从那里遍历trie，这样会更快，因为每个四字节的前缀通常只有几个相应的字典字。如果没有匹配节点，这个位置就不会有匹配词，我们就不需要进一步考虑了。</p><p> While the hash table is designed to reject mismatches quickly and avoid cache misses and high search costs in the trie, it still suffers from similar problems: We might search through several 4-byte prefixes with the hash value of the given position, only to learn that no match can be found. Additionally, hash lookups can be expensive due to cache misses.</p><p>虽然哈希表的设计目的是快速拒绝不匹配，并避免缓存未命中和Trie中的高搜索成本，但它仍然面临类似的问题：我们可能会使用给定位置的哈希值搜索几个4字节的前缀，结果发现没有找到匹配。此外，由于缓存未命中，散列查找的成本可能很高。</p><p> To quickly reject words that do not match the dictionary, but might still cause cache misses, we use a  k=1 bloom filter to quickly rule out most non-matching positions. In the k=1 case, the filter is simply a lookup table with one bit indicating whether any matching 4-byte prefixes exist for a given hash value. If the hash value for the given bit is 0, there won’t be a match. Since the bloom filter uses at most one bit for each four-byte prefix while the hash table requires 16 bytes, cache misses are much less likely. (The actual size of the structures is a bit different since there are many empty spaces in both structures and the bloom filter has twice as many elements to reject more non-matching positions.)</p><p>为了快速拒绝与词典不匹配但仍可能导致缓存未命中的单词，我们使用k=1的Bloom过滤器来快速排除大多数不匹配的位置。在k=1的情况下，过滤器只是一个查找表，其中有一位指示对于给定的散列值是否存在任何匹配的4字节前缀。如果给定位的散列值为0，则不会有匹配。由于布隆过滤器对每个四字节前缀最多使用一位，而哈希表需要16字节，因此缓存未命中的可能性要小得多。(结构的实际大小略有不同，因为两个结构中都有许多空白空间，而Bloom过滤器有两倍的元素来拒绝更多不匹配的位置。)</p><p> This is very useful for performance as a bloom filter lookup requires a single memory access. The bloom filter is designed to be fast and simple, but still rejects more than half of all non-matching positions and thus allows us to save a full hash lookup, which would often mean a cache miss.</p><p>这对性能非常有用，因为Bloom Filter查找只需要一次内存访问。Bloom过滤器的设计既快速又简单，但仍会拒绝一半以上的非匹配位置，从而使我们可以省去完整的散列查找，这通常意味着缓存未命中。</p><p>   Only search the dictionary at some positions This is also done using the stock dictionary, but we search more aggressively. While the stock dictionary only considers positions where the LZ77 match finder did not find a match, we also consider positions that have a bad match according to the brotli cost model: LZ77 matches that are short or have a long distance between the current position and the reference usually only offer a small compression improvement, so it is worth trying to find a better match in the static dictionary.</p><p>只在某些位置搜索词典这也是使用股票词典来完成的，但我们的搜索力度更大。虽然股票字典只考虑LZ77匹配查找器找不到匹配的位置，但我们也根据Brotli成本模型考虑匹配较差的位置：LZ77匹配较短或当前位置和参考位置之间的距离较长的位置通常只提供很小的压缩改进，因此值得尝试在静态字典中找到更好的匹配。</p><p> Only consider the longest match and then transform it Instead of finding and transforming all matches at a position, the radix trie only gives us the longest match which we then transform. This approach results in a vast performance improvement. In most cases, this results in finding the best match.</p><p>只考虑最长的匹配，然后对其进行转换，而不是查找和转换某个位置的所有匹配，基数trie只给出最长的匹配，然后进行转换。这种方法会带来巨大的性能提升。在大多数情况下，这会导致找到最佳匹配。</p><p> Only include some transforms While all transformations can improve the compression ratio, we only included those that work well with the data structures. The suffix transforms can easily be applied after finding a non-transformed match. For the upper case transforms, we include both the non-transformed and the upper case version of a word in the radix trie. The prefix and cut transforms do not play well with the radix trie, therefore a cut of more than 1 byte and prefix transforms are not supported.</p><p>只包含一些转换，虽然所有转换都可以提高压缩比，但我们只包含那些能够很好地处理数据结构的转换。在找到未转换的匹配项后，可以轻松地应用后缀转换。对于大写转换，我们在基数trie中包括单词的未转换版本和大写版本。前缀和剪切转换不能很好地处理基数Trie，因此不支持超过1个字节的剪切和前缀转换。</p><p>  At low compression levels, brotli searches a subset of ~5,500 out of 13,504 words of the dictionary, negatively impacting compression. To store the entire dictionary, we would need to store ~31,700 words in the trie considering the upper case transformed output of ASCII sequences and ~11,000 four-byte prefixes in the hash. This would slow down hash table and radix trie, so we needed to find a different subset of the dictionary that works well for web content.</p><p>在低压缩级别时，Brotli从词典的13,504个单词中搜索~5,500个单词的子集，这对压缩有负面影响。要存储整个词典，我们需要在Trie中存储大约31,700个单词，考虑到ASCII序列的大写转换输出和散列中的大约11,000个4字节前缀。这会降低哈希表和基数trie的速度，因此我们需要找到适合Web内容的字典的另一个子集。</p><p> For this purpose, we used a large data set containing representative content. We made sure to use web content from several world regions to reflect language diversity and optimize compression. Based on this data set, we identified which words are most common and result in the largest compression improvement according to the brotli cost model. We only include the most useful words based on this calculation. Additionally, we remove some words if they slow down hash table lookups of other, more common words based on their hash value.</p><p>为此，我们使用了包含代表性内容的大型数据集。我们确保使用来自世界多个地区的网络内容，以反映语言多样性并优化压缩。基于这个数据集，根据Brotli成本模型，我们确定了哪些单词是最常用的，并导致了最大的压缩改进。我们只收录基于这个计算的最有用的单词。此外，如果某些单词根据其散列值降低了对其他更常用单词的散列表查找速度，则会删除这些单词。</p><p> We have generated separate dictionaries for HTML, CSS and JavaScript content and use the MIME type to identify the right dictionary to use. The dictionaries we currently use include about 15-35% of the entire dictionary including uppercase transforms. Depending on the type of data and the desired compression/speed tradeoff, different options for the size of the dictionary can be useful. We have also developed code that automatically gathers statistics about matches and generates a reduced dictionary based on this, which makes it easy to extend this to other textual formats, perhaps data that is majority non-English or XML data and achieve better results for this type of data.</p><p>我们已经为HTML、CSS和JavaScript内容生成了单独的字典，并使用MIME类型来标识要使用的正确字典。我们目前使用的词典包括整个词典的15%-35%，包括大写转换。根据数据类型和所需的压缩/速度权衡，字典大小的不同选项可能会很有用。我们还开发了自动收集有关匹配的统计信息并基于此生成简化词典的代码，这使得将其扩展到其他文本格式(可能是大多数非英语或XML数据的数据)变得容易，并为这类数据获得更好的结果。</p><p>  We tested the reduced dictionary on a large data set of HTML, CSS and JavaScript files.</p><p>我们在一个由HTML、CSS和JavaScript文件组成的大型数据集上测试了缩减后的词典。</p><p> The improvement is especially big for small files as the LZ77 compression is less effective on them. Since the improvement on large files is a lot smaller, we only tested files up to 256KB. We used compression level 5, the same compression level we currently use for dynamic compression on our edge, and tested on a Intel Core i7-7820HQ CPU.</p><p>这一改进对于小文件来说尤其显著，因为LZ77压缩对它们的效果较差。由于对大文件的改进要小得多，所以我们只测试了256KB以下的文件。我们使用压缩级别5，与我们目前在边缘上用于动态压缩的压缩级别相同，并在英特尔酷睿i7-7820HQ CPU上进行了测试。</p><p> Compression improvement is defined as 1 - (compressed size using the reduced dictionary / compressed size without dictionary). This ratio is then averaged for each input size range. We also provide an average value weighted by file size. Our data set mirrors typical web traffic, covering a wide range of file sizes with small files being more common, which explains the large difference between the weighted and unweighted average.</p><p>压缩改进被定义为1-(使用缩小字典的压缩大小/没有字典的压缩大小)。然后，对每个输入大小范围求该比率的平均值。我们还提供了按文件大小加权的平均值。我们的数据集反映了典型的网络流量，涵盖了大范围的文件大小，小文件更为常见，这解释了加权平均值和未加权平均值之间的巨大差异。</p><p>  With the improved dictionary approach, we are now able to compress HTML, JavaScript and CSS files as well, or sometimes even better than using a higher compression level would allow us, all while using only 1% to 3% more CPU. For reference using compression level 6 over 5 would increase CPU usage by up to 12%.</p><p>有了改进的字典方法，我们现在也能够压缩HTML、JavaScript和CSS文件，有时甚至比使用更高的压缩级别更好，同时只多使用1%到3%的CPU。作为参考，使用压缩级别6超过5会使CPU使用率最多增加12%。</p><p>  Compression  Optimization  Speed &amp; Reliability  Careers</p><p>压缩优化、速度和可靠性的职业生涯</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.cloudflare.com/brotli-compression-using-a-reduced-dictionary/">https://blog.cloudflare.com/brotli-compression-using-a-reduced-dictionary/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/经历/">#经历</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/brotli/">#brotli</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/匹配/">#匹配</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>