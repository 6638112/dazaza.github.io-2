<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>.NET 5.0</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">.NET 5.0</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-11 00:47:28</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/4d8f7fb3aa7a46aaaf49c2063aca8438.png"><img src="http://img2.diglog.com/img/2020/11/4d8f7fb3aa7a46aaaf49c2063aca8438.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>We’re excited to release .NET 5.0 today and for you to start using it. It’s a major release — including C# 9 and F# 5 — with a broad set of new features and compelling improvements. It’s already in active use by teams at Microsoft and other companies, in production and for performance testing. Those teams are showing us great results that demonstrate performance gains and/or opportunities to reduce hosting costs for their web applications. We’ve been running  our own website on 5.0 starting with Preview 1. From what we’ve seen and heard so far, .NET 5.0 delivers significant value without much effort to upgrade. It’s a great choice for your next app, and a straightforward upgrade from earlier .NET Core versions. We hope you enjoy using it, on your desktop, laptop, and cloud instances.</p><p>我们很高兴今天发布.NET5.0，并期待您开始使用它。这是一个重要的版本--包括C#9和F#5--具有广泛的新特性和引人注目的改进。它已经被微软和其他公司的团队在生产和性能测试中积极使用。这些团队向我们展示了出色的结果，展示了性能提升和/或降低其Web应用托管成本的机会。从预览版1开始，我们一直在5.0上运行我们自己的网站。从我们目前的所见所闻来看，.NET5.0无需太多的升级就能带来巨大的价值。对于你的下一款应用来说，这是一个很好的选择，而且可以直接从早期的.NET Core版本升级。我们希望您喜欢在台式机、笔记本电脑和云实例上使用它。</p><p> ASP.NET Core,  EF Core, C#9, and  F# 5 are also being released today.  .NET Conf 2020 — our  free and virtual conference — is being held today so you can learn about all of the new releases.</p><p>ASP.NET Core、EF Core、C#9和F#5也将在今天发布。Net Conf 2020-我们的免费虚拟会议-今天举行，让您了解所有新版本。</p><p> You can  download .NET 5.0, for Windows, macOS, and Linux, for x86, x64, Arm32, Arm64.</p><p>您可以下载.NET5.0，适用于Windows、MacOS和Linux，适用于x86、x64、Arm32和Arm64。</p><p>  For Visual Studio users, you need  Visual Studio 16.8 or later to use .NET 5.0 on Windows and the latest version of  Visual Studio for Mac) on macOS. The  C# extension for  Visual Studio Code already supports .NET 5.0 and C# 9.</p><p>对于Visual Studio用户，您需要Visual Studio 16.8或更高版本才能在Windows上使用.NET 5.0，在MacOS上使用最新版本的Visual Studio for Mac)。Visual Studio代码的C#扩展已经支持.NET5.0和C#9。</p><p> .NET 5.0 is the first release in our .NET unification journey. We built .NET 5.0 to enable a much larger group of developers to migrate their .NET Framework code and apps to .NET 5.0. We’ve also done much of the early work in 5.0 so that Xamarin developers can use the unified .NET platform when we release .NET 6.0. There is more on .NET unification, later in the post.</p><p>NET 5.0是我们的.NET统一之旅的第一个版本。我们构建.NET5.0是为了让更多的开发人员能够将他们的.NET Framework代码和应用程序迁移到.NET5.0。我们在5.0中也做了很多早期工作，以便Xamarin开发人员在发布.NET6.0时可以使用统一的.NET平台。在后面的文章中会有更多关于.NET统一的内容。</p><p> Now is a good time to call out the incredible collaboration with everyone contributing to the .NET project. This release marks the fifth major .NET version as an open source project. There is now a large mix of individuals and small and large companies (including the  .NET Foundation corporate sponsors) working together as a large community on various aspects of .NET in the  dotnet org on GitHub. The improvements in .NET 5.0 are the result of many people, their effort, smart ideas, and their care and love for the platform, all above and beyond Microsoft’s stewardship of the project. From the core team working on .NET every day, we extend a  very large “thank you” to everyone that contributed to .NET 5.0 (and previous releases)!</p><p>现在是宣布与所有参与.NET项目的人进行令人难以置信的合作的好时机。这个版本标志着作为开源项目的第五个主要的.NET版本。现在，在GitHub上的DotNet org中，有大量的个人和大小公司(包括.NET Foundation企业赞助商)作为一个大型社区在.NET的各个方面共同工作。NET5.0中的改进是许多人、他们的努力、聪明的想法以及他们对该平台的关心和热爱的结果，所有这些都超出了微软对该项目的管理。从每天致力于.NET的核心团队，我们向所有为.NET5.0(以及之前的版本)做出贡献的人致以非常强烈的“感谢”！</p><p> We  introduced .NET 5.0 way back in May 2019, and even set the November 2020 release date at that time. From that post: “we will ship .NET Core 3.0 this September, .NET 5 in November 2020, and then we intend to ship a major version of .NET once a year, every November”. You’d think that “November 2020” was a cheque that could not be cashed given all the challenges this year, however, .NET 5.0 has been released on time. Thanks to everyone on the team that made that happen! I know it has not been easy. Looking forward, you should expect .NET 6.0 in November 2021. We intend to release new .NET versions every November.</p><p>我们早在2019年5月就引入了.NET5.0，当时甚至设定了2020年11月的发布日期。这篇帖子写道：“我们将在今年9月发布.NET Core 3.0，在2020年11月发布.NET5，然后我们打算每年11月发布一次.NET的主要版本。”你可能会认为“2020年11月”是一张支票，考虑到今年面临的所有挑战，这张支票是不能兑现的，然而，.NET5.0已经按时发布了。感谢团队中的每一个人，是他们让这一切成为现实！我知道这并不容易。展望未来，您应该可以期待在2021年11月发布.NET6.0。我们打算每年11月发布新的.NET版本。</p><p> The rest of the blog is dedicated to highlighting and detailing most of the improvements in .NET 5.0. There is also an update on our .NET unification vision.</p><p>博客的其余部分致力于突出和详细介绍.NET5.0中的大部分改进。还有一个关于我们的.NET统一愿景的更新。</p><p>   .NET 5.0 is already battle-tested by being hosted for months at  dot.net and  Bing.com ( version).</p><p>.NET5.0已经在dot.net和Bing.com(版本)上托管了几个月，已经经过了战斗测试。</p><p> Performance is greatly improved across many components and is described in detail at  Performance Improvements in .NET 5.0,  Arm64 Performance in .NET 5.0, and  gRPC.</p><p>许多组件的性能都得到了极大的提高，在.NET5.0中的性能改进、.NET5.0中的ARM64性能和GRPC中都有详细描述。</p><p> C# 9 and F# 5 offer new language improvements such as top-level programs and records for C# 9, while F# 5 offers interactive programming and a performance boost for functional programming on .NET.</p><p>C#9和F#5提供了新的语言改进，比如C#9的顶级程序和记录，而F#5提供了交互式编程和.NET上函数式编程的性能提升。</p><p> .NET libraries have enhanced performance for Json serialization,  regular expressions, and HTTP ( HTTP 1.1,  HTTP/2). They are also are now completely annotated for nullability.</p><p>NET库增强了Json序列化、正则表达式和HTTP(HTTP 1.1、HTTP/2)的性能。它们现在也被完全注释为可为空。</p><p> P95 latency has dropped due to refinements in the  GC,  tiered compilation, and  other areas.</p><p>由于GC、分层编译和其他方面的改进，P95延迟已经降低。</p><p> Application deployment options are better, with ClickOnce client app publishing,  single-file apps,  reduced container image size, and the addition of Server Core container images.</p><p>应用程序部署选项更好，ClickOnce客户端应用程序发布、单文件应用程序、减小的容器镜像大小以及添加的服务器核心容器镜像。</p><p> I’ve written many samples for the .NET 5.0 preview posts. You might want to take a look at  .NET 5.0 Examples to learn more about new C# 9 and libraries features.</p><p>我已经为.NET5.0预览帖编写了很多样例。您可能想看一下.NET5.0示例，以了解更多关于新的C#9和库特性的信息。</p><p>  .NET 5.0 has a nearly identical  platform support matrix as  .NET Core 3.1, for Windows, macOS, and Linux. If you are using .NET Core 3.1 on a supported operating system, you should be able to adopt .NET 5.0 on that same operating system version for the most part. The most significant addition for .NET 5.0 is Windows Arm64.</p><p>对于Windows、MacOS和Linux，.Net 5.0的平台支持列表与.NET Core 3.1几乎相同。如果您在受支持的操作系统上使用.NET Core 3.1，则应该能够在该操作系统的大部分版本上采用.NET5.0。在.NET5.0中，最重要的新增功能是Windows Arm64。</p><p> .NET 5.0 is a  current release. That means that it will be supported for three months after .NET 6.0 is released. As a result, we expect to support .NET 5.0 through the middle of February 2022. .NET 6.0 will be an LTS release and will be supported for three years, just like .NET Core 3.1.</p><p>.Net 5.0是当前版本。这意味着它将在.NET6.0发布后的三个月内得到支持。因此，我们预计到2022年2月中旬将支持.NET5.0。与.NET Core 3.1一样，.NET6.0将是一个LTS版本，并将支持三年。</p><p>  Last year, we shared a  vision of a unified .NET stack and ecosystem. The value to you is that you will be able to use a single set of APIs, languages, and tools to target a broad set of application types, including mobile, cloud, desktop, and IoT. You might realize that you can already target a broad set of platforms with .NET today, however, the tools and APIs are not always the same across Web and Mobile, for example, or released at the same time.</p><p>去年，我们分享了一个统一的.NET堆栈和生态系统的愿景。它对您的价值在于，您将能够使用一组API、语言和工具来瞄准广泛的应用类型，包括移动、云、桌面和物联网。您可能已经意识到，现在您已经可以使用.NET面向广泛的平台，然而，工具和API在Web和Mobile之间并不总是相同的，或者并不总是同时发布的。</p><p> As part of .NET 5.0 and 6.0, we are unifying .NET into a single product experience, while enabling you to pick just the parts of the .NET platform that you want to use. If you want to target Mobile and not WebAssembly, you don’t need to download the WebAssembly tools, and vice versa. Same with ASP.NET Core and WPF. You’ll also have a much easier way to acquire all the .NET tools and build and runtime packs that you need from the command line. We’re enabling a package manager experience (including using existing package managers) for .NET platform components. That will be great for many scenarios. Quick construction of a development environment and CI/CD will probably be the biggest beneficiaries.</p><p>作为.NET5.0和6.0的一部分，我们正在将.NET统一到单一的产品体验中，同时使您能够选择您想要使用的.NET平台的部分。如果你想以Mobile而不是WebAssembly为目标，你不需要下载WebAssembly工具，反之亦然。ASP.NET Core和WPF也是如此。您还可以通过更简单的方式从命令行获取所需的所有.NET工具以及构建和运行时包。我们正在为.NET平台组件提供包管理器体验(包括使用现有的包管理器)。这对于很多场景来说都是很棒的。快速建设发展环境和传播与信息/光盘可能是最大的受益者。</p><p> We had intended to deliver the entirety of the unification vision with .NET 5.0, but in the wake of the global pandemic, we had to adapt to the changing needs of our customers. We’ve been working with teams from companies from around the world that have needed help to speed up their adoption of cloud technologies. They, too, have had adapt to the changing needs of their customers. As a result, we are delivering the vision across two releases.</p><p>我们原本打算用.NET5.0提供完整的统一愿景，但在全球流行之后，我们不得不适应客户不断变化的需求。我们一直在与来自世界各地的公司的团队合作，这些公司需要帮助来加快他们采用云技术的速度。他们也必须适应客户不断变化的需求。因此，我们将在两个版本中交付这一愿景。</p><p> The first step towards this vision was  consolidating .NET repos, including a large subset of Mono. Having one repo for the runtime and libraries for .NET is a precondition to delivering the same product everywhere. It also helps with making broad changes that affect runtime and libraries, where there were previously repo boundaries. Some people were worried that a large repo would be harder to manage. That hasn’t proven to be the case.</p><p>实现这一愿景的第一步是整合.NET repos，包括Mono的一个大子集。拥有一个用于运行时和.NET库的repo是在任何地方交付相同产品的前提条件。它还有助于进行广泛的更改，这些更改会影响运行时和库，而这些库以前是有repo边界的。一些人担心，大规模回购将更难管理。事实证明并非如此。</p><p> In the .NET 5.0 release, Blazor is best example of taking advantage of repo consolidation and .NET unification. The runtime and libraries for  Blazor WebAssembly are now built from the consolidated  dotnet/runtime repo. That means Blazor WebAssembly and Blazor on the server use the exact same code for  List&lt;T&gt;, for example. That wasn’t the case for Blazor prior to .NET 5.0. The approach we took for Blazor WebAssembly is very similar to what we’ll do with Xamarin in .NET 6.0.</p><p>在.NET5.0版本中，Blazor是利用回购整合和.NET统一的最佳例子。Blazor WebAssembly的运行时和库现在是从合并的DotNet/运行时repo构建的。例如，这意味着Blazor WebAssembly和服务器上的Blazor对List&lt；T&gt；使用完全相同的代码。但在.NET5.0之前，Blazor并非如此。我们对Blazor WebAssembly采取的方法与我们在.NET6.0中使用Xamarin的方法非常相似。</p><p> The .NET Framework remains a supported Microsoft product and will continue to be supported with each new version of Windows. We announced last year that we had  stopped adding new features to .NET Framework and  finished adding .NET Framework APIs to .NET Core. That means that now is a great time to consider moving your .NET Framework apps to .NET Core. For .NET Framework client developers, Windows Forms and WPF are supported with .NET 5.0. We’ve heard from many developers that porting from .NET Framework is straightforward. For .NET Framework server developers, you need to adopt ASP.NET Core to use .NET 5.0. For Web Forms developers, we believe that  Blazor provides a similar developer experience with an efficient and much more modern implementation. WCF server and Workflow users can look to  community projects that are supporting those frameworks. The  porting from .NET Framework to .NET Core doc is a good place to start. That all said, keeping your app on .NET Framework is a fine approach if you are happy with your experience.</p><p>NET Framework仍然是受支持的Microsoft产品，并且每个新版本的Windows都将继续支持它。我们去年宣布已经停止向.NET Framework添加新功能，并完成了向.NET Core添加.NET Framework API。这意味着现在是考虑将您的.NET Framework应用程序迁移到.NET Core的大好时机。对于.NET Framework客户端开发人员，.NET5.0支持Windows窗体和WPF。我们从许多开发人员那里听说，从.NET Framework移植非常简单。对于.NET Framework服务器开发人员，您需要采用ASP.NET Core才能使用.NET5.0。对于Web Forms开发人员，我们相信Blazor通过更高效、更现代化的实现提供了类似的开发体验。WCF服务器和工作流用户可以查看支持这些框架的社区项目。从.NET Framework移植到.NET Core文档是一个很好的起点。这就是说，如果你对自己的体验满意，那么让你的应用程序运行在.NET Framework上是一个很好的方法。</p><p> The Windows team is working on  Project Reunion as the next step forward for UWP and related technologies. We’ve been collaborating with the Reunion team to ensure that .NET 5.0 and later versions will work well with WinUI and WebView2. The Project Reunion repo is the best place to stay up to date with progress.</p><p>Windows团队正致力于将留尼汪号项目作为UWP及其相关技术的下一步。我们一直在与留尼汪岛团队合作，以确保.NET5.0及更高版本能够很好地与WinUI和WebView2协同工作。团圆项目是了解最新进展的最佳场所。</p><p> Let’s switch to looking at what’s new in the 5.0 release.</p><p>让我们来看看5.0版本中的新特性。</p><p>  C# 9 and  F# 5 are part of the .NET 5.0 release and included in the .NET 5.0 SDK. Visual Basic is also included in the 5.0 SDK. It does not include language changes, but has improvements to support the Visual Basic Application Framework on .NET Core.</p><p>C#9和F#5是.NET5.0版本的一部分，包含在.NET5.0SDK中。Visual Basic也包含在5.0 SDK中。它不包括语言更改，但进行了改进以支持.NET Core上的Visual Basic应用程序框架。</p><p> C# Source Generators are an important new C# compiler feature. They are not technically part of C# 9 since it doesn’t have any language syntax. See  New C# Source Generator Samples to help you get started using this new feature. We expect to make more use of  source generators within the .NET product in .NET 6.0 and beyond.</p><p>C#源代码生成器是一项重要的C#编译器新特性。从技术上讲，它们不是C#9的一部分，因为它没有任何语言语法。请参阅新的C#源代码生成器示例，帮助您开始使用这一新功能。我们希望在.NET6.0及更高版本的.NET产品中更多地使用源代码生成器。</p><p> As a way to try out the new release ourselves, a few of us decided to update the  dotnet/iot repo to use new C# 9 syntax and target .NET 5.0. It uses top-level programs, records, patterns, and switch expressions. It has also been updated to take advantage of the complete set of nullable annotations in .NET libraries. We’ll take a look at few examples from that repo to explore C# 9.</p><p>作为自己试用新版本的一种方式，我们中的一些人决定更新DotNet/IoT Repo，以使用新的C#9语法并以.NET5.0为目标。它使用顶级程序、记录、模式和切换表达式。它还进行了更新，以利用.NET库中完整的可为空的批注集。我们将查看该repo中的几个示例来探索C#9。</p><p>   using System;using System.Device.Gpio;using System.Threading;var pin = 18;var lightTime = 1000;var dimTime = 200;Console.WriteLine($&#34;Let&#39;s blink an LED!&#34;);using GpioController controller = new ();controller.OpenPin(pin, PinMode.Output);Console.WriteLine($&#34;GPIO pin enabled for use: {pin}&#34;);// turn LED on and offwhile (true){ Console.WriteLine($&#34;Light for {lightTime}ms&#34;); controller.Write(pin, PinValue.High); Thread.Sleep(lightTime); Console.WriteLine($&#34;Dim for {dimTime}ms&#34;); controller.Write(pin, PinValue.Low); Thread.Sleep(dimTime);}</p><p>Using System；Using System.Device.Gpio；Using System.Thread；var pin=18；var lightTime=1000；var dimTime=200；Console.WriteLine($&#34；让&#39；s闪烁LED！&#34；)；使用GpioController控制器=new()；Controller er.OpenPin(pin，PinMode.Output)；Console.WriteLine($&#34；GPIO pin已启用使用：控制器.Write(管脚，PinValue.High)；线程.睡眠(LightTime)；Console.WriteLine($&#34；调暗{dimTime}ms&34；)；控制器.Write(管脚，PinValue.Low)；线程.睡眠(DimTime)；}。</p><p> You can also see the use of target-typed  new, with the assignment to the  controller variable. The  GpioController type is only defined on the left-hand side of the assignment. The type is inferred on the right-hand side. This new syntax is an alternative to  var, which has the type only showing on the right-hand side of the assignment and is inferred on the left-hand side with the  var keyword.</p><p>您还可以看到如何使用目标类型的new，并将其赋值给控制器变量。GpioController类型仅在赋值的左侧定义。类型是在右手边推断出来的。这种新语法是var的另一种选择，var的类型只显示在赋值的右侧，并通过关键字var在左侧推断。</p><p> Top-level programs can also grow in complexity, by defining methods and taking advantage of types defined in the same or other files. The  CharacterLcd sample demonstrates some of those capabilities.</p><p>通过定义方法并利用在相同或其他文件中定义的类型，顶级程序也可能增加复杂性。CharacterLcd示例演示了其中一些功能。</p><p>  C# 9 includes support for new patterns. You can see an example of a logical pattern in the  following code from the  CCS811 Gas sensor.</p><p>C#9包括对新模式的支持。您可以在CCS811气体传感器的以下代码中看到一个逻辑模式的示例。</p><p>  Another new pattern is property patterns. You can see several properties checks in my  Mycroft information access 6.0 sample. The  following code is taken from the  PN532 RFID and NFC reader sample.</p><p>另一种新模式是财产模式。您可以在我的Mycroft信息访问6.0示例中看到几个属性检查。以下代码摘自PN532 RFID和NFC读取器示例。</p><p>  This code tests that  pollingType (which is typed as  byte[]) is not null and does not contain &gt;15 bytes.</p><p>这段代码测试pollingType(类型为byte[])不为空，并且不包含&gt；15个字节。</p><p>    C# 9 includes a new type of class called a record. It has a number of benefits compared to regular classes, half of which relate to more terse syntax. The  following record is taken from the  Bh1745 RGB Sensor binding.</p><p>C#9包括一种名为Record的新类。与常规类相比，它有许多好处，其中一半与更简洁的语法有关。以下记录取自Bh1745 RGB传感器绑定。</p><p>     The .NET libraries are now completely annotated for  nullability. That means if you  enable nullability, you’ll get more type information from the platform to direct your use of the feature. At present, the  .NET docs have not been fully annotated. For example,   String.IsNullOrEmpty(string) should be annotated to take a  string?, while  String.Split(Char[]) has an annotation of  char[]?. We hope that will get fixed soon. Complete information is available at  source.dot.net and via F12 metadata lookups in Visual Studio.</p><p>现在，.NET库完全为空性添加了注释。这意味着如果您启用了空性，您将从平台获得更多类型信息来指导您使用该功能。目前，还没有对.NET文档进行完整的注释。例如，String.IsNullOrEmpty(String)应该被注释为接受一个字符串？，而String.Split(Char[])的注释是char[]？我们希望这个问题很快就能解决。完整的信息可以在Soure.dot.net上找到，也可以通过Visual Studio中的F12元数据查找获得。</p><p> The  System.Device.Gpio and  Iot.Device.Bindings packages (version 1.1.0 for both) have also been annotated as part of this release, using the updated .NET 5.0 annotations. Those libraries are both multi-targeted, however, we use the 5.0 view to produce annotations for all targets.</p><p>System.Device.Gpio和Iot.Device.Bindings包(这两个包的版本都是1.1.0)也作为此版本的一部分进行了注释，使用了更新的.NET5.0注释。这两个库都是多目标的，但是，我们使用5.0视图为所有目标生成注释。</p><p> Note: Existing .NET Core 3.1 code might generate new diagnostics (if you have nullability enabled) when you retarget it to .NET 5.0, since there are new annotations.</p><p>注意：现有的.NET Core 3.1代码可能会在您将其重定目标为.NET5.0时生成新的诊断(如果您启用了为空功能)，因为有新的注释。</p><p> We’ve also added new annotation types. It’s common for large classes to instantiate object members in helper methods called from a constructor. The C# compiler can’t follow the flow of calls to the object assignment. It will think that the member is null when exiting the constructor and will warn with  CS8618. The  MemberNotNull attribute resolves this problem. You apply the attribute to the helper method. The compiler will then see that you set this value and realize that the method is called from a constructor.  MemberNotNullWhen is similar.</p><p>我们还添加了新的注释类型。大型类在从构造函数调用的帮助器方法中实例化对象成员是很常见的。C#编译器不能遵循对对象赋值的调用流程。当退出构造函数时，它会认为该成员为空，并将使用CS8618发出警告。MemberNotNull属性可以解决此问题。将该属性应用于帮助器方法。然后，编译器将看到您设置了此值，并意识到该方法是从构造函数调用的。MemberNotNullWhen类似。</p><p> You can see an example of  MemberNotNull in the  BMxx80 temperature sensors with the  following code.</p><p>您可以使用以下代码在BMxx80温度传感器中看到MemberNotNull的示例。</p><p> [MemberNotNull(nameof(_calibrationData))]private void ReadCalibrationData(){ switch (this) { case Bme280 _: _calibrationData = new Bme280CalibrationData(); _controlRegister = (byte)Bmx280Register.CTRL_MEAS; break; case Bmp280 _: _calibrationData = new Bmp280CalibrationData(); _controlRegister = (byte)Bmx280Register.CTRL_MEAS; break; case Bme680 _: _calibrationData = new Bme680CalibrationData(); _controlRegister = (byte)Bme680Register.CTRL_MEAS; break; default: throw new Exception(&#34;Bmxx80 device not correctly configured. Could not find calibraton data.&#34;); } _calibrationData.ReadFromDevice(this);}</p><p>[MemberNotNull(nameof(_calibrationData))]private空读取校准数据(){Switch(This){case BME280_：_CalibrationData=new Bme280 CalibrationData()；_Control Register=(字节)Bmx280Register.CTRL_Meas；Break；case Bmp280_：_CalibrationData=new Bmp280 CalibrationData()；_Control Register=(字节)Bmx280Register.CTRL_Meas；Break；case BME6。找不到校准数据。&#34；)；}_CalibrationData.ReadFromDevice(This)；}。</p><p> The  actual code uses conditional compilation. That’s because the project is multi-targeted, and this attribute is only supported with .NET 5.0+ . The use of the attribute enables skipping runtime checks (in the constructor) that would otherwise be needed to satisfy nullability requirements, as  is the case for earlier .NET versions.</p><p>实际代码使用条件编译。这是因为该项目是多目标的，而该属性仅在.NET5.0+中受支持。使用该属性可以跳过运行时检查(在构造函数中)，否则将需要这些检查来满足可空性要求，就像早期的.NET版本一样。</p><p>  We’ve improved the Windows Forms designer, changed the way that target frameworks work for .NET 5.0 and beyond, changed the way that WinRT is supported, and made other improvements.</p><p>我们改进了Windows Forms Designer，更改了目标框架在.NET5.0及更高版本中的工作方式，更改了支持WinRT的方式，并进行了其他改进。</p><p>  The Windows Forms designer (for .NET Core 3.1 and .NET 5.0) has been updated in Visual Studio 16.8, and now supports all Windows Forms controls. It also supports all of the Telerik controls. The designer includes all the designer functionality you would expect, including: drag-and-drop, selection, move and resize, cut/copy/paste/delete of controls, integration with the Properties Window, events generation and more. Data binding and support for a broader set of third party controls is coming soon.</p><p>Windows窗体设计器(用于.NET Core 3.1和.NET5.0)已在Visual Studio 16.8中进行了更新，现在支持所有Windows窗体控件。它还支持所有的Telerik控件。设计器包括您预期的所有设计器功能，包括：拖放、选择、移动和调整大小、控件的剪切/复制/粘贴/删除、与属性窗口的集成、事件生成等。数据绑定和对更广泛的第三方控件集的支持很快就会到来。</p><p>    We have changed the approach we use for  target frameworks with .NET 5.0. The following project file demonstrate the new .NET 5.0 target framework.</p><p>在.NET5.0中，我们更改了用于目标框架的方法。以下项目文件演示了新的.NET5.0目标框架。</p><p>  The new  net5.0 form is more compact and intuitive than the  netcoreapp3.1 style we’ve used until this point. In addition, we are extending the target framework to describe operating system dependencies. This change is motivated by our vision to enable targeting iOS and Android with Xamarin in .NET 6.0.</p><p>新的net5.0表单比我们之前使用的netcoreapp3.1样式更紧凑、更直观。此外，我们正在扩展目标框架以描述操作系统依赖关系。这一变化是由我们的愿景推动的，即在.NET6.0中支持使用Xamarin瞄准iOS和Android。</p><p> Windows desktop APIs (including Windows Forms, WPF, and WinRT) will only be available when targeting  net5.0-windows. You can specify an operating system version, like  net5.0-windows7 or  net5.0-windows10.0.17763.0 ( for  Windows October 2018 Update). You need to target a Windows 10 version if you want to use  WinRT APIs.</p><p>Windows桌面API(包括Windows窗体、WPF和WinRT)仅在面向net5.0-windows时可用。您可以指定操作系统版本，如net5.0-Windows7或net5.0-windows10.0.17763.0(适用于Windows 2018年10月更新)。如果您想要使用WinRT API，则需要瞄准Windows 10版本。</p><p> Cross-platform scenarios can be a bit more challenging, when using the new  net5.0-windows TFM.  System.Device.Gpio demonstrates  a pattern for managing the Windows target-framework if you want to avoid building for Windows or avoid pulling Windows runtime packages on Linux, for example.</p><p>当使用新的net5.0-windows tfm时，跨平台的场景可能会更具挑战性。例如，System.Device.Gpio演示了一种用于管理Windows目标框架的模式，例如，如果您希望避免为Windows构建或避免在Linux上拉取Windows运行时包。</p><p>  net5.0-windows will be used to expose Windows-specific functionality, including Windows Forms, WPF and WinRT APIs.</p><p>Net5.0-Windows将用于公开特定于Windows的功能，包括Windows Forms、WPF和WinRT API。</p><p> .NET 6.0 will use the same approach, with  net6.0, and will add  net6.0-ios and  net6.0-android.</p><p>.Net 6.0将使用与net6.0相同的方法，并将添加net6.0-iOS和net6.0-android。</p><p>  Portable APIs, like ASP.NET Core will be usable with  net5.0. The same will be true of Xamarin forms with  net6.0.</p><p>像ASP.NET Core这样的可移植API将可以在net5.0上使用。同样的情况也适用于Net6.0的Xamarin Forms。</p><p> The templates in Visual Studio 16.8 still target .NET Core 3.1, for console, WPF and Windows Forms apps. The ASP.NET templates have been updated to support .NET 5.0. We will update the templates in Visual Studio 16.9 for the remaining templates.</p><p>Visual Studio 16.8中的模板仍然以.NET Core 3.1为目标，用于控制台、WPF和Windows窗体应用程序。ASP.NET模板已更新为支持.NET5.0。我们将在Visual Studio 16.9中更新其余模板的模板。</p><p>  On the topic of targeting Windows APIs, we have moved to a  new model for supporting WinRT APIs as part of .NET 5.0. This includes calling APIs (in either direction; CLR &lt;==&gt; WinRT), marshaling of data between the two type systems, and unification of types that are intended to be treated the same across the type system or  ABI boundary (i.e. “projected types”;   IEnumerable&lt;T&gt; and   IIterable&lt;T&gt; are examples).</p><p>关于以Windows API为目标的主题，我们已经转向了一个新的模型，将WinRT API作为.NET5.0的一部分来支持。这包括调用API(双向；CLR&lt；==&gt；WinRT)，两个类型系统之间的数据封送处理，以及要在类型系统或ABI边界上被同等对待的类型的统一(例如，“投影类型”；IEnumerable&lt；T&gt；和IIterable&lt；T&gt；就是例子)。</p><p> The  existing WinRT interop system has been removed from the .NET runtime as part of .NET 5.0. This is a breaking change. That means that apps and libraries using WinRT with .NET Core 3.x will need to be rebuilt and will not run on .NET 5.0 as-is. Libraries that use WinRT APIs will need to multi-target to manage this difference between .NET Core 3.1 and .NET 5.0.</p><p>现有的WinRT互操作系统已作为.NET5.0的一部分从.NET运行时中移除。这是一个突破性的变化。这意味着使用WinRT和.NET Core 3.x的应用程序和库需要重新构建，不能按原样在.NET5.0上运行。使用WinRT API的库需要多目标来管理.NET Core 3.1和.NET5.0之间的这种差异。</p><p> Going forward, we will rely on the new  CsWinRT tool provided by the WinRT team in Windows. It generates C#-based WinRT interop assemblies, which can be delivered via NuGet. That’s exactly what the Windows team is doing, for the WinRT APIs in Windows. The tool can be used by anyone that wants to use WinRT (on Windows) as an interop system, to expose native APIs to .NET or .NET APIs to native code.</p><p>展望未来，我们将依靠WinRT团队在Windows中提供的新CsWinRT工具。它生成基于C#的WinRT互操作程序集，这些程序集可以通过NuGet交付。这正是Windows团队正在为Windows中的WinRT API所做的事情。任何想要使用WinRT(在Windows上)作为互操作系统的人都可以使用该工具，以将本机API公开给.NET或将.NETAPI公开给本机代码。</p><p> The CsWinRT tools is logically similar to tlbimp and tlbexp, although much better. The tlb tools relied on a lot of COM interop plumbing in the .NET runtime. The CsWinRT tool only relies on public .NET APIs. That said, the  function pointers feature in C# 9 — and partially implemented in the .NET 5.0 runtime — was in part inspired by the needs of the CsWinRT tool.</p><p>CsWinRT工具在逻辑上类似于tlbimp和tlbexp，但要好得多。TLB工具依赖于.NET运行时中的大量COM互操作管道。CsWinRT工具只依赖于公共的.NETAPI。也就是说，C#9中的函数指针功能--在.NET5.0运行时中部分实现了--在一定程度上是受到CsWinRT工具需求的启发。</p><p>  It is symmetrical with the tool-based interop systems provided for other OSes, like iOS and Android.</p><p>它与为iOS和Android等其他操作系统提供的基于工具的互操作系统是对称的。</p><p> The tool can take advantage of other .NET features (AOT, C# features, IL linking), which was not an option for the previous system.</p><p>该工具可以利用其他.NET特性(AOT、C#特性、IL链接)，而这在以前的系统中不是一个选项。</p><p> You don’t need to add NuGet references to use WinRT APIs. Targeting a Windows 10 TFM — just discussed in the .NET 5.0 TFM section earlier — is enough. If you target .NET Core 3.1 or earlier, you need to reference WinRT packages. You can see this pattern in the  System.Device.Gpio project.</p><p>使用WinRT API不需要添加NuGet引用。以Windows10TFM为目标--刚才在.NET5.0TFM一节中已经讨论过了--已经足够了。如果您的目标是.NET Core 3.1或更早版本，则需要引用WinRT包。您可以在System.Device.Gpio项目中看到此模式。</p><p>  We’ve had requests to enable exports for native binaries that calls into .NET code for a long time. The building block for the scenario is  hosting API support for  UnmanagedCallersOnlyAttribute.</p><p>很长一段时间以来，我们一直要求为调用.NET代码的本机二进制文件启用导出。该场景的构建块是托管对UnManagedCeller sOnlyAttribute的API支持。</p><p> This feature is a building-block for creating higher level experiences.  Aaron Robinson, on our team, has been working on a  .NET Native Exports project that provides a more complete experience for publishing .NET components as native libraries. We’re looking for feedback on this capability to help decide if the approach should be included in the product.</p><p>此功能是创建更高级别体验的构建块。我们团队中的Aaron Robinson一直致力于一个.NET Native Exports项目，该项目为将.NET组件发布为本机库提供了更完整的体验。我们正在寻找有关此功能的反馈，以帮助决定是否应将该方法包含在产品中。</p><p>     Over the years, we’ve seen a variety of hosting models for .NET in native applications.  @rseanhall proposed and implemented  a novel new model for doing that, which takes advantage of all the built-in application functionality offered by the .NET application hosting layer (specifically loading dependencies), while enabling a custom entrypoint to be called from native code. That’s perfect for a lot of scenarios, and that one can imagine becoming popular with developers that host .NET components from native applications. That didn’t exist before. Thanks for the contribution,  @rseanhall.</p><p>多年来，我们在本机应用程序中看到了各种.NET托管模型。@rseanHall为此提出并实现了一种新颖的新模型，该模型利用了.NET应用程序托管层提供的所有内置应用程序功能(特别是加载依赖项)，同时允许从本机代码调用自定义入口点。这在很多情况下都是完美的，可以想象在从本机应用程序托管.NET组件的开发人员中变得流行起来。这在以前是不存在的。谢谢你的贡献，@rseanHall。</p><p>    Event pipe is a new subsystem and API that we added in  .NET Core 2.2 to make it possible to perform  performance and other diag</p><p>事件管道是我们在.NET Core 2.2中添加的一个新的子系统和API，它使执行性能和其他诊断成为可能。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://devblogs.microsoft.com/dotnet/announcing-net-5-0/">https://devblogs.microsoft.com/dotnet/announcing-net-5-0/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/net/">#net</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>