<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何使用图论解决秘密圣诞老人问题 How to solve the Secret Santa Problem using graph theory</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to solve the Secret Santa Problem using graph theory<br/>如何使用图论解决秘密圣诞老人问题 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-09 21:35:05</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/e19f2ce1b4516394055c371251f9ce5a.png"><img src="http://img2.diglog.com/img/2021/2/e19f2ce1b4516394055c371251f9ce5a.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Every year we have a  Secret Santa event in our family. Instead of giving a crappy cheap gift to every family member, we assign receivers randomly, so everybody gets one good and valuable present from an anonymous Santa.</p><p>每年我们的家人都会举办一次秘密圣诞老人活动。我们没有给每个家庭成员廉价的礼物，而是随机分配接收者，这样每个人都会从一个匿名的圣诞老人那里得到一份好礼物。</p><p> We decided to develop a simple website where every family member can sign up, fill their wishlist and get a receiver’s name when the event starts. There are many websites and apps for this, but we decided to have our own service to add some modifications to the sorting algorithm.</p><p> 我们决定建立一个简单的网站，每个家庭成员都可以在活动开始时注册，填写愿望清单并获得收件人的姓名。有许多网站和应用程序可用于此目的，但我们决定拥有自己的服务，以对排序算法进行一些修改。</p><p> After every participant has registered, we need to run a sorting algorithm to decide who gives a present to whom. To solve the Secret Santa Problem we need to find this sorting algorithm.</p><p> 每个参与者注册后，我们需要运行排序算法来确定谁向谁赠送礼物。为了解决“秘密圣诞老人”问题，我们需要找到这种排序算法。</p><p> We have an array of all participants. Let’s take the first one by random. Let’s say we have Bob. Next, we remove Bob from the initial array and get a random participant from it. Let’s say we get Alice. So, Bob gives a present to Alice. Then remove Alice from the array and get a random participant who will become a receiver for Alice. And so on. Repeat until the initial array is empty. The last participant will be the Secret Santa for Bob, who was first. The chain of Santas is complete.</p><p> 我们有所有参与者。让我们随机抽取第一个。假设我们有鲍勃。接下来，我们从初始数组中删除Bob并从中获得随机参与者。假设我们得到了爱丽丝。因此，鲍勃给了爱丽丝礼物。然后从阵列中删除Alice，并得到一个随机参与者，该参与者将成为Alice的接收者。等等。重复直到初始数组为空。最后一位参加者是第一位Bob的Secret Santa。圣诞老人链已完成。</p><p>  Such an algorithm is called naive. Each step is obvious, and it imitates people taking tokens from a hat or a lottery machine. In most cases, naive algorithms are not optimal and don’t have great performance, but this task is so easy that the naive algorithm is optimal and has  O(n) performance and O(1) memory.</p><p>  这种算法称为朴素。每个步骤都是显而易见的，它模仿了从帽子或彩票机中获取代币的人们。在大多数情况下，朴素算法不是最佳算法，并且性能不高，但是此任务非常容易，因此朴素算法是最佳算法，具有O（n）性能和O（1）内存。</p><p> The next step is to modify the problem and add some additional requirements to our algorithm. This is why we wanted to create our own service. Sometimes with pure random you can get a Secret Santa who cannot be secret for some reason. E.g., if my Santa is my wife, it is almost impossible to keep it secret.</p><p> 下一步是修改问题，并对我们的算法增加一些其他要求。这就是为什么我们想要创建自己的服务。有时，由于纯粹的随机性，您会得到一个秘密的圣诞老人，由于某种原因它不会成为秘密。例如，如果我的圣诞老人是我的妻子，几乎不可能对其保密。</p><p> So, we decided to add constraints to the problem. For example, Alice and Bob sign in to the event but don’t want to give each other gifts. We need to add this data to the algorithm and take these constraints into account. We can slightly modify the algorithm: when we need to pick a receiver for a participant with constraints (e.g., Bob), we remove these constraints (Alice) from the pool of participants and pick a random one just as before.</p><p> 因此，我们决定为该问题添加约束。例如，爱丽丝（Alice）和鲍勃（Bob）登录了活动，但不想互相送礼物。我们需要将此数据添加到算法中并考虑这些约束。我们可以稍微修改一下算法：当我们需要为有约束条件的参与者（例如鲍勃）挑选一个接收者时，我们从参与者池中删除这些约束条件（爱丽丝）并像以前一样随机选择一个。 </p><p> With such constraints our naive algorithm can fail in some cases. What if it is the last step of the algorithm, we need to pick a receiver for Bob, and Alice is the only option left in the pool? In this case, if we apply all the constraints, there will be no options to pick, and therefore there will be no solution.</p><p>由于这种限制，我们的幼稚算法在某些情况下可能会失败。如果这是算法的最后一步，我们需要为Bob选择一个接收器，而Alice是池中剩下的唯一选项，该怎么办？在这种情况下，如果我们应用所有约束，将没有可供选择的选项，因此将没有解决方案。</p><p>  How can we solve it? The simplest way here is to restart the algorithm until we get a solution. If there are few constraints, it should be pretty safe. Actually, we fixed it exactly this way in the first version of the web-service. It works really well for 10 participants and a couple of constraints and finds a solution in one run. Sometimes it needs 1 or 2 restarts, but there are no infinite loops.</p><p>  我们该如何解决呢？这里最简单的方法是重新启动算法，直到获得解决方案。如果没有什么限制，那应该很安全。实际上，我们在Web服务的第一个版本中完全采用这种方式进行了修复。它非常适合10位参与者和几个约束，并且一次运行即可找到解决方案。有时需要重新启动1或2次，但是没有无限循环。</p><p> But this is a dirty solution to our initial problem. Let’s find a proper algorithm that solves this problem for any input data. Probably, we need to use another representation of it.</p><p> 但这是我们最初的问题的肮脏解决方案。让我们找到一种可以解决所有输入数据问题的合适算法。可能我们需要使用它的另一种表示形式。</p><p> We have participants. We also know constraints (if any) for participants who don’t want to give presents to each other. When we have some objects and connections between them, it’s time to think about  graphs.</p><p> 我们有参与者。我们也知道不想互相赠送礼物的参与者的限制（如果有）。当我们有一些对象以及它们之间的联系时，该考虑一下图形了。</p><p>  In this picture, nodes are participants, and connections between nodes show that they can give each other presents. Bob and Alice cannot do this, so there is no direct connection between them.</p><p>  在此图中，节点是参与者，节点之间的连接表明它们可以互相提供礼物。鲍勃和爱丽丝无法做到这一点，因此他们之间没有直接联系。</p><p> Now we can see that our solution is a path on this graph. It must start with any node, then go through each other node exactly once, and then go back to the beginning, so it means the path is actually a cycle. A path that goes through all nodes exactly once called  a Hamiltonian path. Consequently, such a cycle is a Hamiltonian cycle.</p><p> 现在我们可以看到我们的解决方案是该图中的路径。它必须从任何节点开始，然后精确地遍历其他节点一次，然后再回到起点，因此这意味着该路径实际上是一个循环。穿过所有节点的路径曾经被称为哈密顿路径。因此，这种循环是哈密顿循环。</p><p> This means that the Secret Santa Problem is basically a Hamiltonian cycle problem, and we can find the right algorithm in a book or on the internet.</p><p> 这意味着“秘密圣诞老人问题”基本上是哈密顿循环问题，我们可以在书中或在互联网上找到正确的算法。 </p><p>  But Google disappointed me. Apparently, there is no fast algorithm to find a Hamiltonian path or cycle in a graph. This is an  NP-problem (nondeterministic polynomial), which means there is no polynomial algorithm for it.</p><p>但是谷歌令我失望。显然，没有快速算法可以在图中找到哈密顿路径或循环。这是一个NP问题（不确定性多项式），这意味着没有多项式算法。</p><p>  Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city?</p><p>  给定一个城市列表以及每对城市之间的距离，最精确的路线是什么？</p><p> Sounds familiar, doesn’t it? We need to visit each node exactly once and return to the initial node. This is basically a Hamiltonian cycle we have here. The TSP doesn’t have a fast solution. People write scientific papers about how to solve it faster. Some use  heuristics to reduce the number of options in  brute-force search. Some use  dynamic programming to split it into subproblems, which are easier to solve.</p><p> 听起来很熟悉，不是吗？我们需要访问每个节点一次，然后返回到初始节点。这基本上是我们在这里的哈密顿周期。 TSP没有快速的解决方案。人们撰写有关如何更快解决问题的科学论文。有些使用启发式方法来减少暴力搜索中的选项数量。有些人使用动态编程将其分解为子问题，这些子问题更容易解决。</p><p> Does it mean our Secret Santa Problem requires such a complex algorithm? No, it’s much easier. The main difference here is that the Traveling Salesman Problem requires an optimal Hamiltonian cycle (shortest or most profitable) and the Secret Santa Problem requires any Hamiltonian cycle.</p><p> 这是否意味着我们的“秘密圣诞老人问题”需要如此复杂的算法？不，要容易得多。这里的主要区别在于，旅行商问题需要一个最佳的汉密尔顿周期（最短或最有利可图），而秘密圣诞老人问题则需要任何汉密尔顿周期。</p><p> To brute-force the TSP, we need to find all the possible cycles and pick the optimal. The amount of possible cycles is calculated with  the factorial function: multiplication of all integers from 1 to N. If we have 5 nodes in a graph, there will be 120 cycles to brute-force. For 10 nodes, there would be 3628800 options. For 20 nodes: 2432902008176640000. That’s a lot.</p><p> 为了对TSP进行暴力破解，我们需要找到所有可能的周期并选择最佳周期。可能的循环量是通过阶乘函数计算的：将1到N之间的所有整数相乘。如果图中有5个节点，则将有120个循环要进行蛮力。对于10个节点，将有3628800个选项。 20个节点：2432902008176640000。</p><p> Our problem is much more simple. There are many suitable cycles in the graph, and we need to find the first suitable. Brute-force is not that scary now.</p><p> 我们的问题要简单得多。图中有许多合适的周期，我们需要找到第一个合适的周期。蛮力现在并不那么可怕。</p><p>  Let’s figure out the algorithm. Our goal is to find a Hamiltonian cycle in the graph using brute-force. We start with a random node. This node has some connected nodes. We pick one of its neighbors at random and go there. This node has connected nodes too. We pick one of them which hasn’t been visited yet. And so on.</p><p>  让我们找出算法。我们的目标是使用蛮力在图中找到哈密顿循环。我们从一个随机节点开始。该节点具有一些连接的节点。我们随机选择一个邻居，然后去那里。该节点也已连接节点。我们选择了其中一个尚未被访问的人。等等。 </p><p> At some steps, we can find out that there are no available nodes to pick. It might happen if there are no more connections (because of constraints) or if all neighbor nodes have been visited already. This issue looks like the issue we had with the naive algorithm. With a graph, it’s more clear that we can do a step back and pick another random node. If we did a step back and there are still no nodes to pick, we do another step back.</p><p>在某些步骤中，我们可以发现没有可供选择的节点。如果没有更多的连接（由于约束）或已经访问了所有邻居节点，则可能会发生这种情况。这个问题看起来像我们在使用朴素算法时遇到的问题。使用图形，可以更清楚地知道我们可以后退一步，然后选择另一个随机节点。如果我们退后一步，但仍然没有要选择的节点，则再退一步。</p><p> Repeat until we visit all nodes and return to the first one. The cycle is complete.</p><p> 重复直到访问所有节点并返回第一个节点。循环完成。</p><p>            If we always find a dead end and, after multiple backtrackings, we returned to the first node without any success in finding a Hamiltonian cycle, then there is no solution for this graph. This is the worst possible case because we need to brute-force all the paths to verify that there is no suitable cycle. And it’s a lot, remember the factorial function.</p><p>            如果我们总是发现一个死胡同，并且在多次回溯之后，我们没有找到汉密尔顿周期成功地返回第一个节点，那么该图就没有解决方案。这是最坏的情况，因为我们需要暴力破解所有路径以验证没有合适的循环。还有很多，请记住阶乘函数。</p><p> But we are solving the Secret Santa Problem for a particular web-service. It’s actually an engineering task, not a math one. It is only possible to fail the algorithm if there are too many constraints, and there are not enough connections in the graph to find a proper cycle.</p><p> 但是，我们正在为特定的Web服务解决“秘密圣诞老人”问题。这实际上是一项工程任务，而不是一项数学任务。如果约束太多，并且图中没有足够的连接来找到合适的循环，则可能会使算法失败。</p><p> It would be suspicious if we had a Secret Santa event, and some participants decided that they don’t want to see almost all other people as their Santas. We can add some limits to the interface and define that each participant can have 3 constraints at max. This must be enough for everybody, and it will prevent the algorithm from brute-forcing millions of paths.</p><p> 如果我们举办了“秘密圣诞老人”活动，那将很可疑，一些参与者认为他们不希望将几乎所有其他人都视为圣诞老人。我们可以在界面上添加一些限制，并定义每个参与者最多可以有3个约束。这对于每个人都必须足够，并且将防止该算法强行使用数百万条路径。</p><p> I did some tests. With 3 constraints algorithm sometimes has to do 1 or 2 backtrackings, but for most cases, it finds a solution in N steps for N participants. With a larger amount of constraints, it gets worse. E.g., with 100 participants and 50 constraints for each, brute-force sometimes requires 100 steps, sometimes 400000, and sometimes 1500000.</p><p> 我做了一些测试。具有3个约束的算法有时必须进行1或2个回溯，但是在大多数情况下，它会为N个参与者分N个步骤找到解决方案。约束量越大，情况就越糟。例如，有100个参与者，每个参与者有50个约束，蛮力有时需要100步，有时需要400000，有时需要1500000。</p><p> Our initial problem is solved, and we have a working web-service with a stable sorting algorithm. It works fast enough even with thousands of participants, which is more than enough for a family-scope event. And we learned something about Hamiltonian cycles, NP-problems, and depth-first backtracking search.</p><p> 我们最初的问题已经解决，并且我们有一个具有稳定排序算法的可运行网络服务。即使有成千上万的参与者，它的运行速度也足够快，这对于家庭聚会活动来说已经足够了。我们了解了有关汉密尔顿周期，NP问题和深度优先回溯搜索的知识。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/pragmatic-computer-science/how-to-solve-the-secret-santa-problem-using-graph-theory-a6b216ccc622">https://medium.com/pragmatic-computer-science/how-to-solve-the-secret-santa-problem-using-graph-theory-a6b216ccc622</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/图论/">#图论</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/secret/">#secret</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/算法/">#算法</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>