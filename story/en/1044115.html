<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Swift渲染Moana Rendering Moana with Swift</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rendering Moana with Swift<br/>使用Swift渲染Moana </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-15 20:11:38</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/beee79d8608eda909df459e644e30140.jpg"><img src="http://img2.diglog.com/img/2021/1/beee79d8608eda909df459e644e30140.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>TLDR: Render Disney’s Moana scene in less than 10.000 lines of Swift code.</p><p>TLDR：在少于10.000行的Swift代码中渲染迪士尼的Moana场景。</p><p> After Walt Disney Animation Studios released the scene description of the island in Moana some efforts were started to render it besides Disneys Hyperion. I am aware of the following render engines:</p><p> 沃尔特·迪斯尼动画工作室发布了莫阿纳岛的场景描述后，除了迪斯尼的Hyperion，还开始着手渲染。我知道以下渲染引擎：</p><p>  Here I present another one, the  Gonzales renderer, written by  me. It is heavily inspired by PBRT and written in  Swift (with a few lines in C++ to call OpenEXR and Ptex). It is optimized only as far as to be able to render it in a reasonable amount of time on a free Google Cloud instance (8 vCPUS, 64GB RAM). As far as I know this is the only renderer able to render Moana not written in C/C++. I wrote it with vi and command line Swift on Ubuntu Linux and Xcode on macOS so it should be relatively painless to get it compiled on these platforms.</p><p>  在这里，我介绍由我编写的另一个Gonzales渲染器。它在很大程度上受到PBRT的启发，并用Swift编写（在C ++中有几行调用OpenEXR和Ptex）。它仅在能够在合理的时间内在免费的Google Cloud实例（8个vCPUS，64GB RAM）上呈现的情况下进行了优化。据我所知，这是唯一能够渲染不是用C / C ++编写的Moana的渲染器。我在Ubuntu Linux上使用vi和命令行Swift编写了代码，在macOS上使用Xcode编写了代码，因此在这些平台上进行编译应该相对容易些。</p><p>  I was always uncomfortable with header files and the preprocessor in C and C++. From my point of view something (a variable, a function, …) should be declared and defined  once, not twice. Also, the textual inclusion of header files brings with it many problems like having to add implementation details to header files (templates come to mind) or slow compilation times by repeated inclusion of headers and its combinatorial explosion. When I started C++ modules were not available so I evaluated Python (too slow), Go (too much like C) and some others but in the end only Rust and Swift were serious contenders. I finally chose Swift because of readability (I just don’t like „fn main“ of „impl trait“). Also, being written by the implementors of LLVM and Clang gave me confidence that it would a) not be abandoned in the future and b) meet my performance goals. In short, I wanted a compiled language, no pointers, modules, concepts, ranges, readable templates, and I wanted it  now. Also, compilers were invented to make the life of programmers easier by making programs more readlabe, and sometimes when looking at templated-based code makes me think we are going backwards in time. I like my stuff readable.</p><p>  对于C和C ++中的头文件和预处理器，我总是感到不舒服。从我的角度来看，应该一次声明（而不是两次）声明（定义一个变量，一个函数，…）。同样，头文件的文本包含也带来了许多问题，例如必须向头文件添加实现细节（想到的模板），或者由于重复包含头及其组合爆炸而导致编译时间变慢。当我开始使用C ++模块时，我无法评估Python（太慢），Go（太像C）和其他一些东西，但最终只有Rust和Swift是真正的竞争者。由于可读性的缘故，我最终选择了Swift（我只是不喜欢“ impl trait”的“ fn main”）。另外，由LLVM和Clang的实现者编写的文件使我充满信心，它a）将来不会被放弃，并且b）达到我的性能目标。简而言之，我想要一种编译语言，没有指针，模块，概念，范围，可读模板，现在我想要它。同样，发明了编译器是通过使程序更具可读性来使程序员的生活更轻松，并且有时在查看基于模板的代码时，我认为我们会倒退。我喜欢我的东西可读。</p><p>  Parsing went through a few incarnations. First it was a simple  String(file.availableData, encoding: .utf8) but that is simply to big to fit in memory. Data was not used for similar reasons. Also Scanner from Foundation was evicted at a time. In the end I settled on a InputStream read into an UnsafeMutablePointer&lt;UInt8&gt; array of 64kB.</p><p>  解析经历了一些变化。首先，它是一个简单的String（file.availableData，编码：.utf8），但它太大了以适合内存。出于类似原因未使用数据。基金会的扫描仪也被逐出了一次。最后，我决定将InputStream读入UnsafeMutablePointer＆lt; UInt8＆gt;。数组64kB。</p><p> The Array dead end; in short, don’t ever use Array in a hot path. That is to say, do not ever  generate one. This should have been clear from the beginning since it is heap allocated but the lesson was learned quickly since it always turned up at the top of an analysis done with perf. For fixed-size arrays this can be overcome with tuples or Swift’s internal  FixedArray. Even if the Array is only used subscript getters tend to show up at the top of perf runs.</p><p> 数组死角；简而言之，永远不要在热途中使用Array。也就是说，永远不要生成一个。从一开始就应该清楚这一点，因为它是堆分配的，但是由于它总是出现在用perf进行的分析的顶部，所以很快就学到了这一课。对于固定大小的数组，可以使用元组或Swift的内部FixedArray来克服。即使仅使用数组，下标getter也会显示在性能运行的顶部。</p><p> In general, I found it quite practical to develop on Linus and macOS in parallel since the available tools to check for performance and memory nicely complement each other. I used mainly four tools:</p><p> 总的来说，我发现并行开发Linus和macOS相当实用，因为可用的用于检查性能和内存的工具可以很好地互补。我主要使用了四个工具： </p><p> Perf: This Linux kernel tool gives valuable information where time is spent. Just fire it up, look at the function showing up at the top and wonder where time is wasted. Hint; it is usually not where you think it is. In my case it was always swift_retain or release which tells you over and over again to not allocate objects on the heap.</p><p>性能：此Linux内核工具提供了宝贵的时间信息。只需将其启动，查看顶部显示的功能，并想知道时间浪费在哪里。暗示;它通常不在您认为的位置。在我的情况下，总是swift_retain或release一次又一次告诉您不要在堆上分配对象。</p><p> Valgrind Memcheck: This shows where the memory is gone. For example, an analysis with this tool is the reason why the acceleration structure is separated from the acceleration structure builder; the memory spent in building a bounding hierarchy was simply never released. It is nice to have no pointers in Swift, no malloc or new, or even shared_pointers, but it is still necessary to  think about how memory is used.</p><p> Valgrind Memcheck：这显示内存已耗尽。例如，使用此工具进行分析是将加速结构与加速结构生成器分离的原因；花在建立边界层次结构上的内存从未被释放过。在Swift中没有指针，没有malloc或new甚至没有shared_pointers都很好，但是仍然有必要考虑一下如何使用内存。</p><p> Xcode profiling: I mostly used Time Profiler, Leaks and Allocations which gives you roughly the same information as Perf and Valgrind but from a different viewpoint. Sometimes it is very helpful to look at the same thing from two different views. Which reminds me of the old times when we used to feed our software to three different compilers (Visual Studio, GCC and the one from IRIX, what was its name again? MIPSPro?).</p><p> Xcode概要分析：我主要使用Time Profiler，Leaks和Allocations，它们为您提供与Perf和Valgrind大致相同的信息，但是从不同的角度来看。有时从两个不同的角度看同一件事很有帮助。这让我想起了过去，我们曾经将软件提供给三种不同的编译器（Visual Studio，GCC和IRIX的一种），它的名字又叫MIPSPro？</p><p> Talking about memory, while Swift makes it very easy to write readable and compact code, you still have to think about low-level operations like memory allocations and the like. I frequently switched between structs and classes just to see how memory and performance are affected. The nice thing about not having pointers, new and shared_pointers is that I was able most of the time to just switch between the two without changing anything else in the system.</p><p> 谈到内存，尽管Swift使得编写可读性和紧凑代码非常容易，但是您仍然必须考虑低级操作，例如内存分配等。我经常在结构和类之间切换，只是为了了解内存和性能如何受到影响。没有指针，new和shared_pointers的好处是，我大部分时间都可以在两者之间切换而无需更改系统中的任何其他内容。</p><p>  About protocol-based programming: Grepping through todays‘ Gonzales shows 23 protocols, 57 structs, 47 final classes and 2 non-final classes. Inheritance is almost never used. The two remaining non-final classes are TrowbridgeReitzDistribution and Texture, both of which I’m not happy about and think about redesigning them in the future. All in all, protocol-based programming turns out to result in nice code, for example I used to have a Primitive class like PBRT but soon changed it to a protocol inheriting from protocols like Boundable, Intersectable, Emitting (gone now) and others. Now it is gone too, the BoundingHierarchyBuild just depends on a Boundable existential type and returns a hierarchy of Intersectables that is used by BoundingHierarchy. All primitives are now stored as an array of existential types consisting of a composition of protocols of Boundable and Intersectable ( var primitives = [Boundable &amp; Intersectable]()).</p><p>  关于基于协议的编程：翻阅当今的Gonzales，可以看到23种协议，57个结构，47个最终类和2个非最终类。继承几乎从未使用过。剩下的两个非最终类是TrowbridgeReitzDistribution和Texture，我都不满意，并且考虑在将来重新设计它们。总而言之，基于协议的编程最终会产生漂亮的代码，例如，我曾经拥有PBRT之类的Primitive类，但很快将其更改为继承自Boundable，Intersectable，Emitting（现已消失）等协议的协议。现在它也消失了，BoundingHierarchyBuild仅依赖于Boundable存在类型，并返回由BoundingHierarchy使用的Intersectables层次结构。现在，所有原语都存储为存在类型的数组，该数组由可绑定和可交叉的协议组成（var原语= [Boundable＆Intersectable]（））。</p><p> The primitives in a BoundingHierarchy on the other hand are stored as a [AnyObject &amp; Intersectable]. This has two reasons: 1. Only intersection is needed. 2. AnyObject forces the stored objects to be reference types (or classes) which saves memory since the layout of protocols for both structs and classes ( OpaqueExistentialContainer) uses 40 bytes since Swift tries to store structs inline, whereas class-only protocols ( ClassExistentialContainer) use only 16 bytes as only a pointer has to be stored as can be seen in  Swift’s documentation or verified in the  source. I emphasize that this is not only an academic discussion but I came across this since it showed up at the top of a memcheck run.</p><p> 另一方面，BoundingHierarchy中的基元存储为[AnyObject＆amp;相交]。这有两个原因：1.仅需要交叉点。 2. AnyObject强制存储的对象为引用类型（或类），这节省了内存，因为结构和类的协议布局（OpaqueExistentialContainer）都使用40字节，因为Swift试图以内联方式存储结构，而纯类协议（ClassExistentialContainer）仅使用16个字节，因为只需要存储一个指针即可，如Swift的文档中所示或在源代码中进行了验证。我强调，这不仅是学术讨论，而且由于它出现在memcheck运行的顶部，所以我碰到了这一点。</p><p> One of the reasons you can render Moana in less than 10.000 lines is the ability to write compact code in Swift. One extreme example is parameter lists. In PBRT you can attach arbitrary parameters to objects which results in around 1000 lines of code in paramset.[h|cpp]. In Swift you can achieve the same in about three lines:</p><p> 您可以在少于10.000行中呈现Moana的原因之一是能够在Swift中编写紧凑的代码。一个极端的例子是参数列表。在PBRT中，您可以将任意参数附加到对象，从而在参数集[h | cpp]中产生大约1000行代码。在Swift中，您可以通过三行代码实现相同的目的： </p><p>  Actually, I’m cheating a little bit here but you get the point. (Also, I think this has changed in PBRT-v4.)</p><p>实际上，我在这里有点作弊，但是您明白了。 （此外，我认为这在PBRT-v4中已经改变。）</p><p> About interfacing C++ for Ptex and OpenEXR support: Interoperability with C++ is  on the way for Swift but wasn’t available when I started/as of now. Since I’m using OpenEXR and Ptex only for reading textures and writing images I resorted to  extern &#34;C&#34;. One modulemap and a few lines of C++ code later (100 for Ptex, 82 for OpenEXR) I had support for reading and writing OpenEXR images and Ptex textures.</p><p> 关于将C ++用于Ptex和OpenEXR的接口支持：与C ++的互操作性正在Swift中发展，但在我开始时（或目前）还不可用。由于我仅将OpenEXR和Ptex用于读取纹理和写入图像，所以我求助于extern＆＃34; C＆＃34;。后来有一个modulemap和几行C ++代码（Ptex为100，OpenEXR为82）我支持读写OpenEXR图像和Ptex纹理。</p><p> I am releasing the code now as I am able to render Moana on a Google Compute Engine with 8 vCPUs and 64GB memory which is free for three months, so please download the code, get an account at fire it up. 🙂 That said, there is a lot to do as I optimized it only as far as to be able to get one image rendered. The following is a big todo list roughly sorted from easily implemented to big projects which I might or might not tackle in the future.</p><p> 我现在要发布代码，因为我可以在具有8个vCPU和64GB内存的Google Compute Engine上渲染Moana，这三个月都是免费的，因此请下载代码，并启动一个帐户。 🙂就是说，要做很多事情，因为我只对其进行了优化，以便能够渲染一张图像。以下是一个大型待办事项清单，从容易实施的项目到我将来可能会解决或可能不会解决的大型项目进行分类。</p><p>  Ray differentials for direct rays. This should be relatively easy; have a look at how PBRT-v3 does it, implement differential generation in the camera, pump it through the system and use it in the call to Ptex. There it is handled automatically.</p><p>  直接光线的光线差异。这应该相对容易些。看看PBRT-v3是如何做到的，如何在摄像机中实现差分生成，将其泵送到系统中，并在对Ptex的调用中使用。在那里它是自动处理的。</p><p> Better hierarchies: I only implemented the simplest bounding hierarchy which is nice since it is only 177 lines of code but is also results in suboptimal rendering times. SAH optimized hierarchies should be much better in this regard. They also should not be to difficult to implement since I followed very much PBRT’s implementation.</p><p> 更好的层次结构：我仅实现了最简单的边界层次结构，这很不错，因为它只有177行代码，但渲染时间也不理想。在这方面，SAH优化的层次结构应该更好。由于我非常关注PBRT的实施，因此实施起来也不难。</p><p> Faster parsing: Integrate Ingo Wald’s  fast pbrt parser which parses Moana in seconds instead of half an hour. Or even better: Write a parser for the pbf format in Swift.</p><p> 更快的解析速度：集成Ingo Wald的快速pbrt解析器，该解析器可以在几秒钟内而不是半小时内解析Moana。甚至更好：在Swift中为pbf格式编写一个解析器。</p><p>  An idea about faster parsing, hierarchy generation and scene formats:  LLVM has  three different bitcode formats; in-memory, machine readable (binary) and human readable and it can losslessly convert between the three. Can we have the same? Like PBRT (human readable), PBF or USD (machine readable) and BHF (binary hierarchy format) where bounding hierarchies are already generated and can simply be mapped to memory.</p><p>  关于更快的解析，层次结构生成和场景格式的想法：LLVM具有三种不同的位码格式。内存，机器可读（二进制）和人类可读的，它可以在这三种之间进行无损转换。我们可以一样吗？像PBRT（人类可读），PBF或USD（机器可读）和BHF（二进制层次结构格式）一样，它们的边界层次结构已经生成，可以简单地映射到内存中。 </p><p> Beginner tasks: I only tried to get Moana to render but it should be fairly easy to enhance Gonzales to be able to render other scenes by adding features or fixing bugs. There are lots of  scenes  to  try. Also there  are  many  exporters for PBRT which should work for Gonzales too.</p><p>入门任务：我只是想让Moana进行渲染，但是增强Gonzales使其能够通过添加功能或修复错误来渲染其他场景应该相当容易。有很多场景可以尝试。也有许多PBRT出口商也应为冈萨雷斯服务。</p><p>   Memory: Lots of memory is used for pixel samples as the image is only written when rendering is finished. Change that to write tiles as they are rendered and discard samples early. This interferes with pixel filtering but since we are denoising anyway maybe this is not needed anymore?</p><p>   内存：由于仅在渲染完成时才写入图像，因此许多内存用于像素样本。将其更改为在渲染时写入图块，并尽早丢弃样本。这会干扰像素过滤，但由于我们无论如何都要进行去噪，也许不再需要了吗？</p><p> Smaller Transforms: As of now Transforms store two matrices, a 4×4 matrix storing the transformation and its inverse. This is a little wasteful since you can always compute one from the other but inversion is slow but after careful thinking when which transform is needed it should be possible to get rid of one. Right now both are used when intersecting a triangle but is it possible to store triangle (and other objects like curves) in world space to get rid of the transformation of the ray into object space and similarly the transformation to world space for surface interactions? And how does this interact with transformed primitives and object instances?</p><p> 较小的变换：到目前为止，变换存储两个矩阵，一个4×4矩阵存储变换及其逆矩阵。这有点浪费，因为您总是可以彼此计算，但是求逆很慢，但是在仔细考虑何时需要哪种转换之后，应该可以摆脱其中一种。现在在相交三角形时都使用了两者，但是是否可以在世界空间中存储三角形（以及其他对象，例如曲线）以摆脱射线到对象空间的转换以及类似地到表面相互作用的到世界空间的转换？以及如何与转换后的原语和对象实例进行交互？</p><p> Denoising: I am using OpenImageDenoise for the time being but of course an integrated denoiser in Swift would be nice to have. Also, the beauty, albedo and normal image are written separately, this should be rearchitected.</p><p> 降噪：我暂时正在使用OpenImageDenoise，但是在Swift中使用集成的去噪器当然是不错的选择。此外，应将美女，反照率和正常形象分别写入，这应该重新构造。</p><p>   Beyond path tracing: Look at  PxrUnified and implement  Guided Path Tracing (I had a look at it but it looks… confusing) and  Manifold Next Event Estimation. I think I saw an implementation somewhere but I forgot. (And if only Weta followed Disney’s lead and published the Gandalf head from that paper, sigh!)</p><p>   超越路径跟踪：查看PxrUnified并实现“引导路径跟踪”（我看过它，但看起来……令人迷惑）和流形下一个事件估计。我想我在某处看到了一个实现，但我忘了。 （如果只有Weta跟随迪斯尼的领导，并从那篇论文中发表了甘道夫的头像，那就叹气！）</p><p>  Faster rendering: Embree has a  path tracer. Look at it hard and try to make Gonzales faster.</p><p>  渲染速度更快：Embree具有路径跟踪器。努力看待它，并尝试使冈萨雷斯更快。</p><p> GPU rendering: This should be a big one, PBRT-v4 obviously does this as some of the mentioned renderers above. It should be very well possible to follow them and use Optix to render on a graphics card but I would much prefer a solution not involving closed source. Which would mean that you have to implement your own Optix.   But looking at how CPUs and GPUs are evolving it might be possible in a distant future to use the same (Swift) code on both of them; you can have instances with 448 CPUs in the cloud and the latest GPUs have a few thousand micro-cpus, they look more and more the same. I wonder whether it will be needed to program for AVX in the future as it seems less needed as you can just throw more cores at the problem. At the same time memory is getting more and more NUMA-like so having your data next to the ALU is getting more important. Maybe one day we have render nodes in the cloud each responsible for one part of the scene, each node partitioning the scene geometrically and sending only portions to the CPUS. Then the returned intersections could simply sorted by the  t value of the ray which reminds me of sort-first/middle/last architectures like  Chromium.</p><p> GPU渲染：这应该是一个很大的渲染，显然，PBRT-v4会像上面提到的某些渲染器一样做到这一点。跟随它们并使用Optix在图形卡上进行渲染应该是非常有可能的，但是我更喜欢不涉及封闭源代码的解决方案。这意味着您必须实施自己的Optix。但是，看看CPU和GPU的发展情况，很可能在遥远的将来在两者上使用相同的（Swift）代码。您可以在云端拥有448个CPU的实例，而最新的GPU具有数千个微CPU，它们看起来越来越相似。我想知道将来是否需要对AVX进行编程，因为它似乎不需要了，因为您可以在问题上投入更多的内核。同时，内存变得越来越像NUMA，因此将数据放在ALU旁边变得越来越重要。也许有一天，我们在云中有渲染节点，每个渲染节点负责场景的一部分，每个节点将场景进行几何划分，并且仅将部分内容发送给CPUS。然后，返回的交叉点可以简单地按射线的t值排序，这让我想起了Chromium等排序优先/中间/最后的体系结构。 </p><p> That’s it for now. I would be extremely happy to receive comments what could be done better or implemented more elegantly, bug reports or even pull requests. 😉 Also thanks to Matt Pharr and PBRT, the most valuable resource in the known universe (at least when it involves rendering).</p><p>现在就这样。 我非常高兴收到评论，这些评论可以做得更好或更优雅地执行，还可以报告错误，甚至可以提出请求。 😉同时还要感谢Matt Pharr和PBRT，这是已知宇宙中最有价值的资源（至少在涉及渲染时）。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gonsoloblog.wordpress.com/2021/01/14/rendering-moana-with-swift/">https://gonsoloblog.wordpress.com/2021/01/14/rendering-moana-with-swift/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/swift/">#swift</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/moana/">#moana</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>