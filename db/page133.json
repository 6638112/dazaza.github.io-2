[{"category": "", "categoryclass": "", "imagename": "949004924e0a52f9cd492d71714a1a42.jpg", "infoid": 1072145, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "\u6d77\u602a\u5728\u5730\u7403\u4e0a\u5927\u591a\u6570\u822a\u6d77\u6587\u5316\u7684\u795e\u8bdd\u548c\u4f20\u8bf4\u4e2d\u626e\u6f14\u7740\u91cd\u8981\u7684\u89d2\u8272\uff0c\u5e76\u4e14\u62e5\u6709\u5982\u6b64\u9f13\u821e\u4eba\u5fc3\u7684\u6d77\u6d0b\u751f\u7269\u591a\u6837\u6027\uff0c\u4e0d\u96be\u770b\u51fa\u539f\u56e0\u3002\u4e0e\u9c7c\u7684\u9ad8\u7ea7\u7b56\u5c55\u4eba\u5965\u5229\u5f17\u00b7\u514b\u91cc\u95e8\u548c\u8f6f\u4f53\u52a8\u7269\u7684\u9ad8\u7ea7\u7b56\u5c55\u4eba\u4e54\u6069\u00b7\u963f\u5e03\u83b1\u7279\u4e00\u8d77\u63a2\u7d22\u6f5c\u4f0f\u5728\u535a\u7269\u9986\u6e7f\u85cf\u54c1\u4e2d\u7684\u6614\u65e5\u5947\u5999\u6d77\u602a\u80cc\u540e\u7684\u73b0\u5b9e\u7075\u611f\u3002\u6d77\u5996\u8d77\u6e90\u4e8e\u65af\u582a\u7684\u7eb3\u7ef4\u4e9a\u6c11\u95f4\u4f20\u8bf4\uff0c\u901a\u5e38\u88ab\u63cf\u8ff0\u4e3a\u4e00\u79cd\u5177\u6709\u653b\u51fb\u6027\u7684\u5934\u8db3\u7c7b\u751f\u7269\uff0c\u80fd\u591f\u6467\u6bc1\u6574\u8258\u8239\u5e76\u5c06\u6c34\u624b\u62d6\u5165\u5384\u8fd0\u3002\u4e54\u6069\u8bf4\uff1a\u201c\u4e16\u754c\u5404\u5730\u7684\u8bb8\u591a\u6587\u5316\u90fd\u6709\u5173\u4e8e\u6709\u89e6\u624b\u7684\u91ce\u517d\u9a9a\u6270\u6d77\u5458\u6216\u901a\u5e38\u8d77\u4e0d\u6765\u7684\u795e\u8bdd\u6216\u4f20\u8bf4\u3002\u201d\u5728\u53e4\u5e0c\u814a\uff0c\u4e9a\u91cc\u58eb\u591a\u5fb7\u548c\u666e\u6797\u5c3c\u5199\u8fc7\u5173\u4e8e teuthos\uff08\u9c7f\u9c7c\uff09\u7684\u6587\u7ae0\u3002\u6709\u5965\u5fb7\u8d5b\u4e2d\u7684 Scylla \u548c\u6765\u81ea\u52a0\u52d2\u6bd4\u6d77 (Lusca)\u3001\u65e5\u672c (Akkorokamui) \u548c\u65b0\u897f\u5170 (Te Wheke-a-Muturangi) \u7684\u7c7b\u4f3c\u795e\u8bdd\u3002\u4e54\u6069\u8bf4\uff1a\u201c\u9c7f\u9c7c\u548c\u7ae0\u9c7c\u786e\u5b9e\u662f\u4e0d\u5bfb\u5e38\u7684\u52a8\u7269\u3002\u4ed6\u4eec\u7684\u8eab\u4f53\u8ba1\u5212\u4e0e\u6211\u4eec\u5728\u6d77\u4e2d\u6240\u77e5\u7684\u4efb\u4f55\u5176\u4ed6\u4e8b\u7269\u90fd\u4e0d\u76f8\u4f3c\u3002\u5b83\u4eec\u5feb\u901f\u79fb\u52a8\uff0c\u5b83\u4eec\u7684\u8eab\u4f53\u3001\u624b\u81c2\u548c\u89e6\u624b\u79fb\u52a8\u7684\u65b9\u5f0f\u4f3c\u4e4e\u523a\u6fc0\u4e86\u6211\u4eec\u5bf9\u672a\u77e5\u4e8b\u7269\u7684\u6050\u60e7\u3002 \u201c\u6211\u8ba4\u4e3a\u5b83\u4eec\u662f\u5982\u6b64\u5947\u602a\u7684\u751f\u7269\uff0c\u4e00\u4e9b\u975e\u5e38\u5927\u7684\u7269\u79cd\u5f88\u5c11\u88ab\u770b\u5230\uff0c\u8fd9\u4f7f\u5f97\u5b83\u4eec\u5f88\u53ef\u80fd\u6210\u4e3a\u6d77\u5996\u548c\u5176\u4ed6\u6d77\u517d\u4f20\u8bf4\u7684\u8d77\u70b9\u3002\n\u201c\u6211\u4eec\u8ba4\u4e3a\u53d1\u751f\u7684\u4e8b\u60c5\u662f\uff0c\u5de8\u578b\u9c7f\u9c7c\u548c\u5927\u7ae0\u9c7c\u7684\u90e8\u5206\u6d88\u5316\u6216\u8150\u70c2\u7684\u9057\u9ab8\u88ab\u51b2\u4e0a\u6d77\u6ee9\uff0c\u4eba\u4eec\u5f00\u59cb\u731c\u6d4b\u5b83\u4eec\u53ef\u80fd\u662f\u4ec0\u4e48\u3002 \u201c\u5728\u632a\u5a01\uff0c\u6d77\u5996\u795e\u8bdd\u4e0d\u65ad\u53d1\u5c55\uff0c\u8fd9\u79cd\u88ab\u51b2\u6bc1\u7684\u6807\u672c\u88ab\u89e3\u91ca\u4e3a\u6765\u81ea\u4e0a\u5e1d\u6216\u9b54\u9b3c\u7684\u4fe1\u606f\uff0c\u6709\u65f6\u88ab\u79f0\u4e3a\u6d77\u5929\u4f7f\u3001\u6d77\u9b54\u9b3c\u6216\u6d77\u50e7\u3002\u201d\u4ed6\u8865\u5145\u8bf4\uff0c\u201c\u8fd9\u4e9b\u4e8b\u60c5\u662f\u5206\u5f00\u53d1\u751f\u7684\uff0c\u4e16\u754c\u5404\u5730\u7684\u4eba\u4eec\u63d0\u51fa\u4e86\u7c7b\u4f3c\u7684\u7b54\u6848\u548c\u795e\u8bdd\u2014\u2014\u8fd9\u662f\u795e\u8bdd\u5f62\u5f0f\u7684\u8d8b\u540c\u8fdb\u5316\u7684\u4e00\u4e2a\u6848\u4f8b\u3002\u201d\u5de8\u578b\u9c7f\u9c7c (Architeuthis dux) \u4e8e 1857 \u5e74\u9996\u6b21\u88ab\u897f\u65b9\u79d1\u5b66\u5206\u7c7b\uff0c\u79d1\u5b66\u5bb6\u4eec\u4ecd\u5728\u5fd9\u4e8e\u89e3\u5f00\u4ed6\u4eec\u7684\u5965\u79d8\u3002 \u201c\u547d\u540d\u548c\u5206\u7c7b\u4e00\u79cd\u65b0\u52a8\u7269\u53ea\u662f\u4e00\u4e2a\u5f00\u59cb\uff0c\u201d\u4e54\u6069\u8bf4\u3002 \u201c\u6211\u4eec\u77e5\u9053\u5b83\u662f\u771f\u5b9e\u7684\uff0c\u800c\u4e0d\u662f\u4eba\u4eec\u60f3\u8c61\u4e2d\u7684\u795e\u8bdd\u4e2d\u7684\u91ce\u517d\uff0c\u4f46\u6211\u4eec\u4ecd\u7136\u53ea\u662f\u5f00\u59cb\u4e86\u89e3\u5b83\u4eec\u3002\u201d\u5de8\u578b\u9c7f\u9c7c\u751f\u6d3b\u5728\u4e16\u754c\u5404\u5730\u7684\u6e29\u5e26\u6c34\u57df\uff0c\u751f\u6d3b\u5728\u5730\u8868\u4ee5\u4e0b 200-1,400 \u7c73\u4e4b\u95f4\u3002\u4eba\u4eec\u8ba4\u4e3a\u96cc\u6027\u53ef\u4ee5\u957f\u5230 13 \u7c73\uff0c\u800c\u7a0d\u5c0f\u7684\u96c4\u6027\u53ef\u4ee5\u957f\u5230 10 \u7c73\u3002\u5de8\u578b\u9c7f\u9c7c\u4e0d\u6311\u98df\u2014\u2014\u5b83\u4eec\u6355\u98df\u9c7c\u7c7b\u548c\u7532\u58f3\u7c7b\u52a8\u7269\uff0c\u4e5f\u5403\u98df\u3002\u79d1\u5b66\u5bb6\u4eec\u53d1\u73b0\u4e86\u4e00\u4e9b\u81ea\u76f8\u6b8b\u6740\u7684\u8bc1\u636e\uff0c\u4f46\u83dc\u5355\u4e0a\u6ca1\u6709\u8239\u53ea\u7684\u8ff9\u8c61\u3002\n\u4ed6\u4eec\u6700\u5927\u7684\u9002\u5e94\u662f\u4ed6\u4eec\u7684\u5927\u773c\u775b\u3002\u5de8\u578b\u9c7f\u9c7c\u62e5\u6709\u5730\u7403\u4e0a\u6240\u6709\u751f\u7269\u7684\u7b2c\u4e8c\u5927\u773c\u775b\uff0c\u7528\u4e8e\u5e2e\u52a9\u63a2\u6d4b\u548c\u907f\u5f00\u62b9\u9999\u9cb8\uff0c\u62b9\u9999\u9cb8\u662f\u552f\u4e00\u5927\u5230\u8db3\u4ee5\u5728\u5b83\u4eec\u5b8c\u5168\u957f\u5927\u540e\u5403\u6389\u5de8\u578b\u9c7f\u9c7c\u7684\u6355\u98df\u8005\u3002\u867d\u7136\u5176\u4ed6\u4e00\u4e9b\u8f83\u5c0f\u7684\u9c7f\u9c7c\u79cd\u7c7b\u662f\u597d\u6597\u7684\u730e\u98df\u8005\uff0c\u4f46\u4eba\u4eec\u8ba4\u4e3a\u5de8\u578b\u9c7f\u9c7c\u5728\u8fdc\u79bb\u4eba\u7c7b\u63a5\u89e6\u7684\u6df1\u6e29\u5e26\u6c34\u57df\u8fc7\u7740\u5b64\u72ec\u7684\u751f\u6d3b\u3002\u636e\u4e54\u6069\u8bf4\uff0c\u201c\u5b83\u4eec\u53ef\u80fd\u65e0\u6cd5\u53d8\u5f97\u8db3\u591f\u5927\u4ee5\u51fb\u6c89\u4e00\u8258\u8239\uff0c\u4f46\u8fd9\u53d6\u51b3\u4e8e\u4f60\u7684\u8239\u7684\u5927\u5c0f\u3002\u201d &#39;\u5de8\u578b\u9c7f\u9c7c\u65e0\u6cd5\u5728\u5730\u8868\u83b7\u5f97\u5b83\u4eec\u6240\u9700\u7684\u6c27\u6c14\u3002\u56e0\u6b64\uff0c\u5f53\u4eba\u4eec\u786e\u5b9e\u5728\u5730\u8868\u9047\u5230\u6d3b\u4f53\u65f6\uff0c\u90a3\u662f\u56e0\u4e3a\u4ed6\u4eec\u538b\u529b\u5927\uff0c\u53ef\u80fd\u5feb\u8981\u6b7b\u4e86\u3002 \u201c\u6211\u4eec\u4ecd\u7136\u4e0d\u77e5\u9053\u5b83\u4eec\u662f\u5982\u4f55\u4ea4\u914d\u7684\uff0c\u5b83\u4eec\u80fd\u6d3b\u591a\u4e45\uff0c\u5b83\u4eec\u662f\u5982\u4f55\u751f\u957f\u7684\u3002\u5b83\u4eec\u4ecd\u7136\u662f\u9ad8\u5ea6\u795e\u79d8\u7684\u91ce\u517d\uff0c\u4ee4\u4eba\u5174\u594b\u7684\u662f\u79d1\u5b66\u5bb6\u4ecd\u5728\u56de\u7b54\u8fd9\u4e9b\u95ee\u9898\u3002\u4f5c\u4e3a\u4e16\u754c\u5404\u5730\u822a\u6d77\u6c11\u4fd7\u7684\u4e00\u4e2a\u7279\u5f81\uff0c\u62e5\u6709\u4eba\u5f62\u8eaf\u5e72\u548c\u86c7\u5f62\u5c3e\u5df4\u7684\u6d77\u5996\u548c\u4eba\u9c7c\u5df2\u7ecf\u5728\u5730\u56fe\u548c\u4eba\u7c7b\u60f3\u8c61\u7684\u89d2\u843d\u91cc\u8426\u7ed5\u4e86\u6570\u5343\u5e74\u3002\u5965\u5229\u5f17\u8bf4\uff1a\u201c\u5728 18 \u4e16\u7eaa\uff0c\u4efb\u4f55\u4e58\u5750\u6728\u8239\u98de\u8d8a\u5730\u5e73\u7ebf\u7684\u4eba\u6bd4\u4eca\u5929\u81f3\u5c11\u6709\u65e0\u7ebf\u7535\u8054\u7cfb\u7684\u5b87\u822a\u5458\u66f4\u80fd\u4e0e\u5176\u4ed6\u4eba\u8131\u8282\u3002\u201d\n\u201c\u8fd9\u4e9b\u6c34\u624b\u6709\u65f6\u4f1a\u56e0\u4e3a\u4e0e\u5bb6\u91cc\u7684\u4eba\u6ca1\u6709\u63a5\u89e6\u800c\u65c5\u884c\u591a\u5e74\u3002\u4eba\u4eec\u5bf9\u4ed6\u4eec\u53ef\u80fd\u5728\u4e16\u754c\u53e6\u4e00\u7aef\u770b\u5230\u7684\u5947\u5999\u4e8b\u7269\u62b1\u6709\u5f88\u5927\u7684\u671f\u671b\u3002\u4ed6\u4eec\u7684\u6545\u4e8b\u975e\u5e38\u53d7\u6b22\u8fce\uff0c\u4ee5\u81f3\u4e8e\u65e5\u672c\u6709\u8fdb\u53d6\u5fc3\u7684\u5de5\u5320\u5728\u9690\u533f\u52a8\u7269\u6807\u672c\u65b9\u9762\u5efa\u7acb\u4e86\u84ec\u52c3\u53d1\u5c55\u7684\u8d38\u6613\u3002\u867d\u7136\u4eca\u5929\u6211\u4eec\u53ef\u80fd\u4f1a\u56e0\u4e3a\u5b83\u4eec\u662f\u6076\u4f5c\u5267\u800c\u8ba4\u51fa\u521b\u9020\u6027\u52a8\u7269\u6807\u672c\u5265\u5236\u672f\u6216\u5de7\u5999\u5730\u5e72\u71e5\u6d77\u6d0b\u52a8\u7269\uff0c\u4f46\u7f8e\u4eba\u9c7c\u66fe\u7ecf\u662f\u597d\u5947\u5fc3\u548c\u72c2\u6b22\u8282\u6742\u800d\u7684\u79c1\u4eba\u6a71\u67dc\u7684\u73cd\u8d35\u7279\u5f81\u3002 Jenny Hanivers - \u53ef\u8ffd\u6eaf\u5230 1500 \u5e74\u4ee3 - \u662f\u4e00\u79cd\u5947\u5999\u7684\u6d77\u6d0b\u751f\u7269\uff0c\u7531\u9cd0\u9c7c\u6216 Rhinobatidae \u79d1\u7684\u9cd0\u9c7c\uff08\u4fd7\u79f0\u5409\u4ed6\u9c7c\uff09\u7684\u5e72\u71e5\u8eab\u4f53\u5236\u6210\u3002\u8fd9\u4e9b\u9c7c\u751f\u6d3b\u5728\u6d77\u5e95\uff0c\u867d\u7136\u5b83\u4eec\u8eab\u4f53\u7684\u524d\u7aef\u4f7f\u5b83\u4eec\u770b\u8d77\u6765\u50cf\u9cd0\u9c7c\u6216\u9cd0\u9c7c\uff0c\u4f46\u8eab\u4f53\u7684\u5176\u4f59\u90e8\u5206\u66f4\u50cf\u9ca8\u9c7c\u3002\u5c3d\u7ba1\u97f3\u4e50\u540d\u79f0\uff08\u6307\u7684\u662f\u5b83\u4eec\u72ec\u7279\u7684\u4f53\u578b\uff09\uff0c\u5409\u4ed6\u9c7c\u4e0d\u4f1a\u4e3a\u6c34\u624b\u5531\u5c0f\u591c\u66f2\u3002\u8fd9\u79cd\u5e73\u9759\u7684\u5e95\u6816\u52a8\u7269\u5403\u65e0\u810a\u690e\u52a8\u7269\uff0c\u5728\u4e16\u754c\u5404\u5730\u7684\u6d45\u6d77\u4e2d\u90fd\u80fd\u627e\u5230\u3002\u6839\u636e\u5965\u5229\u5f17\u7684\u8bf4\u6cd5\uff0c\u5728\u5b83\u4eec\u7684\u4eb2\u621a\u2014\u2014\u5c04\u7ebf\u4e2d\u53ef\u4ee5\u770b\u5230\u4e0e\u8b66\u62a5\u5668\u884c\u4e3a\u6700\u76f8\u4f3c\u7684\u884c\u4e3a\u3002\u4ed6\u8bf4\uff1a\u201c\u4e00\u4e9b\u5c0f\u79cd\u7c7b\u7684\u9cd0\u9c7c\u559c\u6b22\u628a\u81ea\u5df1\u7684\u9f3b\u5b50\u4f38\u51fa\u6c34\u9762\uff0c\u6709\u65f6\u4f1a\u4ece\u6c34\u4e2d\u51fa\u73b0\u4e00\u4e2a\u5947\u602a\u7684\u50cf\u8138\u4e00\u6837\u7684\u5e7b\u5f71\u3002\u5b83\u4eec\u901a\u5e38\u662f\u6c34\u65cf\u7bb1\u7684\u7279\u5f81\uff0c\u6709\u4e9b\u7269\u79cd\u751a\u81f3\u4f1a\u8ba9\u4eba\u7c7b\u89e6\u6478\u5b83\u4eec\u3002 \u201c\u5982\u679c\u4f60\u770b\u4e00\u4e0b\u901a\u5e38\u4f4d\u4e8e\u6d77\u5e8a\u4e0a\u7684\u8eab\u4f53\u5e95\u90e8\uff0c\u4f60\u4f1a\u770b\u5230\u5b83\u4eec\u7528\u6765\u538b\u788e\u548c\u5403\u6389\u7532\u58f3\u7c7b\u52a8\u7269\u7684\u4e0b\u5df4\uff0c\u4ee5\u53ca\u6392\u51fa\u6c34\u7684\u547c\u5438\u5b54\u3002\u5f53\u5b83\u4eec\u5e72\u71e5\u6298\u53e0\u65f6\uff0c\u5c31\u4f1a\u9732\u51fa\u4e00\u5f20\u602a\u8bde\u7684\u8138\u3002\n\u8fd9\u4e9b\u52a8\u7269\u8fd8\u6709\u4e00\u4e2a\u5c16\u5c16\u7684\u9f3b\u5b50\u6216\u8bb2\u53f0\uff0c\u7c7b\u4f3c\u4e8e\u6559\u4f1a\u7684\u5e3d\u5b50\uff0c\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u5b83\u4eec\u6709\u65f6\u4e5f\u88ab\u79f0\u4e3a\u6d77\u4e3b\u6559\u3002\u6d77\u86c7\u548c\u6d77\u9f99\u51fa\u73b0\u5728\u4e16\u754c\u5404\u5730\u53ef\u8ffd\u6eaf\u5230\u53e4\u4ee3\u7684\u6545\u4e8b\u4e2d\uff0c\u901a\u5e38\u88ab\u63cf\u7ed8\u6210\u5bf9\u6c34\u624b\u9020\u6210\u4e25\u91cd\u7834\u574f\u3002\u5965\u5229\u5f17\u8bf4\uff1a\u201c\u6d77\u86c7\u795e\u8bdd\u53ef\u4ee5\u8ffd\u6eaf\u5230\u53e4\u4ee3\uff0c\u6211\u4eec\u751a\u81f3\u65e0\u6cd5\u8fa8\u522b\u3002\u201d \u201c\u5982\u679c\u6211\u4eec\u6b63\u5728\u5bfb\u627e\u4ea7\u751f\u8fd9\u4e9b\u6545\u4e8b\u7684\u81ea\u7136\u4e16\u754c\u7684\u5019\u9009\u4eba\uff0c\u90a3\u4e48\u7687\u5e26\u9c7c\u5c31\u4f4d\u5c45\u699c\u9996\u3002\u201d\u5965\u5229\u5f17\u8bf4\uff1a\u201c\u7687\u5e26\u9c7c\u771f\u7684\u662f\u4e00\u79cd\u975e\u5e38\u6f02\u4eae\u7684\u52a8\u7269\u2014\u2014\u957f\u8fbe\u516b\u7c73\uff0c\u957f\u7740\u4e00\u5f20\u9a6c\u4f3c\u7684\u8138\uff0c\u5934\u4e0a\u6709\u706b\u7ea2\u8272\u7684\u51a0\uff0c\u9ccd\u4e00\u76f4\u5ef6\u4f38\u5230\u660e\u4eae\u7684\u91d1\u5c5e\u94f6\u8272\u8eab\u4f53\u3002\u4f60\u8fd8\u60f3\u4ece\u6d77\u602a\u90a3\u91cc\u5f97\u5230\u4ec0\u4e48\uff1f\u4e16\u754c\u4e0a\u6700\u957f\u7684\u786c\u9aa8\u9c7c\uff0c\u5de8\u578b\u7687\u5e26\u9c7c (Regalecus glesne)\uff0c\u5df2\u88ab\u8bb0\u5f55\u53ef\u957f\u8fbe 8 \u7c73\u3002\u5b83\u5728\u4e16\u754c\u5404\u5730\u7684\u6e29\u5e26\u548c\u70ed\u5e26\u6c34\u57df\u5747\u6709\u53d1\u73b0\uff0c\u636e\u4fe1\u751f\u6d3b\u5728 200 \u81f3 1,000 \u7c73\u7684\u6df1\u5904\u3002\u4e0e\u6d77\u6d0b\u4e2d\u8bb8\u591a\u6700\u5927\u7684\u751f\u7269\u4e00\u6837\uff0c\u7687\u5e26\u9c7c\u5403\u6d6e\u6e38\u751f\u7269\u3002 \u201c\u4e0d\u5e78\u7684\u662f\uff0c\u5f53\u4ed6\u4eec\u6d6e\u51fa\u6c34\u9762\u65f6\uff0c\u8fd9\u610f\u5473\u7740\u4ed6\u4eec\u9047\u5230\u4e86\u9ebb\u70e6\u5e76\u9677\u5165\u56f0\u5883\uff0c\u201d\u5965\u5229\u5f17\u89e3\u91ca\u8bf4\u3002\n\u7687\u5e26\u9c7c\u901a\u5e38\u4ee5\u5782\u76f4\u6216\u6c34\u5e73\u59ff\u52bf\u6e38\u6cf3\uff0c\u5229\u7528\u8eab\u4f53\u7684\u5de6\u53f3\u8d77\u4f0f\u548c\u80cc\u9ccd\u6765\u4fdd\u6301\u5e73\u8861\u548c\u5411\u524d\u79fb\u52a8\u3002\u53ea\u6709\u5728\u6c34\u9762\uff0c\u5b83\u4eec\u5728\u547c\u5438\u56f0\u96be\u65f6\u624d\u4f1a\u4fa7\u8eab\u6e38\u6cf3\u3002 \u201c\u5b83\u4eec\u5728\u6c34\u9762\u4e0a\u4fa7\u8eab\u6e38\u6cf3\uff0c\u8fd9\u4e9b\u4ece\u5de6\u5230\u53f3\u7684\u8d77\u4f0f\u53d8\u6210\u4e86\u5782\u76f4\u7684\u8d77\u4f0f\uff0c\u521b\u9020\u4e86\u4e00\u4e2a\u6709\u8da3\u7684\u5947\u89c2\uff0c\u751a\u81f3\u53ef\u4ee5\u4f7f\u5b83\u4eec\u7684\u8eab\u4f53\u5377\u51fa\u6c34\u9762\u3002\u201d\u5c3d\u7ba1\u751f\u6d3b\u5728\u6df1\u6d77\u3001\u4ee5\u6d6e\u6e38\u751f\u7269\u4e3a\u98df\u7684\u7687\u5e26\u9c7c\u5bf9\u6c89\u6ca1\u8239\u53ea\u6216\u5403\u6389\u6c34\u624b\u6ca1\u6709\u5174\u8da3\uff0c\u4f46\u4e00\u4e9b\u4eba\u8ba4\u4e3a\u5b83\u4eec\u662f\u6df1\u6d77\u5730\u9707\u548c\u6d77\u5578\u7684\u53ef\u9760\u9884\u62a5\u5668\uff0c\u5728\u5730\u9707\u4e8b\u4ef6\u53d1\u751f\u524d\u5c31\u5c06\u81ea\u5df1\u6401\u6d45\u3002\u5c3d\u7ba1\u8be5\u7406\u8bba\u5c1a\u672a\u5f97\u5230\u8bc1\u5b9e\uff0c\u4f46\u5965\u5229\u5f17\u8ba4\u4e3a\u5b58\u5728\u4e00\u4e9b\u6709\u8da3\u7684\u5047\u8bbe\u8054\u7cfb\u3002 \u201c\u5b83\u662f\u4e00\u79cd\u957f\u800c\u6241\u5e73\u7684\u5e26\u72b6\u52a8\u7269\uff0c\u5982\u679c\u4f60\u6709\u8fd9\u79cd\u4f53\u578b\uff0c\u5b83\u53ef\u80fd\u4f1a\u7279\u522b\u53d7\u5230\u538b\u529b\u6ce2\u7684\u5f71\u54cd\uff0c\u201d\u4ed6\u8bf4\u3002 &#39;\u6709\u76f8\u5f53\u591a\u7684\u731c\u60f3\uff0c\u4f46\u53ef\u80fd\u6709\u5176\u6838\u5fc3\u7684\u4e1c\u897f\u3002 \u201c\u6d77\u6d0b\uff0c\u5c24\u5176\u662f\u6df1\u6d77\uff0c\u662f\u5730\u7403\u4e0a\u63a2\u7d22\u6700\u5c11\u7684\u6816\u606f\u5730\u3002\u4e00\u76f4\u4ece\u90a3\u91cc\u4f20\u6765\u7684\u56fe\u50cf\u5411\u6211\u4eec\u5c55\u793a\u4e86\u6211\u4eec\u771f\u6b63\u77e5\u9053\u7684\u5f88\u5c11\uff0c\u8fd8\u6709\u591a\u5c11\u60ca\u559c\u5728\u6df1\u6d77\u7b49\u7740\u6211\u4eec\u3002", "note_en": "Sea monsters have a prominent role in myths and legends of most seafaring cultures on Earth and with such inspiring  ocean biodiversity, it&#39;s not difficult to see why.\n  Join  Oliver Crimmen, Senior Curator of Fish, and  Jon Ablett, Senior Curator of Mollusca, as they explore the real-life inspiration behind fantastic sea monsters of yore that are lurking in the Museum&#39;s wet collections.\n  Originating in Scandinavian folklore, the kraken is usually depicted as an aggressive cephalopod-like creature capable of destroying entire ships and dragging sailors to their doom.\n  &#39;Many cultures around the world have a myth or legend about a tentacled beast bothering seamen or generally getting up to no good,&#39; Jon says.\n In ancient Greece, Aristotle and Pliny wrote about teuthos (squid). There&#39;s the Scylla in the Odyssey and similar myths from the Caribbean (Lusca), Japan (Akkorokamui) and New Zealand (Te Wheke-a-Muturangi).\n  Jon says, &#39;Squid and octopus really are unusual animals. Their body plan isn&#39;t similar to anything else that we know of in the sea. They move quickly and the way that their bodies, arms and tentacles move seem to stimulate something in our fear of the unknown.\n &#39;I think the fact that they are such odd creatures, with some very large species being very rarely seen, make it very likely that they could be the starting points for the kraken and other sea beast legends.\n &#39;What we think happened is that the partially digested or rotted remains of giant squid and large octopus were washing up on beaches and people were starting to guess what they might be.\n &#39;In Norway, the kraken myth grew and such washed-up specimens were interpreted as messages from God or the Devil, sometimes called sea angels, sea devils or sea monks.&#39;\n  He adds, &#39;These things happened separately and people around the world came up with similar answers and mythologies - a case of convergent evolution in myth form.&#39;\n  Giant squid ( Architeuthis dux) were first classified by Western science in 1857 and scientists are still busy unpacking their mysteries.\n &#39;Naming and classifying a new animal is only the beginning,&#39; Jon says. &#39;We knew it was real and not a mythical beast from people&#39;s imaginations, but we&#39;re still really just getting to know them.&#39;\n Found in temperate waters all over the world, giant squid live between 200-1,400 metres below the surface. Females are thought grow up to 13 metres and the slightly smaller males reach 10 metres.\n Giant squid aren&#39;t fussy eaters - they hunt fish and crustaceans and also scavenge. Scientists have found some evidence of cannibalism, but there&#39;s no sign of ships on the menu.\n Their greatest adaptation are their huge eyes. Giant squids have the second-largest eyes of any creature on Earth, \u00a0used to help detect and avoid sperm whales, which are the only predator large enough to eat giant squids when they are fully grown.\n While some other species of smaller squid are aggressive pack hunters, the giant squid is thought to lead a solitary life in deep, temperate water, far from human contact.\n  According to Jon, &#39;They probably can&#39;t get big enough to take down a ship, but then it depends on the size of your vessel.&#39;\n &#39;Giant squid can&#39;t get the oxygen they need at the surface. So when people do come across a live one at the surface, it&#39;s because they are stressed and probably dying.&#39;\n &#39;We still don&#39;t know how they mate, how long they live for, how they grow. They&#39;re still highly mysterious beasts and it&#39;s exciting that scientists are still answering these questions.&#39;\n  A feature of seafaring folklore around the world, sirens and merfolk with humanoid torsos and serpentine tails have haunted the corners of maps and human imagination for millennia.\n  Oliver says, &#39;Anybody travelling in a wooden ship over the horizon in the eighteenth century was more out of touch with the rest of humanity than today\u2019s astronauts who at least have radio contact.&#39;\n &#39;These sailors would sometimes be travelling for years out of contact with people at home. There were big expectations about the fantastic things they might have seen on the other side of the world.&#39;\n Their stories were so popular that enterprising craftspeople in Japan established a thriving trade in cryptozoological specimens.\n  Although today we may recognise creative taxidermy or artfully dried sea animals for the hoaxes they were, mermaids were once prized features of private cabinets of curiosity and carnival sideshows.\n  Jenny Hanivers - which date back to the 1500s - are fantastical sea creatures manufactured from the dried bodies of skates or rays from the family Rhinobatidae , commonly known as guitar fishes. These fishes live on the seabed, and while the front end of their bodies makes them look like rays or skates, the rest of the body is more like a shark.\n  Despite the musical name (which refers to their distinctive body shape), guitar fish don&#39;t serenade sailors. The placid, bottom-dwelling animals eat invertebrates and can be found all over the world in shallow seas.\n According to Oliver, the closest resemblance to siren-like behaviour is seen in their relatives, the rays. He says, &#39;Some small species of ray have endeared themselves to humans with their habit of poking their snouts up out of the water, which can sometimes create a strange face-like apparition emerging from the water. They are often features of aquaria where some species will even let humans touch them.\n &#39;If you look at the underside of the body, which is normally resting on the seabed, you will see the jaws they use to crush and eat crustaceans and the breathing apertures where water is expelled. When they are dried and folded, a kind of grotesque face is revealed.&#39;\n  The animals also have a pointed snout or rostrum, which resembles an ecclesiastical hat, which is why they were sometimes also called sea bishops.\n  Sea serpents and sea dragons appear in stories from all over the world dating back to antiquity, and are usually depicted creating havoc for sailors.\n  &#39;Sea serpent myths go back into antiquity to a point in time we can&#39;t even discern,&#39; Oliver says. &#39;If we are looking for candidates from the natural world that generated these tales, then the oarfish is at the top of the list.&#39;\n  Oliver says, &#39;The oarfish really is a fantastic looking animal - up to eight metres long, with a horse-like face, flame-red crest on its head and fin all the way down its bright, metallic silver body. What else do you want from a sea monster?&#39;\n  The world&#39;s longest bony fish, the giant oarfish ( Regalecus glesne),  has been documented growing up to eight meters in length.\n It is found worldwide in temperate and tropical waters and is thought to live at depths between 200 and 1,000 metres. Like many of the largest creatures in the sea, oarfish eat plankton.\n  &#39;Unfortunately, when they come to the surface, it means they are in trouble and stranding themselves,&#39; Oliver explains.\n  Oarfish usually swim in a vertical or horizontal position, using left and right undulations of their bodies and dorsal fins to balance and move forward. It is only at the surface, where they are struggling to breathe that they swim on their sides.\n &#39;Swimming on their sides at the surface, these left to right undulations become vertical undulations that create an interesting spectacle and can even cause their bodies to coil up out of the water.&#39;\n  Although deep-sea-dwelling, plankton-eating oarfish have no interest in sinking ships or consuming sailors, they are considered by some to be reliable predicators of deep-sea earthquakes and tsunamis, stranding themselves in numbers before seismic events.\n  While the theory remains unproven, Oliver believes there are some interesting hypothetical links. &#39;It&#39;s a long, flat, ribbon-shaped animal and if you have that kind of body shape, maybe it&#39;s going to be particularly affected by pressure waves,&#39; he says. &#39;There&#39;s quite a lot of conjecture, but there may be something at the heart of it.\n &#39;The sea, especially the deep sea, is the least explored habitat on Earth. Images coming back from there all the time are showing us just how little we really know and how many surprises are still waiting for us in the deep ocean.&#39;", "posttime": "2021-08-09 01:48:54", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "\u7f8e\u4eba\u9c7c,monsters,\u52a8\u7269", "title": "\u6d77\u602a\u53ca\u5176\u7075\u611f\u6765\u6e90\uff1a\u86c7\u3001\u7f8e\u4eba\u9c7c\u3001\u6d77\u5996\u7b49", "title_en": "Sea monsters and their inspiration: serpents, mermaids, the kraken and more", "transed": 1, "url": "https://www.nhm.ac.uk/discover/sea-monsters-inspiration-serpents-mermaids-the-kraken.html", "via": "", "real_tags": ["\u7f8e\u4eba\u9c7c", "monsters", "\u52a8\u7269"]}, {"category": "", "categoryclass": "", "imagename": "9f7d2389e187cdabe6f0dab242ec177b.png", "infoid": 1072142, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "\u5728 Grapl\uff0c\u6211\u4eec\u76f8\u4fe1\u4e3a\u4e86\u6784\u5efa\u6700\u597d\u7684\u9632\u5fa1\u7cfb\u7edf\uff0c\u6211\u4eec\u9700\u8981\u6df1\u5165\u4e86\u89e3\u653b\u51fb\u8005\u7684\u884c\u4e3a\u3002\u4f5c\u4e3a\u8be5\u76ee\u6807\u7684\u4e00\u90e8\u5206\uff0c\u6211\u4eec\u6b63\u5728\u6295\u8d44\u8fdb\u653b\u6027\u5b89\u5168\u7814\u7a76\u3002\u7ee7\u7eed\u5173\u6ce8\u6211\u4eec\u7684\u535a\u5ba2\uff0c\u4e86\u89e3\u6709\u5173\u9ad8\u98ce\u9669\u6f0f\u6d1e\u3001\u6f0f\u6d1e\u5229\u7528\u548c\u9ad8\u7ea7\u5a01\u80c1\u7b56\u7565\u7684\u65b0\u7814\u7a76\u3002\u5728\u6b64\u5904\u67e5\u627e\u5df2\u53d1\u5e03\u7684 CVE-2021-3490 \u7684\u672c\u5730\u63d0\u6743 (LPE) \u6982\u5ff5\u8bc1\u660e\uff1ahttps://github.com/chompie1337/Linux_LPE_eBPF_CVE-2021-3490\u3002\u5b83\u9488\u5bf9 Ubuntu 20.10 (Groovy Gorilla) \u5185\u6838 5.8.0-25.26 \u5230 5.8.0-52.58\u3002\u548c Ubuntu 21.04 (Hirsute Hippo) 5.11.0-16.17\u3002\u8fd9\u7bc7\u535a\u6587\u65e8\u5728\u4ece\u6f0f\u6d1e\u5229\u7528\u5f00\u53d1\u4eba\u5458\u7684\u89d2\u5ea6\u8be6\u7ec6\u6982\u8ff0 eBPF\u3002\u5728\u8fd9\u7bc7\u6587\u7ae0\u4e2d\uff0c\u6211\u4ecb\u7ecd\u4e86\uff1a\u6211\u5bf9 eBPF \u4e00\u65e0\u6240\u77e5\u3002\u6211\u5e0c\u671b\u901a\u8fc7\u5206\u4eab\u4e00\u4e2a PoC \u4ee5\u53ca\u6211\u7684\u5f00\u53d1\u7ecf\u9a8c\uff0c\u5b83\u53ef\u4ee5\u5e2e\u52a9\u5176\u4ed6\u4eba\u5f00\u59cb\u4f7f\u7528 eBPF\u3002 Berkeley Packet Filter (BPF) \u6700\u521d\u662f\u4f5c\u4e3a\u5728\u5185\u6838\u4e2d\u6267\u884c\u6570\u636e\u5305\u8fc7\u6ee4\u7684\u4e00\u79cd\u65b9\u5f0f\u800c\u521b\u5efa\u7684\u3002\u5b83\u7684\u529f\u80fd\u540e\u6765\u88ab\u91cd\u65b0\u8bbe\u8ba1\u548c\u6269\u5c55\uff0c\u4ee5\u521b\u5efa\u6269\u5c55\u7684\u4f2f\u514b\u5229\u6570\u636e\u5305\u8fc7\u6ee4\u5668 (eBPF) [1]\u3002\u7b80\u800c\u8a00\u4e4b\uff0ceBPF \u4e3a\u7528\u6237\u6a21\u5f0f\u5e94\u7528\u7a0b\u5e8f\u63d0\u4f9b\u4e86\u4e00\u79cd\u65e0\u9700\u7f16\u5199\u5185\u6838\u6a21\u5757\u5373\u53ef\u5728\u5185\u6838\u4e2d\u8fd0\u884c\u4ee3\u7801\u7684\u65b9\u6cd5\u3002\u4f7f\u7528 eBPF \u4e0e\u5185\u6838\u6a21\u5757\u76f8\u6bd4\u7684\u6240\u8c13\u597d\u5904\u662f\u6613\u7528\u6027\u3001\u7a33\u5b9a\u6027\u548c\u5b89\u5168\u6027\u3002\u4e0e\u7eaf\u7528\u6237\u6a21\u5f0f\u7a0b\u5e8f\u76f8\u6bd4\uff0c\u901a\u8fc7\u76f4\u63a5\u5728\u5185\u6838\u4e2d\u6267\u884c\u67d0\u4e9b\u4efb\u52a1\u8fd8\u53ef\u4ee5\u83b7\u5f97\u6027\u80fd\u6539\u8fdb\u3002 eBPF \u7a0b\u5e8f\u7528\u4e8e\u505a\u5f88\u591a\u4e8b\u60c5\uff0c\u4f8b\u5982\uff1a\u8ddf\u8e2a\u3001\u68c0\u6d4b\u3001\u6302\u94a9\u7cfb\u7edf\u8c03\u7528\u3001\u8c03\u8bd5\uff0c\u5f53\u7136\u8fd8\u6709\u6570\u636e\u5305\u6355\u83b7/\u8fc7\u6ee4\u3002 eBPF \u7a0b\u5e8f\u662f\u7528\u9ad8\u7ea7\u8bed\u8a00\u7f16\u5199\u7684\uff0c\u5e76\u4f7f\u7528\u5de5\u5177\u94fe\uff08\u4f8b\u5982 BCC [18]\uff09\u7f16\u8bd1\u6210 eBPF \u5b57\u8282\u7801\u3002 eBPF VM \u4f7f\u7528\u4e00\u4e2a\u7b80\u5355\u7684\u6307\u4ee4\u96c6\uff0c\u8be5\u6307\u4ee4\u96c6\u4f7f\u7528 11 \u4e2a* 64 \u4f4d\u5bc4\u5b58\u5668\u3001\u4e00\u4e2a\u7a0b\u5e8f\u8ba1\u6570\u5668\u548c\u4e00\u4e2a 512 \u5b57\u8282\u56fa\u5b9a\u5927\u5c0f\u7684\u5806\u6808\u3002\u4e5d\u4e2a\u5bc4\u5b58\u5668\u662f\u901a\u7528\u8bfb\u5199\uff0c\u4e00\u4e2a\u662f\u53ea\u8bfb\u5806\u6808\u6307\u9488\uff0c\u7a0b\u5e8f\u8ba1\u6570\u5668\u662f\u9690\u5f0f\u7684 [2] \u3002\u6307\u4ee4\u96c6\u4e0e x86 \u7c7b\u4f3c\uff0c\u53ef\u5bf9 64 \u4f4d\u548c 32 \u4f4d\u503c\u8fdb\u884c\u64cd\u4f5c\u3002\n*\u4ece\u6280\u672f\u4e0a\u8bb2\uff0c\u5b83\u4f7f\u7528\u4e86 12 \u4e2a\u5bc4\u5b58\u5668\uff0c\u4f46\u7b2c 12 \u4e2a\u5bc4\u5b58\u5668\u662f\u4e00\u4e2a\u8f85\u52a9\u5bc4\u5b58\u5668\uff0c\u4ec5\u7528\u4e8e\u6267\u884c ALU \u536b\u751f\u64cd\u4f5c [12]\u3002\u7528\u6237\u6a21\u5f0f\u5e94\u7528\u7a0b\u5e8f\u4f7f\u7528 bpf() [14] \u7cfb\u7edf\u8c03\u7528\u5c06\u5b57\u8282\u7801\u52a0\u8f7d\u5230\u5185\u6838\u4e2d\uff0c\u5176\u4e2d eBPF \u9a8c\u8bc1\u5668\u5c06\u6267\u884c\u8bb8\u591a\u68c0\u67e5\u4ee5\u786e\u4fdd\u7a0b\u5e8f\u5728\u5185\u6838\u4e2d\u201c\u5b89\u5168\u201d\u8fd0\u884c\u3002\u8fd9\u4e2a\u9a8c\u8bc1\u6b65\u9aa4\u5f88\u5173\u952e\u2014\u2014eBPF \u4e3a\u975e\u7279\u6743\u7528\u6237\u516c\u5f00\u4e86\u4e00\u6761\u5728 ring0 \u4e2d\u6267\u884c\u7684\u8def\u5f84\u3002\u52a0\u8f7d\u7a0b\u5e8f\u540e\uff0c\u7528\u6237\u6a21\u5f0f\u5e94\u7528\u7a0b\u5e8f\u5c06\u7a0b\u5e8f\u9644\u52a0\u5230\u201c\u6302\u94a9\u70b9\u201d\u3002\u6302\u94a9\u70b9\u662f\u5185\u6838\u4e2d\u53ef\u4ee5\u9644\u52a0 eBPF \u7a0b\u5e8f\u7684\u5730\u65b9 [5]\u3002 eBPF \u7a0b\u5e8f\u662f\u4e8b\u4ef6\u9a71\u52a8\u7684\uff0c\u8fd9\u610f\u5473\u7740\u7a0b\u5e8f\u5c06\u5728\u6302\u94a9\u70b9\u53d1\u751f\u67d0\u4e9b\u4e8b\u4ef6\u65f6\u6267\u884c\u3002\u7ecf\u5178\u7528\u4f8b\u662f\u5c06 eBPF \u7a0b\u5e8f\u9644\u52a0\u5230\u5957\u63a5\u5b57\uff0c\u5f53\u6570\u636e\u5199\u5165\u65f6\u7a0b\u5e8f\u5c06\u5728\u5957\u63a5\u5b57\u4e2d\u6267\u884c\u3002\u5982\u679c\u8bbe\u7f6e\u4e86 kconfig \u65cb\u94ae CONFIG_BPF_JIT\uff0c\u5219 eBPF \u7a0b\u5e8f\u5728\u9a8c\u8bc1\u548c\u52a0\u8f7d\u540e\u4f1a\u88ab JIT \u7f16\u8bd1\u4e3a\u539f\u751f\u6c47\u7f16\u6307\u4ee4\u3002\u5426\u5219\uff0c\u5f53\u7a0b\u5e8f\u6267\u884c\u65f6\uff0c\u5b83\u4f1a\u5728 eBPF \u89e3\u91ca\u5668\u4e2d\u8fd0\u884c\uff0c\u8be5\u89e3\u91ca\u5668\u89e3\u7801\u5e76\u6267\u884c eBPF \u5b57\u8282\u7801\u6307\u4ee4\u3002\u7528\u6237\u6a21\u5f0f\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u4f7f\u7528 eBPF \u6620\u5c04\u548c eBPF \u8f85\u52a9\u51fd\u6570\u4e0e\u5185\u6838\u4e2d\u8fd0\u884c\u7684 eBPF \u7a0b\u5e8f\u4ea4\u4e92\u5e76\u4ece\u4e2d\u83b7\u53d6\u6570\u636e\uff0c\u8fd9\u4e9b\u51fd\u6570\u901a\u8fc7 bpf() \u7cfb\u7edf\u8c03\u7528\u8fdb\u884c\u8bbf\u95ee\u3002 sysctl \u65cb\u94ae kernel.unprivileged_bpf_disabled \u51b3\u5b9a\u662f\u5426\u5141\u8bb8\u975e\u7279\u6743\u7528\u6237\u8fd0\u884c eBPF \u7a0b\u5e8f\u3002\u5982\u679c\u672a\u8bbe\u7f6e\uff0c\u5219\u5141\u8bb8\u975e\u7279\u6743\u7528\u6237\u5c06 eBPF \u7a0b\u5e8f\u9644\u52a0\u5230\u7528\u6237\u62e5\u6709\u7684\u5957\u63a5\u5b57\u3002\u5728\u8bb8\u591a Linux \u53d1\u884c\u7248\u4e2d\uff0c\u4f8b\u5982 Ubuntu\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u672a\u542f\u7528 unprivileged_bpf_disabled\u3002\u56e0\u6b64\uff0c\u6211\u51b3\u5b9a\u66f4\u4ed4\u7ec6\u5730\u7814\u7a76 eBPF\uff0c\u56e0\u4e3a\u5141\u8bb8\u975e\u7279\u6743\u7528\u6237\u5728\u5185\u6838\u4e2d\u8fd0\u884c\u4ee3\u7801\u662f\u4e00\u4e2a\u6210\u719f\u7684\u653b\u51fb\u9762\u3002\u6211\u5728\u4e0a\u9762\u63d0\u5230\u8fc7\uff0c\u7528\u6237\u6a21\u5f0f\u8fdb\u7a0b\u53ef\u4ee5\u4f7f\u7528 eBPF \u6620\u5c04\u4e0e\u5185\u6838\u4e2d\u7684 eBPF \u7a0b\u5e8f\u8fdb\u884c\u4ea4\u4e92\u3002\u5b83\u4eec\u4e5f\u53ef\u4ee5\u88ab\u591a\u4e2a eBPF \u7a0b\u5e8f\u7528\u6765\u76f8\u4e92\u4ea4\u4e92\u3002\u5b83\u4eec\u662f\u5177\u6709\u4efb\u610f\u6570\u636e\u7ed3\u6784\u7684\u901a\u7528\u952e/\u503c\u5b58\u50a8 [6]\u3002\u6709\u591a\u79cd\u7c7b\u578b\u7684\u6620\u5c04\uff0c\u5305\u62ec\uff1a\u6570\u7ec4\u3001\u961f\u5217\u548c\u5806\u6808\u3002\nkey_size - \u7528\u4e8e\u7d22\u5f15\u5143\u7d20\u7684\u952e\u7684\u5b57\u8282\u5927\u5c0f\uff08\u7528\u4e8e\u6570\u7ec4\u6620\u5c04\uff09 map_flags - \u63cf\u8ff0\u6620\u5c04\u7684\u7279\u6b8a\u7279\u6027\uff0c\u4f8b\u5982\u662f\u5426\u5e94\u8be5\u9884\u5148\u5206\u914d\u6574\u4e2a\u6620\u5c04\u5185\u5b58\u3002\u53ef\u4ee5\u4f7f\u7528 BPF_MAP_CREATE \u547d\u4ee4\u901a\u8fc7 bpf() \u7cfb\u7edf\u8c03\u7528\u4ece\u7528\u6237\u7a7a\u95f4\u521b\u5efa\u548c\u66f4\u6539 eBPF \u6620\u5c04\uff0c\u4f7f\u7528 BPF_MAP_UPDATE_ELEM \u547d\u4ee4\u66f4\u65b0\uff0c\u5e76\u4f7f\u7528 BPF_MAP_LOOKUP_ELEM \u547d\u4ee4\u68c0\u7d22\u5176\u5185\u5bb9\u3002 eBPF \u7a0b\u5e8f\u53ef\u4ee5\u4f7f\u7528 BPF_MAP_CREATE \u8fd4\u56de\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5e76\u8c03\u7528 eBPF \u8f85\u52a9\u51fd\u6570\u6765\u8bbf\u95ee eBPF \u6620\u5c04\uff0c\u8be5\u51fd\u6570\u5c06\u8fd4\u56de\u6307\u5411\u6620\u5c04\u4e2d\u503c\u7684\u6307\u9488\u3002\u6211\u7f16\u5199\u7684\u6f0f\u6d1e\u5229\u7528\u4e86 eBPF \u9a8c\u8bc1\u5668\u4e2d\u7684\u4e00\u4e2a\u9519\u8bef\u3002\u56e0\u6b64\uff0c\u5728\u6df1\u5165\u7814\u7a76\u6f0f\u6d1e\u4e4b\u524d\uff0c\u91cd\u8981\u7684\u662f\u7b80\u8981\u89e3\u91ca\u9a8c\u8bc1\u5668\u7684\u5185\u90e8\u7ed3\u6784\u3002\u9a8c\u8bc1\u5668\u9996\u5148\u6784\u5efa\u7a0b\u5e8f\u7684\u63a7\u5236\u6d41\u56fe\u3002\u7136\u540e\uff0c\u5b83\u5c06\u901a\u8fc7\u6bcf\u4e2a\u53ef\u80fd\u7684\u63a7\u5236\u6d41\u6765\u9a8c\u8bc1\u6bcf\u6761\u6307\u4ee4\u662f\u5426\u6709\u6548\u4ee5\u53ca\u6240\u6709\u5185\u5b58\u8bbf\u95ee\u90fd\u662f\u5b89\u5168\u7684 [3]\u3002\u4e4b\u540e\uff0c\u5b83\u5c06\u5411\u7a0b\u5e8f\u6dfb\u52a0\u8fd0\u884c\u65f6\u68c0\u67e5\u3002\u8fd9\u4e2a\u8fc7\u7a0b\u79f0\u4e3a ALU Sanitation\uff0c\u5c06\u8865\u4e01\u63d2\u5165 eBPF \u5b57\u8282\u7801\uff0c\u4ee5\u786e\u4fdd\u5728\u6267\u884c\u6307\u9488\u8fd0\u7b97\u65f6\u4e0d\u4f1a\u8fdd\u53cd\u8fd0\u884c\u65f6\u5141\u8bb8\u7684\u5185\u5b58\u8303\u56f4 [4]\u3002\u4e0d\u80fd\u6267\u884c\u6307\u9488\u6bd4\u8f83\uff0c\u53ea\u80fd\u5411\u6307\u9488\u6dfb\u52a0\u6216\u51cf\u53bb\u6807\u91cf\u503c\u3002 eBPF \u9a8c\u8bc1\u5668\u4e2d\u7684\u6807\u91cf\u503c\u662f\u4efb\u4f55\u4e0d\u662f\u4ece\u6307\u9488\u6d3e\u751f\u7684\u503c\u3002\u9a8c\u8bc1\u5668\u8ddf\u8e2a\u54ea\u4e9b\u5bc4\u5b58\u5668\u5305\u542b\u6307\u9488\uff0c\u54ea\u4e9b\u5305\u542b\u6807\u91cf\u503c\u3002\u6307\u9488\u8fd0\u7b97\u4e0d\u80fd\u79bb\u5f00\u5730\u56fe\u7684\u201c\u5b89\u5168\u201d\u8fb9\u754c\u3002\u610f\u601d\u662f\uff0c\u7a0b\u5e8f\u65e0\u6cd5\u8bbf\u95ee\u9884\u5b9a\u4e49\u5730\u56fe\u5185\u5b58\u4e4b\u5916\u7684\u4efb\u4f55\u5185\u5bb9\u3002\u4e3a\u6b64\uff0c\u9a8c\u8bc1\u5668\u4f1a\u8ddf\u8e2a\u6bcf\u4e2a\u5bc4\u5b58\u5668\u7684\u503c\u7684\u4e0a\u9650\u548c\u4e0b\u9650\u3002\n\u6307\u9488\u4e0d\u80fd\u5b58\u50a8\u5728\u6620\u5c04\u4e2d\u6216\u5b58\u50a8\u4e3a\u8fd4\u56de\u503c\uff0c\u4ee5\u907f\u514d\u5185\u6838\u5730\u5740\u6cc4\u6f0f\u5230\u7528\u6237\u7a7a\u95f4\u3002\u9a8c\u8bc1\u5668\u4e3a\u6bcf\u4e2a\u53ef\u80fd\u7684\u6267\u884c\u8def\u5f84\u4e2d\u7684\u6bcf\u4e2a\u5bc4\u5b58\u5668\u5b58\u50a8\u4ee5\u4e0b\u8fb9\u754c\u503c\uff0c\u4ee5\u786e\u4fdd\u6ca1\u6709\u8d8a\u754c\u5185\u5b58\u8bbf\u95ee\uff1a umin_value \uff0c umax_value \u5b58\u50a8\u88ab\u89e3\u91ca\u4e3a\u65e0\u7b26\u53f7\u65f6\u7684\u5bc4\u5b58\u5668\u7684\u6700\u5c0f\u503c/\u6700\u5927\u503c (64 bit) \u6574\u6570 smin_value \uff0c smax_value \u5728\u89e3\u91ca\u4e3a\u6709\u7b26\u53f7\uff0864 \u4f4d\uff09\u6574\u6570\u65f6\u5b58\u50a8\u5bc4\u5b58\u5668\u7684\u6700\u5c0f\u503c/\u6700\u5927\u503c\u3002 u32_min_value , u32min_value \u5728\u89e3\u91ca\u4e3a\u65e0\u7b26\u53f7\uff0832 \u4f4d\uff09\u6574\u6570\u65f6\u5b58\u50a8\u5bc4\u5b58\u5668\u7684\u6700\u5c0f\u503c/\u6700\u5927\u503c\u3002 s32_min_value , s32_max_value \u5b58\u50a8\u5bc4\u5b58\u5668\u7684\u6700\u5c0f\u503c/\u6700\u5927\u503c\uff0c\u5f53\u89e3\u91ca\u4e3a\u6709\u7b26\u53f7\uff0832 \u4f4d\uff09\u6574\u6570\u65f6\u3002 var_off \u5305\u542b\u6709\u5173\u5df2\u77e5\u5bc4\u5b58\u5668\u4f4d\u7684\u4fe1\u606f\u3002\u5b83\u5b58\u50a8\u5728\u4e00\u4e2a\u540d\u4e3a tnum \u7684\u7ed3\u6784\u4e2d\uff0c\u8be5\u7ed3\u6784\u5305\u542b\u4e24\u4e2a 64 \u4f4d\u5b57\u6bb5\uff1a mask \u548c value \u3002\u5728\u63a9\u7801\u4e2d\u8bbe\u7f6e\u7684\u6bcf\u4e00\u4f4d\u90fd\u610f\u5473\u7740\u8be5\u4f4d\u7684\u503c\u662f\u672a\u77e5\u7684\u3002\u672a\u8bbe\u7f6e\u4f4d\u662f\u5df2\u77e5\u7684\uff0c\u5b83\u4eec\u7684\u771f\u5b9e\u503c\u5b58\u50a8\u5728 value \u4e2d\u3002\u4f8b\u5982\uff0c\u5982\u679c var_off = {mask = 0x0; value = 0x1} \uff0c\u5bc4\u5b58\u5668\u7684\u6240\u6709\u4f4d\u90fd\u662f\u5df2\u77e5\u7684\uff0c\u5e76\u4e14\u5df2\u77e5\u5bc4\u5b58\u5668\u7684\u503c\u4e3a1\u3002\u5982\u679cvar_off = {mask = 0xFFFFFFFF00000000; value = 0x3} \u8868\u793a\u5bc4\u5b58\u5668\u7684\u4f4e 32 \u4f4d\u5df2\u77e5\u4e3a 0x00000003\uff0c\u9ad8 32 \u4f4d\u672a\u77e5\u3002\n\u8fd9\u4e9b\u8fb9\u754c\u7528\u4e8e\u76f8\u4e92\u66f4\u65b0\u3002\u7279\u522b\u662f\uff0c\u5982\u679c var_off \u6307\u793a\u5bc4\u5b58\u5668\u662f\u5df2\u77e5\u5e38\u6570\uff0c\u5219\u66f4\u65b0\u6700\u5c0f/\u6700\u5927\u754c\u9650\u4ee5\u53cd\u6620\u5df2\u77e5\u503c\u3002\u6211\u4eec\u7a0d\u540e\u4f1a\u770b\u5230\u4e3a\u4ec0\u4e48\u8fd9\u5f88\u91cd\u8981\uff01 ALU Sanitation \u662f\u4e00\u9879\u529f\u80fd\uff0c\u7528\u4e8e\u8865\u5145\u9a8c\u8bc1\u5668\u7684\u9759\u6001\u8303\u56f4\u8ddf\u8e2a\u3002\u5982\u679c\u5bc4\u5b58\u5668\u7684\u503c\u5728\u8fd0\u884c\u65f6\u672a\u843d\u5728\u5176\u9884\u671f\u8303\u56f4\u5185\uff0c\u5219\u8be5\u60f3\u6cd5\u662f\u4e3a\u4e86\u9632\u6b62 OOB \u5185\u5b58\u8bbf\u95ee\u3002\u6dfb\u52a0\u6b64\u529f\u80fd\u662f\u4e3a\u4e86\u5e2e\u52a9\u51cf\u8f7b\u9a8c\u8bc1\u5668\u4e2d\u7684\u6f5c\u5728\u6f0f\u6d1e\u5e76\u9632\u6b62\u6295\u673a\u653b\u51fb\u3002\u5bf9\u4e8e\u6d89\u53ca\u6307\u9488\u548c\u6807\u91cf\u5bc4\u5b58\u5668\u7684\u6bcf\u4e2a\u7b97\u672f\u8fd0\u7b97\uff0c\u90fd\u4f1a\u8ba1\u7b97 alu_limit\u3002\u8fd9\u8868\u793a\u53ef\u4ee5\u6dfb\u52a0\u5230\u6307\u9488\u6216\u4ece\u6307\u9488\u4e2d\u51cf\u53bb\u7684\u6700\u5927\u7edd\u5bf9\u503c [4]\u3002\u5728\u8fd9\u4e9b\u64cd\u4f5c\u4e2d\u7684\u6bcf\u4e00\u4e2a\u4e4b\u524d\uff0c\u4f7f\u7528\u4ee5\u4e0b\u6307\u4ee4\u4fee\u8865\u5b57\u8282\u7801\uff1a *patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux - &gt;alu_limit ) \uff1b *\u8865\u4e01++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; *\u8865\u4e01++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; *\u8865\u4e01++ = BPF_ALU64_IMM (BPF_NEG, BPF_REG_AX, 0); *\u8865\u4e01++ = BPF_ALU64_IMM (BPF_ARSH, BPF_REG_AX, 63); *\u8865\u4e01++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ;\u6ce8\u610foff_reg \u4ee3\u8868\u88ab\u6dfb\u52a0\u5230\u6307\u9488\u5bc4\u5b58\u5668\u7684\u6807\u91cf\u5bc4\u5b58\u5668\uff0cBPF_REG_AUX \u4ee3\u8868\u8f85\u52a9\u5bc4\u5b58\u5668\u3002\u8fd0\u884c\u65f6 off_reg \u7684\u503c\u4ece alu_limit \u4e2d\u51cf\u53bb\u5e76\u5b58\u50a8\u5230 BPF_REG_AX \u4e2d\u3002\u5982\u679c off_reg &gt; alu_limit \uff0c\u5219\u8bbe\u7f6e BPF_REG_AX \u7684\u6700\u9ad8\u4f4d\uff08\u7b26\u53f7\u4f4d\uff09\u3002\u5982\u679c BPF_REG_AUX \u4e2d\u5b58\u50a8\u7684\u5dee\u503c\u4e3a\u6b63\uff0coff_reg \u4e3a\u8d1f\uff0c\u8868\u793a alu_limit \u548c\u5bc4\u5b58\u5668\u7684\u503c\u5177\u6709\u76f8\u53cd\u7684\u7b26\u53f7\uff0c\u5219 BPF_OR \u64cd\u4f5c\u5c06\u8bbe\u7f6e\u7b26\u53f7\u4f4d\u3002\nBPF_NEG \u64cd\u4f5c\u5c06\u5426\u5b9a\u7b26\u53f7\u4f4d\u3002\u5982\u679c\u8bbe\u7f6e\u4e86\u7b26\u53f7\u4f4d\uff0c\u5219\u4e3a 0\uff0c\u5426\u5219\u4e3a 1\u3002 BPF_ARSH \u64cd\u4f5c\u8fdb\u884c 63 \u4f4d\u7b97\u672f\u53f3\u79fb\u3002\u8fd9\u5c06\u7528\u5168 0 \u6216 1\uff08\u7b26\u53f7\u4f4d\u7684\u503c\uff09\u586b\u5145 BPF_REG_AX\u3002\u6839\u636e\u4e0a\u8ff0\u64cd\u4f5c\u7684\u7ed3\u679c\uff0cBPF_AND \u64cd\u4f5c\u8981\u4e48\u5c06 off_reg \u7f6e\u7a7a\uff0c\u8981\u4e48\u4fdd\u6301\u4e0d\u53d8\u3002\u8fd9\u610f\u5473\u7740\u5982\u679c off_reg \u8d85\u8fc7 alu_limit \uff0c\u6216\u8005\u5982\u679c off_reg \u548c alu_limit \u5177\u6709\u76f8\u53cd\u7684\u7b26\u53f7\uff0c\u5219 off_reg \u7684\u503c\u5c06\u88ab\u66ff\u6362\u4e3a 0\uff0c\u4ece\u800c\u4f7f\u6307\u9488\u7b97\u672f\u8fd0\u7b97\u5f52\u96f6\u3002\u6700\u8fd1\u66f4\u65b0\u4e86 alu_limit \u7684\u8ba1\u7b97\u65b9\u5f0f [15]\u3002\u67d0\u4e9b Linux \u53d1\u884c\u7248\u53ef\u80fd\u5c1a\u672a\u91c7\u7528\u65b0\u7684\u5b9e\u73b0\u3002\u4e3a\u5b8c\u6574\u8d77\u89c1\uff0c\u6211\u5c06\u6db5\u76d6\u4e24\u8005\uff0c\u5e76\u5728\u4e0b\u4e00\u8282\u4e2d\u91cd\u65b0\u8ba8\u8bba\u4e3a\u4ec0\u4e48\u5dee\u5f02\u5f88\u91cd\u8981\uff0c\u56e0\u4e3a\u5b83\u4eec\u53d8\u5f97\u76f8\u5173\u3002 alu_limit \u7531\u6307\u9488\u5bc4\u5b58\u5668\u7684\u8fb9\u754c\u51b3\u5b9a\u3002\u610f\u601d\u662f\uff0c\u5982\u679c\u6307\u9488\u5bc4\u5b58\u5668\u6307\u5411\u6620\u5c04\u7684\u5f00\u5934\uff0c\u5219\u51cf\u6cd5\u7684 alu_limit \u4e3a 0\uff0c\u52a0\u6cd5\u7684 alu_limit \u7b49\u4e8e\u6620\u5c04\u7684\u5927\u5c0f\uff08\u51cf 1\uff09\u3002 alu_limit \u968f\u6307\u9488\u5bc4\u5b58\u5668\u4e0a\u7684\u540e\u7eed\u64cd\u4f5c\u66f4\u65b0\u3002 alu_limit \u7531\u504f\u79fb\u5bc4\u5b58\u5668\u7684\u8fb9\u754c\u51b3\u5b9a\u3002\u8fd9\u610f\u5473\u7740\u662f\u5426\u5c06\u8fd0\u884c\u65f6\u504f\u79fb\u5bc4\u5b58\u5668\u7684\u503c\u4e0e\u9a8c\u8bc1\u5668\u9759\u6001\u8303\u56f4\u8ddf\u8e2a\u671f\u95f4\u8ba1\u7b97\u7684\u5bc4\u5b58\u5668\u8fb9\u754c\u8fdb\u884c\u6bd4\u8f83\u3002\n\u6211\u5bf9 eBPF \u9a8c\u8bc1\u5668\u7684\u521d\u6b65\u4e86\u89e3\u6765\u81ea Manfred Paul \u8fd9\u7bc7\u51fa\u8272\u7684\u535a\u5ba2\u6587\u7ae0\uff0c\u8be6\u7ec6\u4ecb\u7ecd\u4e86\u4ed6\u5bf9 CVE-2020-8835 \u7684\u5229\u7528\u3002\u6211\u5f3a\u70c8\u5efa\u8bae\u68c0\u67e5\u4e00\u4e0b\uff01\u56de\u60f3\u4e00\u4e0b\uff0ceBPF \u6307\u4ee4\u96c6\u53ef\u4ee5\u5bf9\u6574\u4e2a 64 \u4f4d\u5bc4\u5b58\u5668\u6216\u4ec5\u4f4e 32 \u4f4d\u8fdb\u884c\u64cd\u4f5c\u3002\u56e0\u6b64\uff0c\u9a8c\u8bc1\u5668\u8303\u56f4\u8ddf\u8e2a\u5305\u542b\u5bc4\u5b58\u5668\u4f4e 32 \u4f4d\u7684\u5355\u72ec\u8fb9\u754c\uff1a {u,s}32_{min,max}_value \u3002\u6bcf\u6b21\u64cd\u4f5c\u90fd\u4f1a\u66f4\u65b0\u8fd9\u4e9b\u8fb9\u754c\u3002\u6bcf\u4e2a\u64cd\u4f5c\u90fd\u6709\u4e24\u4e2a\u8ddf\u8e2a\u529f\u80fd\uff0c\u4e00\u4e2a 64 \u4f4d\u548c\u4e00\u4e2a 32 \u4f4d\u8ba1\u6570\u5668\u90e8\u5206\u3002\u4e24\u8005\u90fd\u5728\u51fd\u6570 adjust_scalar_min_max_vals \u4e2d\u8c03\u7528 64 \u4f4d\u64cd\u4f5c\u3002 * /* \u8b66\u544a\uff1a\u6b64\u51fd\u6570\u5bf9 64 \u4f4d\u503c\u8fdb\u884c\u8ba1\u7b97\uff0c\u4f46 * \u5b9e\u9645\u6267\u884c\u53ef\u80fd\u53d1\u751f\u5728 32 \u4f4d\u503c\u4e0a\u3002\u56e0\u6b64\uff0c*\u50cf\u4f4d\u79fb\u8fd9\u6837\u7684\u4e1c\u897f\u5728 32 \u4f4d\u60c5\u51b5\u4e0b\u9700\u8981\u989d\u5916\u68c0\u67e5\u3002*/ static int adjust_scalar_min_max_vals ( struct bpf_verifier_env *env, struct bpf_insn *insn, struct bpf_reg_state *dst_reg, struct bpf_reg_state src_reg ) { ... case BdPFst_AND - &gt;var_off = tnum_and (dst_reg - &gt;var_off , src_reg .var_off ) ; scalar32_min_max_and (dst_reg , &amp;src_reg ) ; scalar_min_max_and (dst_reg , &amp;src_reg ) ;\u4f11\u606f ;\u6848\u4f8b BPF_OR : dst_reg - &gt;var_off = tnum_or (dst_reg - &gt;var_off , src_reg .var_off ) ; scalar32_min_max_or (dst_reg , &amp;src_reg ) ; scalar_min_max_or (dst_reg , &amp;src_reg ) ;\u4f11\u606f ;\u6848\u4f8b BPF_XOR : dst_reg - &gt;var_off = tnum_xor (dst_reg - &gt;var_off , src_reg .var_off ) ; scalar32_min_max_xor (dst_reg , &amp;src_reg ) ; scalar_min_max_xor (dst_reg , &amp;src_reg ) ;\u4f11\u606f ; ... } \u6f0f\u6d1e CVE-2021-3490 \u4f4d\u4e8e BPF_AND \u3001 BPF_OR \u548c BPF_XOR \u64cd\u4f5c\u7684 32 \u4f4d\u8ddf\u8e2a\u51fd\u6570\u4e2d\u3002\u6bcf\u4e2a\u529f\u80fd\u90fd\u662f\u4e00\u6837\u7684\u3002\u8ba9\u6211\u4eec\u6765\u770b\u770b BPF_AND \u7684\u8fdd\u89c4\u4ee3\u7801\u7684\u6458\u5f55\uff1a static void scalar32_min_max_and ( struct bpf_reg_state *dst_reg, struct bpf_reg_state *src_reg ) { bool src_known = tnum_subreg_is_const (src_reg - &gt;var_off) bool dst_known = tnum_subreg_is_const (dst_reg - &gt;var_off); struct tnum var32_off = tnum_subreg (dst_reg - &gt;var_off) ; s32 smin_val = src_reg-&gt;s32_min_value; u32 umax_val = src_reg - &gt;u32_max_value \uff1b /* \u5047\u8bbe scalar64_min_max_and \u5c06\u88ab\u8c03\u7528\uff0c\u6240\u4ee5\u5b83\u5b89\u5168 * \u8df3\u8fc7\u66f4\u65b0\u5df2\u77e5 32 \u4f4d\u60c5\u51b5\u7684\u5bc4\u5b58\u5668\u3002 */ \u5982\u679c (src_known &amp;&amp; dst_known ) \u8fd4\u56de\uff1b ... }\n\u5982\u4e0a\u9762\u7684\u4ee3\u7801\u7247\u6bb5\u6240\u793a\uff0c\u5982\u679c\u6e90\u5bc4\u5b58\u5668\u548c\u76ee\u6807\u5bc4\u5b58\u5668\u7684\u4f4e 32 \u4f4d\u5df2\u77e5\uff0c\u5219\u8be5\u51fd\u6570\u4f1a\u8df3\u8fc7\u66f4\u65b0 32 \u4f4d\u8fb9\u754c\u3002\u8fd4\u56de\u4e0a\u9762\u7684\u6ce8\u91ca\u6307\u51fa\u8fd9\u662f\u53ef\u4ee5\u7684\uff0c\u56e0\u4e3a 64 \u4f4d\u5bf9\u5e94\u7269\u4f1a\u5904\u7406\u5b83\u3002\u6211\u4eec\u6765\u770b\u770b\uff1a static void scalar_min_max_and ( struct bpf_reg_state *dst_reg, struct bpf_reg_state *src_reg ) { bool src_known = tnum_is_const (src_reg - &gt;var_off ) ; bool dst_known = tnum_is_const (dst_reg - &gt;var_off) ; s64 smin_val = src_reg-&gt;smin_value; u64 umin_val = src_reg - &gt;umin_value \uff1b if (src_known &amp;&amp; dst_known ) { __mark_reg_known (dst_reg , dst_reg - &gt;var_off .value ) ;\u8fd4\u56de ; } ... } \u7684\u786e\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u5982\u679csrc_known \u548cdst_known \u4e3a\u771f\uff0c\u51fd\u6570__mark_reg_known \u4f1a\u88ab\u8c03\u7528\u3002\u4f60\u80fd\u53d1\u73b0\u95ee\u9898\u5417\uff1f\u5728 scalar32_min_max_and \u4e2d\uff0c _known \u53d8\u91cf\u662f\u4f7f\u7528 tnum_subreg_is_const \u8ba1\u7b97\u7684\u3002 64 \u4f4d\u5bf9\u5e94 scalar_min_max_and \u4f7f\u7528 tnum_is_const \u3002\u533a\u522b\u5728\u4e8e\uff0c\u5982\u679c\u5bc4\u5b58\u5668\u7684\u4f4e 32 \u4f4d\u662f\u5df2\u77e5\u5e38\u91cf\uff0c\u5219\u524d\u8005\u8fd4\u56de\u771f\uff0c\u800c\u540e\u8005\u4ec5\u5728\u6574\u4e2a 64 \u4f4d\u90fd\u662f\u5e38\u91cf\u65f6\u624d\u8fd4\u56de\u771f\u3002\u5982\u679c\u64cd\u4f5c\u6d89\u53ca\u4f4e 32 \u4f4d\u5df2\u77e5\u4f46\u9ad8 32 \u4f4d\u672a\u77e5\u7684\u5bc4\u5b58\u5668\uff0c\u5219\u8fdd\u53cd\u6ce8\u91ca\u4e2d\u6240\u8ff0\u7684\u5047\u8bbe\u3002\u5728\u51fd\u6570 adjust_scalar_min_max_vals \u4e2d\uff0c\u5728\u8fd4\u56de\u4e4b\u524d\uff0c\u901a\u8fc7\u8c03\u7528\u4ee5\u4e0b\u4e09\u4e2a\u51fd\u6570\u6700\u540e\u4e00\u6b21\u66f4\u65b0\u76ee\u6807\u5bc4\u5b58\u5668\u7684\u8fb9\u754c\uff1a\u8fd9\u4e9b\u51fd\u6570\u4e2d\u7684\u6bcf\u4e00\u4e2a\u90fd\u6709 32 \u4f4d\u548c 64 \u4f4d\u5bf9\u5e94\u9879\u3002\u6211\u5c06\u53ea\u4ecb\u7ecd 32 \u4f4d\u60c5\u51b5\uff0c\u56e0\u4e3a\u90a3\u662f\u9519\u8bef\u5f71\u54cd\u7684\u5185\u5bb9\u3002\nstatic void __update_reg32_bounds (struct bpf_reg_state *reg) { struct tnum var32_off = tnum_subreg (reg-&gt;var_off); /* \u6700\u5c0f\u6709\u7b26\u53f7\u662f\u6700\u5927\uff08\u7b26\u53f7\u4f4d\uff09 | min(other bits) */ reg - &gt;s32_min_value = max_t (s32 , reg - &gt;s32_min_value , var32_off .value | (var32_off .mask &amp; S32_MIN ) ) ; /* \u6700\u5927\u6709\u7b26\u53f7\u662f\u6700\u5c0f\uff08\u7b26\u53f7\u4f4d\uff09 | max(other bits) */ reg - &gt;s32_max_value = min_t (s32 , reg - &gt;s32_max_value , var32_off .value | (var32_off .mask &amp; S32_MAX ) ) ; reg - &gt;u32_min_value = max_t (u32 , reg - &gt;u32_min_value , (u32 )var32_off .value ) ; reg - &gt;u32_max_value = min (reg - &gt;u32_max_value , (u32 ) (var32_off .value | var32_off .mask ) ) ;\u8bf7\u6ce8\u610f\uff0c\u6700\u5c0f\u503c\u8fb9\u754c\u8bbe\u7f6e\u4e3a\u5f53\u524d\u6700\u5c0f\u503c\u6216\u5bc4\u5b58\u5668\u7684\u5df2\u77e5\u503c\uff0c\u4ee5\u8f83\u5927\u8005\u4e3a\u51c6\u3002\u7c7b\u4f3c\u5730\uff0c\u6700\u5927\u8fb9\u754c\u8bbe\u7f6e\u4e3a\u5f53\u524d\u6700\u5927\u503c\u6216\u5bc4\u5b58\u5668\u7684\u5df2\u77e5\u503c\uff0c\u4ee5\u8f83\u5c0f\u8005\u4e3a\u51c6\u3002\u7136\u540e\uff0c\u5728 __reg32_deduce_bounds \u4e2d\u4f7f\u7528\u6709\u7b26\u53f7\u548c\u65e0\u7b26\u53f7\u8fb9\u754c\u76f8\u4e92\u66f4\u65b0\u3002 /* \u4f7f\u7528\u6709\u7b26\u53f7\u7684\u6700\u5c0f\u503c/\u6700\u5927\u503c\u6765\u901a\u77e5\u65e0\u7b26\u53f7\uff0c\u53cd\u4e4b\u4ea6\u7136 */ static void __reg32_deduce_bounds ( struct bpf_reg_state *reg ) { /* \u4ece\u6709\u7b26\u53f7\u7684\u8fb9\u754c\u4e2d\u5b66\u4e60\u7b26\u53f7\u3002 * \u5982\u679c\u6211\u4eec\u4e0d\u80fd\u8de8\u8d8a\u7b26\u53f7\u8fb9\u754c\uff0c\u90a3\u4e48\u6709\u7b26\u53f7\u8fb9\u754c\u548c * \u65e0\u7b26\u53f7\u8fb9\u754c * \u662f\u4e00\u6837\u7684\uff0c\u6240\u4ee5\u7ed3\u5408\u8d77\u6765\u3002\u8fd9\u751a\u81f3\u5728 * \u5426\u5b9a\u60c5\u51b5\u4e0b\u4e5f\u6709\u6548\uff0c\u4f8b\u5982 * -3 s&lt;= x s&lt;= -1 \u610f\u5473\u7740 0xf...fd u&lt;= x u&lt;= 0xf...ff\u3002 */ if (reg - &gt;s32_min_value &gt;= 0 || reg - &gt;s32_max_value &lt; 0 ) { reg - &gt;s32_min_value = reg - &gt;u32_min_value = max_t (u32 , reg - &gt;s32_min_value , reg - &gt;u32_min_value ) ; reg - &gt;s32_max_value = reg - &gt;u32_max_value = min_t (u32 , reg - &gt;s32_max_value , reg - &gt;u32_max_value ) ;\u8fd4\u56de ; } ... } static void __reg_bound_offset (struct bpf_reg_state *reg) { struct tnum var64_off = tnum_intersect (reg - &gt;var_off , tnum_range (reg - &gt;umin_value , reg - &gt;umax_value ) ) ; struct tnum var32_off = tnum_intersect (tnum_subreg (reg -&gt;var_off), tnum_range (reg -&gt;u32_min_value, reg -&gt;u32_max_value)); reg - &gt;var_off = tnum_or (tnum_clear_subreg (var64_off), var32_off); tnum_intersect \u63a5\u53d7\u4e24\u4e2a tnum \u5e76\u5c06\u4e24\u8005\u4f20\u8fbe\u7684\u77e5\u8bc6\u7ec4\u5408\u6210\u4e00\u4e2a tnum \u3002\u8ba9\u6211\u4eec\u901a\u8fc7\u4e00\u4e2a\u4f8b\u5b50\u6765\u5b8c\u6210\u8fd9\u4e9b\u6b65\u9aa4\uff0c\u8fd9\u6837\u6211\u4eec\u5c31\u80fd\u7406\u89e3\u4e3a\u4ec0\u4e48\u8fd9\u662f\u4e00\u4e2a\u4e25\u91cd\u7684\u6f0f\u6d1e\u3002\n\u5047\u8bbe\u6211\u4eec\u6709\u6307\u4ee4 BPF_ALU64_REG(BPF_AND, R2, R3)\u3002\u8be5\u6307\u4ee4\u5bf9\u5bc4\u5b58\u5668 R2 \u548c R3 \u6267\u884c AND \u8fd0\u7b97\u5e76\u5c06\u7ed3\u679c\u4fdd\u5b58\u5728 R2 \u4e2d\u3002 R2 \u6709 var_off = {mask = 0xFFFFFFFF00000000; value = 0x1}\uff0c\u8868\u793a\u5df2\u77e5\u4f4e 32 \u4f4d\u503c\u4e3a 1\uff0c\u9ad8 32 \u4f4d\u672a\u77e5\u3002\u56e0\u4e3a\u5bc4\u5b58\u5668\u7684\u4f4e 32 \u4f4d\u662f\u5df2\u77e5\u7684\uff0c\u6240\u4ee5\u5b83\u7684 32 \u4f4d\u8fb9\u754c\u7b49\u4e8e\u8be5\u503c\u3002 R3 \u6709 var_off = {mask = 0x0; value = 0x100000002}\uff0c\u610f\u5473\u7740\u6574\u4e2a 64 \u4f4d\u662f\u5df2\u77e5\u7684\u5e76\u4e14\u7b49\u4e8e 0x100000002\u3002\u5982 adjust_scalar_min_max_vals \u7247\u6bb5\u7684\u7b2c 12 \u884c\u6240\u793a\uff0c\u51fd\u6570 tnum_and \u88ab\u8c03\u7528\u3002\u8fd9\u5c06\u6267\u884c AND \u8fd0\u7b97\u5e76\u5c06\u7ed3\u679c\u4fdd\u5b58\u5728\u76ee\u6807\u5bc4\u5b58\u5668 R2 \u7684 var_off \u4e2d\u3002\u56de\u60f3\u4e00\u4e0b\uff0c\u4e24\u4e2a\u5bc4\u5b58\u5668\u4e2d\u7684\u4f4e 32 \u4f4d\u90fd\u662f\u5df2\u77e5\u7684\u3002 R3 \u7684\u6240\u6709\u4f4d\u90fd\u662f\u5df2\u77e5\u7684\uff1a\u9ad8 31 \u4f4d\u662f 0\uff0c\u7b2c 32 \u4f4d\u662f 1\u3002\u8fd9\u610f\u5473\u7740 R2 \u5269\u4e0b var_off = {mask = 0x100000000;\u503c = 0x0}\u3002\u8fd9\u662f\u56e0\u4e3a 2 &amp; 1 = 0\uff08\u5bf9\u4e8e\u4f4e 32 \u4f4d\uff09\uff0c\u5e76\u4e14\u9664\u4e86\u7b2c 32 \u4f4d\u4e4b\u5916\u7684\u6240\u6709\u4f4d\u90fd\u5c06\u88ab\u79f0\u4e3a 0\uff0c\u56e0\u4e3a R3 \u5728\u7b2c 32 \u4f4d\u4e2d\u6709\u4e00\u4e2a 1\u3002\u5728\u4e0b\u4e00\u884c\uff0c\u8c03\u7528 scalar32_min_max_and\u3002\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u8fd9\u4e2a\u51fd\u6570\u4f1a\u7acb\u5373\u8fd4\u56de\u5e76\u4e14\u4e0d\u4f1a\u6539\u53d8\u8fb9\u754c\uff0c\u56e0\u4e3a\u4e24\u4e2a\u5bc4\u5b58\u5668\u7684\u4f4e 32 \u4f4d\u90fd\u662f\u5df2\u77e5\u7684\u3002\u7136\u540e __update_reg32_bounds \u88ab\u8c03\u7528\u3002\u8fd9\u5c06\u8bbe\u7f6e u32_max_value = 0 \uff0c\u56e0\u4e3a var_off.value = 0 &lt; u32_max_value = 1 \u7684\u503c\u3002\u540c\u6837\uff0c\u5b83\u4f1a\u8bbe\u7f6e u32_min_value = 1 \u56e0\u4e3a var_off.value = 0 &lt; u32_min_value \u3002\u7b7e\u540d\u8fb9\u754c\u4e5f\u662f\u5982\u6b64\u3002\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u7559\u4e0b\u4e86\u4e00\u4e2a\u5bc4\u5b58\u5668\uff0c\u5176\u4e2d {u,s}32_max_value = 0 &lt; {u,s}32_min_value = 1 \uff01\n@@ - 7084 , 11 + 7084 , 10 @@ static void scalar32_min_max_and (struct bpf_reg_state *dst_reg , s32 smin_val = src_reg - &gt; s32_min_value ; u32 umax_val = 3 src_max - u32 umax_val = 3 src_max - u32 umax_val = 3 src_max - u /* 3 src_max - u /* 3 2_reg_\u548c * 4 _ \u548c * 4 \u5c06\u5b89\u5168\u79f0\u4e3a\u5b89\u5168\u8df3\u8fc7\u66f4\u65b0\u5df2\u77e5 32 \u4f4d\u60c5\u51b5\u7684\u5bc4\u5b58\u5668\u3002- */ - if (src_known &amp;&amp; dst_known ) + if (src_known &amp;&amp; dst_known ) { + __mark_reg32_known (dst_reg , var32_off .value ) ; return ; + } \u4e0a\u9762\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u770b\u5230\uff0c\u5982\u679c\u6e90\u548c\u76ee\u6807\u5bc4\u5b58\u5668\u7684\u4f4e 32 \u4f4d\u662f\u5df2\u77e5\u5e38\u91cf\uff0c\u5219\u5728\u8fd4\u56de\u4e4b\u524d\u5728\u76ee\u6807\u5bc4\u5b58\u5668\u4e0a\u8c03\u7528 __mark_reg32_known\u3002 /* \u5c06\u5bc4\u5b58\u5668\u7684\u672a\u77e5\u90e8\u5206\uff08\u53d8\u91cf\u504f\u79fb\u91cf\u6216\u6807\u91cf * \u503c\uff09\u6807\u8bb0\u4e3a\u5df2\u77e5\u503c @imm\u3002 */ static void __mark_reg32_known ( struct bpf_reg_state *reg, u64 imm ) { reg - &gt;var_off = tnum_const_subreg (reg - &gt;var_off , imm ) ; reg - &gt;s32_min_value = (s32 )imm ; reg - &gt; value.imm ; reg - &gt;s32_s3_s3_s32 .....", "note_en": "At  Grapl we believe that in order to build the best defensive system we need to deeply understand attacker behaviors. As part of that goal we&#39;re investing in offensive security research.  Keep up with our blog for new research on high risk vulnerabilities, exploitation, and advanced threat tactics.\n    Find the released local privilege escalation (LPE) Proof-of-Concept for  CVE-2021-3490 here:  https://github.com/chompie1337/Linux_LPE_eBPF_CVE-2021-3490. It targets Ubuntu 20.10 (Groovy Gorilla) kernels 5.8.0-25.26 through 5.8.0-52.58. and Ubuntu 21.04 (Hirsute Hippo) 5.11.0-16.17.\n    This blog post is intended to give a detailed overview of eBPF from the perspective of an exploit developer. In this post, I cover:\n     I had no knowledge of eBPF going into this. My hope is that by sharing a PoC as well as my experience developing it, it can help others get started with eBPF exploitation.\n                  Berkeley Packet Filter (BPF) was initially created as a way to perform packet filtering in the kernel. Its capabilities were later redesigned and extended to create extended Berkeley Packet Filter (eBPF)  [1].\n    Put simply, eBPF provides a way for a user mode application to run code in the kernel without needing to write a kernel module.The purported benefits of using eBPF versus a kernel module are ease of use, stability, and security. There are also performance improvements gained by doing certain tasks directly in the kernel compared to a pure user mode program. eBPF programs are used to do a myriad of things such as: tracing, instrumentation, hooking system calls, debugging, and of course, packet capturing/filtering.\n    eBPF programs are written in a high level language and compiled into eBPF bytecode using a toolchain (such as  BCC   [18]). The eBPF VM uses a simple instruction set that uses eleven* 64-bit registers, a program counter, and a 512 byte fixed-size stack. Nine registers are general purpose read-write, one is a read-only stack pointer and the program counter is implicit  [2] . The instruction set is similar to x86, and operates on both 64 and 32 bit values.\n          *Technically, it uses   12 registers,  but the 12th register is an auxiliary register only used to perform ALU sanitation operations   [12].\n  A user mode application loads the bytecode into the kernel using the   bpf()    [14] syscall, where the eBPF verifier will perform a number of checks to ensure the program is \u201csafe\u201d to run in the kernel. This verification step is critical - eBPF exposes a path for unprivileged users to execute in ring0.\n    After the program is loaded, the user mode application attaches the program to a \u201chook point\u201d. A hook point is a place in the kernel where eBPF programs can be attached  [5]. eBPF programs are event driven, meaning the program will execute when certain events occur at the hook point. The classic use case is attaching an eBPF program to a socket, where the program will execute when data is written to it.\n    If the   kconfig knob   CONFIG_BPF_JIT is set, the eBPF program is JIT compiled into native assembly instructions after it is verified and loaded. Otherwise, when the program is executed it is run in the eBPF interpreter which decodes and executes the eBPF bytecode instructions.\n  User mode applications can interact with and get data from the eBPF program running in the kernel using eBPF maps and eBPF helper functions, which are accessed via the    bpf()  syscall.\n      The     sysctl   knob    kernel.unprivileged_bpf_disabled  determines whether unprivileged users are allowed to run eBPF programs. If it is not set, unprivileged users are allowed to attach an eBPF program to a socket that the user owns. In many Linux distributions, such as Ubuntu,    unprivileged_bpf_disabled  is not enabled by default. Because of this, I decided to look into eBPF more closely, as allowing unprivileged users to run code in the kernel is a ripe attack surface.\n    I mentioned above that user mode processes can interact with a eBPF program in the kernel using eBPF maps. They can also be used by multiple eBPF programs to interact with each other. They are a generic key/value store with an arbitrary data structure  [6]. There are various types of maps including: arrays, queues, and stacks.\n      key_size  - the size in bytes of the key used to index an element (used in array maps)\n   map_flags  - describes special characteristics of the map, such as if the entire map memory should be preallocated or not.\n eBPF maps can be created and altered from user space via the    bpf()  syscall using the    BPF_MAP_CREATE  command, updated using the    BPF_MAP_UPDATE_ELEM  command, and retrieve its contents using the    BPF_MAP_LOOKUP_ELEM  command. eBPF maps can accessed by eBPF programs using the file descriptor returned by    BPF_MAP_CREATE  and calling eBPF helper functions, which will return pointers to values within the map.\n      The exploit I wrote leverages a bug in the eBPF verifier. So before I delve into the vulnerability it is important to briefly explain the internals of the verifier.\n    The verifier starts by building a control flow graph of the program. Then, it will verify each instruction is valid and all memory accesses are safe through each possible flow of control  [3]. Afterwards, it will add in runtime checks to the program. This process, called  ALU Sanitation, inserts patches to the eBPF bytecode to ensure permitted memory ranges are not violated during runtime when performing pointer arithmetic  [4].\n      No pointer comparisons can be performed, and only scalar values can be added or subtracted to a pointer. A scalar value in the eBPF verifier is any value that is not derived from a pointer. The verifier keeps track of which registers contain pointers and which contain scalar values.\n Pointer arithmetic can not leave the \u201csafe\u201d bounds of a map. Meaning, the program can not access anything outside the predefined map memory. To do so, verifier keeps track of the upper and lower bounds of the values for each register.\n No pointers can be stored in maps or stored as a return value, in order to avoid leaking kernel addresses to user space.\n     The verifier stores the following bound values, for every register in each possible path of execution, to ensure there are no out-of-bound memory accesses:\n  umin_value ,    umax_value  store the min/max value of the register when interpreted as an unsigned (64 bit) integer\n smin_value ,   smax_value  store the min/max value of the register when interpreted as a signed (64 bit) integer.\n u32_min_value ,   u32min_value  store the min/max value of the register when interpreted as an unsigned (32 bit) integer.\n s32_min_value ,   s32_max_value  store the min/max value of the register when interpreted as a signed (32 bit) integer.\n var_off  contains information about the bits of the the register that are known. It is stored in a structure called    tnum  which contains two 64 bit fields:    mask  and    value . Every bit that is set in    mask  means the value of that bit is  unknown. The unset bits are known, and their true value are stored in    value . For example, if    var_off = {mask = 0x0; value = 0x1} , all bits of the register are known, and the register is known to have a value of 1. If    var_off = {mask = 0xFFFFFFFF00000000; value = 0x3}  it means that the lower 32 bits of the register are known to be 0x00000003 and the upper 32 bits are unknown.\n These bounds are used to update each other. In particular, if    var_off  indicates the register is a known constant, the min/max bounds are updated to reflect the known value. We will see why this is important later!\n      ALU Sanitation is a feature that was introduced to supplement the static range tracking of the verifier. The idea is to prevent OOB memory accesses if the value of registers do not fall within their expected range during runtime. This was added to help mitigate potential vulnerabilities in the verifier and protect against speculative attacks.\n  For every arithmetic operation that involves a pointer and a scalar register, an    alu_limit  is calculated. This represents the maximum absolute value that can be added to or subtracted from the pointer  [4]. Before each of these operations, the bytecode is patched with the following instructions:\n  *patch ++  =  BPF_MOV32_IMM ( BPF_REG_AX , aux - &gt;alu_limit ) ; *patch ++  =  BPF_ALU64_REG ( BPF_SUB ,  BPF_REG_AX , off_reg ) ; *patch ++  =  BPF_ALU64_REG ( BPF_OR ,  BPF_REG_AX , off_reg ) ; *patch ++  =  BPF_ALU64_IMM ( BPF_NEG ,  BPF_REG_AX ,  0 ) ; *patch ++  =  BPF_ALU64_IMM ( BPF_ARSH ,  BPF_REG_AX ,  63 ) ; *patch ++  =  BPF_ALU64_REG ( BPF_AND ,  BPF_REG_AX , off_reg ) ;\n    Note that    off_reg  represents the scalar register being added to the pointer register, and    BPF_REG_AUX  represents the auxiliary register.\n      The value of    off_reg  at runtime is subtracted from    alu_limit  and stored into    BPF_REG_AX . If    off_reg &gt; alu_limit , the highest bit of    BPF_REG_AX  is set (the sign bit).\n If the difference stored in    BPF_REG_AUX  is positive and off_reg is negative, indicating that    alu_limit  and the register\u2019s value have opposing signs, the    BPF_OR  operation will set the sign bit.\n The    BPF_NEG  operation will negate the sign bit. If the sign bit is set, it will become 0, and if not, it will become 1.\n The    BPF_ARSH  operation does an arithmetic right shift of 63 bits. This fills    BPF_REG_AX  with either all 0s or 1s, the value of the sign bit.\n Depending on the result of the above operation, the    BPF_AND  operation will either null out    off_reg  or leave it unchanged.\n This means that if    off_reg  exceeds    alu_limit , or if    off_reg  and    alu_limit  have opposing signs, the value of    off_reg  will be replaced with 0, nulling the pointer arithmetic operation.\n        The way    alu_limit  is calculated was  recently updated  [15]. The new implementation may not have been adopted yet by some Linux distributions. For completeness, I will cover both, and revisit why the differences matter as they become relevant in the next sections.\n      The    alu_limit  is determined by the boundaries of the  pointer register. Meaning, if the pointer register points to the beginning of a map, the    alu_limit  for subtraction is 0, and the alu_limit for addition is equal to the size of the map (minus 1). The    alu_limit  is updated with subsequent operations on the pointer register.\n      The    alu_limit  is determined by the boundaries of the  offset register. Meaning if the value of the offset register at runtime is compared against the register\u2019s boundaries computed during the verifier\u2019s static range tracking.\n    My initial knowledge of the eBPF verifier came from this excellent   blog post  by Manfred Paul detailing his exploitation of CVE-2020-8835. I highly recommend checking it out!\n      Recall that the eBPF instruction set can operate on both the entire 64 bits of registers or just the lower 32 bits. For this reason, the verifier range tracking contains separate bounds for the lower 32 bits of a register:    {u,s}32_{min,max}_value .\n  These bounds are updated for every operation. Each operation has two tracking functions with a 64 bit and a 32 bit counter part. Both are called for a 64 bit operation in the function   adjust_scalar_min_max_vals  .\n  * /* WARNING: This function does calculations on 64-bit values, but * the actual execution may occur on 32-bit values. Therefore, * things like bitshifts need extra checks in the 32-bit case.*/ static int  adjust_scalar_min_max_vals ( struct bpf_verifier_env *env, struct bpf_insn *insn, struct bpf_reg_state *dst_reg, struct bpf_reg_state src_reg ) { ...  case  BPF_AND : dst_reg - &gt;var_off  =  tnum_and (dst_reg - &gt;var_off , src_reg .var_off ) ;  scalar32_min_max_and (dst_reg ,  &amp;src_reg ) ;  scalar_min_max_and (dst_reg ,  &amp;src_reg ) ;  break ;  case  BPF_OR : dst_reg - &gt;var_off  =  tnum_or (dst_reg - &gt;var_off , src_reg .var_off ) ;  scalar32_min_max_or (dst_reg ,  &amp;src_reg ) ;  scalar_min_max_or (dst_reg ,  &amp;src_reg ) ;  break ;  case  BPF_XOR : dst_reg - &gt;var_off  =  tnum_xor (dst_reg - &gt;var_off , src_reg .var_off ) ;  scalar32_min_max_xor (dst_reg ,  &amp;src_reg ) ;  scalar_min_max_xor (dst_reg ,  &amp;src_reg ) ;  break ;  ... }\n    The bug,  CVE-2021-3490, is found in the 32 bit tracking function for    BPF_AND ,    BPF_OR , and    BPF_XOR  operations. It is the same in each of the functions.\n    Let\u2019s take a look at an excerpt of the  offending code for    BPF_AND :\n  static  void  scalar32_min_max_and ( struct bpf_reg_state *dst_reg, struct bpf_reg_state *src_reg ) { bool src_known  =  tnum_subreg_is_const (src_reg - &gt;var_off ) ; bool dst_known  =  tnum_subreg_is_const (dst_reg - &gt;var_off ) ; struct tnum var32_off  =  tnum_subreg (dst_reg - &gt;var_off ) ; s32 smin_val  = src_reg - &gt;s32_min_value ; u32 umax_val  = src_reg - &gt;u32_max_value ;  /* Assuming scalar64_min_max_and will be called so its safe * to skip updating register for known 32-bit case. */  if  (src_known  &amp;&amp; dst_known )  return ; ... }\n    As shown in the code snippet above, if the lower 32 bits of both the source and destination register are known, the function skips updating the 32 bit bounds.\n    The comment above the return states that this is OK, because the  64 bit  counterpart will take care of it. Let\u2019s take a look:\n  static  void  scalar_min_max_and ( struct bpf_reg_state *dst_reg, struct bpf_reg_state *src_reg ) { bool src_known  =  tnum_is_const (src_reg - &gt;var_off ) ; bool dst_known  =  tnum_is_const (dst_reg - &gt;var_off ) ; s64 smin_val  = src_reg - &gt;smin_value ; u64 umin_val  = src_reg - &gt;umin_value ;  if  (src_known  &amp;&amp; dst_known )  {  __mark_reg_known (dst_reg , dst_reg - &gt;var_off .value ) ;  return ;  }  ... }\n  Indeed, we can see if    src_known  and    dst_known  are true, the function    __mark_reg_known  will be called. Can you spot the problem?\n    In    scalar32_min_max_and , the    _known  variable is calculated using    tnum_subreg_is_const  . The 64 bit counterpart,    scalar_min_max_and , uses    tnum_is_const . The difference is that the former returns true if the the lower 32 bits of the register are known constants, and the latter returns true only if the entire 64 bits are constant. If the operation involves registers where the lower 32 bits are known but the upper 32 bits are unknown, the assumption stated in the comment is violated.\n    In the function    adjust_scalar_min_max_vals , before returning, the bounds of the destination register are updated a last time by calling the  following three functions:\n    Each of these functions have 32 and 64 bit counterparts. I\u2019ll just cover the 32 bit case, since that is what the bug affects.\n      static  void  __update_reg32_bounds ( struct bpf_reg_state *reg ) { struct tnum var32_off  =  tnum_subreg (reg - &gt;var_off ) ;  /* min signed is max(sign bit) | min(other bits) */ reg - &gt;s32_min_value  =  max_t (s32 , reg - &gt;s32_min_value , var32_off .value  |  (var32_off .mask  &amp;  S32_MIN ) ) ;  /* max signed is min(sign bit) | max(other bits) */ reg - &gt;s32_max_value  =  min_t (s32 , reg - &gt;s32_max_value , var32_off .value  |  (var32_off .mask  &amp;  S32_MAX ) ) ; reg - &gt;u32_min_value  =  max_t (u32 , reg - &gt;u32_min_value ,  (u32 )var32_off .value ) ; reg - &gt;u32_max_value  =  min (reg - &gt;u32_max_value ,  (u32 ) (var32_off .value  | var32_off .mask ) ) ; }\n    Notice that the min bounds set to either the current min or the known value of register, whichever is larger. Similarly, the max bounds are set either the current max, or the known value of the register, whichever is smaller.\n  Then, the signed and unsigned bounds are used to update each other in   __reg32_deduce_bounds  .\n  /* Uses signed min/max values to inform unsigned, and vice-versa */ static  void  __reg32_deduce_bounds ( struct bpf_reg_state *reg ) {  /* Learn sign from signed bounds. * If we cannot cross the sign boundary, then signed and * unsigned bounds * are the same, so combine. This works even in the * negative case, e.g. * -3 s&lt;= x s&lt;= -1 implies 0xf...fd u&lt;= x u&lt;= 0xf...ff. */  if  (reg - &gt;s32_min_value  &gt;=  0  || reg - &gt;s32_max_value  &lt;  0 )  { reg - &gt;s32_min_value  = reg - &gt;u32_min_value  =  max_t (u32 , reg - &gt;s32_min_value , reg - &gt;u32_min_value ) ; reg - &gt;s32_max_value  = reg - &gt;u32_max_value  =  min_t (u32 , reg - &gt;s32_max_value , reg - &gt;u32_max_value ) ;  return ;  } ... }\n      static  void  __reg_bound_offset ( struct bpf_reg_state *reg ) { struct tnum var64_off  =  tnum_intersect (reg - &gt;var_off ,  tnum_range (reg - &gt;umin_value , reg - &gt;umax_value ) ) ; struct tnum var32_off  =  tnum_intersect ( tnum_subreg (reg - &gt;var_off ) , tnum_range (reg - &gt;u32_min_value , reg - &gt;u32_max_value ) ) ; reg - &gt;var_off  =  tnum_or ( tnum_clear_subreg (var64_off ) , var32_off ) ; }\n    tnum_intersect  takes two    tnum s and combines the knowledge conveyed by both into a single    tnum .\n Let\u2019s go through the steps using an example so we can understand why this is a critical vulnerability.\n  Suppose we have the instruction   BPF_ALU64_REG(BPF_AND, R2, R3). This instruction performs an   AND operation on registers   R2 and   R3 and saves the results in   R2.\n  R2 has   var_off = {mask = 0xFFFFFFFF00000000; value = 0x1}, meaning the lower 32 bits are known to have a value of 1, and the upper 32 bits are unknown. Because the lower 32 bits of the register are known, its 32bit bounds are equal to the value.\n R3 has   var_off = {mask = 0x0; value = 0x100000002}, meaning the entire 64 bits are known and equal to   0x100000002.\n   As shown on line 12 of the snippet of   adjust_scalar_min_max_vals, the function   tnum_and is called. This will perform an AND operation and save the results in var_off of the destination register,   R2. Recall, the lower 32 bits in both of the registers are known. All of the bits of R3 are known: the upper 31 bits of are 0, and the 32nd bit is 1. This means that    R2  is left with    var_off = {mask = 0x100000000; value = 0x0} . This is because 2 &amp; 1 = 0 (for the lower 32 bits), and all but the 32nd bit will be known to be 0, since    R3  has a 1 in the 32nd bit.\n On the next line,    scalar32_min_max_and  is called. We already know that this function will return immediately and make no changes to the bounds, because the lower 32 bits of both registers are known.\n Then    __update_reg32_bounds  is called. This will set    u32_max_value = 0 , because the value of    var_off.value = 0 &lt; u32_max_value = 1 . Similarly, it will set    u32_min_value = 1  because    var_off.value = 0 &lt; u32_min_value . The same goes for the signed bounds.\n Now we can see that in this case, we are left with a register where    {u,s}32_max_value = 0 &lt; {u,s}32_min_value = 1 !\n      @@  - 7084 , 11  + 7084 , 10 @@  static  void  scalar32_min_max_and (struct bpf_reg_state  *dst_reg , s32 smin_val  = src_reg - &gt;s32_min_value ; u32 umax_val  = src_reg - &gt;u32_max_value ;  -  /* Assuming scalar64_min_max_and will be called so its safe- * to skip updating register for known 32-bit case.- */ -  if  (src_known  &amp;&amp; dst_known ) +  if  (src_known  &amp;&amp; dst_known )  { +  __mark_reg32_known (dst_reg , var32_off .value ) ;  return ; +  }\n    Above we can see that now,   __mark_reg32_known  is called on the destination register before returning if the lower 32 bits of the source and destination register are known constants.\n    /* Mark the unknown part of a register (variable offset or scalar * value) as known to have the value @imm.*/ static  void  __mark_reg32_known ( struct bpf_reg_state *reg, u64 imm ) { reg - &gt;var_off  =  tnum_const_subreg (reg - &gt;var_off , imm ) ; reg - &gt;s32_min_value  =  (s32 )imm ; reg - &gt;s32_max_value  =  (s32 )imm\n......", "posttime": "2021-08-09 00:55:07", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "\u7834\u89e3,ebpf,pwning,bpf", "title": "\u4f7f\u7528 eBPF \u8fdb\u884c\u5185\u6838\u7834\u89e3\uff1a\u4e00\u4e2a\u7231\u60c5\u6545\u4e8b", "title_en": "Kernel Pwning with eBPF: A Love Story", "transed": 1, "url": "https://www.graplsecurity.com/post/kernel-pwning-with-ebpf-a-love-story", "via": "", "real_tags": ["\u7834\u89e3", "ebpf", "pwning", "bpf"]}, {"category": "", "categoryclass": "", "imagename": "", "infoid": 1072141, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "Wildfire Games \u81ea\u8c6a\u5730\u5ba3\u5e03\u53d1\u5e03 0AD Alpha 25\uff1a\u201cYaun\u00e3\u201d\uff0c\u8fd9\u662f 0 AD \u7684\u7b2c 25 \u4e2a Alpha \u7248\u672c\uff0c\u8fd9\u662f\u4e00\u6b3e\u514d\u8d39\u3001\u5f00\u6e90\u7684\u53e4\u4ee3\u6218\u4e89\u5b9e\u65f6\u6218\u7565\u6e38\u620f\u3002 Yaun\u00e3 \u662f\u53e4\u6ce2\u65af\u8bed\u4e2d\u7231\u5965\u5c3c\u4e9a\u4eba\uff08\u5e0c\u814a\u4eba\uff09\u7684\u8bcd\u3002\u8ba2\u5355\u91cd\u7ec4\u2014\u2014\u73a9\u5bb6\u73b0\u5728\u53ef\u4ee5\u5c06\u65b0\u8ba2\u5355\u63a8\u5230\u751f\u4ea7\u961f\u5217\u7684\u524d\u9762 0 AD \u662f\u514d\u8d39\u8f6f\u4ef6\u3002\u8fd9\u610f\u5473\u7740\u60a8\u53ef\u4ee5\u5728\u76f8\u540c\u7684\u8bb8\u53ef\u4e0b\u514d\u8d39\u4e0b\u8f7d\u3001\u91cd\u65b0\u5206\u53d1\u3001\u4fee\u6539\u548c\u8d21\u732e\u5e94\u7528\u7a0b\u5e8f\uff1a\u7528\u4e8e\u4ee3\u7801\u7684 GNU \u516c\u5171\u8bb8\u53ef\u7248\u672c 2 (GPL v2) \u548c\u7528\u4e8e\u827a\u672f\u4f5c\u54c1\u7684\u77e5\u8bc6\u5171\u4eab\u7f72\u540d\u76f8\u540c\u65b9\u5f0f\u5171\u4eab 3.0 (CC-BY-SA 3.0) .\u5c3d\u7ba1\u60a8\u53ef\u80fd\u4f1a\u53d1\u73b0\u6709\u4e9b\u4eba\u901a\u8fc7\u4e92\u8054\u7f51\u6216\u7269\u7406\u5a92\u4f53\u51fa\u552e 0 AD \u7684\u526f\u672c\uff0c\u4f46\u60a8\u59cb\u7ec8\u53ef\u4ee5\u9009\u62e9\u76f4\u63a5\u4ece\u5f00\u53d1\u4eba\u5458\u5904\u5b8c\u5168\u514d\u8d39\u4e0b\u8f7d 0 AD\u3002\u6ca1\u6709\u201c\u514d\u8d39\u589e\u503c\u201d\u6a21\u5f0f\uff0c\u6ca1\u6709\u6e38\u620f\u5185\u5e7f\u544a\uff0c\u6ca1\u6709\u6355\u83b7\u3002", "note_en": "Wildfire Games proudly announces the release of 0AD Alpha 25: \u201cYaun\u00e3,\u201d the twenty-fifth alpha version of 0 A.D., a free, open-source real-time strategy game of ancient warfare.\u00a0Yaun\u00e3 is an\u00a0old Persian word for Ionians (Greeks).\n     Order Restructuring \u2013 Players Can Now Push New Orders To The Front Of Their Production Queues\n   0 A.D. is free software. This means you are free to download, redistribute, modify and   contribute \u00a0to the application under the same licences: GNU Public Licence version 2 (GPL v2) for code and Creative Commons Attribution Share-Alike 3.0 (CC-BY-SA 3.0) for artwork.\n Although you might find some people selling copies of 0 A.D., either over the internet or on physical media, you will always have the option to   download 0 A.D. \u00a0completely gratis, directly from the developers. No \u201cfreemium\u201d model, no in-game advertising, no catch.", "posttime": "2021-08-09 00:54:51", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "ad,alpha", "title": "0 AD \u963f\u5c14\u6cd5 25\uff1aYaun\u0101", "title_en": "0 A.D. Alpha 25: Yaun\u0101", "transed": 1, "url": "https://play0ad.com/new-release-0-a-d-alpha-25-yauna/", "via": "", "real_tags": ["ad", "alpha"]}, {"category": "", "categoryclass": "", "imagename": "f1ac3d2c9a9eb77da56b61f928e0d7a6.png", "infoid": 1072140, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "\u636e\u62a5\u9053\uff0c\u652f\u4ed8\u670d\u52a1\u516c\u53f8 Xsolla \u89e3\u96c7\u4e86 150 \u540d\u5458\u5de5\uff0c\u6839\u636e\u5bf9\u5176\u6d3b\u52a8\u7684\u5927\u6570\u636e\u5206\u6790\uff08\u901a\u8fc7 Game World Observer\uff09\uff0c\u8be5\u516c\u53f8\u4f4d\u4e8e\u4fc4\u7f57\u65af\u5f7c\u5c14\u59c6\u7684\u529e\u516c\u5ba4\u7684\u5458\u5de5\u88ab\u89e3\u96c7\u3002\u66f4\u7cdf\u7cd5\u7684\u662f\uff0cXsolla \u7684\u9996\u5e2d\u6267\u884c\u5b98\u517c\u521b\u59cb\u4eba Aleksandr Agapitov \u5411\u53d7\u5f71\u54cd\u7684\u5458\u5de5\u53d1\u9001\u4e86\u4e00\u5c01\u7535\u5b50\u90ae\u4ef6\uff0c\u89e3\u91ca\u4e86\u8fd9\u4e00\u51b3\u5b9a\uff0c\u5e76\u900f\u9732\u4ed6\u4eec\u5df2\u88ab\u89e3\u96c7\uff0c\u56e0\u4e3a\u4ed6\u4eec\u88ab\u6807\u8bb0\u4e3a\u201c\u4e0d\u656c\u4e1a\u4e14\u6548\u7387\u4f4e\u4e0b\u7684\u5458\u5de5\u201d\u3002 \u201c\u60a8\u6536\u5230\u8fd9\u5c01\u7535\u5b50\u90ae\u4ef6\u662f\u56e0\u4e3a\u6211\u7684\u5927\u6570\u636e\u56e2\u961f\u5206\u6790\u4e86\u60a8\u5728 Jira\u3001Confluence\u3001Gmail\u3001\u804a\u5929\u3001\u6587\u6863\u3001\u4eea\u8868\u677f\u4e2d\u7684\u6d3b\u52a8\uff0c\u5e76\u5c06\u60a8\u6807\u8bb0\u4e3a\u4e0d\u656c\u4e1a\u4e14\u6548\u7387\u4f4e\u4e0b\u7684\u5458\u5de5\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u5f53\u60a8\u8fdc\u7a0b\u5de5\u4f5c\u65f6\uff0c\u60a8\u5e76\u4e0d\u603b\u662f\u5728\u5de5\u4f5c\u573a\u6240\u3002 \u201c\u4f60\u4eec\u4e2d\u7684\u8bb8\u591a\u4eba\u53ef\u80fd\u4f1a\u611f\u5230\u9707\u60ca\uff0c\u4f46\u6211\u771f\u7684\u76f8\u4fe1 Xsolla \u4e0d\u9002\u5408\u4f60\u4eec\u3002 Nadia \u548c\u5979\u7684\u62a4\u7406\u56e2\u961f\u4e0e\u4e03\u5bb6\u9886\u5148\u7684\u4eba\u529b\u8d44\u6e90\u673a\u6784\u5408\u4f5c\uff0c\u56e0\u4e3a\u6211\u4eec\u5c06\u5e2e\u52a9\u60a8\u627e\u5230\u4e00\u4e2a\u597d\u5730\u65b9\uff0c\u5728\u90a3\u91cc\u60a8\u8d5a\u5f97\u66f4\u591a\uff0c\u5de5\u4f5c\u66f4\u5c11\u3002 Sasha \u5c06\u5e2e\u52a9\u60a8\u83b7\u5f97\u63a8\u8350\uff0c\u5305\u62ec\u6211\u81ea\u5df1\u7684\u63a8\u8350\u3002 Natalia \u4f1a\u4e3a\u60a8\u89e3\u8bfb\u60a8\u7684\u6743\u5229\u3002 \u201c\u518d\u6b21\u611f\u8c22\u60a8\u7684\u8d21\u732e\u3002\u5982\u679c\u4f60\u60f3\u548c\u6211\u4fdd\u6301\u8054\u7cfb\uff0c\u8bf7\u7ed9\u6211\u5199\u4e00\u5c01\u957f\u4fe1\uff0c\u628a\u4f60\u6240\u6709\u7684\u89c2\u5bdf\u3001\u4e0d\u516c\u548c\u611f\u6fc0\u3002\u201d\u8fd9\u7acb\u5373\u5f15\u53d1\u4e86\u53ef\u9884\u89c1\u7684\u53cd\u5f39\uff1a\u65e0\u8bba\u662f\u88c1\u5458\u672c\u8eab\u8fd8\u662f\u7535\u5b50\u90ae\u4ef6\u7684\u8bed\u6c14\u3002\u636e ProPerm.ru \u79f0\uff0c\u8be5\u516c\u53f8\u6b63\u5728\u8c03\u67e5\u5bfb\u627e\u6cc4\u9732\u7535\u5b50\u90ae\u4ef6\u7684\u5458\u5de5\u3002\u88c1\u5458\u540e\uff0c\u963f\u52a0\u76ae\u6258\u592b\u53ec\u5f00\u4e86\u4e00\u6b21\u65b0\u95fb\u53d1\u5e03\u4f1a\uff0c\u4ed6\u89e3\u91ca\u8bf4\uff0c\u5927\u89c4\u6a21\u88c1\u5458\u662f\u7531\u4e8e\u516c\u53f8\u5df2\u505c\u6b62\u663e\u793a 40% \u7684\u589e\u957f\u3002\u963f\u52a0\u76ae\u6258\u592b\u63d0\u4f9b\u4e86\u66f4\u591a\u7ec6\u8282\uff0c\u5305\u62ec\u4e0b\u5c97\u5458\u5de5\u603b\u6570\u53ef\u80fd\u5360\u516c\u53f8\u6240\u6709\u529e\u516c\u5ba4\u5458\u5de5\u603b\u6570\u7684 40%\u3002\n\u5728\u65b0\u95fb\u53d1\u5e03\u4f1a\u4e4b\u540e\uff0c\u963f\u52a0\u76ae\u6258\u592b\u901a\u8fc7\u4e00\u6761\u63a8\u6587\u5f15\u53d1\u4e86\u8fdb\u4e00\u6b65\u7684\u4e89\u8bae\uff0c\u63a8\u6587\u5927\u81f4\u7ffb\u8bd1\u4e3a\u201c\u8ba9\u4f60\u4ed6\u5988\u7684\u5c41\u80a1\u6eda\u5f00\uff0c\u6216\u8005\u8ba9\u4f60\u4ed6\u5988\u7684\u5c41\u80a1\u6eda\u51fa\u53bb\u3002\u201d\u963f\u52a0\u76ae\u6258\u592b\u5728\u63a5\u53d7\u300a\u798f\u5e03\u65af\u4fc4\u7f57\u65af\u300b\u91c7\u8bbf\u65f6\u900f\u9732\uff0c\u5728\u4e0e\u7ecf\u7406\u8ba8\u8bba\u540e\uff0c60 \u540d\u53d7\u5f71\u54cd\u7684\u5458\u5de5\u53ef\u80fd\u4f1a\u7559\u5728\u516c\u53f8\uff0c\u800c\u88ab\u89e3\u96c7\u7684\u5458\u5de5\u5c06\u4fdd\u7559\u533b\u7597\u4fdd\u9669\uff0c\u5e76\u83b7\u5f97\u76f8\u5f53\u4e8e\u56db\u5230\u516d\u4e2a\u6708\u5de5\u8d44\u7684\u533b\u7597\u5de5\u8d44\u3002", "note_en": "Payment services company Xsolla has reportedly fired 150 of its employees, with workers in the company\u2019s office in Perm, Russia being terminated based on big data analysis of their activity (via  Game World Observer).\n Making the situation worse, Xsolla CEO and founder Aleksandr Agapitov sent an email to the affected employees explaining the decision, revealing that they had been let go because they had been tagged as \u201cunengaged and unproductive employees.\u201d\n   \u201cYou received this email because my big data team analyzed your activities in Jira, Confluence, Gmail, chats, documents, dashboards and tagged you as unengaged and unproductive employees. In other words, you were not always present at the workplace when you worked remotely.\n \u201cMany of you might be shocked, but I truly believe that Xsolla is not for you. Nadia and her care team partnered with seven leading HR agencies, as we will help you find a good place, where you will earn more and work even less. Sasha will help you get a recommendation, including the one from myself. And Natalia will read you your rights.\n \u201cOnce again, thank you for your contribution. If you want to stay in contact with me, please write me a long letter about all your observations, injustice, and gratitude.\u201d\n This prompted immediate and predictable backlash: both for the layoffs themselves and for the tone of the email. According to  ProPerm.ru, the company is investigating to find the employee who leaked the email.\n Following the layoffs, Agapitov held a press conference in which he explained that the mass layoffs were caused by the fact that the company has stopped showing 40% growth. Agapitov provided further details, including that the total number of laid-off employees could total 40% of the company\u2019s headcount across all of its offices.\n Following the press conference, Agapitov incited further controversy with a  Tweet that roughly translates to \u201cWork your fucking ass off or get your fucking ass out.\u201d\n Speaking with  Forbes Russia, Agapitov revealed that 60 of the affected employees might stay with the company following discussions with their managers, while those who have been let go will keep their medical insurance and receive medical pay equal to four to six monthly salaries.", "posttime": "2021-08-09 00:54:30", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "\u5927\u6570\u636e,\u6570\u636e\u5206\u6790,based,\u5458\u5de5", "title": "\u827e\u514b\u7d22\u62c9\u57fa\u4e8e\u5bf9\u5176\u6d3b\u52a8\u7684\u5927\u6570\u636e\u5206\u6790\u89e3\u96c7\u4e86 150 \u540d\u5458\u5de5", "title_en": "Xsolla fires 150 employees based on big data analysis of their activity", "transed": 1, "url": "https://www.mcvuk.com/business-news/xsolla-fires-150-employees-based-on-big-data-analysis-of-their-activity-many-of-you-might-be-shocked-but-i-truly-believe-that-xsolla-is-not-for-you/", "via": "", "real_tags": ["\u5927\u6570\u636e", "\u6570\u636e\u5206\u6790", "based", "\u5458\u5de5"]}, {"category": "", "categoryclass": "", "imagename": "6d4fe6117029a98c7aa66fe2542b07c2.png", "infoid": 1072138, "ip": "", "isanchordig": 1, "ischecked": 1, "isdelete": 0, "isneo": 1, "mark": "", "name": "", "note": "\u590f\u5b63\u7684\u4e09\u4f0f\u5929\u5df2\u7ecf\u5230\u6765\uff0c\u672c\u5468\u5e02\u573a\uff08\u80a1\u7968\u3001\u503a\u52a1\u3001\u5546\u54c1\u5e02\u573a\uff09\u51e0\u4e4e\u6ca1\u6709\u53d8\u52a8\uff0c\u82f1\u56fd\u300a\u91d1\u878d\u65f6\u62a5\u300b\u7684\u64b0\u7a3f\u4eba\u601d\u8003\u5982\u4f55\u5728\u80a1\u7968\u548c\u5546\u54c1\u5e02\u573a\u65e0\u7cbe\u6253\u91c7\u7684\u60c5\u51b5\u4e0b\u5ea6\u8fc7\u4ed6\u4eec\u7684\u4e00\u5929\u3002\u968f\u610f\u7684\u60f3\u6cd5\u6293\u4f4f\u4e86\u65e0\u804a\u7684\u65f6\u523b\u3002\u751a\u81f3\u300a\u91d1\u878d\u65f6\u62a5\u300b\u4e5f\u6682\u65f6\u7f29\u6c34\u4e86\uff1a\u672c\u5468\u6bcf\u5929 6 \u9875\uff0c\u4ece\u7ecf\u5178\u7684 12 \u9875\u51cf\u5c11\u4e86\u3002\u590f\u5929\u5230\u4e86\u3002\u5173\u4e8e\u5fb7\u56fd\u8d54\u507f\u7684\u4e89\u8bba\u4ecd\u5728\u7ee7\u7eed\u3002\u5728\u8fc7\u53bb\u7684\u4e00\u5e74\u91cc\uff0c\u82f1\u56fd\u548c\u6cd5\u56fd\u5df2\u7ecf\u6e05\u695a\uff0c\u5fb7\u56fd\u65e0\u6cd5\u5168\u989d\u652f\u4ed8\u3002 1921 \u5e74 8 \u6708 10 \u65e5\u5c31\u4e09\u4e2a\u6838\u5fc3\u95ee\u9898\u5c55\u5f00\u8c08\u5224\uff0c\u800c\u4e0d\u662f\u8fdd\u7ea6\uff1a\u5fb7\u56fd\u5411\u76ee\u524d\u5360\u9886\u5fb7\u56fd\u5730\u533a\u7684\u82f1\u56fd\u548c\u6cd5\u56fd\u58eb\u5175\u4ed8\u6b3e\u3001\u5b9e\u7269\uff08\u94a2\u3001\u7164\u3001\u6728\u6750\uff09\u8f6c\u79fb\u4ee3\u66ff\u5fb7\u56fd\u91d1\u9a6c\u514b\uff0c\u4ee5\u53ca\u627f\u62c5\u6218\u4e89\u503a\u52a1\u6b27\u6d32\u8f83\u5c0f\u7684\u56fd\u5bb6\u3002\u5386\u53f2\u4e8b\u5b9e\uff1a\u5fb7\u56fd\u5728\u7b2c\u4e00\u200b\u200b\u6b21\u4e16\u754c\u5927\u6218\u540e\u4f7f\u7528\u4e24\u79cd\u5e73\u884c\u8d27\u5e01\uff1a\u91d1\u9a6c\u514b\u548c\u7eb8\u5e01\u3002\u51e1\u5c14\u8d5b\u6761\u7ea6\u89c4\u5b9a\u4ee5\u91d1\u9a6c\u514b\u652f\u4ed8\uff0c\u8fd9\u9020\u6210\u4e86\u4e25\u91cd\u7684\u8d22\u653f\u538b\u529b\u3002 1920 \u5e74\u4ee3\u7684\u5fb7\u56fd\u5f53\u7136\u88ab\u79f0\u4e3a\u9b4f\u739b\u5171\u548c\u56fd\uff0c\u5e76\u5c06\u5728 9 \u6708\u5f00\u59cb\u7ecf\u5386\u4e25\u91cd\u7684\u901a\u8d27\u81a8\u80c0\uff0c\u8fd9\u79cd\u901a\u8d27\u81a8\u80c0\u4f1a\u6301\u7eed\u4e24\u5e74\u76f4\u5230\u91d1\u878d\u5d29\u6e83\u3002\u7ebd\u7ea6\u7684\u4ea4\u6613\u5458\u60f3\u77e5\u9053\u4ec0\u4e48\u53ef\u80fd\u4f1a\u6539\u53d8\u5e02\u573a\u3002 \u300a\u534e\u5c14\u8857\u65e5\u62a5\u300b\u7684\u7f16\u8f91\u4eec\u63a8\u6d4b\uff0c\u9ad8\u7a0e\u6536\u548c\u516c\u5171\u652f\u51fa\u6b63\u5728\u635f\u5bb3\u516c\u4f17\u5bf9\u62e5\u6709\u80a1\u7968\u7684\u770b\u6cd5\u3002\u4e0d\u65f6\u6709\u8db3\u591f\u52c7\u6562\u7684\u4eba\u5bf9\u4e0d\u53d7\u6b22\u8fce\u7684\u666e\u901a\u80a1\u53d1\u8868\u610f\u89c1\u3002\u6807\u51c6\u77f3\u6cb9\u516c\u53f8\u5728 1911 \u5e74\u88ab\u62c6\u5206\u4e3a\u8fd1\u4e09\u6253\u516c\u53f8\uff0c\u672c\u6587\u5217\u51fa\u4e86\u6240\u6709\u524d\u6210\u5206\u7684\u4ef7\u683c\u3002\u5c3d\u7ba1\u8fc7\u53bb\u4e00\u5e74\u8270\u96be\uff0c\u4f46 1921 \u5e74\u5df2\u7ecf\u663e\u793a\u51fa\u77f3\u6cb9\u89e6\u5e95\u7684\u8ff9\u8c61\u3002\u4f5c\u8005\u5efa\u8bae\u7cbe\u660e\u7684\u6295\u8d44\u8005\u8d2d\u4e70\u6240\u6709\u8fd9\u4e9b\u80a1\u7968\u3002\u6bcf\u5bb6\u516c\u53f8\u7684\u4ea4\u6613\u4ef7\u683c\u90fd\u4f4e\u4e8e\u8d26\u9762\u4ef7\u503c\uff01\u5e02\u76c8\u7387\u4ecb\u4e8e 3 \u5230 5 \u4e4b\u95f4\u3002\u63d0\u9192\u4e00\u4e0b\uff0c\u65e0\u98ce\u9669\u503a\u5238\u7684\u6536\u76ca\u7387\u4e3a 5%\uff0c\u79ef\u6781\u9f13\u52b1\u6563\u6237\u6295\u8d44\u8005\u4e0d\u8981\u6301\u6709\u80a1\u7968\u3002\u5386\u53f2\u4e8b\u5b9e\uff1a\u62a5\u7eb8\u4e0a\u5bf9\u666e\u901a\u80a1\u7684\u51b7\u6f20\u4f1a\u8ba9\u73b0\u4ee3\u6295\u8d44\u8005\u5782\u6d8e\u4e09\u5c3a\u3002\u5982\u679c\u4ece 1921 \u5e74\u5230\u73b0\u5728\uff0c\u4e70\u5165\u5e76\u6301\u6709\u9053\u743c\u65af\u6307\u6570\uff0c\u603b\u56de\u62a5\u5c06\u662f 500,000%\uff085,000 \u500d\uff09\uff01\u6839\u636e\u57c3\u514b\u68ee\u7f8e\u5b5a\u7684\u524d\u8eab\u65b0\u6cfd\u897f\u6807\u51c6\u77f3\u6cb9\u516c\u53f8\uff08\u62c6\u5206\u8c03\u6574\u540e\u7684 0.04 \u7f8e\u5143\uff09\uff0c\u8d2d\u4e70\u548c\u6301\u6709 100 \u5e74\u5c06\u76f8\u5f53\u4e8e 800,000% \u7684\u56de\u62a5\uff088,000 \u500d\uff09\uff01\u81f4\u6211\u4eec\u7684\u8bfb\u8005\uff1a\u5982\u679c\u4ec0\u4e48\u90fd\u4e0d\u505a\uff0c\u90a3\u4e48\u5728\u5f53\u65f6\u6295\u8d44\u4e8e\u5927\u76d8\u7684 100 \u7f8e\u5143\u4eca\u5929\u5c06\u4ef7\u503c 500,000 \u7f8e\u5143\uff01\u5728\u4eca\u5929\u7684\u6a21\u56e0\u80a1\u7968\u4e16\u754c\u4e2d\uff0c\u8fd9\u5982\u4f55\u6210\u4e3a\u5934\u6761\u65b0\u95fb\uff1f\n\u9605\u8bfb\u672c\u65f6\u4e8b\u901a\u8baf\u662f\u514d\u8d39\u7684\u3002\u5982\u679c\u60a8\u559c\u6b22\u5b83\uff0c\u8bf7\u5206\u4eab\u7ed9\u670b\u53cb\u6216\u901a\u8fc7 PayPal \u6350\u8d60\uff08\u4e0b\u9762\u7684\u6309\u94ae\uff09\u3002", "note_en": "Dog days of summer have arrived, bringing little to no movements in markets this week (equity, debt, commodity markets)\n  Writers at the FT ponder how to spend their day while equity and commodity markets vacillate listlessly. Random ideas captures the very moment of boredom. Even the Financial Times has temporarily shrunk: 6 pages per day this week down from the classic 12 pages. Summer has arrived.\n Wrangling over German reparations continues. Over the past year, it has become clear to Britain and France that Germany cannot pay in full. Instead of default, talks open on August 10, 1921 regarding three core issues: German payments to British and French soldiers currently occupying German regions, in kind (steel, coal, timber) transfers in lieu of German gold marks, and assumption of war debt of smaller European countries.\n Historical Fact: Germany operates two parallel currencies after WWI: the gold mark and paper mark. The Treaty of Versailles stipulates payment in gold marks, which is causing severe fiscal strain. The Germany of the 1920s is, of course, known as the Weimar Republic and will begin experiencing severe inflation in September that drags on for two years until financial implosion.\n Traders in New York wonder what might turn the market. The editors of the WSJ surmise that high taxation and public spending are harming public perception of owning equities.\n  Every now and then, someone brave enough offers their opinion on unpopular common stocks. Standard Oil was split into nearly three dozen companies in 1911, and this article lists the prices of all former constituents. Despite having a rough past year, 1921 has shown signs of an oil bottom. The writer recommends astute investors purchase shares in all of them. Every single company trades below book value! PE ratios range from 3 to 5. As a reminder, risk free bonds are yielding 5%, and retail investors are being actively encouraged not to own equities.\n  Historical Fact: The apathy in the papers regarding common stocks would make the modern day investor salivate. If one bought and held the Dow from 1921 to present, the total return would be 500,000% (5,000x)! Based on ExxonMobil\u2019s predecessor company Standard Oil of New Jersey ($0.04 split adjusted), buying and holding for 100 years would equate to an 800,000% return (8,000x)! To our readers: $100 invested in the broad market back then would be worth $500,000 today by doing  absolutely nothing! How\u2019s that for a headline in today\u2019s meme stock world?\n  Reading this newsletter is free. If you enjoy it, then please share to a friend or donate via PayPal (button below).", "posttime": "2021-08-09 00:53:52", "source_domain": "news.ycombinator.com", "source_name": "Hacker News", "tags": "\u534e\u5c14\u8857,\u91d1\u878d\u65f6\u62a5,ft,\u5fb7\u56fd", "title": "\u6211\u6bcf\u5468\u9605\u8bfb 100 \u5e74\u524d\u5230 1929 \u5e74\u7684\u82f1\u56fd\u300a\u91d1\u878d\u65f6\u62a5\u300b\u548c\u300a\u534e\u5c14\u8857\u65e5\u62a5\u300b", "title_en": "I'm reading the FT and WSJ from 100 years ago each week leading to 1929", "transed": 1, "url": "https://roaring20s.substack.com/p/august-8-1921", "via": "", "real_tags": ["\u534e\u5c14\u8857", "\u91d1\u878d\u65f6\u62a5", "ft", "\u5fb7\u56fd"]}]