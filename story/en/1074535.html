<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>尼克斯·弗莱克斯：导言Nix Flakes: An Introduction</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Nix Flakes: An Introduction<br/>尼克斯·弗莱克斯：导言</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-22 02:35:37</div><div class="page_narrow text-break page_content"><p>Nix is a package manager that lets you have a more deterministic view of yoursoftware dependencies and build processes. One if its biggest weaknesses out ofthe box is that there are very few conventions on how projects using Nix shouldwork together. It&#39;s like having a build system but also having to configuresystems to run software yourself. This could mean copying a NixOS module out ofthe project&#39;s git repo, writing your own or more. In contrast to this,  Nixflakes define a set of conventions for howsoftware can be build, run, integrated and deployed without having to rely onexternal tools such as  Niv or Lorri to help you do basic tasks in atimely manner.</p><p>Nix是一个软件包管理器，可以让您对软件依赖关系和构建过程有一个更确定的视图。其最大的缺点之一是，关于使用Nix的项目应该如何协同工作，几乎没有约定。它&#39；这就像有一个构建系统，但也必须配置系统来运行自己的软件。这可能意味着从项目中复制一个NixOS模块#39；s git repo，编写自己的或更多。与此相反，Nixflakes定义了一组约定，用于如何构建、运行、集成和部署软件，而无需依赖外部工具（如Niv或Lorri）来帮助您以轻松的方式完成基本任务。</p><p> This is going to be a series of posts that will build on eachother. This postwill be an introduction to Nix flakes and serve as a &#34;why should I care?&#34; styleoverview of what you can do with flakes without going into too much detail. Mostof these will get separate posts (some more than one post).</p><p>这将是一系列的帖子，它们将建立在彼此的基础上。这篇帖子将介绍Nix flakes，并作为&#34；我为什么要在乎&#34; Style概述了如何使用薄片，而无需太多细节。其中大多数人会得到单独的帖子（有些帖子不止一个）。</p><p> In my opinion, here are some of the big reasons you should care about Nixflakes:</p><p>在我看来，以下是你应该关心尼克斯的一些重要原因：</p><p>   One of the big annoying parts about getting into Nix is that setting up projectsisn&#39;t totally a defined science. Nix configurations just tend to groworganically and can easily become weird or difficult to understand for peoplethat didn&#39;t start the project. Nix flakes helps fix this by doing a few things:</p><p>进入Nix最让人恼火的地方之一是设置项目；这不完全是一门有定义的科学。Nix配置往往会有机地增长，对于那些没有&#39；我不能启动这个项目。Nix flakes通过做以下几件事来帮助解决这个问题：</p><p> Defining a  flake.nix as the central &#34;hub&#34; for your project&#39;s dependencies,exposed packages, NixOS configuration modules  andmore.</p><p>定义一片雪花。以尼克斯为中心&#34；枢纽和#34；为了你的项目&#39；的依赖项、公开的软件包、NixOS配置模块等等。</p><p> Shipping a  set of templates so that youcan get projects started easily. Think something like Yeoman but built directly into Nix. You can also defineyour own templates in your  flake.nix.</p><p>提供一组模板，以便轻松启动项目。想象一下类似于约曼的东西，但它直接内置于尼克斯。你也可以在flake中定义自己的模板。尼克斯。</p><p> As an example that we will use for the rest of this post to help explain it,let&#39;s make a Go project with their Go template. First you will need to enableNix flakes on your machine. If you are using NixOS, add this to your configuration.nix file:</p><p>作为一个例子，我们将用这篇文章的其余部分来帮助解释它，让&#39；让我们用Go模板做一个Go项目。首先，您需要在您的机器上启用Blenix薄片。如果您使用的是NixOS，请将其添加到您的配置中。nix文件：</p><p>   If you are not on NixOS, you will need to either edit  ~/.config/nix/nix.confor  /etc/nix/nix.conf and add the following line to it:</p><p>如果你不在NixOS上，你需要编辑~/。config/nix/nix。Conver/etc/nix/nix。conf并添加以下行：</p><p>  &lt; Mara&gt; You may need to restart the Nix daemon here, but if you are unsure how Nix wasset up on that non-NixOS machine feel free to totally restart yourcomputer.</p><p>&lt；玛拉&gt；您可能需要在此处重新启动Nix守护进程，但如果您不确定Nix是如何在非NixOS机器上设置的，请随时完全重新启动计算机。</p><p> Now go to a temporary folder and run these commands to make a folder and createa new flake from a template:</p><p>现在转到一个临时文件夹，运行以下命令创建一个文件夹，并从模板创建一个新的薄片：</p><p>     {  description = &#34;A simple Go package&#34;;   # Nixpkgs / NixOS version to use.  inputs.nixpkgs.url = &#34;nixpkgs/nixos-21.11&#34;;   outputs = { self, nixpkgs }:  let   # Generate a user-friendly version number.  version = builtins.substring 0 8 self.lastModifiedDate;   # System types to support.  supportedSystems = [ &#34;x86_64-linux&#34; &#34;x86_64-darwin&#34; &#34;aarch64-linux&#34; &#34;aarch64-darwin&#34; ];   # Helper function to generate an attrset &#39;{ x86_64-linux = f &#34;x86_64-linux&#34;; ... }&#39;.  forAllSystems = nixpkgs.lib.genAttrs supportedSystems;   # Nixpkgs instantiated for supported system types.  nixpkgsFor = forAllSystems (system: import nixpkgs { inherit system; });   in  {   # Provide some binary packages for selected system types.  packages = forAllSystems (system:  let  pkgs = nixpkgsFor.${system};  in  {  go-hello = pkgs.buildGoModule {  pname = &#34;go-hello&#34;;  inherit version;  # In &#39;nix develop&#39;, we don&#39;t need a copy of the source tree  # in the Nix store.  src = ./.;   # This hash locks the dependencies of this package. It is  # necessary because of how Go requires network access to resolve  # VCS. See https://www.tweag.io/blog/2021-03-04-gomod2nix/ for  # details. Normally one can build with a fake sha256 and rely on native Go  # mechanisms to tell you what the hash should be or determine what  # it should be &#34;out-of-band&#34; with other tooling (eg. gomod2nix).  # To begin with it is recommended to set this, but one must  # remeber to bump this hash when your dependencies change.  #vendorSha256 = pkgs.lib.fakeSha256;   vendorSha256 = &#34;sha256-pQpattmS9VmO3ZIQUFn66az8GSmB4IvYhTTCFn6SUmo=&#34;;  };  });   # The default package for &#39;nix build&#39;. This makes sense if the  # flake provides only one package or there is a clear &#34;main&#34;  # package.  defaultPackage = forAllSystems (system: self.packages.${system}.go-hello);  }; }</p><p>{description=&#34；一个简单的Go包&#34；#Nixpkgs/NixOS版本要使用。inputs.Nixpkgs.url=&#34；Nixpkgs/NixOS-21.11&#34；#outputs={self，Nixpkgs}：让#生成一个用户友好的版本号。版本=内置。子字符串0 8 self。最后修改日期要支持的系统类型。supportedSystems=[&#34；x86_64-linux&#34；&#34；x86_64-darwin&#34；&#34；aarch64-linux&#34；&#34；aarch64-darwin&#34；]帮助函数生成属性集#39；{x86_64-linux=f&#34；x86_64-linux&#34；…}&#39;.  forAllSystems=nixpkgs。lib。genAttrs支持的系统已为受支持的系统类型实例化NIXPKG。nixpkgsFor=forAllSystems（系统：import nixpkgs{inherit system；}）；在{#中为所选系统类型提供一些二进制软件包。软件包=forAllSystems（系统：let pkgs=nixpkgsFor.${system}；在{go hello=pkgs.buildGoModule{pname=&#34；go hello&#34；#inherit version；#在&#39；nix develop&#39；中，我们不需要nix store中的源代码树的副本。src=./.#此哈希锁定此包的依赖项。这是#必要的，因为go需要网络访问才能解决#VCS。请参阅https://www.tweag.io/blog/2021-03-04-gomod2nix/关于#细节。通常情况下，用户可以使用假sha256构建，并依赖原生Go#机制来告诉您哈希应该是什么，或者确定它应该是什么#34；带外&#34；使用其他工具（如gomod2nix）。#首先，建议设置此值，但必须记住，当依赖项发生变化时，要使用此哈希值#vendorSha256=pkgs。lib。假药256；供应商HA256=#34；sha256-pQpattmS9VmO3ZIQUFn66az8GSmB4IvYhTTCFn6SUmo=&&#39；nix build&#39；。如果#flake只提供一个包，或者有一个清晰的#34；主要的&#34；#包裹defaultPackage=forAllSystems（system:self.packages.${system}.go hello）；}；}</p><p> This defines a single Go package that is supported on macOS and Linux for 64 bitx86 processors and 64 bit ARM processors.</p><p>这定义了macOS和Linux上支持的用于64位x86处理器和64位ARM处理器的单Go包。</p><p> &lt; Mara&gt; In practice this spread should cover all of the main targets you&#39;ll need tocare about for local development and clouddeployment.</p><p>&lt；玛拉&gt；在实践中，这个价差应该覆盖所有的主要目标&#39；我们需要关注本地开发和云部署。</p><p>       {  description = &#34;A simple Go package&#34;;    inputs.nixpkgs.url = &#34;nixpkgs/nixos-21.11&#34;;    outputs = { self, nixpkgs }: {  packages = { ... };  defaultPackage = { ... };  }; }</p><p>{description=&#34；一个简单的Go包&#34；inputs.nixpkgs.url=&#34；nixpkgs/nixos-21.11&#34；outputs={self，nixpkgs}:{packages={…}；defaultPackage={…}；}；}</p><p> &lt; Cadey&gt; A note: in the rest of this article (and series of articles), when I refer to a&#34;flake output&#34;, I am referring to an attribute in the  outputs attribute ofyour  flake.nix. Ditto with &#34;flake input&#34; referring to the  inputs attributeof your  flake.nix.</p><p>&lt；卡迪&gt；注意：在本文的其余部分（以及系列文章）中，当我提到A&#34；薄片输出&#34；，我指的是你的雪花的输出属性中的一个属性。尼克斯。与#34相同；薄片输入&#34；参考雪花的输入属性。尼克斯。</p><p> When you ran  nix build earlier, it defaulted to building the package in defaultPackage. You can also build the  go-hello package by running thiscommand:</p><p>当您早些时候运行nix build时，它默认为在defaultPackage中构建包。您还可以通过运行以下命令来构建go hello包：</p><p>    A standard default package means that you can more easily build software withouthaving to read documentation on what file to build.  nix build will Just Work™️.</p><p>标准的默认软件包意味着您可以更轻松地构建软件，而无需阅读要构建的文件的文档。nix build只会起作用™️.</p><p>  Additionally, you can expose a package as an application. This allows you tosimplify that above  nix build and  ./result/bin/go-hello cycle into a single nix run command. Open  flake.nix in your favorite editor and let&#39;s configure go-hello to be the default app:</p><p>此外，还可以将包公开为应用程序。这使您可以简化上述nix构建和测试/result/bin/go hello循环到一个nix run命令中。打开薄片。关闭你最喜欢的编辑器，让&#39；s将go hello配置为默认应用程序：</p><p>      &lt; Mara&gt; What is that extra part of the URL path for? Is that a gitbranch?</p><p>&lt；玛拉&gt；URL路径的额外部分是用来做什么的？那是gitbranch吗？</p><p> &lt; Cadey&gt; Yes, you can use that syntax to set the git branch that Nix should build from.By default it will use the default branch (typically  main), but sometimes youneed to specify a branch or commit directly.</p><p>&lt；卡迪&gt；是的，您可以使用该语法设置Nix应该从中构建的git分支。默认情况下，它将使用默认分支（通常为main），但有时需要指定分支或直接提交。</p><p>  One of Nix&#39;s superpowers is the ability to declaratively manage the developmentenvironment for a project so that you can be sure that everyone working on theproject is using the same tools.</p><p>尼克斯和#39；s的超能力是以声明方式管理项目的开发环境的能力，这样您就可以确保项目中的每个人都在使用相同的工具。</p><p> &lt; Cadey&gt; I use this with all of my projects to the point that when I am outside of aproject folder I do not have any development toolsavailable.</p><p>&lt；卡迪&gt；我在我所有的项目中都使用了它，以至于当我在项目文件夹之外时，我没有任何可用的开发工具。</p><p> Flakes has the ability to specify this using the  devShell flake output. Youcan add it to your  flake.nix using this:</p><p>Flakes能够使用devShell flake输出指定这一点。你可以把它加到你的薄片上。尼克斯：用这个：</p><p> # after defaultApp  devShell = forAllSystems (system:  let pkgs = nixpkgsFor.${system};  in pkgs.mkShell {  buildInputs = with pkgs; [ go gopls goimports go-tools ];  });</p><p>#defaultApp devShell=forAllSystems（系统：let pkgs=nixpkgsFor.${system}；在pkgs.mkShell中{buildInputs=with pkgs；[go gopls goimports go tools]；}）；</p><p> &lt; Mara&gt; I consider this to be a basic Go development environment. It includes standardtools such as the language server,  goimports for better formatting and toolslike  staticcheck. If you use staticcheckregularly at work, please consider throwing  Dominik a couple bucksa month if you find it useful. It helps the project be moreself-sustaining.</p><p>&lt；玛拉&gt；我认为这是一个基本的GO开发环境。它包括标准工具，如语言服务器、用于更好格式化的goimports和类似staticcheck的工具。如果你在工作中定期使用静态检查，如果你觉得多米尼克有用的话，请考虑把它扔掉几个月。这有助于项目更加自我维持。</p><p>   And then hack at your project all you want. You can send this git repo to afriend and they will have the same setup.</p><p>然后随心所欲地攻击你的项目。你可以把这个git回购发送给朋友，他们也会有相同的设置。</p><p>  Now let&#39;s talk about inputs. Flake inputs let you add external dependencies to aproject. As an example, let&#39;s look at the  nixpkgs input:</p><p>现在让&#39；让我们来谈谈投入。片状输入允许您将外部依赖项添加到项目中。例如，让&#39；让我们看看nixpkgs输入：</p><p>  This defines the release of nixpkgs that should be used for the project. Thistemplate defaults to NixOS 21.11&#39;s version of nixpkgs, however we can upgrade itto nixos-unstable by changing it to this:</p><p>这定义了应用于项目的NIXPKG的版本。该模板默认为NixOS 21.11&#39；s版本的nixpkgs，但我们可以将其升级为nixos不稳定，方法是将其更改为：</p><p>  Then we can run  nix flake update and then  nix develop and see that we arerunning a newer version of Go:</p><p>然后我们可以运行nix flake update，然后运行nix develope，看看我们运行的是一个更新版本的Go：</p><p> $ nix flake update warning: updating lock file &#39;/home/cadey/tmp/gohello/flake.lock&#39;: • Updated input &#39;nixpkgs&#39;:  &#39;github:NixOS/nixpkgs/77aa71f66fd05d9e7b7d1c084865d703a8008ab7&#39; (2022-01-19)  → &#39;github:NixOS/nixpkgs/2128d0aa28edef51fd8fef38b132ffc0155595df&#39; (2022-02-16)   $ nix develop  [ [email protected]:~/tmp/gohello]$ go version go version go1.17.7 linux/amd64</p><p>$nix flake update警告：正在更新锁文件&#39/home/cadey/tmp/gohello/flake。锁&#39；：•更新输入&#39；尼克斯帕克斯&#39；：&#39;github:NixOS/nixpkgs/77aa71f66fd05d9e7b7d1c084865d703a8008ab7和#39；(2022-01-19)  → &#39;github:NixOS/nixpkgs/2128d0aa28edef51fd8fef38b132ffc0155595df&#39；（2022-02-16）$nix开发[[受电子邮件保护]：~/tmp/gohello]$go版本go版本go1。17.7 linux/amd64</p><p> This also lets you pull in other Nix flakes projects, such as my CSS framework Xess:</p><p>这还允许您引入其他Nix flakes项目，例如my CSS framework Xess：</p><p>   &lt; Cadey&gt; By default when you pull in another project with Nix flakes, it treats thatproject as an entirely separate universe and only interacts with the outputs ofthat flake. This means it pulls in its own version of nixpkgs, each dependencyit has can pull in that own version of nixpkgs and vice versa ad infinitum. Bymaking Xess&#39; nixpkgs input follows our own one, we are saying &#34;I understand thismay be incompatible, but please use this version of nixpkgs instead&#34;. This canhelp larger projects with many inputs (such as a nixos configs repo made bysomeone with too many throwaway side projects) evaluate and build faster. Nixflakes does have a cached evaluator, but still it helps to avoid the problem inthe first place.</p><p>&lt；卡迪&gt；默认情况下，当您使用Nix flakes拉入另一个项目时，它将该项目视为一个完全独立的宇宙，并且只与该flake的输出交互。这意味着它可以拉入自己版本的nixpkgs，它拥有的每个依赖项都可以拉入自己版本的nixpkgs，反之亦然。通过制作Xess和#39；nixpkgs的输入遵循我们自己的输入，我们说&#34；我知道这可能不兼容，但请改用这个版本的nixpkgs&#34；。这可以帮助有很多投入的大型项目（例如，有太多一次性项目的人进行的nixos configs回购）更快地评估和构建。Nixflakes确实有一个缓存的计算器，但它仍然有助于从一开始就避免这个问题。</p><p> Or anything you want! A useful library to pull in is flake-utils, that can help yousimplify your  flake.nix and get rid of those ugly  forAllSystems and nixpkgsFor functions in the  flake.nix that this post used by default. For anexample of a flake that uses this library, see  this flake.nix from the IRCbot that lives in   #xeserv.</p><p>或者任何你想要的！一个有用的库是flake utils，它可以帮助您简化flake。nix和摆脱那些丑陋的forAllSystems和nixpkgsFor flake中的函数。禁止默认使用此帖子。有关使用此库的薄片的示例，请参见此薄片。住在#xeserv的IRCbot的nix。</p><p>   Normally you need to enable Nix flakes in your Nix daemon to take advantage ofthem. This is great for when you can do that, but sometimes you&#39;ll need to makethings work for people without flakes enabled. This could happen when needing tograft in a Nix flakes project to one without flakes enabled. There is a librarycalled  flake-compat that makes thiseasy.</p><p>通常，您需要在Nix守护进程中启用Nix薄片来利用它们。当你能做到这一点时，这很好，但有时你&#39；我们需要在不启用雪花的情况下为人们提供服务。当需要将Nix flakes项目中的一个项目转换为未启用flakes的项目时，可能会发生这种情况。有一个名为flake compat的图书馆可以让这一切变得简单。</p><p>    (import (  let  lock = builtins.fromJSON (builtins.readFile ./flake.lock);  in fetchTarball {  url = &#34;https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz&#34;;  sha256 = lock.nodes.flake-compat.locked.narHash; } ) {  src = ./.; }).defaultNix</p><p>（导入（让lock=builtins.fromJSON（builtins.readFile./flake.lock）；在fetchTarball{url=&#34；https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake compat.locked.rev}。焦油gz&#34；；sha256=锁。节点。片状同胞。锁上了。narHash；}）{src=./；}）。defaultNix</p><p>  (import (  let  lock = builtins.fromJSON (builtins.readFile ./flake.lock);  in fetchTarball {  url = &#34;https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz&#34;;  sha256 = lock.nodes.flake-compat.locked.narHash; } ) {  src = ./.; }).shellNix</p><p>（导入（让lock=builtins.fromJSON（builtins.readFile./flake.lock）；在fetchTarball{url=&#34；https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake compat.locked.rev}。焦油gz&#34；；sha256=锁。节点。片状同胞。锁上了。narHash；}）{src=./；}）。shellNix</p><p>   Nix flakes has native support for private git repositories as inputs. This canbe useful when trying to build software you don&#39;t want to release as open to theworld. To use a private repo, your flake input URL should look something likethis:</p><p>Nix flakes本机支持将私有git存储库作为输入。这在尝试构建你不需要的软件时很有用；I don’我不想对外开放。要使用私人回购，您的flake输入URL应该如下所示：</p><p>  &lt; Cadey&gt; I&#39;m pretty sure you could use private git repos outside of flakes, however itwas never really clear to me  how you end up doingit.</p><p>&lt；卡迪&gt；我&#39；我很确定你可以在flakes之外使用私人git回购协议，但我一直不清楚你最终会怎么做。</p><p>  The biggest ticket item for me is that it lets you embed NixOS modules in flakesthemselves. This lets you define the system configuration for software rightnext to where the software is defined, thus shipping it as a unit. Using thisyou can make installing software a matter of adding it to your system&#39;s flake,adding the module and then enabling the settings you want to enable.</p><p>对我来说，最大的问题是它可以让你把NixOS模块嵌入到薄片中。这使您可以在定义软件的位置旁边定义软件的系统配置，从而将其作为一个单元发货。使用它，你可以把安装软件变成将其添加到系统中的一件事&#39；s flake，添加模块，然后启用要启用的设置。</p><p>  nixosModules.bot = { config, lib, ... }: {  options.within.services.mara-bot.enable =  lib.mkEnableOption &#34;enable Mara bot&#34;;   config = lib.mkIf config.within.services.mara-bot.enable {  users.groups.mara-bot = { };   users.users.mara-bot = {  createHome = true;  isSystemUser = true;  home = &#34;/var/lib/mara-bot&#34;;  group = &#34;mara-bot&#34;;  };   systemd.services.mara-bot = {  wantedBy = [ &#34;multi-user.target&#34; ];  environment.RUST_LOG = &#34;tower_http=debug,info&#34;;  unitConfig.ConditionPathExists = &#34;/var/lib/mara-bot/config.yaml&#34;;  serviceConfig = {  User = &#34;mara-bot&#34;;  Group = &#34;mara-bot&#34;;  Restart = &#34;always&#34;;  WorkingDirectory = &#34;/var/lib/mara-bot&#34;;  ExecStart = &#34;${self.defaultPackage.&#34;${system}&#34;}/bin/mara&#34;;  };  };  }; };</p><p>尼克松模块。bot={config，lib，…}{options.within.services.mara-bot.enable=lib.mkEnableOption&#34；enable-mara-bot&#34；config=lib.mkIf-config.within.services.mara-bot.enable{users.groups.mara-bot={}；用户。用户。mara bot={createHome=true；isSystemUser=true；home=&#34；/var/lib/mara bot&#34；group=&#34；mara bot&#34；}；系统化。服务。mara bot={wantedBy=[&#34；多用户。target&#34；]；环境RUST_LOG=&#34；塔http=debug，info&#34；；unitConfig。ConditionPathExists=&#34/var/lib/mara bot/config。亚马尔&#34；；serviceConfig={User=&#34；mara bot&#34；Group=&#34；mara bot&#34；Restart=&#34；always&#34；WorkingDirectory=&#34；/var/lib/mara bot&#34；ExecStart=&#34；${self.defaultPackage.&#/宾/马拉&#34；}；}；}；}；}；</p><p> The key important part here is the  ExecStart line. It points back to theflake&#39;s default package (which is hopefully where the bot&#39;s code is defined),and then has systemd manage that.</p><p>这里最重要的部分是起点。它指向湖外&#39；s的默认包（希望在其中定义bot&#39；的代码），然后由systemd管理。</p><p> I plan to use this to radically simplify my nixos-configs repo. Right now it hasa lot of code that is very project-specific and if I can move that into theprojects in question, I can eliminate a lot of code out of the core of myconfigs repo.</p><p>我计划用它来彻底简化我的nixos配置回购协议。现在，它有很多特定于项目的代码，如果我能将这些代码转移到相关的项目中，我可以从myconfigs repo的核心中删除很多代码。</p><p>  Finally, Nix flakes lets you see the configuration version of a system byembedding it at the build step. Normally NixOS lets you see the followinginformation with  nixos-version --json:</p><p>最后，Nix flakes通过在构建步骤嵌入系统，让您可以看到系统的配置版本。通常，NixOS允许您通过NixOS版本——json查看以下信息：</p><p>  You have the NixOS version and the nixpkgs hash. That doesn&#39;t tell you whatconfiguration you are running or anything about it though. However with flakesyou can embed the git hash of your configuration into the system config:</p><p>您有NixOS版本和nixpkgs哈希。这并不意味着&#39；但是，我不能告诉你正在运行什么配置或关于它的任何事情。但是，使用flakesyou可以将配置的git哈希嵌入到系统配置中：</p><p>       There is a lot more to get into with each of these topics. I&#39;m only reallygiving a very high level overview on them while I learn more and migrate over myNixOS configurations to flakes piecemeal. This has also given me theopportunity to clean things up and chew out a lot of the fat from my NixOSconfigurations. More to come when it is ready.</p><p>以上每一个主题都有很多内容要讨论。我&#39；我只是对它们做了一个非常高层次的概述，同时我了解了更多信息，并通过myNixOS配置零碎地迁移到了薄片上。这也给了我一个机会来清理东西，从我的尼克松配置中咀嚼出很多脂肪。准备好后会有更多。</p><p>   This article was posted on M02 21 2022. Facts and circumstances may have changed since publication. Please  contact me before jumping to conclusions if something seems wrong or unclear.</p><p>本文发布在M02 21 2022上。自公布以来，事实和情况可能发生了变化。如果有问题或不清楚的地方，请在下结论之前联系我。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/尼克斯/">#尼克斯</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/flakes/">#flakes</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nix/">#nix</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>