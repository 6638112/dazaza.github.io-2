<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>CPPFS  - 支持多个后端结束的CPPFS  - 跨平台C ++文件系统库 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">CPPFS  - 支持多个后端结束的CPPFS  - 跨平台C ++文件系统库 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-20 23:36:30</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/56f3a6f759334ed34860e5ce40077ee6.png"><img src="http://img2.diglog.com/img/2021/3/56f3a6f759334ed34860e5ce40077ee6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>CPPFS是一个跨平台C ++库，提供面向对象的抽象，用于处理文件和文件系统。</p><p>  CPPF不仅可以访问本地文件系统，而且可以用于远程和虚拟文件系统。专门化虚拟后端接口，可以轻松扩展到CPPF以支持其他remote协议或虚拟文件系统。目前已实现以下后端：</p><p>            ＃包括＆lt; cppfs / fs.h＆gt;＃包括＆lt; cppfs / filehandle.h＆gt;使用命名空间cppfs; void Openfile（const std :: string＆amp;文件名）{filehandle fh = fs ::打开（文件名）; if（fh。isfile（））{/ *文件... * /} else if（fh。isdirectory（））{/ *目录... * /} else else（！fh。存在（））{/ *不在那里 ...  */ }}</p><p>  ＃包括＆lt; cppfs / fs.h＆gt;＃包括＆lt; cppfs / filehandle.h＆gt;使用命名空间cppfs; void Openfile（const std :: string＆amp;文件名）{filehandle fh = fs ::打开（文件名）; if（fh。iSfile（））{auto in = fh。 createInputStream（）; // ...自动= fh。 createOutputStream（）; // ...}}</p><p>  ＃包括＆lt; cppfs / fs.h＆gt;＃包括＆lt; cppfs / filehandle.h＆gt;使用命名空间cppfs; void lstdir（const std :: string＆amp; path）{filehandle dir = fs ::打开（路径）; if（dir。isdirectory（））{for（fileiterator它= dir。begin（）;它！= dir。ext。结束（）; ++它）{std :: string path = *它; }}}</p><p>   类FilePath用于表示文件系统中的路径。可以从字符串构造并将其转换回字符串。</p><p>  仅使用正斜杠（＆＃39; /＆＃39）作为分隔符以统一格式存储路径。统一格式与所有系统兼容，但作为用户的便利性，在显示路径时应转换为下列格式。将路径转换为NativeFormat，调用调用。 </p><p>FilePath可用于获取有关路径的语法信息。但是，它纯粹在字符串上工作，它不能提供Path点的实际文件或目录的信息。以下功能可用于获取有关路径的信息：</p><p> filepath路径= ...; //检查路径是否为空（＆＃34;＆＃34;）bool空= path.isusempty（）; //检查路径是否是绝对路径（例如，＆＃34; /test.txt&&#34;或＆＃34; c：/ test.txt& n34;）bool abs = path.isabsolute（）; //检查路径是否是相对路径（例如，＆＃34;数据/ test.txt＆＃34;）bool rel = path.isrelative（）; //检查path是否指向文件/目录（例如，＆＃34; / path / to / dir＆＃34;）//或其内容（例如，＆＃34; / path / dir / dir / dir / dir / dir / dir / dir / dir /＆＃34 ;）。 bool listcontent = path.pointstocontent（）;</p><p> filepath提供了获取文件路径的各个组件的函数，例如包含目录的文件名，扩展名或路径。这些函数的所有功能忽略路径上的尾随斜线，因此它们在路径指向的对象上运行，而不是它内容。</p><p> filepath path1（＆＃34; c：/path/to/file.txt＆＃34;）; filepath path2（＆＃34; c：/ path / to / directory / diguration /＆＃34;）; //获取完整路径:: cout＆lt;＆lt; path1.fullpath（）＆lt;＆lt; std :: endl; //＆＃34; c：/path/to/file.txt&#34; std :: cout＆lt;＆lt; path2.fullpath（）＆lt;＆lt; std :: endl; //＆＃34; c：/ path / to / directory＆＃34; //获取文件名componentstd :: cout <＆lt;＆lt; path1.filename（）＆lt;＆lt; std :: endl; //＆＃34; file.txt＆＃34; std :: cout＆lt;＆lt;＆lt; path2.filename（）＆lt;＆lt; std :: endl; //＆＃34;目录＆＃34; std :: cout＆lt;＆lt; path1.baseName（）＆lt;＆lt; std :: endl; //＆＃34;文件＆＃34; std :: cout＆lt;＆lt; path2.baseName（）＆lt;＆lt; std :: endl; //＆＃34;目录＆＃34; std :: cout＆lt;＆lt; path1.extension（）＆lt;＆lt; std :: endl; //＆＃34; .txt＆＃34; std :: cout＆lt;＆lt; path2.extension（）＆lt;＆lt; std :: endl; //＃34;＆＃34; //获得包含directorystd :: cout＆lt;＆lt;＆lt; path1.directoryPath（）＆lt;＆lt; std :: endl; //＆＃34; c：/ path / to /＆＃34; std :: cout＆lt;＆lt; path2.directoryPath（）＆lt;＆lt; std :: endl; //＆＃34; c：/ path / to /＆＃34; //获取驱动器Lettertry :: Cout＆lt;＆lt; path1.driveletter（）＆lt;＆lt; std :: endl; //＆＃34; c：＆＃34; std :: cout＆lt;＆lt; path2.driveletter（）＆lt;＆lt; std :: endl; //＆＃34; c：＆＃34;</p><p> 通常需要组合路径才能确定文件的实际位置。要组合两个路径，可以使用函数解析。第一个路径必须相对于组合两条路径，否则仅返回第一个路径。路径的组合也发生在纯语法级别，而不检查是否存在任何路径。</p><p> FIREPATH SRC（＆＃34; c：/ projects＆＃34;）; filepath rel（＆＃34; ./文件/ test.txt＆＃34;）; filepath asb（＆＃34; c：/ projects2 / Readme.txt＆＃34;）; filepath path1 = src.resolve（rel）; std :: cout <lt;＆lt; path1.fullpath（）＆lt;＆lt; std :: endl; //＆＃34; c：/ projects / d文档/ test.txt＆＃34; filepath path2 = src.resolve（abs）; std :: cout＆lt;＆lt; path2.fullpath（）＆lt;＆lt; std :: endl; //＃34; c：/projects2/readme.txt&#34;</p><p> 结合相对路径时，产生的字符串可以包含Lotof＆＃34; ..＆＃34;和＃34;＆＃34;成分。要在语法级别解决这些问题，可以调用解决的功能。它将删除所有＆＃34;。＆＃34;和＆＃34;和＃34;，只要它是可能的。 ＆＃34; ..＆＃34;在一开始就不会删除路径。 </p><p>用于访问CPPFS中的文件和目录的主类是FileHandle.it可用于将有关文件系统对象的信息，用于Manipulatethem（例如，复制，重命名或删除），以及读写文件。</p><p> 要获取文件句柄，可以调用全局函数fs ::打开。访问的TheType将由可访问的路径或URL自动确定。文件系统将在剩余的任何打开文件处理时自动关闭。</p><p> //打开本地FileFileHandle File1 = FS :: Open（＆＃34;数据/ Readme.txt＆＃34;）; //在ssh serverlogincredentials上打开文件登录; login.setvalue（＆＃34;用户名＆＃34;＆＃34;用户名＆＃34;）; login.setvalue（＆＃34;密码＆＃34;＆＃ 34; password＆＃34;）; login.setvalue（＆＃34; publickey＆＃34;＆＃34; /pel/to/key.pub＆＃34;）; //默认值：＆＃34; $ home / .ssh / id_rsa.pub＆＃34; login.setvalue（＆＃34; privatekey＆＃34; / pitionalkey＆＃34; / pather＆＃34;）; //默认值：＆＃34; $ home / .ssh / id_rsa＆＃34; login.setvalue（＆＃34; port＃34;＆＃34; 999＆＃34;）; //默认值：22fileHandle file2 = fs ::打开（＆＃34; ssh：//example.com/home/user/readme.txt＆＃34;，＆amp;登录）;</p><p> 此刻，无法在GlobalLevel注册新的文件系统。要使用自定义文件系统，请创建它的实例并使用AbstractFileSystem接口访问它。</p><p>   文件句柄可用于访问其指向的文件系统对象的信息。还可以复制文件句柄，创建指向同一文件SystemObject的第二个句柄，但不继承以前句柄的状态。此操作仅将句柄的路径复制到那种廉价的操作。</p><p> //从本地文件systemfile handle文件= fs ::打开（＆＃34;数据/ readme.txt＆＃34;）; //将第二个句柄到同一个FileFileHandle File2 = File;</p><p> 一旦获得文件句柄，它可以用于查询文件系统对象的基本信息。 </p><p>filehandle file = fs ::打开（＆＃34;数据/ readme.txt＆＃34;）; //检查类型if（file.isfile（））std :: cout＆lt;＆lt; ＆＃34;文件＆＃34; ＆lt;＆lt; std :: endl;否则if（file.isdirectory（））std :: cout＆lt;＆lt; ＆＃34;目录＆＃34; ＆lt;＆lt; std :: endl;否则if（file.issymboliclink（））std :: cout <＆lt;＆lt; ＆＃34; Symlink＆＃34; ＆lt;＆lt; std :: endl;否则if（！file.exists（））std :: cout <lt;＆lt; ＆＃34;文件不存在＆＃34; ＆lt;＆lt; std :: endl; //获取文件名和pathstd :: string path = file.path（）; std :: string filename = file.filename（）; //获取文件信息无符号int size = file.size（）; unsigned int atime = file.accesstime（）; unsigned int mtime = file.modificationtime（）; unsigned int uid = file.userid（）; unsigned int gid = file.groupid（）; unsigned long perm = file.permissions（）;</p><p>   仅在需要时检索文件信息，即，在上述功能之一的第一次调用上，然后在内存中缓存。当句柄的操作修改文件信息时，它会自动更新。然而，如果在应用程序之外修改文件或使用outcleHandle到同一文件的文件，则文件句柄无法知道更改。因此，必须手动更新：</p><p>   使用FileHandle，可以执行基本文件操作。对于二进制操作，例如复制或移动，第二文件处理器被认为是操作的目标。根据特工，目标不需要已经存在。如果针对目录而不是文件的目标点，则目标将被认为是在该目录中（例如，文件将被复制给定目录的文件）。</p><p> filehandle dir = fs ::打开（＆＃34;数据＆＃34;）; filehandle file = fs ::打开（＆＃34; readme.txt＆＃34;）; filehandle dest; //如果（！dir.isdirectory（））dir.createdirectory（）尚未存在，如果尚不存在//将文件复制到Directoryfile.copy（dir）; //将文件复制到另一个filedest = dir.open（＆＃34; readme2.txt＆＃34;）; file.copy（dest）; //重命名filefile.rename（＆＃34; Readme3.txt＆＃34;）; //将文件移动到Directoryfile.move（dir）中; //创建硬链接nest = dir.open（＆＃34; readme4.txt＆＃34;）; file.createlink（dest）; //创建符号linkdest = dir.open（＆＃34; readme5.txt＆＃34;）; file.createSymboliclink（dest）; //删除filefile.remove（）; //删除目录（仅当为空）dir.removedirectory（）;</p><p>  要读取和写入文件，应用标准C ++流。要打开Afile的输入流，请调用CreateInputStream。要创建输出流，请调用createOutputStream。</p><p>     高级文件操作包括生成文件的哈希和Base64编码。它们可以直接调用文件句柄：</p><p> filehandle file = fs ::打开（＆＃34; Readme.txt＆＃34;）; //获取filestd的sha1哈希:: string hash = file.sha1（）; //获取FISESTD :: String BASE64 = FILE.BASE64（）的BASE64编码; //从base64编码文件编写文件.wilefilebase64（base64）; </p><p>FileHandle用于访问文件以及目录。要检查文件句柄指向目录是否，可以使用函数ISDirectory。</p><p>     filehandle dir = fs ::打开（＆＃34;数据＆＃34;）; for（fileiterator它= dir.begin（）;它！= dir.end（）; ++它）{std :: string path = *它;}</p><p> 为了自动遍历目录树，可以调用遍历遍历功能。它可以通过它</p><p>  filehandle dir = fs ::打开（＆＃34;数据＆＃34;）; //遍历所有文件entriesdir.traverse（[]（filehandle＆amp; fh） - ＆gt; bool {std :: cout＆lt;＆lt; fh。path（）＆lt; std :: endl;返回true; //继续}）; //遍历所有文件和目录Dir.traverse（[]（fileHandle＆amp; fh） - ＆gt; bool {std :: cout＆lt;＆lt; fh。path（）＆lt; std :: endl;返回true; //继续}，[]（filehandle＆amp; dir） - ＆gt; bool {std :: cout＆lt; dir。path（）＆lt; st; std :: endl;返回true; //继续}）;</p><p> 当获得对目录的句柄时，它可以用于打开相对于该目录的文件句柄：</p><p> filehandle dir = fs ::打开（＆＃34;数据＆＃34;）; //打开parent directoryfilehandle parentdir = dir.parentdirectory（）; //在DirectoryFileHandle File1中打开文件1 = Dir.open（＆＃34; Readme.txt＆＃34;）; //相对于directoryfilehandle file2 = dir.open（＆＃34; readme.txt＆＃34;）;</p><p>  对于目录树上的更高级别操作，可以使用类树，差异和更改。树包含树数据结构中的所有文件和目录的信息。通过呼叫ReadTree可以从adirectory手柄获得。 </p><p>//读取来自当前目录Std :: unique_ptr＆lt; tree＆gt的目录树; tree1 = dir.readtree（）; //从当前目录中读取目录树，给它一个虚拟rootstd :: unique_ptr＆lt; tree＆gt; tree2 = dir.readtree（＆＃34; / root＆＃34;）;</p><p> 给定两个目录树，可以计算它们之间的差异，从而导致差异对象。差异包含许多文件系统操作，以便从源树TOTE DESTIVER树转换。这可以用来实现基本文件同步：</p><p> //打开DirectiesFileHandle SRCDIR = FS ::打开（＆＃34; data1＆＃34;）; filehandle dstdir = fs ::打开（＆＃34; data2＆＃34;）; //读取目录树自动srctree = srcdir.readtree（）;自动dsttree = dstdir.readtree（）; //计算差异自动差异= dsttree-＆gt; Creatediff（* srctree）; // sync目录（更改更改：diff-＆gt;更改（））{if（更改。操作（）==更改:: copyfile）{filehandle src = srcdir。打开（改变。Path（））; filehandle dst = dstdir。打开（改变。Path（））; SRC。复制（DST）; }如果（更改。操作（）==更改:: copyDir）{fileHandle SRC = SRCDIR。打开（改变。Path（））; filehandle dst = dstdir。打开（改变。Path（））; SRC。 CopyDirectoryRec（DST）; }如果（更改。操作（）== change :: removefile）{filehandle dst = dstdir。打开（改变。Path（））; DST。消除（）; }如果（更改。操作（）==更改:: recumentir）{filehandle dst = dstdir。打开（改变。Path（））; DST。 reameedirectoryrec（）; }} </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/cginternals/cppfs">https://github.com/cginternals/cppfs</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cppfs/">#cppfs</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cross/">#cross</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1052672.html"><img src="http://img2.diglog.com/img/2021/3/thumb_4c3974da37744474bdb452695e60f15c.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1052672.html">Conan  -  C / C ++的包管理器 </a></div><span class="my_story_list_date">2021-3-16 14:55</span></div><div class="col-sm"><div><a target="_blank" href="/story/1052644.html"><img src="http://img2.diglog.com/img/2021/3/thumb_84862d0d9e7c47e8e9f1531b3f2513ee.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1052644.html">C ++如何解析函数调用 </a></div><span class="my_story_list_date">2021-3-16 10:44</span></div><div class="col-sm"><div><a target="_blank" href="/story/1049143.html"><img src="http://img2.diglog.com/img/2021/2/thumb_17e7ecd194befaf639813457d932baf4.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1049143.html">在C ++中实现并行Copy_If </a></div><span class="my_story_list_date">2021-2-25 2:14</span></div><div class="col-sm"><div><a target="_blank" href="/story/1045324.html"><img src="http://img2.diglog.com/img/2021/1/thumb_5f63c04a23404eeb4b88f6421ddb2a74.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1045324.html">2020年Go和C ++中的错误与异常 </a></div><span class="my_story_list_date">2021-1-20 19:33</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>