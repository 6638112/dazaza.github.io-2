<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Rust：2020年的结构化和处理错误（2020） Rust: Structuring and handling errors in 2020 (2020)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rust: Structuring and handling errors in 2020 (2020)<br/>Rust：2020年的结构化和处理错误（2020） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-17 05:10:18</div><div class="page_narrow text-break page_content"><p>I recently started learning the  Rust programming language by going through  &#34; the book&#34;, which does a phenomenal job of explaining the language basics.</p><p>我最近通过学习＆＃34;开始学习Rust编程语言。这本书，在解释语言基础方面做得非常出色。</p><p> After working through the book’s main content I got started with my first non-trivial, real-world application.But I soon found myself faced with a question I didn’t yet feel well-equipped to handle:</p><p> 读完本书的主要内容后，我开始了我的第一个非平凡的，真实的应用程序。但是我很快发现自己遇到了一个问题，我还没有能力很好地处理：</p><p>  This article describes my journey of discovering the answer to this question.I will try to explain the pattern I’ve settled on together with example code showing its implementation, in the hope that other newcomers may have an easier time getting started.</p><p>  本文介绍了寻找该问题答案的过程。我将尝试说明我所采用的模式以及示例代码，以展示其实现方式，以期希望其他新手可以更轻松地上手。</p><p>    While the book goes through the basics of error handling, including use of the  std::Result type and error propagation with the   ? operator, it largely glosses over the different patterns for using these tools in real-world applications or the trade-offs involved with different approaches.   1</p><p>    虽然本书介绍了错误处理的基础知识，包括使用std :: Result类型和带有？的错误传播。运营商，它很大程度上掩盖了在实际应用中使用这些工具的不同模式，或者涉及不同方法的权衡。 1个</p><p> When I began looking into best practices, I came across quite a bit of outdated advice to use the   failure crate. Failure had a semi-official feel to it as a result of being in the  rust-lang-nursery namespace, but  it has recently been deprecated.</p><p> 当我开始研究最佳实践时，我遇到了很多使用故障包装箱的过时建议。由于位于rust-lang-nursery命名空间中，因此失败具有一种半官方的感觉，但最近已弃用了它。</p><p> There have been a number of improvements to the  std::error::Error trait in the past two years.   2These have made  failure less needed in general and have sparked a number of more modern libraries taking advantage of these improvements to offer better ergonomics.</p><p> 在过去两年中，对std :: error :: Error特性进行了许多改进。 2这些使总体上减少了对故障的需求，并激发了许多更现代的图书馆，这些图书馆利用这些改进来提供更好的人体工程学。</p><p> After reading through quite a lot of historical context and evaluating a number of libraries, I’ve now settled on a (largely library-agnostic) pattern for structuring errors, which I implement using the  anyhow and  thiserror crates.   3</p><p> 在阅读了很多历史背景并评估了许多库之后，我现在选择了一种（主要与库无关的）模式来构造错误，该模式可以通过anyhow和thiserror板条箱实现。 3 </p><p>    Let’s introduce some example code for use throughout the rest of this article.We’ll build a program to count the number of words in a text file, much like  wc -w would do.</p><p>让我们介绍一些示例代码，供本文其余部分使用。我们将构建一个程序来计算文本文件中的单词数，就像wc -w一样。</p><p>  use   std:: env ;   use   std:: error:: Error ;   use   std:: fs:: File ;   use   std:: io:: prelude:: * ;   use   std:: io:: BufReader ;    /// Count the number of words in the given input. /// /// Any potential errors, such as being unable to read from the input will be propagated /// upwards as-is due to the use of `line?` just before `split_whitespace()`.  fn  count_words &lt; R:  Read &gt; ( input:  &amp; mut   R )  -&gt;  Result &lt; u32 ,   Box &lt; dyn   Error &gt;&gt;   {    let   reader   =   BufReader:: new ( input );    let   mut   wordcount   =   0 ;    for   line   in   reader . lines ()   {    for   _word   in   line ? . split_whitespace ()   {    wordcount   +=   1 ;    }    }    Ok ( wordcount )   }    fn  main ()  -&gt;  Result &lt; (),   Box &lt; dyn   Error &gt;&gt;   {    for   filename   in   env:: args (). skip ( 1 ). collect:: &lt; Vec &lt; String &gt;&gt; ()   {    let   mut   reader   =   File:: open ( &amp; filename ) ? ;     let   wordcount   =   count_words ( &amp; mut   reader ) ? ;    println ! ( &#34;{} {}&#34; ,   wordcount ,   filename );    }     Ok (())   }</p><p>  使用std :: env;使用std :: error :: Error;使用std :: fs :: File;使用std :: io :: prelude :: *;使用std :: io :: BufReader; ///计算给定输入中的单词数。 /// ////由于在split_whitespace（）之前使用了line ?，任何潜在的错误（例如无法从输入中读取）都将按原样向上传播。 fn count_words＆lt; R：阅读＆gt; （输入：＆amp; mut R）-＆gt;结果＆lt; u32，框＆lt; dyn错误＆gt;＆gt; {let reader = BufReader :: new（input）;让mut wordcount = 0;为读者排队。 lines（）{for _word in line？ 。 split_whitespace（）{wordcount + = 1; }}确定（wordcount）} fn main（）->结果＆lt; （），方框＆lt; dyn错误＆gt;＆gt; {表示env :: args（）中的文件名。跳过（1）。收集：＆lt; Vec＆lt;字符串＆gt;＆gt; （）{let mut reader = File :: open（＆amp; filename）？ ;让wordcount = count_words（＆amp; mut reader）吗？ ; println！ （＆＃34; {} {}＆＃34;，wordcount，filename）； }     好 （（））   }</p><p> Let’s generate an input file for our new word counter and try to run it:</p><p> 让我们为新字计数器生成一个输入文件，然后尝试运行它：</p><p>  If you don’t have a  words.txt however, you’ll encounter the following error:</p><p>  但是，如果没有words.txt，则会遇到以下错误：</p><p> $ cargo run --quiet -- words.txtError: Os { code: 2, kind: NotFound, message: &#34;No such file or directory&#34; }</p><p> $ cargo run --quiet-words.txt错误：Os {代码：2，种类：未找到，消息：＆＃34;没有这样的文件或目录＆＃34; }</p><p>  To make the example complete, let’s also  simulate an error in the  read() call happening under the hood inside  count_words()   4 so we can see what that looks like:</p><p>  为了使示例更完整，我们还模拟了在count_words（）4内部发生的read（）调用中发生的错误，因此我们可以看到如下所示：</p><p> $ cargo run --quiet -- words.txtError: Custom { kind: BrokenPipe, error: &#34;read: broken pipe&#34; }</p><p> $ cargo run --quiet-words.txt错误：自定义{种类：BrokenPipe，错误：＆＃34;阅读：折断的管道＆＃34; } </p><p>  So what’s wrong with the above error?While the underlying error cause ( “broken pipe”) is made clear, we’re missing a lot of context.We can’t tell which file could not be opened and there is no information about the sequence of events leading up to this error.</p><p>因此，上面的错误出了什么问题？虽然明确了潜在的错误原因（“破损的管道”），但我们缺少很多上下文。我们无法确定无法打开哪个文件，也没有关于该文件的信息。导致此错误的事件顺序。</p><p>  count_words() returns an error because we run into an error iterating over  reader.lines() (lines 14-15).</p><p>  count_words（）返回错误，因为我们在遍历reader.lines（）（第14-15行）时遇到了错误。</p><p> Iterating over  reader.lines() errors because we injected an implementation of  std::io::Read that fails on the first call to  read().</p><p> 遍历reader.lines（）错误，因为我们注入了std :: io :: Read的实现，该实现在第一次调用read（）时失败。</p><p>  In this example the file name is an input argument for the program itself.This makes it easy to correlate the error to the file it was trying to open.</p><p>  在此示例中，文件名是程序本身的输入参数，这使得将错误与试图打开的文件相关联变得容易。</p><p> Now imagine an error happening 5 calls deep inside a library within a much larger piece of software.Without any information on the chain of events in such a case, it quickly gets very difficult to understand what might be causing the error.</p><p> 现在想象一下在更大的软件中，在库的深处发生5次调用时发生的错误，在这种情况下，如果没有事件链的任何信息，很快就很难理解导致错误的原因。</p><p>  Earlier on I mentioned  two different libraries,  anyhow and  thiserror (though both are by the same author,  dtolnay).You might be wondering why we need two separate libraries to do something as basic as dealing with errors.</p><p>  前面我提到了两个不同的库，无论如何和thiserror（尽管都是同一作者dtolnay）。您可能想知道为什么我们需要两个独立的库来做一些基本的处理错误的工作。</p><p> It took me a moment to appreciate this distinction, but there’s value in approaching error handling differently between libraries and applications as they tend to have different concerns:</p><p> 我花了一点时间来欣赏这种区别，但是在库和应用程序之间以不同的方式处理错误时，由于它们往往存在不同的关注点，因此它们具有一定的价值： </p><p> Libraries should focus on  producing meaningful, structured error types/variants.This allows applications to easily differentiate various error cases.</p><p>库应专注于产生有意义的，结构化的错误类型/变量，这使应用程序可以轻松地区分各种错误情况。</p><p>  Libraries may want to cast errors from one type to another.An IO error should likely be wrapped by a high-level error type provided by the library. Otherwise an IO error in library  foo cannot be distinguished from a similar IO error in library  bar.</p><p>  库可能希望将错误从一种类型转换为另一种类型。IO错误应该由库提供的高级错误类型包装。否则，无法将库foo中的IO错误与库栏中的类似IO错误区分开。</p><p> Not doing so also requires the consumer to know library internals.For example, is it just IO errors that might be returned? What about HTTP errors that might originate from an HTTP client internal to the library?</p><p> 不这样做还需要使用者知道库的内部知识，例如，可能返回的仅仅是IO错误吗？可能来自库内部的HTTP客户端的HTTP错误呢？</p><p> Libraries must be careful when changing errors or creating new errors, as these can easily introduce breaking changes for consumers.They may produce new errors internally, but these are unlikely to require special structure and can be more easily changed at will.</p><p> 图书馆在更改错误或创建新错误时必须小心谨慎，因为它们很容易为消费者带来重大变化，它们可能在内部产生新错误，但这些错误不太可能需要特殊的结构并且可以更轻松地进行更改。</p><p> Where libraries return errors, applications decide if and how those errors are formatted and displayed to users.</p><p> 库在哪里返回错误，应用程序决定是否格式化这些错误以及如何将这些错误格式化并显示给用户。</p><p> Applications may also want to parse and inspect errors, for example to forward them to exception tracking services or to retry operations when doing so is deemed to be safe.</p><p> 应用程序可能还希望解析和检查错误，例如将错误转发给异常跟踪服务或在认为安全的情况下重试操作。</p><p> Additionally, and I think this is quite important,  libraries should always use  std::Result together with an error type implementing  std::error::Error in their public APIs.Custom result types like  failure::Fail may not compose well with other parts of your user’s code and force them to learn yet another library.</p><p> 此外，我认为这很重要，库应始终使用std :: Result以及在其公共API中实现std :: error :: Error的错误类型.fail :: Fail之类的自定义结果类型可能无法与其他类型很好地组合用户代码的一部分，并迫使他们学习另一个库。 </p><p>  Coming back to our word counting example, imagine we want to make  count_words available as a public library.You wouldn’t normally do this for such a small and simple piece of code, but there can be value in making functionality available through public crates within larger projects.</p><p>回到我们的字数统计示例，想象一下我们想将count_words作为公共库提供。您通常不会在这么小的和简单的代码中就这样做，但是在通过内部的公共包装箱提供功能方面会有价值较大的项目。</p><p> As a demonstration, we can define boundaries in our word counter to separate this code into a library and an application part.</p><p> 作为演示，我们可以在字计数器中定义边界，以将该代码分为库和应用程序部分。</p><p> We’ll extract  count_words into a  library crate named  wordcounter.I’ll highlight relevant parts below, but if you want to skip ahead, you can find the complete  src/wordcounter.rs on GitHub.</p><p> 我们将count_words提取到名为wordcounter的库箱中。下面将重点介绍相关部分，但是如果您要跳过，可以在GitHub上找到完整的src / wordcounter.rs。</p><p> Everything outside of  count_words is our application code.This is going to live in a  binary crate which we’ll call  rwc (for  Rust Word Count — very original, I know).The relevant files for this are  src/main.rs and  src/lib.rs.</p><p> count_words之外的所有内容都是我们的应用程序代码。它将生活在一个称为rwc的二进制条板箱中（Rust Word Count –我知道这很原始）。与此相关的文件是src / main.rs和src /lib.rs。</p><p>  For our  wordcounter library, we’ll define a top-level error type called  WordCountError.This enum has error variants for every possible error that our library might encounter.</p><p>  对于字计数器库，我们将定义一个称为WordCountError的顶级错误类型。此枚举具有库可能遇到的每种可能错误的错误变体。</p><p> This is where  thiserror comes into play.While we could implement this by hand,  thiserror allows us to avoid writing lots of boilerplate code:</p><p> 这是此错误起作用的地方。虽然我们可以手动实现此错误，但此错误使我们可以避免编写大量样板代码：</p><p> use   thiserror:: Error ;    /// WordCountError enumerates all possible errors returned by this library.  #[derive(Error, Debug)]   pub   enum  WordCountError   {    /// Represents an empty source. For example, an empty text file being given    /// as input to `count_words()`.    #[error( &#34;Source contains no data&#34; )]    EmptySource ,     /// Represents a failure to read from input.    #[error( &#34;Read error&#34; )]    ReadError   {   source:  std:: io:: Error   },     /// Represents all other cases of `std::io::Error`.    #[error(transparent)]    IOError ( #[from]   std:: io:: Error ),   }</p><p> 使用thiserror :: Error; /// WordCountError枚举此库返回的所有可能的错误。 ＃[derive（Error，Debug）] pub枚举WordCountError {///表示一个空源。例如，给///一个空的文本文件作为`count_words（）`的输入。 ＃[error（＆＃34; Source不包含任何数据＆＃34;）] EmptySource，///表示从输入中读取失败。 ＃[error（＆＃34; Read error＆＃34;）] ReadError {源：std :: io :: Error}，///表示所有其他情况`std :: io :: Error`。 ＃[error（transparent）] IOError（＃[from] std :: io :: Error），} </p><p> (Quoting the official documentation:  “Thiserror deliberately does not appear in your public API. You get the same thing as if you had written an implementation of  std::error::Error by hand, and switching from handwritten impls to thiserror or vice versa is not a breaking change.&#34;)</p><p>（引用官方文档：“故意在公共API中未出现Thiserror。您将获得与手工编写std :: error :: Error实现，然后从手写的impls切换到thiserror或相反的效果相同的东西。并非重大变化。＆＃34;）</p><p>     Compared to the previous version, our new code is a lot more specific.Users now get a lot more insight into the possible error cases that might be returned.As an added benefit, we also no longer have to Box  Error because the size of  WordCountError can be determined at compile time.</p><p>     与以前的版本相比，我们的新代码更加具体，用户现在可以更深入地了解可能返回的错误情况，此外，由于WordCountError的大小，我们也不再需要Box Error可以在编译时确定。</p><p>   EmptySource may be considered an error related to our business domain.We can return this from our  count_words function using the following code:</p><p>   EmptySource可能被视为与我们的业务领域有关的错误。我们可以使用以下代码从count_words函数返回此错误：</p><p>  ReadError is an example of wrapping a lower-level error into our high-level library error.This is used to return a meaningful error for read errors and can be seen here:</p><p>  ReadError是将低级错误包装到高级库错误中的示例，用于为读取错误返回有意义的错误，可以在此处看到：</p><p> for   line   in   reader . lines ()   {    let   line   =   line . map_err ( | source |   WordCountError:: ReadError   {   source   }) ? ;    for   _word   in   line . split_whitespace ()   {    wordcount   +=   1 ;    }   }</p><p> 为读者排队。 lines（）{让line = line。 map_err（|源| WordCountError :: ReadError {源}）？ ;对于_word行。 split_whitespace（）{wordcount + = 1; }}</p><p> The most interesting code in the snippet above is found on line 2, which contains  line.map_err(|source| WordCountError::ReadError { source })?;.There’s quite a lot going on here though, so let’s unpack this step by step:</p><p> 上面代码段中最有趣的代码位于第2行，其中包含line.map_err（| source | WordCountError :: ReadError {source}）？;。虽然这里有很多工作，所以让我们逐步解压缩：</p><p> We iterate over the lines from  reader, which get returned as  io::Result&lt;String&gt; because read operations can fail.</p><p> 我们遍历来自阅读器的行，这些行以io :: Result＆lt; String＆gt;返回。因为读取操作可能会失败。 </p><p> If the result is of the  Err variant, our use of  map_err() transforms the error value embedded inside this result from an  io::Error into a  WordCountError::ReadError. If the result is of the  Ok variant, it remains unchanged.</p><p>如果结果是Err变体，则我们使用map_err（）会将嵌入在该结果中的错误值从io :: Error转换为WordCountError :: ReadError。如果结果是Ok变体，则它保持不变。</p><p> We then unpack the result with the  ? operator. If it was of the  Ok variant then this is assigned to the variable  line. If it was of the  Err variant, the function exits here, returning this as the return value (remember the return type is  Result&lt;u32, WordCountError&gt;).</p><p> 然后，我们用？解压结果。操作员。如果它是Ok变体，则将其分配给变量行。如果是Err变体，则函数在此处退出，将其作为返回值返回（请记住，返回类型为Result＆lt; u32，WordCountError＆gt;）。</p><p> Because we encapsulate  io::Error under the  source attribute of  WordCountError::ReadError, our context/error chain remains intact.This ensures  anyhow, which we’ll use on the application side of things below, ends up displaying both errors   5.</p><p> 因为我们将io :: Error封装在WordCountError :: ReadError的source属性下，所以我们的上下文/错误链保持不变。这确保了我们在以下应用程序端使用的方式最终会显示这两个错误5。</p><p>  At this point, it’s worth noting errors may use  error(transparent) to forward the  source and  Display methods straight through to an underlying error without adding an additional message.This can be seen in the  WordCountError::IOError case which acts as a “catch-all” variant for all other IO errors.</p><p>  在这一点上，值得注意的是，错误可以使用error（透明）将源方法和Display方法直接转发给基础错误，而无需添加其他消息。这可以在WordCountError :: IOError案例中看到，它充当“捕获” -all”所有其他IO错误的变体。</p><p> If we didn’t care for the specialized  WordCountError::ReadError variant, this means we could have also written our code as follows, in which case we no longer need to use  map_err() and can use  ? directly:</p><p> 如果我们不关心特殊的WordCountError :: ReadError变体，则意味着我们也可以按照以下方式编写代码，在这种情况下，我们不再需要使用map_err（）并可以使用？直：</p><p>  With this pattern, we avoid adding additional error wrapping code while still transforming errors into our high-level  WordCountError in order to keep our public API clean.</p><p>  使用这种模式，我们避免添加其他错误包装代码，同时仍将错误转换为高级WordCountError，以保持公共API的整洁。</p><p>  With the API above in place, we can adjust the rest of our code to handle application-level concerns like argument parsing and invocation of  wordcounter::count_words.</p><p>  使用上面的API，我们可以调整其余代码以处理应用程序级的问题，例如参数解析和wordcounter :: count_words的调用。 </p><p>  // Some `use` statements have been omitted here for brevity  use   anyhow:: { Context ,   Result };    fn  main ()  -&gt;  Result &lt; () &gt;   {    for   filename   in   env:: args (). skip ( 1 ). collect:: &lt; Vec &lt; String &gt;&gt; ()   {    let   mut   reader   =   File:: open ( &amp; filename ). context ( format ! ( &#34;unable to open &#39;{}&#39;&#34; ,   filename )) ? ;    let   wordcount   =    count_words ( &amp; mut   reader ). context ( format ! ( &#34;unable to count words in &#39;{}&#39;&#34; ,   filename )) ? ;    println ! ( &#34;{} {}&#34; ,   wordcount ,   filename );    }    Ok (())   }</p><p>//为了简洁起见，这里省略了一些`use`语句：{{Context，Result}; fn main（）->结果＆lt; （）＆gt; {表示env :: args（）中的文件名。跳过（1）。收集：＆lt; Vec＆lt;字符串＆gt;＆gt; （）{let mut reader = File :: open（＆amp; filename）。上下文（格式！（无法打开＆＃39; {}＆＃39;＆＃34;，文件名））？ ;让wordcount = count_words（＆amp; mut reader）。上下文（格式！（＆＃34;无法计算＆＃39; {}＆＃39;＆＃34;，文件名）中的单词））？ ; println！ （＆＃34; {} {}＆＃34;，wordcount，filename）； }    好 （（））   }</p><p>   Instead of having to create custom error types or using  std::Result&lt;T, Box&lt;dyn Error&gt;&gt; everywhere, we can use   anyhow::Result as a more convenient type with less boilerplate.</p><p>   不必创建自定义错误类型或使用std :: Result＆lt; T，而使用Box＆lt; dyn Error＆gt;＆gt;。在任何地方，我们都可以使用anyhow :: Result作为更方便的类型，并且减少样板。</p><p> In the case of  main() above, this allows us to directly return  anyhow::Result&lt;()&gt;.It feels like a minor thing, but I find that being able to focus only on the success data type without having to annotate additional error types adds a lot of clarity here.</p><p> 在上面的main（）情况下，这使我们可以直接返回:: Result＆lt;（）＆gt;这似乎是一件小事，但我发现能够仅关注成功数据类型而无需注释其他错误类型在这里增加了很多清晰度。</p><p>  The   anyhow::Context trait, which we brought in via  use anyhow::Context above, enables a  context() method on  Result types.This lets us wrap/annotate errors with more information in a way that is more ergonomic to write than the  map_err approach used in the library code:</p><p>  通过上面使用anyhow :: Context引入的anyhow :: Context特性，它对Result类型启用了context（）方法。这使我们可以用比编写更加符合人体工程学的方式包装/注释错误，并提供更多信息。库代码中使用的map_err方法：</p><p> let   mut   reader   =   File:: open ( &amp; filename )    . context ( format ! ( &#34;unable to open &#39;{}&#39;&#34; ,   filename )) ? ;    let   wordcount   =   count_words ( &amp; mut   reader )    . context ( format ! ( &#34;unable to count words in &#39;{}&#39;&#34; ,   filename )) ? ;</p><p> let mut reader = File ::打开（＆amp; filename）。上下文（格式！（无法打开＆＃39; {}＆＃39;＆＃34;，文件名））？ ;让wordcount = count_words（＆amp; mut reader）。上下文（格式！（＆＃34;无法计算＆＃39; {}＆＃39;＆＃34;，文件名）中的单词））？ ;</p><p> This provides valuable information to the user of the application about what was being attempted should an error occur.With these calls in place our errors will now be displayed as follows:</p><p> 这为应用程序的用户提供了有关发生错误时正在尝试的操作的有价值的信息。通过这些调用，我们的错误现在将显示如下：</p><p> $ cargo run --quiet -- words.txtError: unable to open &#39;words.txt&#39;Caused by: No such file or directory (os error 2)</p><p> $ cargo run --quiet-words.txt错误：无法打开＆＃39; words.txt＆＃39;原因：没有这样的文件或目录（操作系统错误2） </p><p> $ cargo run --quiet -- words.txtError: unable to count words in &#39;words.txt&#39;Caused by: 0: Error encountered while reading from input 1: read: broken pipe</p><p>$ cargo run --quiet-words.txt错误：无法计算＆＃39; words.txt＆＃39;中的单词造成原因：0：从输入中读取时遇到错误1：读取：管道损坏</p><p> In both cases our error message now includes the name of the file we were working with.We also describe what high-level operation was being attempted when the problem occurred.</p><p> 在这两种情况下，我们的错误消息现在都包含正在使用的文件的名称。我们还描述了发生问题时正在尝试的高级操作。</p><p>  You’ll notice we didn’t have to write any extra error formatting code to get these nice error displays.All we had to do is change the return type of  main into anyhow’s  Result type.</p><p>  您会注意到，我们不必编写任何额外的错误格式代码即可显示这些精美的错误消息。我们要做的就是将main的返回类型更改为Result类型。</p><p> It isn’t necessary to rely on this implicit behavior of returning a  Result from  main.We could choose to move all of our code into a  run function instead and then write  main as follows:</p><p> 不必依赖于从ma​​in返回Result的隐式行为。我们可以选择将所有代码移到run函数中，然后按以下方式编写main：</p><p>   One advantage of this approach (beyond having more control about how our program exits, such as via different exit code) is that it allows us to change how the message is formatted.</p><p>   这种方法的优势（除了可以更好地控制程序的退出方式，例如通过不同的退出代码），还可以使我们更改消息的格式。</p><p> For example, if we use  eprintln!(&#34;{:#?}&#34;, err) instead (note the  {:#?} vs  {:?}), we’ll get a struct-style representation:</p><p> 例如，如果我们使用eprintln！（＆＃34; {：＃？}＆＃34 ;, err）代替（注意{：＃？}与{：？}），我们将获得结构样式表示：</p><p> $ cargo run --quiet -- words.txtError { context: &#34;unable to count words in \&#39;words.txts\&#39;&#34;, source: ReadError { source: Custom { kind: BrokenPipe, error: &#34;read: broken pipe&#34;, }, },}</p><p> $ cargo run --quiet-words.txtError {上下文：＆＃34;无法计算\＆＃39; words.txts \＆＃39;＆＃34;中的单词，来源：ReadError {来源：自定义{种类：BrokenPipe，错误：＆＃34;阅读：管道破损＆＃34 ;、}，}，} </p><p>   So far we haven’t talked about backtraces, which are a common tool to use when debugging complex issues.</p><p>到目前为止，我们还没有讨论过回溯，回溯是调试复杂问题时常用的工具。</p><p> Anyhow also allows us to capture and display a backtrace when an error happens.At the moment, support for backtraces is only available on  nightly Rust though, as the  std::backtrace module is currently a nightly-only experimental API.</p><p> 无论如何，也允许我们在发生错误时捕获并显示回溯痕迹。目前，仅在每晚Rust上才提供对回溯痕迹的支持，因为std :: backtrace模块当前是仅夜间实验的API。</p><p>  $ RUST_BACKTRACE=1 cargo run --quiet -- words.txtError: unable to count words in &#39;words.txt&#39;Caused by: 0: Error encountered while reading from input 1: read: broken pipe 0: &lt;E as anyhow::context::ext::StdError&gt;::ext_context at /home/zoni/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.28/src/backtrace.rs:26 1: anyhow::context::&lt;impl anyhow::Context&lt;T,E&gt; for core::result::Result&lt;T,E&gt;&gt;::context::{{closure}} at /home/zoni/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.28/src/context.rs:50 2: core::result::Result&lt;T,E&gt;::map_err at /rustc/2454a68cfbb63aa7b8e09fe05114d5f98b2f9740/src/libcore/result.rs:612 3: anyhow::context::&lt;impl anyhow::Context&lt;T,E&gt; for core::result::Result&lt;T,E&gt;&gt;::context at /home/zoni/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.28/src/context.rs:50 4: wordcount::run at src/lib.rs:58 5: rwc::main at src/main.rs:9 6: std::rt::lang_start::{{closure}} at /rustc/2454a68cfbb63aa7b8e09fe05114d5f98b2f9740/src/libstd/rt.rs:67 7: std::rt::lang_start_internal::{{closure}} at src/libstd/rt.rs:52 std::panicking::try::do_call at src/libstd/panicking.rs:297 std::panicking::try at src/libstd/panicking.rs:274 std::panic::catch_unwind at src/libstd/panic.rs:394 std::rt::lang_start_internal at src/libstd/rt.rs:51 8: std::rt::lang_start at /rustc/2454a68cfbb63aa7b8e09fe05114d5f98b2f9740/src/libstd/rt.rs:67 9: main 10: __libc_start_main 11: _start</p><p>  $ RUST_BACKTRACE = 1货物运行--quiet-words.txt错误：无法计算＆＃39; words.txt＆＃39;中的单词原因：0：从输入1读取时遇到错误1：读取：管道破裂0：＆lt ; E无论如何:: context :: ext :: StdError＆gt; ::: ext_context位于/home/zoni/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.28/src/backtrace.rs:26 1 ：anyhow :: context ::＆lt; impl anyhow :: Context＆lt; T，E＆gt;对于/home/zoni/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.28/上的core :: result :: Result＆lt; T，E＆gt;＆gt; :: context :: {{closure}} src / context.rs：50 2：core :: result :: Result＆lt; T，E＆gt; :: map_err at /rustc/2454a68cfbb63aa7b8e09fe05114d5f98b2f9740/src/libcore/result.rs:612 3：anyhow :: context ::＆lt; impl无论如何：: Context＆lt; T，E＆gt;对于core :: result :: Result＆lt; T，E＆gt;＆gt; ::: context位于/home/zoni/.cargo/registry/src/github.com-1ecc6299db9ec823/anyhow-1.0.28/src/context.rs:50 4：wordcount ::在src / lib.rs：58运行5：rwc :: main在src / main.rs：9 6：std :: rt :: lang_start :: {{closure}}在/ rustc / 2454a68cfbb63aa7b8e09fe05114d5f98b2f9740 / src / libstd / rt.rs：67 7：std :: rt :: lang_start_internal :: {{closure}} at src / libstd / rt.rs：52 std :: panicking :: try :: do_call at src / libstd / panicking.rs:297 std :: panicking ::在src / libstd / panicking.rs：274 std :: panic :: catch_unwind在src / libstd / panic.rs：394 std :: rt :: lang_start_internal在src / libstd /rt.rs:51 8：std :: rt :: lang_start位于/rustc/2454a68cfbb63aa7b8e09fe05114d5f98b2f9740/src/libstd/rt.rs:67 9：main 10：__libc_start_main 11：_start</p><p> I generally find Rust’s backtraces too cryptic and confusing to be of much help so their lack of support on the stable channel hasn’t been a problem for me personally.Having the chain of errors displayed by  anyhow has been more than sufficient for me so far.</p><p> 我通常发现Rust的回溯图太神秘且令人困惑，以至于无济于事，因此就我个人而言，在稳定渠道上缺乏支持并不是我个人的问题。到目前为止，无论如何显示的错误链对我来说已经绰绰有余。</p><p>  This is not the end of Rust’s error story.Changes are still underway and it remains to be seen whether these two libraries are going to remain as favored as they are today.</p><p>  这还不是Rust的错误故事的终点。变化仍在进行之中，这两个库是否会像今天一样受到青睐尚待观察。</p><p> One thing is for sure though:The story for error handling has come a long way and with the current state of Rust, you can write very robust software in a pleasant and practical manner.</p><p> 但是可以肯定的是：关于错误处理的故事已经走了很长一段路，并且在Rust的当前状态下，您可以以一种愉快而实用的方式编写非常强大的软件。</p><p> I hope you found this article useful.If you did, please consider sending a quick thank you note, either  through email or via a tweet to  @NickGroenen.</p><p> 希望本文对您有所帮助，请考虑通过电子邮件或推文向@NickGroenen发送感谢信。 </p><p>  There’s a bit of  discussion happening on Reddit and one comment posted there seems worth including here. u/Yaahallo writes:</p><p>Reddit上正在进行一些讨论，并在此处发布了一条评论，似乎值得在此添加。 u / Yaahallo写道：</p><p> I think the bit about error handling being different depending on if you’re writing a library vs an application is simplification that’s common in the rust community but also a source of confusion.</p><p> 我认为错误处理的不同之处取决于您是在编写库还是在编写应用程序，这是rust社区中的常见简化，也是造成混乱的根源。</p><p> The reasons for using anyhow vs thiserror aren’t really based on if it’s a library or an application, it’s actually about whether or not you need to handle errors or report them.</p><p> 无论如何，使用此错误与此错误的原因并不完全基于它是库还是应用程序，而实际上是关于您是否需要处理错误或报告错误。</p><p> Libraries often want to support as many error handling use cases for their consumers as possible.This ends up meaning that they want to export error types that are both handleable (aka an enum) and reportable (aka implements std::error::Error).</p><p> 库通常希望为其使用者提供尽可能多的错误处理用例，这最终意味着他们希望导出既可处理（又称枚举）又可报告（也实现std :: error :: Error）的错误类型。 。</p><p> Applications on the other hand often end up doing the error handling or reporting.For handling you don’t need a library usually, you just use match.For reporting you do need an error type, or more accurately an error reporting type, which is exactly what anyhow::Error is designed to do.</p><p> 另一方面，应用程序通常最终会执行错误处理或报告。对于处理，您通常不需要库，您只需要使用match;对于报告，您确实需要错误类型，或更准确地说是错误报告类型，即到底是什么设计了：: Error的目的。</p><p> Burntsushi (from  ripgrep fame) agrees with a lot of my points but also  challenges the use of proc-macro based libraries like  thiserror for certain use cases, primarily due to the increase in compilation times that result from their use.To add to his point, he shows us how to write the  WordCountError implementation from this article by hand.</p><p> Burntsushi（来自ripgrep知名度）同意我的许多观点，但也对某些用例挑战了使用基于proc-macro的库（例如thiserror），这主要是由于使用它们导致编译时间增加。 ，他向我们展示了如何手工编写本文中的WordCountError实现。</p><p> And there’s also an interesting thread regarding  the performance implications of using  context() versus  with_context().</p><p> 关于使用context（）与with_context（）的性能影响，还有一个有趣的话题。 </p><p> This is not meant to be taken as criticism.Introducing the entire problem space and all of the different considerations to handling errors does not feel like a good fit for the purpose of the book.That being said, from a newcomer perspective, more official guidance on this topic somewhere that is easily discoverable and accessible would be nice to have.  ↩︎</p><p>但这并不意味着批评。引入整个问题空间以及处理错误的所有不同考虑因素似乎并不适合本书的目的，也就是说，从新手的角度来看，更多的是官方指导在这个主题上，一个易于发现和访问的地方将是一件很高兴的事情。 ↩︎</p><p> These include improvements around  Display, a proper  source method and support for a backtrace API.See  RFC 2504 and its associated  tracking issue for details.  ↩︎</p><p> 这些包括围绕Display的改进，适当的源方法以及对backtrace API的支持。有关详细信息，请参阅RFC 2504及其相关的跟踪问题。 ↩︎</p><p> I can highly recommend reading  Error Handling Survey by Yoshua Wuyts for an overview of various alternatives.  ↩︎</p><p> 我强烈建议阅读Yoshua Wuyts的《错误处理调查》，以概述各种替代方案。 ↩︎</p><p> count_words() takes as parameter any type which implements the trait  std::io::Read.Implementors of the Read trait are called  readers. Readers are defined by one required method,  read().  ↩︎</p><p> count_words（）将实现特征std :: io :: Read的任何类型作为参数。Read特征的实现者称为阅读器。读者通过一种必需的方法read（）进行定义。 ↩︎</p><p> Because this uses the  source() method on  std::error::Error it’s not specific to  anyhow.It will work with any library supporting  RFC 2504.  ↩︎</p><p> 因为这是在std :: error :: Error上使用source（）方法，所以它不是特定的。它将与支持RFC 2504的任何库一起使用。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://nick.groenen.me/posts/rust-error-handling/">https://nick.groenen.me/posts/rust-error-handling/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/结构化/">#结构化</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>