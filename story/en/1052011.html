<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>叫狼的安全扫描仪 The security scanner that cried wolf</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The security scanner that cried wolf<br/>叫狼的安全扫描仪 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-13 00:19:44</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/683eefd0c651c21887d33a6611373ed2.png"><img src="http://img2.diglog.com/img/2021/3/683eefd0c651c21887d33a6611373ed2.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>If you run a security scanner on your Docker image, you might be in for a shock: often you’ll be warned of dozens of security vulnerabilities, even on the most up-to-date image.After the third or fourth time you get this result, you’ll start tuning the security scanner out.</p><p>如果您在Docker Image上运行安全扫描仪，您可能正在震惊：通常您通常会警告数十个安全漏洞，即使是最新的图像。在您获得的第三或第四次此结果，您将开始调整安全扫描仪。</p><p> Eventually, you won’t pay attention to the security scanner at all—and you might end up missing a real security vulnerability that slipped through.</p><p> 最终，您不会关注所有人的安全扫描仪 - 您可能最终缺少缺少的真正安全漏洞。</p><p> This is not your fault: the problem is the way many security scanners report their results.So let’s see what they output, why it’s problematic, and how to get more useful security scanner results.</p><p> 这不是您的错：问题是许多安全扫描仪报告其结果的方式。所以让我们看看它们的输出，为什么它是有问题的，以及如何获得更多有用的安全扫描仪结果。</p><p>  Let’s say I create the following Dockerfile, using the latest stable release of Debian at the time of writing:</p><p>  假设我创建了以下Dockerfile，在撰写本文时使用最新稳定的Debian发布：</p><p>    And finally I push it to a well-known Docker image registry service.I won’t mention it by name because this isn’t about any specific service, it’s about a general problem.</p><p>    最后我将它推到一个众所周知的Docker Image Registry Service.i将不提到它的名称，因为这不是任何特定的服务，它是关于一般问题。</p><p> The image registry performs a security scan, and it comes back saying there are 62 different security vulnerabilities in this image.One of them is high severity!</p><p> 图像注册表执行安全扫描，并回到此图像中有62个不同的安全漏洞。它们的严重程度很高！</p><p>  Except… this image has every security update put out by Debian.It’s the stable release, Debian is a well-respected Linux distribution that puts out timely security updates—what’s going on?</p><p>  除了......这个图像具有Debian的每一个安全更新。它是稳定的发布，Debian是一个备受尊敬的Linux发行版，它会出现及时的安全更新 - 发生了什么？ </p><p>  As we’ve seen, pretty much every single image based on Debian Stable is going to be insecure.If that’s your default base image (as it is for most official Docker images that aren’t Alpine-based), that means  all your images are going to be marked as insecure.</p><p>正如我们所见，几乎基于Debian稳定的每一个图像都将是不安全的。如果这是您的默认基础图像（因为它是基于高山不是基于高山的最官方Docker图像），这意味着您的所有图像将被标记为不安全。</p><p> Which means you’re going to start ignoring these results; not a good outcome!</p><p> 这意味着你将开始忽略这些结果;不是一个好的结果！</p><p> Alternatively, you might want to try to fix these vulnerabilities—but how, exactly?In this example I’ve made sure to install all updates, what else can you do?</p><p> 或者，您可能希望尝试修复这些漏洞 - 但是究竟如何？在此示例中，我务必安装所有更新，您还能做什么？</p><p>  The problem with the security scanner results is that it’s listing CVEs that are never going to be fixed in this release of Debian Stable.In fact, some of them will  never get fixed, in this or any future release.This is due to a number of reasons:</p><p>  安全扫描仪结果的问题是它的列表CVES永远不会在此版本的Debian稳定中修复。事实上，其中一些将永远不会修复，在此或任何未来的发布中。这是由于一个数字原因：</p><p> It’s not something that can be fixed within the boundaries of a stable long-term-support release.</p><p> 它不是可以在稳定的长期支持释放的边界内固定的东西。</p><p> Luckily, many of these vulnerabilities are also irrelevant to most or all container runtime environments.</p><p> 幸运的是，许多这些漏洞也与大多数或所有集装箱运行时环境无关。</p><p> To give you a sense of what I’m talking about, let’s look at a few of the vulnerabilities on the list.</p><p> 让您了解我所谈论的内容，让我们看看列表中的一些漏洞。 </p><p>  Sounds bad, doesn’t it?But notice it’s from 2017—why hasn’t it been closed since?</p><p>听起来很糟糕，不是吗？但是注意到它是从2017年开始的 - 为什么它没有关闭？</p><p>  The xdr_bytes and xdr_string functions in the GNU C Library (aka glibc or libc6) 2.25 mishandle failures of buffer deserialization, which allows remote attackers to cause a denial of service (virtual memory allocation, or memory consumption if an overcommit setting is not used) via a crafted UDP packet to port 111, a related issue to CVE-2017-8779.</p><p>  GNU C库（AKA Glibc或Libc6）中的XDR_Bytes和XDR_String函数2.25缓冲区反序列化的失败，这允许远程攻击者导致拒绝服务（如果未使用过度光彩设置，则虚拟内存分配或内存消耗）通过将UDP数据包制成到Port 111，CVE-2017-8779的相关问题。</p><p> First, unless you’re running an NFS server or client inside your container—which seems highly unlikely—this isn’t something you need to worry about.</p><p> 首先，除非您在容器内运行NFS服务器或客户端 - 似乎非常不可能 - 这不是您需要担心的。</p><p> Second, if we follow the links we will eventually discover that  the maintainers dispute this is a glibc issue, and consider it an application vulnerability.Their feeling is that whoever calls these APIs needs to do it in the appropriate way to make it secure.So seems like this is never going to get fixed in glibc.</p><p> 其次，如果我们按照链接，我们最终会发现维护者争议这是一个Glibc问题，并考虑它的应用程序漏洞。众多人的感觉是，无论谁拨打这些API都需要以适当的方式做到这一点来使其能够实现它。所以似乎这永远不会在glibc中得到修复。</p><p>   chroot in GNU coreutils, when used with –userspec, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal’s input buffer.</p><p>   在GNU Coreutils中的Chroot，与-Userspec一起使用时，允许本地用户通过制作的TioCSTI IOCTL呼叫将字符推向终端的输入缓冲区。</p><p> First, you’re unlikely to be relying on the  chroot command-line tool for security inside a container.</p><p> 首先，您不太可能依赖Chroot命令行工具进行容器内的安全性。</p><p> Second, it seems the maintainers aren’t going to fix this; there’s a note in the Debian security tracker saying:</p><p> 其次，似乎维护者不会解决这个问题; Debian安全跟踪器中有一个说明： </p><p> Restricting ioctl on the kernel side seems the better approach, but rejected by Linux upstream.Fixing this issue via setsid() would introduce regressions.</p><p>限制内核方面的IOCTL似乎更好的方法，但是通过Linux上游拒绝。通过SetsID（）将此问题介绍回归。</p><p> Looking further, it sounds like the developers have added a new option that makes this tool more secure, but default behavior isn’t going to change.There isn’t much Debian can do about this without breaking compatibility.</p><p> 看起来它听起来像开发人员添加了一个新的选项，使这个工具更安全，但默认行为不会发生变化。没有太多的debian可以在没有破坏兼容性的情况下做到这一点。</p><p>   stack_protect_prologue in cfgexpand.c and stack_protect_epilogue in function.c in GNU Compiler Collection (GCC) 4.1 through 8 (under certain circumstances) generate instruction sequences when targeting ARM targets that spill the address of the stack protector guard, which allows an attacker to bypass the protection of -fstack-protector, -fstack-protector-all, -fstack-protector-strong, and -fstack-protector-explicit against stack overflow by controlling what the stack canary is compared against.</p><p>   stack_protect_prologue在cfgexpand.c和stack_protect_epileogue中的gnu编译器集合（gcc）4.1到8（在某些情况下）在捕获堆栈保护器警卫地址的ARM目标时生成指令序列，这允许攻击者绕过保护 - 保护器，-fstack-protector-all，-fstack-protector-strong，和-fstack-protector通过控制堆栈金丝雀与堆栈溢出而明确。</p><p> Basically, your C code will be more vulnerable to stack overflow attacks, if you’re running on ARM.Unless you’re using Graviton instances on AWS, chances are you’re on x86_64, and this CVE is irrelevant.</p><p> 基本上，如果您在ARM.UNLES上运行，您的C代码将更容易受到堆栈溢出攻击，即时您正在使用AWS上的Graviton实例，您可以在x86_64上进行机会，而且这个cve是无关紧要的。</p><p> From Debian’s perspective, they’re not going to change to a major new version of GCC in a stable release.And while they will backport security fixes when possible, in this case they say that’s it’s “too intrusive to backport.”</p><p> 从Debian的角度来看，他们不会在稳定的版本中改变为GCC的一个主要的新版本。当他们将在可能的情况下，他们将在可能的情况下，在这种情况下，他们说这是“过于侵入的侵入性”。</p><p> If you do need this fix, you can’t get it within the confines of the Debian Buster stable release; it will only be available when a new Debian Stable ships with a newer major gcc release.</p><p> 如果您确实需要此修复，则无法在Debian Buster稳定发布的范围内获得它;只有新的Debian稳定的船用较新的GCC发布时，它只可用。</p><p>   Let’s create a Docker image based on their Universal Base Image, with the version matching RHEL 8, and install updates:</p><p>   让我们基于它们的通用基础映像创建Docker图像，版本匹配RHEL 8，并安装更新： </p><p>  If we run the resulting image through the same security scanner—there are no security vulnerabilities!</p><p>如果我们通过相同的安全扫描仪运行生成的图像 - 没有安全漏洞！</p><p>  Looking at the first two CVEs we considered above, RedHat came to the same decisions as Debian: both issues were closed as WONTFIX ( 1,  2).</p><p>  看着我们考虑的前两个CVES，RedHat与Debian相同的决定：这两个问题都被关闭为WONTFIX（1,2）。</p><p> So why does the Debian-based image have so many security vulnerabilities listed, and the RedHat one does not?It seems to be some sort of reporting or data issue.For security issues that are in the WONTFIX category, the vulnerability databases used by the security scanner have the security issues marked as closed for RedHat, but not for Debian.It’s unclear to me where in the chain of communication and interpretation this issue happens.</p><p> 那么为什么基于Debian的图像有这么多列出的安全漏洞，而RedHat没有？它似乎是某种报告或数据问题。对于WontFix类别中的安全问题，用于WONTFIX类别中的漏洞数据库安全扫描仪具有标记为redhat的安全问题，但不是debian.it对我不清楚，在沟通链和解释链中发生这种问题。</p><p> But while this is annoying, it doesn’t really tell us anything about the security of Debian vs. RedHat.It just means we get more useful security scanner output for RedHat.</p><p> 但是，虽然这很烦人，但它并没有真正告诉我们Debian与Redhat的安全性。它只是意味着我们为RedHat获得更多有用的安全扫描仪输出。</p><p>  Let’s take a step back and think about why we want a security vulnerability in the first place.</p><p>  让我们回来吧，想想为什么我们首先想要一个安全漏洞。</p><p> Unless you have the organizational resources to create custom security patches for 3rd-party software, which is unlikely, you are going to be relying on security updates from your Linux distribution of choice.Best practices for security include installing these updates as part of your Docker image build.</p><p> 除非您拥有组织资源来为第三方软件创建自定义安全修补程序，这不太可能，您将依赖于Linux发行版的安全更新。安全性的实践包括将这些更新作为Docker的一部分安装这些更新图像构建。</p><p> So the point of the security scanner is to catch cases where you’re forgotten to do that, or the update process failed (for example,  due to Docker build caching).</p><p> 因此，安全扫描仪的点是捕获您忘记执行此操作的情况，或者更新过程失败（例如，由于Docker Build Caching）。 </p><p> In other words, what you really want to know is whether you’ve failed to install security updates.</p><p>换句话说，你真正想知道的是你是否无法安装安全更新。</p><p> Luckily, many security vulnerability scanners have an option for this.The  command-line Trivy security scanner has an option called  --ignore-unfixed.The registry-based security scanner I used in this article has a checkmark to “Only show fixable”.</p><p> 幸运的是，许多安全漏洞扫描仪都有一个选项。命令行Trivy Security Scanner具有一个名为--ignore-Unixed的选项。本文中使用的基于注册表的安全扫描程序具有复选标记，以“仅显示可配置”复选标记。</p><p> So make sure to always use these options, and your security vulernability scanner output will become far more useful.</p><p> 因此，请务必始终使用这些选项，并且您的安全致力扫描仪输出将变得更加有用。</p><p> Sidenote: If you happen to work on a security scanner, please, make sure your scanner has a “show only fixable” option, and make sure it’s  on by default.</p><p> sidenote：如果您碰巧在安全扫描仪上工作，请确保扫描仪具有“仅显示可固定”选项，并确保默认情况下。</p><p>  Security scanners are useful for detecting vulnerabilities not just in your system packages, but also in  your Python dependencies, and even your own code.And since we’re talking about Docker, do make sure that  Docker build caching doesn’t break your security updates.</p><p>  安全扫描仪对于检测不仅在您的系统包中的漏洞，而且在您的Python依赖项中，甚至是您自己的代码，甚至是我们正在谈论Docker，确保Docker Build缓存不会破坏安全更新。</p><p> Looking at the bigger picture, one thing we’ve learned is that many security vulnerabilities never get fixed.Most are trivial and unlikely, it’s true, but maybe one of them happens to apply to your particular setup.And chances are there are many more serious vulnerabilities that haven’t been found yet.</p><p> 看着更大的画面，我们已经学到的一件事是许多安全漏洞永远不会得到修复。以上甚至很不可能，这是真的，但也许其中一个恰好适用于你的特定设置。有机会还有更多尚未发现的严重漏洞。</p><p> So you should to take further steps to ensure your Docker image is secure.Two examples:</p><p> 因此，您应该进一步措施确保您的Docker Image是Secure.two示例： </p><p> To reduce the risk from privilege escalation attacks,  don’t run as root and disable all capabilities.</p><p>要降低特权升级攻击的风险，请不要以root身份运行并禁用所有功能。</p><p>  Don’t write C and C++, and instead use memory-safe languages like Python, or Rust if you’re extending Python; as many as  70% of security vulnerabilities are due to memory unsafety.</p><p>  不要写C和C ++，而是使用像Python这样的内存安全语言，或者如果您正在扩展Python，则会生锈;多达70％的安全漏洞是由于内存不安全。</p><p>    Learn how to build fast, production-ready Docker images—read the rest of the  Docker packaging guide for Python.</p><p>    了解如何快速构建，生产就绪Docker图像 - 阅读Python的其他Docker打包指南。</p><p>        With as much as a dozen different intersecting technologies, and an unknown number of details to get right, Docker packaging isn&#39;t simple, especially for production.</p><p>        与十几个不同的交叉技术，以及未知数量的细节，以获得正确的，码头包装ISN＆＃39; T简单，特别是生产。</p><p> But you still need fast builds that save you time, and security best practices that keep you safe.</p><p> 但您仍然需要节省您的时间快速构建，以及让您安全的安全最佳实践。</p><p> Take the fast path to learning best practices, by using the   Python on Docker Production Handbook.</p><p> 通过在Docker生产手册上使用Python来获取最佳实践的快速路径。</p><p> Sign up for my newsletter, and join over 2600 Python developers and data scientists learning practical tools and techniques, from Docker packaging to testing to Python best practices, with a free new article in your inbox every week.</p><p> 注册我的时事通讯，加入超过2600多个Python开发人员和数据科学家学习实用工具和技术，从Docker包装到测试到Python最佳实践，每周在您的收件箱中有一个免费的新文章。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://pythonspeed.com/articles/docker-security-scanner/">https://pythonspeed.com/articles/docker-security-scanner/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/安全/">#安全</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/scanner/">#scanner</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>