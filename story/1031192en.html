<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>了解Unity Engine对象(Unity for Engineers#5)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">了解Unity Engine对象(Unity for Engineers#5)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-26 12:29:38</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/82f2f6e9b7caeacc0d69e7adfa12483a.jpg"><img src="http://img2.diglog.com/img/2020/10/82f2f6e9b7caeacc0d69e7adfa12483a.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>We already discussed Game Objects and Components as twoof the fundamental building blocks of the Unity Engine. Today, we’ll discusstheir programmatic representation.</p><p>我们已经讨论了游戏对象和组件作为Unity引擎的两个基本构件。今天，我们将讨论它们的程序表示。</p><p> This is   Unity for Software Engineers,a series for folks familiar with software development best practices seeking anaccelerated introduction to Unity as an engine and editor. More is coming overthe next few weeks, so  consider subscribing forupdates.</p><p>这是面向软件工程师的Unity for Software Engineers系列，面向熟悉软件开发最佳实践的人们，希望能够更快地介绍Unity作为引擎和编辑器。接下来的几周会有更多，所以考虑订阅更新。</p><p> The Unity Engine  runtime is primarily written in C++, and much of the Engine’sprimitives (such as the game objects and their components) live in C++ land.You’ll also know that the Unity Engine  API is in C#. The API gives you accessto all of Unity’s native objects in a way that—save for a few pitfallswe’ll discuss today—feels like intuitive, idiomatic C#.</p><p>Unity Engine运行时主要是用C++编写的，并且引擎的大部分原型(如游戏对象及其组件)都在C++环境中，您还会知道Unity Engine API是用C#编写的。API让你可以访问Unity的所有原生对象--除了我们今天要讨论的几个缺陷--感觉就像是直观的、惯用的C#。</p><p>   At the top of the Unity Object hierarchy sits   UnityEngine.Object. For themost part provides a  name string, an  int GetInstanceID() method, and a bunchof equality comparers.</p><p>Unity对象层次的顶部是UnityEngine.Object。因为大多数部分提供了一个名称字符串、一个int GetInstanceID()方法和一组相等比较器。</p><p> The class also provides a  static void Destroy(Object obj) method (and someoverloads) that destroys a  UnityEngine.Object and any of its subclasses. Whenan Object is destroyed, the  native part of the object is freed from memory,and the smaller  managed part will be garbage collected  at some point afterthere are no more references to it.</p><p>该类还提供了一个静态void销毁(Object Obj)方法(和一些重载)，用于销毁UnityEngine.Object及其任何子类。当一个对象被销毁时，该对象的本机部分将从内存中释放，而较小的托管部分将在不再有对它的引用之后的某个时候被垃圾回收。</p><p> Because your valid reference to a  UnityEngine.Object can point to a destroyednative object,  UnityEngine.Object overrides C#‘s  operator== and  operator!=to make a destroyed Object  appear null. Simply accessing methods on adestroyed object will return  NullReferenceException, albeit with a friendliererror message that tells you which object you were trying to access.</p><p>因为您对UnityEngine.Object的有效引用可以指向销毁的本机对象，所以UnityEngine.Object覆盖C#的运算符==和运算符！=，以使销毁的对象显示为空。简单地访问已销毁对象上的方法将返回NullReferenceException，尽管会有一条FriendlierError消息告诉您正在尝试访问哪个对象。</p><p>   Let’s start at a high-level: A GameObject inherits a name and instance ID fromits parent. Otherwise, conceptually, a GameObject</p><p>让我们从高层次开始：GameObject继承一个名称，实例ID来自父对象。否则，从概念上讲，GameObject。</p><p>    Let’s dig a bit deeper. When starting, most of the interesting stuff in aGameObject is in its  Components. A GameObject has at least one Component:its   Transform. ATransform describes the position and rotation of the GameObject. A Transformincludes helper properties that show an object’s  absolute world position androtation, as well as the position and rotation  relative to its parent. In theEditor, the Transform position and rotation are set from the  parent relativevariants.</p><p>让我们再深入挖掘一下。开始时，aGameObject中的大多数有趣的东西都在它的组件中。游戏对象至少有一个组件：它的变换。ATransform描述游戏对象的位置和旋转。变换包括辅助对象属性，这些属性显示对象的绝对世界位置和旋转，以及相对于其父对象的位置和旋转。在编辑器中，变换位置和旋转是从父相对变量设置的。</p><p> Since every GameObject has a Transform (and also, given that a Transform isfrequently needed/accessed), the GameObject directly exposes a Transform transform public property.</p><p>由于每个游戏对象都有一个变换(而且，假设变换是经常需要/访问的)，因此游戏对象直接公开变换公共属性。</p><p> You can access individual components from  T GetComponent&lt;T&gt;(), or lists ofcomponents from  T[] GetComponents&lt;T&gt;(), etc. These methods search through allcomponents on a GameObject and return ones with a compatible type (or null, ifnone exist in the singular case). Since these methods search through componentsand check type compatibility, it is often recommended to cache this lookup.</p><p>您可以从T GetComponent&lt；T&gt；()访问单个组件，或从T[]GetComponents&lt；T&gt；()访问组件列表等。这些方法搜索GameObject上的所有组件并返回兼容类型的组件(如果在单数情况下不存在，则返回NULL)。由于这些方法搜索组件并检查类型兼容性，因此通常建议缓存此查找。</p><p> If you are building/extending a GameObject by hand, you can always use T AddComponent&lt;T&gt;(). In most cases, however, you’re better off using theEditor.</p><p>如果您要手动构建/扩展游戏对象，则始终可以使用T AddComponent&lt；T&gt；()。然而，在大多数情况下，您最好使用编辑器。</p><p>  We have discussed serialization extensively throughout the series: as a fundamental conceptand in our tour of the Editor, when describing the Inspector,and the  practice of usingthe Inspector as an injection framework.</p><p>我们在整个系列中广泛讨论了序列化：作为一个基本概念，在我们的编辑器之旅中，在描述Inspector时，以及使用Inspector作为注入框架的实践。</p><p> Using tags. Every Game Object can have a  tag string. You can findobjects in the scene using that tag through the static functions GameObject.FindGameObjectsWithTag and  GameObject.FindGameObjectWithTag.A GameObject also exposes a public  bool CompareTag(string tag) method.</p><p>使用标签。每个游戏对象都可以有一个标记字符串。可以通过静态函数GameObject.FindGameObjectsWithTag和GameObject.FindGameObjectWithTag.GameObject使用该标记在场景中查找对象。GameObject还公开公共bool CompareTag(字符串标记)方法。</p><p> This is a quick-and-dirty way to get the job done, but is still a popularway. A common use of this in the wild is to have a  &#34;Player&#34; tag to findthe Player. Ideally, these methods should not be called every frame, so ifyou have to use them, consider caching the result.</p><p>这是一种既快捷又肮脏的完成工作的方法，但仍然是一种很受欢迎的方法。这在野外的一个常见用法是有一个玩家的标签来找到玩家。理想情况下，不应该每帧都调用这些方法，因此如果您必须使用它们，请考虑缓存结果。</p><p> Using layers. A layer is an  int between 0 and 31. Every Game Object isin exactly one layer.</p><p>使用图层。层是介于0和31之间的整数。每个游戏对象正好在一个层中。</p><p> While you can’t directly look up all objects in a layer, if you already havea reference to a GameObject (e.g., in a collision event), you can check aGameObject against a  LayerMask. A LayerMask is typically used in functions like  Physics.Raycast(). Thisallows you to find objects with colliders intersecting with a given  ray.Passing a  LayerMask to  Physics.Raycast() will only return objects withinthe specified set of layers.</p><p>虽然你不能直接查找一个层中的所有对象，但是如果你已经引用了一个游戏对象(例如，在一个碰撞事件中)，你可以对照一个层蒙版检查一个游戏对象。LayerMask通常用于Physics.racast()等函数中。这允许您查找具有与给定光线相交的碰撞器的对象。将LayerMask传递到Physics.racast()将只返回指定层集中的对象。</p><p> Inside the Unity Engine,  Cameras make heavy use of layers. E.g., you canhave one camera that renders “everything but UI”, and overlay another camerafor an in-game HUD, etc.</p><p>在Unity引擎内部，相机大量使用层。例如，你可以有一个相机来渲染“除了UI以外的所有东西”，然后叠加另一个相机用于游戏中的HUD，等等。</p><p> Using indirect references. There are many reasons why the methods abovemight be insufficient: you might not want to use tags to avoid depending oncopy-pasted strings, and layers might not fit your use case. If referencinga fellow object in-scene is not an option (e.g., you’re dealing with adynamic set of objects or don’t have access to the current scene objects inthe context you need this reference, etc.), then you might want to lookfurther.</p><p>使用间接引用。上述方法可能不够充分的原因有很多：您可能不想使用标记来避免依赖复制粘贴的字符串，并且层可能不适合您的用例。如果不能引用场景中的同伴对象(例如，您正在处理动态的对象集，或者在需要此引用的上下文中无法访问当前场景对象，等等)，那么您可能需要进一步查看。</p><p> For this, an increasingly popular concept is  runtime sets ScriptableObjects. You can read more about this in Unity’s how-to article on architecting your game with ScriptableObjects,based on  the talk by RyanHipple. If you have an hour to spare, you might want to watch the wholething.</p><p>为此，一个越来越流行的概念是运行时集ScriptableObjects。你可以在Unity的How-to文章中阅读更多关于使用ScriptableObjects构建游戏的文章，这篇文章基于RyanHipple的演讲。如果你有一个小时的空闲时间，你可能想看完整个过程。</p><p> A GameObject also exposes a  BroadcastMessage and  SendMessage functions thatpropagate  messages (described in the   Component section) toall components in or under it.</p><p>GameObject还公开BroadCastMessage和SendMessage函数，这些函数将消息(在组件部分中描述)传播到它里面或下面的所有组件。</p><p>   Unity defines the behaviors of game objects through the  composition of theseComponent classes. This is a core tenet of what game engines refer to as anEntity Component System (ECS). The Ripple blog has an applied overview ofECS, and  Robert Nystrom’s Game Programming Patterns describes entity component systems in detail.Confusingly, Unity refers to their next-generation high-performance gameprogramming paradigm as ECS, which is also ECS-based but takes things to the next level with data-oriented design.</p><p>Unity通过这些eComponent类的组合定义游戏对象的行为。这是游戏引擎所称的实体组件系统(ECS)的核心原则。Ripple博客有ECS的应用概述，Robert Nystrom的游戏编程模式详细描述了实体组件系统，令人困惑的是，Unity将他们的下一代高性能游戏编程范例称为ECS，它也是基于ECS的，但通过面向数据的设计将事情带到了一个新的水平。</p><p> From the outside looking in, both Unity’s  MonoBehaviour-based paradigm  andUnity ECS are entity component systems, though  how you use them differsubstantially.</p><p>从外部看，Unity的基于MonoBehaviour的范例和Unity ECS都是实体组件系统，尽管您如何使用它们有很大的不同。</p><p> Every behavior on a GameObject is driven through its Components.User-implemented Components will usually extend the  MonoBehaviour subclass(more on that later).</p><p>GameObject上的每个行为都是通过其组件驱动的，用户实现的组件通常会扩展MonoBehaviour子类(稍后将详细介绍)。</p><p>    In addition to its  GameObject, a component exposes shorthand properties andmethods such as  Transform transform,  T GetComponent&lt;T&gt;(), etc. These aresimply convenience shorthands for accessing those same methods on thecorresponding  gameObject.</p><p>除了其GameObject之外，组件还公开速记属性和方法，如Transform Transform、T GetComponent&lt；T&gt；()等。这些只是在相应的GameObject上访问这些相同方法的方便快捷方式。</p><p> The most important functionality of a Component is driven through  UnityMessages (also sometimes called  Unity Event Functions when referring tobuilt-in messages). These are effectively callbacks functions triggered  by theEngine in certain situations. Every Component will receive a  Awake(), Start(),  Update() and other messages, for example. The Unity Docs on the Order of Execution ofthese messages is a convenient resource.</p><p>组件最重要的功能是通过UnityMessages驱动的(在引用内置消息时，有时也称为Unity事件函数)。在某些情况下，这些函数实际上是由Engine触发的回调函数。例如，每个组件将接收唤醒()、启动()、更新()和其他消息。这些消息的执行顺序上的Unity Docs是一个方便的资源。</p><p> To have your component receive a particular message, simply add a  private void method with the appropriate message name. The runtime will usereflection to call these messages, when applicable. This is why you don’t see an override directive on these messages. Messages like  Update,  LateUpdate,and  FixedUpdate are inspected once per type, so don’t worry about reflectionbeing used in every frame. See more details in the” 10000 Update() calls”Unity blog post for more information.</p><p>要让您的组件接收特定消息，只需添加一个具有适当消息名称的私有void方法。如果适用，运行库将使用反射来调用这些消息。这就是为什么您在这些消息上看不到覆盖指令的原因。像Update、LateUpdate和FixedUpdate这样的消息每种类型都会检查一次，所以不用担心在每个帧中都会使用反射。有关更多信息，请参阅“10000更新()调用”Unity博客帖子中的更多详细信息。</p><p> A   Behaviour is a type of component that  can be enabled or disabled. Whena  Behaviour is disabled,  Start,  Update,  FixedUpdate,  LateUpdate, OnEnable, and  OnDisable messages are not called.</p><p>行为是一种可以启用或禁用的组件类型。禁用行为时，不调用Start、Update、FixedUpdate、LateUpdate、OnEnable和OnDisable消息。</p><p>   A GameObject in a loaded scene will exist in memory until the object is Destroyed explicitly or the scene is unloaded. A GameObject can be set to inactive, which will cause it to stop receiving  Update (and related) events.</p><p>加载的场景中的游戏对象将存在于内存中，直到该对象被显式销毁或该场景被卸载。游戏对象可以设置为非活动状态，这将使其停止接收更新(和相关)事件。</p><p> When an object is  created, the messages called on a component depend onif: (1) the GameObject is active, and (2) the component is enabled:</p><p>创建对象时，组件上调用的消息取决于：(1)GameObject是否处于活动状态，以及(2)组件是否已启用：</p><p>      A Unity object might  appear to become  null when destroyed.  == nullchecking does more than you think.</p><p>被销毁时，Unity对象可能会显示为空。==空检查比您想象的要多。</p><p> As a result, null-coalescing operators ( ??,  ??=) and null-conditionaloperators ( ?.,  ?[]) don’t work as expected.</p><p>因此，空合并运算符(？？，？？=)和空条件运算符(？.，？[])不能按预期工作。</p><p>  Don’t create abstract classes that unnecessarily declare  Update or othermessages to make overriding easier; that’ll result in the engine alwayscalling these events.</p><p>不要创建不必要地声明Update或其他消息的抽象类以使覆盖更容易；这将导致引擎始终缩放这些事件。</p><p> Disabling an Object or Component is a great way to limit its game logic orsave on CPU-bound effort, but these objects still have a memory overhead.</p><p>禁用对象或组件是限制其游戏逻辑或节省CPU开销的好方法，但这些对象仍有内存开销。</p><p>  You can also   subscribe and stay in the loop—it would mean a lot!</p><p>您也可以订阅并保持在循环中-这将意味着很多！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.eyas.sh/2020/10/unity-for-engineers-pt5-object-component/">https://blog.eyas.sh/2020/10/unity-for-engineers-pt5-object-component/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/unity/">#unity</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>