<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>单个Emoji字符的字符串长度函数评估大于1 String length functions for single emoji characters evaluate to greater than 1</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">String length functions for single emoji characters evaluate to greater than 1<br/>单个Emoji字符的字符串长度函数评估大于1 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-27 06:38:35</div><div class="page_narrow text-break page_content"><p>It’s Not Wrong that  &#34;🤦🏼‍♂️&#34;.length == 7</p><p>这不是错误的那个＆＃34;🤦🏼♂️＆＃34; .length == 7</p><p>  But It’s Better that  &#34;🤦🏼‍♂️&#34;.len() == 17 and Rather Useless that  len(&#34;🤦🏼‍♂️&#34;) == 5</p><p>  但它更好的是那个＆＃34;🤦🏼♂️＆＃34; .len（）== 17，而不是无用的那个len（＆＃34;🤦🏼♂️＆＃34;）== 5</p><p> From time to time, someone shows that in JavaScript the  .length of a string containing an emoji results in a number greater than 1 (typically 2) and then proceeds to the conclusion that haha JavaScript is so broken—and is rewarded with many likes. In this post, I will try to convince you that ridiculing JavaScript for this is less insightful than it first appears and that Swift’s approach to string length isn’t unambiguously the best one. Python 3’s approach is unambiguously the worst one, though.</p><p> 不时地显示，在JavaScript中，包含EMOJI的字符串的长度导致数量大于1（通常为2），然后进行得出的结论，即哈哈JavaScript是如此破碎 - 许多喜欢的奖励。在这篇文章中，我会尝试说服你嘲笑JavaScript，这比首次出现的洞察力不那么富有洞察力，并且Swift的字符串长度的方法不是明确的最佳状态。但是，Python 3的方法是明确的最糟糕的方法。</p><p>  &#34;🤦🏼‍♂️&#34;.length == 7 evaluates to  true as JavaScript. Let’s try JavaScript console in Firefox:</p><p>  ＆＃34;🤦🏼♂️＆＃34; .Length == 7作为JavaScript评估为True。让我们在Firefox中尝试JavaScript控制台：</p><p>  Haha, right? Well, you’ve been told that the Python community suffered the Python 2 vs. Python 3 split, among other things, to Get Unicode Right. Let’s try Python 3:</p><p>  哈哈，对吗？好吧，你被告知，Python社区遭受了Python 2对阵Python 3拆分，以及其他事情来获得Unicode右。让我们试试Python 3：</p><p> $ python3Python 3.6.8 (default, Jan 14 2019, 11:02:34) [GCC 8.0.1 20180414 (experimental) [trunk revision 259383]] on linuxType &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.&gt;&gt;&gt; len(&#34;🤦🏼‍♂️&#34;) == 5True&gt;&gt;&gt;</p><p> $ python3python 3.6.8（默认值，2019年1月14日，11:02:34）[GCC 8.0.1 20180414（实验）[Trunk Revision 259383]在Linuxtype＆＃34;帮助＆＃34;，＆＃34;版权＆＃ 34;，＆＃34;学分和＃34;或＆＃34;许可证＆＃34;有关更多信息。＆gt;＆gt;＆gt; Len（＆＃34;🤦🏼♂️＆＃34;）== 5true＆gt;＆gt;＆gt;</p><p> OK, then. Now, Rust has the benefit of learning from languages that came before it. Let’s try Rust:</p><p> 好吧。现在，Rust有利于从之前的语言学习。让我们尝试生锈： </p><p> $ cargo new -q length$ cd length$ echo &#39;fn main() { println!(&#34;{}&#34;, &#34;🤦🏼‍♂️&#34;.len() == 17); }&#39; &gt; src/main.rs$ cargo run -qtrue</p><p>$ cargo new -q loget $ cd长度$ echo＆＃39; fn main（）{println！（＆＃34; {}＆＃34;＆＃34;🤦🏼♂️＆＃34; .len（） == 17）; }＆＃39; ＆gt; src / main.rs $货物运行-qtrue</p><p>     The string that contains one graphical unit consists of 5 Unicode scalar values. First, there’s a base character that means a person face palming. By default, the person would have a cartoonish yellow color. The next character is an emoji skintone modifier the changes the color of the person’s skin (and, in practice, also the color of the person’s hair). By default, the gender of the person is undefined, and e.g. Apple defaults to what they consider a male appearance and e.g. Google defaults to what they consider a female appearance. The next two scalar values pick a male-typical appearance specifically regardless of font and vendor. Instead of being an emoji-specific modifier like the skin tone, the gender specification uses an emoji-predating gender symbol (MALE SIGN) explicitly ligated using the ZERO WIDTH JOINER with the (skin-toned) face-palming person. (Whether it is a good or a bad idea that the skin tone and gender specifications use different mechanisms is out of the scope of this post.) Finally, VARIATION SELECTOR-16 makes it explicit that we want a multicolor emoji rendering instead of a monochrome dingbat rendering.</p><p>     包含一个图形单元的字符串由5个Unicode标量值组成。首先，有一个基本的角色，这意味着一个人的面孔柏。默认情况下，该人将有一种卡通黄色。下一个字符是一个表情符号Skintone修饰符，改变了人皮肤的颜色（以及在实践中，也是人的头发的颜色）。默认情况下，该人的性别未定义，例如，苹果默认为他们认为男性外观和例如， Google默认为他们认为女性外观。接下来的两个标量值明确地选择了一个男性典型的外观，无论字体和供应商如何。性别规范而不是像肤色一样的表达特定的修饰语，而是使用零宽度木匠用（皮肤定位的）面部柏树人明确地连接的表情符号预测性别符号（男性标志）。 （是否是一种很好的或坏的想法，即肤色和性别规范使用不同的机制是不可能的。）最后，变体选择器-16使我们能够明确到我们想要多色EMOJI渲染而不是单色。 Dingbat渲染。</p><p> Each of the languages above reports the string length as the number of  code units that the string occupies. Python 3 strings store Unicode code points each of which is stored as one code unit by CPython 3, so the string occupies 5 code units. JavaScript (and Java) strings have (potentially-invalid) UTF-16 semantics, so the string occupies 7 code units. Rust strings are (guaranteed-valid) UTF-8, so the string occupies 17 code units. We’ll come to back to the actual  storage as opposed to  semantics later.</p><p> 上面的每种语言都将字符串长度报告为字符串占用的代码单元数。 Python 3字符串存储Unicode代码点每个由cpython 3存储为一个代码单元，因此字符串占用5个代码单元。 JavaScript（和Java）字符串具有（潜在无效）UTF-16语义，因此字符串占用7个代码单元。 rust字符串（保证有效）UTF-8，因此字符串占用17个代码单元。我们将稍后再次返回实际存储，而不是语义。</p><p> Note about Python 3 added on 2019-09-09: Originally this article claimed that Python 3 guaranteed UTF-32 validity. This was in error. Python 3 guarantees that the units of the string stay within the Unicode code point range but does not guarantee the absence of surrogates. It not only allows unpaired surrogates, which might be explained by wishing to be compatible with the value space of potentially-invalid UTF-16, but Python 3 allows materializing even surrogate pairs, which is a truly bizarre design. The previous conclusions stand with the added conclusion that Python 3 is even more messed up than I thought! With the way the example string was constructed in Python 3, the Python 3 string happens to match the valid UTF-32 representation of the string, so it is still illustrative of UTF-32, but the rest of the article has been slightly edited to avoid claiming that Python 3 used UTF-32.</p><p> 关于Python 3在2019-09-09中添加了关于Python 3：最初本文声称Python 3保证了UTF-32有效性。这是错误的。 Python 3保证字符串的单位保持在Unicode码点范围内，但不保证缺少代理人。它不仅允许未配对代理，这可能是通过希望与潜在的UTF-16的价值空间兼容来解释，但Python 3允许实现甚至代理对，这是一个真正的奇异设计。之前的结论是达到的结论，即Python 3比我想象的更搞砸了！随着示例字符串在Python 3中构造的方式，突然发生Python 3字符串以匹配字符串的有效UTF-32表示，因此它仍然是UTF-32的说明，但其余的文章已经略微编辑避免声称Python 3使用UTF-32。</p><p>  There’s a language for that. The following used Swift 4.2.3, which was the latest release when I was researching this, on Ubuntu 18.04:</p><p>  有一种语言。以下使用的Swift 4.2.3，这是我在ubuntu 18.04上研究的最新版本：</p><p> $ mkdir swiftlen$ cd swiftlen/$ swift package init -q --type executable$ swift package init --type executableCreating executable package: swiftlenCreating Package.swiftCreating README.mdCreating .gitignoreCreating Sources/Creating Sources/swiftlen/main.swiftCreating Tests/Creating Tests/LinuxMain.swiftCreating Tests/swiftlenTests/Creating Tests/swiftlenTests/swiftlenTests.swiftCreating Tests/swiftlenTests/XCTestManifests.swift$ echo &#39;print(&#34;🤦🏼‍♂️&#34;.count == 1)&#39; &gt; Sources/swiftlen/main.swift $ swift run swiftlen 2&gt;/dev/nulltrue</p><p> $ mkdir swiftlen $ cd swiftlen / $ swift包init-q-type可执行文件$ swift包init  -  type executablecreation可执行包：swiftlencreating package.swiftcreating Readme.mdcreating .gitignoreCreating源/创建源/ swiftlen / main.swift创建测试/创建测试/ Linuxmain.SwiftCroaring测试/ SwiftLentests /创建测试/ SwiftLentests / SwiftLentests.Swift创建测试/ SwiftLentests / XCTestmanifests.swift $ Echo＆＃39;打印（＆＃34;🤦🏼♂️＆＃34; .count == 1） ＆＃39; ＆gt;源/ swiftlen / main.swift $ swift运行swiftlen 2＆gt; / dev / nulltrue</p><p> (Not using the Swift REPL for the example, because it does not appear to accept non-ASCII input on Ubuntu! Swift 5.0.3 prints the same and the REPL is still broken.)</p><p> （不使用Swift Repl为例，因为它似乎没有接受Ubuntu上的非ASCII输入！SWIFT 5.0.3打印相同，REPL仍然被打破。） </p><p> OK, so we’ve found a language that thinks the string contains one countable unit. But what is that countable unit? It’s an  extended grapheme cluster. (“Extended” to distinguish from the older attempt at defining grapheme clusters now called  legacy grapheme clusters.) The definition is in  Unicode Standard Annex #29 (UAX #29).</p><p>好的，所以我们发现了一种认为字符串包含一个可数单元的语言。但是可数单位是什么？这是一个扩展的图形集群。 （“扩展”以区分从旧的尝试定义现在称为传统图形集群的图形集群。）定义在Unicode标准附件＃29中（UAX＃29）。</p><p>    Given a valid Unicode string and a version of Unicode, all of the above are well-defined and it holds that each item higher on the list is greater or equal than the items lower on the list.</p><p>    给定有效的Unicode字符串和Unicode的版本，所有上述都是明确定义的，并且它保存在列表上更高的每个项目比列表上更低的项目更大或相等。</p><p> One of these is not like the others, though: The first three numbers have an unchanging definition for any valid Unicode string whether it contains currently assigned scalar values or whether it is from the future and contains unassigned scalar values as far as software written today is aware. Also, computing the first three lengths does not involve lookups from the Unicode database. However, the last item depends on the Unicode version and involves lookups from the Unicode database. If a string contains scalar values that are unassigned as far as the copy of the Unicode database that the program is using is aware, the program will potentially overcount extended grapheme clusters in the string compared to a program whose copy of the Unicode database is newer and has assignments for those scalar values (and some of those assignments turn out to be combining characters).</p><p> 其中一个并不像其他人，但是：前三个数字对于任何有效的Unicode字符串，它是否包含当前分配的标量值或者是来自未来的任何有效的Unicode字符串，并包含目前写的软件的未分配标量值知道的。此外，计算前三个长度不涉及来自Unicode数据库的查找。但是，最后一个项目取决于Unicode版本，涉及从Unicode数据库查找。如果字符串包含程序使用的Unicode数据库的副本，则该字符串值是所知道的，则该程序将可能会占据字符串中的扩展图形群集，而与Unicode数据库的副本更新的程序相比，该程序相比有关这些标量值的分配（以及其中一些分配结果是组合字符）。</p><p>  It is not the case that a given programming language has to choose only one of the above. If we run this Swift program:</p><p>  给定的编程语言必须仅选择上述一个语言是不这样的。如果我们运行此Swift程序：</p><p>     use unicode_segmentation::UnicodeSegmentation;fn main() {	let s = &#34;🤦🏼‍♂️&#34;;	println!(&#34;{}&#34;, s.graphemes(true).count());	println!(&#34;{}&#34;, s.chars().count());	println!(&#34;{}&#34;, s.encode_utf16().count());	println!(&#34;{}&#34;, s.len());}</p><p>     使用unicode_segmentation :: Unicodesegation; fn main（）{let s =＆＃34;🤦🏼♂️＆＃34 ;; println！（＆＃34; {}}＆＃34;，s.graphemes（true）.count（））; println！（＆＃34; {}＆＃34;，s.chars（）。count（））; println！（＆＃34; {}}＆＃34;，s.encode_utf16（）。count（））; println！（＆＃34; {}＆＃34;，s.len（））;}</p><p>   That’s unexpected! It turns out that  unicode-segmentation does not implement the latest version of the Unicode segmentation rules, so it gives the ZERO WIDTH JOINER generic treatment (break right after ZWJ) instead of the newer refinement in the emoji context.</p><p>   那是出乎意料的！事实证明，Unicode-segsation不实现Unicode分段规则的最新版本，因此它给出了Zero Widey Joiner通用处理（ZWJ之后的右侧）而不是表情符号上下文中的较新的细化。</p><p> Let’s try again, but this time with  unic-segment = &#34;0.9.0&#34; in  Cargo.toml: use unic_segment::Graphemes;fn main() {	let s = &#34;🤦🏼‍♂️&#34;;	println!(&#34;{}&#34;, Graphemes::new(s).count());	println!(&#34;{}&#34;, s.chars().count());	println!(&#34;{}&#34;, s.encode_utf16().count());	println!(&#34;{}&#34;, s.len());}</p><p> 让我们再试一次，但这次与Unic-segment =＆＃34; 0.9.0＆＃34;在Cargo.toml：使用Unic_segment :: Graphemes; Fn Main（）{Let S =＆＃34;🤦🏼♂️＆＃34 ;; Println！（＆＃34; {}＆＃34;，graphemes :: new（s）.count（））; println！（＆＃34; {}＆＃34;，s.chars（）。count（））; println！（＆＃34; {}}＆＃34;，s.encode_utf16（）。count（））; println！（＆＃34; {}＆＃34;，s.len（））;} </p><p>  In the Rust case, strings (here mere string slices) know the number of UTF-8 code units they contain. The  len() method call just returns this number that has been stored since the creation of the string (in this case, compile time). In the other cases, what happens is the creation of an iterator and then instead of actually examining the values (string slices correspoding to extended grapheme clusters, Unicode scalar values or UTF-16 code units) that the iterator would yield, the  count() method just consumes the iterator and returns the number of items that were yielded by the iteration. The count isn’t stored anywhere on the string (slice) afterwards. If we wanted to later know the counts again, we’d have to iterate over the string again.</p><p>在生锈案例中，字符串（这里只有字符串切片）知道它们包含的UTF-8代码单元的数量。 LEN（）方法调用只返回自创建字符串（在这种情况下，编译时间）以来已存储的此数字。在其他情况下，会发生什么是创建迭代器，而不是实际检查迭代器将产生的迭代器将产生的值（字符串切片，Unicode群集，Unicode标量值或UTF-16代码单元）方法只需消耗迭代器并返回由迭代所产生的项目数。之后，计数未存储在字符串（切片）上的任何位置。如果我们想再次稍后知道计数，我们必须再次迭代字符串。</p><p>  This introduces a notable question in the design space: Should a given type of length quantity be eagerly computed when the string is created? Or should the length be computed when someone asks for it? Or should it be computed when someone asks for it and then automatically stored on the string object so that it’s available immediately if someone asks for it again?</p><p>  这在设计空间中引入了一个值得注意的问题：如果创建字符串时会热切地计算给定类型的长度数量？或者如果有人要求它应该计算长度？或者当有人要求它然后自动存储在字符串对象中时，它应该计算，以便如果有人再次要求它可以立即可用？</p><p> The answer Rust has is that the length in the code units of the Unicode Encoding Form of the language is stored upon string creation, and the rest are computed when someone asks for them (and then forgotten and not stored on the string).</p><p> 答案Rust具有语言的Unicode编码形式的代码单元中的长度存储在字符串创建时，并且当有人要求它们（然后忘记并不存储在字符串上时，其余的</p><p> Swift is a higher-level language and doesn’t document the exact nature of its string internals as part of the API contract. In fact, the internal representation of Swift strings changed substantially between Swift 4.2 and Swift 5.0. It’s not documented if different views to the string are held onto once created, for example. The documentation does say that strings are copy-on-write, so the first mutation may involve copying the string’s storage.</p><p> SWIFT是一种更高级别的语言，并没有将其字符串内部内部的确切性质作为API合同的一部分记录。事实上，SWIFT串的内部表示在SWIFT 4.2和SWIFT 5.0之间大大变化。例如，如果对字符串的不同视图保持在创建次数，则不会记录。文档确实说字符串是复制写入的，因此第一个突变可能涉及复制字符串的存储。</p><p> Notably, the design space includes not remembering anything. The C programming language is a prominent example of this case. C strings don’t even remember their number of code units. To find out the number of code units, you have to iterate over the string until a sentinel value. In the case of C, the sentinel is the code unit for U+0000, so it excludes one Unicode scalar value from the possible string contents. However, that’s not a strictly necessary property of a sentinel-based design that doesn’t remember any lengths. 0xFF does not occur as a code unit in any valid UTF-8 string and 0xFFFFFFFF does not occur in any valid UTF-32 string, so they could be used as sentinels for UTF-8 and UTF-32 storage, respectively, without excluding a scalar value from the Unicode value space. There is no 16-bit value that never occurs in a valid UTF-16 string. However, a valid UTF-16 string does not contain unpaired surrogates, so an unpaired low surrogate could, in principle, be used as a sentinel in a design that wanted to use guaranteed-valid UTF-16 strings that don’t remember their code unit length.</p><p> 值得注意的是，设计空间不包括任何内容。 C编程语言是这种情况的一个突出示例。 C字符串甚至没有记住他们的代码单位数。要找出代码单元的数量，您必须在Sentinel值旁边迭代字符串。在C的情况下，Sentinel是U + 0000的代码单元，因此它从可能的字符串内容中排除一个Unicode标量值。但是，这不是一个基于Sentinel的设计的严格必要的属性，这些属性不记得任何长度。 0xFF不会在任何有效的UTF-8字符串中作为代码单元发生，并且在任何有效的UTF-32字符串中都不会发生0xFFFFFFFF，因此它们可以分别用作UTF-8和UTF-32存储的Sentinels，而无需排除A来自Unicode值空间的标量值。没有16位值，永远不会发生在有效的UTF-16字符串中。但是，有效的UTF-16字符串不包含未配对的代理，因此原则上，未配对的低代理人可以用作想要使用保证有效的UTF-16字符串的设计中的Sentinel，这些rom-16字符串不记得其代码单位长度。</p><p>  The length of the string as counted in code units of its storage-native Unicode Encoding Form (i.e. whichever of UTF-8, UTF-16, and UTF 32 the programming language has chosen for its string semantics) is not like the other lengths. It is the length that the implementation cannot avoid having to know at the time of creating a new string, because it is the length that is required to be known in order to be able to allocate storage for a string. Even C, which promptly forgets about the code unit length in the storage-native Unicode Encoding Form after string has been created, has to know this length when allocating storage for a new string.</p><p>  在其存储原始Unicode编码形式的代码单元中计数的字符串的长度（即，以utf-8，UTF-16和UTF 32为其字符串语义选择的编程语言）不像另一个长度。它的长度是在创建新字符串时必须知道必须知道的长度，因为它是能够为字符串分配存储所需的长度。偶数C，它迅速忘记在创建字符串之后的存储原本机Unicode编码表单中的代码单元长度，必须在为新字符串分配存储时知道此长度。</p><p> That is, the design decision is about whether to remember this length. It is not about whether to compute it eagerly. You just have to have it at string creation time—i.e. eagerly.</p><p> 也就是说，设计决定是关于是否要记住这一长度。它不是关于是否急切地计算它。你只需要在String创建时间 - 即。热切地。 </p><p> Considering that remembering this quantity makes string concatenation, which is a common operation, substantially faster to implement compared to not remembering this quantity, remembering this quantity is fundamentally reasonable. Also, it means that you don’t need to maintain a sentinel value, which means that a substring operation can yield results that share the buffer with the original string instead of having to copy in order to be able to insert sentinel. (Note that you can easily foil this benefit if you wish to eagerly maintain zero-termination for the sake of C string compatibility.)</p><p>考虑到记住此数量使得字符串连接是一个常见的操作，与不记得这个数量相比，实现的速度基本上更快，记住此数量是根本合理的。此外，这意味着您不需要维护Sentinel值，这意味着子字符串操作可以产生与原始字符串共享缓冲器的结果，而不是必须复制以便能够插入哨兵。 （请注意，如果您希望急切地保持零终止，因此可以轻松地融合这种福利，以便C字符串兼容性。）</p><p>  Even if we’ve established that it makes sense for string implementation to remember the storage length of the string in code units all the storage-native Unicode encoding form, it doesn’t answer whether a string implementation should also remember other lengths or which kind of length should be offered in the most ergonomic API. (As we see above, Swift makes the number of extended grapheme clusters more ergonomic to obtain that the code unit or scalar value length.)</p><p>  即使我们已经确定字符串实现是有道理的，以记住代码单元中的字符串的存储长度，也不回答字符串实现是否应该记住其他长度或哪种类型应在最符合人体工程学的API中提供长度。 （正如我们上面的那样，SWIFT使得扩展的石墨簇数量更加符合人体工程学，以获得代码单元或标量值长度。）</p><p> Also, if any other length is to be remembered, there is the question of whether it should be eagerly computed as string creation time or lazily computed the first time someone asks for it. It is easy to see why at least the latter does not make sense for multi-threaded systems-programming language like Rust. If some properties of an object are lazily initialized, in a multi-threaded case you also need to solve synchronization of these computations. Furthermore, you need to allocate space at least for a pointer to auxiliary information if you want to be able to add auxiliary information later or you need to have a hashtable of auxiliary information where the string the information is about is the key, so auxiliary information, even when not present, has storage implications or implications of having to have global state in a run-time system. Finally, for systems programming, it may be more desirable to know the time complexity of a given operation clearly even if it means “always O(n)” instead of “possibly O(n) but sometimes O(1)”. Even if the latter looks strictly better, it is less  predictable.</p><p> 此外，如果要记住任何其他长度，那么有问题是应该被急切地计算为字符串创建时间还是懒洋地计算有人第一次要求它。很容易看出为什么至少后者没有意义于像生锈这样的多线程系统编程语言。如果对象的某些属性懒惰地初始化，则在多线程的情况下，还需要解决这些计算的同步。此外，如果要能够稍后添加辅助信息，则需要至少针对指向辅助信息的指针分配空间或者您需要具有字符串信息所在的辅助信息的哈希表是关键，因此辅助信息，即使在不存在时，也具有在运行时系统中具有全局状态的存储影响或含义。最后，对于系统编程，即使它意味着“始终O（n）”而不是“可能O（n）但有时O（1）”，也可能更希望清楚地清楚地了解给定操作的时间复杂度。即使后者严格看起来，它也不太可预测。</p><p> For a higher-level language, arguments from space requirements or synchronization issues might not be decisive. It’s more relevant to consider what a given length quantity is  used for. This is often forgotten in Internet debates that revolve around what length is the most “correct” or “logical” one. So for the lengths that don’t map to the size of storage allocation, what are they good for?</p><p> 对于更高级别的语言，空间需求或同步问题的参数可能不会导致决定性。它更重要的是考虑一些给定的长度数量。这通常忘记围绕互联网辩论，这些辩论围绕最长度是最“正确”或“逻辑”的争论。因此，对于不映射到存储分配大小的长度，它们有什么好处？</p><p> It turns out that in the Firefox code base there are two places where someone wants to know the number of Unicode scalar values in a string that is not being stored as UTF-32 and attention is not paid to what the scalar values actually are. The IETF specification for Session Traversal Utilities for NAT (STUN) used for WebRTC has the curious property that it places length limits on certain protocol strings such that the limits are expressed as number of Unicode scalar values but the strings are transmitted in UTF-8. Firefox validates these limits. (The limit looks like an arbitrary power-of-two (128 scalar values). The spec has remarks about the possible resulting byte length, which was wrong according to the IETF UTF-8 RFC that was current and already nearly five years old at the time of publication of the STUN RFC. Specifically, the STUN RFC repeatedly says that 128 characters as UTF-8 may be as long as 763 bytes. To arrive at that number, you have to assume that a UTF-8 character can be up to six bytes long, as opposed to up to 4 bytes long as in the prevailing UTF-8 RFC and in the Unicode Standard, and that the last character of the 128 is a zero terminator and, therefore, known to take just one byte.) In this case, the reason for wishing to know a non-storage length is to  impose a limit. The other case is reporting the column number for the source location of JavaScript errors.</p><p> 事实证明，在Firefox代码库中有两个地方有人想要知道未被存储为UTF-32的字符串中的Unicode标量值的数量，并且不支付给标量值实际的注意力。用于WebRTC的NAT（STUN）的会话遍历实用程序的IETF规范具有奇和的属性，其在某些协议字符串上置于长度限制，使得限制表示为Unicode标量值的数量，但在UTF-8中发送字符串。 Firefox验证了这些限制。 （限制看起来像一个任意的两个功率（128个标量值）。规范有关于可能结果的字节长度的备注，根据IETF UTF-8 RFC，这是近五年的IETF UTF-8 RFC错误STUN RFC的出版时间。具体来说，令人惊叹的RFC重复说，UTF-8的128个字符可以是763字节。要到达该号码，您必须假设UTF-8字符可以启动长度为6个字节，而不是在普遍的UTF-8 RFC和Unicode标准中相反，并且128的最后一个字符是零终止者，因此已知只需要一个字节。 ）在这种情况下，希望知道非存储长度的原因是施加限制。另一种情况是报告JavaScript错误的源位置的列号。</p><p> Length limits, which we’ll come back to, probably aren’t a frequent enough a use case to justify making strings know a particular kind of length as opposed to such length being possible to compute when asked for. Neither are error messages.</p><p> 我们将返回的长度限制可能不是频繁的使用情况，以证明制作字符串知道特定的长度，而不是在被要求时计算的长度。既不是错误消息。</p><p> Another use case for asking for a length is iterating by index and using the length as the loop termination condition 1990s Java style. Like this:</p><p> 用于询问长度的另一个用例是通过索引迭代并使用长度作为循环终止条件1990s Java样式。像这样： </p><p> for (int i = 0; i &lt; s.length(); i++) { // Do something with s.charAt(i)}</p><p>for（int i = 0; i＆lt; s.length（）; i ++）{//与s.charat（i）做某事}</p><p> In this case, it’s actually important for the length to be precomputed number on the string object. This use case is coupled with the requirement that indexing into the string to find the  nth unit corresponding to the count of units that the “length” represents should be a fast operation.</p><p> 在这种情况下，它实际上对于字符串对象上的数字的长度实际上是重要的。此用例与索引到字符串的要求，以找到与“长度”代表的单位计数对应的第n个单元应该是快速操作。</p><p> The above pattern is a lot less conclusive in terms of what lengths should be precomputed (and what the indexing unit should be) than it first appears. The above loop doesn’t do random access by index. It sequentially uses every index from zero up to, but not including,  length. Indeed, especially when iterating over a string by Unicode scalar value, typically when you examine the contents of a string, you iterate over the string in order. Programming languages these days provide an  iterator facility for this, and e.g. to iterate over a UTF-8 string by scalar value, the iterator does not need to know the number of scalar values up front. E.g. in Rust, you can do this in O(n) time despite string slices not knowing their number of Unicode scalar values:</p><p> 以上模式的结论在于应该预先计算的长度（以及索引单元应该是什么），它是首次出现的。上述循环不按索引随机访问。它顺序使用从零到零的每个索引，但不包括长度。实际上，特别是当通过Unicode标量值迭代字符串时，通常在检查字符串的内容时，您按顺序迭代字符串。这些天编程语言为此提供了迭代器设施，而例如，要通过标量值迭代UTF-8字符串，迭代器不需要了解前面的标量值的数量。例如。在Rust中，尽管字符串切片不知道它们的Unicode标量值数量，但您可以在O（n）时间中执行此操作：</p><p>  (Note that  char is an 8-bit code unit (possibly UTF-8 code unit) in C and C++,  char is a UTF-16 code unit in Java,  char is a Unicode scalar value in Rust, and  Character is an extended grapheme cluster in Swift.)</p><p>  （请注意，CHAR是C和C ++中的8位代码单元（可能的UTF-8代码单元），CHAR是Java中的UTF-16代码单元，CHAR是RURE中的UNICODE标量值，并且字符是一个扩展的石墨剧烈蔓延。）</p><p> A programming language together with its library ecosystem should provide iteration over a string by Unicode scalar value and by extended grapheme cluster, but it does not follow that strings would need to know the scalar value length or the extended grapheme cluster length up front. Unlike the code unit storage length, those quantities aren’t useful for accelerating operations like concatenation that don’t care about the exact content of the string.  The observation that having strings know their code unit length in their storage-native Unicode encoding form is extremely reasonable does not answer how many bits wide the code units should be.</p><p> 与其库生态系统一起的编程语言应由Unicode标量值和扩展的图形群集提供迭代，但它不遵循字符串需要了解标量值长度或扩展的图形群集长度向前了解。与代码单元存储长度不同，那些数量对于加速同时加速的操作不适用于不关心字符串的确切内容。具有字符串在其存储原生Unicode编码形式中知道其代码单元长度的观察是非常合理的，不应回答代码单元应该是多少位。</p><p> The usual way to approach this question is to argue that UTF-32 is the best, because it provides O(1) indexing by “character” in the sense of a character meaning a Unicode scalar value, or the argument focuses on whether UTF-8 is unfair to some languages relative to UTF-16. I think these are bad ways to approach this question.</p><p> 接近这个问题的通常方法是争辩说UTF-32是最好的，因为它在字符意义上通过“字符”提供了o（1）索引，这意味着Unicode标量值，或者参数侧重于utf- 8对UTF-16的某种语言是不公平的。我认为这些是解决这个问题的糟糕方式。</p><p> First of all, the argument that the answer should be UTF-32 is bad on two counts. First, it assumes that random access scalar value is important, but in practice it isn’t. It’s reasonable to want to have a capability to iterate over a string by scalar value, but random access by scalar value is in the YAGNI department. Second, arguments in favor of UTF-32 typically come at a point where the person making the argument has learned about surrogate pairs in UTF-16 but has not yet learned about extended grapheme clusters being even larger things that the user perceives as unit. That is, if you escape the variable-width nature of UTF-16 to UTF-32, you pay by doubling the memory requirements and extended grapheme clusters are  still variable-width.</p><p> 首先，答案应该是UTF-32的论点在两个计数上是糟糕的。首先，它假设随机访问标量值很重要，但实际上它不是。希望通过标量值迭代字符串的功能是合理的，但标量值的随机访问是在YAGNI部门。其次，赞成UTF-32的论据通常会出现在提出论证的人在UTF-16中的代理对，但尚未了解到用户认为是单位的更大的东西甚至更大的图形群集。也就是说，如果逃避UTF-16的变量宽度性质到UTF-32，则通过加倍存储器要求，扩展的石墨簇仍然是可变的宽度。 </p><p> I’ll come back to the length fairness issue later, but I think a different argument is much more relevant  in practice for the choice of in-memory Unicode encoding form. The more relevant argument is this: Implementations that choose UTF-8 actually accept the UTF-8 storage requirements. When wider-unit semantics are chosen for a language that doesn’t provide raw memory access and, therefore, has the opportunity to tweak string storage, the implementations try to come up with ways to avoid actually paying the cost of the wider units in some situations.</p><p>我稍后会回到长度的公平问题，但我认为在实践中，可以在实践中进行不同的论点，以便选择内存的Unicode编码形式。更相关的参数是：选择UTF-8实际上接受UTF-8存储要求的实现。当更宽单元语义选择了不提供原始内存访问，因此语言，有机会来调整字符串存储，实现方式试图想出的办法，以避免实际支付更广泛的单位成本在某些情况。</p><p> JavaScript and Java strings have the semantics of potentially-invalid UTF-16. SpiderMonkey and V8 implement an optimization for omitting the leading zeros of each code unit in a string, i.e. storing the string as ISO-8859-1 (the actual ISO-8859-1, not the Web notion of “ISO-8859-1” as a label of windows-1252), when all code units in the string have zeros in the most-significant half. The HotSpot JVM also implements this optimization, though enabling it is optional. Swift 4.2 implements a slightly different variant of the same idea, where ASCII-only strings are stored as 8-bit units and everything else is stored as UTF-16. CPython since 3.3 makes the same idea three-level with code point semantics: Strings are stored with 32-bit code units if at least one code point has a non-zero bit above the low 16 bits. Else if a string has a non-zero bits above the low 8 bits for at least one code point, the string is stored as 16-bit units. </p><p> JavaScript和Java字符串具有潜在无效的UTF-16的语义。 SpiderMoNkey和V8实现了一个优化，以省略字符串中的每个代码单元的前导零，即将字符串存储为ISO-8859-1（实际的ISO-8859-1，而不是“ISO-8859-1”的Web概念作为Windows-1252的标签），当字符串中的所有代码单位都有零，最重要的一半。 Hotspot JVM还实现了这种优化，但使其是可选的。 Swift 4.2实现了相同思想的略微不同的变体，其中仅存储ASCII字符串作为8位单元，并且其他所有内容存储为UTF-16。 CPython自3.3自3级与代码点语义进行相同的思想：如果至少一个代码点具有高于16位上方的非零位，则串以32位代码单元存储。否则如果字符串在低8位上方具有至少一个代码点的非零位，则将字符串存储为16位单元。</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hsivonen.fi/string-length/">https://hsivonen.fi/string-length/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/字符/">#字符</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/length/">#length</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/字符串/">#字符串</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>