<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Flutter中的离线语音识别：否Siri，否Google和否，不是STT Offline Speech Recognition in Flutter: No Siri, No Google, and No, It’s Not STT</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Offline Speech Recognition in Flutter: No Siri, No Google, and No, It’s Not STT<br/>Flutter中的离线语音识别：否Siri，否Google和否，不是STT </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-19 23:50:32</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/2f2f72d0bb098d70fa2f52eabe4ce2a6.png"><img src="http://img2.diglog.com/img/2021/2/2f2f72d0bb098d70fa2f52eabe4ce2a6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I don’t have to tell you about the importance of hands-free mobile apps in the 21st century. What I do have to tell you is that it’s easier than you think to add it to your Flutter project. Picovoice recently released a series of  Flutter packages that have made adding offline voice commands to your mobile app a walk in the park. No, seriously — you’ll have time to take a walk in the park after doing it.</p><p>我无需告诉您有关免提移动应用在21世纪的重要性。我要告诉您的是，将其添加到Flutter项目中比想象的要容易。 Picovoice最近发布了一系列Flutter软件包，使您可以在公园散步时将脱机语音命令添加到您的移动应用程序中。不，是认真的-做完之后，您将有时间在公园里散步。</p><p> For this tutorial, I’ve taken some inspiration from last year’s ubiquitous  #flutterclock challenge and created a simple clock app. A clock app is a perfect platform for  domain-specific voice controls (i.e. it has a defined list of commands and parameters). We don’t need the clock to understand the scope of the English language to set an alarm for tomorrow, and we certainly don’t need to send microphone audio to the big computer in the sky to divine our intent — let’s keep it simple and private. A hands-free mode also happens to be an extremely useful addition to a clock app. You may want to set a timer in the kitchen when your hands occupied or start a stopwatch during your workout.</p><p> 在本教程中，我从去年无处不在的#flutterclock挑战中汲取了一些灵感，并创建了一个简单的时钟应用。 Clock应用程序是特定于域的语音控制的理想平台（即，它具有定义的命令和参数列表）。我们不需要时钟就可以理解英语的范围来为明天设置警报，我们当然也不需要将麦克风音频发送到空中的大型计算机来了解我们的意图-让我们保持简单和私人的。免提模式也是时钟应用程序的一个非常有用的补充。您可能想在双手占据厨房时设置计时器，或者在锻炼过程中启动秒表。</p><p>   Though I used the Flutter Clock challenge as inspiration, I decided against using the actual project as a starting point because there was a bit too much code that I wasn’t going to use and a fair amount I was going to add. Instead, I started from scratch and came up with something reminiscent of the Android Clock app.</p><p>   尽管我以Flutter Clock挑战为灵感，但我还是决定不以实际项目为起点，因为我不想使用太多代码，并且要添加很多代码。相反，我从头开始，想到了Android Clock应用程序。</p><p>  The UI is fairly simple: three different widgets that are toggled between using the bottom navigation bar. As for the code-behind, the backbone is a periodic function that updates our clock and checks on any active alarms and timers.</p><p>  UI非常简单：使用底部导航栏在三个不同的小部件之间切换。至于背后的代码，骨干网是一个定期功能，可更新我们的时钟并检查任何活动的警报和计时器。</p><p>   Now that we have a simple clock app, let’s go ahead and see how we add an offline voice AI to it. For this project, we’re going to need the app to understand a set of commands, but we’re also going to want a wake word to tell the app when to listen for a command. The  Picovoice Platform Flutter SDK will give us everything we need, so let’s import it by adding it to the project’s  pubspec.yaml file.</p><p>   现在我们有了一个简单的时钟应用程序，让我们继续前进，看看如何向其添加离线语音AI。对于此项目，我们将需要该应用程序理解一组命令，但我们还需要一个唤醒词来告知应用程序何时收听命令。 Picovoice Platform Flutter SDK将为我们提供所需的一切，因此，通过将其添加到项目的pubspec.yaml文件中进行导入。</p><p>  Next, we’re going to use the  PicovoiceManager class to capture audio and pass it to the Picovoice platform.</p><p>  接下来，我们将使用PicovoiceManager类捕获音频并将其传递到Picovoice平台。</p><p>  There’s a couple of things to unpack here — in the constructor we’re providing the  PicovoiceManager with two files and two callbacks. Both  keywordPath and  _wakeWordCallback relate the  Porcupine wake word engine — the part of the platform that is always listening for a specific trigger phrase. As for  contextPath and  _inferenceCallback, these relate to the  Rhino Speech-to-Intent engine, which is going to attempt to decipher the command that follows the wake word. If we try to launch the app at this point, Picovoice will fail to initialize due to missing keyword and context files — this is our next task. Now let’s head over to the  Picovoice Console to create a custom wake word and command context for our app.</p><p>  这里需要解压缩两件事-在构造函数中，我们为PicovoiceManager提供了两个文件和两个回调。 keywordPath和_wakeWordCallback都与豪猪唤醒词引擎相关联-平台中始终侦听特定触发短语的部分。至于contextPath和_inferenceCallback，它们与Rhino语音转意图引擎有关，后者将尝试对唤醒字后面的命令进行解密。如果我们此时尝试启动该应用程序，由于缺少关键字和上下文文件，Picovoice将无法初始化-这是我们的下一个任务。现在，让我们转到Picovoice控制台，为我们的应用创建自定义唤醒词和命令上下文。 </p><p>  The Picovoice Console gives us all the tools we need to create voice interfaces that fit our needs and work on our desired platforms. Currently, you can sign up for a free personal account or start a 30-day trial of the enterprise account. In this tutorial, we are going to create a custom command context that works and train it for Android and iOS.</p><p>Picovoice控制台为我们提供了创建符合我们需求并在所需平台上工作的语音界面所需的所有工具。当前，您可以注册一个免费的个人帐户或开始试用该企业帐户的30天。在本教程中，我们将创建一个自定义命令上下文，该上下文可以工作并针对Android和iOS进行培训。</p><p> To create a custom context, we’ll click on the Rhino tab, create an empty context and use the built-in editor to design our command interface. Our goal here is to create a simple grammar that our clock app will be able to use to control the app. The context will contain a set of   intents and   slots. Intents are essentially our command phrases — in our case, these will include items such as  setTimer and  setAlarm. Slots, on the other hand, you can think of as variables. For example, our context will contain a slot called  day which has values “Monday” through “Sunday”, “today” and “tomorrow”. An example of an intent expression in our context would be something like:</p><p> 要创建自定义上下文，我们将单击Rhino选项卡，创建一个空上下文，然后使用内置编辑器来设计命令界面。我们的目标是创建一个简单的语法，供我们的时钟应用程序用来控制该应用程序。上下文将包含一组意图和位置。意图实际上是我们的命令短语-在我们的情况下，它们将包括诸如setTimer和setAlarm之类的项。另一方面，您可以将插槽视为变量。例如，我们的上下文将包含一个名为day的广告位，其值从“星期一”到“星期日”，“今天”和“明天”。在我们的上下文中，意图表达的示例如下：</p><p>  Words in parathesis are optional and text preceded by a dollar-sign are slots that we’ve created.</p><p>  括号中的单词是可选的，带有美元符号的文本是我们创建的广告位。</p><p>  As for our wake word, we can use any one of the available Porcupine models that have been released for free to the public under the Apache 2.0 license. You can find these free wake word files over on the  Porcupine Github repo. If you’d like to create custom wake words, you’ll want to sign up for an Enterprise console account.</p><p>  至于我们的口号，我们可以使用任何一种根据Apache 2.0许可免费向公众发布的Porcupine模型。您可以在豪猪Github存储库中找到这些免费的唤醒词文件。如果您想创建自定义唤醒词，则需要注册一个Enterprise控制台帐户。</p><p> Now that we have the required files, we can bring them into our Flutter project and start voice-enabling our app.</p><p> 现在我们有了所需的文件，我们可以将它们引入Flutter项目并开始为我们的应用启用语音功能。</p><p>  Earlier in this article, we saw that the constructor for  PicovoiceManager takes a  keywordPath and a  contextPath — the  keywordPath refers to the file path of the Porcupine model file (.ppn file extension), while the  contextPath refers to the file path of the Rhino model file (.rhn file extension). Now that we have these required files, we’ll drop them into the asset folder of our Flutter project and add them to the  pubspec.yaml file as assets.</p><p>  在本文的前面，我们看到PicovoiceManager的构造函数采用了一个keywordPath和一个contextPath — keywordPath指的是豪猪模型文件的文件路径（.ppn文件扩展名），而contextPath指的是Rhino模型的文件路径。文件（.rhn文件扩展名）。现在我们有了这些必需的文件，我们将它们放入Flutter项目的asset文件夹中，并将它们作为资产添加到pubspec.yaml文件中。</p><p>  Traditionally, non-media assets have been difficult to load in a cross-platform app, but luckily Flutter has an asset bundle that we can read from and extract into a local directory using the  path_provider package. We’ll now add this file logic and some platform detection to our  _initPicovoice function from earlier:</p><p>  传统上，非媒体资产很难在跨平台应用程序中加载，但是幸运的是Flutter拥有资产束，我们可以使用path_provider包从中读取并提取到本地目录中。现在，我们将从前面的_initPicovoice函数中添加此文件逻辑和一些平台检测： </p><p>  If you launch the app now,  PicovoiceManager will initialize and start streaming audio. If you attempt to say the wake word, followed by any of the commands from the context, you’ll see them printed to the debug console. While this is all well and good, we need these voice controls to actually control the app now!</p><p>如果您现在启动应用程序，PicocoiceManager将初始化并开始流式传输音频。如果您尝试说唤醒词，然后从上下文中的任何命令，您将看到它们打印到调试控制台。虽然这一切都很好，但我们需要这些语音控制实际控制现在的应用程序！</p><p>  From the print commands in our  _wakeCallback and  _inferenceCallback, you can start to work out the code we’re going to add to parse the objects we’re going to receive from the  PicovoiceManager. The good news is, the  keywordIndex is a simple toggle switch and the  inference is a structured map object with known keys such as this:</p><p>  从我们的_wakecallback和_InferenceCallback中的打印命令，您可以开始制定我们要添加的代码，以解析我们将从PicociceManager接收的对象。好消息是，关键词是一个简单的切换开关，推动是一个结构化的地图对象，具有已知键，如下所示：</p><p>  This is in stark contrast to the speech-to-text approach where we have to parse a completely unknown and unstructured string. After filling out these functions, we have callbacks that look like the following:</p><p>  这与我们必须解析完全未知和非结构化的字符串的语音到文本方法的显着对比。填写这些功能后，我们有回调，看起来像以下内容：</p><p>  As you can see, the wake word callback simply changes the UI state to listening; Picovoice manages the switch between Porcupine and Rhino internally. In our app’s case, this will turn the microphone blue, letting the user know they can issue a command to the app.</p><p>  如您所见，唤醒词回调只是将UI状态更改为侦听; Picovoice在内部管理豪猪和犀牛之间的交换机。在我们的应用程序的情况下，这将转动麦克风蓝，让用户知道他们可以向应用程序发出命令。</p><p> The inference requires some additional logic to translate the inference object into a command. First, we check if the inference engine understood the spoken phrase as a command that exists within its context. If it was understood, we need to determine which intent to execute and then pass the slots (i.e. command variables) to the relevant app method. For example, the  _setTimer function takes the slots and turns them into a timer duration:</p><p> 推断需要一些附加逻辑来将推理对象转换为命令。首先，我们检查推理引擎是否理解语音短语作为其上下文中存在的命令。如果据了解，我们需要确定要执行哪个目的，然后将插槽（即命令变量）传递给相关的应用程序方法。例如，_settimer函数拍摄插槽并将它们转换为定时器持续时间：</p><p>  Once we’ve filled in all the control functions we should have a completely hands-free and cross-platform Flutter clock, as demonstrated in the following video:</p><p>  一旦我们填充了所有控制功能，我们应该具有完全免提和跨平台的颤动时钟，如以下视频所示：</p><p>  Hope you enjoyed this tutorial! Feel free to browse and reuse the source code  here. Learn more about Picovoice and our technology by visiting our  website,  Github, or  developer documentation.</p><p>  希望你喜欢这个教程！随时浏览并重用此处的源代码。通过访问我们的网站，GitHub或Developer文档来了解有关Picocoice和我们技术的更多信息。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/picovoice/offline-speech-recognition-in-flutter-no-siri-no-google-and-no-its-not-speech-to-text-c960180e9239">https://medium.com/picovoice/offline-speech-recognition-in-flutter-no-siri-no-google-and-no-its-not-speech-to-text-c960180e9239</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/flutter/">#flutter</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语音/">#语音</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/speech/">#speech</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/命令/">#命令</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>