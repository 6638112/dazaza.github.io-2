<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么生锈串似乎很难 Why Rust strings seem hard</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why Rust strings seem hard<br/>为什么生锈串似乎很难 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-15 22:29:09</div><div class="page_narrow text-break page_content"><p>2493  Brandon Smith  Lately I&#39;ve been seeing lots of anecdotes from people trying to get into Rust who get really hung up on strings ( &amp;str,  String, and their relationship). Beyond Rust&#39;s usual challenges around ownership, there can be an added layer of frustration because strings are so  easy in the great majority of languages. You just add them together, split them, whatever! They&#39;re primitives that you can do whatever you want with. For someone who&#39;s only ever known this mental model (which is to say, never worked much with C/C++), using strings in Rust can be a rude awakening. They feel very complicated, have all these restrictions and extra steps, and it all just seems so unnecessary.</p><p>2493 Brandon Smith最近是我＆＃39; Ve一直看到从试图进入真正挂断字符串（＆amp; str，string和他们的关系）的人的人们从事人们的轶事。超越生锈＆＃39;常规挑战的所有权，可以增加一层挫折，因为弦在大多数语言中都很容易。你只是把它们加在一起，拆分它们，无论如何！它们和＃39;你可以做任何你想做的原因。对于唯一知道这个心理模型的人（也就是说，从来没有用C / C ++工作），使用锈迹可以是一个粗鲁的觉醒。他们感到非常复杂，拥有所有这些限制和额外的步骤，这一切似乎都是不必要的。</p><p>  It&#39;s a testament to Rust&#39;s breadth and accessibility that even people who have never done low-level programming before are giving it a try. This is a good thing! But it comes with some extra challenges when you aren&#39;t coming in with a background in C/C++.</p><p>  它＆＃39; Syexame＆＃39; S甚至是从未在以前从未做过低级编程的人则为尝试的人。这是一件好事！但是当您在C / C ++中使用背景时，它会带来一些额外的挑战。</p><p>  &#34;Go learn C++ and come back&#34; isn&#39;t a very reasonable solution to this problem, so I wanted to dig into one of the most common issues I see, and give a &#34;cliff notes&#34; explanation that hopefully makes Rust a bit more accessible to more people.</p><p>  ＆＃34;去学习c ++并回来＆＃34; ISN＆＃39;这是一个非常合理的解决问题，所以我想挖掘我看到的最常见问题之一，并给出一个＆＃34;悬崖笔记＆＃34;有希望使RUDE的解释能够对更多人更容易获得更多的人。</p><p>      Strings are simple, right? They&#39;re just primitives - like numbers or booleans - that you can create with a literal ( &#34;foo&#34;), pass around, copy freely, add together with other strings (or primitives), return from functions, etc.</p><p>      字符串很简单，对吗？他们只是基因的原始词或布尔值 - 你可以用文字（＆＃34; foo＆＃34;）来创建，通过自由复制，加上其他字符串（或基元），从函数返回， 等等。</p><p>      A string is a primitive in the sense that it&#39;s fundamental: not many programs can accomplish much of value without dealing with strings. But it is  not a primitive in terms of implementation.</p><p>      一个字符串是一个原始的意义上，它＆＃39; s根本：没有多少个程序可以在不处理字符串的情况下实现大部分价值。但它在实施方面不是一个原始的。</p><p>  A distinguishing feature of other primitives like numbers, booleans, etc, is that they have a  constant size. Any two numbers of the same type (an  f64, for example- or a  double for the Java folks) take up the exact same number of bytes in memory. This means we can set aside space for a variable, or a function argument, or whatever, and we know that any possible  f64 will be able to fit there. No matter what math we do on it, no matter how large or small its value is.</p><p>  像数字，布尔值等其他基元的区别特征是它们具有恒定的大小。任何两个相同类型（f64，例如 -  java folks的f64）占用内存中完全相同数量的字节。这意味着我们可以为变量或函数参数或其他任何可能留出空间，我们知道任何可能的F64都能适应那里。无论我们的价值多大或多少，我们都在做什么数学。</p><p>  A string, on the other hand, does not have a constant size. If you take string A and string B, and they aren&#39;t identical ( &#34;foo&#34; and  &#34;foo&#34;), it&#39;s very unlikely they have the same size.  &#34;foofoo&#34; takes up twice as much space in memory as  &#34;foo&#34;.</p><p>  另一方面，一个字符串没有常量大小。如果你拿着字符串a和string b，他们areen＆＃39; t相同（＆＃34; foo＆＃34;和＃34; foo＆＃34; s，它非常不太可能它们具有相同的大小。 ＆＃34; foofoo＆＃34;占据emex的两倍于＆＃34; foo＆＃34; </p><p>  Technically there will be a tiny amount of extra data, like a length, so it won&#39;t be precisely twice the size. But it&#39;s close enough for our purposes.</p><p>从技术上讲，将有一个小数量的额外数据，如长度，所以它赢得了＆＃39;恰好是大小的两倍。但它与我们的目的足够接近。</p><p>  This is a problem, because under the hood flat data structures have to have a known size at compile-time, even in higher-level languages. Any data whose size can&#39;t be known at compile-time (or actively changes as the program runs) has to live on the heap, and be dynamically allocated as the program runs. This gets largely hidden from you in many languages like JavaScript.</p><p>  这是一个问题，因为在罩的平面数据结构下必须在编译时具有已知尺寸，即使在更高级别的语言中也是如此。任何大小可以在编译时都知道的任何数据（或随着程序运行时的主动更改）必须在堆上静置，并随着程序运行而动态分配。这在很大程度上被许多语言从您那样隐藏起来。</p><p>  The heap is like a big bucket of memory that the system your code is running on can lend out. Your program says &#34;I need X bytes for something&#34;, and the system says &#34;okay here you go&#34;. Then if your program later says &#34;actually that wasn&#39;t enough, now I need Y bytes&#34;, it&#39;ll have to take the new chunk, copy everything into it from the old one, and then give the old one back to the system. This is how  Vec works! It&#39;s also how JavaScript&#39;s arrays work, and as we&#39;ll find out soon, it&#39;s how Rust&#39;s  String works.    So why doesn&#39;t this need to happen with things like numbers? Because the compiler can go ahead and designate the right amount of memory right off the bat. It knows it will never have to expand, so it will never have to request more memory from the memory-bucket (heap).</p><p>  堆就像一个大桶内存，系统您的代码正在运行的系统可以借出。你的程序说＆＃34;我需要x字节的东西，而＃34;并且系统说＆＃34;好的，你去这里和＃34;然后，如果您的程序后来说＆＃34;实际上是那个＆＃39; t足够，现在我需要y字节＆＃34;，它＆＃39; ll必须采取新块，从旧的一切复制到它中，并然后将旧的一个返回系统。这是VEC如何工作！它＆＃39; s也是javascript＆＃39; s阵列的工作，以及我们＆＃39; ll很快找出来，它＆＃39; s如何生锈＆＃39; s字符串的工作。那么为什么不得不像数字一样发生这种情况？因为编译器可以继续并指定正确的蝙蝠数量的内存量。它知道它永远不会展开，因此它永远不会要求更多内存桶（堆）。</p><p>  So when you really get down to it, a string is a data structure living in the heap, not a primitive. Roughly speaking it&#39;s an array of characters (in C it is literally an array of characters). When you add two strings together, the program doesn&#39;t know in advance how big the result will be, so it needs to request the memory for it from the heap, as it&#39;s running. When you pass a string to a function, you&#39;re really passing a pointer to that heap-allocated array which some other code can use to look up its contents. The pointer itself, like a number, has a constant size.</p><p>  因此，当您真的达到它时，一个字符串是生活在堆中的数据结构，而不是一个原始的。粗略地说出它＆＃39; s一个字符数组（在c中它实际上是一个字符数组）。当您一起添加两个字符串时，程序并在前提时知道结果是多大的，因此它需要从堆上请求内存，就像运行一样。将字符串传递给函数时，您＆＃39;重新将指针指向该堆分配的数组，其中一些其他代码可以用于查找其内容。指针本身就像一个数字一样，具有常量大小。</p><p>  &#34;But strings are used constantly!&#34; you might be thinking. &#34;We&#39;re always slicing and dicing and remixing them; it would be insane to have to work with them as arrays, much less arrays that have to be manually re-allocated, copied, and de-allocated whenever their length changes!&#34;</p><p>  ＆＃34;但字符串是不断使用的！＆＃34;你可能会思考。 ＆＃34;我们始终切片和切割并重新混合它们;必须与它们一起工作是阵列的疯了，无论只要它们的长度变化，必须手动重新分配，复制和解除分配的阵列更少！＆＃34;</p><p>      By &#34;most languages&#34; I mean &#34;most of the most commonly-used languages&#34;. Which is to say JavaScript, Python, Java, C#, Go, Kotlin, Swift, and so on. In all of these languages, strings are  immutable. You may assign a  different string into a string slot, but you may not  change the string itself. The new one takes its place, the old one is lost to the winds of the garbage collector (unless some other code is using it, in which case it gets left alone).</p><p>      by＆＃34;大多数语言＆＃34;我的意思是＆＃34;大多数最常用的语言＆＃34;这就是说javascript，python，java，c＃，go，kotlin，swift等。在所有这些语言中，字符串都是不可变的。您可以将不同的字符串分配给字符串插槽，但您可能不会更改字符串本身。新人占据了它的位置，旧的一个人丢失到垃圾收集器的风中（除非一些其他代码使用它，在这种情况下它独自留下）。</p><p>  Garbage-collection is a language feature where the system can automatically figure out when some piece of memory it lent out is done being used, and can put it back in the bucket so it can then be doled out to someone else.</p><p>  垃圾收集是一种语言特征，系统可以自动弄清楚当它耗尽的某些内存是使用的，并且可以将其放回桶中，以便它可以将其丢弃给别人。 </p><p>    It completes the illusion that strings are just primitives: numbers and booleans are immutable in these languages too! You may assign a  new number into a &#34;slot&#34;, but you cannot  change the number per se.</p><p>它完成了字符串只是基元的错觉：数字和布尔也是这些语言的不可变！您可以将新号码分配给A＆＃34;插槽＆＃34;但您无法更改数字本身。</p><p>  It makes working with strings much simpler in many ways. Like with numbers you can pass a string off to another function (or even another thread!) without worrying about what will be done to it (and the other code can receive it without worrying what yours might do to it). It also dovetails nicely with automatic garbage-collection, which these languages also have.</p><p>  它使得在许多方面使用字符串更简单。与数字一样，您可以将字符串传递给另一个函数（甚至是另一个线程！），而不担心它将完成的内容（而其他代码可以在不担心您可能对此的情况下接收它）。它还与自动垃圾收集很好，这些语言也有很好的套装。</p><p>  Ruby is actually an outlier, which I just learned while researching this article! It does have mutable strings, despite being a high-level garbage-collected language.</p><p>  Ruby实际上是一个异常值，我刚刚在研究这篇文章时学会了！尽管是一种高级别的垃圾收集语言，它确实有变形字符串。</p><p>  If you&#39;re new to C/C++/Rust, this is probably your mental model for strings. It&#39;s probably ingrained deep in your bones, and peeling back the assumptions you&#39;ve formed is understandably a difficult thing to do.</p><p>  如果你和C / C ++ / RUST的新＆＃39，这可能是你的弦乐模型。它＆＃39可能在骨骼中深入根深蒂固，并剥离了你的假设和＃39; ve所形成的假设是可以理解的很难做到的事情。</p><p>      Well, the good news is they aren&#39;t just plain arrays of characters. Both languages give you a data structure wrapped around that character array which lets you do reasonable operations like append one string onto another, without manually tracking its length or re-allocating the underlying array as needed. Those things happen automatically.</p><p>      好吧，好消息是他们aren＆＃39; t只是字符阵列。这两种语言都会为您提供围绕该字符数组包裹的数据结构，该字符数组允许您完成合理的操作，如将一个字符串附加到另一个字符串，而无需手动跟踪其长度或根据需要重新分配底层数组。那些事情会自动发生。</p><p>  The bad news (depending on your perspective) is that the language doesn&#39;t hide as much about them as the languages above. You get/have to work with strings as a  data structure, not a  primitive. In Rust, the  String struct works very similarly to a  Vec of characters (or a Python  list, or a Java  ArrayList, or a JavaScript array, etc), with some added bells and whistles for convenience. Like a  Vec you can add characters onto the end, you can remove characters, and you can change characters in the middle. Other code that references the same  String will see these updates. The  String is a thing you very explicitly create (often via  String::new() or  String::from()), and possibly mutate, and then it gets de-allocated when it goes out of scope.</p><p>  坏消息（取决于您的角度来看）是语言并不像上面的语言一样隐藏它们。您必须使用/必须使用字符串作为数据结构，而不是一个原始的。在Rust中，字符串结构非常类似于字符（或Python列表，或Java ArrayList或JavaScript arrow等）的VEC，为方便起见，有一些添加的钟声和吹口哨。就像一个VEC，你可以将字符添加到最后，可以删除字符，并且可以更改中间的字符。引用相同字符串的其他代码将看到这些更新。字符串是您非常明确地创建的东西（通常通过字符串:: new（）或字符串:: from（）），并且可能会发生变异，然后它在脱离范围时被解除分配。</p><p>    Control. C++ and Rust are designed for use-cases where finely-grained control is valuable. For example there are times when you might want to re-use an existing  String and replace or add to its contents, instead of allocating a whole new one each time you  + something else with it. Giving people this level of control means presenting a more complex mental model.</p><p>    控制。 C ++和RUTR设计用于使用精细磨碎的控制有价值的情况。例如，有时您可能希望重新使用现有的字符串并替换或添加到其内容，而不是每次+使用它的其他内容分配全新的一个。给予人们这种控制级别的控制意味着呈现更复杂的心理模型。 </p><p>    String is the closest thing Rust has to the strings you&#39;re familiar with in other languages, but when you just type out a string literal, you get the type  &amp;str:</p><p>字符串是最接近的rust for the strings＆＃39;熟悉其他语言，但是当你只输入一个字符串文字时，你得到了类型＆amp; str：</p><p>    A  &amp;str is a string  slice. It&#39;s a reference (pointer + length) to a segment of one of those character arrays we&#39;ve been talking about. If you have a mutable slice ( &amp;mut str) then you can mutate its contents, however you  cannot changethe length. A string slice always refers to the same series of bytes in memory; you cannot add or remove bytes, because it doesn&#39;t know how to re-allocate itself if it needs more room. It doesn&#39;t even know whether or not those bytes live on the heap. It&#39;s just a reference.</p><p>    A＆amp; str是一个串切片。它的参考（指针+长度）到其中一个字符阵列之一的参考（指针+长度）。一直在谈论。如果您有一个可变的切片（＆amp; mut str），那么您可以突变其内容，但是您无法长度。字符串切片始终指的是内存中的相同系列字节;您无法添加或删除字节，因为它不知道如何重新分配自己，如果需要更多的空间。它甚至知道这些字节是否在堆上。它只是一个参考。</p><p>  The key to understanding strings in Rust is to internalize the fact that  every &amp;str needs a place to live. Often it lives inside a  String (we can get a  &amp;str from a  String by calling the  .as_str() method), but when your code itself contains a string literal like  &#34;What the heck?&#34;, the string you&#39;re given points to  a part of your program itself. Your program&#39;s code contains that character array, so the  &amp;str can just point to it directly. But it can&#39;t grow or shrink (in fact, in this case it can&#39;t even change - you can&#39;t get a  &amp;mut str to it) because there&#39;s other stuff around it.</p><p>  理解Rust中弦的关键是内化每个＆amp; str需要一个住的地方。它经常生活在字符串内（我们可以通过调用.as_str（）方法）从一个字符串中获取一个＆amp;当您的代码本身包含一个字符串文字，如＆＃34;哈克？＆＃34;，字符串you＆＃39;重新为您的程序本身提供指向。您的程序＆＃39; s代码包含该字符数组，所以＆amp; str可以直接指向它。但它可以＆＃39; t生长或缩小（实际上，在这种情况下，它可以＆＃39;甚至改变 - 你可以＆＃39; t得到一个＆amp; mut str到它），因为有些东西＆＃39;其他东西它。</p><p>    I think the first wall lots of people hit with Rust strings is something like this:</p><p>    我认为第一个墙上的墙壁击中生锈串是这样的：</p><p>  let a :  &amp;str  =  &#34;hello &#34; ; let b :  &amp;str  =  &#34;world&#34; ; let c  = a  + b ;</p><p>  让答：＆amp; str =＆＃34;你好＆＃34; ;让B：＆amp; str =＆＃34;世界＆＃34; ;让c = a + b;</p><p>  error [E0369 ] : cannot add ` &amp;str` to ` &amp;str`  - -&gt; src /main .rs : 4 : 15  | 4  |  let c  = a  + b ;  |  -  ^  -  &amp;str  |  |  |  |  | ` +` cannot  be used to concatenate two ` &amp;str` strings  |  &amp;str  |help : ` to_owned ( )` can  be used to create an owned `String` from a string reference . String concatenation appends the string on the right to the string on the left and may require reallocation . This requires ownership of the string on the left  | 4  |  let c  = a . to_owned ( )  + b ;  |  ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^</p><p>  错误[e0369]：不能添加`＆amp; str`到`＆amp; str`  -   - ＆gt; SRC / MAIN .RS：4：15 | 4 |让c = a + b; | -  ^  - ＆amp; str | | | | | `+`不能用于连接两个`＆amp; str`字符串| ＆amp; str |帮助：`to_owned（）`可用于从字符串引用创建所有的`string`。字符串连接将右侧的字符串附加到左侧的字符串，可能需要重新分配。这需要左侧的字符串| 4 |让c = a。 to_owned（）+ b; | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^</p><p>  &#34;What the heck? I have to call a method before I can add two strings together? This language sucks!&#34;</p><p>  ＆＃34;什么是哎呀？我必须在我一起添加两个字符串之前调用一种方法？这种语言很糟糕！＆＃34; </p><p>  But step back and think about it in the context of our new understanding:  a and  b live in our program&#39;s code, which can&#39;t be modified. So if we add them together, where does the new string live?</p><p>但在我们的新理解的背景下退回并思考它：A和B生活在我们的程序中，＆＃39; s＆＃39; t被修改。所以，如果我们在一起添加它们，新字符串会在哪里生活？</p><p>  Well, it&#39;s going to have to live in a  String. The language doesn&#39;t know how big it will need to be ahead of time, so we need to make a dynamic place for it that can adjust to whatever size necessary.</p><p>  好吧，它＆＃39;必须生活在一个字符串中。该语言并不知道提前需要大大，所以我们需要为它制作一个动态的地方，可以调整到必要的尺寸。</p><p>  Where do we get that  String? Well, we have some options there! We could create one separately:</p><p>  我们在哪里得到那个字符串？好吧，我们在那里有一些选择！我们可以单独创建一个：</p><p>  let a :  &amp;str  =  &#34;hello &#34; ; let b :  &amp;str  =  &#34;world&#34; ; let  mut new_string : String  = String :: new ( ) ;new_string . push_str (a ) ;new_string . push_str (b ) ; let c  = new_string . as_str ( ) ;</p><p>  让答：＆amp; str =＆＃34;你好＆＃34; ;让B：＆amp; str =＆＃34;世界＆＃34; ;让mut new_string：string = string :: new（）; new_string。 push_str（a）; new_string。 push_str（b）;让c = new_string。 AS_STR（）;</p><p>  That&#39;s a little clunky though. Fortunately, Rust makes our lives a little easier. In Rust the  + operator will take a  String on the left and a  &amp;str on the right, and it will call  .push_str() on the left  String,  mutating it so that it now holds a copy of the  &amp;str&#39;s contents, and then the  String will be the result of the addition. So this will work:</p><p>  那个＆＃39;虽然有点笨拙。幸运的是，生锈让我们的生活更轻松。在Rust中，+运算符将在左侧和A＆amp; str右侧拍摄一个字符串，它会在左侧字符串上调用.push_str（），使其变化，使其持有＆amp的副本。str＆＃39 ;■内容，然后字符串将是添加的结果。所以这将有效：</p><p>  let c  = String :: from ( &#34;hello &#34; )  +  &#34;world&#34; ;  // c is a String, not a &amp;str!</p><p>  让c = string :: from（＆＃34; hello＆＃34;）+＆＃34;世界＆＃34; ; // c是一个字符串，而不是a＆amp; str！</p><p>      Okay, one last thing: what&#39;s that  .to_owned() method suggested in the error message?  .to_owned() is a Rust method that several data types implement, and is intended for exactly this situation. From the docs:</p><p>      好的，最后一件事：什么＆＃39; s那个.to_owned（）方法在错误消息中建议？ .to_owned（）是几种数据类型实现的rust方法，并且用于恰好这种情况。来自文档： </p><p>  Some types make it possible to go from borrowed to owned, usually by implementing the Clone trait. But Clone works only for going from &amp;T to T. The ToOwned trait generalizes Clone to construct owned data from any borrow of a given type.</p><p>某些类型可以通过实施克隆特征来从借来的借用。但克隆仅适用于从＆amp; t到t. Todown特性概括了克隆从给定类型的任何借用构建拥有的数据。</p><p>  That&#39;s a bit technical, but the gist is that when you have a non-mutable reference to something, but you need to mutate it, etc (which we do! because we need to put  &#34;world&#34; somewhere), you call this method and it gives you a copy that you can do whatever you want with. In the case of  &amp;str, this copy ends up in the form of a  String. So:</p><p>  那个＆＃39; sa bit技术，但是，当你对某些东西有一个不可变形的引用时，你需要改变它，等等（我们做的！因为我们需要把＆＃34;世界＆＃34;在某处），您调用此方法，它为您提供了一份您可以使用所需的副本。在＆amp; str的情况下，此副本以字符串的形式结束。所以：</p><p>    When you&#39;ve got two  &amp;strs that you want to add together into a new  String, this is arguably the cleanest way to do it, which is why it&#39;s so conveniently suggested by the compiler:</p><p>    当你＆＃39;你有两个＆amp;你想要一起加入一个新的字符串，这可以说是最干净的方法，这就是为什么它和＃39;编译器如此方便地建议的原因：</p><p>        Rust is a uniquely powerful language, and despite all its challenges, it&#39;s uniquely accessible in some ways. It&#39;s minting tons new low-level programmers who otherwise were/would&#39;ve been scared off by C/C++. That&#39;s fantastic!</p><p>        Rust是一种独特的强大语言，尽管所有的挑战，它就在某种程度上独特地访问了它。它＆＃39;咒语吨的新的低级程序员否则/＆＃39; ve被c / c ++吓到了。那个＆＃39;太棒了！</p><p>  But being productive in it means learning how certain things really work, or you&#39;ll constantly be fighting with the compiler (which is still better than having constant bugs!). Hopefully I&#39;ve shed light on one of those subjects today.</p><p>  但在它的富有成效意味着学习某些事情如何真正工作，或者你＆＃39;不断与编译器（仍然比持续的虫子更好！）。希望我今天的一个科目之一，我＆＃39;</p><p>  To summarize: every piece of string content in Rust has to live somewhere. That somewhere can be in a quoted string literal, inside a  String on the heap, or somewhere else. When you&#39;re working with strings, you have to think about where the content actually lives/will live. If you don&#39;t have a place to put it, your code won&#39;t compile. If a reference/slice outlives the string content it&#39;s pointing at (borrowing is a topic for another day), your code won&#39;t compile. Incorporate this &#34;where&#34; into your mental model, and you&#39;ll have a much easier time getting your code to work.</p><p>  总结：生锈中的每一块字符串内容都必须居住在某个地方。某处可以在一个引用的字符串文字中，在堆上的字符串内，或其他地方。当你＆＃39;重新使用字符串时，您必须考虑内容实际生活/将居住的位置。如果你没有＆＃39; t有一个地方来放置它，你的代码赢得了＆＃39; t编译。如果参考/切片更远的字符串内容，它指向的字符串内容（借用是另一天的话题），您的代码赢得了＆＃39; t编译。合并这个＆＃34;哪里和＃34;进入你的心理模型，你＆＃39; ll有一个更容易的时间让你的代码工作。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.brandons.me/blog/why-rust-strings-seem-hard">https://www.brandons.me/blog/why-rust-strings-seem-hard</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/生锈/">#生锈</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/strings/">#strings</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/字符串/">#字符串</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>