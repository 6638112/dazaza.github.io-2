<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Futhark的蓝色噪音 Blue Noise in Futhark</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Blue Noise in Futhark<br/>Futhark的蓝色噪音 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-13 01:08:53</div><div class="page_narrow text-break page_content"><p>A while ago, I read Surma’s excellent article on  dithering. Immediately, it sparked my interest in the game  Return of the Obra Dinn, which I’ve since enjoyed immensely. I also thought it would be fun to try to implement some of the dithering algorithms he’s describing in Futhark, but I never really got around to it. Until now!</p><p>久前，我读了苏克马的抖动的优秀文章。立即，它引起了我对奥德拉·丁尼恩的游戏回归的兴趣，因为我从非常享受。我也认为尝试实施他在Futhark描述的一些抖动算法很有趣，但我从未真正过到处。到现在！</p><p> I’ll mainly be focusing on the blue noise filter, as that seemed like the most interesting one, but I’ll also be implementing the Bayer filter and perhaps a few others. I’ll skip most of the details about how dithering works and what the purpose is, and instead direct you to the article linked above. The purpose of this post is to illustrate how we can implement the algorithms described using Futhark.</p><p> 我主要将专注于蓝色噪声滤波器，因为这似乎是最有趣的滤波器，但我也可以在拜耳过滤器中实施拜耳滤波器，也许是其他人。我将跳过大部分关于抖动工作以及目的的详细信息，而是将您指向上面链接的文章。本篇文章的目的是说明我们如何实现使用Futhark描述的算法。</p><p> By the way, this blog post was written using  futhark literate so you can inspect the entire source code at your leisure.</p><p> 顺便说一下，这个博客帖子是使用Futhark incorate编写的，所以您可以在闲暇时检查整个源代码。</p><p>   We’ll be using the same images as in Surma’s blog post:</p><p>   我们将使用与Surma的博客文章中的相同图像：</p><p>   Loading images into futhark literate returns pixels in ARGB format in the form of  [][]u32. We’re only interested in greyscale images, so let’s write a few functions to convert an ARGB image into greyscale. We’ll use  f32 values between 0 and 1 to represent greyscale, with 0 being black and 1 being white. We also immediately perform some gamma-correction, so we can meaningfully work with greyscale images from now on.</p><p>   将图像加载到Futhark界面中以[] [] U32的形式返回ARGB格式的像素。我们只对灰度图像感兴趣，因此让我们写一些函数来将argb图像转换为灰度。我们将使用0到1之间的F32值来表示灰度，0是黑色和1个白色。我们也立即执行一些伽玛修正，因此我们可以从现在开始使用灰度图像。</p><p> let unpack_rgb (pixel: u32): (u8, u8, u8) = (u8.u32 pixel, u8.u32 (pixel &gt;&gt; 8), u8.u32 (pixel &gt;&gt; 16))let brightness (pixel: u32): f32 = let (r, g, b) = unpack_rgb pixel -- We could use just one of the channels, but this should give us the same -- result when the input images are already greyscale. in (f32.u8 r + f32.u8 g + f32.u8 b) / (255.0 * 3)</p><p> 让unpack_rgb（像素：u32）:( u8，u8，u8）=（u8.u32像素，u8.u32（像素＆gt;＆gt; 8），U8.u32（像素＆gt;＆gt; 16））让亮度（像素：U32）：F32 =设（r，g，b）= unpack_rgb pixel  - 我们可以只使用其中一个频道，但这应该给我们带来相同的结果 - 当输入图像已经灰度时，结果也是如此。在（F32.U8 R + F32.U8 G + F32.U8 B）/（255.0 * 3）</p><p>  let to_linear (b: f32): f32 = if b &lt;= 0.04045 then b / 12.92 else ((b + 0.055) / 1.055) ** 2.4let greyscale [n][m] (img: [n][m]u32): [n][m]f32 = map (map (to_linear &lt;-&lt; brightness)) img</p><p>  让_linear（b：f32）：f32 =如果b＆lt; = 0.04045则b / 12.92 else（（b + 0.055）/ 1.055）** 2.4灰度[n] [m] [m] [m] [n]（img：[n] [m] U32）：[n] [m] f32 = map（map（to_linear＆lt;亮度））img </p><p>  Now we can try to apply the simple quantization method of checking if each pixel is below or above 0.5 in order to determine if it should be black or white:</p><p>现在我们可以尝试应用单个量化方法检查每个像素是否低于或高于0.5，以便确定它是否应该是黑色或白色：</p><p>      Note that I use booleans to represent pure black-and-white pixels:  true is white and  false is black.</p><p>      请注意，我使用Booleans表示纯黑白像素：True是白色，假是黑色。</p><p> As stated in the original article, this method is pretty unsatisfying. We can barely see what’s depicted.</p><p> 如原始文章所述，这种方法非常不满意。我们几乎无法看到所描绘的内容。</p><p>  import &#34;lib/github.com/diku-dk/cpprandom/random&#34;module d = uniform_real_distribution f32 minstd_randlet quantize_random [n][m] (seed: i32) (img: [n][m]f32): [n][m]bool = -- Create a rng per pixel let rngs = minstd_rand.rng_from_seed [seed] |&gt; minstd_rand.split_rng n |&gt; map (minstd_rand.split_rng m) -- For each pixel apply the randomness factor and quantize in map2 (map2 (\rng pixel -&gt; let (_, x) = d.rand (0, 1) rng in pixel &gt; x)) rngs img</p><p>  Import＆＃34; lib / github.com / diku-dk / cpprandom / comantum＆＃34;模块d = siment_real_distibution f32 minstd_randlet量化_random [n] [m]（种子：i32）（img：[n] [m] f32） ：[n] [m] bool =  - 每像素创建RNG，让RNGs = minstd_rand.rng_from_seed [seed] |＆gt; minstd_rand.split_rng n |＆gt;地图（minstd_rand.split_rng m） - 对于每个像素，在map2中应用随机性因子并量化（map2（\ rng pixel  - ＆gt; let（_，x）= d.rand（0,1）rng在pixel＆gt; x ））RNGS IMG</p><p>      What we’re really doing when we’re quantizing, is to compare each pixel in the original image to a  mask. We’ve seen two cases, one where we compare to a mask where all the values are 0.5, and one where the mask is randomly generated, but many other masks exist. We can also imagine that it might not be necessary for the mask to have the same size as the input image, if we can just tile the original image with the mask image.</p><p>      我们在量化时真正做的是，将原始图像中的每个像素进行比较到掩码。我们已经看到了两个案例，我们将其与掩码进行比较，其中所有值为0.5，以及随机生成掩码的一个掩码，但存在许多其他掩模。我们还可以想象掩码可能没有必要具有与输入图像相同的大小，如果我们只能用掩模图像铺设原始图像。</p><p> This generalized process is called  dithering, so let’s write a function to apply a dither mask to an image:</p><p> 此广义过程称为抖动，因此让我们写一个函数来向图像应用抖动掩码：</p><p> let dither [n][m][n&#39;][m&#39;] (img: [n][m]f32) (mask: [n&#39;][m&#39;]f32): [n][m]bool = let helper i j pixel = pixel &gt; mask[i % n&#39;, j % m&#39;] in map2 (\i -&gt; map2 (helper i) (iota m)) (iota n) img</p><p> 让抖动[n] [n] [n＆＃39;] [m＆＃39;]（max：[n] [m] f32）（掩模：[n＆＃39;] [m＆＃39;] f32）：[ n] [m] bool =让辅助ij pixel = pixel＆gt; map2中[i％n＆＃39;]在map2（\ i  - ＆gt; map2（辅助i）（iota m））（iota n）img </p><p>  Now let’s look at some masks. The first one is the Bayer mask, which uses  Bayer matrices.</p><p>现在让我们看看一些面具。第一个是拜耳掩模，它使用拜耳矩阵。</p><p> First, we need a helper function:  concat_m takes four equal-sized matrices and arranges them in a square matrix.</p><p> 首先，我们需要一个辅助函数：Concat_m采用四个相等大小的矩阵并将它们排列在方矩阵中。</p><p> let concat_m [n] &#39;t (xss1: [n][n]t) (xss2: [n][n]t) (xss3: [n][n]t) (xss4: [n][n]t): [][]t = let n2 = n * 2 in concat (transpose (concat_to n2 (transpose xss1) (transpose xss2))) (transpose (concat_to n2 (transpose xss3) (transpose xss4)))</p><p> 假设concat_m [n]＆＃39; t（xss1：[n] t）（xss2：[n] [n] t）（xss3：[n] [n] t）（xss4：[n] [ n] t）：[] t =拍摄n2 = n * 2在concat（转置（转置xss1）（翻转xss2）））（转置（concate_to n2（翻转xss3）（翻转xss3）））</p><p>  let bayer (n: i64): [][]i32 = let helper i = map (map (\x -&gt; 4 * x + i)) let bayer = [[0, 2], [3, 1]] in if n == 0 then bayer else loop bayer for _ in 1 ... n do concat_m (helper 0 bayer) (helper 2 bayer) (helper 3 bayer) (helper 1 bayer)</p><p>  让拜耳（n：i64）：[] [] i32 =让舵机i = map（map（\ x  - ＆gt; 4 * x + i））让拜耳= [[0,2]，[3,1]]如果n == 0那么拜耳别跳别队_在1 ... n do concat_m（助手0拜耳）（Helper 2拜耳）（Helper 3 Bayer）（Helper 1 Bayer）</p><p> Note that we should perhaps use the by bit-arithmetic method instead, or at least figure out which one is faster: https://en.wikipedia.org/wiki/Ordered_dithering</p><p> 注意，我们应该使用比特算术方法，或者至少确定哪一个更快：https://en.wikipedia.org/wiki/Ordered_dithing</p><p> We’ll also need to be able to normalize Bayer filters (and later bluenoise filters). For that we’ll introduce  normalize_i32:</p><p> 我们还需要能够正常化拜耳滤波器（以及后来的Bluenoise过滤器）。为此，我们将介绍正常化_I32：</p><p> let normalize_i32 [n][m] (xss: [n][m]i32): [n][m]f32 = let maximum = i32.maximum (map i32.maximum xss) in map (map (\x -&gt; f32.i32 x / f32.i32 maximum)) xss</p><p> 让rangalize_i32 [n] [m]（xss：[n] [m] i32）：[n] [m] f32 =在地图中置于map（map（\ x  - ＆gt）的最大= i32.maximum ; f32.i32 x / f32.i32最大值））xss </p><p> Let’s see some results. First we create the first four bayer matrices, to see the effect of larger matrices on the dither result:</p><p>让我们看看一些结果。首先，我们创建了前四个拜耳矩阵，看看较大矩阵对抖动结果的影响：</p><p> let bayer0 = normalize_i32 (bayer 0)let bayer1 = normalize_i32 (bayer 1)let bayer2 = normalize_i32 (bayer 2)let bayer3 = normalize_i32 (bayer 3)</p><p> 让Bayer0 = Normalize_I32（拜耳0）让Bayer1 = Normalize_I32（拜耳1）让Bayer2 = Normalize_I32（拜耳2）让Bayer3 = Normalize_I32（拜耳3）</p><p>                    Let’s move on to blue noise filters, which is another way of generating masks for dithering. It’s based on the  void-and-cluster method as originally described by Robert Ulichney.</p><p>                    让我们继续前进到蓝色噪声过滤器，这是一种为抖动产生掩模的另一种方式。它基于最初由Robert Ulichney描述的空白和群集方法。</p><p> The algorithm has takes a random binary pattern as input, processes that into a  initial binary pattern and then uses that initial binary pattern to generate the final mask through three phases.</p><p> 该算法采用随机二进制图案作为输入，进入初始二进制模式，然后使用该初始二进制模式来通过三相生成最终掩模。</p><p> First, we need to be able to generate the input pattern, which is just a randomly generated binary pattern, where less than half the values are white:</p><p> 首先，我们需要能够生成输入模式，这只是一个随机生成的二进制模式，其中不到一半的值是白色：</p><p> module dist = uniform_int_distribution i64 minstd_randlet rand_binary_pattern (seed: i32) (n: i64) (m: i64): [n][m]bool = let rng = minstd_rand.rng_from_seed [seed] -- Generate an n*m matrix with just `false` values let xss = replicate n (replicate m false) -- Generate a minority number of indices and set them to `true`. let rngs = minstd_rand.split_rng (n * m / 4) rng let (idxs, vals) = map (\rng -&gt; let (rng, y) = dist.rand (0, n) rng let (_, x) = dist.rand (0, m) rng in ((y, x), true)) rngs |&gt; unzip in scatter_2d xss idxs vals</p><p> module dist = siment_int_distribution i64 minstd_randlet rand_binary_pattern（seed：i32）（n：i64）（m：i64）：[n] [m] bool = let rng = minstd_rand.rng_from_seed [seed]  - 仅使用n * m矩阵 - 生成n * m矩阵`false`值让xss = replice n（repliced m false） - 生成少数逻辑数目，并将它们设置为`true`。让RNGS = minstd_rand.split_rng（n * m / 4）rng（idxs，vals）= map（\ rng  - ＆gt; let（rng，y）= dist.rand（0，n）rng vet（_，x） = dist.rand（0，m）rng In（（y，x），true））rngs |＆gt;散射x2d xss andxs vals中的解压缩</p><p> The algorithm depends on being able to find the  tightest cluster and  largest void of a given image. To find the tightest cluster, we apply a gaussian blur to the image and find the brightest pixel in the result. To find the largest void, we do the same but try to find the darkest pixel in the result.</p><p> 该算法取决于能够找到最紧密的集群和给定图像的最大void。要找到最密封的集群，我们将高斯模糊应用于图像，并在结果中找到最亮的像素。要找到最大的void，我们这样做但尝试找到结果的最黑暗的像素。 </p><p> We therefore need to be able to compute a gaussian kernel that we can use to blur with. We use the gaussian function that Surma also uses, which is a slightly modified version of the one suggested by Ulichney.</p><p>因此，我们需要能够计算我们可以用来模糊的高斯内核。我们使用Surma也使用的高斯函数，这是Ulichney建议的略微修改的版本。</p><p> let gaussian_kernel (n: i64): [n][n]f32 = let sigma: f32 = 1.5 let factor = 1 / (2 * f32.pi * sigma ** 2) let gaussian x y = factor * f32.e ** (- (f32.i64 (x - n / 2) ** 2 + f32.i64 (y - n / 2) ** 2) / (2 * sigma ** 2)) in tabulate_2d n n gaussian</p><p> 让Gaussian_kernel（n：i64）：[n] [n] f32 =让sigma：f32 = 1.5让因素= 1 /（2 * f32.pi * sigma ** 2）让高斯xy = factor * f32.e ** （ - （f32.i64（x  -  n / 2）** 2 + f32.i64（y  -  n / 2）** 2）/（2 * sigma ** 2））在Tabular_2d nn gaussian</p><p>  let blur_naive [n] (kernel: [n][n]f32) (inp: [n][n]bool) = let halfn = n / 2 let blur_pixel (py: i64) (px: i64): f32 = map2 (\qy -&gt; map2 (\qx g -&gt; let x = (px + qx - halfn) % n let y = (py + qy - halfn) % n in f32.bool inp[y, x] * g) (iota n)) (iota n) kernel |&gt; flatten |&gt; f32.sum in tabulate_2d n n blur_pixel</p><p>  让Blur_naive [n]（内核：[n] [n] f32）（Inp：[n] bool）= Let Halfn = N / 2 Let blur_pixel（py：i64）（px：i64）：f32 = map2 （\ qy  - ＆gt; map2（\ qx g  - ＆gt; let x =（px + qx  -  halfn）％n在f32.bool inp [y，x] * g中let y =（py + qy  -  halfn）％n ）（iota n））（iota n）内核|＆gt;扁平|＆gt; f32.sum在tabulate_2d n b blur_pixel中</p><p> Having implemented our blur function, we can now implement the  tightest_cluster and  largest_void functions. Really, they are quite similar, and we could certainly abstract them out into one function, but keeping them separate makes it more clear what they do.</p><p> 实现了我们的模糊功能，我们现在可以实现CILICEST_CLUSTER和RESTAL_VOID函数。真的，他们是非常相似的，我们肯定可以将它们抽出一个函数，但保持它们分开使其更清楚他们的所作所为。</p><p> let tightest_cluster [n] (blur: [n][n]bool -&gt; [n][n]f32) (inp: [n][n]bool): (i64, i64) = -- Blur the input image blur inp -- Return also the indices for each pixel and its boolean value. |&gt; map3 zip3 (tabulate_2d n n (\i j -&gt; (i, j))) inp -- Flatten the matrix so we are working on a single-dimensional array. -- Find the highest-valued pixel, considering only pixels that are `true` in -- the original input. |&gt; flatten |&gt; reduce_comm (\(idx, x, v) (idx&#39;, x&#39;, v&#39;) -&gt; if v &gt; v&#39; || !x&#39; then (idx, x, v) else (idx&#39;, x&#39;, v&#39;)) ((-1, -1), false, f32.lowest) |&gt; (.0)let largest_void [n] (blur: [n][n]bool -&gt; [n][n]f32) (inp: [n][n]bool): (i64, i64) = blur inp |&gt; map3 zip3 (tabulate_2d n n (\i j -&gt; (i, j))) inp |&gt; flatten |&gt; reduce_comm (\(idx, x, v) (idx&#39;, x&#39;, v&#39;) -&gt; if v &lt; v&#39; || x&#39; then (idx, x, v) else (idx&#39;, x&#39;, v&#39;)) ((-1, -1), true, f32.highest) |&gt; (.0)</p><p> 让紧身_cluster [n]（模糊：[n] [n] bool  - ＆gt; [n] [n] f32）（Inp：[n] [n] bool）:( i64，i64）=  - 模糊输入图像Blur Inp  - 还返回每个像素的指数及其布尔值。 |＆gt; MAP3 ZIP3（表格_2D N N（\ I j  - ＆gt;（i，j）））INP  - 压平矩阵，因此我们正在使用一条单维数组。 - 查找最高值的像素，仅考虑仅为“真实”的像素 - 原始输入。 |＆gt;扁平|＆gt; reame_comm（\（idx，x，v）（idx＆＃39;，x＆＃39;，v＆＃39;） - ＆gt;如果v＆gt; v＆＃39; ||！x＆＃39;然后（idx，x， v）否则（Idx＆＃39;，x＆＃39;，v＆＃39;））（（-1，-1），false，f32.lowest）|＆gt; （.0）让Rest_void [n]（模糊：[n] [n] bool  - ＆gt; [n] [n] f32）（Inp：[n] bool）:( I64，I64）=模糊INP |＆gt; MAP3 ZIP3（表格_2D N N（\ I j  - ＆gt;（i，j）））INP |＆GT;扁平|＆gt; reame_comm（\（idx，x，v）（Idx＆＃39;，x＆＃39;，v＆＃39;） - ＆gt;如果v＆lt; v＆＃39; || x＆＃39;然后（idx，x，v ）否则（IDX＆＃39;，x＆＃39;，V＆＃39;））（（-1，-1），真实，f32.highest）|＆gt; （.0）</p><p> With these building blocks in place, let’s implement  initial_binary_pattern.  ip is the input pattern, and the result is the initial binary pattern.</p><p> 使用这些构建块，让我们实现Initial_Binary_Pattern。 IP是输入模式，结果是初始二进制模式。</p><p> let initial_binary_pattern [n] (blur: [n][n]bool -&gt; [n][n]f32) (ip: *[n][n]bool): *[n][n]bool = let (_, _, res) = -- Initialize the two indices with invalid but different values loop ((i, j), (i&#39;, j&#39;), ip) = ((-2, -2), (-1, -1), ip) -- While the the two indices are different while (i, j) != (i&#39;, j&#39;) do -- Compute the location of the tightest cluster let (i, j) = tightest_cluster blur ip -- Set that location to false let ip[i, j] = false -- Compute the location of the largest void let (i&#39;, j&#39;) = largest_void blur ip -- Set that location to true let ip[i&#39;, j&#39;] = true -- Repeat in ((i, j), (i&#39;, j&#39;), ip) in res</p><p> 让initial_binary_pattern [n]（模糊：[n] [n] bool  - ＆gt; [n] [n] f32）（ip：* [n] [n] bool）：* [n] [n] bool = let（ _，_，res）=  - 用无效但不同的值循环初始化两个索引（（i，j），（i＆＃39;，j＆＃39;），IP）=（（-2，-2）， （-1，-1），IP） - 虽然这两个指数不同（i，j）！=（i＆＃39;，j＆＃39;）do  - 计算最紧密的集群的位置i，j）= cixtest_cluster blur ip  - 将该位置设置为false，让let ip [i，j] = false  - 计算最大的void的位置让（i＆＃39;，j＆＃39;）= tally_void blur ip  -  - 将该位置设置为true，让ip [i＆＃39;，j＆＃39;] = true  - 重复（（i，j），（i＆＃39;，j＆＃39;），IP），IP） </p><p> Finally, in order to visualize the smallish patterns, let’s write some functions to scale them up to arbitrary pixels sizes:</p><p>最后，为了可视化Smallish模式，让我们写一些函数来扩展它们，以便达到任意像素大小：</p><p> let scale [n][m] &#39;t (n2: i64) (m2: i64) (img: [n][m]t): *[n2][m2]t = let y_scale = f32.i64 n2 / f32.i64 n let x_scale = f32.i64 m2 / f32.i64 m in tabulate_2d n2 m2 (\i j -&gt; img[i64.f32 &lt;| f32.i64 i / y_scale, i64.f32 &lt;| f32.i64 j / x_scale])let scale_f32: (i64 -&gt; i64 -&gt; [][]f32 -&gt; *[][]f32) = scalelet scale_bool: (i64 -&gt; i64 -&gt; [][]bool -&gt; *[][]bool) = scale</p><p> 让规模[n] [m]＆＃39; t（n2：i64）（m2：i64）（img：[n] [m] t）：* [n2] [m2] t = let y_scale = f32.i64 n2 / f32.i64 n设x_scale = f32.i64m2 / f32.i64 m在表格_2d n2 m2中（\ ij  - ＆gt; img [i64.f32＆lt; | f32.i64i / y_scale，i64.f32＆lt; | f32 .i64 j / x_scale]）Let Scale_F32：（I64  - ＆gt; I64  - ＆gt; [] [] f32  - ＆gt; * [] f32）=缩放量表_bool：（i64  - ＆gt; i64  - ＆gt; [] [ ] BOOL  - ＆gt; * [] [] bool）=比例</p><p> With all that in hand, let’s take a look at what a generated initial binary pattern could look like:</p><p> 随着所有的，让我们看看生成的初始二进制模式可以看起来像：</p><p>    That looks pretty good, I think! So now, let’s go about turning it into a blue noise pattern. The  bluenoise function is a pretty straight-forward implementation of the algorithm as described in Ulichneys original paper:</p><p>    看起来很好，我想！所以现在，让我们走进蓝色噪音模式。 Bluenoise函数是ulichneys原始纸上所述的算法非常直接的实现：</p><p> let bluenoise [n] (blur: [n][n]bool -&gt; [n][n]f32) (ibp: [n][n]bool) : [n][n]i32 = -- Load the binary pattern with the initial binary pattern let bp = copy ibp -- ones is the number of `true` values in the binary pattern let ones = flatten ibp |&gt; map i32.bool |&gt; i32.sum let rank = ones - 1 -- `dit` is the result dither array we&#39;ll input values into. let dit = replicate n (replicate n 0i32) -- Phase 1 let (dit, _, _) = loop (dit, bp, rank) while rank &gt;= 0 do let (i, j) = tightest_cluster blur bp let bp[i, j] = false let dit[i, j] = rank in (dit, bp, rank - 1) let bp = copy ibp let rank = ones -- Phase 2 let (dit, bp, rank) = loop (dit, bp, rank) while rank &lt; i32.i64 (n * n / 2) do let (i, j) = largest_void blur bp let bp[i, j] = true let dit[i, j] = rank in (dit, bp, rank + 1) -- Invert the binary pattern, such that `false` are now the minority pixels let bp = map (map (!)) bp -- Phase 3 let (dit, _, _) = loop (dit, bp, rank) while rank &lt; i32.i64 (n * n) do let (i, j) = tightest_cluster blur bp let bp[i, j] = false let dit[i, j] = rank in (dit, bp, rank + 1) in dit</p><p> 让bluenoise [n]（模糊：[n] [n] bool  - ＆gt; [n] [n] f32）（Ibp：[n] [n] bool）：[n] [n] i32 =  - 加载具有初始二进制模式的二进制模式让BP = Copy IBP  -  Oner是二进制模式中的“True”值的数量，让One = Flatten IBP |＆Gt;地图i32.bool |＆gt; I32.Sum让Rank = Oner  -  1  -  DIT`是结果抖动阵列WE＆＃39; LL输入值。让DIT =复制n（复制n 0i32） - 阶段1让（DIT，_，_）=循环（DIT，BP，等级）而等级＆gt; = 0做，让（i，j）= cirtent_cluster blur bp让bp [i，j] = false让dit [i，j] =排名（dit，bp，rank-1）让bp = copy Ibp让Rank = One  - 阶段2让（DIT，BP，RANK）=循环（ dit，bp，等级）等级＆lt; i32.i64（n * n / 2）让（i，j）= gest_void blur bp让bp [i，j] = true let dit [i，j] =排名（dit，bp，等级+ 1） -  - 倒置二进制模式，使得`FALSE`现在是少数像素让BP =地图（MAP（！））BP  - 阶段3让（DIT，_，_）=循环（DIT，BP，等级）而等级＆lt; i32.i64（n * n）让（i，j）= cixtest_cluster blur bp让bp [i，j] = false令dit [i，j] = dit中的（dit，bp，rank + 1）排名</p><p>     Looks pretty random to me. Let’s try to apply it to our images:</p><p>     对我看起来很随意。让我们试着将它应用于我们的图像：</p><p>      The naive blue noise implementation is pretty slow, even in Futhark. Let’s try to see if we can speed it up, by applying the gaussian in the frequency space.</p><p>      即使在Futhark，朴素的蓝色噪音实现也很慢。让我们试着看看我们是否可以通过在频率空间中应用高斯来加速它。 </p><p>    let center_fft [n] &#39;t (img: [n][n]t): [n][n]t = map (rotate (n / 2)) img |&gt; rotate (n / 2)</p><p>让Center_FFT [N]＆＃39; T（IMG：[n] [n] t）：[n] [n] t = map（旋转（n / 2））img |＆gt;旋转（N / 2）</p><p> To blur, we transform both the kernel and the input image to the frequency space and multiply them together</p><p> 要模糊，我们将内核和输入图像转换为频率空间并将它们乘以在一起</p><p> let blur_fft [n] (kernel: [n][n]f32) (inp: [n][n]bool): [n][n]f32 = let kernel&#39; = kernel |&gt; fft32.fft2_re |&gt; center_fft let inp&#39; = map (map f32.bool) inp |&gt; fft32.fft2_re |&gt; center_fft in map2 (map2 (c32.*)) kernel&#39; inp&#39; |&gt; center_fft |&gt; fft32.ifft2 |&gt; center_fft |&gt; map (map c32.mag)let bluenoise_mask_fft = normalize_i32 (bluenoise (blur_fft ker_64) ibp)</p><p> 让模糊[n]（内核：[n] [n] f32）（inp：[n] bool）：[n] [n] f32 =让核＆＃39; =内核|＆gt; fft32.fft2_re |＆gt; Center_fft让InP＆＃39; =地图（MAP F32.BOOL）INP |＆GT; fft32.fft2_re |＆gt; Map2中的Center_FFT（Map2（C32。*））内核＆＃39; INP＆＃39; |＆gt; Center_FFT |＆GT; FFT32.IFFT2 |＆GT; Center_FFT |＆GT;地图（地图C32.mag）Let Bluenoise_Mask_FFT = Normalize_I32（Bluenoise（Blur_fft Ker_64）IBP）</p><p>         -- ==-- entry: blur_naive_bench-- compiled random input { [32][32]bool }-- compiled random input { [64][64]bool }-- compiled random input { [128][128]bool }</p><p>          -  ==  - 输入：blur_naive_bench--编译随机输入{[32] [32] bool}  - 编译随机输入{[64] [64] bool}  - 编译随机输入{[128] [128] bool }</p><p>  -- ==-- entry: blur_fft_bench-- compiled random input { [32][32]bool }-- compiled random input { [64][64]bool }-- compiled random input { [128][128]bool }-- compiled random input { [256][256]bool }</p><p>   -  ==  - 输入：blur_fft_bench--编译随机输入{[32] [32] bool}  - 编译随机输入{[64] [64] bool}  - 编译随机输入{[128] [128] bool }  - 编译随机输入{[256] [256] bool}</p><p>  -- ==-- entry: bluenoise_test_naive-- compiled random input { [16][16]bool }-- compiled random input { [32][32]bool }-- compiled random input { [64][64]bool }</p><p>   -  ==  - 条目：bluenoise_test_naive  - 编译随机输入{[16] [16] bool}  - 编译随机输入{[32] [32] bool}  - 编译随机输入{[64] [64] bool }</p><p> entry bluenoise_test_naive [n] (inp: *[n][n]bool): *[n][n]i32 = let kernel = gaussian_kernel n let ibp = initial_binary_pattern (blur_naive kernel) inp in bluenoise (blur_naive kernel) ibp</p><p> 条目bluenoise_test_naive [n]（inp：* [n] [n] bool）：* [n] [n] i32 = let kernel = gaussian_kernel n让ibp = initial_binary_pattern（blur_naive内核）在bluenoise（blur_naive内核）IBP中的IBP </p><p> -- ==-- entry: bluenoise_test_fft-- compiled random input { [16][16]bool }-- compiled random input { [32][32]bool }-- compiled random input { [64][64]bool }-- compiled random input { [128][128]bool }</p><p>-  ==  - 输入：bluenoise_test_fft  - 编译随机输入{[16] [16] bool}  - 编译随机输入{[32] [32] bool}  - 编译随机输入{[64] [64] bool }  - 编译随机输入{[128] [128] bool}</p><p> entry bluenoise_test_fft [n] (inp: *[n][n]bool): *[n][n]i32 = let kernel = gaussian_kernel n let ibp = initial_binary_pattern (blur_naive kernel) inp in bluenoise (blur_fft kernel) ibp</p><p> 条目bluenoise_test_fft [n]（inp：* [n] [n] bool）：* [n] [n] i32 = let kernel = gaussian_kernel n让ibp = initial_binary_pattern（blur_naive内核）在bluenoise（blur_fft kernel）IBP中的IBP</p><p>  $ futhark bench --backend=opencl bluenoise.futCompiling bluenoise.fut...Reporting average runtime of 10 runs for each dataset.bluenoise.fut:blur_naive_bench (using bluenoise.fut.tuning):data/[32][32]bool.in: 102μs (RSD: 0.149; min: -37%; max: +25%)data/[64][64]bool.in: 410μs (RSD: 0.069; min: -12%; max: +10%)data/[128][128]bool.in: 4424μs (RSD: 0.005; min: -1%; max: +1%)data/[256][256]bool.in: 38266μs (RSD: 0.006; min: -1%; max: +1%)bluenoise.fut:blur_fft_bool (using bluenoise.fut.tuning):data/[32][32]bool.in: 159μs (RSD: 0.165; min: -31%; max: +25%)data/[64][64]bool.in: 175μs (RSD: 0.107; min: -14%; max: +20%)data/[128][128]bool.in: 179μs (RSD: 0.180; min: -35%; max: +26%)data/[256][256]bool.in: 133μs (RSD: 0.160; min: -18%; max: +29%)bluenoise.fut:bluenoise_test_naive (using bluenoise.fut.tuning):[16][16]bool: 23879μs (RSD: 0.003; min: -1%; max: +0%)[32][32]bool: 99598μs (RSD: 0.012; min: -1%; max: +2%)[64][64]bool: 5203831μs (RSD: 0.005; min: -1%; max: +1%)bluenoise.fut:bluenoise_test_fft (using bluenoise.fut.tuning):[16][16]bool: 40842μs (RSD: 0.076; min: -8%; max: +8%)[32][32]bool: 131507μs (RSD: 0.003; min: -0%; max: +0%)[64][64]bool: 522510μs (RSD: 0.002; min: -0%; max: +0%)[128][128]bool: 2110416μs (RSD: 0.009; min: -1%; max: +1%)</p><p>  $ futhark bechch  -  backend = depencl bluenoise.futcompiling bluenoise.fut ...报告每个DataSet.bluenoise.fut：blur_naive_bench（使用bluenoise.fut.tuning）：data / [32] [32] bool 。 ）BOOL.in：4424μs（RSD：0.005; min：-1％; max：+ 1％）数据/ [256] bool.in：38266μs（RSD：0.006; min ：-1％; max：+ 1％）bluenoise.fut：blur_fft_bool（使用bluenoise.fut.tuning）：data / [32] [32] bool.in：159μs（RSD：0.165; min：-31％;最大：+ 25％）数据/ [64] [64] BOOL.IN：175μs（RSD：0.107; min：-14％;最大：+ 20％）数据/ [128] bool.in：179μs（RSD ：0.180; min：-35％; max：+ 26％）数据/ [256] bool.in：133μs（rsd：0.160; min：-18％; max：+ 29％）bluenoise.fut：bluenoise_test_naive （使用Bluenoise.Fut.Tuning）：[16] [16] BOOL：23879μs（RSD：0.003; min：-1％;最大：+0％）[32] [32] BOOL：99598μs（RSD：0.012; min ：-1％;最大值：+ 2％）[64] [64] bool：5203831μs（RSD：0.005; min：-1％; max：+ 1％）bluenoise.fut：bluenoise_te st_fft（使用bluenoise.fut.tuning）：[16] [16] BOOL：40842μs（RSD：0.076; Min：-8％; MAX：+ 8％）[32] BOOL：131507μs（RSD：0.003; MIN：-0％;最大：+0％）[64] BOOL：522510μs（RSD：0.002; min：-0 ％; max：+ 0％）[128] bool：2110416μs（RSD：0.009; min：-1％;最大：+ 1％）</p><p> Surma mentions that it takes him about half a minute to generate a 64x64 blue noise texture on a 2018 MacBook Pro. In contrast, we do it in around half a second.</p><p> Surma提到它需要他大约半分钟，以在2018年MacBook Pro上产生64x64的蓝色噪声纹理。相比之下，我们在大约一秒钟内完成它。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://munksgaard.github.io/bluenoise/">https://munksgaard.github.io/bluenoise/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/蓝色/">#蓝色</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/noise/">#noise</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/f32/">#f32</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>