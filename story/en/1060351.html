<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用来自WebasseMbly的异步Web API Using asynchronous web APIs from WebAssembly</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Using asynchronous web APIs from WebAssembly<br/>使用来自WebasseMbly的异步Web API </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-28 10:59:53</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/e8e314237879f1e916b0dbc41e946650.jpg"><img src="http://img2.diglog.com/img/2021/4/e8e314237879f1e916b0dbc41e946650.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The I/O APIs on the web are asynchronous, but they&#39;re synchronous in most system languages. When compiling code to WebAssembly, you need to bridge one kind of APIs to another—and this bridge is Asyncify. In this post, you&#39;ll learn when and how to use Asyncify and how it works under the hood.</p><p>Web上的I / O API是异步的，但它们＆＃39;在大多数系统语言中同步。将代码编译为webassembly时，您需要将一个API桥接到另一个 - 而且此桥接性是异步。在这篇文章中，您＆＃39; ll学习何时以及如何使用Asyncify以及它在引擎盖下工作。</p><p>  I&#39;ll start with a simple example in C. Say, you want to read the user&#39;s name from a file, and greet them with a &#34;Hello, (username)!&#34; message:</p><p>  我＆＃39; ll从c的一个简单的例子开始。说，你想从文件中读取用户＆＃39; s名称，并用一个＆＃34迎接它们;你好，（用户名）！＆＃34;信息：</p><p>  # include  &lt;stdio.h&gt;   int  main ( )  {  FILE  *stream  =  fopen ( &#34;name.txt&#34; ,  &#34;r&#34; ) ;   char name [ 20 + 1 ] ;  size_t len  =  fread ( &amp;name ,  1 ,  20 , stream ) ;  name [len ]  =  &#39;\0&#39; ;   fclose (stream ) ;   printf ( &#34;Hello, %s!\n&#34; , name ) ;   return  0 ;  }</p><p>  ＃包括＆lt; stdio.h＆gt; int main（）{file * stream = fopen（＆＃34; name.txt＆＃34;，＆＃34; r＆＃34;）; CHAR名称[20 + 1]; size_t len = fread（＆amp;名称，1,20，流）;名称[len] =＆＃39; \ 0＆＃39; ; fclose（流）; Printf（＆＃34;你好，％s！\ n＆＃34;，name）;返回0; }</p><p> While the example doesn&#39;t do much, it already demonstrates something you&#39;ll find in an application of any size: it reads some inputs from the external world, processes them internally and writes outputs back to the external world. All such interaction with the outside world happens via a few functions commonly called input-output functions, also shortened to I/O.</p><p> 虽然该示例不做多少事情，但它已经展示了你的东西＆＃39; LL在任何大小的应用中找到的东西：它读取了外部世界的一些输入，内部处理它们并将输出写回外部世界。所有与外界的互动都会通过一些称为输入输出函数的少数功能发生，也缩短到I / O.</p><p> To read the name from C, you need at least two crucial I/O calls:  fopen, to open the file, and  fread to read data from it. Once you retrieve the data, you can use another I/O function  printf to print the result to the console.</p><p> 要从C中读取名称，您需要至少两个关键的I / O呼叫：Fopen，打开文件，并释放读取数据。检索数据后，您可以使用另一个I / O功能PrintF将结果打印到控制台。</p><p> Those functions look quite simple at first glance and you don&#39;t have to think twice about the machinery involved to read or write data. However, depending on the environment, there can be quite a lot going on inside:</p><p> 这些功能乍一看看起来非常简单，你不必三思而后行地思考读取或写入数据的机器。但是，根据环境，内部可能会有很多：</p><p> If the input file is located on a local drive, the application needs to perform a series of memory and disk accesses to locate the file, check permissions, open it for reading, and then read block by block until the requested number of bytes is retrieved. This can be pretty slow, depending on the speed of your disk and the requested size.</p><p> 如果输入文件位于本地驱动器上，则应用程序需要执行一系列内存和磁盘访问以找到文件，检查权限，打开它以读取，然后按块读取块，直到检索请求的字节数。 。这可能很慢，具体取决于磁盘的速度和所请求的大小。 </p><p> Or, the input file might be located on a mounted network location, in which case, the network stack will now be involved too, increasing the complexity, latency and number of potential retries for each operation.</p><p>或者，输入文件可能位于安装的网络位置，在这种情况下，现在涉及网络堆栈，增加每个操作的复杂性，延迟和潜在重试的数量。</p><p> Finally, even  printf is not guaranteed to print things to the console and might be redirected to a file or a network location, in which case it would have to go via the same steps above.</p><p> 最后，甚至PrintF不保证将事物打印到控制台，并且可能被重定向到文件或网络位置，在这种情况下它必须通过上面的相同步骤进行。</p><p> Long story short, I/O can be slow and you can&#39;t predict how long a particular call will take by a quick glance at the code. While that operation is running, your whole application will appear frozen and unresponsive to the user.</p><p> 长话短说，I / O可以很慢，你可以＆＃39; t预测特定呼叫在代码上快速浏览需要多长时间。虽然该操作正在运行，但您的整个应用程序将出现冻结并对用户没有响应。</p><p> This is not limited to C or C++ either. Most system languages present all the I/O in a form of synchronous APIs. For example, if you translate the example to Rust, the API might look simpler, but the same principles apply. You just make a call and synchronously wait for it to return the result, while it performs all the expensive operations and eventually returns the result in a single invocation:</p><p> 这不限于C或C ++。大多数系统语言以同步API的形式呈现所有I / O.例如，如果将示例转换为生锈，则API可能看起来更简单，但应用相同的原则。您只需拨打电话并同步等待它返回结果，而它执行所有昂贵的操作，最终返回一个调用中的结果：</p><p>   But what happens when you try to compile any of those samples to WebAssembly and translate them to the web? Or, to provide a specific example, what could &#34;file read&#34; operation translate to? It would need to read data from some storage.</p><p>   但是，当您尝试将这些样本中的任何一个样本编译为WebasseMbly并将其转换为Web时会发生什么？或者，提供一个具体的例子，可以＆＃34;文件读取＆＃34;操作转换为？它需要从某些存储中读取数据。</p><p>  The web has a variety of different storage options you could map to, such as in-memory storage (JS objects),   localStorage,  IndexedDB, server-side storage, and a new  File System Access API.</p><p>  Web具有各种不同的存储选项，您可以映射到内存存储（JS对象），LocalStorage，IndexedDB，服务器端存储以及新文件系统访问API。</p><p> However, only two of those APIs—the in-memory storage and the  localStorage—can be used synchronously, and both are the most limiting options in what you can store and for how long. All the other options provide only asynchronous APIs.</p><p> 但是，只有两个API-Memory存储和LocalStorage  - 可以同步使用，并且两者都是您可以存储的最限制性的选项以及多长时间。所有其他选项只提供异步API。 </p><p> This is one of the core properties of executing code on the web: any time-consuming operation, which includes any I/O, has to be asynchronous.</p><p>这是网络上执行代码的核心属性之一：任何耗时的操作，包括任何I / O，必须异步。</p><p> The reason is that the web is historically single-threaded, and any user code that touches the UI has to run on the same thread as the UI. It has to compete with the other important tasks like layout, rendering and event handling for the CPU time. You wouldn&#39;t want a piece of JavaScript or WebAssembly to be able to start a &#34;file read&#34; operation and block everything else—the entire tab, or, in the past, the entire browser—for a range from milliseconds to a few seconds, until it&#39;s over.</p><p> 原因是Web是历史上单线程的，并且触摸UI的任何用户代码都必须在与UI相同的线程上运行。它必须与其他重要任务相竞争，如布局，渲染和事件处理CPU时间。你想要一块javascript或webassembly，以便能够启动一个＆＃34;文件读取＆＃34;操作和阻止所有其他选项卡，或者，过去，整个浏览器 - 从毫秒到几秒钟，直到它＆＃39; s结束。</p><p> Instead, code is only allowed to schedule an I/O operation together with a callback to be executed once it&#39;s finished. Such callbacks are executed as part of the browser&#39;s event loop. I won&#39;t be going into details here, but if you&#39;re interested in learning how the event loop works under the hood, check out  Tasks, microtasks, queues and schedules which explains this topic in-depth.</p><p> 相反，代码仅允许将I / O操作加上一旦＆＃39完成了一次以执行的回调。此类回调是作为浏览器的一部分执行的。我赢了＆＃39;如果你＆＃39;＆＃39; revery＆＃39; verfy＆＃39;遗嘱感兴趣地学习事件循环如何在引擎盖下工作，签出讲述这个主题的任务，微量障碍，队列和计划深入。</p><p> The short version is that the browser runs all the pieces of code in sort of an infinite loop, by taking them from the queue one by one. When some event is triggered, the browser queues the corresponding handler, and on the next loop iteration it&#39;s taken out from the queue and executed. This mechanism allows simulating concurrency and running lots of parallel operations while using only a single thread.</p><p> 简短的版本是浏览器通过将它们从队列中从队列中取出一个无限循环中的所有代码。当触发某些事件时，浏览器队列相应的处理程序，并在下一个循环迭代中，从队列中取出并执行。此机制允许在仅使用单个线程时模拟并发性和运行大量并行操作。</p><p> The important thing to remember about this mechanism is that, while your custom JavaScript (or WebAssembly) code executes, the event loop is blocked and, while it is, there is no way to react to any external handlers, events, I/O, etc. The only way to get the I/O results back is to register a callback, finish executing your code, and give the control back to the browser so that it can keep processing any pending tasks. Once I/O is finished, your handler will become one of those tasks and will get executed.</p><p> 要记住此机制的重要事项是，虽然您的自定义JavaScript（或Webassembly）代码执行，但事件循环被阻止，虽然它是，但没有办法对任何外部处理程序，事件，I / O作出反应。获得I / O结果的唯一方法是注册回调，完成执行代码，并将控件返回给浏览器，以便它可以继续处理任何挂起的任务。一旦I / O完成，您的处理程序将成为其中一个任务，并将执行。</p><p> For example, if you wanted to rewrite the samples above in modern JavaScript and decided to read a name from a remote URL, you would use Fetch API and async-await syntax:</p><p> 例如，如果您想要在现代JavaScript中重写上述样本并决定从远程URL读取名称，则您将使用fetch API和Async-Await语法：</p><p>  async  function  main ( )  {   let response  =  await  fetch ( &#34;name.txt&#34; ) ;   let name  =  await response . text ( ) ;  console . log ( &#34;Hello, %s!&#34; , name ) ;  }</p><p>  async函数main（）{让响应=等待获取（＆＃34; name.txt＆＃34;）;让名称=等待答复。文本 （ ） ;安慰 。日志（＆＃34;您好，％s！＆＃34;，名称）; } </p><p> Even though it looks synchronous, under the hood each  await is essentially syntax sugar for callbacks:</p><p>即使它看起来同步，在引擎盖下，每个等待都是基本上是标准的语法糖：</p><p>   In this de-sugared example, which is a bit clearer, a request is started and responses are subscribed to with the first callback. Once the browser receives the initial response—just the HTTP headers—it asynchronously invokes this callback. The callback starts reading the body as text using  response.text(), and subscribes to the result with another callback. Finally, once  fetch has retrieved all the contents, it invokes the last callback, which prints &#34;Hello, (username)!&#34; to the console.</p><p>   在该替换示例中，这是一个比特更清晰的示例，启动请求，并使用第一回调订阅响应。一旦浏览器收到初始响应 - 只需http标题 - 它异步调用此回调。回调开始读取身体作为使用response.text（）的文本，并使用另一个回调订阅结果。最后，一旦获取已经检索了所有内容，它会调用最后一个回调，打印＆＃34;你好，（用户名）！＆＃34;到控制台。</p><p> Thanks to the asynchronous nature of those steps, the original function can return control to the browser as soon as the I/O has been scheduled, and leave the entire UI responsive and available for other tasks, including rendering, scrolling and so on, while the I/O is executing in background.</p><p> 由于这些步骤的异步性质，原始函数一旦安排I / O，就可以立即将控制返回到浏览器，并响应整个UI响应，包括其他任务，包括渲染，滚动等等，而且I / O在后台执行。</p><p> As a final example, even simple APIs like &#34;sleep&#34;, which makes an application wait a specified number of seconds, are also a form of an I/O operation:</p><p> 作为最终的示例，甚至是简单的API，＆＃34;睡眠＆＃34;，它使应用程序等待指定的秒数，也是I / O操作的一种形式：</p><p>   Sure, you could translate it in a very straightforward manner that would block the current thread until the time expires:</p><p>   当然，您可以以非常简单的方式翻译它，这将阻止当前线程直到时间到期：</p><p>   In fact, that&#39;s exactly what Emscripten does in  its default implementation of &#34;sleep&#34;, but that&#39;s very inefficient, will block the entire UI and won&#39;t allow any other events to be handled meanwhile. Generally, don&#39;t do that in production code.</p><p>   事实上，＆＃39;究竟是什么在其默认实施中的＆＃34;睡眠＆＃34;，但是＆＃39; s非常低效，将阻止整个UI并赢得任何其他事件同时处理。一般来说，在生产代码中on don＆＃39;</p><p> Instead, a more idiomatic version of &#34;sleep&#34; in JavaScript would involve calling  setTimeout(), and subscribing with a handler:</p><p> 相反，更加惯用的版本和＃34;睡眠＆＃34;在JavaScript中将涉及调用setTimeout（），并使用处理程序订阅： </p><p>   What&#39;s common to all these examples and APIs? In each case, the idiomatic code in the original systems language uses a blocking API for the I/O, whereas an equivalent example for the web uses an asynchronous API instead. When compiling to the web, you need to somehow transform between those two execution models, and WebAssembly has no built-in ability to do so just yet.</p><p>所有这些例子和API的共同点是什么＆＃39;在每种情况下，原始系统语言中的惯用代码使用I / O的阻塞API，而等效示例用于Web使用异步API。在编译到Web时，您需要在这两个执行模型之间以某种方式转换，并且WebAsseMbly没有内置的能力才能执行此操作。</p><p>  This is where  Asyncify comes in. Asyncify is a compile-time feature supported by Emscripten that allows pausing the entire program and asynchronously resuming it later.</p><p>  这是Asyncify进出的地方。Asyncify是EMScripten支持的编译时功能，允许暂停整个程序并在稍后异步恢复它。</p><p>   If you wanted to use Asyncify to implement an asynchronous sleep for the last example, you could do it like this:</p><p>   如果您想在最后一个示例中使用Asyncify来实现异步睡眠，则可以这样做：</p><p>  # include  &lt;stdio.h&gt;   # include  &lt;emscripten.h&gt;   EM_JS ( void , async_sleep ,  ( int seconds ) ,  {  Asyncify . handleSleep (wakeUp  = &gt;  {   setTimeout (wakeUp , seconds  *  1000 ) ;   } ) ;  } ) ; …  puts ( &#34;A&#34; ) ;  async_sleep ( 1 ) ;  puts ( &#34;B&#34; ) ;</p><p>  ＃包括＆lt; stdio.h＆gt; ＃包括＆lt; emscripten.h＆gt; em_js（void，async_sleep，（int copes），{asyncify。handlesleep（wakeup =＆gt; {setsimout（唤醒，秒* 1000）;}）; ......放（＆＃34; a＆＃34;）; async_sleep（1）;放（＆＃34; b＆＃34;）;</p><p> EM_JS is a macro that allows defining JavaScript snippets as if they were C functions. Inside, use a function   Asyncify.handleSleep() which tells Emscripten to suspend the program and provides a  wakeUp() handler that should be called once the asynchronous operation has finished. In the example above, the handler is passed to  setTimeout(), but it could be used in any other context that accepts callbacks. Finally, you can call  async_sleep() anywhere you want just like regular  sleep() or any other synchronous API.</p><p> EM_JS是一种宏，允许定义JavaScript片段，就像它们是C函数一样。在内部，使用函数asyncify.handlesleep（），它告诉EMScripten暂停程序并提供一旦异步操作完成后应调用的唤醒（）处理程序。在上面的示例中，处理程序将传递给SetTimeOut（），但它可以在接受回调的任何其他上下文中使用。最后，您可以像常规睡眠（）或任何其他同步API一样调用您想要的Async_sleep（）。</p><p> When compiling such code, you need to tell Emscripten to activate the Asyncify feature. Do that by passing  -s ASYNCIFY as well as   -s ASYNCIFY_IMPORTS=[func1, func2] with an array-like list of functions that might be asynchronous.</p><p> 编译此类代码时，您需要告诉EMScripten来激活Asyncify功能。通过assyncify和syyncify_imports = [func1，func2]来执行此操作，其中包含可能是异步的数组的函数列表。</p><p>   This lets Emscripten know that any calls to those functions might require saving and restoring the state, so the compiler will inject supporting code around such calls.</p><p>   这让Emscripten知道对这些函数的任何调用可能需要保存和恢复状态，因此编译器将在此类调用周围注入支持代码。 </p><p> Now, when you execute this code in the browser you&#39;ll see a seamless output log like you&#39;d expect, with B coming after a short delay after A.</p><p>现在，当您在浏览器中执行此代码时，请参阅像您的无缝输出日志，如您所期望的无缝输出日志。</p><p>   You can  return values from Asyncify functions too. What you need to do is return the result of  handleSleep(), and pass the result to the  wakeUp() callback. For example, if, instead of reading from a file, you want to fetch a number from a remote resource, you can use a snippet like the one below to issue a request, suspend the C code, and resume once the response body is retrieved—all done seamlessly as if the call were synchronous.</p><p>   您也可以从Asyncify函数中返回值。您需要做的是返回Handlesleep（）的结果，并将结果传递给WakeUp（）回调。例如，如果不是从文件读取，则要从远程资源获取一个数字，可以使用下面的片段发出请求，暂停C代码，并重新检索响应主体 - 所有如何无缝完成，就像呼叫同步一样。</p><p>  EM_JS (int , get_answer ,  ( ) ,  {   return Asyncify . handleSleep ( wakeUp  =&gt;  {   fetch ( &#34;answer.txt&#34; )   . then ( response  =&gt; response . text ( ) )   . then ( text  =&gt;  wakeUp ( Number (text ) ) ) ;   } ) ;  } ) ;  puts ( &#34;Getting answer...&#34; ) ; int answer  =  get_answer ( ) ;  printf ( &#34;Answer is %d\n&#34; , answer ) ;</p><p>  em_js（int，get_answer，（），{return asyncify。handlesleep（wakeup =＆gt; {fetch（＆＃34; ackan.txt＆＃34;）。然后（response =＆gt;响应。text（）。然后（文本=＆gt;唤醒（数字（文本）））;}）;}）;放（＆＃34;得到答案...＆＃34;）; int回答= get_answer（）; printf（＆＃34;答案是％d \ n＆＃34;，答案）;</p><p> In fact, for Promise-based APIs like  fetch(), you can even combine Asyncify with JavaScript&#39;s async-await feature instead of using the callback-based API. For that, instead of  Asyncify.handleSleep(), call  Asyncify.handleAsync(). Then, instead of having to schedule a  wakeUp() callback, you can pass an  async JavaScript function and use  await and  return inside, making code look even more natural and synchronous, while not losing any of the benefits of the asynchronous I/O.</p><p> 事实上，对于基于承诺的API，如fetch（），您甚至可以使用JavaScript＆＃39; s异步 - 等待特征而不是使用基于回调的API来组合Asyncify。为此，而不是Asyncify.Handlesleep（），call asyncify.handleasync（）。然后，不必计划唤醒（）回调，您可以通过异步JavaScript函数并使用等待和返回内部，使代码看起来更自然和同步，同时不会丢失异步I / O的任何优势。</p><p>  EM_JS (int , get_answer ,  ( ) ,  {   return Asyncify . handleAsync ( async  ( )  =&gt;  {   let response  =  await  fetch ( &#34;answer.txt&#34; ) ;   let text  =  await response . text ( ) ;   return  Number (text ) ;   } ) ;  } ) ;  int answer  =  get_answer ( ) ;</p><p>  em_js（int，get_answer，（），{return asyncify。handleasysync（async（）=＆gt; {让响应=等待获取（＆＃34; ackan.txt＆＃34;）;让文本=等待响应。文字（）;返回号码（文本）;}）;}）; int回答= get_answer（）;</p><p>  But this example still limits you only to numbers. What if you want to implement the original example, where I tried to get a user&#39;s name from a file as a string? Well, you can do that too!</p><p>  但此示例仍然仅限于数字。如果您想实现原始示例，我试图从文件中获取用户的名称，从中何时才能成为字符串？好吧，你也可以这样做！</p><p> Emscripten provides a feature called  Embind that allows you to handle conversions between JavaScript and C++ values. It has support for Asyncify as well, so you can call  await() on external  Promises and it will act just like  await in async-await JavaScript code:</p><p> EMScripten提供称为Jualind的功能，允许您处理JavaScript和C ++值之间的转换。它也支持异步，因此您可以在外部承诺上调用await（），它将类似于Async-Await JavaScript代码的等待： </p><p>   When using this method, you don&#39;t even need to pass  ASYNCIFY_IMPORTS as a compile flag, as it&#39;s already included by default.</p><p>使用此方法时，您甚至需要将Asyncify_import传递为编译标志，默认情况下已包含＆＃39;默认情况下。</p><p>   Say that you have a similar synchronous call somewhere in your Rust code that you want to map to an async API on the web. Turns out, you can do that too!</p><p>   例如，您在生锈代码中有类似的同步调用，您要将您想要映射到Web上的异步API。事实证明，你也可以这样做！</p><p> First, you need to define such a function as a regular import via  extern block (or your chosen language&#39;s syntax for foreign functions).</p><p> 首先，您需要将这样的函数定义为常规导入通过extern块（或您所选择的语言＆＃39;对外部函数的语法）。</p><p>      Now you need to instrument the WebAssembly file with code for storing/restoring the stack. For C / C++, Emscripten would do this for us, but it&#39;s not used here, so the process is a bit more manual.</p><p>      现在，您需要使用代码介绍WebasseMbly文件以存储/还原堆栈。对于C / C ++，Emscripten会为我们做到这一点，但它在这里没有使用它，因此该过程有点手动。</p><p> Luckily, the Asyncify transform itself is completely toolchain-agnostic. It can transform arbitrary WebAssembly files, no matter which compiler it&#39;s produced by. The transform is provided separately as part of the  wasm-opt optimiser from the  Binaryen toolchain and can be invoked like this:</p><p> 幸运的是，Asyncify变换本身是完全的工具链无症状。它可以改变任意的webassembly文件，无论哪个编译器它＆＃39;该转换是单独提供的，作为来自Binaryen Toolchain的WASM-Opt优化器的一部分，可以像这样调用：</p><p>   Pass  --asyncify to enable the transform, and then use  --pass-arg=… to provide a comma-separated list of asynchronous functions, where the program state should be suspended and later resumed.</p><p>   pass -ascify以启用转换，然后使用--pass-arg = ...以提供逗号分隔的异步函数列表，其中程序状态应暂停，稍后恢复。</p><p> All that&#39;s left is to provide supporting runtime code that will actually do that—suspend and resume WebAssembly code. Again, in the C / C++ case this would be included by Emscripten, but now you need custom JavaScript glue code that would handle arbitrary WebAssembly files. We&#39;ve created a library just for that.</p><p> left是提供支持的运行时代码，实际执行该挂起并恢复WebasseMbly代码。同样，在C / C ++案例中，EMScripten将包括在内，但现在您需要处理任意WebasseMbly文件的自定义JavaScript胶水代码。我们＆＃39; ve为此创建了一个图书馆。 </p><p>  It simulates a standard  WebAssembly instantiation API, but under its own namespace. The only difference is that, under a regular WebAssembly API you can only provide synchronous functions as imports, while under the Asyncify wrapper, you can provide asynchronous imports as well:</p><p>它模拟了标准的WebAsseMbly Instantial API，但在其自己的命名空间下。唯一的区别是，在常规webassembly api下，您只能将同步函数提供为导入，而在Asyncify包装器下，您也可以提供异步导入：</p><p>  const  { instance  }  =  await Asyncify . instantiateStreaming ( fetch ( &#39;app.wasm&#39; ) ,  {  env :  {   async  get_answer ( )  {   let response  =  await  fetch ( &#34;answer.txt&#34; ) ;   let text  =  await response . text ( ) ;   return  Number (text ) ;   }   }  } ) ; …  await instance .exports . main ( ) ;</p><p>  const {实例} =等待Asyncify。 InstantiAtesteStreaming（获取（＆＃39; app.wasm＆＃39;），{enth：{async get_answer（）{让响应=等待获取（＆＃34; acquess.txt＆＃34;）;让文本=等待响应。文字（）;返回号码（文本）;}}}）; ......等待实例.ports。主要的 （ ） ;</p><p> Once you try to call such an asynchronous function - like  get_answer() in the example above - from the WebAssembly side, the library will detect the returned  Promise, suspend and save the state of the WebAssembly application, subscribe to the promise completion, and later, once it&#39;s resolved, seamlessly restore the call stack and state and continue execution as if nothing has happened.</p><p> 一旦您尝试称之为上面的示例中的异步函数 - 像get_answer（） - 从webassembly侧，库将检测到返回的承诺，暂停和保存WebasseMbly应用程序的状态，订阅承诺完成，并稍后，一旦它解决了，就解决了，无缝恢复呼叫堆栈和状态，并继续执行，好像没有发生任何事情。</p><p> Since any function in the module might make an asynchronous call, all the exports become potentially asynchronous too, so they get wrapped as well. You might have noticed in the example above that you need to  await the result of  instance.exports.main() to know when the execution is truly finished.</p><p> 由于模块中的任何函数都可能进行异步呼叫，因此所有导出都会变得异步，因此它们也会被包裹。在上面的示例中，您可能已经注意到，您需要等待instance.exports.main（）的结果，以知道执行何时何时完成。</p><p>  When Asyncify detects a call to one of the  ASYNCIFY_IMPORTS functions, it starts an asynchronous operation, saves the entire state of the application, including the call stack and any temporary locals, and later, when that operation is finished, restores all the memory and call stack and resumes from the same place and with the same state as if the program has never stopped.</p><p>  当Asyncify检测到一个Asyncify_imports函数的呼叫时，它启动异步操作，保存应用程序的整个状态，包括调用堆栈和任何临时当地人，稍后，当该操作完成时，恢复所有内存并呼叫堆叠并从同一个地方恢复，并且具有与程序从未停止的相同状态。</p><p> This is quite similar to async-await feature in JavaScript that I showed earlier, but, unlike the JavaScript one, doesn&#39;t require any special syntax or runtime support from the language, and instead works by transforming plain synchronous functions at compile-time.</p><p> 这与我之前显示的JavaScript中的异步 - 等待特征非常相似，但与JavaScript One不同，不需要语言的任何特殊语法或运行时支持，而是通过在编译时转换普通同步功能 - 而是适用时间。</p><p>    Asyncify takes this code and transforms it to roughly like the following one (pseudo-code, real transformation is more involved than this):</p><p>    Asyncify采用此代码并将其转换为大致相当于以下一个（伪代码，实际转换比此更涉及）： </p><p>  if  ( mode  ==  NORMAL_EXECUTION )  {   puts ( &#34;A&#34; ) ;   async_sleep ( 1 ) ;   saveLocals ( ) ;  mode  =  UNWINDING ;   return ;  }  if  ( mode  ==  REWINDING )  {   restoreLocals ( ) ;  mode  =  NORMAL_EXECUTION ;  }  puts ( &#34;B&#34; ) ;</p><p>if（mode == normal_execution）{puts（＆＃34; a＆＃34;）; async_sleep（1）; Savelocals（）; mode =展开;返回 ; }如果（mode == rewinding）{restorelelocals（）; mode = normal_execution;放（＆＃34; B＆＃34;）;</p><p> Initially  mode is set to  NORMAL_EXECUTION. Correspondingly, the first time such transformed code is executed, only the part leading up to  async_sleep() will get evaluated. As soon as the asynchronous operation is scheduled, Asyncify saves all the locals, and unwinds the stack by returning from each function all the way to the top, this way giving control back to the browser event loop.</p><p> 最初模式设置为romalm_execution。相应地，第一次执行此类转换代码，只执行通往Async_sleep（）的部分将被评估。一旦安排了异步操作，Asyncify会保存所有当地人，并通过从每个函数返回到顶部来解除堆栈，以这种方式使控制回浏览器事件循环。</p><p> Then, once  async_sleep() resolves, Asyncify support code will change  mode to  REWINDING, and call the function again. This time, the &#34;normal execution&#34; branch is skipped - since it already did the job last time and I want to avoid printing &#34;A&#34; twice - and instead it comes straight to the &#34;rewinding&#34; branch. Once it&#39;s reached, it restores all the stored locals, changes mode back to &#34;normal&#34; and continues the execution as if the code were never stopped in the first place.</p><p> 然后，一旦Async_sleep（）解析，Asyncify支持代码将更改模式以重新运行，并再次调用该函数。这次，＆＃34;正常执行＆＃34;分支是跳过 - 因为它已经上次已经完成了这项工作，我想避免印刷＆＃34; a＆＃34;两次 - 而且它直接到了＆＃34;倒下＆＃34;分支。一旦它到达，它达到了，它会恢复所有存储的当地人，更改模式回到＆＃34;正常＆＃34;并继续执行，好像代码永远不会停止。</p><p>  Unfortunately, Asyncify transform isn&#39;t completely free, since it has to inject quite a bit of supporting code for storing and restoring all those locals, navigating the call stack under different modes and so on. It tries to modify only functions marked as asynchronous on the command line, as well as any of their potential callers, but the code size overhead might still add up to approximately 50% before compression.</p><p>  不幸的是，异步转换为完全自由，因为它必须注入相当多的支持代码来存储和恢复所有这些本地，从而在不同模式下导航呼叫堆栈等。它试图仅在命令行上修改标记为异步的函数，以及其潜在的呼叫者中的任何一个，但在压缩之前，代码大小仍可能会增加大约50％。</p><p>  This isn&#39;t ideal, but in many cases acceptable when the alternative is not having the functionality altogether or having to make significant rewrites to the original code.</p><p>  这是＆＃39; t的理想，但在许多情况下，当替代方案没有完全或必须对原始代码进行重写的功能时，可以接受。</p><p> Make sure to always enable optimizations for the final builds to avoid it going even higher. You can also check  Asyncify-specific optimization options to reduce the overhead by limiting transforms only to specified functions and/or only direct function calls. There is also a minor cost to runtime performance, but it&#39;s limited to the async calls themselves. However, compared to the cost of the actual work, it&#39;s usually negligible.</p><p> 确保始终为最终构建启用优化以避免它更高。您还可以通过仅限于指定函数和/或仅直接函数调用，检查特定于特定于特定的优化选项以减少开销。运行时性能也有次要的成本，但它＆＃39; s仅限于异步呼叫自己。但是，与实际工作的成本相比，它通常可以忽略不计。</p><p>  Now that you&#39;ve looked at the simple examples, I&#39;ll move on to more complicated scenarios.</p><p>  现在你看了看起来简单的例子，我＆＃39; ll继续转移到更复杂的情景。 </p><p> As mentioned in the beginning of the article, one of the storage options on the web is an asynchronous  File System Access API. It provides access to a real host filesystem from a web application.</p><p>如文章开头所述，Web上的一个存储选项是异步文件系统访问API。它可以从Web应用程序提供对真实主机文件系统的访问。</p><p> On the other hand, there is a de-facto standard called  WASI for WebAssembly I/O in the console and the server-side. It was designed as a compilation target for system languages, and exposes all sorts of file system and other operations in a traditional synchronous form.</p><p> 另一方面，在控制台和服务器端中存在一个名为WEDAssembly I / O的WASI的De-Facto标准。它被设计为系统语言的编译目标，并以传统的同步形式公开各种文件系统和其他操作。</p><p> What if you could map one to another? Then you could compile any application in any source language with any toolchain supporting the WASI target, and run it in a sandbox on the web, while still allowing it to operate on real user files! With Asyncify, you can do just that.</p><p> 如果你可以将一个映射到另一个人怎么办？然后，您可以使用支持WASI目标的任何源语言中的任何源语言编译任何应用程序，并在Web上的沙箱中运行它，同时允许它在真实的用户文件上运行！使用异步，您可以做到这一点。</p><p> In this demo, I&#39;ve compiled Rust  coreutils crate with a few minor patches to WASI, passed via Asyncify transform and implemented asynchronous  bindings from WASI to File System Access API on the JavaScript side. Once combined with  Xterm.js terminal component, this provides a realistic shell running in the browser tab and operating on real user files - just like an actual terminal.</p><p> 在这个演示中，i＆＃39; Ve编译的rust coreutils用几个小修补程序向isi括号，通过Asyncify Transform传递，并通过WASI实现了JavaScript侧的文件系统访问API的异步绑定。一旦与Xterm.js终端组件组成，它就提供了一个现实的shell在浏览器选项卡中运行并在真实的用户文件上运行 - 就像一个实际的终端。</p><p>   Asyncify use-cases are not limited just to timers and filesystems, either. You can go further and use more niche APIs on the web.</p><p>   Asyncify使用情况不仅限于定时器和文件系统。您可以进一步进一步并在Web上使用更多的利基API。</p><p> For example, also with the help of Asyncify, it&#39;s possible to map  libusb—probably the most popular native library for working with USB devices—to a  WebUSB API, which gives asynchronous access to such devices on the web. Once mapped and compiled, I got standard libusb tests and examples to run against chosen devices right in the sandbox of a web page.</p><p> 例如，也在Asyncify的帮助下，它可以映射Libusb-可能是最受欢迎的本机库，用于使用USB设备 - 到WebUSB API，它为Web上的这些设备提供异步访问。一旦映射和编译，我得到了标准的libusb测试和示例，以便在网页的沙箱中运行的所选设备。</p><p>   Those examples demonstrate just how powerful Asyncify can be for bridging the gap and porting all sorts of applications to the web, allowing you to gain cross-platform access, sandboxing, and better security, all without losing functionality.</p><p>   这些示例似乎只有强大的Asyncify可以用于拓展间隙并将各种应用程序移植到Web，允许您获得跨平台访问，沙箱和更好的安全性，而不是失去功能。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://web.dev/asyncify/">https://web.dev/asyncify/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/来自/">#来自</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>