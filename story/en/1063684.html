<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>来自程序员的透视（2015）的兔子 Bunnyhopping from the Programmer's Perspective (2015)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Bunnyhopping from the Programmer's Perspective (2015)<br/>来自程序员的透视（2015）的兔子 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-05 15:54:43</div><div class="page_narrow text-break page_content"><p>&#34;Bunnyhopping&#34; is an exploit of a very popular bug in games like  Quake III Arena,  Half-Life, and  Counter-Strike. Bunnyhopping, or  bhopping for short, allows a player to exceed the game-defined speed limit. It has created entirely new methods of play and allows very exciting, fast-paced emergent gameplay. As a decidedly skill-based mechanic, competitive players love bhopping because it is so hard to master. Thus, it may be useful to you as a game developer to &#34;implement&#34; bunnyhopping into your game. The purpose of this article is to define what bunnyhopping is, why it is important to consider as a game developer, and how to implement it mathematically into your FPS movement code. All code examples are open-source and free to use, as always.</p><p>＆＃34; Bunnyhopping＆＃34;在Quake III竞技场，半衰期和反击等游戏中是一种非常受欢迎的错误。 Bunnyhopping或Bhopping for Short，允许玩家超过游戏定义的速度限制。它创建了完全新的播放方法，并允许非常令人兴奋，快节奏的紧急游戏。作为一个明确的技巧的机械师，竞争球员喜欢Bhopping，因为它很难掌握。因此，您作为游戏开发人员对＆＃34;实施＆＃34; Bunnyhopping进入你的游戏。本文的目的是定义Bunnyhopping的原因，为什么考虑作为游戏开发人员很重要，以及如何在数学上将其实施到您的FPS移动代码中。所有代码示例都是开源的，始终是免费的。</p><p>     The most important component of bunnyhopping is the concept of  Air Strafing. In the clip above you may notice the player quickly wiggle his mouse left and right. When he does this, he syncs his mouse movement with his movement keys. That is, when he moves the mouse to the left he holds the  a (left movement) key, and when he moves the mouse to the right he holds the  d (right movement) key. The result of this from the player&#39;s perspective is a rapid increase in speed. This explains in part why bunnyhopping is such a skill-based mechanic. It takes great skill and accuracy to perfectly sync your mouse movement to your movement keys.</p><p>     Bunnyhopping最重要的成分是空气流动的概念。在上面的剪辑中，您可能会注意到玩家迅速掀起鼠标左右。当他这样做时，他用他的运动钥匙同步他的鼠标运动。也就是说，当他将鼠标移动到左侧时，他握住了一个（左移）键，当他将鼠标移动到右侧时，他握住D（右移）键。来自玩家的结果和＃39; S的透视是速度快速增加。这部分地解释了为什么Bunnyhopping是这样一种技能的机械师。它需要很大的技巧和准确性，可以将您的鼠标移动与移动钥匙完美地同步。</p><p>  Air Strafing works because of the way movement acceleration is handled in the Quake Engine. It is possible in any game that is based off of the Quake engine, such as Source. If you would like you can check out the  Quake III movement code or the  Half Life 2 movement code on GitHub. Keep in mind that both codebases contain engine-specific code so they aren&#39;t as easy to integrate as the code in this article. Nevertheless it is still interesting to see the origins of the mechanic.</p><p>  由于在地震引擎中处理移动加速度的方式，空气流放工作。在任何基于地震引擎的游戏中可以进行，例如源。如果您希望您可以查看Quake III运动代码或GitHub上的半衰期2机芯代码。请记住，两个代码库都包含特定于发动机的代码，因此它们是易于集成在本文中的代码中的易于集成。然而，看到机械师的起源仍然有趣。</p><p> In the Quake III acceleration code, movement speed is limited in a very interesting and nonobvious way.  Instead of limiting velocity directly, only the projection of the current velocity onto acceleration is limited. To explain this further, I need to first explain what vector projection is.</p><p> 在Quake III加速码中，运动速度以非常有趣和极性的方式受到限制。代替直接限制速度，而不是限制电流速度在加速度上的投影是有限的。要进一步解释这一点，我需要首先解释矢量投影。</p><p>  The projection of a vector  a onto a vector  b (also known as the component of  a onto  b) is &#34;The orthagonal projection of  a onto a straight line parallel to  b&#34; (To quote  Wikipedia). This concept is illustrated below.</p><p>  向量A投影到载体B上（也称为A的组分）是＆＃34; A在平行于B＆＃34的直线上的orthagonlople投影; （引用维基百科）。这个概念如下所示。</p><p>     V proj = |a| * cos( Θ ) = a • b̂  Above, • represents a  dot product and  b̂ is the unit vector of b (that is, a vector in the direction of b and a length of 1). The dot product notation works because a dot product is equal to  |a| * |b| * cos(Θ). This is preferable because it is faster to perform than a cosine calculation.</p><p>     v proj = | a | * COS（θ）= A•B上方，表示点产品，B是B的单位向量（即，B的方向的载体和1）。 DOT产品符号为代表产品等于| A | * | B | * cos（θ）。这是优选的，因为它比余弦计算更快。</p><p>  I&#39;ll repeat here what I said before:  Instead of limiting velocity directly, only the projection of the current velocity onto acceleration is limited. This allows the player to exceed the maximum velocity in certain situations. Recall that in order to airstrafe you must sync your movement keys with your mouse movement. Let&#39;s model this mathematically:</p><p>  我之前的说法我在这里重复了什么：代替直接限制速度，而是仅将当前速度的投影限制在加速度上。这允许玩家超过某些情况下的最大速度。回想一下，为了机架式机构，您必须使用鼠标移动同步移动键。在数学上设＆＃39; </p><p> Figure 2: Using projection to limit speed. &#34;Time 0&#34; is on the top left, Time 1 is on the top right, etc. Here is the key to this diagram:    V c = The current velocity before any calculations   V w = The direction that the player wants to move in (the so-called wish direction).   V p = V c projected onto V w. Keep in mind that we are only considering magnitude in this calculation, so the direction of the projection doesn&#39;t matter. 	 V a = The acceleration to be added to V p. The magnitude of this acceleration is server-defined.   V max = The server-defined maximum velocity. If V p + V a exceeds this, then V a is truncated.</p><p>图2：使用投影限制速度。 ＆＃34;时间0＆＃34;在左上角，时间1在右上角等。以下是该图的关键：V C =在任何计算之前的当前速度V W =玩家想要进入的方向（所谓的希望方向）。 v p = v c投射到V w。请记住，我们只考虑该计算中的幅度，因此投影的方向并不是。 v a =要添加到v p的加速度。此加速度的大小是定义的。 v max =服务器定义的最大速度。如果V P + V A超过此，则截断V a。</p><p> In the above example, the player is both moving and turning left. After 4 physics ticks, V p passes the server-defined speed limit V max and V a is truncated to account for this. Note, however, that V c still substantially exceeds V max!</p><p> 在上面的示例中，播放器既移动并左转。 4个物理刻度后，v P通过服务器定义的速度限制v max，v a被截断以占此帐户。但请注意，V C仍然大大超过V Max！</p><p>   private  Vector3  Accelerate ( Vector3  accelDir ,  Vector3  prevVelocity ,  float  accelerate ,  float  max_velocity ) {  float  projVel  =  Vector3 . Dot ( prevVelocity ,  accelDir );  // Vector projection of Current velocity onto accelDir.  float  accelVel  =  accelerate  *  Time . fixedDeltaTime ;  // Accelerated velocity in direction of movment  // If necessary, truncate the accelerated velocity so the vector projection does not exceed max_velocity  if ( projVel  +  accelVel  &gt;  max_velocity )  accelVel  =  max_velocity  -  projVel ;  return  prevVelocity  +  accelDir  *  accelVel ; }</p><p>   私有Vector3加速（Vector3 Accell，Vector3 Previpity，Float Accelerate，Float Max_velocity）{Float Projvel = Vector3。 DOT（Previpity，Accell）; //当前速度的矢量投影到Accell。 Float Accelvel =加速*时间。固定地德拉斯省; //加速速度在移动方向//如有必要，截断加速速度，使矢量投影不超过max_velocity（projvel + Accelvel＆gt; max_velocity）Accelvel = max_velocity  -  projvel;返回PreviLocity + Acceldir * Accelvel; }</p><p>  Friction also plays an important role in bunnyhopping as well as Quake-style movment in general. Bunnyhopping earned its name because the player literally has to hop in order to gain speed. This is because if players didn&#39;t do this friction would reduce their speed.</p><p>  摩擦还在兔子普通以及一般的地震风格中起着重要作用。 Bunnyhopping赢得了它的名字，因为玩家实际上必须跳跃以获得速度。这是因为如果玩家没有做这种摩擦会降低速度。</p><p> Why, then, is it possible to bunnyhop at all? Wouldn&#39;t you always hit the ground and thus lose speed? This actually is not true in the Quake or Source engines because  there is a 1-frame window where friction is not applied when the player hits the ground. This means that the player has a single frame to input the  jump command without losing speed - another reason why bunnyhopping is so hard! If you want to retain the skill-based nature of bunnyhopping then be sure to add this delay into your physics calculations. If you want bhopping to be accessible to new players, you can add  auto-bhopping where the player can simply hold space to automatically jump frame-perfectly.</p><p> 那么，为什么，它是可能的兔子？ WORN＆＃39; T你总是击中地面，从而失去速度？这实际上在地震或源引擎中不是真的，因为有一个1帧窗口，当玩家击中地面时不应用摩擦。这意味着玩家有一个帧来输入跳转命令而不会丢失速度 - 这是熊尼霍普上很难的另一个原因！如果您想保留Bunnyhopping的技能性质，请务必将此延迟添加到您的物理计算中。如果您希望Bhopping可以访问新玩家，您可以添加播放器可以简单地保持空间以自动跳过框架的自动bhopping。</p><p>  float  speed  =  prevVelocity . magnitude ; if  ( speed  !=  0 )  // To avoid divide by zero errors {  float  drop  =  speed  *  friction  *  Time . fixedDeltaTime ;  prevVelocity  *=  Mathf . Max ( speed  -  drop ,  0 )  /  speed ;  // Scale the velocity based on friction. }</p><p>  浮动速度= previpity。震级 ; if（速度！= 0）//避免归零误差{float drop = speed *摩擦*时间。固定地德拉斯省; previvelocity * = mathf。最大（速度 - 滴，0）/速度; //根据摩擦缩放速度。 }</p><p> Of course, friction is only applied when the player is grounded.  friction is a server-defined variable of the approximate range 1-5. The higher  friction is, the less slippery surfaces become. If you are familiar with console commands in the Source engine, you may recognize this variable as  sv_friction.</p><p> 当然，摩擦力仅在玩家接地时应用。摩擦是近似范围1-5的服务器定义变量。摩擦较高，表面较少。如果您熟悉源引擎中的控制台命令，则可以将此变量识别为SV_FRICTION。 </p><p>   // accelDir: normalized direction that the player has requested to move (taking into account the movement keys and look direction) // prevVelocity: The current velocity of the player, before any additional calculations // accelerate: The server-defined player acceleration value // max_velocity: The server-defined maximum player velocity (this is not strictly adhered to due to strafejumping) private  Vector3  Accelerate ( Vector3  accelDir ,  Vector3  prevVelocity ,  float  accelerate ,  float  max_velocity ) {  float  projVel  =  Vector3 . Dot ( prevVelocity ,  accelDir );  // Vector projection of Current velocity onto accelDir.  float  accelVel  =  accelerate  *  Time . fixedDeltaTime ;  // Accelerated velocity in direction of movment  // If necessary, truncate the accelerated velocity so the vector projection does not exceed max_velocity  if ( projVel  +  accelVel  &gt;  max_velocity )  accelVel  =  max_velocity  -  projVel ;  return  prevVelocity  +  accelDir  *  accelVel ; } private  Vector3  MoveGround ( Vector3  accelDir ,  Vector3  prevVelocity ) {  // Apply Friction  float  speed  =  prevVelocity . magnitude ;  if  ( speed  !=  0 )  // To avoid divide by zero errors  {  float  drop  =  speed  *  friction  *  Time . fixedDeltaTime ;  prevVelocity  *=  Mathf . Max ( speed  -  drop ,  0 )  /  speed ;  // Scale the velocity based on friction.  }  // ground_accelerate and max_velocity_ground are server-defined movement variables  return  Accelerate ( accelDir ,  prevVelocity ,  ground_accelerate ,  max_velocity_ground ); } private  Vector3  MoveAir ( Vector3  accelDir ,  Vector3  prevVelocity ) {  // air_accelerate and max_velocity_air are server-defined movement variables  return  Accelerate ( accelDir ,  prevVelocity ,  air_accelerate ,  max_velocity_air ); }</p><p>// Acceldir：归一化方向，播放器已要求移动（考虑到移动键和看方向）// previpity：玩家的当前速度，在任何额外的计算//加速：服务器定义播放器加速度// MAX_VELOCITY：服务器定义的最大播放器速度（这不是由于StradeJumping的严格遵守）私有Vector3加速（Vector3 Accell，Vector3 PreviCity，Float Accelerate，Float Max_velocity）{Float Projvel = Vector3。 DOT（Previpity，Accell）; //当前速度的矢量投影到Accell。 Float Accelvel =加速*时间。固定地德拉斯省; //加速速度在移动方向//如有必要，截断加速速度，使矢量投影不超过max_velocity（projvel + Accelvel＆gt; max_velocity）Accelvel = max_velocity  -  projvel;返回PreviLocity + Acceldir * Accelvel;私人Vector3 Leveground（Vector3 Accell，Vector3 PreviLocity）{//应用摩擦浮动速度= PrevIpocity。震级 ; if（速度！= 0）//避免归零误差{float drop = speed *摩擦*时间。固定地德拉斯省; previvelocity * = mathf。最大（速度 - 滴，0）/速度; //根据摩擦缩放速度。 } // ground_accelerate和max_velocity_ground是服务器定义的移动变量返回加速（acceldir，previbity，ground_accelerate，max_velocity_ground）;私人Vector3 MoveAir（Vector3 Accell，Vector3 PreviLocity）{// air_Accelerty和Max_Velocity_Air是服务器定义的移动变量返回加速（Acceldir，PreviCity，Air_Accelerate，MAX_Velocity_Air）; }</p><p> Those of you who are familiar with the Source engine may once again recognize the  sv_accelerate,  sv_airaccelerate, and  sv_friction convars in this code. Take some time to tweak these server-defined variables to your liking as they determine the feel of your game&#39;s movement.</p><p> 熟悉源引擎的人可能再次识别此代码中的SV_ACCELETE，SV_AIRACCELATE和SV_FRICTION SCRARAR。花一些时间来调整这些服务器定义的变量，因为它们决定了游戏的感觉＆＃39;运动。</p><p> That&#39;s it! This should be all you need to implement bunnyhopping into your game. If you have any questions or comments please feel free to post in the comments section below. Thank you for reading!</p><p> 它＆＃39;它！这应该是所有你需要在你的游戏中实施兔子。如果您有任何疑问或意见，请随时在以下意见部分发布。谢谢你的阅读！</p><p>  Quake III movement code - This is the original Quake engine movment code that &#34;started it all&#34;. Check this out for nostalgia. There is a lot of engine-specific/messy code in there so watch out.</p><p>  Quake III运动代码 - 这是＆＃34的原始地震引擎的移动代码;启动它所有＆＃34;在怀旧中检查一下。那里有很多发动机特定/杂乱的代码所以注意。</p><p>  Source Engine movement code - This code was based off of the Quake engine code. However, it is a bit easier to decipher than the Quake engine. It also has some old code from an unreleased TF2 &#34;Commander Mode&#34; which is pretty cool.</p><p>  源引擎移动代码 - 此代码基于Quake引擎代码。然而，解读的比Quake引擎更容易。它还来自未发布的TF2＆＃34的旧代码;指挥官模式＆＃34;这很酷。</p><p>  &#34;How do I implement strafe-jumping?&#34; - This is a gamedev stackexchange question that is pretty enlightening on the maths behind strafejumping.</p><p>  ＆＃34;我如何实施streaf-跳跃？＆＃34; - 这是一个GameVevStackexchange问​​题，它在StradeJumping背后的数学上非常启发。</p><p>  F3Quake - Strafing Theory - This is a player-created mathematical analysis on strafe jumping which seeks to find the mathematically optimal air strafing strategy. It&#39;s an interesting read for any math nerd. It also details the worth of implementing bunnyhopping for the sake of a hardcore community.</p><p>  F3Quake  -  Strafing理论 - 这是一个关于STRAFE跳跃的玩家创作的数学分析，寻求找到数学上最佳的空气磨削策略。它＆＃39;对于任何数学书呆子的有趣阅读。它还详细介绍了为硬核社区缘故实施兔子。 </p><p>       comments powered by  Disqus</p><p>评论由Disqus提供动力 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://adrianb.io/2015/02/14/bunnyhop.html">https://adrianb.io/2015/02/14/bunnyhop.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序员/">#程序员</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/速度/">#速度</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>