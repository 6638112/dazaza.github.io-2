<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>您不应该使用的Git命令Git Commands You Should Never Use</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Git Commands You Should Never Use<br/>您不应该使用的Git命令</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-26 20:11:19</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/7e0d0104c518dbfa3406205113e0eaf3.jpeg"><img src="http://img2.diglog.com/img/2020/11/7e0d0104c518dbfa3406205113e0eaf3.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Git is a powerful tool. And, in my opinion, the only version control system software developers should be using in 2020. Perhaps there will be a new king in town one day. But in 2020, Git is the only solution worth investing your time with. Why? Because everyone uses it! Literally, everyone.</p><p>Git是一个强大的工具。而且，在我看来，到2020年，唯一的版本控制系统软件开发人员应该使用该软件。也许有一天，该镇将有一位新国王。但是在2020年，Git是唯一值得您投入时间的解决方案。为什么？因为每个人都使用它！从字面上看，每个人。</p><p> However, not everyone is an expert with git! These are three git commands that I believe you should NEVER use unless you truly understand what you’re doing!</p><p> 但是，并不是每个人都是git的专家！我相信这是三个git命令，除非您真正了解自己在做什么，否则切勿使用！</p><p>  Simply put, the git s  ubmodule command allows you to add a git repository into your git repository! However, managing a project where multiple submodules are used can be cumbersome.</p><p>  简而言之，git s ubmodule命令允许您将git仓库添加到git仓库中！但是，管理使用多个子模块的项目可能很麻烦。</p><p>  The above command adds the repository specified as a directory within your current git repository. This directory is itself a complete git repository. If you change directory into the new submodule you’ll notice that ALL of your git commands behave as if you just moved to a completely new repository. Because you have!</p><p>  上面的命令将指定为目录的存储库添加到当前git存储库中。这个目录本身就是一个完整的git仓库。如果您将目录更改为新的子模块，则会注意到所有git命令的行为都如同您刚刚移至全新的存储库一样。因为你有！</p><p> We’ll hereby reference the top-level repository as the “parent” repository and the submodule as the “child”. Within the parent repository, the directory which is the child submodule is treated more or less exactly how any other file within git would be treated. When the child repository is changed, you’ll see in the  git status of the parent that the submodule has new commits or has modified content. Under the hood, from the perspective of the parent, a git submodule can be thought of as nothing more than a single file that contains a remote location and a commit id! The only way to update this file, and thus the parent’s reference to the submodule, is to track a different commit ID. Only when the most recent commit (aka the HEAD) of the child repository changes can the parent repository git add/git commit the updated submodule.</p><p> 在此，我们将顶级存储库称为“父”存储库，将子模块称为“子级”。在父存储库中，作为子子模块的目录或多或少准确地对待了git中的任何其他文件。更改子存储库后，您将在父存储库的git状态下看到该子模块具有新的提交或已修改的内容。从父级的角度来看，可以将git子模块视为一个单独的文件，该文件包含远程位置和提交ID！更新此文件以及父级对子模块的引用的唯一方法是跟踪不同的提交ID。仅当子存储库的最新提交（即HEAD）更改时，父存储库git add / git才能提交更新的子模块。</p><p> This intuitively means that if you are actively working within the child submodule, your workflow must also include managing the parent’s reference to the child. For instance, when you make a new commit in the child, you need to ALSO commit the parent’s reference to the child in order to keep the full project up to date. This can clearly become painful. Especially if you have many submodules or multiple levels of nested submodules. Each commit in any child repository equally requires updates to all references to that repository. This is why, in my opinion, submodules should only be used if the development team of the parent repository is   different from the development team of the child. Submodules work well to keep track of references to external source code dependencies. However, I believe submodules do not work well to segment a single development team’s project into multiple sub-components. The resulting increase in complexity is not worth the additional effort required to maintain the parent/child relationship.</p><p> 直观地表示，如果您正在子级子模块中积极工作，则工作流还必须包括管理父级对子级的引用。例如，当您在子项中进行新提交时，还需要提交父项对子项的引用，以使整个项目保持最新状态。这显然会很痛苦。特别是当您有许多子模块或多层嵌套子模块时。同样，任何子存储库中的每次提交都需要更新对该存储库的所有引用。我认为这就是为什么仅在父存储库的开发团队与子存储库的开发团队不同的情况下才使用子模块的原因。子模块可以很好地跟踪对外部源代码依赖项的引用。但是，我认为子模块不能很好地将单个开发团队的项目划分为多个子组件。结果造成的复杂性增加不值得维持父母/子女关系所需的额外工作。</p><p> An additional note of interest: when using git submodules you must recognize that the parent repository will store no backup of the contents of the submodule. Only a reference. If you do not own the location which the submodule references, there is no guarantee that what you’re referencing will continue to exist at that location forever. If you do not own the remote location, I highly suggest creating your own remote location which is a clone of the original location as opposed to depending on a third party to maintain their repository at that exact location forever.</p><p> 另一个有趣的注意事项：使用git子模块时，您必须认识到父存储库将不存储该子模块内容的备份。仅供参考。如果您不拥有子模块引用的位置，则无法保证您引用的内容将永远存在于该位置。如果您不拥有该远程位置，我强烈建议您创建自己的远程位置，该位置是原始位置的副本，而不是依赖第三方将其存储库永久保持在该确切位置。</p><p>  git filter-branch is a fascinatingly dangerous command which has an extremely useful niche use case.</p><p>git filter-branch是一个非常有趣的命令，它具有非常有用的利基用例。</p><p>  The above command will execute  &lt;terminal command&gt; for every commit in the tree starting at and working backward from HEAD. The command will create a new commit with the new content for each commit. For example, say that you accidentally committed your private user credentials as a file in your git repository. You suddenly noticed this was the case several commits later. You could run the following command to re-write all your previous commits by removing that file from each commit.</p><p>  上面的命令将从HEAD开始并从HEAD开始对树中的每个提交执行。该命令将使用每个提交的新内容创建一个新提交。例如，假设您不小心将私人用户凭据作为git存储库中的文件提交。您突然注意到这种情况在以后多次提交。您可以运行以下命令，通过从每个提交中删除该文件来重写所有先前的提交。</p><p>   Why would you want to do this instead of just creating a new commit which removes that file? Because someone malicious could always go back to the previous commit and see your private credentials if you don’t remove the file from all   past commits as well.</p><p>   您为什么要这样做，而不仅仅是创建一个删除该文件的新提交？因为如果您也没有从所有过去的提交中删除文件，那么恶意软件总会返回到先前的提交并查看您的私人凭据。</p><p> Great! We achieved what we wanted to do. This command seems wonderful! What’s the problem?!</p><p> 大！我们实现了我们想要做的。这个命令似乎很棒！有什么问题？！</p><p> The problem is that you’ve now essentially created a completely new repository with a completely new history. If you were working in a team with a shared remote repository, you just destroyed your ability to push or pull to/from the remote repository. To alleviate this, you could force push to the remote repository but then you’re potentially permanently destroying valuable changes.</p><p> 问题是您现在已经创建了一个具有全新历史记录的全新存储库。如果您在一个使用共享远程存储库的团队中工作，那么您只是破坏了向/从远程存储库推/拉的能力。为了缓解这种情况，您可以强行推送到远程存储库，但是有可能永久性地破坏有价值的更改。</p><p> Because there’s no longer a common history, comparing your local repository to the remote repository would need to be done manually or have been done prior to the  git filter-branch. Additionally , after the force push, you’ll have destroyed your team’s ability to push/pull to/from the remote repository. This causes your team to need to delete their local branch or repository in order to clone/pull the new history.</p><p> 由于不再有共同的历史记录，因此需要将本地存储库与远程存储库进行比较，或者需要在git filter-branch之前进行比较。此外，在强行推入之后，您将破坏团队推入/拉出远程存储库的能力。这导致您的团队需要删除其本地分支或存储库才能克隆/提取新历史记录。</p><p> Also, there will be no stored history of the changes which the  git filter-branch command itself created. You better be   absolutely sure that the changes you’re introducing with  git filter-branch are the changes you want because there’s no going back!</p><p> 而且，将不会存储git filter-branch命令本身创建的更改的历史记录。最好绝对确保git filter-branch引入的更改是您想要的更改，因为没有回头路了！</p><p>  git rebase is perhaps the most controversial git command in existence. There are many development teams that mandate  git rebase over  git merge. Personally, I am a fan of the  git merge approach. For one simple reason.  git rebase rewrites history and rewriting history is inherently dangerous.</p><p>git rebase也许是现存最有争议的git命令。有许多开发团队要求git在git merge上重新设置基础。我个人是git merge方法的粉丝。原因很简单。 git rebase重写历史记录，而重写历史记录本质上是危险的。</p><p> Let me explain the difference between  git merge and  git rebase before I further explain why I prefer  git merge.</p><p> 让我先解释一下git merge和git rebase之间的区别，然后再进一步解释为什么我更喜欢git merge。</p><p> Both  git merge and  git rebase solve the same problem. They solve the problem of combining two branches with parallel changes into a single branch with one history. Let’s examine the case where we have a master branch and a feature branch as depicted in the following image.</p><p> git merge和git rebase解决了相同的问题。他们解决了将具有并行更改的两个分支合并为具有一个历史记录的单个分支的问题。让我们检查一下我们拥有一个主分支和一个功能分支的情况，如下图所示。</p><p>  The feature branch was created from the master branch at the “m2” commit. The feature branch then made changes to the repository in commits “f1” and “f2”. While the “f1” and “f2” changes were being developed, the master branch was updated with the “m3” commit. How do we update the master branch with the changes created in the feature branch?</p><p>  功能分支是在“ m2”提交时从主分支创建的。然后，功能分支在提交“ f1”和“ f2”中对存储库进行更改。在开发“ f1”和“ f2”更改的同时，master分支已更新为“ m3”提交。如何使用功能分支中创建的更改来更新master分支？</p><p> git merge does this by preserving all of the commits of the feature branch. On the master branch, a new commit will be created which has a historical relationship to both the HEAD of the master branch   and the HEAD of the feature branch. This merge commit exists to resolve the final states of the two branches. If the changes introduced between the two branches are not able to be resolved automatically, a merge conflict occurs and the user must resolve the conflict by deciding what changes should be kept prior to the creation of the merge commit. The direction of merging the master branch into the feature branch or merging the feature branch into the master branch generally doesn’t affect the resulting resolution. All that changes is on which branch the merge commit will be initially created.</p><p> git merge通过保留feature分支的所有提交来做到这一点。在master分支上，将创建一个新提交，该提交与master分支的HEAD和feature分支的HEAD都具有历史关系。存在此合并提交以解决两个分支的最终状态。如果不能自动解决两个分支之间引入的更改，则会发生合并冲突，并且用户必须通过确定在创建合并提交之前应保留哪些更改来解决冲突。将主分支合并到功能分支或将功能分支合并到主分支的方向通常不会影响最终的分辨率。所有更改都将在最初创建合并提交的哪个分支上进行。</p><p> git rebase, however, achieves resolving the two branches into one history by moving commits within history. For example, instead of the changes of the “f1” commit being applied to “m2”.  git rebase will store the changes made in “f1” and “f2”, move the feature branch to instead be based upon “m3”, then apply “f1” and “f2” upon “m3”. If there is a conflict, you must resolve that conflict one by one for each commit which will be applied to the new base commit (in our example, merge conflicts may occur when applying both “f1” and “f2” upon “m3”).</p><p> 但是，git rebase通过在历史记录内移动提交来将两个分支解析为一个历史记录。例如，不是将“ f1”提交的更改应用于“ m2”。 git rebase将存储在“ f1”和“ f2”中所做的更改，将功能分支移至基于“ m3”的位置，然后在“ m3”上应用“ f1”和“ f2”。如果存在冲突，则必须针对将应用于新的基本提交的每个提交一一解决该冲突（在我们的示例中，在“ m3”上同时应用“ f1”和“ f2”时可能会发生合并冲突） 。</p><p> git rebase is great because the resulting git history is a straight line. There’s no single commit that has more than one parent. However, after the rebase, commits “f1” and “f2” are no longer true preservations of the original “f1” and “f2” commits. Their commit ID will be different. Their content may be different. And as a result, you fall into the same issue which  git filter-branch created. If you’re working with a shared remote repository and conducted the rebase locally. You’ll need to force push the rebased changes to the remote repository. A force push risks permanently removing valuable changes that may have been on the remote repository. Additionally, a force push destroys your collaborators’ ability to push/pull to/from that branch on the remote repository.</p><p> git rebase很棒，因为生成的git历史是一条直线。没有一个提交具有多个父级。但是，在重新设置基准之后，提交“ f1”和“ f2”不再是原始“ f1”和“ f2”提交的真正保留。他们的提交ID将不同。它们的内容可能有所不同。结果，您陷入了git filter-branch创建的同一问题。如果您正在使用共享的远程存储库并在本地进行了变基。您需要强制将经过重新调整的更改推送到远程存储库。强制推送可能会永久删除远程存储库中可能有价值的更改。此外，强行推销会破坏您的协作者向远程存储库中的该分支推入/拉出的能力。</p><p> Generally, teams relegate the use of  git rebate to only occur during pull requests to the master branch. Thus, avoiding the potential for collaboration issues. However, I still prefer to never rewrite history.</p><p>通常，团队将git rebate的使用授权仅发生在对master分支的拉动请求期间。因此，避免了潜在的协作问题。但是，我仍然希望永远不要重写历史记录。</p><p>  When working with a team of developers, it is important for git to not get in the way of seamless collaboration. Generally speaking, behavior within git that re-writes history or alters the convention of how most people interact with git should be avoided. Git submodules alter the general git convention by causing changes to be tracked on multiple levels as opposed to just once for the entire project.  git filter-branch and  git rebase both re-write your git history. And we discussed that there are complications that arise when the git history is changed. In my opinion,  git rebase has little advantage over  git merge and should almost always be avoided. However,  git filter-branch has its uses in dire situations. It’s an “Oh $#!&amp;” button more than it is a useful tool. Good to know it exists, but hopefully you’ll never need to use it.</p><p>  与开发人员团队合作时，重要的是git不要妨碍无缝协作。一般而言，应避免在git中重写历史记录或更改大多数人与git交互方式的约定的行为。 Git子模块通过使更改在多个级别上进行跟踪而改变了整个git约定，而不是整个项目一次。 git filter-branch和git rebase都重新编写了git历史记录。我们讨论了git历史记录更改时会出现一些复杂情况。在我看来，git rebase与git merge相比没有什么优势，应该几乎避免使用。但是，git filter-branch在可怕的情况下有其用途。它比“ Oh $＃！＆”按钮更实用。很高兴知道它的存在，但是希望您永远不需要使用它。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://mquettan.medium.com/3-git-commands-you-should-never-use-99f6ec910989">https://mquettan.medium.com/3-git-commands-you-should-never-use-99f6ec910989</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>