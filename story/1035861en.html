<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Python的Bisect模块Using Python's Bisect Module</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Using Python's Bisect Module<br/>使用Python的Bisect模块</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-22 13:18:24</div><div class="page_narrow text-break page_content"><p>Blog JUNTO Contact        The goal of the  bisect module is to allow you to efficiently search andupdate sorted lists. To this end, it provides:</p><p>博客JUNTO联系人bisect模块的目标是使您能够有效地搜索和更新排序的列表。为此，它提供：</p><p>   In  statistical data binning, you have a data that you want to group into &#34;bins&#34;. E.g.</p><p>   在统计数据装仓中，您有一个要分组为“箱”的数据。例如。</p><p> You have data on students&#39; grades and want to group scores between 80 and 90into &#34;B&#34;, scores between 90 and 100 into &#34;A&#34;, etc.</p><p> 您具有学生成绩的数据，并且希望将80到90之间的分数分组为“ B”，将90到100之间的分数分组为“ A”，依此类推。</p><p> To me, a straightforward approach is to write a function that computes the bin.E.g., binning fruits:</p><p> 对我来说，一种简单的方法是编写一个计算bin的函数，例如对水果进行装箱：</p><p> def bin_fruit(fruit): if fruit in [&#34;lemon&#34;, &#34;orange&#34;]: return &#34;citrus&#34; elif fruit in [&#34;apple&#34;, &#34;pear&#34;]: return &#34;malinae&#34;import randomdata = random.choices( [&#34;lemon&#34;, &#34;orange&#34;, &#34;apple&#34;, &#34;pear&#34;], k=10)data</p><p> def bin_fruit（fruit）：如果[“ lemon”，“ orange”]中的水果：返回“ citrus” elif [[“ apple”，“ pear”]中的水果：返回“ malinae” import randomdata = random.choices（[ “，” orange“，” apple“，” pear“]，k = 10）data</p><p>     def bin_score(score): if 90 &lt;= score &lt;= 100: return &#34;A&#34; elif 80 &lt;= score &lt; 90: return &#34;B&#34; elif 70 &lt;= score &lt; 80: return &#34;C&#34; elif 60 &lt;= score &lt; 70: return &#34;D&#34; elif score &lt; 60: return &#34;F&#34;import randomdata = [random.randint(50, 100) for _ in range(10)]data</p><p>def bin_score（分数）：如果90 <=分数<= 100：返回“ A” elif 80 <=分数<90：返回“ B” elif 70 <=分数<80：返回“ C” elif 60 <=分数<70 ：返回“ D” Elif得分<60：返回“ F” import randomdata = [ran_randrand（50，100）for _ in range（10）] data</p><p>    For a dataset of  n records and  m bins, the  timecomplexity of this approach tends to be</p><p>    对于n个记录和m个仓的数据集，此方法的时间复杂度往往是</p><p>  Because binning one record takes O( m) time -- O( m)if-statements are checked -- and  n records need to be binned.</p><p>  由于对一个记录进行分箱需要O（m）的时间-选中O（m）if语句-并且需要对n个记录进行分箱。</p><p> If the number of bins  m is constant, then the overall timecomplexity is simply O( n).</p><p> 如果箱数m为常数，则整个时间复杂度仅为O（n）。</p><p> But what if the number of bins  m is large enough that thestraightforward approach is too slow?</p><p> 但是，如果箱数m足够大而直接方法太慢怎么办？</p><p> bins = { &#34;lemon&#34;: &#34;citrus&#34;, &#34;orange&#34;: &#34;citrus&#34;, &#34;apple&#34;: &#34;malinae&#34;, &#34;pear&#34;: &#34;malinae&#34;,}def bin_fruit(fruit): return bins[fruit]import randomdata = random.choices( [&#34;lemon&#34;, &#34;orange&#34;, &#34;apple&#34;, &#34;pear&#34;], k=10)data</p><p>bins = {“柠檬”：“柑橘”，“橙色”：“柑橘”，“苹果”：“麦莉娜”，“梨”：“麦莉娜”，} def bin_fruit（fruit）：return bins [fruit] import randomdata = random.choices（[“柠檬”，“橙色”，“苹果”，“梨”]，k = 10）数据</p><p>    Binning one record this way takes O(1) time -- regardless of the number ofbins  m -- because  dictionaries are implemented using hash tables. And creating the  dictionary take O( m) time --one entry for each bin. Thus, the overall time complexity, for  nrecords and  m bins, is</p><p>    这种方式对一个记录进行绑定需要O（1）时间-不管bin的数量是多少-因为字典是使用哈希表实现的。创建字典需要O（m）时间-每个bin都有一个条目。因此，对于n个记录和m个仓，总的时间复杂度为</p><p> score_bins = [60, 70, 80, 90]score_letters = [&#34;F&#34;, &#34;D&#34;, &#34;C&#34;, &#34;B&#34;, &#34;A&#34;]import bisectdef bin_score(score): i = bisect.bisect(score_bins, score) return score_letters[i]import randomdata = [random.randint(50, 100) for _ in range(10)]data</p><p> score_bins = [60、70、80、90] score_letters = [“ F”，“ D”，“ C”，“ B”，“ A”] import bisectdef bin_score（score）：i = bisect.bisect（score_bins，得分）return score_letters [i] import randomdata = [range（10）中_的[random.randint（50，100）]</p><p>    Binning one record this way takes O(log  m) time, because bisect.bisect uses  binary search to navigate  score_bins. Andcreating  score_bins takes O( m) time. Thus, the overall timecomplexity, for  n records and  m bins, is</p><p>    用这种方式对一条记录进行绑定需要O（log m）时间，因为bisect.bisect使用二进制搜索来导航score_bins。创建score_bins需要O（m）时间。因此，对于n个记录和m个仓，总的时间复杂度为</p><p>  NOTE: If you are able to use 3rd-party libraries, such as  NumPy or Pandas, then look at these functions:  numpy.digitize, numpy.searchsorted,  pandas.Series.searchsorted,  pandas.qcut, pandas.cut.</p><p>  注意：如果您能够使用第三方库（例如NumPy或Pandas），请查看以下函数：numpy.digitize，numpy.searchsorted，pandas.Series.searchsorted，pandas.qcut，pandas.cut。</p><p>    For example, you can imagine having a temperature sensor that regularly reportsthe temperature. You want to regularly report the median temperature, as wellas be able to incorporate new temperature data as it arrives.</p><p>例如，您可以想象有一个定期报告温度的温度传感器。您希望定期报告中间温度，并能够在到达时合并新的温度数据。</p><p>  def add_new_measurement(data, temperature): data.append(temperature)def median(data): return statistics.median(data)import randomimport statisticsdata = [random.randint(93, 100) for _ in range(10)]data</p><p>  def add_new_measurement（数据，温度）：data.append（温度）def中值（数据）：返回统计信息。median（数据）import randomimport statisticsdata = [ran_randrand（93，100）for _ in range（10）] data</p><p>          So if the workload requires frequently adding new data and infrequentlycomputing the median, this approach works well.</p><p>          因此，如果工作负载需要频繁添加新数据并且不经常计算中位数，则此方法效果很好。</p><p> But what if the workload is inverted? For example, if temperature measurementsare received every couple of minutes, but the median must be computed everycouple of seconds.</p><p> 但是如果工作量倒退了怎么办？例如，如果每两分钟收到一次温度测量值，但必须每两秒钟计算一次中值。</p><p> In that scenario, I think we would be better suited by speeding up computingthe median, even at the expense of slowing down adding new data.</p><p> 在那种情况下，我认为我们最好通过加快计算中位数来解决问题，即使是以减慢添加新数据的代价为代价。</p><p> Computing order statistics can be done in O(1) time if the data is alreadysorted. So a straightforward way to handle this workload would be to sort thedata after appending and use the fact that the data is sorted to efficientlycompute the median:</p><p>如果数据已经排序，则可以在O（1）时间内完成计算订单统计信息。因此，处理此工作负载的一种直接方法是在附加数据后对数据进行排序，并利用对数据进行排序的事实来有效地计算中位数：</p><p> def add_new_measurement(data, temperature): data.append(temperature) data.sort()def median(data): n = len(data) if n % 2 == 0: return (data[(n // 2) - 1] + data[n // 2]) / 2 else: return data[n // 2]import randomdata = sorted(random.randint(93, 100) for _ in range(10))data</p><p> def add_new_measurement（数据，温度）：data.append（温度）data.sort（）def中位数（数据）：n = len（数据）如果n％2 == 0：返回（data [（n // 2）- 1] + data [n // 2]）/ 2 else：返回数据[n // 2] import randomdata = sorted（random.randint（93，100）for _ in range（10））data</p><p>          But I think that the  time complexity for adding new data can further beimproved by using  bisect.insort, which runs in</p><p>          但是我认为使用bisect.insort可以进一步提高添加新数据的时间复杂度。</p><p>         In this week&#39;s post you learned how to use the  bisect module forstatistical data binning and adding new data to sorted lists.</p><p>         在本周的帖子中，您学习了如何使用bisect模块进行统计数据装仓并将新数据添加到已排序列表中。</p><p>  Algorithms that process input piece-by-piece -- like the temperature sensorscenario -- are called  online algorithms.</p><p>  像温度传感器一样，逐段处理输入的算法称为在线算法。</p><p> bisect.insort can be used to implement an  Insertion sort. Insertionsort is an  online algorithm and -- along with Python&#39;s built-in timsort -- is an  adaptive sorting algorithm because it takesadvantage of data that is partially sorted.</p><p>bisect.insort可用于实现插入排序。 Insertionsort是一种在线算法，并且与Python的内置timsort一起是一种自适应排序算法，因为它利用了部分排序的数据的优势。</p><p>   If you enjoyed this week&#39;s post, share it with your friends and stay tuned fornext week&#39;s post. See you then!</p><p>   如果您喜欢本周的帖子，请与您的朋友分享，并继续关注下一周的帖子。回头见！</p><p>  (If you spot any errors or typos on this post, contact me via my contact page</p><p>  （如果您发现此帖子有任何错误或错别字，请通过我的联系页面与我联系</p><p>.)</p><p>）</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://johnlekberg.com/blog/2020-11-21-stdlib-bisect.html">https://johnlekberg.com/blog/2020-11-21-stdlib-bisect.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bisect/">#bisect</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>