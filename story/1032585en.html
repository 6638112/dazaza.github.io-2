<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>简单图像矢量化</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">简单图像矢量化</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-01 14:07:53</div><div class="page_narrow text-break page_content"><p>Vectorization is when you take some minecraft-style raster image and make a crisp vector picture out of it.</p><p>矢量化是指当你拍摄一些“我的世界”风格的光栅图像，并从中制作一张清晰的矢量图片的时候。</p><p>      It&#39;s especially useful when you want to turn a satellite photo into a map. Or if you want to scan some blueprint and turn it into a CAD model. Or if you want to reissue an old game and you don&#39;t want to redraw all the artwork from scratch.</p><p>当你想把卫星照片变成地图时，它特别有用。或者，如果您想扫描一些蓝图并将其转换为CAD模型。或者，如果您想重新发布一个旧游戏，但您不想从头开始重新绘制所有的艺术作品。</p><p>  The algorithm I&#39;m going to show you has nothing to do with all these things. It&#39;s a basic vectorization technique which, in its original form, has little to none applications in the industry.</p><p>我要告诉你的算法与所有这些事情没有任何关系。它是一种基本的矢量化技术，在最初的形式下，在行业中几乎没有应用。</p><p>  On the plus side, it illustrates the approach rather well. It shows how things like bilinear interpolation, gradient descent, and parametric splines work together to solve a real-world problem. At the very least, it makes learning about all these things a little more compelling.</p><p>从好的方面来说，它很好地说明了这种方法。它展示了双线性插值、梯度下降和参数样条线如何协同工作来解决真实世界的问题。至少，它让学习所有这些东西变得更有说服力了。</p><p>    A raster image is essentially a rectangular table of things. If it&#39;s a full-color RGB, then it&#39;s a table of color pixels. Color pixels are the triplets of 8-bit integer values where each value represents an amount of red, green, and blue color.</p><p>光栅图像本质上是一张由物体组成的矩形桌子。如果它是全彩色RGB，那么它就是彩色像素表。颜色像素是8位整数值的三元组，其中每个值表示红色、绿色和蓝色的量。</p><p>  Medical images, such as obtained from computed tomography, are usually the tables of 12-bit or 16-bit integers. It&#39;s not a color really since the values come from invisible X-ray radiation, but they are called gray values nevertheless.</p><p>诸如从计算机断层扫描获得的医学图像通常是12位或16位整数的表格。它不是真正的颜色，因为这些值来自不可见的X射线辐射，但它们被称为灰度值。</p><p>  Satellite images may have a lot of channels. Apart from the colors of the visible specter they may contain ultra-violet and infra-red luminosity. Channels may be represented by integers or floating point values.</p><p>卫星图像可能有很多频道。除了可见幽灵的颜色外，它们还可能含有紫外线和红外线的光度。通道可以用整数或浮点值表示。</p><p>      Technically, we can already turn it into vectors rather easily. Let&#39;s just agree on some threshold, and mark the contour of all the pixels that have the values exceeding this threshold.</p><p>从技术上讲，我们已经可以相当容易地将其转化为矢量。让我们就某个阈值达成一致，并标记所有值超过该阈值的像素的轮廓。</p><p>    Well, it&#39;s simple, but it&#39;s not what we wanted. We want curves, not corners. And for that, we have to make our image less cornery.</p><p>嗯，这很简单，但这不是我们想要的。我们要的是曲线，而不是拐角。为此，我们必须让我们的形象不那么拐弯抹角。</p><p>    Let&#39;s say our image is not a table of values. Let&#39;s say we only know the values in the centers of the pixels, and we have to guess the values between them somehow.</p><p>让我们假设我们的形象不是一张价值表。让我们假设我们只知道像素中心的值，我们必须以某种方式猜测它们之间的值。</p><p>  This is called interpolation. The simplest case would be the nearest neighbor interpolation, where for every point on an image, the value is the value from the nearest pixel&#39;s center. But this simply turns it back into a table.</p><p>这称为插值。最简单的情况是最近邻插值法，对于图像上的每个点，该值都是最近像素中心的值。但这只会把它变回一张桌子。</p><p>  A little more advanced is the  bilinear interpolation. The value is the linear sum of the four neighboring values. It looks like this.</p><p>更先进一点的是双线性插值。该值是四个邻接值的线性和。看起来是这样的。</p><p>  // pixel value with out of bounds checksfunction pixel_in(pixels, i, j) { if(i &gt;= pixels.length) return pixel_in(pixels, pixels.length-1, j); if(i &lt; 0) return pixel_in(pixels, 0, j); if(j &gt;= pixels[0].length) return pixel_in(pixels, i, pixels[0].length-1); if(j &lt; 0) return pixel_in(pixels, i, 0); return pixels[i][j];}// linear interpolationfunction value_in(pixels, x, y) { var j = Math.floor(x - 0.5); var tj = x - 0.5 - j; var i = Math.floor(y - 0.5); var ti = y - 0.5 - i; return pixel_in(pixels, i, j) * (1 - ti) * (1 - tj) + pixel_in(pixels, i, j+1) * (1 - ti) * (tj) + pixel_in(pixels, i+1, j+1) * (ti) * (tj) + pixel_in(pixels, i+1, j) * (ti) * (1 - tj);}</p><p>//带越界检查的像素值函数Pixel_in(象素，i，j){if(i&&gt;；=Pixels.length)返回Pixel_in(象素，Pixels.length-1，j)；if(i&lt；0)返回Pixel_in(象素，0，j)；IF(j&&gt;；=象素[0].length)返回Pixel_in(象素，i，象素[0].length-1)；IF(j&lt；0)返回Pixel_in(象素，i，0)；返回象素[i][j]；}//线性插值函数value_in(像素，x，y){var j=Math.Floor(x-0.5)；var tj=x-0.5-j；var i=Math.Floor(y-0.5)；var ti=y-0.5-i；返回Pixel_in(像素，i，j)*(1-ti)*(1-tj)+Pixel_in(像素，i，j+1)*(1-ti)*(Tj)+Pixel_in(像素，i+1，j+1)*(Ti)*(Tj)+Pixel_in(像素，i+1，j)*(Ti)*(Ti)*(1-Tj)；}。</p><p>  If we darken the pixels where the interpolated value meets the threshold, we&#39;ll get some kind of a contour.</p><p>如果我们把插值值达到阈值的像素变暗，我们就会得到某种轮廓。</p><p>      There are other methods. Plenty of them. But linear interpolation solves the cornery border problem just fine. Although, the border we see is just the borderline of some threshold. It&#39;s not a vector representation yet.</p><p>还有其他方法。很多。但是线性插值很好地解决了拐角边界问题。尽管如此，我们看到的边界仅仅是某个门槛的边界。它还不是矢量表示法。</p><p>    We can borrow an idea from the  simplest possible smooth contouring algorithm. We&#39;ll build an initial border from the source pixels, and then we&#39;ll use our linearly interpolated image to find the best place to put each contour point so the image value will meet the threshold value.</p><p>我们可以借鉴最简单的平滑等高线算法的思想。我们将从源像素建立一个初始边界，然后我们将使用线性插值图像来找到放置每个轮廓点的最佳位置，这样图像值将达到阈值。</p><p>  When you have a  distance field, it&#39;s easy. A distance field is when for any point in space you can tell how far it lies from the surface you want. It&#39;s basically a function from point in space to distance.</p><p>当你有一个距离场时，这就很容易了。距离场是指对于空间中的任意点，您可以判断它离所需曲面的距离有多远。它基本上是一个从空间点到距离的函数。</p><p>  You take its gradient, take the difference between the value you have and the threshold value. Since it&#39;s the distance field, the value difference is exactly the distance you should move your point for. And the gradient is the exact opposite direction. You just inverse, multiply, add — and you&#39;re there.</p><p>你取它的梯度，取你的值和阈值之间的差值。因为它是距离字段，所以值差异正好是您应该移动点的距离。而梯度是完全相反的方向。你只需求逆、乘、加 - ，你就在那里了。</p><p>  Unfortunately, we don&#39;t have a distance field. We have a continuous image which only resembles one.</p><p>不幸的是，我们没有距离场。我们有一个连续的图像，它只与一个相似。</p><p>  But the principle still works. If you traverse against the gradient, you will get closer to the threshold value. And the more the difference, the further you have to go. It&#39;s just you wouldn&#39;t always get there in one try.</p><p>但这一原则仍然有效。如果您逆着渐变进行遍历，则会更接近阈值。差异越大，你就必须走得越远。只是你不会总是一次尝试就能做到。</p><p>    // gradientfunction gradient(pixels, x, y) { const eps = 1e-5; return [(value_in(pixels, x + eps, y) - value_in(pixels, x, y)) / eps, (value_in(pixels, x, y + eps) - value_in(pixels, x, y)) / eps];}// how far should you shift the point to meet the isoline// if value_in were a distance functionfunction gradient_shift(pixels, threshold, x, y) { var g = gradient(pixels, x, y); var g_norm = Math.sqrt(g[0]*g[0] + g[1]*g[1]); var d = threshold - value_in(pixels, x, y); return [g[0] * d / g_norm / g_norm, g[1] * d / g_norm / g_norm];}// brings a point closer to the threshold isolinefunction fit_point_better(pixels, threshold, point) { const ok_error = 1/255; if(Math.abs(value_in(pixels, point[0], point[1]) - threshold) &lt; ok_error) return point; gs = gradient_shift(pixels, threshold, point[0], point[1]) var new_point = [point[0] + gs[0], point[1] + gs[1]]; return fit_point_better(pixels, threshold, new_point);}</p><p>//梯度函数梯度(像素，x，y){const EPS=1e-5；return[(value_in(像素，x+EPS，y)-value_in(像素，x，y))/EPS，(value_in(像素，x，y+EPS)-value_in(像素，x，y))/EPS]；}//如果value_in是距离函数GRADER_SHIFT(像素，阈值，x，y){var g=GRADER(像素，x，y)；var g_Norm=Math.sqrt(g[0]*g[0]+g[1]*g[1])；var d=Threshold-Value_in(像素，x，y)；返回[g[0]*d/g_NORM/g_NOROM，g[1]*d/g_NORM/g_NORM]；//如果value_in是距离函数，则返回[g[0]*d/g_NORM/g_NORM，g[1]*d/g_NORM/g_NORM]；}//使一个点更接近阈值隔离函数fit_point_Better(像素，阈值，点){const ok_error=1/255；if(Math.abs(value_in(像素，点[0]，点[1])-阈值)&lt；ok_error)返回点；gs=GRADER_SHIFT(像素，阈值，点[0]，点[1])var new_point=[point[0]+gs[0]，point[1]+gs[1]]；返回FIT_POINT_BETER(像素，阈值，NEW_POINT)；}。</p><p>  We&#39;ll move our contour points against the gradient until we&#39;re close enough to the threshold</p><p>我们将根据渐变移动轮廓点，直到我们足够接近阈值。</p><p>          All we have to do to make the contour smooth is to turn each line segment into a parametric cubic curve.</p><p>要使轮廓线光滑，只需将每条直线段变成一条参数三次曲线即可。</p><p>  It&#39;s probably sounds more complicated than it is. A parametric cubic curve is just a pair of polynomials. If you have the points and partial derivatives in this points, you can get the coefficients for them from this pair of  linear systems:</p><p>这听起来可能比实际情况复杂得多。一条参数三次曲线就是一对多项式。如果在这些点上有点和偏导数，就可以从这对线性系统中获得它们的系数：</p><p>  Px(t 1)&#39; = 3a xt 1 2 + 2b xt 1 + c = dx 1/dt Px(t 1) = a xt 1 3 + b xt 1 2 + c xt 1 + d = x 1 Px(t 2) = a xt 2 3 + b xt 2 2 + c xt 2 + d = x 2 Px(t 2)&#39; = 3a xt 2 2 + 2b xt 2 + c = dx 2/dt    Py(t 1)&#39; = 3a yt 1 2 + 2b yt 1 + c = dy 1/dt Py(t 1) = a yt 1 3 + b yt 1 2 + c yt 1 + d = y 1 Py(t 2) = a yt 2 3 + b yt 2 2 + c yt 2 + d = y 2 Py(t 2)&#39; = 3a yt 2 2 + 2b yt 2 + c = dy 2/dt</p><p>Px(T1)&#39；=3aXt12+2bxt1+c=dx1/dtpx(T1)=axt13+bxt12+cxt1+d=x1px(T2)=axt23+bxt22+cxt2+d=x2px(T2)&#39；=3axt2+2bxt2+c=dx2/dtPy(T1)&#39；=3a yt 1 2+2b yt 1+c=dy 1/dt Py(T 1)=a yt 13+b yt 12+c yt 1+d=y 1 Py(T 2)=a yt 23+b yt 22+c+d=y 2 Py(T 2)&#39；=3a yt 22+2b yt 2+c=dy 2/dt。</p><p>      Even more, since we get to choose the parameter range, we can make it [0..1]. This greatly simplifies our system and makes it really easy to solve.</p><p>更重要的是，由于我们可以选择参数范围，因此可以将其设置为[0..1]。这极大地简化了我们的系统，使其非常容易解决。</p><p>  Here is the function that makes one array of polynomial coefficients from two pairs of point and tangent values.</p><p>下面是从两对点和切值生成一个多项式系数数组的函数。</p><p>  // solver specific to [0..1] parametrized splinesfunction spline_for(p1, p1d, p2, p2d) {// A = [// [1, 0, 0, 0],// [0, 1, 0, 0],// [1, 1, 1, 1],// [0, 1, 2, 3]];// B = [p1, p1d, p2, p2d] return [ p1, p1d, 3*p2 - p2d - 3*p1 - 2*p1d, p2d + p1d - 2*p2 + 2*p1 ];}</p><p>//特定于[0..1]参数化样条函数SPLINE_FOR(p1，p1d，p2，p2d){//A=[//[1，0，0，0]，//[0，1，0，0]，//[1，1，1，1]，//[0，1，2，3]]；//B=[p1，p1d，p2，p2d]return[p1，p1d，3*p2-p2d-3*p1-2*p1d，p2d+p1d-2*p2+2*p1]；}。</p><p>    // polynomialfunction polynomial_in_t(A, t){ var pt = 0.0; for(var i = 0; i &lt; A.length; ++i){ pt += A[i] * Math.pow(x, i); } return pt;}</p><p>//多项式函数多项式_in_t(A，t){var pt=0.0；for(var i=0；i&lt；A.length；++i){pt+=A[i]*Math.pow(x，i)；}返回pt；}。</p><p>  So for every line segment with tangents, we can make a parametric polynomial. There is one problem though. We don&#39;t have tangents.</p><p>所以对于每条有切线的线段，我们可以做一个参数多项式。不过，有一个问题。我们没有切线。</p><p>  We have the gradient, which is orthogonal to the tangent, but there are two possible tangents in every point. The tangent can be oriented left or right from the gradient.</p><p>我们有梯度，它与切线正交，但每个点都有两条可能的切线。切线可以从渐变向左或向右。</p><p>  But this is solvable. Let&#39;s just pick the direction we like and keep it consistent.</p><p>但这是可以解决的。让我们选择我们喜欢的方向，并保持一致。</p><p>  Let the curves that originally come from horizontally oriented segments always have both tangents that way that  dx &gt; 0. And the ones that come from vertically oriented segments, will have  dy &gt; 0.</p><p>让最初来自水平方向线段的曲线始终具有DX&gt；0的两条切线。而那些来自垂直方向的线段，将具有dy&gt；0。</p><p>      Let&#39;s split our vectorization into two parts. First, we&#39;ll get points and tangents for every line segment from the pixels. Then we&#39;ll turn it all into polynomial splines.</p><p>让我们把向量化分成两部分。首先，我们将从像素中获取每个线段的点和切线。然后我们将把它全部变成多项式样条。</p><p>    function turn_pixels_into_points_and_tangents(pixels, threshold) { var points = []; var tangents = []; // &#34;horizontal&#34; pieces for(var i = 0; i &lt;= pixels.length; i += 1) { var old_point = []; var old_tangent = []; for(var j = 0; j &lt;= pixels[0].length; j += 1) { // if right, left, top, and bottom pixels have a sign change, // there should be a spline there var sign_change_on_the_right = (pixel_in(pixels, i-1, j+0) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) &lt; 0; var sign_change_on_the_left = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i+0, j-1) - threshold) &lt; 0; var sign_change_on_the_bottom = (pixel_in(pixels, i+0, j-1) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) &lt; 0; var sign_change_on_the_top = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i-1, j+0) - threshold) &lt; 0; if(sign_change_on_the_right || sign_change_on_the_left) { // fits the point on a threshold isoline var point = fit_point_better(pixels, threshold, [j, i]); var g = gradient(pixels, point[0], point[1]); // we want our tangent to be X-positive for horizontal pieces var tangent = g[1] &gt;= 0 ? [g[1], -g[0]] : [-g[1], g[0]]; // this is an T or X junction, the tangent is ambiguous if(sign_change_on_the_left + sign_change_on_the_right + sign_change_on_the_top + sign_change_on_the_bottom &gt; 2) tangent = [0., 0.]; // store the point+tangent and the previous point+tangent // if there is one if(sign_change_on_the_left &amp;&amp; old_point) { points.push([old_point, point]); tangents.push([old_tangent, tangent]); } // save the point+tangent for later if(sign_change_on_the_right) { old_point = point; old_tangent = tangent; } } } } // &#34;vertical&#34; pieces for(var j = 0; j &lt;= pixels[0].length; j += 1) { var old_point = []; var old_tangent = []; for(var i = 0; i &lt;= pixels.length; i += 1) { var sign_change_on_the_right = (pixel_in(pixels, i-1, j+0) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) &lt; 0; var sign_change_on_the_left = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i+0, j-1) - threshold) &lt; 0; var sign_change_on_the_bottom = (pixel_in(pixels, i+0, j-1) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) &lt; 0; var sign_change_on_the_top = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i-1, j+0) - threshold) &lt; 0; if(sign_change_on_the_bottom || sign_change_on_the_top) { var point = fit_point_better(pixels, threshold, [j, i]); var g = gradient(pixels, point[0], point[1]); var tangent = g[0] &lt; 0 ? [g[1], -g[0]] : [-g[1], g[0]]; if(sign_change_on_the_left + sign_change_on_the_right + sign_change_on_the_top + sign_change_on_the_bottom &gt; 2) tangent = [0., 0.]; if(sign_change_on_the_top &amp;&amp; old_point) { points.push([old_point, point]); tangents.push([old_tangent, tangent]); } if(sign_change_on_the_bottom) { old_point = point; old_tangent = tangent; } } } } return [points, tangents];}</p><p>函数Turn_Pixels_Into_Points_and_Tangents(像素，阈值){var Points=[]；var Tangents=[]；//&#34；水平&#34；块(var i=0；i&lt；=Pixels.length；i+=1){var old_point=[]；var old_Tangent=[]；for(var j=0；j&lt；=像素[0].length；J+=1){//如果右、左、上、下四个像素有符号变化，//这里应该有样条线var sign_change_on_the_right=(Pixel_in(像素，i-1，j+0)-阈值)*(Pixel_in(像素，i+0，j+0)-阈值)&lt；0；Var Sign_Change_On_the_Left=(Pixel_in(像素，i-1，j-1)-阈值)*(Pixel_in(像素，i+0，j-1)-阈值)&lt；0；var sign_change_on_the_Bottom=(Pixel_in(像素，i+0，j-1)-阈值)*(Pixel_in(像素，i+0，j+0)-阈值)&lt；0；Var sign_change_on_the_top=(Pixel_in(像素，i-1，j-1)-阈值)*(Pixel_in(像素，i-1，j+0)-阈值)&lt；0；if(sign_change_on_the_right||sign_change_on_the_Left){//拟合阈值等值线上的点var point=fit_point_Better(像素，阈值，[j，i])；var g=渐变(像素，点[0]，点[1])；//我们希望我们的切线对于水平段是X正的var Tangent=g[1]&gt；=0？[g[1]，-g[0]]：[-g[1]，g[0]]；//这是一个T或X交叉点，如果(Sign_Change_On_the_Left+Sign_Change_On_the_Right+Sign_Change_On_the_Bottom&gt；2)Tangent=[0，0.]；//如果(Sign_Change_On_the_Left&Amp；)存在一个(Sign_Change_On_the_Left&Amp；)切线=[0，0.]；//这是T或X交叉点，切线是不明确的。&amp；old_point){points.ush([old_point，point])；Tangents.ush([old_Tangent，Tangent])；}//如果(Sign_Change_On_The_Right){old_point=point；old_Tangent=Tangent；}//&#34；(var j=0；j&lt；=像素[0].length；j+=1){var old_point=[]；Var old_Tangent=[]；for(var i=0；i&lt；=picels.length；i+=1){var sign_change_on_the_right=(Pixel_in(像素，i-1，j+0)-阈值)*(Pixel_in(像素，i+0，j+0)-阈值)&lt；0；Var Sign_Change_On_the_Left=(Pixel_in(像素，i-1，j-1)-阈值)*(Pixel_in(像素，i+0，j-1)-阈值)&lt；0；var sign_change_on_the_Bottom=(Pixel_in(像素，i+0，j-1)-阈值)*(Pixel_in(像素，i+0，j+0)-阈值)&lt；0；Var sign_change_on_the_top=(Pixel_in(像素，i-1，j-1)-阈值)*(Pixel_in(像素，i-1，j+0)-阈值)&lt；0；if(sign_change_on_the_Bottom||sign_change_on_the_top){var point=fit_point_Better(像素，阈值，[j，i])；var g=渐变(像素，点[0]，点[1])；var切线=g[0]&lt；0？[g[1]，-g[0]]：[-g[1]，g[0]]；if(sign_change_on_the_Left+sign_change_on_the_right+sign_change_on_the_Bottom&gt；2)切线=[0，0.]；if(sign_change_on_the_top&amp；&amp；old_point){points.ush([old_point，point])；Tangents.ush([old_Tangent，Tangent])；}if(Sign_Change_On_The_Bottom){old_point=point；old_Tangent=Tangent；}return[点，切线]；}。</p><p>    function turn_points_and_tangents_into_splines(points_and_tangents){ var splines = []; var points = points_and_tangents[0]; var tangents = points_and_tangents[1]; for(var i = 0; i &lt; points.length; ++i) { var Px = spline_for( points[i][0][0], tangents[i][0][0], points[i][1][0], tangents[i][1][0]); var Py = spline_for( points[i][0][1], tangents[i][0][1], points[i][1][1], tangents[i][1][1]); splines.push([Px, Py]); } return splines}</p><p>函数turn_points_and_tangents_into_splines(points_and_tangents){变量样条=[]；变量POINTS=POINTS_AND_TENGNTS[0]；VAR TENTINTS=POINTS_AND_TENTINTS[1]；FOR(var i=0；i&lt；points.length；++i){var px=SPLINE_FOR(Points[i][0][0]，Tangents[i][0][0]，Points[i][1][0]，Tangents[i][1][0])；Var Py=SPLINE_FOR(点[i][0][1]，切线[i][0][1]，点[i][1][1]，切线[i][1][1])；样条线.推([px，Py])；}返回样条曲线}。</p><p>  This split is not essential for the algorithm, but it makes it possible to edit the model in both image and spline representation.</p><p>此拆分对于算法不是必需的，但它使编辑图像和样条线表示中的模型成为可能。</p><p>    Now, when we have the algorithm, let&#39;s see how it works in practice. Let&#39;s import a gray-scale image from PGM, turn it into splines, edit them, then export them as SVG.</p><p>现在，当我们有了算法后，让我们看看它在实践中是如何工作的。让从PGM导入灰度图像，将其转换为样条线，对其进行编辑，然后将其导出为SVG。</p><p>  PGM is a 1-channel ASCII image format. You can make a PGM file in GIMP or any other raster image editor.</p><p>PGM是一种单通道ASCII图像格式。可以在GIMP或任何其他光栅图像编辑器中生成PGM文件。</p><p>  P216 162550 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 77 125 38 0 0 0 0 0 0 0 0 0 0 0 00 120 255 254 203 144 96 3 0 0 0 0 0 0 0 00 34 253 255 255 255 255 230 154 94 8 0 0 0 0 00 0 196 255 255 255 255 255 255 252 241 139 83 6 0 00 0 149 255 255 255 255 255 255 255 255 255 250 213 80 00 0 98 255 255 255 255 255 255 255 255 255 255 224 58 00 0 2 224 255 255 255 255 255 255 255 242 152 4 0 00 0 0 145 255 255 255 255 255 255 255 154 1 0 0 00 0 0 82 251 255 255 255 255 255 255 253 156 1 0 00 0 0 6 237 255 255 255 255 255 255 255 252 146 3 00 0 0 0 149 255 255 243 149 252 255 255 255 240 21 00 0 0 0 69 249 255 152 1 150 252 255 238 71 0 00 0 0 0 0 211 224 4 0 1 137 240 86 0 0 00 0 0 0 0 73 57 0 0 0 2 20 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</p><p>P216 162550 0 0 0 77 125 38 0 0 0 00 120 255 254203 144 96 3 0 0 0 00 34 253 255 255 255 230 154 94 8 0 0 00 0 196 255 255 255 252 241 139 83 6 0 00 0 149 255 255 255 250 213 80 00 0 98 255 255 255 224 58 00 0 2 224 255 255 255 242 152 4。0 00 0 0 145 255 255 255 154 1 0 00 0 0 0 82 251 255 255 255 253 156 1 0 00 0 0 6 237 255 255 255 3 00 0 0 149 255 243 149 252 255 255 240 21 00 0 0 69 249 255 152 1 150 252 255 238 71 0 00 0 0 0 211 224 4 0 1 137 240 86 0 0 00 0 0 0 73 57 0 0 2 20 0 0 00 0 0 0</p><p>      When the image is imported, we can either edit the source image pixel-by-pixel or move the splines&#39; points and tangents. Click on a canvas to increase a pixel&#39;s luminosity. Click holding the Shift key to reduce it. Please note that in this example, image editing overrides vectors.</p><p>导入图像时，我们可以逐个像素编辑源图像，也可以移动样条点和切线。单击画布以增加像素的亮度。单击按住Shift键可减小该值。请注意，在本例中，图像编辑覆盖矢量。</p><p>        When you&#39;re happy with the splines, you can export them in  SVG. In this example, only the outline is supported. No filling, no coloring.</p><p>当您对样条线感到满意时，可以将其导出为SVG。在本例中，仅支持大纲。没有填充物，没有着色。</p><p>        You don&#39;t have to export the polynomials. SVG supports  Bézier curves, and they are basically the same as cubic polynomials. Only instead of coefficients, you write down the control points.</p><p>你不必输出多项式。SVG支持Bézier曲线，与三次多项式基本相同。只是你写下的不是系数，而是控制点。</p><p>  The first point is the starting point of the spline. The second is the sum of the first point and one-third of a tangent vector. The third is the subtraction of the finishing point of the spline and the one-third of a second tangent. The fourth is the finishing point of the spline.</p><p>第一个点是样条曲线的起点。第二个是第一个点与切向量的三分之一之和。第三个是样条曲线的终点和第二条切线的三分之一的减去。第四个是样条曲线的终点。</p><p>  The code for the export function, just as all the code mentioned here including the visuals, is available  on Github.</p><p>导出函数的代码，就像这里提到的所有代码(包括视觉效果)一样，可以在Github上找到。</p><p>    The algorithm shows how bilinear interpolation, polynomial approximation, differential analysis, and iterative algorithms work together to solve a practical problem.</p><p>该算法展示了双线性插值、多项式近似、微分分析和迭代算法如何协同工作来解决实际问题。</p><p>  I hope this page will not only satisfy one&#39;s curiosity but help someone retain inspiration while studying these things. I know from my experience that basic calculus while being not more complicated than the traffic code, is particularly hard to learn because you don&#39;t see the application right away. You learn about series, limits, derivatives, integrals, and for what reason? How do you turn this knowledge into something useful?</p><p>我希望这个页面不仅能满足人们的好奇心，还能帮助人们在学习这些东西的同时保持灵感。根据我的经验，我知道基础微积分虽然不比交通规则复杂，但特别难学，因为你不会马上看到应用程序。你学习级数、极限、导数、积分，原因是什么？如何将这些知识转化为有用的东西呢？</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://wordsandbuttons.online/simple_image_vectorization.html">https://wordsandbuttons.online/simple_image_vectorization.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/图像/">#图像</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/image/">#image</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/像素/">#像素</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>