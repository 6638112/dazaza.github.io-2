<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Python中的声明性验证 Declarative Validation in Python</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Declarative Validation in Python<br/>Python中的声明性验证 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-05 20:53:32</div><div class="page_narrow text-break page_content"><p>In the past two years I’ve become reasonably comfortable with both PureScript and Haskell. I’ve learned so many new things whilediving into the pure functional programming ecosystem and many of thesetechniques can be applied to other paradigms. Unfortunately, the pure FP worldcan feel a bit like another dimension – where many programming problems haveelegant solutions but the world of “regular” programming isn’t aware of thesepatterns.</p><p>在过去的两年里，我对Pureescript和Haskell都会合理舒适。我学到了许多新的东西，同时进入纯粹的功能编程生态系统，并且许多这是其他范例可以应用于其他范式。不幸的是，纯粹的FP Worldcan感觉有点像另一个维度 - 许多编程问题都有散开解决方案，但“常规”编程的世界不了解素图。</p><p> One such pattern is called “applicative-style validation”, but I’ll simply callit “declarative validation”. In this post I’ll provide some motivation for usingthis technique and then build a small library in Python implementing these ideas.</p><p> 一种这样的模式被称为“适用式验证”，但我将简单地调用“声明性验证”。在这篇文章中，我将为使用这项技术提供一些动机，然后在Python实现这些想法的一个小图书馆。</p><p>  Many of our programs accept input from the user. Often we need to validate thisinput before continuing processing and, in the case of errors, inform the userof any problems. There are several techniques for performing this kind ofvalidation, but the most common is to write some imperative code that walks overthe input and builds up a list of errors. If there are no errors, the providedinput is valid, otherwise it isn’t. We can wrap the result our validationreturns in an object that indicates if the validation was successful.</p><p>  我们的许多程序接受用户的输入。我们通常需要在继续处理之前验证此单一，而在错误的情况下，请通知用户任何问题。有几种用于执行此类无验证的技术，但最常见的是写一些遍布输入的命令代码，并建立错误列表。如果没有错误，则提供的iny有效，否则它不是。我们可以在一个指示验证是否成功的对象中包装我们的validationReturn。</p><p> @ dataclass class  Valid :  value :  Any  def  is_valid ():  return  True @ dataclass class  Invalid :  value :  Any  def  is_valid ():  return  False def  validate_name ( name ,  errors ):  if  not  isinstance ( name ,  str )  or  name  ==  &#34;&#34; :  errors . append ( &#34;name must be a non-empty string&#34; ) def  validate_age ( age ,  errors ):  if  not  isinstance ( age ,  int ):  errors . append ( &#34;age must be an int&#34; )  elif  age  &lt;  10 :  errors . append ( &#34;age must be at least 10&#34; ) def  validate ( data ):  errors  =  []  validate_name ( data . get ( &#34;name&#34; ),  errors )  validate_age ( data . get ( &#34;age&#34; ),  errors )  if  not  errors :  return  Valid ( data )  else :  return  Invalid ( errors )</p><p> @ DataClass类有效：value：任何def is_valid（）：返回true @ dataclass类无效：value：def is_valid（）：返回false def validate_name（名称，错误）：如果不是isinstance（名称，str）或name == ＆＃34;＆＃34; ：错误。附加（＆＃34;名称必须是非空字符串＆＃34;）def validate_age（年龄，错误）：如果不是isinstance（年龄，int）：错误。附加（＆＃34;年龄必须是int＆＃34;）elif年龄＆lt; 10：错误。附加（＆＃34;年龄必须至少10＆＃34;）def验证（数据）：errors = [] validate_name（数据。获取（＆＃34;名称＆＃34;），错误）validate_age（数据。get（ ＆＃34;年龄＆＃34;），错误）如果不是错误：返回有效（数据）else：返回无效（错误）</p><p> While this approach works, things get complicated when we have validations thatare dependent on previous results. Say, for example, that we want to add a new,more complicated rule stating that if the name is  Drew, the age must be atleast  40. In order to do this, both name and age need to be present and havethe appropriate type. But we don’t have a convenient way to “reuse” this logicfrom the existing  validate_name and  validate_age functions. One approach isto simply re-check locally and assume errors have already been added if thetypes are incorrect.</p><p> 虽然这种方法有效，但是当我们有验证依赖于之前的结果时，事情会变得复杂。例如，我们要添加一个新的，更复杂的规则，说明如果名称绘制，则年龄必须至少为40.为了做到这一点，才需要出现姓名和年龄并有适当的类型。但是，我们没有方便的方法来“重用”此逻辑的现有validate_name和validate_age函数。一种方法是在本地重新检查，如果Qoypes不正确，已经添加了错误。</p><p> def  validate_drew ( data ,  errors ):  if  ( not  isinstance ( data . get ( &#34;name&#34; ),  str )  or  not  isinstance ( data . get ( &#34;age&#34; ),  int )):  return  elif  data . get ( &#34;name&#34; )  ==  &#34;Drew&#34;  and  data . get ( &#34;age&#34; )  &lt;  40 :  errors . append ( &#34;Drew must be old&#34; )</p><p> def validate_drew（数据，错误）：if（不是isinstance（数据。获得（＆＃34;名称＆＃34;），str）或不isinstance（＆＃34;年龄＆＃34;），int）） ：返回Elif数据。得到（＆＃34;名称＆＃34;）==＆＃34; drew＆＃34;和数据。得到（＆＃34;年龄＆＃34;）＆lt; 40：错误。附录（＆＃34;德鲁必须老＆＃34;）</p><p> This isn’t great, because now we’ve duplicated the instance checks in twoplaces. We could also make sure specific errors are not present in the  errorslist, but this would couple this validation to the errors exposed in a previousvalidations.</p><p> 这不是很大的，因为现在我们在Twoplaces中重复了实例检查。我们也可以确保错误列表中不存在特定错误，但这会将此验证耦合到以前过验证中暴露的错误。 </p><p> The downsides of the stateful validation approach can be overcome by using a“parsing” approach. That is, we declaratively describe the shape and type of theinput that we expect and return an error if our data does not meet thoseexpectations. This approach is extremely well documented in the post  Parse,don’tvalidate.Parsing is a fantastic alternative to stateful validation, but this style ofparsing (often called monadic parsing) does have one disadvantage – it haltsprocessing as soon as the first error is reached. We’d like to collect as muchinformation as possible on the invalid input for our user.</p><p>可以使用“解析”方法来克服有状态验证方法的缺陷。也就是说，我们声明性地描述了我们预期并返回错误，如果我们的数据不符合TheSeppectations，则返回错误的形状和类型。在Parse后，这种方法在解析后有很好的记录，不验证。倒进是一个很好的状态验证的替代方案，但这种风格的桨式（通常称为Monadic解析）确实有一个缺点 - 它一旦达到第一个错误就会停止处理。我们希望在我们用户的无效输入上收集尽可能多的信息。</p><p> We can take another approach that gives us the composability of the parsingapproach as well as the error accumulation of the stateful approach. Thisapproach is traditionally called “applicative-style validation”.</p><p> 我们可以采取另一种方法，使我们提供了ParsingApproach的可融合性以及有状态方法的错误积累。这个人传统上称为“适用式验证”。</p><p>  We’ll be providing two primary functions along with our existing  Valid and Invalid types.</p><p>  我们将提供两个主要功能以及我们现有的有效和无效类型。</p><p> validate_into allows us to call a provided function with a list ofarguments, assuming all the arguments are  Valid. Otherwise, it accumulatesthe errors in any  Invalid arguments.</p><p> validate_into允许我们调用提供的函数，其中包含Otguments列表，假设所有参数都有效。否则，它累积在任何无效参数中的错误。</p><p>  and_then allows us to perform another “stage” of validations assuming thesubject of the function is  Valid. If the subject of the function is Invalid, we do nothing.</p><p>  And_then允许我们假设函数的验证的验证的另一个“阶段”是有效的。如果函数的主题无效，我们什么都不做。</p><p> You can think of  validate_into as building one “stage” of our validationpipeline and  and_then as linking two stages together. Any validations within astage will have their errors accumulated, but if a stage fails, we won’t runvalidations for any later stages. This means we should only break ourvalidations into stages when a given stage depends on valid values from aprevious stage.</p><p> 您可以将validate_into视为构建验证普通和验证的一个“阶段”，并将两个阶段连接在一起。 Astage内的任何验证都会累积其错误，但如果阶段失败，我们将无法为任何较小的阶段运行。这意味着当给定阶段取决于不适治阶段的有效值时，我们应该仅将Outvalidations分解为阶段。</p><p> Let’s use these two functions to reimplement our validations from above. First,we’ll define a  Person class into which we’ll be placing the valid data.</p><p> 让我们使用这两个功能从上面重新实现我们的验证。首先，我们将定义一个人类，我们将在其中放置有效数据。 </p><p>   def  validate_name ( name ):  if  not  isinstance ( name ,  str )  or  name  ==  &#34;&#34; :  return  Invalid ([ &#34;name must be a non-empty string&#34; ])  else :  return  Valid ( name ) def  validate_age ( age ):  if  not  isinstance ( age ,  int ):  return  Invalid ([ &#34;age must be an integer&#34; ])  elif  age  &lt;  10 :  return  Invalid ([ &#34;age must be at least 10&#34; ])  else :  return  Valid ( age ) def  validate_drew ( person ):  if  person . name  ==  &#34;Drew&#34;  and  person . age  &lt;  40 :  return  Invalid ([ &#34;Drew is old&#34; ])  else :  return  Valid ( person ) def  validate ( data ):  return  validate_into (  Person ,  validate_name ( data . get ( &#34;name&#34; )),  validate_age ( data . get ( &#34;age&#34; )),  ). and_then ( validate_drew )</p><p>def validate_name（名称）：如果不是isinstance（姓名，str）或name ==＆＃34;＆＃34; ：返回无效（[＆＃34;名称必须是非空字符串＆＃34;]）else：返回有效（姓名）def validate_age（年龄）：如果不是isinstance（年龄，int）：返回无效（[＆＃ 34;年龄必须是整数＆＃34;]）Elif年龄＆lt; 10：返回无效（[＆＃34;年龄必须至少为10＆＃34;]）else：返回有效（年龄）def validate_drew（person）：如果是人。 name ==＆＃34; drew＆＃34;和人。年龄＆lt; 40：返回无效（[＆＃34; draw旧＆＃34;]）else：返回有效（人）def验证（数据）：return validate_into（person，validate_name（数据。get（＆＃34;姓名＆＃34; ）），validate_age（数据。得到（＆＃34;年龄＆＃34;）），）。 And_then（validate_drew）</p><p> There are a few things to notice here. First, each validation function standsalone. Second, there is no mutation of the input data happening. Each functionperforms its validations and then returns a  Valid or  Invalid value. Last,note that each  Invalid returns a  list of errors. This allows ouraccumulation to happen.</p><p> 这里有几件事要注意到。首先，每个验证函数都进行隔离。其次，没有输入数据的突变发生。每个都函数验证，然后返回有效或无效值。最后，请注意，每个无效返回错误列表。这允许我们的绯意发生。</p><p>  validate ({  &#34;name&#34; :  None ,  &#34;age&#34; :  &#34;hello&#34; , }) # =&gt; Invalid(value=[# &#39;name must be a non-empty string&#39;,# &#39;age must be an integer&#39;]) validate ({  &#34;name&#34; :  &#34;Drew&#34; ,  &#34;age&#34; :  38 , }) # =&gt; Invalid(value=[&#39;Drew is old&#39;]) validate ({  &#34;name&#34; :  &#34;Jane&#34; ,  &#34;age&#34; :  38 , }) # =&gt; Valid(value=Person(name=&#39;Jane&#39;, age=38))</p><p>  验证（{＆＃34;姓名＆＃34;：none，＆＃34;年龄＆＃34;：＆＃34;你好＆＃34;，}）＃=＆gt;无效（value = [＃＆＃39;名称必须是非空字符串＆＃39;，＃＆＃39;年龄必须是整数＆＃39;]）验证（{＆＃34;姓名＆＃34;：＆ ＃34; drew＆＃34;，＆＃34;年龄＆＃34;：38，}）＃=＆gt;无效（value = [＆＃39; drew旧的＆＃39;]）验证（{＆＃34;姓名＆＃34;：＆＃34;简＆＃34;，＆＃34;年龄＆＃34;：38，} ）＃=＆gt;有效（价值=人（名称=＆＃39; Jane＆＃39;，年龄= 38））</p><p> Notice that the second stage of our validations, namely  validate_drew, canassume all of its input is  Valid after the first stage. Therefore, we don’tneed to re-check anything regarding the types of  name or  age beforeperforming our specific validation (Drew needs to be old). Also notice how easyit would be to add new validations if we added a new argument to the  Personconstructor.</p><p> 请注意，我们的验证第二阶段，即vightate_drew，Canassume所有输入都在第一阶段后有效。因此，我们并不确保重新检查任何关于我们具体验证的名称或年龄类型的内容（Drew需要旧的）。如果我们为PersonConstructor添加了新参数，请注意添加新验证的效力如何是多么难看。</p><p>  We might image that the library to support this code would be quite complicated.In practice, it is very simple. The only function outside of the standardlibrary we use is  curry from the  toolz library, but if we wanted to dropthis dependency we could re-implement  curry ourselves.</p><p>  我们可能会认为，支持此代码的库会非常复杂。在练习中，它非常简单。我们使用的标准Library之外的唯一功能是来自工具库库的咖喱，但如果我们想删除依赖，我们可以自己重新落实咖喱。</p><p> from  dataclasses  import  dataclass from  functools  import  reduce from  toolz  import  curry from  typing  import  Any @ dataclass class  Valid :  value :  Any  def  is_valid ( self ):  return  True  def  apply ( self ,  other ):  if  other . is_valid ():  return  Valid ( self . value ( other . value ))  else :  return  other  def  and_then ( self ,  f ):  return  f ( self . value ) @ dataclass class  Invalid :  value :  Any  def  is_valid ( self ):  return  False  def  apply ( self ,  other ):  if  other . is_valid ():  return  self  else :  return  Invalid ( self . value  +  other . value )  def  and_then ( self ,  f ):  return  self def  validate_into ( f ,  * args ):  return  reduce ( lambda  a ,  b :  a . apply ( b ),  args ,  Valid ( curry ( f )))</p><p> 从DataClasses从Functools导入DataClass从Toolz导入Curry从键入导入键键入导入任何@ dataclass类有效：value：任何def is_valid（self）：返回true def应用（self，其他）：如果是另一个。 is_valid（）：返回有效（self。值（其他值））else：返回其他def和_then（self，f）：返回f（self.value）@ dataclass类无效：value：任何def is_valid（self）：返回假def申请（自我，其他）：如果是的话。 IS_VALID（）：返回自我否则：返回无效（SELE。值+其他。值）def和_then（self，f）：返回自我def validate_into（f，* args）：返回减少（lambda a，b：a。申请） b），args，有效（咖喱（f）））</p><p> The above code is the entirety of our library. The  and_then function isrelatively straight forward. If we attempt to chain a new stage of validationson a  Valid value, we simple invoke the provided function with the  valueinside of our  Valid. If we attempt to chain a new stage of validations on an Invalid value, we just ignore the provided function and return  self.</p><p> 上面的代码是我们的图书馆的整体。 AND_THEN函数呈呈态度直截了当。如果我们尝试将验证的新阶段连锁有效值，我们简单地调用提供的功能，其中有效的价值占据了您的有效价值。如果我们尝试将验证的新阶段链接到无效值，我们只是忽略提供的功能并返回自我。 </p><p> The  validate_into function feels more complicated, so let’s describe what itis doing step by step. First, we  curry the provided function. This isimportant because we’re going to be applying the function one argument at a timeas we determine if each argument is  Valid. We also place this curried functioninto a  Valid wrapper as it starts in a  Valid state before seeing anyarguments. Then, one by one, we apply the next argument to our “function sofar”. In the case that the argument is  Valid and the “function so far” isvalid, we just invoke the function with the argument and re-wrap it in  Valid.If the “function so far” is  Valid but the new argument is  Invalid, we makethe new “function so far” the  Invalid result. Finally, and importantly, if the“function so far” is already  Invalid and we’re provided a new  Invalidargument, we concatenate the errors and re-wrap the result in  Invalid.</p><p>validate_into函数感觉更复杂，因此让我们描述一步一步的ITIS。首先，我们咖喱提供的功能。这不一致，因为我们将在Timeas上应用一个参数，我们确定每个参数是否有效。我们还将此咖喱函数介绍了一个有效的包装器，因为它在查看AnyGuments之前在有效状态下开始。然后，一个接一个地，我们将下一个参数应用于我们的“函数sofar”。在该参数有效和“到目前为止”是isvalid的情况下，我们只是用参数调用函数并重新包装它在有效状态。如果“到目前为止”是有效的，但新参数无效，我们makethe新的“函数到目前为止”无效结果。最后，重要的是，如果“函数到目前为止”已经无效，我们提供了一个新的InvalidArgument，我们会连接错误并重新包装导致无效。</p><p> Using these simple tools, we can write complicated, deeply-nested validators.Reuse of our validators is simple as they are nothing more than functions. Wecan place them in a package and share commonly used validators (think validate_presence) easily across our codebase.</p><p> 使用这些简单的工具，我们可以编写复杂的深刻嵌套的验证器。我们的验证器的灵活性很简单，因为它们只不过是功能。 WeCan将它们放在一个包中，并在我们的代码库中轻松分享常用的验证器（思考validate_presence）。</p><p>  Nothing in this post is new. I am reimplementing ideas from many other ecosystemsin Python to make them more approachable. Applicative-style validation is justone of a huge number of ideas from the pure functional programming world thatdeserves wider recognition and adoption in more mainstream languages.</p><p>  这篇文章中的任何内容都是新的。我正在重新实现来自许多其他Ecosystemsin Python的想法，使它们更加平衡。申请风格验证是纯粹的功能编程世界的大量想法，即在更多主流语言中更广泛的认可和采用。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.drewolson.org/declarative-validation">https://blog.drewolson.org/declarative-validation</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/声明/">#声明</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/验证/">#验证</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>