<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Elixir Swenserver解释说明 Elixir GenServer Explained</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Elixir GenServer Explained<br/>Elixir Swenserver解释说明 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-28 11:19:52</div><div class="page_narrow text-break page_content"><p>I started learning Elixir a few months ago, mostly through hacking on  Papercups. I&#39;m ashamed to say most of my Elixir education has been through trial and error, figuring things out as I go along. So this past week I decided to take some time off from Papercups to go a bit deeper into the language.</p><p>几个月前，我开始学习Elixir，主要是通过黑客攻击纸张。我愤怒地说，我的大部分Elixir教育一直是通过审判和错误的，在我走的时候弄清楚。所以过去的一周我决定从纸上掉一段时间休息，更深入地进入语言。</p><p> In particular, I was itching to learn more about handling concurrency in Elixir. This, of course, led me to GenServers.</p><p> 特别是，我正在拍摄更多关于在Elixir中处理并发性的更多信息。当然，这让我感到了惩罚者。</p><p> Anyone who&#39;s moderately familiar with Elixir has probably at least  heard of   GenServer. (If you haven&#39;t, that&#39;s ok too!) Strictly speaking, it&#39;s one of those things you can get away with avoiding for a while, and still be reasonably productive while using something like the Phoenix framework.</p><p> ＆＃39; SOMEDERY熟悉ELIXIR的人可能至少听说了Genserver。 （如果你没有，那也没有，那个＆＃39; SOOD！）严格来说，它＆＃39;虽然你可以逃避一段时间，但在使用这样的东西时仍然具有合理的效率凤凰框架。</p><p> But it&#39;s an incredible useful feature of the language that you can add to your toolbox! There are so many nice things you can do with it. For example, with GenServers, you can:</p><p> 但它＆＃39;是您可以添加到工具箱的语言的令人难以置信的有用功能！你可以用它做很多好的东西。例如，使用Genservers，您可以：</p><p> set up recurring tasks to run every few hours (e.g. check out Jose&#39;s answer to  &#34;How can I schedule code to run every few hours in Elixir?&#34; on Stack Overflow)</p><p> 设置每隔几个小时的重复任务每隔几个小时（例如，检查何塞＆＃39;答案到＆＃34;如何安排在Elixir中每隔几个小时运行代码？＆＃34;堆栈溢出）</p><p> handle async processes much more easily, with built-in functionality for tracing, error reporting, and retry logic</p><p> 更轻松地处理异步流程，具有追踪，错误报告和重试逻辑的内置功能</p><p>   A  GenServer is a process, just like any other Elixir process. It can be used to manage state and execute code asynchronously, and includes some handy functionality around tracing and error reporting.</p><p>   Genserver是一个过程，就像任何其他Elixir进程一样。它可用于异步管理状态并执行代码，并包括围绕跟踪和错误报告的一些方便的功能。 </p><p> Another way of thinking about it — a GenServer is like an isolated little box, with a few things inside of it:</p><p>另一种思考方式 - 一个咒语就像一个孤立的小盒子，其中有一些东西：</p><p> its internal state (which can be any Elixir data structure, from a simple number to a complex map/struct),</p><p> 其内部状态（可以是任何Elixir数据结构，从简单的数字到复杂的地图/结构），</p><p>  and a callback module, which defines the code to run depending on the message that is received in the mailbox</p><p>  和一个回调模块，它定义了根据邮箱中收到的消息运行的代码</p><p>   While learning about GenServers, I found many of the examples to be a bit contrived... a lot of &#34;key-value&#34; stores, shopping lists, and things like that. I wanted to understand how GenServers are being used &#34;out in the wild&#34;, so I turned to one of my favorite Elixir open-source repos:  https://github.com/plausible/analytics</p><p>   在学习Genservers时，我发现许多例子有点是一个......很多＆＃34;钥匙值＆＃34;商店，购物列表和类似的东西。我想了解Genservers是如何使用的，并且在野外＆＃34;所以我转向了我最喜欢的elixir开源repos：https：//github.com/plausible/analytics</p><p> A bit of background:  Plausible is an open-source analytics platform, with &gt;1000 paying customers. Because they are a real-world production application serving many users, I figured I could learn a lot from diagnosing one of their modules. 🤓</p><p> 有点背景：合理的是一个开源分析平台，具有＆gt; 1000支付客户。因为它们是服务许多用户的真实生产应用程序，所以我想我可以学习很多诊断他们的模块。 🤓</p><p> For the sake of this post, I&#39;m going to go through one of the simpler GenServers in their repo:  Plausible.Event.WriteBuffer, which can be found at  /lib/plausible/event/write_buffer.ex</p><p> 为了这篇文章，我将通过他们的repo中的一个更简单的genservers之一：plausible.event.writeBuffer，它可以在/lib/plausible/fent/write_buffer.ex中找到</p><p>  At a high level, this GenServer allows Plausible to insert large quantities of events into the database in batches, rather than doing an insertion for each individual event. (This seems particularly important for a product like Plausible&#39;s, where they are potentially ingesting thousands of events per second!)</p><p>  在高级别中，此Genserver允许合理的信息以批量将大量事件插入数据库中，而不是为每个单独事件进行插入。 （这对像合理的产品似乎尤为重要，在那里他们可能会摄取每秒成千上万的事件！） </p><p>  adding them to a  buffer in the process&#39;s internal state, represented by a list (i.e.  [])</p><p>将它们添加到过程中的缓冲区＆＃39; s内部状态，由列表表示（即[]）</p><p> &#34;flushing&#34; the buffer every 5 seconds, or if it reaches its capacity of 10,000 events — whichever comes first where &#34;flushing&#34; means saving all the events in the buffer to a database (in this case, ClickHouse)</p><p> ＆＃34;冲洗＆＃34;每5秒的缓冲区，或者它达到其容量为10,000个事件 - 无论哪个是第一次在其中＆＃34;冲洗＆＃34;意味着将缓冲区中的所有事件保存到数据库（在本例中，单击小时）</p><p> (For the full context, let&#39;s take a look at the codebase: we can see that the  Plausible.Event.WriteBuffer GenServer is used in the   PlausibleWeb.Api.ExternalController.event/2 method, which handles the logic for the   POST /api/event API endpoint, which in turn gets called from their  JavaScript tracking snippet.)</p><p> （对于完整的上下文，让＆＃39; s看看代码库：我们可以看到plausible.event.writeBuffer Genserver用于PlausibleWeb.api.externalController.Event / 2方法，它处理逻辑post / api /事件API端点，又从他们的JavaScript跟踪片段调用。）</p><p>  Before we jump into it, here&#39;s the  full module, with some minor stylistic tweaks and annotations I&#39;ve added myself for some additional context:</p><p>  在我们跳入它之前，这里的完整模块，带有一些小型风格调整和注释I＆＃39; ve添加了一些其他背景：</p><p> defmodule Plausible .Event .WriteBuffer  do  use GenServer  require Logger    5_000    10_000  # Client APIs  def start_link (_opts )  do GenServer .start_link (__MODULE__ ,  [ ] ,   __MODULE__ )  end  def insert (event )  do GenServer .cast (__MODULE__ ,  { :insert , event } )  { :ok , event }  end  def flush ( )  do GenServer .call (__MODULE__ ,  :flush ,  :infinity )  :ok  end  # Server (callbacks)    true  def init (buffer )  do Process .flag ( :trap_exit ,  true ) timer  = Process .send_after (self ( ) ,  :tick ,   )  { :ok ,  % {  buffer ,   timer } }  end    true  def handle_cast ( { :insert , event } ,  % {  buffer ,   timer }  = _state )  do new_buffer  =  [event  | buffer ]  if length (new_buffer )  &gt;=    do Logger .info ( &#34;Buffer full, flushing to disk&#34; ) Process .cancel_timer (timer ) do_flush (new_buffer ) new_timer  = Process .send_after (self ( ) ,  :tick ,   )  { :noreply ,  % {   [ ] ,   new_timer } }  else  { :noreply ,  % {state  |   new_buffer } }  end  end    true  def handle_info ( :tick ,  % {  buffer }  = _state )  do do_flush (buffer ) timer  = Process .send_after (self ( ) ,  :tick ,   )  { :noreply ,  % {   [ ] ,   timer } }  end    true  def handle_call ( :flush , _from ,  % {  buffer ,   timer }  = _state )  do Process .cancel_timer (timer ) do_flush (buffer ) new_timer  = Process .send_after (self ( ) ,  :tick ,   )  { :reply ,  nil ,  % {   [ ] ,   new_timer } }  end    true  def terminate (_reason ,  % {  buffer }  = _state )  do Logger .info ( &#34;Flushing event buffer before shutdown...&#34; ) do_flush (buffer )  end  # Private/utility methods  defp do_flush (buffer )  do  case buffer  do  [ ]  -&gt;  nil events  -&gt; Logger .info ( &#34;Flushing   #{length (events ) } events&#34; ) events  = Enum .map (events ,  &amp; (Map .from_struct ( &amp;1 )  |&gt; Map .delete ( :__meta__ ) ) ) Plausible .ClickhouseRepo .insert_all (Plausible .ClickhouseEvent , events )  end  end end</p><p> DefModule合理的.Event .writeBuffer确实使用Genserver要求记录器5_000 10_000＃客户端API Def Start_Link（_Opts）Do Genserver .start_link（__module__，[]，__module__）结束def插入（事件）do genserver .cast（__module__，{：插入，事件}）{：确定，事件}结束def flush（）do genserver .call（__module__，：flush，：Infinity）：确定#server（回调）true def init（buffer）do process .flag（：trap_exit，true ）timer = process .send_after（self（），：tick，）{：ok，％{buffer，timer}}结束true def handle_cast（{：插入，事件}，％{buffer，timer} = _state）do new_buffer = [事件|缓冲区]如果长度（new_buffer）＆gt; = do logger .info（＆＃34; buffer full，刷新到磁盘＆＃34;）进程.cancel_timer（timer）do_flush（new_buffer）new_timer = process .send_after（self（），：勾选，）{：noreply，％{[]，new_timer}} else {：noreply，％{state | new_buffer}}结束结束true def handle_info（：tick，％{buffer} = _state）do do_flush（buffer）timer = process .send_after（self（），：tick，）{：：noreply，％{[]，timer}}结束真实def handle_call（：flush，_from，％{buffer，timer} = _state）do进程.cancel_timer（timer）do_flush（beaffer）new_timer = process .send_after（self（），：tick，）{：回复，nil， ％{[]，new_timer}}结束try def tendine（_reason，％{buffer} = _state）do logger .info（＆＃34;关闭前刷新事件缓冲区...＆＃34;）do_flush（缓冲区）结束＃私人/实用方法DEFP DO_FLUSH（缓冲区）DO CASE BUFFER DO []  - ＆gt;零事件 - ＆gt; logger .info（＆＃34;刷新＃{长度（事件）}事件＆＃34;）events = enum .map（事件，＆amp;（map.from_struct（＆amp; 1）|＆gt;地图.delete（：__元__） ））合理的.clickhouseepo .insert_all（合理的.clickhouseEvent，活动）结束结束</p><p> Note: If you&#39;re able to read the code above and know  exactly what&#39;s going on at every step, you probably don&#39;t need to read any further!</p><p> 注意：如果您＆＃39;重新能够阅读上面的代码，并确切地知道每一步，你可能还要进一步阅读＆＃39;</p><p> Let&#39;s start off where the core of the logic actually lives: in the GenServer callbacks.</p><p> 让＆＃39; s开始逻辑的核心实际生活的核心：在Genserver回调中。 </p><p>   handle_call/3 - invoked when  GenServer.call/3 is called, to handle messages synchronously GenServer.call/3 will block until a reply is received (unless the call times out or nodes are disconnected)</p><p>句柄_call / 3  - 调用genserver.call/3时调用，同步处理消息genserver.call/3将阻止，直到收到回复（除非呼叫超时或节点断开连接）</p><p> handle_info/2 - invoked to handle all other messages (i.e. outside of those triggered by  GenServer.call/3 and  GenServer.cast/2, and  &#34;system&#34; messages)</p><p> handle_info / 2  - 调用以处理所有其他消息（即由Genserver.Call/3和Genserver.Cast / 2触发的那些邮件（即，和＃34;系统＆＃34;消息）</p><p>   The  init/1 callback is invoked when the GenServer is started, and handles setting the initial internal state of the server process.</p><p>   启动Genserver时调用init / 1回调，并处理设置服务器进程的初始内部状态。</p><p>   true  def init (buffer )  do Process .flag ( :trap_exit ,  true ) timer  = Process .send_after (self ( ) ,  :tick ,   )  { :ok ,  % {  buffer ,   timer } }  end</p><p>   true def init（缓冲区）do进程.flag（：trap_exit，true）timer = process .send_after（self（），：tick，）{：确定，％{buffer，timer}}结束</p><p> The first line of this method ( Process.flag(:trap_exit, true)) sets us up to &#34;trap exits&#34;. This allows us to handle any &#34;clean-up&#34; tasks before the process terminates, in the  terminate/2 callback. (We&#39;ll discuss this below!)</p><p> 此方法的第一行（process.flag（：trap_exit，true）设置我们最多＆＃34;陷阱退出＆＃34;这使我们能够处理任何＆＃34;清理＆＃34;在过程之前任务终止，在终止/ 2回调中。 （我们＆＃39; ll在下面讨论这个！）</p><p> Next, we set up a timer to run the  :tick event in 5 seconds ( @flush_interval_ms == 5_000). As we&#39;ll see below, this  :tick event also calls itself recursively, so that it effectively runs every 5 seconds while the server is alive. (That explains why it&#39;s called &#34;tick&#34;!)</p><p> 接下来，我们在5秒内设置一个计时器以在5秒内运行：勾选事件（@flush_interval_ms == 5_000）。当我们＆＃39; ll见下文，这个：勾选事件还要递归调用自己，以便在服务器活跃时有效地运行每5秒一次。 （这解释了为什么它＆＃39; s被叫＆＃34;勾选＆＃34 ;!）</p><p> Finally, we store the initial  buffer (in this case, an empty list, i.e.  []) and the  timer in the internal state.</p><p> 最后，我们存储初始缓冲区（在这种情况下，空列表，即内部状态中的计时器。 </p><p>     true  def handle_cast ( { :insert , event } ,  % {  buffer ,   timer }  = _state )  do new_buffer  =  [event  | buffer ]  if length (new_buffer )  &gt;=    do Logger .info ( &#34;Buffer full, flushing to disk&#34; ) Process .cancel_timer (timer ) do_flush (new_buffer ) new_timer  = Process .send_after (self ( ) ,  :tick ,   )  { :noreply ,  % {   [ ] ,   new_timer } }  else  { :noreply ,  % {state  |   new_buffer } }  end  end</p><p>True Def Handle_cast（{：插入，事件}，％{buffer，timer} = _state）do new_buffer = [事件|缓冲区]如果长度（new_buffer）＆gt; = do logger .info（＆＃34; buffer full，刷新到磁盘＆＃34;）进程.cancel_timer（timer）do_flush（new_buffer）new_timer = process .send_after（self（），：勾选，）{：noreply，％{[]，new_timer}} else {：noreply，％{state | new_buffer}}结束结束</p><p>  Inserting a new event into the internal state&#39;s  buffer, by prepending it to the list</p><p>  将新事件插入内部状态和＃39; s缓冲区，通过预先配置到列表</p><p> Checking if the buffer has reached capacity, and if so, sets up a new timer which will trigger the next automatic  flush in 5 seconds</p><p> 检查缓冲区是否已达到容量，如果是，请设置一个新的计时器，它将在5秒内触发下一个自动刷新</p><p> resets the internal state&#39;s  buffer to an empty list, and updates the timer as well</p><p> 将内部状态重置为空列表，并更新计时器</p><p> The reason this is handled in a  handle_cast/2 callback rather than a  handle_call/3 callback is so that the client can execute this asynchronously, without blocking on the completion of a potential  do_flush/1 method invocation. (As we&#39;ll see below, the &#34;flushing&#34;/saving of 10,000 events is a potentially expensive operation that could take a few seconds to complete.)</p><p> 此原因这在Handle_cast / 2回调中处理而不是hange_call / 3回调是为了使客户端可以异步执行，而不会在完成潜在DO_FLUSH / 1方法调用的情况下阻止。 （作为我们＆＃39; ll见下文，＆＃34;冲洗＆＃34; /挽救10,000个事件是一个可能需要几秒钟的潜在昂贵的操作。）</p><p> Let&#39;s take a quick look at the  do_flush/1 method to see what&#39;s going on there:</p><p> 让＆＃39;快速看看Do_Flush / 1方法，以查看那里的内容和＃39;</p><p> defp do_flush (buffer )  do  case buffer  do  [ ]  -&gt;  nil events  -&gt; Logger .info ( &#34;Flushing   #{length (events ) } events&#34; ) events  = Enum .map (events ,  &amp; (Map .from_struct ( &amp;1 )  |&gt; Map .delete ( :__meta__ ) ) ) Plausible .ClickhouseRepo .insert_all (Plausible .ClickhouseEvent , events )  end  end</p><p> defp do_flush（缓冲区）do case buffer do []  - ＆gt;零事件 - ＆gt; logger .info（＆＃34;刷新＃{长度（事件）}事件＆＃34;）events = enum .map（事件，＆amp;（map.from_struct（＆amp; 1）|＆gt;地图.delete（：__元__） ））合理的.clickhouterepo .insert_all（合理的.clickhouseEvent，活动）结束结束 </p><p> This method is just standard Elixir. All it&#39;s doing is taking the events in the buffer, formatting them into plain maps (rather than structs), and then persisting them to the database ( ClickHouse). (If we wanted a slightly more explicit name for this method, we could call it something like  save_to_clickhouse/1 instead.)</p><p>这种方法只是标准的elixir。所有＆＃39;正在做的是在缓冲区中取出事件，将它们格式化为纯地图（而不是结构），然后持续到数据库（点击屋）。 （如果我们想要这种方法稍微明确的名称，我们可以称之为save_to_clickhouse / 1。）</p><p> Note that if we wanted to save some whitespace, this could also be written like:</p><p> 请注意，如果我们想保存一些空格，这也可以写类似：</p><p> defp do_flush ( [ ] ) ,    nil  defp do_flush (events )  do Logger .info ( &#34;Flushing   #{length (events ) } events&#34; ) events  = Enum .map (events ,  &amp; (Map .from_struct ( &amp;1 )  |&gt; Map .delete ( :__meta__ ) ) ) Plausible .ClickhouseRepo .insert_all (Plausible .ClickhouseEvent , events )  end</p><p> defp do_flush（[]），nil defp do_flush（事件）do logger .info（＆＃34;刷新＃{length_ {lence}事件＆＃34;）events = enum .map（事件，＆amp;（map.from_struct（） ＆amp; 1）|＆gt;地图。地图.delete（：__ meta__）））合理的.clickhoutersepo .insert_all（合理的.clickhouseEvent，活动）结束</p><p>   The  handle_call/3 callback is invoked when  GenServer.call/3 is called, to handle synchronous messages. Note that  GenServer.call/3 will block until a reply is received (unless the call times out or nodes are disconnected).</p><p>   调用genserver.call/3时调用handle_call / 3回调，以处理同步消息。请注意，Genserver.Call/3将阻止，直到收到回复（除非呼叫超时或节点断开连接）。</p><p>   true  def handle_call ( :flush , _from ,  % {  buffer ,   timer }  = _state )  do Process .cancel_timer (timer ) do_flush (buffer ) new_timer  = Process .send_after (self ( ) ,  :tick ,   )  { :reply ,  nil ,  % {   [ ] ,   new_timer } }  end</p><p>   true def handle_call（：flush，_from，％{buffer，timer} = _state）do进程.cancel_timer（timer）do_flush（buffer）new_timer = process .send_after（self（），：tick，）{：回复，nil，％ {[]，new_timer}}结束</p><p> This code looks quite similar to the logic above, in the  handle_cast/2 callback. In this case, we&#39;re allow the  :flush event to be called manually, which takes whatever is currently in the state&#39;s  buffer and saves it to the database (in the  do_flush/1 method). Once again, the  buffer is reset to an empty list, and  timer is reset as well.</p><p> 此代码看起来非常类似于上面的逻辑，在Handle_cast / 2回调中。在这种情况下，我们＆＃39;重新允许手动调用：刷新事件，这需要当前处于状态和＃39; s缓冲区并将其保存到数据库（在do_flush / 1方法中）。再次，缓冲区将重置为空列表，并且还复位计时器。</p><p>  The  handle_info/2 callback is invoked to handle all other messages (i.e. outside of those triggered by  GenServer.call/3 and  GenServer.cast/2). In our case, we use it to handle messages passed around internally within the GenServer itself.</p><p>  调用handle_info / 2回调以处理所有其他消息（即由genserver.call/3和genserver.cest / 2触发的那些邮件）。在我们的情况下，我们使用它来处理内部在Genserver本身内部传递的消息。 </p><p>   true  def handle_info ( :tick ,  % {  buffer }  = _state )  do do_flush (buffer ) timer  = Process .send_after (self ( ) ,  :tick ,   )  { :noreply ,  % {   [ ] ,   timer } }  end</p><p>true def handle_info（：tick，％{buffer} = _state）do do_flush（buffer）timer = process .send_after（self（），：tick，）{：norecly，％{[]，timer}}结束</p><p> The  :tick handles flushing the events in our  buffer at a regular interval. (In this case, every 5 seconds.)</p><p> 答案：刻度处理在常规间隔中刷新我们缓冲区中的事件。 （在这种情况下，每5秒钟。）</p><p>   This callback is invoked when the server is about to exit, and can handle any clean-up tasks.</p><p>   当服务器即将退出时，可以调用此回调，并可以处理任何清理任务。</p><p>  true  def terminate (_reason ,  % {  buffer }  = _state )  do Logger .info ( &#34;Flushing event buffer before shutdown...&#34; ) do_flush (buffer )  end</p><p>  true def terminate（_reason，％{buffer} = _state）do logger .info（＆＃34;关闭前刷新事件缓冲区...＆＃34;）do_flush（缓冲区）结束</p><p> By trapping exists in the  init/1 callback above, we can ensure that before this GenServer process terminates, we flush anything that&#39;s left in our  buffer. Otherwise, we might end up in a situation where the process is terminated before some of the events in memory don&#39;t have a chance to get saved to the database, and would be lost.</p><p> 通过陷阱存在于上面的init / 1回调中，我们可以确保在此Genserver过程终止之前，我们互化的任何＆＃39;留在我们的缓冲区中。否则，我们可能会在内存中的一些事件之前终止进程的情况结束，其中有机会保存到数据库，并且会丢失。</p><p>   def start_link (_opts )  do GenServer .start_link (__MODULE__ ,  [ ] ,   __MODULE__ )  end  def insert (event )  do GenServer .cast (__MODULE__ ,  { :insert , event } )  { :ok , event }  end  def flush ( )  do GenServer .call (__MODULE__ ,  :flush ,  :infinity )  :ok  end</p><p>   def start_link（_opts）do genserver .start_link（__module__，[]，__module__）结束def插入（事件）do genserver .cast（__module__，{：插入，事件}）{：确定，事件}结束def flush（）do genserver .call（__module__，：flush，：无限）：ok结束</p><p>   This is probably the least intuitive of the three methods above — once we understand the code here, the rest should more or less fall into place.</p><p>   这可能是上面三种方法的最少直观 - 一旦我们理解这里的代码，其余的应该或多或少地到位。 </p><p>  As you might guess, the  start_link/1 method is responsible for, well, starting the GenServer process. All it&#39;s doing is calling  start_link/3 on  GenServer itself, with a few strange arguments:</p><p>正如您可能猜到的那样，start_link / 1方法是负责，嗯，启动Genserver进程。所有它＆＃39; s正在致电genserver本身上调用start_link / 3，有一些奇怪的参数：</p><p> __MODULE__, which is simply an alias for the module itself (in this case,  Plausible.Event.WriteBuffer). This first argument passes the  Plausible.Event.WriteBuffer in as the callback module, so that we can use the server callbacks we implemented above when certain messages are passed to the server process via  GenServer.call and  GenServer.cast. Note that calling  GenServer.start_link(Plausible.Event.WriteBuffer, [], name: Plausible.Event.WriteBuffer) would result in identical behavior. The main advantage of using  __MODULE__ is if we decide to rename the module, we only have to update it in one place!</p><p> __Module__，这只是模块本身的别名（在这种情况下，Plausible.Event.WriteBuffer）。此第一参数将Plausible.Event.Went.WriteBuffer作为回调模块，以便在通过Genserver.Call和Genserver.Cast传播到服务器进程时，我们可以使用我们在上面实现的服务器回调。请注意，调用genserver.start_link（plausible.event.writeBuffer，[]，名称：Plausible.Event.WriteBuffer）将导致相同的行为。使用__module__的主要优点是，如果我们决定重命名模块，我们只需要在一个地方更新它！</p><p> An empty list (i.e.  []) is passed in as the second argument. This is passed to our  init/1 callback as the default  buffer. We&#39;ll take a look at this in more detail below.</p><p> 空列表（即[]）作为第二个参数传递。这将传递给我们的init / 1回调作为默认缓冲区。我们＆＃39; ll在下面更详细地看一下这一点。</p><p> The last argument is a keyword list of options. Here, we assign the process a name with  name: __MODULE__ (which is the same as  name: Plausible.Event.WriteBuffer). This allows us to pass messages to the GenServer using the module name (i.e  GenServer.call(__MODULE__, message, timeout)/ GenServer.cast(__MODULE__, message)). Otherwise, after starting the GenServer, we would have to keep a reference to its process ID (or &#34;PID&#34;, which is returned in the  start_link/1 method), and then pass it in explicitly. (This is a very common practice.)</p><p> 最后一个参数是选项的关键字列表。在这里，我们为该过程分配名称：__module__（与名称相同：plausible.event.writeBuffer）。这允许我们使用模块名称（igenserver.call（__模块__，消息，超时）/ genserver.cest（__模块__，消息））传递给Genserver的消息。否则，在启动Genserver之后，我们必须继续参考其进程ID（或＆＃34; pid＆＃34;在start_link / 1方法中返回的pid＆＃34），然后明确传递它。 （这是一个非常常见的做法。）</p><p> (GenServer also has a method called simply  start/3, which takes the same arguments as  start_link/3 — the only difference is that  start_link/3 &#34;links&#34; the GenServer process to the current process, which is useful when we want to start the GenServer as part of a &#34;supervision tree&#34;. By starting a process with  start_link under a  Supervisor, it allows the application to monitor the process for any errors/crashes, and automatically restart the process if necessary.)</p><p> （Genserver还有一种称为sign start / 3的方法，它采用与start_link / 3相同的参数 - 唯一的区别是start_link / 3＆＃34;链接＆＃34; Genserver进程到当前过程，这是有用的我们希望将Genserver作为A＆＃34的一部分启动;通过在主管下使用Start_Link开始一个进程，它允许应用程序监视任何错误/崩溃的过程，并自动重新启动此过程必要的。）</p><p>   defmodule Plausible .Application  do  use Application  def start (_type , _args )  do children  =  [  # ... Plausible .Event .WriteBuffer ,  # ...  ] opts  =  [   :one_for_one ,   Plausible .Supervisor ]  # ... Supervisor .start_link (children , opts )  end  # ... end</p><p>   defmodule合理的。应用程序def start（_type，_args）do shopts = [＃...合理的..writebuffer，＃...] opts = [：one_for_one，plausible .supervisor]＃... supervisor .start_link （儿童，选择）结束＃...结束</p><p> GenServer&#39;s  start_link/3 method is what enables us to start the process under this  Supervisor. (When we include  Plausible.Event.WriteBuffer amongst the children of the supervisor, its  start_link/3 method is invoked automatically when  Supervisor.start_link/2 is called.)</p><p> Genserver＆＃39; s start_link / 3方法是让我们在此主管下启动过程。 （当我们包括Plausible.Event.Went.writeBuffer在主管的子女中，当调用Supervisor.Start_Link / 2时，会自动调用其Start_Link / 3方法。） </p><p> Hopefully at this point, we have a pretty good understanding of what&#39;s going on in  Plausible.Event.WriteBuffer.start_link/1! Now all that&#39;s left to cover are the two methods exposed in our client API:  insert/1 and  flush/0</p><p>希望在这一点上，我们非常了解在Plausible.event.writeBuffer.start_link / 1中进行的＆＃39; start.start_link / 1！现在，左盖上的所有这些都是我们的客户端API中暴露的两种方法：插入/ 1和Flush / 0</p><p>    Here we see that all this is doing is taking an  event and sending an asynchronous request to our GenServer via the  cast/2 method. (Since we&#39;re using  cast/2 here instead of  call/3, we know that this is a non-blocking call which will return immediately, regardless of what happens in the callback.)</p><p>    在这里，我们看到所有这些都在做一个事件并通过演员/ 2方法向我们的Genserver发送异步请求。 （因为我们在这里使用CAST / 2而不是呼叫/ 3，我们知道这是一个非阻塞呼叫，它将立即返回，无论在回调中发生什么。）</p><p> The first argument of  GenServer.cast/2 takes a process ID (i.e. PID) or a registered server name. In this case, we set the name to  __MODULE__ in the 3rd argument of our  GenServer.start_link/3 above, which is why we&#39;re using that here. (This is a very common practice with GenServers.)</p><p> Genserver.Cast / 2的第一个参数采用进程ID（即PID）或已注册的服务器名称。在这种情况下，我们将名称设置为__module__在我们的genserver.start_link / 3的第3个参数中，这就是为什么我们在这里使用它。 （这是Genservers的一种非常常见的做法。）</p><p> The second argument is the &#34;message&#34; we want to send, often in the form of a tuple or an atom. Here we&#39;re sending  {:insert, event}, which will be handled in the  handle_cast({:insert, event}, ...) callback discussed above.</p><p> 第二个论点是＆＃34;消息＆＃34;我们想常常以元度或原子的形式发送。在这里，我们发送{：插入，事件}，它将在上面讨论的Handle_cast（{：插入，事件}，...）回调中处理。</p><p> Since we don&#39;t wait for a return value, the  insert/1 method just returns an echo of the event that was passed in, in the form of  {:ok, event}.</p><p> 由于我们不等待返回值，因此插入/ 1方法刚刚返回传递的事件的回声，以{：确定，事件}的形式。</p><p>     GenServer.call/3, unlike  GenServer.cast/2, blocks the process until the callback completes. So if the  :flush event ends up taking 10 seconds to execute, the  flush/0 method will not return  :ok until 10 seconds have passed.</p><p>     Genserver.Call/3，与Genserver.Cast / 2不同，阻止该过程直到回调完成。因此，如果：刷新事件最终需要10秒钟才能执行，则刷新/ 0方法将不会返回：OK直到10秒过去。</p><p> call/3 takes a third argument, which we see here is  :infinity. This represents the maximum amount of time we allow the method to take before a timeout error occurs. By default, this is set to  5_000, or 5 seconds. By passing in  :infinity, we&#39;re allowing the process to take as long as it needs to complete.</p><p> 呼叫/ 3采取第三个论点，我们在这里看到了：无限。这代表了在发生超时错误之前允许该方法采取的最大时间。默认情况下，这设置为5_000或5秒。通过进入：无限，我们＆＃39;只要需要完成，就允许过程需要。 </p><p>  Let&#39;s take one last look at the full module definition, to double check that we understand everything that&#39;s going on. I&#39;ve added some comments in the code to help out a bit. 😉</p><p>让＆＃39;最后一看一下完整的模块定义，要仔细检查我们了解的一切＆＃39;我在代码中添加了一些评论来帮助解决一点。 😉</p><p> defmodule Plausible .Event .WriteBuffer  do  use GenServer  require Logger  # Flush/save every 5 seconds    5_000  # Allow a maximum of 10,000 events in our buffer list    10_000  ############################################################################  # Client APIs  ############################################################################    &#34;&#34;&#34; Starts a linked GenServer process, passing in the current module (`__MODULE__` == `Plausible.Event.WriteBuffer`) as both the callback module and the alias/name of the server process for future reference. We also pass in an empty list (`[]`) as the initial value of the internal state&#39;s `buffer` (handled in the `init/1` callback below). &#34;&#34;&#34;  def start_link (_opts )  do GenServer .start_link (__MODULE__ ,  [ ] ,   __MODULE__ )  end    &#34;&#34;&#34; Sends an `:insert` message asynchronously to the current module&#39;s GenServer process, which adds the provided `event` to the internal state&#39;s `buffer`. &#34;&#34;&#34;  def insert (event )  do GenServer .cast (__MODULE__ ,  { :insert , event } )  { :ok , event }  end    &#34;&#34;&#34; Sends a (synchronous) `:flush` message to the current module&#39;s GenServer process, which manually &#34;flushes&#34; all events in the internal state&#39;s `buffer` to the database. Sets the `timeout` option to `:infinity`, allowing this call to take as long as it needs to complete. &#34;&#34;&#34;  def flush ( )  do GenServer .call (__MODULE__ ,  :flush ,  :infinity )  :ok  end  ############################################################################  # Server callbacks  ############################################################################    &#34;&#34;&#34; Sets up the initial state of the GenServer, and traps exits so that we can gracefully handle a process termination in our `terminate/2` callback below. &#34;&#34;&#34;    true  def init (buffer )  do Process .flag ( :trap_exit ,  true ) timer  = Process .send_after (self ( ) ,  :tick ,   )  { :ok ,  % {  buffer ,   timer } }  end    &#34;&#34;&#34; Callback that handles `:insert` messages passed to `GenServer.cast/2`. In this callback, we add the new event to the internal state&#39;s `buffer`. If we reach the maximum capacity of the `buffer`, we &#34;flush&#34; it to the database and reset our state. Otherwise, we simply update the internal state with the updated `buffer`. &#34;&#34;&#34;    true  def handle_cast ( { :insert , event } ,  % {  buffer ,   timer }  = _state )  do new_buffer  =  [event  | buffer ]  if length (new_buffer )  &gt;=    do Logger .info ( &#34;Buffer full, flushing to disk&#34; ) Process .cancel_timer (timer ) do_flush (new_buffer ) new_timer  = Process .send_after (self ( ) ,  :tick ,   )  { :noreply ,  % {   [ ] ,   new_timer } }  else  { :noreply ,  % {state  |   new_buffer } }  end  end    &#34;&#34;&#34; Callback that handles internal `:tick` messages. In this callback, we automatically flush whatever is in the `buffer` every 5 seconds (i.e. `@flush_interval_ms`). &#34;&#34;&#34;    true  def handle_info ( :tick ,  % {  buffer }  = _state )  do do_flush (buffer ) timer  = Process .send_after (self ( ) ,  :tick ,   )  { :noreply ,  % {   [ ] ,   timer } }  end    &#34;&#34;&#34; Callback that handles `:flush` messages passed to `GenServer.call/3`. In this callback, we handle manually flushing whatever is currently in the internal state&#39;s `buffer` to the database. &#34;&#34;&#34;    true  def handle_call ( :flush , _from ,  % {  buffer ,   timer }  = _state )  do Process .cancel_timer (timer ) do_flush (buffer ) new_timer  = Process .send_after (self </p><p> DefModule合理的..Event .writeBuffer确实使用Genserver要求记录记录器＃每5秒5秒5秒5_000＃允许在我们的缓冲区列表中最多10,000个事件10_000 ################### ######################################## ########客户端API ################################## ###################################＆＃34;＆＃34;＆＃34;启动链接的Genserver进程，传递在当前模块（`__module__` =='plausible.fent.writebuuster`）作为回调模块和服务器进程的别名/名称，以便将来参考。我们还通过空列表（`[]`）作为内部状态的初始值＆＃39; s`缓冲区的初始值（在下面的`init / 1`回调中处理）。 ＆＃34;＆＃34;＆＃34; def start_link（_opts）do genserver .start_link（__module__，[]，__module__）结束＆＃34;＆＃34;发送到当前模块的“：INSERT`”消息，并将所提供的“事件”添加到内部状态和＃39; S“缓冲区”的Genserver进程中。 ＆＃34;＆＃34;＆＃34; def插入（事件）do genserver .cast（__module__，{：插入，事件}）{：好的，事件} End＆＃34;＆＃34;＆＃34;发送（同步）`：flush`：手动＆＃39; s的genserver过程，它手动＆＃34; flushes＆＃34;内部状态的所有事件＆＃39; s`缓冲区ob到数据库。将`: timeout`选项设置为`：Infinity`，只要需要完成此调用即可。 ＆＃34;＆＃34;＆＃34; def flush（）do genserver .call（__module__，：flush，：无穷大）：确定############################ #######################################服务器回调＃ ######################################## #########################＆＃34;＆＃34;＆＃34;设置Genserver的初始状态，陷阱退出，以便在下面的“终止/ 2”回调中优雅地处理流程终止。 ＆＃34;＆＃34;＆＃34; true def init（缓冲区）do进程.flag（：trap_exit，true）timer = process .send_after（self（），：tick，）{：确定，％{buffer，timer}} End＆＃34;＆＃34; ＆＃34;处理`：插入的呼叫传播到`genserver.cest / 2`。在此回调中，我们将新事件添加到内部状态和＃39; s`缓冲区。如果我们达到“缓冲区”的最大容量，我们＆＃34; Flush＆＃34;它到数据库并重置我们的州。否则，我们只需使用更新的`Buffer`更新内部状态。 ＆＃34;＆＃34;＆＃34; True Def Handle_cast（{：插入，事件}，％{buffer，timer} = _state）do new_buffer = [事件|缓冲区]如果长度（new_buffer）＆gt; = do logger .info（＆＃34; buffer full，刷新到磁盘＆＃34;）进程.cancel_timer（timer）do_flush（new_buffer）new_timer = process .send_after（self（），：勾选，）{：noreply，％{[]，new_timer}} else {：noreply，％{state | new_buffer}}结束＆＃34;＆＃34;＆＃34;处理内部`：勾号的回调。在此回调中，我们每5秒（即'@ flush_interval_ms`）自动互化`缓冲区填充＆＃34;＆＃34;＆＃34; true def handle_info（：tick，％{buffer} = _state）do do_flush（buffer）timer = process .send_after（self（），：tick，）{：noreply，％{[]，timer}}末端＆＃34; ＆＃34;＆＃34;处理`：刷新的消息传递给`genserver.call / 3`。在此回调中，我们处理目前内部状态的任何内容互化的东西＆＃39; s`缓冲区ob the数据库。 ＆＃34;＆＃34;＆＃34; true def handle_call（：flush，_from，％{buffer，timer} = _state）do process .cancel_timer（timer）do_flush（buffer）new_timer = process .send_after（self</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://papercups.io/blog/genserver">https://papercups.io/blog/genserver</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/genserver/">#genserver</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>