<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Pylo：几个Prolog引擎的Python前端</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Pylo：几个Prolog引擎的Python前端</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-21 00:07:47</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/98dc7dcc7c64dcbb78b63fb6fc5684d1.jpeg"><img src="http://img2.diglog.com/img/2020/10/98dc7dcc7c64dcbb78b63fb6fc5684d1.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>pylo is a Python front-end for several Prolog engines.It allows you to write your program once and execute it with different Prolog engines simply by switching the back-end.</p><p>Pylo是几个Prolog引擎的Python前端，它允许您只需切换后端，就可以编写一次程序并使用不同的Prolog引擎执行它。</p><p>    GNU Prolog (works only on OSX so far; GNNU PROLOG&#39;s foreign function interface does not compile properly on Linux)</p><p>GNU Prolog(到目前为止只能在OSX上运行；GNNU Prolog的外部函数接口在Linux上不能正确编译)。</p><p>       STEP 1:  pylo relies on ENV variables to detect which Prolog engines to support.The desired Prolog engines need to be installed first.</p><p>步骤1：Pylo依赖ENV变量来检测要支持的Prolog引擎。需要首先安装所需的Prolog引擎。</p><p> To install the support for  GNU Prolog, you need to provide the  GNUPROLOG_HOME variable pointing to the installation folder of GNU Prolog:</p><p>要安装对GNU Prolog的支持，您需要提供指向GNU Prolog安装文件夹的GNUPROLOG_HOME变量：</p><p>    To install the support for  XSB_PROLOG, you need to provide  XSB_HOME variable pointing to the source of XSB Prolog.This is the folder in which you unpacked the XSB source files.For example</p><p>要安装对XSB_PROLOG的支持，您需要提供指向XSB Prolog源代码的XSB_HOME变量。这是解压XSB源文件的文件夹。例如。</p><p>   FAQ README cmplib etc lib siteInstallXSB.jar admin config examples packages syslibLICENSE bin docs gpp prolog-commonsMakefile build emu installer prolog_includes</p><p>常见问题自述文件cmplib etc lib站点InstallXSB.jar管理配置示例软件包syglibLICENSE bin文档GPP prolog-commonsMakefile构建EMU安装程序prolog_include。</p><p> To install the support for  SWI Prolog, you need to provide  SWIPL_HOME variable pointing to the installation folder of SWIPL.On OSX, this looks like</p><p>要安装对SWI Prolog的支持，您需要提供指向SWIPL安装文件夹的SWIPL_HOME变量。在OSX上，如下所示。</p><p>       STEP 2: Clone this repository. You need to pull it recursively to get the submodules.</p><p>步骤2：克隆此存储库。您需要递归地提取它来获得子模块。</p><p>           To install the support for  GNU Prolog, you need to provide the path to the GNu-prolog&#39;s installation folder through the  GNU_LIB_PATH.For instance, using the default installation on OSX results in the following path</p><p>要安装GNU Prolog支持，您需要通过GNU_LIB_PATH提供GNU-Prolog安装文件夹的路径。例如，在OSX上使用默认安装会导致以下路径。</p><p>  To install the support for  XSB Prolog, you need to provide the path to the foreign interface library through the  XSB_LIB_PATH.To locate this folder, assume that  &lt;XSB_ROOT&gt; contains the folder in which the XSB source was unpacked.</p><p>要安装对XSB Prolog的支持，您需要通过XSB_LIB_PATH提供外部接口库的路径。要找到此文件夹，假定&lt；XSB_ROOT&gt；包含解压XSB源代码的文件夹。</p><p>  where  &lt;arch&gt; is the architecture of your system (it will be the only folder in  &lt;XSB_ROOT&gt;/config folder).</p><p>其中&lt；arch&gt；是系统的体系结构(它将是&lt；XSB_ROOT&&gt;；/config文件夹中的唯一文件夹)。</p><p> To install the support for  SWI Prolog, you need to provide the path to the SWIPL library through the  SWIPL_LIB_PATH.To find the right folder, look for the  lib/&lt;arch&gt; folder in the SWIPL installation folder ( &lt;arch&gt; is the architecture of you system).For instance, on OSX the EVN var should look like this</p><p>要安装对SWI Prolog的支持，您需要通过SWIPL_LIB_PATH提供SWIPL库的路径。要查找正确的文件夹，请在SWIPL安装文件夹中查找lib/&lt；Arch&&gt;文件夹(&lt；Arch&&gt;是您的系统的体系结构)。例如，在OSX上，EVN var应如下所示。</p><p>  STEP 2: Once the environment variables have been setup, you can install  pylo (and the desired Prolog engines) with the following commands</p><p>步骤2：设置环境变量后，可以使用以下命令安装Pylo(和所需的Prolog引擎。</p><p>    Important: due to the incompatibility of the compiling options, you cannot specify all three options at the same time.If you want to build the support for several Prolog engines, you have to compile the engines separately (with only one flag specified at the time).</p><p>重要提示：由于编译选项不兼容，您不能同时指定所有三个选项。如果要构建对多个Prolog引擎的支持，则必须分别编译引擎(当时仅指定一个标志)。</p><p> STEP 3: Once the compilation is done, make sure that the  build folder is accessible through the  PATH and  PYTHONPATH variables.</p><p>步骤3：编译完成后，确保可以通过PATH和PYTHONPATH变量访问Build文件夹。</p><p>  In order to use SWIPL, you need to provide a path to the dynamic library using the  LD_LIBRARY_PATH env var. For instance, on OSX</p><p>为了使用SWIPL，您需要使用LD_LIBRARY_PATH环境变量提供动态库的路径。例如，在OSX上</p><p>  For Ciao prolog, you also need to be able to find the dynamic library. On OSX</p><p>对于Ciao Prolog，您还需要能够找到动态库。关于OSX。</p><p>        To reduce the memory usage, constants, variables, functors and predicates should be constructed through context:</p><p>为了降低内存使用量，常量、变量、函数器和谓词需要通过上下文进行构造：</p><p>  If you want to use a proposition in a clause (a functor without arguments), like  a :- ..., create it as a  Predicate with arity 0.Be careful to construct clauses with literals, not structures.</p><p>如果您希望在子句中使用命题(不带参数的函数器)，如：-...，请将其创建为带编号0的谓词。请小心使用文字而不是结构来构建子句。</p><p>  Pylo allows you to conveniently specify the knowledge base and the query it with different prolog engines.All basic constructs (constants, variables, functors and predicates) should be created using the  global context (functions prefixed with  c_:  c_const,  c_pred,  c_var,  c_functor), which ensures that there are not duplicates.</p><p>Pylo允许您方便地指定知识库并使用不同的PROLOG引擎进行查询。所有基本结构(常量、变量、函数器和谓词)都应该使用全局上下文(函数以c_：c_const、c_pred、c_var、c_functor为前缀)创建，这样可以确保不会出现重复。</p><p> from  pylo  import  c_pred,  c_var,  c_const,  c_functor,  Atom,  Clause,  Conj,  Structure,  List # create some constants  luke  =  c_const( &#34;luke&#34;)  anakin  =  c_const( &#34;anakin&#34;) leia  =  c_const( &#34;leia&#34;) padme  =  c_const( &#34;padme&#34;) # create predicates father  =  c_pred( &#34;father&#34;,  2)  mother  =  c_pred( &#34;mother&#34;,  2) parent  =  c_pred( &#34;parent&#34;,  2) # create literals f1  =  Atom( father, [ anakin,  luke])  f2  =  Atom( father, [ anakin,  leia]) f3  =  Atom( mother, [ padme,  luke]) f4  =  Atom( mother, [ padme,  leia]) # create Variables X  =  c_var( &#34;X&#34;)  Y  =  c_var( &#34;Y&#34;) # create clauses  head  =  Atom( parent, [ X, Y])  body1  =  Atom( father, [ X, Y]) body2  =  Atom( mother, [ X, Y]) rule1  =  Clause( head,  Conj( body1)) rule2  =  Clause( head,  Conj( body2)) # create structures sabre  =  c_const( &#34;sabre&#34;) green  =  c_const( &#34;green&#34;) item  =  c_functor( &#34;item&#34;) struct  =  Structure( item, [ sabre,  green]) # create lists l  =  List([ padme,  leia,  1,  2,  3])</p><p>从Pylo import c_pred，c_var，c_const，c_functor，Atom，Clause，Conj，Structure，List#创建一些常量Luke=c_const(&#34；Luke&#34；)Anakin=c_const(&#34；Anakin&#34；)leia=c_const(&#34；leia&#34；)padme=c_const(&#34；padme&#34；)#create谓词父=c_pred(&#34；padme&#34；)。，2)MASTER=c_pred(&#34；MASTER&#34；，2)Parent=c_PRED(&#34；Parent&#34；，2)#创建文字f1=Atom(父亲，[阿纳金，卢克])f2=Atom(父亲，[阿纳金，莱娅])f3=Atom(母亲，[帕德梅，卢克])f4=Atom(母亲，[帕德梅，莱娅])#创建变量X=c_var(&#34；X&#34；)Y=c_var(&#34；Y&#34；)#CREATE子句Head=Atom(Parent，[X，Y])Body1=Atom(Parent，[X，Y])Body2=Atom(Move，[X，Y])rule1=Clause(Head，Conj(Body1))rule2=Clause(Head，Conj(Body2))#Create Structures sabre=c_const(&#34；sabre&#34；)green=c_const(&#34；green&#34；)Item=c_functor(&#34；Item&#34；)struct=Structure(Item，[sabre，green])#创建列表l=list([padme，leia，1，2，3])。</p><p> Such an explicit object-oriented way might be suited for automated construction of programs.Pylo also provides many convenient shortcuts for less tedious construction of knowledge bases.The above example could have been constructed in the following way</p><p>这种显式的面向对象的方法可能适合于程序的自动构建，Pylo还为知识库的构建提供了许多方便快捷的方式，上面的例子可以用下面的方式来构建。</p><p> from  pylo  import  c_pred,  c_const,  c_var,  c_functor,  List # construct predicates father  =  c_pred( &#34;father&#34;,  2) mother  =  c_pred( &#34;mother&#34;,  2) parent  =  c_pred( &#34;parent&#34;,  2) belongs_to  =  c_pred( &#34;belongs_to&#34;,  2) # create facts directly # applying the predicate symbol to terms/strings creates a literal # it also converts strings to the appropriate structures f1  =  father( &#34;anakin&#34;,  &#34;luke&#34;) f2  =  father( &#34;anakin&#34;,  &#34;leia&#34;) f3  =  mother( &#34;padme&#34;,  &#34;luke&#34;) f4  =  mother( &#34;padme&#34;,  &#34;leia&#34;) # create structures directly # applying the functor to a series of terms/strings creates a structure # it also knows how to convert strings to the right form item  =  c_functor( &#34;item&#34;,  2) struct  =  item( &#34;sabre&#34;,  &#34;green&#34;) f5  =  belongs_to( struct,  &#34;luke&#34;) # create list l  =  List([ &#34;padme&#34;,  &#34;leia&#34;,  1,  2,  3])  # if constants are numbers, just use python data structures # creating clauses rule1  =  parent( &#34;X&#34;,  &#34;Y&#34;)  &lt;=  father( &#34;X&#34;,  &#34;Y&#34;) rule2  =  parent( &#34;X&#34;,  &#34;Y&#34;)  &lt;=  mother( &#34;X&#34;,  &#34;Y&#34;)</p><p>从Pylo导入c_pred、c_const、c_var、c_functor，列表#构造谓词父项=c_pred(&#34；父项&#34；，2)母项=c_pred(&#34；母亲&#34；，2)父项=c_pred(&#34；父项&#34；，2)CLOSES_TO=c_PRED(&#34；CLOSES_TO&#34；，2)#直接创建事实#将谓词符号应用于术语/字符串创建文字#它还会将字符串转换为适当的结构f1=父亲(&#34；阿纳金&#34；，&#34；卢克&#34；)f2=父亲(&#34；阿纳金&#34；，&#34；莱娅&#34；)f3=母亲(&#34；padme&#34；，&#34；卢克&#34；)f4=母亲(&#34；padme&#34；，&#34；Leia&#34；))#直接创建结构#将函数器应用于一系列术语/字符串创建一个结构#它还知道如何将字符串转换为正确的格式Item=c_functor(&#34；Item&#34；，2)struct=Item(&#34；sabre&#34；，&#34；green&#34；)f5=Beles_to(struct，&#34；Luke&#34；)#create list l=list([&#34；padme&#34；，&#34；leia&#34；)#create list l=list([&#34；padme&#34；，&#34；leia&#34；)#create list l=list([&#34；padme&#34；，&#34；leia&#34；，1，2，3])#如果常量是数字，只需使用Python数据结构#Creating子句Rule 1=Parent(&#34；X&#34；，&#34；Y&#34；)&lt；=Parent(&#34；X&#34；，&#34；Y&#34；)rule2=Parent(&#34；X&#34；，&#34；Y&#34；)&lt；=母亲(&#34；X&#34；，&#34；Y&#34；)。Y&#34；)。</p><p>   from  pylo. engines  import  SWIProlog from  pylo. engines  import  XSBProlog from  pylo. engines  import  GNUProlog # Create GNU Prolog instance pl_gnu  =  GNUProlog() # create XSB Prolog # you need to provide the path pl_xsb  =  XSBProlog( &#34;[path to the XSB folder used in installation]&#34;) # create SWI Prolog # the path to SWIPL binary is optional if it corresponds pl_swi  =  SWIProlog( &#39;/usr/local/bin/swipl&#39;)</p><p>从皮洛寄来的。引擎从Pylo导入SWIProlog。引擎从Pylo导入XSBProlog。引擎导入GNUProlog#create GNU Prolog实例pl_gnu=GNUProlog()#create XSB Prolog#您需要提供路径pl_xsb=XSBProlog(&#34；[安装中使用的XSB文件夹的路径]&#34；)#create SWI Prolog#如果对应于pl_Swi=SWIProlog(&#39；/usr/local/bin/swpl&#39；)，则SWIPL二进制文件的路径是可选的。</p><p>  SWIProlog takes the path to the executable as an argument. If the path is standard, i.e. is  /usr/local/bin/swipl on OSX, no argument needs to be passed</p><p>SWIProlog将可执行文件的路径作为参数。如果路径是标准路径，即OSX上的路径为/usr/local/bin/swpl，则不需要传递任何参数。</p><p>  from  pylo  import  Prolog pl  =  Prolog() # consult file pl. consult( &#34;metagol.pl&#34;) # load module # Pylo does not provide a standardization of modules accross different engines # this means that it is your job to ensure that the correct mofule nam is provided  # # for instance, GNU prolog does not have modules # XSB Prolog needs to specify which predicates to load frm the library,  # this is provided as an extra names arguments &#39;predicates&#39;, which takes a list of predicates pl. use_module( &#34;library(lists)&#34;) # asserta a fact or a clause pl. asserta() # assertz a fact or a clause pl. assertz() # retract literal pl. retract() # check whether it is possible to satisfy a query # has_solution(...) can take any number of literals as an argument, which is interpreted as a conjunction pl. has_solution() # query all solutions # query(...) takes any number of literals as an input, which is interpreted as a conjuncion # it additionally takes &#39;max_solutions&#39; arguments, which can be used to limit the number of solutions to look for pl. query()</p><p>From pylo import prolog pl=prolog()#查询文件pl。Consult(&#34；metagol.pl&#34；)#load module#Pylo不提供跨不同引擎的模块的标准化#这意味着确保提供正确的模块名称是您的工作##例如，GNU Prolog没有模块#XSB Prolog需要指定要从库中加载哪些谓词，#这是作为额外的名称参数提供的，它接受谓词pl的列表。Use_module(&#34；library(List)&#34；)#断言事实或子句pl。Asserta()#断言事实或子句pl。Assertz()#撤销文字pl。Retract()#检查是否可能满足查询#HAS_Solution(...)。可以将任意数量的文字作为参数，该参数被解释为连接词pl。HAS_Solution()#查询所有解决方案#query(...)。接受任意数量的文字作为输入，它被解释为conjucion#它另外还接受&#39；max_Solutions&#39；参数，该参数可用于限制查找pl的解的数量。查询()。</p><p>  from  pylo. engines  import  XSBProlog from  pylo  import  c_pred  pl  =  XSBProlog( &#34;/Users/seb/Documents/programs/XSB&#34;) person  =  c_pred( &#34;person&#34;,  1) friends  =  c_pred( &#34;friends&#34;,  2) stress  =  c_pred( &#34;stress&#34;,  1) influences  =  c_pred( &#34;influences&#34;,  2) smokes  =  c_pred( &#34;smokes&#34;,  1) asthma  =  c_pred( &#34;asthma&#34;,  1) pl. assertz( person( &#34;a&#34;)) pl. assertz( person( &#34;b&#34;)) pl. assertz( person( &#34;c&#34;)) pl. assertz( friends( &#34;a&#34;,  &#34;b&#34;)) pl. assertz( friends( &#34;a&#34;,  &#34;c&#34;)) pl. assertz( stress( &#34;X&#34;)  &lt;=  person( &#34;X&#34;)) pl. assertz( influences( &#34;X&#34;,  &#34;Y&#34;)  &lt;=  person( &#34;X&#34;)  &amp;  person( &#34;Y&#34;)) pl. assertz( smokes( &#34;X&#34;)  &lt;=  stress( &#34;X&#34;)) pl. assertz( smokes( &#34;X&#34;)  &lt;=  friends( &#34;X&#34;,  &#34;Y&#34;)  &amp;  influences( &#34;Y&#34;,  &#34;X&#34;)  &amp;  smokes( &#34;Y&#34;)) pl. assertz( asthma( &#34;X&#34;)  &lt;=  smokes( &#34;X&#34;)) query_p  =  person( &#34;X&#34;) tv  =  pl. query( query_p) print( &#34;all persons: &#34;,  tv) query_f  =  friends( &#34;X&#34;,  &#34;Y&#34;) tv  =  pl. query( query_f) print( &#34;all friends: &#34;,  tv) query_st  =  stress( &#34;Y&#34;) tv  =  pl. query( query_st) print( &#34;all stressed people: &#34;,  tv) tv  =  pl. query( influences( &#34;X&#34;,  &#34;Y&#34;)) print( &#34;all influences: &#34;,  tv) tv  =  pl. query( smokes( &#34;X&#34;)) print( &#34;all smokers: &#34;,  tv) tv  =  pl. query( asthma( &#34;X&#34;),  max_solutions = 3) print( &#34;all asthma: &#34;,  tv)</p><p>从皮洛寄来的。引擎从Pylo导入XSBProlog导入c_pred pl=XSBProlog(&#34；/Users/Seb/Documents/Programs/XSB&34；)Person=c_pred(&#34；Person&#34；，1)Friends=c_pred(&#34；Friends&#34；，2)Stress=c_pred(&#34；Stress&#34；，1)Imffects=c_pred(&#34；Influence&#34；，2)Smokes=c_pred(&#34；Smokes&#34；；，1)哮喘=c_pred(&#34；哮喘&#34；，1)pl.。Assertz(人(&#34；a&#34；))pl.。Assertz(Person(&#34；b&#34；))pl.。Assertz(Person(&#34；c&#34；))pl.。Assertz(Friends(&#34；a&#34；，&#34；b&#34；))pl.。Assertz(Friends(&#34；a&#34；，&#34；c&#34；))pl.。Assertz(Stress(&#34；X&#34；)&lt；=Person(&#34；X&#34；))pl.。Assertz(影响(&#34；X&34；，&#34；Y&34；)&lt；=Person(&#34；X&34；)&amp；Person(&#34；Y&#34；))pl.。Assertz(Smokes(&#34；X&#34；)&lt；=Stress(&#34；X&#34；))pl.。Assertz(Smokes(&#34；X&34；)&lt；=Friends(&#34；X&34；，&#34；Y&34；)&amp；Influents(&#34；Y&#34；，&#34；X&34；)&amp；Smokes(&#34；Y&#34；))pl.。Assertz(哮喘(&#34；X&34；)&lt；=吸烟(&#34；X&34；))query_p=Person(&#34；X&#34；)TV=pl.。Query(Query_P)打印(&#34；所有人：&#34；，tv)query_f=Friends(&#34；X&#34；，&#34；Y&#34；)tv=pl.。Query(Query_F)print(&#34；all Friends：&#34；，tv)query_st=stress(&#34；Y&#34；)tv=pl.。Query(Query_St)打印(&#34；所有有压力的人：&#34；，tv)tv=pl。查询(影响(&#34；X&#34；，&#34；Y&#34；))打印(&#34；所有影响：&#34；，TV)TV=pl.。查询(Smokes(&#34；X&#34；))打印(&#34；所有吸烟者：&#34；，TV)TV=pl.。查询(哮喘(&#34；X&#34；)，max_Solutions=3)打印(&#34；所有哮喘：&#34；，TV)</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/sebdumancic/pylo2">https://github.com/sebdumancic/pylo2</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/引擎/">#引擎</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/prolog/">#prolog</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1030068.html"><img src="http://img2.diglog.com/img/2020/10/thumb_f8f5d529d35334f2fb264d19f656224e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030068.html">Python 3.9</a></div><span class="my_story_list_date">2020-10-20 22:48</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030063.html"><img src="http://img2.diglog.com/img/2020/10/thumb_ebba69f4297e762af60b8f98f2e4d95d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030063.html">PyInstrument-关注慢速部分的统计Python配置文件</a></div><span class="my_story_list_date">2020-10-20 22:46</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030062.html"><img src="http://img2.diglog.com/img/2020/10/thumb_febd33768c5e817e34a81b0bd750e291.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030062.html">CPython提速实施方案</a></div><span class="my_story_list_date">2020-10-20 22:46</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030052.html"><img src="http://img2.diglog.com/img/2020/10/thumb_8e77f040d37fd76761e6b57f203fb02c.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030052.html">Python中的模式匹配</a></div><span class="my_story_list_date">2020-10-20 22:41</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>