<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>关于帕克索斯的注记</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">关于帕克索斯的注记</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-05 02:01:06</div><div class="page_narrow text-break page_content"><p>These are my notes after learning the  Paxos algorithm.The primary goal here is to sharpen my own understanding of the algorithm, but maybe someone will find this explanation of Paxos useful!This post assumes fluency with mathematical notation.</p><p>这些是我在学习了Paxos算法后的笔记。这里的主要目标是加深我自己对该算法的理解，但也许有人会发现这个关于Paxos的解释很有用！这篇文章假设我对数学符号很熟练。</p><p> I must confess it took me a long time to understand distributed consensus.I’ve read a whole bunch of papers( Part Time Parliament, Paxos Made Simple, Practical BFT, In Search of an Understandable Consensus Algorithm, CASPaxos: Replicated State Machines without logs), but they didn’t make sense.Or rather, nothing specific was unclear, but, at the same time, I was unable to answer the core question:</p><p>我必须承认，我花了很长时间来理解分布式共识。我读了一大堆论文(在议会兼职期间，Paxos做了简单实用的BFT，寻找一个可以理解的共识算法，CASPaxos：没有日志的复制状态机)，但它们没有意义。或者说，没有什么具体的东西是不清楚的，但同时，我无法回答核心问题：</p><p>    The Paxos Algorithm or How to Win a Turing Award lecture (I can’t believe I actually was in St. Petersburg at that time and missed this!)</p><p>帕克索斯算法或如何赢得图灵奖讲座(我不敢相信我当时真的在圣彼得堡，错过了这个！)。</p><p> I now think that the thing is actually much simpler than it is made to believe :-)</p><p>我现在认为事情实际上比人们想象的要简单得多：-)。</p><p> Paxos is an algorithm for implementing distributed consensus.Suppose you have  N machines which communicate over a faulty network.The network may delay, reorder, and loose messages (it can not corrupt them though).Some machines might die, and might return later.Due to network delays, “machine is dead” and “machine is temporary unreachable” are indistinguishable.What we want to do is to make machines agree on some value.“Agree” here means that if some machine says “value is X”, and another machine says “value is Y”, then X necessary is equal to Y.It is OK for machine to answer “I don’t know yet”.</p><p>Paxos是一种实现分布式共识的算法。假设你有N台机器，它们在故障网络上通信。网络可能会延迟、重新排序和松散消息(尽管它不会破坏它们)。一些机器可能会死掉，可能会稍后返回。由于网络延迟，“机器死了”和“机器暂时无法到达”是无法区分的。我们要做的是让机器就某个值达成一致。这里的“同意”是指，如果一台机器说“值是X”，而另一台机器说“值是Y”，那么“机器死了”和“机器暂时无法到达”是无法区分的。我们要做的是让机器就某个值达成一致。这里的“同意”是指，如果一台机器说“值是X”，而另一台说“值是Y”，那么X必需等于Y。机器回答“我还不知道”是可以的。</p><p> The problem with this formulation is that Paxos is an elementary, but subtle algorithm.To understand it (at least for me), a precise, mathematical formulation is needed.So, let’s try again.</p><p>这个公式的问题是，Paxos是一个基本但微妙的算法。要理解它(至少对我来说)，需要一个精确的数学公式。所以，让我们再试一次。</p><p> What is Paxos?Paxos is a theorem about sets!This is definitely mathematical, and is true (as long as you base math on set theory), but is not that helpful.So, let’s try again.</p><p>什么是Paxos？Paxos是一个关于集合的定理！这绝对是数学的，而且是真的(只要你把数学建立在集合论的基础上)，但是没有什么帮助。所以，让我们再试一次。</p><p>  A system is characterized by a state.The system evolves in discrete steps: each step takes system from  state to  state&#39;.Transitions are non-deterministic: from a single current  s1, you may get to different next states  s2 and  s3.(non-determinism models a flaky network).An infinite sequence of system’s states is called a behavior:</p><p>系统的特征是一种状态。系统以离散的步骤演化：每一步都将系统从一个状态带到另一个状态。转变是不确定的：从一个当前的S1，你可能会到达不同的下一个状态S2和S3。(非决定论为一个松散的网络建模)。无限的系统状态序列被称为一种行为：</p><p>  Due to non-determinism, there’s a potentially infinite number of possible behaviors.Nonetheless, depending on the transition function, we might be able to prove that some condition is true for any state in any behavior.</p><p>由于非决定论，潜在的可能行为的数量是无限的，不朽的，依赖于转移函数，我们也许能够证明，对于任何行为中的任何状态，某些条件都是正确的。</p><p> Let’s start with a simple example, and also introduce some notation.I won’t use TLA+, as I don’t enjoy its concrete syntax.Instead, math will be set in monospaced unicode.</p><p>让我们从一个简单的例子开始，并介绍一些符号。我不会使用TLA+，因为我不喜欢它的具体语法。</p><p> The example models an integer counter.Each step the counter decrements or increments (non-deterministically), but never gets too big or too small</p><p>该示例对整数计数器进行建模。每一步计数器都会递减或递增(非确定性)，但不会变得太大或太小。</p><p> Sets: ℕ -- Natural numbers with zeroVars: counter ∈ ℕInit ≡ counter = 0Next ≡ (counter &lt; 9 ∧ counter&#39; = counter + 1) ∨ (counter &gt; 0 ∧ counter&#39; = counter - 1)Theorem: ∀ i: 0 ≤ counter_i ≤ 9-- Notation-- ≡: equals by definition-- ∧: &#34;and&#34;, conjunction-- ∨: &#34;or&#34;, disjunction</p><p>集合：ℕ--带零的自然数变量：Counter∈ℕInit≡Counter=0Next≡(Counter&lt；9∧Counter&#39；=Counter+1)∨(Counter&gt；0∧Counter&#39；=Counter-1)定理：∀I：0≤Counter_I≤9--NOTATION--≡：定义等于--∧：&#34；和&#34；，CONNECT-∨：&#34；或&#34；，析取。</p><p> The sate of the system is a single variable —  counter.It holds a natural number.In general, we will represent a state of any system by a fixed set of variables.Even if the system logically consists of several components, we model it using a single unified state.</p><p>系统的状态是一个单变量的 - 计数器，它包含一个自然数，通常我们会用一组固定的变量来表示任何系统的状态，即使系统在逻辑上由几个组件组成，我们也会用一个统一的状态对其进行建模。</p><p> The  Init formula specifies the initial state, the  counter is zero.Note that  = is a mathematical equality, and not an assignment. Init is a  predicate on states.</p><p>初始化公式指定初始状态，计数器为零。请注意=是数学等式，而不是赋值。Init是一个基于状态的谓词。</p><p>  Next defines a non-deterministic transition function.It is a predicate on pairs of states,  s1 and  s2. counter is a variable in the  s1 state,  counter&#39; is the corresponding variable in the  s2 state.In plain English, transition from  s1 to  s2 is valid if one of these is true:</p><p>下一步，定义了一个非确定性转移函数，它是关于状态对S1和S2的谓词。COUNTER是S1状态下的变量，COUNTER#39；是S2状态下的对应变量。简而言之，如果下列条件之一成立，则从S1到S2的转换是有效的：</p><p> Value of  counter in  s1 is less than  9 and value of  counter in  s2 is greater by 1.</p><p>S1中的COUNTER值小于9，S2中的COUNTER值大于1。</p><p> Value of  counter in  s1 is greater than  0, and value of  counter in  s2 is smaller by 1.</p><p>S1中的COUNTER值大于0，S2中的COUNTER值小于1。</p><p> Next is true for  ({counter: 5}, {counter: 6}).  Next is false for  ({counter: 5}, {counter: 5}).</p><p>NEXT对于({COUNTER：5}，{COUNTER：6})为真。NEXT对于({COUNTER：5}，{COUNTER：5})为FALSE。</p><p>  0 → 1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9</p><p>0→1→2→3→4→5→6→7→8→9。</p><p>  0 → 1 → 2 → 3 → 3 → 2 → 1 → 0</p><p>%0→%1→%2→%3→%3→%2→%1→%0。</p><p>  1 → 2 → 3 → 4 → 5:  Init does not hold for initial state</p><p>1→2→3→4→5：初始化不适用于初始状态。</p><p>  0 → 1 → 0 → -1:  Next does not hold for  (0, -1) pair</p><p>0→1→0→-1：Next不适用于(0，-1)对。</p><p> “behavior” means that the initial state satisfies  Init, and each transition satisfies  Next.</p><p>“行为”是指初始状态满足Init，然后每个转换都满足。</p><p> We can state and prove a theorem about this system: for every state in every behavior, the value of counter is between 0 and 9.Proof is by induction:</p><p>我们可以陈述并证明关于这个系统的一个定理：对于每个行为中的每个状态，计数器的值都在0到9之间。Proof是通过归纳法得出的：</p><p> If the condition is true for state  s1, and  Next holds for  (s1, s2), then the condition is true for  s2.</p><p>如果条件对于状态S1为真，并且接下来对于(S1，S2)成立，则条件对于S2为真。</p><p> As usual with induction, sometimes we would want to prove a  stronger property, because it gives us more powerful base for an induction step.</p><p>与通常的归纳法一样，有时我们会想要证明一个更强的性质，因为它为归纳法步骤提供了更强大的基础。</p><p> To sum up, we define a non-deterministic state machine using two predicates  Init and  Next. Init is a predicate on states which restricts possible initial states. Next is a predicate on  pairs of states, which defines a non-deterministic transition function. Vars section describes the state as a fixed set of typed variables. Sets defines auxiliary fixed sets, elements of which are values of variables. Theorem section specifies a predicate on behaviors:  sequences of steps evolving according to  Init and  Next.</p><p>总之，我们使用两个谓词Init和Next定义了一个非确定性状态机。Init是限制可能的初始状态的状态谓词。接下来是状态对上的谓词，它定义了一个非确定性的转移函数。Vars部分将状态描述为一组固定的类型化变量。集合定义辅助固定集合，其元素是变量的值。定理部分指定了关于行为的谓词：根据Init和Next演化的步骤序列。</p><p> The theorem does not automatically follow from  Init and  Next, it needs to be proven.Alternatively, we can simulate a range of possible behaviors on a computer and check the theorem for the specific cases.If the set of reachable states is small enough (finite would be a good start), we can enumerate  all behaviors and produce a brute force proof.If there are too many reachable states, we can’t prove the theorem this way, but we often can prove it to be wrong, by finding a counter example.This is the idea behind model checking in general and TLA+ specifically.</p><p>这个定理不会自动从Init和Next得到证明。或者，我们可以在计算机上模拟一系列可能的行为，并针对具体情况检查定理。如果可达状态集足够小(有限将是一个很好的开始)，我们可以枚举所有行为并产生暴力证明。如果可达状态太多，我们不能用这种方式证明定理，但我们通常可以通过找到反例来证明它是错误的。这就是我们的想法。如果可达状态太多，我们就不能用这种方式证明定理，但我们通常可以通过找到反例来证明它是错误的。这就是我们的想法：如果可达状态集足够小(有限将是一个好的开始)，我们可以列举所有行为并产生暴力证明。</p><p> Having mastered the basic vocabulary, let’s start slowly building towards Paxos.We begin with defining what consensus is.As this is math, we’ll do it using sets.</p><p>掌握了基本词汇后，让我们开始慢慢构建Paxos。我们首先定义共识是什么。因为这是数学，所以我们将使用集合来完成。</p><p> Sets: 𝕍 -- Arbitrary set of valuesVars: chosen ∈ 2^𝕍 -- Subset of valuesTheorem: ∀ i: |chosen_i| ≤ 1 ∧ ∀ i, j: i ≤ j ∧ chosen_i ≠ {} ⇒ chosen_i = chosen_j-- Notation-- {}: empty set-- 2^X: set of all subsets of X, powerset-- |X|: cardinality (size) of the set</p><p>集合：𝕍--任意值集合Vars：SELECTED∈2^𝕍--值子集定理：∀i：|SELECTED_I|≤1∧∀i，j：i≤j∧SELECTED_I≠{}⇒CHOSED_I=SELECTED_j--NOTATION--{}：空集--2^X：由X的所有子集组成的集合，幂集--|X|：集合的基数(大小。</p><p> The state of the system is a set of chosen values.For this set to constitute consensus (over time) we need two conditions to hold:</p><p>系统的状态是一组选定的值。要使这组值构成共识(随着时间的推移)，我们需要两个条件来满足：</p><p> if we choose a value at one point in time, we stick to it (math friendly: any two chosen values are equal to each other)</p><p>如果我们在某个时间点选择一个值，我们会坚持使用它(数学友好：任何两个选择的值都相等)</p><p>  Sets: 𝕍 -- Arbitrary set of valuesVars: chosen ∈ 2^𝕍 -- Subset of valuesInit ≡ chosen = {}Next ≡ chosen = {} ∧ ∃ v ∈ 𝕍: chosen&#39; = {v}Theorem: ∀ i: |chosen_i| ≤ 1 ∧ ∀ i, j: i ≤ j ∧ (chosen_i ≠ {} ⇒ chosen_i = chosen_j)</p><p>集合：𝕍--任意值集合Vars：SELECTED∈2^VARS--值子集Init≡SELECTED={}Next≡SELECTED={}∧∃v∈𝕍：SELECTED&#39；={v}定理：∀i：|SELECTED_i|≤1∧∀i，j：i≤j∧(SELECTED_I≠{}⇒SELECTED_i=SELECTED_j)。</p><p> In the initial state, the set of chosen values is empty.We can make a step if the current set of chosen values is empty, in which case we select an arbitrary value.</p><p>在初始状态下，选择的值集为空。如果当前选择的值集为空，我们可以执行一个步骤，在这种情况下，我们可以选择任意值。</p><p> This technically breaks our behavior theory: we require behaviors to be infinite, but, for this spec, we can only make a single step.The fix is to allow empty steps: a step which does not change the state at all is always valid.We call such steps “stuttering steps”.</p><p>这在技术上打破了我们的行为理论：我们要求行为是无限的，但对于这个规范，我们只能迈出一步。修复方法是允许空步骤：根本不改变状态的步骤总是有效的。我们称这样的步骤为“卡顿步骤”。</p><p> The proof of the first condition of the consensus theorem is a trivial induction.The proof of the second part is actually non-trivial, here’s a sketch.Assume that  i and  j are indices, which violate the condition.They might be far from each other in state-space, so we can’t immediately apply  Next.So let’s choose the  smallest  j1 ∈ [i+1;j] such that the condition is violated.Let  i1 = j1 - 1.The condition is still violated for  (i1, j1) pair, but this time they are subsequent steps, and we can show that  Next does not hold for them, concluding the proof.</p><p>一致性定理第一个条件的证明是一个平凡的归纳，第二部分的证明实际上是非平凡的，这里有一个示意图，假设i和j是违反条件的指标，它们在状态空间中可能相距很远，所以我们不能立即应用下一个条件，所以我们选择最小的J1∈[i+1；使得条件是违反的，设i1=j1-1，(i1，j1)对仍然违反条件，但这一次它们是后续步骤，我们可以证明下一步不适用于它们，从而得出证明。(i1，j1)对(i1，j1)对仍然违反条件，但这次是后续步骤，我们可以证明下一步不适用于它们，从而得出证明。</p><p> Let’s try to extend this to a truly distributed case, where we have  N machine (“acceptors”).We start with formalizing the naive consensus algorithm: let acceptors vote for values, and select the value which gets a majority of votes.</p><p>让我们尝试将其扩展到真正分布式的情况，其中我们有N台机器(“接受者”)，我们从形式化的朴素共识算法开始：让接受者为值投票，并选择获得多数选票的值。</p><p> Sets: 𝕍 -- Arbitrary set of values 𝔸 -- Finite set of acceptorsVars: votes ∈ 2^(𝔸×𝕍) -- Set of (acceptor, value) pairsInit ≡ votes = {}Next ≡ ∃ a ∈ 𝔸: ∃ v ∈ V: votes&#39; = votes ∪ {(a, v)} ∧ ∀ v ∈ V: (a, v) ∉ voteschosen ≡ {v ∈ V: |{a ∈ 𝔸: (a, v) ∈ votes}| &gt; |𝔸| / 2}</p><p>集合：𝕍--任意值集合𝔸--有限接受者集合Vars：Votes∈2^(𝔸×𝕍)--(接受者，值)对的集合Init≡Votes={}Next≡∃a∈𝔸：∃v∈V：Votes&#39；=Votes∪{(a，v)}∧∀v∈V：(a，v)∉voteselected≡{v∈V：|{a∈𝔸：(a，v)∈Votes}|&gt；|𝔸|/2}。</p><p> The state of the system is the set of all votes cast by all acceptors.We represent a vote as a pair of an acceptor and the value it voted for.Initially, the set of votes is empty.On each step, some acceptor casts a vote for some value (adds  (a, v) pair to the set of votes), but only if it hasn’t voted yet.Remember that  Next is a predicate on pairs of states, so we check  votes for existing vote, but add a new one to  votes&#39;.The value is chosen if the set of acceptors which voted for the value ( {a ∈ 𝔸: (a, v) ∈ votes}) is at least half as large as the set of all acceptors.In other words, if a majority of acceptors has voted for the value.</p><p>系统的状态是所有接受者投出的所有选票的集合。我们将一张选票表示为接受者和它所投的值的一对。最初，这组选票是空的。在每一步上，一些接受者为某个值投下一票(将(a，v)对加到这组选票中)，但前提是它还没有投票。请记住，NEXT是状态对上的谓词，所以我们检查现有选票的选票，但在选票中添加一个新的选票#39；如果投票支持该值的接受者集合({a∈𝔸：(a，v)∈Votes})至少是所有接受者集合的一半，则选择该值。换句话说，如果大多数接受者投票支持该值。</p><p>  Let’s prove consensus theorem for Majority Vote protocol.TYPE ERROR, DOES NOT COMPUTE.The consensus theorem is a predicate on behaviors of states consisting of  chosen variable.Here,  chosen isn’t a variable,  votes is! chosen is a function which maps current state to some boolean.</p><p>让我们证明多数投票协议的共识定理。类型错误，不竞争。共识定理是关于由选定变量组成的国家行为的谓词。这里，选定不是变量，选票是！SELECTED是一个将当前状态映射到某个布尔值的函数。</p><p> While it is intuitively clear what “consensus theorem” would look like for this case, let’s make this precise.Let’s  map states with  votes variable to states with  chosen variable using the majority rule,  f.This mapping naturally extends to a mapping between corresponding behaviors (sequences of steps):</p><p>虽然直观上很清楚这种情况下的“共识定理”是什么样子，但让我们来精确一下。让我们使用多数规则f将具有投票变量的状态映射到具有所选变量的状态。此映射自然扩展到相应行为(步骤序列)之间的映射：</p><p> f(votes_0 → votes_1 → ...)= f(votes_0) → f(votes_1) → ...= chosen_0 → chosen_1 → ...</p><p>F(Votes_0→Votes_1→...)=f(Votes_0)→f(Votes_1)→...=SELECTED_0→SELECTED_1→...。</p><p> Now we can precisely state that for every behavior  B of majority voting spec, the theorem holds for  f(B).This yields a better way to prove this!Instead of proving the theorem directly (which would again require i1, j1 trick), we prove that our mapping  f is a homomorphism.That is, we prove that if  votes_0 → votes_1 → …​ is a behavior of the majority voting spec, then  f(votes_0) → f(votes_1) → …​ is a behavior of the consensus spec.This lets us to re-use existing proof.</p><p>现在我们可以准确地说，对于多数投票规范的每一种行为B，定理对f(B)都成立。这提供了一种更好的证明方法！我们证明了我们的映射f是同态，而不是直接证明定理(这同样需要i1，j1技巧)。也就是说，我们证明了如果Votes_0→Votes_1→…。投票是多数投票规范的行为，然后是f(​_0)→f(Votes_1)→…。​是一种共识规范的行为，这让我们可以重用现有的证据。</p><p> The poof for initial step is trivial, but let’s spell it out just to appreciate the amount of details a human mind can glance through</p><p>最初的步骤是微不足道的，但让我们把它说清楚，只是为了欣赏人类大脑可以浏览的细节的数量。</p><p> f({votes: {}})= {chosen: {v ∈ V: |{a ∈ 𝔸: (a, v) ∈ {}}| &gt; |𝔸| / 2}}= {chosen: {v ∈ V: |{}| &gt; |𝔸| / 2}}= {chosen: {v ∈ V: 0 &gt; |𝔸| / 2}}= {chosen: {v ∈ V: FALSE}}= {chosen: {}}</p><p>F({∈：{}})={Choose：{v∈𝔸V：|{a∈：(a，v)∈{}}|&gt；|𝔸|/2}}={Choose：{v∈V：|{}|&gt；|𝔸|/2}}={Choose：{v∈V：0&gt；|𝔸|/2}}={Choose：{v∈V：False}}={Choose：{}}。</p><p> Let’s show that if Majority Vote’s  Next_m holds for  (votes, votes&#39;), then Consensus’s  Next_c holds for  (f(votes), f(votes&#39;)).There’s one obstacle on our way: this claim is false!Consider a case with three acceptors and two values:  𝔸 = {a1, a2, a3},  𝕍 = {v1, v2}.Consider these values of  votes and  votes&#39;:</p><p>让我们证明，如果多数票的next_m支持(Votes，Votes&39；)，那么共识的next_c支持(f(Votes)，f(Votes&39；))。我们前进的道路上有一个障碍：这个声明是错误的！考虑一个有三个接受者和两个值的情况：𝔸={a1，a2，a3}，𝕍={v1，v2}。考虑一下投票数和投票数的以下值：</p><p> votes = {(a1, v1), (a2, v1), (a1, v2)}votes&#39; = {(a1, v1), (a2, v1), (a1, v2), (a3, v2)}</p><p>投票={(a1，v1)，(a2，v1)，(a1，v2)}投票&#39；={(a1，v1)，(a2，v1)，(a1，v2)，(a3，v2)}。</p><p> If you just mechanically check  Next, you see that it works! a3 hasn’t cast its vote, so it can do this now.The problem is that  chosen(votes) = {v1} and  chosen(votes&#39;) = {v1, v2}.</p><p>如果你只是机械地检查下一步，你会发现它起作用了！A3还没有投票，所以现在可以投票了，问题是SELECTED(VORTS)={v1}和SELECTED(VORTS&#39；)={V1，V2}。</p><p> We are trying to prove too much! f works correctly only for states reachable from  Init, and the bad value of  votes where  a1 votes twice is not reachable.</p><p>我们试图证明的太多了！F仅适用于可从Init访问的州，并且无法访问A1投票两次的投票值错误。</p><p> So, we first should prove a lemma: each acceptor votes at most once.After that, we can prove  Next_m(votes, votes&#39;) = Next_c(f(votes), f(votes&#39;)) under the assumption of at most once voting.Specifically, if  |f(votes&#39;)| turns out to be larger than  1, then we can pick two majorities which voted for different values, which allows to pin down a single acceptor which voted twice, which is a contradiction.The rest is left as an exercise for the reader :)</p><p>因此，我们首先要证明一个引理：每个接受者至多投票一次。然后，我们可以在至多一次投票的假设下证明next_m(Votes，Votes&39；)=next_c(f(Votes)，f(Votes&39；))。具体地说，如果|f(Votes)|大于1，那么我们可以选择投票给不同值的两个多数，这样可以确定一个接受者投了两次票，这是一个矛盾的问题。剩下的就留给读者练习了：)，如果|f(Votes)|大于1，那么我们可以选择两个多数投票给不同的值，这样就可以确定一个接受者投了两次票，这是矛盾的。剩下的就留给读者练习了：)。</p><p> So, majority vote indeed implements consensus.Let’s look closer at the “majority” condition.It is clearly important.If we define  chosen as</p><p>因此，多数票确实实现了共识。让我们更仔细地看看“多数”条件。这显然很重要。如果我们将选择定义为。</p><p> chosen ≡ {v ∈ V: |{a ∈ 𝔸: (a, v) ∈ votes}| &gt; 0}</p><p>选择的≡{v∈V：|{a∈𝔸：(a，v)∈Votes}|&gt；0}。</p><p> then its easy to construct a behavior with several chosen values.The property of majority we use is that any two majorities have at least one acceptor in common.But any other condition with this property would work as well as majority.For example, we can assign an integer weight to each acceptor, and require the sum of weights to be more than half.As a more specific example, consider a set of for acceptors  {a, b, c, d}.</p><p>我们使用的多数属性是任何两个多数都有至少一个共同的接受者，但是任何其他具有此属性的条件也同样适用。例如，我们可以为每个接受者分配一个整数权重，并要求权重之和大于一半。作为一个更具体的例子，考虑一组for接受者{a，b，c，d}。在这个例子中，我们来看一下FOR接受者的集合{a，b，c，d}，例如，我们可以为每个接受者分配一个整数权重，并要求权重之和大于一半。作为一个更具体的例子，考虑一组for接受者{a，b，c，d}。</p><p>       Sets: 𝕍 -- Arbitrary set of values 𝔸 -- Finite set of acceptors ℚ ∈ 2^𝔸 -- Set of quorumsAssume: ∀ q1, q1 ∈ ℚ: q1 ∩ q2 ≠ {}Vars: votes ∈ 2^(𝔸×𝕍) -- Set of (acceptor, value) pairsInit ≡ votes = {}Next ≡ ∃ a ∈ 𝔸: ∃ v ∈ V: votes&#39; = votes ∪ {(a, v)} ∧ ∀ v ∈ V: (a, v) ∉ voteschosen ≡ {v ∈ V: ∃ q ∈ ℚ: AllVotedFor(q, v)}AllVotedFor(q, v) ≡ ∀ a ∈ q: (a, v) ∈ votes</p><p>集合：𝕍--任意值集合𝔸--有限接受者集合ℚ∈2^𝔸--仲裁集合假设：∀Q1，Q1∈ℚ：Q1∩Q2≠{}Vars：Votes∈2^(𝔸×𝕍)--(接受者，值)对集合Init≡Votes={}Next≡∃a∈𝔸：∃v∈V：Votes&#39；=Votes∪{(a，v)}∧∀v∈V：(a，v)∉Votes Choose≡{v∈V：∃q∈ℚ：AllVoted For(q，v)}AllVoted for(q，v)≡∀a∈q：(a，v)∈Votes。</p><p> We require to specify a set of quorums — set a of subsets of acceptors such that every two quorums have at least one acceptor in common.The value is chosen if there exists a quorum such that its every member voted for the value.</p><p>我们需要指定一组Quorum - Set a，它由接受者的子集组成，这样每两个Quorum至少有一个共同的接受者。如果存在一个Quorum，使得每个成员都投票支持该值，则选择该值。</p><p> There’s one curious thing worth noting here.Consensus is a property of the whole system, there’s no single “place” where we can point to and say “hey, this is it, this is consensus”.Imagine 3 acceptors, sitting on Earth, Venus, and Mars, and choosing between values  v1 and  v2.They can execute Quorum Vote algorithm without communicating with each other at all.They will necessary reach consensus without knowing which specific value they agreed on!An external observer can then travel to the three planets, collect the votes and discover the chosen value, but this feature isn’t built into the algorithm itself.</p><p>这里有一件奇怪的事情值得注意。Consensus是整个系统的属性，我们没有一个“地方”可以指着说“嘿，就是它，这就是共识”。想象3个接受者，坐在地球、金星和火星上，在v1和v2值之间进行选择，他们可以执行法定投票算法，而根本不需要相互沟通。他们必须在不知道他们同意的具体值的情况下达成共识！然后，外部观察者可以旅行到这三个行星，收集选票，发现选择的值，但这个功能并不是算法本身的组成部分。</p><p> OK, so we’ve just described an algorithm for finding consensus among  N machines, proved the consensus theorem for it, and noted that it has staggering communication efficiency:  zero messages.Should we collect our Turing Award?</p><p>好的，我们刚刚描述了一种在N台机器之间寻找共识的算法，证明了它的共识定理，并注意到它具有惊人的通信效率：零消息。我们应该领取图灵奖吗？</p><p> Well, no, there’s a big problem with Quorum Vote — it can get stuck.Specifically, if there are three values, and the votes are evenly split between them, then no value is chosen, and only stuttering steps are possible.If you can vote for different values, it might happen that neither value receives a majority of votes.Voting satisfies the safety property, but not the liveness property — the algorithm can get stuck even if all machines are on-line and communication is perfect.</p><p>嗯，不，Quorum Vote - 有一个很大的问题，它可能会被卡住。具体地说，如果有三个值，选票在它们之间平均分配，那么就不会选择任何值，只可能出现卡顿的步骤。如果你可以投票给不同的值，可能会出现两个值都得不到多数票的情况。投票满足安全属性，但不满足活性属性 - ，即使所有机器都在线并且通信完美，算法也可能会卡住。</p><p> There is a simple fix to the problem, with a rich historical tradition among many “democratic” governments.Let’s have a vote, and let’s pick the value chosen by the majority, but let’s allow to vote only for a single candidate value:</p><p>这个问题有一个简单的解决办法，在许多“民主”政府中有着丰富的历史传统。让我们进行投票，让我们选择多数人选择的值，但让我们只允许投票给单一的候选值：</p><p> Sets: 𝕍 -- Arbitrary set of values 𝔸 -- Finite set of acceptors ℚ ∈ 2^𝔸 -- Set of quorumsAssume: ∀ q1, q1 ∈ ℚ: q1 ∩ q2 ≠ {}Vars: votes ∈ 2^(𝔸×𝕍) -- Set of (acceptor, value) pairsInit ≡ votes = {}Next ≡ ∃ a ∈ 𝔸, v ∈ V: ∀ (a1, v1) ∈ votes: v1 = v ∧ votes&#39; = votes ∪ {(a, v)}chosen ≡ {v ∈ V: ∃ q ∈ ℚ: AllVotedFor(q, v)}AllVotedFor(q, v) ≡ ∀ a ∈ q: (a, v) ∈ votes</p><p>集合：𝕍--任意值集合𝔸--有限接受者集合ℚ∈2^𝔸--仲裁集合假设：∀Q1，Q1∈ℚ：Q1∩Q2≠{}Vars：Votes∈2^(𝔸×𝕍)--(接受者，值)对集合Init≡Votes={}Next≡∃a∈𝔸，v∈V：∀(a1，v1)∈Votes：v1=v∧Votes&#39；=Votes∪{(a，v)}Selected≡{v∈V：∃q∈ℚ：AllVoted For(q，v)}AllVoted For(q，v)≡∀a∈q：(a，v)∈Votes。</p><p> The new condition says that an acceptor is only allowed to cast a vote if all other votes are for the same value.As a special case, if the set of votes is empty, the acceptor can vote for any value (but all other acceptors would have to vote for this value afterwards).</p><p>新的条件规定，只有在所有其他票数都相同的情况下，接受者才能投票。作为特例，如果票数为空，接受者可以投票支持任何值(但所有其他接受者随后都必须投票支持该值)。</p><p> From a mathematical point of view, this algorithm is perfect.From a practical stand point, not so much: an acceptor to cast the first vote somehow needs to make sure that it is indeed the first one.The obvious fix to this problem is to assign a unique integer number to each acceptor, call the highest-numbered acceptor “leader”, and allow only the leader to cast the first decisive vote.</p><p>从数学的角度看，这个算法是完美的。从实用的角度来看，并非如此：接受人投第一票需要以某种方式确保它确实是第一票。这个问题的明显解决办法是给每个接受人分配一个唯一的整数，称人数最多的接受人为“领先者”，只允许领先者投第一张决定性的一票。</p><p> So acceptors first communicate with each other to figure out who the leader is, then the leader casts the vote, and the followers follow.But this also violates liveness: if the leader dies, then the followers would wait indefinitely.A fix for this problem is to let the second highest acceptor to take over the leadership if the leader perishes.But under our assumptions, it’s impossible to distinguish between a situation when the leader is dead from a situation when it just has a  really bad internet connection.So naively picking successor would lead to a split vote and a standstill again (power transitions are known to be problematic for authoritarian regimes in real life too!).If only there were some kind of …​ distributed consensus algorithm for picking the leader!</p><p>因此，接受者首先相互沟通，弄清楚谁是领导者，然后领导者投票，追随者跟随。但这也违反了活跃性：如果领导者死亡，追随者就会无限期地等待。解决这个问题的一个办法是，如果领导者死亡，让第二高接受者接管领导权。但在我们的假设下，很难将领导人去世的情况与网络连接非常糟糕的情况区分开来。因此，天真地选择继任者会导致分裂投票和再次停滞不前(众所周知，权力交接在现实生活中对威权政权也是有问题的！)。如果有某种形式的…就好了。​分布式协商选出领袖算法！</p><p> This is the place were we start discussing real Paxos :-)It starts with a “ballot voting” algorithm.This algorithm, just like the ones we’ve already seen, does not define any messages.Rather, message passing is an implementation detail, so we’ll get to it later.</p><p>这是我们开始讨论真正的Paxos的地方：-)它从“投票投票”算法开始。这个算法和我们已经看到的算法一样，没有定义任何消息。相反，消息传递是一个实现细节，所以我们稍后再讨论它。</p><p> Recall that rigged voting requires all acceptors to vote for a single values.It is immune to split voting, but is susceptible to getting stuck when the leader goes offline.The idea behind ballot voting is to have many voting rounds, ballots.In each ballot, acceptors can vote only for a single value, so each ballot individually can get stuck.However, as we are running many ballots, some ballots will make progress.The value is chosen in a ballot if it is chosen by some quorum of acceptors.The value is chosen in an overall algorithm if it is chosen in some ballot.</p><p>回想一下，舞弊投票要求所有接受者投票给单一的值。它不受分开投票的影响，但当领先者脱机时容易被卡住。抽签背后的想法是有许多轮投票，即抽签。在每一轮投票中，接受者只能投票给单一的值，所以每一票都可能被卡住。但是，由于我们正在进行多轮投票，有些选票会取得进展。如果值是由一定的法定人数选择的，那么它就是在投票中选出的。如果值是在某些选票中选出的，那么它就是在一个整体的算法中选出的，如果它是在一些选票中选出的，那么它就是在一个整体的算法中选出的。</p><p> The Turing award question is: how do we make sure that no two ballots choose different values?Note that it is OK if two ballots choose the same value.</p><p>图灵奖的问题是：我们如何确保没有两个选票选择不同的值？请注意，如果两个选票选择相同的值也是可以的。</p><p> Let’s just brute force this question, really.First, assume that the ballots are ordered (for example, by numbering them with natural numbers).And let’s say we want to pick some value  v to vote for in ballot  b.When  v is safe?Well, when no other value  v1 can be chosen by any other ballot.Let’s tighten this up a bit.</p><p>让我们真的粗暴地强行回答这个问题。首先，假设选票是有序的(例如，用自然数编号)。假设我们想要在选票b中选择某个值v来投票。什么时候v是安全的？好的，当其他任何选票都不能选择其他值v1时。让我们把这个限制得更紧一些。</p><p> Value  v is safe at ballot  b if any smaller ballot  b1 ( b1 &lt; b) did not choose and will not choose any value other than  v.</p><p>如果任何较小的选票b1(b1&lt；b)没有选择也不会选择除v之外的任何值，则值v在选票b处是安全的。</p><p> So yeah, easy-peasy, we  just need to predict which values will be chosen in the future, and we are done!We’ll deal with it in a moment, but let’s first convince ourselves that, if we only select safe values for voting, we won’t violate consensus spec.</p><p>所以，简单地说，我们只需要预测未来将选择哪些价值观，我们就完成了！我们稍后会处理这个问题，但让我们首先说服自己，如果我们只选择安全的价值观进行投票，我们就不会违反共识规范。</p><p> So, when we select a safe value  v to vote for in a particular ballot, it might get chosen in this ballot.We need to check that it won’t conflict with any other value.For smaller ballots that’s easy — it’s the definition of safety condition.What if we conflict with some value  v1 chosen in a future ballot?Well, that value is also safe, so whoever chose  v1, was sure that it won’t conflict with  v.</p><p>所以，当我们在某一次投票中选择一个安全值v时，它可能会在这次投票中被选中。我们需要检查它是否不会与任何其他值冲突。对于较小的选票，这很容易 - ，这是安全条件的定义。如果我们与将来投票中选择的某个值v1发生冲突怎么办？嗯，这个值也是安全的，所以无论谁选择了v1，都肯定它不会与v冲突。</p><p> How do we tackle the precognition problem?We’ll ask acceptors to commit to  not voting in certain ballots.For example, if you are looking for a safe value for ballot  b and know that there’s a quorum  q such that each quorum member never voted in smaller ballots, and promised to never vote in smaller ballots, you can be sure that any value is safe.Indeed, any quorum in smaller ballots will have at least one member which would refuse to vote for any value.</p><p>我们如何解决预知问题？我们将要求接受者承诺不在某些选票中投票。例如，如果你正在寻找一个安全的b选票值，并且知道有一个法定人数Q，这样每个法定人数成员从未在较小的选票中投票，并且承诺永远不会在较小的选票中投票，你可以确定任何值都是安全的。事实上，任何较小选票中的任何法定人数都将至少有一个成员拒绝投票给任何值。</p><p> Ok, but what if there’s some quorum member which has already voted for some  v1 in some ballot  b1 &lt; b?(Take a deep breath, the next sentence is the kernel of the core idea of Paxos).Well, that means that  v1 was safe at  b1, so, if there will be no votes between  b1 and  b,  v1 is also safe at  b!(Exhale).In other words, to pick a safe value at  b we:</p><p>好的，但是如果有一些法定成员已经在一些选票b1和b中投票给了某个v1呢？(深呼吸，下一句话是Paxos核心思想的核心)。嗯，这意味着v1在b1是安全的，所以，如果b1和b之间没有选票，v1在b！(呼气)也是安全的。换句话说，要在b选择一个安全值，我们：</p><p> Among all of the votes already cast by the quorum members we pick the one with the highest ballot number.</p><p>在法定人数成员已经投出的所有选票中，我们选择得票数最高的一张。</p><p> To implement the “never vote” promise, each acceptor will maintain  maxBal value.It will never vote in ballots smaller or equal to  maxBal.</p><p>为了实现“永不投票”的承诺，每个接受者将保持maxBal值，永远不会在小于或等于maxBal的选票中投票。</p><p> Let’s stop hand-waving and put this algorithm in math.Again, we are not thinking about messages yet, and just assume that each acceptor can observe the state of the whole system.</p><p>让我们停止挥手，把这个算法付诸数学。另外，我们还没有考虑消息，只是假设每个接受者都可以观察整个系统的状态。</p><p> Sets: 𝔹 -- Numbered set of ballots (for example, ℕ) 𝕍 -- Arbitrary set of values 𝔸 -- Finite set of acceptors ℚ ∈ 2^𝔸 -- Set of quorumsAssume: ∀ q1, q1 ∈ ℚ: q1 ∩ q2 ≠ {}Vars: -- Set of (acceptor, ballot, value) triples votes ∈ 2^(𝔸×𝔹×𝕍) -- Function that maps acceptors to ballot numbers or -1. -- maxBal :: 𝔸 -&gt; 𝔹 ∪ {-1} maxBal ∈ (𝔹 ∪ {-1})^𝔸Voted(a, b) ≡ ∃ v ∈ 𝕍: (a, b, v) ∈ votesSafe(v, b) ≡ ∃ q ∈ ℚ: ∀ a ∈ q: maxBal(a) ≥ b - 1 ∧ ∃ b1 ∈ 𝔹 ∪ {-1}: ∀ b2 ∈ [b1+1; b-1], a ∈ q: ¬Voted(a, b2) ∧ b1 = -1 ∨</p><p>集合：𝔹--编号的选票集合(例如，ℕ)𝕍--任意值集合𝔸--接受者的有限集合ℚ∈2^𝔸--仲裁集合假设：∀Q1，Q1∈ℚ：Q1∩Q2≠{}Vars：--(接受者，选票，值)三重投票集合∈2^(𝔸×𝔹×𝕍)--将接受者映射到选票编号或-1的函数。--MAXBAL：：𝔸-&gt；𝔹∪{-1}MaxBal∈(𝔹∪{-1})^𝔸Vote(a，b)≡∃v∈𝕍：(a，b，v)∈votesSafe(v，b)≡∃q∈ℚ：∀a∈q：maxBal(A)≥b-1∧∃b1∈𝔹∪{-1}：∀b2∈[b1+1；B-1]，a∈q：，投票(a，b2)∧b1=-1∨。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://matklad.github.io/2020/11/01/notes-on-paxos.html">https://matklad.github.io/2020/11/01/notes-on-paxos.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/克索斯/">#克索斯</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/notes/">#notes</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/投票/">#投票</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>