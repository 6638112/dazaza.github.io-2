<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从键盘快捷键中获得智慧Gaining Bitwisdom from Keyboard Shortcuts</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Gaining Bitwisdom from Keyboard Shortcuts<br/>从键盘快捷键中获得智慧</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-21 05:50:53</div><div class="page_narrow text-break page_content"><p>Managing keyboard shortcuts in JavaScript/TypeScript is a real shitshow.Let&#39;s say you have the following keyboard shortcuts (assuming you&#39;re on macOS):</p><p>在JavaScript/TypeScript中管理键盘快捷键真是一件糟糕的事情。让&#39；假设你有以下快捷键（假设你在macOS上）：</p><p>   document . addEventListener ( &#34;keydown&#34; ,  (event : KeyboardEvent )  =&gt;  {  if  ( event .metaKey  &amp;&amp;  !event .altKey  &amp;&amp;  !event .ctrlKey  &amp;&amp;  !event .shiftKey  &amp;&amp; event .code  ===  &#34;KeyL&#34;  )  {  doThingA ( ) ;  }  if  ( event .metaKey  &amp;&amp; event .ctrlKey  &amp;&amp;  !event .altKey  &amp;&amp;  !event .shiftKey  &amp;&amp; event .code  ===  &#34;KeyL&#34;  )  {  doThingB ( ) ;  }  if  ( event .metaKey  &amp;&amp; event .ctrlKey  &amp;&amp; event .shiftKey  &amp;&amp;  !event .altKey  &amp;&amp; event .code  ===  &#34;KeyL&#34;  )  {  doThingC ( ) ;  } } ) ;</p><p>文件addEventListener（&#34；keydown&#34；，（事件：KeyboardEvent）=&gt；{if（event.metaKey&amp；！event.altKey&amp；！event.ctrlKey&amp；！event.shiftKey&amp；&amp；event.code===&amp#34；KeyL&amp#34；）{doThingA（）；}if（event.metaKey&amp；event.ctrlKey&amp；event.altKey&amp；event.shiftKey&amp；event.code===&amp；34；KeyL&amp；34；）{doThingB（）；}if（event.metaKey&amp；event.ctrlKey&amp；event.shiftKey&amp；event.altKey&amp；event.code===&amp；34；KeyL&amp；34；）{doThingC（）；}}）；</p><p>  document . addEventListener ( &#34;keydown&#34; ,  (event : KeyboardEvent )  =&gt;  {  if  (event .metaKey  &amp;&amp;  !event .altKey  &amp;&amp; event .code  ===  &#34;KeyL&#34; )  {  if  (event .ctrlKey )  {  if  (event .shiftKey )  {  doThingC ( ) ;  }  else  {  doThingB ( ) ;  }  }  else  {  doThingA ( ) ;  }  } } ) ;</p><p>文件addEventListener（&#34；keydown&#34；，（事件：KeyboardEvent）=&gt；{if（event.metaKey&amp；！event.altKey&amp；&amp；&amp；event.code===&amp#34；KeyL&amp#34；）{if（event.ctrlKey）{if（event.shiftKey）{doThingC（）；}else{doThingB（）；}else{doThingA（）；}}}）；</p><p> So your choices out-of-the-box are to make it confusing or make it verbose.Good news! It turns out there&#39;s a third option: bit flags.</p><p>因此，你的开箱即用的选择是让它变得混乱或冗长。好消息！结果是&#39；第三个选项：位标志。</p><p> I needed to add quite a few keyboard shortcuts to a side project I&#39;m working on, so I implemented my own little keyboard shortcut library using bit flags.My esteemed colleague, Matt Mayhem (of  Bad Shadows and  No Tomorrow Boys fame),was reviewing my pull request and wanted to know what the hell was going on with all the  &amp; and  | operators, so that is why this post exists.</p><p>我需要在一个辅助项目I&#39；我正在工作，所以我用位标志实现了自己的小键盘快捷键库。我尊敬的同事马特·梅希姆（Matt Mayhem，饰演坏阴影，没有明日男孩的名声）正在审查我的拉车请求，想知道所有的&amp；和|操作员，这就是这个帖子存在的原因。</p><p> Before I dig into bit shifting, bit flags, and bitwise operators, let&#39;s all hop on the trolley to Binary Junction to talk about base-2 numbers.</p><p>在深入研究位移位、位标志和位运算符之前，让&#39；Let’我们都跳上小车去二进制交叉点，谈谈基数为2的数字。</p><p>  Most of us operate in the  base-10 (or  decimal) universe, which I&#39;m too lazy to explain, so  I&#39;ll let someone else do it. Binary numbers are expressed in the  base-2 numeral system, which is just a fancy way of saying it only uses two symbols:  0 and  1.</p><p>我们中的大多数人都在以10为基数（或十进制）的宇宙中工作，我&#39；我懒得解释，所以我&#39；我会让别人做的。二进制数用2进制表示，这只是一种花哨的说法，表示它只使用两个符号：0和1。</p><p> I&#39;ll be using the terms  base-10 and  decimal interchangeably, but they refer to the same thing.</p><p>我&#39；我将交替使用10进制和十进制，但它们指的是同一件事。</p><p> Counting in binary is a little weird, so let&#39;s talk about that weirdness.We&#39;re going to use JavaScript&#39;s   parseInt() function to get the decimal representation of a binary number.The first argument is the binary number string and the second is the radix. To get the decimal value, I&#39;m using a radix of  2 (for base- 2 number system).</p><p>二进制计数有点奇怪，所以让&#39；让我们来谈谈这种奇怪。我们&#39；我们将使用JavaScript&#39；s parseInt（）函数以获取二进制数的十进制表示形式。第一个参数是二进制数字符串，第二个参数是基数。要获得十进制值，I&#39；m使用基数为2（对于基数为2的数字系统）。</p><p>   If you guessed  5, buy yourself a drink! If  101 =  5 sounds like bullshit to you, bear with me.You count binary from  right to left. As you move from right to left, the decimal representation of that bit is:</p><p>如果你猜到了5，给自己买杯饮料吧！如果你觉得101=5听起来像胡说八道，请容忍我。从右到左计算二进制数。从右向左移动时，该位的十进制表示为：</p><p>  You find the decimal value for each bit and add them all up. So here&#39;s how you turn  101 into  5:</p><p>找到每一位的十进制值，然后将它们相加。所以这里&#39；这就是把101变成5的方法：</p><p>  That right-most column represents the decimal value of each bit.Since the 0th and 2nd bits are  1, you multiply  1 by 2⁰ ( 1) and 2² ( 4) respectively and add them up to get  5.</p><p>最右边的那一列代表每一位的十进制值。因为第0位和第2位是1，所以将1乘以2⁰ （1）和2²（4），将它们相加得到5。</p><p> JavaScript uses  32-bit signed integers for bitwise operations.That means that any bit-twiddling under the hood operates on binary numbers that look like this:</p><p>JavaScript使用32位有符号整数进行逐位操作。这意味着任何在引擎盖下旋转的位都会对二进制数进行操作，如下所示：</p><p>  I can save you some time spent counting and assure you that there are 32x  1s in that number.Each  1 represents a bit, which is where &#34;32-bit&#34; comes from.A 32-bit  signed integer has a minimum value of  -2147483648 and a maximum value of  2147483647.But if you were to run this:</p><p>我可以为你节省一些计算时间，并向你保证这个数字是32x1。每个1代表一个位，即&#34；32位&#34；来自。32位有符号整数的最小值为-2147483648，最大值为2147483647。但如果你要运行这个：</p><p>  It logs out  4294967295. How the hell can you get all the way up to  4294967295?Well that&#39;s easy, the very first bit is the &#34;sign bit&#34; (and the  most significant bit), so flipping it to  1 makes the number  unsigned.Since we&#39;re no longer dealing with negative numbers, we just shimmy everything over by  2147483648.The minimum of  -2147483648 becomes  0, and the maximum of  2147483647 becomes  4294967295.</p><p>它注销了4294967295。你怎么能一直到4294967295？那&#39；这很简单，第一位是&#34；符号位&#34；（以及最高有效位），因此将其翻转为1会使数字无符号。自从我们&#39；我们不再处理负数了，我们只是把所有的数据都加上2147483648。最小值-2147483648变为0，最大值2147483647变为4294967295。</p><p>   Now that you have a better understanding of binary numbers (hopefully), let&#39;s rap about bit shifting and bit flags.</p><p>既然你对二进制数有了更好的理解（希望如此），那就让&#39；s关于位移位和位标志的说唱。</p><p>  We need to represent the four modifier keys as bit flags. I&#39;m using TypeScript here, so I&#39;m going to use an  enum.I&#39;m also using Electron and this application only runs on macOS, so I&#39;m going to represent each modifier in the macOS parlance.</p><p>我们需要将四个修改键表示为位标志。我&#39；我在这里使用打字脚本，所以我&#39；我将使用枚举。我&#39；我也使用Electron，这个应用程序只在macOS上运行，所以我&#39；我将用macOS术语来表示每个修饰语。</p><p> enum Mod  { Command  =  1  &lt;&lt;  1 ,  // 2 in base-10 Control  =  1  &lt;&lt;  2 ,  // 4 in base-10 Option  =  1  &lt;&lt;  3 ,  // 8 in base-10 Shift  =  1  &lt;&lt;  4 ,  // 16 in base-10 }</p><p>枚举Mod{Command=1&lt；&lt；1，//2在base-10控件中=1&lt；&lt；2，//4在base-10选项中=1&lt；&lt；3，//8在base-10中Shift=1&lt；&lt；4，//16在base-10}</p><p>  The left shift operator ( &lt;&lt;) shifts the first operand the specified number of bits to the left.Excess bits shifted off to the left are discarded. Zero bits are shifted in from the right.</p><p>左移位运算符（&lt；&lt；）将第一个操作数向左移位指定位数。向左移位的多余位将被丢弃。零位从右边移入。</p><p> So if we were to log out each of those modifiers in their base-2 representation, here&#39;s what we&#39;d get:</p><p>因此，如果我们要注销它们的base-2表示中的每一个修饰符，这里&#39；这就是我们&#39；d得到：</p><p>  Like  parseInt(), JavaScript&#39;s  toString() function cantake an optional radix argument that converts the number to the specified base.</p><p>比如parseInt（）、JavaScript&#39；函数可以使用一个可选的基数参数，将数字转换为指定的基数。</p><p> You can see that the number of  0s directly corresponds to the number to the right of the  &lt;&lt; operator in the  Mod enum.</p><p>您可以看到0的数量直接对应于&lt&书信电报；Mod enum中的运算符。</p><p> So what&#39;s the point of all this? Well, let&#39;s switch to base-10 for a minute. You need to check for multiple true or false conditions.The nice thing about using bit flags is any combination of those  Mod values will never add up to the same number:</p><p>那又怎样&#39；这一切的意义是什么？好吧，让&#39；让我们切换到10垒一分钟。你需要检查多个正确或错误的条件。使用位标志的好处是，这些Mod值的任何组合都不会等于同一个数字：</p><p>  The list goes on (just trust me). Each possible combination of those flags will never overlap with another combination.For example, you&#39;ll never run into an issue where the value could be either ( Mod.Command +  Mod.Option) or( Mod.Option +  Mod.Shift).</p><p>清单还在继续（相信我）。这些标志的每个可能组合都不会与另一个组合重叠。例如，你&#39；我永远不会遇到值可能是（Mod.Command+Mod.Option）或（Mod.Option+Mod.Shift）的问题。</p><p> There&#39;s actually an issue with the amount of bits we&#39;re shifting (i.e.  1,  2,  3, and  4),but we&#39;ll cover that later.</p><p>那里&#39；这实际上是我们的比特数问题&#39；重新转换（即1、2、3和4），但我们&#39；我稍后再谈。</p><p> Now that we&#39;ve got our modifiers set up, let&#39;s cover how to use them with bitwise operators.</p><p>现在我们&#39；我们已经设置好了修改器，让&#39；下面介绍如何将它们与位运算符一起使用。</p><p>   I&#39;m only concerned with the  AND,  OR, and  NOT operators for my purposes, but  XOR is there if you need it.Bitwise operators can be described by something called a  truth table.If you don&#39;t feel like clicking through on that link, here&#39;s a quick rundown:</p><p>我&#39；我只关心AND，OR，AND运算符，而不是我的目的，但如果您需要的话，XOR是存在的。位运算符可以用真值表来描述。如果你没有&#39；我不想点击这里的链接&#39；下面是一个简短的概述：</p><p> A truth table is a mathematical table used to carry out logical operations in Maths.It includes boolean algebra or boolean functions.It is primarily used to determine whether a compound statement is true or false based on the input values.</p><p>真值表是数学中用来进行逻辑运算的数学表。它包括布尔代数或布尔函数。它主要用于根据输入值确定复合语句是真是假。</p><p> The truth table on the linked site is a bit difficult to grasp, so let&#39;s go through the truth table for each operator we&#39;re concerned with.</p><p>链接站点上的真相表有点难以掌握，所以让&#39；让我们为每个运算符检查真值表&#39；我们关心的是。</p><p> Assuming you have two bits a and b. The truth table for the  AND bitwise operator looks like this:</p><p>假设有两位a和b。and位运算符的真值表如下所示：</p><p>  If you swapped out  0 for  false,  1 for true, and  &amp; for  &amp;&amp;, it would map to:</p><p>如果将0替换为false，将1替换为true，并将&amp；为&amp&amp；，它将映射到：</p><p> console . log ( false  &amp;&amp;  false ) ;  // falseconsole . log ( false  &amp;&amp;  true ) ;  // falseconsole . log ( true  &amp;&amp;  false ) ;  // falseconsole . log ( true  &amp;&amp;  true ) ;  // true</p><p>安慰日志（假和假）；//假控制台。日志（假与真）；//假控制台。日志（真与假）；//假控制台。日志（真与真）；//符合事实的</p><p>   If you swapped out  0 for  false,  1 for true, and  | for  ||, it would map to:</p><p>如果将0替换为false，将1替换为true，将|替换为| |，它将映射到：</p><p> console . log ( false  ||  false ) ;  // falseconsole . log ( false  ||  true ) ;  // trueconsole . log ( true  ||  false ) ;  // trueconsole . log ( true  ||  true ) ;  // true</p><p>安慰日志（假| |假）；//假控制台。日志（假| |真）；//trueconsole。日志（真| |假）；//trueconsole。日志（真| |真）；//符合事实的</p><p>   So we have a  Mod bit flag enum and some operators we can use to shimmy bits around.Let&#39;s apply that to keyboard shortcuts.</p><p>所以我们有一个Mod bit flag enum和一些操作符，可以用来调整位。让&#39；让我们将其应用于键盘快捷键。</p><p>  For the time being, we&#39;re going to focus exclusively on modifiers and worry about non-modifier keys (e.g. letters, numbers, symbols) later.Let&#39;s create a function called  areKeysDown with an  event and a  combo argument.The  event is a   KeyboardEvent and the  combo is a number that corresponds to our bit flags.</p><p>目前，我们&#39；我们以后将只关注修饰符，并担心非修饰符键（例如字母、数字、符号）。让&#39；s创建一个名为areKeysDown的函数，其中包含一个事件和一个组合参数。事件是一个键盘事件，组合是一个与我们的位标志相对应的数字。</p><p> As far as desired functionality goes, we want to check if a specific combination of keys are down.It&#39;s important to note that the function returns  true if and only if those  exact keys are down.So  areKeysDown(event, Mod.Command) returns  true if the  Command key is down, but  false if  Command +  Control is down.</p><p>就所需的功能而言，我们希望检查特定的按键组合是否已关闭。它&#39；It’重要的是要注意，当且仅当那些精确的键被按下时，函数才会返回true。因此，如果命令键关闭，areKeysDown（事件，Mod.Command）将返回true，如果Command+Control关闭，则返回false。</p><p>  function  areKeysDown (event : KeyboardEvent , combo :  number ) :  boolean  {  let keyCode  = combo ;  if  ( (combo  &amp; Mod .Command )  === Mod .Command )  {  if  ( !event .metaKey )  {  return  false ;  }  else  { keyCode  = keyCode  &amp;  ~Mod .Command ;  }  }  else  {  if  (event .metaKey )  {  return  false ;  }  }  // ... rest of Mod handlers ...  // This will change when we add non-modifier keys:  return keyCode  ===  0 ; }</p><p>函数areKeysDown（事件：KeyboardEvent，combo:number）：布尔值{let keyCode=combo；if（（combo&amp；Mod.Command）==Mod.Command）{if（！event.metaKey）{return false；}else{keyCode=keyCode&amp；~Mod.Command；}else{if（event.metaKey）{return false；}}/。。。其余的Mod处理程序…//当我们添加非修改键时，这将发生变化：return keyCode===0；}</p><p> On macOS,  event.metaKey indicates the  Command key ( ⌘) is down, event.altKey indicates the  Option key ( ⌥) is down, event.ctrlKey indicates the  Control key ( ⌃) is down,and  event.shiftKey indicates the  Shift key is down.</p><p>在macOS上，事件。metaKey表示命令键（⌘) 事件已经结束。altKey表示选项键（⌥) 事件已经结束。ctrlKey表示控制键（⌃) 这件事已经结束了。shiftKey表示Shift键已按下。</p><p>  document . addEventListener ( &#34;keydown&#34; ,  (event : KeyboardEvent )  =&gt;  {  // Logs out true if event.metaKey = true, other modifiers are false,  // and no other keys are pressed:  console . log ( areKeysDown (event , Mod .Command ) ) ; } ) ;</p><p>文件addEventListener（&#34；keydown&#34；，（事件：KeyboardEvent）=&gt；{//如果event.metaKey=true，则注销true，其他修饰符为false，//并且没有按下其他键：console.log（areKeysDown（event，Mod.Command））；}；</p><p> Let&#39;s talk this out. On the very first line I create a local variable,  keyCode which is assigned the value of  combo.The idea is that we step through each modifier and clear the bit flag from the  keyCode until we get down to the bottom of the function.After getting rid of all the  Mod flags, you&#39;re left with the  keyCode which represents the letter or number that was pressed.</p><p>让&#39；让我们谈谈。在第一行中，我创建了一个局部变量keyCode，它被赋予combo的值。这个想法是，我们一步一步地通过每个修饰符，清除键码中的位标志，直到我们到达函数的底部。去掉所有Mod标志后，您&#39；re left键代码代表按下的字母或数字。</p><p>   Hooray! We&#39;ve encountered our first bitwise operator, the  AND. So what is this line doing?Well, according to the  MDN documentation for the AND operator:</p><p>好极了我们&#39；我们遇到了第一个位运算符AND。那么这条线在做什么？好吧，根据MDN文档中关于和操作员的描述：</p><p> The bitwise AND operator ( &amp;) returns a  1 in each bit position for which the corresponding bits of both operands are  1s.</p><p>按位AND运算符（&amp；）在两个操作数的对应位均为1的每个位位置返回1。</p><p>  const a  =  5 ;  // 00000000000000000000000000000101 const b  =  3 ;  // 00000000000000000000000000000011 // Only bit that&#39;s a 1 in both values ^console . log (a  &amp; b ) ;  // 00000000000000000000000000000001 // Which is why it only logs out 1 ^</p><p>常数a=5；//000000000000000000101常数b=3；//00000000000000000000000011//；在两个值中都是1。/a&b0000000000000000000000001//这就是它只注销1的原因^</p><p>  const combo  = Mod .Command ;  // 00000000000000000000000000000010 const compare  = combo  &amp; Mod .Command ;  // 00000000000000000000000000000010 // This translates to: // if 00000000000000000000000000000010 // == 00000000000000000000000000000010 // Which is true! So we know the Command modifier was pressed. if  (compare  === Mod .Command )  {  // ... }</p><p>const combo=Mod。命令；//00000000000000000000000010 const compare=combo&amp；摩登派青年命令；//00000000000000000000000000000010//这转换为：//if 00000000000000000000000010/==00000000000000000000000000000010//这是真的！所以我们知道命令修改器被按下了。如果（compare==Mod.Command）{/…}</p><p>  if  ( (combo  &amp; Mod .Command )  === Mod .Command )  {  if  ( !event .metaKey )  {  return  false ;  }  else  { keyCode  = keyCode  &amp;  ~Mod .Command ;  } }</p><p>如果（（组合和修改命令）==Mod。命令）{if（！event.metaKey）{return false；}else{keyCode=keyCode&amp；~Mod.Command；}</p><p> The  if (!event.metaKey) statement is pretty obvious. If we&#39;re checking for the  Command modifier, and it isn&#39;t pressed, the function returns  false.The  else is where things get spicy. I&#39;m using the  AND plus the  NOT operator to clear  Mod.Command from  keyCode.</p><p>if（！event.metaKey）语句非常明显。如果我们&#39；重新检查命令修饰符，它不是&#39；t按下，函数返回false。另一个是事情变得辛辣的地方。我&#39；m使用AND和NOT运算符清除Mod。来自keyCode的命令。</p><p>   Dafuq does that mean? Well for a 32-bit integer, it turns all the  1s to  0s and  0s to  1s.</p><p>达夫那是什么意思？对于32位整数，它将所有的1变成0，0变成1。</p><p>  But hang on a second, wouldn&#39;t that mean the value would be huge after we NOT it?You are correct, but don&#39;t forget that this is a two-step operation:</p><p>但是等一下，不是吗&#39；这难道不意味着在我们不这么做之后，它的价值将是巨大的吗？你是对的，但是不要&#39；不要忘记这是一个两步操作：</p><p> const combo  = Mod .Command ;  // 00000000000000000000000000000010 const not  =  ~Mod .Command ;  // 11111111111111111111111111111101 console . log ( (combo  &amp; not ) . toString ( 2 ) ) ;  // 00000000000000000000000000000000 // ^ Don&#39;t forget about the AND!</p><p>const combo=Mod。命令；//00000000000000000000000010 const not=~Mod。命令；//11111111111111111111101控制台。日志（（组合和非组合）。toString（2））；//00000000000000000000000000/^Don&#39；别忘了还有！</p><p>  The bitwise AND operator ( &amp;) returns a  1 in each bit position forwhich the corresponding bits of both operands are  1s.</p><p>按位AND运算符（&amp；）在两个操作数的对应位均为1的每个位位置返回1。</p><p> There are  no positions in the  combo and  not variables in which both bits are  1, so the output of that is  0.The final  else statement enforces the requirement that the function return  true if and only if  the exact combo specified is pressed.If you&#39;re checking if  Mod.Control is down and the user is pressing  Control +  Command, the function returns  false.</p><p>组合中没有位置，也没有两个位都为1的变量，因此其输出为0。最后一条else语句强制要求当且仅当按下指定的确切组合时函数返回true。如果你&#39；重新检查国防部。控件关闭且用户按下Control+Command时，函数返回false。</p><p> function  areKeysDown (event : KeyboardEvent , combo :  number ) :  boolean  {  let keyCode  = combo ;  if  ( (combo  &amp; Mod .Command )  === Mod .Command )  {  // ...  }  else  {  // The Command key is depressed, but we&#39;re explicitly checking  // if it is _not_ down, so we return false:  if  (event .metaKey )  {  return  false ;  }  }  // ... rest of Mod handlers ...  // This will change when we add non-modifier keys:  return keyCode  ===  0 ; }</p><p>函数areKeyDown（事件：KeyboardEvent，combo:number）：布尔值{let keyCode=combo；if（（combo&amp；Mod.Command）==Mod.Command）{/…}否则//Command键被按下，但我们&#39；重新显式检查//if _not u down，因此我们返回false:if（event.metaKey）{return false；}}/。。。其余的Mod处理程序…//当我们添加非修改键时，这将发生变化：return keyCode===0；}</p><p> So this is all well and good, but not very useful. How do you check for multiple modifiers?I&#39;m glad you asked!</p><p>这一切都很好，但不是很有用。如何检查多个修改器？我&#39；我很高兴你这么问！</p><p>  Let&#39;s add a second modifier  if statement to our  areKeysDown function that checks for  Control:</p><p>让&#39；s在areKeysDown函数中添加第二个修饰符if语句，用于检查控制：</p><p> function  areKeysDown (event : KeyboardEvent , combo :  number ) :  boolean  {  let keyCode  = combo ;  if  ( (combo  &amp; Mod .Command )  === Mod .Command )  {  if  ( !event .metaKey )  {  return  false ;  }  else  { keyCode  = keyCode  &amp;  ~Mod .Command ;  }  }  else  {  if  (event .metaKey )  {  return  false ;  }  }  if  ( (combo  &amp; Mod .Control )  === Mod .Control )  {  if  ( !event .ctrlKey )  {  return  false ;  }  else  { keyCode  = keyCode  &amp;  ~Mod .Control ;  }  }  else  {  if  (event .ctrlKey )  {  return  false ;  }  }  // ... rest of Mod handlers ...  // This will change when we add non-modifier keys:  return keyCode  ===  0 ; }</p><p>函数areKeysDown（事件：KeyboardEvent，combo:number）：布尔值{let keyCode=combo；if（（combo&amp；Mod.Command）==Mod.Command）{if（！event.metaKey）{return false；}else{keyCode=keyCode&amp；~Mod.Command；}else{if（event.metaKey）{return false；}如果（（组合和模块控制）==Mod。控件）{if（！event.ctrlKey）{return false；}else{keyCode=keyCode&amp；~Mod.Control；}else{if（event.ctrlKey）{return false；}}/。。。其余的Mod处理程序…//当我们添加非修改键时，这将发生变化：return keyCode===0；}</p><p>  In order to check for multiple modifiers, we&#39;re going to bring out the final bitwise operator:  OR.So our function call looks like this:</p><p>为了检查多个修饰符，我们&#39；我们将给出最后一个按位运算符：OR。我们的函数调用如下所示：</p><p> document . addEventListener ( &#34;keydown&#34; ,  (event : KeyboardEvent )  =&gt;  {  // Logs out true if event.metaKey = true, event.ctrlKey = true,  // other modifiers are false, and no other keys are pressed:  console . log ( areKeysDown (event , Mod .Command  | Mod .Control ) ) ; } ) ;</p><p>文件addEventListener（&#34；keydown&#34；，（事件：KeyboardEvent）=&gt；{//如果event.metaKey=true，event.ctrlKey=true，则注销true，//其他修饰符为false，并且没有按下其他键：console.log（areKeysDown（event，Mod.Command | Mod.Control））；}；</p><p>  The bitwise OR operator ( |) returns a  1 in each bit position for which thecorresponding bits of either or both operands are  1s.</p><p>按位OR运算符（|）在其中一个或两个操作数的对应位为1的每个位位置返回1。</p><p>  const a  =  5 ;  // 00000000000000000000000000000101 const b  =  3 ;  // 00000000000000000000000000000011 // These are either 1 or 0 ^^^console . log (a  | b ) ;  // 00000000000000000000000000000111 // So it turns them all into 1s ^^^</p><p>常数a=5；//000000000000000000101常数b=3；//00000000000000000000000011//这些是1或0^^^控制台。日志（a | b）；//000000000000000000000000111//所以它把它们都变成了1^^^</p><p>  document . addEventListener ( &#34;keydown&#34; ,  (event : KeyboardEvent )  =&gt;  {  // Logs out true if event.metaKey = true, event.ctrlKey = true,  // other modifiers are false, and no other keys are pressed:  console . log ( areKeysDown (event , Mod .Command  | Mod .Control ) ) ; } ) ; function  areKeysDown (event : KeyboardEvent , combo :  number ) :  boolean  {  // Mod.Command = 00000000000000000000000000000010  // Mod.Control = 00000000000000000000000000000100  // combo = 00000000000000000000000000000110  // Set bits with a 1 in either number to 1 ^^  if  ( (combo  &amp; Mod .Command )  === Mod .Command )  {  // Mod.Command = 00000000000000000000000000000010  // combo = 00000000000000000000000000000110  // combo &amp; Mod.Command = 00000000000000000000000000000010  // Only position where Mod.Command _and_ combo is 1 ^  // Does 00000000000000000000000000000010  // == 00000000000000000000000000000010?  // Yep! So we know that Mod.Command is in the combo argument  } }</p><p>文件addEventListener（&#34；keydown&#34；，（事件：KeyboardEvent）=&gt；{//如果event.metaKey=true，event.ctrlKey=true，则注销true，//其他修饰符为false，并且没有按下其他键：console.log（areKeysDown（event，Mod.Command | Mod.Control））；}；函数areKeysDown（事件：KeyboardEvent，combo:number）：布尔{//Mod.Command=00000000000000000000000000000010//Mod.Control=000000000000000000000000000000100//combo=000000000000000000000000000000110//如果（（combo&amp；Mod.Command）==Mod Command），则将任意数字中的位设置为1^^^{//Mod.Command=00000000000000000000000010//combo=000000000000000000000000110//combo&amp；Mod.Command=00000000000000000000000000000010//Mod.Command_u和u00000000000000000010//==00000000000000000000000010？//是的！所以我们知道Mod.Command在com中bo参数}</p><p>  document . addEventListener ( &#34;keydown&#34; ,  (event : KeyboardEvent )  =&gt;  {  console . log ( areKeysDown (event , Mod .Command  | Mod .Control ) ) ; } ) ; function  areKeysDown (event : KeyboardEvent , combo :  number ) :  boolean  {  // Mod.Command = 00000000000000000000000000000010  // Mod.Control = 00000000000000000000000000000100  // combo = 00000000000000000000000000000110  // Set bits with a 1 in either number to 1 ^^  let keyCode  = combo ;  if  ( (combo  &amp; Mod .Command )  === Mod .Command )  {  // See previous example (we know it&#39;s true)...  if  ( !event .metaKey )  {  return  false ;  }  else  {  // ~Mod.Command = 11111111111111111111111111111101  // keyCode is still combo which = 00000000000000000000000000000110 keyCode  = keyCode  &amp;  ~Mod .Command ;  // 00000000000000000000000000000100  // Only bit position in both numbers with value of 1 ^  }  }  else  {  // ...  }  if  ( (combo  &amp; Mod .Control )  === Mod .Control )  {  // Mod.Control = 00000000000000000000000000000100  // combo = 00000000000000000000000000000110  // combo &amp; Mod.Control = 00000000000000000000000000000100  // Only position where command _and_ combo is 1 ^  // Does 00000000000000000000000000000100  // == 00000000000000000000000000000100?  // Yep! So we know that Mod.Control is in the combo argument  if  ( !event .ctrlKey )  {  return  false ;  }  else  {  // ~Mod.Control = 11111111111111111111111111111011  // keyCode = combo w/o Mod.Command = 00000000000000000000000000000100 keyCode  = keyCode  &amp;  ~Mod .Control ;  // 00000000000000000000000000000000  }  }  // The keyCode is now 0, so we return true!  return keyCode  ===  0 ; }</p><p>文件addEventListener（&#34；keydown&#34；，（事件：KeyboardEvent）=&gt；{console.log（areKeysDown（事件，Mod.Command | Mod.Control））；}；函数areKeysDown（事件：KeyboardEvent，combo:number）：布尔值{//Mod.Command=00000000000000000000000000000010//Mod.Control=000000000000000000000000000000100//combo=000000000000000000000000110//将任意数字中的1位设置为1^^^让keyCode=combo；如果（（combo&amp；Mod.Command）==Mod。Command）{//参见前面的示例（我们知道它是真的）…如果（！event.metaKey）{return false；}else{/~Mod.Command=11111111111111111111111101//keyCode仍然是combo=000000000000000000000000110 keyCode=keyCode&amp；~Mod.Command；//000000000000000000000000100//两个数字中的唯一位位置，值为1^}else{/…}如果（（组合和模块控制）==Mod。（控制）{//Mod.Control=000000000000000000000000100//combo=000000000000000000000000110//combo&amp；Mod.Control=000000000000000000000000000000100//只有命令_和uCombo为1的位置^//如果（！event.ctrlKey）{return false；}否则{//~Mod.Control=111111111111111111111111011//keyCode=combo w/o Mod.Command=000000000000000000000000000000100 keyCode=keyCode&amp；~Mod.Control；//00000000000000000000000000000000000000}//keyCode现在是0，所以我们返回true！return keyCode==0；}</p><p> So that&#39;s how we handle multiple modifiers. But that  still doesn&#39;t get us all the functionality we need.What about letters, numbers, arrow keys, etc.? Let&#39;s cover that next.</p><p>因此&#39；这就是我们处理多个修饰语的方式。但这仍然没有&#39；我们无法获得所需的所有功能。字母、数字、箭头键等呢。？让&#39；接下来我们来报道。</p><p>  This is where things start to get a little hairy.The  KeyboardEvent has a  keyCode property that has been deprecated for a while and is no longer recommended.</p><p>这就是事情开始变得有点棘手的地方。KeyboardEvent的keyCode属性已被弃用一段时间，不再推荐使用。</p><p>  The deprecated  KeyboardEvent.keyCode read-only property represents a system andimplementation dependent numerical code identifying the unmodified value of the pressed key.</p><p>不推荐使用的键盘事件。keyCode只读属性表示与系统和实现相关的数字代码，用于标识按键的未修改值。</p><p> It&#39;s handy for bit flags because it&#39;s a number, so the letter  A has a  keyCode of  65.You could check if  Command +  A is pressed by doing this:</p><p>它&#39；因为它是&#39；s是一个数字，所以字母a的键码是65。通过执行以下操作，可以检查是否按下了Command+A：</p><p> document . addEventListener ( &#34;keydown&#34; ,  (event : KeyboardEvent )  =&gt;  {  // Logs out 65 if &#34;A&#34; is pressed:  console . log (event .keyCode ) ;  // Logs out true if event.metaKey = true and &#34;A&#34; is pressed  // (and only if those keys are pressed):  console . log ( areKeysDown (event , Mod .Command  |  65 ) ) ; } ) ;</p><p>文件addEventListener（&#34；keydown&#34；，（事件：KeyboardEvent）=&gt；{//如果按了&#34；A&#34；则注销65次：console.log（event.keyCode）；//如果按了event.metaKey=true和&#34；A&#34；则注销true（仅当按下这些键时）：console.log（areKeysDown（event，Mod.Command | 65））；</p><p> I imagine the primary reason for the deprecation was due to issues with international keyboard layouts.MDN recommends you use   KeyboardEvent.codeinstead, which is fine, but it just requires a little extra work.</p><p>我想不赞成的主要原因是国际键盘布局的问题。MDN建议您使用KeyboardEvent。代码，这很好，但它只需要一点额外的工作。</p><p> I created an  enum with each non-modifier key to make the  areKeysDown function more readable.If the  keyCode property  wasn&#39;t deprecated, that would look something like this:</p><p>我用每个非修饰键创建了一个枚举，以使areKeysDown函数更具可读性。如果keyCode属性不是&#39；t不推荐，看起来是这样的：</p><p> enum Key  { LetterA  =  65 , LetterB  =  66 , LetterC  =  67 , LetterD  =  68 ,  // ... and so on ... }</p><p>枚举键{LetterA=65，LetterB=66，LetterC=67，LetterD=68，//……等等……}</p><p>  document . addEventListener ( &#34;keydown&#34; ,  (event : KeyboardEvent )  =&gt;  {  console . log ( areKeysDown (event , Mod .Command  | Key .LetterA ) ) ; } ) ; function  areKeysDown (event : KeyboardEvent , combo :  number ) :  boolean  {  let keyCode  = combo ;  if  ( (combo  &amp; Mod .Command )  === Mod .Command )  {  // ... keyCode  = keyCode  &amp;  ~Mod .Command ;  // keyCode = 65 = Key.LetterA  // ...  }  // event.keyCode = 65 = Key.LetterA = keyCode, so we return true:  return event .keyCode  === keyCode ; }</p><p>文件addEventListener（&#34；keydown&#34；，（事件：KeyboardEvent）=&gt；{console.log（areKeysDown（事件，Mod.Command | Key.LetterA））；}；函数areKeyDown（事件：KeyboardEvent，combo:number）：布尔值{let keyCode=combo；if（（combo&amp；Mod.Command）==Mod.Command）{/..keyCode=keyCode&amp；~Mod.Command；//keyCode=65=Key.letta/../事件keyCode=65=Key。LetterA=keyCode，所以我们返回true:return事件。keyCode===keyCode；}</p><p>  enum Key  { LetterA  =  1 , LetterB , LetterC , LetterD ,  // ... and so on ... }</p><p>枚举键{LetterA=1，LetterB，LetterC，LetterD，//……等等……}</p><p> I started at  1 instead of  0, because  0 would be the result of clearing all the modifiers.There would be no way to differentiate between &#34;only modifiers are pressed&#34; and &#34;some modifiers plus the letter  A was pressed&#34;.</p><p>我从1开始，而不是0，因为0将是清除所有修饰符的结果。没有办法区分&#34；只按下修改器&#34；和&#34；一些修饰语加上字母A被按下&#34；。</p><p> Now we just need a table to map the  Key enum to the corresponding  KeyboardEvent.code values:</p><p>现在我们只需要一个表来将密钥枚举映射到相应的KeyboardEvent。代码值：</p><p> const codeByKeyTable : Record &lt;Key ,  string &gt;  =  {  [Key .LetterA ] :  &#34;KeyA&#34; ,  [Key .LetterB ] :  &#34;KeyB&#34; ,  [Key .LetterC ] :  &#34;KeyC&#34; ,  [Key .LetterD ] :  &#34;KeyD&#34; ,  // ... and so on ... }</p><p>const codeByKeyTable:记录&lt；键，字符串&gt；={[Key.LetterA]：&#34；Key.LetterB]：&#34；Key&#34；[Key.LetterC]：&#34；Key&#34；[Key.LetterD]：&#34；KeyD&#34；/…等等。}</p><p>  document . addEventListener ( &#34;keydown&#34; ,  (event : KeyboardEvent )  =&gt;  {  // Logs out &#34;KeyA&#34; when you press the letter &#34;A&#34;:  console . log (event .code ) ; } ) ;</p><p>文件addEventListener（&#34；keydown&#34；，（事件：KeyboardEvent）=&gt；{//Logs out&#34；KeyA&#34；当您按下字母&#34；A&#34；：console.log（event.code）；}；</p><p> If you&#39;re wondering why I used  KeyboardEvent.code instead of  KeyboardEvent.key, it&#39;s because  KeyboardEvent.codereturns a value that  isn&#39;t altered by keyboard layout or the state of the modifier keys. KeyboardEvent.key returns a different value depending on the state of the modifier keys, which wouldpretty much break all our code.</p><p>如果你&#39；你想知道我为什么用KeyboardEvent。代码而不是键盘事件。钥匙，它&#39；这是因为键盘事件。Code返回的值不是&#39；t根据键盘布局或修改键的状态进行更改。键盘事件。键根据修改键的状态返回不同的值，这将大大破坏我们所有的代码。</p><p>  document . addEventListener ( &#34;keydown&#34; ,  (event : KeyboardEvent )  =&gt;  {  console . log ( areKeysDown (event , Mod .Command  | Key .LetterA ) ) ; } ) ; function  areKeysDown (event : KeyboardEvent , combo :  number ) :  boolean  {  let keyCode  = combo ;  if  ( (combo  &amp; Mod .Command )  === Mod .Command )  {  // ... keyCode  = keyCode  &amp;  ~Mod .Comma</p><p>文件addEventListener（&#34；keydown&#34；，（事件：KeyboardEvent）=&gt；{console.log（areKeysDown（事件，Mod.Command | Key.LetterA））；}；函数areKeyDown（事件：KeyboardEvent，combo:number）：布尔值{let keyCode=combo；if（（combo&amp；Mod.Command）==Mod.Command）{/…keyCode=keyCode&amp；Mod.Comma</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/键盘/">#键盘</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bitwisdom/">#bitwisdom</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/mod/">#mod</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>