<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用C ++ 20进行位操作 Bit Manipulation with C++20</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Bit Manipulation with C++20<br/>使用C ++ 20进行位操作 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-13 17:22:22</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/06d3aad1627e300211563c2e6e97eabe.png"><img src="http://img2.diglog.com/img/2020/12/06d3aad1627e300211563c2e6e97eabe.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This post concludes my presentation of library features in C++20. Today I write about the class  std::source_location and a few functions for bit manipulation.</p><p>这篇文章总结了我对C ++ 20库功能的介绍。今天，我写关于类std :: source_location和一些用于位操作的函数的文章。</p><p>    std::source_location represents information about the source code. This information includes file names, line numbers, and function names. The information is precious when you need information about the call site, such as for debugging, logging, or testing purposes. The class  std::source_location is the better alternative for the predefined C++11 macros  __FILE__ and  __LINE__ and should, therefore, be used.</p><p>    std :: source_location表示有关源代码的信息。该信息包括文件名，行号和函数名。当您需要有关呼叫站点的信息（例如用于调试，记录或测试目的）时，此信息非常宝贵。 std :: source_location类是预定义的C ++ 11宏__FILE__和__LINE__的更好替代方法，因此应使用。</p><p>      The call  std::source_location::current() creates a new source location object  src. src represents the information of the call site. Now, no C++ compiler supports  std::source_location. Consequently, the following program  sourceLocation.cpp is from  cppreference.com/source_location.</p><p>      调用std :: source_location :: current（）创建一个新的源位置对象src。 src代表呼叫站点的信息。现在，没有C ++编译器支持std :: source_location。因此，以下程序sourceLocation.cpp来自cppreference.com/source_location。</p><p>     // sourceLocation.cpp // from cppreference.com #include &lt;iostream&gt; #include &lt;string_view&gt; #include &lt;source_location&gt;  void  log(std ::string_view message,  const std ::source_location &amp; location  = std ::source_location ::current()){ std ::cout  &lt;&lt;  &#34;info:&#34;  &lt;&lt; location.file_name()  &lt;&lt;  &#39;:&#39;  &lt;&lt; location.line()  &lt;&lt;  &#39; &#39;  &lt;&lt; message  &lt;&lt;  &#39;\n&#39;;}  int  main(){ log( &#34;Hello world!&#34;);  // info:main.cpp:19 Hello world!}</p><p>     // sourceLocation.cpp //来自cppreference.com #include＆lt; iostream＆gt; #include＆lt; string_view＆gt; #include＆lt; source_location＆gt;  无效日志（std :: string_view消息，  const std :: source_location＆amp; location = std :: source_location :: current（））{ std :: cout＆lt;＆lt; ＆＃34; info：＆＃34;  ＆lt;＆lt; location.file_name（）＆lt;＆lt; ＆＃39;：＆＃39;  ＆lt;＆lt; location.line（）＆lt;＆lt; ＆＃39; ＆＃39;  ＆lt;＆lt;消息＆lt;＆lt; ＆＃39; \ n＆＃39 ;;}  int main（）{ log（＆＃34; Hello world！＆＃34;）; // info：main.cpp：19您好，世界！}</p><p>              Endianness can be big-endian or little-endian. Big-endian means that the most significant byte comes first; little-endian means that the least significant byte comes first.</p><p>              字节序可以是大字节序或小字节序。 Big-endian表示最高有效字节在前； little-endian表示最低有效字节在前。</p><p>  A scalar type is either an arithmetic type, an  enum, a pointer, a member pointer, or a  std::nullptr_t.</p><p>  标量类型可以是算术类型，枚举，指针，成员指针或std :: nullptr_t。</p><p>            If all scalar types have  sizeof 1 and therefore endianness does not matter; the values of the enumerators  std::endian::little,  std::endian::big, and  std::endian::native are identical.</p><p>            如果所有标量类型的大小都为1，则字节序无关紧要；枚举数std :: endian :: little，std :: endian :: big和std :: endian :: native的值相同。 </p><p>  When I perform the following program  getEndianness.cpp on an x86 architecture, I get the answer little-endian.</p><p>当我在x86体系结构上执行以下程序getEndianness.cpp时，得到的答案是little-endian。</p><p>    // getEndianness.cpp #include &lt;bit&gt; #include &lt;iostream&gt; int  main() {  if constexpr (std ::endian ::native  == std ::endian ::big) { std ::cout  &lt;&lt;  &#34;big-endian&#34;  &lt;&lt;  &#39;\n&#39;; }  else  if constexpr (std ::endian ::native  == std ::endian ::little) { std ::cout  &lt;&lt;  &#34;little-endian&#34;  &lt;&lt;  &#39;\n&#39;;  // little-endian }}</p><p>    // getEndianness.cpp #include＆lt; bit＆gt; #include＆lt; iostream＆gt; int main（）{  如果constexpr（std :: endian :: native == std :: endian :: big）{ std :: cout＆lt;＆lt; ＆＃34; big-endian＆＃34; ＆lt;＆lt; ＆＃39; \ n＆＃39 ;; }  否则，如果constexpr（std :: endian :: native == std :: endian :: little）{ std :: cout＆lt;＆lt; ＆＃34;小尾数＆＃34; ＆lt;＆lt; ＆＃39; \ n＆＃39 ;; //小尾数 }}</p><p>    constexpr if enables it to compile source code conditionally. This means that the compilation depends on the endianness of your architecture. If you want to know more about endianness, read the same-named  Wikipedia page.</p><p>    constexpr如果启用它可以有条件地编译源代码。这意味着编译取决于您的体系结构的字节序。如果您想进一步了解字节序，请阅读同名的Wikipedia页面。</p><p>            The functions except of  std::bit_cast require an unsigned integer type ( unsigned char, unsigned short, unsigned int, unsigned long, or  unsigned long long).</p><p>            除std :: bit_cast之外的函数均要求无符号整数类型（无符号字符，无符号短字符，无符号int，无符号长或无符号长整型）。</p><p>       // bit.cpp #include &lt;bit&gt; #include &lt;bitset&gt; #include &lt;iostream&gt;  int  main() {  std :: uint8_t num =  0b00110010;  std ::cout  &lt;&lt; std ::boolalpha;  std ::cout  &lt;&lt;  &#34;std::has_single_bit(0b00110010): &#34;  &lt;&lt; std ::has_single_bit(num)   &lt;&lt;  &#39;\n&#39;;  std ::cout  &lt;&lt;  &#34;std::bit_ceil(0b00110010): &#34;  &lt;&lt; std ::bitset &lt; 8 &gt;(std ::bit_ceil(num))   &lt;&lt;  &#39;\n&#39;; std ::cout  &lt;&lt;  &#34;std::bit_floor(0b00110010): &#34;   &lt;&lt; std ::bitset &lt; 8 &gt;(std ::bit_floor(num))  &lt;&lt;  &#39;\n&#39;;  std ::cout  &lt;&lt;  &#34;std::bit_width(5u): &#34;  &lt;&lt; std ::bit_width( 5u)  &lt;&lt;  &#39;\n&#39;;  std ::cout  &lt;&lt;  &#34;std::rotl(0b00110010, 2): &#34;  &lt;&lt; std ::bitset &lt; 8 &gt;(std ::rotl(num,  2))   &lt;&lt;  &#39;\n&#39;; std ::cout  &lt;&lt;  &#34;std::rotr(0b00110010, 2): &#34;  &lt;&lt; std ::bitset &lt; 8 &gt;(std ::rotr(num,  2))   &lt;&lt;  &#39;\n&#39;;  std ::cout  &lt;&lt;  &#34;std::countl_zero(0b00110010): &#34;  &lt;&lt; std ::countl_zero(num)  &lt;&lt;  &#39;\n&#39;; std ::cout  &lt;&lt;  &#34;std::countl_one(0b00110010): &#34;  &lt;&lt; std ::countl_one(num)  &lt;&lt;  &#39;\n&#39;; std ::cout  &lt;&lt;  &#34;std::countr_zero(0b00110010): &#34;  &lt;&lt; std ::countr_zero(num)  &lt;&lt;  &#39;\n&#39;; std ::cout  &lt;&lt;  &#34;std::countr_one(0b00110010): &#34;  &lt;&lt; std ::countr_one(num)  &lt;&lt;  &#39;\n&#39;; std ::cout  &lt;&lt;  &#34;std::popcount(0b00110010): &#34;  &lt;&lt; std ::popcount(num)  &lt;&lt;  &#39;\n&#39;; }</p><p>       // bit.cpp #include＆lt; bit＆gt; #include＆lt; bitset＆gt; #include＆lt; iostream＆gt;  int main（）{  std :: uint8_t num = 0b00110010;  std :: cout＆lt;＆lt; std :: boolalpha;  std :: cout＆lt;＆lt; ＆＃34; std :: has_single_bit（0b00110010）：＆＃34; ＆lt;＆lt; std :: has_single_bit（num）  ＆lt;＆lt; ＆＃39; \ n＆＃39 ;;  std :: cout＆lt;＆lt; ＆＃34; std :: bit_ceil（0b00110010）：＆＃34; ＆lt;＆lt; std :: bitset＆lt; 8＆gt;（std :: bit_ceil（num））  ＆lt;＆lt; ＆＃39; \ n＆＃39 ;; std :: cout＆lt;＆lt; ＆＃34; std :: bit_floor（0b00110010）：＆＃34;  ＆lt;＆lt; std :: bitset＆lt; 8＆gt;（std :: bit_floor（num））＆lt;＆lt; ＆＃39; \ n＆＃39 ;;  std :: cout＆lt;＆lt; ＆＃34; std :: bit_width（5u）：＆＃34; ＆lt;＆lt; std :: bit_width（5u）＆lt;＆lt; ＆＃39; \ n＆＃39 ;;  std :: cout＆lt;＆lt; ＆＃34; std :: rotl（0b00110010，2）：＆＃34; ＆lt;＆lt; std :: bitset＆lt; 8＆gt;（std :: rotl（num，2））  ＆lt;＆lt; ＆＃39; \ n＆＃39 ;; std :: cout＆lt;＆lt; ＆＃34; std :: rotr（0b00110010，2）：＆＃34; ＆lt;＆lt; std :: bitset＆lt; 8＆gt;（std :: rotr（num，2））  ＆lt;＆lt; ＆＃39; \ n＆＃39 ;;  std :: cout＆lt;＆lt; ＆＃34; std :: countl_zero（0b00110010）：＆＃34; ＆lt;＆lt; std :: countl_zero（num）＆lt;＆lt; ＆＃39; \ n＆＃39 ;; std :: cout＆lt;＆lt; ＆＃34; std :: countl_one（0b00110010）：＆＃34; ＆lt;＆lt; std :: countl_one（num）＆lt;＆lt; ＆＃39; \ n＆＃39 ;; std :: cout＆lt;＆lt; ＆＃34; std :: countr_zero（0b00110010）：＆＃34; ＆lt;＆lt; std :: countr_zero（num）＆lt;＆lt; ＆＃39; \ n＆＃39 ;; std :: cout＆lt;＆lt; ＆＃34; std :: countr_one（0b00110010）：＆＃34; ＆lt;＆lt; std :: countr_one（num）＆lt;＆lt; ＆＃39; \ n＆＃39 ;; std :: cout＆lt;＆lt; ＆＃34; std :: popcount（0b00110010）：＆＃34; ＆lt;＆lt; std :: popcount（num）＆lt;＆lt; ＆＃39; \ n＆＃39 ;; }</p><p>        The next program shows the application and the output of the functions  std::bit_floor,  std::bit_ceil,  std::bit_width, and  std::bit_popcount for the numbers 2 to 7.</p><p>        下一个程序显示2到7的函数std :: bit_floor，std :: bit_ceil，std :: bit_width和std :: bit_popcount的应用程序和输出。</p><p>   // bitFloorCeil.cpp #include &lt;bit&gt; #include &lt;bitset&gt; #include &lt;iostream&gt;  int  main() { std ::cout  &lt;&lt; std ::endl;  std ::cout  &lt;&lt; std ::boolalpha;   for ( auto i  =  2u; i  &lt;  8u;  ++i) { std ::cout  &lt;&lt;  &#34;bit_floor(&#34;  &lt;&lt; std ::bitset &lt; 8 &gt;(i)  &lt;&lt;  &#34;) = &#34;   &lt;&lt; std ::bit_floor(i)  &lt;&lt;  &#39;\n&#39;; std ::cout  &lt;&lt;  &#34;bit_ceil(&#34;  &lt;&lt; std ::bitset &lt; 8 &gt;(i)  &lt;&lt;  &#34;) = &#34;   &lt;&lt; std ::bit_ceil(i)  &lt;&lt;  &#39;\n&#39;; std ::cout  &lt;&lt;  &#34;bit_width(&#34;  &lt;&lt; std ::bitset &lt; 8 &gt;(i)  &lt;&lt;  &#34;) = &#34;   &lt;&lt; std ::bit_width(i)  &lt;&lt;  &#39;\n&#39;;  std ::cout  &lt;&lt;  &#34;bit_popcount(&#34;  &lt;&lt; std ::bitset &lt; 8 &gt;(i)  &lt;&lt;  &#34;) = &#34;   &lt;&lt; std ::popcount(i)  &lt;&lt;  &#39;\n&#39;;   std ::cout  &lt;&lt; std ::endl; }  std ::cout  &lt;&lt; std ::endl; }</p><p>   // bitFloorCeil.cpp #include＆lt; bit＆gt; #include＆lt; bitset＆gt; #include＆lt; iostream＆gt;  int main（）{ std :: cout＆lt;＆lt; std :: endl;  std :: cout＆lt;＆lt; std :: boolalpha;   对于（auto i = 2u; i＆lt; 8u; ++ i）{ std :: cout＆lt;＆lt; ＆＃34; bit_floor（＆＃34;＆lt; std :: bitset＆lt; 8＆gt;（i）＆lt;＆lt;＆＃34;）=＆＃34;  ＆lt;＆lt; std :: bit_floor（i）＆lt;＆lt; ＆＃39; \ n＆＃39 ;; std :: cout＆lt;＆lt; ＆＃34; bit_ceil（＆＃34;＆lt; std :: bitset＆lt; 8＆gt;（i）＆lt;＆lt;＆＃34;）=＆＃34;  ＆lt;＆lt; std :: bit_ceil（i）＆lt;＆lt; ＆＃39; \ n＆＃39 ;; std :: cout＆lt;＆lt; ＆＃34; bit_width（＆＃34;＆lt; std :: bitset＆lt; 8＆gt;（i）＆lt;＆lt;＆＃34;）=＆＃34;  ＆lt;＆lt; std :: bit_width（i）＆lt;＆lt; ＆＃39; \ n＆＃39 ;;  std :: cout＆lt;＆lt; ＆＃34; bit_popcount（＆＃34;＆lt; std :: bitset＆lt; 8＆gt;（i）＆lt;＆lt;＆＃34;）=＆＃34;  ＆lt;＆lt; std :: popcount（i）＆lt;＆lt; ＆＃39; \ n＆＃39 ;;  std :: cout＆lt;＆lt; std :: endl; }  std :: cout＆lt;＆lt; std :: endl; } </p><p>        Additionally to coroutines, C++20 has much to offer for concurrency First, C++20 has new atomics. The new atomics exists for floating-point values and smart pointers. C++20 also enables waiting on atomics. To coordinate threads, semaphore, latches, and barriers come into play. Also, the  std::thread was improved with  std::jthread. The execution of a  std::jthread can be interrupted and joins automatically in its destructor.</p><p>除了协程外，C ++ 20还提供了许多并发功能。首先，C ++ 20具有新的原子。存在用于浮点值和智能指针的新原子。 C ++ 20还允许等待原子。为了协调线程，信号量，闩锁和屏障开始起作用。另外，std :: thread也通过std :: jthread进行了改进。 std :: jthread的执行可以被中断并自动加入其析构函数中。</p><p>    Thanks a lot to my  Patreon Supporters : Matt Braun, Roman Postanciuc, Tobias Zindl, Marko,   G Prvulovic, Reinhold Dröge, Abernitzke,   Frank Grimm  , Sakib, Broeserl,   António Pina, Darshan Mody, Sergey Agafyin,  Андрей Бурмистров, Jake, GS, Lawton Shoemake, Animus24, Jozo Leko, John Breland, espkk, Wolfgang Gärtner   ,  Louis St-Amour, Stephan Roslen, Venkat Nandam, Jose Francisco, Douglas Tinkham, Kuchlong Kuchlong, Avi Kohn, Robert Blanch, Truels Wissneth, Kris Kafka, Mario Luoni, Neil Wang, Friedrich Huber, Sudhakar Balagurusamy, lennonli, and Pramod Tikare Muralidhara.</p><p>    非常感谢我的Patreon支持者：Matt Braun，Roman Postanciuc，Tobias Zindl，Marko，G Prvulovic，ReinholdDröge，Abernitzke，Frank Grimm，Sakib，Broeserl，AntónioPina，Darshan Mody，Sergey Agafyin，АндрейБурмистров Lawton Shoemake，Animus24，Jozo Leko，John Breland，espkk，WolfgangGärtner，Louis St-Amour，Stephan Roslen，Venkat Nandam，Jose Francisco，Douglas Tinkham，Kuchlong Kuchlong，Avi Kohn，Robert Blanch，Truels Wissneth，Kris Kafka，Mario Luoni ，Neil Wang，Friedrich Huber，Sudhakar Balagurusamy，lennonli和Pramod Tikare Muralidhara。</p><p>          I&#39;m happy to give online-seminars or face-to-face seminars world-wide. Please call me if you have any questions.</p><p>          我很乐意在全球范围内举办在线研讨会或面对面的研讨会。如果您有任何疑问，请给我打电话。</p><p>          C++20 - A Deep Insight: Feb. 1. 2021 - Feb. 3. 2021 (16:00 - 20:00 UTC)</p><p>          C ++ 20-深入分析：2021年2月1日-2021年2月3日（UTC 16:00-20:00）</p><p>    Here is a compilation of my standard seminars. These seminars are only meant to give you a first orientation.</p><p>    这是我的标准研讨会的汇总。这些研讨会仅是为了给您一个第一方向。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.modernescpp.com/index.php/bit-manipulation-with-c-20">http://www.modernescpp.com/index.php/bit-manipulation-with-c-20</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/std/">#std</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1038059.html"><img src="http://img2.diglog.com/img/2020/12/thumb_977df6d26a6381e3ca831650b8902e09.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1038059.html">Skybolt：具有Python绑定的C ++行星环境渲染引擎 </a></div><span class="my_story_list_date">2020-12-6 20:46</span></div><div class="col-sm"><div><a target="_blank" href="/story/1038051.html"><img src="http://img2.diglog.com/img/2020/12/thumb_46d9b42d58b021e14ad294ce56bed05f.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1038051.html">C ++仍需要预处理器吗？ （2017） </a></div><span class="my_story_list_date">2020-12-6 20:21</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037957.html"><img src="http://img2.diglog.com/img/2020/12/thumb_b28292cfd6e08266eb3ade4fe4286595.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037957.html">一种特殊的地狱：C和C ++中的intmax_t </a></div><span class="my_story_list_date">2020-12-6 3:54</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037915.html"><img src="http://img2.diglog.com/img/2020/12/thumb_50a96ec38224a65e065993b6f8c5b389.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037915.html">std :: visit是现代C ++的所有错误（2017） </a></div><span class="my_story_list_date">2020-12-5 22:9</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>