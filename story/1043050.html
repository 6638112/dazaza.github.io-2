<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>30分钟内曲折 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">30分钟内曲折 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-03 17:04:17</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/b5d0f1167a86fdbbb8945644fc4c54f6.png"><img src="http://img2.diglog.com/img/2021/1/b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>命令zig run my_code.zig将编译并立即运行您的Zigprogram。这些单元格中的每一个都包含一个可以尝试运行的zig程序（其中一些包含编译时错误，可以将其注释掉以进行播放）</p><p>   //注释看起来像这样，然后转到pub fn main（）行的末尾void {}</p><p> 您可以使用内置的@import并将命名空间分配给const值，从标准库中进行导入。必须为zig中的几乎所有内容明确分配其标识符。您也可以这样导入其他zig文件，以及使用@cImport以类似方式导入C文件。</p><p>    const std = @import（＆＃34; std＆＃34;）; pub fn main（）void {var x：i32 = 47; //声明＆＃34; x＆＃34; i32类型的值为47。std.debug。 print（＆＃34; x：{} \ n＆＃34 ;,。{x}）;}</p><p>  pub fn main（）void {const x：i32 = 47; x = 42； //错误：无法分配给常量}</p><p> Zig非常挑剔，不会让您在外部范围内隐藏标识符，以免引起混淆：</p><p> const x：i32 = 47; pub fn main（）void {var x：i32 = 42; //错误：重新定义＆＃39; x＆＃39;} </p><p>全局作用域中的常量默认情况下是编译时＆＃34; comptime＆＃34;值，如果您省略类型，则它们是comptime类型的，并且可以转换为您的运行时值的运行时类型。</p><p> const x：i32 = 47;常数y = -47; // comptime整数。 pub fn main（）void {var a：i32 = y; //将comptime常数强制转换为正确的类型var b：i64 = y; //将comptime常数强制转换为正确的类型var c：u32 = y; //错误：无法将负值-47转换为无符号整数}</p><p> 如果稍后要设置它，则可以明确地选择使其保持未定义状态，但是如果您尝试使用它，zig将会出错。</p><p> pub fn main（）void {var x：i32 = undefined; foo（x）; //错误：使用未声明的标识符＆＃39; foo＆＃39;}</p><p> 在某些情况下，zig将允许您省略类型信息（如果可以确定的话）。</p><p> const std = @import（＆＃34; std＆＃34;）; pub fn main（）void {var x：i32 = 47; var y：i32 = 47; var z = x + y; //声明z并将其设置为94。std.debug。 print（＆＃34; z：{} \ n＆＃34 ;,。{z}）;}</p><p>  pub fn main（）void {var x = 47; //错误：类型为＆＃39; comptime_int＆＃39;的变量必须为const或comptime} </p><p>这是一个不返回任何内容的函数（foo）。 pub关键字表示该函数可从当前作用域导出，这就是为什么main必须是pub的原因。 Youcall的功能与大多数编程语言相同：</p><p> const std = @import（＆＃34; std＆＃34;）; fn foo（）void {std.debug。 print（＆＃34; foo！\ n＆＃34 ;,。{}）; //可选：return;} pub fn main（）void {foo（）;}</p><p>  const std = @import（＆＃34; std＆＃34;）; fn foo（）i32 {return 47;} pub fn main（）void {var result = foo（）;标准调试。 print（＆＃34; foo：{} \ n＆＃34 ;,。{result}）;}</p><p>  fn foo（）i32 {return 47;} pub fn main（）void {foo（）; //错误：表达式值被忽略}</p><p>    const std = @import（＆＃34; std＆＃34;）; fn foo（x：i32）void {std.debug。 print（＆＃34; foo param：{} \ n＆＃34 ;,。{x}）;} pub fn main（）void {foo（47）;}</p><p>  可以通过使用const关键字为结构命名来声明结构，它们可以不按顺序分配，也可以通过使用通常的点语法取消引用来使用它们。</p><p> const std = @import（＆＃34; std＆＃34;）; const Vec2 = struct {x：f64，y：f64}; pub fn main（）void {var v = Vec2 {.y = 1.0，.x = 2.0};标准调试。 print（＆＃34; v：{} \ n＆＃34 ;,。{v}）;} </p><p>结构可以具有默认值；结构也可以是匿名的，并且可以强制转换为另一个结构，只要可以将所有值都标明：</p><p> const std = @import（＆＃34; std＆＃34;）; const Vec3 = struct {x：f64 = 0.0，y：f64，z：f64}; pub fn main（）void {var v：Vec3 =。{。y = 0.1，.z = 0.2}; //好的var w：Vec3 =。{。y = 0.1}; //错误：缺少字段：＆＃39; z＆＃39;标准调试。 print（＆＃34; v：{} \ n＆＃34 ;,。{v}）;}</p><p> 您可以将函数放入结构中以使其像OOP样式的对象一样工作。第一个参数是指向对象的指针，可以称为＆＃34; Object-style＆＃34 ;，类似于Python具有自参数化成员函数的方式。典型的约定是通过调用变量self使这一点变得显而易见。</p><p> const std = @import（＆＃34; std＆＃34;）; const LikeAnObject = struct {值：i32，fn print（self：* LikeAnObject）void {std.debug。 print（＆＃34; value：{} \ n＆＃34 ;,。{self.value}）; }}; pub fn main（）void {var obj = LikeAnObject {.value = 47};对象打印（）;}</p><p>  通过使用const关键字将枚举组分配为类型来声明枚举。</p><p>  您可以将Enum的值设置为整数，但不会自动强制转换，必须使用@enumToInt或@intToEnum进行转换。</p><p> const std = @import（＆＃34; std＆＃34;）; const EnumType =枚举{EnumOne，EnumTwo，EnumThree = 3}; pub fn main（）void {std.debug。 print（＆＃34; One：{} \ n＆＃34 ;,。{EnumType.EnumOne}）;标准调试。 print（＆＃34; Two ?: {} \ n＆＃34 ;,。{EnumType.EnumTwo == .EnumTwo}）;标准调试。 print（＆＃34; Three ?: {} \ n＆＃34 ;,。{@enumToInt（EnumType.EnumThree）== 3}）;} </p><p>zig具有数组，它们是具有编译时已知长度的连续内存。您可以通过预先声明类型并提供值列表来对其进行初始化。您可以使用数组的len字段访问长度。</p><p>   const std = @import（＆＃34; std＆＃34;）; pub fn main（）void {var array：[3] u32 = [3] u32 {47，47，47}; //也有效：// var array = [_] u32 {47，47，47}; var invalid = array [4]; //错误：索引4在大小为3的数组之外。std.debug。 print（＆＃34; array [0]：{} \ n＆＃34 ;,。{array [0]}）;标准调试。 print（＆＃34; length：{} \ n＆＃34 ;,。{array.len}）;}</p><p> zig还具有切片，这些切片具有运行时已知的长度。您可以使用切片操作从数组或其他切片构造切片。与数组类似，切片具有一个len字段，该字段告诉您其长度。</p><p>   尝试访问超出分片范围的操作会导致运行时恐慌（这意味着您的程序将崩溃）。</p><p> const std = @import（＆＃34; std＆＃34;）; pub fn main（）void {var array：[3] u32 = [_] u32 {47，47，47}; var slice：[] u32 = array [0 ..2]; //也有效：// var slice = array [0..2]; var invalid = slice [3]; //恐慌：索引超出标准std.debug。 print（＆＃34; slice [0]：{} \ n＆＃34 ;,。{slice [0]}）;标准调试。 print（＆＃34; length：{} \ n＆＃34 ;,。{slice.len}）;}</p><p> 顺便说一句，我们已经将该东西传递给了std.debug.print的第二个参数匿名数组。在编译时，将分析参数的内容和类型，并将其匹配到您提供的（编译时）格式字符串，并且show zig知道如何使打印内容漂亮。</p><p> const std = @import（＆＃34; std＆＃34;）; pub fn main（）void {std.debug。 print（＆＃34; {} \ n＆＃34 ;,。{1，2}）; ＃错误：未使用的参数} </p><p>字符串文字是以NULL终止的utf8编码的const u8字节数组。 Unicode字符仅允许在字符串文字和注释中使用。</p><p>   const std = @import（＆＃34; std＆＃34;）; const string =＆＃34; hello世界＆＃34 ;; const world =＆＃34; world＆＃34 ;; pub fn main（）void {var slice：[] const u8 = string [0 ..5];标准调试。 print（＆＃34; string {} \ n＆＃34 ;,。{string}）;标准调试。 print（＆＃34; length {} \ n＆＃34 ;,。{world.len}）;标准调试。 print（＆＃34; null {} \ n＆＃34 ;,。{world [5]}）;标准调试。 print（＆＃34; slice {} \ n＆＃34 ;,。{slice}）;标准调试。 print（＆＃34; huh？{} \ n＆＃34 ;,。{string [0 ..7]}）;}</p><p>  const std = @import（＆＃34; std＆＃34;）; fn foo（）[] const u8 {//注意函数返回一个切片return＆＃34; foo＆＃34 ;; //但这是一个const数组。} pub fn main（）void {std.debug。 print（＆＃34; foo：{} \ n＆＃34 ;,。{foo（）}）;}</p><p>   const std = @import（＆＃34; std＆＃34;）; fn foo（v：i32）[] const u8 {if（v＆lt; 0）{return＆＃34; negative＆＃34 ;; } else {return＆＃34; non-negative＆＃34 ;; }} pub fn main（）void {std.debug。 print（＆＃34; positive {} \ n＆＃34 ;,。{foo（47）}）;标准调试。 print（＆＃34; negative {} \ n＆＃34 ;,。{foo（-47）}）;}</p><p>  const std = @import（＆＃34; std＆＃34;）; fn foo（v：i32）[] const u8 {开关（v）{0 =＆gt;返回＆＃34;零＆＃34;否则=＆gt;返回＆＃34;非零＆＃34; }} pub fn main（）void {std.debug。 print（＆＃34; 47 {} \ n＆＃34 ;,。{foo（47）}）;标准调试。 print（＆＃34; 0 {} \ n＆＃34 ;,。{foo（0）}）;}</p><p>  const std = @import（＆＃34; std＆＃34;）; pub fn main（）void {var array = [_] i32 {47，48，49};为（数组）|价值| {标准调试。 print（＆＃34; array {} \ n＆＃34 ;,。{value}）; }（数组）|值，索引| {标准调试。 print（＆＃34; array {}：{} \ n＆＃34 ;,。{index，value}）; } var slice = array [0 ..2];为（切片）|价值| {标准调试。 print（＆＃34; slice {} \ n＆＃34 ;,。{value}）; }（切片）|值，索引| {标准调试。 print（＆＃34; slice {}：{} \ n＆＃34 ;,。{index，value}）; }}</p><p>  const std = @import（＆＃34; std＆＃34;）; pub fn main（）void {var array = [_] i32 {47，48，49}; var索引：u32 = 0; while（index＆lt; 2）{std.debug。 print（＆＃34; value：{} \ n＆＃34 ;,。{array [index]}）;索引+ = 1; }} </p><p>错误是特殊的联合类型，您表示函数可以通过加前缀来出错！到前面。您只需简单地将其返回就可以抛出错误，就像正常返回一样。</p><p> const MyError = error {GenericError，//只是标识符列表，例如枚举。 OtherError}; pub fn main（）！ void {return MyError.GenericError;}</p><p> 如果编写的函数可能出错，则必须决定在返回时如何处理。 try是两个很常见的选项，它们非常懒惰，它们只是将错误转发为函数的错误。 catch可显式处理错误。</p><p>  const std = @import（＆＃34; std＆＃34;）; const MyError = error {GenericError}; fn foo（v：i32）！ i32 {if（v == 42）return MyError.GenericError; return v;} pub fn main（）！ void {// //捕获陷阱并处理冒泡的错误_ = foo（42）catch | err | {标准调试。 print（＆＃34; error：{} \ n＆＃34 ;,。{err}）; }; //尝试不要在这里被激活。标准调试。 print（＆＃34; foo：{} \ n＆＃34 ;,。{try foo（47）}）; //这最终将导致main打印错误跟踪并返回非零_ = try foo（42）;}</p><p>  const std = @import（＆＃34; std＆＃34;）; const MyError = error {GenericError}; fn foo（v：i32）！ i32 {if（v == 42）return MyError.GenericError; return v;} //注意，wrap_foo没有错误是安全的！因为//我们处理所有情况，并且不返回错误。 fn wrap_foo（v：i32）void {if（foo（v））|价值| {标准调试。 print（＆＃34; value：{} \ n＆＃34 ;,。{value}）; } else |错误| {标准调试。 print（＆＃34; error：{} \ n＆＃34 ;,。{err}）; }} pub fn main（）void {wrap_foo（42）; wrap_foo（47）;}</p><p>    这是一个多重调度的示例（尽管您已经在std.debug.print中看到了这一点，也许现在您可以想象它是如何实现的：</p><p> const std = @import（＆＃34; std＆＃34;）; fn foo（x：anytype）@TypeOf（x）{//注意，此if语句发生在编译时，而不是运行时。如果（@TypeOf（x）== i64）{返回x + 2; } else {return 2 * x; }} pub fn main（）void {var x：i64 = 47; var y：i32 = 47;标准调试。 print（＆＃34; i64-foo：{} \ n＆＃34 ;,。{foo（x）}）;标准调试。 print（＆＃34; i32-foo：{} \ n＆＃34 ;,。{foo（y）}）;} </p><p>const std = @import（＆＃34; std＆＃34;）; fn Vec2Of（comptime T：type）type {return struct {x：T，y：T};} const V2i64 = Vec2Of（i64）; const V2f64 = Vec2Of（f64）; pub fn main（）void {var vi = V2i64 {.x = 47，.y = 47}; var vf = V2f64 {.x = 47.0，.y = 47.0}; 标准调试。 print（＆＃34; i64 vector：{} \ n＆＃34 ;,。{vi}）; 标准调试。 print（＆＃34; f64 vector：{} \ n＆＃34 ;,。{vf}）;}  就是这样！ 现在，您知道了相当不错的Zig。 我没有涉及的一些（非常重要）的事情包括： </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gist.github.com/ityonemo/769532c2017ed9143f3571e5ac104e50">https://gist.github.com/ityonemo/769532c2017ed9143f3571e5ac104e50</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/zig/">#zig</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/const/">#const</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>