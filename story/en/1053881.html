<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Swift Array Design（2014） The Swift Array Design (2014)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Swift Array Design (2014)<br/>Swift Array Design（2014） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-22 08:43:58</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/e80b6e055898f05ae4007afadd4f22b2.png"><img src="http://img2.diglog.com/img/2021/3/e80b6e055898f05ae4007afadd4f22b2.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>tt { background-color: #f2f2f2;}div.content ul &gt; li { background: none; padding: 0 0 0 0.5em; list-style-image: none; list-style-type: disc;}a:link { color: #AB6023; font-weight: normal}   Performance equivalent to C arrays for subscript get/set ofnon-class element types is the most important performance goal.</p><p>tt {背景颜色：＃f2f2f2; div.Content UL＆GT;李{背景：无;填充：0 0 0 0.5EM;列表样式图像：无;列表样式类型：光盘;}}：链接{颜色：＃ab6023;字体重量：正常}正常}相当于下标get / set的C阵列的性能是最重要的表现目标。</p><p> It should be possible to receive an  NSArray from Cocoa,represent it as an  Array&lt;AnyObject&gt;, and pass it right back toCocoa as an  NSArray in O(1) and with no memory allocations.</p><p> 应该可以从CocoA接收NSArray，表示它作为数组＆lt; aforobject＆gt;，并将其转回tococoa作为o（1）中的nsArray，没有内存分配。</p><p> Arrays should be usable as stacks, so we want amortized O(1) appendand O(1) popBack. Together with goal #1, this implies a std::vector-like layout, with a reserved tail memory capacitythat can exceed the number of actual stored elements.</p><p> 阵列应该可以使用堆栈，因此我们要摊销O（1）ampendand o（1）popach。与目标＃1一起，这意味着STD :: vector-lible布局，保留尾部存储器容量可以超过实际存储元素的数量。</p><p> To achieve goals 1 and 2 together, we use static knowledge of theelement type: when it is statically known that the element type is nota class, code and checks accounting for the possibility of wrapping an NSArray are eliminated. An  Array of Swift value types alwaysuses the most efficient possible representation, identical to that of ContiguousArray.</p><p> 为了达到目标1和2，我们使用静态知识所以静态知识类型：当静态已知元素类型是NOTA类时，代码和检查会考虑包装NSARRAY的可能性。一系列SWIFT值类型总是最有效的表示表示，与TominigureArray相同。</p><p>   Swift provides three generic array types, all of which have amortizedO(1) growth. In this document, statements about  ArrayType applyto all three of the components.</p><p>   SWIFT提供了三种通用数组类型，所有这些都具有amortizedo（1）的增长。在本文档中，关于ArrayType的语句适用于所有三个组件。</p><p> ContiguousArray&lt;Element&gt; is the fastest and simplest of the three--usethis when you need &#34;C array&#34; performance. The elements of a ContiguousArray are always stored contiguously in memory.</p><p> Contegulearray＆lt;元素＆gt;当你需要的时候是三个 -  useThis的最快和最简单的＆＃34; c array＆＃34;表现。关节阵列的元素始终在内存中连续存储。</p><p> Array&lt;Element&gt; is like  ContiguousArray&lt;Element&gt;, but optimized forefficient conversions from Cocoa and back--when  Element can be a classtype,  Array&lt;Element&gt; can be backed by the (potentially non-contiguous)storage of an arbitrary  NSArray rather than by a Swift ContiguousArray.  Array&lt;Element&gt; also supports up- and downcastsbetween arrays of related class types. When  Element is known to be anon-class type, the performance of  Array&lt;Element&gt; is identical to thatof  ContiguousArray&lt;Element&gt;.</p><p> 数组＆lt;元素＆gt;就像关节阵列＆lt;元素＆gt;，但是从可可和背部进行了优化的前置机转换 - 当元素可以是classtype，array＆lt;元素＆gt;可以由任意NsArray的（潜在的非连续）存储来支持，而不是通过SWIFT Contigulearray来支持。数组＆lt;元素＆gt;还支持相关类类型的相关类阵列上下游。当已知元素是Anon-Class类型时，阵列的性能＆lt;元素＆gt;与Compitulearray＆lt;元素＆gt;。 </p><p> ArraySlice&lt;Element&gt; is a subrange of some  Array&lt;Element&gt; or ContiguousArray&lt;Element&gt;; it&#39;s the result of using slice notation,e.g.  a[7...21] on any Swift array  a. A slice always hascontiguous storage and &#34;C array&#34; performance. Slicing an ArrayType is O(1) unless the source is an  Array&lt;Element&gt; backed byan  NSArray that doesn&#39;t supply contiguous storage.</p><p>arrayslice＆lt;元素＆gt;是某些阵列＆lt;元素＆gt的子范围;或关连阵列＆lt;元素＆gt ;;它＆＃39; s使用切片表示法的结果，例如。任何SWIFT阵列a上的[7 ... 21]。切片始终具有张有的储存和＆＃34; c array＆＃34;表现。切片ArrayType是O（1），除非源是数组＆lt;元素＆gt;支持＆＃39; t提供连续存储的NSArray。</p><p> ArraySlice is recommended for transient computations but not forlong-term storage. Since it references a sub-range of some sharedbacking buffer, a  ArraySlice may artificially prolong the lifetime ofelements outside the  ArraySlice itself.</p><p> 建议为瞬态计算，但不符合术语存储。由于它引用了一些共享缓冲区的子范围，因此arrayslice可以人工延长亚拉丝本身外部的寿命。</p><p>       Every class type or  @objc existential (such as  AnyObject) is bridged to Objective-C and  bridged back to Swift via theidentity transformation, i.e. it is  bridged verbatim.</p><p>       每个类类型或@objc存在（例如AnyObject）桥接到Objective-C并通过当Iidentity转换桥接到SWIFT，即它桥接逐字。</p><p> A type  T that is not  bridged verbatim can conform to BridgedToObjectiveC, which specifies its conversions to and fromObjectiveC:</p><p> 不桥接逐字的类型T可以符合BridgedToObjectivec，它将其转换与fromObjectIvec指定：</p><p> protocol _BridgedToObjectiveC { typealias _ObjectiveCType: AnyObject func _bridgeToObjectiveC() -&gt; _ObjectiveCType class func _forceBridgeFromObjectiveC(_: _ObjectiveCType) -&gt; Self}</p><p> 协议_BridgedToObjectivec {typeAleias _Objectivectype：AnyObject Func _bridgetoObjectivec（） - ＆gt; _objectivectype类func _forcebridgefromobjectivec（_：_objectivectype） - ＆gt;自己}</p><p> Classes and  @objc existentials shall not conform to _BridgedToObjectiveC, a restriction that&#39;s not currentlyenforceable at compile-time.</p><p> 类和@objc存在性不应符合_bridgedtoObjectIvec，这是一个在编译时无法定时的限制。</p><p> Some generic types ( ArrayType &lt;T&gt; in particular) bridge toObjective-C only if their element types bridge. These types conformto  _ConditionallyBridgedToObjectiveC:</p><p> 某些通用类型（arrayType＆lt; t＆gt;特别是）kidebjective-c ockobjective-c ock。这些类型符合_conditionallyBridgedToObjectIvec： </p><p> protocol _ConditionallyBridgedToObjectiveC : _BridgedToObjectiveC { class func _isBridgedToObjectiveC() -&gt; Bool class func _conditionallyBridgeFromObjectiveC(_: _ObjectiveCType) -&gt; Self?}</p><p>协议_conditionallyBridgedToObjectivec：_bridgedtoObjectivec {class func _isbridgedtoObjectivec（） - ＆gt; BOOL Class Func _conditionallyBridgeFromObjectIvec（_：_Objectivectype） - ＆gt;自己？}</p><p> Bridging from, or  bridging back to, a type  T conforming to _ConditionallyBridgedToObjectiveC when T._isBridgedToObjectiveC() is  false is a user programmingerror that may be diagnosed atruntime.  _conditionallyBridgeFromObjectiveC can be used to attemptto bridge back, and return  nil if the entire object cannot bebridged.</p><p> 桥接或桥接回到符合_conditionallbridgedToObjectivec（当T._IsbridgedToObjectivec（）为false时的T型T是一个用户编程，可以诊断atruntime。 _ConditionallyBridgridFromObjectIvec可用于尝试桥接，如果整个对象无法牢记，则返回nil。</p><p> then a value  x of type  T is  bridged as T._ObjectiveCType via  x._bridgeToObjectiveC(), and an object y of  T._ObjectiveCType is  bridged back to  T via T._forceBridgeFromObjectiveC(y)</p><p> 然后，T类型的值x通过x._bridgetoObjectivec（）桥接为t._objectivectype，并且将t._objectivectivectivectype的对象y桥接回T通过t._forcebridgefromobjectivec（y）</p><p>   From here on, this document deals only with  Array itself, and not Slice or  ContiguousArray, which support a subset of  Array&#39;s conversions. Future revisions will add descriptions of  Sliceand  ContiguousArray conversions.</p><p>   从这里开始，本文档仅处理数组本身，而不是切片或关节array，这支持阵列和＃39; s转换的子集。未来的修订将添加Sliceand Contiguving array转换的描述。</p><p>   In these definitions,  Base is  AnyObject or a trivial subtypethereof,  Derived is a trivial subtype of  Base, and  Xconforms to  _BridgedToObjectiveC:</p><p>   在这些定义中，基础是AnyObject或级别的子类型，导出是基础的琐碎子类型，以及_bridgedToObjectec的Xconforms：</p><p> Trivial bridging implicitly converts  [Base] to NSArray in O(1). This is simply a matter of returning theArray&#39;s internal buffer, which is-a  NSArray.</p><p> 琐碎的桥接隐式地将[基本]转换为o（1）中的nsArray。这只是返回TheArray＆＃39; s内部缓冲区的问题，即它是一个nsarray。</p><p> Trivial bridging back implicitly converts  NSArray to [AnyObject] in O(1) plus the cost of calling  copy() onthe  NSArray.  [1]</p><p> 琐碎的桥接背面隐式地将NSArray转换为O（1）中的[AnyObject]加上NSArray上调用Copy（）的成本。 [1] </p><p> Either type of implicit conversion may be combined with trivial bridging in an implicit conversion to  NSArray.</p><p>可以将任一类型的隐式转换组合在隐式转换到NSArray中，可以与普通桥接组合。</p><p> Checked bridging back converts  [T] to  [X]? where X._ObjectiveCType is  T or a trivial subtype thereof.</p><p> 检查桥接返回将[t]转换为[x]？其中x._objectivectype是t或其琐碎的子类型。</p><p> Forced conversions convert  [AnyObject] or  NSArray to [T] implicitly, in bridging thunks between Swift and Objective-C.</p><p> 强制转换将[AnyObject]或NSArray Implication地转换为[T]，在SWIFT和Objective-C之间的桥接Thunks中。</p><p> For example, when a user writes a Swift method taking  [NSView],it is exposed to Objective-C as a method taking  NSArray, whichis force-converted to  [NSView] when called from Objective-C.</p><p> 例如，当用户写入SWIFT方法时，将[NSVIEW]拍摄时，它被暴露于Object-C，以便在Objective-C调用时使用NSArray的方法，该方法转换为[NSView]。</p><p>  A forced conversion where any element fails to convert is considereda user programming error that may trap. In the case of forceddowncasts, the trap may be  deferred to the point where an offendingelement is accessed.</p><p>  强制转换，其中任何元素都无法转换，例如可以陷阱的用户编程错误。在强制播放的情况下，陷阱可能被推迟到访问违禁的程度。</p><p> Both checked and forced downcasts may be combined with  trivialbridging back in conversions from  NSArray.</p><p> 检查和强制衰落都可以与NSArray的转换中的琐碎桥式组合。</p><p>       When up-casting an  [Derived] to  [Base], a buffer of Derived object can simply be  unsafeBitCast&#39;ed to a bufferof elements of type  Base--as long as the resulting buffer is nevermutated. For example, we cannot allow a  Base element to beinserted in the buffer, because the buffer&#39;s destructor will destroythe elements with the (incorrect) static presumption that they have Derived type.</p><p>       当上施加[派生]到[Base]时，派生对象的缓冲器可以简单地是不安全的BITCAST＆＃39;编辑到类型基础的BUFFEROF  - 只要从未介绍生成的缓冲区。例如，我们不能允许基本元素在缓冲区中捕食，因为缓冲区＆＃39; s析构函数将摧毁它们具有衍生类型的（不正确）静态推定的元素。 </p><p> Furthermore, we can&#39;t (logically) copy the buffer just prior tomutation, since the  [Base] may be copied prior to mutation,and our shared subscript assignment semantics imply that all copiesmust observe its subscript assignments.</p><p>此外，我们可以＆＃39; t（逻辑上）只能在突变之前复制缓冲区，因为可以在突变之前复制[基础]，并且我们的共享下标分配语义意味着所有复制符号遵守其下标作业。</p><p> Therefore, converting  [T] to  [U] is akin toresizing: the new  Array becomes logically independent. To avoidan immediate O(N) conversion cost, and preserve shared subscriptassignment semantics, we use a layer of indirection in the datastructure. Further, when  T is a subclass of  U, theintermediate object is marked to prevent in-place mutation of thebuffer; it will be copied upon its first mutation:</p><p> 因此，将[t]转换为[U]是类似的，：新阵列变为逻辑上独立。为了避免立即O（n）转换成本，并保留共享的Subscriptassigmment语义，我们在数据结构中使用一层间接。此外，当T是U的子类时，标记为防止缓冲的原始突变;它将被复制在第一个突变之上：</p><p>    In forced downcasts, if any element fails to have dynamic type  Derived,it is considered a programming error that may cause a trap. Sometimeswe can do this check in O(1) because the source holds a known buffertype. Rather than incur O(N) checking for the other cases, the newintermediate object is marked for deferred checking, and all elementaccesses through that object are dynamically typechecked, with a trapupon failure (except in  -Ounchecked builds).</p><p>    在强制沮丧中，如果任何元素未能导出动态类型，则它被视为可能导致陷阱的编程错误。有时我们可以在O（1）中进行此检查，因为源持有已知的BufferType。而不是引起O（n）检查其他情况，Newintermediate对象被标记为延期检查，并且通过该对象的所有ExpertyAccess都是动态打印的，具有Trapupon失败（在-OUNCHECKED构建中除外）。</p><p> When the resulting array is later up-cast (other than to a type thatcan be validated in O(1) by checking the type of the underlyingbuffer), the result is also marked for deferred checking.</p><p> 当由此产生的阵列稍后推动（除了通过检查底层缓冲器的类型以O（1）中验证的类型），结果也标记为延迟检查。</p><p>  This  copy() may amount to a retain if the  NSArrayis already known to be immutable. We could eventually optimize outthe copy if we can detect that the  NSArray is uniquelyreferenced. Our current unique-reference detection applies only toSwift objects, though.</p><p>  如果已知已知是不可变的，则此副本（）可能会纳入保留。如果我们可以检测到NSArray无唯一参考，我们最终可以优化副本。但是，我们目前的唯一参考检测仅适用于TOSWIFT对象。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/apple/swift/blob/main/docs/Arrays.rst">https://github.com/apple/swift/blob/main/docs/Arrays.rst</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/array/">#array</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>