<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我的bash中正在运行什么？ （2014年） What am I running inside my bash? (2014)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What am I running inside my bash? (2014)<br/>我的bash中正在运行什么？ （2014年） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-29 02:25:30</div><div class="page_narrow text-break page_content"><p>For the TL;DR crowd:I desperately needed to extract the complete (and very lengthy) command line I had written 6 months ago in a bash shell - which was still running under  screen. Read on to see how I eventually made it...</p><p>对于TL; DR人群：我非常需要提取我六个月前在bash shell中编写的完整（且非常冗长）的命令行-该命令行仍在屏幕下运行。继续阅读以了解我最终是如何做到的...</p><p> Let&#39;s assume you are using bash as your daily shell. You&#39;ve heard lots of worrying things lately about it&#39;s safety. But that&#39;s not what&#39;s bothering you.</p><p> 假设您使用bash作为日常外壳。您最近听说过很多有关它的安全性的令人担忧的事情。但这不是困扰您的原因。</p><p> What&#39;s bothering you is that some months ago you abused the holy UNIX principles with it. It couldn&#39;t be helped. You were asked to implement a daemon that monitors a folder for incoming &#34;stuff&#34;. The clients upload files there, and you were expected to do various things with them.</p><p> 困扰您的是，几个月前，您滥用了神圣的UNIX原理。这无济于事。您被要求实现一个守护进程，该守护进程监视文件夹中是否有传入的＆＃34; stuff＆＃34;。客户端将文件上传到那里，您应该对它们执行各种操作。</p><p>  So you hacked at a frantic pace, and made a lengthy bash pipeline that did it all. Loops over the input files, pipes, redirects - you name it. And having no time to fool around with  supervisord, you pasted &#34;The Magic CmdLine (TM)&#34; inside a  screen, where your bash patiently started chugging along... And you moved to the next emergency on your list - which naturally, was scheduled for yesterday too...</p><p>  因此，您以疯狂的速度进行了黑客攻击，并制作了冗长的bash管道来完成所有操作。循环输入文件，管道，重定向-命名。而且您没有时间闲逛主管，您粘贴了＆＃34; The Magic CmdLine（TM）＆＃34;在屏幕上，您的bash耐心地开始颤抖着……然后您移至列表中的下一个紧急事件-自然，该紧急事件也定于昨天进行...</p><p>  The Magic CmdLine (TM) obediently worked and worked. You checked its behaviour during the first couple of weeks - and just as expected, any errors on incoming files sent by the clients, were reported on its stderr, which your invocation conveniently redirected to some error log file. All was well.</p><p>  Magic CmdLine（TM）顺服地工作了。您在头几周内检查了它的行为-就像预期的那样，客户端发送的传入文件上的任何错误都报告在其stderr上，您的调用可方便地将其重定向到某个错误日志文件。一切都好。</p><p>  And suddenly, you remembered it. Only now (you moron!) you realize - horror of horrors - that you&#39;ve forgotten all about The Magic CmdLine (TM). Arguments, redirects, everything down the mental drain. Gulp.</p><p>  突然间，你想起了。直到现在（您这个笨蛋！），您才意识到-恐怖的恐怖-您已完全忘记了Magic CmdLine（TM）。争论，重新定向，一切都花在了精神上。喝了</p><p> You are a single reboot away from, erm, a well-deserved flogging from your boss (translation:  screen or no  screen, The Magic CmdLine (TM) that you painstakingly investigated 6 months ago, will be forever lost... when the next reboot happens).</p><p> 您只需重新启动一次，即可摆脱老板的应有之f（错误：屏幕显示或不显示屏幕，六个月前您认真研究过的Magic CmdLine（TM）），它将永远丢失……下一次重新启动发生）。 </p><p>  You reattach to the magic  screen, fingers crossed. You hit ESC and scroll back up, hoping to see the magic line invocation... but to no avail. The error reports it generated were written all over  screen&#39;s scrollback buffer - you can&#39;t scroll all the way up to the invocation line.</p><p>您重新回到魔术屏幕，手指交叉。您按下ESC并向上滚动，希望看到魔术线的调用...但无济于事。它生成的错误报告被写在整个屏幕的回滚缓冲区中-您无法一直滚动到调用行。</p><p> Heck, there  has to be a way to get to that line.  ps aux | grep ... doesn&#39;t help - it shows the currently running  piece of the command you wrote. You want the whole shebang.</p><p> 哎呀，必须有一条通往那条线的方法。 ps aux | grep ...没有帮助-它显示了您编写的命令当前正在运行的部分。你想要整个shebang。</p><p>  I have a long running bash instance (inside a screen session) that is executing a complex set of commands inside a loop (with each loop doing pipes, redirects, etc). The long command line was written inside the terminal - it&#39;s not inside any script. Now, I know the bash process ID, and I have root access - how can I see the exact command line being executed inside that bash?</p><p>  我有一个运行时间很长的bash实例（在屏幕会话中），它在一个循环内执行一组复杂的命令（每个循环执行管道，重定向等）。长长的命令行写在终端内部-不在任何脚本内。现在，我知道了bash的进程ID，并且我具有root访问权限-如何查看在该bash中执行的确切命令行？</p><p>  # In shell A, this sequence of commands was run - under screen: $ echo  $$ 8909 $  while   true   ;   do  echo  1   ;  echo  2 &gt; /dev/null  ;  sleep  30   ;   done # In shell B, I want to do some magic based on the 8909 PID, and get the # string... &#34;while true ; do echo 1 ; echo 2&gt;/dev/null ; sleep 30 ; done&#34;</p><p>  ＃在外壳A中，此命令序列在屏幕下运行：$ echo $$ 8909 $ while true;做回声1;回声2 / dev / null;睡30;在外壳B中，我想基于8909 PID做一些魔术，并获得＃字符串...＆＃34; while true;做回声1;回声2＆gt; / dev / null;睡30;完成＆＃34;</p><p>  One tells you to search the process list - which would only give  sleep in this example ( and in your real case, the currently running part of your complex Magic CmdLine (TM)).</p><p>  一个告诉您搜索进程列表-在此示例中，该列表只会使您进入睡眠状态（在您的实际情况下，这是复杂的Magic CmdLine（TM）当前正在运行的部分）。</p><p>      You download the bash source code, untar, and hoping you can somehow recover the history information kept inside the running instance of bash, you  grep for dear life:</p><p>      您下载了bash源代码，untar，并希望可以某种方式恢复保存在bash运行实例中的历史信息，您可以使用grep延长生命：</p><p>  Hmm...  histfile.c - isn&#39;t our dear beloved  bash saving history into a file? Opening inside VIM, searching...</p><p>  嗯... histfile.c-我们亲爱的bash将历史记录保存到文件中不是吗？在VIM内部打开，搜索... </p><p>    Spawn GDB - and activate God mode! That is, attach to the running bash, and call  write_history on our own - it conveniently takes the filename to save in as an argument!</p><p>生成GDB-并激活上帝模式！也就是说，附加到正在运行的bash上，并自行调用write_history-它方便地将文件名保存为参数！</p><p> $ gdb --pid  8909 ... Loaded symbols  for  /lib/i 386 -linux-gnu/i 686 /cmov/libnss_files . so . 2 0xb76e7424   in   __kernel_vsyscall () ( gdb )  call write_history ( &#34;/tmp/foo&#34; ) $1   =   0 ( gdb )  detach ( gdb )  q  $ tail - 1  /tmp/foo while   true   ;   do  echo  1   ;  echo  2 &gt; /dev/null  ;  sleep  30   ;   done</p><p> $ gdb --pid 8909 ...为/ lib / i 386 -linux-gnu / i 686 / cmov / libnss_files加载的符号。这样。 2 __kernel_vsyscall（）（gdb）中的0xb76e7424调用write_history（＆＃34; / tmp / foo＆＃34;）$ 1 = 0（gdb）detach（gdb）q $ tail-1 / tmp / foo为true;做回声1;回声2 / dev / null;睡30;完成</p><p>  You answer your own question in StackOverflow. The other answers are somehow deleted, apparently ashamed of your monstrous luck.</p><p>  您在StackOverflow中回答自己的问题。其他答案以某种方式被删除，显然为您的厄运感到羞耻。</p><p>    You SSH into the remote machine running the thing. The bash process running the thing has PID 53165.</p><p>    您通过SSH进入运行Thing的远程计算机。运行Thing的bash进程具有PID 53165。</p><p>   $ ssh IamInHell [ ttsiod@IamInHell ]  su - .... [ root@IAmInHell  ~]  gdb --pid  53165 GNU gdb  ( GDB )  Red Hat Enterprise Linux  ( 7.2 - 60 . el6_4 . 1 ) ... Attaching to process  53165 /bin/bash  ( deleted ):  No such file or directory</p><p>   $ ssh IamInHell [ttsiod @ IamInHell] su-.... [root @ IAmInHell〜] gdb --pid 53165 GNU gdb（GDB）Red Hat Enterprise Linux（7.2-60。el6_4。1）...附加到进程53165 / bin / bash（已删除）：没有这样的文件或目录</p><p>  The stupid ShellShock thingie forced everyone to update their bash... The automatic updates in that machine  removed the binary of the old bash, and installed a new one.</p><p>  愚蠢的ShellShock事情迫使每个人都更新其bash ...该计算机中的自动更新删除了旧bash的二进制文件，并安装了一个新bash。</p><p> So even though the process is still up, 6 months later... the binary filefrom which it was spawned (and which GDB searches for, to get the address of  write_history) can&#39;t be found.</p><p> 因此，即使该过程仍在进行中，但6个月后……仍无法找到生成该二进制文件的二进制文件（以及GDB搜索该二进制文件以获取write_history的地址）。 </p><p>    But I also know my OS - I know it well. I can get the content of that old binary  from memory - via the  proc interface:</p><p>但是我也知道我的操作系统-我非常了解。我可以通过proc接口从内存中获取旧二进制文件的内容：</p><p> [ root@IamInHell ]  lsof  + L1  |  grep bash  |  grep  53165 bash  53165  root txt REG  253 , 0   938832   0   791023  /bin/bash  ( deleted ) [ root@IamInHell ]  cat /proc / 53165 /exe  &gt;  /tmp/oldBash</p><p> [root @ IamInHell] lsof + L1 | grep bash | grep 53165 bash 53165 root txt REG 253，0 938832 0 791023 / bin / bash（已删除）[root @ IamInHell] cat / proc / 53165 / exe＆gt; / tmp / oldBash</p><p>  [ root@IamInHell ]  gdb --pid  53165  /tmp/oldBash ... Loaded symbols  for  /lib 64 /libnss_files . so . 2 0x0000003d37aac8be   in   waitpid ()  from /lib 64 /libc . so . 6 ... ( gdb )  call write_history ( &#34;/tmp/foo&#34; ) $1   =   0 ( gdb )  detach Detaching from program :  /tmp/oldBash ,  process  53165 ( gdb )  q [ root@IamInHell ]  tail - 1  /tmp/foo  while   true   ;   do   ...</p><p>  [root @ IamInHell] gdb --pid 53165 / tmp / oldBash ...为/ lib 64 / libnss_files加载的符号。这样。 2 0x0000003d37aac8be位于/ lib 64 / libc的waitpid（）中。这样。 6 ...（gdb）调用write_history（＆＃34; / tmp / foo＆＃34;）$ 1 = 0（gdb）detach从程序中分离：/ tmp / oldBash，进程53165（gdb）q [root @ IamInHell] tail -1 / tmp / foo为true时；做...</p><p> Dancing around my desk. The people around me are looking at me, puzzled and wondering about my mental state.</p><p> 在我的桌子周围跳舞。我周围的人看着我，感到困惑并想知道我的精神状态。</p><p>   To ease the pain of my future self - and potentially the pain of other fellow coders / admins, I  write a script automating all this.</p><p>   为了减轻我未来的痛苦，并减轻其他编码人员/管理员的痛苦，我编写了一个脚本来自动完成所有这些工作。</p><p> And decide it&#39;s been quite a while since I posted something on my blog :-)</p><p> 自从我在自己的博客上发布了一些东西以来，就已经决定了很长时间了：-)</p><p> The comments on this website require the use of JavaScript. Perhaps your browser isn&#39;t JavaScript capable or the script is not being run for another reason. If you&#39;re interested in reading the comments or leaving a comment behind please try again with a different browser or from a different connection.</p><p> 本网站上的评论要求使用JavaScript。可能您的浏览器不支持JavaScript，或者由于其他原因而未在运行脚本。如果您有兴趣阅读评论或留下评论，请使用其他浏览器或其他连接重试。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.thanassis.space/bashheimer.html">https://www.thanassis.space/bashheimer.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/running/">#running</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bash/">#bash</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>