<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>调试器工作原理：获取和设置x86寄存器</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">调试器工作原理：获取和设置x86寄存器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-24 07:31:15</div><div class="page_narrow text-break page_content"><p>在本文中，我将简要描述用于在32位和64位x86CPU上转储和恢复不同类型寄存器的方法。第一部分将重点介绍通用寄存器、调试寄存器和浮点寄存器，直至SSE扩展提供的XMM寄存器。我将解释如何通过ptrace(2)接口获取它们的值。</p><p>Ptrace(2)API通常在所有现代BSD系统和Linux中使用，因为它们都是从4.3BSD中设计和实现的原始表单中派生出来的。本文主要关注FreeBSD和NetBSD系统。尽管如此，其他操作系统(如OpenBSD、蜻蜓BSD或Linux)的用户仍然可以从本文中获益，因为基本原理是相同的，并且代码示例旨在很容易地适用于其他平台。</p><p>单个CPU(在现代硬件中：如果超线程可用，则为CPU核心或CPU线程)一次只能执行一个程序线程。为了能够同时运行多个进程和线程，操作系统必须执行上下文切换，即周期性地挂起当前运行的线程，保存其状态，恢复另一个线程保存的状态并恢复它，保存和恢复处理器寄存器的值在上下文切换中起着重要的作用。重要的是，该进程对于要切换的进程是完全透明的，并且在正确实现的内核中，应该没有程序可以察觉到的副作用。</p><p>由于多种原因，调试器可能需要检查被调试程序的寄存器集。通过检查程序计数器，它能够确定源代码中将继续执行的位置，并通过更改它可以控制执行。堆栈指针是内省存储在堆栈上的变量所必需的，而其余的寄存器本身可以保存变量。</p><p>一组特殊的x86寄存器是调试寄存器。它们不能由程序本身访问；但是，它们可以由调试器读取或写入。它们允许在正在执行的代码上设置硬件辅助断点(指令执行陷阱)，并在变量上设置观察点(读和/或写操作陷阱)。</p><p>术语“通用寄存器”有点含糊，从狭义上讲，它指的是少数几个(i386上8个，AMD64上16个)可用于存储任意数据(通常是整数或指针)的基线寄存器。在更广泛的意义上，它意味着处理器体系结构中的所有基线寄存器，历史上不包括浮点寄存器和特殊类型的寄存器。在x86上，这包括“狭义”通用寄存器、程序计数器(EIP/RIP)、段寄存器和标志寄存器。</p><p>可以直接复制大多数通用寄存器，例如使用MOV指令，或通过推送将其推送到堆栈上。可以使用LEA指令复制EIP/RIP寄存器，并通过JMP恢复。可以通过PUSHFD/PUSHFQ将标志寄存器推送到堆栈，然后通过POPFD/POPFQ从堆栈中弹出标志寄存器。</p><p>下面的清单演示了一个程序，该程序在执行过程中在任意点捕获allamd64GPRS的值，并在从汇编返回后打印这些值。</p><p>#include&lt；stdio.h&gt；#include&lt；stdint.h&gt；enum{R_Rax，R_RBX，R_RCX，R_RDX，R_RSI，R_RDI，R_RBP，R_RSP，R_R8，R_R9，R_R10，R_R11，R_R12，R_R13，R_R14，R_R15，R_RIP，R_RFLAGS，R_Length}；enum{S_CS，S_DS，S_ES，S_FS，S_GS，S_SS，S_Length}；Int main(){uint64_t GPR[R_LENGTH]；uint16_t seg[S_LENGTH]；ASM易失性(/*用随机数据填充寄存器*/&#34；mov$0x0102030405060708，%%rax\n\t&#34；&#34；mov$0x1112131415161718，%%rbx\n\t&#34；&#34；mov$0x2122232425262728，%%rcx\n\t&#34；&#34；mov$0x3132333435373738，%%rdx\n\t&#34；&#34；mov$0x2122232425262728，%%rcx\n\t&#34；&#34；mov$0x3132333435373738，%rdx\n\t&#34；MOV$0x4142434445464748，%%RSI\n\t&#34；&#34；mov$0x5152535455565758，%%RDI\n\t&#34；/*RBP用于帧指针，RSP是堆栈指针*/&#34；mov$0x8182838485868788，%%R8\n\t&#34；&#34；mov$0x9192939495969798，%%R9\n\t&#34；&#34；mov$0xa1a1a2a3a4a5a6a7a8，%%Rb1b2b3b4b5b6b7b8，%%R11\t&#34；&#34；mov$0x9192939495969798，%%R9\n\t&#34；&#34；mov$0xa1a2a2a4a5a6a7a8，%%Rb1b2b3b4b5b6b7b8，%r11\t&#34；&#34；mov$0x9192939495969798，%%R9\n\t&#34；&#34。&#34；mov$0xc1c2c3c4c5c6c7c8，%%r12\n\t&#34；&#34；mov$0xd1d2d3d4d5d5d6d7d8，%%r13\n\t&#34；&#34；mov$0xe1e2e3e4e5e6e7e8，%r14\n\t&#34；&#34；mov$0xf1f2f3f4f5f6f7f8，%%R15\n\t&#34；/*GPRS*/&34；mov%%rax，%[rax]\n\t&34；&#34；MOV%%RBX，%[RBX]\n\t&#34；&#34；mov%%RCX，%[RCX]\n\t&#34；&#34；mov%%RDX，%[RDX]\n\t&#34；&#34；mov%%RSI，%[RSI]\n\t&#34；&#34；mov%RDI，%[RDI]\n\t&#34；&#34；MOV%%RBP，%[RBP]\n\t&#34；&#34；mov%%RSP，%[RSP]\n\t&#34；&#34；mov%%R8，%[R8]\n\t&#34；&#34；mov%%R9，%[R9]\n\t&#34；&#34；mov%R10，%[R10]\n\t&#34；&#34；MOV%%R11，%[R11]\n\t&#34；&#34；mov%%R12，%[R12]\n\t&#34；&#34；mov%%R13，%[R13]\n\t&#34；&#34；mov%%R14，%[R14]\n\t&#34；&#34；mov%R15，%[R15]\n\t&#34；/*转储RIP*/#34；LEA(%%rip)，%%rbx\n\t&#34；&#34；mov%%rbx，%[rip]\n\t&#34；&#34；mov%[rbx]，%%rbx\n\t&#34；/*转储段寄存器*/&#34；mov%%cs，%[cs]\n\t&#34；&#34；mov%%ds，%[ds]\n\t&#34；&#34；Mov%%es，%[es]\n\t&#34；&#34；mov%%fs，%[fs]\n\t&#34；&#34；mov%%gs，%[gs]\n\t&#34；&#34；mov%%ss，%[ss]\n\t&#34；/*dump RFLAGS*/&#34；push fq\n\t&#34；&#34；popq%[rflag]\n\t&#34；：[RAX]&#34；=m&#34；(GPR[R_RAX])，[RBX]&#34；=m&#34；(GPR[R_RBX])，[RCX]&#34；=m&#34；(GPR[R_RCX])，[RDX]&#34；=m&#34；(GPR[R_RDX])，[RSI]&#34；=m&#34；(GPR[R_RSI])，[RDI]&#34；=m&#34；(GPR[R_RDI])，[RBP]&#34；=m&#34；(GPR[R_RBP])，[RSP]&#34；=m&#34；(GPR[R_RSP])，[R8]&#34；=m&#34；(GPR[R_R8])，[R9]&#34；=m&#34；(GPR[R_R9])，[R10]&#34；=m&#34；(GPR[R_R10])，[R11]&#34；=m&#34；(GPR[R_R11])，[R12]&#34；=m&#34；(GPR[R_R12])，[R13]&#34；=m&#34；(GPR[R_R13])，[R14]&#34；=m&#34；(GPR[R_R14])，[R15]&#34；=m&#34；(GPR[R_R15])，[RIP]&#34；=m&#34；(GPR[R_RIP])，[rflag]&#34；=m&#34；(GPR[R_RFLAGS])，[cs]&#34；=m&#34；(seg[S_CS])，[ds]&#34；=m&#34；(seg[S_DS])，[ES]&#34；=m&#34；(seg[S_ES])，[fs]&#34；=m&#34；(seg[S_FS])，[gs]&#34；=m&#34；(seg[S_GS])，[ss]&#34；=m&#34；(seg[S_SS])：：&#34；%rax&#34；，&#34；%rbx&#34；，&#34；%rcx&#34；，&#34；%rdx&#34；；，&#34；%RSI&#34；，&#34；%RDI&#34；，&#34；%R8&#34；，&#34；%R9&#34；，&#34；%R10&#34；，&#34；%R11&#34；，&#34；%R12&#34；，&#34；%R13&#34；，&#34；%R14&#34；，&#34；%R15&#34；，&#34；Memory&#34；)；printf(&#34；rax=0x%016lx\n&#34；，GPR[R_RAX])；printf(&#34；rbx=0x%016lx\n&#34；，GPR[R_RBX])；printf(&#34；rcx=0x%016lx\n&#34；，GPR[R_RCX])；printf(&#34；RDX=0x%016lx\n&34；，GPR[R_RDX])；printf(&#34；RSI=0x%016lx\n&34；，GPR[R_RSI])；printf(&#34；RDI=0x%016lx\n&#34；，GPR[R_RDI])；printf(&#34；RBP=0x%016lx\n&#34；，GPR[R_RBP])；printf(&#34；RSP=0x%016lx\n&#34；，GPR[R_RSP])；printf(&#34；R8=0x%016lx\n&#34；GPR[R_R8])；printf(#34；R9=0x%016lx\n&34；#34；R8=0x%016lx\n&34；)；printf(&#34；R8=0x%016lx\n&#34；)；printf(#&34；R9=0x%016lx\n&34；，GPR[R_R9])；printf(&#34；R10=0x%016lx\n&#34；，GPR[R_R10])；printf(&#34；R11=0x%016lx\n&#34；，GPR[R_R11])；printf(&#34；r12=0x%016lx\n&#34；，GPR[R_R12])；printf(&#34；R13=0x%016lx\n&#34；GPR[R_R13])；printf(#34；R14=0x%016lx\n&34；#34；R13=0x%016lx\n&#34；)；printf(&#34；R13=0x%016lx\n&#34)；printf(#&34；R14=0x%016lx\n&34；，GPR[R_R14])；printf(&#34；R15=0x%016lx\n&#34；，GPR[R_R15])；printf(&#34；RIP=0x%016lx\n&#34；，GPR[R_RIP])；printf(&#34；cs=0x%04x\n&#34；，seg[S_CS])；printf(&#34；ds=0x%04x\n&#34；，seg[S_DS])；printf(&#34；es=0x%04x\n&#34；，seg[S_ES])；printf(&#34；fs=0x%04x\n&#34；，seg[S_FS])；printf(&#34；gs=0x%04x\n&#34；，seg[S_GS])；printf(&#34；ss=0x%04x\n&#34；，seg[S_SS])；printf(&#34；rflag=0x%016lx\n&34；，gpr[R_RFLAGS])；Return 0；}。</p><p>FreeBSD和NetBSD都使用PT_GETREGS请求从程序中获取GPRS的值，并使用PT_SETREGS更新它们。请求将指向struct reg的指针作为参数。</p><p>在FreeBSD上，i386和AMD64都将单独的寄存器列表作为结构的字段。在NetBSD上，i386使用常规结构，而AMD64将所有值放入一个数组中，该数组的索引在头文件中定义为常量。</p><p>下面的清单比较了FreeBSD和NetBSD上使用的结构。请注意，NetBSD/AMD64使用特殊的宏。例如，Greg(RDI RDI，0)定义_REG_RDI。</p><p>/*FreeBSD/i386*//*NetBSD/i386*/struct__reg32{struct reg{__uint32_t r_fs；int r_eax；__uint32_t r_es；int r_ecx；__uint32_t r_ds；int r_edX；__uint32_t r_edi；int r_ebx；__uint32_t r_esi；int r_esp；_uint32_t r_ebp；int r_ep；__uint32_t r_isp；int r_ESI；__uint32_t r_ebx；int r_edi；__uint32_t</p><p>可以使用FSAVE指令转储这些寄存器的内容，并使用FRSTOR指令恢复这些寄存器的内容。该指令指向108字节的内存缓冲区，存储控制寄存器和ST(I)寄存器的当前值，并重置FPU。</p><p>FSAVE助记符隐式插入额外的FWAIT指令，以确保FPU完成处理之前的操作。如果您希望在异常处理过程中捕获FPU状态，则应改为使用FNSAVE，因为它无需等待即可捕获直接的FPU状态。(=。</p><p>作为MMX指令集的一部分引入的64位MM i寄存器与ST(I)寄存器重叠。因此，不需要新的转储指令，如果使用MM i寄存器，它们将作为FSAVE中ST(I)的一部分转储。</p><p>SSE寄存器组引入了8个新的128位寄存器XMM i和一个控制MXCSR寄存器。同时介绍了一种新的倾倒功能FXSAVE及其恢复功能FXRSTOR。它们使用512字节的内存缓冲区对齐在16字节边界上，布局与FSAVE不同。</p><p>FSAVE和FXSAVE之间的明显区别在于后者保存SSE寄存器。在i386上，存储寄存器XMM0..XMM7，缓冲区的剩余部分保留/未使用。在AMD64上，保留空间的大部分用于存储XMM8..XMM15。</p><p>另一个经常被忽略的区别是，FTW状态寄存器由FSAVE以其完整形式存储，而由FXSAVE以其简化形式存储。前者指示每个ST(I)寄存器包含的值类型-空、零、归一化数字和特殊，后者仅指示寄存器是否为空。</p><p>要访问进一步的处理器扩展(如AVX)引入的寄存器，需要使用XSAVE指令。与前面描述的这些不同，它被设计为可扩展的。XSAVE是一个广泛的话题，它将是本文第二部分的主题。</p><p>FXSAVE/FXRSTOR指令的传统变体将FIP(导致异常的指令)和FDP(其操作数)指针存储为成对的16位段寄存器(分别为FCS、FD)和32位地址寄存器(FIP、FDP)。这对于AMD64程序来说是一个问题，因为原始的64位指针被截断为32位。</p><p>为解决此问题，提供了附加助记符FXSAVE64/FXRSTOR64。它们在相应的指令前面加上REX.W=1前缀，将FIP和FDP字段改为使用64位指针。它们的缺点是不再报告该段；但是，较新的AMD64处理器无论如何都不再支持FCS/FD。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.moritz.systems/blog/how-debuggers-work-getting-and-setting-x86-registers-part-1/">https://www.moritz.systems/blog/how-debuggers-work-getting-and-setting-x86-registers-part-1/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/work/">#work</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1029531.html"><img src="http://img2.diglog.com/img/2020/10/thumb_5e4fc7cc9d21eaa5f6c83224a92a62fb.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029531.html">使远程工作成为永久性的吗？不可能，湾区领导人说</a></div><span class="my_story_list_date">2020-10-18 7:41</span></div><div class="col-sm"><div><a target="_blank" href="/story/1026229.html"><img src="http://img2.diglog.com/img/2020/9/thumb_1a9f3fbe13f0dce29103554fb196af76.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1026229.html">做重要的事情</a></div><span class="my_story_list_date">2020-9-25 3:7</span></div><div class="col-sm"><div><a target="_blank" href="/story/1026088.html"><img src="http://img2.diglog.com/img/2020/9/thumb_24051b495d61af98326283214dae32c1.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1026088.html">桑达尔·皮查伊说，谷歌正在计划未来工作的“混合”模式，允许部分在家工作，因为62%的员工希望拥有这种灵活性</a></div><span class="my_story_list_date">2020-9-24 14:18</span></div><div class="col-sm"><div><a target="_blank" href="/story/1025987.html"><img src="http://img2.diglog.com/img/2020/9/thumb_f8a9f00cfc5aee25a95e2ad1b4ee2f13.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1025987.html">远程工作加剧了数据蔓延</a></div><span class="my_story_list_date">2020-9-24 4:0</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>