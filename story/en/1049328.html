<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>自动推理作为一个讨厌的孩子 Automated Reasoning as an Annoying Child</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Automated Reasoning as an Annoying Child<br/>自动推理作为一个讨厌的孩子 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-25 16:35:45</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/3a0874a8669731ec388b0915a8e3a880.png"><img src="http://img2.diglog.com/img/2021/2/3a0874a8669731ec388b0915a8e3a880.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This blog is the second in a series of posts about a joint project between Galois, Supranational, The Ethereum Foundation, and Protocol labs verifying the blst signature library. You can find the first post  here. It’s a combination of my bad jokes and an overview of what we’re trying to achieve.</p><p>这个博客是有关Galois，Supranational，以太坊基金会和协议实验室之间的联合项目的系列文章的第二部分，该项目验证了最先进的签名库。您可以在这里找到第一篇文章。这是我的恶作剧和对我们要实现的目标的概述。</p><p> It’s happening already. The development team is deep into conversations with the proof tools, and they’re taking a lot of effort. The best description of how these conversations go is “like talking to a child.”</p><p> 它已经发生了。开发团队与证明工具进行了深入的对话，他们正在付出很多努力。关于这些对话进行方式的最好描述是“就像和孩子说话一样”。</p><p> Before I get too deep into explaining what’s difficult about our work, let’s spend a post describing what exactly we’re trying to achieve and what a proof tool for program verification (like our  SAW tool) actually is. A program proof tool like SAW takes a program, along with a description of what that program should do, and tells you if the two are in agreement or not. Along the way, the tool might highlight spots where it doesn’t have enough information to do this successfully or even where the program is buggy.</p><p> 在我太深入地解释工作上的困难之前，让我们先花时间描述一下我们到底要实现什么，以及什么是程序验证的证明工具（例如SAW工具）。像SAW这样的程序证明工具将带走一个程序，以及对该程序应执行的操作的描述，并告诉您两者是否一致。在此过程中，该工具可能会突出显示没有足够信息来成功完成此操作的地方，甚至是程序存在错误的地方。</p><p> Basically, using a program proof tool is like talking to an incredibly curious and insistent child. In fact, make that two children. Every time you tell them something, they listen, nod, and then ask, “but why?”. Then you answer questions for a while, and before long, you’re sitting in the grocery store parking lot with two masked heroes staring back at you:</p><p> 基本上，使用程序证明工具就像和一个非常好奇且执着的孩子说话。实际上，让那两个孩子。每次您告诉他们一些事情时，他们都会听着，点点头，然后问：“为什么？”。然后，您回答问题一会儿，不久之后，您坐在杂货店停车场，两个戴着面具的英雄正凝视着您：</p><p>  Creepy, I know. If all of this sounds frustrating, you’re right – it can be! But just like explaining the  Clone   Saga to two inquisitive Spider-Men, the feeling when the tool finally understands you more than makes up for it. Let’s do a quick example to demonstrate exactly how child-like a prover can be, and why, at the end of the day, this childish curiosity actually turns out to be a great thing.</p><p>  令人毛骨悚然，我知道。如果所有这些听起来令人沮丧，那么您是对的-可以！但是，就像向两个好奇的蜘蛛侠讲解《克隆传奇》一样，该工具最终对您的理解远胜于弥补。让我们举一个简单的例子，确切地证明证明者像孩子一样的能力，以及为什么最终，这种幼稚的好奇心实际上是一件很棒的事情。</p><p> SAW helps us prove that programs are correct. We call the process of writing a proof of program correctness  formal verification.</p><p> SAW帮助我们证明程序是正确的。我们称编写程序正确性证明的过程为正式验证。</p><p>  The first thing SAW does is give us a precise language for describing what a program should do. We call this a  specification. Specifications in SAW (and loads of other verification tools) take the form:</p><p>  SAW要做的第一件事是为我们提供一种精确的语言来描述程序应该做什么。我们称其为规范。 SAW中的规范（以及其他验证工具的负载）采用以下形式： </p><p> If you have a collection of objects and variables called  M (mostly described as a memory layout in C)</p><p>如果您有一个称为M的对象和变量的集合（通常被描述为C中的内存布局）</p><p>   Seems pretty simple right? It’s exactly how we all think about programs we write. In particular, we “skip over” thinking about the specifics of function operations by instead thinking about how they’re meant to be called, and what happens when they’re done. It’s abstraction. I really like abstraction. I also love abstraction. I guess I have Positive Feelings for abstraction.</p><p>   看起来很简单吧？这正是我们所有人对所编写程序的看法。特别是，我们“跳过”了功能操作的细节，转而考虑了如何调用它们以及完成后会发生什么。它是抽象的。我真的很喜欢抽象。我也喜欢抽象。我想我对抽象有积极的感觉。</p><p> There’s a key difference in the way verification tools think about memory layouts like  M and parameters like  P. When we run a function, our memory layouts look like this (with respect to the tension between 1 indexing and putting a value at memory cell 0):</p><p> 验证工具思考诸如M之类的内存布局和诸如P之类的参数的方式上有一个关键差异。当我们运行一个函数时，我们的内存布局看起来像这样（相对于1索引和在存储单元0上放置一个值之间的张力） ：</p><p>     We just stuck variables in there. Right in memory! Each variable represents  any number. The memory cell x might contain 17, or 1729, or 127 billion, and this memory layout represents all those possibilities. That means we can use SAW to understand millions of different possible memory layouts, all using the same specification.</p><p>     我们只是将变量卡在那里。就在内存中！每个变量代表任何数字。存储器单元x可能包含17、1729或1270亿个，并且此存储器布局表示所有这些可能性。这意味着我们可以使用SAW来理解数以百万计的不同可能的内存布局，并且全部使用相同的规范。</p><p> The program  F is just a normal function. Suppose it’s a (pseudocode) function that increments every value in an array.</p><p> 程序F只是正常功能。假设它是一个（伪代码）函数，可以递增数组中的每个值。</p><p> void inc_all(int[] r, size s){	for(int i=0; i&lt;size; i++){		r[i] = r[i] + 1	}}</p><p> void inc_all（int [] r，size s）{for（int i = 0; i＆lt; size; i ++）{r [i] = r [i] + 1}}</p><p> Yeah yeah, I write C pseudocode. It gives you some real insight into where my head is these days. I did leave out a semicolon as a nod to my Haskell and Python buddies.</p><p> 是的，我编写了C伪代码。它使您对这些天的真实情况有了一些真正的了解。我确实省略了分号来向我的Haskell和Python伙伴表示敬意。 </p><p> We also need parameters to call this function with. Let’s say that  r starts at memory cell 1 and has a size of 5 (so it ends at 5). What do we expect once the function is done? We called that memory layout  M’</p><p>我们还需要参数来调用此函数。假设r从存储单元1开始，大小为5（因此结束于5）。功能完成后，我们期望什么？我们称该内存布局为M’</p><p>  And there you have it, a full specification of inc_all (when called at a certain size with a specific memory layout). If we know the value of x in the original memory layout, we know the value of x in the result, no matter what number we chose.</p><p>  在那里，有了inc_all的完整规范（当以特定大小和特定的内存布局调用时）。如果我们知道原始内存布局中的x值，那么无论选择什么数字，我们都知道结果中的x值。</p><p> The first question a proof tool asks of a proof engineer is  what do you want me to prove? The answer to this question comes in the form of a specification and a program. It’s not unusual to find bugs at this stage. Just the act of trying to explain what a program is supposed to do is likely to uncover some mistakes in the program if they exist.</p><p> 证明工具向证明工程师提出的第一个问题是您要我证明什么？这个问题的答案以规范和程序的形式出现。在此阶段发现错误并不罕见。只是试图解释程序应该做什么的行为很可能会发现程序中的某些错误（如果存在）。</p><p> Once we have described what the function should do, how do we use SAW to find out whether it actually does it? This is where the real questions start, and there are a lot of them! For the program inc_all SAW will ask all of these questions:</p><p> 一旦描述了该功能应该做什么，我们如何使用SAW来确定它是否确实起作用？这是真正的问题开始的地方，其中有很多！对于程序inc_all SAW将询问所有以下问题：</p><p> Does the M’ that the proof tool obtained match the one suggested in the specification for each memory value?</p><p> 证明工具获得的M’是否与规范中为每个记忆值建议的M匹配？</p><p> It’s a lot of questions for a 2 line program, but each of these questions guards against a particular thing that could go wrong in the program. It turns out many things can go wrong in C without semicolons. After all, C is a powerful language, and with great power comes great responsibility.</p><p> 2行程序有很多问题，但是每个问题都针对程序中可能出错的特定问题。事实证明，在没有分号的情况下，C可能会出错。毕竟，C是一门强大的语言，强大的能力伴随着巨大的责任。</p><p>  The good news is that proof automation allows the proof tool to answer many (or sometimes all) of these questions without any help from the programmer! In fact, that’s most of what SAW does – ask questions, and then answer the questions itself. Spider-Men don’t do this unfortunately.</p><p>  好消息是，证明自动化使证明工具无需程序员的任何帮助即可回答许多（或全部）这些问题！实际上，这是SAW所做的大部分工作-提出问题，然后回答问题本身。不幸的是，蜘蛛侠不会这么做。 </p><p> The best thing about program proof tools is that they will  always ask every question, no matter how meticulous, and that they won’t prove a program correct unless they are fully convinced of the answers. This meticulousness is a notion we often refer to as  soundness. If you want to send me on a rant, please ask me how I feel about the phrase soundness. I don’t even know why I brought it up. It couldn’t possibly be because I want you to engage with me on Twitter about it (I’m  @ n1nj4 ).</p><p>程序证明工具的最好之处在于，无论多么细致，它们都会始终询问每个问题，并且除非他们完全相信答案，否则它们不会证明程序是正确的。这种细致性是我们经常称为健全性的概念。如果您想让我发狂，请问我我对这句话的感觉如何。我什至不知道为什么要提出它。可能不是因为我希望您在Twitter上与我联系（我是@ n1nj4）。</p><p> In this case, our proof automation can answer all of these questions about the program, which means the proof will succeed. In other cases, either the code or the specification is wrong, and we need to figure out how. Again, a lot of the bugs get shaken out just because our proof engineers know that the tool will be asking so many questions of the code. It leaves no room for sloppiness or for hand-waving errors. The proof tool reduces most code to either correct or incorrect with regards to a specification, and it will not consider the proof complete until it is fully convinced.</p><p> 在这种情况下，我们的证明自动化可以回答有关程序的所有这些问题，这意味着证明将成功。在其他情况下，代码或规范都不对，我们需要弄清楚怎么做。同样，许多错误被淘汰了，仅仅是因为我们的证明工程师知道该工具会询问很多代码问题。它不会留下任何草率或挥手的错误。证明工具会根据规范减少大多数代码的正确性或不正确性，并且在完全确信之前不会认为证明是完整的。</p><p> Learning to think about programs on top of a framework like this fundamentally changes the way proof engineers think about programs. In fact, our tech lead,  Andrei  Stefanecsu, will often analyse a new piece of code with SAW first, instead of inspecting it manually. This is because for him, SAW provides a useful framework for thinking about the important properties of code rather than the surface structure.</p><p> 在这样的框架之上学习如何思考程序，从根本上改变了证明工程师思考程序的方式。实际上，我们的技术负责人Andrei Stefanecsu通常会先使用SAW分析新代码，而不是手动检查代码。这是因为SAW为他提供了一个有用的框架，可用于思考代码的重要属性而不是表面结构。</p><p> If you’ve spent time programming, you’ve likely had your thinking transformed by program reasoning tools. Everything from type systems to functions influence our thinking about programs, to the point where even when they’re not available we use them to guide our programming. Ask any programmer who’s moved from a strongly typed language to a dynamically typed one, or a Rust programmer who has gone back to using C. Program proof tools like SAW and others are a natural extension of this.</p><p> 如果您花了很多时间进行编程，则可能已被程序推理工具转变了思维方式。从类型系统到功能的所有因素都会影响我们对程序的思考，甚至​​在不可用时，我们也会使用它们来指导我们的编程。问问从强类型语言过渡到动态类型语言的任何程序员，或者已回到使用C语言的Rust程序员。问问：像SAW之类的程序证明工具都是这种扩展。</p><p> In particular, the child-like aspects of program proof tools change the way that engineers think about their programs. Developing the mindset of never getting away with anything because you know that the tool will call you on it will make you a better programmer in the same way kids make you a better person by asking you why you need 8 boxes of cookies when you take them to the grocery store.</p><p> 特别是，程序证明工具的类似于孩子的方面会改变工程师对程序的思考方式。养成永远不放弃任何东西的心态，因为您知道该工具会召唤您，这将使您成为更好的程序员，就像孩子通过问您为什么需要8盒Cookie一样，使您成为更好的人到杂货店。</p><p> All of this becomes more concrete in the details of how we specify programs and develop proofs. For the next post in this series, I’ll show you some examples of our blst specifications and break them down in detail.</p><p> 在我们如何指定程序和开发证明的细节中，所有这些都变得更加具体。在本系列的下一篇文章中，我将向您展示一些关于我们最严格的规范的示例，并将其详细分解。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://galois.com/blog/2020/10/automated-reasoning-as-an-annoying-child/">https://galois.com/blog/2020/10/automated-reasoning-as-an-annoying-child/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/自动/">#自动</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/reasoning/">#reasoning</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>