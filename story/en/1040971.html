<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在现代C ++中编写自定义迭代器 Writing a custom iterator in modern C++</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Writing a custom iterator in modern C++<br/>在现代C ++中编写自定义迭代器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-21 09:55:12</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/49378e695281bcc7cb8b5aaf5698c966.png"><img src="http://img2.diglog.com/img/2020/12/49378e695281bcc7cb8b5aaf5698c966.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>An iterator is an object that points to an element inside a container. Like a pointer, an iterator can be used to access the element it points to and can be moved through the content of the container. Each container in the C++ Standard Library provides its own iterator, as well as some methods to retrieve it. Using iterators is quite easy: obtain an instance from a container, move it around where needed and then get the pointed element.</p><p>迭代器是指向容器内元素的对象。像指针一样，迭代器可用于访问其指向的元素，并可在容器的内容中移动。 C ++标准库中的每个容器都提供了自己的迭代器以及一些检索它的方法。使用迭代器非常简单：从容器中获取实例，将其移动到需要的地方，然后获取指向的元素。</p><p> Concretely, an iterator is a simple class that provides a bunch of operators: increment  ++, dereference  * and few others which make it very similar to a pointer and the arithmetic operations you can perform on it. In fact, iterators are a generalization of pointers, which are often used as a foundation when writing the iterator itself.</p><p> 具体而言，迭代器是一个简单的类，提供了许多运算符：增量++，解引用*和其他一些使其与指针和可以对其执行的算术运算非常相似的运算符。实际上，迭代器是指针的泛化，在编写迭代器本身时通常将其用作基础。</p><p> Iterators are one of the building blocks of the Standard Library containers, but they are also useful when you want to provide the ability to iterate over elements of a custom container that you wrote yourself: this is what I want to investigate in the present article. Adding iterators to your containers will make them compatible with the  range-based for loops and the  C++ Algorithms library: a collection of functions for searching, sorting, counting and manipulating containers, based on iterators.</p><p> 迭代器是标准库容器的构建块之一，但是当您要提供对您自己编写的自定义容器的元素进行迭代的功能时，它们也很有用：这是我在本文中要研究的内容。向容器中添加迭代器将使其与基于范围的for循环和C ++算法库兼容：基于迭代器的一组用于搜索，排序，计数和操作容器的函数。</p><p>  Before digging deeper, let&#39;s define a silly custom container that we want to spice up with iterators:</p><p>  在深入研究之前，让我们定义一个愚蠢的自定义容器，我们希望通过迭代器来为其增添趣味：</p><p>  The  Integers class is a wrapper around a raw array of  ints: we want to be able to access elements of that private array through an iterator, as well as to loop over it or pass it to any of the Standard Library algorithms. Let&#39;s start by making some design decisions.</p><p>  Integers类是原始整数数组的包装：我们希望能够通过迭代器访问该私有数组的元素，以及对其进行循环或将其传递给任何标准库算法。让我们从做出一些设计决策开始。</p><p>  The first step is to choose the type of iterator we want to implement. Modern C++ defines six types:</p><p>  第一步是选择我们要实现的迭代器的类型。现代C ++定义了六种类型：</p><p> Can scan the container forward only once, can&#39;t change the value it points to (read-only);</p><p> 只能向前扫描一次容器，不能更改其指向的值（只读）； </p><p> Can scan the container forward only once, can&#39;t read the value it points to (write-only);</p><p>只能向前扫描一次容器，不能读取它指向的值（只写）；</p><p> Can scan the container forward multiple times, can read and write the value it points to;</p><p> 可以多次向前扫描容器，可以读写指向的值；</p><p>  Same as previous one but can access the container also non-sequentially (i.e. by jumping around);</p><p>  与上一个相同，但也可以不顺序访问容器（即通过跳转）;</p><p> Same as previous one, with the addition that logically adjacent elements are also physically adjacent in memory.</p><p> 与上一个相同，除了逻辑上相邻的元素在内存中也物理上相邻。</p><p> The six categories are hierarchical: a Bidirectional Iterator is also a Forward Iterator and a Random Access Iterator is both a Bidirectional and a Forward Iterator and so on. Normally, all iterators are Input Iterators (1) which makes them read-only, also known as  constant iterators. Iterators that both support read and write operations are also Output Iterators (2) and are called  mutable iterators.</p><p> 这六个类别是分层的：双向迭代器也是前向迭代器，随机访问迭代器既是双向迭代又是前向迭代器，依此类推。通常，所有迭代器都是输入迭代器（1），这使它们成为只读，也称为常量迭代器。同时支持读取和写入操作的迭代器也是输出迭代器（2），称为可变迭代器。</p><p>  Input and Output iterators are often used for low-level components such as input and output streams (the so-called  single-pass algorithms) and thus have limitations. We want to do more with our custom container, so we will skip those two and jump straight to the mutable Forward Iterator.</p><p>  输入和输出迭代器通常用于低级组件，例如输入和输出流（所谓的单遍算法），因此具有局限性。我们想对自定义容器做更多的事情，因此我们将跳过这两个并直接跳转到可变的Forward Iterator。</p><p>    The first thing to do is to assign the iterator some properties. Until C++17 this is done by  tagging it with the   tag dispatch mechanism, while C++20 uses  concepts: in this article I will follow the traditional approach.</p><p>    首先要做的是为迭代器分配一些属性。在C ++ 17之前，这是通过使用标签分发机制对其进行标记来完成的，而C ++ 20使用的是概念：在本文中，我将遵循传统方法。 </p><p>  iterator_category — one of the six iterator categories we have seen above. The full list is available  here. The  std::forward_iterator_tag tag is what we need;</p><p>iterator_category —我们在上面看到的六个迭代器类别之一。完整列表在这里。我们需要std :: forward_iterator_tag标记；</p><p> difference_type — a signed integer type that can be used to identify distance between iterator steps. Our iterator is basically a wrapper around a pointer and leverages pointer arithmetic, so the default   std::ptrdiff_t is a good choice;</p><p> different_type —一个有符号整数类型，可用于标识迭代器步骤之间的距离。我们的迭代器基本上是指针的包装器，并利用指针算术，因此默认的std :: ptrdiff_t是一个不错的选择。</p><p>  #include &lt;iterator&gt; // For std::forward_iterator_tag#include &lt;cstddef&gt; // For std::ptrdiff_tstruct Iterator { using iterator_category = std::forward_iterator_tag; using difference_type = std::ptrdiff_t; using value_type = int; using pointer = int*; // or also value_type* using reference = int&amp;; // or also value_type&amp;};</p><p>  #include＆lt; iterator＆gt; //对于std :: forward_iterator_tag＃include＆lt; cstddef＆gt; //对于std :: ptrdiff_tstruct迭代器{使用iterator_category = std :: forward_iterator_tag;使用difference_type = std :: ptrdiff_t;使用value_type = int;使用指针= int *; //或使用reference = int＆amp ;;的value_type *； //或value_type＆amp;};</p><p>  Some of the tags above might seem useless at first. In fact, you will notice how they will never get mentioned during the definition of our iterator. Tags are used to select the most efficient algorithm if your container is passed to one of the Standard Library functions from the  &lt;algorithm&gt; library. Wrong tags mean sub-optimal performance! The iterator category is also used to set algorithm requirements, for example:   std::fill wants a Forward Iterator, while   std::reverse wants a Bidirectional Iterator. Passing the wrong iterator will result in a compilation error.</p><p>  上面的某些标签一开始似乎没有用。实际上，您会注意到在定义迭代器的过程中永远不会提及它们。如果您的容器从＆lt; algorithm＆gt;传递给标准库函数之一，则使用标记来选择最有效的算法。图书馆。错误的标签表示性能欠佳！迭代器类别还用于设置算法要求，例如：std :: fill需要一个正向迭代器，而std :: reverse需要一个双向迭代器。传递错误的迭代器将导致编译错误。</p><p>  All iterators must be  constructible,  copy-constructible,  copy-assignable,  destructible and  swappable. Let&#39;s translate those requirements into code for our iterator:</p><p>  所有迭代器必须是可构造的，可复制构造的，可分配复制的，可破坏的和可交换的。让我们将这些要求转换为迭代器的代码：</p><p>  Easy! We just need a custom constructor to initialize the private member variable  m_ptr, which points to an element of the  Integers container. The custom constructor satisfies the  constructible requirement, while all others are covered by the implicitly-declared constructors and operators kindly provided by the compiler.</p><p>  简单！我们只需要一个自定义构造函数即可初始化私有成员变量m_ptr，该变量指向Integers容器的元素。定制构造函数满足可构造要求，而其他所有构造函数均由编译器提供的隐式声明的构造函数和运算符覆盖。</p><p>  We are building a mutable Forward Iterator, which inherits properties from both Input and Output Iterators. The resulting iterator must support the following operations:</p><p>  我们正在构建一个可变的正向迭代器，该继承器从输入和输出迭代器继承属性。生成的迭代器必须支持以下操作： </p><p> ++iterator and  iterator++ — incrementable, to move it one step forward, both prefix and postfix versions. The latter must return something dereferenceable;</p><p>++ iterator和iterator ++-可递增，将其向前移动一步，包括前缀和后缀版本。后者必须返回可取消引用的东西；</p><p>  struct Iterator { // Iterator tags here... // Iterator constructors here... reference operator*() const { return *m_ptr; } pointer operator-&gt;() { return m_ptr; } // Prefix increment Iterator&amp; operator++() { m_ptr++; return *this; } // Postfix increment Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; } friend bool operator== (const Iterator&amp; a, const Iterator&amp; b) { return a.m_ptr == b.m_ptr; }; friend bool operator!= (const Iterator&amp; a, const Iterator&amp; b) { return a.m_ptr != b.m_ptr; }; private: pointer m_ptr;};</p><p>  struct Iterator {//这里的Iterator标签... //这里的Iterator构造函数... reference operator *（）const {return * m_ptr; }指针操作符-＆gt;（）{return m_ptr; } //前缀增量Iterator＆amp; operator ++（）{m_ptr ++;返回* this; } //后缀增量Iterator operator ++（int）{Iterator tmp = * this; ++（*此）;返回tmp; }朋友bool运算符==（const Iterator＆amp; a，const Iterator＆amp; b）{return a.m_ptr == b.m_ptr; }; =（const Iterator＆amp; a，const Iterator＆amp; b）{return a.m_ptr！= b.m_ptr; };私人：指针m_ptr;};</p><p> As you can see every operator involves the usage of the private pointer  m_ptr. Also, notice the  friend declaration for the two comparison operators: this is handy way to define the operators as non-member functions, yet being able to access private parts of the  Iterator class (rationale  here).</p><p> 如您所见，每个运算符都涉及私有指针m_ptr的使用。另外，请注意两个比较运算符的好友声明：这是将运算符定义为非成员函数的便捷方法，但仍能够访问Iterator类的私有部分（此处为合理值）。</p><p>  Our iterator is good to go. The last step is to give our custom container the ability to create  Iterator objects. This is done by adding two public methods  begin() and  end() that return instances of the  Iterator class, representing the first and the last element respectively:</p><p>  我们的迭代器很好。最后一步是使我们的自定义容器能够创建Iterator对象。这可以通过添加两个公共方法begin（）和end（）来完成，这些方法返回Iterator类的实例，分别代表第一个元素和最后一个元素：</p><p> class Integers{public: // Iterator definition here ... Iterator begin() { return Iterator(&amp;m_data[0]); } Iterator end() { return Iterator(&amp;m_data[200]); } // 200 is out of bounds};</p><p> class Integers {public：//此处的迭代器定义...迭代器begin（）{return Iterator（＆amp; m_data [0]）; }迭代器end（）{return迭代器（＆amp; m_data [200]）; } // 200超出范围};</p><p> The  end() method returns an iterator that refers to an  invalid memory address, past the end of our raw array. Such iterator is just a placeholder used to determine when the boundary has been reached: it should never be accessed directly.</p><p> end（）方法返回一个迭代器，该迭代器在原始数组的末尾指向无效的内存地址。这样的迭代器只是一个占位符，用于确定何时到达边界：永远不要直接访问它。</p><p>   Both the custom container and its iterator are now ready. Let&#39;s test them with the range-based for loop:</p><p>   现在，定制容器及其迭代器都已准备就绪。让我们使用基于范围的for循环对其进行测试： </p><p>  This code will magically print the value of each integer in the container. It works because the range-based for loop is just syntactic sugar created by the compiler for the following:</p><p>此代码将神奇地打印容器中每个整数的值。之所以起作用，是因为基于范围的for循环只是编译器为以下目的创建的语法糖：</p><p> for (auto it = integers.begin(), end = integers.end(); it != end; ++it) { const auto i = *it; std::cout &lt;&lt; i &lt;&lt; &#34;\n&#34;;}</p><p> 对于（auto it = integers.begin（），end = integers.end（）; it！= end; ++ it）{const auto i = * it; std :: cout＆lt;＆lt;我＆lt;＆lt; ＆＃34; \ n＆＃34 ;;}</p><p> In words: two iterators  it and  end are created. The first one points to the beginning of the container, the other one points to the end. Then, on each loop, the  it iterator is incremented until it&#39;s equal to  end, that is until the end of the container has been reached. The actual value is obtained by dereferencing  it in a local variable before being printed.</p><p> 换句话说：创建了两个迭代器it和end。第一个指向容器的开头，另一个指向结尾。然后，在每个循环上，迭代器都会递增，直到等于结束，即直到达到容器的末尾为止。实际值是通过在打印之前在局部变量中取消引用来获得的。</p><p> Notice how the compiler makes use of all the operators and functions we have previously implemented: the  begin() and  end() methods in the custom container, the ability to compare the two iterators with the  != operator, the ability to increment  it with the prefix syntax and finally the ability to dereference it to grab the actual value it points to.</p><p> 请注意，编译器如何利用我们之前实现的所有运算符和函数：自定义容器中的begin（）和end（）方法，可以将两个迭代器与！=运算符进行比较，并可以使用前缀语法，最后可以取消引用以获取其指向的实际值。</p><p>   The function assigns all elements in the container the value  3. It works because  std::fill is usually implemented like this:</p><p>   该函数为容器中的所有元素分配值3。之所以起作用，是因为std :: fill通常是这样实现的：</p><p> template &lt;typename ForwardIterator, typename T&gt;void fill(ForwardIterator first, ForwardIterator last, const T&amp; value){ for (; first != last; ++first) *first = value;}</p><p> 模板＆lt; typename ForwardIterator，类型名T＆gt;无效填充（ForwardIterator首先，ForwardIterator最后，const T＆amp; value）{for（; first！= last; ++ first）* first = value;}</p><p> Note that our iterator doesn&#39;t work with all functions from the Algorithm library. For example, we can&#39;t pass it to   std::reverse as it requires a Bidirectional Iterator. The hard part has been done so far, so extending the iterator is now just a matter of adding more operators to the class and choose the best tags to describe it.</p><p> 请注意，我们的迭代器不适用于算法库中的所有函数。例如，我们不能将其传递给std :: reverse，因为它需要双向迭代器。到目前为止，最困难的部分已经完成，因此，扩展迭代器只是在类中添加更多运算符并选择最佳标签来描述它的问题。 </p><p>   Our custom container is a wrapper around an old-school array, which can be navigated with pointer arithmetic. Indeed we could get rid of the whole  Iterator class and just return a pointer to the first and last array element from the  Integers::begin() and  Integers::end() methods respectively. Range-based for loops and functions from the Algorithm library would still work fine. However, real-world containers are often based on more complex data structures than plain arrays — think of linked lists or maps to name a few, where pointers and their operations aren&#39;t just enough. Iterators abstract away all that complexity behind a handy object that behaves like a pointer and let you access a complex data structure with familiar operations.</p><p>我们的自定义容器是一个老式数组的包装，可以使用指针算法进行导航。实际上，我们可以摆脱整个Iterator类，而只需分别从Integers :: begin（）和Integers :: end（）方法返回指向第一个和最后一个数组元素的指针。算法库中基于范围的循环和函数仍然可以正常工作。但是，现实世界中的容器通常基于比普通数组更复杂的数据结构-考虑一下链表或映射，其中的指针及其操作还不够。迭代器将所有复杂性抽象到了像指针一样方便的对象后面，并使您可以通过熟悉的操作访问复杂的数据结构。</p><p>  In our example, the  Integers class could have been a wrapper around a  std::array. In this case you don&#39;t need to implement any custom iterator at all and just return the iterator that belongs to the Standard Library container in use. For example:</p><p>  在我们的示例中，Integers类可能是std :: array的包装器。在这种情况下，您根本不需要实现任何自定义迭代器，只需返回属于使用中的标准库容器的迭代器即可。例如：</p><p> class Integers{ using IntegersType = std::array&lt;int, 32&gt;; // ... IntegersType::iterator begin() { return m_data.begin(); } IntegersType::iterator end() { return m_data.end() } private: IntegersType m_data;};</p><p> 类Integers {使用IntegersType = std :: array＆lt; int，32＆; // ... IntegersType :: iterator begin（）{return m_data.begin（）; } IntegersType :: iterator end（）{return m_data.end（）}私有：IntegersType m_data;};</p><p> The code above works because all containers in the C++ Standard Library do what we have done with our  Integer container: they all implement their iterators as class members. The  IntegersType alias is used to simplify type names and is not mandatory. Also, returning  auto as iterator type seems just fine in C++17.</p><p> 上面的代码之所以有效，是因为C ++标准库中的所有容器都完成了我们对Integer容器所做的工作：它们都将其迭代器实现为类成员。 IntegersType别名用于简化类型名称，不是必需的。另外，在C ++ 17中，将auto作为迭代器类型返回似乎还不错。</p><p>  By default,  Iterator can alter the element it points to. If you want to make it immutable, the common trick is to add another iterator type to the custom container class — let&#39;s call it  ConstantIterator. This new iterator type is almost identical to the original one, except for its dereference operator which now returns a  constant reference:</p><p>  默认情况下，Iterator可以更改其指向的元素。如果要使其不可变，通常的技巧是在自定义容器类中添加另一种迭代器类型-我们将其称为ConstantIterator。这种新的迭代器类型几乎与原始迭代器类型相同，除了它的取消引用运算符现在可以返回常量引用之外：</p><p>  The same thing applies to the  -&gt; operator. Finally, the custom container must be able to return such new iterator type. This is done by adding two additional public methods  cbegin() and  cend() (where the leading  c stands for  constant) that return instances of the  ConstantIterator class:</p><p>  同样的情况适用于-＆gt;操作员。最后，自定义容器必须能够返回这种新的迭代器类型。这可以通过添加两个其他的公共方法cbegin（）和cend（）（其中前导c代表常量）来完成，这些方法返回ConstantIterator类的实例：</p><p>  Many Standard Library containers provide both the  begin()/end() and the  cbegin()/cend() pairs. The same pattern is applied for each iterator type. For example,   std::array also has  rbegin()/rend(), where  r stands for  reverse iterator (yes, you can loop a Standard Library arrays in reverse, too).</p><p>  许多标准库容器都提供begin（）/ end（）和cbegin（）/ cend（）对。每种迭代器类型都应用相同的模式。例如，std :: array也具有rbegin（）/ rend（），其中r代表反向迭代器（是的，您也可以反向循环标准库数组）。 </p><p>  C++20 introduces  concepts, a smart way to put constraints on the types a template function or class can take in. While iterator categories and properties remain the same, what changes is  how you enforce them: with tags until C++17, with concepts since C++20. For example, instead of the  std::forward_iterator_tag tag you would mark your iterator with the   std::forward_iterator concept. The same thing applies to all iterator properties. For example, a Forward Iterator must be   std::incrementable. This new mechanism helps in getting better iterator definitions and makes errors from the compiler much more readable. I will upgrade the article as soon as the concept implementation will become more widespread.</p><p>C ++ 20引入了一些概念，这是一种对模板函数或类可以接受的类型施加约束的明智方法。虽然迭代器的类别和属性保持不变，但执行方式的变化是：使用标记，直到C ++ 17，自C ++ 20以来的概念。例如，您可以使用std :: forward_iterator概念标记迭代器，而不是std :: forward_iterator_tag标记。同样的情况适用于所有迭代器属性。例如，正向迭代器必须是std :: incrementable。这种新机制有助于获得更好的迭代器定义，并使来自编译器的错误更易读。一旦概念实现变得更加广泛，我将对本文进行升级。</p><p>   #include &lt;iterator&gt;#include &lt;cstddef&gt;class Integers{public: struct Iterator { using iterator_category = std::forward_iterator_tag; using difference_type = std::ptrdiff_t; using value_type = int; using pointer = int*; using reference = int&amp;; Iterator(pointer ptr) : m_ptr(ptr) {} reference operator*() const { return *m_ptr; } pointer operator-&gt;() { return m_ptr; } Iterator&amp; operator++() { m_ptr++; return *this; } Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; } friend bool operator== (const Iterator&amp; a, const Iterator&amp; b) { return a.m_ptr == b.m_ptr; }; friend bool operator!= (const Iterator&amp; a, const Iterator&amp; b) { return a.m_ptr != b.m_ptr; }; private: pointer m_ptr; }; Iterator begin() { return Iterator(&amp;m_data[0]); } Iterator end() { return Iterator(&amp;m_data[200]); }private: int m_data[200];};</p><p>   #include＆lt; iterator＆gt; #include＆lt; cstddef＆gt; class Integers {public：struct Iterator {using iterator_category = std :: forward_iterator_tag;使用difference_type = std :: ptrdiff_t;使用value_type = int;使用指针= int *;使用reference = int＆amp ;;迭代器（指针ptr）：m_ptr（ptr）{}参考运算符*（）const {返回* m_ptr; }指针操作符-＆gt;（）{return m_ptr; }迭代器和放大器; operator ++（）{m_ptr ++;返回* this; }迭代器操作符++（int）{迭代器tmp = * this; ++（*此）;返回tmp; }朋友bool运算符==（const Iterator＆amp; a，const Iterator＆amp; b）{return a.m_ptr == b.m_ptr; }; =（const Iterator＆amp; a，const Iterator＆amp; b）{return a.m_ptr！= b.m_ptr; };专用：指针m_ptr; };迭代器begin（）{return Iterator（＆amp; m_data [0]）; }迭代器end（）{return迭代器（＆amp; m_data [200]）; }专用：int m_data [200];}; </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.internalpointers.com/post/writing-custom-iterators-modern-cpp">https://www.internalpointers.com/post/writing-custom-iterators-modern-cpp</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/迭代/">#迭代</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/custom/">#custom</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>