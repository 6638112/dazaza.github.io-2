<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么视频游戏图形仍然是一个挑战？ Why are video games graphics (still) a challenge?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why are video games graphics (still) a challenge?<br/>为什么视频游戏图形仍然是一个挑战？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-29 04:45:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/0306f97c9c65c94779062edd566317cd.png"><img src="http://img2.diglog.com/img/2020/12/0306f97c9c65c94779062edd566317cd.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This post will cover challenges and aspects of production to consider when creating new rendering / graphics techniques and algorithms – especially in the context of  applied research for real time rendering. I will base this on my personal experiences, working on  Witcher 2, Assassin’s Creed 4: Black Flag, Far Cry 4, and God of War.</p><p>这篇文章将涵盖创建新的渲染/图形技术和算法时要考虑的挑战和生产方面，尤其是在实时渲染的应用研究中。我将基于我的个人经验，在《巫师2》，《刺客信条4：黑旗》，《孤岛惊魂4》和《战神》中工作。</p><p> Many of those challenges are easily ignored – they are  real problems in production, but not necessarily there only if you only read about those techniques, or if you work on pure research, writing papers, or create tech demos.</p><p> 这些挑战中有许多很容易被忽略-它们是生产中的实际问题，但只有当您仅了解这些技术，或者您从事纯研究，撰写论文或创建技术演示时，并不一定存在。</p><p> I have seen statements like “why is this brilliant research technique X not used in production?” both from gamers, but also from my colleagues with academic background. And there are always some good reasons!</p><p> 我看到过这样的陈述：“为什么这种出色的研究技术X不在生产中使用？”既来自游戏玩家，也来自具有学术背景的同事。总是有一些很好的理由！</p><p> The post is also inspired by  my joke tweet from a while ago about appearing smart and mature as a graphics programmer by “dismissing” most of the rendering techniques – that they are not going to work on foliage. 🙂 And yes, I will come back to vegetation rendering a few times in this post.</p><p> 这篇文章还受到我前段时间在我的玩笑推文中的启发，该推文是通过“取消”大多数渲染技术来使他们成为图形程序员而变得聪明成熟的，因为这些渲染技术不会在叶子上起作用。 yes是的，在这篇文章中我将再次回到植被渲染。</p><p> I tend to think of this topic as well when I hear discussions about how “photogrammetry, raytracing, neural rendering, [insert any other new how topic] will be a universal answer to rendering and replace everything!”. Spoiler alert: not gonna happen (soon).</p><p> 当我听到有关“摄影测量，光线追踪，神经渲染，[插入任何其他新主题”将如何成为渲染和替换所有内容的通用答案”的讨论时，我也会想到这个主题。剧透警报：不会（很快）发生。</p><p>   Rendering engineers, especially ones earlier in their career – who haven’t built their intuition yet,</p><p>   渲染工程师，尤其是在职业生涯早期的工程师，他们还没有建立直觉，</p><p>   People who are excited and care about game graphics (or real time graphics in general) and would like to understand a bit “how sausages are made”. Some concepts might be too technical, but then feel free to skip those.</p><p>   那些对游戏图形（或一般来说是实时图形）感到兴奋和关心的人，并且想了解一点“香肠的制作方法”。有些概念可能太技术性，但是可以随时跳过这些概念。 </p><p> Note that I didn’t place “pure” academic researchers in the above list – as I don’t think that pure research should be considering too many obstacles. Role of the fundamental research is inspiration and creating theory that can be later productionized by people who are experts in productionization.</p><p>请注意，我没有将“纯粹的”学术研究人员放在上面的列表中-因为我不认为纯粹的研究应该考虑太多的障碍。基础研究的作用是启发和创造理论，这些理论以后可以由生产专家来生产。</p><p> But if you are a pure researcher and somehow got here, I’ll be happy if you’re interested in what kinds of problems might be on the long way from idea or paper to a product (and  why most new genuinely good research will never find its place in products).</p><p> 但是，如果您是一个纯粹的研究人员并且以某种方式来到了这里，如果您对从构思或论文到产品的漫长过程中可能会遇到哪些问题感兴趣，以及为什么大多数新的真正优秀的研究永远不会找到它在产品中的位置）。</p><p>  Very important note –  none of the “obstacles” I am going to describe  are deal breakers.</p><p>  非常重要的说明–我要描述的“障碍”都不是破坏交易的因素。</p><p> Far from it – most successful tech that became state of the art violates many of those constraints! It simply means that those are challenges that will need to be overcome in some way – manual workarounds, feature exclusivity, ignoring the problems, or applying them only in specific cases.</p><p> 远非如此-成为最先进技术的最成功的技术违反了许多限制！这仅意味着这些挑战将需要以某种方式加以克服-手动解决方法，功能独占，忽略问题或仅在特定情况下应用。</p><p> I am going to describe first the  use-cases – potential uses of the technology and how those impact potential requirements and constraints.</p><p> 我将首先描述用例-技术的潜在用途以及它们如何影响潜在的需求和约束。</p><p>  The categories of “use cases” deserve some explanation and description of “severity” of their constraints.</p><p>  “用例”类别应对其约束的“严重性”进行一些解释和描述。</p><p>  Tech demo is the easiest category. If your whole product is a  demonstration of a given technique (whether for benchmarking, showing off some new research, artistic demoscene), most of the considerations go away.</p><p>  技术演示是最简单的类别。如果您的整个产品都是给定技术的演示（无论是用于基准测试，展示一些新研究，艺术演示），则大多数考虑都将消失。 </p><p> You can actually retrofit everything: from the demo concept, art itself, camera trajectory to show off the technology the best and avoid any problems.</p><p>实际上，您可以进行所有改装：从演示概念，艺术品本身，照相机轨迹到最佳展示技术，避免出现任何问题。</p><p> The main considerations will be around performance (a choppy tech demo can be seen as a tech failure) and working very closely with artists able to show it off.</p><p> 主要考虑因素将围绕性能（不稳定的技术演示可被视为技术失败），并与能够进行展示的艺术家紧密合作。</p><p> The rest? Hack away, write one-off code – just don’t have expectations that turning a tech demo into a production ready feature is simple or easy (it’s more like the 99% of work remaining).</p><p> 其余的部分？轻松完成，编写一次性代码–只是不期望将技术演示转换为可用于生产的功能既简单又容易（更像是剩余的99％的工作）。</p><p>  The next level “up” in the difficulty is creating some  special features that are one-off. It can be some visual special effect happening in a single scene, game intro, or a single level that is different from the other ones. In this case, a feature doesn’t need to be very “robust”, and often replaces many others.</p><p>  难度的下一个“提升”是创建一些一次性的特殊功能。可能是某些视觉特殊效果发生在单个场景，游戏介绍或与其他场景不同的单个关卡中。在这种情况下，功能不必太“健壮”，而通常可以替代许多其他功能。</p><p> An example could be lighting in the jungle levels in Assassin’s Creed 4: Black Flag that I worked on.</p><p> 例如，我在《刺客信条4：黑旗》中丛林中的照明。</p><p>  Jungles were “cut off” from the rest of the open world by special streaming corridors and we completely replaced the whole lighting in them! Instead of relying on tree shadow maps and global lighting, we created  fake “caustics” that looked much softer and played very nicely with our volumetric lighting / atmospherics system. They not only looked better, but also were much faster – obviously worked only because of those special conditions.</p><p>  丛林通过特殊的水流走廊与其他开放世界“隔离”，我们完全替换了其中的整个照明！我们没有依赖树影地图和全局照明，而是创建了伪造的“焦散”，看起来更柔和，并且在我们的体积照明/大气系统中表现得非常好。它们不仅看起来更好，而且速度更快-显然仅由于这些特殊条件而起作用。</p><p>  A slightly more demanding type of feature is cinematic-only one. Cinematics are a bit different as they can be very strictly controlled by cinematic artists and  most of their aspects like lighting, character placement, or animations are faked – just like in regular cinema! Cinematics often feature fast camera cuts (useful to hide any transitions/popping) and have more computational budget due to more predictable nature (and even in 60fps console games rendered in 30fps).</p><p>  稍微有点苛刻的功能是仅电影功能。电影技术有点不同，因为它们可以由电影艺术家严格控制，并且它们在照明，角色放置或动画等大多数方面都是伪造的，就像在常规电影院一样！电影通常具有快速的摄像机剪切功能（可用于隐藏任何过渡/弹出窗口），并且由于具有更可预测的性质而具有更多的计算预算（甚至在以30fps渲染的60fps控制台游戏中）。 </p><p>   “Regular” features – lighting, particles, geometry rendering – are the  hardest category. They need to be either very easy to implement (most of the obstacles / problems solved easily), provide huge benefits surpassing state of the art by far to facilitate the adoption pain, or have some very excited team pushing for it (never underestimate the drive of engineers or artists that really want to see something happen!).</p><p>“常规”功能-照明，粒子，几何体渲染-是最难的类别。他们需要要么非常易于实施（大多数障碍/问题就很容易解决），要么提供远远超过现有技术的巨大收益（以解决采用难题），要么让一些非常激动的团队为之奋斗（永远不要低估推动力）真正想看到某些事情发生的工程师或艺术家！）。</p><p>   Paradoxically, if something is a key or differentiating feature, this can alleviate many of the difficulties. Let’s take VR – there stereo, performance (low latency), and perfect AA with no smudging (so rather forget about TAA), are  THE features and absolutely core to the experience. This means that you can completely ignore for example rendering foliage or some animations that would look uncannily – as being immersed and the VR experience of being there are much more important!</p><p>   矛盾的是，如果某项是关键或与众不同的功能，则可以减轻许多困难。让我们以虚拟现实为例–立体声，性能（低延迟）和完美的AA而不会弄脏（宁可不用TAA），它们是功能，绝对是体验​​的核心。这意味着您可以完全忽略例如渲染树叶或某些看起来令人讨厌的动画–因为沉浸和在那里的VR体验更为重要！</p><p>  Let’s have a look at compatibility of a newly developed feature with some other common “features” (the distinction between “features”, and the next large section “pipeline” is fuzzy).</p><p>  让我们看一下新开发的功能与其他一些常见“功能”的兼容性（“功能”之间的区别，以及下一个较大的“管道”部分是模糊的）。</p><p> Features are not the most important of challenges – arguably the category I’m going to cover at the end (the “process”) is. But those are fun and easy to look at!</p><p> 功能并不是挑战中最重要的-可以说我最后要讨论的类别（“过程”）是。但是这些很有趣，而且很容易看！</p><p>  Dense geometry like  foliage – a “feature” that inspired this post – is an enemy of most rendering algorithms.</p><p>  密集的几何形状（例如树叶）是激发这篇文章的“特征”，是大多数渲染算法的敌人。</p><p> The main problem is that with very dense geometry (lots of overlapping and small triangles), many “optimizations” and assumptions become impossible.</p><p> 主要问题是，由于几何形状非常密集（大量重叠和小三角形），许多“优化”和假设变得不可能。</p><p>      Dense geometry through which you can see (like grass blades) is incompatible with many techniques, for example lightmapping (storing a precomputed lighting per every grass blade texel would be very costly).</p><p>      可以看到的密集几何体（例如草叶）与许多技术不兼容，例如，光照贴图（每个草叶texel存储一个预先计算的照明会非常昂贵）。 </p><p> If a game has a tree here and there or is placed in a city, this might not be a problem. But for any “natural” environment, a big chunk of the productionization of any feature is going to be combining it to coexist well with foliage.</p><p>如果游戏在这里到处都有树，或者放在城市中，那么这可能不是问题。但是对于任何“自然”环境，任何功能的大量生产都将结合起来使其与树叶很好地共存。</p><p>  Alpha testing is an extension of the above, as it disables even more hardware features / optimizations.</p><p>  Alpha测试是上述功能的扩展，因为它禁用了更多硬件功能/优化。</p><p> Alpha testing is a technique, when a pixel evaluates “alpha” value from a texture or pixel shader computations, and  based on some fixed threshold, doesn’t render/write it.</p><p> 阿尔法测试是一种技术，当像素从纹理或像素着色器计算中评估“阿尔法”值，并且基于某个固定阈值时，不会渲染/写入该值。</p><p> It is much faster than alpha blending, but for example disables early z writes (early z tests are ok), and requires raytracing hit shaders and reading a texture to decide if a texel was opaque or not.</p><p> 它比alpha混合快得多，但是例如禁用了早期的z写操作（早期的z测试是可以的），并且需要光线跟踪命中着色器并读取纹理来确定纹理像素是否不透明。</p><p> It also makes antialiasing very challenging (forget about regular MSAA, you have to emulate alpha to coverage…).</p><p> 这也使抗锯齿变得非常具有挑战性（忘了常规的MSAA，您必须模拟alpha覆盖）。</p><p> For a description and great visual explanation of some problems, see this blog post of  Ben Golus.</p><p> 有关某些问题的描述和直观的视觉解释，请参阅Ben Golus的此博客文章。</p><p>  Most animators work with “skeletal animations”.  Creating rigs, skinning meshes, animating skeletons. When you create a new technique for rendering meshes that relies on some heavy precomputations, would animators be able to “deform” it? Would they be able to plug it into a complicated animation blending system? How does it fit in their workflow?</p><p>  大多数动画师都使用“骨骼动画”。创建装备，蒙皮网格，为骨骼设置动画。当您创建一种新的渲染网格的技术时，它依赖于一些繁琐的预计算，动画师是否能够对其“变形”？他们能够将其插入复杂的动画混合系统中吗？它如何适合他们的工作流程？ </p><p> Note that it can also mean rigid deformations, like a rotating wheel – it’s much cheaper to render complicated objects as a skinned whole, than splitting them.</p><p>请注意，它也可能意味着刚性变形，例如旋转的轮子–将复杂的对象作为蒙皮的整体进行渲染要比拆分它们便宜得多。</p><p>    The next category of animations are “procedural” and non-rigid. Procedural animations are useful for any animation that is “endless”, relatively simple, and shouldn’t loop too visibly. The most common example is  leaf shimmer and branch movement.</p><p>    下一类动画是“过程性的”和非刚性的。程序动画对于“无休止”，相对简单且不应太明显地循环的动画很有用。最常见的例子是叶片微光和树枝运动。</p><p> See  this video of middleware Speedtree movement – all movement there is described by some mathematical formulas, not animated “by hand” and looks fantastic and plausible.</p><p> 观看有关中间件Speedtree运动的视频-那里的所有运动都是由一些数学公式描述的，而不是“手工制作”的动画，看上去奇妙而合理。</p><p> A good rendering technique that is applicable on elements like foliage (again!) needs to support the option of displacing it in any arbitrary fashion from simple shimmer to large bends – otherwise the world will look “dead”.</p><p> 一种适用于树叶（再次！）等元素的良好渲染技术需要支持以任意方式（从简单的微光到大弯角）进行替换的选项–否则世界将看起来“死”。</p><p> Non-rigid animation, modifying vertex positions, or even streaming whole vertex buffers causes headaches for the raytracing – as it requires readjusting the spatial acceleration structures (essential for RT) every single frame, which is impractical.</p><p> 非刚性动画，修改顶点位置，甚至流式传输整个顶点缓冲区都会导致光线跟踪的麻烦-因为它需要每帧重新调整空间加速度结构（对于RT至关重要），这是不切实际的。</p><p>  Yet another type of animation is animating textures on surfaces of objects. This is not just for emulating  neons or TVs, but also for example raindrops and rain ripples. Technical and FX artists have lots of amazing tricks there, from just sliding and scaling UVs, having flowmaps, to directly animating “flipbook” textures.</p><p>  动画的另一种类型是在对象表面上设置纹理动画。这不仅用于模拟霓虹灯或电视，还用于例如雨滴和雨水波纹。技术人员和FX艺术家那里有许多惊人的技巧，从滑动和缩放UV，具有流程图到直接为“动画书”纹理设置动画。</p><p>   Many techniques work well assuming a relatively fixed camera viewpoint. From artists tricks and hacks, to techniques like impostor rendering.</p><p>   假设摄像机的视点相对固定，许多技术都可以很好地工作。从艺术家的技巧和骇客，到冒名顶替者渲染之类的技术。 </p><p> Some rendering acceleration techniques optimize for a semi-constrained view (like  Project Seurat that my colleagues worked on). Degrees of camera freedom are something to be considered when adapting any technique. A billboard-based tree can look ok from a distance, but if you get closer, or can see the scene from a higher viewpoint, it will break completely.</p><p>一些渲染加速技术针对半约束视图进行了优化（例如我的同事从事的Project Seurat项目）。适应任何技术时都应考虑相机自由度。基于广告牌的树从远处看可能不错，但是如果您离得很近，或者可以从更高的角度看到场景，则树会完全断裂。</p><p> Also – think of early photogrammetry that was capturing the specular reflections as textures, which look absolutely wrong when you change the viewpoint even slightly.</p><p> 另外–想像一下早期的摄影测量法，将镜面反射捕获为纹理，当您稍微改变视点时，看起来绝对是错误的。</p><p>  How dynamic is the lighting? Is there a dynamic time of day? Weather system? Can the user turn on/off lights? Do special effects cast lights? Are there dynamic shadow casting objects?</p><p>  照明的动态程度如何？有一天的动态时间吗？天气系统？用户可以打开/关闭灯吗？特殊效果会投射灯光吗？是否有动态阴影投射对象？</p><p> The answer is going to be “yes” to many of those questions for most of the contemporary real-time rendering products like games; especially with a tendency of creating larger, living worlds.</p><p> 对于大多数当代实时渲染产品（如游戏），答案将是“很多”。特别是倾向于创造更大的生活世界。</p><p> This doesn’t necessarily preclude precomputed/baked solutions (like  our precomputed GI solution for AC4 that supported dynamic time of day!) but needs extra considerations.</p><p> 这并不一定排除预先计算/烘焙的解决方案（例如我们支持AC4的动态计算的GI预先计算的GI解决方案！），但需要额外考虑。</p><p> There are still many new publications coming out that describe new approaches and solutions to those problems (combining precomputations of the light transport, and the dynamic lighting).</p><p> 仍然有许多新出版物发表，描述了解决这些问题的新方法和解决方案（结合了光传输和动态照明的预计算）。</p><p>  Shadows, another never ending topic and an unsolved problem. Most games still use a mixture of precomputed shadows and shadow maps, some start to experiment with raytraced shadows.</p><p>  阴影，另一个永无止境的话题和未解决的问题。大多数游戏仍然使用预先计算的阴影和阴影贴图的混合物，有些游戏开始尝试使用光线跟踪阴影。 </p><p> Anytime you want to insert a new type of object to be rendered, you need to consider: is it going to be able to receive shadows from other objects? Is it going to cast shadows on other objects?</p><p>每当您要插入要渲染的新型对象时，都需要考虑：它是否能够接收来自其他对象的阴影？它会在其他物体上投射阴影吗？</p><p> For particles or volumetrics, the answer might not be easy (as partial transmittance is not supported by shadow maps), but also “simple” techniques like mesh tessellation or parallax occlusion mapping are going to create a mismatch between shadow caster and the receiver, potentially causing shadowing artifacts!</p><p> 对于粒子或体积，答案可能并不容易（因为阴影贴图不支持部分透射率），但是像网格细分或视差遮挡贴图这样的“简单”技术也会在阴影投射器和接收器之间造成不匹配。造成阴影伪影！</p><p>   Finally, if the environment can be dynamic (through game story mandated changes, destruction, or in the extreme case through user content creation), any techniques relying on offline precomputation become challenging.</p><p>   最后，如果环境是动态的（通过强制更改，销毁游戏故事，或者在极端情况下通过创建用户内容），则依赖脱机预计算的任何技术都将面临挑战。</p><p> On  God of War the Caldera Lake and the bridge, moving levels of water and bridge rotations were  one of the biggest concerns throughout the whole production from the perspective of lighting / global illumination systems that rely on precomputations. There was no “general” solution, it all relied on manual work and streaming / managing the loaded data…</p><p> 从依靠预计算的照明/全球照明系统的角度来看，在战神破火山口湖和桥梁上，水位和桥梁旋转的移动是整个生产过程中最大的问题之一。没有“通用”解决方案，它全部依靠手动工作以及流式传输/管理加载的数据…</p><p>   Finally, there are transparent objects and particles – a very special and different category than anything else.</p><p>   最后，还有透明的对象和粒子–一个非常特殊且与众不同的类别。</p><p> They don’t write depth or motion vectors (more on it later), require back-to-front sorting, need many evaluations of costly computations and texture samplers per final output piels, usually are lit in a simpler way, need special handling of shadows… They are also very expensive due to overdraw – a single output pixel can be many evaluations of alpha blended particles’ pixel shaders.</p><p> 他们不编写深度或运动矢量（稍后会详细介绍），需要从头到尾进行排序，需要对每个最终输出的批处理进行许多评估，包括昂贵的计算和纹理采样器，通常以更简单的方式点亮，需要对阴影...由于过度绘制，它们也非常昂贵-一个输出像素可以对alpha混合粒子的像素着色器进行许多评估。</p><p> Person-years of work (on most projects I worked on there were N dedicated FX artists and at least one dedicated FX and particle rendering engineer) that cannot be just discarded or ignored by a newly introduced technique.</p><p> 历时数年的工作（在我从事的大多数项目中，有N位专业的FX艺术家以及至少一位专业的FX和粒子渲染工程师）不能被新引入的技术丢弃或忽略。 </p><p>  The above were some product features and requirements to consider. But what about some deeper, more low-level implications? Rendering of a single frame requires tens of discrete passes that are designed to work with each other, tens of intermediate outputs and buffers. Let’s look at  parts of the rendering pipeline to consider.</p><p>以上是要考虑的一些产品功能和要求。但是，一些更深层次，更底层的含义呢？渲染单个帧需要数十个离散通道，这些通道被设计为可以相互配合工作，需要数十个中间输出和缓冲区。让我们看一下要考虑的部分渲染管道。</p><p>  I mentioned above some challenges with alpha testing, alpha blending, sorting, and particles. But it gets even more challenging when you realize that many features require  precise Z buffer values in the depth buffer for every object!</p><p>  我在上面提到了alpha测试，alpha混合，排序和粒子方面的一些挑战。但是，当您意识到许多功能需要每个对象的深度缓冲区中的精确Z缓冲区值时，挑战就变得更大了！</p><p> That creamy depth of field effect and many other camera effects? Most require a depth buffer. Old school depth fog? Required depth buffer!</p><p> 那种奶油般的景深效果和许多其他相机效果？大多数需要深度缓冲区。老派深度迷雾？需要深度缓冲区！</p><p>  Ok, this seems like a deal breaker, as we know that alpha blended objects don’t write those and there cannot be a single depth value corresponding to them… But games are a mastery of smoke and mirrors and faking. 🙂 If you really care you can create depth proxies by hand, sort and reorder some things manually, alpha blend depth (wrong but can look “ok”), tweak depth of field until artifacts are not distracting… Lots of manual work and puzzles “which compromise is less bad”!</p><p>  好的，这看起来像是一个交易突破，因为我们知道Alpha混合对象不会写这些对象，并且不能有对应于它们的单个深度值……但是游戏精通烟雾，镜子和伪造。 🙂如果您真的很在意，可以手动创建深度代理，手动对一些东西进行排序和重新排序，alpha混合深度（错误，但看起来可以），调整景深，直到工件不会分散注意力……很多手动工作和难题”哪种妥协还不错”！</p><p>  A related pipeline component is writing of the motion vectors. While depth is essential for many mentioned depth based effects, proper occlusions, screen-sapce refractions, fog etc,  the motion vectors are used for “only” two things: motion blur and temporal antialiasing (see below).</p><p>  一个相关的流水线组件是运动矢量的写入。虽然深度对于许多上述基于深度的效果，适当的遮挡，屏幕空间折射，雾等至关重要，但运动矢量仅用于“两件事情”：运动模糊和时间抗锯齿（请参见下文）。</p><p> Motion blur seems like “just an effect”, but having small amounts of it is essential to reduce the “strobing” effect and generally cheap feel (see movie 24fps half shutter motion blur).</p><p> 运动模糊似乎只是“一种效果”，但是减少运动模糊和减少通常的廉价感觉至关重要（请参阅电影24fps半快门运动模糊）。</p><p> (Some bragging / Christmas time nostalgia: thinking about motion blur made me feel nostalgic – motion blur was the first feature I  got interviewed about by the press – I still feel the pride the 23 year old me living in Eastern Europe and that didn’t even finish the college felt!)</p><p> （有些吹牛/圣诞节的怀旧之情：对运动模糊的思考使我感到怀旧-运动模糊是我被媒体采访的第一个功能-我仍然对23岁的我生活在东欧感到自豪，但事实并非如此。甚至完成了大学的感觉！） </p><p> Producing accurate motion vectors is not trivial – for every pixel, you need to estimate where this part of the object was in the previous frame. This can mean re-computing some animation data again, storing it for the previous frame (extra used memory), or can be too difficult / impossible (dealing with occlusions, shadows, or texture animations).</p><p>产生准确的运动矢量并非易事-对于每个像素，您都需要估计对象的这一部分在上一帧中的位置。这可能意味着再次重新计算一些动画数据，将其存储到前一帧（额外使用的内存），或者可能太困难/不可能（处理遮挡，阴影或纹理动画）。</p><p> On AC4 we have implemented it for almost everything – with an exception of the ocean and ignored the TAA and motion blur problems on it…</p><p> 在AC4上，我们几乎对所有事物都实现了它-除了海洋，它忽略了TAA和上面的运动模糊问题……</p><p>  Temporal antialiasing… one of the biggest achievements of the rendering engines in the last few years, but also one of the biggest sources of problems and artifacts. Not going to discuss here if there are alternatives to it or if it’s a good idea or not, but it’s here to stay for a while – not just for the antialiasing, but also  temporal distribution of samples in Monte Carlo techniques, supersampling, stochastic rendering, and allowing for slow things to become possible or higher quality in real-time.</p><p>  临时抗锯齿…是过去几年渲染引擎的最大成就之一，但也是问题和工件的最大来源之一。在这里不讨论是否有替代方法，或者它是否是一个好主意，但这将在这里停留一段时间-不仅用于抗锯齿，而且还用于蒙特卡洛技术，超级采样，随机渲染中的样本时间分布，并允许缓慢的事情变为可能或实时获得更高的质量。</p><p> It  can be a problem for many new rendering techniques – not only because of the need for pretty good motion vectors, but also its nature can lead to some smearing artifacts, or even cancel out visual effects like sparkly snow (glints, sparkles, muzzle flash etc).</p><p> 对于许多新的渲染技术而言，这可能是一个问题–不仅是因为需要非常好的运动矢量，而且它的性质还可能导致产生一些拖尾的伪影，甚至抵消诸如闪闪发光的雪（闪烁，火花，枪口闪光）的视觉效果等等）。</p><p>   Majority of the engines use  deferred shading (yes, there are many exceptions and they look and perform fantastic). It has many desirable properties and “lifts” / decouples parts of the rendering, simplifies things like decals, can provide a sweet reduction of the overdraw…</p><p>   大多数引擎使用延迟着色（是的，有很多例外，它们看起来和表现都很棒）。它具有许多理想的属性，并且可以“提升” /解耦渲染的各个部分，简化了贴花之类的事情，可以很好地减少透支。</p><p>  But having a “bottleneck” in form of the GBuffer and lighting not having access to any other data can be very limiting.</p><p>  但是，以GBuffer形式出现“瓶颈”，并且照明无法访问任何其他数据可能会非常受限制。</p><p> New shading model? New look-up table? New data precomputed / prebaked and stored in vertices or textures?  Need to squeeze those into GBuffer!</p><p> 新的阴影模型？新的查询表？预计算/预烘焙并存储在顶点或纹理中的新数据？需要将它们压缩到GBuffer中！ </p><p> Modern GPUs handle branching and divergence with ease (provided there is “some” coherency), but it can complicate the pipeline and lead to “exclusive” features.</p><p>现代GPU可以轻松处理分支和发散（前提是存在“某种”一致性），但它会使管道复杂化并导致“专有”功能。</p><p> For example on God of War you couldn’t use subsurface scattering at the same time as the cloth/retroreflective specular model due to them (re)using same slots in the GBuffer. The GBuffer itself was very memory heavy anyway and there were many more mutually exclusive features – I had many possible combinations written out in my notebook (IIRC there were 6 bits just for encoding the material type + its features) and “negotiating” those compromises between different artists who all had different uses and needs.</p><p> 例如，在《战神》中，您不能与布料/反射镜面模型同时使用次表面散射，因为它们（重新）使用了GBuffer中的相同插槽。无论如何，GBuffer本身都占用大量内存，并且还有更多互斥的功能–我在笔记本中写了许多可能的组合（IIRC有6位仅用于编码材料类型及其功能），并“协商”有不同用途和需求的不同艺术家。</p><p>   In most cinematics, there are  heavy camera cuts all the time to show different characters, different perspectives of the scene, or maybe action happening in parallel. This is a tool widely used in all kinds cinema (maybe except for  Dogme 95 or Birdman 😉 ), and if a cinematic artist wants to use it, it needs to be supported.</p><p>   在大多数电影中，始终会有大量的摄像机镜头剪辑以显示不同的角色，不同的场景视角，或者可能同时发生动作。这是一种广泛用于各种电影院的工具（也许Dogme 95或Birdman except除外），如果电影艺术家想要使用它，则需要对其进行支持。</p><p> But what happens when the camera cuts with all the per-pixel temporal accumulation history for TAA/temporal supersampling? How about all the texture streaming that suddenly sees a completely new view? View-dependent amortized rendering like shadowmap caching? All solvable, but also a lot of work, or might introduce unacceptable delay / popping / prohibitive cost of the new frame. A colleague of mine also noted that this is a problem for physics or animations – often when the camera cuts and animators adjusted some positions, you see physical objects “settling in”, for example a necklace move on a character. Another immersion breaker that requires another series of custom “hacks”.</p><p> 但是，当相机使用TAA /时间超采样的所有每个像素的时间累积历史记录进行剪切时，会发生什么？突然看到全新视图的所有纹理流如何处理？与视图相关的摊销渲染，例如阴影映射缓存？所有这些都可以解决，但也需要大量工作，否则可能会导致新框架的延迟/弹出/成本过高。我的一位同事还指出，这是物理或动画方面的问题–通常当相机切割并且动画师调整了某些位置时，您会看到物理物体“沉入其中”，例如项链在角色上移动。另一个浸入式断路器需要另一系列的自定义“ hacks”。</p><p> Conversely,  lack of camera cuts (like in  God of War) is also difficult, especially for cinematics lighting, good animations, transitions etc. In any case – both need to be solved/accounted for. Even worth adding a flag “camera was cut” in the renderer.</p><p> 相反，缺乏镜头的裁剪也很困难（例如在《战神》中），尤其是对于电影照明，良好的动画，转场等。无论如何，这两者都需要解决/解决。甚至值得在渲染器中添加标志“相机被剪切”。</p><p>  Games generally don’t render what you don’t see in the camera frustum – which is obviously desirable, as why would you waste cycles on it?</p><p>  游戏通常不会呈现您在摄像机视锥中看不到的内容-这显然是可取的，因为为什么您会浪费时间呢？</p><p>  Now, it gets more complicated! Why would you animate objects that are not visible? Not doing so can save a lot of CPU time.</p><p>  现在，它变得更加复杂！为什么要设置不可见对象的动画？不这样做可以节省大量CPU时间。 </p><p> However things being visible in the main view is only part of the story – there are reflections, shadows… I cannot count in how many games I have seen the shadows of the off-screen characters in the “T-pose” (default pose when a character is not animated). Raytracing that can “touch” any objects poses a new challenge here!</p><p>但是，在主视图中可见的内容只是故事的一部分–反射，阴影……我不能指望在“ T姿势”（默认姿势为角色没有动画）。可以“触摸”任何物体的光线追踪在这里提出了新的挑战！</p><p>   Occlusion culling is the next step after frustum culling. You don’t want to render things outside of the camera? Sure. But if in front of the camera there is a huge building, you also  don’t want to render the whole city behind it!</p><p>   截锥剔除是平截头剔除之后的下一步。您不想在相机外部渲染物体吗？当然。但是，如果在镜头前有一个巨大的建筑物，那么您也不想在其后面渲染整个城市！</p><p>  Robust occlusion culling (together with the LOD, streaming etc. below) is in many ways an unsolved problem – all existing solutions require compromises, precomputation, or extremely complex pipelines.</p><p>  健壮的遮挡剔除（连同下面的LOD，流等）在许多方面都是无法解决的问题-所有现有解决方案都需要折衷，预先计算或极其复杂的管道。</p><p> In a way an occlusion culling system is a new rendering feature that has to go through all the steps that I list in this post! 🙂 But given its complexity and general fragility of many solutions – yet another aspect to consider, we don’t want to make it even more difficult.</p><p> 在某种程度上，遮挡剔除系统是一项新的渲染功能，必须经过我在本文中列出的所有步骤！ 🙂但是，鉴于其复杂性和许多解决方案的总体脆弱性-需要考虑的另一个方面，我们不想使其变得更加困难。</p><p>  Any technique that requires some computational budget to render and memory usage needs to “scale” properly with distance. When the rendered object is 100m away and occupies a few pixels, you don’t want it to eat 100MB of memory or its rendering/</p><p>  任何需要一些计算预算来渲染和占用内存的技术都需要随距离适当地“缩放”。当渲染的对象在100m之外且占用几个像素时，您不希望它占用100MB的内存或它的渲染/</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bartwronski.com/2020/12/27/why-are-video-games-graphics-still-a-challenge-productionizing-rendering-algorithms/">https://bartwronski.com/2020/12/27/why-are-video-games-graphics-still-a-challenge-productionizing-rendering-algorithms/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/games/">#games</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/渲染/">#渲染</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>