<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>RISC和CISC在2020年意味着什么？What do RISC and CISC mean in 2020?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What do RISC and CISC mean in 2020?<br/>RISC和CISC在2020年意味着什么？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-21 12:25:50</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/1933307081dac539de420c7564fded04.jpeg"><img src="http://img2.diglog.com/img/2020/11/1933307081dac539de420c7564fded04.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Many today say the difference between RISC and CISC has become irrelevant. Is that true? And if not what exactly is the difference between modern RISC and CISC CPUs?</p><p>如今，许多人说RISC和CISC之间的区别变得无关紧要。真的吗？如果不是，那么现代RISC和CISC CPU之间到底有什么区别？</p><p>   Apple has now released the M1 Apple Silicon chips, and after all the fuzz you may be wonder what makes it different from an intel or AMD processor? You have probably heard M1 referred to as an ARM processor and that ARM is a so called RISC processor, unlike x86 processors from intel and AMD.</p><p>Apple现在已经发布了M1 Apple Silicon芯片，经过一番摸索，您可能想知道它与Intel或AMD处理器有何不同？您可能听说过M1被称为ARM处理器，而ARM是所谓的RISC处理器，与Intel和AMD的x86处理器不同。</p><p> If you try to read up about the difference between RISC and CISC microprocessors, you will hear a lot of people tell you that RISC and CISC doesn’t matter anymore. That they are essentially the same. But is that really true?</p><p>如果您想了解RISC和CISC微处理器之间的区别，您会听到很多人告诉您RISC和CISC不再重要。它们本质上是相同的。但这是真的吗？</p><p> Okay, so you are confused and you want some straight answers. Well, then this article is the right place for you to start.</p><p>好吧，所以您很困惑，您想要一些直接的答案。好吧，那么本文是您开始的正确地方。</p><p> I have plowed through a ton of comments and writing on this, sometimes by the engineers themselves that created these chips, so you don’t have to waste time on this.</p><p>我经过大量评论并为此撰写了文章，有时是由创建这些芯片的工程师自己撰写的，因此您不必在此上浪费时间。</p><p> First I will start with some of the basics you got to understand before we begin to answer some of the deeper questions such as RISC vs CISC. I am putting in headlines, so you can skip over the stuff you already know.</p><p>首先，在开始回答一些更深层次的问题（例如RISC vs CISC）之前，我将首先介绍一些您必须了解的基础知识。我将成为头条新闻，因此您可以跳过已经知道的内容。</p><p>    Let us just clarify what a microprocessor is. You probably already have some idea, otherwise you would not have clicked on this article.</p><p>让我们澄清一下微处理器是什么。您可能已经有了一些主意，否则您将无需单击本文。</p><p> The CPU is basically the brain of the computer. It reads instructions from memory, telling the computer what to do. These instructions are just numbers which have to be interpreted a specific way.</p><p>CPU基本上是计算机的大脑。它从内存中读取指令，告诉计算机该怎么做。这些说明只是数字，必须以特定的方式进行解释。</p><p> There is nothing in memory that marks a number off as being just a number or specifically an instruction. Instead it is up to the makers of the operating system and programs to make sure instructions and data is put into the locations where the CPU expects to find program code and data.</p><p>内存中没有任何东西可以将数字标记为数字或特定的指令。而是由操作系统和程序的制造者来确保将指令和数据放入CPU期望找到程序代码和数据的位置。</p><p> Microprocessors (CPUs) do very simple things. Here is an example of the kind of instructions a CPU follows:</p><p>微处理器（CPU）做非常简单的事情。这是CPU遵循的一种指令示例：</p><p>  This is a human readable form of what would just be a list of numbers in the computer. For instance  load r1, 150 would in a typical RISC CPU be represented by a single 32-bit number. That means a number with 32 digits, where each digit must be a 0 or 1.</p><p>这是人类可读的形式，只是计算机中的数字列表。例如，负载r1在典型的RISC CPU中将由单个32位数字表示。这表示一个包含32位数字的数字，其中每个数字必须为0或1。</p><p> load in first line, moves the contents of memory location 150 to register  r1. Your computer memory (RAM) is a collection of billions of numbers. Each of these numbers has an address (location) so that the CPU has a way of picking the right one.</p><p>在第一行加载时，将存储单元150的内容移至寄存器r1。您的计算机内存（RAM）是数十亿个数字的集合。这些数字中的每一个都有一个地址（位置），以便CPU有一种选择正确的数字的方式。</p><p>  Next, you may wonder what a  register is. This is actually a pretty old concept. Old mechanical cash registers in convenience stores also had the concept of  registers. Back then a register was some sort of mechanical contraption that held the number you want to operate on. Often it would have an  accumulator  register which you could add values to. It would keep track of the sum.</p><p>接下来，您可能想知道什么是寄存器。这实际上是一个非常古老的概念。便利店中的旧机械收银机也有收银机的概念。那时的收银机是某种机械装置，可以存放您要操作的号码。通常它会有一个累加器寄存器，您可以向其中添加值。它将跟踪总和。</p><p> Your electronic calculator is the same. What you see most of the time on the display is the contents of the accumulator. You do a bunch of computations that affect the contents of the accumulator.</p><p>您的电子计算器是相同的。大部分时间在显示屏上看到的是累加器的内容。您进行了大量影响累加器内容的计算。</p><p> CPUs are the same. They have a number of registers often given simple names such as A, B, C or r1, r2, r3, r4 etc. CPU instructions usually do operations on these registers. They may add two numbers together stored in different registers.</p><p>CPU是一样的。它们有许多寄存器，通常使用简单的名称，例如A，B，C或r1，r2，r3，r4等。CPU指令通常在这些寄存器上执行操作。它们可以将两个数字加在一起存储在不同的寄存器中。</p><p> In our example  add r1, r2 adds the contents of  r1 and  r2 together and store the result in  r1.</p><p>在我们的示例中，将r1和r2相加，将r1和r2的内容相加，并将结果存储在r1中。</p><p> Finally we want to store the result in memory (RAM) using  store r1, 310, which stores the result in the memory cell with address 310.</p><p>最后，我们要使用存储区r1 310将结果存储在内存（RAM）中，该存储区将结果存储在地址为310的存储单元中。</p><p>  As you can imagine there is a limited number of instructions that a CPU understands. If you are familiar with regular programming where you can define your own functions, machine code is  not like that.</p><p>可以想象，CPU可以理解的指令数量有限。如果您熟悉可以定义自己的函数的常规编程，那么机器代码就不是这样。</p><p> There is a  fixed number of instructions that the CPU understands. You as a programmer cannot add to this set.</p><p>CPU可以理解固定数量的指令。您作为程序员不能添加到该集合中。</p><p> There are a large number of different CPUs, and they don’t all use the same instruction set. That means they will not interpret numbers for instructions the same way.</p><p>有很多不同的CPU，它们并不都使用相同的指令集。这意味着他们不会以相同的方式解释指令的数字。</p><p> In one CPU architecture  501012 may mean  add r10, r12 while in another architecture it may mean  load r10, 12. The combination of instructions a CPU understands and the registers it knows about is called the  Instruction Set Architecture (ISA).</p><p>在一个CPU体系结构中501012可能意味着添加r10，r12，而在另一体系结构中可能意味着加载r10、12。CPU理解的指令和它所知道的寄存器的组合称为指令集体系结构（ISA）。</p><p> Intel and AMD chips e.g. both understand the x86 ISA. While e.g. the chips Apple use in their iPhone and iPad devices such as the A12, A13, 14 etc all understand the ARM ISA. And now we can add M1 to that list.</p><p>英特尔和AMD芯片，例如都了解x86 ISA。虽然苹果在其iPhone和iPad设备中使用的芯片（例如A12，A13、14等）都了解ARM ISA。现在我们可以将M1添加到该列表中。</p><p> These chips are what we call Apple Silicon. They use the ARM ISA, like many other mobile phones and tablets. Even gaming consoles such as Nintendo and the worlds current fastest super computer uses the ARM ISA.</p><p>这些芯片就是我们所谓的Apple Silicon。他们像许多其他手机和平板电脑一样使用ARM ISA。甚至任天堂等游戏机和世界上最快的超级计算机也使用ARM ISA。</p><p> x86 and ARM is not interchangeable. A computer program will be compiled for a particular ISA, unless it is a JavaScript, Java, C# or similar. In this case the program is compiled to byte code which is a CPU-like ISA, but for a CPU that doesn’t really exist. You need a  Just in Time Compiler or interpreter to translate this made up instruction set to the actual instruction set used on the CPU in your computer.</p><p>x86和ARM不可互换。除非是JavaScript，Java，C＃或类似程序，否则将为特定的ISA编译计算机程序。在这种情况下，程序被编译为字节代码，这是类似CPU的ISA，但对于实际上并不存在的CPU。您需要即时编译器或解释器，以将此组合指令集转换为计算机CPU中使用的实际指令集。</p><p>  This means that most current programs on the Apple Macs will not run out of the box on the new Apple Silicon based Macs. Current programs are made up of x86 instructions. To solve this programs have to be recompiled for the new ISA. And Apple has an ace up their sleeve with  Rosetta 2, which is a program that will translate x86 instructions to ARM instructions before it is run.</p><p>这意味着Apple Macs上的大多数当前程序都不会在新的基于Apple Silicon的Macs上开箱即用。当前程序由x86指令组成。为了解决这个问题，必须为新的ISA重新编译程序。而Apple拥有Rosetta 2的优势，该程序可以在运行之前将x86指令转换为ARM指令。</p><p>  Now the next question is. Why use a new ISA for their Macs? Why couldn’t Apple just make their Apple Silicon understand the x86 instructions? No recompile or translation with  Rosetta 2 needed.</p><p>现在下一个问题是。为什么要为Mac使用新的ISA？苹果为什么不让他们的Apple Silicon理解x86指令？无需使用Rosetta 2重新编译或翻译。</p><p> Well, it turns out all instruction sets are not created equal. The ISA of a CPU heavily influence how you can design the CPU itself. The particular ISA you use can complicate or simplify the job of creating a high performance CPU or a CPU that consumes little power.</p><p>好吧，事实证明并非所有指令集都相等。 CPU的ISA在很大程度上影响您可以如何设计CPU本身。您使用的特定ISA可能会使创建高性能CPU或功耗很小的CPU的工作复杂化或简化。</p><p> The second issue is licensing. Apple cannot freely make their own CPUs with an 86 ISA. It is part of Intel’s intellectual property and they don’t want competitors. The ARM company in contrast doesn’t actually build their own CPUs. They just design the ISA and provide reference designs for CPUs implementing this ISA.</p><p>第二个问题是许可。 Apple无法使用86 ISA自由地制造自己的CPU。它是英特尔知识产权的一部分，他们不想要竞争对手。相比之下，ARM公司实际上并没有构建自己的CPU。他们只是设计ISA，并为实现该ISA的CPU提供参考设计。</p><p> Hence ARM lets you do almost exactly what you want. This is what Apple wants. They want to create tailor made solutions for their computers with specialized hardware handling things like machine learning, encryption and face recognition. If you go with x86 you have to do all that on external chips. For efficiency reasons Apple wants to do all that stuff in one large integrated circuit, or what we call a  System on a Chip (SoC).</p><p>因此，ARM使您几乎可以完全按照自己的意愿做。这就是苹果想要的。他们希望为计算机创建量身定制的解决方案，并使用专门的硬件处理诸如机器学习，加密和面部识别之类的事情。如果使用x86，则必须在外部芯片上进行所有操作。出于效率方面的考虑，Apple希望在一个大型集成电路或所谓的片上系统（SoC）中完成所有这些工作。</p><p> This is a development that began on smart phones and tablets. They are too small to have lots of different separate chips on some big  motherboard. Instead they must integrate everything typically spread out over one motherboard into one chip, that contains CPU, GPU, memory and other specialized hardware.</p><p>这是从智能手机和平板电脑开始的发展。它们太小，无法在大型主板上具有许多不同的独立芯片。相反，他们必须将通常分布在一个主板上的所有东西集成到一个芯片中，该芯片包含CPU，GPU，内存和其他专用硬件。</p><p> Now this trend is arriving on laptops and likely later on desktop PCs. Tight integration gives better performance, and here x86 with their inflexible licensing scheme is a big disadvantage.</p><p>现在，这种趋势已经出现在笔记本电脑上，并且可能稍后会出现在台式机上。紧密的集成提供了更好的性能，在这里x86及其僵化的许可方案是一个很大的缺点。</p><p> But let us not derail what this article is primarily about: RISC vs CISC. Instruction Set Architectures tend to follow different core philosophies for how the ISA is defined. x86 is what we call a CISC architecture. While ARM follows the RISC philosophy. That makes a big difference. So let us delve into the key difference.</p><p>但是，让我们不要偏离本文的主要内容：RISC vs CISC。指令集体系结构倾向于遵循不同的核心哲学来定义ISA。 x86是我们所谓的CISC架构。而ARM遵循RISC哲学。那有很大的不同。因此，让我们深入研究关键区别。</p><p>   CISC stands for  Complex Instruction Set Computer, while RISC stands for  Reduced Instruction Set Computer.</p><p>CISC代表复杂指令集计算机，而RISC代表精简指令集计算机。</p><p> Explaining what the difference is today, is harder than when RISC first came out because both RISC and CISC processor have stolen ideas form each other, and there has been a heavy marketing campaign with the interest of bluring the distinction.</p><p>要解释今天的差异，要比RISC初次问世时要困难得多，因为RISC和CISC处理器都相互盗取了思想，并且开展了一场激烈的营销活动，目的是模糊区分。</p><p>  Paul DeMone writes  this article back in 2000, which gives some idea of the marketing pressure that developed early on.</p><p>保罗·德曼（Paul DeMone）早在2000年就撰写了这篇文章，对早期发展的营销压力给出了一些想法。</p><p> Back in 1987, the top of the line x86 processor was an intel 386DX, while a top of the line RISC processor was  MIPS R2000.</p><p>早在1987年，顶级x86处理器是Intel 386DX，而顶级RISC处理器是MIPS R2000。</p><p> Despite the fact that the intel processor had more transistors, 275 000 vs 115 000 on the MIPS and had twice as much cache, the x86 processor was completely demolished in performance tests.</p><p>尽管intel处理器的晶体管数量更多，在MIPS上为275 000 vs 11.5万，并且具有两倍的高速缓存，但是x86处理器在性能测试中被完全拆除。</p><p> Both processors ran at 16 MHz clock rate, but the RISC processor had 2–4 times higher performance, depending on benchmark used.</p><p>两种处理器均以16 MHz的时钟速率运行，但是RISC处理器的性能要高出2-4倍，具体取决于所使用的基准。</p><p> Thus it is not strange that by the early 90s it had become a generally accepted idea that RISC processors had vastly better performance.</p><p>因此，到90年代初，RISC处理器的性能大大提高已成为人们普遍接受的想法就不足为奇了。</p><p> Intel thus started getting a perception problem in the market. They had problems convincing investors and buyers that their outdated CISC design could beat a RISC processor.</p><p>因此，英特尔开始在市场上出现认知问题。他们很难说服投资者和买家他们过时的CISC设计可以击败RISC处理器。</p><p> Thus Intel began marketing their chips as being RISC processors, with a simple decoding stage in front which turned CISC instructions into RISC instructions.</p><p>因此，英特尔开始将其芯片作为RISC处理器进行营销，并在其前面进行了简单的解码，从而将CISC指令转换为RISC指令。</p><p> Thus Intel could present themselves in an attractive way: They would say with our chips you still get technologically superior RISC processors but our RISC processors understands x86 instructions which you already know and love.</p><p>因此，英特尔可以以吸引人的方式展示自己：他们会说，使用我们的芯片，您仍然可以获得技术上更先进的RISC处理器，但是我们的RISC处理器能够理解您已经知道并喜欢的x86指令。</p><p> But let us clarify this right away: There are no RISC internals in x86 chips. That is just a marketing ploy. Bob Colwells, one of the main creators of the intel Pentium Pro, regarded as the chip with RISC inside makes  this clear himself.</p><p>但是，让我们立即进行澄清：x86芯片中没有RISC内部结构。那只是营销策略。英特尔奔腾Pro的主要创造者之一鲍勃·科威尔斯（Bob Colwells）被认为是内置RISC的芯片，这一点很明显。</p><p> You will however see this falsehood propagated all over the internet, because Intel was really good at pushing this marketing ploy. It works because there are some half truths to it. But in order to really understand RISC vs CISC you really have to begin by dispensing with this myth.</p><p>但是，您会看到这种虚假信息在整个Internet上传播，因为英特尔确实擅长推动这种营销策略。之所以有效，是因为其中包含了一些事实。但是，为了真正理解RISC与CISC，您必须首先摆脱这个神话。</p><p> Thinking that a CISC processor can have a RISC processor inside it will just confuse you about the difference between RISC and CISC.</p><p>认为CISC处理器内部可以装有RISC处理器，只会使您对RISC和CISC之间的区别感到困惑。</p><p>  Okay with that rant out of the way, let us look at what RISC and CISC is really about. Both are about philosophies in how you design a CPU.</p><p>好的，不用担心，让我们看一下RISC和CISC的真正含义。两者都是关于如何设计CPU的哲学。</p><p> Let us begin by looking at the CISC philosophy. CISC is harder to pin down as the chips we label CISC have a large variety of designs. But we can still talk about some common patterns.</p><p>让我们开始看看CISC的哲学。由于我们标记为CISC的芯片具有多种设计，因此CISC很难确定。但是我们仍然可以谈论一些常见的模式。</p><p> Back in the late 1970s when CISC processor began development, memory was still really expensive. Compilers were also really bad and people tended to write programs in assembly code by hand.</p><p>早在1970年代末CISC处理器开始开发时，内存仍然非常昂贵。编译器也确实很糟糕，人们倾向于手工编写汇编代码程序。</p><p> Because memory was expensive, you needed to find ways of conserving it. The way of doing this was to come up with really powerful CPU instructions which could do a lot of stuff.</p><p>因为内存很昂贵，所以您需要找到保存内存的方法。这样做的方法是想出功能强大的CPU指令，可以完成很多工作。</p><p> This also helped Assembly programmers as they could more easily code programs, as there would always be some single instruction that did what they wanted.</p><p>这也有助于汇编程序员，因为他们可以更轻松地编写程序，因为总有一些指令可以完成他们想要的事情。</p><p> This started after a while to get really complicated to deal with. Designing decoders for all these instructions became a hassle. One way they solved this with initially was to invent  Microcode.</p><p>一段时间后开始，这变得非常复杂。为所有这些指令设计解码器变得很麻烦。他们最初解决此问题的一种方法是发明微码。</p><p> In program you know you can avoid repeating common tasks by placing them in a separate  subroutine (function), which you could call repeatedly.</p><p>在程序中，您知道可以将重复的任务放在单独的子例程（函数）中，从而避免重复执行这些任务。</p><p> The idea of Microcode was similar. For each machine code instruction in the ISA you make a little program stored in special memory inside the CPU made up of much simpler instructions called Microcode.</p><p>微码的想法与此类似。对于ISA中的每条机器代码指令，您都会制作一个小程序，该程序存储在CPU内部的特殊存储器中，该程序由简单得多的指令（​​称为微码）组成。</p><p> Thus the CPU would have a small set of simple Microcode instructions. They could then add lots of advance ISA instructions by simply adding new little Microcode programs inside the CPU.</p><p>因此，CPU将具有一小组简单的微码指令。然后，他们可以通过简单地在CPU内添加新的小型Microcode程序来添加许多高级ISA指令。</p><p> This had the added benefit that the memory holding these Microcode programs was Read-Only Memory (ROM), which at the time was much cheaper than RAM. Hence reducing RAM usage at the expense of increasing ROM usage was an economic tradeoff.</p><p>这样做还有一个好处，就是保存这些微代码程序的存储器是只读存储器（ROM），当时它比RAM便宜得多。因此，以增加ROM使用量为代价来减少RAM使用量是一种经济上的权衡。</p><p> So everything looked really nice in CISC land for a while. But eventually they started running into problems. All these Microcode programs became a problem to deal with. Sometimes they would make a programming mistake. Fixing a microcode program with a bug, was a much bigger hassle than fixing a bug in a regular program. You cannot access and test that code like you access and test regular software.</p><p>因此，一段时间以来，CISC领域的一切看起来都非常好。但是最终他们开始遇到问题。所有这些微代码程序都成为要解决的问题。有时他们会犯编程错误。修复带有错误的微代码程序比修复常规程序中的错误要麻烦得多。您无法像访问和测试常规软件一样访问和测试该代码。</p><p> Some people started thinking: there has to be a simpler way of dealing with this mess!</p><p>有些人开始思考：必须有一种更简单的方法来处理这种混乱！</p><p>  RAM started getting cheaper, compilers got better and people were not programming as much in assembly code anymore.</p><p>RAM开始变得越来越便宜，编译器变得越来越好，人们不再用汇编代码进行编程了。</p><p>  They had started observing by analyzing programs that the complex instructions that was added to CISC was not used very much by people.</p><p>他们通过分析程序开始观察到，添加到CISC的复杂指令很少被人们使用。</p><p> Compiler writers also found it hard to pick one of these complex instructions. Instead they preferred to combine simpler instructions to get the job done.</p><p>编译器作者还发现很难选择这些复杂的指令之一。相反，他们更喜欢结合更简单的说明来完成工作。</p><p> You could say we had a case of the 80/20 rule. Roughly 80% of the time was spent running 20% of the instructions.</p><p>您可以说我们有80/20规则的情况。大约80％的时间用于执行20％的指令。</p><p> So the RISC idea was: Let us ditch the complex instructions and replace them with fewer simple instructions. Instead of debugging and fixing Microcode programs which is hard. You leave it to compiler writers to solve the issues.</p><p>因此，RISC的想法是：让我们放弃复杂的指令，并用更少的简单指令代替它们。而不是调试和修复很难的微码程序。您将其留给编译器作者解决。</p><p> There is some contention in what the word  Reduced should be interpreted as in relation to RISC. It has been interpreted as reducing the number of instructions. But a more sensible interpretation is that it means a reduction in instruction complexity. Meaning the instructions themselves are made simpler. This does not necessarily mean simple seen from the perspective of the user, but rather simpler to implement in hardware and preferably utilizing few CPU resources at the same time.</p><p>对于“精简”一词应解释为与RISC有关，有些争议。它被解释为减少了指令数量。但是更合理的解释是，这意味着降低了指令的复杂性。意味着说明本身变得更简单。从用户的角度看，这并不一定意味着简单，而是在硬件中实现更简单，并且最好同时利用很少的CPU资源。</p><p> RISC code is not necessarily easier to write for a human. I made that mistake years ago when I thought I would save time writing my assembly code using PowerPC instructions (an IBM RISC architecture with tons of instructions). It gave me a lot of extra work and frustrations.</p><p>RISC代码不一定适合人类编写。多年前我犯了一个错误，当时我以为可以节省使用PowerPC指令（带有大量指令的IBM RISC体系结构）编写汇编代码的时间。它给了我很多额外的工作和挫败感。</p><p> One of the key rationals behind RISC was that people had stopped handwriting assembly code and you needed an instruction set which was easy for compilers to deal with. RISC is optimized for compilers not necessarily for humans.</p><p>RISC背后的关键原理之一是人们停止了手写汇编代码，而您需要一个易于编译器处理的指令集。 RISC针对编译器进行了优化，而未必针对人类。</p><p> Although particular RISC instruction sets can in some ways feel easier to write for a human because there are a lot fewer instructions to learn. On the other hand you typically have to write more instructions than if you used a CISC instruction set.</p><p>尽管特定的RISC指令集在某种程度上可以让人类更容易编写，因为要学习的指令要少得多。另一方面，与使用CISC指令集相比，通常必须编写更多的指令。</p><p>  Another core idea of RISC was pipelining. Let me give you a simple analogy to give a motivation for what this is about.</p><p>RISC的另一个核心思想是流水线。让我给您一个简单的类比，以为这是一个动机。</p><p> Think of shopping in the grocery store. Now this works a bit different in every country, but I am basing this on how it works in my native Norway. You can divide the activities at the cash register in multiple steps:</p><p>想想在杂货店购物。现在，这在每个国家/地区都略有不同，但是我将基于它在我的祖国挪威的运作方式。您可以通过多个步骤在收银机中划分活动：</p><p>   If this happened in a non-pipeline fashion, which is how most CISC processor operated initially, then the next customer would not begin putting their groceries on the conveyer belt until you had packed up all your groceries and left.</p><p>如果这是大多数CISC处理器最初采用的非流水线方式，那么下一个客户就不会开始将杂货放在传送带上，直到您将所有杂货打包好并离开为止。</p><p> This is inefficient, because the conveyer belt could be used to scan items while you pack. Even the payment terminal could be used while you pack. Resources are thus under utilized.</p><p>这是低效的，因为打包时可以使用传送带扫描物品。您甚至可以在打包时使用付款终端。因此资源被利用不足。</p><p> We can think of each step as taking a clock cycle or time unit. That means it takes 3 time units to process each customer. Thus in 9 time units you have only processed 3 customers.</p><p>我们可以将每个步骤视为一个时钟周期或时间单位。这意味着处理每个客户需要3个时间单位。因此，在9个时间单位中，您只处理了3个客户。</p><p> However we could pipeline this process. Once I start operating the payment terminal, the next customer could put their food products on the conveyor belt.</p><p>但是我们可以通过管道进行此过程。一旦我开始操作付款终端，下一位客户便可以将他们的食品放在传送带上。</p><p> When I start packing, this customer could use the payment terminal which I just finished using. A third customer could at this point begin putting their groceries on the conveyor belt.</p><p>当我开始打包时，此客户可以使用我刚刚使用的付款终端。此时，第三位客户可以开始将杂货放在传送带上。</p><p> The result of this approach is that every time unit somebody will be finish packing and leaving with their groceries. Thus in 9 time units you would process 6 customers. As time increases, you would get close to processing one customer in just 1 time unit, all thanks to pipelining. That is a 9x speedup.</p><p>这种方法的结果是，每个单位有人将完成包装并随身携带食品杂货。因此，您将以9个时间单位处理6个客户。随着时间的增加，由于流水线化，您将接近在1个时间单位内处理一位客户。那是9倍的加速。</p><p> We could describe using the cash register as having a latency of 3 time units, but a throughput of one shopping per 1 time unit.</p><p>我们可以将收银机描述为具有3个时间单位的延迟，但每1个时间单位一次购物的吞吐量。</p><p> In microprocessor terminology this would mean 1 instruction has a latency of 3 clock cycles, but an average throughput of 1 instruction per clock cycle.</p><p>用微处理器术语，这意味着1条指令的等待时间为3个时钟周期，但平均吞吐量为每个时钟周期1条指令。</p><p> Now there was a bunch of assumption I put into this example, which was that every stage in the checkout took equal amounts of time. That putting groceries on the conveyor belt took about the same time as operating the payment terminal or packing the groceries.</p><p>现在，我在此示例中做出了很多假设，即结帐的每个阶段花费的时间相同。将杂货放在传送带上的时间大约与操作付款终端或包装杂货的时间相同。</p><p> If the times varies a lot for each stage, this does not work well. E.g. if somebody has a lot of groceries on the conveyor belt, then the payment terminal and packing area remain unused for many time unites, dropping the efficiency of the whole thing.</p><p>如果每个阶段的时间相差很大，则效果不佳。例如。如果某人在传送带上有很多杂货，则支付终端和包装区域在很多时间都未使用，这会降低整体效率。</p><p> RISC designers understood this. Thus they tried to standardize how long each instruction is and split up what an instruction does into stages which take roughly the same time. That way each resource inside the CPU can remain utilized to the max constantly as instructions get processed.</p><p>RISC设计师了解这一点。因此，他们试图标准化每条指令的时间长度，并将一条指令的工作分成大致相同时间的多个阶段。这样，随着指令的处理，CPU内部的每个资源都可以不断地最大化利用。</p><p> E.g. if we look at the ARM RISC processor, it has a 5-stage pipeline for processing instructions:</p><p>例如。如果我们看一下ARM RISC处理器，它有一个5级管道来处理指令：</p><p> Fetch instruction from memory and update program counter to be able to fetch next instruction next clock cycle.</p><p>从存储器中获取指令并更新程序计数器，以便能够在下一个时钟周期获取下一条指令。</p><p> Decode instruction. Meaning figure out what it is supposed to do. That means activating various electric wires to toggle on different parts of the CPU we are using to perform the instruction.</p><p>解码指令。弄清楚它应该做什么。这意味着激活各种电线以切换我们用来执行指令的CPU的不同部分。</p><p>  Memory Access data in memory if relevant. That is what a  load instruction would do.</p><p>内存访问内存中的数据（如果相关）。这就是加载指令的作用。</p><p> The ARM instructions have sections dealing with each of these parts, and each stage typically takes 1 clock cycle. This makes it easy to push ARM instructions through a pipeline.</p><p>ARM指令的各个部分分别处理这些部分，每个阶段通常需要1个时钟周期。这使得通过管道推送ARM指令变得容易。</p><p> E.g. because each instruction has the same size, the  Fetch stage knows how to get the next instruction. It doesn’t need to decode first.</p><p>例如。因为每个指令的大小相同，所以Fetch阶段知道如何获取下一条指令。不需要先解码。</p><p> With CISC instructions is this tricky. Instructions can be variable length. So you don’t really know until you decode parts of the instruction where the next instruction will be.</p><p>使用CISC指令是很棘手的。指令可以是可变长度的。因此，直到您解码了下一条指令所在的部分后，您才真正知道。</p><p> The second problem is that CISC instructions can have arbitrary complexity. Making multiple memory accesses and doing a whole host of things which means you cannot easily divide a CISC instruction into cleanly separate parts which can execute in a staged fashion.</p><p>第二个问题是CISC指令可能具有任意复杂性。进行多个内存访问并执行全部操作，这意味着您无法轻松地将CISC指令划分为可以分阶段执行的干净独立的部分。</p><p> Pipelining was the killer feature, which really caused early RISC processors to destroy their CISC counterparts in performance.</p><p>流水线是杀手级功能，确实导致早期的RISC处理器破坏了其CISC同类产品的性能。</p><p>  To keep the number of cycles needed for each instruction relatively uniform and predictable to make everything pipeline friendly, RISC ISAs separate loading and storing to memory clearly from other instructions.</p><p>为了使每条指令所需的周期数相对统一和可预测，以使所有内容都流水线友好，RISC ISA与其他指令清楚地将加载和存储分开。</p><p> In CISC e.g. an instruction may load data from memory, perform an addition, multiplication or whatever and write the result back to memory.</p><p>在CISC中一条指令可以从内存中加载数据，执行加法，乘法或其他操作，然后将结果写回内存。</p><p> In the RISC world this is generally a big no-no. RISC operations such as add, shift, multiply etc generally only work on registers. They don’t access memory.</p><p>在RISC世界中，这通常是一个很大的禁忌。 RISC操作（例如加，移位，乘等）通常仅在寄存器上起作用。他们不访问内存。</p><p> This is important for pipelines to work. Otherwise instructions in pipelines can get all sorts of dependencies between them.</p><p>这对于管道正常工作很重要。否则，管道中的指令可以获取它们之间的各种依赖性。</p><p>  A big challenge for RISC relative to CISC is that with simpler instructions, more instructions are needed and memory, while not expensive, is slow. If a RISC program ends up consuming a lot more memory than a CISC program it can end up running a lot slower because the CPU is constantly waiting for slow memory reads.</p><p>相对于CISC而言，RISC面临的一大挑战是使用更简单的指令需要更多的指令，而内存虽然不昂贵，但速度较慢。如果RISC程序最终消耗的内存比CISC程序大得多，则运行起来可能会慢得多，因为CPU一直在等待慢速的内存读取。</p><p> RISC designers made some observations to solve this problem. They observed that a lot of instructions are really just moving data in and out of memory, to prepare for different operations. By having a larger number of registers, they could cut down on the number of times they had to write data back to memory.</p><p>RISC设计人员进行了一些观察以解决此问题。他们观察到，许多指令实际上只是将数据移入和移出内存，以准备进行不同的操作。通过拥有更多的寄存器，它们可以减少必须将数据写回内存的次数。</p><p> This did require improvements in compilers. Compilers had to analyze programs well and understand when they could keep variables in a register and when it had to be written back to memory. Juggling a ton of registers became an important thing for compilers to make RISC CPUs run fast.</p><p>这确实需要对编译器进行改进。编译器必须很好地分析程序，并了解何时可以将变量保存在寄存器中以及何时必须将其写回内存。处理大量寄存器已成为编译器使RISC CPU快速运行的重要任务。</p><p> Because RISC instructions were simpler. There was not lots of different addressing modes to deal with e.g. there was more bits available among the 32 bits for a whole instruction to specify the number of a register.</p><p>因为RISC指令更简单。没有太多不同的寻址模式要处理，例如在整个32位指令中，有更多位可用于指定寄存器的编号。</p><p> This is important to understand. A CPU could easily have hundred</p><p>了解这一点很重要。一个CPU可以轻松拥有数百个</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://erik-engheim.medium.com/what-does-risc-and-cisc-mean-in-2020-7b4d42c9a9de">https://erik-engheim.medium.com/what-does-risc-and-cisc-mean-in-2020-7b4d42c9a9de</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>