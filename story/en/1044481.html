<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Rust是制作Web API的困难方法 Rust is a hard way to make a web API</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rust is a hard way to make a web API<br/>Rust是制作Web API的困难方法 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-16 08:20:50</div><div class="page_narrow text-break page_content"><p>Rust is an amazing language. It has enabled excellent CLI tools like  ripgrep and  exa. Companies like Cloudflare are using Rust for their own systems and  encouraging people to write Rust to run microservices. Rust makes it possible to write really fast software that’s secure, tiny, and more concise than C++ or C.</p><p>Rust是一种很棒的语言。它启用了出色的CLI工具，例如ripgrep和exa。诸如Cloudflare之类的公司正在将Rust用于其自己的系统，并鼓励人们编写Rust以运行微服务。借助Rust，可以编写出比C ++或C更安全，更微型，更简洁的真正快速的软件。</p><p> If I were writing a geocoder, a routing engine, a real-time messaging platform, a database, or a CLI tool, Rust would be at the top of the list.</p><p> 如果我正在编写地理编码器，路由引擎，实时消息传递平台，数据库或CLI工具，Rust将位于列表的顶部。</p><p> But last year, I spent some time trying to make Rust work for a plain-vanilla API to power a normal website. It wasn’t a very good fit.</p><p> 但是去年，我花了一些时间试图使Rust在普通的API上工作，以为普通网站提供支持。这不是一个很好的选择。</p><p>  Rust has a fair number of web server frameworks, database connectors, and parsers. But building authentication? You have only  very low-level parts. Where Node.js will give you  passport and Rails has  devise and Django gives you an  auth model out of the box, in Rust you’re going to build this system by learning how to shuttle a shared vec into low-level crypto libraries. There are libraries trying to fix this, like  libreauth, but they’re nascent and niche. Repeat for plenty of other web framework problem areas.</p><p>  Rust具有相当数量的Web服务器框架，数据库连接器和解析器。但是建立身份验证？您只有非常低级的部分。 Node.js将为您提供护照，Rails进行了设计，而Django为您提供了一个现成的auth模型，在Rust中，您将通过学习如何将共享的vec传递到低级加密库中来构建该系统。有一些库试图解决此问题，例如libreauth，但是它们是新生事物，并且是利基市场。对其他许多Web框架问题重复上述步骤。</p><p> How about SDKs? In mainstream languages, you’ll be able to plug into Google Cloud services, AWS, or Stripe by bringing in an official library. Those libraries are mostly great. The  aws-sdk-js and  Stripe libraries, for example, are incredibly well-designed and maintained.</p><p> SDK怎么样？使用主流语言，您可以通过引入官方库来插入Google Cloud Services，AWS或Stripe。这些库大多很棒。例如，aws-sdk-js和Stripe库经过精心设计和维护。</p><p> Not so with Rust. There are a few third-party libraries trying to fill in the blanks, which is great, but with the sheer velocity of those services, will they really be able to give a quality experience?</p><p> Rust并非如此。有一些第三方库试图填补空白，这很棒，但是由于这些服务的飞速发展，他们真的能够提供优质的体验吗？</p><p> Some people will say  well, X language is so good you can just write an SDK yourself in a weekend! To which I must reply, no.</p><p> 有人会说，X语言很棒，您可以在周末自己编写一个SDK！我必须回答，不。 </p><p> Rust’s ecosystem is rich in other domains. The crates for building CLIs, managing concurrency, doing really impressive operations with binary data and low-level parsers - they’re spectacular.</p><p>Rust的生态系统在其他领域也很丰富。用于创建CLI，管理并发性，使用二进制数据和低级解析器进行令人印象深刻的操作的板条箱非常出色。</p><p>  I’ve been reading  Nicholas Nethercote’s  excellent blog for years now, in which he describes how the Rust team has made the compiler faster. And they certainly have made it faster!</p><p>  多年来，我一直在阅读Nicholas Nethercote的优秀博客，其中他描述了Rust团队如何使编译器更快。而且他们当然使它变得更快！</p><p> But compared to other languages you build websites with, it’s slow. It’s much slower than the Go compiler and much, much slower than the startup time for interpreted languages like JavaScript, Ruby, and Python.</p><p> 但是，与您用来建立网站的其他语言相比，它的速度很慢。它比Go编译器要慢得多，比JavaScript，Ruby和Python等解释型语言的启动时间要慢得多。</p><p> Once your code is compiled, everything’s amazing! But in my case, this basic API - which wasn’t even feature-complete and was by no means a complex system - took more than ten minutes to compile. On the weak hardware of  Google Code Build, it would run out of time, every time. We couldn’t build anything.</p><p> 编译代码后，一切都将变得非常棒！但就我而言，这个基本的API（甚至还没有功能完善而且绝不是一个复杂的系统）需要十多分钟的时间来编译。在Google Code Build较弱的硬件上，每次都会用完时间。我们什么都做不了。</p><p> Caching helps as long as you don’t have to rebuild cached dependencies. And, I don’t know, maybe  slimming down dependencies would help Rust projects compile faster. But  serde, for example - the JSON and other-format serializer/deserializer that nearly everyone uses - takes up a huge chunk of compile time. Should we replace serde with something that compiles faster but lacks great documentation and ecosystem support? It’s a bad trade.</p><p> 只要您不必重建缓存的依赖项，缓存就会有所帮助。而且，我不知道，也许减少依赖关系将有助于Rust项目更快地编译。但是例如serde（几乎每个人都使用的JSON和其他格式的序列化器/反序列化器）占用了大量的编译时间。我们是否应该使用编译速度更快但缺乏强大文档和生态系统支持的产品来代替serde？这是一笔不好的交易。</p><p>  Rust makes you think about dimensions of your code that matter tremendously for systems programming. It makes you think about how memory is shared or copied. It makes you think about real but unlikely corner cases and make sure that they’re handled. It helps you write code that’s incredibly efficient in every possible way.</p><p>  Rust使您考虑对系统编程至关重要的代码尺寸。它使您考虑如何共享或复制内存。它可以让您考虑真实但不太可能发生的极端情况，并确保已对它们进行处理。它可以帮助您以各种可能的方式编写出令人难以置信的高效代码。</p><p> These are all valid concerns. But for most web applications, they’re not the most important concerns. And buzzword-oriented thinking around them leads to some incorrect assumptions.</p><p> 这些都是有效的担忧。但是对于大多数Web应用程序而言，它们并不是最重要的问题。而围绕流行语的思考会导致一些错误的假设。 </p><p> Take, for example, Rust’s safety. This is a big part of the marketing, and it’s absolutely correct: Rust’s main promise is to be both  safe and  low-level - it works without a garbage collector, while at the same time protecting against memory-based exploits. When you read “safety”, think about Rust competing with C. Code in C can reference arbitrary memory, can easily overflow and segfault. Rust code can be just as fast as that C code, but protect that memory access, and without the cost of a garbage collector or some kind of runtime checking.</p><p>以Rust的安全为例。这是市场营销的重要组成部分，而且绝对正确：Rust的主要承诺是安全且低级别-它无需垃圾收集器即可工作，同时还能防止基于内存的漏洞。当您阅读“安全性”时，请考虑Rust与C竞争。C中的代码可以引用任意内存，可以轻松地溢出和段错误。 Rust代码可以与C代码一样快，但是可以保护该内存访问，而无需花费垃圾回收器或某种运行时检查的费用。</p><p> But Rust’s memory rules aren’t more secure than Node.js’s or Python’s. Your web application written in Rust isn’t going to be systematically more or less secure than an application in Python or Ruby. High-level languages with garbage collectors pay a performance penalty in exchange for generally dodging this whole class of exploits and bugs. You can’t reference uninitialized memory in JavaScript because you simply can’t reference memory-as-memory in JavaScript.</p><p> 但是Rust的内存规则并不比Node.js或Python的安全。用Rust编写的Web应用程序在系统上不会比使用Python或Ruby的应用程序更加安全。带有垃圾回收器的高级语言通常会回避整个漏洞利用和漏洞，以换取性能损失。您无法在JavaScript中引用未初始化的内存，因为您根本无法在JavaScript中引用作为内存的内存。</p><p>  This is describing the design goal of Node.js and other systems - they do occasionally have bugs that creep into this problem area. The  previous behavior of Node.js&#39;s Buffer object, for example, is a good read. Heck, if you ask  some people, Rust is  less secure than a GC’ed language for web apps if you use any crates that have  unsafe code - which includes Actix, the most popular web framework, because  unsafe code allows things like deferencing raw pointers.</p><p>  这是在描述Node.js和其他系统的设计目标-他们偶尔确实会出现一些漏洞，这些漏洞会潜入这个问题区域。例如，可以很好地了解Node.js的Buffer对象的先前行为。哎呀，如果您问一些人，如果您使用任何带有不安全代码的板条箱（包括最流行的Web框架Actix），Rust的安全性就不如GC应用程序的Web应用程序语言，因为不安全的代码允许诸如延迟原始指针之类的操作。</p><p> If you’re writing a video game, a pause to run garbage collection is bad. If you’re writing code for a microcontroller, any memory “overhead” or waste is really bad. But most web applications can spare a little memory overhead in exchange for productivity.</p><p> 如果您正在编写视频游戏，则暂停运行垃圾回收很不好。如果您正在为微控制器编写代码，那么任何内存“开销”或浪费都是非常糟糕的。但是大多数Web应用程序可以节省一点内存开销，以换取生产力。</p><p> This argument is pretty much the same for the other attributes of Rust. Its concurrency primitives are  amazing if you’re doing something complicated and need blistering-fast performance. But if you aren’t? The Rust async ecosystem is challenging, to say the least: there are different sorts of async, projects that span domains to do async implementations of unrelated stuff like  tokio.</p><p> 对于Rust的其他属性，此参数几乎相同。如果您要执行复杂的操作并且需要快速的性能，那么它的并发原语非常棒。但是，如果不是？至少可以说，Rust异步生态系统具有挑战性：存在各种类型的异步项目，这些项目跨越域来对不相关的东西（例如tokio）进行异步实现。</p><p> It feels a lot less like Node.js, which had a good async story but ugly syntax, than Python Tornado or Twisted, which had a weird async story and also ugly syntax.</p><p> 与Python.Tornado或Twisted（它们有一个怪异的异步故事，也有丑陋的语法）相比，它感觉上不像Node.js（它有一个很好的异步故事，但语法很丑）。</p><p> Async, I’m sure, will stabilize and homogenize and be a lot easier to do in the future. But I was working in the present.</p><p> 我敢肯定，异步将稳定和均匀化，并且将来会更容易实现。但是我现在正在工作。 </p><p>  There are many people currently learning Rust, writing CLI apps or low-level code in Rust, and having an extremely fun time. There are dramatically fewer people using Rust to write plain-vanilla web applications.</p><p>当前有很多人学习Rust，用Rust编写CLI应用程序或低级代码，并度过了一个非常愉快的时光。使用Rust编写普通的Web应用程序的人数大大减少。</p><p> This is an important part of the equation for technology choices: are there people working with the tool  and are they roughly in the same domain? Unfortunately, a lot of the incredibly exciting work in the Rust ecosystem has nothing to do with web application servers. There are some promising web frameworks - even a  somewhat higher-level framework - but they’re undoubtedly in a niche. Even Actix, the main web framework, has a  very top-heavy set of contributors.</p><p> 这是技术选择方程式的重要组成部分：是否有人在使用该工具，并且他们大致在同一领域吗？不幸的是，Rust生态系统中许多令人难以置信的激动人心的工作与Web应用程序服务器无关。有一些有前途的Web框架-甚至是更高级别的框架-无疑是利基市场。甚至主要的Web框架Actix也有大量的贡献者。</p><p> If Rust grows at its current rate, the web portion of the community will reach a sort of critical mass, but right - I don’t think there are enough people using Rust for websites for it to be a practical tool for websites. And compare to other communities in which there are entire companies dedicated to building web applications with existing tools - not cutting-edge work, but the kind of stuff that differentiates a mature technology from a new one.</p><p> 如果Rust的发展速度如此之快，社区的网络部分将达到某种临界水平，但是对-我认为没有足够的人将Rust用作网站，使其成为实用的网站工具。并与其他社区进行比较，在该社区中，整个公司都致力于使用现有工具来构建Web应用程序-不是尖端工作，而是将成熟技术与新技术区分开的那种东西。</p><p>  This part isn’t just about Rust, it’s about the GraphQL ecosystem and Rust’s involvement in that ecosystem is one example.</p><p>  这部分不仅涉及Rust，还涉及GraphQL生态系统，Rust参与该生态系统就是一个例子。</p><p> The  n+1 problem is something that everyone building web applications should understand. The gist is: you have a page of photos (1 query). You want to show the author of each photo. How many queries do you end up with: 1, combining the photos &amp; authors, or a query per photo to get the author after retrieving the photos? Or 2 queries, with the second having something like  user.id IN ids to fetch all authors in a single pass and then reconnect them to their photos.</p><p> n + 1问题是每个构建Web应用程序的人都应该理解的问题。要点是：您有一张照片页面（1个查询）。您想显示每张照片的作者。您最终要进行多少次查询：1，合并照片＆amp;作者，或查询每张照片以检索照片后获得作者？或2个查询，第二个查询具有诸如user.id IN ID之类的内容，可一次性获取所有作者，然后将其重新连接到他们的照片。</p><p> n+1 queries are usually the highest-priority database fixes: they’re usually high-impact, and changing an n+1 query into a single query is usually a big win. And we have lots of ways to try and resolve them: you can write SQL and try to get a lot done in a single query using CTEs and JOINs, like we did at Observable, or use an ORM layer like ActiveRecord that has  quick ways to turn n+1 queries into predictable queries.</p><p> n + 1查询通常是优先级最高的数据库修复程序：它们通常具有很高的影响力，并且将n + 1查询更改为单个查询通常是一个大胜利。我们有很多方法来尝试解决它们：您可以编写SQL并尝试使用CTE和JOIN在单个查询中完成很多工作，就像我们在Observable所做的那样，或者使用ActiveRecord之类的ORM层来快速地解决这些问题。将n + 1个查询变成可预测的查询。</p><p> We were using  Juniper, a  GraphQL server for Rust applications. GraphQL basically lets your  frontend application define queries, instead of the backend. You give it a range of things it could query, and the application - React or something else - sends arbitrary queries to the backend.</p><p> 我们正在使用Juniper，这是用于Rust应用程序的GraphQL服务器。 GraphQL基本上允许您的前端应用程序定义查询，而不是后端。您给它提供了一系列可以查询的内容，然后应用程序-React或其他东西-将任意查询发送到后端。 </p><p> This makes things  hard for the backend. Any sort of SQL-level optimization is impossible - your server is writing dynamic SQL, so you rely on the intelligence of your GraphQL server, which is not always high. Juniper, for example: n+1 queries by default. The workaround -  a dataloader - is rough and independently maintained. So at the end of the day, you’re going to have a blisteringly-fast application layer that’s spending all of its time inefficiently querying your database.</p><p>这使后端变得困难。任何形式的SQL级优化都是不可能的-您的服务器正在编写动态SQL，因此您依赖于GraphQL服务器的智能，而这种智能并不总是那么高。以Juniper为例，默认情况下为n + 1个查询。解决方法-数据加载器-很粗糙并且需要独立维护。因此，归根结底，您将拥有一个快速增长的应用程序层，该层将花费所有的时间低效地查询数据库。</p><p> The word is that GraphQL works really well with non-SQL databases which can serve these sorts of requests fast. I’m sure that there’s some special database used internally at Facebook that’s incredible in combination with GraphQL, but the rest of industry is pretty attached to Postgres and its ilk,  for good reason.</p><p> 这个词就是说GraphQL与非SQL数据库可以很好地配合使用，后者可以快速地满足这类请求。我敢肯定，在Facebook内部使用了一些特殊的数据库，将其与GraphQL结合使用令人难以置信，但是，出于充分的原因，其余行业都与Postgres及其同类紧密相关。</p><p>  So I tried to lead with the main caveat: this isn’t about Rust in general. It’s about using the language and its ecosystem for a particular goal. Simple web APIs.</p><p>  因此，我尝试着主要警告：这与Rust无关。这是关于将语言及其生态系统用于特定目标的信息。简单的Web API。</p><p> The caveat to that: in the general sense, you can build a website with anything and be successful. Remember how OkCupid was  implemented in C++. There’s a popular  astrology app, Co-star, that’s all Haskell. If you’re great at writing some language and you can hire other people with lots of talent, you can do it and be heroes.</p><p> 需要注意的是：从一般意义上讲，您可以使用任何内容构建网站并获得成功。请记住，如何在C ++中实现OkCupid。 Haskell就是一个受欢迎的占星术应用，联合明星。如果您擅长编写某种语言，并且可以聘请其他有很多才能的人，那么您可以做到并成为英雄。</p><p> Another caveat: what I was trying to build was a  CRUD-heavy web application API for a website. It wasn’t a web “service” as you might call them nowadays, something that did one operation very fast and millions of times, but a web “application” - something that did quite a few different operations and had a fair bit of domain logic in it. If you’re  not building that kind of thing, this advice might not apply! If what you need is to do one or two things at hyper-fast speed, like if you’re writing a payment gateway or voice messaging application, Rust’s tradeoffs might work a lot better.</p><p> 另一个警告：我试图构建的是网站的CRUD繁重的Web应用程序API。如今，它已不是一种您可以称呼它的网络“服务”，它一次完成了数百万次的快速操作，但是却成为了一个“应用程序”，它做了许多不同的操作，并且拥有相当多的域名逻辑。如果您不是要构建这种东西，则此建议可能不适用！如果您需要以超快的速度执行一两个操作，例如正在编写付款网关或语音消息传递应用程序，Rust的权衡可能会更好。</p><p> Here’s another caveat: I’m writing this in January 2021. Assuming that society continues to function, Rust will evolve and will probably get a lot better, and it may become really easy to use for web application development.</p><p> 这是另一个警告：我将在2021年1月写这篇文章。假设社会继续运转，Rust将会发展并可能会变得更好，并且它对于Web应用程序开发来说真的很容易使用。</p><p>  All said, I really enjoyed working with Rust. It’s a beautiful language with a lot of cool ideas, and I hope that soon I’ll be thinking about something I want to build and Rust will be the right tool. As it is now, though, a lot of the things I want to build are better served by languages that have different priorities.</p><p>  所有人都说，我非常喜欢与Rust一起工作。这是一门优美的语言，包含许多很棒的主意，我希望很快我会考虑要构建的东西，而Rust将是正确的工具。但是，就目前而言，具有不同优先级的语言可以更好地满足我想构建的许多东西。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://macwright.com/2021/01/15/rust.html">https://macwright.com/2021/01/15/rust.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/制作/">#制作</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hard/">#hard</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>