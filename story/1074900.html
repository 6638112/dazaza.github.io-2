<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Ky是一个基于浏览器获取API的小巧优雅的HTTP客户端</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Ky是一个基于浏览器获取API的小巧优雅的HTTP客户端</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-25 15:16:46</div><div class="page_narrow text-break page_content"><p>Ky的目标是现代浏览器和Deno。对于较旧的浏览器，您需要传输并使用fetch polyfill和globalThis polyfill。用于节点。js，看看我有什么。对于同构需求（如SSR），请查看ky universal。</p><p>从&#39进口ky；肯塔基州；const json=wait ky。帖子（&#39；https://example.com&#39; ,  {json:{foo:true}}）。json（）；安慰日志（json）//=&gt`{数据：&#39；🦄&#39;}`</p><p>类HTTPError扩展了错误{}const response=wait fetch（&#39；https://example.com&#39; ,  {method:&#39；POST&#39；，body:JSON.stringify（{foo:true}），headers:{&#39；content type&#39；：&#39；application/JSON&#39；}）；如果（！response.ok）{throw new HTTPError（`Fetch error:${response.statusText}`）；}const json=等待响应。json（）；安慰日志（json）//=&gt`{数据：&#39；🦄&#39;}`</p><p>如果您使用的是Deno，请从URL导入Ky。例如，使用CDN：</p><p>默认情况下，credentials选项是同源的，这也是规范中的默认选项，但并非所有浏览器都能跟上。</p><p>返回一个响应对象，为方便起见添加了Body方法。例如，您可以调用ky.get（输入）。直接使用json（），而不必先等待响应。当这样调用时，将根据所使用的body方法设置适当的Accept头。与窗口的主体方法不同。取来如果响应状态不在200。。。299.此外。如果响应状态为204，json（）将返回一个空字符串，而不是由于正文为空而引发解析错误。</p><p>当使用请求实例作为输入时，任何URL更改选项（如prefixUrl）都将被忽略。</p><p>在内部，标准方法（GET、POST、PUT、PATCH、HEAD和DELETE）是大写的，以避免因区分大小写而导致服务器错误。</p><p>发送JSON的快捷方式。使用此选项而不是body选项。接受任何简单的对象或值，即JSON。stringify（）&#39；d，并以正确的标题集发送到正文中。</p><p>类型：字符串|对象&lt；字符串，字符串|数字|布尔值&gt；|阵列&lt；阵列&lt；字符串|数字|布尔值&gt&gt；|URLSearchParams默认值：&#39&#39;</p><p>搜索要包含在请求URL中的参数。设置此选项将覆盖输入URL中的所有现有搜索参数。</p><p>发出请求时在输入URL前加前缀。它可以是任何有效的URL，无论是相对的还是绝对的。尾随斜杠/是可选的，如果需要，将在与输入连接时自动添加。仅当输入为字符串时生效。使用此选项时，输入参数不能以斜杠/开头。</p><p>从&#39进口ky；肯塔基州&#39；；//在…上https://example.comconst response=wait ky（&#39；unicorn&#39；，{prefixUrl:&#39；/api&#39；}）//=&gt&#39;https://example.com/api/unicorn&#39; const response2=wait ky（&#39；独角兽&#39；，{prefixUrl:&#39；https://cats.com&#39; } ) ; //=&gt&#39;https://cats.com/unicorn&#39;</p><p>prefixUrl和input连接后，根据页面的基本URL（如果有）解析结果。</p><p>如果使用此选项来增强一致性并避免对输入URL的处理方式产生混淆，则不允许在输入中使用前导斜杠，因为在使用prefixUrl时，输入不会遵循正常的URL解析规则，这会更改前导斜杠的含义。</p><p>表示最大重试次数、允许的方法、允许的状态代码和最大重试时间的限制、方法、状态代码和maxRetryAfter字段的对象。</p><p>如果retry是一个数字，它将被用作限制，其他默认值将保持不变。</p><p>如果maxRetryAfter设置为undefined，它将使用选项。暂停。如果Retry After标头大于maxRetryAfter，它将取消请求。</p><p>使用函数0.3*（2**（retry-1））*1000计算重试之间的延迟，其中retry是尝试次数（从1开始）。</p><p>从&#39进口ky；肯塔基州；const json=wait ky（&#39；https://example.com&#39; ,  {重试：{limit:10，methods:[&#39；get&#39；]，状态代码：[413]}）。json（）；</p><p>获取响应（包括重试）的超时（毫秒）。不能大于2147483647。如果设置为false，则不会超时。</p><p>钩子允许在请求生命周期中进行修改。钩子函数可以是异步的，并且可以串行运行。</p><p>这个钩子使您能够在发送请求之前修改请求。在这之后，Ky不会对请求做进一步的更改。钩子函数接收请求和选项作为参数。例如，您可以修改请求。这里是标题。</p><p>钩子可以返回一个请求来替换传出的请求，或者返回一个响应来完全避免发出HTTP请求。这可以用来模拟请求、检查内部缓存等。从这个钩子返回请求或响应时，一个重要的考虑因素是，将跳过所有剩余的beforeRequest钩子，因此您可能只希望从最后一个钩子返回它们。</p><p>从&#39进口ky；肯塔基州；常数api=ky。扩展（{hooks:{beforeRequest:[request=&gt；{request.headers.set（&#39；X-request-With&#39；，&#39；ky&#39；）；			 }		 ]	 } } ) ; const response=等待api。获得（&#39；https://example.com/api/users&#39; ) ;</p><p>这个钩子允许您在重试之前修改请求。在这之后，Ky不会对请求做进一步的更改。钩子函数接收一个带有规范化请求和选项的对象、一个错误实例和重试计数。例如，您可以修改请求。这里是标题。</p><p>如果请求收到响应，则错误类型为HTTPError，并且响应对象在出现错误时可用。回答请注意，某些类型的错误（如网络错误）本质上意味着未收到响应。在这种情况下，错误将不是HTTPError的实例。</p><p>您可以通过抛出错误来防止Ky重试请求。Ky不会以任何方式处理它，错误将传播到请求发起方。在这种情况下，不会调用beforeRetry钩子的其余部分。或者，您可以返回ky.stop符号来执行相同的操作，但不会传播错误（这有一些限制，请参阅ky.stop docs了解详细信息）。</p><p>从&#39进口ky；肯塔基州；const response=wait ky（&#39；https://example.com&#39; ,  {hooks:{beforetry:[async（{request，options，error，retryCount}）=&gt；{const token=wait ky（&#39；https://example.com/refresh-token&#39; ) ;要求标题。set（&#39；Authorization&#39；，`token${token}`）；			 }		 ]	 } } ) ;</p><p>这个钩子允许您在抛出HTTPError之前修改它。钩子函数接收HTTPError作为参数，并应返回HTTPError的实例。</p><p>从&#39进口ky；肯塔基州；等待ky（&#39；https://example.com&#39; ,  {hooks:{beforeError:[error=&gt；{const{response}=error；if（response&amp；response.body）{error.name=&#39；GitHubError&#39；error.message=`response.body.message}（${response.statusCode}）`return error；}）；</p><p>这个钩子使您能够读取并有选择地修改响应。钩子函数接收规范化的请求、选项和响应的克隆作为参数。Ky将使用钩子函数的返回值作为响应对象，如果它&#39；这是一个回应的例子。</p><p>从&#39进口ky；肯塔基州；const response=wait ky（&#39；https://example.com&#39; ,  {hooks:{afterResponse:[（_-request，_-options，response）=&gt；{//您可以对响应执行一些操作，例如logging.log（response）；//或者返回一个'response'实例来覆盖响应。返回新的响应（&#39；另一个响应&#39；，{status:200}） ;}、//或在403错误异步（请求、选项、响应）=&gt；{if（response.status==403）{//Get a fresh token const token=wait ky（&#39；https://example.com/token&#39; ) . 文本（）；//使用令牌请求重试。标题。set（&#39；Authorization&#39；，`token${token}`）；返回ky（请求）；				 }			 }		 ]	 } } ) ;</p><p>在执行重定向后，如果响应具有非2xx状态代码，则抛出HTTPError。要同时抛出重定向而不是跟随重定向，请将重定向选项设置为&#39；手册&#39；。</p><p>如果您正在检查资源可用性，并且希望得到错误响应，那么将此设置为false可能会很有用。</p><p>注意：如果为false，则错误响应被视为成功，请求将不会重试。</p><p>progress对象包含以下元素：percent、transferredBytes和totalBytes。如果是&#39；如果无法检索正文大小，则totalBytes将为0。</p><p>从&#39进口ky；肯塔基州；const response=wait ky（&#39；https://example.com&#39; ,  {onDownloadProgress:（progress，chunk）=&gt；{//示例输出：//`0%-0/1271字节`/`100%-1271字节`控制台.log（${progress.percent*100}%-${progress.transferredBytes}的${progress.totalBytes}字节`）；	 } } ) ;</p><p>从&#39进口ky；肯塔基州；从&#39进口伯恩@哈皮克斯/伯恩&#39；const json=wait ky（&#39；https://example.com&#39; ,  {parseJson:text=&gt；伯恩（text）}）。json（）；</p><p>可以使用删除标题。extend（）通过传递带有未定义值的标头。仅当头来自Headers实例时，以字符串形式传递undefined会移除头。</p><p>从&#39进口ky；肯塔基州；const url=&#39；https://sindresorhus.com&#39; ; const original=ky。创建（{headers:{rainbow:&#39；rainbow&#39；，unicorn:&#39；unicorn&#39；}）；常量扩展=原始。扩展（{headers:{rainbow:undefined}}）；const response=await extended（url）。json（）；安慰日志（&#39；彩虹&#39；回应）//=&gt；假控制台。日志（&#39；独角兽&#39；回应）//=&gt；符合事实的</p><p>从&#39进口ky；肯塔基州&#39；；//在…上https://my-site.com常数api=ky。创建（{prefixUrl:&#39；https://example.com/api&#39; } ) ; const response=等待api。获取（&#39；用户/123&#39；）//=&gt&#39;https://example.com/api/users/123&#39; const response=等待api。get（&#39；/status&#39；，{prefixUrl:&#39；&#39；}）//=&gt&#39;https://my-site.com/status&#39;</p><p>可由beforeRetry挂钩返回以停止重试的符号。这也会在重试前使剩余的挂钩短路。</p><p>注意：返回此符号将导致Ky中止，并返回未定义的响应。在访问响应上的任何属性或使用可选链接之前，请确保检查响应。它也与身体方法不兼容，例如。json（）或。text（），因为没有解析响应。通常，我们建议抛出一个错误，而不是返回这个符号，因为这将导致Ky中止，然后抛出，从而避免这些限制。</p><p>ky.stop的一个有效用例是防止在请求副作用时重试，因为返回的数据并不重要。例如，将客户端活动记录到服务器。</p><p>从&#39进口ky；肯塔基州；const options={hooks:{beforeRetry:[async（{request，options，error，retryCount}）=&gt；{const shouldStopRetry=wait ky（&#39；https://example.com/api&#39; ) ;if（shouldStopRetry）{return ky.stop；}}}]}；//请注意，如果返回'ky.stop'，响应将为'undefined'。const response=wait ky。帖子（&#39；https://example.com&#39; ,  选项）；//使用`。text（）`或其他正文方法不受支持。const text=wait ky（&#39；https://example.com&#39; ,  选项）。文本（）；</p><p>暴露在检查的瞬间。该错误具有响应对象的response属性、请求对象的request属性和规范化选项的options属性（在使用ky.create（）创建实例时传递给ky，或者在执行请求时直接传递给ky）。</p><p>请求超时时引发的错误。它具有请求对象的请求属性。</p><p>以Ky格式发送表单数据与获取相同。只需将FormData实例传递给body选项。内容类型标题将自动设置为多部分/表单数据。</p><p>从&#39进口ky；肯塔基州&#39；；//`多部分/表单数据`const formData=new formData（）；formData。附加（&#39；食物&#39；，&#39；薯条&#39；）；formData。追加（&#39；饮料&#39；，&#39；冰茶&#39；）；const response=wait ky。post（url，{body:formData}）；</p><p>如果要以application/x-www-form-urlencoded格式发送数据，则需要使用urlsearchparms对数据进行编码。</p><p>从&#39进口ky；肯塔基州&#39；；//`application/x-www-form-urlencoded`const searchParams=new URLSearchParams（）；搜索参数。套餐（&#39；食物&#39；&#39；薯条&#39；）；搜索参数。套餐（&#39；饮料&#39；&#39；冰茶&#39；）；const response=wait ky。post（url，{body:searchParams}）；</p><p>Fetch（因此也是Ky）通过AbortController API内置了对请求取消的支持。阅读更多。</p><p>从&#39进口ky；肯塔基州；const controller=new AbortController（）；const{signal}=控制器；设置超时（（）=&gt；{controller.abort（）；}，5000 ) ; 尝试{console.log（等待ky（url，{signal}）。text（）；}catch（error）{if（error.name==&#39；abortror&#39；）{console.log（&#39；Fetch aborted&#39；）；}else{console.error（&#39；Fetch error:&#39；error）；}</p><p>如何将其用于使用服务器端渲染（SSR）的web应用程序（React、Vue.js等）？</p><p>要么使用可以在浏览器中运行的测试运行程序，比如Mocha，要么使用AVA和ky universal。阅读更多。</p><p>确保代码作为JavaScript模块（ESM）运行，例如使用&lt；脚本类型=&#34；模块34&gt；在HTML文档中添加标签。然后，该模块可以直接导入Ky，而无需绑定器或其他工具。</p><p>它&#39；这只是我设法得到的一个随机简短的npm包名。然而，它在日语中有一个含义：</p><p>KY是一种可用于文本的俚语，是空気読めない （kuuki yomenai），字面意思是“看不见空气”它&#39；这是一个短语，用来形容没有领会其中隐含的意思的人。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/获取/">#获取</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tiny/">#tiny</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/请求/">#请求</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>