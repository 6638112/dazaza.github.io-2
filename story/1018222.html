<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>沮丧吗？不是你的问题，是铁锈的问题</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">沮丧吗？不是你的问题，是铁锈的问题</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-08-15 05:17:45</div><div class="story_img_container"><a href="http://img.diglog.com/img/2020/8/99194f67e5542018f2c1c325832cade0.png"><img src="http://img.diglog.com/img/2020/8/99194f67e5542018f2c1c325832cade0.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>学习生锈是..。一种体验。一次情感之旅。在我努力学习“锈”的最初几个月里，我几乎没有比这更沮丧的了。</p><p>更糟糕的是，不管你以前有多少Java、C#、C++或其他方面的经验，它仍然会让你感到不安。</p><p>事实上，更多的经验可能会让事情变得更糟！习惯已经变得更深了，而且有一种特定的期望，那就是，到现在，你应该能够在更短的时间内完成这件事。</p><p>也许，在成功发布代码多年之后，您不再像刚开始时那样有同样的好奇心、同样的坦率和意愿去感觉丢失了。</p><p>学习“铁锈”会让你觉得自己又像个初学者了--为什么这么难呢？这并不觉得应该有那么难。我以前也做过类似的事情。我知道我想要什么。现在我只需要..。让它发生吧。</p><p>我会继续在我所有的初学者级别的文章中包括这样的介绍，因为它们非常重要：如果你染上了锈，就会受到阻碍。告诉你，你很快就会跟上速度的，那就是大错特错，而我也不是大话王。</p><p>然而，有一个非常好的原因是学习如此之难。当你从另一种语言切换到Rust时，你并不是从法语切换到西班牙语-你不仅仅是在学习新的词汇，这样你就可以说出相同的东西，只是它们的拼写和发音不同。</p><p>你正在学习新的词汇，并学会谈论你以前从未讨论过的话题。你正在学习一种全新的沟通方式。演讲(口语或书面语)对我们很多人来说都是非常重要的，从头开始是非常令人不安的。</p><p>你会遇到一些你不能用你的任何先验知识来框定的问题。写铁锈需要遵守一套规则，而这些规则你是无法用其他语言的类比来描述的。这又增加了另一个级别的难度：通常情况下，你甚至不能描述出哪里出了问题，无法得到一些帮助。</p><p>通用搜索引擎在解决锈蚀问题方面相当没用。您最好的选择几乎就是Rust编译器本身，以及它的诊断功能。或者，咬紧牙关，接受这样一个事实：在你回到你想要做的事情之前，你将不得不回去阅读更多的初学者水平的材料，然后才能有一个瞬间。</p><p>然而，编译器只能做到这一点--因为它不仅面临着解释在其他语言中没有等价物的概念的困难，而且：它是从你的代码而不是你的大脑开始工作的。</p><p>当你把你脑海中的东西放入代码中时，细节就会丢失--虽然这些在其他语言中可能无关紧要，但在Rust中，它们非常重要。</p><p>如果您做了大量的动态类型/弱类型工作，这一点尤其正确。</p><p>您来自Python、Ruby或JavaScript等语言，因此习惯于编写如下所示的函数：</p><p>当你有一个这样的函数时，你知道只在可以加在一起的东西上调用它。例如，数字。你知道不应该用这样的话来称呼它。对象或字典，因为那样的结果可能是无意义的。</p><p>然而，铁锈并不是那么聪明。首先，它真的希望所有的东西都有一种类型：</p><p>但是，如果我们想要使我们的add函数对任何两个可以相加的东西起作用，我们必须使我们的函数成为泛型函数-这是它自己的兔子洞。</p><p>错误[E0369]：无法将`T`添加到`T`--&gt；src/main.rs：6：7|6|a+b|-^-T|T|Help：考虑限制类型参数`T`|5|fn add&lt；T：std：：ops：：add&lt；output=T&gt；&gt；(a：t，b：t)-&gt；T{|^。</p><p>那里的帮助部分就是关于钱的--问题的核心是铁锈赢了--除非它确实知道可以加两样东西，否则我们就不加这两样东西了。</p><p>使用std：：ops：：add；fn main(){println！(&#34；ten={}&#34；，add(4，6))；}fn add&lt；T&gt；(a：t，b：t)-&gt；T其中T：add&lt；output=T&gt；，{a+b}。</p><p>所以-你比拉斯特聪明。铁锈只知道你说了什么。你最好也清楚你的意思！</p><p>但这也有一个好处：花时间仔细地向拉斯特描述你的意思，可以避免很多错误。它可以防止整个班级的错误。</p><p>在这个简单示例中，很明显：由于Rust在默认情况下没有对字符串进行所有类型的隐式强制，因此您永远不会得到意外的[Object Object][Object Object]。</p><p>而且，最重要的是，如果要将添加函数作为机箱的一部分发布(NPM包、gem、.。蛋?。Y&#39；所有人，Python还好吗？)，其他人也不可能以意外的[对象对象][对象对象]而告终。</p><p>因为这些类型不仅仅是建议性的--它们还是您的库接口的一部分，即使它被用作另一个项目的一部分。</p><p>如果您已经习惯了更动态/弱类型的语言，那么很长一段时间以来，您一直在维护不变量--可能从未使用过不变量这个词。</p><p>您也可以将其称为假设&在调用add的整个持续时间内，我们假设a和b可以相加。从它永远不会改变的意义上说，它是一个不变的东西。如果在某一时刻，a或b变成不能相加的值，那么我们的代码将是错误的。</p><p>对于错误也有一个更专业的术语-维护不变量就是维护健全性。破坏不变量的代码称为不健全代码。</p><p>在Rust中，我们没有牢记不变量，而是直接将它们保存在代码中。这允许编译器在编译时强制执行它们。</p><p>您还可以将不变量视为永久断言。例如，C代码往往包含很多运行时断言-如果我们到达代码的这一部分，那么&#34；ptr&#34；不能为空。</p><p>不过，奖品是试图从一开始就阻止无效程序编译-尽早发现问题。对于难以描述的问题或涉及不受控制的用户输入的情况，仅求助于运行时错误。</p><p>您可能会对前面的例子提出异议。你可能会发现你自己想要争辩这样的函数：</p><p>//(再次未编译)fn add&lt；T&gt；(a：t，b：t)-&gt；T{a+b}。</p><p>...拥有Rust约束类型T本身所需的所有信息，因此只能使用可以一起相加的值来调用Add。</p><p>Fn Get_Some_Numbers()-&gt；vec&lt；usize&gt；{vec！[1，2，3]}fn main(){//此`let`绑定现在具有显式类型：let v：vec&lt；usize&gt；=Get_Some_Numbers()；}。</p><p>#include&lt；stdint.h&gt；#include&lt；stdio.h&gt；char*Humanize_number(Size_T N){开关(N){案例0：return&#34；零&#34；；案例1：return&#34；one&#34；；案例2：return&#34；Two&#34；；}}int main(){printf(&#34；0=%s\n&#34；，Humanize_number(0))；printf(&#34；1=%s\n&#34；，Humanize_number(1))；printf(&#34；2=%s\n&#34；，Humanize_number(2))；printf(&#34；3=%s\n&#34；，Humanize_number(3))；返回0；}。</p><p>$GCC Main.c-o Main&amp；./Main0=零1=One2=两个[1]148103分段故障(核心转储)。/Main。</p><p>C编译器知道这段代码有问题。如果我们向-WALL询问它的意见，它会告诉我们：</p><p>$GCC-Wall main.c-o main.c：in函数‘Humanize_number’：main.c：13：1：警告：控件到达非空函数[-Wreturn-type]13|}|^。</p><p>Fn main(){println！(&#34；0={}&#34；，Humanize_number(0))；println！(&#34；1={}&#34；，Humanize_number(1))；println！(&#34；2={}&#34；，Humanize_number(2))；println！(&#34；3={}&#34；，Humanize_number(3))；}fn Humanize_number(n：usize)-&gt；&amp；&#39；静态字符串{Match n{0=&gt；&#34；，0&#34；，1=&gt；&#34；，2=&gt；&#34；，}}</p><p>错误[E0004]：非穷举模式：`_`未覆盖--&gt；src/main.rs：9：11|9|匹配n{|^模式`_`未覆盖|=help：确保处理所有可能的情况，可能是通过添加通配符或更多匹配臂=注意：匹配值的类型为`usize`。</p><p>即使没有人使用0、1或2以外的值调用Humanize_number，这对Rust来说也无关紧要。它不会让您按原样编译代码。</p><p>由于usize类型的值范围从0到40亿(在32位上)，或0到18百万分之一(即180亿)，它希望您确保每个案例都得到处理。</p><p>Fn Humanize_Number(n：usize)-&gt；&amp；&#39；静态字符串{Match n{0=&gt；&#34；，0&#34；，1=&gt；&#34；，2=&gt；&#34；，_=&gt；死机！(&#34；n太大&#34；)，}}。</p><p>Fn Humanize_Number(n：usize)-&gt；&amp；&#39；静态字符串{Match n{0=&gt；&#34；，1=&gt；&#34；，1=&gt；&#34；，2=&gt；&#34；，_=&gt；&#34；大数字&34；，}}。</p><p>Struct NumberTooBig；FN Humanize_Number(n：usize)-&gt；result&lt；&amp；&39；static str，NumberTooBig&gt；{Match n{0=&gt；OK(&#34；零&#34；)，1=&gt；OK(&#34；one&#34；)，2=&gt；OK(&#34；Two&#34；)，_=&gt；Err(。</p><p>Fn main(){println！(&#34；0={}&#34；，Humanize_number(0).unwork_or(&#34；a Big number&#34；))；println！(&#34；1={}&#34；，Humanize_number(1).unwork_or(&#34；a Big number&#34；))；println！(&#34；2={}&#34；)。，Humanize_number(2).unwork_or(&#34；a Big number&#34；))；println！(&#34；3={}&#34；，Humanize_number(3).unwork_or(&#34；a Big number&#34；))；}。</p><p>为什么Rust不想让我们编写在某些情况下可以工作的代码，而不是其他情况下可以工作的代码？因为在这种情况下，立即出现分段故障是我们所能期待的最好结果。</p><p>如果我们实际将Humanize_number的结果存储在某个地方，并在以后使用它，那么问题会变得更加严重。或者，如果我们最终将其传递给需要有效字符串的函数。所有的不变量都会被打破，谁知道会发生什么呢？</p><p>嗯。或者泄露客户的私人数据。或者让手术机器人大发雷霆。可能会发生很多不好的事情。</p><p>但这并没有回答我们最初的问题：为什么拉斯特可以在这里推断出v的类型：</p><p>Fn main(){//推导为`vec&lt；u8&gt；`let v=vec！[0u8，3u8，5u8]；}。</p><p>对于初学者来说，指定类型和这些类型的界限不仅仅对函数的调用者有用。</p><p>使用std：：ops：：add；fn main(){let a=vec！[0，1]；let b=vec！[2，3]；//！对不能相加的值调用`add`，让c=add(a，b)；}fn add&lt；T&gt；(a：t，b：t)-&gt；T其中T：add&lt；output=T&gt；，{a+b}。</p><p>错误[E0277]：无法将`std：：VEC：：VEC&lt；{INTEGER}&gt；`添加到`STD：：VEC：：VEC&lt；{INTEGER}&gt；`--&gt；src/main.rs：6：13|6|let c=add(a，b)；|^^`std：：vec：：vec&lt；{INTEGER}&gt；+std：(a：T，b：t)-&gt；T|-此10|where 11|T：add&lt；output=T&gt；，|-`add`|=help：`std：：ops：：Add`未为`std：：VEC：：VEC&lt；{INTEGER}&gT；`实现特性`std：：ops：：Add`。</p><p>使用std：：ops：：add；fn main(){让14th=add(7，7)；dbg！(十四)；}fn add&lt；T&gt；(a：t，b：t)-&gt；T其中T：add&lt；output=T&gt；，{//从a中减去b，但我们只要求可以添加的类型//！A-b}</p><p>货物检查--安静[E0369]：无法从`T`减去`T`--&gt；src/main.rs：12：7|12|a-b|-^-T|T|Help：考虑进一步限制此界限|10|T：add&lt；output=T&&gt;；+std：：ops：：sub&lt；output=T&&gt;；，|^。</p><p>在这一点上，我们正危险地接近于与学术论文调情，所以让我们立即举个例子。</p><p>锈病有一个Into特征，它描述了一种类型转化为另一种类型的能力。它与强制转换(as运算符)不同；您实际上必须调用into()方法：</p><p>Fn main(){设a：u8=255；设b：u16=a。Into()；设c：u32=a。变成()；设d：u64=a。INTO()；DBG！(a、b、c、d)；}。</p><p>$Cargo运行--安静[src/main.rs：8]a=255[src/main.rs：8]b=255[src/main.rs：8]c=255[src/main.rs：8]d=255。</p><p>在此代码示例中，a是一个无符号8位整数，我们使用相同的方法将其转换为无符号16位整数、无符号32位整数和无符号64位整数，所有这些都使用相同的方法：Into：：Into。</p><p>这意味着into：：into可以返回不同的类型，不仅取决于接收方是什么类型(在所有三个调用中都是U8)，而且还取决于预期的类型。</p><p>Fn main(){设a：u8=255；设b=a。Into()；println！(&#34；b={}&#34；，b)；}</p><p>$Cargo Run--quieteric[E0282]：需要类型批注--&gt；src/main.rs：4：9|4|let b=a.into()；|^考虑给`b`一个类型。</p><p>显然，我们需要一个类型，让我们称其为B，对于该类型，A存在Iml Into B&&gt;，B也存在Imp Display，因为我们在println！中使用它。打电话。</p><p>但是有很多这样的类型-u16、u32、u64、u128、i16、i32、i64和i128都可以很好地工作。</p><p>请注意，i8不起作用，因为它不能表示所有可能的u8值。在这种情况下，我们必须使用TryIntotrait，它代表尝试转换容易出错的操作的能力。</p><p>由于我们讨论的主题是整数类型，因此该规则有一个值得注意的例外。在此代码中：</p><p>我们得到了一辆Vec&lt；I32&gt；。整数文字不是特定类型，它们是{整数}。如果需要特定类型，则它们可以变为U64、I8或其他任何类型-但如果不是，则默认为I32。这是我能想到的唯一例外。</p><p>Rust编译器有很多关于类型、它们可能的值以及它们能够做的事情的知识(在很大程度上是：它们实现的特性)。</p><p>它一直使用这些知识来推断变量绑定、文字和类型参数的类型(fn add&lt；T&gt；中的T)。</p><p>但是，Rust编译器所能做的演绎是有限制的。当它开始看起来太像猜测时，它会要求更明确的指令型注释。</p><p>//(不编译)struct Wolf{}Impl Wolf{FN greet(&amp；self){println！(&#34；awoooo&34；)；}}struct蜥蜴{}Impll Lizard{FN greet(&amp；self){println！(&#34；*chirp chirp*&34；)；}}FN Acquisition_Pet&lt；T&gt；(comfy：bofy。T{if comfy{wolf{}}Else{蜥蜴{}fn main(){让PET=Acquisition_Pet(True)；Pet。Greet()；}。</p><p>错误[E0282]：需要类型批注--&gt；src/main.rs：27：5|26|let PET=Acquisition_Pet(True)；|-考虑给`pet`一个类型27|pet.greet()；|^无法推断类型|=备注：此时必须知道类型。</p><p>错误[E0308]：类型不匹配--&gt；src/main.rs：19：9|17|fn Acquisition_Pet&lt；T&gt；(comfy：bool)-&gt；T{|--由于返回类型而应为`T`|此类型参数18|if comfy{19|wolf{}|^预期类型参数`T`，找到结构`Wolf`|=Note：应为类型参数`T。(comfy：bool)-&gt；T{|--返回类型需要`T`|此类型参数...21|蜥蜴{}|^需要类型参数`T`，找到结构`Lizard`|=备注：需要的类型参数`T`找到结构`Lizard`。</p><p>现在的问题是什么？Acquisition_pet是泛型的-显然，它可以返回不同的类型。我们用true来调用它，所以很明显，它应该返回一个Wolf，而且我们也希望返回一个Wolf(这是我们在main函数中给我们的petbinding指定的类型)。</p><p>Fn Ask_Comfy_Preference()-&gt；bool{println！(&#34；你喜欢舒适的宠物吗？(是或否)&#34；)；让mut Answer=string：：new()；std：：IO：：stdin()。读取行(&A；MUT应答)。展开()；匹配答案。Trim(){&#34；yes&#34；=&gt；true，&#34；no&#34；=&gt；false，_=&gt；{Panic！(&#34；抱歉，我听不懂您的回答：{：？}&#34；，Answer)；}fn main(){let comfy=Ask_comfy_Preference()；let PET=Acquisition_PET(Comfy)；PET。Greet()；}。</p><p>现在宠物的类型取决于用户输入。在具有动态类型的语言中，这根本不是问题。但在这里，没有鸭子可以嘎嘎叫，也不能像鸭子一样走路。</p><p>狼和蜥蜴都有打招呼的方法，这并不重要，它们在结构上的相似性一点也不相关。</p><p>唯一重要的是代码的各个部分都同意维护的合同。</p><p>在Rust标准库中有一种类型，可以让我们返回任何东西。嗯，这是一个特性：任何。</p><p>//错误代码ahoy fn Acquisition_PET(comfy：bool)-&gt；dyn std：：any：：any{if comfy{wolf{}}Else{蜥蜴{}。</p><p>这不起作用-我们不能只使用特征作为返回类型，就像这样：</p><p>尝试编译该代码会给您很多建议。编译器想要同时给你上一堂很多东西的速成课程--所以为了不再吓跑你，我就不给你看了。</p><p>Fn Acquisition_PET(comfy：bool)-&gt；Iml std：：any：：any{if comfy{wolf{}}Else{蜥蜴{}。</p><p>这一次，我们承诺返回实现任何。我们只是不想给它命名。这在很多情况下都很方便。</p><p>货物检查--quietart[E0308]：`if`和`ali`具有不兼容的类型--&gt；src/main。RS：21：9|18|/if comfy{19||wolf{}||-由于此原因，预期为20||}否则{21||蜥蜴{}||^需要结构`Wolf`，发现结构`Lizard`22||}||_-`if`和`sel`的类型不兼容</p><p>因为即使我们没有指定具体的返回类型(只是它应该实现Any特征)，编译器应该仍然能够找出它，给定函数的签名(它的参数类型)和它内部的代码。</p><p>现在，它还不能计算出具体的类型应该是struct Wolf还是struct Lizard。</p><p>我很好奇为什么编译器不建议使用以下修复程序，我们将重新使用这些修复程序：</p><p>Fn Acquisition_PET(comfy：bool)-&gt；Box&lt；dyn std：：any：：any&gt；{if comfy{Box：：New(Wolf{})}Else{Box：：New(Lizard{})}}。</p><p>看，退回狼或蜥蜴的问题在于，这两种动物的大小可能完全不同。</p><p>正确的。重点是，我们需要知道实际的类型是什么-它有多大，它有哪些字段，等等。</p><p>但是，如果我们返回Box&lt；dyn any&gt；，我们只是返回其类型实现Any的avalue的地址。Box&lt；T&gt；只是一个指针，我们知道它的大小(32位为4字节，64位为8字节)。</p><p>错误[E0599]：在当前作用域--&gt；src/main.rs：40：9|40|pet.greet()；|^`中找不到`std：：boxed：：box&lt；dyn std：：any：：any&gt；`中的struct`std：：boxed：：box&lt；dyn std：：any：：any&gt；`</p><p>不过，这一次，答案很清楚--我们将返回实现任何的东西的地址。</p><p>Fn main(){let comfy=ASK_COMFY_PERFER()；let PET=Acquisition_PET(Comfy)；println！(&#34；我们有一个{：？}&#34；，pet.type_id())；}。</p><p>$Cargo Run--安静你喜欢舒适的宠物吗？(是或否)是的，我们有TYPEID{t：13993700938491603631}$货运--安静，你喜欢舒适的宠物吗？(是或否)NOWE获得类型ID{t：8639049246320250335}。</p><p>我们可以做的另一件事是尝试将结果值向下转换为特定的具体类型，如Wolf或Lizard：</p><p>Fn main(){让comfy=ASK_COMFY_PERFER()；让PET=。</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fasterthanli.me/articles/frustrated-its-not-you-its-rust">https://fasterthanli.me/articles/frustrated-its-not-you-its-rust</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1018137.html"><img src="http://img.diglog.com/img/2020/8/thumb_a70a67e36816e4d5127db6e9aa791ae4.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1018137.html">苹果和谷歌刚刚被广受欢迎的视频游戏“堡垒之夜”的开发商起诉，原因是它们的应用商店政策。以下是你需要知道的关于它重新点燃的重大反垄断斗争的信息。</a></div><span class="my_story_list_date">2020-8-15 1:11</span></div><div class="col-sm"><div><a target="_blank" href="/story/1018084.html"><img src="http://img.diglog.com/img/2020/8/thumb_d212942a9fcf58ece6f66f6eb9267108.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1018084.html">EPIC Games对苹果提起反垄断诉讼，辩称App Store是垄断企业，不寻求损害赔偿，只是寻求“允许公平竞争”的禁令救济</a></div><span class="my_story_list_date">2020-8-15 0:5</span></div><div class="col-sm"><div><a target="_blank" href="/story/1017802.html"><img src="http://img.diglog.com/img/2020/8/thumb_c643d180e38c0ecdd8f2041918dc48dc.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1017802.html">吉姆·胡德(Jim Hood)的个人资料，他在担任密西西比州股份公司(密西西比州股份公司)的16年间曾与谷歌发生争执，消息人士称，他现在为AG领导的多州反垄断调查提供建议</a></div><span class="my_story_list_date">2020-8-13 5:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1017650.html"><img src="http://img.diglog.com/img/2020/8/thumb_48db8eb787e01587afbae8abe49292fa.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1017650.html">Bevy：Rust构建的数据驱动游戏引擎和APP框架</a></div><span class="my_story_list_date">2020-8-12 6:17</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>