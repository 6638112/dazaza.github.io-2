<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>最终用户编程（2019） End-User Programming (2019)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">End-User Programming (2019)<br/>最终用户编程（2019） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-15 18:45:50</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/77377a21be06e05f99660314dda3f109.png"><img src="http://img2.diglog.com/img/2020/12/77377a21be06e05f99660314dda3f109.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Compare to Unix, for example. A user of a Unix system learns to type commands, edit text files, and copy/move/delete files and directories as part of their regular use. And when they are ready to write a program, they can continue using the same concepts and interface, because a Unix shell script is just a series of commands saved into a text file. That text file can be copied, moved around, edited, and deleted just like any other file.</p><p>例如，与Unix比较。 Unix系统的用户在日常使用中学习键入命令，编辑文本文件以及复制/移动/删除文件和目录。而且，当他们准备编写程序时，可以继续使用相同的概念和界面，因为Unix shell脚本只是保存在文本文件中的一系列命令。该文本文件可以像其他文件一样被复制，移动，编辑和删除。</p><p>   Zapier and  IFTTT offer tantalizing glimpses of end-user accessible automation for the web and cloud APIs. But by the full measure of the in-place toolchain idea, these fail because, for example, the act of automating your smarthome components with IFTTT requires a completely different interface and set of concepts from using those components day-to-day.</p><p>   Zapier和IFTTT为Web和云API提供了诱人的最终用户可访问的自动化功能。但是从就地工具链的想法的全面衡量来看，这些方法失败了，因为例如，使用IFTTT自动化智能家居组件的行为需要与每天使用这些组件完全不同的界面和概念集。</p><p>  A similar problem of “tool in its own standalone universe” exists in academic examples of end-user programming.  Eve,  Sketch-n-Sketch, and Pharo are technical design marvels. But they require the user to enter an entire new world of tooling and concepts, leaving behind everything they already know about using computers. They have to be motivated to want to program to begin with, rather than having it there waiting for them in an environment they are already using, such as their word processor, their web browser, or their photo editor.</p><p>  最终用户编程的学术示例中也存在一个类似的“独立工具中的工具”问题。 Eve，Sketch-n-Sketch和Pharo是技术设计奇迹。但是它们要求用户进入工具和概念的全新世界，而抛弃了他们已经知道的有关使用计算机的所有知识。必须激励他们开始编程，而不是让它们在那里已经在使用的环境中等待他们，例如文字处理器，Web浏览器或照片编辑器。</p><p>     With the context of those three qualities and what has come before, our research lab set out to do some end-user programming experiments. Our testbed was a tablet thinking tool called  Capstone.</p><p>     结合这三种品质以及以前的品质，我们的研究实验室着手进行一些最终用户编程实验。我们的测试平台是一个称为Capstone的平板电脑思维工具。</p><p>  If we assume that a creative professional is using Capstone on a regular basis for their notes, clippings, and research, what programming or automation capabilities can we offer that would give them more power, flexibility, and customization within that context?</p><p>  如果我们假设有创造力的专业人员定期使用Capstone进行笔记，剪辑和研究，那么我们可以提供哪些编程或自动化功能来在这种情况下为其提供更多功能，灵活性和定制性？</p><p> We ran five experiments to try applying embodiment, living systems, and in-place toolchains to Capstone.</p><p> 我们进行了五个实验，以尝试将实施，生活系统和就地工具链应用于Capstone。</p><p>  The Capstone user interface consists of cards on a canvas. As a simple starting place, we built an editor inside the Capstone system that allows the user to edit the underlying code of a given card. Think of this as similar to the web browser’s “View Source” option, but with write capability.</p><p>  Capstone用户界面由画布上的卡片组成。作为一个简单的起点，我们在Capstone系统内部构建了一个编辑器，允许用户编辑给定卡的基础代码。可以将其视为类似于网络浏览器的“查看源代码”选项，但具有写入功能。 </p><p>  On the surface, this seems to fulfill the in-place toolchain goal: the user needs nothing additional to start editing the code of their chosen card. It’s a live coding environment where every keystroke re-renders the card so that users see the results of their work right away.</p><p>从表面上看，这似乎可以实现就地工具链的目标：用户不需要其他任何东西就可以开始编辑所选卡的代码。这是一个实时编码环境，每次击键都会重新渲染卡，以便用户立即查看其工作结果。</p><p> However, we found the actual use of this approach uninspiring. It felt obvious, not a bold new direction that hasn’t been tried before. From the user’s standpoint, it felt editable but not inviting to the user. The jump from cards-on-a-canvas in a touch/stylus interface to a cryptic code editor with Javascript and React code was incongruous.</p><p> 但是，我们发现这种方法的实际使用没有启发性。感觉很明显，不是以前从未尝试过的大胆新方向。从用户的角度来看，它是可编辑的，但并不能吸引用户。从触摸/手写笔界面中的画布上的卡片到使用Javascript和React代码的隐秘代码编辑器的跳转是不协调的。</p><p>  For our next experiment, we wanted to embrace the cards+canvas model and touch interface of Capstone, while also borrowing some ideas from Unix pipes.</p><p>  对于我们的下一个实验，我们希望包含Cardstone + Canvas模型和Capstone的触摸界面，同时还借鉴了Unix管道的一些想法。</p><p> What would this look like for a more visual environment like that of Capstone’s cards-on-canvas? Our approach was to allow each card within Capstone to take input and provide output, allowing the user to chain them together with the visual equivalent of a pipe operator.</p><p> 对于像Capstone的画布卡这样的视觉环境来说，这会是什么样？我们的方法是允许Capstone中的每张卡接受输入并提供输出，从而允许用户将它们与管道操作员的视觉等效物链接在一起。</p><p>  We added fields to each card: uses and exposes. Like the names suggest, cards could now wait for some input, and expose some output. Those inputs and outputs were  strongly typed to allow for exchange of richer datatypes like arrays and objects.</p><p>  我们向每张卡添加了字段：使用和公开。顾名思义，卡现在可以等待一些输入，并公开一些输出。这些输入和输出经过强类型化，以允许交换更丰富的数据类型，例如数组和对象。</p><p> In the examples below, we’ve borrowed a use case from  this Emacs literate programming example. Here, a teacher begins with a table (spreadsheet or CSV) of student grades and wishes to create an ad-hoc dashboard showing pass/fail for each student.</p><p> 在下面的示例中，我们从这个Emacs识字编程示例中借用了一个用例。在这里，老师从学生成绩表开始（电子表格或CSV），并希望创建一个临时仪表板，显示每个学生的合格/不合格。</p><p>  By dragging the “exposes” label from one card onto another card’s “uses” label, the user creates connections between cards. Connected cards are color-coded, inspired by spreadsheet cell-and-range color coding. Based on user feedback, we found that users wanted to keep cards in a pipeline physically near each other.</p><p>  通过将“公开”标签从一张卡拖动到另一张卡的“使用”标签上，用户可以在卡之间建立连接。受电子表格单元格和范围颜色编码的启发，已连接的卡采用了颜色编码。根据用户的反馈，我们发现用户希望将卡保持在物理上彼此靠近的管道中。 </p><p>  By combining multiple simple cards users could build data-processing pipelines. Further enhancements included multiple inputs/outputs and renaming inputs or outputs.</p><p>通过组合多个简单的卡，用户可以建立数据处理管道。进一步的增强包括多个输入/输出以及重命名输入或输出。</p><p>  Many attempts at more accessible programming languages are weakly typed, under the hypothesis that types are unforgiving to newcomers. Our team’s instinct is the opposite: strong typing, with the right interface, can be friendlier for newcomers by making program components “snap” together like building blocks. If the blocks fit, the program will probably work. See the previously mentioned Scratch;  Elm’s strong typing for eliminating runtime errors; and  Hazel’s “typed holes” live programming environment.</p><p>  在类型对新手不宽容的假设下，许多尝试使用更易访问的编程语言的尝试都是弱类型的。我们团队的直觉是相反的：通过使程序组件像构建块一样“对齐”，强健的打字和正确的界面可以使新手更加友好。如果块适合，该程序可能会运行。参见前面提到的Scratch； Elm强大的输入功能可消除运行时错误；和Hazel的“打字孔”实时编程环境。</p><p>   Unix pipelines continue to be the reigning champion for composability — something not yet replicated in GUI environments. We feel that this CSV pipeline experiment produced positive findings supporting the value of strong typing (here as uses/exposes), and showed a potential interface for in-place toolchains that don’t break out of the touchscreen interface.</p><p>   Unix管道仍然是可组合性的主导者-在GUI环境中尚未复制。我们认为，该CSV管道实验产生了积极的发现，支持了强类型（在这里是使用/公开）的价值，并显示了不脱离触摸屏界面的就地工具链的潜在界面。</p><p> On the other hand, visual embodiment of the data pipeline created some problems. It adds visual clutter (a problem with many/most visual programming systems). Furthermore we found a tradeoff between grouping cards together in a way that makes the program flow clear (e.g. pipeline goes top-to-bottom or left-to-right) versus grouping cards in a way that reflects how the user wants to think about their content more generally.</p><p> 另一方面，数据管道的可视化实施方式带来了一些问题。它增加了视觉混乱（许多/大多数视觉编程系统都存在问题）。此外，我们发现在将卡片分组在一起（这可以使程序流程清晰（例如，管道从上到下或从左到右））与在反映用户想要如何思考他们的卡片的方式之间进行权衡内容更一般。</p><p>  For our third experiment, we decided to relax the constraint of an in-place toolchain in exchange for better results on other dimensions. In particular, we wanted to see if the  REPL (read-evaluate-print loop) used in many programming systems would be of value.</p><p>  对于我们的第三个实验，我们决定放宽就地工具链的约束，以换取其他维度上的更好结果。特别是，我们希望了解在许多编程系统中使用的REPL（读取评估打印循环）是否有价值。</p><p>  REPLs are traditionally built on wire protocols. That is, the user’s console sends commands to the runtime system over the network. But Capstone uses a synchronizing data model which keeps all of the visible elements stored in a live document. This allowed us to build the REPL by writing directly into the document from a session on another device.</p><p>  传统上，REPL是建立在有线协议上的。也就是说，用户控制台通过网络将命令发送到运行时系统。但是Capstone使用同步数据模型，该模型将所有可见元素存储在实时文档中。这使我们能够通过从另一设备上的会话直接写入文档来构建REPL。</p><p>   Being able to interact with a live system felt magical. Much like browser Dev Tools, the user can change appearance of anything via CSS. They can also interact with the cards data model to move cards around on the screen, move cards between boards, or absolutely anything else within the system. But unlike Dev Tools, all of these changes persist. The user has modified their workspace, customized it to their taste, via a fully programmable interface.</p><p>   能够与实时系统交互非常神奇。就像浏览器开发工具一样，用户可以通过CSS更改外观。他们还可以与卡数据模型进行交互，以在屏幕上四处移动卡，在板之间移动卡，或在系统中进行其他任何操作。但是，与开发工具不同，所有这些更改仍然存在。用户通过完全可编程的界面修改了工作空间，并根据自己的喜好对其进行了自定义。 </p><p> Our team was energized by this result and we instantly wanted this capability for all of our existing systems such as the desktop computers we use in our regular work lives. But we also quickly ran into what would likely be the biggest chunk of work in making a system like this real: API design.</p><p>我们的团队为这一结果感到鼓舞，我们立即希望为我们所有现有系统（例如我们在日常工作中使用的台式计算机）提供此功能。但是，我们也很快遇到了使这样的系统成为现实的最大工作量：API设计。</p><p> Typically software systems are built with an internal API used only by the professional engineers building that system. These functions are often minimally documented and have obscure names that may reflect history or even internal in-jokes, whereas a public-facing API is designed separately, well-documented, versioned, and kept more stable.</p><p> 通常，软件系统是使用内部API构建的，内部API仅由构建该系统的专业工程师使用。这些函数通常很少进行文档记录，其名称晦涩难懂，可能反映出历史甚至是内部笑话，而面向公众的API则经过单独设计，有据可查，经过版本控制并保持更稳定。</p><p> Our finding here is that for a living system to work, the internal and external APIs need to be mostly the same.</p><p> 我们在这里的发现是，要使运行中的系统正常工作，内部和外部API必须基本相同。</p><p> We also noted that living systems produce a tension between hackabilty and the danger of user breakage. For example, the user can change a card’s background color just as easily as executing a command that would discard every card onscreen or even put the system into a crashed state or infinite loop. What to allow, how to surface errors, and how to recover are deep and challenging questions we did not explore in the course of this experiment.</p><p> 我们还注意到，生命系统在可破解性与用户破坏危险之间产生了张力。例如，用户可以像执行命令那样轻松更改卡的背景颜色，该命令会丢弃屏幕上的每张卡，甚至使系统进入崩溃状态或无限循环。允许的内容，如何显示错误以及如何恢复是我们在本实验过程中未探讨的深层且具有挑战性的问题。</p><p>  Our next move was to extend the REPL with hooks for system events, such as the user dragging a card around the canvas.</p><p>  我们的下一步是使用系统事件的钩子扩展REPL，例如用户在画布上拖动卡片。</p><p> With a hook for card dragging, we could then build a “window manager” within the Capstone environment:</p><p> 有了卡拖动的钩子，我们就可以在Capstone环境中构建一个“窗口管理器”：</p><p>  Hooks bring a significant downside: the computation is no longer visible. The user’s code could do things hidden behind the curtain, which is the opposite of embodiment.</p><p>  挂钩带来了很大的缺点：计算不再可见。用户的代码可以做隐藏在幕后的事情，这与实施例相反。 </p><p> A parallel here is  triggers and stored procedures in databases like  PostgreSQL. They also have the  downside of no embodiment. Hence, while SQL is an end-user programming success story, triggers are typically reserved for professional database engineers rather than SQL console dabblers.</p><p>与之类似的是诸如PostgreSQL之类的数据库中的触发器和存储过程。他们也有没有体现的缺点。因此，尽管SQL是最终用户编程的成功案例，但触发器通常是为专业数据库工程师而不是SQL控制台涉猎者保留的。</p><p>  For our final experiment we wanted to explore how the user could create long-running programs (or  daemons) inside of Capstone that solved the embodiment problem of hooks.</p><p>  对于我们的最终实验，我们想探索用户如何在Capstone内部创建长期运行的程序（或守护程序），以解决钩子的体现问题。</p><p> Typically when we say embodiment we mean a visual element onscreen. But we took inspiration from the world of  chat bots: what if computation was embodied as something with a bit of personality, a sense of being an actor or a collaborator in the system along with human collaborators?</p><p> 通常，当我们说实施例时，是指屏幕上的视觉元素。但是我们从聊天机器人的世界中汲取了灵感：如果将计算体现为具有某种个性，与系统中的角色或协作者以及人类协作者一样的东西，该怎么办？</p><p>  Like the REPL experiment, Capstone bots still suffer from no in-place toolchain. The end-user programmer must write the script in Javascript and then issue a command to add the card (or update an existing one) in their Capstone workspace. Technical details are available in  the pull request.</p><p>  像REPL实验一样，Capstone机器人仍然没有适当的工具链。最终用户程序员必须使用Javascript编写脚本，然后发出命令以在其Capstone工作区中添加卡（或更新现有卡）。在拉取请求中可以找到技术细节。</p><p> A subtle but important piece of the bot interface design is that a bot subscribes to all changes in the document (similar to  reactive programming). This is instead of subscribing to specific event types (similar to  event-emitter) such as as moving or deleting a card. Another variation on this experiment was to allow bots to expose a small UI. Since the bot’s card already has screen real estate, why not allow programming direct interactivity?</p><p> 僵尸程序界面设计的一个微妙但重要的部分是，僵尸程序订阅了文档中的所有更改（类似于反应式编程）。这不是预订特定的事件类型（类似于事件发射器），例如移动或删除卡。此实验的另一个变体是允许漫游器公开一个小的UI。由于漫游器卡已经具有屏幕空间，为什么不允许编程直接交互功能？</p><p>  Although creating bot code does not satisfy the in-place toolchain goal, embodying them as cards has its own set of in-place toolchain benefits. In the same way a Unix user can manipulate a script file like any other file, a Capstone user can manipulate a bot like any other file.</p><p>  尽管创建机器人代码不能满足就地工具链的目标，但是将其体现为卡片具有自己的就地工具链优势。 Unix用户可以像其他文件一样操作脚本文件，Capstone用户可以像其他文件一样操作机器人程序。</p><p>  We noticed user behavior like creating a board full of their favorite bots and mirroring those cards onto the shelf to take them to the board where they wanted it. Deleting a bot is done by  throwing the card off the screen like any other card. All operations that worked on (for example) an image card worked on a bot card as well. Computation follows the same rules as data (it can be cloned, shared, stored, etc). This feels important.</p><p>  我们注意到用户的行为，例如创建一个装满他们最喜欢的机器人的棋盘，并将这些卡镜像到架子上，以将其带到他们想要的棋盘上。删除漫游器是通过像其他任何卡片一样将卡片从屏幕上丢下来完成的。所有处理（例如）图像卡的操作也都适用于机器人卡。计算遵循与数据相同的规则（可以克隆，共享，存储等）。这很重要。 </p><p>  The potential for end-user programming remains largely a dream in today’s computing devices. The huge amount of work done by academia and industry indicates this is a very hard problem indeed. But in working on this problem via these experiments, our team feels that it is achievable with enough concentrated effort from our industry, and worth doing so.</p><p>在当今的计算设备中，最终用户编程的潜力仍然很大。学术界和工业界所做的大量工作表明，这确实是一个非常棘手的问题。但是在通过这些实验解决此问题时，我们的团队认为，通过我们行业的足够努力，这是可以实现的，值得这样做。</p><p> Our positive findings from these experiments include the strength of combining strong typing (uses/exposes) with visual program flows; the magic feeling of interacting with a living system; and embodiment of long-running computation as bots, visually represented as cards with properties the user already knows.</p><p> 从这些实验中我们获得的积极发现包括将强类型（使用/暴露）与可视化程序流相结合的优势；与生命系统互动的神奇感觉；以及长期运行为机器人的计算的实施方式，以视觉上表示为具有用户已经知道的属性的卡片。</p><p> Our negative findings included that our best experiment (REPL) still required an external/separate toolchain; that visual arrangement of computation cards can get messy quickly; and that API design and documentation will be a huge challenge for a powerful end-user system.</p><p> 我们的负面发现包括我们最好的实验（REPL）仍然需要外部/单独的工具链；计算卡的视觉布置会很快变得混乱；对于强大的最终用户系统而言，API设计和文档编制将是巨大的挑战。</p><p> At Ink &amp; Switch we continue to believe that the end-user programming utopia is reachable. Are you working on this problem, or have thoughts on what we&#39;ve written here? Get in touch:  @inkandswitch or   [email protected]</p><p> 在油墨Switch我们继续认为，最终用户编程的乌托邦是可以实现的。您是在解决这个问题，还是对我们在这里写的内容有想法？保持联系：@inkandswitch或[受电子邮件保护]</p><p>   Three of the five Capstone end-user programming experiments used a different device for the programming interface. In both cases, we were able to build on the CRDT / Hypermerge data storage layer rather than use a traditional network connection such such as  ssh or  nREPL.</p><p>   五个Capstone最终用户编程实验中的三个在编程界面上使用了不同的设备。在这两种情况下，我们都可以在CRDT / Hypermerge数据存储层上构建，而不必使用诸如ssh或nREPL之类的传统网络连接。</p><p>  We could speculate that this is the difference between imperative vs declarative code. Imperative programs say “run this function on the host.” Declarative says “update a portion of the document and let all subscribers to the document choose how to render the new state.”</p><p>  我们可以推测这是命令性代码与声明性代码之间的区别。命令性程序说“在主机上运行此功能”。声明式说：“更新文档的一部分，并让文档的所有订阅者选择如何呈现新状态。”</p><p> Even in the case of a REPL, which is by nature imperative, simply storing the history of commands within the document gives us a scrubbable history of changes made to the system that is inspectable by anyone with access to the document.</p><p> 即使在本质上是必须的REPL的情况下，简单地将命令的历史记录存储在文档中也可以使我们对系统进行的更改具有可清除的历史记录，任何有权访问该文档的人都可以检查该历史记录。 </p><p> We are already  exploring this topic in our next Ink &amp; Switch project. We’re experimenting with live documents as a basis for a new programming model; realtime version control that combines the best parts of Git/Github and Google Docs; inspectable change history as a way to surface the power of CRDTs to end users; and what happens with end-user programmable environments when everyone is connected to a shared document.</p><p>我们已经在下一个Ink＆amp;中探索了这个主题。切换项目。我们正在尝试将实时文档作为新编程模型的基础；实时版本控制，结合了Git / Github和Google Docs的最佳功能；可检查的变更历史记录，以向最终用户展示CRDT的功能；当每个人都连接到共享文档时，最终用户可编程环境会发生什么。</p><p>  We chose  Chrome OS as our platform for Capstone over more mature options like the iPad or Surface largely because web technologies offer vastly more possibilities for end-user programming. On other platforms, we would have needed to embed a scripting language and runtime such as  Lua.</p><p>  我们选择Chrome OS作为Capstone的平台，而不是iPad和Surface等更成熟的选项，主要是因为网络技术为最终用户编程提供了更多的可能性。在其他平台上，我们将需要嵌入脚本语言和运行时，例如Lua。</p><p> Some examples of apps that make great use of the web’s native extensibility:</p><p> 充分利用网络的本机可扩展性的一些应用示例：</p><p>  Embedding the Javascript toolchain for building and running Javascript programs in place (such as the editable cards shown in our first experiment) is straightforward. In this case we  bundled the  Babel compiler via  @babel/standalone for building JSX files. As an added bonus, it bundles most popular presets and plugins.</p><p>  嵌入Javascript工具链以就地构建和运行Javascript程序（例如我们的第一个实验中显示的可编辑卡）非常简单。在这种情况下，我们通过@ babel / standalone捆绑了Babel编译器以构建JSX文件。另外，它捆绑了最流行的预设和插件。</p><p> One open question is how to use external libraries. A potential solution is using a service like  unpkg to provide users with a fetch and cache mechanism.</p><p> 一个未解决的问题是如何使用外部库。潜在的解决方案是使用unpkg之类的服务为用户提供获取和缓存机制。</p><p> Overall, the web is the only full-featured platform ever created that allows instant download and execution of a program written by a stranger (by visiting a website URL). But the perfect sandboxing of the Javascript runtime means that this action is almost completely safe. This is a truly stunning technical achievement and means that the web is a promising place for end-user programming capabilities.</p><p> 总体而言，网络是有史以来创建的唯一功能齐全的平台，该平台允许即时下载和执行由陌生人编写的程序（通过访问网站URL）。但是Javascript运行时的完美沙箱意味着此操作几乎是完全安全的。这是一项真正令人惊叹的技术成就，意味着网络是最终用户编程功能的有希望的地方。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.inkandswitch.com/end-user-programming.html">https://www.inkandswitch.com/end-user-programming.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/最终用户/">#最终用户</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/user/">#user</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>