<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>迷失的编程方法：Commodore 64 Basic</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">迷失的编程方法：Commodore 64 Basic</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-07 11:19:13</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/1c73dcb4e8eef769e2d2e29f3add898a.png"><img src="http://img2.diglog.com/img/2020/11/1c73dcb4e8eef769e2d2e29f3add898a.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In this interactive article, we will build a breakout game using Commodore 64 BASIC in the browser. This is a fun programming hack, but it has quite profound theoretical background. Let me explain.</p><p>在这篇互动文章中，我们将在浏览器中使用Commodore 64 Basic构建一个突围游戏。这是一个有趣的编程技巧，但它有相当深厚的理论背景。听我解释。</p><p>  I believe that  how we interact with a programming environment when programming is more important than the specific programming language that we are using.</p><p>我相信，当编程比我们使用的特定编程语言更重要时，我们如何与编程环境交互。</p><p>  This has never been widely studied and we have interesting things to learn from past systems, including Commodore 64 BASIC.</p><p>这从来没有被广泛研究过，我们可以从过去的系统中学到一些有趣的东西，包括准将64 Basic。</p><p>  We should look at the history and recreate past programming experiences in order to learn from them, following a method that a historian of science, Hasok Chang, calls  complemetary science.</p><p>我们应该回顾历史，重现过去的编程经验，以便向他们学习，遵循科学史学家张夏硕(Hasok Chang)所称的完全科学的方法。</p><p>  Reading about interactions is not enough. To get a sense of how the interaction worked, you need to experience it yourself, at least in a limited form. This is best done with an interactive article.</p><p>仅仅阅读有关互动的内容是不够的。要了解互动是如何运作的，你需要亲身体验，至少是在有限的形式下。这最好是用一篇互动的文章来完成。</p><p>  This is an interactive article that documents some of the interesting aspects of programming Commodore 64 BASIC. I&#39;m not trying to create an accurate Commodore 64 simulator though. The point is to show a few things that we can learn from for future programming systems.</p><p>这是一篇交互式文章，记录了Commodore 64 Basic编程的一些有趣方面。不过，我并不是要创造一个精确的准将64模拟器。重点是展示一些我们可以在未来的编程系统中学习的东西。</p><p>  We will start with a Hello World example to see how things work and then we&#39;ll build a small Breakout game. This illustrates how easy it is to get started, how the environment supports learning and how the Commmodore 64 BASIC mode of interaction lets us gradually build a program in a way that is quite different from modern programming environments.</p><p>我们将从Hello World示例开始，看看事情是如何工作的，然后我们将构建一个小型突围游戏。这说明了入门是多么容易，环境如何支持学习，以及Commmodore 64基本交互模式如何让我们以一种与现代编程环境截然不同的方式逐步构建程序。</p><p>        When Commodore 64 starts, a welcome screen from BASIC awaits you. Even if you want to use it to just play games, you start with a programming environment. This tells you that you too can become a programmer and you certainly do not need to download gigabytes of tools and wait hours for your XCode or Visual Studio to install.</p><p>当准将64启动时，一个来自Basic的欢迎屏幕等待着你。即使您只想使用它来玩游戏，您也可以从编程环境开始。这告诉您，您也可以成为一名程序员，您当然不需要下载千兆字节的工具，也不需要等待数小时才能安装XCode或Visual Studio。</p><p>  Let&#39;s follow the tradition and tell BASIC to say hello world for us. To do this, type the following command, or if you are lazy, just click the button.</p><p>让我们遵循传统，让Basic为我们问好世界。要执行此操作，请键入以下命令，或者如果您很懒，只需单击该按钮即可。</p><p>       To a modern programmer, it is amazing how little it takes to get from booting the machine to printing hello world. Not only you start in the programming environment but you also do not need to write any classes, static methods and compile the program.</p><p>对于一个现代程序员来说，从启动机器到打印Hello world所需的时间是如此之少，这是令人惊讶的。您不仅可以从编程环境开始，还不需要编写任何类、静态方法和编译程序。</p><p>  The obvious next thing is to print hello world in an infinite loop. Previously, we entered a single command and BASIC executed it, but now we need to create a program. To do this, we prefix code with line numbers:</p><p>显而易见的下一步是在无限循环中打印Hello world。以前，我们输入一个命令并由Basic执行它，但现在我们需要创建一个程序。为此，我们在代码前加上行号：</p><p>    This is again ingenious. BASIC keeps a list of lines of your program and when you type a line starting with number, it inserts it into the right location. You can use the same prompt for running commands and editing your program. To run the program now, just type RUN:</p><p>这又是一种巧妙的做法。Basic会保存程序的行列表，当您键入以数字开头的行时，它会将其插入到正确的位置。您可以使用相同的提示符来运行命令和编辑程序。要现在运行该程序，只需键入run：</p><p>       If you run a program with an infinite loop like this one, you can stop it using Ctrl+C or Command+C. If you want to see the program that you entered, you can type the LIST command.</p><p>如果您运行的程序带有类似这样的无限循环，您可以使用Ctrl+C或Command+C来停止它。如果您想要查看您输入的程序，您可以输入list命令。</p><p>          There is a lot of clever hacks that you can do in BASIC with a few lines of code. This ease of getting started contributes to what makes it a fun programming environment. If you found an interesting hack in a computer magazine, you could type it into the console and run it straight away.</p><p>在Basic中，只需几行代码就可以实现许多巧妙的技巧。这种入门的简便性使它成为一个有趣的编程环境。如果你在电脑杂志上发现了有趣的黑客攻击，你可以把它输入控制台，然后马上运行它。</p><p>  The fact that you had to copy code from a paper magazine sounds like a hassle, but it has an educational quality. It keeps the samples that can be distributed in this way reasonably small and it makes you think about the code as you are typing it.</p><p>你必须从纸质杂志上复制代码这一事实听起来很麻烦，但它具有教育意义。它使可以以这种方式分发的样本保持在相当小的范围内，并且让您在输入代码时考虑代码。</p><p>  To experience this yourself, you should try typing the following three-line program to the console! It generates a famous maze. This relies on special Commodore character codes: 147 clears the screen, 205 and 206 are backslash and slash crossing the full character size.</p><p>要亲自体验这一点，您应该尝试在控制台中输入以下三行程序！它会产生一个著名的迷宫。这依赖于特殊的准将字符代码：147清除屏幕，205和206是反斜杠和横跨整个字符大小的斜杠。</p><p>            To build our Breakout game, we can proceed gradually. This is yet another nice feature of the programming environment. We want to create a ball that bounces off the wall, but let&#39;s start with a ball that just moves to the right.</p><p>要打造我们的突围游戏，我们可以循序渐进。这是编程环境的另一个很好的特性。我们想创造一个从墙上弹起的球，但让我们从一个向右移动的球开始吧。</p><p>  We will do only a tiny bit of planning. Code that initializes variables with the game state starts at line 1000 and code that handles ball movement will start at 2000. We will also first clear the screen and use DELETE to remove all the previous maze and Hello World code.</p><p>我们只会做很少的规划。用游戏状态初始化变量的代码从第1000行开始，处理球移动的代码从2000开始。我们还将首先清除屏幕并使用DELETE删除所有先前的迷宫和Hello World代码。</p><p>  PRINT CHR$(147);DELETE 1000 REM STATE INITIALIZATION 1010 X=02000 REM BALL MOVEMENT2010 POKE X CHR$(32)2020 X=X+12030 POKE X CHR$(209)2040 GOTO 2000RUN</p><p>打印CHR$(147)；删除1000REM状态初始化1010X=02000 REM球移动2010 Pke X CHR$(32)2020 X=X+12030 Pke X CHR$(209)2040Goto 2000Run。</p><p>  To draw a ball at a specific location, we use POKE which writes a value to a memory location. Here, the part of memory representing a screen starts at offset 0. We first erase the previous ball using a space (character code 32) and then draw a ball (character code 209).</p><p>要在特定位置绘制一个球，我们使用poke，它将一个值写入内存位置。这里，代表屏幕的内存部分从偏移量0开始。我们首先使用空格(字符代码32)擦除前一个球，然后画一个球(字符代码209)。</p><p>          To make the ball bounce off the walls, we need to check when it gets to the side of the screen and reverse the direction in which it moves. To do this, we need to keep more state. We were using the varibale X to keep the X coordinate. Now we add Y for the Y coordinate and also DX, DY for the direction (+1 or -1). To see our code clearly, let&#39;s first clear the screen and LIST our current code.</p><p>要让球从墙上弹起，我们需要检查它何时到达屏幕一侧，并反转它移动的方向。要做到这一点，我们需要保持更多的状态。我们使用变量X来保持X坐标。现在，我们为Y坐标添加Y，并为方向(+1或-1)添加DX、DY。为了清楚地看到我们的代码，让我们首先清除屏幕并列出我们当前的代码。</p><p>    We immediately follow the edits in initialization code with edits in the ball movement code, starting at line 2000, to check for collisions with the left side and the right side of the screen:</p><p>我们紧跟在初始化代码中的编辑之后，在球移动代码中进行编辑(从第2000行开始)，以检查与屏幕左侧和右侧的冲突：</p><p> 2010 POKE ((Y*40)+X) CHR$(32)2020 X=X+DX2030 Y=Y+DY2040 IF X=40 THEN DX=-12050 IF X=40 THEN X=382060 IF X&lt;0 THEN DX=12070 IF X&lt;0 THEN X=12200 POKE ((Y*40)+X) CHR$(209)2210 GOTO 2000RUN</p><p>2010Poke((Y*40)+X)CHR$(32)2020 X=X+DX2030 Y=Y+DY2040如果X=40，则DX=-12050如果X=40，则X=382060；如果X&lt；0，则DX=12070如果X&lt；0，则X=12200 Pke((Y*40)+X)CHR$(209)2210转至2000Run。</p><p>        We knew that we will need to add checks for the top and the bottom side, so we left some empty lines. The checking code ends at 2070 and ball drawing is on line 2200. We just need to inser the remaining checks:</p><p>我们知道需要为顶部和底部添加支票，所以我们保留了一些空行。检查代码在2070结束，抽球在2200行。我们只需要填上剩下的支票：</p><p>  2080 IF Y=25 THEN DY=-12090 IF Y=25 THEN Y=232100 IF Y&lt;0 THEN DY=12110 IF Y&lt;0 THEN Y=2RUN</p><p>2080年如果Y=25，则DY=-12090；如果Y=25，则Y=232100；如果Y&lt；0，则DY=12110；如果Y&lt；0，则Y=2Run。</p><p>        Why is the ball still moving just from left to right and back? We added the checking code, but forgot to change DY. This is easy to fix:</p><p>为什么球还在从左向右再向后移动？我们添加了校验码，但忘了更改DY。这很容易修复：</p><p>          This is what we wanted, a ball that bounces off the walls! But let me reflect on how we created the program. We started with a moving ball and then added bouncing in two steps. The programming model of Commodore 64 BASIC makes this very easy.</p><p>这就是我们想要的，一个从墙上弹起的球！但让我反思一下我们是如何创建这个项目的。我们从一个移动的球开始，然后分两步增加弹跳。Commodore 64 Basic的编程模型使这一点变得非常简单。</p><p>  This relies on two things. First, as the code is a simple imperative list of commands, the addressing (using line numbers) makes editing the program much easier than if it consisted of complex composed expressions. We had to be clever about line numbers to have space for inserting code, but this is a small price to pay. Second, the dual use of the console, as both an editor and a REPL, means that the interaction is kept quite simple.</p><p>这取决于两件事。首先，由于代码是一个简单的命令性命令列表，寻址(使用行号)使编辑程序比编辑由复杂的组合表达式组成的程序要容易得多。我们必须聪明地处理行号，才能有空间插入代码，但这只是一个很小的代价。其次，控制台的双重用途(既是编辑器又是REPL)意味着交互非常简单。</p><p>  There is even more to the console. You can use it to run one off tests, like  PRINT (Y*40)+X to test your calculation. You can also modify the state directly and then jump into the middle of a program. For example, we can move the ball to the right bottom corner and let the program run from there by jumping over the initialization code:</p><p>这款游戏机还有更多的功能。您可以使用它来运行一次性测试，比如Print(Y*40)+X来测试您的计算。您也可以直接修改状态，然后跳到程序中间。例如，我们可以将球移动到右下角，并通过跳过初始化代码让程序从那里运行：</p><p>            Before we can turn the program into an actual game, we need to figure out how to handle input from keyboard. If you have a string variable  K$, you can use  GET$ K$ to read a key from a buffer. This will return an empty string if there is no key in the buffer, so we need to write a loop waiting for a key. We can do this on lines 10-50, before the start of our actual program:</p><p>在我们把这个程序变成一个真正的游戏之前，我们需要弄清楚如何处理来自键盘的输入。如果您有一个字符串变量K$，则可以使用GET$K$从缓冲区读取密钥。如果缓冲区中没有键，这将返回一个空字符串，因此我们需要编写一个等待键的循环。在实际程序开始之前，我们可以在第10-50行执行此操作：</p><p>       After printing the PETSCII code of the character, we explicitly stop the program, so that it does not continue into our ball bouncing code. Try running the program now using the  RUN command repeatedly to get key codes for up and down arrows! The interpreter does not support all keys, but it handles arrows, space and alphanumeric characters.</p><p>打印完字符的PETSCII代码后，我们显式地停止程序，这样它就不会继续进入我们的球弹跳代码。现在尝试使用Run命令重复运行该程序，以获取向上和向下箭头的关键代码！解释器不支持所有键，但它可以处理箭头、空格和字母数字字符。</p><p>  We will need the key code for the up key (145) and the down key (17). Now that we know this, we can delete our test code:</p><p>我们需要向上键(145)和向下键(17)的密钥代码。现在我们知道了这一点，我们可以删除我们的测试代码：</p><p>         Now that we figured out how to handle input, we can add a paddle to our game. It will be on the left side of the screen and will move using up and down keys. We can write the code independently of all that we have written so far, adding a line 1050 to the initialization code and starting the paddle moving code at 2500.</p><p>既然我们已经了解了如何处理输入，我们就可以在游戏中添加一把桨了。它将位于屏幕的左侧，并使用向上键和向下键进行移动。我们可以独立于到目前为止已经编写的所有代码来编写代码，在初始化代码中添加1050行，并在2500处开始划桨移动代码。</p><p>  The logic is quite simple. We read a key and get its code. If the key is up or down, we increment or decrement the position of the paddle. We then draw the paddle using  POKE, also drawing a space before and after to erase a previous state. The emulator does not support  FOR loops, so we just draw 5 vertical bar characters one after the other.</p><p>逻辑很简单。我们读取一把钥匙并得到它的代码。如果键向上或向下，我们会递增或递减球拍的位置。然后，我们使用POKE绘制划桨，还在前后画了一个空格来擦除之前的状态。仿真器不支持循环，所以我们只需要一个接一个地绘制5个竖线字符。</p><p>  1050 P=102500 REM MOVING A PADDLE 2510 K$=&#34;&#34;2520 K=02530 GET$ K$2540 IF K$&lt;&gt;&#34;&#34; THEN K=ASC(K$)2550 IF K=145 THEN P=P-12560 IF K=17 THEN P=P+12570 POKE ((P-1)*40) CHR$(32)2571 POKE ((P+0)*40) CHR$(182)2572 POKE ((P+1)*40) CHR$(182)2573 POKE ((P+2)*40) CHR$(182)2574 POKE ((P+3)*40) CHR$(182)2575 POKE ((P+4)*40) CHR$(182)2576 POKE ((P+5)*40) CHR$(32)2580 GOTO 2500</p><p>1050P=102500 REM移动A球拍2510 K=02530，如果K$&lt；&&gt;34；&#34；&#34；则获得$2540 K；；&#34；&#34；；2520 K=02530，如果K$&lt；&gt；&#34；&#34；则获得$2540；则K=Asc(K$)2550如果K=145，则P=P-12560如果K=17，则P=P+12570 poke((P-1)*40)chr$(32)2571 poke((P+0)*40)chr$(182)2572 poke((P+1)*40)chr$(182)2573 poke((P+2)*40)chr$(182)2574 poke((P+3)*40)chr。</p><p>  You can run this regardless of whether you followed the previous sections. If you did, typing  RUN would start the bouncing ball, so instead, we initialize P manually and jump directly to the paddle handling code.</p><p>无论您是否遵循了前面的章节，您都可以运行此命令。如果您这样做了，输入run将启动弹跳球，因此，我们手动初始化P并直接跳到球拍处理代码。</p><p>         To get something running as soon as possible, we did not add any checks to make sure that the paddle does not run outside of the screen. If this happens, the program right now stops and you need to kill it using Ctrl+C. To fix this, we need to draw spaces around the paddle only when it is not at the start/end and ensure that P is between 0 and 20. We were wise enough to use multiples of 10 as our line numbers, so we have space to insert this code between 2560 and 2570.</p><p>为了尽快让某些东西运行，我们没有添加任何检查以确保PATE不会在屏幕之外运行。如果发生这种情况，程序会立即停止，您需要使用Ctrl+C组合键终止它。要解决这个问题，我们只需要在不在开始/结束位置时在桨周围画空格，并确保P在0到20之间。我们非常明智地使用10的倍数作为行号，所以我们有空间在2560到2570之间插入此代码。</p><p>  2570 IF P&gt;0 THEN POKE ((P-1)*40) CHR$(32)2576 IF P&lt;20 THEN POKE ((P+5)*40) CHR$(32)2561 IF P&gt;0 THEN P=02562 IF P&lt;20 THEN P=20GOTO 2500</p><p>如果P&&gt;0，则戳((P-1)*40)chr$(32)2576如果P&lt；20，则戳((P+5)*40)chr$(32)2561如果P&&gt;0，则P=02562；如果P&lt；20，则P=20GOTO 2500。</p><p>          We built two parts of the game largely independently. The code for the bouncing ball is between lines 2000 and 2500 and we can start it by typing  RUN or  GOTO 2000. The code for the paddle starts after that and we can run it using  GOTO 2500. The last step is to connect the two parts! If you skipped a part of the tutorial, the following lets you reload all the code.</p><p>我们在很大程度上独立构建了游戏的两个部分。弹跳球的代码在2000到2500行之间，我们可以通过输入run或goto 2000来启动它。在那之后，划板的代码就开始了，我们可以使用GOTO 2500来运行它。最后一步是把这两个部分连接起来！如果您跳过了本教程的一部分，以下内容可让您重新加载所有代码。</p><p>     The whole code is now too long to fit on a screen when you run  LIST. If you want to see it, you need to run  LIST -2500 to see everything before line 2500 or  LIST 2500- to see everything after.</p><p>现在运行List时，整个代码太长，无法显示在屏幕上。如果您想查看它，则需要运行list-2500来查看第2500行之前的所有内容，或者运行list 2500来查看2500行之后的所有内容。</p><p>  To link the two parts, we need to make a couple of edits. First, we&#39;ll clear the screen at the end of the initialization code and update the bouncing so that the ball keeps on the right of the paddle. Second, we&#39;ll connect the two parts. To do this, we merge the two loops by removing  GOTO 2000 from the end of the ball movement code. We&#39;ll jump to line 2000 only after also updating the paddle on line 2580.</p><p>要链接这两个部分，我们需要进行几次编辑。首先，我们将清除初始化代码末尾的屏幕，并更新弹跳，使球保持在球拍的右侧。其次，我们将把这两个部分联系起来。为此，我们通过从球移动代码的末尾删除GoTo 2000来合并这两个循环。只有在更新了2580线上的球拍之后，我们才会跳到2000线。</p><p>          This looks like a game, but we are missing one last crucial bit. We need to add a check to detect when the ball does not hit the paddle while bouncing off the left side of the screen. We insert this between lines 2030 and 2040, i.e just after we update the ball location.</p><p>这看起来像是一场比赛，但我们遗漏了最后一个关键部分。我们需要添加一个检查，以检测球在从屏幕左侧反弹时没有击中球拍。我们在2030和2040行之间插入这段代码，也就是在更新球位置之后。</p><p>  2031 IF (X=0) AND (Y&lt;P) THEN GOTO 30002032 IF (X=0) AND (Y&gt;(P+4)) THEN GOTO 30003000 STOPRUN</p><p>2031年如果(X=0)和(Y&lt；P)，则转到30002032 IF(X=0)和(Y&&gt;；(P+4))，然后转到30003000 STOPRUN。</p><p>        When the ball is below or above the paddle, the code jumps to line 3000 which uses the  STOP command to terminate the program. To make the game a bit nicer, we replace this with a nice GAME OVER effect. If you are typing this, you can also run  GOTO 3000 at the end to debug just the game over code, without having to play the game.</p><p>当球在球拍下方或上方时，代码跳转到3000行，该行使用STOP命令终止程序。为了让游戏更好看一些，我们用一个漂亮的游戏结束效果来代替它。如果你正在输入这段代码，你也可以在最后运行GoTo 3000，在代码上只调试游戏，而不必玩游戏。</p><p>  3000 REM GAME OVER3010 PRINT CHR$(147);3020 S=03030 S=S+13040 PRINT &#34; GAME OVER&#34;3050 IF S&lt;25 THEN GOTO 30303060 PRINT CHR$(147)RUN</p><p>3000REM游戏OVER3010打印克朗$(147)；3020S=03030 S=S+13040打印游戏结束##34；3050如果S&lt；25，则转到30303060打印克朗$(147)运行。</p><p>          That&#39;s it! If you followed the individual steps of the article, you now created a simple Breakout game in a bit less than 50 lines of code. The point of the article was to let you experience how the process of programming feels, but if you skipped over some parts, you can cheat and load the whole game below. After doing this, use  RUN to run it or  LIST to see the full code.</p><p>就是这样！如果您遵循了本文的各个步骤，那么现在您已经用不到50行代码创建了一个简单的Breakout游戏。这篇文章的目的是让你体验编程过程的感觉，但是如果你跳过一些部分，你可能会欺骗并加载下面的整个游戏。完成此操作后，使用Run运行它，或使用List查看完整代码。</p><p>        I started this article by suggesting that  how we interact with a programming environment is more important than the language that is used. Computer science is very good for talking about programming languages, but it has traditionally said little about interacting.</p><p>我在开始这篇文章时提出，我们如何与编程环境交互比使用的语言更重要。计算机科学非常擅长谈论编程语言，但它传统上很少谈及交互。</p><p>  The point of this article is to point out some of the interesting aspects of interacting with Commodore 64 BASIC. This is a very simple environment, but there are some valuable lessons:</p><p>本文的重点是指出与Commodore 64 Basic交互的一些有趣的方面。这是一个非常简单的环境，但有一些宝贵的经验教训：</p><p>  It is easy to start programming. The system boots into a programming environment, making that the primary way of interacting with the machine. Loading a game from a tape and running it involves the same kind of interactions as programming.</p><p>开始编程很容易。系统引导进入编程环境，使其成为与机器交互的主要方式。从磁带加载并运行游戏涉及到与编程相同的交互。</p><p>  It is easy to learn. The fact that many programs were available as code listings in paper magazines may be an accidental virtue, but it means that they are short and that you learn as you copy them.</p><p>这很容易学。许多程序在纸质杂志上以代码清单的形式出现，这可能是偶然的美德，但这意味着它们很短，你可以在复制的过程中学习。</p><p>  There is just one kind of interaction. You type commands into a console, but this works both as a way of running commands immediately (REPL) and as a way of constructing a program (editor).</p><p>只有一种互动。您可以在控制台中键入命令，但这既是立即运行命令的一种方式(REPL)，也是构建程序(编辑器)的一种方式。</p><p>  You get a simple yet flexible workspace. We created two parts of the game independently and then connected them by editing two GOTOs. They are also easy to test independently, because we can set variables in the REPL mode and jump direclty into the middle of our code.</p><p>你会得到一个简单而灵活的工作空间。我们独立创建了游戏的两个部分，然后通过编辑两个GoTo将它们连接在一起。它们也很容易独立测试，因为我们可以在REPL模式下设置变量，并直接跳到代码中间。</p><p>  Hacker access to extra features. I only partly demonstrated this, but  POKE (and  SYS) give you access to many extra features of the system. The common things are simple, but curious hackers get a reward.</p><p>黑客访问额外功能。我只是部分演示了这一点，但是POKE(和SYS)让您可以访问系统的许多额外功能。常见的事情很简单，但好奇的黑客会得到奖励。</p><p>  I&#39;m not suggesting we should throw away our TypeScript with Visual Studio Code or Java with Eclipse and go back to Commodore 64 and BASIC. However, modern programming environments, even with REPL or live reloading, can certainly learn a few tricks.</p><p>我并不是建议我们扔掉使用Visual Studio Code的打字稿或使用Eclipse的Java打字稿，而是回到Commodore 64和Basic。然而，现代编程环境，即使使用REPL或实时重载，也肯定可以学到一些技巧。</p><p>  Perhaps the most important point is that the language should be co-designed with the programming interactions. For example, line numbers in BASIC are not just poor man&#39;s loops. They enable many of the interesting interactions with the system.</p><p>也许最重要的一点是，语言应该与编程交互一起设计。例如，BASIC中的行号不仅仅是穷人的循环。它们允许与系统进行许多有趣的交互。</p><p>    This article also tries to make a methodological point. A naive view of science is that it is a progressive enterprise that gradually improves our knowledge bit by bit. As historians and philosophers of science pointed out, actual science is much more complicated.</p><p>本文还试图提出一个方法论观点。一种天真的观点认为，科学是一项进步的事业，是一点一点地逐步提高我们的知识。正如历史学家和科学哲学家指出的那样，实际的科学要复杂得多。</p><p>  Pluralism in science means that there can sometimes be multiple accepted, but mutually inconsistent theories, which can still productively exchange ideas. Scientific revolutions mean that sometimes, revolutionary shift in the basic assumptions invalidates past knowledge.</p><p>科学中的多元化意味着有时可能会有多个被接受但相互矛盾的理论，这些理论仍然可以有效地交流思想。科学革命意味着，有时，基本假设的革命性转变会使过去的知识失效。</p><p>  Although we are sometimes reluctant to call computer science a science, we nevertheless believe in the naive idea of its straightforward progressive nature. This view implies that our present knowledge encompasses all the good ideas from the past and forgotten ideas were lost because they were simply not good. This is not true for sciences like physics and much less so for computer science.</p><p>尽管我们有时不愿称计算机科学为一门科学，但我们仍然相信其直截了当的进步本质这一天真的想法。这种观点暗示，我们现在的知识囊括了过去所有好的想法，而被遗忘的想法则因为它们根本就不好而丢失了。物理等科学并非如此，计算机科学更是如此。</p><p>  What does this mean? If we accept that there might be something to past scientific ideas that were lost, it becomes worthwhile to reconstruct those ideas, bring them into a modern context and see how they can contribute to current developments. Historian of science, Hasok Chang, calls this approach  complementary science.</p><p>这是什么意思？如果我们承认过去的科学思想可能有某些东西丢失了，那么就有必要重建这些思想，把它们放在现代的背景下，看看它们如何为当前的发展做出贡献。科学史学家张夏硕(Hasok Chang)称这种方法为互补科学。</p><p>  Complementary computer science is exactly what I tried to do in this article. I believe that interesting ideas on how to interact with a programming environment have been lost, largely because programming research became so focused on  languages (possibly under the influence of Algol). This article is an attempt to recreate some of the interesting past ideas. My choice of starting with Commodore 64 BASIC is a fairly pragmatic one. There are more interesting past programming systems, but this one was relatively easy to recreate.</p><p>互补的计算机科学正是我在这篇文章中想要做的。我认为，关于如何与编程环境交互的有趣想法已经丢失，很大程度上是因为编程研究变得如此专注于语言(可能是在ALGOL的影响下)。这篇文章试图重现一些有趣的过去的想法。我选择从准将64 Basic开始是一个相当务实的选择。过去还有更有趣的编程系统，但这一个相对容易重现。</p><p>  Talking about programming interactions is also harder than talking about programming languages, because a language can easily be described formally in a printed paper. To make sense of an interaction, you need to experience it. This is why this article is interactive and why I encourage the reader to play with the environment, at least by copying some of the code.</p><p>谈论编程交互也比谈论编程语言更难，因为一种语言很容易在纸质报纸上进行正式描述。要理解互动，你需要体验它。这就是为什么这篇文章是交互式的，也是我鼓励读者玩弄环境的原因，至少是通过复制一些代码来实现的。</p><p>  In other words, we need to change both what we talk about and how we talk about it, because  the medium is the message.</p><p>换句话说，我们需要改变我们谈论的内容和谈论它的方式，因为媒介就是信息。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://tomasp.net/commodore64/">http://tomasp.net/commodore64/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ways/">#ways</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033536.html"><img src="http://img2.diglog.com/img/2020/11/thumb_037aca4fd4242375cfdc54c66dcb59f0.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033536.html">
Netflix在法国测试编程的线性电视和电影频道</a></div><span class="my_story_list_date">2020-11-6 20:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033316.html"><img src="http://img2.diglog.com/img/2020/11/thumb_21f8be35cef4397449ea9dd55e0aa657.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033316.html">Python取代Java成为第二大最受欢迎的编程语言</a></div><span class="my_story_list_date">2020-11-5 20:25</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033174.html"><img src="http://img2.diglog.com/img/2020/11/thumb_b1db87a8aa18f25398c18443eb064347.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033174.html">异步/等待在编程中的优势</a></div><span class="my_story_list_date">2020-11-4 22:6</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033004.html"><img src="http://img2.diglog.com/img/2020/11/thumb_022ae1f163e3837faf7572f4d1b4761b.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033004.html">使用Haskell以本机速度编程R</a></div><span class="my_story_list_date">2020-11-4 1:10</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>