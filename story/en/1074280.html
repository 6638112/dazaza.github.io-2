<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Caxa：包节点。将js应用程序转换为可执行二进制文件Caxa: Package Node.js applications into executable binaries</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Caxa: Package Node.js applications into executable binaries<br/>Caxa：包节点。将js应用程序转换为可执行二进制文件</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 19:37:01</div><div class="page_narrow text-break page_content"><p>Simple to use.  npm install caxa and call  caxa from the command line. No need to declare which files to include; no need to bundle the application into a single file.</p><p>简单易用。npm安装caxa并从命令行调用caxa。无需声明要包含哪些文件；无需将应用程序捆绑到单个文件中。</p><p> Supports any kind of Node.js project, including those with native modules (for example,  sharp,  @leafac/sqlite (shameless plug!),  and others).</p><p>支持任何类型的节点。js项目，包括那些带有本机模块的项目（例如，sharp、@leafac/sqlite（无耻的插件！），和其他人）。</p><p>   Relatively small binaries. A “Hello World!” application is ~30MB, which is terrible if compared to Go’s ~2MB, and worse still if compared to C’s ~50KB, but best-in-class if compared to other packaging solutions for Node.js.</p><p>相对较小的二进制文件。“你好，世界！”应用程序的容量约为30MB，与Go的2MB相比非常糟糕，与C的50KB相比更糟糕，但与Node的其他打包解决方案相比，它是同类中最好的。js。</p><p>   No magic. No traversal of  require()s trying to find which files to include; no patches to Node.js source.</p><p>没有魔法。不需要遍历require（）以查找要包含的文件；节点没有补丁。js来源。</p><p>  Doesn’t support cross-compilation (for example, building a Windows executable from a macOS development machine).</p><p>不支持交叉编译（例如，从macOS开发机器构建Windows可执行文件）。</p><p> Doesn’t support packaging with a Node.js version different from the one that’s running caxa (for example, bundling Node.js 15 while running caxa with Node.js 14).</p><p>不支持使用节点打包。js版本与运行caxa的版本不同（例如，将Node.js 15捆绑在一起，同时将caxa与Node.js 14捆绑在一起）。</p><p>     Build. For example, compile TypeScript with  tsc, bundle with webpack, and whatever else you need to get the project ready to start. Typically this is the kind of thing that goes into an  npm  prepare script, so the  npm ci from the previous point may already have taken care of this.</p><p>建筑例如，用tsc编译TypeScript，用webpack打包，以及任何你需要的东西来让项目准备好开始。通常，这是npm准备脚本中要用到的内容，因此前一点中的npm ci可能已经解决了这一点。</p><p> If there are files that shouldn’t be in the package, remove them from the directory. For example, you may wish to remove the  .git directory.</p><p>如果包中有不应包含的文件，请将其从目录中删除。例如，您可能希望删除。git目录。</p><p> You don’t need to  npm dedupe --production, because caxa will do that for you from within the build directory. (Otherwise, if you tried to  npm dedupe --production you’d uninstall caxa, which should probably be in  devDependencies.)</p><p>您不需要npm重复数据消除——生产，因为caxa将在构建目录中为您完成这项工作。（否则，如果您尝试npm重复数据消除--生产，您将卸载caxa，它可能应该在devdependences中。）</p><p> It’s recommended that you run caxa on a Continuous Integration server. (GitHub Actions, for example, does a shallow fetch of the repository, so removing the  .git directory becomes negligible—but you can always do that with the  --exclude advanced option.)</p><p>建议您在持续集成服务器上运行caxa。（例如，GitHub操作对存储库进行浅层获取，因此删除.git目录变得微不足道，但您始终可以使用--exclude advanced选项来完成这项操作。）</p><p>  $  npx caxa --help Usage: caxa [options] &lt;command...&gt; Package Node.js applications into executable binaries. Arguments:  command The command to run and optional arguments to pass to the command every time the executable is called. Paths must be absolute.  The ‘{{caxa}}’ placeholder is substituted for the folder from which the package runs. The ‘node’ executable is available at  ‘{{caxa}}/node_modules/.bin/node’. Use double quotes to delimit the command and each argument. Options:  -V, --version output the version number  -i, --input &lt;input&gt; The input directory to package.  -o, --output &lt;output&gt; The path where the executable will be produced. On Windows must end in ‘.exe’. In macOS may end in ‘.app’ to generate a macOS  Application Bundle. In macOS and Linux, may end in ‘.sh’ to use the Shell Stub, which takes less space, but depends on some  tools being installed on the end-user machine, for example, ‘tar’, ‘tail’, and so forth.  -f, --force [Advanced] Overwrite output if it exists. (default: true)  -F, --no-force  -e, --exclude &lt;path...&gt; [Advanced] Paths to exclude from the build. The paths are passed to https://github.com/sindresorhus/globby and paths that match  will be excluded. [Super-Advanced, Please don’t use] If you wish to emulate ‘--include’, you may use ‘--exclude &#34;*&#34; &#34;.*&#34;  &#34;!path-to-include&#34; ...’. The problem with ‘--include’ is that if you change your project structure but forget to change the caxa  invocation, then things will subtly fail only in the packaged version.  -d, --dedupe [Advanced] Run ‘npm dedupe --production’ on the build directory. (default: true)  -D, --no-dedupe  -p, --prepare-command &lt;command&gt; [Advanced] Command to run on the build directory while packaging.  -n, --include-node [Advanced] Copy the Node.js executable to ‘{{caxa}}/node_modules/.bin/node’. (default: true)  -N, --no-include-node  -s, --stub &lt;path&gt; [Advanced] Path to the stub.  --identifier &lt;identifier&gt; [Advanced] Build identifier, which is the path in which the application will be unpacked.  -b, --remove-build-directory [Advanced] Remove the build directory after the build. (default: true)  -B, --no-remove-build-directory  -m, --uncompression-message &lt;message&gt; [Advanced] A message to show when uncompressing, for example, ‘This may take a while to run the first time, please wait...’.  -h, --help display help for command Examples:  Windows:  &gt; caxa --input &#34;examples/echo-command-line-parameters&#34; --output &#34;echo-command-line-parameters.exe&#34; -- &#34;{{caxa}}/node_modules/.bin/node&#34; &#34;{{caxa}}/index.js&#34; &#34;some&#34; &#34;embedded arguments&#34; &#34;--an-option-thats-part-of-the-command&#34;  macOS/Linux:  $ caxa --input &#34;examples/echo-command-line-parameters&#34; --output &#34;echo-command-line-parameters&#34; -- &#34;{{caxa}}/node_modules/.bin/node&#34; &#34;{{caxa}}/index.js&#34; &#34;some&#34; &#34;embedded arguments&#34; &#34;--an-option-thats-part-of-the-command&#34;  macOS (Application Bundle):  $ caxa --input &#34;examples/echo-command-line-parameters&#34; --output &#34;Echo Command Line Parameters.app&#34; -- &#34;{{caxa}}/node_modules/.bin/node&#34; &#34;{{caxa}}/index.js&#34; &#34;some&#34; &#34;embedded arguments&#34; &#34;--an-option-thats-part-of-the-command&#34;  macOS/Linux (Shell Stub):  $ caxa --input &#34;examples/echo-command-line-parameters&#34; --output &#34;echo-command-line-parameters.sh&#34; -- &#34;{{caxa}}/node_modules/.bin/node&#34; &#34;{{caxa}}/index.js&#34; &#34;some&#34; &#34;embedded arguments&#34; &#34;--an-option-thats-part-of-the-command&#34;</p><p>$npx caxa——帮助用法：caxa[选项]&lt；命令&gt；包节点。将js应用程序转换为可执行二进制文件。参数：每次调用可执行文件时，命令将运行该命令，并将可选参数传递给该命令。路径必须是绝对的。“{caxa}}”占位符将替换运行包的文件夹。“node”可执行文件可在“{caxa}}/node_modules/”上找到。bin/节点'。使用双引号分隔命令和每个参数。选项：-V，--version输出版本号-i，--input&lt；输入&gt；要打包的输入目录-o、 --输出&lt；产量&gt；生成可执行文件的路径。在Windows上必须以“”结尾。exe'。在macOS中可能会以'结尾。“应用程序”生成macOS应用程序包。在macOS和Linux中，可能以'结尾。sh’使用Shell Stub，占用的空间较小，但取决于最终用户机器上安装的一些工具，例如“tar”、“tail”等等-f、 --强制[高级]覆盖输出（如果存在）。（默认值：true）-F，-no force-e，--exclude&lt；路径&gt；[高级]从生成中排除的路径。路径被传递到https://github.com/sindresorhus/globby匹配的路径将被排除。[超级高级，请不要使用]如果你想模仿'-include'，你可以使用'-exclude&#34*&#34; &#34;.*&#34;  &#34;!包含&#34；…'的路径。“--include”的问题是，如果您更改了项目结构，但忘记了更改caxa调用，那么只有在打包的版本中，事情才会微妙地失败-d、 --重复数据消除[高级]在生成目录上运行“npm dedupe--production”。（默认值：true）-D，--无重复数据消除-p，--prepare命令&lt；指挥部&gt；打包时在生成目录上运行的[Advanced]命令-n、 --包含节点[高级]复制节点。js可执行文件到{caxa}/node_modules/。bin/节点'。（默认值：true）-N，--no include节点-s，--stub&lt；路径&gt；[Advanced]指向存根的路径--标识符&lt；标识符&gt；[Advanced]构建标识符，即应用程序解包的路径-b、 --删除生成目录[Advanced]在生成后删除生成目录。（默认值：true）-B，-no remove build directory-m，--uncompression message&lt；信息&gt；[高级]解压时显示的消息，例如，“第一次运行可能需要一段时间，请稍候……”-h、 --帮助显示命令示例的帮助：Windows:&gt；caxa——输入和#34；示例/echo命令行参数&#34--输出&#34；echo命令行参数。exe&#34；——&#34;{{caxa}}/node_modules/。bin/node&#34&#34;{{caxa}}/index。js&#34&#34;有些&#34&#34;嵌入参数&#34&#34;--这是命令的一部分#34；macOS/Linux:$caxa——输入和#34；示例/echo命令行参数&#34--输出&#34；echo命令行参数&#34；——&#34;{{caxa}}/node_modules/。bin/node&#34&#34;{{caxa}}/index。js&#34&#34;有些&#34&#34;嵌入参数&#34&#34;--这是命令的一部分#34；macOS（应用程序包）：$caxa——输入和#34；示例/echo命令行参数&#34--输出&#34；Echo命令行参数。应用程序&#34；——&#34;{{caxa}}/node_modules/。bin/node&#34&#34;{{caxa}}/index。js&#34&#34;有些&#34&#34;嵌入参数&#34&#34;--这是命令的一部分#34；macOS/Linux（Shell存根）：$caxa——输入和#34；示例/echo命令行参数&#34--输出&#34；echo命令行参数。sh&#34；——&#34;{{caxa}}/node_modules/。bin/node&#34&#34;{{caxa}}/index。js&#34&#34;有些&#34&#34;嵌入参数&#34&#34;--这是命令的一部分#34；</p><p> Here’s  a real-world example of using caxa. This example includes packaging for Windows, macOS, and Linux; distributing tags with GitHub Releases Assets; distributing Insiders Builds for every push with GitHub Actions Artifacts; and deploying a binary to a server with  rsync (and publishing an npm package as well, but that’s beyond the scope of caxa).</p><p>下面是一个使用caxa的真实例子。这个例子包括Windows、macOS和Linux的打包；使用GitHub发布标签释放资产；通过GitHub Actions工件，为每一次推送分发内部人员构建；以及使用rsync将二进制文件部署到服务器（以及发布npm包，但这超出了caxa的范围）。</p><p>  Instead of calling caxa from the command line, you may prefer to write a program that builds your application, for example:</p><p>与其从命令行调用caxa，不如编写一个构建应用程序的程序，例如：</p><p> import  caxa  from  &#34;caxa&#34; ; ( async  ( )  =&gt;  {  await  caxa ( {  input:  &#34;examples/echo-command-line-parameters&#34; ,  output:  &#34;echo-command-line-parameters&#34; ,  command:  [  &#34;{{caxa}}/node_modules/.bin/node&#34; ,  &#34;{{caxa}}/index.js&#34; ,  &#34;some&#34; ,  &#34;embedded arguments&#34; ,  ] ,  } ) ; } ) ( ) ;</p><p>从&#34进口caxa；卡萨&#34；（异步（）=&gt；{wait caxa（{input:&#34；examples/echo命令行参数&#34；，output:&#34；echo命令行参数&#34；{caxa}/node_modules/.bin/node#34；&#34；{caxa 34}/index.js 34；，&#34；&#34；一些&##嵌入参数&#( ) ;</p><p> You may need to inspect  process.platform to determine in which operating system you’re running and come up with the appropriate parameters.</p><p>您可能需要检查流程。平台来确定您正在运行的操作系统，并提供适当的参数。</p><p>   If you wish to run a command that isn’t  node, for example,  ts-node, you may do so by extending the  PATH. For example, you may run the following on macOS/Linux:</p><p>如果希望运行非node的命令，例如ts node，可以通过扩展路径来实现。例如，您可以在macOS/Linux上运行以下操作：</p><p>   This is only an issue on macOS/Linux. In these operating systems a binary must have the executable mode enabled in order to run. You may check the mode from the command line with  ls -l: on an output that reads like  -rwxr-xr-x [...]/bin/node, the  xs represent that the file is executable.</p><p>这只是macOS/Linux上的一个问题。在这些操作系统中，二进制文件必须启用可执行模式才能运行。您可以在类似于-rwxr-xr-x[…]的输出上使用ls-l:从命令行检查模式/bin/node，xs表示该文件是可执行的。</p><p> Here’s what you may do when you distribute the binary to ensure that the file mode is preserved:</p><p>以下是分发二进制文件时可以执行的操作，以确保保留文件模式：</p><p> Create a tarball or zip. The file mode is preserved through compression/decompression, and macOS/Linux (most distributions, anyway) come out of the box with software to uncompress tarballs and zips—the user can just double-click on the file.</p><p>制作一个防水布或拉链。文件模式是通过压缩/解压来保持的，macOS/Linux（无论如何，大多数发行版）自带了解压tarball和zips的软件，用户只需双击文件即可。</p><p>   Fun fact: Windows 10 also comes with the  tar executable, so the command above works on Windows as well. Unfortunately the File Explorer on Windows doesn’t support uncompressing the  .tgz with a double-click (it supports uncompressing  .zip, however). Fortunately, Windows doesn’t have issues with file modes to begin with (it simply looks for the  .exe extension) so distributing the caxa output directly is appropriate.</p><p>有趣的事实：Windows 10还附带了tar可执行文件，所以上面的命令也适用于Windows。不幸的是，Windows上的文件资源管理器不支持解压缩文件。双击tgz（但它支持解压缩.zip）。幸运的是，Windows一开始就没有文件模式的问题（它只是查找.exe扩展名），因此直接分发caxa输出是合适的。</p><p> In some contexts this may make more sense, but it requires your users to use the command line.</p><p>在某些情况下，这可能更有意义，但它需要用户使用命令行。</p><p>  caxa doesn’t do anything special to your application, so there’s no built-in way of telling whether the application is running from the packaged version. It’s part of caxa’s ethos of being as out of the way as possible. Also, I consider it to be a bad practice: an application that is so self-aware is more difficult to reason about and test.</p><p>caxa不会对应用程序执行任何特殊操作，因此没有内置的方法来判断应用程序是否从打包版本运行。这是caxa尽可能远离尘嚣的精神气质的一部分。此外，我认为这是一个糟糕的做法：一个自我意识很强的应用程序更难推理和测试。</p><p> That said, if you really need to know whether the application is running from the packaged versions, here are some possible workarounds in increasing levels of badness:</p><p>这就是说，如果你真的需要知道应用程序是否是从打包的版本运行的，下面是一些可能的解决方法，以提高不良程度：</p><p> Receive a command-line argument that you embed in the packaging process, for example,  &#34;{{caxa}}/node_modules/.bin/node&#34; &#34;application.js&#34; &#34;--caxa&#34;.</p><p>接收一个嵌入到打包过程中的命令行参数，例如，&#34；{{caxa}}/node_modules/。bin/node&#34&#34;应用js&#34&#34;--caxa&#34；。</p><p>  Even though the code for the application is in a temporary directory, the current working directory when calling the packaged application is preserved, and you may inspect it with  process.cwd(). This is probably not something you have to think about—caxa just gets it right.</p><p>即使应用程序的代码位于临时目录中，调用打包的应用程序时的当前工作目录也会被保留，您可以使用进程来检查它。cwd（）。这可能不是你必须考虑的caxa问题，只要把它做好就行了。</p><p>   As far as I can understand, the root of the problem with creating binaries for Node.js projects is native modules. Native modules are libraries written at least partly in C/C++, for example,  sharp,  @leafac/sqlite (shameless plug!),  and others. There are at least three issues with native modules that are relevant here:</p><p>据我所知，为Node创建二进制文件是问题的根源。js项目是本机模块。本机模块是至少部分用C/C++编写的库，例如sharp、@leafac/sqlite（无耻的插件！），等等。本机模块至少有三个问题与此相关：</p><p> You must have a working C/C++ build system to install these libraries (C/C++ compiler,  make, Python, and so forth). On Windows, you must install  windows-build-tools. On macOS, you must install the Command-Line Tools (CLT) with  xcode-select --install. On Linux, it depends on the distribution, but on Ubuntu  sudo apt install build-essential is enough.</p><p>要安装这些库（C/C++编译器、make、Python等等），必须有一个运行正常的C/C++构建系统。在Windows上，必须安装Windows生成工具。在macOS上，必须使用xcode select--install安装命令行工具（CLT）。在Linux上，这取决于发行版，但在Ubuntu sudo上，apt install build essential就足够了。</p><p> The installation of native modules isn’t cross-platform. Unlike JavaScript dependencies, which you may copy from an operating system to another, native modules produce compiled C/C++ code that’s specific to the operating system on which the dependency is installed. This compiled code appears in your  node_modules directory in the form of  .node files.</p><p>本机模块的安装不是跨平台的。JavaScript依赖项可以从一个操作系统复制到另一个操作系统，与此不同，本机模块生成特定于安装依赖项的操作系统的编译C/C++代码。编译后的代码以的形式出现在node_modules目录中。节点文件。</p><p> As far as I understand,  Node.js insists on loading native modules from files in the disk. Other Node.js packaging solutions get around this limitation in one of two ways: They either patch Node.js to trick it into loading native modules differently; or they put  .node files somewhere before starting your program.</p><p>据我所知，诺德。js坚持从磁盘中的文件加载本机模块。另一个节点。js打包解决方案可以通过以下两种方式之一绕过这个限制：要么修补节点。js欺骗它以不同的方式加载本机模块；或者他们把。在启动程序之前的某个位置创建节点文件。</p><p>  caxa builds on the idea of putting  .node files in a temporary location, but takes it to ultimate consequence: a caxa executable is a form of  self-extracting archive containing your whole project along with the  node executable. When you first run a binary produced by caxa, it  extracts the source the whole project (and the bundled  node executable) into a temporary location. From there, it simply calls whatever command you told it to run when you packaged the project.</p><p>caxa建立在推杆的理念之上。节点文件位于临时位置，但最终的结果是：caxa可执行文件是一种自解压存档形式，包含整个项目和节点可执行文件。当您第一次运行caxa生成的二进制文件时，它会将整个项目（以及捆绑的节点可执行文件）的源文件提取到一个临时位置。从那里，它只需调用打包项目时让它运行的任何命令。</p><p> At first, this may seem too costly, but in practice it’s mostly okay: It doesn’t take too long to uncompress a project in the first place, and caxa doesn’t clean the temporary directory after running your program, so subsequent calls are effectively cached and run without overhead.</p><p>一开始，这似乎成本太高，但实际上基本上没什么问题：首先解压缩项目不会花费太长时间，而且运行程序后caxa不会清理临时目录，因此后续调用会被有效缓存并在没有开销的情况下运行。</p><p> This idea is simple, but it’s super powerful! caxa supports any kind of project, including those with native dependencies, because running a caxa executable amounts to the same as installing Node.js on the user’s machine. caxa produces packages fast, because generating a self-extracting archive is a simple matter of concatenating some files. caxa supports any version of Node.js, because it simply copies the  node executable with which it was called into the self-extracting archive.</p><p>这个想法很简单，但它超级强大！caxa支持任何类型的项目，包括那些具有本机依赖项的项目，因为运行caxa可执行文件等同于安装节点。用户机器上的js。caxa生成包的速度很快，因为生成自解压归档文件只需连接一些文件。caxa支持任何版本的节点。js，因为它只是将调用它的节点可执行文件复制到自解压归档文件中。</p><p> Fun fact: By virtue of compressing the archive, caxa produces binaries that are naturally smaller when compared to other packaging solutions. Obviously, you could achieve the same outcome by compressing the output of these other tools, which may want to do anyway to preserve the file mode (see  § Preserving the Executable Mode of the Binary).</p><p>有趣的事实：通过压缩归档文件，caxa生成的二进制文件与其他打包解决方案相比自然更小。显然，您可以通过压缩这些其他工具的输出来实现相同的结果，这些工具可能无论如何都想保留文件模式（请参见§保留二进制文件的可执行模式）。</p><p>  Did you know that you may append anything to a binary and it’ll continue to work? This is true of binaries for Windows, macOS, and Linux. Here’s an example to try out on macOS/Linux:</p><p>你知道吗，你可以把任何东西附加到二进制文件中，它会继续工作吗？适用于Windows、macOS和Linux的二进制文件也是如此。下面是一个在macOS/Linux上试用的示例：</p><p> $  cp   $(which ls ) ./ls   # Copy the ‘ls’ binary into the current directory to play with it$  ./ls   # List the files, proving the that the binary works$   echo ANYTHING  &gt;&gt; ls   # Append material to the binary$  tail ./ls   # You should see ‘ANYTHING’ at the end of the output$  ./ls   # The output should be same as before!$  rm ls   # Okay, the test is over</p><p>$cp$（这是ls）/ls#将“ls”二进制文件复制到当前目录中，以使用它$/ls#列出文件，证明二进制文件可以运行$echo ANYTHING&gt&gt；ls#在二进制$tail中添加材料/ls#你应该在输出$的末尾看到'ANYTHING'/ls#输出应与之前相同！$好了，考试结束了</p><p> The caxa self-extracting archives work by putting together three parts: 1. a stub; 2. an archive; and 3. a footer. This is the layout of these parts in the binary produced by caxa:</p><p>caxa自解压档案由三部分组成：1。存根；2.档案；三,。页脚。这是caxa生产的二进制文件中这些部件的布局：</p><p>  The  STUB and the  ARCHIVE are separated by the  CAXACAXACAXA string. And the  ARCHIVE and the  FOOTER are separated by a newline. This layout allows caxa to find the footer by simply looking backward from the end of the file until it reaches a newline. And if this is the first time you’re running the caxa executable and the archive needs to be uncompressed, then caxa may find the beginning of the  ARCHIVE by looking forward from the beginning until it reaches the  CAXACAXACAXA separator.</p><p>存根和存档由caxacaxa字符串分隔。档案和页脚之间用新行隔开。这种布局允许caxa只需从文件末尾向后看，直到到达换行符即可找到页脚。如果这是您第一次运行caxa可执行文件，并且归档文件需要解压缩，那么caxa可以通过从开始向前看，直到到达caxa分隔符，来找到归档文件的开始。</p><p> Build a binary with caxa and inspect it yourself in a text editor (Visual Studio Code asks you to confirm that you want to open a binary, but works fine after that). You should be able to find the  CAXACAXACAXA separator between the  STUB and the  ARCHIVE, as well as the  FOOTER at the end.</p><p>使用caxa构建一个二进制文件，并在文本编辑器中亲自检查（Visual Studio代码要求您确认是否要打开一个二进制文件，但在这之后可以正常工作）。您应该能够在存根和归档文件之间找到caxacaxa分隔符，以及末尾的页脚。</p><p>     You may find the source code for the stub in  stubs/stub.go. You may build the stub with  npm run build:stubs. You will need a Go compiler, but the stub has no dependencies beyond the Go standard library, so there’s no need to setup Go modules or configure a  $GOPATH. There are pre-compiled stubs for the major platforms in the npm package. If you wish to verify that the stubs really were compiled from  stubs/stub.go, you may recompile it yourself, because the Go compiler appears to be deterministic and always produce the same binaries given the same source (at least that’s what happened in my tests).</p><p>您可以在stubs/stub中找到存根的源代码。去您可以使用npm run build:stubs构建存根。您将需要一个Go编译器，但存根除了Go标准库之外没有任何依赖项，因此无需设置Go模块或配置$GOPATH。npm包中有针对主要平台的预编译存根。如果您希望验证存根是否真的是从存根/存根编译而来。go，您可以自己重新编译它，因为go编译器似乎是确定性的，并且总是在给定相同源的情况下生成相同的二进制文件（至少在我的测试中是这样）。</p><p> This is beautiful in a way: We’re using Go’s ability to produce binaries to bootstrap Node.js’s ability to produce binaries.</p><p>这在某种程度上很漂亮：我们使用Go的能力来生成二进制文件来引导节点。js生成二进制文件的能力。</p><p>    This is JSON containing the extra information that caxa needs to run your project: Most importantly, the command that you want to run, but also an identifier for where to uncompress the archive.</p><p>这是一个JSON，包含caxa运行项目所需的额外信息：最重要的是，您要运行的命令，还有一个用于解压缩归档文件的标识符。</p><p>  Fun fact: There’s nothing Node.js-specific about the stubs. You may use them to uncompress any kind of archive and run any arbitrary command on the output! And it’s relatively straightforward to build a self-extracting archive from scratch. For example, you may run the following in macOS:</p><p>有趣的事实：没有节点。关于存根。您可以使用它们来解压缩任何类型的存档，并对输出运行任意命令！从零开始构建自解压归档相对简单。例如，您可以在macOS中运行以下操作：</p><p> $  cp stub an-ls-caxa$  tar -czf - README.md  &gt;&gt; an-ls-caxa$   printf   &#34;\n{  \&#34;identifier \&#34;:  \&#34;an-ls-caxa/AN-ARBITRARY-STRING-THAT-SHOULD-BE-DIFFERENT-EVERY-TIME \&#34;,  \&#34;command \&#34;: [ \&#34;ls \&#34;,  \&#34;{{caxa}} \&#34;] } &#34;  &gt;&gt; an-ls-caxa$  ./an-ls-caxa README.md</p><p>$cp存根和ls caxa$tar-czf-README。md&gt&gt；ls caxa$printf&#34；\n{&#34；标识符\&#34；：\&#34；一个ls-caxa/an-arbitative-STRING-THAT-SHOULD-BE-DIFFERENT-TIME \&#34；\&#34；命令\&#34；[\&#34；ls\&&#34；，\&#34；{caxa 34；]&#34;  &gt&gt；一个ls caxa$/ls caxa自述文件。医学博士</p><p>  It depends on the operating system. You may find the location on your system with:</p><p>这取决于操作系统。您可以通过以下方式在系统上找到位置：</p><p>   Why No Cross-Compilation? Why No Different Versions of Node.js besides the Version with Which caxa Was Called?</p><p>为什么没有交叉编译？为什么没有不同版本的节点。除了调用caxa的版本之外，还有js吗？</p><p>  I believe you should have environments to work with all the operating systems you plan on supporting. They may not be your main development environment, but they should be able to build your project and let you test things. At the very least, you should use a service like GitHub Actions which lets you run build tasks and tests on Windows, macOS, and Linux.</p><p>我相信你应该有一个可以与你计划支持的所有操作系统协同工作的环境。它们可能不是您的主要开发环境，但它们应该能够构建您的项目并让您进行测试。至少，您应该使用像GitHub Actions这样的服务，它允许您在Windows、macOS和Linux上运行构建任务和测试。</p><p> (I, for one, bought a PC to work on caxa. Yet another reason to  support my work!)</p><p>（比如，我买了一台电脑在caxa上工作。这是支持我工作的另一个原因！）</p><p> The principle of least surprise. When cross-compiling (for example, building a Windows executable from a macOS development machine), or when bundling different versions of Node.js (for example, bundling Node.js 15 while running caxa with Node.js 14), there’s no straightforward way to guarantee that the packaged project will run the same as the unpackaged version. If you aren’t using any native modules then things  may work, but as soon as you introduce a new dependency that you didn’t know was native your application may break. Not only are native dependencies different on the operating systems, but they may also be different between different versions of Node.js if these versions aren’t ABI-compatible (which is why sometimes when you update Node.js you must run  npm install again).</p><p>最小惊喜原则。交叉编译时（例如，从macOS开发机器构建Windows可执行文件），或绑定不同版本的节点时。js（例如，在运行caxa和Node.js 14时绑定Node.js 15），没有直接的方法可以保证打包的项目将与未打包的版本运行相同。如果您没有使用任何本机模块，那么事情可能会成功，但一旦引入了一个您不知道是本机的新依赖项，您的应用程序可能会崩溃。本机依赖项不仅在操作系统上不同，而且在不同版本的节点之间也可能不同。js，如果这些版本不兼容ABI（这就是为什么有时在更新Node.js时必须再次运行npm安装）。</p><p> Fun fact: The gold-standard for easy cross-compilation these days is Go. But even in Go cross-compilation goes out the window as soon as you introduce C dependencies (something called CGO). It appears that many people in the Go community try to solve the issue by avoiding CGO dependencies, sometimes going to great lengths to reinvent everything in pure Go. On the one hand, this sounds like fun when it works out. On the other hand, it’s a huge case of not-invented-here syndrome. In any case, native modules seem to be much more prevalent in Node.js than CGO is in Go, so I think that cross-compilation in caxa would be a fool’s errand.</p><p>有趣的事实：如今，易于交叉编译的黄金标准是Go。但是，即使在Go中，只要引入C依赖项（称为CGO），交叉编译也会消失。Go社区中的许多人似乎都试图通过避免CGO依赖性来解决这个问题，有时他们会不遗余力地在纯Go中重新创造一切。一方面，这听起来很有趣。另一方面，这是一个巨大的非发明于此综合征病例。在任何情况下，本机模块似乎在Node中更为普遍。js而不是CGO正在运行，所以我认为在caxa中进行交叉编译是一件愚蠢的事情。</p><p> If you still insist on cross-compiling or compiling for different versions of Node.js, you can still use the stub to build a self-extracting archive by hand (see  § Using the Self-Extracting Archive without caxa). You may even use  https://www.npmjs.com/package/node to more easily bundle different versions of Node.js.</p><p>如果您仍然坚持交叉编译或编译不同版本的Node。js，您仍然可以使用存根手动构建自解压存档（请参阅§使用不带caxa的自解压存档）。你甚至可以使用https://www.npmjs.com/package/node以更轻松地捆绑不同版本的节点。js。</p><p>  An macOS Application Bundle is just a folder with a particular structure and an executable at a particular place. When creating a macOS Application Bundle caxa doesn’t build a self-extracting archive, instead it just copies the application to the right place and creates an executable bash script to start the process.</p><p>macOS应用程序包只是一个具有特定结构的文件夹，以及位于特定位置的可执行文件。创建macOS应用程序包时，caxa不会构建自解压归档，而是将应用程序复制到正确的位置，并创建一个可执行的bash脚本来启动该过程。</p><p> The macOS Application Bundle may be run by simply double-clicking on it from Finder. It opens a Terminal.app window with your application. If you’re running an application that wasn’t built on your machine (which is most likely the case for your users, who probably downloaded the application from the internet), then the first time you run it macOS will probably complain about the lack of a signature. The solution is to go to  System Preferences &gt; Security &amp; Privacy &gt; General and click on  Allow. You must instruct your users on how to do this.</p><p>macOS应用程序包可以通过在Finder中双击来运行。它打开了一个终端。应用程序窗口中的应用程序。如果您运行的应用程序不是在您的机器上构建的（这很可能是您的用户的情况，他们可能从internet下载了该应用程序），那么第一次运行它时，macOS可能会抱怨缺少签名。解决方案是转到系统首选项&gt；保安及；隐私&gt；常规，然后单击允许。你必须指导你的用户如何做到这一点。</p><p>  It’s equivalent to the Go stub, except that it is smaller, because it’s just a dozen lines of Bash, but it depends on some things being installed on the end-user machine, for example,  tar,  tail, and so forth.</p><p>它相当于Go存根，只是它更小，因为它只有十几行Bash，但它取决于最终用户机器上安装的一些东西，例如tar、tail等等。</p><p>  If you’re interested in one of these features, please send a Pull Request if you can, or at least reach out to me and mention your interest, and I may get to them.</p><p>如果您对其中一个功能感兴趣，请尽可能发送请求，或者至少联系我并说明您的兴趣，我可能会找到它们。</p><p> Other compression algorithms. Currently caxa uses tarballs, which are ubiquitous and reasonably efficient in terms of compression/uncompression times and archive size. But there are better algorithms out there… (See  https://github.com/leafac/caxa/issues/1.)</p><p>其他压缩算法。目前，caxa使用tarball，它无处不在，在压缩/解压缩时间和归档大小方面相当有效。但是还有更好的算法…（参见https://github.com/leafac/caxa/issues/1.)</p><p> Add support for signing the executables. There are limitations on the kinds of executables that are signable, and a self-extracting archive of the kind that caxa produces may be unsignable (I know very little about this…). A solution could be use Go’s support for embedding data in the binary (which landed in Go 1.16). Of course this would require the person packaging a project to have a working Go build system. Another solution would be to manipulate the executables as data structures, instead of just appending stuff at the end. Go has facilities for this in the standard library, but then the packager itself (not only the stubs) would have to be written in Go, and creating packages on the command line by simply concatenating files would be impossible.</p><p>添加对可执行文件签名的支持。可签名的可执行文件的种类有限制，而caxa生成的那种自解压归档文件可能是不可签名的（我对此知之甚少……）。一个解决方案是使用Go的支持，将数据嵌入二进制文件中（该文件在Go 1.16中发布）。当然，这需要打包项目的人有一个运行的Go-build系统。另一个解决方案是将可执行文件作为数据结构进行操作，而不是仅仅在末尾添加内容。Go在标准库中有实现这一点的工具，但是打包程序本身（不仅是存根）必须用Go编写，并且在命令行上通过简单地连接文件来创建包是不可能的。</p><p> Add support for custom icons and other package metadata. This should be relatively straightforward by using  rcedit for  .exes and by adding  .plist files to  .apps (we may copy whatever Electron is doing here as well).</p><p>添加对自定义图标和其他包元数据的支持。通过使用rcedit for，这应该相对简单。加上。plist文件到。应用程序（我们也可以复制Electron在这里做的任何事情）。</p><p>   Below follows the extended version with everything I learned along the way of building caxa.</p><p>下面是我在构建caxa的过程中学到的所有知识的扩展版本。</p><p>  Deno has experimental support for producing binaries. I haven’t tried it myself, but maybe one day it catches on and caxa becomes obsolete. Let’s hope for that!</p><p>Deno提供了生成二进制文件的实验支持。我自己也没试过，但也许有一天它流行起来，caxa就过时了。希望如此！</p><p>  pkg is great, and it’s where I first learned that you coul</p><p>pkg很棒，这是我第一次了解到你可以</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/应用/">#应用</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/package/">#package</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/caxa/">#caxa</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>