<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>什么是模糊测试？ What Is Fuzz Testing?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What Is Fuzz Testing?<br/>什么是模糊测试？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-08 06:35:29</div><div class="page_narrow text-break page_content"><p>Fuzz testing detects the hard-to-find bugs that developers &amp;  other security tools like  SAST (static analysis) and  SCA (software composition analysis) typically miss.</p><p>Fuzz测试检测开发人员＆amp的难以找到的错误;其他安全工具，如SAST（静态分析）和SCA（软件成分分析）通常会错过。</p><p> Instead of testing with a small, pre-defined set of test cases that are handwritten by developers like unit tests or SAST, fuzz testing constantly tests your code with newly generated inputs, using the feedback and results it gathers to generate additional test cases, in an effort to exercise all of your application’s code paths. This feedback loop is run thousands of times per second, making it an effective way to test your application very thoroughly.</p><p> 代替用由单位测试或Sast等开发人员手写的小型预定义的测试用例进行测试，而是使用新生成的输入，使用反馈和结果来持续测试代码，而不是将代码与新生成的输入进行测试，以生成其他测试用例努力锻炼所有应用程序的代码路径。此反馈循环每秒运行数千次，使其具有非常彻底测试应用程序的有效方法。</p><p>   At its core, fuzz testing is an advanced type of random testing. It can be helpful to imagine fuzzing as a million monkeys typing on a million keyboards, all of which are hooked up to your application. These inputs are random, often completely invalid and unexpected by your program.</p><p>   在其核心，模糊测试是一种先进的随机测试类型。想象一百万只键盘上的百万只猴子，这一切都可以有所帮助，所有这些都是挂钩的。这些输入是随机的，通常由您的程序完全无效和意外。</p><p> Fuzz testing is so powerful because developers tend to only test the happy paths in their code (ie, the inputs that the user should be sending), leaving the malicious inputs untested. You can see how once you unleash all of those “monkeys” onto your application, you’ll end up uncovering all the edge cases your application doesn’t handle with grace. More often than not, your users end up playing the role of the “monkeys”, causing all sorts of unexpected and unhandled behavior in your live instance. Fuzzing allows you to discover these bugs before they ever hit production.</p><p> 模糊测试是如此强大，因为开发人员倾向于仅测试其代码中的快乐路径（即，用户应该发送的输入），因此将恶意输入未经测试。您可以看到释放所有这些“猴子”到应用程序上的所有内容，您将最终揭示您的应用程序无法使用恩典处理的所有边缘案例。更常见的是，您的用户最终播放了“猴子”的角色，在您的实例中导致各种意外和未处理的行为。模糊允许您在曾经生成之前发现这些错误。</p><p> You can think about it in terms of what a developer knows and doesn’t know.</p><p> 您可以根据开发商知道并不知道的方式思考它。</p><p> Known knowns: bugs that developers expect and write tests for: typically covered by manually written checks like unit and integration tests</p><p> 已知已知的：开发人员期望和写测试的错误：通常由手动写入单位和集成测试的检查</p><p> Known unknowns: bugs that developers know exist, but aren’t quite sure where or how they might manifest: usually found by SAST and SCA tools, which act like spell checkers looking for common errors</p><p> 已知未知数：开发人员知道的错误，但并不完全确定它们可能表现出来的地方或如何显示：通常由SAST和SCA工具找到，如拼写检查正在寻找常见错误 </p><p> Unknown unknowns: bugs that developers don’t expect, and are therefore also unsure where they may present themselves. Truly new bugs and vulnerabilities like  Heartbleed,  Urgent/11 and the  tens of thousands of Chrome vulnerabilities, which are otherwise discovered by users in production.</p><p>未知未知数：开发人员不指望的错误，因此也不确定他们可能呈现自己的地方。真正的新错误和漏洞，如令人毛骨悚然的，紧急/ 11和数万个Chrome漏洞，这些漏洞是由生产中的用户发现的。</p><p>   The types of bugs that fuzz testing can find vary between languages, but ultimately, a fuzzer is used to invalidate assumptions about your code. If you can define a property that must hold true for any given input (also called an invariant), then the fuzzer will look for inputs that break your invariant. Some invariants are true for every application. For example, your code should never produce:</p><p>   模糊测试的错误类型可以在语言之间变化，但最终，模糊器用于使您的代码的假设无效。如果您可以定义必须为任何给定的输入（也称为不变量）必须保持的属性（也称为不变量），则模糊将查找打破您不变的输入。每个应用程序都有一些不变性。例如，您的代码永远不应该产生：</p><p>  These are bugs that fuzz testing can easily discover in any code: your application should never crash, corrupt memory, or time out. It also just so happens that these types of bugs also make up over 50% of all  CVEs (the largest database of publicly disclosed vulnerabilities - 149,000 of them).</p><p>  这些是错误测试可以在任何代码中轻松发现的错误：您的应用程序不应该崩溃，损坏的内存或超时。它也是如此恰好，这些类型的错误也占所有CVES的50％以上（最大的公开披露漏洞数据库 -  149,000人）。</p><p> Developers can write their own invariants to discover bugs specific to their application by defining properties that must always be true. If the fuzzer detects that a property is not true for some input, it knows it has found a logic bug. Applications with complex business logic typically have a lot of underlying bugs that can only be found with fuzz testing.</p><p> 开发人员可以通过定义必须始终为true的属性来编写自己的不变性，以发现所特有的错误。如果Fuzzer检测到某些输入对属性不正确，它知道它已找到逻辑错误。具有复杂业务逻辑的应用程序通常只有很多底层错误，只能使用utzzz测试找到。</p><p>  Hopefully by now, you’re convinced that fuzz testing is an effective way to find bugs in your code and are starting to think about its applications. In our opinion, if you’re writing complex, mission-critical software, fuzz testing is the most effective way to mitigate unexpected bugs. Any part of your software that consumes data across a trust boundary is a perfect candidate for fuzzing.</p><p>  希望到现在，你相信伪装测试是在代码中找到错误的有效方法，并开始考虑其应用程序。在我们看来，如果您正在编写复杂，关键任务软件，Fuzz测试是减轻意外错误的最有效方法。您在信任边界上消耗数据的软件的任何部分都是模糊的完美候选者。</p><p>   While this isn’t an exhaustive list, it gives you a sense of the type of software that should be fuzzed. If you don’t control the source of the data your software processes, that software should be thoroughly fuzz tested.</p><p>   虽然这不是一个详尽的列表，但它为您提供了应该模糊的软件类型的感觉。如果您不控制数据流程的来源，则该软件应彻底欺骗。</p><p> On the other hand, if you’ve written a parser or framework that is meant to work with a custom or less well-known protocol, then it absolutely makes sense to fuzz that protocol implementation. This is very common in software that uses industry-specific protocols with custom framework implementations such as DICOM or BACNET.</p><p> 另一方面，如果您已编写了用于使用自定义或不太众所周知的协议的解析器或框架，那么符号对该协议实现绝对有意义。这在使用具有自定义框架实现（如DICOM或BACnet等行业特定协​​议的软件中非常常见。 </p><p>  Coverage-guided fuzz testing (sometimes referred to as mutational fuzzing) is one of the most important breakthroughs in the fuzzing space, which has made it the de-facto fuzzing technique over the last 5 years. Taking our monkey example from above, it’s a way to make the “monkeys” much smarter - allowing them to cover more lines of code in a fraction of the time.</p><p>覆盖引导的模糊测试（有时称为突变模糊）是模糊空间中最重要的突破之一，这使得它在过去5年中成为了De-Facto的模糊技术。从上面拍摄我们的猴子示例，这是一种使“猴子”更智能的方法 - 让他们在一小部分时间内覆盖更多的代码。</p><p> The idea behind coverage-guided fuzzing is that the fuzzing engine monitors the code coverage output of your application as it processes an input, which then guides the generation of the next set of inputs. While the fuzzer may generate inputs “randomly” at first, it saves the inputs that trigger new coverage in your application to the corpus (a set of interesting inputs), allowing it to drive deeper into your code with each set of new inputs.</p><p> 覆盖引导模糊背后的想法是，模糊发动机监视应用程序的代码覆盖输出，因为它处理输入，然后引导下一组输入集。虽然Fuzzer首先可以生成“随机”的输入，但它可以节省触发应用程序中的新覆盖的输入到语料库（一组有趣的输入），允许它通过每组新输入将其更深入地进入您的代码。</p><p> When you run this feedback loop thousands of times per second, the fuzzing engine very quickly picks up on structure and patterns within your program, essentially learning how to generate inputs tailored specifically to your application.</p><p> 当您每秒运行此反馈循环千次循环时，模糊发动机很快就会在程序中很快拾取结构和模式，基本上学习如何生成专门针对您的应用程序量身定制的输入。</p><p> A great example of this is  Michal Zalewski’s blog post on pulling JPEGs out of thin air (spoiler alert: in just 6 hours, the fuzzer taught itself to generate valid JPEG images from scratch).</p><p> 一个很好的例子是Michal Zalewski的博客帖子在拉出薄空气中拉出JPEG（扰流器警报：在短短6小时内，Fuzzer自身从头开始生成有效的JPEG图像）。</p><p> Coverage-guided fuzz testing is the most generally applicable fuzzing technique for developers -  if you can write a unit test, you can write a fuzz test. It can also fit seamlessly into continuous integration workflows, making it a great choice for many dev teams.</p><p> 覆盖引导的模糊测试是开发人员最普遍适用的模糊技术 - 如果您可以编写单元测试，可以编写模糊测试。它还可以无缝地融入持续的集成工作流程，使其成为许多开发团队的最佳选择。</p><p>  Protocol fuzzing (occasionally called generational fuzzing) acts as a low-friction alternative to coverage-guided fuzzing. Instead of knowing nothing about the application it’s fuzzing and learning as it goes along, it starts off with an in-depth understanding of the protocol the code expects, and sends inputs that mostly conform to the specification, with some exceptions - it’s important to test the robustness of the parser as well as the underlying business logic.</p><p>  协议模糊（偶尔称为世代模糊）用作覆盖引导模糊的低摩擦替代品。而不是在应用程序的情况下毫无了解它的应用程序，而是通过对代码预期的协议进行深入了解，而不是深入了解，并发送大多数符合规范的输入 - 有一些例外 - 测试是很重要的 - 重要的是测试解析器的鲁棒性以及底层业务逻辑。</p><p> This can be very effective against obscure and complex protocols that often have proprietary implementations or where the protocol is impossible to sufficiently test manually. Protocol fuzzing can craft inputs specifically for the protocol your application expects, enabling the fuzzer to not only test the parser layer, but the core business logic of your application as well.</p><p> 这对模糊和复杂的协议非常有效，这些方案通常具有专有实施或协议无法手动测试。 Protocol Fuzzing可以为您的应用程序预期的协议专门用于协议的工艺输入，使模糊不仅可以测试Parser层，而且可以对应用程序的核心业务逻辑。 </p><p> The other benefit of protocol fuzzing is the ability to fuzz large pre-compiled applications and complex systems. Protocol fuzzing typically only needs a thin agent to be deployed alongside the software under test in order to monitor for crashes, system errors, path traversal and unexpected behavior.</p><p>协议模糊的另一个好处是能够模仿大型预编译应用和复杂系统。协议模糊通常只需要将薄代理部署在被测软件旁边，以便监视崩溃，系统错误，路径遍历和意外行为。</p><p> We recommend protocol fuzzing as a great solution when testing complex, obscure or custom protocols, as well as a good alternative to coverage-guided fuzzing for when you have to fuzz black-box systems that are hard to instrument or modify.</p><p> 我们建议在测试复杂，模糊或自定义协议时作为一个很好的解决方案，以及覆盖引导模糊的替代方案，当您必须努力乐于仪器或修改时覆盖引导的模糊。</p><p>  Fuzzing sounds like a magic bullet, and is incredibly powerful when used properly, but in reality it’s difficult to get right - especially when it comes to integrating into your CI/CD pipeline and convincing your developers to adopt it as part of their workflow.</p><p>  模糊声像是一个魔法子弹，并且在正确使用时非常强大，但实际上它很难正确 - 特别是当涉及到您的CI / CD管道并说服开发人员作为工作流程的一部分采用它时，这很难。</p><p> Current fuzzing tools (open source or otherwise), aren’t very developer friendly, often forcing users to learn completely new testing paradigms, work with low-level structures they don’t understand, and significantly modify their application to get any results at all. Add in the need for custom infrastructure code to keep the fuzzer testing applications 24/7, and the set up time becomes too prohibitive for most teams to even consider.</p><p> 目前的模糊工具（开源或其他方式），不是很友好的，通常强迫用户学习完全新的测试范式，与低级结构一起工作，他们不明白，并显着修改其应用程序得到任何结果。添加了自定义基础架构代码，以保持模糊测试应用程序24/7，并且对于大多数团队甚至考虑的建议时间变得过于禁止。</p><p> Fuzzbuzz completely abstracts the complexities of fuzzing, so you don’t have to be a security or infrastructure expert to test your code. Fuzzbuzz requires no code to get started (although we do support all of the open source fuzzers), integrates directly into existing developer workflows, and ensures all bugs are reproducible and actionable, so developers don’t waste their time fiddling with infrastructure or chasing false positives.</p><p> FuzzBuzz完全摘要模糊的复杂性，因此您不必是测试代码的安全或基础设施专家。 FuzzBuzz不需要代码即可开始（虽然我们确实支持所有开源模糊），直接集成到现有的开发人员工作流程中，并确保所有错误是可重复和可操作的，因此开发人员不会浪费他们的时间摆弄基础设施或追逐虚假积极的。</p><p> Fuzzbuzz uses automation and intelligence to make fuzz testing as developer friendly as possible, but you don’t have to take our word for it -  sign up for a demo with the founders by clicking “Get Early Access” in the top right (or shoot me an email   [email protected]). We’re onboarding new users every week!</p><p> FuzzBuzz使用自动化和智能，使您可以尽可能友好地制作模糊测试，但您不必通过单击右上方的“获得早期访问”来注册与创始人的演示（或拍摄）我是电子邮件[电子邮件保护]）。我们每周都在登上新用户！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.fuzzbuzz.io/what-is-fuzz-testing">https://blog.fuzzbuzz.io/what-is-fuzz-testing</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fuzz/">#fuzz</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>