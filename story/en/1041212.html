<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>核心数据定律 The Laws of Core Data</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Laws of Core Data<br/>核心数据定律 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-22 13:43:48</div><div class="page_narrow text-break page_content"><p>In my conversations with developers, I’ve heard a pretty common theme from them that “Core Data is hard” or “Core Data is buggy” or “I could never get it to work right and gave up on it”.</p><p>在与开发人员的对话中，我听到了一个非常普遍的主题，即“核心数据很难”或“核心数据有错误”或“我永远无法使它正常工作并放弃”。</p><p> I’ve spent a lot of time using Core Data and thought I’d share my “Laws of Core Data”. These are a set of rules I’ve developed over time on how to use Core Data in such a way that it is almost  entirely painless. When I follow these rules, I almost  never have any problems using it.</p><p> 我花了很多时间使用Core Data，并以为我会分享“ Laws of Core Data”。这些是我随着时间的流逝而制定的一套规则，这些规则几乎完全不费力地使用Core Data。当我遵循这些规则时，使用它几乎没有任何问题。</p><p>  It’s common to hear developers talk about and treat Core Data as if it were a database. They see that it’s powered by  SQLite, and think it’s functionally equivalent.</p><p>  经常听到开发人员谈论核心数据并将其视为数据库的情况。他们看到它由SQLite提供支持，并认为它在功能上等效。</p><p>    Core Data is an “object graph and persistence framework”, which is basically like a fancy kind of  object-relational mapping. That means it is a whole bunch of code to help you maintain a graph (ie, a “network” of related pieces of data with a defined organization) of objects and then persist them in some fashion.</p><p>    核心数据是一个“对象图和持久性框架”，基本上就像是一种奇特的对象关系映射。这就是一堆完整的代码，可以帮助您维护对象的图形（即具有定义的组织的相关数据的“网络”），然后以某种方式持久化它们。</p><p>  It does not necessarily mean you have tables with rows of data. It does not necessarily mean that you have the ability to join across data types. It does not necessarily mean that it’s even stored as a file on your disk.</p><p>  这并不一定意味着您具有包含数据行的表。这并不一定意味着您具有跨数据类型进行联接的能力。这不一定意味着它甚至已作为文件存储在磁盘上。</p><p>      Having these abilities means you can have Core Data take care of a lot more logic for you than if you were using a traditional database.</p><p>      拥有这些功能意味着与使用传统数据库相比，您可以让Core Data为您处理更多的逻辑。</p><p>  This is very much related to the first law, but is a bit more specific, and it has to do with  how Core Data persists data. It is exceptionally rare to find a Core Data implementation that does not use SQLite as the persistence layer,  but it does happen.</p><p>  这与第一定律有很大关系，但是更具体一些，它与Core Data持久化数据的方式有关。很少会发现没有使用SQLite作为持久层的Core Data实现，但是确实发生了。 </p><p>      In addition to these, Core Data also allows you to create your own persistence mechanism, by subclassing either   NSAtomicStore or   NSIncrementalStore. So, if you wanted, you could make Core Data save things to a  git repository, or to  CloudKit, or to  MySQL or  PostgreSQL, or to your own custom backend… Several years ago I created a framework to access the  stackoverflow.com API, and networking was done via a custom Core Data store that translated Core Data requests in to API calls. It was weird, but it worked.</p><p>除了这些，Core Data还允许您通过子类化NSAtomicStore或NSIncrementalStore来创建自己的持久性机制。因此，如果您愿意，可以使Core Data将内容保存到git存储库，CloudKit，MySQL或PostgreSQL或您自己的自定义后端中。...几年前，我创建了一个框架来访问stackoverflow.com API，联网是通过自定义核心数据存储完成的，该存储将核心数据请求转换为API调用。这很奇怪，但是有效。</p><p>  Core Data does not have to be just SQLite. In fact, modeling your schema as if it were SQLite (or some other RDBMS variant) is a sure sign you’re “doing it wrong”. Setting up custom things like artificial foreign keys or join tables are almost never necessary and are almost always wrong.</p><p>  核心数据并不仅限于SQLite。实际上，对架构进行建模就好像它是SQLite（或其他RDBMS变体）一样，这无疑是您“做错了”的标志。几乎不需要设置诸如人造外键或联接表之类的自定义内容，并且几乎总是错误的。</p><p>  Typically one of the first things that developers do when creating a Core Data stack is to create a “DataStack” object that encapsulates loading up the model, creating the store coordinator, and then creating the main   NSManagedObjectContext. That “stack” object then gets passed around as your “Core Data manager” object by which you get the context you need. iOS 10.0 and macOS 10.12 added the concept of an   NSPersistentContainer, which does a lot of this for you.</p><p>  通常，开发人员在创建Core Data堆栈时要做的第一件事就是创建一个“ DataStack”对象，该对象封装了加载模型，创建存储协调器，然后创建主NSManagedObjectContext的过程。然后，该“堆栈”对象将作为“核心数据管理器”对象传递，通过它可以获取所需的上下文。 iOS 10.0和macOS 10.12添加了NSPersistentContainer的概念，它可以为您完成很多工作。</p><p>  Having a single object to load up your model and everything is great. But you  don’t need to pass it around.</p><p>  拥有一个对象即可加载模型，一切都很好。但是您不需要传递它。</p><p>  It’s usually passed around in order to have easy access to making a new context or accessing the model. That is all unnecessary. If you do decide to pass Core Data objects around your app, then all you need is the  NSManagedObjectContext (“MOC”).</p><p>  为了方便访问新的上下文或访问模型，通常将其传递出去。那都是不必要的。如果您确实决定在应用程序中传递Core Data对象，那么您只需要NSManagedObjectContext（“ MOC”）。</p><p>  Your MOC has an   NSPersistentStoreCoordinator (“PSC”) property, which itself has an   NSManagedObjectModel (“MOM”, aka the schema). So from a single MOC, you can get any information you need about your schema, where things are being saved, what format they’re being saved in, the configuration for the persistent stores, etc.</p><p>  您的MOC具有NSPersistentStoreCoordinator（“ PSC”）属性，该属性本身具有NSManagedObjectModel（“ MOM”，也称为架构）。因此，从单个MOC中，您可以获得与架构有关的任何信息，存储内容的位置，存储格式，持久性存储的配置等。</p><p>  If you decide you need to create a new, one-off MOC, it’s easy to do so with your existing MOC:</p><p>  如果您决定需要创建一个新的一次性MOC，则可以使用现有的MOC轻松做到这一点： </p><p>  let existingContext: NSManagedObjectContext = ... let newContext = NSManagedObjectContext(concurrencyType: .privateQueueConcurrencyType) newContext.persistentStoreCoordinator = existingContext.persistentStoreCoordinator // that&#39;s it</p><p>让existingContext：NSManagedObjectContext = ...让newContext = NSManagedObjectContext（concurrencyType：.privateQueueConcurrencyType）newContext.persistentStoreCoordinator = existingContext.persistentStoreCoordinator //做到这一点</p><p>    (Creating new contexts like this isn’t ideal, because of another law further down)</p><p>    （创建新的环境并不理想，因为还有其他法律规定）</p><p>  This law is  the source of bugs when it comes to Core Data. Offhand I’d guess that more than 90% of the pain developers experience with Core Data is because of this.</p><p>  涉及核心数据时，此法律是错误的来源。随便说一句，我想开发人员在使用Core Data时遇到的痛苦有90％以上是因为这个。</p><p>  Core Data tries to be efficient; it typically doesn’t like to load up more data than you need, which means there are times when you ask it for data (like an object property) and it doesn’t have it handy. When this happens, it has to go load the data from its store (which might not even be a local file on disk!) before it can respond to you.</p><p>  核心数据试图提高效率；它通常不希望加载比您需要的数据更多的数据，这意味着有时您会要求它提供数据（例如对象属性），并且它不方便使用。发生这种情况时，它必须先从其存储中加载数据（甚至可能不是磁盘上的本地文件！），然后它才能响应您。</p><p>  This is called “faulting”. The marker value internal kept by a managed object is a “fault”, and the process of “fulfilling” (ie, retrieving the data) the fault is “faulting”.</p><p>  这称为“故障”。被管理对象保留的内部标记值是“故障”，而“完成”（即，检索数据）故障的过程就是“故障”。</p><p>  Here’s the thing: Core Data has to be  safe. It has to synchronize these faulting calls with other accesses of the persistent store, and it has to do it in a way that isn’t going to interfere with other calls to fault in data. The way it does that is by expecting that all calls to fault in data happen safely inside one of its queues.</p><p>  关键在于：核心数据必须安全。它必须将这些错误的调用与持久性存储的其他访问进行同步，并且必须以不干扰其他数据错误调用的方式进行。这样做的方法是期望所有对数据错误的调用都在其队列之一中安全地发生。</p><p>  Every managed object “belongs” to a particular MOC (more on this in a minute), and every MOC has a  DispatchQueue that it uses to synchronize its internal logic about loading data from its  persistentStoreCoordinator.</p><p>  每个受管理对象“都属于”特定的MOC（稍后将对此进行详细介绍），并且每个MOC都有一个DispatchQueue，可用于同步其有关从其persistentStoreCoordinator加载数据的内部逻辑。 </p><p>  If you use an  NSManagedObject from  outside the MOC’s queue, then the calls to fault in data are not properly synchronized and protected, which means you’re susceptible to race conditions.</p><p>如果您是在MOC队列之外使用NSManagedObject的，那么对数据故障的调用将无法正确同步和受到保护，这意味着您很容易出现竞争状况。</p><p>  So, if you have an   NSManagedObject, the  only safe place to use it is from  inside a call to  perform or  performAndWait on its MOC, like so:</p><p>  因此，如果您有一个NSManagedObject，则唯一安全的使用位置是在其MOC上对perform或performAndWait的调用中，如下所示：</p><p>  let object: NSManagedObject = ... var propertyValue: PropertyType! object.managedObjectContext.performAndWait { propertyValue = object.property } ...</p><p>  let对象：NSManagedObject = ... var propertyValue：PropertyType！ object.managedObjectContext.performAndWait {propertyValue = object.property} ...</p><p>  Using your own  DispatchQueue or one of the global queues is insufficient. The managed object has to be accessed from the queue that is controlled by the MOC, and the way to do that is with the  perform and  performAndWait methods.</p><p>  使用您自己的DispatchQueue或全局队列之一是不够的。必须从MOC控制的队列中访问托管对象，而执行此操作的方法是使用perform和performAndWait方法。</p><p>  There is one special case to this, and that is dealing with managed objects that belong to a MOC whose queue is the “main” queue. The  DispatchQueue.main queue is bound to the main thread of your app, and so if you’re on the main thread and have a main-thread-object, you can “safely” not use  perform calls because you are  already inside the context’s queue.</p><p>  这有一个特殊情况，那就是处理属于MOC的托管对象，该MOC的队列为“主”队列。 DispatchQueue.main队列绑定到应用程序的主线程，因此，如果您在主线程上并且具有主线程对象，则可以“安全地”不使用执行调用，因为您已经在上下文的内部队列。</p><p>  The  only managed object property that is safe to use outside of a queue or pass between queues/threads is the object’s  objectID: this is a Core Data-provided identifier unique for that particular object. You can access this property from anywhere, and it is the  only way to “transfer” a managed object from one context to another:</p><p>  可以在队列外使用或在队列/线程之间传递的唯一安全托管对象属性是对象的objectID：这是Core Data提供的该特定对象唯一的标识符。您可以从任何地方访问此属性，这是将托管对象从一个上下文“转移”到另一个上下文的唯一方法：</p><p>  let objectInContextA: NSManagedObject = ... let objectID = objectInContextA.objectID let contextB: NSManagedObjectContext = ... contextB.perform { let objectInContextB = contextB.object(with: objectID) // objectInContextB is now a separate *instance* from the original object, // but both are backed by the same data in the persistent store }</p><p>  let objectInContextA：NSManagedObject = ... let objectID = objectInContextA.objectID let contextB：NSManagedObjectContext = ... contextB.perform {let objectInContextB = contextB.object（with：objectID）// objectInContextB现在是与原始对象分开的* instance *对象，//但都由持久性存储中的相同数据支持} </p><p>  I will add here that it is  really unfortunate we have to care about this. It’s not hard to imagine a world where managed objects deal with this sort of stuff automatically. However, this is what happens when we’re dealing with a framework that is over 14 years old and is based on another framework ( EOF) that is 24 years old. The problem of “binary compatibility” is a blog post for another day.</p><p>我要在这里补充一点，很遗憾，我们必须对此予以关注。不难想象，托管对象会自动处理这种事情。但是，当我们处理的框架已经使用了14年以上，并且基于24年的另一个框架（EOF）时，就会发生这种情况。 “二进制兼容性”问题是另一天的博客文章。</p><p>  This is a generalization of the previous law. Because of the weirdness around faulting and queue access, it’s my opinion that  NSManagedObject shouldn’t actually be a subclass of  NSObject. When we see  NSObject in our code, we have assumptions about how they work with regards to memory management, multi-threaded access, and behavior.  NSManagedObject breaks enough of these rules that it probably shouldn’t be an  NSObject, but should be its own root class.</p><p>  这是先前法律的概括。由于错误和队列访问的怪异，我认为NSManagedObject实际上不应该是NSObject的子类。当我们在代码中看到NSObject时，就对它们如何在内存管理，多线程访问和行为方面进行了假设。 NSManagedObject违反了这些规则，因此它可能不应该是NSObject，而应该是其自己的根类。</p><p>  So, forget that it’s an  NSObject. It doesn’t really behave like one, and you shouldn’t use it as if it were.</p><p>  因此，忘记它是一个NSObject。它的行为实际上并不像一个，并且您不应像使用它那样使用它。</p><p>  One of the more esoteric features of Core Data is the ability to have relationships between contexts: you can have a MOC that is not actually backed by the  NSPersistentStoreCoordinator, but is instead backed by  another MOC. This has some really interesting implications, but in general: you don’t need this.</p><p>  核心数据的一项更深奥的功能是能够在上下文之间建立关系：您可以拥有一个MOC，该MOC实际上不受NSPersistentStoreCoordinator支持，而由另一个MOC支持。这确实有一些有趣的含义，但总的来说：您不需要。</p><p>  The ability to have a child MOC is neat in some corner cases. Let’s review the core functionality of MOCs in order to understand those cases:</p><p>  在某些特殊情况下，拥有孩子MOC的能力很巧妙。让我们回顾一下MOC的核心功能，以了解这些情况：</p><p>    That’s really the core pieces. So, you would want a child MOC if:</p><p>    那才是真正的核心。因此，如果满足以下条件，您将需要一个儿童MOC：</p><p>    As you can see, when you deal with child contexts, you’re really dealing with transient (non-persisted) objects. You’re fundamentally changing loading and saving behavior.</p><p>    如您所见，当处理子上下文时，您实际上是在处理临时（非持久）对象。您将从根本上改变加载和保存行为。 </p><p>  The times when you  need this are pretty rare. You would typically want this for something like a complex sub-graph creation flow, where along each step of the flow, you need to enforce relationship integrity, but don’t want to actually save it to the persistent store until the flow is complete. And if the flow is cancelled, you don’t want any of it to be saved at all. You could do that by having a child context, doing all the flow steps in the child context, and saving it up to a parent context, but you can still delete the child context if the user aborts.</p><p>需要这种情况的时间很少见。对于复杂的子图创建流程，您通常会希望这样做，在流程的每个步骤中，您都需要加强关系的完整性，但是在流程完成之前，您不希望将其实际保存到持久性存储中。而且，如果取消了流程，您根本就不会保存任何流程。您可以通过具有子上下文，在子上下文中执行所有流程步骤并将其保存到父上下文中来实现，但是如果用户中止，您仍然可以删除子上下文。</p><p>  They’re kind of like transactions in normal database systems. You can start importing or editing a bunch of data, and if something goes wrong or is cancelled, you can roll back the changes.</p><p>  它们有点像普通数据库系统中的事务。您可以开始导入或编辑大量数据，如果出现问题或被取消，则可以回滚更改。</p><p>  Parent/child contexts are  usually advocated for something like “load some data in the background, and the saving it pushes it to the main queue context”. That can work, but it does mean that in order to persist your data, you actually have to save  two contexts, instead of just one (because  save()-ing a context only pushes the data up one level. For a child context, the data only goes to the parent context, not all the way up to the PSC). In my opinion, using a child context like this is unnecessarily complicated.</p><p>  通常提倡父/子上下文，例如“在后台加载一些数据，并将其保存到主队列上下文中”。可以奏效，但这确实意味着要保留数据，实际上必须保存两个上下文，而不是仅保存一个上下文（因为save（）－上下文只能将数据上移一个级别。对于子上下文，数据仅到达父上下文，而不是一直到PSC）。我认为，使用这样的儿童上下文会不必要地变得复杂。</p><p>  For general, non-transactional usage, I think it’s better to have two contexts (one for the main thread, one for the background) that both link directly to the PSC. Importation of data is done on the background context, and when it saves, the main queue listens for the  NSManagedObjectContextDidSave notification and merges in the changes with  .mergeChanges(fromContextDidSave:) method to update its internally-held objects. Even that step might be unnecessary if the context has  automaticallyMergesChangesFromParent set to  true.</p><p>  对于一般的非事务性用法，我认为最好有两个直接链接到PSC的上下文（一个用于主线程，一个用于后台）。数据的导入是在后台上下文中完成的，并且在保存时，主队列侦听NSManagedObjectContextDidSave通知，并使用.mergeChanges（fromContextDidSave :)方法合并更改以更新其内部保存的对象。如果上下文自动将MergesChangesFromParent设置为true，那么即使是该步骤也可能是不必要的。</p><p>  If you’re building an app that is reading information out of Core Data, displaying it to the user, and allowing minimal edits, then in my experience it’s best to keep the main queue context a “read-only” context.</p><p>  如果您要构建的应用程序正在从Core Data中读取信息，将其显示给用户并允许进行最少的编辑，那么根据我的经验，最好将主队列上下文保持为“只读”上下文。</p><p>  By having strict rules around which contexts are readable vs writable, it makes it  much easier to reason about when parts of your UI should be reloaded: commands to update the UI come from a single direction (from your model towards your UI). If you allow mutation of stored information, then that can be encapsulated as a sort of “request for mutation”, sent off to the controller for this part of your model, and executed there. Performing the mutation on a Core Data object directly makes it harder to debug where changes are coming from (the data import step? editing in the UI? something else?), because you have a single point of entry.</p><p>  通过具有关于可读性和可写性的严格的规则，可以更轻松地推断何时应重新加载部分UI：用于更新UI的命令来自单个方向（从模型到UI）。如果您允许对存储信息进行突变，则可以将其封装为一种“突变请求”，发送给模型这一部分的控制器，然后在此处执行。直接在Core Data对象上执行突变使您更难以调试更改的来源（数据导入步骤，在UI中进行编辑或其他操作），因为您只有一个入口点。</p><p>  If you follow the next law as well, then this law becomes very simple to enforce.</p><p>  如果您也遵循下一条法律，那么执行该法律将变得非常简单。 </p><p>  This is more along the lines of “general good advice” than anything specific to Core Data, but here it is:</p><p>这更像是“一般性好的建议”，而不是针对核心数据的任何建议，但实际上是：</p><p>  It’s generally a smart thing to hide the fact that you’re using Core Data from the rest of your app. This isn’t because you’re “ashamed” of it and need to obscure it (😉), but is more because of the fact that Core Data objects carry a decent amount of baggage with them that the rest of your app shouldn’t have to know about it (see earlier point about how objects bring along  the entire stack).</p><p>  从应用程序的其余部分隐藏您正在使用Core Data的事实通常是明智的。这并不是因为您对此感到“羞愧”并需要使其模糊不清（😉），而是因为Core Data对象随身携带了相当数量的行李，而应用程序的其余部分则不应必须了解这一点（请参阅前面的有关对象如何带入整个堆栈的知识）。</p><p>  When you pass managed objects or contexts around your app, the temptation to just reach inside an object and pull out the PSC or the MOM or whatever and use it becomes too high. Don’t do that. Avoid violating the  Law of Demeter and have a proper controller object that you can ask for what you need.</p><p>  当您在应用程序周围传递托管对象或上下文时，仅进入对象内部并拉出PSC或MOM或其他任何东西并使用它的诱惑就会变得过高。不要那样做避免违反Demeter法则，并拥有适当的控制器对象，您可以索要您需要的东西。</p><p>  You could hide a managed object behind a protocol, but that also makes it easy to forget the law about queue usage.</p><p>  您可以将托管对象隐藏在协议后面，但是这也很容易忘记有关队列使用的法律。</p><p>  In my opinion, you should keep the details of graph integrity and persistence to a confined part of your app, and data should only get out via custom-purpose  struct values (or something like them).</p><p>  我认为，应将图形完整性和持久性的详细信息保留在应用程序的受限部分，并且数据应仅通过自定义结构值（或类似的值）输出。</p><p>  As a rudimentary example of what this might look like, you could do something like this:</p><p>  作为一个大概的例子，您可以执行以下操作：</p><p>  protocol ManagedObjectInitializable { init(managedObject: NSManagedObject) } class ModelController { func fetchObjects&lt;T&gt;(completion: @escaping (Array&lt;T&gt;) -&gt; Void) 	 where T: ManagedObjectInitializable { ... } } struct Person: ManagedObjectInitializable { let firstName: String let lastName: String ... }</p><p>  协议ManagedObjectInitializable {init（managedObject：NSManagedObject）}类ModelController {func fetchObjects＆lt; T＆gt;（完成：@escaping（Array＆lt; T＆gt;）-＆gt;无效）其中T：ManagedObjectInitializable {...}}结构体：ManagedObjectInitializable {让firstName：字符串let lastName：字符串...} </p><p>  There are many different ways you could abstract out the details of Core Data, each with their pros and cons. But hiding Core Data like this from the rest of your app is a huge step along the road to proper encapsulation and “need-to-know”  information hiding.</p><p>您可以采用多种不同的方法来提取核心数据的详细信息，每种方法各有利弊。但是从应用程序的其余部分隐藏这样的Core Data是实现正确封装和“需要知道”信息隐藏的巨大一步。</p><p>  These days it’s pretty common to use apps that sync data between devices or are powered by a server backend. Very rarely do you find apps that produce and consume data that is  only local to the device.</p><p>  如今，使用在设备之间同步数据或由服务器后端提供支持的应用程序已经很普遍。在极少数情况下，您找不到会产生和使用仅设备本地数据的应用程序。</p><p>  Because of this, I find that it’s nice to use Core Data as a local cache. With Core Data hidden behind an abstraction layer, it’s easily integrated into a model layer from which I request data. The model layer looks in Core Data, and if the data is there, returns that. If it’s not, the data is fetched, saved in to Core Data, and then returned.</p><p>  因此，我发现将Core Data用作本地缓存非常好。由于Core Data隐藏在抽象层的后面，因此可以轻松地集成到我从中请求数据的模型层中。模型层在核心数据中查找，如果有数据，则返回该数据。如果不是，则将获取数据，将其保存到Core Data中，然后返回。</p><p>  Using Core Data in this manner means that if I ever have schema conflicts (ie, I’ve updated my app with a new schema version, and the persisted data from the old version is no longer compatible with the new version), I don’t really have any qualms about just nuking the entire persistent store and starting over. Of course, I  can go through process of performing a  migration and dealing with manually shuffling data around to be in the new format,  but I don’t have to. That’s huge and saves me a ton of work.</p><p>  以这种方式使用Core Data意味着，如果我遇到架构冲突（即，我已使用新的架构版本更新了我的应用，并且旧版本中的持久数据不再与新版本兼容），我不会实际上，对于否定整个持久性存储并重新开始没有任何疑虑。当然，我可以执行迁移过程并处理手动改组数据以采用新格式的过程，但是我不必这样做。那是巨大的，为我节省了大量的工作。</p><p>  There is a big “gotcha” with this approach though: Core Data works best when you have the  entire data set to query against. Because Core Data cares a lot about validation and graph integrity, it doesn’t work as well as a cache if parts of your data are missing. You can account for that in your schema, but that can also complicate how you use it. So if you’re going to use Core Data as a local cache, it’s best if you can use it against a whole part of your data set.</p><p>  但是，这种方法有一个很大的“陷阱”：当您要查询整个数据集时，核心数据最有效。由于Core Data非常关注验证和图形完整性，因此如果丢失部分数据，它就不能像缓存一样有效。您可以在模式中考虑到这一点，但是这也会使您的使用方式复杂化。因此，如果您打算将Core Data用作本地缓存，则最好将其用于整个数据集。</p><p> So, those are my “laws” for using Core Data. When I follow these laws, I almost  never have any problems with race conditions, corrupted data, “sadness like the death of optimism”, or data integrity. It all just works, and tends to work really, really well.</p><p> 因此，这些是我使用Core Data的“法律”。当我遵循这些法律时，我几乎不会遇到种族状况，数据损坏，“悲伤如乐观主义之死”或数据完整性等问题。这一切都可以正常工作，并且往往可以非常非常好地工作。</p><p>   A special thanks to  Cole Joplin,  Tom Harrington, and  Soroush Khanlou for proof-reading and providing feedback.</p><p>   特别感谢Cole Joplin，Tom Harrington和Soroush Khanlou的校对和提供反馈。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://davedelong.com/blog/2018/05/09/the-laws-of-core-data/">https://davedelong.com/blog/2018/05/09/the-laws-of-core-data/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/core/">#core</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>