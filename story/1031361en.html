<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>解析RISC-V程序集</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">解析RISC-V程序集</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-27 06:26:25</div><div class="page_narrow text-break page_content"><p>Recently, I needed to analyze some RISC-V assembly code for a research project and then calculate some basic metrics, but I couldn&#39;t find a suitable tool. Ok, I&#39;ll just grab a parser from one of the smaller open-source assemblers. This wasn&#39;t successful though since the ones I looked at use crude, regex-based parsers that don&#39;t maintain information about the structure.</p><p>最近，我需要为一个研究项目分析一些RISC-V汇编代码，然后计算一些基本指标，但我找不到合适的工具。好的，我将从一个较小的开放源码汇编器中获取一个解析器。这并不成功，因为我看到的那些使用粗糙的、基于正则表达式的解析器，这些解析器不维护有关结构的信息。</p><p> Not a problem, I&#39;ll implement my own! Let me just look up the grammar for RISC-V assembly... oh no, there isn&#39;t an official one?! Wait. The language itself isn&#39;t even standardized beyond the instruction set, and each major assembler supports different notations and features???</p><p>没问题，我会实现我自己的！让我查一下RISC-V汇编的语法...。哦，不，没有正式的吗？！等。除了指令集之外，语言本身甚至没有标准化，而且每个主要汇编语言都支持不同的符号和功能？</p><p>  Challenge accepted! My goal is to write a parser that supports the GNU assembler&#39;s (GAS) syntax.</p><p>接受挑战！我的目标是编写一个支持GNU汇编程序(GAS)语法的解析器。</p><p>  If you are looking for a hand-written lexer and parser for RISC-V assembly that builds a parse tree and does not have any third-party dependencies (e.g., ANTLR or Yacc), then this is for you. It could be handy in making your own linter, prettifier, or assembler for RISC-V. Alternatively, if you want a more in-depth tutorial on parsing, see the first part of my tutorial series:  Let&#39;s make a Teeny Tiny compiler.</p><p>如果您正在寻找用于RISC-V程序集的手写词法分析器和解析器，可以构建解析树，并且没有任何第三方依赖项(例如，ANTLR或Yacc)，那么这是为您准备的。在为RISC-V制作自己的短绒、美容剂或汇编器时，它可能会很方便。或者，如果您需要更深入的解析教程，请参阅我的教程系列的第一部分：让我们做一个Teeny Tiny编译器。</p><p> The source code for the parser can be found on  GitHub. If you want to know more about RISC-V assembly, see my colleague&#39;s  lecture notes.</p><p>解析器的源代码可以在GitHub上找到。如果你想了解更多关于RISC-V组件的知识，请看我同事的课堂讲稿。</p><p>  The core of most assembly languages is beautifully simple. A source file is composed of zero or more labels, instructions, directives, and comments. We can represent it in EBNF like so:</p><p>大多数汇编语言的核心都非常简单。源文件由零个或多个标签、指令、指令和注释组成。我们可以用EBNF表示它，如下所示：</p><p>  Such a language would be very easy to parse. At the start of each line, decide whether it is a label, an instruction, a directive, or a comment. Let&#39;s keep going with this and expand these terms:</p><p>这样的语言将非常容易解析。在每行的开头，确定它是标签、指令、指令还是注释。让我们继续这样做，并扩展这些术语：</p><p> program ::= {label | instruction | directive | comment}	label ::= symbol &#39;:&#39;instruction ::= symbol [symbol {&#39;,&#39; symbol}]directive ::= &#39;.&#39; symbol [symbol {&#39;,&#39; symbol}]</p><p>程序：：={Label|Instructive|Directive|Comment}标签：：=Symbol&#39；：&#39；指令：：=Symbol[Symbol{&#39；，&#39；Symbol}]指令：：=&#39；.&#39；Symbol[Symbol{&#39；，&#39；Symbol}]</p><p> Label is simple enough. An instruction is a symbol followed by zero or more operands that are comma separated. Here I am using symbol as a catch all. It can be a number, a register, an instruction, or a label. A directive is essentially the same as an instruction but it starts with a period.</p><p>标签很简单。指令是一个符号，后跟以逗号分隔的零个或多个操作数。在这里，我使用符号作为一个包罗万象的词。它可以是数字、寄存器、指令或标签。指令本质上与指令相同，但它以句点开头。</p><p> Are we ready to implement the parser yet? Not quite. Although this is almost enough for RISC-V assembly, it is still missing quite a few features. To name a few: labels can be on the same line as an instruction, values can have a leading positive or negative sign, and offsets can be specified for an operand.</p><p>我们准备好实现解析器了吗？不完全是。虽然这对于RISC-V组装来说几乎足够了，但它仍然缺少相当多的功能。仅举几例：标签可以与指令位于同一行，值可以具有前导正号或负号，并且可以为操作数指定偏移量。</p><p>  program ::= {[label] [directive | instruction] [comment] newline}label ::= symbol &#39;:&#39;directive ::= &#39;.&#39; symbol [[&#39;.&#39; | &#39;+&#39; | &#39;-&#39;] symbol {&#39;,&#39; [&#39;+&#39; | &#39;-&#39;] symbol}]instruction ::= symbol [operand {&#39;,&#39; operand}]operand ::= [&#39;+&#39; | &#39;-&#39;] (symbol &#39;(&#39; symbol &#39;)&#39; | symbol)# Lexer rules in regex-ish notation.newline ::= [\n\r]+comment ::= #[^\n\r]+symbol ::= ([a-zA-Z0-9](&#39;.&#39;?[a-zA-Z0-9])*) | (\&#34;(\\[^\n]|[^&#34;\n])*\&#34;)# Whitespace, commas, colons, and parentheses are token delimiters.# Spaces and tabs can be used interchangeably and consecutively.</p><p>程序：：={[Label][指令|指令][注释]newline}标签：：=Symbol&#39；：&#39；指令：：=&#39；.&#39；|&#39；+&#39；|&#39；-&#39；]Symbol{&#39；，&#39；[&#39；+&#39；|&#39；-&#39；]Symbol}]指令：：=Symbol[Operand{&#39；，&#39；Operand}]操作数：：=[&#39；+&#39；|&#39；-&#39；](Symbol&#39；(&#39；Symbol&#39；)&#39；|Symbol)#正则表示法的词法分析器规则。newline：：=[\n\r]+COMMENT：：=#[^\n\r]+Symbol：：=([a-Za-Z0-9](&#39；.&#39；？[A-Za-Z0-9])*)|(\&#34；(\\[^\n]|[^&#34；\n])*\&#34；)#空格、逗号、冒号和圆括号是标记分隔符。#空格和制表符可以互换和连续使用。</p><p> But wait! How do we know that an instruction or register was used properly? I decided to keep the grammar as minimal as possible and to verify such things later on. That means that this grammar will accept some code that is not allowed, but that in the next step we can prune out. For example, &#34;xor xor, xor, xor, xor&#34; will be parsed just fine, despite it not being legal RISC-V assembly. We can fix that.</p><p>但是等等！我们如何知道指令或寄存器是否正确使用？我决定尽量减少语法，并在以后验证这些内容。这意味着该语法将接受一些不允许的代码，但是在下一步我们可以删除。例如，&#34；xor xor，xor&34；可以很好地解析，尽管它不是合法的RISC-V程序集。我们可以解决这个问题。</p><p>  If you are interested in using the parser for your own project, there may be a few things you&#39;ll want to add. Namely, a  verification step, similar to a semantic analysis step in compilers, that checks some of the following things:</p><p>如果您对将解析器用于您自己的项目感兴趣，那么您可能需要添加一些东西。即，类似于编译器中的语义分析步骤的验证步骤，其检查以下内容中的一些：</p><p> Literal values are of correct form and size (e.g., hex or can be represented with 16 bits)</p><p>文字值的形式和大小正确(例如，十六进制或可以用16位表示)。</p><p> You would check these in the parser, by modifying the grammar functions,  Label(),  Directive(),  Instruction(), and  Operand(), to check the contents of the tokens.</p><p>您可以通过修改语法函数Label()、Directive()、Instruction()和Operand()在解析器中检查这些标记，以检查标记的内容。</p><p>  void Parser::Instruction() { NextToken(); // Is there at least one operand? if(!CheckToken(TokenType::Newline) &amp;&amp; !CheckToken(TokenType::Comment)) { Operand(); // Zero or more operands. while(CheckToken(TokenType::Comma)) { NextToken(); Operand(); } }}</p><p>Void Parser：：Instruction(){NextToken()；//是否至少有一个操作数？IF(！CheckToken(TokenType：：newline)&amp；&amp；！CheckToken(TokenType：：Comment)){Operand()；//零个或多个操作数。While(CheckToken(TokenType：：Comma)){NextToken()；Operand()；}</p><p>  void Parser::Instruction() { int numOperands = verifier-&gt;LookupInstruction(token-&gt;literal); if(numOperands == -1) { ReportError(&#34;Invalid instruction.&#34;); } NextToken(); // Is there at least one operand? int actNumOperands = 0; if(!CheckToken(TokenType::Newline) &amp;&amp; !CheckToken(TokenType::Comment)) { Operand(); actNumOperands++; // Zero or more operands. while(CheckToken(TokenType::Comma)) { NextToken(); Operand(); actNumOperands++; } // Verify correct number of operands. if(numOperands != actNumOperands) { ReportError(&#34;Incorrect number of operands.&#34;); } }}</p><p>Void Parser：：Instruction(){int numOperands=verifier-&gt；LookupInstruction(token-&gt；literal)；if(numOperands==-1){ReportError(&#34；Invalid Instruction.&#34；)；}NextToken()；//是否至少有一个操作数？Int actNumOperands=0；if(！CheckToken(TokenType：：Newline)&amp；&amp；！CheckToken(TokenType：：Comment)){Operand()；actNumOperands++；//零个或多个操作数。While(CheckToken(TokenType：：Comma)){NextToken()；Operand()；actNumOperands++；}//验证操作数是否正确。If(numOperands！=actNumOperands){ReportError(&#34；操作数不正确。&#34；)；}。</p><p> Voila! The instructions and number of operands are now verified. To actually do this, I recommend implementing a  Verifier class that has functions for looking up if an instruction/directive exists and the number and format of operands for each, along with functions for verifying literals, registers, and labels.</p><p>瞧啊！现在验证了指令和操作数的数量。要真正做到这一点，我建议实现一个Verizer类，该类具有查找指令/指令是否存在以及每个指令的操作数的数量和格式的函数，以及用于验证文字、寄存器和标签的函数。</p><p> Similarly, you can add an  emitter step if you were building an assembler. In this scenario, you would look up the corresponding binary representation of each instruction and operand, emitting those to a file as you parse. You can see how a compiler does this in the emitting portion of my  Let&#39;s make a Teeny Tiny compiler tutorial.</p><p>同样，如果您正在构建汇编器，则可以添加发射器步骤。在此方案中，您将查找每条指令和操作数的相应二进制表示形式，并在解析时将其发送到文件。您可以在我的let‘s make a Teeny Tiny编译器教程的发出部分看到编译器是如何做到这一点的。</p><p>  A notable feature that cannot be parsed with this parser is math expressions. Luckily, this is a fairly easy thing to add! I have previously written a tutorial on parsing that covers math expressions. See part 1 of  Let&#39;s make a Teeny Tiny compiler. The GNU assembler supports two prefix operators, - and ~ for negation and complementation, and these binary operators from highest precedence to lowest: *, /, %, &lt;, &lt;&lt;, &gt;, &gt;&gt;, |, &amp;, ^, !, +, -.</p><p>这个解析器不能解析的一个值得注意的特性是数学表达式。幸运的是，这是一个相当容易添加的东西！我以前写过一篇关于解析的教程，涵盖了数学表达式。请参阅“让我们做一个小小的编译器”的第1部分。GNU汇编器支持两个前缀运算符-和~用于否定和互补，并且这些二元运算符从最高优先级到最低优先级依次为：*、/、%、&lt；、&lt；、&gt；、&gt；&gt；、|、&amp；、^、！、+、-。</p><p>  expression ::= bitwise {( &#34;-&#34; | &#34;+&#34; ) bitwise}bitwise ::= term {( &#39;|&#39; | &#39;&amp;&#39; |&#39;^&#39; ) term}term ::= unary {( &#34;/&#34; | &#34;*&#34; ) unary}unary ::= [&#34;+&#34; | &#34;-&#34;] symbol</p><p>表达式：：=按位{(&#34；-&#34；|&#34；+&#34；)按位}按位：=Term{(&#39；|&#39；|&#39；&amp；&#39；|&#39；^&#39；)Term}Term：：=一元{(&#34；/&#34；|&#34；*&#34；)一元}符号：：=[&#34；+&#34；|&#34；-&#34；]符号。</p><p> Preprocessor features (i.e., #include and #define) and multi-line comments are left as an exercise to the reader... 🙂</p><p>预处理器特性(即#include和#define)和多行注释留给读者作为练习……。🙂。</p><p>  The core of assemblers really are quite simple. They do little more than string substitution, so parsing should be trivial. Assembly languages aren&#39;t even recursive! You just need to replace instruction mnemonics and operands with their respective binary representation. However, the mainstream assemblers allow constructs that make parsing a little more complicated, plus assembly languages are not standardized. Despite all this, this article should prove that these problems can be solved if you take them step by step.</p><p>汇编器的核心确实非常简单。它们只做字符串替换，所以解析应该很简单。汇编语言甚至不是递归的！您只需将指令助记符和操作数替换为它们各自的二进制表示形式。然而，主流汇编器允许构造使解析稍微复杂一些，而且汇编语言没有标准化。尽管如此，本文应该证明，如果你循序渐进，这些问题是可以解决的。</p><p>  Hopefully this parser can help you with your RISC-V project. If you use it, shoot me an email and let me know about your project! You can find the source code on  GitHub.</p><p>希望这个解析器可以帮助您处理RISC-V项目。如果你使用它，给我发一封电子邮件，让我知道你的项目！您可以在GitHub上找到源代码。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://web.eecs.utk.edu/~azh/blog/parsingriscv.html">https://web.eecs.utk.edu/~azh/blog/parsingriscv.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031352.html"><img src="http://img2.diglog.com/img/2020/10/thumb_5605bf4ec42c70945d13b66251f27051.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031352.html">论本地应用程序</a></div><span class="my_story_list_date">2020-10-27 6:23</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031336.html"><img src="http://img2.diglog.com/img/2020/10/thumb_1a65df924f8779c225ea2e11e4155568.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031336.html">使用Reaction Native for Web在Web上运行您的Reaction Native应用程序</a></div><span class="my_story_list_date">2020-10-27 6:19</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031283.html"><img src="http://img2.diglog.com/img/2020/10/thumb_2cb6bfd97ab3ee538969ec06516b4c0a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031283.html">UEFI-rs：用Rust编写UEFI应用程序</a></div><span class="my_story_list_date">2020-10-27 0:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031259.html"><img src="http://img2.diglog.com/img/2020/10/thumb_895c4bbecd9ceab3d056ef918cb36859.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031259.html">
YouTube更新了其移动应用程序，增加了新手势、视频章节列表等功能</a></div><span class="my_story_list_date">2020-10-27 0:2</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>