<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>关于Fexprs和Def宏</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">关于Fexprs和Def宏</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-30 02:00:49</div><div class="page_narrow text-break page_content"><p>wrote:&gt; Wikipedia&#39;s page on macros had really no history on it at all. I added some, including&gt; references to Kohlbecker and Clinger. =C2=A0If anyone wants to make it better (or correct&gt; the terrible guesses I made about FEXPRs), take a look at it:&gt;&gt; http://en.wikipedia.org/wiki/Macro_%28computer_science%29#Lisp_.2F_S-expression_macros``The earliest Lisp macros took the form of FEXPRs, function-likeoperators whose inputs were not the values computed by the arguments but rather thesyntactic forms of the arguments, and whose output were syntactic fragments to be used in place of the FEXPR&#39;s use.&#39;&#39;The arguments to a FEXPR were definitely *not* the syntactic forms,but were insteadthe literal list structure of the source code as returned by `read&#39;.The `output&#39; of a FEXPRis used as the return value of the expression that invoked the FEXPR.The differenceis subtle but critical. It hinges on the implementation details of LISP I.LISP I was not simply an implementation of a language definition. It was animplementation of a *meta-circular* language definition. In a language witha meta-circular component, we can partition functions into two classes:those that are `normal&#39; and those that are `level crossing&#39;. In the LISP Iimplementation, a name could be bound to an EXPR or SUBR, whichis simply a first-class procedure (the difference being simply that anEXPR was a procedure implemented via a recursive evaluation whilea SUBR was a procedure implemented by direct execution in theunderlying platform (IBM 704 assembly). A SUBR was either a primitiveor a chunk of compiled code.) But there were analogous level-crossingversions of these called FEXPRs and FSUBRs. A FEXPR was a level-crossingprocedure implemented via recursive evaluation and an FSUBR was alevel-crossing procedure implemented by direct execution.But FEXPRs and FSUBRs were not meta-syntactic operators thatworked on programs via reification and reflection, but rathermeta-implementationoperators that relied on the meta-circular definition of EVAL (that is,a FEXPR or FSUBR runs at the semantic level of meta-EVAL, not EVAL.)This distinction was not lost on McCarthy et al. FEXPRs were *designed*around the fact that the language had a meta-circular definition that wasimplemented via recursive descent of list structure. Most, if not all, ofthe people agitating for the reconsideration of FEXPRs do not understand thisdistinction. A macro is a program that performs rewrites at a syntactic level.It is abstracted away from the concrete representation of the program itoperates on. A FEXPR, on the other hand, is a program that is deliberately*not* abstracted away from the concrete representation. It is as intimatelytied to that representation as EVAL.&gt; In later Lisps, FEXPRs were replaced by DEFMACRO, a system that&gt; allowed programmers to specify source-to-source transformations that&gt; were applied before the program is run.FEXPRs (and FSUBRs) weren&#39;t actually `replaced&#39;. FEXPRs andFSUBRs were never intended as source-&gt;source transforms. The macrofacility was added as a separate, unrelated feature. The problem withFEXPRs is that they are far too powerful and place too many constraintson the implementation. It was discovered that certain idiomatic uses ofFEXPRs were `safe&#39; (with well-defined, intuitive semantics) whereas otheruses were `unsafe&#39; (with vague semantics that rely on the existence ofmeta-circular fixed points (yikes!) and were difficult to reason about).One cannot effectively program with `unsafe&#39; FEXPRs, so they fellout of favor really quickly. `Safe&#39; FEXPRs turn out to be the subsetof FEXPRs that can be understood as source-&gt;source translations.Since macros provided that same power without the attendant problems,they quickly became the preferred way to meta-program. With FEXPRsno longer necessary, meta-circularity is no longer necessary andEVAL no longer needs to operate on list structure.Another way to look at it is this: the denotational semantics of alanguage have a function `Big-E&#39; that maps `expressions&#39; to `values&#39;.If we wish, we can define a function Big-P (for parse) that maps`list structure&#39; to `expressions&#39; and Big-P^-1 that maps them back.LISP I defines Big-E[[   ]] =3D apply( Big-E[[ car (Big-P^-1 [[ ]])]], map (lambda (arg) Big-P^-1 [[ eval arg ]]) (cdr (Big-P^-1 [[ ]]))(or something like that). The point is that the semantic definition ofBig-E is defined via the isomorphism between code and list structure andis inextricably linked to it. A FEXPR manipulates objects on both sidesof the isomorphism (yuck), so Big-P and Big-P^-1 cannot be factored outof the semantics. A macro, however, only manipulates objects on oneside, allowing Big-P to be factored out and hidden as a syntactic transform.This greatly simplifies the definition of Big-E (in essence, it allows us todefine Big-E over a simple Scott domain rather than a reflective one).--=20~jrm</p><p>写道：维基百科关于宏的页面实际上根本没有关于它的历史。我添加了一些内容，包括&gt；对科尔贝克和克林格的引用。=C2=A0如果有人想让它变得更好(或纠正我对FEXPR的可怕猜测)，请看一看：&gt；&gt；http://en.wikipedia.org/wiki/Macro_%28computer_science%29#Lisp_.2F_S-expression_macros``The最早的Lisp宏采用FEXPR的形式，这是一种类似函数的运算符，其输入不是参数计算的值，而是参数的语法形式，其输出是语法片段，将用来代替FEXPR的使用。&#39；&#39；FEXPR的参数绝对是语法形式，而不是`read&#39；；返回的源代码的文字列表结构。FEXPR的‘output’用作调用FEXPR的表达式的返回值。差别很细微，但很关键。这取决于LISP I的实现细节。LISP I不是简单的语言定义的实现。它是一种“元循环”语言定义的实现。在具有元循环成分的语言中，我们可以将函数划分为两类：“正常”函数和“水平交叉”函数。在LISP I实现中，名称可以绑定到EXPR或SUBR，这只是一个一级过程(区别很简单，EXPR是通过递归计算实现的过程，而SUBR是通过在底层平台(IBM704汇编)中直接执行实现的过程)。SUBR可以是原始代码，也可以是编译后的代码块。)。但也有类似的跨级版本，称为FEXPR和FSUBR。FEXPR是通过递归求值实现的跨层过程，FSUBR是通过直接执行实现的跨层过程，但是FEXPR和FSUBR不是通过物化和反射在程序上工作的元句法运算符，而是依赖于EVAL的元循环定义的元实现运算符(即，FEXPR或FSUBR运行在元EVAL的语义层，而不是EVAL)。McCarthy等人并没有忽视这一区别。FEXPR是围绕这样一个事实“设计”的，即该语言有一个通过递归下降列表结构实现的元循环定义。大多数(如果不是全部)鼓动重新考虑FEXPR的人都不理解这一区别。宏是在语法级别执行重写的程序，它是从它所操作的程序的具体表示中抽象出来的。另一方面，FEXPR是一个故意“不”从具体表示中抽象出来的程序。在后来Lisp中，FEXPR被DEFMACRO取代，DEFMACRO是一种允许程序员指定在程序运行之前应用的源到源转换的系统。FEXPR(和FSUBR)实际上并没有被替换。FEXPR和FSUBR从未打算作为源-源转换。宏工具被添加为一个独立的、不相关的功能。FEXPR的问题在于它们太强大了，并且对实现施加了太多约束。研究发现，FEXPR的某些惯用用法是“安全的”(具有明确的、直观的语义)，而另一些用法则是“不安全的”(具有模糊的语义，依赖于亚循环不动点(YIKS！)的存在。)。一个人不能用“不安全的FEXPR”进行有效的编程，所以他们很快就失宠了。‘Safe&#39；FEXPR原来是FEXPR的子集，可以理解为源-源翻译。由于宏提供了同样的功能而没有随之而来的问题，它们很快就成为元程序的首选方式。有了FEXPR，亚循环就不再必要了，EVAL也不再需要对列表结构进行操作。另一种看待它的方式是这样的：一种语言的外指语义有一个函数`Big-E&39；将‘表达式’映射到‘值’。如果我们愿意，我们可以定义一个函数Big-P(用于解析)，该函数将`列表结构‘映射到’表达式‘。如果我们愿意，我们可以定义一个将`列表结构映射到`表达式’的函数Big-P(用于解析)。LISP I定义Big-E[[]]=3D Apply(Big-E[[Car(Big-P^-1[[]])]]，map(lambda(Arg)Big-P^-1[[eval Arg]])(Cdr(Big-P^-1[[]])(或类似的东西)。重点在于，Big-E的语义定义是通过代码和列表结构之间的同构来定义的，并且与之有着千丝万缕的联系。FEXPR操作同构(讨厌)两侧的对象，因此不能将Big-P和Big-P^-1从语义中分离出来。然而，宏只在一侧操作对象，允许将Big-P作为句法转换进行分解和隐藏。这大大简化了Big-E的定义(本质上，它允许我们在简单的Scott域上定义Big-E，而不是在反射域上定义Big-E)。--=20~JRM</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.brinckerhoff.org/scraps/joe-marshall-on-FEXPRS-and-DEFMACRO.txt">https://www.brinckerhoff.org/scraps/joe-marshall-on-FEXPRS-and-DEFMACRO.txt</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/def/">#def</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fexprs/">#fexprs</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fexpr/">#fexpr</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>