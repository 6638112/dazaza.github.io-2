<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>C从怪异机器上获得的可移植性教训C Portability Lessons from Weird Machines</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">C Portability Lessons from Weird Machines<br/>C从怪异机器上获得的可移植性教训</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-22 02:59:28</div><div class="page_narrow text-break page_content"><p>In this article we’ll go on a journey from 4-bit microcontrollers to room-sized mainframes and learn how porting C to each of them helped people separate the essence of the language from the environment of its birth. I’ve found technical manuals and videos for this article to help bring each computer to life.</p><p>在本文中，我们将继续从4位微控制器到房间大小的大型机的旅程，并学习如何将C移植到每一个大型机上，帮助人们将语言的本质与其诞生的环境区分开来。我找到了这篇文章的技术手册和视频，帮助每台电脑焕然一新。</p><p> It’s amazing that, by carefully writing portable ANSI C code and sticking to standard library functions, you can create a program that will compile and work without modification on almost any of these weird systems.</p><p>令人惊讶的是，通过仔细编写可移植的ANSI C代码并坚持使用标准库函数，您可以创建一个程序，在几乎所有这些奇怪的系统上编译和工作，而无需修改。</p><p>  I hope that being exposed to these examples will help you write code more portably, and dispel the belief that current computers with their multiple cores, cache hierarchy, and pipelining, are somehow too alien for C. A language tough enough to handle the diversity of old machines is tough enough to handle today’s relatively homogeneous CPUs.</p><p>我希望接触到这些例子将有助于您更方便地编写代码，并消除这样的信念，即具有多核、缓存层次结构和流水线的当前计算机在某种程度上对C来说太陌生了。一种足以处理旧计算机多样性的语言，足以处理当今相对同质的CPU。</p><p> To prepare this article I worked backward from the book “Portable C” (by Henry Rabinowitz), searching for architectures that illustrate each of the pitfalls he points out. You should read the book for a great explanation of what the author calls “C-World,” a semantic model of the execution of a C program.</p><p>为了准备这篇文章，我从亨利·拉比诺维茨（Henry Rabinowitz）的《便携式C》（Portable C）一书中回顾，寻找能够说明他指出的每一个缺陷的体系结构。你应该阅读这本书，了解作者所说的“C-World”，一个C程序执行的语义模型。</p><p>  While this video doesn’t show the true computer in operation, you can still see the shape of one of the control panels. The gentleman in the video has quixotic fascination with it.</p><p>虽然这段视频没有显示运行中的真实计算机，但您仍然可以看到其中一个控制面板的形状。视频中的这位绅士对它有着不切实际的魅力。</p><p>   The first unusual thing about the architecture is its word size. You may be familiar with datatypes having powers-of-two bit sizes, but these Unisys series went with multiples of 9! The word size is 18 bits, and the C compiler for the platform uses:</p><p>该建筑的第一个不寻常之处是它的字数。您可能熟悉具有两位大小幂的数据类型，但这些Unisys系列使用的是9的倍数！字长为18位，平台的C编译器使用：</p><p>   Just to make matters more interesting, the oddly sized integers use ones’ complement binary arithmetic. That’s right, in this system there are distinct values for positive and negative zero. (CDC computers also used ones’ complement.)</p><p>为了让事情变得更有趣，奇怪大小的整数使用1的补码二进制算法。没错，在这个系统中，正零和负零有不同的值。（CDC的计算机也使用了一个的补充。）</p><p> The thirty-six bits integers can hold a lot, but guess what they can’t hold on this architecture? Pointer values. Section 8.6.1 of the  C manaul for the Unisys 2200 says:</p><p>36位整数可以保存很多数据，但是猜猜在这个体系结构中它们不能保存什么？指针值。Unisys 2200的C manaul第8.6.1节规定：</p><p> A pointer in UC cannot be treated as an integer. A UC pointer is a two-word structure with the base virtual address (VA) of a bank in the first word and a bit-word pointer in the second word. The bit-word pointer is necessary since the 2200 hardware does not have byte pointers; the basic pointer in the 2200 hardware is a word (36-bit) VA pointer that can only point to words. The bit-word portion of the UC pointer has a bit offset in the first 6 bits of the word and a word offset in the lower 24 bits of the word. If you convert (cast) a UC pointer to a 36-bit integer (int, long, or unsigned), the bit offset is lost. Converting it back to a C pointer results in it pointing to a word boundary. If you add 1 to the integer before converting it back to a pointer, the pointer points to the next word, not the next byte. A 36-bit integer is not capable of holding all the information in a UC pointer.</p><p>UC中的指针不能视为整数。UC指针是两个字的结构，第一个字是银行的基虚拟地址（VA），第二个字是位字指针。由于2200硬件没有字节指针，所以位字指针是必需的；2200硬件中的基本指针是一个字（36位）VA指针，只能指向字。UC指针的位字部分在字的前6位有位偏移，在字的下24位有字偏移。如果将UC指针转换（强制转换）为36位整数（int、long或unsigned），则位偏移量将丢失。将其转换回C指针会导致它指向单词边界。如果在将整数转换回指针之前将其加1，指针将指向下一个单词，而不是下一个字节。36位整数不能保存UC指针中的所有信息。</p><p> If you think regular pointers are demanding, section 8.6.2 says that function pointer requires a full eight words!</p><p>如果您认为常规指针要求很高，那么第8.6.2节说函数指针需要整整八个单词！</p><p> A function pointer is 8 words long and has a completely different format. Only two words out of the 8-word function pointer are actually (currently) used by UC-generated code. (The second and third words.) (More of the words are used by other UCS languages such as FORTRAN and COBOL.) You can cast UC data pointers to function pointers and function pointers to data pointers and not lose any information. The two words that hold information are simply moved back and forth.</p><p>函数指针的长度为8个字，格式完全不同。UC生成的代码实际上（当前）只使用了8字函数指针中的两个字。（第二和第三个词。）（其他UCS语言如FORTRAN和COBOL使用了更多的单词。）可以将UC数据指针转换为函数指针，将函数指针转换为数据指针，并且不会丢失任何信息。包含信息的两个单词只是来回移动。</p><p> Finally, if you think the Unisys is confined to the pages of history, you’re mostly right, but not entirely. They still manufacture and sell the “ClearPath Dorado” which uses the 2200 architecture.</p><p>最后，如果你认为Unisys仅限于历史，你基本上是对的，但并非完全正确。他们仍在制造和销售使用2200体系结构的“ClearPath Dorado”。</p><p>    Like the previous Unisys machine, the ClearPath has an unusual word size. Here are the integral data type sizes for the ClearPath  C compiler:</p><p>与之前的Unisys机器一样，ClearPath具有不同寻常的字长。以下是ClearPath C编译器的整数数据类型大小：</p><p>  This machine uses neither twos’ complement nor ones’ complement signed arithmetic – it uses sign-magnitude form instead.</p><p>这台机器既不使用2的补码，也不使用1的补码有符号算术，而是使用符号大小形式。</p><p>   A reliable old machine that had a devoted community. Fairly normal architecture, except it is big endian, unlike most computers nowadays. The char datatype is unsigned by default. Finally, the standard compiler for this architecture guarantees that function arguments are evaluated from left to right.</p><p>一台可靠的旧机器，拥有一个忠诚的社区。与当今大多数计算机不同的是，这是一种相当普通的体系结构。默认情况下，char数据类型是无符号的。最后，这种体系结构的标准编译器保证从左到右计算函数参数。</p><p>    C is so portable that someone wrote a compiler –  Symbolics C – for a computer running Lisp natively. Targeting the Symbolics Lisp machine required some creativity. For instance, a pointer is represented as a pair consisting of a reference to a list and a numerical offset into the list. In particular, the NULL pointer is  &lt;NIL, 0&gt;, basically a NIL list with no offset. Certainly  not a bitwise zero integral value.</p><p>C的可移植性如此之强，以至于有人为一台本机运行Lisp的计算机编写了一个编译器——Symbolics C。瞄准Symbolics Lisp机器需要一些创造力。例如，指针被表示为一对，由对列表的引用和列表中的数字偏移组成。具体来说，空指针是&lt；零，0&gt；，基本上是一个没有偏移量的零列表。当然不是按位零整数值。</p><p> The word size is 16 bits. There are no alignment requirements for data, although instructions must be on a 16-bit boundary. Here are the sizes of integer types defined by the compiler on the machine:</p><p>字长为16位。虽然指令必须位于16位边界上，但对数据没有对齐要求。以下是计算机上编译器定义的整数类型的大小：</p><p>     This processor found its way into many game consoles, embedded systems, and printers. It’s a pretty normal architecture, though big endian with a compiler default of unsigned chars. Also pointers (32 bits) are a different size than ints (16 bits).</p><p>这种处理器被应用到许多游戏机、嵌入式系统和打印机中。这是一个非常正常的体系结构，尽管big-endian的编译器默认为无符号字符。指针（32位）的大小也不同于整数（16位）。</p><p> One significant quirk is that the machine is very sensitive to data alignment. The processor had two-byte granularity and lacked the circuitry to cope with unaligned addresses. When presented with such an address, the processor would throw an exception. The original Mac (also based on the 68000) would usually demand the user restart the machine after an alignment error. (Similarly, some Sparc machines would raise a SIGBUS exception for alignment problems.)</p><p>一个重要的怪癖是机器对数据对齐非常敏感。处理器有两个字节的粒度，缺乏处理未对齐地址的电路。当出现这样一个地址时，处理器会抛出一个异常。最初的Mac（也基于68000）通常会要求用户在校准错误后重新启动机器。（类似地，一些Sparc机器会因对齐问题引发SIGBUS异常。）</p><p>    This machine uses a different numbering scheme for character- and integer-pointers. The same location in memory must be referred to by different addresses depending on the pointer type. A cast between  char* and  int* actually changes the address inside the pointer. Chris Torek  recounts the details.</p><p>这台机器对字符和整数指针使用不同的编号方案。内存中的同一位置必须由不同的地址引用，具体取决于指针类型。char*和int*之间的转换实际上会改变指针内的地址。克里斯·托雷克讲述了细节。</p><p>  This machine provides another cautionary tale about trying to manipulate pointer values as if they were integers. On this architecture char* or void* are secretly word pointers with an offset stored in the three unused higher-order bits. Thus incrementing char* as an integer value would move to the next word but keep the same offset.</p><p>这台机器提供了另一个警告故事，关于试图像处理整数一样处理指针值。在这种架构中，char*或void*是秘密的字指针，其偏移量存储在三个未使用的高阶位中。因此，将char*作为整数值递增将移动到下一个单词，但保持相同的偏移量。</p><p>    Notable for using a NULL pointer address that is not bitwise zero. In particular it uses segment 07777, offset 0 for the null pointer. (Some Honeywell-Bull mainframes use 06000 for the NULL pointer value, which is another example of non-zero NULL.)</p><p>值得注意的是使用了非位零的空指针地址。特别是，它使用段07777，空指针的偏移量为0。（一些霍尼韦尔公牛大型机使用06000作为NULL指针值，这是非零NULL的另一个例子。）</p><p>    The DECstation uses the R3000 processor. It could be switched into either little- or big-endian mode at the programmer’s discretion. One quirk is that the processor raises an exception for signed integer overflow, unlike many other processors which silently wrap to negative values. Allowing a signed integer to overflow (in a loop for instance), is thus not portable.</p><p>DECstation使用R3000处理器。它可以由程序员自行决定切换到小端或大端模式。一个怪癖是，处理器会引发有符号整数溢出异常，这与许多其他处理器不同，它们会自动换行为负值。因此，允许有符号整数溢出（例如在循环中）是不可移植的。</p><p>    This computer is actually the origin of the ARM architecture which we commonly find in mobile phones and Arduinos. The Acorn in particular uses ARM2, and has a 32-bit data bus and a 26-bit address space. Like the Motorola 68000, the ARM2 raises a SIGBUS exception for unaligned memory access. (Note that the Arduino is an instance of a compiler still using 16-bit ints.)</p><p>这台计算机实际上是ARM架构的起源，我们通常在手机和Arduinos中找到这种架构。Acorn特别使用ARM2，具有32位数据总线和26位地址空间。与摩托罗拉68000一样，ARM2为未对齐的内存访问引发了SIGBUS异常。（请注意，Arduino是仍然使用16位整数的编译器的一个实例。）</p><p>    Everyone who writes about programming the Intel 286 says what a pain its segmented memory architecture was. Each memory segment can address up to 64 Kb, which is the largest contiguous region of memory that C could allocate per data object. (Thus size_t is smaller than unsigned int in this architecture.)</p><p>每一位写英特尔286编程的人都说它的分段内存架构是多么痛苦。每个内存段的地址可达64KB，这是C可以为每个数据对象分配的最大连续内存区域。（因此，在这种体系结构中，size_t小于unsigned int。）</p><p> Because the full address of any word in memory was specified by a segment and offset, there are 4096 ways of referring to it by some combination of the two. (For instance address 0x1234 can be referenced as 0123:0004, 0122:0014, etc.) Also variables declared next to one another may live in different segments, far apart in memory. This breaks some highly inadvisable tricks people used, like zeroing out a block of several variables by memset’ing the whole memory range between their addresses.</p><p>因为内存中任何单词的完整地址都是由一个段和偏移量指定的，所以有4096种方法可以通过两者的某种组合来引用它。（例如，地址0x1234可以引用为0123:0004、0122:0014等）另外，相邻声明的变量可能位于不同的段中，在内存中相距很远。这打破了人们使用的一些非常不可取的伎俩，比如通过记忆设置地址之间的整个内存范围来将多个变量块归零。</p><p> Despite this awkwardness, the personal computer was hot, and as of 1983 Byte Magazine (Vol 8, Issue 8) identified that there were nine different C compilers for the IBM PC! I found the  manual for one of them, Lattice C. It’s the same compiler used on other IBM products such as the System 370.</p><p>尽管有这种尴尬，个人电脑还是很热，到1983年字节杂志（第8卷，第8期）发现IBM PC有九种不同的C编译器！我找到了其中一款产品Lattice C的手册。它与IBM其他产品（如System 370）上使用的编译器相同。</p><p> In Lattice C both short and int are 16 bits, but long is 32. Char is signed by default, and of course the x86 is little endian.</p><p>在晶格C中，short和int都是16位，但long是32位。默认情况下，Char是有符号的，当然x86是little endian。</p><p>  Sticking with the theme of memory complications, enter the 8051. It’s a microcontroller that uses a “Harvard architecture.” This means it communicates with different types of memory attached to the same system. It uses word-oriented addressing for the ROM space and byte-oriented addressing for the RAM space. It needs differently sized pointers for each.</p><p>按照记忆并发症的主题，进入8051。它是一个微控制器，采用“哈佛体系结构”这意味着它与连接到同一系统的不同类型的内存进行通信。它对ROM空间使用面向字的寻址，对RAM空间使用面向字节的寻址。它需要不同大小的指针。</p><p> Many addresses are ambiguous, and could meaningfully point to either the RAM or ROM bank. 8051 compilers such as  Crossware use a slightly larger “generic” pointer which tags the memory class in its high byte to resolve the ambiguity.</p><p>许多地址模棱两可，可能有意义地指向RAM或ROM库。Crossware等8051编译器使用稍大的“通用”指针，将内存类标记为高位字节，以解决歧义。</p><p>    The Saturn family are  4-bit microprocessors developed by Hewlett-Packard in the 1980s for programmable scientific calculators and microcomputers. The video above shows the HP-71B calculator, which is really more of a general purpose computer in strange packaging. You load bulk data into it by zipping a magnetic band through some kind of a reader slot.</p><p>Saturn系列是Hewlett-Packard在20世纪80年代为可编程科学计算器和微型计算机开发的4位微处理器。上面的视频显示了HP-71B计算器，它实际上更像是一台包装奇特的通用计算机。你可以通过某种读卡器插槽压缩一条磁条，将大量数据加载到其中。</p><p> The Saturn processor doesn’t have hardware instructions to do signed arithmetic. That has to be emulated using combinations of other assembly instructions. Thus unsigned number operations are more efficient. No surprise that char defaults to being unsigned.</p><p>土星处理器没有硬件指令来执行有符号算术。必须使用其他汇编指令的组合来模拟。因此，无符号数运算更有效。char默认为未签名也就不足为奇了。</p><p> The memory is interesting. Its addresses are nibble-based, and can address 1M nibbles = 512Kb. Pointers are 20-bits, but stored as 32-bits.  Saturn C datatypes are pretty normal:</p><p>记忆很有趣。它的地址是基于半字节的，可以寻址1M半字节=512Kb。指针为20位，但存储为32位。土星C数据类型非常正常：</p><p>     This was one of the first low-cost 8-bit microprocessors, and it found its way into all kinds of systems including the Apple II, Commodore 64, and Nintendo Entertainment System. This processor is downright hostile to C compilers. Check out the crazy  optimization suggestions for the CC65 compiler.</p><p>这是最早的低成本8位微处理器之一，它被用于各种系统，包括苹果II、Commodore 64和任天堂娱乐系统。这个处理器完全不适合C编译器。查看CC65编译器的疯狂优化建议。</p><p>  There is no multiply or divide operation in the assembly, it has to be emulated with other instructions.</p><p>程序集中没有乘法或除法操作，必须与其他指令一起模拟。</p><p> Accessing any address higher than the “zero page” (0x0 to 0xFF) causes a performance penalty.</p><p>访问任何高于“零页”（0x0到0xFF）的地址都会导致性能下降。</p><p>   However it accesses its memory in one cycle, so a programmer can use the zero page as a pool of 256 8-bit registers.</p><p>然而，它在一个周期内访问内存，因此程序员可以使用零页作为256个8位寄存器的池。</p><p> The 6502 helps reveal the edge of portability, the place where C’s “luxuries” are too costly.</p><p>6502有助于揭示便携性的优势，即C的“奢侈品”过于昂贵的地方。</p><p>    The C home planet. Not much to say about it, because things work smoothly. The real surprises happened when porting PDP code to other machines. Pointers of all types and integers can be interchanged without casting.</p><p>C星球的家园。没什么好说的，因为事情进展顺利。真正的惊喜发生在将PDP代码移植到其他机器上时。所有类型和整数的指针都可以在不强制转换的情况下互换。</p><p> One strange thing about this machine is that whereas 16-bit words are stored in little endian, 32-bit long ints use a weird mixed endian format. The four bytes in the string “Unix” when stored in the PDP-11 are arranged as “nUxi” if interpreted as big endian. In fact that scrambled string itself resulted when porting code from the PDP to a big endian machine.</p><p>这台机器的一个奇怪之处是，虽然16位的字是以小尾端存储的，但32位长的整数使用奇怪的混合尾端格式。当存储在PDP-11中时，字符串“Unix”中的四个字节如果被解释为big-endian，则被安排为“nUxi”。事实上，当将代码从PDP移植到big-endian机器时，会产生加扰字符串本身。</p><p>    The VAX is like a 32-bit PDP. It’s the next machine in PDP evolution. People enjoyed coding for the VAX with its nice flat memory and uniform pointers of all types. People liked it so much that the term “VAXocentric” referred to sloppy coding by those who got too comfortable with the architecture and who didn’t bother to learn how other computers differed.</p><p>VAX就像一个32位的PDP。这是PDP进化中的下一台机器。人们喜欢为VAX编写代码，因为它有漂亮的扁平内存和各种类型的统一指针。人们非常喜欢它，以至于“VAXocentric”一词指的是那些对体系结构太过熟悉，又懒得去了解其他计算机的不同之处的人的草率编码。</p><p> The assembly for x86-64 looks externally similar to VAX, and people originally believed VAX would outlast Intel. This proved incorrect, as the “attack of the micros” destroyed the mainframe and minicomputer markets.</p><p>x86-64的汇编在外观上与VAX相似，人们最初认为VAX会比英特尔更持久。事实证明，这是不正确的，因为“微型计算机攻击”摧毁了大型机和小型计算机市场。</p><p>   Programs run faster with data aligned properly, but there is no strict alignment requirement, unlike previous architectures such as the IBM 360, PDP-11, Interdata 8/32 etc. Size and alignment attributes are logically independent. The VAX-11 C compiler aligns all the basic data types on address boundaries which are multiples of the size of each type.</p><p>与IBM 360、PDP-11、Interdata 8/32等以前的体系结构不同，程序在正确对齐数据的情况下运行得更快，但没有严格的对齐要求。大小和对齐属性在逻辑上是独立的。VAX-11 C编译器将地址边界上的所有基本数据类型对齐，地址边界是每种类型大小的倍数。</p><p> Other facts: the VAX C compiler doesn’t guarantee left-to-right evaluation of function arguments. Chars are signed by default. The PDP was OK with division by zero and returned the dividend, but VAX causes an unmaskable trap.</p><p>其他事实：VAX C编译器不能保证从左到右计算函数参数。字符是默认签名的。PDP接受零除法并返回股息，但VAX会导致无法掩盖的陷阱。</p><p> Bell Labs wrote an interesting  report about porting programs from the PDP to VAX, and some of their recommendations were adopted by ANSI C.</p><p>贝尔实验室写了一篇关于将程序从PDP移植到VAX的有趣报告，他们的一些建议被ANSI C采纳。</p><p>  If these digital delectations make you want to learn more about writing portable code, then the best place to learn is in one of the excellent books on the topic. The one by Henry Rabinowitz mentioned earlier is great, as is another by Mark Horton. Good books are another strength of the C language. Unlike new trendy languages, C has been around long enough to accumulate professional and well regarded literature.</p><p>如果这些数字化的乐趣让你想学习更多关于编写可移植代码的知识，那么最好的学习地点就是关于这一主题的优秀书籍之一。前面提到的亨利·拉比诺维茨（Henry Rabinowitz）的作品很棒，马克·霍顿（Mark Horton）的作品也是如此。好书是C语言的另一个优势。与新的流行语言不同，C语言已经存在了足够长的时间，积累了专业的、广受好评的文献。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/可移植性/">#可移植性</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lessons/">#lessons</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指针/">#指针</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>