<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Ruby光纤调度器Ruby Fiber Scheduler</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Ruby Fiber Scheduler<br/>Ruby光纤调度器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-03-01 22:27:42</div><div class="page_narrow text-break page_content"><p>Fiber Scheduler enables asynchronous programming in Ruby. The feature was one of the big additions to Ruby 3.0, and is one of the core components of  the awesome async gem.  The best part is that you don&#39;t need a whole framework to get started!  It&#39;s possible to achieve the benefits of asynchronous programming using a standalone Fiber Scheduler with just a couple of  built-in Ruby methods.</p><p>Fiber Scheduler支持Ruby中的异步编程。该功能是Ruby 3.0的一大新增功能，也是awesome async gem的核心组件之一。最棒的是你没有&#39；我们不需要一个完整的框架来开始！它&#39；使用一个独立的光纤调度器，只需几个内置的Ruby方法，就可以实现异步编程的好处。</p><p>    A set of hooks for blocking operations built into the language. Hook implementations are delegated to the  Fiber.scheduler object.</p><p>语言中内置的一组用于阻止操作的钩子。钩子实现被委托给光纤。调度程序对象。</p><p>    Implements the asynchronous behavior. This is an object that needs to be explicitly set by the programmer, as Ruby does not provide a default Fiber Scheduler implementation.</p><p>实现异步行为。这是一个需要程序员显式设置的对象，因为Ruby不提供默认的光纤调度器实现。</p><p>  Big thanks to Samuel Williams! He&#39;s a Ruby core developer who designed and implemented the Fiber Scheduler feature into the language.</p><p>非常感谢塞缪尔·威廉姆斯！他&#39；s是一位Ruby核心开发人员，他在语言中设计并实现了光纤调度器功能。</p><p>    Fiber Scheduler interface is a set of hooks for blocking operations. It allows for inserting asynchronous behavior when a blocking operation occurs. These hooks are documented with  Fiber::SchedulerInterface class.</p><p>光纤调度器接口是一组用于阻塞操作的挂钩。它允许在发生阻塞操作时插入异步行为。这些挂钩是用Fiber:：SchedulerInterface类记录的。</p><p>    Hooks are  low-level. This results in a small number of hooks, with each hook handling the behavior of many  high-level methods. For example, the  #address_resolve hook is responsible for handling around 20 methods.</p><p>钩子是低级的。这会产生少量的钩子，每个钩子处理许多高级方法的行为。例如，#address_resolve钩子负责处理大约20种方法。</p><p>  Hooks work only if  Fiber.scheduler object is set, and hooks&#39; implementation is delegated to that object.</p><p>钩子只有在有纤维的情况下才能起作用。调度器对象已设置，挂钩&#39；实现被委托给该对象。</p><p>    Let&#39;s look at the example showing how  Kernel#sleep hook could be implemented. In practice all hooks are coded in C, but for clarity Ruby pseudocode is used here.</p><p>让&#39；让我们来看一个显示如何实现内核#sleep hook的示例。实际上，所有钩子都是用C编写的，但为了清楚起见，这里使用了Ruby伪代码。</p><p>      If a  Fiber.scheduler object is set – run its  #kernel_sleep method.  #kernel_sleep should run  sleep asynchronously.</p><p>如果是纤维。调度程序对象已设置–运行其#内核_sleep方法#内核_sleep应该异步运行sleep。</p><p>  Otherwise, perform a regular  synchronous_sleep that will block the current thread until  sleep is done.</p><p>否则，执行常规的同步_睡眠，将阻止当前线程，直到睡眠完成。</p><p>      The concept &#34;blocking operation&#34; was mentioned a couple times already, but what does it really mean?  A blocking operation is any operation where a Ruby process (more specifically: current thread) ends up waiting. A more descriptive name for blocking operations would be  &#34;waiting operations&#34;.</p><p>概念&#34；阻塞操作&#34；已经提过好几次了，但这到底是什么意思？阻塞操作是Ruby进程（更具体地说：当前线程）等待的任何操作。阻塞操作的更具描述性的名称是&#34；等待操作&#34；。</p><p>      As a counterexample, the following snippet takes a while to finish, but  does not contain blocking operations:</p><p>作为反例，以下代码段需要一段时间才能完成，但不包含阻塞操作：</p><p>  def  fibonacci(n)  return n  if [ 0,  1].include? n fibonacci(n -  1) + fibonacci(n -  2) endfibonacci( 100)</p><p>如果[0,1]，def fibonacci（n）返回n。包括n斐波那契（n-1）+fibonacci（n-2）endfibonacci（100）</p><p>  Getting the result of  fibonacci(100) requires a lot of waiting, but it&#39;s only a  programmer that&#39;s waiting! The whole time Ruby interpreter is working, crunching the numbers in the background. A naive fibonacci implementation does not contain blocking operations.</p><p>获得斐波那契（100）的结果需要很多等待，但它&#39；他只是一个程序员&#39；等着呢！Ruby解释器一直在工作，在后台处理数字。朴素的斐波那契实现不包含阻塞操作。</p><p>  It pays off to develop an intuition on what a blocking operation is (and is not), as  the whole point of asynchronous programming is to wait on multiple blocking operations at the same time.</p><p>开发关于阻塞操作是什么（或不是什么）的直觉是有好处的，因为异步编程的全部目的是同时等待多个阻塞操作。</p><p>      If you want to enable the asynchronous behavior in Ruby, you need to set a Fiber Scheduler object for the current thread. That&#39;s done with the  Fiber.set_scheduler(scheduler) method. The implementation is commonly a class with all the  Fiber::SchedulerInterface methods defined.</p><p>如果想在Ruby中启用异步行为，需要为当前线程设置一个Fiber Scheduler对象。那&#39；光纤已经用完了。设置_调度程序（调度程序）方法。该实现通常是一个定义了所有Fiber:：SchedulerInterface方法的类。</p><p>  Ruby does not provide a default Fiber Scheduler class, nor an object that could be used for that purpose. It seems unusual, but not including the Fiber Scheduler implementation with the language is actually a good  long-term decision. It&#39;s best to leave this relatively  fast-evolving concern outside the core Ruby.</p><p>Ruby不提供默认的Fiber Scheduler类，也不提供可用于此目的的对象。这似乎很不寻常，但不将光纤调度器实现包含在语言中实际上是一个很好的长期决定。它&#39；最好把这个相对快速发展的问题放在核心Ruby之外。</p><p>  Writing a Fiber Scheduler class from scratch is a complex task, so it&#39;s recommended to use an existing solution. The list of implementations can be found at  Fiber Scheduler List project.</p><p>从头开始编写Fiber Scheduler类是一项复杂的任务，因此它&#39；建议使用现有的解决方案。可在Fibre Scheduler list项目中找到实施列表。</p><p>      All examples use Ruby 3.1 and  FiberScheduler class from the  fiber_scheduler gem, which is maintained by yours truly. This gem is  not a hard dependency for the examples, as every snippet below should still work if references to  FiberScheduler are replaced with another Fiber Scheduler class.</p><p>所有示例都使用Ruby 3.1和fiber_scheduler gem中的FiberScheduler类，该类由您自己维护。对于这些示例来说，这个gem并不是一个硬依赖项，因为如果对FiberScheduler的引用被另一个Fiber Scheduler类替换，下面的每个代码段都应该仍然有效。</p><p>        The above code is creating two fibers, each making an HTTP request. The requests run in parallel and the whole program finishes in 2 seconds.</p><p>上面的代码创建了两个光纤，每个光纤发出一个HTTP请求。请求并行运行，整个程序在2秒内完成。</p><p>  Sets a Fiber Scheduler in the current thread which enables  Fiber.schedule method to work, and fibers to behave asynchronously.</p><p>在当前线程中设置启用光纤的光纤调度程序。安排方法工作，光纤异步工作。</p><p>  The example uses only standard Ruby methods – both  Fiber.set_scheduler and  Fiber.schedule have been available since Ruby 3.0.</p><p>该示例仅使用标准的Ruby方法，包括光纤和光纤。设置调度程序和光纤。自Ruby 3.0以来，日程安排一直可用。</p><p>      require  &#34; fiber_scheduler &#34; require  &#34; httparty &#34; require  &#34; open-uri &#34; require  &#34; redis &#34; require  &#34; sequel &#34; DB =  Sequel.postgres Sequel.extension( : fiber_concurrency) Fiber.set_scheduler( FiberScheduler.new) Fiber.schedule  do  URI.open( &#34; https://httpbin.org/delay/2 &#34;) end Fiber.schedule  do  # Use any HTTP library  HTTParty.get( &#34; https://httpbin.org/delay/2 &#34;) end Fiber.schedule  do  # Works with any TCP protocol library  Redis.new.blpop( &#34; abc123 &#34;,  2) end Fiber.schedule  do  # Make database queries  DB.run( &#34; SELECT pg_sleep(2) &#34;) end Fiber.schedule  do sleep  2 end Fiber.schedule  do  # Run system commands  ` sleep 2 ` end</p><p>要求&#34；光纤调度&#34；要求&#34；httparty&#34；要求&#34；打开uri&#34；要求&#34；redis和#34；要求&#34；续集&#34；DB=续集。博士后续集。扩展（：fiber_concurrency）光纤。设置调度程序（FiberScheduler.new）光纤。计划做URI。开放式（&#34；https://httpbin.org/delay/2 &#34;) 末端纤维。计划不要使用任何HTTP库HTTParty。获得（&#34；https://httpbin.org/delay/2 &#34;) 末端纤维。schedule do#适用于任何TCP协议库Redis。刚出现的blpop（&#34；abc123&#34；2）端光纤。计划进行数据库查询。运行（&#34；选择pg#U睡眠（2）&#34；）末端纤维。安排睡眠2个月。计划执行#运行系统命令'sleep 2'结束</p><p>  If we ran this program sequentially it would take about 12 seconds to finish. But as the operations run in parallel, the total running time is just over 2 seconds.</p><p>如果我们按顺序运行这个程序，大约需要12秒才能完成。但由于这些操作并行运行，总运行时间仅为2秒多。</p><p>  You&#39;re not constrained to making just HTTP requests.  Any blocking operation that&#39;s built into Ruby or implemented by an external gem works!</p><p>你&#39；我们不局限于发出HTTP请求。任何&#39；s内置在Ruby中或由外部gem实现！</p><p>          The  sleep method was chosen for the scaling example due to its low overhead. If we used network requests the execution time would be longer because of the overhead of setting up thousands of connections and performing SSL handshakes etc.</p><p>在缩放示例中选择了sleep方法，因为它的开销很低。如果我们使用网络请求，执行时间会更长，因为需要建立数千个连接和执行SSL握手等开销。</p><p>  One of the main benefits of asynchronous programming is waiting on many blocking operations at the same time.  The benefits increase as the number of blocking operations grows. Luckily, it&#39;s super easy to run large numbers of fibers.</p><p>异步编程的主要好处之一是同时等待许多阻塞操作。随着阻塞操作数量的增加，好处也会增加。幸运的是，它&#39；它非常容易运行大量光纤。</p><p>    Ruby can work asynchronously with just a Fiber Scheduler and a couple  built-in methods – no frameworks are required!</p><p>Ruby只需要一个光纤调度器和两个内置方法就可以异步工作——不需要框架！</p><p>  It&#39;s easy to make it work. Choose a  Fiber Scheduler implementation, and then use these methods:</p><p>它&#39；这很容易做到。选择光纤调度器实现，然后使用以下方法：</p><p>  Fiber.set_scheduler(scheduler) sets a Fiber Scheduler for the current thread, enables blocking operations to behave async.</p><p>纤维set_scheduler（调度程序）为当前线程设置光纤调度程序，使阻塞操作表现为异步。</p><p>  Once you get it going, you can  make any code asynchronous by wrapping it in a  Fiber.schedule block.</p><p>一旦开始运行，就可以通过将任何代码封装在光纤中来实现异步。计划块。</p><p>    Whole libraries can easily be converted to async with this approach, and it rarely takes more effort than shown here.</p><p>使用这种方法，整个库都可以轻松地转换为异步，而且几乎不需要比这里显示的更大的工作量。</p><p>  The big benefit of asynchronous programming is parallelizing blocking/waiting operations to reduce the program running time. This often translates into running more operations on a single CPU, or even better, handling more requests with your web server.</p><p>异步编程的最大好处是并行化阻塞/等待操作，以减少程序运行时间。这通常会转化为在单个CPU上运行更多操作，或者更好地使用web服务器处理更多请求。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/光纤/">#光纤</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fiber/">#fiber</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>