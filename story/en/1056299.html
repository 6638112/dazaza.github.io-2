<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>早期的LISP第II部分 Early Lisp Part II</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Early Lisp Part II<br/>早期的LISP第II部分 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-05 23:59:40</div><div class="page_narrow text-break page_content"><p>By April of 1959, issues with using  subst to implement β-reduction became apparent.In the April 1959 Quarterly Progress Report of the Research Laboratory of Electronics, McCarthy gives an updated definition of the universal S-function  apply: apply[f;args]=eval[cons[f;appq[args]];NIL]where appq[m]=[null[m]→NIL;T→cons[list[QUOTE;car[m]];appq[cdr[m]]]]and eval[e;a]=[atom[e]→eval[assoc[e;a];a];atom[car[e]]→[car[e]=QUOTE→cadr[e];car[e]=ATOM→atom[eval[cadr[e];a]];car[e]=EQ→[eval[cadr[e];a]=eval[caddr[e];a]];car[e]=COND→evcon[cdr[e];a];car[e]=CAR→car[eval[cadr[e];a]];car[e]=CDR→cdr[eval[cadr[e];a]];car[e]=CONS→cons[eval[cadr[e];a];eval[caddr[e];a]];T→eval[cons[assoc[car[e];a];evlis[cdr[e];a]];a]];caar[e]=LABEL→eval[cons[caddar[e];cdr[e]];cons[list[cadar[e];car[e]];a]];caar[e]=LAMBDA→eval[caddar[e];append[pair[cadar[e];cdr[e]];a]]and evcon[c;a]=[eval[caar[c];a]→eval[cadar[c];a];T→evcon[cdr[c];a]]and evlis[m;a]= [null[m]→NIL;T→cons[list[QUOTE;eval[car[m];a]];evlis[cdr[m];a]]</p><p>到1959年4月，使用子实现β-减少的问题变得显而易见。在1959年4月的电子设备研究实验室的季度进展报告中，MCCarthy提供了适用的通用S函数的更新定义：应用[F; F; args] = eval [f ctoup [f; appq [arps]]; nil]其中appq [m] = [null [m]→nil; t→缺点[list [quote; car [m]]; appq [cdr [m]] ]]和求解[e; a] = [原子[e]→eval [Ascap [e; a]; a]; Atom [Car [E]]→[Car [E] = Quote→CADR [E];汽车[e] =原子→Atom [eval [CADR [E]; a]];轿车[e] = eq→[eval [CADR [E]; a] = eval [caddr [e]; a]];汽车[ e] = Cond→Evcon [CDR [e]; a];轿车[e] =轿车→汽车[eval [CADR [E]; a]]; car [e] = cdr→cdr [eval [CADR [CADR [CADR [CADR [CADR [CADR [E] ; a]];轿车[e] =缺点→涉及[eval [CADR [E]; a]; eval [Caddr [e]; a]]; t→eval [cons [Acap [Car [e]; a] ; aevlis [cdr [e]; a]]; a]; caar [e] = label→eval [caddar [e]; cdr [e]];缺点[列表[cadar [e];汽车[e ]; a]]; caar [e] = lambda→eval [caddar [e];附录[对[cadar [cadar [e]; cdr [e]]; a]和evcon [c; a] = [eval [ CAAR [C]; A]→eval [CADAR [C]; A]; T→EVCON [CDR [C]; A]和EVLIS [M; A] = [NULL [M]→NIL; T→缺点[列表[报价; eval [车[m]; a]]; evlis [cdr [m]; a]]</p><p> I find this a lot easier to understand if we transcribe it into modern Common LISP: ;;; Hey Emacs, this is -*- Lisp -*-(in-package &#34;CL-USER&#34;);; Avoid smashing the standard definitions.(shadow &#34;APPLY&#34;)(shadow &#34;ASSOC&#34;)(shadow &#34;EVAL&#34;)(defun apply (f args) (eval (cons f (appq args)) nil))(defun appq (m) (cond ((null m) nil) (t (cons (list &#39;QUOTE (car m)) (appq (cdr m))))))(defun eval (e a) (cond ((atom e) (eval (assoc e a) a)) ((atom (car e)) (cond ((eq (car e) &#39;QUOTE) (cadr e)) ((eq (car e) &#39;ATOM) (atom (eval (cadr e) a))) ((eq (car e) &#39;EQ) (eq (eval (cadr e) a) (eval (caddr e) a))) ((eq (car e) &#39;COND) (evcon (cdr e) a)) ((eq (car e) &#39;CAR) (car (eval (cadr e) a))) ((eq (car e) &#39;CDR) (cdr (eval (cadr e) a))) ((eq (car e) &#39;CONS) (cons (eval (cadr e) a) (eval (caddr e) a))) (t (eval (cons (assoc (car e) a) (evlis (cdr e) a)) a)))) ((eq (caar e) &#39;LABEL) (eval (cons (caddar e) (cdr e)) (cons (list (cadar e) (car e)) a))) ((eq (caar e) &#39;LAMBDA) (eval (caddar e) (append (pair (cadar e) (cdr e)) a)))))(defun evcon (c a) (cond ((eval (caar c) a) (eval (cadar c) a)) (t (evcon (cdr c) a))))(defun evlis (m a) (cond ((null m) nil) (t (cons (list &#39;QUOTE (eval (car m) a)) (evlis (cdr m) a)))));;; Modern helpers(defun assoc (k l) (cadr (cl:assoc k l)))(defun pair (ls rs) (map &#39;list #&#39;list ls rs))(defun testit () (apply &#39;(label ff (lambda (x) (cond ((atom x) x) ((quote t) (ff (car x)))))) (list &#39;((a . b) . c))))</p><p> 我发现我们更容易了解我们是否将其转录为现代普通的Lisp :;;;嘿emacs，这是 -  *  -  lisp  -  *  - （包装和＃34; cl-user＆＃34;）;避免滥用标准定义f（APPQ ARGS））NIL））（DEFUN APPQ（M）（COND（（null m）零）（t（缺点（缺点＆＃39; quote（carm））（APPQ（CDR M）））））））） ）（Defun Eval（EA）（Cond（（Atom E）（eval（Acce ea）a））（（原子（汽车e））（cond（（eq（eq（equ（e）＆＃39; quote）（cadr e） ）（（eq（轿车e）＆＃39;原子）（原子（eval（CADR e）a）））（（eq（e）＆＃39; eq）（方程式）（eq（eval（CADR e）a）（ eval（CADDR e）a））））（（eq（care e）＆＃39; cond）（EVCON（CDR）a））（（eq（eq（care）＆＃39;汽车）（汽车（eval（CADR e）a）））（（eq（eq（care）＆＃39; cdr）（cdr（eval（CADR e）a））））（（eq（care e）＆＃39; cons）（缺点（eval（CADR e）a）（求助（CADDR e）a））））（at（emp（涉及（acc（care（acc））（EVLIS（CDR e）））a）））））（（eq（caar e）＆ ＃39;标签）（申请（CADDAR E）（CDR e））（缺点（名单（CADAR E）（CARE））a））））（（eq（caar e）＆＃39; lambda）（eval （CADDAR E）（附加（对（CADAR E）（CDR E））a）））））））（Defun Evcon（CA）（Cond（（eval（Caar C）A）（eval（CADAR C）A））（ t（Evcon. （CDR C）a）））））（Defun EVLIS（MA）（COND（（NULL M）零）（T（缺点（名单和＃39; Quote（eval（CAR M）））（EVLIS（CDR M））一个）））））;;;现代助手（Defun Adsoc（KL）（CADR（CL：Assoc）））（Defun对（LS RS）（Map＆＃39;列表＃39; list ls rs））（defun testit（）（适用＆ ＃39;（标签ff（lambda（x）（cond（（atom x）x）（（引用t）（ff（car x））））））（列表＆＃39;（（a。b）。c ））））</p><p> There are a few things to notice about this. First, there is no code that inspects the value cell or function cell of a symbol. All symbols are evaluated by looking up the value in the association list  a, so this evaluator uses one namespace. Second, the recursive calls to  eval when evaluating combinations (the last clause of the inner  cond and the  LABEL and  LAMBDA clauses) are in tail position, so this evaluator could be coded up tail-recursively. (It is impossible to say without inspecting the IBM 704 assembly code.)</p><p> 关于这个有一些事情要注意到这一点。首先，没有代码检查符号的值单元格或功能单元格。通过查找关联列表A中的值来评估所有符号，因此此评估程序使用一个命名空间。其次，评估组合时的递归调用评估（内部条件的最后一个条款和标签和Lambda条款）处于尾部位置，因此该评估员可以递归地编码尾部。 （不检查IBM 704汇编代码是不可能的。）</p><p> What is most curious about this evaluator is the first clause in the outer  cond in  eval. This is where variable lookup happens. As you can see, we look up the variable by calling  assoc, but once we obtain the value, we call  eval on it. This LISP isn&#39;t storing values in the environment, but rather expressions that evaluate to values. If we look at the  LAMBDA clause of the cond, the one that handles combinations that begin with lambda expressions, we can see that it does not evaluate the arguments to the lambda but instead associates the bound variables with the arguments&#39; expressions. This therefore has call-by-name semantics rather than the modern call-by-value semantics.</p><p> 关于此评估者的最好奇员是外部COND中的第一个条款。这是可变查找发生的地方。正如您所看到的，我们通过调用Assoc来查找变量，但一旦我们获得该值，我们就会调用eval。此Lisp ISN＆＃39; t存储环境中的值，而是评估为值的表达式。如果我们查看COND的Lambda子句，请致电以lambda表达式开头的组合，我们可以看到它不会评估Lambda的参数，而是将绑定变量与参数＆＃39相关联。表达。因此，它具有逐个名称语义而不是现代呼叫Quale值语义。</p><p> By April 1960 we see these changes: (defun eval (e a) (cond ((atom e) (assoc e a)) ((atom (car e)) (cond ((eq (car e) &#39;QUOTE) (cadr e)) ((eq (car e) &#39;ATOM) (atom (eval (cadr e) a))) ((eq (car e) &#39;EQ) (eq (eval (cadr e) a) (eval (caddr e) a))) ((eq (car e) &#39;COND) (evcon (cdr e) a)) ((eq (car e) &#39;CAR) (car (eval (cadr e) a))) ((eq (car e) &#39;CDR) (cdr (eval (cadr e) a))) ((eq (car e) &#39;CONS) (cons (eval (cadr e) a) (eval (caddr e) a))) (t (eval (cons (assoc (car e) a) (evlis (cdr e) a)) a)))) ((eq (caar e) &#39;LABEL) (eval (cons (caddar e) (cdr e)) (cons (list (cadar e) (car e)) a))) ((eq (caar e) &#39;LAMBDA) (eval (caddar e) (append (pair (cadar e) (evlis (cdr e) a)) a)))))</p><p> 到1960年4月，我们看到了这些变化:( Defun评估（EA）（Cond（Atom E）（Assoc EA））（（Atom（Care E））（Cond（（eq（轿车e）＆＃39; quote）（ CADR e））（（eq（汽车e）＆＃39; atom）（原子（eval（cadr e）a）））（（eq（care e）＆＃39; eq）（方程式）（eqs（eval（CADR E） a）（eval（CADDR e）a））））（（eq（care e）＆＃39; cond）（EVCON（CDR e）a））（（eq（care e）＆＃39;汽车）（汽车（ eval（CADR e）a）））（（eq（e）＆＃39; cdr）（CDR（eval（CADR e））））（（eq（eq（care）＆＃39; cons）（缺点（评估（CADR e）a）（求助（CADDR e）a））））（申请（股份（CARE（CARE）A）（EVLIS（CDR））a））））））（（嘉嘉（CAAR e）＆＃39;标签）（eval（CADDAR E）（CDR e））（缺点（名单（CADAR E）（CARE）（CARE））a）））（（eq（caar e）＆＃39; lambda ）（评估（Caddar E）（附加（对（CADAR E）（EVLIS（CDR e）））））））））））</p><p>Note how evaluating an atom now simplylooks up the value of the atom in the association list and evaluation of a combination of a  lambda involves evaluatingthe arguments eagerly. This is a call-by-value interpreter.</p><p>说明如何评估Atom现在SimpleyLook上升到Atom的价值，并评估Lambda组合涉及热切地评估争论。这是一个逐个值解释器。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://funcall.blogspot.com/2021/04/early-lisp-part-ii-apply-redux.html?m=1">http://funcall.blogspot.com/2021/04/early-lisp-part-ii-apply-redux.html?m=1</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/eval/">#eval</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>