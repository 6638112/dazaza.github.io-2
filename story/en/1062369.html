<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>建立ASIC设计时学习的经验教训 Lessons learned while building an ASIC design</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Lessons learned while building an ASIC design<br/>建立ASIC设计时学习的经验教训 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-13 11:37:47</div><div class="page_narrow text-break page_content"><p>Ever since I started working with FPGAs, I’ve always wanted to do an ASIC design. Ifnothing else, I wanted to understand from experience what it was like.</p><p>自从我开始使用FPGA以来，我一直想做ASIC设计。别的东西，我想从体验中了解它的样子。</p><p> Last year, I got my chance. I’m now on my second design, and the team I’mworking with has just sent a piece of this second design to be  tapedout.</p><p> 去年，我有机会。我现在正在第二个设计中，而是刚刚用的团队刚刚派出了一块这个第二个设计来占用。</p><p> The process, however, was different in many ways I wasn’t expecting. Here,below, are some of those differences I wasn’t expecting.</p><p> 然而，这种过程在很多方面都不是不同的。在这里，下面，我不期望的一些差异。</p><p>    The design as a whole is a memory controller, as shown in Fig. 1. It’s a memorycontroller which can be sold independently to customers for placement intoa larger SoC design.</p><p>    整个设计是存储器控制器，如图1所示。它是一个MemoryController，可以独立出售给客户放置更大的SoC设计。</p><p> This first ASIC component of the design I needed to build was actually fairlysimple. There’s not a lot of logic in it. I personally like to think of thisportion of the design as a glorified serializer and deserializer. It takes8x samples of a signal and serializes them to an output, and then does the samein reverse. Except, there are some subtle differences.</p><p> 我需要构建的设计的第一个ASIC组件实际上是公平的。它没有很多逻辑。我个人希望将设计的商品视为美味的序列化器和解序机。它需要8倍的信号样本，并将它们序列化为输出，然后将同性相反。除了，有一些微妙的差异。</p><p>  More specifically, the design is the first half of a two stage design processto build a memory controller. The first stage involves building the high speedportions of the design, as shown in Fig. 2. This is the high risk stage. Itinvolves buildingcomponents that cannot be implemented in an FPGA. In some respects, this is athrow-away portion of the design, and so it is important to minimize itscost. The second part will handle the protocol and logic associated with thedesign. This is the more complicated part. Its gate count will be muchhigher. By verifying this portion of the design within an FPGA, cost and timeto development can beoptimized. Even better, if necessary, the protocol can be debugged andfixed–something not easily done on an ASIC. The first stage, therefore, isbasically a speed translator. It communicates with slower logic on one sideof the chip, and faster logic on the other. Since this is for a memorycontroller, the high speed lines are bidirectional, and they come accompaniedby a clock whenever data is present. Shifting this clock by 90 degrees wasa bit of a challenge, as was delaying the clock in order to sample in themiddle of a received data bit, but the design was still pretty basic.</p><p>  更具体地，设计是两个阶段设计过程的前半部分构建内存控制器。第一阶段涉及构建设计的高速度，如图2所示。这是高风险阶段。 ITINVOLVES无法在FPGA中实施的建筑组件。在某些方面，这是设计的Athrow部分，因此最大限度地减少Itscost是很重要的。第二部分将处理与TheDesign相关的协议和逻辑。这是更复杂的部分。它的门数将是很长的。通过在FPGA中验证设计的这一部分，可以优化成本和时间开发。更好的话，如有必要，可以调试和修复协议 - 在ASIC上不容易完成。因此，第一阶段是速度翻译。它与芯片一侧的较慢的逻辑与较慢的逻辑通信，另一个逻辑更快。由于这是用于存储器控制器，因此高速线是双向的，并且每当存在数据时，它们都会伴随时钟。将此时钟转换为90度的挑战，因为延迟时钟才能在接收数据位的Themiddle中进行采样，但设计仍然非常基本。</p><p>   Not all of this was my fault. As I understand things, the engineer who wasworking this project before me had left mid-project. My job was to pick upwhere he left off. Unfortunately, that meant there was a bit of managementconfusion between when the last engineer left and when my contract was signed.It didn’t help that I wasn’t certain I’d even have the bandwidth for thisproject when I started it, and so I delayed bidding for the project by acouple months.</p><p>   并非所有这都是我的错。正如我所了解的事情，工程师在我面前在我面前担任这个项目已经离开了中间项目。我的工作就是在他离开的地方挑选。不幸的是，这意味着当签署我的合同时最后一个工程师和当我的合同签名时，有一些管理层。如果我开始时，我甚至不确定我甚至在我开始时拥有这个项目的带宽，所以我通过每周延迟了该项目的竞标。 </p><p>  The project was also late because after building my portion of the project(in 2-4 weeks), I discovered that wasn’t nearly enough. Sure, Iformally verified (nearly) every portion of the design, but I couldn’tsimulate the entire design end to end. The low-speed logic design simulationwas handed to me in a non-functional state, and I had just changed theinterface on top of that. In whole, this was a non-starter. How was I toknow if my new interface was sufficient, if I couldn’t verify the whole?</p><p>该项目也迟到，因为在建立我的部分（在2-4周内）后，我发现这几乎没有足够的。当然，IFORMALLY验证（几乎）设计的各个部分，但我无法将整个设计结束结束。低速逻辑设计仿真在非功能状态下向我传递给我，我刚刚改变了接口的顶部。总的来说，这是一个非起动器。如果我无法验证整体，我是如何知道如果我的新界面足够了，那么</p><p> So, let’s back up a bit to understand how this started. I was given a designconsisting of a protocol portion and a physical layer portion, togetherwith several simulation components–much like Fig. 3 below.</p><p> 所以，让我们备份一点以了解这是如何开始的。我被赋予了协议部分和物理层部分的设计，相同的几个模拟组件 - 就像图3一样。</p><p>  I was told a lot of things about it. For example, this was what was left froma previous working design that had been delivered to customers. Since then,that design had been adjusted and modified by a previous engineer, but thosemodifications had yet to make it into a delivery. I was also told that lessthan half of the test scripts were passing. Further, the 8b internal interfacewas too fast for an FPGA to handle, and so I would need to slow it down byparallelizing the data path. So my initial task was simply to upgrade froman 8-bit data path in the digital front end to a 64-bit data path. That muchof the task was quite straightforward, and that was the portion that was to gointo this ASIC design.</p><p>  我被告知了很多事情。例如，这是从以前的工作设计留下的东西，这些设计已被提供给客户。从那时起，该设计已经被先前的工程师调整和修改，但是尚未将其交付交付。我也被告知，考试脚本的一半是通过的。此外，8B内部接口对于FPGA来处理太快，因此我需要通过平行数据路径来减慢它。因此，我的初始任务只是简单地升级数字前端的8位数据路径到64位数据路径。这项任务非常简单，这是谷歌这个ASIC设计的部分。</p><p> Straightforward? Yes. However, it did send me crawling all over the originaldesign, and I did have to make changes in more places than I was expecting–evenin the low-speed logic that was destined to be scrapped as part of my upgrades.</p><p> 直截了当？是的。但是，它确实让我抓住了所有的原始设计，我必须在更多的地方进行更改，而不是我期待 - 甚至是注定被报废被报废的低速逻辑作为我升级的一部分。</p><p> For example, the AXI bus width of the design given to me was naturally 32-bitswide. This works nicely with an AXI4-lite controller. A 64-bit datapath,however, meant that either the bus would also need to be made 64-bits wide,or that the bus width would become a performance bottleneck.</p><p> 例如，给我的设计的AXI总线宽度自然32位。这与Axi4-Lite控制器很好地工作。然而，64位数据路径意味着总线还需要进行64位宽，或者总线宽度将成为性能瓶颈。</p><p> The next problem was that the simulation I was given didn’t work. Yes, thesimulation supported nearly a hundred separate tests, but I was told at theoutset that most of them didn’t work.</p><p> 下一个问题是我给出的模拟不起作用。是的，这一激励支持几百个单独的测试，但我被告知了大多数人都没有工作。</p><p> On top of that, the free Verilog simulator I had access to on my desktop, Icarus Verilog, didn’t support the SystemVerilogdot notation when calling tasks. Getting the simulation, therefore, to evenbuild in  Icarus Verilog took some days.</p><p> 最重要的是，我在桌面上访问的免费Verilog模拟器Icarus Verilog在调用任务时不支持SystemVerogdot表示法。因此，在Icarus Verilog中达到模拟，花了一些时间。 </p><p> To make matters worse, once I got to the point where I could try one or twoof the “verified” tests, that is once I could test the first of the simulationsthat were supposed to “just work”–they didn’t work. Instead, the “verified”tests did the worst thing possible: they hung the simulation. That left mewondering if, or when, I should kill the simulation or if it was actuallydoing something useful while it wasn’t printing anything to the screen.</p><p>让事情变得更糟，一旦我到达了我可以尝试一个或两个“验证的”测试的地步，那就是我可以测试第一个模拟应该“只是工作” - 他们没有工作。相反，“验证的”测试是最糟糕的事情：他们挂了模拟。如果，如果，如果我应该杀死模拟，或者如果它实际上是有用的，而且在没有打印到屏幕上的东西时，那就留下了墨守作用。</p><p> Needless to say, my 2-4 week task took much longer to accomplish than I wasanticipating. It is now five months later, and the design is only now tapingout.</p><p> 毋庸置疑，我的2-4周任务比我迷茫地面完成了更长时间。现在是五个月后，设计只有陷阱。</p><p>  Seriously, I’d be a much better engineer, and certainly a much more profitableone, if I could estimate the time to complete a project from the beginningmuch better than I can today.</p><p>  说真的，我会成为一个更好的工程师，当然可以估计比我今天更好地完成项目的时间来完成项目的时间。</p><p>   It wasn’t until after I had built my design that I got a chance to read theoriginal contract between my client and his customer. That contract calledfor a built-in self testing (BIST) capability. Oops. I hadn’t built thatin. No problem, I thought, I could add in a simple BIST capability with justa couple extra registers.</p><p>   直到我建立了我的设计之前，我有机会阅读客户和他的客户之间的理论合同。该合同已称为内置自检（BIST）功能。哎呀。我没有建立那个。没有问题，我想，我可以用简单的BIST能力添加Justa耦合额外的寄存器。</p><p> First, there was the control wire. The slave access port(s) need to beadjusted so they could turn on the BIST checker. That part was easy, and Iknow  how to formally verify that a bus register can be properlycontrolled,so I was good there. The second part was to capture the internal state on agiven signal. This was almost as simple as,</p><p> 首先，有控制线。从属访问端口需要抛绑定，以便它们可以打开BIST检查器。那部分很容易，我知道如何正式验证总线寄存器可以正确控制，所以我很好。第二部分是捕获动态信号的内部状态。这几乎是简单的，</p><p>   But did it work in simulation? No. I hadn’t built a simulation for it.</p><p>   但它在模拟中工作了吗？不，我没有为它建立模拟。</p><p> Building the simulation took another day, since I needed to check all of thevarious bits that could be captured above. (The capture signal was wider thana single bit.) It then took another day (or two) to get it all to work.</p><p> 建立模拟拍摄了另一天，因为我需要检查可以在上面捕获的所有名字比特。 （捕获信号越宽于单位。）它然后拍摄另一天（或两个）以使其全部工作。 </p><p>  Was the task done? No. Now, every time I change the design, I have to go backand re-verify it against this simulation. Worse, because of the clock gamestaking place within this design, there were all kinds of timing errors generatedby this logic. In the end, I split the capture signal into two, each capturedon a separate clock. Even that wasn’t enough, because I only later thoughtthrough the fact that eight of the internal values were captured on their ownspecial clocks–but that’s part of the longer story.</p><p>任务完成了吗？不，现在，每次我更改设计时，我都必须退回，重新验证此模拟。更糟糕的是，由于在这种设计中的时钟GameStaking的地方，这个逻辑产生了各种定时错误。最后，我将捕获信号分成两个，每个Captured都是单独的时钟。即使是那还不够，因为我稍后只深受关注他们的八个内部值在其自己的小钟上被捕获 - 但这是较长故事的一部分。</p><p>  For the other half, I suggested monitoring the output of the high speeddevice through the input channel. The data would just reflect back within thehigh speed portion of the design onto the input, as shown in Fig. 5 below.</p><p>  对于另一半，我建议通过输入通道监控高速行程的输出。数据只能在设计的高速部分内反射到输入上，如图5所示。5下面。</p><p>  This, I reckoned, could be implemented with a simple no-logic change in thefront end. That is, it was a no-logic change until I actually took the timeto simulate it instead of telling everyone it would “just work”. Only afterI built a simulation for this check did I realize I had turned reflectionsoff to optimize power. Although I fixed up the design to get this to work,there was a second problem to it that I wasn’t expecting. Because the designwould receive and return its own transmitted data as it was transmitting it,the I/O lines couldn’t be shared between transmit and receive. This nearlydoubled the number of I/O pins on the ASIC to the point where the size of theI/O pin pads dominated the size of the ASIC and therefore it’s manufacturingcost.</p><p>  我估计，这可以通过在前一端的简单无逻辑变化实现。也就是说，直到我实际拍摄Timeto模拟它，而不是告诉大家，这是一个禁用的变化，而不是告诉所有它会“只是在工作”。只有在此检查的仿真中才会实现了我意识到我已经转过了反射来优化电力。虽然我修复了设计来实现这一点，但我没有期待的第二个问题。因为设计在传输时，设计将接收并返回其自己的传输数据，因此无法在发送和接收之间共享I / O线。这近来，ASIC上的I / O引脚数差点为AI / O引脚垫的大小主导ASIC的大小，因此是它的制造单元。</p><p> Both adjustments required only a minimal amount of design adjustments to ourhigh speed ASIC design. The design changes may have taken only 15 minuteseach. Building the simulation necessary to prove these changes may havetaken closer to a day for each of them. Running all the various simulationsnow at  tape out still takes severaldays–assuming everything works.</p><p> 这两种调整只需要对我们的高速ASIC设计进行最小的设计调整。设计变更可能仅采用15分钟。构建证明这些变化所需的模拟可能会对每个人留下近一天。在磁带处运行所有各种模拟仍然需要几天 - 假设一切都有效。</p><p> Even these early simulations weren’t the end of the verification task. Oncethe design was laid out and the internal timing values from within the designwere known, it then needed to be verified  again, and then again as a secondportion of the design was laid out, and again as a third portion, etc. Thenumber of times my “working” logic has had to go through a simulator has beensomewhat of a shock to me. More on that to come.</p><p> 即使是这些早期的模拟也不是验证任务的结束。 oncethe设计被布局并从设计中所知的内部时序值，然后需要再次验证，然后再次作为设计的第二代，并且再次作为第三部分等。我的第三部分“工作”逻辑必须经过模拟器，这对我感到震惊。更多的是到来。</p><p>  One of the first things I did with the design I received was to strip out anyand all unused logic. This meant both the logic I wasn’t using as well as anylogic I couldn’t explain. As a result, I quickly removed the  TEST_MODEinput, as well as the several  SCAN_* inputs associated with it, such as the SCAN_CLK.</p><p>  我收到的设计的第一件事之一是剥离所有未使用的逻辑。这意味着我没有使用的逻辑以及我无法解释的任何逻辑。因此，我很快删除了test_modeinput，以及与它相关联的几个扫描_ *输入，例如scan_clk。</p><p> That worked great until I sent my design to the layout engineer. He told meI had to put these values back into the design to support DFT scan chain insertion.</p><p> 在我将设计发送到布局工程师之前，这很棒。他告诉Mei必须将这些值放回设计中以支持DFT扫描链插入。 </p><p> Our  DFT implementationworked off of a basic scan chain. That meant that every flip-flop in thedesign needed to be connected to a massive shift register running throughthe whole design. This allows you to test the internal circuitry of thedesign after it has been manufactured, to verify that it was manufacturedcorrectly.</p><p>我们的DFT实现了基本扫描链的工作。这意味着在通过整个设计中运行的全部换档寄存器所需的每个触发器。这允许您在制造后测试基因的内部电路，以验证它是制造的是否制造。</p><p>  That meant I had to go back and put this logic back into the design inspite of having removed it.</p><p>  这意味着我不得不回去并将这个逻辑放回删除它的设计时。</p><p>  This felt a bit strange to do. The DFTsignals weren’t connected to anything within the RTL, and they generated Verilatorlint errors, but they were apparently still necessary.</p><p>  这觉得有点奇怪。 dftsignals没有连接到RTL中的任何内容，它们生成了VerilatorLint错误，但它们显然仍然是必要的。</p><p>  This was the biggest change. I needed to add a clock switch to everyincoming clock within my design. If  TEST_MODE was high, then the designrequired the use of the  SCAN_CLK. If  TEST_MODE was low, then the designclock would be used.</p><p>  这是最大的变化。我需要在我的设计中添加一个时钟切换到每一个时钟。如果test_mode很高，则DesignErquired使用Scan_Clk。如果test_mode低，则将使用DesignClock。</p><p>  Unlike the  clockswitchwe studied earlier on the blog, however, this switch was nothing more thana simple multiplexer selecting which of two clocks would be produced at theoutput.</p><p>  不像博客上之前研究的ClockSwitchWe，此开关只不过是更简单的多路复用器，从而选择两个时钟将在TheOutput中产生。</p><p>  Every internal clock needed to be multiplexed with the  SCAN_CLK. Thiswas in addition to the incoming clocks mentioned above.</p><p>  每个内部时钟都需要与SCAN_CLK复用。此外，除了上面提到的来潮之外。</p><p>  Basically, if you are going to create a logic generated clock, anythingthat will subsequently become the edge of a flip-flop, then the DFT logicneeds to be able to toggle that downstream logic with the  SCAN_CLK.Every clock within the design therefore, and not just those one coming fromthe PLL, needed a multiplexer on it before it could be used.</p><p>  基本上，如果要创建逻辑生成的时钟，则随后将成为触发器的边缘，然后DFT LogicEEEDS能够将该下游逻辑与Scan_Clk.every时钟块切换到设计中，因此而不是只是那些来自PLL的那些，在使用之前需要一个多路复用器。 </p><p>  This also means that there will only ever be a single clock throughout thedesign when in the DFTtest mode. This will naturally limit the things the DFTtest mode can actually test. In other words, any further testing andverification that might need to be done in silicon was my responsibility.</p><p>这也意味着在DFTTEST模式下，只会在整个内计中都有一个时钟。这将自然地限制DFTTEST模式实际测试的东西。换句话说，任何可能在硅中需要完成的进一步测试和验证是我的责任。</p><p>  This one also surprised me. Because my design logic might toggle onan asynchronous reset, it also needed a multiplexer to bypassthe  reset synchronizerwhen the test mode was active.</p><p>  这个也让我感到惊讶。因为我的设计逻辑可能会切换onan异步重置，所以它还需要多路复用器到Bypassthe复位同步器当测试模式处于活动状态时。</p><p> In many ways, this  DFTlogic looked and acted very much like JTAG logic might–but without the JTAG state machine.There was a long shift register, or even series of shift registers–i.e. thescan chain, within the design that were controlled by this DFTcircuitry. I just didn’t realize that I, as the digital designer prior tolayout, had a role to play in the process.</p><p> 在许多方面，这种DftLogic看起来并表现得非常像JTAG逻辑可能 - 但没有JTAG状态机。它们是一个长移位寄存器，甚至是Shift Registers-i.e。 Thescan链，在设计的设计内，由此Dftcircuitry控制。我只是没有意识到我作为数字设计师先前的Tolayout，在这个过程中发挥作用。</p><p> In other words, the next time I’m given a design like this, I’m not going toimmediately rip out the  DFTlogic as my first step.</p><p> 换句话说，下次我给出了这样的设计，我不会像我的第一步一样地扯掉DFTLOGIC。</p><p>  Manufacturing cost for ASIC production is generally proportional to the areaused by the design. More specifically, the cost is dominated by the cost toproduce the masks necessary to manufacture a wafer. It’s also possible toplace multiple dissimilar chips on a given wafer in order to help spread thecost of manufacturing a wafer across multiple users. That still leaves waferarea as the dominant measure of cost.</p><p>  ASIC生产的制造成本通常与设计的区域成比例。更具体地说，成本由低于制造晶片所需的面罩来支配成本。在给定晶片上也可能是多个不同的碎片，以帮助在多个用户跨越制造晶圆的结果。仍然留下了瓦斯拉亚作为优势的成本衡量标准。</p><p> Prior to this design, I had always thought that meant that the logic area ofthe design, as measured in gate counts, would then be roughly proportional tothe overall area and would therefore dominate the overall manufacturing cost.</p><p> 在此设计之前，我一直认为这意味着设计的逻辑区域，如在栅极计数中测量的，然后将大致比例而不是整体区域，因此将占据整体制造成本。</p><p> Much to my surprise, I discovered that each I/O pad connecting the design tothe outside world required a minimum amount of area. In my case, the designrequired so many I/O pads that the size of these pads proved to dominate thesize of the design. The actual gate area was much smaller.</p><p> 令我惊讶的是，我发现每个I / O垫连接到世界外面的设计需要最少的区域。在我的情况下，DesignErquired这么多的I / O垫认为这些垫的大小证明是占据设计的主导。实际的栅极区域要小得多。 </p><p> Even apart from the I/O pad sizes, there was a very large analog section tothis high-speed chip. This included things like the PLL and several DLLs,in addition to the circuitry necessary to handle unwanted electrostaticdischarge (ESD) or the circuitry required to “clean” (i.e. filter) the powerfor the analog logic. I had never thought of a design asneeding these components before, and to my surprise the digital logic wasvery small in size in comparison to them.</p><p>即使除了I / O垫尺寸外，也有一个非常大的模拟剖面Tothis高速芯片。除了处理不需要的静电Discharge（ESD）或“清洁”所需的电路所需的电路之外，这包括PLL和几个DLL的内容包括模拟逻辑所需的电源。我从未想过以前的这些组件的设计，并令我惊讶的是与他们相比，数字逻辑似乎小的数字逻辑。</p><p>  Ok, I’ll be honest here, I’ve never used ‘x propagation in any of my designsprior to these ASIC projects. My favorite simulator, Verilator,doesn’t support them as a design decision. SymbiYosys, theformal verification tool I use, always assigns a ‘1 or a ‘0 to every value ina broken trace, and checks all possible values for something that isn’t givena initial value–so I haven’t needed ‘x support.</p><p>  好的，我会在这里诚实，我从未在任何DesignsProir中使用过'x传播到这些ASIC项目。我最喜欢的模拟器Verilator，不支持它们作为设计决策。 Symbiyosys，我使用的完整验证工具，始终将“1或'0分配给每个值ina损坏的跟踪，并检查所有可能的值，以便为初始值 - 所以我没有需要'x支持。</p><p> Then a customer complained that my first ASIC design didn’t work in theirsimulation. I traced the complaint down to one of two problems.</p><p> 然后，客户抱怨说，我的第一个ASIC设计并没有在他们的应用中工作。我将投诉追溯到两个问题之一。</p><p> I’ve enjoyed using  always @(*) blocks for any combinational logic. Inparticular, I’ve enjoyed using this block when dealing with generateblocks like the one below</p><p> 我很喜欢使用任何组合逻辑的@（*）块。单独的，我在处理下面的那样使用此块时使用此块</p><p> reg	 [ N - 1 : 0 ]	 VAL ; generate  if  ( OPT_DESIGN_OPTION ) begin	 always  @ ( posedge  clk )	 begin		 // Some complex block setting VAL	 end end  else  begin	 always  @ ( * )		 VAL  =  CONSTANT ; end  endgenerate</p><p> reg [n  -  1：0] val;生成if（opt_design_option）开始总是@（posedge clk）开始//一些复杂的块设置val结束否则early @（*）val =常数;结束终止</p><p> I like this approach because I don’t need to create second wire to hold the value in  VAL.</p><p> 我喜欢这种方法，因为我不需要创建第二根线以保持val中的值。</p><p> The problem with this approach is that nothing triggers the  always @(*) block. It’s not a problem in hardware,  VAL is given the  CONSTANT as its definition. It’s only a problem in simulation. In simulation,  VAL is not given an initial value and the  always @(*) block is never triggered because nothing within it ever changes. As a result,  VAL remains  x (undefined) in the simulation.</p><p> 这种方法的问题是没有任何攻击始终@（*）块。它不是硬件中的问题，val被赋予常量作为其定义。它只是模拟中的一个问题。在仿真中，VAL没有给出初始值，并且永远不会触发始终@（*）块，因为它内部没有变化。结果，Val在模拟中保持x（未定义）。 </p><p> The SystemVerilog specification fixes this issue somewhat in its definition of  always_comb. However, other than  localparams, I’ve tried to avoid SystemVerilog features so that I can maintain compatibility with the older parsers that are out there.</p><p>SystemVerilog规范在always_comb的定义中有点修复了这个问题。但是，除了LocalParams之外，我试图避免SystemVerilog功能，以便我可以与那里的旧解析器保持兼容性。</p><p> Fixing this forced me to adjust my personal design standards so that  VAL would be defined as a wire (a.k.a. a net) in these constructs. This also meant that I would now need to define a separate register, let’s call it  r_VAL, which the former logic sets. In the end, the wire is then assigned the resulting value either way.</p><p> 修复此迫使我调整我的个人设计标准，使VAL将被定义为这些构造中的电线（A.K.A. A网）。这也意味着我现在需要定义一个单独的寄存器，让我们称之为r_val，前逻辑集。最后，将导线分配任一向得到的值。</p><p> wire	 [ N - 1 : 0 ]	 VAL ; generate  if  ( OPT_DESIGN_OPTION ) begin	 reg	 [ N - 1 : 0 ]	 r_VAL ;	 always  @ ( posedge  clk )	 begin		 // Some complex block setting r_VAL	 end	 assign	 VAL  =  r_VAL ; end  else  begin	 assign	 VAL  =  CONSTANT ; end  endgenerate</p><p> 电线[n  -  1：0] val;生成if（opt_design_option）begin reg [n  -  1：0] r_val;总是@（提出clk）开始//一些复杂的块设置r_val结束指定val = r_val; exhelse begin指定val =常量;结束终止</p><p> Personally I find this cumbersome. However, it’s now going to become part of my personal coding standard lest I come across this bug again. Indeed, there’s now  a version of the  ZipCPU following this new coding guideline as well.</p><p> 就个人而言，我发现这很麻烦。但是，它现在将成为我个人编码标准的一部分，以免再次遇到这个错误。实际上，现在这个新的编码指南之后的zipcpu也有一个版本。</p><p>   In this example,  div_clk isn’t given an initial value because, well, initial values aren’t allowed in ASICs. As long as the hardware can fix the value at either  0 or  1, this clock divider will do the right thing. Even better, I can use formal tools to verify that this simple circuit will do the right thing either way it’s set. The problem is not that the hardware won’t work, the problem is that the simulator won’t work with something like this.  div_clk will be given an initial assignment of ‘x, and anything that depends upon it will then get an ‘x value.</p><p>   在此示例中，div_clk未给出初始值，因为嗯，ASIC中不允许初始值。只要硬件可以在0或1处修复值，这个时钟分频器就会做正确的事情。更好，我可以使用正式的工具来验证这个简单的电路是否会做正确的方式。问题不是硬件不起作用，问题是模拟器无法使用这样的内容。 div_clk将被赋予“x”的初始分配，以及任何取决于它的任何东西都会得到'x值。</p><p> The result of all of this is that I’ve found myself forcing signals to be reset that don’t really need to be reset at all.</p><p> 所有这一切的结果是我发现自己强迫信号被重置，根本不需要重置。</p><p> Up until now, I’ve used  initial statements in my designs quite heavily.They work great in FPGA designs. They just don’t work at all in ASICdesigns.</p><p> 到目前为止，我已经非常重大在我的设计中使用了初始陈述。他们在FPGA设计中工作得很好。他们只是在AsicDesigns中的所有工作。 </p><p>  Worse, because of ‘x propagation issues, any bit that isn’t set by theasynchronous reset gets flagged as an ‘x and shows up like a sore thumb onany simulation trace.</p><p>更糟糕的是，由于'x传播问题，任何由theasynchronous reset设置的位都被标记为'x并显示镜头拇指Onany模拟跟踪。</p><p>  I’ve also avoided asynchronous resets in the past, based upon a commentin some Xilinx documentation suggesting that RF interference might triggeran accidental asynchronous reset. (I’ve since been asked by a Xilinxdesigner to find the document, and … I can’t remember where I found itinitially. They claim asynchronous resets should work just fine.)</p><p>  根据一些Xilinx文档，我还避免了过去的异步重置，这表明RF干扰可能会引发意外异步重置。 （我已经被XilinxDesigner询问找到该文件，...我不记得我在哪里发现它。他们声称异步重置应该很好。）</p><p>  Not so with this design. In this case, every flop was initialized with anasynchronous reset. In some cases, the asynchronous reset would be activelong before the clock ever was.</p><p>  没有那么设计。在这种情况下，每个牌照都以互换复位初始化。在某些情况下，在钟表之前，异步重置将是Activelong。</p><p>  This also affected my formal proofs. My first attempt at proofs withoutinitial statements involved just not evaluating any assertions on thefirst clock cycle of the proof. Now I’m starting to get into the habitof gating all of my formal assertions with a reset check, to make sure thatthe logic works once the reset is accomplished.</p><p>  这也影响了我的正式证据。我的第一次尝试缺少缺乏的缺陷陈述，该声明涉及的缺陷陈述的任何断言在证明的第一个时钟周期中。现在，我开始进入所有正式断言的栖息地，重置检查，以确保在重置完成后，逻辑工作。</p><p>  This also means that my  AXI bus propertysets nowhave options for asynchronous reset checking. If this option is turned on,the AXI property sets will now insist all VALID flags go to zero on thesame clock as the reset, in addition to the clock following.</p><p>  这也意味着我的AXI总线Propersets现在的异步重置检查选项。如果打开此选项，则AXI属性集现在将在CLEAK之外，在CHERS CLACK上，AXI属性集现在将所有有效的标志转到零。</p><p> Perhaps I shouldn’t complain. As I mentioned above, logic is cheap. Once Iknew what was going on, these fixes only took minutes to make. It’s not thelogic that costs so much, it’s the verification part that’s much harder.</p><p> 也许我不应该抱怨。正如我上面提到的那样，逻辑很便宜。一旦我知道发生了什么，这些修复只需花几分钟的时间。这不是那么多的成本，这是验证部分更难的。</p><p>  In FPGAs, there are  rules forclocks. One ofthose rules is that logic generated clocks are bad. In general, FPGA toolscan’t handle the timing analysis of any logic generated clocks,the logic generated clock doesn’t have the same timing relationship as theclock it came from, and it isn’t placed automatically on the clock routingnetwork. These are all reasons why logic generated clocks are generally bad.</p><p>  在FPGA中，有规则码头。一项规则是逻辑生成的时钟很糟糕。通常，FPGA工具库不处理任何逻辑生成的时钟的定时分析，逻辑生成的时钟没有与其来自的Theclock具有相同的时序关系，并且它不会在时钟路由网络上自动放置。这些都是逻辑生成时钟通常坏的原因。 </p><p>  ASIC designs are different. Indeed, once you dig into the weeds of an ASIC,you might start to believe that all clocks are logic generated. You wouldbe right to some extent, because even the PLLs have some amount of logicwithin them.</p><p>AsiC设计是不同的。实际上，一旦你挖掘ASIC的杂草，你可能会开始相信所有时钟都是逻辑生成的。你会在某种程度上做出，因为即使plls也有一定数量的逻辑。</p><p>  Unlike FPGAs, ASICs don’t come with a set of dedicated clock routingnetworks. Instead, the clock trees used within ASIC designs have to beengineered and inserted into the design for each clock that uses them.</p><p>  与FPGA不同，ASIC不带一套专用时钟路由网络。相反，ASIC设计中使用的时钟树必须出现并插入设计中的每个时钟的设计。</p><p>  I grew up in Minnesota, not far from  Lock and Dam number one on theMississippi river. That lock and Damhas since become imagery for me to understand power usage within anelectronic circuit. Imagine, if you will, that every wire within anelectronic design is a lock on a river that can either hold water (i.e.charge) or not. Energy is used every time the lock is filled, and it ismeasured by the amount of water necessary to fill the lock.</p><p>  我在明尼苏达州长大，不远离锁和大坝第一个在Themississpipi河上。锁定和陷阱以来成为我的图像，以了解电路内的功率使用。想象一下，如果您愿意，电动设计中的每根电线都是河上的锁，可以保持水（即充电）。每次填充锁时都使用能量，并且它被填充锁定所需的水量释放。</p><p>  The higher the water level is, that is the higher the core voltage is within a design, the more water that will be necessary to fill the lock. Similarly, the longer the lock is whose water level (a.k.a voltage) needs to be adjusted, the more water it will take to adjust it.</p><p>  水位越高，即核心电压在设计内的越高，填充锁的填充越多。同样，锁定的水位（A.K.A电压）需要调整较长的水位，调整它的水越多。</p><p> Clock trees are equivalent to very long lock chambers throughout the design that all need to be filled. It takes a lot of current to switch the tree from one voltage le</p><p> 时钟树相当于整个设计中的长锁室，所有这些都需要填充。从一个电压LE切换树需要大量的电流</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://zipcpu.com/blog/2021/03/06/asic-lsns.html">https://zipcpu.com/blog/2021/03/06/asic-lsns.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/asic/">#asic</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/learned/">#learned</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>