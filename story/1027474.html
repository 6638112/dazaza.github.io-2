<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>让我们使用WebAssembly和Haskell构建一个Cloudflare工作器</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">让我们使用WebAssembly和Haskell构建一个Cloudflare工作器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-07 08:21:48</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/9927a832d599ad94c40bf43ac809edb0.png"><img src="http://img2.diglog.com/img/2020/10/9927a832d599ad94c40bf43ac809edb0.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>在Stack Builders，我们相信Haskell的表达性静态类型系统为软件行业和依赖我们服务的世界范围内的社区提供了许多好处。为了充分实现这些优势，有必要进行适当的培训并访问允许可靠部署服务的生态系统。在探索帮助我们基于Haskell运行系统的工具时，我们的开发人员Cristhian Motoche创建了一个教程，展示如何使用Asterius将Haskell编译成WebAssembly，以便在Cloudflare上部署。</p><p>CloudFlare Workers是一个无服务器平台，允许我们在CloudFlare基础设施的边缘运行代码。它构建在GoogleV8之上，因此可以用JavaScript或任何其他面向WebAssembly的语言编写功能。</p><p>WebAssembly是一种可移植的二进制指令格式，可以在内存安全的沙箱环境中快速执行。因此，对于需要执行资源要求和独立操作的任务，它特别有用。</p><p>Haskell是一种纯函数式语言，可以面向WebAssembly。因此，它可以帮助开发人员将复杂的任务分解为小功能，稍后可以组合这些小功能来完成复杂的任务。此外，它是静态类型的，并且具有类型推断，因此如果在编译时出现类型错误，它将发出警告。正因为如此，Haskell是一种很好的针对WebAssembly的源语言。</p><p>我们将使用Asterius从Haskell瞄准WebAssembly。这是一个文档丰富的工具，经常更新，并支持许多Haskell特性。</p><p>首先，按照文档中的建议，我们将使用Podman从Docker集线器拉取Asterius预置容器。在本教程中，我们将使用Asterius版本200617，它支持GHC8.8。</p><p>现在，我们将创建一个名为fact.hs的Haskell模块，该文件将导出一个纯函数：</p><p>模块阶乘(FACT)WHERFACT：：INT-&&gt;；Intact n=go n 1 where go 0 acc=acc go n acc=go(n-1)(n*acc)外部导出javascript&#34；FACT&#34；FACT：：INT-&&gt;Int</p><p>在此模块中，我们定义了一个名为Fact的纯函数，该函数使用尾递归进行优化，并使用Asterius JavaScript FFI导出，以便在用JavaScript实例化WebAssembly模块时可以调用它。</p><p>接下来，我们将创建一个名为act_node.mjs的JavaScript文件，其中包含以下代码：</p><p>将*作为RTS从&#34；./rts.mjs&#34；；从&#34；./fact.wasm.mjs&#34；导入模块导入*；从&#34；./fact.req.mjs&#34；；异步函数handleModule(M){const i=await rts.newAsteriusInstance(Object.Assign(req，{module：m}))；const result=await i.exports.act(5)；console.log(result)；}module.then(handleModule)；</p><p>此代码导入rts.mjs(公共运行时)、WebAssembly加载器和Asterius实例所需的参数。它创建一个新的Asterius实例，使用输入5调用导出的函数FACT，并打印出结果。</p><p>您可能已经注意到，事实是异步完成的。Asterius导出的任何函数都会发生这种情况，即使它是纯函数。</p><p>接下来，我们将使用Asterius命令行界面(CLI)ahc-link编译此代码，并在Node中运行JavaScript代码：</p><p>Ahc-link\--input-hs fact.hs\--no-main\--export-function=act\--run\--input-mjs act_node.mjs\--output-dir=node。</p><p>此命令将fact.hs作为Haskell输入文件，指定不导出任何主函数，并导出事实函数。此外，它将factnode.mjs作为默认替换生成文件的入口JavaScript文件，并将生成的代码放在一个名为node的目录中。</p><p>如您所见，结果在节点中执行，并在控制台中打印出事实结果。</p><p>指定wasm_module绑定需要此文件。Name值对应于从工作代码访问WebAssembly模块的全局变量。在我们的示例中，它的名称将为WASM。</p><p>将*作为RTS从&#34；./rts.mjs&#34；导入；从&#34；./fact.req.mjs&#34；导入事实；异步函数handleFact(Param){const i=等待rts.newAsteriusInstance(Object.Assign(Fact，{module：WASM}))；返回等待i.exports.act(Param)；}异步函数handleRequest(Req){if(req.method==&#34；post&#34；){const data=awaitreq.formData()；const param=parseInt(&#34；post&#34；){const data=await req.formData()；const param=parseInt(&#34；POST&#34；){const data=await req.formData()；const param=parseInt(&#34；Param&#34；)；if(Param){const resp=await handleFact(Param)；返回新响应(resp，{status：200})；}Else{在请求为整数&#34；，{status：400}，)中返回新响应(&#34；期望&#39；param&#39；，)；}}返回新响应(&#34；方法不允许&#34；，{status：405})；}addEventListener(&#34；FETCH&#34；，Event=&gt；{event.respondWith(handleRequest(event.request))})。</p><p>HandleFact是一个异步函数，它使用全局WASM模块创建一个Asterius实例，作为Worker全局变量，并使用一些输入调用导出的函数FACT。</p><p>HandleRequest处理工作进程的请求。它需要一个POST请求，请求正文中有一个名为param的参数。如果param是一个数字，它会调用handleFact来响应事实的结果。</p><p>使用服务工作者API，我们监听将以handleRequest结果响应的FETCH事件。</p><p>我们需要构建代码并将其捆绑到单个JavaScript文件中，因为每个Worker只接受一个脚本。幸运的是，Asterius附带了Parcel.js，它将把所有必要的代码捆绑在单个JavaScript文件中。</p><p>Ahc-link\--input-hs fact.hs\--no-main\--export-function=act\--input-mjs act_cfw.mjs\--Bundle\--Browser\--output-dir worker</p><p>AHC-LINK将在名为Worker的目录中生成一些文件。对于我们的工人来说，我们只对JavaScript文件(fact.js)和WebAssembly模块(fact.wasm)感兴趣。现在，是时候把它们都提交给工人了。我们可以使用提供的REST API来实现这一点。</p><p>确保您具有帐户ID($CF_ACCOUNT_ID)、脚本名称($SCRIPT_NAME)和API令牌($CF_API_TOKEN)：</p><p>CD workercurl-X PUT&#34；https://api.cloudflare.com/client/v4/accounts/$CF_ACCOUNT_ID/workers/scripts/$SCRIPT_NAME&#34；\-H&#34；授权：持有者$CF_API_TOKEN&#34；\-F&#34；[电子邮件受保护]；TYPE=应用程序/JSON&#34；\-F&#34；[电子邮件受保护]；TYPE=应用程序/JavaScript&#34；\-F&#34；[电子邮件受保护]；TYPE=应用程序/WASM&#34；</p><p>现在，访问Workers UI，您可以在其中使用编辑器查看、编辑和测试脚本。此外，您还可以在workers.dev子域($cfw_subdomain)上将其启用；在这种情况下，您只需：</p><p>到目前为止，我们已经创建了一个WebAssembly模块，该模块导出我们在Workers中运行的纯Haskell函数。但是，我们也可以使用Asterius AHC-CABAL CLI创建和构建一个Cabal项目，然后使用AHC-dist将其编译为WebAssembly。</p><p>然后，让我们向我们的阴谋项目添加一些依赖项。阴谋文件将如下所示：</p><p>CABAL-版本：2.4名称：CABAL-cfw-examplversion：0.1.0.0许可证：无可执行文件CABAL-cfw-示例GHC-Options：-OPTL--export-function=handleReq main-is：Main.hs build-Dependents：base，bytestring，Aeson&gt；=1.5&amp；&amp；&lt；1.6，文本默认语言：Haskell2010。</p><p>这是一个简单的CABAL文件，除了-OPTL--export-function=handleReq GHC标志。这在从CABAL项目导出函数时是必需的。</p><p>在本例中，我们将定义一个简单的用户记录，并使用模板Haskell自动定义其实例！</p><p>{-#language OverloadedStrings#-}{-#language TemplateHaskell#-}模块main其中import Asterius.Typesimport Control.Monadimport Data.Aeson Hidding(Object)导入限定数据。Aeson as Aimport Data.Aeson.THimport Qualified Data.ByteString.Lazy.Char8 as B8import Data。Textmain：：IO()main=putStrLn&#34；CFW Cabal&#34；Data User=user{name：：text，age：：int}$(DerveJSON defaultOptions&#39；user)：：IO()main=putStrLn&#34；cfw Cabal&#34；data user=user{name：：text，age：：int}$(DerveJSON defaultOptions&#39；user)。</p><p>注意：这个示例没有必要创建一个Cabal项目，因为预构建的容器附带了很多预构建的包(包括Aesona)。然而，它将帮助我们展示AHC-阴谋和AHC-Dist的潜力。</p><p>接下来，我们将定义handleReq，我们将像以前一样使用JavaScript FFI导出它。</p><p>HandleReq：：JSString-&gt；JSString-&gt；IO JSObjecthandleReq方法rawBody=case from&#34；post&#34；-&gt；让&#34；POST&#34；-&gt；的JS_NEW_RESPONSE方法中的任一个User：：Right_-&gt；js_new_Response(toJSString&#34；SUCCESS！&#34；)200 Left Err-&gt；js_new_response(ToJSerr)400_&gt；js_new_response(toJSString&#34；js_new_response(toJSerr&#34；)不是有效方法#34；的情况下，让字符串user=eitherDecode(B8.pack$fromJSString rawBody)。)405外来导出javascript&#34；handleReq&#34；handleReq：：JSString-&gt；JSString-&gt；IO JSObjectforeign import javascript&#34；new Response($1，{\&#34；status\&#34；：$2})&#34；js_new_response：：JSString-&gt；Int-&gt；IO JSObject。</p><p>这一次，我们定义了js_new_response，这是一个创建JavaScript对象的Haskell函数，用于创建响应。HandleReq从JavaScript获取两个字符串参数，并使用它们准备响应。</p><p>这将为我们的可执行文件生成一个名为Cabal-cfw-example的二进制文件。我们将使用AHC-dist来获取该二进制文件和目标WebAssembly：</p><p>从&#34；./rts.mjs&#34；./rts.mjs&#34；导入*as rts；；从&#34；./Cabal_cfw_example.req.mjs&#34；导入CABAL_CFW_Example；异步函数handleRequest(Req){const i=等待rts.newAsteriusInstance(Object.assign(cabal_cfw_example，{模块：wasm}))；const body=等待req.text()；返回等待i.exports.handleReq(req.method，body)；}addEventListener(&#34；FETCH&#34；，Event=&gt；{event.respondWith(handleRequest(event.request))})；</p><p>最后，我们可以像以前一样定义metadata.json文件并使用Workers API上传脚本和WebAssembly模块，从而将代码部署到Worker。</p><p>Worker限制您的JavaScript和WebAssembly的文件大小。因此，您需要小心处理添加的任何依赖项。</p><p>堆栈构建器通过诸如表达性静态类型之类的技术构建更好的软件，以便更好地生活。我们使用Asterius将Haskell编译为WebAssembly，并使用Workers API将其部署到Cloudflare Workers。Asterius支持很多Haskell特性(例如模板Haskell)，并且它提供了一个易于使用的JavaScript FFI来与JavaScript交互。此外，它还提供了包含大量Haskell包的预构建容器，因此您可以立即开始编写脚本。</p><p>按照这种方法，我们可以用Haskell编写功能性类型安全代码，将其定向到WebAssembly，然后将其发布到在Cloudflare基础设施边缘运行的Workers。</p><p>CloudFlare工作人员Haskell WebAssembly WASM CFW</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.cloudflare.com/cloudflare-worker-with-webassembly-and-haskell/">https://blog.cloudflare.com/cloudflare-worker-with-webassembly-and-haskell/</a></div><div class="story_tags page_narrow"></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>