<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何使用Python、Transformers和Scikit对文本进行分类How to Classify Text with Python, Transformers and Scikit-Learn</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to Classify Text with Python, Transformers and Scikit-Learn<br/>如何使用Python、Transformers和Scikit对文本进行分类</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-26 07:15:45</div><div class="page_narrow text-break page_content"><p>There’s an enormous amount of text out there, and more and more of it is generated every day in the form of emails, social media posts, chats, websites, and articles. All these text documents are rich sources of information. But because of the unstructured nature of the text, understanding and analyzing it is difficult and time-consuming. As a result, most companies are not able to leverage this invaluable source of information. This is where Natural Language Processing (NLP) methods like text classification come in.</p><p>那里有大量的文本，每天都有越来越多的文本以电子邮件、社交媒体帖子、聊天、网站和文章的形式生成。所有这些文本文件都是丰富的信息来源。但由于文本的非结构化性质，理解和分析它既困难又耗时。因此，大多数公司无法利用这一宝贵的信息来源。这就是文本分类等自然语言处理（NLP）方法的用武之地。</p><p>       Text classification, also known as  text categorization or  text tagging, is the process of assigning a text document to one or more categories or classes. It enables organizations to automatically structure all types of relevant text in a quick and inexpensive way. By classifying their text data, organizations can get a quick overview of the trends and also narrow down sections for further analysis.</p><p>文本分类，也称为文本分类或文本标记，是将文本文档分配给一个或多个类别或类别的过程。它使组织能够以快速、廉价的方式自动构建所有类型的相关文本。通过对文本数据进行分类，组织可以快速了解趋势，并缩小范围进行进一步分析。</p><p>     Let’s say you are hired by an organization to help them sort through their customer reviews. First things first, if the organization has a global customer base and there are reviews written in multiple languages, dividing them based on their language will help with downstream tasks.</p><p>假设你受雇于一家公司，帮助他们整理客户评论。首先，如果组织有一个全球客户群，并且有多种语言编写的评论，根据其语言进行划分将有助于完成下游任务。</p><p>     As uplifting and fulfilling as positive reviews are, they rarely contain any urgent issues that need to be addressed immediately. So, it might be a good idea to perform sentiment analysis and classify the reviews as positive and negative. Here your previous language classification will come in handy for making language-specific sentiment analysis models.</p><p>尽管积极的评价令人振奋和满足，但它们很少包含任何需要立即解决的紧迫问题。因此，进行情绪分析并将评论分为正面和负面可能是一个好主意。在这里，您以前的语言分类将有助于创建特定于语言的情感分析模型。</p><p>  Once you have the negative reviews, you can further categorize them by feature/product mentioned. This will enable different teams to easily find relevant reviews and figure out what they’re doing wrong or what improvements need to be made.</p><p>一旦你有了负面评论，你可以根据提到的功能/产品对其进行进一步分类。这将使不同的团队能够轻松找到相关的评论，并找出他们做错了什么或需要进行哪些改进。</p><p>      Manual text classification involves a human annotator, who reads through the contents of the text documents and tags them. Now you might think that this method only causes problems when you’re working with large amounts of text. But you would be wrong to think so, here are two reasons:</p><p>手动文本分类涉及人工注释员，他通读文本文档的内容并对其进行标记。现在你可能会认为这种方法只会在处理大量文本时产生问题。但你这么想是不对的，有两个原因：</p><p>   As a side effect of being slow, manual classification hinders an organization’s ability to quickly identify and respond to critical situations. For instance, let’s say a cloud provider or an API goes down, if a person is sequentially going through the customer support tickets, it might take the organization a while to realize that their services are down.</p><p>作为缓慢的副作用，手动分类会妨碍组织快速识别和应对关键情况的能力。例如，假设一个云提供商或一个API宕机，如果一个人正在按顺序查看客户支持票证，组织可能需要一段时间才能意识到他们的服务宕机。</p><p>   Humans are imperfect beings even on their best days. They’re prone to making mistakes due to factors like lack of sleep, boredom, distractions, etc. These can cause inconsistent classifications. For critical applications, these lapses can cost the organization thousands of dollars.</p><p>即使在最美好的日子里，人类也是不完美的。由于睡眠不足、无聊、分心等因素，他们容易犯错误。这些因素可能导致分类不一致。对于关键应用程序，这些失误可能会让公司损失数千美元。</p><p>  And beyond these disadvantages, human hours cost considerably more than running a Python script on a cloud server. So performing   automatic text classification by applying natural language processing and other AI techniques is the best choice for most cases. Automatic classification is faster and more cost-effective. And on top of that, once a text classification model is trained to satisfactory specifications, it performs consistently.</p><p>除了这些缺点之外，人工时间的成本远远高于在云服务器上运行Python脚本。因此，应用自然语言处理和其他人工智能技术进行自动文本分类是大多数情况下的最佳选择。自动分类速度更快，成本效益更高。最重要的是，一旦文本分类模型训练到令人满意的规格，它的性能就会保持一致。</p><p>  There are many ways to automatically classify text documents, but all the methods can be  classified into three types:</p><p>有很多方法可以自动对文本文档进行分类，但所有方法都可以分为三种类型：</p><p>   Rule-based methods use a set of manually created linguistic rules to classify text. These rules consist of a pattern or a set of patterns for each of the categories. A very simple approach could be to classify documents based on the occurrences of category-specific words.</p><p>基于规则的方法使用一组手动创建的语言规则对文本进行分类。这些规则由每个类别的一个模式或一组模式组成。一种非常简单的方法是根据特定类别单词的出现情况对文档进行分类。</p><p>  Say that you want to classify news articles into two classes:  Business and  Science. To do this you’ll need to create two lists of words that categorize each class. For instance, you could choose names of organizations like Goldman Sachs, Morgan Stanley, Apple, etc. for the business class, and for the science class, you could choose words like NASA, scientist, researchers, etc.</p><p>假设你想把新闻文章分为两类：商业和科学。要做到这一点，你需要创建两个单词列表，对每个类别进行分类。例如，你可以选择高盛、摩根士丹利、苹果等机构的名称。在商务课上，你可以选择NASA、科学家、研究人员等词汇。</p><p>  Now, when you want to classify a news article, the rule-based classifier will count the number of business-related words and science-related words. If the number of business-related words is greater than science-related words then the article will be classified as Business and vice versa.</p><p>现在，当你想对一篇新闻文章进行分类时，基于规则的分类器将统计与商业相关的词和与科学相关的词的数量。如果与商业相关的单词数量大于与科学相关的单词数量，则文章将被归类为商业，反之亦然。</p><p>      International Space Station: How NASA Plans To Destroy It” as science because there is one science-related word - “NASA” and no business-related words.</p><p>国际空间站：美国宇航局计划如何摧毁它作为科学，因为有一个与科学有关的词——“NASA”，而没有与商业有关的词。</p><p>  The biggest advantage of using rule-based systems is that there easy to understand by laymen. So once a bare-bones system is created, it can be incrementally improved over time. But the other side of this advantage is that the developers need deep knowledge of the domain to create the rules. Moreover, rule-based classification methods don’t scale well as adding new rules without proper testing can affect the results of older rules.</p><p>使用基于规则的系统的最大优点是，外行很容易理解。因此，一旦创建了一个基本系统，它就可以随着时间的推移而逐步改进。但这种优势的另一方面是，开发人员需要对领域有深入的了解才能创建规则。此外，基于规则的分类方法不能很好地扩展，在没有适当测试的情况下添加新规则可能会影响旧规则的结果。</p><p>    Instead of defining the rules manually, you can choose a machine learning-based method that automatically learns the rules using past observations. Machine learning-based classifiers use labeled examples as training data to learn associations between words/phrases and the labels, i.e., the categories.</p><p>您可以选择一种基于机器学习的方法，使用过去的观察自动学习规则，而不是手动定义规则。基于机器学习的分类器使用带标签的示例作为训练数据来学习单词/短语和标签之间的关联，即类别。</p><p>  Now, that sounds easy enough to tackle, but there’s one problem you need to solve before you can train your machine learning classifier. Feature extraction. You see, computers don’t understand the text as we do, they only understand numbers, 0s &amp; 1s. In the case of computer vision problems, the images are internally stored in the form of numbers representing the values of the individual pixels.</p><p>这听起来很容易解决，但在训练机器学习分类器之前，有一个问题需要解决。特征提取。你看，计算机不像我们那样理解文本，它们只理解数字、0和；1s。在计算机视觉问题的情况下，图像以数字的形式存储在内部，表示各个像素的值。</p><p>  But that isn’t the case for text. So, the first step for training an NLP classifier is to transform the text into a numerical vector representation. One of the most commonly used text embedding methods is bag of words. It creates a vector that counts the occurrences of each word in a predefined dictionary.</p><p>但文本并非如此。因此，训练NLP分类器的第一步是将文本转换为数字向量表示。最常用的文本嵌入方法之一是单词包。它创建一个向量，统计每个单词在预定义词典中的出现次数。</p><p>  Let&#39;s say you define the dictionary as:  “(What, a, sunny, serene, beautiful, day, night)”, and you want to create the vector embedding of the sentence “What a serene night”. You would end up with the following vector representation for the sentence:  (1, 1, 0, 1, 0, 0, 1).</p><p>让&#39；假设你将字典定义为：“（What，a，sunny，serene，beautiful，day，night）”，你想创建一个嵌入句子“What a serene night”的向量。你会得到以下句子的向量表示法：（1，1，0，1，0，0，0，1）。</p><p>  After you have generated the vector representation of all the labeled text documents, you can use them to train a classifier. The vector representation of text documents is passed to the classifier with their correct categories. The model learns the associations between different linguistic features in the text and the categories:</p><p>生成所有带标签文本文档的向量表示后，可以使用它们来训练分类器。文本文档的向量表示将传递给分类器，并带有正确的类别。该模型学习文本中不同语言特征与类别之间的关联：</p><p>     Once the model has been trained up to the required performance standards, it can be used to make accurate predictions. The same feature extraction method is used to create the vector representation of the new text documents. The classification model uses these feature vectors to predict the categories of the documents.</p><p>一旦模型被训练到所需的性能标准，它就可以用来做出准确的预测。使用相同的特征提取方法创建新文本文档的矢量表示。分类模型使用这些特征向量来预测文档的类别。</p><p>    Machine learning-based text classification methods are generally more accurate than rule-based classifiers. Besides that, machine learning classifiers are easier to scale as you can simply add new training examples to update the model. The only problem with machine learning classifiers is that they are hard to understand and debug. So if something goes wrong, it can be hard to figure out what caused the issue.</p><p>基于机器学习的文本分类方法通常比基于规则的分类器更准确。除此之外，机器学习分类器更容易扩展，因为您可以简单地添加新的训练示例来更新模型。机器学习分类器的唯一问题是它们很难理解和调试。因此，如果出现问题，可能很难找出问题的原因。</p><p>  Hybrid text classification methods combine the best of both worlds. They combine the generalization ability of the machine learning classifier with the easy-to-understand and tweak rule-based methods. They can learn complex rules thanks to the machine learning model, and any conflicting classifications or erratic behavior can be fixed using rules.</p><p>混合文本分类方法结合了这两个方面的优点。它们将机器学习分类器的泛化能力与易于理解和调整的基于规则的方法相结合。多亏了机器学习模型，他们可以学习复杂的规则，任何冲突的分类或不稳定的行为都可以使用规则修复。</p><p>  Take for instance the task of classifying financial news articles based on their industrial sectors such as pharma, finance, automotive, mining, etc. To do this you can create a hybrid system. First, train a named entity recognition model that extracts company names from the news articles. Then, create a list of the companies in each sector. And that&#39;s it, using these two things you can create a competent classifier.</p><p>例如，根据行业对金融新闻文章进行分类，如制药、金融、汽车、采矿等。要做到这一点，你可以创建一个混合系统。首先，训练一个命名实体识别模型，从新闻文章中提取公司名称。然后，创建每个部门的公司列表。那&#39；就是这样，使用这两件事你可以创建一个合格的分类器。</p><p>         You&#39;ll be working with some of our old Google News data dumps. The news data is stored in the JSONL format. Normally you can load JSONL files into a   DataFrame using the   read_json method with the   lines=True argument, but our data is structured a bit weirdly.</p><p>你&#39；我们将处理一些旧的谷歌新闻数据转储。新闻数据以JSONL格式存储。通常，您可以使用read_json方法将JSONL文件加载到数据帧中，并使用lines=True参数，但我们的数据结构有点奇怪。</p><p>     Each of the individual entries is stored within an Object ( enclosed within    {&#39;item&#39;:}). So, if you try to load it straight away with the   read_json method   it will load all of it as one column.</p><p>每个条目都存储在一个对象中（包含在{&#39；item&#39；：}中）。因此，如果您尝试使用read_json方法直接加载它，它会将所有内容作为一列加载。</p><p>     To fix this, you can read the file like a normal text file and use the   json.loads method to create a list of dictionaries.</p><p>要解决这个问题，可以像读取普通文本文件一样读取该文件，并使用json。加载方法以创建字典列表。</p><p>     There is still an issue to deal with 😬. The value of the attributes for each headline is stored inside its own object. Fret not, you can quickly fix it with some more dictionary manipulation.</p><p>还有一个问题需要解决😬. 每个标题的属性值存储在它自己的对象中。不用担心，你可以通过更多的字典操作快速修复它。</p><p>             You don&#39;t really need the other attributes like   country,   lang, or   cleaned_url.  And the  topic labels-&#39;WORLD&#39; and &#39;NATION&#39; are not very informative as their definition is very loose. So, you can  drop them off.</p><p>你没有&#39；我真的不需要其他属性，比如国家、语言或url。以及主题标签&#39；世界&#39；和&#39；国家&#39；它们的定义非常松散，因此信息量不大。所以，你可以把它们放下。</p><p>      Next, you should take a look at how many training examples we have for each category.</p><p>接下来，您应该看看我们为每个类别提供了多少培训示例。</p><p>      More than 350000 articles for the two biggest categories and even the small group has about 40000 examples!</p><p>两大类超过35万篇文章，甚至小组也有大约4万个例子！</p><p>          Jokes aside, as you&#39;re going to use the state-of-the-art BERT transformer model to create the vector representations, I recommend that you train the models with a subset of the available dataset.</p><p>除了笑话，就像你&#39；我们将使用最先进的BERT transformer模型来创建向量表示，我建议您使用可用数据集的子集来训练模型。</p><p>   Now you can load the BERT sentence transformer and create the vector embedding for the headlines.</p><p>现在，您可以加载BERT句子转换器，并为标题创建向量嵌入。</p><p>            The Support Vector Classifier(SVM) comes out on top. You can use this to predict the topic of new news headlines.</p><p>支持向量分类器（SVM）位居榜首。你可以用它来预测新新闻标题的主题。</p><p>           There you have it. You now know what text classification is, how it works, and how you can train your own machine learning text classifiers. But hey, what about neural networks? That&#39;s a good question! The thing is, as good as neural networks are they are not really necessary for this task. Both SVMs and NNs can approximate non-linear decision boundaries, and they both achieve comparable results on the same dataset. Neural networks can pull ahead in performance but they need a lot more computational power, training data, and time.</p><p>给你。现在，您知道什么是文本分类，它是如何工作的，以及如何培训自己的机器学习文本分类器。但是，神经网络呢？那&#39；这是个好问题！问题是，尽管神经网络很好，但对于这项任务来说，它们并不是真正必要的。支持向量机和神经网络都能逼近非线性决策边界，在同一个数据集上都能得到可比的结果。神经网络可以在性能上领先，但它们需要更多的计算能力、训练数据和时间。</p><p>  On the other hand, support vector machines can reliably identify the decision boundary based on the sole support vectors. Therefore, you can train an SVM classifier with a small subset of the data you would need to train a neural network that achieves similar performance. If, however, any marginal increase in performance is beneficial for your application feel free to go with neural networks.</p><p>另一方面，支持向量机能够基于唯一的支持向量可靠地识别决策边界。因此，您可以使用训练达到类似性能的神经网络所需的一小部分数据来训练SVM分类器。然而，如果性能的任何微小提高都有利于应用程序，那么可以使用神经网络。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/text/">#text</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/分类/">#分类</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>