<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>MemraphDB：为什么以及如何实现Bolt协议v4</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">MemraphDB：为什么以及如何实现Bolt协议v4</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-30 02:39:06</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/376dd510ea02f190d389d1997cc26b0d.jpg"><img src="http://img2.diglog.com/img/2020/10/376dd510ea02f190d389d1997cc26b0d.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Today, we’re proud to announce the release of  Memgraph 1.2, which significantly improves Memgraph’s compatibility with the broader graph ecosystem. This makes it easier for developers and data scientists to work with Memgraph using their favourite tools.</p><p>今天，我们自豪地宣布发布Memgraph 1.2，它显著提高了Memgraph与更广泛的图形生态系统的兼容性。这使得开发人员和数据科学家更容易使用他们喜欢的工具来使用Memgraph。</p><p> One of the biggest changes in this release, is the addition of Bolt v4 and v4.1 support.</p><p>此版本中最大的变化之一是增加了Boltv4和v4.1支持。</p><p> In this post, we will explore what exactly is the Bolt protocol, what it brings to the table, and how we implemented it into Memgraph.</p><p>在这篇文章中，我们将探索Bolt协议到底是什么，它给我们带来了什么，以及我们是如何在Memgraph中实现它的。</p><p>  If you’re thinking about using Memgraph in your application, one of therequirements is the possibility of querying Memgraph directly from yourapplication with as little effort as possible. You can achieve that by writingdrivers for the Memgraph server in the language you want to support. Drivers arespecial libraries that follow predefined rules, aka a protocol, to communicate betweenyour application and a server.</p><p>如果您正在考虑在您的应用程序中使用Memgraph，其中一个要求是可以尽可能少地直接从您的应用程序中查询Memgraph。您可以通过用您想要支持的语言编写Memgraph服务器的驱动程序来实现这一点。驱动程序是遵循预定义规则(也称为协议)的特定库，用于在应用程序和服务器之间进行通信。</p><p> Instead of defining its own rules, Memgraph decided to use Neo4j’s protocolcalled  Bolt. There are 3 important reasons for thisdecision:</p><p>Memgraph没有定义自己的规则，而是决定使用Neo4j的称为Bolt的协议。做出这一决定有三个重要原因：</p><p> Neo4j also uses  Cypher (that doesn’t mean that the Bolt protocol can’t be used for other query languages!)</p><p>Neo4j也使用Cypher(这并不意味着Bolt协议不能用于其他查询语言！)。</p><p>   In other words, by making our server compatible with the Bolt protocol, you canuse Memgraph in any of the languages and frameworks listed above just by usingNeo4j’s libraries.</p><p>换句话说，通过使我们的服务器与Bolt协议兼容，您只需使用Neo4j的库就可以在上面列出的任何语言和框架中使用Memgraph。</p><p>  First, we need to know how to exchange messages. Bolt exchanges its messages using a request-response pattern between the client and the server. Each request message can be followed by zero or record messages which are then followed by one summary message. The different possibilities for record messages depends on the type of the request message.</p><p>首先，我们需要知道如何交换信息。Bolt在客户端和服务器之间使用请求-响应模式交换消息。每条请求消息后面可以跟零个或记录消息，然后这两个消息后面跟一个摘要消息。记录消息的不同可能性取决于请求消息的类型。</p><p>     Also, we need to know how to serialize our data. Bolt uses its own PackStream which provides specification for serializing a bunch of different types of data. It is fully compatible with the typessupported by Cypher. We won’t go into details but every type is defined with its marker, its size and its data.</p><p>此外，我们还需要知道如何序列化我们的数据。Bolt使用自己的PackStream，它为序列化一系列不同类型的数据提供了规范。它与Cypher支持的类型完全兼容。我们不会深入讨论细节，但是每种类型都是用它的标记、大小和数据来定义的。</p><p>   One of those types is a structure. The size of the structure defines how many fieldsit contains and the fields can be of any other type. But we’re missing animportant information. How do we know what the structure represents? Structurescarry additional data, its tag byte. This tag tells us what does the structurerepresent. We’re now half way through to understanding how to define request andresponse messages.</p><p>其中一种类型是结构。结构的大小定义了包含多少字段，字段可以是任何其他类型。但我们遗漏了一条重要信息。我们怎么知道这个结构代表什么呢？结构承载附加数据，其标记字节。这个标签告诉我们这个结构代表什么。我们现在已经理解了如何定义请求和响应消息。</p><p> We can’t expect that our data will always be small enough to send it all atonce. To solve this problem, Bolt defines how the message is chunked. Each chunkis starts with two-byte header that tells us the size of chunk data in bytesfollowed by the chunk data itself. Now, we have another problem. How do we knowif we received the last chunk of message? We just add a marker! In our case weappend to the end of the last chunk  00 00.</p><p>我们不能指望我们的数据总是足够小，可以一次发送所有数据。为了解决这个问题，Bolt定义了消息的分块方式。每个块都以两字节头开始，它告诉我们块数据的大小(以字节为单位)，然后是块数据本身。现在，我们有了另一个问题。我们怎么知道我们是否收到了最后一段消息呢？我们只要加个记号笔就行了！在我们的情况下，武器一直到最后一块00 00。</p><p> Now, we have everything we need to define our messages. We can define each typeof request/response message as a unique structure, having a unique set of fields.We can send the defined structure using the chunking method defined before.We’re set! We can serialize and deserialize messages now!</p><p>现在，我们已经拥有了定义我们的信息所需的一切。我们可以将每种类型的请求/响应消息定义为唯一的结构，具有唯一的字段集。我们可以使用前面定义的分块方法发送定义的结构。我们设置好了！我们现在可以序列化和反序列化消息了！</p><p>  A good protocol specification should contain as much information as possible.Without enough information, we can only guess how our server or client shouldbehave in some situations, causing a lot of headache for every developer thattries to implement that protocol.</p><p>一个好的协议规范应该包含尽可能多的信息。没有足够的信息，我们只能猜测我们的服务器或客户端在某些情况下应该如何运行，这给每个试图实现该协议的开发人员带来了很多令人头疼的问题。</p><p> So, as a good protocol, Bolt defines how to parse different types of requestmessage and send the correct response message. It defines how each requestmessage looks and what to send as a response message in each possiblesituation. Also, it defines the state of server after each request message andits outcome.</p><p>因此，作为一个很好的协议，Bolt定义了如何解析不同类型的请求消息并发送正确的响应消息。它定义了每个请求消息的外观，以及在每个可能的情况下作为响应消息发送的内容。此外，它还定义了每个请求消息及其结果之后的服务器状态。</p><p> If want to delve deeper into the Bolt Protocol specifications, you can find everything  here.</p><p>如果想要更深入地研究Bolt协议规范，您可以在这里找到所有内容。</p><p>   Implementing rules is not hard, but to do it efficiently requires a lot ofcareful planning and having a good understanding of how the protocol works.</p><p>实现规则并不难，但要有效地实现它，需要进行大量仔细的规划，并对协议的工作原理有很好的理解。</p><p>   As with any software, protocols are susceptible to change. Bolt defines it’sversion using major and minor versions. At the start of each connection, theclient needs to do a handshake with the server.</p><p>与任何软件一样，协议很容易更改。Bolt使用主要版本和次要版本来定义它的版本。在每个连接开始时，客户端需要与服务器握手。</p><p>    Yes, Memgraph does support the Bolt protocol. But up until now, it only supported Bolt v1, while the current version is 4.1. By looking at the handshake process we can conclude that the client can support  at most four versions. The logical thinking is that the client will always support the latest 4 versions. At the time of writing this, the latest version is v4.1, which pushed v1 out of the support list, making us, and everyone else that wanted to try Memgraph using Neo4j’s drivers, very sad.</p><p>是的，Memgraph确实支持Bolt协议。但到目前为止，它只支持Bolt v1，而目前的版本是4.1。通过查看握手过程，我们可以得出结论，客户端最多只能支持四个版本。合乎逻辑的想法是，客户端将始终支持最新的4个版本。在写这篇文章的时候，最新的版本是v4.1，它把v1赶出了支持列表，这让我们和其他所有想要使用Neo4j的驱动程序来尝试Memgraph的人感到非常难过。</p><p>    It’s important to emphasize that after version 1.0, newer versions weren’t documented,which made keeping up with the newer versions really hard. But, after v4.1, Neo4jdecided to document every version nicely making our lives much easier. ThanksNeo4j!</p><p>需要强调的是，在1.0版之后，没有记录更新的版本，这使得跟上更新的版本变得非常困难。但是，在4.1版之后，Neo4j决定很好地记录每个版本，让我们的生活变得容易得多。感谢Neo4j！</p><p>   Since Memgraph was only compatible with the first version of the Bolt protocol, we had three major and one minor version change to catch up with.Most of it was just some basic additions to the already existing messages, but there were also some bigger changes. For example, we made the decision to preserve support for Bolt v1. This has been very challenging as one of the hardest things in programming is making bigger changes to an existing code while not breaking the old behaviour.</p><p>因为Memgraph只与Bolt协议的第一个版本兼容，所以我们有三个主要的和一个小的版本更改要跟上，大部分只是对现有消息的一些基本添加，但也有一些更大的更改。例如，我们决定保留对Bolt v1的支持。这是非常具有挑战性的，因为编程中最困难的事情之一是在不破坏旧行为的情况下对现有代码进行更大的更改。</p><p>  Handling a code that behaves differently for each version can be hard. After wedecide on a version for a specific connection, we need to be careful which messagesare allowed for that version, which response should each message produce, whatparameters are allowed, and many more things. And to do that while reusing as muchof code as possible, with the addition of keeping the readability can be a challenge.The only real advice I can give you here is write as many tests that will cover asmuch as possible because a smallest detail can make your server misbehave whileimplementing a support for a protocol.</p><p>处理每个版本行为不同的代码可能很困难。在我们决定了特定连接的版本之后，我们需要注意该版本允许哪些消息、每条消息应该生成哪个响应、允许哪些参数，等等。要做到这一点，同时尽可能多地重用代码，并保持可读性，这可能是一个挑战。在这里，我能给您的唯一真正的建议是编写尽可能多的测试，这些测试将覆盖尽可能多的内容，因为最小的细节可能会使您的服务器在实现对协议的支持时行为不正常。</p><p>  In Bolt v3, new request messages for handling transactions were added. Those messagesare for starting an explicit transaction and ending the transaction bycommitting or rollbacking the changes.Because we already had support for transactions and you could already dothe same thing by running queries consisting of  BEGIN,  COMMIT and  ROLLBACKcommands, the only thing we had to do was add functions that directly run thosequeries when the corresponding request was received.</p><p>在Boltv3中，添加了处理事务的新请求消息。这些消息用于通过提交或回滚更改来启动显式事务和结束事务。因为我们已经支持事务，并且您已经可以通过运行由BEGIN、COMMIT和ROLLBACK命令组成的查询来做同样的事情，所以我们唯一需要做的就是添加在收到相应请求时直接运行这些序列的函数。</p><p>  The biggest change to the Bolt protocol was the change to the  PULL and DISCARD message.Before we delve deeper, let’s explain those messages.When you want to run a query on a server using Bolt messages, first you need tosend a  RUN message that contains the query we want to execute. To get the resultsof the query we send a  PULL message, and if we want to discard the results,we simply send the  DISCARD message. The natural way of handling this is preparingthe query when we receive the  RUN message and executing it when we receive the PULL message. Additionally, to avoid wasting memory, we don’t keep the result, wejust forward it to the encoder and send it directly to the client.</p><p>对Bolt协议最大的更改是对拉和丢弃消息的更改。在我们深入研究之前，让我们先解释一下这些消息。当您要使用Bolt消息在服务器上运行查询时，首先需要发送包含我们要执行的查询的Run消息。为了获得查询的结果，我们发送一条Pull消息，如果我们想丢弃结果，只需发送Discard消息即可。处理这种情况的自然方法是在我们收到Run消息时准备查询，并在我们收到Pull消息时执行它。此外，为了避免浪费内存，我们不保存结果，只需将其转发给编码器，然后直接发送给客户端。</p><p> In Bolt v1, there were  PULL_ALL and  DISCARD_ALL messages. As their name suggests,the only options you had was all or nothing. Taking this into account, we developeda solution that would simply stream all the results to the client after it receives PULL_ALL message. But, since v4.0, things got a little more complicated.The  PULL_ALL message was renamed to  PULL. Additionally, the  PULL message can come with some extra parameters.</p><p>在Boltv1中，有Pull_ALL和DIRECAD_ALL消息。顾名思义，你唯一的选择就是要么全有要么什么都没有。考虑到这一点，我们开发了一个解决方案，在客户端收到PULL_ALL消息后，它将简单地将所有结果流式传输到客户端。但是，从V4.0开始，事情变得稍微复杂一些。Pull_All消息被重命名为Pull。此外，Pull消息可以带有一些额外的参数。</p><p>   You can now pull an arbitrary number of results. This small change implies a lot ofchanges to the existing code. The easiest solution would be to execute the query on thefirst pull and save all of the results in memory. After that, for each pull, we justsend next  n results. Even though it’s the easiest solution to implement, it’s tooinefficient memory-wise. Taking this into account, we have a hard requirement ofkeeping the old, lazy behaviour while not keeping any of the results in memory.</p><p>现在，您可以提取任意数量的结果。这一小小的更改意味着对现有代码的大量更改。最简单的解决方案是在第一次拉入时执行查询，并将所有结果保存在内存中。在那之后，对于每一次拉取，我们只发送下一个n个结果。尽管这是最容易实现的解决方案，但在内存方面效率太低。考虑到这一点，我们有一个严格的要求，既要保留旧的、懒惰的行为，又不能在内存中保留任何结果。</p><p> There are different types of queries and each query demands a different approach toachieve this behaviour. Queries with a constant size of the result, like profiling andexplain queries, can have a simple vector of results from which the results arelazily pulled. For most of the queries that have variable size of the result, weprepare all the necessary resources for the execution and ask for the next result onlywhen it’s needed after which the results are streamed instantly to the client.The resources are cleaned after the  PULL request that returned thelast result. This is possible because of Memgraph’s lazy way of handling the execution.</p><p>有不同类型的查询，每个查询需要不同的方法来实现此行为。具有恒定结果大小的查询(如概要分析和解释查询)可以有一个简单的结果矢量，从该矢量中可以相对地提取结果。对于大多数结果大小可变的查询，我们为执行准备所有必要的资源，只在需要的时候才请求下一个结果，然后将结果立即流式传输到客户端。资源在返回上一个结果的Pull请求之后被清理。这是可能的，因为Memgraph懒惰地处理执行。</p><p> The query that was surprisingly the hardest to implement lazily was the  DUMP query.By itself, it’s really simple to implement this query. You analyse different parts ofyour database and, as a result, send a query that defines that part. For example, weiterate each vertex in our database, and we send back a query for creating that vertex.As we said before, creating vertices is only part of the  DUMP query result. We need todo the same thing for many different parts, like defining indexes and constraints, andwith the new Bolt protocol we need to do everything lazily. That means that the executionof  DUMP query can stop in any part, at any time. A solution we ended up going with wasdefining each part as a self-contained chunk. Each chunk needs to keep track of its statusto continue from where it left off and to know when it finished. We also need to definean object that will iterate those chunks, continuing to the next chunk only when thethe previous was finished. This way we don’t need to think about other chunks while definingeach chunk. We can easily add a new chunk by implementing a specific interface, and the mostthe important thing is, no results are kept in memory.</p><p>令人惊讶的是，最难实现的查询是转储查询，就其本身而言，实现该查询非常简单。您分析数据库的不同部分，结果是发送定义该部分的查询。例如，我们迭代数据库中的每个顶点，然后发回创建该顶点的查询。如前所述，创建顶点只是转储查询结果的一部分。我们需要为许多不同的部分做同样的事情，比如定义索引和约束，使用新的Bolt协议，我们需要懒惰地做每件事。这意味着转储查询的执行可以在任何地方、任何时间停止。我们最终采用的一个解决方案是将每个部分定义为一个独立的块。每一块都需要跟踪它的状态，以便从它停止的地方继续，并知道它什么时候结束。我们还需要定义将迭代这些块的对象，仅当前一个块完成时才继续到下一个块。这样，我们在定义每个块时就不需要考虑其他块了。我们可以通过实现特定的接口轻松地添加新的块，最重要的是，没有结果保存在内存中。</p><p>   While in explicit transaction, each  RUN message returns a  qid which uniquely definesthat execution. Using that  qid, we can pull from each unfinished execution inside theexplicit transaction at any time. Along the small API changes of returning the  qid, weneed to keep information about every unfinished execution. There were of course some memoryproblems here and there, but the most important thing while designing the solution for thisis how will you find an execution that is represented by that  qid. We decided to use the qid as the index of each execution inside the list of executions. The only thing you needto be careful of is deleting finished queries so your  qids and indices don’t go out ofsync.</p><p>在显式事务中，每个运行消息返回一个唯一定义该执行的qid。使用该qid，我们可以随时从显式事务内的每个未完成的执行中拉出。随着返回qid的API的小变化，我们需要保存关于每个未完成的执行的信息。当然，这里和那里都有一些内存问题，但在设计解决方案时，最重要的是如何找到由该qid表示的执行。我们决定使用qid作为执行列表中每个执行的索引。您唯一需要注意的是删除已完成的查询，这样您的qid和索引就不会不同步。</p><p> All of the things above apply to the  DISCARD_ALL message which was renamed to  DISCARD.</p><p>以上所有内容都适用于重命名为DiscardAll的DISCARD_ALL消息。</p><p>  In previous versions of Memgraph, a  DISCARD_ALL message didn’t produce the correct behaviour.While we were implementing the protocol the only information we had was that the  DISCARD_ALLmessage discards all of the results. We concluded that this means that we can safely ignore the prepared execution. As we figured that out much later, with the help from one of our community members, this message should have executed the query and simply discarded all the results, i.e. the results should not have been streamed. This mistake was noticeable by executing a query with a side effect and sending a  DISCARD_ALL message. We fixed this in our newest version of server but it’s a great example of how protocols should always be defined in as much detail as possible.</p><p>在Memgraph的以前版本中，DIRECAD_ALL消息不会产生正确的行为，当我们实现该协议时，我们得到的唯一信息是DIRECAD_ALL消息会丢弃所有结果。我们的结论是，这意味着我们可以安全地忽略准备好的执行。我们很久以后才发现，在社区成员的帮助下，该消息应该已经执行了查询，并简单地丢弃了所有结果，即结果不应该被流式传输。通过执行有副作用的查询并发送DISCARD_ALL消息，这个错误非常明显。我们在最新版本的服务器中修复了这个问题，但这是一个很好的例子，说明应该如何总是尽可能详细地定义协议。</p><p>  We plan to keep up as much as possible with the newest versions of the Bolt protocol. The pool of 4 versions gives us some leeway but it’s still our job to keep up with the newest versions of Neo4j drivers so you can query Memgraph from many different languages.</p><p>我们计划尽可能跟上最新版本的Bolt协议。4个版本的池给了我们一些回旋余地，但我们的工作仍然是跟上最新版本的Neo4j驱动程序，这样你就可以从许多不同的语言查询Memgraph。</p><p>  Although Memgraph supports Neo4j drivers, we are also developing our own drivers using the Bolt protocol to deliver better performance and developer experience. So far, we have implemented the following drivers:</p><p>虽然Memgraph支持Neo4j驱动程序，但我们也在使用Bolt协议开发我们自己的驱动程序，以提供更好的性能和开发人员体验。到目前为止，我们已经实现了以下驱动程序：</p><p>   In this blog post we explored what it means to support a Neo4j driver and why it isn’t always trivial to keep up with the newest versions.</p><p>在这篇博客文章中，我们探讨了支持Neo4j驱动程序的意义，以及为什么跟上最新版本并不总是那么容易。</p><p> Now that Memgraph supports the newest version of the Bolt protocol we encourage you to try it out and let us know what you think.</p><p>既然Memgraph支持最新版本的Bolt协议，我们鼓励您尝试一下，并让我们知道您的想法。</p><p>  If you can’t come up with an example to try out Memgraph, no worries, we put together examples for each supported driver in our  How to Query Memgraph Programmatically?.</p><p>如果您想不出一个示例来试用Memgraph，请不要担心，我们在“如何以编程方式查询Memgraph？”一书中为每个支持的驱动程序提供了示例。</p><p> Also, bugs and mistakes are always possible so feel free to report any strange behaviour on our  forum.</p><p>此外，错误和错误总是可能的，所以请随时在我们的论坛上报告任何奇怪的行为。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://memgraph.com/blog/memgraph-1-2-release-implementing-the-bolt-protocol-v4">https://memgraph.com/blog/memgraph-1-2-release-implementing-the-bolt-protocol-v4</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/实现/">#实现</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/消息/">#消息</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>