<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何编写可读代码 How to Write Readable Code</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to Write Readable Code<br/>如何编写可读代码 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-06 20:16:09</div><div class="page_narrow text-break page_content"><p>These are some of the things I think about when trying to write clean, readable code.</p><p>这些是我在尝试编写简洁易读的代码时所考虑的事情。</p><p>  There are many ways to write any piece of code. Some will run faster, some will take less memory, some will be easier to test. And some will be more clear.</p><p>  有许多方法可以编写任何代码。有些会运行得更快，有些会占用更少的内存，有些会更易于测试。有些会更清楚。</p><p>  This means you have to deprioritize other aspects, like speed. There’s no such thing as prioritizing one thing without deprioritizing something else (when everything is a priority, nothing is).</p><p>  这意味着您必须降低其他方面的优先级，例如速度。没有优先事项而不是其他优先事项（当一切都优先时，什么都没有）。</p><p>  Writing well requires knowing what good writing looks like, and creating clear code requires knowing what clear code looks like. Reading well-regarded code can give you a sense of what good can look like.</p><p>  写得好需要知道好的写作是什么样的，而创建清晰的代码则需要知道清晰的代码是什么样的。阅读备受好评的代码可以使您对好的外观有所了解。</p><p> A good sense for clear code won’t keep you from writing unreadable code, but it will tell you what parts don’t smell right.</p><p> 对于清晰的代码，良好的理解不会阻止您编写难以理解的代码，但会告诉您哪些部分闻起来不正确。</p><p>  Your first idea for how to write the code will rarely be the most clear.</p><p>  关于如何编写代码的第一个想法很少会是最清楚的。</p><p> It’s often easier to find a readable way to write code after you’re finished with the mental work of getting the first version written down. Reading back over what you just wrote will help give ideas for how to improve it.</p><p> 在完成写下第一个版本的思想工作之后，通常更容易找到一种易于编写代码的方式。重新阅读您刚刚写的内容将有助于提出改进建议。 </p><p>  If you’re not sure how to organize the code, start by explaining what needs to be done as though you are telling it to another person (or rubber duck). Write it down: “Well, we need to skip it if the user is deleted, or if the order is already in progress…” Take that explanation and transform it into code.</p><p>如果您不确定如何组织代码，请先向别人（或橡皮鸭）讲解，然后再进行说明。写下来：“好吧，如果删除了用户，或者订单已经在处理中，我们需要跳过它……”进行解释并将其转换为代码。</p><p> When laying out the code, it’s better to be thinking in terms of human communication rather than machine abstractions.</p><p> 在布置代码时，最好是在人际交流方面进行思考，而不要在计算机抽象方面进行思考。</p><p>  Add comments that explain why the code is doing what it is doing, or is structured the way that it is structured.</p><p>  添加注释，以解释代码为何执行其正在执行的操作或以其结构化方式进行结构化。</p><p> Just reading the logic won’t tell you why the author thought that was the right logic. There might be some business reason you don’t know about - perhaps users outside the US sometimes put the street number at the end of the first line of the address. Or maybe there is some little technical detail - this query is structured in this weird way to convince Postgres to optimize it correctly. These are added bits of context that don’t exist in the code itself.</p><p> 仅阅读逻辑并不能告诉您为什么作者认为这是正确的逻辑。您可能不知道某些业务原因-也许美国境外的用户有时将街道号码放在地址第一行的末尾。也许有一些技术细节-这个查询以这种怪异的方式构造，以说服Postgres正确地优化它。这些是代码本身不存在的附加上下文。</p><p> Code can’t self-document if it isn’t there. If you decide to not write some code and don’t leave a comment explaining why, there will be nothing left to explain what you were thinking!</p><p> 如果代码不存在，则无法自我记录。如果您决定不编写任何代码，并且不留下任何解释原因的注释，那么您将什么都没有解释。</p><p> Even if it is possible to understand the reasoning from just reading the code, it’s hard mental work that can be very easily prevented.</p><p> 即使仅通过阅读代码就可以理解其原因，也可以很容易地避免进行艰苦的脑力劳动。</p><p>       Mixing levels of abstraction makes the reader jump between thinking about what is being done and how it is implemented.</p><p>       混合的抽象级别使读者可以在思考正在做的事情和如何实现它之间进行选择。 </p><p> When you talk about what code does, you are talking about the current level of abstraction. When you talk about how the code does it, you are talking about the next level of abstraction down.</p><p>当您谈论代码做什么时，您所谈论的是当前的抽象级别。当您谈论代码的工作方式时，您正在谈论的是抽象的下一层。</p><p> In the  welcome method, what it does is send a welcome email if it has not already been sent. How it determines if the email was already sent is to query the database of past email records. Notice that the second version of  welcome moves the ‘how’ to a separate method. It’s only concerned with the ‘what’, meaning it stays at one level of abstraction.</p><p> 在welcome方法中，它的作用是发送欢迎电子邮件（如果尚未发送）。如何确定是否已发送电子邮件是要查询过去电子邮件记录的数据库。请注意，第二版的welcome将“如何”转移到一个单独的方法。它只关心“什么”，这意味着它停留在一个抽象层次上。</p><p> Make each function live at one level of abstraction, and delegate lower-level details to methods at lower levels of abstraction. Methods with a single level of abstraction tend to read like a story about what is going on.</p><p> 使每个函数处于一个抽象级别，并将较低级别的细节委派给较低抽象级别的方法。具有单一抽象级别的方法往往读起来就像是关于正在发生的事情的故事。</p><p>  Big functions can (sometimes!) be made more readable by breaking them up into smaller functions.</p><p>  通过将大型函数分解为较小的函数，可以使它们（有时！）更具可读性。</p><p> Sometimes that function acts like a series of steps, in which case it works well to extract a function for each step. Other times, there are different decisions to be made, each of which could be made in a different function. Perhaps there’s parts of the function that act like making a decision and parts that act like taking action. There’s a lot of different dimensions you can use to split up a function. It takes practice to get good at seeing the right one to use.</p><p> 有时，该函数的作用类似于一系列步骤，在这种情况下，可以很好地为每个步骤提取一个函数。在其他时候，有不同的决定要做出，每个决定都可以在不同的功能中做出。也许功能的某些部分像决策一样起作用，而某些部分像采取行动一样起作用。您可以使用许多不同的维度来分解功能。需要练习才能善于看到正确的使用方法。</p><p>  Each bit of logic is given a name. This makes it easier to know what each bit of logic is for and helps you find where a bit of logic lives.</p><p>  逻辑的每一位都有一个名称。这使您更容易知道逻辑的各个方面是什么，并帮助您找到逻辑的所在。</p><p>  It’s easier to tell what the program was “thinking” when you look at a stack trace or run a debugger.</p><p>  当您查看堆栈跟踪或运行调试器时，很容易分辨出程序在想什么。 </p><p> Computers would work fine with no functions at all. Functions exist for the sake of programmers, so make good use of them.</p><p>计算机可以正常工作，完全没有任何功能。为了程序员的存在而存在函数，因此请充分利用它们。</p><p>   Now, it’s a very good idea to extract magic numbers to constants and have one copy of the logic for making a particular decision. Repeating those bits of code is a bad idea.</p><p>   现在，将魔术数提取为常数并获得用于做出特定决策的逻辑副本是一个很好的主意。重复这些代码是个坏主意。</p><p> DRY starts to go too far when two functions that happen to share a handful of lines become a target for deduplication. Completely avoiding duplicated lines means that you’ll end up with confusing, nonsense abstractions that exist only to hold those few shared lines. This makes the code weirdly hard to change because the structure of two unrelated pieces of code will be tied together.</p><p> 当碰巧共享少量行的两个功能成为重复数据删除的目标时，DRY开始走得太远。完全避免重复的行意味着您最终将得到混乱的，无意义的抽象，这些抽象仅用于容纳那几条共享行。这使得代码难以更改，因为两个不相关的代码片段的结构将被捆绑在一起。</p><p> The test for whether some pieces of code should be deduplicated is simple: would anything bad happen if one was changed without also changing the other? If the answer is yes, then make a single source of truth for it. If not, consider leaving it alone.</p><p> 是否对某些代码进行重复数据删除的测试很简单：如果更改了一个代码而不更改另一个代码，会发生什么不好的事情？如果答案是肯定的，则为其提供唯一的真理来源。如果没有，请考虑不理会它。</p><p> The point of DRY isn’t to run a manual compression process on the codebase, it’s to avoid a dependency where two parts of the code need to be manually kept in sync. Remember, deduplicating code is not the same thing as creating an abstraction.</p><p> DRY的目的不是在代码库上运行手动压缩过程，而是避免依赖关系，在该依赖关系中需要手动保持两部分代码同步。请记住，重复数据删除与创建抽象不是一回事。</p><p>   I’m sure you’ve seen stories like this one: you start off with a clean function that’s called in three different places. You want to use it in a fourth place, but it needs to do something slightly different, so you add a configuration parameter. Then the first caller gets a new feature, requiring two more configuration parameters. A fifth use case is added with its own special parameter. Caller #2 is too slow, so you add yet another parameter for skip part of the work.</p><p>   我敢肯定，您已经看过这样的故事：您从一个在三个不同地方调用的干净函数开始。您想在第四位使用它，但是它需要做一些稍有不同的事情，因此您添加了一个配置参数。然后，第一个调用者获得一项新功能，需要另外两个配置参数。第五个用例将添加其自己的特殊参数。呼叫者2的速度太慢，因此您添加了另一个参数来跳过部分工作。</p><p> Somehow, your clean function that started life doing one thing now has 5 configuration parameters and does potentially 2^5 = 32 different things (or more)!</p><p> 不知何故，您一开始就做一件事情的干净函数现在有5个配置参数，并且可能执行2 ^ 5 = 32种不同的事情（或更多）！ </p><p> It’s much better to have multiple functions, each of which does just one thing.</p><p>最好有多个功能，每个功能都只做一件事。</p><p> Once you have separate functions, there will of course be duplication. When those shared parts need to be kept in sync, apply DRY and extract them to shared functions. This is easier if the function is already broken down into subfunctions for decisions and steps.</p><p> 一旦有了单独的功能，当然会有重复。当这些共享部分需要保持同步时，请应用DRY并将其提取到共享功能中。如果该功能已细分为决策和步骤子功能，则这会更容易。</p><p> Remember, a few duplicated lines is fine! If each of the separate functions has its own for-loop over a list, that’s very acceptable duplication.</p><p> 记住，几行重复就可以了！如果每个单独的函数在列表中都有其自己的for循环，则这是非常可以接受的重复。</p><p> One advantage of this approach is that when one use-case goes away, you can easily delete the relevant function. You don’t have to dig around in the logic of a complicated function to tease out the parts that were for that particular set of options.</p><p> 这种方法的一个优势是，当一个用例消失时，您可以轻松删除相关功能。您无需深入研究复杂功能的逻辑即可弄清楚用于该特定选项集的部分。</p><p> Readers of a special-purpose function will find it much easier to understand what it does.</p><p> 专用功能的读者会发现，它更容易理解其功能。</p><p> (Note that this is only the right approach if you control all the callers of the function. If you function is part of a public API, then the reasoning here doesn’t apply because you don’t know what all the usecases are or will be.)</p><p> （请注意，只有控制了函数的所有调用者，这才是正确的方法。如果函数是公共API的一部分，则此处的理由并不适用，因为您不知道所有用例是什么或将是什么用例是。）</p><p>  Race cars go faster than normal cars, but at the expense of having hard seats, making lots of noise, and lacking A/C. If you don’t know that your function is going to need to be a race car, don’t strip out the A/C yet. Leave the creature comforts in - focus on writing code that is easy for humans to read instead of easy for computers to run.</p><p>  赛车的行驶速度比普通汽车要快，但是要牺牲硬座，发出很多噪音和缺少空调的代价。如果您不知道自己的功能将需要成为赛车，请不要剥离空调。让动物安心-专注于编写易于阅读的代码，而不是易于计算机运行的代码。 </p><p> The same is true about premature generalization. You wouldn’t buy a dump truck if you don’t need to haul huge loads of things, so you also shouldn’t make your code able to serve all kinds of needs that may never happen.</p><p>过早的概括也是如此。 如果您不需要拖运大量的东西，则不会购买自卸车，因此也不应使您的代码能够满足可能永远不会发生的各种需求。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://jeremymikkola.com/posts/2021_02_02_how_to_write_readable_code.html">http://jeremymikkola.com/posts/2021_02_02_how_to_write_readable_code.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编写/">#编写</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/readable/">#readable</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>