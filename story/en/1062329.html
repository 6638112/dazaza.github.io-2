<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>稍后有55,000行的生锈代码：调试器出生 55,000 lines of Rust code later: A debugger is born</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">55,000 lines of Rust code later: A debugger is born<br/>稍后有55,000行的生锈代码：调试器出生 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-13 06:41:55</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/ef7bbb645d098a51d12c3575d15c3dd5.png"><img src="http://img2.diglog.com/img/2021/5/ef7bbb645d098a51d12c3575d15c3dd5.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Permalink         I am proud to announce that the  Record &amp; Debug Tool ( rd) has entered alpha.</p><p>永久链接我很自豪地宣布记录＆amp;调试工具（RD）已输入Alpha。</p><p> The Record &amp; Debug Tool (  rd) is a record/replay debugger written in Rust. It is a project to port the  rr project from C/C++ to Rust. Why is this a good idea? Why Rust? For that, please read some of my older posts and updates:</p><p> 记录＆amp;调试工具（RD）是用Rust编写的记录/重播调试器。它是一个项目，将RR项目从C / C ++移植到生锈。为什么这是一个好主意？为什么生锈？为此，请阅读我的一些较旧的帖子和更新：</p><p>  Current Status: The port is substantially complete and is currently of an alpha level quality. You should be able to use  rd for the tasks you would ordinarily use  rr for. The  rr project keeps accumulating features and fixes and many of them have not found their way into rd yet. However, my expectation is that  rd should be reasonably robust, complete and usable now. Please try it out!</p><p>  当前状态：端口基本完成，目前是alpha级别质量。您应该能够为您通常使用RR使用的任务使用RD。 RR项目仍然累积的功能和修复，其中许多人还没有找到进入RD的方式。但是，我的期望是RD应该是合理的，完整和可用现在。请尝试一下！</p><p> Today in this blog post I want to go deeper into why debuggers matter and why you should care about the Record &amp; Debug Tool (  rd).</p><p> 今天在这个博文帖子里，我想深入了解为什么调试器重要以及你应该关心记录和amp;调试工具（RD）。</p><p>  In my opinion, debuggers are under-appreciated and under-invested tools in a programmer&#39;s arsenal. Now, there are hundreds of new programming languages around with new ones appearing every year. There are also an uncountable number of articles that appear regularly on technical blogs about trying out a new programming language or gushy posts about a new feature introduced in this year&#39;s hot programming language!</p><p>  在我看来，在程序员＆＃39; arsenal中受到了升值和投资的推迟工具。现在，每年都有数百个新的编程语言。还有一个不可数的文章，这些文章定期出现关于尝试新的编程语言或Gushy Post关于今年推出的新功能的新功能博客＆＃39; S热编程语言！</p><p> The same cannot be said about debuggers: the field of debuggers is decidedly more sedate. New debuggers arise on the scene very occasionally. Most people could probably only name  gdb and  lldb as the general purpose debuggers they are aware of. You will also rarely see fans wax eloquent about new features in a new release of gdb/lldb (there are always exceptions though).</p><p> 关于调试者也不可能说：调试器领域的决心更加稳重。新的调试器非常偶尔在现场出现。大多数人可能只会将GDB和LLDB命名为他们所知的通用调试器。您还将很少看到粉丝蜡eloquent关于新版本的GDB / LLDB中的新功能（常见的例外）。</p><p> Yes, there are language specific debuggers for Golang, Python, PHP, Java, .Net etc. but even these debuggers hardly receive the attention in proportion to the value they provide, and the sheer time end-users spend using them.</p><p> 是的，有Golang，Python，PHP，Java，.NET等的语言特定调试器。但即使这些调试器也几乎没有与他们提供的价值成比例的注意，并且纯粹的时间最终用户使用它们。 </p><p> There are various historical and practical reasons for this phenomenon of under-appreciation and under-investment. Debuggers as they are currently implemented are often not very useful for various reasons -- bugs are often difficult to repeat, once the bug is repeated, it is tough to pin down (have you ever stepped too far in the debugger only to have to restart your 10-min setup again?), the interface is too low level, the breakpoint paradigm has limitations etc. In fact there often many capable developers who will insist that debuggers are not useful and will avoid them at all costs -- they will encourage other approaches like program logs etc.</p><p>这种历史和实际的原因，对欣赏和投资不足的这种现象。试用者目前实施的调试器往往不是很有用的原因，虫子往往很难重复，一旦错误重复，它难以放下（你曾经在调试器中走过太远，只需要重新启动你的10分钟内容再次？），界面水平过低，断点范式的界面有局限性等。事实上，经常有许多有能力的开发商谁将坚持认为，调试器并不有用，并将避免所有费用 - 他们会鼓励他们其他方法如程序日志等。</p><p> Furthermore, debuggers are seen as unsexy, messy, special case ridden pieces of engineering that are pointlessly hard to build and lack the theoretical beauty that one sees in compiler design and implementation. The truth is somewhat more nuanced: Yes debuggers are tremendously messy and special case ridden. That is because they necessarily need to operate at a low level of abstraction as they often deal with registers, interrupts, memory etc. But then, compilers are  just as messy -- most people don&#39;t get to see that because they simply do the parsing, type checking and IR generation and leave the dirty parts to, say, LLVM.</p><p> 此外，调试器被视为无声，凌乱，特殊的案例骑在毫无意义的工程件，难以建立，缺乏在编译设计和实施中看到的理论美容。真相有点细微差别更为细微：是的调试器是非常凌乱和特殊的案件骑行。这是因为它们必然需要在低级别的抽象中运行，因为它们经常处理寄存器，中断，存储器等，但是，编译器就像凌乱 - 大多数人不得不看看，因为他们只是进行解析，键入检查和红外一代，并将脏部留给LLVM。</p><p> Let&#39;s talk about the other complaint: debuggers don&#39;t have a theoretically interesting core. Nothing could be further from the truth. There is nothing inherently pedestrian about the work a debugger does. Just as a compiler uses sophisticated algorithms at  compile-time, a good debugger needs to employ sophisticated analyses and algorithms for things that happen during  run-time. Except the main problem is that very few debuggers actually do this today!</p><p> 让＆＃39;谈论另一个投诉：调试器Don＆＃39; T有一个理论上有趣的核心。没有东西会离事实很远。关于调试器的工作没有任何内在的行人。正如编译器在编译时使用复杂的算法一样，很好的调试器需要采用复杂的分析和算法，以便在运行时发生的事情。除了主要问题是，很少有人的调试器今天实际上这样做！</p><p> Debuggers have not experienced the revolution that compiler design and implementation has experienced over the last few decades. There are  tons of academic papers written and Ph.Ds. minted every year in the field of compilers and PL theory every year. The same cannot be said for the field of debugger design and implementation. Debuggers, at least in the popular perception, have not significantly progressed in terms of capability over the last few decades.</p><p> 在过去的几十年中，调试人员没有经历过编译设计和实施的革命。有很多学术论文写作，博士学位。每年在编译和PL理论领域每年铸造。调试器设计和实现领域也无法说。至少在流行的感知中，在过去几十年的能力方面没有显着进展。</p><p> This can only mean one thing: the field of debuggers is ripe for disruption and innovation. Just like  llvm facilitated the rise of hundreds of new computer languages, I forsee a similar rise for debugging and debuggers in the coming years.</p><p> 这只能意味着一件事：调试器领域是对中断和创新的成熟。就像LLVM促进了数百个新电脑语言的崛起，我在未来几年内备我的调试和调试器类似的崛起。</p><p>  Science and engineering is based on the important principle of repeatability. You should be able to repeat something reliably in order to fix it, study it, improve it. Debuggers are plagued by this issue of lack of repeatability in the things they are studying: programs under execution. Bugs are ephemeral: sometimes they reveal themselves and sometimes they don&#39;t. So most debuggers like  gdb/ lldb can be quite unsatisfying tools because they can&#39;t reliably &#34;home-in&#34; on the bug they are trying to resolve. This is possibly one of the reasons why people don&#39;t invest so much in debuggers -- the current debugging paradigm is perceived as having inherent limits and it is just not powerful enough.</p><p>  科学与工程基于重复性的重要原则。您应该能够可靠地重复某些内容，以便解决它，研究它，改进它。在他们正在学习的事情中，调试者缺乏可重复性的困扰：正在执行的计划。虫子是短暂的：有时他们会揭示自己，有时他们不会＆＃39; t。所以，像GDB / LLDB这样的最多的调试器可以是相当不满意的工具，因为它们可以在＆＃39; t＆＃34; home-in＆＃34;在他们尝试解决的错误上。这可能是人们在调试器中投入大量投资的原因之一 - 当前调试范式被认为具有固有的限制，它不够强大。</p><p> To resolve this problem of repeatability, record-replay debugging was invented quite some time ago. The concept is simple: record an execution of a program that exhibits a bug and then replay the same  exact execution later. The bug will always appear in the replay and you can reliably debug the problem. There are many record and replay systems  around.</p><p> 为了解决这种重复性问题，在很久以前的情况下，记录重播调试。概念很简单：记录展示错误的程序的执行，然后稍后重播相同的精确执行。该错误将始终出现在重放中，您可以可靠地调试问题。周围有许多记录和重播系统。 </p><p> However, for a long time there was a problem: most record-replay systems either were proprietary or limited in ability in some important way or both.</p><p>然而，很长一段时间都有一个问题：大多数记录重播系统要么在一些重要的方式或两者都是专有的或有限的能力。</p><p> The  rr debugger when it was released was a breath of fresh air. Finally, there was a viable open-source record-relay implementation! In the annals of debugging, I think this was a significant event: The  rr debugger not only has novel technical aspects, it is quite &#34;practical&#34; and usable for day-to-day debugging needs.</p><p> RR调试器在发布时是一种新鲜空气的呼吸。最后，有一个可行的开源记录继电器实现！在调试的历史中，我认为这是一个重要的事件：RR调试器不仅具有新颖的技术方面，它是完全＆＃34;实用＆＃34;并且可用于日常调试需求。</p><p> Thinking beyond, record-and-replay debugging provides a platform on which you can super-charge debugging. By solving the repeatibility issue you can fix your bug more easily. But more importantly, you can now build some really amazing and powerful debugging tools on top of this &#34;base debugger&#34;. You can do powerful analyses and take a data-mining approach to studying your program. As a further example, for people who are fans of logging, you can do something amazing:  retro-logging. This allows you to insert some logging statements in the areas of the program you are interested in  after the program has already run! Because you have already recorded the execution, the program replayer can print out these logging statements when it replays the program.</p><p> 思考超越，Record-and-Replay调试提供了一个平台，您可以在其中进行超级充电调试。通过解决可重复问题，您可以更轻松地修复臭虫。但更重要的是，您现在可以在此＆＃34的顶部构建一些非常神奇和强大的调试工具;基础调试器＆＃34;您可以进行强大的分析，并采取数据采矿方法来研究您的计划。作为一个进一步的例子，对于粉丝的粉丝的人来说，你可以做一些惊人的事情：复古记录。这允许您在程序已经运行后的程序的区域中插入某些日志记录语句！由于您已经录制了执行，因此程序重播器可以在重放程序时打印出这些日志记录。</p><p> The important take-way here is that  rr provides a platform (just like LLVM did for compilers) which will allow the next generation of debugging tools to be built. (Companies like Pernosco are doing just that).</p><p> 这里的重要上行是RR提供了一个平台（就像编译器一样的LLVM），这将允许构建下一代调试工具。 （Pernosco这样的公司正在做那个）。</p><p> Of course, I want to point out that record-replay debugging in the  rr paradigm is not a silver bullet. Parallel execution is essentially serialized during record. So a large class of concurrency issues cannot adequately be solved by  rr. Recording/replaying programs executing parallely on multiple CPU cores reliably and in a light-weight way is still a research problem.</p><p> 当然，我想指出RR范例中的记录重播调试不是银弹。并行执行在记录期间基本上序列化。因此，RR无法充分解决大类的并发问题。录制/重放程序可靠地在多个CPU内核上进行平静，并以轻量级方式仍然是一个研究问题。</p><p>  So where does  rd come into the picture? A huge amount of compiler/debugger infrastructure is built in the C/C++ language (gcc, llvm, gdb, lldb, Swift, javac etc). The problems and complexity of C/C++ are well documented. Writing effective C/C++ is like walking a tightrope: a small mistake and you&#39;ll basically fall to your death. Modern languages like Rust provide extra guard-rails while not compromising on performance. They also don&#39;t assume that its programmers are as smart as Herb Sutter! :-). Tough things like concurrency and parallelism in C/C++ become easier in Rust.</p><p>  那么Rd在哪里进入图片？ C / C ++语言（GCC，LLVM，GDB，LLDB，SWIFT，JAVAC等内置了大量的编译器/调试器基础架构。 C / C ++的问题和复杂程度良好记录。写作有效的c / c ++就像走一个绳索：一个小错误和你＆＃39; ll基本上落到你的死亡。现代语言如Rust提供额外的卫兵，而不会妥协于性能。他们也没有假设其程序员与草药嘘声一样聪明！ :-)。 C / C ++中的并发性和并行性和并行性等艰难的事情变得更容易生锈。</p><p> Sadly due to historical reasons,  rr is also built in C/C++. Some of main developers of  rr are huge Rust fans and I&#39;m pretty sure if  rr were built by them today, they would choose Rust as the implementation language. See this  interesting discussion.</p><p> 可悲的是由于历史原因，RR也建于C / C ++。 RR的一些主要开发人员是巨大的生锈粉丝和我＆＃39;嗯，如果他们今天建造了RR，他们将选择RUDE作为实施语言。看到这个有趣的讨论。 </p><p> However, does that mean that like LLVM we are forever stuck with C/C++ for a foundational piece of debugging software like  rr?</p><p>但是，这是否意味着像LLVM一样，我们永远被C / C ++陷入了C / C ++，因为RR等政策软件？</p><p> No. The  rd port of  rr to Rust is my attempt to change that inevitability. I&#39;ve been obsessed by reverse-debugging for some time. I also believe that often the best way to learn something really well is to re-do it in some way. The  rd port has been the expression of my love affair with the record-and-replay paradigm of debugging. I&#39;m very happy that I&#39;ve been able to come so far. Many times I thought I should give up -- I&#39;ve documented my experiences while porting  rr to Rust in the previous blogs that I linked above.</p><p> 不可以。RR的RD港是我的尝试改变不可避免的性。我在一段时间内被反转调试迷恋。我也相信通常最好的方法来学习一些真的很好，就是以某种方式重新做到。 RD港口一直是我对调试的记录和重播范例的爱情的表达。我很高兴我能到目前为止来到我＆＃39。很多次我以为我应该放弃 - 我＆＃39;在将RR移植到上面链接的博客中，他们记录了我的经历。</p><p> This port has been a long and lonely journey so far but I think  rd has reached a stage that end-users can use it. Hopefully now that this project has reached this milestone, other developers can play around with it too and give feedback and contribute.</p><p> 到目前为止，这个港口一直是一个漫长而孤独的旅程，但我认为RD已经达到了最终用户可以使用它的舞台。希望现在这个项目已达到这个里程碑，其他开发人员也可以与之玩，并提供反馈和贡献。</p><p> I have a few dreams and plans for  rd. My hope is that in the future it can become a laboratory for some exiting features in debugging. But this will only come to fruition once  rd becomes a reliable and much loved piece of software that  rr already is.</p><p> 我有一些梦想和计划。我希望在未来，它可以成为一些退出调试功能的实验室。但是，一旦RD成为RR已经是可靠和非常喜欢的软件，这将只会出现。</p><p> Please play around with  rd and let me know if things worked out for you. This is alpha level software, so I apologise in advance if things don&#39;t work as expected!</p><p> 请与Rd一起玩，并让我知道是否为您制定了。这是alpha级软件，所以我提前道歉，如果事情不按预期工作！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/sidkshatriya/me/blob/master/004-A-debugger-is-born.md">https://github.com/sidkshatriya/me/blob/master/004-A-debugger-is-born.md</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/生锈/">#生锈</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/调试器/">#调试器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>