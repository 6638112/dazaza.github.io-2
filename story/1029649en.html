<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Emacs问题</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Emacs问题</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-19 03:14:31</div><div class="page_narrow text-break page_content"><p>Lisp still doesn&#39;t seem like the right language for doing textmanipulation, and nothing I&#39;ve seen from the Emacs libraries is makingme think any differently. It sure beats the hell out of Javathough. Maybe someday someone will write Emacs using Ruby as theembedded interpreter...</p><p>LISP看起来仍然不是进行文本操作的合适语言，而且我从Emacs库中看到的任何东西都不会让我有任何不同的想法。不过，它确实把Java语言打得天翻地覆。也许有一天会有人用Ruby作为嵌入式解释器来编写Emacs……。</p><p> These are all great points. I know exactly how he feels. I knowsoooo exactly how Charles feels that I decided to write a blog insteadof an email reply. Because all the things he&#39;s brought up are real,bona-fide problems.</p><p>这些都是很棒的观点。我很清楚他的感受。我非常了解查尔斯的感受，所以我决定写博客，而不是回复电子邮件。因为他提出的所有事情都是实实在在的问题。</p><p>  Let&#39;s start by considering the basic problem: how good  isLisp for text processing? That turns out to be a complicated question.</p><p>让我们从一个基本问题开始考虑：Lisp对于文本处理有多好？事实证明，这是一个复杂的问题。</p><p> When we think of &#34;text processing&#34;, most of us usually thinkimmediately of regular expressions. Unless &#34;we&#34; are C++ programmers,in which case &#34;we&#34; like to write 2500-line clones of the Unix &#39;grep&#39;utility whenever &#34;we&#34; need to do a text search — or so it would seem,from the candidates I&#39;ve interviewed in the past few months. ButI think it&#39;s safe to say that most programmers equate text processingwith regular expressions.</p><p>当我们想到文本处理时，我们中的大多数人通常会立即想到正则表达式。除非我们是C++程序员，在这种情况下，每当我们需要进行文本搜索时，我们都喜欢编写2500行的Unix实用程序的克隆-或者看起来是这样，来自我在过去几个月面试过的候选人。但我认为可以肯定地说，大多数程序员将文本处理等同于正则表达式。</p><p> Regexps are obviously quite useful. If you aren&#39;t  extremelyproficient with regular expressions right now, then you shoulddrop everything and go become proficient with them. I bet I useregular expressions on 350 days out of every year: in my editor, onthe command-line, in my code — anywhere that using one would save metime or make my code clearer. Oh, how it hurts to think about allthe so-called &#34;programmers&#34; out there who don&#39;t know how to use regexps. Argh. Let&#39;s just drop it.</p><p>Regexp显然非常有用。如果你现在不是非常精通正则表达式，那么你应该放下一切去精通它们。我敢打赌，我每年350天都会使用常规表达式：在我的编辑器中，在命令行中，在我的代码中-任何地方使用它都可以节省我的时间或使我的代码更清晰。哦，想想所有那些不知道如何使用regexp的所谓程序员是多么痛苦啊。啊.。让我们别再提这件事了。</p><p> However, I read somewhere that Lispers have always been a bitskeptical of regular expressions, because regexps are actually a bitweak compared to the generalized processing you can do on treestructures. Lisp folks ask: why are you storing your data as text inthe first place? (As opposed to storing it as Lisp.)</p><p>然而，我在某处读到Lispers一直对正则表达式持怀疑态度，因为与可以对树结构进行的通用处理相比，正则表达式实际上有点弱。LISP人员会问：为什么要将数据存储为文本？(而不是将其存储为Lisp。)。</p><p> I dunno about you, but the first response that comes to my mind is:&#34;duh, what about logs?&#34; I remember thinking: gosh, what a bunch oflosers; the Lisp folks don&#39;t even know that the logs of virtually allsystems are one-line entries that most easily parsed (by far) usingregexps.</p><p>我不知道你怎么想，但我想到的第一个反应是：嗯，日志怎么样？我记得当时在想：天哪，一群失败者；Lisp的人甚至不知道几乎所有系统的日志都是一行条目，(到目前为止)最容易使用regexp进行解析。</p><p>  Then I noticed, no more than three weeks ago, that in Java 1.5, myjava.util.logging output had quietly turned into XML. D&#39;oh!!!Regexps  suck for processing XML. If you don&#39;t know why,please don&#39;t tell me that you don&#39;t know, or I will hate you. Betterto keep silent.</p><p>然后，不到三周前，我注意到在Java1.5中，myjava.util.log输出已经悄悄地转换为XML。D&#39；噢！Regexp处理XML很糟糕。如果你不知道为什么，请不要告诉我你不知道，否则我会恨你的。最好还是保持沉默。</p><p> Why, then, are logs switching to XML output? Well, er, ah, becauseXML offers more powerful and generalized text-processing capabilitiesthan one-line log entries. I suppose. I actually haven&#39;t quitegotten used to the new XML output format, but I&#39;m giving it a go andtrying to learn to like it. It&#39;s quite verbose, which in some casesis good, and in others, maybe not so good.</p><p>那么，为什么日志要切换到XML输出呢？嗯，呃，啊，因为XML提供了比一行日志条目更强大、更通用的文本处理能力。我想是吧。实际上，我还没有完全习惯新的XML输出格式，但我正在尝试它，并试图学习喜欢它。它相当冗长，在某些情况下是好的，在另一些情况下可能不是那么好。</p><p> Case in point:   Java stack traces in the logs have  each individualstack frame entry wrapped in its own XML element. The stack tracesare already long, but this makes them sort of crazy. Well, you be thejudge. Would you rather have your log entries look like this:</p><p>例如：日志中的Java堆栈跟踪将每个单独的堆栈框架条目包装在其自己的XML元素中。堆栈跟踪已经很长了，但这让它们有点疯狂。好吧，你来评头论足。您是否希望日志条目如下所示：</p><p>  Feb 21, 2005 6:57:39 PM java.util.logging.LogManager$RootLogger log SEVERE: A very very bad thing has happened! java.lang.Exception 	at logtest.main(logtest.java:24)</p><p>2005-02-21 6：57：39 PM java.util.logging.LogManager$RootLogger日志严重：发生了非常非常糟糕的事情！位于logtest.main(logtest.java：24)的java.lang.Exception。</p><p>     &lt; ? xml  version= &#34;1.0 &#34;  encoding= &#34;utf-8 &#34;  standalone= &#34;no &#34; ?&gt;&lt; ! DOCTYPE log  SYSTEM  &#34;logger.dtd &#34;&gt;&lt; log&gt;&lt; record&gt; &lt; date&gt;2005-02-21T18:57:39&lt; / date&gt; &lt; millis&gt;1109041059800&lt; / millis&gt; &lt; sequence&gt;1&lt; / sequence&gt; &lt; logger&gt; &lt; / logger&gt; &lt; level&gt;SEVERE&lt; / level&gt; &lt; class&gt;java.util.logging.LogManager$RootLogger&lt; / class&gt; &lt; method&gt;log&lt; / method&gt; &lt; thread&gt;10&lt; / thread&gt; &lt; message&gt;A very very bad thing has happened!&lt; / message&gt; &lt; exception&gt; &lt; message&gt;java.lang.Exception&lt; / message&gt; &lt; frame&gt; &lt; class&gt;logtest&lt; / class&gt; &lt; method&gt;main&lt; / method&gt; &lt; line&gt;30&lt; / line&gt; &lt; / frame&gt; &lt; / exception&gt;&lt; / record&gt;&lt; / log&gt;</p><p>&lt；？XML版本=&#34；1.0&#34；编码=&#34；utf-8&#34；独立=&#34；no&#34；？&gt；&lt；！DOCTYPE日志系统#34；logger.dtd&34；&gt；&lt；log&gt；&lt；记录&gt；&lt；Date&gt；Date&gt；2005-02-21T18：57：39&lt；/Date&gt；&lt；/Millis&lt；1109041059800；/Millis&lt；&lt；Sequence&gt；/Sequence&lt；/Sequence&lt；/LT；/Lgger&gt；&lt；Level&gt；Severe&lt；/Level&gt；&lt；class&gt；java.util.logging.LogManager$RootLogger&lt；/class&gt；&lt；method&gt；log&lt；/method&gt；&lt；线程&gt；10&lt；/线程&gt；&lt；message&gt；发生了一件非常糟糕的事情！&lt；/message&gt；&lt；异常&gt；message&gt；java.lang.Exception&lt；/message&gt；&lt；frame&gt；&lt；class&gt；Logtest&lt；/class&gt；&lt；method&gt；main&lt；/method&gt；&lt；line&gt；30&lt；/line&gt；&lt；/Frame&gt；&lt；/Exception&gt；&lt；/Record&gt；&lt；/log&gt；；</p><p>   I guess it kinda depends. If your log only has a few entries,or you&#39;re just doing quick-and-dirty searches, regular expressionsmight be sufficient. But with lots of entries, XML (even thoughit&#39;s five times as verbose) becomes a really powerful tool.</p><p>我想这要看情况了。如果您的日志只有几个条目，或者您只是在执行快速而肮脏的搜索，则常规表达式可能就足够了。但是有了大量的条目，XML(即使是冗长的五倍)成为了一个真正强大的工具。</p><p> For instance, you can do XPath expressions on XML — they&#39;re sort oflike regular expressions, but they understand the XML tree structure:something that no regexp, no matter how fancy, will ever be able todo. With a one-line XPath expression, you could (for instance)select all of the log entries that have a stack trace containing aparticular Java class (or a set of classes). Trying to do  that reliably with regexps will take you time, patience, anda lot of auxiliary scripting. With XPath it&#39;s a snap.</p><p>例如，您可以在XML上执行XPath表达式-它们有点像正则表达式，但它们理解XML树结构：这是任何regexp(无论多么花哨)都无法实现的功能。使用一行XPath表达式，您可以(例如)选择具有包含特定Java类(或一组类)的堆栈跟踪的所有日志条目。尝试使用正则表达式可靠地做到这一点需要您花费时间、耐心和大量的辅助脚本。有了XPath，这就轻而易举了。</p><p> (Incidentally, if you&#39;re not already extremely proficient with XPath,I suggest you drop everything and go become proficient with it. Pathexpressions are becoming quite popular, and XPath is leading the pack.They&#39;re very powerful. If you don&#39;t know how to use XPath, you willwind up reinventing it badly in your XML-processing code.)</p><p>(顺便说一句，如果您还不是非常精通XPath，我建议您放下一切去精通它。PathExpression正变得非常流行，而XPath则处于领先地位，它们非常强大。如果您不知道如何使用XPath，您最终会在XML处理代码中糟糕地重新发明它。)。</p><p> XML data also lets you use XSLT transforms (or XQuery, if you&#39;rehardcore and perhaps slightly crazy), or you can simply use yourfavorite SAX or DOM parser in your favorite language, and quickly doall sorts of remarkable things that would be extremely clunky usingregular expressions. Clunky, nothing — you&#39;d actually just bewriting your own ad-hoc XML parser in  each script. You justdon&#39;t want to go there.</p><p>XML数据还允许您使用XSLT转换(或者XQuery，如果您是硬核的，可能有点疯狂)，或者您可以简单地用您喜欢的语言使用您最喜欢的SAX或DOM解析器，然后快速地做各种使用正则表达式会非常笨拙的事情。实际上，您只是在每个脚本中编写您自己的即席XML解析器。你就是不想去那里。</p><p> So XML is pretty nice. And that sort of validates what the Lisppeople were saying all along, which is that you want even your&#34;simple&#34; text data to be tree-structured. In Lisp, the equivalent logoutput might look very similar to the XML:</p><p>所以XML非常好。这在某种程度上验证了LispPeople一直以来的说法，那就是您甚至希望您的简单文本数据也是树形结构的。在Lisp中，等效的日志输出可能与XML非常相似：</p><p>  ( log&#39;( record ( date  &#34;2005-02-21T18:57:39&#34;)  ( millis 1109041059800)  ( sequence 1)  ( logger nil)  ( level  &#39;SEVERE)  ( class  &#34;java.util.logging.LogManager$RootLogger&#34;)  ( method  &#39;log)  ( thread 10)  ( message  &#34;A very very bad thing has happened!&#34;)  ( exception ( message  &#34;java.lang.Exception&#34;)  ( frame ( class  &#34;logtest&#34;)  ( method  &#39;main)  ( line 30)))))</p><p>(日志&#39；(Record(Date&#34；1109041059800-02-21T18：57：39&#34；)(Millis 2005)(序列1)(记录器无)(严重级别)(类&#34；java.util.logging.LogManager$RootLogger&#34；)(方法&#39；日志)(线程10)(消息&#34；发生了非常糟糕的事情！&#34；)(异常(消息&#34；java.lang.Exception&#34；)(Frame(class&#34；logtest&#34；)(method&#39；main)(第30行)。</p><p>   Well... similar, except for being ten times cleaner and easier toread. It still has all the same metadata that the XML gives you, andyou can still process it using tools that are just as powerful, if notmore so.</p><p>嗯..。相似的，除了更干净和更容易阅读的十倍。它仍然具有XML提供给您的所有相同的元数据，您仍然可以使用同样强大的工具(如果不是更强大的话)来处理它。</p><p> You could even trivially convert it to XML and use XSLT, if you weresilly enough. But Lisp is directly executable, so you could simplymake the tag names functions that automatically transform themselves.It&#39;d be a lot easier than using XSLT, and less than a tenth thesize.</p><p>如果您足够愚蠢，甚至可以简单地将其转换为XML并使用XSLT。但是Lisp是直接可执行的，所以您可以简单地使标记名函数自动进行自我转换。它比使用XSLT容易得多，而且大小不到XSLT的十分之一。</p><p> And for your XPath queries, well, there are mature Common Lisp packagesthat support them  directlyon both XML and Lisp data. The same is truefor Scheme.</p><p>对于您的XPath查询，有一些成熟的Common Lisp包直接支持XML和Lisp数据。方案也是如此。</p><p> I don&#39;t care how fancy your language is — C++, Ruby, Python, Java,Perl whatever — I can  guarantee you that even if it supportsdoing XPath queries on the syntax trees for source code in thatlanguage, which is unlikely, I doubt very much that you&#39;d want to do it. Have you ever looked at the ANTLR or JavaCCgrammar for Java or C++? And the grammars for Python and Ruby arealmost as complex. A query language can&#39;t hide that kind ofcomplexity. It will always be more work to processthe source code programmatically in syntactically complex languages.</p><p>我不在乎你的语言有多棒--C++、Ruby、Python、Java、Perl等等--我可以向你保证，即使它支持在语法树上执行XPath查询，以获取该语言的源代码(这是不太可能的)，我也非常怀疑你是否愿意这样做。您看过Java或C++的ANTLR或JavaCC语法吗？Python和Ruby的语法几乎同样复杂。查询语言无法掩盖这种复杂性。用语法复杂的语言以编程方式处理源代码总是需要做更多的工作。</p><p>  So everyone in the world except for the Lisp community is pretty muchstuck with the same fundamental text-processing problem, which I&#39;llsummarize:</p><p>因此，除了Lisp社区之外，世界上的每个人都面临着相同的基本文本处理问题，我将对此进行总结：</p><p>  Doing this  effectively requires your data to be tree-structured. Regexps don&#39;t cut it for any data or processing that&#39;s sufficiently complex.</p><p>要有效地做到这一点，您的数据必须是树形结构的。Regexp不会对任何足够复杂的数据或处理进行裁剪。</p><p> Your only real option these days, for most languages, is to use XML. It has all the best tools and the widest support for  your language.</p><p>如今，对于大多数语言来说，您唯一真正的选择就是使用XML。它拥有所有最好的工具，并对您的语言提供最广泛的支持。</p><p> XML processing, which is supposed to be easy, starts to become arbitrarily complex when you start having to use XSLT or XQuery, or roll your own transformations using a SAX or DOM parser in your favorite language.</p><p>当您开始必须使用XSLT或XQuery，或者使用您喜欢的语言中的SAX或DOM解析器进行自己的转换时，本应简单的XML处理开始变得任意复杂。</p><p>   In Lisp, your code  is data, and your data  iscode, so you have a third option (aside from regexps or XML)that&#39;s not realistically an option in any other language:  you store your text data as a  lisp program.</p><p>在Lisp中，您的代码是数据，您的数据是代码，所以您还有第三个选择(除了regexp或XML)，这在任何其他语言中实际上都不是一个选择：将文本数据存储为LISP程序。</p><p> If you simply want to scan it visually, well, you can see for yourselfin my example above, it&#39;s easier on the eyes than XML. It&#39;s also morecompact, which is easier on the disks, networks, databases, andIDEs.</p><p>如果您只是想要直观地扫描它，那么您可以自己看看，在我上面的例子中，它比XML更容易看起来。它也更小巧，在磁盘、网络、数据库等方面更容易使用。</p><p> If you want to query it, you load it in and use Lisp functions, whichnow include various flavors of path expressions, including XPath,if you like.</p><p>如果您想要查询它，您可以加载它并使用Lisp函数，这些函数现在包括各种风格的路径表达式，如果您愿意的话，还可以包括XPath。</p><p> And if you want to transform it, well, you can write your owntransformer, of course, but it&#39;s probably easier to make the actualcode know how to transform itself. In any case, your transformerswill be easier to write, since they have all the benefits of XSLT(i.e. transformers can themselves be auto-generated andauto-transformed, breaking things into nice stages), without all thedownsides of XSLT (ugliness, surliness, no fun at parties, etc.)</p><p>如果你想转换它，当然，你可以编写你自己的转换器，但是让实际代码知道如何自我转换可能更容易。在任何情况下，您的转换器都更容易编写，因为它们具有XSLT的所有优点(即转换器本身可以自动生成和自动转换，将事情分成多个很好的阶段)，而没有XSLT的所有缺点(丑陋、粗暴、在聚会上没有乐趣，等等)。</p><p>  Of course we&#39;re not just talking about log data. The situation iseven clearer for configuration files. You definitely want them in XML, except it has the same problems, so... Hey, waita minute — if your configuration file is... Lisp, then it&#39;s notreally a... configuration file anymore; it&#39;s part of your... program?Is that right?</p><p>当然，我们谈论的不仅仅是日志数据。对于配置文件来说，情况就更清楚了。您肯定希望它们是XML格式的，只是它有相同的问题，所以...。嘿，等一下-如果你的配置文件是...。口齿不清，那它就不是真正的.。配置文件不再是您的...的一部分。节目？是这样吗？</p><p>  The whole nasty &#34;configuration&#34; problem becomes incredibly moreconvenient in the Lisp world. No more stanza files, apache-config,.properties files, XML configuration files, Makefiles — all thoselame, crappy, half-language creatures that you wish were executable,or at least loaded directly into your program without specializedprocessing. I know, I know — everyone raves about the power ofseparating your code and your data. That&#39;s because they&#39;re usinglanguages that simply can&#39;t do a good job of representing data ascode. But it&#39;s what you really want, or all the creepy half-languageswouldn&#39;t all evolve towards being Turing-complete, would they?</p><p>在Lisp世界中，整个令人讨厌的配置问题变得令人难以置信地更加方便。不再有节文件、apache-config、.properties文件、XML配置文件、Makefile-所有那些您希望是可执行的、拙劣的、半语言的生物，或者至少不需要特殊处理就直接加载到您的程序中。我知道，我知道--每个人都对分离你的代码和数据的力量赞不绝口。这是因为他们使用的语言根本不能很好地将数据表示为代码。但这才是你真正想要的，否则所有令人毛骨悚然的半种语言都不会朝着图灵完备的方向发展，不是吗？</p><p> In fact, if you insist on code/data separation  and you&#39;rean advocate of OOP, then you&#39;re talking out of both sides of your mouth.If your gut reaction to having log entries know how to transform orprocess themselves is &#34;woah, that&#39;s just  wrong&#34;, thinkagain: you&#39;re imposing a world-view on the problem that&#39;s notconsistent with your notions of data encapsulation and active objects.This world-view dates back to ancient Unix and pre-Unix days. Butif you think about it, there&#39;s no reason log entries or config filesshouldn&#39;t be executable and subclassable. It might be better.</p><p>事实上，如果你坚持代码/数据分离，而你又是OOP的倡导者，那么你就是在胡说八道。如果你对让日志条目知道如何自我转换或处理的直觉反应是哇，那就大错特错了，想想：你正在强加一个世界观来解决这个问题，这个世界观与你对数据封装和活动对象的概念不一致。这种世界观可以追溯到古代Unix和Unix之前的时代。但是如果你仔细想想，没有理由日志条目或配置文件不应该是可执行的和子类的。这样可能会更好。</p><p> And what about, oh, web pages? Or word-processor documents? Well, youfigure it out. Web pages use HTML, which isn&#39;t even powerful enough torepresent  text styles, let alone something like an eventhandler. So Web pages have CSS, and JavaScript, and all this otherhooey. It&#39;s become so ugly that people don&#39;t really write web pagesanymore, not for production stuff. Nowadays people treat the morassof ancient, crufty Web technologies as a sort of assembly language.You write code to assemble your pages piecewise using PHP or XML/XSLTor Perl/Mason or Java/JSP or perhaps all of them in a giant uglypipeline, which &#34;compiles&#34; down to an unreadable Web page format.Talk about fun!</p><p>那么，哦，网页呢？还是文字处理器文档？好吧，你自己想办法吧。网页使用HTML，它的功能甚至不足以表示文本样式，更不用说像晚行者那样的东西了。所以网页有CSS、JavaScript等等。它变得如此丑陋，以至于人们不再真正地写网页，也不再写制作用的东西。现在，人们把陈旧、肮脏的网络技术视为一种汇编语言。你用PHP、XML/XSLT、Perl/Mason或Java/JSP来编写代码，把你的页面分段组装起来，或者也许所有这些都放在一条巨大的uglypipeline中，它会编译成一种难以阅读的网页格式。说来有趣！</p><p> I can tell you in all honesty: everyone who tries this feels pain.And there are a  lot of people in the world doing exactly whatI described above. Building production websites == pain. The worldis gradually, very slowly, converging towards using a variety of&#34;executable XML&#34; formats (e.g. Ant, Jelly, Cocoon) which... well, theysort of ease the pain, but it&#39;s replaced with new pain: the pain ofthe executable-XML language designers not having a frigging clue whatthey&#39;re doing.</p><p>我可以坦率地告诉你：每个尝试这样做的人都会感到痛苦。世界上有很多人都在做我上面描述的事情。建设生产网站==痛苦。世界正在逐渐地、非常缓慢地向使用各种可执行的XML格式(例如，蚂蚁、果冻、茧)汇聚，这些格式……。嗯，它们在某种程度上缓解了痛苦，但它被新的痛苦所取代：可执行XML语言设计者对他们正在做的事情一无所知的痛苦。</p><p> So now Ant has a macro system, and try/catch tags, and if-tags, andit&#39;s gradually migrating towards Turing-completeness if it&#39;s not therealready. But it still has all the same yucky problems it&#39;s had fromday one: properties that look like variables that you can only setonce, and weird inconsistencies in the way the tags work,and of course the fact that it&#39;s automatically 10x as verbose as aprogramming language because it&#39;s XML. Don&#39;t get me wrong — it&#39;sstill way better than Make. But that&#39;s not a very high bar now,is it?</p><p>所以现在Ant有了一个宏系统，Try/Catch标签，if标签，如果它还没有的话，它正逐渐迁移到图灵完整性(Turing-Complete)。但它仍然有从第一天起就存在的所有令人讨厌的问题：看起来像只能设置一次的变量的属性，以及标签工作方式的奇怪不一致，当然还有一个事实，即它自动地比编程语言冗长10倍，因为它是XML。别误会我的意思--它仍然比制造好得多。但是现在这个门槛不是很高，不是吗？</p><p> Let&#39;s face it: a Turing-complete Ant (or Jelly, or any pure-XMLprocessing framework) is going to be a monstrosity, because it willtake years (if not decades) for them to figure out thatTuring-completeness does not equal expressiveness, and they&#39;llhave to add lexical scoping, and data types, and a class system,and first-class functions, and and and...</p><p>让我们面对现实吧：图灵完整的Ant(或Jelly，或任何纯XML处理框架)将是一个庞然大物，因为他们需要数年(如果不是几十年)才能弄清楚图灵完整性不等于表现力，他们将不得不添加词法作用域、数据类型、类系统和一流的函数，而且……。</p><p>   How did I get so far off the original track of text processing? Well,that&#39;s the punch line of this shaggy-dog story: it&#39;s  all textprocessing! Log files, configuration files, XML data, query strings,mini-languages, programming languages, transformers, web pages, worddocuments,  everything... the vast majority of yourprogramming work involves text processing somehow.</p><p>我怎么会偏离文本处理的原始轨道这么远呢？嗯，这就是这个乱七八糟的故事的妙处：全是文本处理！日志文件、配置文件、XML数据、查询字符串、迷你语言、编程语言、转换器、网页、Word文档，应有尽有……。您的绝大多数编程工作都以某种方式涉及到文本处理。</p><p> What would you rather do? Learn 16 different languages and frameworksin order to do &#34;simple&#34; log-file and configuration-file processing?Or just buckle down, learn Lisp, and have all of these problems goaway forever?</p><p>你更愿意做什么？学习16种不同的语言和框架，以便进行简单的日志文件和配置文件处理？还是只需认真学习Lisp，所有这些问题就一劳永逸了？</p><p> It&#39;s a rhetorical question. The answer is patently obvious at thispoint:   Lisp is  evil, and you&#39;d damned well betterwrite all your code in C++ and XML and JavaScript and PL*SQL and CSSand XSLT and regular expressions and all those other God-fearingred-blooded manly patriotic all-American languages from now on. No more of this crazy Lisp talk, ya hear?</p><p>这是一个反问句。在这一点上，答案显然是显而易见的：Lisp是邪恶的，从现在开始，你最好用C++、XML、JavaScript、PL*SQL、CSS、XSLT和正则表达式以及所有其他敬畏上帝的、热血的、充满爱国精神的全美语言来编写所有的代码。别再说这种疯狂的里斯普话了，听到了吗？</p><p> Welcome to my life. I&#39;m the cow in the Gary Larsen comic — the onewho looks up, shocked, and says: &#34;Hey, wait a minute! This is grass!We&#39;ve been eating  grass.&#34; The other cows stare blankly,munching the grass.</p><p>欢迎来到我的生活。我是加里·拉森漫画中的奶牛--抬起头，震惊地说：嘿，等一下！这是草！我们一直在吃草。&#34；其他的牛茫然地盯着，嚼着草。</p><p> Actually, I do feel like that cow, but I also feel a bit likeone of the characters in Salman Rushdie&#39;s Midnight&#39;s Children.(It&#39;s one of the most amazing fictional works ever written, andif you haven&#39;t read it, you&#39;re missing out.) There&#39;s a characterwho can travel forward and backward through time, so he canof course see the future. The funny thing is:   all the otherchildren, even though they  know he can see the future,refuse to believe anything he says about it.</p><p>事实上，我确实觉得自己像那头牛，但我也觉得自己有点像萨尔曼·拉什迪(Salman Rushdie)的“午夜的孩子”(Midnight‘s Children)中的一个人物。(这是有史以来最令人惊叹的虚构作品之一，如果你没有读过，那你就错过了。)。有一个角色可以在时间中来回穿梭，所以他当然可以看到未来。有趣的是：所有其他孩子，即使他们知道他能预见未来，也拒绝相信他说的任何话。</p><p> Yes, you&#39;re probably boiling over with objections to my littlediscussion above. You think I&#39;m trivializing things, or you thinkthat perhaps I&#39;m overstating the importance of tree-structured data(perhaps you&#39;re not an XML fan), or maybe you&#39;re simply mad at me forreasons you can&#39;t really articulate, other than to say, vaguely, thatI appear to have &#34;Paul Graham-itis&#34;. I understand how you feel.</p><p>是的，你可能会因为反对我上面的小讨论而勃然大怒。你认为我在小题大做，或者你认为我可能夸大了树形结构数据的重要性(也许你不是XML爱好者)，或者你只是因为你不能真正清楚地说出我似乎有保罗·格雷厄姆-伊蒂斯(Paul Graham-tis)的原因而生我的气。我理解你的感受。</p><p>   Putting all ranting aside for the moment, let&#39;s talk about Charles&#39;second concern: wouldn&#39;t it be better if Emacs were written in Ruby?</p><p>暂时把所有的喧嚣放在一边，让我们来谈谈查尔斯的第二个问题：如果Emacs是用Ruby编写的，不是更好吗？</p><p> After all, Emacs is designed for manipulating any old kind of text,not just tree-structured text like XML or Lisp. And Charles was righton the mark when he said nothing in the Emacs libraries indicates thatEmacs-Lisp is particularly good for plain-vanilla text manipulation.It&#39;s missing a lot of features we&#39;ve become accustomed to. Perlhas raised the bar on ordinary/arbitrary string processing.</p><p>毕竟，Emacs是为操作任何旧类型的文本而设计的，而不仅仅是像XML或Lisp这样的树形结构文本。当查尔斯在Emacs库中什么也没说时，他是对的，这表明Emacs-Lisp特别适合普通文本操作。它缺少了许多我们已经习惯的功能。Perl提高了普通/任意字符串处理的标准。</p><p> Although a Ruby-based Emacs would probably be quite nice in somerespects, I now think (even liking Ruby as much as I do) a Common LispEmacs would be even nicer. I don&#39;t want to belabor it, because if youagree with me then you need no convincing, and if you don&#39;t, then youprobably cannot be convinced in any reasonable amount of time. Thesummary is that Lisp has intrinsic, un-beatable technical advantagesstemming from its s-expression structure, and Common Lisp has 20+years of maturity that give it far more stability, performance, andinteroperability than Ruby or Python will have for a long, long time (if ever.)</p><p>虽然从长远来看，基于Ruby的Emacs可能会相当不错，但我现在认为(甚至像我一样喜欢Ruby)Common LispEmacs会更好。我不想喋喋不休，因为如果你同意我的意见，那么你就不需要说服，如果你不同意，那么你很可能在任何合理的时间内都不会被说服。主要是，Lisp具有源自其s-表达式结构的固有的、无与伦比的技术优势，而Common Lisp已有20多年的成熟度，这使得它比Ruby或Python在很长很长一段时间内(如果有的话)具有更高的稳定性、性能和互操作性。</p><p>  That&#39;s the rub: Emacs Lisp is even older than Common Lisp, and it&#39;sgot some unfortunate incompatibilities with Common Lisp (and Schemeeven more so) that make porting forward so nontrivial as to be nearinga complete rewrite.</p><p>这就是问题所在：Emacs Lisp甚至比Common Lisp更早，而且它与Common Lisp(和Scheme更是如此)有一些不幸的不兼容之处，这使得向前移植变得如此重要，以至于几乎要完全重写。</p><p> Since Emacs is so ancient, there are millions of lines of fairlywell-debugged elisp code out there; it&#39;s one of the original andlongest-lived open-source applications, so you&#39;d have an absolutelyhuge task in trying to re-implement all of it. Most people who trythis wind up trying to create a &#34;compatibility-mode&#34; for old elispcode. Guile Emacs, JEmacs and a few Common Lisp editors all attemptthis, and none yet have succeeded at doing it well.</p><p>由于Emacs是如此古老，有数百万行经过良好调试的ELISP代码；它是原始的、寿命最长的开源应用程序之一，因此您将有一个绝对巨大的任务来尝试重新实现所有这些代码。大多数尝试此功能的人最终都试图为旧的elispcode创建兼容模式。Guile Emacs、JEmacs和一些Common Lisp编辑器都试图做到这一点，但都没有成功。</p><p> The other option is to just live with Emacs, since it  isstill Lisp, and even has a fairly comprehensive set of macros thatgive a large subset Common Lisp&#39;s functionality. So it&#39;s generallyeasier to hack Emacs to interoperate with your language (or anysystem, in fact) than it is to try to re-implement Emacs.</p><p>另一种选择是只使用Emacs，因为它仍然是Lisp，甚至有一套相当全面的宏集，提供了很大的Common Lisp功能子集。因此，破解Emacs以与您的语言(或实际上是任何系统)进行互操作通常比尝试重新实现Emacs更容易。</p><p> Unfortunately, this wouldn&#39;t really be a big deal if people could justgo in and hack on Emacs source code and &#34;fix things&#34;. For instance,I&#39;d love to add Perl5-compatible regular expressions, and areader-macro system to allow for raw strings (or at least hack in somesyntax to support regexps without having to double-escape everything).</p><p>不幸的是，如果人们可以直接进入并破解Emacs的源代码并修复问题，这真的不是什么大不了的事。例如，我喜欢添加与Perl5兼容的正则表达式，以及允许原始字符串的区域读取器-宏系统(或者至少在某些语法中进行修改以支持正则表达式，而不必对所有内容进行双重转义)。</p><p> But there are several blocking issues. One is that the Emacs folksare notoriously picky about contributions — you have to provide legalpaperwork saying the work is your own, that the FSF can use it, etc.It&#39;s the basic problem that led to Eric Raymond&#39;s famous  &#34;TheCathedral and the Bazaar&#34; essay — GNU Emacs is the archetypalCathedral. So: good luck getting your changes into Emacs. The Lucidfolks tried for a while, and ultimately forked the code base toproduce XEmacs, which is a famously bad situation.</p><p>但也有几个阻碍问题。其一，Emacs的民众对捐款的挑剔是出了名的--你必须提供法律文件，说明这些作品是你自己的，FSF可以使用它，等等。这是导致埃里克·雷蒙德(Eric Raymond)著名的大教堂和集市的基本问题--GNU Emacs就是原型大教堂。所以：祝您好运，让您的更改进入Emacs。Lucid家族尝试了一段时间，最终派生了代码库来生成XEmacs，这是出了名的糟糕情况。</p><p> The difficulty of contributing extends beyond the core binary. If youwanted to contribute, say, a pure-elisp String library (which Emacscould really use), or a collections package, I&#39;m not sure you couldpull it off. You&#39;d have to get it by RMS, and it seems fairlydaunting. RMS is, well, conservative — to put it mildly. I thinkhe&#39;s a superhero, but he doesn&#39;t make it easy to contribute to Emacs.</p><p>贡献的困难超出了核心二进制文件的范围。比方说，如果你想贡献一个纯ELISP的字符串库(Emacs确实可以使用它)，或者一个收藏包，我不确定你能不能做到。你必须通过RMS才能拿到它，这似乎相当令人望而生畏。RMS是，嗯，保守的-委婉地说。我认为他是个超级英雄，但他并不能让为Emacs捐款变得容易。</p><p> Even if contributing weren&#39;t such a hassle, it&#39;s not entirely clear topeople that Emacs is worth hacking on. It&#39;s missing many of the corerendering-engine features that would make it capable of doing, say, aWeb Browser. Getting it to the point where it could render PostScriptseems an impossible task.</p><p>即使捐款不是一件麻烦的事，我们也不完全清楚Emacs是否值得一试。它缺少了许多相关引擎功能，而这些功能将使它能够执行比方说网络浏览器的工作。(工业和信息化部电子科学技术情报研究所陈皓)。让它达到可以呈现PostScript的程度似乎是一项不可能完成的任务。</p><p> And many newer programmers aren&#39;t using Emacs at all; they&#39;ve beenlured away by the siren-song of IDEs like Eclipse, IntelliJ, VisualStudio, and so on. Emacs doesn&#39;t have a very pretty face (because ofthe simple rendering engine I mentioned above), and it certainlydoesn&#39;t have much marketing. Most programmers these days are quiteastonished that anyone would actually still use Emacs. If theyrealized how much functionality it has, and how powerful itsextensibility model is, they&#39;d be ten times as astonished. It&#39;s gotthings that Eclipse may  never have, not in a hundred years,and that&#39;s no exaggeration. If they tried hard enough, they wouldeventually wind up rewriting most of it in Lisp, which would be ratherironic, all in all.</p><p>而且许多新的程序员根本不使用Emacs；他们被Eclipse、IntelliJ、VisualStudio等IDE的诱惑力所吸引。Emacs的脸不是很漂亮(因为我上面提到的简单的渲染引擎)，而且它肯定没有太多的市场。如今，大多数程序员都非常惊讶，竟然有人还在使用Emacs。如果他们意识到它有多么多的功能，以及它的可扩展性模型是多么强大，他们会感到十倍的惊讶。它得到了Eclipse可能永远不会有的东西，一百年内都不会有，这一点也不夸张。如果他们足够努力，他们最终会用Lisp重写其中的大部分内容，总而言之，这将是非常具有讽刺意味的。</p><p>  So! The situation is best described as a &#34;dilemma&#34;. Emacs isn&#39;treally advancing, and it appears to be a lot of work to re-implementit in another language. (Not that people like the Guile folks aren&#39;ttrying, but it&#39;s still </p><p>所以!。这种情况最好用进退两难来形容。Emacs正在不断进步，要用另一种语言重新实现似乎有很多工作要做。(并不是说像狡猾的人这样的人正在努力，但它仍然在努力。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://sites.google.com/site/steveyegge2/the-emacs-problem">https://sites.google.com/site/steveyegge2/the-emacs-problem</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/emacs/">#emacs</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/xml/">#xml</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>