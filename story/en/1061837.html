<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Atari 2600游戏陷阱如何建立世界 How Atari 2600 Game Pitfall Builds Its World</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How Atari 2600 Game Pitfall Builds Its World<br/>Atari 2600游戏陷阱如何建立世界 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-11 07:56:59</div><div class="page_narrow text-break page_content"><p>Games for the Atari 2600 were quite constrained. When Warren Robinett first pitched the idea that would become  Adventure, a game where you would explore a world with many rooms and pick up items to help you along the way, he was denied because it wasn&#39;t thought feasible. And it made sense to do so. This was the late 70s; there had never been a game with multiple screens before. This was in the days of  Space Invaders and  Pac Man, when everything in a game was in front of the player at all times, so the fact that  Adventure was able to have 30 rooms when it was finally released in 1980 was quite impressive.</p><p>Atari 2600的游戏非常受约束。当沃伦罗宾特首先投球时，这是一个会成为冒险的想法，你会探索一个有很多房间的游戏，然后拿起物品来帮助你，他被否认，因为它不是可行的。这样做是有意义的。这是70年代末期;之前从未有过多个屏幕的游戏。这是在太空入侵者和PAC人的日子里，当一场比赛中的一切都是在玩家前面的时候，所以冒险能够在1980年终于发布时拥有30间房间的事实非常令人印象深刻。</p><p>    The opening screen of  Adventure. The player controls the dot (which Robinett called &#39;the man&#39;).</p><p>    冒险的开放屏幕。播放器控制点（罗宾特称为＃39;男人＆＃39;）。</p><p>    Each area shown on your television screen will have one or more barriers or walls, through which you CANNOT pass. There are one or more openings. To move from one area to an adjacent area, move &#34;off&#34; the television screen through one of the openings, the adjacent area will be shown on your television screen.</p><p>    电视屏幕上显示的每个区域都有一个或多个障碍或墙壁，通过您无法通过。有一个或多个开口。从一个区域移动到邻近区域，移动＆＃34;关闭＆＃34;电视屏幕通过其中一个开口，相邻区域将在电视屏幕上显示。</p><p>  It was quite an innovation to have multiple rooms, and the fact that  Adventure managed to have 30 was revolutionary. But  Pitfall!, made by David Crane and released in 1983, had 255, all of which were much more elaborate (graphically speaking) than anything in  Adventure. In this article we&#39;ll talk about how this was done.</p><p>  拥有多个房间是完全创新的创新，以及冒险设施拥有30个的事实是革命性的。但是，大卫起重机和1983年发布的陷阱！所有这些都比冒险中的任何东西都更加精致（图形）。在本文中，我们＆＃39;请谈谈这是如何完成的。</p><p>  The game  Superman had multiple rooms and was released before  Adventure, but was actually based on  Adventure&#39;s code.</p><p>  游戏超人有多个房间，在冒险之前发布，但实际上是基于冒险和＃39; S代码。</p><p>      But in order to fully appreciate the difficulty of such a feat let&#39;s note the difficulties faced by programmers for the Atari. The console itself had only 128 bytes of RAM. That&#39;s 1024 bits. For comparison, this sentence alone takes up more space if encoded in ASCII, let alone the UTF format in which it&#39;s actually encoded. Suffice it to say there was not much space on the Atari.</p><p>      但为了充分欣赏这样一个壮举的难度让＆＃39; s注意atari的程序员面临的困难。控制台本身只有128个字节的RAM。那个＆＃39; s 1024位。例如，如果在ASCII中编码，则这句话单独占用更多空间，更不用说它＆＃39; s实际编码的UTF格式。足以说Atari上没有太大的空间。</p><p>  But that&#39;s no matter, surely the cartidge itself offers sufficient space, right? Well, sort of. Atari 2600 cartidges at this point generally had 4 kilobytes of ROM, the vast majority of which had to be dedicated to the actual code. If we ignore the need to store code, we could dedicate 16 bytes per room, but of course we can&#39;t just ignore the space needed to store the code.</p><p>  但是，无论如何，禁止盒装本身提供足够的空间，对吧？好吧，有点。 Atari 2600箱在这一点上一般有4千字节的ROM，绝大多数必须致力于实际代码。如果我们忽略存储代码的需要，我们可以专用每房间16个字节，但当然我们可以＆＃39; t忽略存储代码所需的空间。 </p><p>  The addressable space for the Atari 2600 is actually only 2K. 4K was made possible by a technique called bank switching.</p><p>Atari 2600的可寻址空间实际上只有2k。通过一种名为Bank交换的技术实现4K。</p><p>      The way you make a large world without storing much data is by having some code generate it for you.</p><p>      在没有存储太多数据的情况下使一个大型世界的方式是通过让一些代码为您生成它。</p><p>  The biggest problem with this, however, is that you generally need to save the data you generated. This is what games such as  Rogue and  Minecraft do. They randomly generate worlds in order to give variety to players, but save the data once it&#39;s generated. The limitations of the Atari do not afford this luxury.</p><p>  但是，这是最大的问题是，您通常需要保存生成的数据。这是流氓和MINECRAFT等游戏。他们随机生成世界，以便为玩家提供品种，但一旦生成的＆＃39;生成的数据。 Atari的局限性不起这种奢侈品。</p><p>  Crane overcame this in two ways. The first was in the way he represented a room&#39;s layout in memory, and the second was the way in which he generated those representations. The way these representations are generated actually obviate the need to store anything but the current room in memory, but we&#39;ll get to that later. First we will look at how the current room is represented.</p><p>  起重机以两种方式夸大了这一点。第一个是他代表了一个房间的途中，第二个是他在他生成这些陈述的方式。生成这些表示的方式实际上避免了存储在内存中当前房间的任何东西的需要，但是我们稍后会到达那个。首先，我们将研究当前房间的代表。</p><p>    Crane used a single byte to represent the layout of the current room. That may seem incredible given all that&#39;s going on in any given room, but it&#39;s actually quite simple.</p><p>    起重机使用单个字节来表示当前房间的布局。在任何特定的房间里，尤其可能看起来令人难以置信，但它实际上非常简单。</p><p>  The byte that holds the layout of the current room is split into four parts:</p><p>  保持当前房间布局的字节被分成四个部分：</p><p>    The first three bits control which object spawns. This is complicated by two things, both of which are controlled by bits 3 to 5.</p><p>    对象产生的前三个位控制。这两件事都很复杂，两者都由比特3至5控制。 </p><p>  First, a room may contain a treasure (the case if bits 3 to 5 are 101). If it does contain a treasure, then the usual item determined by the bits does not appear and the corresponding treasure is put in its place.</p><p>首先，房间可以包含宝藏（如果位3至5的情况为101）。如果它确实包含宝藏，则不会出现由比特确定的通常项目，并且相应的宝藏将放入其位置。</p><p>  Second, if there are crocodiles (the case if bits 3 to 5 are 100) then bits 0 to 2 being 010, 011, 110 or 111 cause there to be a vine that allows the player to swing over the crocs. Otherwise there will be no vine, forcing the player to jump on the heads of the crocodiles to get across. The rules for items and treasures are</p><p>  其次，如果有鳄鱼（如果位3到5为100），则位0至2为010,011,110或111，导致允许玩家在Croc上摆动的vine。否则不会有藤蔓，强迫玩家跳上鳄鱼的头部来跨越。物品和宝藏的规则是</p><p>  I always write the high bit first, so &#39;100&#39; would more accurately be called bits 5 to 3.</p><p>  我总是先写下高位，所以＆＃39; 100＆＃39;将更准确地称为位5到3。</p><p>              Bits 6 and 7 determine the pattern of the trees. This doesn&#39;t affect the gameplay at all, but gives the player the sense of changing locations. The tree patterns are all very similar, so I won&#39;t go into detail here, but if you want to see what they are for yourself you can look at the trees in rooms 1, 2, 3, and 5 for bit patterns of 11, 10, 00, and 01 respectively.</p><p>              位6和7确定树的图案。这并不影响游戏玩法，但是给出了播放器的变化感。树形图案都非常相似，所以我在这里赢得了＆＃39;如果你想看看他们自己是什么，你可以看看1,2,3和5的房间里的树木分别为11,10,00和01。</p><p>    Bit 7 is reused to control whether the wall in the underground is drawn on the left or right. It doesn&#39;t control whether or not there is a wall, that&#39;s elsewhere in the code, but if there is a wall, then this bit being a 0 puts the wall to the left, and this bit being a 1 puts the wall to the right.</p><p>    位7被重用以控制左侧或右侧是否绘制地下的墙壁。它并不控制在代码中的其他地方，但是如果有墙，但如果有墙，那么这个位为0，左边是左边的墙，这一点是一个1将墙放在右侧。</p><p>  And that&#39;s how a single byte determines the layout of the current room. But like I mentioned, only the current room is ever stored in memory. How this is made possible is by the way the rooms were generated.</p><p>  和＃39; S单个字节如何确定当前房间的布局。但就像我提到的那样，只有当前的房间才能存储在内存中。这是如何成为可能的是房间的产生方式。</p><p>    The bytes that describe the room are generated by something that Crane called a polynomial counter, but what we now call a  linear feedback shift register, or LFSR.</p><p>    描述房间的字节由起重机称为多项式计数器的东西生成，但我们现在呼叫线性反馈移位寄存器或LFSR。 </p><p>  An LFSR is a way to generate pseudo random numbers from a seed by taking a binary number, performing a logical shift either left or right one, and then computing the input bit through a linear function of the original bits. Typically this function is a series of XORs.</p><p>LFSR是通过采用二进制数来从种子生成伪随机数的方式，执行左或右一个，然后通过原始位的线性函数计算输入比特。通常，此功能是一系列XORS。</p><p>    When the player starts the game the room byte is set to C4 in hex (11000100 in binary, 196 in decimal). This is the seed. When the player goes one room to the right, the byte is shifted to the left, and the low bit (bit 0) becomes the XOR of bits 3, 4, 5, and 7. The formula for this is</p><p>    当玩家开始游戏时，房间字节将在十六进制中设置为C4（在十进制的二进制，196中的11000100中）。这是种子。当播放器向右移动一个房间时，字节向左移动，低位（位0）变为位3,4,5和7的XOR</p><p>    Where &#39;+&#39; denotes XOR and the prime denotes a bit in the previous state. This pattern has the desirable property of being a maximal-length LFSR, which means that it will produce every combination of 8 bits save for all zeros. This allows the world in  Pitfall! to have both the greatest number of rooms as well as an equal likelihood for any given string of bits (save for, again, all zeros).</p><p>    在哪里＆＃39; +＆＃39;表示XOR，PRIME表示先前状态的一点。该模式具有作为最大长度LFSR的理想特性，这意味着它将产生8位的每个组合保存所有零。这允许世界陷入困境！拥有最多数量的房间以及任何给定的位数的平等可能性（再次保存，所有零）。</p><p>    So when you move to the right after the first room, the byte goes from 11000100 to 10001001. All the bits get shifted left, then bit 0 get set to 1, as 1 = 0 + 0 + 0 + 1.</p><p>    因此，当您在第一个房间后向右移动时，字节从11000100到10001001。所有位都移位，然后将位0设置为1，为1 = 0 + 0 + 0 + 1。</p><p>   ; room&#39; = room &lt;&lt; 1 | (bit3 + bit4 + bit5 + bit7) LOOP_ROOM:  LDA ROOM  ASL  EOR ROOM  ASL  EOR ROOM  ASL  ASL  EOR ROOM  ASL  ROL ROOM  DEX  BPL  LOOP_ROOM</p><p>   ;房间＆＃39; =室＆lt;＆lt; 1 | （Bit3 + Bit4 + Bit5 + Bit7）Loop_room：LDA室ASL房间ASL房间ASL ASL ASL EOR Room ASL ROL Room Dex BPL Loop_room</p><p>    ROOM is the byte that describes the current room. Before getting into how this works, it&#39;s important to note the last two lines, and why this is a loop. Crane wanted it so that if Pitfall Harry (the hero in  Pitfall!) is in the underground, then going over a room actually transports him over three rooms.  DEX decrements the  X register and  BPL branches if the preceding calculation wasn&#39;t negative, so Crane implemented this behavior by setting the  X register to  2 before calling this subroutine if Harry was underground. Otherwise the  X register is set to  0 and there&#39;s no looping.</p><p>    房间是描述当前房间的字节。在进入这是如何工作的之前，它很重要的是要注意最后两行，以及为什么这是一个循环。起重机想要它，这样如果捕捉哈利（陷阱中的英雄！）在地下，那么走过房间实际上将他运送到三个房间。如果前面的计算是N个＆＃39; t负数，则DEX递减X寄存器和BPL分支，因此起重机通过将X寄存器设置为2，在调用此子程序之前将X寄存器设置为2，如果Harry在地下，请在调用此子程序之前。否则，X寄存器设置为0和＃39;否循环。</p><p>  More accurately,  ROOM is the location in memory where the byte that describes the room is.</p><p>  更准确地说，房间是内存中的位置，其中描述了房间的字节。 </p><p>  So that&#39;s why it&#39;s a loop. The rest of the code is, as assembly code for the Atari often is, a bit dense. This isn&#39;t an article about 6502 assembly, so I won&#39;t go into too much detail, but basically what&#39;s going on is that the  ASL (arithmetic shift left) commands are moving the bits into the correct places, and the  EOR (exclusive or) commands are XOR-ing the bits. Finally, the  ROL (rotate left) command shifts the  ROOM byte to the left while inputting the carry bit into bit 0. That carry bit is a result of the previous  EOR&#39;s and  ASL&#39;s. And all of this together produces the desired behavior.</p><p>所以它＆＃39;为什么它＆＃39; s循环。其余的代码是，作为Atari的汇编代码通常是致密的。这是一个大约6502个装配的文章，所以我赢得了太多细节，但基本上正在发生＆＃39; s＆＃39; asl（算术偏移左）命令将比特移动到正确的地方，以及EOR（独占或）命令是XOR-ING。最后，ROL（旋转）命令将房间字节转移到左侧，同时将携带位输入到位0.携带位是先前EOR＆＃39; s和ASL的结果。所有这一切都会产生所需的行为。</p><p>  If we want to see every room that this generates, we can use the following 6502 assembly, which loops through the above code until the byte gets back to what it started as and stores every generated byte in order at addresses  $00 to  $FF (0 to 255).</p><p>  如果我们希望看到这一点的每个房间，我们都可以使用以下6502个装配，通过上面的代码循环，直到字节返回到它开始的内容并存储每个生成的字节，以便在地址$ 00到$ ff（0到255）。</p><p> LDA #0  ; initialize address offset to 0  TAX define ROOM $00 define SEED $C4  LDA #SEED  STA ROOM LOOP_ROOM:  ; do all the LFSR stuff  ASL  EOR ROOM  ASL  EOR ROOM  ASL  ASL  EOR ROOM  ASL  ROL ROOM  LDA ROOM  INX  ; increment address offset  STA $00,X  ; store generated byte  CMP #SEED  ; stop if we complete a cycle  BEQ  STOP  JMP  LOOP_ROOM  ; get next room byte STOP:  BRK</p><p> LDA＃0;初始化地址偏移到0税定义房间$ 00定义种子$ C4 LDA #seed STA Room_room：;所有的LFSR内容ASL房间ASL房间ASL ASL ASL ASL ROL ROL ROOL LDA Room Inx;递增地址偏移sta $ 00，x;存储生成的byte cmp #seed;如果我们完成一个循环beq stop jmp loop_room;得到下一个房间字节停止：brk</p><p>   But this doesn&#39;t get to why Crane&#39;s design was so genius. The above details what happens when you go right, but what about when you go left, back to where you came? The eight bits that describe that room were never stored in memory; only the current room is in memory. So how does  Pitfall! handle going left? Well, with this LFSR:</p><p>   但这并不是为了为什么起重机和＃39;设计是如此天才。上述详细信息当你对的时候会发生什么，但是当你离开时，呢？回到你来的地方？描述房间的八个比特从未存储在内存中;只有当前的房间内存。陷阱如何！把手留在左边？好吧，使用此LFSR：</p><p>  I&#39;m being a little loose with terminology. Technically &#39;LFSR&#39; refers to the register acted upon, but here I&#39;ll be using the term to refer to the formula that calculates the input bit.</p><p>  我＆＃39; m与术语有点松散。技术上＆＃39; lfsr＆＃39;指寄存器采取行动，但这里是我＆＃39; LL使用该术语来指代计算输入位的公式。</p><p>    What&#39;s special about this LFSR is that it is the inverse of the previous one. Every time you go left, this LFSR undoes what was last done by the LFSR used when you go right. From here on we&#39;ll refer to this LFSR as the left LFSR, and the previous one as the right LFSR.</p><p>    什么＆＃39;特别的关于这个lfsr是它是前一个的反比力。每次剩下，这次LFSR都会撤消当您正确使用的LFSR完成的工作。从这里的we＆＃39; ll将此LFSR称为左LFSR，以及前一个LFSR。</p><p>   ; room&#39; = room &gt;&gt; 1 | ((bit4 + bit5 + bit6 + bit0) * 128) LOOP_ROOM:  LDA ROOM  ASL  EOR ROOM  ASL  EOR ROOM  ASL  ASL  ROL  EOR ROOM  LSR  ROR ROOM  DEX  BPL  LOOP_ROOM</p><p>   ;房间＆＃39; =房间＆gt;＆gt; 1 | （（Bit4 + Bit5 + Bit6 + Bit0）* 128）Loop_Room：LDA室ASL房间ASL ROR ROL ROL EOR ROOL LSR ROR ROR ROR ROR ROR ROOR BPL Loop_room </p><p>  You might notice this LFSR is also labeled  LOOP_ROOM. This is from a disassembly, we don&#39;t know what Crane originally called this piece of code, but it&#39;s fine that they share the same label. This is because the branch commands ( BPL for example) can only offset the program counter by 255 at most, and these two labels are seperated by about 1000 instructions. To jump greater distances you need either the  JMP or  JSR command, which are unconditional jumps.</p><p>您可能会注意到此LFSR也标记为Loop_room。这是从拆卸，我们不知道最初称之为这段代码的起重机，但它很好，它们与他们共享相同的标签。这是因为分支命令（例如，BPL）最多只能将程序计数器偏移255，并且这两个标签被分开约1000个指令。跳跃更大的距离，您需要JMP或JSR命令，这些命令是无条件跳转。</p><p>  Let&#39;s just appreciate what Crane did for a moment. He found an LFSR that was both invertable  and maximal-length. That&#39;s some impressive programming. But I won&#39;t just ask you to take my word that these two LFSRs are inverses, I&#39;ll prove it to you.</p><p>  让＆＃39;据欣赏起重机拍了一下。他发现了一种可旋转和最大长度的LFSR。那些令人印象深刻的编程。但我赢了＆＃39; t只是请你把我的话语拿到这两个lfsrs是反演，我＆＃39; ll证明你。</p><p>    Consider a sequence of eight bits  B =  b 7  b 6  b 5  b 4  b 3  b 2  b 1  b 0. We&#39;ll use  B r to denote  B after applying the right LFSR and  B l to denote  B after applying the left LFSR. What we want to show is that  B rl =  B lr =  B. That is, we want to show that the result of applying the right and then the left LFSR, or the left and then the right, is the same as doing nothing.</p><p>    考虑一系列八位B = B 7 B 6 B 5 B 4 B 3 B 2 B 1 B 0. WE＆＃39; LL在施加右LFSR和B L之后使用B r表示B表示B留下LFSR。我们想要显示的是B RL = B LR = B.也就是说，我们希望展示应用右边的结果，然后左LFSR，或左侧，然后右侧，与无效相同。</p><p>  Formally, what we&#39;re showing is that the composition of two functions in either order equals the identity function, which would make the two functions inverses by definition.</p><p>  正式，我们＆＃39;重新显示的是，任一阶的两个函数的组成等于身份函数，这将使两个功能通过定义反转。</p><p>      Applying this to  B =  b 7  b 6  b 5  b 4  b 3  b 2  b 1  b 0 we get the following:</p><p>      将此应用于B = B 7 B 6 B 5 B 4 B 3 B 2 B 1 B 0我们得到以下内容：</p><p>            Which establishes the fact that  B rl =  B. Showing that  B lr =  B is much the same, so is left as an exercise for the reader. ∎</p><p>            这建立了B RL = B的事实。显示B LR = B是相同的，因此留下读者的练习。 ∎</p><p>    The above can also be verified with some simple code, so if you wish to try that  here&#39;s a small JavaScript program that&#39;ll do the job. Also included is a function that lists all the rooms.</p><p>    上面也可以用一些简单的代码来验证，所以如果您想尝试在这里＆＃39;＆＃39;＆＃39; ll做这项工作。还包括一个列出所有房间的函数。 </p><p>  And that&#39;s how  Pitfall! builds its world. A simple representation combined with an invertable linear feedback shift register.</p><p>那个＆＃39;如何陷阱！建立它的世界。一种简单的表示与可逆的线性反馈移位寄存器组合。</p><p>      You would think all the information about a game as influential and popular as  Pitfall! would be widespread and readily available. This is not the case.</p><p>      您会将关于游戏的所有信息作为有影响力和流行的陷阱！将是普遍的，随时可用。不是这种情况。</p><p>  The game&#39;s use of a LFSR is widely known, but how it was implemented is, as far as I can tell, not detailed anywhere save for in the actual assembly. But when I found  an analalyzed and commented version of the assembly the description given for the LFSR was actually incorrect! At least, the description of the left LFSR was incorrect. But it was wrong in a fairly obvious way, and it wasn&#39;t hard to figure out the correct way.</p><p>  游戏＆＃39;使用LFSR是众所周知的，但据我所知，它是如何实施的，而不是在实际装配中详细介绍。但是当我发现大会的分析和评论版本时，LFSR给出的描述实际上是不正确的！至少，左LFSR的描述不正确。但它以相当明显的方式出现了错误，而且难以弄清楚正确的方式。</p><p>  Originally the comment said that decrementing the LFSR entailed XOR-ing with the 1 bit instead of the 0 bit. It is now fixed.</p><p>  最初评论称，递减LFSR将XOR-ing与1位而不是0位。它现在是固定的。</p><p>  Much more involved was figuring out how the byte was actually translated into rendering the world. Nowhere, not in any talk, any webpage, any book, or in the commented source code, was a description of what series of bits corresponded to what patterns in the room. At first I tried to go through the assembly, but assembly written for the Atari is so optimized and hacky and uses so many tricks that it became obvious to me that that would be way too much of a hassle.</p><p>  更多涉及的是弄清楚字节如何实际翻译成世界。无处可见，不在任何谈话，任何网页，任何书籍或在评论中的源代码中，是描述了什么系列比特对应于房间内的模式的比赛。起初我试图经过大会，但为Atari写的大会是如此优化，言辞，并使用这么多技巧，对我来说显而易见的是，这将是太多麻烦的方式。</p><p>  So how did I do it? Well, I wrote a little program to generate the sequence of the LFSR (the JavaScript program linked to above) and I compared it to the rooms. Doing this for bit 7, which controlled the side of the screen the underground wall was drawn on, was easy, as were bits 6 and 7 controlling the trees. But for the others it was rather tedious.  This map was an invaluable resource.</p><p>  那我是怎么做到的？嗯，我写了一个小程序来生成LFSR的序列（与上面链接的JavaScript程序），我将其与房间进行比较。为位7进行这一点，它控制屏幕侧面的地下墙壁上绘制，很容易，而不是控制树木的比特6和7。但对于其他人来说，它相当乏味。这张地图是一个宝贵的资源。</p><p>  I&#39;m surprised that, as far as I can tell, I&#39;m the first to detail how exactly  Pitfall! rendered its world, but I&#39;m also kind of disappointed. If you haven&#39;t seen  this GDC talk about preserving the history of games you absolutely should. Unlike many other disciplines the history of software is not being well preserved, even though it should be the easiest to preserve. We have the original source code for basically zero games for the Atari, NES, SNES, ColecoVision, you name it. Disassemblies are invaluable, don&#39;t get me wrong, but they&#39;re not the original. And they show nothing about the original comments.</p><p>  我惊讶的是，据我所知，我是第一个细节的陷阱！呈现世界，但我也有点失望。如果你没有看到这个GDC谈论绝对应该保护你的游戏历史。与许多其他学科不同，软件历史并不完全保存，即使它应该是最容易的保护。我们拥有原始源代码的Atari，NES，Snes，ColeCovision，您将其命名为。拆卸是宝贵的，不要让我错了，但他们不是原来的。他们没有任何关于原始评论的信息。 </p><p>  Maybe if we&#39;re lucky Activision and Atari and Nintendo have all the original code somewhere in a vault, which they&#39;ll release freely into the public for the good of mankind, but I&#39;m not holding my breath. Everyone who is able should be working to preserve whatever piece of history they can, &#39;cause it&#39;s not gonna preserve itself.</p><p>也许如果我们＆＃39;重新幸运的Activision和Atari和Nintendo在一个保险库中的所有原始代码，它们＆＃39; ll自由地释放到公众身上，为人类的好处，但我没有屏住呼吸 。 能够努力保存他们可以努力的每个人都可以努力，＆＃39;因为它不会保护它。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://evoniuk.github.io/posts/pitfall.html">https://evoniuk.github.io/posts/pitfall.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/陷阱/">#陷阱</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pitfall/">#pitfall</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/房间/">#房间</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>