<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>剖析Apple M1 GPU，第一部分 Dissecting the Apple M1 GPU, part I</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Dissecting the Apple M1 GPU, part I<br/>剖析Apple M1 GPU，第一部分 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-09 07:07:30</div><div class="page_narrow text-break page_content"><p>Apple’s latest line of Macs includes their in-house “M1” system-on-chip, featuring a custom GPU. This poses a problem for those of us in the  Asahi Linux project who wish to run Linux on our devices, as this custom Apple GPU has neither public documentation nor open source drivers. Some speculate it might descend from PowerVR GPUs, as used in older iPhones, while others believe the GPU to be completely custom. But rumours and speculations are no fun when we can peek under the hood ourselves!</p><p>苹果最新的Mac系列包括其内部的“ M1”片上系统，该系统具有定制GPU。这对于希望在我们的设备上运行Linux的Asahi Linux项目中的我们来说是一个问题，因为此自定义Apple GPU既没有公共文档也没有开源驱动程序。一些人推测它可能来自旧款iPhone中使用的PowerVR GPU，而另一些人则认为GPU是完全定制的。但是，当我们自己窥视内部时，谣言和猜测就不好玩了！</p><p> A few weeks ago, I purchased a Mac Mini with an M1 GPU as a development target to study the instruction set and command stream, to understand the GPU’s architecture at a level not previously publicly understood, and ultimately to accelerate the development of a Mesa driver for the hardware. Today I’ve reached my first milestone: I now understand enough of the instruction set to disassemble simple shaders with a free and open-source tool chain,  released on GitHub here.</p><p> 几周前，我购买了带有M1 GPU的Mac Mini作为开发目标，以研究指令集和命令流，以前所未有的水平了解GPU的体系结构，并最终加快Mesa驱动程序的开发用于硬件。今天，我已经达到了自己的第一个里程碑：我现在已经了解了足够的指令集，可以使用免费的开放源代码工具链（在GitHub此处发布）分解简单的着色器。</p><p> The process for decoding the instruction set and command stream of the GPU parallels the same process I used for reverse-engineering Mali GPUs in the Panfrost project, originally pioneered by the Lima, Freedreno, and Nouveau free software driver projects. Typically, for Linux or Android driver reverse-engineering, a small wrap library will be written to inject into a test application via  LD_PRELOAD that hooks key system calls like  ioctl and  mmap in order to analyze user-kernel interactions. Once the “submit command buffer” call is issued, the library can dump all (mapped) shared memory for offline analysis.</p><p> 解码GPU的指令集和命令流的过程与我在Panfrost项目中对Mali GPU进行反向工程所使用的过程相似，该过程最初是由Lima，Freedreno和Nouveau自由软件驱动程序项目率先开发的。通常，对于Linux或Android驱动程序进行逆向工程，将编写一个小型包装库，以通过LD_PRELOAD注入到测试应用程序中，该应用程序挂接ioctl和mmap之类的关键系统调用，以便分析用户内核交互。发出“提交命令缓冲区”调用后，库可以转储所有（映射的）共享内存以进行脱机分析。</p><p> The same overall process will work for the M1, but there are some macOSisms that need to be translated. First, there is no  LD_PRELOAD on macOS; the equivalent is  DYLD_INSERT_LIBRARIES, which has some extra security features which are easy enough to turn off for our purposes. Second, while the standard Linux/BSD system calls do exist on macOS, they are not used for graphics drivers. Instead, Apple’s own  IOKit framework is used for both kernel and userspace drivers, with the critical entry point of  IOConnectCallMethod, an analogue of  ioctl. These differences are easy enough to paper over, but they do add a layer of distance from the standard Linux tooling.</p><p> M1可以使用相同的整体过程，但是需要翻译一些macOSism。首先，在macOS上没有LD_PRELOAD；等效项是DYLD_INSERT_LIBRARIES，它具有一些额外的安全功能，可以轻松地将其关闭以达到我们的目的。其次，尽管标准的Linux / BSD系统调用确实存在于macOS上，但它们并不用于图形驱动程序。相反，苹果自己的IOKit框架用于内核和用户空间驱动程序，其关键入口点是IOConnectCallMethod（与ioctl类似）。这些差异很容易被掩盖，但是它们确实与标准Linux工具增加了一层距离。</p><p> The bigger issue is orienting ourselves in the IOKit world. Since Linux is under a copyleft license, (legal) kernel drivers are open source, so the  ioctl interface is public, albeit vendor-specific. macOS’s kernel (XNU) being under a permissive license brings no such obligations; the kernel interface is proprietary and undocumented. Even after wrapping  IOConnectCallMethod, it took some elbow grease to identify the three critical calls: memory allocation, command buffer creation, and command buffer submission. Wrapping the allocation and creation calls is essential for tracking GPU visible memory (what we are interested in studying), and wrapping the submission call is essential for timing the memory dump.</p><p> 更大的问题是将自己定位在IOKit世界中。由于Linux具有copyleft许可证，因此（合法）内核驱动程序是开源的，因此ioctl接口是公共的，尽管特定于供应商。受许可的macOS内核（XNU）不承担任何此类义务；内核接口是专有的且未记录。即使在包装完IOConnectCallMethod之后，也需要花些时间来确定三个关键调用：内存分配，命令缓冲区创建和命令缓冲区提交。包装分配和创建调用对于跟踪GPU可见内存（我们感兴趣的研究对象）是必不可少的，包装提交调用对于计时内存转储至关重要。</p><p> With those obstacles cleared, we can finally get to the shader binaries, black boxes in themselves. However, the process from here on out is standard: start with the simplest fragment or compute shader possible, make a small change in the input source code, and compare the output binaries. Iterating on this process is tedious but will quickly reveal key structures, including opcode numbers.</p><p> 清除这些障碍之后，我们终于可以使用着色器二进制文件，即黑盒子。但是，从头到尾的过程是标准的：从最简单的片段或计算着色器开始，对输入源代码进行少量更改，然后比较输出二进制文件。重复此过程很繁琐，但是会很快揭示出关键结构，包括操作码编号。</p><p> The findings of the process documented in the free software disassembler confirm a number of traits of the GPU:</p><p> 自由软件反汇编器中记录的过程发现证实了GPU的许多特性： </p><p> One, this is a scalar architecture. Unlike some GPUs that are scalar for 32-bits but vectorized for 16-bits, the M1’s GPU is scalar at all bit sizes. Yet Metal optimization resources imply 16-bit arithmetic should be significantly faster, in addition to a reduction of register usage leading to higher thread count (occupancy). This suggests the hardware is superscalar, with more 16-bit ALUs than 32-bit ALUs, allowing the part to benefit from low-precision graphics shaders much more than competing chips can, while removing a great deal of complexity from the compiler.</p><p>一个，这是一个标量体系结构。与某些32位标量但16位矢量化的GPU不同，M1的GPU在所有位大小下都是标量。然而，Metal优化资源暗示16位算术应该大大加快，而且减少了寄存器使用量，从而导致更高的线程数（占用量）。这表明硬件是超标量的，与32位ALU相比，具有更多的16位ALU，从而使该部件比其他芯片更能受益于低精度图形着色器，同时消除了编译器的大量复杂性。</p><p> Two, this seems to handle scheduling in hardware, common among desktop GPUs but less so in the embedded space. This again makes the compiler simpler at the expense of more hardware. Instructions seem to have minimal encoding overhead, unlike other architectures which need to pad out instructions with  nop’s to accommodate highly constrained instruction sets.</p><p> 第二，这似乎可以处理硬件的调度，这在台式机GPU中很常见，但在嵌入式空间中则较少。这又使编译器更简单，但硬件更多。指令似乎具有最小的编码开销，这与其他体系结构不同，后者需要使用nop填充指令以适应高度受限的指令集。</p><p> Three, various modifiers are supported. Floating point ALUs can do clamps (saturate), negates, and absolute value modifiers “for free”, a common shader architecture trait. Further, most (all?) instructions can type-convert between 16-bit and 32-bit “for free” on both the destination and the sources, which allows the compiler to be much more aggressive about using 16-bit operations without risking conversion overheads. On the integer side, various bitwise complements and shifts are allowed on certain instructions for free. None of this is unique to Apple’s design, but it’s worth noting all the same.</p><p> 三，支持各种修饰符。浮点ALU可以“免费”进行钳位（饱和），取反和绝对值修改器，这是常见的着色器体系结构特征。此外，大多数（全部？）指令都可以在目标和源上“免费”在16位和32位之间进行类型转换，从而使编译器在使用16位操作时更具攻击性，而不会冒转换风险间接费用。在整数方面，某些指令可免费使用各种按位补码和移位。这些都不是Apple设计所独有的，但值得一提。</p><p> Finally, not all ALU instructions have the same timing. Instructions like  imad, used to multiply two integers and add a third, are avoided in favour of repeated  iadd integer addition instructions where possible. This also suggests a superscalar architecture; software-scheduled designs like those I work on for my day job cannot exploit differences in pipeline length, inadvertently slowing down simple instructions to match the speed of complex ones.</p><p> 最后，并非所有的ALU指令都具有相同的时序。避免使用像imad这样的指令来将两个整数相乘并加上第三个整数，而尽可能使用重复的iadd整数加法指令。这也暗示了超标量体系结构。像我日常工作一样，由软件计划的设计无法利用流水线长度上的差异，无意中降低了简单指令的速度，以适应复杂指令的速度。</p><p> From my prior experience working with GPUs, I continue to expect to find some eldritch horror waiting in the instruction set, to balloon compiler complexity. Though the above work currently covers only a small surface area of the instruction set, so far everything seems sound. There are no convoluted optimization tricks, but doing away with the trickery is creating a streamlined, efficient design that does one thing and does it well. Maybe Apple’s hardware engineers discovered it’s hard to beat simplicity.</p><p> 从我以前使用GPU的经验来看，我继续期望在指令集中发现一些等待着编译的复杂性的eldritch恐怖。尽管上述工作目前仅覆盖指令集的一小部分表面积，但到目前为止，一切似乎都还不错。没有复杂的优化技巧，但要消除这种技巧，就可以创建一种精简而有效的设计，该设计可以一劳永逸。也许苹果的硬件工程师发现很难克服简单性。</p><p> Alas, a shader tool chain isn’t much use without an open-source userspace driver. Next up: dissecting the command stream!</p><p> las，没有开放源代码的用户空间驱动程序，着色器工具链就没什么用了。下一步：剖析命令流！</p><p> Disclaimer: This work is a hobby project, conducted based on public information. Opinions expressed may not reflect those of my employer.</p><p> 免责声明：这项工作是一项业余项目，基于公共信息进行。所表达的观点可能无法反映我雇主的观点。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://rosenzweig.io/blog/asahi-gpu-part-1.html">https://rosenzweig.io/blog/asahi-gpu-part-1.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gpu/">#gpu</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>