<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我就是这么说的</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我就是这么说的</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-10 16:42:09</div><div class="page_narrow text-break page_content"><p>Every now and then I get questions on how to work with git in a smooth way when developing, bug-fixing or extending curl – or how I do it. After all, I  work on open source full time which means I have very frequent interactions with git (and GitHub). Simply put, I work with git all day long. Ordinary days, I issue git commands several hundred times.</p><p>时不时地，我会被问到如何在开发、修复错误或扩展curl时顺利地使用git，或者我是如何做到这一点的。毕竟，我全职从事开源工作，这意味着我与Git(和GitHub)的互动非常频繁。简而言之，我整天都在和Git打交道。平时，我会发出几百次git命令。</p><p> I have a very simple approach and way of working with git in curl. This is how it works.</p><p>我有一个非常简单的方法，可以在curl中使用git。这就是它的运作方式。</p><p>  I use git almost exclusively from the command line in a terminal. To help me see which branch I’m working in, I have this little bash helper script.</p><p>我几乎只在终端的命令行中使用git。为了帮助我了解我在哪个分支机构工作，我有这个小小的bash助手脚本。</p><p> brname () { a=$( git rev-parse --abbrev-ref HEAD 2&gt;/dev/null) if [ -n &#34;$a&#34; ]; then echo &#34; [$a]&#34; else echo &#34;&#34; fi}PS1=&#34;\u@\h:\w\$(brname)$ &#34;</p><p>Brname(){a=$(git rev-parse--abbrev-ref head 2&gt；/dev/null)如果[-n&#34；$a&#34；]；则ECHO&#34；[$a]&#34；ELSE ECHO&#34；&#34；FI}PS1=&#34；\u@\h：\W\$(Brname)$&#34；</p><p> That gives me a prompt that shows username, host name, the current working directory and the current checked out git branch.</p><p>这会给我一个提示符，显示用户名、主机名、当前工作目录和当前签出的git分支。</p><p> In addition: I use Debian’s  bash command line completion for git which is also really handy. It allows me to use tab to complete things like git commands and branch names.</p><p>此外，我对git使用Debian的bash命令行补全，这也非常方便。它允许我使用Tab键完成git命令和分支机构名称等操作。</p><p>  I of course also have my customized  ~/.gitconfig file to provide me with some convenient aliases and settings. My most commonly used git aliases are:</p><p>当然，我也有自己定制的~/.gitconfig文件，可以为我提供一些方便的别名和设置。我最常用的git别名是：</p><p>  The ‘latest’ one is for listing all changes done to curl since the most recent RELEASE-NOTES “sync”. The others should hopefully be rather self-explanatory.</p><p>最新的一个是列出自最新版本以来对curl所做的所有更改-注释“同步”。其他的应该是不言而喻的。</p><p>   The main curl development is done in the single  curl/curl git repository (primarily hosted on GitHub). We keep the master branch the bleeding edge development tree and we work hard to always keep that working and functional. We do our releases off the master branch when that day comes (every eight weeks) and we provide “ daily snapshots” from that branch, put together – yeah – daily.</p><p>主要的curl开发是在单一的curl/curl git库中完成的(主要托管在GitHub上)。我们保留了主分支，即前沿开发树，并且我们努力工作，以始终保持它的工作和功能。当这一天到来的时候(每八周)，我们就会在主分支上发布，我们会提供该分支的“每日快照”，并将这些快照放在一起--对--每天。</p><p> When merging fixes and features into master, we avoid merge commits and use rebases and fast-forward as much as possible. This makes the branch very easy to browse, understand and work with – as it is 100% linear.</p><p>在将修复和功能合并到master中时，我们避免合并提交，并尽可能多地使用rebase和快进。这使得该分支非常易于浏览、理解和使用-因为它是100%线性的。</p><p>  When I start something new, like work on a bug or trying out someone’s patch or similar, I first create a local branch off master and work in that. That is, I don’t work directly in the master branch. Branches are easy and quick to do and there’s no reason to shy away from having loads of them!</p><p>当我开始做一些新的事情时，比如修复一个bug，或者尝试别人的补丁或类似的补丁，我会首先创建一个本地分支，然后在这个分支上工作。也就是说，我不是直接在总公司工作。分枝既容易又快捷，没有理由回避大量的分枝！</p><p> I typically name the branch prefixed with my GitHub user name, so that when I push them to the server it is noticeable who is the creator (and I can use the same branch name locally as I do remotely).</p><p>我通常使用GitHub用户名作为分支命名的前缀，这样当我将它们推送到服务器时，就会注意到谁是创建者(而且我可以在本地和远程使用相同的分支名称)。</p><p>  Once I’ve reached somewhere, I commit to the branch. It can then end up one or more commits before I consider myself “done for now” with what I was set out to do.</p><p>一旦我到了某个地方，我就会去树枝。然后，在我认为自己“暂时完成”之前，它可能会以一次或多次提交而告终，而我本来打算做的事情就已经完成了。</p><p> I try not to leave the tree with any uncommitted changes – like if I take off for the day or even just leave for food or an extended break. This puts the repository in a state that allows me to easily switch over to another branch when I get back – should I feel the need to. Plus, it’s better to commit and explain the change  before the break rather than having to recall the details again when coming back.</p><p>我尽量不带着任何未完成的改变离开这棵树--比如，如果我离开一天，甚至只是去吃东西或延长休息时间。这使存储库处于这样一种状态，即当我返回时，我可以轻松地切换到另一个分支--如果我觉得需要这样做的话。此外，最好在休息前承诺并解释更改，而不是回来时不得不再次回忆细节。</p><p>  “git stash” is therefore not a command I ever use. I rather create a new branch and commit the (temporary?) work in there as a potential new line of work.</p><p>因此，“git stash”不是我使用过的命令。我宁愿创建一个新分支并提交(临时？)。在那里工作，作为一种潜在的新工作方式。</p><p>  Yes I am the lead developer of the project but I still maintain the same work flow as everyone else. All changes, except the most minuscule ones, are done as pull requests on GitHub.</p><p>是的，我是这个项目的首席开发人员，但我仍然像其他人一样保持着相同的工作流程。除最微小的更改外，所有更改都是通过GitHub上的拉取请求完成的。</p><p> When I’m happy with the functionality in my local branch. When the bug seems to be fixed or the feature seems to be doing what it’s supposed to do and the test suite runs fine locally.</p><p>当我对我当地分店的功能感到满意的时候。当错误似乎被修复，或者功能似乎在做它应该做的事情，并且测试套件在本地运行良好时。</p><p> I then clean up the commit series with “ git rebase -i” (or if it is a single commit I can instead use just “ git commit --amend“).</p><p>然后，我使用“git rebase-i”清理提交序列(或者，如果是单次提交，我可以只使用“git Commit--amendate”)。</p><p> The commit series should be a set of logical changes that are related to this change and not any more than necessary, but kept separate if they are separate. Each commit also gets its own proper commit message. Unrelated changes should be split out into its own separate branch and subsequent separate pull request.</p><p>提交系列应该是一组与此更改相关的逻辑更改，并且不会超过必要的更改，但如果它们是分开的，则应保持独立。每个提交还获得其自己的正确提交消息。不相关的更改应分为独立的分支和后续的单独拉入请求。</p><p>   On GitHub, I then make the newly pushed branch into a  pull request (aka “a PR”). It will then become visible in the list of pull requests on the site for the curl source repository, it will be announced in the #curl IRC channel and everyone who follows the repository on GitHub will be notified accordingly.</p><p>然后，在GitHub上，我将新推送的分支转换为Pull请求(也称为“PR”)。然后，它将出现在站点上对curl源库的请求列表中，它将在#curl IRC频道中公布，所有在GitHub上关注该库的人都会收到相应的通知。</p><p> Perhaps most importantly, a pull request kicks of a flood of CI jobs that will build and test the code in numerous different combinations and on several platforms, and the results of those tests will trickle in over the coming hours. When I write this, we have around 90 different CI jobs – per pull request – and something like 8 different code analyzers will scrutinize the change to see if there’s any obvious flaws in there.</p><p>也许最重要的是，拉请求会引发大量的CI工作，这些工作将在许多不同的组合和几个平台上构建和测试代码，这些测试的结果将在接下来的几个小时内陆续公布。当我写这篇文章的时候，我们有大约90个不同的CI任务-每个拉取请求-大约8个不同的代码分析器将仔细检查这个变化，看看其中是否有任何明显的缺陷。</p><p>   Most contributors who would work on curl would not do like me and make the branch in the curl repository itself, but would rather do them in their own forked version instead. The difference isn’t that big and I  could of course also do it that way.</p><p>大多数使用cURL的贡献者不会像我这样在curl库中创建分支，而是更愿意在他们自己的派生版本中创建分支。差别不是很大，我当然也可以那样做。</p><p>  As it will take some time to get the full CI results from the PR to come in (generally a few hours), I switch over to the next branch with work on my agenda. On a normal work-day I can easily move over ten different branches, polish them and submit updates in their respective pull-requests.</p><p>由于需要一些时间才能从公关处获得完整的CI结果(通常需要几个小时)，所以我切换到下一个分支机构处理我的议程上的工作。在正常的工作日，我可以轻松地移动到10个不同的分支机构，对它们进行润色，并在它们各自的拉取请求中提交更新。</p><p> I can go back to the master branch again with ‘ git checkout master‘ and there I can “ git pull” to get everything from upstream – like when my fellow developers have pushed stuff in the mean time.</p><p>我可以再次回到Git Check Master分支机构，在那里我可以“Git Pull”从上游获取所有东西-就像我的开发伙伴在同一时间推东西的时候一样。</p><p>  If a reviewer or a CI job find a mistake in one of my PRs, that becomes visible on GitHub and I get to work to handle it. To either fix the bug or discuss with the reviewer what the better approach might be.</p><p>如果审查员或CI工作人员在我的公关中发现了错误，GitHub上就会显示出来，我就会开始处理。要么修复错误，要么与评审者讨论什么是更好的方法。</p><p> Unfortunately, flaky CI jobs is a part of life so very often there ends up one or two red markers in the list of CI jobs that can be ignored as the test failures in them are there due to problems in the setup and not because of actual mistakes in the PR…</p><p>不幸的是，不稳定的CI作业是生活的一部分，因此在CI作业列表中经常会出现一两个红色标记，可以忽略，因为其中的测试失败是由于设置中的问题，而不是PR…中的实际错误。</p><p> To get back to my branch for that PR again, I “ git checkout bagder/my-new-stuff-or-bugfix“, and fix the issues.</p><p>为了再次回到我的分支机构进行公关，我“git check out bagder/my-new-thing-or-bugfix”，并修复了这些问题。</p><p> I normally start out by doing follow-up commits that repair the immediate mistake and push them on the branch:</p><p>我通常从后续提交开始，修复直接的错误，并将它们推到分支上：</p><p>  If the number of fixup commits gets large, or if the follow-up fixes aren’t small, I usually end up doing a squash to reduce the number of commits into a smaller, simpler set, and then force-push them to the branch.</p><p>如果修复提交的数量变大，或者如果后续的修复不是很少，我通常会进行挤压以将提交的数量减少到一个更小、更简单的集合，然后将它们强制推到分支。</p><p> The reason for that is to make the patch series easy to review, read and understand. When a commit series has too many commits that changes the previous commits, it becomes hard to review.</p><p>这样做的原因是为了使补丁系列易于查看、阅读和理解。如果提交序列中的提交太多，从而更改了以前的提交，则很难对其进行审查。</p><p>  When the pull request is ripe for merging (independently of who authored it), I switch over to the master branch again and I merge the pull request’s commits into it. In special cases I cherry-pick specific commits from the branch instead. When all the stuff has been yanked into master properly that should be there, I push the changes to the remote.</p><p>当Pull请求的合并时机成熟时(与作者无关)，我再次切换到主分支，并将Pull请求的提交合并到其中。在特殊情况下，我会从分支中挑选特定的提交。当所有应该放在那里的东西都被正确地拉入主机时，我就把零钱推到遥控器上。</p><p> Usually, and especially if the pull request wasn’t done by me, I also go over the commit messages and polish them somewhat before I push everything. Commit messages should follow our style and mention not only which PR that it closes but also which issue it fixes and properly give credit to the bug reporter and all the helpers – using the right syntax so that our automatic tools can pick them up correctly!</p><p>通常，特别是如果拉请求不是由我完成的，我还会在推送所有内容之前检查提交消息并对其进行一些润色。提交消息应该遵循我们的风格，不仅提到它关闭了哪个PR，而且还提到它修复了哪个问题，并适当地给予错误报告者和所有帮助者信任-使用正确的语法，以便我们的自动工具可以正确地提取它们！</p><p>   There’s a button GitHub that says “rebase and merge” that could theoretically be used for merging pull requests. I  never use that (and if I could, I’d disable/hide it). The reasons are simply:</p><p>GitHub上有一个按钮，上面写着“Rebase and Merge”，理论上可以用来合并Pull请求。我从不使用它(如果可以的话，我会禁用/隐藏它)。原因很简单：</p><p> I don’t feel that I have the proper control of the commit message(s)</p><p>我觉得我无法正确控制提交消息。</p><p> I can’t select to squash a subset of the commits, only all or nothing</p><p>我不能选择压缩提交的子集，只能全部压缩或不压缩。</p><p> I often want to cleanup the author parts too before push, which the UI doesn’t allow</p><p>我经常想在推送之前清理作者部分，这是用户界面不允许的。</p><p> The downside with not using the merge button is that the message in the PR says “closed by [hash]” instead of “merged in…” which causes confusion to a fair amount of users who don’t realize it means that it actually means the same thing! I consider this is a (long-standing) GitHub UX flaw.</p><p>不使用合并按钮的缺点是，PR中的消息显示为“Closed by[Hash]”，而不是“Merge in…”这会让相当多的用户感到困惑，他们没有意识到这意味着它实际上是一回事！我认为这是(长期)GitHub UX的一个缺陷。</p><p>  If the branch has nothing to be kept around more, I delete the local branch again with “ git branch -d [name]” and I remove it remotely too since it was completely merged there’s no reason to keep the work version left.</p><p>如果分支没有更多需要保留的内容，我会使用“git Branch-d[name]”再次删除本地分支，并远程删除它，因为它已经完全合并，没有理由保留工作版本。</p><p> At any given point in time, I have some 20-30 different local branches alive using this approach so things I work on over time all live in their own branches and also submissions from various people that haven’t been merged into master yet exist in branches of various maturity levels. Out of those local branches, the number of concurrent pull requests I have in progress can be somewhere between just a few up to ten, twelve something.</p><p>在任何给定的时间点，我都有大约20-30个不同的本地分支机构在使用这种方法，所以我长期从事的工作都在它们自己的分支机构中进行，也有来自不同人的提交，这些提交还没有合并到Master中，但存在于不同成熟度级别的分支机构中。在这些本地分支中，我正在处理的并发拉请求的数量可能在几到十到十二个之间。</p><p>  Not strictly related, but in order to keep interested people informed about what’s happening in the tree, we sync the  RELEASE-NOTES file every once in a while. Maybe every 5-7 days or so. It thus becomes a file that explains what we’ve worked on since the previous release and it makes it well-maintained and ready by the time the release day comes.</p><p>没有严格的关系，但为了让感兴趣的人了解树中正在发生的事情，我们偶尔同步发布说明文件。可能每隔5-7天左右。因此，它变成了一个文件，解释了自上一版本以来我们所做的工作，并使其在发布日到来时得到了良好的维护和准备。</p><p>   Which makes the script add suggested updates to it, so I then load the file into my editor, remove the separation marker and all entries that don’t actually belong there (as the script adds all commits as entries as it can’t judge the importance).</p><p>这使得脚本向其添加建议的更新，因此我随后将该文件加载到我的编辑器中，删除分隔标记和实际上不属于那里的所有条目(因为脚本将所有提交作为条目添加，因为它无法判断重要性)。</p><p> When it looks okay, I run a cleanup round to make it sort it and remove unused references from the file…</p><p>当它看起来没问题时，我运行一次清理循环，让它对其进行排序，并从文件…中删除未使用的引用。</p><p>    … and paste that updated list into the RELEASE-NOTES. Finally, I get refreshed counters for the numbers at the top of the file by running</p><p>…。并将更新后的列表粘贴到发行说明中。最后，我通过运行以下命令获得文件顶部数字的刷新计数器。</p><p>  Then I commit the update (which needs to have the commit message  RELEASE-NOTES: synced“) and push it to master. Done!</p><p>然后，我提交更新(需要有提交消息Release-NOTES：SYNCED“)并将其推送到master。搞定了！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://daniel.haxx.se/blog/2020/11/09/this-is-how-i-git/">https://daniel.haxx.se/blog/2020/11/09/this-is-how-i-git/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033532.html"><img src="http://img2.diglog.com/img/2020/11/thumb_5e143a32f7969efc4f275fd50bf175e2.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033532.html">签名的Git推送</a></div><span class="my_story_list_date">2020-11-6 18:8</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032920.html"><img src="http://img2.diglog.com/img/2020/11/thumb_a43233b95ced0cf51878a1f2af7b4ac9.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032920.html">在降价中创建Git差异</a></div><span class="my_story_list_date">2020-11-3 13:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031563.html"><img src="http://img2.diglog.com/img/2020/10/thumb_ddcebc24c93769a39bbe0a3a1529926d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031563.html">Git过滤机制的使用方式与Git LFS不同</a></div><span class="my_story_list_date">2020-10-28 2:16</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029888.html"><img src="http://img2.diglog.com/img/2020/10/thumb_1f2b2be319b55f9d6b730c81d2e39952.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029888.html">Git 2.29亮点</a></div><span class="my_story_list_date">2020-10-20 3:23</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>