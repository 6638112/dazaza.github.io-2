<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>rkyv比{bincode，capnp，cbor，flodbuffers，明信片，prost，}更快。 Rkyv is faster than {bincode, capnp, cbor, flatbuffers, postcard, prost, }</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rkyv is faster than {bincode, capnp, cbor, flatbuffers, postcard, prost, }<br/>rkyv比{bincode，capnp，cbor，flodbuffers，明信片，prost，}更快。 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-12 09:06:36</div><div class="page_narrow text-break page_content"><p>I&#39;ve been working on  rkyv, a zero-copy deserialization library, since November of 2020. rkyv is similar to  Cap&#39;n Proto and  FlatBuffers, but has a handful of different design choices that make it stand out:</p><p>我一直在2020年11月的零拷贝反序列化图书馆工作的rkyv .rkyv类似于Cap＆＃39; n qualto和flowbuffers，但有一个不同的设计选择，使它脱颖而出：</p><p>  But just having design goals isn&#39;t good enough, you need results to back them up. With that in mind, I can&#39;t disclaim enough that I am the creator and maintainer of rkyv. However, the last thing I want is to be biased, so I made some benchmarks to hopefully convince you on their own merits.</p><p>  但只是有设计目标是＆＃39; t足够好，你需要结果来备份它们。考虑到这一点，我可以＆＃39; t不足以让我是rkyv的创造者和维护者。然而，我想要的最后一件事就是偏见，所以我做了一些基准，希望能够以自己的优点说服你。</p><p>  There are a  couple  different  benchmarks already available, but in general they fail in a couple different ways:</p><p>  还有一些不同的基准已经提供，但总的来说，他们以几种不同的方式失败：</p><p>  This leads to highly variable results and can make it difficult to see whether one library is really faster than another</p><p>  这导致高度可变的结果，并且可能很难看出一个图书馆是否比另一个库更快</p><p>    For most serialization formats, all you can do is serialize and deserialize data. But zero-copy deserialization libraries can access and traverse data without deserializing it first. Knowing how these operations compare with each other is essential to evaluating their relative performance.</p><p>    对于大多数序列化格式，您可以执行的所有数据都是序列化和反序列化数据。但零拷贝解除级化库可以在不首先进行反序列化的情况下访问和遍历数据。了解这些操作如何相互比较至关重要，以评估它们的相对性能。</p><p>  With these shortcomings in mind, I set off to make my own benchmarks. The goal was to be thorough and complete, and I think I did a pretty good job.</p><p>  考虑到这些缺点，我掀起了自己的基准。目标是彻底和完整，我想我做得非常好。</p><p> You can run the benchmarks yourself or look over the raw data  from the github repo. I&#39;ll summarize the results.</p><p> 您可以自己运行基准测试或从GitHub Repo查看原始数据。我＆＃39; ll总结了结果。 </p><p>   log: a data set of HTTP request logs that are small and contain many strings</p><p>日志：小型且包含许多字符串的HTTP请求日志的数据集</p><p> mesh: a single mesh composed of triangles, each of which has three vertices and a normal</p><p> 网格：由三角形组成的单个网格，每个网格都有三个顶点和正常</p><p> Each data set is randomly generated from an RNG seeded with the  first 20 digits of pi, so the data tested is identical for every run. For each data set, a library was measured for the following:</p><p> 每个数据集都是从使用PI的前20位接种的RNG随机生成的，因此每个运行都有相同的数据。对于每个数据集，衡量了一个图书馆的：</p><p>     Abomonation requires a mutable backing to access and read serialized data. This means that it&#39;s not viable for some use cases.</p><p>     Abomonation需要一个可变的备份来访问和读取序列化数据。这意味着它＆＃39;对于某些用例不可行。</p><p>  While Flatbuffers and Cap&#39;n Proto support buffer mutation in the main (usually C++) libraries, the rust counterparts do not and they couldn&#39;t be tested for this.</p><p>  虽然FlinBuffers和Cap＆＃39; N proto支持缓冲缓冲突变在主要（通常是C ++）库中，生锈对应物没有，它们不能为此进行测试。</p><p> None of the other zero-copy deserialization frameworks provided deserialization capabilities by default. Writing and benchmarking my own deserialization code is somewhat meaningless for these. You can get an idea of what sort of deserialization performance you&#39;d get by looking at the read benchmark.</p><p> 默认情况下，其他零拷贝解序列化框架都没有提供反级化功能。写作和基准测试我自己的反序列化代码对于这些来说有点毫无意义。您可以了解您＆＃39; D通过查看读取基准测试，了解了什么样的反序列化性能。</p><p> Abomonation&#39;s  decode qualified as access not deserialize because it yields an immutable reference instead of a mutable object. In order to deserialize this object, a simple  Clone would suffice but I&#39;m not here to write and benchmark my own deserialization code.</p><p> Abomonation＆＃39; s的解码有资格作为访问不反序列化，因为它产生了不可变的引用而不是可变对象。为了使这个对象进行反序列化，简单的克隆就足够了，但我不是在这里写和基准自己的反序列化代码。 </p><p>    This data set is composed of HTTP request logs that are small and contain many strings.</p><p>此数据集由HTTP请求日志组成，该日志很小，包含多个字符串。</p><p>        The data set is a single mesh. The mesh contains an array of triangles, each of which has threevertices and a normal vector.</p><p>        数据集是单个网格。该网格包含一系列三角形，每个三角形具有三个曲线和正常矢量。</p><p>                      Unsurprisingly, these two had very similar performance because they&#39;re almost the same format. CBOR did a bit better than serde_json in every benchmark, but these two consistently trailed behind all the other frameworks (in some cases, very considerably behind).</p><p>                      不出所料，这两个性能非常相似，因为它们几乎是相同的格式。 CORE比每个基准中的SERDE_JSON更好，但这两个一贯落后于所有其他框架（在某些情况下，非常大幅度）。</p><p>  Prost was the chosen representative for protobuf-style serialization. Its performance was average-to-lackluster on every benchmark, with the exception of the log size benchmark. It beat out postcard, which consistently performed extremely well in the size/zlib categories. This shows just how much the format was optimized for stringy data and minimizing wire size.</p><p>  Prost是Protobuf风格序列化的选择代表。其性能在每个基准测试中平均到缺乏风格，除了日志大小基准。它击败明信片，这在尺寸/ Zlib类别中一直非常好。这仅显示了针对Sringy数据进行优化的格式，并最大限度地减少线尺寸。</p><p>  Despite being completely different libraries, bincode and postcard had very similar benchmark results. Serialize and deserialize speed were very close for both of them, and the main difference between the two was usually the final size. Postcard consistently beat bincode on size and zlib. I suspect that they are using very similar techniques, but that postcard has a few more tricks up its sleeve that don&#39;t cost much to perform but give it a sizeable advantage.</p><p>  尽管是完全不同的库，但是Bincode和明信片具有非常相似的基准结果。序列化和反序列化速度非常接近它们，两者之间的主要区别通常是最终尺寸。明信片始终如一地击败Bincode大小和Zlib。我怀疑他们正在使用非常相似的技术，但明信片有几个诡计，袖子＆＃39; t成本很多，但给它一个相当大的优势。</p><p>  Cap&#39;n Proto had a good showing, and it proved its worth as a replacement for protobuf. Compared to prost, it was faster to serialize, and supported comparatively fast zero-copy deserialization. These two features are absolutely killer. Unfortunately, it didn&#39;t stack up nearly as well against the other zero-copy frameworks. It consistently had disapointing access and read times compared to its competitors, and failed pretty miserably on the mesh size benchmarks. This makes sense as it wasn&#39;t built to handle large amounts of raw data, but it was disappointing to see so much wasted space compared to FlatBuffers.</p><p>  帽子＆＃39; n proto有一个很好的表现，它证明了其值作为protobuf的替代品。与PROST相比，序列化更快，并支持相对快速的零拷贝反序列化。这两个功能绝对是杀手。不幸的是，它并没有堆积在另一个零拷贝框架上。与其竞争对手相比，它始终如一的访问和读取时间，并且在网格尺寸基准中失败了很糟糕。这是有道理的，因为它是为了处理大量的原始数据而构建的，但与FlinBuffers相比，看到如此多的浪费空间令人失望。</p><p>  FlatBuffers is the comparison point for zero-copy deserialization. It&#39;s got a lot of usage, was built specifically for performance, and proves out the zero-copy concept. It did well in all categories on most of the tests, but had a major stumbling block. In the  minecraft_savedata test, its serialization performance was by far the worst, even worse than serde_json (which had to write twice as much data!). This highlights a major weakness of FlatBuffers: its very poor serialization performance on highly-structured data. It&#39;s possible (even probable) that I wrote this bench more poorly than it could be, but it&#39;s enough that I wouldn&#39;t recommend its use for general-purpose data.</p><p>  FlodBuffers是零拷贝反序列化的比较点。它有很多用法，专门用于性能，并证明了零拷贝概念。它在大部分测试中的所有类别都做得很好，但有一个主要的绊脚石。在Minecraft_Savedata测试中，其序列化性能迄今为止，比Serde_JSON（必须编写两倍的数据！）。这突出了FlatBuffers的主要弱点：其在高结构数据上的序列化性能非常差。它可能（甚至可能是可能的），我将这个替补队写得比它更差，但它足够＆＃39;我应该为通用数据推荐它的用途。 </p><p>  Abomonation was definitely a bright spot in the benchmarks. It proved out its insanely fast serialization on every bench, and didn&#39;t suffer from some of the size traps that its competitors fell into. It would be an easy library to recommend if it didn&#39;t come with so many caveats. It&#39;s very unsafe, non-portable, requires mutable backing to access its data, and doesn&#39;t support mutations. Nonetheless, abomonation was a really impressive contender in every benchmark.</p><p>Abomonation绝对是基准中的亮点。它在每个替补席上都证明了其疯狂快速的序列化，并没有遭受其竞争对手陷入的一些大小陷阱。如果它没有带来这么多的警告，那将是一个简单的库。它＆＃39; s非常不安全，不可移植，需要可变的支持来访问其数据，并不支持突变。尽管如此，Abomonation在每个基准中都是一个非常令人印象深刻的竞争者。</p><p>  I went into these benchmarks not knowing how rkyv would perform relative to its peers, but confident that it would make a good showing. It ended up doing much better than I expected. It won nearly every performance category, and was highly competitive with the winner when it didn&#39;t. It also did so without compromising on size, where it was also highly competitive. Finally it showed exceptional scalability, peforming equally well on all different kinds of data where its zero-copy competitors all hard shortcomings on one or more of the data sets. Unlike abomonation, it&#39;s also a safe, highly-portable format that doesn&#39;t need mutable backing and has more feature support than other competitors.</p><p>  我进入了这些基准，不知道RKYV如何相对于同龄人表现，而是有信心它会发挥良好的表现。它最终比我预期的要好得多。它几乎赢得了几个绩效范畴，并且当它没有胜利时对胜利者具有竞争力。它也这样做也没有妥协，而且它也具有竞争力。最后，它表现出卓越的可扩展性，在其零拷贝竞争对手的所有不同类型的数据上都同样良好的性能，其在一个或多个数据集中的所有难点。与吸引力不同，它也是一种安全，高度便携的格式，不需要变形支持，并且具有比其他竞争对手更多的功能支持。</p><p>  I welcome and encourage anyone to run  the benchmarks for themselves and open pull requests to improve or clean up whatever they want. I am confident in the validity of these results, and will happily update the tables as changes are made. I will update my analyses if there are any major changes.</p><p>  我欢迎并鼓励任何人为自己运营基准，并打开拉出请求，以改善或清理他们想要的任何东西。我对这些结果的有效性充满信心，并随着更改的变化，乐意将表更新。如果存在任何重大更改，我将更新我的分析。</p><p> My hope is that this article not only convinced you that  rkyv is one of the best-performing serializers available, but that it also helped you understand the relationships between the different serialization solutions available in rust today.</p><p> 我的希望是，这篇文章不仅相信你的rkyv是最好的序列化者之一，但它还帮助了您了解Rusti上可用的不同序列化解决方案的关系。</p><p> If you&#39;re interested in rkyv, I encourage you to contribute to the  request for feedback for planning its future</p><p> 如果您＆＃39;对rkyv感兴趣，我鼓励您为计划未来的反馈提供贡献 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://davidkoloski.me/blog/rkyv-is-faster-than/">https://davidkoloski.me/blog/rkyv-is-faster-than/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/bincode/">#bincode</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/faster/">#faster</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/序列化/">#序列化</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>