<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>GO类型参数-吃水设计</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">GO类型参数-吃水设计</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-05 20:20:06</div><div class="page_narrow text-break page_content"><p>We suggest extending the Go language to add optional type parameters to type and function declarations. Type parameters are constrained by interface types. Interface types, when used as type constraints, permit listing the set of types that may be assigned to them. Type inference via a unification algorithm permits omitting type arguments from function calls in many cases. The design is fully backward compatible with Go 1.</p><p>我们建议扩展Go语言，在类型和函数声明中添加可选的类型参数。类型参数受接口类型的约束。接口类型用作类型约束时，允许列出可能分配给它们的一组类型。在许多情况下，通过统一算法的类型推断允许从函数调用中省略类型参数。该设计完全向后兼容GO 1。</p><p>   We then explain the full design starting from scratch, introducing the details as we need them, with simple examples.</p><p>然后，我们从零开始解释整个设计，在需要的时候介绍细节，并用简单的例子介绍它们。</p><p> After the design is completely described, we discuss implementation, some issues with the design, and a comparison with other approaches to generics.</p><p>在完整描述了设计之后，我们将讨论实现、设计中的一些问题以及与其他泛型方法的比较。</p><p> We then present several complete examples of how this design would be used in practice.</p><p>然后，我们将提供几个完整的示例，说明如何在实践中使用这种设计。</p><p>  This section explains the changes suggested by the design draft very briefly. This section is intended for people who are already familiar with how generics would work in a language like Go. These concepts will be explained in detail in the following sections.</p><p>本部分非常简要地解释了设计草案建议的更改。本部分面向已经熟悉泛型如何在Go这样的语言中工作的人。以下各节将详细解释这些概念。</p><p> Functions can have an additional type parameter list that uses square brackets but otherwise looks like an ordinary parameter list:  func F[T any](p T) { ... }.</p><p>函数可以有一个使用方括号的附加类型参数列表，但在其他方面看起来像一个普通参数列表：func F[T any](P T){...}。</p><p> These type parameters can be used by the regular parameters and in the function body.</p><p>这些类型参数可以由常规参数使用，也可以在函数体中使用。</p><p>  Each type parameter has a type constraint, just as each ordinary parameter has a type:  func F[T Constraint](p T) { ... }.</p><p>每个类型参数都有一个类型约束，就像每个普通参数都有一个类型一样：func F[T Constraint](P T){...}。</p><p>   Interface types used as type constraints can have a list of predeclared types; only type arguments that match one of those types satisfy the constraint.</p><p>用作类型约束的接口类型可以有一个预声明类型列表；只有与其中一个类型匹配的类型参数才能满足约束。</p><p> In the following sections we work through each of these language changes in great detail. You may prefer to skip ahead to the  examples to see what generic code written to this design draft will look like in practice.</p><p>在接下来的几节中，我们将详细介绍这些语言更改中的每一个。您可能更喜欢跳到示例，看看写到此设计草案中的通用代码在实践中会是什么样子。</p><p>  There have been many  requests to add additional support for generic programming in Go. There has been extensive discussion on  the issue tracker and on  a living document.</p><p>有很多人要求在Go中增加对泛型编程的额外支持。关于问题跟踪器和一份活生生的文件，人们进行了广泛的讨论。</p><p> This design draft suggests extending the Go language to add a form of parametric polymorphism, where the type parameters are bounded not by a declared subtyping relationship (as in some object oriented languages) but by explicitly defined structural constraints.</p><p>这份设计草案建议扩展Go语言以增加一种形式的参数多态性，其中类型参数不是由声明的子类型关系(就像在一些面向对象语言中那样)限定的，而是由明确定义的结构约束限定的。</p><p> This version of the design draft has many similarities to the one presented on July 31, 2019, but contracts have been removed and replaced by interface types, and the syntax has changed.</p><p>这一版本的设计草案与2019年7月31日提交的设计草案有许多相似之处，但合同已被移除，取而代之的是接口类型，语法也发生了变化。</p><p> There have been several proposals for adding type parameters, which can be found through the links above. Many of the ideas presented here have appeared before. The main new features described here are the syntax and the careful examination of interface types as constraints.</p><p>有几个关于添加类型参数的建议，可以通过上面的链接找到这些建议。这里提出的许多想法以前就出现过。这里描述的主要新特性是语法和对作为约束的接口类型的仔细检查。</p><p> This design does not support template metaprogramming or any other form of compile time programming.</p><p>此设计不支持模板元编程或任何其他形式的编译时编程。</p><p> As the term  generic is widely used in the Go community, we will use it below as a shorthand to mean a function or type that takes type parameters. Don&#39;t confuse the term generic as used in this design with the same term in other languages like C++, C#, Java, or Rust; they have similarities but are not the same.</p><p>由于术语泛型在围棋社区中被广泛使用，下面我们将使用它作为一种缩写，表示接受类型参数的函数或类型。不要将本设计中使用的术语泛型与其他语言(如C++、C#、Java或Rust)中的相同术语混淆；它们有相似之处，但又不相同。</p><p>    Generic code is written using abstract data types that we call  type parameters. When running the generic code, the type parameters are replaced by  type arguments.</p><p>泛型代码是使用抽象数据类型编写的，我们称之为类型参数。运行泛型代码时，类型参数将替换为类型参数。</p><p> Here is a function that prints out each element of a slice, where the element type of the slice, here called  T, is unknown. This is a trivial example of the kind of function we want to permit in order to support generic programming. (Later we&#39;ll also discuss  generic types).</p><p>下面是一个打印切片的每个元素的函数，其中切片的元素类型(这里称为T)是未知的。这是我们为了支持泛型编程而想要允许的函数类型的一个很小的例子。(稍后我们还将讨论泛型类型)。</p><p> // Print prints the elements of a slice.// It should be possible to call this with any slice value.func Print(s []T) { // Just an example, not the suggested syntax.	for _, v := range s {		fmt.Println(v)	}}</p><p>//print打印切片的元素。//应该可以使用任何切片值调用它。func print(s[]T){//只是一个示例，不是建议的语法。For_，v：=range s{fmt.Println(V)}}。</p><p> With this approach, the first decision to make is: how should the type parameter  T be declared? In a language like Go, we expect every identifier to be declared in some way.</p><p>使用这种方法，首先要做的决定是：应该如何声明类型参数T？在像Go这样的语言中，我们希望每个标识符都以某种方式声明。</p><p> Here we make a design decision: type parameters are similar to ordinary non-type function parameters, and as such should be listed along with other parameters. However, type parameters are not the same as non-type parameters, so although they appear in the list of parameters we want to distinguish them. That leads to our next design decision: we define an additional optional parameter list describing type parameters.</p><p>这里我们做了一个设计决策：类型参数类似于普通的非类型函数参数，因此应该与其他参数一起列出。但是，类型参数与非类型参数不同，因此尽管它们出现在参数列表中，但我们希望区分它们。这将导致我们的下一个设计决策：我们定义一个描述类型参数的附加可选参数列表。</p><p> This type parameter list appears before the regular parameters. To distinguish the type parameter list from the regular parameter list, the type parameter list uses square brackets rather than parentheses. Just as regular parameters have types, type parameters have meta-types, also known as constraints. We will discuss the details of constraints later; for now, we will just note that  any is a valid constraint, meaning that any type is permitted.</p><p>此类型参数列表显示在常规参数之前。为了区分类型参数列表和常规参数列表，类型参数列表使用方括号而不是圆括号。正如常规参数具有类型一样，类型参数也具有元类型，也称为约束。我们稍后将讨论约束的细节；现在，我们只需注意Any是有效的约束，这意味着允许任何类型。</p><p> // Print prints the elements of any slice.// Print has a type parameter T and has a single (non-type)// parameter s which is a slice of that type parameter.func Print[T any](s []T) {	// same as above}</p><p>//Print打印任何切片的元素。//Print有一个类型参数T，并且只有一个(非类型)参数s，它是该类型参数的切片。func print[T any](s[]T){//同上}。</p><p> This says that within the function  Print the identifier  T is a type parameter, a type that is currently unknown but that will be known when the function is called. The  any means that  T can be any type at all. As seen above, the type parameter may be used as a type when describing the types of the ordinary non-type parameters. It may also be used as a type within the body of the function.</p><p>这说明在函数print中，标识符T是一个类型参数，这是一种当前未知但在调用函数时就会知道的类型。Any表示T可以是任何类型。如上所述，在描述普通非类型参数的类型时，类型参数可以用作类型。它还可以用作函数体中的类型。</p><p> Unlike regular parameter lists, in type parameter lists names are required for the type parameters. This avoids a syntactic ambiguity, and, as it happens, there is no reason to ever omit the type parameter names.</p><p>与常规参数列表不同，在类型参数列表中，类型参数需要名称。这避免了语法歧义，而且碰巧没有理由省略类型参数名称。</p><p> Since  Print has a type parameter, any call of  Print must provide a type argument. Later we will see how this type argument can usually be deduced from the non-type argument, by using  type inference. For now, we&#39;ll pass the type argument explicitly. Type arguments are passed much like type parameters are declared: as a separate list of arguments. As with the type parameter list, the list of type arguments uses square brackets.</p><p>因为print有一个类型参数，所以任何对print的调用都必须提供一个类型参数。稍后我们将看到，通过使用类型推断，通常可以从非类型参数中推导出此类型参数。目前，我们将显式传递类型参数。类型参数的传递方式与类型参数的声明方式非常相似：作为单独的参数列表。与类型参数列表一样，类型参数列表使用方括号。</p><p> // Call Print with a []int.	// Print has a type parameter T, and we want to pass a []int,	// so we pass a type argument of int by writing Print[int].	// The function Print[int] expects a []int as an argument.	Print[int]([]int{1, 2, 3})	// This will print:	// 1	// 2	// 3</p><p>//使用[]int调用print。//print有一个类型参数T，我们希望传递一个[]int，//因此我们通过编写print[int]传递一个int的类型参数。//函数print[int]需要一个[]int作为参数。Print[int]([]int{1，2，3})//这将打印：//1//2//3。</p><p>  Let‘s make our example slightly more complicated. Let’s turn it into a function that converts a slice of any type into a  []string by calling a  String method on each element.</p><p>让我们使我们的示例稍微复杂一些。让我们将其转换为一个函数，通过对每个元素调用一个字符串方法，将任何类型的片段转换为[]字符串。</p><p> // This function is INVALID.func Stringify[T any](s []T) (ret []string) {	for _, v := range s {		ret = append(ret, v.String()) // INVALID	}	return ret}</p><p>//此函数为INVALID.func Stringify[T any](s[]T)(ret[]string){for_，v：=range s{ret=append(ret，v.String())//INVALID}return ret}。</p><p> This might seem OK at first glance, but in this example  v has type  T, and  T can be any type. This means that  T need not have a  String method. So the call to  v.String() is invalid.</p><p>乍一看，这似乎没问题，但在本例中，v的类型是T，T可以是任何类型。这意味着T不需要字符串方法。因此，对v.String()的调用无效。</p><p> Naturally, the same issue arises in other languages that support generic programming. In C++, for example, a generic function (in C++ terms, a function template) can call any method on a value of generic type. That is, in the C++ approach, calling  v.String() is fine. If the function is called with a type argument that does not have a  String method, the error is reported when compiling the call to  v.String with that type argument. These errors can be lengthy, as there may be several layers of generic function calls before the error occurs, all of which must be reported to understand what went wrong.</p><p>当然，同样的问题也会出现在其他支持泛型编程的语言中。例如，在C++中，泛型函数(在C++术语中是函数模板)可以对泛型类型的值调用任何方法。也就是说，在C++方法中，调用v.String()就可以了。如果使用没有字符串方法的类型参数调用函数，则在使用该类型参数编译对v.String的调用时会报告错误。这些错误可能很长，因为在错误发生之前可能有几层泛型函数调用，必须报告所有这些调用才能了解哪里出了问题。</p><p> The C++ approach would be a poor choice for Go. One reason is the style of the language. In Go we don&#39;t refer to names, such as, in this case,  String, and hope that they exist. Go resolves all names to their declarations when they are seen.</p><p>对于围棋来说，C++方法不是一个好的选择。其中一个原因是语言的风格。在Go中，我们不引用名称，例如，在本例中是字符串，并且希望它们存在。当看到所有名称时，Go会将它们解析为其声明。</p><p> Another reason is that Go is designed to support programming at scale. We must consider the case in which the generic function definition ( Stringify, above) and the call to the generic function (not shown, but perhaps in some other package) are far apart. In general, all generic code expects the type arguments to meet certain requirements. We refer to these requirements as  constraints (other languages have similar ideas known as type bounds or trait bounds or concepts). In this case, the constraint is pretty obvious: the type has to have a  String() string method. In other cases it may be much less obvious.</p><p>另一个原因是Go是为支持大规模编程而设计的。我们必须考虑泛型函数定义(如上所述的Stringify)和对泛型函数的调用(未显示，但可能在其他包中)相距甚远的情况。通常，所有泛型代码都希望类型参数满足某些要求。我们将这些要求称为约束(其他语言也有类似的概念，称为类型界限或特征界限或概念)。在本例中，约束非常明显：该类型必须有一个string()字符串方法。在其他情况下，这一点可能不那么明显。</p><p> We don‘t want to derive the constraints from whatever  Stringify happens to do (in this case, call the  String method). If we did, a minor change to  Stringify might change the constraints. That would mean that a minor change could cause code far away, that calls the function, to unexpectedly break. It’s fine for  Stringify to deliberately change its constraints, and force callers to change. What we want to avoid is  Stringify changing its constraints accidentally.</p><p>我们不想从Stringify碰巧做的任何事情中派生约束(在本例中，调用字符串方法)。如果我们这样做了，对Stringify的微小更改可能会改变约束。这意味着微小的更改可能会导致调用该函数的代码意外崩溃。Stringify可以故意更改其约束，并强制调用者更改。我们要避免的是Stringify意外地改变了它的约束。</p><p> This means that the constraints must set limits on both the type arguments passed by the caller and the code in the generic function. The caller may only pass type arguments that satisfy the constraints. The generic function may only use those values in ways that are permitted by the constraints. This is an important rule that we believe should apply to any attempt to define generic programming in Go: generic code can only use operations that its type arguments are known to implement.</p><p>这意味着约束必须对调用方传递的类型参数和泛型函数中的代码设置限制。调用方只能传递满足约束的类型参数。泛型函数只能以约束允许的方式使用这些值。这是一条重要的规则，我们认为应该适用于在Go中定义泛型编程的任何尝试：泛型代码只能使用其类型参数已知要实现的操作。</p><p>  Before we discuss constraints further, let&#39;s briefly note what happens when the constraint is  any. If a generic function uses the  any constraint for a type parameter, as is the case for the  Print method above, then any type argument is permitted for that parameter. The only operations that the generic function can use with values of that type parameter are those operations that are permitted for values of any type. In the example above, the  Print function declares a variable  v whose type is the type parameter  T, and it passes that variable to a function.</p><p>在我们进一步讨论约束之前，让我们简单地注意一下当约束为ANY时会发生什么。如果泛型函数对类型参数使用Any约束(就像上面的print方法一样)，则允许该参数使用任何类型参数。泛型函数可以对该类型参数值使用的唯一操作是允许对任何类型的值执行的操作。在上面的例子中，print函数声明了一个类型为类型参数T的变量v，并将该变量传递给一个函数。</p><p>  define and use composite types that use those types, such as a slice of that type</p><p>定义和使用使用这些类型的复合类型，例如该类型的片段。</p><p> It&#39;s possible that future language changes will add other such operations, though none are currently anticipated.</p><p>未来的语言变化可能会添加其他此类操作，尽管目前预计不会添加任何此类操作。</p><p>  Go already has a construct that is close to what we need for a constraint: an interface type. An interface type is a set of methods. The only values that can be assigned to a variable of interface type are those whose types implement the same methods. The only operations that can be done with a value of interface type, other than operations permitted for any type, are to call the methods.</p><p>Go已经有了一个接近我们约束所需的构造：接口类型。接口类型是一组方法。可以赋给接口类型变量的唯一值是其类型实现相同方法的那些变量。除了允许任何类型的操作之外，可以使用接口类型的值执行的唯一操作是调用方法。</p><p> Calling a generic function with a type argument is similar to assigning to a variable of interface type: the type argument must implement the constraints of the type parameter. Writing a generic function is like using values of interface type: the generic code can only use the operations permitted by the constraint (or operations that are permitted for any type).</p><p>使用类型参数调用泛型函数类似于向接口类型的变量赋值：类型参数必须实现类型参数的约束。编写泛型函数类似于使用接口类型的值：泛型代码只能使用约束允许的操作(或任何类型允许的操作)。</p><p> Therefore, in this design, constraints are simply interface types. Implementing a constraint means implementing the interface type. (Later we&#39;ll see how to define constraints for operations other than method calls, such as  binary operators).</p><p>因此，在此设计中，约束只是接口类型。实现约束意味着实现接口类型。(稍后我们将了解如何为方法调用以外的操作定义约束，例如二元运算符)。</p><p> For the  Stringify example, we need an interface type with a  String method that takes no arguments and returns a value of type  string.</p><p>对于Stringify示例，我们需要一个带有字符串方法的接口类型，该方法不接受任何参数，并返回一个字符串类型的值。</p><p> // Stringer is a type constraint that requires the type argument to have// a String method and permits the generic function to call String.// The String method should return a string representation of the value.type Stringer interface {	String() string}</p><p>//Stringer是一种类型约束，它要求类型参数具有//字符串方法，并允许泛型函数调用字符串。//String方法应返回值的字符串表示形式。type Stringer接口{string()string}。</p><p> (It doesn‘t matter for this discussion, but this defines the same interface as the standard library’s  fmt.Stringer type, and real code would likely simply use  fmt.Stringer.)</p><p>(这与本文的讨论无关，但这定义了与标准库的fmt.Stringer类型相同的接口，真正的代码很可能只使用fmt.Stringer。)。</p><p>  Now that we know that constraints are simply interface types, we can explain what  any means as a constraint. As shown above, the  any constraint permits any type as a type argument and only permits the function to use the operations permitted for any type. The interface type for that is the empty interface:  interface{}. So we could write the  Print example as</p><p>既然我们知道约束只是接口类型，我们就可以解释约束是什么意思了。如上所述，Any约束允许任何类型作为类型参数，并且只允许函数使用任何类型允许的操作。其接口类型为空接口：接口{}。因此，我们可以将打印示例编写为。</p><p> // Print prints the elements of any slice.// Print has a type parameter T and has a single (non-type)// parameter s which is a slice of that type parameter.func Print[T interface{}](s []T) {	// same as above}</p><p>//Print打印任何切片的元素。//Print有一个类型参数T，并且只有一个(非类型)参数s，它是该类型参数的切片。func print[T接口{}](s[]T){//同上}。</p><p> However, it‘s tedious to have to write  interface{} every time you write a generic function that doesn’t impose constraints on its type parameters. So in this design we suggest a type constraint  any that is equivalent to  interface{}. This will be a predeclared name, implicitly declared in the universe block. It will not be valid to use  any as anything other than a type constraint.</p><p>然而，每次编写不对其类型参数施加约束的泛型函数时，都必须编写接口{}，这是很乏味的。因此，在此设计中，我们建议使用与接口{}等效的类型约束Any。这将是一个预先声明的名称，在语义块中隐式声明。除了类型约束之外，将Any用作任何其他类型约束都是无效的。</p><p> (Note: clearly we could make  any generally available as an alias for  interface{}, or as a new defined type defined as  interface{}. However, we don&#39;t want this design draft, which is about generics, to lead to a possibly significant change to non-generic code. Adding  any as a general purpose name for  interface{} can and should be  discussed separately).</p><p>(注意：显然，我们可以将任何类型作为接口{}的别名，或者作为定义为接口{}的新定义类型)。然而，我们不希望这份关于泛型的设计草案导致对非泛型代码的可能重大改变。将Any添加为接口{}的通用名称可以而且应该单独讨论)。</p><p>  For a generic function, a constraint can be thought of as the type of the type argument: a meta-type. As shown above, constraints appear in the type parameter list as the meta-type of a type parameter.</p><p>对于泛型函数，可以将约束视为类型参数的类型：元类型。如上所示，约束在类型参数列表中显示为类型参数的元类型。</p><p> // Stringify calls the String method on each element of s,// and returns the results.func Stringify[T Stringer](s []T) (ret []string) {	for _, v := range s {		ret = append(ret, v.String())	}	return ret}</p><p>//Stringify对s的每个元素调用String方法，//返回结果。func Stringify[T Stringer](s[]T)(ret[]string){for_，v：=range s{ret=append(ret，v.String())}return ret}。</p><p> The single type parameter  T is followed by the constraint that applies to  T, in this case  Stringer.</p><p>单个类型参数T后跟应用于T的约束，在本例中为Stringer。</p><p>  Although the  Stringify example uses only a single type parameter, functions may have multiple type parameters.</p><p>虽然Stringify示例只使用一个类型参数，但函数可以有多个类型参数。</p><p> // Print2 has two type parameters and two non-type parameters.func Print2[T1, T2 any](s1 []T1, s2 []T2) { ... }</p><p>//Print2有两个类型参数和两个非类型参数。func Print2[T1，T2 any](s1[]t1，s2[]t2){...}。</p><p>  // Print2Same has one type parameter and two non-type parameters.func Print2Same[T any](s1 []T, s2 []T) { ... }</p><p>//Print2Same有一个类型参数和两个非类型参数。func Print2Same[T any](S1[]T，S2[]T){...}。</p><p> In  Print2  s1 and  s2 may be slices of different types. In  Print2Same  s1 and  s2 must be slices of the same element type.</p><p>在Print2中，S1和S2可以是不同类型的切片。在Print2Same中，S1和S2必须是相同元素类型的切片。</p><p> Just as each ordinary parameter may have its own type, each type parameter may have its own constraint.</p><p>就像每个普通参数可能有自己的类型一样，每个类型参数也可能有自己的约束。</p><p> // Stringer is a type constraint that requires a String method.// The String method should return a string representation of the value.type Stringer interface {	String() string}// Plusser is a type constraint that requires a Plus method.// The Plus method is expected to add the argument to an internal// string and return the result.type Plusser interface {	Plus(string) string}// ConcatTo takes a slice of elements with a String method and a slice// of elements with a Plus method. The slices should have the same// number of elements. This will convert each element of s to a string,// pass it to the Plus method of the corresponding element of p,// and return a slice of the resulting strings.func ConcatTo[S Stringer, P Plusser](s []S, p []P) []string {	r := make([]string, len(s))	for i, v := range s {		r[i] = p[i].Plus(v.String())	}	return r}</p><p>//Stringer是需要字符串方法的类型约束。//字符串方法应返回值的字符串表示形式。type Stringer接口{String()string}//Plusser是需要Plus方法的类型约束。//Plus方法应将参数添加到内部//字符串并返回结果。type Plusser接口{Plus(字符串)字符串}//ConcatTo使用字符串方法获取元素切片，使用Plus方法获取元素切片//。切片应具有相同//数量的元素。这会将s的每个元素转换为一个字符串，//将其传递给p的相应元素的Plus方法，//并返回一段结果字符串。func ConcatTo[S Stringer，P Plusser](s[]S，p[]P)[]string{r：=make([]string，len(S))for i，v：=range s{r[i]=p[i].plus(v.String())}return r}。</p><p> A single constraint can be used for multiple type parameters, just as a single type can be used for multiple non-type function parameters. The constraint applies to each type parameter separately.</p><p>一个约束可以用于多个类型参数，就像单个类型可以用于多个非类型函数参数一样。该约束分别应用于每个类型参数。</p><p> // Stringify2 converts two slices of different types to strings,// and returns the concatenation of all the strings.func Stringify2[T1, T2 Stringer](s1 []T1, s2 []T2) string {	r := &#34;&#34;	for _, v1 := range s1 {		r += v1.String()	}	for _, v2 := range s2 {		r += v2.String()	}	return r}</p><p>//Stringify2将两个不同类型的分片转换为字符串，//并返回所有字符串的拼接。func Stringify2[t1，t2 Stringer](s1[]t1，s2[]t2)string{r：=&#34；&#34；for_，v1：=range s1{r+=v1.String()}for_，v2：=range s2{r+=v2.String()}return r}。</p><p>  We want more than just generic functions: we also want generic types. We suggest that types be extended to take type parameters.</p><p>我们想要的不仅仅是泛型函数：我们还想要泛型类型。我们建议将类型扩展为接受类型参数。</p><p> // Vector is a name for a slice of any element type.type Vector[T any] []T</p><p>//向量是任何元素类型的切片的名称。类型向量[T任意][]T。</p><p> A type‘s type parameters are just like a function’s type parameters.</p><p>类型的类型参数就像函数的类型参数一样。</p><p>  To use a generic type, you must supply type arguments. This is called  instantiation. The type arguments appear in square brackets, as usual. When we instantiate a type by supplying type arguments for the type parameters, we produce a type in which each use of a type parameter in the type definition is replaced by the corresponding type argument.</p><p>若要使用泛型类型，必须提供类型参数。这称为实例化。和往常一样，类型参数出现在方括号中。当我们通过为类型参数提供类型参数来实例化类型时，我们会生成一个类型，在该类型中，在类型定义中每次使用类型参数都会被相应的类型参数替换。</p><p> // v is a Vector of int values.//// This is similar to pretending that &#34;Vector[int]&#34; is a valid identifier,// and writing// type &#34;Vector[int]&#34; []int// var v &#34;Vector[int]&#34;// All uses of Vector[int] will refer to the same &#34;Vector[int]&#34; type.//var v Vector[int]</p><p>//v是整数值的向量。/这类似于假装&#34；向量[int]&#34；是有效的标识符，//写入//type&#34；向量[int]&#34；[]int//var v&#34；向量[int]&#34；//所有对向量[int]的使用都将引用相同的&#34；向量[int]&#34；类型。//var v向量[int]</p><p> Generic types can have methods. The receiver type of a method must declare the same number of type parameters as are declared in the receiver type&#39;s definition. They are declared without any constraint.</p><p>泛型类型可以有方法。方法的接收方类型必须声明与接收方类型定义中声明的类型参数数量相同的类型参数。它们的声明没有任何约束。</p><p> // Push adds a value to the end of a vector.func (v *Vector[T]) Push(x T) { *v = append(*v, x) }</p><p>//PUSH将值添加到向量的末尾。func(v*Vector[T])Push(X T){*v=append(*v，x)}。</p><p> The type parameters listed in a method declaration need not have the same names as the type parameters in the type declaration. In particular, if they are not used by the method, they can be  _.</p><p>方法声明中列出的类型参数不必与类型声明中的类型参数同名。具体地说，如果方法没有使用它们，则它们可以是_。</p><p> A generic type can refer to itself in cases where a type can ordinarily refer to itself, but when it does so the type arguments must be the type parameters, listed in the same order. This restriction prevents infinite recursion of type instantiation.</p><p>泛型类型可以在通常可以引用其自身的情况下引用自身，但当它这样做时，类型参数必须是按相同顺序列出的类型参数。此限制可防止类型实例化的无限递归。</p><p> // List is a linked list of values of type T.type List[T any] struct {	next *List[T] // this reference to List[T] is OK	val T}// This type is INVALID.type P[T1, T2 any] struct {	F *P[T2, T1] // INVALID; must be [T1, T2]}</p><p>//List是T类型的值的链接列表。type list[T any]struct{Next*List[T]//对list[T]的引用是OK ValT}//此类型为INVALID。type P[T1，T2 any]struct{F*P[T2，T1]//无效；必须为[T1，T2]}。</p><p>  // ListHead is the head of a linked list.type ListHead[T any] struct {	head *ListElement[T]}// ListElement is an element in a linked list with a head.// Each element points back to the head.type ListElement[T any] struct {	next *ListElement[T]	val T	// Using ListHead[T] here is OK.	// ListHead[T] refers to ListElement[T] refers to ListHead[T].	// Using ListHead[int] would not be OK, as ListHead[T]	// would have an indirect reference to ListHead[int].	head *ListHead[T]}</p><p>//ListHead是链接列表的头部。type ListHead[T any]struct{head*ListElement[T]}//ListElement是链表中具有头部的元素。//每个元素都指向头部。键入ListElement[T any]struct{Next*ListElement[T]val T//在此处使用ListHead[T]即可。//ListHead[T]引用ListElement[T]引用ListHead[T]。//使用ListHead[int]不太好，因为ListHead[T]//将间接引用ListHead[int]。Head*ListHead[T]}。</p><p> (Note: with more understanding of how people want to write code, it may be possible to relax this rule to permit some cases that use different type arguments.)</p><p>(注意：随着人们对如何编写代码有了更多的了解，可以放宽这一规则，允许某些情况下使用不同类型的参数。)。</p><p>  // StringableVector is a slice of some type, where the type// must have a String method.type StringableVector[T Stringer] []Tfunc (s StringableVector[T]) String() string {	var sb strings.Builder	for i, v := range s {		if i &gt; 0 {			sb.WriteString(&#34;, &#34;)		}		// It&#39;s OK to call v.String here because v is of type T		// and T&#39;s constraint is Stringer.		sb.WriteString(v.String())	}	return sb.String()}</p><p>//StringableVector是某种类型的切片，其中的类型//必须具有字符串方法。type StringableVector[T Stringer][]Tfunc(s StringableVector[T])string()string{var SB string。i的Builder，v：=range s{if I&gt；0{sb.WriteString(&#34；，&#34；)}//这里可以调用v.String，因为v是T类型。的约束是Stringer。Sb.WriteString(v.String())}返回sb.String()}</p><p>  Although methods of a generic type may use the type&#39;s parameters, methods may not themselves have additional type parameters. Where it would be useful to add type arguments to a method, people will have to write a suitably parameterized top-level function.</p><p>尽管泛型类型的方法可以使用该类型的参数，但方法本身可能没有附加的类型参数。在向方法添加类型参数非常有用的情况下，人们必须编写一个适当参数化的顶级函数。</p><p>   As we‘ve seen, we are using interface types as constraints. Interface types provide a set of methods, and nothing else. This means that with what we’ve seen so far, the only thing that generic functions can do with values of type parameters, other than operations that are permitted for any type, is call methods.</p><p>正如我们已经看到的，我们使用接口类型作为约束。接口类型提供一组方法，其他什么都不提供。这意味着，根据我们到目前为止所看到的，泛型函数唯一可以对类型参数值执行的操作(任何类型都允许执行的操作)就是调用方法。</p><p> However, method calls are not sufficient for everything we want to express. Consider this simple function that returns the smallest element of a slice of values, where the slice is assumed to be non-empty.</p><p>然而，方法调用并不足以满足我们想要表达的所有内容。考虑这个简单的函数，它返回值切片的最小元素，其中假设切片为非空。</p><p> // This function is INVALID.func Smallest[T any](s []T) T {	r := s[0] // panic if slice is empty	for _, v := range s[1:] {		if v &lt; r { // INVALID			r = v		}	}	return r}</p><p>//此函数是INVALID.func Minimest[T any](s[]T)T{r：=s[0]//如果_，v：=range s[1：]{if v&lt；r{//无效r=v}}返回r}。</p><p> Any reasonable generics implementation should let you write this function. The problem is the expression  v &lt; r. This assumes that  T supports the  &lt; operator, but the constraint on  T is simply  any. With the  any constraint the function  Smallest can only use operations that are available for all types, but not all Go types support  &lt;. Unfortunately, since  &lt; is not a method, there is no obvious way to write a constraint—an interface type—that permits  &lt;.</p><p>任何合理的泛型实现都应该允许您编写此函数。问题在于表达式v&lt；r。这假设T支持&lt；运算符，但对T的约束只是ANY。对于ANY约束，最小函数只能使用对所有类型都可用的操作，但并非所有围棋类型都支持&lt；。不幸的是，由于&lt；不是一个方法，因此没有明显的方法来编写允许&lt；的约束(接口类型)。</p><p> We need a way to write a constraint that accepts only types that support  &lt;. In order to do that, we observe that, aside from two exceptions that we will discuss later, all the arithmetic</p><p>我们需要一种方法来编写只接受支持&lt；的类型的约束。为了做到这一点，我们观察到，除了我们将在后面讨论的两个例外之外，所有的算法。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md">https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/参数/">#参数</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033066.html"><img src="http://img2.diglog.com/img/2020/11/thumb_7b874496b8110227f7bd777cbb4a55f2.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033066.html">设计覆盆子PI 400</a></div><span class="my_story_list_date">2020-11-4 6:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033059.html"><img src="http://img2.diglog.com/img/2020/11/thumb_774985449cd0a74aebb044ef0766c3ba.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033059.html">Lyft的两名高管将在加州第22号提案投票前夕离开公司，他们分别负责战略举措和设计</a></div><span class="my_story_list_date">2020-11-4 6:16</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032966.html"><img src="http://img2.diglog.com/img/2020/11/thumb_2dc4f69e661f67af2553fca7aa327f56.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032966.html">将产品设计与人的需求联系起来</a></div><span class="my_story_list_date">2020-11-3 22:16</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032683.html"><img src="http://img2.diglog.com/img/2020/11/thumb_bccae1d48d6c6685ed976e465aeac4fc.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032683.html">颤动网：不良设计的分形</a></div><span class="my_story_list_date">2020-11-2 5:36</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>