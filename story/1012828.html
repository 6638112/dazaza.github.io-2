<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>调试NIX项目中的动态链接错误</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">调试NIX项目中的动态链接错误</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-07-19 11:17:05</div><div class="page_narrow text-break page_content"><p>前几天，在建立一个我是贡献者的科学项目时，伊朗陷入了两个系统库之间令人讨厌的版本冲突。一怒之下，我决定充分了解NIX，以便能够建立一个可重现的、严格控制的本地构建。现在已经完成了，总的来说，我对工具和设置非常满意。我正在使用direnv将我的普通shell与Nix的nix-shell特性紧密集成在一起，在很大程度上感觉一切都是无缝的。看到cmake报告说它发现了过多的二进制文件和库，内容经过散列并整齐地安装在/nix/store下的小行中，这让人非常耳目一新。</p><p>我使用NIX来管理我的开发环境，但不是用来构建项目本身。NIX确保项目依赖项已安装并且可由编译器和链接器发现。构建项目是使用CMake完成的，CMake是为cmake设置的，用于查找nix安装的库。NIX通过用自己的shell脚本包装C编译器并通过环境变量注入库和二进制文件的路径来实现这一点。除了声明您想要的包是buildInput之外，要使cmake正常工作几乎没有什么可做的。我的shell.nix文件的第一个版本如下所示：</p><p>#file shell.nix{pkgs？导入&lt；nixpkgs&gt；{}}：包。MkShell{buildInput=with pkgs；[cmake(callPackage nix/petsc.nix{})Metis hdf5 openmpi(python38.。With Packages(Packages：[Packages.。Numpy]))]]；}。</p><p>使用此设置，我在构建项目时几乎没有遇到什么问题。我必须覆盖默认的PETSc派生，才能使用METIS和OpenMPIsupport进行编译，这并不太难：</p><p>#file nix/petsc.nix{petsc，blas，gfortran，lapack，python，metis，openmpi}：petsc。OverrideAttrs(oldAttrs：rec{nativeBuildInput=[blas gfortran gfortran.。CC.。Lib lapack python openmpi Metis]；preconfigure=&#39；&#39；export fc=&#34；${gfortran}/bin/gfortran&#34；f77=&#34；${gfortran}/bin/gfortran&#34；patchShebangs。ConfigureFlagsArray=($configureFlagsArray&#34；--with-mpi-dir=${openmpi}&#34；&#34；--with-metis=${metis}&#34；&#34；--with-blas-lib=[${blas}/lib/libblas.so，${gfortran。CC.。Lib}/lib/libgfortran.a]&#34；&#34；--with-lapack-lib=[${lapack}/lib/liblapack.so，${gfortran。CC.。Lib}/lib/libgfortran.a]&#34；)&#39；&#39；})。</p><p>此Nix文件返回一个函数，该函数在shell.nix中使用callPackage函数调用。Petsc.overrideAttrs是覆盖使用stdenv.mkDerivation创建的派生属性的一种巧妙方式。构建具有MPI和METIS支持的PETSc太简单了，只需将一组不同的参数传递给配置脚本即可。</p><p>弄清楚怎么做这一切是很有趣的。我主要指的是NIX“药丸”，这是通过NIX工具和语言取得的巨大进步。</p><p>使用这些Nix文件，我可以执行cmake..。&amp；&amp；制作成功。让项目开始运行则是另一回事。最终的二进制文件立即失败，并出现动态加载错误：</p><p>该二进制文件试图从Nix在构建PETSC过程中创建的一个临时目录加载动态库。当然这失败了：当我调用bin/warpxm时，该目录已经被清理干净了。二进制文件应该链接到nix存储中/nix/store下的petsc派生结果，而不是/private/tmp下的文件。在某种程度上，似乎有一个环境变量被错误地设置到了这个intermediatedirectory中。要想弄清楚在哪里，我必须学习更多关于在OSX上链接的知识，这比我预期的要多得多。</p><p>首先，我检查了Nix的编译器包装器插入的编译器和链接器标志。它们通过NIX_CFLAGS_COMPILE和NIX_LDFLAGS传入。当您使用nix-shell和direnv时，派生的所有环境变量都会注入到shell中。这只是一个简单的问题，就是把它们呼应出来：</p><p>这些看起来不错！在这个shell中调用cmake和make应该会拉入正确的库。</p><p>然后我记起这个项目使用pkg-config来查找并将链接库放在一起。坦率地说，我不太理解pkg-config，但我知道在这个项目中，它是从cmake内部调用的。它根据自己的规则搜索库，并在Nix完成设置所有内容的工作后运行。因此，它绕过了我们刚才检查的编译器和linkerflag。</p><p>在设置这个Nix环境之前，我碰巧安装了pkg-config。因此，cmake能够从我的用户路径调用系统pkg-config。也许系统版本的pkg-config不知何故找到了错误的库？实际上，echo$PKG_CONFIG_PATH确认它正在搜索我的$HOME下的一个目录。我认为当我向Nix派生添加依赖项时，可能有一些问题交叉了，一次一个：适当配置pkg-config可能会有所帮助。</p><p>一种普遍的看法是，通过传递--pury标志，可以将nix-shell与用户安装的内容隔离开来。这是不对的。事实上，它保持了用户的整个路径。我已经提交了一张罚单来解决这个问题。然而，在更多地使用nix-shell之后，我相信即使没有对开发环境进行热隔离，它也是一个超级有用的工具。</p><p>我再次参考了关于C项目的Nix wiki页面，其中也有关于使用pkg-config的内容。将pkg-config派生作为nativeBuildInput包含似乎会让petsc这样的包将它们的iroutput路径附加到PKG_CONFIG_PATH环境变量。我这样做了：</p><p>一包。MkShell{buildInput=with pkgs；[...]；nativeBuildInput=with pkgs；[pkg-config]；}</p><p>但这并没有解决问题。我将不得不更深入地追查坏库是在哪里被拉进来的。</p><p>深入研究cmake文档和项目的.cmake文件后，我插入了三条打印语句：</p><p>FIND_PACKAGE(需要PkgConfig)pkg_CHECK_MODULES(PETSC PETSC REQUIRED)link_directories(${PETSC_LIBRARY_DIRS})+MESSAGE(&#34；PETSC库：${PETSC_LIBRARY}&#34；)+MESSAGE(&#34；PETS库目录：${PETSC_LIBRARY_DIRS}&#34；)+MESSAGE(&#34；PETSC链接库：${PETSC_LINK_LIBRARS}&#34；)列表(追加WARPXM_LINK。</p><p>第二个看起来不错。但是第一个，仅仅是库的名字petsc，为了舒适，有点太含蓄了。正是这个变量被附加到链接目标列表中。在编译时，将由链接器来查找库petsc，而我不确定它会显示在哪里。使用.dylib的绝对路径更安全，如下所示：</p><p>我在这里的想法是错误的。我们可以确定链接器将在编译时查看的位置：在NIX_LDFLAGS中列出的路径中！我没有清楚地考虑到编译过程中的数据流。</p><p>将链接目标更改为绝对路径仅在下一次cmake期间缓解了我的疑虑。&amp；&amp；生成循环。当然，链接器现在不可能搞砸了。不涉及神秘的图书馆搜索，只有一条绝对路径，这不可能被误解…。</p><p>在这一点上，我完全被搞糊涂了。每次尝试修复时，igrep都会徒劳地在build目录中查找有问题的/private/tmp路径，然后空手而归。我跟踪了传递给编译器的最终的、不可撤销的链接选项，这些选项隐藏在构建树中的link.txt文件中。它们无可争议地表明我的二进制文件链接到了正确的库：</p><p>我几乎令我满意地证明，CMake用这个库做了正确的事情，我完全失去了想法。最后，一个非常幸运的谷歌搜索将我带到了NIX手册中描述达尔文(MacOS)平台特定问题的部分。它声明：</p><p>在Darwin上，库使用绝对路径进行链接，库在链接时通过其安装名称进行解析。有时，包不能正确设置这一点，导致库查找在运行时失败。这可以通过添加额外的链接器标志或在修复阶段运行install_name_tool-id来修复。</p><p>这是一种非常实事求是的表达方式，当我理解它时，它让我大吃一惊。据我所知，以下是MacOS上发生的事情：</p><p>我的源代码有一个include指令，include&lt；petsc.h&gt；或类似的指令，它创建一个由链接器满足的二进制接口。</p><p>在链接时，我们将绝对路径列表传递给库，链接器查找与接口匹配的路径。</p><p>然后，链接器保存它在二进制文件的加载部分中找到的库的install_name。</p><p>在运行时，二进制文件(实际上是MacOS DYLD系统)加载库。</p><p>我肯定在这件事上有些地方弄错了，所以如果能听到比我更了解这件事的人的意见，我会非常感激的！</p><p>无论如何，这个发现让我想到了install_name的概念，所以我有了一些东西可以继续。更多的搜索导致了一篇有用的博客文章，准确地描述了我面临的问题。还介绍了如何检查库的INSTALL_NAME：</p><p>NIX手册指出“有些软件包无法正确设置”，并指向修复程序，即使用install_name_tool更改已构建库的install_name。Nixpkgs上的PETSC派生是否正确执行此操作？我看到它正在使用install_name_tool执行某些操作：</p><p>PrePatch=&#39；&#39；substituteInPlace配置\--替换/bin/sh/usr/bin/python&#39；&#39；+stdenv。利布。OptionalString stdenv.。IsDarwin；替换InPlace配置/install.py\--替换/usr/bin/install_name_tool install_name_tool&#39；&#39；；</p><p>此指令仅用install_name_tool替换字符串/usr/bin/install_name_tool的外观。Nix包这样做的原因是为了确保构建依赖于Nix构建的工具，这些工具在构建shell的路径中提供，而不是依赖于系统目录(如/usr/bin)中的二进制文件。</p><p>引入此替换的PR表明它修复了Darwin上的构建，因此在PETSc中必须调用/usr/bin/install_name_tool。在PETSCrepo中搜索它会导致下面这一行，该行执行的正是Mark日志在install_name上发布的指令：它使用install_name_tool-id将install_name更改为库在其安装目录中的绝对路径。</p><p>如果是os的话。小径。Splitext(Dst)[1]=.dylib；和os。小径。Isfile(&#39；/usr/bin/install_name_tool&#39；)：[output，err，flg]=self。EcuteShellCommand(&#34；otool-D&#34；+src)oldname=output[Output.。查找(&#34；\n&#34；)+1：]installName=oldname。替换(操作系统。小径。Realpath(自我。ArchDir)，赛尔夫。InstallDir)Self。EcuteShellCommand(&#39；/usr/bin/install_name_tool-id&#39；+installName+&#39；&#39；&#39；+dst)。</p><p>根据这一点，在构建库时，库的install_name应该已经由PETSc修复了！除…外。注意到什么了吗？IF语句中的第二个条件。在PETSc派生运行其prePatchstep之后，该条件将变为和os.path.isfile(&#39；install_name_tool&#39；)。这肯定会失败：install_name_tool不会是运行configure的目录中的一个文件！打补丁的配置脚本将静默跳过此步骤，将库的INSTALL_NAME保留为构建它的TEMPORARY目录！</p><p>幸运的是，这个问题的解决方案并不太难。我们应该将绝对路径传递给我们想要运行的程序，而不是路径上的程序名。这可以通过覆盖PrePatch步骤来完成，如下所示：</p><p>PrePatch=&#39；&#39；substituteInPlace配置\--替换/bin/sh/usr/bin/python&#39；&#39；+stdenv。利布。OptionalString stdenv.。IsDarwin&#39；&#39；substituteInPlace config/install.py\--替换/usr/bin/install_name_tool${Darwin。Cctools}/bin/install_name_tool&#39；&#39；；</p><p>NIX变量${darwin.cctools}将展开到构建的darwin.cctools派生的完整路径，即/nix/store下的目录。因此，PETSc的configure.py内的打补丁的if语句变为。</p><p>并且结果库的INSTALL_NAME将是正确的。我们可以使用otool-D再次检查：</p><p>看起来好多了！由于错误位于动态加载的库中，我们甚至不需要重新编译就可以检查它是否正常工作：</p><p>主构建GIT：(➜)Build dyld_✗_library=1 bin/warpxmdyld：已加载：/Users/jack/src/warpxm/build/bin/warpxmdyld：已加载：/nix/store/z4f1bq363m0ydmbyncfi2srij8vlsx32-Libsystem-osx-10.12.6/lib/libSystem.B.dylibdyld：已加载：/。Nix/store/w23r8kplmfx2xc111cpvmdjwmkwy6ip3-petsc-3.13.2/lib/libpetsc.3.13.dylib...。</p><p>我花了大部分时间调试这个问题，而没有对不同的构建阶段有所了解。我应该很清楚，cmake和pkg-config设置都不可能是原因，因为在我调用cmake时，有问题的/private/tmp目录早就消失了。如果我只关注NIX提供的PETScDeriation，我可能会更早地关注install_name_toolpatch。在这过程中，我很幸运地在Nix手册中找到了关于达尔文特有的链接器问题的注释。</p><p>至于Nix，我绝对会更多地使用它。值得注意的是，它能产生的影响是如此之小。我可以使用它来管理这个项目的环境，而不会影响其他开发人员管理他们环境的方式。当然，如果他们问起，我会建议他们试试Nix，但每个人都能在自己的时间做这件事是很好的。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.johnbcoughlin.com/posts/nix-dynamic-linking/">https://www.johnbcoughlin.com/posts/nix-dynamic-linking/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/nix/">#nix</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/dynamic/">#dynamic</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>