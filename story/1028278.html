<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>C++中按返回类型重载</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">C++中按返回类型重载</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-12 21:43:22</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/112e8ad687703295c4a6e412456388da.jpg"><img src="http://img2.diglog.com/img/2020/10/112e8ad687703295c4a6e412456388da.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>//这是OK std：：string to_string(Int I)；std：：string to_string(Bool B)；std：：string si=to_string(0)；std：：string sb=to_string(True)；//这不是OK int from_string(std：：string_view s)；bool from_string(std：：string_view s)；int i=from_string(&#34；7&#34；)；bool b=from_string(&#34；false&#34；)；</p><p>按参数类型重载是许多命令性语言的一个非常简单的功能。然而，它们中的大多数都不支持按返回类型重载。尤其是C++不支持。例如，clang抱怨：</p><p>&lt；source&gt；：4：6：错误：不能重载仅返回类型不同的函数bool from_string(std：：string_view s)；~^&lt；source&gt；：3：5：注意：此处为上一个声明int from_string(std：：string_view s)；~~^。</p><p>所以…。如果我告诉你，在C++中，我们实际上可以通过返回类型来重载，会怎么样？</p><p>转换运算符可以在C++中由用户定义。它们允许我们将自定义的隐式或显式转换添加到我们的类型中。这些转换本身也可以重载，这将我们引向一个简单的原型：</p><p>Struct to_string_t{std：：string_view s；运算符int()const；//int from_string(std：：string_view s)；运算符bool()const；//bool from_string(std：：string_view s)；}；int i=to_string_t{&#34；7&#34；}；bool b=to_string_t{&#34；true&#34；}；</p><p>查看Godbolt，这将编译并调用所需的转换运算符。这里需要注意的重要一点是，编译器需要知道转换的目标类型。因此，auto i=to_string_t{&#34；7&#34；}；不能按预期工作。我的类型是to_string_t，而不是int。</p><p>虽然我们可以使用转换运算符技术在许多情况下通过返回类型实现重载，但它并不总是适用的。如前所述，编译器需要知道目标类型才能选择正确的转换运算符，除非强制执行，否则不会进行转换。我们已经看到了最简单的不应用转换的情况：</p><p>错误：对&#39；bar&#39；的调用是不明确的bar(from_string(&#34；true&#34；))；^~~&lt；source&gt；：41：6：注意：候选函数void bar(Int)；^&lt；source&gt；：42：6：注意：候选函数void bar(Bool)；^。</p><p>类似地，这意味着std：：cout&lt；&lt；from_string(&#34；2&#34；)&lt；&lt；std：：Endl；不起作用。(这方面的错误消息有点可怕，因为我们至少有16个候选重载。)。</p><p>最后，只能隐式应用一个用户定义的转换，因此以下内容不起作用：</p><p>&lt；source&gt；：22：5：错误：调用&#39；test_bar&#39；test_bar(from_string(&#34；3&#34；))；^~&lt；source&gt；：18：6：候选函数无效：对于1s t参数void test_bar(Bar B)，没有已知的从&#39；to_string_t&#39；到&#39；bar&#39；的转换；^~&lt；源&gt；：22：5：错误：没有匹配的函数调用&#39；test_bar&#39；test_bar(from_string(&#34；3&#34；))；^。</p><p>所有这些情况都可以通过向所需类型显式添加强制转换来解决，例如int(TO_STRING(&#34；10&#34；))。</p><p>C++中普通函数重载的一个重要方面是重载集的可扩展性。独立的作者和库只需在相同的命名空间中提供具有正确名称的函数，就可以添加到同一重载集中。我们也可以通过参数相关查找来添加到重载集中，尽管这是否应该被视为功能或错误稍有争议。</p><p>在其基本形式中，我们的转换运算符方法是不可扩展的。用户定义的转换函数必须是成员函数，并且我们不能在调用后将成员添加到其他类。因此，如果我们的库定义了。</p><p>Struct to_string_t{std：：string_view s；运算符int()const；//int from_string(std：：string_view s)；运算符bool()const；//bool from_string(std：：string_view s)；}；</p><p>那么这意味着“返回类型int和bool的重载”，其他库/文件不能添加到此。</p><p>有一种方法可以解决这个问题并增加可扩展性。这会增加一些实现复杂性，对于更专业的用例，实际上可能并不需要可扩展性。但是，我认为from_string在设计时应该考虑可扩展性。</p><p>注意：本节的其余部分更多地关注元编程和API设计，而不是返回类型重载。您可以跳到下一节查看最终版本。</p><p>这里的解决方案是转换函数可以模板化。我们将使用它将转换委托给模板专门化，然后模板专门化可以适当地扩展：</p><p>模板&lt；class T&gt；struct to_string_impl{static_assert(Always_false&lt；T&gt；，&#34；转换为T不受支持&#34；)；}；struct to_string_t{std：：string_view s；template&lt；class T&gt；Operator T()const{return to_string_impl&lt；T&gt；：from_string(S)；}}；To_string_t from_string(std：：string_view s){return to_string_t{s}；}。</p><p>To_string_t中的转换现在已模板化，并始终调用to_string_impl&lt；T&gt；：：from_string(S)。TO_STRING_IMPL&lt；T&gt；是专用于所有支持的转换的类模板。如果调用不支持的转换，Always_False&lt；T&gt；会生成一条漂亮的(-ish)错误消息。我们现在可以通过以下方式添加支持的转换：</p><p>同样，其他作者或最终用户也可以为自定义类型添加转换。有时，有条件地添加转换很有用。例如，只有当T本身支持from_string时，才可能支持my_range&lt；T&gt；。因此，习惯上向基本模板添加第二个模板参数：</p><p>部分专门化只有在T本身满足HAS_FROM_STRING&lt；T&gt；时才是“活动的”(当然，这是SFINAE的一个例子)。</p><p>模板&lt；class T&gt；auto impl_has_from_string(Int)-&gt；decltype(to_string_impl&lt；T&gt；：：from_string(std：：decval&lt；std：：string_view&gt；())，std：：true_type{})；template&lt；class T&gt；std：：false_type impl_has_from_string(Char)；template&lt；class T&gt；常量表达式bool has_from_string=dectype(impl_has_from_string&lt；T&gt；(0))：：value；</p><p>这里，如果TO_STRING_IMPL&lt；T&gt；：：FROM_STRING不存在，我们使用表达式SFINAE禁用第一个IMPL_HAS_FROM_STRING重载。Impl_has_from_string本身在int和char上被重载，并通过impl_has_from_string&lt；T&gt；(0)调用。这是一种“先尝试int重载，如果不适用，则接受char重载”的廉价方式。但是，如果我们尝试检查没有from_string的某些类型的has_from_string&lt；T&gt；，则会触发static_assert(Always_false&lt；T&gt；)；，但是，如果我们尝试检查没有from_string的某些类型的has_from_string&lt；T&gt；，则会触发static_assert(Always_false&lt；T&gt；)；因此，在基本模板中，我们将static_assert移动到to_string_t：：Operator T()(请参见下一节)。</p><p>请注意，模板化的TO_STRING_IMPL类不是唯一的选项。我们还可以使用标记分派甚至正常重载，例如，通过将第二个参数重载的(用户可扩展的)void Convert_To(std：：string_view s，T&amp；v)委托给它。</p><p>//基模板，专门化并提供静态from_string方法模板&lt；class=void&gt；struct to_string_impl{}；Namespace Detail//隐藏Impl Detail{template&lt；class T&gt；auto has_from_string(Int)-&gt；dectype(to_string_impl&lt；T&gt；：：from_string(std：：decval&lt；std：：string_view&gt；()，std：：true_type{})；template&lt；类T&gt；std：：false_type has_from_string(Char)；}//检查T是否有from_string模板&lt；class T&gt；constexpr bool has_from_string=dectype(Detail：：has_from_string&lt；T&gt；(0))：：value；//返回类型重载机制struct to_string_t{std：：string_view s；template&lt；class T&gt；运算符T()const{static_assert(has_from_string&lt；T&gt；，&#34；转换为T不受支持&#34；)；return to_string_impl&lt；T&gt；：：from_string(S)；}}；//提供&#34；return-type重载函数&#34；to_string_t from_string(std：：string_view s){return to_string_t{s}；}的便利包装。</p><p>模板&lt；&gt；struct to_string_impl&lt；int&gt；{static int from_string(std：：string_view s)；}；template&lt；&gt；struct to_string_impl&lt；bool&gt；{static bool from_string(std：：string_view s)；}；模板&lt；class T&gt；struct my_range{/*...*/}；模板&lt；class T&gt；Struct to_string_impl&lt；my_range&lt；T&gt；，std：：enable_if_t&lt；has_from_string&lt；T&gt；&gt；{static my_range&lt；t&gt；from_string(std：：string_view s)；}；</p><p>HAS_FROM_STRING&lt；T&gt；可用于(在编译时)测试FROM_STRING是否可用于特定类型：</p><p>按参数类型重载在现代命令式语言中普遍存在，但通常不支持按返回类型重载。但是，我们可以使用用户定义的转换操作符(Mis)在C++中进行模拟。只要目标类型已知，就会选择适当的“重载”。基本版本很简单：</p><p>Struct to_string_t{std：：string_view s；运算符int()const；//int from_string(std：：string_view s)；运算符bool()const；//bool from_string(std：：string_view s)；}；to_string_t from_string(std：：string_view s){return to_string_t{s}；}</p><p>默认情况下，此解决方案不具有正常按参数类型重载的可扩展性。但是，我们可以通过委托给可以专门化的模板化类的模板化转换运算符来恢复它。在此过程中，我们还可以定义一个HAS_FROM_STRING&lt；T&gt；来帮助诊断或SFINAE。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://artificial-mind.net/blog/2020/10/10/return-type-overloading">https://artificial-mind.net/blog/2020/10/10/return-type-overloading</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/return/">#return</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/string/">#string</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1026301.html"><img src="http://img2.diglog.com/img/2020/9/thumb_b44f367f1c0bf1d078c296cfd99b71e9.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1026301.html">C++重写Apache Spark可获得高达20倍的性能</a></div><span class="my_story_list_date">2020-9-25 5:31</span></div><div class="col-sm"><div><a target="_blank" href="/story/1026087.html"><img src="http://img2.diglog.com/img/2020/9/thumb_c72a4bdf84c77ccc3eff0558d5edc17a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1026087.html">在C++中整数溢出陷阱的开销有多大？</a></div><span class="my_story_list_date">2020-9-24 14:18</span></div><div class="col-sm"><div><a target="_blank" href="/story/1025018.html"><img src="http://img2.diglog.com/img/2020/9/thumb_4351d4b97da56db56c41a8c24bf61ba7.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1025018.html">Libcu++：NVIDIA C++标准库</a></div><span class="my_story_list_date">2020-9-19 18:4</span></div><div class="col-sm"><div><a target="_blank" href="/story/1023576.html"><img src="http://img2.diglog.com/img/2020/9/thumb_1f94c54761d806d119769fa17b118592.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1023576.html">C++即将获得一个巨大的更新</a></div><span class="my_story_list_date">2020-9-12 23:53</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>