<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>TL；DR–混合公钥加密TL;DR – Hybrid Public Key Encryption</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">TL;DR – Hybrid Public Key Encryption<br/>TL；DR–混合公钥加密</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-03-01 22:20:06</div><div class="page_narrow text-break page_content"><p>HPKE is a  CFRG in  RFC 9180 that describes a scheme for hybrid public key encryption.It is co-authored by my  Cryspen co-founder  Karthikeyan Bhargavan and one ofhis PhD students  Benjamin Lipp as part of his research at  Inria.</p><p>HPKE是RFC 9180中描述混合公钥加密方案的CFRG。这本书是由我的Cryspen联合创始人Karthikeyan Bhargavan和他的一名博士生Benjamin Lipp合著的，作为他在Inria研究的一部分。</p><p> This blog post will give a brief overview of the specification and describes some use cases.</p><p>这篇博客文章将简要概述该规范，并描述一些用例。</p><p> If you want to learn more about the security proofs behind HPKE and the RFC process,Benjamin wrote an  excellent blog post about it.</p><p>如果你想了解更多关于HPKE和RFC过程背后的安全证明，Benjamin写了一篇关于它的优秀博客文章。</p><p> Hybrid Public Key Encryption, or short HPKE, is a cyrptographic mechanism thatallows encrypting payload to a public key.It is called “hybrid” because the payload is encrypted with a symmetric scheme.The symmetric key is then encrypted to the receivers public key.The  HPKE standard defines a number of natural extensions to the basic settingthat allow the sender to authenticate themselves.</p><p>混合公钥加密（Hybrid Public Key Encryption，简称HPKE）是一种cyrptographic机制，允许将有效负载加密为公钥。它被称为“混合”，因为有效载荷是用对称方案加密的。然后将对称密钥加密为接收方公钥。HPKE标准定义了一些基本设置的自然扩展，允许发送方对自己进行身份验证。</p><p>  Hybrid public key encryption has been used in different ways since the early 1990s in protocols such as  PGP or  SMIME.While these two protocols are for a very specific use case a more general version of hybrid encryption is described in  ECIES. ECIES is part of many systems nowadays. Storing keys in the secure enclave on an iOS device for example uses  ECIES.For a deeper explanation and history of hybrid crypto systems I recommend reading Christopher Wood’s blog post.</p><p>自20世纪90年代初以来，在PGP或SMIME等协议中以不同的方式使用了混合公钥加密。虽然这两个协议适用于非常特定的用例，但ECIES中描述了更通用的混合加密版本。ECIES是当今许多系统的一部分。例如，在iOS设备上的安全enclave中存储密钥使用ECIES。对于混合密码系统的更深入的解释和历史，我建议阅读克里斯托弗·伍德的博客文章。</p><p> However, there’s no general description of hybrid public key encryption with modern primitives.The  HPKE standard solves this issue.Even before the RFC is finalised it is used in specifications for  ECH,  MLS,  ODOH, and  PPM.This shows the high demand for  HPKE.</p><p>然而，没有关于混合公钥加密和现代原语的一般描述。HPKE标准解决了这个问题。甚至在RFC最终确定之前，它就被用于ECH、MLS、ODOH和PPM的规范中。这表明对HPKE的需求很高。</p><p> HPKE has four distinct modes of operation: Base, Auth, PSK, AuthPSK.In this blog post we only describe the two most commonly used modes Base and Auth.</p><p>HPKE有四种不同的操作模式：Base、Auth、PSK、AuthPSK。在这篇博文中，我们只描述了两种最常用的模式Base和Auth。</p><p>  The  Base mode is the most common use case for HPKE where payload is encryptedto a public key.All other modes are authenticated in different ways.</p><p>基本模式是HPKE最常见的用例，其中有效负载被加密为公钥。所有其他模式都以不同的方式进行身份验证。</p><p> AuthPSK uses the sender’s private key as well as a pre-shared, high-entropy, key for authentication</p><p>AuthPSK使用发送方的私钥以及预共享的高熵密钥进行身份验证</p><p>  The following figure depicts the general flow of encrypting to a public key.This is the Base mode in HPKE.This is the most basic application of hybrid crypto systems.Alex knows the public key from Sasha and wants to send some  Data to them.Shasha’s public key is used to encrypt a shared secret, which is used to encryptthe  Data.The encrypted shared secret as well as the encrypted data is sent to Sasha, whocan retrieve the shared secret with their corresponding private key.</p><p>下图描述了加密到公钥的一般流程。这是HPKE中的基本模式。这是混合密码系统最基本的应用。Alex从Sasha那里知道公钥，想向他们发送一些数据。Shasha的公钥用于加密用于加密数据的共享密钥。加密的共享密钥以及加密的数据被发送给Sasha，Sasha可以用相应的私钥检索共享密钥。</p><p>   Sometimes it is useful or necessary to authenticate the sender of the data.This is depicted in the figure below and represents the HPKE Auth mode.The authentication is achieved by mixing in the sender’s private key such thatthe receiver will only retrieve the correct shared secret if the public keythey use for the sender corresponds to the used private key.</p><p>有时，对数据的发送者进行身份验证是有用的或必要的。如下图所示，它代表HPKE Auth模式。身份验证是通过混合发送方的私钥来实现的，这样接收方只有在他们为发送方使用的公钥与使用的私钥对应时才会检索到正确的共享密钥。</p><p>   HPKE is essentially standardising how to use  Key Encapsulation Mechanisms (KEM)for hybrid encryption.The sender in  HPKE uses a KEM to generate the shared secret as well as theencapsulation.The shared secret is then used in an  AEAD (after running it through a key schedule)in order to encrypt a payload.</p><p>HPKE本质上是标准化如何使用密钥封装机制（KEM）进行混合加密。HPKE中的发送方使用KEM生成共享密钥和封装。然后在AEAD中使用共享秘密（在通过密钥调度运行它之后），以加密有效负载。</p><p> All HPKE use cases so far only take advantage of the single-shot APIs from HPKE.In order to encrypt a payload to a public key the sender needs to provide thereceiver’s public key  pkR, some information  info and additional data  aad to bind the encryptionto a certain context, as well as the payload  pt.HPKE returns the cipher text  ct as well as the encapsulation  enc that are both sent tothe receiver.</p><p>到目前为止，所有HPKE用例都只利用HPKE的单次API。为了将有效载荷加密为公钥，发送方需要提供接收方的公钥pkR、一些信息信息和附加数据，以将加密绑定到特定上下文，以及有效载荷pt。HPKE返回发送给接收器的密文ct和封装enc。</p><p>  When using the Auth mode the sender’s private key  sk is needed in addition.</p><p>使用身份验证模式时，还需要发送方的私钥sk。</p><p> The receiver takes the encapsulation  enc and cipher text  ct together with theirprivate key to retrieve the payload.</p><p>接收器将封装enc和密文ct与其私钥一起获取有效载荷。</p><p>  When using the Auth mode the sender’s public key  pkS is needed in addition.</p><p>使用身份验证模式时，还需要发送方的公钥pkS。</p><p>  HPKE allows multiple encryptions with the same shared secret.This is favourable if multiple messages are sent from the sender to the receiver.To this end HPKE generates a context that allows encrypting (and decrypting) multiplemessages.</p><p>HPKE允许使用同一共享密钥进行多次加密。如果从发送方向接收方发送多条消息，这是有利的。为此，HPKE生成一个允许加密（和解密）多条消息的上下文。</p><p>  Note that HPKE goes a step further than the  AEAD RFC and simplifies the API.The consumer only needs to provide the payload and (potentially empty) additionaldata.HPKE takes care of providing unique nonces to the AEAD and fails if the maximumnumber of encryptions with the context have been performed — in particular ifthe nonce would overflow.</p><p>请注意，HPKE比AEAD RFC更进一步，简化了API。消费者只需要提供有效负载和（可能是空的）附加数据。HPKE负责向AEAD提供唯一的nonce，如果对上下文执行了最大数量的加密，则会失败，尤其是如果nonce会溢出。</p><p>   In some scenarios applications need to establish additional shared secrets.This can be achieved with the HPKE exporter interface.The API is similar to the  Seal and  Open functions above but don’t requirea payload or additional data.Instead an  exporter_context and the length of the exported secret  L have tobe provided.</p><p>在某些情况下，应用程序需要建立额外的共享机密。这可以通过HPKE导出器接口实现。API与上述密封和开启功能类似，但不需要有效载荷或额外数据。相反，我必须提供导出者的上下文和导出秘密的长度。</p><p>   Instead of inventing new use cases for HPKE we describe how HPKE is used in  MLSand  ECH as they reflect common uses of hybrid public key encryption.</p><p>我们没有为HPKE发明新的用例，而是描述了HPKE如何在MLS和ECH中使用，因为它们反映了混合公钥加密的常见用途。</p><p>  MLS (Message Layer Security) is an IETF draft that standardises a new way of efficiently encrypting messagesbetween participants in groups.It aims to solve the problem of end-to-end encryption in instant messaging. HPKE is a core building block.In order to encrypt a message to a specific entity in the protocol,  MLS uses  HPKEto encrypt the message to the specific public key.</p><p>MLS（Message Layer Security）是IETF的一份草案，它标准化了一种新的有效加密分组参与者之间消息的方法。它旨在解决即时通讯中的端到端加密问题。HPKE是一个核心构建块。为了将消息加密到协议中的特定实体，MLS使用HPKET将消息加密到特定公钥。</p><p>  ECH (Encrypted Client Hello) is a mechanism in  TLS (Transport Layer Security)for encrypting a ClientHello message under a server public key.This description from the  ECH draft corresponds directly to the Base mode of  HPKEas described above.This allows  TLS connections to become more private because they don’t leakinformation about the connection, in particular the exact server the client wantsto connect to.</p><p>ECH（Encrypted Client Hello）是TLS（传输层安全）中的一种机制，用于在服务器公钥下加密ClientHello消息。ECH草案中的描述与上述HPKEA的基本模式直接对应。这使得TLS连接变得更私密，因为它们不会泄露有关连接的信息，尤其是客户端希望连接到的确切服务器。</p><p>  In order to better understand the message flow and working of HPKE we put togetheran interactive demo below to demonstrate how HPKE works.</p><p>为了更好地理解HPKE的信息流和工作原理，我们在下面放了一个交互式演示来演示HPKE是如何工作的。</p><p>  The sender retrieves the public key from the receiver that has been generated in the first step.</p><p>发送方从接收方检索在第一步中生成的公钥。</p><p> The sender uses HPKE to encrypt the payload together with the info and additional data to the receiver’s public key.</p><p>发送方使用HPKE加密有效载荷以及接收方公钥中的信息和附加数据。</p><p> When clicking “HPKE Open” the receiver uses the private key to retrieve the shared secret and decrypt the ciphertext.The “Info” and “Additional Data” are the same as entered on the sender’s side.</p><p>单击“HPKE Open”时，接收方使用私钥检索共享密钥并解密密文。“信息”和“附加数据”与发送方输入的信息相同。</p><p>  The demo is written in  hacspec (a subset of Rust) with a  WASM frontend.Please stay tuned for a follow-up blog post diving into the details of this implementation.</p><p>该演示是用hacspec（Rust的子集）编写的，带有WASM前端。请继续关注后续的博客文章，深入了解这个实现的细节。</p><p>  HPKE is a simple, but very powerful new tool that allows to efficiently solvekey distribution problems (see the MLS use case) as well as increase privacyin existing protocols (see the ECH use case).</p><p>HPKE是一个简单但功能强大的新工具，可以有效地解决密钥分发问题（参见MLS用例），并增加现有协议的隐私（参见ECH用例）。</p><p> My company  Cryspen offers support for using  HPKE as well as high assurance implementationsof HPKE and other protocols. Get in touch for more information.</p><p>我的公司Cryspen为使用HPKE以及HPKE和其他协议的高保证实现提供支持。联系以获取更多信息。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/混合/">#混合</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hybrid/">#hybrid</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hpke/">#hpke</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>