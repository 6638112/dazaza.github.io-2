<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>totally_safe_transmute，逐行 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">totally_safe_transmute，逐行 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-17 05:07:59</div><div class="page_narrow text-break page_content"><p>这些文件链接（由Benjamin Herr编写）在推文的声音中实现厌恶生锈的std :: mem :: mem :: transfultwithout的任何使用不安全。如果你经营它，你会发现它确实有效！</p><p> ＃[test] fn main（）{设v：vec＆lt; U8＆gt; = B＆＃34; foo＆＃34; .to_vec（）;设v：string = totally_safe_transmute（v）; assert_eq！ （＆amp; v，＆＃34; foo＆＃34;）; }</p><p>  $ git clone https://github.com/ben0x539/totaly- safe-transmute $ cargo build $ cargo测试编译完全安全 - 传输v0.0.3（/ tmp /完全安全传输）完成测试[未通过+ debuginfo] Target（s）在0.49s运行目标/ debug / deps / totally_safe_transmute-be2ea6d9a3f8d258 running 1 testtest main ...确定测试结果：好的。 1通过; 0失败; 0忽略了; 0测量; 0过滤出来;完成在0.00s Doc-Tests完全安全 - 透射术0测试结果：OK。 0通过; 0失败; 0忽略了; 0测量; 0过滤出来;完成0.00秒</p><p> 此博客文章将通过该实施，逐行，并解释它的工作原理。没有什么特别复杂的;我刚刚出现了一个巨大的东西，想知道我会提供详细的解释。 Rust Newcomearsare预期的受众。</p><p>  大多数不安全的语言都有用于在某些内存地址处传输（或重新诠释）数据的机制，作为全新类型。 C在其铸造语法下包括诠释; C ++提供了更明显的重新诠释器＆lt; t＆gt;（当reinterpret_cast熟悉时，有很多警告发布）。</p><p>  C样式“通用”API通常会产生VOID *的形式产生的结果，呼叫者预计将Void *施放到合适的类型.Callers负责确保目的地类型与类型相同或兼容最初是施加到空白*。</p><p>  C和C ++回调模式经常提供void *参数，允许用户在回调之间提供其他数据或上下文。然后，每个呼叫负责铸造到适当的类型。 </p><p>指针值偶尔需要1通过ANINTEGLAL类型循环。 C ++专门允许这一点，只要目的地积分型至少具有足够的宽度来表示所有可能的指针值。</p><p>  多态性：Berkeley套接字Apispecifies Connect（2）接受结构SockAdd *，它实际上是在Internally中重新解释的家庭特定的SockAddr结构之一（例如IPv4Sockets的Sockaddr_in）。 C ++还明确允许在其“相似性”规则下。</p><p>  廉价的对象序列化或转换：与上面相关，但略微有关：C和C ++与您转换几乎任何ObjectOto Char * 2.这允许对象被视为字节的袋子，这在编写哈希表时是方便的（您不在乎内容内容，您只想唯一地识别它们）或序列化结构在特定于主机的格式3时。</p><p> 以上每个都是有用的，但令人难以置信的不安全：嬗变是在运行时诺兰操作，该运行时将一个类型变为另一个类型，而是在编译时将某些位置视为在内存中的某个位置，就像其类型一样。结果：TypesResult之间的大多数可能是未定义的行为。</p><p>  Rust需要与C接口，所以4 RUTR支持嬗变。它通过std :: mem :: transtute来实现。但是，转换了一个根本不安全的操作，因此Rust禁止使用MEM :: Transume Event for在明确的不安全上下文中：</p><p> 使用std :: mem; ＃ ）{让foo = foo {a：0xaa，b：0xbb，c：0xcc，d：0xdd};让吧：栏=不安全{MEM :: Transume（Foo）}; //输出（x86-64）：bar.a = 0xddccbbaa println！ （＆＃34; bar.a = {：x}＆＃34;，酒吧.a）; }</p><p>  当然，传输可以包裹到安全的上下文中。但是底层操作总是不安全，不可能在其他安全的铁锈代码中。 </p><p>＃！[foutbid（不安全_code）]使用std :: {io :: {self，write，seek}，fs}; pub fn totally_safe_transmute＆lt; t，u＆gt; （v：t） - ＆gt; u {＃[R​​epre（c）]枚举e＆lt; t，u＆gt; {t（t），＃[允许（dead_code）] u（u），}让v = e :: t（v）;让mut f = f = fs :: OpenOptions :: new（）.write（true）.open（＆＃34; / proc / self / mem＆＃34;）.expect（＆＃34; welp＆＃34;）; F .seek（IO :: Seekfrom :: start（＆amp; v作为* const _为u64））.expect（＆＃34; Oof＆＃34;）; f .write（＆amp; [1]）.expect（＆＃34; darn＆＃34;）;如果让e :: u（v）= v {return v; }  恐慌！ （＆＃34; RIP＆＃34;）; }</p><p>   禁止是控制RUSTC LINTER（以及允许，警告和拒绝）的属性。在这种情况下，我们会告诉Rustc禁止禁止浏览不安全的嘴唇的任何东西，这正是它在TIN上所说的内容：捕获使用不安全。</p><p> 在这种情况下，禁止使用不安全不做任何事情：快速阅读代码展示不安全从未显示过。但它是读者的顶级证明，如果rustc接受代码（并且它确实），那么没有使用不安全。</p><p>     然后它采用一个混凝土参数v，它是T型而最终，ITRETURNS A U.</p><p> 我们知道，嬗变功能的作业是将一种类型的SomeValue重新诠释为其他类型，因此我们可以将此签名重写为：</p><p>   我们的下一点是一个有一些时髦的属性的简洁枚举。用我们友好的typeparameters重写：</p><p>  首先，我们将E作为ROP（C）标记为Rep（c）。这是ABI-Modify属性：它告诉RustC使用平台的C abi而不是（故意）的不稳定生锈abi。 </p><p>这实际上是什么意思？对于具有字段的枚举（如此），RUST使用“标记的Union”表示形式。在效果中，E成为这样的东西（在C语法中）：</p><p>   下一页：E有两个变体：第一个包含SRCTY类型的值，另一个包含一个值。</p><p> 可是等等！另一个rustc linter注释：这次，我们告诉Rustc，你的变体无法失败的Dead_code Lint.Normally，RustC会在静态推断上方的情况下警告我们;使用DEAD_CODE启用，它静默警告。像ABI布局一样，我们会看到为什么这是重要的。</p><p> 最后，我们通过新的绑定遮蔽了我们的v参数。 v已经是T型，Socreating e :: t完全没有问题。</p><p>    首先，我们正在打开一个文件。具体而言，我们在写模式下打开/ proc / self / mem。</p><p> / proc / self / mem是一个非常特殊的5个文件：它介绍了当前进程的视图，虚拟地址范围稀疏地映射。</p><p> 作为一个快速的黑客，我们可以通过检查str对象6的内存表示来证明这一点在Python中： </p><p>＆gt;＆gt;＆gt; x =＆＃34;此字符串足够长，以防止任何字符串互动＆＃34; ＆gt;＆gt;＆gt; ＃在cpython中，对象＆＃39; s id（通常）它的指针＆gt;＆gt;＆gt; x_addr = id（x）＆gt;＆gt;＆gt;十六进制（X_ADDR）＆＃39; 0x7FF1BC7CFCE0＆＃39; ＆gt;＆gt;＆gt; mem =打开（＆＃34; / proc / self / mem＆＃34; mode =＆＃34; rb＆＃34;）＆gt;＆gt; mem。寻求（x_addr）＆gt;＆gt;＆gt; mem。读（Len（x）* 4）B＆＃39; [Snip]＆＃34; thi \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00这个字符串足以阻止任何字符串interning \ x00 e \＆＃39; [Snip]＆＃39;</p><p>   ＆gt;＆gt;＆gt; ＃使用CTYPE避免我们看到的布局拍白，而GT;＆gt;＆gt;进口ctypes＆gt;＆gt;＆gt; cstr = ctypes。 c_char_p（b＆＃34;看起来ma，没有手和＃34;）＆gt;＆gt; cstr_addr = ctypes。 CAST（CSTR，CTYPES。C_VOID_P）。价值＆gt;＆gt;＆gt;十六进制（CStr_addr）＆＃39; 0x7f47f3e9c7​​90＆＃39; ＆gt;＆gt;＆gt; MEM =打开（＆＃34; / proc / self / mem＆＃34;，mode =＆＃34; r + b＆＃34;）＆gt;＆gt;＆gt; mem。寻求（cstr_addr）＆gt;＆gt;＆gt; mem。读（len（cstr.value））b＆＃39;看起来ma，没有手＆＃39; ＆gt;＆gt;＆gt; mem。寻求（CStr_Addr + 5）＆gt;＆gt;＆gt; mem。写（＆＃39; p＆＃39;）＆gt;＆gt; mem。寻求（cstr_addr）＆gt;＆gt;＆gt; mem。读（Len（CSTR.值））B＆＃39;看PA，没有手和＃39;</p><p> 完全两块完全_safe_transmute现在应该是有意义的：我们在自己的运行过程中寻求我们的V变量（现在是e的变体）的地址，我们为它写了一个U8（[1]）。</p><p> 但为什么1？回想起上面的e的c abi表示！第一部分是iurunion判别者。当数据是SRCTY时，判别是0.当我们强制性地搬运到1时，数据现在被解释为DSTTY！</p><p>  好的，所以我们已经戳了记忆并将我们的E :: T转变为E :: U。让我们看看我们是如何让它的：</p><p>  乍一看，这对此没有什么特别之处：我们只是丢弃了我们之前添加的枚举包装，以便我们可以返回我们的新棉被的dstty值。</p><p>  ......但是返回dstty的唯一方法是v为e :: u。 </p><p>......但V无条件初始化为E :: T，因此从未达到过返回。</p><p> 这就是我们需要允许（Dead_Code）之前的原因：没有E :: U曾经以那种可能达到返回声明的方式构建，因此只不需要它作为一个变种。确实，我们可以通过删除来确认这一点允许属性：</p><p> $ Cargo Build Compling完全安全 - 传输V0.0.3（/ TMP /完全安全 - 传输）警告：Variant永远不会构建：`U`  - ＆gt; SRC / lib.rs：9：9 | 9 | U（U），| ^^^^ | =注意：`＃[Warn（Dead_Code）]`On默认运行：1个警告发出的完成Dev [未通过+ DebugInfo]目标0.15s</p><p> 但是，唉：这不是真正死的代码：编译器是“错误的”，我们通过修改程序自己的内存来在运行时生成存在。然后我们是不可能的条件，并返回我们的传输价值。</p><p>  totally_safe_transmute是一个令人愉快的黑客，演示了当推理程序的行为时的关键限制：每个行为模型都是在环境模型上的偶然，并在程序（或程序的运行时，或编译器，或其他任何其他人）选择（或未切断）在所述环境中处理看似不可能的条件。</p><p> 这样做的能力不会反映生锈的根本不良，任何不仅仅是它的安全语言：从Rust的角度来看，完全_Unsafe_Transmute是什么，因此undefined是不可义的;处理无法发生的事情。</p><p>  如前所述，这种黑客仅通过对/proc/self/mem的依赖性作用于Linux。其他操作系统可能具有类似的机制。 </p><p>我没有测试过这个，但我很确定它只适用于小型架构（如x86）.on大endian架构，写入可能需要调整写作。</p><p>  如果我们非常迂腐：这技要技术上不是嬗变。语义上，嬗变是编译时类型的无效变化; totally_safe_transmutewrites程序的内存内存表示，以在运行时完成等效行为。我认为这是一个有区别的区别。</p><p>  因为Totally_Safe_Transmute依赖于未定义的行为（不可能的程序状态），因此在擦除E :: U分支并将功能缩短到Anuncuditional Punic的功能，Rust将是正确的！它在我的测试中没有这样做（即使在释放模式下），但程序语义中没有任何东西可以防止它这样做。但是，它会的日子，而且完全_safe_transmute会停止工作！</p><p> 应用程序和网络编程的巨大罪行之一，以及漏洞的共同来源。 ↩</p><p>  除其他原因之外。如上所述，当所有需求是某些对象的“一对字节”视图时，嬗变是有用的，或者当您可以保证一致的类型布局时。它对先进的寿命抹布也很有用。 ↩</p><p>  特定于平台：它是Linux的Procfs的一部分。因此，Totally_Safe_Transmute将无法在其他内容上运行（AS-IS）。 ↩</p><p>  正如您所明白的那样，它不是微不足道的（它不仅仅是一个长度数据对）。 unicodeObject.h中的CPython源具有完整的结构细节，完全与此帖子无关紧要。 ↩ </p><p>Reddit讨论 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.yossarian.net/2021/03/16/totally_safe_transmute-line-by-line">https://blog.yossarian.net/2021/03/16/totally_safe_transmute-line-by-line</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/safe/">#safe</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1044639.html"><img src="http://img2.diglog.com/img/2021/1/thumb_59ebd47c69a93232009c8a7f8642d8cb.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1044639.html">Google的安全浏览计划使我度过了难关 </a></div><span class="my_story_list_date">2021-1-17 6:6</span></div><div class="col-sm"><div><a target="_blank" href="/story/1041936.html"><img src="http://img2.diglog.com/img/2020/12/thumb_03dc0def78ee1317659ff8da96c8ae4c.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1041936.html">安全黑客（2011） </a></div><span class="my_story_list_date">2020-12-27 7:31</span></div><div class="col-sm"><div><a target="_blank" href="/story/1041302.html"><img src="http://img2.diglog.com/img/2020/12/thumb_b6cf19ee4915f3d5bd89203ebd351566.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1041302.html">Europol取消了VPN Safe-Inet </a></div><span class="my_story_list_date">2020-12-23 1:7</span></div><div class="col-sm"><div><a target="_blank" href="/story/1039813.html"><img src="http://img2.diglog.com/img/2020/12/thumb_8d2597aac8b586acddb8be18b5f82d19.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1039813.html">最小的安全Bash脚本模板 </a></div><span class="my_story_list_date">2020-12-15 19:41</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>