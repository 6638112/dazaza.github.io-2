<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>构建更好的整体（使用WebAssembly） Building a Better Monolith (With WebAssembly)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Building a Better Monolith (With WebAssembly)<br/>构建更好的整体（使用WebAssembly） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-09 19:33:48</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/fa700b7acf94f3d28e9470ad345e7bd3.png"><img src="http://img2.diglog.com/img/2020/12/fa700b7acf94f3d28e9470ad345e7bd3.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>When you hear that a company runs a monolith, you may think they&#39;re old-fashioned and they must have trouble scaling it, right? I&#39;m here to tell you that  some people (myself included) think monoliths are awesome for a whole lot of teams. That said, technology has advanced, and I truly think it&#39;s time to revisit the monolith with a new approach.</p><p>当您听说一家公司经营着一家大公司时，您可能会认为他们过时了，他们必须在扩展方面遇到麻烦，对吧？我在这里告诉您，有些人（包括我自己）认为整体对于许多团队来说都很棒。话虽如此，技术已经进步了，我真的认为现在是时候用一种新的方法重新审视整体。</p><p> If you&#39;re new to back-end development, a monolith is a server-side system that runs as one.... thing. It&#39;s a single program that starts up, serves some network requests, and then terminates. Alternatives to &#39;the monolith&#39; include service-oriented architectures (SOA), microservices, serverless functions, and probably a few that I haven&#39;t heard of. Each of these approaches has their time and place, and I salute anyone who has made an educated decision to build a system with these patterns. I&#39;m of the opinion that a large number of web applications and services would be well served by a monolith.... but with some upgrades.</p><p> 如果您不熟悉后端开发，那么Monolith就是作为一个东西运行的服务器端系统。它是一个单个程序，可以启动，处理一些网络请求，然后终止。巨石的替代品包括面向服务的体系结构（SOA），微服务，无服务器功能，可能还有一些我从未听说过的功能。这些方法中的每一种都有其时间和地点，我向任何做出过明智决定以这种模式构建系统的人致敬。我认为，大量的Web应用程序和服务可以通过整体组件很好地服务....，但需要进行一些升级。</p><p>  The reasoning behind the alternative design patterns is very sound. By distributing the work among many different “things”, you make the system as a whole able to handle more. It is well known that by doing so, you introduce more complexity, which requires more effort, and therefore often more people-power and more money. The one possible exception I can see is serverless functions, which do indeed simplify many things, but whose downsides comes in the form of more difficult testing, vendor dependence, or the need for non-commodity tooling. When done right, the extra effort can lead to a very capable system whose benefits are truly remarkable. The classic example is Netflix, and they’ve done very well for themselves.</p><p>  替代设计模式背后的理由非常合理。通过在许多不同的“事物”之间分配工作，您可以使系统作为一个整体来处理更多的事情。众所周知，这样做会引入更多的复杂性，这需要更多的精力，因此通常需要更多的人力和金钱。我看到的一个可能的例外是无服务器功能，确实确实简化了许多事情，但其缺点是测试更加困难，对供应商的依赖性更高，或者需要使用非商品工具。如果做得正确，那么额外的努力将导致一个功能强大的系统，其收益确实是非凡的。经典的例子是Netflix，他们自己做得很好。</p><p>  If monoliths are hard to scale and microservices are too complex, then how do you design a system that can scale with your traffic and your development team without becoming a pain to operate, maintain and expand its functionality? Over the past few years, it has become clear that a middle-ground is needed. I don’t expect this solution to work for everyone, but most products aren’t serving the kind of traffic that  really makes the microservice effort worth it.</p><p>  如果整体难于扩展，而微服务太复杂，那么您如何设计一个可以随流量和开发团队进行扩展而又不致于难以操作，维护和扩展其功能的系统？在过去的几年中，很明显需要中间立场。我并不希望这个解决方案能为所有人所用，但是大多数产品并不能提供真正使微服务值得的流量。</p><p>  Before getting into the core of what SUFA is, I want to mention that this is not an entirely new way of thinking. Things like the actor pattern, the  Neomonolith, and others have stipulated some similar ideas over the years, and SUFA is just one way of combining several concepts into one straightforward design pattern. So, what is it?</p><p>  在深入探讨SUFA的核心之前，我要提到这不是一种全新的思维方式。多年来，诸如演员模式，新独石等事物都规定了一些类似的想法，而SUFA只是将多个概念组合成一种简单的设计模式的一种方式。那是什么</p><p>    A system designed with SUFA can be run in the simplest of deployment scenarios. Auto-scaling groups have existed for a long time, and they’re made even easier by container orchestration systems. A SUFA system can be run on one ASG, or can be expanded with a service mesh to allow for capability groups (which we’ll talk about in a future post).</p><p>    使用SUFA设计的系统可以在最简单的部署方案中运行。自动缩放组已经存在很长时间了，容器编排系统使它们变得更加容易。 SUFA系统可以在一个ASG上运行，也可以通过服务网格进行扩展以允许功能组（我们将在以后的文章中讨论）。</p><p>  Rather than multiple services who each exist as something to be deployed, SUFA systems exist as one single deployable. This can be a Docker image, an AMI, or some other artifact, but there is only one  thing that needs to be built. It should be built by CI/CD on a continuous or tagged release cadence, and it should be made available in an artifact registry such as a Docker registry or S3 bucket.</p><p>  SUFA系统不是作为一个要部署的东西而存在的多个服务，而是作为一个可部署的系统而存在。这可以是Docker映像，AMI或其他一些工件，但是只需要构建一件事。它应该由CI / CD以连续或带标记的发布节奏构建，并且应该在工件注册表（例如Docker注册表或S3存储桶）中可用。 </p><p>  A standard monolith probably includes a handler layer which is responsible for taking API requests and making calls to a business logic or data storage layer to handle those requests. SUFA systems instead handle requests by chaining together a series of functions, each completely independent and unaware of one another. Functions should expect a particular input, perform some operations, and produce an output to be passed into functions further down the chain. Functions should be easily testable and reusable across different scenarios (such as for different API requests). SUFA systems should also be designed to consume and produce event-based traffic as a primary method of communication.</p><p>标准的整体组件可能包括处理程序层，该处理程序层负责接收API请求并调用业务逻辑或数据存储层以处理这些请求。 SUFA系统通过将一系列功能链接在一起来处理请求，每个功能完全独立并且彼此之间不知道。函数应该期望一个特定的输入，执行一些操作，并产生一个输出，该输出将传递到更下游的函数中。这些功能应该易于在不同情况下进行测试和重用（例如针对不同的API请求）。 SUFA系统还应设计为使用和产生基于事件的流量作为主要的通信方法。</p><p>  Well this seems like it should be straightforward, but in SUFA design, “Application” has a very particular meaning. A SUFA system should serve one single application, meaning that it should encompass all of the capabilities needed for a fully formed product. This can be up for some interpretation (such as whether a company should have one SUFA for their whole business, even if they have distinct product areas), but the point is to avoid having multiple “things” serving one application. If functionality needs to be shared across multiple applications, the functions comprising the SUFA system should be easily reusable and composed for other purposes.</p><p>  好吧，这似乎应该很简单，但是在SUFA设计中，“应用程序”具有非常特殊的含义。 SUFA系统应该服务于一个单一的应用程序，这意味着它应该包含完整产品所需的所有功能。这可以通过某种解释来解决（例如，即使公司具有不同的产品领域，一家公司是否应为整个业务使用一个SUFA），但关键是要避免在一个应用程序中使用多个“事物”。如果功能需要在多个应用程序之间共享，则构成SUFA系统的功能应易于重用，并可以用于其他目的。</p><p> You&#39;ll notice that this is all very technology-agnostic and vendor-agnostic. SUFA is meant to span across languages, cloud vendors, and deployment environments. SUFA is a way of designing your server-side system such that it is testable, scalable, and secure. You&#39;ll notice I haven&#39;t touched on scalability yet, so let&#39;s discuss that</p><p> 您会注意到，这完全与技术无关，与供应商无关。 SUFA旨在跨越各种语言，云供应商和部署环境。 SUFA是一种设计可测试，可扩展且安全的服务器端系统的方法。您会注意到我还没有谈到可扩展性，所以让我们讨论一下</p><p>  The critical factor that allows a SUFA system to scale is that it is composed of independent functions. SUFA systems should rely on an underlying framework to orchestrate the execution of these functions such that it can scale effectively. By using a function runner or job scheduler to run the required functions, a SUFA framework abstracts away  how the functions are executed, and the programmer writing the code only needs to indicate which functions to run, and in what order.</p><p>  允许SUFA系统扩展的关键因素是它由独立的功能组成。 SUFA系统应依靠底层框架来协调这些功能的执行，以便可以有效扩展。通过使用函数运行器或作业调度程序运行所需的函数，SUFA框架可以抽象出函数的执行方式，而编写代码的程序员只需指示要运行的函数以及运行的顺序即可。</p><p> Additional scalability is provided by  capability groups and  meshing, which I plan on writing follow-up posts for, as they deserve to be explored at length.</p><p> 功能组和网格提供了额外的可伸缩性，我计划为其编写后续文章，因为值得对其进行详细探讨。</p><p>  The SUFA pattern was designed in concert with  Atmo, which is an all-in-one framework upon which SUFA systems can be built. Atmo uses a file known as a &#39;Directive&#39; to describe all aspects of your application, including how to chain functions to handle requests. You can write your functions using several languages to be run atop Atmo, as it is built to use WebAssembly modules as the unit of compute. Atmo will automatically scale out to handle your application load, and includes all sorts of tooling and built-in best practices to ensure you&#39;re getting the best performance and security without needing to write a single line of boilerplate ever again.</p><p>  SUFA模式是与Atmo协同设计的，Atmo是可以构建SUFA系统的多合一框架。 Atmo使用称为＆＃39; Directive＆＃39;的文件描述应用程序的所有方面，包括如何链接功能以处理请求。您可以使用多种语言来编写函数，以便在Atmo上运行，因为它是使用WebAssembly模块作为计算单位而构建的。 Atmo将自动扩展以处理您的应用程序负载，并包括各种工具和内置的最佳实践，以确保您获得最佳性能和安全性而无需再次编写任何样板。</p><p> The awesome capabilities of WebAssembly and the design thinking behind SUFA are being harnessed by the open source  Suborbital Development Platform to introduce a new way to build your web applications. I&#39;ve been working for over a year to realize this goal, and I&#39;m extremely happy with the results thus far. Riding the wave of new technologies and practices such as JAMStack and edge computing means that we have a opportunity to bring the best of the old and the new to the next generation of software makers to do incredible things. I hope you&#39;ll come and join me!</p><p> 开源的Suborbital Development Platform利用WebAssembly的强大功能和SUFA背后的设计思想，引入了一种构建Web应用程序的新方法。我已经为实现这一目标进行了一年多的努力，到目前为止，我对结果非常满意。驾驭诸如JAMStack和边缘计算之类的新技术和新实践浪潮，意味着我们有机会将新旧软件的精华带给下一代软件制造商，以完成令人难以置信的事情。希望您能加入我的行列！ </p><p> Please reach out on Twitter ( @cohix or  @SuborbitalDev if you&#39;d like to talk about SUFA design or the Suborbital project!</p><p>如果您想谈论SUFA设计或Suborbital项目，请访问Twitter（@cohix或@SuborbitalDev！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/monolith/">#monolith</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/系统/">#系统</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>