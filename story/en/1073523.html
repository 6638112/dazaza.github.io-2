<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>异步Rust中的模拟时间Mocking Time in Async Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Mocking Time in Async Rust<br/>异步Rust中的模拟时间</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 21:04:18</div><div class="page_narrow text-break page_content"><p>We love async Rust at Ditto. We were early adopters, using futures and streams in our networking code long before async/await became stable. Our product is a perfect use case. It&#39;s I/O-heavy, there are numerous peer-to-peer connections synchronizing data concurrently, and we need to use all cores efficiently on low-powered devices like mobile phones.</p><p>我们喜欢async Rust，同上。我们是早期采用者，早在async/await变得稳定之前，我们就在网络代码中使用未来和流。我们的产品是一个完美的用例。它&#39；在I/O方面，有大量的对等连接同时同步数据，我们需要在手机等低功耗设备上高效地使用所有核心。</p><p> A common challenge in async is writing good tests. Take a simple example: below we create a hypothetical  Connection. If there is no activity for 10 seconds it should time out internally and close its events channel. We can write a test verifying this:</p><p>异步中的一个常见挑战是编写好的测试。举个简单的例子：下面我们创建一个假设的连接。如果10秒钟内没有活动，它应该在内部超时并关闭其事件通道。我们可以编写一个测试来验证这一点：</p><p> #[tokio::test]async fn test_timeout_occurs() { // Create the Connection let mut conn = Connection::new().await; // Wait for a while delay_for(Duration::from_secs(11)).await.unwrap(); // The receive channel should have closed assert_eq!(conn.try_recv().unwrap_err(), TryRecvError::Disconnected);}</p><p>#[tokio:：test]异步fn test_timeout_ocurses（）{//创建连接让mut conn=Connection:：new（）.Wait；//等待一段时间延迟_for（Duration:：from_secs（11））.Wait.unwrap（）；//接收通道应该关闭assert_eq！（conn.try_recv（）.unwrap_err（），tryrecveror:：Disconnected）}</p><p> One problem with this test is that it always takes 11 seconds to execute: 10 seconds to wait for the timeout plus a safety factor. Slow tests are a huge hassle for both developers and CI/CD. Imagine if it was 30 minutes instead. Your CI runs would take  at least 30 minutes, all because of this one test!</p><p>这个测试的一个问题是执行总是需要11秒：10秒等待超时加上安全系数。缓慢的测试对开发人员和CI/CD来说都是一个巨大的麻烦。想象一下，如果是30分钟。你的CI运行至少需要30分钟，这都是因为这一次测试！</p><p> A related challenge is testing for the  absence of a timer expiry. Here we ensure the events channel is still open at 5 seconds:</p><p>一个相关的挑战是测试计时器是否过期。在这里，我们确保事件频道在5秒时仍然打开：</p><p> #[tokio::test]async fn test_timeout_does_not_occur() { // Create the Connection let mut conn = Connection::new().await; // Wait less than in the other test delay_for(Duration::from_secs(5)).await.unwrap(); // The receive channel should still be open (but no value) assert_eq!(conn.try_recv().unwrap_err(), TryRecvError::Empty);}</p><p>#[tokio:：test]异步fn test_timeout_not_Occurse（）{//创建连接让mut conn=Connection:：new（）.Wait；//等待时间小于其他测试延迟中的时间（持续时间：：from_secs（5））.Wait.unwrap（）；//接收通道仍应打开（但没有值）assert_eq！（conn.try_recv（）.unwrap_err（），TryRecvError:：Empty）；]</p><p> This test is also slow, weighing in at 5 seconds, but there is a more insidious problem. Imagine our  Connection had a bug which caused it to close the channel after only 4 seconds. Would this test catch it? Probably… but not necessarily.</p><p>这个测试也很慢，在5秒钟内称重，但有一个更隐蔽的问题。想象一下，我们的连接出现了一个错误，导致它在4秒钟后关闭了通道。这个测试能抓住它吗？可能…但不一定。</p><p> When that internal 4-second timer expires a series of steps must occur. A tokio worker thread must be unparked and poll the task which was waiting on that timer. Having noticed that the timer has expired it drops the events sender, which indicates to the receiving end that the channel is closed. It&#39;s only a small amount of work but it&#39;s not instantaneous, and it has to run concurrently with the main test task.</p><p>当内部4秒计时器过期时，必须执行一系列步骤。一个tokio worker线程必须被解列并轮询等待该计时器的任务。在注意到计时器已过期后，它会丢弃事件发送器，这向接收端指示通道已关闭。它&#39；这只是一小部分工作，但它&#39；它不是即时的，它必须与主测试任务同时运行。</p><p> If you run this on your high-end development machine (which is what Rust developers use) then that expiry-and-channel-close process will occur in a matter of milliseconds. By the time the test task performs the assertion 1 second later, the channel will almost certainly be closed and the bug will be detected. On a heavily-loaded CI server, however, there may be fierce contention between threads. Processing the inner timeout might be delayed by 1–2 real-world seconds and the test would appear to pass. The previous test has the same problem in reverse; if the inner timeout gets delayed it will fail, even though the code being tested is correct.</p><p>如果在高端开发机器（Rust开发者使用的机器）上运行这个程序，那么过期和通道关闭过程将在几毫秒内发生。当测试任务在1秒后执行断言时，几乎肯定会关闭通道并检测到错误。然而，在负载沉重的CI服务器上，线程之间可能存在激烈的竞争。处理内部超时可能会延迟1–2秒，测试似乎会通过。上一次测试的问题相反；如果内部超时被延迟，它将失败，即使测试的代码是正确的。</p><p> These tests are non-deterministic and will result in flaky CI: intermittent build failures where you&#39;re not sure whether you can trust the results. This is suboptimal.</p><p>这些测试是不确定的，会导致不稳定的CI：间歇性的构建失败，其中&#39；我们不确定你是否能相信结果。这是次优的。</p><p> Conventional wisdom says that you shouldn&#39;t structure your code this way. Any logic you want to test should be expressed as synchronous code which is fully deterministic and abstracted away from the system clock. This is okay for small unit tests but it becomes a headache in larger integration tests. Some of our business logic is tied up in async behavior. Why can&#39;t we test that, the way our customers will experience it? If we test only the sync parts we&#39;re losing coverage.</p><p>传统智慧认为你不应该&#39；不要这样构造代码。要测试的任何逻辑都应该表示为完全确定的同步代码，并从系统时钟中抽象出来。这对于小型单元测试来说是可以的，但在大型集成测试中却成了一个头疼的问题。我们的一些业务逻辑与异步行为有关。为什么可以&#39；我们不测试一下吗？我们的客户将如何体验？如果我们只测试同步部分，我们&#39；我们正在失去报道。</p><p>  In a test context, passage of time should be abstracted so that tests execute near-instantly no matter how long the delays are.</p><p>在测试环境中，时间的流逝应该被抽象出来，这样无论延迟多长，测试都可以立即执行。</p><p> Tests should be fully deterministic: an earlier timer always gets to work to completion before a timer scheduled later.</p><p>测试应该是完全确定的：一个更早的计时器总是在一个更晚的计时器之前工作到完成。</p><p> As a unit test advances mock time,  Instant::now() should return the correct intermediate time during the triggering of each timer.</p><p>随着单元测试推进模拟时间，Instant:：now（）应该在触发每个计时器期间返回正确的中间时间。</p><p> The processing work attached to a timer should allow new timers to be registered along the way.</p><p>附加在计时器上的处理工作应该允许新的计时器在此过程中注册。</p><p> Ditto has built an internal library to address all of these problems. This crate,  ditto_time, abstracts over  std::time and the tokio timer functions. Here is the first test again, except now using this library.</p><p>同上，我们已经建立了一个内部库来解决所有这些问题。这个板条箱，同上，抽象了std:：time和东京定时器的功能。这里是第一次测试，除了现在使用这个库。</p><p> #[test]fn test_timeout_occurs_fast() { let (time_control, _guard) = register_new_control(); let rt = build_instrumented_runtime(&amp;time_control); rt.block_on(async { let mut conn = Connection::new().await; time_control.advance(Duration::from_secs(10)).await; // &lt;---- assert_eq!(conn.try_recv().unwrap_err(), TryRecvError::Disconnected); });}</p><p>#[test]fn test_timeout_occurrent_fast（）{let（time_control，_guard）=register_new_control（）；let rt=build_instrumented_runtime（&amp；time_control）；rt.block_on（async{let mut conn=Connection:：new（）.wait；time_control.advance（Duration:：from_secs（10））.wait；//&lt；--assert_eq！（conn.try_recv（）.unwrap)），TryRecvError:：Disconnected）}）</p><p> This test is reliable and completes immediately. First there is a little boilerplate which ensures the code under test will use mock timers instead of real ones. For now, focus on the call to  time_control.advance(). Notice that it moves time ahead precisely 10 seconds. Then on the next line, the channel is guaranteed to be closed.</p><p>该测试是可靠的，并立即完成。首先，有一个小样本，确保测试中的代码将使用模拟计时器，而不是真正的计时器。现在，请关注对时间控制的调用。advance（）。请注意，它将时间精确地向前移动10秒。然后在下一条线路上，通道保证关闭。</p><p> This is the most difficult part. It is not sufficient to trigger the timer. Somehow we have to know when the code which  received that timer event has finished doing all of its associated work. This isn&#39;t possible using conventional timer futures. We don&#39;t know when the associated task will get scheduled, let alone when it&#39;s finished. Therefore the futures in  ditto_time are different—they output a  FrozenTimeControlGuard.</p><p>这是最困难的部分。触发计时器是不够的。不知何故，我们必须知道接收计时器事件的代码何时完成了所有相关工作。这不是&#39；使用传统计时器是不可能的。我们没有&#39；我不知道相关的任务将在什么时候被安排，更不用说什么时候&#39；结束了。因此，在同上的时间里，期货是不同的，它们输出一个FrozenTimeControlGuard。</p><p> { let _guard = ditto_time::delay_for(Duration::from_secs(10)).await.unwrap(); // handle timer event // guard dropped; time can advance}</p><p>{let _guard=ditto_time:：delay_for（Duration:：from_secs（10））.wait.unwrap（）//处理计时器事件//保护被丢弃；时间可以提前}</p><p> It turns out that in almost all situations, timer-driven code does all of the relevant processing in a single block immediately following the  await. Therefore all we have to do is create a binding like  _guard, and now we have a value that can notify us when the end of the block has been reached—and therefore time can continue. In unusual cases the developer can preserve the guard as long as needed.</p><p>事实证明，在几乎所有情况下，计时器驱动的代码在等待之后立即在单个块中执行所有相关处理。因此，我们所要做的就是创建一个像_-guard这样的绑定，现在我们有了一个值，可以在到达块的末尾时通知我们，因此时间可以继续。在不寻常的情况下，开发人员可以根据需要保留警卫。</p><p>  In unit test code the guard contains a oneshot sender. On drop the channel closes and the call to  advance() knows that it can move on to the next timer.  advance() is an async loop over all the currently-registered timers, triggering them one at a time and waiting for the corresponding channel to close. In non-test code there is no channel at all—no extra processing is required.</p><p>在单元测试代码中，警卫包含一个一次性发送器。在drop上，通道关闭，对advance（）的调用知道它可以转到下一个计时器。advance（）是一个异步循环，覆盖所有当前注册的计时器，一次触发一个计时器，并等待相应的通道关闭。在非测试代码中，根本没有通道，不需要额外的处理。</p><p> The last trick is correctly selecting real vs mock timers, and ensuring that they are associated with the correct  TimeControl. Rust runs tests in parallel so there may be many tokio runtimes executing tests simultaneously. If we tried to use global storage, different tests will clobber each other.</p><p>最后一个技巧是正确选择真实计时器和模拟计时器，并确保它们与正确的时间控件相关联。Rust并行运行测试，因此可能有许多tokio运行时同时执行测试。如果我们试图使用全局存储，不同的测试将相互碰撞。</p><p> The solution is thread-local storage (TLS). Tokio offers  the ability to run code when each worker thread is started, which is an opportunity to store an  Arc&lt;TimeControl&gt;. This is the purpose of the  build_instrumented_runtime boilerplate in the test. When the code under test calls  delay_for() it will dynamically create a  Delay future of the correct variant:</p><p>解决方案是线程本地存储（TLS）。Tokio提供了在每个工作线程启动时运行代码的能力，这是一个存储Arc的机会&lt；时间控制&gt；。这就是测试中构建的测试运行时模板的目的。当被测代码调用delay_for（）时，它将动态创建正确变量的延迟未来：</p><p> thread_local!( static MOCK_CONTROL: RefCell&lt;Option&lt;Arc&lt;TimeControl&gt;&gt;&gt; = RefCell::new(None));pub fn delay_for(duration: std::time::Duration) -&gt; Delay { MOCK_CONTROL.with(|it| match it.borrow().as_ref() { Some(control) =&gt; { let deadline = control.now() + duration; Delay::new_mock(control, deadline) } None =&gt; Delay::Real(Box::pin(tokio::time::sleep(duration))), })}</p><p>本地线程！（静态模拟_控件：RefCell&lt；Option&lt；Arc&lt；TimeControl&gt；=RefCell:：new（无））；发布fn延迟（持续时间：标准时间：持续时间）->；延迟{MOCK_CONTROL.with（|it | match it.borrow（）.as_ref（）{Some（CONTROL）=&gt；{let deadline=CONTROL.now（）+持续时间；延迟：：new_MOCK（CONTROL，deadline）}None=&gt；延迟：：真实（盒子：：引脚（东京：：时间：：睡眠（持续时间）），}</p><p>  #[test]fn test_timeout_occurs_fast() { let (time_control, _guard) = register_new_control(); let rt = build_instrumented_runtime(&amp;time_control); rt.block_on(async { let mut conn = Connection::new().await; time_control.advance(Duration::from_secs(10)).await; assert_eq!(conn.try_recv().unwrap_err(), TryRecvError::Disconnected); });}</p><p>#[test]fn test_timeout_occurrent_fast（）{let（time_control，_guard）=register_new_control（）；let rt=build_instrumented_runtime（&amp；time_control）；rt.block_on（异步{let mut conn=Connection:：new（）.wait；time_control.advance（持续时间：：from_secs（10））.wait；断言_eq！（conn.try_recv（）.unwrap_err（），TryRecvError:：Disconnected）}）</p><p> A  TimeControl instance is created that the test will use to advance time, and will also collect registrations of mock timers.</p><p>创建了一个TimeControl实例，测试将使用该实例来提前计时，并且还将收集模拟计时器的注册。</p><p>   advance() is called with a 10 second duration. This will advance to 10 seconds, permitting all of the code inside  Connection to run. The channel gets closed.</p><p>调用advance（）的持续时间为10秒。这将提前到10秒，允许连接中的所有代码运行。频道关闭了。</p><p> The second test can be adapted similarly. If the channel closes in 5 seconds or less, we&#39;re guaranteed to catch it.</p><p>第二个测试也可以进行类似的调整。如果通道在5秒或更短时间内关闭，我们&#39；你一定会抓住的。</p><p> #[test]fn test_timeout_does_not_occur_fast() { let (time_control, _guard) = register_new_control(); let rt = build_instrumented_runtime(&amp;time_control); rt.block_on(async { let mut conn = Connection::new().await; time_control.advance(Duration::from_secs(5)).await; assert_eq!(conn.try_recv().unwrap_err(), TryRecvError::Empty); });}</p><p>#[test]fn test_timeout_not_occurrent_fast（）{let（time_control，_guard）=register_new_control（）；let rt=build_instrumented_runtime（&amp；time_control）；rt.block_on（async{let mut conn=Connection:：new（）.wait；time_control.advance（持续时间：from_secs（5））.wait；assert_eq！（conn.try_recv（）.try_err（）.unwrap（），TryRecvError:：Empty）}）</p><p> This technique has enabled Ditto to build fast-running unit tests on exactly the same async code our customers use, with only modest code modifications to account for the guards. Testing gives us the confidence to include business logic directly in our async layer, avoiding the overhead of structuring timer-driven code into sync and async components. We believe async Rust has a bright future and our customers are already seeing the benefits.</p><p>这种技术使Ditto能够在我们的客户使用的完全相同的异步代码上构建快速运行的单元测试，只需对代码进行适度的修改即可解决这些问题。测试让我们有信心将业务逻辑直接包含在异步层中，避免了将计时器驱动的代码构造为同步和异步组件的开销。我们相信async Rust有着光明的未来，我们的客户已经看到了它的好处。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/模拟/">#模拟</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1072687.html"><img src="http://img2.diglog.com/img/2022/1/thumb_fce16028afb0f29cca60b950bde96b7c.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072687.html">不相信平均值：如何评估和加强业务的健康</a></div><span class="my_story_list_date">2022-1-11 7:11</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072666.html"><img src="http://img2.diglog.com/img/2022/1/thumb_85b9057458b3e0928e2830e0081133ad.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072666.html">看看联邦调查局越来越多的面部承认使用，包括来自FBI和冰等机构的最近合同，ClearView AI，信任邮票和其他人</a></div><span class="my_story_list_date">2022-1-11 3:39</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072564.html"><img src="http://img2.diglog.com/img/2022/1/thumb_6003c74de391823d5141a450b25fecf9.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072564.html">史前雨林的化石在澳大利亚生锈的岩石里藏起来</a></div><span class="my_story_list_date">2022-1-10 5:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072557.html"><img src="http://img2.diglog.com/img/2022/1/thumb_d33f0fc4936d2e42636ddd12ed07947d.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072557.html">印度的反托拉斯看门狗在新闻出版商投诉后订购了谷歌的调查，该公司正在滥用其新闻汇总统治</a></div><span class="my_story_list_date">2022-1-10 4:40</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>