<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>向你学习Agda（2014）Learn You an Agda (2014)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Learn You an Agda (2014)<br/>向你学习Agda（2014）</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 04:33:31</div><div class="page_narrow text-break page_content"><p>This is a markdown version of the tutorial Learn You an Agda and Achieve Enlightenment!by  Liam O’Connor-Davis.</p><p>这是一个降价版的教程学习你的Agda和实现启蒙！利亚姆·奥康纳·戴维斯著。</p><p> I made this version for my own reference, while working through thetutorial, making some revisions and additions, and a fewcorrections. You may prefer the original.</p><p>我制作这个版本是为了我自己的参考，同时我还进行了一些修改和补充，以及一些修正。你可能更喜欢原版。</p><p>         Welcome to  Learn You an Agda and Achieve Enlightenment!If you’re reading this, you’re probably curious as to what Agda is, why you wantto learn it, and in general what the big deal is about dependently typed, purelyfunctional programming.</p><p>欢迎学习Agda并获得启发！如果你正在读这篇文章，你可能会好奇Agda是什么，为什么你想学习它，以及一般来说，依赖类型的纯函数编程有什么大不了的。</p><p> Inspired by BONUS, the writer of Learn You a Haskell, I decidedthat I should write an approachable Agda tutorial that would introduce dependently typedprogramming to ordinary people rather than Ivory Tower Academics. Of course, seeing as I am one of those Ivory Tower Academics, this might not be easy. I am, however, preparedto give it a try. Learning Agda was a very rewarding but very difficult process for me. Itis my hope that, by writing this tutorial, it will become a little bit easier for everyoneelse.</p><p>受BONUS的启发，我决定写一本易懂的Agda教程，向普通人而不是象牙塔学者介绍独立打字编程。当然，鉴于我是象牙塔学者之一，这可能并不容易。不过，我准备试一试。学习Agda对我来说是一个非常有益但非常困难的过程。我希望，通过编写本教程，每个人都能轻松一点。</p><p>   (The original tutorial suggested that Haskell should be learned before Agda.However, if one already knows some functional programming, thenAgda should not be very hard to learn. This should be especially true for thosewith some background in logic and experience with other dependently typed languages.)</p><p>（最初的教程建议在Agda之前先学习Haskell。但是，如果一个人已经知道一些函数式编程，那么Agda应该不是很难学。对于那些具有一定逻辑背景和其他依赖类型语言经验的人来说，这一点尤其重要。）</p><p>  This tutorial is not aimed at those who are completely new to functionalprogramming. Agda is similar on a basic level to typed functional languages suchas Haskell and ML, and so knowing a language in the ML family will certainlymake learning Agda a great deal easier.</p><p>本教程并非针对那些完全不熟悉功能编程的人。Agda在基本层面上类似于Haskell和ML等类型化函数语言，因此了解ML家族中的一种语言肯定会使学习Agda变得更容易。</p><p> If you don’t know a statically typed functional language, I recommend that youlearn Haskell, as Agda has a close relationship with the Haskell ecosystem. Ifyou’re looking for a good Haskell tutorial, look no further than this book’scompanion,  Learn You a Haskell.</p><p>如果您不懂静态类型的函数式语言，我建议您学习Haskell，因为Agda与Haskell生态系统有着密切的关系。如果你想找一本好的哈斯凯尔教程，那就看看这本书的比较吧，给你学一本哈斯凯尔。</p><p> If you don’t know how purely functional programming works, learn a little of it before trying to tackle Agda.</p><p>如果你不知道纯粹的函数式编程是如何工作的，在尝试解决Agda之前先学一点。</p><p> Understanding of imperative and object oriented programming (C, Java, Ruby..) isn’tnecessary. In fact, trying to apply skills learned from these languages might even beharmful when you’re trying to learn Agda.</p><p>了解命令式和面向对象编程（C、Java、Ruby等）没有必要。事实上，当你试图学习Agda时，尝试运用从这些语言中学习到的技能甚至可能会表现得很糟糕。</p><p> The moral of the story is: keep an open mind. A lot of Agda’s power comes from features that are at first difficult to understand. It took a long time for everything in Agda to fall into place in my head. Agda is  hard. After some time, though, Agda’s inherentawesomeness comes to the fore, and it all just clicks. If you encounter obstacles in your Agda learning, don’t be discouraged! Keep working, and eventually you will be a master of Agda fu.</p><p>这个故事的寓意是：保持开放的心态。Agda的很多功能最初很难理解。过了很长一段时间，阿格达的一切才在我的脑海中就位。阿格达很难。然而，过了一段时间，阿格达的内在美脱颖而出，一切都只是咔哒一声。如果你在Agda学习中遇到障碍，不要气馁！继续努力，最终你会成为阿格达夫的大师。</p><p>   Agda is a programming language, but not a programming language like Java. It’s not even very much like Haskell, although it’s a lot more like Haskell than Java.</p><p>Agda是一种编程语言，但不像Java那样是一种编程语言。它甚至不太像Haskell，尽管它更像Haskell而不是Java。</p><p> Agda is a programming language that uses  dependent types. Many of you wouldbe familiar with types from imperative languages such as Java or C++, and if you’rereading up to this point, you should also have a familiarity with types fromHaskell.</p><p>Agda是一种使用依赖类型的编程语言。很多人都会熟悉java语言或C++等命令式语言的类型，如果你重新阅读到这一点，你也应该熟悉Haskel.</p><p> Types in these languages essentially annotate expressions with a tag. At a simple level,an expression’s type might just be a concrete type, like  Bool or  Int. Java (throughgenerics), C++ (through templates) and Haskell all support polymorphic types as well,such as  List a or  Map k v.</p><p>这些语言中的类型本质上是用标记来注释表达式。在一个简单的层次上，表达式的类型可能只是一个具体类型，比如BoL或int（java）（泛型）、C++（通过模板）和Haskell都支持多态类型，例如列表A或图K V。</p><p>  But, if  List a is a type, then what exactly  is just  List (without the parameter)? Haskell calls it a “type constructor”, but really it’s a  function at the typelevel.  List takes in a type, say  Int, and returns a new type,  ListInt. Haskell (with appropriate extensions) even supports arbitrary functions onthe type level, that don’t necessarily have to construct a type term, andinstead can simply refer to existing ones.</p><p>但是，如果列表a是一种类型，那么什么才是列表（没有参数）？Haskell称之为“类型构造函数”，但实际上它是类型级别的函数。List接受一个类型，比如Int，然后返回一个新类型ListInt。Haskell（带有适当的扩展）甚至支持类型级别上的任意函数，这些函数不一定要构造类型术语，而Instead可以简单地引用现有的函数。</p><p> So, Haskell has type-level functions, even type-level types (kinds). It almost seems likean entirely new language, overlaid over Haskell, that operates at compile time,manipulating type terms.</p><p>因此，Haskell有类型级别的函数，甚至有类型级别的类型（种类）。它几乎像是一种全新的语言，覆盖在Haskell之上，在编译时运行，处理类型术语。</p><p> In fact, you could think of any type system this way. In C++, people exploit theTuring-completeness of their type system to perform compile-time analysis andcomputation. While such type level work is very powerful, I fear that such typemachinery is very often difficult to understand and manipulate. Even in Haskell,applications that make extensive use of type-level computation are very oftensubstantially harder to comprehend. The type-level “language” is almost alwayssubstantially more complicated to work with than the value-level “language.”</p><p>事实上，你可以这样想任何类型的系统。在C++中，人们利用其类型系统的完整性来完成编译时分析和计算。虽然这种打字水平的工作非常强大，但我担心这种打字机器往往很难理解和操作。即使在Haskell中，广泛使用类型级计算的应用程序通常也很难理解。类型级别的“语言”几乎总是比值级别的“语言”更复杂</p><p> In Agda, the distinction between types and values does not exist. Instead, thelanguage you use to manipulate type terms is exactly the same language that youuse to manipulate values.</p><p>在Agda中，类型和值之间不存在区别。相反，用于操纵类型术语的语言与用于操纵值的语言完全相同。</p><p> This means that you can actually include values  inside a type. For example, the  Listtype constructor can be parameterized by both the type of its contents  and the length of the list in question (we’ll be doing this later). This allows the compiler to check for youto make sure there are no cases where you attempt to call  head on apotentially empty list, for example. Being able to include values inside a type,and use all the same value-level operations on them, is what makes Agda dependently typed - Not only can values have a type, but types can have a value.</p><p>这意味着您实际上可以在类型中包含值。例如，Listtype构造函数可以通过其内容的类型和相关列表的长度进行参数化（我们将在后面进行）。例如，这允许编译器检查您，以确保您没有试图在一个可能为空的列表上调用head的情况。能够在类型中包含值，并对其使用所有相同的值级操作，这就是Agda依赖于类型的原因——不仅值可以有一个类型，而且类型也可以有一个值。</p><p> In fact, seeing as the language of values and the language of types are thesame,  any property that you can express about a value can be expressedstatically in its type, and machine checked by Agda. We can statically eliminateany error scenario from our program.</p><p>事实上，由于值的语言和类型的语言是相同的，所以任何可以表达的关于值的属性都可以在其类型中静态地表达，并由Agda进行机器检查。我们可以从程序中静态消除任何错误场景。</p><p>    If I can come up with a function of type  Foo -&gt; Bar (and Agda says that it’stype correct) that means that I’ve written not only a program, but also a proofby construction that, assuming some premise  Foo, the judgment  Barholds. (We’ll touch more on proofs later; I don’t want to get bogged down indetails just yet.)</p><p>如果我能想出一个Foo类型的函数-&gt；Bar（Agda说它是正确的）这意味着我不仅编写了一个程序，而且还编写了一个证明结构，假设某个前提为Foo，判断Barhold。（稍后我们将更多地讨论证据；我不想现在就陷入细节。）</p><p> Seeing as our  Foo and  Bar can be as expressive as we like, this lets usprove  anything we want about our program simply by exploiting thiscorrespondence between proofs and programs - called the Curry-Howard Correspondence,discovered by two brilliant logicians in the sixties.</p><p>鉴于我们的Foo和Bar可以随心所欲地表达，这让我们只需利用证明和程序之间的这种对应关系，就可以对我们的程序进行任何我们想要的改进——称为Curry Howard对应关系，这是两位杰出的逻辑学家在60年代发现的。</p><p>   The validity of formal verification of software is often hotly contested byprogrammers who usually have no experience in formal verification. Often testingmethodologies are presented as a more viable alternative.</p><p>软件形式验证的有效性经常受到程序员的激烈质疑，他们通常没有正式验证的经验。通常，测试方法被认为是一种更可行的选择。</p><p> While formal verification is excessive in some situations where bugs areacceptable, I hardly think that testing could replace formal verificationcompletely. Here are three reasons for this:</p><p>虽然在某些可以接受bug的情况下，形式验证是过度的，但我几乎不认为测试可以完全取代形式验证。以下是三个原因：</p><p> Proofs work in concurrent scenarios. You can’t reliably unit test against race conditions, starvation or deadlock. All of these things can be eliminated via formal methods.</p><p>证明在并行场景中有效。您无法可靠地针对竞争条件、饥饿或死锁进行单元测试。所有这些都可以通过形式化方法消除。</p><p>  Proofs, like programs, are compositional. Tests are not. In testingscenarios, one typically has to write both unit tests and integration tests:unit tests for testing small components individually, and integration testsfor testing the interaction between those small components. If I have proofsof the behavior of those small components, I can simply use those proofresults to satisfy a proof obligation about their interaction – there is noneed to reinvent everything for both testing scenarios.</p><p>像程序一样，证明也是合成的。测试并非如此。在测试场景中，通常必须编写单元测试和集成测试：分别测试小组件的单元测试，以及测试这些小组件之间交互的集成测试。如果我有这些小组件行为的证明，我可以简单地使用这些证明结果来满足关于它们的交互的证明义务——没有必要为两种测试场景重新创造一切。</p><p>  Proofs are fool-proof. If I have a suite of tests to show some property,it’s possible that that property does not actually hold - I simply have notbeen thorough enough in my tests. With formal verification, it’s impossiblefor violations of your properties to slip through the cracks like that.</p><p>证据是傻瓜式的。如果我有一套测试来显示某些属性，那么该属性可能实际上并不成立——我只是在测试中不够彻底。有了正式的验证，违反你的财产就不可能像那样从裂缝中溜走。</p><p> Of course, proofs are not for every scenario, but I think they should be farmore widely used than they currently are.</p><p>当然，证据并非适用于所有情况，但我认为它们应该比目前更广泛地使用。</p><p> Thanks to Curry-Howard, Agda can also be used as a  proof language, as opposedto a  programming language. You can construct a proof not just about yourprogram, but about anything you like.</p><p>多亏了Curry Howard，Agda还可以用作证明语言，而不是编程语言。你可以构建一个证明，不仅是关于你的程序，而且是关于你喜欢的任何东西。</p><p> In fact, Curry-Howard shows us that the fundamentals of functional programming(Lambda Calculus), and the fundamentals of mathematical proof (Logic) are infact the same thing ( isomorphic). This means that we can structuremathematical proofs in Agda as  programs, and have Agda check them for us. It’sjust as valid as a standard pen-and-paper mathematical proof (probably more so,seeing as Agda doesn’t let us leave anything as “an exercise for the reader” -and Agda can check our proof’s correctness automatically for us. We’ll be doingthis later by proving some basic mathematical properties on Peano natural numbers.</p><p>事实上，库里·霍华德向我们展示了函数式编程（Lambda演算）的基本原理和数学证明（逻辑）的基本原理实际上是一样的（同构的）。这意味着我们可以在Agda中以程序的形式构造数学证明，并让Agda为我们检查它们。它必须和标准的纸笔数学证明一样有效（可能更有效，因为Agda不允许我们把任何东西作为“读者练习”留下”——Agda可以自动为我们检查证明的正确性。我们稍后将通过证明一些关于Peano自然数的基本数学性质来完成这项工作。</p><p> So, Agda is a language that really lives the dream of the Curry-Howardcorrespondence. An Agda program is also a proof of the formula represented inits type.</p><p>因此，阿格达是一种真正实现了库里·霍华德梦想的语言。Agda程序也是inits类型表示的公式的证明。</p><p>   At the time of writing, it is only really feasible to edit Agda code usingEmacs. GNU Emacs or XEmacs are both fine. However, you don’t need a great dealof Emacs proficiency to edit Agda code.</p><p>在编写本文时，只有使用ingemacs编辑Agda代码才是真正可行的。GNU Emacs或XEmacs都可以。然而，编辑Agda代码并不需要精通Emacs。</p><p>  (If you are using Ubuntu Linux, you may wish to skip to the next section, Installing on Ubuntu Linux.)</p><p>（如果您使用的是Ubuntu Linux，您可能希望跳到下一节，在Ubuntu Linux上安装。）</p><p> You’ll need GHC, a Haskell compiler, and an assortment of tools and librariesthat make up the  Haskell Platform. It isthe best way to get started using Haskell, and it’s also the easiest way to get Agda.</p><p>您将需要GHC、Haskell编译器以及各种工具和库，它们构成了Haskell平台。这是开始使用Haskell的最佳方式，也是获得Agda的最简单方式。</p><p> Once you have Haskell and Emacs, there are three things you still need to do:</p><p>一旦你有了Haskell和Emacs，你还需要做三件事：</p><p> Install Agda. Linux users may have Agda packages available from their packagemanager (search for “agda” to find out). If not or otherwise, simply use theHaskell platform’s  cabal-install tool to download, compile, and set up Agda.</p><p>安装Agda。Linux用户可以从packagemanager中获得Agda软件包（搜索“Agda”以查找）。如果没有或没有，只需使用Haskell平台的cabal安装工具下载、编译和设置Agda即可。</p><p>  Install Agda mode for emacs. Simply type in a command prompt (where Agda is inyour  PATH):</p><p>为emacs安装Agda模式。只需输入命令提示符（Agda在您的路径中）：</p><p>  Compile Agda mode as well (you’ll need to do this again if you update Agda):</p><p>还要编译Agda模式（如果更新Agda，则需要再次编译）：</p><p>  By then you should be all set. To find out if everything went as well asexpected, head on over to the  next section.</p><p>到那时你应该准备好了。要想知道一切是否都如预期般顺利，请转到下一节。</p><p>  On a Ubuntu Linux system, instead of installing Agda using cabal as above, onecould alternatively use the following two commands, which take a few minutes to run:</p><p>在Ubuntu Linux系统上，不必像上面那样使用cabal安装Agda，也可以使用以下两个命令，这两个命令需要几分钟才能运行：</p><p>  That’s it! Now, when you launch Emacs and edit a file with the .agda extension,it should switch to  agda-mode or  agda2-mode. If not, you can switch manuallyby invoking one of the following (in Emacs, of course):  M-x agda-mode or  M-x agda2-mode or  Esc-x agda-mode. (An easy way to find out which agdamodes are available is to type  M-x agda and then hit tab a couple of times tosee the possible completions.)</p><p>就这样！现在，当您启动Emacs并使用。agda扩展，应切换至agda模式或agda2模式。如果没有，您可以通过调用以下选项之一（当然是在Emacs中）手动切换：M-x agda模式或M-x agda2模式或Esc-x agda模式。（找到可用AGDAMODE的一个简单方法是键入M-x agda，然后点击tab几次，查看可能的完成情况。）</p><p>     Most language tutorials start with the typical “Hello, World” example, but thisis not really appropriate for a first example in Agda. Unlike other languages,which rely on a whole lot of primitive operations and special cases for basicconstructs, Agda is very minimal - most of the “language constructs” areactually defined in libraries.</p><p>大多数语言教程都以典型的“Hello，World”示例开头，但这并不适用于Agda中的第一个示例。与其他语言不同，Agda依赖于大量的原始操作和基本构造的特殊情况，Agda非常小，大多数“语言构造”实际上都是在库中定义的。</p><p> Agda doesn’t even have numbers built in, so the first thing we’re going to do isdefine them—specifically  natural numbers. Natural numbers are nonnegativeintegers, that is, the whole numbers starting with zero and goingup. Mathematics uses the symbol $\N$ to represent natural numbers, so we’re goingto borrow that for our example (Another thing that sets Agda apart from otherlanguages is its extensive use of unicode to make mathematical constructs morenatural). To enter ℕ into emacs, type  \bn. To enter the unicode arrow (→),type  \-&gt;. I’m going to demonstrate this line by line, so bear with me.</p><p>Agda甚至没有内置数字，所以我们要做的第一件事就是定义它们，特别是自然数。自然数是非负整数，也就是以零和goingup开头的整数。数学使用符号$\N$来表示自然数，因此我们将借用它作为例子（Agda与其他语言不同的另一个特点是它广泛使用unicode，使数学构造更自然）。进入ℕ 在emacs中，键入\bn。输入unicode箭头(→),键入\-&gt；。我将一行一行地演示这一点，请耐心听我说。</p><p>   The  data keyword means we’re defining a type—in this case,  ℕ.In this example, we’re specifying that the type  ℕ is of type  Set (that’swhat the colon means).</p><p>data关键字表示我们在本例中定义了一个类型，ℕ.在本例中，我们指定ℕ 是Set类型（冒号的意思）。</p><p>   If you recall the introduction, I mentioned that in Agda, types and values aretreated the same way. Since values are given types, typesare given types as well. Types are merely a special group of language terms, andin Agda, all terms have types.</p><p>如果您还记得介绍的话，我提到在Agda中，类型和值的处理方式是相同的。因为值是给定的类型，所以类型也是给定的类型。类型只是一组特殊的语言术语，在Agda中，所有术语都有类型。</p><p> Even  Set (the type of our type  ℕ) has a type:  Set₁, which has a type Set₂, going on all the way up to infinity. We’ll touch more on what these Set types mean later, but for now you can think of  Set as the type we giveto all the data types we use in our program.</p><p>甚至设置（我们的类型）ℕ) 有一种类型：Set₁, 哪个有一套字体₂, 一直到无穷远。稍后我们将进一步讨论这些集合类型的含义，但现在您可以将集合视为我们在程序中使用的所有数据类型的类型。</p><p> This infinite hierarchy of types provides an elegant resolution of  Russell’s Paradox.For example,  Set₁ cannot contain  Set₁ or  Set₂, only  Set, so Russell’sproblematic set (that contains itself) cannot exist.</p><p>这种类型的无限层次结构为罗素悖论提供了一个优雅的解决方案。例如，设置₁ 不能包含集合₁ 还是设定₂, 只有集合，所以罗素的问题集合（包含自身）不可能存在。</p><p>   Okay, so, we’ve defined our type, but now we need to fill the type withvalues. While a type with no values does have its uses, a natural numbers typewith no values is categorically wrong. So, the first natural number we’ll defineis zero:</p><p>好的，我们已经定义了类型，但是现在我们需要用值填充类型。虽然没有值的类型确实有它的用途，但没有值的自然数类型是绝对错误的。所以，我们要定义的第一个自然数是零：</p><p>  Here we are simply declaring the term  zero to be a member of our new type ℕ. We could continue to define more numbers this way:</p><p>在这里，我们只是宣布零这个术语是我们新类型的一个成员ℕ. 我们可以继续这样定义更多的数字：</p><p>  But we’d quickly find our text editor full of definitions and we’d be no closerto defining all the natural numbers than when we started. So, we should insteadrefer to a strict mathematical definition.</p><p>但是，我们很快就会发现我们的文本编辑器中充满了定义，而且我们定义所有自然数的速度也不会比我们开始时快。所以，我们应该引用一个严格的数学定义。</p><p> For any natural number $n$, $n + 1$ is also a natural number. For convenience,We shall refer to $n + 1$ as $\mathtt{suc}\ n.$  1($\forall n \in \mathbb{N}.\ \mathtt{suc}\ n \in \mathbb{N}$).</p><p>对于任何自然数$n$，$n+1$也是一个自然数。为方便起见，我们将$n+1$称为$\mathtt{suc}\n.$1（$\forall n\in\mathbb{n}.\\mathtt{suc}\n\in\mathbb{n}$）。</p><p> (The notation I’m using here should befamiliar to anyone who knows set theory and/or first-order logic. Don’t panicif you don’t know these things, we’ll be developing models for similar things inAgda later, so you will be able to pick it up as we go along.)</p><p>（我在这里使用的符号应该对任何了解集合论和/或一阶逻辑的人都很熟悉。不要惊慌。如果你不了解这些东西，我们将在AGDA中为类似的东西开发模型，这样你就可以在我们继续的过程中学习。）</p><p> This is called an  inductive definition of natural numbers. We call it inductive because it consists of a  base rule, where we define a fixedstarting point, and an  inductive rule that, when applied to an element of theset,  induces the next element of the set. This is a very elegant way to defineinfinitely large sets. This way of defining natural numbers was developed by amathematician named Giuseppe Peano, and so they’re called the Peano numbers.</p><p>这被称为自然数的归纳定义。我们称之为归纳，是因为它由一个基本规则和一个归纳规则组成，在这个基本规则中，我们定义了一个固定的起点，而归纳规则应用于集合中的一个元素时，会归纳出集合中的下一个元素。这是一种非常优雅的定义大集合的方式。这种定义自然数的方法是由一位名叫朱塞佩·皮亚诺（Giuseppe Peano）的数学学家发明的，因此它们被称为皮亚诺数。</p><p> We will look at inductive  proof in the coming sections, which shares a similar structure.</p><p>在接下来的章节中，我们将研究归纳证明，它具有相似的结构。</p><p> For the base case, we’ve already defined zero to be in $\mathbb{N}$ by saying: zero : ℕ. To define the natural numbers inductively, let’s recall theinduction step of first order logic. This can be written as follows:</p><p>对于基本情况，我们已经在$\mathbb{N}$中定义了零，方法是：零：ℕ. 为了归纳地定义自然数，让我们回顾一下一阶逻辑的诱导步骤。这可以写如下：</p><p>  $\forall n \in \mathbb{N}.\ \mathtt{suc}\ n \in \mathbb{N}$ Given a natural number  n, the constructor  suc will returnanother natural number. In other words,  suc could be considered a function that, when given a natural number, produces the next naturalnumber. In Agda, we define the constructor  suc like so:</p><p>$\forall n\in\mathbb{n}.\\mathtt{suc}\n\in\mathbb{n}$给定一个自然数n，构造函数suc将返回另一个自然数。换句话说，suc可以被认为是一个函数，当给定一个自然数时，它会产生下一个自然数。在Agda中，我们这样定义构造函数suc：</p><p>  Now we can express the number one as  suc zero, and the number two as  suc (suczero), and the number three as  suc (suc (suc zero)), and so on.</p><p>现在我们可以将数字1表示为suc zero，将数字2表示为suc（suczero），将数字3表示为suc（suc（suc zero）），依此类推。</p><p>     If you load that into GHCi and ask it what the type of  Suc is, it(unsurprisingly) will tell you:  Nat -&gt; Nat. This is a good way to get anintuition for how to define constructors in Agda.</p><p>如果您将其加载到GHCi中，并询问它Suc的类型，它（毫不奇怪）会告诉您：Nat-&gt；纳特。这是学习如何在Agda中定义构造函数的好方法。</p><p> Also, GHC supports an extension, Generalized Algebraic Data Types or GADTs,which allows you to define data types Agda style:</p><p>此外，GHC还支持一个扩展，即广义代数数据类型或GADT，它允许您定义Agda样式的数据类型：</p><p>  It’s worth noting that GADTs are not exactly the same as Agda data definitions,and Haskell is still not dependently typed, so much of what you learn in thisbook won’t carry over directly to extended Haskell.</p><p>值得注意的是，GADT与Agda数据定义并不完全相同，Haskell仍然不是依赖于类型的，因此您在本书中学到的很多内容不会直接延续到扩展的Haskell。</p><p>   Now we’re going to define some arithmetic operations on our naturalnumbers. Let’s try addition, first.</p><p>现在，我们将对自然数定义一些算术运算。让我们先试试加法。</p><p>  Here I’m declaring a function. To start with, I give it a type  2—it takestwo natural numbers, and returns a natural number.</p><p>我在这里声明一个函数。首先，我给它一个类型2，它接受两个自然数，然后返回一个自然数。</p><p>   Unlike Haskell which has only prefix functions (ordinary functions) and infixfunctions (operators), Agda supports  mixfix syntax. This allows you to declarefunctions where the arguments can appear anywhere within a term. You useunderscores to refer to the “holes” where the arguments are meant to go.</p><p>与Haskell不同，它只有前缀函数（普通函数）和InfixFunction（运算符），Agda支持mixfix语法。这允许您声明参数可以出现在术语中任何位置的函数。你可以用下划线来指代论点的“漏洞”。</p><p>   This can be used with great flexibility: You can call this function with  if athen b else c, which Agda interprets as  if_then_else_ a b c. This syntacticflexibility delivers great expressive power, but be careful about using it toomuch, as it can get very confusing!</p><p>这可以非常灵活地使用：你可以用if-athen b else c调用这个函数，Agda将其解释为if_-then_else_uuB c。这种语法灵活性提供了强大的表达能力，但要小心过度使用，因为它可能会让人非常困惑！</p><p>    _+_ : ℕ → ℕ → ℕ zero + m = m (suc n) + m = suc (n + m)</p><p>_+_ : ℕ → ℕ → ℕ 零+m=m（suc n）+m=suc（n+m）</p><p> Normally we’d run the program at this point to verify that it works, but in Agdawe  check our code. This checks that all our  proof obligations have been met:</p><p>通常情况下，我们会在此时运行程序，以验证它是否有效，但在Agdawe中，请检查我们的代码。这将检查我们的所有证明义务是否已得到履行：</p><p> It checks your types. Types are how you encode proofs in Agda (although wehaven’t done any non-trivial proofs yet), so this is important.</p><p>它会检查你的类型。类型是在Agda中对证明进行编码的方式（尽管我们还没有做任何非琐碎的证明），所以这一点很重要。</p><p> Proof obligations of a program can only be machine-checked if the programterminates, but checking that any program terminates is in generalundecidable (see  The Halting Problem).To circumvent this dilemma, Agda runs its checker only on  structural recursionwith finite data structures, and warns that it can’t check proof obligations inwhich non-structural recursion is used. We will discuss this more in latersections, but all of the examples in the early part of this tutorial canbe proved by Agda to terminate.</p><p>程序的证明义务只能在程序终止时进行机器检查，但检查任何程序是否终止通常是不可判定的（请参阅停止问题）。为了避免这种困境，Agda只在有限数据结构的结构递归上运行它的检查器，并警告它不能检查使用非结构递归的证明义务。我们将在后面的章节中对此进行更多讨论，但Agda可以证明本教程早期的所有示例都是终止的。</p><p>  module LearnYouAn where data ℕ : Set where zero : ℕ suc : ℕ → ℕ _+_ : ℕ → ℕ → ℕ zero + m = m (suc n) + m = suc (n + m)</p><p>模块LearnYouAn数据在哪里ℕ : 设置为零：ℕ suc：ℕ → ℕ _+_ : ℕ → ℕ → ℕ 零+m=m（suc n）+m=suc（n+m）</p><p> Make sure you get the indentation right! In particular, the constructorsfor  zero and  suc start in the 5thcolumn (below the t in  data), whereas all three lines in the definition of _+_ begin in column 3.</p><p>确保缩进正确！特别是，zero和suc的构造函数从第5列开始（数据中t的下方），而+u定义中的所有三行都从第3列开始。</p><p> To check the program, type  C-c C-l in Emacs (or choose Load from the Agdamenu). If your program checks correctly, there will be no error messages, no hole markers(yellow highlighting) and no orange-highlighted non-terminating sections. Also,the words  (Agda: Checked) should appear in the Emacs mode line, and you shouldnotice that the colors of characters have changed.</p><p>要检查程序，请在Emacs中键入C-C-l（或从Agdamenu中选择Load）。如果程序检查正确，则不会出现错误消息、孔标记（黄色高亮显示）和橙色高亮显示的非终止部分。此外，单词（Agda:Checked）应该出现在Emacs模式行中，您应该注意到字符的颜色已经改变。</p><p> Right now, our checks aren’t all that meaningful—the only thing they prove isthat our addition function does indeed take any natural number and produce anatural number, as the type suggests. Later on, when we encode more informationin our types, our checks can mean a lot more—even more than running andtesting the program.</p><p>现在，我们的检查并没有那么有意义。他们证明的唯一一件事是，我们的加法函数确实可以接受任何自然数，并产生一个自然数，正如类型所示。后来，当我们在类型中编码更多信息时，我们的检查可能比运行和测试程序意味着更多。</p><p>   To evaluate an expression (just to verify that it truly does work), we can type C-c C-n into emacs, or select “Evaluate term to normal form” from the Agdamenu. Then, in the minibuffer, we can type an expression for 3 + 2:</p><p>要计算一个表达式（只是为了验证它是否真的有效），我们可以在emacs中键入C-C-n，或者从agdamnus中选择“将术语计算为标准形式”。然后，在minibuffer中，我们可以为3+2输入一个表达式：</p><p>    In this section we have examined the Peano natural numbers, and defined somebasic functions and data types in Agda. In the next section, we’ll look atpropositional logic, and how to encode logical proofs in Agda using this system.</p><p>在本节中，我们研究了Peano自然数，并在Agda中定义了一些基本函数和数据类型。在下一节中，我们将介绍命题逻辑，以及如何使用该系统在Agda中编码逻辑证明。</p><p>   If you are having trouble getting the First program to work, make sure you havethe indentation right. It might help to download the LearnYouAn.agda file, just to be sure.</p><p>如果第一个程序无法运行，请确保缩进正确。下载LearnYouAn可能会有所帮助。agda文件，只是为了确定。</p><p>     Now that we’ve defined the natural numbers, we’re going to do some simpleexample proofs of some basic mathematical properties. We’ll first discuss logicand logic specification in  natural deduction, and as we go, we’ll discuss theapplication to Agda.</p><p>现在我们已经定义了自然数，我们要做一些简单的例子来证明一些基本的数学性质。我们将首先讨论自然演绎中的逻辑和逻辑规范，接下来，我们将讨论Agda的应用。</p><p> At a fundamental level, a logic is a system of  judgments. Judgments arestatements in a mathematical  language that may be proven, or unproven. A language is usually described as a set of strings, which make up every  termin the language, but this is a simplification: a language can be made up ofarbitrary data structures. We just use strings to represent these structuresbecause any data structure can be represented in some string form.</p><p>从根本上讲，逻辑是一个判断系统。判断是数学语言中可能被证明或未被证明的陈述。一种语言通常被描述为一组字符串，这些字符串构成了该语言的每个术语，但这是一种简化：一种语言可以由任意数据结构组成。我们只使用字符串来表示这些结构，因为任何数据结构都可以用字符串形式表示。</p><p> For our example, we will define a very simple logic based on the language of natural numbers $\mathbb{N}$ we used earlier.</p><p>在我们的例子中，我们将基于前面使用的自然数$\mathbb{N}$语言定义一个非常简单的逻辑。</p><p> We’re going to have just one type of judgment, of the form $\mathbb{N}\\textbf{even}$, which is provable only when the given number is even.</p><p>我们只需要一种类型的判断，形式为$\mathbb{N}\\textbf{偶数}$，只有当给定的数字是偶数时才可以证明。</p><p> A logic consists of a set of  axioms and a set of  rules. Axioms are thefoundation of the logic: they’re the basic, simple statements that are assumedto be true.  Rules describe how to produce new  theorems from existing ones.A theorem is a proposition that has been proved. Thus, the rules tell us how toconstruct proofs of statements using proofs of other statements. We canformally specify these axioms and rules in a  meta-logic called  naturaldeduction, by writing them in the form of  inference rules, which look like this:</p><p>逻辑由一组公理和一组规则组成。公理是逻辑的基础：它们是基本的、简单的、被认为是正确的陈述。规则描述了如何从现有的定理中产生新的定理。定理是一个已被证明的命题。因此，规则告诉我们如何使用其他语句的证明来构造语句的证明。我们可以通过将这些公理和规则以推理规则的形式写入名为naturaldeduction的元逻辑中，从而正式指定这些公理和规则，如下所示：</p><p> This says that if we can prove all of the  premises $P_1 \cdots P_n$, then wecan prove the  conclusion $C$.</p><p>这就是说，如果我们能证明所有的前提$P_1\cdots P_n$，那么我们就能证明结论$C$。</p><p> For our purposes, we have just one axiom, that the number zero is even. Axiomsare written as inference rules with no premises:</p><p>出于我们的目的，我们只有一条公理，那就是零是偶数。公理是作为推理规则编写的，没有前提：</p><p> Then, based</p><p>然后，基于</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/学习/">#学习</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/learn/">#learn</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/agda/">#agda</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>