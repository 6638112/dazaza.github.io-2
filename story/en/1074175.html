<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Shard manager：地理分布应用程序的碎片管理框架Shard manager: A shard management framework for geo-distributed applications</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Shard manager: A shard management framework for geo-distributed applications<br/>Shard manager：地理分布应用程序的碎片管理框架</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 12:13:16</div><div class="page_narrow text-break page_content"><p>This is one of the last papers I’m writing about from SOSP - I am trying out something new and publishing the queue of papers I plan on reading  here. These paper reviews can  be delivered weekly to your inbox, or you can subscribe to the  Atom feed. As always, feel free to reach out on  Twitter with feedback or suggestions!</p><p>这是我在SOSP上写的最后几篇论文之一——我正在尝试一些新的东西，并在这里发布我计划阅读的论文队列。这些论文评论可以每周发送到你的收件箱，也可以订阅Atom订阅源。一如既往，请随时在Twitter上发表反馈或建议！</p><p>  This week’s paper is  Shard Manager: A Generic Shard Management Framework for Geo-distributed Applications. The research describes a framework developed by Facebook for running  sharded applications at scale.</p><p>本周的论文是Shard Manager：一个用于地理分布应用程序的通用Shard管理框架。这项研究描述了Facebook为大规模运行分片应用程序开发的框架。</p><p> Application sharding   In the context of Shard Manager.  assigns subsets of requests to instances of an application, allowing tasks to specialize - a group of tasks specialized for a subset of requests is called a  shard.</p><p>在Shard Manager的上下文中进行应用程序分片。将请求子集分配给应用程序实例，允许任务进行专门化——为请求子集专门化的一组任务称为碎片。</p><p> This approach is particularly useful when tasks fetch state or other metadata. As an example, a speech recognition application may load machine learning models to process languages. Assigning requests for different languages to different shards means that an application’s tasks don’t need to download every model (which would be time and bandwidth-intensive).</p><p>当任务获取状态或其他元数据时，这种方法特别有用。例如，语音识别应用程序可以加载机器学习模型来处理语言。将不同语言的请求分配给不同的切分意味着应用程序的任务不需要下载每个模型（这会占用大量时间和带宽）。</p><p> The Shard Manager paper not only discusses the technical aspects of running a sharding system at scale, but also includes data on usage and adoption inside Facebook. The paper’s information about which features were critical for users inside Facebook could help future efforts prioritize    @rakyll has a great article about a potential implementation. .</p><p>Shard Manager论文不仅讨论了大规模运行分片系统的技术方面，还包括Facebook内部的使用和采用数据。该报关于Facebook内部哪些功能对用户至关重要的信息可能有助于未来的工作优先化@rakyll有一篇关于潜在实现的伟大文章。</p><p>  The Shard Manager paper makes five main contributions: analysis of sharding usage at Facebook, design and implementation of the sharding system, a domain-specific language for defining sharding constraints, a constraint solver to place shards inside Facebook’s data centers, analysis of sharding usage at Facebook, and an evaluation of the system in production.</p><p>Shard Manager论文有五个主要贡献：分析Facebook上的分片使用情况、分片系统的设计和实现、定义分片约束的特定领域语言、将分片放入Facebook数据中心的约束解算器、分析Facebook上的分片使用情况，并对生产中的系统进行了评估。</p><p>  The paper notes three main motivations for implementing Shard Manager:  increasing availability,  supporting geo-distributed applications, and  improved load balancing.</p><p>本文指出了实现Shard Manager的三个主要动机：提高可用性、支持地理分布应用程序和改进负载平衡。</p><p> To  increase availability, Shard Manager aims to smoothly handle planned data center maintenance   Facebook recently published a paper on their cluster manager,  Twine  - if a container stops while processing user requests, those requests will fail, impacting the availability of the application. For the vast majority of containers, Facebook’s infrastructure knows in advance that the container is shutting down. Shard Manager aims to smoothly handle these shutdown events by coordinating with the container infrastructure, ensuring that to-be-shutdown containers stop receiving requests, and that requests that do make it to a shutting down container are forwarded to another active instance.</p><p>为了提高可用性，Shard Manager旨在顺利处理计划中的数据中心维护Facebook最近在其群集管理器Twine上发表了一篇论文——如果容器在处理用户请求时停止，这些请求将失败，影响应用程序的可用性。对于绝大多数容器，Facebook的基础设施提前知道容器正在关闭。Shard Manager的目标是通过与容器基础设施协调来顺利处理这些关闭事件，确保待关闭的容器停止接收请求，并确保发送到关闭容器的请求被转发到另一个活动实例。</p><p>  The second major motivator for Shard Manager is enabling  geo-distributed applications (an approach to independently deploying and scaling application shards). Before Shard Manager, services were primarily configured with  regional deployments - to operate at Facebook scale, applications need to run in groups of datacenters called  regions, with similar configurations in each region. For a sharded application, this meant reserving enough resources to serve every shard in every region, even if the shards weren’t needed - this constraint led to wasted data center resources. Furthermore,  regional deployments were unwieldy in the event of data center or region maintenance, as other regions might not have the spare capacity to store additional copies of every shard.</p><p>Shard Manager的第二个主要动力是支持地理分布的应用程序（一种独立部署和扩展应用程序碎片的方法）。在Shard Manager之前，服务主要通过区域部署进行配置——为了在Facebook规模上运行，应用程序需要在称为区域的数据中心组中运行，每个区域的配置类似。对于分片应用程序，这意味着保留足够的资源来服务于每个区域的每个分片，即使不需要这些分片——这种限制导致了数据中心资源的浪费。此外，在数据中心或区域维护的情况下，区域部署非常笨拙，因为其他区域可能没有多余的容量来存储每个碎片的额外副本。</p><p>  Improved load balancing is the third main motivation for Shard Manager.  Geo-distributed applications can flexibly add and shift shards independently, simplifying the process of shifting load - rather than needing to make a copy of every shard, the system can add or move specific shards. At the same time, deciding when and how to place shards is a difficult optimization problem that Shard Manager needed to address.</p><p>改进的负载平衡是Shard Manager的第三个主要动机。地理分布应用程序可以独立灵活地添加和移动碎片，简化了转移负载的过程——系统不需要复制每个碎片，而是可以添加或移动特定的碎片。同时，决定何时以及如何放置碎片是碎片管理器需要解决的一个困难的优化问题。</p><p>   A critical piece of a sharding framework is assigning requests to shards. Shard Manager uses client-provided keys, called  app-keys, to perform this mapping - continuing with the language server example, requests for English are sent to X shard, while requests for German and Mandarin might be sent to Y and Z shards.</p><p>切分框架的一个关键部分是将请求分配给切分。Shard Manager使用客户端提供的密钥（称为应用密钥）来执行此映射——继续语言服务器示例，对英语的请求发送到X Shard，而对德语和普通话的请求可能发送到Y和Z Shard。</p><p> The paper also discusses another approach, called  UUID-keys, that map requests to shards based on  hashes of keys provided by clients.</p><p>本文还讨论了另一种称为UUID密钥的方法，该方法基于客户端提供的密钥散列将请求映射到碎片。</p><p> There are pros and cons to using  app-keys versus  UUID-keys, mostly based around data-locality - in the context of shard manager, data-locality means that similar data, potentially from related users or regions of the world, is placed on the same or nearby shards. The paper argues that  app-keys provide data-locality, while  UUID-keys do not.</p><p>与UUID密钥相比，使用应用程序密钥有其利弊，UUID密钥主要基于数据局部性——在shard manager的上下文中，数据局部性意味着相似的数据（可能来自世界上相关的用户或地区）被放置在相同或附近的碎片上。本文认为，应用程序密钥提供数据位置，而UUID密钥不提供数据位置。</p><p> Data locality would enable features like sequentially scanning multiple shards when performing a query. At the same-time, data locality could increase the potential for hot-spots, where reads of similar data all go to the same shard. Previous approaches to sharding frameworks, like Slicer   See the paper on Slicer  here. , mention adding support for an  app-key like approach to preserve data locality, but mention that, “many Google applications are already structured around single-key operations rather than scans, encouraged by the behavior of existing storage systems.”</p><p>数据局部性将支持在执行查询时顺序扫描多个碎片等功能。同时，数据局部性可能会增加热点的可能性，在热点中，相似数据的读取都会进入同一个碎片。以前的切分框架方法，如Slicer，请参阅此处关于Slicer的文章，提到添加了对类似应用程序键的方法的支持，以保留数据的局部性，但提到“由于现有存储系统的行为，许多谷歌应用程序已经围绕单键操作而不是扫描构建。”</p><p>  There are three main components of the Shard Manager architecture:  application clients/servers, a  control plane    Control plane is used because it is the layer that performs management and metadata storage operations. , and the  Cluster Manager.</p><p>Shard Manager体系结构有三个主要组件：应用程序客户端/服务器，使用控制平面控制平面，因为它是执行管理和元数据存储操作的层，以及集群管理器。</p><p>  Application servers are the actual binaries that operate shards and receive requests from clients. Each server has a library that allows it to manage shard state (like reporting server health), register/deregister the shard from receiving requests, and hook into shard management events. When a shard performs management operations, it writes state to Zookeeper   It would be interesting to hear if Shard Manager considered adopting  Delos, a system for storing control plane data discussed in a previous paper review. , a persistent data store.</p><p>应用服务器是实际的二进制文件，用于操作碎片并接收来自客户端的请求。每台服务器都有一个库，允许它管理碎片状态（如报告服务器运行状况），注册/取消注册碎片接收请求，并连接到碎片管理事件。当碎片执行管理操作时，它会将状态写入Zookeeper。如果碎片管理器考虑采用Delos，这将是一个有趣的消息。Delos是一个存储控制平面数据的系统，在之前的论文综述中讨论过，持久数据存储。</p><p> To call an  application server, an  application client uses a library (called a  Service Router). The client’s  Service Router routes requests based on an  app-key (which defines the mapping from request to shard), selecting an available shard based on state the library consumes from a service discovery   See this article on  service discovery for more background.  system. The  Service Router periodically polls in the background to receive updates as shards are added, removed, and scaled.</p><p>要调用应用程序服务器，应用程序客户端使用库（称为服务路由器）。客户端的服务路由器根据应用程序密钥（定义从请求到碎片的映射）路由请求，并根据库在服务发现中使用的状态选择可用碎片。有关更多背景信息，请参阅本文中的服务发现。系统随着碎片的添加、删除和缩放，服务路由器会定期在后台轮询以接收更新。</p><p>  Orchestrator: an intermediary component that receives health and load information from application servers. It shares this data with other members of the control plane (like the components that schedule and scale shards), and propagates it to the  Service Discovery System so that application clients have an updated view of the system.</p><p>Orchestrator：从应用服务器接收运行状况和负载信息的中间组件。它与控制平面的其他成员（如调度和缩放碎片的组件）共享此数据，并将其传播到服务发现系统，以便应用程序客户端拥有系统的更新视图。</p><p>  TaskController: commmunicates with the  Cluster Manager to request more resources (when scaling shards up) or to receive system events, like pending maintenance (which the  Task Controller uses to shutdown shards gracefully). The  TaskController propagates this information to the  Orchestrator so that it can fulfill the job of shutting down application servers and shards gracefully.</p><p>TaskController：与群集管理器通信以请求更多资源（在扩展碎片时）或接收系统事件，如挂起的维护（任务控制器使用它来优雅地关闭碎片）。TaskController会将此信息传播到Orchestrator，以便它能够优雅地完成关闭应用程序服务器和碎片的工作。</p><p> Lower in the infrastructure stack is the  Cluster Manager   For more information on the Cluster Manager, see the  Twine paper. , which communicates with the  TaskController above to ensure that planned events, like “upcoming hardware maintenance events, kernel updates, and container starts/stops/moves” are handled gracefully, increasing application availability.</p><p>基础结构堆栈的下方是群集管理器。有关群集管理器的更多信息，请参阅夹绳纸，它与上面的TaskController通信，以确保计划中的事件（如“即将到来的硬件维护事件、内核更新和容器启动/停止/移动”）得到妥善处理，从而提高应用程序可用性。</p><p>  The paper discusses how Shard Manager features aim to  increase application availability and  supporting geo-distributed applications, while  scaling the system.</p><p>本文讨论了Shard Manager功能如何在扩展系统的同时提高应用程序可用性和支持地理分布应用程序。</p><p>  Shard Manager implements two main techniques   The paper also mentions shard distribution across fault domains (like multiple regions and data centers) as increasing availability, but I defer discussion of shard distribution to placement and load balancing.  to increase application availability:  coordinating container shutdown with the Cluster Manager, and  migrating shard traffic.</p><p>Shard Manager实现了两种主要技术本文还提到了跨容错域（如多个区域和数据中心）的碎片分布，以提高可用性，但我将碎片分布的讨论推迟到布局和负载平衡。提高应用程序可用性：与群集管理器协调容器关闭，并迁移碎片流量。</p><p> Coordinating container shutdown is critical to increasing availability because it ensures requests are not sent to a container that might shutdown while responding. Shard Manager must also ensure that planned maintenance events don’t take too much capacity offline at once (which would leave the application in a state where it is unable to respond to all incoming requests). To prevent both of these situations, Shard Manager’s  TaskController communicates with the  Cluster Manager, removing imminently decommissioning shards from service discovery and launching new shards as others prepare to go offline. If it is not possible to shift shards in anticipation of maintenance, the the  Task Controller can warn the  Cluster Manager that the proposed operations would put an application in an unsafe state.</p><p>协调容器关闭对于提高可用性至关重要，因为它可以确保请求不会发送到可能在响应时关闭的容器。Shard Manager还必须确保计划的维护事件不会一次离线占用太多容量（这会使应用程序处于无法响应所有传入请求的状态）。为了防止这两种情况，Shard Manager的TaskController与群集管理器进行通信，从服务发现中删除即将停用的碎片，并在其他人准备脱机时启动新的碎片。如果无法在维护之前转移碎片，任务控制器可以警告集群管理器，建议的操作将使应用程序处于不安全状态。</p><p> Shard Manager also supports  migrating shard traffic by implementing a graceful handover procedure. This process forwards in-progress requests from the old to new shard, ensuring that as few as possible are dropped on the floor. The system’s traffic migration also aims to handoff any new requests from application clients, who may continue to send requests to the old shard - the service discovery system is eventually consistent   See  this blog post from Amazon’s Werner Vogels on eventual consistency. , so clients may temporarily use out-of-date routing state.</p><p>Shard Manager还通过实现优雅的切换过程来支持迁移Shard流量。这个过程将正在进行的请求从旧的碎片转发到新的碎片，确保尽可能少的碎片掉到地板上。该系统的流量迁移还旨在切换来自应用程序客户端的任何新请求，这些客户端可能会继续向旧的碎片发送请求——服务发现系统最终是一致的。请参阅亚马逊的沃纳·沃格尔（Werner Vogels）关于最终一致性的这篇博文，因此，客户端可能会暂时使用过时的路由状态。</p><p>   Geo-distributed applications allow shards to be deployed independently to Facebook’s infrastructure around the world. While the technique provides several benefits, like independent scaling of individual shards, it also poses its own challenges - choosing how to place shards and when to move them is a difficult optimization problem. To solve the optimization problems associated with placement and load balancing, Shard Manager uses a  constraint solver, configurable with a dedicated language for expressing  constraints.</p><p>地理分布应用程序允许将碎片独立部署到Facebook全球的基础设施中。虽然这项技术提供了一些好处，比如独立缩放单个碎片，但它也带来了自身的挑战——选择如何放置碎片以及何时移动碎片是一个困难的优化问题。为了解决与布局和负载平衡相关的优化问题，Shard Manager使用了一个约束解算器，该解算器可配置专用语言来表达约束。</p><p> Shard Manager originally used a heuristic-based implementation to make load balancing decisions, which proved both complicated and difficult to scale. As a result, the system migrated to a constraint solver   The paper mentions a number of optimization techniques, including  mixed integer programming (MIP), genetic algorithms, and  simulated annealing. I’m far from an expert in this type of research, so this could be a potential topic for a future paper review. .</p><p>Shard Manager最初使用基于启发式的实现来做出负载平衡决策，这既复杂又难以扩展。因此，系统迁移到约束求解器。本文提到了许多优化技术，包括混合整数规划（MIP）、遗传算法和模拟退火。我远不是这类研究的专家，所以这可能是未来论文评论的潜在主题。</p><p> The inputs to the solver are  constraints and  goals - example constraints are system stability or server capacity, while example goals are load balancing across regions (to increase resource utilization) or spreading replicas across multiple data centers (to increase availability in the event of a problem with a specific data center).</p><p>解算器的输入是约束和目标——示例约束是系统稳定性或服务器容量，而示例目标是跨区域的负载平衡（以提高资源利用率）或跨多个数据中心分发副本（以在特定数据中心出现问题时提高可用性）。</p><p>  An application configures its placement and load balancing using a domain-specific language   There is some very interesting and related research from VMWare on programmatically configuring cluster managers  Building Scalable and Flexible Cluster Managers Using Declarative Programming.  that translates into a form that a constraint solver can use. Even though Facebook has a high-powered constraint solver for data center problems   The paper links to another Facebook paper from SOSP on  RAS: Continuously Optimized Region-Wide Datacenter Resource Allocation. , Shard Manager made further optimizations   The paper mentions  Local Search, which “has grown from a simple heuristic idea into a mature field of research in combinatorial optimization that is attracting ever-increasing attention.”  to scale for its the high request rate.</p><p>应用程序使用特定于域的语言配置其位置和负载平衡VMWare对以编程方式配置群集管理器进行了一些非常有趣且相关的研究，使用声明式编程构建可扩展且灵活的群集管理器。这转化为约束解算器可以使用的形式。尽管Facebook有一个针对数据中心问题的高效约束求解器，该论文还是链接到了SOSP在RAS上的另一篇Facebook论文：持续优化的区域范围数据中心资源分配，Shard Manager进行了进一步的优化该论文提到了局部搜索，它“已经从一个简单的启发式思想发展成为一个在组合优化中吸引越来越多关注的成熟研究领域。”以适应其高请求率。</p><p>   Partitions: Each application is divided into many partitions, “where each partition typically comprises thousands of servers and hundreds of thousands of shard replicas.”</p><p>分区：每个应用程序被划分为多个分区，“每个分区通常由数千台服务器和数十万个碎片副本组成。”</p><p> mini-Shard Managers (mini-SM), which are essentially copies of an individual shard manager  control plane (mentioned in a previous section). Each  mini-SM handles a subset of servers and shards.</p><p>mini Shard manager（mini SM），本质上是单个Shard manager控制平面的副本（在上一节中提到）。每个迷你SM处理服务器和碎片的子集。</p><p>  The scale-out   “Scale-out” in this context means adding more  mini-Shard Managers to cover more machines, as trying to make a single Shard Manager cover many machines would be difficult  version of Shard Manager also adds several new components including a  frontend that serves as a balancer for communication with external systems (like the  Cluster Manager and tooling),  Application Managers that handle coordination of an application’s partitions over multiple mini-SMs, and a  partition registry that  Application Managers communicate with to get assignments of application partitions to mini-SMs.</p><p>在这种情况下，横向扩展“横向扩展”意味着添加更多的迷你碎片管理器以覆盖更多的机器，由于试图让单个Shard Manager覆盖多台机器会很困难，Shard Manager的版本还添加了几个新组件，包括充当与外部系统（如群集管理器和工具）通信的平衡器的前端，应用程序管理器通过多个迷你SMs处理应用程序分区的协调，以及应用程序管理器与之通信以将应用程序分区分配给迷你SMs的分区注册表。</p><p>  Shard Manager aims to provide support for as many sharded applications inside Facebook as possible, and provides data points what was critical to driving adoption. The paper argues for the importance of features in two areas that align with project’s motivation:  increasing availability and  geo-distributed deployments.</p><p>Shard Manager旨在为Facebook内尽可能多的分片应用程序提供支持，并提供数据点，这些数据点对推动采用至关重要。本文论证了与项目动机一致的两个方面的功能的重要性：提高可用性和地理分布部署。</p><p> Many applications that migrated to Shard Manager take advantage of its  availability features, in particular around handling planned events - “70% of SM applications choose to gracefully drain shards before a container restart.”</p><p>许多迁移到Shard Manager的应用程序都利用了它的可用性功能，尤其是在处理计划事件方面——“70%的SM应用程序选择在容器重启之前优雅地排空碎片。”</p><p>  The paper also notes similarly high-adoption of  geo-distributed applications - 67% of sharded applications using Shard Manager use  geo-distributed deployments.</p><p>论文还指出，地理分布应用程序的采用率也很高——使用Shard Manager的分片应用程序中有67%使用地理分布部署。</p><p>   The paper evaluates Shard Manager using three criteria: whether the system succeeds at scale, whether it is able to achieve the original goals of increasing application availability and supporting geo-distributed applications, and whether Shard Manager can adequately solving the optimization problems to load-balance.</p><p>本文使用三个标准评估Shard Manager：系统是否在规模上成功，是否能够实现提高应用程序可用性和支持地理分布应用程序的原始目标，以及Shard Manager是否能够充分解决负载平衡的优化问题。</p><p> To evaluate scale, Shard Manager shows the number of applications, shards, and mini-SMs, demonstrating that the architecture is able to scale out as needed:</p><p>为了评估规模，Shard Manager显示了应用程序、碎片和迷你短信的数量，表明该体系结构能够根据需要进行扩展：</p><p> In total, SM manages hundreds of applications’ nearly 100M shards hosted on over one million servers, and those applications process billions of requests per second. SM gracefully handles millions of machine and network maintenance events per month.</p><p>SM总共管理数百个应用程序的近1亿个碎片，这些碎片托管在100多万台服务器上，这些应用程序每秒处理数十亿个请求。SM每月优雅地处理数以百万计的机器和网络维护事件。</p><p>  To evaluate availability, Shard Manager shows that applications using graceful migration show fewer spikes of failed requests relative to those that use no graceful migration strategy. The paper also shows how shard upgrades do not cause an increase in client error rate.</p><p>为了评估可用性，Shard Manager显示，与不使用优雅迁移策略的应用程序相比，使用优雅迁移的应用程序显示的失败请求峰值更少。本文还展示了碎片升级如何不会导致客户端错误率的增加。</p><p>   To evaluate load balancing, the paper shows migrating shards to reduce network latency and load balancing over a changing environment and request rate.</p><p>为了评估负载平衡，本文展示了在不断变化的环境和请求速率下迁移碎片以减少网络延迟和负载平衡。</p><p>  Lastly, the paper shows how the improved constraint solver is able to solve constraints at a much faster rate than the baseline solver - in fact, the original baseline solver isn’t able to complete.</p><p>最后，本文展示了改进的约束求解器如何以比基线解算器快得多的速度求解约束——事实上，原始基线解算器无法完成。</p><p>   The  Shard Manager paper details an impressive at scale production system, while sharing data points that will be useful to future implementers of sharding frameworks. I particuarly enjoyed how the paper discussed adoption and internal usecases when prioritizing development - I’ve seen this theme in a number of Facebook research papers, including Delos (which I previously covered  here) and  RocksDB. I’m also looking forward to future work from folks interested in an open source sharding framework, like the one  @rakyll outlined!</p><p>Shard Manager论文详细介绍了一个令人印象深刻的大规模生产系统，同时分享了数据点，这些数据点对sharding框架的未来实现者很有用。我特别喜欢这篇论文在优先考虑开发时如何讨论采用和内部用例——我在许多Facebook研究论文中看到过这个主题，包括Delos（我之前在这里讨论过）和RocksDB。我也期待着对开源切分框架感兴趣的人将来的工作，比如@rakyll概述的那个！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/manager/">#manager</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/shard/">#shard</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/应用程序/">#应用程序</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>