<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>以地鼠的身份学习铁锈，第三部分</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">以地鼠的身份学习铁锈，第三部分</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-03 17:21:17</div><div class="page_narrow text-break page_content"><p>Hello and welcome to the third post in my series about learning Rust. In case you want to hit it from the start,  here’s a link to the first one! This entire series covers my journey from being a completely land-locked Gopher to becoming (hopefully) a hardened Rustacean, able to skitter the hazardous seabed of any application safely.</p><p>大家好，欢迎阅读我的“学习生锈”系列文章的第三篇。如果您想从一开始就点击它，这里有一个指向第一个的链接！这整个系列涵盖了我的旅程，从一个完全封闭在陆地上的地鼠，变成(希望如此)一只老练的Rustacean，能够安全地掠过任何应用程序的危险海床。</p><p> Warning: Incoming opinion monologue; feel free to skip to  The Lesson Review review if that’s what you’re after</p><p>警告：即将到来的观点独白；如果你想要的是复习功课，请随时跳到复习复习。</p><p>  Let me begin not by thwacking loosely about in concepts I know little yet of, as there’s plenty of time for that, but instead allow me to paint the landscapes I see for both Rust and Go. At quite the visceral it occurred to me that these modern languages are built not just to make our coding lives more delightful - but instead to shepherd us into particular engineering and organizational goals.</p><p>让我开始不要在我还不太了解的概念上松散地思考，因为有足够的时间来做这件事，而是允许我画出我看到的铁锈和Go的风景。在相当发自内心的时候，我意识到这些现代语言的构建不仅是为了让我们的编程生活更愉快，而且是为了引导我们实现特定的工程和组织目标。</p><p> The needs for new general purpose languages no longer stem from the “simple” software problems. Take the problems of using variables (Assembly), using custom data types (C), cross-platform, cross-architecture compatibility (JVM languages) or even being dead simple (Python). Today’s languages can instead choose features from all the preceding and  then apply engineering and organizational direction.</p><p>对新的通用语言的需求不再源于“简单的”软件问题。以使用变量(Assembly)、使用自定义数据类型(C)、跨平台、跨架构兼容性(JVM语言)甚至是非常简单(Python)的问题为例。今天的语言可以从前面的所有功能中选择功能，然后应用工程和组织方向。</p><p>  I’ve been writing in Go as a hobby since 2014 but professionally only since 2018. As a hobbyist I’ll admit I used to think “Go is  opinionated”. That seemed cool, because opinions mean something! Right? But  why was it opinionated Levi, WHY? WAKE UP MAN!</p><p>自2014年以来，我一直把围棋作为一种爱好写东西，但直到2018年才开始专业写作。作为一个业余爱好者，我承认我曾经认为“围棋是固执己见的”。这看起来很酷，因为意见是有意义的！对吗？但是为什么它会固执己见，为什么呢？醒醒，伙计！</p><p> Well today I have a completely different look on it. Go is simply a language that is very  safe to share across engineers. This is because engineers don’t need to make a lot of decisions when they use Go. If an application has had its design completed in theory then in Go it often really is just a matter of whacking out the code to make it a reality.</p><p>今天我对它有了完全不同的看法。围棋只是一种在工程师之间共享非常安全的语言。这是因为工程师在使用围棋时不需要做很多决定。如果一个应用程序在理论上已经完成了它的设计，那么实际上它通常只是一个敲打代码来使其成为现实的问题。</p><p> Just look at how much of Go’s development tooling Google owns. With Java, I remember choosing between Ant or Maven for your build tooling. Go doesn’t let you chose. The closest we got to having a choice was with  dep for dependency management. But finally Google caved and  gomod was brought about as the standard. Go does its best to take choices away from you. You don’t need to chose between Tomcat or Jetty - the Go  net/http package will handle 10kRPS for you no problem. Hell I’ve looked at apps serving 50kRPS, whilst  logging a third of said requests simply using  fmt.Println. You just don’t need to stray far from the standard library to scale and that is a huge plus of the language. (A large part of this is also comes from the fact that webservers haven’t changed a heck of a lot in the past 10 years so Go didn’t have to “keep up” - on the other hand my experience with http2 in Go has been far from ideal).</p><p>看看谷歌拥有多少Go开发工具就知道了。使用Java时，我记得在构建工具中选择Ant或Maven。围棋不让你选择。我们最接近的选择是依赖关系管理的dep。但最终谷歌屈服了，gomod成为了标准。围棋会尽最大努力剥夺你的选择。您不需要在Tomcat或Jetty之间进行选择-Go Net/http包将为您处理10kRPS，没有问题。见鬼，我看过服务于50kRPS的应用程序，而仅使用fmt.Println就记录了三分之一的请求。您只需远离标准库即可扩展，这是该语言的一个巨大优势。(这在很大程度上也是因为在过去的10年里，网络服务器并没有改变太多，所以围棋不必“跟上”--另一方面，我在围棋中使用http2的体验远非理想)。</p><p>  This is by far the biggest selling point of using Go  in a company. If you need to hire help you can find basically  anyone with backend experience, and they will pick up 90% of Go in a week or two. You don’t need to worry at all if they have experience with Struts, JUnit or Spring - what’s in the standard library is plenty. I mean it. Do they need to know about passing pointers or values? Not really - general software engineering practices like peer review and simple unit testing will uncover those types of issues with ease.</p><p>这是到目前为止在公司使用Go的最大卖点。如果你需要雇佣帮手，你基本上可以找到任何有后台经验的人，他们会在一到两周内拿到90%的围棋。如果他们有使用Struts、JUnit或Spring的经验，您完全不需要担心-标准库中的内容已经很多了。我是认真的。他们需要知道如何传递指针或值吗？并非如此-一般的软件工程实践，如同行评审和简单的单元测试，可以很容易地发现这些类型的问题。</p><p> Now on the other hand - who in their right mind would hire  me to join their Rust team right now? Nobody - because I would be a gigantic liability to that team.</p><p>另一方面，现在谁还会雇佣我加入他们的铁锈团队呢？没有人-因为我会是那支球队的巨大负担。</p><p> Go’s purpose is for dev shops to crank out web services that are scalable, easy to develop and do not require mission critical performance.</p><p>Go的目的是让开发人员开发出可伸缩、易于开发且不需要关键任务性能的Web服务。</p><p>   I’m a noob. 100%. But even so, in my feeble mind I can already see what Rust is. I see a very sharp knife; but this knife is completely and utterly shrouded and encased in tamper-proof, child-proof, thief-proof hardened and sealed plastic shells. Yes shells as in the plural of shell. These shells are even adult-proof too, where the adult is a generic engineer trained generally in other languages only. The compiler is the packaging, and it will let you wield the knife when it knows exactly what your action plan is. -But oh no, not just any plan will do, your plan  must adhere to each and every rule and regulation from the Knife Safety Measurement Act of 1938 and its associated amendments!! (This may not be strictly true as I’ve heard about an  unsafe keyword).</p><p>我是个菜鸟。100%。但即便如此，在我虚弱的脑海里，我已经明白了什么是铁锈。我看到了一把非常锋利的刀，但这把刀完全地、完全地被包裹在防篡改、防儿童、防盗、硬化和密封的塑料外壳中。是的，shell，就像shell的复数形式一样。这些外壳甚至也是成人专用的，成人是一名普通工程师，一般只接受过其他语言的培训。编译器就是包装，当它确切地知道您的行动计划时，它会让您挥舞这把刀。-但是，哦，不，不是任何计划都可以，你的计划必须遵守1938年《刀具安全测量法》及其相关修正案中的每一项规则和规定！！(这可能不是严格意义上的，因为我听说过一个不安全的关键字)。</p><p> But why so much plastic broseidon? You know, and I know that it’s to keep mild-minded people like myself exactly, from nicking fingers with that very sharp knife. Warping back to a meta-level, those fingers don’t even necessarily belong to me the coder, but to the end users of the code. It is no secret to anybody even slightly interested in Rust that a major driving factor for the language was to be able to replace C++ code with something  as efficient but much less susceptible to security exploits. Thus, the safety plastic aims not to protect individual coders, but the  coding organization.</p><p>但是为什么会有这么多塑料布洛赛登呢？你知道，我知道这是为了防止像我这样心地温和的人，不被那把非常锋利的刀划伤手指。回到元级别，这些手指甚至不一定属于我这个程序员，而是属于代码的最终用户。对于任何对Rust感兴趣的人来说，这都不是什么秘密，这种语言的一个主要驱动因素是能够用同样高效但不太容易受到安全漏洞攻击的东西来替换C++代码。因此，安全塑料的目的不是保护个人编码员，而是保护编码组织。</p><p> Okay, you’ve probably heard enough of my opinion, let’s move on before this analogy implodes and actually hurts someone.</p><p>好了，你可能已经听够了我的观点，在这个比喻崩溃并真正伤害到某人之前，让我们继续前进吧。</p><p>    One of the first ‘huh’ moments in this lesson was this compiler message:</p><p>本课中最先让人大吃一惊的时刻之一是这条编译器消息：</p><p>  Naturally I ran the command listed, which took me to a  less window (buffer?) containing the following:</p><p>很自然地，我运行了列出的命令，这会将我带到一个较少的窗口(Buffer？)。包含以下内容：</p><p> An immutable variable was reassigned.Erroneous code example:&#39;&#39;&#39;fn main() { let x = 3; x = 5; // error, reassignment of immutable variable}&#39;&#39;&#39;By default, variables in Rust are immutable. To fix this error, add the keyword`mut` after the keyword `let` when declaring the variable. For example:&#39;&#39;&#39;fn main() { let mut x = 3; x = 5;}&#39;&#39;&#39;</p><p>重新指定了不可变变量。错误代码示例：&#39；&#39；&#39；&#39；&#39；&#39；&#39；&#39；&#39；&#39；默认情况下，Rust中的变量是不可变的。要修复此错误，请在声明变量时在关键字`let`后添加关键字`mu`。例如：&#39；&#39；&#39；fn main(){设mut x=3；x=5；}&#39；&#39；&#39；</p><p> &amp;mldrand this slightly let me down. There isn’t a whole lot of information in this “explanation”. I proceeded to allow  rustc to “explain” some more random error codes to me, most of them seemed also to be quite small or to have been deprecated. I am hoping either A) I don’t have to use this feature much or B) I can make rustc/cargo/intellij just tell me the detailed stuff by default.</p><p>这让我有点失望(&amp；mldrand)。这个“解释”里没有太多的信息。我继续让rustc向我“解释”更多的随机错误代码，其中大多数似乎也相当小或已被弃用。我希望要么是A)我不需要经常使用这个功能，要么B)我可以创建rustc/Cargo/IntelliJ，默认情况下只需告诉我详细信息即可。</p><p>   For some reason this irked me when I first saw it (the comment taken verbatim from my lesson notes). On second look it actually seems really, really helpful for readability.</p><p>由于某种原因，当我第一次看到它时，这让我很恼火(这条评论是从我的课堂笔记中逐字摘录的)。仔细一看，它似乎真的对可读性真的很有帮助。</p><p>   This seems like a really handy trick. You get to write code as if your variable was immutable, but the compiler does the switching for you. What is really messing my head up though is that you learn about Shadowing before you learn about Ownership. So does my naive understanding of shadowing change after this? I don’t think so &amp;mldr at least. Here’s something I wrote to verify my learnings:</p><p>这看起来是个很方便的把戏。您可以编写代码，就好像您的变量是不可变的一样，但是编译器会为您进行切换。然而，真正让我头晕目眩的是，你在了解所有权之前就已经了解了影子。那么，在这之后，我对影子的天真理解是否改变了呢？我不这么认为&至少我不这么认为。这是我写的一些东西来验证我的学习：</p><p> fn  main ()   {    let   mut   s   =   String:: from ( &#34;hello&#34; );    let   r1   =   &amp; mut   s ;    let   r1   =   &amp; mut   s ;    println ! ( &#34;{}&#34; ,   r1 );   }</p><p>Fn main(){let mut s=string：：from(&#34；hello&#34；)；let r1=&amp；mut s；let r1=&amp；mut s；println！(&#34；{}&#34；，r1)；}。</p><p> &amp;mldrand it works. It also answers a question I had when originally learning ownership. For some reason when reading the examples in the book I came away thinking Rust could infer when immutable references&#39; scopes end, but not mutable ones. I was puzzled by this and had a follow-up item but this little example proves I was wrong. Happy days!</p><p>&amp；mldrand它起作用了。它还回答了我最初学习所有权时的一个问题。由于某种原因，当我读到书中的例子时，我想Rust可以推断出不可变引用的结束时间，但不能推断出可变引用的结束时间。我对此感到困惑，并有一个后续项目，但这个小例子证明我错了。快乐的日子！</p><p>   The  Invalid array element access example didn’t work - it was supposed to produce a runtime error but instead it failed to compile:</p><p>无效的数组元素访问示例不起作用-它本应产生运行时错误，但却无法编译：</p><p> Compiling   variables   v0 . 1.0   ( / home / levi / rustprojs / variables )   error:  this   operation   will   panic   at   runtime    --&gt;  src / main . rs: 5: 19    |   5   |   let   element   =   a [ index ];    |   ^^^^^^^^   index   out   of   bounds:  the   len   is   5   but   the   index   is   10    |    =   note:  ` #[deny(unconditional_panic)] `   on   by   default</p><p>编译变量V0。1.0(/home/levi/rustprojs/Variables)错误：此操作将在运行时死机--&gt；src/main。RS：5：19|5|设element=a[index]；|^index出界：镜头为5，索引为10|=备注：`#[DENY(无条件_PARGIC)]`默认开启。</p><p> I don’t even know if I should call this a nit or just straight up be impressed. Did Rust  evolve to the point the  book can no longer trick me into making a runtime panic?! This is some straight-jacket level packaging I swear to god. Much applause.</p><p>我甚至不知道我是应该称这为“Nit”，还是应该直截了当地说“印象深刻”。铁锈是不是进化到了这本书再也不能欺骗我制造运行时恐慌的地步了？！我向上帝发誓，这是个直夹克级别的包装。热烈的掌声。</p><p>   Having picked up many a good pointer during this lesson I figured I had bumped myself up a couple of notches. Maybe white-belt, double-yellow-tip or something along those lines&amp;mldr “ Let’s go for a wander” I thought to myself with quiet confidence. Looking left, and then looking right, under the shelter of a single raised eye-brow I chose to descend toward the belly of Rust.</p><p>在这节课中拿到了许多好的指针后，我想我已经把自己提升了几个档次。也许是白腰带、双黄尖端或类似的东西&mldr“我们去散散步吧”我心平气和地想。我先向左看，然后向右看，在一条扬起的眉毛的掩护下，我选择向铁锈的肚子走去。</p><p>  I chose a simple avenue. I chose something concrete to all beginners. I chose the pinnacle of  Hello_World&amp;mldr</p><p>我选择了一条简单的道路。我选择了一些对所有初学者来说都很具体的东西。我选择了Hello_World&amp；mldr的巅峰。</p><p>  &amp;mldr and dive I did. Straight into the ground after clanking my head into a hard iron post of this macro. My eyes but glimpsed Sauron directly and from then on and always, I am blind:</p><p>&amp；mldr和俯冲我做到了。当我的头撞到这个宏硬的铁柱后，我直接撞到了地上。我的眼睛却直接瞥见了索伦，从那以后，我一直是瞎子：</p><p> #[macro_export]   #[stable(feature =  &#34;rust1&#34; , since =  &#34;1.0.0&#34; )]   #[allow_internal_unstable(print_internals, format_args_nl)]   macro_rules !   println   {    ()   =&gt;   ( $crate:: print ! ( &#34;\n&#34; ));    ( $($arg: tt ) * )   =&gt;   ({    $crate:: io:: _print ( $crate:: format_args_nl ! ( $($arg ) * ));    })   }</p><p>#[MACRO_EXPORT]#[STRATE(FEATURE=&#34；RUST1&#34；，SING=&#34；1.0.0&#34；)]#[ALLOW_INTERNAL_USTRATE(PRINT_INTERNAL，FORMAT_ARGS_NL)]MACRO_RULES！Println{()=&gt；($crate：：print！(&#34；\n&#34；))；($($arg：tt)*)=&gt；({$crate：：IO：：_print($crate：：format_args_nl！($($arg)*)；})}。</p><p> What in God’s sweet name is this acrid assault on all of my senses?</p><p>看在上帝的份上，这对我所有感官的辛辣攻击到底是什么？</p><p> I am going to be honest here. There is no way in hell I will understand this macro by the end of my twentieth lesson. Will I?I’m not sure actually. I guess there’s hope? Chapters  10,  14 and  19 all look they will be mandatory.  Hoping Intensifies &amp;mldr ?</p><p>我在这里要说实话。见鬼，我不可能在第二十课结束前理解这个宏图。我会吗？实际上我不太确定。我想还有希望吧？第10章、第14章和第19章看起来都将是强制性的。希望强化&&amp；mldr？</p><p>   If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value. Keep this in mind as you explore function return values and expressions next.</p><p>如果在表达式末尾添加分号，则会将其转换为语句，然后该语句将不返回值。当您接下来探索函数返回值和表达式时，请记住这一点。</p><p> This was a mind fuck - about 10 minutes before reading this I thought to myself that semi-colons seemed optional and kind of pointless in rust. Boy was I well outside the woods.</p><p>这是一种他妈的思维-大约在阅读这篇文章的10分钟前，我对自己说，分号似乎是可选的，在生锈的情况下有点毫无意义。孩子们，我在树林外面很远的地方。</p><p> A later thought did have me wondering though; do Rustaceans really just write expressions at the end of their getter functions or is it more common to explicitly  return?</p><p>不过，后来的一个想法确实让我想知道：Rustaceans真的只是在其getter函数的末尾编写表达式，还是显式返回更常见？</p><p>   In Rust, the idiomatic comment style starts a comment with two slashes, and the comment continues until the end of the line. For comments that extend beyond a single line, you’ll need to include // on each line, like this:</p><p>在Rust中，惯用的注释样式以两个斜杠开始注释，注释一直持续到行尾。对于超过一行的注释，您需要在每行包含//，如下所示：</p><p> What’s weird is that  /* */ style comments are clearly supported - I tried it after reading this. The entire Comments sub-lesson doesn’t make  any mention of them though? I’m guessing this has something to do with the  idiomatic qualifier the authors used. If this  is the case then that’s fine, I’d just like to know who defines the idioms and better yet, point me to the Rust Idioms Bible. In Go we have  effective Go.</p><p>奇怪的是，/**/样式注释被明确支持-我在读完这篇文章后尝试了一下。但是，整个评论子课没有提到它们吗？我猜这与作者使用的惯用限定词有关。如果是这样的话那很好，我只想知道是谁定义了这些成语，更好的是，给我指给我看“生锈成语圣经”。在围棋中，我们有有效的围棋。</p><p> I guess it occurs to me now that this very book could  be the Bible I’m faffling about&amp;mldr.  But even then I still think it should mention  /**/’s and why we shouldn’t used them&amp;mldr</p><p>我想，现在我突然想到，这本书可能就是我正在胡思乱想的那本“圣经”。但即便如此，我仍然认为它应该提到/**/，以及为什么我们不应该使用它们&&和mldr。</p><p>   One thing you see mentioned a lot about Rust when you’re new is the ownership checker, so I was very happy to finally reach a chapter showing me something really novel. By the way, if you’re still with me then congratulations - you have the patience of a bullfrog.</p><p>当你是新手的时候，你会看到很多关于Rust的事情，那就是所有权检查，所以我很高兴终于有一章向我展示了一些非常新奇的东西。顺便说一句，如果你还和我在一起，那么恭喜你--你有牛蛙般的耐心。</p><p> Now I’ll start this chapter off by saying I was tricked about strings.</p><p>现在我要开始这一章，先说我在弦上被耍了。</p><p> The book really led me to believe there are literally two types of strings in Rust, which I personally thought was a very ballsy move on Rust’s part. Only over the next thirty minutes did the authors mercifully reveal to me that there is but ONE  String! The “special” string literals are really just some sugar over an immutable string slice reference. Ultimately I kind of felt duped by this but I guess if people aren’t familiar with slices and references etc then maybe this teaching approach makes sense.</p><p>这本书真的让我相信“铁锈”中确实有两种弦，我个人认为这对“铁锈”来说是一个非常大胆的举动。只是在接下来的30分钟里，作者才仁慈地告诉我，只有一根绳子！“特殊的”字符串字面值实际上只是在不可变的字符串片引用上加了一些糖。归根结底，我觉得自己被这一点欺骗了，但我想，如果人们不熟悉切片和参考资料等，那么也许这种教学方法是有意义的。</p><p> Ultimately though, in a kind of anti-climactic bust, this chapter was actually quite uneventful for my rusty brain. (Hey; I’ve been living with terrible Go puns since forever ok!) There were only two things from the chapter in which I wanted to know more about. The first is Traits, oh my goodness these sound intriguing - I’ll be patient for this though. The second was from this tidbit in the  introduction:</p><p>最终，在一种反高潮的半身像中，这一章对我生锈的大脑来说实际上是相当平淡无奇的。(嘿；我一直生活在可怕的围棋双关语中，好吧！)。在这一章中，我只有两件事想要更多地了解。第一个是特点，哦，天哪，这些听起来很有趣--不过我会有耐心的。第二个来自于引言中的这个花絮：</p><p> With the String type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:</p><p>对于字符串类型，为了支持可变的、可增长的文本片段，我们需要在堆上分配一定数量的内存(编译时未知)来保存内容。这意味着：</p><p> We need a way of returning this memory to the allocator when we’re done with our String.</p><p>当我们处理完字符串时，我们需要一种将该内存返回给分配器的方法。</p><p> That first part is done by us: when we call String::from, its implementation requests the memory it needs. This is pretty much universal in programming languages.</p><p>第一部分由我们完成：当我们调用String：：From时，它的实现请求它所需的内存。这在编程语言中几乎是通用的。</p><p> &amp;mldrI just wish the book told me a bit more, i.e. does  String make a libc malloc call or does it just make a new slice and the comiler has its own behind the scenes memory layer? I’m 90% sure this will  need to become clearer later in order to write good Rust code, which is in stark contrast with Go where have little-to-no control over heap vs stack allocations (and subsequently it doesn’t pay off very well to know or rely on how the runtime allocator works as this has always been subject to change too).</p><p>&amp；mldr我只是希望这本书能告诉我更多信息，即字符串是进行libc malloc调用，还是只是做了一个新的切片，而搅拌器有自己的幕后内存层？我90%肯定这一点稍后需要变得更清楚，以便编写好的Rust代码，这与Go形成鲜明对比，在Go中，对堆和堆栈分配几乎没有控制权(因此，知道或依赖运行时分配器的工作方式不会有很好的回报，因为这也总是会发生变化)。</p><p> This is definitely something I could just dive into  String to check out for myself but for the sake of this blog series and my own time each night, I’m largely restricting my explorations to what the book is teaching me verbatim for the minute.  Also remember what Sauron did to my eyes with  println!</p><p>这绝对是我可以自己深入了解的东西，但为了这个博客系列和我每晚自己的时间，我在很大程度上将我的探索限制在这本书一分钟一字不变地教给我的内容上。还记得索伦用普林特恩对我的眼睛做了什么吗？</p><p>  To cap-off a double-chapter post here, I think the lessons were solid. The scariness of  immutable variables by default is subsiding as I learn some of the patterns for dealing with them. Taking a step back it is nice to have a language introduce the concepts of the stack and heap at such an early stage, I re-read the  C book about a year ago and I don’t even think those concepts were mentioned in it!? In fact the last programming book I read that went deep on these concepts was the fantastic  RISC-V Assembly Language book. So yeah, Rust is clearly setting the table well in advance for young crabbies.</p><p>在这里结束一篇双篇章的帖子，我认为教训是扎实的。默认情况下，不可变变量的恐惧正在消退，因为我了解了一些处理它们的模式。退一步说，在这么早的阶段就有一种语言引入堆栈和堆的概念是很好的，大约一年前我重读了那本C语言书，我甚至不认为里面提到了这些概念！？事实上，我读的最后一本深入研究这些概念的编程书籍是奇妙的RISC-V汇编语言书籍。所以，是的，拉斯特显然是提前为年轻的克拉比准备了餐桌。</p><p> I’m really, really looking forward to unpacking the next lessons from the  Rust book and hope that you’re enjoying the journey with me. As usual I greatly appreciate any guidance and corrections in the comments, until next time Gophers and Rustaceans, Nofo a (Byebye)!</p><p>我真的，真的很期待从“铁锈”这本书中解开下一课，希望你和我一起享受这段旅程。像往常一样，我非常感谢评论中的任何指导和更正，直到下一次地鼠和Rustaceans，Nofo a(再见)！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://levpaul.com/posts/rust-lesson-3-and-4/">https://levpaul.com/posts/rust-lesson-3-and-4/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/身份/">#身份</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1032933.html"><img src="http://img2.diglog.com/img/2020/11/thumb_0803f67b2dea838dffa8a2a38c7afff6.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032933.html">Scipio：适用于Rust和Linux的每核线程机箱</a></div><span class="my_story_list_date">2020-11-3 14:45</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032908.html"><img src="http://img2.diglog.com/img/2020/11/thumb_be7c5ac7c26fb279aed5af0ebbacaf23.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032908.html">OX是一个用Rust编写的快速文本编辑器，可以在您的终端上运行</a></div><span class="my_story_list_date">2020-11-3 12:4</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032258.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032258.html">古物鉴定师的铁锈</a></div><span class="my_story_list_date">2020-10-30 19:30</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032252.html"><img src="http://img2.diglog.com/img/2020/10/thumb_32a6a18f6a7b3db994451021b6994b68.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032252.html">铁锈网到了吗？是的，而且它跑得太快了</a></div><span class="my_story_list_date">2020-10-30 18:37</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>