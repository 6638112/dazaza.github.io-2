<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>CockroachDB与Scylla基准测试 CockroachDB vs. Scylla Benchmark</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">CockroachDB vs. Scylla Benchmark<br/>CockroachDB与Scylla基准测试 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-22 04:56:30</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/dba7ea1245fd4ac305da7bcd31651f2c.png"><img src="http://img2.diglog.com/img/2021/1/dba7ea1245fd4ac305da7bcd31651f2c.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The database space has always been a complicated field that introduced many options and tradeoffs. Two particular classes of databases, NoSQL and NewSQL, have been most recently pitted against each other in the industry. However, both terms were  coined long ago. These two families of databases offer expanded capabilities beyond traditional databases. They also often overlap so that today the boundaries are even more blurred as more new database implementations are born.</p><p>数据库空间一直是一个复杂的领域，引入了许多选项和折衷方案。在业界，最近有两类特殊的数据库NoSQL和NewSQL相互对立。但是，这两个术语是很久以前创造的。这两个数据库家族提供了超越传统数据库的扩展功能。它们也经常重叠，因此随着更多新数据库实现的诞生，今天的边界变得更加模糊。</p><p> In this article, we compare what we consider the best of breed in NoSQL versus the best in class in NewSQL. Admittedly biased, we selected ourselves for NoSQL. For NewSQL, we chose CockroachDB. The latter represents distributed SQL, the segment which represents not only the SQL API but also the distributed relational database model.</p><p> 在本文中，我们将在NoSQL中同类最佳的与在NewSQL中同类最佳的进行比较。诚然有偏见，我们选择了NoSQL。对于NewSQL，我们选择了CockroachDB。后者代表分布式SQL，该段不仅代表SQL API，而且代表分布式关系数据库模型。</p><p> Obviously, the comparison is of the apples and oranges type. We expect Scylla will be faster — providing lower latencies and greater throughputs — while CockroachDB should have stronger consistency and be friendlier to use with its SQL interface. Our goal was to put forward a rational analysis and put a price tag on the differences in workloads that could be addressed by the two databases. So we won’t cover SQL JOINs which are supported by CockroachDB alone and we won’t cover timeseries workloads where Scylla has a clear design advantage.</p><p> 显然，比较是苹果和橘子类型的。我们希望Scylla会更快-提供更低的延迟和更大的吞吐量-而CockroachDB应该具有更强的一致性并且更友好地与其SQL接口一起使用。我们的目标是提出合理的分析并为两个数据库可以解决的工作量差异定价。因此，我们不会涵盖仅由CockroachDB支持的SQL JOIN，也不会涵盖Scylla具有明显设计优势的时间序列工作负载。</p><p>   CockroachDB (CRDB) was built from the ground up to support global OLTP workloads while maintaining high availability and strong consistency. It is based on ideas from  Google Spanner [ whitepapers] [ 2012-GDD] [ 2017-TT] [ 2017-SQL] (and  F1). Cockroach Labs, the company that supports it, was founded in 2014.</p><p>   CockroachDB（CRDB）是从头开始构建的，以支持全球OLTP工作负载，同时保持高可用性和强一致性。它基于Google Spanner的想法[白皮书] [2012-GDD] [2017-TT] [2017-SQL]（和F1）。支持它的公司Cockroach Labs成立于2014年。</p><p> Scylla has likewise been under development since 2014. It was modeled after Apache Cassandra and Amazon DynamoDB, supporting API compatibility for both.</p><p> Scylla自2014年以来也一直在开发中。它以Apache Cassandra和Amazon DynamoDB为模型，支持两者的API兼容性。</p><p>  Scylla is a wide-column distributed NoSQL database that uses an eventual consistency model to provide fast and efficient reads and writes along with multi-datacenter high availability.</p><p>  Scylla是一个宽列的分布式NoSQL数据库，它使用最终的一致性模型来提供快速有效的读取和写入以及多数据中心的高可用性。</p><p> In Scylla all nodes are equal: there are no leaders, followers, or replica sets. And there is no single point of failure; client applications can interact with any node in the cluster. This allows Scylla to scale linearly to many nodes without performance degradation and overhead costs.</p><p> 在Scylla中，所有节点都是相等的：没有领导者，关注者或副本集。而且没有单点故障。客户端应用程序可以与集群中的任何节点进行交互。这使Scylla可以线性扩展到许多节点，而不会降低性能和开销。 </p><p>  Scylla is a Cassandra rewrite in C++, however, the performance gains arrive from its radical, asynchronous, shard-per-core design and its desire to achieve full control of the entire resource allocation and execution.</p><p>Scylla是用C ++进行的Cassandra重写，但是，性能的提高源于其激进的，异步的，按内核划分的设计以及对完全控制整个资源分配和执行的渴望。</p><p> The computing model is completely async with futures and promises and has its own task switching mechanism, developed in order to run a million continuations (lambda functions) per second per core. In a high performance database, control is even more important than efficiency. Scylla makes every computation and IO operation belong to a priority class. Its CPU and IO schedulers control the execution of all continuations. Latency sensitive classes such as read and write operations are given a higher, dynamic priority over background tasks such as compaction, repair, streaming, etc.</p><p> 计算模型与期货和承诺完全不同步，并且具有自己的任务切换机制，该机制的开发目的是每个内核每秒运行一百万个连续性（lambda函数）。在高性能数据库中，控制比效率甚至更重要。 Scylla使所有计算和IO操作都属于优先级类别。它的CPU和IO调度程序控制所有延续的执行。与诸如压缩，修复，流式传输等后台任务相比，对延迟敏感的类（如读写操作）具有更高的动态优先级。</p><p> Scylla makes sure the OS does not play its traditional role by pinning threads to cores, memory to shards nor overload the filesystem/disks with IO beyond their capacity. Compaction controllers measure the compaction debt and dynamically set the compaction priority. Thus compaction control, which makes Log Structured Merge (LSM) trees complicated, is a solved problem with Scylla. More on the thread-per-core approach can be found  here, and on  seastar.io, our application framework. These capabilities to precisely control resource utilization are behind another unique feature of Scylla:  workload prioritization, where different workloads can have different priorities, permitting OLTP and OLAP (driven by Presto/Spark) workloads to co-exist running simultaneously in the same cluster on the same hardware.</p><p> Scylla通过将线程固定在核心上，将内存固定在分片上，或用超出其容量的IO重载文件系统/磁盘，来确保操作系统不会发挥其传统作用。压实控制器测量压实债务并动态设置压实优先级。因此，压缩控制使Log Structured Merge（LSM）树变得复杂，这是Scylla解决的问题。可以在这里以及我们的应用程序框架seastar.io上找到更多有关每核线程方法的信息。这些精确控制资源利用率的功能是Scylla另一个独特功能的背后：工作负载优先级，其中不同的工作负载可以具有不同的优先级，允许OLTP和OLAP（由Presto / Spark驱动）工作负载在服务器上同一集群中同时运行并存。相同的硬件。</p><p>  Scylla uses an eventual consistency model. Many workloads do not require strong consistency guarantees while they do require availability. For example, during partitioning, an isolated datacenter should continue to accept reads and writes. Scylla has an API for stronger consistency using lightweight transactions (LWT).</p><p>  Scylla使用最终的一致性模型。许多工作负载在需要可用性时并不需要强大的一致性保证。例如，在分区期间，隔离的数据中心应继续接受读取和写入。 Scylla具有使用轻量级事务（LWT）增强一致性的API。</p><p> Scylla can even be tuned per transaction, so that you can state the desired level of consistency. Do you just want the transaction to succeed if even one node acknowledges a read or write (a consistency level of 1, or CL=1)? If so, the rest of the nodes will be caught up in due time. Or do you want a majority of replica nodes to acknowledge a read or write (CL=QUORUM, LOCAL_QUORUM, ..)? Or do you want every replica node to acknowledge that the transaction successfully completed (CL=ALL)?</p><p> Scylla甚至可以针对每个事务进行调整，以便您可以声明所需的一致性级别。您是否只希望即使一个节点也承认读或写（一致性级别为1或CL = 1），事务也能够成功？如果是这样，其余的节点将在适当的时间赶上。还是您想让大多数副本节点确认读或写（CL = QUORUM，LOCAL_QUORUM等）？还是希望每个副本节点都确认事务已成功完成（CL = ALL）？</p><p>  In Scylla data is spread as uniformly as possible across all nodes by the means of the hash function ( partitioner) so that the load can be evenly distributed and efficiently processed by all cores in the cluster. Token ring and cluster topology configuration is shared with the clients. This makes clients aware of the nodes where data actually resides. They can efficiently choose the closest nodes that own the data and even reach the specific cpu core that handles partition within the node, minimizing extra hops and maximizing load balancing.</p><p>  在Scylla中，数据通过散列函数（分区器）尽可能均匀地分布在所有节点上，以便负载可以由群集中的所有核心平均分配并有效地进行处理。令牌环和群集拓扑配置与客户端共享。这使客户端知道数据实际所在的节点。他们可以有效地选择拥有数据的最近节点，甚至可以到达处理该节点内分区的特定cpu核心，从而最大程度地减少了额外的跃点并最大化了负载平衡。</p><p>  Clients choose the operations coordinator either randomly or as close to the target replicas as possible and send their requests. Multiple policies exist to select the coordinator with different load balancing options. The coordinator asynchronously replicates writes to the number of replicas. A user can pick the number of replicas data shall be read from. That makes request processing very predictable in terms of implied operations, IO and round trips.</p><p>  客户可以随机选择或尽可能接近目标副本的操作协调器，然后发送其请求。存在多种策略来选择具有不同负载平衡选项的协调器。协调器将写入异步复制到多个副本。用户可以选择要读取的副本数据的数量。这使请求处理在隐式操作，IO和往返方面非常可预测。 </p><p> Scylla uses a commitlog and in parallel memtable, SSTables, etc. You can read more about Scylla’s read path in  this article about our row-level cache, and more on the  write path in our documentation.</p><p>Scylla使用了一个commitlog以及并行的memtable，SSTables等。您可以在本文中了解有关Scylla的行级缓存的更多阅读路径，以及文档中的write路径。</p><p>  Scylla offers a natural RDBMS-like model when data is organized in tables that consist of rows and columns on top of the wide-column storage. A row key consists of a partition key and optionally clustering key. A clustering key defines rows ordering inside of the partition. A partition key determines partition placement.</p><p>  当数据被组织在宽列存储顶部的由行和列组成的表中时，Scylla提供了一种类似于RDBMS的自然模型。行键由分区键和可选的群集键组成。集群键定义分区内部的行顺序。分区键确定分区位置。</p><p> Users define tables schemas, insert data into rows, and then read it. There are usual concepts such as Secondary Indexes, Materialized Views, Complex Data Types, Lightweight Transactions, and other features built on top.</p><p> 用户定义表模式，将数据插入行中，然后读取它。通常有一些概念，例如二级索引，物化视图，复杂数据类型，轻量级事务以及其他基于顶部的功能。</p><p> The wide-column data model differs from the classical RDBMS-style model in that rows are not first-class citizens but the cells are. Rows consist of cells.</p><p> 宽列数据模型与经典的RDBMS样式模型的不同之处在于，行不是一等公民，而是单元格。行由单元格组成。</p><p>  Though the Scylla CQL user language can be deceptively very similar to what most of us are used to with SQL:</p><p>  尽管Scylla CQL用户语言在外观上可以与我们大多数人使用SQL时非常相似：</p><p> SELECT * FROM Table;UPDATE Table (a, b, c) VALUES (1, 2, 3) WHERE Id = 0;</p><p> SELECT * FROM表；更新表（a，b，c）值（1、2、3）Id = 0;</p><p> However, Scylla does   not provide full ACID semantics for its operations. Usually, ACID is applied to transactions but let’s take a look at what is provided for a single operation:</p><p> 但是，Scylla并未为其操作提供完整的ACID语义。通常，ACID适用于交易，但让我们看一下为单个操作提供的功能： </p><p> consistency is provided in an ACID sense that it preserves application invariants if the operations preserve them</p><p>从ACID的意义上讲，提供了一致性，如果操作保留了它们，它将保留应用程序不变式</p><p> What Scylla does not provide from an ACID perspective is  isolation. But why would you need isolation if you don’t have multi-statement cross-partition transactions? If you want to know a detailed analysis to this question, you can read the Jepsen analysis of Scylla  here — section 3.4  Normal Writes Are Not Isolated, and our accompanying post  here.</p><p> 从ACID角度来看，Scyla没有提供的是隔离。但是，如果您没有多语句跨分区事务，为什么还要隔离？如果您想对此问题进行详细的分析，可以在此处阅读Scylla的Jepsen分析—第3.4节“正常书写不孤立”，以及我们的随附文章。</p><p>   Data ordering prohibits efficient sequential primary key scanning because every partition has random placement. This limits an opportunity to make range-based JOIN operations. Even though it allows sequential local scan, it is a tradeoff that Scylla makes in order of delivering maximum performance possible out of available hardware.</p><p>   数据排序禁止有效的顺序主键扫描，因为每个分区都有随机的位置。这限制了进行基于范围的JOIN操作的机会。尽管它允许顺序进行本地扫描，但这也是Scylla做出的权衡，以便从可用硬件中提供最大的性能。</p><p> Cell-based data organization along with the timestamp non-monotonicity prevents an efficient usage of levels in LSM storage and opens an opportunity for torn row writes.</p><p> 基于单元的数据组织以及时间戳的非单调性阻止了LSM存储中级别的有效使用，并为行写入被撕毁提供了机会。</p><p> While all of the nodes in Scylla are homogenous and cluster resizing is easy, the data is sharded through key range allocations to nodes. Sharding is not transactional thus only done in a serial way and there is no software enforcement. In addition, these ranges are static once the topology is set and can result in hot shards. Our recently-announced  Project Circe is about to address these limitations.</p><p> 尽管Scylla中的所有节点都是同构的，并且集群大小调整很容易，但是通过对节点的关键范围分配来分片数据。分片不是事务性的，因此只能以串行方式完成，并且没有软件强制执行。此外，一旦设置了拓扑，这些范围就是静态的，并且可能导致碎片。我们最近宣布的Project Circe将解决这些限制。</p><p>   CockroachDB is a distributed NewSQL database built from the ground up to support global OLTP workloads while maintaining high availability and strong consistency.</p><p>   CockroachDB是从头开始构建的分布式NewSQL数据库，以支持全球OLTP工作负载，同时保持高可用性和强一致性。</p><p> It is built on the foundation of ideas that stand behind Google’s Spanner database. CockroachDB focuses on providing fully serializable ACID transactions on top of its strongly consistent highly-available distributed KV store. Its transactions are serializable and reads are linearizable from the beginning by default.</p><p> 它建立在Google Spanner数据库背后的思想基础之上。 CockroachDB专注于在其高度一致的高度可用的分布式KV存储之上提供完全可序列化的ACID事务。默认情况下，它的事务从一开始就可序列化，而读取则可线性化。 </p><p> It has a completely different design than Scylla and exploits that to serve SQL requests efficiently.</p><p>它的设计与Scylla完全不同，并且可以有效地服务SQL请求。</p><p>  CockroachDB’s primary focus is consistency, topology flexibility and SQL compatibility. It provides high availability the same way Scylla does — with redundancy, but keeps replicas consistent throughout operations. Maintaining consistency all the time implies additional overhead. However, CockroachDB uses different innovative approaches to provide high performance quality of service such as Raft with Leases, cost-free linearization, parallel two-phase commit, an innovative hybrid transactions scheduler, vectorization, in-memory data layout optimization and more. CockroachDB is written in Go and susceptible to garbage collection spikes.</p><p>  CockroachDB的主要重点是一致性，拓扑灵活性和SQL兼容性。它提供了与Scylla相同的方式提供高可用性-具有冗余性，但在整个操作过程中保持副本的一致性。始终保持一致性意味着额外的开销。但是，CockroachDB使用不同的创新方法来提供高性能的服务质量，例如带租赁的Raft，免费的线性化，并行两阶段提交，创新的混合事务调度程序，向量化，内存中数据布局优化等等。 CockroachDB用Go语言编写，容易受到垃圾回收高峰的影响。</p><p>  CockroachDB favors consistency in place of availability. It provides different options to maintain high availability and build hybrid cluster topologies. Availability is based on redundancy. Because of Raft to be available every ReplicaSet requires a quorum of its nodes to be alive. This limits availability.</p><p>  CockroachDB支持一致性而不是可用性。它提供了不同的选项来维持高可用性并构建混合集群拓扑。可用性基于冗余。由于可以使用Raft，所以每个ReplicaSet都需要一定数量的节点才能处于活动状态。这限制了可用性。</p><p>  In an architectural sense, it is very similar to Google Spanner: ordered data keyspace is split into Data Ranges or Tablets. Data range replicas are grouped into ReplicaSets. Each ReplicaSet has a dedicated leader that is determined by the consensus process. For consensus, CockroachDB uses Raft with different optimizations.</p><p>  从结构上讲，它与Google Spanner非常相似：有序数据键空间被分为数据范围或平板电脑。数据范围副本被分组为ReplicaSet。每个ReplicaSet都有一个专用的领导者，该领导者由共识过程确定。为了达成共识，CockroachDB使用Raft进行了不同的优化。</p><p>  In every ReplicaSet, there is only one dedicated node that serves reads and writes. It is called a leaseholder. Only the leaseholder can offer a write to the ReplicaSet leader. Because there always exists only one leaseholder in a group, reads that served from it are linearizable.</p><p>  在每个ReplicaSet中，只有一个专用节点为读取和写入提供服务。它被称为租赁者。只有租约持有人可以向ReplicaSet负责人写信。由于组中始终只有一个租约持有人，因此从中读取的内容可以线性化。</p><p> Now it must be clear that reads are cheap and linearizable. The writes in its turn are synchronous — the transaction coordinator always waits until all writes would be replicated before committing the transaction. Transaction commit is asynchronous though.</p><p> 现在必须清楚，读取是廉价的并且可以线性化。反过来，写入是同步的-事务协调器始终等待，直到所有写入都将被复制，然后再提交事务。事务提交是异步的。</p><p> All reads and writes in CockroachDB execute in the context of transactions. A transaction is an interactive session with respect to the ACID properties in which a client sends requests and then finalizes them with a commit or abort keyword.</p><p> CockroachDB中的所有读取和写入都在事务上下文中执行。事务是关于ACID属性的交互式会话，在该会话中，客户端发送请求，然后使用commit或abort关键字完成请求。 </p><p>  CockroachDB offers a classical relational data model with tables and rows built on top of LSM-based key-value storage. CockroachDB is wire compatible with PostgreSQL.</p><p>CockroachDB提供了一个经典的关系数据模型，其中的表和行建立在基于LSM的键值存储之上。 CockroachDB与PostgreSQL有线兼容。</p><p>  CockroachDB currently supports only one transaction execution mode: SERIALIZABLE isolation. This is good when a user needs strong isolation guarantees free of  anomalies. CockroachDB does not offer picking a weaker isolation model for higher performance.</p><p>  CockroachDB当前仅支持一种事务执行模式：SERIALIZABLE隔离。当用户需要强大的隔离保证而没有异常时，这很好。 CockroachDB不提供选择较弱的隔离模型以获得更高的性能。</p><p> To serialize transactions CockroachDB offers a parallel two-phase commit variant and a novel hybrid serialization scheduler. In the best simple case, CockroachDB is capable of committing a transaction in 1 Round Trip Time (RTT). In general, though, it requires a serialization check on every read and write and waiting that all writes were replicated. To atomically switch data visibility CockroachDB uses indirection in the read path.</p><p> 为了序列化事务，CockroachDB提供了并行的两阶段提交变体和新颖的混合序列化调度程序。在最好的简单情况下，CockroachDB能够在1个往返时间（RTT）中提交事务。通常，尽管如此，它要求对每个读取和写入进行序列化检查，并等待所有写入被复制。为了自动切换数据可见性，CockroachDB在读取路径中使用间接寻址。</p><p>   CockroachDB offers maximum flexibility on data placement policy. Users have control over how data is organized on disk (families) and how it is split and distributed across the world. The model supports independent data rebalance (instead of a ring rebalance), an independent isolated cluster topology change, and even data access control.</p><p>   CockroachDB在数据放置策略上提供了最大的灵活性。用户可以控制如何在磁盘（系列）上组织数据以及如何在世界范围内拆分和分配数据。该模型支持独立的数据重新平衡（而不是环重新平衡），独立的隔离群集拓扑更改，甚至数据访问控制。</p><p> This design approach allows CockroachDB to flexibly and seamlessly control cluster membership. Nodes can be added or removed instantly and in parallel into the cluster and they can start serving data as soon as they have the first data range replicated. Data split and rebalance occurs automatically in the background based on the load distribution and resources utilization.</p><p> 这种设计方法使CockroachDB可以灵活，无缝地控制集群成员资格。可以立即在群集中并行添加或删除节点，并且节点可以在复制第一个数据范围后立即开始提供数据。根据负载分配和资源利用率，数据拆分和重新平衡会在后台自动发生。</p><p> In data modeling, a user has great flexibility in keeping all data in an ordered fashion or randomly distributing it in the keyspace depending on his load patterns.</p><p> 在数据建模中，用户具有很大的灵活性，可以按有序方式保留所有数据，或者根据其加载方式将其随机分布在键空间中。</p><p> Data replicas are always kept in a consistent state. That gives an opportunity to compact delete tombstones in the LSM trees right away and simplifies many operations.</p><p> 数据副本始终保持一致状态。这提供了立即压缩LSM树中的删除逻辑删除的机会，并简化了许多操作。 </p><p>  Writes inside a ReplicaSet require consensus coordination and are limited in throughput in that sense. To mitigate this CockroachDB implies dynamic data ranges splitting and rebalancing.</p><p>在ReplicaSet中进行的写入需要共识协调，并且在这种意义上吞吐量受到限制。为了减轻这种情况，CockroachDB意味着动态数据范围的拆分和重新平衡。</p><p>   Reads preliminary are served only from the leaseholder nodes which means that you don’t utilize the rest of the replicas.</p><p>   初步阅读仅从租约节点提供，这意味着您不会利用其余副本。</p><p> It’s easier to miss load distribution and get hot data ranges. If load distribution is uneven hot data ranges will affect performance.</p><p> 错过负载分配并获取最新数据范围更容易。如果负载分布不均匀，那么热数据范围将影响性能。</p><p> Availability guarantees are weaker. There is an overhead implied by the language with automatic memory management.</p><p> 可用性保证较弱。自动内存管理的语言隐含了开销。</p><p>  Overall both databases are focused on different things and use different approaches to serve reads and write. However, let’s take a look at their performance.</p><p>  总体而言，两个数据库都专注于不同的事物，并使用不同的方法来提供读写服务。但是，让我们看看他们的表现。</p><p> In order to measure performance differences, we ran YCSB workloads on AWS for Scylla and CockroachDB with two datasets, with sizes of 1B and 100M keys. All clusters consisted of 3 × i3.4xlarge AWS EC2 nodes (each with 16 vCPU, 122 GiB RAM, 10GiB network, and 2 × 1.9TiB NVMe SSDs) in a single region (eu-north-1) spread across 3 availability zones (abc) with the standard replication factor (RF=3) and almost default configuration.</p><p> 为了衡量性能差异，我们在AWS上为Scylla和CockroachDB运行了YCSB工作负载，其中包含两个数据集，大小分别为1B和100M密钥。所有群集均由3个i3.4xlarge AWS EC2节点（每个节点具有16个vCPU，122个GiB RAM，10GiB网络和2个1.9TiB NVMe SSD）组成，并分布在3个可用区中的单个区域（eu-north-1）（ abc）具有标准复制因子（RF = 3）和几乎默认配置。</p><p> To measure CockroachDB performance, we used the  brianfrankcooper/YCSB 0.17.0 benchmark with PostgreNoSQL binding and CockroachDB v20.1.6 YCSB  port to the Go programming language that offers better support for this database. For Scylla 4.2.0, we used the  brianfrankcooper/YCSB 0.18.0 with a Scylla-native binding and a  Token Aware balancing policy.</p><p> 为了测量CockroachDB的性能，我们使用了带有PostgreNoSQL绑定的brianfrankcooper / YCSB 0.17.0基准测试以及将Goock编程语言的CockroachDB v20.1.6 YCSB端口提供给该数据库更好的支持。对于Scylla 4.2.0，我们使用了带有Scylla本机绑定和Token Aware平衡策略的brianfrankcooper / YCSB 0.18.0。 </p><p>  While the official CockroachDB  documentation states that the storage capacity limit is 150GiB per vCPU and up to 2.5 TB per node total, we did not manage [ #56362 with 20.1.6] [ #38778 with 20.2.0] to successfully load 1B keys into the CockroachDB cluster — for most of the trials it went unresponsive after about 3-5 hours of loading with some critical errors in the logs. A few times we observed a similar behavior during a 30 minute long sustained workload.</p><p>尽管CockroachDB官方文档指出存储容量限制为每个vCPU 150GiB，每个节点总计不超过2.5 TB，但我们并未管理[将＃56362与20.1.6] [＃38778与20.2.0]成功地加载1B密钥到CockroachDB群集-在大多数测试中，加载约3-5小时后，日志中出现一些严重错误，因此它没有响应。几次我们在持续30分钟的持续工作量中观察到了类似的行为。</p><p> Another problem was load throughput degradation from 12K TPS down to 2.5K TPS in 3-5 hours. Loading 1B keys at a rate of 2.5K keys inserted per second could take about 111 hours or 4.5 days. We decided not to wait for it. Similar issues were observed by YugaByte: [ 1B trial], [ slowdown] and [ results].</p><p> 另一个问题是负载吞吐量在3-5小时内从12K TPS下降到2.5K TPS。以每秒插入2.5K个密钥的速度加载1B密钥大约需要111个小时或4.5天。我们决定不等待它。 YugaByte也观察到类似的问题：[1B试用]，[减速]和[结果]。</p><p> We reduced the dataset size for CockroachDB to 100M. Loading took 7 hours and resulted in 1.1TB of data overall that later was compacted to 450GiB. The latency graph over this 7 hours period can be seen below.</p><p> 我们将CockroachDB的数据集大小减小到100M。加载过程耗时7个小时，最终产生了1.1TB的整体数据，后来压缩为450GiB。这7小时内的等待时间图表如下所示。</p><p>  In its turn, Scylla did well with 1B keys — Scylla loaded 4.8TB of data (before major compaction, 3.9 TB after) in about 3 hours and showed the same performance characteristics as with the smaller dataset.</p><p>  反过来，Scylla在使用1B密钥方面做得很好-Scylla在大约3个小时内加载了4.8 TB的数据（在大型压缩之前，在3.9 TB之后），并且表现出与较小数据集相同的性能。</p><p> Key Observation: Loading 10 times the data into Scylla took less than half the time it took for CockroachDB. Scylla was over 20x more efficient in initial data loading.</p><p> 关键观察：将数据加载到Scylla中的时间是10倍，不到使用CockroachDB所需时间的一半。 Scylla的初始数据加载效率提高了20倍以上。</p><p>  From YCSB’s github: “This workload has a mix of 50/50 reads and writes. An application example is a session store recording recent actions.”</p><p>  来自YCSB的github：“此工作负载包含50/50的读写操作。一个应用示例是记录最近动作的会话存储。”</p><p> Scylla showed the capability to produce 120K TPS under 60% CPU utilization with P99 latency &lt;4.6ms, and 150K TPS with P99 &lt;12ms for the 1B dataset size.</p><p> 对于1B数据集大小，Scylla显示了在60％CPU使用率下产生120K TPS的能力，P99延迟＜4.6ms，而P99 ＜12ms的150K TPS对于1B数据集大小。 </p><p>  In this Grafana diagram, taken from the Scylla Monitoring Stack dashboard, you can see that 2 clients have 600 µsec P99 latency for writes, &lt;4ms P99 latency for reads while serving 60k ops for reads and 60k ops for writes; 120K TPS in total.</p><p>在这个从Scylla Monitoring Stack仪表板获取的Grafana图中，您可以看到2个客户端的写入时延为600 µsec P99，读取时小于4ms P99时延，同时提供60k ops读取和60k ops写入；总计120K TPS。</p><p> CockroachDB in this example of workload A produced at most 16K TPS with P99 52ms and intermediate spikes that reach 200ms at utilization varying from 50% – 75%:</p><p> 在工作负载A的此示例中，CockroachDB最多产生16K TPS，P99为52ms，中间峰值达到200ms，利用率从50％到75％不等：</p><p>  Key Observation: Scylla handled 10x the amount of data, while providing 9.3x the throughput at 1/4th the latency.</p><p>  关键观察：Scylla处理了10倍的数据量，同时以1/4的延迟提供了9.3倍的吞吐量。</p><p>    For the large, 1B key dataset, Scylla successfully managed to serve 150K-200K TPS on most of the workloads at 75-80% utilization with decent latency. One of the best Scylla results was 180K TPS with p99 latencies  &lt;5.5ms at average load 75% on workload D with 1B keys. 200K TPS resulted in small overload and gave latencies around 20-60ms.</p><p>    对于大型的1B关键数据集，Scylla成功地以75-80％的利用率和可观的延迟成功地为大多数工作负载提供了150K-200K TPS。 Scylla最好的结果之一是180K TPS，p99延迟小于5.5毫秒，平均负载7D的工作负载D为1B键。 200K TPS导致较小的过载，并且延迟时间约为20-60ms。</p><p>    As shown in this Grafana chart, it’s not only the performance numbers that are better but also show how Scylla achieves almost maximum system utilization.</p><p>    如这张Grafana图表所示，不仅性能更好，而且还显示了Scylla如何实现几乎最大的系统利用率。</p><p> For example for workload D with 1B keys dataset, Scylla demonstrated 180K TPS with p99 latency of &lt;5.5ms and CPU utilization only at 75%. This level of performance scalability is rare for most of the OSS distributed database systems.</p><p> 例如，对于具有1B键数据集的工作负载D，Scylla展示了180K TPS，p99延迟小于5.5ms，CPU利用率仅为75％。对于大多数OSS分布式数据库系统而言，这种级别的性能可伸缩性是罕见的。</p><p> Workload E produced the worst performance, only 10k ops. This was expected as the operations are short range scans instead of individual records. From YCSB: “Application example: threaded conversations, where each scan is for the posts in a given thread assumed to be clustered by thread id”.</p><p> 工作负载E产生的性能最差，只有10,000次运算。这是预期的，因为操作是短距离扫描而不是单个记录。在YCSB中：“应用示例：线程对话，其中每次扫描都是针对给定线程中的帖子（假定它们被线程ID聚类）”。 </p><p> Workload E is an antipattern for Scylla unless it is modeled as a clustering key. Scylla’s range partition scans are token-based which are randomly placed in the cluster, thus many random reads across multiple nodes are required to satisfy a single scan request.</p><p>除非将工作负载E建模为聚类键，否则它是Scylla的反模式。 Scylla的范围分区扫描是基于令牌的，被随机放置在集群中，因此需要多个节点上的多次随机读取才能满足单个扫描请求。</p><p> Even with that said, for the range scan use-case (E) Scylla outperformed CRDB by 5x.</p><p> 即便如此，在范围扫描用例（E）中，Sylla的性能仍比CRDB高出5倍。</p><p>  CockroachDB in its turn demonstrated performance scalability limits much earlier even with the 100M keys dataset: for workload A it showed 16K TPS with p99 of &lt;52ms. It’s best result was achieved with workload D that showed 40K TPS with p99 &lt;176ms at 80% utilization. Further increasing of the load did not lead to any throughput growth, but only to the growth of latency and its variance.</p><p>  CockroachDB甚至在使用100M密钥数据集的情况下也证明了性能可伸缩性限制要早得多：对于工作负载A，它显示了16K TPS，p99小于52ms。最好的结果是D负载达到40K TPS，p99 <176ms，利用率为80％。负载的进一步增加不会导致任何吞吐量的增长，而只会导致等待时间及其方差的增长。</p><p>     NoSQL and NewSQL models are moving towards each other, each providing more functionality and better performance and availability than traditional database offerings. It is not a surprise that a NoSQL database such as Scylla outperforms a distributed SQL database as CockroachDB by a large margin. The results do not mean that one should select Scylla/NoSQL for every workload.</p><p>     NoSQL和NewSQL模型正在相互接近，与传统的数据库产品相比，它们各自提供了更多的功能以及更好的性能和可用性。毫不奇怪，像Scylla这样的NoSQL数据库要比CockroachDB大得多地胜过分布式SQL数据库。结果并不意味着应该为每个工作负载选择Scylla / NoSQL。</p><p> With 1B keys dataset, Scylla showed 5x to 10x better throughput and stable low latencies while handling 10x amount of data. CockroachDB demonstrated throughput degradation while data loading, and during the YCSB workloads we measured throughput that closely matched the CRDB whitepaper, yet with larger and greater varying latencies.</p><p> 借助1B密钥数据集，Scylla在处理10倍数据量的同时，吞吐量提高了5到10倍，并保持了低延迟。 CockroachDB展示了数据加载时吞吐量的下降，在YCSB工作负载期间，我们测量的吞吐量与CRDB白皮书非​​常接近，但延迟却越来越大。</p><p> Many modern workloads do not require strong consistency and can’t be straightjacketed by the imposition of operational limits to enormous scale requirements. These workloads are ideal for Scylla. Other workloads, where strong consistency guarantees and transactions are required or the flexibility of a relational database model, with JOINs and sorted keys, and moderate amounts of data should consider a database such as CockroachDB.</p><p> 许多现代工作负载并不需要强的一致性，也不能因对巨大规模的要求施加操作限制而受到束缚。这些工作负载是Scylla的理想选择。其他需要使用JOIN和排序键以及适量数据的，需要强一致性保证和事务处理或关系数据库模型的灵活性的工作负载，应考虑使用诸如CockroachDB之类的数据库。</p><p> Recently at the Scylla summit we announced  Project Circe, a 12 month roadmap plan that among other things adds the Raft consensus protocol and allows big improvements for strongly consistent workloads. CockroachDB on their end closed a huge round of funding and improved their LSM performance. Both databases are embraced by their respective communities for the capab</p><p> 最近在Scylla峰会上，我们宣布了Circe项目，这是一个为期12个月的路线图计划，其中包括添加了Raft共识协议，并允许对高度一致的工作负载进行重大改进。 CockroachDB最终结束了巨额融资，并改善了LSM性能。这两个数据库均受各自社区的欢迎 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.scylladb.com/2021/01/21/cockroachdb-vs-scylla-benchmark/">https://www.scylladb.com/2021/01/21/cockroachdb-vs-scylla-benchmark/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/scylla/">#scylla</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>