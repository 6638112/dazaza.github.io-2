<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>结构化编程：如何编写正确的if语句 Structured programming: how to write proper if statements</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Structured programming: how to write proper if statements<br/>结构化编程：如何编写正确的if语句 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-15 20:07:03</div><div class="page_narrow text-break page_content"><p>The  if statement (or  if expression) is the cornerstone of every modern programming language - it is so pervasive that we rarely think about how exactly should we use it, or how it is meant to be used. But despite its popularity,  if wasn’t always there, and it wasn’t as pervasive as nowadays, so its role is, I’d argue, still somewhat misunderstood. So in this article, I will examine some mistakes that we can easily avoid in order to improve on our code.</p><p>if语句（或if表达式）是每种现代编程语言的基石-它是如此普遍，以至于我们很少考虑应该如何准确地使用它，或者应该如何使用它。但是，尽管它很受欢迎，但如果它并不总是存在的话，并且它不像当今那样普遍存在，那么我认为它的作用还是有点被误解了。因此，在本文中，我将研究一些可以轻松避免的错误，以改进我们的代码。</p><p>  This is an opinionated text, i.e. it contains my opinions and although I have many arguments that back them, they are ultimately based on my core beliefs about what programming is and should be. So here are some of the things on which this advice is based on, structured as postulates.</p><p>  这是一个自以为是的文本，即它包含了我的观点，尽管我有很多论点可以支持它们，但它们最终还是基于我对编程是什么以及应该是什么的核心信念。因此，此处是此建议所基于的一些内容，并按照假设进行了组织。</p><p>  A form of this appears in a little book known in the hacker community as “SICP”, but I don’t know if they were the first to state it. It means that programs are not just instructions for performing a given task - they are text, and as such they should be subject to the same stylistical rules as other text is.</p><p>  这种形式出现在骇客社区中称为“ SICP”的一本小书中，但我不知道他们是否是第一个陈述它的人。这意味着程序不仅仅是执行给定任务的指令-它们是文本，因此它们应与其他文本一样受相同的样式规则约束。</p><p>  This one looks pretty self-explanatory, but the key point is that we have to dedicate effort to make it such, by constantly thinking not only about ways in which the code might go wrong, but also about ways to diagnose potential problems.</p><p>  这看起来很不言自明，但是关键是我们必须不懈地努力，不仅要不断思考代码可能出错的方式，而且还要思考诊断潜在问题的方式。</p><p> I guess I should say something about why I believe these things. Simple - because all other approaches just fail because of the human factor, e.g. any code, that is written without regard for style is bound to become legacy when the person who supports it leaves. Likewise, maintaining code that lacks structure results in bugs (which often can be fixed only by imposing more structure).</p><p> 我想我应该说些为什么我相信这些事情。很简单-因为所有其他方法都只是由于人为因素而失败，例如当支持该代码的人离开时，任何不考虑样式而编写的代码都必将成为传统。同样，维护缺少结构的代码也会导致错误（通常只能通过施加更多的结构来解决）。</p><p> Lastly, people often contrast good structure and readability with speed. Firstly, the comparison is a bit unfair, because a well-structured is easier to optimize. And for cases in which it is really the case, in 99% the gain is so little that nobody cares, so the emphasis should remain on readability and structure even then. This is when I would throw this very famous quote by DEK:</p><p> 最后，人们经常将良好的结构和可读性与速度进行对比。首先，这种比较有点不公平，因为结构良好的结构更易于优化。对于确实如此的情况，在99％的情况下，增益是如此之低，以至于没人在乎，因此即便如此，仍应将重点放在可读性和结构上。这是我抛出DEK这个非常著名的报价的时候：</p><p> Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97 % of the time: pre mature optimization is the root of all evil. source</p><p> 程序员浪费大量时间来考虑或担心程序非关键部分的速度，而在考虑调试和维护时，这些对效率的尝试实际上会产生严重的负面影响。我们应该忘记效率低下的问题，大约有97％的时间是这样的：成熟前的优化是万恶之源。资源 </p><p> Keep in mind that he wrote this when computers were a thousand times slower than today, so we should care about maintainability even more.</p><p>请记住，他在计算机比现在慢一千倍的时候写了这篇文章，因此我们应该更加在意可维护性。</p><p>  Once upon a time, all there was was the assembly language where people didn’t have brackets and had to use  jump instructions instead. For those who don’t know what jump does, if you imagine that somewhere in the virtual machine, or the interpreter, that runs your code there is a variable that denotes which line of code should be executed next, then  jump is a functionality that basically allows you to set that variable to whatever value you please - it is like a portal that allows you to go to from any place of the program to any other place. For example, a typical  if statement that looks like this when written with jumps:</p><p>  从前，所有的汇编语言都是人们没有方括号，而不得不使用跳转指令。对于那些不知道跳转是什么的人，如果您想象运行代码的虚拟机或解释器中的某个地方，有一个变量指示下一步应执行哪一行代码，那么跳转是一种功能基本上允许您将变量设置为所需的任何值-就像门户网站一样，它允许您从程序的任何位置转到任何其他位置。例如，典型的if语句在使用跳转编写时如下所示：</p><p> compare input to waterlevelif less, jump to Aif equal, jump to Bjump to CA:turn motor onjump to CB:turn motor offC:...</p><p> 将输入与水位比较，如果少，则跳至Aif相等，跳至Bjump到CA：打开电机到CB：关闭电机C：...</p><p>  You can see from this example that, although powerful, jumps are much harder to work with than  if-s, although they can sometimes make your code a bit shorter, they will 100% make it less readable which is hardly a good deal - if the important thing is for code to bug free, so you’d always prefer to have a longer and more readable piece of code, than one which is shorter but harder to understand. This realization led to the rise of what was at the time called “structural programming” paradigm, which was based on the idea that the power of jumps should not be exposed to the programmer - a point which was brought by Edsger W. Dijkstra in the seminal essay  Go To Statement Considered Harmful ( goto is the equivalent of a  jump instruction statements in non-assembly language context). Simultaneously, the idea of a  block meaning a collection statements that perform a common task (usually denoted today by wrapping them in curly brackets) was pushed forward, and the two ideas gave birth to the  if statement that we know today:</p><p>  您可以从此示例中看到，尽管功能强大，但跳转比if-s难得多，尽管它们有时可以使您的代码短一些，但它们会100％降低可读性，这几乎不是一件好事-如果重要的是代码无错误，所以您总是希望有一段更长的代码和可读性更高的代码，而不是较短但更难理解的代码。这种认识导致了当时所谓的“结构化编程”范式的兴起，该范式是基于这样的思想，即跳跃的力量不应暴露给程序员-这一点由Edsger W. Dijkstra提出。精读文章Go To语句被认为有害（goto等同于非汇编语言上下文中的跳转指令语句）。同时，块的意思是执行一个常见任务的集合语句（通常今天用大括号括起来表示）的想法被推进了，这两个想法催生了我们今天所知道的if语句：</p><p> if (input less than waterlevel) { turn motor on} else if (input equal to waterlevel) {turn motor off} else {...</p><p> if（输入小于水位）{打开马达} else if（输入等于水位）{关闭马达} else {...</p><p> The adoption of structured programming was a long process which began with people even questioning whether structured programs are even capable of encoding all possible computations, but today, although some people are  still defending the use of goto, it (the process) is largely finished -  goto is banished and the structured style of programming is so pervasive across modern languages that the term “structured” is not used any more, simply because there is nothing to contrast it with.</p><p> 采用结构化程序设计是一个漫长的过程，始于人们甚至质疑结构化程序是否甚至还能够编码所有可能的计算，但是今天，尽管有些人仍在捍卫goto的使用，但它（过程）在很大程度上已经完成- goto被放逐，结构化的编程风格在现代语言中如此普遍，以至于不再使用“结构化”一词，仅仅是因为没有什么可与之形成对比的。</p><p> And to reiterate, the reasons for this are quite obvious - using brackets makes our code much more akin to the way we usually talk and write with each other: we often say</p><p> 重申一下，这样做的原因非常明显-使用方括号可使我们的代码更像我们通常相互交谈和编写的方式：我们经常说 </p><p>   “if A then go to the previous page and start reading from line 12”.</p><p>“如果A然后转到上一页并从第12行开始阅读”。</p><p> (I wonder if the programmers who defend the use of  goto write and talk like that?)</p><p> （我想知道捍卫goto用法的程序员是否会像这样写和说话？）</p><p>   A leftover from the  goto-driven style of programming is the possibility of so-called “early exit” - the ability to quit the execution of a given function or method from any place of it’s body (most-oftenly by using the keyword  return) as opposed to executing the function to the end. So again if we consider our plain old  if  else statement:</p><p>   goto驱动的编程风格的剩余部分是所谓的“提前退出”的可能性-能够从其主体的任何位置退出给定功能或方法的执行（通常是通过使用关键字return）而不是执行到最后。再一次，如果我们考虑普通的if语句：</p><p>      Why not write like this? We already established that  goto is bad and I’d argue that mixing the two approaches is even worse in some respects, as it might fool you that the code is structured when it really isn’t. Furthermore, the early exit makes our code as confusing as any other  goto-containing code when translated to natural language. Imagine someone saying:</p><p>      为什么不这样写呢？我们已经确定goto不好，并且我认为在某些方面混合使用两种方法会更糟，因为这可能使您误以为代码实际上不是结构化的。此外，提前退出会使我们的代码在翻译成自然语言时像其他任何包含goto的代码一样令人困惑。想象有人说：</p><p>   “If you don’t get home early ignore everything I’d say after this sentence. Bring me a coffee.”</p><p>   “如果您不早点回家，请忽略我在这句话之后要说的一切。给我喝杯咖啡。</p><p> So if your language supports it, always rely on the implicit  return instead of explicitly ending your execution. If not, the simple rule you can follow is that you should either return from all branches of the  if statement or from none of them.</p><p> 因此，如果您的语言支持，则始终依靠隐式返回，而不是显式结束执行。如果没有，您可以遵循的简单规则是，您应该从if语句的所有分支返回，也可以不从任何分支返回。</p><p>  The most common type of situation that I have seen the premature  return pattern is for handling errors. Imagine for example a very long function with some validation at the beginning. Many people would write:</p><p>  我看到过早的返回模式最常见的情况是处理错误。例如，想象一个很长的函数，在开始时进行了一些验证。很多人会写： </p><p> signup (user) { if (username is valid ) { throw invalid username } create account for user sign user up initialise some other stuff write action in log send emails ...}</p><p>注册（用户）{如果（用户名有效）{抛出无效的用户名}为用户注册用户创建帐户，初始化其他一些东西，在日志中发送操作，写电子邮件...}</p><p> This is a very subtle variant of the issue I am describing (made even more subtle by the fact that  throw is used instead of a  return). The correct way would be:</p><p> 这是我正在描述的问题的非常微妙的变体（由于使用了throw而不是return，这一事实变得更加微妙）。正确的方法是：</p><p> signup (user) { if (username is valid ) { throw invalid username } else { create account for user sign user up initialise some other stuff write action in log send emails ... }}</p><p> 注册（用户）{如果（用户名有效）{抛出无效的用户名}其他{为用户注册用户创建帐户，初始化一些其他内容，在日志发送电子邮件中写入操作...}}</p><p> but people would prefer having the main function code directly in the body in order to avoid indentation (especially if there is a lot of it already). According to them (and they have a point) the error handling is somewhat outside of the domain of the function, we can perhaps say that they are at different levels of abstraction. In cases like this, we should use  functions to structure our code and to keep the different levels of abstraction separate.</p><p> 但是人们希望直接在主体中使用主要功能代码以避免缩进（特别是如果已经有很多缩进）。根据他们（他们有观点），错误处理在功能范围之外，我们可以说它们处于不同的抽象级别。在这种情况下，我们应该使用函数来构造代码并保持不同的抽象级别分离。</p><p> Functions are everything that random sequences of statement are not and can never be - they  have names, they have  a separate scope (blocks also have their own scope, but they also inherit the scope of the parent block), and most importantly they are  easy to debug (e.g. you have the name of the thing that went wrong right there on the top of the stack trace. So let’s look at how the code above can be made to work with functions. I think this is a very cool and underused pattern that allows you to lose the indentation without sacrificing your structure.</p><p> 函数是语句的随机序列不是也不能永远是的所有东西-它们具有名称，具有独立的作用域（块也具有自己的作用域，但它们也继承父块的作用域），最重要的是，它们很容易进行调试（例如，您在堆栈跟踪的顶部上有出错的名称。因此，让我们看一下如何使上面的代码与函数一起使用。我认为这是一个非常酷且未充分利用的模式这样您就可以在不牺牲结构的情况下丢失缩进。</p><p> signup (user) { if (username is valid ) { throw invalid username } else { return signup internal (user) }}signup internal (user) { // or _signup as some people name it create account for user sign user up initialise some other stuff write action in log send emails...}</p><p> 注册（用户）{如果（用户名有效）{抛出无效的用户名}否则{返回内部注册（用户）}}内部注册（用户）{//或_signup为某些人命名，为用户注册创建帐户用户注册初始化其他内容在日志发送电子邮件中写入操作...}</p><p>  This is another bad pattern that, we might say, has the same root cause as the first one - in their effort to keep things simple and concise, people don’t include all the structure that needs to be there in a robust piece of code.</p><p>  我们可能会说，这是另一种不好的模式，与第一个模式有相同的根本原因-为了使事情简单明了，人们并没有将所有需要的结构都包含在健壮的代码中。 </p><p> In  if statements we often have to deal with multiple conditions that are dependent on one another. And sometimes in such cases, people try to deal with all of them in one statement with multiple branches and  else if-s. I argue that it’s actually better to have  one statement per condition and to nest statements to get the control flow we want.</p><p>在if语句中，我们经常不得不处理多个相互依赖的条件。有时在这种情况下，人们尝试在一个带有多个分支的语句中处理所有这些语句，否则尝试使用if-s。我认为，最好是每个条件只有一个语句，然后嵌套语句以获得我们想要的控制流。</p><p>  if (a and not b) { do this } else if (a) { do that } if (b) { do the other thing }</p><p>  如果（a而不是b）{这样做}否则（a）{这样做} if（b）{做另一件事}</p><p> This is the typical mess that we end up when we just add stuff to our code without refactoring it, and although it does not look that bad, it is nearly impossible to understand. I feel sorry for the person would have to debug this thing in order to fix the issues that it would no doubt cause, and I am firmly convinced that the only smart thing that they can do is to separate the code that deals with  a and the code that deals with  b into two separate statements like this:</p><p> 这是典型的混乱，当我们只是在代码中添加内容而不进行重构时，我们最终会陷入困境，尽管它看上去并不那么糟糕，但几乎无法理解。我为该人必须调试此程序以解决毫无疑问会引起的问题而感到抱歉，我坚信他们唯一可以做的聪明事就是将处理a和the的代码分开。将b处理为两个单独的语句的代码，如下所示：</p><p> if (a) { if (b) { do that do the other thing } else { do this } } else { if (b) { do the other thing } else { // ??? } }</p><p> if（a）{if（b）{做其他事情} else {做此}} else {if（b）{做其他事情} else {// ??? }}</p><p> You can see that this block now starts to look like a piece of logic, as opposed to a random pile of conditionals. We can now reason about it, for example we can point out that not all combinations of values of  a and  b are handled, but more on that later. In short, our code does not work like a Rube Goldberg machine any more.</p><p> 您可以看到，此块现在看起来像是逻辑，而不是随机的条件堆。现在，我们可以对此进行推理，例如，我们可以指出，并非a和b值的所有组合都得到处理，但稍后会处理更多。简而言之，我们的代码不再像Rube Goldberg机器那样工作。</p><p> Some people would argue that having to repeat the  do the other thing block in two branches is a deficiency but I beg to disagree - the two branches represent two different cases and the fact that we handle those two cases in the same way is hardly a reason for us not to enumerate them explicitly - we lose a little bit of conciseness but we gain a great deal in terms of readability and robustness.</p><p> 有人会辩称，必须在两个分支中重复执行另一事物块是一个缺陷，但我不同意-两个分支代表两个不同的案例，而我们以相同的方式处理这两个案例的事实几乎不是原因因为我们没有明确列举它们-我们失去了一些简洁性，但是在可读性和鲁棒性方面却获得了很多。</p><p> But what if we have to repeat more than one line? As I said above, wrap that into a function.</p><p> 但是，如果我们必须重复多行，该怎么办？如我上面所说，将其包装为一个函数。 </p><p>  We all know that  if statements should handle all possible cases and doing so is very easy, especially if we keep one condition per statement, we just have to ensure that every  if statement has an  else clause which would handle the cases where the other condition or conditions are not satisfied. Although simple, this rule is sometimes broken. What do we do, for example, when there is nothing that we  should do in a given case? Imagine, for example, that we have a “Sing Up” button that can be disabled and that does not work if it is disabled. The specification might say something like “if the button is disabled, do nothing.” Turning this requirement into code in a straightforward manner, would result into this:</p><p>我们都知道，如果语句应该处理所有可能的情况，并且这样做很容易，尤其是如果我们在每个语句中保留一个条件，那么我们只需要确保每个if语句都具有else子句即可处理其他情况或其他情况。条件不满足。尽管很简单，但有时却会违反此规则。例如，当在给定情况下我们什么都不要做时，我们该怎么办？例如，假设我们有一个“ Sing Up”按钮，可以将其禁用，如果禁用，该按钮将不起作用。规范可能会说类似“如果按钮被禁用，则什么也不做。”以简单的方式将此要求转换为代码将导致以下结果：</p><p>  Our implementation will be correct, but I’d argue that  the specification is wrong - as a user, I hate it when I click stuff and don’t get any feedback (and you would start hating you too, if your users start contacting you with annoying questions). You have nothing to lose and everything to win if you just throw an alert there.</p><p>  我们的实现是正确的，但我认为该规范是错误的-作为用户，当我单击内容且没有任何反馈时，我会讨厌它（如果用户开始与您联系，您也会开始讨厌您）带着烦人的问题）。如果您在那里发出警报，您将不会失去任何东西，也不会赢得任何胜利。</p><p> on signup click() { if (signup enabled ) { signupuser } else { show popup &#34;signup is disabled because ${reason}&#39; }</p><p> 在注册时单击click（）{如果（启用了注册）{signupuser}否则{show popup＆＃34; signup被禁用，因为$ {reason}＆＃39; }</p><p> Aside from making your program better, this line might be useful for debugging - imagine that some user clicks the Signup button and nothing happens. This would mean that there is a bug somewhere in the code path. But if the path contains more than one  if statements with no  else-s then there would be no way for you to know which of them went wrong. Having some kind of marker of what happened, no matter if it is a message that a user sees, if it’s front-end code, or an exception that you can look up in your logs, if it’s in the back-end would ensure makes all such issues trivial to fix.</p><p> 除了使您的程序更好之外，此行可能对调试很有用-假设某些用户单击“注册”按钮而没有任何反应。这意味着在代码路径中的某个位置存在错误。但是，如果路径包含多个if语句，且没有其他-s，那么您将无法知道其中哪个出错了。无论发生的是用户看到的消息，前端代码，还是可以在日志中查找的异常（无论后端是后端），都可以对发生的事情进行某种标记所有这些问题都是微不足道的。</p><p> Another case when people make this mistake is the situation where you have a bunch of cases that you handle in different ways and you don’t really expect for something else to happen (this pattern is even more pervasive if you break the rule about conflating multiple conditions in one statements).</p><p> 人们犯此错误的另一种情况是，您遇到许多情况以不同的方式处理，而您并不真正期望发生其他事情（如果您违反了将多个数据混为一谈的规则，这种模式将更加普遍一个陈述中的条件）。</p><p> if (a === 1) { do this } else if (a === 2) { do that } else { // What do do here? }</p><p> if（a === 1）{这样做} else if（a === 2）{这样做} else {//在这里做什么？ }</p><p> My advice here is to do  something - return a value, throw an exception, any exception, leave a breadcrumb that when the time comes would help you what went wrong.</p><p> 我在这里的建议是做某事-返回值，抛出异常，任何异常，留下面包屑，以备不时之需将帮助您解决问题。 </p><p>  No matter how punctual are we with our  if statements, the logic of our programs ultimately depends on the business requirements, which often seem ugly when implemented directly. In these cases, you might help yourself by encoding some of those requirements in datastructures, or even a DSL, and to write your code around those datastructures. Suppose you have the following requirement.</p><p>无论我们使用if语句有多守时，我们程序的逻辑最终都取决于业务需求，而直接执行这些业务需求通常很难看。在这些情况下，您可以通过在数据结构甚至DSL中编码一些需求来帮助自己，并围绕这些数据结构编写代码。假设您具有以下要求。</p><p> When the user signs up, charge them for membership. Membership costs 10 dollars for people below 18 years old and 20 for people who are older. Oh, and also pro members pay 2 dollars extra, unless they are subscribed for more than 5 years, in this case they pay 1.</p><p> 用户注册后，向他们收取会员资格。会员费用为18岁以下的人10美元，年龄较大的人20美元。哦，专业会员也要额外支付2美元，除非订阅了5年以上，在这种情况下，他们需要支付1。</p><p> Again, going straight from requirement to code would result in a somewhat messy block (note that there are two subsequent  if-s - something which I see as an anti-pattern).</p><p> 再次，从需求直接转到代码将导致混乱的块（请注意，随后有两个if-s-我认为这是反模式）。</p><p> if (less than 18) { charge 10 } else { charge 20 } if (pro) { if (subscribed for 5) { charge 1 } else { charge 2 } }</p><p> 如果（少于18）{收费10}否则{收费20}如果（赞成）{如果（订为5）{收费1}否则{收费2}}</p><p> A way to avoid this is to encode this logic as data. Let’s go back to the requirements and create a table with all the conditions. The table would look something like this:</p><p> 避免这种情况的一种方法是将该逻辑编码为数据。让我们回到需求并创建一个包含所有条件的表格。该表将如下所示：</p><p>  After that, we can easily use this table to get the price for a given user, for example with the following functional piece:</p><p>  之后，我们可以轻松地使用此表来获取给定用户的价格，例如，使用以下功能块：</p><p> rellevant charges = all charges filter(age min &lt; user.age &lt; age max ) filter(subscribed for min &lt; user.subscribed for &lt; subscribed for max) filter(pro membershup and plan.isPrototal = rellevant charges reduce (charge object 1.price + charge.object 2.price)</p><p> 相对费用=所有费用过滤器（年龄最小＆lt;用户。年龄＆年龄最大）过滤器（针对最小＆lt;用户。针对＆lt;针对最大订阅）过滤器（promemberhup和plan.isPrototal =相对费用减少（费用对象1.price +费用。对象2.price） </p><p> Not only did we manage to make our code very beautiful, we already have a mechanism to edit the rules without code changes.</p><p>我们不仅设法使代码变得非常漂亮，而且已经有了一种无需更改代码即可编辑规则的机制。</p><p>  Let’s see one more example of how we can utilize data structures for control-flow. This one has to do with error handling. We often have multiple ways in which things can go wrong and we are encoding them with  ifs, like this.</p><p>  让我们再看一个示例，说明如何利用数据结构进行控制流。这与错误处理有关。我们经常会以多种方式出错，并且我们使用ifs对其进行编码，如下所示。</p><p> if (error1) { return Error: error1} else if (error2) { return Error: error2} else { doStuff()}</p><p> if（error1）{返回错误：error1} else if（error2）{返回错误：error2} else {doStuff（）}</p><p> Although this approach does not contradict the non-conflation rule (which is only valid for conditions that are  dependent on one another) it has certain disadvantages in terms of readability, not to mention the inability to return a list of all errors, which is sometimes preferred. If we view error checks as functions that take an input and return a result indicating whether the input is valid under a given criteria, then we can encode them as a table, similar to the one in the previous example, except that here rows will feature custom logic.</p><p> 尽管这种方法与非合并规则（仅对彼此依赖的条件有效）并不矛盾，但在可读性方面有某些缺点，更不用说无法返回所有错误的列表了，这有时是首选。如果我们将错误检查视为接受输入的函数，并返回指示输入在给定条件下是否有效的结果，则可以将它们编码为表格，类似于上一个示例，只是这里的行将以自定义逻辑。</p><p> error checks = [ name: Below 18, check: (user) =&gt; user.age &lt; 18 name: is not pro , check: (user) =&gt; !user.isPro]</p><p> 错误检查= [名称：18岁以下，检查：（用户）=＆gt;用户年龄＆lt; 18名称：不是pro，请检查：（用户）=＆gt; ！user.isPro]</p><p> As I mentioned, this makes it easy to gather all the errors and return them as an array:</p><p> 如前所述，这使得收集所有错误并以数组形式返回它们变得容易：</p><p> errors = error checks filter(error.check(user)) map(error.name)if (errors &gt; 0) { throw errors} else { do stuff}</p><p> 错误=错误检查过滤器（error.check（user））map（error.name）if（错误＆gt; 0）{抛出错误}其他{做事情} </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://boris-marinov.github.io/if/">http://boris-marinov.github.io/if/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/结构化编程/">#结构化编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>