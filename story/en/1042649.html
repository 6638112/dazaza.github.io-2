<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们如何构建GitHub Globe How We Built the GitHub Globe</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How We Built the GitHub Globe<br/>我们如何构建GitHub Globe </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-31 21:23:29</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/fdc83b9dc3efa32de32c9f6b3d0d41d3.png"><img src="http://img2.diglog.com/img/2020/12/fdc83b9dc3efa32de32c9f6b3d0d41d3.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>GitHub is where the world builds software. More than 56 million developers around the world build and work together on GitHub. With our new  homepage, we wanted to  show how open source development transcends the borders we’re living in and to tell our product story through the lens of a developer’s journey.</p><p>GitHub是全世界构建软件的地方。全世界有超过5600万开发人员在GitHub上构建和协作。通过我们的新主页，我们想展示开源开发如何超越我们所生活的边界，并通过开发者的旅程来讲述我们的产品故事。</p><p> Now that it’s live, we would love to share how we built the homepage-directly from the voices of our designers and developers. In this five-part series, we’ll discuss:</p><p> 现在它已经上线了，我们很乐意直接从设计师和开发人员的声音中分享我们如何构建主页。在这个由五部分组成的系列文章中，我们将讨论：</p><p>   At Satellite in 2019, our CEO  Nat showed off  a visualization of open source activity on GitHub over a 30-day span. The sheer volume and global reach was astonishing, and we knew we wanted to build on that story.</p><p>   在2019年的Satellite上，我们的CEO Nat展示了30天跨GitHub上开源活动的可视化。庞大的数量和全球影响力令人惊讶，我们知道我们希望在这个故事的基础上继续前进。</p><p>   The main goals we set out to achieve in the design and development of the globe were:</p><p>   我们着手在全球设计和开发中实现的主要目标是：</p><p> An interconnected community. We explored many different options, but ultimately landed on pull requests. It turned out to be a beautiful visualization of pull requests being opened in one part of the world and closed in another.</p><p> 相互联系的社区。我们探索了许多不同的选择，但最终落入了请求请求。事实证明，这是在世界某个地方打开并在另一个地方关闭的拉取请求的漂亮可视化。</p><p> A showcase of real work happening now. We started by simply showing the pull requests’ arcs and spires, but quickly realized that we needed “proof of life.” The arcs could quite as easily just be design animations instead of real work. We iterated on ways to provide more detail and found most resonance with clear hover states that showed the pull request, repo, timestamp, language, and locations. Nat had the idea of making each line clickable, which really upleveled the experience and made it much more immersive.  Read more here.</p><p> 现在展示真实工作。我们从简单地显示拉动请求的弧线和尖顶开始，但是很快意识到我们需要“生命力证明”。弧线可以很容易地只是设计动画而不是实际工作。我们对提供更多详细信息的方法进行了迭代，并通过清晰的悬停状态（显示拉动请求，回购，时间戳，语言和位置）发现了最多的共鸣。 Nat的想法是使每条线都可点击，这确实提升了体验并使其更加身临其境。在这里阅读更多。</p><p> Attention to detail and performance. It was extremely important to us that the globe not only looked inspiring and beautiful, but that it performed well on all devices. We went through many, many iterations of refinement, and there’s still more work to be done.</p><p> 注意细节和性能。对于我们而言，极为重要的是，地球仪不仅看起来令人鼓舞，美丽，而且在所有设备上都表现出色。我们经历了许多次细化的迭代，还有许多工作要做。 </p><p>  At the most fundamental level, the globe runs in a WebGL context powered by  three.js. We feed it data of recent pull requests that have been created and merged around the world through a JSON file. The scene is made up of five layers: a halo, a globe, the Earth’s regions, blue spikes for open pull requests, and pink arcs for merged pull requests. We don’t use any textures: we point four lights at a sphere, use about 12,000 five-sided  circles to render the Earth’s regions, and draw a halo with a simple custom shader on the backside of a sphere.</p><p>从最基本的角度来看，地球在由three.js支持的WebGL上下文中运行。我们向它提供通过JSON文件在全球范围内创建并合并的最近请求请求的数据。场景由五层组成：一个光环，一个地球仪，地球区域，用于打开请求请求的蓝色尖峰和用于合并请求请求的粉红色弧。我们不使用任何纹理：我们将四个光源指向一个球体，使用大约12,000个五边形圆来渲染地球区域，并使用一个简单的自定义着色器在球体的背面绘制光晕。</p><p>  To draw the Earth’s regions, we start by defining the desired density of circles (this will vary depending on the performance of your machine—more on that later), and loop through longitudes and latitudes in a nested for-loop. We start at the south pole and go upwards, calculate the circumference for each latitude, and distribute circles evenly along that line, wrapping around the sphere:</p><p>  要绘制地球区域，我们首先定义所需的圆密度（这将取决于您的计算机的性能而有所不同，稍后会进一步说明），然后在嵌套的for循环中遍历经度和纬度。我们从南极开始，然后向上，计算每个纬度的周长，然后沿该线均匀分布圆，并环绕球体：</p><p> for (let lat = -90; lat &lt;= 90; lat += 180/rows) { const radius = Math.cos(Math.abs(lat) * DEG2RAD) * GLOBE_RADIUS; const circumference = radius * Math.PI * 2; const dotsForLat = circumference * dotDensity; for (let x = 0; x &lt; dotsForLat; x++) { const long = -180 + x*360/dotsForLat; if (!this.visibilityForCoordinate(long, lat)) continue; // Setup and save circle matrix data }}</p><p> for（let lat = -90; lat＆lt; = 90; lat + = 180 / rows）{const radius = Math.cos（Math.abs（lat）* DEG2RAD）* GLOBE_RADIUS; const周长=半径* Math.PI * 2; const dotForLat =圆周* dotDensity; for（let x = 0; x＆lt; dotsForLat; x ++）{const long = -180 + x * 360 / dotsForLat;如果（！this.visibilityForCoordinate（long，lat））继续; //设置并保存圆矩阵数据}}</p><p> To determine if a circle should be visible or not (is it water or land?) we load a small PNG containing a map of the world, parse its image data through canvas’s  context.getImageData(), and map each circle to a pixel on the map through the visibilityForCoordinate(long, lat) method. If that pixel’s alpha is at least 90 (out of 255), we draw the circle; if not, we skip to the next one.</p><p> 为了确定一个圆是否应该可见（它是水还是陆地？），我们加载一个包含世界地图的小PNG，通过canvas的context.getImageData（）解析其图像数据，并将每个圆映射到一个像素通过visibilityForCoordinate（long，lat）方法绘制地图。如果该像素的Alpha值至少为90（255个像素），则我们绘制圆圈；如果没有，我们跳到下一个。</p><p> After collecting all the data we need to visualize the Earth’s regions through these small circles, we create an instance of  CircleBufferGeometry and use an  InstancedMesh to render all the geometry.</p><p> 收集了我们需要通过这些小圆圈可视化地球区域所需的所有数据之后，我们创建了CircleBufferGeometry的实例，并使用InstancedMesh渲染了所有几何形状。</p><p>  As you enter the new GitHub homepage, we want to make sure that you can see your own location as the globe appears, which means that we need to figure where on Earth that you are. We wanted to achieve this effect without delaying the first render behind an IP look-up, so we set the globe’s starting angle to center over Greenwich, look at  your device’s timezone offset, and convert that offset to a rotation around the globe’s own axis (in radians):</p><p>  当您进入新的GitHub主页时，我们要确保在地球出现时可以看到自己的位置，这意味着我们需要弄清楚您在地球上的位置。我们希望在不延迟IP查找后的第一个渲染的情况下实现这种效果，因此我们将地球仪的起始角度设置为以格林威治为中心，查看设备的时区偏移量，然后将该偏移量转换为围绕地球仪自身轴的旋转（以弧度为单位）：</p><p> const date = new Date();const timeZoneOffset = date.getTimezoneOffset() || 0;const timeZoneMaxOffset = 60*12;rotationOffset.y = ROTATION_OFFSET.y + Math.PI * (timeZoneOffset / timeZoneMaxOffset);</p><p> const date = new Date（）; const timeZoneOffset = date.getTimezoneOffset（）|| 0; const timeZoneMaxOffset = 60 * 12; rotationOffset.y = ROTATION_OFFSET.y + Math.PI *（timeZoneOffset / timeZoneMaxOffset）; </p><p> It’s not an  exact measurement of your location, but it’s quick, and does the job.</p><p>它不是您所在位置的精确度量，但它可以快速完成任务。</p><p>  The main act of the globe is, of course, visualizing all of the pull requests that are being opened and merged around the world. The data engineering that makes this possible is a different topic in and of itself, and we’ll be sharing how we make that happen in an  upcoming post. Here we want to give you an overview of how we’re visualizing all your pull requests.</p><p>  当然，全球范围内的主要行为是可视化在全球范围内正在打开和合并的所有拉动请求。使之成为可能的数据工程本身就是一个不同的话题，我们将在下一篇文章中分享如何实现这一点。在这里，我们希望向您概述我们如何可视化所有拉动请求。</p><p>   Let’s focus on pull requests being merged (the pink arcs), as they are a bit more interesting. Every merged pull request entry comes with two locations: where it was opened, and where it was merged. We map these locations to our globe, and draw a bezier curve between these two locations:</p><p>   让我们集中讨论合并的拉取请求（粉红色弧线），因为它们比较有趣。每个合并的拉取请求条目都有两个位置：打开位置和合并位置。我们将这些位置映射到地球上，并在这两个位置之间绘制贝塞尔曲线：</p><p>  We have three different orbits for these curves, and the longer the two points are apart, the further out we’ll pull out any specific arc into space. We then use instances of  TubeBufferGeometry to generate geometry along these paths, so that we can use  setDrawRange() to animate the lines as they appear and disappear.</p><p>  这些曲线有3个不同的轨道，而且两点之间的距离越长，我们将越往外拉出任何特定的弧线进入太空。然后，我们使用TubeBufferGeometry的实例沿这些路径生成几何，以便可以使用setDrawRange（）对线的出现和消失进行动画处理。</p><p> As each line animates in and reaches its merge location, we generate and animate in one solid  circle that stays put while the line is present, and one  ring that scales up and immediately fades out. The ease out easings for these animations are created by multiplying a speed (here 0.06) with the difference between the target (1) and the current value (animated.dot.scale.x), and adding that to the existing scale value. In other words, for every frame we step 6% closer to the target, and as we’re coming closer to that target, the animation will naturally slow down.</p><p> 当每条线进行动画处理并到达其合并位置时，我们会在一个实线圆圈中生成该动画并对其进行动画处理，而该实线会在存在该线时保持不变，并且一个环会放大并立即消失。通过将速度（在此为0.06）与目标（1）和当前值（animated.dot.scale.x）之差相乘，并将其添加到现有的比例值中，可以创建这些动画的缓动缓动。换句话说，对于每一帧，我们都离目标越近6％，并且随着我们离目标越近，动画自然会放慢速度。</p><p> // The solid circleconst scale = animated.dot.scale.x + (1 - animated.dot.scale.x) * 0.06;animated.dot.scale.set(scale, scale, 1);// The landing effect that fades outconst scaleUpFade = animated.dotFade.scale.x + (1 - animated.dotFade.scale.x) * 0.06;animated.dotFade.scale.set(scaleUpFade, scaleUpFade, 1);animated.dotFade.material.opacity = 1 - scaleUpFade;</p><p> //实心圆圈const scale = animation.dot.scale.x +（1-animation.dot.scale.x）* 0.06; animateated.dot.scale.set（scale，scale，1）; //淡出constScaleUpFade =动画.dotFade.scale.x +（1-动画.dotFade.scale.x）* 0.06; animated.dotFade.scale.set（scaleUpFade，scaleUpFade，1）; animated.dotFade.material.opacity = 1 -scaleUpFade;</p><p>  The homepage and the globe needs to perform well on a variety of devices and platforms, which early on created some creative restrictions for us, and made us focus extensively on creating a well-optimized page. Although some modern computers and tablets could render the globe at 60 FPS with antialias turned on, that’s not the case for all devices, and we decided early on to leave antialias turned off and optimize for performance. This left us with a sharp and pixelated line running along the top left edge of the globe, as the globe’s highlighted edge met the darker color of the background:</p><p>  主页和全球都需要在各种设备和平台上保持良好的性能，这在早期就给我们带来了一些创作上的限制，并使我们广泛关注于创建经过优化的页面。尽管某些现代计算机和平板电脑可以在打开抗锯齿功能的情况下以60 FPS的速度渲染地球图像，但并非所有设备都如此，因此我们决定尽早关闭抗锯齿功能并优化性能。这使我们在地球的左上边缘有一条清晰的像素化线条，因为地球的突出显示的边缘与背景的深色相遇： </p><p>  This encouraged us to explore a halo effect that could hide that pixelated edge. We created one by using a custom shader to draw a gradient on the backside of a sphere that’s slightly larger than the globe, placed it behind the globe, and tilted it slightly on its side to emphasize the effect in the top left corner:</p><p>这鼓励我们探索可能隐藏该像素化边缘的光晕效果。我们使用自定义着色器创建了一个球体，该球体在比球体稍大的球体的背面绘制渐变，将球体放置在球体后方，并稍微倾斜其侧面以强调左上角的效果：</p><p>   This smoothed out the sharp edge, while being a much more performant operation than turning on antialias. Unfortunately, leaving antialias off also produced a fairly prominent  moiré effect as all the circles making up the world came closer and closer to each other as they neared the edges of the globe. We reduced this effect and simulated the look of a thicker atmosphere by using a  fragment shader for the circles where each circle’s alpha is a function of its distance from the camera, fading out every individual circle as it moves further away:</p><p>   这样可以平滑锐利的边缘，同时比打开抗锯齿功能更高效。不幸的是，取消抗锯齿也产生了相当显着的波纹效果，因为组成世界的所有圈子在靠近地球边缘时都越来越近。我们通过为圆使用片段着色器来减少这种效果并模拟更浓厚的气氛，其中每个圆的alpha值是其与相机的距离的函数，随着每个圆的进一步远离，淡出每个圆：</p><p> if (gl_FragCoord.z &gt; fadeThreshold) { gl_FragColor.a = 1.0 + (fadeThreshold - gl_FragCoord.z ) * alphaFallOff;}</p><p> 如果（gl_FragCoord.z＆g​​t; fadeThreshold）{gl_FragColor.a = 1.0 +（fadeThreshold-gl_FragCoord.z）* alphaFallOff;}</p><p>  We don’t know how quickly (or slowly) the globe is going to load on a particular device, but we wanted to make sure that the header composition on the homepage is always balanced, and that you got the impression that the globe loads quickly even if there’s a slight delay before we can render the first frame.</p><p>  我们不知道地球将以多快（或缓慢）的速度加载到特定设备上，但我们想确保主页上的标题组合始终保持平衡，并且给人以地球快速加载的印象即使在渲染第一帧之前稍有延迟。</p><p> We created a bare version of the globe using only gradients in  Figma and exported it as an SVG. Embedding this SVG in the HTML document adds little overhead, but makes sure that  something is immediately visible as the page loads. As soon as we’re ready to render the first frame of the globe, we transition between the SVG and the canvas element by crossfading between and scaling up both elements using the  Web Animations API. Using the Web Animations API enables us to not touch the DOM at all during the transition, ensuring that it’s as stutter-free as possible.</p><p> 我们仅在Figma中使用渐变创建了地球的裸露版本，并将其导出为SVG。在HTML文档中嵌入此SVG几乎不会增加开销，但要确保在页面加载时立即可见。一旦准备好渲染地球的第一帧，就可以使用Web Animations API在两个元素之间进行交叉淡化并按比例放大，从而在SVG和canvas元素之间进行过渡。使用Web Animations API，我们可以在过渡过程中完全不接触DOM，从而确保它尽可能无死角。</p><p> const keyframesIn = [ { opacity: 0, transform: &#39;scale(0.8)&#39; }, { opacity: 1, transform: &#39;scale(1)&#39; } ];const keyframesOut = [ { opacity: 1, transform: &#39;scale(0.8)&#39; }, { opacity: 0, transform: &#39;scale(1)&#39; } ];const options = { fill: &#39;both&#39;, duration: 600, easing: &#39;ease&#39; };this.renderer.domElement.animate(keyframesIn, options);const placeHolderAnim = placeholder.animate(keyframesOut, options);placeHolderAnim.addEventListener(&#39;finish&#39;, () =&gt; { placeholder.remove();});</p><p> const keyframesIn = [{不透明度：0，变换：＆＃39; scale（0.8）＆＃39; }，{不透明度：1，变换：＆＃39; scale（1）＆＃39; }]; const keyframesOut = [{不透明度：1，变换：＆＃39; scale（0.8）＆＃39; }，{opacity：0，transform：＆＃39; scale（1）＆＃39; }]; const options = {fill：＆＃39; both＆＃39 ;，持续时间：600，缓动：＆＃39; ease＆＃39; }; this.renderer.domElement.animate（keyframesIn，options）; const placeHolderAnim = placeholder.animate（keyframesOut，options）; placeHolderAnim.addEventListener（＆＃39; finish＆＃39 ;,（）=＆gt; {{placeholder.remove（ ）;}）;</p><p>  We aim at maintaining 60 FPS while rendering an as beautiful globe as we can, but finding that balance is tricky—there are thousands of devices out there, all performing differently depending on the browser they’re running and their mood. We constantly monitor the achieved FPS, and if we fail to maintain 55.5 FPS over the last 50 frames we start to degrade the quality of the scene.</p><p>  我们的目标是维持60 FPS，同时尽我们所能呈现出美丽的地球，但要找到这种平衡是很棘手的-那里有成千上万的设备，根据它们所运行的浏览器和心情，它们的性能各不相同。我们会不断监控已达到的FPS，如果在过去的50帧中未能保持55.5 FPS，我们将开始降低场景质量。 </p><p>   There are four quality tiers, and for every degradation we reduce the amount of expensive calculations. This includes reducing the pixel density, how often we raycast (figure out what your cursor is hovering in the scene), and the amount of geometry that’s drawn on screen—which brings us back to the circles that make up the Earth’s regions. As we traverse down the quality tiers, we reduce the desired circle density and rebuild the Earth’s regions, here going from the original ~12 000 circles to ~8 000:</p><p>质量分为四个等级，对于每次降级，我们都会减少昂贵的计算量。这包括降低像素密度，降低射线发射频率（弄清楚光标在场景中的悬浮状态）以及在屏幕上绘制的几何图形的数量，这使我们回到构成地球区域的圆上。当我们遍历质量等级时，我们降低了所需的圆密度并重建了地球的区域，这里从原来的约12000个圆圈变为约8000个圆圈：</p><p> // Reduce pixel density to 1.5 (down from 2.0)this.renderer.setPixelRatio(Math.min(AppProps.pixelRatio, 1.5));// Reduce the amount of PRs visualized at any given timethis.indexIncrementSpeed = VISIBLE_INCREMENT_SPEED / 3 * 2;// Raycast less often (wait for 4 additional frames)this.raycastTrigger = RAYCAST_TRIGGER + 4;// Draw less geometry for the Earth’s regionsthis.worldDotDensity = WORLD_DOT_DENSITY * 0.65;// Remove the worldthis.resetWorldMap();// Generate world anew from new settingsthis.buildWorldGeometry();</p><p> //将像素密度降低到1.5（从2.0降低）this.renderer.setPixelRatio（Math.min（AppProps.pixelRatio，1.5））; //减少在任何给定时间可视化的PR数量this.indexIncrementSpeed = VISIBLE_INCREMENT_SPEED / 3 * 2 ; //减少射线广播（等待4个额外的帧）this.raycastTrigger = RAYCAST_TRIGGER + 4; //为地球区域绘制较少的几何图形this.worldDotDensity = WORLD_DOT_DENSITY * 0.65; //删除世界this.resetWorldMap（）; //生成从新设置重新世界this.buildWorldGeometry（）;</p><p>  These are some of the techniques that we use to render the globe, but the creation of the globe and the new homepage is part of a longer story, spanning multiple teams, disciplines, and departments, including design, brand, engineering, product, and communications. We’ll continue the deep-dive in this 5-part series, so come back soon or follow us on Twitter  @GitHub for all the latest updates on this project and more.</p><p>  这些是我们用于渲染地球仪的一些技术，但是地球仪的创建和新首页是一个较长故事的一部分，涉及多个团队，学科和部门，包括设计，品牌，工程，产品和通讯。我们将在这个分为5部分的系列文章中继续进行深入研究，因此请稍后再回来，或者在Twitter @GitHub上关注我们，以获取该项目的所有最新更新以及更多信息。</p><p>  In the meantime, don’t miss out on the new GitHub globe wallpapers from the GitHub Illustration Team to enjoy the globe from your desktop or mobile device:</p><p>  同时，不要错过GitHub Illustration Team的新GitHub Globe壁纸，从您的台式机或移动设备上欣赏地球：</p><p>   Love the new GitHub homepage or any of the work you see here?   Join our team!</p><p>   喜欢新的GitHub主页或您在此处看到的任何作品吗？加入我们的团队！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.blog/2020-12-21-how-we-built-the-github-globe/">https://github.blog/2020-12-21-how-we-built-the-github-globe/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/github/">#github</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/地球/">#地球</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>