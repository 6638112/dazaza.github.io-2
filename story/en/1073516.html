<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>MikroTik认证被揭发MikroTik authentication revealed</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">MikroTik authentication revealed<br/>MikroTik认证被揭发</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-15 20:40:28</div><div class="page_narrow text-break page_content"><p>In August 2019, MikroTik issued a RouterOS software update to version 6.45.1 which removed plaintext password storage on all routers that upgraded to the new firmware. While enhancing router security, this came as a blow for researchers, network administrators, and tinkerers who used customized tooling with MikroTik proprietary protocols such as MAC Telnet and Winbox. MikroTik has since failed to detail the new authentication procedure  despite user requests for assistance. Margin Research is excited to illuminate the authentication procedure and offer Python  proof of concept (POC) implementations for Winbox and MAC Telnet authentication.</p><p>2019年8月，MikroTik发布了6.45.1版RouterOS软件更新，删除了升级到新固件的所有路由器上的明文密码存储。在增强路由器安全性的同时，这对使用MikroTik专有协议（如MAC Telnet和Winbox）的定制工具的研究人员、网络管理员和修补者来说是一个打击。尽管用户请求协助，MikroTik仍未能详细说明新的认证程序。Margin Research很高兴能够阐明身份验证过程，并为Winbox和MAC Telnet身份验证提供Python概念验证（POC）实现。</p><p>  MikroTik&#39;s new authentication process uses a variation of Secure Remote Password (SRP). SRP is a type of Password Authentication Key Exchange protocol which incorporates the password within key exchange calculations. Knowledge of the correct password is required to compute the shared secret, so identical secrets indicate successful authentication. The SRP specification dates back over two decades and mainstream use gained traction in the recent past, highlighted by its use in OpenSSL. However, MikroTik does not implement this SRP protocol. Rather, RouterOS employs elliptic curve SRP (EC-SRP), specifically EC-SRP5. This protocol, which is much less prevalent, is defined by the following sequence:</p><p>米克罗蒂克&#39；s的新身份验证过程使用了安全远程密码（SRP）的变体。SRP是一种密码认证密钥交换协议，它将密码合并到密钥交换计算中。计算共享机密需要知道正确的密码，因此相同的机密表示身份验证成功。SRP规范可以追溯到20多年前，在最近的过去，主流使用获得了牵引力，其在OpenSSL中的使用突出了这一点。然而，MikroTik没有实现这个SRP协议。相反，RouterOS使用椭圆曲线SRP（EC-SRP），特别是EC-SRP5。该协议的流行程度要低得多，其定义顺序如下：</p><p>  The router generates a 16-byte user  salt and calculates the user’s password verifier,  v, according to the equation  v = ECDH(SHA2(salt | SHA2(username | “:” | password)))  [1]</p><p>路由器生成一个16字节的用户salt，并根据等式v=ECDH（SHA2（salt | SHA2（username |“：“| password））[1]计算用户的密码验证器v</p><p> The router stores  username,  salt, and  v’s x coordinate,  v x, in memory in  /rw/store/user.dat</p><p>路由器将用户名salt和v的x坐标vx存储在/rw/store/user的内存中。dat</p><p>   The client generates an ephemeral private key,  Tc, and computes its ephemeral public key point  Wc = ECDH(Tc). The client sends an authentication request including  username and the point’s x coordinate,  Wc x, as its ephemeral public key Since each elliptic curve x coordinate has two y solutions,  (x, y) and  (x, -y), the client also transmits the parity of the generated point’s y coordinate,  Wc y, to ensure the server calculates the identical point and not its negation</p><p>客户端生成临时私钥Tc，并计算其临时公钥Wc=ECDH（Tc）。客户端发送一个身份验证请求，包括用户名和点的x坐标Wc x，作为其临时公钥，因为每个椭圆曲线x坐标有两个y解（x，y）和（x，-y），客户端还传输生成点的y坐标Wc y的奇偶校验，以确保服务器计算相同的点，而不是其否定</p><p> The server retrieves the associated client’s  salt and  v x. The server then generates an ephemeral private key,  Ts, and computes a password-entangled public key point,  Ws = ECDH(Ts) + plot(SHA2(v x))  [2]. Finally, the server responds with  Ws x and  salt The server similarly calculates and transmits the parity of its public point’s y coordinate,  Ws y</p><p>服务器检索相关客户端的salt和Vx。然后，服务器生成临时私钥Ts，并计算密码纠缠的公钥点Ws=ECDH（Ts）+plot（SHA2（Vx））[2]。最后，服务器用Ws-x和salt进行响应。服务器同样计算并传输其公共点的y坐标Ws-y的奇偶性</p><p>  The client, now knowing the user’s  salt and the server’s public key, can compute the shared secret and confirmation code as follows: Calculates  v&#39;s private key,  vp = SHA2(salt | SHA2(username | “:” | password))</p><p>客户机现在知道了用户的salt和服务器的公钥，可以按如下方式计算共享密钥和确认码：计算v&#39；s私钥，vp=SHA2（salt | SHA2（用户名|“：“|密码））</p><p>       Calculates the shared point,  z, using elliptic curve multiplication with the previously calculated  u point to find  z = u(Tc + h.v)</p><p>计算共享点z，使用椭圆曲线与之前计算的u点相乘，以找到z=u（Tc+h.v）</p><p>  The server computes the shared secret point,  z, as follows: Performs a final elliptic curve scalar multiplication using the server’s private key to yield  z = Ts(Wc + h.v)</p><p>服务器计算共享秘密点z，如下所示：使用服务器的私钥执行最终的椭圆曲线标量乘法，以产生z=Ts（Wc+h.v）</p><p> The server validates the username and password by similarly calculating  Cc and checking against the client provided value.  [3]</p><p>服务器通过类似地计算Cc并检查客户端提供的值来验证用户名和密码。[3]</p><p>   The server and client can encrypt data once confirming an equivalent shared secret. MikroTik employs a MAC-then-encrypt strategy, leveraging AES-CBC as the encryption algorithm and HMAC as the authentication algorithm. RouterOS also uses separate send and receive keys for both HMAC and AES, labeled below as  AES s, AES r, HMAC s, HMAC r. Both server and client generate these keys using “magic” strings and the HMAC key derivation function, HKDF. Messages prepend encrypted data with the unique random initialization vector,  IV, used in AES-CBC mode.</p><p>一旦确认了一个等效的共享秘密，服务器和客户端就可以对数据进行加密。MikroTik采用MAC-then加密策略，利用AES-CBC作为加密算法，HMAC作为身份验证算法。RouterOS还为HMAC和AES使用单独的发送和接收密钥，下面标记为AES s、AES r、HMAC s、HMAC r。服务器和客户端都使用“魔术”字符串和HMAC密钥派生函数HKDF生成这些密钥。消息使用AES-CBC模式中使用的唯一随机初始化向量IV预先发送加密数据。</p><p>     This is undoubtedly a complicated procedure, and involves many more steps than standard elliptic curve Diffie Hellman or previous RouterOS protocols that simply checked password hashes. But the difficulty does not end there; this protocol is additionally complicated by MikroTik’s elliptic curve choices. RouterOS authentication uses a standard Montgomery curve, such as the popular donna25519 library, for some calculations,  but not all. And it unfortunately does not use the NaCl/libsodium default Ed25519 Edwards curve. Rather, for either added efficiency or obscurity (or a bit of both), RouterOS performs most calculations over the standard Weierstrass curve:  Y 2=X 3+aX+b. Furthermore, it calculates points in weighted projective space  P(2,3,1) for even greater computation efficiency. This yields the Weierstrass equation:  y 2=x 3+axz 4+bz 6, where  Y=y/z 3 and  X=x/z 2.</p><p>这无疑是一个复杂的过程，涉及的步骤比标准的椭圆曲线Diffie-Hellman或以前的RouterOS协议（它们只是检查密码散列）多得多。但困难并不止于此；这个协议由于MikroTik的椭圆曲线选择而变得更加复杂。RouterOS身份验证使用标准的蒙哥马利曲线（如流行的Donna2519库）进行某些计算，但不是全部。不幸的是，它没有使用NaCl/LiB默认的Ed25519 Edwards曲线。相反，为了提高效率或模糊度（或两者兼而有之），RouterOS在标准Weierstrass曲线上执行大多数计算：Y 2=X 3+aX+b。此外，它计算加权投影空间P（2,3,1）中的点，以获得更高的计算效率。这就产生了Weierstrass方程：y2=x3+axz4+bz6，其中y=y/z3和x=x/z2。</p><p>   Confused? Understandably so. The result of everything previously detailed is an authentication protocol with copious elliptic curve calculations across three different curve varieties: Montgomery curves, Weierstrass curves in affine form ( Z=1), and Weierstrass curves in weighted projective space. This requires conversions to and from different curves and projective spaces, which makes following the authentication flow extremely difficult. The  Python POC examples detail the sequence specifically, though the following high-level overview might be better suited for some interested readers:</p><p>困惑的这是可以理解的。前面详细介绍的所有内容的结果都是一个认证协议，其中包含三种不同曲线类型的大量椭圆曲线计算：蒙哥马利曲线、仿射形式的Weierstrass曲线（Z=1）和加权投影空间中的Weierstrass曲线。这需要在不同的曲线和投影空间之间进行转换，这使得遵循身份验证流程非常困难。Python POC示例详细介绍了该序列，不过下面的高级概述可能更适合一些感兴趣的读者：</p><p> The  ECDH() equation generates a public key,  pub, by multiplying private key,  priv, by base point  g on the Weierstrass curve in  weighted projective space. This returns the point  (xw : yw : zw). The function then converts the point to Weierstrass affine form and further converts to Montgomery form; specifically, the function calculates the Weierstrass affine coordinate   X=x/z 2 and converts  X to Montgomery form This is odd because the private key is multiplied over the Weierstrass curve, but the public key returned is the x coordinate in Montgomery form</p><p>ECDH（）方程通过将私钥priv乘以加权射影空间中Weierstrass曲线上的基点g来生成公钥pub。这将返回点（xw:yw:zw）。然后，该函数将点转换为Weierstrass仿射形式，并进一步转换为Montgomery形式；具体来说，该函数计算Weierstrass仿射坐标X=X/z 2，并将X转换为蒙哥马利形式。这很奇怪，因为私钥在Weierstrass曲线上相乘，但返回的公钥是蒙哥马利形式的X坐标</p><p> The  plot() function plots a given x coordinate on the Weierstrass curve in affine form. Therefore, it returns a Weierstrass point  (X : Y : 1) Interestingly, it actually performs this operation by first plotting the point on the Montgomery curve and converting the x coordinate by adding constant  a/3 (where  a is the Montgomery curve constant from the curve’s equation  Y 2=X 3+aX 2+X)</p><p>函数的作用是：在Weierstrass曲线上以仿射形式绘制给定的x坐标。因此，它返回一个Weierstrass点（X:Y:1）。有趣的是，它实际上是通过首先在蒙哥马利曲线上绘制该点并通过添加常数a/3（其中a是曲线方程Y 2=X 3+aX 2+X中的蒙哥马利曲线常数）来转换X坐标来执行此操作的</p><p> All point multiplication and addition over the Weierstrass curve are performed in weighted projective space. Thus, any returned parameters (e.g., shared secret point  z, public keys  Wc and  Ws) must be converted to Weierstrass affine form</p><p>Weierstrass曲线上的所有点乘和加法都是在加权投影空间中进行的。因此，任何返回的参数（例如，共享秘密点z、公钥Wc和Ws）都必须转换为Weierstrass仿射形式</p><p> The picture becomes a bit clearer with those considerations in mind. The subtle choice of using Weierstrass curves for public key calculations makes an obscure protocol even more challenging to replicate. Considering all the intricacies outlined, it is no surprise that this authentication scheme was not reproduced in a public implementation until now.</p><p>考虑到这些因素，情况变得更清楚了。使用Weierstrass曲线进行公钥计算的微妙选择使得一个模糊的协议更难复制。考虑到所概述的所有复杂性，毫不奇怪，直到现在，这种身份验证方案还没有在公共实现中复制。</p><p>  We hope so. This cryptographic reverse engineering effort had a little bit of everything: an obscure protocol, multiple elliptic curve definitions, and conversions from weighted projective space. If you are hungry for more, or want to put yourself through further technical torture, please see the source code and additional commentary in our  GitHub repo. But wait! For those who are truly insatiable, there&#39;s more. The single best resource we used in reverse engineering was an unfinished  IEEE submission draft courtesy of the WayBack Machine. In fact, MikroTik&#39;s implementation is  nearly identical to the draft&#39;s proposed protocol. See if you can spot the minor nuances and marvel (as we did) that the shared secret remains the same.</p><p>我们希望如此。这项加密逆向工程的工作包含了一点所有内容：一个模糊的协议、多个椭圆曲线定义，以及从加权投影空间进行的转换。如果你渴望得到更多，或者想让自己经受进一步的技术折磨，请参阅我们GitHub repo中的源代码和附加注释。但是等等！对于那些真正贪得无厌的人来说&#39；还有更多。我们在逆向工程中使用的最好的资源是一个未完成的IEEE提交草案，这是由回程机器提供的。事实上，米克罗蒂克&#39；其执行情况与草案几乎相同&#39；他提议的协议。看看你是否能发现细微的差别，并惊叹（就像我们所做的那样）共享的秘密仍然是一样的。</p><p>  [1]  ECDH() accepts a private key as input and returns the associated elliptic curve public key, as in elliptic curve Diffie Hellman. This is replicated by the  gen_public_key method in  elliptic_curves.py’s  WCurve class</p><p>[1] ECDH（）接受私钥作为输入，并返回相关的椭圆曲线公钥，如椭圆曲线Diffie-Hellman。这是通过椭圆曲线中的gen_公钥方法复制的。py的WCurve课程</p><p> [2]  plot() accepts an x coordinate and returns the corresponding point on the elliptic curve. This is replicated by the  lift_x method in  elliptic_curves.py’s  WCurve class</p><p>[2] plot（）接受x坐标并返回椭圆曲线上的对应点。在椭圆曲线中，lift_x方法可以复制这一点。py的WCurve课程</p><p> [3] The server may complete the authentication handshake by sending a server confirmation code,  Cs, for the client to validate the server’s authenticity. In the case of the Winbox protocol,  Cs = SHA2(h + Cc + zx)</p><p>[3] 服务器可以通过向客户端发送服务器确认码Cs来完成认证握手，以验证服务器的真实性。在Winbox协议的情况下，Cs=SHA2（h+Cc+zx）</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/认证/">#认证</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/曲线/">#曲线</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>