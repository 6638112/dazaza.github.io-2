<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Ascii Ray Franing介绍 An Introduction to ASCII Ray Marching</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">An Introduction to ASCII Ray Marching<br/>Ascii Ray Franing介绍 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-08 02:20:23</div><div class="page_narrow text-break page_content"><p>In preparation for my computer graphics exam next week, I decided to take an excursion to the low-level side of things: ray marching ASCII graphics of rotating spheres!</p><p>为下周准备我的电脑图形考试，我决定接受事物的低级方面的游览：光线游行旋转球体的ASCII图形！</p><p>        Object-order rendering is the technique commonly used for both games and visualizations alike: APIs like OpenGL allow you to draw objects made up from primitives like triangles piece by piece. The primitives are projected into 2D, depth-tests are made to ensure objects behind another one are invisible and finally, they are coloured in pixel by pixel. This way, you „rasterize“ a 3D-object onto your screen.</p><p>        对象渲染是常用于游戏和可视化的技术相似：API如OpenGL，允许您绘制从基元像三角形块等原语组成的对象。将原语投射到2D中，进行深度测试，以确保另一个人背后的物体是看不见的，最后，它们以像素上的像素上彩色。这样，您将在屏幕上“将”3D对象“括号”。</p><p>  Image-order rendering takes a different approach, however: you do not fill the screen object after object, but pixel after pixel. So instead of looking at a triangle and figuring out where to draw it on the screen, you take a single pixel of the screen and figure out what colour it might be. As light rays emitted by a light source hit an object, some of them are reflected into the eye or camera of the observer. Since lots of light rays are emitted but never actually hit the camera, it is much more efficient to trace them backwards: send out “rays” from the camera, determine where they hit an object and then see if the path to the light source is occluded. This technique can allow for much more realistic graphics, seen with modern technology like the NVIDIA RTX GPUs that employ a mixture of object-order and image-order rendering.</p><p>  图像排序呈现采用不同的方法，但是：您不会在对象之后填充屏幕对象，但像素之后的像素。因此，而不是查看三角形并弄清楚在屏幕上绘制的地方，你拍摄屏幕的一个像素，并找出它可能的颜色。随着光源发射的光线击中物体，其中一些被反射到观察者的眼睛或相机中。由于发射了很多光线但从未实际击中相机，则追溯到追溯它们更有效：从相机发送“光线”，确定它们在何处击中对象，然后看看光源的路径是否为闭塞。这种技术可以允许更逼真的图形，与现代技术相似，如NVIDIA RTX GPU，该技术采用了对象阶和图像级渲染的混合。</p><p>  While these techniques  can be used to produce high-quality images, in this article we will try to render an image made up of ASCII characters into the terminal. It can be easily adapted to output image files, though.</p><p>  虽然这些技术可用于产生高质量的图像，但在本文中，我们将尝试将由ASCII字符组成的图像渲染到终端中。但是，它可以很容易地适应输出图像文件。</p><p>    In this article, we will focus on image-order rendering, and ray marching in particular. Where ray tracing consists of a scene made up of primitives whose intersections with the ray are calculated using “fixed” algorithms, ray marching represents the scene implicitly by a  surface distance function. It maps a point in space to a lower limit of the distance to the nearest object in the scene – similar to radar, it tells us how much further we can go without hitting anything.</p><p>    在本文中，我们将专注于图像级渲染，特别是射线。其中光线跟踪由使用“固定”算法计算与光线交叉点的基元组成的场景，光线游行通过表面距离功能隐式表示场景。它将空间中的一个点映射到场景中最近对象的距离的下限 - 类似于雷达，它告诉我们我们可以进一步走得更远而不击中任何东西。</p><p>    Figure 1 illustrates the process of ray marching. We start with the ray  r, evaluate the surface distance function (SDF) at that position and obtain the red perimeter. We continue to walk in the ray direction until we intersect the perimeter and evaluate the SDF again. In this case, we did not hit any object and the ray will continue until eternity (or floating-point overflow, in this case).</p><p>    图1说明了光线游行的过程。我们从Ray R开始，评估该位置的表面距离功能（SDF）并获得红色周长。我们继续走进光线方向，直到我们与周边相交并再次评估SDF。在这种情况下，我们没有击中任何对象，并且光线将继续直到永恒（或浮点溢出，在这种情况下）。</p><p>    Figure 2 shows what happens if we near a surface: the perimeter will get smaller and smaller, until it hits a certain threshold and we consider it a collision with the surface.</p><p>    图2显示了如果我们靠近表面：周长会变得更小，更小，直到它击中某个阈值，我们认为它与表面碰撞。 </p><p>  If we shoot a ray for each pixel on the screen (our ASCII character in a terminal), we should be able to render a 3D scene. Let us jump into the code!</p><p>如果我们在屏幕上的每个像素射出光线（我们的终端中的ASCII字符），我们应该能够渲染3D场景。让我们跳入代码！</p><p>    I will be using C with a little bit of C++ mixed in, running on a Linux machine. You will find the complete source at the bottom of this page.</p><p>    我将使用C的C ++混合使用C，在Linux机器上运行。您将在此页面底部找到完整的源。</p><p>      The first method will do the actual ray marching: sending out a ray and following it until it hits an object. It then calls shade with the surface position as a parameter, which will calculate how well illuminated that spot is. sdf is the surface distance function that is needed for ray traversal.</p><p>      第一种方法将进行实际的光线行程：发出光线并跟随它直到击中对象。然后它将阴影称为曲面位置作为参数，这将计算该点的发光程度。 SDF是射线遍历所需的表面距离功能。</p><p>    First, we will need a data structure to store points in 3D space.  vec3 is its name, short for three-dimensional vector:</p><p>    首先，我们需要一个数据结构来存储3D空间中的点。 vec3是它的名称，三维向量短：</p><p>    Pretty standard so far. Now we add some operators so we can add and subtract them and methods to determine their length:</p><p>    到目前为止漂亮的标准。现在我们添加了一些运算符，因此我们可以添加和减去它们和方法来确定它们的长度：</p><p>  float  length ()  {  return  sqrt ( x * x  +  y * y  +  z * z );  }  void  normalize ()  {  float  vectorlength  =  length ();  x  =  x  /  vectorlength ;  y  =  y  /  vectorlength ;  z  =  z  /  vectorlength ;  }  struct  vec3  operator * ( float  fac )  {  struct  vec3  r ;  r . x  =  x  *  fac ;  r . y  =  y  *  fac ;  r . z  =  z  *  fac ;  return  r ;  }  struct  vec3  operator + ( struct  vec3  other )  {  struct  vec3  r ;  r . x  =  x  + other . x ;  r . y  =  y  + other . y ;  r . z  =  z  +  other . z ;  return  r ;  }  struct  vec3  operator - ( struct  vec3  other )  {  struct  vec3  r ;  r . x  =  x  -  other . x ;  r . y  =  y  -  other . y ;  r . z  =  z  -  other . z ;  return  r ;  } } ;</p><p>  浮动长度（）{返回Sqrt（x * x + y * y + z * z）; void normalize（）{float vectorLength = length（）; x = x / vectorLength; y = y / vectorLength; z = z / vectorLength; } struct vec3运算符*（float fac）{struct vec3 r; r。 x = x * fac; r。 y = y * fac; r。 z = z * fac;返回r; } struct vec3运算符+（struct vec3其他）{struct vec3 r; r。 x = x +其他。 X ; r。 y = y +其他。 y; r。 z = z +其他。 Z;返回r; } struct vec3运算符 - （struct vec3其他）{struct vec3 r; r。 x = x  - 其他。 X ; r。 y = y  - 其他。 y; r。 z = z  - 其他。 Z;返回r; }};</p><p>  normalize can be used to preserve the direction of the vector and make sure it has a length of 1.</p><p>  标准化可用于保留载体的方向，并确保其长度为1。 </p><p>    As a display, we use a frame buffer that stores the value of each pixel. A pixel can be one of seven ASCII characters defined in the string  pixels.</p><p>作为显示，我们使用存储每个像素的值的帧缓冲区。像素可以是字符串像素中定义的七个ASCII字符之一。</p><p>  #include &lt;math.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#define WIDTH 80#define HEIGHT 40 static  char  framebuffer [ HEIGHT  *  WIDTH ]; const  int  npixels  =  7 ; const  char  * pixels  =  &#34; .:+|0#&#34; ;</p><p>  #include＆lt; math.h＆gt; #include＆lt; unistd.h＆gt; #include＆lt; time.h＆gt; #define宽度80＃定义高度40静态char framebuffer [高度*宽度]; Const int npixels = 7; const char * pixels =＆＃34; 。：+ | 0＃＆＃34; ;</p><p>      Next up, we will implement the function that does the actual raymarching: it iterates over each xy-coordinate and shoots off a ray. The camera will be at position (0, 0, -3), so that is where our ray will start. We position the screen a little bit in front of the camera and send a ray from the cameras origin „through“ the pixel  target (see figure 3). We must correct the y-coordinate a bit, because the screen is usually not a perfect square.</p><p>      接下来，我们将实现实际横梁的函数：它迭代每个XY坐标并射击光线。相机将处于位置（0，0，-3），因此这就是我们的光线将开始的位置。我们将屏幕定位在相机前面有点一点点，并从相机原产地发送射线“通过”像素目标（参见图3）。我们必须纠正y坐标一点，因为屏幕通常不是完美的正方形。</p><p>  void  raymarch ()  {  for  ( int  y  =  0 ;  y  &lt;  HEIGHT ;  y ++ )  {  for  ( int  x  =  0 ;  x  &lt;  WIDTH ;  x ++ )  {  struct  vec3  pos  =  { 0.0 ,  0.0 ,  - 3.0 };  struct  vec3  target  =  {  x  /  ( float )  WIDTH  -  0.5 f ,  ( y  /  ( float )  HEIGHT  -  0.5 f )  *  ( HEIGHT  /  ( float )  WIDTH )  *  1.5 f ,  - 1.5 f  };  struct  vec3  ray  =  target  -  pos ;  ray . normalize ();</p><p>  void raymarch（）{for（int y = 0; y＆lt;高度; y ++）{for（int x = 0; x＆lt;宽度; x ++）{struct vec3 pos = {0.0,0.0，0.0， -  3.0 }; struct vec3目标= {x /（浮点）宽度 -  0.5 f，（y /（浮点）高度 -  0.5 f）*（高度/（浮点）宽）* 1.5 f， -  1.5 f}; struct vec3 ray = target  -  pos;射线 。正常化（）;</p><p>  The ray must be normalized: later, we want to multiply it by the sdf to get the new position  pos. If the length of the ray would not be 1, we might end up overshooting and landing inside the object.</p><p>  光线必须归一化：稍后，我们希望将其乘以SDF来获取新位置POS。如果光线的长度不会是1，我们可能会最终超过物体内部的过冲和降落。</p><p>  After the ray is initialized, we can start marching in its direction. We employ another for loop here, the 3rd nested for-loop! You might begin to understand why ray marching is deemed computationally expensive. We also store the pixel value  pxl the ray returned and initialize it with the first pixel value (which is a space).  dist will hold the value of the SDF and tells us how far out the object lies.  max is an upper limit on how far we will march.</p><p>  初始化射线后，我们可以在其方向开始。我们在这里雇用另一个循环，第3个嵌套for-loop！您可能开始了解为什么雷行军被视为计算昂贵。我们还将像素值PXL存储返回的光线并用第一个像素值（这是空格）初始化。 DIST将持有SDF的价值并告诉我们对象的谎言有多远。 Max是我们将三月有多远的上限。</p><p>  char  pxl  =  pixels [ 0 ];  float  dist ;  float  max  =  9999.0 f ;  for  ( int  i  =  0 ;  i  &lt;  15000 ;  i ++ )  {  if  ( fabs ( pos . x )  &gt;  max 		 ||  fabs ( pos . y )  &gt;  max 		 ||  fabs ( pos . z )  &gt;  max ) 	 break ;</p><p>  char pxl =像素[0]; Float Dist; float max = 9999.0 f; for（int i = 0; i＆lt; 15000; i ++）{if（pos x）＆gt; max || fabs（pos。y）＆gt; max || fabs（pos。z）＆gt; max ） 	 休息 ; </p><p>  fabs is the absolute value of a floating-point number. As you can see, if a ray exceeds the max value in either dimension, we drop it and colour that pixel dark. Otherwise, we need to update the position: we evaluate the surface distance function and walk exactly that far into the direction of our ray:</p><p>Fabs是浮点数的绝对值。如您所见，如果光线超过任一维度超过最大值，则我们将其删除并颜色为像素暗。否则，我们需要更新位置：我们评估表面距离功能并将远距离进入我们的光线方向：</p><p>  dist  =  sdf ( pos );  if  ( dist  &lt;  1e-6 )  {  pxl  =  shade ( pos );  break ;  }  pos  =  pos  +  ray  *  dist ;  }  // end for (i)</p><p>  dist = sdf（pos）; if（dist＆lt; 1e-6）{pxl = shade（pos）;休息 ; pos = pos + ray * dist; } //结束（i）</p><p>  If the distance is less than 0.000001, we will assume we have hit the surface and call the  shade function to colour that pixel accordingly. In that case, we can also exit the inner for loop, since we have already hit an object. Otherwise, the for loop will continue to march, until the ray is either out of bounds or the maximum iteration count of 15000 is hit.</p><p>  如果距离小于0.000001，我们将假设我们已经击中了表面并呼叫阴影功能以相应地彩色该像素。在这种情况下，我们也可以退出内部循环，因为我们已经击中了一个对象。否则，for循环将继续3月，直到光线耗尽界限，或者击中15000的最大迭代计数。</p><p>  All that is left to do is writing the pixel value into the frame buffer, and returning from the function:</p><p>  剩余的所有这些都是将像素值写入帧缓冲区，并从函数返回：</p><p>  framebuffer [ y  *  WIDTH  +  x ]  =  pxl ;  }  // end for(x)  }  // end for(y) }  // end raymarch()</p><p>  FrameBuffer [Y * width + x] = PXL; } //结束（x）} // for（y）} //结束raymarch（）</p><p>  And that concludes the ray marching part of our program! Pretty short, considering it actually renders a 3D scene from scratch.</p><p>  这总结了我们计划的一部分的光线！很短，考虑到它实际上是从头开始的3D场景。</p><p>    Even though the  raymarch() function is complete, we have not talked once about the object we are going to render. For starters, we will keep it simple: a simple sphere at position (0,0,0) with a radius of 0.2 will suffice.</p><p>    即使Raymarch（）函数完成，我们也没有谈论我们将要渲染的对象。对于初学者来说，我们将保持简单：一个半径为0.2的位置（0,0,0）的简单球就足够了。 </p><p>    The surface distance function must tell us the distance to the nearest point on the surface. It will be positive for points outside of the object, negative for points inside the object and approximately zero on the surface. How might we calculate the SDF for a given position  pos? Simple: we subtract the sphere centre from the position and calculate the length of that vector. If we subtract the radius r from that value, we will obtain the distance of position to the surface. And that is exactly how the sdf function is implemented:</p><p>表面距离功能必须告诉我们到表面上最接近点的距离。它将在物体外部的点，物体内部的点数和表面上大约零的阳性。我们如何计算给定位置POS的SDF？简单：我们从位置中减去球体中心并计算该矢量的长度。如果我们从该值中减去半径r，我们将获得位置到表面的位置。这正是SDF功能的实施方式：</p><p>  float  sdf ( struct  vec3  pos )  {	 struct  vec3  center  =  { 0.0 ,  0.0 ,  0.0 };		 return  ( pos  -  center ). length ()  -  0.2 ; }</p><p>  Float SDF（STRUCT VEC3 POS）{STRUCT VEC3 CENTER = {0.0,0.0,0.0};返回（pos-center）。长度（） -  0.2; }</p><p>    For a quick test, we will use the simplest shading function imaginable: it simply colours all surface points with a “dark” character (#):</p><p>    为了快速测试，我们将使用可想而知的最简单的着色功能：它只是用“黑暗”字符（＃）颜色所有曲面点：</p><p>      This section is a bit boring: it contains the code for printing the frame buffer and clearing the screen. Feel free to skip over it.</p><p>      此部分有点镗孔：它包含用于打印帧缓冲区并清除屏幕的代码。随意跳过它。</p><p>  // Terminal clear sequence const  char  * cls_seq  =  &#34;\e[1;1H\e[2J&#34; ; void  cls ()  {  write ( 0 ,  cls_seq ,  10 ); } void  printfb ()  {  char  * fb  =  framebuffer ;  char  nl  =  &#39;\n&#39; ;  cls ();  for  ( int  y  =  0 ;  y  &lt;  HEIGHT ;  y ++ )  {  write ( 1 ,  fb ,  WIDTH );  write ( 1 ,  &amp; nl ,  1 );  fb  +=  WIDTH ;  } } int  main ()  {  for  ( int  i  =  0 ;  i  &lt;  WIDTH  *  HEIGHT ;  i ++ )  framebuffer [ i ]  =  &#39; &#39; ;  while ( true )  {  raymarch ();  printfb ();  sleep ( 1 );  } }</p><p>  //终端清除序列const char * cls_seq =＆＃34; \ e [1; 1h \ e [2j＆＃34; ; void cls（）{写（0，cls_seq，10）; void printfb（）{char * fb = framebuffer; char nl =＆＃39; \ n＆＃39; ; cls（）; for（int y = 0; y＆lt;高度; y ++）{写（1，fb，宽度）;写（1，＆amp; nl，1）; FB + =宽度; } int main（）{for（int i = 0; i＆lt;宽度*高度; i ++）framebuffer [i] =＆＃39; ＆＃39; ;而（true）{raymarch（）; printfb（）;睡眠（1）; }}</p><p>  In the main function, we clear the frame buffer and then enter an endless loop of ray marching and drawing the frame buffer.</p><p>  在主函数中，我们清除帧缓冲区，然后输入光线的无限循环并绘制帧缓冲区。</p><p>      $ g++ raymarcher1.cpp  -lm  -o raymarcher $ ./raymarcher  #####  ###########  #############  ###############  ###############  #################  ###############  ###############  #############  ###########  #####</p><p>      $ g ++ raymarcher1.cpp -lm -o raymarcher $ ./ raymarcher ##### ############################### ################################################## ##### ########################################### </p><p>  Lo and behold! It actually renders a sphere to the screen. It looks a bit boring, but that will change soon.</p><p>罗哈，看不见！它实际上是屏幕上的球体。它看起来有点无聊，但这很快就会改变。</p><p>      The first thing we are going to add is a timer, to spit out frames at the correct moment and to animate the sphere. To do that, we need to add the following to the beginning of our file:</p><p>      我们要添加的第一件事是一个计时器，吐出正确时刻的框架并为球体进行动画。为此，我们需要将以下内容添加到我们的文件开头：</p><p>      while ( true )  {  double  last_frame  =  t ;  raymarch ();  printfb ();  frame ++ ;  do  {  struct  timespec  time ;  clock_gettime ( CLOCK_REALTIME ,  &amp; time );  t  =  time . tv_sec  +  time . tv_nsec  *  1e-9 ;  }  while  (( t  -  last_frame )  &lt;  1.0  /  60.0 );  }</p><p>      虽然（true）{double last_frame = t; Raymarch（）; printfb（）;框架++; do {struct timespec时间; clock_gettime（clock_realtime，＆amp;时间）; t =时间。 tv_sec +时间。 TV_NSEC * 1E-9; }而（（t  -  last_frame）＆lt; 1.0 / 60.0）; }</p><p>  The last bit will wait for a 1/60th of a second before redrawing the screen.</p><p>  在重绘屏幕之前，最后一位将等待1/60的一秒。</p><p>    We kind of took a shortcut when writing the  shade function: it does not include any lighting and assigns the same brightness to each point on the sphere. To spice things up a bit, we are going to introduce a light source:</p><p>    在写阴影功能时，我们有点拍摄：它不包括任何照明，并为球体上的每个点分配相同的亮度。要有点香味，我们将介绍一个光源：</p><p>  char  shade ( struct  vec3  pos )  {  struct  vec3  L  =  { 		 50.0  *  sin ( t ), 		 20.0 , 		 50.0  *  cos ( t )  };  L . normalize ();</p><p>  Char Shade（struct vec3 pos）{struct vec3 l = {50.0 * sin（t），20.0,50.0 * cos（t）};湖正常化（）;</p><p>      Next, we are going to calculate the so-called normal: it is the vector that defines the orientation of the surface. It is exactly orthogonal to the tangential plane of our surface. In traditional rendering techniques (like object-based ordering), the normal would be part of the geometry we are rendering. In our case, with an SDF, we take a different path: if the normal points away from our surface point, that means it is going to be the direction where SDF grows most quickly. Calculus tells us that this direction is called the gradient and can be determined by deriving the function. So that is what we are going to do:</p><p>      接下来，我们将计算所谓的正常情况：它是定义表面方向的矢量。它与我们表面的切向平面恰好正交。在传统的渲染技术中（如基于对象的排序），正常是我们呈现的几何的一部分。在我们的案例中，通过SDF，我们采取了一个不同的路径：如果普通点远离我们的表面点，这意味着它将是SDF最快增长的方向。微积分告诉我们，这个方向被称为梯度，可以通过导出该功能来确定。这就是我们要做的事情： </p><p>  float  dt  =  1e-6 ;	 float  current_val  =  sdf ( pos );		 struct  vec3  x  =  { pos . x  +  dt ,  pos . y ,  pos . z };	 float  dx  =  sdf ( x )  -  current_val ;		 struct  vec3  y  =  { pos . x ,  pos . y  +  dt ,  pos . z };	 float  dy  =  sdf ( y )  -  current_val ;		 struct  vec3  z  =  { pos . x ,  pos . y ,  pos . z  +  dt };	 float  dz  =  sdf ( z )  -  current_val ;	 struct  vec3  N ;  // N for normal	 N . x  =  ( dx  -  pos . x )  /  dt ;	 N . y  =  ( dy  -  pos . y )  /  dt ;	 N . z  =  ( dz  -  pos . z )  /  dt ;</p><p>float dt = 1e-6; float clust_val = sdf（pos）; struct vec3 x = {pos。 x + dt，pos。 y，pos。 z}; float dx = sdf（x） -  current_val; struct vec3 y = {pos。 x，pos。 y + dt，pos。 z}; float dy = sdf（y） -  current_val; struct vec3 z = {pos。 x，pos。 y，pos。 z + dt}; Float Dz = SDF（Z） -  Current_Val; struct vec3 n; // n正常n。 x =（dx  -  pos。x）/ dt; ñ。 Y =（Dy-POS。Y）/ DT; ñ。 Z =（DZ  -  POS。Z）/ DT;</p><p>  Next up, we have to handle a case where the normal calculations fail. In that case, we abort the shading process and simply return a dark pixel:</p><p>  接下来，我们必须处理正常计算失败的情况。在这种情况下，我们中止了阴影过程，只需返回一个黑暗像素：</p><p>    A normal would not be a normal if it was not normalized, of course! Now that we have obtained the normal and the light vector, we can do basic Phong shading: in the seventies, smart scientists figured out an easy way to do a pretty good approximation of the lightness. They came up with the following formula:</p><p>    如果它当然没有正常化，正常不会是正常的！现在我们已经获得了正常和光矢量，我们可以做基本的Phong Sading：在七十年代，聪明的科学家们发现了一种简单的方法，可以做出非常好的亮度。他们提出了以下公式：</p><p>  Lightness = k ambient · c ambient + k diffuse · c diffuse · (L · N) + k specular · (R L · V) n · c specular</p><p>  灯光= k环境·C环境+ K漫射·C漫射·（L·N）+ k镜·（R L·V）N·C镜片</p><p>    ambient lighting, which is light that does not originate from one particular light source but just floats around the room. Its strength is given by the coefficient k ambient and its color is c ambient, which is an RGB vector with 3 components.</p><p>    环境照明，这是不源于一个特定光源的光，但只是漂浮在房间周围。其强度由系数k环境称为C，其颜色是C环境，其是具有3个组分的RGB载体。</p><p>  diffuse lighting, which is the light from a light source that is scattered when hitting the object’s surface. (L · N) is the dot product between the light vector and the normal vector, and since both have length 1, it is the cosine of the angle between the two. Since the cosine is close to one when the angle is small, the diffuse lighting is brighter when the light source shines from directly above the surface than if it is just above the “horizon”.</p><p>  漫射照明，其是来自光源的光，当撞击物体表面时散射。 （L·N）是光矢量和正常矢量之间的点产品，并且由于两者具有长度1，它是两者之间的角度的余弦。由于余弦靠近角度较小，因此当光源直接闪耀到表面上方的漫射照明比它在“地平线上方之上即可。</p><p>  specular lighting, which is a bright spot resulting from reflection. R L is the reflection vector.</p><p>  镜面照明，这是由反射产生的亮点。 R L是反射矢量。 </p><p>  We are going to ignore ambient and specular lighting and focus on just diffuse lighting. Since we do not have any coloured light, we can safely ignore the c diffuse component. So all that is left is the term (L · N) — we just need to calculate the dot product between light vector and the normal vector:</p><p>我们将忽略环境和镜面照明，专注于漫射照明。由于我们没有任何彩色光线，我们可以安全地忽略C漫射组件。所以剩下的就是术语（L·n） - 我们只需要计算光矢量和正常矢量之间的点产品：</p><p>  float  diffuse  =  L . x  *  N . x  +  L . y  *  N . y  +  L . z  *  N . z ;	 diffuse  =  ( diffuse  +  1.0 )  /  2.0  *  npixels ;</p><p>  float diffuse = l。 x * n。 x + l。 y * n。 y + l。 z * n。 Z; Diffuse =（Diffuse + 1.0）/ 2.0 * npixels;</p><p>  Since the dot product returns the cosine, which is in the range from -1 to 1, we add 1 and divide it by two so it is between 0 and 1. Then we multiply by the number of different pixel values. In the next bit, we are going to return the pixel with the closest brightness level:</p><p>  由于点产品返回余弦，这在-1到1的范围内，我们添加1并将其分两个，因此它在0到1之间。然后我们乘以不同像素值的数量。在下一点中，我们将以最接近的亮度级别返回像素：</p><p>    And that’s it. Compile it, run it, and see how much a little bit of shading can improve your graphics, even if running in a terminal!</p><p>    就是这样。编译它，运行它，看看一点点着色可以改善你的图形，即使在终端中运行！</p><p>      In just 128 lines of code, we were able to implement a ray marcher with basic Phong-shading and ASCII output. We were able to apply some multi-dimensional calculus (normal calculation) and geometry (SDF). A lot of things can be adapted and extended, especially since SDFs provide a pretty compact way of expressing scenes. Inigo Quilez has assembled a  comprehensive page of different SDFs.</p><p>      在仅需128行代码中，我们能够实现具有基本Phong-Shading和ASCII输出的射线游行。我们能够应用一些多维微积分（正常计算）和几何体（SDF）。很多东西都可以调整和扩展，特别是因为SDF提供了表达场景的非常紧凑的方式。 Inigo Quilez组装了一页不同SDF的综合页面。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ch-st.de/its-ray-marching-march/">https://ch-st.de/its-ray-marching-march/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ray/">#ray</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ascii/">#ascii</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/光线/">#光线</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>