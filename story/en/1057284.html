<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>一年的编译器模糊竞选活动 A Year in the Life of a Compiler Fuzzing Campaign</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A Year in the Life of a Compiler Fuzzing Campaign<br/>一年的编译器模糊竞选活动 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-09 23:05:28</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/38946b4e40e80ee3b42b0c5fe6224e1b.jpg"><img src="http://img2.diglog.com/img/2021/4/38946b4e40e80ee3b42b0c5fe6224e1b.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In the summer of 2020, we described our work fuzzing the Solidity compiler,  solc. So now we’d like to revisit this project, since fuzzing campaigns tend to “ saturate,” finding fewer new results over time. Did Solidity fuzzing run out of gas? Is fuzzing a high-stakes project worthwhile, especially if it has its own active and effective fuzzing effort?</p><p>在2020年夏天，我们描述了我们的工作模糊巩固编译器，Solc。所以现在我们想重新审视这个项目，因为模糊运动往往会“饱和”，以时间随着时间的推移找到较少的新结果。坚固的模糊耗尽气体吗？欺骗一个高赌注项目值得的，特别是如果它有自己的积极和有效的模糊努力？</p><p> The first bugs from that fuzzing campaign were submitted in February of 2020 using an  afl variant. Since then, we’ve submitted 74 reports. Sixty-seven have been confirmed as bugs, and 66 of those have been fixed. Seven were duplicates or not considered to be true bugs.</p><p> 使用AFL Variant的2月20日2月份提交了该模糊运动的第一个错误。从那时起，我们已经提交了74个报告。六十七被确认为错误，66人已得到修复。七个是重复的或不被认为是真正的错误。</p><p> Given that 21 of these bugs were submitted since last December, it’s fair to say that our fuzzing campaign makes a strong case for why independent fuzzing is still important and can find different bugs, even when OSSFuzz-based testing is also involved.</p><p> 鉴于自去年12月以来提交了21个错误，说我们的模糊运动为为什么独立的模糊仍然重要而且可以找到不同的错误，即使也在基于OSSFuzz的测试也是如此。</p><p> Why is it useful to keep fuzzing such a project perhaps indefinitely? The answer has three parts. First, more fuzzing covers more code execution paths and long fuzzing runs are especially helpful. It would be hard to get anywhere near path-coverage saturation with any fuzzer we know of. Even when running afl for 30 or more days, our tests still find new paths around every 1-2 hours and sometimes find new edges. Some of our reported bugs were discovered only after a month of fuzzing.</p><p> 为什么不确定地模糊这样的项目是有用的？答案有三个部分。首先，更具模糊涵盖更多的代码执行路径，长模常用尤为有用。在路径覆盖饱和子附近有任何我们所知道的任何模糊的地方，很难得到任何情况。即使在运行30天或更长时间时，我们的测试仍然在每1-2小时内找到新的路径，有时会找到新的边缘。我们报告的一些错误仅在一个月的模糊后被发现。</p><p> A production compiler is fantastically complex, so fuzzing in-depth is useful. It takes time to generate inputs such as the  most recent bug we found fuzzing the Solidity level of solc:</p><p> 生产编译器非常复杂，因此深入模糊很有用。生成输入需要时间，例如我们发现的最新错误，我们发现的SOLC的稳定性级别：</p><p> pragma experimental SMTChecker; contract  A {  function f()  internal virtual { v(); }  function v()  internal virtual { }} contract  B  is A {  function f()  internal virtual override { super.f(); }} contract  C  is B {  function v()  internal override {   if (0==1) f(); }}</p><p> Pragma实验SMTChecker;合同A {函数f（）内部虚拟{v（）; }函数v（）内部虚拟{}}合同b是{function f（）内部虚拟覆盖{super.f（）;合同C是B {函数v（）内部覆盖{if（0 == 1）f（）; }}</p><p> This code should compile without error, but it didn’t. Until the bug was fixed, it caused the SMT Checker to crash, throwing a fatal “Super contract not available” error, due to  incorrect contract context used for variable access in virtual calls inside branches.</p><p> 此代码应没有错误编译，但它没有。直到错误是固定的，它导致SMT检查器崩溃，抛出致命的“超合同不可用”错误，由于在分支机构内的虚拟呼叫中的可变访问权限不正确。 </p><p> Compilers should undergo fuzz testing for long stretches of time because of their complexity and number of possible execution paths. A rule of thumb is that afl hasn’t really started in earnest on any non-trivial target until it hits one million executions, and compilers likely require much more than this. In our experience, compiler runs vary anywhere from less than one execution per second to as many as 40 executions per second. Just getting to one million executions can take a few days!</p><p>编译器应该在长时间的时间内进行绒毛测试，因为它们的复杂性和可能的​​执行路径数量。经验法则是，在达到一百万个执行之前，AFL尚未在任何非琐碎的目标上真正开始，并且编译器可能需要多大程度上。在我们的经验中，编译器运行的任何地方都会在少于一个执行每秒到每秒40个执行。刚刚获得一百万个执行可能需要几天！</p><p> The second reason we want to fuzz independently alongside OSSFuzz is to approach the target from a different angle. Instead of strictly using a dictionary- or grammar-based approach with traditional fuzzer mutation operators, we used ideas from  any-language mutation testing to add  “code-specific” mutation operators to afl, and rely mostly (but not exclusively) on those, as opposed to afl’s even more generic mutations, which tend to be focused on binary format data. Doing something different is likely going to be a good solution to fuzzer saturation.</p><p> 我们希望独立于OSSFuzz的第二种原因是从不同的角度接近目标。而不是严格地使用传统的模糊突变运算符的基于字典或语法的方法，而是从任何语言突变测试中使用了思想，将“代码特定的”突变运算符添加到AFL，并依赖于那些（但不是完全），与AFL更通用的突变相反，这倾向于专注于二进制格式数据。做一些不同的事情可能会成为模糊饱和的良好解决方案。</p><p> Finally, we keep grabbing the latest code and start fuzzing on new versions of solc. Since the OSSFuzz continuous integration doesn’t include our techniques, bugs that are hard for other fuzzers but easy for our code-mutation approach will sometimes appear, and our fuzzer will find them almost immediately.</p><p> 最后，我们一直抓住最新的代码并开始对新版本的索尔公司进行模糊。由于OSSfuzz持续集成不包括我们的技术，因此有时会出现对其他模糊物而且易于用于我们的代码突变方法的错误，并且我们的模糊将立即找到它们。</p><p> But we don’t grab every new release and start over, because we don’t want to lose the ground that was gained with our long fuzzing campaigns. We also don’t continually take up where we left off since the tens of thousands of test corpora that afl can generate are likely full of uninteresting paths that might make finding bugs in the new code easier. We sometimes resume from an existing run, but only infrequently.</p><p> 但我们不抓住每一个新的释放并重新开始，因为我们不想失去与我们的长模糊的竞选活动获得的地面。我们也不会不断占据我们离开的地方，因为这是AFL可以生成的数万个测试Corpora可能充满了可能在新代码中发现错误的不感兴趣的路径。我们有时会从现有的运行中恢复，但不常。</p><p> Finding bugs in a heavily-fuzzed program like solc is not easy. The next best independent fuzzing effort to ours, that of Charalambos Mitropoulos, also mentioned by the solc team in their post of the OSSFuzz fuzzing, has only discovered 8 bugs, even though it’s been ongoing since October 2019.</p><p> 在Solc这样的严重模糊程序中找到错误并不容易。索尔曼团队在OSSFuzz窗口帖子中的索尔姆·米特罗斯的下一个最佳独立的模糊努力，也提到了Solc队伍，只会发现了8个错误，即使它自2019年10月以来一直在进行中。</p><p>  Our success with solc inspired us to fuzz other compilers. First, we tried fuzzing the  Vyper compiler—a language intended to provide a safer, Python-like, alternative to Solidity for writing Ethereum blockchain smart contracts. Our previous Vyper fuzzing uncovered some interesting bugs using essentially a grammar-based approach with the TSTL (Template Scripting Testing Language) Python library via python-afl.  We found a few bugs during this campaign, but chose not to go to extremes, because of the poor speed and throughput of the instrumented Python testing.</p><p>  我们的成功与Solc启发了我们欺骗其他编译器。首先，我们尝试模糊vyper编译器 - 一种旨在提供更安全，python的替代方面的语言，以稳定地编写国内区块链智能合同。我们以前的Vyper模糊通过Python-AFL使用基本上使用基于语法的方法使用基于语法的方法的一些有趣的错误。我们在这个广告系列中找到了一些错误，但选择不去极端，因为仪表般的Python测试的速度和吞吐量差。</p><p> In contrast, my collaborator, Rijnard van Tonder at Sourcegraph, had much greater success fuzzing the  Diem project’s Move language—the language for the blockchain formerly known as Facebook’s Libra. Here, the compiler is fast and the instrumentation is cheap. Rijnard has reported  14 bugs in the compiler, so far, all of which have been confirmed and assigned, and 11 of which have been fixed. Given that the fuzzing began just two months ago, this is an impressive bug haul!</p><p> 相比之下，我的合作师Rijnard Van Tonder在SourceGraph中，迪姆项目的移动语言更加壮大 - 被称为Facebook的Libra的区块链的语言。在这里，编译器很快，仪器便宜。 Rijnard在编译器中报告了14个错误，到目前为止，所有这些都已确认和分配，其中11个已被修复。鉴于这只是两个月前开始的模糊，这是一个令人印象深刻的虫子！ </p><p> Using Rijnard’s notes on fuzzing Rust code using afl.rs, I tried our tools on Fe, a  new smart contract language supported by the Ethereum foundation. Fe is, in a sense, a successor to Vyper, but with more inspiration from Rust and a much faster compiler. I began fuzzing Fe on the date of its first alpha release and submitted my first issue nine days later.</p><p>使用RIJNARD关于使用AFL.RS模糊锈蚀码的注释，我尝试了我们的工具，以Ethereum基金会支持的新智能合同语言。在某种意义上，FE是vyper的继承者，但是从生锈和更快的编译器中有更多的灵感。我在第一个alpha发布之日开始模糊FE，并在九天后提交了我的第一个问题。</p><p>  To support my fuzzing campaign, the Fe team changed failures in the Yul backend, which uses solc to compile Yul, to produce Rust panics visible to afl, and we were off to the races. So far, this effort has produced  31 issues, slightly over 18% of all GitHub issues for Fe, including feature requests. Of these, 14 have been confirmed as bugs, and ten of those have been fixed; the remaining bugs are still under review.</p><p>  为了支持我的模糊运动，FE团队在YUL后端改变了失败，它使用SOLC编译YUL，以产生AFL可见的生锈恐慌，我们已离开赛道。到目前为止，这项努力已经产生了31个问题，占FE的所有GitHub问题的18％以上，包括特征请求。其中，14已经被证实为虫子，其中十是固定的;剩下的错误仍在审查中。</p><p> We didn’t just fuzz smart contract languages. Rijnard fuzzed the  Zig compiler—a new systems programming language that aims at simplicity and transparency and found two bugs ( confirmed, but not fixed).</p><p> 我们不仅仅是Fuzz Smart合同语言。 RIJNARD模糊了ZIG编译器 - 一种新的系统编程语言，旨在简单和透明度，并发现两个错误（确认，但不固定）。</p><p>  We uncovered 88 bugs that were fixed during our afl compiler fuzzing campaign, plus an additional 14 confirmed, but not yet fixed bugs.</p><p>  我们发现在我们的AFL编译器模糊运动期间修复的88个错误，以及另外14个确认，但尚未修复错误。</p><p> What’s interesting is that the fuzzers aren’t using dictionaries or grammars. They know nothing about any of these languages beyond what is expressed by a modest corpus of example programs from the test cases. So how can we fuzz compilers this effectively?</p><p> 有趣的是，模糊不使用词典或语法。他们对超出了来自测试用例的示例程序的适度语料库表达的任何语言的任何语言都不了解。那么我们如何有效地模仿编译器？</p><p> The fuzzers operate at a regular-expression level. They don’t even use context-free language information. Most of the fuzzing has used  fast C string-based heuristics to make “code-like” changes, such as removing code between brackets, changing arithmetic or logical operators, or just swapping lines of code, as well as changing  if statements to  while and removing function arguments. In other words, they apply the kind of changes a mutation testing tool would. This approach works well even though Vyper and Fe aren’t very C-like and only Python’s whitespace, comma, and parentheses usage are represented.</p><p> 模糊物以常规表达水平运行。它们甚至没有使用无背景语言信息。大多数模糊都使用了基于快速的C字符串的启发式方法来使“代码类似”更改，例如递除括号，更改算术或逻辑运算符之间的代码，或者只是交换代码线，以及更改为陈述和删除函数参数。换句话说，他们应用这种改变的类型突变测试工具。即使Vyper和Fe不是非常的C形，刚刚的空格，逗号和括号使用，也可以很好地运作良好。</p><p> Custom dictionaries and language-aware mutation rules may be more effective, but the goal is to provide compiler projects with effective fuzzing without requiring many resources. We also want to see the impact that a good fuzzing strategy can have on a project during the early stages of development, as with the Fe language. Some of the bugs we’ve reported highlighted tricky corner cases for developers much earlier than might have otherwise been the case. We hope that discussions such as  this one will help produce a more robust language and compiler with fewer hacks made to accommodate design flaws detected too late to easily change.</p><p> 自定义词典和语言感知突变规则可能更有效，但目标是提供具有有效模糊的编译项目，而无需许多资源。与FE语言一样，我们还希望看到良好的模糊策略在项目期间可以对项目的影响。我们已经报告的一些错误突出显示的开发人员的棘手的角落案例早比可能是否则的情况。我们希望这一讨论，例如这一讨论将有助于生产更强大的语言和编译器，而且具有更少的黑客，以适应设计缺陷检测到的，以便轻松改变。 </p><p> We plan to keep fuzzing most of these compilers since the solc effort has shown that a fuzzing campaign can remain viable for a long time, even if there are other fuzzing efforts targeting the same compiler.</p><p>我们计划自从SOLC努力表明，长时间的模糊运动可以保持可行的模糊运动，即使还针对相同的编译器的其他模糊努力，我们都可以继续模糊这些编译器。</p><p> Compilers are complex and most are also rapidly changing. For example, Fe is a brand-new language that isn’t really fully designed, and Solidity is well-known for making dramatic changes to both user-facing syntax and compiler internals.</p><p> 编译器很复杂，大多数也在迅速变化。例如，FE是一种不完全全新的全新语言，并且众所周知，对用户面向用户的语法和编译内部的剧烈更改众所周知。</p><p> We’re also talking to Bhargava Shastry, who leads the internal fuzzing effort of Solidity, and applying some of the semantic checks they apply in their protobuf-fuzzing of the Yul optimization level ourselves. We started directly fuzzing Yul via solc’s strict-assembly option, and we already found one  amusing bug that was quickly fixed and incited  quite a bit of discussion! We hope that the ability to find more than just inputs that crash solc will take this fuzzing to the next level.</p><p> 我们还与Bhargava Shastry交谈，他领导着坚固的内部模糊努力，并应用了一些语义检查，他们在他们自己的Protobuf-fuzzing中应用了它们。我们通过Solc的严格组装选项开始直接模糊yul，我们已经发现了一个有趣的错误，这是快速修复和煽动了相当多的讨论！我们希望能够找到不仅仅是仅仅输入崩溃索尔科将把这种模糊的输入达到下一级别。</p><p> The issue at large is whether fuzzing is limited to the bugs it can find due to the inability of a compiler to detect many wrong-code errors.  Differential comparison of two compilers, or of a compiler with its own output when optimizations are turned off, usually requires a much more restricted form of the program, which limits the bugs you find, since programs must be compiled and executed to compare results.</p><p> 大大问题是由于编译器无法检测到许多错误代码错误，模糊都限制了它可以找到的错误。在关闭优化时，两个编译器或编译器的差异比较，并且在优化时的输出，通常需要更多的程序的限制形式，这限制了所发现的错误，因为必须编译和执行程序以比较结果以比较结果。</p><p> One way to get around this problem is to make the compiler crash more often. We imagine a world where compilers include something like a testing option that enables aggressive and expensive checks that wouldn’t be practical in normal runs, such as  sanity-checks on register allocation. Although these checks would likely be too expensive for normal runs, they could be turned on for both some fuzzing runs, since the programs compiled are usually small, and, perhaps even more importantly, in final production compilation for extremely critical code (Mars Rover code, nuclear-reactor control code — or high-value smart contracts) to make sure no wrong-code bugs creep into such systems.</p><p> 解决这个问题的一种方法是使编译器更频繁地崩溃。我们想象一个编译器包括像测试选项的内容的世界，这使得能够在正常运行中不能实际的攻击性和昂贵的检查，例如在寄存器分配上的Sanity-Checks。虽然这些检查可能太昂贵，但对于正常运行可能是过于昂贵的，但它们可以打开一些模糊运行，因为编译的节目通常很小，并且甚至更重要的是，在最终的批判代码中的最终生产汇编中（Mars Rover Code ，核 - 反应堆控制代码或高价值智能合同），以确保没有错误代码错误蠕动到这样的系统中。</p><p> Finally, we want to educate compiler developers and developers of other tools that take source code as input, that effective fuzzing doesn’t have to be a high-cost effort requiring significant developer time. Finding crashing inputs for a compiler is often easy, using nothing more than some spare CPU cycles, a decent set of source code examples in the language, and the  afl-compiler-fuzzer tool!</p><p> 最后，我们希望教育将源代码作为输入的源代码的其他工具的编译器开发人员和开发人员，这种有效的模糊不一定是需要显着开发人员时间的高成本工作。查找编译器的崩溃输入通常很容易，只使用了一些备用CPU周期，语言中的一组体面的源代码示例，以及AFL-Compiler-fuzzer工具！</p><p> We hope you enjoyed learning about our long-term compiler fuzzing project, and we’ve love to hear about your own fuzzing experiences on Twitter @trailofbits.</p><p> 我们希望您喜欢了解我们的长期编译器模糊项目，我们喜欢听到您在Twitter @trailofbits上的虚拟体验。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.trailofbits.com/2021/03/23/a-year-in-the-life-of-a-compiler-fuzzing-campaign/">https://blog.trailofbits.com/2021/03/23/a-year-in-the-life-of-a-compiler-fuzzing-campaign/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/life/">#life</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>