<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Decompiling Flacuffers案例研究：Facebook的GraphQL架构（2020） Decompiling FlatBuffers case study: Facebook's GraphQL schema (2020)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Decompiling FlatBuffers case study: Facebook's GraphQL schema (2020)<br/>Decompiling Flacuffers案例研究：Facebook的GraphQL架构（2020） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-22 11:51:17</div><div class="page_narrow text-break page_content"><p>Back in 2017, while looking for an open-source client for Facebook&#39;s Messenger,I stumbled upon  fbchat.A project that implements an open-source interface for Facebook&#39;s Messenger.Knowing full-well that Facebook did not officially expose that interface for user-to-user communication, I became intrigued.From what I knew from  libpurple&#39;s it would have had to use MQTT, but it was not the case.This implementation used a REST based API, digging through the source-code I found out it used a version of the GraphQL API.</p><p>回到2017年，同时寻找facebook的开源客户端，我偶然发现了fbchat.a项目，它为facebook实现了一个开源接口，而＃39; s messenger.knows facebook没有正式公开该界面进行用户到用户通信，我变得兴起。从Libpuleplple＆＃39;它必须使用mqtt，但这不是案例。这一实现使用了基于休息的API，挖掘通过我发现它使用了GraphQL API版本的源代码。</p><p> After digging a bit on the internet I realised that there existed no public documentation of this particular API.Except perhaps, the occasional blog-post about a few fields or methods. And of course, what the fbchat projectmanaged to dig-up.</p><p> 在互联网上挖掘一点之后，我意识到该特定API的公共文档可能是偶尔的博客文献，偶尔有关少数字段或方法。当然，FBCHAT项目管理到挖掘。</p><p> Source code for the provided files and a decoded schema can be found at:  fb-graphql-schema</p><p> 可以找到所提供文件和解码模式的源代码：fb-graphql-schema</p><p>  But API interfaces must be known publicly, at least by the clients of those APIs.And here begins our journey. And its first task, find a client for Facebook&#39;s GraphQL API.An easy task you say? Given that we all know about the Facebook for Android and Messenger apps, even Facebook Lite, it should be easy.Unfortunately not, we do not know in what format the schema is stored, it could be compressed, obfuscated, it might exist only as byte code.</p><p>  但是API接口必须公开，至少由这些API的客户端。在这里开始我们的旅程。及其第一批任务，为Facebook找到一个客户＆＃39; s graphql api.an轻松任务您说？鉴于我们都知道有关Android和Messenger应用程序的Facebook，甚至Facebook Lite，它应该是简单的。不幸的是，我们不知道以什么格式存储了模式，它可以压缩，混淆，它可能只存在于此字节代码。</p><p> And we have one more problem, how do we find it?This problem we can answer, at least by a simple heuristic, the schema must contain the type and field names.Fortunately for us some of them have already been provided by the fbchat project.We end up with a string search through Facebook&#39;s apps.Sample GraphQL queries can be found at  _graphql.py</p><p> 我们有一个问题，我们如何找到它？这个问题我们可以至少通过简单的启发式回答，这一模式必须包含类型和字段名称。对于我们的一些人已经由FBChat项目提供了一些类型和字段。 。我们最终通过Facebook＆＃39; s apps.sample graphql查询最终找到了一个字符串搜索，可以在_graphql.py中找到</p><p> I&#39;m more familiar with Android so that was my platform of choice.My first try was Facebook Lite, but I had no success.Next up, Facebook for Android(aka com.facebook.katana).The version we are going to discuss is v230.0.0.36.117 , given that I revisited the schema in 2019.</p><p> 我更熟悉Android，所以这是我的首选平台。我的首要尝试是Facebook Lite，但我没有成功。我没有成功.Next Up，Facebook for Android（Aka Com.facebook.katana）。我们要去的版本讨论是v230.0.0.36.117，因为我在2019年重新审视了这一架构。</p><p> In this case  apktool d -r gave me a decent start. The  -r flag is needed due to a bug in apktool.It disables the extraction of resources, but it won&#39;t affect the discussion.</p><p> 在这种情况下，Apktool D -R给了我一个体面的开始。由于APKTOOL中的错误，需要-R标志。它会禁用资源的提取，但它会影响讨论。 </p><p> Now, we can start looking for strings.We&#39;ll need a sufficiently uncommon string so that it doesn&#39;t match too many files, long ones are generally the best.So let&#39;s try  grep -R lightweight_event_creator. And more sure than not, we get:</p><p>现在，我们可以开始寻找字符串。我们需要一个足够罕见的字符串，以便它＆＃39; t匹配太多文件，长的是最好的。所以让＆＃39; s try grep -r lightweight_event_creator 。更肯定，我们得到：</p><p>    I was expecting a few months of dex reverse engineering, but the task seems to be a different one.We now have to deduce the file-type. Let&#39;s try:</p><p>    我期待几个月的DEX逆向工程，但任务似乎是一个不同的。我们现在必须推断文件类型。让＆＃39;试试：</p><p>  So it&#39;s a custom encoding, it might be ASN.1, a proprietary serialization, or anything else.This file must be read somewhere, so we might find a reference to it and hopefully to its format:</p><p>  所以它＆＃39; s一个自定义编码，它可能是ASN.1，专有序列化，或其他任何东西。这档案必须在某处读取，因此我们可能会发现对它的引用，并希望其格式有限：</p><p>  Nothing useful... the code could be obfuscated or downloaded from the internet.An Android installation might provide us with more information.Let&#39;s find out where it&#39;s used:</p><p>  没什么用的...代码可以从Internet被混淆或下载.Android安装可能会提供更多信息。＆＃39;查找它的位置和＃39; s使用的地方</p><p> $ adb root$ adb shellgeneric_arm64:/ # setenforce 0generic_arm64:/ # stopgeneric_arm64:/ # startgeneric_arm64:/ # strace -ff -i -s 500 -o /data/local/tmp/strace.zygote -p $(pidof zygote)generic_arm64:/ # grep -R graph_metadata.bin /data/local/tmp/strace.zygote.*strace.zygote.6690:[e893a7ac] pread64(31, &#34;assets/graph_metadata.bin&#34;, 25, 5584953) = 25</p><p> $ adb root $ adb shellgeneric_arm64：/＃setenforce 0generic_arm64：/＃stopgeneric_arm64：/＃startgeneric_arm64：/＃strace -ff -i-s 500 -o / data/local/tmp/strace.zygote -p $（pidof zygote）generic_arm64 ：/＃grep -r graph_metadata.bin /data/local/tmp/strace.zygote.*strace.zygote.6690:[e893a7ac] praead64（31，＆＃34;资产/ graph_metadata.bin＆＃34 ;,25,5584953 ）= 25.</p><p> And in this case we got nothing, or maybe. But it&#39;s not an open, nor an openat.We have an offset let&#39;s check that with the apk:</p><p> 在这种情况下，我们一无所获或也许。但它并非开放，也不是Openat。我们有一个偏移偏移量，＆＃39;■使用APK检查：</p><p>  So, it&#39;s there, we now have a hint to tell gdb what condition to break on:</p><p>  所以，它＆＃39;我们现在有一个提示告诉GDB什么条件打破： </p><p> $ adb forward tcp:4444 tcp:4444$ adb shellgeneric_arm64:/ # am set-debug-app com.facebook.katanageneric_arm64:/ # setprop wrap.com.facebook.katana &#39;gdbserver localhost:4444&#39;</p><p>$ adb转发tcp：4444 tcp：4444 $ adb shellgeneric_arm64：/ #am set-debug-app com.facebook.katanageNeric_arm64：/＃setprop wrap.com.facebook.katana＆＃39; gdbserver localhost：4444＆＃39;</p><p>    #0 0xf5b567a4 in pread64 () from target:/system/lib/libc.so [36/1861]#1 0xf6a768d8 in ?? () from target:/system/lib/libandroidfw.so#2 0xf6a73190 in android::ZipFileRO::findEntryByName(char const*) const () from target:/system/lib/libandroidfw.so#3 0xf6a65664 in android::AssetManager::openNonAssetInPathLocked(char const*, android::Asset::AccessMode, android::AssetManager::asset_path const&amp;) () from target:/system/lib/libandroidfw.so#4 0xf6a65bd6 in android::AssetManager::open(char const*, android::Asset::AccessMode) () from target:/system/lib/libandroidfw.so#5 0xf753c79e in AAssetManager_open () from target:/system/lib/libandroid.so#6 0xda7f928a in ?? () from target:/data/data/com.facebook.katana/lib-xzs/libcoldstart.so#7 0xda7f91ec in ?? () from target:/data/data/com.facebook.katana/lib-xzs/libcoldstart.so#8 0xda7f9160 in ?? () from target:/data/data/com.facebook.katana/lib-xzs/libcoldstart.so#9 0xda815bf0 in ?? () from target:/data/data/com.facebook.katana/lib-xzs/libcoldstart.so#10 0xda6efece in ?? () from target:/data/data/com.facebook.katana/lib-xzs/libcoldstart.so#11 0xda6f2186 in ?? () from target:/data/data/com.facebook.katana/lib-xzs/libcoldstart.so#12 0xda6f2012 in ?? () from target:/data/data/com.facebook.katana/lib-xzs/libcoldstart.so</p><p>    ＃0 0xf5b567a4在pread64（）中，来自目标：/system/lib/libc.so [36/1861]＃1 0xf6a768d8在?? （）来自目标：/system/lib/libandroidfww.so#2 0xf6a73190在android :: zipfilero :: findentrybyname（char const *）const（）来自目标：/system/lib/libandroidfw.so#3 0xf6a65664在Android :: AssetManager :: OpenNONASSetinpathLocked（Char Const *，Android :: Asset :: AccessMode，AssetManager :: Asset_Path Const＆amp;）（）来自目标：/system/lib/libandroidfw.so#4 0xf6a65bd6在Android :: AssetManager :: Open（Char Const *，Android :: Asset :: AccessMode）（）来自目标：/system/lib/libandroidfw.so#5 0xf753c79e在target：/system/lib/libandroid.so#6 0xda7f928a in ansasset manager_open（） ？ （）来自目标：/data/data/com.facebook.katana/lib-xzs/libcoldstart.so#7 0xda7f91ec在?? （）来自目标：/data/data/com.facebook.katana/lib-xzs/libcoldstart.so#8 0xda7f9160在?? （）来自目标：/data/data/com.facebook.katana/lib-xzs/libcoldstart.so#9 0xda815bf0在?? （）来自目标：/data/data/com.facebook.katana/lib-xzs/libcoldstart.so#10 0xda6efece在?? （）来自目标：/data/data/com.facebook.katana/lib-xzs/libcoldstart.so#11 0xda6f2186在?? （）来自目标：/data/data/com.facebook.katana/lib-xzs/libcoldstart.so#12 0xda6f2012在?? （）来自目标：/data/data/com.facebook.katana/lib-xzs/libcoldstart.so</p><p> Looks like it&#39;s somewhere in libcoldstart.so. Let&#39;s see if we can find its format.Maybe we can get some information by looking at the libraries it links to?</p><p> 看起来像是libcoldstart.so的某个地方＆＃39;让＆＃39; s看我们是否能找到它的格式..我们可以通过查看它链接的图书馆来获得一些信息？</p><p> $ adb pull /data/data/com.facebook.katana/lib-xzs/libcoldstart.so$ readelf -a libcoldstart.so | grep &#39;Shared library:&#39; 0x00000001 (NEEDED) Shared library: [libz.so] 0x00000001 (NEEDED) Shared library: [libdl.so] 0x00000001 (NEEDED) Shared library: [liblowlevel.so] 0x00000001 (NEEDED) Shared library: [libxplat_yoga_util_utilAndroid.so] 0x00000001 (NEEDED) Shared library: [liblog.so] 0x00000001 (NEEDED) Shared library: [libandroid.so] 0x00000001 (NEEDED) Shared library: [libxplat_third-party_jsoncpp_jsoncppAndroid.so] 0x00000001 (NEEDED) Shared library: [libglog.so] 0x00000001 (NEEDED) Shared library: [libfmt.so] 0x00000001 (NEEDED) Shared library: [libflatbuffersflatc.so] 0x00000001 (NEEDED) Shared library: [libsigmux.so] 0x00000001 (NEEDED) Shared library: [libfbsystrace.so] 0x00000001 (NEEDED) Shared library: [libmemalign16.so] 0x00000001 (NEEDED) Shared library: [libbreakpad.so] 0x00000001 (NEEDED) Shared library: [libprofiloextapi.so] 0x00000001 (NEEDED) Shared library: [liblinkerutilsmerged.so] 0x00000001 (NEEDED) Shared library: [libdistractmerged.so] 0x00000001 (NEEDED) Shared library: [libgnustl_shared.so] 0x00000001 (NEEDED) Shared library: [libm.so] 0x00000001 (NEEDED) Shared library: [libc.so]</p><p> $ adb pull / data/data/com.facebook.katana/lib-xzs/libcoldstart.so$ readelf -a libcoldstart.so | Grep＆＃39;共享库：＆＃39; 0x00000001（所需）共享库：[libz.so] 0x00000001（所需）共享库：[libdl.so] 0x00000001（所需）共享库：[liblowlevel.so] 0x00000001（需要）共享库：[libxplat_yoga_util_utilandroid.so] 0x00000001（所需的）共享库：[liblog.so] 0x00000001（需要）共享库：[libandroid.so] 0x00000001（所需）共享库：[libxplat_third-party_jsoncpp_jsoncppandroid.so] 0x00000001（所需）共享库：[libglog.so] 0x00000001（需要）共享库：[libfmt.so] 0x00000001（需要）共享库：[libflatbudeersflatc.so] 0x00000001（所需）共享库：[libsigmux.so] 0x00000001（所需）共享库：[libfbsystrace.so] 0x00000001（需要）共享库：[libmemalign16.so] 0x00000001（需要）共享库：[libbreakpad.so] 0x00000001（所需）共享库：[libprofiloextapi.so] 0x00000001（所需）共享库：[Liblinkerutilsmerged.so] 0x00000001（所需）共享库：[libdistractmerged.so] 0x00000001（需要）共享库：[libgnustl _shared.so] 0x00000001（需要）共享库：[libm.so] 0x00000001（所需）共享库：[libc.so]</p><p> Now we have a reference to FlatBuffers: &#34;libflatbuffersflatc.so&#34;, could this be the format?Let&#39;s check. An easy way to see if a file is formated using FlatBuffers is to check that thefirst 4 bytes interpreted as an int32_t point to a table, the first int32_t in a table is thenegative offset to its virtual table. Let&#39;s see:</p><p> 现在我们对FlinBuffers有一个参考：＆＃34; libflatbuffersflatc.so＆＃34;这可能是格式吗？让＆＃39; s检查。一种简单的方法来看看使用flobuffers是否形成文件的方法是检查首次将4个字节解释为int32_t指向表，表中的第一个Int32_t在Thenegative偏移到其虚拟表中。让＆＃39; s pee：</p><p> $ hexdump -C graph_metadata.bin | head00000000 20 00 00 00 00 00 00 00 00 00 16 00 28 00 04 00 | ...........(...|00000010 08 00 0c 00 10 00 14 00 18 00 1c 00 20 00 24 00 |............ .$.|00000020 16 00 00 00 e0 10 2f 00 10 27 25 00 04 3a 1f 00 |....../..&#39;%..:..|00000030 20 fd 1d 00 ac 96 13 00 94 96 13 00 68 12 13 00 | ...........h...|00000040 b4 0e 0b 00 04 00 00 00 64 52 00 00 a0 0e 0b 00 |........dR......|00000050 90 0e 0b 00 84 0e 0b 00 78 0e 0b 00 68 0e 0b 00 |........x...h...|00000060 4c 0e 0b 00 28 0e 0b 00 08 0e 0b 00 e4 0d 0b 00 |L...(...........|00000070 c8 0d 0b 00 ac 0d 0b 00 94 0d 0b 00 84 0d 0b 00 |................|00000080 68 0d 0b 00 58 0d 0b 00 40 0d 0b 00 24 0d 0b 00 |h...X...@...$...|00000090 08 0d 0b 00 f0 0c 0b 00 d8 0c 0b 00 c0 0c 0b 00 |................|</p><p> $ hexdump -c graph_metadata.bin | HEAD00000000 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 16 00 28 00 04 00 | ...........（... | 00000010 08 00 0C 00 10 00 14 00 1 1C 00 20 00 2 00 | ............。$。| 00000020 16 00 00 00 00 00 00 00 e010 2f 00 10 27 25 00 04 3a 1f 00 | ......＆＃39;％..：.. | 00000030 20 FD 1D 00 AC 96 13 00 94 96 13 00 68 12 13 00 | ........... H ... | 00000040 B4 0E 0B 00 04 00 00 00 64 52 00 00 A0 0B 00 | ........博士。 ..... | 00000050 90 0e 0b 00 84 0e 0b 00 78 0e 0b 00 68 0e 0b 00 | ........ x ... h ... | 00000060 4c 0e 0b 00 28 0e 0b 00 08 0E 0B 00 E4 0D 0B 00 | L ...（........... | ........... | 00000070 C8 0D 0B 00 AC 0D 0B 00 94 0D 0B 00 84 0D 0B 00 | ...... .......... | 00000080 68 0D 0B 00 58 0D 0B 00 40 0D 0B 00 24 0D 0B 00 | H ... X ... ... @ ... $ ... | 00000090 08 0d 0b 00 F0 0C 0B 00 D8 0C 0B 00 C0 0C 0B 00 | ................ |</p><p> Integers in FlatBuffers are little-endian. We get:The first offset is 0x20 , it points to a 0x16 which points to the (0x16, 0x28).Assuming that 0x16 is the length of the virtual table, the data immediately after it isour root table. It would seem that it passes this heuristic.</p><p> FlatBuffers中的整数是小endian。我们得到：第一个偏移是0x20，它指向0x16，它指向（0x16，0x28）.Assuming 0x16是虚拟表的长度，它在它是Root table之后的数据。似乎它通过了这种启发式。 </p><p>     &gt;&gt;&gt; import fbs&gt;&gt;&gt; data = open(&#39;graph_schema.bin&#39;, &#39;rb&#39;).read()&gt;&gt;&gt; root = root = fbs.deref_offset(data, 00)&gt;&gt;&gt; fbs.get_table_vt(data, root){&#39;vt_len&#39;: 22, &#39;tbl_len&#39;: 40, &#39;entries&#39;: (4, 8, 12, 16, 20, 24, 28, 32, 36)}</p><p>＆gt;＆gt;＆gt;进口FBS＆gt;＆gt;＆gt; data =打开（＆＃39; graph_schema.bin＆＃39;＆＃39; rb＆＃39;）。read（）＆gt;＆gt;＆gt; root = root = fbs.deref_offset（数据，00）＆gt;＆gt;＆gt; fbs.get_table_vt（数据，root）{＆＃39; vt_len＆＃39 ;:22，＆＃39; tbl_len＆＃39 ;: 40，＆＃39;条目＆＃39 ;:（4,8,12,16,20 ，24,28,32,36）}}</p><p> From here it&#39;s a lot of guess work, and trial and error.So far I&#39;ve got the following schema, it&#39;s incomplete, but it provides us with enoughinformation to reconstruct all types and fields of the GraphQL API:</p><p> 从这里它＆＃39;苏猜起作用，以及试验和错误。所以我＆＃39; ve得到了以下架构，它＆＃39; s不完整，但它为我们提供了足够的信息来重建所有类型和字段GraphQL API：</p><p>   The schema as you&#39;ve probably noticed has an extra layer of encoding, probably to reduce its size.We don&#39;t know what the types nor fields mean. The most helpful indicator is that if the type of a fieldis a short we can check if it&#39;s an index in a vector by checking that all values are less than the vector&#39;slength and the maximum index is close to the length of the vector.</p><p>   架构与你一样。Ve可能注意到有一个额外的编码层，可能会减少它的尺寸。我们不知道什么类型的类型也意味着什么。最有用的指标是，如果差异的类型是短暂的，我们可以通过检查所有值小于向量＆＃39来检查矢量中的索引＆＃39;＆＃39; SLENG和最大索引接近载体的长度。</p><p> We&#39;ll skip over the manual decoding. I&#39;ll just show you the script I wrote to extract the types from the schema:</p><p> 我们＆＃39; ll跳过手动解码。我＆＃39; ll只是向您展示我写入的脚本以从架构中提取类型：</p><p>     I have presented my findings to Facebook, their response was that the schema is not confidential.</p><p>     我向Facebook提交了我的调查结果，他们的回应是模式不是保密的。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://cajum.github.io/fbgraphql/">https://cajum.github.io/fbgraphql/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/facebook/">#facebook</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/graphql/">#graphql</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>