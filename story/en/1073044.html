<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Python启动之前解决带有锈迹的代码2021的出现Solving Advent of Code 2021 with Rust before Python can start</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Solving Advent of Code 2021 with Rust before Python can start<br/>在Python启动之前解决带有锈迹的代码2021的出现</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-14 12:47:42</div><div class="page_narrow text-break page_content"><p>I did  Advent of Code for the second time this year. For those of you who haven&#39;t heard of it, it&#39;s a set of short programming puzzles that are released two at a time for the first 25 days of December. People tend to have different goals when solving the problems — some people race to finish quickly and make the leaderboard, some try to learn new languages, and some do ridiculous things (like  a person who solved most of the puzzles in  Scratch!). Rather than focusing on quickly submitting solutions, I tried to optimize the runtime of my solutions with an initial goal of solving all puzzles in 800ms (about the time it takes the  JVM to cold start).  		As you may have guessed from this article&#39;s title, that goal was achieved -  I solved all 49 puzzles in ~65ms without multithreading on an AMD 5950x. This greatly exceeded my expectations and ended up being faster than even  python can start (~70ms on the same machine)! Additionally, three days ( 23,  25, and  15) took the vast majority of that time. Without those days, the remaining solutions run in a handful of milliseconds total.</p><p>我今年第二次做了《代码的出现》。对于那些没有&#39；我没听说过，它&#39；这是一组简短的编程谜题，在12月的前25天一次发布两个。在解决问题时，人们往往有不同的目标——一些人竞相快速完成并进入排行榜，一些人试图学习新的语言，还有一些人做一些可笑的事情（比如一个人在Scratch中解决了大部分难题！）。我没有专注于快速提交解决方案，而是尝试优化解决方案的运行时间，最初的目标是在800毫秒内解决所有难题（大约是JVM冷启动所需的时间）。正如你可能从这篇文章中猜到的&#39；在AMD5950X上，我不用多线程就在65毫秒内解决了所有49个难题。这大大超出了我的预期，结果比python的启动速度还要快（在同一台机器上大约70毫秒）！此外，三天（23天、25天和15天）占据了绝大多数时间。如果没有这些日子，剩下的解决方案只需几毫秒就可以运行。</p><p>    Note: The title of this article is a bit clickbaity — with  python not resident in the  page cache, it takes the 5950x-based system ~70ms to run  time python3 -c &#34;exit()&#34;, but it only takes ~10ms with a hot page cache.</p><p>注意：本文的标题有点点击诱饵——由于python不驻留在页面缓存中，因此需要基于5950x的系统~70ms才能运行时间为python3-c&#34；退出（）&#34；，但使用热页缓存只需10毫秒。</p><p>    I had the idea to try using   rustdoc as a way to present my code along with explanations of what I found interesting about the problems and how I optimized them. This format should allow you to browse through my solutions to problems, see the types I used and read my thoughts, and view the actual code I wrote. It&#39;s the first time I&#39;ve tried using  rustdoc like this, so I&#39;d appreciate feedback.    You can find  my writeups and solutions here, and you should probably read them before continuing. You&#39;ll get the most value out of them if you&#39;ve already solved AoC 2021, but you can also  follow along with the problem descriptions for part one of each day.  		Now that you&#39;ve done that...</p><p>我想尝试使用rustdoc作为一种展示我的代码的方式，并解释我对这些问题感兴趣的地方，以及我是如何优化它们的。这种格式应该允许您浏览我的问题解决方案，查看我使用的类型，阅读我的想法，并查看我编写的实际代码。它&#39；这是我第一次&#39；我试过像这样使用rustdoc，所以我&#39；感谢您的反馈。你可以在这里找到我的写作和解决方案，在继续之前，你可能应该阅读它们。你&#39；如果你&#39；我已经解决了AOC 2021，但是你也可以跟随每天的第一部分的问题描述。现在你&#39；我做到了。。。</p><p>    An unexpected problem with writing efficient AoC solutions is the inability to effectively benchmark them, making it hard to make informed decisions on what to improve. Many performance analysis tools use approaches similar to   perf, which involve sampling the program runtime every few milliseconds (totally non-biased shoutout to  FunctionTrace as a great non-sampled Python profiler!). As the slowest puzzle ( day 23) ran in ~31ms, it&#39;s hard to gather enough data to make optimization decisions off of. As a result, I generally optimized based on a few heuristics and used   cargo-criterion to validate my hypotheses.  		I used two main heuristics, which are things to always keep in mind when you care about performance:</p><p>编写高效的AoC解决方案时，一个意想不到的问题是无法有效地对它们进行基准测试，这使得很难就改进内容做出明智的决定。许多性能分析工具使用类似于perf的方法，每几毫秒对程序运行时进行一次采样（FunctionTrace是一个非常棒的非采样Python分析器，完全没有偏见）。当最慢的谜题（第23天）在约31毫秒内运行时，它是&#39；很难收集足够的数据来做出优化决策。因此，我通常会基于一些启发式方法进行优化，并使用cargo准则来验证我的假设。我使用了两种主要的启发式方法，当您关心性能时，应始终牢记这两种方法：</p><p>    My initial goal was always to find a faster algorithm that allowed me to avoid some computations. For example, for  Day 17 Part 2, any optimization we do to computing steps of the projectile movement will still be slower than avoiding computing most of the steps via  triangle numbers. Note that this doesn&#39;t need to be a faster algorithm in order to do less work — writing code so the compiler can elide bounds checks, or memoizing the results of some computations can often be very effective.  		After finding an efficient algorithm, I focused on minimizing the amount of time spend waiting on reads for main memory. This is typically done via the  processor&#39;s cache, which will transparently cache accesses to main memory. However, caches have a fixed size that tends to be substantially smaller than the amount of RAM on a system — my development machine with 32GB of RAM only has ~1MB of cache! To efficiently use the cache, it&#39;s important to minimize the size of data that&#39;s being used, as well as use patterns that can utilize the cache.    Day 23 has a good example of minimizing the size of data. We need to represent many different game states and iterate through them, but a game naively consists of 27 different spaces each requiring a byte to store, which is then padded to 32 bytes by the compiler. By removing unreachable states and compressing some information into bits, we&#39;re able to reduce this to 16 bytes, allowing us to double the number of game states we can fit in our cache before taking the long trip to main memory. If we remove only this 16 byte optimization, day 23 is more than 30% slower!  		While optimizing the size of data structures can help fit more data into the cache and allow the CPU to spend its time computing rather than waiting for memory, it&#39;s also important to ensure the program effectively uses the cache. To be feasible to implement in hardware, CPU caches store  lines (typically 64 bytes each) rather than individual bytes. This means that after you access a location in memory, accessing anything soon after it will likely hit the cache, avoiding a round-trip to memory. As an example, we utilize this in  Day 9 by iterating over each row in order rather than using something like BFS. As we&#39;re iterating over each  u16 (taking 2 bytes of space), we&#39;ll load 32 entries into the cache for memory access we do. If we instead iterated over each column, we&#39;d end up loading many different lines into the cache but not immediately using them, which would cause us to access main memory more often.  Day 15 is a good example of a case where we can&#39;t necessarily do this well; with Djikstra&#39;s the next neighbor may be located anywhere in the grid (512KB in memory), so we&#39;re rarely able to share memory accesses via the cache and instead spend most of our time waiting for data to load from main memory.</p><p>我最初的目标一直是找到一个更快的算法，让我避免一些计算。例如，对于第17天第2部分，我们对计算弹丸运动的步数所做的任何优化，仍然比避免通过三角形数计算大多数步数要慢。请注意，这并不意味着&#39；为了减少工作量，不需要更快的算法——编写代码，这样编译器就可以省去边界检查，或者记忆某些计算的结果通常是非常有效的。在找到一个高效的算法后，我专注于最小化等待读取主内存的时间。这通常通过处理器&39；s缓存，它将透明地缓存对主内存的访问。然而，缓存有一个固定的大小，往往比系统上的RAM量小得多——我的开发机器有32GB的RAM，只有~1MB的缓存！为了有效地使用缓存，它&#39；重要的是尽量减少数据的大小&#39；以及使用可以利用缓存的模式。第23天是最小化数据大小的好例子。我们需要表示许多不同的游戏状态并对它们进行迭代，但一个游戏通常由27个不同的空间组成，每个空间都需要存储一个字节，然后由编译器填充到32个字节。通过消除无法到达的状态并将一些信息压缩成比特，我们&#39；我们可以将其减少到16字节，这样我们就可以在长时间访问主内存之前，将缓存中可以容纳的游戏状态数量增加一倍。如果我们只删除这个16字节的优化，第23天的速度会慢30%以上！虽然优化数据结构的大小有助于将更多数据放入缓存，并允许CPU花费时间进行计算，而不是等待内存，但它&#39；确保程序有效地使用缓存也很重要。为了在硬件中实现，CPU缓存存储行（通常每个行64字节），而不是单个字节。这意味着，在访问内存中的某个位置后，在它很可能命中缓存后不久访问任何内容，从而避免了对内存的往返访问。作为一个例子，我们在第9天通过按顺序迭代每一行来利用这一点，而不是使用BFS之类的东西。正如我们&#39；重新迭代每个u16（占用2字节的空间），我们&#39；我们将加载32个条目到缓存中，以便进行内存访问。如果我们迭代每一列，我们&#39；d最终会将许多不同的行加载到缓存中，但不会立即使用它们，这会导致我们更频繁地访问主内存。第15天是一个很好的例子，我们可以&#39；不一定要做好这件事；与Djikstra&#39；s下一个邻居可能位于网格中的任何位置（内存为512KB），因此我们&#39；我们很少能够通过缓存共享内存访问，而是将大部分时间花在等待从主存加载数据上。</p><p>    I continue to really enjoy Rust. Many of my early solutions look fairly similar to the Python solutions, except with enforced error checking, no worries that they&#39;ll be wrong, and  blazingly fast performance (it wouldn&#39;t be a Rust article if I didn&#39;t use this phrase somewhere). By ensuring I&#39;ll rarely need to debug runtime errors and can still have native performance, Rust has become my favorite practical language.  		Most of my solutions had two phases, where I first solved the problem without particularly caring about performance, then where I optimized it until it had satisfactory performance.		During the first phase, I frequently used fancy data structures like  vectors and  hashtables, then converted them to simpler data structures like fixed-sized arrays. Rust&#39;s strong type system enabled me to refactor with confidence, knowing that I couldn&#39;t miss something and end up with annoying issues at runtime.  		Performance-wise, it&#39;s really nice to have the ability to control memory-usage by specifically choosing my data types, while also not needing to manually manage memory via  malloc() and  free(). I specifically chose integer sizes to optimize for memory layout and cache efficiency on many days, but almost never thought about allocations (and even without thought they only make up a tiny fraction of the  flamegraph for my solutions).    Lifetimes are one of the things that new Rust programmers seem to find confusing, but the Rust team has done a great job here, I used references all over my code, but only needed to use explicit lifetime annotations twice. The compiler does a much better job getting out of your way than in the pre-1.0 days.  		I didn&#39;t need to touch   unsafe at all, and from some quick profiling in  VTune, I don&#39;t feel like I missed any performance as a result. This continues to reinforce my belief that the average programmer considering  unsafe should consider refactoring their code to use a different pattern instead.  		I didn&#39;t use  nightly Rust at all. This mostly worked out, but there were some unstable APIs that I would&#39;ve loved having. Off the top of my head,  BtreeMap::pop_first would&#39;ve simplified my hacky priority queue implementation, and there were various unstable features related to   const generics that I expected to exist.    Const generics seem like a neat idea, and it was my first time actually applying them to a Rust program. I used them in a few places, but due to some limitations I never felt like they made a big improvement over passing an additional argument. In particular, the inability to use  const generics function arguments in data structures meant I couldn&#39;t make the optimizations around memory layout that I would&#39;ve expected.  		Integer operations seem to be horribly annoying in Rust. If you care about the amount of memory your integers use, you&#39;ll end up casting back and forth between  usize to index collections,  isize to handle potentially negative cases, and whatever integral type you actually want. This is a reasonable design decision, but it&#39;s incredibly frustrating to litter code with  as usize and the like when I know the conversion will be safe.    rustdocs is amazing. The ability to browse through generated documentation for everything in the ecosystem, including useful features like searching for functions by return type, makes onboarding to new libraries (or even the standard library) a breeze. Something like  Hoogle would be still be nice to have, but I find Rust docs to be a massively more pleasant experience than the standard Python or Java docs.</p><p>我仍然很喜欢生锈。我的许多早期解决方案看起来与Python解决方案非常相似，除了强制的错误检查，不用担心它们&#39；我错了，而且表现得非常快（如果我不在某处使用这个短语，它就不会是一篇生锈的文章）。确保我&#39；我几乎不需要调试运行时错误，而且仍然具有本机性能，Rust已经成为我最喜欢的实用语言。我的大多数解决方案都有两个阶段，首先我解决了问题，而不特别关心性能，然后我优化它，直到它有令人满意的性能。在第一阶段中，我经常使用一些奇特的数据结构，比如向量和哈希表，然后将它们转换成更简单的数据结构，比如固定大小的数组。锈蚀#39；s强大的类型系统使我能够自信地进行重构，因为我知道我不能&#39；不要错过一些东西，并在运行时遇到恼人的问题。就性能而言，它&#39；通过特别选择我的数据类型来控制内存使用，同时也不需要通过malloc（）和free（）手动管理内存，这真是太好了。我特别选择了整数大小来优化内存布局和缓存效率，但几乎从来没有考虑过分配（甚至没有想到它们只占我解决方案的flamegraph的一小部分）。生命周期是新的Rust程序员似乎感到困惑的事情之一，但Rust团队在这方面做得很好，我在代码中使用了所有引用，但只需要使用显式生命周期注释两次。与1.0版本之前的版本相比，编译器在解决问题方面做得更好。我没有&#39；根本不需要触碰不安全的东西，从VTune中的一些快速评测来看，我不&#39；我不觉得自己因此错过了任何表演。这继续增强了我的信念：考虑不安全的普通程序员应该考虑重构他们的代码来使用不同的模式。我没有&#39；根本不用夜间生锈。这基本上是可行的，但有一些不稳定的API，我会#39；我喜欢拥有。在我脑海中，BtreeMap:：pop#u首先会&#39；我简化了我的hacky priority queue实现，并且有许多与const泛型相关的不稳定特性，我希望这些特性能够存在。Const泛型看起来是个不错的主意，这是我第一次将它们应用到一个Rust程序中。我在一些地方使用了它们，但由于一些限制，我从来没有觉得它们比通过额外的论证有很大的改进。尤其是，不能在数据结构中使用const泛型函数参数意味着我不能&#39；t围绕内存布局进行优化，我会&#39；我预料到了。整数运算在Rust中似乎非常烦人。如果你关心整数使用的内存量，你&#39；最后，我会在usize到索引集合、isize到处理潜在的负面情况，以及任何你真正想要的积分类型之间来回转换。这是一个合理的设计决策，但它&#39；当我知道转换是安全的时候，把代码乱扔给as usize之类的东西会让我非常沮丧。这太棒了。通过生成的文档浏览生态系统中的所有内容的能力，包括按返回类型搜索函数等有用功能，使新库（甚至标准库）的安装变得轻而易举。像Hoogle这样的东西仍然很好，但我发现Rust docs比标准Python或Java docs更令人愉快。</p><p>    I thought using Rust to solve Advent of Code 2021 was enjoyable, and it was satisfying to write some high performance solutions with it. I felt like I got initial solutions to the problems in a similar amount of time that a dynamic language like Python would&#39;ve required (though optimization obviously took longer), and it&#39;s nice to feel like my CPU is being effectively utilized.  		I&#39;d love to see more people attempting to solve AoC with minimal runtime, and think a comparison with other high-performance languages like C or C++ would be fun.  		From a quick scan of the  Advent of Code subreddit, I believe I have the fastest public implementation for all days. If anyone believes that&#39;s wrong (particularly if benchmarked on  one of my available systems), let me know!</p><p>我认为使用锈迹来解决代码2021的出现是令人愉快的，用它编写一些高性能的解决方案是令人满意的。我觉得我在与Python这样的动态语言相似的时间内得到了问题的初始解决方案&#39；我需要（尽管优化显然需要更长的时间），而且它&#39；很高兴我的CPU得到了有效利用。我&#39；我喜欢看到更多的人试图用最少的运行时间来解决AOC，并且认为与其他高性能语言如C或C++相比是有趣的。通过快速浏览Code subreddit的出现，我相信我拥有了迄今为止最快的公共实现。如果有人相信&#39；这是错误的（特别是如果以我的一个可用系统为基准），请告诉我！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/带有/">#带有</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/advent/">#advent</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1072461.html"><img src="http://img2.diglog.com/img/2022/1/thumb_fb508e6cf18e791c484b3c2c3c695664.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072461.html">代码审查方式</a></div><span class="my_story_list_date">2022-1-9 21:58</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072457.html"><img src="http://img2.diglog.com/img/2022/1/thumb_44cc3c562cfb3896f12902316e131f35.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072457.html">绕过门密码</a></div><span class="my_story_list_date">2022-1-9 21:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072403.html"><img src="http://img2.diglog.com/img/2021/8/thumb_85e5202f76bb0f0b03afa2d1ee761760.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072403.html">明天新 OpenAI 代码编写技术的现场演示</a></div><span class="my_story_list_date">2021-8-10 4:33</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072393.html"><img src="http://img2.diglog.com/img/2021/8/thumb_6b556d6fd050f0203839396803172378.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072393.html">联合国 IPCC 关于气候变化的报告听起来像是地球的“红色代码”</a></div><span class="my_story_list_date">2021-8-10 3:47</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>