<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用TLS转到HTTPS服务器 Go HTTPS Servers with TLS</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Go HTTPS Servers with TLS<br/>使用TLS转到HTTPS服务器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-11 23:53:44</div><div class="page_narrow text-break page_content"><p>This post is a basic introduction to running HTTPS servers and clients in Gousing TLS. It assumes some familiarity with public-key crypto. Feel free tocheck out my earlier posts about  RSA and the Diffie-Hellman Key Exchange; TLS usesthe elliptic-curve version of Diffie-Hellman. I won&#39;t be covering how theprotocol itself works in detail here, but if you&#39;re interested I recommend toread up on the subject.</p><p>此帖子是运行HTTPS服务器和客户端的基本介绍TLS。它假设一些熟悉公钥加密。随时可以免费攻击我的早期关于RSA和Diffie-Hellman密钥交换的帖子; TLS USESTHE椭圆曲线版本的Diffie-Hellman。我赢得了＆＃39; T＆＃39; Protocol本身如何详细介绍，但如果你＆＃39;遗嘱感兴趣，我建议在这个主题上toread。</p><p>  TLS (Transport Layer Security) is a protocol designed to enable client-servercommunication over the Internet in a way that prevents eavesdropping, tamperingand message forgery. It&#39;s described in  RFC 8446.</p><p>  TLS（传输层安全性）是一种协议，该协议旨在以防止窃听，TamperingAnd伪造的方式启用Internet的客户端 -  ServerConcunication。它＆＃39;在RFC 8446中描述。</p><p> TLS relies on state-of-the art cryptography; this is also why it&#39;s recommendedusing the newest version of TLS available, which is 1.3 (as of early 2021).Revisions of the TLS protocol clean up potentially unsafe corner cases, removeweak encryption algorithms and generally try to make the protocol more secure.</p><p> TLS依赖于最先进的密码学;这也是为什么它＆＃39; S推荐最新版本的TLS可用的TLS，这是1.3（截至2021年初）.TLS协议的重新分析潜在的不安全的角落案例，删除了eChryption算法，并且通常尝试更多地使协议更新安全的。</p><p> When a client connects to a server with plain HTTP, it starts sending plaintextdata wrapped in TCP packets right after completing the standard TCP handshake(SYN -&gt; SYN-ACK -&gt; ACK). Using TLS, the situation is somewhat more complicated [1]:</p><p> 当客户端连接到具有普通HTTP的服务器时，它开始在完成标准TCP握手（SYN-＆GT; SYN-ACK  - ＆GT）后立即将包裹在TCP数据包中的PLAINTEXTDATA发送。使用TLS，情况有点复杂[1]：</p><p>  After completing the TCP handshake, the server and client perform a TLShandshake to agree on a shared secret that&#39;s unique only to them (at to thisspecific point in time). This shared secret is then used to securely encrypt alldata being exchanged between them. While there&#39;s a lot going on here, it&#39;ssomething the TLS layer implements for us. We just have to set up the TLS server(or client) properly; the actual diff between an HTTP and an HTTPS server in Gois minimal.</p><p>  完成TCP握手后，服务器和客户端执行TLShandshake以同意共享秘密，＆＃39;唯一的独特秘密（在此目的）。然后使用此共享秘密来安全地加密在它们之间交换的Alldata。虽然有很多事情在这里，它＆＃39; ssomething tls层的图层为我们。我们只需正确设置TLS服务器（或客户）; HTTP和HTTPS服务器之间的实际差异在GOI最小。</p><p> Before we jump to the code showing how to set up an HTTPS server in Go usingTLS, let&#39;s talk about  certificates. In the diagram above, you&#39;ll notice thatthe server sends a certificate to the client as part of its very first ServerHello message. Formally these are known as X.509 certificates,described by  RFC 5280.</p><p> 在我们跳转到展示如何设置HTTPS服务器的代码之前，请展示证书。在上图中，您＆＃39; ll注意到服务器将证书发送给客户端作为其第一个serverhello消息的一部分。正式这些称为X.509证书，由RFC 5280描述。</p><p> Public key cryptography plays a major part in TLS. A certificate is a standardway to wrap the server&#39;s public key, along with its identity and a signature bya trusted authority (typically a  Certificate Authority). Suppose you want totalk to  https://bigbank.com; how do you know it&#39;s really Big Bank there askingfor your password? What if someone is sitting on your cable connection,intercepting all traffic and pretending to be Big Bank (classical MITM -man-in-the-middle attack).</p><p> 公钥加密播放TLS的主要部分。证书是将服务器包装的标准道，以及公钥，以及其身份和签名BYA可信任权限（通常是证书颁发机构）。假设您想要ToTalk to https://bigbank.com;你怎么知道它＆＃39;真正的大银行那里要求你的密码？如果有人坐在电缆连接，拦截所有流量并假装是大银行（古典Mitm-Man-In-中攻击）的话。 </p><p> The certificate process is designed to prevent this scenario. When your client&#39;sunderlying TLS implementation accesses  https://bigbank.com, it expects BigBank&#39;s certificate with a public key, signed by a trusted certificate authority(CA). Certificate signatures can form a tree (bank&#39;s key signed by A, which issigned by B, which is signed by C, etc.), but at the end of the chain it musthave some certificate authority trusted by your client. Modern browsers have alist of pre-trusted CAs (along with their own certificates) built-in. Since yourcable snooper cannot forge a trusted certificate&#39;s signature, they cannotimpersonate Big Bank. Since the certificate carries the bank&#39;s legitimate publickey, when you use it to generate your shared secret only the bank will be ableto decrypt it.</p><p>证书流程旨在防止这种情况。当您的客户端＆＃39; sunderlying tls实现访问https://bigbank.com，它希望Bigbank＆＃39; s证书与公钥，由可信证书颁发机构（CA）签名。证书签名可以形成一棵树（由a由b签名的bank＆＃39; s键，由c等），但在链条的末尾，它弥漫了您的客户信赖的一些证书颁发机构。现代浏览器的alist of Pre Trusted CA（以及他们自己的证书）内置。由于yourcable snooper无法伪造可信证书＆＃39; s签名，他们不能签名大银行。自证书携带银行＆＃39; s合法的publickey，当您使用它来生成您的共享秘密时，银行将是ableto解密。</p><p> For local testing, it&#39;s often very useful to be able to work with self-signedcertificates. A self-signed certificate is a certificate for some entity E witha public key P, but the key is signed not by a known certificate authority, butrather by P itself. While self-signed certificates have some additionallegitimate uses, we&#39;ll focus on their use for testing here.</p><p> 对于本地测试，它往往能够与自我遗传的人一起工作非常有用。自签名证书是一些实体E与公钥P的证书，但关键字不由已知证书颁发机构签名，并通过P本身绑定。虽然自签名证书有一些额外的用途，但我们＆＃39; LL专注于他们在此测试中的测试。</p><p> Go&#39;s standard library has excellent support for everything related to crypto,TLS and certificates. Let&#39;s see how to generate a self-signed certificate in Go!</p><p> Go＆＃39; S标准库对与Crypto，TLS和证书相关的所有内容具有出色的支持。 Let＆＃39; S看如何在GO上生成自签名证书！</p><p> privateKey ,  err  :=  ecdsa . GenerateKey ( elliptic . P256 (),  rand . Reader ) if  err  !=  nil  {  log . Fatalf ( &#34;Failed to generate private key: %v&#34; ,  err ) }</p><p> privatekey，错误：= ecdsa。 Generatekey（椭圆形。P256（），兰德。如果err！= nil {log。 Fatalf（＆＃34;未能生成私钥：％v＆＃34;，err）}</p><p> This code uses the  crypto/ecdsa,  crypto/elliptic and  crypto/randpackages to generate a new key pair  [2], using the P-256 elliptic curve,which is one of the allowed curves in TLS 1.3.</p><p> 此代码使用Crypto / ECDSA，Crypto / Elliptic和Crypto / RandPackages使用P-256椭圆曲线生成新的密钥对[2]，这是TLS 1.3中的允许曲线之一。</p><p>  serialNumberLimit  :=  new ( big . Int ). Lsh ( big . NewInt ( 1 ),  128 ) serialNumber ,  err  :=  rand . Int ( rand . Reader ,  serialNumberLimit ) if  err  !=  nil  {  log . Fatalf ( &#34;Failed to generate serial number: %v&#34; ,  err ) } template  :=  x509 . Certificate {  SerialNumber :  serialNumber ,  Subject :  pkix . Name {  Organization :  [] string { &#34;My Corp&#34; },  },  DNSNames :  [] string { &#34;localhost&#34; },  NotBefore :  time . Now (),  NotAfter :  time . Now (). Add ( 3  *  time . Hour ),  KeyUsage :  x509 . KeyUsageDigitalSignature ,  ExtKeyUsage :  [] x509 . ExtKeyUsage { x509 . ExtKeyUsageServerAuth },  BasicConstraintsValid :  true , }</p><p>  serialnumberlimit：=新（大。int）。 LSH（大。纽丁（1），128）SerialNumber，Err：= Rand。 int（rand。读者，serialnumberlimit）如果err！= nil {log。 Fatalf（＆＃34;未能生成序列号：％v＆＃34;，err）}模板：= x509。证书{SerialNumber：SerialNumber，主题：PKIX。姓名{组织：[]字符串{＆＃34;我的corp＆＃34; }，}，dnsnames：[]字符串{＆＃34; localhost＆＃34; }，ofebreor：时间。现在（），未出现：时间。现在 （）。添加（3 *时间。小时），keyusage：x509。 KeyUsagedIgitalSignature，ExtKeyusage：[] X509。 extkeyusage {x509。 extkeyusageserverauth}，BasicConstraintSvalid：True，}</p><p> Each certificate needs a unique serial number; typically, certificateauthorities will have these stored in some database but for our local needs arandom 128-bit number will do. This is what the first few lines of the snippetare doing.</p><p> 每个证书都需要一个唯一的序列号;通常，认证授权将使这些数据库存储在某些数据库中，但对于我们的本地需求，Arandom 128位数将执行。这就是Snippetare的前几行。 </p><p> Next comes the  x509.Certificate template. For more information on what thefields mean, see the  crypto/x509 package docs, as well as  RFC 5280. We&#39;ll just note that the certificateis valid for 3 hours, and is only valid for the  localhost domain.</p><p>接下来是x509.certificate模板。有关菲尔德的意思，请参阅Crypto / X509软件包文档以及RFC 5280.WE＆＃39; LL只是注意到证书有效期为3小时，并且仅适用于LocalHost域。</p><p>  derBytes ,  err  :=  x509 . CreateCertificate ( rand . Reader ,  &amp; template ,  &amp; template ,  &amp; privateKey . PublicKey ,  privateKey ) if  err  !=  nil  {  log . Fatalf ( &#34;Failed to create certificate: %v&#34; ,  err ) }</p><p>  derbytes，err：= x509。 CreateCertificate（Rand。读者，＆amp;模板，＆amp;模板，＆amp; private。Publickey，privateKey）如果err！= nil {log。 Fatalf（＆＃34;未能创建证书：％v＆＃34;，err）}</p><p> The certificate is created from the template, and is signed with the private keywe&#39;ve generated earlier. Note that  &amp;template is passed in both for the template and  parent parameters of  CreateCertificate. The latter iswhat makes this certificate  self-signed.</p><p> 该证书是从模板创建的，并与私钥键签名＆＃39; ve先前生成。请注意，＆amp;模板在CreateCertificate的模板和父参数中传递。后者是让这个证书自签名的。</p><p> This is it, we have the private key for our server and its certificate (whichcontains the public key, among other information). All that&#39;s left now is toserialize them into files. First, the certificate:</p><p> 这是它，我们拥有我们的服务器及其证书的私钥（其中公钥，以及其他信息）。现在留下的所有＆＃39;现在将它们分为文件。一，证书：</p><p> pemCert  :=  pem . EncodeToMemory ( &amp; pem . Block { Type :  &#34;CERTIFICATE&#34; ,  Bytes :  derBytes }) if  pemCert  ==  nil  {  log . Fatal ( &#34;Failed to encode certificate to PEM&#34; ) } if  err  :=  os . WriteFile ( &#34;cert.pem&#34; ,  pemCert ,  0644 );  err  !=  nil  {  log . Fatal ( err ) } log . Print ( &#34;wrote cert.pem\n&#34; )</p><p> pemcert：= PEM。 EncopeTomeMory（＆amp; pem。块{类型：＆＃34;证书＆＃34;，字节：derbytes}）如果pemcert == nil {log。致命（＆＃34;未能将证书编码为PEM＆＃34;）}如果ERR：= OS。 writefile（＆＃34; cert.pem＆＃34;，pemcert，0644）; err！= nil {log。致命（错误）}日志。打印（＆＃34;写ict.pem \ n＆＃34;）</p><p>  privBytes ,  err  :=  x509 . MarshalPKCS8PrivateKey ( privateKey ) if  err  !=  nil  {  log . Fatalf ( &#34;Unable to marshal private key: %v&#34; ,  err ) } pemKey  :=  pem . EncodeToMemory ( &amp; pem . Block { Type :  &#34;PRIVATE KEY&#34; ,  Bytes :  privBytes }) if  pemKey  ==  nil  {  log . Fatal ( &#34;Failed to encode key to PEM&#34; ) } if  err  :=  os . WriteFile ( &#34;key.pem&#34; ,  pemKey ,  0600 );  err  !=  nil  {  log . Fatal ( err ) } log . Print ( &#34;wrote key.pem\n&#34; )</p><p>  privbytes，err：= x509。 Marshalpkcs8privatekey（privateKey）如果err！= nil {log。 FATALF（＆＃34;无法进行编组私钥：％v＆＃34;，err）} pemkey：= pem。 EncodeTomeMory（＆amp; PEM。块{类型：＆＃34;私钥＆＃34;，字节：bytes：privbytes}）如果pemkey == nil {log。致命（＆＃34;未能对PEM＆＃34编码键进行键，如果err：=操作系统。 writefile（＆＃34; key.pem＆＃34;，pemkey，0600）; err！= nil {log。致命（错误）}日志。打印（＆＃34;写key.pem \ n＆＃34;）</p><p> We serialize the certificate and the key into PEM files, which looks like this(for the certificate):</p><p> 我们将证书和密钥序列化为PEM文件，它看起来像这样（对于证书）： </p><p>  If you&#39;ve ever set up SSH keys, the format should look familiar. We can usethe  openssl command-line tool to show its contents:</p><p>如果你有没有设置SSH键，则格式应该看起来很熟悉。我们可以使用openssl命令行工具来显示其内容：</p><p> $ openssl x509 -in cert.pem -textCertificate: Data: Version: 3 (0x2) Serial Number: b0:42:06:02:e1:0f:52:3f:e1:2d:1f:45:9b:fa:c9:f7 Signature Algorithm: ecdsa-with-SHA256 Issuer: O = My Corp Validity Not Before: Mar 27 14:25:49 2021 GMT Not After : Mar 27 17:25:49 2021 GMT Subject: O = My Corp Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (256 bit) pub: 04:9f:c0:d4:a2:7c:1d:8b:58:37:9b:eb:15:00:59: bc:27:05:0d:ab:69:24:13:aa:aa:5a:47:50:b5:78: 48:b2:e9:c8:2a:52:28:8e:96:be:23:50:30:e2:14: 29:72:f8:04:bd:a4:d3:5e:f2:8e:b7:fc:66:9b:ff: df:1d:c0:53:50 ASN1 OID: prime256v1 NIST CURVE: P-256 X509v3 extensions: X509v3 Key Usage: critical Digital Signature X509v3 Extended Key Usage: TLS Web Server Authentication X509v3 Basic Constraints: critical CA:FALSE X509v3 Subject Alternative Name: DNS:localhost Signature Algorithm: ecdsa-with-SHA256 30:45:02:20:62:52:58:18:8c:12:bc:0f:80:9a:c1:de:f0:fd: f8:07:9f:a1:95:f5:84:2b:8f:a4:06:6c:9d:27:ae:57:25:93: 02:21:00:b3:83:96:a2:85:45:e1:ed:19:b4:2f:52:b7:26:b1: bb:79:1b:93:b8:54:a4:1e:80:21:ce:4e:1c:cb:a1:6a:7d</p><p> $ openssl x509 -in cert.pem -textCertificate：数据：版本：3（0x2）序列号：B0：42：06：02：E1：0F：52：3F：E1：2D：1F：45：9B：FA： C9：F7签名算法：ECDSA-WITH-SHA256发行者：O =我的公司有效性不是之前：3月27日14:25:49 2021 GMT不是以下：3月27日17:25:49 2021 GMT主题：o =我的CORP主题公众关键信息：公钥算法：ID-ECPUBLICKEY公钥：（256位）酒吧：04：9F：C0：D4：A2：7C：1D：8B：58：37：9B：EB：15：00：59：59：59： BC：27：05：0D：AB：69：24：13：AA：AA：5A：5A：47：50：B5：78：48：B2：E9：C8：2A：52：28：8E：96：是： 23：50：30：E2：14：29：72：F8：04：BD：A4：D3：5E：F2：8E：B7：FC：66：9B：FF：DF：1D：C0：53：50Asn1 oid：prime256v1 nist曲线：p-256 x509v3扩展：x509v3键使用：x509v3键使用：关键数字签名x509v3扩展键使用：tls web服务器身份验证x509v3基本约束：严重ca：false x509v3主题备用名称：dns：localhost签名算法：ECDSA -SHA256 30：45：02：20：62：52：58：18：8C：12：BC：0F：80：9A：C1：DE：F0：FD：F8：07：9F：A1：95：F5： 84：2B：8F：A4：06：6C：9D：27：AE：57：25：93：02：21：00：B3：83：96 ：A2：85：45：E1：ED：19：B4：2F：52：B7：26：B1：BB：79：1B：93：B8：54：A4：1E：80：21：CE：4E：1C ：CB：A1：6A：7D</p><p> Now that we have the certificate and private key in hand, we are ready to run anHTTPS server! Once again, the standard library makes it very easy, though it&#39;simportant to mention that security is a very tricky issue. Before exposing yourserver to the public Internet, consider consulting with a security engineerabout best practices and what configuration options to be aware of  [3].</p><p> 现在我们在手中拥有证书和私钥，我们已准备好运行ANHTTPS服务器！再次，标准库使其非常容易，虽然它＆＃39;类似提到安全性是一个非常棘手的问题。在将您的服务器暴露给公共互联网之前，请考虑与安全工程交流最佳实践以及要知道的配置选项的咨询[3]。</p><p>  func  main ()  {  addr  :=  flag . String ( &#34;addr&#34; ,  &#34;:4000&#34; ,  &#34;HTTPS network address&#34; )  certFile  :=  flag . String ( &#34;certfile&#34; ,  &#34;cert.pem&#34; ,  &#34;certificate PEM file&#34; )  keyFile  :=  flag . String ( &#34;keyfile&#34; ,  &#34;key.pem&#34; ,  &#34;key PEM file&#34; )  flag . Parse ()  mux  :=  http . NewServeMux ()  mux . HandleFunc ( &#34;/&#34; ,  func ( w  http . ResponseWriter ,  req  * http . Request )  {  if  req . URL . Path  !=  &#34;/&#34;  {  http . NotFound ( w ,  req )  return  }  fmt . Fprintf ( w ,  &#34;Proudly served with Go and HTTPS!&#34; )  })  srv  :=  &amp; http . Server {  Addr :  * addr ,  Handler :  mux ,  TLSConfig :  &amp; tls . Config {  MinVersion :  tls . VersionTLS13 ,  PreferServerCipherSuites :  true ,  },  }  log . Printf ( &#34;Starting server on %s&#34; ,  * addr )  err  :=  srv . ListenAndServeTLS ( * certFile ,  * keyFile )  log . Fatal ( err ) }</p><p>  func main（）{addr：=标志。字符串（＆＃34; addr＆＃34;，＆＃34;：4000＆＃34;，＆＃34; https网络地址＆＃34;）certfile：=标志。字符串（＆＃34; certfile＆＃34;，＆＃34; cert.pem＆＃34;，＆＃34;证书pem文件＆＃34;）keyfile：=标志。字符串（＆＃34; keyfile＆＃34;，＆＃34; key.pem＆＃34;，＆＃34;关键pem文件＆＃34;）标志。 parse（）mux：= http。 newservemux（）mux。 hangefunc（＆＃34; /＆＃34; func（wthitch。remptingwriter，req * http.receque）{如果需要。url。路径！=＆＃34; /＆＃34; {http。notfound（w， req）return} fmt。fpptf（w，＆＃34;自豪地与go和https！＆＃34;）}）srv：=＆amp; http。服务器{addr：* addr，handler：mux，tlsconfig：＆amp; TLS。配置{Minversion：TLS。 VersionTLS13，PreferSerciphersuites：True，}，}日志。 Printf（＆＃34;％s＆＃34上的启动服务器;，* addr）err：= srv。 listendservetls（* certfile，* keyfile）日志。致命（错误）}</p><p> It serves a single handler on the root path. The interesting part is theTLS configuration, as well as the  ListenAndServeTLS call, which takes thepaths to a certificate file and a private key file (in PEM format, just aswe generated them earlier). The TLS configuration has many possible fields;here, I opted for a relatively strict protocol of forcing TLS 1.3 at minimum.TLS 1.3 comes with strong security out of the box, so this is a good option ifyou can ensure all your clients understand this version (and in 2021, theyshould!)</p><p> 它在根路径上为单个处理程序提供服务。有趣的部分是Thetl配置，以及ListendServetls调用，它将路径带到证书文件和私钥文件（以PEM格式为单位，刚刚为我们生成的。 TLS配置有许多可能的字段;这里，我选择了一个相对严格的迫使TLS 1.3的协议.TLS 1.3附带了强有力的安全性，所以这是一个很好的选择如果您可以确保所有客户都了解此版本（并且在2021年，他们应该！）</p><p> The diff from a plain HTTP server is fewer than 10 lines of code! The bulk ofthe server&#39;s code (handlers for specific routes) is completely oblivious to theunderlying protocol and won&#39;t change.</p><p> 来自普通HTTP服务器的差异不到10行代码！服务器＆＃39; s代码（特定路由的处理程序）完全忘记了禁止的协议，并赢得了＆＃39; t的变化。</p><p> With this server running locally (and serving on port 4000 by default), Chromewill initially balk when accessing it:</p><p> 使用此服务器本地运行（默认为端口4000上），ChromeWill最初在访问它时最初是Balk： </p><p>  That&#39;s because a web browser will not, by default, accept a self-signedcertificate. As mentioned above, browsers come with a hard-coded list of CAsthey trust, and our self-signed certificate is obviously not one of them. Wecan still proceed to the server by clicking Advanced and then allowing Chrometo go on, accepting the risk explicitly. It will then show us the website,albeit grudgingly (with a red &#34;Not secure&#34; sign in the address bar).</p><p>默认情况下，＆＃39; s是因为Web浏览器不会接受一个自映号的自映号。如上所述，浏览器附带一个硬编码的Casthey信任列表，我们的自签名证书显然不是其中之一。 WeCan仍然通过单击高级然后允许Chromoco继续进行服务器，明确接受风险。然后它将向我们展示网站，尽管勉强（带红色＆＃34;不可求和＃34;登录地址栏）。</p><p>  $ curl -Lv https://localhost:4000* Trying 127.0.0.1:4000...* TCP_NODELAY set* Connected to localhost (127.0.0.1) port 4000 (#0)* ALPN, offering h2* ALPN, offering http/1.1* successfully set certificate verify locations:* CAfile: /etc/ssl/certs/ca-certificates.crt CApath: /etc/ssl/certs* TLSv1.3 (OUT), TLS handshake, Client hello (1):* TLSv1.3 (IN), TLS handshake, Server hello (2):* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):* TLSv1.3 (IN), TLS handshake, Certificate (11):* TLSv1.3 (OUT), TLS alert, unknown CA (560):* SSL certificate problem: unable to get local issuer certificate* Closing connection 0curl: (60) SSL certificate problem: unable to get local issuer certificateMore details here: https://curl.haxx.se/docs/sslcerts.htmlcurl failed to verify the legitimacy of the server and therefore could notestablish a secure connection to it. To learn more about this situation andhow to fix it, please visit the web page mentioned above.</p><p>  $ curl -lv https：// localhost：4000 *尝试127.0.0.1：4000...* tcp_nodelay set *连接到localhost（127.0.0.1）端口4000（＃0）* ALPN，提供H2 * ALPN，提供HTTP / 1.1 *成功设置证书验证位置：* cafile：/etc/sl/certs/ca-certificates.crt capath：/ etc / ssl / certs * tlsv1.3（Out），TLS握手，客户端Hello（1）：* TLSv1 .3（in），tls握手，服务器hello（2）：* tlsv1.3（in），tls握手，加密扩展（8）：* tlsv1.3（in），tls握手，证书（11）：* tlsv1 .3（OUT），TLS警报，UNKNOWN CA（560）：* SSL证书问题：无法获取本地发行人证书*结束连接0Curl：（60）SSL证书问题：无法在此处获取本地发行者认证信息详细信息：https：/ /curl.haxx.se/docs/slcerts.htmlcurl无法验证服务器的合法性，因此可以不会建立到它的安全连接。要了解有关此情况的更多信息，请访问它，请访问上面提到的网页。</p><p> By reading the docs, we can find that  curl can be made to trust our serverby providing it with the server&#39;s certificate into the   --cacert flag. Ifwe try that:</p><p> 通过阅读文档，我们可以发现可以使卷曲信任我们的服务器，并将其提供给服务器和＃39; s证书到--cacert标志。如果我们试试：</p><p> $ curl -Lv --cacert &lt;path/to/cert.pem&gt; https://localhost:4000* Trying 127.0.0.1:4000...* TCP_NODELAY set* Connected to localhost (127.0.0.1) port 4000 (#0)* ALPN, offering h2* ALPN, offering http/1.1* successfully set certificate verify locations:* CAfile: /home/eliben/eli/private-code-for-blog/2021/tls/cert.pem CApath: /etc/ssl/certs* TLSv1.3 (OUT), TLS handshake, Client hello (1):* TLSv1.3 (IN), TLS handshake, Server hello (2):* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):* TLSv1.3 (IN), TLS handshake, Certificate (11):* TLSv1.3 (IN), TLS handshake, CERT verify (15):* TLSv1.3 (IN), TLS handshake, Finished (20):* TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1):* TLSv1.3 (OUT), TLS handshake, Finished (20):* SSL connection using TLSv1.3 / TLS_AES_128_GCM_SHA256* ALPN, server accepted to use h2* Server certificate:* subject: O=My Corp* start date: Mar 29 13:30:25 2021 GMT* expire date: Mar 29 16:30:25 2021 GMT* subjectAltName: host &#34;localhost&#34; matched cert&#39;s &#34;localhost&#34;* issuer: O=My Corp* SSL certificate verify ok.* Using HTTP2, server supports multi-use* Connection state changed (HTTP/2 confirmed)* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0* Using Stream ID: 1 (easy handle 0x557103006e10)&gt; GET / HTTP/2&gt; Host: localhost:4000&gt; user-agent: curl/7.68.0&gt; accept: */*&gt;* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):* Connection state changed (MAX_CONCURRENT_STREAMS == 250)!&lt; HTTP/2 200&lt; content-type: text/plain; charset=utf-8&lt; content-length: 33&lt; date: Mon, 29 Mar 2021 13:31:34 GMT&lt;* Connection #0 to host localhost left intactProudly served with Go and HTTPS!</p><p> $ curl -lv --cacert＆lt; path / to / cert.pem＆gt; https：// localhost：4000 *尝试127.0.0.1:4000...* tcp_nodelay设置*连接到localhost（127.0.0.1）端口4000（＃0）* ALPN，提供H2 * ALPN，提供HTTP / 1.1 *成功设置证书验证位置：* cafile：/ home/eliben/eli/private-code-for-blog/2021/tls/cert.pem capath：/ etc / ssl / certs * tlsv1.3（出），tls握手，客户招呼（1）：* TLSV1.3（IN），TLS握手，服务器Hello（2）：* TLSv1.3（IN），TLS握手，加密扩展（8）：* TLSv1.3（IN），TLS握手，证书（11）：* tlsv1.3（in），tls握手，证书验证（15）：* tlsv1.3（in），tls握手，完成（20）：* tlsv1.3（out），tls更改密码，更改密码规格（1）：* TLSv1.3（OUT），TLS握手，完成（20）：* SSL连接使用TLSv1.3 / TLS_AES_128_GCM_SHA256 * ALPN，服务器被接受使用H2 *服务器证书：*主题：o =我的corp *开始日期：3月29日13:30:25 2021 GMT *过期日期：3月29日16:30:25 2021 GMT * SoberAstname：主机＆＃34; localhost＆＃34;匹配的证书＆＃39; s＆＃34; localhost＆＃34; *发行人：o = my corp * ssl证书验证确定。*使用http2，服务器支持多用途*连接状态已更改（HTTP / 2确认）*复制http / 2在升级后流缓冲区中的数据流缓冲区：LEN = 0 *使用流ID：1（简易处理0x557103006E10）＆gt; get / http / 2＆gt;主持人：localhost：4000＆gt;用户代理：CURL / 7.68.0＆gt;接受：* / *＆gt; * tlsv1.3（in），tls握手，newsession票（4）：*连接状态已更改（max_concurrent_streams == 250）！＆lt; http / 2 200＆lt;内容类型：文本/平原; charset = UTF-8＆lt;内容长度：33＆lt;日期：Mon，29 Mar 2021 3月29日13:31:34 GMT＆lt; *连接＃0到主机localhost左转and https！</p><p>  We can also talk to our server using a custom HTTPS client written in Go. Here&#39;sthe code:</p><p>  我们还可以使用常用的自定义HTTPS客户端与我们的服务器交谈。这里＆＃39;代码：</p><p> func  main ()  {  addr  :=  flag . String ( &#34;addr&#34; ,  &#34;localhost:4000&#34; ,  &#34;HTTPS server address&#34; )  certFile  :=  flag . String ( &#34;certfile&#34; ,  &#34;cert.pem&#34; ,  &#34;server certificate&#34; )  flag . Parse ()  cert ,  err  :=  os . ReadFile ( * certFile )  if  err  !=  nil  {  log . Fatal ( err )  }  certPool  :=  x509 . NewCertPool ()  if  ok  :=  certPool . AppendCertsFromPEM ( cert );  ! ok  {  log . Fatalf ( &#34;unable to parse cert from %s&#34; ,  * certFile )  }  client  :=  &amp; http . Client {  Transport :  &amp; http . Transport {  TLSClientConfig :  &amp; tls . Config {  RootCAs :  certPool ,  },  },  }  r ,  err  :=  client . Get ( &#34;https://&#34;  +  * addr )  if  err  !=  nil  {  log . Fatal ( err )  }  defer  r . Body . Close ()  html ,  err  :=  io . ReadAll ( r . Body )  if  err  !=  nil  {  log . Fatal ( err )  }  fmt . Printf ( &#34;%v\n&#34; ,  r . Status )  fmt . Printf ( string ( html )) }</p><p> func main（）{addr：=标志。字符串（＆＃34; addr＆＃34;，＆＃34; localhost：4000＆＃34;，＆＃34; https服务器地址＆＃34;）certfile：=标志。字符串（＆＃34; certfile＆＃34;，＆＃34; cert.pem＆＃34;，＆＃34;服务器证书＆＃34;）标志。 parse（）cert，err：=操作系统。 ReadFile（* Certfile）如果err！= nil {log。致命（错误）} certpool：= x509。 newcertpool（）如果确定：= certpool。 Appendcertsfrompem（证书）; ！！好的{log。 Fatalf（＆＃34;无法解析％s＆＃34;，* certfile）}客户端：=＆amp; http。客户{Transport：＆amp; http。运输{tlsclientconfig：＆amp; TLS。配置{rootcas：certpool，}，}，} r，err：= client。获取（＆＃34; https：//＆＃34; + * addr）如果err！= nil {log。致命（错误）}推迟r。身体 。关闭（）HTML，ERR：= IO。如果err！= nil {log。 FAGAL（ERR）} FMT。 Printf（＆＃34;％v \ n＆＃34;，r。状态）fmt。 printf（字符串（html））}</p><p> The only part making this different from a standard HTTP client is the TLSsetup. The important bit is setting up the  RootCAs field of the tls.Config struct. This is telling Go which certificates the client cantrust.</p><p> 与标准HTTP客户端不同的唯一部分是TLSSetup。重要位是设置TLS.config结构的rootcas字段。这是告诉我们客户昏昏欲睡的证书。 </p><p> You may not know that Go comes with a tool to generate self-signedTLS certificates, right in the standard installation. If you have Go installedat  /usr/local/go, you can run this tool with:</p><p>您可能不知道Go附带一个工具，可以在标准安装中生成自签名状态证书。如果您有Go SimiteAt / USR / Local / Go，则可以使用以下工具运行：</p><p>  In general, it accomplishes the same goal as the first code snippet in thispost, but whereas my snippet makes some opinionated decisions about what togenerate,  generate_cert is configurable with flags and supports severaldifferent options.</p><p>  通常，它完成了与ThisPost中的第一个代码片段相同的目标，而我的代码段对其进行了一些有关的决策，则将Generate_Cert配置有关标志并支持几个选项。</p><p> As we&#39;ve seen, while self-signed certificates can work for testing, they&#39;re notideal for all scenarios. For example, it&#39;s difficult to make browsers trustthem, and even then the user experience doesn&#39;t fully replicate the &#34;real world&#34;one.</p><p> 正如我们所看到的，虽然自签名证书可以用于测试，但他们＆＃39;重新判断所有情景。例如，它难以使浏览器Trustthem＆＃39;即使那么用户体验也不完全复制＆＃34;现实世界＆＃34;一个。</p><p> Another option for generating local certificates for testing is the mkcert tool. It creates a localcertificate authority (CA), and adds it to your system&#39;s trusted list of CAs.It then generates certificates signed by this authority for you, so as far asthe browser is concerned, they&#39;re fully trusted.</p><p> 生成用于测试的本地证书的另一个选项是MKCert工具。它创建了一个LocalCertificate权限（CA），并将其添加到您的系统＆＃39; S受信任的CAS的可信列表。然后，为您生成由此权限签名的证书，因此在浏览器的威胁中，他们＆＃39;重新获得完全信任。</p><p> If we run our simple HTTPS server with a certificate/key generated by mkcert, Chrome will happily access it without warnings; we can also seethe details in the Security tab of developer tools:</p><p> 如果我们使用MKCert生成的证书/键运行我们的简单HTTPS服务器，Chrome将愉快地访问它而不进行警告;我们还可以在开发人员工具的“安全”选项卡中进行详细信息：</p><p>  curl will also successfully contact the server without requiring a cacert flag, because it checks the system&#39;s trusted CAs already.</p><p>  卷曲还将成功联系服务器而无需CACERT标志，因为它已经检查了系统＆＃39; S值得信赖的CAS。</p><p> If you&#39;re looking for  real certificates, Let&#39;s Encrypt is of course a naturaloption, using the  certbot client or somethingsimilar. In Go, libraries like  certmagic can automate the interaction withLet&#39;s Encrypt for servers.</p><p> 如果您＆＃39;重新查找真实证书，Let＆＃39; S加密当然是NationalOption，使用Certbot客户端或某些内容。在Go中，像CertMagic这样的图书馆可以自动化与服务器加密的交互和＃39; s加密。 </p><p> So far the examples we&#39;ve seen have the server providing its (CA-signed)certificate to the client to prove that the server is legitimately who it claimsto be (e.g. your bank&#39;s website, before you agree to provide your password).</p><p>到目前为止我们看到的例子是我们看到的服务器向客户提供了（CA-签名的）证书，以证明服务器合法地索赔者（例如您的银行＆＃39; s网站，在您同意提供之前你的密码）。</p><p> This idea is easy to extend to  mutual authentication, where the client alsohas a signed certificate to prove its identity. In the world of TLS, this iscalled  mTLS (for  mutual TLS), and could be useful in many settings whereinternal services have to communicate with each other securely. Public-keycrypto is generally considered more secure than passwords.</p><p> 这个想法很容易扩展到相互身份验证，客户端也是签名证书以证明其身份。在TLS的世界中，这种ISCalled MTLS（用于相互TLS），并且在许多设置中都有用的是，有时候服务必须安全地互相通信。公共keycrypto通常被认为比密码更安全。</p><p> Here&#39;s a simple HTTPS server with client authentication. The lines that changedfrom the earlier HTTPS server are highlighted:</p><p> 这里＆＃39; s具有客户端身份验证的简单HTTPS服务器。从早期的HTTPS服务器突出显示的线条：</p><p> func  main ()  {  addr  :=  flag . String ( &#34;addr&#34; ,  &#34;:4000&#34; ,  &#34;HTTPS network address&#34; )  certFile  :=  flag . String ( &#34;certfile&#34; ,  &#34;cert.pem&#34; ,  &#34;certificate PEM file&#34; )  keyFile  :=  flag . String ( &#34;keyfile&#34; ,  &#34;key.pem&#34; ,  &#34;key PEM file&#34; )   clientCertFile  :=  flag . String ( &#34;clientcert&#34; ,  &#34;clientcert.pem&#34; ,  &#34;certificate PEM for client authentication&#34; )  flag . Parse ()  mux  :=  http . NewServeMux ()  mux . HandleFunc ( &#34;/&#34; ,  func ( w  http . ResponseWriter ,  req  * http . Request )  {  if  req . URL . Path  !=  &#34;/&#34;  {  http . NotFound ( w ,  req )  return  }  fmt . Fprintf ( w ,  &#34;Proudly served with Go and HTTPS!&#34; )  })   // Trusted client certificate.   clientCert ,  err  :=  os . ReadFile ( * clientCertFile )   if  err  !=  nil  {   log . Fatal ( err )   }   clientCertPool  :=  x509 . NewCertPool ()   clientCertPool . AppendCertsFromPEM ( clientCert )  srv  :=  &amp; http . Server {  Addr :  * addr ,  Handler :  mux ,  TLSConfig :  &amp; tls . Config {  MinVersion :  tls . VersionTLS13 ,  PreferServerCipherSuites :  true ,   ClientCAs :  clientCertPool ,   ClientAuth :  tls . RequireAndVerifyClientCert ,  },  }  log . Printf ( &#34;Starting server on %s&#34; ,  * addr )  err  =  srv . ListenAndServeTLS ( * certFile ,  * keyFile )  log . Fatal ( err ) }</p><p> func main（）{addr：=标志。字符串（＆＃34; addr＆＃34;，＆＃34;：4000＆＃34;，＆＃34; https网络地址＆＃34;）certfile：=标志。字符串（＆＃34; certfile＆＃34;，＆＃34; cert.pem＆＃34;，＆＃34;证书pem文件＆＃34;）keyfile：=标志。字符串（＆＃34; keyfile＆＃34;，＆＃34; key.pem＆＃34;，＆＃34; key pem文件＆＃34;）clientCertfile：=标志。字符串（＆＃34; clientcert＆＃34;，＆＃34; clientcert.pem＆＃34;，＆＃34;客户身份验证和＃34的证书pem;）标志。 parse（）mux：= http。 newservemux（）mux。 hangefunc（＆＃34; /＆＃34; func（wthitch。remptingwriter，req * http.receque）{如果需要。url。路径！=＆＃34; /＆＃34; {http。notfound（w， REQ）返回} FMT。FPRINGF（W，＆＃34;自豪地与GO和HTTPS服务！＆＃34;）}）//受信任的客户证书。 ClientCert，Err：= OS。 ReadFile（* ClientCertFile）如果Err！= nil {log。致命（错误）} clientCertPool：= x509。 newcertpool（）clientcertpool。 Appendcertsfrompem（ClientCert）SRV：=＆amp; http。服务器{addr：* addr，handler：mux，tlsconfig：＆amp; TLS。配置{Minversion：TLS。 VersionTLS13，PreferServiphersuites：True，ClientCas：ClientCertPool，ClientAuth：TLS。 REALEANDVERIFYCLIENTCERT，}，}日志。 Printf（＆＃34;在％s＆＃34上启动服务器;，* addr）err = srv。 listendservetls（* certfile，* keyfile）日志。致命（错误）}</p><p> The changes are pretty much what you&#39;d expect; in addition to setting up itsown certificate, key and TLS config, the server loads a client certificate andsets  TLSConfig to trust it. Naturally, this could also be the certificateof a locally trusted CA which signs client certificates.</p><p> 这些变化几乎是什么＆＃39; d期待;除了设置Itnown证书，键和TLS Config之外，服务器还加载客户端证书，并支持TLSConfig以信任它。当然，这也可以是签署客户证书的本地受信任的CA的证书。</p><p> And this is an HTTPS client which authenticates itself when connecting to aserver; again, the lines that changed from the earlier (non-mTLS) client arehighlighted:</p><p> 这是一个HTTPS客户端，它在连接到Aserver时攻击自己;再次，从前（非MTLS）客户端更改的行是highlighted：</p><p> func  main ()  {  addr  :=  flag . String ( &#34;addr&#34; ,  &#34;localhost:4000&#34; ,  &#34;HTTPS server address&#34; )  certFile  :=  flag . String ( &#34;certfile&#34; ,  &#34;cert.pem&#34; ,  &#34;server certificate&#34; )   clientCertFile  :=  flag . String ( &#34;clientcert&#34; ,  &#34;clientcert.pem&#34; ,  &#34;certificate PEM for client&#34; )   clientKeyFile  :=  flag . String ( &#34;clientkey&#34; ,  &#34;clientkey.pem&#34; ,  &#34;key PEM for client&#34; )  flag . Parse ()   // Load our client certificate and key.   clientCert ,  err  :=  tls . LoadX509KeyPair ( * clientCertFile ,  * clientKeyFile )   if  err  !=  nil  {   log . Fatal ( err )   }  // Trusted server certificate.  cert ,  err  :=  os . ReadFile ( * certFile )  if  err  !=  nil  {  log . Fatal ( </p><p> func main（）{addr：=标志。字符串（＆＃34; addr＆＃34;，＆＃34; localhost：4000＆＃34;，＆＃34; https服务器地址＆＃34;）certfile：=标志。字符串（＆＃34; certfile＆＃34;，＆＃34; cert.pem＆＃34;，＆＃34;服务器证书＆＃34;）clientCertfile：=标志。字符串（＆＃34; clientcert＆＃34;，＆＃34; clientcert.pem＆＃34;，＆＃34;客户端＆＃34的证书pem; clientKeyFile：=标志。字符串（＆＃34; clientkey＆＃34;，＆＃34; clientkey.pem＆＃34;，＆＃34;客户端＆＃34的关键pem; parse（）//加载我们的客户端证书和密钥。 ClientCert，Err：= TLS。 loadx509keypair（* clientcertfile，* clientKeyfile）如果err！= nil {log。致命（错误）} //受信任的服务器证书。 CERT，ERR：= OS。 ReadFile（* Certfile）如果err！= nil {log。致命的 （ </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://eli.thegreenplace.net/2021/go-https-servers-with-tls/">https://eli.thegreenplace.net/2021/go-https-servers-with-tls/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/tls/">#tls</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/servers/">#servers</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/证书/">#证书</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>