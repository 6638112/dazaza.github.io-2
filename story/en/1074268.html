<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何用Python编写更好的科学代码？How to write better scientific code in Python?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to write better scientific code in Python?<br/>如何用Python编写更好的科学代码？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 18:33:26</div><div class="page_narrow text-break page_content"><p>A large part of any scientific effort lies down in writing code.Be it typical machine-learning modeling, an analysis, or contributing to a data project,a significant part of the time goes into prototyping new functionalities.Being exploratory, it is expected that several parts of the program will be replaced or modified often beyond what was planned initially.</p><p>任何科学努力的很大一部分都在于编写代码。无论是典型的机器学习建模、分析，还是参与数据项目，大部分时间都花在了新功能的原型设计上。由于是探索性的，预计该计划的几个部分将被替换或修改，通常会超出最初的计划。</p><p> Unlike for “consumer software”, changes are often induced not by customer’s requirements,but rather by outcomes of the process along the way.For this reason, it is extremely valuable to design it in ways,which will not require a “total reconstruction”, if experimental evidence suggests a differentpath.</p><p>与“消费者软件”不同，变化通常不是由客户的需求引起的，而是由过程的结果引起的。因此，如果实验证据表明存在不同的路径，以不需要“完全重建”的方式设计它是非常有价值的。</p><p> Writing science code comes with two (additional) specific challenges:The first one relates to mathematical errors.Mistakes in computations are often hard to trace, especially when the code is semanticallycorrect.No bugs are found.No exception is raised.All looks good, but the (numerical) result is wrong.Especially, with implementing probabilistic models, the results may sometimes look good,depending on some initial conditions or a random factor.</p><p>编写科学代码有两个（额外的）具体挑战：第一个与数学错误有关。计算中的错误通常很难追踪，尤其是当代码语义正确时。没有发现漏洞。没有提出任何例外。一切看起来都不错，但（数字）结果是错误的。特别是，通过实施概率模型，结果有时可能看起来不错，这取决于一些初始条件或随机因素。</p><p> The second comes from the fact described earlier.There will always be experimental parts, and they change all the time.Therefore, the key is to design each component, so that most of the work can stayand serve as a rock-solid foundation for the next stage of development.</p><p>第二个来自前面描述的事实。总会有实验性的部分，而且它们一直在变化。因此，关键是要设计每一个部件，使大部分工作能够为下一阶段的发展奠定坚实的基础。</p><p> In this article, we focus on patterns that can make the code more robust,understandable, and overall easier to handle.You will see how simple improvements can lead to more reusable code and fewer bugs.</p><p>在本文中，我们将重点介绍一些模式，这些模式可以使代码更加健壮、易于理解，并且总体上更易于处理。您将看到简单的改进可以带来更多可重用的代码和更少的bug。</p><p>  Our task, for the sake of demonstration, is to calculate the  expected valueof outcomes of a random process.Mathematically, it comes down to this formula:</p><p>为了演示，我们的任务是计算随机过程结果的预期值。从数学上讲，可以归结为以下公式：</p><p>   As you may wonder, the challenge here is that you want it to work with  any distribution:continuous or discrete.Or if not plausible, you want at least to recognize the nature of the problem,so you can adapt the code smoothly.</p><p>正如你可能想知道的，这里的挑战是，你希望它能与任何分布：连续或离散。或者，如果不合理，至少要认识到问题的本质，这样才能顺利地调整代码。</p><p>  Let’s start with a not-so-good code, to begin with.Say you want to roll six-sided dice.With each outcome equally probable, it comes down to calculating the mean value over sampled results.</p><p>让我们从一个不太好的代码开始。假设你想掷六面骰子。由于每个结果的概率都相等，因此需要计算抽样结果的平均值。</p><p> import  random import  statistics def  die ( sides  =  6 ):  return  random . randint ( 1 ,  sides ) def  expected_value ( n_samples ):  samples  =  [ die ()  for  _  in  range ( n_samples )]  return  statistics . mean ( samples )</p><p>导入随机导入统计数据def die（sides=6）：返回随机。randint（1，sides）def expected_value（n_samples）：samples=[范围内（n_samples）的die（）]返回统计信息。平均值（样本）</p><p>  First of all, the  die function returns one sample at a time.It needs to be called  N times to get  N samples, which is slow.</p><p>首先，die函数一次返回一个样本。需要调用N次才能获得N个样本，这很慢。</p><p> Secondly, the  expected_value function strongly depends on the  die functionthat produces samples.It is evident, once you consider using a different die, say a 12-sided one.With this design, you need to “open” the  expected_value to accept an additionalparameter  sides, only to pass it on to  die to extend it for the more general case.While this would work, it makes the  interface of  expected_value unintuitive,but the solution still relies on using  die as the source of samplesthus making it hard to consider other distributions.</p><p>其次，期望_值函数强烈依赖于生成样本的模函数。显然，一旦你考虑使用不同的骰子，比如说12面骰子。在这种设计中，您需要“打开”预期的_值，以接受额外的参数，然后将其传递到模具，以扩展到更一般的情况。虽然这会起作用，但它使得ExpEdTyx值的接口不直观，但是该解决方案仍然依赖于使用骰子作为采样源，从而使得很难考虑其他分布。</p><p>      This is pretty obvious, but you just move the problem elsewhere…Now,  samples become a new entity, storage for data (even very large),and it is quite anonymous.The  expected_value function expects to receive it but to prepare it is on you.</p><p>这是非常明显的，但你只是把问题转移到其他地方……现在，样本变成了一个新的实体，用于存储数据（甚至非常大），而且它是相当匿名的。expected_value函数希望接收它，但准备它的工作由您自己负责。</p><p>  Another way is to keep the  die inside, by passing it to  expected_value as an object.</p><p>另一种方法是将模具保持在内部，将其作为对象传递给预期的_值。</p><p> from  functools  import  partial twelve_sided_die  =  partial ( die ,  12 ) def  expected_values ( die ,  n_samples ):  samples  =  [ die ()  for  _  in  range ( n_samples )]  return  statistics . mean ( samples ) ev  =  expected_values ( twelve_sided_die ,  10000 )</p><p>从functools导入部分十二面_die=partial（die，12）def预期_值（die，n_samples）：samples=[die（）用于范围内（n_samples）]返回统计信息。平均值（样本数）ev=预期值（十二面，10000）</p><p> The idea uses a prepared “version” of  die and makes  expected_value use it as the sourceof samples.However, a new problem arises:The  expected_value is only compatible with  die.It can’t compute the result with any other “sample generator”, or at least it is notguaranteed to do it correctly.</p><p>该想法使用了一个准备好的“版本”模具，并使预期的_值将其用作样本来源。然而，出现了一个新问题：预期的_值仅与die兼容。它不能用任何其他“样本生成器”计算结果，或者至少不能保证它能正确地计算结果。</p><p>  The third idea is to recognize the problem at a more abstract level and design better interfaces.</p><p>第三个想法是在更抽象的层面上认识问题，并设计更好的接口。</p><p>  There exist a  probability distribution from which we can sample. (It can be a die, a coin, normal distribution - doesn’t matter).</p><p>存在一个概率分布，我们可以从中取样。（它可以是一个骰子，一枚硬币，正态分布——没关系）。</p><p>  There is a  mathematical operation that consumes and transforms data. (E.g. calculating mean, variance, etc.).</p><p>有一种数学运算可以消耗和转换数据。（例如，计算平均值、方差等）。</p><p> Let’s give is more attention to how we can build the right abstractionsand how to control their mutual compatibility.</p><p>让我们更加关注如何构建正确的抽象，以及如何控制它们的相互兼容性。</p><p>  Mathematically, a probability distribution can be function - continuous or discrete, finite or infinite, from which we can  draw samples.The “prescription” for this function can be very different depending on the problem.We may use an “existing” formula such as Gaussian or Poisson distribution, but it can also be a “custom” creation derived from e.g. histogram.</p><p>从数学上讲，概率分布可以是函数——连续或离散，有限或无限，我们可以从中抽取样本。根据问题的不同，此功能的“处方”可能会非常不同。我们可以使用“现有”公式，如高斯分布或泊松分布，但它也可以是从直方图衍生的“自定义”创建。</p><p>    Due to  @abstractmethod, our distribution enforces that we implement  sample method to any child class that derives from this abstraction.For our die, this can be:</p><p>由于@abstractmethod的存在，我们的发行版强制我们对从这个抽象派生的任何子类实现sample方法。对于我们的死亡，这可以是：</p><p> import  numpy  as  np class  Die ( Distribution ):  def  __init__ ( self ,  sides  =  6 ):  self . sides  =  sides  def  sample ( self ,  n_samples ):  return  np . random . randint ( 1 ,  self . sides  +  1 ,  size = n_samples )</p><p>将numpy作为np类模具导入（分发）：def__init__（self，sides=6）：self。侧面=侧面def样本（自身，n_样本）：返回np。随机的randint（1，自边+1，大小=n_个样本）</p><p> Here, the delivery of samples happens by invoking the method  sample that is specificto tossing a fair die:  Die(12).sample(10000).Moreover, thanks to  numpy, we can create large amounts of data very quickly byreplacing the list comprehension with  np.ndarray.</p><p>这里，通过调用特定于抛出公平骰子的方法sample来交付样本：骰子（12）。样本（10000）。此外，得益于numpy，我们可以通过使用np替换列表理解来快速创建大量数据。恩达雷。</p><p> In fact, things can be improved even further.Currently, calling  Die() returns something like this  &lt;__main__.Die at 0x7f43f4448400&gt;,which is not imformative. Aslo  Die() == Die() evaluates to  False, as for pythonthey are two different object instances of the same class.To fix it, we need to implement two more methods:</p><p>事实上，事情还可以进一步改善。目前，调用Die（）会返回如下内容&lt__主要的。模具位于0x7F43F448400&gt；，这并不具有信息性。对于Pythonthy，它们是同一类的两个不同对象实例。要解决这个问题，我们还需要实现另外两种方法：</p><p> def  __repr__ ( self ):  return  f &#34;{self.__class__.__name__}(sides={self.sides})&#34;  def  __eq__ ( self ,  other ):  if  isinstance ( other ,  self . __class__ ):  return  self . sides  ==  other . sides  return  False</p><p>def__repr__（self）：返回f&#34；{self._class__._name__}（sides={self.sides}）和#34；def__eq__（self，other）：如果是instance（other，self._class___）：返回self。两边。双方返回错误</p><p> The  __repr__ method makes the rendering of the object nice,and  __eq__ will only return  True if the dice are “equally sided”.</p><p>__repr______________________________________________。</p><p>  Implementing the four methods each time can be tedious.Besides, the current implementation of  Die does not prevent altering of an object, even accidentally, by assigning the attribute to an existing object like this  die.sides = 20.</p><p>每次实现这四种方法可能会很乏味。此外，当前的Die实现并不能通过将属性指定给像这个Die这样的现有对象来防止对象的更改，即使是意外更改。侧面=20。</p><p>  from  dataclasses  import  dataclass @dataclass ( frozen = True ) class  Die ( Distribution ):  sides :  int  =  6  def  sample ( self ,  n ):  return  np . random . randint ( 1 ,  self . sides  +  1 ,  size = n )</p><p>从dataclasses导入dataclass@dataclass（冻结=True）类死亡（分布）：侧面：int=6 def样本（self，n）：返回np。随机的randint（1，自边+1，大小=n）</p><p> The behavior of this example is the same as the one before.Additionally, setting  frozen=True, assigning a new value to  die.sides will raise an exception.If we want a new die, we should create a new object.</p><p>这个例子的行为和之前的一样。此外，设置freezed=True，为die指定一个新值。双方将提出一个例外。如果我们想要一个新的模具，我们应该创建一个新的对象。</p><p> Now, our  expected_value function will likely take  die as a distribution objectand do the math by calling its  sample method.</p><p>现在，我们的expected_value函数可能会将die作为一个分布对象，并通过调用它的sample方法进行计算。</p><p>   The above example is neat.We know exactly what  expected_value does, and it is easy to test.However, an n-sided die is not the only distribution we may want to calculate the expectedvalue of.For example, for the tossing of a coin, the outcomes are not numeric (unless we establish a convention and stick to it).Naturally, it makes sense to provide some hints as to what interfaces can be usedtogether and how.</p><p>上面的例子很简洁。我们确切地知道预期_值的作用，并且很容易测试。然而，n面模具并不是我们可能想要计算的期望值的唯一分布。例如，抛硬币的结果不是数字的（除非我们建立一个惯例并坚持下去）。当然，提供一些关于哪些接口可以一起使用以及如何使用的提示是有意义的。</p><p> For a  dynamically typed language like python, you are not forced to stick to variables’ types.However, with various IDEs and tools such as  mypy, typing can help you spotpotential points of failure and make the code more transparent.</p><p>对于python这样的动态类型化语言，您不必拘泥于变量的类型。然而，使用各种IDE和工具（如mypy），键入可以帮助您发现潜在的故障点，并使代码更加透明。</p><p>  from  typing  import  Generic ,  Sequence ,  TypeVar D  =  TypeVar ( &#34;D&#34; ) class  Distribution ( ABC ,  Generic [ D ]):  @abstractmethod  def  sample ( self ,  n :  int )  -&gt;  Sequence [ D ]:  ... @dataclass ( frozen = True ) class  Die ( Distribution [ int ]):  sides :  int  =  6  def  sample ( self ,  n :  int )  -&gt;  Sequence [ int ]:  return  np . random . randint ( 1 ,  self . sides  +  1 ,  size = n ) @dataclass ( frozen = True ) class  Coin ( Distribution [ str ]):  outcomes :  tuple  =  ( &#34;H&#34; ,  &#34;T&#34; )  fairness :  float  =  0.5  def  sample ( self ,  n :  int )  -&gt;  Sequence [ str ]:  p  =  ( self . fairness ,  1.0  -  self . fairness )  return  np . random . choice ( self . outcomes ,  size = n ,  p = p ) @dataclass ( frozen = True ) class  Gaussian ( Distribution [ float ]):  mu :  float  =  0.0  sigma :  float  =  1.0  def  sample ( self ,  n :  int )  -&gt;  Sequence [ float ]:  np . random . normal ( loc = self . mu ,  scale = self . sigma ,  size = n )</p><p>输入import Generic、Sequence、TypeVar D=TypeVar（&#34；D&#34；）类分布（ABC，泛型[D]）：@abstractmethod def sample（self，n:int）->；序列[D]：@数据类（冻结=True）类模具（分布[int]）：侧面：int=6 def样本（自身，n:int）->；序列[int]：返回np。随机的randint（1，self.sides+1，size=n）@dataclass（冻结=True）类硬币（分布[str]）：结果：元组=（&#34；H&#34；，&#34；T&#34；）公平性：浮动=0.5 def样本（自身，n:int）->；Sequence[str]：p=（self.fairity，1.0-self.fairity）返回np。随机的选择（self.outcocts，size=n，p=p）@dataclass（冻结=True）class Gaussian（分布[float]）：mu:float=0.0 sigma:float=1.0 def样本（self，n:int）->；序列[float]：np。随机的正常（loc=self.mu，scale=self.sigma，size=n）</p><p> Several things that happen here.Thanks to  D = TypeVar(&#34;D&#34;), we can now define a new variable type, by whichwe parametrize each distribution’s type.You can notice that  Distribution inherits not only after the abstract base classbut also after  Generic[D], which turns it also into a new (parametrized) type.Now, it becomes a sort of identity, constituting a new data type.</p><p>这里发生了几件事。多亏了D=TypeVar（&#34；D&#34；），我们现在可以定义一个新的变量类型，通过它我们可以参数化每个分布的类型。您可以注意到，Distribution不仅在抽象基类之后继承，而且在泛型[D]之后继承，这也将它转换为一个新的（参数化的）类型。现在，它变成了一种身份，构成了一种新的数据类型。</p><p> Each version of  sample is expected to return a sequence of a particular typethat makes sense to each individual distribution’s context.This way, we have a unified interface that is a also parametrized.We can use this to ensure the correct behavior of  expected_value:</p><p>每个版本的示例都会返回一个特定类型的序列，该序列对每个发行版的上下文都有意义。这样，我们就有了一个统一的接口，它也是一个参数化的接口。我们可以使用它来确保预期_值的正确行为：</p><p>  While passing e.g.  die = Die() or  gaussian = Gaussian() to  expected_value will work(as both  int and  float are numeric), passing  coin = Coin() will be flagged outby e.g.  mypy, stating that</p><p>当将例如die=die（）或gaussian=gaussian（）传递到预期的_值时（因为int和float都是数字），传递coin=coin（）将被例如mypy标记出来，说明</p><p>    As you can see, designing interfaces using  typing helps to formalize the intensionsand catch bugs early.You can even bring it to the next level by leveraging  numpy’s  dtype.This way, you will not only ensure that the different elements fit together, but alsobe more conscious regarding the memory footprint of your data.</p><p>正如您所见，使用类型化设计接口有助于将意图形式化，并尽早捕获错误。您甚至可以利用numpy的数据类型将其提升到下一个级别。这样，您不仅可以确保不同的元素组合在一起，还可以更加注意数据的内存占用。</p><p>  import  numpy.typing  as  npt class  Distribution ( ABC ,  Generic [ D ]):  @abstractmethod  def  sample ( self ,  n :  int )  -&gt;  np . NDArray [ np . generic ]:  ... class  Die ( Distribution [ int ]):  sides :  int  =  6  def  sample ( self ,  n :  int )  -&gt;  npt . NDArray [ np . uint8 ]:  return  np . random . randint (  1 ,  self . sides  +  1 ,  size = n ,  dtype = np . uint8  )</p><p>进口numpy。键入npt类分布（ABC，泛型[D]）：@abstractmethod def sample（self，n:int）->；NPNDArray[np.泛型]：。。。级模具（分配[int]）：侧面：int=6 def样本（自身，n:int）->；《不扩散条约》。NDArray[np.uint8]：返回np。随机的randint（1，self.sides+1，size=n，dtype=np.uint8）</p><p> This way, you will even be informed if the  die.sample method returns numbers thatare different than strictly unsigned 8-bit integers.The question is whether you want to go that deep?It’s something to think about.</p><p>这样，你甚至会被告知，如果死亡。sample方法返回与严格无符号8位整数不同的数字。问题是你是否想深入到那一步？这是一件值得思考的事情。</p><p>  Let’s come back to designing the calculation part.So far, we have  expected_value that is prepared to work with numerical distributions.Naturally, we can compute the expected value for  Die and  Gaussian, but not for  Coin.Not with the current design.</p><p>让我们回到设计计算部分。到目前为止，我们已经预期了_值，它可以用于数值分布。当然，我们可以计算骰子和高斯的期望值，但不能计算硬币的期望值。与当前的设计不同。</p><p>  We can create a  proxy distribution by mapping e.g.  (&#34;H&#34;, &#34;T&#34;) -&gt; (0, 1), or</p><p>我们可以通过映射来创建代理分布，例如（&#34；H&#34；，&#34；T&#34；）-&gt；（0,1），或</p><p> The first approach creates an artificial body, whose idea relies on convention.It doesn’t prevent anyone from defining another proxy with  (&#34;H&#34;, &#34;T&#34;) -&gt; (1, 0),leading to a hard to detect the bug.</p><p>第一种方法创建了一个人造身体，其想法依赖于惯例。它不会阻止任何人用（&#34；H&#34；，&#34；t&#34；）定义另一个代理-&gt；（1,0），导致错误难以检测。</p><p>  def  expected_value (  d :  Distribution [ D ],  f :  Callable [[ D ],  Any ]  =  lambda  x :  x ,  n :  int  =  1000 )  -&gt;  float :  return  np . mean ( np . apply_along_axis ( f ,  axis = 0 ,  arr = d . sample ( n )))</p><p>def预期_值（d:分布[d]，f:可调用[[d]，任意]=lambda x:x，n:int=1000）->；float：返回np。平均值（np.沿_轴应用_（f，轴=0，arr=d.样本（n）））</p><p> The second argument to  expected_value is a callable (a function), that we can optionallyuse to translate outcomes of e.g.  Coin() distribution.By default, however, it will leave the outcomes intact.</p><p>expected_value的第二个参数是一个可调用的（函数），我们可以选择使用它来转换Coin（）分布的结果。然而，默认情况下，它将保持结果不变。</p><p> die  =  Die ( 12 ) expected_values ( die ,  n = 10000 ) gaussian  =  Gaussian ( mu = 4.0 ,  sigma = 2.0 ) expected_value ( gaussian ,  n = 100000 ) # but coin  =  Coin ( fairness = 0.75 ) expected_value ( coin ,  f = lambda  x :  np . where ( x  ==  &#34;H&#34; ,  1.0 ,  0.0 ))</p><p>die=die（12）预期_值（die，n=10000）gaussian=gaussian（mu=4.0，sigma=2.0）预期_值（gaussian，n=100000）#但coin=coin（公平性=0.75）预期_值（coin，f=lambda x:np.其中（x==&#34；H&#34；，1.0，0.0））</p><p> Here, we not only avoided creating a proxy distribution but also managed to avoidtying  expected_value to any specific way of converting the data.The  expected_value function does only what it promises to do: computes the expected value.If any adaptation or conversion is required, it is provided externally.Note that also here we have an option: we can define a named function (e.g.  coin_conversion)in case we plan to reuse it or stick to  lambda when a separate definition doesnot add value.</p><p>在这里，我们不仅避免创建代理分布，而且还设法避免将预期的_值转换为任何特定的数据转换方式。expected_value函数只执行它承诺的操作：计算期望值。如果需要任何调整或转换，则由外部提供。请注意，这里我们还有一个选项：我们可以定义一个命名函数（例如coin_转换），以防我们计划重用它，或者在单独的定义没有增加价值时坚持使用lambda。</p><p>  Abstracting away mathematical calculations proves itself useful especially withdesigning  iterative algorithms.Oftentimes, aside from the main computations, we have to keep an eye on somecollateral results such as convergence, early stopping (max iterations), metrics, and so on.</p><p>事实证明，抽象数学计算本身非常有用，尤其是在设计迭代算法时。通常，除了主要的计算之外，我们还必须关注一些附带的结果，比如收敛、提前停止（最大迭代）、度量等等。</p><p> Let’s take the  constant for example.Mathematically, we can get its value by taking the following limit:</p><p>让我们以常数为例。从数学上讲，我们可以通过以下极限得到它的值：</p><p>     def  approximate_e (  initial_guess :  float ,  max_iter :  int  =  10 ,  epsilon :  float  =  0.01 )  -&gt;  float :  e_value  =  initial_guess  for  n  in  range ( 1 ,  max_iter  +  1 ):  new_e_value  =  ( 1.0  +  1.0  /  n )  **  n  if  abs ( new_e_value  -  e_value )  &lt;  epsilon :  return  new_e_value  e_value  =  new_e_value  return  new_e_value</p><p>定义近似值（初始值：浮点，最大值：int=10，ε：浮点=0.01）->；浮动：e_值=范围内n的初始值（1，最大值+1）：新的e_值=（1.0+1.0/n）**n如果abs（新的e_值-e_值）&lt；epsilon:return new_e_value e_value=new_e_value return new_e_value</p><p>  First of all, the function does three things instead of just one.Line  8. is the absolute essence of the calculation.Yet, with the early stopping and convergence conditions, we are left with a lot of codeoverhead, which is tightly coupled with the actual calculations.Although the two conditions look like something more generic, if we choose to replacethe subject of the approximation (to a square root for example), we will have tocopy-paste this additional code and make sure it doesn’t break the new algorithm.</p><p>首先，函数做三件事而不是一件事。第8行。是计算的绝对本质。然而，由于早期的停止和收敛条件，我们留下了大量的代码开销，这与实际计算紧密耦合。虽然这两个条件看起来更一般，但如果我们选择替换近似的主题（例如平方根），我们将不得不复制粘贴这段附加代码，并确保它不会破坏新算法。</p><p> Secondly, our only options regarding parametrizing the two conditions are to eitherhard-code the values for  max_iter and  epsilon or allow users to provide them asarguments.It spoils the interface and makes testing more difficult.</p><p>第二，关于参数化这两个条件，我们唯一的选择是对max_iter和epsilon的值进行硬编码，或者允许用户提供它们作为参数。它破坏了界面，使测试更加困难。</p><p> Finally, the algorithm generates the data “eagerly”.Instead of focusing on the math and providing values “when asked”, it throws the dataat you.For large amounts of data, this can cause memory issues.</p><p>最后，该算法“急切地”生成数据。它没有把重点放在数学上，并在“被要求时”提供值，而是把数据扔给你。对于大量数据，这可能会导致内存问题。</p><p>  Now, let’s address all three problems at once by separating the responsibility between thedifferent parts.We have three things:</p><p>现在，让我们通过分离不同部分之间的责任来同时解决这三个问题。我们有三件事：</p><p>  from  typing  import  Iterator import  itertools def  approximate_e ()  -&gt;  Iterator [ float ]:  n  =  1  while  True :  yield  ( 1.0  +  1.0  /  n )  **  n  n  +=  1 def  early_stop (  values :  Iterator [ float ],  max_iter :  int  =  100 )  -&gt;  Iterator [ float ]:  return  itertools . islice ( values ,  max_iter ) def  convergence (  values :  Iterator [ float ],  epsilon :  float  =  0.01 )  -&gt;  Iterator [ float ]:  for  a ,  b  in  itertools . pairwise ( values ):  yield  a  if  ( a  -  b )  &lt;  epsilon :  break</p><p>输入import Iterator import itertools def approximate_e（）-&gt；迭代器[float]：n=1，而True:yield（1.0+1.0/n）**n+=1 def early_stop（值：迭代器[float]，最大值：int=100）->；迭代器[float]：返回itertools。islice（值，最大值）定义收敛（值：迭代器[float]，ε：float=0.01）&gt；迭代器[float]：对于itertools中的a，b。成对（值）：如果（a-b）&lt；伊普西隆：休息</p><p> This design uses iterators, which implement “lazy” loading.The data items are only returned one by one when requested (hence the keyword  yield).Thanks to that, we (almost) don’t have to worry about the memory.</p><p>这个设计使用迭代器，它实现“惰性”加载。数据项仅在请求时逐个返回（因此使用关键字yield）。多亏了这一点，我们（几乎）不必担心记忆力。</p><p> Furthermore, each of the three functions can exist separately.They have their specific interface and can be unit-tested in isolation.</p><p>此外，这三个功能中的每一个都可以单独存在。它们有特定的接口，可以单独进行单元测试。</p><p>  values  =  approximate_e () values  =  early_stop ( values ,  max_iter = 50 ) values  =  convergence ( values ,  epsilon = 0.001 ) for  value  in  values :  print ( &#34;e becomes:&#34; ,  value )</p><p>值=近似值（e（）值=提前停止（值，最大值=50）值=收敛（值，ε=0.001）值中值：打印（&#34；e变成：&#34；，值）</p><p>   def  pairwise ( values :  Iterator [ D ])  -&gt;  Iterator [ Tuple [ D ,  D ]]:  a  =  next ( values ,  None )  if  a  is  None :  return  for  b  in  values :  yield  a ,  b  a  =  b</p><p>def pairwise（值：迭代器[D]）-&gt；迭代器[Tuple[D，D]]：a=next（values，None）如果a为None：返回值中的b:yield a，ba=b</p><p>  Scientific programming comes with additional challenges.It is an exciting discipline, but the number of pitfalls seems to grow at least quadraticallywith problem complexity.</p><p>科学编程带来了额外的挑战。这是一门令人兴奋的学科，但陷阱的数量似乎随着问题的复杂性至少呈二次增长。</p><p> In this article, we have discussed two main components that seem to occur again and again in every scientific programming task: data and calculations.Hopefully, by abstracting them in the right way, you can not only increase theefficiency of your code and reduce bugs but also make coding a much better experience.For you and your team!</p><p>在本文中，我们讨论了在每项科学编程任务中似乎反复出现的两个主要组成部分：数据和计算。希望通过以正确的方式对它们进行抽象，您不仅可以提高代码的效率，减少错误，还可以让编码成为更好的体验。为了你和你的团队！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1072461.html"><img src="http://img2.diglog.com/img/2022/1/thumb_fb508e6cf18e791c484b3c2c3c695664.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072461.html">代码审查方式</a></div><span class="my_story_list_date">2022-1-9 21:58</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072457.html"><img src="http://img2.diglog.com/img/2022/1/thumb_44cc3c562cfb3896f12902316e131f35.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072457.html">绕过门密码</a></div><span class="my_story_list_date">2022-1-9 21:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072403.html"><img src="http://img2.diglog.com/img/2021/8/thumb_85e5202f76bb0f0b03afa2d1ee761760.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072403.html">明天新 OpenAI 代码编写技术的现场演示</a></div><span class="my_story_list_date">2021-8-10 4:33</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072393.html"><img src="http://img2.diglog.com/img/2021/8/thumb_6b556d6fd050f0203839396803172378.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072393.html">联合国 IPCC 关于气候变化的报告听起来像是地球的“红色代码”</a></div><span class="my_story_list_date">2021-8-10 3:47</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>