<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>合成孔径雷达成像Synthetic-Aperture Radar Imaging</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Synthetic-Aperture Radar Imaging<br/>合成孔径雷达成像</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-24 05:22:40</div><div class="page_narrow text-break page_content"><p>Few years ago I did some  simple synthetic-aperture radar (SAR) imagingexperiments with the second version of my homemadeFMCW radar. Since then I made a much improved  third version of theradar but didn&#39;t do any SAR measurements due to theamount of effort it would have required. I did have plans to do some SARexperiments afterwards but it took until now to have enough time andmotivation.</p><p>几年前，我使用自制的FMCW雷达的第二版进行了一些简单的合成孔径雷达（SAR）成像实验。从那时起，我制作了雷达的第三个改进版本，但由于需要大量的工作，因此未进行任何SAR测量。之后我确实有计划进行一些SAR实验，但是直到现在为止，它才有足够的时间和动力。</p><p> Synthetic aperture radar (SAR) imaging is a way to synthesize very large antennaarray by moving single antenna on a known path. If there are no moving targetsin the scene then one radar taking many measurements along a path gives the sameresult as one ridiculously large radar that is as long as the movement path.</p><p> 合成孔径雷达（SAR）成像是一种通过在已知路径上移动单个天线来合成非常大的天线阵列的方法。如果场景中没有移动目标，则一架雷达沿一条路径进行多次测量的结果与一头与移动路径一样长的可笑的大型雷达的结果相同。</p><p> SAR imaging of a single target. As the radar moves the measured distance follows a parabola.</p><p> 单个目标的SAR成像。随着雷达的移动，测得的距离跟随抛物线。</p><p> If we move on a straight path while radar pointing 90 degrees from the directionof the path measures a distance to the single target, we will find that themeasured distance follows a parabola. This follows directly from the Pythagoreantheorem. The SAR imaging problem is finding out the target position from themeasured distance data. Of course in a real scene we have multiple targets andthe solution isn&#39;t as simple as looking where the closest approach is as couldbe done in the picture above.</p><p> 如果我们在一条直线路径上移动，而雷达指向的方向与该路径的方向成90度，则该距离将测量到单个目标，因此，我们发现测得的距离遵循抛物线。这直接来自勾股定理。 SAR成像问题是从测得的距离数据中找出目标位置。当然，在真实场景中，我们有多个目标，解决方案并不像上图中那样寻找最接近的方法在哪里。</p><p>  There are few different algorithms for solving this problem, but the one I&#39;mgoing to use is called Omega-k algorithm. It is a fast imaging algorithmutilizing FFT which also makes it efficient to calculate on GPU. The derivationmostly follows  a paper by Guo andDong.</p><p>  解决此问题的算法很少，但我要使用的算法称为Omega-k算法。这是一种利用FFT的快速成像算法，它也使得在GPU上高效计算成为可能。该推导主要遵循郭和董的论文。</p><p> The radar I have is a frequency modulated constant wave (FMCW) radar. Ittransmits a short frequency sweep. The transmitted waveform can be modeled as:</p><p> 我拥有的雷达是调频恒定波（FMCW）雷达。它传输短的频率扫描。传输波形可以建模为：</p><p> $$ s_t(\tau) = \exp(j 2 \pi f_c \tau + \pi \gamma \tau^2),\quad -T_s/2 &lt; \tau &lt; T_s/2 $$</p><p> $$ s_t（\ tau）= \ exp（j 2 \ pi f_c \ tau + \ pi \ gamma \ tau ^ 2），\ quad -T_s / 2 <\ tau <T_s / 2 $$</p><p> , where  \(j = \sqrt{-1}\),  \(f_c =\) RF carrier frequency,  \(\tau =\) time variable, \(\gamma = B/T_s =\) sweep bandwidth / sweep length  \(=\) sweep rate.</p><p>，其中\（j = \ sqrt {-1} \），\（f_c = \）RF载波频率，\（\ tau = \）时间变量，\（\ gamma = B / T_s = \）扫描带宽/扫描长度\（= \）扫描速率。</p><p> The transmitted wave reflects off a target at some distance and is received aftertime  \(t_d\). Ignoring the amplitude, the received wave is a time-delayed copyof the transmitted signal:  \(s_r(\tau) = s_t(\tau - t_d)\). Signals from multipletargets are summed.</p><p> 所发射的波在一定距离处反射离开目标，并在时间\（t_d \）之后被接收。忽略振幅，接收到的波是发射信号的延时复制：\（s_r（\ tau）= s_t（\ tau-t_d）\）。来自多个目标的信号相加。</p><p> The receiver mixes the received signal with the transmitted signal. This mixingis called dechirping and it removes the high frequency RF component. The resultis a low frequency signal, usually some few kHz to MHz and is easy to digitizewith low-cost ADC. With the complex signals we take complex conjugate of thetransmitted signal to get the low-pass product and the resulting mixing product is:</p><p> 接收器将接收的信号与发送的信号混合。这种混合称为去杂散，可以去除高频RF分量。结果是一个低频信号，通常在几千赫兹到兆赫兹之间，并且易于通过低成本ADC进行数字化。对于复数信号，我们对传输的信号进行复数共轭以获得低通积，得到的混合积为：</p><p> $$ s_{\text{IF}}(\tau) = s_t(\tau - t_d) s_t^*(\tau) = \exp(-j 2 \pi f_c t_d- j 2 \pi \gamma t_d \tau + j \pi \gamma \tau^2) $$</p><p> $$ s _ {\ text {IF}}（\ tau）= s_t（\ tau-t_d）s_t ^ *（\ tau）= \ exp（-j 2 \ pi f_c t_d- j 2 \ pi \ gamma t_d \ tau + j \ pi \ gamma \ tau ^ 2）$$</p><p> During SAR measurement the radar repeats this measurement while moving ona straight path with a constant speed. The position of the radar on the path is: \(x = v \tau + x_n\), where  \(v\) is speed of the radar platform and  \(x_n= v n T_p\).  \(n\) is the index for measurements and  \(T_p\) is the transmitrepetition interval.</p><p> 在SAR测量期间，雷达以恒定速度沿直线路径重复进行此测量。雷达在路径上的位置为：\（x = v \ tau + x_n \），其中\（v \）是雷达平台的速度，\（x_n = v n T_p \）。 \（n \）是测量的索引，\（T_p \）是发射重复间隔。</p><p> If the radar target is at position  \((x_0, y_0)\) the distance to the target canbe written as:</p><p> 如果雷达目标在位置\（（（x_0，y_0）\））到目标的距离可以写成：</p><p>  We set the y-coordinate of the path to be 0 and x position is limited to  \(-L/2&lt; x &lt; L/2\), where  \(L\) is length of the path.</p><p>  我们将路径的y坐标设置为0，x位置限制为\（-L / 2 <x <L / 2 \），其中\（L \）是路径的长度。</p><p> Since electromagnetic waves travel at the speed of light and radar signal needsto travel to the target and back to the radar, we get expressionfor received signal time delay  \(t_d = 2R(x)/c\), where  \(c\) is the speed of light.</p><p>由于电磁波以光速传播并且雷达信号需要传播到目标并返回到雷达，因此我们获得了接收信号时间延迟\（t_d = 2R（x）/ c \）的表达式，其中\（c \）为光的速度。</p><p>  $$ s_{\text{IF}}(\tau, x) = \exp\left(-j \frac{4 \pi}{c} (f_c + \gamma \tau) R(x)\right)\exp\left(j \frac{4 \pi \gamma^2}{c^2} R^2(x)\right) $$</p><p>  $$ s _ {\ text {IF}}（\ tau，x} = \ exp \ left（-j \ frac {4 \ pi} {c}（f_c + \ gamma \ tau）R（x）\ right）\ exp \ left（j \ frac {4 \ pi \ gamma ^ 2} {c ^ 2} R ^ 2（x）\ right）$$</p><p> The last term in the above expression is called residual video phase term andit&#39;s an undesirable by-product from dechirping operation. It should be removedbefore further processing by multiplying by  \(\exp(-j \frac{4 \pi \gamma^2}{c^2}R^2(x))\). However this form is inconvenient because it depends on  \(R(x)\). Usingthe fact that  \(R(x) = c t_d / 2\) and that  \(t_d\) can be expressed in terms offrequency of the IF signal:  \(f = -2 \gamma R(x) / c = -\gamma t_d \Rightarrowt_d = -\frac{f}{\gamma}\) we can write the correction term as  \(\exp(-j \pi f^2/ \gamma)\). This form can be applied easily to the Fourier transformed signal.</p><p> 上式中的最后一项称为剩余视频相位项，它是去皮操作的不良副产品。应该先乘以\（\ exp（-j \ frac {4 \ pi \ gamma ^ 2} {c ^ 2} R ^ 2（x））\），然后将其删除。但是，这种形式不方便，因为它取决于\（R（x）\）。利用\（R（x）= c t_d / 2 \）和\（t_d \）可以用IF信号的频率表示的事实：\（f = -2 \ gamma R（x）/ c =- \ gamma t_d \ Rightarrowt_d =-\ frac {f} {\ gamma} \）我们可以将校正项写为\（\ exp（-j \ pi f ^ 2 / \ gamma）\）。这种形式可以容易地应用于傅立叶变换的信号。</p><p>  $$ s(\tau, x_n) = \exp\left(-j \frac{4 \pi}{c} (f_c + \gamma \tau) \sqrt{y_0^2 + (x_n - x_0 + v \tau)^2}\right) $$</p><p>  $$ s（\ tau，x_n）= \ exp \ left（-j \ frac {4 \ pi} {c}（f_c + \ gamma \ tau）\ sqrt {y_0 ^ 2 +（x_n-x_0 + v \ tau ）^ 2} \ right）$$</p><p> Ideally we would like to have the signal in form  \(\exp(-j 2 \pi f_y y_0)\exp(-j2\pi f_x x_0)\), then we could apply two dimensional inverse Fourier transform toget a delta function centered at  \((x_0, y_0)\) focusing the image. Currently thesignal  \(s(\tau, x_n)\) is not in this form and inverse Fourier transform doesn&#39;tgive anything interesting. We need to find some processing steps to apply to thesignal to get it to the required form so that inverse Fourier transform can beapplied. The reason to look specifically for this kind of form is that FFT canbe performed very efficiently.</p><p> 理想情况下，我们希望信号的形式为\（\ exp（-j 2 \ pi f_y y_0）\ exp（-j2 \ pi f_x x_0）\），然后我们可以应用二维傅立叶逆变换以获得以中心为中心的增量函数在\（（x_0，y_0）\）处聚焦图像。目前，信号\（s（\ tau，x_n）\）不在这种形式下，傅立叶逆变换没有任何有趣的意义。我们需要找到一些处理步骤以应用于信号以使其达到所需的形式，以便可以应用傅立叶逆变换。之所以专门考虑这种形式，是因为FFT可以非常有效地执行。</p><p> As a first step, note that  \(\gamma\) has units of Hz/s and  \(\tau\) has units of s.The product  \(\gamma \tau\) has units of Hz so it&#39;s a frequency. This product is actuallyinstantenous modulation frequency of the sweep. We do substitution  \(\gamma\tau \rightarrow f_\tau\) to get rid of the time variable.  \(\tau\) range was  \(-T/2\ldots T/2\) and the new range for  \(f_\tau\) is  \(-B/2 \ldots B/2\).</p><p> 首先，请注意\（\ gamma \）的单位为Hz / s，\（\ tau \）的单位为s。乘积\（\ gamma \ tau \）的单位为Hz，因此它是一个频率。该乘积实际上是瞬时扫描的调制频率。我们做替换\（\ gamma \ tau \ rightarrow f_ \ tau \）来摆脱时间变量。 \（\ tau \）范围是\（-T / 2 \ ldots T / 2 \），新的\（f_ \ tau \）范围是\（-B / 2 \ ldots B / 2 \）。</p><p> $$ S(f_\tau, x_n) = \exp\left(-j \frac{4 \pi}{c} (f_c + f_\tau) \sqrt{y_0^2 + (x_n - x_0 + \frac{v f_\tau}{\gamma} )^2}\right) $$</p><p> $$ S（f_ \ tau，x_n）= \ exp \ left（-j \ frac {4 \ pi} {c}（f_c + f_ \ tau）\ sqrt {y_0 ^ 2 +（x_n-x_0 + \ frac { v f_ \ tau} {\ gamma}）^ 2} \ right）$$</p><p> Also instead of using frequency the math is cleaner and the implementation ofthe algorithm is easier when using wavenumbers instead. We define rangewavenumber  \(K_r = K_{rc} + \Delta K_r\).  \(K_{rc} = \frac{4\pi f_c}{c}\),  \(\DeltaK_r = \frac{4\pi f_\tau}{c} = -\frac{2\pi B}{c} \ldots \frac{2\pi B}{c}\).</p><p>同样，代替使用频率，数学更简洁，而当使用波数时，算法的实现更容易。我们定义范围波数\（K_r = K_ {rc} + \ Delta K_r \）。 \（K_ {rc} = \ frac {4 \ pi f_c} {c} \），\（\ DeltaK_r = \ frac {4 \ pi f_ \ tau} {c} =-\ frac {2 \ pi B} { c} \ ldots \ frac {2 \ pi B} {c} \）。</p><p> $$ S(K_r, x_n) = \exp\left(-j K_r \sqrt{y_0^2 + (x_n - x_0 + \frac{v c \Delta K_r}{4 \pi \gamma} )^2}\right) $$</p><p> $$ S（K_r，x_n）= \ exp \ left（-j K_r \ sqrt {y_0 ^ 2 +（x_n-x_0 + \ frac {vc \ Delta K_r} {4 \ pi \ gamma}）^ 2} \ right ）$$</p><p> Next step is to do Fourier transform in azimuth direction (direction of themovement) to move also the  \(x_n\) variable to frequency domain.</p><p> 下一步是在方位角方向（运动方向）上进行傅立叶变换，以将\（x_n \）变量也移至频域。</p><p> $$ S(K_r, K_x) = \int_{-\infty}^\infty S(K_r, x_n) \exp(-j K_x x_n)\, dx_n = \int_{-\infty}^\infty \exp(j\Phi(x_n))\, dx_n $$</p><p> $$ S（K_r，K_x）= \ int _ {-\ infty} ^ \ infty S（K_r，x_n）\ exp（-j K_x x_n）\，dx_n = \ int _ {-\ infty} ^ \ infty \ exp（ j \ Phi（x_n））\，dx_n $$</p><p> \(K_x = 2\pi f_x\) is wavenumber in the azimuth direction. This integral doesn&#39;t haveexact solution, but there is a method to calculate quite accurate approximationusing a method called principle of stationary phase (PSOP). Phase of thefunction being integrated can be written as:</p><p> \（K_x = 2 \ pi f_x \）是方位角方向的波数。这个积分没有精确的解决方案，但是有一种方法可以使用称为固定相位原理（PSOP）的方法来计算非常精确的近似值。集成功能的阶段可以写成：</p><p> $$ \Phi(x_n) = -K_r \sqrt{y_0^2 + \left(x_n - x_0 + \frac{v c \Delta K_r}{4 \pi \gamma} \right)^2} - K_x x_n $$</p><p> $$ \ Phi（x_n）= -K_r \ sqrt {y_0 ^ 2 + \ left（x_n-x_0 + \ frac {v c \ Delta K_r} {4 \ pi \ gamma} \ right）^ 2}-K_x x_n $$</p><p> If we plot the phase  \(\Phi(x_n)\) for some realistic values we get a plot thatlooks something like below:</p><p> 如果我们为某些实际值绘制相位\（\ Phi（x_n）\），我们将得到一个如下图所示的图：</p><p>  There is one point where derivative of the phase is zero (stationary point) andthe function varies slowly, but away from that point the function is highlyoscillatory. As we integrate the function the oscillations far away from thestationary point cancel out and mainly the area around the stationary pointcontributes to the result of the integral.</p><p>在一个点上，相位的导数为零（平稳点），并且函数变化缓慢，但远离该点，函数具有很高的振荡性。当我们对函数进行积分时，远离固定点的振荡会被抵消，并且主要是固定点周围的区域会贡献积分结果。</p><p> We can expand the function around the stationary point  \(\frac{d}{dx_n}\Phi(x_n) \rvert_{x_n=x_n^\star} = 0\), as \(\Phi(x_n) = \Phi(x_n^\star) + 0 + \frac{1}{2}\Phi^{&#39;&#39;}(x_n - x_n^\star)^2\).</p><p> 我们可以围绕固定点\（\ frac {d} {dx_n} \ Phi（x_n）\ rvert_ {x_n = x_n ^ \ star} = 0 \）展开函数，如\（\ Phi（x_n）= \ Phi （x_n ^ \ star）+ 0 + \ frac {1} {2} \ Phi ^ {''}（x_n-x_n ^ \ star）^ 2 \）。</p><p>  $$ \begin{aligned}S(K_r, K_x) &amp;\approx \exp(j\Phi(x_n^\star)) \int_{-\infty}^\infty \exp\left(j\frac{1}{2}\Phi^{&#39;&#39;}(x_n^\star)(x_n-x_n^\star)^2\right)\, d x_n \\&amp;= \exp(j\Phi(x_n^\star)) \int_{-\infty}^\infty \exp\left(j\frac{1}{2}\Phi^{&#39;&#39;}(x_n^\star)s^2\right)\, d s \\&amp;= \exp(j\Phi(x_n^\star)) \sqrt{\frac{2\pi j}{\Phi^{&#39;&#39;}(x_n^\star)}} \end{aligned}$$</p><p>  $$ \ begin {aligned} S（K_r，K_x）＆\ approx \ exp（j \ Phi（x_n ^ \ star））\ int _ {-\ infty} ^ \ infty \ exp \ left（j \ frac {1} {2} \ Phi ^ {''}（x_n ^ \ star）（x_n-x_n ^ \ star）^ 2 \ right）\，d x_n \\＆= \ exp（j \ Phi（x_n ^ \ star）） \ int _ {-\ infty} ^ \ infty \ exp \ left（j \ frac {1} {2} \ Phi ^ {''}（x_n ^ \ star）s ^ 2 \ right）\，ds \\＆= \ exp（j \ Phi（x_n ^ \ star））\ sqrt {\ frac {2 \ pi j} {\ Phi ^ {''}（x_n ^ \ star）}} \ end {aligned} $$</p><p> Since  \(\Phi(x_n)\) is purely real function, if  \(\mu\) is sign of the \(\Phi(x_n^\star)\), then the square root term can be written as \(\sqrt{\frac{2\pi}{|\Phi^{&#39;&#39;}(x_n^\star)|}} exp(j\pi \mu/4)\). The secondderivative contributes amplitude term and constant phase term, neither of themwhich is important for focusing image which mainly depends on aligning thephases. We have ignored the amplitude since beginning and it ends up being slowlyvarying function so we will just approximate it away.</p><p> 因为\（\ Phi（x_n）\）是纯实函数，所以如果\（\ mu \）是\（\ Phi（x_n ^ \ star）\）的符号，则平方根项可以写为\（ \ sqrt {\ frac {2 \ pi} {| \ Phi ^ {''}（x_n ^ \ star）|}} exp（j \ pi \ mu / 4）\）。二阶导数贡献振幅项和恒定相位项，它们都不对聚焦图像重要，而聚焦图像主要取决于对准相位。自开始以来，我们就忽略了振幅，而振幅最终是缓慢变化的函数，因此我们将其近似化。</p><p>   Plugging in the stationary point to the  \(S(K_r, K_x)\) equation above we get thesolution of the integral:</p><p>   将固定点插入上面的\（S（K_r，K_x）\）方程，我们得到积分的解：</p><p> $$ S(K_r, K_x) \approx \exp\left(j(-y_0 \sqrt{K_r^2 - K_x^2} - K_x x_0 + \frac{c \Delta K_r K_xv}{4\pi\gamma})\right) $$</p><p> $$ S（K_r，K_x）\约\ exp \ left（j（-y_0 \ sqrt {K_r ^ 2-K_x ^ 2}-K_x x_0 + \ frac {c \ Delta K_r K_xv} {4 \ pi \ gamma} ）\ right）$$</p><p> The last term is phase offset caused by the movement of the radar during thesweep. It can be removed by multiplying with exponential in the opposite phase.</p><p> 最后一项是由于扫描过程中雷达的运动引起的相位偏移。可以通过在相反的相位乘以指数将其删除。</p><p> \(x_0\) term is already in the correct form as it is multiplied only by  \(K_x\), but \(y_0\) term depends on both  \(K_r\) and  \(K_x\).  \(K_r, K_x\) dependence can be fixedby making a substitution  \(\sqrt{K_r^2 - K_x^2} \rightarrow K_y\). This step iscalled Stolt interpolation as it is implemented by interpolating the data toa new grid.</p><p>\（x_0 \）项已经采用了正确的格式，因为它仅与\（K_x \）相乘，但是\（y_0 \）项同时取决于\（K_r \）和\（K_x \）。可以通过替换\（\ sqrt {K_r ^ 2-K_x ^ 2} \ rightarrow K_y \）来固定\（K_r，K_x \）依赖性。此步骤称为Stolt插值，因为它是通过将数据插值到新网格来实现的。</p><p>   Taking 2D inverse Fourier transform gives the focused image with delta functioncentered at  \((x_0, y_0)\).</p><p>   进行2D逆傅立叶变换可得出聚焦图像，其delta函数的中心为\（（x_0，y_0）\）。</p><p>  The Omega-k algorithm is mainly large FFTs and interpolation. Both can beimplemented well on GPU which requires large parallelism from the program. Wellwritten GPU implementation should be several times faster than CPUimplementation. For convenience I&#39;ll implement the algorithm using Tensorflowlibrary. Although it&#39;s most often used for training neural nets it can just aswell be used for other purposes.</p><p>  Omega-k算法主要是大型FFT和插值。两者都可以在GPU上很好地实现，而GPU需要程序具有很大的并行性。精心编写的GPU实现应比CPU实现快几倍。为了方便起见，我将使用Tensorflowlibrary实现该算法。尽管它最常用于训练神经网络，但也可以用于其他目的。</p><p> The derivation above was done using continous signals but in practice the radarsamples the signal with ADC resulting in discrete samples. Most of the abovederivation is still valid, some additional thought is needed for example in making sure that sampling grid is small enough to avoid aliasing.</p><p> 以上推导是使用连续信号完成的，但实际上，雷达使用ADC对信号进行采样，从而得到离散采样。上面的大多数推导仍然有效，例如，在确保采样网格足够小以避免混叠时，还需要一些其他考虑。</p><p>  import  numpy  as  np import  tensorflow  as  tf # Load captured data and parameters from the disk. data ,  settings  =  load_data ( ... ) # &#39;data&#39; contains the captured data in 2D array.  # First dimensions is index of the sweep on the path  # and second is raw values of the sweep from ADC. # Platform movement speed during the measurement. v  =  settings [ &#39;v&#39; ] # Samplerate of the digitized signal. fs  =  settings [ &#39;fs&#39; ] # Sweep length. tsweep  =  settings [ &#39;tsweep&#39; ] # Bandiwdth of the sweep. bw  =  settings [ &#39;bw&#39; ] # RF center frequency of the sweep. fc  =  settings [ &#39;f0&#39; ]  +  bw / 2 # Time between the sweeps. tdelay  =  settings [ &#39;tdelay&#39; ] # Sweep rate. gamma  =  bw  /  tsweep # Number of captured sweeps. sweep_samples  =  len ( data [ 0 ]) # Position difference between the captured sweeps. delta_x  =  ( tsweep  +  tdelay )  *  v # Wavenumber axes kx  =  np . linspace ( - np . pi / delta_x ,  np . pi / delta_x ,  len ( data )) dkr  =  np . linspace (( 4 * np . pi / c ) * ( - bw / 2 ),  ( 4 * np . pi / c ) * ( bw / 2 ),  sweep_samples ) kr  =  ( 4 * np . pi / c ) * fc  +  dkr ky0  =  ( kr [ 0 ] ** 2  -  kx [ 0 ] ** 2 ) ** 0.5 ky_delta  =  kr [ 1 ]  -  kr [ 0 ]  # Same spacing as kr to avoid aliasing during interpolation. # Ky axis after interpolation. ky_interp  =  np . arange ( ky0 ,  kr [ - 1 ],  ky_delta )</p><p>  import numpy as np import tensorflow as tf＃从磁盘加载捕获的数据和参数。 data，settings = load_data（...）＃'data'包含2D数组中捕获的数据。 ＃第一维是路径上扫描的索引，第二维是来自ADC的扫描的原始值。 ＃测量期间平台的移动速度。 v =设置['v']＃数字化信号的采样率。 fs =设置['fs']＃扫描长度。 tsweep =设置['tsweep']＃扫描的带宽。 bw =设置['bw']＃扫描的RF中心频率。 fc =设置['f0'] + bw / 2＃两次扫描之间的时间。 tdelay = settings ['tdelay']＃扫描速率。 gamma = bw / tsweep＃捕获的扫描数。 sweep_samples = len（data [0]）＃捕获的扫描之间的位置差。 delta_x =（tsweep + tdelay）* v＃波数轴kx = np。 linspace（-np.pi / delta_x，np.pi / delta_x，len（数据））dkr = np。 linspace（（4 * np .pi / c）*（-bw / 2），（4 * np .pi / c）*（bw / 2），sweep_samples）kr =（4 * np .pi / c）* fc + dkr ky0 =（kr [0] ** 2-kx [0] ** 2）** 0.5 ky_delta = kr [1]-kr [0]＃与kr的间距相同，以避免插值时出现混叠。 ＃插补后的Ky轴。 ky_interp = np。范围（ky0，kr [-1]，ky_delta）</p><p> Straight away one difference between the real data and the derivation is that myradar doesn&#39;t have IQ sampling and the captured signal is purely real. We canhowever easily generate the required imaginary part. If we take FFT of thecaptured signal, since the signal is purely real positive and negative frequencycomponents are complex conjugates. However the complex signal should only havenegative frequency components (Negative because the delayed RF signal in thereceiver mixer is lower frequency than the LO signal). If we zero the positivecomponents and then take inverse FFT, the result is a complex signal with theright properties. This transformation is called  Hilberttransform. We can also applywindowing function in range direction and do the RVP term multiplication at thesame time. We do this step as a pre-processing step using numpy:</p><p> 实际数据与推导之间的直接区别是，myradar没有IQ采样，并且捕获的信号是纯真的。但是，我们可以轻松生成所需的虚部。如果我们对捕获的信号进行FFT，则由于该信号是纯实数的正和负频率分量是复共轭。但是，复信号应仅具有负频率分量（负，因为接收混频器中的延迟RF信号的频率低于LO信号的频率）。如果我们将正分量归零，然后进行逆FFT，则结果是具有正确属性的复杂信号。这种转换称为希尔伯特转换。我们还可以在范围方向上应用窗口功能，并同时进行RVP项乘法。我们将此步骤作为使用numpy的预处理步骤：</p><p> def  hilbert_rvp ( x ,  fs ,  gamma ):  # Last dimension is the range dimension  y  =  np . fft . fft ( x ,  axis =- 1 )  y [:,: y . shape [ 1 ] // 2 + 1 ]  =  0  # Zero the positive frequencies  # Residual video phase term compensation  f  =  np . linspace ( - fs / 2 ,  fs / 2 ,  y . shape [ 1 ])  y  *=  np . exp ( 1j  *  np . pi  *  f ** 2  /  gamma )  return  np . fft . ifft ( y ,  axis =- 1 ) # Windowing function in range direction. # Decreases sidelobes from FFT. w  =  np . hanning ( data . shape [ 1 ]) # fs = Samplerate of the ADC. # gamma = Sweep bandiwdth / length of the sweep. data  =  hilbert_rvp ( w  *  data ,  fs ,  gamma )</p><p> def hilbert_rvp（x，fs，gamma）：＃最后一个维度是范围维度y = np。英尺fft（x，轴=-1）y [：，：y。 shape [1] // 2 + 1] = 0＃正频率为零＃剩余视频相位项补偿f = np。 linspace（-fs / 2，fs / 2，y。shape [1]）y * = np。 exp（1j * np。pi * f ** 2 / gamma）返回np。英尺ifft（y，axis =-1）＃范围方向的开窗功能。 ＃减少FFT的旁瓣。 w = np。 hanning（data。shape [1]）＃fs = ADC的采样率。 ＃gamma =扫描带宽/扫描长度。数据= hilbert_rvp（w *数据，fs，伽玛）</p><p> The next step would be azimuth FFT but before that we will first zero pad the datain azimuth direction because target azimuth positions can be outside theendpoints of the movement path. Without zero padding those targets would aliasto locations inside the path.</p><p>下一步将是方位角FFT，但是在此之前，我们将首先在方位角方向对数据进行零填充，因为目标方位角位置可能在移动路径的端点之外。没有零填充，这些目标将别名到路径内的位置。</p><p> # Add &#39;zpad&#39; zeros symmetrically to both sides of the azimuth axis. data  =  np . pad ( data ,  (( zpad // 2 ,  zpad // 2 ),  ( 0 ,  0 )),  &#39;constant&#39; )</p><p> ＃在方位轴的两侧对称添加“ zpad”零。数据= np。 pad（data，（（（zpad // 2，zpad // 2），（0，0）），'常量'）</p><p> Now the pre-processing is done and the rest is done on GPU. The first step isazimuth FFT which needs to be done in a slightly roundabout way due tolimitations of the function.</p><p> 现在预处理已经完成，其余的都在GPU上完成了。第一步是方位角FFT，由于功能的限制，需要以稍微绕行的方式进行。</p><p> # Create a tensor from pre-processed data. img  =  tf . constant ( data ,  dtype = tf . complex64 ) # Tensorflow FFT doesn&#39;t have option to choose the axis to transform # and it always calculates FFT over the last axis. # Transpose to swap the axes before and after FFT to calculate FFT over # the first axis. img  =  tf . transpose ( img ) img  =  tf . signal . fft ( img ) img  =  tf . transpose ( img ) # Shift frequency components so that zero-frequency is at the center. img1 ,  img2  =  tf . split ( img ,  [ img . shape [ 0 ] . value  -  img . shape [ 0 ] . value // 2 ,  img . shape [ 0 ] . value // 2 ],  axis = 0 ) img  =  tf . concat ([ img2 ,  img1 ],  axis = 0 )</p><p> ＃从预处理数据创建张量。 img = tf。常量（data，dtype = tf。complex64）＃Tensorflow FFT没有选择要转换的轴的选项＃并且它总是在最后一个轴上计算FFT。 ＃换位以交换FFT之前和之后的轴，以计算＃在第一个轴上的FFT。 img = tf。转置（img）img = tf。信号。 fft（img）img = tf。 transpose（img）＃移位频率分量，以使零频率为中心。 img1，img2 = tf。拆分（img，[img。shape [0]。值-img。shape [0]。value // 2，img。shape [0]。value // 2]，轴= 0）img = tf。 concat（[img2，img1]，轴= 0）</p><p>  # Matched filtering to compensate for movement during the sweep. mf  =  tf . exp ( j  *  tf . cast ( tf . expand_dims ( dkr ,  0 )  *  tf . expand_dims ( kx ,  - 1 ),  tf . complex64 )  *  tf . cast ( c  *  v  /  ( 4  *  np . pi  *  gamma ),  tf . complex64 )) img  =  img  *  mf</p><p>  ＃匹配过滤以补偿扫描期间的移动。 mf = tf。 exp（j * tf。cast（tf。expand_dims（dkr，0）* tf。expand_dims（kx，-1），tf。complex64）* tf。cast（c * v /（4 * np。pi * gamma）， tf。complex64））img = img * mf</p><p> After matched filtering we are supposed to do the Stolt interpolation. The datais currently defined on  \(K_x, K_r\) axes and we need to interpolate it to  \(K_x,K_y\) axes. In general the new  \(K_y\) axis points don&#39;t correspond exactly to thepoints on the existing grid and we need to interpolate. The problem is thatthere is no easy way to do the interpolation in Tensorflow. Simple interpolationmethods such as linear interpolation, while easy to implement, are not goodenough as they cause distortions in the frequency domain. The ideal interpolationwould be  sinc interpolation,but the formula needs multiplication for every sample in the signal to calculateone output point resulting in a very slow  \(O(n^2)\) algorithm. A good compromisebetween efficient algorithm and minimal frequency domain distortions is  Lanczosinterpolation. Instead ofinterpolating with  \(\text{sinc}(x)\) that has infinite support, a kernel  \(L(x)\) withfinite support is used so that only nearby samples need to be considered in theinterpolation:</p><p> 经过匹配滤波后，我们应该进行Stolt插值。数据当前是在\（K_x，K_r \）轴上定义的，我们需要将其插值到\（K_x，K_y \）轴。通常，新的\（K_y \）轴点并不完全对应于现有网格上的点，因此我们需要进行插值。问题在于在Tensorflow中没有简单的方法进行插值。线性插值之类的简单插值方法虽然易于实现，但由于它们会引起频域失真，因此效果不佳。理想的插值将是Sinc插值，但是该公式需要对信号中的每个样本相乘以计算一个输出点，从而导致非常慢的\（O（n ^ 2）\）算法。 Lanczosinterpolation是高效算法和最小频域失真之间的一个很好的折衷方案。而不是使用具有无限支持的\（\ text {sinc}（x）\）进行插值，而是使用具有无限支持的内核\（L（x）\），以便在插值中仅需考虑附近的样本：</p><p> $$ L(x) = \begin{cases} \text{sinc}(x)\, \text{sinc}(x/a) &amp; \text{if}\ -a &lt; x &lt; a, \\ 0 &amp; \text{otherwise} \end{cases}$$</p><p> $$ L（x）= \ begin {cases} \ text {sinc}（x）\，\ text {sinc}（x / a）＆\ text {if} \ -a <x <a，\\ 0＆ \ text {otherwise} \ end {cases} $$</p><p> As far as I know there isn&#39;t really any easy way to implement it efficiently inTensorflow with the existing operations. Applying the formula for every point in theimage adds so many operations to the computation graph that it never finishes.I ended up writing a custom operation in C++ for it with both CPU and GPUimplementations. The code for it is too long to include here but you can find itin the  Gitrepository. Aftercompiling the operation and writing some Python code to interface with it theStolt interpolation can be written in a single line:</p><p>据我所知，实际上没有任何简单的方法可以在Tensorflow中使用现有操作有效地实现它。对图像中的每个点应用公式都会给计算图增加太多的操作，以至于它永远无法完成。我最终用C ++为它编写了具有CPU和GPU实现的自定义操作。它的代码太长，无法在此处包含，但您可以在Gitrepository中找到它。编译完该操作并编写一些Python代码以与其接口之后，Stolt插值可以单行编写：</p><p> from  interp_op  import  stolt_interp # The original grid where the data is defined. ky  =  tf . constant (( kr ** 2  -  ( kx ** 2 )[:, np . newaxis ]) ** 0.5 ,  dtype = tf . float32 ) # Stolt interpolation # &#39;interp_order&#39; is Lanczos kernel order &#39;a&#39;. img  =  stolt_interp ( ky ,  img ,  ky_interp ,  interp_order )</p><p> from interp_op import stolt_interp＃定义数据的原始网格。 ky = tf。常量（（kr ** 2-（kx ** 2）[:, np。newaxis]）** 0.5，dtype = tf。float32）＃Stolt插值＃'interp_order'是Lanczos内核顺序'a'。 img = stolt_interp（ky，img，ky_interp，interp_order）</p><p>     I mounted the radar on the rear rack of bicycle and pedaled the bicycle ina straight line with constant speed to take the measurement. It&#39;s very importantthat the path is known since any difference in the actual position and the oneused during the image formation leads to image quality degradation. The positionshould be known within a fraction of wavelength to avoid any defocusingerrors. My radar works at 6 GHz which works out to few cm precision requirementover about 200 m long path. This is probably not going to happen, but we aregoing to see later how the introduced position errors can be at least partlycorrected.</p><p>     我将雷达安装在自行车的后架上，并以恒定速度将自行车踩在一条直线上以进行测量。知道路径非常重要，因为实际位置和图像形成过程中使用的位置之间的任何差异都会导致图像质量下降。位置应该在波长的一小部分之内，以避免任何散焦误差。我的雷达工作在6 GHz，在大约200 m长的路径上达到几厘米的精度要求。这可能不会发生，但是我们稍后将看到如何至少部分纠正引入的位置误差。</p><p> Photograph of the scene being imaged. Imaging path is on the footpath on right and the radar points to the parking lot on left.</p><p> 正在成像的场景的照片。成像路径位于右侧的人行道上，雷达指向左侧的停车场。</p><p> In the above picture is the scene being imaged. It&#39;s a parking lot with lot ofpole-like targets that should be well visible in the generated image.</p><p> 上图中是正在成像的场景。这是一个停车场，上面有许多类似杆子的目标，应该在生成的图像中清晰可见。</p><p>  Raw captured data doesn&#39;t look like much. Sweep length is 1 ms, with 1 MHzsampling rate, so each sweep has 1000 points and there are total of 6444 sweeps.The output signal of the FMCW radar is a superposition of sine waves from eachvisible target. Frequency depends on the distance to the target, closer it isthe lower the frequency. Amplitude depends on the amount of power reflectedwhich depends on the size, shape, material and distance to the target.</p><p>  原始捕获的数据看起来并不多。扫描长度为1 ms，采样率为1 MHz，因此每个扫描有1000个点，总共有6444个扫描。FMCW雷达的输出信号是来自每个可见目标的正弦波的叠加。频率取决于到目标的距离，距离越近，频率越低。幅度取决于反射的功率大小，取决于大小，形状，材料和到目标的距离。</p><p> Taking FFT in range direction turns it into easier to read format with range on X-axis.</p><p> 在范围方向上进行FFT可以使其更容易读取X轴范围内的格式。</p><p> Above is FFT of the raw data in range direction. Range FFT is not part of theimage processing, but this is how non-imaging measurement would be processed.FFT allows changing X-axis from wavenumbers to distance to the target.</p><p>上面是原始数据在范围方向上的FFT。范围FFT并不是图像处理的一部分，但这是处理非成像测量的方式.FFT允许将X轴从波数更改为到目标的距离。</p><p>  Generated SAR image of the parking lot. The camera photograph above was taken at (90, 0) looking towards (0,0).</p><p>  生成的停车场的SAR图像。上面的相机照片是在（90，0）朝（0,0）方向拍摄的。</p><p> The image is mostly focused, there is some visible spreading but at least mostof the targets can be recognized. There are some curved artifacts that I&#39;m notsure where they come from.</p><p> 图像主要是聚焦的，有一些可见的散布，但至少可以识别大多数目标。我不确定有些弯曲的工件来自何处。</p><p>  When zooming into the foreground objects some smearing from movementdeviations is visible. These can be fixed with autofocusing algorithm.</p><p>  放大前景对象时，可以看到运动偏差带来的一些拖影。这些可以通过自动聚焦算法解决。</p><p> Image formation time on different programs using the above data from the parking lot. Program start-up and data preprocessing time is not included.</p><p> 使用来自停车场的以上数据，在不同程序上的图像形成时间。不包括程序启动和数据预处理时间。</p><p> There is absolutely huge speed up from utilizing GPU. Numpy implementation does the FFTusing Numpy and Stolt interpolation is coded in Python without vectorization.Numpy version takes 22 min and 30 s to form the image of the above data most ofwhich is spent in the interpolation routine. TensorFlow CPU implementationcalculates everything on CPU, Stolt interpolation is a custom op coded in C++. Itis about 16x times faster than the Numpy implementation with most of the speedupcoming from the much faster C++ interpolation function. Image formation takes1 min 20 s.</p><p> 利用GPU绝对有巨大的速度。 Numpy实现使用FFT进行FFT，Numpy和Stolt插值是在没有向量化的情况下在Python中编码的.Numpy版本需要22分钟30 s的时间来形成上述数据的图像，其中大部分数据都用在插值例程中。 TensorFlow CPU实现可计算CPU上的所有内容，Stolt插值是用C ++编写的自定义操作代码。它比Numpy实现快大约16倍，而大多数速度来自更快的C ++插值函数。图像形成需要1分钟20 s。</p><p> TensorFlow GPU Python code is completely identical to the CPU version. Itcalculates FFTs using nVidia&#39;s cufft library on GPU and interpolation is doneusing custom CUDA kernel also on GPU. Image formation takes only 80 ms. Thespeedup is absolutely huge being over 1000x faster than TensorFlow CPU and overten thousand times faster than the Numpy version.</p><p> TensorFlow GPU Python代码与CPU版本完全相同。它在GPU上使用nVidia的cufft库计算FFT，并且在GPU上也使用自定义CUDA内核进行插值。图像形成仅需80毫秒。加速绝对是巨大的，比TensorFlow CPU快1000倍以上，比Numpy版本快一千倍以上。</p><p> Speedup from GPU shouldn&#39;t really be this much. I think part of the reason isthat GPU implementation using nVidia&#39;s libraries is much more optimized thanwhatever CPU implementation TensorFlow uses. CPU FFT doesn&#39;t seem to bemultithreaded, so just multithreaded FFT should speed it up by some smallfactor.</p><p>GPU的加速实际上并不需要那么多。我认为部分原因是使用nVidia库的GPU实现比TensorFlow使用的任何CPU实现都要优化得多。 CPU FFT似乎不是多线程的，因此只有多线程FFT才能以较小的速度加快它的速度。</p><p>  There are some inevitable motion errors when moving the radar on a bicycle. Ifthere is a smal</p><p>  在自行车上移动雷达时，不可避免地会出现一些运动错误。如果有轻微</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hforsten.com/synthetic-aperture-radar-imaging.html">https://hforsten.com/synthetic-aperture-radar-imaging.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/合成孔径雷达/">#合成孔径雷达</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/aperture/">#aperture</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/信号/">#信号</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>