<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们制作了自己的x86外壳代码仿真器及其工作原理</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我们制作了自己的x86外壳代码仿真器及其工作原理</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-11 18:36:25</div><div class="page_narrow text-break page_content"><p>Detecting exploits is one of the major strengths of Hypervisor Memory Introspection (HVMI). The ability to monitor guest physical memory pages against different kinds of accesses, such as write or execute, allows HVMI to impose restrictions on critical memory regions: for example, stack or heap pages can be marked as being non-executable at the EPT level, so when an exploit manages to gain arbitrary code execution, the introspection logic would step in and block the execution of the shellcode.</p><p>检测漏洞是管理程序内存自检(HVMI)的主要优势之一。通过监视访客物理内存页面以防止不同类型的访问(如写入或执行)，HVMI可以对关键内存区域施加限制：例如，堆栈或堆页面可以在EPT级别标记为不可执行，因此当利用漏洞成功获得任意代码执行时，自省逻辑将介入并阻止外壳代码的执行。</p><p> In theory, intercepting execution attempts from memory regions such as the stack or the heap should be enough to prevent most of the exploits. Real life is often more complicated, and there are many cases where legit software uses techniques that may resemble on attack - Just In Time compilation (JIT) in browsers is one good example. In addition, an attacker may store its payload in other memory regions, outside the stack or the heap, so a method of discerning good code from bad code is useful.</p><p>理论上，拦截来自内存区域(如堆栈或堆)的执行尝试应该足以防止大多数利用漏洞。现实生活往往更加复杂，在很多情况下，合法软件使用的技术可能类似于攻击-浏览器中的即时编译(JIT)就是一个很好的例子。此外，攻击者可能会将其有效负载存储在堆栈或堆之外的其他内存区域中，因此区分好代码和坏代码的方法很有用。</p><p> We will talk in this blog post about the Bitdefender Shellcode Emulator, or  bdshemu for short. bdshemu is a library capable of emulating basic x86 instructions, while observing shellcode-like behavior. Legitimate code, such as JIT code, will look different compared to a traditional shellcode, so this is what bdshemu is trying to determine: whether the emulated code behaves like a shellcode or not.</p><p>我们将在这篇博客文章中谈论BitDefender Shellcode Emulator，简称bdshemu。Bdshemu是一个库，它能够模拟基本的x86指令，同时观察类似外壳代码的行为。与传统的外壳代码相比，合法代码(如JIT代码)看起来会有所不同，因此bdshemu正在尝试确定：模拟代码的行为是否与外壳代码类似。</p><p>  bdshemu is a library written in C, and is part of the bddisasm project (and of course, it makes use of bddisasm for instruction decoding). The bdshemu library is built to emulate x86 code only, so it has no support for API calls. In fact, the emulation environment is highly restricted and stripped down, and there are only two memory regions available:</p><p>Bdshemu是一个用C编写的库，是bddisasm项目的一部分(当然，它利用bddisasm进行指令解码)。Bdshemu库仅用于模拟x86代码，因此不支持API调用。事实上，仿真环境受到高度限制和精简，只有两个内存区域可用：</p><p>  Both of these memory regions are virtualized, meaning that they are in fact copies of the actual memory being emulated, so modifications made to them don’t affect the actual system state. Any access made by the emulated code outside of these two areas (which we will call the shellcode and the stack, respectively) will trigger immediate emulation termination. For example, an API call will automatically cause a branch outside the shellcode region, thus terminating emulation. However, in bdshemu, all we care about is instruction-level behavior of the code, which is enough to tell us whether the code is malicious or not.</p><p>这两个内存区域都是虚拟化的，这意味着它们实际上是被仿真的实际内存的副本，因此对它们所做的修改不会影响实际的系统状态。仿真代码在这两个区域(我们将分别称为外壳代码和堆栈)之外进行的任何访问都将触发立即终止仿真。例如，API调用将自动导致外壳代码区域之外的分支，从而终止模拟。然而，在bdshemu中，我们所关心的是代码的指令级行为，这足以告诉我们代码是否是恶意的。</p><p> While bdshemu provides the main infrastructure for detecting shellcodes inside a guest operating-system, it is worth noting that this is not the only way HVMI determines that execution of a certain page is malicious - two other important indicators are used:</p><p>虽然bdshemu为检测来宾操作系统内的外壳代码提供了主要基础设施，但值得注意的是，这并不是HVMI确定某个页面的执行是恶意的唯一方式--还使用了另外两个重要指标：</p><p> The executed page is located on the stack - this is common with stack-based vulnerabilities;</p><p>执行的页面位于堆栈上-这在基于堆栈的漏洞中很常见；</p><p>  The stack is pivoted - when a page is first executed and the  RSP register points outside the normal stack allocated for the thread;</p><p>当第一次执行页面并且RSP寄存器指向分配给线程的正常堆栈之外时，堆栈被旋转；</p><p> These two indicators are enough on their own to trigger an exploit detection. If these are not triggered, bdshemu is used to take a good look at the executed code, and decide if it should be blocked or not.</p><p>这两个指示器本身就足以触发攻击检测。如果这些代码没有被触发，则使用bdshemu来仔细查看执行的代码，并决定是否应该阻止它。</p><p>  bdshemu is created as a standalone C library, and it only depends on bddisasm. Working with bdshemu is fairly simple, as just like bddisasm, it is a single-API library:</p><p>Bdshemu是作为一个独立的C库创建的，它只依赖于bddisasm。使用bdshemu相当简单，就像bddisasm一样，它是一个单一API库：</p><p>  The emulator expects a single  SHEMU_CONTEXT argument, containing all the needed information in order to emulate the suspicious code. This context is split in two sections - input parameters and output parameters. The input parameters must be supplied by the caller, and they contain information such as the code to be emulated, or initial register values. The output parameters contain information such as what shellcode indicators bdshemu detected. All these fields are well documented in the source-code.</p><p>仿真器需要一个SHEMU_CONTEXT参数，该参数包含模拟可疑代码所需的所有信息。此上下文分为两个部分-输入参数和输出参数。输入参数必须由调用方提供，并且它们包含要仿真的代码或初始寄存器值等信息。输出参数包含诸如bdshemu检测到什么外壳代码指示符之类的信息。所有这些领域都在源代码中得到了很好的记录。</p><p> Initially, the context is filled in with the following main information (please note that emulation outcome may change depending on the value of the provided registers and stack):</p><p>最初，使用以下主要信息填充上下文(请注意，仿真结果可能会根据提供的寄存器和堆栈的值而变化)：</p><p> Input registers, such as segments, general purpose registers, MMX and SSE registers; they can be left 0, if they are not known, or if they are irrelevant;</p><p>输入寄存器，如段、通用寄存器、MMX和SSE寄存器；如果它们未知或不相关，可以将它们留为0；</p><p>      Environment info, such as mode (32 or 64 bit), or ring (0, 1, 2 or 3);</p><p>环境信息，如模式(32或64位)或振铃(0、1、2或3)；</p><p>  Control parameters, such as minimum stack-string length, minimum NOP sled length or the maximum number of instructions that should be emulated;</p><p>控制参数，例如最小堆栈串长度、最小NOP滑板长度或应该仿真的最大指令数；</p><p> The main output parameter is the  Flags field, which contains a list of shellcode indicators detected during the emulation. Generally, a non-zero value of this field strongly suggests that the emulate code is, in fact, a shellcode.</p><p>主要输出参数是Flags字段，该字段包含在模拟期间检测到的外壳代码指示符的列表。通常，此字段的非零值强烈表明仿真代码实际上是外壳代码。</p><p> bdshemu is built as a plain, quick and simple x86 instruction emulator: since it only works with the shellcode itself and a small virtual stack, it doesn’t have to emulate any architectural specifics - interrupts or exceptions, descriptor tables, page-tables, etc. In addition, since we only deal with the shellcode and stack memory, bdshemu does not do memory access checks, since it doesn’t even allow accesses to other addresses. The only state apart from the registers that can be accessed is the shellcode itself and the stack, and both are copies of the actual memory contents - the system state is never modified during the emulation, only the provided  SHEMU_CONTEXT is. This makes bdshemu extremely fast, simple, and lets us focus on its main purpose: detecting shellcodes.</p><p>Bdshemu被构建为一个简单、快速、简单的x86指令仿真器：因为它只与外壳代码本身和一个小的虚拟堆栈一起工作，所以它不必模拟任何体系结构细节-中断或异常、描述符表、页表等。此外，由于我们只处理外壳代码和堆栈内存，bdshemu不执行内存访问检查，因为它甚至不允许访问其他地址。除了可以访问的寄存器之外，唯一可以访问的状态是外壳代码本身和堆栈，两者都是实际内存内容的副本-系统状态在仿真期间永远不会修改，只有提供的SHEMU_CONTEXT才会修改。这使得bdshemu非常快速、简单，并让我们将重点放在它的主要用途上：检测外壳代码。</p><p> As far as instruction support goes, bdshemu supports all the basic x86 instructions, such as branches, arithmetic, logic, shift, bit manipulation, multiplication/divison, stack access and data transfer instructions. In addition, it also has support for other instructions, such as some basic MMX or AVX instructions -  PUNPCKLBW or  VPBROADCAST are two good examples.</p><p>就指令支持而言，bdshemu支持所有基本的x86指令，如分支、算术、逻辑、移位、位操作、乘除、堆栈访问和数据传输指令。此外，它还支持其他指令，例如一些基本的MMX或AVX指令-PUNPCKLBW或VPBROADCAST就是两个很好的例子。</p><p>  In order to determine whether an emulated piece of code behaves like a shellcode, there are several indicators bdshemu uses.</p><p>为了确定模拟代码的行为是否与外壳代码类似，bdshemu使用了几个指示符。</p><p>  This is the classic presentation of shellcodes; since the exact entry point of the shellcode when gaining code execution may be unknown, attackers usually prepend a long sequence of  NOP instructions, encoding  0x90. The parameters for the NOP-sled length can be controlled when calling the emulator, via the  NopThreshold context field. The default value is  SHEMU_DEFAULT_NOP_THRESHOLD, which is  75, meaning that minimum 75% of all the emulated instruction must be  NOP.</p><p>这是外壳代码的经典表示形式；因为在获得代码执行时外壳代码的确切入口点可能是未知的，所以攻击者通常会在前面加上一长串NOP指令，编码为0x90。在调用仿真器时，可以通过NopThreshold上下文字段控制NOP-SLED长度的参数。默认值为SHEMU_DEFAULT_NOP_THRESHOLD，即75，这意味着所有仿真指令的最低75%必须是NOP。</p><p>  Shellcodes are designed to work correctly no matter what address they’re loaded at. This means that the shellcode has to determine, dynamically, during runtime, the address it was loaded at, so absolute addressing can be replaced with some form of relative addressing. This is typically achieved by retrieving the value of the instruction pointer using well-known techniques:</p><p>外壳代码被设计为无论加载到哪个地址都能正常工作。这意味着外壳代码必须在运行时动态确定加载它的地址，因此可以用某种形式的相对寻址代替绝对寻址。这通常是通过使用众所周知的技术检索指令指针的值来实现的：</p><p> CALL $+5/POP ebp - executing these two instructions will result in the value of the instruction pointer being stored in the  ebp register; data can then be accessed inside the shellcode using offsets relative to the  ebp value;</p><p>调用$+5/POP EBP-执行这两条指令将导致指令指针的值存储在EBP寄存器中；然后可以使用相对于EBP值的偏移量在外壳代码内访问数据；</p><p>  FNOP/FNSTENV [esp-0xc]/POP edi - the first instruction is any FPU instruction (not necessarily  FNOP), and the second instruction,  FNSTENV saves the FPU environment on the stack; the third instruction will retrieve the  FPU Instruction Pointer from  esp-0xc, which is part of the FPU environment, and contains the address of the last FPU executed - in our case,  FNOP; from there on, addressing relative to the  edi can be used to access shellcode data;</p><p>FNOP/FNSTENV[esp-0xc]/POP EDI-第一条指令是任何FPU指令(不一定是FNOP)，第二条指令FNSTENV将FPU环境保存在堆栈上；第三条指令将从esp-0xc检索FPU指令指针，它是FPU环境的一部分，包含最后执行的FPU的地址-在我们的例子中是FNOP；从那时起，可以使用相对于EDI的寻址来访问外壳。</p><p> Internally, bdshemu keeps track of all the instances of the instruction pointer being saved on the stack. Later loading that instruction pointer from the stack in any way will result in triggering this detection. Due to the way bdshemu keeps track of the saved instruction pointers, it doesn’t matter when, where or how the shellcode attempts to load the RIP in a register and use it, bdshemu will always trigger a detection.</p><p>在内部，bdshemu跟踪保存在堆栈上的指令指针的所有实例。稍后，以任何方式从堆栈加载该指令指针都会导致触发此检测。由于bdshemu跟踪保存的指令指针的方式，外壳代码何时、何地或如何尝试将RIP加载到寄存器并使用它并不重要，bdshemu将始终触发检测。</p><p> In 64 bit, RIP-relative addressing can be used directly, since the instruction encoding allows it. However, surprisingly, a large number of shellcodes still use a classic method of retrieving the instruction pointer (generally the  CALL/POP technique), which is somehow weird, but it probably indicated that 32 bit shellcodes were ported to 64 bit with minimal modifications.</p><p>在64位中，可以直接使用RIP相对寻址，因为指令编码允许这样做。然而，令人惊讶的是，大量外壳代码仍然使用检索指令指针的经典方法(通常是调用/弹出技术)，这有点奇怪，但这可能表明32位外壳代码只需极少的修改即可移植到64位。</p><p>  Most often, shellcodes come in encoded or encrypted forms, in order to avoid certain bad characters (for example,  0x00 in a shellcode that should resemble a string may break the exploit) or to avoid detection by security technologies (for example, AV scanners). This means that during runtime, the shellcode must decode itself (usually in-place), by modifying its own contents, and then executing the plain-text code. Typical methods of decoding involve  XOR or  ADD based decryption algorithms.</p><p>最常见的情况是，外壳代码以编码或加密的形式出现，以避免某些恶意字符(例如，外壳代码中应该类似于字符串的0x00可能会破坏利用漏洞)或避免被安全技术(例如，反病毒扫描仪)检测到。这意味着在运行时，外壳代码必须自己解码(通常是就地解码)，方法是修改自己的内容，然后执行纯文本代码。典型的解码方法涉及基于XOR或ADD的解密算法。</p><p> Certainly, bdshemu follows this kind of behavior, and keeps track internally of each modified byte inside the shellcode. Whenever the suspected shellcode writes any portion of itself, and then it executes it, the self-write detection will be triggered.</p><p>当然，bdshemu遵循这种行为，并在内部跟踪外壳代码中修改的每个字节。只要可疑的外壳代码写入自身的任何部分，然后执行它，就会触发自写检测。</p><p>  Once a shellcode has gained code execution, it needs to locate several functions inside various modules, in order to carry its actual payload (for example, downloading a file, or creating a process). On Windows, the most common way of doing this is by parsing the user-mode loader structures, in order to locate the addresses where the required modules were loaded, and then locate the needed functions inside these modules. The sequence of structures the shellcode will access is:</p><p>一旦外壳代码获得代码执行，它就需要在各个模块中定位几个函数，以便承载其实际有效负载(例如，下载文件或创建进程)。在Windows上，最常见的方法是解析用户模式加载器结构，以便找到加载所需模块的地址，然后在这些模块中定位所需的函数。外壳代码将访问的结构顺序为：</p><p> The Thread Environment Block ( TEB), which is located at  fs:[0] (32 bit thread) or  gs:[0] (64 bit thread);</p><p>线程环境块(TEB)，位于fs：[0](32位线程)或gs：[0](64位线程)；</p><p>  The Process Environment Block ( PEB), which is located at  TEB+0x30 (32 bit) or  TEB+0x60 (64 bit)</p><p>进程环境块(PEB)，位于TEB+0x30(32位)或TEB+0x60(64位)。</p><p> Inside the  PEB_LDR_DATA, there are several lists which contain the loaded modules. The shellcode will iterate through these lists in order to locate the much needed libraries and functions.</p><p>在PEB_LDR_DATA中，有几个包含已加载模块的列表。外壳代码将遍历这些列表，以便找到急需的库和函数。</p><p> On each memory access, bdshemu will see if the shellcode tries to access the  PEB field inside  TEB. bdshemu will keep track of memory accesses even if they are made without the classic  fs/gs segment prefixes - as long as an access to the  PEB field inside  TEB is identified, the TIB access detection will be triggered.</p><p>在每次内存访问时，bdshemu将查看外壳代码是否尝试访问TEB内的PEB字段。BDSHEMU将跟踪存储器访问，即使它们是在没有经典的FS/GS段前缀的情况下进行的-只要识别到对TEB内的PEB字段的访问，就会触发TIB访问检测。</p><p>  Legitimate code will rely on several libraries in order to invoke operating system services - for example, in order to create a process, normal code would call one of the  CreateProcess functions on Windows. It is uncommon for legitimate code to directly invoke a SYSCALL, since the SYSCALL interface may change over time. For this reason, bdshemu will trigger the SYSCALL detection whenever it sees that a suspected shellcode directly invokes a system service using the  SYSCALL/SYSENTER/INT instructions.</p><p>合法代码将依赖几个库来调用操作系统服务-例如，为了创建进程，正常代码将调用Windows上的CreateProcess函数之一。合法代码直接调用syscall的情况并不常见，因为syscall接口可能会随着时间的推移而改变。因此，只要bdshemu发现可疑的外壳代码使用syscall/SYSENTER/INT指令直接调用系统服务，就会触发syscall检测。</p><p>  Another common way for shellcodes to mask their contents is to dynamically construct strings on the stack. This may eliminate the need to write Position Independent Code (PIC), since the shellcode would dynamically build the desired strings on the stack, instead of referencing them inside the shellcode as regular data. Typical ways of achieving this is by saving the string contents on the stack, and then reference the string using the stack pointer:</p><p>外壳代码屏蔽其内容的另一种常见方式是在堆栈上动态构造字符串。这可以消除编写位置无关代码(PIC)的需要，因为外壳代码将在堆栈上动态构建所需的字符串，而不是将它们作为常规数据在外壳代码内引用。实现这一点的典型方法是将字符串内容保存在堆栈上，然后使用堆栈指针引用该字符串：</p><p>  The code above would end up storing the string  calc.exe on the stack, which can then be used as a normal string throughout the shellcode.</p><p>上述代码最终会将字符串calc.exe存储在堆栈上，然后可以在整个外壳代码中将其用作普通字符串。</p><p> For each value saved on the stack that resembles a string, bdshemu keeps track of the total length of the string constructed on the stack. Once the threshold indicated by the  StrLength field inside the context is exceeded, the stack string detection will be triggered. The default value for this field is  SHEMU_DEFAULT_STR_THRESHOLD, which is equal to  8, meaning that dynamically constructing a string equal to or longer than 8 characters on the stack will trigger this detection.</p><p>对于保存在堆栈上的每个类似于字符串的值，bdshemu都会跟踪堆栈上构造的字符串的总长度。一旦超过上下文中StrLength字段指示的阈值，就会触发堆栈字符串检测。此字段的默认值为SHEMU_DEFAULT_STR_THRESHOLD，等于8，这意味着在堆栈上动态构造等于或超过8个字符的字符串将触发此检测。</p><p>  While the above mentioned techniques are general and can be applied to any shellcode, on any operating system and on both 32 or 64 bit (except for the TIB access detection, which is Windows specific), bdshemu also has the capability of determining some kernel-specific shellcode behavior.</p><p>虽然上述技术是通用的，可以应用于任何操作系统和32位或64位的任何外壳代码(除了特定于Windows的TIB访问检测)，但bdshemu也能够确定一些内核特定的外壳代码行为。</p><p>  The Kernel Processor Control Region ( KPCR) is a per-processor structure on Windows systems that contains lots of information critical for the kernel, but which may be useful for an attacker as well. Commonly, the shellcode would wish to reference the currently executing thread, which can be retrieved by accessing the  KPCR structure, at offset  0x124 on 32 bit systems and  0x188 on 64 bit systems.</p><p>内核处理器控制区(KPCR)是Windows系统上的每个处理器的结构，其中包含许多对内核至关重要的信息，但也可能对攻击者有用。通常，外壳代码希望引用当前执行的线程，在32位系统上的偏移量为0x124，在64位系统上的偏移量为0x188，可以通过访问kpcr结构来检索该线程。</p><p> Just like the TIB access detection technique, bdshemu keeps track of memory accesses, and when the emulated code reads the current thread from the  KPCR, it will trigger the  KPCR access detection.</p><p>就像TIB访问检测技术一样，bdshemu跟踪内存访问，当仿真代码从KPCR读取当前线程时，它将触发KPCR访问检测。</p><p>  SWAPGS is a system instruction that is only executed when transitioning from user-mode to kernel-mode and vice-versa. Sometimes, due to the specifics of certain kernel exploits, the attacker will end up needing to execute  SWAPGS - for example, the EternalBlues kernel payload famously intercepted the SYSCALL handler, so it needed to execute  SWAPGS when a SYSCALL took place, just like an ordinary system call would do.</p><p>SWAPGS是一条系统指令，只有在从用户模式转换到内核模式时才会执行，反之亦然。有时，由于某些内核攻击的特殊性，攻击者最终需要执行SWAPGS-例如，著名的EternalBlues内核有效负载拦截了syscall处理程序，因此它需要在syscall发生时执行SWAPGS，就像普通的系统调用所做的那样。</p><p> bdshemu will trigger the SWAPGS detection whenever it encounters the  SWAPGS instruction being executed by a suspected shellcode.</p><p>每当bdshemu遇到由可疑外壳代码执行的SWAPGS指令时，它都会触发SWAPGS检测。</p><p>  Some shellcodes (such as the aforementioned EternalBlue kernel payload) will have to modify the SYSCALL handler in order to migrate to a stable execution environment (for example, because the initial shellcode executes at a high IRQL, which needs to be lowered before calling useful routines). This is done by modifying the SYSCALL MSRs using the  WRMSR instruction, and then waiting for a syscall to execute (which is at lower IRQL) to continue execution (this is also where the SWAPGS technique comes in handy, since  SWAPGS must be executed after each SYSCALL on 64 bit).</p><p>一些外壳代码(如前面提到的EternalBlue内核有效负载)必须修改syscall处理程序才能迁移到稳定的执行环境(例如，因为初始外壳代码在较高的IRQL下执行，在调用有用的例程之前需要降低IRQL)。这是通过使用WRMSR指令修改系统调用MSR，然后等待系统调用执行(位于较低的IRQL)以继续执行(这也是SWAPGS技术派上用场的地方，因为SWAPGS必须在64位上的每个系统调用之后执行)来完成。</p><p> In addition, in order to locate the kernel image in memory, and, subsequently, useful kernel routines, a quick and easy technique is by querying the SYSCALL MSR (which normally points to the SYSCALL handler inside the kernel image), and then walk pages backwards until the beginning of the kernel image is found.</p><p>此外，为了在内存中定位内核镜像以及随后有用的内核例程，一种快速而简单的技术是查询syscall MSR(通常指向内核镜像内的syscall处理程序)，然后向后遍历页面，直到找到内核镜像的开头。</p><p> bdshemu will trigger the MSR access detection whenever the suspected shellcode accesses the SYSCALL MSRs (both on 32 or 64 bit mode).</p><p>只要可疑的外壳代码访问syscall MSR(在32位或64位模式下)，bdshemu就会触发MSR访问检测。</p><p>  The bdshemu project contains some synthetic test-cases, but the best way to demonstrate its functionality is by using real-life shellcodes. In this regard, Metasploit is remarkable at generating different kinds of payloads, using all kind of encoders. Let’s take the following shellcode as a purely didactic example:</p><p>Bdshemu项目包含一些合成测试用例，但演示其功能的最佳方式是使用真实的外壳代码。在这一点上，Metasploit在使用各种编码器生成不同类型的有效负载方面非常出色。让我们以下面的外壳代码作为一个纯粹的说教例子：</p><p> DA C8 D9 74 24 F4 5F 8D 7F 4A 89 FD 81 ED FE FFFF FF B9 61 00 00 00 8B 75 00 C1 E6 10 C1 EE 10 83 C5 02 FF 37 5A C1 E2 10 C1 EA 10 89 D3 09 F3 21 F2 F7 D2 21 DA 66 52 66 8F 07 6A 02 03 3C 24 5B 49 85 C9 0F 85 CD FF FF FF 1C B3 E0 5B 62 5B 62 5B 02 D2 E7 E3 27 87 AC D7 9C 5C CE 50 45 02 51 89 23 A1 2C 16 66 30 57 CF FB F3 9A 8F 98 A3 B8 62 77 6F 76 A8 94 5A C6 0D 4D 5F 5D D4 17 E8 9C A4 8D DC 6E 94 6F 45 3E CE 67 EE 66 3D ED 74 F5 97 CF DE 44 EA CF EB 19 DA E6 76 27 B9 2A B8 ED 80 0D F5 FB F6 86 0E BD 73 99 06 7D 5E F6 06 D2 07 01 61 8A 6D C1 E6 99 FA 98 29 13 2D 98 2C 48 A5 0C 81 28 DA 73 BB 2A E1 7B 1E 9B 41 C4 1B 4F 09 A4 84 F9 EE F8 63 7D D1 7D D1 7D 81 15 B0 9E DF 19 20 CC 9B 3C 2E 9E 78 F6 DE 63 63 FE 9C 2B A0 2D DC 27 5C DC BC A9 B9 12 FE 01 8C 6E E6 6E B5 91 60 F2 01 9E 62 B0 07 C8 62 C8 8C</p><p>DA C8 D9 74 24 F4 5F 8D 7F 4A 89 FD 81 ED FE FFFF B9 61 00 00 00 8B 75 00 C1 E6 10 C1 EE 10 83 C5 02 FF 37 5A C1 E2 10 C1 EA 10 89 D3 09 F3 21 F2 F7 D2 21 DA 66 66 52 66 8F 07 6A 02 03 3C 24 5B 49 85 C9 0F 85 CD FF 1C B3 E0 5B 62 5B 5B 02 D2 E7 E3 E3 27 87 AC D。0D 4D 5F 5D D4 17 E8 9C A4 8D DC 6E 94 6F 45 3E CE 67 EE 66 3D ED 74 F5 97 CF DE 44 EA CF EB 19 DA E6 76 27 B9 2A B8 ED 80 0D F5 FB F6 86 0E BD 73 99 06 7D 5E F6 06 D2 07 01 61 8A 6D C1 E6 99 FA 98 29 13 2D 98 2C 48 A5 0C 81 28 DA 73 BB 2A E1 7B 1E 9B 41 C41。A0 2D DC 27 5C DC BC A9 B9 12 FE 01 8C 6E E6 6E B5 91 60 F2 01 9E 62 B0 07 C8 62 C8 8C。</p><p> Saving this as a binary file as  shellcode.bin and then viewing its contents yields a densely packed chunk of code, highly indicative of an encrypted shellcode:</p><p>将其另存为二进制文件shellcode.bin，然后查看其内容会生成一个密集打包的代码块，这高度表明是加密的外壳代码：</p><p>  Using the disasmtool provided in the bddisasm project, one can use the  -shemu option to run the shellcode emulator on the input.</p><p>使用bddisasm项目中提供的disasmtool，可以使用-shemu选项在输入上运行外壳代码仿真器。</p><p>  Running this on our shellcode will display step-by-step information about each emulated instruction, but because that trace is long, let’s jump directly to the end of if:</p><p>在我们的外壳代码上运行它将显示有关每个仿真指令的逐步信息，但是因为该跟踪很长，所以让我们直接跳到if的末尾：</p><p> Emulating: 0x0000000000200053 XOR eax, eax RAX = 0x0000000000000000 RCX = 0x0000000000000000 RDX = 0x000000000000ee00 RBX = 0x0000000000000002 RSP = 0x0000000000100fd4 RBP = 0x0000000000100fd4 RSI = 0x0000000000008cc8 RDI = 0x000000000020010c R8 = 0x0000000000000000 R9 = 0x0000000000000000 R10 = 0x0000000000000000 R11 = 0x0000000000000000 R12 = 0x0000000000000000 R13 = 0x0000000000000000 R14 = 0x0000000000000000 R15 = 0x0000000000000000 RIP = 0x0000000000200055 RFLAGS = 0x0000000000000246Emulating: 0x0000000000200055 MOV edx, dword ptr fs:[eax+0x30]Emulation terminated with status 0x00000001, flags: 0xe, 0 NOPs SHEMU_FLAG_LOAD_RIP SHEMU_FLAG_WRITE_SELF SHEMU_FLAG_TIB_ACCESS</p><p>Emulating：0x0000000000200053 XOR eax，eax RAX=0x0000000000000000 RCX=0x0000000000000000 RDX=0x000000000000ee00 RBX=0x0000000000000002 RSP=0x0000000000100fd4 RBP=0x0000000000100fd4 RSI=0x0000000000008cc8 RDI=0x000000000020010c R8=0x0000000000000000 R9=0x0000000000000000 R10=0x0000000000000000 R11=0x0000000000000000 R12=0x0000000000000000 R13=0x0000000000000000 R14=0x0000000000000000 R15=0x0000000000000000 RIP=0x0000000000200055 RFLAGS=0x0000000000000246Emulating：0x0000000000200055 MOV edx，dword ptr fs：[eax+0x30]Emulation terminated with status 0x00000001，flags：0xe，0 NOPs SHEMU_FLAG_LOAD_RIP SHEMU_FLAG_WRITE_SELF SHEMU_FLAG_TIB_ACCESS。</p><p> We can see that the last emulated instruction is  MOV edx, dword ptr fs:[eax+0x30], which is a  TEB access instruction, but which also triggers emulation to be stopped, since it is an access outside shellcode memory (and remember, bdshemu will stop at the first memory access outside the shellcode or the stack). Moreover, this small shellcode (generated using Metasploit) triggered 3 detections in bdshemu:</p><p>我们可以看到，最后一条模拟指令是MOV edX，dword PTR fs：[EAX+0x30]，这是TEB访问指令，但也会触发模拟停止，因为它是外壳代码存储器之外的访问(请记住，bdshemu将在外壳代码或堆栈之外的第一次存储器访问时停止)。此外，这个小的外壳代码(使用Metasploit生成)在bdshemu中触发了3次检测：</p><p> SHEMU_FLAG_LOAD_RIP - the shellcode loads the  RIP inside a general-purpose register, to locate its position in memory;</p><p>SHEMU_FLAG_LOAD_RIP-外壳代码将RIP加载到通用寄存器中，以定位其在内存中的位置；</p><p>    SHEMU_FLAG_TIB_ACCESS - the shellcode goes on to access the  PEB, in order to locate important libraries and functions;</p><p>SHEMU_FLAG_TIB_ACCESS-外壳代码继续访问PEB，以定位重要的库和函数；</p><p> These indicators are more than enough to conclude that the emulated code is, without a doubt, a shellcode. What’s even more awesome about bdshemu is that generally, at the end of the emulation, the memory will contain the decrypted form of the shellcode. disasmtool is nice enough to save the shellcode memory once emulation is done - a new file, named  shellcode.bin_decoded.bin is created which now contains the decoded shellcode; let’s take a look at it:</p><p>这些指标足以断定，仿真代码无疑是外壳代码。关于bdshemu，更令人敬畏的是，通常在仿真结束时，内存将包含外壳代码的解密形式。Disasmtool非常好，可以在模拟完成后保存外壳代码内存-创建了一个名为shellcode.bin_decded.bin的新文件，该文件现在包含已解码的外壳代码；让我们来看看它：</p><p>  Looking at the decoded shellcode, one can immediately see not only that it is different, but that is plain text - a keen eye will quickly identify the  calc.exe string at the end of the shellcode, hinting us that it is a classic  calc.exe spawning shellcode.</p><p>查看解码的外壳代码，人们不仅可以立即看到它是不同的，而且这是纯文本-敏锐的眼睛会很快识别出外壳代码末尾的calc.exe字符串，提示我们这是一个典型的calc.exe派生外壳代码。</p><p>  We presented in this blog-post the Bitdefender shellcode emulator, which is a critical part of HVMI’s exploit detection technology. bdshemu is built to detect shellcode indicators at the binary-code level, without the need to emulate complex API calls, complex memory layout or complex architectural entities, such as page-tables, descriptor tables, etc. - bdshemu focuses on what matters most, emulating the instructions and determining if they behave like a shellcode.</p><p>我们在这篇博文中介绍了BitDefender外壳代码仿真器，它是HVMI漏洞检测技术的关键部分。Bdshemu的构建目的是在二进制代码级别检测外壳代码指示符，而无需模拟复杂的API调用、复杂的内存布局或复杂的体系结构实体(如页表、描述符表等)。bdshemu专注于什么是最重要的，模拟指令并确定它们的行为是否像外壳代码。</p><p> Due to its simplicity, bdshemu works for shellcodes aimed towards any operating system, as most of the detection techniques are specific to instruction-level behavior, instead of high level behavior such as API calls. In addition, it works on both 32 and 64 bit code, as well as with user or kernel specific code.</p><p>由于其简单性，bdshemu适用于针对任何操作系统的外壳代码，因为大多数检测技术都特定于指令级行为，而不是API调用等高级行为。此外，它既可以处理32位和64位代码，也可以处理特定于用户或内核的代码。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hvmi.github.io/blog/2020/11/11/bdshemu.html">https://hvmi.github.io/blog/2020/11/11/bdshemu.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/x86/">#x86</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/shellcode/">#shellcode</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034170.html"><img src="http://img2.diglog.com/img/2020/11/thumb_56a05dc5c975233a30baf94faf5b2661.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034170.html">为什么并发性很难</a></div><span class="my_story_list_date">2020-11-10 7:38</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033720.html"><img src="http://img2.diglog.com/img/2020/11/thumb_bba3eb5c8d73b959a4615157fb01dd65.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033720.html">FBI警告称黑客滥用错误配置的SonarQube应用程序从美国政府机构和私人企业窃取源代码仓库</a></div><span class="my_story_list_date">2020-11-8 8:44</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033691.html"><img src="http://img2.diglog.com/img/2020/11/thumb_f8aa49dfa5b05dd69bcd9fc030339c08.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033691.html">如何拥有代码</a></div><span class="my_story_list_date">2020-11-7 18:10</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033690.html"><img src="http://img2.diglog.com/img/2020/11/thumb_0588ada816e1b2413594f6bfb6f8d351.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033690.html">Vgil：永远保持道德警惕的编程语言</a></div><span class="my_story_list_date">2020-11-7 18:10</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>