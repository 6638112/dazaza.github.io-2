<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>双抓取，调度算法和洋葱圈 Double fetches, scheduling algorithms, and onion rings</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Double fetches, scheduling algorithms, and onion rings<br/>双抓取，调度算法和洋葱圈 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-11 07:58:53</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/b6db7cd197a2535fb1b664ee120c99a4.png"><img src="http://img2.diglog.com/img/2020/12/b6db7cd197a2535fb1b664ee120c99a4.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Most people thought I was crazy for doing this, but I spent the last few months of my gap year working as a short order cook at a family-owned fast-food restaurant. (More on this  here.) I’m a programmer by trade, so I enjoyed thinking about the restaurant’s systems from a programmer’s point of view. Here’s some thoughts about two such systems.</p><p>大多数人都认为我为此感到疯狂，但是我度过了假期的最后几个月，在一家家庭式快餐店当短期厨师。 （这里有更多信息。）我是一名行业程序员，所以我很乐意从程序员的角度考虑餐厅的系统。这是关于两个这样的系统的一些想法。</p><p>   Human systems, at first glance, can appear broken, but due to subtle human factors, they might actually work just fine.</p><p>   乍一看，人的系统可能看起来很破损，但是由于人为因素的影响，它们实际上可能工作得很好。</p><p> My best example is the system for taking and fulfilling orders. We never wrote anything down, and would re-ask orders multiples times, including when ringing customers up. (In computer security, this is known as a  double fetch.) Not great service and can theoretically let customers lie and pay less.</p><p> 我最好的例子是接受和履行订单的系统。我们从不写下任何东西，并且会多次要求订单，包括在吸引客户时。 （在计算机安全性方面，这被称为“双重获取”。）服务不是很好，并且从理论上讲可以让客户撒谎并减少支付。</p><p> In practice most customers didn’t mind  too much, liars are rare, and we can loosely detect when something seems off with an order.</p><p> 实际上，大多数客户不太介意，骗子很少，我们可以轻松地发现订单出现问题的时间。</p><p> Writing orders down and asking strictly once seems optimal but has subtle flaws. For one thing, there’s not enough space behind the counter for everyone to walk to the written order, so it requires more internal communication. This will fail during a rush when you’re blocked on order details and coworkers are too busy for questions.  Customers are always idle; coworkers aren’t.</p><p> 写下订单并严格要求一次似乎是最佳选择，但存在细微的缺陷。一方面，柜台后面没有足够的空间让每个人都能走到书面订单，因此需要更多的内部沟通。如果您在订单明细中受阻，而同事却忙于提问，这将无法解决。客户总是闲着；同事不是。</p><p> It can increase confusion if order slips aren’t thrown out when orders are finished and is also logistically (and literally) messy if you have greasy gloves and want to avoid touching a pen, then food. Lastly, many of my coworkers were older and very used to the existing system.  A major transition to a new system would have generated more confusion than it’s worth.</p><p> 如果在完成订单时不扔掉订单单，可能会增加混乱，如果戴着油腻的手套并且想避免接触笔和食物，那么这在逻辑上（字面上）也会很混乱。最后，我的许多同事都比较老，非常习惯现有系统。向新系统的重大过渡会带来比其价值更大的混乱。</p><p>  While I covered a range of duties including the cash register, milkshake machine, and grill, I spent the most time on the deep fryer. I’m delighted to present this overanalysis of life as a fry cook, from a programmer’s point of view.</p><p>  我负责收银机，奶昔机和烧烤炉等一系列工作，但我在油炸锅上花费了最多的时间。从程序员的角度，我很高兴地介绍这种对炒菜锅的生活的过度分析。 </p><p>   This picture has 2 fryers, each with 2 baskets that can be submerged to sit in the vats of hot oil below. At work, only 1 fryer would be active on any given day which effectively allows 2 items to be fried at the same time.</p><p>这张照片有2个油炸锅，每个都有2个篮子，可以浸没在下面的热油桶中。在工作中，任何一天只有一个油炸锅处于活动状态，这实际上允许同时油炸2个项目。</p><p> Fry cooks have a lot in common with operating systems in that they are both responsible for scheduling. Operating systems schedule threads to run on a limited number of cores; fry cooks schedule food to be fried in a limited number of fryers. Different food items have different priorities, and different lengths of time to cook.</p><p> 油炸厨师与操作系统有很多共同之处，因为它们都负责调度。操作系统将线程调度为在有限数量的内核上运行；炸锅厨师计划在有限数量的炸锅中油炸食物。不同的食物有不同的优先级，并且烹饪时间也不同。</p><p> French fries, curly fries, and onion rings (collectively, “fries”) are the main menu items from the deep fryer. Each fry order could be large or small (except for rings which were only large) and eat-in or to-go. The job of the fry cook is to:</p><p> 法式炸薯条，卷曲的炸薯条和洋葱圈（统称为“炸薯条”）是油炸锅的主要菜单项。每个炸薯条的大小都可以大或小（只有大的圆环除外），并且可以吃或吃。油炸厨师的工作是：</p><p> Serve them onto the customer’s tray on the counter, or their to-go bag</p><p> 将它们放在柜台上客户的托盘或待办事项包上</p><p> The goal is to do this with maximum speed and accuracy and without dropping orders. You’ll ideally minimize the number of times you ask customers and coworkers for order details. In addition, there are a few sources of complexity to handle:</p><p> 我们的目标是以最大的速度和准确性来做到这一点，而又不会下订单。理想情况下，您可以最大程度地减少向客户和同事询问订单详细信息的次数。此外，还有一些复杂性需要处理：</p><p> Incomplete information: Depending on the greeter, they may forget to specify if it’s eat-in or to-go. You can always ask the customer, but the grill chef will likely ask the same question in a little bit. You might be able to save a customer ask if you can eavesdrop on that interaction.</p><p> 信息不完整：根据问候者的不同，他们可能会忘记指定是进餐还是进餐。您可以随时询问客户，但是烧烤厨师可能会稍作询问。您可能可以保存客户询问，是否可以窃听该交互。</p><p> Timing requirements: You need to finish orders by the time the grill chef finishes the burgers/hot dogs, but you shouldn’t finish too early. If you put the fries on the counter way before the burgers are ready, they’ll get cold. This matters less for to-go orders, which you can serve into the bag immediately.</p><p> 时间要求：您需要在烧烤厨师煮完汉堡/热狗之前完成订单，但不要太早完成。如果您在准备汉堡之前将炸薯条放在柜台上，它们会变冷。这对于待办订单而言意义不大，您可以立即将其放入袋中。 </p><p> Scale: During a rush, you might receive many orders per minute, while only being able to process 1-2 per minute. Once the greeter relays the order, they forget it, so it’s up to you to remember. And remember: no writing things down.</p><p>规模：在高峰期，您每分钟可能会收到很多订单，而每分钟只能处理1-2个订单。迎宾员下达命令后，他们便会忘记该命令，因此您要记住。记住：不要写下来。</p><p> Waste avoidance: Sometimes you or another cook will make too many fries. To avoid wasting them, you can use the excess towards a future order by refreshing them with a splash later and adding them to a fresh batch.</p><p> 避免浪费：有时您或另一位厨师会做太多的薯条。为避免浪费它们，您可以将多余的部分用于以后的订单，方法是稍后用刷新来刷新它们，并将它们添加到新批次中。</p><p> Changing orders: Customers sometimes change their order after you’ve started cooking (e.g. regular fry to curly fry). Now you have to figure out what to do with the partially cooked portion currently in the fryer.</p><p> 更改订单：客户有时会在您开始做饭后更改他们的订单（例如，将普通炸薯条换成卷曲炸薯条）。现在，您必须弄清楚如何处理当前油炸锅中的部分煮熟的部分。</p><p> Miscellaneous items: In addition to fries, there other items that need to be scheduled for time in the fryer, including chicken patties, bacon, clam strips, and fish fillets.</p><p> 杂项：除了炸薯条外，还需要安排其他时间在炸锅中烹饪，包括鸡肉馅饼，培根，蛤c条和鱼片。</p><p>  Batching orders together. If a large and small fry order are in the queue, you can cook them in the same basket at the same time. Some customers request their fries “well done”, meaning cooked extra long. This makes batching more complicated.</p><p>  一起批处理订单。如果队列中有大大小小的鱼苗订单，则可以同时在同一篮子中烹制它们。一些顾客要求炸薯条“做得好”，这意味着煮的时间更长。这使批处理更加复杂。</p><p> “Wait n Splash”: If a fry order is done cooking far before the rest of the grill items and you don’t have pressing items that need fryer time, you can raise the basket from the oil, but leave the food in it. When the grill items finish, you can quickly splash the food back in the oil to refresh it, then serve it. This will prevent it from getting cold on the counter.</p><p> “等待飞溅”：如果在剩下的烧烤物品之前就完成了油炸命令，并且没有需要油炸时间的紧迫物品，则可以从油中提起篮子，但将食物留在里面。烧烤物品完成后，您可以将食物快速倒回油中以使其刷新，然后上菜。这样可以防止它在柜台上变冷。</p><p> Inactive fryer baskets: It can be handy to have extra storage space for cooked food. If you have a “wait n splash” order waiting, but you have more orders to fry, you can use the 2 spare baskets from the inactive fryer to store the waiting order and free up the fryer slot. This is also useful when customers change their order and you need to quickly stash the half cooked portion somewhere and start the adjusted order.</p><p> 不活动的炸锅篮：可以方便地为熟食提供额外的存储空间。如果您有一个“等待n飞溅”的订单正在等待，但是您有更多的要炸的订单，则可以使用非活动炸锅中的2个备用篮来存储等待的订单并腾出炸锅插槽。当客户更改订单并需要将半熟部分快速存放在某个地方并开始调整后的订单时，这也很有用。 </p><p> “The tong dip”: If both fryers are in use and the grill chef hands you bacon to be urgently cooked, you can hold the bacon in tongs and dip it into one of the submerged baskets. This lets you effectively cook more than 2 things at the same time.</p><p>“钳子蘸料”：如果两个炸锅都在使用，并且烧烤厨师将培根交给您紧急煮熟，则可以将培根放在钳子中，然后浸入一个浸没的篮子中。这样一来，您可以有效地同时烹饪两件事。</p><p> Here’s the system I ended up using. When a new order came in, I’d stop whatever I was doing and grab the appropriate container and place it in the corresponding fry bucket. This captures all 3 pieces of information about the order (fry type, size, to-go?) letting me forget it. If I strictly follow this, I can just process the containers in the buckets like a queue. However, I still need to keep a sense of order memorized because the system doesn’t capture global ordering – if I have containers in the fry, curly fry, and onion ring buckets, I can’t tell which order came in first.</p><p> 这是我最终使用的系统。接到新订单时，我会停止做任何事情，拿起合适的容器，然后将其放入相应的油炸桶中。这捕获了有关订单的所有3条信息（油炸类型，大小，待运？），让我忘记了。如果严格遵守此规则，我可以像处理队列一样处理存储桶中的容器。但是，由于该系统无法捕获全局订单，因此我仍然需要保持一定的顺序感-如果在炸锅，卷发炸锅和洋葱圈桶中有容器，则无法确定先到哪个顺序。</p><p> I don’t have a solution for this. On a super busy day, this system falls apart and I drop orders. Extreme load like that has only happened a few times and in that case, I just make large batches, forget about syncing up with the grill items, and hope I don’t have too much excess at the end. Generally, the system worked nicely.</p><p> 我对此没有解决方案。在非常忙碌的一天，这个系统崩溃了，我下订单了。这样的极端负载只发生了几次，在这种情况下，我只生产了大批产品，却忘记了与烧烤物品同步，并希望最后我不会有太多多余的东西。通常，该系统运行良好。</p><p>  It’s fun to think about human systems, like those in a restaurant, from a programmer’s point of view. A fry cook’s job closely resembles that of an operating system scheduler, complete with optimization points and edge cases. One can try to optimize human systems as if they were computer systems, but it’s critical to understand the subtle human aspects of the system when evaluating improvements.</p><p>  从程序员的角度考虑人的系统（例如餐厅中的人系统）很有趣。油炸厨师的工作与操作系统调度程序非常相似，并带有优化点和边缘案例。人们可以尝试像计算机系统一样优化人类系统，但是在评估改进时，了解系统的微妙的人类方面至关重要。</p><p> Did you learn something from this post? I’d love to hear what it was — tweet me  @offlinemark!</p><p> 您从这篇文章中学到了什么吗？我很想听听它是什么-鸣叫我@offlinemark！</p><p> I also have a mailing list if you want to know when I write new posts:</p><p> 如果您想知道何时撰写新帖子，我也有一个邮件列表： </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://offlinemark.com/2020/11/12/double-fetches-scheduling-algorithms-onion-rings/">https://offlinemark.com/2020/11/12/double-fetches-scheduling-algorithms-onion-rings/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/算法/">#算法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/抓取/">#抓取</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fetches/">#fetches</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/订单/">#订单</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>