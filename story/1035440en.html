<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从规范生成WebAssembly 6502仿真器的代码Code-generating a WebAssembly 6502 emulator from specifications</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Code-generating a WebAssembly 6502 emulator from specifications<br/>从规范生成WebAssembly 6502仿真器的代码</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-16 21:29:45</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/58b04e074eebe65efe8bfe26ccb3dc08.png"><img src="http://img2.diglog.com/img/2020/11/58b04e074eebe65efe8bfe26ccb3dc08.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Writing emulators that bring old computer hardware back to life is a popular hobby, and one that I have been enjoying recently through my own goal of writing an Atari 2600 emulator. However, writing a CPU emulator can get a little repetitive and tedious, so I thought I’d explore a different approach - generating the CPU emulation code from a specification rather than manually translating it. This blog post shares the fruitful results.</p><p>编写仿真器使旧的计算机硬件起死回生是一种流行的爱好，我最近通过自己的目标--编写一款Atari 2600仿真器--一直在享受这一爱好。然而，编写CPU仿真器可能会有些重复和乏味，所以我想我应该探索一种不同的方法-从规范生成CPU仿真代码，而不是手动转换它。这篇博文分享了丰硕的成果。</p><p>  The Atari 2600 was a highly popular console in the late 70s and early 80s, bringing games like Pong, Breakout and Space Invaders into people’s homes. At the time hardware (and notably memory) costs were very high, so in order to create an affordable console, the team behind the 2600 had to get quite creative. To understand just how creative this machine was, I’d highly recommend reading the book  Racing the Beam - the 2600 had so little memory that it didn’t have a conventional video RAM (a region of memory mapped direct to the screen), instead the various registers that effect the ‘pixels’ of the image were updated as the TV scanned each frame!</p><p>雅达利2600在70年代末和80年代初是一款非常受欢迎的游戏机，将乒乓球、越狱和太空入侵者等游戏带入了人们的家中。当时硬件(特别是内存)的成本非常高，所以为了制造出一款价格合理的游戏机，2600的研发团队不得不变得相当有创意。要了解这台机器到底有多有创意，我强烈推荐你读一读《竞速光束》一书--2600的内存如此之少，以至于它没有传统的视频RAM(一块直接映射到屏幕上的内存区域)，而是在电视扫描每一帧时更新了影响图像‘像素’的各种寄存器！</p><p> Since reading this book I’ve always wanted to have a go at emulating a 2600 in order to learn more about its hardware, and a few months back I embarked on this journey.</p><p>自从读了这本书后，我一直想尝试模仿2600，以便更多地了解它的硬件，几个月前我就开始了这段旅程。</p><p> I decided to write the emulator using  AssemblyScript, a TypeScript-derived language that compiles to WebAssembly since it has been a  couple of years since I last tried it out and I am keen to see how it has evolved.</p><p>我决定使用AssemblyScript编写仿真器，这是一种派生于文字脚本的语言，自我上次尝试以来已经有几年时间了，它会编译成WebAssembly，我非常想看看它是如何演变的。</p><p> A fairly standard approach to writing a computer emulator is to ‘build’ the CPU first, then start tackling the hardware that surrounds it. However, my main interest and motivation was to explore how the 2600 ‘races the beam’, more specifically the relationship between the CPU (Central Processing Unit) and the TIA (Television Interface Adapter); so instead I started to build the two in parallel, implementing just enough CPU instructions to support the TIA functions.</p><p>编写计算机模拟器的一个相当标准的方法是首先“构建”CPU，然后开始处理围绕它的硬件。然而，我的主要兴趣和动机是探索2600如何“赛跑光束”，更具体地说是CPU(中央处理器)和TIA(电视接口适配器)之间的关系；因此，我开始并行构建这两个处理器，实现恰好足以支持TIA功能的CPU指令。</p><p> Fortunately there is a lot of great documentation available for this console, most notably the book  Atari 2600 Programming for Newbies. I have been reading that book chapter-by-chapter, implementing the emulator features I need to support each example in turn.</p><p>幸运的是，这个控制台上有很多很棒的文档，其中最著名的是面向新手的《Atari 2600编程》一书。我一直在逐章阅读这本书，依次实现支持每个示例所需的仿真器功能。</p><p> Here you can see the progression as I’ve implemented the various scanline synchronisation features, background colours and asymmetrical playfield graphics:</p><p>在这里，你可以看到我已经实现了各种扫描线同步功能、背景颜色和不对称的运动场图形：</p><p>   However, I’d reached a stage where it made sense to tackle the 6502 CPU (or more correctly the 6507, the same chip in a smaller package), and implement its instruction set in their entirety, and that is what the blog post primarily focusses on.</p><p>然而，我已经到了一个有意义的阶段，解决6502 CPU(或者更准确地说，6507，一个更小的封装中的相同芯片)，并完整地实现它的指令集，这也是这篇博客文章主要关注的。</p><p> As an aside, if you are planning on having a go at writing your own emulator, the Atari 2600 is not an easy starting point. Most people familiarise themselves with the basic concepts of emulation via the much simpler CHIP-8. I did just that a little while back, writing a  CHIP-8 emulator in Rust.</p><p>顺便说一句，如果你打算尝试编写自己的仿真器，雅达利2600不是一个容易的起点。大多数人通过简单得多的芯片-8来熟悉仿真的基本概念。不久前我就是这么做的，在Rust中编写了一个Chip-8仿真器。</p><p>  The Atari 2600 uses a MOS 6507 as its CPU, a 6502 in a smaller package, cutting costs and reducing the addressable memory range. I started tackling this emulator in exactly the same way that I did with the CHIP-8. Structurally these emulators all look the same; read the next instruction from memory, switch on the opcode, read any associated operands from memory or registers, perform the operation then write to the appropriate location. It’s not a particularly challenging task, however, with the 52 instructions that the 6502 supports it is a little tedious!</p><p>Atari 2600使用MOS 6507作为CPU，在更小的封装中使用6502，从而降低了成本并缩小了可寻址内存范围。我开始处理这个仿真器的方式与我处理芯片8的方式完全相同。从结构上看，这些仿真器看起来都是一样的；从内存中读取下一条指令，打开操作码，从内存或寄存器中读取任何相关的操作数，执行操作，然后写入适当的位置。然而，这并不是一项特别具有挑战性的任务，因为6502支持的52个指令有点单调乏味！</p><p>  I’m using one of the many online reference sources for the  6502 instruction set, this particular one stands out as being quite concise and structured (which matters later on).</p><p>我使用的是6502指令集的众多在线参考资源中的一个，这个特别的资源非常简洁和结构化(这将在后面讨论)。</p><p> Here’s an example instruction,  AND, a bitwise and operation applied to the value currently held in the accumulator (one of the three CPU registers):</p><p>下面是一条指令示例，以及对累加器(三个CPU寄存器之一)中当前保存的值应用的按位AND操作：</p><p> AND AND Memory with Accumulator A &amp; M -&gt; A N Z C I D V + + - - - - addressing assembler opc bytes cyles -------------------------------------------- immediate AND #oper 29 2 2 zeropage AND oper 25 2 3 zeropage,X AND oper,X 35 2 4 absolute AND oper 2D 3 4 absolute,X AND oper,X 3D 3 4* absolute,Y AND oper,Y 39 3 4* (indirect,X) AND (oper,X) 21 2 6 (indirect),Y AND (oper),Y 31 2 5*</p><p>与和存储器与累加器A&A和M-&gt；A N Z C I D V++-寻址汇编程序OPC字节周期-立即数和#oper 29 2 2零位和运算25 2 3零位，X和oper，X 35 2 4绝对值和op 2D 34绝对值，X和op，X 3D 3 4*绝对值，Y和op，Y 39 3 4*。X)21 2 6(间接)，Y和(Opera)，Y 31 2 5*。</p><p>  A pseudocode representation of the operation itself  A &amp; M -&gt; A, read, bitwise-and and assign</p><p>操作本身的伪代码表示A&amp；M-&&gt;A、Read、按位AND和ASSIGN。</p><p>  A mini table, with headings - N Z C I D V, that denotes the effect on the CPUs various status registers. In this case the negative and zero registers are updated based on the result of the operation.</p><p>一个迷你表，标题为-N Z C I D V，表示对CPU各种状态寄存器的影响。在这种情况下，负值和零值寄存器根据操作结果进行更新。</p><p> Below this information is a table that details the various addressing modes that this instruction supports. In each case the operation is the same, however, the source of the operand is different. For example  immediate mode uses the value of the operand directly (i.e. the byte that follows the AND opcode in program memory), whereas the  absolute,X mode operand is a 16-bit address, which is combined with the X register value, giving the address of the value to ‘AND’ with the accumulator.</p><p>此信息下方的表格详细说明了此指令支持的各种寻址模式。在每种情况下，操作都是相同的，但是操作数的来源是不同的。例如，立即模式直接使用操作数的值(即程序存储器中AND操作码后面的字节)，而绝对X模式操作数是一个16位地址，它与X寄存器值相结合，将值的地址提供给累加器的“AND”。</p><p> These various addressing modes require different numbers of reads and writes and as a result they require a different number of clock cycles in order to complete, as detailed in the  cycles columns. Furthermore, the cycles for some instructions may vary depending on the values involved at runtime - in this instance the asterisk  * denotes that an extra cycle is required if a page boundary is crossed. From the perspective of writing an Atari 2600 emulator, getting this right is vital, as these clock cycles elapse the TV ‘beam’ is racing!</p><p>这些不同的寻址模式需要不同数量的读取和写入，因此它们需要不同数量的时钟周期才能完成，如周期列中所述。此外，根据运行时涉及的值，某些指令的周期可能会有所不同-在这种情况下，星号*表示如果跨越页边界，则需要额外的周期。从编写雅达利2600仿真器的角度来看，正确处理这一点是至关重要的，因为这些时钟周期流逝，电视‘光束’正在竞速！</p><p> This specification, which details just one of the 52 instructions, packs in a lot of information, and in my initial implementation resulted in quite a lot of emulation code and associated unit tests.</p><p>该规范只详细说明了52条指令中的一条，包含了大量信息，在我最初的实现中产生了相当多的仿真代码和相关的单元测试。</p><p> After implementing a handful of these I took the obvious step of looking for patterns, both in terms of the specification itself and simple refactoring opportunities in the code I was writing. However, despite trying various techniques (including peeking at other people’s implementations in  JavaScript,  Rust and  C#) I couldn’t find a pattern I was happy with. To be more specific, I couldn’t find a pattern that allowed me to easily determine that my implementation correctly implemented the specification via visual inspection, which frustrated me!</p><p>在实现了几个模式之后，我采取了明显的步骤来寻找模式，无论是从规范本身还是从我正在编写的代码中的简单重构机会来看。然而，尽管尝试了各种技术(包括偷看别人的JavaScript、Rust和C#实现)，我还是找不到我满意的模式。更具体地说，我找不到一种模式可以让我通过视觉检查轻松地确定我的实现是否正确地实现了规范，这让我很沮丧！</p><p> It was at this point that the thought struck me, rather than manually translating the specification into code, this is a process I could automate. My hope was that it would be easier to implement, and be sure of the correctness, of this translation process than to verify the correctness of the emulator implementation. In other words, if the specification is correct, and the translation process is correct and error free, the emulator it generates must be correct also.</p><p>正是在这一点上，我有了这个想法，这是一个我可以自动化的过程，而不是手动将规范转换为代码。我的希望是，与验证仿真器实现的正确性相比，更容易实现并确保此转换过程的正确性。换句话说，如果规范是正确的，并且翻译过程是正确和无错误的，那么它生成的仿真器也一定是正确的。</p><p>  The 6502 specification is a ~600 line text file which is in some senses a Domain Specific Language (DSL), it makes sense to employ a conventional pattern for compiling (or transpiling) this into the CPU emulator implementation. I’ve covered this topic before in an earlier blog post which explores the standard tokeniser-parser-emitter pattern via the  creation of my own language that targets WebAssembly. In this case the ‘language’ is more rigid in structure, and a tokeniser wouldn’t offer much advantage, so here I opted for a simpler two-phase parser-emitter structure.</p><p>6502规范是一个大约600行的文本文件，在某种意义上是一种域特定语言(DSL)，使用常规模式将其编译(或转换)到CPU仿真器实现是有意义的。在之前的一篇博客文章中，我已经讨论过这个主题，该文章通过创建我自己的针对WebAssembly的语言，探索了标准的记号-解析器-发射器(tokeniser-parser-emitter)模式。在这种情况下，“语言”在结构上更加僵化，记号分割器不会提供太多优势，因此在这里我选择了一个更简单的两阶段解析器-发射器结构。</p><p>  The role of the parser is to output the Abstract Syntax Tree (AST). In this context the main purpose of this step is to read the specification and generate an array of instruction objects, each containing the relevant information that describes its function.</p><p>解析器的作用是输出抽象语法树(AST)。在此上下文中，此步骤的主要目的是读取规范并生成指令对象数组，每个指令对象包含描述其功能的相关信息。</p><p> There is nothing terribly notable about the parser implementation, it is 170 lines of TypeScript code which is mostly concerned with string wrangling. You can  view the code on GitHub if you are interested.</p><p>解析器的实现没有什么特别值得注意的，它有170行打字代码，主要与字符串争论有关。如果你感兴趣，可以在GitHub上查看代码。</p><p>  {   &#34;name&#34; :   &#34;AND&#34; ,   &#34;type&#34; :   &#34;assignment&#34; ,   &#34;expression&#34; :   &#34;A &amp; M&#34; ,   &#34;assignee&#34; :   &#34;A&#34; ,   &#34;description&#34; :   &#34;AND Memory with Accumulator&#34; ,   &#34;flags&#34; :   {   &#34;zero&#34; :   &#34;Modified&#34; ,   &#34;negative&#34; :   &#34;Modified&#34;   },   &#34;addressingModes&#34; :   [   {   &#34;opcode&#34; :   &#34;29&#34; ,   &#34;cycles&#34; :   2 ,   &#34;mode&#34; :   &#34;Immediate&#34; ,   &#34;cycleModifier&#34; :   &#34;None&#34;   },   {   &#34;opcode&#34; :   &#34;25&#34; ,   &#34;cycles&#34; :   3 ,   &#34;mode&#34; :   &#34;Zeropage&#34; ,   &#34;cycleModifier&#34; :   &#34;None&#34;   },   {   &#34;opcode&#34; :   &#34;35&#34; ,   &#34;cycles&#34; :   4 ,   &#34;mode&#34; :   &#34;Zeropage,X&#34; ,   &#34;cycleModifier&#34; :   &#34;None&#34;   },   {   &#34;opcode&#34; :   &#34;2D&#34; ,   &#34;cycles&#34; :   4 ,   &#34;mode&#34; :   &#34;Absolute&#34; ,   &#34;cycleModifier&#34; :   &#34;None&#34;   },   {   &#34;opcode&#34; :   &#34;3D&#34; ,   &#34;cycles&#34; :   4 ,   &#34;mode&#34; :   &#34;Absolute,X&#34; ,   &#34;cycleModifier&#34; :   &#34;PageBoundaryCrossed&#34;   },   {   &#34;opcode&#34; :   &#34;39&#34; ,   &#34;cycles&#34; :   4 ,   &#34;mode&#34; :   &#34;Absolute,X&#34; ,   &#34;cycleModifier&#34; :   &#34;PageBoundaryCrossed&#34;   },   ...   ],  }</p><p>{&#34；名称&#34；：&#34；和&#34；，&#34；类型&#34；：&#34；分配&#34；，&#34；表达式&#34；：&#34；A&amp；M&#34；，&#34；受理人&#34；：&#34；A&#34；，&#34；描述&#34；：&#34；和带有累加器&#34；，&#34；标志&#34；：{&#34；零&#34；：&#34；已修改&#34；，&#34；负数&#34；：&#34；已修改&#34；}，&#34；寻址模式&#34；：[{&#34；操作码&#34；：&#34；29&#34；，&#34；周期&#34；：2，&#34；模式&#34；：&#34；立即&#34；，&#34；周期修改器&#34；：&#34；无&#34；}，{&#34；操作码&#34；：&#34；25&#34；，&#34；周期&#34；：3，&#34；模式&#34；：&#34；Zeropage&#34；，&#34；cycleModiizer&#34；：&#34；None&#34；}，{&#34；opcode&#34；：&#34；35&#34；，&#34；Cycle&#34；：4，&#34；模式&#34；：&#34；Zeropage，X&#34；，&#34；cycleModiizer&#34；：&#34；None&#34；}，{&#34；操作码&#34；：&#34；2D&#34；，&#34；周期&#34；：4，&#34；模式&#34；：&#34；绝对&#34；，&#34；周期修改器&#34；：&#34；无&#34；}，{&#34；操作码&#34；：&#34；3D&#34；，&#34；Cycle&#34；：4，&#34；模式&#34；：&#34；绝对，X&#34；，&#34；周期修饰符&#34；：&#34；页面边界交叉&#34；}，{&#34；操作码&#34；：&#34；39&#34；，&#34；Cycle&#34；：4，&#34；模式&#34；：&#34；绝对，X&#34；，&#34；周期修饰符&#34；：&#34；页面边界交叉&#34；}，...]，}</p><p> An important element to note is the  type property, which in this case is  assignment. The parser identifies the instruction type, other examples include  branch and  test, which broadly describes the type of operation this instruction represents and as a result the ‘shape’ of the code that is generated.</p><p>需要注意的一个重要元素是type属性，在本例中是赋值。解析器识别指令类型，其他示例包括分支和测试，它大致描述了该指令表示的操作类型，并因此描述了生成的代码的“形状”。</p><p> Also, the  expression property in this case has the value  A &amp; M. I  could have also parsed these expressions into a nested AST, however the expressions are so trivial that this wouldn’t have added much value.</p><p>此外，本例中的Expression属性的值为A&amp；M。我也可以将这些表达式解析为嵌套的AST，但是这些表达式太琐碎了，因此不会增加太多价值。</p><p>  The generator / emitter takes the AST output from the parser and generates the resultant emulator code, which in this case is written in AssemblyScript.</p><p>生成器/发射器从解析器获取AST输出，并生成生成的仿真器代码，在本例中，该代码是用AssemblyScript编写的。</p><p>  const  generateInstruction  =  ( instruction :  Instruction )  =&gt;  instruction . addressingModes  . map ( address  =&gt;  {  switch  ( instruction . type )  {  case  &#34; assignment &#34; :  return  generateAssignment ( instruction ,  address );  case  &#34; branch &#34; :  return  generateBranch ( instruction ,  address );  case  &#34; test &#34; :  return  generateTest ( instruction ,  address );  case  &#34; empty &#34; :  return  generateEmpty ( instruction ,  address );  case  &#34; jump &#34; :  return  generateJump ( instruction ,  address );  case  &#34; push &#34; :  return  generatePush ( instruction ,  address );  case  &#34; pop &#34; :  return  generatePop ( instruction ,  address );  }  })  . join ( &#34; \n &#34; );</p><p>Const GenerateInstructions=(指令：指令)=&gt；指令。地址模式。MAP(地址=&&gt;；{开关(指令。Type){case&#34；Assignment&#34；：Return GenerateAssignment(指令，地址)；Case&#34；Branch&#34；：return GenerateBranch(指令，地址)；case&#34；test&#34；：return GenerateTest(指令，地址)；case&#34；Empty&#34；：return GenerateEmpty(指令，地址)；case&#34；Jump&#34；：return GenerateJump(指令，地址)；case&#34；Push&#34；：return GeneratePush(指令，地址)；case&#34；POP&#34；：return GeneratePop(Instruction，Address)；}})。加入(&#34；\n&#34；)；</p><p> This iterates over each of the addressing modes for the instruction, invoking a generator based on the instruction type.</p><p>这将遍历指令的每种寻址模式，根据指令类型调用生成器。</p><p> Here’s an example generator, in this case for the  assignment type following the example of the  AND instruction:</p><p>下面是一个示例生成器，在本例中，赋值类型遵循AND指令的示例：</p><p> const  generateAssignment  =  (  instruction :  AssignmentInstruction ,  address :  AddressingMode )  =&gt;  ` case 0x ${ address . opcode } : /*  ${ instruction . name }  */ {  ${ applyAddressingMode ( address . mode )}  const result: u16 =  ${ replaceRegisters ( instruction . expression )} ;  ${ setFlags ( instruction . flags )}   ${ assignValue ( instruction . assignee ,  address . mode )}   ${ handleCycles ( address )} ; } break;` ;</p><p>Const GenerateAssignment=(指令：AssignmentInstructions，地址：AddressingMode)=&gt；`案例0x${地址。操作码}：/*${指令。名称}*/{${applyAddressingMode(地址。模式)}常量结果：U16=${replaceRegisters(指令。表达式)}；${setFlags(指令。标志)}${assignValue(指令。受让人，地址。模式)}${handleCycle(地址)}；}Break；`；</p><p> This code generates the required  case statement for this specific opcode (a combination of instruction and addressing mode). The body of the code ‘applies’ the addressing mode to locate the operand value, performs a simple transformation of the expression,  A &amp; M, sets status flags, assigns the resultant value and updates the remaining clock cycles. If you’re interested in the detail of any of these functions,  take a look at the sourcecode.</p><p>此代码为该特定操作码(指令和寻址模式的组合)生成所需的CASE语句。代码体‘应用’寻址模式来定位操作数值，执行表达式A&amp；M的简单转换，设置状态标志，分配结果值并更新剩余时钟周期。如果您对这些函数的任何细节感兴趣，请查看源代码。</p><p> Let’s take a look at the output for the  Zeropage,X addressing mode for the  AND instruction:</p><p>让我们看一下AND指令的Zeropage，X寻址模式的输出：</p><p> case  0x35 :  /* AND */  {  const  addr  =  ( this . memory . read ( this . pc ++ )  +  this . xRegister )  &amp;  0xff ;  const  memval :  u16  =  this . memory . read ( addr );  const  result :  u16  =  this . accumulator  &amp;  memval ;  this . statusRegister . zero  =  u8 ( result  ===  0 );  this . statusRegister . negative  =  u8 ( result  !==  0 );  this . accumulator  =  ( result  &amp;  0xff )  as  u8 ;  this . cyclesRemaining  =  3 ;  }  break ;</p><p>案例0x35：/*and*/{const addr=(this.。记忆。读一下(这个。)。PC++)+这个。XRegister)&amp；0xff；常量记忆：U16=此。记忆。Read(Addr)；常量结果：U16=this。累加器&amp；Memval；这个。状态寄存器。ZERO=U8(结果==0)；这。状态寄存器。负=U8(结果！==0)；这。累加器=(Result&amp；0xff)AS U8；这。周期剩余=3；}中断；</p><p> If you refer back to the original specification you can see that it performs the required AND operation, correctly sets the zero and negative status flags, and finally updates the remaining number of cycles.</p><p>如果您重新参考原始规范，您会发现它执行了所需的AND运算，正确地设置了零和负状态标志，最后更新了剩余的周期数。</p><p>  With this code generation approach, a 170 line parser and a 270 line generator I was able to generate a 6502 emulator direct from specification. Take a look at the  1,995 line generated file if you’re interested. I have much more confidence in its correctness than if I had manually implemented it from specification - and had much more fun too!</p><p>使用这种代码生成方法，170行解析器和270行生成器能够直接从规范生成6502仿真器。如果您感兴趣，请看一下1,995行生成的文件。与从规范中手动实现它相比，我对它的正确性更有信心--也得到了更多的乐趣！</p><p> I’ve read a number of articles on emulation, and the 6502 spcifically, but haven’t yet seen anyone else taking this approach. I feel certain it has been done before, however, it is fair to say that most people just get their ‘heads down’ and churn out their emulator manually.</p><p>我已经阅读了很多关于仿真和6502的文章，但还没有看到其他人采用这种方法。我确信以前已经有人这么做了，然而，公平地说，大多数人只是“埋头苦干”，手工制作他们的仿真器。</p><p> Now that my 6502 is complete, I can start tackling some more interesting Atari 2600 features. Sprites are next on my list. However, as the 6502 is the core of the BBC Micro (my first home computer), the NES, C64 and a great many other computers and consoles I could easily get distracted!!!</p><p>现在我的6502已经完成了，我可以开始处理一些更有趣的雅达利2600功能了。精灵是我的下一个目标。然而，由于6502是BBC Micro(我的第一台家用电脑)、NES、C64和许多其他电脑和游戏机的核心，我很容易分心！</p><p>  I am Technology Director at Scott Logic and am a prolific technical author, blogger and speaker on a range of technologies.</p><p>我是Scott Logic的技术总监，是一位多产的技术作家、博客作者和演讲者。</p><p> My blog includes posts on a wide range of topics, including WebAssembly, HTML5 / JavaScript and data visualisation with D3 and  d3fc. You&#39;ll also find a whole host of posts about previous technology interests including iOS, Swift, WPF and Silverlight.</p><p>我的博客包含了很多主题的帖子，包括WebAssembly、HTML5/JavaScript以及D3和D3FC的数据可视化。你还可以找到一大堆关于以前对技术感兴趣的帖子，包括iOS、SWIFT、WPF和Silverlight。</p><p> I&#39;m board member of  FINOS, which is encouraging open source collaboration in the financial sector. I&#39;m also  very active on GitHub, contributing to a number of different projects.</p><p>我是Finos的董事会成员，该组织鼓励金融领域的开源合作。我在GitHub上也非常活跃，为许多不同的项目做出了贡献。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.scottlogic.com/2020/08/26/codegen-6502-webassembly.html">https://blog.scottlogic.com/2020/08/26/codegen-6502-webassembly.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/生成/">#生成</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>