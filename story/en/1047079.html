<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Raspberry Pi的开源AirPlay镜像服务器 An open-source AirPlay mirroring server for the Raspberry Pi</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">An open-source AirPlay mirroring server for the Raspberry Pi<br/>Raspberry Pi的开源AirPlay镜像服务器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-06 19:49:01</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/3a3fec980a373a6fd8e4b4395bde9953.png"><img src="http://img2.diglog.com/img/2021/2/3a3fec980a373a6fd8e4b4395bde9953.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>An open-source implementation of an AirPlay mirroring server for the Raspberry Pi.The goal is to make it run smoothly even on a Raspberry Pi Zero.</p><p>Raspberry Pi的AirPlay镜像服务器的开源实现，目的是使其即使在Raspberry Pi Zero上也能平稳运行。</p><p>  Screen mirroring and audio works for iOS 9 or newer. Recent macOS versions also seem to be compatible. The GPU is used for decoding the h264 video stream. The Pi has no hardware acceleration for audio (AirPlay mirroring uses AAC), so the FDK-AAC decoder is used for that.</p><p>  屏幕镜像和音频适用于iOS 9或更高版本。最新的macOS版本似乎也兼容。 GPU用于解码h264视频流。 Pi没有音频的硬件加速（AirPlay镜像使用AAC），因此使用FDK-AAC解码器。</p><p> Both audio and video work fine on a Raspberry Pi 3B+ and a Raspberry Pi Zero, though playback is a bit smoother on the 3B+.</p><p> 音频和视频在Raspberry Pi 3B +和Raspberry Pi Zero上都可以正常工作，尽管在3B +上回放更流畅。</p><p>  Make sure no other demanding tasks are running (this is particularly important for audio on the Pi Zero)</p><p>  确保没有其他苛刻的任务正在运行（这对于Pi Zero上的音频尤为重要）</p><p> By using OpenSSL for AES decryption, I was able to speed up the decryption of video packets from up to 0.2 seconds to up to 0.007 seconds for large packets (On the Pi Zero). Average is now more like 0.002 seconds.</p><p> 通过使用OpenSSL进行AES解密，我可以将视频数据包的解密速度从大的数据包的0.2秒提高到0.007秒（在Pi Zero上）。现在平均更像是0.002秒。</p><p>  RPiPlay might not be suitable for remote video playback, as it lacks a dedicated component for that: It seems like AirPlay on an AppleTV effectively runs a web server on the device and sends the URL to the AppleTV, thus avoiding the re-encoding of the video.For rough details, refer to the (mostly obsolete)  inofficial AirPlay specification.</p><p>  RPiPlay可能不适合用于远程视频播放，因为它缺少专用的组件：AppleTV上的AirPlay似乎有效地在设备上运行了Web服务器并将URL发送到AppleTV，从而避免了对RPiPlay的重新编码。有关详细信息，请参阅（大多数已过时的）官方AirPlay规范。</p><p>      For building on a fresh Raspbian Stretch or Buster install, these steps should be run:</p><p>      为了在全新的Raspbian Stretch或Buster安装上进行构建，应运行以下步骤： </p><p> sudo apt-get install cmakesudo apt-get install libavahi-compat-libdnssd-devsudo apt-get install libplist-devsudo apt-get install libssl-devmkdir build cd buildcmake ..make</p><p>sudo apt-get install cmakesudo apt-get install libavahi-compat-libdnssd-devsudo apt-get install libplist-devsudo apt-get install libssl-devmkdir build cd buildcmake ..make</p><p>     sudo apt-get install cmake libavahi-compat-libdnssd-dev libplist-dev libssl-dev \ libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev gstreamer1.0-libav \ gstreamer1.0-vaapi gstreamer1.0-plugins-badmkdir build cd buildcmake ..make</p><p>     sudo apt-get install cmake libavahi-compat-libdnssd-dev libplist-dev libssl-dev \ libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev gstreamer1.0-libav \ gstreamer1.0-vaapi gstreamer1.0-plugins -badmkdir构建cd buildcmake ..make</p><p>  sudo dnf install cmake avahi-compat-libdns_sd-devel libplist-devel openssl-devel \ gstreamer1-plugins-base-devel gstreamer1-libav gstreamer1-vaapi \ gstreamer1-plugins-bad-freemkdir build cd buildcmake ..make</p><p>  sudo dnf install cmake avahi-compat-libdns_sd-devel libplist-devel openssl-devel \ gstreamer1-plugins-base-devel gstreamer1-libav gstreamer1-vaapi \ gstreamer1-plugins-bad-freemkdir build cd buildcmake ..make</p><p> Note: The -b, -r, -l, and -a options are not supported with the gstreamer renderer.</p><p> 注意：gstreamer渲染器不支持-b，-r，-l和-a选项。</p><p>  After building, to install the executable on the system permanently (so it can be run from anywhere), simply run the following command:</p><p>  构建之后，要在系统上永久安装可执行文件（以便可以在任何地方运行），只需运行以下命令：</p><p>   Start the rpiplay executable and an AirPlay mirror target device will appear in the network.At the moment, these options are implemented:</p><p>   启动rpiplay可执行文件，AirPlay镜像目标设备将出现在网络中。目前，这些选项已实现：</p><p>     -l: Enables low-latency mode. Low-latency mode reduces latency by effectively rendering audio and video frames as soon as they are received, ignoring the associated timestamps. As a side effect, playback will be choppy and audio-video sync will be noticably off.</p><p>     -l：启用低延迟模式。低延迟模式通过在接收到音频和视频帧后立即有效地渲染它们而忽略了相关的时间戳，从而减少了延迟。副作用是，播放会断断续续，音频视频同步会明显关闭。 </p><p>       All the resources in this repository are written using only freely available information from the internet. The code and related resources are meant for educational purposes only. It is the responsibility of the user to make sure all local laws are adhered to.</p><p>此存储库中的所有资源仅使用来自Internet的免费可用信息来编写。该代码和相关资源仅用于教育目的。用户有责任确保遵守所有当地法律。</p><p> This project makes use of a third-party GPL library for handling FairPlay. The legal status of that library is unclear. Should you be a representative of Apple and have any objections against the legality of the library and its use in this project, please contact me and I&#39;ll take the appropriate steps.</p><p> 该项目利用第三方GPL库来处理FairPlay。该图书馆的法律地位尚不清楚。如果您是Apple的代表，并且对该库的合法性及其在本项目中的使用有任何异议，请与我联系，我将采取适当的措施。</p><p> Given the large number of third-party AirPlay receivers (mostly closed-source) available for purchase, it is my understanding that an open source implementation of the same functionality wouldn&#39;t violate any of Apple&#39;s rights either.</p><p> 鉴于有大量可供购买的第三方AirPlay接收器（大多是封闭源），据我了解，具有相同功能的开源实现也不会侵犯任何Apple的权利。</p><p>  The code in this repository accumulated from various sources over time. Here is my attempt at listing the various authors and the components they created:</p><p>  随着时间的推移，此存储库中的代码是从各种来源累积的。这是我尝试列出各种作者及其创建的组件的尝试：</p><p> dsafa22: Created an  AirPlay 2 mirroring server(seems gone now) for Android based on ShairPlay. This project is basically a port of dsafa22&#39;s code to the Raspberry Pi, utilizing OpenMAX and OpenSSL for better performance on the Pi. All code in  lib/ concerning mirroring is dsafa22&#39;s work. License: GNU LGPLv2.1+</p><p> dsafa22：基于ShairPlay为Android创建了AirPlay 2镜像服务器（现在似乎消失了）。这个项目基本上是dsafa22代码到Raspberry Pi的移植，利用OpenMAX和OpenSSL在Pi上获得更好的性能。 lib /中所有有关镜像的代码都是dsafa22的工作。许可证：GNU LGPLv2.1 +</p><p> Juho Vähä-Herttua and contributors: Created an AirPlay audio server called  ShairPlay, including support for Fairplay based on PlayFair. Most of the code in  lib/ originally stems from this project. License: GNU LGPLv2.1+</p><p> JuhoVähä-Herttua及其贡献者：创建了一个名为ShairPlay的AirPlay音频服务器，包括对基于PlayFair的Fairplay的支持。 lib /中的大多数代码最初都来自此项目。许可证：GNU LGPLv2.1 +</p><p> EstebanKubata: Created a FairPlay library called  PlayFair. Located in the  lib/playfair folder. License: GNU GPL</p><p> EstebanKubata：创建了一个名为PlayFair的FairPlay库。位于lib / playfair文件夹中。许可证：GNU GPL </p><p> Joyent, Inc and contributors: Created an http library called  llhttp. Located at  lib/llhttp/. License: MIT</p><p>Joyent，Inc和贡献者：创建了一个名为llhttp的http库。位于lib / llhttp /。执照：麻省理工学院</p><p> Team XBMC: Managed to show a black background for OpenMAX video rendering. This code is used in the video renderer. License: GNU GPL</p><p> XBMC小组：设法为OpenMAX视频渲染显示黑色背景。该代码在视频渲染器中使用。许可证：GNU GPL</p><p> Alex Izvorski and contributors: Wrote  h264bitstream, a library for manipulation h264 streams. Used for reducing delay in the Raspberry Pi video pipeline. Located in the  renderers/h264-bitstream folder. License: GNU LGPLv2.1</p><p> Alex Izvorski和贡献者：编写了h264bitstream，一个用于处理h264流的库。用于减少Raspberry Pi视频管道中的延迟。位于renderers / h264-bitstream文件夹中。许可证：GNU LGPLv2.1</p><p>  I&#39;m afraid I won&#39;t have time to regularly maintain this project. Instead, I&#39;m hoping this project can be improved in a community effort. I&#39;ll fix and add as much as I need for personal use, and I count on you to do the same!</p><p>  恐怕我没有时间定期维护此项目。相反，我希望可以通过社区的努力来改善这个项目。我会根据个人需要修复和添加尽可能多的东西，并且我希望您也可以这样做！</p><p>        Now audio and video work on Raspberry Pi Zero. I don&#39;t know what exactly did the trick, but static compilation seems to have helped.</p><p>        现在，音频和视频可以在Raspberry Pi Zero上运行。我不知道该技巧到底做了什么，但是静态编译似乎有所帮助。</p><p>  For multiple reasons, it&#39;s very difficult to clearly define the protocol names and versions of the components that make up the AirPlay streaming system. In fact, it seems like the AirPlay version number used for marketing differs from that used in the actual implementation. In order to tidy up this whole mess a bit, I did a little research that I&#39;d like to summarize here:</p><p>  由于多种原因，要明确定义组成AirPlay流系统的组件的协议名称和版本非常困难。实际上，用于市场营销的AirPlay版本号似乎与实际实施中使用的版本号不同。为了稍微整理一下整个混乱情况，我做了一些研究，想在此总结一下：</p><p> The very origin of the AirPlay protocol suite was launched as AirTunes sometime around 2004. It allowed to stream audio from iTunes to an AirPort Express station. Internally, the name of the protocol that was used was RAOP, or Remote Audio Output Protocol. It seems already back then, the protocol involved AES encryption. A public key was needed for encrypting the audio sent to an AirPort Express, and the private key was needed for receiving the protocol (ie used in the AirPort Express to decrypt the stream). Already in 2004, the public key was reverse-engineered, so that  third-party sender applications were developed.</p><p> AirPlay协议套件的真正起源是在2004年左右的某个时候作为AirTunes推出的。它允许将音频从iTunes流传输到AirPort Express电台。在内部，使用的协议名称为RAOP或远程音频输出协议。似乎早在那时，该协议就涉及AES加密。需要一个公共密钥来加密发送到AirPort Express的音频，并需要私有密钥来接收协议（即，在AirPort Express中用于解密流）。早在2004年，对公钥进行了逆向工程，因此开发了第三方发件人应用程序。 </p><p> Some time  around 2008, the protocol was revised and named AirTunes 2. It seems the changes primarily concerned timing. By 2009, the new protocol was  reverse-engineered and documented.</p><p>大约在2008年的某个时候，该协议进行了修订，并命名为AirTunes2。似乎更改主要涉及时间安排。到2009年，对新协议进行了逆向工程并记录了下来。</p><p> When the Apple TV 2nd generation was introduced in 2010, it received support for the AirTunes protocol. However, because this device allowed playback of visual content, the protocol was extended and renamed AirPlay. It was now possible to stream photo slideshows and videos. Shortly after the release of the Apple TV 2nd generation, AirPlay support for iOS was included in the iOS 4.2 update. It seems like at that point, the audio stream was still actually using the same AirTunes 2 protocol as described above. The video and photo streams were added as a whole new protocol based on HTTP, pretty much independent from the audio stream. Soon, the first curious developers began to  investigate how it worked. Their conclusion was that visual content is streamed unencrypted.</p><p> 当Apple TV第二代于2010年推出时，它获得了对AirTunes协议的支持。但是，由于此设备允许播放视觉内容，因此该协议得到了扩展，并重命名为AirPlay。现在可以流式传输照片幻灯片和视频。在第二代Apple TV发行后不久，iOS 4.2更新中包括了对iOS的AirPlay支持。似乎到那时，音频流实际上仍在使用与上述相同的AirTunes 2协议。视频和照片流是作为基于HTTP的全新协议添加的，与音频流几乎没有关系。很快，第一批好奇的开发人员开始研究它是如何工作的。他们的结论是视觉内容未经加密就流化了。</p><p> In April 2011, a talented hacker  extracted the AirPlay private key from an AirPort Express. This meant that finally, third-party developers were able to also build AirPlay reveiver (server) programs.</p><p> 2011年4月，一位才华横溢的黑客从AirPort Express中提取了AirPlay私钥。最终，这意味着第三方开发人员也可以构建AirPlay接收程序（服务器）程序。</p><p> For iOS 5, released in 2011, Apple added a new protocol to the AirPlay suite: AirPlay mirroring.  Initial investigators found this new protocol used encryption in order to protect the transferred video data.</p><p> 对于2011年发布的iOS 5，Apple向AirPlay套件添加了新协议：AirPlay镜像。最初的研究人员发现，此新协议使用加密功能来保护传输的视频数据。</p><p> By 2012, most of AirPlay&#39;s protocols had been reverse-engineered and  documented. At this point, audio still used the AirTunes 2 protocol from around 2008, video, photos and mirroring still used their respective protocols in an unmodified form, so you could still speak of AirPlay 1 (building upon AirTunes 2). The Airplay server running on the Apple TV reported as version 130. The setup of AirPlay mirroring used the xml format, in particular a stream.xml file.Additionally, it seems like the actual audio data is using the ALAC codec for audio-only (AirTunes 2) streaming and AAC for mirror audio. At least these different formats were used in  later iOS versions.</p><p> 到2012年，大多数AirPlay协议都经过了逆向工程并记录在案。在这一点上，音频仍使用大约2008年左右的AirTunes 2协议，视频，照片和镜像仍以未经修改的形式使用其各自的协议，因此您仍然可以说是AirPlay 1（基于AirTunes 2）。在Apple TV上运行的Airplay服务器报告为版本130。AirPlay镜像的设置使用xml格式，尤其是stream.xml文件。此外，实际音频数据似乎使用ALAC编解码器仅用于音频（ AirTunes 2）流媒体和AAC用于镜像音频。至少在更高的iOS版本中使用了这些不同的格式。</p><p> Sometime before iOS 9, the protocol for mirroring was slightly modified: Instead of the &#34;stream.xml&#34; API endpoint, the same information could also be querried in binary plist form, just by changing the API endpoint to &#34;stream&#34;, without any extension. I wasn&#39;t able to figure out which of these was actually used by what specific client / server versions.</p><p> 在iOS 9之前的某个时间，已略微修改了镜像协议：代替了＆＃34; stream.xml＆＃34; API端点，只需将API端点更改为＆＃34; stream＆＃34 ;，而无需任何扩展，就可以以二进制plist形式查询相同的信息。我无法弄清楚哪个特定的客户端/服务器版本实际使用了其中的哪个。</p><p> For iOS 9, Apple made  considerable changes to the AirPlay protocol in 2015, including audio and mirroring. Apparently, the audio protocol was only slightly modified, and a  minor change restored compatibility. For mirroring, an  additional pairing phase was added to the connection establishment procedure, consisting of pair-setup and pair-verify calls. Seemingly, these were added in order to simplify usage with devices that are connected frequently. Pair-setup is used only the first time an iOS device connects to an AirPlay receiver. The generated cryptographic binding can be used for pair-verify in later sessions. Additionally, the stream / stream.xml endpoint was replaced with the info endpoint (only available as binary plist AFAICT).As of iOS 12, the protocol introduced with iOS 9 was still supported with only slight modifications, albeit as a legacy mode. While iOS 9 used two SETUP calls (one for general connection and mirroring video, and one for audio), iOS 12 legacy mode uses 3 SETUP calls (one for general connection (timing and events), one for mirroring video, one for audio).</p><p> 对于iOS 9，Apple在2015年对AirPlay协议进行了重大更改，包括音频和镜像。显然，音频协议仅稍作修改，而较小的更改恢复了兼容性。为了进行镜像，在连接建立过程中添加了一个附加的配对阶段，该阶段由对建立和对验证呼叫组成。看来，添加这些是为了简化频繁连接的设备的使用。配对设置仅在iOS设备首次连接到AirPlay接收器时使用。生成的加密绑定可用于以后的会话中的配对验证。此外，stream / stream.xml端点已替换为info端点（仅可作为二进制plist AFAICT使用）。从iOS 12开始，仍仅对iOS 9引入的协议进行了少许改动（即使是传统模式）也受支持。 iOS 9使用两个SETUP调用（一个用于常规连接和镜像视频，一个用于音频），而iOS 12旧模式使用3个SETUP调用（一个用于常规连接（定时和事件），一个用于镜像视频，一个用于音频） 。 </p><p> The release of tvOS 10.2 broke many third-party AirPlay sender (client) programs in 2017. The reason was that it was now mandatory to perform device verification via a pin in order to stream content to an Apple TV. The functionality had been in the protocol before, but was not mandatory. Some discussion about the new scheme can be found  here. A full specification of the pairing and authentication protocol was made available on  GitHub. At that point, tvOS 10.2 reported as AirTunes/320.20.</p><p>tvOS 10.2的发布在2017年破坏了许多第三方AirPlay发送器（客户端）程序。原因是现在必须强制通过大头针执行设备验证才能将内容流式传输到Apple TV。该功能以前曾在协议中提供，但不是强制性的。关于新方案的一些讨论可以在这里找到。配对和认证协议的完整规范已在GitHub上提供。当时，tvOS 10.2报告为AirTunes / 320.20。</p><p>  iOS 11.4 added AirPlay 2 in 2018. Although extensively covered by the media, it&#39;s not entirely clear what changes specifically Apple has made protocol-wise.</p><p>  iOS 11.4在2018年添加了AirPlay2。尽管媒体广泛报道了该信息，但尚不清楚苹果在协议方面做出了哪些具体改变。</p><p> From captures of the traffic between an iOS device running iOS 12.2 and an AppleTV running tvOS 12.2.1, one can see that the communication on the main mirroring HTTP connection is encrypted after the initial handshake.This could theoretically be part of the new AirPlay 2 protocol. The AppleTV running tvOS 12.2.1 identifies as AirTunes/380.20.1.When connecting from the same iOS device to an AppleTV 3rd generation (reporting as AirTunes/220.68), the communication is still visible in plain. From the log messages that the iOS device produces when connected to an AppleTV 3rd generation, it becomes apparent that the iOS device is treating this plain protocol as the legacy protocol (as originally introduced with iOS 9). Further research showed that at the moment, all available third-party AirPlay mirroring receivers (servers) are using this legacy protocol, including the open source implementation of dsafa22, which is the base for RPiPlay. Given Apple considers this a legacy protocol, it can be expected to be removed entirely in the future. This means that all third-party AirPlay receivers will have to be updated to the new (fully encrypted) protocol at some point.</p><p> 从捕获的运行iOS 12.2的iOS设备与运行tvOS 12.2.1的AppleTV之间的流量捕获中可以看出，在初始握手之后，主镜像HTTP连接上的通信已加密，这在理论上可能是新AirPlay 2的一部分协议。运行tvOS 12.2.1的AppleTV标识为AirTunes / 380.20.1。从同一iOS设备连接到第三代AppleTV（报告为AirTunes / 220.68）时，仍然可以清晰地看到通信。从iOS设备连接到第三代AppleTV时产生的日志消息中，很明显，iOS设备正在将此简单协议视为旧协议（最初由iOS 9引入）。进一步的研究表明，目前，所有可用的第三方AirPlay镜像接收器（服务器）都在使用此旧协议，包括dsafa22的开源实现，后者是RPiPlay的基础。鉴于Apple认为这是旧版协议，可以预期将来会完全删除它。这意味着所有第三方AirPlay接收器都必须在某个时候更新为新的（完全加密的）协议。</p><p> More specifically, the encryption starts after the pair-verify handshake completed, so the fp-setup handshake is already happening encrypted. Judging from the encryption scheme for AirPlay video (aka HLS Relay), likely two AES GCM 128 ciphers are used on the socket communication (one for sending, one for receiving). However, I have no idea how the keys are derived from the handshake data.</p><p> 更具体地说，加密是在完成对验证握手之后开始的，因此fp-setup握手已经在进行加密了。从AirPlay视频（又名HLS中继）的加密方案来看，套接字通信可能使用两种AES GCM 128密码（一种用于发送，一种用于接收）。但是，我不知道如何从握手数据派生密钥。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/FD-/RPiPlay">https://github.com/FD-/RPiPlay</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/开源/">#开源</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pi/">#pi</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/source/">#source</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/airplay/">#airplay</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>