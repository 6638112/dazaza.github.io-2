<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何拥有代码</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">如何拥有代码</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-07 18:10:50</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/f8aa49dfa5b05dd69bcd9fc030339c08.png"><img src="http://img2.diglog.com/img/2020/11/f8aa49dfa5b05dd69bcd9fc030339c08.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This part two of  how to read a code.In the first post I asked how to make a change to an unknown code base with confidence. Knowing the architecture of itis a necessary but often not sufficient step. You can make changes. But I doubt it&#39;s with confidence.  You now have apassive understanding of it. Passively knowing an application is like having studied a foreign language butnever really spoken it. When you try to speak it you say at best tourist clichés or get stuck working outthe grammar in your head.</p><p>这是如何阅读代码的第二部分。在第一篇文章中，我询问了如何自信地更改未知的代码库。了解ITS的架构是必要的，但通常还不够。您可以进行更改。但我怀疑这是有信心的。你现在对它的理解是消极的。被动地了解一种应用程序就像学习了一门外语，但从来没有真正说过它。当你试着说这句话的时候，你最好是说些旅游老生常谈，否则你的脑子里就会被语法搞糊涂了。</p><p>  Meanwhile your foreign friend smiles, suffers through and eventually leaves. What&#39;smissing? It&#39;s the act of actually doing something. But making changes with confidence requires more than merely runningit and hoping your changes work.</p><p>与此同时，你的外国朋友微笑着，忍受着痛苦，最终离开了。你在笑什么？它是实际做某事的行为。但是，自信地做出改变需要的不仅仅是运行它并希望你的改变奏效。</p><p>  You need to actively make the application your own. So how do you own acode?  I&#39;ll assume you know the rough architecture as outlined in  part 1. There is one more piece ofpassive knowledge we&#39;re missing: an overview of all the states the data can be in. And that is very hard to guess untilyou get it up and running.  When trying my dirty paws on a new piece of software I early on try to get itrunning locally. Not least because of the uneasy feeling that I or it might be doing something naughty if it&#39;s notcontained on my device. Staging environments are fine on paper.</p><p>你需要积极地让这个应用程序成为你自己的应用程序。那么，你是如何拥有Acode的呢？我将假设您了解第1部分中概述的粗略架构。还有一条被动的知识我们还遗漏了：数据可能处于的所有状态的概述。在你启动并运行它之前，很难猜到这一点。当我在一个新软件上尝试我的肮脏爪子时，我会在早期尝试让它在本地运行。尤其是因为我有一种不安的感觉，如果我的设备上没有安装它，我或它可能会做一些淘气的事情。试运行环境在理论上是好的。</p><p>  But production details and services tend to leak intostage and test-environments. Just because you have a stage-environment doesn&#39;t mean the third-party systems you talk todoes. Being able to run the application locally on your machine has many advantages.</p><p>但生产细节和服务往往会泄露到舞台和测试环境中。仅仅因为你有舞台环境，并不意味着你与之交谈的第三方系统也有舞台环境。能够在您的机器上本地运行应用程序有很多优点。</p><p>  The feedback iterationloop will be as fast as you make it. You can insert debug probes, printfs, sniff network traffic, shut down vital partsand watch it burn in the safe comfort of your couch.  It&#39;s your own black-box laboratory for trying to figureit out in the wild.  In the interview book  Coders at work  Brad Fitzpatrick makes a very good comment:&#34;Try to get the damn thing to build. Get over that hurdle. That tends to be the hugest hurdle for most people&#34;.</p><p>反馈迭代循环会和你做的一样快。你可以插入调试探头，打印文件，嗅探网络流量，关闭重要部件，然后在舒适的沙发上看着它燃烧。这是你自己的黑匣子实验室，因为你试图在野外找出答案。布拉德·菲茨帕特里克(Brad Fitzpatrick)在《工作中的程序员》(The Coders At Work)一书中做出了非常好的评论：试着把这该死的东西造出来。跨过那道坎。对于大多数人来说，这往往是最大的障碍。</p><p>  Sincemore languages today are interpreted: let&#39;s make that into running the software. This is the goal of compiling softwareanyway. It&#39;s very correct that getting it to run is the &#34;hugest&#34; hurdle. There will be dependencies. Therewill be proxies and firewalls.</p><p>因为现在更多的语言都是翻译的：让我们把这一点应用到软件的运行中吧。无论如何，这就是编译软件的目标。让它跑起来是最大的障碍，这是非常正确的。将会有依赖关系。将会有代理和防火墙。</p><p>  There will be things that the active developers forgot they did once they started or gotonboarded on the project. Small config and dotfiles-files stashed deep into their home folder no one remembers puttingthere.</p><p>活跃的开发人员一旦开始或加入这个项目，就会有一些忘记做的事情。小配置和点文件--这些文件隐藏在他们的主文件夹深处，没有人记得放在那里。</p><p>  I fully expect to spend a day or two just getting one application to run when first getting into a new projectbecause of this. The process often involves someone showing you at a rapid pace:</p><p>正因为如此，当我第一次进入一个新的项目时，我完全希望花一两天的时间来运行一个应用程序。这个过程通常需要有人快速地向你展示：</p><p>  &#34;Oh, you need this credential. Then of course you need to comment out these lines. And oh, wait - Bob knows where you need to get credentials for the proxy talking to the backend-system&#34;. Ad nauseum. I try to get these setup sessions done on my machine. If so I usually take screenshots of what we&#39;re doing so I can go back and correct or inspect it at my own pace when the rapid session is over.   If it&#39;s on some other person&#39;s computer I ask the person to take screenshots of what I need to do for the same reasons. Expect to do the walk of shame back a couple of times to ask for details that you missed, didn&#39;t fully understand or they simply forgot to tell you.  This is the problem with experts.</p><p>哦，你需要这张证件。当然，您需要注释掉这些行。哦，等等-Bob知道您需要从哪里获得与后端系统对话的代理的凭据。特别恶心。我尝试在我的机器上完成这些设置会话。如果是这样的话，我通常会对我们正在做的事情截屏，这样当快速会议结束后，我就可以回去按照自己的节奏纠正或检查它。如果它在别人的电脑上，出于同样的原因，我会让他为我需要做的事情截屏。如果你错过了、没有完全理解或者他们只是忘了告诉你的细节，你可能会羞愧地问几次。这就是专家的问题所在。</p><p>  They know so much they forget how little the new person knows. All acronyms and TLA:s have a deep visceral meaning for them whereas for the new guy they are just weird terms thrown around.   But! Running it locally the first time comes with it&#39;s perils. You need to stop it from doing any harmful operations to the outside world. The application might be transferring money out of some account, deleting a database or calling your mother telling her about what you did on that summer camp way back.</p><p>他们知道的太多了，以至于忘记了新人知道的有多少。所有的缩略语和TLA：对他们来说都有深刻的内在含义，而对于新来的人来说，它们只是被抛来抛去的奇怪的术语。但!。第一次在当地运行它伴随着它的危险。你需要阻止它对外部世界做任何有害的操作。这个应用程序可能会从某个账户转账，删除数据库，或者打电话给你母亲，告诉她你很久以前在夏令营里做了什么。</p><p>  And we don&#39;t want that.  The network is what will cause harm to any external resources. There are of course dangers of it messing up your own computer but at least that&#39;s locally and at worst just a reinstall of the OS away.</p><p>我们不希望这样。网络是对任何外部资源都会造成损害的东西。当然，搞砸你自己的电脑也有危险，但至少这是本地的，在最坏的情况下，只需重新安装操作系统即可。</p><p> A good way to see if it runs at all after it&#39;s been built is to isolate it in a container environment such as docker without a  network connection. This way you can start it and watch if any network calls are made.</p><p>要查看它在构建后是否还能运行，一个好方法是将它隔离在容器环境中，比如没有网络连接的docker环境中。通过这种方式，您可以启动它并查看是否进行了任何网络调用。</p><p>  Then you can dig in and see if those calls are dangerous operations or not. Visual studio code has a nice effort in  running code in a docker-container so you can run and alter it while internet-less.</p><p>然后你就可以深入调查，看看这些电话是不是危险操作。Visual Studio代码很好地在停靠容器中运行代码，这样您就可以在没有互联网的情况下运行和更改它。</p><p>   Edit: This is a good example of complicating an easy solution. It struck me embarrassingly late (after publication) that you can also do the  two idiots one keyboard trick: pull the network cord. Or bring all the network interfaces down.</p><p>编辑：这是使简单的解决方案复杂化的一个很好的例子。令我尴尬的是(在出版之后)你还可以做两个白痴一样的键盘小把戏：拔下网线。或者关闭所有网络接口。</p><p>   Merely watching it run in a container is usually not that exciting. It might do nothing because you didn&#39;t tell it to. Before running it full-scale I like to take certain key files for a test-spin to see more how they interact when sent certain data.</p><p>仅仅看着它在容器里运行通常并不那么令人兴奋。它可能什么也做不了，因为你没有告诉它去做。在全面运行它之前，我喜欢对某些关键文件进行测试，以了解它们在发送特定数据时如何交互。</p><p>  This is the result of a  maxim I call &#34;insert main&#34;. This approach differs if a file can be executed by itself (as in Javascript) or if there needs to be a single main() method somewhere (as in Java). This usually means if the language is statically typed or not.  Let&#39;s start with the first case: here we find dynamically typed languages such as javascript, python or perl. You are also in luck since dependencies tend to come in the form of objects, dictionaries and are easier to mock out than with a full blown type system.  Simply pick a file. Verify that it does not do something naughty when run, wipe out and external files imported and insert a call to some method you want to exercise. Then run the file standalone. Add back any needed dependencies as needed for the method to not fail.</p><p>这是我称之为插入Main的一条格言的结果。如果文件可以自己执行(比如Javascript)，或者需要在某个地方只有一个main()方法(比如Java)，这种方法就会有所不同。这通常意味着语言是否为静态类型。让我们从第一种情况开始：这里我们找到了动态类型的语言，如Javascript、Python或Perl。您也很幸运，因为依赖项往往以对象、字典的形式出现，而且比使用成熟的类型系统更容易模仿。只需选择一个文件。验证它在运行、清除和导入外部文件时不会做一些淘气的事情，并插入对您想要执行的方法的调用。然后独立运行该文件。根据需要重新添加任何所需的依赖项，以便该方法不会失败。</p><p>  But first verify that the dependencies do not do something naughty themselves first. In statically typed languages it&#39;s usually not possible to have two main functions in the same program.</p><p>但首先要验证依赖项本身不会做一些淘气的事情。在静态类型语言中，通常不可能在同一个程序中有两个主要函数。</p><p>  The main() can be moved to the file you&#39;re interested in but being statically typed this tends to cause a lot of work resolving imports and namespaces. A better approach is to hijack a unit-test which gives you a new &#34;main&#34; to run code via.  Most statically typed languages have unit-testing frameworks and many are built in (as golang does for example). Whip out a unit-test and gut it of any asserts. Then use it as a main() entry where you can exercise methods.  Another approach can be to use a REPL (locally or online such as  repl.it) to cut out small methods or snippets from a bigger file and try them out interactively. There are repls for statically typed languages too.</p><p>Main()可以移到您感兴趣的文件中，但由于是静态键入的，这往往会导致解析导入和名称空间的大量工作。一个更好的方法是劫持一个单元测试，它会给你一个新的运行代码的平台。大多数静态类型语言都有单元测试框架，而且很多都是内置的(例如，Golang就是这样做的)。拿出一个单元测试，去掉所有断言。然后将其用作main()条目，您可以在其中练习方法。另一种方法是使用REPL(本地的或在线的，如repl.it)从较大的文件中剪切出小的方法或片段，并交互地试用它们。静态类型语言也有相应的解决方案。</p><p>   If your application interacts with other systems - which most do - calling these systems are not only dangerous but a big black box in your understanding. What goes over to the other end?</p><p>如果您的应用程序与其他系统交互(大多数系统都是这样做的)，那么调用这些系统不仅很危险，而且在您的理解中是一个巨大的黑匣子。另一端是什么？</p><p>  What responses come back and how do they affect your application in turn?  A really good way of learning how the system interacts with other systems is to build rigs and fakes of the real system it&#39;s calling. At one project I was at we had more or less the entire outside world built into fake mocks that we could interact and control the response they sent.   Build the smallest possible fake system with canned responses and wire up the main application to talk to your local mock instead. I prefer nodejs and the  express framework if it&#39;s http because it takes about 5 lines of code to get started.</p><p>返回的响应是什么？它们又对您的应用程序产生了怎样的影响？了解该系统如何与其他系统交互的一个非常好的方法是构建它所调用的真实系统的钻机和仿制品。在我所在的一个项目中，我们或多或少地将整个外部世界构建成了假的模仿，我们可以互动并控制他们发送的回应。使用预录的响应构建尽可能小的虚假系统，并将主应用程序连接起来与您的本地模拟程序对话。如果NodeJS是http，我更喜欢NodeJS和Express框架，因为它需要大约5行代码才能上手。</p><p>  Now you can dump out what the outgoing request looks like and how the application reacts when it gets different responses back. If you have no idea how the reply looks like - try to record it either via calling it yourself or trying to dump out responses in environments you know are safe to sniff.</p><p>现在，您可以转储传出请求的外观，以及应用程序在收到不同响应时的反应。如果你不知道回复是什么样子的--试着记录下来，要么自己打电话，要么试着在你知道可以安全嗅探的环境中倾倒回复。</p><p>  If not - just type something up and watch the application spit out errors until you get it right. It&#39;s like network driven  TDD.</p><p>如果不是，只需输入一些内容，然后看着应用程序发出错误，直到正确为止。它就像网络驱动的TDD。</p><p> Only seeing the system in full action can give you the whole picture. If the data-type is an integer you still don&#39;t know what the range of the data is. Is it the full range of the integer or does the digits only go from one to eleven?  Here&#39;s the first time I might reach for a debugger. Debuggers are great if you don&#39;t know which path the code is taking. Interfaces, inheritance or and complex conditionals are the usual sources of hard to follow code paths.</p><p>只有看到这个系统全面运转，你才能看到全貌。如果数据类型是整数，您仍然不知道数据的范围是多少。它是整个整数范围，还是数字只从1到11？这是我第一次接触调试器。如果你不知道代码走的是哪条路，调试器是很棒的。接口、继承或复杂条件是代码路径难以遵循的常见来源。</p><p>  Solving a bug that results from some errors several layers deeper than your program a debugger is indispensable.  When trying to understand the state of an application I find debuggers of less value and plain &#39;ole  printfs.</p><p>解决一些错误导致的错误，甚至比你的程序深几层的错误，调试器是必不可少的。当我试图理解一个应用程序的状态时，我发现调试器的价值较低，而且在printfs中很普通。</p><p>  The UI can only show so much of the state and you can&#39;t save it for later (lest you cut and paste). Printfs to the terminal or writing state to disk makes diffing and understanding things more permanent.  Moving away from debuggers and inserting debug code into the real application has another advantage. You can do assertions on expected state to see if you are correct. If this value is something else than the expected digit 11 - print that out. Or crash the program.  This way you can interactively figure out what&#39;s a valid state and how it comes about.   With the application now defused by talking to fake mocks with the internal state known we are ready to make changes. If it wasn&#39;t for human psychology! A mental hurdle to get around is that others&#39; code is somehow holy and cannot be touched.</p><p>用户界面只能显示如此多的状态，您不能将其保存以供以后使用(以免剪切和粘贴)。将文件系统打印到终端或将状态写入磁盘使区分和理解事物更加持久。摆脱调试器，将调试代码插入到实际应用程序中还有另一个好处。您可以对预期状态进行断言，以查看您是否正确。如果此值不是预期数字11，则将其打印出来。否则程序就会崩溃。这样一来，你就可以互动地找出什么是有效状态，以及它是如何产生的。现在，通过与已知内部状态的假模仿对话来解除应用程序的影响，我们已经准备好进行更改。如果不是因为人类心理！那么要绕过的一个心理障碍是，其他人的代码在某种程度上是神圣的，不能被触碰。</p><p>  This is a dangerous notion. You owe it to yourself and to others to try and improve the piece no matter how known and respected the original author(s) are. People grow blind-spots to their own code.</p><p>这是一个危险的想法。不管原创作者多么知名和受人尊敬，你都有责任去尝试和改进这篇文章。很多人对自己的代码视而不见。</p><p>  I do too. Those first few months are valuable for being the outsider that sees these blind-spots. Keep telling yourself that your outside perspective is as valuable (if not more) than the main author(s).   However! Chances are the code you intend to change doesn&#39;t fit your head. Which brings us to another mental hurdle: refactoring. It provides no extra value to stakeholders and you risk stepping on someone&#39;s toes for altering their masterpiece.</p><p>我也是。头几个月很有价值，因为我是看到这些盲点的局外人。不断告诉自己，你的外部观点与主要作者一样有价值(如果不是更高的话)。然而！很可能你想要更改的代码并不适合你。这给我们带来了另一个心理障碍：重构。它不会给利益相关者带来额外的价值，而且你可能会因为修改某人的杰作而踩到他们的脚趾。</p><p>  So what do you do? You do it anyway of course. We&#39;re here to own the application. If the layout in one file doesn&#39;t make sense - move it around until it does. If the names of files, methods or variables are too vague or too specific: change them.</p><p>那你是做什么的？当然，不管怎样，你还是要这么做。我们在这里拥有这款应用程序。如果一个文件中的布局没有意义--移动它，直到它有意义为止。如果文件、方法或变量的名称过于模糊或过于具体：请更改它们。</p><p>  As stated in  part 1 I often carry branches full with comments around from when learning how to read a code. In these branches I highlight (laced in foul words and personal attacks) things that could be improved by refactoring.    I&#39;ve even made it a habit of blocking out time in my calendar to do refactor sessions. I keep a list around during normal work of areas that annoy or irk me (usually the hairiest and ugliest parts of the application).</p><p>如第1部分所述，从学习如何阅读代码开始，我经常随身携带充满注释的分支。在这些分支中，我强调(夹杂着脏话和人身攻击)可以通过重构改进的东西。我甚至已经养成了在日程表上腾出时间进行重构会议的习惯。在正常工作期间，我会列出让我恼火或恼火的地方(通常是应用程序中毛发最多、最丑的部分)。</p><p>  When the refactor-session rolls around I get my list out, pick an area and start fixing it. I got this from a stack overflow response on how to deal with badly written legacy code. Most people would complain and live with it.</p><p>当重构会议结束时，我拿出我的清单，选择一个区域并开始修复它。这是我从一个堆栈溢出响应中得到的，该响应是关于如何处理编写糟糕的遗留代码的。大多数人会抱怨并忍受它。</p><p>  But one illuminating answer said: &#34;The programmer went to work refactoring it. 2 years later it was completely rewritten.&#34; Only when you&#39;ve refactored the code violently can you start calling it your own.</p><p>但有一个很有启发性的答案是：程序员开始对它进行重构。两年后，它被完全重写了。只有当你对代码进行了猛烈的重构后，你才能开始称它为你自己的代码。</p><p>  Or joint custody if there&#39;s others working on it. And by  Conway&#39;s law the things you refactor will one day become yours so pick the parts that interest you the most. It&#39;s a good way to claim some turf.  I&#39;ve noticed most people will appreciate a PR with your thoughts on how to improve the code-base. It&#39;s a discussion-opener with some substance because it&#39;s not only opinion but actual changes to back up that opinion.</p><p>或者共同监护权，如果有其他人在做的话。根据康威定律，你重构的东西总有一天会成为你的，所以选择你最感兴趣的部分。这是一个抢占地盘的好方法。我注意到，大多数人都会喜欢公关，因为你对如何改进代码库有自己的想法。这是一个具有一定实质内容的开场白，因为它不仅是观点，而且是支持这一观点的实际变化。</p><p>   After going through all this you will have run it many times. You will have altered it to fit your head and you know the valid states data can be in. You can now wear the pin saying &#34;Proud code owner&#34; because of all the hard work you&#39;ve put in.</p><p>在经历了这一切之后，你会运行它很多次。你可以根据自己的情况对其进行修改，你也知道数据所在的有效状态。由于你付出的所有努力，你现在可以佩戴写有骄傲代码所有者的别针了。</p><p>  Let&#39;s celebrate with expensive champagne and cute puppies! When your grandchildren ask with starry eyes years from now &#34;why did you do it&#34; you can calmly reply after first taking a sip of that cute puppie:  Yes kids, it&#39;s hard work. Like all good things in life the best stuff doesn&#39;t come easy. And neither did this. I even looked slow in the beginning because of me going through all of this.</p><p>让我们用昂贵的香槟和可爱的小狗来庆祝吧！几年后，当你的孙子孙女满眼星光地问你为什么要这么做时，你可以在第一口喝了一口可爱的小狗之后平静地回答：是的，孩子们，这是一项艰苦的工作。就像生活中所有美好的事物一样，最美好的事物来之不易。这件事也没有。一开始我甚至看起来很慢，因为我经历了这一切。</p><p>  But it paid off. You see, at first my seemingly faster but sloppier colleagues were making changes at breakneck speed. While impressive they were also playing russian roulette. There would be bugs and those would creep into production.</p><p>但它得到了回报。你看，一开始，我那些看起来更快但更马虎的同事们正在以惊人的速度做出改变。令人印象深刻的是，他们还在玩俄罗斯轮盘赌。会有错误，这些错误会悄悄进入生产。</p><p>  Things would eventually break. Fast without being correct means nothing. Nothing! I, on the other hand, after going through all of the steps above knew what I was doing.</p><p>事情最终会破裂。快而不准，什么都不是。没什么!。另一方面，在经历了上述所有步骤之后，我知道自己在做什么。</p><p>  A change made would only do what I expected it to do and nothing else because I knew how to verify it locally. When I got questions on how the application worked I usually knew it by heart, or I could do a quick test to verify my assumptions.</p><p>所做的更改只会做我期望它做的事情，而不会做其他任何事情，因为我知道如何在本地验证它。当我被问到关于应用程序如何工作的问题时，我通常会牢记在心，或者我可以做一个快速测试来验证我的假设。</p><p> But there&#39;s more. That hard work compounds. Yes, the first change was really slow. But the second went faster. And the third. And by the time the tenth change rolled in I would be flying through it.</p><p>但还有更多的原因。这份辛苦的工作让人不知所措。是的，第一个变化真的很慢。但第二次的速度更快。还有第三个。到第十个变化到来的时候，我已经飞快地通过它了。</p><p>  This is because by knowing the code that intimately I could also plan how to verify changes a lot faster and more accurate. I&#39;ve built up an arsenal of verification methods while owning it.  The grandchildren look at you in awe and ponder your nuggets of wisdom while you drift back into sleep, slightly drooling and snoring. But with a smile of confidence and clear conscience.</p><p>这是因为，通过深入了解代码，我还可以计划如何更快、更准确地验证更改。在拥有它的同时，我已经建立了一个验证方法的武器库。孙子孙女们敬畏地看着你，思考着你的智慧金块，而你却微微流着口水，打着呼噜睡着了。但带着自信和问心无愧的微笑。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.iamjonas.me/2020/11/how-to-own-code.html">https://www.iamjonas.me/2020/11/how-to-own-code.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/拥有/">#拥有</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/code/">#code</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033690.html"><img src="http://img2.diglog.com/img/2020/11/thumb_0588ada816e1b2413594f6bfb6f8d351.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033690.html">Vgil：永远保持道德警惕的编程语言</a></div><span class="my_story_list_date">2020-11-7 18:10</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033666.html"><img src="http://img2.diglog.com/img/2020/11/thumb_9222b5228a7e2dd43e62006225cc6c4a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033666.html">Google Photos应用程序中的代码显示，Google将为Google One订户添加新的编辑功能和过滤器</a></div><span class="my_story_list_date">2020-11-7 14:19</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033632.html"><img src="http://img2.diglog.com/img/2020/11/thumb_1c73dcb4e8eef769e2d2e29f3add898a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033632.html">迷失的编程方法：Commodore 64 Basic</a></div><span class="my_story_list_date">2020-11-7 11:19</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033500.html"><img src="http://img2.diglog.com/img/2020/11/thumb_f71e1473a8a167bcdd9af7f1bdbd013f.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033500.html">Tobias Lutke仍在为Shopify编写代码</a></div><span class="my_story_list_date">2020-11-6 9:28</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>