<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>更多MacOS安装程序漏洞 More macOS Installer Flaws</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">More macOS Installer Flaws<br/>更多MacOS安装程序漏洞 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-04 04:12:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/9de304de4f9b8dbaac6f722ba09394b7.png"><img src="http://img2.diglog.com/img/2021/6/9de304de4f9b8dbaac6f722ba09394b7.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Back in  December, we wrote about attacking macOS installers. Over the last couple of months, as my team looked into other targets, we kept an eye on the installers of applications we were using and interacting with regularly. During our research, we noticed yet another of the aforementioned flaws in the Microsoft Teams installer and in the process of auditing it, discovered another generalized flaw with macOS package installers.</p><p>回到12月，我们写了关于攻击麦斯科斯安装者。在过去的几个月里，当我的团队看着其他目标时，我们一直关注我们使用经常使用和互动的应用程序的安装。在我们的研究期间，我们注意到了Microsoft团队安装程序和审计过程中的另一个上述缺陷，发现了麦斯卡套装安装程序的另一个广泛缺陷。</p><p> Frustrated by the prevalence of these issues, we decided to write them up and make separate reports to both Apple and Microsoft. We wrote to Apple to recommend implementing a fix similar to what they did for  CVE-2020–9817 and explained the additional LPE mechanism discovered. We wrote to Microsoft to recommend a fix for the flaw in their installer.</p><p> 令人沮丧的是这些问题的普遍性，我们决定向他们编写并与苹果和微软一起单独报告。我们写信给Apple，建议实施类似于他们为CVE-2020-9817所做的解决方案，并解释了所发现的额外LPE机制。我们写信给Microsoft建议修复其安装程序中的缺陷。</p><p> Both companies have rejected these submissions and suggestions. Below you will find full explanations of these flaws as well as proofs-of-concept that can be integrated into your existing post-exploitation arsenals.</p><p> 两家公司都拒绝了这些提交和建议。您可以找到对这些缺陷的完整解释以及概念证据，可以集成到您现有的开发后武库中。</p><p>  To recap from the previous blog, macOS installers have a variety of convenience features that allow developers to customize the installation process for their applications. Most notable of these features are  preinstall and  postinstall scripts. These are scripts that run before and after the actual application files are copied to their final destination on a given system.</p><p>  要从上一个博客中重新回顾，MacOS安装程序具有各种便利功能，允许开发人员自定义其应用程序的安装过程。最值得注意的是这些功能是预装和PostInstall脚本。这些是在对给定系统上复制到其最终目的地之前和之后运行的脚本。</p><p> If the installer itself requires elevated privileges for any reason, such as setting up a system-level Launch Daemon for an auto-updater service, the installer will prompt the user for permission to elevate privileges to root. There is also the case of unattended installations automatically doing this, but we will not be covering that in this post.</p><p> 如果安装程序本身需要升高的权限，例如设置用于自动updater服务的系统级启动守护程序，则安装程序将提示用户升高到root权限的权限。还有无人值守安装的情况自动执行此操作，但我们不会在这篇文章中覆盖。</p><p> The primary issue being discussed here occurs when these scripts — running as root — read from and write to locations that a normal, lower-privileged user has control over.</p><p> 这里讨论的主要问题是在这些脚本 - 以root身份运行 - 读取和写入正常的，低特权用户控制的位置时发生。</p><p>  In July 2020,  NCC Group posted their advisory for CVE-2020–9817. In this advisory, they discuss an issue where files extracted to Installer Sandbox directories retained the permissions of a lower-privileged user, even when the installer itself was running with root privileges. This means that any local attacker (local for code execution, not necessarily physical access) could modify these files and potentially escalate to root privileges during the installation process.</p><p>  2020年7月，NCC集团发布了CVE-2020-9817的咨询。在此咨询中，他们讨论了一个问题，其中提取到安装程序Sandbox目录的文件保留了较低特权用户的权限，即使安装程序本身以root权限运行。这意味着任何本地攻击者（代码执行本地，不一定是物理访问）都可以在安装过程中修改这些文件并可能升级到root权限。 </p><p> NCC Group conceded that these issues could be mitigated by individual developers, but chose to report the issue to Apple to suggest a more holistic solution. Apple appears to have agreed, provided a fix in  HT211170, and assigned a CVE identifier.</p><p>NCC集团承认，各个开发商可以减轻这些问题，但选择向Apple报告该问题，以建议更全面的解决方案。 Apple似乎已同意，提供了HT211170的修复，并为CVE标识符分配了。</p><p> Apple’s solution was simple: They modified files extracted to an installer sandbox to obtain the permissions of the user the installer is currently running as. This means that lower privileged users would not be able to modify these files during the installation process and influence actions performed by root.</p><p> Apple的解决方案很简单：修改了将文件提取到安装程序沙箱，以获取安装程序当前运行的用户的权限。这意味着较低的特权用户在安装过程中将无法修改这些文件，并影响root执行的操作。</p><p> Similar to the sandbox issue, as noted in our previous blog post, it isn’t uncommon for developers to use other less-secure directories during the installation process. The most common directories we’ve come across that fit this bill are  /tmp and  /Applications, which both have read/write access for standard users.</p><p> 与Sandbox问题类似，如我们之前的博客文章所指出的那样，开发人员在安装过程中使用其他更少安全的目录并不罕见。我们遇到的最常见的目录适用于此账单是/ TMP和/应用程序，这两者都有标准用户的读/写访问。</p><p> Let’s use Microsoft Teams as yet another example of this. During the installation process for Teams, the application contents are moved to  /Applications as normal. The  postinstall script creates a system-level Launch Daemon that points to the TeamsUpdaterDaemon application ( /Applications/Microsoft Teams.app/Contents/TeamsUpdaterDaemon.xpc/Contents/MacOS/TeamsUpdaterDaemon), which will run with root permissions. The issue is that if a local attacker is able to create the  /Applications/Microsoft Teams directory tree prior to installation, they can overwrite the TeamsUpdaterDaemon application with their own custom payload during the installation process, which will be run as a Launch Daemon, and thus give the attacker root permissions. This is possible because while the installation scripts do indeed change the write permissions on this file to root-only, creating this directory tree in advance thwarts this permission change because of the open nature of  /Applications.</p><p> 让我们使用Microsoft团队作为又一个例子。在团队的安装过程中，应用程序内容正常移动到/应用程序。 PostInstall脚本创建一个系统级启动守护程序，该守护程序指向teamsupdaterdaemon应用程序（/ applications / microsoft teams.app/contents/teamsupdaterdaemon.xpc/contents/macos/teamsupdaterdaemon），其将使用root权限运行。问题是，如果本地攻击者能够在安装之前创建/应用程序/ Microsoft团队目录树，则在安装过程中，它们可以使用自己的自定义有效载荷覆盖TeamSupdaterDaemon应用程序，这将作为启动守护程序运行从而给予攻击者根权限。这是可能的，因为安装脚本确实将此文件的写入权限更改为root toot，因此由于/应用程序的开放性质，提前创建此目录树。</p><p>  # Prep Steps Before Installing /tmp ❯❯❯ mkdir -p “/Applications/Microsoft Teams.app/Contents/TeamsUpdaterDaemon.xpc/Contents/MacOS/” # Just before installing, have this running. Inelegant, but it works for demonstration purposes. # Payload can be whatever. It won’t spawn a GUI, though, so a custom dropper or other application would be necessary. /tmp ❯❯❯ while true; do ln -f -F -s /tmp/payload “/Applications/Microsoft Teams.app/Contents/TeamsUpdaterDaemon.xpc/Contents/MacOS/TeamsUpdaterDaemon”; done # Run installer. Wait for the TeamUpdaterDaemon to be called.</p><p>  ＃准备步骤在安装/ tmp❯❯❯mkdir -p之前“/ applications / microsoft teams.app/contents/teamsupdaterdaemon.xpc/contents/macos/”＃就在安装之前，使这个正在运行。 Itegartant，但它适用于示范目的。 ＃有效载荷可以是什么。但是，它不会产生一个GUI，所以需要自定义滴管或其他应用程序。 / tmp❯❯❯真实; do ln -f -f-s / tmp / payload“/ applications / microsoft teams.app/contents/teamsupdaterdaemon.xpc/contents/macos/teamsupdaterdaemon”;完成＃运行安装程序。等待队伍DaterDaemon被召唤。</p><p> The above creates a symlink to an arbitrary payload at the file path used in the  postinstall script to create the Launch Daemon. During the installation process, this directory is owned by the lower-privileged user, meaning they can modify the files placed here for a short period of time before the installation scripts change the permissions to allow only root to modify them.</p><p> 以上在PostInstall脚本中使用的文件路径中的任意有效载荷创建了一个符号链接以创建启动守护程序。在安装过程中，此目录由较低特权用户拥有，这意味着在安装脚本更改权限以仅允许root来修改它们之前，它们可以修改此处的文件短段。</p><p> In our report to Microsoft, we recommended verifying the integrity of the TeamsUpdaterDaemon prior to creating the Launch Daemon entry or using the  preinstall script to verify permissions on the  /Applications/Microsoft Teams directory.</p><p> 在我们向Microsoft的报告中，我们建议在创建启动守护程序条目或使用预安装脚本之前验证TeamSupdaterDaemon的完整性以验证/应用程序/ Microsoft团队目录上的权限。 </p><p> The Microsoft Teams vulnerability triage team has been met with criticism over their handling of vulnerability disclosures these last couple of years. We’d expected that their recent inclusion in Pwn2Own showcased vast improvements in this area, but unfortunately, their communications in this disclosure as well as other disclosures we’ve recently made regarding their products demonstrate that this is not the case.</p><p>Microsoft团队漏洞分类团队在过去几年的漏洞披露的漏洞中得到了批评。我们预计他们最近的纳入PWN2OWN展示了这一领域的巨大改进，但遗憾的是，他们在本公开中的通信以及我们最近对其产品的其他披露表明这并非如此。</p><p>    In response to our disclosure report, Microsoft stated that this was a non-issue because  /Applications requires root privileges to write to. We pointed out that this was not true and that if it was, it would mean the installation of any application would require elevated privileges, which is clearly not the case.</p><p>    根据我们的披露报告，Microsoft表示这是一个非问题，因为/应用程序需要root权限写入。我们指出，这不是真的，如果是，它将意味着任何应用程序的安装都需要提升的特权，这显然不是这种情况。</p><p> We received a response stating that they would review the information again. A few days later our ticket was closed with no reason or response given. After some prodding, the triage team finally stated that they were still unable to confirm that  /Applications could be written to without root privileges. Microsoft has since stated that they have no plans to release any immediate fix for this issue.</p><p> 我们收到了一个响应，说明他们会再次审查信息。几天后，我们的票被关闭，没有理由或答复给出。在一些潜水之后，分类团队终于指出，他们仍然无法确认/应用程序可以写入没有root权限。微软已表示他们没有计划为此问题发布任何立即修复。</p><p> Apple’s response was different. They stated that they did not consider this a security concern and that mitigations for this sort of issue were best left up to individual developers. While this is a totally valid response and we understand their position, we requested information regarding the difference in treatment from CVE-2020–9817. Apple did not provide a reason or explanation.</p><p> 苹果的回应是不同的。他们表示，他们没有考虑这一安全问题，这类问题的减轻者最好留给个别开发人员。虽然这是一个完全有效的回复，我们了解他们的立场，但我们要求有关CVE-2020-9817的治疗差异的信息。苹果没有提供理由或解释。</p><p>  During our research, we also discovered a way to bypass Gatekeeper and code signing requirements for package installers.</p><p>  在我们的研究中，我们还发现了一种绕过网守和包装安装程序的代码签名要求的方法。</p><p> According to  Gatekeeper documentation, packages downloaded from the internet or created from other possibly untrusted sources are supposed to have their signatures validated and a prompt is supposed to appear to authorize the opening of the installer. See the following quote for Apple’s explanation:</p><p> 根据Gatekeeper文档，从Internet下载或从其他可能不受信任的源创建的软件包应该具有验证的签名，并且应该提示似乎授权安装程序的打开。查看Apple解释的以下报价：</p><p> When a user downloads and opens an app, a plug-in, or an installer package from outside the App Store, Gatekeeper verifies that the software is from an identified developer, is notarized by Apple to be free of known malicious content, and hasn’t been altered. Gatekeeper also requests user approval before opening downloaded software for the first time to make sure the user hasn’t been tricked into running executable code they believed to simply be a data file.</p><p> 当用户下载并打开应用程序，插件或安装程序包从App Store外部，GateKeeper验证了软件来自所识别的开发人员，由Apple公证，不受已知的恶意内容，而且Hasn' T被改变了。 GateKeeper还请在打开下载的软件之前首次请求用户批准，以确保用户尚未被欺骗到运行的可执行代码，他们认为只是数据文件。 </p><p> In the case of downloading a package from the internet, we can observe that modifying the package will trigger an alert to the user upon opening it claiming that it has failed signature validation due to being modified or corrupted.</p><p>在从Internet下载包的情况下，我们可以观察到修改包将在打开后触发用户对用户的警报，声称它由于被修改或损坏而导致的签名验证失败。</p><p>  If we duplicate the package and modify it, however, we can modify contained files at will and repackage it sans signature. Most users will not notice that the installer is no longer signed (the lock symbol in the upper right-hand corner of the installer dialog will be missing) since the remainder of the assets used in the installer will look as expected. This newly modified package will also run without being caught or validated by Gatekeeper (Note: The applications installed will still be checked by Gatekeeper when they are run post-installation. The issue presented here regards the scripts run by the installer.) and could allow malware or some other malicious actor to achieve privilege escalation to root. Additionally, this process can be completely automated by monitoring for .pkg downloads and abusing the fact that all .pkg files follow the same general format and structure.</p><p>  如果我们复制包并修改它，我们可以修改包含的文件并重新括起来。大多数用户不会注意到安装程序不再签名（安装程序对话框的右侧右手角中的锁定符号将丢失，因为安装程序中使用的资产的其余部分将如预期视图。此新修改的程序包也将在不被捕获或由Gatekeeper捕获或验证的情况下运行（注意：在安装后运行时仍将通过Gatekeeper检查所安装的应用程序。此处呈现的问题对于安装程序来表示脚本。）并可以允许恶意软件或其他一些恶意演员，以实现root的特权升级。此外，该过程可以通过监视.pkg下载并滥用所有.pkg文件遵循相同的一般格式和结构的事实来完全自动化。</p><p> The below instructions can be used to demonstrate this process using the Microsoft Teams installer. Please note that this issue is not specific to this installer/product and can be generalized and automated to work with any arbitrary installer.</p><p> 以下说明可用于使用Microsoft Teams安装程序演示此过程。请注意，此问题并不特定于此安装程序/产品，可以概括并自动使用任何任意安装程序。</p><p>  When downloaded, the binary should appear in the user’s Downloads folder ( ~/Downloads). Before running the installer, open a Terminal session and run the following commands:</p><p>  下载时，二进制应该出现在用户的下载文件夹中（〜/下载）。在运行安装程序之前，打开终端会话并运行以下命令：</p><p> # Rename the package yes | mv ~/Downloads/Teams_osx.pkg ~/Downloads/old.pkg # Extract package contents pkgutil — expand ~/Downloads/old.pkg ~/Downloads/extract # Modify the post installation script used by the installer mv ~/Downloads/extract/Teams_osx_app.pkg/Scripts/postinstall ~/Downloads/extract/Teams_osx_app.pkg/Scripts/postinstall.bak echo “#!/usr/bin/env sh\nid &gt; ~/Downloads/exploit\n$(cat ~/Downloads/extract/Teams_osx_app.pkg/Scripts/postinstall.bak)” &gt; ~/Downloads/extract/Teams_osx_app.pkg/Scripts/postinstall rm -f ~/Downloads/extract/Teams_osx_app.pkg/Scripts/postinstall.bak chmod +x ~/Downloads/extract/Teams_osx_app.pkg/Scripts/postinstall # Repackage and rename the installer as expected pkgutil -f --flatten ~/Downloads/extract ~/Downloads/Teams_osx.pkg</p><p> ＃重命名包是| mv〜/下载/ teams_osx.pkg〜/下载/ old.pkg＃extract包目录pkgutil  - 展开〜/ downloads / old.pkg〜/ downloads / elizt＃修改安装程序mv〜/下载/提取的后安装脚本/teams_osx_app.pkg/scripts/postinstall〜/下载/提取/ teams_osx_app.pkg / scripts / postinstall.bak echo“＃！/ usr / bin / env sh \ n＆gt; 〜/下载/ exploit \ n $（cat〜/ downloads / extract / teams_osx_app.pkg / scripts / postinstall.bak）“＆gt; 〜/下载/提取/ teams_osx_app.pkg / scripts / postinstall rm -f〜/ downloads / extract / teams_osx_app.pkg / scripts / postinstall.bak chmod + x〜/ downloads / extract / teams_osx_app.pkg / teams_osx_app.pkg / scripts / postinstall＃repactage和将安装程序重命名为预期的pkgutil -f --flatten〜/下载/提取〜/​​ downloads / teams_osx.pkg</p><p> When a user runs this newly created package, it will operate exactly as expected from the perspective of the end-user. Post-installation, however, we can see that the  postinstall script run during installation has created a new file at  ~/Downloads/exploit that contains the output of the  id command as run by the root user, demonstrating successful privilege escalation.</p><p> 当用户运行此新创建的包时，它将从最终用户的角度正常运行。但是，安装后，我们可以看到安装期间的PostInstall脚本在安装期间创建了一个新文件，它在〜/ downloads / exproit中包含了root用户运行的id命令的输出，展示了成功的特权升级。</p><p>    Based on the steps provided, it appears you are reporting Gatekeeper does not apply to a package created locally. This is expected behavior.</p><p>    根据提供的步骤，它看起来您报告网守不适用于本地创建的包。这是预期的行为。 </p><p>  We confirmed that this is indeed what we were reporting and requested additional information based on the Gatekeeper documentation available:</p><p>我们确认这确实是我们在提供的网守文档上报告和请求的其他信息：</p><p>  Apple explained that their initial explanation was faulty, but maintained that Gatekeeper acted as expected in the provided scenario.</p><p>  Apple解释说，他们的初始解释是有问题的，但维持该门卫在提供的方案中按预期行事。</p><p> Essentially, they state that  locally created packages are not checked for malicious content by Gatekeeper nor are they required to be signed. This means that even packages that require root privileges to run can be copied, modified, and recreated locally in order to bypass security mechanisms. This allows an attacker with local access to man-in-the-middle package downloads and escalates privileges to root when a package that does so is executed.</p><p> 从本质上讲，它们说明了所创建的包裹未按网守检查恶意内容，也不需要签名。这意味着甚至可以在本地复制，修改和重新创建要运行的root权限的包甚至可以在本地复制，以绕过安全机制。这允许攻击者对中间人的包裹下载，并在执行所需的包时升级到root权限。</p><p>  So, are these flaws actually a big deal? From a realistic risk standpoint, no, not really. This is just another tool in an already stuffed post-exploitation toolbox, though, it should be noted that similar installer-based attack vectors are actively being exploited,  as is the case in recent SolarWinds news.</p><p>  那么，这些缺陷实际上是一个大问题吗？从一个现实的风险的立场，不，不是真的。然而，这只是一个已经填充的后开发后工具箱中的另一个工具，应该指出的是，基于安装的攻击向量正在积极被剥削，就像最近的Solarwinds新闻一样。</p><p> From a triage standpoint, however, this is absolutely a big deal for a couple of reasons:</p><p> 然而，从分类角度来看，这绝对是几乎没有原因：</p><p> Apple has put so much effort over the last few iterations of macOS into baseline security measures that it seems counterproductive to their development goals to ignore basic issues such as these (especially issues they’ve already implemented similar fixes for).</p><p> Apple对宏的最后几个迭代筹集了这么多努力进入基线安全措施，似乎对其发展目标似乎适得其反，以忽视这些基本问题（特别是他们已经实施了类似的修复）。</p><p> It demonstrates how much emphasis some vendors place on making issues go away rather than solving them.</p><p> 它展示了一些厂商在发出问题上消失而不是解决它们的程度。 </p><p> We understand that vulnerability triage teams are absolutely bombarded with half-baked vulnerability reports, but becoming unresponsive during the disclosure response, overusing canned messaging, or simply giving incorrect reasons should not be the norm and highlights many of the frustrations researchers experience when interacting with these larger organizations.</p><p>我们理解，漏洞分类团队绝对被轰炸，并在披露响应期间没有反应迟钝，过度划分的罐头消息，或者只是给予错误的原因不应该是规范，并且突出了与这些互动时的许多挫折研究人员体验更大的组织。</p><p> We want to point out that we do not blame any single organization or individual here and acknowledge that there may be bigger things going on behind the scenes that we are not privy to. It’s also totally possible that our reports or explanations were hot garbage and our points were not clearly made. In either case, though, communications from the vendors should have been better about what information was needed to clarify the issues before they were simply discarded.</p><p> 我们想指出，我们不会责怪任何单一组织或个人在这里，并承认我们在幕后可能会有更大的事情，我们没有枢密。我们的报告或解释也可能是热垃圾，我们的积分没有明确。然而，在任何一种情况下，供应商的通信都应该更好地了解澄清问题所需的信息，以便在只是丢弃之前。</p><p> Circling back to the issues at hand, what can users do to protect themselves? It’s impractical for everyone to manually audit each and every installer they interact with. The occasional spot check with  Suspicious Package, which shows all scripts executed when an installer package is run, never hurts. In general, though, paying attention to proper code signatures (look for the lock in the upper righthand corner of the installer) goes a long way.</p><p> 圈出来回到手头的问题，用户可以做些什么来保护自己？每个人都手动审核每个安装人员都是不切实际的。偶尔的Spoto Check与可疑包，它显示了运行安装程序包时执行的所有脚本，从不伤害。但是，一般来说，请注意适当的代码签名（在安装人员的上右侧角落中寻找锁定）。</p><p> For developers, pay special attention to the directories and files being used during the installation process when creating distribution packages. In general, it’s best practice to use an installer sandbox whenever possible. When that isn’t possible, verifying the integrity of files as well as enforcing proper permissions on the directories and files being operated on is enough to mitigate these issues.</p><p> 对于开发人员，在创建分发包时，请特别注意在安装过程中使用的目录和文件。通常，尽可能使用安装程序沙箱是最好的做法。何时不可能，验证文件的完整性以及强制执行目录和正在运行的文件的正确权限是否足以减轻这些问题。</p><p> Further details on these discoveries can be found in  TRA-2021–19,  TRA-2021–20, and  TRA-2021–21.</p><p> 有关这些发现的进一步细节可以在TRA-2021-19，TRA-2021-20和TRA-2021-21中找到。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/tenable-techblog/more-macos-installer-flaws-c868d9067eb3">https://medium.com/tenable-techblog/more-macos-installer-flaws-c868d9067eb3</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/漏洞/">#漏洞</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/安装程序/">#安装程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/installer/">#installer</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>