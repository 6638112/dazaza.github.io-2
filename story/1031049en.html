<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>内核线程中的NAPI轮询</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">内核线程中的NAPI轮询</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-25 11:13:59</div><div class="page_narrow text-break page_content"><p>Benefits for LWN subscribers The primary benefit from  subscribing to LWN is helping to keep us publishing, but, beyond that, subscribers get immediate access to all site content and access to a number of extra site features. Please sign up today!</p><p>对LWN用户的好处订阅LWN的主要好处是帮助我们保持发布，但除此之外，订阅者可以立即访问所有网站内容和访问许多额外的网站功能。今天就来报名吧！</p><p>   Systems that manage large amounts of network traffic end up dedicating asignificant part of their available CPU time to the network stack itself.Much of this work is done in software-interrupt context, which can beproblematic in a number of ways. That may be about to change, though,once  thispatch series posted by Wei Wang is merged into the mainline. Once a packet arrives on a network interface, the kernel must usuallyperform a fair amount of protocol-processing work before the data in thatpacket can be delivered to the user-space application that is waiting forit. Once upon a time, the network interface would interrupt the CPU when apacket arrived; the kernel would acknowledge the interrupt, then trigger asoftware interrupt to perform this processing work. The problem with thisapproach is that, on busy systems, thousands of packets can arrive everysecond; handling the corresponding thousands of hardware interrupts can runthe system into the ground. The solution to this problem  was merged in2003 in the form of a mechanism that was called, at the time, &#34;newAPI&#34; or &#34;NAPI&#34;. Drivers that support NAPI can disable the packet-receptioninterrupt most of the time and rely on the network stack to poll for newpackets at a frequent interval. Polling may seem inefficient, but on busysystems there will always be new packets by the time the kernel polls forthem; the driver can then process all of the waiting packets at once. Inthis way, one poll can replace dozens of hardware interrupts. NAPI has evolved considerably since 2003, but one aspect remains the same:it still runs in software-interrupt mode. These interrupts, once queued bythe kernel, will be processed at either the next return from a hardwareinterrupt or the next return from kernel to user mode. They thus run in anessentially random context, stealing time from whatever unrelated processhappens to be running at the time. Software interrupts are hard for systemadministrators to manage and can create surprising latencies if they runfor a long time. For this reason, kernel developers have wanted to reduceor eliminate their use for years; they are an old mechanism that is deeplywired into core parts of the kernel, though, and are hard to get rid of. Wang&#39;s patch set (which contains work from Paolo Abeni, Felix Fietkau, andJakub Kicinski) doesn&#39;t eliminate software interrupts, but it is a possiblestep in that direction. With these patches applied, the kernel canoptionally (under administrator control) create a separate kernel threadfor each NAPI-enabled network interface. After that, NAPI polling will bedone in the context of that thread, rather than in a software interrupt. The amount of work that needs to be done is essentially unchanged with thispatch set, but the change in the way that work is done is significant.Once NAPI polling moves to its own kernel thread, it becomes much morevisible and subject to administrator control. A kernel thread can have itspriority changed, and it can be bound to a specific set of CPUs; thatallows the administrator to adjust how that work is done in relation to thesystem&#39;s user-space workload. Meanwhile, the CPU scheduler will have a betterunderstanding of how much CPU time NAPI polling requires and can avoidoverloading the CPUs where it is running. Time spent handling softwareinterrupts, instead, is nearly invisible to the scheduler. There aren&#39;t a lot of benchmark results posted with the patch set; thosethat are available indicate a possible slight increase in overhead when thethreaded mode is used. Users who process packets at high rates tend tofret over every nanosecond, but even they might find little to quibbleabout if these results hold. Meanwhile, those users should also see moredeterministic scheduling for their user-space code, which is alsoimportant.</p><p>管理大量网络流量的系统最终会将其可用CPU时间的很大一部分专门用于网络堆栈本身，其中大部分工作是在软件中断环境中完成的，这在很多方面都会有问题。然而，一旦王伟发布的这个补丁系列被合并到主线上，这种情况可能会改变。一旦数据包到达网络接口，内核通常必须执行相当数量的协议处理工作，然后才能将数据包中的数据传送到等待它的用户空间应用程序。曾几何时，当数据包到达时，网络接口会中断CPU；内核会确认中断，然后触发软件中断来执行此处理工作。这种方法的问题在于，在繁忙的系统上，每秒可能会有数千个数据包到达；处理相应的数千个硬件中断可能会使系统陷入困境。这个问题的解决方案在2003年以一种机制的形式合并，当时被称为newAPI&34；或&#34；napi&34；。支持NAPI的驱动程序可以在大多数时间禁用数据包接收中断，并依赖网络堆栈以频繁的间隔轮询新数据包。轮询可能看起来效率不高，但在繁忙的系统上，内核轮询时总会有新的数据包；然后驱动程序可以一次处理所有等待的数据包。通过这种方式，一次轮询可以取代数十个硬件中断。自2003年以来，NAPI有了很大的发展，但有一个方面保持不变：它仍然运行在软件中断模式下。这些中断一旦由内核排队，将在下一次从硬件中断返回或下一次从内核返回到用户模式时处理。因此，它们在基本上随机的上下文中运行，从当时碰巧正在运行的任何无关进程中窃取时间。软件中断对于系统管理员来说很难管理，如果它们长时间运行，可能会造成令人惊讶的延迟。出于这个原因，内核开发人员多年来一直希望减少或消除它们的使用；不过，它们是一种与内核核心部分紧密相连的旧机制，很难摆脱。Wang的补丁程序集(包含Paolo Abeni、Felix Fietkau和Jakub Kicinski的工作)不能消除软件中断，但它是朝着这个方向迈出的可能一步。应用这些补丁后，内核会选择性地(在管理员控制下)为每个启用NAPI的网络接口创建单独的内核线程。之后，NAPI轮询将在该线程的上下文中进行，而不是在软件中断中进行。这个补丁程序集基本上没有改变需要完成的工作量，但是工作方式发生了很大的变化。一旦NAPI轮询移动到它自己的内核线程，它就会变得更加可见，并受管理员的控制。内核线程可以更改其优先级，并且可以将其绑定到一组特定的CPU上，从而允许管理员根据系统的用户空间工作负荷来调整该工作是如何完成的。同时，CPU调度器将更好地理解NAPI轮询所需的CPU时间，并可以避免运行时CPU过载。相反，处理软件中断所花费的时间对于调度器几乎是不可见的。补丁程序集发布的基准测试结果并不多；这些可用的结果表明，使用线程模式时可能会略微增加开销。以高速率处理数据包的用户往往会为每一纳秒而烦恼，但即使是他们也可能会发现，如果这些结果成立的话，也没什么好争辩的。同时，这些用户还应该看到他们的用户空间代码的更多确定性调度，这也很重要。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://lwn.net/Articles/833840/">https://lwn.net/Articles/833840/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内核/">#内核</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/polling/">#polling</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/中断/">#中断</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>