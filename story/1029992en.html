<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>关于Zig(和铁锈)的各种思考</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">关于Zig(和铁锈)的各种思考</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-20 17:53:07</div><div class="page_narrow text-break page_content"><p>I&#39;ve been using  zig for ~4 months worth of side projects, including a  toy text editor and an  interpreter for a relational language. I&#39;ve written ~10kloc.</p><p>我已经使用ZIG进行了大约4个月的附带项目，包括一个玩具文本编辑器和一种关系语言的解释器。我已经写了~10kloc。</p><p> That&#39;s not nearly enough time to form a coherent informed opinion. So instead here is an incoherent assortment of thoughts and experiences, in no particular order :)</p><p>这远远没有足够的时间来形成一个连贯的、知情的观点。因此，以下是一系列杂乱无章的想法和经历，没有特别的顺序：)。</p><p> This is not meant to be an introduction to zig - check out the excellent  language docs or the new  ziglearn.org instead. I&#39;ll try to focus instead on things that are not immediately obvious from reading intro material.</p><p>这不是对zig的介绍-请查看优秀的语言文档或新的ziglearn.org。我会试着把注意力放在那些从阅读介绍性材料中看不出来的东西上。</p><p> The obvious point of comparison is to rust. For context, I&#39;ve been using rust  since 2015. Mostly in research positions writing throwaway code, but also ~14 months working on  a commercial database which is ~100kloc.</p><p>显而易见的比较点是生锈。作为背景，我从2015年起就开始使用铁锈了。主要是在研究岗位上编写一次性代码，但也有大约14个月的时间在大约100kloc的商业数据库上工作。</p><p>  Zig is dramatically simpler than rust. It took a few days before I felt proficient vs a month or more for rust.</p><p>ZIG比铁锈简单得多。我花了几天时间才感到熟练，而不是一个月或更长时间的生锈。</p><p> Most of this difference is  not related to lifetimes. Rust has patterns, traits, dyn, modules, declarative macros, procedural macros, derive, associated types, annotations, cfg, cargo features, turbofish, autoderefencing, deref coercion etc. I encountered most of these in the first week. Just understanding how they all work is a significant time investment, let alone learning when to use each and how they affect the available design space.</p><p>这种差异大部分与寿命无关。Ruust有模式、特征、动态、模块、声明性宏、过程性宏、派生、关联类型、注释、cfg、货物特性、Turbofish、autoderefence、deref强制等等。我在第一周就遇到了这些东西中的大多数。仅仅了解它们是如何工作的就是一项巨大的时间投入，更不用说学习何时使用它们以及它们如何影响可用的设计空间了。</p><p> I still haven&#39;t internalized the full rule-set of rust enough to be able predict whether a design in my head will successfully compile. I don&#39;t remember the order in which methods are resolved during autoderefencing, or how module visibility works, or how the type system determines if one impl might  overlap another or be an orphan. There are frequent moments where I know what I want the machine to do but struggle to encode it into traits and lifetimes.</p><p>我还没有将全部规则内在化到能够预测我脑海中的设计是否能成功编译的程度。我不记得在自动取消引用期间解析方法的顺序，不记得模块可见性是如何工作的，也不记得类型系统是如何确定一个Impl可能会重叠另一个还是孤立的。经常有这样的时刻，我知道我想让机器做什么，但却很难把它编码成特性和寿命。</p><p> Zig manages to provide many of the same features with a single mechanism - compile-time execution of regular zig code. This comes will all kinds of pros and cons, but one large and important pro is that I already know how to write regular code so it&#39;s easy for me to just write down the thing that I want to happen.</p><p>ZIG设法通过单一机制提供许多相同的特性-常规ZIG代码的编译时执行。这会带来各种各样的利弊，但一个重大而重要的优点是，我已经知道如何编写常规代码，所以写下我想要发生的事情对我来说很容易。</p><p>  One of the key differences between zig and rust is that when writing a generic function, rust will prove that the function is type-safe for every possible value of the generic parameters. Zig will prove that the function is type-safe only for each parameter that you actually call the function with.</p><p>Zig和rust之间的主要区别之一是，在编写泛型函数时，rust将证明该函数对于泛型参数的每个可能值都是类型安全的。Zig将证明该函数只对您实际调用函数时使用的每个参数是类型安全的。</p><p> On the one hand, this allows zig to make use of arbitrary compile-time logic where rust has to restrict itself to structured systems (traits etc) about which it can form general proofs. This in turn allows zig a great deal of expressive power and also massively simplifies the language.</p><p>一方面，这允许ZIG使用任意的编译时逻辑，其中Rust必须将自己限制在结构化系统(特征等)上，它可以形成关于这些系统的一般证明。这反过来又赋予了ZIG极大的表现力，同时也极大地简化了语言。</p><p> On the other hand, we can&#39;t type-check zig libraries which contain generics. We can only type-check specific uses of those libraries.</p><p>另一方面，我们可以对包含泛型的zig库进行类型检查。我们只能对这些库的特定用途进行类型检查。</p><p> // This function is typesafe if there exist no odd perfect numbers// https://en.wikipedia.org/wiki/Perfect_number#Odd_perfect_numbersfn foo(comptime n: comptime_int, i: usize) usize { const j = if (comptime is_odd_perfect_number(n)) &#34;surprise!&#34; else 1; return i + j;}</p><p>//如果不存在奇数完全数，则此函数是类型安全的//comptime foo(comptime n：comptime_int，i：usize)usize{const j=if(comptime is_ODD_Perfect_Number(N))&#34；https://en.wikipedia.org/wiki/Perfect_number#Odd_perfect_numbersfn！&#34；Else 1；Return i+j；}。</p><p> This means zig also doesn&#39;t get the automatic, machine-checked documentation of type constraints that rust benefits from and may face more challenges providing IDE support.</p><p>这意味着ZIG也无法获得自动的、机器检查的类型约束文档，而Ruust将从中受益，并可能面临更多提供IDE支持的挑战。</p><p> This might harm the zig ecosystem by making it harder to compose various libraries. But  julia has a similar model and in practice it has worked very well ( eg,  eg).</p><p>这可能会使构建各种库变得更加困难，从而损害ZIG生态系统。但朱莉娅有一个类似的模式，而且在实践中效果很好。</p><p>   It should be relatively trivial to implement specialization the same way, which has been a  work in progress in rust for years and is critical to many optimizations in julia&#39;s math libraries.</p><p>以同样的方式实现专门化应该是相对简单的，这是一项多年来一直在进行的工作，对Julia的数学库中的许多优化都是至关重要的。</p><p> Julia chose dynamic typing because it&#39;s very difficult to encode the types of various mathematical operations into a general schema (eg fortress  struggled with this). Zig&#39;s approach of not requiring general schemas but still type-checking individual cases may be an interesting sweet spot.</p><p>朱莉娅之所以选择动态类型，是因为要把各种数学运算的类型编码成一个通用的模式非常困难(如堡垒为此苦苦挣扎)。Zig的方法不需要通用模式，但仍然对个别情况进行类型检查，这可能是一个有趣的最佳点。</p><p>  I used the  2020 CWE Top 25 Most Dangerous Software Weaknesses to get a sense of the relative frequency of different causes of memory unsafety.</p><p>我使用了2020年CWE最危险的25个软件弱点来了解不同内存不安全原因的相对频率。</p><p> (I&#39;m assuming that the zig programmer is using release-safe mode instead of the unfortunately named release-fast mode which disables all runtime safety checks.)</p><p>(我假设ZIG程序员使用的是发布安全模式，而不是命名不幸的快速发布模式，该模式禁用所有运行时安全检查。)。</p><p>  Both languages primarily use bounds-checked slices and relegate pointer arithmetic to a separate type ( *T in rust,  [*]T in zig).</p><p>这两种语言主要使用边界检查切片，并将指针算法降级为单独的类型(*T表示铁锈，[*]T表示zig)。</p><p>  Both languages require explicit annotations for nulls ( Option&lt;T&gt; in rust,  ?T in zig) and require code to either handle the null case or safely crash on null ( x.unwrap() in rust,  x.? in zig).</p><p>这两种语言都需要对空值进行显式注释(rust中的选项&lt；t&gt；，zig中的？t)，并且要求代码要么处理空值情况，要么在rust，x中的NULL(x.unwire())上安全崩溃。之字形)。</p><p> Dereferencing/casting a null c pointer is undefined behavior in both languages, but is checked at runtime in zig.</p><p>取消引用/强制转换null c指针在两种语言中都是未定义的行为，但在zig中会在运行时进行检查。</p><p>  Rust catches overflow in debug and wraps in release. Zig catches overflow in debug/release-safe and leaves behavior undefined in release-fast.</p><p>铁锈在调试中捕获溢出，并在发布中包装。ZIG在DEBUG/RELEASE-SAFE中捕获溢出，并在RELEASE-FAST中保留未定义的行为。</p><p> Both languages allow explicitly asking for wraparound ( x.wrapping_add(1) in rust,  x +% 1 in zig).</p><p>这两种语言都允许显式请求环绕(铁锈中的x.wrapping_add(1)，zig中的x+%1)。</p><p>  As long as all unsafe code obeys the aliasing and lifetime rules, rust protects completely against UAF.</p><p>只要所有不安全的代码都遵守别名和生存期规则，铁锈就可以完全保护您免受UAF的攻击。</p><p> Zig has little protection. The recently merged GeneralPurposeAllocator avoids reusing memory regions (which prevents freed data from being overwritten) and reusing pages (which means that UAF will eventually result in a page fault). But this comes at the cost of fragmentation and lower performance and it also won&#39;t provide protection for child allocators using the GPA as a backing allocator.</p><p>Zig几乎没有什么保护作用。最近合并的GeneralPurposeAllocator避免重用内存区域(这可以防止释放的数据被覆盖)和重用页面(这意味着UAF最终将导致页面错误)。但这是以碎片化和较低的性能为代价的，而且它也不会为使用GPA作为后备分配器的孩子分配器提供保护。</p><p>  Both languages will insert implicit casts between primitive types whenever it is safe to do so, and require explicit casts otherwise.</p><p>只要安全，这两种语言都会在基元类型之间插入隐式强制转换，否则需要显式强制转换。</p><p>   In rust the Send/Sync traits flag types which are safe to move/share across threads. In the absence of unsafe code it should be impossible to cause data races.</p><p>在RUST中，发送/同步特征标记可以安全地跨线程移动/共享的类型。在没有不安全代码的情况下，应该不可能导致数据竞争。</p><p> Zig has no comparable protection. It&#39;s possible to implement the same logic as Send/Sync in comptime zig, but without the ability to track ownership the rules would have to be much more restrictive.</p><p>Zig没有类似的保护措施。在comptime zig中实现与发送/同步相同的逻辑是可能的，但如果没有跟踪所有权的能力，则规则将受到更多限制。</p><p>  Rust prevents having multiple mutable references to the same memory region at the same time.</p><p>生锈可防止同时对同一存储区域进行多个可变引用。</p><p> This means that eg iterator invalidation is prevented at compile time, because the borrow checker won&#39;t allow mutating a data-structure while an iterator is holding a reference to the data-structure. Similarly for resizing a data-structure while holding a reference to the old allocation. Both examples are easy sources of UAF in zig.</p><p>这意味着在编译时防止例如迭代器无效，因为当迭代器持有对数据结构的引用时，借用检查器不允许改变数据结构。类似地，用于在保持对旧分配的引用的同时调整数据结构的大小。这两个例子都是Zig型UAF的简单来源。</p><p>  Neither language is able to produce stack traces for stack overflows at the moment ( rust,  zig)</p><p>目前，这两种语言都不能生成堆栈溢出的堆栈跟踪(铁锈、ZIG)。</p><p> In the future zig is  intended to statically check the maximum stack usage of your program and force recursive code to explicitly allocate space on the heap, so that stack overflows produce a recoverable OutOfMemory error rather than a crash.</p><p>将来，zig旨在静态检查程序的最大堆栈使用率，并强制递归代码显式分配堆上的空间，以便堆栈溢出产生可恢复的OutOfMemory错误，而不是崩溃。</p><p> This is not an academic problem - I&#39;ve seen real-world crashes from recursive tree transformations in compilers ( eg) and it&#39;s often painful to write the same logic without recursion.</p><p>这不是一个学术问题-我在现实世界中见过编译器(例如)中的递归树转换造成的崩溃，在没有递归的情况下编写相同的逻辑通常是很痛苦的。</p><p>  Undefined behavior in rust is defined  here. It&#39;s worth noting that breaking the aliasing rules in unsafe rust can cause undefined behavior but these rules are not yet well-defined. So far this hasn&#39;t caused me any problems but it is a little unnerving.</p><p>这里定义了锈蚀中未定义的行为。值得注意的是，在不安全的锈蚀中违反别名规则可能会导致未定义的行为，但这些规则还没有很好地定义。到目前为止，这还没有给我带来任何问题，但它让我有点不安。</p><p> Miri is an interpreter for rusts Mid-level Intermediate Representation which will detect many (but not all) cases of undefined behavior in unsafe rust. It&#39;s far too slow to use for the whole materialize test suite but was useful for unit-testing an unsafe module.</p><p>MIRI是一个用于锈蚀中级中间表示的解释器，它将检测许多(但不是所有)不安全锈蚀中的未定义行为的情况。它太慢了，不能用于整个物化测试套件，但对于单元测试不安全的模块很有用。</p><p> Undefined behavior in zig is defined  here. This list is  probably incomplete given that the core language is still under development.</p><p>此处定义了ZIG中未定义的行为。鉴于核心语言仍在开发中，这个列表可能并不完整。</p><p> Zig  aspires to insert runtime checks for almost all undefined behavior when compiling in debug mode. So far all the easy cases are handled, which is already a dramatic improvement over c.</p><p>Zig渴望在调试模式下编译时为几乎所有未定义的行为插入运行时检查。到目前为止，所有简单的情况都得到了处理，这已经比c++语言有了很大的进步。</p><p> Zigs compile-time partial evaluation is done by an IR interpreter - it seems plausible that this could also be used as a miri-like tool in the future.</p><p>Zigs编译时的部分计算是由IR解释器完成的-这似乎有可能在将来也用作类似Miri的工具。</p><p>  @import takes a path to a file and turns the whole file into a struct. So modules are just structs. And vice-versa - if you have a large struct declaration you can move it into a file to reduce the indentation.</p><p>@import接受文件的路径，并将整个文件转换为结构。所以模块只是结构。反之亦然-如果您有一个很大的结构声明，您可以将其移动到文件中以减少缩进。</p><p>  @import is part of the compile-time execution system so things like platform-specific modules and configurable features can be specified in regular code rather than rust&#39;s limited set of  #[cfg(...)] macros.</p><p>@import是编译时执行系统的一部分，因此可以在常规代码中指定特定于平台的模块和可配置功能等内容，而不是使用RUST的有限#[cfg(...)]。宏。</p><p>  Array, struct, enum and union literals can be anonymous -  .{.Constant = 1.0} is an anonymous union with it&#39;s own type, but can be implicitly cast to any union with a  Constant: f64 field because they share the same structure.</p><p>数组、结构、枚举和联合文字可以是匿名的-。{.Constant=1.0}是其自身类型的匿名联合，但可以隐式强制转换为具有常量：f64字段的任何联合，因为它们共享相同的结构。</p><p> In rust my code is littered with  use Expr::* and I&#39;m careful to avoid name collisions between different enums that I might want to import in the same functions. In zig I just use anonymous literals everywhere and don&#39;t worry about it.</p><p>在Ruust中，我的代码中到处都是use expr：：*和Use expr：：*，我会小心避免想要在相同函数中导入的不同枚举之间的名称冲突。在zig中，我只是在任何地方都使用匿名文字，不用担心。</p><p>  Anonymous literals are also nice when using structs to simulate keyword arguments. No need to find and import the correct type:</p><p>在使用结构模拟关键字参数时，匿名文字也很有用。无需查找并导入正确的类型：</p><p> fn do_things(config: struct { max_things: usize = 1000, // default value flavor: Flavor,}) void { ...}do_things(.{.flavor = .Strawberry});</p><p>Fn do_Things(config：struct{max_thing：usize=1000，//默认风味：风味，})void{...}do_Things(.{.style=.strawberry})；</p><p>   let  constant  =  if let  Expr :: Constant(constant)  =  expr { constant }  else  {  panic! () } ;</p><p>Let Constant=if let expr：：Constant(Constant)=expr{Constant}Else{Panic！()}；</p><p>          This works because tagged unions in zig create a separate type for the tag itself and there is an implicit cast from the union to the tag.</p><p>这是可行的，因为ZIG中的标记联合为标记本身创建了单独的类型，并且存在从联合到标记的隐式强制转换。</p><p>  Zig integers may be any size (eg  u42 for a 42-bit unsigned integer). Together with the  packed annotation on structs this makes it really easy to write bit-packing code ( eg).</p><p>Zig型整数可以是任意大小(例如，U42表示42位无符号整数)。再加上结构上的压缩注释，这使得编写比特打包代码(例如)变得非常容易。</p><p>  There is no pattern matching, but a  switch on enums and unions is checked for exhaustiveness at compile time. This covers ~90% of my use of pattern matching.</p><p>没有模式匹配，但是在编译时检查枚举和联合的开关是否详尽。这涵盖了我使用的模式匹配的大约90%。</p><p> More complex matches ( eg) have to handled by chained  if statements. This is usually less readable than the equivalent rust and I miss the exhaustiveness checks.</p><p>更复杂的匹配(例如)必须由链接的IF语句处理。这通常比等效锈的可读性差，我错过了详尽的检查。</p><p>  Existing tools for native languages (valgrind, prof etc) work for both languages, modulo name mangling.</p><p>现有的本地语言工具(valgrind、prof等)对两种语言都有效，即模名损坏。</p><p> Both languages work with gdb and lldb but the experience is mediocre. Rust has builtin support  in gdb which improves pretty-printing and allows writing rust expressions, but still has many holes and quirks.</p><p>这两种语言都可以使用gdb和lldb，但体验一般。Rust在gdb中有内置的支持，它改进了漂亮的打印，并允许编写rust表达式，但仍然有很多漏洞和怪异之处。</p><p> Rust has  unstable support for LLVM sanitizers (asan, libfuzzer etc). This is an  open issue in zig.</p><p>铁锈对LLVM消毒剂(ASAN、libfuzzer等)的支持不稳定。这在ZIG中是一个悬而未决的问题。</p><p>  The  Rust Language Server is usable. It works well on valid code, but struggles to deal with invalid states during editing. It can also be painfully slow in large codebases - when working on materialize it was often 3-5x slower than just running  cargo check.</p><p>Rust语言服务器可以使用。它在有效代码上工作得很好，但在编辑过程中很难处理无效状态。在大型代码库中，它也可能慢得令人痛苦-当使用Materialize时，它通常比仅仅运行货物检查慢3-5倍。</p><p>  I haven&#39;t yet tried the  Zig Language Server but it appears to be fairly complete.</p><p>我还没有尝试过Zig语言服务器，但它似乎相当完整。</p><p> The upcoming incremental zig compiler is intended to be usable as an IDE backend too. I haven&#39;t been following the design closely but it seems clear that they&#39;ve been paying attention to what the rust community has learned over the last half-decade or so.</p><p>即将推出的增量式ZIG编译器也可以作为IDE后端使用。我一直没有密切关注这个设计，但似乎很明显，他们一直在关注锈蚀社区在过去五年左右的时间里学到了什么。</p><p>  The zig standard library provides a  standard interface for allocators. Everything in the stdlib that allocates memory takes an allocator as an argument. This makes it easy to use custom allocators without having to write your own basic data-structures. While there isn&#39;t much of a zig ecosystem yet, it seems likely that future libraries will follow this convention.</p><p>ZIG标准库为分配器提供了标准接口。Stdlib中分配内存的所有内容都以分配器作为参数。这使得使用自定义分配器变得很容易，而不必编写您自己的基本数据结构。虽然目前还没有太多之字形的生态系统，但未来的图书馆似乎很可能会遵循这一惯例。</p><p> Rust provides an implicit global allocator. The standard library and most other libraries use only the global allocator. It&#39;s possible to choose the global allocator, but not to use different global allocators in different parts of your program.</p><p>Rust提供了一个隐式全局分配器。标准库和大多数其他库仅使用全局分配器。可以选择全局分配器，但不能在程序的不同部分使用不同的全局分配器。</p><p> While it&#39;s possible to write your own allocators in rust, there isn&#39;t yet a standard interface for allocators and most of the ecosystem uses only the global allocator. There is  work underway to improve the situation.</p><p>虽然可以用铁锈来编写您自己的分配器，但是目前还没有一个分配器的标准接口，而且生态系统的大多数都只使用全局分配器。目前正在进行改善这种情况的工作。</p><p> I&#39;ve also found that switching from the global allocator to a custom allocator in rust can require a lot of refactoring and produce a lot of boilerplate, as it introduces new lifetimes that spread through every allocated type. When writing compilers in zig I tend to arena allocate everything. In rust I end up using the global allocator and cloning a lot of data instead because it&#39;s easier.</p><p>我还发现，在RUST中从全局分配器切换到自定义分配器需要进行大量的重构，并且会产生大量的样板，因为它会引入新的生命周期，这些生命周期会传播到每个已分配的类型中。当用之字形编写编译器时，我倾向于分配所有内容。在Rust中，我最终使用全局分配器并克隆大量数据，因为这样更容易。</p><p>  In rust, if you store a  String or  Vec in eg  typed-arena the backing data will still be allocated and freed by the global allocator. It provides the lifetime benefits of an arena allocator but not the performance benefits. Allocators like  bumpalo currently require reimplementing stdlib types like  String and  Vec. There are  plans to fix this.</p><p>在RUST中，如果您将字符串或VEC存储在例如TYPED-ARENA中，则支持数据仍将由全局分配器分配和释放。它提供了竞技场分配器的终生优势，但没有性能优势。像umpalo这样的分配器目前需要重新实现像string和vec这样的stdlib类型。我们有计划来解决这个问题。</p><p> Until then it&#39;s often hard to gain the performance benefits of such specialized allocators eg there is a hot path in materialize&#39; data plane ( here) that would be cheaper and simpler if we could just bump allocate  String and  Vec.</p><p>在此之前，通常很难获得这种专用分配器的性能优势，例如，在Materialize数据平面(这里)中有一条热门路径，如果我们只需增加Allocation String和VEC，它将会更便宜、更简单。</p><p>  The rust global allocator panics on allocation failures. Zig allocators return an OutOfMemory error which can be recovered from.</p><p>Rust全局分配器在分配失败时出现恐慌。ZIG分配器返回一个OutOfMemory错误，可以从中恢复。</p><p> The downside of OutOfMemory errors is that they introduce a  lot more error paths which can be difficult to test. I mostly choose to just panic anyway, but there are definitely cases where recovery is feasible and useful eg:</p><p>OutOfMemory错误的缺点是它们引入了更多难以测试的错误路径。不管怎样，我大多选择惊慌失措，但肯定有一些情况下恢复是可行的和有用的，例如：</p><p> a sql database might want to set a memory limit per client and abort queries that exceed the limit</p><p>SQL数据库可能希望为每个客户端设置内存限制，并中止超过该限制的查询</p><p>  Zig has no syntax for closures. You can create closures manually, but it&#39;s verbose. There is a  tracking issue open but it doesn&#39;t look like there is a consensus yet. The lack of closures limits some kinds of apis eg a direct port of  differential dataflow to zig would be unpleasant to use.</p><p>Zig没有闭包的语法。您可以手动创建闭包，但它很繁琐。有一个追踪问题悬而未决，但看起来还没有达成共识。缺少闭包限制了某些类型的API，例如将差分数据流直接移植到ZIG将不太好用。</p><p>  Zig has no equivalent to smart pointers. I haven&#39;t wanted any yet, but I expect to miss rust&#39;s  Rc eventually. Manually incrementing reference counts is hilariously error-prone.</p><p>ZIG没有等同于智能指针的功能。我现在还不想要，但我预计最终会怀念拉斯特的RC。手动递增引用计数非常容易出错。</p><p>  Zig&#39;s error handling model is similar to rust&#39;s, but it&#39;s errors are an open union type rather than a regular union type like rust&#39;s. So:</p><p>Zig的错误处理模型类似于Rust的错误处理模型，但它的错误是开放联合类型，而不是像Rust那样的常规联合类型。因此：</p><p> The compiler can accurately infer the exact set of errors that can be returned by each function. (In rust it&#39;s  very tempting to just have a single error enum per library).</p><p>编译器可以准确推断每个函数可以返回的确切错误集。(在Rust中，每个库只有一个错误枚举是非常诱人的)。</p><p> If you handle a subset of possible errors and propagate the rest, the compiler will correctly infer the reduced error set.</p><p>如果处理可能错误的子集并传播其余错误，编译器将正确推断减少的错误集。</p><p> You can use a comptime assert to check that the inferred set of errors is exactly what you expected - neither more nor less.</p><p>您可以使用comptime断言来检查推断的错误集是否完全符合您的预期-既不多也不少。</p><p>  Zig&#39;s errors also carry a  trace of each function that they passed through, even if the error changed along the way. This is  not the same as the stacktrace at the point the error was created - it&#39;s tracking the errors path through your error handling code.</p><p>ZIG的错误还带有它们所经过的每个函数的痕迹，即使错误在此过程中发生了变化。这与创建错误时的堆栈跟踪不同-它通过错误处理代码跟踪错误路径。</p><p> To find this path in rust I first have to figure out how to reproduce the crash, record it in  rr and then walk backwards from the panic.</p><p>要在铁锈中找到这条路，我首先必须弄清楚如何重现撞车，将其记录在rr中，然后从恐慌中向后走。</p><p>  Zig&#39;s errors can&#39;t yet carry any extra information about the error. There is an  open issue to improve this but it looks like there are some remaining design problems to be solved.</p><p>ZIG的错误还不能携带任何有关该错误的额外信息。这是一个有待改进的问题，但看起来还有一些剩余的设计问题需要解决。</p><p> In the meantime, any extra information has to be passed though a side-channel ( eg). This is annoying and error-prone.</p><p>在此期间，任何额外的信息都必须通过旁路(例如)传递。这很烦人，而且容易出错。</p><p>      function List(comptime T: type) type { return struct { value: T, next: ?List(T), def len(self: *const List(T)) usize { return 1 + if (self.next) |next| next.len() else 0; } };}</p><p>函数列表(comptime T：type)类型{return struct{value：T，next：？list(T)，def len(self：*const list(T))usize{return 1+if(self.next)|next|next.len()Else 0；}}；}。</p><p>  You can also insert arbitrary logic into that function. Here is a function that implements the  struct-of-arrays transformation:</p><p>您还可以在该函数中插入任意逻辑。下面是一个实现数组结构转换的函数：</p><p> fn StructOfArrays(comptime T: type) type { // reflect info about the type T const t_info = @typeInfo(T); // check that T is a struct if (t_info != .Struct) @compileError(&#34;StructOfArrays only works on structs!&#34;); // make a new set of fields where each type is an array var soa_fields: [t_info.Struct.fields.len]std.builtin.TypeInfo.StructField = undefined; for (t_info.Struct.fields) |t_field, i| { var soa_field = t_field; soa_field.field_type = []t_field.field_type; soa_field.default_value = null; soa_fields[i] = soa_field; } // make a new type with those array fields var soa_info = t_info; soa_info.Struct.fields = &amp;soa_fields; const Inner = @Type(soa_info); // return the final type return struct { inner: Inner, const Self = @This(); /// Fetch the i&#39;th element of self fn get(self: *const Self, i: usize) T { var t: T = undefined; // for each field of t, get the data from the i&#39;th element of the corresponding array // (this is unrolled at compile time because of the `inline` keyword) inline for (t_info.Struct.fields) |t_field| { @field(t, t_field.name) = @field(self.inner, t_field.name)[i]; } return t; } };}</p><p>Fn StructOfArray(comptime T：type)type{//反映有关类型T的信息const t_info=@typeInfo(T)；//如果(t_info！=.Struct)@compileError(&#34；StructOfArray仅适用于结构！&#34；)；//新建一组字段，其中每种类型都是一个数组var SOA_FIELS：[t_info.Struct.fields.len]std.builtin.TypeInfo.StructField=未定义；对于(t_info.Struct.field)|t_field，i|{var soa_field=t_field；soa_field.field_type=[]t_field.field_type；soa_field.default_value=null；soa_field[i]=soa_field；}//用这些数组字段var soa_info=t_info；soa_info.Struct.field=&amp；soa_field；const INTERNAL=@Type(SOA_INFO)；//返回最终类型返回结构{Internal：Internal，const self=@this()；/获取自身fn get(self：*const self，i：usize)T的第i&#39；个元素{var t：t=unfined；//对于t的每个字段，从i&#39；(t_info.Struct.field)|t_field|{@field(t，t_field.name)=@field(self.ner，t_field.name)[i]；}return t；}的内联对应数组的第个元素//(由于关键字`inline`而在编译时展开)|t_field|{@field(t，t_field.name)=@field(self.iner，t_field.name)[i]；}return t；}}；}。</p><p> While verbose, this is built entirely out of tools that I learned in the first few days of using zig. I think the only way to implement the same example in rust would be with a  custom derive but I haven&#39;t yet learned how to write procedural macros.</p><p>虽然冗长，但这完全是由我在使用ZIG的最初几天学到的工具构建的。我认为在Ruust中实现相同示例的唯一方法是使用自定义派生，但我还没有学会如何编写过程性宏。</p><p>  In rust, you can use  #[derive(Ord)] to create a default implementation of the  Ord trait for a type. If you don&#39;t do this, users of your library  cannot do it themselves because of the orphan impl rules. If you do do this, users of your library pay for the extra compile time even if they never use it.</p><p>在Rust中，可以使用#[Derate(Ord)]为类型创建Ord特征的默认实现。如果您不执行此操作，则由于孤立实施规则，您的库的用户无法自己执行此操作。如果您这样做，您的库的用户将为额外的编译时间付费，即使他们从未使用过它。</p><p>  pub fn compare(a: anytype, b: @TypeOf(a)) Ordering { const T = @TypeOf(a); if (std.meta.trait.hasFn(&#34;compare&#34;)(T)) { // if T has a custom implementation of compare, use that return T.compare(a, b); } else { // otherwise, use reflection to derive a default implementation switch (@typeInfo(T)) { ... } }}</p><p>Pub FN Compare(a：anytype，b：@typeof(A))排序{const T=@typeof(A)；if(std.meta.trait.hasFn(&#34；Compare&#34；)(T)){//如果T具有Compare自定义实现，则使用返回T.Compare(a，b)；}Else{/否则，使用反射派生默认实现开关(@typeInfo(T)){...}}</p><p>  This function works on any type, even those from other packages, can be overridden on a type-by-type basis and will only be compiled for functions on which it is actually used. With a  little extra work it can also be made extensible by third-party libraries which didn&#39;t create the original type.</p><p>此函数适用于任何类型，即使是来自其他包的类型，也可以逐个类型重写，并且仅为实际使用它的函数编译。只需做一点额外的工作，它也可以由没有创建原始类型的第三方库进行扩展。</p><p>  Zig&#39;s compilation is lazy. Only code which is actually reachable needs to typecheck. So if you run  zig test --test-filter the_one_test_i_care_about_right_now then only the code used for that test needs to typecheck. This makes it much easier to test quick changes and to incrementally refactor code.</p><p>Zig的编译是懒惰的。只有实际可访问的代码才需要进行类型检查。因此，如果您运行zig test--test-filter the_one_test_i_care_about_right_now，那么只需要对用于该测试的代码进行类型检查。这使得测试快速更改和增量重构代码变得容易得多。</p><p>   I came across  this article while taking a break from repeatedly failing to cross-compile a rust+gtk hello world for the pinephone and had a working zig version within a few hours.</p><p>我是在反复未能为Pinephone交叉编译Rust+GTK hello world而休息时读到这篇文章的，几个小时内就有了一个工作正常的zig版本。</p><p> The zig compiler includes sources for it&#39;s own standard library and sources for libc for various platforms, so there is no need for a tool like  xargo.</p><p>Zig编译器包括它自己的标准库的源代码和各种平台的libc源代码，因此不需要像xargo这样的工具。</p><p> On a side note, I was also able to compile the zig+gtk hello world directly on the pinephone, whereas compiling the rust+gtk hello world requires 2.8gb of memory, ~10x as much as the zig version and more than the 2gb available on the phone.</p><p>另外，我还可以直接在Pinephone上编译zig+gtk hello world，而编译rust+gtk hello world需要2.8 GB的内存，大约是zig版本的10倍，超过手机上可用的2 GB。</p><p>  Zig has an experimental build system where the build graph is assembled by zig code. This makes it easy to have various different build tasks and share logic between them. Each task gets tied to a command with some comments which show up in  zig build --help so it&#39;s easy to see what&#39;s available.</p><p>ZIG有一个实验性的构建系统，其中构建图由ZIG代码组装。这使得拥有各种不同的构建任务并在它们之间共享逻辑变得容易。每个任务都与带有一些注释的命令捆绑在一起，这些注释显示在zig build--help中，因此很容易看到可用的内容。</p><p> Rust has a fixed declarative format in  Cargo.toml. It offers four built-in profiles and  doesn&#39;t yet allow creating more. It determines the list of targets and which profile to use for each by looking in some predefined directories.</p><p>Ruust在Cargo.toml中有固定的声明格式。它提供了四个内置配置文件，并且还不允许创建更多配置文件。它通过查找一些预定义的目录来确定目标列表以及每个目标要使用的配置文件。</p><p> In materialize this doesn&#39;t work out - there are more than four profiles needed. Eg one of the test suites is too slow to run without optimizations but it still needs things like overflow checks turned on. It&#39;s also often useful to run some target with various different settings. I end up just writing shell scripts that override the profile settings.</p><p>在具体化中，这是行不通的-需要四个以上的配置文件。例如，其中一个测试套件运行速度太慢，无法在没有优化的情况下运行，但它仍然需要打开溢出检查之类的功能。使用各种不同设置运行某些目标通常也很有用。我最终只编写了覆盖配置文件设置的shell脚本。</p><p> build.zig also handles tasks like compiling and linking c libraries. In rust, this requires a  build.rs file which is yet another system to learn.</p><p>Zig还处理编译和链接c库等任务。在rust中，这需要一个build.rs文件，这是另一个需要学习的系统。</p><p> To be fair, zig doesn&#39;t yet have a package manager so it doesn&#39;t have to worry about trying to compose build options from various projects. But I expect that specifying the range of options with code rather than a configuration file will still be the simpler choice.  Nix and  Guix are good prior art here - both make it easy to express arbitrary modifications to dep</p><p>公平地说，ZIG还没有包管理器，所以它不必担心试图组合各种项目的构建选项。但我希望使用代码而不是配置文件来指定选项范围仍然是更简单的选择。NIX和Guix在这里是很好的现有技术-这两种技术都使得表达任意修改dep变得很容易。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://scattered-thoughts.net/writing/assorted-thoughts-on-zig-and-rust/">https://scattered-thoughts.net/writing/assorted-thoughts-on-zig-and-rust/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/铁锈/">#铁锈</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/thoughts/">#thoughts</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/zig/">#zig</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1029945.html"><img src="http://img2.diglog.com/img/2020/10/thumb_c180ce97ee44e8390bdcf0f0cdfccb0b.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029945.html">BillTrust是一家生产处理B2B支付的基于云的软件的公司，该公司将通过SPAC合并在纳斯达克上市，交易价值13亿美元</a></div><span class="my_story_list_date">2020-10-20 10:41</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029849.html"><img src="http://img2.diglog.com/img/2020/10/thumb_424092b0899178aabc16e3d041fa5bd2.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029849.html">欧盟反垄断监管机构再次将谷歌/Fitbit合并的决定截止日期延长至2021年1月8日；与此同时，Fitbit的市场份额继续流失</a></div><span class="my_story_list_date">2020-10-20 0:53</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029837.html"><img src="http://img2.diglog.com/img/2020/10/thumb_d00bea1d733a315169cdb424db866d1f.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029837.html">谷歌关闭其紧急位置共享应用Trusted Contacts</a></div><span class="my_story_list_date">2020-10-19 23:53</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029690.html"><img src="http://img2.diglog.com/img/2020/10/thumb_7bace9cca35abf0879053ee32d147eb3.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029690.html">谷歌将于12月2日停止其受信任的联系人应用程序，转而将用户引导至地图功能；该应用程序可帮助用户在紧急情况下查看联系人</a></div><span class="my_story_list_date">2020-10-19 9:22</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>