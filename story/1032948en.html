<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>AWS上的ABAC状态</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">AWS上的ABAC状态</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-03 17:44:12</div><div class="page_narrow text-break page_content"><p>Two years ago, in November 2018, AWS  announced new conditions keys  aws:PrincipalTag and  aws:RequestTag, and  started to push the concept of Attribute Based Access Control (ABAC). This post will describe what this is, the difficulties with implementing this strategy, and what AWS needs to do for customers to be successful with this concept.</p><p>两年前，也就是2018年11月，AWS公布了新的条件密钥aws：prinalTag和aws：RequestTag，并开始推动基于属性的访问控制(ABAC)概念。这篇文章将描述这是什么，实施这一战略的困难，以及AWS需要做些什么才能让客户成功地使用这一概念。</p><p>  A long standing problem with AWS security has been that if you had two projects in a single AWS account, it was often impossible to ensure that some principals (meaning the users and roles there) could only interact with the resources of one project and not the other. In order to implement a least privilege strategy, you want to isolate the actions each principal can take to only certain resources to ensure they cannot impact or exfil data from the other project.</p><p>AWS安全的一个长期问题是，如果您在一个AWS帐户中有两个项目，通常无法确保某些主体(即那里的用户和角色)只能与一个项目的资源交互，而不能与另一个项目的资源交互。为了实现最低权限策略，您需要隔离每个主体只能对某些资源执行的操作，以确保它们不会影响其他项目或从其他项目中导出数据。</p><p> The solution many customers have been forced to adopt is to isolate their projects into separate AWS accounts, but that’s not always ideal. For example, it can be difficult to take an existing account and move resources into another account as an account grows. So AWS started focusing on tagging resources and restricting access via tags. Over time, many privileges started to be able to work with the condition key  aws:ResourceTag so that you could restrict who could interact with an existing resource. But what if you wanted the principal to create new resources, but restrict what tags they could use, so they couldn’t create a resource with the tag of another project? For this AWS  released  aws:RequestTag.</p><p>许多客户被迫采用的解决方案是将他们的项目隔离到单独的AWS帐户中，但这并不总是理想的。例如，随着帐户的增长，很难采用现有帐户并将资源移动到另一个帐户。因此，AWS开始专注于标记资源并通过标记限制访问。随着时间的推移，许多特权开始能够使用条件键aws：ResourceTag，这样您就可以限制谁可以与现有资源交互。但是，如果您希望主体创建新资源，但限制他们可以使用的标记，这样他们就不能使用另一个项目的标记创建资源，那该怎么办呢？为此，AWS发布了AWS：RequestTag。</p><p> What if you had many principals and projects and you didn’t want to create separate IAM policies for each one? You want a single policy that you can apply to all principals that says “Only interact with resources that match the same tag as you have” or the common request of “You can only interact with resources you created.” To implement this concept, AWS released  aws:PrincipalTag, so you could now use a conditions such as:</p><p>如果您有许多主体和项目，并且不想为每个主体和项目创建单独的IAM策略，该怎么办？您需要一个可以应用于所有主体的策略，即“仅与与您拥有的相同标记匹配的资源交互”或“您只能与您创建的资源交互”的公共请求。为了实现这一概念，AWS发布了aws：prinalTag，因此您现在可以使用以下条件：</p><p>  Attribute-based access control (ABAC) is an authorization strategy that defines permissions based on attributes, which on AWS means tags. Two of the best resources on this concept are  Brigid Johnson’s re:Inforce talk  Scale Permissions Management in AWS w/ Attribute-Based Access Control and  Michael Chan’s blog post  Working backward: From IAM policies and principal tags to standardized names and tags for your AWS resources.</p><p>基于属性的访问控制(ABAC)是一种基于属性定义权限的授权策略，在AWS中属性意味着标签。关于这一概念，最好的两个资源是Brigid Johnson的Re：Inforce Talk Scale Permission Management in AWS w/Attribute-Based Access Control，以及Michael Chan的博客文章Working Backward：从IAM策略和主体标记到AWS资源的标准化名称和标记。</p><p>   The first issue people ran into with ABAC was that not all resources supported tags. Of those resources that did, not all supported IAM conditions to restrict these tags. Of those that did, not all supported tag on create, so you could only restrict access to tag existing resources, leaving resources untagged. Let’s get some stats on how much coverage AWS has today. Using the IAM data from  Parliament (which is just the AWS  docs scraped into a json file), we find there are 869 privileges that contain the word  create, which we can assume to be the privileges that grant permission to create a resource.</p><p>人们在使用ABAC时遇到的第一个问题是，并不是所有的资源都支持标签。在那些支持的资源中，并不是所有的资源都支持IAM条件来限制这些标签。在支持创建的资源中，并不是所有的资源都支持标记，因此您只能限制对现有资源的标记访问，而不对资源进行标记。让我们来了解一下AWS今天的覆盖范围。使用来自议会的IAM数据(只是将AWS文档拼凑到一个json文件中)，我们发现有869个权限包含单词create，我们可以假定这些权限是授予创建资源权限的权限。</p><p> $ cat parliament/iam_definition.json | jq &#39;.[]|.prefix as $prefix|.privileges[]|.privilege as $privilege|select($privilege|ascii_downcase|contains(&#34;create&#34;))|$prefix+&#34;:&#34;+$privilege&#39; | sort | uniq | wc -l 869</p><p>$cat议会/iam_finition.json|jq&#39；.[]|.prefix as$prefix|.Priviles[]|.Privilica as$privilege|select($privilege|ascii_downcase|contains(&#34；create&#34；))|$prefix+&#34；：&#34；+$privilege&#39；|SORT|uniq|wc-l 869。</p><p> Next, we’ll find all the privileges of these that allow the  RequestTag condition key:</p><p>接下来，我们将查找允许RequestTag条件键的所有权限：</p><p> $ cat parliament/iam_definition.json | jq &#39;.[]|.prefix as $prefix|.privileges[]|.privilege as $privilege|select($privilege|ascii_downcase|contains(&#34;create&#34;)).resource_types[].condition_keys[]|select(.|ascii_downcase |contains(&#34;requesttag&#34;))|$prefix+&#34;:&#34;+$privilege&#39; | sort | uniq | wc -l 381</p><p>$cat议会/iam_finition.json|jq&#39；.[]|.prefix as$prefix|.Priviles[]|.Privilica as$privilege|select($privilege|ascii_downcase|contains(&#34；create&#34；)).resource_types[].condition_keys[]|select(.|ascii_downcase|contains(&#34；requesttag&#34；))|$prefix+&#34；：&#34；+$privilege&#39；|SORT|uniq|wc-l381。</p><p> We find that 381 of 869 (43%) privileges for creating resources on AWS allows you to both tag the new resources and to restrict what tags are used for that. This search does miss some privileges that are used to create resources but do not include the word  create, such as  ec2:RunInstances that lets you create an EC2 and  route53:ChangeResourceRecordSets that lets you create a subdomain. It also misses situations where AWS has two privileges for creating a resource, where one privilege is used for creating the resource with tags and one without, such as  cloudfront:CreateDistribution and  cloudfront:CreateDistributionWithTags. However, 43% seems roughly correct.</p><p>我们发现，在AWS上创建资源的869个权限中，有381个(43%)允许您对新资源进行标记，并限制对其使用的标记。此搜索确实缺少用于创建资源的某些权限，但不包括单词create，例如允许您创建EC2的ec2：RunInstances和允许您创建子域的route53：ChangeResourceRecordSets。它还忽略了AWS具有两个创建资源的权限的情况，即一个权限用于创建带标记的资源，另一个权限不带标记，例如CloudFront：CreateDistribution和CloudFront：CreateDistributionWithTags。然而，43%似乎大致正确。</p><p> One might try to argue that the more widely used resources do support tag on create and restricting those tags, but there are some popular resources that do not. For example, the following privileges are all unable to restrict tag on create:  lambda:CreateFunction,  dynamodb:CreateTable,  kms:CreateKey,  logs:CreateLogGroup,  s3:CreateBucket,  sqs:CreateQueue&#34;, and  iam:CreateRole.</p><p>有人可能会试图争辩说，更广泛使用的资源确实支持在创建和限制那些标记时使用标记，但有些流行的资源并不支持。例如，以下权限都无法限制CREATE上的标签：lambda：CreateFunction、DynamoDB：CreateTable、KMS：CreateKey、Logs：CreateLogGroup、S3：CreateBucket、SQS：CreateQueue&#34；、IAM：CreateRole。</p><p> As a hack, for resources that don’t support tag on create, you can use the names of the resources in a similar way as a tag, but this is awkward.</p><p>作为一种技巧，对于不支持在创建时使用标记的资源，您可以使用与标记类似的方式使用资源的名称，但这很尴尬。</p><p>  Given a resource in an AWS account, there is not much tooling available that can tell you who all has access to it. Some tools (ex.  awspx) will tell you who has certain privileges, but they don’t understand conditions, among other details. So for example, they can tell you who has  secretsmanager:CreateSecret, but they won’t tell you who can create a secret with the tag  foo.</p><p>在给定AWS账户中的资源的情况下，没有多少可用的工具可以告诉您谁都有权访问它。一些工具(例如。Awspx)会告诉您谁拥有某些特权，但他们不了解条件等细节。例如，他们可以告诉您谁拥有secsmanager：CreateSecret，但不会告诉您谁可以使用标签foo创建秘密。</p><p> I built some functionality into  CloudMapper through it’s  access_check command that tries to understand more IAM logic. It has some understanding of conditions and will also take IAM Boundaries into consideration, but it does not understand the existing tags on a resource, and lacks a lot of other functionality. Its answers will be more correct than other tools for some questions, but will still be incorrect for a lot of cases. The project  PMapper also has some additional logic in it.</p><p>我通过试图理解更多IAM逻辑的access_check命令在CloudMapper中构建了一些功能。它对条件有一定的了解，也会考虑IAM边界，但是它不理解资源上的现有标记，并且缺乏很多其他功能。对于某些问题，它的答案将比其他工具更正确，但在许多情况下仍然是不正确的。项目PMapper中还包含一些额外的逻辑。</p><p>  There is an API called  SimulatePrincipalPolicy that can be used to understand who has access to resources, but it is missing a lot of functionality you would expect. For example, you can pass it the ARN of a principal, the ARN of a resource, and associated privilege to check for, but if there are any conditions, you then have to also include the condition values that should be used when checking this. This means you have to figure out the tags of the resource and the resource policy to then pass to this call.</p><p>有一个名为SimulatePrincalPolicy的API可用于了解谁有权访问资源，但它缺少许多您期望的功能。例如，您可以将主体的ARN、资源的ARN和要检查的关联权限传递给它，但如果有任何条件，则还必须包括检查时应使用的条件值。这意味着您必须找出资源的标记和资源策略，然后将其传递给此调用。</p><p> So for example, assume we have a principal that can call  secretsmanager:GetSecretValue only on secrets that have been tagged with a  project key that has a value  foo, and we have a secret with that tag. In order to check if our principal can access this secret, we can run:</p><p>因此，例如，假设我们有一个主体，它只能对已使用值为foo的项目键进行标记的秘密调用Secretsmanager：GetSecretValue，并且我们有一个带有该标记的秘密。为了检查我们的主体是否可以访问此密码，我们可以运行以下命令：</p><p> aws iam simulate-principal-policy \ --policy-source-arn arn:aws:iam::123456789012:user/testuser \ --action-names secretsmanager:getsecretvalue \ --resource-arns arn:aws:secretsmanager:us-east-1:123456789012:secret:test-abcdef \ --context-entries ContextKeyName=secretsmanager:ResourceTag/project,ContextKeyValues=foo,ContextKeyType=string</p><p>AWS IAM模拟-主体-策略\--策略-源-ARN ARN：AWS：IAM：：123456789012：用户/测试用户\--操作名称秘密管理器：获取秘密值\--资源-ARNS arn:aws:secretsmanager:us-east-1:123456789012:secret:test-abcdef\--上下文条目ContextKeyName=secretsmanager:ResourceTag/project，上下文键值=foo，上下文键值=字符串。</p><p> Notice in the last line, I have to tell it the value of the tag for the resource that I want it to check. The policy simulator does not figure that out for you. So if you were to try to automate this, you would have to make a describe call, knowing where in the response to find the tag value, and how to format the call to  SimulatePrincipalPolicy with this value. Also, if the IAM policy has unrelated condition keys for other privileges, you have to provide context keys for those too. Next, you have to provide the resource policy if one exists, the IAM boundary if one exists, and potentially other data.</p><p>请注意，在最后一行中，我必须告诉它我希望它检查的资源的标记值。策略模拟器不会为您计算出这一点。因此，如果您要尝试自动执行此操作，则必须执行Describe调用，知道在响应中的什么位置查找标记值，以及如何使用此值格式化对SimulatePrincalPolicy的调用。此外，如果IAM策略具有用于其他权限的不相关的条件键，则您也必须为这些权限提供上下文键。接下来，您必须提供资源策略(如果存在)、IAM边界(如果存在)以及可能的其他数据。</p><p>   Zelkova is an automated reasoning solution for IAM policies that was announced by AWS in 2017 and available for private beta. When I talk to people about the problem of understanding who has access what, this project often comes up as a possible option by those who aren’t familiar with what exactly it does. Unfortunately, Zelkova is an engine that you still have to figure out the inputs to. It can answer some IAM related questions, but for our goals of understanding who has access to what, it has all the same limitations as iam:SimulatePrincipalPolicy.</p><p>Zelkova是AWS于2017年发布的针对IAM策略的自动化推理解决方案，可供私人测试版使用。当我和人们谈论了解谁有权访问什么的问题时，这个项目经常被那些不熟悉它的确切功能的人作为一个可能的选择。不幸的是，Zelkova是一个引擎，你仍然需要弄清楚它的输入。它可以回答一些与IAM相关的问题，但是对于我们了解谁有权访问哪些内容的目标而言，它与IAM：SimulatePrincialPolicy具有相同的限制。</p><p>  An AWS Organization feature called  Tag Policies was supposed to help enforce tagging, but it is critically limited by only being able to enforce what tag values may be used when defined tag keys are used. This means you cannot enforce that a resource is tagged. You can only enforce that when someone attempts to tag a resource with a certain key, that the value is one of a defined set. In order to enforce tagging actually be used in an organization, you have to use SCPs as described  here.</p><p>AWS组织的一项称为标记策略的功能本应帮助强制执行标记，但它受到严重限制，因为它只能在使用定义的标记键时强制执行可能使用的标签值。这意味着您不能强制标记资源。只有当有人试图用某个键标记资源时，才能强制要求该值是定义的集合中的一个。为了强制在组织中实际使用标记，您必须按照此处所述使用SCP。</p><p>   Further, Tag Policies do not have coverage across all resources that support tags. The list of supported resources is  here. An example of a resource that supports tags, but is not supported by Tag Policies, is S3 objects.</p><p>此外，标签策略并不涵盖支持标签的所有资源。支持的资源列表在此处。支持标签但不受标签策略支持的资源的一个示例是S3对象。</p><p> AWS needs to extend the functionality of this feature to support enforcement of using tag keys, as there is little value in it in its current form.</p><p>AWS需要扩展此功能的功能，以支持强制使用标签密钥，因为其当前形式没有什么价值。</p><p>  People often work on multiple projects, but there is no way to tag a principal with a key that has multiple tag values. As an example, imagine you have two projects,  foo and  bar, and you want to allow a person to work on just  foo and all the resources they create should have a  Project tag with value  foo, and likewise you have another person who should only work on the  bar projects. AWS  has shown how to create a single IAM policy that can be applied to both people, and you’d just need to make sure to apply a  Project tag to the principals to define which project they can work on.</p><p>人们经常处理多个项目，但是无法使用具有多个标记值的键来标记主体。例如，假设您有两个项目，foo和bar，并且您希望允许一个人只处理foo，并且他们创建的所有资源都应该有一个值为foo的Project标记，同样，您还有一个人应该只处理bar项目。AWS已经展示了如何创建可应用于两个人的单一IAM策略，您只需确保将项目标签应用到委托人，以定义他们可以处理的项目。</p><p> Now imagine that one of these employees needs to work on both projects. You cannot tag a principal with both  foo and  bar. One solution is to have the person assume different IAM roles depending on which project they are working on. Another option would be to create a custom IAM policy for this person that hard-codes what projects they can work on, and therefore stops using the principal tag on them. Neither option seems ideal.</p><p>现在假设这些员工中的一个需要同时处理这两个项目。不能同时使用foo和bar标记主体。一种解决方案是让人员根据他们从事的项目承担不同的IAM角色。另一种选择是为此人创建自定义IAM策略，该策略对他们可以处理的项目进行硬编码，从而停止在这些项目上使用主体标签。这两个选择似乎都不理想。</p><p>  AWS has a concept of  transitive tags that will follow an entity as they assume between roles which can assist with auditing sessions. They have transitive tags for the creation of sessions, but not for other resources. It would be nice if this concept could be applied to any resources they create, such that EC2s and other resources are automatically tagged in some way as they are created, without the user having to specify those tags. So if a user is part of the  foo project, all the resources they create are automatically tagged as being part of  foo.</p><p>AWS有一个可传递标签的概念，当实体在不同角色之间承担时，这些标签将跟随在实体后面，这可以帮助审计会话。它们有用于创建会话的可传递标记，但没有用于其他资源的可传递标记。如果可以将此概念应用于它们创建的任何资源，这样EC2和其他资源在创建时就会以某种方式自动标记，而无需用户指定这些标记，那就太好了。因此，如果用户是foo项目的一部分，他们创建的所有资源都会自动标记为foo的一部分。</p><p>  Others outside of AWS have also written about the limitations and difficulties of ABAC, touching on other problems they’ve run into:</p><p>AWS以外的其他人也写到了ABAC的限制和困难，触及了他们遇到的其他问题：</p><p> Still Early Days for ABAC by  Ian McKay describes a bug he found where he could tag resources despite not having privileges to do so.</p><p>伊恩·麦凯(Ian McKay)所著的“ABAC的早期日子”描述了他发现的一个bug，他可以在那里标记资源，尽管他没有这样做的特权。</p><p>  Don’t use Tags to Manage Permissions in AWS by  Rowan Udell points out usability issues with tags.</p><p>不要使用标签来管理AWS中的权限，作者Rowan Udell指出了标签的可用性问题。</p><p>  Creating correct IAM policies to enforce tags is difficult. Some goals are impossible and some are awkward due to limitations of IAM. The limitations are not constant across resource types and these discrepancies add to the complexity. It is possible in some situations to define permissions based on tags, but it is not universally possible, so beware when attempting to adopt this strategy. AWS’s lack of company-wide direction and standardization is a regular source of frustration for customers.</p><p>创建正确的IAM策略来实施标记是困难的。由于IAM的限制，有些目标是不可能的，有些目标是尴尬的。各种资源类型的限制并不是恒定的，这些差异增加了复杂性。在某些情况下，可以基于标记定义权限，但不是所有情况下都可以，因此在尝试采用此策略时要小心。AWS缺乏全公司范围的指导和标准化，这经常让客户感到沮丧。</p><p> One of the biggest problems on AWS that has a relatively straightforward solution, is tooling to understand environments, such as who has access to which resources. I would love for AWS to increase investment in this area, such as by improving the SimulatePrincipalPolicy API to automatically figure out the conditions involved in a call. Until they do so, or someone else does, attempting to define permissions based on tags is going to be unnecessarily difficult, and your best strategy for security boundaries, for a variety of reasons, will continue to be to use separate AWS accounts.</p><p>具有相对简单解决方案的AWS上最大的问题之一是了解环境的工具，例如谁有权访问哪些资源。我希望AWS能够增加在这方面的投资，例如通过改进SimulatePrincalPolicy API来自动计算出呼叫中涉及的条件。在他们这样做之前，或者其他人这样做之前，尝试基于标签定义权限将是不必要的困难，出于各种原因，您安全边界的最佳策略将继续是使用单独的AWS帐户。</p><p>  If you’re interested in learning more about AWS Security, I provide  training, including remote training!</p><p>如果您有兴趣了解更多关于AWS安全的知识，我提供培训，包括远程培训！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://summitroute.com/blog/2020/11/02/state_of_abac_on_aws/">https://summitroute.com/blog/2020/11/02/state_of_abac_on_aws/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/abac/">#abac</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/标记/">#标记</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>