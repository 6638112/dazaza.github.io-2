<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>piscina  -  node.js工作台 Piscina – The Node.js Worker Pool</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Piscina – The Node.js Worker Pool<br/>piscina  -  node.js工作台 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-24 03:11:06</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/eb7d7e9d30a31036d54e9bd7370cce61.png"><img src="http://img2.diglog.com/img/2021/3/eb7d7e9d30a31036d54e9bd7370cce61.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>const  path  =  require ( &#39;path&#39; ) ; const  Piscina  =  require ( &#39;piscina&#39; ) ; const  piscina  =  new  Piscina ( {  filename:  path . resolve ( __dirname ,  &#39;worker.js&#39; ) } ) ; ( async  function ( )  {  const  result  =  await  piscina . runTask ( {  a:  4 ,  b:  6  } ) ;  console . log ( result ) ;  // Prints 10 } ) ( ) ;</p><p>const路径=要求（＆＃39;路径＆＃39;）; const piscina =要求（＆＃39; piscina＆＃39;）; const piscina = new piscina（{filename：path。解析（__dirname，＆＃39; worker.js＆＃39;）}）; （async函数（）{const结果= await piscina。runtask（{a：4，b：6}）;控制台。日志（结果）; //打印10}）（）;</p><p>    const  { promisify  }  =  require ( &#39;util&#39; ) ; const  sleep  =  promisify ( setTimeout ) ; module . exports  =  async  ( { a , b  } )  =&gt;  {  // Fake some async activity  await  sleep ( 100 ) ;  return  a  +  b ; } ;</p><p>    const {promisify} =要求（＆＃39; util＆＃39;）; Const Sleep = ProMisify（Settimout）;模块 。导出=异步（{a，b}）=＆gt; {//假冒一些异步活动等待睡眠（100）;返回一个+ b; };</p><p>  import  {  Piscina  }  from  &#39;piscina&#39; ; const  piscina  =  new  Piscina ( {  // The URL must be a file:// URL  filename:  new  URL ( &#39;./worker.mjs&#39; ,  import . meta . url ) . href } ) ; ( async  function  ( )  {  const  result  =  await  piscina . runTask ( {  a:  4 ,  b:  6  } ) ;  console . log ( result ) ;  // Prints 10 } ) ( ) ;</p><p>  从＆＃39导入{piscina}; piscina＆＃39; ; const piscina = new piscina（{// url必须是文件：// url文件名：新网址（＆＃39; ./ worker./ worker.mjs＆＃39;，导入meta。url）。href}; （async函数（）{const结果= await piscina。runtask（{a：4，b：6}）;控制台。日志（结果）; //打印10}）（）;</p><p>     &#39;use strict&#39; ; const  Piscina  =  require ( &#39;piscina&#39; ) ; const  { AbortController  }  =  require ( &#39;abort-controller&#39; ) ; const  { resolve  }  =  require ( &#39;path&#39; ) ; const  piscina  =  new  Piscina ( {  filename:  resolve ( __dirname ,  &#39;worker.js&#39; ) } ) ; ( async  function ( )  {  const  abortController  =  new  AbortController ( ) ;  try  {  const  task  =  piscina . runTask ( {  a:  4 ,  b:  6  } ,  abortController . signal ) ;  abortController . abort ( ) ;  await  task ;  }  catch  ( err )  {  console . log ( &#39;The task was canceled&#39; ) ;  } } ) ( ) ;</p><p>     ＆＃39;使用严格＆＃39; ; const piscina =要求（＆＃39; piscina＆＃39;）; const {abortController} =要求（＆＃39;中止控制器＆＃39;）; const {解析} =要求（＆＃39;路径＆＃39;）; const piscina = new piscina（{filename：解析（__dirname，＆＃39; worker.js＆＃39;）}）; （async函数（）{const abortcontroller = new abortcontroller（）;尝试{const task = piscina。runtask（{a：4，b：6}，abortcontroller。信号）; abortController。abortController。abort（）;等待任务;捕获（ err）{控制台。日志（＆＃39;任务被取消＆＃39;）;}}）;</p><p>  (In Node.js 15.0.0 or higher, there is a new built-in  AbortControllerimplementation that can be used here as well.)</p><p>  （在Node.js 15.0.0或更高版本中，还有一个新的内置abortiontrollerimplictation，也可以在此处使用。）</p><p>  &#39;use strict&#39; ; const  Piscina  =  require ( &#39;piscina&#39; ) ; const  EventEmitter  =  require ( &#39;events&#39; ) ; const  { resolve  }  =  require ( &#39;path&#39; ) ; const  piscina  =  new  Piscina ( {  filename:  resolve ( __dirname ,  &#39;worker.js&#39; ) } ) ; ( async  function ( )  {  const  ee  =  new  EventEmitter ( ) ;  try  {  const  task  =  piscina . runTask ( {  a:  4 ,  b:  6  } ,  ee ) ;  ee . emit ( &#39;abort&#39; ) ;  await  task ;  }  catch  ( err )  {  console . log ( &#39;The task was canceled&#39; ) ;  } } ) ( ) ;</p><p>  ＆＃39;使用严格＆＃39; ; const piscina =要求（＆＃39; piscina＆＃39;）; Const Eventemitter =要求（＆＃39;事件＆＃39;）; const {解析} =要求（＆＃39;路径＆＃39;）; const piscina = new piscina（{filename：解析（__dirname，＆＃39; worker.js＆＃39;）}）; （async函数（）{const ee = new envertemitter（）;尝试{const task = piscina。runtask（{a：4，b：6}，ee）; ee。发射（＆＃39;中止＆＃39;）;等待任务;} catch（错误）{控制台。日志（＆＃39;任务被取消＆＃39;）;}}）;</p><p>  A worker thread will not be made available to process tasks until Piscinadetermines that it is &#34;ready&#34;. By default, a worker is ready as soon asPiscina loads it and acquires a reference to the exported handler function.</p><p>  工人线程不会用于处理任务，直到PiscinadeTermines是＆＃34; Ready＆＃34;默认情况下，一旦asisiscina加载它并获取对导出的处理程序函数的引用即可备注。 </p><p> There may be times when the availability of a worker may need to be delayedlonger while the worker initializes any resources it may need to operate.To support this case, the worker module may export a  Promise that resolvesthe handler function as opposed to exporting the function directly:</p><p>有时，在工人初始化任何资源时，工人的可用性可能需要延迟，可能需要操作。要支持这种情况，工作模块可能会导出解析vistive处理程序功能而不是直接导出函数：</p><p> async  function  initialize ( )  {  await  someAsyncInitializationActivity ( ) ;  return  ( { a , b  } )  =&gt;  a  +  b ; } module . exports  =  initialize ( ) ;</p><p> async函数initialize（）{await someasyncinitializationActivity（）;返回（{a，b}）=＆gt; A + B; } 模块 。导出= initialize（）;</p><p>   When the  maxQueue option is set, once the  Piscina queue is full, noadditional tasks may be submitted until the queue size falls below thelimit. The  &#39;drain&#39; event may be used to receive notification when thequeue is empty and all tasks have been submitted to workers for processing.</p><p>   设置maxqueue选项时，一旦Piscina队列已满，可以提交NoAditional任务，直到队列大小低于Thelimit。 ＆＃39;流失＆＃39;事件可用于在当水为空时接收通知，并且已将所有任务提交给工人进行处理。</p><p>  &#39;use strict&#39; ; const  { resolve  }  =  require ( &#39;path&#39; ) ; const  Pool  =  require ( &#39;../..&#39; ) ; const  pool  =  new  Pool ( {  filename:  resolve ( __dirname ,  &#39;worker.js&#39; ) ,  maxQueue:  &#39;auto&#39; } ) ; const  stream  =  getStreamSomehow ( ) ; stream . setEncoding ( &#39;utf8&#39; ) ; pool . on ( &#39;drain&#39; ,  ( )  =&gt;  {  if  ( stream . isPaused ( ) )  {  console . log ( &#39;resuming...&#39; ,  counter ,  pool . queueSize ) ;  stream . resume ( ) ;  } } ) ; stream  . on ( &#39;data&#39; ,  ( data )  =&gt;  {  pool . runTask ( data ) ;  if  ( pool . queueSize  ===  pool . options . maxQueue )  {  console . log ( &#39;pausing...&#39; ,  counter ,  pool . queueSize ) ;  stream . pause ( ) ;  }  } )  . on ( &#39;error&#39; ,  console . error )  . on ( &#39;end&#39; ,  ( )  =&gt;  {  console . log ( &#39;done&#39; ) ;  } ) ;</p><p>  ＆＃39;使用严格＆＃39; ; const {解析} =要求（＆＃39;路径＆＃39;）; const pool =要求（＆＃39; ../ ...和ad 39;）; const pool =新池（{filename：解析（__dirname，＆＃39; worker.js＆＃39;），maxqueue：＆＃39;自动＆＃39;}）; const Stream = GetStreamSomeHow（）;溪流 。 setencoding（＆＃39; utf8＆＃39;）;水池 。在（＆＃39;漏极和＃39;（）=＆gt; {if（stream。ispaused（））{控制台。日志（＆＃39;恢复...＆＃39;柜台，池。排队）;流。Resume（）;}}）;溪流  。在（＆＃39;数据＆＃39;（数据）=＆gt; {池。runtask（数据）;如果（池。queuesize ===池。选项。maxqueue）{控制台。日志（＆＃39;暂停。 ..＆＃39;，计数器，池。queue化）;流。暂停（）;}}）。 ON（＆＃39;错误＆＃39;，控制台。错误）。在（＆＃39; ext＆＃39;，（）=＆gt; {控制台。日志（＆＃39; done＆＃39;）;</p><p>    Piscina works by creating a pool of Node.js Worker Threads to whichone or more tasks may be dispatched. Each worker thread executes asingle exported function defined in a separate file. Whenever atask is dispatched to a worker, the worker invokes the exportedfunction and reports the return value back to Piscina when thefunction completes.</p><p>    Piscina通过创建一个节点.js工作池，可以调度到哪个或更多任务。每个工作线程在单独文件中执行asingle导出的函数。每当atask被调入工作者时，工作者都会调用导出功能，并在函数完成时将返回值报告回Piscina。</p><p>   The following optional configuration is supported: filename: ( string | null) Provides the default source for the code thatruns the tasks on Worker threads. This should be an absolute path or anabsolute  file:// URL to a file that exports a JavaScript  function or async function as its default export or  module.exports.  ES modulesare supported.</p><p>   支持以下可选配置：filename :( String | null）为代码提供了ThomRuns在工作线程上的任务的默认源。这应该是一个绝对路径或AnaBsolute文件：// filed for oc属于将JavaScript函数或async函数导出为其默认导出或module.exports的文件。 es moduesare支持。</p><p> minThreads: ( number) Sets the minimum number of threads that are alwaysrunning for this thread pool. The default is based on the number ofavailable CPUs.</p><p> minthreads :( number）设置始终为此线程池的最小线程数。默认值基于AVailable CPU的数字。 </p><p> maxThreads: ( number) Sets the maximum number of threads that arerunning for this thread pool. The default is based on the number ofavailable CPUs.</p><p>maxthreads :( number）设置为此线程池进行arerunning的最大线程数。默认值基于AVailable CPU的数字。</p><p> idleTimeout: ( number) A timeout in milliseconds that specifies how longa  Worker is allowed to be idle, i.e. not handling any tasks, before it isshut down. By default, this is immediate.  Tip:  The default  idleTimeoutcan lead to some performance loss in the application because of the overheadinvolved with stopping and starting new worker threads. To improve performance,try setting the  idleTimeout explicitly.</p><p> iDletimeout :( number）以毫秒为单位，指定允许Wonga Worker如何空闲，即在ISShut之前不处理任何任务。默认情况下，这是立即的。提示：默认的idleyoutcan导致应用程序中的某些性能损失，因为停止和启动新的工人线程过度播放。要提高性能，请尝试显式设置iDletimeout。</p><p> maxQueue: ( number |  string) The maximum number of tasks that may bescheduled to run, but not yet running due to lack of available threads, ata given time. By default, there is no limit. The special value  &#39;auto&#39;may be used to have Piscina calculate the maximum as the square of  maxThreads.When  &#39;auto&#39; is used, the calculated  maxQueue value may be found by checkingthe   options.maxQueue property.</p><p> maxqueue :(字符串）可以陷入困境的最大任务数，但尚未由于缺少可用的线程而尚未运行，则给定时间。默认情况下，没有限制。特殊价值＆＃39;自动＆＃39;可用于有piscina计算最大值作为maxthreads的正方形。当＆＃39;自动＆＃39;使用，可以通过检查选项.MaxQueue属性来找到计算的克苏索值。</p><p> concurrentTasksPerWorker: ( number) Specifies how many tasks can sharea single Worker thread simultaneously. The default is  1. This generallyonly makes sense to specify if there is some kind of asynchronous componentto the task. Keep in mind that Worker threads are generally not built forhandling I/O in parallel.</p><p> ConcurrentTasksperWorker：（Number）指定Sharea Single Worker线程可以同时使用多少任务。默认值为1.这一般地是有意义的，以指定是否存在某种异步组件对任务。请记住，工人线程通常并行地构建了i / o。</p><p> useAtomics: ( boolean) Use the   Atomics API for faster communicationbetween threads. This is on by default.</p><p> vereatomics :( boolean）使用原子学API更快的Companical2线程。默认情况下，这是开启的。</p><p> resourceLimits: ( object) See  Node.js new Worker options stackSizeMb : ( number) The default maximum stack size for the thread.Small values may lead to unusable Worker instances. Default: 4</p><p> resourcelimits :(对象）请参阅node.js新工作人员选项stacksizemb :( number）线程的默认最大堆栈大小.Small值可能导致无法使用的工人实例。默认值：4</p><p> env: ( object) If set, specifies the initial value of  process.env insidethe worker threads. See  Node.js new Worker options for details.</p><p> env :(对象）如果设置，则指定process.env Insidethe Worker线程的初始值。有关详细信息，请参阅Node.js新工人选项。 </p><p> argv: ( any[]) List of arguments that will be stringified and appended to process.argv in the worker. See  Node.js new Worker options for details.</p><p>argv :(任何[]）将被串联和附加到工人的Process.argv的参数列表。有关详细信息，请参阅Node.js新工人选项。</p><p> execArgv: ( string[]) List of Node.js CLI options passed to the worker.See  Node.js new Worker options for details.</p><p> EXECARGV :( String []）节点.js CLI选项的列表传递给Worker.see node.js新的工作者选项有关详细信息。</p><p> workerData: ( any) Any JavaScript value that can be cloned and madeavailable as  require(&#39;piscina&#39;).workerData. See  Node.js new Worker optionsfor details. Unlike regular Node.js Worker Threads,  workerData must notspecify any value requiring a  transferList. This is because the  workerDatawill be cloned for each pooled worker.</p><p> WorkerData：（任何）任何可以克隆的JavaScript值和MeDeavaulable，因为需要（＆＃39; piscina＆＃39;）。工作者。请参阅Node.js New Worker options以详细信息。与常规Node.js Worker线程不同，WorkerData必须指定需要传送列表的任何值。这是因为克隆了每个合并的工作者的人员。</p><p> taskQueue: ( TaskQueue) By default, Piscina uses a first-in-first-outqueue for submitted tasks. The  taskQueue option can be used to provide analternative implementation. See  Custom Task Queues for additional detail.</p><p> TaskQueue :( TaskQueue）默认情况下，Piscina使用了一个先进的任务的第一张外外。 TaskQueue选项可用于提供分析实现。有关其他详细信息，请参阅自定义任务队列。</p><p> niceIncrement: ( number) An optional value that decreases priority forthe individual threads, i.e. the higher the value, the lower the priorityof the Worker threads. This value is only used on Linux and requires theoptional   nice-napi module to be installed.See   nice(2) for more details.</p><p> NiceIncrement :(编号）一个可选的值，即在单个线程中减少优先级，即，值越高，工作线程的优先级越低。此值仅在Linux上使用，并需要安装Aptigional Nice-NAPI模块。将（2）欣赏到更多详细信息。</p><p> trackUnmanagedFds: ( boolean) An optional setting that, when  true, willcause Workers to track file descriptors managed using  fs.open() and fs.close(), and will close them automatically when the Worker exits.Defaults to  true. (This option is only supported on Node.js 12.19+ andall Node.js versions higher than 14.6.0).</p><p> trackunmanagedfds :( boolean）一个可选的设置，当为true时，将跟踪使用fs.open（）和fs.close（）管理的文件描述符的工人，并且当工作员退出到true时将自动关闭它们。 （此选项仅在高于14.6.0的Node.js 12.19+和所有Node.js版本上支持。</p><p> Use caution when setting resource limits. Setting limits that are too low mayresult in the  Piscina worker threads being unusable.</p><p> 设置资源限制时要小心。在Piscina工人线程中的梅雷曲板太低的设定限制是无法使用的。 </p><p>   transferList: An optional lists of objects that is passed to[ postMessage()] when posting  task to the Worker, which are transferredrather than cloned.</p><p>传输列表：将任务发布到工作人员时传递给[PostMessage（）]的可选对象列表，这些对象将转移到TransfortRather而不是克隆。</p><p> filename: Optionally overrides the  filename option passed to theconstructor for this task. If no  filename was specified to the constructor,this is mandatory.</p><p> filename：可选地覆盖传递给theconstructor的文件名选项以获取此任务。如果没有将文件名指定给构造函数，则这是强制性的。</p><p> abortSignal: An [ AbortSignal][] instance. If passed, this can be used tocancel a task. If the task is already running, the corresponding  Workerthread will be stopped.(More generally, any  EventEmitter or  EventTarget that emits  &#39;abort&#39;events can be passed here.) Abortable tasks cannot share threads regardlessof the  concurrentTasksPerWorker options.</p><p> abortsignal：[abortsignal] []实例。如果通过，这可以用来使用tocancel一个任务。如果任务已经运行，则将停止相应的工作者。（更一般地，发出＆＃39的任何EventEmitter或EventTarget;中止＆＃39;事件可以通过此处传递。</p><p> This returns a  Promise for the return value of the (async) function callmade to the function exported from  filename. If the (async) function throwsan error, the returned  Promise will be rejected with that error.If the task is aborted, the returned  Promise is rejected with an erroras well.</p><p> 这返回了从文件名导出的函数的（async）函数callmade返回值的承诺。如果（async）函数划分错误，则返回的承诺将被拒绝使用该错误。如果任务中止，则返回的承诺将被错误拒绝。</p><p>       All other errors are reported by rejecting the  Promise returned from runTask(), including rejections reported by the handler function itself.</p><p>       通过拒绝从runtask（）返回的承诺来报告所有其他错误，包括处理程序函数本身报告的拒绝。</p><p>        A copy of the options that are currently being used by this instance. Thisobject has the same properties as the options object passed to the constructor.</p><p>        此实例当前使用的选项的副本。此object属于与构造函数传递的选项对象相同的属性。</p><p>  A histogram summary object summarizing the collected run times of completedtasks. All values are expressed in milliseconds.</p><p>  总结完成任务的RUND时间的直方图摘要对象。所有值都以毫秒表示。 </p><p>  All properties following the pattern  p{N} where N is a number (e.g.  p1,  p99)represent the percentile distributions of run time observations. For example, p99 is the 99th percentile indicating that 99% of the observed run times werefaster or equal to the given value.</p><p>模式p {n}之后的所有属性，其中n是数字（例如p1，p99）表示运行时间观测的百分位分布。例如，P99是第99个百分位数，表明观察到的运行时间的99％尚不到或等于给定值。</p><p> {  average:  1880.25 ,  mean:  1880.25 ,  stddev:  1.93 ,  min:  1877 ,  max:  1882.0190887451172 ,  p0_001:  1877 ,  p0_01:  1877 ,  p0_1:  1877 ,  p1:  1877 ,  p2_5:  1877 ,  p10:  1877 ,  p25:  1877 ,  p50:  1881 ,  p75:  1881 ,  p90:  1882 ,  p97_5:  1882 ,  p99:  1882 ,  p99_9:  1882 ,  p99_99:  1882 ,  p99_999:  1882 }</p><p> {平均：1880.25，STDDEV：1.93，MIN：1877，MAX：1882.0190887451172，P0_001：1877，P0_01：1877，P0_1：1877，P1：1877，P2_5：1877，P10：1877，P50：1877，P50 ：1881，P75：1881，P90：1882，P97_5：1882，P99：1882，P99_9：1882，P99_99：1882，P99_999：1882}</p><p>      A point-in-time ratio comparing the approximate total mean run timeof completed tasks to the total runtime capacity of the pool.</p><p>      将近似总均值均值均值的时间比较与池总运行时容量进行比较。</p><p> A pools runtime capacity is determined by multiplying the  durationby the  options.maxThread count. This provides an absolute theoreticalmaximum aggregate compute time that the pool would be capable of.</p><p> 通过将optionBy.MaxThread计数乘以乘以乘以汇率来确定池运行时容量。这提供了绝对的理论上的聚合计算池能够的计算时间。</p><p> The approximate total mean run time is determined by multiplying themean run time of all completed tasks by the total number of completedtasks. This number represents the approximate amount of time thepool as been actively processing tasks.</p><p> 通过将所有已完成任务的全部完成任务的总数乘以所有已完成的任务的乘积来确定近似总平均运行时间。此数字表示近似的THEPOOL一直在主动处理任务。</p><p> The utilization is then calculated by dividing the approximate totalmean run time by the capacity, yielding a fraction between  0 and  1.</p><p> 然后通过将近似总芯片运行时间除以容量来计算利用，从而产生0到1之间的分数。</p><p>  A histogram summary object summarizing the collected times tasks spentwaiting in the queue. All values are expressed in milliseconds.</p><p>  总结在队列中占用的收集时间任务的直方图摘要对象。所有值都以毫秒表示。 </p><p>  All properties following the pattern  p{N} where N is a number (e.g.  p1,  p99)represent the percentile distributions of wait time observations. For example, p99 is the 99th percentile indicating that 99% of the observed wait times werefaster or equal to the given value.</p><p>模式p {n}之后的所有属性，其中n是数字（例如p1，p99）表示等待时间观察的百分位分布。例如，P99是第99个百分位数，表明99％的观察到的等待时间尚不到或等于给定值。</p><p> {  average:  1880.25 ,  mean:  1880.25 ,  stddev:  1.93 ,  min:  1877 ,  max:  1882.0190887451172 ,  p0_001:  1877 ,  p0_01:  1877 ,  p0_1:  1877 ,  p1:  1877 ,  p2_5:  1877 ,  p10:  1877 ,  p25:  1877 ,  p50:  1881 ,  p75:  1881 ,  p90:  1882 ,  p97_5:  1882 ,  p99:  1882 ,  p99_9:  1882 ,  p99_99:  1882 ,  p99_999:  1882 }</p><p> {平均：1880.25，STDDEV：1.93，MIN：1877，MAX：1882.0190887451172，P0_001：1877，P0_01：1877，P0_1：1877，P1：1877，P2_5：1877，P10：1877，P50：1877，P50 ：1881，P75：1881，P90：1882，P97_5：1882，P99：1882，P99_9：1882，P99_99：1882，P99_999：1882}</p><p>      By default, any value returned by a worker function will be cloned whenreturned back to the Piscina pool, even if that object is capable ofbeing transfered. The  Piscina.move() method can be used to wrap andmark transferable values such that they will by transfered rather thancloned.</p><p>      默认情况下，即使该对象能够转移，也将克隆回Piscina池时克隆任何由工作函数返回的任何值。 piscina.move（）方法可用于包装和标记可传输的值，使得它们将通过传输而不是传输。</p><p> The  value may be any object supported by Node.js to be transferable(e.g.  ArrayBuffer, any  TypedArray, or  MessagePort), or any objectimplementing the  Transferable interface.</p><p> 该值可以是Node.js支持的任何对象以可转换（例如，ArrayBuffer，任何TymedArray或MessagePort），或任何Objectimplementing可转换接口。</p><p>   The object returned by the  move() method should not be set as anested value in an object. If it is used, the  move() object itselfwill be cloned as opposed to transfering the object it wraps.</p><p>   移动（）方法返回的对象不应将其设置为对象中的敏感值。如果使用它，则移动（）对象本身克隆，而不是将其包裹的对象传输。</p><p>  Objects may implement the  Transferable interface to create their owncustom transferable objects. This is useful when an object beingpassed into or from a worker contains a deeply nested transferableobject such as an  ArrayBuffer or  MessagePort.</p><p>  对象可以实现可转换的接口以创建其AnyCuStom可转移对象。当呈向或从工作者呈现的对象包含深度嵌套的转换诸如ArrayBuffer或MessagePort时，这非常有用。</p><p> Transferable objects expose two properties inspected by Piscinato determine how to transfer the object. These properties arenamed using the special static  Piscina.transferableSymbol and Piscina.valueSymbol properties:</p><p> 可转移物体暴露了Piscinato检测的两个属性，确定如何传输对象。这些属性使用特殊的静态piscina.transferablesymbol和piscina.valuesymbol属性： </p><p> The  Piscina.transferableSymbol property provides the object(or objects) that are to be included in the  transferList.</p><p>piscina.transferablesymbol属性提供要包含在传送列表中的对象（或对象）。</p><p>   const  { move , transferableSymbol , valueSymbol }  =  require ( &#39;piscina&#39; ) ; module . exports  =  ( )  =&gt;  {  const  obj  =  {  a:  {  b:  new  Uint8Array ( 5 ) ;  } ,  c:  {  new  Uint8Array ( 10 ) ;  } ,  get  [ transferableSymbol ] ( )  {  // Transfer the two underlying ArrayBuffers  return  [ this . a . b . buffer ,  this . c . buffer ] ;  }  get  [ valueSymbol ] ( )  {  return  {  a:  {  b:  this . a . b  } ,  c:  this . c  } ;  }  } ;  return  move ( obj ) ; } ;</p><p>   const {move，transferablesymbol，supersymbol} =要求（＆＃39; piscina＆＃39;）;模块 。 Exports =（）=＆gt; {const obj = {a：{b：new uint8array（5）; }，C：{新UINT8ARRAY（10）; }，get [transferablesymbol]（）{//传输两个底层的arroundBuffers返回[此。一种 。湾缓冲区，这个。 C 。缓冲 ] ;获取[值ymbol]（）{return {a：{b：this。一种 。 b}，c：这。 C  } ; }};返回移动（obj）; };</p><p>  By default, Piscina uses a simple array-based first-in-first-out (fifo)task queue. When a new task is submitted and there are no availableworkers, tasks are pushed on to the queue until a worker becomesavailable.</p><p>  默认情况下，Piscina使用简单的基于数组的首先（FIFO）任务队列。提交新任务并没有可用的工作者时，将推送到队列，直到工作者成为可用。</p><p> If the default fifo queue is not sufficient, user code may replace thetask queue implementation with a custom implementation using the taskQueue option on the Piscina constructor.</p><p> 如果默认的FIFO队列不够，则用户代码可以使用Piscina构造函数上的TaskQueSue选项用自定义实现替换Thetask队列实现。</p><p>  interface  Task  {  readonly  [ Piscina . queueOptionsSymbol ] :  object  |  null ; } interface  TaskQueue  {  readonly  size :  number ;  shift  ( ) :  Task  |  null ;  remove  ( task :  Task ) :   void ;  push  ( task :  Task ) :   void ; }</p><p>  接口任务{readonly [piscina。 QueueOptionsSymbol]：对象|空值 ; }接口TaskQueue {ReadOnly Size：Number; Shift（）：任务|空值 ;删除（任务：任务）：void;推（任务：任务）：void; }</p><p> An example of a custom task queue that uses a shuffled priority queueis available in   examples/task-queue;</p><p> 使用示例/任务队列中可用的Shubububled Priority Queueis的自定义任务队列的示例;</p><p> The special symbol  Piscina.queueOptionsSymbol may be set as a propertyon tasks submitted to  runTask() as a way of passing additional optionson to the custom  TaskQueue implementation. (Note that because thequeue options are set as a property on the task, tasks with queueoptions cannot be submitted as JavaScript primitives).</p><p> 特殊符号piscina.queueOptionsSymbol可以设置为提交给RunTask（）的浮标任务，作为将其他替代单传递给自定义TaskQueue实现的方式。 （请注意，由于“当时”选项“设置为”任务“中的属性，因此无法将带有队列选项的任务作为JavaScript语义提交）。 </p><p>    Workers are generally optimized for offloading synchronous,compute-intensive operations off the main Node.js event loop thread.While it is possible to perform asynchronous operations and I/Owithin a Worker, the performance advantages of doing so will beminimal.</p><p>工人通常优化用于从主节点事件循环线程中卸载同步，计算密集型操作。虽然可以执行异步操作和I / OWITHIN一个工作人员，但这样做的性能优势将Beminimal。</p><p> Specifically, it is worth noting that asynchronous operationswithin Node.js, including I/O such as file system operationsor CPU-bound tasks such as crypto operations or compressionalgorithms, are already performed in parallel by Node.js andlibuv on a per-process level. This means that there will belittle performance impact on moving such async operations intoa Piscina worker (see examples/scrypt for example).</p><p> 具体而言，值得注意的是，异步操作With Node.js，包括文件系统操作函数CPU绑定任务，例如加密操作或压缩仪，这些任务已经由每个过程级别的Node.js和Libuv并行地执行。这意味着会贬低对Piscina工人移动这种诸如异步操作的性能影响（例如，参见示例/杂文）。</p><p>  Piscina provides the ability to configure the minimum andmaximum number of worker threads active in the pool, as well asset limits on the number of tasks that may be queued up waitingfor a free worker. It is important to note that setting the maxQueue size too high relative to the number of worker threadscan have a detrimental impact on performance and memory usage.Setting the  maxQueue size too small can also be problematicas doing so could cause your worker threads to become idle andbe shutdown. Our testing has shown that a  maxQueue size ofapproximately the square of the maximum number of threads isgenerally sufficient and performs well for many cases, but thiswill vary significantly depending on your workload. It will beimportant to test and benchmark your worker pools to ensure you&#39;veeffectively balanced queue wait times, memory usage, and workerpool utilization.</p><p>  Piscina提供了配置池中活动的最小和最大数量的工作线程的能力，以及可以排队等待自由工作者的任务数量的资产限制。重要的是要注意，将Maxqueue尺寸相对于工作人员的数量太高，对性能和内存使用产生了有害影响。静态尺寸太小也可能是有问题的，因此可能导致你的工作线变得闲置关掉。我们的测试表明，Maxqueue大小的大小千分之夸的线程的平方是出色的，对于许多情况来说，对于许多情况来说，但这都是根据你的工作量而差异很大。测试和基准测试和基准，以确保您＆＃39; VEEFFective平衡队列等待时间，内存用法和WorkerPool利用率。</p><p>  The thread pool maintained by Piscina has both a minimum and maximumlimit to the number of threads that may be created. When a Piscinainstance is created, it will spawn the minimum number of threadsimmediately, then create additional threads as needed up to thelimit set by  maxThreads. Whenever a worker completes a task, acheck is made to determine if there is additional work for it toperform. If there is no additional work, the thread is marked idle.By default, idle threads are shutdown immediately, with Piscinaensuring that the pool always maintains at least the minimum.</p><p>  由Piscina维护的线程池具有最小值和最大值，可以创建的线程数。创建PiscinainStance时，它将产生最小线程数，然后根据MaxThreads设置的Thelimit，创建其他线程。每当工人完成任务时，就会确定ACheck以确定是否有额外的工作。如果没有额外的工作，则线程标记为空闲.By默认值，立即关闭空闲线程，池仍然保持最小值。</p><p> When a Piscina pool is processing a stream of tasks (for instance,processing http server requests as in the React server-siderendering example in examples/react-ssr), if the rate in whichnew tasks are received and queued is not sufficient to keep workersfrom going idle and terminating, the pool can experience a thrashingeffect -- excessively creating and terminating workers that willcause a net performance loss. There are a couple of strategies toavoid this churn:</p><p> 当Piscina池正在处理任务流（例如，在示例/ React-SSR中的React Server-SircleDendering示例中处理HTTP服务器请求时），如果接收到新任务的速率并排队不足以保持工作人员闲置和终止，游泳池可以遇到ThrashingEffect  - 过度创建和终止工人遗漏净性能损失。有几种策略tavoid这次流失：</p><p> Strategy 1: Ensure that the queue rate of new tasks is sufficient tokeep workers from going idle. We refer to this as &#34;queue pressure&#34;.If the queue pressure is too low, workers will go idle and terminate.If the queue pressure is too high, tasks will stack up, experienceincreased wait latency, and consume additional memory.</p><p> 策略1：确保新任务的队列率足以闲置的工人。我们将此称为＆＃34;队列压力＆＃34;。如果队列压力太低，工人将闲置并终止。如果队列压力太高，则任务将堆叠，versiancread等待延迟，并占用额外的等待延迟记忆。</p><p> Strategy 2: Increase the  idleTimeout configuration option. Bydefault, idle threads terminate immediately. The  idleTimeout optioncan be used to specify a longer period of time to wait for additionaltasks to be submitted before terminating the worker. If the queuepressure is not maintained, this could result in workers sitting idlebut those will have less of a performance impact than the thrashingthat occurs when threads are repeatedly terminated and recreated.</p><p> 策略2：增加idlemout配置选项。 bydefault，空闲线程立即终止。 IDLETIMEOUT OptionCan可用于指定更长的时间段等待在终止工作人员之前要提交的其他要素。如果没有维护队列压力，这可能导致坐着的工人坐着，当线程重复终止和重新创建时，那些将缺乏的性能撞击的性能影响。 </p><p> Strategy 3: Increase the  minThreads configuration option. This hasthe same basic effect as increasing the  idleTimeout. If the queuepressure is not high enough, workers may sit idle indefinitely butthere will be less of a performance hit.</p><p>策略3：增加Minthreads配置选项。这具有与增加Idletimeout的基本效果相同。如果队列压力不够高，工人可能无限期地闲置，但仍将达到绩效令人沮丧。</p><p> In applications using Piscina, it will be most effective to use acombination of these three approaches and tune the various configurationparameters to find the optimum combination both for the applicationworkload and the capabilities of the deployment environment. Thereare no one set of options that are going to work best.</p><p> 在使用Piscina的应用中，使用这三种方法的丙蛋白是最有效的，并调整各种配置参数，以找到应用程序加载和部署环境的功能的最佳组合。 Oreare没有一套选择最好的选择。</p><p>  On Linux systems that support   nice(2), Piscina is capable of settingthe priority of every worker in the pool. To use this mechanism, an additionaloptional native addon dependency ( nice-napi,  npm i nice-napi) is required.Once   nice-napi is installed, creating a  Piscina instance with the niceIncrement configuration option will set the priority for the pool:</p><p>  在支持Nice（2）的Linux系统上，Piscina能够在池中的每个工人设置优先级。要使用此机制，需要一个其他可选的本机addon依赖项（Nice-Napi，NPM i Nice-Napi）。安装了Nice-Napi，使用NicePcrement配置选项创建Piscina实例将设置池的优先级：</p><p>  The higher the  niceIncrement, the lower the CPU scheduling priority will befor the pooled workers which will generally extend the execution time ofCPU-bound tasks but will help prevent those threads from stealing CPU time fromthe main Node.js event loop thread. Whether this is a good thing or not dependsentirely on your application and will require careful profiling to get correct.</p><p>  NicePecrement越高，CPU调度优先级的较低工人将是汇总的工人，它通常会扩展到跨界任务的执行时间，但有助于防止这些线程从主节点事件循环线程窃取CPU时间。无论这是一件好事还是不依赖于您的申请，并需要仔细的分析以获得正确。</p><p> The key metrics to pay attention to when tuning the  niceIncrement are thesampled run times of the tasks in the worker pool (using the   runTimeproperty) and the  delay of the Node.js main thread event loop.</p><p> 关键指标要注意调整NicePecrement时是工作池中任务的按次运行时间（使用RuntimeProperty）和Node.js主线程事件循环的延迟。</p><p>  Every  Piscina instance creates a separate pool of threads and operateswithout any awareness of the other. When multiple pools are created in asingle application the various threads may contend with one another, andwith the Node.js main event loop thread, and may cause an overall reductionin system performance.</p><p>  每个Piscina实例都会创建一个单独的线程池，并操作其他对方的任何意识。当在ASICE应用程序中创建多个池时，各种线程可以彼此竞争，并且具有Node.js主事件循环线程，并且可能导致整体证明系统性能。</p><p> Modules that embed Piscina as a dependency  should make it clear viadocumentation that threads are being used. It would be ideal if thosewould make it possible for users to provide</p><p> 嵌入Piscina作为依赖性的模块应该使其清除使用线程的虚拟度量。如果有可能为用户提供提供的人，那将是理想的 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/piscinajs/piscina">https://github.com/piscinajs/piscina</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/piscina/">#piscina</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/worker/">#worker</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/任务/">#任务</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>