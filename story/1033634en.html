<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>投产--学到的教训</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">投产--学到的教训</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-07 11:20:00</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/f7f2caa96921446fe0226e178a3094dc.png"><img src="http://img2.diglog.com/img/2020/11/f7f2caa96921446fe0226e178a3094dc.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I recently got a DevOps job that mostly involves writing a new backend system in Go completely from scratch. Here&#39;s what I learned having never actually used it in production, knowing it mostly just from personal projects.</p><p>我最近得到了一份DevOps的工作，主要是在Go中完全从头开始编写一个新的后端系统。这是我从没有在生产中实际使用过，主要是从个人项目中了解到的。</p><p>  At the start, we decided to try simply sticking with Go&#39;s http library and a simple routing library -   mux.</p><p>一开始，我们决定简单地坚持使用Go的Http库和一个简单的路由库 -MUX。</p><p>  Logging  -  I wanted some solution that would print information about each request, including body params, auth tokens, etc. (for debugging purposes).</p><p>记录 - 我想要一些解决方案，可以打印关于每个请求的信息，包括主体参数、身份验证令牌等(用于调试目的)。</p><p> Better error handling  -  I wanted the errors to still be JSON responses with an error message and code.</p><p>更好的错误处理 - 我希望错误仍然是带有错误消息和代码的JSON响应。</p><p> I had two options; implement solutions to the above problems myself, use different 3rd party libraries for each problem, or pick a web framework that already does most (if not all) of these things.</p><p>我有两个选择：我自己实现上述问题的解决方案，为每个问题使用不同的第三方库，或者选择一个已经完成了大部分(如果不是全部)这些事情的Web框架。</p><p> I eventually decided to use the Echo web framework. With almost 20k GitHub stars, a pretty active community, and great documentation I thought it was a great tool for the job.</p><p>我最终决定使用Echo web框架。有近20000位GitHub明星，一个相当活跃的社区，以及很棒的文档，我认为它是一个很好的工作工具。</p><p>  I also found there to be a little less boilerplate when it comes to writing the apps in  echo (mainly when parsing a json body, writing errors, and manually setting headers), leading to improved code readability.</p><p>我还发现，在使用ECHO编写应用程序时(主要是在解析json正文、编写错误和手动设置标题时)，样板文件会少一些，从而提高了代码的可读性。</p><p>  However the real difference in productivity will be noticed when you have slightly more complex endpoints. You&#39;ll often run into cases where you need to validate certain JSON fields, and you&#39;ll want meaningful error messages describing what&#39;s wrong. If you want to do that without any library, your code will quickly become much harder to read:</p><p>但是，当您的端点稍微复杂一些时，就会注意到生产率的真正差异。您经常会遇到需要验证某些JSON字段的情况，并且您会想要有意义的错误消息来描述错误所在。如果您想在没有任何库的情况下做到这一点，您的代码将很快变得更难阅读：</p><p>   Go web frameworks (or go in general) don&#39;t enforce any particular file structure. If you ever used something like ASP.NET/ASP.NET Core, you&#39;ll know what I&#39;m talking about when I say that some frameworks are tightly structured and many things are done implicitly by convention rather than explicitly specified.</p><p>Go Web框架(或Go一般)不强制任何特定的文件结构。如果你曾经使用过像ASP.NET/ASP.NET Core这样的东西，你就会知道我说的是什么，当我说一些框架结构紧凑，许多事情都是按照约定而不是显式指定的时候，你就会知道我在说什么。</p><p> The thing about Go is that it&#39;s really easy to skip learning about structuring your code and make it a hard to read+maintain mess. If you still don&#39;t know what I&#39;m talking about, here&#39;s an example of a ( bad) Go endpoint I wrote a while back:</p><p>关于围棋的事情是，它真的很容易跳过学习结构化你的代码，使它很难阅读和维护混乱。如果你仍然不知道我在说什么，下面是我前段时间写的一个(坏的)围棋终点的例子：</p><p>  Do you see what I mean? It&#39;s quite likely that the in total the &#34;better&#34; way will contain more lines in total after adding all the  CreateUser and  CreateAgency methods, but… It will be much easier to understand, reuse, debug, and modify later on as each method will have a single purpose.If you haven&#39;t already, I highly recommend you have a look at the following resources for a good code structure:</p><p>你明白我的意思吗？很可能在添加了所有CreateUser和CreateAgency方法之后，更好的方法总共将包含更多行，但…除外。以后理解、重用、调试和修改这些方法会容易得多，因为每个方法都只有一个目的。如果您还没有，我强烈建议您查看以下资源以获得良好的代码结构：</p><p> https://github.com/bxcodec/go-clean-arch - also a REST API example, but more strictly following the &#34;Clean Architecture&#34; concepts</p><p>Https://github.com/bxcodec/go-clean-arch - also一个rest API示例，但更严格地遵循清洁架构的概念。</p><p> In general, the concept is simple. You should separate the code that communicates with the database from the actual application logic itself, which should also stay separate from the transport/endpoint logic (in this example the HTTP endpoints).</p><p>一般来说，这个概念很简单。您应该将与数据库通信的代码与实际应用程序逻辑本身分开，实际应用程序逻辑本身也应该与传输/端点逻辑(在本例中是HTTP端点)分开。</p><p>  When I first started programming in Go, I wanted to use the least libraries possible, so of course I opted in for using the  database/sql package (with Postgres). Although the experience was OK, I came across quite a lot of boilerplate when querying data, especially having to use the Scan syntax.This lead me to the following 2 options:</p><p>当我第一次开始使用Go编程时，我希望尽可能少地使用库，所以我当然选择了使用数据库/SQL包(与Postgres一起)。虽然体验还可以，但在查询数据时，我遇到了相当多的样板，特别是必须使用扫描语法。这使我有了以下两个选项：</p><p> sqlx  -  a lightweight wrapper on top of  database/sql with some extensions that will make querying much easier.</p><p>SQLX- 是一个建立在数据库/SQL之上的轻量级包装器，它带有一些扩展，可以使查询变得更加容易。</p><p> gorm  -  an ORM (Object-Relational Mapping) library for Go, which generates SQL models and queries based on your Go models.</p><p>GORM-SQLGO的对象关系映射(Object-Relational Map， )库，它根据围棋模型生成SQL模型和查询。</p><p> I don&#39;t think there&#39;s a clear &#34;better&#34; library, in the end it comes down to the use case and preference.</p><p>我不认为有一个明确的更好的库，归根结底，它取决于用例和偏好。</p><p> gorm will probably make your life easier, especially if you often forget to add fields to queries after altering the database (because in gorm you won&#39;t have to do that at all).</p><p>GORM可能会让您的生活更轻松，特别是如果您经常忘记在更改数据库之后向查询添加字段(因为在GORM中您根本不需要这样做)。</p><p> sqlx on the other hand is much more SQL centric, it&#39;s more like writing Go code to interface with SQL rather than gorm &#39;s approach of generating SQL from Go code. It&#39;s nice if you prefer to have total control over your SQL and not having to learn new syntax of GORM.</p><p>另一方面，SQLX更多地以SQL为中心，它更像是编写Go代码来与SQL交互，而不是GORM从Go代码生成SQL的方法。如果你喜欢完全控制你的SQL，而不需要学习新的GORM语法，那就好了。</p><p>  One of the challenges I came across was configuring the project for production. There are always some differences between the dev and prod environments, such as what port the app should run on, the host and credentials for the database, and etc.</p><p>我遇到的挑战之一是为生产配置项目。开发环境和生产环境之间总是有一些不同之处，比如应用程序应该在哪个端口上运行、数据库的主机和凭据等等。</p><p> I&#39;ve seen people configure their app variables via JSON, YAML, or even gitignored .go files. I personally found env files to work the best, especially with docker-compose:</p><p>我见过人们通过JSON、YAML，甚至是GOG.go文件来配置他们的应用程序变量。我个人发现env文件工作得最好，尤其是使用docker-compose：</p><p> I usually combine these with the following utility functions: Building the Docker image is also extremely easy in Go.:</p><p>我通常将这些功能与以下实用功能结合使用：构建Docker镜像也非常容易：</p><p>  There are also a few other things that came to my mind that I didn&#39;t consider worth their own sections:</p><p>我脑海中还浮现出一些我认为不值得在他们自己的栏目中使用的东西：</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://tdom.dev/go-in-production">https://tdom.dev/go-in-production</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/学到/">#学到</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lessons/">#lessons</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>