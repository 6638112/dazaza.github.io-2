<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用茴香和L？VE进行光线行进</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">用茴香和L？VE进行光线行进</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-21 08:03:30</div><div class="page_narrow text-break page_content"><p>Previously I’ve decided to implement a rather basic  raycasting engine in ClojureScript.It was a lot of fun, an interesting experience, and ClojureScript was awesome.I’ve implemented small  labyrinth game, and thought about adding more features to the engine, such as camera shake, and wall height change.But when I’ve started working on these, I quickly understood, that I’d like to move on to something more interesting, like real 3D rendering engine, that also uses rays.</p><p>以前我已经决定在ClojureScript中实现一个相当基本的光线投射引擎。这非常有趣，体验非常棒。我已经实现了一个小迷宫游戏，并考虑在引擎中添加更多功能，比如相机抖动和墙高更改。但是当我开始研究这些功能时，我很快就明白了，我想要转到更有趣的东西上，比如也使用光线的真实3D渲染引擎。</p><p> Obviously, my first though was about writing a ray-tracer  1.This technique is wide known, and gained a lot of traction recently.With native hardware support for ray tracing, a lot of games are using it, and there are a lot of tutorials teaching how to implement one  2.In short, we cast a bunch of rays in 3D space, and calculate their trajectories, looking for what ray will hit and bounce off.Different materials have different bounce properties, and by tracing rays from camera to the source of light, we can imitate illumination.There are also a lot of different approaches how to calculate bouncing, e.g. for global illumination, and ambient light, but I’ve felt that it is a rather complicated task, for a weekend post.And unlike raycasting, most ray-tracers require polygonal information in order to work, where raycasting only need to know wall start and end points.</p><p>显然，我的第一个想法是关于编写光线跟踪器1。这项技术是广为人知的，最近获得了很大的吸引力。有了光线跟踪的本机硬件支持，很多游戏都在使用它，有很多教程讲授如何实现一个2。简而言之，我们在3D空间投射一束光线，并计算它们的轨迹，寻找哪些光线会击中和反弹。不同的材质有不同的反弹属性，通过跟踪从相机到光源的光线，我们可以模拟照明。还有很多不同的方法来计算反弹，例如对于全局照明，与光线投射不同，大多数光线跟踪器需要多边形信息才能工作，光线投射只需要知道墙的起点和终点。</p><p> I’ve wanted a similar approach for 3D rendering, where we specify an object in terms of it’s mathematical representation.Like for sphere, we’ll just specify coordinate of a center, and a radius, and our rays will find intersection points with it, providing us a sufficient data to draw this sphere on screen.And recently, I’ve read about a similar technique, that uses rays for drawing on screen, but instead of casting infinite rays as in raycasting, it marches a ray in terms of steps.And it also uses a special trick, to make this process very optimized, therefore we can use it for rendering real 3D objects.</p><p>我一直想要一种类似的3D渲染方法，我们根据对象的数学表示来指定对象。就像球体一样，我们只需指定一个中心的坐标和半径，我们的光线就会找到与它的交点，为我们在屏幕上绘制这个球体提供了足够的数据。最近，我读到了一个类似的技术，它使用光线在屏幕上绘制，但不是像光线投射那样投射无限的光线，而是按步骤行进一条光线。它还使用了一个特殊的技巧，使这个过程非常优化，因此我们可以使用它来渲染真实的3D对象。</p><p> I’ve decided to structure this post similarly to the one about raycasting, so this will be another long-read, often more about Fennel rather than raymarching, but at the end I promise that we’ll get something that looks like this:</p><p>我已经决定将这篇文章的结构与那篇关于光线投射的帖子类似，所以这将是另一篇阅读很久的文章，通常更多的是关于茴香而不是光线行进，但最后我保证我们会得到类似于以下内容的东西：</p><p>  So, just as in raycasting, first we need to do is to understand how raymarching engine works  on paper.</p><p>所以，就像光线投射一样，我们首先需要了解光线行进引擎是如何在纸上工作的。</p><p>  Raymarching can be illustrated similarly to raycaster, except it requires more steps until we could render our image.First, we need a camera, and an object to look at:</p><p>光线行进可以类似于光线投射器进行说明，不同之处在于它需要更多步骤才能渲染图像。首先，我们需要一个摄影机和一个要查看的对象：</p><p>  Our first step would to cast a ray, however, unlike with raycasting, we’ll cast a portion of a ray:</p><p>我们的第一步是投射光线，但是，与光线投射不同的是，我们将投射一部分光线：</p><p>  We then check, if the ray intersects with the sphere.It’s not, so we do one more step:</p><p>然后我们检查光线是否与球体相交。不是，所以我们再做一步：</p><p>    Oops, ray overshoot, and is now inside the sphere.This is not really good option for us, as we want for our rays to end directly at the object’s surface, without calculating intersection point with the object itself.We can fix this by casting shorter ray:</p><p>哎呀，光线过冲，现在位于球体内。这对我们来说并不是很好的选择，因为我们希望光线直接结束于对象的曲面，而不计算与对象本身的交点。我们可以通过投射较短的光线来修复此问题：</p><p>  However, this is very inefficient!And besides, if we’ll change the angle a bit or move the camera, we will overshoot again.Which means that we’ll either have incorrect result, or require a very small step size, which will blow up computation process.How we can fix this?</p><p>但是，这是非常低效的！而且，如果我们稍微改变角度或移动相机，我们又会过度拍摄，这意味着我们要么会得到错误的结果，要么需要很小的步长，这会破坏计算过程，我们如何解决这个问题呢？</p><p>  The solution to this is a signed distance function, or a so called Distance Estimator.Imagine if we knew how far we are from the object at any point of time?This would mean that we can shoot a ray of this length in any direction and still don’t hit anything.Let’s add another object to the scene:</p><p>这个问题的解决方案是一个带符号的距离函数，或所谓的距离估计器。想象一下，如果我们知道我们在任何时间点离对象有多远？这意味着我们可以向任何方向发射这种长度的光线，但仍然不会击中任何东西。让我们向场景中添加另一个对象：</p><p>  Now, let’s draw two circles, which will represent distances from the objects, to the point from where we’ll cast rays:</p><p>现在，让我们绘制两个圆，这两个圆将表示从对象到我们要投射光线的点的距离：</p><p>  We can see, that there are two circles, and one is bigger than another.This means, that if we choose the shortest safe distance, we can safely cast ray in any direction and not overshoot anything.For example, let’s cast a ray towards the square:</p><p>我们可以看到，有两个圆，一个比另一个大。这意味着，如果我们选择最短的安全距离，我们可以安全地向任何方向投射光线，任何东西都不会超调。例如，让我们向正方形投射一条光线：</p><p>  We can see, that we haven’t reached the square, but more importantly we did not overshoot it.Now we need to march the ray again, but what distance should it cover?To answer this question, we need to take another distance estimation from ray end to the objects in the scene:</p><p>我们可以看到，我们还没有到达广场，但更重要的是我们没有超调。现在我们需要再次行进光线，但它应该覆盖多远？要回答这个问题，我们需要另一个距离估计，从光线端到场景中的对象：</p><p>  Once again we choose shorter distance, and march towards the square, then get the distance again, and repeat the whole process:</p><p>我们再一次选择较短的距离，向广场行进，然后再次获得距离，并重复整个过程：</p><p>  You can see that with each step the distance to the object becomes smaller, and thus we will never overshoot the object.However this also means, that we will take a lot of really small steps, until we finally fully hit the object, if we ever do.This is not a good idea, because it is even more inefficient than using fixed distance, and produces too accurate results, which we don’t really need.So instead of marching up until we exactly hit the object, we will march  enough times.E.g. until the distance to the object is small enough, then there’s no real point to continue marching, as it is clear that we will hit the object soon.But this also means, that if the ray goes near the edge of an object, we do a lot of expensive steps of computing distance estimations.</p><p>你可以看到，每走一步到物体的距离就会变小，因此我们永远不会超过物体。然而，这也意味着，如果我们真的这样做了，我们将走很多非常小的步骤，直到我们最终完全击中物体。这不是一个好主意，因为它比使用固定距离效率更低，产生的结果太准确，这是我们并不真正需要的。所以，我们不是一直前进，直到我们准确地击中物体，而是行进足够多的时间。例如，如果我们这样做的话，我们会走足够多的时间，因为它比使用固定距离的效率更低，产生的结果太准确，这是我们并不真正需要的。在到物体的距离足够小之前，没有继续行进的真正意义，因为很明显我们很快就会击中物体。但这也意味着，如果光线靠近物体的边缘，我们要做很多昂贵的计算距离估计的步骤。</p><p> Here’s a ray that is parallel to the side of the square, and marches towards the circle:</p><p>这是一条平行于正方形一侧的光线，它朝向圆形行进：</p><p>  We do a lot of seemingly pointless measurements, and if a ray was closer to the square’s side, we would do even more steps.However this also means, that we can use this data (since we’re already computed it) to render such things as glow, or ambient occlusion.But more on this later.</p><p>我们做了很多看似毫无意义的测量，如果光线更靠近正方形的一侧，我们会做更多的步骤。但这也意味着，我们可以使用这些数据(因为我们已经计算了它)来渲染诸如辉光或环境光遮挡之类的东西。</p><p> Once ray hit an object we have all the data we need.Ray represents a point on the screen, and the more rays we cast the higher resolution of our image will be.And since we’re not using triangles to represent objects, our spheres will always be smooth, no matter how close we are to it, because there’s no polygons involved.</p><p>一旦光线击中一个物体，我们就有了所有需要的数据。光线代表了屏幕上的一个点，我们投射的光线越多，图像的分辨率就越高。由于我们没有使用三角形来表示物体，所以我们的球体永远是平滑的，无论我们离它有多近，因为没有涉及多边形。</p><p> This is basically it.Ray marching is quite simple concept, just like raycaster, although it’s a bit more complicated, as we do have to compute things in 3D space now.So let’s begin implementing it by installing required tools, and setting up the project.</p><p>基本上就是这样。光线行进是一个非常简单的概念，就像光线投射器一样，尽管它有点复杂，因为我们现在必须在3D空间中计算东西。所以让我们通过安装所需的工具和设置项目来开始实现它。</p><p>  As you know from the title we will use two main tools to create ray-marcher, which are  LÖVE, a free game engine, and  Fennel the programming language.I’ve chosen Fennel, because it is a Lisp like language, that compiles to Lua, and I’m quite a fan of Lisps.But we also needed to draw somewhere, and I know no GUI toolkit for Lua.But there is LÖVE - a game engine that runs Lua code, which is capable on running on all systems, thus a perfect candidate for our task.</p><p>正如您从标题中了解到的，我们将使用两个主要工具来创建Ray-Marcher，它们是免费的游戏引擎LöVE和编程语言Fennel。我选择了Fennel，因为它是一种类似Lisp的语言，可以编译成Lua，而且我是Lisp的忠实粉丝。但是我们也需要在某个地方画画，我知道没有LuGUI工具包。但是有一个运行Lua代码的游戏引擎LÖVE，它能够在所有系统上运行，因此是我们任务的完美候选者。</p><p> Installation steps may differ per operating system, so please refer to manuals  3 ,   4.At the time of writing this post I’m using Fedora GNU/Linux, so for me it means:</p><p>安装步骤可能因操作系统而异，因此请参阅手册3、4。在撰写本文时，我使用的是Fedora GNU/Linux，因此对我来说，这意味着：</p><p> $ sudo dnf install love luarocks readline-devel$ luarocks install --local fennel$ luarocks install --local readline  # requires readline-devel$  export  PATH= &#34; $PATH : $HOME /.luarocks/bin&#34;</p><p>$sudo DNF install Love luarocks readline-devel$luarock install--local fennel$luarock install--local readline#要求readline-devel$export path=&#34；$path：$home/.luarock/bin&#34；</p><p> It’s better to permanently add  $HOME/luarocks/bin (or another path, if your installation differs) to the  PATH variable in your shell, in order to be able to use installed utilities without specifying full path every time.You can test if everything is installed correctly, by running  fennel in you command line.</p><p>最好将$HOME/luarock/bin(如果安装不同，则将另一个路径)永久添加到shell中的PATH变量，以便能够使用已安装的实用程序，而无需每次都指定完整路径。您可以通过在命令行中运行fennel来测试是否正确安装了所有内容。</p><p> $ fennelWelcome to Fennel 0.5.0 on Lua 5.3!Use (doc something) to view documentation.&gt;&gt; (+ 1 2 3)6&gt;&gt;</p><p>$fennel欢迎使用Lua 5.3上的Fennel 0.5.0！使用(Doc Thing)查看文档。&gt；&gt；(+1 2 3)6&gt；&gt；</p><p> For other distributions installation steps may vary, and for Windows, I think it’s safe to skip the  readline part, which is fully optional, but makes editing in a REPL a bit more comfortable.</p><p>对于其他发行版，安装步骤可能会有所不同，而对于Windows，我认为跳过readline部分是安全的，这是完全可选的，但在REPL中进行编辑会更方便一些。</p><p> Once everything is installed, let’s create the project directory, and the  main.fnl file, where we will write our code.</p><p>安装完毕后，让我们创建项目目录和main.fnl文件，我们将在其中编写代码。</p><p>  And that’s it!We can test if everything works by adding this code to  main.fnl:</p><p>仅此而已！我们可以通过将以下代码添加到main.fnl来测试是否一切正常：</p><p>  Now we can compile it with  fennel --compile main.fnl &gt; main.lua, thus producing the  main.lua file, and run  love . (dot is intentional, it indicates current directory).</p><p>现在我们可以用fennel编译它--编译main.fnl&gt；main.lua，从而生成main.lua文件，然后运行Love。(点是故意的，表示当前目录)。</p><p>     Just as in raycaster, we need a camera that will shoot rays, and some objects to look at.Let’s begin by creating a camera object, that will store coordinates and rotation information.We can do so, by using  var to declare a variable that is local to our file, and that we can later change with  set  5:</p><p>就像在raycaster中一样，我们需要一个将发射光线的摄影机以及一些要查看的对象。让我们从创建一个Camera对象开始，该对象将存储坐标和旋转信息。我们可以这样做，方法是使用var声明文件的本地变量，稍后可以使用集5更改该变量：</p><p>   For those unfamiliar with Lisps, and especially Clojure, let me quickly explain what this syntax is.If you know this stuff, feel free to  skip this part.</p><p>对于那些不熟悉Lisp的人，尤其是Clojure，让我快速解释一下这个语法是什么。如果您知道这些东西，可以跳过这一部分。</p><p> We start by using a  var special form, that binds a value to a name like this:  (var name value).So if we start the REPL, using  fennel command in the shell, and write  (var a 40), a new variable  a will be created.We then can check, that it has the desired value by typing  a, and pressing return:</p><p>我们首先使用var特殊形式，它将一个值绑定到如下名称：(var name值)。因此，如果我们在shell中使用fennel命令启动REPL，并写入(Var A 40)，将创建一个新的变量a。然后，我们可以通过键入a并按Return键来检查它是否具有所需的值：</p><p>  We can then alter the contents of this variable by using  set special form, which works like this  (set name new-value):</p><p>然后，我们可以使用SET SPECIAL FORM更改此变量的内容，其工作方式如下(SET NAME NEW-VALUE)：</p><p>  Now to curly and square brackets.Everything enclosed in curly braces is a hashmap.We can use any Lua value as our key, and the most common choice is a string, but Fennel has additional syntax for defining keys - a colon followed by a word:  :a.This is called a keyword, and in Fennel it is essentially the same as  &#34;a&#34;, but we don’t need to write a pair of quotes.However keywords can’t contain spaces, and some other symbols.</p><p>现在是花括号和方括号。花括号中的所有东西都是一个哈希图。我们可以使用任何Lua值作为键，最常见的选择是字符串，但是茴香有定义键的附加语法-冒号后跟单词：：A。这被称为关键字，在茴香中它本质上与&#34；a&#34；相同，但是我们不需要写一对引号。但是，关键字不能包含空格和其他一些符号。在茴香中，它本质上与&#34；a&#34；相同，但是我们不需要写一对引号。但是，关键字不能包含空格和其他一些符号。</p><p> So writing this  {:a 0 :b 2 :c :hello} in the REPL will make a new table, that holds three key value pairs, which we can later get with another syntax - the dot  ..Combining it with  var, we can see that it works:</p><p>因此，在REPL中写入{：A 0：B2：C：HELLO}将生成一个新表，其中包含三个键值对，稍后我们可以使用另一种语法-点..将其与var结合使用，我们可以看到它是有效的：</p><p>  There’s also a shorthand for this syntax, that is, we can type  m.b and access the  :b key’s value:</p><p>此语法还有一个简写，即，我们可以键入m.b并访问：b键的值：</p><p>  Notice that even though we’ve specified the value for  :c as  :hello, the REPL printed it to us as  &#34;hello&#34;.</p><p>请注意，即使我们将：c的值指定为：hello，REPL还是将其打印为&#34；hello&#34；。</p><p> We’re left with square brackets now, and this is plain simple vector.It can grow and shrink, and store any Lua values in it:</p><p>现在我们只剩下方括号了，这是一个简单的向量，它可以增大和缩小，并在其中存储任何Lua值：</p><p>  However Lua doesn’t really have vectors or arrays, and it utilizes tables for this, where keys are simply indexes.So the code above is equivalent to this Fennel expression  {1 0 2 &#34;a&#34; 3 &#34;b c&#34; 4 (fn [x] x)}, but we can use square brackets for convenience.</p><p>但是，Lua并没有真正的向量或数组，它使用表来实现这一点，其中键只是索引。因此，上面的代码等同于这个茴香表达式{1 0 2&#34；a&#34；3&#34；b c&#34；4(fn[x]x)}，但是为了方便起见，我们可以使用方括号。</p><p> Note, that we can combine indexed tables (vectors) and ordinary tables (hashmaps) together.We can do it as shown above, by specifying indexes as keys, or define a vector var and  set a key in it to some value:</p><p>请注意，我们可以将索引表(向量)和普通表(哈希图)组合在一起。我们可以如上所示，将索引指定为键，或者定义一个向量变量并将其中的键设置为某个值：</p><p> &gt;&gt; ( var  v [0 1  :a]) &gt;&gt; ( set  v.a 3) &gt;&gt;  v{ :a 3 1 0 2 1 3  &#34;a&#34;}</p><p>&gt；&gt；(var v[0 1：A])&gt；&gt；(集合V.A 3)&gt；&gt；v{：a 3 1 0 2 1 3&#34；a&#34；}。</p><p>  So camera is essentially a  Lua table, that stores keys  :pos,  :x-rotate, and  :y-rotate, each storing a respective value.We use a vector as our position, and two floats as our rotation angles.Now we can make objects, but before that, we need a scene to store those objects:</p><p>因此，Camera实质上是一个Lua表，其中存储了关键点：位置、：X-旋转和：Y-旋转，每个关键点都存储了一个值。我们使用一个向量作为位置，使用两个浮点作为旋转角度。现在我们可以制作对象，但在此之前，我们需要一个场景来存储这些对象：</p><p>  Yep, that’s our scene.Nothing fancy, simply an empty vector to which we will later add objects.</p><p>是的，这就是我们的场景。没有什么花哨的东西，只是一个空向量，我们稍后会向其中添加对象。</p><p> Now we can create these objects, so let’s start with perhaps the simplest one - a sphere.And I’ll also briefly explain what makes raymarching different from other methods of creating 3D graphics.</p><p>现在我们可以创建这些对象了，所以让我们从可能最简单的球体开始。我还将简要解释光线行进与其他创建3D图形的方法的不同之处。</p><p>  What is a sphere?That depends on the domain, we’re working in.Let’s open up  Blender, remove the default cube, and create sphere with  Shift+a, Mesh, UV Sphere:</p><p>什么是球体？这取决于我们正在使用的域。让我们打开Blender，移除默认立方体，并使用Shift+a、网格、UV球体创建球体：</p><p>  To me, this looks nothing like a sphere, because it consists out of rectangles.However if we subdivide the surface, we can get more correct representation:</p><p>对我来说，这看起来一点也不像球体，因为它是由矩形组成的。但是，如果我们细分曲面，我们可以得到更正确的表示：</p><p>  This looks more like a sphere, but this is still just an approximation.Theoretically, if we move very close to it, we will see the edges and corners, especially with flat shading.Also, each subdivision adds more points, and it gets more and more expensive to compute:</p><p>这看起来更像一个球体，但这仍然只是一个近似值。理论上，如果我们非常接近它，我们会看到边和角，特别是带有平面着色的边和角。此外，每个细分都会添加更多的点，计算成本也会越来越高：</p><p>  We have to make these trade-offs, because we don’t need very accurate spheres, when we need real time processing.But raymarching doesn’t have this limitation, because sphere in raymarching is defined by the point and radius length.Which we can then work with by using signed distance function.</p><p>我们必须做这些权衡，因为当我们需要实时处理时，我们不需要非常精确的球体。但是光线行进没有这个限制，因为光线行进中的球体是由点和半径长度定义的，然后我们可以使用带符号的距离函数来处理。</p><p>  ( fn  sphere [ radius  pos  color]  ➊ ( let [[ x  y  z]  ➋ ( or  pos [0 0 0]) [ r  g  b] ( or  color [1 1 1])] { :radius ( or  radius 5)  :pos [( or  x 0) ( or  y 0) ( or  z 0)]  :color [( or  r 0) ( or  g 0) ( or  b 0)]  :sdf  sphere-distance  ➌}))</p><p>(fn球体[半径位置颜色]➊(let[[x y z]➋(或位置[0 0])[r g b](或颜色[1 1 1])]{：半径(或半径5)：位置[(或x 0)(或y 0)(或z 0)]：颜色[(或r 0)(或g 0)(或b 0)]：sdf球距➌})。</p><p> There’s a lot of stuff going on, so let’s dive into it.</p><p>有很多事情在进行，所以让我们潜入其中。</p><p> This is a so called constructor - a function, that takes some parameters and constructs an object with these parameters applied, then returns it.In most typed languages we would define a class, or structure to represent this object, however in Fennel (and hence in Lua) we can just use a table.And this is my favorite part of such languages.</p><p>在大多数类型化语言中，我们会定义一个类或结构来表示这个对象，但是在Fennel中(因此在Lua中)，我们只能使用表。这是我最喜欢的这类语言的一部分。</p><p> So we used  fn special form to create a function named  sphere, that takes three parameters:  radius, position in space  pos, and  color ➊.Then we see another special form  let.It is used to introduce locally scoped variables, and has another nice property - destructuring ➋.</p><p>因此，我们使用fn特殊形式创建了一个名为➊的函数，它有三个参数：半径、空间位置pos和颜色let。然后我们看到另一个特殊形式let，它用于引入局部作用域变量，并且具有另一个很好的属性-析构➋。</p><p> Let’s quickly understand how  let works in this case.If you know how destructuring works, you can  skip this part.</p><p>让我们快速了解一下let在这种情况下是如何工作的。如果您知道解构是如何工作的，您可以跳过这一部分。</p><p>   We’ve introduced two local variables  a and  b, which hold values  1 and  2 respectively.Then we’ve computed their sum and returned it as a result.</p><p>我们引入了两个局部变量a和b，它们分别包含值1和2，然后计算它们的和并返回结果。</p><p> This is good, but what if we wanted to compute a sum of three vector elements multiplied by  b?Let’s put a vector into  a:</p><p>这很好，但是如果我们想要计算三个向量元素乘以b的和呢？让我们把一个向量放到a中：</p><p>  There are many ways to do this, such as  reduce over a vector with a function that sums elements, or get values from the vector in a loop, and put those into some local variable.However, in case of our project, we always know exactly how many elements there will be, so we can just take these out by indexes without any kind of loop:</p><p>有很多方法可以做到这一点，比如使用对元素求和的函数对向量进行Reduce，或者从循环中的向量中获取值，然后将这些值放入某个局部变量中。但是，在我们的项目中，我们总是确切知道将有多少元素，所以我们只需按索引取出这些元素，而不需要任何类型的循环：</p><p> &gt;&gt; ( let [ a [1 2 3]  b 2  a1 ( .  a 1)  a2 ( .  a 2)  a3 ( .  a 3)] ( * ( +  a1  a2  a3)  b))12</p><p>&gt；&gt；(设[a[1 2 3]b2A1(.。A1)a2(.。A 2)A3(.。A 3)](*(+a1 a2 a3)b))12。</p><p> Yet, this is very verbose, and not really good.We can make it a bit less verbose by skipping local variable definitions and use values directly in the sum:</p><p>但是，这非常冗长，而且不是很好。我们可以通过跳过局部变量定义并直接在总和中使用值来使其变得不那么冗长：</p><p> &gt;&gt; ( let [ a [1 2 3]  b 2] ( print ( ..  &#34;value of second element is &#34; ( .  a 2))) ( * ( + ( .  a 1) ( .  a 2) ( .  a 3))  b)) value  of  sectond  element  is 212</p><p>&gt；&gt；(设[a[1 2 3]b 2](打印(..。&#34；第二个元素的值是&#34；(.。A 2)(*(+(.。A 1)(.。A 2)(.。A 3))b))第二个元素的值为212。</p><p> However, again, this isn’t really great, as we have to repeat the same syntax three times, and what if we want to use second value from the vector in several places?Like here, I’ve added  print since I particularly about second element’s value, and want to see it in the log, but I have to repeat myself and get second element twice.We could use a local binding for this, but we don’t want to do this manually.</p><p>然而，这又一次不是很好，因为我们必须重复相同的语法三次，如果我们想在几个地方使用向量中的第二个值怎么办？就像这里，我添加了print，因为我特别关心第二个元素的值，并希望在日志中看到它，但我必须重复自己并获取第二个元素两次。我们可以使用本地绑定来实现这一点，但我们不想手动执行此操作。</p><p> That’s where destructuring comes in handy, and trust me, it is a very handy thing.We can specify a pattern, that is applied to our data, and binds variables for us like this:</p><p>这就是解构派上用场的地方，相信我，这是一件非常方便的事情。我们可以指定一个模式，该模式应用于我们的数据，并为我们绑定变量，如下所示：</p><p> &gt;&gt; ( let [[ a1  a2  a3] [1 2 3]  b 2] ( print ( ..  &#34;value of second element is &#34;  a2)) ( * ( +  a1  a2  a3)  b)) value  of  sectond  element  is 212</p><p>&gt；&gt；(设[[a1a2a3][1 2 3]b2](打印(..。&#34；第二元素的值为&#34；a2))(*(+a1 a2 a3)b)第二元素的值为212。</p><p>   This is much shorter than any of previous examples, and allows us to use any of vector values in several places.</p><p>这比前面的任何示例都要短得多，并且允许我们在多个位置使用任何向量值。</p><p>  &gt;&gt; ( var  m { :a-key 1  :b-key 2}) &gt;&gt; ( let [{ :a-key  a  :b-key  b}  m] ( +  a  b))3</p><p>&gt；&gt；(var m{：A-KEY 1：B-KEY 2})&gt；&gt；(设[{：A-KEY a：B-KEY b}m](+a b))3</p><p> And this also has a shorthand for when the name of the key and the name of desired local binding will match:</p><p>这也有一个表示键名称和所需本地绑定名称何时匹配的简写：</p><p> &gt;&gt; ( var  m { :a 1  :b 2}) &gt;&gt; ( let [{ :  a  :  b}  m] ( +  a  b))3</p><p>&gt；&gt；(var m{：a1：b2})&gt；&gt；(设[{：a：b}m](+a b))3。</p><p>   -- vector destructuring -- (let [[a b] [1 2]] (+ a b)) local _0_ = {1, 2} local a = _0_[1] local b = _0_[2] return (a + b) -- hashmap destructuring -- (let [{: a : b} {:a 1 :b 2}] (+ a b)) local _0_ = {a = 1, b = 2} local a = _0_[ &#34;a&#34;] local b = _0_[ &#34;b&#34;] return (a + b)</p><p>--向量解构--(设[[a b][1 2]](+a b))local_0_={1，2}local a=_0_[1]local b=_0_[2]return(a+b)--(let[{：a：b}{：a 1：b}](+a b))local_0_={a=1，b=2}local a=_0_[&#34；a&#34；]本地b=_0_[&#34；b&#34；]返回(a+b)。</p><p> Which is nothing special really, but this example still shows the power of Lisp’s macro system, in which destructuring is implemented.But it gets really cool when we use this in function forms, as we will see later.</p><p>这真的没什么特别的，但是这个例子仍然展示了Lisp宏系统的强大功能，在这个宏系统中实现了解构。但是当我们在函数形式中使用它时，它变得非常酷，我们稍后将看到这一点。</p><p>  If we were to call  (sphere) now, we would get an error, because we specified a value ➌ for a key  :sdf, that doesn’t yet exist.SDF stands for  Signed Distance Function.That is, a function, that will return the distance from given point to an object.The distance is positive when the point is outside of the object, and is negative when the point is inside the object.</p><p>如果我们现在调用(➌)，我们会得到一个错误，因为我们为键sdf指定了一个尚不存在的值sdf。sdf代表符号距离函数。也就是说，这是一个函数，它将返回从给定点到对象的距离。当点在对象外部时，距离为正，当点在对象内时，距离为负值。</p><p> Let’s define an SDF for a sphere.What’s great about spheres, is that to compute the distance to the sphere’s surface, we only need to compute distance to the center of the sphere, and subtract sphere’s radius from this distance.</p><p>让我们为球体定义一个SDF。球体的伟大之处在于，要计算到球体表面的距离，我们只需要计算到球体中心的距离，然后从这个距离减去球体的半径。</p><p>   ( local  sqrt  math.sqrt)  ➊( fn  sphere-distance [{ :pos [ sx  sy  sz]  :  radius} [ x  y  z]]  ➋ ( - ( sqrt ( + (^ ( -  sx  x) 2) (^ ( -  sy  y) 2) (^ ( -  sz  z) 2)))  radius))</p><p>(LOCAL sqrt math.sqrt)➊(fn sphere-Distance[{：pos[sx sy sz]：Radius}[x y z]]➋(-(sqrt(+(^(-sx x)2)(^(-sy y)2)(^(-sz)2))Radius)。</p><p> For  performance reasons we declare  math.sqrt as a  local variable  sqrt, that holds function value, to avoid repeated table lookup.</p><p>出于性能原因，我们将math.sqrt声明为保存函数值的局部变量sqrt，以避免重复查找表格。</p><p> As was later pointed out, Luajit does optimize such calls, and there is no repeated lookup for method calls.This is still ture for plain Lua, so I’m going to keep this as is, but you can skip all these local definitions if you want and use methods directly.</p><p>正如后来指出的，Luajit确实优化了这类调用，并且不会重复查找方法调用。这对于普通Lua仍然是正确的，所以我将保持原样，但是如果您愿意，您可以跳过所有这些局部定义，直接使用方法。</p><p> And at ➋ we again see destructuring, however not in the  let block, but in the function argument list.What essentially happens here is this - function takes two parameters, first of which is a hashmap, that must have a  :pos keyword associated with a vector of three numbers, and a  :radius keyword with a value.Second parameter is simply a vector of three numbers.We immediately destructuring these parameters into a set of variables local to the function body.Hashmap is being destructured into sphere position vector, which is immediately destructured to  sx,  sy, and  sz, and a  radius variable storing sphere’s radius.Second parameter is destructured to  x,  y, and  z.We then compute the resulting value by using the formula from above.However, Fennel and Lua only understand definitions in the order from the top to the bottom, so we need to define  sphere-distance before  sphere.</p><p>在➋，我们再次看到解构，但是不是在LET块中，而是在函数参数列表中。这里本质上发生的是这样的-函数接受两个参数，第一个是散列图，它必须具有与三个数字的向量相关联的：pos关键字，以及一个：RADIUS关键字和一个值。第二个参数只是三个数字的向量。我们立即将这些参数解构为函数体局部的一组变量。Hashmap被解构为球位置向量，该向量立即解构为sx、sy和sz，以及存储球的半径的半径变量。第二个参数被解构为x，然后我们使用上面的公式计算结果值，但是Fennel和Lua只理解从上到下的顺序定义，所以我们需要先定义球面距离，然后再定义球面距离。</p><p> Let’s test our function by passing several points and a sphere of radius 5:</p><p>让我们通过传递几个点和一个半径为5的球体来测试我们的函数：</p><p> &gt;&gt; ( sphere-distance ( sphere 5) [5 0 0])0.0 &gt;&gt; ( sphere-distance ( sphere 5) [0 15 0])10.0 &gt;&gt; ( sphere-distance ( sphere 5) [0 0 0])-5.0</p><p>&gt；&gt；(球体距离(球体5)[5 0 0])0.0&gt；&gt；(球体距离(球体5)[0 150])10.0&gt；(球体距离(球体5)[0 0 0])-5.0。</p><p> Great!First we check if we’re on the sphere’s surface, because the radius of our sphere is  5, and we’ve set  x coordinate to  5 as well.Next we check if we’re  10 something away from the sphere, and lastly we check that we’re  inside the sphere, because sphere’s center and our point both are at the origin.</p><p>很好！首先我们检查我们是否在球体的表面上，因为球体的半径是5，我们也把x坐标设为5，然后我们检查我们是否离球体有10左右的距离，最后我们检查我们是不是在球体内部，因为球体的中心和我们的点都在原点上。</p><p>   This works because methods in Lua are a syntactic sugar.When we write  (s:sdf p) it is essentially equal to  (s.sdf s p), and our distance function takes sphere as it’s first parameter, which allows us to utilize method syntax.</p><p>这是可行的，因为Lua中的方法是语法糖，当我们编写(s：sdf p)时，它本质上等于(s.sdf s p)，并且我们的距离函数将sphere作为它的第一个参数，这允许我们利用方法语法。</p><p> Now we need a distance estimator - a function that will compute distances to all object and will return the shortest one, so we could then safely extend our ray by this amount.</p><p>现在我们需要一个距离估计器-一个函数，它将计算到所有对象的距离，并返回最短的一个，这样我们就可以安全地将光线扩展这个量。</p><p> ( local  DRAW-DISTANCE 1000)( fn  distance-estimator [ point  scene] ( var  min  DRAW-DISTANCE) ( var  color [0 0 0]) ( each [ _  object ( ipairs  scene)] ( let [ distance ( object :sdf  point)] ( when ( &lt;  distance  min) ( set min  distance) ( set  color ( .  object  :color))))) ( values  min  color))</p><p>(LOCAL绘制距离1000)(FN Distance-估计器[点场景](var min绘制距离)(var color[0 0 0])(每个[_object(ipains场景)](let[Distance(object：SDF point)])(When(&lt；Distance min)(设置最小距离)(设置颜色(.。对象：颜色)(值最小颜色)</p><p> This function will compute the distance to  each object in the  scene from given  point, using our signed distance functions, and will choose the minimum distance and a color of this ray.Even though it makes little sense to return color from distance-estimator, we’re doing this here because we don’t want to compute this whole process again just to get the color of the endpoint.</p><p>该函数将使用我们的符号距离函数计算从给定点到场景中每个对象的距离，并将选择该光线的最小距离和颜色。尽管从距离估计器返回颜色意义不大，但我们在这里这样做是因为我们不想仅仅为了获得端点的颜色而再次计算整个过程。(=。</p><p>  &gt;&gt; ( distance-estimator [5 4 0] [( sphere) ( sphere 2 [5 7 0] [0 1 0])])1.0 [0 1 0]</p><p>&gt；&gt；(距离估计器[5 4 0][(球体)(球体2[5 7 0][0 1 0])])1.0[0 1 0]。</p><p> It works, we obtained the distance to second sphere, and it’s color, because the point we’ve specified was closer to this sphere than to the other.</p><p>它起作用了，我们得到了到第二个球体的距离，它是颜色的，因为我们指定的点离这个球体比到另一个球体更近。</p><p> With the camera, object, a scene, and this function we have all we need to start shooting rays and rendering this on screen.</p><p>有了相机、物体、场景和这个功能，我们就有了所有需要的东西来开始拍摄光线并将其渲染到屏幕上。</p><p>  Just as in raycaster, we cast rays from the camera, but now we do it in 3D space.In raycasting our horizontal resolution was specified by an amount of rays, and our vertical resolution was basically infinite.For 3D this is not an option, so our resolution now depends on the 2D matrix of rays, instead of 1D matrix.</p><p>就像在光线投射器中一样，我们从相机投射光线，但现在我们在3D空间投射光线。在光线投射中，我们的水平分辨率是由光线数量指定的，而垂直分辨率基本上是无穷大的。对于3D，这不是一个选项，所以我们的分辨率现在取决于2D光线矩阵，而不是1D矩阵。</p><p> Quick math.How many rays we’ll need to cast in order to fill up 512 by 4</p><p>快速计算。我们需要投射多少光线才能填满512乘4。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://andreyorst.gitlab.io/posts/2020-10-15-raymarching-with-fennel-and-love/">https://andreyorst.gitlab.io/posts/2020-10-15-raymarching-with-fennel-and-love/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/fennel/">#fennel</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/光线/">#光线</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>