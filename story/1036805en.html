<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>掌握Unix管道，第1部分Mastering Unix pipes, Part 1</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Mastering Unix pipes, Part 1<br/>掌握Unix管道，第1部分</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-27 09:54:55</div><div class="page_narrow text-break page_content"><p>A pipe is a first-in-first-out interprocess communication channel.The pipe version as it is known today was invented by an American Computer Scientist Douglas McIlroyand incorporated into Version 3 AT&amp;T UNIX in 1973 by Ken Thompson.</p><p>管道是先进先出的进程间通信通道。今天已知的管道版本由美国计算机科学家Douglas McIlroyand发明，并于肯·汤普森（Ken Thompson）于1973年并入了版本3 AT＆T UNIX。</p><p> It was inspired by the observation that frequently the output of one application isused as an input for another. This concept can be reused to connect a chainof processes. This is frequently observedin UNIX shell constructs that utilize the  | operator.</p><p> 受到观察的启发，经常将一个应用程序的输出用作另一应用程序的输入。可以重用此概念以连接流程链。在使用|的UNIX shell构造中经常观察到这种情况。操作员。</p><p> $ find lib -name *.c | awk -F  &#39;/&#39;  &#39;{print $NF}&#39; | sort -u | tailyp_maplist.cyp_master.cyp_match.cyp_order.cyperr_string.cyplib.cypprot_err.cyyerror.czdump.czic.c</p><p> $查找lib -name * .c | awk -F'/''{print $ NF}'|排序-u | tailyp_maplist.cyp_master.cyp_match.cyp_order.cyperr_string.cyplib.cypprot_err.cyyerror.czdump.czic.c</p><p>   This concept of connecting the UNIX tools has been expanded to various native tools,such as the troff formatting system, that are specifically designed to be used in pipelines.The troff format and the associated toolkit are still used in the NetBSD Operating System.The build rules, producing the  .ps files ( PostScript)look like this one, forthe kernmalloc (the kernel allocator documentation) example:</p><p>   连接UNIX工具的概念已扩展到各种本机工具，例如troff格式化系统，这些工具是专门为在管道中使用而设计的.troff格式和相关的工具包仍在NetBSD操作系统中使用。对于kernmalloc（内核分配器文档）示例，生成.ps文件（PostScript）的规则看起来像这样一个：</p><p> #	$NetBSD: Makefile,v 1.4 2003/07/10 10:34:26 lukem Exp $ # #	@(#)Makefile	1.8 (Berkeley) 6/8/93 DIR =	papers/kernmallocSRCS =	kernmalloc.t appendix.tMACROS =	-ms paper.ps : ${SRCS} alloc.fig usage.tbl	 ${TOOL_SOELIM }  ${SRCS } |  ${TOOL_TBL } |  ${TOOL_PIC } |  \ 	  ${TOOL_EQN } |  \ 	  ${TOOL_VGRIND } |  ${TOOL_ROFF_PS }  ${MACROS } &gt;  ${.TARGET } .include &lt;bsd.doc.mk&gt;</p><p> ＃$ NetBSD：Makefile，v 1.4 2003/07/10 10:34:26 lukem Exp $＃＃@（＃）Makefile 1.8（Berkeley）6/8/93 DIR = papers / kernmallocSRCS = kernmalloc.t appendix.tMACROS = -ms paper.ps：$ {SRCS} alloc.fig usage.tbl $ {TOOL_SOELIM} $ {SRCS} | $ {TOOL_TBL} | $ {TOOL_PIC} | \ $ {TOOL_EQN} | \ $ {TOOL_VGRIND} | $ {TOOL_ROFF_PS} $ {MACROS}> $ {。TARGET} .include </p><p>      The  pipe function takes an array of two integers, and writes file descriptorsof the read and write end of the pipe into it upon successful return.The  fildes[0] file descriptor is opened for reading and  fildes[1] for writing.Some implementations of UNIX allow using the  fildes[0] end for writing too and  fildes[1] for reading(the full duplex mode), but this behavior is unspecified by POSIX and it is only safe to assume thatthey are unidirectional (half duplex mode).</p><p>      pipe函数采用两个整数组成的数组，并在成功返回后将管道的读取和写入端的文件描述符写入到其中。打开fildes [0]文件描述符以进行读取，并打开fildes [1]进行写入。 UNIX也允许使用fildes [0]端进行写入，并使用fildes [1]进行读取（全双工模式），但是POSIX未指定这种行为，只能安全地假定它们是单向的（半双工模式）。</p><p> The  pipe call can fail and return  -1, setting appropriate  errnoif the process ( EMFILE) or the system ( ENFILE) expired the allowed number ofopen file descriptors.</p><p> 如果进程（EMFILE）或系统（ENFILE）超出了允许的打开文件描述符数量，则管道调用可能会失败并返回-1，并设置适当的错误。</p><p>  This interface as it looks is appropriate only for processes that have the shared ancestor (usually the direct parent)and is usually combined with  fork(2)/ vfork(2)/ posix_spawn(3) or an equivalent interface(otherwise the pipe would be a futile feature).To workaround the limitation of having the shared predecessor,the fifo special files or UNIX domain sockets can be used.</p><p>从外观上看，此接口仅适用于具有共享祖先（通常是直接父级）的进程，并且通常与fork（2）/ vfork（2）/ posix_spawn（3）或等效接口组合在一起（否则管道为为了解决共享前身的限制，可以使用fifo特殊文件或UNIX域套接字。</p><p> In the UNIX system, file descriptors are inherited by children by default (with some exceptions in modern APIs)and thus the created pipe, referenced by the array of two file descriptors, connects the child and the parent.</p><p> 在UNIX系统中，默认情况下，子项继承文件描述符（现代API中有一些例外），因此，由两个文件描述符的数组引用的创建的管道将子项和父项连接起来。</p><p>  In order to make the pipe effective, the user has to decide the direction of the data flow andclose the other ends. If the intention is to send data from process A to process B, then we needto close the  fildes[0] (reading) end in process A and  fildes[1] (writing) end in process B.</p><p>  为了使管道有效，用户必须确定数据流的方向并关闭另一端。如果打算将数据从进程A发送到进程B，则我们需要在进程A中关闭fildes [0]（读取）端，并在进程B中关闭fildes [1]（写入）端。</p><p>    #include  &lt;sys/types.h&gt;  #include  &lt;sys/wait.h&gt;  #include  &lt;err.h&gt;  #include  &lt;stdio.h&gt;  #include  &lt;stdlib.h&gt;  #include  &lt;unistd.h&gt;   int main( int argc,  char  **argv){	 char c;	 int status;	pid_t child;	 int fildes[ 2];	 if (pipe(fildes)  ==  - 1)		err(EXIT_FAILURE,  &#34;pipe&#34;);	 if ((child  = fork())  ==  - 1)		err(EXIT_FAILURE,  &#34;fork&#34;);	 if (child  ==  0) {		 /* child */		 if (close(fildes[ 1])  ==  - 1)			err(EXIT_FAILURE,  &#34;close&#34;);		read(fildes[ 0],  &amp;c,  1);		printf( &#34;Received: %c \n &#34;, c);		 /* force the buffer to be printed on the output (screen) */		fflush(stdout);		_exit( 0);	}	 /* parent */	 if (close(fildes[ 0])  ==  - 1)		err(EXIT_FAILURE,  &#34;close&#34;);	 if (write(fildes[ 1],  &#34;x&#34;,  1)  ==  - 1)		err(EXIT_FAILURE,  &#34;write&#34;);	 /* wait for the child process termination */	 if (wait( &amp;status)  ==  - 1)		err(EXIT_FAILURE,  &#34;wait&#34;);	 return EXIT_SUCCESS;}</p><p>    #include  #include  #include  #include  #include  #include  int main（int argc，char ** argv）{char c;整数状态； pid_t child; int fildes [2];如果（pipe（fildes）==-1）err（EXIT_FAILURE，“ pipe”）;如果（（child = fork（））==-1）err（EXIT_FAILURE，“ fork”）; if（child == 0）{/ * child * / if（close（fildes [1]）==-1）err（EXIT_FAILURE，“ close”）; read（fildes [0]，＆c，1）; printf（“ Received：％c \ n”，c）; / *强制将缓冲区打印在输出（屏幕）上* / fflush（stdout）; _exit（0）; } / *父* / if（close（fildes [0]）==-1）err（EXIT_FAILURE，“ close”）;如果（write（fildes [1]，“ x”，1）==-1）err（EXIT_FAILURE，“写”）; / *等待子进程终止* / if（wait（＆status）==-1）err（EXIT_FAILURE，“ wait”）;返回EXIT_SUCCESS;}</p><p> NB. For the sake of simplicity, certain code paths such as handling interrupts ( EINTR) were omitted.</p><p> 注意为了简单起见，省略了某些代码路径，例如处理中断（EINTR）。</p><p>    Once the readable end of the pipe is closed, an attempt is done to write results with  SIGPIPE emitted into the writing process.A process can either be killed or caught or ignore the signal and then needs to handle the error ( -1 and errno set to  EPIPE) manually.</p><p>    一旦管道的可读端关闭，就会尝试将结果写入SIGPIPE写入写入过程中。一个过程可以被杀死或捕获或忽略信号，然后需要处理错误（-1和errno集到EPIPE）。</p><p> Once the writable end of the pipe is closed, an attempt to read from the pipe returns  0 and notifes  EOF on the file descriptor.</p><p> 一旦管道的可写端关闭，从管道中读取的尝试将返回0并在文件描述符上标注EOF。</p><p>  The amount of free space inside the pipe (kernel buffering) is limited and implementation specific.</p><p>管道内部的可用空间量（内核缓冲）受到限制，具体取决于实现方式。</p><p> When the child process starts, the default stdio I/O buffering on pipes defaults to the fully buffered mode.The three basic approaches to workaround this are:</p><p> 子进程启动时，管道上的默认stdio I / O缓冲默认为完全缓冲模式。三种解决方法是：</p><p>  The size of the kernel buffer storing the pipe data is limited and will cause further attempts to  write(2) data to blockuntil the space is regained, by the  read(2) operation on the other end.The minimum acceptable value in a  POSIX systemis set to 512 bytes.</p><p>  存储管道数据的内核缓冲区的大小是有限的，并且将导致另一尝试通过另一端的read（2）操作再次写入（2）数据以阻塞空间，直到重新获得空间。POSIX系统中的最小可接受值是设置为512字节。</p><p> In order to check the maximum number of bytes that can be written atomically to a pipe, a programer can use the compiler constant  PIPE_BUF orthe dynamic value  _PC_PIPE_BUF passed to  pathconf(2) or  fpathconf(2). pathconf(2) and  fpathconf(2) can be applied on:</p><p> 为了检查可以原子地写入管道的最大字节数，程序员可以使用编译器常量PIPE_BUF或传递给pathconf（2）或fpathconf（2）的动态值_PC_PIPE_BUF。 pathconf（2）和fpathconf（2）可以应用于：</p><p>   #include  &lt;err.h&gt;  #include  &lt;limits.h&gt;  #include  &lt;stdio.h&gt;  #include  &lt;stdlib.h&gt;  #include  &lt;unistd.h&gt;   int main( int argc,  char  **argv){	 int fildes[ 2];	 if (pipe(fildes)  ==  - 1)		err(EXIT_FAILURE,  &#34;pipe&#34;);	printf( &#34;_PC_PIPE_BUF: %ld \n &#34;, fpathconf(fildes[ 1],_PC_PIPE_BUF));	printf( &#34;PIPE_BUF: %d \n &#34;, PIPE_BUF);	 return EXIT_SUCCESS;}</p><p>   #include  #include  #include  #include  #include  int main（int argc，char ** argv）{int fildes [ 2];如果（pipe（fildes）==-1）err（EXIT_FAILURE，“ pipe”）; printf（“ _PC_PIPE_BUF：％ld \ n”，fpathconf（fildes [1]，_ PC_PIPE_BUF））; printf（“ PIPE_BUF：％d \ n”，PIPE_BUF）;返回EXIT_SUCCESS;}</p><p> However, the real number is usually larger. It can be retrieved with  ioctl(FIONSPACE) on NetBSD.This feature is unavailable on other systems: FreeBSD, OpenBSD and Linux, thus FreeBSD implements FIONSPACE for sockets, but not for pipes.</p><p> 但是，实数通常较大。可以使用NetBSD上的ioctl（FIONSPACE）检索它。此功能在其他系统（FreeBSD，OpenBSD和Linux）上不可用，因此FreeBSD为套接字而不是管道实现FIONSPACE。</p><p> #include  &lt;sys/types.h&gt;  #include  &lt;sys/ioctl.h&gt;  #include  &lt;err.h&gt;  #include  &lt;stdio.h&gt;  #include  &lt;stdlib.h&gt;  #include  &lt;unistd.h&gt;   int main( int argc,  char  **argv){	 int fildes[ 2];	 int n;	 if (pipe(fildes)  ==  - 1)		err(EXIT_FAILURE,  &#34;pipe&#34;);	 if (ioctl(fildes[ 1], FIONSPACE,  &amp;n)  ==  - 1)		err(EXIT_FAILURE,  &#34;ioctl&#34;);	printf( &#34;FIONSPACE fildes[1]: %d \n &#34;, n);	 return EXIT_SUCCESS;}</p><p> #include  #include  #include  #include  #include  #include  int main（int argc，char ** argv）{int fildes [2]; int n;如果（pipe（fildes）==-1）err（EXIT_FAILURE，“ pipe”）;如果（ioctl（fildes [1]，FIONSPACE，＆n）==-1）err（EXIT_FAILURE，“ ioctl”）; printf（“ FIONSPACE fildes [1]：％d \ n”，n）;返回EXIT_SUCCESS;}</p><p> An alternative approach to check the maximum buffer size of the pipe feature is to count thebytes writable into it manually, one by one, and to detect the hang.This can be achieved for example with the  alarm(3) call, unblocking the hang.</p><p>检查管道功能的最大缓冲区大小的另一种方法是手动手动逐个计算可写入其中的字节数并检测挂起，例如可以通过使用alarm（3）调用来解除挂起。</p><p> #include  &lt;err.h&gt;  #include  &lt;signal.h&gt;  #include  &lt;stdio.h&gt;  #include  &lt;stdlib.h&gt;  #include  &lt;unistd.h&gt;   static  int n; static  void sighand( int s){	printf( &#34;bytes written into the pipe: %d \n &#34;, n);	exit(EXIT_SUCCESS);} int main( int argc,  char  **argv){	 int fildes[ 2];	 if (signal(SIGALRM, sighand)  == SIG_ERR)		err(EXIT_FAILURE,  &#34;signal&#34;);	 if (pipe(fildes)  ==  - 1)		err(EXIT_FAILURE,  &#34;pipe&#34;);	alarm( 5);  /* arm the alarm to 5 seconds */	 while (write(fildes[ 1],  &#34;x&#34;,  1)  !=  - 1)		 ++n;	 /* if we ended up here, there was an error */	err(EXIT_FAILURE,  &#34;write&#34;);}</p><p> #include  #include  #include  #include  #include 静态整数n; static void sighand（int s）{printf（“写入管道的字节：％d \ n”，n）; exit（EXIT_SUCCESS）;} int main（int argc，char ** argv）{int fildes [2]; if（signal（SIGALRM，sighand）== SIG_ERR）err（EXIT_FAILURE，“信号”）;如果（pipe（fildes）==-1）err（EXIT_FAILURE，“ pipe”）;警报（5）; / *将警报设置为5秒* /，同时（write（fildes [1]，“ x”，1）！=-1）++ n; / *如果我们到这里结束，则发生错误* / err（EXIT_FAILURE，“写”）;}</p><p> Alternatively, one could set the pipe end in the non-blocking mode.This can be achieved withthe  fcntl(2) call and the  F_SETFL +  O_NONBLOCK arguments.</p><p> 或者，可以将管道末端设置为非阻塞模式，这可以通过fcntl（2）调用和F_SETFL + O_NONBLOCK参数来实现。</p><p>  Writing into a full pipe buffer returns with  -1 and errno  EAGAIN, instead of blocking.</p><p>  写入完整的管道缓冲区将返回-1和errno EAGAIN，而不是阻塞。</p><p> #include  &lt;err.h&gt;  #include  &lt;errno.h&gt;  #include  &lt;fcntl.h&gt;  #include  &lt;limits.h&gt;  #include  &lt;stdio.h&gt;  #include  &lt;stdlib.h&gt;  #include  &lt;unistd.h&gt;   int main( int argc,  char  **argv){	 int fildes[ 2];	 int n;	 if (pipe(fildes)  ==  - 1)		err(EXIT_FAILURE,  &#34;pipe&#34;);	 if (fcntl(fildes[ 1], F_SETFL, O_NONBLOCK)  ==  - 1)		err(EXIT_FAILURE,  &#34;fcntl&#34;);	 while (write(fildes[ 1],  &#34;x&#34;,  1)  !=  - 1)		 ++n;	 /* filter real errors from the unavailable for now resource */	 if (errno  != EAGAIN)		err(EXIT_FAILURE,  &#34;write&#34;);	printf( &#34;bytes written into the pipe: %d \n &#34;, n);	 return EXIT_SUCCESS;}</p><p> #include  #include  #include  #include  #include  #include  #include  int main（int argc，char ** argv）{int fildes [2]; int n;如果（pipe（fildes）==-1）err（EXIT_FAILURE，“ pipe”）;如果（fcntl（fildes [1]，F_SETFL，O_NONBLOCK）==-1）err（EXIT_FAILURE，“ fcntl”）; while（write（fildes [1]，“ x”，1）！=-1）++ n; / *从当前资源不可用中过滤实际错误* / if（errno！= EAGAIN）err（EXIT_FAILURE，“ write”）; printf（“写入管道的字节：％d \ n”，n）;返回EXIT_SUCCESS;}</p><p> There are a few other kernel specific approaches to guess the maximum buffer sizethat can be stored inside the kernel. One of them is to read  PIPE_SIZE from  &lt;sys/pipe.h&gt;on BSD systems, but given that it is 16384 for FreeBSD, NetBSD and OpenBSD, it’s merely aninternal implementation specific header.</p><p> 还有一些其他特定于内核的方法来猜测可以存储在内核中的最大缓冲区大小。其中之一是从BSD系统上的读取PIPE_SIZE，但考虑到FreeBSD，NetBSD和OpenBSD的PIPE_SIZE为16384，它只是内部特定于实现的标头。</p><p> In order to make the picture fuller, we need to mention that the FreeBSD and NetBSD kernelsallow tuning of the pipe behavior and investigatingthe kernel virtual address spent on the buffers.</p><p> 为了使图片更完整，我们需要提到FreeBSD和NetBSD内核允许调整管道行为并调查在缓冲区上花费的内核虚拟地址。</p><p>      What are “big” pipes in NetBSD? They are special case pipes that exceed  PIPE_SIZE four times (giving 65536 bytes) on atomic writes.The maximum number of “big” pipes is set by default to 32, but can be tuned dynamically in runtime.</p><p>在NetBSD中什么是“大”管道？它们是特殊情况下的管道，在原子写入时超过PIPE_SIZE的四倍（给定65536字节）。默认情况下，“大”管道的最大数量设置为32，但可以在运行时动态调整。</p><p>  As we can see, these limits highly depend on the Operating System and the portableapproach to pick the buffer size with guaranteed atomic writes is to use the POSIX limitsrepresented by  PIPE_BUF and  _PC_PIPE_BUF or fallback to the bare minimum allowed by POSIX at 512 bytes.</p><p>  如我们所见，这些限制在很大程度上取决于操作系统，而选择具有保证的原子写入的缓冲区大小的可移植方法是使用PIPE_BUF和_PC_PIPE_BUF表示的POSIX限制，或者回退到POSIX所允许的最小字节数512字节。</p><p> In practice, sometimes it’s not important whether an operation will block or not, as the kernelwill handle the communication channel with a sequence of write and read operations, and blockingthe appropriate end upon reaching the internal kernel buffer limit. Properly designed softwareshall be immune to the buffering sizes and defer the buffering sizes to the kernel designerswho tuned the mechanism for maximal efficiency.</p><p> 在实践中，有时是否阻塞操作并不重要，因为内核将通过一系列读写操作来处理通信通道，并在达到内部内核缓冲区限制时阻塞适当的端点。正确设计的软件应不受缓冲大小的影响，并将缓冲大小推迟给内核设计人员，后者调整了该机制以实现最大效率。</p><p> Why not raise the limits to very large sizes like 32 megabytes? Because the kernel would be proneto Denial of Service attacks, more easily going out of available kernel virtual memory.</p><p> 为什么不将限制提高到32 MB之类的超大尺寸？由于内核将是proneto拒绝服务攻击，因此更容易从可用内核虚拟内存中移出。</p><p>  Furthermore, the whole mechanism could lead to undesirable waste of kernel memory and in some cornercases even to the latencies similar to  bufferbloat.</p><p>  此外，整个机制可能导致不希望的内核内存浪费，甚至在某些极端情况下甚至导致类似于缓冲膨胀的延迟。</p><p>  We have introduced the reader to the UNIX pipe concept and presented the basic characteristics of thisinterprocess communication channel. In the next part, we will dig into the examples of combiningtwo processes and managing the byte transfers.</p><p>  我们向读者介绍了UNIX管道概念，并介绍了此进程间通信通道的基本特征。在下一部分中，我们将深入探讨结合两个进程和管理字节传输的示例。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.moritz.systems/blog/mastering-unix-pipes-part-1/">https://www.moritz.systems/blog/mastering-unix-pipes-part-1/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/unix/">#unix</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/管道/">#管道</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>