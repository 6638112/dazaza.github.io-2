<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Rust为1100万并发用户扩展Elixir</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">使用Rust为1100万并发用户扩展Elixir</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-11 08:32:49</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/d8a50e934080e1cb6b2fa8ece56296f9.png"><img src="http://img2.diglog.com/img/2020/11/d8a50e934080e1cb6b2fa8ece56296f9.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Over the last year, the Backend Infrastructure team at Discord was hard at work improving the scalability and performance of our core real-time communications infrastructure.</p><p>在过去的一年里，Discorde的后端基础设施团队一直在努力提高我们核心实时通信基础设施的可扩展性和性能。</p><p> One big project we undertook was changing how we update the Member List (all those nifty people on the right side of the screen). Instead of sending updates for every single person in the Member List, we could just send down the updates for the visible portion of the Member List. This has obvious benefits such as less network traffic, less CPU usage, better battery life; the list goes on and on.</p><p>我们承担的一个大项目是改变我们更新会员列表的方式(屏幕右侧所有漂亮的人)。我们不需要为成员列表中的每个人发送更新，只需向下发送成员列表中可见部分的更新即可。这有明显的好处，比如更少的网络流量，更少的CPU使用量，更长的电池续航时间；不胜枚举。</p><p> However, this posed one big problem on the server side: We needed a data structure capable of holding hundreds of thousands of entries, sorted in a particular way that can accept and process tons of mutations, and can report back indices of where things are being added and removed.</p><p>然而，这给服务器端带来了一个大问题：我们需要一种能够容纳数十万个条目的数据结构，以一种特殊的方式进行排序，可以接受和处理大量的突变，并且可以返回添加和删除内容的索引。</p><p> Elixir is a functional language; its data structures are immutable. This is great for reasoning about code and supporting the massive concurrency you enjoy when you write Elixir. The double-edged sword of immutable data structures is that mutations are modeled by taking an existing data structure and an operation and creating a brand new data structure that is the result of applying that operation to the existing data structure.</p><p>ELXIR是一种函数式语言；它的数据结构是不可变的。这对于代码推理和支持您在编写Elixir时享受到的大规模并发性非常有用。不可变数据结构的双刃剑是，突变是通过采用现有数据结构和操作并创建全新的数据结构来建模的，该数据结构是将该操作应用于现有数据结构的结果。</p><p> This meant that when someone joined a server — internally referred to as guilds — with a Member List of 100,000 members, we would have to build a new list with 100,001 members in it. The BEAM VM is pretty speedy and  getting faster everyday. It tries to take advantage of  persistent data structures where it can, but at the scale we operate, these large lists could not be updated fast enough.</p><p>这意味着，当某人加入一个拥有10万名成员的服务器(内部称为行会)时，我们将不得不构建一个包含100,001名成员的新列表。BEAM VM速度相当快，而且每天都在变得更快。它试图在可能的情况下利用持久数据结构，但在我们运营的规模上，这些大型列表的更新速度还不够快。</p><p>  Two engineers took up the challenge of making a pure Elixir data structure that could hold large sorted sets and support fast mutation operations. This is easier said than done, so let’s put on our Computer Science helmets and go spelunking into the caves of data structure design.</p><p>两名工程师接受了挑战，制造出一种纯粹的万灵丹数据结构，它可以容纳大的排序集，并支持快速变异操作。这说起来容易做起来难，所以让我们戴上计算机科学的头盔，深入数据结构设计的洞穴。</p><p> Elixir ships with a set implementation called MapSet. MapSet is a general purpose data structure built on top of the Map data structure. It’s useful for lots of Set operations, but it provides no guarantees around ordering, which is a key requirement for the Member List. This pretty much ruled out MapSet as a contender.</p><p>ELXIR附带一个名为MapSet的Set实现。MapSet是建立在Map数据结构之上的通用数据结构。它对许多集合操作很有用，但是它不能保证排序，而排序是成员列表的一个关键要求。这几乎排除了MapSet作为竞争者的可能性。</p><p> Next up would be the venerable List type: wrap the List with a helper that would enforce uniqueness and sort the list after insertion of new elements. A quick benchmark of this approach shows that for small lists — 5,000 elements— insertion time was measured between 500𝜇s and 3,000𝜇s. This was already far too slow to be viable.</p><p>接下来是令人敬畏的列表类型：使用帮助器包装列表，该帮助器将强制唯一性，并在插入新元素后对列表进行排序。这种方法的一个快速基准显示，对于5,000个元素的小列表，插入时间在500𝜇s到3,000𝜇s之间测量。这已经太慢了，无法实现。</p><p> Even worse, the performance of insertion scaled with size of list and depth of position in the list. Worst case that was benchmarked was adding a new element to the end of a 250,000 item list, which came in around 170,000𝜇s: basically an eternity.</p><p>更糟糕的是，插入的性能随列表的大小和在列表中的位置深度而变化。最糟糕的情况是在250,000个项目列表的末尾添加一个新元素，这个列表大约有170,000个𝜇：基本上是永恒的。</p><p>   Erlang ships with a module called ordsets. Ordsets are Ordered Sets, so sounds like we found the solution to our problem: Let’s break out the benchmarking to check for viability. When the list is small the performance looks pretty great measuring between 0.008𝜇s and 288𝜇s. Sadly, when the size tested was increased to 250,000 worst-case performance increased to 27,000𝜇s, which was five times faster than our custom List implementation but still not fast enough.</p><p>Erlang附带了一个名为ordsets的模块。Ordset是有序集，所以听起来我们找到了问题的解决方案：让我们打破基准测试来检查可行性。当列表很小时，性能看起来相当不错，介于0.008𝜇和288𝜇之间。遗憾的是，当测试的大小增加到250,000时，最坏情况下的性能会增加到27,000𝜇，这比我们的自定义列表实现快了五倍，但仍然不够快。</p><p> Having exhausted all the obvious candidates that come with the language, a cursory search of packages was done to see if someone else had already solved and open sourced the solution to this problem. A few packages were checked, but none of them provided the properties and performance required. Thankfully, the field of Computer Science has been optimizing algorithms and data structures for storing and sorting data for the last 60 years, so there were plenty of ideas about how to proceed.</p><p>在用尽了该语言附带的所有明显的候选程序之后，我们粗略地搜索了一下包，看看是否有人已经解决了这个问题并将其开源。检查了几个包，但它们都没有提供所需的属性和性能。值得庆幸的是，在过去的60年里，计算机科学领域一直在优化存储和排序数据的算法和数据结构，因此有很多关于如何继续进行的想法。</p><p>  The ordsets perform extremely well at small sizes. Maybe there was some way that we could chain a bunch of very small ordsets together and quickly access the correct one when accessing a particular position. If you turn your head sideways and squint real hard, this starts to look like a  Skip List, which is exactly what was implemented.</p><p>在小尺寸的情况下，这些数据集表现得非常好。也许有某种方法可以让我们将一堆非常小的指令集链接在一起，并在访问特定位置时快速访问正确的指令集。如果你侧着头，使劲眯着眼睛，这看起来就像是跳过列表，而这正是你所实现的。</p><p> The first incarnation of this new data structure was pretty straightforward. The OrderedSet was a wrapper around a list of Cells, inside each cell was a small ordset: the first item of the ordset, the last item of the ordset, and a count of the number of items. This allowed the OrderedSet to quickly traverse the list of Cells to find the appropriate Cell and then do a very fast ordset operation. By leveraging compile time guards in the implementation of traversal, you can get pretty good performance in the worst case scenarios that stymie ordset. Insertion of an item at the end of a 250,000 item list dropped from 27,000𝜇s to 5,000𝜇s, five times faster than raw ordsets and 34 times faster than the naive List implementation.</p><p>这种新数据结构的第一个化身非常简单。OrderedSet是单元格列表的包装器，每个单元格内部都有一个较小的命令集：命令集的第一项、命令集的最后一项和项数的计数。这允许OrderedSet快速遍历单元格列表以找到合适的单元格，然后执行非常快速的命令集操作。通过在遍历实现中利用编译时间保护，您可以在阻碍命令集的最坏情况下获得相当好的性能。在250,000个条目列表末尾插入条目的速度从27,000𝜇下降到5,000𝜇，比原始命令集快5倍，比朴素列表实现快34倍。</p><p>  The old worst case was better, but a new worst case of insertion at the beginning of the list had been created; a 250,000 item list was clocking in at 19,000𝜇s. Wat?!</p><p>旧的最差情况更好一些，但新的最差情况是在列表开头插入；一个250,000个项目列表以19,000个𝜇记录。什么？！</p><p> This makes sense if you think about the data structure. When you insert an item into the front of the OrderedSet it ends up in the first Cell, but that Cell is full, so it evicts its last item to the next Cell, but that Cell is full, so it evicts its last item to the next Cell, and so on. At this point, most engineers would shrug and say “You can’t have your cake and eat it too,” but at Discord we are pushing the envelope on quantum cake technology.</p><p>如果您考虑一下数据结构，这是有意义的。当您将一项插入到OrderedSet的前面时，它会在第一个Cell中结束，但该Cell是满的，因此它会将其最后一项逐出到下一个Cell，但该Cell是满的，因此它会将其最后一项逐出到Next Cell，依此类推。在这一点上，大多数工程师会耸耸肩，说“你不能既有蛋糕又吃蛋糕”，但在意见不一的情况下，我们正在挑战量子蛋糕技术的极限。</p><p>  The problem is that when things fill up, operations can cascade from Cell to Cell. What if we could do something more clever? What if we allow Cells to swell and split, dynamically inserting new Cells in the middle of the list? This is slightly more expensive, but has the benefit that the worst case is a Cell Split instead of 2N Cell operations, where N is the number of Cells.</p><p>问题是，当空间被填满时，操作可能会从一个Cell级联到另一个Cell。如果我们能做些更聪明的事呢？如果我们允许单元格膨胀和拆分，并在列表中间动态插入新单元格，会怎么样？这样做的成本稍高，但好处是，最糟糕的情况是信元拆分，而不是2N个信元操作，其中N是信元的数量。</p><p>  At small list sizes, this new dynamic OrderedSet could perform insertions at any point in the list between 4𝜇s and 34𝜇s. Not bad. The real test came when we cranked up the size to 250,000. Inserting at the beginning of the list took…. drumroll…. 4𝜇s. That’s looking fast. But remember last time we made one number fast, we made another slow. Maybe the end of the list is horrible now, better check.</p><p>在较小的列表大小下，这个新的Dynamic OrderedSet可以在列表中4个𝜇到34个𝜇之间的任意位置执行插入。当我们把尺寸扩大到25万件时，真正的考验来了。在列表开头插入花费了…。。鼓声…。。4个𝜇s。看起来很快。但请记住，上一次我们让一个数字变快了，我们又让另一个数字变慢了。也许现在名单的末尾很可怕，最好检查一下。</p><p> With a list size of 250,000 items, inserting an item at the end of the list took 640𝜇s. Looks like we have a winner.</p><p>在列表大小为250,000项的情况下，在列表末尾插入一项需要640𝜇。看起来我们有赢家了。</p><p>   This solution would work for guilds up to 250,000 members, but that was the scaling limit. For a lot of people, this would have been the end of the story. But Discord has been using Rust to make things go fast, and we posed a question: “Could we use Rust to go faster?”</p><p>这个解决方案适用于最多25万名会员的公会，但这是扩展的限制。对于很多人来说，这将是故事的结局。但不和谐组织一直在利用铁锈让事情发展得更快，我们提出了一个问题：“我们能用铁锈来加快速度吗？”</p><p> Rust is not a functional language, and will happily let you mutate data structures. It also has no run-time and provides “zero-cost abstractions.” If we could somehow get Rust to manage this set, it would probably perform much better.</p><p>Rust不是一种函数式语言，它可以让您很高兴地改变数据结构。它也没有运行时，并提供“零成本抽象”。如果我们能以某种方式让拉斯特来管理这套设备，它的表现可能会好得多。</p><p> Our core services aren’t written in Rust, they are Elixir-based. Elixir serves this purpose very well, and lucky for us, the BEAM VM had another nifty trick up its sleeve. The BEAM VM has three types of functions:</p><p>我们的核心服务不是用Rust写的，它们是基于长生不老药的。长生不老药很好地实现了这一目的，幸运的是，BEAM VM还有另一个妙招。BEAM VM具有三种类型的功能：</p><p> Functions that are built into the language and act as the building blocks for user-space functions. These are called BIFs or Built-In Functions.</p><p>内置于语言中并充当用户空间函数的构建块的函数。这些被称为BIF或内置函数。</p><p> Then there are NIFs or Native Implemented Functions. These are functions that are built in C or Rust and compiled into the BEAM VM. Calling these functions is just like calling a BIF but, you can control what it does.</p><p>然后是NIF或原生实现的功能。这些函数是用C或Rust构建的，并编译到BEAM VM中。调用这些函数就像调用BIF一样，但您可以控制它的功能。</p><p> There’s a fantastic Elixir project called  Rustler. It provides nice support on the Elixir and Rust side for making a safe NIF that is well behaved and using the guarantees of Rust is guaranteed not to crash the VM or leak memory.</p><p>有一个很棒的长生不老药项目叫“铁匠”。它在Elixir和Rust端提供了很好的支持，以创建行为良好的安全NIF，并且使用Rust的保证不会导致VM崩溃或内存泄漏。</p><p> We set aside a week to see if this would be worth the effort. By the end of the week, we had a very limited proof-of-concept that we could measure. The first benchmarks were extremely promising. The best case for adding an item to the set was 0.4𝜇s with a worst case of 2.85𝜇s, compared to OrderedSet’s 4𝜇s to 640𝜇s. This was a benchmark just using integers, but it was enough evidence to build out support for a wider range of Erlang Terms and fill out the rest of the functionality.</p><p>我们留出了一周的时间，看看这是否值得我们付出努力。到了周末，我们可以衡量的概念证明非常有限。第一批基准非常有希望。向集合中添加条目的最好情况是0.4Erlang s，最差情况是2.85Erlang s，而OrderedSet的最差情况是4𝜇到640Erlang s。这只是一个使用整数的基准，但它足以增强对更广泛的𝜇术语的支持，并完善其余功能。</p><p> With the spike showing so much promise, we continued on building out support for most Erlang Terms and all the functionality we needed for the member list. It was time to benchmark again. We cranked the number of items all the way up to 1,000,000 items. The test machine churned for a few minutes and finally printed out the result: SortedSet best case was 0.61𝜇s and worst case was 3.68𝜇s, testing multiple sizes of sets from 5,000 to 1,000,000 items.</p><p>随着这个峰值显示出如此多的前景，我们继续构建对大多数Erlang术语的支持，以及成员列表所需的所有功能。现在是再次制定基准的时候了。我们把商品数量一路增加到100万件。测试机搅拌了几分钟，最后打印出结果：SortedSet最好的情况是0.61𝜇，最坏的情况是3.68𝜇，测试了从5,000到1,000,000个项目的多种大小的集合。</p><p> For the second iteration in a row we were able to make the worst case as good as the previous iterations best-case timings.</p><p>对于连续的第二次迭代，我们能够使最坏的情况与前一次迭代的最佳情况计时一样好。</p><p>  The Rust backed NIF provides massive performance benefits without trading off ease of use or memory. Since the library operations all clocked in well under the 1 millisecond threshold, we could just use the built-in Rustler guarantees and not need to worry about reductions or yielding. The SortedSet module looks to the caller to just be a vanilla Elixir module that performs crazy fast.</p><p>铁锈支持的NIF在不牺牲易用性或内存的情况下提供了巨大的性能优势。由于图书馆的所有操作都在1毫秒的阈值以下，我们可以只使用内置的Rustler保证，而不需要担心减少或减少。在调用者看来，SortedSet模块只是一个执行速度非常快的香草药剂模块。</p><p>  Today, the Rust backed SortedSet powers every single Discord guild: from the 3 person guild planning a trip to Japan to 200,000 people enjoying the latest, fun game.</p><p>今天，铁锈支持的SortedSet为每一个不和谐的行会提供动力：从计划去日本旅行的3人行会到20万人正在享受最新的有趣游戏。</p><p> Since deploying SortedSet, we’ve seen performance improve across the board with no impact to memory pressure. We learned that Rust and Elixir can work side by side to operate in extremely tight performance constraints. We can still keep our core real-time communications logic in the higher-level Elixir with its wonderful guarantees and easy concurrency while dropping down into Rust when needed.</p><p>自从部署SortedSet以来，我们看到性能在没有影响内存压力的情况下全面提升。我们了解到，铁锈和长生不老药可以并排工作，在极其严格的性能约束下运行。我们仍然可以将我们的核心实时通信逻辑保留在更高级别的灵丹妙药中，因为它具有出色的保证和容易的并发性，并且在需要时可以下降到Rust中。</p><p> If you need a high-speed mutation friendly SortedSet,  we have released SortedSet as an open source library.</p><p>如果你需要一个高速变异友好的SortedSet，我们已经发布了一个开源的SortedSet。</p><p> If solving hard problems with awesome tools like Elixir and Rust is interesting to you,  go check out our jobs page.</p><p>如果你对使用像Elixir和Rust这样的强大工具来解决难题感兴趣，那就去看看我们的招聘页面吧。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.discord.com/using-rust-to-scale-elixir-for-11-million-concurrent-users-c6f19fc029d3">https://blog.discord.com/using-rust-to-scale-elixir-for-11-million-concurrent-users-c6f19fc029d3</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/scale/">#scale</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/列表/">#列表</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034383.html"><img src="http://img2.diglog.com/img/2020/11/thumb_13adc774d7220747f1b03cc994ede446.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034383.html">InfluxDB将赌注押在Rust和Apache Arrow的下一代数据存储上</a></div><span class="my_story_list_date">2020-11-11 4:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034269.html"><img src="http://img2.diglog.com/img/2020/11/thumb_524109d84e42d6e5e81376458a2dafa9.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034269.html">亚马逊因使用商家数据而面临欧盟反垄断指控：来源</a></div><span class="my_story_list_date">2020-11-10 22:26</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034264.html"><img src="http://img2.diglog.com/img/2020/11/thumb_1eb6a76bdc96a6c7ea176671840feb7e.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034264.html">欧盟就亚马逊使用数据提起反垄断诉讼</a></div><span class="my_story_list_date">2020-11-10 22:20</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034251.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c1dfc94501cbe88803516dad93e2d016.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034251.html">
欧洲对亚马逊使用大数据提起反垄断诉讼</a></div><span class="my_story_list_date">2020-11-10 21:2</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>