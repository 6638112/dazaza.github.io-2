<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>PG8000  -  Pure-Python PostgreSQL驱动程序 Pg8000 – Pure-Python PostgreSQL driver</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Pg8000 – Pure-Python PostgreSQL driver<br/>PG8000  -  Pure-Python PostgreSQL驱动程序 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-14 01:19:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/c6ad49a465a06eb847d9dbe9539daab0.png"><img src="http://img2.diglog.com/img/2021/5/c6ad49a465a06eb847d9dbe9539daab0.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>pg8000 comes with two APIs, the native pg8000 API and the DB-API 2.0 standardAPI. These are the examples for the native API, and the DB-API 2.0 examplesfollow in the next section.</p><p>PG8000配有两个API，本机PG8000 API和DB-API 2.0 StandardAPI。这些是本机API的示例，DB-API 2.0在下一部分中的示例示例。</p><p> Import pg8000, connect to the database, create a table, add some rows and thenquery the table:</p><p> 导入pg8000，连接数据库，创建一个表，添加一些行，然后添加一个表：</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  # Connect to the database with user name postgres &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  # Create a temporary table &gt;&gt; &gt; &gt;&gt; &gt;  con. run( &#34;CREATE TEMPORARY TABLE book (id SERIAL, title TEXT)&#34;)[] &gt;&gt; &gt; &gt;&gt; &gt;  # Populate the table &gt;&gt; &gt; &gt;&gt; &gt;  for  title  in ( &#34;Ender&#39;s Game&#34;,  &#34;The Magus&#34;):...  con. run( &#34;INSERT INTO book (title) VALUES (:title)&#34;,  title = title)[][] &gt;&gt; &gt; &gt;&gt; &gt;  # Print all the rows in the table &gt;&gt; &gt; &gt;&gt; &gt;  for  row  in  con. run( &#34;SELECT * FROM book&#34;):...  print( row)[ 1,  &#34;Ender&#39;s Game&#34;][ 2,  &#39;The Magus&#39;]</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃使用用户名Postgres＆gt连接到数据库。＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃创建一个临时表＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。跑（＆＃34;创建临时表书（ID序列，标题文本）＆＃34;）[]＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃填充表格＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;在（＆＃34; enter＆＃39; same＆＃34 ;,＆＃34; magus＆＃34;）：...骗局的标题运行（＆＃34;插入到书籍（标题）值（：title）＆＃34;标题= title）[] [] []＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃打印表格中的所有行＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;在骗局中排行。 run（＆＃34;从书中选择*，从书中选择*）：...打印（行）[1，＆＃34; enter＆＃39; s游戏＆＃34;] [2，＆＃39; magus＆＃39 ;]</p><p> &gt;&gt;&gt; import pg8000.native&gt;&gt;&gt;&gt;&gt;&gt; con = pg8000.native.Connection(&#34;postgres&#34;, password=&#34;cpsnow&#34;)&gt;&gt;&gt;&gt;&gt;&gt; con.run(&#34;START TRANSACTION&#34;)[]&gt;&gt;&gt; # Create a temporary table&gt;&gt;&gt; con.run(&#34;CREATE TEMPORARY TABLE book (id SERIAL, title TEXT)&#34;)[]&gt;&gt;&gt; for title in (&#34;Ender&#39;s Game&#34;, &#34;The Magus&#34;, &#34;Phineas Finn&#34;):... con.run(&#34;INSERT INTO book (title) VALUES (:title)&#34;, title=title)[][][]&gt;&gt;&gt; con.run(&#34;COMMIT&#34;)[]&gt;&gt;&gt; for row in con.run(&#34;SELECT * FROM book&#34;):... print(row)[1, &#34;Ender&#39;s Game&#34;][2, &#39;The Magus&#39;][3, &#39;Phineas Finn&#39;]</p><p> ＆gt;＆gt;＆gt;进口PG8000.NAID＆gt;＆gt;＆gt;＆gt;＆gt;＆gt; CON = pg8000.native.Connection（＆＃34; postgres的＆＃34 ;,密码=＆＃34; cpsnow＆＃34;）＆GT;＆GT;＆GT;＆GT;＆GT;＆GT; con.run（＆＃34;开始交易＆＃34;）[]＆gt;＆gt; ＃创建一个临时表＆gt;＆gt;＆gt; con.run（＆＃34;创建临时表图书（ID序列，标题文本）＆＃34;）[]＆gt;＆gt;＆gt;在（＆＃34; enter＆＃39; s游戏中的标题和＃34;＆＃34; Magus＆＃34 ;,＆＃34; phineas finn＆＃34;）：...康明（＆＃34;插入书（标题）值（：标题）＆＃34;，标题=标题）[] [] [] [] [] []＆gt;＆gt;＆gt; con.run（＆＃34;提交＆＃34;）[]＆gt;＆gt;在Con.Run中的行（＆＃34;从书中选择*）：...打印（行）[1，＆＃34; Ender＆＃39; s游戏＆＃34;] [2，＆＃39 ; Magus＆＃39;] [3，＆＃39; phineas finn＆＃39;]</p><p>  &gt;&gt;&gt; import pg8000.native&gt;&gt;&gt;&gt;&gt;&gt; con = pg8000.native.Connection(&#34;postgres&#34;, password=&#34;cpsnow&#34;)&gt;&gt;&gt;&gt;&gt;&gt; # Create a temporary table&gt;&gt;&gt; con.run(&#34;CREATE TEMPORARY TABLE book (id SERIAL, title TEXT)&#34;)[]&gt;&gt;&gt; for title in (&#34;Ender&#39;s Game&#34;, &#34;The Magus&#34;, &#34;Phineas Finn&#34;):... con.run(&#34;INSERT INTO book (title) VALUES (:title)&#34;, title=title)[][][]&gt;&gt;&gt;&gt;&gt;&gt; con.run(&#34;START TRANSACTION&#34;)[]&gt;&gt;&gt; con.run(&#34;DELETE FROM book WHERE title = :title&#34;, title=&#34;Phineas Finn&#34;)[]&gt;&gt;&gt; con.run(&#34;ROLLBACK&#34;)[]&gt;&gt;&gt; for row in con.run(&#34;SELECT * FROM book&#34;):... print(row)[1, &#34;Ender&#39;s Game&#34;][2, &#39;The Magus&#39;][3, &#39;Phineas Finn&#39;]</p><p>  ＆gt;＆gt;＆gt;进口PG8000.NAID＆gt;＆gt;＆gt;＆gt;＆gt;＆gt; CON = pg8000.native.Connection（＆＃34; postgres的＆＃34 ;,密码=＆＃34; cpsnow＆＃34;）＆GT;＆GT;＆GT;＆GT;＆GT;＆GT; ＃创建一个临时表＆gt;＆gt;＆gt; con.run（＆＃34;创建临时表图书（ID序列，标题文本）＆＃34;）[]＆gt;＆gt;＆gt;在（＆＃34; enter＆＃39; s游戏中的标题和＃34;＆＃34; Magus＆＃34 ;,＆＃34; phineas finn＆＃34;）：...康明（＆＃34; INSERT INTO书（标题）VALUES（：标题）＆＃34 ;,标题=标题）[] [] []＆GT;＆GT;＆GT;＆GT;＆GT;＆GT; con.run（＆＃34;开始交易＆＃34;）[]＆gt;＆gt; con.run（＆＃34;从标题=：title＆＃34;，标题=＆＃34; phineas finn＆＃34;）[]＆gt;＆gt; con.run（＆＃34;回滚＆＃34;）[]＆gt;＆gt;在Con.Run中的行（＆＃34;从书中选择*）：...打印（行）[1，＆＃34; Ender＆＃39; s游戏＆＃34;] [2，＆＃39 ; Magus＆＃39;] [3，＆＃39; phineas finn＆＃39;]</p><p>  &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  import  datetime &gt;&gt; &gt; &gt;&gt; &gt;  ts  =  datetime. date( 1980,  4,  27) &gt;&gt; &gt;  con. run( &#34;SELECT timestamp &#39;2013-12-01 16:06&#39; - :ts&#34;,  ts = ts)[[ datetime. timedelta( days = 12271,  seconds = 57960)]]</p><p>  ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;导入DateTime＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ts = datetime。日期（1980,4,27）＆gt;＆gt; ＆gt;骗子。跑（＆＃34;选择时间戳＆＃39; 2013-12-01 16：06＆＃39;  - ：Ts＆＃34;，ts = ts）[[DateTime。 Timedelta（天= 12271，秒= 57960）]]</p><p>  When communicating with the server, pg8000 uses the character set that theserver asks it to use (the client encoding). By default the client encoding isthe database’s character set (chosen when the database is created), but theclient encoding can be changed in a number of ways (eg. settingCLIENT_ENCODING in postgresql.conf). Another way of changing the clientencoding is by using an SQL command. For example:</p><p>  与服务器通信时，PG8000使用TheServer要求使用的字符集（客户端编码）。默认情况下，客户端编码是数据库的字符集（在创建数据库时选择），但是可以以多种方式更改，但是可以以多种方式更改（例如，postgreSQL.conf中的setcarlient_encoding）。改变ClientEncodinging的另一种方式是使用SQL命令。例如： </p><p> JSON always comesback from the server de-serialized. If the JSON you want to send is a  dictthen you can just do:</p><p>JSON始终从服务器释放出序列化。如果你要发送的json是一个dictthen，你可以刚才做：</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  val  = { &#39;name&#39;:  &#39;Apollo 11 Cave&#39;,  &#39;zebra&#39;:  True,  &#39;age&#39;:  26.003} &gt;&gt; &gt;  con. run( &#34;SELECT :apollo&#34;,  apollo = val)[[{ &#39;age&#39;:  26.003,  &#39;name&#39;:  &#39;Apollo 11 Cave&#39;,  &#39;zebra&#39;:  True}]]</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; val = {＆＃39;：＆＃39; apollo 11洞穴＆＃39 ;,＆＃39; zebra＆＃39; true，＆＃39;年龄＆＃39 ;: 26.003}＆gt;＆gt; ＆gt;骗子。运行（＆＃34;选择：apollo＆＃34;，apollo = val）[[{＆＃39;年龄＆＃39;：26.003，＆＃39;名称＆＃39 ;:＆＃39; apollo 11洞穴＆＃39; ，＆＃39;斑马＆＃39;：true}]]</p><p>  &gt;&gt; &gt;  import  json &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt; &gt;&gt; &gt;  val  = [ &#39;Apollo 11 Cave&#39;,  True,  26.003] &gt;&gt; &gt;  con. run( &#34;SELECT CAST(:apollo as jsonb)&#34;,  apollo = json. dumps( val))[[[ &#39;Apollo 11 Cave&#39;,  True,  26.003]]]</p><p>  ＆gt;＆gt; ＆gt;进口json＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; val = [＆＃39;阿波罗11洞穴＆＃39;，真实，26.003]＆gt;＆gt; ＆gt;骗子。 run（＆＃34;选择cast（：apolloasejsonb）＆＃34; apollo = json。转储（val））[[＆＃39; apollo 11 cave＆＃39;，26.003]]]</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  con. run( &#34;create temporary table quark (id serial, name text)&#34;)[] &gt;&gt; &gt;  for  name  in ( &#39;Up&#39;,  &#39;Down&#39;):...  con. run( &#34;INSERT INTO quark (name) VALUES (:name)&#34;,  name = name)[][] &gt;&gt; &gt;  # Now execute the query &gt;&gt; &gt; &gt;&gt; &gt;  con. run( &#34;SELECT * FROM quark&#34;)[[ 1,  &#39;Up&#39;], [ 2,  &#39;Down&#39;]] &gt;&gt; &gt; &gt;&gt; &gt;  # and retried the metadata &gt;&gt; &gt; &gt;&gt; &gt;  con. columns[{ &#39;table_oid&#39;: ...,  &#39;column_attrnum&#39;:  1,  &#39;type_oid&#39;:  23,  &#39;type_size&#39;:  4,  &#39;type_modifier&#39;:  - 1,  &#39;format&#39;:  0,  &#39;name&#39;:  &#39;id&#39;}, { &#39;table_oid&#39;: ...,  &#39;column_attrnum&#39;:  2,  &#39;type_oid&#39;:  25,  &#39;type_size&#39;:  - 1,  &#39;type_modifier&#39;:  - 1,  &#39;format&#39;:  0,  &#39;name&#39;:  &#39;name&#39;}] &gt;&gt; &gt; &gt;&gt; &gt;  # Show just the column names &gt;&gt; &gt; &gt;&gt; &gt; [ c[ &#39;name&#39;]  for  c  in  con. columns][ &#39;id&#39;,  &#39;name&#39;]</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。运行（＆＃34;创建临时表夸克（ID序列，名称文本）＆＃34;）[]＆gt;＆gt; ＆gt;在（＆＃39;＆＃39;＆＃39; down＆＃39;）的名称：...骗局。 run（＆＃34;插入zhark（名称）值（：name）＆＃34;，name = name）[] []＆gt;＆gt; ＆gt; ＃现在执行Query＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。运行（＆＃34;从Quark＆＃34选择*）[[1，＆＃39; Up＆＃39;]，[2，＃39;＆＃39;]]＆gt;＆gt;＆gt;＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃并重试元数据＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。列[{＆＃39; table_oid＆＃39 ;: ...，＆＃39; column_attrnum＆＃39 ;: 1，＆＃39; type_oid＆＃39 ;: 23，＆＃39; type_size＆＃39 ;: 4，＆ ＃39; type_modifier＆＃39 ;:  -  1，＆＃39;格式＆＃39 ;: 0，＆＃39;姓名＆＃39 ;:＆＃39; id＆＃39; {＆＃39; table_oid＆＃39; ：...，＆＃39; column_attrnum＆＃39 ;: 2，＆＃39; type_oid＆＃39 ;: 25，＆＃39; type_size＆＃39 ;:  -  1，＆＃39; type_modifier＆＃39 ;:  -  1 ，＆＃39;格式＆＃39 ;: 0，＆＃39;姓名＆＃39 ;:＆＃39;名称＆＃39;}]＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃显示列名称＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; [C [＆＃39;符号名称＆＃39;] con。列[＆＃39; id＆＃39;＆＃39;名称＆＃39;]</p><p> PostgreSQL  noticesare stored in a deque called  Connection.notices and added using the append() method. Similarly there are  Connection.notifications for notificationsand  Connection.parameter_statuses for changes to the server configuration.Here’s an example:</p><p> PostgreSQL标记存储在称为Connection.Notices并使用Append（）方法添加的DEQUE。类似地，存在Connectification.notificationsand.parameter_statuses，用于更改服务器配置。的一个例子：</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  con. run( &#34;LISTEN aliens_landed&#34;)[] &gt;&gt; &gt;  con. run( &#34;NOTIFY aliens_landed&#34;)[] &gt;&gt; &gt;  # A notification is a tuple containing (backend_pid, channel, payload) &gt;&gt; &gt; &gt;&gt; &gt;  con. notifications[ 0](...,  &#39;aliens_landed&#39;,  &#39;&#39;)</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。跑（＆＃34;听aliens_landed＆＃34;）[]＆gt; ＆gt;骗子。跑（＆＃34;通知Aliens_landed＆＃34;）[]＆gt;＆gt; ＆gt; ＃通知是包含（后退_pid，频道，有效载荷）＆gt;＆gt的元组。 ＆gt; ＆gt;＆gt; ＆gt;骗子。通知[0]（...，＆＃39; aliens_landed＆＃39;＆＃39;＆＃39;）</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  con. run( &#34;SELECT &#39;silo 1&#39; LIMIT :lim&#34;,  lim = &#39;ALL&#39;) Traceback ( most  recent  call  last): pg8000. exceptions. DatabaseError: ...</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。跑（＆＃34; select＆＃39; silo 1＆＃39; lims：lim＆＃34 ;,5 lim =＆＃39;全部＆＃39;）回溯（最近呼叫最后）：pg8000。例外。数据库错误： ... </p><p> Instead the  docs saythat you can send  null as an alternative to  ALL, which does work:</p><p>相反，Docs Saytht您可以将空闲作为所有工作的替代品，这是工作：</p><p> You might think that the following would work, but in fact the server doesn’tlike it:</p><p> 您可能会认为以下会有效，但实际上服务器没有：</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  con. run( &#34;SELECT &#39;silo 1&#39; WHERE &#39;a&#39; IN :v&#34;,  v =( &#39;a&#39;,  &#39;b&#39;)) Traceback ( most  recent  call  last): pg8000. exceptions. DatabaseError: ...</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。跑（＆＃34;选择＆＃39;孤岛1＆＃39;其中＆＃39; a＆＃39;＆＃39; v＆＃34;，v =（＆＃39; a＆＃39;和＃39; b＆＃39; b＆＃39; 39;））回溯（最近呼叫最后）：PG8000。例外。数据库错误： ...</p><p>  &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  con. run( &#34;SELECT &#39;silo 1&#39; WHERE &#39;a&#39; IN (SELECT unnest(:v))&#34;,  v =( &#39;a&#39;,  &#39;b&#39;))[[ &#39;silo 1&#39;]]</p><p>  ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。跑（＆＃34; select＆＃39; silo 1＆＃39;其中＆＃39; a＆＃39;（选择UNNEST（：V））＆＃34;，v =（＆＃39; a＆＃39; ，＆＃39; b＆＃39;））[[＆＃39; silo 1＆＃39;]]</p><p> In PostgreSQL parameters can only be used for data values, not identifiers. Sometimes this might not work as expected,for example the following fails:</p><p> 在PostgreSQL参数中只能用于数据值，而不是标识符。有时，这可能无法按预期工作，例如以下失败：</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  con. run( &#34;CREATE USER juan WITH PASSWORD :password&#34;,  password = &#39;quail&#39;) Traceback ( most  recent  call  last): pg8000. exceptions. DatabaseError: ...</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。运行（＆＃34;使用密码创建用户Juan：password＆＃34;，password =＆＃39; quail＆＃39;）回溯（最近调用最后）：pg8000。例外。数据库错误： ...</p><p> It fails because the PostgreSQL server doesn’t allow this statement to haveany parameters. There are many SQL statements that one might think would haveparameters, but don’t.</p><p> 它失败，因为PostgreSQL服务器不允许此语句才能获得参数。有许多SQL陈述，人们可能认为将有很多分析器，但是没有。 </p><p> The SQL  COPY statementcan be used to copy from and to a file or file-like object. Here&#39; an exampleusing the CSV format:</p><p>SQL Copy DateplateCan可用于复制到文件或文件等对象。在这里＆＃39;一个emplyusing csv格式：</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt;  from  io  import  BytesIO &gt;&gt; &gt;  import  csv &gt;&gt; &gt;  import  codecs &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  # Create a CSV file in memory &gt;&gt; &gt; &gt;&gt; &gt;  stream_in  =  BytesIO() &gt;&gt; &gt;  StreamWriter  =  codecs. getwriter( &#39;utf-8&#39;) &gt;&gt; &gt;  csv_writer  =  csv. writer( StreamWriter( stream_in)) &gt;&gt; &gt;  csv_writer. writerow([ 1,  &#34;electron&#34;]) &gt;&gt; &gt;  csv_writer. writerow([ 2,  &#34;muon&#34;]) &gt;&gt; &gt;  csv_writer. writerow([ 3,  &#34;tau&#34;]) &gt;&gt; &gt;  stream_in. seek( 0) 0 &gt;&gt; &gt; &gt;&gt; &gt;  # Create a table and then copy the CSV into it &gt;&gt; &gt; &gt;&gt; &gt;  con. run( &#34;CREATE TEMPORARY TABLE lepton (id SERIAL, name TEXT)&#34;)[] &gt;&gt; &gt;  con. run( &#34;COPY lepton FROM STDIN WITH (FORMAT CSV)&#34;,  stream = stream_in)[] &gt;&gt; &gt; &gt;&gt; &gt;  # COPY from a table to a stream &gt;&gt; &gt; &gt;&gt; &gt;  stream_out  =  BytesIO() &gt;&gt; &gt;  con. run( &#34;COPY lepton TO STDOUT WITH (FORMAT CSV)&#34;,  stream = stream_out)[] &gt;&gt; &gt;  stream_out. seek( 0) 0 &gt;&gt; &gt;  StreamReader  =  codecs. getreader( &#39;utf-8&#39;) &gt;&gt; &gt;  for  row  in  csv. reader( StreamReader( stream_out)):...  print( row)[ &#39;1&#39;,  &#39;electron&#39;][ &#39;2&#39;,  &#39;muon&#39;][ &#39;3&#39;,  &#39;tau&#39;]</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt;来自IO导入Bytesio＆Gt;＆gt; ＆gt;进口CSV＆gt;＆gt; ＆gt;导入编解码器＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃在内存中创建CSV文件。＆gt; ＆gt; ＆gt;＆gt; ＆gt; Stream_in = bytesio（）＆gt;＆gt; ＆gt; StreamWriter =编解码器。 getwriter（＆＃39; utf-8＆＃39;）＆gt;＆gt; ＆gt; CSV_WRITER = CSV。作者（StreamWriter（Stream_in））＆gt;＆gt; ＆gt; CSV_WRITER。作品（[1，＆＃34;电子＆＃34;]）＆gt;＆gt; ＆gt; CSV_WRITER。作品（[2，＆＃34; muon＆＃34;]）＆gt;＆gt; ＆gt; CSV_WRITER。作者（[3，＆＃34; tau＆＃34;]）＆gt;＆gt; ＆gt; Stream_in。寻求（0）0＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃创建一个表，然后将CSV复制到IT＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。跑（＆＃34;创建临时表Lepton（ID序列，名称文本）＆＃34;）[]＆gt;＆gt; ＆gt;骗子。跑（＆＃34;从stdin复制leptin与（格式csv）＆＃34; stream = stream_in）[]＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃从表中复制到流＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; Stream_out = bytesio（）＆gt;＆gt; ＆gt;骗子。运行（＆＃34;用（格式csv）＆＃34; stream = stream_out）[]＆gt;＆gt; ＆gt;流出来。寻求（0）0＆gt;＆gt; ＆gt; StreamReader =编解码器。 GetReader（＆＃39; UTF-8＆＃39;）＆gt;＆gt; ＆gt;用于CSV的行。读者（StreamReader（Stream_out））：...打印（行）[＆＃39; 1＆＃39;＆＃39;电子＆＃39;] [＆＃39; 2＆＃39;＆＃39; muon＆＃ 39;] [＆＃39; 3＆＃39;＆＃39; tau＆＃39;]</p><p> If you want to execute a series of SQL statements (eg. an  .sql file), youcan run them as expected:</p><p> 如果要执行一系列SQL语句（例如,.SQL文件），则YOUCAN按预期运行它们：</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  statements  =  &#34;SELECT 5; SELECT &#39;Erich Fromm&#39;;&#34; &gt;&gt; &gt; &gt;&gt; &gt;  con. run( statements)[[ 5], [ &#39;Erich Fromm&#39;]]</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;陈述=＆＃34;选择5;选择＆＃39; eRich fromm＆＃39 ;;＆＃34; ＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。 run（陈述）[[5]，[＆＃39; eRich fromm＆＃39;]]</p><p> The only caveat is that when executing multiple statements you can’t have anyparameters.</p><p> 唯一的警告是，当执行多个陈述时，您就不能有任何parameters。</p><p> Say you had a column called  My Column. Since it’s case sensitive andcontains a space, you’d have to surround it by double quotes. But you can’t do:</p><p> 假设你有一个名为我的列的列。由于它的区分大小写，因此您必须通过双引号括起来。但你做不到：</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  con. run( &#34;select &#39;hello&#39; as &#34; My  Column &#34;&#34;) Traceback ( most  recent  call  last): SyntaxError:  invalid  syntax</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。跑（＆＃34;选择＆＃39;你好＆＃39;作为＆＃34;我的列＆＃34;＆＃34;）回溯（最近呼叫最后一个电话）：syntaxError：语法无效 </p><p> since Python uses double quotes to delimit string literals, so one solution isto use Python’s triple quotesto delimit the string instead:</p><p>由于Python使用双引号来分隔字符串文字，因此一个解决方案是使用Python的三额额相级别界定字符串：</p><p> pg8000 has a mapping from Python types to PostgreSQL types for when it needsto send SQL parameters to the server. The default mapping that comes withpg8000 is designed to work well in most cases, but you might want to add orreplace the default mapping.</p><p> PG8000具有从Python类型到PostgreSQL类型的映射，因为它需要将SQL参数发送到服务器时。在大多数情况下，Cutp8000的默认映射旨在运行良好，但您可能希望添加Orreplace默认映射。</p><p> A Python  datetime.timedelta object is sent to the server as a PostgreSQL interval type, which has the  oid 1186. But let’s say we wanted to createour own Python class to be sent as an  interval type. Then we’d have toregister an adapter:</p><p> 将Python DateTime.Timedelta对象作为PostgreSQL间隔类型发送到服务器，其中具有OID 1186.但是假设我们想创建自己的Python类作为间隔类型。然后我们已经托架了适配器：</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  class  MyInterval( str):...  pass &gt;&gt; &gt; &gt;&gt;  &gt;  def  my_interval_out( my_interval):...  return  my_interval  # Must return a str &gt;&gt; &gt; &gt;&gt; &gt;  con. register_out_adapter( MyInterval,  1186,  my_interval_out) &gt;&gt; &gt;  con. run( &#34;SELECT :interval&#34;,  interval = MyInterval( &#34;2 hours&#34;))[[ datetime. timedelta( seconds = 7200)]]</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; Class MyInterval（str）：...通过和gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; def my_interval_out（my_interval）：...返回my_interval＃必须返回str＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。 register_out_adapter（MyInterval，1186，my_interval_out）＆gt;＆gt; ＆gt;骗子。运行（＆＃34;选择：间隔＆＃34;，interval = myInterval（＆＃34; 2小时＆＃34;））[[DateTime。 Timedelta（秒= 7200）]]</p><p> Note that it still came back as a  datetime.timedelta object because we onlychanged the mapping from Python to PostgreSQL. See below for an example of howto change the mapping from PostgreSQL to Python.</p><p> 请注意，它仍然是DateTime.Timedelta对象，因为我们唯一从Python到PostgreSQL的映射。有关HOWTO将PostgreSQL的映射更改为Python的示例，请参阅下文。</p><p> pg8000 has a mapping from PostgreSQL types to Python types for when it receivesSQL results from the server. The default mapping that comes with pg8000 isdesigned to work well in most cases, but you might want to add or replace thedefault mapping.</p><p> PG8000从PostgresQL类型映射到Python类型，何时收听来自服务器的QL结果。 PG8000附带的默认映射在大多数情况下，才能运行良好，但您可能希望添加或替换thedefault映射。</p><p> If pg800 recieves PostgreSQL  interval type, which has the  oid 1186, itconverts it into a Python  datetime.timedelta object. But let’s say we wantedto create our own Python class to be used instead of  datetime.timedelta. Thenwe’d have to register an adapter:</p><p> 如果PG800收到PostgreSQL间隔类型，则具有OID 1186，它将其转换为Python DateTime.Timedelta对象。但是，让我们说我们希望创建自己的Python类来代替DateTime.Timedelta。然后我们必须注册一个适配器： </p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  class  MyInterval( str):...  pass &gt;&gt; &gt; &gt;&gt;  &gt;  def  my_interval_in( my_interval_str):  # The parameter is of type str...  return  MyInterval( my_interval) &gt;&gt; &gt; &gt;&gt; &gt;  con. register_in_adapter( 1186,  my_interval_in) &gt;&gt; &gt;  con. run( &#34;SELECT  \&#39;2 years&#39;&#34;)[[ &#39;2 years&#39;]]</p><p>＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; Class MyInterval（str）：...通过和gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; def my_interval_in（my_interval_str）：＃参数是str的类型...返回myInterval（my_interval）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。 register_in_adapter（1186，my_interval_in）＆gt;＆gt; ＆gt;骗子。跑（＆＃34;选择\＆＃39; 2年＆＃39;＆＃34;）[[39; 2岁＆＃39;]]]</p><p> Note that registering the &#39;in&#39; adapter only afects the mapping from thePostgreSQL type to the Python type. See above for an example of how to changethe mapping from PostgreSQL to Python.</p><p> 请注意，注册＆＃39;在＆＃39;适配器仅从Python类型从博斯特格QL类型从映射上。有关如何从PostgreSQL转换为Python的示例，请参阅上面。</p><p> Sometimes you’ll get the &#39;could not determine data type of parameter&#39; errormessage from the server:</p><p> 有时你会得到＆＃39;无法确定参数的数据类型＆＃39;来自服务器的errormessage：</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  con. run( &#34;SELECT :v IS NULL&#34;,  v = None) Traceback ( most  recent  call  last): pg8000. exceptions. DatabaseError: { &#39;S&#39;:  &#39;ERROR&#39;,  &#39;V&#39;:  &#39;ERROR&#39;,  &#39;C&#39;:  &#39;42P18&#39;,  &#39;M&#39;:  &#39;could not determine data type of parameter $1&#39;,  &#39;F&#39;:  &#39;postgres.c&#39;,  &#39;L&#39;:  &#39;...&#39;,  &#39;R&#39;:  &#39;exec_parse_message&#39;}</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;骗子。运行（＆＃34;选择：v为null＆＃34;，v = none）回溯（最近呼叫最后一个呼叫）：pg8000。例外。 DatabaseError：{＆＃39; s＆＃39 ;:＆＃39;错误＆＃39;＆＃39; v＆＃39 ;:＆＃39;错误＆＃39 ;,＆＃39; c＆＃39 ;:＆＃39; c＆＃39 ;:＆＃39; c＆＃39 ;:＆＃39; 39; 42P18＆＃39 ;,＆＃39; m＆＃39 ;:＆＃39;无法确定参数1美元＆＃39 ;,＆＃39; f＆＃39 ;:＆＃39; postgres.c＆＃ 39 ;,＆＃39; l＆＃39 ;:＆＃39; ...＆＃39 ;,＆＃39; r＆＃39 ;:＆＃39; exec_parse_message＆＃39;}</p><p> Prepared statementscan be useful in improving performance when you have a statement that’sexecuted repeatedly. Here’s an example:</p><p> 准备好的报表可用于提高性能时，当您有一个反复声明时会提高性能。这是一个例子：</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  # Create the prepared statement &gt;&gt; &gt;  ps  =  con. prepare( &#34;SELECT cast(:v as varchar)&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  # Exceute the statement repeatedly &gt;&gt; &gt;  ps. run( v = &#34;speedy&#34;)[[ &#39;speedy&#39;]] &gt;&gt; &gt;  ps. run( v = &#34;rapid&#34;)[[ &#39;rapid&#39;]] &gt;&gt; &gt;  ps. run( v = &#34;swift&#34;)[[ &#39;swift&#39;]] &gt;&gt; &gt; &gt;&gt; &gt;  # Close the prepared statement, releasing resources on the server &gt;&gt; &gt;  ps. close()</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（＆＃34; postgres＆＃34;密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃创建准备好的声明＆gt;＆gt; ＆gt; ps = con。准备（＆＃34;选择cast（：v作为varchar）＆＃34;）＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃重复地兑换陈述＆gt;＆gt; ＆gt; PS。运行（v =＆＃34;速度＆＃34;）[[＆＃39;速度＆＃39;]]＆gt; ＆gt; PS。跑（v =＆＃34; rapt＆＃34; [＆＃39;＆＃39;]＆gt; ＆gt; PS。跑（v =＆＃34; swift＆＃34;）[[＆＃39; swift＆＃39;]]＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃关闭准备好的声明，释放服务器上的资源＆gt;＆gt; ＆gt; PS。关闭（）</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt;  import  getpass &gt;&gt; &gt; &gt;&gt; &gt;  # Connect to the database with current user name &gt;&gt; &gt;  username  =  getpass. getuser() &gt;&gt; &gt;  connection  =  pg8000. native. Connection( username,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  connection. run( &#34;SELECT &#39;pilau&#39;&#34;)[[ &#39;pilau&#39;]]</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt;进口乐谱＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃使用当前用户名和gt连接到数据库;＆gt; ＆gt;用户名= getpass。 getUser（）＆gt;＆gt; ＆gt;连接= PG8000。本国的。连接（用户名，密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;联系。跑（＆＃34;选择＆＃39; pilau＆＃39;＆＃34;）[[＆＃39; pilau＆＃39;]]] </p><p>  &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt;  from  os  import  environ &gt;&gt; &gt; &gt;&gt; &gt;  username  =  environ. get( &#39;PGUSER&#39;,  &#39;postgres&#39;) &gt;&gt; &gt;  password  =  environ. get( &#39;PGPASSWORD&#39;,  &#39;cpsnow&#39;) &gt;&gt; &gt;  host  =  environ. get( &#39;PGHOST&#39;,  &#39;localhost&#39;) &gt;&gt; &gt;  port  =  environ. get( &#39;PGPORT&#39;,  &#39;5432&#39;) &gt;&gt; &gt;  database  =  environ. get( &#39;PGDATABASE&#39;) &gt;&gt; &gt; &gt;&gt; &gt;  connection  =  pg8000. native. Connection(...  username,  password = password,  host = host,  port = port,  database = database) &gt;&gt; &gt; &gt;&gt; &gt;  connection. run( &#34;SELECT &#39;Mr Cairo&#39;&#34;)[[ &#39;Mr Cairo&#39;]]</p><p>＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt;来自OS进口环境和GT;＆GT; ＆gt; ＆gt;＆gt; ＆gt;用户名= Environ。得到（＆＃39; pguser＆＃39;＆＃39; postgres＆＃39;）＆gt;＆gt; ＆gt;密码=环境。得到（＆＃39; pgpassword＆＃39;＆＃39; cpsnow＆＃39;）＆gt;＆gt; ＆gt; Host = Environ。得到（＆＃39; pghost＆＃39;＆＃39; localhost＆＃39;）＆gt;＆gt; ＆gt;端口=环境。得到（＆＃39; pgport＆＃39 ;,＆＃39; 5432＆＃39;）＆gt;＆gt; ＆gt;数据库=环境。得到（＆＃39; pgdatabase＆＃39;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;连接= PG8000。本国的。连接（...用户名，password = password，host = host，port = port，database = database）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;联系。跑（＆＃34;选择＆＃39;开罗＆＃39先生;＆＃34;）[[＆＃39;开罗和＃39先生;]]</p><p> It might be asked, why doesn’t pg8000 have this behaviour built in? Thethinking follows the second aphorism of The Zen of Python:</p><p> 它可能被问到，为什么PG8000没有这种行为？思考遵循Python Zen的第二个憎恶：</p><p>  So we’ve taken the approach of only being able to set connection parametersusing the  pg8000.native.Connection() constructor.</p><p>  所以我们只采用了能够设置PG8000的连接参数的方法.Connection（）构造函数。</p><p> It may be that your PostgreSQL server is behind an SSL proxy server in whichcase you can set a pg8000-specific attribute ssl.SSLContext.request_ssl = False which tells pg8000 to connect using anSSL socket, but not to request SSL from the PostgreSQL server:</p><p> 可能是您的PostgreSQL服务器位于SSL代理服务器后面，可以在其中设置PG8000特定的属性SSL.SSLContext.Request_ssl = false，告诉pg8000使用anssl套接字连接，但不需要从PostgreSQL服务器请求SSL：</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( username,  password = &#34;cpsnow&#34;) &gt;&gt; &gt;  con. run( &#34;START TRANSACTION&#34;)[] &gt;&gt; &gt;  con. run( &#34;DECLARE c SCROLL CURSOR FOR SELECT * FROM generate_series(1, 100)&#34;)[] &gt;&gt; &gt;  con. run( &#34;FETCH FORWARD 5 FROM c&#34;)[[ 1], [ 2], [ 3], [ 4], [ 5]] &gt;&gt; &gt;  con. run( &#34;MOVE FORWARD 50 FROM c&#34;)[] &gt;&gt; &gt;  con. run( &#34;FETCH BACKWARD 10 FROM c&#34;)[[ 54], [ 53], [ 52], [ 51], [ 50], [ 49], [ 48], [ 47], [ 46], [ 45]] &gt;&gt; &gt;  con. run( &#34;CLOSE c&#34;)[] &gt;&gt; &gt;  con. run( &#34;ROLLBACK&#34;)[]</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（用户名，密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt;骗子。跑（＆＃34;开始交易＆＃34;）[]＆gt;＆gt; ＆gt;骗子。 run（＆＃34;声明c scrossolsor for select * from generate_series（1,100）＆＃34;）[]＆gt;＆gt; ＆gt;骗子。跑（＆＃34;从c＆＃34上获取5.）[[1]，[2]，[3]，[4]，[5]]＆gt; ＆gt;骗子。跑（＆＃34;从c＆＃34移动50;）[]＆gt;＆gt; ＆gt;骗子。运行（＆＃34; FETCH BACKWARD 10选自C＆＃34;）[[54]，[53]，[52]，[51]，[50]，[49]，[48]，[47]，[46 [45]]＆gt;＆gt; ＆gt;骗子。跑（＆＃34;关闭c＆＃34;）[]＆gt;＆gt; ＆gt;骗子。运行（＆＃34;回滚＆＃34;）[]</p><p> &gt;&gt; &gt;  import  pg8000. native &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. native. Connection( username,  password = &#34;cpsnow&#34;) &gt;&gt; &gt; &gt;&gt; &gt;  # Create a BLOB and get its oid &gt;&gt; &gt;  data  =  b&#39;hello&#39; &gt;&gt; &gt;  res  =  con. run( &#34;SELECT lo_from_bytea(0, :data)&#34;,  data = data) &gt;&gt; &gt;  oid  =  res[ 0][ 0] &gt;&gt; &gt; &gt;&gt; &gt;  # Create a table and store the oid of the BLOB &gt;&gt; &gt;  con. run( &#34;CREATE TEMPORARY TABLE image (raster oid)&#34;)[] &gt;&gt; &gt;  con. run( &#34;INSERT INTO image (raster) VALUES (:oid)&#34;,  oid = oid)[] &gt;&gt; &gt;  # Retrieve the data using the oid &gt;&gt; &gt;  con. run( &#34;SELECT lo_get(:oid)&#34;,  oid = oid)[[ b&#39;hello&#39;]] &gt;&gt; &gt; &gt;&gt; &gt;  # Add some data to the end of the BLOB &gt;&gt; &gt;  more_data  =  b&#39; all&#39; &gt;&gt; &gt;  offset  =  len( data) &gt;&gt; &gt;  con. run(...  &#34;SELECT lo_put(:oid, :offset, :data)&#34;,...  oid = oid,  offset = offset,  data = more_data)[[ &#39;&#39;]] &gt;&gt; &gt;  con. run( &#34;SELECT lo_get(:oid)&#34;,  oid = oid)[[ b&#39;hello all&#39;]] &gt;&gt; &gt; &gt;&gt; &gt;  # Download a part of the data &gt;&gt; &gt;  con. run( &#34;SELECT lo_get(:oid, 6, 3)&#34;,  oid = oid)[[ b&#39;all&#39;]]</p><p> ＆gt;＆gt; ＆gt;导入pg8000。天然＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。本国的。连接（用户名，密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃创建一个blob并获得其OID＆gt;＆gt; ＆gt;数据= B＆＃39;你好＆＃39; ＆gt;＆gt; ＆gt; res = con。运行（＆＃34;选择lo_from_bytea（0，：data）＆＃34;，data = data）＆gt;＆gt; ＆gt; oid = res [0] [0]＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃创建一个表并存储blob＆gt的oid;＆gt; ＆gt;骗子。运行（＆＃34;创建临时表图像（光栅OID）＆＃34;）[]＆gt;＆gt; ＆gt;骗子。运行（＆＃34;插入图像（栅格）值（：oid）＆＃34;，oid = oid）[]＆gt;＆gt; ＆gt; ＃使用OID＆gt检索数据。＆gt; ＆gt;骗子。运行（＆＃34;选择lo_get（：oid）＆＃34;，oid = oid）[[b＆＃39; hello＆＃39;]]＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃将一些数据添加到Blob＆gt的末尾;＆gt; ＆gt; more_data = B＆＃39;所有＆＃39; ＆gt;＆gt; ＆gt; offset = len（数据）＆gt;＆gt; ＆gt;骗子。运行（...＆＃34;选择lo_put（：oid，：offset，deam）＆＃34;，... oid = oid，offset = offset，data = more_data）[[＆＃39;＆＃39 ;]]]＆gt;＆gt; ＆gt;骗子。 run（＆＃34;选择lo_get（：oid）＆＃34;，oid = oid）[[b＆＃39;你好所有＆＃39;]＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; ＃下载数据的一部分＆gt;＆gt; ＆gt;骗子。运行（＆＃34;选择lo_get（：oid，6,3）＆＃34;，oid = oid）[[b＆＃39;全部＆＃39;]]]</p><p> Import pg8000, connect to the database, create a table, add some rows and thenquery the table:</p><p> 导入pg8000，连接数据库，创建一个表，添加一些行，然后添加一个表： </p><p> &gt;&gt; &gt;  import  pg8000. dbapi &gt;&gt; &gt; &gt;&gt; &gt;  conn  =  pg8000. dbapi. connect( user = &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt;  cursor  =  conn. cursor() &gt;&gt; &gt;  cursor. execute( &#34;CREATE TEMPORARY TABLE book (id SERIAL, title TEXT)&#34;) &gt;&gt; &gt;  cursor. execute(...  &#34;INSERT INTO book (title) VALUES (%s), (%s) RETURNING id, title&#34;,... ( &#34;Ender&#39;s Game&#34;,  &#34;Speaker for the Dead&#34;)) &gt;&gt; &gt;  results  =  cursor. fetchall() &gt;&gt; &gt;  for  row  in  results:...  id,  title  =  row...  print( &#34;id = %s, title = %s&#34;  % ( id,  title)) id  =  1,  title  =  Ender&#39; s  Game id  =  2,  title  =  Speaker  for  the  Dead &gt;&gt; &gt;  conn. commit()</p><p>＆gt;＆gt; ＆gt;导入pg8000。 dbapi＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; conn = pg8000。 dbapi。 Connect（User =＆＃34; Postgres＆＃34;，密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; Cursor = Conn。 Cursor（）＆gt;＆gt; ＆gt;光标。执行（＆＃34;创建临时表书（ID序列，标题文本）＆＃34;）＆gt;＆gt; ＆gt;光标。执行（...＆＃34;插入到书籍（标题）值（％s），（％s）返回id，title＆＃34;，...（＆＃34; enter＆＃39; s game＆＃34; ，＆＃34;死者的扬声器＆＃34;））> ＆gt;结果=光标。 fetchall（）＆gt;＆gt; ＆gt;在结果中为行：... ID，标题=行...打印（＆＃34; ID =％s，title =％s＆＃34;％（id，title））id = 1，标题= enter＆＃39 ; S游戏ID = 2，标题=死者的扬声器＆gt;＆gt; ＆gt;康涅狄格州。犯罪（）</p><p> &gt;&gt; &gt;  import  pg8000. dbapi &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. dbapi. connect( user = &#34;postgres&#34;,  password = &#34;cpsnow&#34;) &gt;&gt; &gt;  cursor  =  con. cursor() &gt;&gt; &gt; &gt;&gt; &gt;  cursor. execute( &#34;SELECT extract(millennium from now())&#34;) &gt;&gt; &gt;  cursor. fetchone()[ 3.0]</p><p> ＆gt;＆gt; ＆gt;导入pg8000。 dbapi＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。 dbapi。 Connect（User =＆＃34; Postgres＆＃34;，密码=＆＃34; cpsnow＆＃34;）＆gt;＆gt; ＆gt; Cursor = Con。 Cursor（）＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt;光标。执行（＆＃34;从现在（从现在（））＆＃34;）＆gt;＆gt; ＆gt;光标。 fetchone（）[3.0]</p><p> &gt;&gt; &gt;  import  datetime &gt;&gt; &gt;  import  pg8000. dbapi &gt;&gt; &gt; &gt;&gt; &gt;  con  =  pg8000. dbapi. connect( user = &#34;postgres&#34;,</p><p> ＆gt;＆gt; ＆gt;导入DateTime＆gt;＆gt; ＆gt;导入pg8000。 dbapi＆gt;＆gt; ＆gt; ＆gt;＆gt; ＆gt; con = pg8000。 dbapi。连接（用户=＆＃34; postgres＆＃34;</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/tlocke/pg8000">https://github.com/tlocke/pg8000</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pure/">#pure</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gt/">#gt</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>