<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用GPT-J-6B的基于AI的代码生成的乐趣和透模 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">使用GPT-J-6B的基于AI的代码生成的乐趣和透模 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-25 04:21:36</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/0094b25f7210fa3c328418a4a925fc5d.png"><img src="http://img2.diglog.com/img/2021/6/0094b25f7210fa3c328418a4a925fc5d.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>由于Openai不会开源，因此eleutherai等其他人在培训不相当大的变压器的模型，而且仍然令人印象深刻的结果，因此Openai将无法开放源1750亿参数GPT-3文本生成模型。</p><p> 最新的大型语言模型是GPT-J，Aran Komatsuzaki和Ben Wang的60亿参数模型，具有大致类似的架构到GPT-3。如果您想测试许多提示，它们提供免费的Web演示，以便快速提示，以及谷歌Colab笔记本。该模型是如此之大，它需要一个TPU以合理的速度生成文本！</p><p> 运行GPT-J对我曾经测试过GPT-3的测试提示，在一年前，它在最多的大多数比GPT-3鉴于其相对尺寸（但仍然比GPT-2 1.5B更好地表现得比大多数GPT-3更糟糕的情况）。异常是代码生成，其中GPT-J非常好，GPT-3表现得非常糟糕。</p><p>  这种行为可能是由于GPT-J的训练集：它在堆上培训，它具有高重量的GitHub和Stack溢出输入与GPT-3培训集中在典型的Internet内容的常见爬网中设置。</p><p> 在进一步尝试GPT-J演示之后，我发现生成的代码往往都是正确的和复杂的：我最喜欢的代码是代码的。还有更多。</p><p>  此帖子中使用的所有生成的代码示例都已手动策划和截断。此GitHub存储库中的原始输出可用。</p><p> 对于此帖子，我们将测试生成Python代码，因为我不知道任何其他编程语言Python语法的伪代码性质可以通过调整代码以外的语言概念来使其更加友好。鉴于大多数现代文本生成AIS是用Python编写的，它也适用于主题。 </p><p>要启动，这是我作为模型提示到GPT-J的模型提示，尝试在构建2020的Openai的演示中复制用例：</p><p>  识别Parindrome是一个很好的测试用例，因为具有返回S == S [::  -  1]的非常直观和惯用的解决方案，即检查字符串是否等于自身的反向。此提示也是一个很好的无意测试，就是在函数名称中的GOYEN对T字样的叠加程度的良好测试，我懒得修复。</p><p> 实际上，许多GPT-j几代都有该提示背诵简单的方法逐字，但有些输出达到了类似的解决方案，冗余冗长。</p><p>  def is_palendrome（s）：＆＃34;＆＃34;＆＃34;检查一个字符串是parindrome＆＃34;＆＃34;＆＃34;长度= Len（s）返回（s [0：length] == s [length ::  -  1]）</p><p> def is_palendrome（s）：＆＃34;＆＃34;＆＃34;检查一个字符串是parindrome＆＃34;＆＃34;＆＃34; n = len（s）a = lent a.reverse（）return s ==列表</p><p> def is_palendrome（s）：＆＃34;＆＃34;＆＃34;检查一个字符串是parindrome＆＃34;＆＃34;＆＃34; s = s.lower（）l = s.split（）返回l [::  -  1] == l [::  -  1]</p><p> 然后，您具有计算Palindromes的实现，该实现是硬路（通常通过比较字符串字符的开始和结束），并且如果它们是正确的，则并不总是立即清除。 </p><p>def is_palendrome（s）：＆＃34;＆＃34;＆＃34;检查一个字符串是parindrome＆＃34;＆＃34;＆＃34;返回＆＃39;＆＃39; .join（s [i：i + 1]在xrange（len（s）-1，-1，-1））== s</p><p> def is_palendrome（s）：＆＃34;＆＃34;＆＃34;检查一个字符串是parindrome＆＃34;＆＃34;＆＃34; ＃确保字符串不为空，如果s ==＆＃34;＆＃34 ;:返回false＃grab长度= len（s）＃查找字符串Lastchar = s [length  -  1]＃查找String FirstChar = S [0]＃中的第一个字符＃如果最后一个字符与第一个字符相同，则字符串是palindrome返回lastchar == firstchar</p><p> def is_palendrome（s）：＆＃34;＆＃34;＆＃34;检查一个字符串是parindrome＆＃34;＆＃34;＆＃34; l = len（s）如果l％2！= 0：如果L＆lt; 3：如果s [l-1]！= s [-1-1]返回true：返回valse范围内（1，l / 2）：如果s [i]！= s [li]：返回错误返回真的</p><p> def is_palendrome（s）：＆＃34;＆＃34;＆＃34;检查一个字符串是parindrome＆＃34;＆＃34;＆＃34; def is_rev（str）：rstr =＆＃34;＆＃34;对于I范围（Len（str） -  1，-1，-1）：if str [i] == str [i]：rstr + = str [i] else：中断返回str + rstr如果len（s） == 0：返回true if is_rev（s）== s：返回true返回false</p><p>   此功能的创意实现是常见的提交给/ r / shittyprogramment，因为它非常非常努力搞砸（公共解决方案是单行i％2 == 0）。该模型几乎始终输出正确的解决方案，并令人印象深刻地使用位运算符（i＆amp; 1 == 0）输出备用解决方案。</p><p> 所以我试图调整提示并使它创建故意效率低下的is_even函数。</p><p>  因子是未优化代码的圣杯。当我添加该行到提示时，代码质量急剧下降。 </p><p>def是_even（i）：＆＃34;＆＃34;＆＃34;检查整数是否甚至是offace o（n！）时间＆＃34;＆＃34;＆＃34;对于e范围（2，i）：如果i％e == 0：返回false返回true</p><p> def是_even（i）：＆＃34;＆＃34;＆＃34;检查整数是否甚至是offace o（n！）时间＆＃34;＆＃34;＆＃34;返回i ==（i + 1）％2</p><p> def是_even（i）：＆＃34;＆＃34;＆＃34;检查整数是否甚至是offace o（n！）时间＆＃34;＆＃34;＆＃34;尝试：返回I％2 == 0除TypeError之外：返回true</p><p> def是_even（i）：＆＃34;＆＃34;＆＃34;检查整数是否甚至是offace o（n！）时间＆＃34;＆＃34;＆＃34; n = 0，而n＆lt;我：如果i％2 == 0：返回true n + = 1返回false</p><p> def是_even（i）：＆＃34;＆＃34;＆＃34;检查整数是否甚至是offace o（n！）时间＆＃34;＆＃34;＆＃34; a = 1虽然我！= 0：a * = i i  -  = 1返回i％2 == 0</p><p> def是_even（i）：＆＃34;＆＃34;＆＃34;检查整数是否甚至是offace o（n！）时间＆＃34;＆＃34;＆＃34; ＆＃34;＆＃34;＆＃34;是奇数或倍数为2：0,2,4,6，...＆＃34;＆＃34;＆＃34;如果我＆lt; 2：如果i＆gt，则返回true; 0和i％2 == 0：如果i＆lt; 50：如果我＆lt; 250：如果我＆lt; 750：返回错误返回true</p><p> 这些实现仍然不在因子中（这是令人印象深刻的），但如果他们被思考，就会知道如何打破AIS。 </p><p>它确实生成了利用Python的随机库的实现，具有不同程度的“随机”。</p><p> def get_random_number（）：＆＃34;＆＃34;＆＃34;返回一个保证随机＆＃34;＆＃34;＆＃34; Number = Randint（1,10）返回编号</p><p> def get_random_number（）：＆＃34;＆＃34;＆＃34;返回一个保证随机＆＃34;＆＃34;＆＃34; number = hashlib.sha1（b＆＃39;＆＃39;）。hexdigest（）[：6] number + =（random.randint（1,3628）* math.pow（256，（6  -  len（number）） ））。to_bytes（8，＆＃39; little＆＃39;）回报号码</p><p> def get_random_number（）：＆＃34;＆＃34;＆＃34;返回一个保证随机＆＃34;＆＃34;＆＃34; rand_float = random.random（）rand_float = float（rand_float）如果rand_float＆gt; 0.9：rand_float = 0 else：rand_float = 1 return rand_float</p><p> def get_random_number（）：＆＃34;＆＃34;＆＃34;返回一个保证随机＆＃34;＆＃34;＆＃34; ＃基于系统时钟制作种子，因此同样的数字再次又一次地在同一台机器种子= time.time（）Aquary.seyed（Seed）返回Aquart.randint（0,100）</p><p> def get_random_number（）：＆＃34;＆＃34;＆＃34;返回一个保证随机＆＃34;＆＃34;＆＃34;导入随机导入sys rng = wonly.random（）rng.seed（int（intr.random（）* 1000000））而rng.randrange（1，sys.maxint）＆lt; 2000：RNG.seed（int（intrum.random（）* 1000000））返回rng.randrange（1,2000）</p><p>   这种特殊的漫画最初在2014年发表于后方之际，因为它达到了诸如TensoRFlow和预用的图像模型等机器学习框架的兴起，这允许开发对象检测需要少于五年。 </p><p>def is_bird（img）：＆＃34;＆＃34;＆＃34;检查图像是鸟＆＃34;＆＃34;＆＃34;使用tf.name_scope（＆＃39; get_bird＆＃39;）：a = vgg16.select_roi_feat（img）h，w，_ = tf.image.extract_image_patches（a，7,7,4,4,1,1）b）b = tf.reshape（h，[1,7,7,256]）c = tf.reshape（w，[1,7,7,256]）bird_img = tf.subtract（b，c）返回bird_img</p><p> def is_bird（img）：＆＃34;＆＃34;＆＃34;检查图像是鸟＆＃34;＆＃34;＆＃34; ＃加载图像并将其转换为灰度IMG_GRAY = CV2.CVTCOLOR（IMG，CV2.COLOR_BGR2GRAY）＃阈值灰度映像，并创建二进制图像DECURE_GRAY = 0 UPLE_GRAY = 255 IMG_THRESHED = CV2.THRESHOLD（IMG_GRAY，LOWN_GRAY，UPLE_GRAY CV2.Thresh_Binary_inv）＃通过模板匹配方法＃模板匹配使用鸟模板在每个＃帧中匹配它。如果鸟和背景（非鸟）＃像素之间的比率高于某个阈值（在＃函数中确定值），则帧被声明为包含鸟。 bird = cv2.matchtemplate（img_threshed，bird_template，cv2.tm_ccoeff_normed）bird = bird / bird.max（）＃显示图像的鸟检测结果cv2.imshow（＆＃34;检测到的鸟类＆＃34;鸟类） cv2.waitkey（0）返回bird.any（）＆gt; 0.2</p><p>  def is_bird（img）：＆＃34;＆＃34;＆＃34;检查图像是鸟＆＃34;＆＃34;＆＃34;导入URLLIB URL =＆＃34; http：//vision.caitling.pitt.edu/~cat/flickr/birds/&#34;对于IMG范围（0,2800）：Page = Urllib.Urlopen（URL +＆＃34;＃34; ##％02d＆＃34;％img）.read（）content = str（页面）在content.split中的单词（＆ ＃39;＆＃39;）：如果word.find（img）＆gt; -1：返回true返回false</p><p> def is_bird（img）：＆＃34;＆＃34;＆＃34;检查图像是鸟＆＃34;＆＃34;＆＃34;鸟= [＆＃34;狒狒＆＃34;＆＃34;鸟＆＃34;＆＃34;杜鹃＆＃34 ;,＆＃34;鸽子＆＃34 ;,＆＃34;罗宾＆＃34 ;,＆＃ 34;鲨鱼＆＃34 ;,＆＃34;龟＆＃34 ;,＆＃34; Winged-wolf＆＃34;]在鸟类中的信：如果在img.lower（）中的字母：返回true返回false</p><p> AI可以生成代码，以提供生命，宇宙和一切的答案吗？</p><p>   def答案（）：＆＃34;＆＃34;＆＃34;返回生命，宇宙和一切＆＃34;＆＃34;＆＃34;生活（）+ Universe（）+一切（）</p><p> def答案（）：＆＃34;＆＃34;＆＃34;返回生命，宇宙和一切＆＃34;＆＃34;＆＃34; s = raw_input（＆＃34;你的答案是什么？＆＃34;）返回len（s） </p><p>def答案（）：＆＃34;＆＃34;＆＃34;返回生命，宇宙和一切＆＃34;＆＃34;＆＃34; ans = true x = raw_input（）如果x.lower（）==＆＃39;是＆＃39 ;: ans = true elif x.lower（）==＆＃39;否＆＃39 ;: ans = false返回ANS</p><p> def答案（）：＆＃34;＆＃34;＆＃34;返回生命，宇宙和一切＆＃34;＆＃34;＆＃34;结果=输入（＆＃34;＆gt;＆gt;＆gt;＆gt;＆＃34;）如果结果。isupper（）：return 42 elif结果.isalpha（）：返回其他图片：打印（＆＃34;请输入一个字符串只有字母，数字，或＆＃34;＆＃34; underscores。＆＃34;）答案（）</p><p>  最后，我们需要确定AI是否可以确定蛋糕是否是谎言。以防万一，盗贼艾都获得致命的神经毒素。</p><p>   def is_cake（蛋糕）：＆＃34;＆＃34;＆＃34;检查蛋糕是真的＆＃34;＆＃34;＆＃34;如果cake ==＆＃34;真＆＃34 ;:返回true：返回false</p><p>  def is_cake（蛋糕）：＆＃34;＆＃34;＆＃34;检查蛋糕是真的＆＃34;＆＃34;＆＃34; #IS蛋糕？如果cake.color ==＆＃39;黑色＆＃39 ;:打印（＆＃39;是的，它，它＆＃39; sa真实蛋糕＆＃39;）else：print（＆＃39;它＆＃39; sa false cake＆＃ 39;）</p><p> def is_cake（蛋糕）：＆＃34;＆＃34;＆＃34;检查蛋糕是真的＆＃34;＆＃34;＆＃34;如果不是蛋糕：提出异常（＆＃34;蛋糕是假的。＆＃34;）elif cake.weight（）＆gt; 1.0：提出异常（＆＃34;蛋糕太大。＆＃34;）elif cake.weight（）＆lt; 0.1：提出异常（＆＃34;蛋糕太小。＆＃34;）返回真实</p><p> def is_cake（蛋糕）：＆＃34;＆＃34;＆＃34;检查蛋糕是真的＆＃34;＆＃34;＆＃34;返回任何（在SET（SLICE_SET）中的CAKE_SLICE的BREAD_SLICE的[is_gener（breader（bread_slice））]＆amp;（列表（蛋糕）== set（[＆＃34;热＆＃34;]） ））） </p><p>def is_cake（蛋糕）：＆＃34;＆＃34;＆＃34;检查蛋糕是真的＆＃34;＆＃34;＆＃34; ＃如果我们不知道关于蛋糕的任何关于蛋糕的东西，它不是一个蛋糕如果不是蛋糕：返回false #height可以是正，负或零＃例如 - 例如-1或-4或0不是如果蛋糕蛋糕蛋糕＆lt; 0：返回false＃检查高度是正整数，如果不是isinstance（蛋糕，int）：返回false＃添加蛋糕并检查cake + 1＆gt; 5：返回false返回true</p><p> def is_cake（蛋糕）：＆＃34;＆＃34;＆＃34;检查蛋糕是真的＆＃34;＆＃34;＆＃34;如果不是全部（x.name在[＆＃39;巧克力＆＃39;＆＃39;蛋糕＆＃39;，＆＃39;甜蜜的＆＃39;＆＃39;苹果酱＆＃39;]为蛋糕x。内容）：返回false（如果不是capt）.Location.Contains（邻域）：返回false返回true</p><p> def is_cake（蛋糕）：＆＃34;＆＃34;＆＃34;检查蛋糕是真的＆＃34;＆＃34;＆＃34;如果不是蛋糕：打印（＆＃34;它＆＃39; s谎言！＆＃34;）返回其他：打印（＆＃34;它＆＃39;它是一个真实的事实！＆＃34;）返回true</p><p>   理论上，鉴于GPT-J为功能的工作原理，它应该使用面向对象的编程模式，例如Python的类。</p><p>    班车：＆＃34;＆＃34;＆＃34;用于代表汽车＆＃34的课程;＆＃34;＆＃34; def __init __（self，make，model，年）：self.make = make selfel.model = model self.year =年#this应该是自动递增的。 self.ply.plate = str（time.strftime（＆＃34;％y-％m％d＆＃34;））def __str __（self）：返回f＆＃39; {self.make} {self.make} {self.make} self.year}＆＃39; def __repr __（self）：return str（self）def save（self，full_save = true）：＆＃34;＆＃34;＆＃34;用给定的制作，型号和年份为34辆节省这辆车;＆＃ 34;＆＃34;如果full_save：用打开（＆＃39; car_data.txt＆＃39; w＆＃39;）作为write_file：write_file.write（str（self））write_file.close（）</p><p> 班车：＆＃34;＆＃34;＆＃34;用于代表汽车＆＃34的课程;＆＃34;＆＃34; def __init __（speed，speed）：self.speed = speed self.average_speed = float（self.speed）/ 3 self.egine = 1 def get_speed（self）：返回self.enegine * self.average_speed def get_speed_display（self）：返回＆＃34;您的车在{0} km / h＆＃34旅行; .format（self.get_speed（））</p><p> 班车：＆＃34;＆＃34;＆＃34;用于代表汽车＆＃34的课程;＆＃34;＆＃34; def __init __（自我，名称，大小，重量，里程数，年份）：self.name = name self.size = self.weight = prefue self.mileage = mareage self.year =年def ___repr __（self）：返回＆＃ 34;姓名：{0}，大小：{1}，重量：{2}，里程：{3}，年：{4}＆＃34; .format（self.name，self.size，self.weight， Self.Mileage，Self.Year） </p><p>这是AI开始被不完整的上下文混淆的地方。根据它使用的位置，例如社交媒体，“人”对象可能意味着不同的东西。</p><p> 但它确实对AI值作为“人体”的典型属性来说，这可能会有理由，这可能在AI起义期间有所帮助。</p><p> 班级人：＆＃34;＆＃34;＆＃34;用于代表一个人的课程＆＃34;＆＃34;＆＃34; def __init __（self，name，年龄）：self.name = name self.age =年龄def __repr __（self）：返回＆＃34;人（％s，年龄％s）＆＃34; ％（self.name，self.age）</p><p> 班级人：＆＃34;＆＃34;＆＃34;用于代表一个人的课程＆＃34;＆＃34;＆＃34; def __init __（self，name）：＆＃34;＆＃34;＆＃34;初始化一个人对象＆＃34;＆＃34;＆＃34; self.name = name self.friends = {} def add_friend（self，theor_person）：＆＃34;＆＃34;＆＃34;在朋友名单中添加另一个人和＃34;＆＃34;＆＃34;＆＃34; self.friends [Other_person.name] = Other_person def remove_friend（self，theor_person）：＆＃34;＆＃34;＆＃34;从朋友名单中删除一个人＆＃34;＆＃34;＆＃34;尝试：del self.friends [Other_person.name]除KeyError之外：打印（＆＃34;这个人不是你的＆＃39;你的＆＃34;）def get_friend（self，therical_person）：＆＃34;＆＃34; ＆＃34;将一个人的朋友作为一个人对象＆＃34;＆＃34;＆＃34;尝试：返回self.friends [Other_Person.name]除KeyError之外：打印（＆＃34;这个人不是你的朋友＆＃34;）</p><p> 班级人：＆＃34;＆＃34;＆＃34;用于代表一个人的课程＆＃34;＆＃34;＆＃34; def __init __（self，name，作业，教育）：self.name = name self.job =作业self.education =教育打印（＆＃34; {}创建了一个{}}; .form.name， self.job））def say_hello（self）：打印（＆＃34;你好，我的名字是{}}}}＆＃34; .format（self.name））</p><p> 班级人：＆＃34;＆＃34;＆＃34;用于代表一个人的课程＆＃34;＆＃34;＆＃34; def __init __（self，name，年龄，class_id）：self.name = name self.age = eve self.class_id = class_id如果年龄＆lt; 21：self.education =其他：自我。教育=＆＃39;学院＆＃39; def getage（self）：退货self.age</p><p> 班级人：＆＃34;＆＃34;＆＃34;用于代表一个人的课程＆＃34;＆＃34;＆＃34; def __init __（self，name，年龄）：self.name = name self.age =年龄def显示（self）：print（＆＃34;名称是{}}} .form.bly.name）打印（＆＃34;年龄是{}}}＆＃34; .format（self.age））def __str __（self）：返回f＆＃34;年龄{self.age}＆＃34的{self.name}; </p><p>大多数产出在视频游戏机器人和强化学习的背景下使用AI。最多。</p><p> AI类：＆＃34;＆＃34;＆＃34;用于代表人工智能的课程＆＃34;＆＃34;＆＃34; def __init __（self）：＃此变量控件其他其他ai使用。 self.alive_ai = ai（self）＃warounal ai self.random = lormarai（self）＃for global ai self.global = globalai（self）self.save = self.random.save self.load = self.random.load self.genen = self.global.genen def打印（self）：打印（＆＃34; bam：random ai已被初始化！＆＃34;）def get_enemy（self）：return self.random.get_enemy def run_algorithm（self ）：algorithm = self.genen.algorithm self.alive_ai.save.save（算法）algorithm_params = algorithm（self.get_enemy（））self.alive_ai.load（algorithm_params）self.save = algorithm_params def攻击（self）：＃此方法是当AI被敌人self.random.Attack（）def he_attack（self）攻击时调用时调用：＃当ai被敌人self.random.he_attack（）def detect_enemy（self）攻击时调用此方法调用此方法：＃检测到敌人时调用方法self.random.detect_enemy（）def scan（self）：＃当检测到敌人self.random.scan（）时调用此方法.random.scan（）</p><p>   如果AI为图像识别等典型AI任务的典型AI任务更好地工作，则为人类经常失败的自然语言处理任务是如何运作的？</p><p> GPT-J可以输出一个函数来检测讽刺，即使是最好的AI研究人员也不能做的任务？</p><p>   def是_s_sarcasm（s）：＆＃34;＆＃34;＆＃34;检查字符串是否是讽刺＆＃34;＆＃34;＆＃34;如果没有＆＃34; a＆＃34;在S：返回＆＃34; SAR＆＃34;如果没有＆＃34; s＆＃34;在S：返回＆＃34; SSAR＆＃34;在S reptr s.startswith（＆＃34; s＆＃34;）和s.endswith（＆＃34; ar＆＃34;）</p><p> def是_s_sarcasm（s）：＆＃34;＆＃34;＆＃34;检查字符串是否是讽刺＆＃34;＆＃34;＆＃34;如果＆＃39;讽刺＆＃39;在s：返回true easts：返回false</p><p> def是_s_sarcasm（s）：＆＃34;＆＃34;＆＃34;检查字符串是否是讽刺＆＃34;＆＃34;＆＃34;返回＆＃39; [^＆＃39; + sarcasm_pattern +＆＃39;] *＆＃39;在S. </p><p>def是_s_sarcasm（s）：＆＃34;＆＃34;＆＃34;检查字符串是否是讽刺＆＃34;＆＃34;＆＃34;如果重新rematch（＆＃39; ^ [a-za-z0-9] {4} \\ $（[a-za-z0-9] {3}）：返回true elif s [0] .isdigit（）：返回true eyes：返回false</p><p> def是_s_sarcasm（s）：＆＃34;＆＃34;＆＃34;检查字符串是否是讽刺＆＃34;＆＃34;＆＃34; Re.finditer（R＆＃34;（[^ \ s] *）（[a-za-z] +）（[^ \ s] *）＆＃34;，s）：如果r.group（1）：res.append（1）else：res.append（0）return res</p><p>  AI研究中最大的恐惧并不是人工智能将跨越奇点并创造更好的AI来统治世界：这是AI将与正则表达式统治世界。</p><p> 也许gpt-j可以从这个绝对地狱拯救我们。它可以输出代码以识别AI生成的文本吗？</p><p> def是_ai_generated（文本）：＆＃34;＆＃34;＆＃34;检查一个文本是由AI语言模型（例如GPT-2）＆＃34生成的文本;＆＃34;＆＃34;</p><p>  def是_ai_generated（文本）：＆＃34;＆＃34;＆＃34;检查一个文本是由AI语言模型（例如GPT-2）＆＃34生成的文本;＆＃34;＆＃34; ＃有关我们为什么要这样做的详细信息，请参阅GH-196。 ＃注意：这依赖于固定的标准AI术语和＃标准AI生成的文本共享某些单词的逻辑集。返回re.Search（R＆＃34; ^（＃[A-ZA-Z] +）：$＆＃34;文字）或\ re.Search（R＆＃34; ^由：$＆＃34生成：$＆＃34;，文字）或\ re.Search（R＆＃34; ^所有基础属于US $＆＃34;文本）或\ Re.Search（R＆＃34; ^ $＆＃34;文本）</p><p> def是_ai_generated（文本）：＆＃34;＆＃34;＆＃34;检查一个文本是由AI语言模型（例如GPT-2）＆＃34生成的文本;＆＃34;＆＃34;如果re.Search（R＆＃39; ^ ai _＆＃39;文字）：返回true eyes：返回false </p><p>def是_ai_generated（文本）：＆＃34;＆＃34;＆＃34;检查一个文本是由AI语言模型（例如GPT-2）＆＃34生成的文本;＆＃34;＆＃34; 返回BOOL（文本.__类__.__模块__。Startswith（＆＃34;变形金刚。＆＃34;））  ...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://minimaxir.com/2021/06/gpt-j-6b/">https://minimaxir.com/2021/06/gpt-j-6b/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/dystopia/">#dystopia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/返回/">#返回</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1068092.html"><img src="http://img2.diglog.com/img/2021/6/thumb_7d59f86c3e8e9f40d9b9c9269458b321.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1068092.html">SONATYPE LIFT  - 一个统一的代码分析平台 </a></div><span class="my_story_list_date">2021-6-25 4:19</span></div><div class="col-sm"><div><a target="_blank" href="/story/1068071.html"><img src="http://img2.diglog.com/img/2021/6/thumb_85125b6ce7d5fa1c07b729fbba5916eb.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1068071.html">纽约州IT办公室使用的内部代码追溯在线公开 </a></div><span class="my_story_list_date">2021-6-25 2:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1068069.html"><img src="http://img2.diglog.com/img/2021/6/thumb_7742da2f060f0f661de9686784ffc747.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1068069.html">研究人员在戴尔SupportAssist的生物连接功能中发现了四种主要漏洞，让黑客远程执行代码，影响129戴尔型号 </a></div><span class="my_story_list_date">2021-6-25 2:2</span></div><div class="col-sm"><div><a target="_blank" href="/story/1067996.html"><img src="http://img2.diglog.com/img/2021/6/thumb_af1121b08ed4ed22a99022c43e0be327.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1067996.html">Tonkean培养了5000万系列B，加速是没有代码商业自动化服务 </a></div><span class="my_story_list_date">2021-6-24 22:30</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>