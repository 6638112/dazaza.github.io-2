<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>将鞭炮移植到覆盆子派4</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">将鞭炮移植到覆盆子派4</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-24 20:47:15</div><div class="page_narrow text-break page_content"><p>Since we got our hands on the new Raspberry Pi 4, we started exploring howvarious virtualization technologies behave on the board. First thing we tried is how to run  Nabla on it and how it compares to native KVM.</p><p>自从我们拿到了新的Raspberry PI 4之后，我们就开始探索各种虚拟化技术在黑板上是如何运行的。我们首先尝试的是如何在其上运行Nabla，以及它与本机KVM的比较。</p><p> Next thing we wanted to try is  firecracker, the notorious micro-VMM thatAmazon Lambda &amp; Fargate run on. To our disappointment, firecracker was not yet running on RPi4. So we started looking into coding in the necessarychanges :)</p><p>接下来我们想尝试的是“爆竹”，亚马逊Lambda&amp；Fargate在其上运行的臭名昭著的微型VMM。令我们失望的是，“爆竹”还没有在RPi4上运行。因此，我们开始研究必要的更改中的编码：)。</p><p> After a bit of investigation, we figured out that the key missing piece issupport for the GICv2 ARM interrupt controller. In fact, firecracker onlysupports GIC version 3 since it was open-sourced, but not version 2, which isthe version appearing in the Raspberry Pi series, as well as in other popularboards, like the Hikey 970 we got our hands on, or Khadas VIM3. A bit moredigging into the internals of firecracker and the Linux kernel, helped uswork out the details and open a  pull-request which adds support for themissing parts.</p><p>经过一些调查，我们发现缺少的关键部分是对GICv2 ARM中断控制器的支持。事实上，鞭炮只支持GIC版本3，因为它是开源的，但不支持版本2，这是出现在Raspberry Pi系列中的版本，以及其他流行的板子，比如我们拿到的Hikey 970，或者Khadas VIM3。更深入地研究了鞭炮和Linux内核的内部结构，帮助我们解决了细节问题，并打开了一个Pull-Request，它增加了对这些部分的支持。</p><p>  The Generic Interrupt Controller (GIC) is the IP block in the ARM processorsthat implements interrupt handling. The Linux kernel supports user- andkernel-space emulation for GICv2 as well as GICv3 and v4. However, Firecrackeronly handles the GICv3-related configuration of the virtual GIC (VGIC).Similarly, setting up the FDT for the guest microVM from Firecracker onlyhandles GIC-v3 devices.</p><p>通用中断控制器(GIC)是ARM处理器中实现中断处理的IP块。Linux内核支持GICv2、GICv3和v4的用户和内核空间仿真。但是，Firecracker仅处理虚拟GIC(VGIC)的与GICv3相关的配置。类似地，从Firecracker为来宾微VM设置FDT仅处理GIC-v3设备。</p><p> In terms of code organization, the GIC related code currently exposes a functionfor setting up GICv3 performing the corresponding  ioctl KVM commands. Thefirst part of our PR changes this by introducing a GIC Trait which defines thecommon interface for all GIC implementations. Even though it is still underdiscussion, what exactly will be in the Trait in its final form, it will besomething along the following lines:</p><p>在代码组织方面，GIC相关代码目前公开了用于设置GICv3执行相应的ioctl KVM命令的功能。我们公关的第一部分通过引入GIC特性来改变这一点，该特性定义了所有GIC实现的通用接口。尽管它还在讨论中，但它的最终形式到底会是什么，它将围绕以下几个方面进行讨论：</p><p> /// Trait for GIC devices.  pub   trait  GICDevice  {    /// Returns the GIC version of the device    fn  version( &amp; self)  -&gt;  u32;     /// Returns the file descriptor of the GIC device    fn  device_fd( &amp; self)  -&gt;  &amp; DeviceFd;     /// Returns an array with GIC device properties    fn  device_properties( &amp; self)  -&gt;  &amp;[ u64];  }</p><p>/GIC设备的特征。Pub特征GICDevice{/返回设备FN版本(&amp；self)的GIC版本-&gt；u32；/返回GIC设备fn device_fd(&amp；self)-&gt；&amp；DeviceFd；/返回具有GIC设备属性的数组fn device_properties(&amp；self)-&gt；&amp；[U64]；}。</p><p> With this in place, we can define objects per GIC version, which implement thisTrait, and still have the rest of the code deal with the  GICDevice Trait,which is transparent to the GIC version.</p><p>有了这些，我们就可以为实现thisTrait的每个GIC版本定义对象，并且仍然让其余的代码处理GICDevice特性，这对GIC版本是透明的。</p><p> The implementations for each version, implement the Trait and a  new functionwhich is used to create the new object:</p><p>每个版本的实现都实现了特征和用于创建新对象的新函数：</p><p>  The differentiation between the two versions lays in the VGIC registerattributes that each device exposes. As a result, the work we need to do is essentially to  mmap their addresses.</p><p>这两个版本之间的区别在于每个设备公开的VGIC寄存器属性。因此，我们需要做的工作实质上是映射它们的地址。</p><p>  /* Setting up the distributor attribute.  We are placing the GIC below 1GB so we need to substract the size of the distributor. */  set_device_attribute(    &amp;vgic_fd,   kvm_bindings::KVM_DEV_ARM_VGIC_GRP_ADDR,    u64::from(kvm_bindings::KVM_VGIC_V2_ADDR_TYPE_DIST),    &amp;get_dist_addr()   as   * const   u64   as   u64,    0,  ) ?;    /* Setting up the CPU attribute.  */  set_device_attribute(    &amp;vgic_fd,   kvm_bindings::KVM_DEV_ARM_VGIC_GRP_ADDR,    u64::from(kvm_bindings::KVM_VGIC_V2_ADDR_TYPE_CPU),    &amp;get_cpu_addr()   as   * const   u64   as   u64,    0,  ) ?;</p><p>/*设置分发服务器属性。我们将GIC放在1 GB以下，因此需要减去分配器的大小。*/SET_DEVICE_ATTRIBUTE(&amp；VITIC_FD，KVM_BINDINGS：：KVM_DEV_ARM_VGIC_GRP_ADDR，u64：：from(kvm_bindings：：KVM_VGIC_V2_ADDR_TYPE_DIST)，&amp；GET_DIST_ADDR()as*const U64 as U64，0，)？；/*设置cpu属性。*/SET_DEVICE_ATTRIBUTE(&amp；VIGIC_FD，KVM_BINDINGS：：KVM_DEV_ARM_VGIC_GRP_ADDR，u64：：from(kvm_bindings：：KVM_VGIC_V2_ADDR_TYPE_CPU)，&amp；GET_CPUADR()AS*Const U64 AS U64，0，)？；</p><p>  /* Setting up the distributor attribute.  We are placing the GIC below 1GB so we need to substract the size of the distributor. */  set_device_attribute(    &amp;vgic_fd,   kvm_bindings::KVM_DEV_ARM_VGIC_GRP_ADDR,    u64::from(kvm_bindings::KVM_VGIC_V3_ADDR_TYPE_DIST),    &amp;get_dist_addr()   as   * const   u64   as   u64,    0,  ) ?;    /* Setting up the redistributors&#39; attribute. We are calculating here the start of the redistributors address. We have one per CPU. */  set_device_attribute(    &amp;vgic_fd,   kvm_bindings::KVM_DEV_ARM_VGIC_GRP_ADDR,    u64::from(kvm_bindings::KVM_VGIC_V3_ADDR_TYPE_REDIST),    &amp;get_redists_addr( u64::from(vcpu_count))   as   * const   u64   as   u64,    0,  ) ?;</p><p>/*设置分发服务器属性。我们将GIC放在1 GB以下，因此需要减去分配器的大小。*/SET_DEVICE_ATTRIBUTE(&amp；VITIC_FD，KVM_BINDINGS：：KVM_DEV_ARM_VGIC_GRP_ADDR，u64：：from(kvm_bindings：：KVM_VGIC_V3_ADDR_TYPE_DIST)，&amp；GET_DIST_ADDR()as*const U64 as U64，0，)？；/*设置再分发者属性。我们在这里计算分销商地址的起点。我们的每个CPU都有一个。*/SET_DEVICE_ATTRIBUTE(&amp；VIGIC_FD，KVM_BINDINGS：：KVM_DEV_ARM_VGIC_GRP_ADDR，u64：：from(kvm_bindings：：KVM_VGIC_V3_ADDR_TYPE_REDIST)，&amp；GET_REDISTS_ADR(U64：：FROM(VCPU_COUNT))As*Const U64 as U64，0，)？？</p><p> Finally, for both versions of GIC we finalize the device initialization bysetting the number of supported interrupts and the  control_init group.</p><p>最后，对于两个版本的GIC，我们通过设置支持的中断数和CONTROL_INIT组来完成设备初始化。</p><p> /// Finalize the setup of a GIC device  pub   fn  finalize_device(fd:  &amp; DeviceFd)  -&gt;  Result &lt;() &gt;  {    /* We need to tell the kernel how many irqs to support with this vgic.  * See the `layout` module for details.  */    let  nr_irqs:  u32  =   super::layout::IRQ_MAX   -   super::layout::IRQ_BASE   +   1;    let  nr_irqs_ptr   =   &amp;nr_irqs   as   * const   u32;   set_device_attribute(   fd,   kvm_bindings::KVM_DEV_ARM_VGIC_GRP_NR_IRQS,    0,   nr_irqs_ptr   as   u64,    0,   ) ?;     /* Finalize the GIC.  * See https://code.woboq.org/linux/linux/virt/kvm/arm/vgic/vgic-kvm-device.c.html#211.  */   set_device_attribute(   fd,   kvm_bindings::KVM_DEV_ARM_VGIC_GRP_CTRL,    u64::from(kvm_bindings::KVM_DEV_ARM_VGIC_CTRL_INIT),    0,    0,   ) ?;     Ok(())  }</p><p>/完成GIC设备pub fn finalize_device(fd：&amp；DeviceFd)-&gt；result&lt；()&gt；{/*我们需要告诉内核此VIC支持多少IRQ。*详见`layout`模块。*/let nr_irqs：u32=SUPER：：Layout：：IRQ_MAX-SUPER：：Layout：：IRQ_BASE+1；让nr_irqs_ptr=&amp；nr_irqs as*const u32；set_device_attribute(FD，KVM_BINDINGS：：KVM_DEV_ARM_VGIC_GRP_NR_IRQS，0，nr_irqs_ptr as U64，0，？)；/*完成GIC。*请参阅https://code.woboq.org/linux/linux/virt/kvm/arm/vgic/vgic-kvm-device.c.html#211.。*/SET_DEVICE_ATTRIBUTE(FD，KVM_BINDINGS：：KVM_DEV_ARM_VGIC_GRP_CTRL，u64：：from(kvm_bindings：：KVM_DEV_ARM_VGIC_CTRL_INIT)，0，0，)？；OK(())}。</p><p> Regarding the FDT creation, there are differences between v2 and v3 regardingthe interrupt controller  intc node.</p><p>关于FDT创建，v2和v3在中断控制器INTC节点方面存在差异。</p><p> First, we need to define the GICv2  compatible property to be  arm,gic-400,since it is the GIC-400 chip which implements GICv2. Next is the  regproperty of the FDT, which includes the addresses and the corresponding sizes ofthe GIC registers, i.e. distributor and CPU for GICv2, distributor andredistributor for GICv3. Finally, we fix the  interrupts property whichdetermines the interrupt source of the VGIC maintenance interrupt. Thecorresponding values for GICv2 were taken from the respective  Linux Kernel entries.</p><p>首先，我们需要将GICv2兼容属性定义为ARM、GIC-400，因为它是实现GICv2的GIC-400芯片。接下来是FDT的regproperty，它包括GIC寄存器的地址和相应的大小，即GICv2的分配器和CPU，GICv3的分配器和再分配器。最后，我们修正了中断属性，它决定了VGIC维护中断的中断源。GICv2的对应值取自相应的Linux内核条目。</p><p>  While waiting for the patch to merge upstream you can go ahead and check out ityourself.</p><p>在等待补丁向上合并的同时，您可以继续自己检查它。</p><p> Clone and build our fork of firecracker (keep in mind that while the PR reviewis going on, we might force-update the branch).</p><p>克隆并构建我们的鞭炮分叉(请记住，在公关审查进行期间，我们可能会强制更新分支)。</p><p>  Next you need a kernel image and a root filesystem to run with your firecrackerbuild. You can grab the pre-built kernel image and rootfs here:</p><p>接下来，您需要一个内核映像和一个根文件系统来与firecrackerbuild一起运行。您可以在这里获取预建的内核镜像和rootfs：</p><p>  Alternatively, you can build your own kernel and rootfs using the followingsteps provided by the firecracker docs here</p><p>或者，您也可以使用此处的鞭炮文档提供的以下步骤构建您自己的内核和rootfs。</p><p>  To launch our image we will use the  firectl tool. We need, to setup a tapdevice for the networking or our firecracker microVM.</p><p>要启动我们的映像，我们将使用firectl工具。我们需要为网络或我们的爆竹微虚拟机设置一个磁带设备。</p><p> $ sudo ip tuntap add dev tap0 mode tap$ sudo ip addr add  172.16.0.1/24 dev tap0$ sudo ip link  set tap0 up</p><p>$sudo ip tunap add dev tap0模式分路器$sudo IP addr add 172.16.0.1/24 dev分路器0$sudo IP链路设置分路器0。</p><p>     curl 172.16.0.42 &lt;!DOCTYPE html&gt;&lt; html&gt;&lt; head&gt;&lt; title&gt;Welcome to nginx!&lt;/ title&gt;&lt; style&gt;  body {  width:  35 em;  margin:  0  auto;  font-family: Tahoma, Verdana, Arial,  sans-serif; }&lt;/ style&gt;&lt;/ head&gt;&lt; body&gt;&lt; h1&gt;Welcome to nginx!&lt;/ h1&gt;&lt; p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/ p&gt;&lt; p&gt;For online documentation and support please refer to&lt; a  href = &#34;http://nginx.org/&#34;&gt;nginx.org&lt;/ a&gt;.&lt; br/&gt;Commercial support is available at&lt; a  href = &#34;http://nginx.com/&#34;&gt;nginx.com&lt;/ a&gt;.&lt;/ p&gt;&lt; p&gt;&lt; em&gt;Thank you for using nginx.&lt;/ em&gt;&lt;/ p&gt;&lt;/ body&gt;&lt;/ html&gt;</p><p>Curl 172.16.0.42&lt；！DOCTYPE html&gt；&lt；html&gt；&lt；head&gt；&lt；title&gt；欢迎使用nginx！&lt；/title&gt；&lt；style&gt；body{width：35 em；edge：0 auto；font-family：tahoma，verdana，Arial，sans-serif；}&lt；/style&gt；&lt；/head&gt；&lt；body&gt；h1&gt；欢迎使用nginx！&lt；/h1&gt；&lt；p&gt；如果您看到此页面，则表明nginx Web服务器已成功安装并正常工作。需要进一步配置。&lt；/p&gt；&lt；有关联机文档和支持，请参阅&lt；a href=&#34；http://nginx.org/&#34；&gt；nginx.org&lt；/a&gt；。&lt；br/&gt；商业支持位于&lt；a href=&#34；http://nginx.com/&#34；&gt；nginx.com&lt；/a&gt；。&lt；/p&gt；&lt；&lt；em&gt；感谢您使用nginx。&lt；/em&gt；&lt；/p&gt；&lt；/body&gt；&lt；/html&gt；</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.cloudkernels.net/posts/firecracker-rpi4/">https://blog.cloudkernels.net/posts/firecracker-rpi4/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/移植/">#移植</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gic/">#gic</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>