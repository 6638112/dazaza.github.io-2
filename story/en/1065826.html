<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>缩放关系SQL数据库（2020） Scaling Relational SQL Databases (2020)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Scaling Relational SQL Databases (2020)<br/>缩放关系SQL数据库（2020） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-15 12:40:47</div><div class="page_narrow text-break page_content"><p>Many applications today still rely on traditional SQL databases like MySQL, MariaDb or PostgreSQL for data storage and data processing. With the growing amount of data and new workloads that are made with this database systems, we often find ourselves in situations where we need to think about scaling such systems.</p><p>今天许多应用程序仍然依赖于传统的SQL数据库，如MySQL，MariaDB或PostgreSQL，用于数据存储和数据处理。随着使用此数据库系统进行的越来越多的数据和新的工作负载，我们经常在我们需要考虑缩放此类系统的情况下找到自己。</p><p>  data storage, if we store more and more data and it becomes expensive or slow working with them</p><p>  数据存储，如果我们存储越来越多的数据，它变得昂贵或与他们一起工作</p><p>  making SELECT queries faster because of their complexity or because they need to query huge amounts of data</p><p>  使选择查询更快，因为它们的复杂性或因为它们需要查询大量数据</p><p> In this article, I will present some basic ideas and starting points on scaling traditional SQL databases.</p><p> 在本文中，我将在缩放传统SQL数据库上展示一些基本想法和起点。</p><p>  Newer versions of MySQL, PostgreSQL and other traditional SQL databases typically come with performance improvements. Even if the newer database system is not faster as a direct replacement, there might be new features available that we can take advantage of. Keeping our database system up to date expands our options on what we can do with our data and gives us the best out of the box performance. It is a basic enabler for scaling.</p><p>  MySQL，PostgreSQL和其他传统SQL数据库的较新版本通常会有性能改进。即使较新的数据库系统与直接替换不快，也可能有新功能，我们可以利用。保持我们的数据库系统最新延迟扩展我们的选项对我们的数据可以执行的操作，并为我们提供最佳盒式性能。它是一个用于缩放的基本启动器。</p><p>  The most intuitive idea of scaling is to use better hardware to scale vertically (on one database server). When it comes to hardware we typically look at CPUs, disk and RAM:</p><p>  缩放最直观的想法是使用更好的硬件垂直缩放（在一个数据库服务器上）。谈到硬件时，我们通常会查看CPU，磁盘和RAM：</p><p> The number of CPUs affects how many queries the database can run and therefore how many clients can be served</p><p> CPU的数量会影响数据库可以运行的查询数量，因此可以提供多少客户端 </p><p> The size of RAM gives us space for indexes, temporary tables and caches the database can store in a fast memory which makes our system faster due to minimizing IO access to disk</p><p>RAM的大小为我们提供了索引，临时表和缓存的空间，数据库可以存储在快速内存中，这使得我们的系统更快地使IO访问磁盘。</p><p> Disk IO speed highly affects the query times, especially for full scan reads (when indexes cannot be used) or for write-heavy systems</p><p> 磁盘IO速度高度影响查询时间，特别是对于全扫描读取（当不能使用索引时）或写入重型系统</p><p>  If the application’s code is in our control we can cache data in a memory store like  Redis or  Memcached to avoid querying the database. We don’t have to just cache database reads, but we can also use such systems as buffers for writes, e.g. when we are collecting analytical data and a possible delay is not a problem.</p><p>  如果应用程序的代码在我们的控制中，我们可以缓存在Redis或Memcached等内存存储中的数据，以避免查询数据库。我们不必只是缓存数据库读取，但我们也可以使用这样的系统作为写入的缓冲区，例如，当我们收集分析数据并且可能的延迟不是问题。</p><p>  When it comes to data, it all starts with data types, in other words how individual pieces of information are physically stored in memory. Choosing appropriate data types is always a balance between efficiency and functionality, affecting the required memory, query performance and number of operations we can do with the specific data type.</p><p>  涉及数据时，它全部以数据类型开头，换句话说，单个信息如何物理存储在内存中。选择合适的数据类型始终是效率和功能之间的平衡，影响我们可以使用特定数据类型执行所需的内存，查询性能和操作数。</p><p>  logical: how to store general information like a telephone number or an IP address; for instance we can store color as a string, enum or as a collection of RGB integers and we can store IP address as a string or as bytes</p><p>  逻辑：如何存储一般信息，如电话号码或IP地址;例如，我们可以将颜色存储为字符串，枚举或作为RGB整数的集合，我们可以将IP地址存储为字符串或作为字节</p><p> physical: what specific data types we choose for strings, integers or time since we typically have multiple options; e.g. date and time can be typically stored as a timestamp (faster but with limited date range and functionality) or as a more complex datetime which is more developer friendly and flexible, allowing to store timezone etc.</p><p> 物理：我们选择字符串，整数或时间的特定数据类型，因为我们通常具有多个选项;例如日期和时间通常可以存储为时间戳（更快但具有有限的日期范围和功能）或作为更复杂的DateTime，更多的开发人员友好且灵活，允许存储时区等。</p><p> Using an appropriate type for a database column is especially important when we want to index the column, use it in the WHERE clause, use it for joins or when we have a lot of data.</p><p> 使用适当的类型为数据库列尤其重要，当我们想要索引列时尤为重要，在where子句中使用它，使用它以便加入或当我们有很多数据时。 </p><p>  We are often trained to normalize data for relational databases in order to reduce data redundancy and improve data integrity. While this is generally useful, we might want to reconsider it for some of our data when it comes to scaling.</p><p>我们经常接受培训以规范关系数据库的数据，以减少数据冗余并提高数据完整性。虽然这通常是有用的，但我们可能希望在缩放方面重新考虑我们的一些数据。</p><p> Generally speaking the simpler we make our data to be retrieved or saved, the more of it we can have.</p><p> 一般而言，我们使我们能够检索或保存的数据更简单，我们可以拥有的更多信息。</p><p>  A lot of SELECT queries can be optimized by having the data already in the requested form. This can be handy for analyzing large amounts of data. For instance, instead of aggregating data every time, we can aggregate them beforehand. Of course this isn’t always possible, e.g. we cannot aggregate other average aggregates because we would lose precision.</p><p>  通过在已请求的表单中具有已优化的数据，可以优化许多选择查询。这可以方便地分析大量数据。例如，而不是每次聚合数据，而不是预先聚合它们。当然，这并不总是可能的，例如，我们不能汇总其他平均聚合，因为我们会失去精确度。</p><p>  Materialized views are continuously updated data that are updated on write operations or on scheduled time and can be seen as an extension of the previous point. Unlike classic views, materialized views are physically stored and don’t need to be computed when needed. This is useful for situations where a SELECT query would take a long time to produce the result.</p><p>  物化视图是连续更新的数据，这些数据在写操作或计划时间上更新，并且可以被视为前一点的扩展。与经典视图不同，物理化视图是物理存储的，并且在需要时不需要计算。这对于Select查询需要很长时间才能产生结果的情况非常有用。</p><p> As an example, look at  PipelineDB extension for PostgreSQL that produces aggregates on real-time data, allowing us to keep aggregated statistics on a write-heavy systems.</p><p> 例如，查看PostgreSQL的PopelIneyB扩展，它在实时数据上产生聚合，允许我们在写入重系统中保留聚合统计数据。</p><p>  Using the right indexes on tables can be a huge performance changer. Typically, we should index the columns by which we want to query the data or which we want to use to perform joins. However, adding indexes can also reduce performance for write-heavy workloads, since indexes have to be updated on every INSERT and UPDATE. Also it doesn’t make sense to use indexes on some data types. So it is all about finding the right balance.</p><p>  使用正确的表索引可以是一个巨大的性能更换器。通常，我们应该索引我们要查询数据的列，或者我们要用于执行连接。但是，添加索引也可以降低写入重型工作负载的性能，因为必须在每个插入和更新时更新索引。在某些数据类型上使用索引也没有意义。所以这一切都是关于找到合适的平衡。</p><p>  For optimizing reads we need to know how the database query planner will execute our queries. We can use EXPLAIN statement to obtain the execution plan that the SQL server will use for our query.</p><p>  为了优化读取，我们需要知道数据库查询策划器如何执行我们的查询。我们可以使用Explate语句来获取SQL Server将用于我们查询的执行计划。 </p><p> Here we should look if the database plans to use any of the existing indexes on the tables or plans to make a full table scan. It can give us hints whether we should change the structure of our data, add indexes or rewrite the query in a different way. Please note however that full table scan can be also faster or necessary for some queries so it is not a black and white situation.</p><p>在这里，我们应该了解数据库计划在表中使用任何现有索引或计划进行全表扫描。它可以给我们提示是否应该更改数据的结构，以不同的方式添加索引或重写查询。但请注意，对于某些查询，完整的表扫描也可以更快或必要，因此它不是黑白情况。</p><p>  The most common relational databases use multi-version concurrency control and make locking very granular (instead of locking the whole table, like MyISAM storage engine does). However, we still need to tell the database how exactly should the concurrency control behave and we can do so by setting appropriate transaction isolation level. There are 4 basic isolation levels in SQL:1992 standard and they will greatly affect how our database system behaves.</p><p>  最常见的关系数据库使用多版本并发控制并使锁定非常粒度（而不是锁定整个表，如Myisam存储引擎）。但是，我们仍然需要告诉数据库，并发控制行为究竟是如何通过设置适当的交易隔离级别来实现。 SQL：1992标准中有4个基本隔离级别，它们将极大地影响我们的数据库系统的行为方式。</p><p>  Writing or updating individual rows in a table is not efficient, but databases like MySQL or PostgreSQL have ways to insert or modify data in bulk. We should leverage this every time we can.</p><p>  在表中编写或更新单个行是不高效的，但数据库如MySQL或PostgreSQL等数据库有方法可以在批量中插入或修改数据。我们每次都应该利用这一点。</p><p>  Many times we don’t need to query the data by all the columns in a table. If this is the case, we can further optimize the storage size by storing some of the columns in a compressed form. This is especially useful for strings or some types of binary data.</p><p>  多次我们不需要通过表中的所有列查询数据。如果是这种情况，我们可以通过将一些列以压缩形式存储一些列来进一步优化存储大小。这对字符串或某些类型的二进制数据特别有用。</p><p> Some databases or their extensions might be already compressing data under the hood so it always makes sense to look first how the data are stored and whether adding compression on the application layer would bring the desired benefit.</p><p> 某些数据库或其扩展可能已经在引擎盖下压缩数据，以便首先了解存储数据以及是否在应用层上添加压缩会带来所需的益处。</p><p>  When the amount of data or the workload grows we will experience slower and slower ALTER TABLEs to the point where some of them might not finish in a reasonable time. The first important thing to know is that there are typically two ways of changing the structure of the database tables. One is INPLACE, modifying the original table and the other one is COPY, creating a new table and moving the data afterwards. Databases typically try to modify tables INPLACE if possible, but it might make sense sometimes to explicitly ask for the COPY operation.</p><p>  当数据量或工作量增加时，我们将体验到较慢，更慢的改变表到其中一些可能在合理的时间内可能无法完成。最重要的是要知道的是通常有两种改变数据库表的结构的方法。一个是否定，修改原始表，另一个是复制，创建一个新表并之后移动数据。数据库通常会尝试在可能的情况下修改表，但有时会明确要求复制操作可能有意义。</p><p> When adding a new column, it is better to add it at the end of the table, since inserting a column at a specific place is slow.</p><p> 添加新列时，最好将其添加在表的末尾，因为在特定位置插入列是慢的。 </p><p> When changing existing column it might be a good idea to create a new column first, copy the data and remove the column afterwards.</p><p>更改现有列后，首先创建新列可能是一个好主意，然后复制数据并之后删除列。</p><p> If the write operations on the table make it difficult to perform ALTER TABLE, it makes sense to stop clients from writing into the table first. This is not always possible, but e.g. collection of analytical data can be postponed using an ingestion buffer in front of the database or we can temporarily pause our ETL jobs working with the table.</p><p> 如果表上的写入操作使得难以执行更改表，则使客户端首先从写入表格写入表格是有意义的。这并不总是可能的，但是如此。分析数据的集合可以在数据库前面的摄取缓冲区推迟，或者我们可以暂时暂停与表一起使用的ETL作业。</p><p> The last resort is to simply not do any ALTER TABLEs on large and write-heavy tables, opting for creating a new table to store the new data instead.</p><p> 最后的度假胜地是根本没有在大型和重写尺寸表上进行任何改变表，选择创建一个新表来存储新数据。</p><p>  Every database server comes with some basic configuration on the maximum number of concurrent connections. When we need more, we typically need to reconfigure this value. Just increasing the value is not enough though – we need to make sure that our system can actually run well with our desired number of connections.</p><p>  每个数据库服务器都有一些基本配置，最大并发连接数。当我们需要更多时，我们通常需要重新配置此值。虽然越来越大，但是 - 我们需要确保我们的系统实际上可以使用所需数量的连接运行。</p><p>  Traditional SQL databases can’t typically scale horizontally for write operations by adding more servers, but we can still add other machines in the form of read-only replicas. The way this works is that all write operations are done on the main server and propagated to other machines using Write Ahead Log. All the replicas will therefore apply the same operations in the same order to the underlying storage as the main server. This ensures that the data will be in sync.</p><p>  传统的SQL数据库通常不能通过添加更多服务器来水平扩展为写操作，但我们仍然可以以只读副本的形式添加其他计算机。这项工作的方式是所有写入操作都在主服务器上完成，并使用写入前瞻日志传播到其他机器。因此，所有副本将以与主要服务器的底层存储相同的顺序应用相同的操作。这可确保数据将同步。</p><p> Replicas can be then used for scaling the number of read queries and number of connected clients if they only need read operations.</p><p> 然后，可以将副本用于缩放读取查询数和连接客户端的数量，如果它们只需要读取操作。</p><p>  Partitioning allows us to distribute one single table across the filesystem and store individual partitions based on some specific rules. When such rules are chosen well, SQL queries don’t have to query all partitions but can limit their search only to a subset of them. This will cut the time the query will run since not the whole database table needs to be looked into.</p><p>  分区允许我们在文件系统上分发一个单个表，并根据某些特定规则存储单个分区。 When such rules are chosen well, SQL queries don’t have to query all partitions but can limit their search only to a subset of them.这将切割查询运行的时间，因为不需要查看整个数据库表。 </p><p>  When we need to store and work with geospatial, time series and other specialized data, we can sometimes use a database extension like  TimescaleDb or  PostGIS to make the data processing and storage more efficient.</p><p>当我们需要存储和处理地理空间，时间序列和其他专业数据时，我们有时可以使用像时间尺寸或后智能的数据库扩展，以使数据处理和存储更高效。</p><p>  Sharding is partitioning on steroids and allows us to store parts of the database table (shards) on different servers. Distributed databases are often built with the concept of shards, but traditional SQL servers cannot automatically shard data, since they only work with one main server and replicas. So what can we do?</p><p>  分片是在类固醇上分配，并允许我们将数据库表（分片）的部分存储在不同的服务器上。分布式数据库通常使用碎片的概念构建，但传统的SQL服务器无法自动分析数据，因为它们只能使用一个主服务器和副本。所以，我们能做些什么？</p><p> We can investigate whether some clustering solution like  MySQL Cluster or  Vitess for MySQL or  Citus for PostgreSQL would solve our scaling problem. This solutions are built to provide “horizontally scalable SQL database” but they are not without limitations. For instance, MySQL Cluster doesn’t work with classic InnoDb engine, so we cannot just write applications like we used to.</p><p> 我们可以调查一些MySQL群组或Vitess for MySQL或PictgreSQL等群集解决方案是否可以解决我们的缩放问题。构建此解决方案以提供“水平可扩展的SQL数据库”，但它们并非没有限制。例如，MySQL Cluster不适用于Classic InnoDB引擎，因此我们不能只需编写我们曾经的应用程序。</p><p> Another option is to shard data manually on the application layer. This brings additional complexity to the application where we need to manage multiple connections to different servers and query the databases appropriately, but it is a solution to consider.</p><p> 另一种选择是在应用层上手动分离数据。这为应用程序提供了额外的复杂性，我们需要管理与不同服务器的多个连接并适当地查询数据库，但它是考虑的解决方案。</p><p>  If the amount of data is our primary issue and our tables are becoming too large, we should think about whether we can put this data elsewhere.</p><p>  如果数据量是我们的主要问题，我们的表格变得太大，我们应该考虑我们是否可以将此数据放在其他地方。</p><p> If we do need the data occasionally and we don’t need any UNIQUE indexes across the whole table, we can simply divide the data into multiple tables. For instance, we can separate data from different customers or store older data in archive tables. This way we can keep our tables smaller and more performant.</p><p> 如果我们偶尔需要数据，我们在整个表中不需要任何唯一索引，我们可以简单地将数据划分为多个表。例如，我们可以将来自不同客户的数据分开或存储旧数据表中的旧数据。这样我们就可以让我们的表格较小，更加性能。</p><p> In some cases we might even decide that it is okay not to store some data in our primary database and either simply delete them or move them to another storage system.</p><p> 在某些情况下，我们甚至可以决定在我们的主数据库中存储一些数据，并且只需删除它们或将它们移动到另一个存储系统中。 </p><p>  Sometimes relational SQL databases are just not enough. For instance, we might want to create data workflows that are unfit for such systems or we might not be able to make changes to the schema or change how existing programs interact with the database. Maybe we reached our limits in scaling the current data processing and we need more. So what now?</p><p>有时关系SQL数据库是不够的。例如，我们可能希望创建不适合此类系统的数据工作流程，或者我们可能无法对模式进行更改或更改现有程序与数据库交互方式。也许我们在缩放当前数据处理方面达到了极限，我们需要更多。所以现在怎么办？</p><p> In many cases, the best approach is to move the data to another system and process it there. Fortunately, we can utilize Write Ahead Log (WAL) that stores all changes (INSERTs, UPDATEs, ALTER TABLEs) that the database should perform. We can programmatically read this log and stream it into another system. For instance, we can stream data into  Kafka using existing database connectors and allow other applications to read it. Or we can send this data directly to a specialized database, e.g. to an analytical database  Clickhouse or to a data lake like Hadoop and process them there. We can also move the data via other means: taking a copy of the database, extracting data with SQL, etc.</p><p> 在许多情况下，最好的方法是将数据移动到另一个系统并在那里进行处理。幸运的是，我们可以利用写入前瞻性日志（WAL），该日志（WAL）存储数据库应该执行的所有更改（插入，更新，更改表）。我们可以以编程方式读取此日志并将其传输到另一个系统中。例如，我们可以使用现有的数据库连接器将数据传输到Kafka，并允许其他应用程序读取它。或者我们可以直接将此数据发送给专用数据库，例如，到分析数据库点击房或像Hadoop这样的数据湖泊并在那里处理它们。我们还可以通过其他方式移动数据：拍摄数据库的副本，用SQL提取数据等。</p><p> If we only want to scale data computation without using a different database system, process data from multiple data sources at once or simply want to organize our data processing better, we can use distributed cluster-computing software such as  Apache Spark.</p><p> 如果我们只想在不使用不同的数据库系统的情况下扩展数据计算，从多个数据源的过程数据一次或只是想更好地组织我们的数据处理，我们可以使用Apache Spark等分布式群集计算软件。</p><p>  Many people pay for managed SQL databases from cloud providers like AWS or Azure so that they don’t have to worry about maintaining them. However, when we need to scale our traditional SQL store, many scaling options will be actually unavailable to us.</p><p>  许多人从AWS或Azure等云提供商支付托管的SQL数据库，以便他们不必担心维护它们。但是，当我们需要扩展我们的传统SQL商店时，许多缩放选项实际上将无法使用。</p><p> This can include limited ability to change the database configuration, limited hardware options to choose from, limited number of replicas, higher latency, Write Ahead Log might be inaccessible and we might not be able to update the database version to the current, modern version we want. We might not be able to install extensions that would improve performance of our system. Also debugging performance issues on such remote system might be difficult or impossible, since we might not have proper access to the operating system.</p><p> 这可能包括有限的更改数据库配置的能力，有限的硬件选项可供选择，有限的副本，更高的延迟，写入前瞻性日志可能无法访问，我们可能无法将数据库版本更新到当前，现代版本我们想。我们可能无法安装将提高系统性能的扩展。此外，调试此类远程系统上的性能问题可能是困难或不可能的，因为我们可能无法正确访问操作系统。</p><p> So before buying into the dream of never having to worry about a SQL store, we should investigate what the options are and if the managed database offer is actually sufficient.</p><p> 因此，在购买永不担心SQL商店的梦想之前，我们应该调查选项是什么，如果托管数据库提供实际上是足够的。</p><p>  The presented options are just possible starting points to give us some areas to think about. I didn’t want to go into extra details as scaling SQL databases is not a straightforward operation. We always need to think about our system and the options we have, making every solution unique.</p><p>  呈现的选项只是可能的起点，为我们提供一些思考的领域。由于缩放SQL数据库不是直接的操作，我不想进入额外的细节。我们总是需要考虑我们的系统和我们拥有的选项，使每个解决方案都是独一无二的。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://stribny.name/blog/2020/07/scaling-relational-sql-databases/">https://stribny.name/blog/2020/07/scaling-relational-sql-databases/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/database/">#database</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/关系/">#关系</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>