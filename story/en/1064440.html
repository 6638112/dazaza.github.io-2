<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>一件简单的东西 A Simple Thing</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A Simple Thing<br/>一件简单的东西 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-09 07:11:45</div><div class="page_narrow text-break page_content"><p>As I&#39;ve been setting up NetBSD on my ThinkPad T41,I&#39;ve found myself wanting a small piece of functionality:</p><p>作为我在我的ThinkPad T41上设置了NetBSD，我发现自己想要一小块功能：</p><p> I want my xterm window titles to reflectthe current state of the shell running in the terminal.Things like the working directory and the running process.</p><p> 我希望我的XTerm窗口标题反映了在终端中运行的shell的当前状态。作为工作目录和运行进程。</p><p> A simple thing, right?So I thought too.But the problem is more complicated than it looks.</p><p> 一件简单的东西，对了吗？所以我想也是如此。但问题比它看起来更复杂。</p><p> The solution I&#39;ve finally settled onrequires modification of the source of the shell [ 1]as well as a custom program that communicates with the shell,continuously updating the title of the relevant xterm window [ 2].To understand why this is the best solution,we need to go through and dismiss the alternatives.</p><p> 解决方案i＆＃39; ve终于解决了shell [1]源的正常修改，以及与shell通信的自定义程序，不断更新相关的Xterm窗口的标题[2]。要了解为什么最好的解决方案，我们需要通过并解雇替代方案。</p><p>  There are two ways of changing the title of a terminal window:either via X11 or via terminal control codes.</p><p>  有两种方法可以改变终端窗口的标题：通过X11或终端控制代码。</p><p>  As they are sent directly to the terminal (emulator),there is no risk that accidentally affect the wrong window.</p><p>  由于它们被直接发送到终端（仿真器），因此没有意外地影响错误窗口的风险。</p><p> They can be sent by the shell&#39;s built-in  echo command,reducing the latency of running an external command.</p><p> 它们可以由shell＆＃39; s内置echo命令发送，从而减少运行外部命令的延迟。 </p><p> If you search the internet for ways to set the terminal titleto the current working directory,you&#39;ll find many suggestions along the following lines:</p><p>如果您搜索互联网以获取设置终端Titlevo当前工作目录的方法，请＆＃39; ll沿着以下行找到许多建议：</p><p>  This sends the  CSI 2 ; &lt;title&gt; BEL control sequence to the terminalat every prompt, which instructs it to set the window title [ 3].</p><p>  这发送了CSI 2; ＆lt; title＆gt; Bel控制序列到终端的每个提示，指示它设置窗口标题[3]。</p><p>  Not all terminal emulators support this control sequence.NetBSD&#39;s wscons, for example, is completely broken by it.</p><p>  并非所有终端仿真器都支持此控制序列..例如，SBSD＆＃39; S WSCONS完全破碎。</p><p> None of these points are big problems on their own.You can check $TERM to identify wscons.You can tell screen to forward the control sequenceby adding a  ESC P prefix a  ESP \ suffix to it.</p><p> 这些点都不是他们自己的大问题。您可以检查$术语以识别WSCons.You可以告诉屏幕转发控制excomby添加ESC P前缀ASP \后缀。</p><p> The problems start when you try to combine them.If you tell screen to forward the control sequence,it might forward it to wscons.This will  not be caught by the $TERM checkif the screen session was started somewhere else than wscons.</p><p> 当您尝试组合它们时，问题开始。如果您告诉屏幕转发控制序列，它可能会将其转发给WScons.This将不会被屏幕会话在除WSCons其他地方启动屏幕会话。</p><p> For example, I was working on my fork of the jwm window manager [ 4]in a screen session in xterm.I realized that I needed to restart X in order to try out my changes,so I detached from the screen session and quit X.</p><p> 例如，我正在Xterm中的屏幕会话中撰写了JWM Window Manager [4]的叉子.I意识到我需要重新启动X才能尝试我的更改，因此我从屏幕会话中分离并退出X. 。</p><p> Back in wscons, I realized that I still needed to compile my changes.So I re-attached to the screen session and entered  make.Everything went well until my shell&#39;s prompt showed up again.Suddenly, typed characters weren&#39;t being displayed on the screen anymoreand there didn&#39;t seem to be any way to fix it.</p><p> 回到WSCONS中，我意识到我仍然需要编译我的更改。所以我重新附加到屏幕会话并输入make.everything直到我的shell＆＃39; s迅速展示了。很多，键入的人物Weren＆＃39 ;在屏幕上显示，任何似乎都有任何方法来解决它。 </p><p> In my shrc, I made sure that $XTERM_SHELL was setbefore I sent the control sequences,but because the screen session was started in xterm, $XTERM_SHELL  was set,even though I was attached to the session in wscons and not xterm.</p><p>在我的shrc中，我确保了$ xterm_shell是setBefore我发送了控制序列，但由于屏幕会话在xterm中启动，即使我已附加到WSCons中的会话，也是如此，因此Xterm_Shell。</p><p>  Turns out there isn&#39;t any obvious way to do that.The closest thing to a solution is towrite a certain control sequence to the terminal,which asks it for its  secondary device attributes.These will be different for different terminals.I don&#39;t know if they&#39;re guaranteed to be  unique,but they work well enough to distinguish one terminal from another.</p><p>  拒绝那里有任何明显的方法。对解决方案的最接近的东西是终端的一定的控制序列，它要求它为其辅助设备属性。这些对于不同的终端将是不同的.I don＆ ＃39; t知道他们是否保证是独一无二的，但它们很好地与另一个终端区分开。</p><p> Combine that with another problemthat I&#39;ve kept hidden from you until now.I said that you can tell screen to forward control sequencesto the parent terminal.Well, it turns out you don&#39;t want to do thatif you&#39;re  not inside GNU screen.</p><p> 与另一个问题相结合，直到现在。ve ve ide。直到现在。我说你可以告诉屏幕转发控制序列父终端。威尔，它让你不想做这个＆＃39 ;重新在GNU屏幕中。</p><p> My solution to these problems is called  safetitle [ 5].It is a C program that tries to figure out the identity of the terminalbased on its secondary device attributes.If the identified terminal is blacklisted (wscons),it exits.Otherwise, it sends the control sequences that set the terminal title.But don&#39;t forget:if the terminal is identified to be GNU screen,it also sends the special forwarding control sequences.</p><p> 我对这些问题的解决方案称为Subetitle [5]。它是一个c程序，它试图弄清楚终端基于其辅助设备属性的身份。如果识别的终端被列入黑名单（WSCons），则会发送。否则，它会发送设置终端标题的控制序列。但是忘记了：如果终端被识别为GNU屏幕，则它还发送特殊转发控制序列。</p><p> Ultimately, though,I was not entirely satisfied.Not only was safetitle a hack,but because it required forking a child process at every prompt,it was a bit slow.</p><p> 然而，尽管如此，我没有完全满足。只有停用一个黑客，而且因为它需要在每次提示时刻到儿童进程，这有点慢。</p><p> On the flip side,it could be made better by only using it when $TERM is set to screen,and using the traditional method otherwise.Furthermore, just the fact that it supported GNU screen was pretty great,and I would probably have kept using itif it weren&#39;t for the next section of this story.</p><p> 在翻盖方上，当$术语设置为屏幕时，可以更好地使用它，并使用传统方法否则使用传统方法。若要使用它，只是它支持的GNU屏幕的事实非常棒，我可能会留下这是这个故事的下一部分的IT Weren＆＃39; t。</p><p>  Barring the unexpected complications described above,setting the terminal title to the current working directory is easy enough.It is far more difficult to set the terminal titleto the currently running program.</p><p>  禁止上述意外的并发症，将终端标题设置为当前工作目录很容易。它更难以设置当前运行的程序的终端TITLETO。 </p><p> The first problem is terminological.What does one even mean by the currently running program?One probably doesn&#39;t mean the shell itself,which is the obvious answer to the question;one probably means something likethe program running  inside the shell.</p><p>第一个问题是术语。目前正在运行的程序均匀意味着什么可能不会意味着贝壳本身，这是问题的明显答案;一个可能意味着在壳体内运行的程序。</p><p> The problem with this is that the shell can run many programs at once.Take a look at the following process tree:</p><p> 问题是，shell可以立即运行许多程序。查看以下过程树：</p><p> 269 ttyE0 S 0:01.51 xterm 977 ttyp0 Ss 0:00.04 - ksh 808 ttyp0 T 0:00.02 |-- vi Makefile 1204 ttyp0 T 0:01.42 |-- vi a-simple-thing.em 9465 ttyp0 0+ 0:00.01 `-- vi ps -d</p><p> 269 TTYE0 S 0：01.51 XTTTEM 977 TTYP0 SS 0：00.04  -  KSH 808 TTYP0 T 0：00.02 |  -  VI Makefile 1204 TTYP0 T 0：01.42 |  -  VI A-Simpt-intern.em 9465 TTYP0 0 + 0：00.01 ` -  vi ps -d</p><p> xterm is running ksh, which is running three processes simultaneously.Who is to say which is the &#34;correct&#34; currently running process?</p><p> XTerm正在运行KSH，它同时运行三个进程。可以说哪个是＆＃34;正确的＆＃34;目前正在运行的过程？</p><p> One solution is to count the youngest process as the currently running one.The following shell script does exactly that.Given a pid, it prints the pid ofthe corresponding process&#39;s youngest grandchild:</p><p> 一个解决方案是根据当前运行的一个解决方案。以下Shell脚本确实如此.Given一个PID，它打印了相应过程的PID＆＃39;最小的孙子：</p><p> ps -do pid,etime,comm -k etime $opt |pid=$1 perl -lane &#39; if (/^ *$ENV{pid} / .. 1) { next if /^ *$ENV{pid} /; last if not /[|`-]/; $t = 0; $i = 0; $t += $_*(60**$i++) for reverse split /:/, $F[1]; print &#34;$t $_&#34; if $t &gt; 2; }&#39; |sort -n |head -1 |cut -d\ -f2</p><p> ps -do pid，eTime，comm -k eTime $ opt | pid = $ 1 perl -lane＆＃39; if（/ ^ * $ env {pid} / .1）{next if / ^ * $ env {pid} /;持续的，如果不是/ [|` - ] /; $ t = 0; $ i = 0; $ t + = $ _ *（60 ** $ i ++）用于反向拆分/：/，$ f [1];打印＆＃34; $ t $ _＆＃34;如果$ t＆gt; 2; }＆＃39; |排序-n | HEAD -1 | CUT -D \ -F2</p><p> Conceivably, one could check the output of the script every so oftenand set the title of the corresponding xterm window accordingly.</p><p> 可以想象，可以通过每个都可以检查脚本的输出，所以经常设置相应的XTerm窗口的标题。 </p><p> The problem with this naive solution is that the age of the processdoesn&#39;t reflect whether it is currently active in the shell.The only source of this information is the shell itself.</p><p>这个天真解决方案的问题是，过程中的年龄＆＃39; t反映了它当前是否在shell中处于活动状态。此信息的唯一来源是shell本身。</p><p> So perhaps the shell can set the window titlewhenever it starts or continues a process.But looking around at the popular shells, the landscape is rather dry.</p><p> 因此，也许shell可以设置窗口标题，无论它开始还是继续一个过程。在流行的贝壳上环顾四周，景观相当干燥。</p><p> The Z shell is the only shell which properly supports something similar.It offers the  precmd and  preexec functions [ 6]:</p><p> Z shell是唯一适当支持类似的shell。它提供了PRODMD和PREExec函数[6]：</p><p>  It is possible to simulate  preexec in Bash, but it is a hack at best:the special DEBUG signal handler, if set,will be triggered before every command executed by Bash.</p><p>  可以在BASH中模拟PREEXEC，但它最多是一个黑客：如果在BASH执行的每个命令之前，将触发特殊调试信号处理程序。</p><p>      All of these were real, weighing issues to me.If only there were a better way to do it --one that would work with the shell of my choice, the Korn shell.</p><p>      所有这些都是真实的，称重问题。如果只有更好的方法可以与我选择的壳牌一起使用，这是一个更好的方法。</p><p>  The Korn shell being open source, I started trying to modify it.I wanted to implement the following functionalitydirectly in the shell itself:</p><p>  korn shell是开源的，我开始尝试修改它。我想在shell本身中实现以下功能：</p><p>  Unfortunately, I ran in to a big problem:I couldn&#39;t find any way to have the shell itselfsend the terminal control sequences without breaking something.I&#39;d get it working until I tried running  ed,at which point typed characters would stop being displayed.</p><p>  不幸的是，我跑到了一个大问题：我找不到任何方法让shell自身归咎于终端控制序列，而不破坏东西。我＆＃39; d得到它工作直到我尝试运行ed，在哪一点键入字符将停止显示。 </p><p> The underlying issue is that the terminal is difficult to work with.Different terminals support different control sequences,and the current state of the terminal is hard to reason about.</p><p>底层问题是终端难以使用。不同的终端支持不同的控制序列，并且终端的当前状态很难得到推理。</p><p> So I scrapped all of my previous work and started thinkingabout what a more reliable solution might look like.After a good night&#39;s sleep, I came up with this:</p><p> 所以我把所有以前的工作都辞载了，开始思考一个更可靠的解决方案可能看起来更加可靠的解决方案。在睡眠中，睡得很好，我想出了这个：</p><p> Create a program that reads from the named pipe and sets thewindow title of the corresponding xterm window via the X11 API.</p><p> 创建从命名管道读取的程序，并通过X11 API设置相应的XTerm窗口的Window标题。</p><p>  #!/bin/shrm /var/$$.session 2&gt;/dev/nullmkfifo /var/$$.sessionxterm -e ksh -w /var/$$.session &amp;pid=$!xdotool search --sync --pid $!cat /var/$session | while read ln; do	case &#34;$ln&#34; in	cwd*)	cwd=${ln#cwd}		xdotool --pid $! set_window --name &#34;$cwd&#34; ;;	cmd*)	cmd=${ln#cmd}		xdotool --pid $! set_window --name &#34;$cmd ($cwd)&#34; ;;	*)	xdotool --pid $! set_window --name &#34;$cwd&#34; ;;	esacdone</p><p>  ＃！/ bin / shrm /var/war/war/session 2＆gt; / dev / nullmkfifo /var/$$ .sessionxterm -e Ksh -w /var/$$$。PID = $！xdotool search --sync  - -PID $！CAT / VAR / $ SESSION |读Ln;案例＆＃34; $ ln＆＃34;在cwd *）cwd = $ {ln＃cwd} xdotool --pid $！ set_window --name＆＃34; $ cwd＆＃34; ;; cmd *）cmd = $ {ln＃cmd} xdotool --pid $！ set_window --name＆＃34; $ cmd（$ cwd）＆＃34; ;; *）xdotool  -  pid $！ set_window --name＆＃34; $ cwd＆＃34; ;; Esacdone.</p><p> The script creates a named pipe and launches ksh in xterm,telling it to read from the named pipe.Then, it waits for the window associated withthe pid of the launched xterm process to appear.Once the window appears,the script starts reading from the named pipe,updating the title on every line read.</p><p> 该脚本创建一个命名管道并在xterm中启动ksh，告诉它从命名的pipe.then读取，它等待与启动的Xterm进程的PID关联的窗口出现。窗口出现，脚本开始读取读取命名为管道，在每行读取时更新标题。</p><p> This initial shell script didn&#39;t work,because xdotool is rather unreliablewhen it comes to setting window titles.But I knew it was possible,because I had written a small C program myselfthat could set the window title.</p><p> 这个初始shell脚本没有工作，因为xdotool在设置窗口标题时相当不可靠。但是我知道这是可能的，因为我写了一个小的C程序，自己可以设置窗口标题。</p><p>   I patched [ 1] NetBSD&#39;s ksh to support a new option called -w,which expects the name of a file.If provided, the shell opens the file for writingand then,whenever either an interactive command is issued,the prompt is writtenor the cwd of the shell is updated,a single line is written to the file.The line has the following format:</p><p>   我修补了[1] NetBSD＆＃39; s Ksh支持一个名为-W的新选项，它期望提供了文件的名称。如果提供的，shell将打开forth的文件，然后，只要发出交互式命令，提示是编写的shell的CWD已更新，单行将写入文件。行具有以下格式： </p><p>  The second component, tterm [ 2], is what wraps it all together.Upon execution, it creates a named pipe on the file system,identified by tterm&#39;s own pid.Then, it immediately forks.</p><p>第二个组件TTTERM [2]是什么都在一起包装.UPON执行，它在文件系统上创建一个命名管道，由TTTTM＆＃39;自己的PID。然后，它立即叉。</p><p>   Meanwhile, the parent process starts looking fora window belonging to the pid of the child process.Once such a window is found,it starts reading from the named pipe.</p><p>   同时，父进程开始查找属于子进程的PID的窗口。找到这样的窗口，它开始从命名管道读取。</p><p> For every line read,it sets the title of the found windowaccording to the following rules:</p><p> 对于每行读取，它将找到的窗口的标题设置为以下规则：</p><p>  For example, it sets the title to cwd at startup,which is probably your home directory,so it sets it to  ~.Then, when you run  vi todo,it sets the title to  vi todo (~).Finally, when you exit vi,it sets the title back to  ~.</p><p>  例如，它将标题设置为启动时的CWD，这可能是您的主目录，因此它将其设置为〜.then，当您运行VI Todo时，它将标题设置为VI Todo（〜）。最后，当您退出时VI，它将标题设置为〜。</p><p>   In summary, I&#39;ve traveled the world aroundin search of a solution to a very simple problem.Ultimately, the solution turned out to be pretty simple as well.</p><p>   总之，我跳过了世界各地的解决方案，以非常简单的问题。所以解决方案也很简单。</p><p> It only has a single problem:it doesn&#39;t work with GNU screen.While it wouldn&#39;t strictly be impossible to make it work,it would require a lot of effort.In the meantime, I&#39;m happy to fall back on safetitlewhen $TERM is set to screen:</p><p> 它只有一个问题：它没有与GNU屏幕一起工作。当它不可能使其工作，它需要很多努力。在此期间，I＆＃39; m很高兴回落在SafeTlewhen $术语时被设置为屏幕：</p><p>   Window titles are especially dear to me,as I use them to figure out the current working directoryin a script called  dwim [ 7],which emulates the Plan 9 plumbing system on UNIX.It is an extremely useful scriptthat I couldn&#39;t live without.</p><p>   窗口标题对我来说特别珍惜，因为我用它们来弄清楚当前工作目录，它是一个名为dwim [7]的脚本，它在Unix上模拟了计划9管道系统.it是一个非常有用的脚本系统，我可以＆＃39; t live没有。 </p><p> In the end,I hope this page can serve as a resourcefor those who have been looking for the same answer as me.I&#39;ve spent a decently large amount of time researching this topic,so be sure to send me an e-mail [ 8] if there&#39;s something you&#39;re wondering.</p><p>最后，我希望这个页面可以作为那些一直在寻找与me的答案的资源。我在这一主题中度过了非常大量的时间，所以一定要给我发一个 邮件[8]如果有你的东西＆＃39;重新想起。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://ankarstrom.se/~john/a-simple-thing.html">http://ankarstrom.se/~john/a-simple-thing.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/simple/">#simple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/终端/">#终端</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>