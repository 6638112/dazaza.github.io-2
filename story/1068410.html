<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>不可变化改变了一切 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">不可变化改变了一切 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-26 17:33:04</div><div class="page_narrow text-break page_content"><p>2016年1月20日第13卷，第9期有一个不可避免的趋势，可以存储和发送不可改变的数据。我们需要在远处协调不可变，我们可以负担不变，因为储存变得更便宜。本文是一种amuse-bouche采样，重复的计算模式可以利用不可变节性。上下爬上计算堆栈真的确实可以再次产生了一定程度的Déjàvu。</p><p> 它很久以前那很久以前那很昂贵，磁盘存储价格昂贵，DRAM（动态随机存取存储器）昂贵，但与闩锁的协调很便宜。现在所有这些都使用廉价计算（有许多核心），廉价的商品磁盘和廉价的DRAM和SSD（固态驱动器）发生了变化，而与锁存器的协调变得更加困难，因为锁存延迟失去了大量的指导机会。保持不变的副本，现在价格实惠，一个支付减少了协调挑战。</p><p>   由于磁盘的每磅成本，存储越来越多地增加。这意味着很多数据可以保持很长时间。随着越来越多的数据和工作越来越多，分布正在增加。数据中心内的数据似乎＆＃34;遥远。＆＃34;许多核心芯片内的数据可能看起来＆＃34;遥远。＆＃34;在尝试与远离远方的系统协调时，歧义正在增加 - 自从您听到新闻以来发生了更多的东西。你能采取不完整的知识吗？你能等到足够的知识吗？</p><p>   随着各种技术领域的发展，他们通过以一些非常有趣的方式使用不可变数据，回应了增加存储，分配和歧义的这些趋势。本文探讨了应用程序在持续的工作中使用不变性，如何为稍后的离线分析生成不可变数据集，SQL如何暴露和处理不可改变的快照，以及大规模并行的大数据工作如何依赖于不可变数据集。这导致在剩余不变的同时可以改变语义不可变数据集的方式。</p><p> 接下来，该文章考虑了如何通过LSF（日志结构化文件系统），COW（编写写入）和LSM（Log-Structureed Merge-Tree）等技术在创建新的Upcutable文件中如何分层更新性。复制和分布式文件系统如何依赖于消除异常的不变性？硬件人士通过利用SSD和HDD（硬盘驱动器）利用这些技巧加入了派对。不变性是堆叠多层的关键建筑概念，如图1所示。</p><p>     只有许多类型的计算都是附录的。本节看一些常用的方式。</p><p>   在仅附加计算中，将永远录制观察（或长时间）。导出的结果按需计算（或定期预先计算）。 </p><p>这类似于DBMS（数据库管理系统），其中事务日志记录对数据库所做的所有更改。高速附录是更改日志的唯一方法。从这个角度来看，数据库的内容载有日志中最新记录值的缓存。事实是日志。数据库是日志子集的缓存。缓存的子集恰好是来自日志的每个记录和索引值的最新值。</p><p>   会计师不使用橡皮擦;否则他们可能会入狱。分类帐中的所有条目都保留在分类帐中。可以通过在分类帐中制作新条目来进行更正。当一家公司＆＃39;季度结果发表时，它们包括对上一季度的小规则。小修复很好。他们也是附加的。</p><p> 有些条目描述了观察到的事实。例如，接收借记或反对支票账户的信贷是观察到的事实。有些条目描述了派生事实，这意味着基于观察，可以计算新的东西。例如，基于速率和成本的摊销资本开支是导出的事实。另一个例子是当前银行账户余额与应用借记和信用。</p><p>   单程计算意味着以某种方式排序更改。订单可以来自集中式主站或一些类似PAXOS的11个分布式协议，提供串行排序。在语义上一次应用更改，并以其前辈分层。新价值取代旧的值。这方面的粒度可以是关系存储中的一组记录或文档的新版本。分布式的单主计算意味着存在一个数据（关系记录，文档，导出文件等），它从一个逻辑位置发出新版本随时间的新版本。</p><p>   在电话之前，人们使用的使者 - 经常孩子们走路穿过城镇交付信息。或者，邮政服务提供了很长时间的消息。有时人们使用幻想形式有许多层，每个颜色都有不同的颜色。页面上有多个部分。每个参与者都填写了一节（用笔按压），然后从表格的后页上撕下并提交它。每个参与者都有所需的数据并将更多的数据添加到表单中。早期的部分无法更新;数据只能附加到最后。</p><p> 在计算机之前，工作流程经常以纸张形式捕获，表单上的多个部分和多页（例如，＆＃34;填写第3部分，并从后面＆＃34保留GoldenRod页面;）。这个＆＃34;分布式计算＆＃34;仅限申请。新消息是表格的新消息 - 每个都是一个版本，每个都是不可变的。你永远不会被允许覆盖写的东西。</p><p>   令人惊讶的是（对于数据库旧计时器），并非所有数据都保存在关系数据库系统中。本节（基于早期文件7）讨论了解锁数据的一些含义。 </p><p>内部的数据是指由经典关系数据库系统及其周围的应用程序代码保存和管理的内容。有时这被称为服务。</p><p> 内部的数据生活在交易世界中，以可序列化的方式应用的变化（或接近该问题）。</p><p>   外部的数据被准备为消息，文件，文档和/或网页。这些是从一个服务中发送到世界的服务。除了使用数据库之外，还可以由其他机制创建外部数据。</p><p>   *被解锁。它未锁定在数据库中。提取并发送外部副本。</p><p> *有身份。在外面发送时，这些文件，文档和邮件具有唯一的标识（可能是URL）。</p><p> *可能是版本的。更新Aren＆＃39; t更新但具有新唯一标识符的新版本。</p><p>   内部数据与外部数据的表示，含义和使用情况存在深刻差异。越来越多地，数据被视为外部（不可变）数据（参见图2）。 </p><p>数据集是具有唯一ID的数据集合。某些数据集具有与具有架构的多个表的结构。如何由关系数据库引用的这些数据集，以及关系运算符如何跨越DBMS和数据集？</p><p>   数据集是一个固定和不可变的表组。在数据集中捕获每个表的模式。创建数据集时捕获每个表的内容。由于数据集是不可变的，因此创建它，可以消耗读取，然后删除。数据集可以是关系，或者它们可以具有一些其他表示，例如图形，诸如JSON（JavaScript对象符号）或任何其他表示的层次结构（图3）。数据集是一个逻辑集的不可变形表以及其模式。</p><p>    数据集可以由RDBMS（关系DBMS）引用。 DBMS可见元数据。即使可能无法更新，也可以访问数据。即使它物理存储在其他地方，也可以在关系系统内进行语义上存在数据集。因为数据集是不可变的，所以没有必要锁定，并且不担心控制更新。</p><p>   功能计算需要一组输入，并且可预测地创建一组输出。这可能在关系数据库中的锁定或快照数据的查询发生，并且可以在大数据MapReduce风格系统上发生。在这两种情况下，仍然存在不变的数据集合。通过快照或某种形式的隔离，数据库数据对于计算持续时间来说是语义上的。通过大数据计算，输入通常存储在GFS（Google文件系统）或HDFS（Hadoop分布式文件系统）文件中。</p><p> 在那里没有语义障碍，可以在存储在关系数据库中的数据和存储在外部数据集中的数据中进行连接。锁定（或快照隔离）提供了可以加入的关系数据库的版本。命名和冻结数据集可以与关系数据加入（参见图4）。您可以将在DBMS中保存的数据和在不可变数据集中保存的数据中有意义地应用关系。</p><p>  在某些方面，在不可变数据集和关系数据库中工作的能力令人惊讶。使用标识和可选版本定义不可改变的数据集。它的架构，其描述了在创建时的数据集的形状和形式，是描述性的，而在RDBMS中保持的模式是规范性的。</p><p> 该图案剪裁为融合的模式，两个连接数据集的模式（写入时写入其数据）与RDBMS的架构（描述其作为快照的数据）。此外，联接和其他关系运算符必须必须将数据集的内容组合为解释为一组关系表。这一个申请数据集中的标识概念，并专注于表格，以解释为在行和列中保持的一组值。 </p><p>即使在封面下改变，消费者可能会将数据集视为不可变。</p><p>   数据集是语义上不可变的。它有一组表，行和列。它也可能具有半结构化数据（例如，JSON）。它可能具有专有格式的特定于应用程序的数据。</p><p> 数据集可以被定义为选择，投影或加入以前现有的数据集。语义上，所有数据现在都是新数据集的一部分。</p><p> 什么＆＃39;对于数据集重要的是，从读者的角度看起来似乎不变。</p><p>   数据集是语义上不可变的，但可以物理变化。您可以添加索引或两个。它可以为Denormalize表提供优化读取访问。数据集可以分区，并且靠近读者的部分。定向列的数据集表示也可能有意义。</p><p> 您可以制作一个表的副本，列较少，以优化快速访问（一个瘦桌）。列值可以留在瘦桌子和脂肪表中。</p><p> 通过观察和监视数据集的读取使用，您可以意识到新的优化（例如，新索引）是可能的。 </p><p>不变性是大数据的骨干。大规模并行计算基于不可变输入和功能计算。 MapReduce 3和Dryad 9都将不可变文件作为输入。将工作切成碎片，每个都具有不变的输入。此功能计算（使用不可变输入）是幂等的，使得可以失败并重新启动。不变性是大数据的骨干。 MapReduce通过不可变数据执行功能计算以创建不可变输出。失败并重新启动，这对于可靠的大数据至关重要，基于功能计算的幂等性质。</p><p>   数据集显示了一个不可变的语义棱镜，即使基础表示是增强或完全替换的。国王詹姆斯圣经是，角色的性格，即使是在不同的字体上印刷;即使在数字化时;即使伴随着不同的图片。</p><p> 如果对新架构表示有没有变换，则数据集是更改的吗？新地址字段是否可以具有更多容量？枚举值是否可以映射到新的底层表示？数据是否可以从UTF-8映射到UTF-16编码？</p><p> 具有正确的位是不够的。你必须知道如何解释它们。例如，＆＃34;布什总统＆＃34; 1990年的含义不同于2005年。单词＆＃34;餐巾纸＆＃34;在美国和英国被解释不同。</p><p>   创建不可变数据集时，可能不会更改数据的语义。仅内容只能描述它们在创建数据集时。</p><p> 大多数程序员用于SQL DDL（数据定义语言）支持其表的元数据中的动态变化。这发生在交易边界处，并且可以为现有数据规定新的架构。 SQL DDL可以被认为是规范性元数据，因为它是规定表示的（可能会改变）。不可变数据集具有描述性元数据，用于解释有哪些＆＃39;</p><p> 当然，可以创建引用一个或多个现有数据集的新数据集，以便创建其数据的新表示。每个新的数据集都有一个唯一的ID。在其中通过引用实现的数据集而不是按值实现的数据集没有错。 </p><p>标准化的目标是消除更新异常。当数据未以归一化方式存储时，更新可能会产生令人不快的结果。经典榜样是一个不完美的归一下表，其中每个员工都有他或她的经理＆＃39;姓名和电话号码。这使得更新管理员和＃39; S电话号码很难，因为它存储在许多地方。归一化在设计用于更新的数据库中非常重要。</p><p> 然而，在不可变数据集中不需要归一化。正常化不变数据集的唯一原因可能是减少它们所需的存储。另一方面，Denormized数据集可能更容易且更快地处理计算到计算的输入。</p><p>   每个版本都是不可变的。本节首先在多边形并发控制中查看;然后，如LSM在事务空间内提供语义的技术，同时生成描述这些变化状态的不可变数据;最后，它通过母牛的镜头看世界，其中通过编写新的不可变数据来实现高性能更新。</p><p>   版本应该有不可变的名称。除了第一个版本的东西之外，一个新版本捕获了更替换的或增强早期版本的替代。线性版本历史有时被称为强烈一致：一个版本替换另一个版本;有一个父母和一个孩子在那里。每个版本都是不可变的;每个版本都有一个身份。线性版本历史的替代方案是版本历史的DAG（定向非循环图），其中有许多父母和/或许多孩子。这有时被称为最终的一致性。</p><p>   强烈一致，或酸（原子学，一致性，隔离，耐用性），事务显示好像它们以串行顺序运行。这有时被称为序列化。 2</p><p> 数据库按版本更改版本。事务T1是一个版本，稍后的事务T2是一个版本。 TAXTALLELED的记录和索引的新版本和索引在早期版本上更改。新版本可以捕获为整个数据库的快照（虽然这不会导致高性能）。</p><p> 或者，可以将新版本捕获为对以前版本的更改。以这种方式，可以构建密钥值存储，并且可以在键值存储器上构建关系数据库。通过添加Tombstones删除记录。更改数据库是通过向键值存储添加新记录来完成的。 </p><p>如果将时间戳添加到每个新版本中，则可以在给定的时间点显示数据库的状态。这允许用户将数据库的状态导航到任何旧版本。正在进行的工作可以看到数据库版本的稳定快照。</p><p>   LSM在不可变档案上呈现了一个外观的变化。使用LSM树，通过编写新版本的受影响记录来完成对键值存储的15个更改。这些新版本记录到不可变的文件。定期，按键的新版本按键排序，并将其写入称为LSM树中的0个文件的不可变文件。级别0文件合并为级别1级别的集合（通常为10级文件，每个文件，每个文件包含第十个关键范围）。同样，级别1个文件与10到1个文件合并为2级文件。随着LSM树移动，每个级别都有10倍的文件。读取记录通常涉及搜索每个级别的文件。随着LSM文件合并，可以写入具有新标识的新的不可变文件。</p><p>   LSM树可以通过执行牛来创建不可变形的文件。副本的粒度通常是键值对。对于关系数据库，这可以是每个记录或每个索引条目的键值对。将更改复制到日志中，然后复制到LSM树（并为合并复制几次）。</p><p> 高性能牛与日志和经典的DBMS性能技术发生。新版本在内存中捕获并记录以进行故障恢复。每个日志文件的标识是唯一ID，日志文件是不可变的。每个新日志文件都可以记录其前面的日志文件的历史记录，甚至是即将到来的日志文件的标识。有一个最近的日志文件ID表示可以重建整个LSM键值存储。</p><p>   许多文件系统都会保留由不可变块组成的不可变文件。本节探讨了高水平的GFS和HDF的实现以及可以使用这些文件完成的内容的影响。它讨论了可以重命名的文件的变幻莫测，并考虑在一致的哈希商店中存储不可变数据的值。</p><p>   通过不变性改变更改的早期示例是对数结构的文件系统。 16在这本精彩的发明中，文件系统写入总是附加到循环缓冲区的末尾。偶尔，要重建文件系统的足够重建的元数据被添加到循环缓冲区。必须向前复制旧数据，以便未被覆盖。</p><p> 日志结构的文件系统具有一些有趣的性能特征，既好又坏。今天他们是一个重要的技术。随着技术趋势在近年来的方向上继续移动，它们将变得更加重要。 </p><p>GFS，5个HDFS，1和其他提供高度可用的文件。每个文件都是一堆块（也称为块）。该文件由文件名和提供交叉流所需的块的描述组成。每个块都在群集中复制以进行耐用性和高可用性。通常在数据中心的不同故障区域上复制三次。</p><p> 每个文件都是不可变的，（通常）单个编写器。创建该文件，一个进程可以附加到它。文件生存了一段时间，并最终删除。多版本很难，GFS对此有一些挑战。 13.</p><p> 不变的文件和不可变块授权此复制。文件系统对完整文件没有更改的概念。每个块＆＃39; s的不可动提器允许它在没有任何更新异常的情况下轻松复制，因为它没有更新。</p><p>   一个不可变的文件具有身份和内容，也不能改变。您可以随时随地复制不可变文件并在任何用户身边分享用户的不可变副本。只要您管理参考计数（所以您知道它何时何时删除它），您可以使用文件的一个副本来分享许多用户。您可以随时随地分发不可变的文件。使用相同的身份和相同的内容，文件是独立的。</p><p>   GFS和HDFS都提供不变的文件。不可变块（块）a</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://queue.acm.org/detail.cfm?id=2884038">https://queue.acm.org/detail.cfm?id=2884038</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/变化/">#变化</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>