<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>偏序和非布尔逻辑 Partial order and non-Boolean logic</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Partial order and non-Boolean logic<br/>偏序和非布尔逻辑 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-27 07:30:11</div><div class="page_narrow text-break page_content"><p>Numbers. Numbers are easy. All you need to know to sort them out is that</p><p>数字。数字很​​容易。您需要了解的所有内容就是</p><p>  ...or both, but if 6 ≤ 6 and 6 ≤ 6 then 6 = 6.</p><p>  ...或两者兼有，但如果6≤6和6≤6，则6 = 6。</p><p>    A   total order, also known as   linear order is a relation “≤” on a set  S. For  a, b, c ∈ S, the three properties hold.</p><p>    总阶（也称为线性阶）是集合S上的关系“≤”。对于a，b，c∈S，这三个属性成立。</p><p>              With rules established for  ≤, we can also tell either  a &lt; b or  a &gt; b or  a = b for every  a and  b.</p><p>              利用为≤建立的规则，我们还可以告诉＆lt; b或＆gt; b或a = b对于每个a和b。</p><p>        Real numbers are comparable. That implies that you can sort them. Of course, not only numbers are comparable. Names are comparable and sortable in alphabetical order. Skyscrapers are comparable and sortable by height. A lot of things are comparable and sortable.</p><p>        实数是可比的。这意味着您可以对它们进行排序。当然，不仅数字是可比的。名称是可比较的，并且可以按字母顺序排序。摩天大楼具有可比性，可以按高度排序。很多事情都是可比的和可排序的。</p><p>  But a few things aren&#39;t. Like the  intervals, we use to represent numbers with errors. We use them when we don&#39;t know the exact number  x but we know its error  ε and therefore have all the reasons to believe that it&#39;s jammed somewhere between  x 1 and  x 2 where</p><p>  但是有些事情不是。像间隔一样，我们用来表示有错误的数字。当我们不知道确切的数x但知道它的误差ε时，便使用它们，因此有所有理由相信它卡在x 1和x 2之间，其中</p><p>    These intervals are helpful when we want to measure a computational error of some calculation or to see if some algorithm is stable enough. They aren&#39;t comparable or truly sortable though.</p><p>    当我们要测量某些计算的计算误差或查看某种算法是否足够稳定时，这些间隔非常有用。它们不是可比的或真正可排序的。 </p><p>  Consider two overlapping intervals. Let&#39;s say,  [3, 6] and  [5, 8]. We know that the fist interval actually means a number between  3 and  6. The second — another number between  5 and  8. Intuitively, the latter should be greater than the former. But what if it is  5 and the former is  6? Then it&#39;s obviously less. There is a chance they are even equal.</p><p>考虑两个重叠的间隔。假设[3，6]和[5，8]。我们知道，拳头间隔实际上是3到6之间的数字。第二个是5到8之间的另一个数字。从直觉上讲，后者应该大于前者。但是如果它是5而前者是6怎么办？然后显然更少了。他们甚至有机会平等。</p><p>  So there is some kind of order, for instance,  [6, 8] is definitely greater than  [3, 5]. But this order doesn&#39;t hold for every possible pair of intervals.</p><p>  因此存在某种顺序，例如[6，8]绝对大于[3，5]。但是此顺序并不适用于所有可能的间隔对。</p><p>  This makes things unpleasant. For the very least, we can&#39;t now use binary logic since all the comparisons now return three states. E. g.  a ≤ b can now be  true,  false or  none of the above.</p><p>  这使事情变得不愉快。至少，现在我们不能使用二进制逻辑，因为所有比较现在都返回三种状态。例如a≤b现在可以为true，false或以上都不是。</p><p>  Consequently, this means the conventional  if... else statement now has to be redesigned. And all the algorithms that use it.</p><p>  因此，这意味着现在必须重新设计常规的if ... else语句。以及所有使用它的算法。</p><p>  We wouldn&#39;t have to give up binary logic completely if we agree to “split” the semantics of the predicates into two. For every predicate on the two intervals, we can still say whether the numbers they represent definitely suffice the predicate, or whether they possibly do so.</p><p>  如果我们同意将谓词的语义“拆分”为两个，就不必完全放弃二进制逻辑。对于两个间隔上的每个谓词，我们仍然可以说它们所代表的数字确实足以满足该谓词，或者它们是否可以满足要求。</p><p>  For instance,  [3, 5] is definitely less than  [6, 8], and  [3, 6] is possibly less than  [5, 8]. The most unpleasant case for us is when intervals overlap. Everything is indefinite, and everything is possible then.</p><p>  例如，[3，5]绝对小于[6，8]，[3，6]可能小于[5，8]。对于我们来说，最不愉快的情况是间隔重叠。一切都是不确定的，然后一切皆有可能。</p><p>         Still, every  if... else works. Within its semantics that is. However, the algebra behind the logic isn&#39;t yet Boolean. Now  ¬ (a &lt; b) &amp;nequiv a ≥ b. Computational algorithms may be technically built using the same building blocks as if the intervals were numbers but that&#39;s it.</p><p>         不过，其他所有方法都可以。在其语义内。但是，逻辑背后的代数还不是布尔值。现在¬（a＆lt; b）＆nequiv a≥b。从技术上讲，可以使用相同的构建块来构建计算算法，就好像间隔是数字一样，仅此而已。 </p><p>  Speaking of building stuff. Let&#39;s talk about programming. Programming non-Boolean interval logic in C++ or Python is fairly easy. You have to reimplement every predicate for the interval type — and you&#39;re golden!</p><p>说到建筑的东西。让我们谈谈编程。用C ++或Python编程非布尔间隔逻辑非常容易。您必须重新实现间隔类型的每个谓词，并且您很高兴！</p><p>  struct Interval { Number lb; // lower bound Number ub; // upper bound}// Interval-specific predicates.bool coincide(const Interval&amp; l, const Interval&amp; r){ return l.lb == r.lb &amp;&amp; l.ub == r.ub;}bool intersect(const Interval&amp; l, const Interval&amp; r){ return (l.ub &gt;= r.lb &amp;&amp; l.lb &lt;= r.ub) || (r.ub &gt;= l.lb &amp;&amp; r.lb &lt;= l.ub);}// The &#34;definite&#34; interval logic.// The relation should keep for every number in l and in r.bool operator==(const Interval&amp; l, const Interval&amp; r){ return l.lb == l.ub &amp;&amp; coincide(l, r);}bool operator&lt;(const Interval&amp; l, const Interval&amp; r){ return l.ub &lt; r.lb;}bool operator&gt;(const Interval&amp; l, const Interval&amp; r){ return r &lt; l;}bool operator&lt;=(const Interval&amp; l, const Interval&amp; r){ return l.lb &lt; r.ub &amp;&amp; l.ub == r.lb;}bool operator&gt;=(const Interval&amp; l, const Interval&amp; r){ return r &lt;= l;}bool operator!=(const Interval&amp; l, const Interval&amp; r){ return r &lt; l || l &lt; r;}</p><p>  struct Interval {Number lb; //下限数字ub; //上限} //特定于间隔的谓词。bool巧合（const Interval＆l，const Interval＆r）{return l.lb == r.lb＆amp; l.ub == r.ub;}布尔交叉（const Interval＆l，const Interval＆r）{return（l.ub＆gt; = r.lb＆amp;＆l.lb＆lt; = r.ub）| | （r.ub＆gt; = l.lb＆amp; r.lb＆lt; = l.ub）;} //定界＆＃34;间隔逻辑。//该关系对于l和r.bool中的每个数字都应保持不变。==（const Interval＆l，const Interval＆r）符合（l，r）;}布尔运算符＆lt;（const Interval＆l; const Interval＆amp; r）{return l.ub＆lt; r.lb;}布尔运算符＆gt;（const Interval＆l，const Interval＆amp; r）{return r＆lt; l;} bool operator <=（const Interval＆amp; l，const Interval＆amp; r）{return l.lb＆lt; r.ub＆amp;＆amp; l.ub == r.lb;}布尔运算符＆gt; =（const Interval＆l，const Interval＆amp; r）{return r＆lt; = l;} bool运算符！返回r＆lt; l || l ＜ r;}</p><p>  Nobody cares about the relationship between predicates being Boolean-ish. They are all just some arbitrary functions so with them, you can easily define either the “definite” logic or the “possible” one. You can have both if you define them for different but interchangeable types. It&#39;s all a little verbose but doable.</p><p>  没人关心谓词之间是布尔型的关系。它们只是一些任意函数，因此使用它们，您可以轻松定义“确定”逻辑或“可能”逻辑。如果为不同但可互换的类型定义它们，则可以同时具有两者。有点冗长但可行。</p><p>  It gets a little bit more tricky in Rust which relies on the notion of order pretty much.</p><p>  Rust在很大程度上依赖于订单的概念中变得有些棘手。</p><p>  The comparison operators for a custom type are usually introduced using an  std::cmp::Ord trait. It requires that:</p><p>  通常使用std :: cmp :: Ord特性引入自定义类型的比较运算符。它要求：</p><p>  ∀ a, b: (a &lt; b) ⊕ (a = b) ⊕ (a &gt; b) a ≤ b ∧ b ≤ c ⇒ a ≤ c.</p><p>  ∀a，b：（a＆lt; b）⊕（a = b）⊕（a＆gt; b）a≤b∧b≤c⇒a≤c。</p><p>  The first reads as for every  a and  b, one and only one is true: either  (a &lt; b) or  (a = b) or  (a &gt; b). This doesn&#39;t work for us. When intervals intersect, in “definite” logic none of the predicates are true. And in the “possible” logic, they all are.</p><p>  对于每个a和b，第一个读为，只有一个为真：（a＆lt; b）或（a = b）或（a＆gt; b）。这对我们不起作用。当间隔相交时，在“确定”逻辑中，所有谓词都不成立。按照“可能”的逻辑，它们都是。 </p><p>  Luckily, there is another more relaxed trait that represents not total order, but  partial order:  std::cmp::PartialOrd. Which only requires   asymmetry</p><p>幸运的是，还有另一个更为宽松的特征，它代表的不是总顺序，而是部分顺序：std :: cmp :: PartialOrd。 只需要不对称 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://wordsandbuttons.online/partial_order_and_non_boolean_logic.html">https://wordsandbuttons.online/partial_order_and_non_boolean_logic.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/布尔/">#布尔</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/order/">#order</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/间隔/">#间隔</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>