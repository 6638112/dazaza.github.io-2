<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>面向Web的面部ID和触摸ID</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">面向Web的面部ID和触摸ID</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-20 03:24:29</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/64fcd5fbf53eae41f41f9f34f4890df9.png"><img src="http://img2.diglog.com/img/2020/10/64fcd5fbf53eae41f41f9f34f4890df9.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>People often see passwords are the original sin of authentication on the web. Passwords can be easy to guess and vulnerable to breaches. Frequent reuse of the same password across the web makes breaches even more profitable. As passwords are made stronger and unique, they can quickly become unusable for many users. Passwords indeed look notorious, but are passwords themselves the problem, or is it their use as a sole factor for authentication?</p><p>人们经常看到密码是网络身份验证的原罪。密码很容易被猜中，很容易被攻破。在网络上频繁重复使用相同的密码会让入侵变得更加有利可图。随着密码变得更强、更独特，它们可能很快就会对许多用户变得不可用。密码看起来确实臭名昭著，但密码本身是问题所在，还是将其用作身份验证的唯一因素？</p><p> Many believe the latter, and thus  multi-factor authentication has become more and more popular. The introduction of a second factor does fix most of the security issues with passwords, but it inevitably makes the whole authentication experience cumbersome with an additional step. Therefore, multi-factor authentication has not become the de facto authentication mechanism on the web. Face ID and Touch ID for the web provides both the security guarantees of multi-factor authentication and ease of use. It offers multi-factor authentication in a single step. Using this technology, available on over a billion capable Apple devices, web developers can now broadly offer traditional multi-factor authentication with a smooth, convenient experience. And being built on top of the  Web Authentication API makes Face ID and Touch ID phishing resistant as well.</p><p>许多人相信后者，因此多因素身份验证变得越来越流行。引入第二个因素确实解决了密码的大部分安全问题，但它不可避免地会通过额外的步骤使整个身份验证体验变得繁琐。因此，多因素认证并没有成为网络上事实上的认证机制。Face ID和Touch ID for Web提供了多因素身份验证的安全保证和易用性。它在单个步骤中提供多因素身份验证。使用这项在超过10亿台苹果设备上可用的技术，网络开发人员现在可以广泛地提供传统的多因素身份验证，并提供流畅、方便的体验。而建立在网络身份验证API之上的Face ID和Touch ID也可以抵抗网络钓鱼。</p><p> This blog post extends the content of   WWDC 2020 “Meet Face ID and Touch ID for the web” session by providing detailed examples to assist developers’ adoption of this new technology, including how to manage different user agent user interfaces, how to propagate user gestures from user-activated events to WebAuthn API calls, and how to interpret Apple Anonymous Attestation. This article will end by summarizing the unique characteristics of Apple’s platform authenticator and the current status of security key support. If you haven’t heard about WebAuthn before, you’re strongly encouraged to first watch the  WWDC 2020 session, which covers the basic concepts. Otherwise, please enjoy.</p><p>这篇博客文章扩展了WWDC 2020“Meet Face ID and Touch ID for the Web”会议的内容，提供了详细的示例来帮助开发人员采用这项新技术，包括如何管理不同的用户代理用户界面、如何将用户手势从用户激活的事件传播到WebAuthn API调用，以及如何解释Apple匿名证明。本文最后将总结苹果平台认证器的独特特点和安全密钥支持现状。如果您以前没有听说过WebAuthn，强烈建议您首先观看WWDC 2020会议，该会议涵盖了基本概念。不然的话，请慢用。</p><p>  Although user agents are not required to offer UI guidance to users during WebAuthn flows, the reality is that all of them do. This allows user agents to share some of the burden from websites to manage the user experience, but it creates another complexity for websites as each user agent has a different way of presenting the WebAuthn ceremony in its UI. A WebAuthn ceremony could either be the authentication process or the registration process. This section presents how WebAuthn ceremony options map to WebKit/Safari’s UI and the recommended user experience for Face ID and Touch ID for the web.</p><p>虽然在WebAuthn流期间不需要用户代理向用户提供UI指导，但实际上所有用户代理都需要这样做。这允许用户代理分担来自网站的一些管理用户体验的负担，但它给网站带来了另一个复杂性，因为每个用户代理在其UI中呈现WebAuthn仪式的方式不同。WebAuthn仪式可以是认证过程，也可以是注册过程。本节介绍WebAuthn仪式选项如何映射到WebKit/Safari的UI，以及推荐的用于Web的Face ID和Touch ID的用户体验。</p><p> One challenge is to manage different user experiences among the platform authenticator and security keys. Although the WebAuthn API allows presenting both options to the user simultaneously, it’s not the best approach. First, most users are probably only familiar with the branding of the platform authenticator, i.e., Face ID and Touch ID on Apple’s platforms, but are unfamiliar with security keys. Offering both at the same time can confuse users and make it difficult for them to decide what to do. Secondly, the platform authenticator has different behaviors and use cases from security keys. For example, Face ID and Touch ID are suitable for use as a more convenient, alternative mechanism to sign in when most security keys are not. And credentials stored in security keys can often be used across different devices and platforms while those stored in the platform authenticator are typically tied to a platform and a device. Therefore, it is better to present these two options to the user separately.</p><p>一个挑战是管理平台验证器和安全密钥之间的不同用户体验。虽然WebAuthn API允许同时向用户呈现这两个选项，但这不是最好的方法。首先，大多数用户可能只熟悉平台认证器的品牌，即苹果平台上的Face ID和Touch ID，但对安全密钥并不熟悉。同时提供这两种服务可能会让用户感到困惑，并使他们很难决定要做什么。其次，平台认证器与安全密钥具有不同的行为和用例。例如，Face ID和Touch ID适合在大多数安全密钥不是的情况下作为一种更方便的替代登录机制使用。并且存储在安全密钥中的凭证通常可以跨不同的设备和平台使用，而存储在平台认证器中的凭证通常绑定到平台和设备。因此，最好将这两个选项分别呈现给用户。</p><p>  What follows is the recommended way to invoke Face ID and Touch ID for the web. Below is the corresponding Safari UI for registration ceremonies. Here, the Relying Party ID is picked to be displayed in the dialog.</p><p>以下是为Web调用Face ID和Touch ID的推荐方式。下面是用于注册仪式的对应Safari用户界面。在这里，选择要在对话框中显示的依赖方ID。</p><p>   const  options  = {  publicKey : {  rp : {  name :  &#34;example.com&#34; },  user : {  name :  &#34;john.appleseed@example.com&#34;,  id :  userIdBuffer,  displayName :  &#34;John Appleseed&#34; },  pubKeyCredParams : [ {  type :  &#34;public-key&#34;,  alg :  - 7 } ],  challenge :  challengeBuffer,  authenticatorSelection : {  authenticatorAttachment :  &#34;platform&#34; } }}; const  publicKeyCredential  =  await  navigator. credentials. create( options);</p><p>常量选项={public Key：{Rp：{name：&#34；example.com&#34；}，用户：{name：&#34；john.appleseed@example.com&#34；，id：userIdBuffer，displayName：&#34；John Appleseed&#34；}，pubKeyCredParams：[{type：&#34；public-key&#34；，alg：-7}]，challengeBuffer，AuthenticatorSelection：{AuthenticatorAttach：&#34；Platform&#34；}；const public KeyCredential=等待导航器。全权证书。创建(选项)；</p><p> The essential option is to specify  authenticatorSelection: { authenticatorAttachment: &#34;platform&#34; } , which tells WebKit to only invoke the platform authenticator. After the publicKeyCredential is returned, one of the best practices is to store the Credential ID in a server-set, secure, httpOnly cookie, and mark its transport as  &#34;internal&#34;. This cookie can then be used to improve the user experience of future authentication ceremonies.</p><p>基本选项是指定AuthenticatorSelection：{AuthenticatorAttach：&#34；Platform&#34；}，它告诉WebKit只调用平台验证器。在返回public KeyCredential之后，最佳实践之一是将凭据ID存储在服务器集的安全httpOnly cookie中，并将其传输标记为&#34；内部&#34；。然后，此cookie可用于改善未来身份验证仪式的用户体验。</p><p> To protect users from tracking, the WebAuthn API doesn’t allow websites to query the existence of credentials on a device. This important privacy feature, however, requires some extra effort for websites to store provisioned Credential IDs in a separate source and query it before the authentication ceremony. The separate source is often on the backend server. This practice works well for security keys given that they can be used across platforms. Unfortunately, it does not work for the platform authenticator as credentials can only be used on the device where they were created. A server-side source cannot tell whether or not a particular platform authenticator indeed preserves a credential. Hence, a cookie is especially useful. This cookie should not be set through the  document.cookie API since Safari’s Intelligent Tracking Prevention caps the expiry of such cookies to seven days. It’s also important to mark those credentials as  &#34;internal&#34; such that websites could supply it in the authentication ceremony options to prevent WebKit from asking users for security keys at the same time.</p><p>为了保护用户免受跟踪，WebAuthn API不允许网站查询设备上是否存在凭据。然而，这一重要的隐私功能需要网站在单独的源中存储提供的凭证ID，并在身份验证仪式之前对其进行查询，这需要付出一些额外的努力。单独的源通常在后端服务器上。考虑到安全密钥可以跨平台使用，这种做法对安全密钥非常有效。遗憾的是，它不适用于平台验证器，因为凭据只能在创建凭据的设备上使用。服务器端源无法判断特定平台验证器是否确实保留了凭证。因此，cookie特别有用。此Cookie不应通过Document.cookie API设置，因为Safari的智能跟踪防御将此类Cookie的有效期限制为七天。将这些凭据标记为内部凭据也很重要，这样网站就可以在身份验证仪式选项中提供凭据，以防止WebKit同时要求用户提供安全密钥。</p><p> Below are two different UIs for authentication ceremonies. The first one is streamlined for the case where the user agent only has a single credential, while the second one shows how the user agent allows the user to select one of many credentials. For both cases, only  user.name submitted in the registration ceremony is selected to display. For the second case, the order of the list is sorted according to the last used date of the credential. WebKit keeps track of the last used date. Websites thus do not need to worry about it.</p><p>下面是用于身份验证仪式的两个不同UI。第一个示例针对用户代理只有一个凭据的情况进行了简化，而第二个示例显示了用户代理如何允许用户从多个凭据中选择一个。对于这两种情况，只选择显示在注册仪式中提交的user.name。对于第二种情况，列表的顺序根据凭证的上次使用日期进行排序。WebKit跟踪上次使用的日期。因此，网站不需要担心这一点。</p><p>    const  options  = {  publicKey : {  challenge :  challengeBuffer,  allowCredentials : [ {  type :  &#34;public-key&#34;,  id :  credentialIdBuffer1,  transports : [ &#34;internal&#34;] },  // ... more Credential IDs can be supplied. ] }}; const  publicKeyCredential  =  await  navigator. credentials. get( options);</p><p>常量选项={public Key：{challengl：challengeBuffer，allowCredentials：[{type：&#34；public-key&#34；，id：redentialIdBuffer1，transports：[&#34；Internal&#34；]}，//...。可以提供更多凭据ID。]}}；const public KeyCredential=等待导航器。全权证书。GET(选项)；</p><p> To be noted, even though an improvement over WebKit can be made such that  transports: [&#34;internal&#34;] is not necessary to prevent WebKit from asking users for security keys as long as all allowed credentials are found within the platform authenticator, it is for the happy path only. In the case where no credentials are found, this extra property can tell WebKit to show an error message instead of asking the user for security keys.</p><p>需要注意的是，尽管可以对WebKit进行改进，以便只要在平台验证器中找到所有允许的凭证，就不需要传输：[&#34；Internal&34；]来防止WebKit要求用户提供安全密钥，但这只适用于愉快的路径。在没有找到凭据的情况下，这个额外的属性可以告诉WebKit显示错误消息，而不是要求用户提供安全密钥。</p><p>  Despite the fact that the following usage is discouraged, WebKit/Safari has prepared dedicated UI to allow the user to select a security key in addition to the platform authenticator. Below is the one for registration ceremonies.</p><p>尽管不鼓励使用以下用法，WebKit/Safari已经准备了专用UI，以允许用户选择除平台验证器之外的安全密钥。下面是注册仪式用的。</p><p>  The above dialog can be obtained by deleting  authenticatorSelection: { authenticatorAttachment: &#34;platform&#34; } from the registration ceremony code snippet above.</p><p>从上面的注册仪式代码片段中删除AuthenticatorSelection：{AuthenticatorAttach：&#34；Platform&#34；}即可获得上述对话框。</p><p>  The above dialog will be shown if any entry in the  allowCredentials array from the authentication ceremony code snippet above doesn’t have the  transports: [&#34;internal&#34;] property.</p><p>如果上面身份验证仪式代码片段中的allowCredentials数组中的任何条目没有transports：[&#34；Internal&#34；]属性，则会显示上面的对话框。</p><p> To be noted, security keys can be used immediately in both cases after the UI is shown. “Use Security Key” and “Account from Security Key” options are there to show instructions of how to interact with security keys.</p><p>需要注意的是，在显示UI之后，这两种情况下都可以立即使用安全密钥。“Use Security Key”和“Account From Security Key”选项用于显示如何与安全密钥交互的说明。</p><p>  allowCredentials is optional for authentication ceremonies. However, omitting it will result in undetermined behavior in WebKit/Safari’s UI. If credentials are found, the authentication ceremony UI above will be shown. If no credentials are found, WebKit will ask the user for their security keys. Therefore, it is highly recommended not to omit this option.</p><p>对于身份验证仪式，allowCredentials是可选的。但是，省略它将导致WebKit/Safari的UI中出现不确定的行为。如果找到凭据，将显示上面的身份验证仪式UI。如果找不到凭据，WebKit将要求用户提供其安全密钥。因此，强烈建议不要省略此选项。</p><p>  Unsolicited permission prompts are annoying. Mozilla has conducted surveys [ 1,  2] that verify this. Even though WebAuthn prompts are not as often seen on the web as notification prompts today, this situation will change with the release of Face ID and Touch ID for the web.</p><p>未经请求的权限提示令人讨厌。Mozilla已经进行了调查[1，2]来验证这一点。尽管WebAuthn提示不像今天的通知提示那样经常出现在网络上，但随着Face ID和Touch ID for Web的发布，这种情况将会改变。</p><p> Websites don’t ask for notification permission for fun. They ask because notifications can bring users back to their sites and increase their daily active users metric. A similar financial incentive could be found with WebAuthn prompts especially when platform authenticators are available as a fulfilled authentication request results in a high fidelity, persistent unique identifier of the user. This is a universal truth about authentication and that is why many sites ask for it before users even interact with the site. Though it is inevitable that WebAuthn credential will be leveraged to serve targeted ads to users, at least a similar protection that Mozilla did in Firefox for notification permission prompts can be utilized to make those WebAuthn prompts less annoying to users, which is to require user gestures for the WebAuthn API to eliminate annoying ‘on load’ prompts.</p><p>网站不会为了好玩而要求通知许可。他们这样问是因为通知可以将用户带回他们的网站，并增加他们的日活跃用户指标。在WebAuthn提示中可以找到类似的经济激励，特别是当平台认证器可用时，因为履行的认证请求导致用户的高保真、持久的唯一标识符。这是关于身份验证的普遍真理，这就是为什么许多站点甚至在用户与站点交互之前就要求提供它。虽然WebAuthn凭据将不可避免地被利用来向用户提供定向广告，但至少可以利用Mozilla在Firefox中为通知权限提示所做的类似保护，以减少这些WebAuthn提示对用户的烦扰，即要求WebAuthn API的用户手势来消除恼人的“加载”提示。</p><p> We foresaw this problem some time ago and filed an  issue on the WebAuthn specification, but it didn’t get much traction back then. One reason is that it is a breaking change. Another reason is that the risk is not as high with security keys since they are not that popular and not always attached to the platform. The amount of unsolicited prompts has been surprisingly low. The situation is different with the release of Face ID and Touch ID for the web. So, Face ID and Touch ID for the web require user gestures to function. (User gestures are not required for security keys for backward compatibility.)</p><p>我们在一段时间前就预见到了这个问题，并在WebAuthn规范上提交了一个问题，但当时并没有得到太多关注。原因之一是这是一个突破性的变化。另一个原因是，安全密钥的风险不是很高，因为它们不是那么受欢迎，并且并不总是附着在平台上。不请自来的提示量令人惊讶地低。这种情况随着Face ID和Touch ID for Web的发布而有所不同。因此，网页的Face ID和Touch ID需要用户手势才能运行。(为了向后兼容，安全密钥不需要用户手势。)。</p><p> A  user gesture is an indicator to signal WebKit that the execution of the current JavaScript context is a direct result of a user interaction, or more precisely from a handler for a user activated event, such as a  touchend,  click,  doubleclick, or  keydown event [ 3]. Requiring user gestures for the WebAuthn API means API calls must happen within the above JavaScript context. Normally, the user gesture will not be propagated to any async executors within the context. Since it is popular for websites to fetch a challenge asynchronously from a server right before invoking WebAuthn API, WebKit allows WebAuthn API to accept user gestures propagated through XHR events and the Fetch API. Here are examples of how websites can invoke Face ID and Touch ID for the web from user activated events.</p><p>用户手势是通知WebKit当前JavaScript上下文的执行是用户交互的直接结果的指示器，或者更准确地说，来自用户激活事件的处理程序，例如TouchEnd、Click、DoubleClick或Keydown事件[3]。WebAuthn API需要用户手势意味着API调用必须在上面的JavaScript上下文中进行。通常，用户手势不会传播到上下文中的任何异步执行器。由于网站通常在调用WebAuthn API之前从服务器异步获取质询，因此WebKit允许WebAuthn API接受通过XHR事件和Fetch API传播的用户手势。以下是网站如何从用户激活的事件调用Web的Face ID和Touch ID的示例。</p><p>  // Fetching the challengeBuffer before the onclick event. button. addEventListener( &#34;click&#34;,  async ()  = &gt; {  const  options  = {  publicKey : { ...  challenge :  challengeBuffer, ... } };  const  publicKeyCredential  =  await  navigator. credentials. create( options);});</p><p>//在onClick事件之前获取challengeBuffer。纽扣。AddEventListener(&#34；单击&#34；，async()=&gt；{常量选项={public Key：{...。Challenges：challengeBuffer，...}}；const public KeyCredential=等待导航器。全权证书。创建(选项)；})；</p><p>  button. addEventListener( &#34;click&#34;, ()  = &gt; {  const  xhr  =  new  XMLHttpRequest();  xhr. onreadystatechange  =  async  function() {  if ( this. readyState  = =  4  &amp; &amp;  this. status  = =  200) {  const  challenge  =  this. responseText;  const  options  = {  publicKey : { ...  challenge :  hexStringToUint8Array( challenge),  // a custom helper ... } };  const  publicKeyCredential  =  await  navigator. credentials. create( options); } };  xhr. open( &#34;POST&#34;,  &#34;/WebKit/webauthn/challenge&#34;,  true);  xhr. setRequestHeader( &#34;Content-type&#34;,  &#34;application/x-www-form-urlencoded&#34;);  xhr. send();});</p><p>纽扣。AddEventListener(&#34；click&#34；，()=&gt；{const xhr=new XMLHttpRequest()；xhr。Onreadystatechange=异步函数(){if(this.。ReadyState==4&amp；&amp；this。状态==200){常量质询=此。响应文本；常量选项={public Key：{...。质询：heStringToUint8Array(质询)，//a自定义帮助器...}}；const public KeyCredential=等待导航器。全权证书。创建(选项)；}}；xhr。Open(&#34；post&#34；，&#34；/webkit/webauthn/challengl&#34；，true)；xhr。SetRequestHeader(&#34；Content-type&#34；，&#34；application/x-www-form-urlencode&#34；)；xhr。Send()；})；</p><p>  button. addEventListener( &#34;click&#34;,  async ()  = &gt; {  const  response  =  await  fetch( &#34;/WebKit/webauthn/challenge&#34;, {  method :  &#34;POST&#34; });  const  challenge  =  await  response. text();  const  options  = {  publicKey : { ...  challenge :  hexStringToUint8Array( challenge),  // a custom helper ... } };  const  publicKeyCredential  =  await  navigator. credentials. create( options);});</p><p>纽扣。AddEventListener(&#34；click&#34；，async()=&gt；{const response=等待获取(&#34；/webkit/webauthn/challengl&#34；，{method：&#34；post&#34；})；const challenges=等待响应。Text()；常量选项={public Key：{...。质询：heStringToUint8Array(质询)，//a自定义帮助器...}}；const public KeyCredential=等待导航器。全权证书。创建(选项)；})；</p><p> To be noted, readable streams cannot propagate user gestures yet (related  bug). Also, the user gesture will expire after 10 seconds for both XHR events and Fetch API.</p><p>需要注意的是，可读流还不能传播用户手势(相关错误)。此外，对于XHR事件和FETCH API，用户手势都将在10秒后过期。</p><p>  button. addEventListener( &#34;click&#34;, ()  = &gt; {  setTimeout( async ()  = &gt; {  const  options  = { ... };  const  publicKeyCredential  =  await  navigator. credentials. create( options); },  500);});</p><p>纽扣。AddEventListener(&#34；单击&#34；，()=&gt；{setTimeout(async()=&gt；{const options={...}；const public KeyCredential=等待导航器。全权证书。创建(选项)；}，500)；})；</p><p>  On iOS 14, iPadOS 14 and macOS Big Sur Beta Seed 1, only the very first case is supported. Thanks to early feedback from developers, we were able to identify limitations and add the later cases. This also helped us recognize that user gestures are not a well understood concept among web developers. Therefore, we are going to contribute to the HTML specification and help establish a well established concept of a user gesture for consistency among browser vendors. Depending on how it goes, we might reconsider expanding the user gesture requirement to security keys.</p><p>在iOS 14、iPadOS 14和MacOS Big Sur Beta Seed 1上，只支持第一种情况。多亏了开发人员的早期反馈，我们能够识别限制并添加后来的案例。这也帮助我们认识到，用户手势在Web开发人员中并不是一个很好理解的概念。因此，我们将为HTML规范做出贡献，并帮助建立一个良好的用户手势概念，以保持浏览器供应商之间的一致性。根据进展情况，我们可能会重新考虑将用户手势要求扩展到安全密钥。</p><p>  Attestation is an optional feature which provides websites a cryptographic proof of the authenticator’s provenance such that websites that are restricted by special regulations can make a trust decision. Face ID and Touch ID for the web offers Apple Anonymous Attestation. Once verified, this attestation guarantees that an authentic Apple device performed the WebAuthn registration ceremony, but it does not guarantee the operating system running on that device is untampered. If the operating system is untampered, it also guarantees that the private key of the just generated credential is protected by the  Secure Enclave and the usage of the private key is guarded with Face ID or Touch ID. (A note: the guard falls back to device passcode if biometric fails multiple times in a row.)</p><p>认证是一项可选功能，它为网站提供验证者出处的加密证明，以便受特殊规定限制的网站可以做出信任决定。面向网络的Face ID和Touch ID提供Apple匿名认证。一旦经过验证，此证明可保证执行WebAuthn注册仪式的是真实的Apple设备，但不能保证该设备上运行的操作系统未被篡改。如果操作系统未被篡改，它还保证刚刚生成的凭证的私钥受到安全飞地的保护，并且私钥的使用受到Face ID或Touch ID的保护。(注意：如果生物识别连续多次失败，则防护退回到设备密码。)。</p><p> Apple Anonymous Attestation is first of its kind, providing a service like an  Anonymization CA, where the authenticator works with a cloud operated CA owned by its manufacturer to dynamically generate per-credential attestation certificates such that no identification information of the authenticator will be revealed to websites in the attestation statement. Furthermore, among data relevant to the registration ceremony, only the public key of the credential along with a hash of the concatenated authenticator data and client data are sent to the CA for attestation, and the CA will not store any of these. This approach makes the whole attestation process privacy preserving. In addition, this approach avoids the security pitfall of  Basic Attestation that the compromising of a single device results in revoking certificates from all devices with the same attestation certificate.</p><p>Apple匿名认证是此类认证中的第一个，提供类似于匿名CA的服务，其中认证者与其制造商拥有的云操作的CA合作，动态生成每个凭证的认证证书，以便认证声明中不会向网站泄露认证者的身份信息。此外，在与注册仪式相关的数据中，只有凭证的公钥连同串联的认证器数据和客户端数据的散列被发送到CA进行认证，并且CA不会存储这些数据中的任何一个。这种方式使得整个认证过程的私密性得以保护。此外，此方法避免了基本证明的安全缺陷，即单个设备的危害会导致使用相同证明证书的所有设备的证书被吊销。</p><p>  const  options  = {  publicKey : { ...  attestation :  &#34;direct&#34;,  // the essential option ... }}; const  publicKeyCredential  =  await  navigator. credentials. create( options);</p><p>常量选项={public Key：{...。证明：&#34；direct&#34；，//基本选项...}}；const public KeyCredential=等待导航器。全权证书。创建(选项)；</p><p>  This is the definition of the Apple Anonymous Attestation statement format.  Issue 1453 is tracking the progress of adding this statement format to the WebAuthn standard.</p><p>这是Apple匿名证明声明格式的定义。问题1453正在跟踪将此语句格式添加到WebAuthn标准的进度。</p><p> $$attStmtType //= ( fmt: &#34;apple&#34;, attStmt: appleStmtFormat )appleStmtFormat = { x5c: [ credCert: bytes, * (caCert: bytes) ] }</p><p>$$attStmtType//=(fmt：&#34；apple&#34；，attStmt：appleStmtFormat)appleStmtFormat={x5c：[redCert：Bytes，*(caCert：Bytes)]}</p><p> The semantics of the above fields are as follows:  x5c   credCert followed by its certificate chain, each encoded in X.509 format.  credCert The credential public key certificate used for attestation, encoded in X.509 format.</p><p>上述字段的语义如下：X5C CredCert后跟其证书链，每个证书链都以X.509格式编码。CredCert用于证明的凭据公钥证书，以X.509格式编码。</p><p>  Verify that  attStmt is valid CBOR conforming to the syntax defined above and perform CBOR decoding on it to extract the contained fields.</p><p>验证attStmt是符合上面定义的语法的有效CBOR，并对其执行CBOR解码以提取包含的字段。</p><p>   Verify  nonce matches the value of the extension with OID ( 1.2.840.113635.100.8.2 ) in  credCert. The  nonce here is used to prove that the attestation is live and to protect the integrity of the  authenticatorData and the client data.</p><p>验证NONCE是否与CredCert中具有OID(1.2.840.113635.100.8.2)的扩展名的值匹配。这里的随机数用于证明证明是有效的，并保护AuthenticatorData和客户端数据的完整性。</p><p>  If successful, return implementation-specific values representing attestation type Anonymous CA and attestation trust path  x5c.</p><p>如果成功，则返回表示证明类型匿名CA和证明信任路径x5c的实现特定值。</p><p> The final step is to verify  x5c is a valid certificate chain starting from the  credCert to the  Apple WebAuthn root certificate, which then proves the attestation. (This step is usually shared among different types of attestations that utilize  x5c [ 4].) To be noted, the AAGUID is all zeros even if the attestation is enabled as all Apple devices that support Face ID and Touch ID for the web should have the same properties as explained at the beginning of this section and no other devices can request Apple Anonymous Attestation.</p><p>最后一步是验证x5c是从redCert到Apple WebAuthn根证书的有效证书链，然后证明证明。(此步骤通常由利用x5c[4]的不同类型的证明共享。)。需要注意的是，即使启用了证明，AAGUID也是全零的，因为所有支持Web的Face ID和Touch ID的Apple设备都应具有本节开头说明的相同属性，并且任何其他设备都不能请求Apple匿名证明。</p><p>  Here is a summary about unique characteristics of Apple’s platform authenticator, i.e., Face ID and Touch ID for the web.</p><p>以下是关于苹果平台认证器的独特特性的总结，即用于网络的Face ID和Touch ID。</p><p> Face ID and Touch ID for the web is available in Safari, SFSafariViewController and ASWebAuthenticationSession on iOS 14, iPadOS 14 and macOS Big Sur. For macOS, Safari 14 with downlevel OS will not get this feature because the attestation relies on a new system framework.</p><p>在iOS 14、iPadOS 14和MacOS Big Sur上的Safari、SFSafariViewController和ASWebAuthenticationSession中提供了用于Web的Face ID和Touch ID。对于MacOS，带有下层操作系统的Safari 14将不会获得此功能，因为证明依赖于新的系统框架。</p><p> All public key credentials generated by the platform authenticator are resident keys regardless of what option is specified.</p><p>无论指定哪个选项，平台验证器生成的所有公钥凭据都是驻留密钥。</p><p> Credentials can only be cleared for all via Safari &gt; History &gt; Clear History… on Mac Safari or Settings &gt; Safari &gt; Clear History and Website Data on iOS &amp; iPadOS.</p><p>只能通过Safari&&gt;历史&&gt;清除历史…清除所有凭据。在Mac Safari或设置&gt；Safari&gt；清除iOS&amp；iPadOS的历史记录和网站数据。</p><p> The signature counter is not implemented and therefore it is always zero. Secure Enclave is used to prevent the credential private key from leaking instead of a software safeguard.</p><p>签名计数器未实现，因此始终为零。Secure Enclave用于防止凭证私钥泄露，而不是软件保护。</p><p>  Besides the introduction of Face ID and Touch ID for the web, iOS 14, iPadOS 14 and Safari 14 on all supported macOS also have improved security key support including PIN entry and account selection. Here is a list of features that are currently supported. All of them have been supported since iOS 13.3, iPadOS 13.3 and Safari 13 except the two aforementioned.</p><p>除了为网络引入Face ID和Touch ID之外，所有支持的MacOS上的iOS 14、iPadOS 14和Safari 14还改进了对安全密钥的支持，包括PIN输入和账户选择。以下是当前支持的功能列表。从iOS13.3、iPadOS13.3和Safari13开始，除了前面提到的两个之外，所有这些都得到了支持。</p><p> All MUST features in WebAuthn Level 1 and all optional features except CollectedClientData.tokenBinding and most of the extensions. Only the appid extension is supported.</p><p>WebAuthn级别1中的所有必须功能以及除CollectedClientData.tokenBinding和大多数扩展之外的所有可选功能。目前仅支持APPID扩展名。</p><p>    Like Face ID and Touch ID for the web, security key support is available in Safari, SFSafariViewController and ASWebAuthenticationSession.</p><p>与Web的Face ID和Touch ID一样，Safari、SFSafariViewController和ASWebAuthenticationSession也提供安全密钥支持。</p><p>  In this blog post, we introduced Face ID and Touch ID for the web. We believe it is a huge leap forward for authentication on the web. It serves as a great alternative way to sign in, especially for traditional multi-factor authentication mechanisms. With the assistance of this technology, we believe multi-factor authentication will replace sole-factor password as the de facto authentication mechanism on the web. Developers, please start testing this feature today and let us know how it works for you by sending feedback on Twitter ( @webkit,  @alanwaketan,  @jonathandavis) or by  filing a bug.</p><p>在这篇博客文章中，我们介绍了用于网络的Face ID和Touch ID。我们相信这是网络身份验证的一次巨大飞跃。它是一种很好的登录方式，特别是对于传统的多因素身份验证机制。在这项技术的帮助下，我们相信多因素身份验证将取代单一因素密码成为事实上的Web身份验证机制。开发者们，请今天就开始测试这一功能，并通过在Twitter(@webkit，@alanwaketan，@jonathandavis)上发送反馈或提交错误来让我们知道它是如何为您工作的。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://webkit.org/blog/11312/meet-face-id-and-touch-id-for-the-web/">https://webkit.org/blog/11312/meet-face-id-and-touch-id-for-the-web/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/面向/">#面向</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/id/">#id</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>