<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>除非为函数设计函数，否则不要将其用作回调 Don't use functions as callbacks unless they're designed for it</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Don't use functions as callbacks unless they're designed for it<br/>除非为函数设计函数，否则不要将其用作回调 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-06 20:21:02</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/f7f4a0ac06395b6fd7ae5e2f410b8d05.png"><img src="http://img2.diglog.com/img/2021/2/f7f4a0ac06395b6fd7ae5e2f410b8d05.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>// Convert some numbers into human-readable strings: import  { toReadableNumber  }  from  &#39;some-library&#39; ; const readableNumbers  = someNumbers . map (toReadableNumber ) ;</p><p>//将一些数字转换成易于理解的字符串：从＆＃39; some-library＆＃39;中导入{toReadableNumber} ; const visibleNumbers = someNumbers。映射（toReadableNumber）;</p><p>  export  function  toReadableNumber ( num )  {  // Return num as string in a human readable form.  // Eg 10000000 might become &#39;10,000,000&#39; }</p><p>  导出函数toReadableNumber（num）{//以易于理解的形式将num作为字符串返回。 //例如10000000可能会变成＆＃39; 10,000,000＆＃39; }</p><p> Everything works great until  some-library is updated, then everything breaks. But it isn&#39;t  some-library&#39;s fault – they never designed  toReadableNumber to be a callback to  array.map.</p><p> 一切正常，直到更新某些库，然后一切中断。但这并不是某些库的错误–他们从没有将ReadableNumber设计为要对array.map进行回调的方法。</p><p>  // We think of: const readableNumbers  = someNumbers . map (toReadableNumber ) ; // …as being like: const readableNumbers  = someNumbers . map ( ( n )  =&gt;  toReadableNumber (n ) ) ; // …but it&#39;s more like: const readableNumbers  = someNumbers . map ( ( item , index , arr )  =&gt;  toReadableNumber (item , index , arr ) , ) ;</p><p>  //我们想到了：const visibleNumbers = someNumbers。映射（toReadableNumber）; // ...就像：const visibleNumbers = someNumbers。映射（（n）=＆gt; toReadableNumber（n））; //…但它更像是：const visibleNumbers = someNumbers。映射（（item，index，arr）=> toReadableNumber（item，index，arr），）;</p><p> We&#39;re also passing the index of the item in the array, and the array itself to  toReadableNumber. This worked fine at first, because  toReadableNumber only had one parameter, but in the new version:</p><p> 我们还将数组中该项的索引以及数组本身传递给toReadableNumber。最初这很好用，因为toReadableNumber只有一个参数，但是在新版本中：</p><p> export  function  toReadableNumber ( num , base  =  10 )  {  // Return num as string in a human readable form.  // In base 10 by default, but this can be changed. }</p><p> 导出函数toReadableNumber（num，base = 10）{//以易于理解的形式将num作为字符串返回。 //默认情况下以10为基数，但是可以更改。 }</p><p> The developers of  toReadableNumber felt they were making a backwards-compatible change. They added a new parameter, and gave it a default value. However, they didn&#39;t expect that some code would have already been calling the function with three arguments.</p><p> toReadableNumber的开发人员认为他们正在进行向后兼容的更改。他们添加了一个新参数，并为其指定了默认值。但是，他们不希望某些代码已经使用三个参数来调用该函数。 </p><p> toReadableNumber wasn&#39;t designed to be a callback to  array.map, so the safe thing to do is create your own function that  is designed to work with  array.map:</p><p>toReadableNumber并不是被设计为array.map的回调，所以安全的做法是创建自己的函数以用于array.map：</p><p>  And that&#39;s it! The developers of  toReadableNumber can now add parameters without breaking our code.</p><p>  就是这样！ toReadableNumber的开发人员现在可以添加参数而不会破坏我们的代码。</p><p>      This works today because  requestAnimationFrame only does something with the first argument, but that might not be true forever. A extra parameter might be added, and the above code could break in whatever browser ships the updated  requestAnimationFrame.</p><p>      该方法今天有效，因为requestAnimationFrame仅对第一个参数执行某些操作，但可能永远不会正确。可能会添加一个额外的参数，并且在更新的requestAnimationFrame附带的任何浏览器中，以上代码都可能中断。</p><p>   If anyone asks you the result of that in a tech interview, I recommend rolling your eyes and walking out. But anyway, the answer is  [-10, NaN, 2, 6, 12], because   parseInt has a second parameter.</p><p>   如果有人在技术面试中问您这样做的结果，我建议您睁大眼睛然后走开。但是无论如何，答案是[-10，NaN，2，6，12，12]，因为parseInt有第二个参数。</p><p>  Chrome 90 will allow you to use an  AbortSignal to remove an event listener, meaning a single  AbortSignal can be used to remove event listeners,  cancel fetches, and anything else that supports signals:</p><p>  Chrome 90允许您使用AbortSignal删除事件侦听器，这意味着可以使用单个AbortSignal删除事件侦听器，取消提取以及任何支持信号的其他操作：</p><p> const controller  =  new   ( ) ; const  { signal  }  = controller ;el . addEventListener ( &#39;mousemove&#39; , callback ,  { signal  } ) ;el . addEventListener ( &#39;pointermove&#39; , callback ,  { signal  } ) ;el . addEventListener ( &#39;touchmove&#39; , callback ,  { signal  } ) ; // Later, remove all three listeners:controller . abort ( ) ;</p><p> const controller = new（）; const {信号} =控制器； el。 addEventListener（＆＃39; mousemove＆＃39 ;, callback，{signal}）; el。 addEventListener（＆＃39; pointermove＆＃39 ;, callback，{signal}）; el。 addEventListener（＆＃39; touchmove＆＃39;，回调，{信号}）; //稍后，删除所有三个监听器：controller。中止（）;</p><p>      An  AbortController was not designed to be an option object to  addEventListener. It works right now because the only thing   AbortController and the   addEventListener options have in common is the  signal property.</p><p>      AbortController并非旨在作为addEventListener的选项对象。它之所以可以立即执行，是因为AbortController和addEventListener选项唯一的共同点是signal属性。 </p><p> If, say in future,  AbortController gets a  controller.capture(otherController) method, the behaviour of your listeners will change, because  addEventListener will see a truthy value in the  capture property, and  capture is a valid option for  addEventListener.</p><p>如果说将来AbortController获得controller.capture（otherController）方法，则侦听器的行为将发生变化，因为addEventListener将在capture属性中看到真实值，而capture是addEventListener的有效选项。</p><p> As with the callback examples, it&#39;s best to create an object that&#39;s designed to be  addEventListener options:</p><p> 与回调示例一样，最好创建一个设计为addEventListener选项的对象：</p><p> const controller  =  new   ( ) ; const options  =  { signal : controller .signal  } ;el . addEventListener (name , callback , options ) ; // Although I find this pattern easier when multiple things // get the same signal: const  { signal  }  = controller ;el . addEventListener (name , callback ,  { signal  } ) ;</p><p> const controller = new（）; const options = {signal：controller .signal}; el。 addEventListener（名称，回调，选项）; //虽然我发现当多个事物获得相同的信号时，这种模式更容易// const {signal} = controller; el。 addEventListener（名称，回调，{信号}）;</p><p> And that&#39;s it! Watch out for functions being used as callbacks, and objects being used as options, unless they were designed for those purposes. Unfortunately I&#39;m not aware of a linting rule that catches it (edit: looks like there&#39;s  a rule that catches some cases, thanks  James Ross!).</p><p> 就是这样！注意将函数用作回调，将对象用作选项，除非它们是为这些目的而设计的。不幸的是，我不知道有一条规则可以捕捉到它（编辑：看起来有一条规则可以捕捉到某些情况，谢谢詹姆斯·罗斯！）</p><p>  Edit: When I first posted this, it had a little note at the end showing that TypeScript doesn&#39;t prevent this issue, but I still got folks on Twitter telling me to &#34;just use TypeScript&#34;, so let&#39;s look at it in more detail.</p><p>  编辑：当我第一次发布此内容时，它在末尾有一点注释，表明TypeScript不能防止此问题，但是我仍然在Twitter上告诉我＆＃34;只使用TypeScript＆＃34 ;，让我们更详细地了解它。</p><p>       function  toReadableNumber (num ) :  string  {  // Return num as string in a human readable form.  // Eg 10000000 might become &#39;10,000,000&#39;  return  &#39;&#39; ; } const readableNumbers  =  [ 1 ,  2 ,  3 ] . map (toReadableNumber ) ;</p><p>       function toReadableNumber（num）：string {//以易于理解的形式将num作为字符串返回。 //例如10000000可能会变成＆＃39; 10,000,000＆＃39;返回＆＃39;＆＃39; ; } const visibleNumbers = [1,2,3]。映射（toReadableNumber）;</p><p> If  toReadableNumber changed to add a second  string param,  TypeScript would complain, but that isn&#39;t what happened in the example. An additional  number param was added, and this  meets the type constraints.</p><p> 如果toReadableNumber更改为添加第二个字符串参数，则TypeScript会抱怨，但这不是示例中发生的情况。添加了一个附加的数字参数，它满足类型约束。 </p><p> Things get worse with the  requestAnimationFrame example, because this goes wrong after a new version of a  browser is deployed, not when a new version of your  project is deployed. Additionally, TypeScript DOM types tend to lag behind what browsers ship by months.</p><p>使用requestAnimationFrame示例会使情况变得更糟，因为在部署新版本的浏览器后而不是在部署项目的新版本时，这会出错。此外，TypeScript DOM类型往往要落后数月才能发布。</p><p> In my opinion, TypeScript should enforce the number of arguments passed to a callback, just as it does with regular functions. Or at least, there should be an option for this.</p><p> 我认为，TypeScript应该强制传递给回调的参数数量，就像常规函数一样。至少，应该有一个选择。</p><p>  interface    { reverse ? :  boolean ; } function  whatever ( { reverse  =  false  } : Options  =  { } )  {  console . log (reverse ) ; }</p><p>  接口{反向？ ：布尔值; }功能什么（{反向=假}：选项= {}）{控制台。 log（反向）; }</p><p> You could say that TypeScript should warn if the object passed to  whatever has properties other than  reverse. But in this example:</p><p> 您可以说，如果传递给对象的对象具有反向属性之外的其他属性，则TypeScript应该发出警告。但是在这个例子中：</p><p>  …we&#39;re passing an object with properties like  toString,  constructor,  valueOf,  hasOwnProperty etc etc since the object above is an instance of  Object. It seems too restrictive to require that the properties are &#39;own&#39; properties (that isn&#39;t how it works at runtime), but maybe TypeScript could add some allowance for properties that come with  Object.</p><p>  …由于上面的对象是Object的实例，我们正在传递具有诸如toString，构造函数，valueOf，hasOwnProperty等属性的对象。似乎太过严格，无法要求这些属性是“拥有”的。属性（这不是运行时的工作方式），但也许TypeScript可以为Object附带的属性增加一些余地。</p><p> I&#39;m a fan of TypeScript, this blog is built using TypeScript, but it does not solve this problem.</p><p> 我是TypeScript的粉丝，此博客是使用TypeScript构建的，但不能解决此问题。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://jakearchibald.com/2021/function-callback-risks/">https://jakearchibald.com/2021/function-callback-risks/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/functions/">#functions</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>