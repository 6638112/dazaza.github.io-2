<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>编译Lisp：指令编码插曲</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">编译Lisp：指令编码插曲</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-19 13:54:02</div><div class="page_narrow text-break page_content"><p>Welcome back to the Compiling a Lisp series. In this thrilling new update, wewill learn a little bit more about x86-64 instruction encoding instead ofallocating more interesting things on the heap or adding procedure calls.</p><p>欢迎回到编译Lisp系列。在这个激动人心的新更新中，我们将学习更多关于x86-64指令编码的知识，而不是在堆上分配更多有趣的东西或添加过程调用。</p><p> I am writing this interlude because I changed one register in my compiler code( kRbp to  kRsp) and all hell broke loose — the resulting program wascrashing,  rasm2/Cutter were decoding wacky instructions when fed my binary,etc. Over the span of two very interesting but very frustrating hours, Ilearned why I had these problems and how to resolve them. You should learn,too.</p><p>我之所以写这段插曲，是因为我把编译器代码中的一个寄存器(krbp改成了krsp)，所有的地狱都崩溃了-结果程序崩溃了，rasm2/Cutter在给我的二进制文件时解码古怪的指令，等等。在两个非常有趣但非常令人沮丧的小时里，我了解了为什么会有这些问题以及如何解决它们。你也应该学一学。</p><p>   void  Emit_mov_reg_imm32 ( Buffer  * buf ,  Register  dst ,  int32_t  src )  {  Buffer_write8 ( buf ,  kRexPrefix );  Buffer_write8 ( buf ,  0xc7 );  Buffer_write8 ( buf ,  0xc0  +  dst );  Buffer_write32 ( buf ,  src ); }</p><p>Void emit_mov_reg_imm32(buffer*buf，Register dst，int32_t src){buffer_write8(buf，kRexPrefix)；buffer_write8(buf，0xc7)；buffer_write8(buf，0xc0+dst)；buffer_write32(buf，src)；}。</p><p> These functions all purport to encode x86-64 instructions. They do, most of thetime, but they do not tell the whole story. This function is supposed to encodean instruction of the form  mov reg64, imm32. How does it do it? I don’t know!</p><p>这些函数都声称要对x86-64指令进行编码。大多数情况下，他们是这样做的，但他们不会讲述整个故事。此函数假定对mov reg64，imm32格式的指令进行编码。它是怎么做到的？我不知道!。</p><p> They have all these magic numbers in them! What is a  kRexPrefix? Well, it’s 0x48. Does that mean anything to us? No! It gets worse. What are  0xc7 and 0xc0 doing there? Why are we adding  dst to  0xc0? Before this debuggingand reading extravaganza, I could not have told you. Remember how somewhere ina previous post I mentioned I was getting these hex bytes from reading thecompiled output on the Compiler Explorer? Yeah.</p><p>他们里面都有这些神奇的数字！什么是kRexPrefix？嗯，现在是0x48。这对我们有什么意义吗？不！情况变得更糟了。0xc7和0xc0在那里做什么？为什么我们要将DST添加到0xc0？在这场调试和阅读盛会之前，我不可能告诉你。还记得我在上一篇文章中提到的我是如何从Compiler Explorer上读取编译后的输出中获得这些十六进制字节的吗？嗯。</p><p> As it turns out, this is not a robust development strategy, at least withx86-64. It might be okay for some more regular or predictable instruction sets,but not this one.</p><p>事实证明，这不是一个健壮的开发策略，至少对于x86-64是这样。对于一些更规则或更可预测的指令集，它可能是可以的，但不是这个指令集。</p><p>  So where do we go from here? How do we find out how to take these mysticalhexes and incantations to something that better maps to the hardware? Well, weonce again drag  Tom  1 into a debugging session and pullout the big ol’ Intel  Software Developer Manual.</p><p>那么我们接下来要去哪里呢？我们如何找出如何将这些神秘的魔法和咒语带到更好地映射到硬件上的东西上呢？那么，我们再一次将Tom 1拖入调试会话，并调出大号的“英特尔软件开发人员手册”(Intel Software Developer Manual)。</p><p> This is an enormous 26MB, 5000 page manual comprised of four volumes. It’s very intimidating. This is exactly why I didn’t want to pull it out earlierand do this properly from the beginning… but here we are, eventually needingto do it properly.</p><p>这是一本长达26MB、5000页的手册，由四卷组成。这非常吓人。这就是为什么我不想早点把它拔出来，从一开始就正确地做这件事的原因…。但我们到了这里，最终需要做好这件事。</p><p> I will not pretend to understand all of this manual, nor will this post be aguide to the manual. I will just explain what sections and diagrams I founduseful in understanding how this stuff works.</p><p>我不会假装理解这本手册的全部内容，这篇文章也不会成为手册的指南。我将只解释我发现哪些部分和图表对理解这些东西是如何工作有用的。</p><p> I only ever opened Volume 2, the instruction set reference. In that honking2300 page volume are descriptions of every Intel x86-64 instruction and howthey are encoded. The instructions are listed alphabetically and split intosections based on the first letter of each instruction name.</p><p>我只打开过第二卷，指令集参考。在嗡嗡作响2300页中，描述了每条Intelx86-64指令及其编码方式。指令按字母顺序列出，并根据每个指令名的第一个字母拆分集合。</p><p> Let’s take a look at Chapter 3, specifically at the MOV instruction on page  1209. For those following along who do not want to download a massivePDF, this  website has a bunchof the same data in HTML form. Here’s the  page forMOV.</p><p>让我们来看看第3章，特别是第1209页的MOV指令。对于那些不想下载大量PDF的读者，本网站提供了一组HTML格式的相同数据。这是MOV的页面。</p><p> This page has every variant of MOV instruction. There are other instructionsbegin with MOV, like MOVAPD, MOVAPS, etc, but they are different enough thatthey are different instructions.</p><p>此页面包含MOV指令的所有变体。还有其他以MOV开头的指令，如MOVAPD、MOVAPS等，但它们的差异足够大，以至于它们是不同的指令。</p><p>  Opcode, which describes the layout of the bytes in the instruction stream.This describes how we’ll encode instructions.</p><p>操作码，它描述了指令流中字节的布局。它描述了我们将如何对指令进行编码。</p><p>  Instruction, which gives a text-assembly-esque representation of theinstruction. This is useful for figuring out which one we actually want toencode.</p><p>指令，它给出指令的类似文本汇编的表示形式。这对于找出我们实际上想要编码的是哪一个很有用。</p><p>  Op/En, which stands for “Operand Encoding” and as far as I can telldescribes the operand order with a symbol that is explained further in the“Instruction Operand Encoding” table on the following page.</p><p>OP/EN代表“操作数编码”，据我所知，它使用一个符号来描述操作数顺序，下一页的“指令操作数编码”表中将进一步解释该符号。</p><p>  64-Bit Mode, which tells you if the instruction can be used in 64-bit mode(“Valid”) or not (something else, I guess).</p><p>64位模式，它告诉您指令是否可以在64位模式下使用(“有效”)或不可以(我猜是其他模式)。</p><p>  Compat/Leg Mode, which tells you if the instruction can be used in someother mode, which I imagine is 32-bit mode or 16-bit mode. I don’t know. Butit’s not relevant for us.</p><p>Compat/Leg模式，它告诉您指令是否可以在其他模式下使用，我认为是32位模式还是16位模式。我不知道。但这与我们无关。</p><p>  Description, which provides a “plain English” description of the opcode,for some definition of the words “plain” and “English”.</p><p>DESCRIPTION，它提供操作码的“简明英语”描述，用于单词“简明”和“英语”的一些定义。</p><p> Other instructions have slightly different table layouts, so you’ll have towork out what the other columns mean.</p><p>其他说明的表格布局略有不同，因此您必须弄清楚其他列的含义。</p><p> Here’s a preview of some rows from the table, with HTML courtesy of FelixCloutier’s aforementioned web docs:</p><p>下面是表格中一些行的预览，HTML由FelixCloutier前面提到的Web文档提供：</p><p>  If you take a look at the last entry in the table, you’ll see  REX.W + C7 /0id. Does that look familiar? Maybe, if you squint a little?</p><p>如果您查看表中的最后一个条目，您将看到REX.W+C7/0id。这看起来眼熟吗？也许吧，如果你眯着眼睛看一下的话？</p><p> It turns out, that’s the description for encoding the instruction we originallywanted, and had a bad encoder for. Let’s try and figure out how to use this tomake our encoder better. In order to do that, we’ll need to first understand ageneral layout for Intel instructions.</p><p>结果发现，这就是对我们最初想要的指令进行编码的描述，但是它的编码器很糟糕。让我们试着想办法用这个来使我们的编码器做得更好。要做到这一点，我们首先需要了解英特尔指令的一般布局。</p><p>    I found this information at the very beginning of Volume 2, Chapter 2 (page527) in a section called “Instruction format for protected mode, real-addressmode, and virtual-8086 mode”.</p><p>我在第2卷第2章(第527页)的开头部分“保护模式、真实地址模式和虚拟8086模式的指令格式”中找到了这些信息。</p><p> You, like me, may be wondering about the difference between “optional”, “ifrequired”, and “…, or none”. I have no explanation, sorry.</p><p>您可能和我一样想知道“Optional”、“If Required”和“…”之间的区别。，或者一个也没有“。我无法解释，抱歉。</p><p> I’m going to briefly explain each component here, followed up with apiece-by-piece dissection of the particular MOV instruction we want, so we getsome hands-on practice.</p><p>我将在这里简要解释每个组件，然后逐个剖析我们想要的特定MOV指令，这样我们就可以进行一些实践练习。</p><p>  There are a couple kind of instruction prefixes, like REX (Section 2.2.1) andVEX (Section 2.3). We’re going to focus on REX prefixes, since they are neededfor many (most?) x86-64 instructions, and we’re not emitting vectorinstructions.</p><p>有几种指令前缀，如REX(第2.2.1节)和VEX(第2.3节)。我们将重点介绍REX前缀，因为许多人(大多数？)都需要它们。X86-64指令，我们没有发出向量指令。</p><p> The REX prefixes are used to indicate that an instruction, which might normallyrefer to a 32-bit register, should instead refer to a 64-bit register. Alsosome other things but we’re mostly concerned with register sizes.</p><p>REX前缀用于指示通常可能引用32位寄存器的指令应该改为引用64位寄存器。也有一些其他的东西，但是我们最关心的是寄存器的大小。</p><p>  Take a look at Section 2.1.2 (page 529) for a brief explanation of opcodes. Thegist is that the opcode is the  meat of the instruction. It’s what makes a MOVa MOV and not a HALT. The other fields all modify the meaning given by thisfield.</p><p>有关操作码的简要说明，请参阅第2.1.2节(第529页)。其要点是操作码是指令的核心。这是Mova MOV而不是停止的原因。其他字段都会修改此字段所赋予的含义。</p><p>  Take a look at Section 2.1.3 (page 529) for a brief explanation of ModR/M andSIB bytes. The gist is that they encode what register sources and destinationsto use.</p><p>有关ModR/M和SIB字节的简要说明，请参阅第2.1.3节(第529页)。要点是它们对要使用的寄存器源和目标进行编码。</p><p>  Take a look at Section 2.1.4 (page 529) for a brief explanation of displacementand immediate bytes. The gist is that they encode literal numbers used in theinstructions that don’t encode registers or anything.</p><p>有关位移和立即字节的简要说明，请参阅第2.1.4节(第529页)。要点是它们对指令中使用的文字数字进行编码，而不对寄存器或任何东西进行编码。</p><p> If you’re confused, that’s okay. It should maybe get clearer once we get ourhands dirty. Reading all of this information in a vacuum is moderately uselessif it’s your first time dealing with assembly like this, but I included thissection first to help explain how to use the reference.</p><p>如果你糊涂了，没关系。一旦我们把手弄脏了，情况可能会变得更明朗。如果这是您第一次像这样处理汇编，那么在真空中阅读所有这些信息是相当有用的，但我首先包含这一节是为了帮助解释如何使用参考资料。</p><p>  Got all that? Maybe? No? Yeah, me neither. But let’s forge ahead anyway. Here’sthe instruction we’re going to encode:  REX.W + C7 /0 id.</p><p>都拿到了吗？也许吧?。不是吗？是啊，我也是。但不管怎样，让我们继续前进吧。下面是我们要编码的指令：REX.W+C7/0id。</p><p>  First, let’s figure out  REX.W. According to Section 2.2.1, which explains REXprefixes in some detail, there are a couple of different prefixes. There’s ahelpful table (Table 2-4, page 535) documenting them. Here’s a bit diagram withthe same information:</p><p>首先，让我们了解一下REX.W。根据更详细地解释REX前缀的第2.2.1节，有几个不同的前缀。有一个有用的表格(第535页的表2-4)记录了它们。以下是包含相同信息的位图：</p><p>                    0100  W  R  X  B  High bit  Low bit  REX  Bit 3 is the W prefix. If it’s 1, it means the operands are 64 bits. If it’s0, “operand size [is] determined by CS.D”. Not sure what that means.</p><p>0100 W R X B高位低位REX位3是W前缀。如果为1，则表示操作数为64位。如果为0，则“操作数大小[由CS.D确定]”。不确定那是什么意思。</p><p>  Bits 2, 1, and 0 are other types of REX prefixes that we may not end upusing, so I am omitting them here. Please read further in the manual if youare curious!</p><p>位2、1和0是我们最终可能不会使用的其他类型的REX前缀，因此我在这里省略它们。如果你有好奇心，请进一步阅读手册！</p><p> This MOV instruction calls for REX.W, which means this byte will look like 0b01001000, also known as our friend  0x48. Mystery number one, solved!</p><p>此MOV指令调用REX.W，这意味着此字节将类似于0b01001000，也称为我们的朋友0x48。一号谜团，解开了！</p><p>  This is a hexadecimal literal  0xc7. It is the  opcode. There are a couple ofother entries with the opcode  C7, modified by other bytes in the instruction(ModR/M, SIB, REX, …). Write it to the instruction stream. Mystery numbertwo, solved!</p><p>这是十六进制文字0xc7。这是操作码。还有几个具有操作码C7的其他条目，由指令中的其他字节修改(modr/M、sib、rex、…)。那就是。将其写入指令流。第二个谜团，解开了！</p><p>   If the instruction does not require a second operand, then the Reg/Opcodefield may be used as an opcode extension. This use is represented by thesixth row in the tables (labeled “/digit (Opcode)”). Note that values in rowsix are represented in decimal form.</p><p>如果指令不需要第二操作数，则REG/OPCODE字段可用作操作码扩展。这种用法由表中的第六行(标记为“/digit(操作码)”)表示。请注意，第六行中的值以十进制形式表示。</p><p> This is a little confusing because this operation clearly  does have a secondoperand, denoted by the “MI” in the table, which shows Operand 1 being ModRM:r/m (w) and Operand 2 being  imm8/16/32/64. I think it’s because itdoesn’t have a second  register operand that this space is free — theimmediate is in a different place in the instruction.</p><p>这有点混乱，因为此操作显然有第二个操作数，由表中的“MI”表示，它显示操作数1为ModRM：r/m(W)，操作数2为imm8/16/32/64。我认为这是因为它没有第二个寄存器操作数，所以这个空间是空闲的-立即数在指令中的不同位置。</p><p> In any case, this means that we have to make sure to put decimal  0 in the reg part of the ModR/M byte. We’ll see what the ModR/M byte looks like ingreater detail shortly.</p><p>在任何情况下，这意味着我们必须确保在ModR/M字节的reg部分放入十进制0。稍后我们将详细介绍ModR/M字节。</p><p>  id refers to an immediate  double word (32 bits). It’s called a  doubleword because, a word ( iw) is 16 bits. In increasing order of size, we have:</p><p>ID是指立即双字(32位)。它被称为双字，因为一个字(Iw)是16位。按规模递增的顺序，我们有：</p><p>  This means we have to write our 32-bit value out to the instruction stream.These notations and encodings are explained further in Section 3.1.1.1 (page596).</p><p>这意味着我们必须将我们的32位值写出到指令流中。这些符号和编码在3.1.1.1节(第596页)中有进一步的解释。</p><p>             REX  Op  ModR/M      Immediate    0  1      2  3  7       If we were to try and encode the particular instruction  mov rax, 100, itwould look like this:</p><p>REX Op ModR/M IMMEDIATE 0 1 2 3 7如果我们尝试对特定指令mov rax，100进行编码，它将如下所示：</p><p>            REX  Op  ModR/M        Immediate    0  1      2  3  7      0x48  0xc7  0xc0  0x64 0x00 0x00 0x00 This is how you read the table! Slowly, piece by piece, and with a nice cup oftea to help you in trying times. Now that we’ve read the table, let’s go on andwrite some code.</p><p>REX Op ModR/M Immediate 0 1 2 3 7 0x48 0xc7 0xc0 0x64 0x00 0x00 0x00这就是您阅读表格的方式！慢慢地，一块一块地，用一杯好茶来帮助你渡过难关。现在我们已经读完了表，让我们继续编写一些代码。</p><p>  While writing code, you will often need to reference  two more tables than theones we have looked at so far. These tables are Table 2-2 “32-Bit AddressingForms with the ModR/M Byte” (page 532) and Table 2-3 “32-Bit Addressing Formswith the SIB Byte” (page 533). Although the tables describe 32-bit quantities,with the REX prefix all the Es get replaced with Rs and all of a sudden theycan describe 64-bit quantities.</p><p>在编写代码时，您通常需要比我们到目前为止看到的表多引用两个表。这些表格是表2-2“具有ModR/M字节的32位寻址表单”(第532页)和表2-3“带有SIB字节的32位寻址表单”(第533页)。虽然这些表描述的是32位的量，但是有了REX前缀，所有的ES都被替换为R，并且突然之间它们就可以描述64位的量了。</p><p> These tables are super helpful when figuring out how to put together ModR/M andSIB bytes.</p><p>在弄清楚如何将ModR/M和SIB字节组合在一起时，这些表非常有用。</p><p>   Given a register  dst and an immediate 32-bit integer  src, we’re going toencode this instruction. Let’s do all the steps in order.</p><p>给定一个寄存器dst和一个立即的32位整数src，我们将对此指令进行编码。让我们按顺序做所有的步骤。</p><p>  Since the instruction calls for REX.W, we can keep the first line the same asbefore:</p><p>由于指令调用REX.W，因此我们可以保持第一行与前面相同：</p><p>        ModR/M bytes are where the code gets a little different. We want an abstractionto build them for us, instead of manually slinging integers like some kind ofanimal.</p><p>ModR/M字节是代码稍有不同的地方。我们想要一个抽象来为我们构建它们，而不是像某种动物一样手动抛出整数。</p><p> To do that, we should know how they are put together. ModR/M bytes arecomprised of:</p><p>要做到这一点，我们应该知道它们是如何组合在一起的。ModR/M字节包括：</p><p> mod (high 2 bits), which describes what big row to use in the ModR/M table</p><p>MOD(高2位)，描述要在ModR/M表中使用的大行。</p><p>  reg (middle 3 bits), which either describes the second register operand or an opcode extension (like  /0 above)</p><p>REG(中间3位)，描述第二个寄存器操作数或操作码扩展(如上面的/0)。</p><p>  byte  modrm ( byte  mod ,  byte  rm ,  byte  reg )  {  return  (( mod  &amp;  0x3 )  &lt;&lt;  6 )  |  (( reg  &amp;  0x7 )  &lt;&lt;  3 )  |  ( rm  &amp;  0x7 ); }</p><p>Byte modrm(byte mod，byte rm，byte reg){return(mod&amp；0x3)&lt；&lt；6)|((reg&amp；0x7)&lt；&lt；3)|(rm&amp；0x7)；}。</p><p> The order of the parameters is a little different than the order of the bits. Idid this because it looks a little more natural when calling the function fromits callers. Maybe I’ll change it later because it’s too confusing.</p><p>参数的顺序与位的顺序略有不同。我这样做是因为在调用函数时会使调用者看起来更自然一些。因为太混乱了，我以后再换吧。</p><p>  pass  0b11 (3) as  mod, because we want to move directly into a 64-bitregister, as opposed to  [reg], which means that we want to dereference thevalue in the pointer</p><p>将0b11(3)作为mod传递，因为我们希望直接移入64位寄存器，而不是[reg]，这意味着我们希望取消引用指针中的值。</p><p>  void  Emit_mov_reg_imm32 ( Buffer  * buf ,  Register  dst ,  int32_t  src )  {  Buffer_write8 ( buf ,  kRexPrefix );  Buffer_write8 ( buf ,  0xc7 );  Buffer_write8 ( buf ,  modrm ( /*direct*/  3 ,  dst ,  0 ));  // ... }</p><p>Void emit_mov_reg_imm32(buffer*buf，Register dst，int32_t src){buffer_write8(buf，kRexPrefix)；buffer_write8(buf，0xc7)；buffer_write8(buf，modrm(/*direct*/3，dst，0))；//...}</p><p> Which for the above instruction  mov rax, 100, produces a  modrm byte thathas this layout:</p><p>对于上面的指令mov rax，100，其产生与此布局相同的modrm字节：</p><p>                ModR/M  mod  reg  rm  11  000  direct  /0  RAX  000 I haven’t put a datatype for  mods together because I don’t know if I’d beable to express it well. So for now I just added a comment.</p><p>ModR/M mod reg RM 11 000 direct/0 Rax 000我没有把mods的数据类型放在一起，因为我不知道我是否能够很好地表达它。所以现在我只是添加了一个评论。</p><p>  Last, we have the immediate value. As I said above, all this entails is writingout a 32-bit quantity as we have always done:</p><p>最后，我们有即期价值。正如我上面所说的，所有这一切都需要写出一个32位的数量，就像我们一直做的那样：</p><p> void  Emit_mov_reg_imm32 ( Buffer  * buf ,  Register  dst ,  int32_t  src )  {  Buffer_write8 ( buf ,  kRexPrefix );  Buffer_write8 ( buf ,  0xc7 );  Buffer_write8 ( buf ,  modrm ( /*direct*/  3 ,  dst ,  0 ));  Buffer_write32 ( buf ,  src ); }</p><p>Void emit_mov_reg_imm32(buffer*buf，Register dst，int32_t src){buffer_write8(buf，kRexPrefix)；buffer_write8(buf，0xc7)；buffer_write8(buf，modrm(/*direct*/3，dst，0))；buffer_write32(buf，src)；}。</p><p> And there you have it! It took us 2500 words to get us to these measly fourbytes. The real success is the friends we made along the way.</p><p>现在你就知道了！我们花了2500个字才读到这微不足道的4个字节。真正的成功是我们一路结交的朋友。</p><p>  “But Max,” you say, “this produces literally the same output as before with allcases! Why go to all this trouble? What gives?”</p><p>“但是Max，”你说，“这会产生和以前所有情况下一样的输出！为什么要这么麻烦呢？这是怎么回事？“。</p><p> Well, dear reader, having a mod of 3 (direct) means that there is nospecial-case escape hatch when  dst is RSP. This is unlike the other mods,where there’s this  [--][--] in the table where RSP should be. That funkysymbol indicates that there must be a Scale-Index-Base (SIB) byte following theModR/M byte. This means that the overall format for this instruction shouldhave the following layout:</p><p>嗯，亲爱的读者，MOD为3(直接)意味着当DST是RSP时没有特殊情况下的逃生舱口。这与其他MOD不同，在其他MOD中，表中的RSP应该是[--][--]。该FunkySymbol表示ModR/M字节后面必须有一个标度-索引-基数(SIB)字节。这意味着此指令的总体格式应为以下布局：</p><p>            REX  Op  ModR/M        0  1      2  3      SIB  4      Disp    5 If you’re trying to encode  mov [rsp-8], rax, for example, the values shouldlook like this:</p><p>REX Op ModR/M 0 1 2 3 SIB 4 disp 5例如，如果您尝试对mov[RSP-8]、rax进行编码，则值应如下所示：</p><p>            REX  Op  ModR/M        0  1      2  3    0x48  0x89  0x44    SIB  4      Disp    5  0x24  0xf8 This is where an instruction like  Emit_store_reg_indirect ( mov [REG+disp],src) goes horribly awry with the homebrew encoding scheme I cooked up. Whenthe  dst in that instruction is RSP, it’s expected that the next byte is theSIB. And when you output other data instead (say, an immediate 8-bitdisplacement), you get really funky addressing modes. Like what the heck isthis?</p><p>REX Op ModR/M 0 1 2 3 0x48 0x89 0x44 SIB 4 disp 5 0x24 0xf8这就是像emit_store_reg_direct(mov[reg+disp]，src)这样的指令与我设计的自制编码方案出现严重错误的地方。当该指令中的DST为RSP时，预计下一个字节为SIB。而当你输出其他数据时(比方说，立即8位位移)，你就会得到非常时髦的寻址模式。这到底是什么玩意儿？</p><p>  This is actual disassembled assembly that I got from running my binary codethrough  rasm2. Our compiler  definitely does not emit anything thatcomplicated, which is how I found out things were wrong.</p><p>这是实际的反汇编程序集，我通过rasm2运行我的二进制代码得到的。我们的编译器绝对不会发出任何复杂的东西，这就是我发现问题的原因。</p><p> Okay, so it’s wrong. We can’t just blindly multiply and add things. So what dowe do?</p><p>好吧，所以这是错的。我们不能只是盲目地乘法和加法。那么Dowe做了什么？</p><p>  Take a look at Table 2-2 (page 532) again. See that trying to use RSP with anysort of displacement requires the SIB.</p><p>再看一下表2-2(第532页)。请注意，尝试将RSP与任何类型的位移一起使用都需要SIB。</p><p> Now take a look at Table 2-3 (page 533) again. We’ll use this to put togetherthe SIB.</p><p>现在再看一下表2-3(第533页)。我们要用这个把SIB组装起来。</p><p> We know from Section 2.1.3 that the SIB, like the ModR/M, is comprised of threefields:</p><p>我们从第2.1.3节了解到，与ModR/M一样，SIB由三个字段组成：</p><p>  Intel’s language is not so clear and is kind of circular. Let’s take a look atsample instruction to clear things up:</p><p>英特尔的语言不是很清楚，有点循环。让我们来看一下示例说明来澄清一下：</p><p>  Note that while  index and  base refer to registers,  scale refers to oneof 1, 2, 4, or 8, and  disp is some immediate value.</p><p>请注意，index和base指的是寄存器，scale指的是1、2、4或8中的一个，disp是某个立即值。</p><p> This is a compact way of specifying a memory offset. It’s convenient forreading from and writing to arrays and structs. It’s also going to be necessaryfor us if we want to write to and read from random offsets from the stackpointer, RSP.</p><p>这是一种指定内存偏移量的紧凑方式。它便于读取和写入数组和结构。如果我们想写入和读取堆栈指针rsp的随机偏移量，那么它也是必需的。</p><p>   Let’s start by going back to the table enumerating all the kinds of MOVinstructions (page 1209). The specific opcode we’re looking for is  REX.W + 89/r, or  MOV r/m64, r64.</p><p>让我们先回到列举所有类型的MOV指令的表(第1209页)。我们要查找的特定操作码是REX.W+89/r或MOV r/m64，r64。</p><p>     So far, so good. Looking familiar. Now that we have both the instruction prefixand the opcode, it’s time to write the ModR/M byte. Our ModR/M will containthe following information:</p><p>到现在为止还好。看起来很眼熟。现在我们有了指令前缀和操作码，是时候写入ModR/M字节了。我们的ModR/M将包含以下信息：</p><p> reg of whatever register the second operand is, since we have two registeroperands (the opcode field says  /r)</p><p>因为我们有两个寄存器操作数，所以第二个操作数是任何寄存器的REG(操作码字段说/r)。</p><p>  void  Emit_store_reg_indirect ( Buffer  * buf ,  Indirect  dst ,  Register  src )  {  Buffer_write8 ( buf ,  kRexPrefix );  Buffer_write8 ( buf ,  0x89 );  // Wrong!  Buffer_write8 ( buf ,  modrm ( /*disp8*/  1 ,  dst . reg ,  src ));  // ... }</p><p>Void emit_store_reg_direct(buffer*buf，Indirect dst，Register src){buffer_write8(buf，kRexPrefix)；buffer_write8(buf，0x89)；//错误！Buffer_Write8(buf，modrm(/*disp8*/1，dst.。注册表，源))；//...}。</p><p> But no, this is wrong. As it turns out, you still have do this special thingwhen  dst.reg is RSP, as I keep mentioning. In that case,  rm must be thespecial  none value (as specified by the table). Then you also have to write aSIB byte.</p><p>但不，这是不对的。结果是，正如我不断提到的，当dst.reg是RSP时，您仍然需要做这个特殊的事情。在这种情况下，Rm必须是特殊的None值(由表指定)。然后您还必须写入ASIB字节。</p><p> void  Emit_store_reg_indirect ( Buffer  * buf ,  Indirect  dst ,  Register  src )  {  Buffer_write8 ( buf ,  kRexPrefix );  Buffer_write8 ( buf ,  0x89 );  if  ( dst . reg  ==  kRsp )  {  Buffer_write8 ( buf ,  modrm ( /*disp8*/  1 ,  kIndexNone ,  src ));  // ...  }  else  {  Buffer_write8 ( buf ,  modrm ( /*disp8*/  1 ,  dst . reg ,  src ));  }  // ... }</p><p>Void emit_store_reg_direct(buffer*buf，间接DST，寄存器源){buffer_write8(buf，kRexPrefix)；buffer_write8(buf，0x89)；if(dst.。Reg==krsp){buffer_write8(buf，modrm(/*disp8*/1，kIndexNone，src))；//...}否则{buffer_write8(buf，modrm(/*disp8*/1，dst.。注册表，服务器))；}//...}。</p><p> Astute readers will know that  kRsp and  kIndexNone have the same integralvalue of 4. I don’t know if this was intentional on the part of the Inteldesigners. Maybe it’s supposed to be like that so encoding is easier anddoesn’t require a special case for both ModR/M and SIB. Maybe it’scoincidental. Either way, I found it very subtle and wanted to call it outexplicitly.</p><p>精明的读者会知道krsp和kIndexNoone的整数值是4。我不知道这是否是英特尔设计者故意的。也许它应该是这样的，所以编码更容易，并且不需要对ModR/M和SIB都有特殊情况。也许这是偶然的。不管怎样，我发现它非常微妙，我想明确地说出来。</p><p>                 ModR/M  mod  reg  rm  11  100  disp8  RAX  none  000 Let’s go ahead and write that SIB byte. I made a  sib helper function like modrm, with two small differences: the parameters are in order of low tohigh bit, and the parameters have their own special types instead of just being bytes.</p><p>ModR/M mod reg rm 11 100 disp8 Rax NONE 000让我们继续写入SIB字节。我做了一个类似modrm的sib助手函数，只有两个小的不同：参数是从低位到高位的顺序，参数有自己的特殊类型，而不只是字节。</p><p> typedef  enum  {  Scale1  =  0 ,  Scale2 ,  Scale4 ,  Scale8 , }  Scale ; typedef  enum  {  kIndexRax  =  0 ,  kIndexRcx ,  kIndexRdx ,  kIndexRbx ,  kIndexNone ,  kIndexRbp ,  kIndexRsi ,  kIndexRdi }  Index ; byte  sib ( Register  base ,  Index  index ,  Scale  scale )  {  return  (( scale  &amp;  0x3 )  &lt;&lt;  6 )  |  (( index  &amp;  0x7 )  &lt;&lt;  3 )  |  ( base  &amp;  0x7 ); }</p><p>Tyfinf enum{Scale1=0，Scale2，Scale4，Scale8，}scale；tyfinf enum{kIndexRax=0，kIndexRcx，kIndexRdx，kIndexRbx，kIndexNone，kIndexRbp，kIndexRsi，kIndexRdi}Index；byte sib(寄存器基数，索引索引，小数位数){return((scale&amp；0x3)&lt；&lt；6)|(index&amp；0x7)&lt；&lt；3)|(base&amp；0x7)；}。</p><p> I made all these datatypes to help readability, but you don’t have to use themif you don’t want to. The  Index one is the only one that has a small gotcha:where  kIndexRsp should be is  kIndexNone because you can’t use RSP as anindex register.</p><p>我创建所有这些数据类型都是为了提高可读性，但是如果您不想使用它们，也可以不使用它们。Index one是唯一有一个小问题的：kIndexRsp应该在哪里是kIndexNone，因为您不能将RSP用作索引寄存器。</p><p>  void  Emit_store_reg_indirect ( Buffer  * buf ,  Indirect  dst ,  Register  src )  {  Buffer_write8 ( buf ,  kRexPrefix );  Buffer_write8 ( buf ,  0x89 );  if  ( dst . reg  ==  kRsp )  {  Buffer_write8 ( buf ,  modrm ( /*disp8*/  1 ,  kIndexNone ,  src ));  Buffer_write8 ( buf ,  sib ( kRsp ,  kIndexNone ,  Scale1 ));  }  else  {  Buffer_write8 ( buf ,  modrm ( /*disp8*/  1 ,  dst . reg ,  src ));  }  // ... }</p><p>Void emit_store_reg_direct(buffer*buf，间接DST，寄存器源){buffer_write8(buf，kRexPrefix)；buffer_write8(buf，0x89)；if(dst.。Reg==krsp){buffer_write8(buf，modrm(/*disp8*/1，kIndexNone，src))；buffer_write8(buf，sib(krsp，kIndexNone，scale1))；}{buffer_write8(buf，modrm(/*disp8*/1，dst.。注册表，服务器))；}//...}。</p><p>           SIB        scale  index  base  00  100  0  none  RSP  100 This is a very verbose way of saying  [rsp+DISP], but it’ll do. All that’sleft now is to encode that displacement. To do that, we’ll just write it out:</p><p>SIB规模索引基数00 100 0无RSP 100这是一种非常冗长的表示[RSP+DISP]的方式，但它也可以。现在剩下的就是编码那个位移了。要做到这一点，我们只需将其写出来：</p><p> void  Emit_store_reg_indirect ( Buffer  * buf ,  Indirect  dst ,  Register  src )  {  Buffer_write8 ( buf ,  kRexPrefix );  Buffer_write8 ( buf ,  0x89 );  if  ( dst . reg  ==  kRsp )  {  Buffer_write8 ( buf ,  modrm ( /*disp8*/  1 ,  kIndexNone ,  src ));  Buffer_write8 ( buf ,  sib ( kRsp ,  kIndexNone ,  Scale1 ));  }  else  {  Buffer_write8 ( buf ,  modrm ( /*disp8*/  1 ,  dst . reg ,  src ));  }  Buffer_write8 ( buf ,  disp8 ( indirect . disp )); }</p><p>Void emit_store_reg_direct(buffer*buf，间接DST，寄存器源){buffer_write8(buf，kRexPrefix)；buffer_write8(buf，0x89)；if(dst.。Reg==krsp){buffer_write8(buf，modrm(/*disp8*/1，kIndexNone，src))；buffer_write8(buf，sib(krsp，kIndexNone，scale1))；}{buffer_write8(buf，modrm(/*disp8*/1，dst.。Reg，src))；}buffer_write8(buf，disp8(间接。Disp))；}。</p><p> Very nice. Now it’s your turn to go forth and convert the rest of the assemblyfunctions in your compiler! I found it very helpful to extract the modrm/ sib/ disp8 calls into a helper function, because they’re mostly thesame and very repetitive.</p><p>非常好。现在轮到您着手在编译器中转换其余的汇编函数了！我发现将modrm/sib/displ8调用提取到一个helper函数中非常有用，因为它们大多是相同的并且非常重复。</p><p>  This was a very long post. The longest post in the whole series so far, even.We should probably have some concrete takeaways.</p><p>这是一篇很长的帖子。这是到目前为止整个系列中最长的帖子，甚至是。我们可能应该有一些具体的外卖。</p><p>  maybe some third thing, too, I dunno — this post was kind of a lot</p><p>也许还有第三件事，我不知道-这个帖子有点多。</p><p> Hopefully you enjoyed it. I’m going to go try and get a good night’s sleep.Until next time, when we’ll implement procedure calls!</p><p>希望你喜欢。我要去试着睡个好觉。直到下一次，我们将实现过程调用！</p><p>  This is a composite of all the instruction encoding diagrams present in the post. If you&#39;re seeing this text, it means your browser cannot render SVG.</p><p>这是POST中所有指令编码图的组合。如果您再次看到此文本，则意味着您的浏览器无法呈现SVG。</p><p>     If you are an avid reader of this blog (Do those people exist? Please reach out to me. I would love to chat.), you may notice that Tom gets pulled into shenanigans a lot. This is because Tom is the best debugger I have ever encountered, he’s good at reverse engineering, and he knows a lot about low-level things. I think right now he’s working on improving open-source tooling for a RISC-V board for fun. But also he’s very kind and helpful and generally interested in whatever ridiculous situation I’ve gotten myself into. Maybe I should add a list of the Tom Chronicles somewhere on this website. Anyway, everyone needs a Tom.  ↩</p><p>如果你是这个博客的狂热读者(这些人存在吗？请把手伸向我。我很乐意聊天。)，你可能会注意到汤姆经常被拉进恶作剧的圈套。这是因为Tom是我遇到过的最好的调试器，他擅长反向工程，而且他知道很多低级的事情。我想现在他正致力于改进RISC-V板的开源工具，以此为乐。但他也非常善良，乐于助人，而且通常对我陷入的任何荒谬的情况都感兴趣。也许我应该在这个网站的某个地方加一份汤姆编年史的名单。不管怎么说，每个人都需要一个TOM。--↩</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bernsteinbear.com/blog/compiling-a-lisp-10/">https://bernsteinbear.com/blog/compiling-a-lisp-10/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>