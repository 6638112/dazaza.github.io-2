<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>多线程加速JPEG编码 Accelerating JPEG Coding with Multiple Threads</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Accelerating JPEG Coding with Multiple Threads<br/>多线程加速JPEG编码 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-04 20:18:12</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/44b8988ff8f2ebf2f2a5427ca35e4815.jpg"><img src="http://img2.diglog.com/img/2021/1/44b8988ff8f2ebf2f2a5427ca35e4815.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>After the JPEG standard was released in 1992, JPEG images became synonymous with digital photography and are used in almost every application which works with photo quality images. The reason the adoption of the standard was fast and nearly universal is that it makes use of multiple techniques simultaneously to reduce the compressed file size. One of those is an understanding of the limits of the human visual system and which information is important to preserve versus which is less important and can be removed.</p><p>JPEG标准于1992年发布后，JPEG图像成为数字摄影的代名词，几乎在所有处理照片质量图像的应用程序中都使用JPEG图像。采用该标准之所以快速且几乎通用是因为它同时利用多种技术来减小压缩文件的大小。其中之一是对人类视觉系统的局限性的理解，哪些是重要的信息，哪些是不重要的信息，可以删除。</p><p>  There are several steps needed to compress an image using the JPEG method (see image below). To begin, it is usually converted from RGB into the YCbCR colorspace. The reason this is necessary is to allow sub-sampling of the pixels. The human eye is more sensitive to changes in luminance than changes in chrominance. This allows the chroma channels to be downsampled while keeping the luma channel at full resolution. The image can lose 50% of its data with this step and the perceived degradation is quite minimal. The image is then divided into 8x8 MCUs or minimum coded units (the equivalent terminology for video codecs is Macro Blocks). These MCUs are square blocks of pixels which are compressed based on the similarity to each other. The pixels in each MCU are transformed from the spatial domain to the frequency domain with a  Discrete Cosine Transform (DCT). The operation allows for the easy removal of high frequency information (fine detail) to further compress the image. The more high frequency coefficients are removed, the smaller the file and the blurrier the image becomes. This effectively controls the “Q Value” or compression amount used by encoders.</p><p>  使用JPEG方法压缩图像需要几个步骤（请参见下面的图像）。首先，通常将其从RGB转换为YCbCR色彩空间。这是必要的原因是允许像素的二次采样。人眼对亮度的变化比对色度的变化更敏感。这样可以在保持亮度通道处于全分辨率的同时，对色度通道进行下采样。通过此步骤，图像可能会丢失其数据的50％，并且感觉到的降级非常小。然后将图像分为8x8 MCU或最小编码单位（视频编解码器的等效术语是“宏块”）。这些MCU是像素的正方形块，它们基于彼此的相似性进行压缩。每个MCU中的像素都通过离散余弦变换（DCT）从空间域转换到频域。该操作允许轻松去除高频信息（精细细节）以进一步压缩图像。去除的高频系数越多，文件越小，图像变得越模糊。这样可以有效地控制编码器使用的“ Q值”或压缩量。</p><p>  One of the many clever ideas incorporated into the standard is to use the similarity in DC value (essentially the brightness) between adjacent MCUs to further reduce the data size by compressing just the change from one to the next instead of encoding the entire value. This is depicted above in the “DPCM coding” block. This is a great idea, but it creates a small problem. By having each successive MCU’s DC value(s) depend on a delta from the previous, it means that if there is an error in the data, the MCUs from that point on down will all be wrong.</p><p>  该标准中包含的许多巧妙思想之一是使用相邻MCU之间的DC值（基本上是亮度）的相似性，通过仅压缩从一个到下一个的变化而不是编码整个值来进一步减小数据大小。上面在“ DPCM编码”块中对此进行了描述。这是一个好主意，但会带来一个小问题。通过使每个连续的MCU的DC值取决于前一个值的增量，这意味着如果数据中存在错误，则从那以后开始的MCU都是错误的。</p><p> Making matters slightly worse is that the compressed symbols which encode the image data (shown above as “Huffman coding”) are Variable Length Codes (VLC). A single wrong bit can corrupt the data from that point forward. Back in the ‘old’ days when JPEG was invented, this was a very real concern because images were often transmitted over channels (e.g. acoustic modem) that may not have had robust error correction or stored on media (e.g. floppy disks) that were prone to errors. Knowing that the data may suffer from errors, a feature was added to the standard to mitigate the amount of the image that would be corrupted by bad data. The idea was to periodically reset the previous DC value to 0, forcing the next MCU to encode its entire value as a delta from 0. This means that any corrupted DC values will only affect pixels up to the next restart point.</p><p> 更糟糕的是，对图像数据进行编码的压缩符号（上面显示为“霍夫曼编码”）是可变长度代码（VLC）。从那一点开始，单个错误的位可能会破坏数据。早在发明JPEG的“过去”时代，这是一个非常现实的问题，因为图像通常是通过通道（例如，声音调制解调器）传输的，而这些通道可能没有经过严格的纠错，或者存储在容易产生错误的介质（例如软盘）上错误。知道数据可能会出现错误，因此在标准中添加了一项功能，以减轻可能因不良数据而损坏的图像量。这样做的想法是定期将先前的DC值重置为0，迫使下一个MCU将其整个值编码为从0开始的增量。这意味着任何损坏的DC值只会影响直到下一个重启点的像素。</p><p> This is implemented with Restart Markers. They are 2-byte markers placed in between the MCUs at regular intervals (e.g. every 100 MCUs). If a data corruption occurs, it’s easy to scan forward in the file to the next restart marker (JPEG markers are always on byte boundaries and preceded by 0xFF). Once the next restart marker is found, the image can be properly decoded from that point on since the number of MCUs between each restart marker is known.</p><p> 这是通过重新启动标记实现的。它们是2字节的标记，它们以固定的间隔（例如，每100个MCU）放置在MCU之间。如果发生数据损坏，可以很容易地在文件中向前扫描到下一个重新启动标记（JPEG标记始终位于字节边界，并以0xFF开头）。一旦找到下一个重启标记，由于已知每个重启标记之间的MCU数量，因此可以从该点开始对图像进行正确解码。</p><p>  Starting not long after the JPEG standard was released, computer networks and storage were getting more reliable and incorporated error detection and correction (e.g. TCP/IP). The solid state storage cards used in digital cameras were quite reliable and the restart markers were ‘forgotten’ for a while since they made the files slightly larger without giving much perceived benefit. During that period, computer software was mostly designed to run on a single processor using a single thread. The fact that a JPEG image needed to be decoded in a single pass due to its use of variable length codes and a string of successive delta values for the MCU didn’t cause any problems for software since it was designed to run as a single thread anyway.</p><p>  在发布JPEG标准后不久，计算机网络和存储设备就变得更加可靠，并集成了错误检测和纠正功能（例如TCP / IP）。数码相机中使用的固态存储卡相当可靠，并且重新启动标记“被遗忘了”了一阵子，因为它们使文件稍大了一点，却没有带来太大的好处。在此期间，计算机软件主要设计为在使用单个线程的单个处理器上运行。 JPEG图像由于使用可变长度代码和一串连续的增量值用于MCU而需要单次解码，这一事实并没有给软件带来任何问题，因为它被设计为可以单线程运行无论如何。</p><p> In the last few years however, computers and our use of JPEG images have changed dramatically. Nearly every computing device has multiple CPUs and runs an operating system with multiple threads (even phones). The other change is that people are taking, editing and viewing billions of JPEG photos on their mobile phones. Each generation of phones produce larger and higher resolution images. For anyone working with tons of photos, the time to encode and decode them has become increasingly important because of the sheer volume and size of new images being generated.</p><p> 但是，在最近几年中，计算机和我们对JPEG图像的使用发生了巨大变化。几乎每个计算设备都具有多个CPU，并运行具有多个线程的操作系统（甚至是电话）。另一个变化是人们正在使用手机拍摄，编辑和查看数十亿张JPEG照片。每一代手机都会生成更大和更高分辨率的图像。对于处理大量照片的任何人来说，对它们进行编码和解码的时间变得越来越重要，因为所生成的新图像数量巨大且尺寸巨大。 </p><p>   Computers have been getting more powerful on a mostly continuous trajectory since the 1970s. A general term used to describe the continuous improvements in silicon processing called  Moore’s Law was coined many years ago to commemorate Gordon Moore’s prediction that computers will double the number of transistors every 18 months. This has held mostly true for the transistor count, but the maximum speed of computers has basically hit a dead end due to the physical limitations of silicon and power+heat issues. Since individual processor speed hasn’t advanced much in the last few years, the emphasis has shifted to employing many processors to complete tasks faster by working in parallel. In today’s computing environment, it’s advantageous to be able to divide a task into sections and assign them to multiple CPUs. Not all tasks are possible to divide because each successive part may depend on the results from the previous. JPEG encoding and decoding are normally difficult to divide into pieces and run in parallel because of the way each successive MCU depends on the previous one and the use of variable length codes.</p><p>自1970年代以来，计算机在几乎连续的轨迹上变得越来越强大。为了描述戈登·摩尔关于计算机每18个月晶体管数量将增加一倍的预测，人们在多年前创造了一个通用术语，用以描述硅工艺的持续改进，称为摩尔定律。对于晶体管数量而言，这基本上是正确的，但是由于硅的物理局限性以及功率和热量问题，计算机的最高速度已基本陷入僵局。由于过去几年中单个处理器的速度没有太大提高，因此重点已转移到使用许多处理器来通过并行工作更快地完成任务。在当今的计算环境中，将任务划分为多个部分并将它们分配给多个CPU很有好处。并非所有任务都可以划分，因为每个连续的部分都可能取决于前一个的结果。 JPEG编码和解码通常很难分为几部分，并且很难并行运行，因为每个连续的MCU取决于前一个MCU的方式以及可变长度代码的使用。</p><p> However… A convenient benefit of restart markers is that the VLC data is reset to a byte boundary (after the marker) and the MCU DC delta value is also reset. This means that both JPEG encoding and decoding could be divided into multiple threads with the use of restart markers. For encoding, the image could be divided into symmetrical strips and each strip could be encoded by a different processor. When each processor completes that task, the output of each can then be ‘glued’ together using restart markers. For decoding, the task can be spread across as many processors as there are restart markers. The only extra effort needed is to scan forward in the compressed data looking for the restart markers first since the size of the compressed data between each varies and there is no ‘directory’ in JPEG files showing where the restart markers are located.</p><p> 但是…重新启动标记的一个方便好处是VLC数据被重置为字节边界（在标记之后）并且MCU DC增量值也被重置。这意味着可以使用重新启动标记将JPEG编码和解码都分为多个线程。为了进行编码，可以将图像分为对称的条带，并且每个条带可以由不同的处理器编码。当每个处理器完成该任务后，可以使用重新启动标记将每个输出“粘合”在一起。对于解码，任务可以分布在与重新启动标记一样多的处理器上。唯一需要做的工作就是先向前扫描压缩数据以查找重启标记，因为每个压缩数据之间的大小各不相同，并且JPEG文件中没有“目录”来显示重启标记的位置。</p><p>  With multi-threaded applications, the performance rarely scales 1:1 with the number of CPUs utilized (e.g. splitting a task into 12 threads on 12 CPU cores doesn’t mean it will run 12x faster). There is extra overhead in managing the threads and the memory is usually a single entity shared among the processors. Let’s run a test on the following image:</p><p>  对于多线程应用程序，性能很少会随所用CPU的数量而按1：1比例缩放（例如，将任务分成12个CPU内核上的12个线程并不意味着运行速度会快12倍）。管理线程会产生额外的开销，并且内存通常是处理器之间共享的单个实体。让我们对下图进行测试：</p><p>  Among other techniques, at Optidash we incorporate this idea of using restart markers to greatly accelerate both the decoding and encoding of images. The image above was run through one of our testing tools on a 2018 MacBook Pro 15” laptop with a 6-core Intel i7 processor. Here are the results:</p><p>  除其他技术外，在Optidash，我们结合了使用重新开始标记的思想，以极大地加速图像的解码和编码。上图是通过我们的测试工具之一在配备6核Intel i7处理器的2018年MacBook Pro 15英寸笔记本电脑上运行的。结果如下：</p><p>  As you can see in the table above, there is a measurable advantage to splitting JPEG coding into multiple parts and assigning them to different CPUs. Depending on the task, the speed rarely scales linearly when using more CPUs. In this case, the intense use of large areas of memory limits how much benefit multiple CPUs can improve the overall speed.</p><p>  如上表所示，将JPEG编码分为多个部分并将它们分配给不同的CPU有一个可衡量的优势。根据任务的不同，在使用更多CPU时，速度很少会线性扩展。在这种情况下，大量内存的大量使用限制了多个CPU可以提高整体速度的收益。</p><p>  void ThreadedWriteJPEG(assorted JPEG parameters, int numThreads) { int slice; pthread_t tinfo; // set completion counter sliceRemaining = numThreads; // Start a thread for each slice for (slice = 0; slice &lt; numThreads; slice++) { pthread_t tinfo; // Use a ‘slice’ structure to hold info about each thread’s work // This includes a pointer to the start of that strip of pixels // and the number of lines to compress &lt;setup slice structure for each thread’s work&gt; pthread_create(&amp;tinfo, NULL, JPEGBuffer, &amp;slices[slice]); } // for each slice // wait for all worker threads to finish WaitForThreads(&amp;sliceRemaining); // merge slices into a single file and write it WriteJPEGBuffer(slices, numThreads);}</p><p>  void ThreadedWriteJPEG（各种JPEG参数，int numThreads）{int slice; pthread_t tinfo; //设置完成计数器sliceRemaining = numThreads; //为每个切片启动一个线程，用于（切片= 0; slice＆lt; numThreads; slice ++）{pthread_t tinfo; //使用“切片”结构来保存有关每个线程的工作的信息// //包括指向该像素带的起点的指针//以及要压缩＆lt;每个线程的工作的设置切片结构的行数pthread_create（＆amp; tinfo，NULL，JPEGBuffer，＆amp; slices [slice]）; } //对于每个切片// //等待所有工作线程完成WaitForThreads（＆amp; sliceRemaining）; //将切片合并为一个文件，然后将其写入WriteJPEGBuffer（slices，numThreads）;} </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://optidash.ai/blog/accelerating-jpeg-coding-with-multiple-threads">https://optidash.ai/blog/accelerating-jpeg-coding-with-multiple-threads</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/jpeg/">#jpeg</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/图像/">#图像</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>