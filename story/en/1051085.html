<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>测试司机箱子 Testing a Driver Crate</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Testing a Driver Crate<br/>测试司机箱子 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-07 12:14:30</div><div class="page_narrow text-break page_content"><p>Welcome to the second post in our  &#34;testing Embedded Rust&#34; series.In this blog post we&#39;ll cover how to test a platform agnostic  driver crate.</p><p>欢迎来到我们＆＃34的第二篇文章;测试嵌入式生锈＆＃34;系列。在此博客文章中我们＆＃39; ll涵盖如何测试平台无话用司机箱。</p><p>  In the embedded Rust ecosystem, the term driver crate refers to a  generic library that interfaces some external component (e.g. sensor, actuator) using a communication protocol like  I 2C or  SPI.The key point here being  generic: the library implementation does  not contain the platform specific details of  how to do I 2C or SPI transactions – all those details are hidden behind a  trait (Rust term for  interfaces).Because driver crates are generic they can be used on a variety of platforms ranging from embedded Linux to small microcontrollers.</p><p>  在嵌入式生态系统中，术语驱动程序箱是指使用像I 2C或SPI等通信协议接口一些外部组件（例如传感器，执行器）的通用库。这里的关键点是通用的：库实现不包含平台的特定详细信息如何进行I 2C或SPI事务 - 所有这些详细信息都隐藏在特征后面（界面的Rust术语）。由于驱动程序箱是通用的，它们可以用于从嵌入式Linux到小微控制器的各种平台。</p><p> Most  driver crates in the crates.io ecosystem are generic around the traits found in the   embedded-hal crate.This crate covers interfaces commonly found on embedded devices like Serial (AKA UART), I 2C and SPI.To use a driver crate you&#39;ll need a Hardware Abstraction Layer (HAL) that implements the  embedded-hal traits;  you can find plenty of HALs for microcontrollers that implement these traits on crates.io.And if you&#39;re writing a HAL yourself, we covered  how to test a HAL in one of our previous blog posts.</p><p> 箱子里的大多数司机箱。eCosystem在嵌入式 - 哈尔克匠队中发现的特征周围是通用的。本箱覆盖嵌入式设备上的接口，如串行（AKA UART），I 2C和SPI等嵌入式设备。使用驾驶员箱子箱子箱子＆＃ 39; LL需要实现嵌入式HAL特征的硬件抽象层（HAL）;您可以为在箱子上实施这些特征的微控制器找到大量的HALS.and，如果您自己编写了一个HAL，我们如何在我们以前的博客帖子中进行测试。</p><p>   As an example, let&#39;s say you are writing a driver crate for the  SCD30, a carbon dioxide (CO 2) sensor which, by the way, is one of the tasks in our  first knurling session about building an air quality sensor (note: currently you can only access this content if you&#39;re a  sponsor. All knurling material goes public however, so we&#39;ll update this blog post once it does!)</p><p>   作为一个例子，假设您正在为SCD30编写一个司机箱，一所碳二氧化碳（二氧化碳）传感器，顺便说一下，这是我们第一个关于建造空气质量传感器的第一个滚花会话中的任务之一（注意：目前您只能访问此内容＆＃39;重新提供赞助商。但是，所有滚花材料都公开了，所以我们＆＃39;一旦它做了，我们会更新这个博客帖子！）</p><p>  $  # instead of `exa` (Rust tool) you can use the `tree` command $  # https://crates.io/crates/exa  $ exa  -a  -I  &#39;.git*&#39;  -T . ├── Cargo.toml├── src│ └── lib.rs└── target-tests ├── .cargo │ └── config.toml ├── Cargo.toml └── tests └── scd30.rs</p><p>  $＃而不是`exa`（铁锈工具）您可以使用`tree`命令$＃https://crates.io/crates/exa $ exa -a -i＆＃39; .git *＆＃39; -T。 ├──船舶。── - src││──18-5 - 目标测试├──.cargo│└──config.toml├──────────卢比</p><p> The root package ( ./Cargo.toml) is the driver crate itself.There&#39;s a second Cargo package in the  target-tests folder; it will be used exclusively for testing. target-tests will be configured for cross compilation using  config.toml so do  not put these two crates in a Cargo workspace (or you may run into  build issues or  Cargo bugs).</p><p> 根包（./cargo.toml）是司机本身。目标测试文件夹中的第二个货舱包装司司裤。它将专门用于测试。目标测试将配置用于使用Config.Toml的交叉编译，因此请勿将这两个箱子放入货物工作空间（或您可能遇到构建问题或货物错误）。</p><p>  Let&#39;s start by looking at the driver crate.The core of the API will be some generic struct.The SCD30 sensor has an I 2C interface so the struct will be generic around the I 2C implementation.</p><p>  让＆＃39;首先查看驱动程序箱。API的核心将是一些通用结构。SCD30传感器具有I 2C接口，因此结构将在I 2C实现周围通用。 </p><p> use  embedded_hal :: blocking :: i2c ; /// A SCD30 sensor on the I2C bus `I` pub  struct  Scd30 &lt; I &gt; ( I ) where  // ↓ embedded-hal traits  I :  i2c :: Read  +  i2c :: Write ; /// A driver error pub  enum  Error &lt; E &gt;  {  /// I2C bus error  I2c ( E ),  /// CRC validation failed  InvalidCrc , } impl &lt; E ,  I &gt;  Scd30 &lt; I &gt; where  I :  i2c :: Read &lt; Error  =  E &gt;  +  i2c :: Write &lt; Error  =  E &gt; , {  /// Initializes the SCD30 driver  /// This consumes the I2C bus `I`  pub  fn  init ( i2c :  I )  -&gt;  Self  {  // ..  }  /// Returns the firmware version reported by the SCD30  pub  fn  get_firmware_version (  &amp; mut  self ,  )  -&gt;  Result &lt; [ u8 ;  2 ],  Error &lt; E &gt;&gt;  {  // ..  }  // omitted methods to e.g. read CO2 levels  /// Destroys this driver and releases the I2C bus `I`  pub  fn  destroy ( self )  -&gt;  I  {  // ..  } }</p><p>使用embedded_hal ::阻止:: i2c; /// I2C总线`I`的SCD30传感器，PUB结构SCD30＆lt;我＆gt; （i）其中//嵌入嵌入式hal特征i：i2c :: read + i2c :: write; ///驱动程序错误PUB枚举错误＆lt; E＆gt; {/// i2c总线错误I2C（e），/// CRC验证失败InvalidCRC，} iscl＆lt; e，i＆gt; SCD30＆lt;我＆gt;其中i：i2c ::读取＆lt;错误= E＆gt; + i2c ::写入＆lt;错误= E＆gt; ，{///初始化SCD30驱动程序///，这会消耗I2C总线`i`bub fn init（i2c：i） - ＆gt; self {// ..} ///返回scd30 pub fn get_firmware_version（＆amp; mut self，） - ＆gt的固件版本。结果＆lt; [u8; 2]，错误＆lt; E＆gt;＆gt; {// ..} //省略了e.g.读取CO2级别///销毁此驱动程序并释放I2C总线`I` PUB FN Destry（Self） - ＆gt;一世  {  // ..  } }</p><p> Because the API is generic you can compile this crate to Linux, Windows, macOS or to a microcontroller.Having an I 2C interface ( trait) enables testing the crate on your PC without any embedded hardware at all – not even a SCD30 is needed for this!How? Using a mock implementation to simulate the I 2C bus.</p><p> 因为API是通用的，您可以将该箱子编译到Linux，Windows，MacOS或微控制器.Having IC接口（特征），可以在没有任何嵌入式硬件上测试PC上的箱子 - 甚至需要SCD30这个！怎么样？使用模拟实现来模拟I 2C总线。</p><p>  The idea goes like this: you instantiate the driver with an I 2C  mock implementation that can run on your PC without extra hardware.Thankfully, there&#39;s already a solution for this in the crates.io ecosystem: the   embedded-hal-mock crate.As its name suggests, this crate contains mock implementations for several of the  embedded-hal traits.In this example, we&#39;ll use the  i2c::Mock implementation.</p><p>  这个想法是这样的：你用I 2C模拟实现将驱动程序实例化，可以在没有额外的硬件上在PC上运行.Thankfly，在箱子里有一个解决方案.IO生态系统：嵌入式暂停模拟箱子。它的名字表明，这个箱子包含了几个嵌入式哈尔特拉特的模拟实现。在此示例中，我们＆＃39; ll使用i2c :: mock实现。</p><p> Let&#39;s say we want to test the  get_firmware_version function.The  SCD30 Interface Specification (v1.0) states (in section 1.4.9) that querying the firmware version involves these 2 I 2C transactions:</p><p> 假设我们想测试Get_Firmware_version功能。SCD30接口规范（v1.0）状态（第1.4.9节）查询固件版本涉及这2个I 2C事务：</p><p>  For those unfamiliar with I 2C, in a  write transaction the data flows from the  host to the  device and in a  read transaction the data flows the other way.In our case, the  host is going to be the machine running the  Scd30 driver, e.g. a microcontroller, and the  device is going to be the SCD30 sensor.</p><p>  对于那些与I 2C不熟悉的人，在一个写入事务中，数据从主机流到设备，并且在读取事务中，数据流动另一个方式。在我们的情况下，主机将是运行SCD30驱动器的机器，例如，该机器。微控制器，设备将成为SCD30传感器。</p><p> In I 2C, a host can communicate with multiple devices connected to the same bus (electrical interface).To differentiate one device from another each one has a different  address.An I 2C transaction (in either direction) starts with a header.The lower bit (bit 0) of this header indicates the direction: read ( 1) or write ( 0) transaction.The upper 7 bits of the header are the I 2C device address.If we right-shift either of these headers ( 0xC2 or  0xC3) by one bit ( &gt;&gt; 1) we get the I 2C address of the SCD30 sensor:  0x61.</p><p> 在I 2C中，主机可以与连接到相同总线的多个设备（电接口）通信。要将一个设备与另一个设备区分地区，每个设备具有不同的地址。AN I 2C事务（在任一方向上）从标题开始。较低此标题的位（位0）表示方向：读取（1）或写入（0）事务。头部的7位是I 2C设备地址。如果我们向这些标题（0xc2或0xc3中的任一个换档）通过一个比特（＆gt;＆gt; 1）我们获取SCD30传感器的I 2C地址：0x61。</p><p> The SCD30 response in the read transaction contains 3 bytes.The first two bytes are the firmware version: the first byte is the major component; the second one is the minor component.The third byte in the response is a checksum (CRC) of the first two bytes.The firmware version of the SCD30 is always  3.66, in  MAJOR.MINOR format, according to the Interface Specification (v1.0) document.</p><p> 读取事务中的SCD30响应包含3个字节。前两个字节是固件版本：第一个字节是主要组件;第二个是次要组件。响应中的第三个字节是前两个字节的校验和（CRC）。根据接口规范，SCD30的固件版本始终为3.66。 0）文档。 </p><p>  // this code lives inside a `tests` module use  embedded_hal_mock :: i2c ; use  super ::{ Error ,  Scd30 }; #[test] fn  firmware_version ()  {  let  expectations  =  vec! [  i2c :: Transaction :: write ( 0x61 ,  vec! [ 0xD1 ,  0x00 ]),  i2c :: Transaction :: read ( 0x61 ,  vec! [ 0x03 ,  0x42 ,  0xF3 ]),  ];  let  mock  =  i2c :: Mock :: new ( &amp; expectations );  let  mut  scd30  =  Scd30 :: init ( mock );  let  version  =  scd30 .get_firmware_version () .unwrap ();  assert_eq! ([ 3 ,  66 ],  version );  let  mut  mock  =  scd30 .destroy ();  mock .done ();  // verify expectations }</p><p>//此代码生存在“测试”模块中使用Embedded_Hal_Mock :: I2C;使用super :: {错误，scd30}; ＃[test] fn firmware_version（）{让期望= VEC！ [I2C :: Transaction :: Write（0x61，Vec！[0xD1，0x00]），I2C :: Transaction :: Read（0x61，Vec！[0x03，0x42，0xF3]），];让模仿= I2C :: Mock :: New（＆amp;期望）;让mut scd30 = scd30 :: init（模拟）;让Version = SCD30 .get_firmware_version（）.unwrap（）; assert_eq！ （[3,66]，版本）;让mut mock = scd30 .destroy（）;模拟.done（）; //验证期望}</p><p> To create the I 2C  Mock we need to pass in some  expectations.These  expectations are the I 2C transactions expected by the mock.We&#39;ll only test the  get_firmware_version function here so only 2 transactions are expected.</p><p> 要创建I 2C模拟，我们需要通过一些预期来传递。这些预期是Mock.we＆＃39所期望的I 2C事务; LL仅在这里测试Get_Firmware_version函数，所以只有2个交易。</p><p> Note that first argument of the  Transaction constructors is the SCD30 I 2C device address,  not the header of the transaction.</p><p> 请注意，事务构造函数的第一个参数是SCD30 I 2C设备地址，而不是事务的标题。</p><p> Once we have an I 2C mock we can instantiate the  Scd30 driver with it.We&#39;ll then call the  get_firmware_version method on the driver and assert that it returns version  3.66.</p><p> 一旦我们拥有I 2C模拟，我们就可以将SCD30驱动程序与它实例化.we＆＃39; ll然后在驱动程序上调用get_firmware_version方法并断言它返回3.66版。</p><p> Once we are done using the mock we need to call its  done method.This method verifies that all the expectations were used; if they were not, the method panics which fails the test.The  i2c::Mock will also panic if you try to perform a transaction not listed in the set of expectations it was constructed with.</p><p> 一旦我们使用Mock完成，我们需要调用其完成方法。这方法验证了所有的预期;如果不是，则失败测试的方法泛滥。I2C :: Mock还将恐慌，如果您尝试执行它的预期集中未列出的事务，则会恐慌。</p><p> If you  cargo test your crate and correctly implement the  get_firmware_version method then the above test should pass!</p><p> 如果您的货物测试您的箱子并正确实现Get_Firmware_version方法，那么上述测试应该通过！</p><p>  The cool thing about using a mock is that you can simulate failures that would be hard to produce with real hardware.For instance, it&#39;s unlikely you&#39;ll be able to make the SCD30 sensor report a bad checksum in its responses and it would be hard and costly to inject interference in the I 2C bus to flip some bits in the sensor response.But with a mock you can easily simulate these errors and verify that your driver crate behaves correctly in these scenarios.Let&#39;s see how to do that for the  get_firmware_version API.</p><p>  关于使用模拟的很酷的事情就是你可以模拟用真正的硬件生产的失败。对于实例，它，它不太可能与您＆＃39; ll能够使SCD30传感器报告其存在糟糕的校验和对I 2C总线的干扰来重新且昂贵的响应，以在传感器响应中翻转一些位。用模拟可以轻松模拟这些错误并验证这些方案中的驱动程序箱是否正确行为.Let＆＃39 ; s看看如何为get_firmware_version API执行此操作。 </p><p> # [ test ] fn  firmware_version_bad_crc ()  {  let  expectations  =  vec! [  Transaction :: write ( 0x61 ,  vec! [ 0xD1 ,  0x00 ]),  // NOTE negated CRC byte in the response!  Transaction :: read ( 0x61 ,  vec! [ 0x03 ,  0x42 ,  ! 0xF3 ]),  ];  let  mock  =  i2c :: Mock :: new ( &amp; expectations );  let  mut  scd30  =  Scd30 :: init ( mock );  let  res  =  scd30 .get_firmware_version ();  assert_eq! ( Err ( Error :: InvalidCrc ),  res );  scd30 .destroy () .done ();  // verify expectations }</p><p>＃[test] fn firmware_version_bad_crc（）{让期望= Vec！ [事务::编写（0x61，Vec！[0xd1，0x00]），//注意响应中的否定CRC字节！交易::读（0x61，Vec！[0x03，0x42，！0xF3]），];让模仿= I2C :: Mock :: New（＆amp;期望）;让mut scd30 = scd30 :: init（模拟）;让res = scd30 .get_firmware_version（）; assert_eq！ （err（错误:: Invalidcrc），Res）; scd30 .destroy（）.done（）; //验证期望}</p><p> Here we have a test that&#39;s similar to the previous one but includes a fake error in the SCD30 response: the third byte, the CRC, is negated, meaning all its bits are flipped.This should be detected as an error by our  Scd30 driver because the checksum is invalid so this time we assert that  get_firmware_version returns an  InvalidCrc error.</p><p> 在这里，我们的测试与前一个相似的测试，但包括SCD30响应中的假误差：第三个字节，CRC被否定，这意味着所有位都被翻转。这应该被检测为错误我们的SCD30驱动程序因为校验和无效所以这次我们断言get_firmware_version返回InvalidCRC错误。</p><p>  The fact that you can use mocks to test the driver crate code does not mean that should exclusively use mocks to test your code.Wherever possible you should extract the parts of your code base that are  pure, meaning they do not perform side effects like I/O. These parts can then easily be tested using stock testing functionality - without the overhead of using mocks.</p><p>  您可以使用模型来测试驱动程序箱代码的事实并不意味着应该专门使用模型来测试代码。可能会将您的代码库的部分提取为纯粹的，这意味着它们不会像我一样执行副作用/ o。然后可以使用库存测试功能轻松测试这些部件 - 没有使用模拟的开销。</p><p> A great example of this in the SCD30 driver crate is the checksum functionality.All responses from the sensor include a CRC8 checksum; the Interface Specification document describes how to compute it and includes some examples.In this case, you can refactor the CRC computation into a helper function that&#39;s used in functions that involve I 2C communication.The helper function is pure: it takes some bytes and returns one byte, so it can be tested in isolation without mocks.</p><p> 在SCD30驱动程序箱中的一个很好的例子是校验和功能。来自传感器的响应包括CRC8校验和;接口规范文档介绍如何计算它并包含一些示例。在这种情况下，您可以将CRC计算重构为＆＃39; s中使用的辅助函数，涉及I 2C通信的功能。辅助功能是纯粹的：它需要一些字节并返回一个字节，因此它可以在没有模型的情况下以隔离进行测试。</p><p> fn  compute_crc ( bytes :  &amp; [ u8 ])  -&gt;  u8  {  // .. } #[cfg(test)] mod  tests  {  #[test]  fn  crc ()  {  // example from the Interface Specfication document  assert_eq! ( super :: compute_crc ( &amp; [ 0xBE ,  0xEF ]),  0x92 );  } }</p><p> fn compute_crc（bytes：＆amp; [u8]） - ＆gt; u8 {// ..}＃ （超级:: compute_crc（＆amp; [0xbe，0xef]），0x92）; }}</p><p>  Now it&#39;s time to confront the implementation, so far only tested on the host, with reality.The idea is to instantiate the  Scd30 drivers with one of the existing HAL crates, instead of a mock, and test that.</p><p>  现在是对待实施的时间，到目前为止仅在主机上进行测试，实际上是。这个想法是将SCD30驱动程序与现有的HAL箱，而不是模拟，测试。</p><p> This part requires actual hardware: in this example, in addition to the SCD30 sensor we&#39;ll use the nRF52840 Development Kit (DK).These real hardware tests will live in the  target-tests folder we previously created.That folder is configured for cross compilation and set up with  probe-run and  defmt-test for on-target testing.We&#39;ll use the same setup as in  our previous blog post so we won&#39;t repeat those steps here.</p><p> 本部分需要实际硬件：在此示例中，除了SCD30传感器之外，我们还使用NRF52840开发套件（DK）。这些实际硬件测试将居住在我们以前创建的目标测试文件夹中。配置文件夹对于交叉编译并设置探测运行和DEFMT-TEST for Target-Target测试.we＆＃39; ll使用与我们之前的博客文章相同的设置，以便我们在此重复＆＃39;重复这些步骤。 </p><p>    struct  State  {  scd30 :  Scd30 &lt; Twim &lt; TWIM0 &gt;&gt; , } #[defmt_test :: tests] mod  tests  {  use  defmt ::{ assert_eq ,  unwrap };  use  nrf52840_hal ::{  gpio :: p0 ,  twim ::{ self ,  Twim },  };  #[init]  fn  setup ()  -&gt;  super :: State  {  let  peripherals  =  unwrap! ( nrf52840_hal :: pac :: Peripherals :: take ());  let  pins  =  p0 :: Parts :: new ( peripherals .P0 );  let  scl  =  pins .p0_30 .into_floating_input () .degrade ();  let  sda  =  pins .p0_31 .into_floating_input () .degrade ();  let  pins  =  twim :: Pins  {  scl ,  sda  };  let  i2c  =  Twim :: new (  peripherals .TWIM0 ,  pins ,  twim :: Frequency :: K100 ,  );  let  scd30  =  scd30 :: Scd30 :: init ( i2c );  State  {  scd30  }  }</p><p>结构状态{SCD30：SCD30＆lt; Twim＆lt; Twim0＆gt;＆gt; ，}＃[defmt_test :: tests] mod tests {使用defmt :: {assert_eq，unwrap};使用nrf52840_hal :: {gpio :: p0，twim :: {self，twim}，}; ＃[init] fn setup（） - ＆gt;超级::陈述{让外围设备= unwrap！ （nrf52840_hal :: pac ::外围设备:: take（））;让PINS = P0 ::零件::新（外设.p0）;让scl = pins .p0_30 .into_floation_input（）.degrade（）;让SDA = PINS .p0_31 .into_floation_input（）.degrade（）;让PIN = TWIM :: PIN {SCL，SDA};让i2c = twim :: new（外设.twim0，引脚，twim ::频率:: k100，）;让SCD30 = SCD30 :: SCD30 :: init（I2C）;州{SCD30}}</p><p>  # [ test ]  fn  confirm_firmware_id ( state :  &amp; mut  State )  {  const  EXPECTED :  [ u8 ;  2 ]  =  [ 3 ,  66 ];  let  firmware_id  =  state .scd30 .get_firmware_version () .unwrap ();  assert_eq! ( EXPECTED ,  firmware_id );  } }</p><p>  ＃[test] fn confign_firmware_id（州：＆amp; mut状态）{const预期：[U8; 2] = [3,66];让Firmware_id = state .scd30 .get_firmware_version（）.unwrap（）; assert_eq！ （预期，固件_ID）; }}</p><p> Now, don&#39;t be surprised if the driver implementation works with real hardware on the first try!It happens often if you test it with mocks first, in our experience.</p><p> 现在，如果驾驶员实现在第一次尝试的真实硬件上使用真正的硬件，则不会感到惊讶！如果您首先用Mocks测试它，它会经常在我们的经验中进行测试。</p><p> How should one go about testing the rest of the  Scd30 API that involves operations like reading the CO 2 concentration?There&#39;s probably not an expected response when testing the rest of the SCD30 functionality but simply asserting that the rest of the API returns  Ok and not e.g. blocks forever or returns some I 2C or CRC error is a great start.In the case of the CO 2 concentration, you could assert that the returned  f32 value is within some reasonable range (e.g. less than 1,000 parts per million indicates good air exchange in indoor spaces) and that is not a  NaN value or infinity.</p><p> 如何能够测试涉及读取CO 2浓度的操作的其余部分的SCD30 API？在测试SCD30功能的其余部分时可能不是预期的响应，而只是断言其余API返回好，而不是例如块永远或返回一些I 2C或CRC错误是一个很好的开始。在CO 2浓度的情况下，您可以断言返回的F32值在某个合理范围内（例如，每百万份小于1,000份表示良好的空气交换室内空间），这不是Nan值或无穷大。</p><p>  In this post we have seen how to test a driver crate  without additional hardware using mocks and  with embedded hardware using ( defmt-test) on-target tests.</p><p>  在这篇文章中，我们已经看到了如何在没有使用模型和嵌入式硬件的情况下使用额外的硬件测试驱动程序箱，使用（defmt-test）目标测试。</p><p> So far in this post series we have seen tests that run on the host (the build machine) and tests that run on the target (e.g. a microcontroller).In the next blog post we&#39;ll introduce a third type of testing that&#39;s useful in the context of testing complete embedded applications.</p><p> 到目前为止在这篇文章系列中，我们已经看到了在主机（构建机器）上运行的测试和在目标上运行的测试（例如，微控制器）。在下一个博客文章我们＆＃39; LL介绍第三种类型的测试＃39;在测试完整嵌入式应用程序的上下文中有用。</p><p>  Knurling-rs is mainly  funded through GitHub sponsors. Sponsors get early access to the tools we are building and help us to support and grow the knurling tools and courses. Thank you to all of the people already sponsoring our work through the Knurling project!</p><p>  滚环-RS主要通过GitHub赞助商提供资金。赞助商从我们建造的工具获得早期访问，并帮助我们支持和发展滚花工具和课程。感谢所有人都通过滚花项目赞助我们的工作！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ferrous-systems.com/blog/test-driver-crate/">https://ferrous-systems.com/blog/test-driver-crate/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/司机/">#司机</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/driver/">#driver</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>