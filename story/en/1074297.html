<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在锈迹中编程是否更节能？Is It More Energy-Efficient to Program in Rust?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Is It More Energy-Efficient to Program in Rust?<br/>在锈迹中编程是否更节能？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 21:14:57</div><div class="page_narrow text-break page_content"><p>Rust is a programming language implemented as a set of open source projects. It combines the performance and resource efficiency of systems programming languages like C with the memory safety of languages like Java. Rust started as a research project at Mozilla in 2010, and Rust 1.0 launched in 2015. In 2020, support for Rust moved from Mozilla to the  Rust Foundation, a non-profit organization created as a partnership between Amazon Web Services, Inc (AWS), Google, Huawei, Microsoft, and Mozilla. The Foundation’s mission is to support the growth and innovation of Rust, and the member companies have grown from the founding 5 to 27 companies in the first year.</p><p>Rust是一种编程语言，作为一组开源项目实现。它将C等系统编程语言的性能和资源效率与Java等语言的内存安全结合起来。Rust于2010年作为Mozilla的一个研究项目启动，2015年推出Rust 1.0。在2020，支持锈从Mozilla转移到锈基金会，一个非盈利组织，作为亚马逊网络服务公司（AWS）、谷歌、华为、微软和Mozilla之间的伙伴关系而创建。该基金会的使命是支持锈菌的生长和创新，会员公司在第一年从5家公司发展到27家公司。</p><p>  At AWS, Rust has quickly become critical to building infrastructure at scale.  Firecracker is an open source virtualization technology that powers  AWS Lambda and other serverless offerings. It launched publicly in 2018 as our first notable product implemented in Rust. We use Rust to deliver services such as  Amazon Simple Storage Service (Amazon S3),  Amazon Elastic Compute Cloud (Amazon EC2),  Amazon CloudFront, and more. In 2020, we launched  Bottlerocket, a Linux-based container operating system written in Rust, and our Amazon EC2 team uses Rust as the language of choice for new  AWS Nitro System components, including sensitive applications, such as  Nitro Enclaves.</p><p>在AWS，锈蚀很快成为大规模建设基础设施的关键。鞭炮是一种开源虚拟化技术，为AWS Lambda和其他无服务器产品提供了支持。2018年，它作为我们在Rust实施的第一款著名产品公开发布。我们使用Rust来提供服务，比如亚马逊简单存储服务（Amazon S3）、亚马逊弹性计算云（Amazon EC2）、亚马逊CloudFront等等。2020年，我们推出了基于Linux的容器操作系统Bottlerocket，它是用Rust编写的，我们的亚马逊EC2团队使用Rust作为新的AWS Nitro系统组件的首选语言，包括敏感应用程序，如Nitro Enclaves。</p><p>  At AWS, we believe leaders create more than they consume and always leave things better than they found them. In 2019,  AWS was proud to become a sponsor of the Rust project. In 2020,  we started hiring Rust maintainers and contributors, and  we partnered with Google, Huawei, Microsoft, and Mozilla to create the Rust Foundation with a mission to support Rust. AWS is investing in the sustainability of Rust, a language we believe should be used to build sustainable and secure solutions.</p><p>在AWS，我们相信领导者创造的比他们消费的更多，并且总是比他们发现的更好。2019年，AWS自豪地成为Rust项目的赞助商。在2020，我们开始雇用锈病维护者和贡献者，我们与谷歌、华为、微软和Mozilla合作创建锈菌基金会，以支持锈病。AWS正在投资锈菌的可持续性，我们认为应该使用这种语言来构建可持续和安全的解决方案。</p><p>      Source: IEA (2021),  Global data centre energy demand by data centre type, 2010-2022, https://www.iea.org/data-and-statistics/charts/global-data-centre-energy-demand-by-data-centre-type-2010-2022. All rights reserved.</p><p>资料来源：IEA（2021年），按数据中心类型划分的全球数据中心能源需求，2010-2022年，https://www.iea.org/data-and-statistics/charts/global-data-centre-energy-demand-by-data-centre-type-2010-2022.版权所有。</p><p>  Worldwide,  data centers consume about 200 terawatt hours per year. That’s roughly 1% of all energy consumed on our planet. There are a couple of really interesting things about the details of that energy use. If you look at the graph of energy consumption, the top line is basically flat going back as far as 2010. That’s incredibly counter-intuitive give the tremendous growth of big data, machine learning, and edge devices our industry has experienced over that same period of time.</p><p>在全球范围内，数据中心每年消耗约200太瓦时。这大约是我们星球上所有能源消耗的1%。关于能源使用的细节，有几个非常有趣的事情。如果你看一看能源消耗的图表，可以追溯到2010年，顶线基本上是平的。这与我们的行业在同一时期经历的大数据、机器学习和边缘设备的巨大增长极为违背直觉。</p><p>  The second interesting detail is that while the top line of the graph is flat, inside the graph, the distribution over traditional, cloud, and hyperscale data centers has changed dramatically in the same period. Those cloud and hyperscale data centers have been implementing huge energy efficiency improvements, and the migration to that cloud infrastructure has been keeping the total energy use of data centers in balance despite massive growth in storage and compute for more than a decade.</p><p>第二个有趣的细节是，虽然图的顶线是平的，但在图中，传统、云和超规模数据中心的分布在同一时期发生了巨大变化。这些云计算和超规模数据中心一直在实施巨大的能效改进，而向云计算基础设施的迁移一直在保持数据中心的总能源使用平衡，尽管存储和计算在十多年来出现了巨大增长。</p><p>  There have been too many data center efficiency improvements to list, but here are a few examples. In compute, we’ve made efficiency improvements in hardware and implemented smarter utilization of resources to reduce idle time. We’ve slowed the growth of our servers with support for multi-instance and multi-tenant, and we’ve improved drive density and efficiency for storage. We’ve also adopted more energy efficient building materials and cooling systems.</p><p>有太多的数据中心效率改进需要列出，但这里有几个例子。在计算方面，我们在硬件方面进行了效率改进，并实现了更智能的资源利用，以减少空闲时间。通过支持多实例和多租户，我们减缓了服务器的增长，提高了存储的驱动器密度和效率。我们还采用了更节能的建筑材料和冷却系统。</p><p>  As incredible as that success story is, there are two questions it raises. First, is the status quo good enough? Is keeping data center energy use to 1% of worldwide energy consumption adequate? The second question is whether innovations in energy efficiency will continue to keep pace with growth in storage and compute in the future? Given the explosion we know is coming in autonomous drones, delivery robots, and vehicles, and the incredible amount of data consumption, processing, and machine learning training and inference required to support those technologies, it seems unlikely that energy efficiency innovations will be able to keep pace with demand.</p><p>尽管这个成功故事令人难以置信，但它提出了两个问题。首先，现状够好吗？将数据中心能耗保持在全球能耗的1%是否足够？第二个问题是，未来能源效率的创新是否会继续跟上存储和计算的增长？考虑到我们所知道的无人驾驶飞机、运载机器人和车辆的爆炸性增长，以及支持这些技术所需的难以置信的数据消耗、处理和机器学习培训和推理，能效创新似乎不太可能跟上需求。</p><p>    The energy efficiency improvements we’ve talked about so far have been the responsibility of AWS, but just like security, sustainability is a shared responsibility. AWS customers are responsible for energy efficient choices in storage policies, software design, and compute utilization, while AWS owns efficiencies in hardware, utilization features, and cooling systems. We are also making huge investments in renewable energy.</p><p>到目前为止，我们讨论的能效改进是AWS的责任，但就像安全一样，可持续性也是一项共同的责任。AWS客户负责在存储策略、软件设计和计算利用率方面进行节能选择，而AWS在硬件、利用率功能和冷却系统方面拥有效率。我们还在可再生能源方面进行巨额投资。</p><p>  AWS is on a path to have 100% of our data centers powered with renewable energy by 2025, but even renewables have an environmental impact. It will take about half a million acres of solar panels to generate the 200 terawatt hours of energy used by data centers today. The mining, manufacturing, and management of that many solar panels has substantial environmental impact. So, while we’re really proud of our success with renewable energy, as Peter DeSantis, SVP, AWS said at re:Invent 2020, “The greenest energy is the energy we don’t use.”</p><p>AWS有望在2025年前让我们的数据中心100%使用可再生能源，但即使是可再生能源也会对环境造成影响。目前数据中心使用的200太瓦时的能源将需要大约50万英亩的太阳能电池板。许多太阳能电池板的开采、制造和管理都会对环境产生重大影响。因此，正如AWS高级副总裁彼得·德桑蒂斯（Peter DeSantis）在re:Invent2020上所说，虽然我们对可再生能源的成功感到非常自豪，“最绿色的能源是我们不使用的能源。”</p><p>  Renewables should not replace energy efficiency as a design principle. In the same way that operational excellence, security, and reliability have been principles of traditional software design, sustainability must be a principle in modern software design. That’s why  AWS announced a sixth pillar for sustainability to the AWS Well-Architected Framework.</p><p>可再生能源不应取代能源效率作为设计原则。正如卓越操作、安全性和可靠性一直是传统软件设计的原则一样，可持续性也必须是现代软件设计的原则。这就是为什么AWS宣布了AWS良好架构框架的第六个可持续性支柱。</p><p>  What that looks like in practice is choices like relaxing SLAs for non-critical functions and prioritizing resource use efficiency. We can take advantage of virtualization and allow for longer device upgrade cycles. We can leverage caching and longer TTLs whenever possible. We can classify our data and implement automated lifecycle policies that delete data as soon as possible. When we choose algorithms for cryptography and compression, we can include efficiency in our decision criteria. Last, but not least, we can choose to implement our software in energy efficient programming languages.</p><p>在实践中，这看起来像是放松非关键功能的SLA，并优先考虑资源使用效率。我们可以利用虚拟化，并允许更长的设备升级周期。我们可以尽可能利用缓存和更长的TTL。我们可以对数据进行分类，并实施自动化的生命周期策略，以尽快删除数据。当我们选择加密和压缩算法时，我们可以将效率纳入决策标准。最后，但并非最不重要的是，我们可以选择用节能编程语言实现我们的软件。</p><p>    There was a really interesting study a few years ago that looked at the correlation between energy consumption, performance, and memory use. This is a really common conversation in sustainability. Given how little visibility we have into energy or carbon use by our services, is there a metric that can serve as a proxy? Can I look at my existing service dashboards with infrastructure costs, performance, memory, etc and use the trends I see to infer something about the trends in my service’s energy consumption?</p><p>几年前有一项非常有趣的研究，研究了能量消耗、性能和记忆使用之间的相关性。这是可持续发展领域的一个非常常见的话题。鉴于我们对服务业的能源或碳使用了解甚少，有没有一个指标可以作为替代指标？我是否可以查看现有的服务仪表盘，了解基础设施成本、性能、内存等，并使用我看到的趋势来推断服务能耗的趋势？</p><p>  What the study did is implement 10 benchmark problems in 27 different programming languages and measure execution time, energy consumption, and peak memory use. C and Rust significantly outperformed other languages in energy efficiency. In fact, they were roughly 50% more efficient than Java and 98% more efficient than Python.</p><p>这项研究所做的是用27种不同的编程语言实现10个基准问题，并测量执行时间、能耗和峰值内存使用。C和Rust在能源效率方面明显优于其他语言。事实上，它们的效率大约比Java高50%，比Python高98%。</p><p>    It’s not a surprise that C and Rust are more efficient than other languages. What is shocking is the magnitude of the difference. Broad adoption of C and Rust could reduce energy consumption of compute by 50% – even with a conservative estimate.</p><p>C和Rust比其他语言效率更高，这并不奇怪。令人震惊的是，差异之大。广泛采用C和Rust可以将compute的能耗降低50%——即使保守估计也是如此。</p><p>  So the question is why not use more C? The language and developer tools are extremely mature, and the size of the developer community is much bigger than Rust. During his keynote at Open Source Summit in 2021,  Linus Torvalds, the creator of Linux, acknowledged that implementing code in C can be like juggling chainsaws. As a lifelong C programmer, Torvalds knows that, “[C’s subtle type interactions] are not always logical [and] are pitfalls for pretty much anybody.”</p><p>所以问题是为什么不使用更多的C？语言和开发工具非常成熟，开发人员社区的规模比Rust大得多。在2021的开源峰会上，Linux的创建者Linus Torvalds承认在C中实现代码可以像玩链锯一样。作为一名终身的C程序员，托瓦尔兹知道，“[C的微妙类型交互]并不总是合乎逻辑的，而且对几乎所有人来说都是陷阱。”</p><p>  Torvalds called Rust the first language he’s seen that might actually be a solution. Rust delivers the energy efficiency of C without the risk of undefined behavior. We can cut energy use in half without losing the benefits of memory safety.</p><p>托瓦尔兹称生锈是他见过的第一种语言，实际上可能是一种解决方案。Rust提供了C的能量效率，而没有未定义行为的风险。我们可以在不失去记忆安全好处的情况下将能源消耗减半。</p><p>  Several analyses have concluded that more than 70% of the high severity CVEs that occur in C/C++ would be prevented by implementing those same solutions in Rust. In fact, the Internet Security Research Group (ISRG), the nonprofit that supports the Let’s Encrypt project, the Certificate Authority for 260 million websites, has a  goal to move all internet security sensitive infrastructure to Rust. The projects underway include support for Rust in the Linux kernel and migrating curl to Rust implementations of TLS and HTTP.</p><p>几项分析得出结论，在C/C++中发生的高严重性CVE中，70%以上可以通过在Rust中实施相同的解决方案来预防。事实上，支持Let’s Encrypt项目（2.6亿个网站的证书颁发机构）的非营利组织互联网安全研究小组（ISRG）的目标是让所有对互联网安全敏感的基础设施生锈。正在进行的项目包括在Linux内核中支持Rust，以及将curl迁移到TLS和HTTP的Rust实现。</p><p>      Looking again at that study about correlation, we have measurements for more than just energy consumption. The middle column shows the results for execution time, and the times for Rust and C are really similar. Both languages are executing faster than other languages. That means, when you choose to implement your software in Rust for the sustainability and security benefits, you also get the optimized performance of C.</p><p>再看看那项关于相关性的研究，我们得到的不仅仅是能源消耗的测量结果。中间一列显示了执行时间的结果，Rust和C的时间非常相似。这两种语言的执行速度都比其他语言快。这意味着，当您选择在Rust中实现软件以实现可持续性和安全性优势时，您还可以获得C的优化性能。</p><p>            Tenable is a cyber security solutions provider focused on exposure visibility tools, and they had a sidecar agent that filtered out unnecessary metrics. It was written in JavaScript and had been working in production for a few months when the performance started to degrade due to scaling. Tenable decided to rewrite the filter in a more efficient language, and they chose Rust for its performance and safety. The result was about a 50% improvement in latency at both the median and the P95.</p><p>Tenable是一家专注于曝光可见性工具的网络安全解决方案提供商，他们有一个sidecar代理，可以过滤掉不必要的指标。它是用JavaScript编写的，已经在生产环境中工作了几个月，但由于扩展，性能开始下降。Tenable决定用更高效的语言重写过滤器，他们选择Rust是因为它的性能和安全性。结果是，中位数和P95的潜伏期都提高了约50%。</p><p>        50% performance improvements are great, but here are some other graphs from that migration. Tenable also saw a 75% reduction in CPU usage and a 95% reduction in memory usage. That is substantial savings, and that’s not just dollars saved – that’s energy saved. These are the graphs of an energy efficient, sustainable implementation.</p><p>50%的性能改进是很好的，但下面是该迁移的一些其他图表。Tenable的CPU使用率和内存使用率分别降低了75%和95%。这是巨大的节约，这不仅仅是节约了美元，而是节约了能源。以下是节能、可持续实施的图表。</p><p>  Rust is being used today to ship real world production software, but developers aren’t choosing Rust to reduce carbon emissions. When we ask Rust developers why they started using Rust, by far the most common answer is some variant of runtime performance, whether it is because Rust is faster or because Rust has more reliable tail latencies. It’s almost always about performance.</p><p>如今，Rust正被用于运送真实世界的生产软件，但开发者并不是为了减少碳排放而选择Rust。当我们问Rust开发人员为什么开始使用Rust时，到目前为止，最常见的答案是运行时性能的一些变化，无论是因为Rust更快，还是因为Rust具有更可靠的尾部延迟。它几乎总是关于性能。</p><p>        Discord started as a mostly Python, Go, and Elixir shop, and they had a problem with one of their key Go services. It was a pretty simple service, but it had slow tail latencies. Because Go is a garbage collection (GC) language, as objects are created and released, every so often, the garbage collector needs to stop execution of the program and run a garbage collection pass. While the GC is running, the process is unable to respond to requests, and you can see the spikes on the CPU and response time graphs when it’s running.</p><p>Discord最初是一家以Python、Go和Elixir为主的商店，他们的一项关键Go服务出现了问题。这是一个非常简单的服务，但尾部延迟很慢。因为Go是一种垃圾收集（GC）语言，当对象被创建和释放时，垃圾收集器经常需要停止程序的执行并运行垃圾收集过程。当GC运行时，进程无法响应请求，并且在运行时可以看到CPU上的峰值和响应时间图。</p><p>      To fix the issue, Discord decided to try rewriting the service in Rust, and these are the results. The Go implementation is on the left and the Rust implementation is on the right. While the GC spike pattern is gone on the Rust graph, the really amazing difference is the magnitude of the change. The Go and Rust graphs are actually using different units.</p><p>为了解决这个问题，Discord决定尝试在Rust中重写服务，结果如下。Go实现在左边，Rust实现在右边。虽然GC尖峰模式在锈迹图上消失了，但真正惊人的区别是变化的幅度。Go和Rust图实际上使用了不同的单位。</p><p>  The Rust version is more than 10 times faster over all with the worst tail latencies reduced 100 times. These are incredible improvements, and because the server is able to respond to requests far more efficiently, fewer servers are needed, which means that less energy is used. While Discord didn’t decide to start using Rust to reduce energy consumption, that’s the impact.</p><p>生锈版本的速度是所有版本的10倍以上，最糟糕的尾部延迟减少了100倍。这些都是难以置信的改进，因为服务器能够更高效地响应请求，所以需要的服务器更少，这意味着使用的能源更少。虽然Discord没有决定开始使用生锈来减少能源消耗，但这就是影响。</p><p>  Again, Rust isn’t the first efficient language. C has been around for a long time, but Rust is the first mainstream programming language that is efficient without sacrificing safety. 70% of all high severity security vulnerabilities written with C and C++ are due to memory unsafety, and Rust gives you efficiency without feeling like you’re playing with fire.</p><p>再说一次，Rust并不是第一种高效的语言。C语言已经存在很长一段时间了，但Rust是第一种高效且不牺牲安全性的主流编程语言。在C和C++中写的所有严重的安全漏洞中，有70%是由于内存不安全，而生锈会给你带来效率，而不会感觉到你在玩火。</p><p>    Most languages achieve memory safety by automatically managing memory at runtime with a garbage collector. Garbage collectors track outstanding references to a piece of memory and when all references go out of scope, the associated memory can be freed.</p><p>大多数语言通过在运行时使用垃圾收集器自动管理内存来实现内存安全。垃圾收集器跟踪对内存块的未完成引用，当所有引用都超出范围时，可以释放关联的内存。</p><p>  Instead of using a garbage collector to maintain safety, Rust uses ownership and borrow checking. Ownership is fairly simple but has deep implications for the rest of the Rust programming language. In Rust, all memory is owned by a single variable. That variable is called its owner. There can be only one owner at a time, but ownership of the data can be passed around.</p><p>Rust没有使用垃圾收集器来维护安全，而是使用所有权和借阅检查。所有权相当简单，但对Rust编程语言的其他部分有着深刻的影响。在Rust中，所有内存都属于一个变量。该变量称为其所有者。一次只能有一个所有者，但数据的所有权可以传递。</p><p>    First, here is an example of message passing with Go. On the left side, we create a gift, then send it via the channel. On some other go routine on the right side, the gift is received and opened. The Go’s garbage collector is going to manage the memory for us. However, in the code on the left side, we accidentally opened the gift after sending it into the channel. The gift is going to be opened twice, resulting in a bug.</p><p>首先，这里是一个使用Go传递消息的示例。在左侧，我们创建一份礼物，然后通过通道发送。在右边的其他围棋程序中，礼物会被收到并打开。Go的垃圾收集器将为我们管理内存。然而，在左边的代码中，我们在将礼物发送到频道后意外打开了它。礼物将被打开两次，导致一个错误。</p><p>    Here is the same message passing example with Rust. The gift is created and assigned. We say that the `gift` variable owns the data. Ownership of the gift is passed into the channel. The channel consumer receives the gift, taking ownership, and is able to open it. If we try to open the gift after sending it into the channel, the compiler will shout at us, because we are violating the ownership rules. Already, we are seeing how Rust helps us prevent bugs.</p><p>下面是与Rust相同的消息传递示例。礼物被创造和分配。我们说'gift'变量拥有数据。礼物的所有权被转移到渠道中。渠道消费者收到礼物，获得所有权，并能够打开礼物。如果我们在将礼物发送到频道后试图打开它，编译器会对我们大喊大叫，因为我们违反了所有权规则。我们已经看到锈菌如何帮助我们预防虫子。</p><p>    Because Rust enforces the rule that only one variable owns data, when that variable goes out of scope  without passing off ownership, there is no possible way for the data to be accessed. Rust takes advantage of that and will automatically free the memory at that point. There is no need to manually free the memory.</p><p>因为Rust强制执行只有一个变量拥有数据的规则，所以当该变量超出范围而不冒充所有权时，就不可能访问数据。Rust利用了这一点，并将在该点自动释放内存。无需手动释放内存。</p><p>  Rust’s ownership model is part of the type system and based on a concept called  affine types. An affine type imposes a rule that every variable is used at most once. The key is to define what “used” means. In the context of Rust, a use is either moving the data or dropping it. By using affine types, the Rust compiler is able to reason about a program and enforce its ownership rules.</p><p>Rust的所有权模型是类型系统的一部分，基于一个称为仿射类型的概念。仿射类型规定每个变量最多使用一次。关键是定义“使用”的含义。在生锈的情况下，用户要么移动数据，要么丢弃数据。通过使用仿射类型，Rust编译器能够对程序进行推理并执行其所有权规则。</p><p>  The affine type system used by Rust is based on the work done in the early 1990s, when some folks attempted to design a garbage collector free lisp. While successful, they found that they lost a lot of runtime performance due to the excessive copying introduced by not being able to have multiple references to the same piece of data.</p><p>Rust使用的仿射类型系统基于上世纪90年代初的工作，当时一些人试图设计一个无垃圾收集器的lisp。虽然取得了成功，但他们发现，由于无法对同一数据段进行多个引用而引入的过度复制，他们失去了很多运行时性能。</p><p>    And this gets us to the second innovation that has enabled Rust: the borrow checker. When writing larger programs we tend to use abstractions to help organize ideas. One abstraction that you’re probably familiar with is a function. Functions often require arguments. With only ownership, to call a function, we would need to pass ownership of the data into the function and the function would need to pass ownership of the data back when returning. This requires copying memory around and was the source of garbage collector-less lisp performance challenges.</p><p>这就让我们看到了第二个让锈迹得以存在的创新：借阅检查器。在编写大型程序时，我们倾向于使用抽象来帮助组织想法。你可能熟悉的一种抽象是函数。函数通常需要参数。如果只有所有权，要调用函数，我们需要将数据的所有权传递给函数，函数需要在返回时将数据的所有权传递回。这需要复制周围的内存，并且是无垃圾收集器lisp性能挑战的根源。</p><p>    To solve this, Rust lets you borrow data. So, if we have a gift, we own it it. It is ours. If our friend wants to admire it, she can borrow it for a moment, but then she has to give it back to us. Also, while our friend is borrowing the gift, we cannot hand off ownership of the gift to anyone else, because it is currently being borrowed. Most crucially, the Rust compiler enforces these rules, so our friend can’t just run off with the gift. And because the Rust compiler enforces that guarantee, when borrowing data, memory doesn’t have to be copied. The memory stays where it is, and a pointer is passed around. The pointer is guaranteed to be valid. When you put it all together, you have a system that is efficient and prevents bugs, even as the program gets larger and more complex.</p><p>为了解决这个问题，Rust允许您借用数据。所以，如果我们有天赋，我们就拥有它。这是我们的。如果我们的朋友想欣赏它，她可以借一会儿，但她必须把它还给我们。此外，当我们的朋友借礼物时，我们不能将礼物的所有权移交给其他任何人，因为礼物目前正在被借。最关键的是，Rust编译器执行这些规则，所以我们的朋友不能带着礼物跑了。由于Rust编译器强制执行这一保证，因此在借用数据时，不必复制内存。内存保持在原来的位置，并传递指针。指针保证是有效的。当你把它们放在一起，你就有了一个高效的系统，可以防止错误，即使程序变得更大、更复杂。</p><p>  And the same system that prevents memory unsafety can also prevent data races, a category of concurrency bug. A data race happens when two or more threads are concurrently accessing the same data and at least one of those accesses is a mutation. The type system that models ownership and borrowing is able to uphold the same guarantee across multiple threads, enabling more aggressive use of concurrency.</p><p>防止内存不安全的系统也可以防止数据竞争，这是一种并发错误。当两个或多个线程同时访问同一数据，且其中至少一个访问是变异时，就会发生数据竞争。对所有权和借用进行建模的类型系统能够跨多个线程维护相同的保证，从而更积极地使用并发性。</p><p>      Here is an example of how easy it can be to safely add concurrency to a Rust application. We have a function that iterates through an array of numbers and sums all even numbers. This is a highly parallelizable operation and for very large arrays, we could see the function getting significantly faster by adding concurrency.</p><p>下面是一个例子，说明了向Rust应用程序安全地添加并发性是多么容易。我们有一个函数，它遍历一个数字数组，并对所有偶数求和。这是一个高度可并行化的操作，对于非常大的阵列，我们可以看到通过添加并发性，函数的速度显著加快。</p><p>  The left side shows a single threaded version and the right side shows you the parallel version using the rayon library. And look at how similar the functions are. You get all the power of concurrency, without the hazards, by basically writing the same code. The only difference is that we use the par_iter() method instead of iter().</p><p>左侧显示单线程版本，右侧显示使用人造丝库的并行版本。看看这些功能有多相似。通过基本上编写相同的代码，您可以在没有危险的情况下获得并发的所有功能。唯一的区别是我们使用par_iter（）方法而不是iter（）。</p><p>  The parallel version will spread the computation across many threads, all while avoiding copying the array of numbers being passed as the argument. Rayon is able to provide this API safely thanks to Rust’s ownership and borrow checking system. All the checks to guarantee safety happen at compile time.</p><p>并行版本将把计算扩展到多个线程，同时避免复制作为参数传递的数字数组。由于Rust的所有权和借阅检查系统，人造丝能够安全地提供这种API。所有保证安全的检查都发生在编译时。</p><p>    Hopefully, by now we have gotten you interested in Rust and starting your journey of sustainability in the cloud. So where to start? The good news is, all the content you need is available online and there are places you can go to get started.</p><p>希望到现在为止，我们已经让你们对锈迹感兴趣，并开始你们在云端的可持续发展之旅。那么从哪里开始呢？好消息是，你需要的所有内容都可以在网上获得，你可以去一些地方开始。</p><p>  First, you will need to learn the Rust programming language.  The Rust book is an excellent resource to get started learning the language. It will help you get the Rust toolchain installed and teach you the language. The website also has exercises and lots of code examples to read. If you get stuck at any point, have questions, or need clarification, you can post on the user forum or talk directly on the community Discord server. The Discord server is usually the fastest way to get help. There are always people active there who can answer questions in real time.</p><p>首先，您需要学习Rust编程语言。铁锈书是开始学习语言的绝佳资源。它将帮助你安装Rust工具链，并教你该语言。该网站还提供练习和大量代码示例供阅读。如果你在任何时候遇到困难、有问题或需要澄清，你可以在用户论坛上发帖或直接在社区Discord服务器上聊天。Discord服务器通常是获得帮助的最快方式。那里总是有活跃的人可以实时回答问题。</p><p>  Once you have gone through the Rust website, you should be comfortable enough to start building things, but there is another resource we want to call out for diving deeper. The  Crust of Rust is a great youtube channel by Jon Gjenset. He does really deep dives on various Rust related topics, popping the hood and explaining how things work. His videos are multiple hours long, but we keep hearing from people how valuable they are for learning Rust.</p><p>一旦你浏览了Rust网站，你应该会很舒服地开始建造东西，但我们还需要另一个资源来深入挖掘。《锈壳》是Jon Gjenset的youtube频道。他确实深入研究了各种与生锈有关的话题，揭开了引擎盖，解释了事情是如何运作的。他的视频长达数小时，但我们不断听到人们说这些视频对学习锈菌有多么重要。</p><p>            Rust is challenging to learn. Of the more than 8,000 developers responding to the 2020 Rust user survey, only about 100 identified as “expert”, and of the respondents that said they were no longer using Rust, 55% cited learning or productivity as their reason for abandoning the language.</p><p>铁锈很难学。在对2020年Rust用户调查做出回应的8000多名开发者中，只有大约100人被认定为“专家”，在表示不再使用Rust的受访者中，55%的人认为学习或生产力是他们放弃该语言的原因。</p><p>  It takes experienced engineers 3-6 months of study, supported by access to subject matter experts, to become productive with Rust. Some engineers have likened learning Rust to learning to eat your vegetables, and while many of them love it once they are productive, a lot of engineers are deciding against learning it or abandoning the effort before they become productive. The potential impact of Rust on sustainability and security will only materialize if we turn the broccoli into a brownie.</p><p>经验丰富的工程师需要3-6个月的研究，并获得主题专家的支持，才能在生锈问题上取得成效。一些工程师将学习锈病比作学习吃蔬菜，虽然他们中的许多人一旦有了生产力就喜欢锈病，但许多工程师决定不学习锈病，或者在他们变得有生产力之前放弃努力。锈病对可持续性和安全性的潜在影响只有在我们把西兰花变成巧克力饼时才会显现出来。</p><p>        No one developer, service, or corporation can deliver substantial impact on sustainability. Adoption of Rust is like recycling; it only has impact if we all participate. To achieve broad adoption, we are going to have to grow the developer community.</p><p>没有一家开发商、服务或公司能够对可持续性产生实质性影响。采用锈迹就像回收；只有我们都参与，它才会产生影响。为了实现广泛的采用，我们必须发展开发者社区。</p><p>  The Rust developer community has been the fastest growing over the last two years, but based on historical trends, we know that of the half million developers that joined the Rust community in the last 12 months, most of them are not yet proficient with the language. We have some work to do on the Rust developer experience.</p><p>Rust开发者社区在过去两年中增长最快，但根据历史趋势，我们知道，在过去12个月加入Rust社区的50万开发者中，大多数人还不精通该语言。我们在Rust developer体验方面还有一些工作要做。</p><p>  The question that raises is which developer experience? Engineers working on the Linux kernel have a very different ideal developer experience than an engineer building a database service or an engineer delivering a retail website. We can identify the Rust user personas by look</p><p>提出的问题是哪种开发者体验？与构建数据库服务的工程师或提供零售网站的工程师相比，开发Linux内核的工程师有着截然不同的理想开发体验。我们可以通过外观识别用户角色</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/efficient/">#efficient</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>