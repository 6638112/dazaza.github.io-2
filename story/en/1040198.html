<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>不使用偏移量进行分页（2014） Do Not Use Offset for pagination (2014)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Do Not Use Offset for pagination (2014)<br/>不使用偏移量进行分页（2014） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-17 05:06:15</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/8260d28dfd4f27ed8ca9b474b478b009.png"><img src="http://img2.diglog.com/img/2020/12/8260d28dfd4f27ed8ca9b474b478b009.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>offset instructs the databases skip the first N results of a query. However, the database must still fetch these rows from the disk and bring them in order before it can send the following ones.</p><p>offset指示数据库跳过查询的前N个结果。但是，数据库仍必须从磁盘中获取这些行并将它们按顺序排列，然后才能发送以下行。</p><p>  …the rows are first sorted according to the &lt;order by clause&gt; and then limited by dropping the number of rows specified in the &lt;result offset clause&gt; from the beginning…</p><p>  …首先根据＆lt; order by子句＆gt;对行进行排序然后通过删除＆lt; result offset子句＆gt;中指定的行数来进行限制。从最开始…</p><p> There crucial point here is that  offset takes only one single parameter: the number of rows to be dropped. No more context. The only thing the database can do with this number is fetching and dropping that many rows. In other words, big  offsets impose a lot of work on the database—no matter whether SQL or  N o S Q L.</p><p> 这里最关键的一点是offset仅需要一个参数：要删除的行数。没有更多的上下文。数据库唯一可以使用此数字的方法是提取和删除那么多行。换句话说，无论SQL还是N Q S L，大的偏移量都会在数据库上增加很多工作。</p><p> But the trouble with  offset doesn’t stop here: think about what happens if a new row is inserted between fetching two pages?</p><p> 但是偏移问题并不仅限于此：想一想如果在获取两个页面之间插入新行会发生什么情况？</p><p>  When using  offset➌ to skip the previously fetched entries❶, you’ll get duplicates in case there were new rows inserted between fetching two pages➋. There are other anomalies possible too, this is just the most common one.</p><p>  当使用offset➌跳过先前提取的条目❶时，如果在提取两个页面之间插入了新行➋，则会得到重复。也可能存在其他异常，这只是最常见的一种。</p><p> This is not even a database problem, it is the way frameworks implement pagination: they just say which page number to fetch or how many rows to skip. With this information alone, no database can do any better.</p><p> 这甚至不是数据库问题，而是框架实现分页的方式：它们只是说要提取哪个页号或跳过多少行。仅凭此信息，任何数据库都无法做得更好。</p><p>   The root problem all these methods have in common is that they just provide a number of rows to be dropped—no more context. In this article, I’m using  offset to refer to any of these methods.</p><p>   这些方法共有的根本问题是它们只提供了许多要删除的行，而没有更多的上下文。在本文中，我将使用offset来指代任何这些方法。 </p><p>  Now imagine a world without these problems. As it turns out, living without  offset is quite simple: just use a  where clause that selects only data you haven’t seen yet.</p><p>现在想象一个没有这些问题的世界。事实证明，没有偏移的生活非常简单：只需使用where子句，仅选择您尚未看到的数据即可。</p><p> For that, we exploit the fact that we work on an ordered set—you do have an  order by clause, ain’t you? Once there is a definite sort order, we can use a simple filter to only select what follows the entry we have see last:</p><p> 为此，我们利用了一个有序集合这一事实，即您确实有一个order by子句，不是吗？一旦有了确定的排序顺序，我们就可以使用简单的过滤器来选择最后看到的条目后面的内容：</p><p> SELECT ... FROM ... WHERE ... AND id &lt; ?last_seen_id ORDER BY id DESC FETCH FIRST 10 ROWS ONLY</p><p> SELECT ... FROM ... WHERE ... AND ID＆lt; ？last_seen_id ORDER BY ID DESC仅获取前10行</p><p> This is the basic recipe. It gets more interesting when sorting on multiple columns, but the idea is the same. This recipe is also applicable to many  N o S Q L systems.</p><p> 这是基本的食谱。当对多列进行排序时，它变得更加有趣，但是想法是相同的。此配方也适用于许多N Q S L系统。</p><p> This approach—called  seek method or  keyset pagination—solves the problem of drifting results as illustrated above and is even faster than  offset. If you’d like to know what happens inside the database when using  offset or keyset pagination, have a look at  these slides (benchmarks, benchmarks!):</p><p> 这种方法（称为搜索方法或键集分页）解决了如上所述的结果漂移问题，甚至比偏移更快。如果您想了解使用偏移量或键集分页时数据库内部发生的情况，请查看以下幻灯片（基准，基准！）：</p><p>  On  slide 43 you can also see that keyset pagination has some limitations: most notably that you cannot directly navigate to arbitrary pages. However, this is not a problem when using infinite scrolling. Showing page number to click on is a poor navigation interface anyway—IMHO.</p><p>  在幻灯片43上，您还可以看到键集分页有一些限制：最值得注意的是，您不能直接导航到任意页面。但是，使用无限滚动时这不是问题。无论如何，显示要单击的页码都是糟糕的导航界面-IMHO。</p><p> If you want to read more about how to properly implement keyset pagination in SQL, please read  this article. Even if you are not involved with SQL, it’s worth reading  that article before starting to implement anything.</p><p> 如果您想了解有关如何在SQL中正确实现键集分页的更多信息，请阅读本文。即使您不参与SQL，也应该在开始实施任何内容之前先阅读该文章。 </p><p>  The main reason to prefer  offset over keyset pagination is the lack of tool support. Most tools offer pagination based on  offset, but don’t offer any convenient way to use keyset pagination.</p><p>首选偏移而不是键集分页的主要原因是缺少工具支持。大多数工具都提供基于偏移量的分页，但是没有提供使用键集分页的任何便捷方法。</p><p> Please note that keyset pagination affects the whole technology stack up to the JavaScript running in the browser doing AJAX for infinite scrolling: instead of passing a simple page number to the server, you must pass a full keyset (often multiple columns) down to the server.</p><p> 请注意，键集分页会影响整个技术堆栈，直到在浏览器中运行的JavaScript进行AJAX无限滚动：您必须将完整的键集（通常为多列）传递给服务器，而不是将简单的页码传递给服务器。</p><p>   This is where I need your help. If you are maintaining a framework that is somehow involved with pagination, I ask you, I urge you, I beg you, to build in native support for keyset pagination too. If you have any questions about the details, I’m happy to help ( forum,  contact form,  Twitter)!</p><p>   这是我需要您帮助的地方。如果您正在维护某种与分页有关的框架，请问您，我恳请您也为键集分页建立本机支持。如果您对详细信息有任何疑问，我们很乐意为您提供帮助（论坛，联系表，Twitter）！</p><p> Even if you are just using software that should support keyset pagination such as a content management system or webshop, let the maintainers know about it. You might just file a feature request (link to this page) or, if possible, supply a patch. Again, I’m happy to help out getting the details right.</p><p> 即使您只是在使用应支持键集分页的软件（例如内容管理系统或网上商店），也要让维护者知道这一点。您可能只提交了功能请求（链接到此页面），或者，如果可能的话，提供了补丁程序。同样，我很乐意帮助您正确处理细节。</p><p>   The problem with key-set pagination is not a technical one. The problem is just that it is hardly known in the field and has no tool support. If you like the idea of  offset-less pagination, please help spreading the word.  Tweet it,  share it,  mail it, you can even re-blog this post ( CC-BY-NC-ND). Translations are also welcome, just contact me beforehand—I’ll include a link to the translation on this page too!</p><p>   键集分页的问题不是技术问题。问题在于它在该领域鲜为人知并且没有工具支持。如果您喜欢无偏移分页的想法，请帮助推广。发推，分享，邮寄，您甚至可以重新博客此帖子（CC-BY-NC-ND）。也欢迎翻译，请事先与我联系-我还将在此页面上提供指向翻译的链接！</p><p> Oh, and if you are blogging, you could also add a banner on your blog to make your readers aware of it. I’ve prepared a  NoOffset banner gallery with some common banner formats. Just pick what suits you best.</p><p> 哦，而且如果您是博客用户，也可以在博客上添加横幅，以使读者意识到这一点。我准备了具有一些常见横幅格式的NoOffset横幅库。只要选择最适合您的。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://use-the-index-luke.com/no-offset">https://use-the-index-luke.com/no-offset</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/偏移量/">#偏移量</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/offset/">#offset</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>