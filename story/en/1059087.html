<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>解剖Apple M1 GPU，第III部分 Dissecting the Apple M1 GPU, Part III</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Dissecting the Apple M1 GPU, Part III<br/>解剖Apple M1 GPU，第III部分 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-19 22:12:50</div><div class="page_narrow text-break page_content"><p>After a few weeks of investigating the Apple M1 GPU in January, I was able to  draw a triangle with my own open source code. Although I began dissecting the instruction set, the shaders there were specified as machine code. A real graphics driver needs a compiler from high-level shading languages (GLSL or Metal) to a native binary. Our understanding of the M1 GPU’s instruction set has advanced over the past few months. Last week, I began writing a free and open source shader compiler targeting the Apple GPU. Progress has been rapid: at the end of its first week, it can compile both basic vertex and fragment shaders, sufficient to render 3D scenes. The spinning cube pictured above has its shaders written in idiomatic GLSL, compiled with the nascent free software compiler, and rendered with native code like the first triangle in January. No proprietary blobs here!</p><p>在1月份调查Apple M1 GPU的几个星期后，我能够使用自己的开源代码绘制三角形。虽然我开始解剖指令集，但指定为机器代码的着色器。真正的图形驱动程序需要从高级着色语言（GLSL或金属）的编译器到原生二进制文件。我们对M1 GPU指令集的理解已在过去几个月中提出。上周，我开始编写一个针对Apple GPU的免费和开源着色器编译器。进度很快：在第一周结束时，它可以编译基本顶点和片段着色器，足以渲染3D场景。上图所示的旋转立方体具有以惯用的GLSL编写的着色器，与新鲜的Free Software编译器编译，并在1月份的第一个三角形等本机代码呈现。这里没有专有的斑点！</p><p> Over the past few months,  Dougall Johnson has investigated the instruction set in-depth, building on my initial work. His  findings on the architecture are outstanding, focusing on compute kernels to complement my focus on graphics. Armed with his notes and my command stream tooling, I could chip away at a compiler.</p><p> 在过去的几个月里，Dougall Johnson已经调查了深入的指令，建立了我的初始工作。他对架构的调查结果很出色，专注于计算内核，以补充我对图形的关注。用他的笔记和我的命令流制品武装，我可以在编译器上剪切。</p><p> The compiler’s design must fit into the development context.  Asahi Linux aims to run a Linux desktop on Apple Silicon, so our driver should follow Linux’s best practices like upstream development. That includes using the  New Intermediate Representation (NIR) in Mesa, the home for open source graphics drivers. NIR is a lightweight library for shader compilers, with a GLSL frontend and backend targets including Intel and AMD. NIR is an alternative to  LLVM, the compiler framework  used by Apple. Just because Apple prefers LLVM doesn’t mean we have to. A team at Valve famously  rewrote AMD’s LLVM backend as a NIR compiler, improving performance. If it’s good enough for Valve, it’s good enough for me.</p><p> 编译器的设计必须适合开发背景。 Asahi Linux旨在在Apple Silicon上运行Linux桌面，因此我们的司机应遵循Linux的最佳实践，如上游开发。这包括在MESA中使用新的中间表示（NIR），为开源图形驱动程序中的家庭。 NIR是一个用于着色器编译器的轻量级库，具有GLSL前端和包括英特尔和AMD的后端目标。 NIR是LLVM的替代方案，Apple使用的编译器框架。仅仅因为苹果喜欢llvm并不意味着我们必须。阀门的一支团队着名被重写了AMD的LLVM后端作为NIR编译器，提高性能。如果它足够好的阀门，这对我来说足够了。</p><p> Supporting NIR as input does not dictate our compiler’s own intermediate representation, which reflects the hardware’s design. The instruction set of AGX2 (Apple’s GPU) has:</p><p> 支持NIR作为输入不决定我们的编译器自己的中间代表，这反映了硬件的设计。 AGX2（Apple的GPU）的指令集具有：</p><p>   Vector values at the periphery separated with vector combine and extract pseudo-instructions, optimized out during register allocation.</p><p>   矢量值在外围分离为载体组合并提取伪指令，在寄存器分配期间优化。</p><p>  Sources and destinations are sized. The optimizer folds size conversion instructions into uses and definitions.</p><p>  来源和目的地是大小的。优化器将大小转换指令折叠为使用和定义。</p><p> Sources have absolute value and negate bits; instructions have a saturate bit. Again, the optimizer folds these away.</p><p> 来源具有绝对值和否定位;说明具有饱和位。同样，优化器将这些折叠折叠。 </p><p> A large register file means running out of registers is rare, so don’t optimize for register spilling performance.</p><p>一个大的寄存器文件意味着寄存器略有罕见，因此不要优化寄存器溢出性能。</p><p> Minimizing register pressure is crucial. Use static single assignment (SSA) form to facilitate pressure estimates, informing optimizations.</p><p> 最小化寄存器压力至关重要。使用静态单分配（SSA）表单以促进压力估计，通知优化。</p><p> The scheduler simply reorders instructions without leaking details to the rest of the backend. Scheduling is feasible both before and after register allocation.</p><p> 调度程序只需重新排序“指令”而不泄漏到后端其余部分的详细信息。在注册分配之前和之后，调度是可行的。</p><p> Putting it together, a design for an AGX compiler emerges: a  code generator translating NIR to an SSA-based intermediate representation,  optimized by instruction combining passes,  scheduled to minimize register pressure,  register allocated while going out of SSA,  scheduled again to maximize instruction-level parallelism, and finally  packed to binary instructions.</p><p> 将其放在一起，agx编译器的设计出现：将NIR转换为基于SSA的中间表示的代码生成器，通过指令组合传递优化，计划最小化寄存器压力，在从SSA外面的同时分配的寄存器，再次调度以最大化指令 - 灵活性，最后包装到二进制指令。</p><p> These decisions reflect the hardware traits visible to software, which are themselves “shadows” cast by the hardware design. Investigating these traits offers insight into the hardware itself. Consider the register file. While every thread can access up to 256 half-word registers, there is a performance penalty: the more registers used, the fewer concurrent threads possible, since threads share a register file. The number of threads allowed in a given shader is reported in Metal as the  maxTotalThreadsPerThreadgroup property. So, we can study the register pressure versus occupancy trade-off by varying the register pressure of Metal shaders (confirmed via our disassembler) and correlating with the value of  maxTotalThreadsPerThreadgroup:</p><p> 这些决策反映了软件可见的硬件特征，它们本身是“阴影”由硬件设计施放。调查这些特征可以深入了解硬件本身。考虑注册文件。虽然每个线程可以访问最多256个半字寄存器，但有一个性能损失：使用的寄存器越多，可能的并发线程越多，因为线程共享寄存器文件。在金属作为MaxTotalThreadSperThreadGreadGreadGreadGroupGroupGroup属性中报告给定的着色器中允许的线程数。因此，我们可以通过改变金属着色器的寄存器压力来研究寄存器压力与占用速度，通过MAXTOTALTHREADSPERTHREADGROUP的价值与MAXTOTALTHREADSPERTHREADGROUP的价值相关：</p><p>  From the table, it’s clear that up until a threshold, it doesn’t matter how many registers the program uses; occupancy is unaffected. Most well-written shaders fall in this bracket and need not worry. After hitting the threshold, other GPUs might spill registers to memory, but Apple doesn’t need to spill until more than 256 registers are required. Between 112 and 256 registers, the number of threads decreases in an almost linear fashion, in increments of 64 threads. Carefully considering rounding, it’s easy to recover the formula Metal uses to map register usage to thread count.</p><p>  从桌面上，明确才能直到阈值，这并不重要，这些寄存器使用了多少;占用率不受影响。最精良的着色器落在这个括号内，不必担心。在击中阈值后，其他GPU可能会向内存泄露寄存器，但苹果不需要溢出，直到需要超过256个寄存器。在112和256寄存器之间，线程数以几乎线性的方式减少，以64个线程为增量。仔细考虑舍入，恢复配方金属用于将寄存器用法映射到螺纹计数很容易。</p><p> What’s less obvious is that we can infer the size of the machine’s register file. On one hand, if 256 registers are used, the machine can still support 384 threads, so the register file must be at least 256 half-words * 2 bytes per half-word * 384 threads = 192 KiB large. Likewise, to support 1024 threads at 104 registers requires at least 104 * 2 * 1024 = 208 KiB. If the file were any bigger, we would expect more threads to be possible at higher pressure, so we guess each threadgroup has exactly 208 KiB in its register file.</p><p> 什么不太明显的是，我们可以推断机器的注册文件的大小。一方面，如果使用256个寄存器，则机器仍然可以支持384个线程，因此寄存器文件必须至少为256个半字* 2字节/每半词* 384线程= 192kib大。同样地，在104寄存器处支持1024个线程，需要至少104 * 2 * 1024 = 208kib。如果该文件有任何更大，我们会期望在更高的压力下需要更多的线程，因此我们猜测每个线程组在其寄存器文件中有208个Kib。 </p><p> The story does not end there. From Apple’s public specifications, the M1 GPU supports 24576 = 1024 * 24 simultaneous threads. Since the table shows a maximum of 1024 threads per threadgroup, we infer 24 threadgroups may execute in parallel across the chip, each with its own register file. Putting it together, the GPU has 208 KiB * 24 = 4.875 MiB of register file! This size puts it in league with desktop GPUs.</p><p>这个故事没有结束那里。来自Apple的公共规格，M1 GPU支持24576 = 1024 * 24同时线程。由于该表显示了每个ThreadGroup最多1024个线程，因此我们推断24个线程组可以在芯片上并行执行，每个芯片都有其自己的寄存器文件。将其放在一起，GPU有208个Kib * 24 = 4.875 MIB的注册文件！这种大小将其与桌面GPU联盟。</p><p> For all the visible hardware features, it’s equally important to consider what hardware features are absent. Intriguingly, the GPU lacks some fixed-function graphics hardware ubiquitous among competitors. For example, I have not encountered hardware for reading vertex attributes or uniform buffer objects. The OpenGL and Vulkan specifications assume dedicated hardware for each, so what’s the catch?</p><p> 对于所有可见硬件功能，考虑不存在的硬件功能同样重要。有趣的是，GPU缺乏竞争对手普遍存在的一些固定功能图形硬件。例如，我没有遇到用于读取顶点属性或均匀缓冲对象的硬件。 OpenGL和vutkan规范为每个人假设专用硬件，所以捕获是什么？</p><p> Simply put – Apple doesn’t need to care about Vulkan or OpenGL performance. Their only properly supported API is their own Metal, which they may shape to fit the hardware rather than contorting the hardware to match the API. Indeed, Metal de-emphasizes vertex attributes and uniform buffers, favouring general constant buffers, a compute-focused design. The compiler is responsible for translating the fixed-function attribute and uniform state to shader code. In theory, this has a slight runtime cost; conventional wisdom says dedicated hardware is faster and lower power than software emulation. In practice, the code is so simple it may make no difference, although application developers should be mindful of the vertex formats used in case conversion code is inserted. As always, there is a trade-off: omitting features allows Apple to squeeze more arithmetic logic units (or register file!) onto the chip, speeding up everything else.</p><p> 简单地说 - 苹果不需要关心vulkan或OpenGL性能。他们唯一适当支持的API是他们自己的金属，它们可以塑造以适应硬件而不是扭曲硬件以匹配API。实际上，金属解除了顶点属性和均匀缓冲区，优先达到一般恒定缓冲器，以计算为中心的设计。编译器负责将固定功能属性和统一状态转换为着色器代码。从理论上讲，这有轻微的运行时间成本;传统智慧表示专用硬件比软件仿真更快，功耗较低。在实践中，代码如此简单，它可能没有任何区别，尽管应用程序开发人员应该注意在插入转换代码时使用的顶点格式。一如既往，有一个折衷：省略功能允许Apple将更多算术逻辑单元（或寄存器文件！）挤压到芯片上，加快其他一切。</p><p> The more significant concern is the increased time on the CPU spent compiling shaders. If changing fixed-function attribute state can affect the shader, the compiler could be invoked at inopportune times during random OpenGL calls. Here, Apple has another trick: Metal requires the layout of vertex attributes to be specified when the pipeline is created, allowing the compiler to specialize formats at no additional cost. The OpenGL driver pays the price of the design decision; Metal is exempt from shader recompile tax.</p><p> 更重要的问题是CPU花费编译着色器的增加时间。如果更改的固定函数属性状态会影响着色器，则可以在随机OpenGL呼叫期间在Inopportune时调用编译器。在这里，Apple具有另一个技巧：金属需要在创建流水线时要指定的顶点属性的布局，允许编译器以不额外的成本专门化格式。 OpenGL司机支付设计决定的价格;金属免于着色器重新编译税。</p><p> The silver lining is that there is nothing to reverse-engineer for “missing” features like attributes and uniform buffers. As long as we know how to access memory in compute kernels, we can write the lowering code ourselves with no hardware mysteries. So far, I’ve implemented enough to spin a cube.</p><p> 银色衬里是“缺少”特征，如属性和均匀缓冲区，没有任何反向工程师。只要我们知道如何在Compute Kernels中访问内存，我们就可以编写下降代码，没有硬件谜团。到目前为止，我已经实现了足以旋转立方体。</p><p> At present, the in-progress compiler supports most arithmetic and input/output instructions found in OpenGL ES 2.0, with a simple optimizer and native instruction packing. Support for control flow, textures, scheduling, and register allocation will come further down the line as we work towards a real driver.</p><p> 目前，正在进行的编译器支持OpenGL ES 2.0中的大多数算术和输入/输出指令，具有简单的优化器和本机指令包。支持控制流，纹理，调度和注册分配将在朝向真正的驱动程序工作时进一步下降。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://rosenzweig.io/blog/asahi-gpu-part-3.html">https://rosenzweig.io/blog/asahi-gpu-part-3.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寄存器/">#寄存器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>