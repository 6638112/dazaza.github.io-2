<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>AWS Lambda赢得了胜利，但首先它不得不消亡 AWS Lambda is winning, but first it had to die</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">AWS Lambda is winning, but first it had to die<br/>AWS Lambda赢得了胜利，但首先它不得不消亡 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-19 01:58:10</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/6f0496e5df7bf239ccf2ced132ba3258.jpg"><img src="http://img2.diglog.com/img/2020/12/6f0496e5df7bf239ccf2ced132ba3258.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Major feature changes have successfully pushed Lambda workloads into the mainstream, even if FaaS purists feel betrayed</p><p>重大功能更改已成功将Lambda工作负载推向主流，即使FaaS纯粹主义者感到背叛</p><p>  If you ask AWS, they’ll say  definitely. Nearly half of all new applications built inside Amazon this year are  running on Lambda. Andy Jassy took time in his re:Invent keynote to call out the thousands of enterprises who now run Lambda workloads in production, but perhaps most interesting was that this year the new serverless feature announcements graduated to Jassy’s keynote — a spot usually reserved for the flashiest, most strategic reveals of the year. AWS, at least, clearly believes that serverless is now one of the primary selling points for its cloud.</p><p>  如果您问AWS，他们肯定会说。今年，在亚马逊内部构建的所有新应用程序中，几乎有一半在Lambda上运行。安迪·贾西（Andy Jassy）在他的re：Invent主题演讲中花了一些时间，召集了成千上万现在在生产中运行Lambda工作负载的企业，但也许最有趣的是，今年新的无服务器功能公告逐渐转变为贾西（Jassy）的主题演讲-通常是最华丽的地方，是一年中最具战略意义的内容。至少，AWS明确认为无服务器现在是其云的主要卖点之一。</p><p> (On the other hand, there’s  this odd article, which spends most of its length demonstrating FaaS growth, but ran under the headline “Serverless Adoption Stalls” because … Kubernetes teams say they aren’t using as much Lambda? In other news, cats report eating fewer vegetables.)</p><p> （另一方面，有一篇很奇怪的文章，它的大部分时间都在说明FaaS的增长，但是却以“无服务器采用失速”为标题，因为…Kubernetes团队说他们没有使用太多的Lambda？报告少吃蔬菜。）</p><p> What’s not in debate is that Lambda, still the 900-pound gorilla of FaaS, looks a lot different today than when it went GA in 2015. The  loud, weird niche of engineers who bought into serverless early have always had  very specific ideas about what good serverless systems look like … and lately, Lambda’s been rattling their assumptions.</p><p> 没有争议的是，Lambda仍然是FaaS的重达900磅的大猩猩，今天看起来与2015年发布GA时大不相同。大声，怪异的利基市场的工程师们早早地购买了无服务器，他们对什么有一个非常具体的想法好的无服务器系统看起来像……最近，Lambda一直在推敲自己的假设。</p><p>  Those original ideals of FaaS purity didn’t just materialize out of thin air. As recently as 2016, AWS serverless leadership was talking up something they called the Serverless Compute Manifesto. This was a radical vision for how Functions-as-a-Service should, uh, function. The manifesto showed up at  all sorts of talks, including  at ACG’s ServerlessConf. Here are its key tenets:</p><p>  最初的FaaS纯度理想并不仅仅是凭空实现的。就在2016年，AWS无服务器领导层开始谈论他们称之为“无服务器计算宣言”的事情。这是功能即服务应如何运作的根本愿景。宣言出现在各种演讲中，包括ACG的ServerlessConf。以下是其主要宗旨：</p><p>   This manifesto formed a shocking and highly countercultural blueprint for how to build and deploy software. It attracted a small but vibrant community of true believers and a somewhat larger and much louder set of skeptics.</p><p>   该宣言为如何构建和部署软件形成了令人震惊且高度反文化的蓝图。它吸引了一个规模很小但生机勃勃的真正信徒团体，以及一些更大更响亮的怀疑论者。</p><p> But in retrospect, the serverless compute manifesto had trouble penetrating beyond that small, engaged nucleus. The bold vision just left out too many existing, legacy workloads and teams.</p><p> 但是回想起来，无服务器计算宣言很难渗透到那个小的，参与的核心。大胆的愿景只是遗漏了太多的现有遗留工作负载和团队。 </p><p> So, gradually, like the commandments in Orwell’s  Animal Farm, AWS’s non-negotiables of serverless compute began to change. Let’s run through each point of the manifesto and see if Lambda still adheres to it.</p><p>因此，逐渐地，就像奥威尔（Orwell）的动物农场中的诫命一样，AWS的无服务器无协议计算的不可商议性开始发生变化。让我们遍历宣言的每个要点，看看Lambda是否仍然遵守宣言。</p><p>  Sorta, but not strictly. You can deploy multi-function Lambda Layers to manage large binaries, or (now in preview) Lambda Extensions to plug in third-party agents that I’ve been told should definitely not be thought of as “sidecars for Lambda”.</p><p>  Sorta，但不严格。您可以部署多功能Lambda层来管理大型二进制文件，也可以（现在处于预览状态）部署Lambda Extensions来插入第三方代理，我听说这绝对不应该被视为“ Lambda的辅助工具”。</p><p>  No longer true. As of re:Invent 2020, Lambda  now allows you to bring your own containers instead of just shipping a ZIP file of code.</p><p>  不再如此。从re：Invent 2020开始，Lambda现在允许您带上自己的容器，而不仅仅是运送ZIP文件。</p><p>  Not necessarily. Lambda now integrates with EFS, which I guess is technically “elsewhere”, but no more so than any other NFS share attached to a server is “elsewhere”. It’s a persistent filesystem mounted to your compute.</p><p>  不必要。 Lambda现在与EFS集成，从技术上讲，我认为它是“在其他地方”，但是与附加到服务器的任何其他NFS共享相比，“在其他地方”没有更多。这是安装在您的计算机上的持久文件系统。</p><p>  Yes! Now that Lambda can run containers, I believe the request model is now the biggest remaining conceptual difference between Lambda and a managed container service like AWS Fargate. Lambda gives you a new execution environment per concurrent request, whereas a Fargate-like service will still process multiple concurrent requests on the same (long-lived) container.</p><p>  是!现在Lambda可以运行容器了，我认为请求模型现在是Lambda与托管容器服务（例如AWS Fargate）之间最大的概念差异。 Lambda为每个并发请求提供了一个新的执行环境，而类似Fargate的服务仍将在同一个（长期存在的）容器上处理多个并发请求。</p><p>  No longer true. Meet Provisioned Capacity, which trades your cold start problem for a hot cost problem. (I snark, but Provisioned Capacity is way better than running your own Lambda pre-warming job, which a LOT of people used to do.)</p><p>  不再如此。满足预置容量，它将您的冷启动问题换成热成本问题。 （我偷偷摸摸，但“预配置容量”比运行自己的Lambda预热作业好很多，以前很多人都这样做。）</p><p>    Ehhhh. This one is about abstracting away availability zones, which a lot of higher-level AWS services besides Lambda (including Fargate!) now do. That said, we’re starting to hear more guidance from AWS that really, the fault domain you need to be thinking about is regions. That’s right: regions are the new availability zones, and savvy Lambda developers are rolling their own (very un-managed) multi-region architectures as we speak.</p><p>    恩这是关于抽象出可用区，除了Lambda（包括Fargate！）之外，现在还有许多更高级别的AWS服务。就是说，我们开始从AWS那里听到更多的指导，实际上，您需要考虑的故障域是区域。没错：区域是新的可用区域，而精明的Lambda开发人员正在推出他们自己的（非常不受管理的）多区域架构。 </p><p> To reinforce the trend, let’s check in with two other defining early features of Lambda:</p><p>为了加强趋势，让我们检查一下Lambda的其他两个定义性早期功能：</p><p>  Less and less true. Function disk sizes, runtime limits, and CPU and memory sizes have steadily increased over the last 5 years. Today you can run a Lambda function for 15 minutes with 10 GB of memory and 6 vCPUs – a hefty enough blob of compute to make you think seriously about multi-threading, multi-purpose functions, and other things that are against the old ideals of FaaS.</p><p>  越来越少的真实。在过去的5年中，功能磁盘的大小，运行时限制以及CPU和内存的大小稳步增长。今天，您可以使用10 GB内存和6个vCPU在Lambda函数上运行15分钟，这是一个足够大的计算量，足以使您认真考虑多线程，多用途函数以及其他与之相反的理想做法。 FaaS。</p><p>  Only if you want it. In the old days, Lambda architectures biased heavily toward IAM security rather than using VPCs, partly for ideological reasons but also because attaching functions to custom ENIs added tremendous cold start overhead. Today, innovation from AWS has made customer-managed VPCs much more compatible with Lambda.</p><p>  只要你想要。在过去，Lambda体系结构严重偏向于IAM安全性，而不是使用VPC，部分原因是出于意识形态原因，而且还因为将功能附加到自定义ENI上增加了巨大的冷启动开销。如今，AWS的创新使客户管理的VPC与Lambda更加兼容。</p><p>    I feel like Willy Wonka at the end of the chocolate factory tour, looking around to see where all the children went. Of all those ideological principles, those lines in the sand,  per-request scaling is the only thing left.</p><p>    巧克力工厂之旅结束时，我感觉像威利·旺卡（Willy Wonka），环顾四周，看看所有孩子们都去了哪里。在所有这些意识形态原则中，每条要求的缩放比例都是唯一的问题。</p><p> You can still build according to the original serverless manifesto, of course. But the service doesn’t  require you to.</p><p> 当然，您仍然可以根据原始的无服务器宣言进行构建。但是该服务不需要您。</p><p> If you had to distill the revised value prop of Lambda down into a single maxim,  Animal Farm-style, what would you even say at this point? “ All workloads are managed, but some are more managed than others?“</p><p> 如果您不得不将Lambda的修订后的价值支柱精炼成动物农场风格的单一格言，那么您现在会说什么？ “所有工作负载都得到管理，但是有些工作负载比其他工作负载更受管理？”</p><p>  This seems like the right time to clarify that I mostly like the additions to Lambda. I think they are necessary and in many cases, an unmixed good.</p><p>  现在似乎是时候来说明我最喜欢Lambda的新增功能了。我认为它们是必要的，并且在许多情况下是不可混和的商品。 </p><p> I wouldn’t have said that four years ago. I was much more of a FaaS purist at that time. What changed my mind was years of hearing a very particular type of statement from engineering teams, repeated over and over in different variations:</p><p>四年前我不会这么说。那时我更像是FaaS纯粹主义者。让我改变主意的是，多年以来，听到了工程团队的非常特殊的陈述，并以不同的形式反复出现：</p><p> I would love to use Lambda, if only it …  [connected back to my on-prem VPC, was big enough to run my workload, let me use the same language or developer tooling as my other systems, was always warm, supported some form of shared storage, etc, etc]</p><p> 我想使用Lambda，如果可以的话……[连接回我的本地VPC，足以应付我的工作量，让我使用与其他系统相同的语言或开发人员工具，一直很热情，支持某种形式共享存储等）</p><p> My first reaction to these statements was: Why would you want to use Lambda if you can’t or won’t embrace stateless, containerless, scale-to-zero functions? That’s the whole  point of Lambda. It sounded to me like those Kubernetes cats from the New Stack survey, saying they’d really like to eat vegetables if they only contained more meat.</p><p> 我对这些陈述的第一个反应是：如果无法或不支持无状态，无容器，从零缩放到零的函数，为什么要使用Lambda？这就是Lambda的重点。在我看来，这就像来自《 New Stack》调查中的那些Kubernetes猫，说如果它们只含有更多的肉，它们真的很想吃蔬菜。</p><p> But I’ve since come to understand that the really powerful part of that statement is the beginning part. It’s a statement of longing.</p><p> 但自那以后，我开始理解该声明的真正强大部分是开始部分。这是渴望的声明。</p><p>  What is it about Lambda, and serverless compute in general, that inspires this reaction in so many people? Why does a brand-new baby computing paradigm spark such compulsive interest everywhere from tiny startups to big ol’ legacy enterprises?</p><p>  Lambda和一般的无服务器计算到底是什么激发了这么多人的反应？为什么从小型初创公司到大型OL传统企业，全新的婴儿计算范式都会引起如此强烈的兴趣？</p><p> Because more than any specific technical detail, serverless computing is an idea. An idea expressed in a simple phrase:  Own less, build more. All the serverless doctrine, all the technical guidance boils down to this goal. Lambda is an aspirational lifestyle.</p><p> 因为无处不在，所以无服务器计算是一个主意。用一个简单的词组表达一个想法：少拥有，多建设。所有无服务器的学说，所有技术指导都可以归结为这一目标。 Lambda是一种理想的生活方式。</p><p> Lambda, circa 2016, was massively ahead of its time, and to some extent still is. But because of the new feature additions, up to and including container support, it’s making the  own less, build more identity more accessible to more builders than ever before.</p><p> 大约在2016年的Lambda大大领先于它的时代，并且在某种程度上仍然如此。但是，由于增加了新功能（包括容器支持，包括容器支持），因此与以往相比，它使自己的东西更少，构建更多的身份对于更多的构建者更易于访问。 </p><p> What AWS is doing is, one by one, taking away the  if onlys . They’re removing reflexive objections to serverless by providing reassuring options — shared storage, provisioned capacity — for teams that need them.  I’d love to use Lambda!</p><p>AWS正在做的是一个接一个地删除if onlys。他们通过为需要它们的团队提供令人放心的选项（共享存储，已配置的容量）来消除对无服务器的反感。我很想使用Lambda！</p><p>  Will some teams use these features out of confusion or inertia, not realizing that they could build something more radical, more manifesto-like? Yes, and I think this is an area where AWS can do a lot more to help.</p><p>  某些团队是否会出于混乱或惯性使用这些功能，而没有意识到他们可以构建更激进，更像宣言的东西？是的，我认为这是AWS可以提供​​更多帮助的领域。</p><p> Look, the Lambda console is a mess – you know it, I know it, AWS knows it. It’s got more tacked-on feature creep and incoherent UX paths than a 2001 VCR. And say what you will about infrastructure-as-code, the console is still how people explore new services. It’s how they form feelings about what kind of builders they want to be.</p><p> 看起来，Lambda控制台是一团糟–您知道，我知道，AWS也知道。与2001年的VCR相比，它具有更完善的功能蠕变和不连贯的UX路径。并说出您对基础架构即代码的看法，控制台仍然是人们探索新服务的方式。他们如何对自己想要成为什么样的建筑商产生感觉。</p><p> A console redesign is needed for sure, but not just an arbitrary facelift. We need one that foregrounds the Lambda features that support the original manifesto: code-level programming abstractions, function-level deployments. And then a careful reveal of progressive complexity as you push up against the limits of the manifesto or your own organizational constraints. (Is there such a thing as “regressive complexity”? Because that’s the current console.)</p><p> 当然，需要重新设计控制台，而不仅仅是重新设计。我们需要一个能够支持原始宣言的Lambda功能的应用程序：代码级编程抽象，功能级部署。然后，在您突破宣言的限制或您自己的组织约束条件时，仔细揭示渐进式复杂性。 （是否存在“递归复杂性”之类的东西？因为这是当前的控制台。）</p><p> What you want is for builders to be confronted with the simpler, more managed options every time they start a new project. Over time, that changes people’s perceptions. It constantly presents them with the “serverless way”: hey, I could build this using events! I don’t need to put this function in a VPC! Defaults matter. I look forward to seeing how AWS can continue to guide its customers toward success here.</p><p> 您想要的是使构建者在每次开始新项目时都要面对更简单，更受管理的选项。随着时间的流逝，这会改变人们的看法。它不断以“无服务器方式”向他们展示：嘿，我可以使用事件来构建它！我不需要将此功能放在VPC中！默认值很重要。我期待看到AWS如何在这里继续指导其客户取得成功。</p><p> In the meantime, Lambda is finally gaining serious adoption, finally winning, because it’s shedding the FaaS purism that marked its early days — without compromising on its real value prop, the progressive promise of  own less, build more. The serverless compute manifesto had to die so the promise of serverless could finally live.</p><p> 同时，Lambda最终获得了认真的采用，最终赢得了胜利，因为它摆脱了标志着其早期发展的FaaS纯粹主义-在不损害其真正价值的前提下，逐渐减少拥有自己的东西，建立更多的东西。无服务器计算宣言必须消亡，这样无服务器的承诺才能最终实现。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://acloudguru.com/blog/engineering/aws-lambda-is-winning-but-first-it-had-to-die">https://acloudguru.com/blog/engineering/aws-lambda-is-winning-but-first-it-had-to-die</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/lambda/">#lambda</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>