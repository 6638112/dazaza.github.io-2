<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在数据库迁移期间保持数据一致性Keep Data Consistency During Database Migration</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Keep Data Consistency During Database Migration<br/>在数据库迁移期间保持数据一致性</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-30 11:14:00</div><div class="page_narrow text-break page_content"><p>When a system has been live for a long time, it’s not rare to use newer technologies to improve performance, maintainability, or add new features. One of such changes can be which database to use. This can be the most difficult kind of change. During the migration, there are two data sources, which makes it a distributed system. Make data consistent under a distributed system is very hard and can easily go wrong. In this article, we will explore a way to keep the data consistent during the migration, and maintain a low downtime at the same time.</p><p>系统运行了很长时间后，使用更新的技术来提高性能，可维护性或添加新功能的情况并不少见。这些更改之一可以是使用哪个数据库。这可能是最困难的一种更改。在迁移期间，有两个数据源，这使其成为一个分布式系统。在分布式系统下使数据一致非常困难，而且很容易出错。在本文中，我们将探索一种在迁移过程中保持数据一致并同时保持较低停机时间的方法。</p><p>   The source database can be dumped with a consistent view and mark the position in data change logs.</p><p>   可以使用一致的视图转储源数据库，并在数据更改日志中标记位置。</p><p>   The clients only write to one of the databases at a given time. So we can avoid distributed transaction which is error prone and slow.</p><p>   客户端仅在给定时间写入数据库之一。因此，我们可以避免容易出错且速度较慢的分布式事务。</p><p>  We make the switch of database by setup the database permissions. It’s faster than switch from client code and easier to make sure to switch all the clients.</p><p>  我们通过设置数据库权限来切换数据库。它比切换客户端代码更快，并且更容易确保切换所有客户端。</p><p>   First, we need to dump the source database with a consistent view. And mark the position we’ve dumped. For example, in MySQL, you can use  mysqldump with  --master-data to dump the database with a bin log position. ( Document about the usage). After we get all the data from source database, we can insert them into the target database.</p><p>   首先，我们需要使用一致的视图转储源数据库。并标记我们已转储的位置。例如，在MySQL中，可以将mysqldump与--master-data一起使用以转储带有bin日志位置的数据库。 （有关用法的文件）。从源数据库获取所有数据后，可以将它们插入目标数据库。</p><p> Since this is the first step, it’s very easy to handle failure: just start again from beginning. So it’s very important to capture any error while import the dumped data.</p><p> 由于这是第一步，因此很容易处理失败：只需从头开始即可。因此，在导入转储的数据时捕获任何错误非常重要。</p><p>  The next step is to use the capture data changes from the source database. For example, in MySQL, you can use  bin log to capture the changes and insert them to the target database. Since we have the start position from last step, we know where to start parse and import the changes.</p><p>  下一步是使用源数据库中的捕获数据更改。例如，在MySQL中，您可以使用bin日志捕获更改并将其插入目标数据库。由于我们具有从上一步开始的位置，因此我们知道从哪里开始解析并导入更改。</p><p> It’s very important to keep order of the changes while importing. So it’s better to use only one process to parse and import the changes. This part is challenging: the performance matters here.  The time to sync all the changes is the downtime we need for migration.</p><p>导入时保持更改顺序非常重要。因此，最好只使用一个过程来解析和导入更改。这部分具有挑战性：这里的性能很重要。同步所有更改的时间是我们迁移所需的停机时间。</p><p> We also need to make sure we don’t miss any changes or import any changes multiple times even there are system failures. So it’s very important to record the change log position. It’s convenience to write the position into the target database with the same transaction that imports the data. So the position will be synced with the data we imported.</p><p> 我们还需要确保即使系统出现故障，也不会遗漏任何更改或多次导入任何更改。因此，记录更改日志位置非常重要。使用导入数据的同一事务将头寸写入目标数据库很方便。因此，该位置将与我们导入的数据同步。</p><p>  The easy way to keep data consistency is to have a single source of truth. Until now, we are using the source database as the source of truth and sync changes to the target database. We don’t want to mess up the target database with other writes. So we need to setup the target database permission to deny all the writes from clients. For example, in MySQL, you can grant only  select permission to the table for the clients and deny other operations. We allow the read permission so that we can compare the read results at the next step.</p><p>  保持数据一致性的简单方法是只有一个事实来源。到现在为止，我们将源数据库用作真相源，并将更改同步到目标数据库。我们不想用其他写操作弄乱目标数据库。因此，我们需要设置目标数据库权限以拒绝来自客户端的所有写操作。例如，在MySQL中，您只能为客户端授予对该表的选择权限，并拒绝其他操作。我们允许读取权限，以便我们可以在下一步比较读取结果。</p><p>  The next step is to make the clients to read and write both source and target databases.</p><p>  下一步是使客户端读取和写入源数据库和目标数据库。</p><p> We want to read/write source database first. Use this result if there is no permission error, use the read/write result from target database otherwise.</p><p> 我们要先读/写源数据库。如果没有权限错误，请使用此结果，否则请使用目标数据库的读/写结果。</p><p>  Before switch to the target database, we can verify the target database works as expected by compare read results and write operations. Note that the target database may have lag to sync up, so the results may not always the same. But we can have an understanding of the correctness based on the percentage of same results.</p><p>  在切换到目标数据库之前，我们可以通过比较读取结果和写入操作来验证目标数据库是否按预期工作。请注意，目标数据库可能无法同步，因此结果可能并不总是相同。但是我们可以基于相同结果的百分比来了解正确性。</p><p>  After we switch to the target database, the read/write results will be used as the real results.</p><p>  切换到目标数据库后，读/写结果将用作实际结果。</p><p> If you want to make sure the target database can handle the load, it’s a good idea to allow read/write to the target database for a while .But it’s just as a verification, the data in the target database will not be consistent after that. So after we verify the target database can handle the traffic, we need to cleanup the target database and start from step 1 again. (We don’t need to modify the client code during the steps).</p><p>如果要确保目标数据库可以处理负载，建议您允许一段时间对目标数据库进行读/写操作，但这只是一个验证，之后目标数据库中的数据将不一致。 。因此，在确认目标数据库可以处理流量之后，我们需要清理目标数据库并再次从步骤1开始。 （在这些步骤中，我们不需要修改客户端代码）。</p><p>  Only use target database result if there is permission error from source database. Throw other errors from source database.</p><p>  如果源数据库中存在权限错误，则仅使用目标数据库结果。从源数据库引发其他错误。</p><p>  Ignore errors for the target database if the result is not used but make sure to log them, so that it will not affect the current operation while also make sure we don’t have errors before the switch.</p><p>  如果未使用结果，请忽略目标数据库的错误，但请确保将其记录下来，以免影响当前操作，同时确保切换前没有错误。</p><p>  1db_operation() {   2 try {   3 source_result = source_db_operation()   4 } catch (PermissionException e) {   5 return target_db_operation()   6 }   7 async {   8 // do the following things async so it will not impact the performance   9 try {   10 target_result = target_db_operation()  11 compare_result(source_result, target_result)  12 } catch (Exception e) {  13 log_error(e)  14 }  15 }  16 return source_result  17}</p><p>  1db_operation（）{2试试{3 source_result = source_db_operation（）4} catch（PermissionException e）{5 return target_db_operation（）6} 7 async {8 //异步执行以下操作，因此不会影响性能9 try {10 target_result = target_db_operation（）11 compare_result（source_result，target_result）12} catch（Exception e）{13 log_error（e）14} 15} 16 return source_result 17}</p><p> 5. Deny access to the source database from clients and wait for changes to by synced</p><p> 5.拒绝客户端访问源数据库，并等待同步更改</p><p> After we are confident with the read and write to the target database, we can make the switch. We switch the database by change the database permissions. First, we deny all the access to the source database from clients. Then we wait for the changes to be full synced to the target database. During this time, the system is down. So how fast the changes are synced from source database to target database determines how much down time it will be.</p><p> 在对目标数据库的读取和写入充满信心之后，我们可以进行切换。我们通过更改数据库权限来切换数据库。首先，我们拒绝客户端对源数据库的所有访问。然后，我们等待更改完全同步到目标数据库。在此期间，系统已关闭。因此，更改从源数据库到目标数据库的同步速度决定了停机时间。</p><p>  After the target database is fully synced, we can enable the target database permission for all the clients. After this, the system should be online again and the database is fully switched over.</p><p>  目标数据库完全同步后，我们可以为所有客户端启用目标数据库权限。此后，系统应再次联机并且数据库已完全切换。</p><p>  It’s good if everything works well so far. But that may not always the case. Maybe the target database cannot handle the new traffic (that’s why it’s important to test it in step 4). In this case, we need fallback to the source database.</p><p>到目前为止一切都很好，这很好。但这并非总是如此。也许目标数据库无法处理新流量（这就是为什么在步骤4中对其进行测试很重要的原因）。在这种情况下，我们需要回退到源数据库。</p><p> If it’s fine to lost committed data during the migration time, it would be relatively easy to fallback:</p><p> 如果在迁移期间丢失已提交的数据很好，则回退相对容易：</p><p> Allow access to the source database. After this, the clients should be using the source database again.</p><p> 允许访问源数据库。此后，客户端应再次使用源数据库。</p><p> If it’s critical to save the committed data and make sure they are consistent, then before step 5, we should setup a mechanism to capture changes from target database to source database, and mark the change position after step 6. Then the fallback steps would be:</p><p> 如果保存提交的数据并确保它们一致是至关重要的，那么在步骤5之前，我们应该建立一种机制来捕获从目标数据库到源数据库的更改，并在步骤6之后标记更改位置。 ：</p><p> Sync from target database to source database (make sure to stop it after fully synced).</p><p> 从目标数据库同步到源数据库（确保在完全同步后停止它）。</p><p> The sync from target database to source database is very dangerous and hard to test, so it’s really important to test the target database can handle the operations in step 4.</p><p> 从目标数据库到源数据库的同步非常危险且难以测试，因此测试目标数据库可以处理步骤4中的操作非常重要。</p><p>  Once the database is switched to the target database, we can cleanup the code that access the source database. Then the database is fully migrated and you can enjoin it!</p><p>  一旦数据库切换到目标数据库，我们就可以清理访问源数据库的代码。然后数据库将完全迁移，您可以加入它！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/database/">#database</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>