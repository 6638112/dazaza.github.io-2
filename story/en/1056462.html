<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我讨厌PostgreSQL的10件事（2020） 10 Things I Hate About PostgreSQL (2020)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">10 Things I Hate About PostgreSQL (2020)<br/>我讨厌PostgreSQL的10件事（2020） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-06 16:45:15</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/a5bb0f3f5c3e7e877bbdc0cd33ba8cee.png"><img src="http://img2.diglog.com/img/2021/4/a5bb0f3f5c3e7e877bbdc0cd33ba8cee.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Over the last few years, the software development community’s love affair with the popular open-source relational database has reached a bit of a fever pitch. This  Hacker News thread covering a piece titled  “PostgreSQL is the worlds’ best database”, busting at the seams with fawning sycophants lavishing unconditional praise, is a perfect example of this phenomenon.</p><p>在过去的几年里，软件开发社区与流行开源关系数据库的爱情发生了一点发烧间距。这种黑客新闻线覆盖着名为“PostgreSQL的世界最佳数据库”，在宣传Sycophants奢侈品无条件赞美的接缝处破坏，是这种现象的一个完美典范。</p><p> While much of this praise is certainly well-deserved, the lack of  meaningful dissent left me a bit bothered.  No software is perfect, so  exactly what are PostgreSQL’s imperfections?</p><p> 虽然大部分赞美肯定应该得到很好的，但缺乏有意义的异议让我感到有点困扰。没有软件是完美的，所以究竟是什么PostgreSQL的瑕疵？</p><p> I’ve been hands- on with PostgreSQL in production since 2003 with deployments ranging from small (gigabytes) to modest to very large (~petabyte). My perspective is largely from building and running systems that are at least  intended to be continuously available. Needless to say, I have gained first-hand experience with PostgreSQL’s particular idiosyncrasies through some painful production issues over the years.</p><p> 自2003年以来，我一直在生产PostgreSQL，从小（千兆字节）到谦虚到非常大的部署（〜Petabyte）。我的观点主要来自建设和运行系统，这些系统至少打算不断使用。毋庸置疑，我多年来通过一些痛苦的产量问题获得了PostgreSQL的特殊特质的一手经验。</p><p>  Read more here. Suffice to say, this one can bite  hard.  There are many stories of multi-day outages caused by this issue. Go ahead, Google it and you’ll find numerous poor souls writing about the time they stepped on this landmine. Pretty much any non-trivial PostgreSQL install that isn’t staffed with a top expert will run into it eventually.</p><p>  阅读更多。足以说，这个人可以咬人吧。这个问题导致的多日中断有很多故事。继续，谷歌它，你会发现众多贫困的灵魂写作他们踩到这个地雷的时间。几乎没有任何与顶级专家的非琐碎的PostgreSQL安装最终会遇到它。</p><p> It’s likely that, at some point in the future, XIDs will transition to use 64-bit integers, but until then, we’re stuck with it. I guess at least we can be thankful that there is a process which prevents it from happening as a matter of course,  unlike some   airplane software .</p><p> 它可能会在将来的某些时候，xids将转换为使用64位整数，但直到那时，我们陷入困境。我猜至少我们可以感谢有一个过程，这是防止它发生的过程，而不是一些飞机软件。</p><p>  The run-of-the-mill streaming replication setup will almost certainly lose committed data if the active master suddenly fails.  “Such is the price of   asynchronous replication ,” some might say, but it doesn’t have to be this way. PostgreSQL supports synchronous replication with quorum commit for fault-tolerant durability, but it has a   much tighter performance envelope that complicates its application.</p><p>  如果活动主站突然失败，则磨坊流媒体Replication Setup几乎肯定会丢失承诺数据。 “这就是异步复制的价格，”有些人可能会说，但它不一定是这样的。 PostgreSQL支持具有容错耐用性的Quorum提交的同步复制，但它具有更紧密的性能包络，使其应用​​程序复杂化。</p><p> Waiting doesn’t utilize system resources, but transaction locks continue to be held until the transfer is confirmed.  As a result, incautious use of synchronous replication will reduce performance for database applications because of increased response times and higher contention.</p><p> 等待不利用系统资源，但在确认传输之前继续保持事务锁。因此，由于增加的响应时间和更高的争用，不断使用同步复制的使用将降低数据库应用程序的性能。 </p><p> This  bolt-on quorum replication is useful in a pinch, but I hesitate to recommend it for general-purpose use cases. It is similar to  Kafka’s ISR replication with acks=all and a quorum min_isr, but with all the nuanced complexity of a transactional relational database running arbitrary queries. I’m not currently aware of a successful application of quorum commit for highly-available, high-durability replication at non-trivial scale. If you have, reach out!</p><p>这种螺栓频率复制在捏捏中是有用的，但我犹豫推荐用于通用用例。它与Kafka的ISR复制类似于ACKS =全部和仲裁Min_ISR，但具有运行任意查询的事务关系数据库的所有细微复杂性。我目前不知道在非琐碎尺度上成功地应用了Quorum提交的高耐用性复制。如果你有，伸出去吧！</p><p> In terms of relational databases,  Galera Cluster’s group replication is also imperfect, but  closer to the ideal. They even  encourage geo-distributed replication, which would very likely be disastrous for a PostgreSQL replication setup using quorum commit.</p><p> 就关系数据库而言，Galera Cluster的组复制也是不完美的，但更接近理想。他们甚至鼓励地理分布式复制，这对于使用仲裁提交的PostgreSQL复制设置很可能是灾难性的。</p><p>  Streaming Replication is by far the most utilized replication mechanism in production deployments. It is a form of physical replication, meaning that it replicates changes in the on-disk binary data itself.</p><p>  流媒体复制是迄今为止生产部署中最利用的复制机制。它是物理复制的一种形式，这意味着它复制了磁盘二进制数据本身的变化。</p><p> Every time an on-disk database page (8KB) needs to be modified by a write operation, even just a single byte, a copy of the entire page, edited with the requested changes, is written to the  write-ahead log (WAL). Physical streaming replication leverages this existing WAL infrastructure as a log of changes it streams to replicas.</p><p> 每次通过写入操作都需要修改磁盘数据库页面（8KB），甚至只是单个字节，均使用所请求的更改编辑的整个页面的副本，写入预先写入日志（WAL） 。物理流复制将该现有WAL基础架构利用它作为将其流到副本的更改的日志。</p><p> Update: Some folks have pointed out that PostgreSQL only needs to do this full-page write once per WAL checkpoint. This is true, but in most real-world systems most writes will end up on a unique page between checkpoints, following a power law distribution. More importantly though: when anticipating system behavior, the right approach is assuming the more expensive case, particularly if it depends on hard-to-predict and highly dynamic behavior of the application.</p><p> 更新：有些人指出PostgreSQL每个WAL检查点只需要执行此全页。这是真的，但在大多数现实世界的系统中，大多数写作最终会在电力法分布之后的检查点之间的独特页面上。更重要的是：当预期系统行为时，正确的方法是假设更昂贵的情况，特别是如果它取决于应用程序的难以预测和高度动态的行为。</p><p> With physical replication, a large index build, for instance, creates a huge flood of WAL entries which can easily bottleneck the replication stream. The read-modify-replicate process at page-granularity can lead to  hardware-induced data corruption on the master  much more easily propagating to replicas, which I’ve personally witnessed several times in production.</p><p> 具有物理复制，例如，大索引构建，创建了大量的WAL条目，可以轻松瓶颈瓶颈。页面粒度的读取修改 - 复制过程可以导致主机上的硬件引起的数据损坏，更容易传播到副本，我在生产中亲自见证了多次。</p><p> This is in contrast to logical replication, which only replicates  logical data changes. At least theoretically, a large index build would only result in a single command replicated across the network. While PostgreSQL has supported  logical replication for quite some time, most deployments use physical streaming replication because it is more robust, more broadly supported, and much easier to use.</p><p> 与逻辑复制相比，这与逻辑复制相反，只能复制逻辑数据更改。至少从理性地，大索引构建只会导致在网络上复制的单个命令。当PostgreSQL支持相当一段时间的逻辑复制时，大多数部署都使用物理流复制，因为它更加强大，更广泛地支持，更容易使用。 </p><p>  Like most mainstream databases, PostgreSQL uses multi-version concurrency control (MVCC) to implement concurrent transactions. However, its particular implementation often introduces operational pain around garbage row versions and their cleanup ( VACUUM). Generally speaking,  UPDATE operations create new copies (or “row versions”) of any modified rows,  leaving the old versions on disk until they can be cleaned up.</p><p>与大多数主流数据库一样，PostgreSQL使用多版本并发控制（MVCC）来实现并发事务。然而，其特殊实施经常在垃圾行版本周围引入操作疼痛及其清理（真空）。一般来说，更新操作创建任何修改行的新副本（或“行版本”），将旧版本留在磁盘上，直到可以清理它们。</p><p> While this situation has steadily improved over the years, it’s a complex system that is a bit of a black box for anyone approaching the problem for the first time. For instance, knowing about  Heap-Only Tuples (HOT) and when it kicks in can be make-or-break for heavy update-in-place workloads like maintaining a consistent counter column in a row. The default autovacuum setup  does work  most of the time, but when it doesn’t,  good lord.</p><p> 虽然多年来这种情况稳步提高，但它是一个复杂的系统，这是一个黑匣子，因为任何一个都是第一次接近这个问题的黑匣子。例如，了解只有堆的元组（热），并且当它踢出时可以是用于维护一致的计数器列的重新更新的工作负载的制作或中断。默认的Autovacuum Setup在大多数情况下工作，但是当它没有时，良好的主。</p><p> In contrast, MySQL and Oracle use redo and undo logs. They don’t need a similar background garbage collection process. The trade-off they make is mostly additional latency for transactional commit and rollback operations.</p><p> 相比之下，MySQL和Oracle使用重做和撤消日志。它们不需要类似的背景垃圾收集过程。权衡他们使他们的交易提交和回滚操作的额外延迟。</p><p> It could be that at some point in the distant future,  zheap saves us all.</p><p> 它可能是在遥远的未来的某些时候，Zheap拯救了我们所有人。</p><p>  PostgreSQL forks a process for every connection, where as most other databases use a more efficient connection concurrency model. This makes for a difficult tuning problem as there is a relatively low threshold at which adding more connections degrades performance (around ~2x cores) and eventually another higher threshold (hard to estimate, highly workload dependent) where performance will  plummet.</p><p>  PostgreSQL为每个连接的流程伪造，在大多数其他数据库中使用更有效的连接并发模型。这使得在困难的调谐问题中，因为存在相对低的阈值，在此添加更多连接降低性能（左右〜2x核心）并且最终是另一个更高的阈值（难以估计，高度工作依赖性），其性能将骤降。</p><p> The standard recipe of using a connection pooler certainly kicks the can down the road, but introduces significant additional architectural complexity. On a particularly large deployment, I eventually had to layer in a  second  pgbouncer tier. One tier ran on the application servers and another tier on the database servers. Altogether it aggregated connections for around 1 million client processes. Tuning it was 40% dark art, 40% brute force, and 10%  pure luck.</p><p> 使用连接吸收器的标准配方肯定会踢掉路径，但引入了显着的额外架构复杂性。在一个特别大的部署中，我最终不得不在第二个pgbouncer层中划分。在应用程序服务器上以及数据库服务器上的另一个层上ran。完全占用的连接约100万客户进程。调整为40％的黑暗艺术，40％的蛮力，10％纯粹​​运气。</p><p> Process scalability has been getting incrementally better every major release, but ultimately there is a somewhat hard limit to the performance of this architecture compared to something like thread-per-connection, which is used in MySQL.</p><p> 过程可伸缩性一直在逐步逐步逐步升级，但是与像线程相比的内容相比，这种体系结构的性能有所艰难的限制，它在MySQL中使用。 </p><p>   Tables in PostgreSQL have an index for the primary key and  separate row storage called the heap. Other databases  integrate these together or support  “index-organized tables”. In this arrangement, the primary key lookup process leads directly to the row data without a secondary fetch to get the full row and the requisite additional CPU and I/O utilization.</p><p>postgreSQL中的表具有主键和名为堆的单独行存储的索引。其他数据库将这些数据库集成在一起或支持“索引组织表”。在这种安排中，主键查找过程直接导致行数据而不进行次要获取以获取完整的行和必要的附加CPU和I / O利用率。</p><p> The  CLUSTER command in PostgreSQL reorganizes a table according to an index to improve performance, but doesn’t really work for most real-world OLTP cases. It rewrites the entire table under an exclusive lock, blocking any reads or writes. PostgreSQL doesn’t maintain the clustered layout for new data, so this operation must be ran periodically. So it is  really  only useful if you can take your database offline for long periods of time on a regular basis.</p><p> PostgreSQL中的群集命令根据索引重新组织了一张表以提高性能，但对大多数现实世界的OLTP案例并不是真正的工作。它在独占锁下重写整个表，阻止任何读取或写入。 PostgreSQL不会为新数据维护群集布局，因此必须定期运行此操作。因此，如果您可以定期将数据库脱机脱机，则真的很有用。</p><p> But more critically,  index-organized tables save space as the index doesn’t require a separate copy of the row data. For tables with small rows that are mostly covered by the primary key, such as join tables, this can easily cut the table’s storage footprint  in half.</p><p> 但更为严重的是，索引组织的表节省空间，因为索引不需要行数据的单独副本。对于具有大多数由主键覆盖的小行的表，例如加入表，这可以轻松地将表的存储空间分成两半。</p><p>  CREATE TABLE likes (  object_type INTEGER NOT NULL,  object_id BIGINT NOT NULL GENERATED ALWAYS AS IDENTITY,  user_id BIGINT NOT NULL,  created_at TIMESTAMP WITH TIME ZONE NOT NULL,  PRIMARY KEY(object_type, object_id, user_id) );</p><p>  创建表所喜好（Object_type Integer not null，object_id bigint不会生成始终为身份，user_id bigint not null，created_at timestamp与时区不是null，主键（object_type，object_id，user_id）;</p><p> PostgreSQL will maintain an index for the primary key which is separate from the base table storage. This index will contain a full copy of the  object_type,  object_id, and  user_id columns for every row.  20 out of 28 bytes in each row (~70%) will be duplicated. If PostgreSQL supported index-organized tables, it wouldn’t consume all that additional space.</p><p> PostgreSQL将为主键维护与基本表存储分开的主键的索引。此索引将包含每行的Object_type，Object_ID和User_ID列的完整副本。每行中28个字节中的20个（〜70％）中的20个将被重复。如果PostgreSQL支持索引组织的表，则不会消耗所有额外空间。</p><p>  Some  major version upgrades require  hours of downtime to convert the data for a large database. Using the typical streaming replication mechanism, it is not possible to do this gracefully by upgrading a replica and doing a failover. The on-disk binary format is  incompatible across major versions, thus the wire protocol between master and replica is effectively also incompatible.</p><p>  一些主要版本升级需要几个小时的停机时间来转换大型数据库的数据。使用典型的流复制机制，通过升级副本并进行故障转移，无法优雅地执行此操作。磁盘上的二进制格式在主要版本中不兼容，因此主设备和副本之间的线路协议有效地也不兼容。</p><p> Hopefully logical replication will eventually completely replace streaming replication, which would enable an  online, rolling upgrade strategy. When I worked on a large-scale horizontally-scaled deployment, we made a significant engineering investment in custom infrastructure to do these upgrades without downtime using an additional  trigger-based replication system that was also used for shard migration.</p><p> 希望逻辑复制最终将完全替换流式复制，这将使在线，滚动升级策略。当我在大规模的水平缩放部署工作时，我们在自定义基础架构中进行了重大的工程投资，以便使用还使用用于碎片迁移的额外触发器的复制系统进行这些升级。 </p><p>  To be fair, MySQL’s out-of-the-box replication is  much more cumbersome, but compared to some NoSQL stores like MongoDB and Redis or some cluster-oriented replication systems like  MySQL Group Replication and  Galera Cluster, from an ease-of-use and sharp-edge-avoidance perspective,  setting up replication in PostgreSQL leaves  a lot to be desired. While logical replication  theoretically provides far more flexibility for third-party solutions to paper over these gaps, so far it’s there are  some pretty big caveats for using it in place of streaming replication.</p><p>要公平，MySQL的开箱即用的复制更加繁琐，但与MongoDB和Redis等一些NoSQL商店相比，从易用性地，MySQL Group Replication和Galera Cluster等一些面向群集的复制系统和锐利的边缘避免透视，在PostgreSQL中设置复制留下了很多。虽然逻辑复制理论上为在这些差距上对纸张的第三方解决方案提供了更大的灵活性，但到目前为止，它是一些非常大的警告，用于使用它代替流媒体复制。</p><p>  Planner hints allow queries to direct the query planner to use strategies it wouldn’t otherwise use on its own. In what seems to be a form of the  sufficiently smart compiler argument, the PostgreSQL development team has held the line for years in refusing to support query planner hints.</p><p>  策划者提示允许查询指示查询计划者使用策略，否则无法使用它。在似乎是一种足够聪明的编译器参数的形式中，PostgreSQL开发团队在拒绝支持查询计划者提示时举行了这条线。</p><p> I  do understand their reasoning, which largely is about preventing users from attacking problems using query hints that should be fixed by writing proper queries. However,  this philosophy seems brutally paternalistic when you’re watching a production database spiral into a full meltdown under a sudden and unexpected query plan shift.</p><p> 我确实理解他们的推理，这主要是关于阻止用户使用应该通过编写适当查询来修复的查询提示来攻击问题。然而，在突然和意外的查询计划班次下观看生产数据库螺旋到全崩溃时，这种哲学似乎是野蛮的。</p><p> In many of these situations, a hint to the planner can mitigate the issue in minutes, buying the engineering team the hours or days they need to make a proper fix to the query. While there  are some indirect workarounds that involve disabling certain query planner strategies, they are risky and definitely shouldn’t be employed under any kind of time pressure.</p><p> 在许多这些情况下，到计划者的提示可以在几分钟内减轻这个问题，购买工程团队他们需要对查询进行适当的修复时的时间或天。虽然有一些间接解决方法涉及禁用某些查询计划策略，但它们是风险的，并且绝对不应该在任何时间压力下都受雇。</p><p>   InnoDB’s Page Compression in  MySQL commonly   cuts storage footprint in half  and is pretty much  “free” from a performance perspective. PostgreSQL will automatically  compress large values but this isn’t useful for the most common ways data is stored in relational databases. For most RDBMS use cases, a row is typically a few hundred bytes or less, which means compression could only really be effective when applied across multiple rows, or in  blocks.</p><p>   InnodB在MySQL的页面压缩通常会在半场剪裁存储脚印，并且从表现形式的角度来看是“免费”。 PostgreSQL将自动压缩大值，但这对于数据存储在关系数据库中的最常用方式并不有用。对于大多数RDBMS使用情况，行通常是几百个或更小，这意味着压缩在跨多行或块中应用时只能真正有效。</p><p> Block compression is indeed quite difficult to implement for the kind of data structures at the heart of PostgreSQL, but the  “hole punch” strategy employed by MySQL’s InnoDB storage engine seems to work quite well in practice,  despite some drawbacks.</p><p> 块压缩确实很难为PostgreSQL核心的数据结构实际实施，但MySQL的InnoDB存储引擎采用的“孔打孔”策略似乎在实践中工作得很好，尽管有一些缺点。</p><p> 2020–04–07 Update:   Mark Callaghan , of “MySQL at Facebook” fame, questioned my statement here that hole-punching compression works “quite well in practice.” It turns out that the largest MySQL installation in the world never used hole-punching compression, as I previously thought. They did successfully use a  slightly modified version of the older generation of InnoDB compression with success, however, before  migrating to MyRocks a few years ago.</p><p> 2020-04-07更新：Mark Callaghan，“MySQL在Facebook”的名声，在此质疑我的陈述，孔冲压压缩工作“在实践中很好”。事实证明，世界上最大的MySQL安装从未使用过孔冲压，因为我以前认为。他们确实成功地使用略微修改的innodb压缩，并且在几年前迁移到MyRocks之前，它已经成功了。 </p><p> While the hole-punching compression does seem to work for some folks, there are  some caveats make it less of a home run. If you’re running Percona’s version of MySQL, MyRocks is a better bet. If not, it seems that the classic  InnoDB table compression is a safer bet for very read-heavy workloads on flash storage. Mark didn’t point to any specific instances of major production issues, but does point out that he “doubts filesystems have been designed for hole punch per page and I would be afraid of obscure failures.”</p><p>虽然孔冲压压缩似乎为某些人工作，但有一些警告使其成为一个家庭运行。如果您正在运行Percona的MySQL版本，MyRocks是一个更好的赌注。如果没有，似乎经典的InnoDB表压缩是对闪存存储上非常读取的重型工作负载的更安全下注。标记没有指向主要生产问题的任何特定实例，但确实指出他“疑虑文件系统已经为每页孔打孔而设计，我会害怕失败。”</p><p> The only general-purpose block compression setup widely used in the PostgreSQL world  leverages ZFS, which does seem to work quite well for people. ZFS  is a production-grade reality in Linux these days, but definitely brings with it some administrative overhead that doesn’t exist for the more “out-of-the-box” filesystems like XFS or ext4.</p><p> PostgreSQL世界广泛使用的唯一通用块压缩设置利用ZFS，这对人们来说似乎很好。这些天是Linux的生产级现实，但绝对带来了一些管理开销，它不存在于XFS或Ext4等“开箱即用的”文件系统中。</p><p>  You should probably still use PostgreSQL and not something else for storing data that you’d  ideally like to, you know, keep around for some time.  In general I’d recommend starting with PostgreSQL and then trying to figure out why it  won’t work for your use case.</p><p>  您可能仍然应该使用PostgreSQL而不是别的东西来存储您理想地喜欢的数据，您知道，保持一段时间。通常，我建议从PostgreSQL开始，然后尝试弄清楚为什么它不适用于您的用例。</p><p> PostgreSQL is very mature, well-engineered, richly-featured, is generally free of sharp edges, and is quite performant for the vast majority of use cases. It also is unencumbered by a  dominant corporate sponsor, includes fantastic documentation, and has a professional, inclusive community.</p><p> PostgreSQL非常成熟，精心设计，丰富的特色，一般是没有锋利的边缘，并且对于绝大多数用例具有相当的性能。它也是由占优势公司赞助商的不受控制，包括梦幻般的文件，拥有专业，包容性的社区。</p><p> The good news is that the pain caused by many of the issues brought up in this post can be reduced or eliminated by using a managed database service like  Heroku PostgreSQL,  Compose PostgreSQL,  Amazon RDS for PostgreSQL, or  Google Cloud SQL for PostgreSQL. If you can use one of these services, for the love of all that is holy,  please do!</p><p> 好消息是，通过使用Heroku PostgreSQL这样的托管数据库服务，可以减少或消除由Heroku PostgreSQL，PostgreSQL的PostgreSQL，或PostgreSQL的谷歌云SQL，或者可以消除这篇文章中提出的许多问题引起的疼痛。如果您可以使用其中一个服务，因为对所有圣洁的爱，请做！</p><p> I’m proud to say I’ve built software on top of PostgreSQL for almost two decades and remain a strong advocate,  despite its flaws. Given the progress I’ve witnessed over the years by its incredible development team,  I can say that most, if not all of these issues will be resolved in due time.</p><p> 我很自豪地说我在PostgreSQL之上建立了近二十年的软件，尽管它缺陷，但仍然是一个强大的倡导者。鉴于我令人难以置信的发展团队多年来一直在目睹的进展，我可以说，大多数情况下，如果不是所有这些问题都将在适当的时候解决。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://rbranson.medium.com/10-things-i-hate-about-postgresql-20dbab8c2791">https://rbranson.medium.com/10-things-i-hate-about-postgresql-20dbab8c2791</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/讨厌/">#讨厌</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hate/">#hate</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/复制/">#复制</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>