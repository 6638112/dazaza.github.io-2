<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>错误处理很难Error Handling Is Hard</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Error Handling Is Hard<br/>错误处理很难</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-30 22:29:22</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/a004321c5e9cf016b3f0865b6d999f71.png"><img src="http://img2.diglog.com/img/2020/11/a004321c5e9cf016b3f0865b6d999f71.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This blog post will use mostly Rust and Haskell code snippets to demonstrate its points. But I don&#39;t believe the core point is language-specific at all.</p><p>该博客文章将主要使用Rust和Haskell代码片段来说明其要点。但是我根本不相信核心点是特定于语言的。</p><p> Here&#39;s a bit of Rust code to read the contents of  input.txt and print it to  stdout. What&#39;s wrong with it?</p><p> 这是一些Rust代码，用于读取input.txt的内容并将其打印到stdout。它出什么问题了？</p><p>  If you&#39;re Rust-fluent, that  .unwrap() may stick out to you like a sore thumb. You know it means &#34;convert any error that occurred into a panic.&#34; And panics are a Bad Thing. It&#39;s not correct error handling. Instead, something like this is &#34;better&#34;:</p><p>  如果您能说流利的话，那么.unwrap（）可能会像拇指酸痛地伸出来。您知道这意味着“将发生的所有错误转换为紧急情况”。恐慌是一件坏事。这不是正确的错误处理。相反，这样的事情“更好”：</p><p> fn  main () {  match  std::fs::read_to_string( &#34; input.txt &#34; ) {  Ok (s)  =&gt; println! ( &#34; {} &#34; , s),  Err (e)  =&gt; eprintln! ( &#34; Unable to read from input.txt:  {:?} &#34; , e), }}</p><p> fn main（）{match std :: fs :: read_to_string（“ input.txt”）{确定（s）=> println！ （“ {}”，s），Err（e）=> eprintln！ （“无法从input.txt中读取：{：？}”，e），}}</p><p> The presence of  enums in Rust makes it really easy to ensure you properly handle all failure cases fully. The code above will not panic. If an I/O error occurs, such as file not found, permissions denied, or a hardware failure, it will print an error message to  stderr. But this  still isn&#39;t good error handling, for two reasons:</p><p> Rust中枚举的存在使确保您正确处理所有失败案例变得非常容易。上面的代码不会惊慌。如果发生I / O错误，例如找不到文件，权限被拒绝或硬件故障，它将向stderr打印一条错误消息。但这仍然不是很好的错误处理，原因有两个：</p><p> The exit code of the program doesn&#39;t indicate an error occurred. We&#39;d need to use something like   abort to fix that, which isn&#39;t too hard. But it&#39;s something else to remember.</p><p> 该程序的退出代码并不表示发生了错误。我们需要使用中止之类的方法来解决该问题，这并不难。但这是要记住的其他事情。</p><p> This is  very verbose! We&#39;ve got a trivial little program here, and we&#39;re obscuring the actual behavior of the program with all of this line noise around matching different  enum variants.</p><p> 这很冗长！我们这里有一个琐碎的小程序，由于匹配了不同的枚举变量，所有这些行噪声都掩盖了程序的实际行为。</p><p> Fortunately, the Rust language is benevolent, and it makes it possible to do things  even better than before. The  ? operator will try to do something, and automatically short-circuit if an error occurs. We now get to avoid those pesky panics without cluttering our code. And we get the proper exit code to boot!</p><p>幸运的是，Rust语言是仁慈的，它使做事比以前更好。 ？操作员将尝试做某事，并在发生错误时自动短路。现在，我们可以避免那些烦人的恐慌而又不会使我们的代码混乱。并且我们获得了正确的退出代码来启动！</p><p>  All is good in the world, we can stop this post here and go home. The greatest marvel of error handling has arrived!</p><p>  世界上一切都很好，我们可以在这里停止发布并回家。错误处理的最大奇迹来了！</p><p>  So it turns out I forgot to create my  input.txt file. Let&#39;s see the beautiful error message generated by my program:</p><p>  所以事实证明我忘了创建我的input.txt文件。让我们看看我的程序生成的漂亮错误消息：</p><p> Error: Os { code: 2, kind: NotFound, message: &#34;The system cannot find the file specified.&#34; }</p><p> 错误：Os {代码：2，种类：找不到，消息：“系统找不到指定的文件。” }</p><p> Huh... that&#39;s thoroughly unhelpful. In my 5-line program, it&#39;s trivial enough to figure out which file doesn&#39;t exist. But imagine a 5,000 line program. Or if the code in question is in a dependency. Or if you&#39;re a member of the ops team, have never written a line of Rust in your life, don&#39;t have access to the codebase, the production server is down at 2am, and you see this error message in your logs.</p><p> 嗯...那是完全无益的。在我的5行程序中，找出哪个文件不存在很简单。但是想象一下一个5,000行的程序。或者，如果所讨论的代码在依赖项中。或者，如果您是运维团队的成员，一生中从未写过Rust文字，无权访问代码库，生产服务器在凌晨2点关闭，并且您在日志中看到此错误消息。</p><p>  Well,  obviously this is just because Rust uses error returns instead of Good Ol&#39; Runtime Exceptions. Obviously something like Haskell solves this problem better, right? Well, sort of. With this program, and no  input.txt:</p><p>  好吧，显然这仅仅是因为Rust使用错误返回而不是Good Ol'Runtime Exceptions。显然，像Haskell这样的东西可以更好地解决这个问题，对吗？好吧，有点。有了这个程序，没有input.txt：</p><p>    I didn&#39;t even need to include any error handling logic in the code; it&#39;s all implicit! But in reality, the clarity of this error message has little to do with exception handling semantics. It has to do with the construction of this specific error message. It contains enough information to help debug this.</p><p>    我什至不需要在代码中包含任何错误处理逻辑。都是隐性的！但是实际上，此错误消息的清晰度与异常处理语义无关。它与此特定错误消息的构造有关。它包含足够的信息来帮助调试。</p><p> But there are plenty of counterexamples in Haskell. Calling  head on an empty list provides a line number these days, but you used to just get an error that &#34;oops, tried to  head an empty list, somewhere, in one of your libraries. Good luck!&#34; Some low-level network functionality still gives vague error messages.</p><p>但是在Haskell中有很多反例。现在，在空列表上调用head会提供一个行号，但是您过去经常遇到这样的错误：“哎呀，试图在您的一个库中某个地方的一个空列表上添加头。祝您好运！”某些底层网络功能仍然给出模糊的错误消息。</p><p> And even the glorious  does not exist message above is only marginally useful. And that&#39;s because of...</p><p> 甚至上面不存在的光荣消息也仅是微不足道的。那是因为...</p><p>  In a trivial 2-line program, the reality is that &#34;file not found&#34; without any additional information is perfectly reasonable. That&#39;s because I know  exactly the context in which the error occurred. It either occurred on line 1, or line 2. By contrast, in a 500k SLOC codebase, knowing that  input.txt doesn&#39;t exist is probably not nearly enough to debug things.</p><p>  在一个简单的两行程序中，现实情况是没有任何其他信息的“找不到文件”是完全合理的。那是因为我确切知道错误发生的上下文。它发生在第1行或第2行。相比之下，在500k SLOC代码库中，知道input.txt不存在可能不足以调试东西。</p><p>  Similarly, knowing that I can&#39;t connect to IP address 255.813.20.1 may be sufficient in a small network test. But in a reasonably complicated program, I&#39;d  much rather get the context that I&#39;m trying to make an HTTPS request to example.com proxied through a server with IP address 255.813.20.1, which was specified via the  HTTP_PROXY environment variable. That last bit of information may shortcircuit days of debugging to point out &#34;doh, I had a typo in my Kubernetes manifest file!&#34;</p><p>  同样，在小型网络测试中，知道我无法连接到IP地址255.813.20.1就足够了。但是在一个相当复杂的程序中，我宁愿得到这样一个上下文，即我试图通过IP地址为255.813.20.1的服务器向example.com发出HTTPS请求，该服务器是通过HTTP_PROXY环境变量指定的。最后的信息可能会缩短调试时间，以指出“哦，我的Kubernetes清单文件中有错字！”</p><p> Stack traces are often a huge help here. They tell you a lot of useful context. And both Rust and Haskell are particularly weak at providing this context in their error representations. But it&#39;s still not a panacea. The ugly reality is that...</p><p> 堆栈跟踪通常在这里有很大的帮助。它们告诉您很多有用的上下文。而且，Rust和Haskell在其错误表示形式中都很难提供这种上下文。但这仍然不是万能药。丑陋的现实是...</p><p>  Like so many other things, error handling ultimately is a trade-off. When we&#39;re writing our initial code,  we don&#39;t want to think about errors. We code to the happy path. How productive would you be if you had to derail every line of code with thought processes around the myriad ways your code could fail?</p><p>  像其他许多事情一样，错误处理最终是一个权衡。在编写初始代码时，我们不想考虑错误。我们编码到幸福的道路。如果您不得不围绕思维过程以无数种方式失败的思维过程使每一行代码脱轨，那么您将有多大的生产力？</p><p> But then we&#39;re debugging a production issue, and  we definitely want to think about errors. We curse our lazy selves for not handling an error case that  obviously could have arisen. &#34;Why did I decide to abort the process when the TCP connection failed? I should have retried! I should have logged the address I tried to connect to!&#34;</p><p> 但是随后我们正在调试生产问题，我们当然想考虑错误。我们诅咒我们懒惰的自我，因为他们没有处理显然可能出现的错误情况。 “为什么在TCP连接失败时我为什么决定中止该进程？我应该重试！我应该已经记录了尝试连接的地址！”</p><p> Then we flood our code with log messages, and are frustrated when we can&#39;t see the important bits.</p><p>然后，我们用日志消息充斥我们的​​代码，当我们看不到重要的位时感到沮丧。</p><p> Finding the right balance is an art. And typically it&#39;s an art that we don&#39;t spend enough time thinking about. There are some well-established tools for this, like runtime-configurable log levels. That&#39;s a huge step in the right direction.</p><p> 找到正确的平衡是一门艺术。通常，这是一门我们不会花太多时间思考的艺术。为此有一些完善的工具，例如运行时可配置的日志级别。这是朝正确方向迈出的巨大一步。</p><p> Rust is such a great example of this. Explicit  matching on  Result values really forces you to think through all of the different error cases and how to report them correctly. Complex custom  enum error types allow you to define all of the different values you&#39;d want reported. But all of this adds huge line noise compared to  ?. So  ? wins the day.</p><p> Rust是一个很好的例子。明确匹配Result值确实会迫使您考虑所有不同的错误情况以及如何正确报告它们。复杂的自定义枚举错误类型使您可以定义要报告的所有不同值。但是，与？相比，所有这些都会增加巨大的线路噪声。那呢赢得胜利。</p><p>  The Rust community accepts that panics are bad. The Haskell community constantly argues about whether runtime exceptions are a good or bad thing. Java is either loved or hated for checked exceptions. Golang is either lauded or mocked for  if err != nil.</p><p>  Rust社区承认恐慌是有害的。 Haskell社区不断争论运行时异常是好事还是坏事。 Java是检查异常还是喜欢还是讨厌。如果err！= nil，则对Golang表示赞赏或嘲笑。</p><p> I&#39;m not at all arguing that those discussions are irrelevant. There are significant trade-offs to these various approaches. They affect performance, trackability of errors, and more.</p><p> 我一点也不认为这些讨论无关紧要。这些方法之间存在重大折衷。它们会影响性能，错误的可跟踪性等等。</p><p> What I&#39;m arguing here is that we spend a disproportionate time on how we report and recover from errors, and far less on discussing what a good error actually contains.</p><p> 我在这里争论的是，我们在报告和从错误中恢复方面花费的时间不成比例，而在讨论好的错误实际上包含的内容上花费的时间更少。</p><p>  These are evolving thoughts for me. So take them with a grain of salt. And I&#39;m very interested to hear differing opinions.</p><p>  这些是我不断发展的想法。所以把它们和一粒盐一起吃。我很想听到不同的意见。</p><p> I&#39;ve long held that in Haskell, we should use runtime exceptions. This has been interpreted by many as my  advocacy of runtime exceptions. Instead, I would advocate: use the language&#39;s native mechanism. I don&#39;t pine for exceptions when writing Rust. Quite the opposite in fact. I overall prefer explicit error handling. But it&#39;s not worth fighting the battle against runtime exceptions when they are already ubiquitous.</p><p>我一直认为在Haskell中，我们应该使用运行时异常。许多人将其解释为我对运行时异常的提倡。相反，我主张：使用语言的本机机制。在编写Rust时，我不会为例外而努力。实际上恰恰相反。我总体上更喜欢显式错误处理。但是当它们已经无处不在时，与运行时异常作斗争是不值得的。</p><p> I think Rust and Haskell are both close to the sweet spot in error handling. There&#39;s relatively little verbosity around adding this handling. If you leverage libraries like   anyhow in Rust, there&#39;s even less.</p><p> 我认为Rust和Haskell都接近错误处理的最佳位置。添加此处理的详细程度相对较低。如果您像在Rust中那样以任何方式利用库，那就更少了。</p><p> My biggest concern with a library like  anyhow is how easy it becomes to do the wrong thing. Taking our broken example from above. It&#39;s trivial to &#34;upgrade&#34; it to use  anyhow:</p><p> 无论如何，我对图书馆的最大关注是做错事情变得多么容易。从上面举一个破碎的例子。 “升级”它以任何方式使用都是微不足道的：</p><p>  However, this still produces the same useless error message we started with. Instead, we need to be a bit more explicit with a  context method call to get a nicer message:</p><p>  但是，这仍然会产生与我们相同的无用错误消息。取而代之的是，我们需要通过上下文方法调用来更明确地显示一条更好的消息：</p><p> use  anyhow::Context; fn  main () -&gt; anyhow:: Result &lt;()&gt; {  let  s = std::fs::read_to_string( &#34; input.txt &#34; ) . context ( &#34; Failed to read input.txt &#34; ) ? ;  println! ( &#34; {} &#34; , s);  Ok (())}</p><p> 使用anyhow :: Context; fn main（）->总之：:结果 {让s = std :: fs :: read_to_string（“ input.txt”）。上下文（“无法读取input.txt”）？ ; println！ （“ {}”，s）;好 （（））}</p><p>  Error: Failed to read input.txtCaused by: The system cannot find the file specified. (os error 2)</p><p>  错误：无法读取input.txt原因：系统找不到指定的文件。 （操作系统错误2）</p><p> This is a good balance of concision and helpfulness. The downside is that lack of  enforcement. Nothing forced me to add the  .context call. I worry that in a large codebase, or under time pressure, people like me will end up forgetting to add the helpful context.</p><p> 这是简洁和有用之间的良好平衡。缺点是缺乏执法。没有什么迫使我添加.context调用的。我担心在大型代码库中或在时间压力下，像我这样的人最终会忘记添加有用的上下文。</p><p>  No tool can force the &#34;right&#34; level of context, that requires human insight and thought. And those are quantities in short supply, and not usually interested in error messages.</p><p>没有任何工具可以强制需要人类洞察力和思想的“正确”上下文。这些都是供不应求的数量，通常对错误消息不感兴趣。</p><p>  I don&#39;t have an answer here. I would advise people to start by recognizing that good error handling is  difficult. We like to think of it as a trivial but tedious task. It isn&#39;t. Doing this correctly requires real thought and design. We&#39;re too quick to sweep it under the rug as the unimportant parts of our code.</p><p>  我在这里没有答案。我建议人们首先认识到良好的错误处理是困难的。我们喜欢将其视为一项琐碎但繁琐的任务。不是。正确执行此操作需要真实的思想和设计。作为我们代码中不重要的部分，我们太快地把它扫了底。</p><p> I&#39;ll continue with my general advice of using your language&#39;s preferred mechanisms for error handling. In Rust, that means using  Result and avoiding panics. In Haskell, it means some mixture of explicit  Either return values and runtime exceptions (the exact mixture very much up for debate). In Java, it&#39;s mostly checked exceptions, though there&#39;s plenty of added unchecked exceptions to gum up the works too.</p><p> 我将继续建议您使用您的语言的首选机制进行错误处理。在Rust中，这意味着使用Result并避免出现恐慌。在Haskell中，这意味着显式的Either返回值和运行时异常的某种混合（确切的混合非常有争议）。在Java中，它通常是受检查的异常，尽管也添加了许多未经检查的异常来完善工作。</p><p> But consider spending a bit more time on thinking through not just  how to report/raise/throw an error/exception, but what exactly you&#39;re reporting/raising/throwing. Think of the poor ops guy drinking his 7th cup of coffee at 4am trying to figure out what part of the codebase needs  input.txt, or why in the world the program is trying to connect to an invalid IP address.</p><p> 但是，请考虑花更多的时间来思考，不仅要考虑如何报告/引发/抛出错误/异常，还要思考您到底在报告/引发/抛出什么。想一想这个可怜的操作人员在凌晨4点喝了7杯咖啡，试图弄清代码库的哪个部分需要input.txt，或者为什么程序在世界上试图连接到无效的IP地址。</p><p>  Do you like this blog post and need help with DevOps, Rust or functional programming?  Contact us.</p><p>  您是否喜欢这篇博客文章，并且需要有关DevOps，Rust或函数式编程的帮助？联系我们。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/错误处理/">#错误处理</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/handling/">#handling</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>