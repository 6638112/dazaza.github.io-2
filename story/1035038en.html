<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>生产中的耐用品</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">生产中的耐用品</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-14 09:07:09</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/08d2d929fa50be967636c358f30ed16f.png"><img src="http://img2.diglog.com/img/2020/11/08d2d929fa50be967636c358f30ed16f.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>A few weeks ago, Cloudflare announced Durable Objects: a  &#34;truly serverless approach to storage and state&#34;, which piqued our interest here at  Linc. We&#39;re already big proponents of Cloudflare Workers (Workers is our  recommended deploy target, after all), so we&#39;re always interested in what new capabilities that platform is getting. But it was this section that sounded  ideal for solving a particularly annoying UX problem with much less code/infrastructure than we&#39;d assumed we would need (see the  comparison section at the end).</p><p>几周前，Cloudflare发布了耐用对象：一种真正的无服务器存储和状态方法，这在Linc引起了我们的兴趣。我们已经是Cloudflare Workers的主要支持者(毕竟Workers是我们推荐的部署目标)，所以我们总是对该平台获得哪些新功能感兴趣。但是，这一节听起来非常适合用比我们想象中需要的少得多的代码/基础设施来解决特别恼人的用户体验问题(参见最后的比较部分)。</p><p> Historically ... there was no way to control which instance received a request, [so] there was no way to force two clients to talk to the same Worker... Durable Objects change that:   requests related to the same topic can be forwarded to the same object, which can then coordinate between them, without any need to touch storage .</p><p>从历史上看..。没有办法控制哪个实例收到了请求，[因此]也没有办法强制两个客户端与同一个工作进程对话。持久对象改变了这一点：与同一主题相关的请求可以被转发到相同的对象，然后该对象可以在它们之间进行协调，而不需要触及存储。</p><p> This is a big deal. And, after a few days tinkering, we&#39;ve been able to successfully deploy our solution to production! In this post we&#39;ll talk about the problem we solved, how Durable Objects work, we&#39;ll go through the code and what it&#39;s like working with them, and then look at just how much work it saved us.</p><p>这是件大事。而且，经过几天的修修补补，我们已经能够成功地将我们的解决方案部署到生产中！在这篇文章中，我们将讨论我们解决的问题，对象是如何持久工作的，我们将浏览代码以及它使用它们是什么样子，然后看看它为我们节省了多少工作。</p><p> Note:  Durable Objects are in   limited beta , and &#34;not recommended for production use&#34; (yet). However, our use-case doesn&#39;t push any of the   beta limits  and we&#39;re using it to   progressively enhance  our existing solution, so we&#39;ve felt safe   deploying it  to production already!</p><p>注意：耐用对象是有限的测试版，不推荐用于生产(目前还没有)。然而，我们的用例不会超出任何测试版的限制，我们正在使用它来逐步增强我们现有的解决方案，所以我们已经感到安全地将其部署到生产中了！</p><p>  While Linc is a product focussed on automating deployments and previewing each commit, a big part of the day-to-day usage is building commits from source into a  FAB, and viewing the logs of that process is a core piece of the product:</p><p>虽然LINC是一个专注于自动化部署和预览每个提交的产品，但日常使用的很大一部分是将提交从源代码构建到FAB中，而查看该过程的日志是该产品的核心部分：</p><p>  When you&#39;re first getting set up, or when something changes in your build or goes awry, you can find yourself poring over these logs to find and fix your issue. And so being able to watch them &#34;live&#34;, as they&#39;re being built, is a useful tool in reducing your feedback loop (and of course Linc is big on  reducing feedback loops!). But that turns out to be an annoyingly difficult feature to implement.</p><p>当您刚开始设置时，或者当您的构建中发生了一些变化或出错时，您可能会发现自己在仔细阅读这些日志来查找和修复您的问题。因此，当它们正在建造时，能够观看它们的现场直播，是减少反馈循环的一个有用的工具(当然，Linc在减少反馈循环方面做得很好！)。但事实证明，这是一个令人恼火的难以实现的功能。</p><p> For starters, most of the time a build will start before any clients are watching (but not always e.g. when restarting a build after a config change). In this case, you need to accumulate a partial build log  somewhere so it&#39;s ready to send it to the first client to connect. And multiple clients might be watching the same build, and disconnect/reconnect at any moment, too. It&#39;s not intractable, but it&#39;s just complex enough to be tricky.</p><p>对于初学者来说，大多数情况下，构建会在任何客户端查看之前启动(但并非总是在配置更改后重新启动构建时)。在这种情况下，您需要在某个地方累积部分构建日志，以便它准备将其发送到第一个要连接的客户端。而且，多个客户端可能正在观看相同的构建，也可能随时断开/重新连接。这并不难解决，但它就是复杂到让人难以捉摸。</p><p>  Until now, we&#39;ve taken a pragmatic approach: use GraphQL subscriptions to periodically flush the entire `Build` record, logs included, every few seconds. This actually reuses our existing live-update infrastructure that powers almost every view in the app:</p><p>到目前为止，我们采取了一种务实的方法：使用GraphQL订阅每隔几秒钟定期刷新整个“构建”记录(包括日志)。这实际上重复使用了我们现有的实时更新基础设施，这些基础设施几乎支持应用程序中的每一个视图：</p><p>  So while updates are triggered from DB events, using a GraphQL subscription server in this way gives us an important guarantee:  the clients are  always getting the full snapshot of the data that they&#39;re interested in. In other words,  any change to a record in the DB results in the client getting a full update of any affected queries from the server—there&#39;s no need to manage or merge updates on the client, it can simply replace its local cache with the latest update. It makes a fully live UI  much easier to implement, at the expense of some redundant data transfer.</p><p>因此，虽然更新是从数据库事件触发的，但以这种方式使用GraphQL订阅服务器为我们提供了一个重要的保证：客户端始终可以获得他们感兴趣的数据的完整快照。换句话说，对数据库中记录的任何更改都会导致客户端从服务器获得任何受影响查询的完整更新--不需要管理或合并客户端上的更新，只需用最新的更新替换其本地缓存即可。它以一些冗余的数据传输为代价，使完全实时的用户界面更易于实现。</p><p> As a general pattern, it&#39;s worked fantastically for us. But to send each log of a current build line-by-line it&#39;s way way  way too heavy. Not just in terms of sending way more data than necessary, but we&#39;d be absolutely thrashing our Dynamo table   even if nobody&#39;s watching the logs currently. So, we&#39;ve taken a compromise: use the existing infrastructure and flush the logs to the DB every ~10 seconds. Most builds take between 2 and 4 minutes so it&#39;s only a handful of extra writes, and it feels OK for a stop-gap. We&#39;ve had an open ticket to build out a dedicated log-streaming solution but the  amount of additional infrastructure put us off. That is until Durable Objects came along...</p><p>作为一种普遍的模式，它对我们来说非常有效。但是要逐行发送当前构建的每个日志，这样的方式太重了。不仅仅是在发送超过需要的数据方面，我们绝对会在迪纳摩表上大打出手，即使目前没有人在看日志。因此，我们采取了一个折中方案：使用现有的基础设施，每隔10秒将日志刷新到数据库。大多数构建需要2到4分钟，所以这只是少量额外的写入，对于权宜之计来说感觉还可以。我们已经有了构建专用日志流解决方案的开放门票，但大量的额外基础设施让我们望而却步。那是在耐用物品出现之前。</p><p>  Note: it&#39;s worth reading the   introductory blog post  to get a background, but this is my best attempt at a TL;DR:</p><p>注：阅读这篇介绍性的博客文章以了解背景是值得的，但这是我对TL；DR：</p><p> Durable Objects are a way of defining a serverless function as an  instance of a JS class. They can&#39;t be reached by external HTTP requests directly, instead a &#34;normal&#34; (i.e. stateless) Worker creates/accesses instances using their   namespace (usually the name of their class) and an   id. For a given   namespace &amp;   id, there will be  exactly one instance, somewhere in the world, and it can store data. Instances communicate with workers over normal HTTP requests/responses, and support websockets.</p><p>持久对象是将无服务器函数定义为JS类实例的一种方式。外部HTTP请求不能直接访问它们，而是由普通(即无状态)Worker使用它们的命名空间(通常是它们的类名)和ID创建/访问实例。对于给定的命名空间&amp；id，世界上的某个地方只有一个实例，它可以存储数据。实例通过正常的HTTP请求/响应与Worker通信，并支持WebSocket。</p><p> If you find that a bit confusing, you&#39;re not alone! I didn&#39;t really &#34;get&#34; it until I&#39;d read an example, so I&#39;ve reproduced and commented our Worker and Object code in  The Solution section below.</p><p>如果你觉得这有点困惑，你并不孤单！直到我读了一个例子，我才真正得到它，所以我在下面的解决方案部分复制并注释了我们的工作者和目标代码。</p><p>  I hope it&#39;s not terribly controversial, but I&#39;m not a big fan of the name &#34;Durable Objects&#34;. It conjures a very data-centric model, where it sounds like a way to... maybe define classes that magically run in the cloud, and where instances... maybe get &#34;frozen&#34; and stored when they go idle? It presents it like a type of database, whereas the reality is much closer to the Worker/Serverless model, just with per-worker storage.</p><p>我希望它不会引起太大争议，但我不是耐用品这个名字的狂热粉丝。它让人联想到一个非常以数据为中心的模型，在这个模型中，它听起来像是一种……。也许可以定义在云中神奇运行的类，以及其中的实例……。当他们闲置的时候，或许可以把它们冷冻起来，然后储存起来？它将其呈现为一种类型的数据库，而实际情况更接近于Worker/Serverless模型，只是使用了每个Worker的存储。</p><p> That said, the phrase &#34;workers with per-worker storage&#34;  massively downplays how incredibly transformative this concept is, though, so I get that Cloudflare  want it to sound like a &#34;whole new thing&#34;. But conceptually, you may be better thinking about these as &#34;materialised  actors&#34; or, as we&#39;ve come to coining them internally &#34;stateful workers&#34;.</p><p>话虽如此，但使用按员工存储的员工这个短语大大淡化了这个概念有多么惊人的变革性，所以我觉得Cloudflare希望它听起来像一个全新的东西。但从概念上讲，你可能会更好地将这些人想象为实实在在的演员，或者，正如我们在内部创造的那样，他们是有状态的员工。</p><p>   In the documentation, there&#39;s a lot of focus on the fact that an Object has its own key-value storage using `controller.storage`. But that API is available only once you have a live  instance of an Object, and getting  there is actually a whole type of state in disguise.</p><p>在文档中，很多人都在关注这样一个事实，即一个对象使用`Controler.storage`拥有自己的键值存储。但是，只有在拥有对象的活动实例时，该API才可用，而实现该实例实际上是一种伪装的完整状态。</p><p>  Each object has a globally-unique identifier. That object exists in only one location in the whole world at a time. Any Worker running anywhere in the world that knows the object&#39;s ID can send messages to it. All those messages end up delivered to the same place.</p><p>每个对象都有一个全局唯一的标识符。那个物体一次只存在于世界上的一个地方。在世界任何地方运行的任何知道该对象ID的工作人员都可以向其发送消息。所有这些信息最终都被送到了同一个地方。</p><p> Combine this with the fact that each Object instance supports websockets, suddenly you can define a system where, as long as two endpoints share some kind of   key, they can pass messages directly (kind of the way WebRTC connections are possible when two computers can&#39;t talk directly, but can both talk to a  TURN server). And it turns out, for Linc to stream live build logs to the browser, that&#39;s exactly what we need.</p><p>再加上每个对象实例都支持WebSockets这一事实，突然之间，您就可以定义一个系统，在该系统中，只要两个端点共享某种密钥，它们就可以直接传递消息(就像两台计算机不能直接通信，但都可以与TURN服务器通信时，WebRTC连接是可能的)。事实证明，Linc将实时构建日志流传输到浏览器，这正是我们所需要的。</p><p>  We already have an ideal shared key: the git SHA of the current commit being built. We actually use the `tree_id` of the commit, not the commit sha, because a `tree_id` is a hash of  only the underlying code, not its history or commit message (an aside: this is how Linc can release instantly when you merge an up-to-date PR, without waiting for a new build).</p><p>我们已经有了一个理想的共享密钥：正在构建的当前提交的git SHA。我们实际上使用的是提交的`tree_id`，而不是Commit sha，因为`tree_id`只是底层代码的散列，而不是它的历史或提交消息(顺便说一句：这就是Linc在合并最新PR时可以立即发布的方式，而不需要等待新的构建)。</p><p>   The &#34;normal&#34; Cloudflare  Worker that receives requests from the client/builder and connects them to the appropriate Object instance.</p><p>普通的Cloudflare工作器，它接收来自客户端/构建器的请求，并将它们连接到适当的对象实例。</p><p> The Durable  Object itself, which maintains a list of current clients, a history of logs, and broadcasts new log entries from the builder to each client.</p><p>持久对象本身，它维护当前客户端的列表、日志的历史记录，并将新的日志条目从构建器广播到每个客户端。</p><p> The  Builder, which is the machine in our AWS cluster that runs `npm run fab:build` on the source code. It hasn&#39;t needed to change very much, but now sends logs to the Worker as well as saving them to Dynamo. We sometimes call this &#34;build server&#34; or just &#34;server&#34; in the code.</p><p>Builder是我们的AWS集群中运行`npm的机器，它在源代码上运行fab：build`。它不需要太多更改，但现在将日志发送给工人，并将其保存到迪纳摩。我们有时将其称为构建服务器，或者在代码中仅称为服务器。</p><p> The  Client, which is our normal React app, that needs to reconcile &#34;live&#34; logs from the Worker with the existing data from GraphQL.</p><p>客户端是我们正常的Reaction应用程序，它需要将工作人员的实时日志与GraphQL中的现有数据进行协调。</p><p>  It&#39;s fair to say that this is the piece that I was most confused about after reading the  guide. It feels like you should just be able to deploy the Object itself and talk to it directly, but the Worker layer makes a lot of sense once it fits into the bigger picture: it&#39;s the only way   clients (who talk HTTP to their nearest edge location) can talk to   Object instances (which run in exactly one place worldwide).</p><p>公平地说，这是我在读完指南后最困惑的一篇文章。感觉上您应该只需要部署对象本身并直接与其通信，但一旦Worker层符合整体情况，它就变得非常有意义：它是客户端(与其最近的边缘位置通信)与对象实例(它们只在全球一个地方运行)通信的唯一方式。</p><p>  --CODE:language-js-- export default {   async fetch(request, env) {     // Convert our key into a Object ID     const id = env.MyObjectNamespace.idFromName(&#39;some-fixed-value&#39;)     // Connect to that instance, booting it if necessary     const instance = await env.MyObjectNamespace.get(id)     // Forward the current HTTP request to it     return instance.fetch(request)   } }</p><p>--代码：language-js--Export Default{async Fetch(Requestenv){//将密钥转换为对象ID。const id=env.MyObjectNamespace.idFromName(&#39；some-fixed-value&#39；)//连接到该实例，必要时启动。const实例=等待env.MyObjectNamespace.get(Id)：//将当前的http请求转发给它，返回instance.fetch(Request.)}。</p><p> Note that this worker uses a single key for all requests ( `&#39;some-fixed-value&#39;`) which means  _every _ request would be directed to a  _single Object instance _. This is almost certainly not what you want in production, but it was handy when getting started (particularly if you change  `&#39;some-fixed-value&#39;` once or twice, so you can be sure you&#39;re getting a new instance from the last time you deployed).</p><p>请注意，此Worker对所有请求(`&#39；某些固定值&#39；`)使用单个键，这意味着_EVERY_REQUEST将被定向到_Single Object Instance_。这几乎肯定不是您在生产中想要的，但在入门时很方便(特别是如果您更改了一到两次`某些固定值‘，这样您就可以确保从上次部署时得到一个新实例)。</p><p> Our Worker isn&#39;t actually much more complex, but parses the route to find the  `tree_id` to direct all requests for a particular build to a shared instance:</p><p>我们的Worker实际上并不复杂，但它解析路由以找到`tree_id‘，从而将特定构建的所有请求定向到一个共享实例：</p><p> --CODE:language-js-- export default {   async fetch(request, env) {     const { pathname } = new URL(request.url)      // Pro tip: put the parsing of the route in a static method on the Object so you can use it in both places     // (note: the Worker and Object have to be in the same file to share the helper function)     const route = DurableBuildLog.toRouteParams(pathname)     if (!route.match) return notFound()      // Validate that the Client has access to this Site&#39;s build logs     if (route.client) {       if (!await clientHasAccess(route.sitename, request.headers)) {         return notAuthorized()       }     }      // Validate that the Build Server is definitely one of ours.     if (route.server) {       if (!serverIsAuthentic(request.headers)) {         return notAuthorized()       }     }      // Find the DO for our tree_id     const objectId = env.BuildObjects.idFromName(route.tree_id)     const object = await env.BuildObjects.get(objectId)      // Pass our request through and return     const response = await object.fetch(request)     // Logging the response helped a lot with tracking down bugs inside the DO.     // You can use `wrangler tail` to follow these, but beware: it only logs     // from inside the worker, not the Object instance.     console.log(response)     return response   }, }</p><p>--code：language-js--EXPORT DEFAULT{async FETCH(REQUEST，Env){const{pathname}=new URL(request.url)：//Pro提示：将对路由的解析放在对象上的静态方法中，这样您就可以在两个地方使用它：//(注意：Worker和对象必须在同一个文件中才能共享助手函数)：Const route=DurableBuildLog.toRouteParams(Pathname)；If(！route.Match)return NotFound()*//。的生成日志是否为(route.client){1，如果(！await clientHasAccess(route.sitename，request.headers)){1，3，3，3，2}是否返回NoAuthorized()//验证生成服务器是否确实是我们的服务器之一。*if(route.server){95if(！serverIsAuthentic(request.headers)){438，reurn NoAuthorized()*}**//找到我们的tree_id的do，const ObjectID=env.BuildObjects.idFromName(route.tree_id)，const Object=await env.BuildObjects.get(Objectd)：//传递我们的请求并返回。*//您可以使用`wrangler Tail`来跟踪这些内容，但请注意：它只记录来自Worker内部的日志，而不是对象实例。*console.log(Response)返回响应}，}。</p><p> That&#39;s it! We do logging, route parsing and authentication/authorization here but otherwise we just pass requests through to the instance ID derived from the `tree_id` of the current commit.</p><p>就是这样！我们在这里做日志记录、路由解析和认证/授权，否则我们只会将请求传递给从当前提交的`tree_id`派生的实例ID。</p><p>  Once you start thinking of a &#34;Durable Object&#34; as a &#34;stateful worker I can spring into existence anywhere in the world based off its ID&#34;, it starts to become a bit easier to imagine use-cases. For us, we just need to create Websocket connections whenever clients and build servers connect to us, then dispatch events as they come in.</p><p>一旦你开始考虑一个持久的对象，作为一个有状态的工作者，我可以根据它的ID突然出现在世界任何地方，它开始变得更容易想象用例。对于我们来说，我们只需要在客户端和构建服务器连接到我们时创建WebSocket连接，然后在事件传入时进行分派。</p><p>  --CODE:language-js-- export class DurableBuildLog {   // Static method so we can call it from inside and outside the Object   static  toRouteParams(pathname) {     const match = pathname.match(       /^\/((client)|(server))\/([\w-]+)\/([a-f0-9]{15})\/ws$/     )     if (!match) return { match: false }     const [_, __, client, server, sitename, tree_id] = match      return { match: true, client, server, sitename, tree_id }   }</p><p>--代码：Language-js--导出类DurableBuildLog{//静态方法，这样我们就可以从对象内部和外部调用它，静态toRouteParams(路径名){*Const Match=pathname.Match(**/^\/((client)|(server))\/([\w-]+)\/([a-f0-9]{15})\/ws$/*)if(！Match)返回{Match：False}*Const[_，__，Client，Server，Sitename，Tree_id]=Match返回{Match：True，Client，Server，Sitename，tree_id}{Match：true，client，server，sitename，tree_id}。</p><p> Note that this assumes that the &#34;Worker&#34; and our &#34;Object&#34; are defined in the same file (FYI: this is how the  demo works but not the  guide). Using the same file means that both the Worker and the Object can use `DurableBuildLog.toRouteParams` to parse the route which feels like a good enough reason to co-locate them to me.</p><p>请注意，这里假设&#34；worker和我们的&#34；对象是在同一个文件中定义的(仅供参考：这是演示的工作方式，而不是指南)。使用同一个文件意味着Worker和Object都可以使用`DurableBuildLog.toRouteParams`来解析路由，这让我觉得有足够的理由将它们放在一起。</p><p> But this makes the deployment a little confusing—there&#39;s actually three steps (I learned about this from the  publish.sh file in the demo):</p><p>但这让部署有点混乱--实际上有三个步骤(我是从演示中的Publish.sh文件了解到这一点的)：</p><p> Deploy the script as if it was a normal worker  but have the DO class defined and `export`ed inside it. It won&#39;t work yet, we just need it to have been published once before the next step works.</p><p>将脚本作为普通工作程序进行部署，但要在其中定义do类并‘export`’。它还不会奏效，我们只需要在下一步奏效之前把它出版一次。</p><p> Create a namespace from the Object: effectively telling Cloudflare: hey, `DurableBuildLog` is a Durable Object definition, please create a namespace for it and give me the ID.</p><p>从Object创建命名空间：有效地告诉Cloudflare：嘿，`DurableBuildLog`是一个持久的对象定义，请为它创建一个命名空间，并给我ID。</p><p> Deploy the script again with the DO namespace  in your Worker&#39;s bindings. This tells Cloudflare to inject `BuildObjects` on the `env` argument to the Worker, wiring things up.</p><p>在您的Worker绑定中使用DO命名空间再次部署脚本。这将告诉Cloudflare在`env`参数上向Worker注入`BuildObjects`，并将其连接起来。</p><p> Thankfully, after the first time,  you only need to do step 3 to update  both your Worker and your Object code. Again, that for me is a good reason to colocate your Worker and Object, but again this is early beta DX and I&#39;m sure it&#39;ll improve.</p><p>值得庆幸的是，在第一次更新之后，您只需执行步骤3即可更新您的Worker代码和目标代码。同样，对我来说，这是一个很好的理由来放置你的工作人员和对象，但这仍然是早期的测试版DX，我相信它会改进的。</p><p>  --CODE:language-js--   constructor(  state,   env) {     // We could use state.storage if we needed these logs to persist, but we don&#39;t.     // So we&#39;ll just use an instance variable and accept its limitations (see below)     this.server = null     this.clients = []     this.resetLogs()   }    resetLogs = () =&gt; {     this.logs = []   }</p><p>--code：language-js--构造函数(state，env){//如果我们需要这些日志持久化，我们可以使用state.storage，但我们不会。//所以我们将只使用实例变量并接受它的限制(见下文)。对于this.server=null，this.clients=[].setthis.resetLogs()，}Reset Logs=()=&gt；{this.logs=。</p><p> Here, `state.storage` is the API  the docs talk about, and we thought we would need, but we so far haven&#39;t. It turns out, these instances have a small amount of in-memory storage, and so we can just use `this.logs = []` to store our build-logs-so-far. Since our Builder opens a WS connection while it&#39;s building, the effect is that this in-memory instance variable seems to be preserved for the duration of the build,  regardless of whether a client or builder reaches the Object first.</p><p>这里，`state.storage`是文档所说的API，我们认为我们需要，但我们到目前为止还没有。事实证明，这些实例的内存存储空间很小，所以我们可以使用`this.logs=[]`来存储到目前为止的构建日志。由于我们的Builder在构建过程中打开了WS连接，因此无论是客户端还是构建器首先到达对象，其效果都是内存中的实例变量似乎在构建期间被保留。</p><p> Note:  In-memory storage is subject to the same   eviction rules  as normal workers. But in our case, if the Object instance gets evicted during a build, our experience degrades back to our   GraphQL fallback . In practice, since our builds are quite short, we&#39;ve been OK so far, but it&#39;s something we could revisit with a more resilient implementation down the track.</p><p>注意：内存存储遵循与普通工作者相同的逐出规则。但在我们的例子中，如果对象实例在构建期间被逐出，我们的体验将降级为GraphQL后备。在实践中，由于我们的构建时间很短，到目前为止我们还可以，但这是我们可以通过更具弹性的实现来重新考虑的问题。</p><p>  --CODE:language-js--   // Entry point for all new clients/build servers   async fetch(  request) {     // See note on handleErrors below     return await this.handleErrors(  request, async () =&gt; {       const { pathname } = new   URL(  request.url)       const { match, client, server } = DurableBuildLog.toRouteParams(pathname)       if (!match)         return new   Response(&#39;Not found&#39;, {           status: 404,         })        // The only requests we expect to get this far are WebSocket connections       if (  request.headers.get(&#39;Upgrade&#39;) !== &#39;websocket&#39;) {         return new   Response(&#39;expected websocket&#39;, { status: 400 })       }        // Note: const [client_ws, our_ws] = new WebSocketPair() explodes       // as `WebSocketPair` is a secret Rust object and hasn&#39;t been made iterable.       // This is a bug and has been reported.       const pair = new WebSocketPair()       const [client_ws, our_ws] = [pair[0], pair[1]]        // Accept our end of the WebSocket. This tells the runtime that we&#39;ll be terminating the       // WebSocket in JavaScript, not sending it elsewhere.       our_ws.accept()        // If this is a server connection, kick any previous connections,       // clear the logs, and wire event handlers up       if (server) {         if (this.server) this.server.close(1000, &#39;You got kicked&#39;)          this.resetLogs()         this.server = our_ws         our_ws.addEventListener(&#39;message&#39;, this.serverMessage)         our_ws.addEventListener(&#39;close&#39;, this.closeServer)         this.broadcast({ meta: &#39;server connected&#39; })       }        // For client connections, send the logs so far, and add them to the client list       if (client) {         const initial_payload = [           { meta: &#39;connected ok&#39;,   VERSION },           ...this.logs,         ]         if (this.safeSend(...initial_payload)(our_ws)) {           this.clients.push(our_ws)         }       }        return new   Response(null, { status: 101, webSocket: client_ws })   }</p><p>--code：language-js--//所有新客户端的入口点/构建服务器异步获取(请求){2，//请参见下面的handleErrors说明，请等待this.handleErrors(Request，async()=&gt；{Const{pathname}=new URL(request.url)=#const{Match，Client，Server}=DurableBuildLog.toRouteParams(路径名)=DurableBuildLog.toRouteParams(路径名))。，{Status：404，})//我们预计到目前为止的唯一请求是WebSocket连接。如果(request.headers.get(&#39；升级)！==&#39；WebSocket；){将返回新的响应(&#39；预期的WebSocket&#39；)，则会返回新的响应(&#39；预期的WebSocket&#39；)//如果(Request.headers.get(&#39；升级)！==&#39；WebSocket；){将返回新的响应。，{status：400})}//备注：const[Client_ws，our_ws]=new WebSocketPair()在下面爆炸//因为`WebSocketPair`是一个秘密的Rust对象，还没有被设置为可迭代。*//这是一个漏洞，已被报告。*const Pair=new WebSocketPair()；const[Client_ws，our_ws]=[Pair[0]，Pair[1]]：//接受我们的WebSocket端。这告诉运行时，我们将在JavaScript中终止//WebSocket，而不是将其发送到其他地方。*@our_ws.Accept()//如果这是一个服务器连接，如果(Server){*if(this.server)this.server.lose(1000，#39；您被踢到)，则取消之前的任何连接，恢复//清除日志，并连接事件处理程序。如果(Server){*if(this.server)this.server.lose(1000，#39；您被踢了)，则取消这一连接。server=our_ws，#xOur_ws.addEventList.list)连接到我们的_ws.addEventList.lose(1000，#39；你被踢了##；)；如果这是一个服务器连接，则取消之前的任何连接，删除//清除日志，并连接事件处理程序。，this.serverMessage)和我们的_ws.addEventListener(&#39；Close&39；，this.closeServer)和//广播({meta：&#39；服务器已连接)//对于客户端连接，发送到目前为止的日志，并将它们添加到客户端列表中。如果(客户端){0；const Initial_Payload=[1]，则将日志添加到客户端列表中。，VERSION}，...this.logs，]是否会返回新的响应(空，{状态：101，Web套接字：Client_ws}){(this.SafeSend(...Initial_payload)(Our_Ws)){_this.clients.ush(Our_Ws)*})。</p><p> Note: This took a long time to get right, mainly because debugging is a pain (console logs here don&#39;t reach the `wrangler tail` logs on the Worker, despite being in the same file). One absolute little champion nugget of code is the   handleErrors helper  from the Chat demo. This catches exceptions and sends valid WebSocket packets with the error message, rather than letting the request fail. I wouldn&#39;t have been able to get this going without it, but again, this is extremely early-access code, I&#39;m sure the DX story will vastly improve.</p><p>注意：这花了很长时间才纠正过来，主要是因为调试很麻烦(这里的控制台日志不能到达工作进程上的‘wrangler Tail’日志，尽管它们在同一个文件中)。聊天演示中的handleErrors助手绝对是一个小的冠军代码。这会捕获异常并发送带有错误消息的有效WebSocket数据包，而不是让请求失败。如果没有它，我不可能让这一切进行下去，但再说一次，这是非常早进入的代码，我相信DX的故事会有很大改善。</p><p> This method, assuming the request is valid, creates a  WebSocketPair (which is a non-standard extension to the Fetch API of Cloudflare&#39;s invention, btw) keeps a hold of one end in-memory and sends the other down as part of the Response. Once that connection is established, you can poke any data you want down it. Easy as.</p><p>假设请求有效，此方法将创建WebSocketPair(这是Cloudflare发明的Fetch API的非标准扩展)，将一端保留在内存中，并将另一端作为响应的一部分向下发送。一旦建立了连接，您就可以向下插入任何您想要的数据。简单得很。</p><p>  --CODE:language-js--   // When the server sends us an event, broadcast it to the currently-connected clients   // and save it (in memory) for any clients that connect later   serverMessage(  event) {     let msg     try {       msg =   JSON.parse(  event.data)     } catch (e) {       msg = { error: e }     }     this.broadcast(msg)     this.logs.push(msg)   }</p><p>--code：language-js--//当服务器向我们发送事件时，将其广播给当前连接的客户端//并将其保存(在内存中)，以供以后连接到服务器的任何客户端使用。serverMessage(Event){n让msg尝试{_msg=JSON.parse(event.data)*}Catch(E){_msg={error：E}**}nthis.Broadcast(Msg)。</p><p> As for broadcasting to the clients, the only slight complexity is handling the fact that disconnections in WebSockets aren&#39;t always events, sometimes a `.send` call will just fail:</p><p>至于向客户端广播，唯一稍微复杂的是处理WebSocket中的断开连接并不总是事件，有时`.send`调用会失败：</p><p> An aside: code like `this.clients = this.clients.filter(...)` always makes me nervous as it&#39;s not threadsafe. But since JS is single-threaded and your instance is guaranteed to be running in exactly one place worldwide, it&#39;s fine. And embracing that simplifies your code. A lot.</p><p>顺便说一句：像`this.clients.filter(...)`这样的代码总是让我紧张，因为它不是ThreadSafe。但是，由于JS是单线程的，并且您的实例保证只在全球的一个地方运行，所以它很好。接受这一点可以简化您的代码。很多。</p><p> A couple of small utility functions have been ommitted, including a VERSION constant that we find-replace when we deploy, again just so I know 100% that the code has been updated on DO. But other than that, that&#39;s the whole Durable Object!</p><p>几个小的实用函数被省略了，包括一个我们在部署时查找-替换的版本常量，同样是为了让我100%知道代码已经在DO上更新了。但除此之外，这就是所有耐久的目标！</p><p>  The changes on the Build Server side of things are extremely minimal. We use  Websocket-Node to connect to `wss://live-build-logs.lincbot.com/server/${sitename}/${tree_id}/ws` with a shared secret, then push each line of logging as it&#39;s created, along with some metadata like `messageType` of `start_cmd` or `append_log`, etc, knowing that it will be broadcast to any clients who are watching. Of course, if no clients are connected, the Object instance will come into being, accumulate the logs in-memory, then shut down, happy in the knowledge that  it was ready, even if it never got asked to do anything.</p><p>Build Server端的变化非常小。我们使用WebSocket-Node使用共享密钥连接到`wss://live-build-logs.lincbot.com/server/${sitename}/${tree_id}/ws`，然后在创建日志时推送每一行日志，以及一些元数据，如`start_cmd`或`append_log`的`MessageType`，知道它将被广播给任何正在观看的客户端。当然，如果没有客户端连接，对象实例就会出现，在内存中积累日志，然后关闭，高兴地知道它已经准备好了，即使它从未被要求做任何事情。</p><p> But the real win? We  didn&#39;t need to change our existing logging: we still flush to Dynamo and trigger GraphQL every 10 seconds. So if Durable Objects is ever unavailable, or our implementation ever breaks, our existing fallback will continue to work.</p><p>但真正的胜利是什么？我们不需要更改现有的日志记录：我们仍然刷新到Dynamo并每10秒触发一次GraphQL。因此，如果持久对象不可用，或者我们的实现中断，我们现有的后备将继续工作。</p><p>  The final piece is to reconcile the events as they occur over the build log WS with the ones coming from the GraphQL subscription to display in the UI. That ends up involving a little bit of complexity but it&#39;s entirely related to the structure of our app and the choices we&#39;ve made for partitioning data in the past, so I won&#39;t go into the details here.</p><p>最后一步是将在构建日志WS上发生的事件与来自GraphQL订阅的事件进行协调，以显示在用户界面中。这最终会涉及到一些复杂的问题，但这完全与我们的应用程序的结构以及我们过去对数据分区所做的选择有关，所以我在此不再赘述。</p><p> The one thing I will mention is that there are two alternatives we explored: the first is using events from the DO to update the local GraphQL cache, and the second is leaving the GraphQL cache as-is and merging the data within the React component tree. We chose the latter because we&#39;re considering the DO &#34;live&#34; build logs very much a progressive enhancement—until we&#39;ve run them in production for a while we didn&#39;t want to have any code that touched our GraphQL &#34;source of truth&#3</p><p>我要提到的一件事是，我们探索了两种替代方案：第一种是使用DO中的事件来更新本地GraphQL缓存，第二种是保持GraphQL缓存不变并合并Reaction组件树中的数据。我们之所以选择后者，是因为我们认为DO实时构建日志是一种渐进的增强--直到我们在生产中运行它们一段时间后，我们才希望有任何代码触及我们的图形真理源。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://linc.sh/blog/durable-objects-in-production">https://linc.sh/blog/durable-objects-in-production</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/生产/">#生产</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/objects/">#objects</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/日志/">#日志</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>