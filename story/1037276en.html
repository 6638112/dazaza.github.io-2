<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>写作锈灵药Writing Rust the Elixir Way</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Writing Rust the Elixir Way<br/>写作锈灵药</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-30 21:53:28</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/7bed71e248059793470350c1a7e5581b.jpg"><img src="http://img2.diglog.com/img/2020/11/7bed71e248059793470350c1a7e5581b.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>It&#39;s not a secret that I&#39;m a big fan of  Elixir, so when I started doing Rust development I tried to bring some ideas from Elixir to the world of  Rust. This post describes some of the tools I&#39;m building to bring the power of Elixir to Rust.</p><p>我是Elixir的忠实拥护者，这不是什么秘密，因此，当我开始进行Rust开发时，我试图将一些想法从Elixir带入Rust的世界。这篇文章描述了我正在构建的将Elixir的功能带到Rust的一些工具。</p><p>  It&#39;s hard to just pick a few of them, but I believe that Elixir&#39;s biggest advantage comes from using  Erlang as the underlying virtual machine, specially from these 2 properties:</p><p>  很难仅选择其中的几个，但是我相信Elixir的最大优势来自使用Erlang作为底层虚拟机，特别是来自以下两个属性：</p><p>   This is something hard to explain until you experience it yourself. I learned early in my career that you should  never create a thread while handling a request. Threads are heavy, expensive and too many of them can bring your whole machine down. In most cases it&#39;s enough to use a  thread pool, but this approach fails once the number of concurrent tasks outgrows the number of threads in the pool.</p><p>   除非您亲自体验，否则这很难解释。我在职业生涯的早期就知道不要在处理请求时创建线程。线程很重，很昂贵，而且线程太多会使您的整个计算机瘫痪。在大多数情况下，使用线程池就足够了，但是一旦并发任务数超过了池中的线程数，这种方法就会失败。</p><p> Let&#39;s look at an example: imagine a rust application that just creates 2000 threads that wake up every 100 ms and go right back to sleep.</p><p> 让我们看一个例子：假设一个rust应用程序仅创建2000个线程，每100毫秒唤醒一次，然后立即进入睡眠状态。</p><p> use  std :: thread ; use  std :: time :: Duration ; fn  main ()  {  for  _  in  0 .. 2_000  {  thread :: spawn (||  loop  {  thread :: sleep ( Duration :: from_millis ( 100 ));  });  }  thread :: sleep ( Duration :: from_secs ( 1_000 )); }</p><p> 使用std :: thread;使用std :: time :: Duration fn main（）{用于_ in 0 .. 2_000 {线程::生成（||循环{线程:: sleep（持续时间:: from_millis（100））;}）; }线程::睡眠（持续时间:: from_secs（1_000））; }</p><p> Even though the threads don&#39;t do anything, just running this on my MacBook forces it to reboot after a few seconds. This makes it impractical to have massive concurrency with threads. There are many solutions to this problem. The one chosen by Elixir is to abstract concurrent tasks with something called  Processes. They are extremely lightweight, so even running  2 million of them doesn&#39;t present a challenge.</p><p> 即使线程不执行任何操作，只要在我的MacBook上运行该命令，它就会在几秒钟后重新启动。这使得与线程进行大量并发是不切实际的。有许多解决此问题的方法。 Elixir选择的一种方法是使用称为流程的东西抽象并发任务。它们非常轻巧，因此即使运行200万也不会构成挑战。</p><p>  You can achieve  amazing concurrency and performance using  async Rust, but working with async Rust is not as simple as writing regular Rust code and it just doesn&#39;t provide you the same features as Elixir Processes do.</p><p>  使用异步Rust可以实现惊人的并发性和性能，但是使用异步Rust并不像编写常规Rust代码那样简单，并且它没有为Elixir Processes提供相同的功能。</p><p> After thinking for a long time how I could make something that reassembles Elixir Processes in Rust I came up with the idea to introduce an intermediate step,  WebAssembly. WebAssembly is a low level bytecode specification that Rust can target. The idea was simple, instead of compiling Rust for x86-64 you would compile it to the WASM target. From there I would build a set of libraries and a WebAssembly runtime that exposes the concept of  Rust Processes. Contrary to operating system processes or threads, they are lightweight with small memory footprints, fast to create and terminate, and the scheduling overhead is low. In other languages they are also known as  green threads and  goroutines, but I will call them processes to stay close to Elixir&#39;s naming convention.</p><p>在思考了很长时间之后，我如何制作一些可以在Rust中重组Elixir Processes的东西之后，我想到了引入一个中间步骤WebAssembly的想法。 WebAssembly是Rust可以定位的低级字节码规范。这个想法很简单，您无需将其编译为x86-64的Rust，而是将其编译为WASM目标。从那里，我将构建一组库和一个WebAssembly运行时，以展示Rust Processes的概念。与操作系统进程或线程相反，它们是轻量级的，具有较小的内存占用空间，可快速创建和终止，并且调度开销较低。在其他语言中，它们也称为绿色线程和goroutine，但是我将它们称为与Elixir的命名约定保持一致的进程。</p><p>  Let&#39;s look at the same Rust example, but now implemented with Lunatic. At the same time we will crank up the number of concurrent processes to 20k.</p><p>  让我们看一个相同的Rust示例，但是现在使用Lunatic实现了。同时，我们将并行进程数提高到20k。</p><p> use  lunatic ::{ Channel ,  Process }; fn  main ()  {  let  channel :  Channel &lt; () &gt;  =  Channel :: new ( 0 );  for  _  in  0 .. 20_000  {  Process :: spawn ((),  process ) .unwrap ();  }  channel .receive (); } fn  process ( _ :  ())  {  loop  {  Process :: sleep ( 100 );  } }</p><p> 使用疯子::: Channel，Process}; fn main（）{let channel：Channel  = Channel :: new（0）; for _ in 0 .. 20_000 {Process :: spawn（（），process）.unwrap（）; } channel .receive（）; } fn process（_：（））{循环{Process :: sleep（100）; }}</p><p> To run this you will need to compile this Rust code to a  .wasm file first:</p><p> 要运行此程序，您需要首先将此Rust代码编译为.wasm文件：</p><p>    Contrary to the previous example this runs without hiccups on my Late 2013 Macbook and the CPU utilisation is minimal, even if we are using 10x more concurrent tasks. Let&#39;s examine what is exactly happening here.</p><p>    与之前的示例相反，即使我使用的并发任务多10倍，此操作在我的2013年末Macbook上也不会打h，并且CPU利用率极低。让我们检查一下这里到底发生了什么。</p><p> The processes spawned by Lunatic are actually taking full advantage of the power provided by async Rust. They are scheduled on top of a  work stealing async executor, the same used by  async-std. Calling  Process::sleep(100) will actually invoke  smol&#39;s  at function.</p><p> Lunatic产生的进程实际上是在充分利用异步Rust提供的功能。它们被安排在窃取异步执行器的工作之上，与async-std相同。调用Process :: sleep（100）实际上会调用smol的at函数。</p><p> Wait a second! How does this work without the  .await keyword, you may ask yourself. Lunatic takes the same approach as Go, Erlang and the earlier implementation of Rust based on green threads. It creates a tiny stack for executing the process and grows it when your applications needs more. This is a bit less efficient than calculating the exact stack size during compile time as async Rust is doing, but a reasonable tradeoff I would say.</p><p> 等一等！您可能会问自己，如果没有.await关键字，该如何工作。 Lunatic采用与Go，Erlang和基于绿色线程的Rust早期实现相同的方法。它创建了一个小的堆栈来执行该过程，并在您的应用程序需要更多时增加它。这比异步Rust在进行编译时计算确切的堆栈大小要低一些，但是我会说这是一个合理的折衷。</p><p> Now you can write regular  blocking code, but the executor will take care of moving your process off the execution thread if you are waiting, so you never block a thread.</p><p>现在您可以编写常规的阻塞代码，但是如果您在等待，执行程序将负责将您的进程移出执行线程，因此您永远不会阻塞线程。</p><p> As we saw earlier, scheduling threads is a hard task for the operating system. To replace one thread that&#39;s being executed with another one, a lot of work needs to be done (including saving all the registers and some thread state). However, switching between Lunatic Processes does only the minimal amount of work possible. With an idea pioneered by the  libfringe library and using some  asm! macro magic, Lunatic lets the Rust compiler figure out the minimal number of registers to be preserved during context switches.  This makes scheduling Lunatic processes zero-cost. On my machine usually 1ns, equivalent to a function call.</p><p> 如前所述，对操作系统而言，调度线程是一项艰巨的任务。要将一个正在执行的线程替换为另一个正在执行的线程，需要完成许多工作（包括保存所有寄存器和某些线程状态）。但是，在Lunatic流程之间进行切换只会做最少的工作。 libfringe库率先提出了一个想法，并使用了一些asm！宏魔术，Lunatic让Rust编译器找出上下文切换期间要保留的最小寄存器数。这使得计划Lunatic流程的成本为零。在我的机器上通常为1ns，相当于一个函数调用。</p><p> Another benefit of scheduling the Processes in user space instead of using threads is that other applications will continue running normally on your machine, even if your app misbehaves.</p><p> 在用户空间中调度进程而不使用线程的另一个好处是，即使您的应用程序行为不当，其他应用程序仍将继续在您的计算机上正常运行。</p><p> Now that we saw how Lunatic allows you to create applications with massive concurrency, let&#39;s look at fault tolerance.</p><p> 现在，我们了解了Lunatic如何允许您创建具有大量并发性的应用程序，让我们看一下容错能力。</p><p>  Maybe the most known Eralng/Elixir philosophy is  &#34;let it crash&#34;. If you are building complex systems it&#39;s impossible to predict all failure scenarios. Inevitably something is going to fail in your application, but this failure should not bring down the whole thing.</p><p>  也许最著名的Eralng / Elixir哲学是“让它崩溃”。如果您要构建复杂的系统，则不可能预测所有故障情况。不可避免地会在您的应用程序中失败，但是这种失败不会使整个事情崩溃。</p><p> Elixir Processes are completely isolated and can only communicate through messages with each other. This allows you to design your application in a way that failure stays contained inside one process and doesn&#39;t affect the rest of them.</p><p> Elixir进程是完全隔离的，并且只能通过消息相互通信。这样一来，您就可以设计应用程序，使故障保持在一个进程内，而不会影响其余进程。</p><p> Lunatic provides even stronger guarantees than Erlang here.  Each Lunatic process gets their own heap, stack and syscalls.</p><p> 与这里的Erlang相比，Lunatic提供了更强大的保证。每个Lunatic进程都有自己的堆，堆栈和syscall。</p><p>  use  lunatic ::{ Process ,  net };  // Once WASI gets networking support you will be able to use Rust&#39;s `std::net::TcpStream` instead. use  std :: io ::{ BufRead ,  Write ,  BufReader }; fn  main ()  {  let  listener  =  net :: TcpListener :: bind ( &#34;127.0.0.1:1337&#34; ) .unwrap ();  while  let  Ok ( tcp_stream )  =  listener .accept ()  {  Process :: spawn ( tcp_stream ,  handle ) .unwrap ();  } } fn  handle ( mut  tcp_stream :  net :: TcpStream )  {  let  mut  buf_reader  =  BufReader :: new ( tcp_stream .clone ());  loop  {  let  mut  buffer  =  String :: new ();  buf_reader .read_line ( &amp; mut  buffer ) .unwrap ();  tcp_stream .write ( buffer .as_bytes ()) .unwrap ();  } }</p><p>使用疯子::: Process，net}; //一旦WASI获得网络支持，您就可以使用Rust的`std :: net :: TcpStream`。使用std :: io :: {BufRead，Write，BufReader}; fn main（）{让监听器= net :: TcpListener :: bind（“ 127.0.0.1:1337”）.unwrap（）;同时让Ok（tcp_stream）=监听器.accept（）{Process :: spawn（tcp_stream，handle）.unwrap（）; }} fn句柄（mut tcp_stream：net :: TcpStream）{let mut buf_reader = BufReader :: new（tcp_stream .clone（））;循环{let mut buffer = String :: new（）; buf_reader .read_line（＆mut buffer）.unwrap（）; tcp_stream .write（buffer .as_bytes（））.unwrap（）; }}</p><p> This application listens on  localhost:1337 for tcp connections, spawns a process to handle each incoming connection and just echoes incoming lines.</p><p> 该应用程序在localhost：1337上侦听tcp连接，产生一个处理每个传入连接的进程，并仅回显传入的行。</p><p>   The first thing you will notice is that we don&#39;t use any  async or  .await keywords, even though this application will fully utilise Rust&#39;s async IO under the hood.</p><p>   您会注意到的第一件事是，即使此应用程序将完全利用Rust的异步IO，也不会使用任何async或.await关键字。</p><p> Also, the tcp connection becomes fully encapsulated in the Process, even if we called into unsafe C code that crashes:</p><p> 另外，即使我们调用了崩溃的不安全C代码，tcp连接也被完全封装在Process中：</p><p>  The crash is only contained to one connection in this case. It&#39;s not possible to implement something like this in Elixir, because if a call to a C function crashes it will take the whole virtual machine with it.</p><p>  在这种情况下，崩溃仅包含在一个连接中。在Elixir中无法实现这样的事情，因为如果对C函数的调用崩溃，它将占用整个虚拟机。</p><p> Another feature exclusive to Lunatic is the possibility to limit processes&#39; syscall access. If we replaced the previous  spawn call with:</p><p> Lunatic独有的另一个功能是可以限制进程的系统调用访问权限。如果我们将之前的生成调用替换为：</p><p>  any code called from inside the  handle function would be forbidden from using syscalls for filesystem access. This works also for C dependencies, because the enforcement is happening at such a low level. It allows you to express the sandboxing requirements of a Process and to use any dependency without fear. I&#39;m not aware of any other runtime that allows you to do this.</p><p>  从handle函数内部调用的任何代码都将禁止使用syscall进行文件系统访问。这也适用于C依赖项，因为强制执行的级别很低。它使您可以表达流程的沙盒需求，并可以毫无恐惧地使用任何依赖项。我不知道任何其他允许您执行此操作的运行时。</p><p>  This is just a teaser of the capabilities that  Lunatic will provide. There are many more features coming. Once you have this foundation, a new world of possibilities opens up. Some of the features I&#39;m excited about:</p><p>这只是Lunatic将提供的功能的预告片。还有更多功能。一旦有了这个基础，就会打开一个新的可能性世界。我很兴奋的一些功能：</p><p> The ability to transparently move Processes from one machine to another. The programming model relies on processes communicating through messages and if these messages are sent locally or between different computers on a network it doesn&#39;t really matter.</p><p> 将进程从一台机器透明地移动到另一台机器的能力。编程模型依赖于通过消息进行通信的过程，并且如果这些消息是在本地发送或在网络上的不同计算机之间发送的，则实际上并不重要。</p><p> Hot reloading. Now that we have the WASM bytecode as an in-between step it becomes possible to just generate new JIT machine code from it and replace it while the whole system is still running.</p><p> 热装。现在，有了WASM字节码作为中间步骤，就可以从中生成新的JIT机器代码，并在整个系统仍在运行时替换它。</p><p> Running complete applications compiled to WASM as a process. One example would be redirecting file read/writes from the application to tcp streams, as we are in complete charge of syscalls. The advantage here is that you are modelling the execution environment with code.</p><p> 运行完整的应用程序，并将其编译为WASM。一个示例是将文件读取/写入从应用程序重定向到tcp流，因为我们完全负责syscall。这样做的好处是您可以使用代码对执行环境进行建模。</p><p> Lunatic is still in its early days, so there is a lot of development left to do. If you are excited about it or have some ideas you would like to use Lunatic for, reach out to me over email  me@kolobara.com or on twitter  @bkolobara.</p><p> Lunatic仍处于起步阶段，因此还有很多工作要做。如果您对此感到兴奋或有一些想使用Lunatic的想法，请通过电子邮件me@kolobara.com或通过Twitter @bkolobara与我联系。</p><p> I also want to use this opportunity to say a big thank you to the teams working on Rust,  Wasmer,  Wasmtime,  Lucet and  waSCC. It would be impossible to build Lunatic without all the hard work put into this projects.</p><p> 我也想借此机会对Rust，Wasmer，W​​asmtime，Lucet和waSCC上的团队表示非常感谢。没有这个项目的所有辛苦工作，就不可能构建Lunatic。</p><p> P.S. If you would like to learn more about the magic of Erlang and Elixir, this is one of my favorite talks about it by  Saša Jurić: The Soul of Erlang and Elixir. Seriously, go and watch it!</p><p> 附言如果您想更多地了解Erlang和Elixir的魔力，这是SašaJurić我最喜欢的演讲之一：Erlang和Elixir的灵魂。认真地去看吧！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://kutt.it/Pq33h1">https://kutt.it/Pq33h1</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/写作/">#写作</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>