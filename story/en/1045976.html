<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Deno 1.7：独立二进制文件大小减少60％ Deno 1.7: 60% reduction in standalone binary size</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Deno 1.7: 60% reduction in standalone binary size<br/>Deno 1.7：独立二进制文件大小减少60％ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-23 16:05:24</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/90af1d8d66124624d0ca33eb2826b4b6.png"><img src="http://img2.diglog.com/img/2021/1/90af1d8d66124624d0ca33eb2826b4b6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>&lt;- Other News   GitHub      Today we are releasing Deno 1.7.0. This release contains many new features, somestabilizations, and some great improvements to existing APIs and tooling.</p><p>＆lt;-其他新闻GitHub今天我们发布了Deno 1.7.0。此版本包含许多新功能，一些稳定性以及对现有API和工具的一些重大改进。</p><p>  If you already have Deno installed you can upgrade to 1.7 by running deno upgrade. If you are installing Deno for the first time, you can use oneof the methods listed below:</p><p>  如果您已经安装了Deno，则可以通过运行deno upgrade升级到1.7。如果是第一次安装Deno，则可以使用下面列出的方法之一：</p><p>  Before reading on, please consider filling out the Deno survey. Even if you&#39;ve never usedDeno! It takes only 10 minutes and will help us tremendously in directing ourdevelopment.</p><p>  在继续阅读之前，请考虑填写Deno调查。即使您从未使用过Deno！仅需10分钟，将极大地帮助我们指导我们的发展。</p><p>     In the last release we added the ability to compile applications written forDeno into standalone, self-contained executables. When we initially released deno compile in 1.6.0, we had a list of pain points and features we wanted toaddress. This release addresses three of these.</p><p>     在上一发行版中，我们增加了将为Deno编写的应用程序编译成独立的自包含可执行文件的功能。当我们最初在1.6.0中发布deno编译时，我们有了要解决的痛点和功能列表。此版本解决了其中三个问题。</p><p> We are happy to report that in 1.7  deno compile can now cross-compile from anyin stable supported architecture (Windows x64, MacOS x64, and Linux x64) to anyother in stable supported architecture. This means you can now create binariesfor Windows and MacOS from a single Linux CI machine.</p><p> 我们很高兴地报告，在1.7 deno编译中，现在可以从任何稳定支持的体系结构（Windows x64，MacOS x64和Linux x64）交叉编译到任何其他稳定支持的体系结构。这意味着您现在可以从一台Linux CI计算机上为Windows和MacOS创建二进制文件。</p><p> Additionally,  deno compile now generates binaries that are 40-60% smaller thanthose generated by Deno 1.6. To try out this feature, use the  --lite flag whencompiling your application; this tells  deno compile to use a slimmed-downruntime-only Deno binary instead of the full Deno binary that was usedpreviously.</p><p> 此外，deno编译现在生成的二进制文件比Deno 1.6生成的二进制文件小40-60％。要尝试此功能，请在编译应用程序时使用--lite标志。这告诉deno编译使用仅精简运行时的Deno二进制文件，而不是以前使用的完整Deno二进制文件。</p><p> Below you can see an example of a simple hello world program being crosscompiled for Linux from macOS, then it being run on Linux.</p><p> 在下面，您可以看到一个简单的hello world程序示例，该程序已从macOS为Linux交叉编译，然后在Linux上运行。 </p><p>  Finally,  deno compile can now create binaries that have built-in CAcertificates, custom V8 flags, locked down Deno permissions, and pre-populatedcommand line arguments. This should make  deno compile useful to more people.</p><p>最后，deno编译现在可以创建具有内置CA证书，自定义V8标志，锁定Deno权限和预填充命令行参数的二进制文件。这应该使deno编译对更多人有用。</p><p> Here is an example where we create an executable from the std/http/file_servermodule that listens on port 8080 (instead of default 4507), and has CORSenabled. The permissions that the running code has is also locked down (can onlyread from current working directory, and can only listen on port 8080).</p><p> 这是一个示例，其中我们从std / http / file_server模块创建一个可执行文件，该可执行文件侦听端口8080（而不是默认的4507）并启用了CORS。正在运行的代码具有的权限也被锁定（只能从当前工作目录中读取，并且只能在端口8080上侦听）。</p><p>    Data URLsare a useful tool for executing code generated on the fly. In this release weadded support for data URLs in imports (both static and dynamic), as well as inWeb Workers. This feature is already supported across all modern browsers andNodeJS.</p><p>    数据URL是用于执行即时生成的代码的有用工具。在此版本中，我们增加了对导入（静态和动态）以及inWeb Workers中的数据URL的支持。所有现代浏览器和NodeJS已经支持此功能。</p><p>   Above code can be expressed as following data URL: &#34;data:application/typescript;base64,ZXhwb3J0IGNvbnN0IGEgPSAiYSI7CgpleHBvcnQgZW51bSBBIHsKICBBLAogIEIsCiAgQywKfQo=&#34;.This URL is created by base64 encoding the file contents, and appending it to data:application/typescript;base64,. For JavaScript you would append thecontents to  data:application/javascript;base64,.</p><p>   上面的代码可以表示为以下数据URL：＆＃34; data：application / typescript; base64，ZXhwb3J0IGNvbnN0IGEgPSAiYSI7CgpleHBvcnQgZW51bSBBIHsKICBBLAogIEIsCiAgQywKfQo =＆＃34;此URL由baseapplication编码和内容创建，并附加到： base64 ，。对于JavaScript，您可以将内容附加到data：application / javascript; base64,。</p><p>         This release adds a new  Deno.resolveDns API. It can be used to query DNSrecords from a DNS resolver. At the moment only DNS over UDP/TCP is supported(no DNS over HTTPS nor DNS over TLS). One can specify a custom nameserver (forexample Cloudflare&#39;s 1.1.1.1 or Google&#39;s 8.8.8.8) to use, but by default we willuse the system resolver (e.g.  /etc/resolv.conf on Linux).</p><p>         此版本添加了新的Deno.resolveDns API。它可用于从DNS解析器查询DNS记录。目前仅支持UDP / TCP上的DNS（不支持HTTPS上的DNS或TLS上的DNS）。可以指定要使用的自定义名称服务器（例如Cloudflare的1.1.1.1或Google的8.8.8.8），但是默认情况下，我们将使用系统解析器（例如Linux上的/etc/resolv.conf）。</p><p> The API currently supports  A,  AAAA,  ANAME,  CNAME,  MX,  PTR,  SRV,and  TXT records. Responses are returned as structured data.</p><p> 该API当前支持A，AAAA，ANAME，CNAME，MX，PTR，SRV和TXT记录。响应作为结构化数据返回。</p><p> Here is an example for you to try. The example is a very simple version of the dig tool on unix. You can pass it a domain name as the first argument, and itwill return the  A records for this domain via stdout.</p><p> 这是一个示例供您尝试。该示例是unix上的dig工具的非常简单的版本。您可以将域名作为第一个参数传递给它，它将通过stdout返回该域的A记录。 </p><p>     We have replaced the three unstable APIs ( Deno.transpileOnly,  Deno.bundle,and  Deno.compile) used to interact with Deno&#39;s built-in TypeScript compiler bya single improved function ( Deno.emit). You can read all about how to use Deno.emit to bundle, transpile, and more in the TypeScript section of the manual.</p><p>我们已经用一个改进的函数（Deno.emit）代替了与Deno的内置TypeScript编译器进行交互的三个不稳定的API（Deno.transpileOnly，Deno.bundle和Deno.compile）。您可以在手册的TypeScript部分中阅读有关如何使用Deno.emit进行捆绑，转译等的全部信息。</p><p>   deno fmt now supports formatting markdown files, including formatting ofJavaScript and TypeScript codeblocks in these files.</p><p>   deno fmt现在支持格式化降价文件，包括格式化这些文件中的JavaScript和TypeScript代码块。</p><p> Additionally a new flag  --ext was added to allow specifying file extensionwhen formatting code from stdin ( deno fmt -). The available file extensionsare  js,  jsx,  ts,  tsx, and  md. Keep in mind that this flag has noeffect when formatting files on disk.</p><p> 另外，添加了一个新的--ext标志，以便在从stdin（deno fmt-）格式化代码时指定文件扩展名。可用的文件扩展名是js，jsx，ts，tsx和md。请记住，格式化磁盘上的文件时此标志无效。</p><p>     This release a lot of effort has gone into aligning our implementations ofvarious web APIs (Text Encoding, URL, Streams, and WASM) to the variousspecifications for these APIs. This has mostly been internal bug fixes, but inone case specifically there is a rather severe user facing change.</p><p>     此版本已花费大量精力使我们各种Web API（文本编码，URL，流和WASM）的实现与这些API的各种规范保持一致。这主要是内部错误修复，但在一种情况下，尤其是用户面对的更改非常严重。</p><p> Previously we were implementing Streams API according to the spec from circaMarch 2020. In this revision of the spec the  ReadableStream class has a getIterator method that can be used to get an async iterator from the ReadableStream. In the up-to-date revision the  ReadableStream class is anasync iterator, and the  getIterator method has been removed.</p><p> 以前，我们是根据2020年3月左右的规范实现Streams API的。在此规范的修订版中，ReadableStream类具有getIterator方法，该方法可用于从ReadableStream获取异步迭代器。在最新版本中，ReadableStream类是模拟迭代器，并且已删除getIterator方法。</p><p> In an effort to move closer to spec, we want to remove the  getIterator methodon  ReadableStream. To give you time to update your usage of this deprecatedAPI, we have marked the method as  deprecated for this release (1.7). We areplanning to remove the deprecated method in Deno 1.8, which is slated to bereleased in 6 weeks, on March 2nd 2021.</p><p> 为了更接近规范，我们想删除ReadableStream上的getIterator方法。为了让您有时间更新此deprecatedAPI的用法，我们已将该方法标记为此版本（1.7）已弃用。我们计划在2021年3月2日删除将于6周内发布的Deno 1.8中不推荐使用的方法。</p><p> This deprecated API is used in some std modules (specifically std/async, andstd/http) in versions 0.83.0 or lower. Please upgrade to std version 0.84.0. Inyour own code, remove all  .getIterator() calls as shown below:</p><p> 在0.83.0或更低版本的某些std模块（特别是std / async和std / http）中使用了此不推荐使用的API。请升级到标准版本0.84.0。在您自己的代码中，删除所有.getIterator（）调用，如下所示： </p><p>    By default, Deno executes user code in a full sandbox, unless the user passes --allow-* flags on the CLI. Unfortunately, those permissions can&#39;t be scopedto specific modules. Many users have requested this feature, and we are happy toannounce that some progress has been made on this front. Starting with Deno 1.7,users can spawn Web Workers with custom set of permissions, making it possibleto run untrusted code inside a Deno process.</p><p>默认情况下，除非用户在CLI上传递--allow- *标志，否则Deno将在完整的沙箱中执行用户代码。不幸的是，这些权限不能限制在特定的模块上。许多用户都要求使用此功能，我们很高兴地宣布在此方面已经取得了一些进展。从Deno 1.7开始，用户可以使用自定义权限集生成Web Worker，从而可以在Deno进程中运行不受信任的代码。</p><p> It is important to know that permissions given to a worker must be a subset ofprocess permissions, ie. if the process was run without &#34;read&#34; permission thentrying to create worker with &#34;read&#34; permission will result in  PermissionDeniederror.</p><p> 重要的是要知道授予工作人员的权限必须是过程权限的子集，即。如果该进程在运行时没有＆＃34; read＆＃34;权限，然后尝试使用＆＃34; read＆＃34;创建工作程序权限将导致PermissionDeniederror。</p><p> NOTE: This feature is not browser compatible. Browsers will ignore  denofield in the worker option bag.</p><p> 注意：此功能与浏览器不兼容。浏览器将忽略worker选项包中的denofield。</p><p> Here is an example for you to try. It will spawn a worker with the  readpermission, which will then try to read the file  ./log.txt and send it back tothe client.</p><p> 这是一个示例供您尝试。它将产生具有读取权限的工作程序，然后该工作程序将尝试读取文件./log.txt并将其发送回客户端。</p><p>     You can also try run it without the  --allow-read permission. This will causean error to be thrown, because you are trying to escalate permissions:</p><p>     您也可以尝试在没有--allow-read许可的情况下运行它。这将导致引发错误，因为您正尝试升级权限：</p><p>    An unfortunate effect of Deno not having a &#34;document&#34; to run it&#39;s JavaScript in(a HTML page), is that Deno has never had a good way to determine the  originof a script. This is important for APIs like  window.localstorage, where thedata you interact with depends on the page (document) you are on. The LocalStorage API is one of many APIs that makes use of the origin, but this onespecifically is one we want to add soon.</p><p>    Deno没有＆＃34; document＆＃34;的不幸影响在一个HTML页面中运行它的JavaScript，是因为Deno从来没有一个确定脚本来源的好方法。这对于window.localstorage之类的API很重要，您与之交互的数据取决于您所在的页面（文档）。 LocalStorage API是使用起源的许多API之一，但是我们要尽快添加它。</p><p> This is also very useful for isomorphic code (code that runs on client andserver), for example during server side rendering of React components, becausethey can now both make use of  globalThis.location and relative  fetch.</p><p> 这对于同构代码（在客户端和服务器上运行的代码）（例如在React组件的服务器端渲染期间）也非常有用，因为它们现在可以同时使用globalThis.location和相对提取。 </p><p> In this release we are addressing this with the addition of the  --locationflag that lets you set &#34;document&#34; location for scripts. This location can be any http or  https URL (it does not need to exist). If this flag is unset, window.location will still be present, but will throw on access. The same goesfor relative URLs in  fetch and  new Worker. They will be relative to thelocation if it is set, otherwise they will throw. In workers the location willalways be set to the entrypoint script of the Worker.</p><p>在此版本中，我们通过添加--locationflag来解决此问题，该标志可让您设置＆＃34; document＆＃34;脚本的位置。该位置可以是任何http或https URL（不需要存在）。如果未设置此标志，则window.location仍将存在，但将引发访问。提取和新Worker中的相对URL相同。如果设置了它们，它们将相对于位置，否则它们将抛出。在工作程序中，位置始终将设置为工作程序的入口点脚本。</p><p> * the cli&#39;s API is stable. In the future when std becomes stable, likely we</p><p> * cli的API是稳定的。将来，当std变得稳定时，我们可能</p><p> We are aware that some modules use  window.location to determine if they arerunning in a browser or not. This is bad practice. Use typeof Deno !== &#34;undefined&#34; to determine if you are running in Deno, and use typeof document !== &#34;undefined&#34; to determine if the DOM is available or not.</p><p> 我们知道某些模块使用window.location来确定它们是否正在浏览器中运行。这是不好的做法。使用typeof Deno！==＆＃34; undefined＆＃34;确定您是否在Deno中运行，并使用typeof文档！==＆＃34; undefined＆＃34;确定DOM是否可用。</p><p>   Next to our support for streaming response bodies in  fetch, we now alsosupport streaming request bodies. This can be used to upload a large file to awebserver, without first having to buffer it in memory. This can be done bypassing a  ReadableStream to the  body field in the  fetch options.</p><p>   除了对获取中的流式响应正文的支持之外，我们现在还支持流式请求正文。这可用于将大文件上传到Web服务器，而无需先将其缓冲在内存中。可以绕过ReadableStream到获取选项中的body字段来完成此操作。</p><p>  Currently the only runtimes supporting fetch upload streaming are Chromium andDeno. Both implementations have a limitation where you cannot start receivingthe response body until the request body has been fully sent. This is not alimitation in the Fetch specification, rather in the implementations, and willbe addressed in the future.</p><p>  当前，仅支持提取上传流的运行时是Chromium和Deno。这两种实现都有一个局限性，即在请求主体已完全发送之前，您无法开始接收响应主体。这不是Fetch规范中的限制，而是实现中的限制，并将在以后解决。</p><p> For some more examples and usecases for fetch upload streaming take a look at Jake Archibald&#39;s post on the matter: https://web.dev/fetch-upload-streaming/.</p><p> 有关获取上传流的更多示例和用例，请参见Jake Archibald关于此事的文章：https：//web.dev/fetch-upload-streaming/。</p><p>   Some servers require that users reuse existing TLS sessions (for example FTP).Until now Deno has not had the ability to reuse TLS sessions, and instead wouldre-establish a new TLS session for each connection. In this release we haveadded a process global TLS session cache that will allow to reuse existing TLSsessions between the connections.</p><p>   某些服务器要求用户重用现有的TLS会话（例如FTP）。直到现在，Deno还无法重用TLS会话，而是会为每个连接重新建立新的TLS会话。在此版本中，我们添加了进程全局TLS会话缓存，该缓存将允许在连接之间重用现有的TLS会话。 </p><p> The session cache is an in memory cache with a size of 1024 sessions. Overflowsessions will cause others to be evicted. The TLS session cache is used on abest effort basis.</p><p>会话缓存是内存中的缓存，大小为1024个会话。会话过多会导致其他人被逐出。尽力使用TLS会话缓存。</p><p>   Deno.shutdown() and  Conn#closeWrite() are stabilized in this release. Thesefunctions are used to gracefully close a connection by signaling to the otherside that you are done sending data. Unlike the unstable version of this API,the  shutdown() method no longer has a  mode parameter; only the write end ofa socket can be shut down.</p><p>   Deno.shutdown（）和Conn＃closeWrite（）在此版本中已稳定。这些功能用于通过通知另一边您已完成发送数据的方式来正常关闭连接。与该API的不稳定版本不同，shutdown（）方法不再具有模式参数。只能关闭套接字的写端。</p><p> Also in this release the signature of the option bag for the unstable Deno.createHttpClient API has changed. This API can be used to customize how afetch is executed. Instead of being able to specify  caFile (the path to a filecontaining a custom CA certificate), you now specify  caData. This means youcan now use in memory certificates for  Deno.createHttpClient.</p><p> 同样在此版本中，不稳定的Deno.createHttpClient API的选项包的签名也已更改。该API可用于自定义执行获取的方式。现在，您不能指定caFile（包含自定义CA证书的文件的路径），而是指定caData。这意味着您现在可以在内存证书中使用Deno.createHttpClient。</p><p>  The unstable  Deno.permission APIs for the  net permission have also changedslightly. Instead of taking a  url parameter, we now use  host, to match whatthe  --allow-net flag supports.</p><p>  净权限的不稳定的Deno.permission API也已发生了轻微变化。现在，我们不再使用url参数，而是使用host来匹配--allow-net标志支持的内容。</p><p>    deno test --coverage now has the ability to report partially covered lines, aswell as to collect coverage for Deno subprocesses spawned from tests. We willcontinue improving coverage capabilities including other report formats in theupcoming releases.</p><p>    deno test --coverage现在可以报告部分覆盖的行，以及收集从测试生成的Deno子流程的覆盖率。我们将继续改进覆盖范围的功能，包括即将发布的版本中的其他报告格式。</p><p>    Users had previously reported a lot of issue regarding semi-random hangsoccurring in numerous  Deno APIs. After thorough investigation it wasdetermined that all of them were caused by interaction with the  tokio runtime.Due to API changes in  tokio 1.0 we had to re-architecture significant parts of deno_core to cater for those changes. In effect the  ResourceTable, astructure that holds Rust allocated objects (eg. a file handle, TCP connection)was rewritten from scratch, adding the ability to queue different &#34;ops&#34; actingon resources; this means that  writes to the same socket or file are nowguaranteed to happen in the same order as they were started, and so do  reads.</p><p>    用户以前曾报告过许多有关Deno API中半随机挂起的问题。经过彻底的调查后，确定它们都是由与tokio运行时的交互引起的。由于tokio 1.0中API的更改，我们不得不重新架构deno_core的重要部分以适应这些更改。实际上，ResourceTable会从头开始重写保存Rust分配的对象（例如，文件句柄，TCP连接）的结构，从而增加了对不同的队列进行排队的能力。代理资源；这意味着现在保证对同一套接字或文件的写入以与开始时相同的顺序进行，因此读取也是如此。</p><p>   As mentioned above, we spent a lot of time this release to align our web APIs tothe various API specifications. This has been greatly helped by integrating theweb platform test suite into our tests. Web platform tests is  the test suitethat all browser vendors use to test compatibility with the web platformspecifications. We have enabled thousands of tests, but we are far from donewith this effort (there are still thousands of web platform tests to enable). Ifyou think you can help with this effort, take a look at this issue: https://github.com/denoland/deno/issues/9001.</p><p>   如上所述，我们在此版本上花费了大量时间，以使我们的Web API与各种API规范保持一致。通过将Web平台测试套件集成到我们的测试中，这极大地帮助了我们。 Web平台测试是所有浏览器供应商用来测试与Web平台规范的兼容性的测试套件。我们已经启用了成千上万的测试，但是，这项工作还远远没有完成（仍有数千个Web平台测试需要启用）。如果您认为可以帮助您解决此问题，请查看以下问题：https://github.com/denoland/deno/issues/9001。 </p><p> We would greatly appreciate if you filled out the Deno survey, it takes only 10 minutes andwill help us tremendously in further development of Deno.</p><p>如果您填写了Deno调查，我们将不胜感激，它仅需10分钟，将极大地帮助我们进一步发展Deno。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://deno.land/posts/v1.7">https://deno.land/posts/v1.7</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/二进制/">#二进制</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/deno/">#deno</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>