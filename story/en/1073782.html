<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>催化：一种为锡拉和卡桑德拉设计的ORM，用锈迹书写Catalytic: An ORM Designed for ScyllaDB and Cassandra Written in Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Catalytic: An ORM Designed for ScyllaDB and Cassandra Written in Rust<br/>催化：一种为锡拉和卡桑德拉设计的ORM，用锈迹书写</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 09:53:42</div><div class="page_narrow text-break page_content"><p>The following is a guest post by Jasper Visser, a self-taught programmer and enthusiastic  Rustacean who is interested in scalable software design. Jasper is the kind of programmer who automates a 1-minute task by hand and likes to develop and contribute to open source projects.</p><p>以下是Jasper Visser的客座帖子，他是一位自学成才的程序员，也是一位热衷于可伸缩软件设计的Rustacean。Jasper是那种手工自动化一分钟任务的程序员，喜欢开发开源项目并为之做出贡献。</p><p> For more on Rust, the developers at ScyllaDB are hosting a hands-on workshop that covers the Rust driver and sample code.</p><p>关于生锈的更多信息，ScyllaDB的开发人员正在举办一个实践研讨会，涵盖生锈驱动程序和示例代码。</p><p>  Today, I’m excited to unveil a project that I’ve been working on for the past few months. The majority of my working days are spent working with Java and SQL. In my spare time, I like to check out new technology and languages. I have been coding for quite a while now, starting around 5 years ago with  Swift, a language created by Apple for making iOS/macOS apps. I like creating libraries which are used as building blocks for other people’s projects. Swift looks quite a lot like Rust, the language that is used for Catalytic.</p><p>今天，我很兴奋地宣布了一个我在过去几个月里一直在做的项目。我大部分的工作时间都在使用Java和SQL。在业余时间，我喜欢了解新技术和新语言。我已经编写了很长一段时间了，大约5年前开始使用Swift，这是一种由苹果公司创建的用于制作iOS/macOS应用程序的语言。我喜欢创建用作其他人项目构建块的库。斯威夫特看起来很像Rust，这是一种用于催化反应的语言。</p><p> I crossed paths with Rust after reading some RFCs regarding Swift’s development. Swift wants to implement features Rust has, especially the unique Ownership model. Rust was released in about the same year as Swift. While Swift is a little more ergonomic (no lifetimes for example), Rust provides much more flexibility, safety and speed. I really like Rust’s ownership system and the effort of the community to make it compete with the speed of C, while also remaining safe. I made some side projects in Rust, including  GRDB-ORM, a wrapper around  GRDB which is in turn a thin wrapper for SQLite. GRDB-ORM generates high speed and safe Swift code which can interact with an SQLite database. It generates  Swift structs based on the metadata of the database. I like the idea of having a reliable library which derives code from database metadata.</p><p>在阅读了一些关于斯威夫特发展的RFC后，我遇到了锈迹。Swift希望实现Rust的功能，尤其是独特的所有权模式。Rust与Swift大约在同一年发布。虽然Swift更符合人体工程学（例如，没有寿命），但Rust提供了更大的灵活性、安全性和速度。我真的很喜欢Rust的所有权体系和社区的努力，让它在保持安全的同时与C的速度竞争。我在Rust中做了一些副项目，包括GRDB-ORM，它是GRDB的一个包装，反过来又是SQLite的一个薄包装。GRDB-ORM生成高速、安全的Swift代码，可以与SQLite数据库交互。它根据数据库的元数据生成Swift结构。我喜欢拥有一个从数据库元数据中派生代码的可靠库的想法。</p><p> My original goal was to build a server that would enable communication among iOS apps. The server needed a database which is able to handle a lot of writes while remaining scalable. Since scaling horizontally is an issue for relational databases, I had to search for a non-relational database that doesn’t suffer from scaling limitations.</p><p>我最初的目标是构建一个能够在iOS应用程序之间进行通信的服务器。服务器需要一个能够在保持可伸缩性的同时处理大量写操作的数据库。由于水平扩展是关系数据库的一个问题，我必须搜索一个不受扩展限制的非关系数据库。</p><p> It was a joy working with GRDB-ORM. The generated code ensured I wouldn’t have runtime issues. I knew that I needed something similar on the server side as well.</p><p>与GRDB-ORM合作是一种乐趣。生成的代码确保了我不会出现运行时问题。我知道我在服务器端也需要类似的东西。</p><p>   I came across ScyllaDB and I immediately liked the design: multiple computers (nodes) talking to each other and communicating the latest updates. I was impressed to see that ScyllaDB can handle  1 billion inserts a second and officially supports  materialized views, a feature sorely lacking in Apache Cassandra. Combine that with the knowledge that scaling is as simple as adding nodes, and you have an awesome database.</p><p>我遇到了“锡拉布”，我立刻就喜欢上了它的设计：多台计算机（节点）相互对话，交流最新的更新。令我印象深刻的是，ScyllaDB每秒可以处理10亿次插入，并正式支持物化视图，这是Apache Cassandra中非常缺乏的功能。再加上扩展和添加节点一样简单，你就拥有了一个很棒的数据库。</p><p> With an awesome database should come awesome drivers. I was really happy to see the team recently released an official Rust ScyllaDB driver. I think the team did a great job developing a Rust driver with the latest technology, in particular, the Tokio framework. It is fully async and provides a decent number of proc macros, making the library ergonomic and easy to setup.</p><p>一个很棒的数据库应该会有很棒的驱动程序。我真的很高兴看到车队最近释放了一名官方的铁锈锡拉司机。我认为这个团队用最新的技术开发了一个生锈的驱动程序，尤其是Tokio框架。它是完全异步的，并提供了大量的proc宏，使库符合人体工程学，易于设置。</p><p> The maintainers of the rust-scylla-driver respond quickly to issues and are happy to  profile and improve the driver. That triggered me enough to write  Catalytic, a blazingly fast and safe ORM ( Object–relational mapping) built on top of ScyllaDB’s official Rust driver. I did this because I hate:</p><p>rust scylla驱动程序的维护人员对问题做出快速响应，并乐于分析和改进驱动程序。这促使我写下了Catalystal，这是一个建立在Scyllab官方Rust驱动程序之上的速度极快、安全的ORM（对象-关系映射）。我这样做是因为我讨厌：</p><p>  ❌ Incorrect mapping between table and Rust struct. You usually want to have a Rust struct which maps 1-on-1 with a table in ScyllaDB. If you create the Rust structs by hand, it is possible to make a typo in the field declaration.</p><p>❌ 表和结构之间的映射不正确。你通常想要一个Rust struct，它用锡拉的表格一对一地映射。如果手工创建Rust结构，则可能会在字段声明中输入错误。</p><p>        The library isn’t fully complete:  not all types are supported yet. Please feel free to add a new type and submit a PR!</p><p>库还没有完全完成：还不支持所有类型。请随时添加新类型并提交PR！</p><p>  The ORM exclusively uses the prepared statement cache of the Rust driver. This means the driver will reuse queries if it can, providing the  fastest query execution possible.  To check what is generated based on this  table definition, see  this file. The Rust structs are generated in a directory you specify. This means you can generate the mapping once and use your crate without a running ScyllaDB definition.</p><p>ORM专门使用Rust驱动程序的预处理语句缓存。这意味着驱动程序将在可能的情况下重用查询，以尽可能快的速度执行查询。要检查基于此表定义生成的内容，请参阅此文件。Rust结构在指定的目录中生成。这意味着您可以生成一次映射，并在没有运行“锡拉卜”定义的情况下使用您的板条箱。</p><p>  Make sure you have ScyllaDB running. For this tutorial I recommend running  ScyllaDB in Docker. ScyllaDB provides an excellent course that covers the  Rust driver, therefore I skipped the introduction of the driver in this guide.</p><p>确保“锡拉布”正在运行。对于本教程，我建议在Docker中运行Scyllab。“锡拉布”提供了一门极好的课程，涵盖了铁锈驱动程序，因此我在本指南中跳过了对驱动程序的介绍。</p><p> Let me show you the possibilities of Catalytic with the help of some code. The project with the finished code can be found  here. For this example, a simple table is defined in ScyllaDB:</p><p>让我通过一些代码向您展示催化的可能性。完成代码的项目可以在这里找到。在本例中，一个简单的表格在Scyllab中定义：</p><p> create keyspace scylla_mapping with replication = { &#39;class&#39;: &#39;SimpleStrategy&#39;, &#39;replication_factor&#39;: 3};use scylla_mapping;create table person(name text, age int, email text, json_example text, primary key((name), age));</p><p>使用复制创建键空间scylla_映射={</p><p> Make sure your database is reachable from localhost with port 9042. You can change the database URL with the environment variable:  SCYLLA_URI.</p><p>确保可以通过端口9042从本地主机访问数据库。可以使用环境变量SCYLLA_URI更改数据库URL。</p><p> Let’s get our hands dirty and start with creating a Rust binary crate:</p><p>让我们把手弄脏，从制作生锈的二元板条箱开始：</p><p>  Create a rustfmt.toml file next to the Cargo.toml file. This file will format the generated code. The rustfmt.toml file should only have this as content:</p><p>创建一个rustfmt。货物旁边的toml文件。toml文件。此文件将格式化生成的代码。铁锈。toml文件应仅包含以下内容：</p><p>  Open the project in your favorite IDE and navigate to the Cargo.toml file. Add dependencies on the Catalytic and Scylla crate:</p><p>在您最喜欢的IDE中打开项目并导航到Cargo。toml文件。添加对催化剂和锡拉板条箱的依赖性：</p><p> [build-dependencies]catalytic = &#34;0.1&#34;catalytic_table_to_struct = &#34;0.1&#34;[dependencies]catalytic = &#34;0.1&#34;catalytic_macro = &#34;0.1&#34;scylla = &#34;0.3&#34;tracing = &#34;0.1&#34;tracing-subscriber = &#34;0.2&#34;</p><p>[构建依赖项]</p><p> Run your executable, which will download the dependencies. This is required to get autocomplete working in the IDE (I had to restart my IDE). The build-dependencies section is for  a build.rs file. The code inside a build.rs will execute when code changes are made in any of the source files.</p><p>运行可执行文件，它将下载依赖项。这是让自动完成在IDE中工作所必需的（我必须重新启动IDE）。“生成依赖项”部分用于生成。rs文件。构建中的代码。在任何源文件中进行代码更改时，rs将执行。</p><p> Create a build.rs file next to the Cargo.toml and rustfmt.toml file. In this build.rs, we call the table mapper to generate Rust structs. Copy paste this code into the new file:</p><p>创建一个构建。在货物旁边有rs文件。汤姆和鲁斯特福特。toml文件。在这个版本中。rs，我们调用表映射器来生成结构。将此代码复制粘贴到新文件中：</p><p> use catalytic_table_to_struct::transformer::DefaultTransformer;use std::env::current_dir;fn main() { // 1 catalytic_table_to_struct::generate( // 2 &amp;current_dir().unwrap().join(&#34;src&#34;).join(&#34;generated&#34;), // 3 DefaultTransformer, );}</p><p>使用Catalystic_table_to_struct:：transformer:：DefaultTransformer；</p><p> A customization point. The  DefaultTransformer is not intelligent,  so it  probably needs to be changed to a user-specific transformer if you want to do more. For an example of how to do this, see  this file.</p><p>定制点。DefaultTransformer不是智能的，因此如果您想做更多的工作，可能需要将其更改为用户特定的转换器。有关如何执行此操作的示例，请参阅此文件。</p><p>   Add the key-value pair below as an environment variable.  You can do this in your IDE or in the terminal if you run cargo from that:</p><p>将下面的键值对添加为环境变量。您可以在IDE或终端中执行此操作，如果您从以下位置运行货物：</p><p>   First, let’s run simple  CRUD operations. Example operations also available  here. First we need a   CachingSession, a thin wrapper around a regular ScyllaDB session that caches prepared statements.</p><p>首先，让我们运行简单的CRUD操作。此处还提供了示例操作。首先，我们需要一个CachingSession，一个围绕常规Scyllab会话的薄包装，用于缓存准备好的语句。</p><p>  use catalytic::env_property_reader::database_url;use scylla::statement::Consistency;use scylla::{CachingSession, SessionBuilder};mod generated;#[tokio::main]async fn main() { let session = create_session().await;}async fn create_session() -&gt; CachingSession { // Make sure there is logging available when executing the statements tracing_subscriber::fmt::init(); // Create a session: //      - which can operate on a single node //      - caches 1_000 queries in memory let session = CachingSession::from( SessionBuilder::new() .known_node(database_url()) .default_consistency(Consistency::One) .build() .await .unwrap(), 1_000, ); // Use the keyspace session .session .use_keyspace(&#34;scylla_mapping&#34;, false) .await .unwrap(); session}</p><p>使用Catalystal:：env_property_reader:：database_url；</p><p> Now that we have generated files and a session which can operate on those structs, let’s try to do stuff with the Person struct. Add this method in your main.rs file:</p><p>现在我们已经生成了可以在这些结构上操作的文件和会话，让我们尝试使用Person结构。在主菜单中添加此方法。rs文件：</p><p> /// This is an example what you can do with a Person/// You can only do CRUD operations with structs which borrows values, not owned structsasync fn crud_person(session: &amp;CachingSession) -&gt; Result&lt;(), QueryError&gt; { // This is an owned struct // You can convert this to a primary key or a borrowed version let person = Person { name: &#34;Jeff&#34;.to_string(), age: 52, email: &#34; [email protected]&#34;.to_string(), json_example: &#34;something&#34;.to_string(), }; // Insert the person // First convert it to the borrowed version person.to_ref().insert(session).await?; // Select the person back in memory // This will return an owned struct let person_queried = person .primary_key() .select_unique_expect(session) .await .unwrap() .entity; assert_eq!(person, person_queried); // Update the email column of person // Updating and deleting should always be executed on the borrowed version of the primary key // since you can only update/delete 1 row let pk = person.primary_key(); pk.update_email(session, &#34; [email protected]&#34;).await?; // Delete the row in the database pk.delete(session).await?; Ok(())}</p><p>///这是一个你可以对一个人做什么的例子</p><p>   When you now run the application, you will see in the logging that it inserted the person, selected it back, updated and deleted stuff in the database. A lot of code is generated, which I will guide you through.</p><p>当你现在运行应用程序时，你会在日志中看到它插入了这个人，重新选择了他，更新并删除了数据库中的内容。生成了很多代码，我将引导您完成这些代码。</p><p>  The file that is derived from the database metadata can be a little overwhelming. The diagram below provides a quick overview of what’s generated:</p><p>从数据库元数据派生的文件可能有点难以承受。下图简要概述了生成的内容：</p><p>  As shown in the diagram above, a few structs are generated for every table in the database. The arrows show which conversion methods are available:</p><p>如上图所示，为数据库中的每个表生成了一些结构。箭头显示了可用的转换方法：</p><p> If you want to insert a person, you would need a  PersonRef, and if you want to update a row, you would need a  PrimaryKeyRef.</p><p>如果要插入person，需要PersonRef，如果要更新行，则需要PrimaryKeyRef。</p><p> For examples on how to use this, see  this file. When you want to update dynamic columns, you should use the   UpdatableColumnRef enum.</p><p>有关如何使用此功能的示例，请参阅此文件。当您想要更新动态列时，应该使用UpdateableColumnRef枚举。</p><p>  Now that we have the structs generated with predefined queries, you might want to write your own query. That can be done with  macro crate.  This is the method you want to call and you can find  an example here. A big note:  only static queries are supported. This means you cannot build a query at runtime and check it at compile time!</p><p>现在我们已经使用预定义的查询生成了结构，您可能需要编写自己的查询。这可以通过宏板条箱实现。这就是你想要调用的方法，你可以在这里找到一个例子。值得注意的是：只支持静态查询。这意味着您不能在运行时构建查询，并在编译时检查它！</p><p> Let me show you how you can write a compile time checked query. First add another environment variable; this is needed so that the macro can find the modules in which the structs are defined:</p><p>让我向您展示如何编写编译时检查查询。首先添加另一个环境变量；这是必要的，以便宏可以找到定义结构的模块：</p><p>   fn query_persons_older_than( name: &amp;str, age: i32,) -&gt; Result&lt;SelectMultiple&lt;Person&gt;, SerializeValuesError&gt; { let result = catalytic_macro::query!(&#34;select * from person where name = ? and age &gt; ?&#34;, name, age); Ok(result)}</p><p>fn询问年龄大于(</p><p> The macro will replace the  select * by selecting all the columns. This is done on purpose, since  prepared statements can go out of sync when using  *. In this example above, the method returns a  SelectMultiple struct. The query macro can read what type of query you want. With the  SelectMultiple struct,  you can do the following:</p><p>宏将通过选择所有列来替换select*。这是有目的的，因为使用*时，准备好的语句可能会不同步。在上面的示例中，该方法返回SelectMultiple结构。查询宏可以读取所需的查询类型。使用SelectMultiple结构，可以执行以下操作：</p><p>  The code below shows how you can select everything in memory with the SelectMultiple type:</p><p>下面的代码显示了如何使用SelectMultiple type选择内存中的所有内容：</p><p> /// Demonstrates an easy way how to write a compile time checked queryasync fn compile_time_checked_query(session: &amp;CachingSession) { // Generate a person, it can be asserted later that the persons are equal to the queried persons let person = Person { name: &#34;jhon&#34;.to_string(), age: 20, email: &#34;nothing special&#34;.to_string(), json_example: &#34;not important&#34;.to_string(), }; // Remember, you can not insert an owned struct, borrowed values only person.to_ref().insert(session).await.unwrap(); let persons = query_persons_older_than(&amp;person.name, person.age - 1).unwrap(); // Since persons is of type SelectMultiple, functions are available to query multiple rows in the person table // Including paging, limiting and loading everything in memory // For now, just load everything into memory let persons = persons .select_all_in_memory(&amp;session, 10) .await .unwrap() .entities; assert_eq!(1, persons.len()); assert_eq!(person, persons[0]);}</p><p>///演示如何编写编译时检查查询的简单方法</p><p>  #[tokio::main]async fn main() { let session = create_session().await; crud_person(&amp;session).await.unwrap(); compile_time_checked_query(&amp;session).await; // This line is new}</p><p>#[tokio:：main]</p><p> The macro is quite smart in determining what type of query it is. It will reject queries that are already predefined with the table-to-struct mapper, so you never write a query that has already been generated.</p><p>宏在确定查询类型方面非常聪明。它将拒绝已经使用表到结构映射器预定义的查询，因此您永远不会编写已经生成的查询。</p><p>  We looked at how we can generate Rust structs from ScyllaDB/Cassandra tables. You do this with the  table to struct crate. This crate will make sure your Rust structs will always be in sync with the database.</p><p>我们研究了如何从Scyllab/Cassandra表生成Rust结构。你可以用桌子来搭建板条箱。这个板条箱将确保你的Rust structs始终与数据库同步。</p><p>  💡  You can add the generated files in your .gitignore file. It is generated and should always produce the same output.</p><p>💡  您可以在中添加生成的文件。gitignore文件。它是生成的，并且应该始终生成相同的输出。</p><p> For brevity, I won’t elaborate on the   Transformer trait but use it to:</p><p>为简洁起见，我将不详细介绍Transformer特性，但将其用于：</p><p>  Implementing the transformer trait isn’t hard; see the  example file to see how to do this.</p><p>实现变压器特性并不难；请参阅示例文件以了解如何执行此操作。</p><p> Using the  macro crate, you can create compile time checked queries. It returns a specific type with methods on it. So, if you write a query that counts the number of rows, it will return a   Count struct, on which you can call  ‘count’. This extra step ensures that  the query does exactly as you want.</p><p>使用宏板条箱，可以创建编译时检查的查询。它返回一个带有方法的特定类型。因此，如果您编写一个计算行数的查询，它将返回一个Count结构，您可以在其上调用“Count”。这个额外的步骤确保查询完全按照您的要求进行。</p><p> 💡  Create a workspace and create a separate library containing the generated entities and compile time checked queries. This way, the build.rs isn’t executed every time you change your source files. Add a  rerun if changed command to your cql file, then it will automatically run on schema change.</p><p>💡  创建一个工作空间，并创建一个单独的库，其中包含生成的实体和编译时检查的查询。这样的话，就可以进行构建了。不是每次更改源文件时都会执行rs。在cql文件中添加一个rerun if changed命令，然后它将在架构更改时自动运行。</p><p> Another very useful feature is the mapping between a materialized view and the base view. If you have a materialized view with exactly the same  columns as the base view (different primary keys are permitted), you can convert the materialized view to the base table in two ways:</p><p>另一个非常有用的特性是物化视图和基础视图之间的映射。如果物化视图的列与基础视图完全相同（允许使用不同的主键），则可以通过两种方式将物化视图转换为基础表：</p><p> There is a special   query_base_table macro in the macros crate. You can write your custom query which queries the materialized view. The returned type of the macro will be the type of the base table. The macro will do some checks to see if the conversion is safe at compile time. You can find an example  here. This shows that a query is done in a materialized view, but the return type is the struct of the base table.</p><p>宏板条箱中有一个特殊的查询基表宏。您可以编写自定义查询来查询物化视图。宏的返回类型将是基表的类型。宏将进行一些检查，以查看转换在编译时是否安全。你可以在这里找到一个例子。这表明查询是在物化视图中完成的，但返回类型是基表的结构。</p><p> The generated code will also perform a check to see whether an auto conversion can take place and  generates code if it’s safe to do so.</p><p>生成的代码还将执行检查，以查看是否可以进行自动转换，并在安全的情况下生成代码。</p><p>  Catalytic is capable of doing a lot of things, making it very easy and safe to interact with ScyllaDB. There are a few things that would be useful if implemented:</p><p>Catalystic能够做很多事情，使其与锡拉互动非常容易和安全。如果实施，有几件事会很有用：</p><p> Not all types are supported yet. While the basic types are supported, it lacks support for   UDT.</p><p>并非所有类型都受支持。虽然支持基本类型，但它缺乏对UDT的支持。</p><p> Checking queries at compile time is possible, as long as the queries are static. This means you can not conditionally add conditions to the query. I am not sure whether  it will ever be possible to lift this restriction.</p><p>只要查询是静态的，就可以在编译时检查查询。这意味着您不能有条件地向查询添加条件。我不确定是否有可能取消这一限制。</p><p>  Catalytic provides  examples for all the functionality, along with lots of tests. If you still have a question, just start a discussion at  https://github.com/Jasperav/catalytic/discussions or look at the example folders.</p><p>Catalystal提供了所有功能的示例，以及大量测试。如果你还有问题，就从https://github.com/Jasperav/catalytic/discussions或者看看示例文件夹。</p><p>  Rust is an awesome language and, in my opinion, the most convenient one. The ScyllaDB Rust driver is already one of the fastest ScyllaDB drivers,  if not  the fastest. It also provides a lot of safety. Combined with Catalytic, the Rust developer now has a really powerful toolset to build on  ScyllaDB, in probably the fastest way possible.</p><p>Rust是一种很棒的语言，在我看来，它是最方便的语言。“锡拉布锈迹”驱动程序即使不是最快的，也已经是最快的“锡拉布”驱动程序之一。它还提供了很多安全性。加上Catalystic，Rust developer现在有了一个非常强大的工具集，可以以可能最快的方式在Scyllab上构建。</p><p> ScyllaDB’s development is also skyrocketing. Scylla Summit 2022 was held February 9-10, with talks from companies using ScyllaDB in production. Piotr Sarna’s talk, “ ScyllaDB Rust Driver: One Driver to Rule Them All” was particularly interesting. You can watch his session and all of the talks  on-demand.</p><p>锡拉布的发展也在飞速发展。2022年锡拉峰会于2月9日至10日举行，使用锡拉的公司举行了会谈。Piotr Sarna的演讲“锡拉司机：一个司机统治他们所有人”特别有趣。你可以按需观看他的会议和所有演讲。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/orm/">#orm</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1072398.html"><img src="http://img2.diglog.com/img/2021/8/thumb_1ad263f1280bf5559b051c91da5e3a66.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072398.html">新设计的“智能”胰岛素可以改善 1 型糖尿病的治疗</a></div><span class="my_story_list_date">2021-8-10 4:31</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072359.html"><img src="http://img2.diglog.com/img/2021/8/thumb_1208d11d2f3bc36f48f64f103e1ab775.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072359.html">是时候抛弃设计网格了吗？</a></div><span class="my_story_list_date">2021-8-10 1:24</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072290.html"><img src="http://img2.diglog.com/img/2021/8/thumb_e29b049b4af66ff2364c0255a5d002ca.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072290.html">作为数据传输项目的一部分，Facebook 重新设计了其数据传输工具，允许用户将图像移动到 Photobucket 并将事件列表移动到 Google 日历</a></div><span class="my_story_list_date">2021-8-9 20:59</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072111.html"><img src="http://img2.diglog.com/img/2021/8/thumb_9c198ae4180f01f9f3651ce4f301a6c0.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072111.html">一种设计自组织人群系统的理论方法</a></div><span class="my_story_list_date">2021-8-8 21:49</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>