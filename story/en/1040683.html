<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>浏览器中的虚拟机检测 Virtual Machine Detection in the Browser</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Virtual Machine Detection in the Browser<br/>浏览器中的虚拟机检测 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-19 10:53:43</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/3e14d32c9ae580353a63430e3bd41aef.png"><img src="http://img2.diglog.com/img/2020/12/3e14d32c9ae580353a63430e3bd41aef.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Virtual Machine (VM) detection is nothing new. Malware has been doing it for over a decade now. Over time the techniques have advanced as defenders learned new ways of avoiding VM detection.</p><p>虚拟机（VM）检测并不是什么新鲜事物。恶意软件已经这样做了十多年了。随着时间的推移，随着防御者了解了避免VM检测的新方法，该技术也得到了发展。</p><p> A while back a friend and I were working on a project related to exploit delivery via a web application for redteaming purposes. I wanted a way to fingerprint visitors of the site and hash the fingerprint data so I could look for potential repeat visitors. While investigating fingerprinting I stumbled upon something pretty interesting. I was looking at some code that collected information about WebGL capabilities. I quickly realized that some of the fingerprinting information could be useful for VM detection because vendor names were exposed. In this particular instance the string &#34;VMWare&#34; was contained within the WebGL information. After some more testing I also discovered that VirtualBox reported the same kind of information.</p><p> 前一阵子，我和一个朋友正在从事一个与通过网络应用程序进行漏洞利用交付有关的项目，用于团队合作。我想要一种对网站的访问者进行指纹识别并对指纹数据进行哈希处理的方法，以便寻找潜在的重复访问者。在研究指纹时，我偶然发现了一些非常有趣的东西。我正在查看一些收集有关WebGL功能信息的代码。我很快意识到，由于公开了供应商的名称，因此某些指纹信息对于VM检测很有用。在此特定实例中，字符串＆＃34; VMWare＆＃34;包含在WebGL信息中。经过更多测试后，我还发现VirtualBox报告了相同的信息。</p><p> Once I realized it was potentially possible to detect VMs from the browser I started to dig deeper and began searching for other research related to this discovery. I found a pretty well researched academic paper  [1] related to tracking users across multiple browsers. This gave me some other potential techniques that could be applied to VM detection.</p><p> 一旦意识到有可能从浏览器中检测到VM，我便开始更深入地研究并开始寻找与此发现有关的其他研究。我找到了一篇研究得很好的学术论文[1]，该论文与跨多个浏览器跟踪用户有关。这给了我一些其他可以应用于虚拟机检测的潜在技术。</p><p> The end goal of this research is to have multiple techniques for VM detection. Multiple techniques lead to much more accurate detection. Since some techniques are more false-positive prone than others, a weighting system can be applied to the detection capabilities. This allows us to generate detection confidence scoring. This can help account for inaccuracies of certain detection methods. Given enough testing and data it would then be possible to come up with a reasonable threshold value. If a browser scores above the threshold then it would most likely be within a VM. Alternatively, if the browser scored below the threshold value it could be considered to be running on physical hardware.</p><p> 这项研究的最终目标是拥有多种用于VM检测的技术。多种技术可以使检测更加准确。由于某些技术比其他技术更容易出现假阳性，因此可以将加权系统应用于检测功能。这使我们能够生成检测置信度评分。这可以帮助解决某些检测方法的不准确性。如果有足够的测试和数据，那么就有可能提出一个合理的阈值。如果浏览器的得分高于阈值，则很可能在VM内。或者，如果浏览器得分低于阈值，则可以认为它在物理硬件上运行。</p><p>  Now that I have covered some of the background information and history leading up to this blog post we can start to dig into the actual techniques.</p><p>  既然我已经介绍了导致此博客文章的一些背景信息和历史，我们就可以开始研究实际的技术了。</p><p> As mentioned prior in the introduction, WebGL can provide a lot of information about the OpenGL implementation including vendor information. The WEBGL_debug_renderer_info extension  [2] can be used to query for debug information such as the WebGL vendor and rendered.</p><p> 如引言中前面提到的，WebGL可以提供有关OpenGL实现的许多信息，包括供应商信息。 WEBGL_debug_renderer_info扩展[2]可用于查询调试信息，例如WebGL供应商和呈现的信息。</p><p> var  canvas  =  document . createElement ( &#39;canvas&#39; ); var  gl  =  canvas . getContext ( &#39;webgl&#39; ); var  debugInfo  =  gl . getExtension ( &#39;WEBGL_debug_renderer_info&#39; ); var  vendor  =  gl . getParameter ( debugInfo . UNMASKED_VENDOR_WEBGL ); var  renderer  =  gl . getParameter ( debugInfo . UNMASKED_RENDERER_WEBGL ); console . log ( vendor ); console . log ( renderer );</p><p> var canvas = document。 createElement（＆＃39; canvas＆＃39;）; var gl = canvas。 getContext（＆＃39; webgl＆＃39;）; var debugInfo = gl。 getExtension（＆＃39; WEBGL_debug_renderer_info＆＃39;）; var vendor = gl。 getParameter（debugInfo。UNMASKED_VENDOR_WEBGL）; var renderer = gl。 getParameter（debugInfo。UNMASKED_RENDERER_WEBGL）;安慰 。日志（供应商）;安慰 。日志（renderer）; </p><p> Additionally, extension availability can be queried using the   getExtension method on a WebGL context. I have not fully explored this avenue but it might be possible to detect certain WebGL implementations provided by VMs based on the extensions available. Though this idea is likely very false-positive prone.</p><p>此外，可以在WebGL上下文中使用getExtension方法查询扩展可用性。我还没有完全探索这种途径，但是可能可以基于可用扩展来检测VM提供的某些WebGL实现。尽管这个想法很容易产生假阳性。</p><p>   Now, it is important to note that this depends on how the VM is configured. In Virtual Box for example, setting the graphics controller setting under Display to VMSVGA will report cause WebGL to use CPU based implementations of OpenGL which is browser dependent. However, this could still be a useful indicator that the client machine is running in a VM because most modern hardware has integrated GPUs and can provide access to OpenGL natively. Just keep in mind that CPU based OpenGL implementations do not necessarily mean it is a VM outright.</p><p>   现在，重要的是要注意，这取决于VM的配置方式。例如，在“虚拟盒子”中，将“显示”下的图形控制器设置设置为VMSVGA将报告导致WebGL使用基于CPU的OpenGL实现，该实现取决于浏览器。但是，由于大多数现代硬件都集成了GPU并可以提供对OpenGL的访问，因此这仍然可能是客户端计算机正在VM中运行的有用指示。请记住，基于CPU的OpenGL实现不一定意味着它完全是VM。</p><p>  This screenshot depicts Google Chrome utilizing the CPU based OpenGL implementation renderer Google SwiftShader  [4].</p><p>  此屏幕快照描绘了利用基于CPU的OpenGL实现渲染器Google SwiftShader [4]的Google Chrome。</p><p> Another technique seen in normal malware is to determine the screen width and height. This can be achieved in Javascript as well. Additionally, color depth and bits per pixel are other potentially good indicators related to the display.</p><p> 普通恶意软件中出现的另一种技术是确定屏幕的宽度和高度。这也可以用Javascript实现。此外，颜色深度和每像素位数是与显示相关的其他潜在的良好指示。</p><p>   Can we detect the amount of RAM on the client? You bet. Again using Javascript we can determine roughly the amount of RAM available on the browser. One quirk to note here is that the browser will only report RAM values in gigabytes (gb). It also has a quirk where it will only report up to 8gb and as low as 256mb (0.25gb). These ranges of values however, are still enough to use as a VM detection method. Most physical workstations these days come with at least 8gb of RAM. Detecting smaller amounts of RAM such as 2gb or less would be a good indicator the client browser is in a VM. The specification for the Device Memory can be found at  [6]</p><p>   我们可以检测到客户端上的RAM数量吗？你打赌再次使用Javascript，我们可以大致确定浏览器上可用的RAM数量。这里要注意的一个怪癖是浏览器将仅报告GB的RAM值。它也有一个怪癖，它只会报告高达8GB的内存，而低至256MB（0.25GB）。但是，这些值的范围仍然足以用作VM检测方法。如今，大多数物理工作站都配备了至少8gb的RAM。检测到较小量的RAM（例如2gb或更少）将是客户端浏览器在VM中的良好指示。设备存储器的规格可以在[6]中找到。</p><p>  Finally, the last technique I will be covering detects the number of CPU cores. This is done by performing timing attacks using multiple web workers running simultaneously. During my testing of this technique I found it to be very accurate. I tested this concept out using the  [7] Core Estimator Demo site. A small number of CPU cores can be a decent VM indicator and has been used by malware in the past. Core Estimator also provides the Javascript libraries on github  [8].</p><p>  最后，我将介绍的最后一项技术是检测CPU内核的数量。这是通过使用同时运行的多个Web Worker执行定时攻击来完成的。在测试这项技术的过程中，我发现它非常准确。我使用[7] Core Estimator Demo网站测试了这个概念。少数CPU内核可以作为不错的VM指示器，并且过去已被恶意软件使用。 Core Estimator还在github [8]上提供了Javascript库。</p><p>   This blog post covered four unique VM detection capabilities that can be performed from Javascript. When I first discovered these techniques my initial thought was to apply the concepts toward VM detection. Hopefully, both defenders and offensive security professions can find something useful to apply these techniques toward.</p><p>   这篇博客文章介绍了可以通过Javascript执行的四种独特的VM检测功能。当我第一次发现这些技术时，我最初的想法是将这些概念应用于VM检测。希望防御者和进攻安全专业人士都能找到有用的东西，以将这些技术应用于其中。 </p><p> It is interesting to see that academics and various other researchers have applied some of the same concepts toward fingerprinting and privacy issues.</p><p>有趣的是，学者和其他各种研究人员已将某些相同的概念应用于指纹识别和隐私问题。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bannedit.github.io/Virtual-Machine-Detection-In-The-Browser.html">https://bannedit.github.io/Virtual-Machine-Detection-In-The-Browser.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/虚拟机/">#虚拟机</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/浏览器/">#浏览器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/machine/">#machine</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/vm/">#vm</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>