<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Pijul –用Rust编写的数学声音版本控制系统Pijul – The Mathematically Sound Version Control System Written in Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Pijul – The Mathematically Sound Version Control System Written in Rust<br/>Pijul –用Rust编写的数学声音版本控制系统</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-30 01:48:38</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/cc65bab3a09a6e75d302859396040e9b.png"><img src="http://img2.diglog.com/img/2020/11/cc65bab3a09a6e75d302859396040e9b.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In our  Evolution of Version Control System Internals post, we covered the inner workings of many version control systems, both historical and current. However, we haven&#39;t really covered  the possible future of version control. How will this field evolve going forward?</p><p>在“版本控制系统内部的演变”一文中，我们介绍了许多版本控制系统的内部工作原理，包括历史版本和最新版本。但是，我们还没有真正涵盖版本控制的未来。这个领域将如何发展？</p><p> Although Git is dominant now and will certainly remain a strong player for years to come, will better tools be created? Pijul could be a strong contender.</p><p> 尽管Git现在占据主导地位，并且肯定会在未来几年保持强势，但会不会创造出更好的工具？皮约尔可能是一个有力的竞争者。</p><p> In this article, we&#39;ll discuss Pijul - an alpha stage version control system that is gaining attention in the community.</p><p> 在本文中，我们将讨论Pijul-一种受到社区关注的Alpha阶段版本控制系统。</p><p>  Pijul is a VCS written by Pierre-Étienne Meunier and Florent Becker. After releasing a number of experimental prototypes between 2015 and 2020, the first alpha version was released in November 2020. By operating on diffs  and on versions at the same time, Pijul combines aspects of third-generation VCS such as  Git and  Darcs.</p><p>  Pijul是由Pierre-ÉtienneMeunier和Florent Becker编写的VCS。在2015年至2020年间发布了许多实验原型之后，第一个Alpha版本于2020年11月发布。Pijul通过同时在差异版本和版本上进行操作，结合了第三代VCS的各个方面，例如Git和Darcs。</p><p> Pijul is written in  Rust and is currently in alpha stage development. The algorithms and formats underlying Pijul&#39;s design were recently overhauled for performance and robustness of the system, and the team is working on making it as stable as possible after these updates.</p><p> Pijul用Rust编写，目前处于alpha阶段开发中。为了改善系统的性能和健壮性，最近对Pijul设计的算法和格式进行了全面检查，并且团队正在努力在这些更新之后使它尽可能稳定。</p><p> Pijul&#39;s architecture and design methodology was influenced by the  Darcs project, which we  covered in detail here.</p><p> Pijul的架构和设计方法受到Darcs项目的影响，我们在这里详细介绍了该项目。</p><p> One distinctive feature of Pijul (shared with Darcs) is  change commutation, whereby changes that could be recorded independently can be applied in any order, without affecting the result.</p><p> Pijul（与Darcs共享）的一个显着特征是变更换向，从而可以以任何顺序应用可以独立记录的变更，而不会影响结果。</p><p> However, unlike Darcs, which operates on changes only, Pijul applies changes to an abstract data structure representing generalized files, allowing it to maintain a notion of version as well as a notion of change between versions. This has a number of advantages, in particular in terms of performance and in terms of mathematical soundness.</p><p>但是，与仅对更改进行操作的Darcs不同，Pijul将更改应用于代表通用文件的抽象数据结构，从而使其能够维护版本概念以及版本之间的更改概念。这具有许多优点，特别是在性能和​​数学稳健性方面。</p><p> The source code for Pijul can be found at  https://nest.pijul.com/pijul/pijul. The  Pijul Nest is a remote hosting platform for Pijul repositories. Think of it as Pijul&#39;s version of GitHub or BitBucket.</p><p> 可以在https://nest.pijul.com/pijul/pijul中找到Pijul的源代码。 Pijul Nest是用于Pijul存储库的远程托管平台。可以将其视为Pijul的GitHub或BitBucket版本。</p><p>  We already have  Git, the most popular and functional VCS on Earth. Git handles all of the features we could expect from a solid VCS (in fact it sets the benchmark for these features), including:</p><p>  我们已经有了Git，这是地球上最流行，功能最强大的VCS。 Git处理了我们可以从可靠的VCS获得的所有功能（实际上，它为这些功能设定了基准），包括：</p><p> A long list of tools for conveniently managing repositories depending on desired workflow and personal style</p><p> 众多工具可根据所需的工作流程和个人风格方便地管理存储库</p><p>  In Darcs, a repository can be better thought of as a &#34;set of patches&#34; - applied as needed - as opposed to a linear history of dependent changesets.</p><p>  在Darcs中，可以更好地将存储库视为“补丁集”（根据需要应用），而不是依赖变更集的线性历史记录。</p><p> The Darcs model preserves the  identity of patches during operations like rebasing and cherry-picking, whereas Git sometimes needs to rewrite history due to chained identifiers that depend on the order of application. Preserving a change&#39;s ID can be considered a more natural approach.</p><p> Darcs模型在诸如重新定级和挑选樱桃之类的操作期间保留补丁程序的身份，而Git有时需要重写历史记录，因为链接标识符取决于应用程序的顺序。保留更改的ID可以认为是一种更自然的方法。</p><p> Darcs has a very well designed interface and command set that provides verbose output to help speed up the learning curve for users and clarify what actions the users are taking.</p><p> Darcs具有精心设计的界面和命令集，可提供详细的输出，以帮助加快用户的学习速度并阐明用户正在采取的措施。</p><p> Patch bundles can be easily transmitted via email to be applied by the remote repository owner.</p><p>补丁包可以很容易地通过电子邮件传输，由远程存储库所有者应用。</p><p> So since we have Git and Darcs, why do we need Pijul? Pijul was created to solve unrelated problems that exist in Git and Darcs.</p><p> 那么既然我们拥有Git和Darcs，为什么我们需要Pijul？ Pijul的创建是为了解决Git和Darcs中存在的不相关问题。</p><p> Pijul uses a patch-centric model similar to Darcs, which doesn&#39;t require history to be re-written when reordering, cherry-picking, or otherwise reorganizing patches. All patches retain their identities permanently regardless of their context, order, operations performed, or team workflow. This is a very elegant solution and arguably a more natural way to create such a system. This is in contrast to Git in which certain operations such as rebases and cherry-picks can change commit ID&#39;s (and other identifiers), even if the content itself doesn&#39;t change.</p><p> Pijul使用类似于Darcs的以补丁程序为中心的模型，该模型在重新排序，挑选或重组补丁程序时不需要重写历史记录。所有补丁程序都将永久保留其身份，无论其上下文，顺序，执行的操作或团队工作流程如何。这是一个非常优雅的解决方案，并且可以说是一种更自然的创建此类系统的方法。这与Git相反，在Git中，某些操作（例如重新设置基数和Cherry-Picks）可以更改提交ID（和其他标识符），即使内容本身没有更改。</p><p> Furthermore, subsequent cherry-picks from a remote branch in Git can lead to unnatural conflicts due to the rewriting of the initial cherry-picked commit&#39;s ID. Pijul avoids this problem completely as patches always retain their identity, regardless of their location in a branch.</p><p> 此外，由于重写了最初的樱桃采摘的提交ID，因此来自Git远程分支的后续樱桃采摘可能导致不自然的冲突。 Pijul完全避免了此问题，因为补丁程序始终保留其身份，无论它们在分支中的位置如何。</p><p> So what about Darcs? In certain scenarios, Darcs runs into performance issues such as the  exponential merge problem. This issue causes certain merges to increase exponentially in difficulty, effectively preventing these merges from being performed. Pijul has solved this problem.</p><p> 那么Darcs呢？在某些情况下，Darcs会遇到性能问题，例如指数合并问题。此问题导致某些合并的难度成倍增加，从而有效地阻止了这些合并的执行。皮约尔解决了这个问题。</p><p> As is summed up nicely in  Pierre Meunier&#39;s recent post  Toward&#39;s 1.0: &#34;Our goals are to find the smallest possible system, both for reasons of mathematical aesthetics (why store useless stuff?) and the other one for performance.&#34;</p><p> 正如Pierre Meunier在最近发表的Toward 1.0中所总结的那样：“我们的目标是要找到最小的系统，这是出于数学美学的原因（为什么要存储无用的东西？），而另一个则是出于性能考虑。”</p><p> Pijul&#39;s main purpose is to be an efficient VCS based on a sound mathematical theory, guaranteeing that basic properties of changes are always maintained. This consistency bolsters peace of mind in the software development process. With Pijul, developers can be 100% confident that the code they reviewed is the code that gets merged, which is not necessarily the case in Git and Mercurial. Even though file reshuffles do not seem to happen very often in these existing VCS, (and some of them are caught by tests), there are a few statistical studies highlighting their occurrence, and the security implications are huge.</p><p> Pijul的主要目的是基于可靠的数学理论，成为高效的VCS，以确保始终保持变更的基本属性。这种一致性增强了软件开发过程中的安全性。使用Pijul，开发人员可以100％确信他们查看的代码是要合并的代码，而Git和Mercurial不一定是这种情况。尽管在这些现有的VCS中似乎很少发生文件改组（并且其中一些被测试捕获），但仍有一些统计研究突出显示了它们的发生，并且对安全性的影响很大。</p><p> One particular goal of Pijul is to model conflicts as normal states of collaboration, so that conflicts are resolved by normal changes, valid even for the same conflicts in any other context.</p><p>Pijul的一个特定目标是将冲突建模为正常的协作状态，以便通过正常的更改来解决冲突，即使在任何其他上下文中的相同冲突下也是如此。</p><p>  A Pijul repository has a  pristine directory, containing a number of  channels. At any given time, a channel contains a set of unordered  changes, which can also be seen as a version, since the order of independent changes does not matter in Pijul.</p><p>  Pijul存储库具有一个原始目录，其中包含多个通道。在任何给定时间，通道都包含一组无序更改，也可以将其视为版本，因为独立更改的顺序在Pijul中无关紧要。</p><p> The &#34;working copy&#34; is simply the set of files directly editable by the user, and the correspondence between the working copy and the pristine is done by a  file tracking tree, which is just a mapping between working copy files and files as stored in the pristine.</p><p> “工作副本”只是用户直接可编辑的文件集，而工作副本与原始文件之间的对应关系是由文件跟踪树完成的，这只是工作副本文件与存储在文件中的文件之间的映射。原始的。</p><p> Moreover, changes  can (but don&#39;t need to) depend on each other, and do so explicitly (see the section about the &#34;sample change&#34; below), in the sense that each change is uniquely identified by its cryptographic hash, and dependencies are explicit hashes of other changes. The  minimal dependencies are enforced by Pijul to make sure that text edits make sense. For example, a change editing a file or a paragraph depends on the change that introduced that file or paragraph. This is because it doesn&#39;t make sense to change a piece of content that was never added in the first place, so the patch that added the content must be present for the patch that changed it to have meaning. Additionally, the user may specify extra, language-specific dependencies to model the edits more accurately, for example the dependency between introducing a function and using it in another file or another part of the same file. This is an extremely powerful feature.</p><p> 而且，更改可以（但不必）相互依赖，并且可以明确地做到这一点（请参阅下面的“样本更改”部分），因为每个更改都是通过其密码哈希和相关性来唯一标识的。是其他更改的显式哈希。最小依赖性由Pijul强制执行，以确保文本编辑有意义。例如，编辑文件或段落的更改取决于引入该文件或段落的更改。这是因为更改一开始从未添加的内容没有任何意义，因此添加内容的补丁必须存在，才能使该补丁具有意义。另外，用户可以指定额外的，特定于语言的依存关系以更准确地对编辑进行建模，例如，引入功能与在另一个文件或同一文件的另一部分中使用它之间的依存关系。这是一个非常强大的功能。</p><p> If desired, this scheme of dependencies between changes allows Pijul to mimic the strict sequential ordering of commits used by Git and Mercurial, turning Pijul into a sort of &#34;Git, but with mathematically sound merges&#34;. The downside of using Pijul like this is that changes relative to independent features of the project might need to be more carefully split between different channels, like Git branches. The &#34;plain&#34;, or &#34;standard&#34; Pijul way is to try and record changes that are as independent as possible, and keep them on the same channel, since independent changes can always be split later on without changing their identity (i.e. their hash). Channels are useful for different &#34;flavors&#34; of the project, and one can push the same changes to multiple channels without modifying these changes.</p><p> 如果需要，这种更改之间的依存关系方案允许Pijul模仿Git和Mercurial使用的提交的严格顺序，从而将Pijul变成一种“ Git，但具有数学上合理的合并”。像这样使用Pijul的缺点是，相对于项目独立功能的更改可能需要在Git分支等不同渠道之间更仔细地划分。 “普通”或“标准” Pijul方法是尝试记录尽可能独立的更改，并将它们保持在同一通道上，因为独立更改可以始终在以后拆分，而无需更改其标识（即哈希） 。通道可用于项目的不同“风格”，并且可以将相同的更改推送到多个通道而无需修改这些更改。</p><p>  We wanted to get inside the head of Pierre-Étienne Meunier, the creator and lead developer of Pijul, so we  asked him a series of questions related to his background and the creation of Pijul, and the direction of the version control field. His answers were  extremely interesting and worth a read (we split them into a separate post since they were fairly lengthy).</p><p>  我们想成为Pijul的创建者和首席开发人员Pierre-ÉtienneMeunier的负责人，所以我们问了他一系列有关他的背景和Pijul的创建以及版本控制领域方向的问题。他的回答非常有趣，值得一读（由于篇幅冗长，我们将其分成单独的帖子）。</p><p>  One of Pijul&#39;s goals is to minimize the number of commands, so as to allow users to get a full understanding of the system as quickly as possible.</p><p>  Pijul的目标之一是最大程度地减少命令数量，以使用户能够尽快全面了解系统。</p><p>    Here, the meaningful things that get created are  db0, which contains the pristine, in binary format, and a sample  config file, editable in  TOML format.</p><p>在这里，创建的有意义的东西是db0，它包含原始格式（二进制格式）和一个示例配置文件，该文件可以TOML格式进行编辑。</p><p> pijul add &lt;filename.ext&gt;: Adds a file to the repository&#39;s tracking list.  pijul remove &lt;filename.ext&gt;: Remove a file from the tracking list.  pijul mv &lt;filename1.ext&gt; &lt;filename2.ext&gt;: Move and/or rename a file in the tracking list.  pijul ls: Displays a list of currently tracked files. pijul record (or  pijul rec): Creates a change and applies it to the pristine. Once we do that, the  .pijul/changes gets populated with one change:</p><p> pijul add ：将文件添加到存储库的跟踪列表。 pijul remove ：从跟踪列表中删除文件。 pijul mv  ：在跟踪列表中移动和/或重命名文件。 pijul ls：显示当前跟踪文件的列表。 pijul记录（或pijul rec）：创建更改并将其应用于原始记录。完成后，.pijul / changes将填充一个更改：</p><p>  pijul unrecord &lt;hash&gt;: If no change depends on a change  hash, we can also &#34;undo&#34; or &#34;unapply&#34; it using the  unrecord command. For example, here our change&#39;s hash is  ZNPGE4DJNVY4JAQABNSQ..., and we can use any unambiguous prefix of that hash, for example  pijul unrecord ZNPG, or even  pijul unrecord Z to undo it.  pijul reset: Resets the repository to the state of a channel. Without any argument, the current channel is used, and  pijul reset --channel can be used to change the current channel.  pijul fork: Creates an independent channel with the same changes as the current channel.  pijul channel: Lists all the channels.  pijul channel delete &lt;channel&gt;: Deletes an existing channel.  pijul channel rename &lt;channel1&gt; &lt;channel2&gt;: Renames an existing channel.  pijul push: Sends changes to a remote repository. For example, contributing to Pijul can be done with  pijul push pmeunier@nest.pijul.com:pijul/pijul.  pijul pull: Gets changes from a remote repository.</p><p>  pijul unrecord ：如果没有更改取决于更改哈希，我们还可以使用unrecord命令“撤消”或“取消应用”它。例如，此处更改的哈希为ZNPGE4DJNVY4JAQABNSQ ...，我们可以使用该哈希的任何明确前缀，例如pijul未记录ZNPG甚至pijul未记录Z来撤消它。 pijul reset：将存储库重置为通道状态。不带任何参数的情况下，将使用当前通道，而pijul reset --channel可用于更改当前通道。 pijul fork：创建一个独立通道，其更改与当前通道相同。 pijul channel：列出所有通道。 pijul channel delete ：删除现有通道。 pijul channel重命名 ：重命名现有通道。 pijul push：将更改发送到远程存储库。例如，可以通过pijul push pmeunier@nest.pijul.com：pijul / pijul为Pijul捐款。 pijul pull：从远程存储库获取更改。</p><p>  The following content represents the change one gets when adding a single file with three lines to the repository. Once recorded and converted to a binary format for performance reasons (because the change files are read by Pijul quite often), its hash is  LXCA3JPGWBSHNWTJLAWL....</p><p>  以下内容表示将三行的单个文件添加到存储库时获得的更改。一旦出于性能原因将其记录并转换为二进制格式（因为Pijul经常读取更改文件），则其哈希为LXCA3JPGWBSHNWTJLAWL...。</p><p> message = &#39;Adding a file&#39;timestamp = &#39;2020-11-20T16:46:51.098461926Z&#39;[[authors]]name = &#39;pmeunier&#39;full_name = &#39;Pierre-Étienne Meunier&#39;# Changes1. File addition: &#34;file&#34; in &#34;/&#34; 644 up 1.0, new 0:6+ First line+ Second line+ Third line</p><p> message ='添加文件'timestamp ='2020-11-20T16：46：51.098461926Z'[[authors]] name ='pmeunier'full_name ='Pierre-ÉtienneMeunier'＃更改1。文件添加：“ /” 644 up 1.0中的“文件”，新增0：6+第一行+第二行+第三行</p><p> If we add a line &#34;Another line&#34; between the second and third line, we get the following change:</p><p> 如果我们在第二行和第三行之间添加一行“另一行”，则会得到以下更改：</p><p> message = &#39;Adding another line&#39;timestamp = &#39;2020-11-20T16:47:58.634094619Z&#39;[[authors]]name = &#39;pmeunier&#39;full_name = &#39;Pierre-Étienne Meunier&#39;# Dependencies[2] LXCA3JPGWBSHNWTJLAWLANNSBDQUM4XA3ZLSGKVW6OETSFNYI4QAC# Changes1. Edit in file:2 2.7 up 2.31, new 0:13, down 2.31+ Another line</p><p> 消息='添加另一行'时间戳='2020-11-20T16：47：58.634094619Z'[[作者]] name ='pmeunier'full_name ='Pierre-ÉtienneMeunier'＃依赖项[2] LXCA3JPGWBSHNWTJLAWLANNSBDQUM4XA3ZLSGKVW6OETSFNY1Q4。在文件中编辑：2 2.7向上2.31，新0:13，向下2.31+另一行</p><p> Note the presence of the original change as a dependency, identified by the hash  LXCA3JPGWBSHNWTJLAWL....</p><p>请注意，原始更改作为依赖项存在，由哈希LXCA3JPGWBSHNWTJLAWL ...标识。</p><p>  In summary, Pijul is a promising project that is approaching version control in elegant fashion. It strives for many of the objectives that are lacking in current tools like Git and Darcs. It solves complex problems with mathematical rigor and performance in mind. Software development always makes room for new and better solutions to existing problems. Keep an eye on Pijul because it might just lead the push into the next generation of VCS tools.</p><p>  总之，Pijul是一个很有前途的项目，正在以优雅的方式实现版本控制。它致力于实现当前工具（如Git和Darcs）所缺少的许多目标。考虑到数学的严格性和性能，它可以解决复杂的问题。软件开发总是为解决现有问题提供新的更好的解决方案的空间。请留意Pijul，因为它可能会直接推动下一代VCS工具的发展。</p><p> If you&#39;re interested in learning more about how version control systems work under the hood, check out our  Baby Git Guidebook for Developers, which dives into Git&#39;s code in an accessible way. We wrote it for curious developers to learn how version control systems work  at the code level. To do this we documented the first version of Git&#39;s code and discuss it in detail.</p><p> 如果您想了解有关版本控制系统如何在幕后工作的更多信息，请查阅我们的《 Baby Git开发人员指南》，该指南以一种易于访问的方式深入了Git的代码。我们为好奇的开发人员编写了它，以了解版本控制系统如何在代码级别工作。为此，我们记录了Git代码的第一个版本并进行了详细讨论。</p><p> We hope you enjoyed this post! Feel free to shoot me an email at  jacob@initialcommit.io with any questions or comments.</p><p> 希望您喜欢这篇文章！如有任何问题或意见，请随时给我发送电子邮件至jacob@initialcommit.io。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pijul/">#pijul</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>