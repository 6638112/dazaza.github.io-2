<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Go发现和探索mmap Discovering and exploring mmap using Go</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Discovering and exploring mmap using Go<br/>使用Go发现和探索mmap </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-11 11:22:51</div><div class="page_narrow text-break page_content"><p>Recently I&#39;ve come to know the concept of  memory-mapped files while watching a lecture of the course  Intro to Database Systems of  Andy Pavlo on database storage. One of the main problems a database storage engine has to solve is  how to deal with data in disk that is bigger than the available memory. At a higher level, the main purpose of a disk-oriented storage engine is to manipulate data files in a disk. But if we assume that the data in the disk will eventually get bigger than the available memory, we cannot simply load the whole data file into memory, do the change, and write it back to disk.</p><p>最近，我在观看有关数据库存储的Andy Pavlo数据库系统入门课程的演讲时，了解了内存映射文件的概念。数据库存储引擎必须解决的主要问题之一是如何处理磁盘中大于可用内存的数据。更高层次上，面向磁盘的存储引擎的主要目的是操纵磁盘中的数据文件。但是，如果我们假设磁盘中的数据最终将变得大于可用内存，则我们不能简单地将整个数据文件加载到内存中，进行更改并将其写回到磁盘中。</p><p> This is not a new problem in Computer Science. When operational systems were being developed in the early 1960s, a similar problem was faced:  how can we run programs stored in disk that are larger than the available memory? A solution to this problem was made by a group in Manchester, implemented on the  Atlas Computer, in 1961. It was called  virtual memory. The  virtual memory gives a running program the illusion that it has big enough memory, despite the fact that the computer does not have enough.</p><p> 这不是计算机科学中的新问题。在1960年代初期开发操作系统时，面临着一个类似的问题：我们如何运行存储在磁盘中的大于可用内存的程序？ 1961年，曼彻斯特的一个小组提出了一个解决方案，该方案在Atlas计算机上实现。它被称为虚拟内存。尽管计算机没有足够的内存，但虚拟内存给运行中的程序一个幻觉，即它具有足够的内存。</p><p> We are not going to go deep on how  virtual memory works. Just have in mind that when a program is accessing memory it is accessing the  virtual memory. And maybe the data the program is trying to access is not actually in memory, but it does not matter. The operational system will make pretend that it is by going to disk, and putting it there, and replace an old chunk of memory that is not going to be used.</p><p> 我们不会深入探讨虚拟内存的工作方式。请记住，程序正在访问内存时，它正在访问虚拟内存。也许程序正在尝试访问的数据实际上不在内存中，但这无关紧要。操作系统将假装它是通过将其放入磁盘并将其放置在其中，然后替换将不使用的旧内存块来实现的。</p><p> So, one of the ways a database storage engine can solve the larger than memory problem is to make use of  virtual memory and the concept of  memory-mapped files.</p><p> 因此，数据库存储引擎解决大于内存的问题的一种方法是利用虚拟内存和内存映射文件的概念。</p><p> In Linux, we can make this use by using the system call  mmap that lets you map a file, no matter how big, directly into memory. If your program needs to manipulate the file, all it needs is to manipulate the memory. The operating system handles the writes to disk for you.</p><p> 在Linux中，我们可以通过使用系统调用mmap来实现此目的，该函数使您可以将文件（无论大小）直接映射到内存。如果您的程序需要处理文件，则只需处理内存即可。操作系统为您处理磁盘写操作。</p><p> In some occasions, programmers find this method more convenient than the usual system calls:  open,  read,  write,  lseek and  close.</p><p> 在某些情况下，程序员发现此方法比通常的系统调用更方便：打开，读取，写入，查找和关闭。</p><p>  Here is a small example of how you can take advantage of this in Go using the package  mmap-go:</p><p>  这是一个小示例，说明如何使用mmap-go软件包在Go中利用此功能： </p><p> package mainimport ( &#34;os&#34; &#34;fmt&#34; &#34;github.com/edsrzf/mmap-go&#34;)func main() { f, _ := os.OpenFile(&#34;./file&#34;, os.O_RDWR, 0644) defer f.Close() mmap, _ := mmap.Map(f, mmap.RDWR, 0 ) defer mmap.Unmap() fmt.Println(string(mmap)) mmap[0] = &#39;X&#39; mmap.Flush()}</p><p>包mainimport（＆＃34; os＆＃34;＆＃34; fmt＆＃34;＆＃34; github.com/edsrzf/mmap-go&#34;）func main（）{f，_：= os.OpenFile（ ＆＃34; ./ file＆＃34 ;, os.O_RDWR，0644）延迟f.Close（）mmap，_：= mmap.Map（f，mmap.RDWR，0）延迟mmap.Unmap（）fmt.Println（ string（mmap））mmap [0] =＆＃39; X＆＃39; mmap.Flush（）}</p><p>  The beauty is that we could have a much bigger file, and the solution would still work. We would not have to worry about managing memory in order to avoid it filling up.</p><p>  令人高兴的是，我们可以拥有更大的文件，并且该解决方案仍然有效。我们不必担心管理内存以避免它被填满。</p><p>  We&#39;re going to explore more  mmap functionalities from the point of view of the API provided by  mmap-go. There are probably more features that the  native syscall provides that this library does not implement.</p><p>  我们将从mmap-go提供的API的角度探索更多的mmap功能。本机syscall可能提供了该库未实现的更多功能。</p><p>    Let&#39;s look at  prot first. The  prot argument lets you specify the protection levels of your mapping:  RDONLY,  RDWR,  EXEC are the options provided for  mmap-go. These levels are pretty straightforward,  RDONLY means you can only read from the mapping,  RDWR means you can also write, and  EXEC means you can execute code on that mapping. Here is the description of  prot from the Linux  man:</p><p>    让我们先看一下prot。使用prot参数可以指定映射的保护级别：RDONLY，RDWR，EXEC是为mmap-go提供的选项。这些级别非常简单，RDONLY表示您只能从映射中读取，RDWR表示您也可以编写，EXEC表示您可以在该映射上执行代码。这是Linux专家对prot的描述：</p><p> The prot argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file). It is either PROT_NONE or the bitwise OR of one or more of the following flags:PROT_EXEC Pages may be executed.PROT_READ Pages may be read.PROT_WRITE Pages may be written.PROT_NONE Pages may not be accessed.</p><p> prot参数描述了所需的映射内存保护（并且不得与文件的打开模式冲突）。它可以是PROT_NONE或以下一个或多个标志的按位或：可以执行PROT_EXEC页面。可以读取PROT_READ页面。可以写入PROT_WRITE页面。不能访问PROT_NONE页面。</p><p>   I&#39;ve become intrigued by the  EXEC flag and wanted to see an example of how that works. I&#39;ve Google and could not find any example. So I tried a search in Github by  PROT_EXEC and found a good example in  C:  MMapExecDemo. I replicated this example in  Go using  mmap-go.</p><p>   我对EXEC标志很感兴趣，并想看一个例子。我曾经用过Google，找不到任何示例。因此，我尝试通过PROT_EXEC在Github中进行搜索，并在C：MMapExecDemo中找到了一个很好的示例。我使用mmap-go在Go中复制了此示例。</p><p> The first step was to create a function that I wanted to be put in memory by  mmap allocation, compile it, and get its assembly opcodes.</p><p> 第一步是创建一个我想通过mmap分配放入内存的函数，对其进行编译并获取其汇编操作码。 </p><p>   compiled it with  go tool compile -S -N inc.go, then got its assembly by calling  go tool objdump -S inc.o.</p><p>使用go工具compile -S -N inc.go对其进行编译，然后通过调用go工具objdump -S inc.o对其进行汇编。</p><p> func inc(n int) int { 0x22b 48c744241000000000 MOVQ $0x0, 0x10(SP) return n + 1 0x234 488b442408 MOVQ 0x8(SP), AX 0x239 48ffc0 INCQ AX 0x23c 4889442410 MOVQ AX, 0x10(SP) 0x241 c3 RET</p><p> func inc（n int）int {0x22b 48c744241000000000 MOVQ $ 0x0，0x10（SP）返回n + 1 0x234 488b442408 MOVQ 0x8（SP），AX 0x239 48ffc0 INCQ AX 0x23c 4889442410 MOVQ AX，0x10（SP）0x241 c3 RET</p><p>  code := []byte{ 0x48, 0xc7, 0x44, 0x24, 0x10, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x44, 0x24, 0x08, 0x48, 0xff, 0xc0, 0x48, 0x89, 0x44, 0x24, 0x10, 0xc3,}</p><p>  代码：= [] byte {0x48、0xc7、0x44、0x24、0x10、0x00、0x00、0x00、0x00、0x48、0x8b，0x44、0x24、0x08、0x48、0xff，0xc0、0x48、0x89、0x44、0x24、0x24、0x10 ，0xc3，}</p><p>   In this call, we&#39;re using a more complete function called  MapRegion that lets you specify how much memory you are allocating ( Map allocates the size of the underlying file) and the offset of the file.</p><p>   在此调用中，我们使用的是称为MapRegion的更完整的函数，该函数可让您指定要分配的内存量（Map分配基础文件的大小）和文件的偏移量。</p><p> In the beginning, we said that the main purpose of  mmap was to create a mapping between a file and memory. But in this call we are not indicating any file.  mmap can be used just a regular memory allocater by setting  nil to the  *os.File argument and  mmap.ANON to the  flags argument. We will talk about more  mmap.ANON. Since we are not mapping any file, the offset is  0.</p><p> 首先，我们说过mmap的主要目的是在文件和内存之间创建映射。但是在此调用中，我们不指示任何文件。通过将nil设置为* os.File参数并将mmap.ANON设置为flags参数，可以将mmap用作常规内存分配器。我们将讨论更多的mmap.ANON。由于我们没有映射任何文件，因此偏移量为0。</p><p> So we have memory allocated with the same size of our code  len(code). Since we set the flag  mmap.RDWR, we can copy our  code to  memory.</p><p> 因此，我们分配的内存大小与代码len（code）相同。由于设置了标志mmap.RDWR，因此可以将代码复制到内存中。</p><p>  We have the code of our  inc function in memory. In order to execute it, we have to cast that memory address to a function with a signature that matches the signature of our compiled  inc.</p><p>  我们在内存中有inc函数的代码。为了执行它，我们必须将该内存地址强制转换为签名与我们已编译的inc签名匹配的函数。 </p><p>  When we call  inc, we are executing the code we put in memory. That only works because of the flag  mmap.EXEC. If that flag was not set, a  segmentation violation would occur.</p><p>当我们调用inc时，我们正在执行存储在内存中的代码。由于标志mmap.EXEC，这只能工作。如果未设置该标志，则会发生分段冲突。</p><p>  I don&#39;t know if this is a real use case. I just wanted to see what it meant to execute code that you put in memory. And there are probably other ways of achieving the same with regular memory allocation and calls to  mprotect.</p><p>  我不知道这是否是真正的用例。我只是想了解执行存储在内存中的代码的含义。并且可能还有其他方法可以通过常规的内存分配和对mprotect的调用来实现这一点。</p><p> One question that may come up is: but the code is already in the  code variable, can&#39;t we just execute it? No, because the memory static allocated to  code is not executable. Can we make it executable? I&#39;ve tried to use  mprotect on it but still got  segmentation violation.</p><p> 可能出现的一个问题是：但是代码已经在代码变量中了，我们不能执行它吗？否，因为分配给代码的静态内存是不可执行的。我们可以使其可执行吗？我曾尝试在其上使用mprotect，但仍然遇到分段违规问题。</p><p>   We can have many processes mapping the same memory region. This argument lets us decide about the visibility of the updates happening in the mapping. There are many flags, and you can check them out at  mmap. The important ones are  unix.MAP_SHARED,  unix.MAP_PRIVATE and  unix.MAP_ANON.</p><p>   我们可以有许多进程映射相同的内存区域。此参数使我们可以决定映射中发生的更新的可见性。标志很多，您可以在mmap上检出它们。重要的是unix.MAP_SHARED，unix.MAP_PRIVATE和unix.MAP_ANON。</p><p> MAP_SHARED means that changes to the mapping are visible to all processes and will also occur at the underlying mapped file, although we cannot control when.</p><p> MAP_SHARED意味着对映射的更改对于所有进程都是可见的，并且也会在基础映射文件上发生，尽管我们无法控制何时进行。</p><p> MAP_PRIVATE means the changes are private and other processes will not see them. And also, they are not carried through to the underlying file.</p><p> MAP_PRIVATE表示更改是私有的，其他进程将看不到它们。而且，它们不会传递到基础文件。</p><p> MAP_ANON means that there is not going to be a mapped file. It is useful for sub-processes communication with shared memory.</p><p> MAP_ANON表示将不会有映射文件。对于与共享内存的子流程通信很有用。 </p><p> I&#39;ve got confused about the  mmap-go library implementation. It only provides the  mmap.ANON flag, that we used in the above example. If you want your mapping to be private, you can set the  mmap.COPY flag to the  prot argument. Anyways, you can always use the flags provided by the  unix package implementation.</p><p>我对mmap-go库的实现感到困惑。它仅提供在上面的示例中使用的mmap.ANON标志。如果希望映射是私有的，则可以将mmap.COPY标志设置为prot参数。无论如何，您始终可以使用unix软件包实现提供的标志。</p><p>  Two other nice methods,  Lock and  Flush, are provided by the API of  mmap-go. The  Lock method calls the  mlock system call that prevents the mapping to be paged out to disk. And the  Flush method calls the  msync system call that forces the data in memory to be written to disk. This is a good way to trying to have more control over how and when data is flushed to disk.</p><p>  mmap-go的API提供了另外两种不错的方法Lock和Flush。 Lock方法调用mlock系统调用，该调用可防止将映射分页到磁盘。 Flush方法调用msync系统调用，该系统调用强制将内存中的数据写入磁盘。这是尝试更好地控制将数据刷新到磁盘的方式和时间的好方法。</p><p>  I felt kind of stupid of knowing about  mmap after so long. I don&#39;t remember it being brought in my college class. For some reason, I felt amazed by it and its capabilities and decided to dig deeper. I like databases and I&#39;m aiming to get a better grasp of them. This means that  mmap cannot go unnoticed from my learning. For future posts, I&#39;ll try to bring about the benefits and drawbacks of using  mmap, which projects use it, and what kind of problems it is suited for.</p><p>  这么久以后，我对了解mmap感到有点愚蠢。我不记得上大学时带过它。由于某种原因，我对它及其功能感到惊讶，因此决定更深入地研究。我喜欢数据库，我的目标是更好地掌握它们。这意味着mmap不会因我的学习而被忽视。对于以后的帖子，我将尝试介绍使用mmap的优缺点，哪些项目会使用它以及它适合什么样的问题。</p><p> Even though the  mmap can be used to solve that database problem we stated in the beginning, and many modern databases use it,  Andy Pavlo advocates against it and have three lecture on how to databases, that don&#39;t use  mmap, manage data.</p><p> 即使mmap可以用来解决我们一开始就提到的数据库问题，并且许多现代数据库都在使用它，但Andy Pavlo还是反对使用它，并且在关于如何使用数据库而不使用mmap来管理数据的三个演讲中。</p><p> If you like this kind of content, follow me on  twitter. You may find more related stuff there.</p><p> 如果您喜欢这种内容，请在Twitter上关注我。您可能在那里找到更多相关的东西。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://brunocalza.me/2021/01/10/discovering-and-exploring-mmap-using-go/">https://brunocalza.me/2021/01/10/discovering-and-exploring-mmap-using-go/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/发现/">#发现</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/exploring/">#exploring</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/mmap/">#mmap</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>