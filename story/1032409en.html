<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我讨厌Python静态类型标注方案</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我讨厌Python静态类型标注方案</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-31 07:54:02</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/2269f52f0eb0ef16935e9b7ae5ee39df.jpeg"><img src="http://img2.diglog.com/img/2020/10/2269f52f0eb0ef16935e9b7ae5ee39df.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Basically. I don’t hate Python type annotations,  per se — there is nothing wrong with  thing: int = 0 in my eyes. But those same eyes do bleed a little whenever I have to look through any given morass of verbose flotsam of the sort the  typing module encourages people to write.</p><p>基本上。我并不讨厌Python类型的批注-在我看来：int=0没有什么错。但是，每当我不得不看任何给定的冗长的废墟时，这双眼睛确实会有点流血，这就是打字模块鼓励人们写作的那种杂乱无章的东西。</p><p>  The  typing module, and its bestie  the MyPy static analyzer and linter, have preëmptively hijacked two plausibly useful new dunderized Python classmethods:  __class_getitem__(…) and  __mro_entries__(…), which according to their introductory PEP are  off-limits for uses beyond the implementation of the   typing  internals (q.v. section end-note  sub). Which OH COME ON. Abusing dunder methods is what makes Python Python. How else are we to be explicit, which is better than implicit? Didn’t Python only recently add  __matmul__(…) and friends, which don’t even  have a default implementation like anywhere in the standard library?? Ugh. When people do shit like  subpath = pathlike(¬) / pathlike(•) / &#34;frag.ext&#34; should their “abuse” of the  __truediv__(…) and  __rtruediv__(…) dunders be slapped with some kind of new  MethodOffLimitsError?!</p><p>类型模块，以及它最好的Mypy静态分析器和Linter，已经预先劫持了两个看似有用的新的、不可靠的Python类方法：__CLASS_GETIEM__(…)。和__MRO_条目__(…)。，根据它们的介绍性PEP，除了实现键入内部部件(q.v.。小节尾注小节)。哪一个哦来吧。滥用Dunder方法使Python成为Python。我们怎么才能显性地表达出来，这比含蓄要好呢？Python不是最近才添加了__matmul__(…)吗。朋友们，他们甚至没有像标准库中的任何地方那样的默认实现？？呃.。当人们像狗屎一样拉屎时，他们是否应该“滥用”__truediv_(…)？(？和__rtruediv__(…)。笨蛋会被打上某种新的MethodOffLimitsError吗？！</p><p> Speaking of MyPy, I worry that its development is driving the design of the typing syntax and semantics, and it’s at version 0.70.something. I will be blunt: I don’t like MyPy. I don’t like its premise — a programs’ emergent typology is intrinsic to the nature of its functionality; dealing with it using a linting phase — the same way you deal with malformatted docstrings or excess line breaks around method defs — is sending the wrong message.</p><p>说到MyPy，我担心它的开发正在推动类型语法和语义的设计，而且它的版本是0.70。我直截了当地说：我不喜欢我的Py。我不喜欢它的前提-程序的紧急类型学是其功能的本质所固有的；使用linting阶段处理它-就像处理格式错误的文档字符串或方法defs周围的多余换行符一样-发出了错误的消息。</p><p> I also don’t like how MyPy behaves at the moment. I have a project that has some basic definitions in a few Python modules: ABCs, boolean predicates, stringification utilities, &amp;c &amp;c. Those are then used to build a loose hierarchy of data structures, and then those are used to build some interoperable (and hopefully extensible) basic apps. So it’s like a cheeseburger, in terms of how many layers there are and how those layers build and utilize one another. Right? So getting the imports right at that low level is important, to avoid circular dependencies and priority inversions and stuff like that. Well, so. Since MyPy is a static analyzer, it has to represent the target Python program without actually executing it. In some areas, it does this perfectly smoothly — Python’s standard library offers APIs for (say) working with intermediate abstract-syntax graphs, and the interpreter’s internal structures. Some stuff is rather rough, though, and specifically the way MyPy analyzes imports needs to be shot at dawn and reimplemented from nothing. Last time I checked, it did not differentiate between  import statements at module-level and those enclosed within function and method defs, which is wack. It also had no idea what to do with imports that didn’t refer to straight-up super-vanilla standard, ordinary file-based code modules — considering  how much API churn there has been around getting the  sys.meta_path import hooks juuuuuust right, you’d think someone from the MyPy cabal would have noticed that this shit kind-of matters,  n’est ce pas?</p><p>我也不喜欢MyPy目前的表现。我有一个项目，它在几个Python模块中有一些基本定义：ABC、布尔谓词、字符串化实用程序、&amp；c&amp；c。然后用它们来构建松散的数据结构层次结构，然后用它们来构建一些可互操作(希望是可扩展的)基本应用程序。因此，就像芝士汉堡一样，就有多少层，以及这些层是如何构建和利用彼此的。对吗？因此，在如此低的级别上正确获取导入非常重要，以避免循环依赖和优先级反转之类的事情。嗯，所以。因为MyPy是一个静态分析器，所以它必须表示目标Python程序，而不实际执行它。在某些方面，它非常顺利地做到了这一点--Python的标准库提供了(比方说)使用中间抽象语法图和解释器内部结构的API。不过，有些东西相当粗糙，特别是MyPy分析进口的方式需要从无到有，从无到有地重新实现。上次我检查时，它没有区分模块级的import语句和那些包含在函数和方法defs中的语句，这很奇怪。它也不知道如何处理那些没有引用直接的超普通标准的、普通的基于文件的代码模块的导入-考虑到在获得sys.meta_path导入钩子的过程中发生了多少API波动，你会认为MyPy阴谋集团的某个人会注意到这种狗屎般的事情吗，n‘est ce Pas？</p><p> The types and annotations on offer from  typing add a shitload of crufty visual noise to the code.</p><p>输入提供的类型和注释给代码增加了大量的可视噪声。</p><p>  … This is  something I wrote last year, wh en I was doing  import typing as tx to try and mitigate the avalanche of absurd scarecrow types one has to pull out of  typing. I particularly bristle at the  __slots__ member’s requisite annotation (the ClassVar[Tuple[str, ...]] bit) as it is made unnecessarily longer by a) requiring that  ClassVar annotations enclose the type hints for a class member and b) using the  ... tag in the  Tuple hint to indicate that it’s a homogenous invariant. Fuck me. How about just:</p><p>…。这是我去年写的东西，当时我以TX的身份进行输入打字，试图减轻人们不得不退出打字的荒谬稻草人类型的雪崩。我尤其对__槽__成员的必要注释(ClassVar[Tuple[str，...]])感到恼火。位)，因为a)要求ClassVar注释包含类成员的类型提示，以及b)使用...。标记，以指示它是齐次不变量。操我。不如干脆：</p><p>    … that’s actually a little weird, maybe not. Hrm. No judgement in brainstorming. I wouldn’t even mind maybe something along the lines of:</p><p>…。这实际上有点奇怪，也许不是。人力资源管理。集思广益是没有评判的。我甚至不介意这样的事情：</p><p>  … more on the meaning of the angle-bracket syntax to come. But yeah, yeah! We’ve got Unicode support for identifiers in the interpreter, let’s use it! Alias  Ellipses to a higher point of code!!! Yes.This example has digressed towards absurdity, but you see what I am saying.</p><p>…。稍后将详细介绍尖括号语法的含义。但是是啊，是啊！我们已经为解释器中的标识符提供了Unicode支持，让我们使用它吧！将别名省略到更高的代码点！是的，这个例子有点离题，但你知道我在说什么。</p><p>  The  typing module relies on a parallel hierarchy of dummy types to both represent built-ins and to disambiguate certain syntactic nuances.</p><p>类型模块依赖于虚拟类型的并行层次结构来表示内置内容并消除某些语法细微差别的歧义。</p><p>       … is a bit fucking ridiculous. Importing all of those fake names is coarse, and vulgar.  Unpythonic, even. And look, first of all:  the very authors of all of this stuff have acknowledged this fact, more or less — to the point of drafting a PEP explaining this particular logorrheic fuckedupedness, and proposing to fix it by depreciating all of the duplicate dummy types in  typing (so  typing.Dict and  typing.List and  typing.Str, &amp;c) and making the actual builtins work with “type parameters”.</p><p>…。有点他妈的可笑。进口所有这些假名字是粗俗和粗俗的。甚至是无脊椎动物。首先，请看：所有这些东西的作者都或多或少地承认了这一事实-以至于起草了一份PEP来解释这一特殊的逻辑错误，并建议通过折旧键入中所有重复的虚拟类型(因此键入.Dict和键入.List和键入.Str，&amp；c)来解决这个问题，并使实际的内置使用“类型参数”。</p><p>  I put that last bit in quotes because, secondly, the whole thing of using the subscript operator (née ‘brackets’, or  […]) on a typename is also something I consider rather grossitating.</p><p>我把最后一位放在引号中是因为，第二，使用下标运算符(née‘括号’，或[…])的整个过程。在TypeName上也是我认为相当令人讨厌的事情。</p><p> By dint of some explanation, allow me to stop for a moment and give you a bearing or two through the dense fog of my personal opinion: I fucking love C++. I totally fucking love it to pieces. I realize this is a minority opinion; most people with significant domain-experience can expertly enumerate a shitzillion reasons why C++ is a loathsome shambolic chimerical plague on the programming zeitgeist; I have read their amusing posts whilst myself trying to wrap my head around some C++ curve thrown unexpectedly my way on one long late night or another.</p><p>借助于一些解释，请允许我停下来片刻，在我个人观点的迷雾中给您一个或两个方向：我他妈的热爱C++。我真他妈的爱死它了。我意识到这只是少数人的观点；大多数有丰富领域经验的人都可以熟练地列举出无数理由，说明为什么C++是编程时代精神上令人厌恶的混乱的幻想瘟疫；我读过他们的有趣帖子，同时试图理解在某个漫长的深夜意外抛出的一些C++曲线。</p><p>    See yeah that last bit, about the Zen state of it — that, and how C++ isn’t really object-oriented so much as it is struct-oriented — those are the foundations of this love I have for the language. Which, I should probably note at this point, I did not fully immersively learn until 2012, which is after 2011, which is when  C++11 happened, which was (in case you were not as of yet aware) a big deal.</p><p>请看最后一点，关于它的禅宗状态，以及C++是如何与其说是真正面向对象的，不如说是面向结构的-这些都是我对该语言热爱的基础。在这一点上，我可能应该注意到，我直到2012年才完全沉浸在学习中，那是在2011年之后，也就是C++11发生的时候，这是一个很大的问题(如果您还没有意识到的话)。</p><p> But so yeah, the language that I generally hate the most — the one I personally can systematically and righteously discredit and defame at the drop of a conversational hat — is Java. I  earned my right to loathe Java. I programmed  n-tier web service architectures against the first motherfucking commerically available Servlet container ever (JRun 1.0 dogg) and then waded through the horrible mire of JSP; I wrote several ORMs and even an FRM (all of which were pretty fly-by-night, but they worked); I wasted upwards of six to eight hours trying to debug something that was surely dark and formless and as evil as anything that ever walked the Earth — only to eventually discover that a few mislaid characters in the  $CLASSPATH were the cause of the crisis. I used JBoss. I used  WebSphere.</p><p>但是，是的，我通常最讨厌的语言是爪哇--这是一种我个人可以立即系统地、公正地诋毁和诋毁的语言。我赢得了厌恶爪哇的权利。我针对有史以来第一个他妈的商用servlet容器(JRun 1.0 Dogg)编写了n层Web服务体系结构，然后涉水穿过了可怕的JSP泥潭；我编写了几个ORM，甚至一个FRM(所有这些都非常不可靠，但它们都有效)；我浪费了6到8个小时来调试一些肯定是黑暗、无形和邪恶的东西，就像地球上曾经出现过的任何东西一样邪恶-最后才发现$CLASSPATH中的几个错放的字符是导致危机的原因。在调试过程中，我浪费了6到8个小时来调试肯定是黑暗、无形和邪恶的东西-最后才发现$CLASSPATH中的几个错放的字符是导致危机的原因。我使用的是JBoss。我使用的是WebSphere。</p><p>  In recent years my piss and vinegar has evaporated, and so I am able to refrain from telling e.g. total strangers I meet at the bar why anyone subclassing  java.lang.ClassLoader is a spiritually-impoverished sociopath in need of a good public flagellation — honestly, I am no longer that person. I think I was that person, like, back in my twenties; I personally apologize if you knew me then and had to listen to my effusive nonsense on this kind of subject.</p><p>近年来，我的小便和醋都蒸发了，所以我可以克制住不告诉例如我在酒吧遇到的完全陌生的人为什么有人把java.lang.ClassLoader细分为java.lang.ClassLoader是一个精神上贫穷的反社会者，需要一个好的公开鞭打-老实说，我不再是那个人了。我想我就是那个二十多岁的人，如果你当时认识我，不得不听我在这类话题上的胡言乱语，我个人向你道歉。</p><p> But yeah so, the point. OK. The point is that, within this battle-tested and time-tempered taxonomic distaste I harbor, I think I have the largest untempered chunk of raw anti-Java ire remaining for the Java languages’ “generics”.</p><p>但是，是的，所以，重点是。好的。问题是，在我这种经受过战斗考验和经过时间考验的分类学反感中，我认为我对Java语言的“泛型”有最大的原始反Java怒火。</p><p> For a while, Java had no generics. This wasn’t too big a deal; everything under its hood was pointers and everything internally was mercilessly aligned to the system word length (I think?) — also, since “Java” was at once the language, the runtime, the virtual-machine execution environment, and the standard class library, it could count on (just about) every object instances’ class descending from one singular root  Object class.</p><p>有一段时间，Java没有泛型。这不是什么大不了的事；它的引擎盖下的一切都是指针，内部的所有东西都无情地与系统字长对齐(我认为？)-而且，由于“Java”同时是语言、运行时、虚拟机执行环境和标准类库，它可以依赖(几乎)每个对象实例的类从一个单独的根对象类派生出来。</p><p> This last fact makes casting things in Java much different than in (say) C++. Internally, the Java runtime can alter the type-signature metadata records for the castee, which is of a piece with a  s/typename/castname/g type of thing.</p><p>最后一个事实使得Java中的强制转换与(比方说)C++中的转换有很大的不同。在内部，Java运行时可以更改CASTEE的类型签名元数据记录，该记录属于s/typeName/Castname/g类型。</p><p>  Contrastingly, in C++ casting and conversion is  a whole doctoral dissertation of extremely specific, prickly rules and regulations. So it does not matter whether you find these stipulations irritating or (in my case) a long-overdue salve of logic and order, somehow palliative against the endless obsessive-compulsive reflux churn of ones’ own thoughts… we can all agree that casting in Java is pretty thoroughly different from casting in C++.</p><p>与之形成鲜明对比的是，在“C++转换与转换”中有一整篇博士论文，其中包含非常具体、棘手的规则和规则。因此，无论你觉得这些规定令人恼火，还是(对我来说)是一种早就应该的逻辑和秩序的药膏，在某种程度上缓解了自己思想无休止的强迫性回流搅动(…)，这都无关紧要。我们都同意Java中的强制转换与C++中的强制转换完全不同。</p><p> But like so many other decisions made by the people in charge of Java, they added “generics” to the language in a way that  looked like something they knew, regardless of the way it  acted. Java generics work like up- and down-casts within an object hierarchy with a single root; the closest thing C++ has to something that  looks like this is  dynamic_cast&lt;…&gt;(¬) — but C++ type metadata is barely even a runtime thing, they don’t  act the same at all. A cast in C++ will either reinterpret memory or invoke a type conversion operator, or possibly both. Downcasting an instance (even through a straightforward, unbranching type tower) can “slice” the object in memory if the downcasted instance is a temporary passed by value.</p><p>但就像Java负责人做出的许多其他决策一样，他们以一种看起来像他们知道的方式向语言添加了“泛型”，而不考虑它的行为方式。JAVA泛型的工作方式类似于具有单个根的对象层次结构中的向上和向下强制转换；C++最接近的是Dynamic_Cast&lt；…。&gt；()-但是C++类型的元数据甚至不是一个运行时的东西，它们的行为完全不同。C++中的强制转换要么重新解释内存，要么调用类型转换操作符，或者可能两者兼而有之。如果向下转换的实例是临时通过值传递的，则向下转换实例(即使通过一个简单的、无分支类型的塔)也可以在内存中“分割”该对象。</p><p>  I digress, don’t I? This really is all to say that I don’t like what they did in Java — which was: they made generics  look sort of like  C++ templates, even though they  do not act like them. They used a similar angle-bracket syntax for “specialization” and declaration of generic types. But then found that they had to add a bunch of weird shit that doesn’t immediately make sense — like the question-mark typename wildcard-ish expressions — which lead to “PECS” being  something you need to remember while you’re attempting to do all this generic Java-ing.</p><p>我离题了，不是吗？这实际上是说我不喜欢他们在Java中所做的事情--那就是：他们让泛型看起来有点像C++模板，尽管它们的行为并不像C++模板。他们对泛型类型的“专门化”和声明使用了类似的尖括号语法。但是后来发现，他们不得不添加一堆奇怪的狗屎，这些狗屎不会立即有意义-比如问号类型名称通配符之类的表达式-这会导致在尝试执行所有这些通用Java时需要记住“pes”。</p><p> But it’s all bullshit, isn’t it? I don’t know thing one about  javac and how it optimizes things, or the many many many extravagant systems upon subsystems within the JVM that all strive for the most flawless execution of your code. But I do know that Java generics use “type erasure” —  genericized expressions literally do not give a proper fuck about types, meaning all of that metadata the JVM is looking after is just ignored, like when you do, say:</p><p>但这都是胡说八道，不是吗？我对javac一无所知，也不知道它是如何优化东西的，也不知道JVM中的子系统上的许多奢侈系统都在努力使您的代码执行得最完美。但是我确实知道Java泛型使用“类型擦除”-泛化表达式实际上不会给类型带来适当的操控，这意味着JVM正在管理的所有元数据都被忽略了，就像当您这样做时，可以这样说：</p><p>  Experts agree:  this isn’t faster, or better. Java generics  look like C++ templates, an arcane feature one can use to forge a path to the optimal — but they  act like a big shoulder-shrug of a dynamic downcast.</p><p>专家们一致认为：这并不是更快，也不是更好。Java泛型看起来像C++模板，这是一个神秘的特性，人们可以用它来打造一条通向最优的道路-但它们的作用就像是一个动态低迷的人的一大块耸肩。</p><p> So yeah — those are my feelings. Now you know them. Strangely enough, writing this up has made me want to actually go and program in Java again — if for no other reason than to maintain the experiential bonafides that permit me to fucking hate it. But also, you know, when something bothers you, it’s often quite instructive to take a good hard long look at that thing, and to see exactly what it is that is doing the bothering, and how it might work. Yes.</p><p>所以是的-这就是我的感受。现在你认识他们了。奇怪的是，写下这篇文章让我想再次用Java编程-如果没有其他原因，就是为了保持允许我他妈的讨厌Java的经验诚意。但是，你也知道，当有事情困扰你的时候，仔细仔细地看一看它，看看到底是什么在困扰着你，以及它是如何工作的，这通常是很有启发性的。是。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/@hopro/i-detest-the-python-static-typing-annotation-schemes-fbb0fa9b1f59">https://medium.com/@hopro/i-detest-the-python-static-typing-annotation-schemes-fbb0fa9b1f59</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031890.html"><img src="http://img2.diglog.com/img/2020/10/thumb_7cf484ceeae6bc7fc2161eddc603cd15.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031890.html">Pyston v2：更快的Python</a></div><span class="my_story_list_date">2020-10-29 10:34</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031681.html"><img src="http://img2.diglog.com/img/2020/10/thumb_c969aaacb6f2e948b3df52e085ae5422.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031681.html">在Postgres中使用Python和Pandas构建推荐引擎</a></div><span class="my_story_list_date">2020-10-28 10:4</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031446.html"><img src="http://img2.diglog.com/img/2020/10/thumb_51ce4d0597c92556e291d1a74d251921.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031446.html">使用Austin TUI在不降低性能的情况下监视正在运行的Python应用程序</a></div><span class="my_story_list_date">2020-10-27 19:47</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031069.html"><img src="http://img2.diglog.com/img/2020/10/thumb_ca280e09fd83e1f2f155b5d81ec8893c.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031069.html">Python需要改变吗？</a></div><span class="my_story_list_date">2020-10-25 15:53</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>