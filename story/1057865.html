<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Futhark的蓝色噪音 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Futhark的蓝色噪音 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-13 01:08:53</div><div class="page_narrow text-break page_content"><p>久前，我读了苏克马的抖动的优秀文章。立即，它引起了我对奥德拉·丁尼恩的游戏回归的兴趣，因为我从非常享受。我也认为尝试实施他在Futhark描述的一些抖动算法很有趣，但我从未真正过到处。到现在！</p><p> 我主要将专注于蓝色噪声滤波器，因为这似乎是最有趣的滤波器，但我也可以在拜耳过滤器中实施拜耳滤波器，也许是其他人。我将跳过大部分关于抖动工作以及目的的详细信息，而是将您指向上面链接的文章。本篇文章的目的是说明我们如何实现使用Futhark描述的算法。</p><p> 顺便说一下，这个博客帖子是使用Futhark incorate编写的，所以您可以在闲暇时检查整个源代码。</p><p>   我们将使用与Surma的博客文章中的相同图像：</p><p>   将图像加载到Futhark界面中以[] [] U32的形式返回ARGB格式的像素。我们只对灰度图像感兴趣，因此让我们写一些函数来将argb图像转换为灰度。我们将使用0到1之间的F32值来表示灰度，0是黑色和1个白色。我们也立即执行一些伽玛修正，因此我们可以从现在开始使用灰度图像。</p><p> 让unpack_rgb（像素：u32）:( u8，u8，u8）=（u8.u32像素，u8.u32（像素＆gt;＆gt; 8），U8.u32（像素＆gt;＆gt; 16））让亮度（像素：U32）：F32 =设（r，g，b）= unpack_rgb pixel  - 我们可以只使用其中一个频道，但这应该给我们带来相同的结果 - 当输入图像已经灰度时，结果也是如此。在（F32.U8 R + F32.U8 G + F32.U8 B）/（255.0 * 3）</p><p>  让_linear（b：f32）：f32 =如果b＆lt; = 0.04045则b / 12.92 else（（b + 0.055）/ 1.055）** 2.4灰度[n] [m] [m] [m] [n]（img：[n] [m] U32）：[n] [m] f32 = map（map（to_linear＆lt;亮度））img </p><p>现在我们可以尝试应用单个量化方法检查每个像素是否低于或高于0.5，以便确定它是否应该是黑色或白色：</p><p>      请注意，我使用Booleans表示纯黑白像素：True是白色，假是黑色。</p><p> 如原始文章所述，这种方法非常不满意。我们几乎无法看到所描绘的内容。</p><p>  Import＆＃34; lib / github.com / diku-dk / cpprandom / comantum＆＃34;模块d = siment_real_distibution f32 minstd_randlet量化_random [n] [m]（种子：i32）（img：[n] [m] f32） ：[n] [m] bool =  - 每像素创建RNG，让RNGs = minstd_rand.rng_from_seed [seed] |＆gt; minstd_rand.split_rng n |＆gt;地图（minstd_rand.split_rng m） - 对于每个像素，在map2中应用随机性因子并量化（map2（\ rng pixel  - ＆gt; let（_，x）= d.rand（0,1）rng在pixel＆gt; x ））RNGS IMG</p><p>      我们在量化时真正做的是，将原始图像中的每个像素进行比较到掩码。我们已经看到了两个案例，我们将其与掩码进行比较，其中所有值为0.5，以及随机生成掩码的一个掩码，但存在许多其他掩模。我们还可以想象掩码可能没有必要具有与输入图像相同的大小，如果我们只能用掩模图像铺设原始图像。</p><p> 此广义过程称为抖动，因此让我们写一个函数来向图像应用抖动掩码：</p><p> 让抖动[n] [n] [n＆＃39;] [m＆＃39;]（max：[n] [m] f32）（掩模：[n＆＃39;] [m＆＃39;] f32）：[ n] [m] bool =让辅助ij pixel = pixel＆gt; map2中[i％n＆＃39;]在map2（\ i  - ＆gt; map2（辅助i）（iota m））（iota n）img </p><p>现在让我们看看一些面具。第一个是拜耳掩模，它使用拜耳矩阵。</p><p> 首先，我们需要一个辅助函数：Concat_m采用四个相等大小的矩阵并将它们排列在方矩阵中。</p><p> 假设concat_m [n]＆＃39; t（xss1：[n] t）（xss2：[n] [n] t）（xss3：[n] [n] t）（xss4：[n] [ n] t）：[] t =拍摄n2 = n * 2在concat（转置（转置xss1）（翻转xss2）））（转置（concate_to n2（翻转xss3）（翻转xss3）））</p><p>  让拜耳（n：i64）：[] [] i32 =让舵机i = map（map（\ x  - ＆gt; 4 * x + i））让拜耳= [[0,2]，[3,1]]如果n == 0那么拜耳别跳别队_在1 ... n do concat_m（助手0拜耳）（Helper 2拜耳）（Helper 3 Bayer）（Helper 1 Bayer）</p><p> 注意，我们应该使用比特算术方法，或者至少确定哪一个更快：https://en.wikipedia.org/wiki/Ordered_dithing</p><p> 我们还需要能够正常化拜耳滤波器（以及后来的Bluenoise过滤器）。为此，我们将介绍正常化_I32：</p><p> 让rangalize_i32 [n] [m]（xss：[n] [m] i32）：[n] [m] f32 =在地图中置于map（map（\ x  - ＆gt）的最大= i32.maximum ; f32.i32 x / f32.i32最大值））xss </p><p>让我们看看一些结果。首先，我们创建了前四个拜耳矩阵，看看较大矩阵对抖动结果的影响：</p><p> 让Bayer0 = Normalize_I32（拜耳0）让Bayer1 = Normalize_I32（拜耳1）让Bayer2 = Normalize_I32（拜耳2）让Bayer3 = Normalize_I32（拜耳3）</p><p>                    让我们继续前进到蓝色噪声过滤器，这是一种为抖动产生掩模的另一种方式。它基于最初由Robert Ulichney描述的空白和群集方法。</p><p> 该算法采用随机二进制图案作为输入，进入初始二进制模式，然后使用该初始二进制模式来通过三相生成最终掩模。</p><p> 首先，我们需要能够生成输入模式，这只是一个随机生成的二进制模式，其中不到一半的值是白色：</p><p> module dist = siment_int_distribution i64 minstd_randlet rand_binary_pattern（seed：i32）（n：i64）（m：i64）：[n] [m] bool = let rng = minstd_rand.rng_from_seed [seed]  - 仅使用n * m矩阵 - 生成n * m矩阵`false`值让xss = replice n（repliced m false） - 生成少数逻辑数目，并将它们设置为`true`。让RNGS = minstd_rand.split_rng（n * m / 4）rng（idxs，vals）= map（\ rng  - ＆gt; let（rng，y）= dist.rand（0，n）rng vet（_，x） = dist.rand（0，m）rng In（（y，x），true））rngs |＆gt;散射x2d xss andxs vals中的解压缩</p><p> 该算法取决于能够找到最紧密的集群和给定图像的最大void。要找到最密封的集群，我们将高斯模糊应用于图像，并在结果中找到最亮的像素。要找到最大的void，我们这样做但尝试找到结果的最黑暗的像素。 </p><p>因此，我们需要能够计算我们可以用来模糊的高斯内核。我们使用Surma也使用的高斯函数，这是Ulichney建议的略微修改的版本。</p><p> 让Gaussian_kernel（n：i64）：[n] [n] f32 =让sigma：f32 = 1.5让因素= 1 /（2 * f32.pi * sigma ** 2）让高斯xy = factor * f32.e ** （ - （f32.i64（x  -  n / 2）** 2 + f32.i64（y  -  n / 2）** 2）/（2 * sigma ** 2））在Tabular_2d nn gaussian</p><p>  让Blur_naive [n]（内核：[n] [n] f32）（Inp：[n] bool）= Let Halfn = N / 2 Let blur_pixel（py：i64）（px：i64）：f32 = map2 （\ qy  - ＆gt; map2（\ qx g  - ＆gt; let x =（px + qx  -  halfn）％n在f32.bool inp [y，x] * g中let y =（py + qy  -  halfn）％n ）（iota n））（iota n）内核|＆gt;扁平|＆gt; f32.sum在tabulate_2d n b blur_pixel中</p><p> 实现了我们的模糊功能，我们现在可以实现CILICEST_CLUSTER和RESTAL_VOID函数。真的，他们是非常相似的，我们肯定可以将它们抽出一个函数，但保持它们分开使其更清楚他们的所作所为。</p><p> 让紧身_cluster [n]（模糊：[n] [n] bool  - ＆gt; [n] [n] f32）（Inp：[n] [n] bool）:( i64，i64）=  - 模糊输入图像Blur Inp  - 还返回每个像素的指数及其布尔值。 |＆gt; MAP3 ZIP3（表格_2D N N（\ I j  - ＆gt;（i，j）））INP  - 压平矩阵，因此我们正在使用一条单维数组。 - 查找最高值的像素，仅考虑仅为“真实”的像素 - 原始输入。 |＆gt;扁平|＆gt; reame_comm（\（idx，x，v）（idx＆＃39;，x＆＃39;，v＆＃39;） - ＆gt;如果v＆gt; v＆＃39; ||！x＆＃39;然后（idx，x， v）否则（Idx＆＃39;，x＆＃39;，v＆＃39;））（（-1，-1），false，f32.lowest）|＆gt; （.0）让Rest_void [n]（模糊：[n] [n] bool  - ＆gt; [n] [n] f32）（Inp：[n] bool）:( I64，I64）=模糊INP |＆gt; MAP3 ZIP3（表格_2D N N（\ I j  - ＆gt;（i，j）））INP |＆GT;扁平|＆gt; reame_comm（\（idx，x，v）（Idx＆＃39;，x＆＃39;，v＆＃39;） - ＆gt;如果v＆lt; v＆＃39; || x＆＃39;然后（idx，x，v ）否则（IDX＆＃39;，x＆＃39;，V＆＃39;））（（-1，-1），真实，f32.highest）|＆gt; （.0）</p><p> 使用这些构建块，让我们实现Initial_Binary_Pattern。 IP是输入模式，结果是初始二进制模式。</p><p> 让initial_binary_pattern [n]（模糊：[n] [n] bool  - ＆gt; [n] [n] f32）（ip：* [n] [n] bool）：* [n] [n] bool = let（ _，_，res）=  - 用无效但不同的值循环初始化两个索引（（i，j），（i＆＃39;，j＆＃39;），IP）=（（-2，-2）， （-1，-1），IP） - 虽然这两个指数不同（i，j）！=（i＆＃39;，j＆＃39;）do  - 计算最紧密的集群的位置i，j）= cixtest_cluster blur ip  - 将该位置设置为false，让let ip [i，j] = false  - 计算最大的void的位置让（i＆＃39;，j＆＃39;）= tally_void blur ip  -  - 将该位置设置为true，让ip [i＆＃39;，j＆＃39;] = true  - 重复（（i，j），（i＆＃39;，j＆＃39;），IP），IP） </p><p>最后，为了可视化Smallish模式，让我们写一些函数来扩展它们，以便达到任意像素大小：</p><p> 让规模[n] [m]＆＃39; t（n2：i64）（m2：i64）（img：[n] [m] t）：* [n2] [m2] t = let y_scale = f32.i64 n2 / f32.i64 n设x_scale = f32.i64m2 / f32.i64 m在表格_2d n2 m2中（\ ij  - ＆gt; img [i64.f32＆lt; | f32.i64i / y_scale，i64.f32＆lt; | f32 .i64 j / x_scale]）Let Scale_F32：（I64  - ＆gt; I64  - ＆gt; [] [] f32  - ＆gt; * [] f32）=缩放量表_bool：（i64  - ＆gt; i64  - ＆gt; [] [ ] BOOL  - ＆gt; * [] [] bool）=比例</p><p> 随着所有的，让我们看看生成的初始二进制模式可以看起来像：</p><p>    看起来很好，我想！所以现在，让我们走进蓝色噪音模式。 Bluenoise函数是ulichneys原始纸上所述的算法非常直接的实现：</p><p> 让bluenoise [n]（模糊：[n] [n] bool  - ＆gt; [n] [n] f32）（Ibp：[n] [n] bool）：[n] [n] i32 =  - 加载具有初始二进制模式的二进制模式让BP = Copy IBP  -  Oner是二进制模式中的“True”值的数量，让One = Flatten IBP |＆Gt;地图i32.bool |＆gt; I32.Sum让Rank = Oner  -  1  -  DIT`是结果抖动阵列WE＆＃39; LL输入值。让DIT =复制n（复制n 0i32） - 阶段1让（DIT，_，_）=循环（DIT，BP，等级）而等级＆gt; = 0做，让（i，j）= cirtent_cluster blur bp让bp [i，j] = false让dit [i，j] =排名（dit，bp，rank-1）让bp = copy Ibp让Rank = One  - 阶段2让（DIT，BP，RANK）=循环（ dit，bp，等级）等级＆lt; i32.i64（n * n / 2）让（i，j）= gest_void blur bp让bp [i，j] = true let dit [i，j] =排名（dit，bp，等级+ 1） -  - 倒置二进制模式，使得`FALSE`现在是少数像素让BP =地图（MAP（！））BP  - 阶段3让（DIT，_，_）=循环（DIT，BP，等级）而等级＆lt; i32.i64（n * n）让（i，j）= cixtest_cluster blur bp让bp [i，j] = false令dit [i，j] = dit中的（dit，bp，rank + 1）排名</p><p>     对我看起来很随意。让我们试着将它应用于我们的图像：</p><p>      即使在Futhark，朴素的蓝色噪音实现也很慢。让我们试着看看我们是否可以通过在频率空间中应用高斯来加速它。 </p><p>让Center_FFT [N]＆＃39; T（IMG：[n] [n] t）：[n] [n] t = map（旋转（n / 2））img |＆gt;旋转（N / 2）</p><p> 要模糊，我们将内核和输入图像转换为频率空间并将它们乘以在一起</p><p> 让模糊[n]（内核：[n] [n] f32）（inp：[n] bool）：[n] [n] f32 =让核＆＃39; =内核|＆gt; fft32.fft2_re |＆gt; Center_fft让InP＆＃39; =地图（MAP F32.BOOL）INP |＆GT; fft32.fft2_re |＆gt; Map2中的Center_FFT（Map2（C32。*））内核＆＃39; INP＆＃39; |＆gt; Center_FFT |＆GT; FFT32.IFFT2 |＆GT; Center_FFT |＆GT;地图（地图C32.mag）Let Bluenoise_Mask_FFT = Normalize_I32（Bluenoise（Blur_fft Ker_64）IBP）</p><p>          -  ==  - 输入：blur_naive_bench--编译随机输入{[32] [32] bool}  - 编译随机输入{[64] [64] bool}  - 编译随机输入{[128] [128] bool }</p><p>   -  ==  - 输入：blur_fft_bench--编译随机输入{[32] [32] bool}  - 编译随机输入{[64] [64] bool}  - 编译随机输入{[128] [128] bool }  - 编译随机输入{[256] [256] bool}</p><p>   -  ==  - 条目：bluenoise_test_naive  - 编译随机输入{[16] [16] bool}  - 编译随机输入{[32] [32] bool}  - 编译随机输入{[64] [64] bool }</p><p> 条目bluenoise_test_naive [n]（inp：* [n] [n] bool）：* [n] [n] i32 = let kernel = gaussian_kernel n让ibp = initial_binary_pattern（blur_naive内核）在bluenoise（blur_naive内核）IBP中的IBP </p><p>-  ==  - 输入：bluenoise_test_fft  - 编译随机输入{[16] [16] bool}  - 编译随机输入{[32] [32] bool}  - 编译随机输入{[64] [64] bool }  - 编译随机输入{[128] [128] bool}</p><p> 条目bluenoise_test_fft [n]（inp：* [n] [n] bool）：* [n] [n] i32 = let kernel = gaussian_kernel n让ibp = initial_binary_pattern（blur_naive内核）在bluenoise（blur_fft kernel）IBP中的IBP</p><p>  $ futhark bechch  -  backend = depencl bluenoise.futcompiling bluenoise.fut ...报告每个DataSet.bluenoise.fut：blur_naive_bench（使用bluenoise.fut.tuning）：data / [32] [32] bool 。 ）BOOL.in：4424μs（RSD：0.005; min：-1％; max：+ 1％）数据/ [256] bool.in：38266μs（RSD：0.006; min ：-1％; max：+ 1％）bluenoise.fut：blur_fft_bool（使用bluenoise.fut.tuning）：data / [32] [32] bool.in：159μs（RSD：0.165; min：-31％;最大：+ 25％）数据/ [64] [64] BOOL.IN：175μs（RSD：0.107; min：-14％;最大：+ 20％）数据/ [128] bool.in：179μs（RSD ：0.180; min：-35％; max：+ 26％）数据/ [256] bool.in：133μs（rsd：0.160; min：-18％; max：+ 29％）bluenoise.fut：bluenoise_test_naive （使用Bluenoise.Fut.Tuning）：[16] [16] BOOL：23879μs（RSD：0.003; min：-1％;最大：+0％）[32] [32] BOOL：99598μs（RSD：0.012; min ：-1％;最大值：+ 2％）[64] [64] bool：5203831μs（RSD：0.005; min：-1％; max：+ 1％）bluenoise.fut：bluenoise_te st_fft（使用bluenoise.fut.tuning）：[16] [16] BOOL：40842μs（RSD：0.076; Min：-8％; MAX：+ 8％）[32] BOOL：131507μs（RSD：0.003; MIN：-0％;最大：+0％）[64] BOOL：522510μs（RSD：0.002; min：-0 ％; max：+ 0％）[128] bool：2110416μs（RSD：0.009; min：-1％;最大：+ 1％）</p><p> Surma提到它需要他大约半分钟，以在2018年MacBook Pro上产生64x64的蓝色噪声纹理。相比之下，我们在大约一秒钟内完成它。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://munksgaard.github.io/bluenoise/">https://munksgaard.github.io/bluenoise/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/蓝色/">#蓝色</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/noise/">#noise</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/f32/">#f32</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1057598.html"><img src="http://img2.diglog.com/img/2021/4/thumb_7b40323348f4bda5206d4a08ed20b381.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1057598.html">一百家公司占“蓝色经济”的一半以上 </a></div><span class="my_story_list_date">2021-4-11 14:41</span></div><div class="col-sm"><div><a target="_blank" href="/story/1051834.html"><img src="http://img2.diglog.com/img/2021/3/thumb_f13672b8e94b6c901dc72d99d4911a35.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1051834.html">白天的蓝色屏幕 - 更新打印时崩溃了Windows 10 PC </a></div><span class="my_story_list_date">2021-3-12 2:53</span></div><div class="col-sm"><div><a target="_blank" href="/story/1046820.html"><img src="http://img2.diglog.com/img/2021/1/thumb_3afaffff8b4ad7d5c24c3fe03b626037.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1046820.html">YInMn，两个世纪以来的第一个新的蓝色颜料 </a></div><span class="my_story_list_date">2021-1-30 6:48</span></div><div class="col-sm"><div><a target="_blank" href="/story/1046089.html"><img src="http://img2.diglog.com/img/2021/1/thumb_cae27bac19f5a6192bcb3ddaabb4b052.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1046089.html">200年来第一次出售新的蓝色颜料 </a></div><span class="my_story_list_date">2021-1-24 8:4</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>