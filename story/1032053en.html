<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>将Lisp编译为x86-64：带标签的过程调用</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">将Lisp编译为x86-64：带标签的过程调用</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-30 00:37:11</div><div class="page_narrow text-break page_content"><p>Welcome back to the Compiling a Lisp series. Last time, we learned about Intelinstruction encoding. This time, we’re going to use that knowledge to compileprocedure calls.</p><p>欢迎回到编译Lisp系列。上次，我们学习了智能指令编码。这一次，我们将使用这些知识来编译过程调用。</p><p> The usual function expression in Lisp is a  lambda — an anonymous functionthat can take arguments and close over variables. Procedure calls are  notthis. They are simpler constructs that just take arguments and return values.</p><p>Lisp中常用的函数表达式是lambda--一个可以接受参数和关闭变量的匿名函数。过程调用不是这样的。它们是更简单的构造，只接受参数并返回值。</p><p> We’re adding procedure calls first as a stepping stone to full closure support.This will help us get some kind of internal calling convention established andstack manipulation figured out before things get too complicated.</p><p>我们首先添加过程调用作为完全闭包支持的垫脚石，这将帮助我们建立某种内部调用约定，并在事情变得太复杂之前弄清楚堆栈操作。</p><p>  ( labels  (( add  ( code  ( x  y )  ( +  x  y )))  ( sub  ( code  ( x  y )  ( -  x  y ))))  ( labelcall  sub  4  ( labelcall  add  1  2 ))) ; =&gt; 1</p><p>(标签((add(code(X Y)(+x y)(sub(code(X Y)(-x y)(labelcall sub 4(Labelcall Add 12)；=&gt；1。</p><p>  ( labels  (( factorial  ( code  ( x )  ( if  ( &lt;  x  2 )  1  ( *  x  ( labelcall  factorial  ( -  x  1 )))))))  ( labelcall  factorial  5 )) ; =&gt; 120</p><p>(Label((阶乘(code(X)(if(&lt；x2)1(*x(labelcall阶乘(-x 1)(labelcall阶乘5))；=&gt；120。</p><p> These are fairly pedestrian snippets of code but they demonstrate some newfeatures we are adding, like:</p><p>这些代码片段相当平淡无奇，但它们展示了我们添加的一些新功能，例如：</p><p>  Ghuloum does not explain why he does this, but I imagine that the  labels formwas chosen over allowing multiple separate top-level bindings because it iseasier to parse and traverse.</p><p>Ghuloum没有解释他为什么这样做，但我想，之所以选择标签Form而不是允许多个独立的顶级绑定，是因为它更容易解析和遍历。</p><p>  In order to compile a program, we are going to traverse every binding in the labels. For each binding, we will generate code for each  code object.</p><p>为了编译程序，我们将遍历标签中的每个绑定。对于每个绑定，我们将为每个代码对象生成代码。</p><p> Compiling  code objects requires making an environment for their parameters.We’ll establish a calling convention later so that our compiler knows where tofind the parameters.</p><p>编译代码对象需要为它们的参数创建一个环境。我们稍后将建立一个调用约定，以便我们的编译器知道在哪里可以找到参数。</p><p> Then, once we’ve emitted all the code for the bindings, we will compile thebody. The body may, but is not required to, contain a  labelcall expression.</p><p>然后，一旦我们发出了绑定的所有代码，我们将编译正文。正文可以(但不是必须)包含labelcall表达式。</p><p> In order to compile a  labelcall expression, we will compile all of thearguments provided, save them in consecutive locations on the stack, and thenemit a  call instruction.</p><p>为了编译labelcall表达式，我们将编译提供的所有参数，将它们保存在堆栈上的连续位置，然后发出CALL指令。</p><p> When all of these pieces come together, the resulting machine code will looksomething like this:</p><p>当所有这些部分放在一起时，得到的机器代码将如下所示：</p><p>  You can see that all of the  code objects will be compiled in sequence,followed by the body of the  labels form.</p><p>您可以看到，所有代码对象都将按顺序编译，紧随其后的是Labels窗体的正文。</p><p> Because I have not yet figured out how to start executing at somewhere otherthan the beginning of the generated code, and because I don’t store generatedcode in any intermediate buffers, and because we don’t know the sizes of anycode in advance, I do this funky thing where I emit a  jmp to the body code.</p><p>因为我还没有想出如何在生成代码的开头以外的其他地方开始执行，而且我没有将生成的代码存储在任何中间缓冲区中，并且因为我们事先不知道任何代码的大小，所以我做了这个时髦的事情，我向主体代码发出一个JMP。</p><p>   We’re not going to use the System V AMD64 ABI. That calling convention requiresthat parameters are passed first in certain registers, and then on the stack.Instead, we will pass all parameters on the stack.</p><p>我们不会使用System V AMD64ABI。该调用约定要求参数首先在某些寄存器中传递，然后在堆栈上传递。相反，我们将在堆栈上传递所有参数。</p><p> This makes our code simpler, but it also means that at some point later on, wewill have to add a different kind of calling convention so that we can callforeign functions (like  printf, or  exit, or something). Those functionsexpect their parameters in registers. We’ll worry about that later.</p><p>这使我们的代码变得更简单，但这也意味着在以后的某个时刻，我们将不得不添加不同类型的调用约定，以便我们可以调用外部函数(如printf、或exit等)。这些函数期望它们的参数在寄存器中。我们以后再担心这件事。</p><p> If we borrow and adapt the excellent diagrams from the Ghuloum tutorial, thismeans that right before we make a procedure call, our stack will look likethis:</p><p>如果我们借用并改编Ghuloum教程中的优秀图表，这意味着就在我们进行过程调用之前，我们的堆栈将如下所示：</p><p> Low address | ... | +------------------+ | ... | +------------------+ +-&gt; | arg3 | rsp-56 out | +------------------+ args| | arg2 | rsp-48 | +------------------+ +-&gt; | arg1 | rsp-40 +------------------+ | | rsp-32 +------------------+ +-&gt; | local3 | rsp-24 | +------------------+locals| | local2 | rsp-16 | +------------------+ +-&gt; | local1 | rsp-8 +------------------+ base | return point | rsp High address</p><p>低地址|...|+-++|...|+-++-&gt；|arg3|RSP-56输出|+-+参数||arg2|RSP-48|+。|arg1|rsp-40+-++||rsp-32+-&gt；|local3|rsp-24|+-+本地||local2|rsp-16|+-++-&gt；|local1|RSP-8+-+base|返回点|RSP高地址。</p><p>  You can see the first return point at  [rsp]. This is the return point placedby the caller of the  current function.</p><p>您可以在[RSP]处看到第一个返回点。这是当前函数的调用方放置的返回点。</p><p> Above that are whatever local variables we have declared with  let or perhapsare intermediate values from some computation.</p><p>上面是我们用let声明的任何局部变量，或者可能是来自某些计算的中间值。</p><p> Above that is a blank space reserved for the second return point. This is thereturn point for the  about-to-be-called function. The  call instruction willfill in after evaluating all the arguments.</p><p>其上方是为第二个返回点预留的空白区域。这是将要调用的函数的返回点。CALL指令将在评估所有参数后填写。</p><p> Above the return point are all the outgoing arguments. They will appear aslocals for the procedure being called.</p><p>返回点上方是所有传出参数。对于被调用的过程，它们将显示为本地人。</p><p>  The  call instruction decrements  rsp and then writes to  [rsp]. This meansthat if we just emitted a  call, the first local would be overwritten. Nogood. Worse, the way the stack would be laid out would mean that the localswould look like arguments.</p><p>CALL指令递减RSP，然后写入[RSP]。这意味着如果我们只是发出一个调用，第一个本地代码将被覆盖。不好。更糟糕的是，堆栈的布局方式将意味着本地将看起来像参数。</p><p> In order to solve this problem, we need to first adjust  rsp to point to thelast local. That way the decrement will move it below the local and the returnaddress will go between the locals and the arguments.</p><p>为了解决这个问题，我们需要首先调整RSP以指向最后一个本地。这样，减量会将其移到本地地址之下，返回地址将位于本地地址和参数之间。</p><p> After the  call instruction, the stack will look different. Nothing will haveactually changed, except for  rsp. This change to  rsp means that the calleehas a different view:</p><p>在CALL指令之后，堆栈看起来会有所不同。除了RSP，实际上什么都不会改变。对RSP的此更改意味着被调用方具有不同的视图：</p><p> Low address | ... | +------------------+ | ... | +------------------+ +-&gt; | arg3 | rsp-24 in | +------------------+ args| | arg2 | rsp-16 | +------------------+ +-&gt; | arg1 | rsp-8 +------------------+ base | return point | rsp +------------------+ | ~~~~~~~~~~~~ | +------------------+ | ~~~~~~~~~~~~ | +------------------+ | ~~~~~~~~~~~~ | +------------------+ | ~~~~~~~~~~~~ | High address</p><p>低地址|...|+-++|...|+-|arg3|RSP-24位于|+-+args||arg2|RSP-16|+。|arg1|RSP-8+-+BASE|返回点|RSP+-+|~|+-~|+-~|高位地址。</p><p>  The empty colored in spaces below the return point indicate that the values onthe stack are “hidden” from view, since they are above (higher addresses than) [rsp]. The called function will  not be able to access those values.</p><p>返回点下方空白处的彩色空白表示堆栈上的值是“隐藏”的，因为它们高于(高于)[RSP]的地址。被调用的函数将无法访问这些值。</p><p> If the called function wants to use one of its arguments, it can pull it offthe stack from its designated location.</p><p>如果被调用的函数想要使用其参数之一，它可以将其从其指定位置移出堆栈。</p><p> One unfortunate consequence of this calling convention is that Valgrind doesnot understand it. Valgrind cannot understand that the caller has placed dataon the stack specifically for the callee to read it, and thinks this is amove/jump of an uninitialized value. This means that we get some errors nowon these labelcall tests.</p><p>这个调用惯例的一个不幸后果是Valgrind不理解它。Valgrind无法理解调用方已专门将数据放在堆栈上以供被调用方读取，并认为这是未初始化值的移动/跳转。这意味着我们现在在这些标签调用测试中会遇到一些错误。</p><p> Eventually, when the function returns, the  ret instruction will pop thereturn point off the stack and jump to it. This will bring us back to theprevious call frame.</p><p>最后，当函数返回时，ret指令将从堆栈中弹出返回指针并跳转到堆栈。这将把我们带回到之前的呼叫框架。</p><p> That’s that! I have yet to find a good tool that will let me visualize thestack as a program is executing. GDB probably has a mode hidden away somewhereundocumented that does exactly this. Cutter sort of does, but it’s finicky inways I don’t really understand. Maybe one day  Kartik’sx86-64 Mu fork will be able to do this.</p><p>就是这样！我还没有找到一个好的工具，可以让我在程序执行时可视化堆栈。Gdb可能有一个隐藏在某个没有文档的地方的模式，它就是这样做的。卡特有点喜欢，但我真的不太明白它是怎么挑剔的。也许有一天卡地克的x86-64Mu叉会做到这一点。</p><p>  In order for this set of changes to make sense, I am going to explain all ofthe pieces one at a time, top-down.</p><p>为了使这组更改有意义，我将自上而下地逐一解释所有部分。</p><p> First, we’ll look at the new-and-improved  Compile_entry, which has beenupdated to handle the  labels form. This will do the usual Lisp entrypointsetup, some checks, and the aforementioned  jmp to the body of the code.</p><p>首先，我们将查看新的和改进的COMPILE_ENTRY，它已经进行了更新以处理标签表单。这将对代码体执行常见的Lisp entrypointsetup、一些检查和前面提到的JMP。</p><p> Then, we’ll actually look at compiling the  labels. This means going throughthe bindings one-by-one and compiling their  code objects.</p><p>然后，我们将实际了解一下如何编译标签。这意味着逐个检查绑定并编译它们的代码对象。</p><p> Then, we’ll look at what it means to compile a  code object. Hint: it’s verymuch like  let.</p><p>然后，我们将了解编译代码对象意味着什么。提示：它很像LET。</p><p> Last, we’ll tie it all together when compiling the body of the  labels form.</p><p>最后，我们将在编译Label表单的正文时将它们全部捆绑在一起。</p><p>  Most of this code is checking. What used to just compile an expression nowvalidates that what we’ve passed in at least vaguely looks like a well-formed labels form before picking it into its component parts: the  bindings andthe  body.</p><p>这段代码的大部分都在检查。过去只编译表达式的内容现在验证了，在将其放入其组成部分(绑定和正文)之前，我们传入的内容至少模糊地看起来像是格式良好的标签表单。</p><p> int  Compile_entry ( Buffer  * buf ,  ASTNode  * node )  {  Buffer_write_arr ( buf ,  kEntryPrologue ,  sizeof  kEntryPrologue );  assert ( AST_is_pair ( node )  &amp;&amp;  &#34;program must have labels&#34; );  // Assume it&#39;s (labels ...)  ASTNode  * labels_sym  =  AST_pair_car ( node );  assert ( AST_is_symbol ( labels_sym )  &amp;&amp;  &#34;program must have labels&#34; );  assert ( AST_symbol_matches ( labels_sym ,  &#34;labels&#34; )  &amp;&amp;  &#34;program must have labels&#34; );  // Jump to body  word  body_pos  =  Emit_jmp ( buf ,  kLabelPlaceholder );  ASTNode  * args  =  AST_pair_cdr ( node );  ASTNode  * bindings  =  operand1 ( args );  assert ( AST_is_pair ( bindings )  ||  AST_is_nil ( bindings ));  ASTNode  * body  =  operand2 ( args );  _ ( Compile_labels ( buf ,  bindings ,  body ,  /*labels=*/ NULL ,  body_pos ));  Buffer_write_arr ( buf ,  kFunctionEpilogue ,  sizeof  kFunctionEpilogue );  return  0 ; }</p><p>Int COMPILE_ENTRY(buffer*buf，ASTNode*node){buffer_write_arr(buf，kEntryPrologue，sizeof kEntryPrologue)；Assert(AST_IS_Pair(Node)&amp；&amp；#34；程序必须有标签)；//假定它(标签...)。ASTNode*labels_sym=AST_Pair_Car(Node)；Assert(AST_is_Symbol(Labels_Sym)&amp；&amp；&34；程序必须有标签&34；)；Assert(AST_Symbol_Matches(Labels_sym，&34；Labels&34；)&amp；&amp；&34；程序必须有标签&#34；)；//跳到正文单词body_pos=emit_jmp(buf，kLabelPlaceholder)；ASTNode*args=AST_Pair_Cdr(节点)；ASTNode*bindings=operand1(Args)；Assert(AST_IS_Pair(绑定)||AST_is_nil(绑定))；ASTNode*body=operand2(Args)；_(编译_标签(buf，绑定，body，/*labels=*/null，body_pos))；buffer_write_arr(buf，kFunctionEpilogue，sizeof kFunctionEpilogue)；return 0；}。</p><p> Compile_entry dispatches to  Compile_labels for iterating over all of thelabels.  Compile_labels is a recursive function that keeps track of all thelabels so far in its arguments, so we start it off with an empty  labelsenvironment.</p><p>COMPILE_ENTRY分派给COMPILE_LABEL以迭代所有标签。COMPILE_LABESTS是一个递归函数，它在其参数中跟踪到目前为止的所有标签，所以我们从一个空的标签环境开始。</p><p> We also pass it the location of the  jmp so that right before it compiles thebody, it can patch the jump target.</p><p>我们还将JMP的位置传递给它，这样在它编译正文之前，它就可以修补跳转目标。</p><p>  In  Compile_labels, we have first a base case: if there are no labels weshould just emit the body.</p><p>在COMPILE_LABEL中，我们首先有一个基本情况：如果没有标签，我们应该只发出主体。</p><p> int  Compile_labels ( Buffer  * buf ,  ASTNode  * bindings ,  ASTNode  * body ,  Env  * labels ,  word  body_pos )  {  if  ( AST_is_nil ( bindings ))  {  Emit_backpatch_imm32 ( buf ,  body_pos );  // Base case: no bindings. Compile the body  _ ( Compile_expr ( buf ,  body ,  /*stack_index=*/ - kWordSize ,  /*varenv=*/ NULL ,  labels ));  return  0 ;  }  // ... }</p><p>Int Compile_Labels(Buffer*buf，ASTNode*bindings，ASTNode*Body，Env*Labels，Word Body_pos){if(AST_is_nil(Bindings)){emit_backpatch_imm32(buf，body_pos)；//基本情况：无绑定。编译BODY_(COMPILE_EXPR(buf，body，/*STACK_INDEX=*/-kWordSize，/*varenv=*/null，labels))；返回0；}//...}。</p><p> We also patch the jump location to the position where we’re going to emit thebody of the  labels. In the base case with no labels, the jump would be alittle bit useless, since there would be no intervening code to jump over, butthat’s alright. In most cases, there will be bindings.</p><p>我们还将跳跃位置修补到要发射标签主体的位置。在没有标签的基本情况下，跳转有点没用，因为没有要跳过的中间代码，但这没什么。在大多数情况下，都会有绑定。</p><p> We pass in an empty  varenv, since we are not accumulating any locals alongthe way; only labels. For the same reason, we give a  stack_index of -kWordSize — the first slot.</p><p>我们传入一个空的varenv，因为我们一路上没有积累任何当地人；只有标签。出于同样的原因，我们给出了-kWordSize-第一个槽的STACK_INDEX。</p><p> If we  do have labels, on the other hand, we should deal with the first label.This means:</p><p>如果我们有标签，另一方面，我们应该处理第一个标签，即：</p><p>   int  Compile_labels ( Buffer  * buf ,  ASTNode  * bindings ,  ASTNode  * body ,  Env  * labels ,  word  body_pos )  {  // ....  assert ( AST_is_pair ( bindings ));  // Get the next binding  ASTNode  * binding  =  AST_pair_car ( bindings );  ASTNode  * name  =  AST_pair_car ( binding );  assert ( AST_is_symbol ( name ));  ASTNode  * binding_code  =  AST_pair_car ( AST_pair_cdr ( binding ));  word  function_location  =  Buffer_len ( buf );  // Bind the name to the location in the instruction stream  Env  entry  =  Env_bind ( AST_symbol_cstr ( name ),  function_location ,  labels );  // Compile the binding function  _ ( Compile_code ( buf ,  binding_code ,  &amp; entry ));  _ ( Compile_labels ( buf ,  AST_pair_cdr ( bindings ),  body ,  &amp; entry ,  body_pos ));  return  0 ; }</p><p>Int编译_Labels(Buffer*buf，ASTNode*绑定，ASTNode*Body，Env*Labels，Word Body_pos){//....。Assert(AST_IS_Pair(绑定))；//获取下一个绑定ASTNode*binding=AST_Pair_CAR(绑定)；ASTNode*name=AST_Pair_CAR(绑定)；Assert(AST_IS_Symbol(Name))；ASTNode*binding_code=AST_Pair_Car(AST_Pair_Cdr(绑定))；word function_location=buffer_len(Buf)；//将名称绑定到指令流环境条目=env_bind(AST_Symbol_CSTR(Name)，function_location，labels)；//编译绑定函数_(Compile_code(buf，binding_code，&amp；entry))；_(Compile_Labels(buf，AST_Pair_Cdr(Bindings)，body，&amp；entry，body_pos))；返回0；}。</p><p> It’s important to note that we are binding  before we compile the code object and we are making the code location available before it is compiled! Thismeans that  code objects can reference themselves and even recursively callthemselves.</p><p>重要的是要注意，我们在编译代码对象之前是绑定的，并且我们在编译之前使代码位置可用！这意味着代码对象可以引用它们自己，甚至可以递归地调用它们自己。</p><p> Since we then pass that binding into  labels for the recursive call, it alsomeans that labels can access all labels defined before them, too.</p><p>由于我们随后将绑定传递到标签以进行递归调用，因此标签也可以访问在它们之前定义所有标签。</p><p>   I split this into two functions: one helper that pulls apart  code objects (Ididn’t want to do that in  labels because I thought it would clutter themeaning), and one recursive function that does the work of putting theparameters in the environment.</p><p>我将其分成两个函数：一个是分离代码对象的帮助器(我不想在标签中这样做，因为我认为这样会使主题变得混乱)，另一个递归函数负责将参数放入环境中。</p><p> So  Compile_code just pulls apart the  (code (x y z ...) body) into theformal parameters and the body. Since  Compile_code_impl will need torecursively build up information about the  stack_index and  varenv, wesupply those.</p><p>因此COMPILE_CODE只是将(code(x y z...)。Body)转换为形式参数和Body。由于Compile_code_impl将需要递归地构建有关STACK_INDEX和varenv的信息，因此我们对其进行补充。</p><p> int  Compile_code ( Buffer  * buf ,  ASTNode  * code ,  Env  * labels )  {  assert ( AST_is_pair ( code ));  ASTNode  * code_sym  =  AST_pair_car ( code );  assert ( AST_is_symbol ( code_sym ));  assert ( AST_symbol_matches ( code_sym ,  &#34;code&#34; ));  ASTNode  * args  =  AST_pair_cdr ( code );  ASTNode  * formals  =  operand1 ( args );  ASTNode  * code_body  =  operand2 ( args );  return  Compile_code_impl ( buf ,  formals ,  code_body ,  /*stack_index=*/ - kWordSize ,  /*varenv=*/ NULL ,  labels ); }</p><p>Int编译_code(buffer*buf，ASTNode*code，Env*labels){ASSERT(AST_IS_Pair(Code))；ASTNode*code_sym=AST_Pair_Car(Code)；Assert(AST_IS_Symbol(Code_Sym))；Assert(AST_Symbol_Matches(code_sym，&#34；code&#34；))；ASTNode*args=AST_Pair_Cdr(Code)；ASTNode*formals=operand1(Args)；ASTNode*code_body=operand2(Args)；return CODE_IMPL(buf，formals，code_body，/*STACK_INDEX=*/-kWordSize，/*varenv=*/null，labels)；}。</p><p> I said this would be like  let. What I meant by that was that, like  letbodies, code objects have “locals” — the formal parameters. We have to bindthe names of the parameters to successive stack locations, as per our callingconvention.</p><p>我说这会像是出租。我的意思是，与letbody一样，代码对象也有“局部参数”--形式参数。根据我们的调用约定，我们必须将参数的名称绑定到连续的堆栈位置。</p><p> In the base case, we do not have any formals, so we compile the body:</p><p>在基本情况下，我们没有任何形式，所以我们编译正文：</p><p> int  Compile_code_impl ( Buffer  * buf ,  ASTNode  * formals ,  ASTNode  * body ,  word  stack_index ,  Env  * varenv ,  Env  * labels )  {  if  ( AST_is_nil ( formals ))  {  _ ( Compile_expr ( buf ,  body ,  stack_index ,  varenv ,  labels ));  Buffer_write_arr ( buf ,  kFunctionEpilogue ,  sizeof  kFunctionEpilogue );  return  0 ;  }  // ... }</p><p>Int build_code_impl(buffer*buf，ASTNode*formals，ASTNode*body，word stack_index，env*varenv，env*labels){if(AST_is_nil(Formals)){_(build_expr(buf，body，stack_index，varenv，labels))；buffer_write_arr(buf，kFunctionEpilogue，sizeof kFunctionEpilogue)；return 0；}//...}。</p><p> We also emit this function epilogue, which right now is just  ret. I got ridof the  push rbp/ mov rbp, rsp/ pop rbp dance because we switched to using rsp only instead. I alluded to this in the previous instruction encodinginterlude post.</p><p>我们也发出这个函数结语，现在它就是ret。我去掉了PUSH RBP/MOV RBP，RSP/POP RBP舞蹈，因为我们改为只使用RSP。我在之前的指令编码间歇帖子中提到了这一点。</p><p> In the case where we have at least one formals, we bind the name to the stacklocation and go on our merry way.</p><p>在我们至少有一个形式的情况下，我们将名称绑定到堆栈位置，然后继续我们的快乐之路。</p><p> int  Compile_code_impl ( Buffer  * buf ,  ASTNode  * formals ,  ASTNode  * body ,  word  stack_index ,  Env  * varenv ,  Env  * labels )  {  // ...  assert ( AST_is_pair ( formals ));  ASTNode  * name  =  AST_pair_car ( formals );  assert ( AST_is_symbol ( name ));  Env  entry  =  Env_bind ( AST_symbol_cstr ( name ),  stack_index ,  varenv );  return  Compile_code_impl ( buf ,  AST_pair_cdr ( formals ),  body ,  stack_index  -  kWordSize ,  &amp; entry ,  labels ); }</p><p>Int CODE_IMPL(Buffer*buf，ASTNode*Forals，ASTNode*Body，WORD STACK_INDEX，Env*varenv，Env*Labels){//...。Assert(AST_IS_Pair(Formal))；ASTNode*name=AST_Pair_Car(Formal)；Assert(AST_IS_Symbol(Name))；Env entry=Env_Bind(AST_Symbol_CSTR(Name)，stack_index，varenv)；return Compile_code_impl(buf，AST_air_Cdr(Formals)，body，stack_index-kWordSize，&amp；entry，labels)；}。</p><p>   What use are procedures if we can’t call them? Let’s figure out how to compileprocedure  calls.</p><p>如果我们不能调用这些程序，它们又有什么用呢？让我们了解一下如何编译过程调用。</p><p> Code for calling a procedure must put the arguments and return address on thestack precisely how the called procedure expects them.</p><p>调用过程的代码必须按照被调用过程期望的方式将参数和返回地址精确地放在堆栈上。</p><p> Getting this contract right can be tricky. I spent several frustrated hoursgetting this to not crash. Then, even though it didn’t crash, it returned baddata. It turns out that I was overwriting the return address by accident andreturning to someplace strange instead.</p><p>把这份合同做好可能会很棘手。我花了几个小时让它不会坠毁。然后，即使它没有崩溃，它也返回了错误数据。原来我是不小心重写了寄信人的地址，而是回到了一个陌生的地方。</p><p>  Making handmade diagrams that track the changes to  rsp and the stack really helps with understanding calling convention bugs.</p><p>制作跟踪RSP和堆栈更改的手工图表确实有助于理解调用约定错误。</p><p> We’ll start off by dumping yet more code into  Compile_call. This code willlook for something of the form  (labelcall name ...).</p><p>我们将从将更多代码转储到COMPILE_CALL开始。此代码将查找形式为(labelcall name...)的内容。</p><p>  arg_stack_index, which is the first place on the stack where args aresupposed to go. Since we’re skipping a space for the return address, this isone more than the current (available) slot index.</p><p>ARG_STACK_INDEX，这是堆栈上建议使用ARG的第一个位置。因为我们为返回地址跳过了一个空格，所以这比当前(可用)槽索引多一个空格。</p><p>  rsp_adjust, which is the amount that we’re going to have to, well, adjust rsp. Without locals from  let or incoming arguments from a procedure call,this will be  0. With locals and/or arguments, this will be the total amountof space taken up by those.</p><p>RSP_ADJUST，这是我们需要调整RSP的量。如果没有来自let的局部变量或来自过程调用的传入参数，则该值将为0。加上本地人和/或争论，这将是那些人占用的空间总量。</p><p>  int  Compile_call ( Buffer  * buf ,  ASTNode  * callable ,  ASTNode  * args ,  word  stack_index ,  Env  * varenv ,  Env  * labels )  {  // ...  if  ( AST_symbol_matches ( callable ,  &#34;labelcall&#34; ))  {  ASTNode  * label  =  operand1 ( args );  assert ( AST_is_symbol ( label ));  ASTNode  * call_args  =  AST_pair_cdr ( args );  // Skip a space on the stack to put the return address  word  arg_stack_index  =  stack_index  -  kWordSize ;  // We enter Compile_call with a stack_index pointing to the next  // available spot on the stack. Add kWordSize (stack_index is negative)  // so that it is only a multiple of the number of locals N, not N+1.  word  rsp_adjust  =  stack_index  +  kWordSize ;  return  Compile_labelcall ( buf ,  label ,  call_args ,  arg_stack_index ,  varenv ,  labels ,  rsp_adjust );  }  // ... }</p><p>INT COMPILE_CALL(Buffer*buf，ASTNode*Callable，ASTNode*args，WORD STACK_INDEX，Env*varenv，Env*Labels){//...。IF(AST_Symbol_Matches(Callable，&#34；labelcall&#34；)){ASTNode*Label=Operand1(Args)；Assert(AST_is_Symbol(Label))；ASTNode*call_args=AST_Pair_Cdr(Args)；//跳过堆栈上的空格以放置返回地址字arg_stack_index=stack_index-kWordSize；//我们输入COMPILE_CALL，其中STACK_INDEX指向堆栈上的下一个//可用位置。添加kWordSize(STACK_INDEX为负)//这样它只是本地变量N的倍数，而不是N+1.word RSP_ADJUST=STACK_INDEX+kWordSize；返回COMPILE_Labelcall(buf，label，call_args，arg_stack_index，varenv，labels，rsp_adjust)；}//...}。</p><p> Compile_labelcall is one of those fun recursive functions we write sofrequently. Its job is to compile all of the arguments and store their resultsin successive stack locations.</p><p>COMPILE_LABELCALL是我们软编写的有趣的递归函数之一。它的工作是编译所有参数，并将它们的结果存储在连续的堆栈位置。</p><p> In the base case, it has no arguments to compile. It should just adjust thestack pointer, call the procedure, adjust the stack pointer back, and return.</p><p>在基本情况下，它没有要编译的参数。它应该只是调整堆栈指针，调用过程，调整回堆栈指针，然后返回。</p><p> void  Emit_rsp_adjust ( Buffer  * buf ,  word  adjust )  {  if  ( adjust  &lt;  0 )  {  Emit_sub_reg_imm32 ( buf ,  kRsp ,  - adjust );  }  else  if  ( adjust  &gt;  0 )  {  Emit_add_reg_imm32 ( buf ,  kRsp ,  adjust );  } } int  Compile_labelcall ( Buffer  * buf ,  ASTNode  * callable ,  ASTNode  * args ,  word  stack_index ,  Env  * varenv ,  Env  * labels ,  word  rsp_adjust )  {  if  ( AST_is_nil ( args ))  {  word  code_address ;  if  ( ! Env_find ( labels ,  AST_symbol_cstr ( callable ),  &amp; code_address ))  {  return  - 1 ;  }  // Save the locals  Emit_rsp_adjust ( buf ,  rsp_adjust );  Emit_call_imm32 ( buf ,  code_address );  // Unsave the locals  Emit_rsp_adjust ( buf ,  - rsp_adjust );  return  0 ;  }  // ... }</p><p>Void emit_rsp_adjust(缓冲区*buf，字调整){if(adjust&lt；0){emit_sub_reg_imm32(buf，krsp，-adjut)；}ELSE if(adjust&gt；0){emit_add_reg_imm32(buf，krsp，adjust)；}}int Compile_labelcall(Buffer*buf，ASTNode*Callable，ASTNode*args，word stack_index，env*varenv，env*labels，word RSP_ADJUST){if(AST_is_nil(Args)){word code_address；if(！Env_find(labels，AST_Symbol_CSTR(Callable)，&amp；CODE_ADDRESS)){return-1；}//保存本地变量emit_rsp_adjust(buf，rsp_adjust)；emit_call_imm32(buf，code_address)；//取消保存本地变量emit_rsp_adjust(buf，-rsp_adjust)；return 0；}//...}。</p><p> Emit_rsp_adjust is a convenience function that takes some stack adjustmentdelta. If it’s negative, it will issue a  sub instruction. If it’s positive,an  add. Otherwise, it’ll do nothing.</p><p>Emit_rsp_adjust是一个方便的函数，它需要一些堆栈调整增量。如果它是负的，它将发出SUB指令。如果是正数，则为ADD。否则，它什么也做不了。</p><p>  int  Compile_labelcall ( Buffer  * buf ,  ASTNode  * callable ,  ASTNode  * args ,  word  stack_index ,  Env  * varenv ,  Env  * labels ,  word  rsp_adjust )  {  // ...  assert ( AST_is_pair ( args ));  ASTNode  * arg  =  AST_pair_car ( args );  _ ( Compile_expr ( buf ,  arg ,  stack_index ,  varenv ,  labels ));  Emit_store_reg_indirect ( buf ,  Ind ( kRsp ,  stack_index ),  kRax );  return  Compile_labelcall ( buf ,  callable ,  AST_pair_cdr ( args ),  stack_index  -  kWordSize ,  varenv ,  labels ,  rsp_adjust ); }</p><p>Int编译_labelcall(Buffer*buf，ASTNode*Callable，ASTNode*args，WORD STACK_INDEX，Env*varenv，Env*Labels，Word RSP_ADJUST){//...。Assert(AST_IS_Pair(Args))；ASTNode*arg=AST_Pair_Car(Args)；_(COMPILE_EXPR(buf，arg，stack_index，varenv，labels))；emit_store_reg_direct(buf，ind(krsp，stack_index)，krax)；return Compile_labelcall(buf，callable，AST_air_cdr(Args)，stack_index-kWordSize，varenv，labels，rsp_adjut)；}。</p><p> There, that wasn’t so bad, was it? I mean, if you manage to get it right thefirst time. I certainly did not. In fact, I gave up on the first version ofthis compiler many months ago because I could not get procedure calls right.With this post, I have now made it past that particular thorny milestone!</p><p>好了，这还不算太糟，不是吗？我是说，如果你第一次就做对了。我当然没有。事实上，我在几个月前就放弃了这个编译器的第一个版本，因为我不能正确地调用过程。有了这篇文章，我现在已经度过了那个特别棘手的里程碑！</p><p>   I won’t include all the tests in this post, but a full battery of tests isavailable in  compile-procedures.c. Here are some of them.</p><p>我不会在这篇文章中包含所有的测试，但是编译过程中提供了完整的测试。这是其中的一些。</p><p>  TEST  compile_code_with_two_params ( Buffer  * buf )  {  ASTNode  * node  =  Reader_read ( &#34;(code (x y) (+ x y))&#34; );  int  compile_result  =  Compile_code ( buf ,  node ,  /*labels=*/ NULL );  ASSERT_EQ ( compile_result ,  0 );  // clang-format off  byte  expected []  =  {  // mov rax, [rsp-16]  0x48 ,  0x8b ,  0x44 ,  0x24 ,  0xf0 ,  // mov [rsp-24], rax  0x48 ,  0x89 ,  0x44 ,  0x24 ,  0xe8 ,  // mov rax, [rsp-8]  0x48 ,  0x8b ,  0x44 ,  0x24 ,  0xf8 ,  // add rax, [rsp-24]  0x48 ,  0x03 ,  0x44 ,  0x24 ,  0xe8 ,  // ret  0xc3 ,  };  // clang-format on  EXPECT_EQUALS_BYTES ( buf ,  expected );  AST_heap_free ( node );  PASS (); }</p><p>Test CODE_CODE_WITH_TWO_PARAMS(Buffer*buf){ASTNode*node=Reader_Read(&#34；(code(X Y)(+x y))&#34；)；int COMPILE_RESULT=COMPILE_CODE(buf，node，/*labels=*/null)；ASSERT_EQ(CODE_RESULT，0)；//clang-format off byte预期[]={//mov rax，[rsp-16]0x48，0x8b，0x44，0x24，0xf0，//mov[rsp-24]，rax 0x48，0x89，0x44，0x24，0x24，0xe8，//mov rax，[rsp-8]0x48，0x8b，0x44，0x24，0xf8，//add rax，[rsp-24]0x48，0x03，0x44，0x24，0xe8，/ret/0xc3，}；//clang-format on expect_equals_bytes(buf，expred)；AST_HEAP_FREE(节点)；PASS()；}。</p><p> As expected, this takes the first argument in  [rsp-8] and second in [rsp-16], storing a temporary in  [rsp-24]. This test does not testexecution because I did not want to write the testing infrastructure formanually setting up procedure calls.</p><p>正如预期的那样，这采用[RSP-8]中的第一个参数和[RSP-16]中的第二个参数，将临时参数存储在[RSP-24]中。这个测试不测试执行，因为我不想编写测试基础设施正式地设置过程调用。</p><p>  TEST  compile_labels_with_one_label ( Buffer  * buf )  {  ASTNode  * node  =  Reader_read ( &#34;(labels ((const (code () 5))) 1)&#34; );  int  compile_result  =  Compile_entry ( buf ,  node );  ASSERT_EQ ( compile_result ,  0 );  // clang-format off  byte  expected []  =  {  // mov rsi, rdi  0x48 ,  0x89 ,  0xfe ,  // jmp 0x08  0xe9 ,  0x08 ,  0x00 ,  0x00 ,  0x00 ,  // mov rax, compile(5)  0x48 ,  0xc7 ,  0xc0 ,  0x14 ,  0x00 ,  0x00 ,  0x00 ,  // ret  0xc3 ,  // mov rax, 0x2  0x48 ,  0xc7 ,  0xc0 ,  0x04 ,  0x00 ,  0x00 ,  0x00 ,  // ret  0xc3 ,  };  // clang-format on  EXPECT_EQUALS_BYTES ( buf ,  expected );  Buffer_make_executable ( buf );  uword  result  =  Testing_execute_entry ( buf ,  /*heap=*/ NULL );  ASSERT_EQ_FMT ( Object_encode_integer ( 1 ),  result ,  &#34;0x%lx&#34; );  AST_heap_free ( node );  PASS (); }</p><p>Test COMPILE_LABEL_WITH_ONE_LABEL(Buffer*buf){ASTNode*node=Reader_Read(&#34；(labels((const(code()5)1)&#34；)；int COMPILE_RESULT=COMPILE_ENTRY(buf，node)；ASSERT_EQ(COMPILE_RESULT，0)；//clang-format off byte预期[]={//mov rsi，RDI 0x48，0x89，0xfe，//jmp 0x08 0xe9，0x08，0x00，0x00，0x00，//mov rax，编译(5)0x48，0xc7，0xc0，0x14，0x00，0x00，0x00，//ret 0xc3，//mov rax，0x2 0x48，0xc7，0xc0，0x04，0x00，0x00，0x00，//ret 0xc3，}；//clang-format on expect_equals_bytes(buf，expred)；buffer_make_executable(Buf)；uword result=TESTING_EXECUTE_ENTRY(buf，/*heap=*/null)；ASSERT_EQ_FMT(OBJECT_ENCODE_INTEGER(1)，RESULT，&#34；0x%lx&#34；)；AST_HEAP_FREE(节点)；PASS()；}。</p><p> This tests for a jump over the compiled procedure bodies (CHECK!), emittingcompiled procedure bodies (CHECK!), and emitting the body of the  labels form(CHECK!). This one we can execute.</p><p>这将测试是否跳过编译的过程主体(check！)、发出编译的过程主体(check！)和发出标签窗体的主体(check！)。这一次我们可以执行。</p><p>  TEST  compile_labelcall_with_one_param ( Buffer  * buf )  {  ASTNode  * node  =  Reader_read ( &#34;(labels ((id (code (x) x))) (labelcall id 5))&#34; );  int  compile_result  =  Compile_entry ( buf ,  node );  ASSERT_EQ ( compile_result ,  0 );  // clang-format off  byte  expected []  =  {  // mov rsi, rdi  0x48 ,  0x89 ,  0xfe ,  // jmp 0x06  0xe9 ,  0x06 ,  0x00 ,  0x00 ,  0x00 ,  // mov rax, [rsp-8]  0x48 ,  0x8b ,  0x44 ,  0x24 ,  0xf8 ,  // ret  0xc3 ,  // mov rax, compile(5)  0x48 ,  0xc7 ,  0xc0 ,  0x14 ,  0x00 ,  0x00 ,  0x00 ,  // mov [rsp-16], rax  0x48 ,  0x89 ,  0x44 ,  0x24 ,  0xf0 ,  // call `id`  0xe8 ,  0xe9 ,  0xff ,  0xff ,  0xff ,  // ret  0xc3 ,  };  // clang-format on  EXPECT_EQUALS_BYTES ( buf ,  expected</p><p>Test build_labelcall_with_one_param(buffer*buf){ASTNode*node=Reader_Read(&#34；(labels((id(code(X)x)(Labelcall Id 5))&#34；)；int Compile_Result=Compile_Entry(buf，node)；assert_EQ(Compile_Result，0)；//clang-要求的格式关闭字节[]={//mov rsi，RDI 0x48，0x89，0xfe，//jmp 0x06 0xe9，0x06，0x00，0x00，0x00，//mov rax，[rsp-8]0x48，0x8b，0x44，0x24，0xf8，//ret 0xc3，//mov rax，编译(5)0x48，0xc7，0xc0，0x14，0x00，0x00，0x00，//mov[RSP-16]，rax 0x48，0x89，0xf8，//ret 0xc3，//mov rax，编译(5)0x48，0xc7，0xc0，0x14，0x00，0x00，0x00，//mov[RSP-16]。0x24，0xf0，//调用`id`0xe8，0xe9，0xff，0xff，0xff，//ret 0xc3，}；//clang-Expect_EQUALS_BYTES上的格式(buf，期望。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bernsteinbear.com/blog/compiling-a-lisp-11/">https://bernsteinbear.com/blog/compiling-a-lisp-11/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rsp/">#rsp</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031619.html"><img src="http://img2.diglog.com/img/2020/10/thumb_99f2142c0124e0d0a756ac05f1257d4d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031619.html">Eslisp-ECMAScript/JavaScript的S表达式语法，带有类似Lisp的宏</a></div><span class="my_story_list_date">2020-10-28 5:7</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031022.html"><img src="http://img2.diglog.com/img/2020/10/thumb_6e4f4bad7bb9be861f0eccbbc527e64d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031022.html">罗马工具链：Linter、编译器、绑定器等</a></div><span class="my_story_list_date">2020-10-25 7:32</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030829.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b71f23a653e4ac6df1ae71037508c3c3.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030829.html">我自己的编译器基础结构上的我自己的C编译器</a></div><span class="my_story_list_date">2020-10-24 7:31</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030633.html"><img src="http://img2.diglog.com/img/2020/10/thumb_21054de7abd23919431e2a8a7caa1f96.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030633.html">使用Bakeware将Elixir应用程序编译为单个可执行的二进制文件</a></div><span class="my_story_list_date">2020-10-23 2:54</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>