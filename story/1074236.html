<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>LTE上行链路的解调</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">LTE上行链路的解调</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 16:33:21</div><div class="page_narrow text-break page_content"><p>我一直在播放一些LTE录音来复习我的知识，因为这不是一个我非常熟悉的协议。我对理解所有导频信号的结构和特性特别感兴趣。教科书和文档都很棒，但没有什么比用一些IQ记录弄脏你的手更能确保你理解所有细节了。</p><p>为了解决这个问题，我把手机放在一个没有天线的USRP B205mini旁边，录制了一些视频。录制时，我在播放Youtube视频或浏览网页，以获得一些流量。下面可以看到其中一段录音的瀑布。在本文中，我们将了解如何解调突出显示的部分，该部分包含占用15个资源块的7 ms PUSCH（物理上行链路共享信道）以及相应的DMRS（解调参考信号）符号。这篇文章假设读者对OFDM有一定的了解，但不需要了解LTE的任何知识，因此对于那些对LTE有兴趣的人来说，这篇文章非常有用。</p><p>录音可以在这里找到。它是SigMF文件LTE_上行链路_847MHz_2022-01-30_30720ksps。它包含以30.72毫秒每秒记录的886毫秒数据，比我们将在这里看到的要多得多（事实上，一开始就有一个PRACH）。在这段录音中，我的手机恰好使用了20波段。具体来说，是847 MHz的10 MHz通道。解调是在使用NumPy的Jupyter笔记本中完成的。</p><p>描述LTE信号如何被调制的文档是3GPP TS 36.211。我觉得这篇文档有点难读，因为它经常一次处理许多特殊情况（这取决于大量参数），并且不清楚大多数情况下使用的是哪种情况。还有其他一些在线参考资料可以很好地总结材料，并且有一些非常有用的图表。例如，这是来自Keysight的。然而，这些通常不够详细，因此需要通读3GPP文档。</p><p>除某些特殊情况外，LTE信号是使用15khz载波间隔的OFDM调制。LTE打算使用20 MHz带宽信号的30.72 Msps采样时钟，因此根据该时钟速率下的采样定义定时参数。一个符号的有效时间约为66.666 us（15 kHz的倒数），或2048个样本（因此，OFDM DFT可以实现为这种大小的FFT，即二的幂）。</p><p>持续时间的基本单位是一个时隙，持续时间为0.5毫秒，由7个OFDM符号组成。第一个符号使用160个样本（约5.2 us）的循环前缀，而其余符号使用144个样本（约4.7 us）的循环前缀。我们可以检查计算结果，因为7*2048+160+6*144给出15360个样本，正好是0.5毫秒。在时频方面，分配是根据资源块完成的，资源块的持续时间为一个时隙，频率跨度为12个子载波。</p><p>上行链路中的主信道是PUSCH（物理上行链路共享信道），用于将数据从用户设备（电话）发送到eNodeB（基站）。在PUSCH的一个时隙中，前3个符号使用QPSK、16QAM或64 QAM来携带数据，中间的符号是DMRS（解调参考信号），它是用于同步和均衡的导频信号，最后3个符号也携带数据。</p><p>PUSCH的数据符号使用SC-FDMA，而DMRS使用常规OFDMA。SC-FDMA调制通常用预编码器来解释。如果我们将\（M \）个连续子载波分配给我们的UE（用户设备），在OFDMA中，我们将采用\（M \）个QPSK（或QAM）符号，并计算它们的逆傅里叶变换以获得相应的时域OFDM符号（考虑到未分配给我们的UE的OFDM子载波应为零）。这通常是通过对\（M\）符号进行零填充来获得2048个元素的向量（根据分配的\（M\）子载波进行零填充），然后执行2048点逆DFT。在SC-FDMA中，在执行此步骤之前，我们使用一个预编码器，它只是一个\（M \）点DFT。这意味着我们计算QPSK（或QAM）符号的\（M \）点DFT，然后使用该输出以与OFDMA相同的方式使用逆傅里叶变换生成OFDM符号。接收器将使用\（M \）点反向DFT撤销预编码器的操作。</p><p>下面是解释SC-FDMA的另一种方式，我认为它更清楚地说明了发生了什么以及它为什么有用。SC-FDMA符号基本上由\（M \）个时域QPSK（或QAM）符号组成，它们以\（15 M \）kbaud的速率作为PAM波形一个接一个地传输。用于这些符号的脉冲形状使得它们占据分配给我们的UE的OFDMA子载波的频谱，并且更重要的是，使得这些符号与由其他UE发送的符号正交，这些UE具有分配的其他不相交的OFDMA子载波集。与任何OFDM符号一样，SC-FDMA符号具有循环前缀，可以以通常的方式用于信道均衡。这个循环前缀由在第一个符号之前发送的最后几个（M）QPSK（或QAM）时域符号组成。</p><p>与OFDMA相比，SC-FDMA的优势在于其PAPR（峰均功率比）小得多。原因是SC-FDMA本质上是一种时域PAM波形，因此其PAPR适中。另一方面，当许多子载波碰巧在相位上对齐时，普通OFDM会出现巨大的峰值。因此，在LTE上行链路中使用SC-FDMA，因为它更容易有效地放大，这对于电池供电的UE很重要，因为它们有能量限制。</p><p>通过适当的时频分辨率，可以区分SC-FDMA PUSCH符号和OFDMA DMRS符号，因为它们在瀑布中的纹理不同。下图显示了一个示例，使用光标描绘第一个插槽中的7个符号。中间的符号是DMRS，可以看到它的纹理更规则，看起来几乎像一个图案。这种对比也可以在接下来的时段中看到。</p><p>通常，解调OFDM的第一步是实现与符号的粗时间同步。否则，我们所做的FFT可能会占用一个符号的后半部分和下一个符号的前半部分，结果将是垃圾。</p><p>这里我假设我们已经有了粗略的频率同步，在子载波间隔的一小部分之内。如果没有，我们还需要找到一种方法来估计载波频率偏移。在我们的例子中，这并不是真正需要的，因为在847 MHz下，对于参考值精确到几ppm的设备，频率误差将为几kHz。15 kHz的LTE子载波间隔通常会比这个大得多。</p><p>然而，我们需要考虑LTE上行链路的子载波的铺设，以便在DC处没有子载波。中心副载波为+7.5 kHz和-7.5 kHz。更正式地说，对于整数\（n \），上行链路子载波处于\（（n+1/2）\Delta f\），其中\（\Delta f=15 \）kHz是子载波间隔。通常使用FFT的OFDM解调在DC处有一个子载波，或者换句话说，假设子载波在整数处为\（n \δf \）。因此，为了解释这种差异，我们将我们的IQ记录向上移动了7.5 kHz，因此-7.5 kHz的子载波现在被置于DC。等效地，我们假设我们的信号从-7.5 kHz的载波频率偏移开始。</p><p>由于我们正在手动分析上行链路的记录，我们需要做一些与接收上行链路的eNodeB有所不同的事情。事实上，考虑到传播延迟，ue负责它们的传输，以便它们在正确的时刻到达eNodeB。在这个意义上，LTE上行链路在下行链路方面是同步的。eNodeB不需要执行粗略的时间同步。符号必须已经同步到eNodeB。正因为如此，LTE上行链路实际上没有用于粗符号同步的结构，所以我们需要有点创造性。</p><p>在这种情况下，粗同步很容易，因为我们试图同步到PUSCH传输的开始。之前没有信号，所以我们可以检测到这个开始。另一种方法是利用瀑布中可以看到DMRS符号的事实，因此通过观察它，我们可以大致了解DMRS符号何时开始，这为我们提供了所有其他符号的时间。事实上，这就是我在上图中对齐标记的方式。这种技术甚至可以在PUSCH传输的中间使用。</p><p>然而，我将使用的技术是我所说的穷人的施密德尔&amp；考克斯算法。施密德尔和；Cox算法需要精心编制的“前导”OFDM符号，以便在时域中，有用符号的前半部分等于有用符号的后半部分。由于所有偶数子载波都具有此周期性，因此仅使用偶数子载波即可实现此特性。当我们有这样一个“前导”符号时，我们可以计算相关\[C（t）=\int_0^{t_/2}x（t+s）\overline{x（t+t_/2+s）}，ds，\]，其中\（t_\）表示有用的符号长度，\（x（t）\）表示接收到的波形。当\（t\）等于每个“前导”符号的有用符号的开始时，这种相关性将达到峰值。它的工作方式是尝试将符号的前半部分与其后半部分相关联，当这两部分相等时，这会给出一个很大的值。</p><p>如果我们的OFDM波形没有这些周期性的“前导”符号，我们仍然可以通过依赖循环前缀来使用相同的想法。这在灵敏度方面效果不太好，因为循环前缀通常比\（t_/2）\）短得多，但仍然可以在良好的信噪比下工作。我们计算的相关性是\[\widetilde{C}（t）=\int_0^{t_{cp}}x（t+s）\overline{x（t+t_u+s）}，ds，\]，其中\（t_{cp}）表示循环前缀的长度。由于循环前缀完全重复符号末尾发生的事情，因此当\（t\）等于每个符号循环前缀的开头时，这种相关性将达到峰值。</p><p>将此技术应用于我们的PUSCH传输的结果如下所示。波形\（x（t）\）在第一个PUSCH符号之前开始，所以我们不会错过它的开始。</p><p>我们实际上可以在图中看到三种不同的振幅水平。开始时，振幅非常小，因为\（x（t）\）和\（x（t+t_）\）都在脉冲传输开始之前，所以它们只包含小振幅的噪声。然后我们可以看到振幅的小幅度增加，当\（x（t+t_）\）到达第一个符号，但\（x（t）\）仍然是小振幅噪声时，就会发生这种情况。最后，\（x（t）\）到达第一个符号，我们可以看到循环前缀产生的峰值。由于\（x（t）\）和\（x（t+tu）\）都包含OFDM信号的片段，因此即使没有峰值，相关性的振幅现在也更大。</p><p>我们在图中看到的峰值对应于每个循环前缀的开头，因此我们可以使用它们来计数符号。通过一些努力，我们甚至可以分辨出每7个符号中的第一个符号稍长（因为它的循环前缀稍长）。</p><p>上面的数字是在没有载波频率误差的情况下得到的，所以在某种意义上，我们仍然在使用教科书中的“假设信号是同步的”技巧。当我们有载波频率错误时会发生什么？如果我们将\（x（t）\）替换为\（e^{2\pi i f t}x（t）\），我们会看到\（\widetilde{C}（t）\）简单地乘以一个因子\（e^{-2\pi i f t}）。因此，我们仍然可以得到相同振幅的相关峰，但它们不再是真实的正相关峰。它们的相位表示频率误差（以载波频率间隔（1/T_）为模），所以作为奖励，这个可怜的人的施密德&amp；Cox还可以用于实现相当精确的频率同步（通常的Schmidl&amp；Cox算法也是如此）。</p><p>下图显示了在存在2 kHz频率误差的情况下相关性的样子。现在，相关峰的相位应该是-48度角，但如果我们采用相关的复模，我们仍然可以很容易地检测到峰值。</p><p>对第一个相关峰的详细观察（回到没有频率误差的情况）表明，由于噪声，精确定位峰值顶点并不容易。因此，我们用这种方法实现的同步不是很精确。也许我们会有几微秒的误差。同样的问题也发生在普通的Schmidl&amp；考克斯算法。</p><p>从穷人的施密德尔&amp；考克斯，我们现在可以尝试解调SC-FDMA PUSCH符号。SC-FDMA符号的解调以与任何常规OFDM符号相同的方式开始。我们采集2048个样本，我们认为这些样本与符号的有效时间最吻合，并执行2048点FFT。现在我们需要选择对应于SC-FDMA符号占用的子载波的\（M \）FFT单元，并执行\（M \）点IFFT。这将为我们提供SC-FDMA符号中的\（M \）QPSK（或QAM）符号载体。</p><p>当符号完全同步时，这一切都很好。然而，当存在同步错误时，情况并非如此，因此花一些时间思考这些错误如何影响SC-FDMA符号是值得的。粗略地说，由于额外的DFT，与常规OFDM相比，情况正好相反。</p><p>首先，需要说明的是，在执行撤销预编码操作的\（M \）点IFFT之前，不可能判断同步。事实上，如果我们考虑预编码器的功能，它会从QPSK（或QAM）星座中提取\（M \）个符号（我们可以假设符号是随机选择的），并计算它们的DFT。结果接近于从不相关的复杂高斯分布中提取的\（M \）个样本。从这个意义上讲，预编码器输出看起来像AWGN。下图显示了在执行\（M \）点IFFT之前，我们的第一个PUSCH符号的组合。事实上，这个符号是完全同步的，但从这个情节中不可能分辨出来。</p><p>了解同步错误如何影响SC-FDMA的“硬”方法使用了预编码器的定义，如下所示。首先假设我们有一个STO（符号时间偏移）。在解调OFDM符号后，我们得到了相位与频率的斜率。现在我们执行\（M \）点IFFT。这将相位与频率的斜率转换为其输出的循环移位。通常，移位量不是整数个采样数。这意味着每个QPSK（或QAM）符号都会与它的一个相邻符号混合（实际上是与所有相邻符号混合，这是由于分数延迟的工作原理）。这是ISI（符号间干扰），我们得到了一个看起来像垃圾的星座。</p><p>另一方面，假设我们有一个CFO（载波频率偏移）。这意味着我们的解调FFT与OFDM子载波没有很好地对齐。如果这是一个常规的OFDM符号，相邻子载波（携带不同的QPSK或QAM符号）的内容将通过FFT混合，我们将得到ISI。我们可以将CFO理解为频域中的分数偏移，即混合相邻载波。对于SC-FDMA符号，在进行\（M \）点FFT后，频域中的这种偏移几乎转化为时域中的调制（“几乎”是因为偏移不是循环的）。这种调制是最终QPSK（或QAM）符号中的相位与时间斜率。这并不像ISI那么糟糕，而且我们可以测量这个斜率，并用它来估计和修正首席财务官。</p><p>我发现，将SC-FDMA视为时域PAM调制，更容易得出相同的结论。如果我们有一个STO，那么我们将得到ISI，除非我们的STO恰好接近整数个时域符号。请注意，时域符号相当短，因为它们的持续时间是\（T_/M\）。在我们的例子中，正如我们将看到的，PUSCH信号占用\（M=180\）子载波，因此时域符号持续时间约为0.37 us，或11.37个样本。如果我们有一个CFO，那么时域符号的相位PAM符号会随着时间的推移而变化，因此我们可以得到一个相位与时间的斜率，从中我们可以估计CFO。</p><p>仅通过查看SC-FDMA PUSCH符号就很难实现足够精确的时间同步。原因是，虽然很容易确保STO接近时域PAM符号长度\（T_/M \）的整数倍，否则星座将有严重的ISI，看起来非常糟糕，但很难确保STO确实接近零，或者换句话说，我们没有通过几个时域符号来滑动我们的同步。</p><p>事实上，在这里，循环前缀的存在并没有帮助。如果我们向后滑动同步一个符号，我们将把循环前缀的最后一个时域符号作为第一个符号。星座将是正确的，除了QPSK（或QAM）符号将被循环移位一个位置之外，一切都将看起来很棒。当我们试图解释数据时，这将是灾难性的。另一方面，如果我们向前滑动同步一个符号，那么我们将丢弃第一个时域符号，并将下一个OFDM符号的循环前缀的开头作为最后一个时域符号。发生的情况取决于循环前缀长度是否接近整数个时域符号（即\（T_{cp}M/T_ \）是否接近整数），以及下一个OFDM符号是否实际上是使用相同子载波的PUSCH符号（例如，它可能是DMRS符号）。所有这些都将确定最后一个时域符号是从下一个PUSCH符号提取的完全有效的QPSK（或QAM）符号，是来自下一个PUSCH符号的两个QPSK（或QAM）符号的ISI混合，还是仅仅是垃圾。</p><p>出于这些原因，建议使用DMRS符号进行精细时间同步。我们将在下面这样做。否则，从SC-FDMA PUSCH符号中获得干净的QPSK（或QAM）星座并不困难，但数据可能会被篡改。</p><p>作为对同步讨论的演示，下图显示了当所有东西都同步良好时，我们的第一个PUSCH符号的星座。我们还调整了信号的振幅和相位，以使QPSK符号位于其预期位置。</p><p>下面的数字显示了当我们只引入一个时间偏移样本（~0.033 us）时会发生什么。这是非常明显的，因为我们开始获得重大的ISI。</p><p>只有3个样本（~0.098 us）的时间偏移，ISI是如此严重，以至于星座是垃圾。回想一下，在我们的例子中，时域PAM符号的长度是11.37个样本，所以这里我们要看的是时域符号的26%的同步错误。</p><p>然而，如果我们继续增加STO，当我们到达11个样本的偏移量，接近时域PAM符号时，星座看起来又好了。星座的相位发生了旋转，因为子载波的分配不以DC为中心，所以延时也会给我们带来相位旋转。然而，由于我们不知道信号的相位，我们不能使用这个相位旋转来检测我们是时域PAM符号关闭。这清楚地表明，仅仅通过查看PUSCH符号，我们就可以得到一个干净的QPSK星座，但不能确保正确的时间同步。</p><p>请注意，在这种情况下，样本是时域PAM符号（8.8%）中相对较小的一部分，因此我们可以通过使用样本数为整数的延迟来获得良好的同步。如果PU</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/上行/">#上行</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lte/">#lte</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/符号/">#符号</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>