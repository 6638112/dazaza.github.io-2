<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>动态Ftrace滤波</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">动态Ftrace滤波</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-09-22 17:44:24</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/9/8d058e8dadd7acf5558e749320cc5328.png"><img src="http://img2.diglog.com/img/2020/9/8d058e8dadd7acf5558e749320cc5328.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>如果您曾经检查过正在运行的Linux内核，您可能听说过ftrace。它是用于跟踪内核中的流和事件的令人惊叹的工具，并且非常通用-但是如果它不支持您的用例怎么办？</p><p>最近，在进行研究时，我想遵循一个特定的内核代码流：我即将修改现有内核机制的行为，我需要了解不同函数之间的数据流。</p><p>与您试图分析的任何开放源码项目一样，您的导航助手就是源代码。Linux除了是开源的，还提供了大量用于调试的动态工具，它们是对代码静态阅读的一个很好的补充。在这篇文章中，我将重点介绍其中的一个工具，ftrace，并介绍我对其进行的修改，以使其过滤功能更加通用。</p><p>从根本上说，ftrace(Function Tracer，函数跟踪器)是一个动态函数插装基础设施。它可用于设置几乎所有内核函数的动态跟踪，还支持大量用于记录核心内核事件的静态跟踪点。它在大多数现代Linux发行版中都可用。</p><p>它是跟踪内核中的流和事件的强大工具。它通过tracefs提供内核内API和用户模式控制接口，可以说是Linux中最全面的跟踪工具之一。</p><p>Ftrace有多种操作模式，在本文中我将重点介绍function_graph模式：它允许您递归地记录源自给定函数的调用图。</p><p>如果您从未使用过它(或者只是稍微提醒一下)，下面是跟踪/proc/version上的vfs_read调用的内核路径时它的外观：</p><p>8)|vfs_read(){8)|rw_Verify_Area(){8)|SECURITY_FILE_PERMISSION(){8)|APPLMOR_FILE_PERMISSION(){8)|COMMOR_FILE_PERM(){8)0.110 us|aa_file_perm()；8)0.322 us|}8)0.483 us|}8)0.079 us|__fsfy_parent()；8)0.082 us|fsfy()；8)1.004 us|}8)1.180 us|}8)|__vfs_read(){8)|proc_reg_read(){8)|seq_read(){8)0.106 us|rcu_all_qs()；8)|kvmalloc_node(){8)|__kmalloc_node(){8)0.099 us|kmalloc_slet()；8)0.086 us|rcu_all_qs()；8)0.098 us|应该失败板()；8)0.128 us|memcg_kmem_get_cache()；8)0.092 us|memcg_kmem_put_cache()；8)1.562 us|}8)1.743 us|}8)0.089 us|Single_Start()；8)|version_proc_show(){8)|seq_printf(){8)0.836 us|seq_vprintf()；8)1.004美元|}8)1.158美元|}....</p><p>这不是ftrace的入门指南，所以我假设您从现在开始了解它的基础知识。如果您想详细介绍ftrace及其附加模式，我建议您阅读[1]、[2]和[3]中的文章。</p><p>回到这里，我试图了解特定TCP数据包的接收流(它通过哪些函数)。</p><p>TCP接收入口点函数是tcp_v4_rcv。我们可以使用Function_Graphit，但是我们很快就会遇到一个问题--有大量数据是通过图形跟踪该函数生成的：在我的桌面上，在网络负载不是很重的情况下，我得到了一个5MB/s的跟踪文件！这是大量的数据。</p><p>调用没有经过任何过滤-所有调用都写入跟踪文件。我希望查看特定数据包上的tcp_v4_rcv图，而不是系统处理的所有TCP数据包上的tcp_v4_rcv图。</p><p>没有附加到调用的信息(例如，函数参数)。请看上面的样例图-只有函数名和持续时间。我们如何区分“有趣”的电话呢？</p><p>让我们向现有的ftrace特性寻求帮助。为此，我们可以从非常长的文档开始。</p><p>Ftrace可以记录当前的PID/TGID和命令(/proc/pid/comm)，并在跟踪文件中上报。据我所知，没有更多具体的细节可以记录在每个条目上。</p><p>Ftrace还支持按PID过滤：使用set_ftrace_pid文件，我们可以将跟踪的调用限制到特定进程。例如，这将限制对初始化进程的跟踪：</p><p>听起来不错，是吧？对于许多过滤用例，这就足够了：一个简单的程序将其PID写入set_ftrace_pid，然后调用一些您希望跟踪的内核代码。</p><p>在网络RX的情况下，这是不可能的⁴：网络数据包是在软件中断⁵中处理的，这些中断可能在任何cpu上运行，几乎在系统的任何线程的上下文中运行。开始使用PID…进行过滤。</p><p>我不知道ftrace还允许任何其他复杂的过滤器。我们可以尝试从外部过滤掉事件(例如，在网络RX的情况下-使用iptables过滤掉不需要的数据包，这样它们就不会在tcp_v4_rcv中结束)…。</p><p>我的想法是：ftrace具有基于PID的过滤。我可以提供外部过滤，在调用之后，我希望跟踪通过我的过滤器，可以将当前运行的进程的PID“添加”到set_ftrace_filter，从而有效地跟踪该进程(并且我将获得我想要的调用图)。</p><p>当您写入set_ftrace_pid时会发生什么情况？快速搜索该字符串会得到ftrace_init_tracefs，它注册tracefs文件；而ftrace_pid_write实际上实现了写入。</p><p>Ftrace_pid_write相当长，因为它的目的似乎很简单。综上所述，此函数做3件事：</p><p>从输入PID创建TRACE_PID_LIST结构(您可以编写多个PID以进行跟踪)，并将其存储以供以后使用。</p><p>实际上，第三步启用了过滤。Ftrace_pid_func非常简单：调用它而不是原来的跟踪处理程序，并通过读取tr-&gt；trace_buffer.data-&gt；ftrace_ignore_pid.检查是否应该跟踪当前任务。如果(且仅当)应该执行跟踪，它将调用原始处理程序。</p><p>让我们看看这个字段在哪里更新。Ftrace_pid_write之前已为sched_switch事件注册了ftrace_filter_pid_sched_switch_Probe。系统中的每个任务切换都将调用此处理程序。它知道下一个要运行的任务。</p><p>Static void ftrace_filter_pid_sched_switch_Probe(void*data，bool preempt，struct task_struct*prev，struct task_struct*next){struct TRACE_ARRAY*TR=data；struct trace_PID_list*PID_LIST；PID_LIST=rcu_dereference_sched(TR-&&gt;；Function_PID)；this_cpu_write(tr-&gt；trace_buffer.data-&gt；ftrace_ignore_pid，TRACE_IGNORE_THIS_TASK(PID_LIST，NEXT)；}。</p><p>它调用TRACE_IGNORE_THIS_TASK来查看是否将新任务的PID标记为要跟踪：</p><p>Bool trace_Ignore_this_task(struct trace_PID_list*filtered_pids，struct task_struct*task){/**返回FALSE，因为如果filtered_pid不存在，*所有PID都可以跟踪。*/If(！filtered_PIDS)返回FALSE；RETURN！TRACE_FIND_FIRTED_PID(FIRTED_PIDS，TASK-&gt；PID)；}。</p><p>结果被写入FTRACE_IGNORE_PID字段，该字段本身是一个PERPU⁶变量。这是一种缓存优化：不是每当任务命中跟踪函数时过滤列表中的PID，而是在任务切换时执行一次PID检查，稍后的跟踪决策仅仅是对该单个布尔值的缓存读取。干净利落，也是一个很好的使用PERPU的方法！下次调用ftrace_filter_pid_sched_Switch_Probe时，结果将自动失效，这将为下一个任务写入新值。</p><p>我想我们知道的够多了。如果我们可以更新PERPU ftrace_IGNORE_PID，我们就可以控制是否为当前CPU启用跟踪。如果我们可以在我们想要开始跟踪时设置它，在我们想要停止时取消它，我们可以使用它来随意限制过滤。</p><p>所以，我开始在我的测试机器上编写一个内核模块来解决这个问题。很短的时间内，我回想起我为Linux内核⁷开发的MicroPython端口就是为了这样的场合！使用它，我们可以快速定义几个完成工作的钩子。</p><p>我们的目标：给定一个与前提条件匹配的输入TCP数据包(比方说，目标端口是9000)，我们希望获得其tcp_v4_rcv的ftrace调用图。</p><p>我们将从一个钩子开始，它将对数据包进行实际过滤。它必须在ftrace-graph之前调用，否则我们将无法控制过滤！如果我将tcp_v4_rcv本身与ftrace挂钩，它将在ftrace-graph过滤决策之后运行，这对我们来说太晚了。我确信有办法绕过它，但我没有费心检查-相反，我挂钩了tcp_protocol-&gt；处理程序指针，该指针用于调用tcp_v4_rcv。这样，我们肯定会被召唤到它之前。</p><p>Def my_pre_tcp_v4_rcv(SKB)：#TODO：进行过滤...。Return tcp_v4_rcv(SKB)cb=callback(My_Pre_Tcp_V4_Rcv)net_protocol_s=part_struct(&#34；net_protocol&#34；)net_protocol_s(Tcp_Protocol).handler=cb.ptr()。</p><p>此时，我们有了sk_buff，可以做出跟踪决策了。如果我们想要追踪，我们可以写信给tr-&gt；trace_buffer.data-&gt；ftrace_ignore_pid…。遗憾的是，它不在导出的标题中。</p><p>我希望这与标准内核头完全兼容，因此访问未导出的结构不是一个好主意。一种解决方法是将TRACE_IGNORE_THIS_TASK与一个简单的处理程序挂钩，该处理程序只为我们跟踪的任务返回1。然后，我们可以调用ftrace_filter_pid_sched_switch_Probe，就好像发生了调度程序切换一样。它将更新当前任务的跟踪状态-由于我们强制TRACE_IGNORE_THIS_TASK()返回1，因此当前任务将被标记为要跟踪。</p><p>TRACE_TASK=NONE定义MY_TRACE_IGNORE_THIS_TASK(ORIG，FILTERED_PIDS，TASK)：如果TASK==TRACE_TASK ELSE 1 KP=kProbe(&#34；TRACE_IGNORE_THIS_TASK&#34；，KP_ARGS_MODIFY，MY_TRACE_IGNORE_THER_TASK)定义MY_PRE_tcp_v4_rcv(Skb)：GLOBAL TRACE_TASK#在此处插入筛选...#要启用跟踪：TRACE_TASK=CURRENT()ftrace_filter_pid_sched_switch_probe(global_trace，FALSE，NONE，CURRENT())返回tcp_v4_rcv(Skb)。</p><p>有趣的轶事：ftrace不允许在ftrace自己的代码上放置挂钩(例如trace_IGNORE_THIS_TASK)。但是您可以放置kProbe挂钩，这些挂钩有时由ftrace支持，但在本例中，它们不是有用的：)。</p><p>使用这两个钩子，我可以启用基于输入sk_buff的过滤。此处提供了最终的代码片段：</p><p>可以将其粘贴到Python shell中(在粘贴模式下)以启用挂钩。最后，要开始跟踪，我们将执行以下操作：</p><p>#cd/sys/kernel/tracking#echo 2&gt；set_ftrace_pid#echo TCP_v4_rcv&gt；set_graph_function#echo function_graph&gt；current_tracer。</p><p>2是kthreadd的PID-我们需要在set_ftrace_pid中写入一些内容，因此启用了基于PID的过滤。这个内核线程基本上处于休眠状态(它是派生新内核线程的线程。由于它不是经常调度的，所以它处理任何软件中断的机会都很小)。</p><p>就这样!。在启用ftrace并发送要过滤的数据包之后，我在跟踪缓冲区中正好收到一个跟踪！这花了一些时间，但这个痕迹确实帮助我理解了相关的流程。</p><p>除了动态过滤的新功能之外，我们还可以从这里学到的是：只要您确切地知道您要找的是什么，就可以在Linux中实现，即使代码中不支持它。所有需要做的就是在代码中进行一些挖掘，也许还需要在各处添加一个小补丁…。</p><p>注意：这里给出的想法--以及内核Python本身--都是实验性的。不要在生产系统上尝试它们。它们仅作为研究和调试工具在测试机器上使用！</p><p>[4]严格地说，这可以通过将RX流固定到特定的CPU(及其ksoftirqd/CPU线程)来实现。但我想要一个更通用的解决方案。</p><p>[5]在Linux中，软件中断是为响应某些内核/硬件事件而定期执行的一组常见的高优先级作业。有时，它们完成因硬件中断而延迟的工作，但不一定。你可以在这里阅读更多关于他们的信息：https://lwn.net/Articles/520076/.。</p><p>[6]每CPU变量是具有多个副本的变量，每个副本对应于系统的每个CPU。内核代码可以轻松访问当前正在执行的CPU的PERPU实例。如果对象可以在逻辑上绑定到CPU，则将其定义为PERPU变量将消除所有锁定需求，因为每个CPU都有自己的副本。这还有许多其他用途，您可以在此处阅读有关其内核实现的信息：https://0xax.gitbooks.io/linux-insides/content/Concepts/linux-cpu-1.html.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/granulate/dynamic-ftrace-filtering-dececfc3eced">https://medium.com/granulate/dynamic-ftrace-filtering-dececfc3eced</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ftrace/">#ftrace</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pid/">#pid</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>