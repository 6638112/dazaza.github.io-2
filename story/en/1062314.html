<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如果可能的话，避免git lfs Avoid Git LFS if possible</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Avoid Git LFS if possible<br/>如果可能的话，避免git lfs </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-13 05:56:49</div><div class="page_narrow text-break page_content"><p>I have long held the opinion that you should avoid Git LFS if possible.Since people keeping asking me why, I figured I&#39;d capture my thoughtsin a blog post so I have something to refer them to.</p><p>我长期以来一直认为，如果可能的话，你应该避免Git LFS.Since人们留着我为什么，我想到了我的想法博客帖子，所以我有一些东西可以推荐给他们。</p><p>   Git LFS was developed outside the official Git project to fulfill avery real market need that Git didn&#39;t/doesn&#39;t handle large files verywell.</p><p>   Git LFS是在官方GIT项目之外开发的，以实现艾弗里实际市场需要Git Didn＆＃39; T / DONN＆＃39; T处理大文件。</p><p> I believe it is inevitable that Git will gain better support forhandling of large files, as this seems like a critical feature fora popular version control tool.</p><p> 我相信Git将更好地支持大型文件的守人，因为这似乎是一个流行的版本控制工具的关键功能。</p><p> If you make this long bet, LFS is only an interim solution and itsvalue proposition disappears after Git has better native supportfor large files.</p><p> 如果您在这次长期下注时，LFS只是一个临时解决方案，而且Git在GIT具有更好的本机支持后，其值下将消失。</p><p>   The adoption or removal of Git LFS in a repository is an irreversibledecision that requires rewriting history and losing your original commit SHAs.</p><p>   在存储库中采用或删除Git LFS是一种IrreversiDecistic，需要重写历史并失去原始提交SCA。</p><p> In some contexts, rewriting history is tolerable. In many others, itis an extremely expensive proposition. My experience maintainingversion control in professional contexts aligns with the opinionthat rewriting history is expensive and should only be considered ameasure of last resort. Maybe if tools made it easier to rewritehistory without the negative consequences (e.g. GitHub would redirectreferences to old SHA1 in URLs and API calls) I would change my opinionhere. Until that day, the drawbacks of losing history are just toohigh to stomach for many.</p><p> 在某些情况下，重写历史可容忍。在许多其他人中，ITIS一个非常昂贵的主张。我的经验维护在专业背景下的维护控制与重写历史昂贵的观点保持昂贵，只应被视为最后的手段。也许如果工具使得在没有负面后果的情况下更容易重写（例如，GitHub将重新调情到URL和API呼叫中的旧SHA1）我会改变我的意外。直到那一天，失去历史的缺点对于许多人来说太过于肚子。</p><p> The reason adoption or removal of LFS is irreversible is due to theway Git LFS works. What LFS does is change the blob content that aGit commit/tree references. Instead of the content itself, it storesa pointer to the content. At checkout and commit time, LFS blobs/recordsare treated specially via a mechanism in Git that allows content to berewritten as it moves between Git&#39;s core storage and its materializedrepresentation. (The same filtering mechanism is responsible fornormalizing line endings in text files. Although that feature is builtinto the core Git product and doesn&#39;t work exactly the same way. Butthe principles are the same.)</p><p> 通过或去除LFS的原因是不可逆转的，是由于GIT LFS的作品。 LFS所做的是更改Agit提交/树引用的Blob内容。而不是内容本身，它将它存储到内容的指针。在结账和提交时间时，通过Git中的机制特殊处理LFS Blobs / Recordsare，允许内容在Git＆＃39; S核心存储之间移动和其物质化静态。 （相同的过滤机制是文本文件中的负责任的责任线路结束。虽然该功能是内置的核心Git产品，并不完全相同的方式。但原则是相同的。） </p><p> Since the LFS pointer is part of the Merkle tree that a Git commitderives from, you can&#39;t add or remove LFS from a repo without rewritingexisting Git commit SHAs.</p><p>由于LFS指针是Merkle树的一部分，即Git Counderives来自，您可以＆＃39; T从Repo添加或删除LFS而无需重写Git提交SCA。</p><p> I want to explicitly call out that even if a rewrite is acceptable inthe short term, things may change in the future. If you adopt LFStoday, you are committing to a) running an LFS server forever b)incurring a history rewrite in the future in order to remove LFS fromyour repo, or c) ceasing to provide an LFS server and locking out peoplefrom using older Git commits. I don&#39;t think any of these are greatoptions: I would prefer if there were a way to offboard from LFS inthe future with minimal disruption. This is theoretically possible, butit requires the Git core product to recognize LFS blobs/records natively.There&#39;s no guarantee this will happen. So adoption of Git LFS is a oneway door that can&#39;t be easily reversed.</p><p> 我想明确地呼唤，即使短期内的重写是可接受的，事情也可能在未来变化。如果您采用LFStoday，您将永久运行LFS服务器B）将来导致历史记录重写，以便从youryour repo中删除lfs，或c）停止提供LFS服务器并使用较旧的Git提交锁定人员。我不认为这些是伟大选择：如果有一种方法，我宁愿从LFS中断，随着最小的中断。这是理论上可能的，请支出要求Git核心产品本身识别LFS Blobs /记录。＆＃39;否保证这将发生这种情况。所以采用Git LFS是一个可以＆＃39; t容易逆转的单门门。</p><p>   Git users have to install, configure, and sometimes know about theexistence of Git LFS. Version control should  just work. Large filehandling should  just work. End-users shouldn&#39;t have to care thatlarge files are handled slightly differently from small files.</p><p>   Git用户必须安装，配置，有时知道Git LFS的简称。版本控制应该只工作。大型文件手柄应该只工作。最终用户应该注意，必须小心文件与小文件略微不同地处理。</p><p> The usability of Git LFS is generally pretty good. However, there&#39;s anupper limit on that usability as long as LFS exists outside the coreGit product. And LFS will likely never be integrated into the core Gitproduct because the Git maintainers know that LFS is only a stop gapsolution. They would rather solve large files storage  correctly than~forever carry the legacy baggage of having to support LFS in the coreproduct.</p><p> Git LFS的可用性通常非常好。但是，只要LF存在于CoreGit产品之外，就可以使用它的Anupper限制。 LFS可能永远不会集成到核心GiitProduct中，因为Git维护者知道LFS只是停止展望。他们宁愿在〜Forevers携带遗留行李，以便在CoreProduct中支持LFS的遗留行李来解决大文件存储。</p><p> LFS is more complexity for Git server operators as well. Instead ofa self-contained Git repository and server to support, you now haveto support a likely separate HTTP server to facilitate LFS access.This isn&#39;t the hardest thing in the world, especially since we&#39;retalking about key-value blob storage, which is arguably a solved problem.But it&#39;s another piece of infrastructure to support and secure and itincreases the surface area of complexity instead of minimizing it.As a server operator, I would much prefer if the large file storagewere integrated into the core Git product and I simply needed to providesome settings for it to  just work.</p><p> LFS对Git Server运算符更复杂。而不是将自包含的Git存储库和服务器支持，您现在HAVETO支持一个可能的HTTP服务器，以方便LFS Access.This ISN＆＃39; T最难的东西，特别是因为我们＆＃39;返回关于钥匙值Blob Storage可以说是一个解决的问题。但它＆＃39;另一块基础架构来支持和安全，它是复杂性的表面积，而不是最小化它。即服务器运算符，如果大文件储存，我将更喜欢集成到核心Git产品中，我只是需要提供它的设置。</p><p>  Since I&#39;m a maintainer of the Mercurial version control tool, I thoughtI&#39;d throw out how Mercurial handles large file storage better thanGit. Mercurial&#39;s large file handling isn&#39;t great, but I believe itis strictly better with regards to the trade-offs of adopting largefile storage.</p><p>  自I＆＃39; m是Mercurial版本控制工具的维护者，我觉得＆＃39; d抛出了Mercurial如何处理大型文件存储更好的Thangit。 Mercurial＆＃39; S大文件处理ISN＆＃39; T Greaty，但我相信采用大型仓储的权衡严格更好地更好地更好。</p><p> In Mercurial, use of LFS is a dynamic feature that server/repo operatorscan choose to enable or disable whenever they want. When the Mercurialserver sends file content to a client, presence of external/LFS storageis a  flag set on that file revision. Essentially, the flag says  thedata you are receiving is an LFS record, not the file content itself andthe client knows how to resolve that record into content.</p><p> 在Mercurial中，使用LFS是一个动态的功能，即服务器/ repo operatorscan选择每当想要启用或禁用。当MercialServer将文件内容发送到客户端时，在该文件修订版上设置外部/ LFS StorageS的标志。本质上，标志称，您正在接收的Thedata是一个LFS记录，而不是文件内容本身，客户端知道如何将该记录重新分析到内容中。 </p><p> Conceptually, this is little different from Git LFS records in terms ofcontent resolution. However, the big difference is this flag is partof the repository interchange data, not the core repository data as itis with Git. Since this flag isn&#39;t part of the Merkle tree used toderive the commit SHA, adding, removing, or altering the content of theLFS records doesn&#39;t require rewriting commit SHAs. The tracked contentSHA - the data now stored in LFS - is still tracked as part of the Merkletree, so the integrity of the commit / repository can still be verified.</p><p>在概念上，这与Content解决方案中的Git LFS记录很小。但是，很大的区别是该标志是存储库交换数据的一部分，而不是带有git的核心存储库数据。由于此标志ISN＆＃39; T部分Merkle树用于响应于Commit SHA，添加，删除或改变其中的文档内容并不需要重写提交SCA。跟踪的内容 - 现在存储在LFS中的数据 - 仍然被跟踪为MerkletRee的一部分，因此仍然可以验证提交/存储库的完整性。</p><p> In Mercurial, the choice of whether to use LFS and what to use LFS foris made by the server operator and settings can change over time. Forexample, you could start with no use of LFS and then one day decide touse LFS for all file revisions larger than 10 MB. Then a year lateryou lower that to all revisions larger than 1 MB. Then a year afterthat Mercurial gains better  native support for large files andyou decide to stop using LFS altogether.</p><p> 在Mercurial中，选择是否使用LFS以及服务器操作员和设置使用的LFS Foris的内容可以随时间改变。 forexample，您可以从不使用LFS开始，然后一天决定淘汰Lous LFS，用于大于10 MB的所有文件修订。然后一年稍后降低到大于1 MB的所有修订。然后，一年后的Mercurial获得了对大型文件的原始支持，您决定完全停止使用LFS。</p><p> Also in Mercurial, it is possible for clients to push a large file inline as part of the push operation. When the server sees thatlarge file, it can be like  this is a large file: I&#39;m going to addit to the blob store and advertise it as LFS. Because the largefile record isn&#39;t part of the Merkle tree, you can have nice thingslike this.</p><p> 同样在Mercurial中，客户可以作为推送操作的一部分inline推动大文件。当服务器看到那个文件时，它可能就像这是一个大文件：i＆＃39; m要将blob商店添加到blob store并作为lfs宣传它。因为大型唱片ISN＆＃39; T部分Merkle树，你可以有很好的东西。</p><p> I suspect it is only a matter of time before Git&#39;s wire protocol learnsthe ability to dynamically advertise  remote servers for contentretrieval and this feature will be leveraged for better large filehandling. Until that day, I suppose we&#39;re stuck with having torewrite history with LFS and/or funnel large blobs through Git natively,with all the pain that entails.</p><p> 我怀疑git＆＃39; s wire Protocol Searchshe动态广告远程服务器以进行ContentRetrieval的能力，且此功能将利用此功能以获得更好的大型文件。直到那一天，我想我们＆＃39;恢复了用LFS和/或漏斗的毛刺历史，通过当本地加入大斑点，所有需要的疼痛都是如此。</p><p>  This post summarized reasons to avoid Git LFS. Are there justifiablescenarios for using LFS? Absolutely! If you insist on using Git andinsist on tracking many  large files in version control, youshould definitely consider LFS. (Although, if you are a heavy userof large files in version control, I would consider Plastic SCM instead,as they seem to have the most mature solution for large files handling.)</p><p>  这篇文章总结了避免Git LFS的原因。使用LFS是否有justifiablescenarios？绝对地！如果您坚持使用Git Andinsist进行跟踪版本控制中的许多大文件，则肯定会考虑LFS。 （虽然，如果您是版本控制中的大文件的沉重用户，我会考虑塑料SCM，因为它们似乎拥有大文件处理的最成熟解决方案。）</p><p> The main point of this post is to highlight some drawbacks withusing Git LFS because Git LFS is most definitely not a magic bullet. Ifyou can stomach the short and long term effects of Git LFS adoption, byall means, use Git LFS. But please make an informed decision either way.</p><p> 这篇文章的要点是突出一些缺点，因为Git LFS绝对不是魔子弹。如果你可以胃部的git lfs采用的短期和长期影响，byall意味着，使用git lfs。但请以任何方式做出明智的决定。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gregoryszorc.com/blog/2021/05/12/why-you-shouldn%27t-use-git-lfs/">https://gregoryszorc.com/blog/2021/05/12/why-you-shouldn%27t-use-git-lfs/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/避免/">#避免</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/git/">#git</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lfs/">#lfs</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>