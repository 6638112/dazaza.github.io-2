<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Haskell是一种不良的编程语言（2020） Haskell is a Bad Programming Language (2020)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Haskell is a Bad Programming Language (2020)<br/>Haskell是一种不良的编程语言（2020） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-09 20:02:47</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/539a817d1200bc3d262b1971712fbd0b.png"><img src="http://img2.diglog.com/img/2021/1/539a817d1200bc3d262b1971712fbd0b.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Some languages naturally lend themselves towards adoption. Some don’t. You’d expect after 30 years of Haskell, the community, tooling, and development environment would grow much more mature.</p><p>有些语言自然会倾向于采用。有些没有。您希望在Haskell工作30年后，社区，工具和开发环境将变得更加成熟。</p><p>  Funnily enough everyone in the Haskell community blamed everyone else instead of doing a critical assessment of the language like what Perl did. I stifled a laugh when I see proponents of “Simple Haskell”, implying that somehow the language is “too hard for people to learn”.</p><p>  有趣的是，Haskell社区中的每个人都指责其他所有人，而不是像Perl那样对语言进行严格的评估。当我看到“ Simple Haskell”的拥护者时，我大笑起来，这暗示着这种语言“对人们来说太难学了”。</p><p> If people can pick up F#, Scala and Clojure, all with their own brand of weirdness, both in syntax and environment while being functional programming languages, I don’t really see how this statement holds any water.</p><p> 如果人们在使用函数式编程语言的同时，在语法和环境上都能以自己的怪异方式挑选F＃，Scala和Clojure，我真的看不出这句话有什么用。</p><p>  One, programming languages are meant to ease the task of creating computer programs as opposed to writing assembly by hand. Thus, the most important part of programming languages is communication. If the language naturally lends itself towards making code easier for people to understand, it will succeed, even if it is weird. Look at Clojure. Weird parentheses, and yet it took the world by storm all because the programming language actually makes a lot of sense and facilitates communication both between programmers, and the computer.</p><p>  一种是，编程语言是为了简化创建计算机程序的任务，而不是手工编写汇编。因此，编程语言最重要的部分是交流。如果该语言自然使自己易于人们理解，那么即使它很奇怪，它也会成功。看看Clojure。括号括起来很奇怪，但它风靡世界，因为编程语言实际上具有很大的意义，并促进了程序员与计算机之间的通信。</p><p> Haskell proponents try to claim that type signatures are somehow documentation. Yeah, no matter how many times you claim this, it’s really not true. We have had decades of experience in statically typed languages tell us that types are never replacement for clear syntax and documentation. Every few months some newbie comes along to the Haskell reddit and asks why is Haskell documentation so confusing, and the post get destroyed by people telling them to get good or just pointing at academic papers. Really?</p><p> Haskell的支持者试图声称类型签名在某种程度上是文档。是的，无论您声称多少次，这都是真的。我们在静态类型语言方面拥有数十年的经验，这告诉我们类型永远无法替代清晰的语法和文档。每隔几个月，就会有一些新手出现在Haskell reddit上，并问为什么Haskell文档如此混乱，为什么帖子会被人们告诉他们变得良好或只是指向学术论文而被破坏。真？</p><p> What’s even funnier is people saying that “Haskell doesn’t suck, the development environment does”. Haskell has had 30 years to improve itself and while there’s some headway, growth is ridiculously slow. Guess what? If people can work with C++ and create amazing tools with it, I don’t think that statement makes much sense.</p><p> 甚至更有趣的是，人们说“ Haskell不会吸引，开发环境会吸引”。 Haskell有30年的自我完善经验，尽管取得了一些进展，但增长速度却非常缓慢。你猜怎么了？如果人们可以使用C ++并使用它来创建出色的工具，那么我认为这种说法没有多大意义。</p><p> Two, Haskell is a functional language that also convinces its users to commit the same mistakes as writing an OOP language. Very senior Haskellers calls for “type oriented programming” which goes like this: Write types and interfaces for the types and fill in the blanks. Sounds familiar? Because that’s we’ve been doing with Java and the like using UML. Haskell barely benefits because it’s a FP language but being a relatively unflexible language, it throws out all the things we’ve learnt as a software development community like focusing on loose dependencies and being constantly ready for change. Professional developers find themselves describing the system in such concrete ways using types that when the requirements change suddenly their precious castle is reduced to dust and they then have to restructure their types interaction again. This is the bad thing of top-down design. Bottom up design is something we’ve learnt collectively as a good way to be much more flexible in responding to change. Build simple parts, mix and match them to build complex parts.</p><p> 第二，Haskell是一种功能语言，它也说服其用户犯了与编写OOP语言相同的错误。非常资深的Haskellers呼吁采用“面向类型的编程”的方式，如下所示：编写类型和类型的接口并填写空白。听起来很熟悉？因为那是我们一直在使用Java等使用UML进行的工作。 Haskell几乎没有好处，因为它是一种FP语言，但相对来说是一种不灵活的语言，它抛弃了我们作为软件开发社区所学的所有知识，例如专注于松散的依赖关系并时刻准备着应对变化。专业的开发人员发现自己使用类型来具体描述系统，当需求突然改变时，他们宝贵的城堡变成尘土，然后必须重新构造其类型交互。这是自上而下设计的坏事。自下而上的设计是我们共同学习的一种方法，它是一种更好地应对变化的灵活方法。构建简单的零件，混合并匹配它们以构建复杂的零件。 </p><p> Part of this has to do with Haskell’s way of tricking people into thinking that more abstraction with higher level types is a good thing. There’s two things wrong with this. One, types are a concretion. If you’re looking for higher level of abstractions to get flexible behaviour, you’re ultimately going to have a world of pain, because of two, abstractions ultimately leak, and when abstractions on abstractions on abstractions leak, it’s not a pretty sight. Somehow Haskellers think that they are more productive with Haskell when the reality in the real world is that only a few languages can proudly make that claim, such as Python and Lisp. These are languages battle tested in actual software products that it is for a fact that people are simply more productive in it, not because they are easy, but they are simple.</p><p>部分原因与Haskell诱使人们认为使用更高级别类型进行更多抽象是一件好事。这有两个问题。第一，类型是一种凝结。如果您正在寻找更高级别的抽象来获取灵活的行为，那么最终将有一个痛苦的世界，因为有两个，抽象最终会泄漏，并且当抽象上的抽象泄漏时，它并不是一个漂亮的景象。在现实世界中，只有少数几种语言可以自豪地提出这种主张，例如Python和Lisp，Haskellers认为他们可以提高Haskell的生产力。这些语言已经在实际的软件产品中经过了实战测试，这是因为人们实际上在其中提高了生产力，并不是因为它们很简单，而是因为它们很简单。</p><p> Abstractions with types is a bad type of abstraction because it ignores the basic fact that programs deal with data, and data has no types. When you’re reading this article, or talking to someone, do you claim that you’re saying a string, a number, a Text, or something else? No! Data is simply data, and data is inherently dynamic. We add types to data to make it easier (not simpler!) to work with data. In most cases people are looking for schemas, not types. Types wrap data and treat it like a black box whereas schema describes the shape and content of data. As such haskell ultimately suffers a lot when they have to interact with the real world. Suddenly they are left reeling as they find out that the real world is, in fact, dynamic. And so you see people propose “boring haskell” where you basically write haskell like some functional C# program.</p><p> 带类型的抽象是一种糟糕的抽象类型，因为它忽略了程序处理数据且数据没有类型的基本事实。当您阅读本文或与他人交谈时，是否声称您在说字符串，数字，文本或其他东西？没有！数据就是简单的数据，而数据本身就是动态的。我们向数据添加类型以使其更容易（而不是更简单！）处理数据。在大多数情况下，人们在寻找模式，而不是类型。类型包装数据并将其像黑盒子一样对待，而模式描述数据的形状和内容。因此，当Haskell必须与现实世界互动时，他们最终会遭受很多苦难。当他们发现现实世界实际上是动态的时，突然间他们大吃一惊。因此，您会看到人们提出“无聊的haskell”，您基本上像一些功能性C＃程序一样编写haskell。</p><p> Three, Haskell doesn’t suck because it does not have enough libraries, it sucks because working with other languages is a horrifying experience given that so many tricks are needed to make GHCJS. Look, even most haskellers would agree that purescript is a better choice compared to GHCJS. No man is an island, and yet Haskellers generally convinced themselves that other languages need to learn from Haskell, and not the other way around.</p><p> 第三，Haskell不会因为没有足够的库而糟透了，而是因为与其他语言一起工作是一种令人恐惧的经历，因为制作GHCJS需要很多技巧。看起来，即使是大多数散客也同意，与GHCJS相比，purescript是更好的选择。没有人是一个孤岛，但是Haskellers普遍说服自己，其他语言需要向Haskell学习，而不是相反。</p><p> A very clear indication of this is how Haskell treats programming terms.  Instead of explaining Monads like all other design patterns out there, they insist on using some obscure definition from category theory to explain it. Look, when monads are used without the infix notation, the result is horrendous and it looks like yet another callback chain. Functors are basically an Object with a internal state changing method in typical OOP terms. Haskell is not hard, the language itself is fairly easy to grok, but the terms people use are just plain ignorant of the other people in the software community. It is as if Haskell doesn’t want “normal” people to understand it, and it lends towards a sort of elitist community where people claim they understand something when they don’t. Don’t believe me? Try asking people using Haskell about monads and watch as they gape as they give you a psuedo-explanation. I tried it myself. Of course, there are very smart people who do understand Monads, but most people would just tell you to “get an intuition for it”, which to be honest is total BS.</p><p> Haskell如何对待编程术语便是一个非常清楚的指示。他们没有像其他所有设计模式那样解释Monad，而是坚持使用类别理论中一些晦涩的定义来解释它。看起来，当使用不带中缀符号的monad时，结果令人震惊，看起来又像是另一个回调链。按照典型的OOP术语，函子基本上是具有内部状态更改方法的Object。 Haskell并不难，语言本身也相当容易理解，但是人们使用的术语只是对软件社区中的其他人一无所知。就像Haskell不想让“正常”的人理解它一样，它有助于建立一个精英社区，人们声称他们在不了解时会有所了解。不相信我吗？尝试向使用Haskell的人询问单子，并观察它们的裂隙，为您提供伪解释。我自己尝试过。当然，有一些非常聪明的人确实了解Monads，但是大多数人只会告诉您“获得直觉”，说实话，这是总BS。</p><p> Haskell would be better off if people stop thinking that it’s a “beautifully designed” language and start critically examining how to improve core Haskell, in my honest opinion.</p><p> 如果我不再诚实地认为Haskell是一种“精美设计”的语言，而开始批判性地研究如何改进核心Haskell，Haskell将会更好。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.shitiomatic.tech/post/haskell-is-a-bad-programming-language/#ðŸ‘¾">https://blog.shitiomatic.tech/post/haskell-is-a-bad-programming-language/#ðŸ‘¾</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/haskell/">#haskell</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bad/">#bad</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>