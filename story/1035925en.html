<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Linux应用程序性能：简介（2019）Linux Applications Performance: Introduction (2019)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Linux Applications Performance: Introduction (2019)<br/>Linux应用程序性能：简介（2019）</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-22 23:03:50</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/ae6f7895e2011ef9f6c4c2d1eca421e5.png"><img src="http://img2.diglog.com/img/2020/11/ae6f7895e2011ef9f6c4c2d1eca421e5.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>There are several interesting takeaways from the  HackerNews thread for this article series. Do check it out.</p><p>对于本系列文章，HackerNews线程有一些有趣的总结。请检查一下。</p><p> Web apps are the staple of consumers and enterprises. Among the many existing protocols that are used to move and make sense of bits, HTTP has an overwhelming mind share. As you encounter and learn the nuances of web application development, most of you might pay very little attention to the operating system that finally runs your applications. The separation of Dev and Ops only made this worse. But with the DevOps culture becoming common place and developers becoming responsible for running their apps in the cloud, it is a clear advantage to better understand backend operating system nitty-gritty. You don’t really have to bother with Linux and how your backend will scale if you are deploying your backend as a system for personal use or for use by a few concurrent users. If you are trying to deploy for thousands or tens of thousands of concurrent users, however, having a good understanding of how the operating system figures out in your whole stack will be incredibly useful.</p><p> Web应用程序是消费者和企业的主食。在用于移动和理解位的许多现有协议中，HTTP具有压倒性的优势。在您了解和学习Web应用程序开发的细微差别时，大多数人可能很少关注最终运行您的应用程序的操作系统。开发人员和运营人员的分离只会使情况变得更糟。但是，随着DevOps文化变得司空见惯，开发人员开始负责在云中运行其应用程序，更好地了解后端操作系统的本质是一个明显的优势。如果您将后端部署为供个人使用或供少数并发用户使用的系统，则您实际上不必担心Linux以及后端将如何扩展。但是，如果要为成千上万的并发用户进行部署，那么对操作系统如何在整个堆栈中计算出来的全面了解将非常有用。</p><p>  The constraints we are up against in the web services we write are very similar to those in other applications that are required to make a web service or application work. Be those load balancers or the database servers. All these classes of applications have similar challenges in high-performance environments. Understanding these fundamental constraints and how to work around them will in general make you appreciate what performance and scalability of your web applications or services are up against.</p><p>  我们编写的Web服务中要面对的约束与使Web服务或应用程序正常工作所需的其他应用程序中的约束非常相似。是那些负载平衡器还是数据库服务器。所有这些类型的应用程序在高性能环境中都面临类似的挑战。通常，了解这些基本约束以及如何解决它们将使您理解Web应用程序或服务要面对的性能和可伸缩性。</p><p> I am writing this series in response to the questions I get asked by young developers who want to become well–informed system architects. Without diving down into the basics of what makes Linux applications tick and the different ways of structuring Linux or Unix network applications, it is not possible to gain a through and clear understanding of Linux application performance. While there are many types of Linux applications, what I want to explore here are Linux networking–oriented applications as opposed to say, a desktop application like a browser or a text editor. This is because the audience for this series are web services/application developers and architects who want to understand how Linux or Unix applications work and how to structure these services for high performance.</p><p> 我写本系列文章的目的是要回应年轻的开发人员提出的问题，他们希望成为消息灵通的系统架构师。如果不深入探讨使Linux应用程序产生变化的基础知识以及构建Linux或Unix网络应用程序的不同方法，就不可能对Linux应用程序的性能有透彻的了解。尽管有许多类型的Linux应用程序，但我想在这里探索的是面向Linux网络的应用程序，而不是诸如浏览器或文本编辑器之类的桌面应用程序。这是因为本系列的读者是Web服务/应用程序开发人员和架构师，他们想了解Linux或Unix应用程序如何工作以及如何构建这些服务以实现高性能。</p><p> Linux is  the server operating system and more often than not, your applications probably run on Linux finally. Although I say Linux, most of the time you can safely assume I also include other Unix–like operating systems in general. However, I haven’t extensively tested the accompanying code on other Unix–like systems. So, if you are interested in FreeBSD or OpenBSD, your mileage may vary. Where I attempt anything Linux-specific, I’ve done my best to point it out.</p><p> Linux是服务器操作系统，通常，您的应用程序最终可能会在Linux上运行。尽管我说的是Linux，但是大多数时候您可以放心地假设我还包括其他类似Unix的操作系统。但是，我还没有在其他类似Unix的系统上对附带的代码进行广泛的测试。因此，如果您对FreeBSD或OpenBSD感兴趣，那么您的工作量可能会有所不同。在尝试任何特定于Linux的地方，我已尽力指出了这一点。</p><p> While you can certainly use this knowledge to choose the best possible structure for a new network application you want to write from scratch, you might not be firing up your favorite text editor and writing a web server in C or C++ to solve the problem of having to deliver the next business app in your organization. That might be a guaranteed way to get yourself fired. Having said that, knowing these application structures will help you tremendously in choosing one among a few existing applications, if you know how they are structured. After understanding this article series, you will be able to appreciate process–based vs. thread–based vs. event–based systems. You will get to understand and appreciate why Nginx performs better than Apache httpd or why a Tornado based Python application might be able to serve more concurrent users compared to a Django based Python application.</p><p> 虽然您当然可以使用这些知识来为要从头开始编写的新网络应用程序选择最佳的结构，但是您可能并没有启动自己喜欢的文本编辑器并使用C或C ++编写Web服务器来解决以下问题：在您的组织中交付下一个业务应用。那可能是让自己被解雇的保证方法。话虽如此，了解这些应用程序的结构将极大地帮助您从几个现有应用程序中选择一种，只要您知道它们的结构。在理解了本系列文章之后，您将能够了解基于流程的系统，基于线程的系统和基于事件的系统。您将了解并理解为什么Nginx的性能要比Apache httpd好，或者与基于Django的Python应用程序相比，基于Tornado的Python应用程序可能能够为更多的并发用户提供服务。</p><p>  ZeroHTTPd is a web server I wrote from scratch in C as a teaching tool. It has no external dependencies, including for Redis access. We roll our own Redis routines–read more below.</p><p>  ZeroHTTPd是我从头开始用C语言编写的Web服务器，作为教学工具。它没有外部依赖性，包括Redis访问。我们推出了自己的Redis例程-请在下面阅读更多内容。</p><p> While we could talk a whole lot of theory, there is nothing like writing code, running it, benchmarking it to compare each of server architectures we evolve. This should cement your understanding like no other method. To this end, we will develop a simple web server called ZeroHTTPd using process–based, thread–based and event–based models. We will benchmark our each of these servers and see how they perform relative to one another. ZeroHTTPd is a simple–as–possible HTTP server written from scratch in pure C with no external library dependencies. It is implemented in a single C file. For event-based servers, I include  uthash, an excellent hash table implementation, which is comes in a single header file. Otherwise, there are no dependencies and this is to keep things simple.</p><p>尽管我们可以讨论很多理论，但是没有什么比编写代码，运行代码，对其进行基准测试以比较我们所开发的每种服务器体系结构更是如此。这应该像其他方法一样巩固您的理解。为此，我们将使用基于流程，基于线程和基于事件的模型开发一个名为ZeroHTTPd的简单Web服务器。我们将对这些服务器中的每一个进行基准测试，并观察它们相对于彼此的性能。 ZeroHTTPd是一个简单可行的HTTP服务器，从头开始用纯C语言编写，没有任何外部库依赖项。它在单个C文件中实现。对于基于事件的服务器，我包括uthash，这是一个出色的哈希表实现，它位于单个头文件中。否则，就没有依赖性，这是为了使事情保持简单。</p><p> I’ve heavily commented the code to aid understanding. ZeroHTTPd is also a bare minimal web development framework apart from being a simple web server written in a couple of hundred lines of C. It doesn’t do a lot. But, it can server static files and very simple “dynamic” pages. Having said this, ZeroHTTPd is well-suited for you to understand how to architect your Linux applications for high-performance. At the end of the day, most web services wait around for requests, look into what that request is and process them. This is exactly what we will be doing with ZeroHTTPd as well. It is a learning tool, not something you’ll use in production. It is also not going to win awards for error handling, security best practices (oh yes, I’ve used  strcpy) or for clever tricks and shortcuts of the C language, of which there are several. But, it’ll hopefully serve its purpose well (pun unintended).</p><p> 我对代码进行了大量评论，以帮助理解。 ZeroHTTPd除了是用几百行C语言编写的简单Web服务器以外，它还是一个最小的Web开发框架。它并没有做什么用。但是，它可以处理静态文件和非常简单的“动态”页面。话虽如此，ZeroHTTPd非常适合您了解如何构建Linux应用程序以实现高性能。最终，大多数Web服务都在等待请求，调查该请求是什么并处理它们。这正是我们将对ZeroHTTPd进行的操作。它是一种学习工具，不是您将在生产中使用的工具。它也不会因错误处理，安全性最佳实践（是的，我使用过strcpy）或C语言的巧妙技巧和捷径而获奖，其中有很多。但是，它有望很好地实现其目的（意想不到的双关语）。</p><p>   Modern web applications hardly serve just static files. They have complex interactions with various databases, caches, etc. To that end, we build a simple web app named “Guestbook” that lets guests lovingly leave their name and remarks. Guestbook also lists remarks previously left by various guests as well. There is also a visitor counter towards the bottom of the page.</p><p>   现代的Web应用程序几乎不只提供静态文件。他们与各种数据库，缓存等进行复杂的交互。为此，我们构建了一个名为“ Guestbook”的简单Web应用程序，使来宾可以留下自己的名字和评论。留言簿还列出了以前由各个来宾留下的评论。页面底部还有一个访客计数器。</p><p>  We store the visitor counter and the guest book entries in Redis. To talk to Redis, we do not depend on an external library. We have our own custom C routines to talk to Redis. I’m not big fan of rolling out your own stuff when you can use something that is already available and well tested. But the goal of ZeroHTTPd is to teach Linux performance and accessing external services while in the middle of serving an HTTP request has a huge implications as far as performance goes. We need to be in full control of the way we talk to Redis in each of the server architectures we are building. While in one architecture we use blocking calls, in others we use event-based routines. Using an external Redis client library won’t allow us this control. Also, we will be implementing our own Redis client only to the extent we will use Redis (Getting, setting and incrementing a key. Getting and appending to an array). Moreover, the Redis protocol is super elegant and simple. Something to even learn about deliberately. The very fact that you can implement a super-fast protocol that does its job in about 100 lines of codes goes to say a lot about how well thought out the protocol is.</p><p>  我们将访客计数器和访客留言条目存储在Redis中。与Redis交谈时，我们不依赖外部库。我们有自己的自定义C例程与Redis对话。当您可以使用已经可用且经过良好测试的产品时，我不愿意推出自己的产品。但是ZeroHTTPd的目标是传授Linux性能和访问外部服务，而在服务HTTP请求的过程中，就性能而言，这具有巨大的意义。我们需要完全控制我们正在构建的每种服务器体系结构中与Redis进行对话的方式。在一种架构中，我们使用阻塞调用，而在其他架构中，我们使用基于事件的例程。使用外部Redis客户端库将不允许我们使用此控件。另外，我们将仅在使用Redis的范围内实现自己的Redis客户端（获取，设置和递增键。获取并追加到数组）。而且，Redis协议非常优雅和简单。甚至有意学习的东西。实际上，您可以实现一个超快的协议，用大约100行代码来完成它的工作，这实际上说明了该协议的思想如何。</p><p> The following figure illustrates the steps we follow in order to get the HTML ready to serve when a client (browser) requests the  /guestbookURL.</p><p> 下图说明了当客户端（浏览器）请求/ guestbookURL时为使HTML准备就绪而可以使用的HTML的步骤。</p><p>  When a Guestbook page needs to be served, there is one file-system call to read the template into memory and three network-related calls to Redis. The template file has most of the HTML content that makes up the Guestbook page you see in the screenshot above. It also has special placeholders where the dynamic part of the content which comes from Redis like guest remarks and the visitor counter go. We fetch these from Redis, replace these for the placeholders in the template file and finally, the fully formed content is written out to the client. The third call to Redis could have been avoided since Redis returns the new value of any incremented key. However, for our purposes, as we move our server to asynchronous, event-based architectures, having a server that is busy blocking on a bunch of network calls is a good way to learn about things. So, we discard the return value that Redis returns when we increment the visitor count and read it back in a separate call.</p><p>  当需要提供访客留言页时，有一个文件系统调用将模板读入内存，而有三个与网络相关的对Redis的调用。模板文件具有构成您在上面的屏幕截图中看到的Guestbook页面的大多数HTML内容。它还具有特殊的占位符，来自Redis的内容的动态部分（如来宾评论和访问者计数器）可以放置其中。我们从Redis获取这些内容，将其替换为模板文件中的占位符，最后，将完整的内容写出给客户端。由于Redis返回任何增量键的新值，因此可以避免对Redis的第三次调用。但是，出于我们的目的，当我们将服务器移至基于事件的异步体系结构时，拥有一台忙于阻塞网络调用的服务器是了解情况的好方法。因此，当我们增加访问者计数并在单独的调用中将其读回时，我们将丢弃Redis返回的返回值。</p><p>    We shall also measure the performance of each architecture loading them each with 10,000 HTTP requests. However, as we move on to comparisons with architectures that can handle a lot more concurrency, we will switch to testing with 30,000 requests. We test 3 times and consider the average.</p><p>    我们还将测量每种体系结构的性能，将每个体系结构加载10,000个HTTP请求。但是，当我们继续与可以处理更多并发性的体系结构进行比较时，我们将切换到具有30,000个请求的测试。我们测试3次并考虑平均值。</p><p>   It is important that these tests not be run with all components on the same machine. If that is done, the operating system will have the extra overhead of scheduling between all those components, as they vie for CPU. Measuring operating system overhead with each of the chosen server architectures is one of the most important aims of this exercise. Adding more variables will be detrimental to the process. Hence, a setup described in the illustration above will work best.</p><p>重要的是，不要在同一台计算机上对所有组件都运行这些测试。如果这样做，则操作系统将在所有这些组件争夺CPU的时间之间安排额外的开销。使用所选的每种服务器体系结构衡量操作系统开销是此练习的最重要目标之一。添加更多变量将对该过程有害。因此，上图中描述的设置将最有效。</p><p>  load.unixism.net: This is where we run  ab, the Apache Benchmark utility, which generates the load we need to test our server architectures.</p><p>  load.unixism.net：这是我们运行Apache Benchmark实用工具ab的地方，该工具生成我们测试服务器体系结构所需的负载。</p><p> nginx.unixism.net: At times we may want to run more than one instance of our server program. So, we use a suitably configured Nginx server as a load balancer to spread the load coming in from  ab on to our server processes.</p><p> nginx.unixism.net：有时我们可能要运行服务器程序的多个实例。因此，我们使用适当配置的Nginx服务器作为负载平衡器，以将从ab传入的负载分散到我们的服务器进程中。</p><p> zerohttpd.unixism.net: This is where we run our server programs, which are based on the 7 different architectures listed above, one architecture at a time.</p><p> zerohttpd.unixism.net：这是我们运行服务器程序的地方，该服务器程序基于上面列出的7种不同体系结构，一次仅一种体系结构。</p><p> redis.unixism.net: This server runs the Redis daemon which stores the guest remarks and the visitor counter.</p><p> redis.unixism.net：此服务器运行Redis守护程序，该守护程序存储来宾评论和访客计数器。</p><p> All servers have a single CPU core. The idea is to see how much performance we can wring out of it with each of our server architectures. Since all of our server programs are measured against the same hardware, it acts as the baseline against which we measure the relative performance or each of our server architectures. My testing setup consisted of virtual servers rented from Digital Ocean.</p><p> 所有服务器都具有单个CPU内核。这样做的目的是了解我们可以在每种服务器体系结构中获得多少性能。由于我们所有服务器程序都是在相同硬件上测得的，因此它充当了我们衡量相对性能或每种服务器体系结构的基准。我的测试设置包括从Digital Ocean租用的虚拟服务器。</p><p>  There are many things we can measure. However, given a certain amount of compute resources, we want to see how much performance we can squeeze out of each architecture at various levels of increasing concurrency. We test with up to 15,000 concurrent users.</p><p>  我们可以衡量很多事情。但是，在给定一定数量的计算资源的情况下，我们希望了解在提高并发性的各个级别上，可以从每种体系结构中挤出多少性能。我们最多可以测试15,000个并发用户。</p><p>  The following chart shows how servers employing different process architectures perform when subjected to various concurrency levels. In the y-axis we have requests/sec and in the x-axis we have concurrent connections.</p><p>下表显示了采用不同流程体系结构的服务器在经受各种并发级别时的性能。在y轴上，我们有请求/秒，在x轴上，我们有并发连接。</p><p>      You can see from the chart and table above that beyond 8,000 concurrent requests we only have 2 contenders: pre-threaded and epoll. In fact, our poll-based server fares worse than the threaded server, which comfortably beats the former in performance even at the same concurrency levels. The prethreaded server architecture giving the epoll-based server a good run for its money is a testament to how well the Linux kernel handles scheduling of a very large number of threads.</p><p>      从上面的图表可以看出，在8,000个并发请求之外，我们只有2个竞争者：预线程和epoll。实际上，我们基于轮询的服务器的性能要比线程服务器差，即使在相同的并发级别下，后者的性能也可以轻松击败前者。预线程服务器体系结构为基于epoll的服务器提供了一个不错的选择，这证明了Linux内核处理大量线程调度的能力。</p><p>  You can find the source code for  ZeroHTTPd here. Each server architecture gets its own directory.</p><p>  您可以在此处找到ZeroHTTPd的源代码。每个服务器体系结构都有自己的目录。</p><p> ZeroHTTPd│├── 01_iterative│   ├── main.c├── 02_forking│   ├── main.c├── 03_preforking│   ├── main.c├── 04_threading│   ├── main.c├── 05_prethreading│   ├── main.c├── 06_poll│   ├── main.c├── 07_epoll│ └── main.c├── Makefile├── public│   ├── index.html│   └── tux.png└── templates └── guestbook └── index.html</p><p> ZeroHTTPd│├──01_迭代│├──main.c├──02_forking│├──main.c├──03_preforking│├──main.c├──04_threading│├──main.c├──05_prethreading │├──main.c├──06_poll│├──main.c├──07_epoll│└──main.c├──Makefile├──public│├──index.html│└──晚礼服。 png└──模板└──留言簿└──index.html</p><p> In the top level directory, apart from the 7 folders that hold the code for ZeroHTTPd based on the 7 different architectures we discuss, there are 2 other directories there. The “public” and “templates” directories. The “public/” directory contains an index file and an image that you see in the screenshot. You can put other files and folders in here and ZeroHTTPd should serve those static files without problems. When the path component entered in the browser matches a path inside the “public” folder, ZeroHTTPd will look for an “index.html” file in that directory before giving up. Our Guestbook app, which is accessed by going to the path  /guestbook, is a dynamic app, meaning that its content is dynamically generated. It has only one main page and content for that page is based on the file “templates/guestbook/index.html”. It is easy to add more dynamic pages to ZeroHTTPd and extend it. The idea is that users can add more templates inside this directory and extend ZeroHTTPd as needed.</p><p> 在顶层目录中，除了基于我们讨论的7种不同体系结构保存ZeroHTTPd代码的7个文件夹之外，还有2个其他目录。 “公共”和“模板”目录。 “ public /”目录包含一个索引文件和一个您在屏幕快照中看到的图像。您可以将其他文件和文件夹放在此处，ZeroHTTPd应该可以毫无问题地提供这些静态文件。当在浏览器中输入的路径组件与“ public”文件夹内的路径匹配时，ZeroHTTPd会在放弃之前在该目录中查找“ index.html”文件。我们的Guestbook应用程序是动态应用程序，可通过转到/ guestbook路径进行访问，这意味着其内容是动态生成的。它只有一个主页，该页面的内容基于文件“ templates / guestbook / index.html”。向ZeroHTTPd添加更多动态页面并对其进行扩展很容易。想法是用户可以在此目录中添加更多模板，并根据需要扩展ZeroHTTPd。</p><p> To build all 7 servers, all you need to do it run “make all” from the top level directory and all 7 servers are built and placed in the top level directory. The executables expect the “public” and “templates” directories in the same directory they are run from.</p><p> 要构建所有7台服务器，您需要做的全部工作是从顶级目录“全部构建”，然后将所有7台服务器构建并放置在顶级目录中。可执行文件期望运行它们的目录中的“ public”和“ templates”目录。</p><p>  If you don’t understand the Linux API well, you should still be able to follow this series and get a decent enough understanding. I however, do recommend you read more about the Linux programming API. There are innumerable resources to help you out in this regard and that is out of scope as far as this article series goes. Although we will touch over several of Linux’s API categories, our focus will be in mainly in the areas of processes, threads, events and networking. If you don’t know the Linux API well, I encourage you to read the man pages for the system calls and library functions used apart from reading books and articles on their usage.</p><p>  如果您对Linux API的了解不深，那么您仍然应该能够遵循本系列文章，并获得足够体面的理解。但是，我建议您阅读有关Linux编程API的更多信息。在这方面，有无数的资源可以帮助您，而就本系列而言，这已经超出了范围。尽管我们将探讨Linux的API类别，但我们的重点将主要放在流程，线程，事件和网络方面。如果您不太了解Linux API，建议您阅读系统手册和库函数的手册页，并阅读有关其用法的书籍和文章。</p><p>  One thought about performance and scalability. There is no relationship between them, theoretically speaking. You can have a web service that performs really well, responds within a few milliseconds, but does not scale at all. Similarly, there can be a badly performing web application that takes several seconds to respond, but scales to handle tens of thousands of concurrent users. Having said that, the combination of high-performance, highly scalable services is very powerful. High-performance applications use resources sparingly in general and are thus efficient at serving more concurrent users per server, driving down costs, which is a good thing.</p><p>一种关于性能和可伸缩性的想法。从理论上讲，它们之间没有关系。您可以拥有一个性能很好的Web服务，可以在几毫秒内响应，但根本无法扩展。同样，可能存在性能不佳的Web应用程序，该应用程序需要花费几秒钟来响应，但是可以扩展以处理成千上万的并发用户。话虽如此，高性能，高可扩展性服务的组合非常强大。高性能应用程序通常很少使用资源，因此可以有效地为每台服务器服务更多的并发用户，从而降低成本，这是一件好事。</p><p>  Finally, there are always only two possible types of tasks in computing: I/O bound and CPU bound. Getting requests over the internet (network I/O), serving files (network and disk I/O), talking to a database (network and disk I/O) are all I/O bound activities. Several types of DB queries can use a bit of CPU, though (sorting, calculating the mean of a million results, etc). Most of the web applications you will build will be I/O bound and the CPU will rarely be used to its full capacity. When you see a lot of CPU being used in a I/O bound application, it most likely points to poor application architecture. This could mean that the CPU essentially is being spent in process management and context switching overhead–and that’s not exactly very useful. If you are doing things like heavy image processing, audio file conversion or machine learning inference, then your application will tend to be CPU bound. However, for the majority of applications, this won’t be the case.</p><p>  最后，计算中总是只有两种可能的任务类型：I / O绑定和CPU绑定。通过Internet获取请求（网络I / O），提供文件（网络和磁盘I / O），与数据库对话（网络和磁盘I / O）都是与I / O绑定的活动。不过，几种类型的数据库查询可能会占用一点CPU（排序，计算一百万个结果的平均值等）。您将构建的大多数Web应用程序都将受I / O约束，而CPU几乎不会用尽其全部容量。当您看到在受I / O绑定的应用程序中使用了许多CPU时，很可能表明应用程序体系结构不佳。这可能意味着CPU实际上是在过程管理和上下文切换开销上花费的，这并不是非常有用。如果您正在执行繁重的图像处理，音频文件转换或机器学习推断之类的操作，那么您的应用程序将倾向于受CPU限制。但是，对于大多数应用程序而言，情况并非如此。</p><p>  Writing an article series that is tens of thousands of words becomes easy with help from reviewers. Thanks go out to  Vijay Lakshminarayanan and  Arun Venkataswamy for spending their time reviewing this series and suggesting corrections to several obvious and not-so-obvious problems.</p><p>  在审阅者的帮助下，撰写成千上万个单词的文章系列变得容易。感谢Vijay Lakshminarayanan和Arun Venkataswamy花费他们的时间来回顾本系列，并提出对一些明显但不太明显的问题的更正建议。</p><p>    My name is Shuveb Hussain and I’m the author of this Linux-focused blog. You can  follow me on Twitter where I post tech-related content mostly focusing on Linux, performance, scalability and cloud technologies.</p><p>    我叫Shuveb Hussain，我是这个关注Linux的博客的作者。您可以在Twitter上关注我，在那里我发布与技术相关的内容，主要针对Linux，性能，可伸缩性和云技术。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://unixism.net/2019/04/linux-applications-performance-introduction/">http://unixism.net/2019/04/linux-applications-performance-introduction/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/应用程序/">#应用程序</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>