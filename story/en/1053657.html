<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Dennis Ritchie关于C（1988）的别名分析 Dennis Ritchie on alias analysis in C (1988)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Dennis Ritchie on alias analysis in C (1988)<br/>Dennis Ritchie关于C（1988）的别名分析 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-20 23:36:02</div><div class="page_narrow text-break page_content"><p>This 1998 note by Dennis Ritchie  from comp.lang.c  (and also   here ) is very current since the concept of noalias has definitely crept back into the standard. I have reproduced it verbatim, but lightly formatted for readability. For further reading try  Linus Torvalds (pre-nice ) note,  John Reger’s paper on alias and  this proposal for the C 2x standard.</p><p>1998年1998年由Dennis Ritchie从Comp.Lang.c中的说明非常流行，因为诺纳里亚的概念绝对悄然回到了标准。我已经逐字再现了它，但轻微地格式化了可读性。对于进一步阅读，请尝试Linus Torvalds（Pre-Well）注释，John Reger关于别名的论文以及C 2X标准的这一提议。</p><p>  Reproduced below is the long essay I sent as an official comment to X3J11. It is in two parts; the first points out some problems in the current definition of `const,’ and the second is a diatribe about `noalias.’ By way of introduction, the important thing about `const’ is that the current wording says, in section 3.3.4, that a pointer to a const-qualified object may be cast to a pointer to the plain object, but “If an attempt is made to modify the pointed-to object by means of the converted pointer, the behavior is undefined.” Because function prototypes tend to convert your pointers to const-qualified pointers, difficulties arise.In discussion with various X3J11 members, I learned that this section is now regarded as an inadvertant error, and no one thinks that it will last in its current form. Nevertheless, it seemed wisest to keep my comments in their original strong form. The intentions of the committee are irrelevant; only their document matters.</p><p>  下面转载的是我作为官方评论发送的漫长的文章，对x3j11发送。它有两部分;第一个指出了当前定义的一些问题，“第二个是关于”诺纳里亚斯的诽谤“。”通过介绍，关于“const”的重要事项是当前的措辞，在第3.3.4节中说，指向要素限定对象的指针可以投射到指向普通对象的指针，而是“如果尝试通过转换的指针修改指向对象，则该行为是未定义的。”由于函数原型倾向于将指针转换为规定的指针，因此出现困难。在与各种X3J11成员的讨论中，我了解到本节现在被视为无故障错误，并且没有人认为它将持续到其当前形式。尽管如此，似乎最聪明的是以原来的强大形式留下评论。委员会的意图是无关紧要的;只有他们的文件很重要。</p><p> The second part of the essay is about noalias as such. It seems likely that even the intentions of the committee on this subject are confused.</p><p> 文章的第二部分是关于诺纳里亚斯这样的。似乎也有可能甚至对这个主题委员会的意图困惑。</p><p>   This is an essay on why I do not like X3J11 type qualifiers. It is my own opinion; I am not speaking for AT&amp;T.</p><p>   这是为什么我不喜欢X3J11类型限定符的文章。这是我自己的意见;我不是在＆amp; t。</p><p> Let me begin by saying that I’m not convinced that even the pre-December qualifiers (`const’ and `volatile’) carry their weight; I suspect that what they add to the cost of learning and using the language is not repaid in greater expressiveness. `Volatile,’ in particular, is a frill for esoteric applications, and much better expressed by other means. Its chief virtue is that nearly everyone can forget about it. `Const’ is simultaneously more useful and more obtrusive; you can’t avoid learning about it, because of its presence in the library interface. Nevertheless, I don’t argue for the extirpation of qualifiers, if only because it is too late.</p><p> 让我首先说，我不相信即使是12月前的资格赛（`const'和`挥发性'）携带其体重;我怀疑他们增加了学习成本和使用语言的成本不会以更大的表达偿还。 “挥发性”特别是用于深度应用的散热器，并通过其他方式表达更好。它的主要美德是几乎每个人都可以忘记它。 `const'同时更有用，更令人窒息;由于其在库界面中存在，您无法避免了解它。尽管如此，我不争辩于限定符的剥离，如果只是因为为时已晚。</p><p> The fundamental problem is that it is not possible to write real programs using the X3J11 definition of C. The committee has created an unreal language that no one can or will actually use. While the problems of `const’ may owe to careless drafting of the specification, `noalias’ is an altogether mistaken notion, and must not survive.</p><p> 基本问题是，不可能使用C的X3J11定义来编写真实程序。委员会创造了一种不可能或实际使用的虚幻语言。虽然“const”的问题可能欠粗心起草规范，但是“诺纳里亚斯”是一个完全误解的概念，不得生存。</p><p>     can return its first parameter. This first parameter must be declared with `const noalias;’ otherwise, it would be illegal (by the constraints on assignment, 3.3.16.1) to pass the address of a const or noalias object. That is, the type qualifiers in the prototype are not merely an optional pleasantry of the interface; they are required, if one is to pass some kinds of data to this or most other library routines.</p><p>     可以返回其第一个参数。必须使用“const noalias”声明此第一个参数;否则，它将是非法的（通过分配的约束，3.3.16.1）传递const或noalias对象的地址。也就是说，原型中的类型限定符不仅仅是界面的可选智慧;如果是将某些类型的数据传递给此或大多数其他库例程，则需要它们。 </p><p> Unfortunately, there is no way in X3J11’s language for strchr to return the value it promises to, because of the semantics of return (3.6.6.4) and casts (3.3.4). Whether the stripping of the const and noalias qualifiers is done by cast inside strchr, or implicitly by its return statement, strchr returns a pointer that (because of `const’) cannot be stored through, and (because of `noalias’) cannot even be dereferenced; by the rules, it is useless. (Incidentally, I think this observation was made by Tom Plum several years ago; it’s disconcerting that the inconsistency remains.)</p><p>不幸的是，由于返回的语义（3.6.6.4）和演员（3.3.4），X3J11的语言无法以X3J11的语言返回它所承诺的价值。 const和noalias限定符是通过在strchr中投射的剥离，或通过其返回语句隐式地完成，Strchr返回一个指针（因为`const'）无法存储，并且（因为`noalias'）无法存储被解除引人入胜;通过规则，它是无用的。 （顺便提及，我认为这一观察是汤米梅在几年前制作的;它令人不安地留下了不一致的遗体。）</p><p> Although the plain words of the Standard deny it, plastering the appropriate `non-const’ cast on an expression to silence a compiler is sometimes safe, because the most probable implementation of `const’ objects will allow them to be read through any access path, and will diagnose attempts to change them by generating an access violation fault at run time. That is, in common implementations, adding or taking away the `const’ qualifier of a pointer can never create any bugs not implicit in the rule `do not modify a genuine const object through any access path.’</p><p> 虽然标准的普通词语拒绝它，涂抹适当的“非常数”在表达式上沉默，沉默编译器有时是安全的，因为最可能的“const”对象的实现将允许它们通过任何访问路径读取它们，并将诊断尝试通过在运行时生成访问违规故障来更改它们。也就是说，在常见的实现中，添加或获取指针的“const”限定符不能在规则`中创建未隐含的任何错误`，不会通过任何访问路径修改正版const对象。</p><p> Nevertheless, I must emphasize that this is NOT the rule that X3J11 has written, and that its library is inconsistent with its language. Someone writing an interpreter using X3J11/88-001 is perfectly at liberty to (indeed, is advised to) carry with each pointer a `modifiable’ bit, that (following 3.3.4) remains off when a pointer to a const- qualified object is cast into a plain pointer. This implementation will prevent many of the real uses of strchr, for example. I’m thinking of things like</p><p> 然而，我必须强调这不是X3J11所写的规则，而其图书馆与其语言不一致。使用X3J11 / 88-001编写翻译的人在自由于（确实，建议）随身携带的每个指针，（在3.3.4之后）当指向Const-Pervicized对象时保持关闭被铸成普通指针。例如，此实现将防止STRCHR的许多真实用途。我在想类似的东西</p><p>   A related observation is that string literals are not of type `array of const char.’ Indeed, the Rationale (88-004 version) says, `However, string literals do not have [this type], in order to avoid the problems of pointer type checking, particularly with library functions….’ Should this bald statement be considered anything other than an admission that X3J11’s rules are screwy? It is ludicrous that the committee introduces the `const’ qualifier, and also makes strings unwritable, yet is unable to connect the two conceptions.</p><p>   相关观察是字符串文字不属于Const Char的类型。“的确，理由（88-004版）说，”但是，字符串文字没有[这种类型]，以避免问题指针类型检查，特别是库函数......'如果此秃头语句应该被视为X3J11的规则是搭配的备注以外的任何东西？委员会介绍了“Const”的限定符，并且还使字符串销售，但无法连接这两个概念。</p><p>  `Noalias’ is much more dangerous; the committee is planting timebombs that are sure to explode in people’s faces. Assigning an ordinary pointer to a pointer to a `noalias’ object is a license for the compiler to undertake aggressive optimizations that are completely legal by the committee’s rules, but make hash of apparently safe programs. Again, the problem is most visible in the library; parameters declared `noalias type *’ are especially problematical.</p><p>  “诺纳里亚斯”更危险;委员会正在种植时间爆炸，肯定会在人们的面部爆炸。将普通指针分配到指向“诺纳里亚斯”对象的指针是编译者承担委员会规则完全合法的攻击优化的许可，而是使哈希明显安全。同样，该问题在图书馆中最可见;参数声明为“Noalias类型*”尤其问题。</p><p> In order to write such a library routine using the new parameter declarations, it is in practice necessary to violate 3.3.4: `A pointer to a noalias-qualified type … may be converted to … the non-noalias-qualified type. If the pointed to object is referred to by means of the converted pointer, the behavior is undefined.’ Thus, the problem that occurs with `const’ is now much worse; there are no interesting and legal uses of strchr.</p><p> 为了使用新的参数声明编写此类库例程，实际上是违反3.3.4的实践：“将指向诺纳丽亚级的类型...”可以转换为......非纳义统治类型。如果指向对象通过转换的指针引用，则该行为是未定义的。“因此，”const“发生的问题现在更糟糕了; Strchr没有有趣和合法的用途。</p><p> How do you code a routine whose prototype specifies a  noalias pointer? If you fail to violate 3.3.4, but instead try to rewrite the declarations of temporary variables to make them agree in type with parameters, it becomes hard to be sure that the routine works. Consider the specification of strtok:</p><p> 如何代码原型指定诺纳亚州指针的例程？如果您无法违反3.3.4，但是尝试重写临时变量的声明，以使其在类型中同意参数，这变得难以确保例程工作。考虑Strtok的规范： </p><p>  It retains a static pointer to its writable, `noalias’ first argument. Can you be sure that this routine can be made safe under the rules? I have studied it, and the answer is conditionally yes, provided one accepts certain parts of the Standard as gospel (for example that `noalias’ handles will NOT be synchronized at certain times) while ignoring other parts. It is a very dodgy thing. For other routines, it is certain that complete rewriting is necessary: qsort, for example, is full of pointers that rove the argument array and change it here and there. If these local pointers are qualified with `noalias,’ they may all be pointing to different virtual copies of parts of the array; in any event, the argument itself may have a virtual object that might be completely untouched by the attempt to sort it.</p><p>它保留了一个静态指针，以其可写的，“诺纳里亚斯”的第一个参数。您可以确定此例程可以在规则下安全吗？我已经研究过它，答案是有条件的，所以提供标准的某些部分作为福音（例如，“诺纳里亚斯”句柄在某些时间不在某些时间时不会同步）。这是一个非常狡猾的事情。对于其他例程，确定需要完整的重写：例如，QSORT充满了指针，该指针将参数阵列传播并在此处更改它。如果这些本地指针与“诺亚斯”有资格，则它们可能都指向阵列部分的不同虚拟副本;在任何情况下，参数本身都可能具有可能通过尝试对其进行排序的虚拟对象。</p><p> The `noalias’ rules have the assignment and cast restrictions backwards. Assigning a plain pointer to a const- qualified pointer (pc = p) is well-defined by the rules and is safe, in that it restricts what you can do with pc. The other way around (p = pc) is forbidden, presumably because it creates a writable access path to an unwritable object. With `noalias,’ the rules are the same (pna = p is OK, p = pna is forbidden), but the realistic safety requirements are completely different. Both of these assignments are equally suspicious, in that both create two access paths to an object, one manifestation of which might be virtual.</p><p> “诺纳里亚斯”规则向后有分配和压铸限制。将普通指针分配给规则指针（PC = P）由规则很好地定义，并且是安全的，因为它限制了您可以使用PC执行的操作。禁止（P = PC）周围的另一种方式，推测，它是因为它创建了不可写入对象的可写访问路径。对于“诺亚丽莎”，“规则是相同的（PNA = P是OK，禁止PNA），但逼真的安全要求完全不同。这两个分配同样可疑，因为这两个都会为对象创建两个访问路径，其中一个表现为虚拟。</p><p> Here is another way of observing the asymmetry: the presence of `const type *’ in a parameter list is a useful piece of interface information, but `noalias type *’ most assuredly is not. Given the declaration</p><p> 这是观察不对称的另一种方法：参数列表中的“const类型*”存在是一块有用的接口信息，但是最令人愉快的“Noalias类型*”不是。鉴于宣言</p><p>  what information can one glean from it? Some committee members apparently believe that it conveys either to the reader or to the compiler that the routine is safe, provided that the strings do not overlap. They are mistaken. Perhaps the committee’s intent is not reflected in the current words of the Standard, but I can find nothing there that justifies their belief. The rules (page 65, lines 19-20) specify `all objects accessible by these [noalias] lvalues,’ which is the entirety of both array arguments.</p><p>  什么信息可以从中收集？有些委员会成员显然认为它传达给读者或编译器，即常规是安全的，条件是字符串不重叠。他们被误解了。也许委员会的意图没有反映在目前的标准的话语中，但我可以在那里找到任何证明他们的信仰。规则（第65行，第19-20行）指定了这些[noalias] lvalues可访问的所有对象，这是两个数组参数的整体。</p><p>   Is there anything at all I can conclude about the requirements of magic function? Is there anything at all I can conclude about things it promises to do or not to do? All I learn from the Rationale (page 52) is that such a routine enjoins me from letting the arguments overlap, but this is at variance with the Standard, which gives a stronger injunction.</p><p>   我可以在魔术功能的要求中得出任何东西吗？我可以在有什么东西可以得出关于它承诺的事情或不做的事情吗？我从理由中学到的只是这样的例程禁止我让争论重叠，但这与标准的差异，这带来了更强的禁令。</p><p> Within the function itself, things are equally bad. A `const type *’ parameter, though it presents problems for strchr and other routines, does usefully constrain the function: it’s not allowed to store through the pointer. However, within a function with a `noalias type *’ parameter, nothing is gained except bizarre restrictions: it can’t cast the parameter to a plain pointer, and it can’t assign the parameter to another noalias pointer without creating unwanted handles and potential virtual objects. The interface MUST say noalias, or at any rate DOES say noalias, so the author of the routine has all the grotesque inventions of 3.5.3 (handles, virtual objects) rubbed in his face, like or not.  The utter wrongness of `noalias’ is that the information it seeks to convey is not a property of an object at all. `Const,’ for all its technical faults, is at least a genuine property of objects; `noalias’ is not, and the committee’s confused attempt to improve optimization by pinning a new qualifier on objects spoils the language. `Noalias’ is a bogus invention that is not necessary, and not in any case sufficient for its apparent purpose.</p><p> 在功能本身内，事情同样差。 a` const键入*'参数，尽管它为Strchr和其他例程提供了问题，但有用地限制功能：它不允许通过指针存储。但是，在具有`noalias类型*'参数的函数中，除了bizarre限制之外，没有任何内容：它不能将参数投入普通指针，并且它不能将参数分配给另一个诺纳州指针而不创建不需要的句柄潜在的虚拟对象。界面必须说诺纳里亚斯，或者以任何速度都表明诺纳里亚斯，所以例程的作者都有3.5.3（手柄，虚拟物体）的所有怪诞的发明，如此。 “诺纳里亚斯”的完全错误是它旨在传达的信息根本不是对象的属性。 “常备”为所有技术故障，至少是对象的真正财产; “诺纳里亚斯”不是，委员会困惑的尝试通过固定对象上的新限定符来改善优化的困惑破坏了语言。 “诺纳里亚斯”是一个不必要的伪造发明，而不是任何情况都足够了。</p><p> Earlier languages flirted with gizmos intended to help optimization, and generally abandoned them. The original Fortran, for example, had a FREQUENCY statement that didn’t help much, confused people, and was dropped. PL/1 had `normal/abnormal’ and `uses/sets’ attributes that suffered a similar fate. Today, these are generally looked on as adolescent experiments.</p><p> 早期的语言与旨在帮助优化的Gizmos调情，并且通常会抛弃它们。例如，原始的Fortran有一个没有帮助太多，困惑的人的频率陈述，并且被删除了。 PL / 1具有“正常/异常”和“使用/设置”属性，遭受类似的命运。今天，这些通常被视为青少年实验。 </p><p> On the other hand, the insufficiency of `noalias’ is suggested by Cray’s Fortran compiler, which has 20 separate keywords that control various details of optimization. The are specified by an equivalent of #pragma, and thus, despite their oddness, can be ignored when trying to understand the meaning of a program. Perhaps there is some reason to provide a mechanism for asserting, in a particular patch of code, that the compiler is free to make optimistic assumptions about the kinds of aliasing that can occur. I don’t know any acceptable way of changing the language specification to express the possibility of this kind of optimization, and I don’t know how much performance improvement is likely to result. I would encourage compiler-writers to experiment with extensions, by #pragma or otherwise, to see what ideas and improvements they can come up with, but I am certain that nothing resembling the noalias proposal should be in the Standard.</p><p>另一方面，CRAY的Fortran编译器建议了“诺纳里亚斯”的不足，其中有20个单独的关键字，可以控制优化的各种细节。该等同于#Pragma等效，因此，尽管他们在尝试理解程序的含义时，可以忽略它们。也许有一些原因来提供用于在特定代码的特定代码中断言机制，编译器可以自由地对可能发生的锯齿的种类进行乐观假设。我不知道改变语言规范的任何可接受的方式，以表达这种优化的可能性，我不知道可能会产生多少性能改善。我会鼓励编译器编写者通过#Pragma或其他方式进行扩展，看看他们可以提出哪些想法和改进，但我确信任何类似诺纳里亚斯提案的情况都应该是标准。</p><p>  K&amp;R C has one important internal contradiction (variadic functions are forbidden, yet printf exists) and one important divergence between rule and reality (common vs. ref/def external data definitions). These contradictions have been an embarrassment to me throughout the years, and resolving them was high on X3J11’s agenda. X3J11 did manage to come up with an adequate, if awkward, solution to the first problem. Their solution to the second was the same as mine (make a rule, then issue a blanket license to violate it).</p><p>  K＆amp; R C具有一个重要的内部矛盾（禁止禁止打印函数的变量函数）和规则与现实之间的一个重要分歧（常见的与ref / def外部数据定义）。这些矛盾在整个年内对我来说是一种尴尬，解决它们在X3J11的议程上很高。 X3J11确实设法提出了足够的，如果尴尬，解决了第一个问题。他们的解决方案与我的第二个相同（制定规则，然后发出毯子许可证违反它）。</p><p> I’m aware that there are distinctions to be made between `conforming’ and `strictly conforming’ programs. Although the X3J11 rules for qualifiers are inconsistent, and therefore most nominally X3J11 compilers will ignore, or only warn about, casts and assignments that X3J11 says are undefined, people will somehow survive. C has, after all, survived the vararg and the extern problems.</p><p> 我知道“符合”和“严格符合”程序之间存在区别。虽然X3J11的限定符规则不一致，因此大多数名义上的X3J11编译器将忽略，或者只有警告，X3J11所说的，X3J11所说的，人们会以某种方式幸存下来。毕竟，C有浪费差异和外部问题。</p><p> Nevertheless, I advise strongly against sanctifying a language specification that no one can possibly embody in a useful compiler. This advice is based on bitter experience.</p><p> 尽管如此，我强烈建议坚定地了解语言规范，没有人可以在有用的编译器中体现。这个建议是基于痛苦的体验。</p><p>   It must not be reworded, reformulated or reinvented. The draft’s description is badly flawed, but that is not the problem. The concept is wrong from start to finish. It negates every brave promise X3J11 ever made about codifying existing practices, preserving the existing body of code, and keeping (dare I say it?) `the spirit of C.’</p><p>   不得重新重写，重新格式化或重新发明。草案的描述缺陷，但这不是问题。从开始完成这个概念是错误的。它否定了每个勇敢的承诺x3j11，曾经做过编纂现有实践，保留现有的代码组，并保持（敢于我说呢？）“C”的精神。“</p><p> Const has two virtues: putting things in read-only memory, and expressing interface restrictions. For example, saying</p><p> const有两个优点：将事物放在只读内存中，并表达界面限制。例如，说</p><p>  is a reasonable way of expressing that the routine cannot change the object referred to by its first argument. I think that minor changes in wording preserve the virtues, yet eliminate the contradictions in the current scheme.</p><p>  是一种合理的方式，表明例程无法更改其第一个参数所引用的对象。我认为措辞的微小变化保留了美德，但消除了当前方案中的矛盾。 </p><p> 1) Reword page 47, lines 3-5 of 3.3.4 (Cast operators), to remove the undefinedness of modifying pointed-to objects, or remove these lines altogether (since casting non-qualified to qualified isn’t discussed explicitly either.)</p><p>1）重写Page 47，3.3.4（铸造运算符）的第3-5行，以删除修改指向对象的未定义，或者完全删除这些行（因为未明确讨论不合格的投射不合格。 ）</p><p> 2) Rewrite the constraint on page 54, lines 14-15, to say that pointers may be assigned without taking qualifiers into account.</p><p> 2）重写第54行，第14-15行的约束，可以在不考虑限定符的情况下分配指针。</p><p> 3) Preserve all current constraints against modifying non-modifiable lvalues, that is things of manifestlyconst-qualified type.</p><p> 3）保留所有目前的限制，反对修改不可修改的百次值，即表现为合格类型的类型。</p><p>  5) Add a constraint (or discussion or example) to assignment that makes clear the illegality of assigning to an object whose actual type is const-qualified, no matter what access path is used. There is a manifest constraint that is easy to check (left side is not const- qualified), but also a non-checkable constraint (left side is not secretly const-qualified). The effect should be that converting between pointers to const- qualified and plain objects is legal and well-defined; avoiding assignment through pointers that derive ultimately from `const’ objects is the programmer’s responsibility.</p><p>  5）将约束（或讨论或示例）添加到分配，以清除分配给实际类型为Const-Pervicied的对象的非法性，无论使用哪种访问路径都可。有一个清单约束，易于检查（左侧不是规定的），而且也是一个非检职约束（左侧不是秘密规格）。效果应该是转换指向规定的和普通物体的指针是合法的，定义的;避免通过指针赋予最终来自“const”对象的指针是程序员的责任。</p><p> These rules give up a certain amount of checking, but they save the consistency of the language.</p><p> 这些规则放弃了一定数量的检查，但它们节省了语言的一致性。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.yodaiken.com/2021/03/19/dennis-ritchie-on-alias-analysis-in-the-c-programming-language-1988/">https://www.yodaiken.com/2021/03/19/dennis-ritchie-on-alias-analysis-in-the-c-programming-language-1988/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/dennis/">#dennis</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ritchie/">#ritchie</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指针/">#指针</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>