<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>您的单页应用程序现在是多边形填充</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">您的单页应用程序现在是多边形填充</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-08 15:43:25</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/a11989acc6f5528002f1596ca436c0d1.jpeg"><img src="http://img2.diglog.com/img/2020/10/a11989acc6f5528002f1596ca436c0d1.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>我们希望我们的Web应用程序感觉“即时”，页面之间没有任何丑陋的空白屏幕提醒我们，我们的应用程序并不是真正的应用程序。</p><p>空白屏幕会造成糟糕的用户体验。用户不想在单击链接或按钮时等待来自服务器的内容。他们希望网站能像本地应用程序一样快速。</p><p>因此，我们构建了单页面应用程序，其中只替换页面中更改的内容，避免重新加载整个页面，因此导航到另一个页面感觉很即时。</p><p>这样做的另一个好处是，现在我们只需要从服务器获取更改的内容，而不是整个新页面。这减少了我们需要从网络获取的数据量，使我们的应用程序速度更快。这是我们构建单页面应用程序的第二个主要原因。</p><p>我们现在绕过浏览器的路由，转而在客户机上自己处理。大多数情况下，还会添加一个前端框架来处理这些页面的呈现，这进一步增加了复杂性。</p><p>当然，现在框架可以做的更多，但这一切都始于消除页面之间的空白屏幕和减小有效负载大小的愿望。</p><p>如果我告诉你，你也可以有一个速度极快的多页应用程序，而页面之间没有任何空白屏幕，会怎么样？</p><p>这是一个不需要任何客户端路由的多页面应用程序，其中每个新页面都是重新加载整个页面，但只从服务器获取更改的内容。</p><p>让多页应用快速运行的诀窍实际上非常简单：我们利用浏览器的流式HTML解析器。</p><p>问题是浏览器在下载时呈现HTML。它不需要等待整个响应到达，但是一旦内容可用，它就可以开始呈现内容。</p><p>FETCH返回的响应对象在其Body属性中公开响应内容的ReadableStream，因此我们可以访问该响应并开始流式传输响应：</p><p>FETCH(&#39；/ome/url&#39；).Then(Response=&gt；response.body).Then(Body=&gt；{const read=body.getReader()；//我们现在可以读取流了！}。</p><p>典型的单页面应用程序使用应用程序外壳，它实际上是注入内容的单个页面。它通常由页眉、页脚和放置每页内容的中间内容区域组成。</p><p>问题是，加载HTML页面后添加到HTML页面的任何内容都绕过了流HTML解析器，因此呈现速度较慢。</p><p>但是，我们可以通过让服务工作者获取我们需要的所有内容，并让它将所有内容流式传输到浏览器，从而从浏览器流中获益。</p><p>为此，我们需要将所有页面拆分为页眉和页脚，缓存这些模板，然后根据需要从网络获取正文内容。</p><p>服务工作者将拦截任何传出请求，获取页眉和页脚，然后确定需要获取哪些正文内容。这可以只是一个简单的HTML模板，也可以是模板和从网络获取的一些数据的组合。</p><p>然后，服务人员会将这些部分组合成一个完整的HTML页面，并将其返回给浏览器。它类似于服务器端呈现，但都是在客户端使用ReadableStream以流方式完成的。</p><p>这意味着它可以在内容和页脚仍在下载时开始呈现页面的页眉，从而带来巨大的性能优势。</p><p>让我们来看一下代码，特别是每当服务工作者截获传出请求时调用的FETCH事件处理程序：</p><p>Const fetchHandler=异步e=&gt；{const{request}=e；const{url，method}=request；const{pathname}=new URL(Url)；const RouteMatch=routes.find(({url})=&gt；url=路径名)；if(RouteMatch){e.respondWith(getStreamedHtmlResponse(url，RouteMatch))；}Else{e.respondWith(caches.Match(Request).Then(Response=&gt；Response？返回：FETCH(REQUEST))；}}；self.addEventListener(&#39；FETCH&#39；，FETchHandler)；</p><p>FetchHandler函数检查传入的请求，并尝试根据请求的url在routes数组中查找匹配的路由：</p><p>对于Home路由(‘/’)，它将在home.js.html中的script标记内找到home.html模板和附带的JavaScript。</p><p>然后，服务工作者将获取模板header.html和footer.html，将它们与home.html和home.js.html组合成一个完整的HTML页面，并将其流回浏览器。</p><p>在前面的示例中，这是在getStreamedHtmlResponse函数中处理的。我们来看一下，</p><p>Const getStreamedHtmlResponse=(url，RouteMatch)=&gt；{const stream=new ReadableStream({async start(Controller){const push ToStream=stream=&gt；{const read=stream.getReader()；return reader.read().Then(function process(Result){if(result t.do){return；}control er.enqueue(result t.value)；return reader.read().Then(Process)；})；}；Const[Header，Footer，Content，Script]=aWait Promise.all([caches.match(&#39；/src/templates/header.html&#39；)，caches.match(&#39；/src/templates/footer.html&#39；)，caches.Match.Match(routeMatch.Template)，caches.Match(routeMatch.script)])；aWait Push ToStream(header.body)；等待Push ToStream(content.body)；等待Push ToStream(footer.body)；Await Push ToStream(script.body)；Controler.Close()；}})；//这里返回主体为流的响应返回新响应(stream，{Headers：{&#39；Content-Type&#39；：&#39；text/html；charset=utf-8&#39；}})；}；</p><p>在getStreamedHtmlResponse内部，我们构造一个新的ReadableStream，该新的ReadableStream将传递一个underlyingSource对象，其中包含在构造流之后立即调用的start方法。</p><p>向Start传递一个控制器参数，该参数是一个ReadableStreamDefaultController，它允许控制ReadableStream的内部状态和队列。</p><p>在start方法内部，我们获取HTML页面的模板，并使用push ToStream函数将模板内容作为单个流推送到主流中。</p><p>此函数逐个块地从模板块中读取各个流，并使用Controler.enqueue()将它们入队。</p><p>因为Start函数是异步的，所以立即返回一个新的响应，并将ReadableStream作为响应的主体。</p><p>浏览器现在可以流式传输响应，页面几乎立即出现在屏幕上。</p><p>让我们静下心来：我们现在可以像单页面应用程序一样，提供即时响应，但不会像单页面应用程序那样复杂。</p><p>这基本上将单页应用程序减少为多页填充，这是一个相当大胆的说法，但原因如下：</p><p>这个多页面应用程序的渲染速度与单页面应用程序一样快，甚至在页面大小增加时更快，因为我们使用了浏览器的流式HTML解析器。单页面应用程序绕过流解析器，无法利用它。</p><p>就像在单页应用程序中一样，只从网络获取更改的内容。但是，因为服务工作者缓存所有资产并在本地为它们提供服务，所以网络流量被限制在绝对最低限度。</p><p>您的应用程序的复杂性将大大降低。不再需要客户端路由，也不需要框架来呈现页面。服务工作器负责所有呈现，并在独立于主UI线程的自己的线程中操作。</p><p>服务器端渲染是免费的，只需将单独的模板缝合在一起，并像任何其他HTML页面一样提供服务。当服务工作者尚未控制页面时，这些将在第一次呈现时提供。在随后的呈现中，服务工作者将无缝地为缓存的页面提供服务，因为没有客户端路由需要处理。</p><p>现在你可能会想，当谈到速度和性能时，像这样的多页面应用程序是否真的能胜过单页面应用程序。</p><p>我创建了一个演示，这样您就可以亲身体验一下使用流HTML的多页面应用程序可以有多快。您可以在Github上找到源代码。</p><p>如果您在周围单击，您会注意到页面的页眉仍然牢牢地保持在原位，即使每个页面都需要重新加载整个页面，而且有些页面相当重。</p><p>如果我们使用流HTML解析器，这就是浏览器呈现DOM的能力。</p><p>浏览器并不慢。DOM并不慢。我们试图将单页面应用程序模型硬塞到一个本质上是多页的媒介中，通过向它扔框架和大量的库，这让它变得很慢。</p><p>使用服务工作者并正确使用浏览器的流式HTML解析器可以极大地提高Web应用程序的性能，并且通常完全违背了拥有单页面应用程序的目的。</p><p>与其向你的应用程序扔一个框架和十几个库，不如保持它的简单性，并使用这个平台。</p><p>你可以在Twitter上关注我，在那里我经常写关于PWAS、Web组件和现代Web功能的文章。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://itnext.io/your-single-page-app-is-now-a-polyfill-7881fb01694e">https://itnext.io/your-single-page-app-is-now-a-polyfill-7881fb01694e</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/应用程序/">#应用程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/page/">#page</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/页面/">#页面</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1027862.html"><img src="http://img2.diglog.com/img/2020/10/thumb_cad5a7a72a80022eef6a032d093c3bf2.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1027862.html">
Instagram的Thread应用程序现在可以让你给每个人发消息，就像它的Direct应用程序曾经做的那样</a></div><span class="my_story_list_date">2020-10-8 9:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1027780.html"><img src="http://img2.diglog.com/img/2020/10/thumb_ea52f80aea2864ecd97d94978869c463.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1027780.html">
前苹果工程师和自动更正创建者开发了他的第一款应用程序，一款名为Up Spell的文字游戏</a></div><span class="my_story_list_date">2020-10-8 2:16</span></div><div class="col-sm"><div><a target="_blank" href="/story/1027738.html"><img src="http://img2.diglog.com/img/2020/10/thumb_dbdff673c4316c956ec8e6eada2c8e5d.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1027738.html">MetaMask是一款Etherum浏览器扩展和Wallet应用程序，也是分散应用程序的接入点，它增加了令牌交换功能，在Firefox中首当其冲</a></div><span class="my_story_list_date">2020-10-7 19:31</span></div><div class="col-sm"><div><a target="_blank" href="/story/1027623.html"><img src="http://img2.diglog.com/img/2020/10/thumb_06d8d8b383ef31912ae237f0d4470bb5.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1027623.html">TikTok用户推送诈骗应用程序赚了50万美元-直到一名12岁的孩子举报了他们</a></div><span class="my_story_list_date">2020-10-7 15:37</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>