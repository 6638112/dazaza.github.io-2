<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Kademlia P2P协议：一种设计规范</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Kademlia P2P协议：一种设计规范</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-12 21:34:56</div><div class="page_narrow text-break page_content"><p>Kademlia是用于对等网络的通信协议。它是分布式哈希表(DHT)的众多版本之一。</p><p>Kademlia网络的特征是三个常数，我们称之为α、B和k。第一个和最后一个是标准项。引入第二个密钥是因为某些Kademlia实现使用不同的密钥长度。</p><p>Alpha是一个小数字，表示网络调用的并行度，通常为3。</p><p>B是用于标识节点以及存储和检索数据的密钥的位大小；在Basic Kademlia中，这是160，即SHA1摘要(散列)的长度。</p><p>K是存储在存储桶中的最大联系人数；通常为20。</p><p>还可以方便地介绍几个在最初的Kademlia论文中找不到的其他常数。</p><p>TExpire=86400s，键/值对过期的时间；这是从原始发布日期算起的生存时间(TTL。</p><p>TReplicate=3600s，当节点需要发布其整个数据库时，Kademlia复制事件之间的间隔</p><p>TRePublish=86400s，原始发布者必须在此时间之后重新发布键/值对。</p><p>TRePublish和tExpire相等这一事实引入了竞争条件。正在发布的数据的存储可能会在节点过期后立即到达节点，因此实际上需要将数据放到网络上。明智的实现会使tExpire比tRePublish长得多。经验表明，t=86410就足够了。</p><p>Kademlia网络由多个相互协作的节点组成，这些节点相互通信并为彼此存储信息。每个节点都有一个节点ID，这是在网络中标识它的准唯一二进制数。</p><p>在网络中，数据块(值)也可以与相同固定长度的二进制数B(值的密钥)相关联。</p><p>需要值的节点在它认为最接近键的节点处搜索该值。需要保存值的节点将其存储在它认为最接近与该值相关联的键的节点处。</p><p>节点ID是长度为B=160位的二进制数。在Basic Kademlia中，每个节点通过某种未指定的准随机过程选择自己的ID。节点ID必须均匀分布，这一点非常重要；网络设计依赖于此。</p><p>虽然协议没有强制这样做，但是只要节点加入网络，就使用相同的节点ID，而不是生成新的特定于会话的节点ID，可能会有一些好处。</p><p>在Kademlia网络中存储或从Kademlia网络检索的数据还必须具有长度为B的密钥。这些密钥也应该均匀分布。有几种方法可以保证这一点；最常见的方法是获取值的散列，例如160位的SHA1摘要。</p><p>Kademlia的操作是基于异或(XOR)作为度量的使用。任意两个密钥或节点ID x和y之间的距离定义为。</p><p>其中^表示XOR运算符。结果是通过对操作数的每个字节进行逐字节异或得到的。</p><p>Kademlia效仿Pastry将键(包括nodeID)解释为大数。这意味着表示键的字节数组中的低位字节是最高有效字节，因此如果两个键靠近，则距离数组中的低位字节将为零。</p><p>Kademlia节点将其联系人(它已知的其他节点)组织在最多容纳k个联系人的存储桶中。这些被称为k桶。</p><p>存储桶按节点和存储桶中的触点之间的距离进行组织。具体地说，对于桶j，其中0&lt；=j&lt；k，我们保证。</p><p>给定非常大的地址空间，这意味着桶0只有一个可能的成员，即与节点ID仅在高位上不同的密钥，并且出于所有实际目的，除了可能在测试中之外，永远不会填充。另一方面，如果节点ID均匀分布，则很可能所有节点的一半位于桶B-1=159的范围内。</p><p>Kademlia的论文说，k设置的值是这样的，在一个大型网络中，任何一个桶中的所有联系人都不太可能在一小时内消失。任何试图计算此概率的人都应该考虑导致长期联系人优先保留在表中的策略，而不是较新的联系人。</p><p>Kademlia的设计者似乎没有考虑到使用IPv6地址或TCP/IP而不是UDP，或者一个Kademlia节点拥有多个IP地址的可能性。</p><p>在存储桶内，联系人按最近通信的时间排序，最近通信的联系人在列表的末尾，最近最少通信的联系人在最前面，而不管是节点还是联系人启动了消息序列。</p><p>每当一个节点接收到来自另一个节点的通信时，它都会更新相应的存储桶。如果联系人已存在，则会将其移动到桶的末尾。否则，如果存储桶未满，则在末尾添加新触点。如果存储桶已满，节点将ping位于存储桶列表顶部的联系人。如果最近最少出现联系人在(未指定的)合理时间内没有响应，则将其从列表中删除，并将新联系人添加到尾部。否则，出于存储桶更新的目的，新联系人将被忽略。</p><p>在大型繁忙网络中，当节点等待来自列表头部的联系人的回复时，可能会有来自不在桶中的联系人的另一通信。对于存储桶B-1=159来说，这是最有可能的，它负责网络中大约一半的节点。这种情况下的行为未指明，似乎可能会为DOS(拒绝服务)攻击提供漏洞。</p><p>经验表明，节点往往分为两个明显不同的类别，即瞬时节点和长期节点。这种更新策略对寿命较长的网络给予了强烈的优先考虑，从而促进了网络的稳定。它还针对某些类型的拒绝服务(DOS)攻击提供一定程度的保护，可能包括下面讨论的Sybil攻击。</p><p>最初的Kademlia论文maymo02说，Kademlia协议由四个远程过程调用(&#34；RPC&#34；)组成，但随后指定了在执行这些协议和某些其他协议时必须遵循的过程。似乎最好将这些程序和其他协议添加到我们这里所称的Kademlia协议中。</p><p>此RPC涉及一个节点向另一个节点发送ping消息，另一个节点可能用PONG应答。</p><p>这具有双重效果：ping的接收方必须更新对应于发送方的存储桶；如果有回复，则发送方必须更新适合接收方的存储桶。</p><p>所有RPC数据包都需要携带由发送方分配并在回复中回显的RPC标识符。这是长度为B(160位)的准随机数。</p><p>使用较短消息标识符的实现必须考虑生日悖论，这实际上使得冲突的概率取决于标识符中位数的一半。例如，32位RPC标识符将产生与2^-16成正比的冲突概率，这在繁忙的网络中是一个令人不舒服的小数字。如果标识符被初始化为零，或者由具有相同种子的相同随机数生成器生成，则概率将确实非常高。</p><p>必须能够将ping携带到RPC回复上，以强制或允许发送方(RPC的发送方)向其接收方提供附加信息。这可能是不同的IP地址，也可能是将来通信的首选协议。</p><p>存储RPC的发送方提供密钥和数据块，并要求接收方存储数据并使其可用于以后通过该密钥进行检索。</p><p>虽然没有正式规定这一点，但很明显，除了消息ID之外，初始存储消息必须至少包含要存储的数据(包括其长度)和相关密钥。由于传输可以是UDP，因此消息还需要至少包含发送方的nodeID，而回复则需要包含接收方的nodeID。对任何RPC的回复还应包含操作结果的指示。例如，在没有指定最大数据长度的存储中，接收器显然可能因为空间不足或I/O错误而无法存储数据。</p><p>Find_node RPC包括160位密钥。RPC的接收方为它知道最接近密钥的联系人返回多达k个三元组(IP地址、端口、节点ID)。</p><p>如果可能，收件人必须返回k个三元组。如果它返回它已知的所有联系人，则它可能只返回少于k个。</p><p>此RPC的名称具有误导性。即使RPC的密钥是现有联系人的nodeID，或者实际上如果它是接收者本身的nodeID，接收者仍然需要返回k个三元组。更具描述性的名称应该是find_close_nodes。Find_node的接收者永远不应该返回包含请求者的nodeID的三元组。如果请求者确实收到了这样的三元组，它应该丢弃它。节点绝不能将自己的nodeID作为联系人放入存储桶中。</p><p>Find_Value RPC包括B=160位密钥。如果收件人上存在相应的值，则返回关联的数据。否则，RPC等价于find_node，并返回一组k个三元组。</p><p>本节介绍Kademlia用来定位离键最近的k个节点的算法。必须理解的是，从严格意义上讲，这些不一定是最接近的。此外，该算法是迭代的，尽管本文将其描述为递归。</p><p>搜索通过从最接近适合于正被搜索的关键字的桶的非空k桶中选择阿尔法触点开始。如果该存储桶中的触点少于Alpha，则从其他存储桶中选择触点。将记录最接近目标关键点closestNode的联系人。</p><p>未指定用于选择最近存储桶中的触点的标准。如果该桶内的触点少于阿尔法触点，并且触点是从其他桶获得的，则没有用于选择其他桶或从这些桶中使用哪些触点的规则。</p><p>然后，该节点将并行异步find_*RPC发送到候选列表中的Alpha联系人。每个联系人，如果它是活动的，通常应该返回k个三元组。如果任何阿尔法联系人未能回复，它将被从候选名单中删除，至少是暂时删除。</p><p>然后，该节点用收到的回复中的联系人填充入围列表。这些是离目标最近的。从入围名单中选择另一个Alpha联系人。此选择的唯一条件是尚未联系他们。再一次将find_*RPC并行发送给每一个。</p><p>并行搜索的序列被继续，直到返回的集合中没有节点比已经看到的最接近的节点更近，或者发起节点已经累积了k个已探测并已知为活动接触。</p><p>如果循环没有找到更近的节点，如果closestNode保持不变，则发起节点将向它尚未查询的k个最近节点中的每一个发送find_*RPC。</p><p>在此过程结束时，节点将积累一组k个活动联系人，或者(如果RPC是FIND_VALUE)可能已经找到数据值。可以是一组三元组，也可以将值返回给调用方。</p><p>原有的算法描述不够详细。但是，发起节点似乎维护着k个最近节点的候选列表。在每次迭代期间，选择其中的α进行探测，并相应地进行标记。如果探测成功，入围节点将被标记为活动节点。如果在一段未指定的时间之后没有回复，则从候选列表中删除该节点。随着每组回复的返回，它被用来改进候选列表：回复中更近的节点替换更远的节点(未探测？)。入围列表中的节点。迭代将继续，直到成功探测到k个节点或没有任何改进。</p><p>Kademlia使用值3表示alpha，即使用的并行度。看起来(请参见stutz06)该值是最佳的。</p><p>管理并行性至少有三种方法。第一种方法是启动alpha探测，并等到所有探测都成功或超时后再进行迭代。这称为严格并行。第二种是将飞行中的探测器数量限制在alpha以内；每当探测器返回时，就会发射新的探测器。我们可以称之为有界并行。第三种方法是在似乎合理的延迟(持续时间未指定)之后进行迭代，以便飞行中的探测器数量是alpha的某个较低的倍数。这是松散并行，也是Kademlia使用的方法。</p><p>这是Kademlia商店的运营。发起节点执行一次iterativeFindNode，收集一组k个最接近的联系人，然后向每个联系人发送一个原语存储RPC。</p><p>这是基本的Kademlia节点查找操作。如上所述，发起节点使用迭代节点查找和find_node RPC构建最接近的k个联系人的列表。该列表被返回给调用者。</p><p>这是卡德姆利亚的搜索行动。它作为节点查找进行，因此构建了k个最近联系人的列表。但是，这是使用find_value RPC而不是find_node RPC来完成的。如果在节点查找期间的任何时候返回值，而不是一组联系人，则放弃搜索并返回值。否则，如果没有找到值，则将k个最近联系人的列表返回给调用者。</p><p>当iterativeFindValue成功时，发起方必须将键/值对存储在最近的未返回值的节点上。</p><p>如果在任何给定的存储桶范围内都没有为tRefresh执行节点查找(在Basic Kademlia中为一小时)，则节点在该范围内选择一个随机数并使用该数字作为键进行刷新，即iterativeFindNode。</p><p>它将某个已知节点c的值作为其第一个联系人插入到适当的存储桶中。</p><p>它刷新比其最近邻居更远的所有存储桶，后者将位于索引最低的已占用存储桶中。</p><p>如果节点保存了一个良好联系人列表，并将其中一个用作&#34；已知节点&#34；，则它将与此协议一致。</p><p>数据使用iterativeStore存储，其效果是在离键最近的k个节点上复制数据。</p><p>每个节点以tReplicate秒为间隔(每小时)重新发布它包含的每个键/值对。不能将重新发布节点视为键/值对的原始发布者。</p><p>键/值对的原始发布者每隔tRePublish秒(每24小时)重新发布一次。</p><p>当iterativeFindValue成功时，发起方必须将键/值对存储在最近的未返回值的节点上。</p><p>为所有键/值对分配一个过期时间，该时间与当前节点和其ID最接近键的节点之间的节点数成指数反比，其中该数字是从当前节点的桶结构推断的。</p><p>当键/值对被存储时，编写器将使用类似于以下内容的内容来计算过期时间：</p><p>要求数据在最初发布日期之后(一天)过期，这一要求非常含糊，似乎意味着任何数据都不能重新发布。在任何情况下，系统都需要用原始发布时间戳标记存储的键/值对。如果这是准确的，时间戳必须由发布者设置，这意味着时钟必须至少在整个网络上松散地同步。使用数据到达时的生存时间(TTL)来标记键/值对似乎是明智的，tExpire(一天)或其中的一小部分。</p><p>RTT(往返时间)值或一组这样的值，以毫秒为单位。</p><p>将一个或一组RTT添加到联系人数据结构将使您能够在选择使用哪个RTT时做出更好的决定。</p><p>可以使用ping RPC或使用传统的互联网ping来测量到联系人的往返时间(RTT)。</p><p>实现者应该注意避免护送效应。当多个进程需要轮流使用一个资源时，就会出现这种情况。这种突发的活动有向同步漂移的趋势，这可能是灾难性的。在Kademlia中，所有节点都需要每小时重新发布其内容(TReplicate)。护送效应可能会导致这种情况在整个网络中同步，这对用户来说就像网络每小时都会死掉一样。</p><p>实现者应该记住，随机数生成器通常是不可重入的，因此需要同步来自不同线程的访问。</p><p>另外，请注意时钟粒度：在使用时钟为随机数生成器设定种子的情况下，连续调用可能使用相同的种子。</p><p>为了提高效率，商店RPC应该是两阶段的。在第一阶段中，发起方发送密钥和可能的长度，而接收方则用等同于OK的内容或代码来回复，该代码表示它已经具有该值或其他状态代码。如果回复为OK，则发起方可以发送该值。</p><p>还应考虑开发处理分层数据的方法。有些值会很小，适合UDP数据报。但有些消息会非常大，比如超过5 GB，需要分块。相对于UDP数据包，数据块本身可能非常大，通常约为128KB，因此这些数据块必须被分解成单独的UDP数据包。</p><p>如前所述，要求tExpire和tRePublish具有相同的值引入了争用条件：数据在到期后将频繁地立即重新发布。合理的做法是使过期间隔tExpire略大于重新发布间隔tRePublish。该协议当然还应该允许商店RPC的接收方回复它已经拥有数据，以节省昂贵的网络带宽。</p><p>Douceur02的John Douceur的一篇论文描述了一种网络攻击，在该攻击中，攻击者选择节点ID，这些节点ID的值使他们能够在网络中以最适合中断操作的模式定位自己。例如，要从网络中删除数据项，攻击者可能会聚集在其密钥周围，接受任何存储密钥/值对的尝试，但在提供密钥时从不返回值。</p><p>Sybil的变体是Spartacus攻击，攻击者加入网络时声称与其他成员具有相同的节点ID。正如规定的那样，卡德姆利亚没有任何辩护。具体地说，长寿节点总是可以窃取短命节点的nodeID。</p><p>Douceur的解决方案是要求所有节点从中央服务器获取其节点ID，该服务器至少负责确保节点ID的分布是均匀的。</p><p>一种较弱的解决方案是要求从节点的网络地址或某些其他准唯一值导出节点ID。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://xlattice.sourceforge.net/components/protocol/kademlia/specs.html">http://xlattice.sourceforge.net/components/protocol/kademlia/specs.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/p2p/">#p2p</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/节点/">#节点</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1028168.html"><img src="http://img2.diglog.com/img/2020/10/thumb_de2e6e42c27b0348e7a0987a08993504.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1028168.html">设计电池的速度足够快，可以像加油一样充电</a></div><span class="my_story_list_date">2020-10-11 21:46</span></div><div class="col-sm"><div><a target="_blank" href="/story/1028124.html"><img src="http://img2.diglog.com/img/2020/10/thumb_f40a788a2bd0e9737807db3d3abeb321.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1028124.html">OnePlus在发布前展示OnePlus 8T设计</a></div><span class="my_story_list_date">2020-10-11 17:15</span></div><div class="col-sm"><div><a target="_blank" href="/story/1027942.html"><img src="http://img2.diglog.com/img/2020/10/thumb_0311ac3b4a64b83a31346579b885dd4a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1027942.html">Julia程序设计语言的不合理有效性</a></div><span class="my_story_list_date">2020-10-11 15:46</span></div><div class="col-sm"><div><a target="_blank" href="/story/1027887.html"><img src="http://img2.diglog.com/img/2020/10/thumb_10cab046a3d86464a5c0afd879a64393.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1027887.html">如何设计算法(2018)</a></div><span class="my_story_list_date">2020-10-8 12:39</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>