<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Nim Apocrypha，第一卷 一世 Nim Apocrypha, Vol. I</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Nim Apocrypha, Vol. I<br/>Nim Apocrypha，第一卷 一世 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-23 21:30:47</div><div class="page_narrow text-break page_content"><p>Greetings fellow Nim adventurers! Below you will find 16 handy Nim tips&amp; tricks I came across while developing a medium-sized GUI program this year, Gridmonger( and related libraries). Some of them areabout less known or undocumented Nim features or standard library functions,a few are workarounds for some rough edges of the language, and there’s alsoa handful of useful techniques I read about in forums or have invented on myown.</p><p>问候尼姆冒险家们！您将在下面找到16个便捷的Nim提示和放大器;我在今年开发中型GUI程序Gridmonger（和相关库）时遇到的技巧。其中一些是鲜为人知或未记录的Nim功能或标准库函数，一些是该语言某些粗糙边缘的变通办法，还有一些有用的技术，我在论坛上了解到或由我自己发明。</p><p> All tips are for Nim 1.4.2 and beyond, and most are applicable to theC backend. I hope you’ll find something useful here that will make your timewith Nim more enjoyable and productive!</p><p> 所有技巧均适用于Nim 1.4.2及更高版本，并且大部分适用于C后端。希望您会在这里找到有用的东西，这将使您与Nim在一起的时光更加有趣和富有成效！</p><p>   Nim touts itself as a language capable of generating small native binaries.But just naively compiling some program with  nim c -d:release and looking atthe file sizes will make you wonder about the validity of that claim!</p><p>   Nim吹捧自己是一种能够生成小型本机二进制文件的语言。但是，仅仅使用nim c -d：release天真地编译某些程序并查看文件大小会让您怀疑该声明的有效性！</p><p> A release build of  Gridmongerweighs around 12 megs. Anything but small, if you ask me!  Sure, itstatically links  GLFW and NanoVG and a bunch of other Nimlibraries, but to put things into perspective,  REAPER (ahighly-advanced and complex DAW written in C/C++) is about the same size at~13 megs! Surely, my program is much simpler than REAPER, so what’s going onhere?</p><p> Gridmonger的发行版本重约12兆。如果你问我，除了小东西什么都不要！当然，它静态地链接了GLFW和NanoVG以及许多其他Nimlibraries，但是从透视的角度来看，REAPER（用C / C ++编写的高级而复杂的DAW）的大小大致相同，约为13兆！当然，我的程序比REAPER简单得多，那么这里发生了什么？</p><p> It turns out that gcc debug symbols are included in Nim binaries by default,which can account for a quite substantial 2-to 5-fold size increase! Luckily,we can remove them easily with the  strip command which comes with gcc.</p><p> 事实证明，默认情况下，Nim二进制文件中包含gcc调试符号，这可能会导致大小增加2到5倍！幸运的是，我们可以使用gcc附带的strip命令轻松删除它们。</p><p> How about trying to optimise for a small executable with  --opt:size? Sure,that would yield about 30% smaller binaries, but at the expense of somepotential runtime performance loss. So while it might not always be the bestoption, but you can always it  and strip the debug symbols for even biggersavings.</p><p> 如何尝试使用--opt：size优化小型可执行文件？当然，这将产生大约30％的二进制文件，但以潜在的运行时性能损失为代价。因此，尽管它不一定总是最佳选择，但是您可以始终使用它，并去除调试符号以节省更多成本。</p><p> Finally, if you’re hell-bent on producing smallest possible binary,compressing it with an executable packer like  UPXcould be just the ticket.</p><p> 最后，如果您想产生尽可能小的二进制文件，那么使用UPX之类的可执行打包程序对其进行压缩可能只是问题所在。 </p><p>      It is important to note that the presence of debug symbols in a binary  doesnot affect its runtime performance whatsoever. This is because debug symbolsare not even loaded into memory during normal use, only when debugging. Soreally it only affects the space the executable takes up on disk.</p><p>重要的是要注意，二进制文件中调试符号的存在不影响其运行时性能。这是因为在正常使用期间，只有在调试时，调试符号才会加载到内存中。严重的是，它仅影响可执行文件在磁盘上占用的空间。</p><p> In case you’re wondering, you’ll still get nice Nim stack traces witha stripped binary if you compiled it with  -d:debug or  --stacktrace=on--linetrace=on (more on that in the next tip).</p><p> 如果您想知道，如果您使用-d：debug或--stacktrace = on--linetrace = on对其进行了编译，您仍然可以获得带剥离二进制文件的Nim堆栈跟踪（在下一个技巧中有更多介绍）。</p><p>  Creating a release build with  -d:release gives you a speed boost, but atthe price of turning off stack traces (among other things). This can be a problemif you’re trying to implement a crash-reporting mechanism for end-users,which involves surrounding your main method with a  try/except block andwriting exceptions with stack traces to a log file.</p><p>  使用-d：release创建一个发布版本可以提高速度，但是要以关闭堆栈跟踪为代价。如果您要尝试为最终用户实现崩溃报告机制，则可能会遇到问题，该机制涉及将您的主要方法包含在try / except块中，并将带有堆栈跟踪的异常写入日志文件。</p><p> Luckily, you don’t need to ship debug builds to your users just to be able todo that; you can still use  -d:release to get most optimisation benefitswhile turning stack traces back on with  --stacktrace=on --linetrace=on. Theperformance of the resulting binary might be a bit slower, but you know, lifeis all about the right trade-offs.</p><p> 幸运的是，您无需将调试版本交付给用户即可。您仍然可以使用-d：release以获得最大的优化收益，同时使用--stacktrace = on --linetrace = on重新打开堆栈跟踪。生成的二进制文件的性能可能会稍慢一些，但要知道，生命只在于正确的权衡。</p><p>  Nim defaults to the  refc garbage collector (deferred reference counting witha mark &amp; sweep phase for cycle collection), which works very well, even forsoft-realtime requirements. But did you know that there has been a brand newGC introduced in 1.2.x that offers reduced memory footprint and even betterperformance in most cases?</p><p>  Nim默认为refc垃圾收集器（用于循环收集的带有标记和清除阶段的递延引用计数），即使对于软件实时要求，也可以很好地工作。但是您是否知道在1.2.x中引入了全新的GC，在大多数情况下可以减少内存占用并提供更好的性能？</p><p> This is ARC, the fully deterministic Automatic Reference Counting garbagecollector. Switching to ARC is as easy as supplying the  --gc:arc option tothe compiler. It’s a drop-in replacement for most programs. Depending on yourprogram, you might want to use it with the  --deepcopy:on--hint[Performance]:off options.</p><p> 这是ARC，它是完全确定性的“自动引用计数”垃圾收集器。切换到ARC就像向编译器提供--gc：arc选项一样容易。它是大多数程序的直接替代品。根据您的程序，您可能希望将其与--deepcopy：on--hint [Performance]：off选项一起使用。</p><p> ARC has many other benefits, including hard realtime support, shared heapsbetween threads, and simplifying the C FFI. Mind you, ARC cannot handlecyclic data structures. But it has a big brother called ORC, which adds supportfor that.</p><p> ARC具有许多其他好处，包括硬实时支持，线程之间的共享堆以及简化C FFI。请注意，ARC无法处理循环数据结构。但是它有一个叫做ORC的老大哥，为此增加了支持。 </p><p> You can learn more about ARC and ORC in this  excellent blogposton the Nim website.</p><p>您可以在Nim网站上的出色博文中了解有关ARC和ORC的更多信息。</p><p>  Setting the icon for Windows executables is probably easier with VisualStudio, but anyhow, here are the instructions for gcc/MinGW that I’m using.</p><p>  使用VisualStudio可能更容易为Windows可执行文件设置图标，但是无论如何，这是我使用的gcc / MinGW的说明。</p><p> First, you’ll need to generate an  .ico file that contains your icon imagein multiple resolutions. There’s lots of online tools for that, and there’salso ImageMagick—this is outside the scope of this article.</p><p> 首先，您需要生成一个.ico文件，其中包含多种分辨率的图标图像。有很多在线工具可以使用，还有ImageMagick，这不在本文讨论范围之内。</p><p>  Once you have your image, you’ll need to create a resource definition  .rcfile that references your icon file. I used  appicon here for the ID, butyou can use any other string, it doesn’t matter:</p><p>  拥有图片后，您需要创建引用图标文件的资源定义.rcfile。我在这里使用了appicon作为ID，但是您可以使用其他任何字符串，都没关系：</p><p>  The next step is to create the resource object file from the  .rc file( windres is included in MinGW):</p><p>  下一步是从.rc文件创建资源对象文件（windres包含在MinGW中）：</p><p>  This will be a rather short one but it took me a while to figure it out. Itturns out that when you link against the Windows libraries by passing -mwindows to the linker ( -L:-mwindows), you won’t be able to print stuffthe console with  echo anymore.</p><p>  这将是一个相当短的过程，但是我花了一些时间才弄清楚。结果表明，当您通过将-mwindows传递给链接程序（-L：-mwindows）与Windows库进行链接时，将无法再打印带有回显的控制台内容。</p><p> “But this is a useless tip, of course you need to link against the Windowslibs in a GUI program!”, I hear you say. Well, not necessarily. In GLFW apps,for example, you can get away with not linking against the Windows libs inmany cases. For instance, in Gridmonger I only need  -mwindows so I can openthe standard open and save system dialogs. In my debug builds, I don’t linkagainst the Windows libs and I conditionally turn the calls to the dialogfunctions to no-ops, and then I can do my debug printing to the console.</p><p> “但这不是一个有用的技巧，当然您需要在GUI程序中链接Windowslibs！”，我听到您说。好吧，不一定。例如，在GLFW应用程序中，在很多情况下，您无需链接到Windows库就可以摆脱困境。例如，在Gridmonger中，我只需要-mwindows，这样我就可以打开标准的打开和保存系统对话框。在调试版本中，我没有针对Windows库进行链接，而是有条件地将对dialogfunctions的调用转为no-ops，然后可以将调试打印到控制台。 </p><p>   The usingkeyword is a very useful, but often forgotten language feature. It helps tocut down on redundancy when creating method call style APIs, or when passingcontext objects around.</p><p>using关键字是一个非常有用但经常被遗忘的语言功能。创建方法调用样式API或传递上下文对象时，它有助于减少冗余。</p><p> # Without `using` proc  getFloor * ( l :  Level ,  row ,  col :  Natural ,  a :  var  AppContext ):  Floor  =  ... proc  setFloor * ( l :  Level ,  row ,  col :  Natural ,  f :  Floor ,  a :  var  AppContext )  =  ... # With `using` using  l :  Level using  a :  var  AppContext proc  getFloor * ( l ;  row ,  col :  Natural ;  a ):  Floor  =  ... proc  setFloor * ( l ;  row ,  col :  Natural ,  f :  Floor ;  a )  =  ...</p><p> ＃不使用proc getFloor *（l：Level，row，col：Natural，a：var AppContext）：Floor = ... proc setFloor *（l：Level，row，col：Natural，f：Floor，a： var AppContext）= ...＃通过l使用`using`：使用a：var AppContext级别proc getFloor *（l; row，col：Natural; a）：Floor = ... proc setFloor *（l; row，col ：自然，f：底数; a）= ...</p><p>  Did you know that the standard library hasa  browsers module for the solepurpose of opening URLs in the OS default browser in a cross-platform way?In fact, I’ve been using Nim for 4 years and I’ve learned about this justrecently!</p><p>  您是否知道标准库具有一个浏览器模块，其唯一目的是以跨平台的方式在OS默认浏览器中打开URL？事实上，我已经使用Nim已有4年了，最近我已经了解了这一点！</p><p> This is very handy if you want to navigate the user to a program’s websitefrom a desktop app, or to open local HTML documentation.</p><p> 如果您要从桌面应用程序将用户导航到程序的网站，或打开本地HTML文档，这将非常方便。</p><p>  Similarly,  getHomeDir() and getConfigDir() from the os module are super handy if you need tohandle configuration files or program data in a cross-platform way.</p><p>  同样，如果您需要以跨平台方式处理配置文件或程序数据，则os模块中的getHomeDir（）和getConfigDir（）超级方便。</p><p>  However sophisticated modern development tools might be, just echoing stuff tothe console is still one of the easiest and quickest ways to debug a program.But writing things like  echo &#34;foo: &#34;, foo for the hundredth time gets oldreally fast. The  dumpmacro in the standard  sugar modulehelps with exactly that.</p><p>  不管复杂的现代开发工具可能是什么，仅将内容回显到控制台仍然是调试程序的最简单，最快的方法之一，但是编写回声＆＃34; foo：＆＃34;之类的东西，在foo的第一百次就变得陈旧了快速。标准制糖模块中的dumpmacro可以提供帮助。</p><p>  import  sugar var  a  =  42  s  =  &#34;frobnicate&#34;  x  =  7 dump ( a ) dump ( s ) dump ( a  +  x ) # prints: # a = 42 # s = frobnicate # a + x = 49</p><p>  进口糖var a = 42 s =＆frobnicate＆＃34; x = 7 dump（a）dump（s）dump（a + x）＃打印：＃a = 42＃s = frobnicate＃a + x = 49 </p><p>  Although you can use the regular  timesmodule to measure elapsed time, to do it properly you really need a monotonictimer. Such a thing has been added to the standard library recently in theform of  std/monotimes.</p><p>尽管您可以使用常规时间模块来测量经过时间，但要正确执行该操作，您确实需要单调计时器。最近，这种东西已经以std / monotimes的形式添加到标准库中。</p><p> import  os import  std / monotimes import  times proc  durationToFloatMillis * ( d :  Duration ):  float64  =  inNanoseconds ( d ). float64  *  1e-6 let  t0  =  getMonoTime () sleep ( 10 )  # do something for a while let  d  =  getMonoTime ()  -  t0 echo  durationToFloatMillis ( d )</p><p> import os import std / monotimes导入时间proc durationToFloatMillis *（d：Duration）：float64 = inNanoseconds（d）。 float64 * 1e-6让t0 = getMonoTime（）睡眠（10）＃做一会儿让d = getMonoTime（）-t0回波durationToFloatMillis（d）</p><p>  Openarraysare a handy Nim feature that allow you to write procedures that can accepteither arrays or sequences through a unified  openArray type. What themanual forgets to tell you though is that there’s a bunch of overloaded  toOpenArrayand toOpenArrayBytemethods in the  system module to helpcreate openarray “slices” from arrays, seqs, strings and (surprise!) otheropenarrays.</p><p>  Openarrays是一种方便的Nim功能，使您可以编写可通过统一的openArray类型接受数组或序列的过程。手动忘记告诉您的是，系统模块中有一堆重载的toOpenArray和toOpenArrayByte方法，以帮助从数组，seq，字符串和其他（令人惊讶的）open数组创建openarray“切片”。</p><p> One particularly useful function is  thisonethat operates on UncheckedArrays—thisis very useful for treating blocks of memory from C libraries asopenarrays in your Nim code.</p><p> 一个特别有用的函数是在UncheckedArrays上运行的函数，这对于将C库中的内存块视为Nim代码中的openarrays非常有用。</p><p> Speaking of the system module, it’s full of useful stuff that’s not mentionedanywhere in the documentation. Make sure to go through the function list oncein a while, I’ll guarantee you’ll find something of interest every time.</p><p> 说到系统模块，它充满了文档中未曾提及的有用内容。请确保不时浏览一下功能列表，我保证您每次都会找到感兴趣的内容。</p><p>   Sometimes you must resort to C-style pointer arithmetics (especially wheninterfacing with C libraries and data structures), and the type-safe nature ofNim doesn’t exactly make that easy. The following templates make such tasksa lot easier (of course, many other variants could be introduced; that’s anexercise for the reader).</p><p>   有时，您必须诉诸C风格的指针算术（尤其是在与C库和数据结构接口时），而Nim的类型安全本质并没有那么简单。以下模板使此类任务更加容易（当然，可以引入许多其他变体；这对读者来说是一个练习）。</p><p> template  ` ++ ` [ A ] ( a :  ptr  A ,  offset :  int ):  ptr  A  =  cast [ ptr  A ] ( cast [ int ] ( a )  +  offset ) template  ` -- ` [ A ] ( a ,  b :  ptr  A ):  int  =  cast [ int ] ( a )  -  cast [ int ] ( b )</p><p> 模板`++`[A]（a：ptr A，偏移量：int）：ptr A = cast [ptr A]（cast [int]（a）+ offset）模板`-`[A]（a，b ：ptr A）：int =强制转换[int]（a）-强制强制转换[int]（b） </p><p>  One of Nim’s Achilles’ heels is the relative inflexibility of the modulesystem when dealing with circular type dependencies. In a project ofsufficient complexity, where you break up your code into multiple submodules,you’ll hit this issue sooner or later almost invariably.  Long storyshort,the best workaround is to create a  common module early on thatcontains all such circular type definitions. Then you can just include thiscommon module in all other submodules.</p><p>Nim的致命弱点之一是模块系统在处理循环类型依赖项时相对僵硬。在一个复杂性很高的项目中，您将代码分成多个子模块，您迟早会无一例外地遇到这个问题。长话短说，最好的解决方法是尽早创建一个包含所有此类循环类型定义的通用模块。然后，您可以将此通用模块包括在所有其他子模块中。</p><p> The biggest drawback of this approach is that everything defined in commonmust be public. But hey, who told you that there’s anything perfect in thisworld?</p><p> 这种方法的最大缺点是，所有共同定义的东西都必须是公开的。但是嘿，谁告诉你这个世界上有什么完美的呢？</p><p>  The tiny  with macro is super useful forreducing redundancy by lifting parts of an object or tuple into thecurrent scope. Probably easier to show than to explain:</p><p>  通过将对象或元组的一部分提升到当前作用域中，带有宏的tiny宏对于减少冗余非常有用。显示起来可能比解释起来容易：</p><p> import  with type  Widget  =  object  backgroundColor :  string  foregroundColor :  string  Window  =  object  title :  string  inputField :  Widget # Without `with` var  mainWindow  =  Window () mainWindow . inputField . backgroundColor  =  &#34;black&#34; mainWindow . inputField . foregroundColor  =  &#34;red&#34; # Using `with` with  mainWindow . inputField :  backgroundColor  =  &#34;black&#34;  foregroundColor  =  &#34;red&#34; # You can nest it too! with  mainWindow :  title  =  &#34;Qux&#34;  with  inputField :  backgroundColor  =  &#34;black&#34;  foregroundColor  =  &#34;red&#34;</p><p> 类型为Widget = object backgroundColor：字符串frontColor：字符串Window =对象标题：字符串inputField：Widget＃不带`with` var mainWindow = Window（）mainWindow。 inputField。 backgroundColor =＆＃34;黑色＆＃34; mainWindow。 inputField。前景色=＆＃34;红色＆＃34; ＃在mainWindow中使用`with`。 inputField：backgroundColor =＆＃34; black＆＃34;前景色=＆＃34;红色＆＃34; ＃您也可以嵌套！使用mainWindow：title =＆＃34; Qux＆＃34;与inputField：backgroundColor =＆＃34; black＆＃34;前景色=＆＃34;红色＆＃34;</p><p>  Even when armed with the above macro, often there’s a need to set up somealiases (references) to some parts of a nested object hierarchy to improvereadability. This comes up quite often in real-world application and UIprogramming. Consider the following:</p><p>  即使配备了上述宏，通常也需要对嵌套对象层次结构的某些部分进行一些别名（引用），以提高可读性。这在实际的应用程序和UI编程中经常出现。考虑以下：</p><p>  Now imagine that most of the program basically operates on this app context insome way or another. It all becomes horribly redundant and unreadable prettyquickly. And you can’t set up C++ style references because of Nim’s copysemantics (unless you keep using  ref objects everywhere, which is not alwaysthe best choice).</p><p>  现在想象一下，大多数程序基本上都以某种方式在此应用程序上下文中运行。这一切都变得非常多余，并且很快变得难以理解。而且由于Nim的复制语义，您无法设置C ++样式引用（除非您一直在各处使用ref对象，但这并不总是最佳选择）。</p><p>  template  alias * ( newName :  untyped ,  call :  untyped )  =  template  newName ():  untyped  =  call alias ( doc ,  g_app . doc ) alias ( map ,  doc . map ) map . levels [ doc . currLevel ] . setFloor ( row ,  col ,  fEmpty )</p><p>  模板别名*（newName：未类型化，调用：未类型化）=模板newName（）：untyped =调用别名（doc，g_app.doc）别名（map，doc.map）map。级别[doc。 currLevel]。 setFloor（row，col，fEmpty） </p><p> That’s much more readable! (Of course, normally you would use those aliasesmore than just once or twice like in this simple example.)</p><p>更具可读性！ （当然，通常您会像在此简单示例中那样使用这些别名一次或两次以上。）</p><p> Another option for introducing proper C++ style references is the recentlyadded (and totally undocumented) byaddr pragma:</p><p> 引入适当的C ++样式引用的另一种方法是addr pragma最近添加的（并且完全未记录）：</p><p> import  std / decls var  a  =  5 var  b  {. byaddr .}  =  a b  =  3 echo  a  # prints 3</p><p> 导入std / decls var a = 5 var b {。 byaddr。} = a b = 3 echo a＃打印3</p><p>   You should save the best for last, or so they say. Well, this one is aboutsaving memory, big time! More experienced C/C++ programmers can go home now asthey should know all about this already—the rest of the class stays.</p><p>   您应该将最好的保存到最后，否则他们会说。好吧，这是关于节省内存的重要时间！更有经验的C / C ++程序员现在可以回家，因为他们应该已经知道了这一切-其余的课程仍然存在。</p><p>  Let’s say we have an object in our program to hold the properties ofa cell of a large(ish) grid/matrix:</p><p>  假设我们在程序中有一个对象来保存大型（ish）网格/矩阵的单元格的属性：</p><p>  Being the sort of resource conscious developers we are, we are dutifullykeeping an eye on our total memory footprint:</p><p>  作为我们这种注重资源的开发人员，我们尽职尽责地关注我们的总内存占用量：</p><p>   type  Direction  =  enum  East ,  West ,  North ,  South type  Cell *  =  object  b :  byte  d :  Direction  echo  sizeof ( Cell )  # prints 2 var  a :  array [ 500  *  500 ,  Cell ] echo  sizeof ( a )  # prints 500000</p><p>   类型Direction =枚举East，West，North，South类型Cell * =对象b：字节d：方向echo sizeof（Cell）＃打印2 var a：array [500 * 500，Cell] echo sizeof（a）＃打印500000 </p><p> Still completely uninteresting. Enums are represented by the smallest possibleinteger type, hence our enum is 1 byte long, which doubles our total memoryrequirements.</p><p>仍然完全没有兴趣。枚举由最小可能的整数类型表示，因此我们的枚举长度为1个字节，这使我们的总内存需求增加了一倍。</p><p> Okay, time to be a bit more adventurous! We’ll insert a string between thebyte and the enum:</p><p> 好吧，是时候冒险一些了！我们将在thebyte和枚举之间插入一个字符串：</p><p>  A Nim string is just a pointer to a sequence of characters, which means we’reexpecting our object to grow by  sizeof(string) == sizeof(pointer) == 8 bytes(on 64-bit). Right? Right???!! I expect people who had been socialised onnice, cushy high-level languages to vehemently agree with me at this point.</p><p>  Nim字符串只是一个指向字符序列的指针，这意味着我们期望对象以sizeof（string）== sizeof（pointer）== 8个字节（64位）增长。对？对？？？！！我希望那些曾经社交过的，轻松的高级语言的人们在这一点上强烈地同意我的观点。</p><p>        Not exactly the answer we wanted, is it? In good old time-tested codertradition, let’s start changing shit randomly in the hope of improving thesituation somewhat!</p><p>        不完全是我们想要的答案，是吗？在久经考验的良好编码条件下，让我们开始随机更改狗屎，以期有所改善！</p><p> type  Cell *  =  object  s :  string  b :  byte  d :  Direction echo  sizeof ( Cell )  # prints 16 echo  sizeof ( a )  # prints 400000</p><p> 类型Cell * =对象s：字符串b：字节d：方向echo sizeof（Cell）＃打印16 echo sizeof（a）＃打印400000</p><p> Um, we just reduced our total memory footprint by 1/3 by putting thestring first. WTF is going on here?</p><p> 嗯，我们只是将字符串放在首位，从而将总内存占用量减少了1/3。 WTF正在这里吗？</p><p>  Nim objects compile down to C structs (with the C backend), which are governedby strictly defined ordering and memory alignment requirements in thestandard. The exact story varies a bit on each CPU architecture, but onx86/x64 the following main rules hold true:</p><p>  Nim对象可编译为C结构（带有C后端），这些结构由标准中严格定义的顺序和内存对齐要求控制。每种CPU架构的确切情况略有不同，但是onx86 / x64的以下主要规则适用： </p><p> Data types must be aligned according to their bit-width for optimal access.So 64-bit values must be aligned on 8-byte boundaries (addresses evenlydivisible by 8), 32-bit values on4-byte boundaries, and so on.</p><p>数据类型必须根据其位宽进行对齐以实现最佳访问，因此64位值必须在8字节边界（地址可被8整除）上对齐，32位值在4字节边界上对齐，依此类推。</p><p>  Structs must be padded at the end so when they’re placed in contiguousarrays, all their members are aligned optimally as per the above. Inpractical terms this means that the total size of the struct is paddedto the nearest integer multiple of the widest data type it contains.</p><p>  必须在结构末尾填充结构，以便将它们放置在连续数组中时，其所有成员均按照上述最佳方式对齐。不切实际的用语是指该结构的总大小被填充为它所包含的最宽数据类型的最接近的整数倍。</p><p>  The compiler is not allowed to reorder struct fields under any circumstance(to optimise padding or for any other reason), the reason being that thiswould break a lot of low-level code.</p><p>  在任何情况下（为了优化填充或任何其他原因），不允许编译器对结构字段进行重新排序，原因是这将破坏许多低级代码。</p><p>  Unaligned access is supported on x86/x64 (meaning it won’t crash theprogram), but at a significant performance penalty.</p><p>  x86 / x64支持不对齐访问（这不会使程序崩溃），但是会导致性能下降。</p><p> Another important piece of background information is that C99 stipulates thatblocks of memory allocated with  malloc must be correctly aligned for anydata type supported by the implementation. Hence, padding is never requiredbefore the first element of a struct. In practice, you can assume theallocated memory blocks are always 8-byte aligned on x86, and 16-bit alignedon x64, regardless of the OS.</p><p> 另一个重要的背景信息是C99规定，对于实现所支持的任何数据类型，必须为malloc分配的内存块正确对齐。因此，在结构的第一个元素之前永远不需要填充。实际上，您可以假设分配的内存块在x86上始终是8字节对齐的，而在x64上始终是16位对齐的，而与操作系统无关。</p><p> So, armed with this arcane knowledge, it’s not too hard to figure out what’sgoing on:</p><p> 因此，有了这些不可思议的知识，就很难弄清发生了什么：</p><p> # worst case (string in the middle) - 24 bytes with padding type  Cell *  =  object  b :  byte  # 1 byte + 7 pad bytes  s :  string  # 8 bytes (8-byte aligned)  d :  Direction  # 1 byte + 7 pad bytes (to ensure that the next array  # element is 8-byte aligned) # better (string at start) - 16 bytes with padding type  Cell *  =  object  s :  string  # 8 bytes (8-byte aligned because of malloc)  b :  byte  # 1 byte  d :  Direction  # 1 byte + 6 pad bytes (to ensure that the next array  # element is 8-byte aligned)</p><p> ＃最坏的情况（中间的字符串）-填充类型为Cell的24个字节* =对象b：字节＃1个字节+ 7个填充字节s：字符串＃8个字节（8字节对齐）d：方向＃1个字节+ 7个填充字节（以确保下一个数组是＃个元素是8字节对齐的）＃更好（开始时是字符串）-填充类型为Cell的16个字节* = object s：字符串＃8个字节（由于malloc而对齐8个字节）b：字节＃1字节d：方向＃1字节+ 6个填充字节（以确保下一个数组＃元素是8字节对齐的） </p><p> One interesting consequence of the padding requirements is that we might aswell store something useful in those otherwise unused padding bytes (as longas we’re careful not to overshoot):</p><p>填充要求的一个有趣的结果是，我们可能还会在那些未使用的填充字节中存储一些有用的东西（只要我们注意不要过冲）：</p><p> type  Cell *  =  object  s :  string  # 8 bytes  b :  byte  # 1 byte  d :  Direction  # 1 byte  x :  int16  # 2 bytes (offset 10, 2-byte aligned)  y :  int32  # 4 bytes (offset 12, 4-byte aligned) echo  sizeof ( Cell )  # still 16 bytes!</p><p> 类型Cell * =对象s：字符串＃8字节b：字节＃1字节d：方向＃1字节x：int16＃2字节（偏移量10，2字节对齐）y：int32＃4字节（偏移量12、4-字节对齐）echo sizeof（Cell）＃仍然是16个字节！</p><p> Then there’s the  packedpragmatoo that you can apply to objects to effectively disable padding, but thisshould be restricted to low-level code or situations where you must interfacewith C libraries because it doesn’t work that well with GC’d memory (themanual explains why this is so).</p><p> 然后是可以应用于对象的packedpragmatoo，以有效地禁用填充，但这应该限于低级代码或必须与C库进行接口的情况，因为它不能很好地与GC的内存配合使用（该手册解释了为什么这样做是这样）。</p><p> This is definitely a very interesting subject, check out the followingarticles if you would like to explore it further:</p><p> 这绝对是一个非常有趣的主题，如果您想进一步探索，请查看以下文章：</p><p>   So long folks, hope you found something interesting here. Wash your hands,wear face masks, don’t drink and drive during the festive season, and keepNimming! (Is that even a word? I guess it is now…)</p><p>   这么长的人，希望您在这里找到了一些有趣的东西。洗手，戴口罩，在节日期间不要酒后开​​车，并保持安静！ （就是一个字吗？我想现在是……） </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.johnnovak.net/2020/12/21/nim-apocrypha-vol1/">https://blog.johnnovak.net/2020/12/21/nim-apocrypha-vol1/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/nim/">#nim</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/apocrypha/">#apocrypha</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>