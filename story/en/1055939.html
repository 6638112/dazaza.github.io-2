<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>赞美基于财产的检测（2019年） In praise of property-based testing (2019)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">In praise of property-based testing (2019)<br/>赞美基于财产的检测（2019年） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-03 21:03:39</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/ecbc6b857ceb885666ab81228f13adf3.jpeg"><img src="http://img2.diglog.com/img/2021/4/ecbc6b857ceb885666ab81228f13adf3.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Property-based testing is a style of testing that originated with the Haskell library QuickCheck. I’ve been working on bringing it into the mainstream since early 2015, when I released the Python library Hypothesis, which has since seen fairly widespread adoption. I’d like to tell you a bit about what property-based testing is and why it matters</p><p>基于物业的测试是一种源自Haskell Library QuickCheck的测试风格。自2015年初以来，我一直在努力将其纳入主流，当时我发布了Python库假说，这已经被视为相当广泛的采用。我想告诉你一些基于物业的测试以及它为什么要这样做</p><p> Traditional, or example-based, testing specifies the behavior of your software by writing examples of it —each test sets up a single concrete scenario and asserts how the software should behave in that scenario. Property-based tests take these concrete scenarios and generalize them by focusing on which features of the scenario are essential and which are allowed to vary. This results in cleaner tests that better specify the software’s behavior —and that better uncover bugs missed by traditional testing</p><p> 传统或基于示例，测试指定软件的行为通过写入IET-each测试设置单个具体方案并断言软件在该方案中的表现方式。基于物业的测试采取这些具体场景，并通过专注于哪些方案的特征至关重要，并且允许变化。这导致更清晰的测试，更好地指定软件的行为 - 以及传统测试错过的更好的未发现错误</p><p>  The problem with example-based tests is that they end up making far stronger claims than they are actually able to demonstrate. Property-based tests improve on that by expressing exactly the circumstances in which our tests should be expected to pass. Example-based tests use a concrete scenario to suggest a general claim about the system’s behavior, while property-based tests directly focus on that general claim. Property-based testing libraries, meanwhile, provide the tools to test claims</p><p>  基于示例的测试的问题是他们最终使得远远超强的索赔，其实际能够证明。基于物业的测试通过表达预期我们的测试的情况完全相同，提高了这一点。基于示例的测试使用具体方案来建议对系统行为的一般索赔，而基于物业的测试直接关注该一般索赔。同时，基于物业的测试库提供了测试索赔的工具</p><p>  To see how this shift in focus works, take a look at a fairly typical example-based test. Suppose we’re testing a web application that allows users to collaborate on projects. Projects have a maximum number of collaborators, and we want to be able to add users up to that limit. To validate that we can do this, we write the following test:</p><p>  要了解焦点工作的转变如何，请查看一个相当典型的基于示例的测试。假设我们正在测试一个Web应用程序，允许用户在项目上协作。项目有最多的合作者数量，我们希望能够将用户添加到该限制。要验证我们可以执行此操作，我们编写以下测试：</p><p>  from .models  import User, Project  from django.test  import TestCase   class   (TestCase):   def   (self): project = Project.objects.create( collaborator_limit= 3, name= &#34;Some project&#34; ) alex = User.objects.create(email= &#34;alex@example.com&#34;) kim = User.objects.create(email= &#34;kim@example.com&#34;) pat = User.objects.create(email= &#34;pat@example.com&#34;) project.add_user(alex) project.add_user(kim) project.add_user(pat) self.assertTrue(project.team_contains(alex)) self.assertTrue(project.team_contains(kim)) self.assertTrue(project.team_contains(pat))</p><p>  从.models导入用户，从django.test导入testcase类（testcase）：def（self）：project = project.objects.create（collaborator_limit = 3，name =＆＃34;一些项目＆＃34;）alex =用户.Objects.Create（电子邮件=＆＃34; alex@example.com&#34;）Kim = User.Objects.Create（Email =＆＃34; Kim@example.com&#34;）pat = user.objects.create （电子邮件=＆＃34; pat@example.com&#34;）project.add_user（alex）project.add_user（kim）project.add_user（pat）self.asserttrue（project.team_contains（axx））self.asserttrue（项目.team_contains（kim））self.asserttrue（project.team_contains（pat））</p><p> In order to test our general claim (that we can add users up to the collaborator limit of the project), we have written a test of a specific instance of that general claim. This isn’t an unreasonable thing to do: If this test fails, our claim is surely false. The problem is that if our test passes, it doesn’t tell us much about the claim itself —it just tells us that the test passes. This is not reflected well in the test name. The title   test_ can_ add_ users_ up_ to_ collaborator_ limit” sure  sounds like a general claim. A more accurate name would be   test_ can_ add_ three_ users_ at_ the_ same_ domain_ to_ a_ project_ with_ a_ collaborator_ limit_ of_3” —but this is unlikely to be a particularly popular naming convention</p><p> 为了测试我们的一般索赔（我们可以将用户添加到项目的协作限制），我们已经编写了一般索赔的特定实例的测试。这不是一个不合理的事情：如果这项测试失败，我们的索赔肯定是假的。问题是，如果我们的测试通行证，它并没有告诉我们索赔本身 - 只是告诉我们测试通过。这在测试名称中不会很好地反映。标题测试_ CAN_ ADD_用户_ UP___COLLABORATOR_限制“确定声音，如一般索赔。一个更准确的名字是test_can_ add_ users_at_aple_ domain_ to_ a_ project_用_ aga and _ a_ collaborator_ limit_ _3“ - 但这不太可能是一个特别流行的命名约定</p><p> This is the fundamental problem of example-based testing: We often treat our tests as specifications, but in reality they are stories. Worse, they’re often shaggy-dog stories, full of a mess of random details, and we get no clue as to which parts of the test actually matter and which parts are just a distraction</p><p> 这是基于示例性测试的根本问题：我们经常将我们的测试视为规范，但实际上他们是故事。更糟糕的是，他们常常毛茸茸的狗的故事，充满了一个乱糟糟的随机细节，我们没有任何线索，就像哪些部分的测试实际上很重要，哪些部分只是一个分心 </p><p> Take a look at the test on the previous page. Which of the details matter? Presumably —hopefully! —the project name is irrelevant. Does it matter that the collaborator limit is specifically three? Probably not, but it might matter that it’s greater than one. Does it matter that the users all have an email address at the same domain? Maybe, but the test doesn’t say</p><p>看看上一页的测试。哪些细节有关？可能是 - 很快！ - 项目名称是无关紧要的。合作镜限制是否特别是三个重要？可能不是，但它可能重要的是，它大于一个。用户所有人都有同一域的电子邮件地址是否重要？也许，但测试并没有说</p><p>  Property-based testing is about removing those extraneous details, and property-based testing libraries are tools to help us do so</p><p>  基于物业的测试是关于删除那些无关的细节，而基于物业的测试库是帮助我们这样做的工具</p><p>  from .models  import User, Project  from hypothesis.extra.django  import TestCase  from hypothesis  import given  from hypothesis.extra.django.models  import models  from hypothesis.strategies  import text, lists   class   (TestCase):   text(), lists(models(User), unique_by= lambda u: u.email) )   def   ( self, project_name, collaborators ): project = Project.create( name=project_name, collaborator_limit=len(collaborators) )  for c  in collaborators: project.add_user(c)  for c  in collaborators: self.assertTrue(project.team_contains(c))</p><p>  从.models导入用户，从假设导入中的假设导入从假设导入中导入测试..extra.django.models从假设导入模型.strategies导入文本，列出类（testcase）：text（）文本（）列表（ Unique_by = lambda u：u.email））def（self，project_name，协作者）：project = project.create（name = project_name，collaborator_limit = len（collaborators）在协作者中为c：project.add_user（c）对于COLCRABORATORS中的C：self.asserttrue（project.team_contains（c））</p><p> This is the same test, but the details we were unsure of are now allowed to vary: Instead of a fixed project name or set of users, we have said that this works for any project name and any list of distinct users. The test now captures exactly our original intent, because we’ve abstracted away the details that are unimportant by allowing them to vary</p><p> 这是相同的测试，但我们不确定的详细信息现在允许不同：而不是固定的项目名称或用户集，我们已经表示，这适用于任何项目名称和任何不同用户列表。该测试现在捕获完全是我们的原始意图，因为我们通过允许它们不同，我们抽象了不重要的细节</p><p>  The way this works is that Hypothesis uses an  @given decorator to let us specify a range of valid inputs to a test. These inputs are specified using  strategies, which describe the range of valid values for the argument to take</p><p>  这项工作的方式是假设使用@given装饰器让我们为测试指定一系列有效输入。这些输入使用策略指定，该策略描述了要采取的参数的有效值范围</p><p> In this case, our project name may be any string, and our collaborators may be any list of user model objects, as long as they all have distinct email addresses. A test written in this way is expected to pass for any possible argument allowed by its strategies</p><p> 在这种情况下，我们的项目名称可能是任何字符串，我们的协作者可以是任何用户模型对象列表，只要它们都具有不同的电子邮件地址。预计以这种方式编写的测试将通过其策略允许的任何可能的论点</p><p> What happens when we run this new version of the test? Well, it passes. It would require a fairly obtuse implementation to fail the original test and pass this one. Here, the improvement from the original test is purely in terms of making this a better-factored test, but that’s already a big increase in the quality of our test suite</p><p> 我们运行此新版本的测试时会发生什么？好吧，它通过了。它需要一个相当钝的实现来失败原始测试并通过这一个。在这里，原始测试的改进纯粹是在使这一更好的考试方面，但是测试套件的质量已经大幅增加 </p><p>  It’s common for people to use fixtures and factory libraries in order to reduce the tedium of setting up their data over and over again. This causes the tests to depend (in subtle and unintentional ways) on the details of the fixture data, and to become increasingly brittle as a result. Property-based testing avoids that brittleness by insisting the details that shouldn’t matter are allowed to vary, making it impossible for tests to depend on them. The result is a significantly cleaner and more robust test suite, which makes fewer implicit assumptions about fixture data</p><p>人们使用夹具和工厂库是常见的，以减少一遍又一遍地建立数据的乏味。这导致测试依赖于（以微妙和无意的方式）对夹具数据的细节，并且由于结果而变得越来越脆弱。基于物业的测试避免了坚持不懈地允许无关紧要的细节来避免脆性，这使得测试不可能取决于它们。结果是一个显着的清洁和更强大的测试套件，这使得夹具数据的隐式假设较少</p><p> It goes further than this! By forcing us to precisely describe the behavior of our software, property-based testing in turn forces us to make explicit not just the assumptions that we made when writing the tests, but also the assumptions that we made when writing the software. Often we will discover that those assumptions are wrong</p><p> 它比这更重要！通过迫使我们精确描述我们的软件的行为，基于物业的测试依次迫使我们显明不仅仅是我们在编写测试时所做的假设，而且是我们在编写软件时所做的假设。我们常会发现这些假设是错误的</p><p> Let’s take a look at two examples of this sort of wrong assumption, taken from real-world (but old)  bugs found by Hypothesis</p><p> 让我们来看看这种错误假设的两个例子，从假设发现的真实世界（但旧的）错误</p><p>   We wrote some tests for Python bindings to Argon2, an award-winning password hashing library. The test itself is fairly straightforward (take a password, hash it, verify the original password against the hash), but the interesting feature is that Argon2 takes a great many configuration options to control difficulty, and by allowing those to vary we exposed a (fairly harmless) bug in the underlying implementation:</p><p>   我们为Python绑定写了一些测试到argon2，屡获殊荣的密码散列库。测试本身相当简单（拍摄密码，散列，验证哈希的原始密码），但有趣的功能是argon2需要很多配置选项来控制难度，并且通过允许这些允许这些选项允许我们曝光的难度（基础实施中的错误）错误</p><p> from argon2  import PasswordHasher  from hypothesis  import given, assume  import hypothesis.strategies  as st   class   (object):   password=st.text(), time_cost=st.integers( 1,  10), parallelism=st.integers( 1,  10), memory_cost=st.integers( 8,  2048), hash_len=st.integers( 12,  1000), salt_len=st.integers( 8,  1000) )   def   ( self, password, time_cost, parallelism, memory_cost, hash_len, salt_len ):  # Reject examples with a memory cost of less than 8 per thread as invalid   # (these would raise an error when constructing the password hasher)  assume(parallelism *  8 &lt;= memory_cost) ph = PasswordHasher( time_cost=time_cost, parallelism=parallelism, memory_cost=memory_cost, hash_len=hash_len, salt_len=salt_len ) hash = ph.hash(password)  assert ph.verify(hash, password)</p><p> 从argon2导入passwordhasher从假设导入给定，假设导入假设.strategies作为st类（对象）：password = st.text（），time_cost = st.integers（1,10），parturantism = st.integers（1,10） ，memory_cost = st.integers（8,2048），hash_len = st.integers（12,1000），star_len = st.integers（8,1000））def（self，password，time_cost，parturentom，memory_cost，hash_len，salt_len） ：＃拒绝具有每线程少于8的内存成本的示例，如无效＃（在构建密码哈赫时会引发错误）假设（并行性* 8＆lt; = memory_cost）ph = passwordhasher（time_cost = time_cost，parallelism = parallyism ，memory_cost = memory_cost，hash_len = hash_len，salt_len = salt_len）hash = ph.hash（密码）断言ph.verify（哈希，密码）</p><p> Here the test  does fail. When this happens, Hypothesis prints the specific combination of arguments that trigger that failure:</p><p> 这里测试确实失败了。发生这种情况时，假设打印了触发该故障的参数的特定组合：</p><p>  The bug is that if the hash length is greater than 512, it hits an internal fixed-size buffer in the underlying C library, which causes the verification to go wrong. The hashing silently seems to have worked, but the resulting hash will not verify the original password</p><p>  错误是，如果散列长度大于512，则它会在底层C库中击中内部固定大小缓冲区，这会导致验证出错。默默地似乎有效，但结果哈希不会验证原始密码 </p><p> How did we get this output? This is where the property-based testing library, in this case Hypothesis, comes in. When we run a test in Hypothesis, here’s what happens:</p><p>我们是如何获得此输出的？这是基于物业的测试库，在这种情况下的假设中进来。当我们在假设中进行测试时，这就是发生的事情：</p><p> If it has a failing example, it applies shrinking to attempt to find a simpler set of parameters triggering the same bug.</p><p> 如果它有一个失败的示例，它会缩小缩小以尝试找到触发相同错误的更简单的参数集。</p><p> Shrinking, in particular, is one of the big benefits of using property-based testing libraries over fixture libraries with random generation. Debugging randomly generated values puts us back in the situation of having to ask what details matter. And randomly generated values are often worse than if a human had written them, because they are large and messy — which makes it hard to pick out what matters</p><p> 特别是缩小，是使用基于物业的测试库与随机生成的夹具库上的大益处之一。调试随机生成的值让我们回到必须询问细节的情况。随机生成的值通常比人类写在它们的那样差，因为它们很大而凌乱 - 这使得很难挑选出什么事</p><p>  In contrast, consider the falsifying example on the previous page: All of the parameters are the smallest value they can be —except for hash_len, which is instead the smallest value it can be while still triggering the bug. If we replaced 513 with 512, the bug would go away. When we work with these shrunk examples, the details that are responsible for the failure tend to stand out</p><p>  相比之下，考虑上一页的伪造示例：所有参数都是它们可以是-Expt的最小值 - 它是它可能在仍然触发错误时的最小值。如果我们用512更换513，则会消失。当我们使用这些缩放示例时，负责失败的细节倾向于脱颖而出</p><p> This is the first type of assumption that property-based testing helps uncover: assumptions about what sorts of inputs will call up certain functions. Property-based tests require us to be explicit about the valid range, which helps us find out what it actually is, rather than just testing the happy path</p><p> 这是基于属性的测试有助于发现的第一种假设：关于什么类型的输入调用某些功能的假设。基于物业的测试要求我们明确关于有效范围，这有助于我们找到它所实际的东西，而不是测试快乐的路径</p><p>  Another common source of wrong assumptions is when parts of the software are written by different people —either because we’re using third-party libraries or just because there are multiple people on the team. When assumptions are implicit, it can be hard to notice when different people make different ones</p><p>  另一个错误的假设来源是当软件的部分是由不同的人写的，因为我们使用第三方库或仅仅因为团队中有多个人。当假设隐含时，当不同的人制作不同的人时，很难注意到</p><p> The following is a fun example of this sort of mismatch. This comes from a library called BinaryOrNot, whose job is to heuristically detect if a file was meant to be a binary or a text file:</p><p> 以下是这种不匹配的一个有趣的例子。这来自一个名为binaryornot的库，其工作是启发式地检测文件是否符合二进制文件或文本文件： </p><p> from binaryornot.helpers  import is_binary_string  from hypothesis  import given  from hypothesis.strategies  import binary    def   (s): is_binary_string(s)</p><p>来自Binaryornot.helpers从假设给出的假设导入中导入IS_Binary_String.strategiate导入二进制Def（s）：is_binary_string（s）</p><p> Here we have generated a byte string to test and passed it to the  is_binary_string function. Note that we haven’t even checked if it does anything sensible! We’re simply checking if the function raises an error. This is often a very useful test to write with property-based testing, as it’s easy to implement and often flushes out a surprising number of errors. Using assertions or contracts, we can even improve it further by making sure that our code crashes in cases where it might otherwise have silently failed</p><p> 在这里，我们生成了一个字节字符串来测试并将其传递给IS_Binary_String函数。请注意，我们甚至没有检查是否有任何明智的情况！我们只是检查功能是否提出了错误。这通常是与基于物业的测试写入的非常有用的测试，因为它很容易实现并且经常刷出令人惊讶的错误数量。使用断言或合同，我们甚至可以通过确保我们的代码在可能默默地失败的情况下崩溃，进一步提高它</p><p> In this case, the test failed with the input  s=b&#39;\xae\xc5\xdc&#39;m, caused by a Unicode decoding error. Why? Well, because it depended on another library named Chardet. Chardet does heuristic prediction of the intended encoding of text files. In this case, the logic was that BinaryOrNot thought this string might be text, asked Chardet to predict its encoding, and was told that it was a specific encoding with 100 percent confidence. Unfortunately, it turns out that when Chardet says there is no intended implication, this actually means that it’s a valid sequence of bytes for that encoding</p><p> 在这种情况下，测试失败了输入S = B＆＃39; \ xae \ xc5 \ xdc＆＃39; m，由Unicode解码误差引起。为什么？好吧，因为它依赖于另一个名叫Chardet的图书馆。 Chardet是否有启发式预测文本文件的预期编码。在这种情况下，逻辑是BinaryOrnot认为这个字符串可能是文本，要求Chardet预测其编码，并被告知它是一个特定的编码，达到100％的信心。不幸的是，事实证明，当Chardet说没有预期的含义时，这实际上意味着它是该编码的有效字节序列</p><p> This is documented behavior, and has a reasonable enough motivation, but it’s also surprising enough that the BinaryOrNot authors had (equally reasonably) never considered the possibility. There was a mismatch between the contract they believed that Chardet followed and the one that it actually followed, but this mismatch did not arise until their code was tested with property-based testing</p><p> 这是记录的行为，并且具有足够合理的动力，但它也很令人惊讶的是，Binaryornot作者（同样合理地）从未考虑过这种可能性。合同之间存在不匹配，他们相信Chardet遵循以及它实际遵循的合同，但在通过基于物业的测试测试的代码测试之前，这种不匹配不会出现</p><p>   We now get to where most property-based testing articles start: the sorts of tests that only really make sense to write when they’re property-based. Because property-based testing makes it easy to write tests that run over a wide range of parameters, it prompts us to think about what program claims we can make that are always true. These are the  “properties” in  property-based testing.</p><p>   我们现在到达大多数基于物业的测试文章开始的地方：只有在基于属性的属性时，只能真正有意义的测试。由于基于物业的测试使得易于编写在广泛参数范围内的测试，因此它会提示我们思考我们可以使我们能够使其概括的程序。这些是基于物业测试中的“属性”。</p><p> It can be quite hard to think of these properties, so I generally recommend that people don’t worry too much about them until they’ve gotten familiar with the basics of property-based testing and integrated it into their normal workflow. However, there’s one that’s easy and ubiquitous enough that it’s worth knowing about from the start: the encode/decode, or round-tripping, test</p><p> 考虑这些属性可能很难，所以我通常建议人们对他们太担心，直到他们熟悉基于物业的测试基础并将其集成到正常的工作流程中。但是，有一个容易而普遍的是，从一开始就值得了解：编码/解码，或圆跳闸，测试</p><p> When we have some data that we convert to a serialized representation, we can always check that serializing it and deserializing it produces the same result. This is useful for two reasons: First, essentially every nontrivial application serializes its state somewhere — into a database, into files, into an  API. Second, such serialization usually has bugs, and as a result important information gets lost or corrupted when we transform from one format to another</p><p> 当我们有一些数据我们转换为序列化表示时，我们可以始终检查序列化IT并反序列化它产生相同的结果。这是有用的两个原因：首先，基本上每个非竞争应用程序都将其状态序列化到数据库中，进入API。其次，这种序列化通常具有错误，结果，当我们从一种格式转换为另一个格式时，重要信息会丢失或损坏 </p><p>  from dateutil.parser  import parse  from hypothesis  import given, settings  from hypothesis.strategies  import datetimes    def   (dt): formatted = dt.isoformat()  assert formatted == parse(formatted).isoformat()</p><p>从dateutil.parser导入解析从假设导入给定，假设的设置.strategies导入datetimes def（dt）：formatted = dt.isoformat（）断言格式== parse（格式化）.isoformat（）</p><p> This tests the dateutil library’s ability to parse times in the  ISO 8601 format (the one true date format!) as follows:</p><p> 这测试了Dateutil库在ISO 8601格式中解析时间（一种真实日期格式！）如下：</p><p> Then Hypothesis checks that this date agrees with the original. (We check that they have the same ISO 8601 format rather than direct equality due to the intricacies of equality on time zone objects.)</p><p> 然后假设检查此日期与原件同意。 （我们检查它们具有相同的ISO 8601格式而不是由于时区对象的平等复杂而直接平等。）</p><p> This function fails when given 0005-01- 01T00:00:05, which it erroneously parses as 0001-05-01T00:00:05, swapping the year and the month</p><p> 当给定0005-01- 01T00：00：05时，此功能失败，它错误地解析为0001-05-01T00：00：05，交换年份和月份</p><p> This bug is extremely specific. It only occurs when the year is equal to the second, and it happens because of some ambiguity in how the parser interprets the date. It is very unlikely that it would ever have been found by a normal, human testing process, but chances are that some users would eventually have run into it. Hopefully they would have noticed, rather than having their data be silently corrupted. By writing property-based tests that assert the consistency of the data when converting it between different formats, we eliminate whole classes of subtle bugs from production</p><p> 此错误非常具体。它只发生在这一年等于第二年，并且它发生在解析器如何解释日期的一些歧义。它非常不太可能被正常，人类测试过程中发现，但有些用户最终会遇到它。希望他们本来已经注意到，而不是让他们的数据默默地腐败。通过编写基于属性的测试，在不同格式之间转换数据时，可以断言数据的一致性，我们消除了从生产中的全类微妙错误</p><p>   Bridge the gap between what we claim to be testing and what we’re actually testing.</p><p>   桥接我们主张测试的差距以及我们实际测试的内容。</p><p> Reveal the assumptions that we made during testing and development, and check if they are violated.</p><p> 揭示我们在测试和开发期间所做的假设，并检查它们是否被侵犯。 </p><p> Expose subtle inconsistencies in our code that would be hard to detect with example-based testing.</p><p>在我们的代码中公开微妙的不一致，这将难以使用基于示例的测试来检测。</p><p>  But how do you get there if you’re starting from an example-based test suite? The most important thing is to just start. Most property-based testing libraries are designed with easy integrations for common testing frameworks, so it’s fairly easy to add to existing continuous integration. You can start small,  adapting just a couple existing example-based tests into simple properties, using them as a gateway to get yourself over the initial hurdle of using property-based testing</p><p>  但是，如果您从基于示例的测试套件开始，您将如何到达那里？最重要的是刚刚开始。基于大多数基于物业的测试库都是为常用测试框架而轻松集成的，因此添加到现有的连续集成相当容易。您可以开始小，使一些基于示例的实例的测试进入简单的属性，将它们作为网关，以便使用基于物业的测试的初始障碍</p><p> Once you’ve got a couple of property-based tests in your test suite, you can add new property-based tests in the course of normal development.  Can this test be a property-based test?” is a good question to ask during code review. And touching existing code is a good opportunity to generalize the tests before writing new features</p><p> 在测试套件中有几个基于物业的测试后，您可以在正常开发过程中添加新的基于物业的测试。该测试可以是基于物业的测试吗？“在代码审查期间询问是一个很好的问题。并触摸现有代码是在编写新功能之前概括测试的好机会</p><p>  Alternatively, if you want to  get started by jumping in at the deep end, it can be fun to take a day out and get the whole team together to work on adding property-based tests. This will go a lot further a lot faster, but be warned: You will probably find an awful lot of bugs!</p><p>  或者，如果您想通过在深端跳跃开始时，可​​以休闲休闲，让整个团队在一起努力添加基于物业的测试。这将进一步得多，但被警告：你可能会发现很多虫子！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://increment.com/testing/in-praise-of-property-based-testing/">https://increment.com/testing/in-praise-of-property-based-testing/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/财产/">#财产</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/property/">#property</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>