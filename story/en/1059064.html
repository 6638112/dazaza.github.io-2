<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>重新发现汉明码 Rediscovering Hamming Code</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rediscovering Hamming Code<br/>重新发现汉明码 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-19 22:04:20</div><div class="page_narrow text-break page_content"><p>This will arguably be one of the more boring posts on the blog however I figured some keen eyes might extract something useful out of this, even if not technical.</p><p>这将可以说是博客上更无聊的帖子之一，但是我认为一些敏锐的眼睛可能会提取一些有用的东西，即使不是技术。</p><p> Note – if you would like take a closer look at the scratch project, you can find it  here.</p><p> 注意 - 如果您想仔细查看划痕项目，您可以在此处找到它。</p><p> A couple of months back I had started reading an interesting book by the late Richard Hamming, &#34; The Art of Doing Science and Engineering: Learning to Learn&#34;.</p><p> 几个月后，我开始阅读理查德汉明，＆＃34的后期读一本有趣的书;做科学与工程的艺术：学习学习＆＃34;</p><p> It&#39;s a good book but we only get one chapter on hamming code (and  four on  digital filters); earlier chapters however are definitely word a read. Really and truly I hardly understood most it but I did love the narrative on learning, how to learn, and the story on how the hamming code was discovered.</p><p> 它是一本好书，但我们只会在汉明代码（和数字过滤器上的四个）中获取一章;然而，早期的章节肯定是一个读。真的而且真的很难理解大多数情况，但我确实喜欢学习的叙述，如何学习，以及如何发现汉明代码的故事。</p><p> Since my interest in digital filters was, and is, somewhat non-existent I decided hamming code would be a great place to learn a couple of interesting topics and tools for a few reasons:</p><p> 由于我对数字过滤器的兴趣是，并且有些不存在的我决定汉明的代码将是一个很好的地方，了解几个有趣的主题和工具的一些原因：</p><p>  With these characteristics I wanted to explore a few areas around profiling, benchmarking, assembly, concurrency, SIMD and overall bit twiddling all in one place and done gradually.</p><p>  通过这些特征，我希望探索分析，基准测试，装配，并发性，SIMD和整体位的几个区域，并在一个地方逐渐完成。</p><p>  I will spare the detailed explanation of Hamming code as there is already very work out there, as well as different ways of approaching the problem depending on hardware and software. That said, for both of these cases I  highly recommend two videos by  3Blue1Brown and  Ben Eater respectively.</p><p>  我将备用汉明代码的详细解释，因为已经在那里有很好的工作，以及根据硬件和软件接近问题的不同方式。也就是说，对于这两种情况来说，我分别强烈推荐两个视频3Blue1Blown和Ben Eater。 </p><p>  In this particular task I want to be able to do one thing and do it fast. Encode, add noise and decode binary files (yes,  technically it&#39;s three things). Here are some initial versions trying to encode &amp; decode a lorem ipsum text file.</p><p>在这项特定的任务中，我希望能够做一件事并快速做。编码，添加噪声和解码二进制文件（是的，技术上它＆＃39;三件事）。以下是一些尝试编码＆amp的初始版本;解码Lorem IPSUM文本文件。</p><p>  Well, at least it&#39;s roughly equal amount of gibberish. Maybe I got the byte slices all wrong?</p><p>  嗯，至少是它＆＃39; s大致相等的痛苦。也许我得到了字节切片都错了？</p><p>  Seems like I did but instead of fixing it, I made it worse. Some alignment issues, algorithm issues and endianness issues later we managed to get some basic text encoding &amp; decoding working that would translate well to any binary files (in theory).</p><p>  似乎我做了，而不是修复它，我让它变得更糟。一些对齐问题，算法问题和endianness问题后来我们设法获得了一些基本文本编码＆amp;解码工作将与任何二进制文件（理论上）转化。</p><p>  Time to apply some synthetic noise on a per-block basis with a 66.67% chance of flipping a single bit. In real world scenarios binary blocks are interleaved to reduce chances of single blocks have more than 1 bit error which Hamming cannot handle.</p><p>  时间在按块的基础上应用一些合成噪声，使用66.67％的机会翻转单一。在现实世界场景中，二进制块是交错的，以减少单个块的机会具有超过1个汉明无法处理的错误错误。</p><p> The reason for this is that when a bit is damaged in transmission, it tends to occur in a short burst were a few adjacent bits are all flipped altogether. Interleaving blocks builds resiliency against such scenarios.</p><p> 这样的原因是，当在传输中有一点损坏时，它往往发生在短脉冲中是几个相邻的比特完全翻转。交织块对这种情况构成弹性。</p><p>  I tried my hand at some images and somehow made a cursed cat look less terrifying. It&#39;s a feature not a bug.</p><p>  我试着在一些图像中努力，以某种方式制作了诅咒的猫看起来不那么可怕。它＆＃39; s一个不是bug的功能。</p><p>  As it turns out, my file reader is only able to process up to, and exactly, 7168 bytes? I decided to not worry about this for now and move on; I&#39;d be more than happy to feedback on alternative ways to write  this.</p><p>  事实证明，我的文件阅读器只能处理到达，究竟，7168字节？我决定现在不用担心这个并继续前进;我＆＃39; D非常乐意反馈替代方式来写这个。 </p><p>  It took some back-of-the-napkin dry runs till I got the crux of the problem and looking at  other similar implementations, we narrowed down to something that worked. I wanted something simple, that can be optimised so we landed for the following  initial implementation.</p><p>在我收到问题的关键并查看其他类似的实施方面，它花了一些后面的一个人的干燥运行，我们缩小了一些工作的东西。我想要一些简单的东西，可以优化，所以我们降落了以下初步实施。</p><p> We will be going over each component, ( a) encoder, ( b) decoder and ( c) parity check independently to avoid context switching too much and streamlining the improvements.</p><p> 我们将介绍每个组件，（a）编码器，（b）解码器和（c）奇偶校验，独立检查，以避免上下文切换过多并简化改进。</p><p>  The initial encoder is a little bit allover the place but is arguably the simplest part of this implementation. We need to figure how many parity bits,  len_power, we need ( log2{64 bits} = 6) and from that derive the data width,  len ( 2^6 = 64); you will notice soon enough that this entire dance is not required.</p><p>  初始编码器是一个稍微的位置，但可以说是该实现的最简单部分。我们需要计算多少个奇偶校验位，Len_Power，我们需要（log2 {64位} = 6），并且从该导出数据宽度，len（2 ^ 6 = 64）;您将注意到这一点不需要这种整个舞蹈。</p><p> pub fn encode(block: &amp;mut u64) -&gt; u64 { let len_power = (2..).find(|&amp;r| 2u32.pow(r) - r - 1 &gt;= 32).unwrap(); let len = 2usize.pow(len_power); // ...}</p><p> PUB FN编码（块：＆amp; mut U64） - ＆gt; U64 {让Len_Power =（2 ..）。找到（|＆amp; R | 2u32.pow（r） -  r  -  1＆gt; = 32）.unwrap（）;让Len = 2usize.pow（len_power）; // ......}</p><p> These are the only parameters that the encoder needs to be aware of before we can start to encode our message. Starting with  1001 as our example input message, we first go through each bit, see if the index of that bit is a power of 2 and therefore a parity bit. If it is a power of 2, we shift the input message left (i.e.  skip the current bit), otherwise we insert the bit into the encoded message as is.</p><p> 这些是编码器需要知道的唯一参数，然后在我们开始编码我们的消息之前需要了解。从1001开始作为我们的示例输入消息，我们首先通过每个位，看看该位的索引是否是2的功率，因此是一个奇偶校验位。如果它是2的力量，则将输入消息左转（即跳过当前位），否则我们将该位插入到编码的消息中。</p><p> pub fn encode(block: &amp;mut u64) -&gt; u64 { // ... let mut code = 0u64; for i in 0..len { // Check if `i` is not a power of 2 if (i != 0) &amp;&amp; (i &amp; (i - 1)) != 0 { code |= (0b1 &lt;&lt; i) &amp; *block as u64; } else { *block &lt;&lt;= 1; } } // ...}</p><p> PUB FN编码（块：＆amp; mut U64） - ＆gt; U64 {// ...让mut code = 0u64;因为我在0..len {//检查'i`如果（i！= 0）＆amp;＆amp; （I＆amp;（i  -  1））！= 0 {code | =（0b1＆lt; i）＆amp; *块作为U64; }否则{*块＆lt;＆lt; = 1; }} // ......}</p><p> Lastly, we go through each parity bit an compute the remaining four parity bits and insert them into the final encoded message.</p><p> 最后，我们通过每个奇偶校验位进行计算剩余的四个奇偶校验位，并将它们插入最终编码的消息。 </p><p> pub fn encode(block: &amp;mut u64) -&gt; u64 { // ... for i in 0..len_power { // If the parity check is odd, set the bit to 1 otherwise move on. if !parity(&amp;code, i) { code |= 0b1 &lt;&lt; (2usize.pow(i)); } } encoded}</p><p>PUB FN编码（块：＆amp; mut U64） - ＆gt; U64 {// ...为我在0..len_power {//，如果奇偶校验检查是奇数，则将该位设置为1以否则继续前进。如果！奇偶校验（＆amp;代码，i）{code | = 0b1＆lt;＆lt; （2usize.pow（i））;编码}</p><p> If we were to think of this graphically, it may look something like this, ( 1) we get our raw input, ( 2) we map the raw input to the encoded output as part of its data bits and ( 3) we calculate the parity bits and map them to the encoded output as parity bits.</p><p> 如果我们要以图形方式思考，它可能看起来像这样，（1）我们得到了我们的原始输入，（2）我们将原始输入映射到编码输出作为其数据位的一部分和（3）我们计算的奇偶校验位并将其映射到编码输出作为奇偶校验位。</p><p>  Let&#39;s test the implementation out; the results match the expected output and running through a simple benchmark ( criterion), does not yield promising results. Our baseline median execution time of  430.44ns for our encoder with a large number of odd outliers. We now have something that we can improve.</p><p>  让＆＃39;测试实施;结果与预期的输出和通过简单的基准（标准）匹配，不会产生有希望的结果。我们的基准中位数执行时间为430.44ns，为我们的编码器具有大量奇数异常值。我们现在有一些我们可以改进的东西。</p><p>  There are some definite quick wins we can work with here. For starters, since we know we&#39;re always going to work with  u64 (or any fixed-width block size),  len_power and  len do not need to be computed every time we want to encode a block. Let&#39;s also remove a   copy for the internal  encoded variable that is not needed.</p><p>  有一些明确的胜利我们可以在这里合作。对于初学者来说，自从我们知道我们＆＃39;重新始终使用U64（或任何固定宽度块大小），每次想要编码块时都不需要计算Len_Power和Len。让＆＃39; s还删除了不需要的内部编码变量的副本。</p><p> pub fn encode(block: &amp;mut u64) -&gt; u64 { let len_power = 6; let len = 64; let mut code = 0u64;	 // ... Remove `encoded` and work directly on `code` only for i in 0..len_power { // If the parity check is odd, set the bit to 1 otherwise move on. if !parity(&amp;code, i) { code |= 0b1 &lt;&lt; (2usize.pow(i) - 1); } } code}</p><p> PUB FN编码（块：＆amp; mut U64） - ＆gt; U64 {让Len_Power = 6;让Len = 64;让mut code = 0u64; // ...删除“编码”，并仅在“代码”上（即可在“I //”奇偶校验是奇数的情况下，将该位设置为1，以否则将其设置为“。如果！奇偶校验（＆amp;代码，i）{code | = 0b1＆lt;＆lt; （2usize.pow（i） -  1）; } } 代码}</p><p> Re-running our benchmarks, we now run in a median time of  361.27ns, a ~17.5% performance increase. We&#39;re still seeing some outliers, but the average execution time is now bundled up better.</p><p> 重新运行我们的基准，我们现在在361.27ns的中位时间运行，性能增加〜17.5％。我们仍然看到了一些异常值，但平均执行时间现在捆绑更好。</p><p>  At this stage, there are two branching conditions left in our encoder which I will largely leave as to avoid over optimising early on. Let&#39;s profile (via   perf) and plot (via   flamegraph) our encoder and take a peak at the overall execution time.</p><p>  在这个阶段，我们的编码器中还剩两个分支条件，我将在很大程度上离开，以避免早期优化。让＆＃39; s型材（通过perf）和plot（通过函数）我们的编码器，并在整个执行时间迈出峰值。 </p><p> This SVG was hand-edited to save space and keep it interactive. It was not fun and the sample frequency in this sample is low but it translates well enough to larger sample rates (~99Hz).</p><p>此SVG被手动编辑以节省空间并保持交互式。它并不好玩，该样品中的样品频率低，但它很好地转化为更大的样品速率（〜99Hz）。</p><p>  The primary culprit here is the  parity function taking circa ~75% of the total encoder execution time. It&#39;s clear that our parity function isn&#39;t really doing too great so the next natural step is to optimise it which will positively affect the entire implementation. Referring back to the introduction, this is what I meant by shared component.</p><p>  这里的主要罪魁祸首是奇偶校验函数以总编码器执行时间的大约〜75％。它明确了我们的奇偶函数isn＆＃39; t真的做得太大，所以下一个自然步骤是优化它会对整个实施产生积极影响。返回介绍，这是我的意思是由共享组件的意思。</p><p>  Let&#39;s take a boiled down view of the implementation to understand where and how we can optimise our implementation. The parity checker&#39;s job is to determine if a certain sequence of bits are either odd ( 1), or even ( 0). Recall our encoded message is made up of data bits and parity bits.</p><p>  让＆＃39;逐渐落下了解实现，了解我们如何优化我们的实现。奇偶校验检查器＆＃39; S作业是确定某个位序列是否是奇数（1），甚至（0）。回想一下我们的编码消息由数据位和奇偶校验位组成。</p><p>  If we actually take a look at the indexes of the parity bits, they are always exactly a power of 2. So our set of parity bits  P can be rewritten from  P = { P1, P2, P3, P4 } to  P = { 0001, 0010, 0100, 1000 } whereby an intuitive and elegant pattern emerges –</p><p>  如果我们实际上看看奇偶校验位的索引，它们始终是2.所以我们的一组奇偶校验位P可以从P = {P1，P2，P3，P4}重写为P = {0001 ，0010,0100，1000}在那里，直观而优雅的模式出现 - </p><p>  P1 = 2^0 = 1 therefore checks for 1 bit, then skips 1 bit.  P2 = 2^1 = 2 checks for 2 bits, then skips two bits.  P3 checks every 4 bits then skips 4 bits and finally  P4 checks every 8 bits then skips 8 bits.</p><p>  P1 = 2 ^ 0 = 1因此检查1位，然后跳过1位。 P2 = 2 ^ 1 = 2检查2位，然后跳过两位。 P3检查每4位然后跳过4位，最后p4每8位检查每8位，然后跳过8位。</p><p> Note – ignore the  0th bit for now. That will be a global parity bit, part of extended hamming code that checks parity  all bits. We&#39;ll get back to this.</p><p> 注意 - 立即忽略第0位。这将是一个全局奇偶校验位，一部分扩展的汉明代码，检查奇偶校验所有位。我们＆＃39; ll回到这个。</p><p> This visualiation helps to show how parity bits are spread and interleaved to maximise their coverage of all the binary block.</p><p> 这种可视化有助于显示奇偶校验比特如何扩展和交错，以最大化其所有二进制块的覆盖范围。 </p><p>  There are many cases where we do not need to check every bit. For example:</p><p>我们有许多情况下我们不需要检查每一位。例如：</p><p> Parity bit  P4 starts from the 8th element, so there is no need to check the first 8 bits (we may jump ahead);</p><p> 奇偶校验位P4从第8元开始，因此不需要检查前8位（我们可能会跳转）;</p><p> Do not iterate over every bit incrementally, instead skip over bits that are not relevant to a given parity bit. If  P2 checks of  0010 and  0011 and skips  0100 and  0101, then there is no need to iterate over the latter two.</p><p> 不要逐步延迟每位迭代，而是跳过与给定奇偶校验位无关的位。如果P2检查0010和0011并跳过0100和0101，则不需要迭代后两个。</p><p>   Taking a look at our parity check, it may look more involved relative to our encoder.  If we compare it to the points above, we&#39;re doing a good job of not starting the loop from the 0th index but rather from the first bit that is relevant for a given parity. One thing we are not doing so well is that this implementation goes over  every bit and  then determines if we should ignore it or not, which is costly.</p><p>   看看我们的奇偶校验检查，它可能看起来更涉及我们的编码器。如果我们将其与上面的点进行比较，我们＆＃39;重新开始从第0个索引开始循环，而是从与给定奇偶校验相关的第一个比特。我们不那么做的一件事是这个实现越过每位，然后确定我们是否应该忽略它，这是昂贵的。</p><p> fn parity(code: &amp;u64, i: u32) -&gt; bool { let bi = (0b1 &lt;&lt; i) - 1; let (mut parity, mut ignore, mut counter) = (true, false, 0); for j in bi..64 { if !ignore &amp;&amp; (code &amp; 0b1 &lt;&lt; j) != 0b0 { parity = !parity; } counter += 1; if counter &gt;= 0b1 &lt;&lt; i { ignore = !ignore; counter = 0; } } parity // true if even}</p><p> fn奇偶校验（代码：＆amp; u64，i：u32） - ＆gt; BOOL {假设0B1＆lt; i） -  1;让（mut奇偶校验，mut忽略，mut计数器）=（true，false，0）;对于Bi的J.64 {If！Ignore＆amp;＆amp; （代码＆amp; 0b1＆lt; j）！= 0b0 {parity =！parity; }计数器+ = 1;如果计数器＆gt; = 0b1＆lt;我{忽略=！忽略;计数器= 0;如果偶数}}}}奇偶校验//</p><p> Taking a look at the underlying assembly (via   cargo-asm with  rust flag enabled) we see that there&#39;s a lot going on, primarily because of all the  counter and  ignore checks that we mention above.</p><p> 看看潜在的汇编（通过锈旗上的货物ASM，我们已经看到了，我们看到了很多事情，主要是因为所有的柜台和忽略了我们上面提到的检查。</p><p>  My initial impression is that there is not a lot of  branching going on but our loops are simply longer than they need to be. Let&#39;s see if we can write the skipping functionality that actually skips bits it doesn&#39;t need to compute (as opposed to computing,  then deciding if it should skip). After some back-of-the-napkin dry runs, I boiled it down to the following which passes the tests.</p><p>  我最初的印象是，没有很多分支继续，但我们的循环只是比他们需要的长。让＆＃39;我们看看我们是否可以编写实际跳过的跳过功能，它不需要计算（而不是计算，然后决定它应该跳过）。在一些背后的干燥运行后，我将其煮沸到以下，通过测试。 </p><p> pub fn parity(code: &amp;u64, i: u32) -&gt; bool { let mut parity = true; let spread = 2u32.pow(i); let mut j = spread; while j &lt; 64 - spread + 1 { for k in 0..spread { if (code &amp; 0b1 &lt;&lt; j + k) != 0b0 { parity = !parity; } } j += 2 * spread; } parity}</p><p>PUB FN奇偶校验（代码：＆amp; U64，I：U32） - ＆gt; bool {让mut parity = true;让传播= 2u32.pow（i）;让mut j =传播; j＆lt; 64  - 扩展+ 1 {对于0.spread {if（代码＆amp; 0b1＆lt; j + k）！= 0b0 {parity =！parity; }} J + = 2 *传播;奇偶校验}</p><p> We do away with the  ignore and  counter variables and instead skip bits depending on the parity bit we are checking. Whenever we land on a block of bits that we should be checking, we run an internal loop to scan through that entire block, dictated by some spread (i.e. number of consecutive bits we ought to compute) and subsequently jump to the next index.</p><p> 我们消除忽略和计数器变量，而是根据我们正在检查的奇偶校验位跳过比特。每当我们登陆我们应该检查的比特块时，我们都会运行内部循环以扫描整个块，由某些传播（即，我们应该计算的连续比特数量）并随后跳转到下一个索引。</p><p>  The emitted assembly is only slightly reduced but is simpler and quicker resulting in a median execution time of  3.76ns versus  72.23ns.</p><p>  发射的组装仅略微减少，但更简单，更快地导致中值执行时间为3.76ns而不是72.23ns。</p><p>  Remember that 0th bit that we did not cover with our current parity checks? That&#39;s a special parity bit that checks the parity of the  entire block (including all parity and data bits). This is known as  extended hamming code; on top of being able to correct single bit errors, it also allows us to detect (but  not correct) two-bit errors. Let&#39;s try to achieve this using a naive implementation which goes over each bit and computes the global parity.</p><p>  请记住，我们当前的奇偶校验检查我们没有覆盖的第0位？ ＆＃39; s一个特殊的奇偶校验位，用于检查整个块的奇偶校验（包括所有奇偶校验和数据位）。这被称为延伸的汉明码;在能够纠正单个比特错误之上，它还允许我们检测（但不正确）两位错误。让＆＃39;尝试使用难度的实现来实现这一目标，该实现超过每位并计算全局奇偶校验。</p><p> pub fn slow_parity(code: u64) -&gt; bool { let mut parity = true; for i in 0..63 { if code &amp; 0b1 &lt;&lt; i != 0 { parity = !parity; } } parity}</p><p> PUB FN SLOW_PARTY（代码：U64） - ＆gt; bool {让mut parity = true;对于我在0..63 {如果代码＆amp; 0b1＆lt;＆lt;＆lt;我！= 0 {parity =！奇偶校验; }}奇偶校验}</p><p> Running it through our benchmark we can see this takes  7.7907ns median execution time – not great.</p><p> 通过我们的基准运行我们可以看到这需要7.7907ns的中位数执行时间 - 不是很好。</p><p> slow_parity check time: [7.7806 ns 7.7907 ns 7.8013 ns] Found 12 outliers among 100 measurements (12.00%) 8 (8.00%) high mild 4 (4.00%) high severe</p><p> 慢速检查时间：[7.7806 ns 7.7907 ns 7.8013 ns]在100次测量中找到12个异常值（12.00％）8（8.00％）高温4（4.00％）高严重 </p><p> There is a more intuitive way of tackling this which I took from the book,  Hacker&#39;s Delight (vol. 2, p. 96) by  Henry S. Warren Jr. If you haven&#39;t come across this book before, I really cannot recommend it enough. It&#39;s a goldmine. Here&#39;s an excerpt of the relevant section.</p><p>在亨利S.沃伦JR的情况下，有一种更直观地解决这本书，黑客＆＃39;令人愉快的乐趣（第2卷，第96卷）。如果你以前没有举行这本书，我真的无法推荐它。它＆＃39;是一个金矿。这里＆＃39;相关部分的摘录。</p><p>  Let&#39;s implement this, performing a rolling XOR and take the rightmost bit, extended to 64-bit blocks instead of the author&#39;s original 32-bit block.</p><p>  Let＆＃39; s实现这一点，执行滚动XOR并采取右边的位，扩展到64位块而不是作者＆＃39; s原始32位块。</p><p> pub fn fast_parity(code: u64) -&gt; u64 { let mut y: u64 = code ^ (code &gt;&gt; 1); y ^= y &gt;&gt; 2; y ^= y &gt;&gt; 4; y ^= y &gt;&gt; 8; y ^= y &gt;&gt; 16; y ^= y &gt;&gt; 32; 0b1 &amp; y}</p><p> PUB FN Fast_Parity（代码：U64） - ＆gt; U64 {让Mut Y：U64 =代码^（代码＆gt; 1）; y ^ = y＆gt;＆gt; 2; y ^ = y＆gt;＆gt; 4; y ^ = y＆gt;＆gt; 8; y ^ = y＆gt;＆gt; 16; y ^ = y＆gt;＆gt; 32; 0B1＆amp; y}</p><p> The difference is quite stark. Running it through our benchmark we can see the fast parity check running at  937ps (where 1ps = 0.001ns) median execution time versus  7.7907ns median execution time, translating to roughly a ~8300% improvement.</p><p> 差异非常鲜明。通过我们的基准测试我们可以看到快速奇偶校验检查以937ps（其中1ps = 0.001ns）中值执行时间与7.7907ns的中值执行时间，转化为大约8300％的改进。</p><p> fast_parity check time: [937.54 ps 937.86 ps 938.26 ps] Found 13 outliers among 100 measurements (13.00%) 5 (5.00%) high mild 8 (8.00%) high severeslow_parity check time: [7.7806 ns 7.7907 ns 7.8013 ns] Found 12 outliers among 100 measurements (12.00%) 8 (8.00%) high mild 4 (4.00%) high severe</p><p> Fast_Parity检查时间：[937.54 PS 937.86 PS 938.26 PS]在100次测量中找到13个异常值（13.00％）5（5.00％）高温8（8.00％）High SevereSlow_Parity检查时间：[7.7806 NS 7.7907 NS 7.8013 NS]找到了12个异常值在100次测量（12.00％）中，8（8.00％）高温4（4.00％）高严重</p><p> If we compare the assembly code generated we can take a peek as to how this result is achieved thanks to compiler optimisations.</p><p> 如果我们比较生成的汇编代码，我们可以偷看如何通过编译器优化实现这一结果。</p><p>      We can now easily use the  fast_parity check in our encoder before returning the encoded message at the very bottom.</p><p>      我们现在可以在返回非常底部的编码消息之前轻松使用Fast_Parity检查。 </p><p>   Running our benchmarks one more time for both the encoder and decoder yields some promising improvements.</p><p>再次运行我们的基准测试，再次为编码器和解码器产生一些有希望的改进。</p><p> hamming encode time: [153.33 ns 153.38 ns 153.43 ns] change: [-57.763% -57.720% -57.680%] (p = 0.00 &lt; 0.05) Performance has improved.hamming decode time: [118.57 ns 118.60 ns 118.65 ns] change: [-72.866% -72.823% -72.782%] (p = 0.00 &lt; 0.05) Performance has improved.</p><p> 汉明编码时间：[153.33 ns 153.38 ns 153.43 ns]变化：[-57.763％-57.720％-57.680％]（p = 0.05）性能提高了。[118.57 ns 118.60 ns 118.65 ns]变化：[-72.866％-72.823％-72.782％]（P = 0.05）性能提高。</p><p>    If we contrast this with our previous implementations we can see a much faster execution time as well as more stability (dictated by density) with fewer outliers.</p><p>    如果我们将其与以前的实现对比，我们可以看到更快的执行时间以及更少的异常值更快的执行时间以及更多的稳定性（由密度决定）。</p><p>  At this stage, this should cover most of the improvements from an algorithm perspective. There may be some room to further optimise the overall parity checker (not the fast global one) but we can get to that later.</p><p>  在此阶段，这应该涵盖算法视角的大部分改进。可能有一些空间可以进一步优化整体奇偶校验者（不是快速全球的空间），但我们可以稍后获得。</p><p>  The remaining part of our implementation is the decoder. I will not go into as much detail as the implementation is quite simple –</p><p>  我们实现的其余部分是解码器。我不会像实施非常简单一样详细融洽 - </p><p> Re-calculate every parity bit, if there are any odd parities then we have at least one error;</p><p> 如果有任何奇数阶段，则重新计算每个奇偶校验位，然后我们至少有一个错误;</p><p>  If the &#34;check&#34; value is greater than 0, we have an error. Flip the bit corresponding to the &#34;check&#34; value (e.g. if error check is 10110, flip the bit in the 11th index);</p><p>  如果和＃34;检查＆＃34;值大于0，我们有一个错误。翻转对应于＆＃34的比特;检查＆＃34;值（例如，如果错误检查为10110，请在第11索引中翻转该位）; </p><p> pub fn decode(code: &amp;mut u64) -&gt; u64 { let len_power = 6; let len = 64; let mut check = 0b0; for i in 0..len_power { if !parity(&amp;code, i) { check |= 0b1 &lt;&lt; i; } } // We have an error if check &gt; 0b0 { *code ^= 0b1 &lt;&lt; check; } // Drop all parity bits let mut offset = 0; let mut decoded = 0b0; for i in 0..len { // Check if `i` is not a power of 2 if (i != 0) &amp;&amp; (i &amp; (i - 1)) != 0 { decoded |= ((0b1 &lt;&lt; i) &amp; *code) &gt;&gt; offset; } else { offset += 1; } } decoded}</p><p>PUB FN解码（代码：＆amp; mut U64） - ＆gt; U64 {让Len_Power = 6;让Len = 64;让mut检查= 0b0;对于我在0..len_power {if！奇偶校验（＆amp; code，i）{check | = 0b1＆lt;一世; }} //如果检查＆gt; 0b0 {*代码^ = 0b1＆lt;＆lt;查看; } //删除所有奇偶校验位让mut offset = 0;让mut解码= 0b0;因为我在0..len {//检查'i`如果（i！= 0）＆amp;＆amp; （I＆amp;（I  -  1））！= 0 {解码| =（（0b1＆lt; i）＆amp; *代码）＆gt;＆gt;抵消; } else {offset + = 1;解码}</p><p> There isn&#39;t much else left to add here but I&#39;ll still be exploring some ways to speed this up. Keep in mind that right now there is no global parity check.</p><p> 还有别的别人别的东西在这里添加，但我＆＃39; ll仍然探索一些加速这一点的方法。请记住，现在没有全球奇偶校验。</p><p>   This post took a while to write but it aims to show how one might go about tackling a problem and later optimising it. The implementation is not feature complete, there are a few boundary checks missing and we are not checking and testing for the global parity bit in the decoder – it&#39;s meant to be a gradual learning exercise.</p><p>   这篇文章需要一段时间才能写作，但它旨在展示如何解决问题，并稍后优化它。实现不是功能完整的，有几个边界检查丢失，我们没有检查和测试解码器中的全局奇偶校验位 - 它＆＃39;意图是逐步的学习练习。</p><p> I am contemplating extending this solution to optimise it from a workload distribution standpoint through  SIMD and/or parallel workloads. What happens if we use narrower or wider data blocks (i.e. 256-bit)? Can we calculate how many bytes by second we can process with this encoder using real-world scenarios? What&#39;s the expected industry standard and can we get close to (perhaps even leveraging architecture specific instructions).</p><p> 我正在考虑扩展该解决方案，以通过SIMD和/或并行工作负载从工作负载分配立场优化它。如果我们使用较窄或更广泛的数据块（即256位）会发生什么？我们可以通过使用真实世界的场景来计算第二个我们可以使用此编码器来处理多少字节？什么＆＃39;是预期的行业标准，我们可以接近（也许甚至利用架构具体说明）。</p><p> If you are interested in this or have any feedback you&#39;d like to pass, feel free to  reach out, I&#39;d love to hear your input.</p><p> 如果你对此感兴趣或有任何反馈＆＃39; d喜欢通过，随意伸出援手，我喜欢听你的意见。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.digital-horror.com/rediscovering-hamming-code/">https://blog.digital-horror.com/rediscovering-hamming-code/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/发现/">#发现</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hamming/">#hamming</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/奇偶校验/">#奇偶校验</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>