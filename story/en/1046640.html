<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>莫克斯不是存根（2007） Mocks Aren't Stubs (2007)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Mocks Aren't Stubs (2007)<br/>莫克斯不是存根（2007） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-29 13:15:33</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/adf0e5d53803a381eed056e4a815ffe2.png"><img src="http://img2.diglog.com/img/2021/1/adf0e5d53803a381eed056e4a815ffe2.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The term &#39;Mock Objects&#39; has become a popular one to	describe special case objects that mimic real objects for	testing. Most language environments now have frameworks that make it	easy to create mock objects. What&#39;s often not realized, however, is	that mock objects are but one form of special case test object, one	that enables a different style of testing. In this article I&#39;ll	explain how mock objects work, how they encourage testing based on	behavior verification, and how the community around them uses them	to develop a different style of testing.</p><p>术语“模拟对象”已经成为描述特殊情况对象的流行方法，这些特殊情况对象模仿了要测试的真实对象。现在，大多数语言环境都具有易于创建模拟对象的框架。但是，通常没有意识到的是，模拟对象只是一种特殊情况测试对象的形式，一种实现了不同风格的测试。在本文中，我将解释模拟对象如何工作，它们如何基于行为验证鼓励测试以及它们周围的社区如何使用它们来开发不同的测试样式。</p><p> I first came across the term &#34;mock object&#34; a few years ago in the Extreme Programming (XP) community. Since then I&#39;ve run into mock objects more and more.Partly this is because many of the leading developers of mock objectshave been colleagues of mine at ThoughtWorks at various times. Partly it&#39;sbecause I see them more and more in the XP-influenced testingliterature.</p><p> 我首先遇到了“模拟对象”一词。几年前在极限编程（XP）社区中。从那时起，我就越来越多地遇到模拟对象。部分原因是，许多领先的模拟对象开发人员一直是ThoughtWorks的同事。部分原因是因为我在受XP影响的测试文学中越来越多地看到它们。</p><p> But as often as not I see mock objects described poorly. In particular Isee them often confused with stubs - a common helper to testingenvironments. I understand this confusion - I saw them as similar fora while too, but conversations with the mock developers have steadilyallowed a little mock understanding to penetrate my tortoiseshellcranium.</p><p> 但是我经常看到模拟对象的描述很差。我特别看到它们经常与存根混淆-存根是测试环境的常见帮助。我理解这种困惑-我也曾将它们视为相似的论坛，但与模拟开发人员的交谈一直在稳步允许一些模拟理解，以渗透我的to壳颅骨。</p><p> This difference is actually two separate differences. On the		one hand there is a difference in how test results are verified: a		distinction between state verification and behavior		verification. On the other hand is a whole different philosophy to		the way testing and design play together, which I term here as the		classical and mockist styles of  Test Driven Development.</p><p> 这种差异实际上是两个单独的差异。一方面，如何验证测试结果存在差异：状态验证和行为验证之间的区别。另一方面，与测试和设计共同发挥作用的哲学完全不同，我在这里将其称为“测试驱动开发”的经典和模拟风格。</p><p> I&#39;ll begin by illustrating the two styles with a simpleexample. (The example is in Java, but the principles make sense withany object-oriented language.) We want to take an order object and fill it from a warehouseobject. The order is very simple, with only one product and aquantity. The warehouse holds inventories of different products. Whenwe ask an order to fill itself from a warehouse there are two possibleresponses. If there&#39;s enough product in the warehouse to fill theorder, the order becomes filled and the warehouse&#39;s amount of theproduct is reduced by the appropriate amount. If there isn&#39;t enoughproduct in the warehouse then the order isn&#39;t filled and nothinghappens in the warehouse.</p><p> 我将通过一个简单的例子来说明这两种样式。 （该示例使用Java，但是这些原则对于任何面向对象的语言都是有意义的。）我们想获取一个订单对象，并从一个仓库对象中填充它。订单非常简单，只有一种产品和数量。仓库中存放着不同产品的库存。当我们要求从仓库填满订单时，有两种可能的响应。如果仓库中有足够的产品来填充订单，则订单将被填充，并且仓库中的产品数量将减少适当的数量。如果仓库中没有足够的产品，则订单无法填写，仓库中什么也没发生。</p><p>  public class OrderStateTester extends TestCase { private static String TALISKER = &#34;Talisker&#34;; private static String HIGHLAND_PARK = &#34;Highland Park&#34;; private Warehouse warehouse = new WarehouseImpl(); protected void setUp() throws Exception { warehouse.add(TALISKER, 50); warehouse.add(HIGHLAND_PARK, 25); } public void testOrderIsFilledIfEnoughInWarehouse() { Order order = new Order(TALISKER, 50); order.fill(warehouse); assertTrue(order.isFilled()); assertEquals(0, warehouse.getInventory(TALISKER)); } public void testOrderDoesNotRemoveIfNotEnough() { Order order = new Order(TALISKER, 51); order.fill(warehouse); assertFalse(order.isFilled()); assertEquals(50, warehouse.getInventory(TALISKER)); }</p><p>  公共类OrderStateTester扩展了TestCase {private static String TALISKER =＆＃34; Talisker＆＃34 ;;私有静态字符串HIGHLAND_PARK =＆＃34; Highland Park＆＃34 ;;私人仓库仓库= new WarehouseImpl（）;受保护的void setUp（）引发异常{Warehouse.add（TALISKER，50）; Warehouse.add（HIGHLAND_PARK，25）; } public void testOrderIsFilledIfEnoughInWarehouse（）{订单=新订单（TALISKER，50）; order.fill（仓库）; assertTrue（order.isFilled（））; assertEquals（0，Warehouse.getInventory（TALISKER））; } public void testOrderDoesNotRemoveIfNotEnough（）{订单=新订单（TALISKER，51）; order.fill（仓库）; assertFalse（order.isFilled（））; assertEquals（50，Warehouse.getInventory（TALISKER））; }</p><p> xUnit tests follow a typical four phase sequence: setup, exercise,			verify, teardown. In this case the setup phase is done partly in the			setUp method (setting up the warehouse) and partly in the test			method (setting up the order). The call to  order.fill is the			exercise phase. This is where the object is prodded to do the			thing that we want to test. The assert statements are then the			verification stage, checking to see if the exercised method			carried out its task correctly. In this case there&#39;s no explicit			teardown phase, the garbage collector does this for us implicitly.</p><p> xUnit测试遵循典型的四个阶段顺序：设置，练习，验证，拆卸。在这种情况下，设置阶段部分通过setUp方法（设置仓库）完成，部分通过测试方法（设置订单）完成。对order.fill的调用是练习阶段。这就是该对象倾向于执行我们要测试的事情的地方。然后，assert语句进入验证阶段，检查执行的方法是否正确执行了其任务。在这种情况下，没有明确的拆卸阶段，垃圾收集器会为我们隐式地完成此任务。 </p><p> During setup there are two kinds of object that we are			putting together. Order is the class that we are testing, but			for  Order.fill to work we also need an instance of			Warehouse. In this situation Order is the object that we are			focused on testing. Testing-oriented people like to use terms			like object-under-test or system-under-test to name such a			thing. Either term is an ugly mouthful to say, but as it&#39;s			a widely accepted term I&#39;ll hold my nose and use it. Following			Meszaros I&#39;ll use System Under Test, or rather the abbreviation SUT.</p><p>在设置过程中，有两种对象要放在一起。 Order是我们正在测试的类，但是要使Order.fill正常工作，我们还需要一个Warehouse实例。在这种情况下，订单是我们重点测试的对象。面向测试的人喜欢使用被测对象或被测系统之类的术语来命名此类事物。这两个词都很难说，但由于它是一个广为接受的词，所以我会紧握鼻子并使用它。在Meszaros之后，我将使用“被测系统”，或简称SUT。</p><p> So for this test I need the SUT ( Order) and onecollaborator ( warehouse). I need the warehouse for tworeasons: one is to get the tested behavior to work at all (since Order.fill calls warehouse&#39;s methods) and secondly I needit for verification (since one of the results of Order.fill is apotential change to the state of the warehouse). As we explore thistopic further you&#39;ll see there we&#39;ll make a lot of the distinctionbetween SUT and collaborators. (In the earlier version of this articleI referred to the SUT as the &#34;primary object&#34; and collaborators as&#34;secondary objects&#34;)</p><p> 因此，对于此测试，我需要SUT（订单）和一个合作者（仓库）。我需要仓库有两个原因：一个是使已测试的行为完全起作用（因为Order.fill调用仓库的方法），其次我需要进行验证（因为Order.fill的结果之一是可能的更改）到仓库的状态）。当我们进一步探索该主题时，您将看到在那里我们将在SUT和协作者之间做出很多区分。 （在本文的早期版本中，我将SUT称为＆＃34;主要对象＆＃34;并将协作者称为＆＃34;次要对象＆＃34;）</p><p> This style of testing uses  state verification:which means that we determine whether the exercised method workedcorrectly by examining the state of the SUT and its collaboratorsafter the method was exercised. As we&#39;ll see, mock objects enable adifferent approach to verification.</p><p> 这种测试方式使用状态验证：这意味着我们可以通过在执行该方法后检查SUT及其合作者的状态来确定所执行的方法是否正确工作。正如我们将看到的，模拟对象启用了不同的验证方法。</p><p> Now I&#39;ll take the same behavior and use mock objects. For this code I&#39;m using the jMock library for definingmocks. jMock is a java mock object library. There are other mockobject libraries out there, but this one is an up to date librarywritten by the originators of the technique, so it makes a good one tostart with.</p><p> 现在，我将采取相同的行为并使用模拟对象。对于此代码，我使用jMock库定义模拟。 jMock是一个Java模拟对象库。还有其他的模拟对象库，但这是该技术的创建者编写的最新库，因此它是一个很好的起点。</p><p> public class OrderInteractionTester extends MockObjectTestCase { private static String TALISKER = &#34;Talisker&#34;; public void testFillingRemovesInventoryIfInStock() { //setup - data Order order = new Order(TALISKER, 50); Mock warehouseMock = new Mock(Warehouse.class); //setup - expectations warehouseMock.expects(once()).method(&#34;hasInventory&#34;) .with(eq(TALISKER),eq(50)) .will(returnValue(true)); warehouseMock.expects(once()).method(&#34;remove&#34;) .with(eq(TALISKER), eq(50)) .after(&#34;hasInventory&#34;); //exercise order.fill((Warehouse) warehouseMock.proxy()); //verify warehouseMock.verify(); assertTrue(order.isFilled()); } public void testFillingDoesNotRemoveIfNotEnoughInStock() { Order order = new Order(TALISKER, 51); Mock warehouse = mock(Warehouse.class); warehouse.expects(once()).method(&#34;hasInventory&#34;) .withAnyArguments() .will(returnValue(false)); order.fill((Warehouse) warehouse.proxy()); assertFalse(order.isFilled()); }</p><p> 公共类OrderInteractionTester扩展了MockObjectTestCase {private static String TALISKER =＆＃34; Talisker＆＃34 ;; public void testFillingRemovesInventoryIfInStock（）{//设置-数据订单=新订单（TALISKER，50）; Mock WarehouseMock =新的Mock（Warehouse.class）; //设置-期望WarehouseMock.expects（once（））。method（＆＃34; hasInventory＆＃34;）.with（eq（TALISKER），eq（50））.will（returnValue（true））; WarehouseMock.expects（once（））。method（＆＃34; remove＆＃34;）.with（eq（TALISKER），eq（50））.after（＆＃34; hasInventory＆＃34;）; //执行order.fill（（Warehouse）WarehouseMock.proxy（））; //验证WarehouseMock.verify（）; assertTrue（order.isFilled（））; } public void testFillingDoesNotRemoveIfNotEnoughInStock（）{订单=新订单（TALISKER，51）;模拟仓库=模拟（Warehouse.class）; Warehouse.expects（once（））。method（＆＃34; hasInventory＆＃34;）.withAnyArguments（）.will（returnValue（false））; order.fill（（Warehouse）Warehouse.proxy（））; assertFalse（order.isFilled（））; }</p><p>  To begin with, the setup phase is very different. For a start			it&#39;s divided into two parts: data and expectations. The data			part sets up the objects we are interested in working with, in			that sense it&#39;s similar to the traditional setup. The difference			is in the objects that are created. The SUT is the same -			an order. However the collaborator isn&#39;t a warehouse object,			instead it&#39;s a mock warehouse - technically an instance of the			class  Mock.</p><p>  首先，设置阶段非常不同。首先，它分为两个部分：数据和期望。数据部分设置了我们感兴趣的对象，从这个意义上讲，它类似于传统设置。区别在于创建的对象。 SUT是相同的-订单。但是，协作者不是仓库对象，而是一个模拟仓库-从技术上讲是Mock类的实例。</p><p> The second part of the setup creates expectations on the mock			object.The expectations indicate which methods should be called on themocks when the SUT is exercised.</p><p> 设置的第二部分在模拟对象上创建期望，期望表明在执行SUT时应在它们上调用哪些方法。 </p><p> Once all the expectations are in place I exercise theSUT. After the exercise I then do verification, which has twoaspects. I runasserts against the SUT - much as before. However I alsoverify the mocks - checking that they were called according to theirexpectations.</p><p>一旦所有期望都实现了，我就开始练习。练习后，我将进行验证，这有两个方面。我对SUT断言-和以前一样。但是，我也验证了模拟-检查它们是否根据期望被调用。</p><p> The key difference here is how we verify that the order did			the right thing in its interaction with the warehouse. With			state verification we do this by asserts against the warehouse&#39;s			state. Mocks use  behavior verification, where we instead check			to see if the order made the correct calls on the warehouse. We			do this check by telling the mock what to expect during setup			and asking the mock to verify itself during verification. Only			the order is checked using asserts, and if the method			doesn&#39;t change the state of the order there&#39;s no asserts at all.</p><p> 此处的主要区别在于我们如何验证订单在与仓库的交互中所做的正确操作。通过状态验证，我们通过针对仓库状态进行断言来做到这一点。假人使用行为验证，而我们在其中检查订单是否在仓库中进行了正确的调用。我们通过告诉模拟程序在安装过程中期望什么并要求模拟程序在验证期间进行自我验证来进行此检查。仅使用断言检查订单，如果该方法不更改订单状态，则根本不会断言。</p><p> In the second test I do a couple of different things. Firstly Icreate the mock differently, using the  mock methodin MockObjectTestCase rather than the constructor. This is aconvenience method in the jMock library that means that I don&#39;t need toexplicitly call verify later on, any mock created with the conveniencemethod is automatically verified at the end of the test. I could havedone this in the first test too, but I wanted to show the verificationmore explicitly to show how testing with mocks works.</p><p> 在第二项测试中，我做了几件不同的事情。首先，我使用MockObjectTestCase中的模拟方法而不是构造函数来不同地创建模拟。这是jMock库中的一种便捷方法，这意味着我以后无需明确调用verify，在测试结束时会自动验证任何使用便捷方法创建的模拟。我也可以在第一个测试中做到这一点，但是我想更明确地显示验证，以显示使用模拟进行测试的工作方式。</p><p> The second different thing in the second test case is that I&#39;verelaxed the constraints on the expectation by using withAnyArguments. The reason for this is that the firsttest checks that the number is passed to the warehouse, so the secondtest need not repeat that element of the test. If the logic of theorder needs to be changed later, then only one test will fail, easingthe effort of migrating the tests. As it turns out I could have left withAnyArguments out entirely, as that is the default.</p><p> 第二个测试案例中的第二个不同之处是，我通过使用withAnyArguments明确了对期望的约束。这样做的原因是，第一个测试检查该编号是否已传递到仓库，因此，第二个测试无需重复测试的该元素。如果以后需要更改订单的逻辑，则只有一个测试将失败，从而简化了迁移测试的工作。事实证明，我本可以完全不使用AnyArguments，因为这是默认设置。</p><p> There are a number of mock object libraries out there. Onethat I come across a fair bit is EasyMock, both in its java and .NETversions. EasyMock also enable behavior verification, but hasa couple of differences in style with jMock which are worthdiscussing. Here are the familiar tests again:</p><p> 有许多模拟对象库。我碰到的一点是EasyMock，无论是在Java还是.NET版本中。 EasyMock还支持行为验证，但是jMock在样式上有几个值得讨论的地方。这又是熟悉的测试：</p><p> public class OrderEasyTester extends TestCase { private static String TALISKER = &#34;Talisker&#34;; private MockControl warehouseControl; private Warehouse warehouseMock; public void setUp() { warehouseControl = MockControl.createControl(Warehouse.class); warehouseMock = (Warehouse) warehouseControl.getMock(); } public void testFillingRemovesInventoryIfInStock() { //setup - data Order order = new Order(TALISKER, 50); //setup - expectations warehouseMock.hasInventory(TALISKER, 50); warehouseControl.setReturnValue(true); warehouseMock.remove(TALISKER, 50); warehouseControl.replay(); //exercise order.fill(warehouseMock); //verify warehouseControl.verify(); assertTrue(order.isFilled()); } public void testFillingDoesNotRemoveIfNotEnoughInStock() { Order order = new Order(TALISKER, 51); warehouseMock.hasInventory(TALISKER, 51); warehouseControl.setReturnValue(false); warehouseControl.replay(); order.fill((Warehouse) warehouseMock); assertFalse(order.isFilled()); warehouseControl.verify(); }}</p><p> 公共类OrderEasyTester扩展了TestCase {private static String TALISKER =＆＃34; Talisker＆＃34 ;;私人的MockControl WarehouseControl;私人仓库WarehouseMock;公共无效setUp（）{WarehouseControl = MockControl.createControl（Warehouse.class）; WarehouseMock =（仓库）WarehouseControl.getMock（）; } public void testFillingRemovesInventoryIfInStock（）{//设置-数据Order order = new Order（TALISKER，50）; //设置-期望WarehouseMock.hasInventory（TALISKER，50）; WarehouseControl.setReturnValue（true）; WarehouseMock.remove（TALISKER，50）; WarehouseControl.replay（）; //执行order.fill（warehouseMock）; // verify WarehouseControl.verify（）; assertTrue（order.isFilled（））; } public void testFillingDoesNotRemoveIfNotEnoughInStock（）{订单=新订单（TALISKER，51）; WarehouseMock.hasInventory（TALISKER，51）; WarehouseControl.setReturnValue（false）; WarehouseControl.replay（）; order.fill（（仓库）WarehouseMock）; assertFalse（order.isFilled（））; WarehouseControl.verify（）; }}</p><p> EasyMock uses a record/replay metaphor for settingexpectations. For each object you wish to mock you create a controland mock object. The mock satisfies the interface of the secondaryobject, the control gives you additional features. To indicate anexpectation you call the method, with the arguments you expect on themock. You follow this with a call to the control if you want a returnvalue. Once you&#39;ve finished setting expectations you call replay onthe control - at which point the mock finishes the recording and isready to respond to the primary object. Once done you call verify onthe control.</p><p> EasyMock使用记录/重放隐喻来设置期望。为每个您希望模拟的对象创建一个controland模拟对象。该模拟满足次要对象的界面，该控件为您提供了其他功能。为了表示期望，您可以调用方法，并在它们上添加所需的参数。如果需要返回值，可以在此之后调用控件。完成期望的设置后，您可以在控件上调用重播-此时，模拟将完成录制并准备响应主对象。完成后，请在控件上调用验证。 </p><p> It seems that while people are often fazed at first sight bythe record/replay metaphor, they quickly get used to it. It has anadvantage over the constraints of jMock in that you are makingactual method calls to the mock rather than specifying method names instrings. This means you get to use code-completion in your IDE and anyrefactoring of method names will automatically update the tests. Thedownside is that you can&#39;t have the looser constraints.</p><p>似乎人们常常对记录/重放隐喻一见钟情，但他们很快就习惯了。它比jMock的约束具有优势，因为您可以对模拟进行实际的方法调用，而不是在字符串中指定方法名称。这意味着您可以在IDE中使用代码完成功能，并且任何方法名称的重构都将自动更新测试。缺点是您不能拥有较宽松的约束。</p><p> The developers of jMock are working on a new version which				will use other techniques to allow you use actual method calls.</p><p> jMock的开发人员正在开发一个新版本，它将使用其他技术来允许您使用实际的方法调用。</p><p> When they were first introduced, many people easily confused			mock objects with the common testing notion of using			stubs. Since then it seems people have better understood the			differences (and I hope the earlier version of this paper			helped). However to fully understand the way people use mocks it			is important to understand mocks and other kinds of test			doubles. (&#34;doubles&#34;? Don&#39;t worry if this is a new term to you,			wait a few paragraphs and all will be clear.)</p><p> 首次引入模拟对象时，许多人很容易将模拟对象与使用存根的通用测试概念混淆。从那时起，人们似乎已经更好地理解了这些差异（我希望本文的早期版本有所帮助）。但是，要完全了解人们使用模拟的方式，重要的是要了解模拟和其他类型的测试双打。 （＆nbsp; doubles＆＃34 ;?不用担心这对您来说是个新名词，请等几段，然后便会清楚。）</p><p> When you&#39;re doing testing like this, you&#39;re focusing on			one element of the software at a time -hence the common term unit			testing. The problem is that to make a single unit work, you			often need other units - hence the need for some kind of			warehouse in our example.</p><p> 当您进行这样的测试时，您一次只关注软件的一个元素，因此使用了通用术语“单元测试”。问题在于，要使一个单元正常工作，您通常需要其他单元-因此在我们的示例中需要某种类型的仓库。</p><p> In the two styles of testing I&#39;ve shown above, the first case			uses a real warehouse object and the second case uses a mock			warehouse, which of course isn&#39;t a real warehouse object. Using			mocks is one way to not use a real warehouse in the test, but			there are other forms of unreal objects used in testing like this.</p><p> 在上面显示的两种测试样式中，第一种情况使用真实的仓库对象，第二种情况使用模拟仓库，这当然不是真正的仓库对象。使用模拟是在测试中不使用真实仓库的一种方法，但是像这样在测试中还有其他形式的虚幻对象。</p><p> The vocabulary for talking about this soon gets messy - all			sorts of words are used: stub, mock, fake, dummy. For this			article I&#39;m going to follow the vocabulary of Gerard Meszaros&#39;s			 book. It&#39;s not what everyone uses, but I think it&#39;s a			good vocabulary and since it&#39;s my essay I get to pick which			words to use.</p><p> 谈论这个的词汇很快就会变得混乱-使用了各种各样的单词：存根，模拟，伪造，伪造。对于本文，我将遵循Gerard Meszaros的书的词汇。它不是每个人都使用的，但是我认为它是一个很好的词汇，并且因为这是我的论文，所以我可以选择要使用的单词。</p><p> Meszaros uses the term  Test Double as the generic term for			any kind of pretend object used in place of a real object for			testing purposes. The name comes from the notion of a Stunt			Double in movies. (One of his aims was to avoid using any name			that was already widely used.) Meszaros then defined five			particular kinds of double:</p><p> Meszaros使用术语Test Double作为测试对象代替真实对象使用的任何假装对象的通用术语。该名称来自电影中的特技替身。 （他的目标之一是避免使用已经被广泛使用的任何名称。）然后，Meszaros定义了五种特殊的double类型： </p><p> Dummy objects are passed around but never actually		used. Usually they are just used to fill parameter lists.</p><p>虚拟对象可以传递，但从未实际使用过。通常它们仅用于填充参数列表。</p><p> Fake objects actually have working implementations, but		usually take some shortcut which makes them not suitable for		production (an  in memory database is a good example).</p><p> 伪对象实际上具有有效的实现，但是通常采取一些捷径，这使它们不适合生产（内存数据库就是一个很好的例子）。</p><p> Stubs provide canned answers to calls made during the test,		usually not responding at all to anything outside what&#39;s		programmed in for the test.</p><p> 存根提供对测试期间进行的呼叫的固定答复，通常通常根本不响应为测试编程的内容以外的任何内容。</p><p> Spies are stubs that also record some information based on how they were called. One form of this might be an email service that records how many messages it was sent.</p><p> 间谍是存根，它们还根据调用方式记录一些信息。其中一种形式可能是电子邮件服务，它记录发送了多少消息。</p><p> Mocks are what we are talking about here: objectspre-programmed with expectations which form a specification of thecalls they are expected to receive.</p><p> 嘲笑是我们在这里谈论的：带有期望的预编程对象，这些对象构成了期望接收的调用的规范。</p><p> Of these kinds of doubles, only mocks insist upon behavior			verification. The other doubles can, and usually do, use state			verification. Mocks actually do behave like other doubles during			the exercise phase, as they need to make the SUT believe it&#39;s			talking with its real collaborators - but mocks differ in			the setup and the verification phases.</p><p> 在这类双打中，只有模拟者坚持进行行为验证。其他双打通常可以使用状态验证。在练习阶段，模拟程序实际上的行为确实像其他双打游戏一样，因为他们需要让SUT相信与真正的合作者交谈-但是模拟在设置和验证阶段有所不同。</p><p> To explore test doubles a bit more, we need to extend ourexample. Many people only use a test double if the real object isawkward to work with. A more common case for a test double would be ifwe said that we wanted to send an email message if we failed to fillan order. The problem is that we don&#39;t want to send actual emailmessages out to customers during testing. So instead we create a testdouble of our email system, one that we can control andmanipulate.</p><p> 要进一步探索测试的两倍，我们需要扩展示例。如果实际对象难以使用，许多人只会使用测试倍数。如果我们说如果我们未能履行订购订单，我们想发送电子邮件，则更常见的是双重测试。问题是我们不想在测试过程中向客户发送实际的电子邮件消息。因此，我们改为创建电子邮件系统的testdouble，我们可以对其进行控制和操作。 </p><p> Here we can begin to see the difference between mocks and			stubs. If we were writing a test for this mailing behavior, we			might write a simple stub like this.</p><p>在这里，我们可以开始看到模拟和存根之间的区别。如果我们正在为此邮件行为编写测试，则可能会编写一个像这样的简单存根。</p><p>  public class MailServiceStub implements MailService { private List&lt;Message&gt; messages = new ArrayList&lt;Message&gt;(); public void send (Message msg) { messages.add(msg); } public int numberSent() { return messages.size(); }}</p><p>  公共类MailServiceStub实现MailService {private List＆lt; Message＆gt;消息=新ArrayList＆lt; Message＆gt;（）;公共无效发送（消息味精）{messages.add（msg）; } public int numberSent（）{return messages.size（）; }}</p><p>   public void testOrderSendsMailIfUnfilled() { Order order = new Order(TALISKER, 51); MailServiceStub mailer = new MailServiceStub(); order.setMailer(mailer); order.fill(warehouse); assertEquals(1, mailer.numberSent()); }</p><p>   公共无效testOrderSendsMailIfUnfilled（）{订单=新订单（TALISKER，51）; MailServiceStub mailer = new MailServiceStub（）; order.setMailer（mailer）; order.fill（仓库）; assertEquals（1，mailer.numberSent（））; }</p><p> Of course this is a very simple test - only that a message			has been sent. We&#39;ve not tested it was sent to the right person,			or with the right contents, but it will do to illustrate the			point.</p><p> 当然，这是一个非常简单的测试-仅发送了一条消息。我们尚未测试它是否已发送给正确的人或正确的内容，但可以说明这一点。</p><p>   public void testOrderSendsMailIfUnfilled() { Order order = new Order(TALISKER, 51); Mock warehouse = mock(Warehouse.class); Mock mailer = mock(MailService.class); order.setMailer((MailService) mailer.proxy()); mailer.expects(once()).method(&#34;send&#34;); warehouse.expects(once()).method(&#34;hasInventory&#34;) .withAnyArguments() .will(returnValue(false)); order.fill((Warehouse) warehouse.proxy()); }}</p><p>   公共无效testOrderSendsMailIfUnfilled（）{订单=新订单（TALISKER，51）;模拟仓库=模拟（Warehouse.class）;模拟邮件=模拟（MailService.class）; order.setMailer（（MailService）mailer.proxy（））; mailer.expects（once（））。method（＆＃34; send＆＃34;）; Warehouse.expects（once（））。method（＆＃34; hasInventory＆＃34;）.withAnyArguments（）.will（returnValue（false））; order.fill（（Warehouse）Warehouse.proxy（））; }}</p><p> In both cases I&#39;m using a test double instead of the real			mail service. There is a difference in that the stub uses			state verification while the mock uses behavior verification.</p><p> 在这两种情况下，我都使用双重测试代替真实邮件服务。区别在于存根使用状态验证，而模拟使用行为验证。</p><p> In order to use state verification on the stub, I need tomake some extra methods on the stub to help with verification. As aresult the stub implements  MailService but adds extratest methods.</p><p> 为了在存根上使用状态验证，我需要在存根上做一些额外的方法来帮助进行验证。结果，存根实现了MailService，但添加了Extratest方法。 </p><p> Mock objects always use behavior verification, a stub can go			either way. Meszaros refers to stubs that use behavior			verification as a Test Spy. The difference is in how exactly the			double runs and verifies and I&#39;ll leave that for you to explore			on your own.</p><p>模拟对象始终使用行为验证，存根可以任意选择。 Meszaros指的是将行为验证用作测试间谍的存根。区别在于两次运行和验证的精确程度不同，我将留给您自己进行探索。</p><p> Now I&#39;m at the point where I can explore the second			dichotomy: that between classical and mockist TDD. The big issue			here is  when to use a mock (or other double).</p><p> 现在，我可以探讨第二个二分法：古典与模拟主义者TDD之间的二分法。这里最大的问题是何时使用模拟（或其他双精度）。</p><p> The  classical TDD style is to use real objects if			possible and a double if it&#39;s awkward to use the real thing. So			a classical TDDer would use a real warehouse and a double for			the mail service. The kind of double doesn&#39;t really matter that			much.</p><p> 经典的TDD风格是在可能的情况下使用真实的对象，在不方便使用真实的对象的情况下使用两倍。因此，传统的TDDer将使用一个真实的仓库，并使用一个双重的邮件服务。双重类型并没有那么重要。</p><p> A  mockist TDD practitioner, however, will alwaysuse a mock for any object with interesting behavior. In this case forboth the warehouse and the mail service.</p><p> 但是，模拟派TDD练习者将始终对任何具有有趣行为的对象使用模拟。在这种情况下，仓库和邮件服务都没有。</p><p> Although the various mock frameworks were designed withmockist testing in mind, many classicists find them useful forcreating doubles.</p><p> 尽管在设计各种模拟框架时都考虑了模拟测试，但许多古典主义者发现它们对于创建双精度模型很有用。</p><p> An important offshoot of the mockist style is that of  Behavior Driven Development (BDD). BDDwas originally developed by my colleague Daniel Terhorst-North as a technique tobetter help people learn Test Driven Development by focusing on howTDD operates as a design technique. This led to renaming tests asbehaviors to better explore where TDD helps with thinking about whatan object needs to do. BDD takes a mockist approach, but it expands onthis, both with its naming styles, and with its desire to integrateanalysis within its technique. I won&#39;t go into this more here, as theonly relevance to this article is that BDD is another variation on TDDthat tends to use mockist testing. I&#39;ll leave it to you to follow the link for more information.</p><p> 模仿者风格的一个重要分支是行为驱动开发（BDD）。 BDD最初是由我的同事Daniel Terhorst-North开发的，旨在通过专注于TDD作为一种设计技术来更好地帮助人们学习测试驱动开发。这导致重命名测试行为，以更好地探索TDD在哪里帮助思考对象需要做什么。 BDD采取了一种模拟方法，但是在命名方式和将分析整合到其技术中的愿望上都对此进行了扩展。我在这里不做更多介绍，因为与本文唯一相关的是BDD是TDD的另一种变体，倾向于使用模拟测试。我将其留给您以点击链接以获取更多信息。</p><p> You sometimes see &#34;Detroit&#34; style used for &#34;classical&#34; and &#34;London&#34; for &#34;mockist&#34;. This alludes to the fact that XP was originally developed with the C3 project in Detroit and the mockist style was developed by early XP adopters in London. I should also mention that many mockist TDDers dislike that term, and indeed any terminology that implies a different style between classical and mockist testing. They don&#39;t consider that there is a useful distinction to be made between the two styles.</p><p> 有时您会看到＆＃34; Detroit＆＃34;用于＆＃34;古典＆＃34;的样式和＆＃34;伦敦＆＃34;为“模拟主义者”。这暗示了XP最初是由底特律的C3项目开发的，而模拟主义者的风格是由XP的早期采用者在伦敦开发的。我还应该提到，许多嘲笑TDD的人不喜欢该术语，甚至不喜欢暗示经典测试和嘲笑测试之间有不同风格的任何术语。他们认为这两种样式之间没有有用的区别。 </p><p> In this article I&#39;ve explained a pair of differences: stateor behavior verification / classic or mockist TDD. What are thearguments to bear in mind when making the choices between them? I&#39;llbegin with the state versus behavior verification choice.</p><p>在本文中，我解释了一对差异：状态或行为验证/经典或模拟主义者TDD。在它们之间进行选择时要牢记哪些参数？我首先介绍状态验证与行为验证的选择。</p><p> The first thing to consider is the context. Are we thinking			about an easy collaboration, such as order and warehouse, or an			awkward one, such as order and mail service?</p><p> 首先要考虑的是上下文。我们是在考虑轻松的协作（例如订单和仓库）还是尴尬的协作（例如订单和邮件服务）？</p><p> If it&#39;s an easy			collaboration then the choice is simple. If I&#39;m a classic TDDer			I don&#39;t use a mock, stub or any kind of double. I use a real			object and state verification. If I&#39;m a mockist TDDer I use a			mock and behavior verification. No decisions at all.</p><p> 如果协作容易，那么选择就很简单。如果我是经典的TDDer，则不要使用模拟，存根或任何双精度类型。我使用一个真实的对象和状态验证。如果我是模拟者TDDer，则可以使用模拟和行为验证。完全没有决定。</p><p> If it&#39;s an awkward collaboration, then there&#39;s no decision if			I&#39;m a mockist - I just use mocks and behavior verification. If			I&#39;m a classicist then I do have a choice, but it&#39;s not a big			deal which one to use. Usually classicists will decide on a case			by case basis, using the easiest route for each situation.</p><p> 如果协作很尴尬，那么我是否要当一个模拟主义者并没有决定-我只是使用模拟和行为验证。如果我是古典主义者，那么我确实可以选择，但是使用哪一个并不重要。通常，古典主义者会根据具体情况决定具体情况，使用每种情况的最简单方法。</p><p> So as we see, state versus behavior verification is mostly			not a big decision. The real issue is between classic and			mockist TDD. As it turns out the characteristics of state and		</p><p> 因此，正如我们所看到的，状态验证与行为验证在很大程度上并不是一个重大决定。真正的问题在经典与嘲讽TDD之间。事实证明，国家的特征和</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://martinfowler.com/articles/mocksArentStubs.html">https://martinfowler.com/articles/mocksArentStubs.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/存根/">#存根</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/aren/">#aren</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>