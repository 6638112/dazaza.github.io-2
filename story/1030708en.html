<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>通向十一和更远的地方</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">通向十一和更远的地方</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-23 12:04:53</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/57d9be383789483b2f59375ae402be78.png"><img src="http://img2.diglog.com/img/2020/10/57d9be383789483b2f59375ae402be78.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In 2018, we launched  Firefox Extension Workshop, a site for Firefox-specific extension development documentation. The site was originally built using the Ruby-based static site generator  Jekyll. We had initially selected Jekyll for this project because we wanted to make it easy for editors to update the site using Markdown, a lightweight markup language.</p><p>2018年，我们推出了Firefox扩展研讨会，这是一个提供特定于Firefox的扩展开发文档的网站。该站点最初是使用基于Ruby的静态站点生成器Jekyll构建的。我们最初为这个项目选择了Jekyll，因为我们想让编辑使用Markdown(一种轻量级标记语言)轻松地更新站点。</p><p> Once the site had been created and more documentation was added, the build times started to grow. Every time we made a change to the site and wanted to test it locally, it would take ten minutes or longer for the site to build. The builds took so long that we needed to increase the default time limit for  CircleCI, our continuous integration and continuous delivery service, because builds were failing when they ran past ten minutes with no output.</p><p>一旦创建了站点并添加了更多文档，构建时间就开始增长。每次我们对站点进行更改并希望在本地进行测试时，站点的构建都需要10分钟或更长时间。构建花费了如此长的时间，以至于我们需要增加CircleCI(我们的持续集成和持续交付服务)的默认时间限制，因为当它们运行超过10分钟而没有输出时，构建就会失败。</p><p> Investigating these slow builds using profiling showed that most of the time was being spent in the Liquid template rendering calls.</p><p>使用性能分析对这些速度较慢的构建进行调查后发现，大部分时间都花在液态模板呈现调用上。</p><p> In addition to problems with build times, there were also issues with cache-busting in local development. This meant that things like a change of images wouldn’t show up in the site without a full rebuild after clearing the local cache.</p><p>除了构建时间的问题外，本地开发中的缓存破坏也有问题。这意味着在清除本地缓存之后，如果没有完全重建，像图像更改这样的事情不会出现在站点中。</p><p> As we were discussing how to best move forward, Jekyll 4 was released with features expected to improve build performance.  However, an early test of porting to this version actually performed worse than the previous version. We then realized that we needed to find an alternative and port the site.</p><p>就在我们讨论如何更好地向前发展时，Jekyll4发布了一些有望提高构建性能的功能。然而，移植到此版本的早期测试实际上比以前的版本执行得更差。然后我们意识到，我们需要找到一个替代方案，然后把这个地点搬到港口。</p><p> Update: 05-10-2020: A Jekyll developer reached out having investigated the slow builds. The findings were that Jekyll on its own isn’t slow, the high build times in our case were primarily caused by 3rd party plugins.</p><p>更新时间：2020年5月10日：一位Jekyll开发人员调查了缓慢的构建过程。结果是Jekyll本身并不慢，在我们的例子中，高构建时间主要是由第三方插件造成的。</p><p>   Build performance needed to be better than the 10 minutes (600s+) it took to build locally.</p><p>构建性能需要高于本地构建所需的10分钟(600秒以上)。</p><p>  Ideally the solution would be JavaScript based, as the Add-ons Engineering team has a lot of collective JavaScript experience and a JavaScript based infrastructure would make it easier to extend.</p><p>理想情况下，解决方案应该是基于JavaScript的，因为Add-ons Engineering团队拥有丰富的JavaScript经验，基于JavaScript的基础设施将使其更容易扩展。</p><p> It needed to be flexible, enough to meet the demands of adding more documentation in the future.</p><p>它需要灵活，足以满足将来添加更多文档的需求。</p><p> Hugo (written in Go),  Gatsby (JS), and  Eleventy (11ty) (JS) were all considered as options.</p><p>雨果(用围棋写的)、盖茨比(JS)和十一(11TY)(JS)都被考虑为选项。</p><p> In the end, Eleventy was chosen for one main reason: it provided enough similarities to Jekyll that we could migrate the site without a major rewrite. In contrast, both Hugo and Gatsby would have required a significant refactoring.  Porting the site also meant less changes up front, which allowed us to focus on maintaining parity with the site already in production.</p><p>最后，选择11是因为一个主要原因：它与Jekyll有足够的相似之处，因此我们可以在不进行重大重写的情况下迁移该站点。相比之下，Hugo和Gatsby都需要进行重大的重构，移植网站也意味着较少的前期更改，这让我们能够专注于保持与已经投入生产的网站的平价。</p><p> As Eleventy provides an option to use liquid templates, via  LiquidJS, it meant that templates only needed relatively minimal changes to work.</p><p>由于Elevty通过LiquidJS提供了使用液态模板的选项，这意味着模板只需要进行相对最少的更改即可工作。</p><p>  There are four main building blocks in the Jekyll site:  Liquid templating, Markdown for documentation, Sass for CSS, and JQuery for behaviour.</p><p>Jekyll站点有四个主要的构建块：用于文档的液态模板、用于文档的Markdown、用于CSS的Sass和用于行为的JQuery。</p><p> To migrate to Eleventy we planned to minimize changes to how the site works, and focus on porting all of the existing documentation without changing the CSS or JavaScript.</p><p>为了迁移到11，我们计划最大限度地减少对站点工作方式的更改，并专注于移植所有现有文档，而无需更改CSS或JavaScript。</p><p>  The blog post  Turning Jekyll up to Eleventy by  Paul Lloyd was a great help in describing what would need to be done to get the site working under Eleventy.</p><p>Paul Lloyd撰写的博客文章Turning Jekyll up to 11很有帮助，它描述了需要做些什么才能让网站在11下运行。</p><p> The first step was to create the an Eleventy configuration file based on the old Jekyll one.</p><p>第一步是在旧的Jekyll配置文件的基础上创建11个配置文件。</p><p> Data files were moved from YAML to JSON. This was done via a  YAML to JSON conversion.</p><p>数据文件从YAML移动到JSON。这是通过YAML到JSON的转换完成的。</p><p> Next, the templates were updated to fix the differences in variables and the includes. The jekyll-assets plugin syntax was removed so that assets were directly served from the assets directory.</p><p>接下来，更新模板以修复变量和Include之间的差异。删除了Jekyll-Assets插件语法，以便直接从Assets目录提供资产。</p><p>  As a minimal fix to replace the Jekyll plugins for CSS and JS,  the CSS (Sass) and JS were built with Command Line Interface (CLI) scripts added to the package.json using Uglify and SASS.</p><p>作为替换CSS和JS的Jekyll插件的最小修复，CSS(Sass)和JS是使用Uglify和Sass使用添加到Package.json的命令行界面(CLI)脚本构建的。</p><p> For Sass, this required loading paths via the CLI and then just passing the main stylesheet:</p><p>对于Sass，这需要通过CLI加载路径，然后只传递主样式表：</p><p>   uglifyjs node_modules/jquery/dist/jquery.js node_modules/dompurify/dist/purify.js node_modules/velocity-animate/velocity.js node_modules/velocity-ui-pack/velocity.ui.js node_modules/slick-carousel/slick/slick.js _assets/js/tinypubsub.js _assets/js/breakpoints.js _assets/js/parallax.js _assets/js/parallaxFG.js _assets/js/inview.js _assets/js/youtubeplayer.js _assets/js/main.js -o _assets/js/bundle.js</p><p>Uglifyjs node_module/jQuery/dist/jquery.js node_module/dompurify/dist/purify.js node_module/ocity-Animate/velocity.js node_module/ocity-ui-pack/velocity.ui.js node_module/slick-carousel/slick/slick.js_sets/js/tinypubsub.js_sets/js/ruppoints.js_sets/js/parallax.js_sets/js/in.js_sets/js/youtubeplayer.js_sets/js/main.js-o_sets/js/bundle.js-o_sets/js/bundle.js/parallax.js_sets/js/in.js_sets/js/youtubeplayer.js_sets/js/main.js-o_sets/js/bundle.js。</p><p> This was clearly quite clunky, but it got JS and CSS working in development albeit in a way that required a script to be run manually. However, with the CSS and JS bundles working, this made it possible to focus on getting the homepage up and running without worrying about anything more complicated to start with.</p><p>这显然相当笨拙，但它让JS和CSS在开发中正常工作，尽管这种方式需要手动运行脚本。然而，随着CSS和JS捆绑包的工作，这使得人们可以专注于主页的启动和运行，而不必担心开始时会有更复杂的事情。</p><p>     With the homepage looking like it should, the next task was fixing the rest of the syntax. This was a pretty laborious process of updating all the templates and removing or replacing plugins and filters that Eleventy didn’t have.</p><p>主页看起来应该是正确的，接下来的任务是修复其余的语法。这是一个相当费力的过程，需要更新所有模板，删除或替换Elevty没有的插件和过滤器。</p><p> After some work fixing up the files, finally the entire site could be built without error! 🎉</p><p>在修复了一些文件之后，最终可以毫无错误地构建整个站点！🎉</p><p> What was immediately apparent was how fast Eleventy is. The entire site was built in under 3 seconds. That is not a typo; it is 3 seconds not minutes.</p><p>显而易见的是，“十一”的速度有多快。整个网站在不到3秒的时间内建成。那不是打字错误，是3秒，不是分钟。</p><p>   Building JS and CSS is not part of Eleventy itself. This means it’s up to you to decide how you want to handle statics.</p><p>构建JS和CSS不是Elevty本身的一部分。这意味着您可以决定如何处理静态。</p><p>   The first approach moved the CSS and JS to node scripts. These replicated the crude CLI scripts using APIs.</p><p>第一种方法将CSS和JS移到节点脚本。它们使用API复制原始的CLI脚本。</p><p> Ultimately we decided to decouple asset building from Eleventy entirely. This meant that Eleventy could worry about building the content, and a separate process would handle the static assets. It also meant that the static asset scripts could write out to the build folder directly.</p><p>最终，我们决定将资产建设与Elevty完全脱钩。这意味着Elevty可以担心内容的构建，而另一个单独的进程将处理静态资产。这还意味着静态资产脚本可以直接写出到Build文件夹。</p><p> This made it possible to have the static assets built in parallel with the Eleventy build. The downside was that Eleventy couldn’t tell the browserSync instance (the server Eleventy uses in development) to update as it wasn’t involved with this process. It also meant that watching JS and SASS source files needed to be handled with a separate watching configuration, which in this case was handled via  chokidar-cli. Here’s the command used in the package.json script for the CSS build:</p><p>这使得静态资产可以与Eleviti构建并行构建。缺点是，Eleviti无法通知BrowserSync实例(Eleviti在开发中使用的服务器)进行更新，因为它不参与此过程。这还意味着需要使用单独的监视配置来处理监视JS和SASS源文件，在本例中，该配置是通过Chokidar-cli处理的。以下是CSS构建的Package.json脚本中使用的命令：</p><p>    With the JS and CSS being built correctly, we needed to update the browserSync instance to tell it that the JS and CSS had changed. This way, when you make a CSS change the page will reload without a refresh. Fast updates provide the ideal short feedback loop for iterative changes.</p><p>正确构建JS和CSS后，我们需要更新BrowserSync实例以告诉它JS和CSS已经更改。这样，当您更改CSS时，页面将在不刷新的情况下重新加载。快速更新为迭代更改提供了理想的短反馈循环。</p><p> Fortunately, browserSync has a web API. We were able to use this to tell browserSync to update every time the CSS or JS build is built in development.</p><p>幸运的是，BrowserSync有一个Web API。我们可以使用它来告诉BrowserSync在每次开发中构建CSS或JS版本时进行更新。</p><p>    Next, we needed to clean up everything and make sure the site looked right. Missing plugin functionality needed to be replaced and docs and templates needed several adjustments.</p><p>接下来，我们需要清理所有东西，并确保站点看起来是正确的。缺少的插件功能需要替换，文档和模板需要几次调整。</p><p>  Use the 11ty “edit this page on github” recipe. (A great feature for making it easier to accept contributions to document improvements).</p><p>使用第11条“在GitHub上编辑此页面”食谱。(这是一个很好的特性，可以让您更容易接受对文档改进的贡献)。</p><p> Clean-up templates to fix some errant markup. This was mainly about looking at whitespace control in liquid as in some cases there were some bad interactions with the markdown which resulted in spurious extra elements.</p><p>清理模板以修复一些错误的标记。这主要是关于液体中的空格控制，因为在某些情况下，与标记之间存在一些不良交互，从而导致虚假的额外元素。</p><p> Recreate the pages API plugin. Under Jekyll this was used by the search, so we needed to recreate this for parity in order to avoid re-implementing the search from scratch.</p><p>重新创建页面API插件。在Jekyll下，搜索使用此选项，因此我们需要重新创建此选项以实现奇偶校验，以避免从头开始重新实现搜索。</p><p> Build tag pages instead of using the search. This was also done for SEO benefits.</p><p>构建标记页面，而不是使用搜索。这也是为了搜索引擎优化的好处。</p><p>  With the site looking like it should and a lot of the minor issues tidied up, one of the final steps was to look at how to handle building the static assets for production.</p><p>站点看起来应该是这样的，并且整理了许多小问题，最后一步是看一下如何处理为生产而构建的静态资产。</p><p> For optimal performance, static assets should not need to be fetched by the browser if that asset (JS, CSS, Image, fonts etc) is in the browser’s cache. To do that you can serve assets with expires headers set into the future (typically one year). This means that if foo.js is cached, when asked to fetch it, the browser won’t re-fetch it unless the cache is removed or the cached asset is older than the expiration date set via the expires header in the original response.</p><p>为了获得最佳性能，如果静态资源(JS、CSS、图像、字体等)在浏览器的缓存中，则不需要由浏览器获取该资源。为此，您可以使用设置为将来(通常为一年)的Expires标头为资产提供服务。这意味着如果foo.js被缓存，当请求获取它时，浏览器不会重新获取它，除非移除缓存或者缓存的资产比通过原始响应中的Expires头设置的过期日期更早。</p><p> Once you’re caching assets in this way, the URL of the resource needs to be changed to “bust the cache”, otherwise the browser won’t make a request if the cached asset is considered “fresh.”</p><p>以这种方式缓存资产后，需要将资源的URL更改为“破坏缓存”，否则，如果缓存的资产被认为是“新鲜的”，浏览器将不会发出请求。</p><p>    The git revision of the entire site can be used as part of the URL. This means that every time a revision is added and the site is published, every asset would be considered fresh. The downside is that this will cause clients to download every asset even if it hasn’t actually been updated since the last time the site was published.</p><p>整个站点的GIT版本可以用作URL的一部分。这意味着每次添加修订并发布站点时，每一项资产都将被认为是新鲜的。缺点是，这将导致客户端下载每一项资产，即使这些资产自上次网站发布以来实际上没有更新过。</p><p>  With this approach, a query string is appended to a URL with either a hash of the contents or some other unique string e.g:</p><p>使用此方法时，查询字符串将使用内容的散列或其他一些唯一字符串附加到URL中，例如：</p><p>   A downside of this approach is that in some cases caching proxies won’t consider the query string. This could result in stale assets being served. Despite this, this approach is pretty common and caching proxies don’t typically default to ignoring query params.</p><p>这种方法的一个缺点是，在某些情况下，缓存代理不会考虑查询字符串。这可能会导致陈旧的资产被提供服务。尽管如此，这种方法还是很常见的，缓存代理通常不会默认忽略查询参数。</p><p>  In this scenario, you change your asset references to point to files with a hash as part of the URL. The server is configured to rewrite those resources internally to ignore the hash.</p><p>在此方案中，您将更改资源引用以指向带有散列的文件，该文件是URL的一部分。服务器被配置为在内部重写这些资源以忽略散列。</p><p> For example if your HTML refers to foo.4ab8sbc7.css the server will serve foo.css. This means you don’t need to update the actual filename of foo.css to foo.4ab8sbc7.css.</p><p>例如，如果您的HTML引用foo.4ab8sbc7.css，则服务器将提供foo.css。这意味着您不需要将foo.css的实际文件名更新为foo.4ab8sbc7.css。</p><p>   In this approach, once you know the hash of your content, you need to update the references to that file, and then you can output the file with that hash as part of the filename.</p><p>在这种方法中，一旦知道了内容的散列，就需要更新对该文件的引用，然后可以使用该散列作为文件名的一部分输出文件。</p><p> The upside of this approach is that once the static site is built this way it can be served anywhere and you don’t need any additional server config as per the previous example.</p><p>这种方法的好处是，一旦以这种方式构建了静态站点，它就可以在任何地方提供服务，并且您不需要任何额外的服务器配置(如前面的示例所示)。</p><p>   Eleventy doesn’t have an asset pipeline, though this is something that is being considered for the future.</p><p>11家公司没有资产管道，尽管这是未来正在考虑的事情。</p><p> In order to deploy the Eleventy port, cache-busting would be needed so we could continue to deploy to S3 with far future expires headers.</p><p>为了部署11个端口，将需要缓存破坏，这样我们就可以继续部署到S3，并使用遥远的Expires标头。</p><p> With the Jekyll assets plugin, you used liquid templating to control the assets building. Ideally, I wanted to avoid content authors needing to know about cache-busting at all.</p><p>使用Jekyll资源插件，您可以使用流动模板来控制资源构建。理想情况下，我希望避免内容作者需要了解缓存破坏。</p><p> To make this work, all asset references would need to start with “/assets/” and could not be built with variables. Given the simplicity of the site, this was a reasonable limitation.</p><p>要实现这一点，所有资产引用都需要以“/Assets/”开头，并且不能用变量构建。考虑到站点的简单性，这是一个合理的限制。</p><p>   The first attempt used Webpack.  We almost got it working using  eleventy-webpack-boilerplate as a guide, however this started to introduce differences in the webpack configs for dev and production since it essentially used the built HTML as an entry point. This was because cache-busting and optimizations were not to be part of the dev process to keep the locale development build as fast as possible. Getting this working became more and more complex, requiring special patched forks of loaders because of limitations in the way HTML extraction worked.</p><p>第一次尝试使用了webpack。“我们几乎使用了11-webpack模板作为指导来让它工作，然而，这开始在webpack的开发和生产配置中引入不同之处，因为它本质上是使用构建的Html作为入口点。这是因为缓存破坏和优化不是开发过程的一部分，以尽可能快地保持区域开发构建。使其工作变得越来越复杂，由于HTML提取工作方式的限制，需要特殊的打补丁的加载器分叉。</p><p> Webpack also didn’t work well for this project because of the way it expects to understand relationships in JS modules in order to build a bundle. The JS for this site was written in an older style where the scripts are concatenated together in a specific order without any special consideration for dependencies (other than script order). This alone required a lot of workarounds to work in Webpack.</p><p>Webpack在这个项目中也没有很好地工作，因为它希望理解JS模块中的关系，以便构建一个捆绑包。此站点的JS是以较旧的样式编写的，其中脚本以特定的顺序连接在一起，而没有对依赖项(脚本顺序除外)进行任何特殊考虑。仅此一项就需要在webpack中进行大量的变通工作。</p><p>   AssetGraph is an extensible,   node.js -based framework for manipulating and optimizing web pages and web applications. The main core is a dependency graph model of your entire website, where all assets are treated as first class citizens. It can automatically discover assets based on your declarative code, reducing the configuration needs to a minimum.</p><p>AssetGraph是一个可扩展的、基于node.js的框架，用于操作和优化网页和Web应用程序。主要核心是整个网站的依赖图模型，其中所有资产都被视为一等公民。它可以根据您的声明性代码自动发现资产，从而将配置需求降至最低。</p><p> The main concept is that the relationship between HTML documents and other resources is essentially a graph problem.</p><p>主要概念是HTML文档和其他资源之间的关系本质上是一个图问题。</p><p> AssetGraph-builder uses AssetGraph, and using your HTML as a starting point it works out all the relationships and optimizes all of your assets along the way.</p><p>AssetGraph-Builder使用AssetGraph，并以您的HTML为起点，计算出所有的关系，并在此过程中优化您的所有资产。</p><p> This sounded ideal. However when I ran it on the built content of the site, node ran out of memory. With no control over what it was doing and minimal feedback as to where it was stuck, this attempt was shelved.</p><p>这听起来很理想。但是，当我在站点的构建内容上运行它时，节点耗尽了内存。由于无法控制它在做什么，对它卡在哪里的反馈也很少，这一尝试被搁置了。</p><p> That said, the overall goals of the AssetGraph project are really good, and this looks like it’s something worth keeping an eye on for the future.</p><p>这就是说，AssetGraph项目的总体目标真的很好，这看起来是未来值得关注的事情。</p><p>  In the end, the solution that ended up working best was to build a script that would process the assets   after the site build was completed by Eleventy.</p><p>最后，最终效果最好的解决方案是构建一个脚本，该脚本将在Elevty完成站点构建之后处理资产。</p><p>  Process the CSS, and rewrite references to resources within them, minify the CSS, and record a content hash for them.</p><p>处理CSS，重写对其中资源的引用，缩小CSS，并记录它们的内容散列。</p><p> Process the JS, and rewrite references to resources within them, minify the JS, and record a content hash for them.</p><p>处理JS，重写对其中资源的引用，缩小JS，并记录它们的内容散列。</p><p> Note: there might be some edge cases not covered here. For example, if a JS file references another JS file,  this could break depending on the order of processing. The script could be updated to handle this, but that would mean files would need to be re-processed as changed and anything that referenced them would also need to be updated and so on. Since this isn’t a concern for the current site, this was left out for simplicity. There’s also no circular dependency detection. Again, for this site and most other basic sites this won’t be a concern.</p><p>注：这里可能没有介绍一些边缘情况。例如，如果一个JS文件引用了另一个JS文件，则根据处理顺序，这可能会中断。可以更新脚本以处理此问题，但这意味着需要将文件重新处理为更改过的文件，并且引用它们的任何内容也需要更新，依此类推。由于这不是当前站点的问题，为了简单起见，省略了这一点。也没有循环依赖检测。同样，对于这个站点和大多数其他基础站点来说，这不会是一个问题。</p><p> There’s a reason optimizations and cache-busting aren’t part of the development build. This separation helps to ensure the site continues to build really fast when making changes locally.</p><p>优化和缓存破坏不是开发构建的一部分，这是有原因的。这种分离有助于确保站点在本地进行更改时继续以非常快的速度构建。</p><p> This is a trade-off, but as long as you check the production build before you release it’s a reasonable compromise. In our case, we have a development site built from master, a staging site built from tags with a -stage suffix, and the production site. All of these deployments run the production deployment processes so there’s plenty of opportunity for catching issues with full builds.</p><p>这是一种权衡，但是只要您在发布之前检查生产版本，这就是一个合理的折衷方案。在我们的示例中，我们有一个从主站点构建的开发站点、一个由带有-Stage后缀的标记构建的临时站点和生产站点。所有这些部署都运行生产部署流程，因此有很多机会捕获完整构建的问题。</p><p>  Porting to Eleventy has been a positive change. It certainly took quite a lot of steps to get there, but it was worth the effort.</p><p>迁移到11号是一个积极的变化。当然，要做到这一点需要相当多的步骤，但付出的努力是值得的。</p><p> In the past, long build times with Jekyll made this site really painful for contributors and document authors to work with. We’re already starting to see some additional contributions as a result of lowering the barrier of entry.</p><p>过去，使用Jekyll需要很长的构建时间，这使得这个站点对于贡献者和文档作者来说非常痛苦。由于降低了准入门槛，我们已经开始看到一些额外的贡献。</p><p> With this port complete, it’s now starting to become clear what the next steps should be to minimize the boilerplate for document authors and make the site even easier to use and contribute to.</p><p>这个移植完成后，下一步应该做什么就开始变得清晰起来，以便最大限度地减少文档作者的样板，并使站点更易于使用和贡献。</p><p> If you have a site running under Jekyll or are considering using a modern static site generator, then taking a look at Eleventy is highly recommended. It’s fast, flexible, well documented, and a joy to work with. ✨</p><p>如果您有一个在Jekyll下运行的站点，或者正在考虑使用现代的静态站点生成器，那么强烈推荐您看一下11。它快速、灵活、文档齐全，使用起来非常愉快。✨</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hacks.mozilla.org/2020/10/to-eleventy-and-beyond/">https://hacks.mozilla.org/2020/10/to-eleventy-and-beyond/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/通向/">#通向</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/eleventy/">#eleventy</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>