<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>借助PRPL加快Web应用交付速度</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">借助PRPL加快Web应用交付速度</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-19 07:53:22</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/2b9279d1c8701ea2ff2035a72d27da90.jpg"><img src="http://img2.diglog.com/img/2020/10/2b9279d1c8701ea2ff2035a72d27da90.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>PRPL is a pattern for structuring and serving web applications and  Progressive Web Apps (PWAs) with an emphasis on improved app delivery and launch performance. The letters describe a set of ordered steps for fast, reliable, efficient loading:</p><p>PRPL是一种构建和服务Web应用程序和渐进式Web应用程序(PWA)的模式，强调改进应用程序交付和启动性能。这些信件描述了一套有序的步骤，以实现快速、可靠、高效的装载：</p><p> Push all resources required for the initial route –  and only those resources – to ensure that they are available as early as possible</p><p>推送初始路径所需的所有资源(包括并且仅推送这些资源)，以确保它们尽早可用。</p><p>  Pre-cache resources for additional routes that the user is likely to visit, maximizing responsiveness to subsequent requests and resilience under poor network conditions</p><p>为用户可能访问的其他路由预缓存资源，最大限度地提高对后续请求的响应能力和在网络条件较差时的恢复能力。</p><p> Lazy-load routes on demand as the user requests them; resources for key routes should load instantly from the cache, whereas less commonly used resources can be fetched from the network upon request</p><p>根据用户请求按需延迟加载路由；关键路由的资源应立即从缓存加载，而不常用的资源可根据请求从网络获取。</p><p> Note:  The PRPL pattern was first introduced by the Polymer team in  2016, but has demonstrated itself applicable to many other stacks.</p><p>注意：PRPL模式是由聚合物团队在2016年首次引入的，但已经证明自己适用于许多其他堆栈。</p><p>  The server and  Service Worker together work to precache the resources for the inactive routes. When the user switches routes, the app lazy-loads any required resources that haven&#39;t been cached yet, and creates the required views.</p><p>服务器和服务工作者共同为非活动路由预缓存资源。当用户切换路线时，应用程序会延迟加载任何尚未缓存的所需资源，并创建所需的视图。</p><p> Twitter.com has used the PRPL pattern in production since  2017. Below we can see their use use of granular code-splitting for critical scripts and  &lt;link rel=preload&gt; to push them so that they are available as early as possible:</p><p>Twitter.com自2017年以来一直在生产中使用PRPL模式。下面，我们可以看到他们对关键脚本使用粒度代码拆分，并使用&lt；link rel=preload&gt；来推送它们，以便它们尽早可用：</p><p>  Additional routes are lazy-loaded on demand, with Twitter serving 40+ chunks on-demand throughout the user-experience. Twitter also (offline) precaches assets for additional routes using Service Workers, to improve responsiveness to subsequent navigations:</p><p>额外的航线是按需懒惰加载的，Twitter在整个用户体验中按需提供40多个区块。Twitter还(离线)使用服务工作者(Service Worker)为资产预留额外的路线，以提高对后续导航的响应能力：</p><p>  Their application shell (skeleton UI) is also offline cached, instantly loading even when users load the site on a slow or spotty network connection:</p><p>他们的应用程序外壳(骨架UI)也是离线缓存的，即使用户在缓慢或参差不齐的网络连接上加载站点，也会立即加载：</p><p>   Apps built using PRPL strive to be reliable, fast and engaging. Beyond these basic goals, PRPL aims to:</p><p>使用PRPL构建的应用程序力求可靠、快速和引人入胜。除了这些基本目标之外，PRPL的目标是：</p><p> Improve an app&#39;s interaction readiness. It does this by ensuring that no extraneous resources are sent to the browser before the first view renders and becomes interactive.</p><p>提高应用程序的交互就绪性。它通过确保在第一个视图呈现和交互之前不会将无关资源发送到浏览器来实现这一点。</p><p> Increase an app’s caching efficiency, especially over time. It does this by sending resources to the browser at high granularity. When resources are unbundled or bundled less aggressively, each change to your code invalidates less of your cache.</p><p>提高应用程序的缓存效率，特别是随着时间的推移。它通过以高粒度将资源发送到浏览器来实现这一点。当资源拆分或绑定不那么积极时，对代码的每一次更改都会减少缓存的无效部分。</p><p> Reduce the complexity of development and deployment. It does this by relying on the app’s implicit dependency graph to map each entry point to the precise set of resources required, reducing or eliminating the need for manual management of bundling and delivery.</p><p>降低开发和部署的复杂性。它依靠应用程序的隐式依赖图将每个入口点映射到所需的精确资源集，从而减少或消除了手动管理捆绑和交付的需要。</p><p> This is a useful mindset because today’s typical app is far heavier than it needs to be. To help deliver better experiences on the mobile web, we need to start by making apps lighter overall. This implies understanding and carefully considering the weight of everything we include – both our own code and our dependencies.</p><p>这是一种有用的心态，因为今天的典型应用程序比它需要的要重得多。为了帮助在移动网络上提供更好的体验，我们需要从整体上让应用程序变得更轻。这意味着理解并仔细考虑我们包含的所有内容的权重-包括我们自己的代码和我们的依赖项。</p><p> But that’s not enough. We’re also delivering our apps in an inefficient fashion, typically serving an all-in-one bundle containing an app’s full set of resources. This bundle must be received and processed on the client in its entirety before the user can do anything. Going forward, we need to structure and serve our apps such that:</p><p>但这还不够。我们也在以一种低效的方式交付我们的应用程序，通常是提供包含应用程序全套资源的一体化捆绑包。在用户可以执行任何操作之前，必须在客户机上完整地接收和处理此捆绑包。展望未来，我们需要构建和服务我们的应用程序，以便：</p><p> Upon a user’s initial request, we deliver and process only those resources necessary to support the requested route, ensuring that our app is interactive as quickly as possible</p><p>根据用户的初始请求，我们只交付和处理支持所请求路径所需的资源，以确保我们的应用程序能够以最快的速度进行交互</p><p> Once interactive, we begin opportunistically delivering the additional resources required to ensure that our app is instantly responsive to follow-on user requests.</p><p>一旦互动，我们就开始机会主义地交付所需的额外资源，以确保我们的应用程序能够立即响应后续用户请求。</p><p> Future updates to our app are maximally efficient, consuming as little bandwidth and time as possible</p><p>我们应用程序的未来更新效率最高，消耗的带宽和时间尽可能少。</p><p>  PRPL is a conceptual pattern that might be implemented in various ways, but it is most easily and effectively realized by utilizing some combination of the following modern web features:</p><p>PRPL是一个概念性模式，可以通过各种方式实现，但通过利用以下现代Web功能的某种组合可以最容易、最有效地实现它：</p><p> A modern module system like  JavaScript Modules, so that tools can easily construct a complete dependency graph</p><p>像JavaScript Modules这样的现代模块系统，这样工具就可以很容易地构建完整的依赖图。</p><p>  Preload, for delivering required resources as quickly as possible. You can also leverage  preload link headers which can be intercepted by cooperating servers and upgraded into  HTTP/2 Server Push responses. It’s important to keep in mind that while powerful, Push has known  challenges, however PRPL&#39;s use of Service Worker&#39;s can side-step the over-pushing problem (only push for the initial load).</p><p>预加载，以便尽快交付所需的资源。您还可以利用预加载链接标头，这些标头可以被协作的服务器截获并升级为HTTP/2服务器推送响应。重要的是要记住，虽然功能强大，推送有已知的挑战，但是PRPL##39；使用服务工作者可以避开过度推送的问题(只推送初始加载)。</p><p>  A big part of PRPL is turning the JS bundling mindset upside down and delivering resources as close to the granularity in which they are authored as possible (at least in terms of functionally independent modules). How do you achieve granularity?</p><p>PRPL的很大一部分是颠覆JS捆绑的思维模式，交付尽可能接近创作粒度的资源(至少在功能独立的模块方面)。您如何实现粒度？</p><p>  You&#39;re already writing things as components. Maybe you&#39;re using ES modules. For Webpack, we use  dynamic import and code-splitting to split your codebase into chunks that are loaded on demand.</p><p>你已经在把东西写成组件了。也许您正在使用ES模块。对于webpack，我们使用动态导入和代码拆分将您的代码库拆分成按需加载的块。</p><p> Meta-frameworks such as  Next.js and  Nuxt.js implement route-based code-splitting by default. If you are using a tooling boilerplate like  create-react-app you would rely on dynamic import with a router like  React Router to add route-based or component-based code-splitting to your application.</p><p>Next.js和Nuxt.js等元框架默认实现基于路由的代码拆分。如果您使用的是诸如create-action-app之类的工具样板，那么您将依赖于使用诸如Reaction Router之类的路由器的动态导入来向您的应用程序添加基于路由或基于组件的代码拆分。</p><p> For the push/preload portion of PRPL, Webpack also supports  preload as a magic comment for preloading critical scripts.</p><p>对于PRPL的Push/Preload部分，webpack还支持将Preload作为预加载关键脚本的神奇注释。</p><p>  Pre-caching your remaining routes can be achieved using service workers. It’s not uncommon to leverage a service worker library such as  Workbox to simplify the process of  precaching routes and chunks for your application.</p><p>预缓存剩余的路由可以使用服务人员来实现。利用诸如WORKBOX之类的服务工作者库来简化为应用程序预缓存路由和块的过程并不少见。</p><p>   The main entrypoint of the application which is served from every valid route. This file should be very small, since it will be served from different URLs therefore be cached multiple times. All resource URLs in the entrypoint need to be absolute, since it may be served from non-top-level URLs.</p><p>应用程序的主要入口点，从每条有效路由提供服务。此文件应该非常小，因为它将从不同的URL提供服务，因此会被多次缓存。入口点中的所有资源URL都需要是绝对的，因为它可能来自非顶级URL。</p><p>  Lazily loaded fragments of the app.  A fragment can represent the code for a particular view, or other code that can be loaded lazily (for example, parts of the main app not required for first paint, like menus that aren&#39;t displayed until a user interacts with the app). The shell is responsible for dynamically importing the fragments as needed.</p><p>应用程序的延迟加载片段。片段可以表示特定视图的代码，也可以表示可以延迟加载的其他代码(例如，第一次绘制时不需要的主应用程序部分，比如直到用户与应用程序交互后才会显示的菜单)。外壳负责根据需要动态导入片段。</p><p>  The app should call dynamic import to lazy-load fragments as they&#39;re required. For example, when the user changes to a new route, it imports the fragment(s) associated with that route. This may initiate a new request to the server, or simply load the resource from the cache.</p><p>应用程序应该调用动态导入来延迟加载片段，因为它们是需要的。例如，当用户更改到新路由时，它会导入与该路由相关联的片段。这可以向服务器发起新的请求，或者简单地从高速缓存加载资源。</p><p>    PRPL is a pattern that has been used at scale since its introduction in 2016 and continues to be a worthwhile approach to loading worth considering for your app.</p><p>PRPL是一种自2016年引入以来一直在大规模使用的模式，并且仍然是一种值得考虑为您的应用程序加载的值得考虑的方法。</p><p>   Credit to Gray Norton, Kevin Schaaf, Alex Russell and many others for their contributions to PRPL and PRPL guidance over time. With special thanks to Twitter.com for their approvals to use the screenshots in this post.</p><p>归功于格雷·诺顿、凯文·沙夫、亚历克斯·罗素和其他许多人，他们多年来对PRPL和PRPL指导做出了贡献。特别感谢Twitter.com批准在这篇文章中使用截图。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://addyosmani.com/blog/the-prpl-pattern/">https://addyosmani.com/blog/the-prpl-pattern/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/prpl/">#prpl</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/应用程序/">#应用程序</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>