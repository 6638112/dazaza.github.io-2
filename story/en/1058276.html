<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>webassembly magic photical performs pixie dust？ Is WebAssembly magic performance pixie dust?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Is WebAssembly magic performance pixie dust?<br/>webassembly magic photical performs pixie dust？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-14 14:23:15</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/35f19104e7b4d833b41c2a5cf8744daa.png"><img src="http://img2.diglog.com/img/2021/4/35f19104e7b4d833b41c2a5cf8744daa.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The incredibly unsatisfying answer is: It depends. It depends on oh-so-many factors, and I’ll be touching on  some of them here.</p><p>令人难以置信的不满意的答案是：它取决于。这取决于哦 - 如此多的因素，我将在这里抚摸其中一些。</p><p>    I really like  AssemblyScript (full disclosure: I am one of their backers). It’s a very young language with a small but passionate team that built a custom compiler for a TypeScript-like language targeting WebAssembly. The reason I like AssemblyScript (or ASC for short) is because it allows the average web developer to make use of WebAssembly without having to learn a potentially new language like C++ or Rust. It’s important to note that the language is TypeScript- like. Don’t expect your existing TypeScript code to just compile out of the box. That being said, the language is intentionally mirroring the behaviors and semantics of TypeScript (and therefore JavaScript), which means that the act of “porting” TypeScript to AssemblyScript are often mostly cosmetic, usually just adding type annotations.</p><p>    我真的很喜欢大会（完整披露：我是他们的支持者之一）。这是一种非常年轻的语言，具有一个小但激情的团队，为目标网址定位的类型语言构建了自定义编译器。我喜欢的原因是assemblyscript（或shart for shart）是因为它允许平均web开发人员使用webassembly，而无需学习潜在的新语言，如C ++或Rust。值得注意的是，语言是拼写的。不要指望您现有的打字代码只能在框中编译。已经说，语言是有意镜像类型签字的行为和语义（以及因此JavaScript），这意味着“将”打字标注字样的动作通常主要是添加类型的注释。</p><p>  I always wondered if there is anything to gain from taking a piece of JavaScript, turning it into AssemblyScript and compiling it to WebAssembly. When my colleague  Ingvar sent me a  piece of JavaScript code to blur images, I thought that this would be a perfect case study. I ran a quick experiment to see if it’s worth doing a deeper exploration into porting JavaScript to AssemblyScript. And  oh boy was it worth it. This article is that deeper exploration.</p><p>  我总是想知道是否有什么可以获得一块javascript的东西，将它转化为组装并将其编译为webassembly。当我的同事ingvar向我发了一块javascript代码来模糊图像，我认为这将是一个完美的案例研究。我跑了一个快速的实验，看看它是否值得深入探索将JavaScript移植到组装。哦，男孩是值得的。本文是更深入的探索。</p><p>  If you want to know more about AssemblyScript, go to the  website, join the  Discord or, if you fancy, watch the  AssemblyScript intro video I made with my podcast husband  Jake.</p><p>  如果您想了解更多关于AssemblyScript的信息，请访问网站，加入Discord，或者如果您喜欢，请观看我用播客丈夫Jake制作的大会介绍视频。</p><p>    I think it is fair to say that most mature use-case for WebAssembly is tapping into the ecosystem of other languages. In  Squoosh, for example, we use libraries from the C/C++ and Rust ecosystem to process images. These libraries were not written with the web in mind, but through WebAssembly, they can run there anyway.</p><p>    我认为这是公平的，可以说是Webassembly的最成熟用例正在进入其他语言的生态系统。例如，在SquoSh中，我们使用C / C ++和Rust Ecosystem的库来处理图像。这些库没有用网页写入，而是通过Webassembly，他们可以在那里运行。</p><p>  WebAssembly, in my perception, is also strongly associated with performance by a lot of people. It was designed to be fast, and it’s compiled, so it’s gotta be fast, right? Well, for the longest time  I have been vocal that WebAssembly and JavaScript have the same  peak performance, and I still stand behind that. Given ideal conditions, they both compile to machine code and end up being equally fast. But there’s obviously more nuance here, and when have conditions  ever been ideal on the web‽ Instead, I think it would be better if we thought about WebAssembly as a way to get more reliable performance.</p><p>  在我的看法中，WebAssembly也与很多人的表现强烈相关。它旨在快速，它编译，所以它必须快速，对吧？好吧，在最长的时间，我一直被网址和javascript具有相同的峰值性能，而且我仍然落后于此。考虑到理想条件，它们都编译为机器代码，并最终同样快速。但是，这里显然有更多细微差别，当有条件在网页上是理想的，我认为如果我们认为WebAsseMbly是一种获得更可靠的性能的方法会更好。</p><p>  However, it’s also important to realize that WebAssembly has recently been getting access to performance primitives (like SIMD or shared-memory threads) that JavaScript cannot utilize, giving WebAssembly an increased chance to out-perform JavaScript. There are also some other qualities of WebAssembly that might make it better suited in specific situations than JavaScript:</p><p>  但是，实现WebasseMbly最近一直访问JavaScript无法使用的性能原语（如SIMD或共享内存线程）也很重要，这使得Webassembly增加了外出JavaScript的机会。还有一些其他Qualassembly的品质可能使其更适合特定情况，而不是JavaScript： </p><p>    For V8 to execute JavaScript, it first gives the code to the interpreter “Ignition”. Ignition is optimized to make code run as  soon as possible. Afterwards, “Sparkplug” takes Ignition’s output (the infamous “bytecode”) and turns it into non-optimized machine code, yielding better performance at the cost of increased memory footprint. While your code is executing, it is closely observed by V8 to gather data on object shapes (think of them like types). Once sufficient data has been collected, V8’s optimizing compiler “TurboFan” kicks in and generates low-level machine code that is optimized for those types. This will give another significant speed boost.</p><p>对于v8来执行javascript，它首先将代码提供给解释器“点火”。点火进行了优化，可以尽快运行代码。之后，“SparkPlug”采用点火输出（臭名昭着的“字节码”）并将其转换为非优化的机器代码，以提高内存占用的成本产生更好的性能。虽然代码正在执行，但v8密切关注它以收集对象形状的数据（请将其视为类型）。一旦收集了足够的数据，V8的优化编译器“TurboOman”启动并生成了为这些类型进行优化的低级机器代码。这将提供另一种显着的速度增强。</p><p>  It’s tradeoffs all the way down: If you want to learn more about the exact tradeoffs JavaScripts engines have to make, I can recommend this  article by  Benedikt and  Mathias.</p><p>  这一切都在下降：如果你想了解更多关于精确权衡的信息，我可以通过Benedikt和Mathias推荐这篇文章。</p><p>  WebAssembly, on the other hand, is strongly typed. It can be turned into machine code  straight away. V8 has a streaming Wasm compiler called “Liftoff“ which, like Ignition, is geared to get your code running  quickly, at the cost of generating potentially suboptimal execution speed. The second Liftoff is done, TurboFan kicks in and generates optimized machine code that will run faster than what Liftoff produced, but will take longer to generate. The big difference to JavaScript is that TurboFan can do its work without having to observe your Wasm first.</p><p>  另一方面，WebAsseMbly是强烈打字的。它可以直接转向机器代码。 V8有一个名为“升降机”的流媒体编译器，它像点火一样，用于使您的代码快速运行，以产生潜在的次优执行速度。第二个升降机进行了完成，TurboOman踢出并生成优化的机器代码，它将比产生的升降机更快地运行，但会更长时间才能生成。与JavaScript的大区别是Turboofan可以在不必先观察您的母鹿的情况下进行工作。</p><p>    The machine code that TurboFan generates for JavaScript is only usable for as long as the assumptions about types hold. If TurboFan generated machine code for a function  f with a number as a parameter, and now all of a sudden that function  f gets called with an object, the engine has to fall back to Ignition or Sparkplug. That’s called a “deoptimization” (or “deopt” for short). Again, because WebAssembly is strongly typed, the types  can’t change. Not only that, but the types that WebAssembly supports are designed to map well to machine code. Deopts can’t happen with WebAssembly.</p><p>    TurboOman为JavaScript生成的机器代码仅适用于Types Hold的假设。如果TurboOman为函数f生成的机器代码f具有一个数字作为参数，并且现在突然函数f称为对象调用，发动机必须倒回点火或火花。这被称为“去优化”（或“缩短”）。同样，因为WebAsseMbly强烈键入，所以类型无法改变。不仅如此，而是旨在将Webassembly支持的类型旨在映射到机器代码。 Webassembly无法发生。</p><p>    Now this one is a bit elusive. According to  webassembly.org, “the wasm stack machine is designed to be encoded in a size- and load-time-efficient binary format.” And yet, WebAssembly is currently somewhat notorious for generating big binary blobs, at least by what is considered “big” on the web. WebAssembly compresses very well (via gzip or brotli), which can undo a lot of the bloat.</p><p>    现在这个有点难以捉摸。根据WebAsseMbly.org，“WASM堆栈机器设计用于以尺寸和负载节省的二进制格式编码。”然而，webassembly目前对于生成大二元斑点时，至少是在网上被认为是“大”的臭名昭着的。 Webassembly压缩非常好（通过gzip或brotli），可以撤消很多膨胀。</p><p>  It is easy to forget that JavaScript comes with a lot of batteries included (despite the claim that it doesn’t have a standard library). For example: You can handle arrays, objects, iterate over keys and values, split strings, filter, map, have prototypical inheritance and so on and so forth. All that is built into the JavaScript engine. WebAssembly comes with  nothing, except arithmetic. Whenever you use any of these higher-level concepts in a language that compiles to WebAssembly, the underpinning code will have to get bundled into your binary, which is one of the causes for big WebAssembly binaries. Of course those functions will only have to be included once, so bigger projects will benefit more from Wasm’s small binary representation than small modules.</p><p>  很容易忘记JavaScript附带大量电池（尽管它没有标准库）。例如：您可以处理数组，对象，迭代键和值，拆分字符串，过滤器，映射，具有原型继承等等等。所有内置于JavaScript引擎中的所有内容。除算术之外，WebAssembly无所作为。每当您在编译到WebasseMbly的语言中使用这些更高级别的概念中的任何一个，都必须将其捆绑到您的二进制文件中，这是大网上装配二进制文件的原因之一。当然，那些函数只需要包括一次，因此更大的项目将从WASM的小型二进制表达中受益，而不是小模块。</p><p>  Not all of these advantages are equally available or important in any given scenario. However, AssemblyScript is known to generate rather small WebAssembly binaries and I was curious how it can hold up in terms of speed and size with  directly comparable JavaScript.</p><p>  并非所有这些优点在任何特定的情况下都同样可用或重要。但是，已知大会旨在生成相当小的Webassembly二进制文件，我很好奇如何在速度和大小方面具有直接可比较的JavaScript。 </p><p>    As mentioned, AssemblyScript mimics TypeScript’s semantics and Web Platform APIs as much as possible, which means porting a piece of JS to ASC is  mostly a matter of adding type annotations to the code. As a first example, I took   glur, a JavaScript library that blurs images.</p><p>如上所述，组装MIMICS MIMICS的语义和Web平台API尽可能多，这意味着移植一块JS以ASC主要是将类型注释添加到代码的问题。作为第一个例子，我拍了glur，是一个迷惑图像的JavaScript库。</p><p>    ASC’s built-in types mirror the types of the WebAssembly VM. While numeric values in TypeScript are just  number (a 64-bit  IEEE754 float according to the spec), AssemblyScript has  u8,  u16,  u32,  i8,  i16,  i32,  f32 and  f64 as its primitive types. The  small-but-sufficiently-powerful standard library of ASC adds higher-level data structures like  string,  Array&lt;T&gt;,  ArrayBuffer,  Uint8Array etc. The only ASC-specific data structure, that is neither in JavaScript nor the Web Platform, is  StaticArray, which I will talk about a bit later.</p><p>    ASC的内置类型镜像WebasseMbly VM的类型。虽然键盘标记中的数值只是数字（根据规范的64位IEEE754浮动），assemblyscript具有U8，U16，U32，I8，I16，I32，F32和F64作为其原始类型。 ASC的小小无于强大的标准库添加了串，阵列＆lt;，arratsbuffer，uint8Array等的更高级别的数据结构。唯一的ASC特定数据结构，即既不是JavaScript也不是Web平台史蒂塔雷，我会稍后谈谈。</p><p>  As an example, here is a function from the glur library and its AssemblyScript’ified counterpart:</p><p>  作为一个例子，这里是来自Glur库及其组装的功能：</p><p>  function  gaussCoef ( sigma )  {  if  (sigma  &lt;  0.5 ) sigma  =  0.5 ;  var a  = Math . exp ( 0.726  *  0.726 )  / sigma ;  /* ... more math ... */  return  new   ( [ a0 , a1 , a2 , a3 , b1 , b2 , left_corner , right_corner  ] ) ; }</p><p>  功能Gausscoef（Sigma）{if（sigma＆lt; 0.5）sigma = 0.5; var a =数学。 EXP（0.726 * 0.726）/ Sigma; / * ...更多Math ... * /返回新（[A0，A1，A2，A3，B1，B2，Left_Corner，Right_Corner]）; }</p><p>  function  gaussCoef (sigma : f32 ) : Float32Array  {  if  (sigma  &lt;  0.5 ) sigma  =  0.5 ;  let a : f32  = Mathf . exp ( 0.726  *  0.726 )  / sigma ;  /* ... more math ... */  const r  =  new   ( 8 ) ;  const v  =  [ a0 , a1 , a2 , a3 , b1 , b2 , left_corner , right_corner  ] ;  for  ( let i  =  0 ; i  &lt; v .length ; i ++ )  { r [i ]  = v [i ] ;  }  return r ; }</p><p>  功能Gausscoef（Sigma：F32）：Float32Array {if（sigma <0.5）sigma = 0.5;让答：f32 = mathf。 EXP（0.726 * 0.726）/ SIGMA; / * ...更多数学... * / const r = new（8）; const v = [a0，a1，a2，a3，b1，b2，left_corner，right_corner]; for（让我= 0; i＆lt; length; i ++）{r [i] = v [i]; }返回r; }</p><p>  The explicit loop at the end to populate the array is there because of a current short-coming in AssemblyScript: Function overloading isn’t supported yet. There is only  exactly one constructor for  Float32Array in ASC, which takes an  i32 parameter for the length of the  TypedArray. Callbacks are supported in ASC, but closures also are not, so I can’t use  .forEach() to fill in the values. This is certainly  inconvenient, but not prohibitively so.</p><p>  填充数组的末尾的显式循环是因为当前在汇编中的电流短圈：函数重载不支持。 ASC仅存在float32Array的一个构造函数，这为TypedArray的长度带来了I32参数。按ASC支持回调，但闭包也不是，所以我不能使用.Foreach（）填写值。这肯定是不方便的，但并不是如此。</p><p>  Mathf: You might have noticed  Mathf instead of  Math.  Mathf is specifically for 32-bit floats, while  Math is for 64-bit floats. I could have used  Math and done a cast, but they are ever-so-slightly slower due to the increased precision required. Either way, the  gaussCoef function is not part of the hot path, so it really doesn’t make a difference.</p><p>  Mathf：你可能已经注意到了Mathf而不是数学。 Mathf专门用于32位浮点数，而数学是64位浮点数。我可以使用数学并完成演员，但由于所需的精度增加，它们略微略微稍慢。无论哪种方式，高斯库函数都不是热路径的一部分，因此它真的没有差异。 </p><p>    Something that took me an embarrassingly long time to figure out is that, uh, types matter. Blurring an image involves convolution, and that means a whole bunch of for-loops iterating over all the pixels. Naïvely I thought that because all pixel indices are positive, the loop counters would be as well and decided to choose  u32 for those loop variables. That’ll bite you with a  lovely infinite loop if any of those loops happen to iterate backwards, like the following one:</p><p>让我难以弄清楚的东西是弄清楚的是，呃，类型。模糊图像涉及卷积，这意味着整个围绕所有像素迭代。我认为，因为所有像素指数都是正的，因此循环计数器也是如此，并决定为那些环路变量选择U32。如果循环发生任何循环，那将用一个可爱的无限循环咬你，如下次数：</p><p>  let j : u32 ;  // ... many many lines of code ... for  (j  = width  -  1 ; j  &gt;=  0 ; j -- )  {  // ... }</p><p>  让J：U32; // ......许多代码行...对于（j =宽度 -  1; j＆gt; = 0; j  - ）{// ...}</p><p>  Apart from that, the act of porting JS to ASC was a pretty mechanical task.</p><p>  除此之外，移植JS到ASC的行为是一个漂亮的机械任务。</p><p>    Now that we have a JS file and an ASC file, we can compile the ASC to WebAssembly and run a little benchmark to compare the runtime performance.</p><p>    既然我们有一个JS文件和ASC文件，我们可以将ASC编译为webassembly并运行一点基准测试来比较运行时性能。</p><p>  d-What?:  d8 is a minimal CLI wrapper around V8, exposing fine-grained control over all kinds of engine features for both Wasm and JS. You can think of it like Node, but with no standard library whatsoever. Just vanilla ECMAScript. Unless you have compiled V8 locally (which you  can do by following  the guide on v8.dev), you probably won’t have  d8 available.  jsvu is a tool that can install pre-compiled binaries for many JavaScript engines, including V8.</p><p>  d  - 何种内容？：D8是v8周围的最小CLI包装器，暴露了对WASM和JS的各种发动机功能的细粒度控制。您可以像节点一样想到它，但没有任何标准库。只是香草ECMAScript。除非您在本地编译v8（通过沿V8.dev上的指南执行该指南），否则您可能不会有D8可用。 JSVU是一种工具，可以为许多JavaScript引擎安装预编译的二进制文件，包括V8。</p><p>  However, since this section has the word “Benchmarking” in the title, I think it’s important to put a disclaimer here: The numbers I am listing here are specific to the code that  I wrote in a language  I chose, ran on  my machine (a 2020 M1 MacBook Air) using a benchmark script that  I made. The results are coarse indicators  at best and it would be ill-advised to derive quantitative conclusions about the general performance of AssemblyScript, WebAssembly or JavaScript from this.</p><p>  然而，由于这个部分在标题中有“基准标记”这个词，我认为在这里放弃一个免责声明是很重要的：我在这里列出的数字是我用我选择的语言写入的代码，ran在我的机器上运行（一个2020 M1 MacBook空气）使用我所做的基准脚本。结果最多是粗略指标，并不是毫无意义地从中获取关于组装，WebAssembly或JavaScript的一般性表现的定量结论。</p><p>  Some might be wondering why I’m using  d8 instead of running this in the browser or even Node. Both Node and the browser have,... other stuff that may or may not screw with the results.  d8 is the most sterile environment I can get and as a cherry on top it allows me to control the tier-up behavior. I can limit execution to use Ignition, Sparkplug or Liftoff only, ensuring that performance characteristics don’t change in the middle of a benchmark.</p><p>  有些人可能想知道为什么我正在使用D8而不是在浏览器中甚至节点运行它。两个节点和浏览器都有，...其他可能或可能无法拧任何结果的其他东西。 D8是我可以获得最无菌的环境，作为顶部的樱桃，它允许我控制分层行为。我可以限制执行以使用点火，Sparkplug或升降机，确保性能特征不会在基准中间变化。 </p><p>    As described above, it is important to “warm-up” JavaScript when benchmarking, giving V8 a chance to optimize it. If you don’t do that, you may very well end up measuring a mixture of the performance characteristics of interpreted JS and optimized machine code. To that end, I’m running the blur program 5 times before I start measuring, then I do 50 timed runs and ignore the 5 fastest and slowest runs to remove potential outliers. Here’s what I got:</p><p>如上所述，在基准测试时，“预热”JavaScript非常重要，使V8有机会优化它。如果您不这样做，您可能会最终最终测量解释JS和优化机器代码的性能特征的混合。为此，我在开始测量之前5次运行模糊程序，然后我做了50个定时运行并忽略5最快，最慢的运行以删除潜在的异常值。这是我得到的：</p><p>     On the one hand, I was happy to see that Liftoff’s output was faster than what Ignition or Sparkplug could squeeze out of JavaScript. At the same time, it didn’t sit well with me that the optimized WebAssembly module takes about 3 times as long as JavaScript.</p><p>     一方面，我很高兴看到升降机的输出比点火或火花可以从JavaScript中挤出的速度更快。与此同时，优化的webassembly模块只要JavaScript长3倍，它并没有很好。</p><p>  To be fair, this is a David vs Goliath scenario: V8 is a long-standing JavaScript engine with a huge team of engineers implementing optimizations and other clever stuff, while AssemblyScript is a relatively young project with a small team around it. ASC’s compiler is single-pass and defers all optimization efforts to  Binaryen (see also:  wasm-opt). This means that optimization is done at the Wasm VM bytecode level, after most of the high-level semantics have been compiled away. V8 has a clear edge here. However, the blur code is so simple — just doing arithmetic with values from memory — that I was really expecting it to be closer. What’s going on here?</p><p>  要公平，这是一个David VS Goliath情景：V8是一个长期以来的JavaScript引擎，具有一支巨大的工程师，实现优化和其他聪明的东西，而组装是一个相对年轻的项目，围绕它的小团队。 ASC的编译器是单通过，持续到Binaryen的所有优化工作（另请参阅：WASM-opt）。这意味着在大多数高级语义被编译后，优化在WASM VM字节码级别完成。 V8在这里有一个清晰的边缘。但是，模糊代码如此简单 - 只是从内存中执行算术 - 我真的期待它更近。这里发生了什么？</p><p>    After quickly consulting with some folks from the V8 team and some folks from the AssemblyScript team (thanks  Daniel and  Max!), it turns out that one big difference here are “bounds checks” — or the lack thereof.</p><p>    快速咨询V8团队的一些人和大会团队的一些人（谢谢Daniel和Max！），事实证明这里的一个大区别是“界检查” - 或缺乏。</p><p>  V8 has the luxury of having access to your original JavaScript code and knowledge about the semantics of the language. It can use that information to apply additional optimizations. For example: It can tell you are not just randomly reading values from memory, but you are iterating over an  ArrayBuffer using a  for ... of loop. What’s the difference? Well with a  for ... of loop, the language semantics guarantee that you will never try to read values outside of the  ArrayBuffer. You will never end up accidentally reading byte 11 when the buffer is only 10 bytes long, or: You never go  out of bounds. This means TurboFan does not need to emit bounds checks, which you can think of as  if statements making sure you are not accessing memory you are not supposed to. This kind of information is lost once compiled to WebAssembly, and since ASC’s optimization only happens at WebAssembly VM level, it can’t necessarily apply the same optimization.</p><p>  V8具有访问原始JavaScript代码和关于语言语义的知识的奢侈品。它可以使用该信息来应用其他优化。例如：它可以告诉您不仅仅是从内存中读取值的不随机读取值，但是您正在使用循环的循环的ArrayBuffer迭代。有什么不同？对于循环的一个...，语言语义保证您永远不会尝试读取阵列缓冲外的值。当缓冲区仅为10个字节时，您永远不会意外读取字节11，或者：您永远不会超出界限。这意味着TurboOman不需要发出界限检查，您可以考虑到确保您不访问内存的语句您不应该。这类信息丢失一旦编译为网页，而且由于ASC的优化只发生在WebasseMbly VM级别，因此不一定应用相同的优化。</p><p>  Luckily, AssemblyScript provides a magic  unchecked() annotation to indicate that we are taking responsibility for staying in-bounds.</p><p>  幸运的是，AssemblyScript提供了一种魔法未选中（）注释，以表明我们负责留下界限。</p><p>  -  prev_prev_out_r = prev_src_r * coeff[6]; -  line[line_index] = prev_out_r;  +  prev_prev_out_r = prev_src_r * unchecked(coeff[6]); +  unchecked(line[line_index] = prev_out_r);</p><p>   -  prev_prev_out_r = prev_src_r * coeff [6]; - 行[line_index] = prev_out_r; + prev_prev_out_r = prev_src_r *未选中（coeff [6]）; +未选中（行[line_index] = prev_out_r）; </p><p>  But there’s more: The Typed Arrays in AssemblyScript ( Uint8Array,  Float32Array, ...) offer the same API as they do on the platform, meaning they are merely a view onto an underlying  ArrayBuffer. This is good in that the API design is familiar and battle-tested, but due to the lack of high-level optimizations, this means that every access to a field on the Typed Array (like  myFloatArray[23]) needs to access memory twice: Once to load the pointer to the underlying  ArrayBuffer of this specific array, and another to load the value at the right offset. V8, as it can tell that you are accessing the Typed Array but never the underlying buffer, is most likely able to optimize the entire data structure so that you can read values with a single memory access.</p><p>但是还有更多：assemblyscript的键入数组（UInt8Array，Float32Array，...）在平台上完成相同的API，这意味着它们仅在底层ArrayBuffer上的视图。这是良好的，因为API设计熟悉并进行了战斗，但由于缺乏高级别的优化，这意味着每次访问键入的阵列上的字段（如MyFloatarray [23]）需要两次访问内存：一旦将指针加载到此特定阵列的基础阵列缓冲区，另一个要在正确的偏移量上加载值。 V8，因为它可以告诉您访问键入的阵列但从来没有底层缓冲区，很可能能够优化整个数据结构，以便您可以使用单个内存访问读取值。</p><p>  For that reason, AssemblyScript provides  StaticArray&lt;T&gt;, which is mostly equivalent to an  Array&lt;T&gt; except that it can’t grow. With a fixed length, there is no need to keep the Array entity separate from the memory the values are stored in, removing that indirection.</p><p>  因此，AssemblyScript提供了StatyArray＆lt; t＆gt;，它大多等于阵列＆lt; t＆gt;除了它不能成长。通过固定长度，不需要将数组实体与存储器分开，这些值存储在内存中，从而消除该间接。</p><p>       A lot better! While the AssemblyScript is still slower than the JavaScript, we got significantly closer. Is this the best we can do?</p><p>       好了很多！虽然组装仍然比JavaScript慢，但我们显着更近。这是我们能做的最好的吗？</p><p>    Another thing that the AssemblyScript folks pointed out to me is that the  --optimize flag is equivalent to  -O3s which aggressively optimizes for speed, but makes tradeoffs to reduce binary size.  -O3 optimizes for speed and speed only. Having  -O3s as a default is good in spirit — binary size matters on the web — but is it worth it? At least in this specific example the answer is no:  -O3s ends up trading the laughable amount of ~30 bytes for a huge performance penalty:</p><p>    对我指出的组件的另一件事是--Optimize标志等同于-O3积极优化速度，而是使权衡降低二元尺寸。 -O3仅优化速度和速度。在-O3s作为默认的灵感良好 - 网上的二元尺寸很重要 - 但它是值得的吗？至少在这个具体的例子中，答案是否定的：-O3最终交易巨大的绩效惩罚的可笑量〜30字节：</p><p>     One single optimizer flag makes a night-and-day difference, letting AssemblyScript overtake JavaScript (on this specific test case!). We made AssemblyScript faster than JavaScript!</p><p>     一个单一优化器标志呈夜间差异，让装配脚本超越JavaScript（在此特定的测试用例！）。我们制作的大会比JavaScript更快！</p><p>      To gain some confidence that the image blur example is not just a fluke, I thought I should try this again with a second program. Rather uncreatively, I took a bubblesort implementation off of StackOverflow and ran through the same process: Add types. Run benchmark. Optimize. Run benchmark. The creation and population of the array that’s to be bubble-sorted is  not part of the benchmarked code path.</p><p>      为了获得一些信心，图像模糊例子不仅仅是一种侥幸，我以为我应该用第二个程序再次尝试这一点。相反，我采取了冒泡性地从stackoverflow的冒泡来实现，并通过相同的进程运行：添加类型。运行基准。优化。运行基准。阵列的创建和群体是泡沫排序的不是基准代码路径的一部分。</p><p>     We did it again! This time with an even bigger discrepancy: The optimized AssemblyScript is almost twice as fast as JavaScript. But do me a favor: Don’t stop reading now.</p><p>     我们再次这样做了！这次具有甚至更大的差异：优化的综合脚本几乎是JavaScript的两倍。但我帮忙：现在不要停止阅读。 </p><p>    Some of you may have noticed that both these examples have very few or no allocations. V8 takes care of all memory management (and garbage collection) in JavaScript for you and I won’t pretend that I know much about it. In WebAssembly, on the other hand, you get a chunk of linear memory and you have to decide how to use it (or rather: the language does). How much do these rankings change if we make  heavy use of dynamic memory?</p><p>有些人可能已经注意到这两个例子都非常少或没有分配。 V8为您提供JavaScript中的所有内存管理（和垃圾收集），我不会假装我对此了解。另一方面，在WebAssAssembly中，您可以获得一大块线性内存，您必须决定如何使用它（或者更确切地说：语言）。如果我们大量使用动态内存，这些排名会如何发生多少？</p><p>  To measure this, I chose to benchmark an implementation of a  binary heap. The benchmark fills the binary heap with 1 million random numbers (courtesy of  Math.random()) and  pop()s them all back out, checking that the numbers are in increasing order. The process remained the same as above: Make a naïve port of the JS code to ASC, run benchmark, optimize, benchmark again:</p><p>  为了测量这一点，我选择基准测试二进制堆的实现。基准测试填充了100万随机数（Math.Random（）的礼貌）填充二进制堆）并将其全部退回，检查数字是否按顺序增加。该过程仍然与上面相同：使JS代码的Naïve端口进行ASC，运行基准，优化，再次进行基准：</p><p>     80x slower than JavaScript?! Even slower than Ignition? Surely, there is something else going wrong here.</p><p>     80x比JavaScript慢？！甚至比点火慢？当然，这里还有其他东西出现问题。</p><p>    All data that we create in AssemblyScript needs to be stored in memory. To make sure we don’t overwrite anything else that is already in memory, there is memory management. As AssemblyScript aims to provide a familiar environment, mirroring the behavior of JavaScript, it adds a fully managed garbage collector to your WebAssembly module so that you don’t have to worry about when to allocate and when to free up memory.</p><p>    我们在组件中创建的所有数据都需要存储在内存中。要确保我们不会覆盖已在内存中的其他任何内容，都有内存管理。随着AssemblyScript旨在提供熟悉的环境，镜像JavaScript的行为，它会将一个完全托管的垃圾收集器添加到WebasseMbly模块，以便您不必担心何时分配以及何时释放内存。</p><p>  By default, AssemblyScript ships with a  Two-Level Segregated Fit memory allocator and an  Incremental Tri-Color Mark &amp; Sweep (ITCMS) garbage collector. It’s not actually relevant for this article what kind of allocator and garbage collector they use, I just found it interesting that you can go  look at them.</p><p>  默认情况下，汇票船用双级分离拟合存储器分配器和增量三色标记＆amp;扫描（ITCMS）垃圾收集器。它实际上与本文实际上并不重要，他们使用的是哪种分配器和垃圾收集器，我刚才发现您可以看看它们的有趣。</p><p>  This default runtime, called  incremental, is surprisingly small, adding only about 2KB of gzip’d WebAssembly to your module. AssemblyScript also offers alternative runtimes, namely  minimal and  stub that can be chosen using the  --runtime flag.  minimal uses the same allocator, but a more lightweight GC that does  not run automatically but must be manually invoked. This could be interesting for high-performance use-cases like games where you want to be in control when the GC will pause your program.  stub is  extremely small (~400B gzip’d) and fast, as it’s just a  bump allocator.</p><p>  这个默认的运行时，称为增量，令人惊讶的是，只增加大约2KB的GZIP的网页主义。 AssemblyScript还提供替代的运行时间，即可以使用--Runtime标志选择的最小和存根。 MIMIMAL使用相同的分配器，而是一个更轻量级的GC，不自动运行，但必须手动调用。对于在GC将暂停程序时，您希望在您想要控制的游戏中，这可能是有趣的。存根非常小（〜400b gzip），快速，因为它只是一个凹凸分配器。</p><p>  My lovely memory bump: Bump allocators are  extremely fast, but lack the ability to free up memory. While that sounds stupid, it can be extremely useful for single-purpose modules, where instead of freeing memory, you delete the entire WebAssembly instance and rather create a new one. If you are curious, I actually wrote a bump allocator in my article  Compiling C to WebAssembly without Emscripten.</p><p>  我可爱的记忆凹凸：凹凸分配器非常快，但缺乏释放记忆的能力。虽然这听起来很愚蠢，但对于单一的模块来说，这可能非常有用，而不是释放内存，则删除整个WebasseMbly实例并相当创建一个新的。如果您很好奇，我实际上在我的文章中编写了一个凹凸分配器，在没有eMscripten的情况下编译到webassembly。 </p><p>       Both  minimal and  stub get us  significantly closer to JavaScripts performance. But  why are these two so much faster? As mentioned above,  minimal and  incremental share the same allocator, so that can’t be it. Both also have a garbage collector, but  minimal doesn’t run it unless explicitly invoked (and we ain’t invoking it). That means the differentiating quality is that  incremental  runs garbage collection, while  minimal and  stub do not. I don’t see why the garbage collector should make this big of a difference, considering it has to keep track of  one array.</p><p>最小和存根都会让我们显着更接近JavaScripts性能。但为什么这两个太快了？如上所述，最小和增量的共享相同的分配器，因此不能成为它。两者也有一个垃圾收集器，但除非明确地调用（我们并不调用它，否则最小的运行它这意味着差异化的质量是增量运行垃圾收集，而最小值和短卷则不会。我不明白为什么垃圾收集器应该使这种差异很大，考虑到它必须跟踪一个阵列。</p><p>    After doing some  profiling with d8 on a build with debugging symbols ( --debug), it turns out that a lot of time is spent in a system library  libsystem_platform.dylib, which contains OS-level primitives for threading and memory management. Calls into this library are made from  __new and  __renew, which in turn are called from  Array&lt;f32&gt;#push:</p><p>    在使用调试符号（--debug）的构建中使用D8进行了一些分析，事实证明，在系统库Libsystem_Platform.Dylib中花费了大量时间，其中包含用于线程和内存管理的OS级原语。进入这个库的呼叫是由__new和__gene制作的，从阵列又称r; f32＆gt; #push：</p><p>  [Bottom up (heavy) profile]: ticks parent name 18670 96.1% /usr/lib/system/libsystem_platform.dylib 13530 72.5% Function: *~lib/rt/itcms/__renew 13530 100.0% Func</p><p>  [自下而上（重）配置文件]：滴答父项名称18670 96.1％/usr/lib/system/libsystem_platform.dylib 13530 72.5％函数：*〜lib / RT / ITCMS / __续签13530 100.0％Func</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://surma.dev/things/js-to-asc/">https://surma.dev/things/js-to-asc/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/magic/">#magic</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>