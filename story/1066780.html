<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>巧妙的树木 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">巧妙的树木 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-19 06:02:24</div><div class="page_narrow text-break page_content"><p>Verkle树是塑造的，成为Ethereum的重要组成部分＆＃39;升级升级。它们与merkle树相同的功能：您可以将大量数据放入Verkle树中，并制作该数据的任何单件或一组碎片的短缺（＆＃34;证人＆＃34;）可以由只有树根的人验证。然而，Verkle Tree提供的关键属性是它们在证明尺寸方面更有效。如果一棵树包含十亿条数据，则在传统的二进制Merkle树中呈现验证需要大约1千字节，但在Verkle树中，证据将小于150字节 - 减少足以使无国籍客户在实践中最终可行的减少。</p><p> 这篇文章将解释验尸树是什么以及它们背后的加密魔法。它们的短尺寸的价格是对更复杂的密码学的依赖程度更高。也就是说，在我看来，密码术仍然比现代ZK Snark方案中发现的高级密码更简单。在这篇文章中我＆＃39; ll做到最好的工作，我可以在解释它。</p><p>  就树的结构（树中的节点被安排的节点以及它们包含的东西）而言，Verkle树非常相似于当前在Ethereum中使用的Merkle Patricia树。每个节点都是（i）空，（ii）包含键和值的叶节点，或（iii）具有一些固定数量的儿童的中间节点（＆＃34;宽度＆＃34;树的宽度＆＃34）。中间节点的值被计算为其子子的值的哈希值。</p><p> 树中值的位置基于其密钥：在下图中，要使用键4cc到达节点，从根开始，然后向下到第4位的子项，然后向下到孩子在位置C（记住：C = 12在十六进制中），然后再次下降到位置C。要使用key baaa到达节点，请转到根的位置 -  b子项，然后是该节点的位置。路径（b，a）处的节点直接包含带有key baaa的节点，因为树中没有其他键在ba开始。</p><p>           Verkle树和Merkle Patricia树结构的唯一真正差异是验证树在实践中更广泛。更宽。当宽度= 2（因此Evereum＆＃39; Seexary Patricia树实际上非常次优）时，帕特里夏树是最有效的。另一方面，Verkle树越来越短，较短的证据越高，宽度越高;唯一的限制是，如果宽度变得太高，则证明开始花费太长以创建。为Etereum提出的Verkle树的宽度为256，有些人甚至有利于将其提升到1024（!!）。</p><p>  在Merkle树（包括Merkle Patricia树）中，值的证明包括整套姐妹节点：证明必须包含树中的所有节点，该节点与路径中的路径中的任何节点共享一个父节点您正在尝试证明的节点。这可能是一个很复杂的理解，所以这里＆＃39;＆＃39; s的校样在4CE位置的迹象。必须包含在证明中的姐妹节点以红色突出显示。</p><p>         那个节点＆＃39;很多节点！您需要在每个级别提供姐妹节点，因为您需要节点的整套子组来计算该节点的值，并且您需要继续执行此操作，直到您到达root。您可能会认为这并不糟糕，因为大多数节点都是零，但是＆＃39;■仅是因为这棵树的节点很少。如果此树有256个随机分配的节点，则顶层几乎肯定会有所有16个节点满16个节点，并且第二层平均将平均为〜63.3％。 </p><p>另一方面，在Verkle树中，您不需要提供姐妹节点;相反，您只需提供路径，稍微替代证明。这就是为什么Verkle树从更大的宽度和Merkle Patricia树中受益于：一棵树宽度更大的树导致两种情况下的较短路径，但在Merkle Patricia树中，这种效果被需要提供所有宽度的更高成本所淹没 - 凭证中的1个姐妹节点。在Verkle树中，该成本不存在。</p><p> 那么我们需要作为证据的额外额外的额外是什么？要了解到，我们首先需要圈回一个关键细节：用于从其子节点计算内部节点的哈希函数不是常规哈希。相反，它＆＃39;是矢量承诺。</p><p> 矢量承诺方案是一种特殊类型的哈希函数，散列列表\（h（z_1，z_2 ... z_n）\ lightarrow c \）。但是矢量承诺具有承诺\（c \）和一个值\（z_i \），它和＃39; s的特殊属性，＆＃39; s可能做出\（c \）是对某些列表的承诺I＆＃39的值; Th位置是\（z_i \）。在Verkle验证中，此简短的证明替换了Merkle Patricia证明中的姐妹节点的功能，使验证者信心为子节点确实是其父节点的给定位置的子节点。</p><p>           在实践中，我们使用比矢量承诺更强大的原始，称为多项式承诺。多项式承诺让您散列多项式，并在任何时候进行评估散列多项式的证据。您可以使用多项式承诺作为矢量承诺：如果我们同意一组标准化协调\（（C_1，C_2 ... C_N），则给出列表\（（y_1，y_2 ... y_n）\）您可以提交多项式\（p \），其中\（p（c_i）= y_i \）所有\（i \在[1..n] \中）（您可以使用Lagrange插值找到此多项式）。我谈论我关于ZK-Snark的文章中的长度的多项式承诺。这两个多项式承诺方案是最容易使用的是KZG承诺和防弹式承诺（在这两种情况下，承诺是一个32-48字节椭圆曲线点）。多项式承诺给了我们更多的灵活性，让我们提高效率，就是这样，它就会发生最简单，最有效的矢量承诺是多项式承诺。</p><p> 这个方案已经非常强大，因为它使用KZG承诺和证明，证明尺寸为96个字节，如果我们设置宽度= 256，则比简单的Merkle验证更高3倍。但是，它事实证明，我们可以进一步提高空间效率。</p><p>        通过使用多项式承诺的额外属性，我们可以通过使用多项式承诺的额外属性，而不是要求对路径的每个承诺进行一个证据。我们可以在沿着无限数量密钥的路径之间证明承诺之间的所有父子链接。我们使用通过随机评估实现多体的方案来执行此操作。</p><p> 但要使用此方案，我们首先需要将问题转换为更具结构化的问题。我们在Verkle树中有一个或多个值的证明。此证明的主要部分包括沿每个节点的路径的中间节点组成。对于我们提供的每个节点，我们还必须证明它实际上是它上方的节点的子节点（以及在正确的位置）。在上面的单值防范示例中，我们需要证明证明： </p><p>关键：4CE节点实际上是前缀：4C中间节点的位置 -  e子节点。</p><p> 前缀：4C中间节点实际上是前缀的位置：4中间节点。</p><p> 如果我们有一个证明多个值的证据（例如，4CE和420），我们将具有更多节点甚至更多的链接。但在任何情况下，我们证明是一系列表单＆＃34的陈述;节点A实际上是节点B＆＃34的位置-I孩子;如果我们正在使用多项式承诺，则这变成了方程式：\（a（x_i）= y \），其中\（y \）是对\（b \）的承诺的哈希。</p><p> 这个证据的细节是由Dankrad Feist的技术和更好的解释。到目前为止，证明生成中最粗壮和耗时的步骤涉及计算形式的多项式\（g \）：</p><p> \（g（x）= r ^ 0 \ frac {a_0（x） -  y_0} {x  -  x_0} + r ^ 1 \ frac {a_1（x） -  y_1} {x  -  x_1} + ... + r ^ n \ frac {a_n（x） -  y_n} {x  -  x_n} \）</p><p> 如果该表达式是多项式（而不是分数），则只能计算每个术语\（r ^ i \ frac {a_i（x） -  y_i} {x-x_i} \）。并且在点\（x_i \）处需要\（a_i（x）\）到等于\（y_i \）。</p><p>  我们正在证明\（（x_i = 2，y_i = 9）\）。 \（a_i（2）\）等于\（9 \）所以这将有效。 </p><p>\（a_i（x） -  9 = x ^ 2 + x-6 \），\（\ frac {x ^ 2 + x  -  6} {x  -  2} \）给出一个clean \（x  -  3 \） 。但如果我们尝试适合\（（x_i = 2，y_i = 10）\），这将无法正常工作; \（x ^ 2 + x-7 \）无法干净地除以\（x  -  2 \）而没有分数余数。</p><p> 其余证据涉及为\（g（x）\）提供多项式承诺，然后证明承诺实际上是正确的。再次，见Dankrad＆＃39;对剩下的证据进行了更多技术描述。</p><p>             Dankrad＆＃39; S多随机评估证明允许先驱证明任意数量的评估\（a_i（x_i）= y_i \），给定每个\（a_i \）的承诺以及被证明的值。此证明是恒定尺寸（一个多项式承诺，一个数字和两个证据;根据正在使用的方案，128-1000字节）。</p><p> 不需要显式提供\（y_i \）值，因为它们可以从Verkle校样中的其他值直接计算：每个\（y_i \）本身是路径中下一个值的散列（无论是承诺或叶子）。</p><p> 也不需要明确地提供\（x_i \）值，因为可以从键和从路径派生的坐标计算路径（并且因此\（x_i \）值）。</p><p> 因此，我们所需要的只是我们证明的叶子（键和值），以及沿着每个叶子到根的路径的承诺。</p><p> 假设宽度-256树和\（2 ^ {32} \）节点，证明需要被证明的键和值，以及沿着该值的路径的每个值的三个承诺根。 </p><p>如果我们证明许多值，还节省了进一步的节省：无论您证明多少值，都不需要在顶级提供超过256个值。</p><p>   假设宽度256和48字节KZG承诺/证明。还要注意，这假定了最大的树木;对于一个真实的随机树，深度为〜0.6（每个元素所以〜30个字节）。如果使用防弹式承诺而不是KZG，它的安全性将降至32字节，因此这些尺寸可以减少1/3。</p><p>  生成证据的大部分是计算每个\（r ^ i \ frac {a_i（x） -  y_i} {x-x_i} \）表达式。这需要大致四个现场操作（即256位模块化算术运算）树的宽度。这是主要约束限制Verkle树宽度。幸运的是，四个现场操作是一种小成本：单个椭圆曲线乘法通常需要数百个现场操作。因此，Verkle树宽可以很高;宽度256-1024似乎是一个最佳范围。</p><p> 要编辑树，我们需要＆＃34;走上树＆＃34;从叶子到根部，改变每个步骤的中间承诺，反映发生较低的变化。幸运的是，我们不必重新计算从头开始重新计算每个承诺。相反，我们利用了同性恋性质：给定多项式承诺\（c = com（f）\），我们可以通过\（c＆＃39来计算\（c＆＃39; = com（f + g）\） ; = C + COM（g）\）。在我们的情况下，\（g = l_i *（v_ {new}  -  v_ {old}）\），其中\（l_i \）是对多项式的预先计算的承诺，其在我们＆＃39的位置等于1; Re试图在其他地方改变和0。</p><p> 因此，单个编辑需要〜4个椭圆曲线乘法（叶片之间的每个承诺，这次包括根），但是通过预先计算和存储每个\（L_I \的许多倍数，它们可以大大加速这些时间）。</p><p> 证明验证非常有效。对于N值的证明，验证者需要执行以下步骤，所有这些步骤都可以在数千毫秒内完成，以便数千个值：</p><p> 不依赖于证明的规模的小持续工作量 </p><p>另请注意，与Merkle Patricia证明一样，Verkle凭证为验证者提供了足够的信息以修改在应用更改后被证明的树中的值并计算新的根哈希值。这对于验证例如。正确处理块的状态变化。</p><p>  Verkle树是一个强大的升级到Merkle证据，允许更小的校样尺寸。而不是需要提供所有＆＃34;姐妹节点＆＃34;在每个级别，PROVER仅需要提供一个单一的证据，这些证明证明了沿着每个叶节点的路径到根目录的所有承诺之间的所有父子关系。与理想的Merkle树相比，这允许证明尺寸减小〜6-8倍，与Ethereum使用今天（!!）相比，相比之下超过20-30倍。</p><p> 他们确实需要更复杂的加密来实现，但它们呈现出大量增长的机会。在中期，Snarks可以进一步改进内容：我们可以将已经有效的Verkle验证验证者扩展到接近零的证人大小，或者如果/当SNARKS更好时，请切换回SNARKED Merkle校样（例如，通过GKR ，或非常狡猾的哈希函数或asics）。进一步下行，量子计算的兴起将迫使改变与哈里斯的哈尔克勒证据的变化，因为它使得Verkle树取决于不安全的线性同态。但是，现在，他们向我们提供了我们将获得这种更先进的技术的相同缩放增益，我们已经拥有了所有的工具，我们需要有效地实现它们。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://vitalik.ca/general/2021/06/18/verkle.html">https://vitalik.ca/general/2021/06/18/verkle.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/树木/">#树木</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/verkle/">#verkle</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/证明/">#证明</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>