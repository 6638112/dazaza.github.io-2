<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Node.js上的GRPC，带buf和tyescript</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Node.js上的GRPC，带buf和tyescript</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-06 07:12:06</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/79c2f375ea3441afe5affb85434a0e73.png"><img src="http://img2.diglog.com/img/2020/11/79c2f375ea3441afe5affb85434a0e73.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In this chapter, we will configure a modern, sustainable build process that lays the foundations for working with gRPC on Node.js.</p><p>在本章中，我们将配置一个现代的、可持续的构建过程，为在Node.js上使用GRPC奠定基础。</p><p> In Part 2, we will build on these learnings and implement a gRPC server in TypeScript. And then finally,  in Part 3, we will close off with useful tips and tricks on topics around code organisation, testing, deployments, further improving developer experience, and more.</p><p>在第2部分中，我们将在这些学习的基础上，以打印脚本的形式实现GRPC服务器。最后，在第3部分中，我们将以关于代码组织、测试、部署、进一步改善开发人员体验等主题的有用提示和技巧来结束。</p><p>  Let’s start by creating a new project (you may optionally want to  git init).</p><p>让我们从创建一个新项目开始(您可以选择使用git init)。</p><p>     Before  we jump into tooling, let’s define our “common” messages as well as our service, aptly named  HelloService.</p><p>在我们开始讨论工具之前，让我们先定义我们的“公共”消息以及我们的服务，将其恰当地命名为HelloService。</p><p>      Now that we’ve defined our protos, let’s install and configure Buf to see what we can improve…</p><p>既然我们已经定义了我们的Protos，那么让我们安装和配置buf，看看我们可以改进…的哪些方面。</p><p> If you’re on macOS, you can use  brew. For other installation options, please refer to the  official guide.</p><p>如果您使用的是MacOS，则可以使用BREW。有关其他安装选项，请参考官方指南。</p><p>  As per  the official guide, we’ll first create our Buf config ( buf.yaml). For the purpose of this tutorial we will use the strictest possible lint setting.</p><p>根据官方指南，我们将首先创建我们的buf配置(buf.yaml)。出于本教程的目的，我们将使用最严格的皮棉设置。</p><p>     $ buf check lint com/language/language.proto:3:1:Package name &#34;com.language&#34; should be suffixed with a correctly formed version, such as &#34;com.language.v1&#34;. com/language/language.proto:10:5:Enum value name &#34;EN&#34; should be prefixed with &#34;CODE_&#34;. com/language/language.proto:10:5:Enum zero value name &#34;EN&#34; should be suffixed with &#34;_UNSPECIFIED&#34;. services/hello/hello_service.proto:5:1:Package name &#34;services.hello&#34; should be suffixed with a correctly formed version, such as &#34;services.hello.v1&#34;.</p><p>$buf check lint com/language/language.proto：3：1：包名&#34；com.language&#34；应以格式正确的版本作为后缀，例如&#34；com.language.v1&#34；。Com/language/language.proto：10：5：枚举值名称&#34；en&#34；应以&#34；code_&#34；为前缀。Com/language/language.proto：10：5：Enum零值名称&#34；en&#34；应以&#34；_UnSpecified&#34；为后缀。Services/hello/hello_service.proto:5:1:Package名称&#34；services.Hello&#34；应该以格式正确的版本作为后缀，例如&#34；services.hello.v1&#34；。</p><p>  In  proto/com/language/language.proto, we’ll update the  Language.Code Enum values as suggested and the package will now need to include a version ( v1).</p><p>在proto/com/language/language.proto中，我们将按照建议更新Language.Code Enum值，该包现在需要包含一个版本(V1)。</p><p>  In  proto/services/hello_service.proto, we’ll update the reference to  Language.Code to include  v1 and the package will now need to include a version ( v1) as well.</p><p>在proto/services/Hello_service.proto中，我们将更新对Language.Code的引用以包括v1，包现在还需要包括一个版本(V1)。</p><p>  Running  buf check lint fails again, this time because we are told that the directory structure must match the package name-spacing.</p><p>运行buf check lint再次失败，这一次是因为我们被告知目录结构必须与包名称间距匹配。</p><p> $ buf check lint com/language/language.proto:3:1:Files with package &#34;com.language.v1&#34; must be within a directory &#34;com/language/v1&#34; relative to root but were in directory &#34;com/language&#34;. services/hello/hello_service.proto:5:1:Files with package &#34;services.hello.v1&#34; must be within a directory &#34;services/hello/v1&#34; relative to root but were in directory &#34;services/hello&#34;.</p><p>$buf check lint com/language/language.proto：3：1：带有包&#34；com.language.v1&#34；的文件必须位于相对于根目录的&#34；com/language/v1&#34；目录中，但位于&#34；com/language&#34；目录中。Services/Hello/Hello_service.proto：5：1：带有Package&#34；services.hello.v1&#34；的文件必须位于相对于根目录的&#34；services/Hello/v1&#34；目录中，但位于&#34；services/Hello&34；目录中。</p><p> All we need is to move the protos into their respective  .VERSION directories, in our case  v1. To verify:</p><p>我们需要做的就是将Protos移到它们各自的.VERSION目录中，在我们的例子中是v1。要验证，请执行以下操作：</p><p>      FileDescriptorSets are the primitive used throughout the Protobuf ecosystem to represent a compiled Protobuf schema. They are also the primary artifact that  protoc produces.</p><p>FileDescriptorSets是在整个Protobuf生态系统中使用的原语，用于表示已编译的Protobuf模式。它们也是proac生产的主要产品。</p><p> You probably also know that working with  protoc and  protoc plugins can be cumbersome, some might even say painful.</p><p>你可能也知道，使用proc和proc插件可能会很麻烦，有些人甚至会说很痛苦。</p><p> Buf aims to alleviate these pains with what it calls Images. An Image is essentially Buf’s custom extension to  FileDescriptorSets. And because it’s an  extension,   Images are FileDescriptorSets, and FileDescriptorSets are Images.</p><p>BUF的目标是通过它所谓的图像来缓解这些痛苦。Image本质上是Buf对FileDescriptorSets的自定义扩展。因为它是一个扩展，所以Images是FileDescriptorSets，而FileDescriptorSets是Images。</p><p>   You can, of course, choose from a  variety of formats but for the purpose of this tutorial we’ll stick to json.</p><p>当然，您可以从各种格式中进行选择，但出于本教程的目的，我们将坚持使用json。</p><p> Now that we’ve successfully built an image, we can use it as a baseline to ensure that any new changes won’t break backwards compatibility.</p><p>现在我们已经成功构建了一个映像，我们可以将其用作基线，以确保任何新的更改都不会破坏向后兼容性。</p><p>   Let’s see what happens if we try to introduce a breaking change in one of our messages. For example, we could change  language_code from position  2 to position  3.</p><p>让我们看看，如果我们试图在其中一条消息中引入一个突破性的变化，会发生什么。例如，我们可以将LANGUAGE_CODE从位置2更改为位置3。</p><p>   $ buf check breaking --against image.json services/hello/v1/hello_service.proto:11:1:Previously present field &#34;2&#34; with name &#34;language_code&#34; on message &#34;GreetRequest&#34; was deleted without reserving the name &#34;language_code&#34;. services/hello/v1/hello_service.proto:11:1:Previously present field &#34;2&#34; with name &#34;language_code&#34; on message &#34;GreetRequest&#34; was deleted without reserving the number &#34;2&#34;.</p><p>$buf支票中断--已删除消息&#34；GreetRequest&#34；上名称为&#34；Language_services/hello/v1/hello_service.proto:11:1:Previously&#34；的Image.json语言当前字段&#34；，但不保留名称&#34；Language_Code&#34；。已删除消息&#34；问候语&#34；上名为&#34；语言_代码&#34；的services/hello/v1/hello_service.proto:11:1:Previously显示字段&#34；2&#34；，但不保留编号&#34；2&#34；。</p><p> This can be especially useful in CI/CD contexts. You could, for example, store your “baseline” Image artefact somewhere and reject any potential changes that don’t pass the breaking change detection, thus only ever allowing the “baseline” Image to be updated on the condition the no breaking changes are introduced.</p><p>这在CI/CD上下文中可能特别有用。例如，您可以将“基线”图像人工产物存储在某个地方，并拒绝任何未通过中断更改检测的潜在更改，从而只允许在没有引入中断更改的情况下更新“基线”图像。</p><p>   While it’s certainly possible to use  the   @grpc/proto-loader  library to load  .proto files directly into the runtime, for those wanting to use TypeScript this would effectively mean losing all typing.</p><p>虽然当然可以使用@grpc/proto-loader库将.proto文件直接加载到运行时中，但对于那些想要使用TypeScrip的人来说，这实际上意味着不再输入任何内容。</p><p> Buf comes with  generation capability which reduces the complexity of using and configuring  protoc + plugins and further streamlines the process. Let’s give it a try!</p><p>BUF具有生成功能，这降低了使用和配置proc+插件的复杂性，并进一步简化了流程。让我们试一试吧！</p><p> ⚠️ NOTE: The below assumes you have a working installation of  protoc ( version 3.12.3 or above).</p><p>⚠️注意：下面假设您已经安装了Protoc(3.12.3版或更高版本)。</p><p>     You can change or completely omit  opt if you like, but for the purpose of this tutorial we’ll use the recommended options. See  https://developers.google.com/protocol-buffers/docs/reference/javascript-generated#compiler-options for more details.</p><p>如果愿意，您可以更改或完全省略opt，但出于本教程的目的，我们将使用推荐的选项。有关更多详细信息，请参阅https://developers.google.com/protocol-buffers/docs/reference/javascript-generated#compiler-options。</p><p>  $ tree build/nodejs build/nodejs ├── com │ └── language │ └── v1 │ └── language_pb.js └── services  └── hello  └── v1  └── hello_service_pb.js 6 directories, 2 files</p><p>$TREE BUILD/NodeJS Build/NodeJS├──COM│└──Language│└──v1│└──Language_pb.js└──服务└──HELLO└──v1└──HELLO_SERVICE_Pb.js 6个目录，2个文件。</p><p>  For this to work, we’ll need to install  grpc-tools to get hold of the  grpc_tools_node_protoc plugin.</p><p>为此，我们需要安装GRPC-Tools来获取GRPC_TOOLS_NODE_PROTOC插件。</p><p>     The  out option is identical to that of the  js plugin— we want the JavaScript and gRPC generated modules to be colocated.</p><p>Out选项与js插件相同-我们希望将JavaScript和GRPC生成的模块放在同一位置。</p><p> You can change or completely omit the  opt if you like, but for the purpose of this tutorial we’ll use the  grpc_js option which instructs the plugin to generate code that uses   @grpc/grpc-js (as opposed to the soon-to-be-deprecated   grpc). See  grpc-tools for more details.</p><p>如果愿意，您可以更改或完全省略该选项，但出于本教程的目的，我们将使用grpc_js选项，该选项指示插件生成使用@grpc/grpc-js的代码(而不是即将废弃的GRPC)。有关更多详细信息，请参阅GRPC-Tools。</p><p> After we’ve run  buf generate again, we will see the new  _grpc_pb.js files.</p><p>再次运行buf Generate之后，我们将看到new_grpc_pb.js文件。</p><p> $ tree build/nodejs build/nodejs ├── com │ └── language │ └── v1 │ ├── language_grpc_pb.js │ └── language_pb.js └── services  └── hello  └── v1  ├── hello_service_grpc_pb.js  └── hello_service_pb.js 6 directories, 4 files</p><p>$TREE BUILD/NodeJS Build/NodeJS├──COM│└──Language│└──v1│├──Language_grpc_pb.js│└──Language_pb.js└──服务└──HELLO└──v1├──HELLO_SERVICE_GRPC_pb.js└──HELLO_SERVICE_pb.js 6个目录，4个文件。</p><p>   First, we install the required plugin ( protoc-gen-ts). Funnily enough, this is the only plugin we’ve used so far that follows the  protoc-gen-NAME convention.</p><p>首先，我们安装所需的插件(proc-gen-ts)。有趣的是，这是我们到目前为止使用的唯一遵循协议命名约定的插件。</p><p>  Buf will by default look for  protoc-gen-NAME ( NAME being  ts as per example below) on  $PATH so we don’t need to use the  path option for this plugin.</p><p>默认情况下，buf将在$PATH上查找proc-gen-name(如下所示，名称为ts)，因此我们不需要为该插件使用路径选项。</p><p>   The  out option is identical to those of the  grpc and  js plugins — we need all TypeScript definitions to be colocated with their JavaScript counterparts.</p><p>Out选项与GRPC和js插件的选项相同--我们需要将所有类型的脚本定义与它们的JavaScript对应项放在同一位置。</p><p> As is the case with the  grpc_tools_node_protoc plugin, you can change or completely omit the  opt if you like. For the purpose of this tutorial we’ll use the  grpc_js option to instruct the plugin to generate code that uses   @grpc/grpc-js (as opposed to the soon-to-be-deprecated   grpc). See  grpc_tools_node_protoc_ts for more details.</p><p>与GRPC_TOOLS_NODE_PROTEC插件一样，如果愿意，您可以更改或完全省略该选项。出于本教程的目的，我们将使用grpc_js选项指示插件生成使用@grpc/grpc-js的代码(与即将废弃的GRPC相对)。有关详细信息，请参阅GRPC_TOOLS_NODE_PRORC_TS。</p><p> Let’s  buf build for one last time. We should now see the TypeScript definitions.</p><p>让我们做最后一次BUF建造吧。现在我们应该看到打字稿定义。</p><p> $ tree build/nodejs build/nodejs ├── com │ └── language │ └── v1 │ ├── language_grpc_pb.js │ ├── language_pb.d.ts │ └── language_pb.js └── services  └── hello  └── v1  ├── hello_service_grpc_pb.d.ts  ├── hello_service_grpc_pb.js  ├── hello_service_pb.d.ts  └── hello_service_pb.js 6 directories, 7 files</p><p>$TREE BUILD/NodeJS Build/NodeJS├──COM│└──Language│└──v1│├──Language_grpc_pb.js│├──Language_pb.d.ts│└──Language_pb.js└──服务└──Hello└──v1├──HELLO_SERVICE_GRPC_pb.d.ts├──HELLO_SERVICE_GRPC_pb.js├──HELLO_SERVICE_pb.d.ts└──HELLO_SERVICE_pb.js 6个目录，7个文件。</p><p> Congrats!  You’ve made it through Part 1 and you can use these modules in your upcoming server and client implementations.</p><p>恭喜你！您已经完成了第1部分，您可以在即将到来的服务器和客户端实现中使用这些模块。</p><p> In  Part 2 we will expand on what we’ve built and implement a Node.js gRPC server in TypeScript.</p><p>在第2部分中，我们将详细介绍我们构建的内容，并用TypeScript实现一个Node.js GRPC服务器。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://slavovojacek.medium.com/grpc-on-node-js-with-buf-and-typescript-part-1-5aad61bab03b">https://slavovojacek.medium.com/grpc-on-node-js-with-buf-and-typescript-part-1-5aad61bab03b</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/buf/">#buf</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>