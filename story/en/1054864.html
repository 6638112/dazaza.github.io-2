<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>你可以用cmake处理钻石 You can handle The Diamond with CMake</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">You can handle The Diamond with CMake<br/>你可以用cmake处理钻石 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-28 18:53:57</div><div class="page_narrow text-break page_content"><p>CMake is a conservative and popular build system for C++,thus the first choice if you look for boring technology.Yet, it does not scale well to large projectsbecause of dependency management.This is about the classic &#34;diamond&#34; shape:</p><p>CMake是一个保守和流行的C ++的构建系统，因此如果您寻找无聊技术，则首选.EET，它对依赖管理的大型项目没有效果很好。这是关于经典＆＃34;钻石＆＃34;形状：</p><p>  By &#34;large scale project&#34;, I&#39;m talking about multiple teamsand even more components such that you cannot structure it as a tree.Instead, it makes more sense to have a flat directory structurewhere you place components side by side.Dependencies between components will quickly grow into all kind of shapes(although you should really avoid cycles)and among them there will sooner or later be a diamond.</p><p>  by＆＃34;大规模项目＆＃34;我谈论多个队伍和＃34; m更多组件，使您无法将其构建为树。在您放置组件方面的平面目录结构，它更有意义逐渐。组件之间的依赖性将迅速生长成各种形状（尽管您应该真正避免周期），其中包括钻石迟早。</p><p> To decouple the components,we would like to build and test each of them independently,so each gets a  CMakeLists.txt.However, we still need a global one at the rootso each of the subdirectories can find its dependencies.</p><p> 要将组件解耦，我们希望独立构建和测试它们中的每一个，因此每个都获取CMAKELISTS.TXT.WEVER，我们仍然需要一个在root的全局，每个子目录都可以找到其依赖项。</p><p>  This need for the root file is annoying.It needs to parse all  CMakeLists.txt files for configuration.</p><p>  对根文件的需求是令人作呕的。它需要解析所有CMAKELIST.TXT文件以进行配置。</p><p> Instead, I would prefer to enter a component directory and build there.Can CMake do this?</p><p> 相反，我宁愿进入一个组件目录并在那里建立.CAN CMake这样做？</p><p> CMake has two mechanisms for dependencies.First, there is  find_package.The intention here is to detect package available on your systemand configure the build accordingly.It comes in a &#34;Module&#34; and a &#34;Config&#34; mode but the distinction is not relevant here.Neither are useful here because they assume a prebuilt library.CMake will not build a dependency through  find_package.</p><p> CMake有两个依赖性机制。首先，存在find_package。这里的意图是为了检测系统上可用的包和相应地配置构建。在a＆＃34;模块＆＃34;和一个＆＃34; config＆＃34;模式但是这里的区别在这里不相关。它们在这里非常有用，因为它们假设一个预构建的库.Camake不会通过find_package构建依赖项。</p><p> The alternative is  add_subdirectory.Just from its name, you see its intention is about a directory  tree.The root  CMakeLists.txt uses it to find the component  CMakeLists.txt.If you try to target a &#34;non-sub&#34; directory, it will show an error message:</p><p> 替代方案是add_subdirectory.just从它的名字中看到它的意图是关于一个目录树。根cmakelists.txt使用它来查找组件cmakelists.txt.if您尝试瞄准A＆＃34;非子＆＃34 ;目录，它将显示一条错误消息： </p><p> CMake Error at CMakeLists.txt:8 (add_subdirectory): add_subdirectory not given a binary directory but the given source directory &#34;../A&#34; is not a subdirectory of &#34;root&#34;. When specifying an out-of-tree source a binary directory must be explicitly specified.</p><p>cmakelists.txt的cmake误差：8（add_subdirectory）：add_subdirectory没有给出二进制目录，但给定的源目录＆＃34; ../ a＆＃34;不是＆＃34的子目录; root＆＃34;当指定树源外源时，必须明确指定二进制目录。</p><p> Well, there is a second parameter for  add_subdirectory to make it work.Since CMake supports out of tree builds,it uses the second parameter to locate where the out-of-tree buildfor the dependency shall be.Let&#39;s assume you create a  build folder in A,the second parameter for dependency base is  sub/base,and you run  cmake .. in there.CMake creates  CMakeCache.txt filesand here it would create one for A and one for its dependency:</p><p> 嗯，有一个add_subdirectory的第二个参数来使它工作.Since cmake支持树构建，它使用第二个参数来定位依赖于依赖的树外构建。 a中的构建文件夹，依赖依赖性基础的第二个参数是sub / base，并且您运行cmake ..在其中.Cmake在此处创建Cmakecache.txt filesand它将为其依赖创建一个，并且可以为其依赖创建一个</p><p>   Since every component creates its own sub build folder,this happens recursively such that base will exist twice.However, CMake has clever magic that inside  sub/Bit does not build its own  base.Instead it builds in  sub/A and reuses the targets there.</p><p>   由于每个组件都会创建自己的子构建文件夹，这会递归地发生，因此基础将存在两次。然而，CMake具有巧妙的魔法，在子/位内部没有构建自己的base.Instead它在sub / a中构建并在那里重用目标并重新使用目标。</p><p> The problem is that CMake complains about duplicate variablesas it parses  base/CMakeLists.txt twice.To avoid that we need  include guardsas in C header files.</p><p> 问题是CMake抱怨重复的variableas，它会解析Base / Cmakelists.txt两次。避免我们需要在C头文件中包含GuardSAS。</p><p>  A problem you might not notice initially is that CMake has no namespacing.This means it gets littered with pre- or postfixes like  ${PROJECT_NAME}:</p><p>  最初可能不会注意到的问题是CMake没有命名方式。这意味着它与$ {project_name}（如{project_name}）类似的预混物乱丢了垃圾</p><p>  Now the build succeeds.You can build from each componentand it builds only dependencies as necessary.We need no root  CMakeLists.txt.Not elegant but useable.</p><p>  现在构建成功。您可以从每个组件构建它，它只能根据需要构建依赖关系。我们不需要根cmakelists.txt.not优雅但可用。</p><p> At least if your dependencies are not that deepor you don&#39;t try to build on Windows with its limited path length.</p><p> 至少如果你的依赖关系不是那么深入你不要尝试在Windows上建立有限的路径长度。 </p><p> Remarkably the solutions seem to map to C solutions.So if you design a build system,it makes sense to considerhow modern languages solved the C problems more cleanly.</p><p>显着的解决方案似乎映射到C solutions.so如果您设计构建系统，则考虑现代语言可以更干净地解决C问题是有意义的。</p><p>  Build systems which mimic CMake, like Meson or xmake, are similar.The primary purpose is to configure the build according to external dependenciesbut for large projects we care about the internal dependencies.</p><p>  构建模仿CMake，如Meson或Xmake的系统。主要目的是根据我们关心内部依赖项的大型项目的外部依赖性配置构建。</p><p> Bazel (and its clones Buck, Pants, and Please)is designed for this use case, so it looks more elegant there.Instead of specifying a directory name to build a dependency,Bazel reuses the folder relative to the workspace (often the repo).This explains why  dependencies are specified with their whole path,like  //component/A:A.Within the same file, the target name  :A is sufficientso here you see the benefits of namespaces.</p><p> Bazel（及其克隆克隆，裤子和裤子）是为此用例而设计的，所以它看起来更优雅。虽然指定要构建依赖项的目录名，Bazel相对于工作空间（通常是回购）重用文件夹（通常是回购）这解释了为什么依赖于依赖关系是用它们的整条路径指定的，如//component/a:a.within同一个文件，目标名称：a是sufficienceo在这里，您可以看到命名空间的好处。</p><p> A more esoteric build system like  redoachieves our use case herebecause it is not burdened by complex features like out-of-tree builds.Its simplicity means that users have to build the more complex features on top.</p><p> 一个更靠的构建系统，如此，因为它是不受树木外构造的复杂功能的负担.its的简单意味着用户必须在顶部构建更复杂的功能。</p><p>   Related posts: Pondering Amazon&#39;s Manyrepo Build Systemshows how Amazon went all-in on packages instead. The Three Owners of an Interfacedescribes how  base packages could appear.</p><p>   相关帖子：思考亚马逊＆＃39; s的manyRepo构建系统表格亚马逊如何在包上全押。 Interfacedescribes的三个所有者如何出现碱包。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://beza1e1.tuxen.de/cmake_diamond.html">http://beza1e1.tuxen.de/cmake_diamond.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/处理/">#处理</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/diamond/">#diamond</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/构建/">#构建</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>