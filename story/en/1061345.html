<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>调试构建的2x-3x性能改进 2x-3x Performance Improvements for Debug Builds</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">2x-3x Performance Improvements for Debug Builds<br/>调试构建的2x-3x性能改进 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-08 22:45:50</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/397c3af5ab8a50dffe568f3fb6acbc45.png"><img src="http://img2.diglog.com/img/2021/5/397c3af5ab8a50dffe568f3fb6acbc45.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>We have made substantial runtime performance improvements in the x86/x64 C++ compiler for Visual Studio’s default debug configuration. For   Visual Studio 2019  version 16.10 Preview 2 , we measure 2x – 3x speedup for programs compiled in debug mode. These improvements come from reducing the overhead introduced by runtime checks (/RTCs) which are enabled by default.</p><p>我们在Visual Studio的默认调试配置中对X86 / X64 C ++编译器进行了大量的运行时性能改进。对于Visual Studio 2019年版本16.10预览2，我们测量2x  -  3x加速，用于在调试模式下编译的程序。这些改进来自减少运行时检查（/ RTC）引入的开销，默认情况下启用。</p><p>  When you compile your code in debug configuration in Visual Studio, there are some flags that are passed to the C++ compiler by default. Most relevant to this blog post are   /RTC1 ,   /JMC  and   /ZI .</p><p>  在Visual Studio中的Debug配置中编译代码时，默认情况下有一些标志传递给C ++编译器。与此博客文章最相关的是/ rtc1，/ jmc和/ zi。</p><p> While all of these flags add useful debugging functionality, their interactions, particularly when /RTC1 is involved, add significant overhead. In this release, we removed the unnecessary overhead while making sure they keep helping you find bugs and make your debugging experience smoother.</p><p> 虽然所有这些标志都添加了有用的调试功能，但它们的交互，特别是当涉及时，增加了大量的开销。在此版本中，我们删除了不必要的开销，同时确保他们继续帮助您找到错误并使您的调试体验更顺畅。</p><p>   and  the x64 assembly generated by the 16.9 compiler when compiled with /RTC1 /JMC /ZI ( Godbolt link):</p><p>   在使用/ rtc1 / jmc / zi（godbolt链接）编译时由16.9编译器生成的x64组件：</p><p> 1 int foo(void) PROC                  2 $LN3:3         push rbp4         push rdi5         sub rsp, 232                ; extra space allocated due to /ZI, /JMC6         lea rbp, QWORD PTR [rsp+32]7         mov rdi, rsp8        mov ecx, 58                 ; (= x)9         mov eax, -858993460         ; 0xCCCCCCCC10         rep stosd                   ; write 0xCC on stack for x DWORDs11         lea rcx, OFFSET FLAT:__977E49D0_example@cpp12         ; call due to /JMC13         call __CheckForDebuggerJustMyCode14        mov eax, 3215         lea rsp, QWORD PTR [rbp+200]16         pop rdi17         pop rbp18         ret 019 int foo(void) ENDP</p><p> 1 int foo（void）proc2 $ ln3：3推RBP.4推RDI.5子RSP，232;由于/ zi，/ jmc而分配的额外空间6 Lea RBP，QWORD PTR [RSP + 32]7 MOV RDI，RSP8 MOV ECX，58; （= x）9 MOV EAX，-858993460; 0xccccccc.10 Rep Stosd;在堆栈上写0xcc for x dwords11 Lea RCX，偏移平：__ 977E49D0_EXAMPLE @ CPP12;由于/ JMC而致电13致电__CheckFordebeBuggerJustmycode.14 mov eax，3215 Lea RSP，QWORD PTR [RBP + 200]16流行rdi.17流行rbp.18 RET 0.19 int foo（void）endp</p><p> In the assembly shown above, the /JMC and /ZI flags add a total of 232 additional bytes on the stack (line 5). This stack space is not always necessary. When combined with the /RTC1 flag, which initializes the allocated stack space (line 10), it consumes a lot of CPU cycles. In this specific example, even though the stack space we allocated is necessary for proper functioning of /JMC and /ZI, its initialization is not. We can prove at compile time that these checks are unnecessary. There are plenty of such functions in any real-world C++ codebase, and that’s where the performance benefit comes from.</p><p> 在上面所示的组件中，/ JMC和/ ZI标志在堆叠上添加了总共232个附加字节（第5行）。此堆栈空间并不总是必要的。与初始化分配的堆栈空间（第10行）初始化的rtc1标志（第10行）时，它会消耗大量的CPU周期。在该具体示例中，即使我们分配的堆栈空间是适当运行/ JMC和/ ZI的正常运行所必需的，其初始化不是。我们可以在编译时证明这些检查是不必要的。任何现实世界C ++码库中有很多这样的功能，那就是绩效效益来自的。</p><p> Keep reading to get a deeper dive into each of these flags, their interactions with /RTC1, and how we avoid its unnecessary overhead.</p><p> 继续阅读以获得深度潜入这些标志，他们与RTC1的互动，以及我们如何避免其不必要的开销。 </p><p>  Using   /RTC1  flag is equivalent to using both /RTCs and /RTCu flags. /RTCs initializes the stack frame of functions by 0xCC to do various runtime checks namely, detecting uninitialized local variables, detecting array overrun and underruns, and stack pointer verification (for x86). You can see the code bloat with /RTCs   here .</p><p>使用/ RTC1标志等同于使用两个/ RTC和/ RTCU标志。 / RCS将函数的堆栈帧初始化0xcc才能进行各种运行时检查，即检测未初始化的局部变量，检测阵列溢出和undruns，以及堆栈指针验证（对于x86）。您可以在此处看到使用/ RTC的代码膨胀。</p><p> As seen in the above assembly code (line 10), the    rep stosd  instruction, introduced by /RTCs, is the main reason for the slowdown. The situation is exacerbated when /RTCs (or /RTC1) is used in conjunction with /JMC, /ZI, or both.</p><p> 如上面的汇编代码（第10行）所示，由/ RTC引入的REP STOSD指令是减速的主要原因。当/ RTC（或/ RTC1）结合/ JMC，/ ZI或两者时，情况加剧了情况。</p><p>  /JMC  stands for   Just My Code Debugging  functionality ,  and during debugging, it automatically skips over functions that are not written by you (such as framework, library, and other non-user code). It works by inserting a function call in the prologue that calls into the runtime library. This helps the debugger to distinguish between user and non-user code. The problem here is that inserting a function call into the prologue of every function in your project means that there are no leaf functions anymore in your whole project. If the function doesn’t need any stack frame originally, now it will, because as per   AMD64 ABI for Windows platforms , we need to have at least four stack slots available for function parameters (called  P  aram Home area ). This means all the functions that were not being initialized earlier by /RTCs, because they were leaf functions and had no stack frame, will now be initialized. It’s normal to have lots and lots of leaf functions in your program ,  especially if you are using a heavily templated code library like C++ STL. /JMC will happily eat some of your CPU cycles in this case. This doesn’t apply for x86 (32 bit) because we don’t have any param home area there. You can see the effects of /JMC   here .</p><p>  / JMC代表我的代码调试功能，并且在调试期间，它会自动跳过您未写入的函数（例如框架，库和其他非用户代码）。它通过在调用进入运行时库中的序幕中插入函数调用来工作。这有助于调试器区分用户和非用户代码。这里的问题在于将函数调用插入项目中的每个函数的序幕意味着整个项目中没有叶子函数。如果函数最初不需要任何堆栈帧，现在它将是，因为根据适用于Windows平台的AMD64 ABI，我们需要至少有四个可用于功能参数的堆栈插槽（称为P ARAM Home Area）。这意味着所有未在/ RTC初始化的函数，因为它们是叶函数并没有堆栈帧，现在将初始化。在您的程序中有很多和大量的叶子函数是正常的，特别是如果您使用像C ++ STL这样的重型模糊代码库。 / JMC在这种情况下会愉快地吃一些CPU周期。这不适用于x86（32位），因为我们没有任何参数家庭区域。您可以在此处看到/ JMC的影响。</p><p>  The next interaction we are going to talk about is with /ZI. It enables your code for   Edit and Continue  support, which means you don’t need to recompile the whole program during debugging for small changes.</p><p>  我们将谈论的下一个互动是与/ zi。它使您的编辑和继续支持代码，这意味着您不需要在调试过程中重新编译整个程序以进行小型更改。</p><p> In order to add such support, we add some padding bytes to the stack (the actual number of padding bytes depends on how big a function is). This way ,  all the new variables you add during your debugging session can be allocated on the padding area without changing the total stack frame size, and you can continue your debugging without having to recompile your code.  See   here  how enabling this flag adds an extra 64 bytes to the generated code.</p><p> 为了添加此类支持，我们将一些填充字节添加到堆栈（填充字节的实际数量取决于功能有多大）。这样，您可以在调试会话期间添加的所有新变量都可以在填充区域分配，而无需更改总堆栈帧大小，并且您可以在不必重新编译代码的情况下继续调试。请参阅此处启用此标志为生成的代码添加额外的64个字节。</p><p> As you may have guessed, more stack area means more things to initialize by /RTCs, leading to more overhead.</p><p> 正如您可能已经猜到的那样，更多的堆栈区域意味着更多的东西以初始化/ RTC初始化，导致更多的开销。</p><p>  The root of all these problems is unnecessary initialization. Do we really need to initialize the stack area every time? No. One can safely prove within the compiler when stack initialization is really needed. For example, you need it when there is at least one address-taken variable, an array declared in your function or uninitialized variables. For every other case, we can safely skip over the initialization, as we are not going to find anything useful through runtime checks anyway.</p><p>  所有这些问题的根源是不必要的初始化。我们是否真的需要每次初始化堆栈区域？在真正需要堆栈初始化时，可以安全地在编译器中证明。例如，当存在至少一个地址拍摄的变量时需要它，在函数或未初始化的变量中声明的数组。对于每种情况，我们可以安全地跳过初始化，因为我们无论如何我们都不会发现通过运行时检查有用。 </p><p> The situation gets a bit more complicated when you compile with edit-and-continue because now you may add uninitialized variables in the debugging session that can only be detected if we initialize the stack area. And we may not have done that. To solve this problem, we included the necessary bits in debugging info and exposed it via  Debug Interface Access SDK. This information tells the debugger where the padding area introduced by /ZI   starts  and   ends . It also tells the debugger if the function   needed any stack initialization . If so, the debugger then unconditionally initializes the stack area in this memory range for the functions that you have edited during your debugging session. The new variables are always allocated on top of this initialized area and our runtime checks can now detect if your newly added code is safe or not.</p><p>当您使用编辑和继续编译时，情况会变得更加复杂，因为现在可以在调试会话中添加未初始化的变量，只有在初始化堆栈区域时才可以检测到的调试会话中。我们可能没有这样做。为了解决这个问题，我们在调试信息中包含必要的比特，并通过调试接口访问SDK公开它。此信息讲述了调试器，其中由/ zi开始和结束引入的填充区域。如果函数需要任何堆栈初始化，它还告诉调试器。如果是这样，则调试器然后无条件地初始化此内存范围内的堆栈区域，以获取在调试会话期间编辑的函数。新变量始终在此初始化区域的顶部分配，我们的运行时检查现在可以检测到新添加的代码是否安全。</p><p>  We compiled following projects in default debug configuration and then used the generated executables to run tests. We noticed 2x – 3x improvements in all the projects we tried. More STL-heavy projects may see larger improvements. Let us know in the comments any improvements you noticed in your projects. Project 1 and   Project 2  are customer provided samples.</p><p>  我们在默认调试配置中编译了以下项目，然后使用生成的可执行文件运行测试。我们注意到我们尝试的所有项目中的2x  -  3x改进。更多的STL沉重的项目可能会看到更大的改进。让我们在评论中知道您在项目中注意到的任何改进。项目1和项目2是客户提供的样品。</p><p>    We hope this speedup makes your debugging workflow efficient and enjoyable. We are continuously listening to your feedback and working towards improving your inner loop experience. We’d love to hear about your experience in the comments below. You can also get in touch with us at   Developer Community , email (  visualcpp@microsoft.com ), and Twitter (  @VisualC ).</p><p>    我们希望此加速使您的调试工作流程高效和愉快。我们不断聆听您的反馈并致力于提高内部循环体验。我们很乐意听到您在下面评价中的经验。您还可以在开发人员社区，电子邮件（VisualCpp@microsoft.com）和推特（@visualc）联系。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://devblogs.microsoft.com/cppblog/2x-3x-performance-improvements-for-debug-builds/">https://devblogs.microsoft.com/cppblog/2x-3x-performance-improvements-for-debug-builds/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/调试/">#调试</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/初始化/">#初始化</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>