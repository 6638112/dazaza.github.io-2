<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我编写JSON-REST API的演变 My evolution writing JSON-REST APIs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">My evolution writing JSON-REST APIs<br/>我编写JSON-REST API的演变 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-15 05:43:37</div><div class="page_narrow text-break page_content"><p>I&#39;ve been writing JSON-REST APIs in Python for a number of years, and over that time I&#39;ve found the tooling has greatly improved. To show you how you can benefit I&#39;m going to show you how I&#39;ve evolved. However, if you want to skip to the tooling I use today take a look at  Quart-Schema.</p><p>我已经用Python编写JSON-REST API多年了，在那段时间里，我发现工具有了很大的改进。为了向您展示如何使我受益，我将向您展示我如何发展。但是，如果您想跳到我今天使用的工具，请看一下Quart-Schema。</p><p>  Writing JSON-REST APIs in Python using Flask/Quart has always been pleasent. Yet communicating the API structure (routes, data, etc) to third parties and to my future self has not been. It is also difficult to guarantee that the API works as the documentation says it does. This has resulted in isses, bugs and misuse, in production I&#39;d love to have avoided.</p><p>  使用Flask / Quart用Python编写JSON-REST API一直很高兴。尚未将API结构（路线，数据等）传达给第三方以及我自己的未来。很难保证API能够像文档所述那样工作。这导致在生产中我不得不避免的问题，错误和滥用。</p><p>          def  (): data = request.get_json() todo_id = create_todo(data[ &#34;task&#34;], data[ &#34;due&#34;]) todo = { &#34;id&#34;: todo_id,  &#34;task&#34;: data[ &#34;task&#34;],  &#34;due&#34;: data[ &#34;due&#34;]}  return jsonify(todo),  201</p><p>          def（）：data = request.get_json（）todo_id = create_todo（data [＆＃34; task＆＃34;]，data [＆＃34; due＆＃34;]）todo = {＆＃34; id＆＃34; ：todo_id，＆＃34; task＆＃34 ;：数据[＆＃34; task＆＃34;]，＆＃34; due＆＃34 ;：数据[＆＃34; due＆＃34;]}返回jsonify（todo） ，201</p><p>  which works very nicely, but meet none of my aims. Both myself and third party user would have to read the code to understand what is sent and returned by the API.</p><p>  效果很好，但没有达到我的目标。本人和第三方用户都必须阅读代码以了解API发送和返回的内容。</p><p>  It also does not help to know when the wrong data has been sent. For example  due should be a date but if it isn&#39;t the  create_todo function will raise a  ValueError resulting in the API returning a 500 response. It should return a 400 response so that the third party and I can tell that it is an error with the data rather than a server or programming issue.</p><p>  这也无助于知道何时发送了错误的数据。例如，到期应为日期，但如果不是，则create_todo函数将引发ValueError，导致API返回500响应。它应该返回400响应，以便第三方和我可以知道这是数据错误，而不是服务器或编程问题。</p><p>    In an attempt to solve the documentation problem experienced with the simple Flask setup I tried the  sphinx autohttp extensions,</p><p>    为了解决简单的Flask设置遇到的文档问题，我尝试了sphinx autohttp扩展，</p><p>  def  ():  &#34;&#34;&#34;Create a TODO task. .. :quickref: Create a TODO. :reqheader Accept: application/json :&lt;json string task: task description :&lt;json string due: todo due date :&gt;json int id: todo unique identifier :&gt;json string task: task description :&gt;json string due: todo due date :resheader Content-Type: application/json :status 201: post created &#34;&#34;&#34; data = request.get_json() todo_id = create_todo(data[ &#34;task&#34;], data[ &#34;due&#34;]) todo = { &#34;id&#34;: todo_id,  &#34;task&#34;: data[ &#34;task&#34;],  &#34;due&#34;: data[ &#34;due&#34;]}  return jsonify(todo),  201</p><p>  def（）：＆＃34;＆＃34;＆＃34;创建TODO任务。 ..：quickref：创建一个待办事项。 ：reqheader接受：application / json：＆lt; json字符串任务：任务描述：＆lt; json字符串到期：todo截止日期：＆gt; json int id：todo唯一标识符：＆gt; json字符串task：任务描述：＆gt; json字符串截止日期：待办事项截止日期：resheader内容类型：application / json：状态201：创建的帖子＆＃34;＆＃34;＆＃34; data = request.get_json（）todo_id = create_todo（data [＆＃34; task＆＃34;]，data [＆＃34; due＆＃34;]）todo = {＆＃34; id＆＃34 ;: todo_id，＆ ＃34; task＆＃34 ;: data [＆＃34; task＆＃34;]，＆＃34; due＆＃34 ;: data [＆＃34; due＆＃34;]}返回jsonify（todo），201 </p><p>  which enables documentation to be created by manually specifying the data structures in the docstring.</p><p>通过手动指定文档字符串中的数据结构，可以创建文档。</p><p>  Whilst this helps with the documentation it has the same issues as the simpler Flask example, in that it doesn&#39;t validate the data sent to the route, nor the data returned. It also doesn&#39;t help with any linters, for example a simple typo like  data[&#34;duo&#34;] would only raise an error during testing, or worse in production.</p><p>  尽管这对文档有帮助，但它与简单的Flask示例有相同的问题，因为它不验证发送到路由的数据，也不验证返回的数据。它还对任何短毛绒都无济于事，例如，像data [＆＃34; duo＆＃34;]之类的简单错字只会在测试过程中产生错误，或者在生产中变得更糟。</p><p>  The bigger issue though, is writing the docstring documentation as it is time consuming, boring work that I (and my colleagues) would forget to do. Over time this lead to the documentation being wrong leading to distrust and lack of use.</p><p>  但是，更大的问题是编写文档字符串文档，因为它很耗时，而且我（和我的同事）会忘记做无聊的工作。随着时间的流逝，这会导致文档错误，从而导致不信任和缺乏使用。</p><p>  I eventually stopped using this technique and reverted to the simpler example as this documentation ended up actively misleading. It also became clear that the winning documentation standard was OpenAPI, rather than sphinx documentation.</p><p>  我最终停止使用此技术，并返回到更简单的示例，因为此文档最终导致了误导。还很清楚，获胜的文档标准是OpenAPI，而不是sphinx文档。</p><p>    It was around this time in that I switched from writing APIs in Flask to writing them in  Quart. The snippets onwards in this article will now assume Quart, but the only difference is the use of async/await keywords, you can remove them to get a Flask equivalent.</p><p>    大约在这个时候，我从用Flask编写API转向了用Quart编写API。现在，本文中的片段将采用Quart，但唯一的区别是使用了async / await关键字，您可以删除它们以获得Flask等效项。</p><p>  I wrote Quart as I wanted to start using the  async  await keywords and libraries. You can remove  async,  await from the examples to get a Flask equivalent.</p><p>  我写Quart的时候就想开始使用async await关键字和库。您可以从示例中删除异步，等待以获取Flask等效项。</p><p>    The data sent and received in the APIs I write is formatted as JSON. This means a  JSONSchema could be used to describe the structure and used to validate that any data matches it. This allows me to write decorators that accept JSONSchemas to validate request and response data,</p><p>    我编写的API中发送和接收的数据格式为JSON。这意味着JSONSchema可用于描述结构，并用于验证任何数据与之匹配。这使我能够编写接受JSONSchema的装饰器，以验证请求和响应数据， </p><p>  from functools  import wraps from typing  import Any, Callable, Dict import fastjsonschema from quart  import abort, make_response, request  def  ( schema: Dict[ str, Any]) -&gt; Callable:  &#34;&#34;&#34;This validates the request JSON. If there is no JSON in the body, or the JSON doesn&#39;t validate this will trigger a 400 response. &#34;&#34;&#34; validator = fastjsonschema. compile(schema)   def  ( func: Callable) -&gt; Callable:   async   def  ( *args: Any, **kwargs: Any) -&gt; Any: data =  await request.get_json()  try: validator(data)  except fastjsonschema.JsonSchemaException: abort( 400)  else:  return  await func(*args, **kwargs)  return wrapper  return decorator  def  ( schemas: Dict[ int, Dict[ str, Any]]) -&gt; Callable:  &#34;&#34;&#34;This validates the response JSON. The schemas are keyed by status code. &#34;&#34;&#34; validators = { status: fastjsonschema. compile(schema)  for status, schema  in schemas.items() }   def  ( func: Callable) -&gt; Callable:   async   def  ( *args: Any, **kwargs: Any) -&gt; Any: result =  await func(*args, **kwargs) response =  await make_response(result)  if response.status_code  in validators: validators[response.status_code]( await response.get_json())  return response  return wrapper  return decorator</p><p>从functools import换行，从输入import Any，可调用，Dict导入，从quart导入中止，make_response，请求def（模式：Dict [str，Any]）-＆gt;可调用的：＆＃34;＆＃34;＆＃34;验证请求JSON。如果正文中没有JSON，或者JSON无法验证，则将触发400响应。 ＆＃34;＆＃34;＆＃34;验证程序= fastjsonschema。编译（schema）def（func：Callable）-＆gt;可调用的：异步def（* args：任何，** kwargs：任何）-＆gt;任意：数据=等待request.get_json（）尝试：验证器（数据）除了fastjsonschema.JsonSchemaException：中止（400）其他：返回等待函数（* args，** kwargs）返回包装器返回装饰器def（模式：Dict [ Dict [str，Any]]）->可调用的：＆＃34;＆＃34;＆＃34;验证响应JSON。架构由状态代码键控。 ＆＃34;＆＃34;＆＃34;验证程序= {状态：fastjsonschema。编译（schema）状态，schema中的schema.items（）} def（func：Callable）-＆gt;可调用的：异步def（* args：任何，** kwargs：任何）-＆gt;任意：result = await func（* args，** kwargs）response = await make_response（result），如果validator中的response.status_code：validators [response.status_code]（await response.get_json（））return response return wrapper return decorator</p><p>    {  &#34;type&#34;:  &#34;object&#34;,  &#34;properties&#34;: {  &#34;due&#34;: { &#34;type&#34;:  &#34;string&#34;,  &#34;format&#34;:  &#34;date&#34;},  &#34;task&#34;: { &#34;type&#34;:  &#34;string&#34;}, },  &#34;required&#34;: [ &#34;due&#34;,  &#34;task&#34;],  &#34;additionalProperties&#34;:  False, })  {  201: {  &#34;type&#34;:  &#34;object&#34;,  &#34;properties&#34;: {  &#34;due&#34;: { &#34;type&#34;:  &#34;string&#34;,  &#34;format&#34;:  &#34;date&#34;},  &#34;id&#34;: { &#34;type&#34;:  &#34;number&#34;},  &#34;task&#34;: { &#34;type&#34;:  &#34;string&#34;}, },  &#34;required&#34;: [ &#34;due&#34;,  &#34;id&#34;,  &#34;task&#34;],  &#34;additionalProperties&#34;:  False, }, }) async   def  (): data =  await request.get_json() todo_id = create_todo(data[ &#34;task&#34;], data[ &#34;due&#34;]) todo = { &#34;id&#34;: todo_id,  &#34;task&#34;: data[ &#34;task&#34;],  &#34;due&#34;: data[ &#34;due&#34;]}  return todo,  201</p><p>    {＆＃34; type＆＃34 ;:＆＃34; object＆＃34 ;,＆＃34; properties＆＃34 ;: {＆＃34; due＆＃34 ;: {＆＃34; type＆＃34 ;:＆＆ 34; string＆＃34 ;、＆＃34; format＆＃34 ;:＆＃34; date＆＃34;}，＆＃34; task＆＃34 ;: {＆＃34; type＆＃34 ;:＆＃34; string＆ ＃34;}，}，＆＃34;必需＆＃34;：[＆＃34; due＆＃34;，＆＃34; task＆＃34;]，＆＃34; additionalProperties＆＃34 ;： False，}）{ 201：{＆＃34; type＆＃34 ;:＆＃34; object＆＃34 ;,＆＃34; properties＆＃34 ;: {＆＃34; due＆＃34 ;: {＆＃34; type＆＃34 ;: ＆＃34; string＆＃34 ;、＆＃34; format＆＃34 ;:＆＃34; date＆＃34;}，＆＃34; id＆＃34 ;： {＆＃34; type＆＃34 ;：＆＃34 ; number＆＃34;}，＆＃34; task＆＃34 ;: {＆＃34; type＆＃34 ;:＆＃34; string＆＃34;}，}，＆＃34; required＆＃34 ;: [＆＃ 34; due＆＃34;，＆＃34; id＆＃34;，＆＃34; task＆＃34;]，＆＃34; additionalProperties＆＃34 ;： False，}，}）异步def（）：数据=等待请求.get_json（）todo_id = create_todo（data [＆＃34; task＆＃34;]，data [＆＃34; due＆＃34;]）todo = {＆＃34; id＆＃34 ;: todo_id，＆＃34; task＆＃34 ;: data [＆＃34; task＆＃34;]，＆＃34; due＆＃34 ;: data [＆＃34; due＆＃34;]}返回待办事项，201</p><p>  The JSONSchemas can then be used as the documentation either when developing or to create an openapi specification of the API for third parties.</p><p>  然后，在开发或为第三方创建API的openapi规范时，可以将JSONSchemas用作文档。</p><p>  This solves the validation and documentation problems, whilst ensuring that the documentation stays correct. It is however just as painful to write as the sphinx docstrings (although now it cannot be ignored). It also doesn&#39;t help linters understand what we are doing with the data.</p><p>  这解决了验证和文档编制问题，同时确保文档保持正确。但是，编写代码与狮身人面像文档字符串一样痛苦（尽管现在无法忽略）。这也没有帮助linters了解我们在处理数据。</p><p>    To gain help from the linting tools the data needs to be defined in a structure they understand. Conveniently Python 3.7 shipped dataclasses which we can use to define the structure and will enable IDEs and linters to alert me of any issues. By altering the decorator to  convert the dataclass to a JSONSchema allows a dataclass to be used instead,</p><p>    为了从整理工具中获得帮助，需要在他们理解的结构中定义数据。方便地，Python 3.7附带了数据类，我们可以使用它们来定义结构，并使IDE和linter可以向我发出任何问题的警报。通过更改装饰器以将数据类转换为JSONSchema，可以改为使用数据类，</p><p>  class  : due: date task:  str   class  ( TodoData):  id:  int    async   def  () -&gt; Todo: data =  await request.get_json() todo_data = TodoData(**data) todo_id = create_todo(todo_data.task, todo_data.due)  return Todo( id=todo_id, task=todo_data.task, due=todo_data.due),  201</p><p>  类别：到期日：日期任务：str类别（TodoData）：id：int异步def（）-> Todo：数据=等待请求。get_json（）todo_data = TodoData（** data）todo_id = create_todo（todo_data.task，todo_data.due）return Todo（id = todo_id，task = todo_data.task，due = todo_data.due）， 201</p><p>  which is actually quite pleasant code to write and actually makes it quicker (with the IDE autocompletion) than any of the previous examples.</p><p>  与以前的任何示例相比，这实际上是令人愉悦的代码编写，并使其（借助IDE自动完成功能）更快。 </p><p>  I have been experimenting with the code to make the dataclass decorators work for a while, and it isn&#39;t the easiest. Thankfully I recently came across  pydantic&#39;s dataclasses which validate the arguments, and can generate schemas for documentation.</p><p>我一直在尝试使用代码来使数据类装饰器工作一段时间，但这并不是最简单的。值得庆幸的是，我最近遇到了pydantic的数据类，这些数据类可验证参数并可以生成文档的架构。</p><p>    Quart-Schema is a Quart extension that provides the validation decorators and auto-generated documentation. The example in this article in full is,</p><p>    Quart-Schema是Quart扩展，提供了验证修饰符和自动生成的文档。全文中的示例是，</p><p>  from datetime  import date from pydantic.dataclasses  import dataclass from quart  import Quart from quart_schema  import QuartSchema, validate_request, validate_responseapp = Quart(__name__)QuartSchema(app)   class  : due: date task:  str   class  ( TodoData):  id:  int    async   def  ( data: TodoData) -&gt; Todo: todo =  await create_todo(data)  return todo,  201</p><p>  从datetime从pydantic.dataclasses导入日期从quart导入dataclass从quart_schema导入Quart导入QuartSchema，validate_request，validate_responseapp = Quart（__ name __）QuartSchema（app）class：due：date task：str class（TodoData）：id：int async def（数据：TodoData）->待办事项：待办事项=等待create_todo（data）返回待办事项，201</p><p>    I think, with Quart-Schema, that I&#39;ve finally achieved all my initial aims in a form that is very clear and simple to write. This has only been possible with the async/await, type hinting, and dataclass improvements to Python made over the past few years.</p><p>    我认为，借助Quart-Schema，我终于以一种非常清晰且易于编写的形式实现了我的所有最初目标。这只有在过去几年中对async / await，类型提示和对Python的数据类改进后才可能实现。</p><p>  I&#39;d quite like to know what you think of this - I&#39;m on twitter  @pdgjones.</p><p>  我很想知道您对此的看法-我在Twitter @pdgjones上。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://pgjones.dev/blog/rest-api-evolution-2020/">https://pgjones.dev/blog/rest-api-evolution-2020/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/json/">#json</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/writing/">#writing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文档/">#文档</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>