<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>哪种编程语言耗电最少？</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">哪种编程语言耗电最少？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-18 18:44:54</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/32f000287cf37abdb097caa42fd9aa7e.png"><img src="http://img2.diglog.com/img/2020/10/32f000287cf37abdb097caa42fd9aa7e.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Last year a team of six researchers in Portugal from three different universities decided to investigate this question, ultimately releasing a paper titled “ Energy Efficiency Across Programming Languages.” They ran the solutions to 10 programming problems written in 27 different languages, while carefully monitoring how much electricity each one used — as well as its speed and memory usage.</p><p>去年，一个由来自三所不同大学的6名葡萄牙研究人员组成的团队决定研究这个问题，最终发表了一篇题为“跨编程语言的能源效率”的论文。他们运行了用27种不同语言编写的10个编程问题的解决方案，同时仔细监控每个问题的用电量-以及速度和内存使用情况。</p><p>  Specifically, they used 10 problems from the  Computer Language Benchmarks Game, a free software project for comparing performance which includes a standard set of simple algorithmic problems, as well as a framework for running tests. (It was formerly known as “The Great Computer Language Shootout.”) “This allowed us to obtain a comparable, representative, and extensive set of programs… along with the compilation/execution options, and compiler versions.”</p><p>具体地说，他们使用了计算机语言基准游戏(Computer Language Benchmark Game)中的10个问题，这是一个用于比较性能的免费软件项目，其中包括一组标准的简单算法问题，以及一个运行测试的框架。(它的前身是“伟大的计算机语言枪战”。)。“这使我们能够获得一套具有可比性、代表性和广泛性的程序…。以及编译/执行选项和编译器版本。“。</p><p> It was important to run a variety of benchmark tests because ultimately their results varied depending on which test was being performed. For example, overall the C language turned out to be the fastest and also the most energy efficient. But in the benchmark test which involved scanning a DNA database for a particular genetic sequence, Rust was the most energy-efficient — while C came in third.</p><p>运行各种基准测试很重要，因为最终它们的结果会根据执行的测试而有所不同。例如，总的来说，C语言被证明是最快的，也是最节能的。但在涉及扫描DNA数据库以寻找特定基因序列的基准测试中，铁锈是最节能的-而C排在第三位。</p><p> Yet even within that same test, the “best” language depends on what your criterion is. For that test C also turned out to be only the  second fastest language (again, placing behind Rust). But Rust dropped a full nine positions if the results were sorted by memory usage. And while Fortran was the second most energy efficient language for this test, it also dropped a full six positions when the results were instead sorted by  execution time.</p><p>然而，即使在同样的测试中，“最好”的语言也取决于你的标准是什么。在那次测试中，C语言也被证明只是第二快的语言(同样，排在Rust之后)。但如果根据内存使用情况对结果进行排序，拉斯特的排名整整下降了9位。虽然Fortran是这项测试的第二高能效语言，但当结果按执行时间排序时，它也下降了整整六位。</p><p>  The researchers note that they “strictly followed” the CLBG project’s guidelines about compiler versions and the best optimization flags. Power consumption was measured using a tool from Intel — the  Running Average Power Limit tool — with each program executed not just once, but 10 times, “to reduce the impact of cold starts and cache effects, and to be able to analyze the measurements’ consistency and avoid outliers.” (For this reason, they report that “the measured results are quite consistent.”) For added consistency, all of the tests were on a desktop running Linux Ubuntu Server 16.10 (kernel version 4.8.0-22-generic), with 16GB of RAM and a 3.20GHz Haswell Intel Core i5-4460 CPU.</p><p>研究人员指出，他们“严格遵循”CLBG项目关于编译器版本和最佳优化标志的指导方针。功耗是使用英特尔的一种工具-运行平均功率限制工具-进行测量的，每个程序不只执行一次，而是执行10次，“以减少冷启动和缓存影响的影响，并能够分析测量的一致性并避免异常值。”(出于这个原因，他们报告说“测量结果相当一致”。)。为了增加一致性，所有的测试都是在运行Linux Ubuntu Server 16.10(内核版本4.8.0-22-通用)的台式机上进行的，具有16 GB的RAM和3.20 GHz的Haswell Intel Corei5-4460 CPU。</p><p>  “Lisp, on average, consumes 2.27x more energy (131.34J) than C, while taking 2.44x more time to execute (4926.99ms), and 1.92x more memory (126.64Mb) needed when compared to Pascal.”</p><p>与Pascal相比，Lisp的平均能耗(131.34J)是C的2.27倍，执行时间(4926.99ms)是C的2.44倍，所需的内存(126.64MB)是Pascal的1.92倍。</p><p> They also compared the results from compiled languages versus interpreted languages (with a separate category for languages that run on virtual machines). And the paper also includes a separate comparison of the different programming paradigms — including both functional and imperative programming, plus object-oriented programming and scripting.</p><p>他们还比较了编译语言和解释语言的结果(对运行在虚拟机上的语言进行了单独的分类)。本文还对不同的编程范例进行了单独的比较-包括函数式编程和命令式编程，以及面向对象的编程和脚本。</p><p>  The paper took a hard look at the common assumption that a  faster program will always use less energy, pointing out that it’s not as simple as the law of physics that says E(nergy) = T(ime) x P(ower). This is partly because power isn’t expended at a consistent rate, the researchers note, suggesting that may be impacting the work of other researchers investigating whether a program’s running time affects its energy consumption. (“Conclusions regarding this issue diverge sometimes…”) In one of their benchmark tests, a Chapel program took 55 percent less time to execute than an equivalent program written in Pascal — and yet that Pascal program used 10 percent less energy.</p><p>这篇论文仔细研究了一个常见的假设，即速度更快的程序总是使用更少的能量，指出它并不像物理定律说的E(能量)=T(Ime)x P(Power)那么简单。研究人员指出，这在一定程度上是因为电力没有以一致的速度消耗，这表明这可能会影响其他研究人员调查程序的运行时间是否影响其能耗的工作。(“关于这个问题的结论有时会有分歧…”)。在他们的一项基准测试中，Chapel程序的执行时间比用Pascal语言编写的同等程序少55%-然而，Pascal程序使用的能源却少了10%。</p><p> So while there’s still a common belief that energy consumption goes down when programs run faster, the researchers state unequivocally that “a faster language is not always the most energy efficient.”</p><p>因此，尽管人们仍然普遍认为，当程序运行得更快时，能耗会降低，但研究人员毫不含糊地表示，“速度更快的语言并不总是最节能的。”</p><p> It can be a hard question to answer, since power consumption is affected by many factors (including the quality of the compiler and what libraries are used). But ultimately the researchers were even able to break down energy consumption based on whether it was being consumed by the CPU or DRAM — concluding that the majority of power (around 88 percent) was consumed by the CPU, on average, whether the benchmark program was compiled, interpreted, or run on a virtual machine.</p><p>这可能是一个很难回答的问题，因为功耗受到许多因素的影响(包括编译器的质量和使用的库)。但最终，研究人员甚至能够根据能耗是由CPU还是DRAM消耗来细分能耗-得出的结论是，大部分电量(约88%)平均由CPU消耗，无论基准程序是在虚拟机上编译、解释还是运行。</p><p> Interestingly, interpreted languages showed a slightly higher variation, with the CPU sometimes consuming as much as 92.90 percent of the power or as little as 81.57 percent.</p><p>有趣的是，口译语言显示出稍高的变化，CPU有时消耗高达92.90%的功率，或低至81.57%。</p><p> After studying their results, the researchers also concluded that the relationship between peak usage of DRAM and energy consumption “is almost non-existent.”</p><p>在研究了他们的结果后，研究人员还得出结论，DRAM的峰值使用和能源消耗之间的关系“几乎不存在”。</p><p> The research provides some more insights into the perennial question: is faster greener? Yes, it’s true that “the top five most energy-efficient languages keep their rank when they are sorted by execution time and with very small differences in both energy and time values.”</p><p>这项研究对这个长期存在的问题提供了更多的见解：更快的速度更环保吗？是的，确实“最节能的五种语言在按执行时间排序时保持了它们的排名，并且在能量和时间值上都有很小的差异。”</p><p> In fact, for nine out of 10 benchmark problems, the top score (for both speed and energy efficiency) came from one of the top three overall fastest and most energy-efficient languages — which didn’t surprise the researchers. “It is common knowledge that these top three languages (C, C++, and Rust) are known to be heavily optimized and efficient for execution performance, as our data also shows.”</p><p>事实上，对于十分之九的基准问题，最高分(速度和能效)来自总体速度最快、最节能的前三名语言之一-这并不让研究人员感到惊讶。众所周知，正如我们的数据所显示的那样，这三大语言(C、C++和Rust)在执行性能方面进行了大量优化和高效。</p><p> But you  don’t see the same order when you rank the other 24 languages by their run-time as you do when you rank them for energy efficiency. “Only four languages maintain the same energy and time rank (OCaml, Haskel, Racket, and Python), while the remainder are completely shuffled.”</p><p>但是，当您按照运行时对其他24种语言进行排名时，您看到的顺序与对它们进行能效排名时所看到的顺序不同。只有四种语言保持相同的能量和时间顺序(OCaml、Haskel、Sracket和Python)，其余语言则完全混乱。</p><p> And even on individual benchmark tests, there are cases where fast-performing languages are not the most energy efficient.</p><p>即使是在单独的基准测试中，也有快速执行的语言并不是最节能的情况。</p><p>  There were other interesting results. Compiled languages “tend to be” the most energy-efficient and fastest-running — and their paper can even quantify that difference with a number. “On average, compiled languages consumed 120J [joules] to execute the solutions, while for a virtual machine and interpreted languages this value was 576J and 2365J, respectively.”</p><p>还有其他有趣的结果。编译语言“往往”是最节能、运行速度最快的语言--他们的论文甚至可以用数字来量化这种差异。平均而言，编译语言执行解决方案消耗120J[焦耳]，而对于虚拟机和解释语言，此值分别为576J和2365J。</p><p> The researchers also applied the same precision when comparing execution times, concluding that on average, “compiled languages took 5103ms, virtual machine languages took 20623ms, and interpreted languages took 87614ms.”</p><p>研究人员在比较执行时间时也应用了同样的精确度，得出的结论是，“编译语言平均耗时5103毫秒，虚拟机语言耗时20623毫秒，解释语言耗时87614毫秒。”</p><p> Of the top five languages in both categories, four of them were compiled. (The exception? Java.)</p><p>在这两个类别的前五种语言中，有四种是编译的。(例外？Java。)。</p><p>  The five  slowest languages were all interpreted: Lua, Python, Perl, Ruby and Typescript. And the five languages which consumed the most energy were  also interpreted: Perl, Python, Ruby, JRuby, and Lua.</p><p>翻译速度最慢的五种语言都是：Lua、Python、Perl、Ruby和TypeScript。并解释了消耗能量最多的五种语言：Perl、Python、Ruby、JRuby和Lua。</p><p> But at the same time, when manipulating strings with regular expression, three of the five  most energy-efficient languages turn out to be interpreted languages (TypeScript, JavaScript, and PHP), “although they tend to be not very energy efficient in other scenarios.”</p><p>但与此同时，当使用正则表达式操作字符串时，五种最节能的语言中有三种是解释型语言(TypeScript、JavaScript和PHP)，“尽管它们在其他场景中往往不是很节能”。</p><p> Compiled languages also took the top five slots for least amount of memory space used.</p><p>编译语言也占据了使用的内存空间最少的前五个位置。</p><p>  “On average, the compiled languages needed 125Mb, the virtual machine languages needed 285Mb, and the interpreted needed 426Mb,” the researchers report. Meanwhile interpreted languages claimed four of the five  bottom spots, meaning they consumed the most memory space: JRuby, Dart, Lua, and Perl. (While Erlang is not an interpreted language, it would also appear in the bottom five, between Dart and Lua).</p><p>“平均而言，编译语言需要125MB，虚拟机语言需要285MB，解释语言需要426MB，”研究人员报告说。与此同时，解释型语言占据了五个垫底位置中的四个，这意味着它们消耗的内存空间最多：JRuby、Dart、Lua和Perl。(虽然Erlang不是一种解释型语言，但它也会出现在后五名中，介于Dart和Lua之间)。</p><p> “If sorted by their programming paradigm, the imperative languages needed 116Mb, the object-oriented 249Mb, the functional 251Mb, and finally the scripting needed 421Mb.”</p><p>如果按编程范例分类，命令式语言需要116Mb，面向对象的需要249Mb，功能性的需要251Mb，最后是脚本需要421Mb。</p><p> In fact, when comparing the different paradigms, imperative programming often came out on top. Its benchmark programs also used far less energy on average —  and ran much faster — than the benchmark programs for object-oriented, functional, and scripting paradigms.</p><p>事实上，在比较不同的范例时，命令式编程常常排在首位。与面向对象、函数式和脚本范型的基准程序相比，其基准程序的平均能耗也要低得多，运行速度也快得多。</p><p>  But there’s a lot of factors to consider. “It is clear that different programming paradigms and even languages within the same paradigm have a completely different impact on energy consumption, time, and memory,” the researchers write. Yet which one of those is most important will depend on your scenario. (Background tasks, for example, don’t always need the fastest run-time..)</p><p>但有很多因素需要考虑。“很明显，不同的编程范例，甚至同一范例中的语言，对能耗、时间和内存都有完全不同的影响，”研究人员写道。然而，其中哪一个最重要将取决于您的方案。(例如，后台任务并不总是需要最快的运行时间。)。</p><p> And some applications require the consideration of two factors — for example, energy usage and execution time. In that case, “C is the best solution, since it is dominant in both single objectives,” the researchers write. If you’re trying to save time while using less memory, C, Pascal, and Go “are equivalent” — and the same is true if you’re watching all  three variables (time, energy use, and memory use). But if you’re just trying to save  energy while using less memory, your best choices are C or Pascal.</p><p>而且一些应用程序需要考虑两个因素，例如，能源使用和执行时间。在这种情况下，“C是最好的解决方案，因为它在两个单一目标中都占主导地位，”研究人员写道。如果您试图在使用较少内存的情况下节省时间，那么C、Pascal和Go“是等价的”-如果您观察所有三个变量(时间、能源使用和内存使用)，情况也是如此。但是，如果您只是想在节省能源的同时使用较少的内存，那么您的最佳选择是C或Pascal。</p><p> At the end of the paper, the researchers add that for further study, they’d like to examine whether total memory use  over time correlates better with energy consumed.</p><p>在论文的最后，研究人员补充说，为了进一步研究，他们希望检查随着时间的推移，总内存使用量是否与消耗的能量有更好的相关性。</p><p> They’re  sharing their data online, suggesting it makes it easier for future researchers to compare, for example, .NET languages or JVM languages. For developers working with mobile applications, Internet-of-Things systems, or other apps drawing from limited power supplies, power consumption is a major concern.</p><p>他们在网上分享他们的数据，这表明这使得未来的研究人员更容易进行比较，例如.NET语言或JVM语言。对于使用移动应用程序、物联网系统或其他使用有限电源的应用程序的开发人员来说，功耗是一个主要问题。</p><p> But in the end, the study may also leave programmers with the thing they hate most: ambiguity. The researchers report that if you’re looking for a single-best programming language, “this question does not have a concrete and ultimate answer.</p><p>但最终，这项研究可能也会给程序员留下他们最讨厌的东西：模棱两可。研究人员报告说，如果你在寻找一种最好的编程语言，“这个问题没有具体和最终的答案。</p><p> “Although the most energy efficient language in each benchmark is almost always the fastest one, the fact is that there is no language which is consistently better than the others,” the researchers conclude. “The situation on which a language is going to be used is a core aspect to determine if that language is the most energy-efficient option.”</p><p>研究人员总结道：“虽然每个基准测试中能源效率最高的语言几乎总是最快的，但事实是没有哪种语言总是比其他语言更好。”“一种语言的使用情况是决定该语言是否是最节能的选择的核心方面。”</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://thenewstack.io/which-programming-languages-use-the-least-electricity/">https://thenewstack.io/which-programming-languages-use-the-least-electricity/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编程语言/">#编程语言</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/languages/">#languages</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>