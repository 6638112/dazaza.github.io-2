<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>DocWriter：将击键发送到Google Doc的打字机（2017） DocWriter: Typewriter that sends its keystrokes to a Google Doc (2017)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">DocWriter: Typewriter that sends its keystrokes to a Google Doc (2017)<br/>DocWriter：将击键发送到Google Doc的打字机（2017） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-29 10:05:09</div><div class="page_narrow text-break page_content"><p>For years I’ve wanted a writing machine that would combine the best parts of a typewriter and a word processor. After months of tinkering, my friend Ben Gross and I just finished building one. We call it the DocWriter. It’s a typewriter that sends its keystrokes in real time to a Google Doc.</p><p>多年来，我一直希望有一种能够将打字机和文字处理器的最佳部件结合在一起的书写机。经过几个月的修补，我的朋友本·格罗斯和我刚完成了一个。我们称它为DocWriter。这是一台打字机，可将其击键实时发送到Google文档。</p><p>  The beauty of a typewriter is that it propels you through a piece of writing. You can’t tinker with phrases, so you get used to laying down paragraphs. Your mind, relieved from the micromechanics of language, applies itself to structure, to the building of sections and scenes and arguments. When you’re done you end up with something  whole, even if it’s imperfect: a draft that reads from start to finish and that you can hold in your hands.</p><p>  打字机的优点在于可以推动您完成一段文字。您无法修改短语，因此习惯了放下段落。您的思想从语言的微力学中解脱出来，将自己应用于结构，部分，场景和论证的构建。完成后，即使不完美，您也会得到完整的结果：草稿从头到尾读起来，可以握在手中。</p><p> A word processor, by contrast, turns revision into a kind of play. This is true not just for the fine wordwork that comes right before publication, but for the big stuff, too, like when you want to move sections around, or see what a story looks like without a side character. Doing this kind of thing on a typewriter would be a nightmare — to say nothing of the simple fact that your words will have to be digitized at some point and it’s just not practical to scan them or type them up off a sheet of paper.</p><p> 相比之下，文字处理器将修订变成一种玩法。这不仅适用于出版前的精美文字，而且适用于大型内容，例如，当您要四处移动章节或查看没有副词的故事时。在打字机上做这种事情将是一场噩梦–更不用说一个简单的事实了，那就是您的单词必须在某个时候进行数字化，并且扫描它们或在一张纸上打字都不实际。</p><p> The idea behind the DocWriter is to be a bridge between these tools so that each serves its purpose: the typewriter, to create the building blocks of a piece of writing, and the word processor, to make the most of them.</p><p> DocWriter背后的想法是在这些工具之间架起一座桥梁，以便每种工具都能实现其目的：打字机（用于创建书写的基本组成部分）和文字处理器，以充分利用它们。</p><p>  The DocWriter is actually pretty simple: we took a Brother SX-4000 electronic typewriter and spied on its  keyboard switch matrix by soldering a few wires onto the main circuit board; we ran those to a Raspberry Pi 3, which runs a C program that reverse engineers the signals; we pipe this data over ssh to a computer program running in the cloud; that program maps the signals to keystrokes and runs a headless web browser that types the keys into a new Google Doc.</p><p>  DocWriter实际上非常简单：我们使用Brother SX-4000电子打字机，通过将几根导线焊接到主电路板上来监视其键盘开关矩阵。我们将它们运行到Raspberry Pi 3，该树运行的C程序对信号进行反向工程。我们通过ssh将这些数据通过管道传输到云中运行的计算机程序；该程序将信号映射到击键，并运行无头Web浏览器，将浏览器键入新的Google文档。</p><p>  From the user’s perspective, you’re just using a typewriter. The Raspberry Pi is hidden inside it (the blue box in the image above), and it draws power from the typewriter itself, so there’s no extra cord. When you turn on the typewriter, it boots the Pi, which connects itself to your WiFi network, and runs the program that listens for keystrokes and pipes them to the cloud. You know that the DocWriter is ready once you get an email from Google Docs saying that the machine has shared a new document with you.</p><p>  从用户的角度来看，您只是在使用打字机。 Raspberry Pi隐藏在其中（上图中的蓝色框），它从打字机本身获取动力，因此没有多余的电线。当您打开打字机时，它将启动Pi，Pi将自身连接到您的WiFi网络，并运行该程序以侦听击键并将其通过管道传输到云。您知道从Google Docs收到一封电子邮件，表明该计算机已与您共享新文档后，DocWriter已准备就绪。</p><p> We’re indebted to  numist, who turned the same model typewriter into a teletype using software much more sophisticated than ours. That work made our project seem doable, and gave us many clues about the kinds of problems we’d encounter along the way.</p><p> 我们感谢numist，他使用比我们更复杂的软件将同一型号的打字机变成了电传打字机。这项工作使我们的项目看起来可行，并且为我们提供了我们在此过程中会遇到的各种问题的许多线索。 </p><p> There were, indeed, many problems: we had a surprisingly hard time getting the case off the typewriter when we first bought it; by unlatching the keyboard, we inadvertently triggered a condition where the motor would endlessly grind up against the case, and nearly convinced ourselves we’d broken the machine; the early versions of our controller code erroneously piped data  to the typewriter, causing all kinds of weird behavior; we built the whole setup three times, first on an Arduino and then on a Raspberry Pi Zero, before settling on the Pi 3; we had a bad connection on a wire that caused some keys to fail; we wrote elaborate code to compensate for noise on the lines, before realizing that we could use pull-up resistors to more or less eliminate it entirely; we spent nearly a full day just installing a headless web browser that worked; and we had to rewrite our main control code about a dozen times.</p><p>确实存在许多问题：我们在首次购买时很难从打字机上取下机箱。通过松开键盘，我们无意间触发了一种条件，即电动机会不断地磨碎外壳，几乎使我们确信我们已经损坏了机器。我们的控制器代码的早期版本错误地将数据通过管道传输到打字机，从而导致各种奇怪的行为；我们先在Arduino上，然后在Raspberry Pi Zero上构建了三遍完整的设置，然后再安装到Pi 3上。我们的电线连接不良，导致某些键失效；在意识到可以使用上拉电阻或多或少完全消除噪声之前，我们编写了详尽的代码来补偿线路上的噪声。我们花了将近一整天的时间来安装一个无头的Web浏览器。而且我们不得不重写我们的主控制代码大约十二次。</p><p>  In the end, though, the setup is elegant: along with wires for power and ground, we had to solder just 16 connections onto the pins controlling the keyboard switch matrix on the typewriter’s circuit board. The rest is software, most of which does exactly what you’d expect. The hardest code to write was the controller to read the raw signals from the typewriter. But we got it down to something with nearly perfect behavior that’s also pretty minimal (especially when you ignore special cases for the Shift key):</p><p>  但最后，设置很优雅：连同电源线和地线，我们只需要将16条连接焊接到控制打字机电路板上键盘开关矩阵的引脚上即可。其余的是软件，其中大多数功能完全符合您的期望。编写最困难的代码是控制器从打字机读取原始信号。但是我们将其归结为具有几乎完美的行为，而且行为也极少（尤其是当您忽略Shift键的特殊情况时）：</p><p> # include   &lt;wiringPi.h &gt;# include   &lt;stdio.h &gt;  int  main( void) {  wiringPiSetup();  setbuf(stdout,  NULL);  int scanPins[] = { 5,  22,  10,  11,  26,  27,  28,  29};  int signalPins[] = { 13,  12,  3,  2,  0,  7,  24,  23};  int i =  0;  int j =  0;  for (i= 0; i&lt; 8; i++) {  pinMode(scanPins[i], INPUT);  pinMode(signalPins[i], INPUT);  pullUpDnControl(scanPins[i], PUD_UP);  pullUpDnControl(signalPins[i], PUD_UP); }  int keyDown[ 8][ 8] = { { 0,  0,  0,  0,  0,  0,  0,  0}, { 0,  0,  0,  0,  0,  0,  0,  0}, { 0,  0,  0,  0,  0,  0,  0,  0}, { 0,  0,  0,  0,  0,  0,  0,  0}, { 0,  0,  0,  0,  0,  0,  0,  0}, { 0,  0,  0,  0,  0,  0,  0,  0}, { 0,  0,  0,  0,  0,  0,  0,  0}, { 0,  0,  0,  0,  0,  0,  0,  0} };  int lastI;  int lastJ;  int sameKeyCount =  0;  for (;;) {  for (i= 0; i&lt; 8; i++) {  for (j= 0; j&lt; 8; j++) {  if ( digitalRead(scanPins[i]) == LOW &amp;&amp;  digitalRead(signalPins[j]) == LOW) { (i == lastI &amp;&amp; j == lastJ) ? sameKeyCount++ : sameKeyCount =  0;  if (sameKeyCount &gt;  50 &amp;&amp; keyDown[i][j] &lt;=  0) {  printf(  &#34; %d, %d \n &#34;, i, j); keyDown[i][j] =  50; } lastI = i; lastJ = j; }  if ( digitalRead(scanPins[i]) == LOW &amp;&amp;  digitalRead(signalPins[j]) == HIGH) { keyDown[i][j] = (keyDown[i][j] -  1); } } } }}</p><p> ＃include＆lt; wiringPi.h＆gt;＃include＆lt; stdio.h＆gt; int main（void）{connectionPiSetup（）; setbuf（stdout，NULL）; int scanPins [] = {5，22，10，11，26，27，28，29}; int signalPins [] = {13，12，3，2，0，7，24，23}; int i = 0; int j = 0; for（i = 0; i <8; i ++）{pinMode（scanPins [i]，INPUT）; pinMode（signalPins [i]，INPUT）; pullUpDnControl（scanPins [i]，PUD_UP）; pullUpDnControl（signalPins [i]，PUD_UP）; } int keyDown [8] [8] = {{0，0，0，0，0，0，0，0}，{0，0，0，0，0，0，0，0}，{0， 0，0，0，0，0，0，0}，{0，0，0，0，0，0，0，0}，{0，0，0，0，0，0，0，0} ，{0，0，0，0，0，0，0，0}，{0，0，0，0，0，0，0，0}，{0，0，0，0，0，0， 0，0}}; int lastI; int lastJ; int sameKeyCount = 0; for（;;）{for（i = 0; i＆lt; 8; i ++）{for（j = 0; j＆lt; 8; j ++）{if（digitalRead（scanPins [i]）== LOW＆amp; digitalRead（ signalPins [j]）== LOW）{（i == lastI＆amp; j == lastJ）？ sameKeyCount ++：sameKeyCount = 0; if（sameKeyCount＆gt; 50＆amp;＆amp; keyDown [i] [j]＆lt; = 0）{printf（＆＃34;％d，％d \ n＆＃34 ;, i，j）; keyDown [i] [j] = 50; } lastI = i; lastJ = j; }如果（digitalRead（scanPins [i]）== LOW＆amp; digitalRead（signalPins [j]）== HIGH）{keyDown [i] [j] =（keyDown [i] [j]-1）; }}}}}</p><p> A Ruby program in the cloud takes the output of this program (raw indexes like “6,0” for spacebar, or “5,3” for “j”) and maps them to strings, which it sends to a Google Doc using the  watir gem for driving headless web browsers.</p><p> 云中的Ruby程序采用该程序的输出（原始索引，例如空格键为“ 6,0”，或“ j”为“ 5,3”），并将其映射为字符串，然后使用watir gem，用于驱动无头Web浏览器。</p><p>  For now this is just a one-off project. But if you think you’d want to build one yourself, or buy one, email me at  [email protected]</p><p>  目前，这只是一个一次性的项目。但是，如果您认为自己想建造一个或购买一个，请给我发电子邮件[受保护的电子邮件] </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://jsomers.net/blog/docwriter">http://jsomers.net/blog/docwriter</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/击键/">#击键</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/打字机/">#打字机</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>