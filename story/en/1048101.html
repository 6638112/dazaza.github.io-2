<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>爱因斯坦符号 Einstein Notation</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Einstein Notation<br/>爱因斯坦符号 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-18 03:33:27</div><div class="page_narrow text-break page_content"><p>Using the Einstein summation convention, many common multi-dimensional,linear algebraic array operations can be represented in a simple fashion.In  implicit mode    einsum computes these values.</p><p>使用爱因斯坦求和约定，可以用一种简单的方式表示许多常见的多维线性代数数组运算。在隐式模式下，einsum计算这些值。</p><p> In  explicit mode,    einsum provides further flexibility to computeother array operations that might not be considered classical Einsteinsummation operations, by disabling, or forcing summation over specifiedsubscript labels.</p><p> 在显式模式下，einsum通过禁用或强制对指定的下标标签求和，从而提供了更大的灵活性来计算其他数组操作（可能不被视为经典的爱因斯坦求和操作）。</p><p>  Specifies the subscripts for summation as comma separated list ofsubscript labels. An implicit (classical Einstein summation)calculation is performed unless the explicit indicator ‘-&gt;’ isincluded as well as subscript labels of the precise output form.</p><p>  将要求和的下标指定为逗号分隔的下标标签列表。除非包含显式指示符“-＆gt;”以及精确输出形式的下标标签，否则将执行隐式（经典的爱因斯坦求和）计算。</p><p>      If provided, forces the calculation to use the data type specified.Note that you may have to also give a more liberal  castingparameter to allow the conversions. Default is None.</p><p>      如果提供了该选项，则强制计算使用指定的数据类型。请注意，您可能还必须提供一个更宽松的强制转换参数才能进行转换。默认为无。</p><p> order {‘C’, ‘F’, ‘A’, ‘K’}, optional</p><p> 顺序{'C'，'F'，'A'，'K'}，可选</p><p> Controls the memory layout of the output. ‘C’ means it shouldbe C contiguous. ‘F’ means it should be Fortran contiguous,‘A’ means it should be ‘F’ if the inputs are all ‘F’, ‘C’ otherwise.‘K’ means it should be as close to the layout as the inputs asis possible, including arbitrarily permuted axes.Default is ‘K’.</p><p> 控制输出的内存布局。 “ C”表示它应该是C连续的。 'F'表示它应该是Fortran连续的，'A'表示如果所有输入都为'F'则应该为'F'，否则为'C'。'K'表示它应该与输入asis尽可能靠近布局可能，包括任意排列的轴。默认值为“ K”。</p><p> casting {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</p><p> 强制转换{'no'，'equiv'，'safe'，'same_kind'，'unsafe'}，可选 </p><p> Controls what kind of data casting may occur. Setting this to‘unsafe’ is not recommended, as it can adversely affect accumulations.</p><p>控制可能发生的数据类型转换。不建议将其设置为“不安全”，因为这会对积聚产生不利影响。</p><p> ‘same_kind’ means only safe casts or casts within a kind,like float64 to float32, are allowed.</p><p> “ same_kind”表示仅允许安全类型转换或同一类型（例如float64到float32）内的类型转换。</p><p>  Controls if intermediate optimization should occur. No optimizationwill occur if False and True will default to the ‘greedy’ algorithm.Also accepts an explicit contraction list from the   np.einsum_pathfunction. See   np.einsum_path for more details. Defaults to False.</p><p>  控制是否应进行中间优化。如果将False和True缺省设置为“贪心”算法，则不会进行优化。还要接受np.einsum_path函数的显式收缩列表。有关更多详细信息，请参见np.einsum_path。默认为False。</p><p> similar verbose interface is provided by  einops package to cover additional operations: transpose, reshape/flatten, repeat/tile, squeeze/unsqueeze and reductions.</p><p> einops软件包提供了类似的详细界面，以涵盖其他操作：转置，重塑/展平，重复/拼贴，挤压/取消挤压和缩小。</p><p>   The Einstein summation convention can be used to computemany multi-dimensional, linear algebraic array operations.    einsumprovides a succinct way of representing these.</p><p>   爱因斯坦求和约定可用于计算许多多维的线性代数数组运算。 einsum提供了一种简洁的表示方式。</p><p> A non-exhaustive list of these operations,which can be computed by    einsum, is shown below along with examples:</p><p> 这些操作的非详尽列表（可以通过einsum计算）在下面显示，并提供示例：</p><p>  The subscripts string is a comma-separated list of subscript labels,where each label refers to a dimension of the corresponding operand.Whenever a label is repeated it is summed, so   np.einsum(&#39;i,i&#39;,  a,  b)is equivalent to    np.inner(a,b). If a labelappears only once, it is not summed, so   np.einsum(&#39;i&#39;,  a) produces aview of   a with no changes. A further example   np.einsum(&#39;ij,jk&#39;,  a,  b)describes traditional matrix multiplication and is equivalent to   np.matmul(a,b). Repeated subscript labels in oneoperand take the diagonal. For example,   np.einsum(&#39;ii&#39;,  a) is equivalentto    np.trace(a).</p><p>  下标字符串是用逗号分隔的下标标签列表，其中每个标签均指对应操作数的维数。每当重复标签时，它都会被累加，因此np.einsum（＆＃39; i，i＆＃39; a，b）等于np.inner（a，b）。如果一个标签仅出现一次，则不会对其求和，因此np.einsum（＆＃39; i＆＃39 ;, a）会产生一个无变化的a视图。另一个示例np.einsum（ij，jk＆＃39; a，b）描述了传统的矩阵乘法，并且等效于np.matmul（a，b）。 oneoperand中重复的下标标签取对角线。例如，np.einsum（＆ii;＃39; a）等效于np.trace（a）。 </p><p> In  implicit mode, the chosen subscripts are importantsince the axes of the output are reordered alphabetically. Thismeans that   np.einsum(&#39;ij&#39;,  a) doesn’t affect a 2D array, while  np.einsum(&#39;ji&#39;,  a) takes its transpose. Additionally,  np.einsum(&#39;ij,jk&#39;,  a,  b) returns a matrix multiplication, while,  np.einsum(&#39;ij,jh&#39;,  a,  b) returns the transpose of themultiplication since subscript ‘h’ precedes subscript ‘i’.</p><p>在隐式模式下，选择的下标很重要，因为输出的轴按字母顺序重新排序。这意味着np.einsum（＆＃39; ij＆＃39 ;, a）不会影响2D数组，而np.einsum（＆＃39; ji＆＃39 ;, a）将对其进行转置。此外，np.einsum（＆＃39; ij，jk＆＃39 ;, a，b）返回矩阵乘法，而np.einsum（＆＃39; ij，jh＆＃39 ;, a，b）返回转置。因为下标'h'在下标'i'之前，所以是乘法的乘积。</p><p> In  explicit mode the output can be directly controlled byspecifying output subscript labels. This requires theidentifier ‘-&gt;’ as well as the list of output subscript labels.This feature increases the flexibility of the function sincesumming can be disabled or forced when required. The call  np.einsum(&#39;i-&gt;&#39;,  a) is like    np.sum(a,  axis=-1),and   np.einsum(&#39;ii-&gt;i&#39;,  a) is like    np.diag(a).The difference is that    einsum does not allow broadcasting by default.Additionally   np.einsum(&#39;ij,jh-&gt;ih&#39;,  a,  b) directly specifies theorder of the output subscript labels and therefore returns matrixmultiplication, unlike the example above in implicit mode.</p><p> 在显式模式下，可以通过指定输出下标标签直接控制输出。这需要标识符“-＆gt;”以及输出下标标签列表。此功能增加了功能的灵活性，因为可以在需要时禁用或强制求和。调用np.einsum（＆＃39; i-＆gt ;, a）就像np.sum（a，axis = -1）和np.einsum（＆＃39; ii-＆gt; i＆＃ 39; a）类似于np.diag（a），不同之处在于einsum默认情况下不允许广播，另外np.einsum（＆＃39，ij，jh-＆gt; ih＆＃39 ;, a，b）直接指定输出下标标签的顺序，因此返回矩阵乘法，这与上面的隐式模式示例不同。</p><p> To enable and control broadcasting, use an ellipsis. DefaultNumPy-style broadcasting is done by adding an ellipsisto the left of each term, like   np.einsum(&#39;...ii-&gt;...i&#39;,  a).To take the trace along the first and last axes,you can do   np.einsum(&#39;i...i&#39;,  a), or to do a matrix-matrixproduct with the left-most indices instead of rightmost, one can do  np.einsum(&#39;ij...,jk...-&gt;ik...&#39;,  a,  b).</p><p> 要启用和控制广播，请使用省略号。 DefaultNumPy样式的广播是通过在每个术语的左侧添加一个省略号来完成的，例如np.einsum（＆lt; ii-＆gt; ... i＆＃39 ;, a）。最后一个轴，您可以执行np.einsum（＆i ... i＆＃39 ;, a），或者使用最左边的索引而不是最右边的索引来做矩阵矩阵乘积，就可以执行np.einsum （＆＃39;，jk ...-＆gt; ik ...＆＃39;，a，b）。</p><p> When there is only one operand, no axes are summed, and no outputparameter is provided, a view into the operand is returned insteadof a new array. Thus, taking the diagonal as   np.einsum(&#39;ii-&gt;i&#39;,  a)produces a view (changed in version 1.10.0).</p><p> 当只有一个操作数时，没有轴求和，也没有提供outputparameter，则返回对该操作数的视图，而不是新的数组。因此，将对角线作为np.einsum（ii-i＆＃39; a）产生视图（在版本1.10.0中进行了更改）。</p><p> einsum also provides an alternative way to provide the subscriptsand operands as   einsum(op0,  sublist0,  op1,  sublist1,  ...,  [sublistout]).If the output shape is not provided in this format    einsum will becalculated in implicit mode, otherwise it will be performed explicitly.The examples below have corresponding    einsum calls with the twoparameter methods.</p><p> einsum还提供了另一种方式来提供下标和操作数作为einsum（op0，sublist0，op1，sublist1，...，[sublistout]）。如果未以这种格式提供输出形状，einsum将以隐式模式进行计算，否则下面的示例具有使用twoparameter方法的对应einsum调用。</p><p>  Views returned from einsum are now writeable whenever the input arrayis writeable. For example,   np.einsum(&#39;ijk...-&gt;kji...&#39;,  a) will nowhave the same effect as    np.swapaxes(a,  0,  2)and   np.einsum(&#39;ii-&gt;i&#39;,  a) will return a writeable view of the diagonalof a 2D array.</p><p>  现在，只要输入数组可写，从einsum返回的视图就可以写。例如，np.einsum（＆lt; ijk ...-＆gt; kji ...＆＃39 ;, a）现在将具有与np.swapaxes（a，0，2）和np.einsum（ ＆lt; ii-＆gt; i＆＃39;，a）将返回2D数组对角线的可写视图。</p><p>  Added the   optimize argument which will optimize the contraction orderof an einsum expression. For a contraction with three or more operands thiscan greatly increase the computational efficiency at the cost of a largermemory footprint during computation.</p><p>  添加了optimize参数，该参数将优化einsum表达式的收缩顺序。对于具有三个或更多操作数的压缩，这可以大大提高计算效率，但需要在计算过程中增加内存占用量。 </p><p> Typically a ‘greedy’ algorithm is applied which empirical tests have shownreturns the optimal path in the majority of cases. In some cases ‘optimal’will return the superlative path through a more expensive, exhaustive search.For iterative calculations it may be advisable to calculate the optimal pathonce and reuse that path by supplying it as an argument. An example is givenbelow.</p><p>通常，采用“贪心”算法，根据经验测试，该算法在大多数情况下会返回最佳路径。在某些情况下，“最优”将通过更昂贵，更详尽的搜索返回最高级路径。对于迭代计算，建议最好计算一次最佳路径并通过将其作为参数重用该路径。下面给出一个例子。</p><p>       &gt;&gt;&gt;  np . einsum ( &#39;ii-&gt;i&#39; ,  a ) array([ 0, 6, 12, 18, 24]) &gt;&gt;&gt;  np . einsum ( a ,  [ 0 , 0 ],  [ 0 ]) array([ 0, 6, 12, 18, 24]) &gt;&gt;&gt;  np . diag ( a ) array([ 0, 6, 12, 18, 24])</p><p>       ＆gt;＆gt;＆gt; np。 einsum（＆＃39; ii-＆quot; i，a）array（[0，6，12，18，24]）＆gt; np。 einsum（a，[0，0]，[0]）array（[0，6，12，18，24]）＆gt; np。诊断（a）数组（[0，6，12，18，24]）</p><p>  &gt;&gt;&gt;  np . einsum ( &#39;ij-&gt;i&#39; ,  a ) array([ 10, 35, 60, 85, 110]) &gt;&gt;&gt;  np . einsum ( a ,  [ 0 , 1 ],  [ 0 ]) array([ 10, 35, 60, 85, 110]) &gt;&gt;&gt;  np . sum ( a ,  axis = 1 ) array([ 10, 35, 60, 85, 110])</p><p>  ＆gt;＆gt;＆gt; np。 einsum（＆lt; ij-＆gt; i＆＃39;，a）array（[10，35，60，85，110]）＆gt; np。 einsum（a，[0，1]，[0]）数组（[10，35，60，85，110]） np。总和（a，轴= 1）数组（[10，35，60，85，110]）</p><p>  &gt;&gt;&gt;  np . einsum ( &#39;...j-&gt;...&#39; ,  a ) array([ 10, 35, 60, 85, 110]) &gt;&gt;&gt;  np . einsum ( a ,  [ Ellipsis , 1 ],  [ Ellipsis ]) array([ 10, 35, 60, 85, 110])</p><p>  ＆gt;＆gt;＆gt; np。 einsum（＆＃39; ... j-＆gt; ...＆＃39; a）数组（[10，35，60，85，110]）＆gt; np。 einsum（a，[椭圆，1]，[椭圆]）数组（[10，35，60，85，110]）</p><p>  &gt;&gt;&gt;  np . einsum ( &#39;ji&#39; ,  c ) array([[0, 3],  [1, 4],  [2, 5]]) &gt;&gt;&gt;  np . einsum ( &#39;ij-&gt;ji&#39; ,  c ) array([[0, 3],  [1, 4],  [2, 5]]) &gt;&gt;&gt;  np . einsum ( c ,  [ 1 , 0 ]) array([[0, 3],  [1, 4],  [2, 5]]) &gt;&gt;&gt;  np . transpose ( c ) array([[0, 3],  [1, 4],  [2, 5]])</p><p>  ＆gt;＆gt;＆gt; np。 einsum（＆lt; ji＆＃39;，c）array（[[0，3]，[1，4]，[2，5]]）＆gt; np。 einsum（＆lt; ij-＆gt; ji＆＃39;，c）array（[[0，3]，[1，4]，[2，5]]）＆gt; np。 einsum（c，[1，0]）array（[[0，3]，[1，4]，[2，5]]）＆gt; np。转置（c）数组（[[0，3]，[1，4]，[2，5]]）</p><p>    &gt;&gt;&gt;  np . einsum ( &#39;ij,j&#39; ,  a ,  b ) array([ 30, 80, 130, 180, 230]) &gt;&gt;&gt;  np . einsum ( a ,  [ 0 , 1 ],  b ,  [ 1 ]) array([ 30, 80, 130, 180, 230]) &gt;&gt;&gt;  np . dot ( a ,  b ) array([ 30, 80, 130, 180, 230]) &gt;&gt;&gt;  np . einsum ( &#39;...j,j&#39; ,  a ,  b ) array([ 30, 80, 130, 180, 230])</p><p>    ＆gt;＆gt;＆gt; np。 einsum（＆＃39; ij，j＆＃39;，a，b）数组（[30，80，130，180，230]） np。 einsum（a，[0，1，b，[1]）数组（[30，80，130，180，230]） np。点（a，b）数组（[30，80，130，180，230]）＆gt; np。 einsum（＆＃39; ... j，j＆＃39;，a，b）数组（[30，80，130，180，230]）</p><p>  &gt;&gt;&gt;  np . einsum ( &#39;..., ...&#39; ,  3 ,  c ) array([[ 0, 3, 6],  [ 9, 12, 15]]) &gt;&gt;&gt;  np . einsum ( &#39;,ij&#39; ,  3 ,  c ) array([[ 0, 3, 6],  [ 9, 12, 15]]) &gt;&gt;&gt;  np . einsum ( 3 ,  [ Ellipsis ],  c ,  [ Ellipsis ]) array([[ 0, 3, 6],  [ 9, 12, 15]]) &gt;&gt;&gt;  np . multiply ( 3 ,  c ) array([[ 0, 3, 6],  [ 9, 12, 15]])</p><p>  ＆gt;＆gt;＆gt; np。 einsum（＆＃39; ...，...＆＃39;，3，c）array（[[0，3，6]，[9，12，15]]）＆gt; np。 einsum（＆＃39;，ij＆＃39;，3，c）array（[[0，3，6]，[9，12，15]]） np。 einsum（3，[省略号]，c，[省略号]）数组（[[0，3，6]，[9，12，15]]） np。乘以（3，c）数组（[[0，3，6]，[9，12，15]]） </p><p>  &gt;&gt;&gt;  np . einsum ( &#39;i,j&#39; ,  np . arange ( 2 ) + 1 ,  b ) array([[0, 1, 2, 3, 4],  [0, 2, 4, 6, 8]]) &gt;&gt;&gt;  np . einsum ( np . arange ( 2 ) + 1 ,  [ 0 ],  b ,  [ 1 ]) array([[0, 1, 2, 3, 4],  [0, 2, 4, 6, 8]]) &gt;&gt;&gt;  np . outer ( np . arange ( 2 ) + 1 ,  b ) array([[0, 1, 2, 3, 4],  [0, 2, 4, 6, 8]])</p><p>＆gt;＆gt;＆gt; np。 einsum（＆＃39，i＆j39;，np。arange（2）+ 1，b）array（[[0，1，2，3，4]，[0，2，4，6，8] ]）＆gt;＆gt; np。 einsum（np。arange（2）+1，[0]，b，[1]）数组（[[0，1，2，3，4]，[0，2，4，6，8]]）＆gt ;＆gt;＆gt; np。外部（np。arange（2）+1，b）数组（[[0，1，2，3，4]，[0，2，4，6，6，8]]）</p><p>  &gt;&gt;&gt;  a  =  np . arange ( 60. ) . reshape ( 3 , 4 , 5 ) &gt;&gt;&gt;  b  =  np . arange ( 24. ) . reshape ( 4 , 3 , 2 ) &gt;&gt;&gt;  np . einsum ( &#39;ijk,jil-&gt;kl&#39; ,  a ,  b ) array([[4400., 4730.],  [4532., 4874.],  [4664., 5018.],  [4796., 5162.],  [4928., 5306.]]) &gt;&gt;&gt;  np . einsum ( a ,  [ 0 , 1 , 2 ],  b ,  [ 1 , 0 , 3 ],  [ 2 , 3 ]) array([[4400., 4730.],  [4532., 4874.],  [4664., 5018.],  [4796., 5162.],  [4928., 5306.]]) &gt;&gt;&gt;  np . tensordot ( a , b ,  axes = ([ 1 , 0 ],[ 0 , 1 ])) array([[4400., 4730.],  [4532., 4874.],  [4664., 5018.],  [4796., 5162.],  [4928., 5306.]])</p><p>  ＆gt;＆gt;＆gt; a = np。范围（60.）。重塑（3、4、5）＆gt;＆gt; b = np。范围（24.）。重塑（4、3、2）＆gt;＆gt; np。 einsum（＆lt; ijk，jil-＆gt; kl＆＃39;，a，b）数组（[[4400.，4730.]，[4532.，4874.]，[4664.，5018.]，[4796 。，5162.]，[4928.，5306.]]）＆gt;＆gt; np。 einsum（a，[0，1，2]，b，[1，0，3]，[2，3]）数组（[[4400.，4730.]，[4532.，4874.]，[4664。 ，[5018。]，[4796.，5162。]，[4928.，5306。]]）＆gt;＆gt; np。张量点（a，b，轴=（[1，0]，[0，1]））数组（[[4400.，4730.]，[4532.，4874.]，[4664.，5018.]，[ 4796.，5162.]，[4928.，5306.]]）</p><p>  &gt;&gt;&gt;  a  =  np . zeros (( 3 ,  3 )) &gt;&gt;&gt;  np . einsum ( &#39;ii-&gt;i&#39; ,  a )[:]  =  1 &gt;&gt;&gt;  a array([[1., 0., 0.],  [0., 1., 0.],  [0., 0., 1.]])</p><p>  ＆gt;＆gt;＆gt; a = np。零（（3，3））＆gt;＆gt; np。 einsum（＆＃39; ii-i＆＃39;，a）[：] = 1＆gt;＆gt;数组（[[1.，0.，0.]，[0.，1.，0.]，[0.，0.，1.]]）</p><p>  &gt;&gt;&gt;  a  =  np . arange ( 6 ) . reshape (( 3 , 2 )) &gt;&gt;&gt;  b  =  np . arange ( 12 ) . reshape (( 4 , 3 )) &gt;&gt;&gt;  np . einsum ( &#39;ki,jk-&gt;ij&#39; ,  a ,  b ) array([[10, 28, 46, 64],  [13, 40, 67, 94]]) &gt;&gt;&gt;  np . einsum ( &#39;ki,...k-&gt;i...&#39; ,  a ,  b ) array([[10, 28, 46, 64],  [13, 40, 67, 94]]) &gt;&gt;&gt;  np . einsum ( &#39;k...,jk&#39; ,  a ,  b ) array([[10, 28, 46, 64],  [13, 40, 67, 94]])</p><p>  ＆gt;＆gt;＆gt; a = np。范围（6）。重塑（（3，2））＆gt; b = np。范围（12）。重塑（（4，3））＆gt; np。 einsum（＆＃39; ki，jk-＆gt; ij＆＃39;，a，b）数组（[[10，28，46，64]，[13，40，67，94]]） ; np。 einsum（＆＃39; ... k-＆gt; i ...＆＃39;，a，b）数组（[[10，28，46，64]，[13，40，67，94] ]）＆gt;＆gt; np。 einsum（＆＃39;，jk＆＃39;，a，b）数组（[[10，28，46，64]，[13，40，67，94]]）</p><p> Chained array operations. For more complicated contractions, speed upsmight be achieved by repeatedly computing a ‘greedy’ path or pre-computing the‘optimal’ path and repeatedly applying it, using an   einsum_path insertion (since version 1.12.0). Performance improvements can beparticularly significant with larger arrays:</p><p> 链式数组操作。对于更复杂的收缩，可以通过重复计算“贪婪”路径或预先计算“最佳”路径并使用einsum_path插入（自1.12.0版开始）重复应用来实现加速。对于较大的阵列，性能改进尤其重要： </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://numpy.org/doc/stable/reference/generated/numpy.einsum.html">https://numpy.org/doc/stable/reference/generated/numpy.einsum.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/符号/">#符号</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/einstein/">#einstein</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/einsum/">#einsum</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>