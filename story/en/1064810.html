<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>GNU编码标准：编写强大的程序 GNU Coding Standards: Writing Robust Programs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">GNU Coding Standards: Writing Robust Programs<br/>GNU编码标准：编写强大的程序 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-10 19:53:54</div><div class="page_narrow text-break page_content"><p>Copyright © 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 FreeSoftware Foundation, Inc.</p><p>版权所有©1992,1993,1994,1995,1999,2997,1998,1999,2000，2001,2001,2001,2004,2005，2006,2007，2008,2009，2010,2011，2012,2013，2014,2015，2013年，2014年，2015年， 2016年，2017年，2018年，2019年，2020 FreeSoftware Foundation，Inc。</p><p> Permission is granted to copy, distribute and/or modify this documentunder the terms of the GNU Free Documentation License, Version 1.3 orany later version published by the Free Software Foundation; with noInvariant Sections, no Front-Cover Texts, and no Back-CoverTexts. A copy of the license is included in the section entitled“GNU Free Documentation License”.</p><p> 许可被授予复制，分发和/或修改GNU免费文档许可证的条款，版本1.3 orany由自由软件基金会发布的版本1.3 orany版本;使用NoInvariant部分，没有前封面文本，没有背套文字。许可证副本包含在题为“GNU免费文档许可证”的部分中。</p><p>       The GNU Coding Standards were written by Richard Stallman and other GNUProject volunteers. Their purpose is to make the GNU system clean,consistent, and easy to install. This document can also be read as aguide to writing portable, robust and reliable programs. It focuses onprograms written in C, but many of the rules and principles are usefuleven if you write in another programming language. The rules oftenstate reasons for writing in a certain way.</p><p>       GNU编码标准由Richard Stallman和其他GNUProject志愿者编写。他们的目的是使GNU系统干净，一致，易于安装。本文档也可以将作为algaide读取以编写便携式，强大和可靠的程序。它侧重于在C中编写的onPrograms，但如果您以另一种编程语言编写，许多规则和原则是有用的。规则经常以某种方式写作的原因。</p><p>   If you did not obtain this file directly from the GNU project andrecently, please check for a newer version. You can get the GNUCoding Standards from the GNU web server in manydifferent formats, including the Texinfo source, PDF, HTML, DVI, plaintext, and more, at:  https://www.gnu.org/prep/standards/.</p><p>   如果您没有直接从GNU项目获得此文件，请检查更新版本。您可以以多种多量格式从GNU Web服务器获取GNUCoding标准，包括Texinfo源，PDF，HTML，DVI，明文等：https：//www.gnu.org/prep/standards/。</p><p> If you are maintaining an official GNU package, in addition to thisdocument, please read and follow the GNU maintainer information(see  Contents in  Information for Maintainers of GNUSoftware).</p><p> 如果您维持官方GNU包，除此之外，请阅读并遵循GNU维护者信息（请参阅GNUSoftware的维护者的信息中的内容）。</p><p>  If you want to receive diffs for every change to these GNU documents,join the mailing list  gnustandards-commit@gnu.org, via the webinterface at https://lists.gnu.org/mailman/listinfo/gnustandards-commit.Archives are also available there.</p><p>  如果您想为这些GNU文档的每一个更改接收Diff，请加入邮件列表GNustAndards-commit@gnu.org，通过https://lists.gnu.org/mailman/listinfo/gnustandards-commit.archives的webinterface也有那里。</p><p>    Please send corrections or suggestions for this document to bug-standards@gnu.org. If you make a suggestion, pleaseinclude a suggested new wording for it, to help us consider thesuggestion efficiently. We prefer a context diff to the Texinfosource, but if that’s difficult for you, you can make a context difffor some other version of this document, or propose it in any way thatmakes it clear. The source repository for this document can be foundat  https://savannah.gnu.org/projects/gnustandards.</p><p>    请将本文档发送到Bug -standards@gnu.org的修正或建议。如果您提出建议，请为其提出建议的新措辞，以帮助我们有效地考虑Thesugion。我们更喜欢与Texinfosource的上下文差异，但如果这对您难以困难，您可以使上下文difffor此文档的其他一些版本，或以任何方式提出它清除它。此文档的源存储库可以是footat https://savannah.gnu.org/projects/gnustandards。 </p><p> These standards cover the minimum of what is important when writing aGNU package. Likely, the need for additional standards will come up.Sometimes, you might suggest that such standards be added to thisdocument. If you think your standards would be generally useful, pleasedo suggest them.</p><p>这些标准涵盖了撰写Agnu包时的重要性最小。可能的是，对额外标准的需求将升级。有时，您可能会建议将此类标准添加到此录制中。如果您认为您的标准通常是有用的，那么Paileo建议他们。</p><p> You should also set standards for your package on many questions notaddressed or not firmly specified here. The most important point is tobe self-consistent—try to stick to the conventions you pick, and tryto document them as much as possible. That way, your program will bemore maintainable by others.</p><p> 您还应在此内容或未在此处牢固指定的许多问题上为您的包设置标准。最重要的一点是Tobe自我一致 - 尝试坚持您选择的约定，并尽可能多地记录它们。这样，您的计划将由其他人提供比较。</p><p> The GNU Hello program serves as an example of how to follow the GNUcoding standards for a trivial program. https://www.gnu.org/software/hello/hello.html.</p><p> GNU Hello程序用作如何遵循琐碎程序的GNUCoding标准的示例。 https://www.gnu.org/software/hello/hello.html。</p><p>        This chapter discusses how you can make sure that GNU softwareavoids legal difficulties, and other related issues.</p><p>        本章讨论了如何确保GNU软件的法律困难以及其他相关问题。</p><p>         Don’t in any circumstances refer to Unix source code for or duringyour work on GNU! (Or to any other proprietary programs.)</p><p>         在任何情况下都不是指unix源代码或在GNU上工作期间的工作！ （或任何其他专有计划。）</p><p> If you have a vague recollection of the internals of a Unix program,this does not absolutely mean you can’t write an imitation of it, butdo try to organize the imitation internally along different lines,because this is likely to make the details of the Unix versionirrelevant and dissimilar to your results.</p><p> 如果您对UNIX计划的内部构件进行了模糊的回忆，这并不绝对意味着您无法编写它的模仿，但是尝试沿着不同的线条内部组织模仿，因为这可能会详细说明UNIX versionirelevant和与您的结果不同。</p><p> For example, Unix utilities were generally optimized to minimizememory use; if you go for speed instead, your program will be verydifferent. You could keep the entire input file in memory and scan itthere instead of using stdio. Use a smarter algorithm discovered morerecently than the Unix program. Eliminate use of temporary files. Doit in one pass instead of two (we did this in the assembler).</p><p> 例如，Unix实用程序通常优化为最小化emory使用;如果您提供速度，您的程序将非常感谢。您可以将整个输入文件保留在内存中并扫描其而不是使用STDIO。使用比UNIX程序更奇怪的更智能算法。消除临时文件的使用。在一个通行证中代替两个（我们在汇编程序中完成了这个）。 </p><p> Or, on the contrary, emphasize simplicity instead of speed. For someapplications, the speed of today’s computers makes simpler algorithmsadequate.</p><p>或者，相反，强调简单而不是速度。对于可编组，今天的计算机的速度使得更简单的算法。</p><p> Or go for generality. For example, Unix programs often have statictables or fixed-size strings, which make for arbitrary limits; usedynamic allocation instead. Make sure your program handles NULs andother funny characters in the input files. Add a programming languagefor extensibility and write part of the program in that language.</p><p> 或者致足。例如，UNIX程序通常具有统治性或固定大小的字符串，这使得任意限制; icubic分配。确保您的程序处理输入文件中的NULS和其他有趣的字符。添加一个编程语言，必须在该语言中编写该程序的部分。</p><p> Or turn some parts of the program into independently usable libraries.Or use a simple garbage collector instead of tracking precisely whento free memory, or use a new GNU facility such as obstacks.</p><p> 或将程序的某些部分转换为可独立使用的库.Oor使用简单的垃圾收集器，而不是准确地跟踪Whento Free Memory，或使用新的GNU设施，如软件。</p><p>        If the program you are working on is copyrighted by the Free SoftwareFoundation, then when someone else sends you a piece of code to add tothe program, we need legal papers to use it—just as we asked you tosign papers initially.  Each person who makes a nontrivialcontribution to a program must sign some sort of legal papers in orderfor us to have clear title to the program; the main author alone is notenough.</p><p>        如果您正在处理的程序受到自由SoftwareFound的版权，那么当其他人向您发送代码来添加陷阱时，我们需要法律论文来使用它 - 正如我们最初要求您的Tosign文件一样使用它。为计划做出非凡的努力的人必须签署某种法律论文，以便我们有明确的职位;单独的主要作者是诺宁。</p><p> So, before adding in any contributions from other people, please tellus, so we can arrange to get the papers. Then wait until we tell youthat we have received the signed papers, before you actually use thecontribution.</p><p> 所以，在添加其他人的任何贡献之前，请告诉我们，所以我们可以安排获取论文。然后等到我们告诉你，我们在实际使用theconution之前收到了签名的论文。</p><p> This applies both before you release the program and afterward. Ifyou receive diffs to fix a bug, and they make significant changes, weneed legal papers for that change.</p><p> 这两者都适用于您之前释放程序之前。如果你会收到差异来修复一个错误，并且他们做出了重大变化，那个改变的Weneed法律论文。</p><p> This also applies to comments and documentation files. For copyrightlaw, comments and code are just text. Copyright applies to all kinds oftext, so we need legal papers for all kinds.</p><p> 这也适用于注释和文档文件。对于版权，评论和代码只是文本。版权适用于各种文本，因此我们需要各种法律论文。 </p><p> We know it is frustrating to ask for legal papers; it’s frustrating forus as well. But if you don’t wait, you are going out on a limb—forexample, what if the contributor’s employer won’t sign a disclaimer?You might have to take that code out again!</p><p>我们知道要求法律论文令人沮丧;这也是令人沮丧的福鲁。但如果你不等不及，你就会在肢体面包上出去，如果贡献者的雇主不会签署免责声明怎么办？你可能必须再次拿出这个代码！</p><p> You don’t need papers for changes of a few lines here or there, sincethey are not significant for copyright purposes. Also, you don’t needpapers if all you get from the suggestion is some ideas, not actual codewhich you use. For example, if someone sent you one implementation, butyou write a different implementation of the same idea, you don’t need toget papers.</p><p> 您不需要针对在这里或那里的几条线的变化，而是因为版权目的而言不重要。此外，如果您从建议中获得的所有想法，您也不需要剩余，而不是您使用的实际代码。例如，如果有人向您发送了一个实施，则为您写不同的同样的想法，您不需要忘记论文。</p><p> The very worst thing is if you forget to tell us about the othercontributor. We could be very embarrassed in court some day as aresult.</p><p> 最糟糕的是，如果你忘记告诉我们关于其他共信家。有一天我们可能会在法庭上非常尴尬。</p><p> We have more detailed advice for maintainers of GNU packages. If youhave reached the stage of maintaining a GNU program (whether releasedor not), please take a look: see  Legal Matters in  Information for GNU Maintainers.</p><p> 我们对GNU包的维护者提供了更详细的建议。如果youbave达到维护GNU计划的阶段（无论是释放者没有），请参观：请参阅GNU维护者的信息中的法律问题。</p><p>        Trademark acknowledgments are the statements that such-and-such is atrademark of so-and-so. The GNU Project has no objection to the basicidea of trademarks, but these acknowledgments feel like kowtowing,and there is no legal requirement for them, so we don’t use them.</p><p>        商标致谢是如此atrademark的声明。 GNU项目对商标的基础菌没有异议，但这些致谢感觉像Kowtowing，而且他们没有法律要求，所以我们不使用它们。</p><p> What is legally required, as regards other people’s trademarks, is toavoid using them in ways which a reader might reasonably understand asnaming or labeling our own programs or activities. For example, since“Objective C” is (or at least was) a trademark, we made sure to saythat we provide a “compiler for the Objective C language” ratherthan an “Objective C compiler”. The latter would have been meant asa shorter way of saying the former, but it does not explicitly statethe relationship, so it could be misinterpreted as using “ObjectiveC” as a label for the compiler rather than for the language.</p><p> 关于其他人的商标，在法律上要求，以读者可以合理地理解自己的计划或活动的方式使用它们。例如，由于“目标C”是（或者至少是）商标，我们肯定会为我们提供“目标C语言的编译器”而不是“目标C编译器”。后者本来是逐步的说法的方式，但它没有明确的统计关系，所以它可能被误解为使用“ObjectiveC”作为编译器的标签而不是语言。</p><p> Please don’t use “win” as an abbreviation for Microsoft Windows inGNU software or documentation. In hacker terminology, callingsomething a “win” is a form of praise. You’re free to praiseMicrosoft Windows on your own if you want, but please don’t do so inGNU packages. Please write “Windows” in full, or abbreviate it to“w.” See  System Portability.</p><p> 请不要将“Win”作为Microsoft Windows Ingnu软件或文档的缩写。在黑客术语中，呼叫称为“胜利”是一种赞美的形式。如果您愿意，您可以自由地播放PraisemicRosoft Windows，但请不要这样做Ingnu包。请完整地写“Windows”，或将其缩写为“w。”请参阅系统可移植性。 </p><p>       This chapter discusses some of the issues you should take intoaccount when designing your program.</p><p>本章讨论您在设计程序时应陷入困境的一些问题。</p><p>        When you want to use a language that gets compiled and runs at highspeed, the best language to use is C. C++ is ok too, but please don’tmake heavy use of templates. So is Java, if you compile it.</p><p>        当您想使用编译并在高速运行的语言时，使用的最佳语言是C. C ++也可以，但请不要使用模板的沉重使用。 java也是如此，如果你编译它。</p><p> When highest efficiency is not required, other languages commonly usedin the free software community, such as Lisp, Scheme, Python, Ruby, andJava, are OK too. Scheme, as implemented by GNU Guile, plays aparticular role in the GNU System: it is the preferred language toextend programs written in C/C++, and also a fine language for a widerange of applications. The more GNU components use Guile and Scheme,the more users are able to extend and combine them (see  The EmacsThesis in  GNU Guile Reference Manual).</p><p> 当不需要最高效率时，其他语言通常使用自由软件社区，例如Lisp，Scheme，Python，Ruby，Andjava也可以。由GNU Guile实施的方案在GNU系统中发挥了一个角色：它是在C / C ++中编写的首选语言待扩展程序，也是一种用于应用程序viderange的精细语言。更多的GNU组件使用套和方案，用户越多能够扩展并组合它们（请参阅GNU套筒引用手册中的emacsthesis）。</p><p> Many programs are designed to be extensible: they include an interpreterfor a language that is higher level than C. Often much of the programis written in that language, too. The Emacs editor pioneered thistechnique.</p><p> 许多程序都设计为可扩展：它们包括一种更高水平的语言的翻译，而且通常以这种语言编写的大部分编程。 Emacs编辑开创了Thistechnique。</p><p>   The standard extensibility interpreter for GNU software is Guile( https://www.gnu.org/software/guile/), which implements thelanguage Scheme (an especially clean and simple dialect of Lisp).Guile also includes bindings for GTK+/GNOME, making it practical towrite modern GUI functionality within Guile. We don’t reject programswritten in other “scripting languages” such as Perl and Python, butusing Guile is the path that will lead to overall consistency of theGNU system.</p><p>   GNU软件的标准扩展性解释器是套子（https://www.gnu.org/software/guile/），它实现了语试方案（一个特别清洁和简单的lisp方言）.Guile还包括gtk + / gnome的绑定，在套筒中制作它实用的桥式现代GUI功能。我们不拒绝其他“脚本语言”的程序，例如Perl和Python，但是套筒是将导致GNU系统的整体一致性的路径。</p><p>         With occasional exceptions, utility programs and libraries for GNUshould be upward compatible with those in Berkeley Unix, and upwardcompatible with Standard C if Standard C specifies theirbehavior, and upward compatible with POSIX if POSIX specifiestheir behavior.</p><p>         对于偶尔的异常，实用程序和图书馆与伯克利UNIX中的那些兼容，并且如果标准C指定htsbehavior，则与标准c向上兼容，如果posix enderiestheir行为，则与posix向上兼容。</p><p>   Standard C and POSIX prohibit many kinds of extensions. Feelfree to make the extensions anyway, and include a ‘ --ansi’,‘ --posix’, or ‘ --compatible’ option to turn them off.However, if the extension has a significant chance of breaking any realprograms or scripts, then it is not really upward compatible. So youshould try to redesign its interface to make it upward compatible.</p><p>   标准C和POSIX禁止多种扩展。无论如何，Feelfree要使扩展，并包括“ -  ansi”，' -  posix'或' - 申请的'选项，以便关闭它们。如果扩展有可能破坏任何Realograms或脚本的机会，那么然后它并不是向上兼容。所以你应该尝试重新设计它的界面，使其向上兼容。 </p><p>  Many GNU programs suppress extensions that conflict with POSIX if theenvironment variable  POSIXLY_CORRECT is defined (even if it isdefined with a null value). Please make your program recognize thisvariable if appropriate.</p><p>许多GNU程序抑制与POSIX冲突的扩展如果定义了“天环境”变量POSIXLY_CORRECT（即使它以空值isdined）。如果合适，请使您的计划认识到这一认可。</p><p> When a feature is used only by users (not by programs or commandfiles), and it is done poorly in Unix, feel free to replace itcompletely with something totally different and better. (For example, vi is replaced with Emacs.) But it is nice to offer a compatiblefeature as well. (There is a free  vi clone, so we offer it.)</p><p> 当仅由用户使用（不是程序或commandfiles）时，并且在UNIX中仍然不足，随意将其替换为完全不同和更好的东西。 （例如，VI被emacs替换为。）但是提供兼容性的兼容性。 （有一个免费的VI克隆，所以我们提供它。）</p><p>        Many GNU facilities that already exist support a number of convenientextensions over the comparable Unix facilities. Whether to use theseextensions in implementing your program is a difficult question.</p><p>        许多已经存在的GNU设施支持可比较的UNIX设施上的许多方便的扩展。是否在实施您的程序时使用theeexions是一个难题。</p><p> On the one hand, using the extensions can make a cleaner program.On the other hand, people will not be able to build the programunless the other GNU tools are available. This might cause theprogram to work on fewer kinds of machines.</p><p> 一方面，使用扩展可以制作一个更清洁的程序。另一方面，人们将无法构建不可用的程序核心可用。这可能导致TheProgram以更少种类的机器工作。</p><p> With some extensions, it might be easy to provide both alternatives.For example, you can define functions with a “keyword”  INLINEand define that as a macro to expand into either  inline ornothing, depending on the compiler.</p><p> 有一些扩展，可能很容易提供替代方案。如图所示，您可以使用“关键字”inlineand定义其中的函数定义为宏以扩展到内联ornothing，具体取决于编译器。</p><p> In general, perhaps it is best not to use the extensions if you canstraightforwardly do without them, but to use the extensions if theyare a big improvement.</p><p> 一般来说，如果你能够在没有它们的情况下才能使用扩展，也许最好不要使用扩展，但如果他们更加改善，则使用扩展。</p><p> An exception to this rule are the large, established programs (such asEmacs) which run on a great variety of systems. Using GNU extensions insuch programs would make many users unhappy, so we don’t do that.</p><p> 这个规则的例外是在各种各样的系统上运行的大型建立的计划（如默认）。使用GNU扩展insuch程序将使许多用户不快乐，所以我们不这样做。 </p><p> Another exception is for programs that are used as part of compilation:anything that must be compiled with other compilers in order tobootstrap the GNU compilation facilities. If these require the GNUcompiler, then no one can compile them without having them installedalready. That would be extremely troublesome in certain cases.</p><p>另一个例外是用于使用作为编译的一部分的程序：任何必须与其他编译器编译的任何内容，以顺序tobootstrap gnu编译设施。如果这些要求GNucompiler，则没有人可以编译它们而不使它们安装。在某些情况下，这将是非常麻烦的。</p><p>       1989 Standard C is widespread enough now that it is ok to use itsfeatures in programs. There is one exception: do not ever use the“trigraph” feature of Standard C.</p><p>       1989标准C普遍够了，现在可以在程序中使用它的成熟是可以的。有一个例外：请勿使用标准C的“三角形”功能。</p><p> The 1999 and 2011 editions of Standard C are not fully supportedon all platforms. If you aim to support compilation bycompilers other than GCC, you should not require these Cfeatures in your programs. It is ok to use these featuresconditionally when the compiler supports them.</p><p> 1999年和2011年版标准C不完全支持所有平台。如果您的目标是支持撰写的GCC以外的代码程序，您不应该在您的程序中要求这些CFeatures。当编译器支持它们时，可以使用这些功能。</p><p> If your program is only meant to compile with GCC, then you canuse these features if GCC supports them, when they give substantialbenefit.</p><p> 如果您的程序仅用GCC编译，那么如果GCC支持它们，则可以使用这些功能，当它们提供实质性偏心时。</p><p> However, it is easy to support pre-standard compilers in most programs,so if you know how to do that, feel free.</p><p> 但是，很容易在大多数程序中支持预设的编译器，因此如果您知道如何做到这一点，请随时。</p><p>        You need such a declaration anyway, in a header file, to get the benefitof prototypes in all the files where the function is called. And onceyou have the declaration, you normally lose nothing by writing thefunction definition in the pre-standard style.</p><p>        无论如何，在标题文件中，您需要这种声明，以便在调用函数的所有文件中获取原型的福利。 antionyou有声明，你通常通过在预设标准风格中写下函数定义来丢失任何内容。</p><p> This technique does not work for integer types narrower than  int.If you think of an argument as being of a type narrower than  int,declare it as  int instead.</p><p> 此技术不适用于窄于INT的整数类型。如果您将参数视为较窄的类型，则将其声明为int。 </p><p> There are a few special cases where this technique is hard to use. Forexample, if a function argument needs to hold the system type dev_t, you run into trouble, because  dev_t is shorter than int on some machines; but you cannot use  int instead,because  dev_t is wider than  int on some machines. Thereis no type you can safely use on all machines in a non-standarddefinition. The only way to support non-standard C and pass such anargument is to check the width of  dev_t using Autoconf and choosethe argument type accordingly. This may not be worth the trouble.</p><p>有一些特殊情况，这种技术很难使用。 forexample，如果函数参数需要保存系统类型dev_t，则遇到麻烦，因为dev_t在某些机器上短于int;但是，你不能使用int，因为dev_t比某些机器上的int宽。其中没有类型您可以在非标准的所有机器上安全使用。支持非标准C并通过此类Anargument的唯一方法是使用AutoConf和Choosethe参数类型来检查Dev_t的宽度。这可能不值得麻烦。</p><p> In order to support pre-standard compilers that do not recognizeprototypes, you may want to use a preprocessor macro like this:</p><p> 为了支持不识别支持者的预先标准编译器，您可能希望使用这样的预处理器宏：</p><p> /* Declare the prototype for a general external function. */#if defined (__STDC__) || defined (WINDOWSNT)#define P_(proto) proto#else#define P_(proto) ()#endif</p><p> / *声明一个通用外部功能的原型。 * /＃如果已定义（__stdc__）||定义（Windowsnt）#define p_（proto）proto＃else＃define p_（proto）（）#endif</p><p>      When supporting configuration options already known when building yourprogram we prefer using  if (... ) over conditional compilation,as in the former case the compiler is able to perform more extensivechecking of all possible code paths.</p><p>      当支持在构建备份时已知的配置选项时，我们更喜欢使用（...）在条件编译时，如前情况下，编译器能够更突出所有可能的代码路径。</p><p>     A modern compiler such as GCC will generate exactly the same code inboth cases, and we have been using similar techniques with good successin several projects. Of course, the former method assumes that HAS_FOO is defined as either 0 or 1.</p><p>     诸如GCC等现代编译器将产生完全相同的代码inboth案例，我们一直在使用类似的技术，良好的昂贵员工。当然，前一种方法假定HAS_FOO被定义为0或1。</p><p> While this is not a silver bullet solving all portability problems,and is not always appropriate, following this policy would have savedGCC developers many hours, or even days, per year.</p><p> 虽然这不是一个银弹解决所有可移植性问题，但并不总是合适的，但在此政策之后，每年都会有很多小时，甚至几天的节省。</p><p> In the case of function-like macros like  REVERSIBLE_CC_MODE inGCC which cannot be simply used in  if (...) statements, there isan easy workaround. Simply introduce another macro HAS_REVERSIBLE_CC_MODE as in the following example:</p><p> 在类似于Reversible_CC_Mode Ingcc的函数状宏的情况下，不能简单地使用IF（...）语句，有易于解决方案。只需在以下示例中引入另一个宏HAS_REVERSIBLE_CC_MODE： </p><p>       This chapter describes conventions for writing robustsoftware. It also describes general standards for error messages, thecommand line interface, and how libraries should behave.</p><p>本章介绍了编写RobustSoftware的惯例。它还描述了错误消息，Thecommand行界面以及库的一般标准。</p><p> How to find the program’s executable and other files that go with it.</p><p> 如何查找程序的可执行文件和其他使用它的文件。</p><p>      The GNU Project regards standards published by other organizations assuggestions, not orders. We consider those standards, but we do not“obey” them. In developing a GNU program, you should implementan outside standard’s specifications when that makes the GNU systembetter overall in an objective sense. When it doesn’t, you shouldn’t.</p><p>      GNU项目涉及其他组织担任的标准，而不是订单。我们考虑这些标准，但我们不会“遵守”它们。在开发GNU计划时，您应该在客观意义上实现GNU SystemBetter的外部标准规格。什么时候没有，你不应该。</p><p> In most cases, following published standards is convenient forusers—it means that their programs or scripts will work moreportably. For instance, GCC implements nearly all the features ofStandard C as specified by that standard. C program developers wouldbe unhappy if it did not. And GNU utilities mostly followspecifications of POSIX.2; shell script writers and users would beunhappy if our programs were incompatible.</p><p> 在大多数情况下，发布的标准之后是方便的预防者 - 这意味着他们的程序或脚本将努力工作。例如，GCC通过该标准指定的标准C的几乎实现了标准C的所有功能。如果没有，C程序开发人员会不满意。而GNU公用事业主要是POSIX的后续概况;如果我们的程序不兼容，shell脚本编写者和用户会呈Beunhappy。</p><p> But we do not follow either of these specifications rigidly, and thereare specific points on which we decided not to follow them, so as tomake the GNU system better for users.</p><p> 但我们不遵循这些规范中的任何一个，以及我们决定不遵循它们的特定点，因为为用户造成了GNU系统。</p><p> For instance, Standard C says that nearly all extensions to C areprohibited. How silly! GCC implements many extensions, some of whichwere later adopted as part of the standard. If you want theseconstructs to give an error message as “required” by the standard,you must specify ‘ --pedantic’, which was implemented only so thatwe can say “GCC is a 100% implementation of the standard”, notbecause there is any reason to actually use it.</p><p> 例如，标准C表示几乎所有的扩展都是C.P.多么愚蠢！ GCC实现了许多扩展，其中一些稍后通过作为标准的一部分。如果您希望将错误消息置于标准的“必需”，则必须指定'-pedantic'，只能实现它，只能说“GCC是标准的100％实现”，因此有任何内容实际使用它的原因。</p><p> POSIX.2 specifies that ‘ df’ and ‘ du’ must output sizes bydefault in units of 512 bytes. What users want is units of 1k, sothat is what we do by default. If you want the ridiculous behavior“required” by POSIX, you must set the environment variable‘ POSIXLY_CORRECT’ (which was originally going to be named‘ POSIX_ME_HARDER’).</p><p> POSIX.2指定“DF”和“DU”必须以512字节为单位输出BYDEFAULT的大小。用户想要的是1K的单位，默认是我们所做的。如果您希望POSIX的荒谬行为“必需”，则必须设置环境变量“posixly_correct”（最初将被命名为“posix_me_harder”）。 </p><p> GNU utilities also depart from the letter of the POSIX.2 specificationwhen they support long-named command-line options, and intermixingoptions with ordinary arguments. This minor incompatibility withPOSIX is never a problem in practice, and it is very useful.</p><p>GNU Utilities还远离POSIX.2的字母。当他们支持长期命令行选项时，以及具有普通参数的IntermixingOptions。对Posix的这种微小的不兼容在实践中绝不是一个问题，它非常有用。</p><p> In particular, don’t reject a new feature, or remove an old one,merely because a standard says it is “forbidden” or “deprecated”.</p><p> 特别是，不要拒绝一个新功能，或者删除旧功能，仅仅因为标准说它是“禁止”或“已弃用”。</p><p>       Avoid arbitrary limits on the length or number of  any datastructure, including file names, lines, files, and symbols, by allocatingall data structures dynamically. In most Unix utilities, “long linesare silently truncated”. This is not acceptable in a GNU utility.</p><p>       避免在任何数据结构的长度或数量上的任意限制，包括动态分配所有数据结构的文件名，行，文件和符号。在大多数UNIX实用程序中，“漫长的线条默默地截断”。这在GNU效用中不可接受。</p><p>   Utilities reading files should not drop NUL characters, or any othernonprinting characters. Programs should work properly with multibytecharacter encodings, such as UTF-8. You can use libiconv to deal witha range of encodings.</p><p>   实用程序读取文件不应丢弃NUL字符或任何其他批读字符。程序应使用多字节Arty编码，例如UTF-8正常工作。您可以使用libiconv处理范围的编码。</p><p>  Check every system call for an error return, unless you know you wishto ignore errors. Include the system error text (from strerror, or equivalent) in  every error messageresulting from a failing system call, as well as the name of the fileif any and the name of the utility. Just “cannot open foo.c” or“stat failed” is not sufficient.</p><p>  检查每个系统调用错误返回，除非您知道您希望忽略错误。从故障系统调用中的每个错误消息中包含系统错误文本（来自sterror，或等效），以及FileIf的名称和实用程序的名称。只是“无法打开foo.c”或“stat失败”是不够的。</p><p>   Check every call to  malloc or  realloc to see if itreturned  NULL. Check  realloc even if you are making theblock smaller; in a system that rounds block sizes to a power of 2, realloc may get a different block if you ask for less space.</p><p>   检查Malloc或Realloc的每一个呼叫，看看ITReturned Null。即使您正在制作较小的块，也要检查Realloc;在将块大小的系统中舍入到2的系统中，如果您要求更少的空间，Realloc可能会得到一个不同的块。</p><p> You must expect  free to alter the contents of the block that wasfreed. Anything you want to fetch from the block, you must fetch beforecalling  free.</p><p> 您必须预计会免费更改群体的内容。您想要从块中获取的任何内容，您必须自由获取Beforecall。 </p><p> If  malloc fails in a noninteractive program, make that a fatalerror. In an interactive program (one that reads commands from theuser), it is better to abort the command and return to the commandreader loop. This allows the user to kill other processes to free upvirtual memory, and then try the command again.</p><p>如果Malloc在非交互式程序中失败，则使那是一个致命的。在交互式程序（从读取器读取命令的程序中，最好中止命令并返回CommandReader循环。这允许用户终止其他进程释放释放上升存储器，然后再次尝试该命令。</p><p>   When static storage is to be written in during program execution, useexplicit C code to initialize it. This way, restarting the program(without reloading it), or part of it, will reinitialize thosevariables. Reserve C initialized declarations for data that will notbe changed.</p><p>   当在程序执行期间要写入静态存储时，请使用C代码以初始化它。这样，重新启动程序（不重新加载它）或其中的一部分，将重新初始化那个批次。保留c未更改的数据初始化声明。</p><p> Try to avoid low-level interfaces to obscure Unix data structures (suchas file directories, utmp, or the layout of kernel memory), since theseare less likely to work compatibly. If you need to find all the filesin a directory, use  readdir or some other high-level interface.These are supported compatibly by GNU.</p><p> 尽量避免低级接口来遮挡UNIX数据结构（如诸如文件目录，UTMP或内核内存的布局），因为该镜头不太可能兼容地工作。如果您需要查找目录的所有文件，请使用ReadDir或其他一些高级接口。这些是GNU兼容支持。</p><p>  The preferred signal handling facilities are the BSD variant of signal, and the POSIX  sigaction function; thealternative USG  signal interface is an inferior design.</p><p>  优选的信号处理设施是信号的BSD变体，以及POSIX SIGACTION功能; TheAlternative USG信号接口是一个劣等的设计。</p><p> Nowadays, using the POSIX signal functions may be the easiest wayto make a program portable. If you use  signal, then on GNU/Linuxsystems running GNU libc version 1, you should include bsd/signal.h instead of  signal.h, so as to get BSDbehavior. It is up to you whether to support systems where signal has only the USG behavior, or give up on them.</p><p> 如今，使用POSIX信号函数可以是制作程序的最简单的方法。如果您使用信号，那么在运行GNU / Linuxsystems上运行GNU Libc版本1，您应该包括BSD / signal.h而不是信号.h，以获得bsdbehavior。由您是否支持信号只有USG行为的系统，或者放弃它们。</p><p>  In error checks that detect “impossible” conditions, just abort.There is usually no point in printing any messag</p><p>  在错误检查中检测到“不可能”的条件，只是abort.here通常在打印任何消息中都没有点</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.gnu.org/prep/standards/standards.html#Semantics">https://www.gnu.org/prep/standards/standards.html#Semantics</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编码标准/">#编码标准</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/coding/">#coding</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>