<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>备忘之前（） Before You Memo()</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Before You Memo()<br/>备忘之前（） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-27 10:38:01</div><div class="page_narrow text-break page_content"><p>There are many articles written about React performance optimizations. In general, if some state update is slow, you need to:</p><p>有很多关于React性能优化的文章。通常，如果某些状态更新很慢，则需要：</p><p> Verify you’re running a production build. (Development builds are intentionally slower, in extreme cases even by an order of magnitude.)</p><p> 确认您正在运行生产版本。 （在极端情况下，开发构建有意地变慢，甚至降低了一个数量级。）</p><p> Verify that you didn’t put the state higher in the tree than necessary. (For example, putting input state in a centralized store might not be the best idea.)</p><p> 确认您没有将状态放在树上的位置超过必要的位置。 （例如，将输入状态放置在集中存储中可能不是最好的主意。）</p><p> Run React DevTools Profiler to see what gets re-rendered, and wrap the most expensive subtrees with  memo(). (And add  useMemo() where needed.)</p><p> 运行React DevTools Profiler来查看要重新渲染的内容，并使用memo（）包装最昂贵的子树。 （并在需要的地方添加useMemo（）。）</p><p> This last step is annoying, especially for components in between, and ideally a compiler would do it for you. In the future, it might.</p><p> 最后一步很烦人，尤其是对于介于两者之间的组件而言，理想情况是编译器会为您完成。将来可能会。</p><p> In this post, I want to share two different techniques. They’re surprisingly basic, which is why people rarely realize they improve rendering performance.</p><p> 在本文中，我想分享两种不同的技术。它们非常基础，这就是为什么人们很少意识到他们可以改善渲染性能的原因。</p><p> These techniques are complementary to what you already know! They don’t replace  memo or  useMemo, but they’re often good to try first.</p><p> 这些技术是对您已经知道的知识的补充！它们不会取代备忘或useMemo，但通常最好先尝试一下。 </p><p>   import  { useState  }  from  &#39;react&#39; ; export  default  function  App ( )  {  let  [color , setColor ]  =  useState ( &#39;red&#39; ) ;  return  (         Hello, world!         ) ; } function  ExpensiveTree ( )  {  let now  = performance . now ( ) ;  while  (performance . now ( )  - now  &lt;  100 )  {  // Artificial delay -- do nothing for 100ms  }  return   I am a very slow component tree.  ; }</p><p>从＆＃39; react＆＃39;导入{useState} ;导出默认功能App（）{让[color，setColor] = useState（＆＃39; red＆＃39;）;返回（您好，世界！）； }函数ExpensiveTree（）{现在=性能。现在 （ ） ; while（performance。now（）-now＆lt; 100）{//人工延迟-100ms不做任何操作} return我是一个非常慢的组件树。 ; }</p><p>  The problem is that whenever  color changes inside  App, we will re-render  &lt;ExpensiveTree /&gt; which we’ve artificially delayed to be very slow.</p><p>  问题在于，只要App内部的颜色发生变化，我们都会重新渲染＆lt; ExpensiveTree /＆gt;我们人为地延迟了很慢的时间。</p><p> I could  put  memo() on it and call it a day, but there are many existing articles about it so I won’t spend time on it. I want to show two different solutions.</p><p> 我可以在上面放memo（）并命名为一天，但是已有很多关于它的文章，所以我不会花时间在上面。我想展示两种不同的解决方案。</p><p>  If you look at the rendering code closer, you’ll notice only a part of the returned tree actually cares about the current  color:</p><p>  如果您仔细查看渲染代码，您会发现返回的树中只有一部分实际上在乎当前颜色：</p><p> export  default  function  App ( )  {   let  [color , setColor ]  =  useState ( &#39;red&#39; ) ;  return  (             Hello, world!           ) ; }</p><p> 导出默认功能App（）{让[color，setColor] = useState（＆＃39; red＆＃39;）;返回（您好，世界！）； }</p><p> So let’s extract that part into a  Form component and move state  down into it:</p><p> 因此，让我们将该部分提取到一个Form组件中，然后将状态下移到其中：</p><p> export  default  function  App ( )  {  return  (                 ) ; } function  Form ( )  {   let  [color , setColor ]  =  useState ( &#39;red&#39; ) ;  return  (             Hello, world!       ) ; }</p><p> 导出默认函数App（）{return（）; }函数Form（）{让[color，setColor] = useState（＆＃39; red＆＃39;）;返回（您好，世界！）； } </p><p>    The above solution doesn’t work if the piece of state is used somewhere  above the expensive tree. For example, let’s say we put the  color on the  parent  &lt;div&gt;:</p><p>如果在昂贵的树上方某处使用了状态块，则上述解决方案将无法正常工作。例如，假设我们将颜色放在父级＆lt; div＆gt;上：</p><p> export  default  function  App ( )  {   let  [color , setColor ]  =  useState ( &#39;red&#39; ) ;  return  (            Hello, world!           ) ; }</p><p> 导出默认功能App（）{让[color，setColor] = useState（＆＃39; red＆＃39;）;返回（您好，世界！）； }</p><p>  Now it seems like we can’t just “extract” the parts that don’t use  color into another component, since that would include the parent  &lt;div&gt;, which would then include  &lt;ExpensiveTree /&gt;. Can’t avoid  memo this time, right?</p><p>  现在看来，我们不能仅仅将不使用颜色的部分“提取”到另一个组件中，因为它将包括父级＆lt; div＆gt ;，然后将其包含＆lt; ExpensiveTree /＆gt;。这次无法避免备忘，对不对？</p><p>       export  default  function  App ( )  {  return  (        Hello, world!            ) ; }  function  ColorPicker (  { children  } )  {  let  [color , setColor ]  =  useState ( &#34;red&#34; ) ;  return  (           {children }      ) ; }</p><p>       导出默认功能App（）{return（Hello，world！）; }函数ColorPicker（{children}）{let [color，setColor] = useState（＆＃34; red＆＃34;）;返回（{children}）; }</p><p>  We split the  App component in two. The parts that depend on the  color, together with the  color state variable itself, have moved into  ColorPicker.</p><p>  我们将App组件一分为二。依赖颜色的部分以及颜色状态变量本身已移至ColorPicker。</p><p> The parts that don’t care about the  color stayed in the  App component and are passed to  ColorPicker as JSX content, also known as the  children prop.</p><p> 无关颜色的部分保留在App组件中，并以JSX内容（也称为儿童道具）的形式传递给ColorPicker。</p><p> When the  color changes,  ColorPicker re-renders. But it still has the same  children prop it got from the  App last time, so React doesn’t visit that subtree.</p><p> 当颜色改变时，ColorPicker重新渲染。但是它仍然具有上次从App获得的子道具，因此React不会访问该子树。 </p><p>   Before you apply optimizations like  memo or  useMemo, it might make sense to look if you can split the parts that change from the parts that don’t change.</p><p>在应用诸如memo或useMemo之类的优化之前，先看一下是否可以将变化的部分与不变的部分分开。</p><p> The interesting part about these approaches is that  they don’t really have anything to do with performance, per se. Using the  children prop to split up components usually makes the data flow of your application easier to follow and reduces the number of props plumbed down through the tree. Improved performance in cases like this is a cherry on top, not the end goal.</p><p> 这些方法的有趣之处在于，它们实际上与性能没有任何关系。使用children props拆分组件通常可以使应用程序的数据流更易于跟踪，并减少了遍历整个树的props的数量。在这种情况下，性能的提高是重中之重，而不是最终目标。</p><p>  For example, when  Server Components are stable and ready for adoption, our  ColorPicker component could receive its  children  from the server. Either the whole  &lt;ExpensiveTree /&gt; component or its parts could run on the server, and even a top-level React state update would “skip over” those parts on the client.</p><p>  例如，当服务器组件稳定并准备好采用时，我们的ColorPicker组件可以从服务器接收其子代。整个＆lt; ExpensiveTree /＆gt;组件或其部件可以在服务器上运行，甚至顶级的React状态更新也将“跳过”客户端上的那些部件。</p><p> That’s something even  memo couldn’t do! But again, both approaches are complementary. Don’t neglect moving state down (and lifting content up!)</p><p> 连备忘录都做不到！但是，这两种方法都是互补的。不要忽略向下移动状态（并向上移动内容！）</p><p> Then, where it’s not enough, use the Profiler and sprinkle those memo’s.</p><p> 然后，在不够的地方，使用探查器并撒上那些备忘录。</p><p>   This is not a new idea. It’s a natural consequence of React composition model. It’s simple enough that it’s underappreciated, and deserves a bit more love.</p><p>   这不是一个新的想法。这是React组成模型的自然结果。很简单，它没有被重视，应该得到更多的爱。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://overreacted.io/before-you-memo/">https://overreacted.io/before-you-memo/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/备忘/">#备忘</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memo/">#memo</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/颜色/">#颜色</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>