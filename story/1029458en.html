<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>RISC-V组件讲座讲稿</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">RISC-V组件讲座讲稿</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-17 23:31:17</div><div class="page_narrow text-break page_content"><p>RISC-V assembly is like any other assembly and resembles MIPS assembly. Just like any assembly, we have a list of instructions that incrementally get us closer to our solution.</p><p>RISC-V组件与任何其他组件类似，与MIPS组件相似。就像任何程序集一样，我们有一个指令列表，它会逐渐使我们更接近我们的解决方案。</p><p> We will be using the  riscv-g++ compiler and linking C++ files with assembly files. You will write the assembly files, and the C++ files help make the lab a little bit easier.</p><p>我们将使用riscv-g++编译器并将C++文件与汇编文件链接起来。您将编写程序集文件，而C++文件有助于简化实验。</p><p>   Assembly files end in a  .S (capital S). The compiler includes all stages of compiling, assembling, and linking, but when we pass a file with a capital S, the compiler will skip right to the assembling stage. Although, the capital S allows us to use the pre-processor, whereas a lowercase s will skip all of that.</p><p>部件文件以.S(大写S)结尾。编译器包括编译、汇编和链接的所有阶段，但是当我们传递一个大写为S的文件时，编译器将直接跳到汇编阶段。不过，大写字母S允许我们使用预处理器，而小写字母s将跳过所有这些。</p><p>    RISC-V contains 32 integer registers and 32 floating point registers. Through the ABI names, we reserve some of these registers for certain purposes. For example, all registers that start with a  t for temporary can be used for any purposes. All registers that start with an  a for argument are used for arguments passed to a function. All registers that start with  s (except sp) for saved are registers that are preserved across function calls.</p><p>RISC-V包含32个整数寄存器和32个浮点寄存器。通过ABI名称，我们保留了其中一些用于特定目的的登记簿。例如，所有以t开头表示临时的寄存器都可以用于任何目的。所有以a for参数开头的寄存器都用于传递给函数的参数。对于保存的寄存器，所有以s开头的寄存器(sp除外)都是跨函数调用保留的寄存器。</p><p>    RISC-V contains integer and logic instructions as well as a few memory instructions. RISC-V is a load/store architecture, so integer instruction operands must be registers.</p><p>RISC-V包含整数和逻辑指令以及一些内存指令。RISC-V是加载/存储体系结构，因此整数指令操作数必须是寄存器。</p><p> Loads (dereferences) from memory address (sp + 8) into register t0. lb = load byte, lh = load halfword, lw = load word, ld = load doubleword.</p><p>从存储器地址(sp+8)加载(取消引用)到寄存器t0。Lb=加载字节，lh=加载半字，lw=加载字，ld=加载双字。</p><p> Stores (dereferences) from register t0 into memory address (sp + 8). sb = store byte, sh = store halfword, sw = store word, sd = store doubleword.</p><p>将寄存器t0存储(取消引用)到内存地址(sp+8)。Sb=存储字节，sh=存储半字，SW=存储字，SD=存储双字。</p><p> Adds value of t0 to the value of t1 and stores the sum into a0.</p><p>将t0的值与t1的值相加，并将和存储到a0中。</p><p>   Multiplies the value of t0 to the value of t1 and stores the product in a0.</p><p>将t0的值乘以t1的值，并将乘积存储在a0中。</p><p> Dividies the value of t3 (denominator) from the value of s3 (numerator) and stores the quotient into the register a1.</p><p>将T3(分母)的值除以S3(分子)的值，并将商存储到寄存器A1中。</p><p> Divides the value of t3 (denominator) from the value of s3 (numerator) and stores the remainder into the register a1.</p><p>将T3(分母)的值除以S3(分子)的值，并将余数存储到寄存器A1中。</p><p>  Performs logical AND on operands t3 and s3 and stores the result into the register a3.</p><p>对操作数T3和S3执行逻辑与，并将结果存储到寄存器A3中。</p><p> Performs logical OR on operands t3 and s3 and stores the result into the register a3.</p><p>对操作数T3和S3执行逻辑或，并将结果存储到寄存器A3中。</p><p> Performs logical XOR on operands t3 and s3 and stores the result into the register a3.</p><p>对操作数T3和S3执行逻辑异或，并将结果存储到寄存器A3中。</p><p> Since RISC-V is a reduced instruction set, many instructions that can be completed by using another instruction are left off. For example, the  neg a0, a1 (two&#39;s complement) instruction does not exist. However, this is equivalent to  sub a0, zero, a1. In other words,  0 - a1 is the same as  -a1.</p><p>由于RISC-V是精简指令集，因此许多可以使用另一条指令完成的指令被省略。例如，neg a0，a1(二进制补码)指令不存在。然而，这相当于suba0，0，a1。换句话说，0-A1与-A1相同。</p><p>   The assembler provides for several  pseudoinstructions, which expand into real instructions. For example,  neg above is a pseudoinstruction. Whenever the assembler reads this instruction, it automatically expands it to be the  sub instruction. Below is a list of all pseudoinstructions and their function.</p><p>汇编器提供几条伪指令，这些伪指令扩展成实指令。例如，上面的neg是一条伪指令。每当汇编器读取此指令时，它都会自动将其展开为SUB指令。下面是所有伪指令及其功能的列表。</p><p>     The floating point instructions are prefixed with an  f, such as fld, fsw, for floating-point load doubleword and floating point store word, respectively. The floating point instructions come in two flavors: (1) single-precision and (2) double-precision. You can select which data size you want by adding a suffix, which is either  .s (for single-precision) or  .d (for double-precision).</p><p>浮点指令以诸如fld、fsw的f作为前缀，分别用于浮点加载双字和浮点存储字。浮点指令有两种类型：(1)单精度和(2)双精度。您可以通过添加后缀来选择所需的数据大小，后缀可以是.s(表示单精度)或.d(表示双精度)。</p><p> # Load a double-precision valueflw ft0, 0(sp)# ft0 now contains whatever we loaded from memory + 0flw ft1, 4(sp)# ft1 now contains whatever we loaded from memory + 4fadd.s ft2, ft0, ft1# ft2 is now ft0 + ft1</p><p>#加载双精度值flw ft0，0(Sp)#ft0现在包含我们从内存加载的所有内容+0flw ft1，4(Sp)#ft1现在包含我们从内存加载的任何内容+4fadd.s ft2，ft0，ft1#ft2现在是ft0+ft1。</p><p> Notice in the code above, we used the  fadd.s instruction to tell the RISC-V processor to add two single-precision values (ft0 and ft1) and store it as a single precision value into ft2.</p><p>注意，在上面的代码中，我们使用fadd.s指令告诉RISC-V处理器将两个单精度值(ft0和ft1)相加，并将其作为单精度值存储到ft2中。</p><p> We can convert between double and single precision using the instructions  fcvt.d.s (convert from single into double) or the  fcvt.s.d (convert from double to single).</p><p>我们可以使用指令fcvt.d.s(从单精度转换为双精度)或fcvt.s.d(从双精度转换为单精度)在双精度和单精度之间进行转换。</p><p>   Branching instructions are a way to jump to different parts of your code. If we didn&#39;t have branching instructions, the CPU would just be able to execute one instruction after another. With jumps and branches, we can go to any instruction, even out of order!</p><p>分支指令是跳转到代码的不同部分的一种方式。如果我们没有分支指令，CPU将只能执行一条接一条指令。有了跳跃和分支，我们可以转到任何指令，即使是无序的！</p><p> Branching instructions are how function calls and conditionals are implemented in assembly. Branching refers to the &#34;conditional jump&#34; instructions, such as  beq, bne, bgt, bge, blt, ble for branch-if equals, not equals, greater than, greater than or equals, less than, and less than or equals, respectively.</p><p>分支指令是函数调用和条件在汇编中实现的方式。分支指的是条件跳转指令，例如用于分支的beq、bne、bgt、bge、blt、ble-if等于、不等于、大于、大于或等于、小于和小于或等于。</p><p> The branching instructions take three parameters: the two operands (registers) to compare, and then if that comparison holds true, a memory label of the instruction you want to execute. If the branch condition is false, the branch instruction is ignored and the CPU goes to the next instruction below.</p><p>分支指令有三个参数：要比较的两个操作数(寄存器)，如果比较结果为真，则是要执行的指令的内存标签。如果分支条件为FALSE，则忽略分支指令，并且CPU转到下面的下一条指令。</p><p> # t0 = 0li t0, 0li t2, 10loop_head:bge t0, t2, loop_end# Repeated code goes hereaddi t0, t0, 1j		loop_headloop_end:</p><p>#t0=0li t0，0li t2，10loop_head：bge t0，t2，loop_end#此处重复代码addi t0，t0，1j loop_headloop_end：</p><p>  Notice that I used the &#34;contrary&#34; view of the condition. In a for loop, as long as the condition holds true, we execute the body of the loop. In assembly, I took the opposite. I&#39;m saying if t0 is greater than or equal to t2 (&gt;= is the opposite of &lt;), then jump OUT of the loop and be done.</p><p>请注意，我使用了与条件相反的&#34；视图。在for循环中，只要条件成立，我们就执行循环体。在集会上，我采取了相反的做法。我的意思是，如果t0大于或等于t2(&gt；=与&lt；相反)，则跳出循环并完成。</p><p>    The stack is used for local memory storage. The stack grows from bottom (high memory) to top (low memory), and the bottom of the stack has a dedicated register called  sp for stack pointer.</p><p>堆栈用于本地内存存储。堆栈从底部(高内存)到顶部(低内存)增长，并且堆栈的底部有一个专用寄存器，称为sp，用于堆栈指针。</p><p> Whenever we use the saved registers or if we want to preserve a temporary register across a function call, we must save it on the stack. To allocate from the stack, we subtract. To deallocate, we add. Notice we don&#39;t &#34;clean&#34; the stack. This is why uninitialized variables in C++ are considered &#34;garbage&#34;, since anything left on the stack is still there.</p><p>无论何时使用保存的寄存器，或者如果我们希望在函数调用中保留临时寄存器，都必须将其保存在堆栈上。要从堆栈中分配，我们需要减去。我们补充说，要解除分配。请注意，我们没有清理堆栈。这就是为什么C++中未初始化的变量会被认为是垃圾，因为堆栈上剩下的任何东西都还在那里。</p><p> The stack MUST be aligned to 8, meaning we must always subtract and add a multiple of 8 from/to the stack.</p><p>堆栈必须对齐到8，这意味着我们必须始终从堆栈中减去8的倍数，然后再将8的倍数加到堆栈中。</p><p>  The code above saves the return address on the stack, calls printf, and then when printf returns, we load the old value of the return address back off the stack, and then deallocate by adding 8.</p><p>上面的代码将返回地址保存在堆栈上，调用printf，然后当printf返回时，我们将返回地址的旧值加载回堆栈，然后通过添加8来解除分配。</p><p>   A compiler&#39;s job is to convert .cpp files into assembly files, where an assembler will assemble an assembly file into machine code as an object file. A linker then links all object files together into an executable or into a library.</p><p>编译器的工作是将.cpp文件转换成汇编文件，汇编器将汇编文件汇编成机器代码作为目标文件。然后，链接器将所有目标文件链接到可执行文件或库中。</p><p> We know that our C++ code boils down into assembly, so whatever we can do in C++, we can also do in assembly. I&#39;ve shown some examples above on how to write a for loop, but let&#39;s take a look at the other C++ constructs.</p><p>我们知道我们的C++代码归结为汇编，所以无论我们在C++中能做什么，我们也可以在汇编中做。我已经在上面展示了一些关于如何编写for循环的示例，但是让我们来看看其他的C++构造。</p><p>   Functions are just a memory label to the very first instruction. The application binary interface (ABI) specifies what registers get what parameters and how to return things back and forth. However, all functions have a preamble, which is essentially setting up a stack frame for local storage, and an epilogue, which usually entails loading saved registers and return address and moving the stack pointer before returning.</p><p>函数只是第一条指令的内存标签。应用程序二进制接口(ABI)指定哪些寄存器获取哪些参数，以及如何来回返回内容。然而，所有函数都有一个前导码和一个尾部，前者实质上是为本地存储设置堆栈帧，后者通常需要加载保存的寄存器和返回地址，并在返回前移动堆栈指针。</p><p> my_function: # Prologue addi sp, sp, -32 sd ra, 0(sp) sd a0, 8(sp) sd s0, 16(sp) sd s1, 24(sp) # Epilogue ld ra, 0(sp) ld a0, 8(sp) ld s0, 16(sp) ld s1, 24(sp) addi sp, sp, 32 ret</p><p>My_function：#序言addi sp，sp，-32 sd ra，0(Sp)sd a0，8(Sp)s0，16(Sp)s1，24(Sp)#epilogue ld ra，0(Sp)ld a0，8(Sp)ld s0，16(Sp)ld s1，24(Sp)addi sp，sp，32 ret。</p><p> This code shows that we first allocate 32 bytes from the stack, which is the size of 4 registers. You can see that I subtract all of the necessary space off of the stack first, store the values, run my code, and then execute the epilogue. This was the main purpose for adding an offset to the store and load instructions.</p><p>此代码显示，我们首先从堆栈中分配32个字节，这是4个寄存器的大小。您可以看到，我首先从堆栈中减去所有必要的空间，存储值，运行代码，然后执行结束语。这是向存储和加载指令添加偏移量的主要目的。</p><p> Another thing to note is that I&#39;m storing all caller saved registers. Once again, we must consider all caller saved registers to be destroyed. That includes all temporary, argument, and return address registers. I did save some saved registers above, but recall, if we use the saved registers, we are required to put their original values back in them before we return.</p><p>另一件需要注意的事情是，我正在存储所有调用者保存的寄存器。再一次，我们必须考虑销毁所有调用者保存的寄存器。包括所有临时寄存器、参数寄存器和返回地址寄存器。我确实保存了上面一些保存的寄存器，但是请记住，如果我们使用保存的寄存器，我们需要在返回之前将它们的原始值放回其中。</p><p> We want one prologue and one epilogue. When we call additional functions, we want our stack to be  framed. In programming languages courses, you will hear about stack frames. So, we allocate ourselves ALL of the space necessary for the function, then store to it.</p><p>我们要一个开场白和一个结束语。当我们调用其他函数时，我们希望我们的堆栈是成帧的。在编程语言课程中，您将听说堆栈框架。因此，我们为自己分配函数所需的所有空间，然后存储到其中。</p><p> bne t0, zero, 1f# Code goes here if t0 == 0j 2f 1:bne t1, zero, 1f# Code goes here if t1 == 0j 2f1:# Code goes here if t0 != 0 and t1 != 02:# Dumping point is here.</p><p>Bne t0，0，1f#如果t0==0j 2f 1：bne t1，0，1f#代码转到这里：#如果t1==0j 2f1：#代码转到这里如果t0！=0和t1！=02：#转储点在这里。</p><p> The assembly code above mocks the following C++ code. if (!t0) { // Code goes here if t0 == 0}else if (!t1) { // Code goes here if t1 == 0}else { // Code goes here if t0 != 0 and t1 != 0}// Dumping point is here.</p><p>上面的汇编代码模仿了下面的C++代码。If(！t0){//如果t0==0}则代码转到这里}否则如果(！t1){//代码转到这里如果t1==0}否则{//代码转到这里如果t0！=0并且t1！=0}//转储点在这里。</p><p> If you don&#39;t remember, the label  1f means to go to the numeric label 1 FORWARD of the given position. This is the opposite of  1b, which looks for a numeric label 1 BACKWARDS of the given position.</p><p>如果您不记得，标签1f的意思是转到给定位置前面的数字标签1。这与1b相反，后者向后查找给定位置的数字标签1。</p><p>   Printf requires that the first parameter be a c-style, null-terminated string, which we can create using the  .asciz assembler directive. The following code gives an example of how to use printf.</p><p>Printf要求第一个参数是c样式的、以NULL结尾的字符串，我们可以使用.asciz汇编指令创建该字符串。下面的代码给出了一个如何使用printf的示例。</p><p> .section .rodataprompt: .asciz &#34;Value of t0 = %ld and value of t1 = %ld\n&#34;.section .textmyfunc: addi sp, sp, -8 sd ra, 0(sp) la a0, prompt mv a1, t0 mv a2, t1 call printf ld ra, 0(sp) addi sp, sp, 8 ret</p><p>.section.rodataPrompt：.asciz&#34；t0=%ld和t1=%ld\n&#34；.section.textmyfunc：addi sp，sp，-8 sd ra，0(Sp)la a0，提示mv a1，t0 mv a2，t1调用printf ld ra，0(Sp)addi sp，sp，8 ret。</p><p> The code above shows that we put the first parameter to printf in a0, which is the string we want to output. Then we want to output the values of t0 and t1, so those need to be moved into the other parameter registers a1 and a2, respectively.</p><p>上面的代码显示，我们将第一个参数放入了a0中的printf，这是我们想要输出的字符串。然后我们要输出t0和t1的值，因此需要将它们分别移到其他参数寄存器a1和a2中。</p><p> Anytime you see a function call, you should be thinking about saving the return address register, like I did above. I might not start off by using the stack, but everytime I type &#34;call&#34;, my fingers automatically expect to start typing something to save the RA (return address) register. Also, remember to always deallocate before you return!</p><p>任何时候看到函数调用时，都应该考虑保存返回地址寄存器，就像我上面所做的那样。我可能不是从使用堆栈开始的，但是每次我键入&#34；call&#34；时，我的手指都会自动地期望开始键入一些内容来保存RA(返回地址)寄存器。另外，记住在你回来之前一定要取消分配！</p><p>   We have 8 argument registers a0 through a7. These will be the 8 NON-FLOAT parameters passed to a function. This includes pointers, in which aX will contain a memory address, or pass-by-value, in which aX will contain the actual value. For floating point values only, you will use fa0 through fa7.</p><p>我们有8个参数寄存器a0到a7。这些将是传递给函数的8个非浮点参数。这包括指针，其中AX将包含内存地址，或按值传递，其中AX将包含实际值。仅对于浮点值，您将使用Fa0到Fa7。</p><p> The ABI further states that we have to return an integer value via a0 or a floating point value via fa0.</p><p>ABI进一步指出，我们必须通过a0返回整数值，或者通过Fa0返回浮点值。</p><p> If you have a function that combines integer and floating point, you use whatever number comes first that hasn&#39;t been taken. For example, consider the following prototype.</p><p>如果你有一个结合了整数和浮点数的函数，你可以使用前面没有取的任何数字。例如，考虑以下原型。</p><p> This function requires that int a be in the register a0, int *b have the memory address that b points to in a1, and the value of float c in fa0. Since we return a float, the result must be put into fa0 before executing the  ret instruction.</p><p>此函数要求int a在寄存器a0中，int*b在a1中具有b指向的内存地址，在fa0中具有浮点数c的值。因为我们返回一个浮点数，所以在执行ret指令之前必须将结果放入Fa0。</p><p>   Take note that we use a0, a1, ..., a7. This goes for all sizes, byte, word, doubleword, etc. Remember that we parse out the data size by choosing the instruction. For float versus double, we choose instruction.s versus instruction.d. For example,  fadd.s fa0, ft0, ft1 adds single-precision values and  fadd.d fa0, ft0, ft1 adds double-precision values.</p><p>请注意，我们使用的是a0、a1、...、a7。这适用于所有大小，字节、字、双字等。请记住，我们通过选择指令来解析数据大小。对于FLOAT和DOUBLE，我们选择direction.s和direction.d。例如，fadd.s fa0、ft0、ft1添加单精度值，而fadd.d fa0、ft0、ft1添加双精度值。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://web.eecs.utk.edu/~smarz1/courses/ece356/notes/assembly/">https://web.eecs.utk.edu/~smarz1/courses/ece356/notes/assembly/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/组件/">#组件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/notes/">#notes</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>