<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>着色技巧A Shader Trick</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A Shader Trick<br/>着色技巧</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-25 17:30:09</div><div class="page_narrow text-break page_content"><p>(I was sending an email today about a simple trick we use in the shader system, and it seemed easy and useful to share that email publicly, so, here you go!)</p><p>（我今天发了一封邮件，内容是关于我们在着色器系统中使用的一个简单技巧，公开分享这封邮件似乎很容易，也很有用，所以，给你！）</p><p>  There&#39;s one other place where fog snaps right now, and that is in time -- it is probably pretty easy to fix, though the explanation might be a little unexpected so I am Ccing it to the team as a general knowledge transfer thing.</p><p>那里&#39；这是另一个雾霾突然袭来的地方，这是及时的——这可能很容易修复，尽管解释可能有点出乎意料，所以我把它作为一般知识传授的事情交给了团队。</p><p>  In general, with floating point numbers, there is a problem with loss of precision when you do computations involving large numbers added to small numbers; the small numbers tend to get dropped and go toward zero. This is a general thing about computers, not just graphics (it is the price we pay for being able to pretend we can store real numbers in small amounts of memory). Most of the time it&#39;s not an issue and programmers don&#39;t think about it, but there are some times when it can be an issue.</p><p>一般来说，对于浮点数来说，当你进行大数加小数的计算时，会出现精度损失的问题；小的数字往往会下降并趋于零。这是关于计算机的一个普遍现象，而不仅仅是图形（这是我们为假装可以在少量内存中存储实数而付出的代价）。大多数时候是&#39；这不是一个问题，程序员不会&#39；I don’我想不起来，但有时它会成为一个问题。</p><p>  In shaders, we often want to have a time variable, controlled by the CPU, that we can use to help generate effects. That time variable counts upward, maybe from the time the level started, or the time the game started. If that number is measured in seconds, then after 10 minutes it will be around 600, after 2 hours it will be 7200, etc. If someone leaves the game running for 3 days (a certification requirement on consoles!), it would get up over 250,000.</p><p>在着色器中，我们通常希望有一个由CPU控制的时间变量，可以用来帮助生成效果。这个时间变量向上计数，可能是从关卡开始的时间，也可能是游戏开始的时间。如果这个数字是以秒为单位的，那么10分钟后它将是600左右，2小时后它将是7200，等等。如果有人让游戏运行3天（这是控制台上的认证要求！），价格将超过25万美元。</p><p>  Those numbers don&#39;t seem super big, but at the same time, we also deal with numbers that are small. If the game is running at 60fps (which on PC these days is considered maybe a slow frame rate!), that&#39;s 0.017 seconds per frame, and we might be doing math that involves both this dt and the current time. At which point the ratio of the current time to the frame time is like 250,000 / (1/60) = 15 million. That is really very high and a recipe for all kinds of numerical problems you don&#39;t expect -- if you add the delta time to the current time, in a 32-bit float, the delta time is almost completely destroyed because there is not enough precision in the number. Long before this time, you&#39;d start to see jitteriness in animation, things not matching up to where you&#39;d expect them to be, etc.</p><p>这些数字没有&#39；看起来不是超级大，但同时，我们也处理小的数字。如果游戏以每秒60帧的速度运行（现在在PC上被认为是一种慢帧速！），那&#39；每帧0.017秒，我们可能在做数学运算，包括这个dt和当前时间。此时，当前时间与帧时间的比率为250000/（1/60）=1500万。这真的非常高，而且是你不知道的各种数值问题的秘方&#39；t expect--如果将增量时间加在当前时间上，在32位浮点中，增量时间几乎完全被破坏，因为数字精度不够。很久以前，你&#39；d开始看到动画中的紧张，事情与你的&#39；我希望他们会这样，等等。</p><p>  One way to solve this is not to let the current time grow indefinitely -- at some point, you reset it to 0. You could pick a fixed amount of time, like I don&#39;t know, every minute, and at the end of the minute the time is back at 0 and you keep going. But if you want your effects to be seamless, they all have to match up exactly at the 1-minute boundary, which makes tuning things difficult and annoying. For example, if you want to make a cosine wave that is seamless across time, you can make the wave with a period of 1 minute, or half a minute, or 1/3 a minute, etc, and firstly this is annoying because when designers want to tune stuff, they have to know this, and it&#39;s unwieldy and confusing, and secondly, these numbers cannot be represented exactly in floating-point numbers either, so you&#39;re adding imprecision that way.</p><p>解决这个问题的一种方法是不要让当前时间无限增长——在某个时刻，你可以将其重置为0。你可以选择固定的时间，就像我不知道的那样&#39；I don’我不知道，每一分钟，最后时间回到0，你继续前进。但是如果你想让你的效果天衣无缝，它们必须在1分钟的边界上完全匹配，这使得调整变得困难和恼人。例如，如果你想制作一个无缝跨越时间的余弦波，你可以制作周期为1分钟、半分钟或1/3分钟的余弦波，等等，首先这很烦人，因为当设计师想要调整东西时，他们必须知道这一点，而且它&#39；第二，这些数字也不能用浮点数精确表示，所以你&#39；这样做会增加不精确性。</p><p>  But there is an old graphics programmer trick that solves this very cleanly, that I think has been around for a long time (I first heard of it from Ignacio when we were working on The Witness).</p><p>但有一个古老的图形编程技巧可以非常干净地解决这个问题，我认为这已经存在很长时间了（我第一次从Ignacio那里听说它是在我们处理证人的时候）。</p><p>  For our cosine wave example mentioned above, we are going to be evaluating some function like cos(freq*time*2*PI), where &#39;time&#39; is just the wall clock time according to the game, and &#39;freq&#39; is some parameter controlling the frequency of the cosine wave, that we want it to be very easy for designers to adjust without introducing problems.</p><p>对于上面提到的余弦波例子，我们将评估一些函数，比如cos（freq*time*2*PI），其中&#39；时间&#39；只是游戏中的挂钟时间，而且&#39；频率&#39；是一些控制余弦波频率的参数，我们希望它非常容易为设计师调整，而不引入问题。</p><p>  The constraint you have to meet, for your cosine waves to match up when the timer resets, is that they all have to evaluate to 1 at whatever the max time is -- because when you reset to time = 0, you will get cos(freq*0*2*PI), which is 1. So cos(freq*time_max*2*PI) also has to be 1, in other words, the cosine has to have gone around the circle an integer number of times. Since we have a factor of 2*PI in there, this means that our wave will be flawless any time freq*time_max is an integer.</p><p>当计时器重置时，为了让余弦波匹配，你必须满足的约束条件是，无论最长时间是什么，它们都必须计算为1——因为当你重置为time=0时，你会得到cos（freq*0*2*PI），也就是1。所以cos（freq*time_max*2*PI）也必须是1，换句话说，余弦必须绕圆整数次。因为我们这里有一个2*PI的因子，这意味着我们的波在任何时候都是完美的，freq*time_max是一个整数。</p><p>  How do we ensure that, easily, in a way that people don&#39;t have to think about? Pick, for time_max, a number of seconds that is 10 to some integer power -- for example, 1000. Then, any number you type into a tweak file, that has no more than 3 digits after the decimal, will result in an integer number of times around the circle. For example, if freq = 9.876, we get cos(9.876*1000*2*PI) == cos(9876*2*PI) == 1. This works for any number you pick with 3 digits after the decimal. If you need 4 digits, make time_max 10000, and so forth. If we are reading values from a tweak file, we can round them to the nearest 3 digits before sending them to the shader (and maybe output a warning, that the digits aren&#39;t being used, if the rounded number is appreciably different from the input number, to remind people of this system).</p><p>我们如何以人们不知道的方式轻松地确保这一点&#39；你不需要考虑吗？为time_max选择10到某个整数幂的秒数，例如1000。然后，在调整文件中键入的任何数字（小数点后的数字不超过3位）都将在圆周围产生整数次。例如，如果freq=9.876，我们得到cos（9.876*1000*2*PI）==cos（9876*2*PI）==1。这适用于小数点后有3位数字的任何数字。如果你需要4位数字，那么把时间设为10000，以此类推。如果我们正在从调整文件中读取值，我们可以在将其发送到着色器之前将其四舍五入到最接近的3位数字（如果四舍五入的数字与输入的数字明显不同，可能会输出一条警告，说明这些数字未被使用，以提醒人们注意这个系统）。</p><p>  This works with any periodic function, we just used cosine here as an example. For linear shifts, like scrolling uv coordinates or whatnot, it&#39;s similar -- if you have uv coordinates from 0 to 1, you just need to make sure shift_rate*time_max is an integer in order for the scrolling to be perfect when the time resets. Similarly for the time parameter used to index a flipbook animation.</p><p>这适用于任何周期函数，我们只是以余弦为例。对于线性移位，比如滚动uv坐标或诸如此类，它&#39；s类似——如果uv坐标从0到1，则只需确保shift_rate*time_max是一个整数，以便在时间重置时完美滚动。类似地，时间参数用于索引动画书动画。</p><p>  So the reason the fog is snapping after you play for a while is that the time sent to the shader system gets reset to 0 every 1000 seconds but the fog doesn&#39;t know about this. And the reason for the resetting is to make sure we maintain good precision in the time-based effects in the shaders.</p><p>因此，播放一段时间后雾会捕捉的原因是，发送到着色器系统的时间每1000秒重置为0，但雾不会&#39；我不知道这件事。重置的原因是确保着色器中基于时间的效果保持良好的精度。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/着色/">#着色</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/shader/">#shader</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/时间/">#时间</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>