<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Python中解决序列比对问题</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在Python中解决序列比对问题</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-26 08:18:59</div><div class="page_narrow text-break page_content"><p>Blog JUNTO Contact       How to create a more efficient solution using the  Needleman-Wunsch algorithm and  dynamic programming .</p><p>博客Jto联系如何使用Needleman-Wunsch算法和动态规划创建更有效的解决方案。</p><p>     As output, your goal is to produce an  alignment, which pairs up elements of the sequence. E.g.</p><p>作为输出，您的目标是产生一个比对，将序列的元素配对。例如。</p><p>    While an alignment can have gaps, it cannot change the relative order of thesequence elements. E.g. &#34;CT&#34; cannot be changed into &#34;TC&#34;.</p><p>虽然对齐可以有间隙，但它不能更改序列元素的相对顺序。例如，不能将&#34；CT&#34；更改为&#34；TC&#34；。</p><p> Specifically, your goal is to produce an alignment with  maximal score.Here&#39;s how to calculate the score:</p><p>具体地说，您的目标是获得最高分数。以下是如何计算分数：</p><p>      So, your goal is to take two  sequences and find an  alignment with  maximal score.</p><p>因此，您的目标是获取两个序列，并找到得分最高的序列。</p><p>  For the input, I represent the  sequences as  strings or lists.E.g. I can represent the sequence &#34;CAT&#34; as</p><p>对于输入，我将序列表示为字符串或列表。我可以将序列&#34；cat&#34；表示为。</p><p>     For the output, I represent an  alignment as a  list of tuples of indices (or  None, if there is a gap.)E.g. this alignment:</p><p>对于输出，我将对齐表示为索引元组列表(如果有差距，则为无)。例如，此对齐：</p><p>         I like starting with  brute force solutions when I work on problems.Brute force solutions tend to be simpler to implement and, fairly often, thebrute force solution is &#34;good enough&#34; for the actual inputs that will beencountered.</p><p>当我处理问题时，我喜欢从暴力解决方案开始。暴力解决方案往往更容易实现，而且通常情况下，对于将要遇到的实际输入来说，暴力解决方案是足够好的。</p><p> I start by creating a function that takes two index ranges and iterates overall possible alignments:</p><p>我首先创建一个函数，该函数接受两个索引范围并迭代所有可能的对齐：</p><p> from collections import dequedef all_alignments(x, y): &#34;&#34;&#34;Return an iterable of all alignments of two sequences. x, y -- Sequences. &#34;&#34;&#34; def F(x, y): &#34;&#34;&#34;A helper function that recursively builds the alignments. x, y -- Sequence indices for the original x and y. &#34;&#34;&#34; if len(x) == 0 and len(y) == 0: yield deque() scenarios = [] if len(x) &gt; 0 and len(y) &gt; 0: scenarios.append((x[0], x[1:], y[0], y[1:])) if len(x) &gt; 0: scenarios.append((x[0], x[1:], None, y)) if len(y) &gt; 0: scenarios.append((None, x, y[0], y[1:])) # NOTE: &#34;xh&#34; and &#34;xt&#34; stand for &#34;x-head&#34; and &#34;x-tail&#34;, # with &#34;head&#34; being the front of the sequence, and # &#34;tail&#34; being the rest of the sequence. Similarly for # &#34;yh&#34; and &#34;yt&#34;. for xh, xt, yh, yt in scenarios: for alignment in F(xt, yt): alignment.appendleft((xh, yh)) yield alignment alignments = F(range(len(x)), range(len(y))) return map(list, alignments)</p><p>从集合导入dequedef all_alignments(x，y)：&#34；&#34；&#34；&#34；返回两个序列的所有比对的迭代值。X，y--序列。&#34；&#34；&#34；def F(x，y)：&#34；&#34；&#34；递归构建对齐的辅助函数。X，y-原始x和y.&#34；&#34；&#34；&#34；if len(X)==0和len(Y)==0的序列索引：如果len(X)&gt；0和len(Y)&gt；0：Scenarios.append((x[0]，x[1：]，y[0]，y[1：]))，则产生deque()Scenario=[]if len(X)&gt；0和len(Y)&gt；0：Scenarios.append((x[0]，x[1：]，y[0]，y[1：]))。0：Scenarios.append((x[0]，x[1：]，None，y))If len(Y)&gt；0：Scenarios.append((None，x，y[0]，y[1：]))#备注：&#34；xh&#34；和&#34；x-head&#34；和&#34；x-ail&#34；，#其中&#34；head&#34；和#&#34；尾部&#34；是序列的其余部分。#&#34；yh&#34；和&#34；yt&#34；也是如此。对于方案中的xh、xt、yh、yt：对于F(xt，yt)中的对齐：alignment.appendleft((xh，yh))屈服对齐=F(range(len(X))，range(len(Y)返回映射(列表，对齐)。</p><p>    [[(0, 0), (1, 1), (2, None)], [(0, 0), (1, None), (2, 1)], [(0, 0), (1, None), (2, None), (None, 1)], [(0, 0), (1, None), (None, 1), (2, None)], [(0, 0), (None, 1), (1, None), (2, None)], [(0, None), (1, 0), (2, 1)], [(0, None), (1, 0), (2, None), (None, 1)], [(0, None), (1, 0), (None, 1), (2, None)], [(0, None), (1, None), (2, 0), (None, 1)], [(0, None), (1, None), (2, None), (None, 0), (None, 1)], [(0, None), (1, None), (None, 0), (2, 1)], [(0, None), (1, None), (None, 0), (2, None), (None, 1)], [(0, None), (1, None), (None, 0), (None, 1), (2, None)], [(0, None), (None, 0), (1, 1), (2, None)], [(0, None), (None, 0), (1, None), (2, 1)], [(0, None), (None, 0), (1, None), (2, None), (None, 1)], [(0, None), (None, 0), (1, None), (None, 1), (2, None)], [(0, None), (None, 0), (None, 1), (1, None), (2, None)], [(None, 0), (0, 1), (1, None), (2, None)], [(None, 0), (0, None), (1, 1), (2, None)], [(None, 0), (0, None), (1, None), (2, 1)], [(None, 0), (0, None), (1, None), (2, None), (None, 1)], [(None, 0), (0, None), (1, None), (None, 1), (2, None)], [(None, 0), (0, None), (None, 1), (1, None), (2, None)], [(None, 0), (None, 1), (0, None), (1, None), (2, None)]]</p><p>[[(0，0)，(1，1)，(2，None)]，[(0，0)，(1，None)，(2，1)]，[(0，0)，(1，None)，(2，None)，(None，1)]，[(0，0)，(1，None)，(None，1)，(2，None)]，[(0，0)，(None，1)，(1，None)，(1，None)，(2，None)]，[(0，None)，(1，0)，(2，1)]，[(0，None)，(1，0)，(2，None)，(None，1)]，[(0，None)，(1，0)，(None，1)，(2，None)]，[(0，None)，(1，None)，(2，0)，(None，1)]，[(0，None)，(1，None)]，(2，None)，(None，0)，(None，1)]，[(0，None)，(1，None)，(None，0)，(2，1)]，[(0，None)，(1，None)，(None，0)，(2，None)，(None，1)]，[(0，None)，(1，None)，(None，0)，(None，1)，(2，None)]，[(0，None)，(None，0)，(1，1)，(2，None)]，[(0，None)，(None，0)，(1，None)，(2，1)]，[(0，None)，(None，0)，(1，None)，(2，None)，(None，1)]，[(0，None)，(None，0)，(1，None)，(None，1)，(2，None)]，[(0，None)，(None，0)，(None，1)，(1，None)，(2，None)]，[(None，0)，(0，1)，(1，None)，(2，None)]，[(None，0)，(0，None)，(1，1)，(2，None)]，[(None，0)，(0，None)，(1，None)，(2，1)]，[(None，0)，(0，None)，(1，None)，(2，None)，(None，1)]，[(None，0)，(0，None)，(1，None)，(1，None)，(2，None)]，[(None，0)，(0，None)，(None，1)，(1，None)，(2，None)]，[(None，0)，(None，1)，(0，None)，(1，无)，(2，无)]]。</p><p>  def print_alignment(x, y, alignment): print(&#34;&#34;.join( &#34;-&#34; if i is None else x[i] for i, _ in alignment )) print(&#34;&#34;.join( &#34;-&#34; if j is None else y[j] for _, j in alignment ))x = &#34;CAT&#34;y = &#34;CT&#34;for alignment in all_alignments(x, y): print_alignment(x, y, alignment) print()</p><p>Def PRINT_ALIGNATION(x，y，Alignment)：print(&#34；&#34；.join(&#34；-&#34；如果i不是其他x[i]for i，_in alignment))print(&#34；&#34；.join(&#34；-&#34；如果j不是其他y[j]for_，j对齐))x=&#34；cat&#34；y=&#34；CT&#34；对于ALL_ALIGNMENTS(x，y)中的对齐方式：PRINT_ALIGNATION(x，y，Alignment)print()。</p><p>  Next, I create a function that takes two sequences and an alignment to produce a score:</p><p>接下来，我创建一个函数，该函数采用两个序列和一个比对来产生分数：</p><p> def alignment_score(x, y, alignment): &#34;&#34;&#34;Score an alignment. x, y -- sequences. alignment -- an alignment of x and y. &#34;&#34;&#34; score_gap = -1 score_same = +1 score_different = -1 score = 0 for i, j in alignment: if (i is None) or (j is None): score += score_gap elif x[i] == y[j]: score += score_same elif x[i] != y[j]: score += score_different return score</p><p>Def ALIGNATION_SCORE(x，y，Alignment)：&#34；&#34；&#34；给对齐打分。X，y--序列。对齐--x和y的对齐。&#34；&#34；&#34；Score_Gap=-1 Score_Same=+1 Score_Different=-1 Score=0 for i，j in Alignment：if(i为None)或(j为None)：Score+=Score_Gap Elif x[i]==y[j]：Score+=Score_Same Elif x[i]！=y[j]：Score+=Score_Different返回Score。</p><p>      With these two functions --  all_alignments and  alignment_score -- the brute force solution will search all alignments to find one witha maximal score:</p><p>使用这两个函数--ALL_ALLIGNS和ALIGN_SCORE--强力解决方案将搜索所有的比对，以找到得分最高的一个：</p><p> from functools import partialdef align_bf(x, y): &#34;&#34;&#34;Align two sequences, maximizing the alignment score, using brute force. x, y -- sequences. &#34;&#34;&#34; return max( all_alignments(x, y), key=partial(alignment_score, x, y), )</p><p>从functools导入partaldef align_bf(x，y)：&#34；&#34；&#34；&#34；比对两个序列，使用暴力将比对分数最大化。X，y--序列。&#34；&#34；&#34；返回max(ALL_ALIGNMENTS(x，y)，KEY=PARTIAL(ALLING_SCORE，x，y)，)</p><p>      What&#39;s the  time complexity of this solution? For two sequences of  n and  m elements:</p><p>这个解决方案的时间复杂度是多少？对于n和m元素的两个序列：</p><p> The number of possible alignments is given by the  Delannoy numbers. The number of alignments  D is given by the  recurrencerelation</p><p>可能的路线数目由德尔诺伊数字给出。路线数D由递归关系给出。</p><p> D( n,  m) =  D( n - 1,  m) +  D( n,  m - 1) +  D( n - 1,  m - 1)</p><p>D(n，m)=D(n-1，m)+D(n，m-1)+D(n-1，m-1)。</p><p>  from functools import lru_cache@lru_cache(maxsize=None)def D(n, m): if n == 0 or m == 0: return 1 else: return D(n - 1, m) + D(n, m - 1) + D(n - 1, m - 1)</p><p>从functools导入lru_cache@lru_cache(maxSize=None)def D(n，m)：如果n==0或m==0：返回1否则：返回D(n-1，m)+D(n，m-1)+D(n-1，m-1)。</p><p> D(100,100) is getting close the the  Eddington number, 10e+80 --the estimated number of hydrogen atoms in the observable universe.</p><p>D(100,100)越来越接近爱丁顿数，10e+80--可见宇宙中氢原子的估计数量。</p><p> Computing the alignment score takes time  linear in the sizes of both sequences:  O( n +  m).</p><p>计算比对分数所花费的时间在两个序列的大小上都是线性的：O(n+m)。</p><p>    The brute force solution is simple, but it doesn&#39;t scale well.In practice, sequence alignment is used to analyze sequences of biological data (e.g.  nucleic acid sequences).Given that the size of these sequences can be hundreds or thousands of elementslong, there&#39;s no way that the brute force solution would work for data of thatsize.</p><p>强力解决方案很简单，但规模不大。在实践中，序列比对用于分析生物数据的序列(例如核酸序列)。考虑到这些序列的大小可以是数百或数千个元素的长度，因此暴力解决方案不可能对这种大小的数据起作用。</p><p> In 1970, Saul B. Needleman and Christian D. Wunsch created a faster algorithmto solve this problem: the  Needleman-Wunsch algorithm.(See  &#34;A general method applicable to the search for similarities in the amino acid sequence of two proteins&#34;,  https://doi.org/10.1016/0022-2836(70)90057-4.)The algorithm uses  dynamic programming to solve the sequence alignment problem in O( m n) time.</p><p>1970年，Saul B.Needleman和Christian D.Wunsch创建了一种更快的算法来解决这个问题：Needleman-Wunsch算法。(参见适用于在两个蛋白质的氨基酸序列中搜索相似性的一般方法，https://doi.org/10.1016/0022-2836(70)90057-4.)The算法使用动态规划来解决O(m，n)时间内的序列比对问题。</p><p> Here&#39;s a Python implementation of the Needleman-Wunsch algorithm, based on section 3 of  &#34;Parallel Needleman-Wunsch Algorithm for Grid&#34;:</p><p>这里是Needleman-Wunsch算法的Python实现，基于网格并行Needleman-Wunsch算法的第3节：</p><p> from itertools import productfrom collections import dequedef needleman_wunsch(x, y): &#34;&#34;&#34;Run the Needleman-Wunsch algorithm on two sequences. x, y -- sequences. Code based on pseudocode in Section 3 of: Naveed, Tahir; Siddiqui, Imitaz Saeed; Ahmed, Shaftab. &#34;Parallel Needleman-Wunsch Algorithm for Grid.&#34; n.d. https://upload.wikimedia.org/wikipedia/en/c/c4/ParallelNeedlemanAlgorithm.pdf &#34;&#34;&#34; N, M = len(x), len(y) s = lambda a, b: int(a == b) DIAG = -1, -1 LEFT = -1, 0 UP = 0, -1 # Create tables F and Ptr F = {} Ptr = {} F[-1, -1] = 0 for i in range(N): F[i, -1] = -i for j in range(M): F[-1, j] = -j option_Ptr = DIAG, LEFT, UP for i, j in product(range(N), range(M)): option_F = ( F[i - 1, j - 1] + s(x[i], y[j]), F[i - 1, j] - 1, F[i, j - 1] - 1, ) F[i, j], Ptr[i, j] = max(zip(option_F, option_Ptr)) # Work backwards from (N - 1, M - 1) to (0, 0) # to find the best alignment. alignment = deque() i, j = N - 1, M - 1 while i &gt;= 0 and j &gt;= 0: direction = Ptr[i, j] if direction == DIAG: element = i, j elif direction == LEFT: element = i, None elif direction == UP: element = None, j alignment.appendleft(element) di, dj = direction i, j = i + di, j + dj while i &gt;= 0: alignment.appendleft((i, None)) i -= 1 while j &gt;= 0: alignment.appendleft((None, j)) j -= 1 return list(alignment)</p><p>从itertools导入产品从集合导入dequedef Needleman_Wunsch(x，y)：&#34；&#34；&#34；对两个序列运行Needleman-Wunsch算法。X，y--序列。基于第3节伪码的代码：Naveed，Tahir；Siddiqui，Imitaz Saeed；Ahmed，Shaftab。网格的并行Needleman-Wunsch算法。Https://upload.wikimedia.org/wikipedia/en/c/c4/ParallelNeedlemanAlgorithm.pdf&#34；&#34；&#34；N，M=len(X)，len(Y)s=lambda a，b：int(a==b)DIAG=-1，-1 LEFT=-1，0 UP=0，-1#为范围(N)中的i创建表格F和PTR F={}PTR={}F[-1，-1]=0：对于范围(M)中的j，F[i，-1]=-I：F[-1，j]=-j Option_PTR=DIAG，LEFT，UP FOR I，J in product(Range(N))中的F[i，-1]=-I：F[-1，j]=-j Option_PTR=DIAG，Left，Up for i，j in product(Range(N))，Range(M))：Option_F=(F[i-1，j-1]+s(x[i]，y[j])，F[i-1，j]-1，F[i，j-1]-1，)F[i，j]，Ptr[i，j]=max(zip(Option_F，Option_Ptr))#从(N-1，M-1)倒到(0，0)#以找到最佳对齐。Align=deque()i，j=N-1，M-1 When i&gt；=0，j&gt；=0：Direction=PTR[i，j]if Direction==DIAG：Element=i，j Elif Direction==Left：Element=i，j alignment.appendLeft(Element)di，Dj=Direction i，j=i+di，j+Dj While i&gt；=0：Alignment.appendLeft((i，None))i-=1 When j&gt；=0：alignment.appendLeft((None，j))j-=1个返回列表(对齐)。</p><p>     def align_fast(x, y): &#34;&#34;&#34;Align two sequences, maximizing the alignment score, using the Needleman-Wunsch algorithm. x, y -- sequences. &#34;&#34;&#34; return needleman_wunsch(x, y)align_fast(&#34;CAT&#34;, &#34;CT&#34;)</p><p>Def align_fast(x，y)：&#34；&#34；&#34；&#34；使用Needleman-Wunsch算法对两个序列进行比对，使比对得分最大化。X，y--序列。&#34；&#34；&#34；返回Needleman_Wunsch(x，y)ALIGN_FAST(&#34；CAT&#34；，&#34；CT&#34；)。</p><p>    What&#39;s the  time complexity of this solution? For two sequences of  n and  m elements:</p><p>这个解决方案的时间复杂度是多少？对于n和m元素的两个序列：</p><p>     In this week&#39;s post, you learned how to solve the &#34;Sequence Alignment&#34; problem.You learned how to create a brute force solution that generates every possible alignment.Then you learned that brute force is infeasible for larger sequences: two10-element sequences have over 8,000,000 different alignments! Finally, youlearned how to reimplement the  Needleman-Wunsch algorithm in Python.</p><p>在本周的帖子中，您学习了如何解决序列比对问题。您学习了如何创建可以生成所有可能的比对的强力解决方案。然后，您了解到暴力对于较大的序列是不可行的：两个10个元素的序列有超过800万个不同的比对！。最后，您了解了如何用Python重新实现Needleman-Wunsch算法。</p><p>   If you enjoyed this week&#39;s post, share it with your friends and stay tuned fornext week&#39;s post. See you then!</p><p>如果你喜欢这周的帖子，那就和你的朋友们分享吧，敬请关注下周的帖子。回头见!。</p><p>  (If you spot any errors or typos on this post, contact me via my contact page</p><p>(如果您在此帖子上发现任何错误或打字错误，请通过我的联系页面与我联系。</p><p>.)</p><p>。)</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://johnlekberg.com/blog/2020-10-25-seq-align.html">https://johnlekberg.com/blog/2020-10-25-seq-align.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/序列/">#序列</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sequence/">#sequence</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031069.html"><img src="http://img2.diglog.com/img/2020/10/thumb_ca280e09fd83e1f2f155b5d81ec8893c.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031069.html">Python需要改变吗？</a></div><span class="my_story_list_date">2020-10-25 15:53</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030931.html"><img src="http://img2.diglog.com/img/2020/10/thumb_b6d2f44664370d45e7761c500cdb97d3.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030931.html">对159个国家的17K名开发人员的调查：JavaScript是最受欢迎的语言，有1240万活跃开发人员，紧随其后的是Python，有900万，然后是Java，有820万</a></div><span class="my_story_list_date">2020-10-24 14:8</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030098.html"><img src="http://img2.diglog.com/img/2020/10/thumb_98dc7dcc7c64dcbb78b63fb6fc5684d1.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030098.html">Pylo：几个Prolog引擎的Python前端</a></div><span class="my_story_list_date">2020-10-21 0:7</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030068.html"><img src="http://img2.diglog.com/img/2020/10/thumb_f8f5d529d35334f2fb264d19f656224e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030068.html">Python 3.9</a></div><span class="my_story_list_date">2020-10-20 22:48</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>