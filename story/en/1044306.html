<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>终端多路复用器 Terminal Multiplexers</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Terminal Multiplexers<br/>终端多路复用器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-15 22:25:53</div><div class="page_narrow text-break page_content"><p>It&#39;s easy to take the terminal for granted. After all, modern terminal emulators like gnome-terminal, konsole, and the others included with Linux desktop environments are feature-rich applications that satisfy most of our needs. But sometimes we need more. We need to have multiple shell sessions running in a single terminal. We need to display more than one application in a single terminal. We need to move a running terminal session from one computer to another. In short, we need a  terminal multiplexer.</p><p>将终端视为理所当然很容易。毕竟，现代终端模拟器（例如gnome-terminal，konsole和Linux桌面环境附带的其他终端模拟器）是功能丰富的应用程序，可以满足我们的大多数需求。但是有时候我们需要更多。我们需要在单个终端上运行多个Shell会话。我们需要在一个终端中显示多个应用程序。我们需要将正在运行的终端会话从一台计算机移动到另一台计算机。简而言之，我们需要一个终端多路复用器。</p><p> Terminal multiplexers are programs that can perform these amazing feats. In this adventure, we will look at three examples: GNU screen, tmux, and byobu.</p><p> 终端多路复用器是可以执行这些惊人功能的程序。在这次冒险中，我们将看三个示例：GNU屏幕，tmux和byobu。</p><p>  If we were to go back in time to say, the mid-1980s, we might find ourselves staring at a computer terminal; a box with an 80-column wide, 24-line high display and a keyboard connected to a shared, central Unix computer via an RS-232 serial connection and, possibly, an acoustic-coupler modem and a telephone handset. On the display screen there might be a shell prompt not unlike the prompt we see today during a Linux terminal session. However, unlike today, the computer terminal of the 1980s did not have multiple windows or tabs to display multiple applications or shell sessions. We only had one screen and that was it. Terminal multiplexers were originally developed to help solve this problem. A terminal multiplexer allows multiple sessions and applications to be displayed and managed on a single screen. While modern desktop environments and terminal emulator programs support multiple windows and tabbed terminal sessions, which mitigate the need of terminal multiplexers for some purposes, terminal multiplexers still offer some features that will greatly enhance our command-line experience.</p><p>  如果我们回想一下1980年代中期，我们可能会发现自己盯着计算机终端。一个具有80列宽，24行高显示屏的盒子，以及一个通过RS-232串行连接（可能还有声耦合器调制解调器和电话听筒）连接到共享的中央Unix计算机的键盘。在显示屏幕上，可能会有一个shell提示符，与我们今天在Linux终端会话期间看到的提示符不同。但是，与今天不同，1980年代的计算机终端没有多个窗口或选项卡来显示多个应用程序或Shell会话。我们只有一个屏幕，仅此而已。终端多路复用器最初是为了帮助解决此问题而开发的。终端多路复用器允许在单个屏幕上显示和管理多个会话和应用程序。尽管现代的桌面环境和终端仿真器程序支持多个窗口和选项卡式终端会话，这减轻了出于某些目的对终端多路复用器的需求，但终端多路复用器仍提供了一些功能，这些功能将大大增强我们的命令行体验。</p><p>  GNU screen goes way back. First developed in 1987, screen appears to be the first program of its type and it defined the basic feature set found in all subsequent terminal multiplexers.</p><p>  GNU屏幕回去了。屏幕最早于1987年开发，似乎是该类型的第一个程序，它定义了所有后续终端多路复用器中发现的基本功能集。</p><p>  As its name implies, GNU screen is part of the GNU Project. Though it is rarely installed by default, it is available in most distribution repositories as the package &#34;screen&#34;.</p><p>  顾名思义，GNU屏幕是GNU工程的一部分。尽管默认情况下很少安装它，但它在大多数发行版本存储库中均以＆＃34; screen＆＃34;软件包的形式提供。</p><p>  We can start using GNU screen by simply entering the  screen command at the shell prompt. Once the command is launched, we will be presented with a shell prompt.</p><p>  我们只需在shell提示符下输入screen命令即可开始使用GNU屏幕。启动命令后，将显示一个shell提示。</p><p>  At this point,  screen is running and has created its first  window . The terminology used by screen is a little confusing. It is best to think of it this way: screen manages a  session consisting of one or more  windows each containing a shell or other program. Furthermore,  screen can divide a terminal display into multiple  regions, each displaying the contents of a window.</p><p>  此时，屏幕正在运行并创建了它的第一个窗口。屏幕使用的术语有些混乱。最好这样考虑：屏幕管理一个由一个或多个窗口组成的会话，每个窗口都包含一个外壳程序或其他程序。此外，屏幕可以将终端显示分为多个区域，每个区域显示一个窗口的内容。 </p><p>  In any case, we have screen running now, and it&#39;s displaying its first window. Let&#39;s enter a command in the current window:</p><p>无论如何，我们现在正在运行屏幕，并且正在显示其第一个窗口。让我们在当前窗口中输入命令：</p><p>   So far, so good. Now, let&#39;s create another window. To do this, we type  Ctrl-a followed by the character &#34;c&#34;. Our terminal screen should clear and we should see a new shell prompt. So what just happened to our first window with  top running in it? It&#39;s still there, running in the background. We can return to the first window by typing  Ctrl-a p (think &#34;p&#34; for &#34;previous&#34;).</p><p>   到现在为止还挺好。现在，让我们创建另一个窗口。为此，我们键入Ctrl-a，后跟字符＆＃34; c＆＃34;。我们的终端屏幕应该清除，并且我们应该看到一个新的shell提示。那么，第一个运行了top的窗口刚刚发生了什么？它仍在后台运行。我们可以通过输入Ctrl-a p返回到第一个窗口（对于上一个＆p34; p认为＆p34; p）。</p><p> Before we go any further, let&#39;s talk about the keyboard. Controlling screen is pretty simple. Every command consists of  Ctrl-a (called the &#34;command prefix&#34; or &#34;escape sequence&#34;) followed by another character. We have already seen two such commands:  Ctrl-a c to create a new window, and  Ctrl-a p to switch from the current window to the previous one. Typing the command  Ctrl-a ? will display a list of all the commands.</p><p> 在继续之前，我们先来谈谈键盘。控制屏幕非常简单。每个命令由Ctrl-a（称为＆＃34;命令前缀＆＃34;或＆＃34;转义序列＆＃34;）组成，后跟另一个字符。我们已经看到了两个这样的命令：Ctrl-a c创建一个新窗口，以及Ctrl-a p从当前窗口切换到上一个窗口。键入命令Ctrl-a吗？将显示所有命令的列表。</p><p> GNU screen has several commands for switching from one window to another. Like the &#34;previous&#34; command, there is a &#34;next&#34; command  Ctrl-a n. Windows are numbered, starting with 0, and may be chosen directly by typing  Ctrl-a followed by a numeral from 0 to 9. It is also possible list all the windows by typing  Ctrl-a &#34;. This command will display a list of windows, where we can choose a window.</p><p> GNU屏幕具有几个命​​令，可从一个窗口切换到另一个窗口。就像上一个命令，有一个＆next＆＃34;命令Ctrl-a n。窗口从0开始编号，可以直接输入Ctrl-a，然后输入0到9进行选择。也可以通过键入Ctrl-a＆＃34;列出所有窗口。该命令将显示窗口列表，我们可以在其中选择一个窗口。</p><p>  As we can see, windows have names. The default name for a window is the name of the program the window was running at the time of its creation, hence both of our windows are named &#34;bash&#34;. Let&#39;s change that. Since we are running  top in our first window, let&#39;s make its name reflect that. Switch to the first window using any of the methods we have discussed, and type the command  Ctrl-a A and we will be prompted for a window name. Simple.</p><p>  如我们所见，窗口具有名称。窗口的默认名称是该窗口在创建时正在运行的程序的名称，因此我们两个窗口都被命名为＆＃34; bash＆＃34;。让我们改变一下。由于我们在第一个窗口中位于顶部，因此让其名称反映出来。使用我们讨论的任何方法切换到第一个窗口，然后键入命令Ctrl-a A，系统将提示您输入窗口名称。简单。</p><p> Okay, so we have created some windows, how do we destroy them? A window is destroyed whenever we terminate the program running in it. After all windows are destroyed,  screen itself will terminate. Since both of our windows are running  bash, we need only exit each respective shell to end our  screen session. In the case of a program that refuses to terminate gracefully,  Ctrl-a k will do the trick.</p><p> 好的，所以我们创建了一些窗口，如何销毁它们？只要我们终止在其中运行的程序，就会破坏一个窗口。销毁所有窗口后，屏幕本身将终止。由于我们两个窗口都运行bash，因此我们只需要退出每个相应的shell即可结束屏幕会话。如果程序拒绝正常终止，则Ctrl-a k可以解决问题。</p><p> Let&#39;s terminate the shell running  top by typing  q to exit  top and then enter  exit to terminate  bash, thereby destroying the first window. We are now taken to the remaining window still running its own copy of  bash. We can confirm this by typing  Ctrl-a &#34; to view the window list again.</p><p> 让我们通过键入q退出top来终止shell运行，然后输入exit终止bash，从而破坏第一个窗口。现在，我们被带到仍然运行其自己的bash副本的其余窗口。我们可以通过输入Ctrl-a＆＃34;来确认这一点。再次查看窗口列表。 </p><p> It&#39;s possible to create windows and run programs without an underlying shell. To do this, we enter  screen followed by the name of the program we wish to run, for example:</p><p>无需基础外壳即可创建窗口和运行程序。为此，我们输入屏幕，然后输入要运行的程序的名称，例如：</p><p>  We can even do this in a  screen window. Issuing a  screen command in a  screen window does not invoke a new copy of  screen. It tells the existing instance of  screen to carry out an operation like creating a new window.</p><p>  我们甚至可以在屏幕窗口中执行此操作。在屏幕窗口中发出屏幕命令不会调用屏幕的新副本。它告诉屏幕的现有实例执行诸如创建新窗口之类的操作。</p><p>  Given that GNU screen was developed for systems that have neither a graphical user interface nor a mouse, it makes sense that screen would provide a way of copying text from one  screen window to another. It does this by entering what is called  scrollback mode. In this mode, screen allows the text cursor to move freely throughout the current window and through the contents of the  scrollback buffer, which contains previous contents of the window.</p><p>  鉴于GNU屏幕是为既没有图形用户界面又没有鼠标的系统开发的，因此有意义的是该屏幕将提供一种将文本从一个屏幕窗口复制到另一个窗口的方式。它通过进入所谓的回滚模式来做到这一点。在这种模式下，屏幕允许文本光标在当前窗口中以及在包含窗口先前内容的回滚缓冲区的内容之间自由移动。</p><p> We start scrollback mode by typing  Ctrl-a [. In scrollback mode we can use the arrow keys and the  Page Up and  Page Down keys to navigate the scrollback buffer. To copy text, we first need to mark the beginning and end of the text we want to copy. This is done by moving the text cursor to the beginning of the desired text and pressing the space bar. Next, we move the cursor to the end of the desired text (which is highlighted as we move the cursor) and press the space bar again to mark the end of the text to be copied. Marking text exits scrollback mode and copies the marked text into screen&#39;s internal buffer. We can now paste the text into any  screen window. To do this, we go to the desired window and type  Ctrl-a ].</p><p> 我们通过输入Ctrl-a [开始滚动模式。在回滚模式下，我们可以使用箭头键以及Page Up和Page Down键来导航回滚缓冲区。要复制文本，我们首先需要标记要复制的文本的开头和结尾。这是通过将文本光标移动到所需文本的开头并按空格键来完成的。接下来，将光标移动到所需文本的结尾（在移动光标时突出显示），然后再次按空格键以标记要复制的文本的结尾。标记文本退出回滚模式，并将标记的文本复制到屏幕的内部缓冲区中。现在，我们可以将文本粘贴到任何屏幕窗口中。为此，我们转到所需的窗口并键入Ctrl-a]。</p><p>   GNU screen can also divide the terminal display into separate regions, each providing a view of a screen window. This allows us to view 2 or more windows at the same time. To split the terminal horizontally, type the command  Ctrl-a S, to split it vertically, type  Ctrl-a |. Newly created regions are empty (i.e., they are not associated with a window). To display a window in a region, first move the focus to the new region by typing  Ctrl-a Tab and then either create a new window, or chose an existing window to display using any of the window selection commands we have already discussed. Regions may be further subdivided to smaller regions and we can even display the same window in more than one region.</p><p>   GNU屏幕还可以将终端显示划分为单独的区域，每个区域提供屏幕窗口的视图。这使我们可以同时查看2个或更多窗口。要水平拆分终端，请键入命令Ctrl-a S，垂直拆分终端，请按Ctrl-a |。新创建的区域为空（即，它们未与窗口关联）。要显示区域中的窗口，请首先通过按Ctrl-a Tab将焦点移至新区域，然后创建一个新窗口，或使用我们已经讨论过的任何窗口选择命令选择一个现有窗口来显示。区域可以进一步细分为较小的区域，我们甚至可以在多个区域中显示相同的窗口。</p><p>  Using multiple regions is very convenient when working with large terminal displays. For example, if we split the display into two horizontal regions, we can edit a script in one region and perform testing of the script in the other. Or we could read a man page in one region and try out a command in the other.</p><p>  当使用大型终端显示器时，使用多个区域非常方便。例如，如果将显示分为两个水平区域，则可以在一个区域中编辑脚本，而在另一个区域中对脚本进行测试。或者，我们可以在一个区域中阅读手册页，然后在另一个区域中尝试命令。</p><p> There are two commands for deleting regions:  Ctrl-a Q removes all regions except the current one, and  Ctrl-a X removes the current region. Note that removing a region does not remove its associated window. Windows continue to exist until they are destroyed.</p><p> 有两个删除区域的命令：Ctrl-a Q删除当前区域以外的所有区域，而Ctrl-a X删除当前区域。请注意，删除区域不会删除其关联的窗口。 Windows一直存在直到被销毁。 </p><p>  Perhaps the most interesting feature of  screen is its ability to detach a session from the terminal itself. Just as it is able to display its windows on any region of the terminal, screen can also display its windows on any terminal or no terminal at all.</p><p>屏幕可能最有趣的功能是它可以将会话与终端本身分离。正如它可以在终端的任何区域上显示其窗口一样，屏幕也可以在任何终端或根本没有终端上显示其窗口。</p><p> For example, we could start a screen session on one computer, say at the office, detach the session from the local terminal, go home and log into our office computer remotely, and reattach the screen session to our home computer&#39;s terminal. During the intervening time, all jobs on our office computer have continued to execute.</p><p> 例如，我们可以在一台计算机上启动一次屏幕会话，例如在办公室，将会话与本地终端分离，回家并远程登录我们的办公室计算机，然后将屏幕会话重新连接到我们的家用计算机终端。在此期间，我们办公室计算机上的所有作业均继续执行。</p><p>  screen -list lists the screen sessions running on a system. If there is more than one session running, the  pid.tty.host string shown in the listing can be appended to the  -d/-D and  -r/-R options below to specify a particular session.</p><p>  screen -list列出系统上运行的屏幕会话。如果有多个会话在运行，可以将清单中显示的pid.tty.host字符串附加到下面的-d / -D和-r / -R选项中，以指定特定的会话。</p><p> screen -d -r detaches a screen session from the previous terminal and reattaches it to the current terminal.</p><p> screen -d -r将屏幕会话与上一个终端分离，并将其重新附加到当前终端。</p><p> screen -D -R detaches a screen session from the previous terminal, logs the user off the old terminal and attaches the session to the new terminal creating a new session if no session existed. According to the  screen documentation, this is the author&#39;s favorite.</p><p> screen -D -R从先前的终端分离屏幕会话，使用户退出旧终端，并将该会话附加到新终端，如果不存在任何会话，则创建新会话。根据屏幕文档，这是作者的最爱。</p><p> The  -d/-D and  -r/-R options can be used independently, but they are most often used together to detach and reattach an existing screen session in a single step.</p><p> -d / -D和-r / -R选项可以单独使用，但是最常一起使用，它们可以在一个步骤中分离和重新连接现有的屏幕会话。</p><p> We can demonstrate this process by opening two terminals. Launch  screen on the first terminal and create a few windows. Now, go to the second terminal and enter the command  screen -D -R. This will the cause the first terminal to vanish (the user is logged off) and the  screen session to move to the second terminal fully intact.</p><p> 我们可以通过打开两个终端来演示此过程。在第一个终端上启动屏幕并创建一些窗口。现在，转到第二个终端并进入命令屏幕-D -R。这将导致第一终端消失（用户已注销），并且屏幕会话完全完整地移至第二终端。 </p><p>  Like many of the interactive GNU utilities, screen is very customizable. During invocation, screen reads the  /etc/screenrc and  ~/.screenrc files if they exist. While the list of customizable features is extensive (many having to do with terminal display control on a variety of Unix and Unix-like platforms), we will concern ourselves with key bindings and startup session configuration since these are the most commonly used.</p><p>像许多交互式GNU实用程序一样，屏幕是非常可定制的。在调用过程中，screen会读取/ etc / screenrc和〜/ .screenrc文件（如果存在）。尽管可定制功能的列表非常广泛（许多与各种Unix和类似Unix的平台上的终端显示控制有关），但由于它们是最常用的，因此我们将关注按键绑定和启动会话配置。</p><p>  # This is a comment# Set some key bindingsbind k # Un-bind the &#34;k&#34; key (set it to do nothing)bind K kill # Make `Ctrl-a K` destroy the current windowbind } history # Make `Ctrl-a }` copy and paste the current # command line# Define windows 7, 8, and 9 at startupscreen -t &#34;mdnght cmdr&#34; 7 mcscreen -t htop 8 htopscreen -t syslog 9 tailf /var/log/syslog</p><p>  ＃这是一个注释＃设置一些键绑定bin k＃取消绑定＆＃34; k＆＃34;键（将其设置为不执行任何操作）bind K kill＃使`Ctrl-a K`破坏当前windowbind}历史记录＃使`Ctrl-a}`复制并粘贴当前＃命令行＃定义窗口7、8和9在启动屏幕上-t＆＃34; mdnght cmdr＆＃34; 7 mcscreen -t htop 8 htopscreen -t syslog 9 tailf / var / log / syslog</p><p> As we can see, the format is pretty simple. The  bind directive is followed by the key and the  screen command it is to be bound to. A complete list of the  screen commands can found in the  screen man page. All of the  screen commands we have discussed so far are simply key bindings like those in the example above. We can redefine them at will.</p><p> 如我们所见，格式非常简单。 bind指令后跟按键和要绑定到的屏幕命令。屏幕命令的完整列表可以在屏幕手册页中找到。到目前为止，我们讨论的所有屏幕命令都是简单的按键绑定，如上面的示例中所示。我们可以随意重新定义它们。</p><p> The three lines at the end of our example screenrc file create windows at startup. The commands set the window title (the  -t option), a window number, and a command for the window to contain. This way, we can set up a  screen session to be automatically built when we start screen which contains a complete multi-window, command-line environment running all of our favorite programs.</p><p> 示例screenrc文件末尾的三行代码在启动时创建窗口。这些命令设置窗口标题（-t选项），窗口编号以及要包含的窗口的命令。这样，我们可以设置一个在启动屏幕时自动构建的屏幕会话，该屏幕会话包含一个运行所有我们喜欢的程序的完整的多窗口命令行环境。</p><p>  Despite its continuing popularity, GNU screen has been criticized for its code complexity (to the point of being called &#34;unmaintainable&#34;) and its resource consumption. In addition, it is reported that screen is no longer actively developed. In response to these concerns, a new program,  tmux, has attracted widespread attention.</p><p>  尽管GNU屏幕一直很受欢迎，但由于其代码复杂性（以至于被称为“不可维护”）和资源消耗而受到批评。另外，据报道，不再积极开发屏幕。针对这些问题，新的程序tmux引起了广泛关注。</p><p> tmux is modern, friendlier, more efficient, and generally superior to  screen in most ways. Conceptually,  tmux is very similar to  screen in that it also supports the concept of sessions, windows and regions (called  panes in tmux). In fact, it even shares a few keyboard commands with  screen.</p><p> tmux是现代的，更友好的，更高效的，并且在大多数方面都优于屏幕。从概念上讲，tmux与屏幕非常相似，因为它还支持会话，窗口和区域（在tmux中称为窗格）的概念。实际上，它甚至与屏幕共享一些键盘命令。</p><p>  tmux is widely available, though not as widely as  screen. It&#39;s available in most distribution repositories but, curiously, it&#39;s not present in Red Hat/CentOS (as of version 6). The package name is &#34;tmux&#34;.</p><p>  tmux可以广泛使用，尽管不如屏幕广泛。它在大多数发行版本存储库中都可用，但是奇怪的是，它在Red Hat / CentOS（从版本6开始）中不存在。软件包名称是＆＃34; tmux＆＃34;。 </p><p>  The program is invoked with the command  tmux new to create a new session. We can optionally add  -s &lt;session_name&gt; to assign a name to the new session and  -n &lt;window_name&gt; to assign a name to the first window. If no option to the  new command is supplied, the  new itself may be omitted; it will be assumed. Here is an example:</p><p>使用命令tmux new调用该程序以创建新会话。我们可以选择添加-s＆lt; session_name＆gt;为新会话分配名称，然后-n＆lt; window_name＆gt;为第一个窗口分配名称。如果没有为新命令提供选项，则可以省略新命令本身；将被假定。这是一个例子：</p><p>  Once the program starts, we are presented with a shell prompt and a pretty status bar at the bottom of the window.</p><p>  程序启动后，在窗口底部将显示一个shell提示和一个漂亮的状态栏。</p><p>   tmux uses the keyboard in a similar fashion to  screen, but rather than using  Ctrl-a as the command prefix,  tmux uses  Ctrl-b. This is good since  Ctrl-a is used when editing the command line in  bash to move the cursor to the beginning of the line.</p><p>   tmux使用键盘的方式类似于屏幕，但是tmux使用Ctrl-b而不是使用Ctrl-a作为命令前缀。这很好，因为在bash中编辑命令行以将光标移动到行首时使用Ctrl-a。</p><p>    Like  screen,  tmux can divide the terminal display into sections called panes. However, unlike the implementation of regions in  screen , panes in  tmux do not merely provide viewports to various windows. In  tmux they are complete pseudo-terminals associated with the window. Thus a single  tmux window can contain multiple terminals.</p><p>    像屏幕一样，tmux可以将终端显示分为几部分，称为窗格。但是，与在屏幕中实现区域不同，tmux中的窗格不仅仅为各种窗口提供视口。在tmux中，它们是与窗口关联的完整伪终端。因此，单个tmux窗口可以包含多个终端。</p><p>  We can demonstrate the behavior of panes by creating a session and a couple of windows. First, we will create a session, name it, and name the initial window:</p><p>  我们可以通过创建一个会话和几个窗口来演示窗格的行为。首先，我们将创建一个会话，命名它​​，并命名初始窗口：</p><p>    We could have done this second step with  Ctrl-b commands, but seeing the command-line method prepares us for something coming up a little later.</p><p>    我们可以使用Ctrl-b命令完成第二步，但是看到命令行方法可以使我们为以后的工作做好准备。</p><p> Assuming that all has gone well, we now find ourselves in a  tmux session named &#34;PaneDemo&#34; and a window named &#34;Window1&#34;. Now we will split the window in two horizontally by typing  Ctrl-b &#34;. We still have only two windows (Window0 and Window1), but now have two shell prompts on Window1. We can switch back and forth between the two panes by typing  Ctrl-b followed by up arrow or down arrow.</p><p> 假设一切顺利，我们现在处于名为＆＃34; PaneDemo＆＃34;的tmux会话中。和一个名为＆＃34; Window1＆＃34;的窗口。现在，我们将通过按Ctrl-b＆＃34;将窗口水平分成两部分。我们仍然只有两个窗口（Window0和Window1），但是Window1上现在有两个shell提示。我们可以在两个窗格之间来回切换，方法是按Ctrl-b，然后按向上箭头或向下箭头。 </p><p> Just for fun, let&#39;s type  Ctrl-b t and a digital clock appears in the current pane. It&#39;s just a cute thing that  tmux can do.</p><p>只是为了好玩，让我们输入Ctrl-b t，数字时钟出现在当前窗格中。这是tmux可以做的一件可爱的事。</p><p>  We can terminate the clock display by typing  q. If we move to the first window by typing  Ctrl-b 0 we see that the panes remain associated with Window1 and have no effect on Window0.</p><p>  我们可以通过输入q来终止时钟显示。如果我们通过输入Ctrl-b 0移到第一个窗口，我们会看到窗格仍与Window1关联，并且对Window0没有影响。</p><p> Returning to Window1, let&#39;s adjust the size of the panes. We do this by typing  Ctrl-b Alt-arrow to move the boundary up or down by 5 lines. Typing  Ctrl-b Ctrl-arrow will move the boundary by 1 line.</p><p> 返回Window1，我们调整窗格的大小。我们可以通过按Ctrl-b Alt-arrow将边界向上或向下移动5行来实现。键入Ctrl-b Ctrl-箭头会将边界移动1行。</p><p> It&#39;s possible to break a pane out into a new window of its own. This is done by typing  Ctrl-b !.</p><p> 可以将窗格拆分成自己的新窗口。这是通过按Ctrl-b！来完成的。</p><p> Ctrl-b x is used to destroy a pane. Note that, unlike  screen, destroying a pane in  tmux also destroys the pseudo-terminal running within it, along with any associated programs.</p><p> Ctrl-b x用于破坏窗格。请注意，与屏幕不同，销毁tmux中的窗格还会销毁其中运行的伪终端以及任何关联程序。</p><p>  Like  screen,  tmux has a copy mode. It is invoked by typing  Ctrl-b [. In copy mode, we can move the cursor freely within the scrollback buffer. To mark text for copying, we first type  Ctrl-space to begin selection, then move the cursor to make our selection. Finally, we type  Alt-w to copy the selected text.</p><p>  像屏幕一样，tmux具有复制模式。通过键入Ctrl-b [来调用它。在复制模式下，我们可以在回滚缓冲区内自由移动光标。要标记要复制的文本，我们首先输入Ctrl-space开始选择，然后移动光标进行选择。最后，我们输入Alt-w复制所选文本。</p><p>  As with the digital clock, we return to normal mode by typing &#34;q&#34;. Now we can paste our copied text by typing  Ctrl-b ].</p><p>  与数字时钟一样，我们通过键入＆＃34; q＆＃34;返回正常模式。现在，我们可以通过按Ctrl-b]粘贴复制的文本。 </p><p>  With  tmux it&#39;s easier to manage multiple sessions than with  screen. First, we can give sessions descriptive names, either during creation, as we saw with our &#34;PaneDemo&#34; example above, or by renaming an existing session with  Ctrl-b $. Second, it&#39;s easy to switch sessions on-the-fly by typing  Ctrl-b s and choosing a session from the presented list.</p><p>使用tmux，比使用屏幕更容易管理多个会话。首先，我们可以在创建过程中为会话提供描述性名称，就像我们在＆＃34; PaneDemo＆＃34;中看到的那样。上面的示例，或者使用Ctrl-b $重命名现有会话。其次，通过键入Ctrl-b并从显示的列表中选择一个会话，可以轻松地即时切换会话。</p><p> While we are in a session, we can type  Ctrl-b d to detach it and, in essence, put  tmux into the background. This is useful if we want to create new a session by entering the  tmux new command.</p><p> 在会话中时，我们可以输入Ctrl-b d来分离它，并实质上将tmux放入后台。如果我们想通过输入tmux new命令来创建新会话，这将很有用。</p><p> If we start a new terminal (or log in from a remote terminal) and wish to attach an existing session to it, we can issue the command  tmux ls to display a list of available sessions. To attach a session, we enter the command  tmux attach -d -t &lt;session_name&gt;. The &#34;-d&#34; option causes the session to be detached from its previous terminal. Without this option, the session will be attached to both its previous terminal and the new terminal.</p><p> 如果启动新终端（或从远程终端登录）并希望将现有会话附加到该终端，则可以发出命令tmux ls以显示可用会话的列表。要附加会话，我们输入命令tmux attach -d -t＆lt; session_name＆gt;。 ＆＃34; -d＆＃34;选项导致会话与其上一个终端分离。没有此选项，会话将同时附加到其先前的终端和新的终端。</p><p>  As we would expect,  tmux is  extremely configurable. When  tmux starts, it reads the files  /etc/tmux.conf and  ~./.tmux.conf if they exist. It is also possible to start  tmux with the  -f option and specify an alternate configuration file. This way, we can have any number of custom configurations.</p><p>  正如我们期望的那样，tmux是非常可配置的。当tmux启动时，它将读取文件/etc/tmux.conf和〜./。tmux.conf（如果存在）。也可以使用-f选项启动tmux并指定备用配置文件。这样，我们可以拥有任意数量的自定义配置。</p><p> The number of configuration commands is extensive, just as it is with  screen. Refer to the  tmux man page for the full list.</p><p> 就像在屏幕上一样，配置命令的数量也很多。有关完整列表，请参见tmux手册页。</p><p> As an example, here is a sample configuration file that changes the command prefix key from  Ctrl-b to  Ctrl-a and creates a new session with 4 windows:</p><p> 例如，这是一个示例配置文件，该文件将命令前缀键从Ctrl-b更改为Ctrl-a，并使用4个窗口创建一个新会话：</p><p> # Sample tmux.conf file# Change the command prefix from Ctrl-b to Ctrl-aunbind-key C-bset-option -g prefix C-abind-key C-a send-prefix###### Create session with 4 windows###### Create session and first windownew-session -d -s MySession# Create second window and vertically split itnew-windowsplit-window -d -h# Create third window (and name it) running Midnight Commandernew-window -d -n MdnghtCmdr mc# Create fourth window (and name it) running htopnew-window -d -n htop htop# Give focus to the first window in the sessionselect-window -t 0</p><p> ＃示例tmux.conf文件＃将命令前缀从Ctrl-b更改为Ctrl-unbind-key C-bset-option -g前缀C-abind-key Ca发送前缀######创建带有4个窗口的会话＃ #####创建会话和第一个窗口new-session -d -s MySession＃创建第二个窗口并垂直分割它new-windowsplit-window -d -h＃创建运行Midnight Commander的第三个窗口new-window -d- n MdnghtCmdr mc＃创建运行htopnew-window -d -n -htop htop＃的第四个窗口（并命名为它）将焦点移至sessionselect-window -t 0中的第一个窗口 </p><p> Since this configuration creates a new session, we should launch  tmux by entering the command  tmux attach to avoid the default behavior of automatically creating a new session. Otherwise, we end up with an additional and unwanted session.</p><p>由于此配置创建了新会话，因此我们应该通过输入命令tmux attach启动tmux，以避免自动创建新会话的默认行为。否则，我们将导致额外的不必要的会话。</p><p>  byobu (pronounced &#34;BEE-oh-boo&#34;) from the Japanese word for &#34;a folding, decorative, multi-panel screen&#34; is not a terminal multiplexer  per se, but rather, it is a wrapper around either GNU screen or tmux (the default is  tmux). It aims to create a simplified user interface with an emphasis on presenting useful system information on the status bar.</p><p>  byobu（发音为BEE-oh-boo＆＃34;），日语为“折叠，装饰性多面板屏风”本身不是终端多路复用器，而是GNU屏幕或tmux（默认为tmux）的包装。它旨在创建一个简化的用户界面，重点是在状态栏上显示有用的系统信息。</p><p>  byobu was originally developed by Canonical employee Dustin Kirkland, and as such is usually found in Ubuntu and other Debian-based distributions. Recent versions are more portable than the initial release, and it is beginning to appear in a wider range of distributions. It is distributed as the package &#34;byobu&#34;.</p><p>  byobu最初是由Canonical员工Dustin Kirkland开发的，因此通常可以在Ubuntu和其他基于Debian的发行版中找到。最新版本比初始版本具有更高的可移植性，并且开始出现在更广泛的发行版中。它作为包＆＃34; byobu＆＃34;分发。</p><p>  byobu can be launched simply by entering the command  byobu followed optionally by any options and commands to be passed to the backend terminal multiplexer (i.e.,  tmux or  screen). For this adventure, we will confine our discussion to the  tmux backend as it supports a larger feature set.</p><p>  只需输入命令byobu，然后可选地输入要传递到后端终端多路复用器（即tmux或screen）的任何选项和命令，即可简单地启动byobu。对于这次冒险，我们将讨论局限于tmux后端，因为它支持更大的功能集。</p><p>   Unlike  screen and  tmux,  byobu doesn&#39;t use a command prefix such as  Ctrl-a to start a command.  byobu relies extensively on function keys instead. This makes  byobu somewhat easier to learn, but in exchange, it gives up some of the power and flexibility of the underlying terminal multiplexer. That said,  byobu still provides an easy-to-use interface for the most useful features and it also provides a key ( F12) which acts as command prefix for  tmux commands. Below is an excerpt from the help file supplied with  byobu when using  tmux as the backend:</p><p>   与screen和tmux不同，byobu不会使用Ctrl-a之类的命令前缀来启动命令。 byobu广泛依赖于功能键。这使得byobu较容易学习，但是作为交换，它放弃了底层终端多路复用器的某些功能和灵活性。也就是说，byobu仍为最有用的功能提供了易于使用的界面，并且还提供了用作tmux命令的命令前缀的键（F12）。以下是使用tmux作为后端时byobu随附的帮助文件的摘录：</p><p> F1 * Used by X11 * Shift-F1 Display this help F2 Create a new window Shift-F2 Create a horizontal split Ctrl-F2 Create a vertical split Ctrl-Shift-F2 Create a new session F3/F4 Move focus among windows Shift-F3/F4 Move focus among splits Ctrl-F3/F4 Move a split Ctrl-Shift-F3/F4 Move a window Alt-Up/Down Move focus among sessions Shift-Left/Right/Up/Down Move focus among splits Ctrl-Shift-Left/Right Move focus among windows Ctrl-Left/Right/Up/Down Resize a split F5 Reload profile, refresh status Shift-F5 Toggle through status lines Ctrl-F5 Reconnect ssh/gpg/dbus sockets Ctrl-Shift-F5 Change status bar&#39;s color randomly F6 Detach session and then logout Shift-F6 Detach session and do not logout Ctrl-F6 Kill split in focus F7 Enter scrollback history Alt-</p><p> F1 *由X11使用* Shift-F1显示此帮助F2创建一个新窗口Shift-F2创建一个水平拆分Ctrl-F2创建一个垂直拆分Ctrl-Shift-F2创建一个新会话F3 / F4在窗口之间移动焦点Shift-F3 / F4在拆分之间移动焦点Ctrl-F3 / F4移动拆分Ctrl-Shift-F3 / F4移动窗口Alt-Up / Down在会话之间移动焦点Shift-左/右/上/下在拆分之间移动焦点Ctrl-Shift-在窗口中向左/向右移动焦点Ctrl-向左/向右/上/下调整大小F5重新加载配置文件，刷新状态Shift-F5切换状态行Ctrl-F5重新连接ssh / gpg / dbus套接字Ctrl-Shift-F5更改状态栏＃39; s随机上色F6分离会话，然后注销Shift-F6分离会话，但不注销Ctrl-F6取消焦点集中的拆分F7输入滚动历史记录Alt-</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.linuxcommand.org/lc3_adv_termmux.php">https://www.linuxcommand.org/lc3_adv_termmux.php</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/多路复用/">#多路复用</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/terminal/">#terminal</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/屏幕/">#屏幕</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>