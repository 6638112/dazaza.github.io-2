<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Serf.io（和Fly.io）构建集群 Building Clusters with Serf.io (and Fly.io)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Building Clusters with Serf.io (and Fly.io)<br/>使用Serf.io（和Fly.io）构建集群 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-15 20:07:59</div><div class="page_narrow text-break page_content"><p>Assume for a second we’d like to see what happens when a web page loads in a browser in Singapore. Easy enough; Fly.io will take a container image you throw at it, transform it into a Firecracker VM, and run it in Singapore.</p><p>假设我们希望看到一秒钟，当网页加载到新加坡的浏览器中时会发生什么。很容易； Fly.io将获取您扔给它的容器图像，将其转换为Firecracker VM，然后在新加坡运行。</p><p>   We want a container that loads a web page in a browser; that sounds like a job for Headless Chromium.  Here’s a Dockerfile; actually, don’t bother, it’s just one of those Dockerfiles that installs the right apt-get packages and then downloads the right Chromium distribution; the entrypoint runs Chromium with the right arguments.</p><p>   我们需要一个在浏览器中加载网页的容器；听起来像无头铬的工作。这是一个Dockerfile；实际上，不要打扰，这只是安装正确的apt-get软件包然后下载正确的Chromium发行版的Dockerfile之一。入口点使用正确的参数运行Chromium。</p><p>     And this will pretty much just work. Say we named the Fly app  ichabod-chrome. When  flyctl deploy finishes, our image will be running as VM somewhere near Singapore, and reachable from around the world as  ichabod-chrome.fly.dev. You could drive the Chrome instance running in Singapore using the  Chrome debug protocol, which has implementations in a ton of languages; for instance, if we want to screenshot a page in Ruby, we could just install the  ferrum gem, and then:</p><p>     这几乎可以正常工作。假设我们将Fly应用命名为ichabod-chrome。当flyctl部署完成时，我们的映像将作为VM在新加坡附近的某个地方运行，并且可以从ichabod-chrome.fly.dev从世界各地访问。您可以使用Chrome调试协议来驱动在新加坡运行的Chrome实例，该协议具有多种语言的实现；例如，如果我们想用Ruby截屏页面，我们可以只安装ferrum gem，然后：</p><p>   Super boring! Neat that it works, though! But there’s, like, an obvious problem here: Chrome Debug Protocol isn’t authenticated, so we’re just kind of hanging out on the Internet hoping nobody does something dumb with the browser proxy we’ve created on this public URL.</p><p>   超级无聊！整洁的工作，但是！但是，这里有一个明显的问题：Chrome调试协议未经身份验证，因此我们只是在互联网上闲逛，希望没人会对我们在此公共URL上创建的浏览器代理做些愚蠢的事情。</p><p>  Let’s fix that. We’ll run our Chrome as a  6PN application, and talk to it over WireGuard. We crack open the  fly.toml that  flyctl generated for us, and add:</p><p>  让我们解决这个问题。我们将Chrome作为6PN应用程序运行，并通过WireGuard与之对话。我们打开flyctl为我们生成的fly.toml，并添加：</p><p>   We also yank out the whole  [[services]] section, because we’re not exposing any public services to health-check anymore. And we change our  entrypoint to bind to its private IPv6 address.</p><p>   我们也取消了整个[[services]]部分，因为我们不再将任何公共服务都接受健康检查。然后，我们更改入口点以绑定到其专用IPv6地址。</p><p>  A  flyctl deploy run loads our “new” application, which speaks CDP only over private IPv6 addresses. But: now we can’t talk to it! We’re not on the private IPv6 network.</p><p>  flyctl部署运行将加载我们的“新”应用程序，该应用程序仅通过专用IPv6地址讲CDP。但是：现在我们不能和它说话！我们不在专用IPv6网络上。 </p><p>  That’s easy to fix:  install WireGuard (it runs everywhere). Then run  flyctl wireguard create, which will generate a WireGuard configuration for us that we can load in our client. Hit the connect button, and we’re good to go again, this time with a cryptographically secure channel to run CDP over. On our internal DNS, which is included in the WireGuard configuration we generate, our app is now reachable at  ichabod-chrome.internal.</p><p>修复起来很容易：安装WireGuard（可在任何地方运行）。然后运行flyctl wireguard create，它将为我们生成一个WireGuard配置，我们可以在客户端中加载该配置。点击“连接”按钮，我们很高兴再次尝试，这次我们使用了加密安全通道来运行CDP。在我们生成的WireGuard配置中包含的内部DNS上，现在可以通过ichabod-chrome.internal访问我们的应用程序。</p><p>   Let’s say we want a bunch of Headless Chromiums, in a bunch of different locations. Maybe we want to screenshot the CNN front page from different countries, or run  Lighthouse tests from around the world. I’m not here to judge your life decisions.</p><p>   假设我们要在一堆不同位置的一堆无头铬。也许我们想截取来自不同国家/地区的CNN首页，或运行来自世界各地的Lighthouse测试。我不是在这里来判断您的人生决定。</p><p>  Getting those Chromium instances up and running is mercifully boring. Let’s say we want roughly to run in Singapore, Sydney, Paris, and Chile:</p><p>  设置和运行这些Chromium实例非常无聊。假设我们要大致在新加坡，悉尼，巴黎和智利进行跑步：</p><p>   … and that’s it; Fly will figure out how to satisfy those constraints and deploy appropriately (we’re asking now for 4 instances, and Fly will try to spread those instances around as many data centers as it can).</p><p>   …就是这样； Fly将找出如何满足这些限制并进行适当部署的方法（我们现在要求4个实例，而Fly将尝试将这些实例分散到尽可能多的数据中心中）。</p><p>  Now, we want to drive these new instances, and do so selectively. To do that, we have to be able to find them. We can use the DNS to do that:</p><p>  现在，我们要驱动这些新实例，并有选择地这样做。为此，我们必须能够找到它们。我们可以使用DNS来做到这一点：</p><p>   And this pretty much works, and you can probably get a long ways just using DNS for instance discovery, especially if your cluster is simple.</p><p>   这几乎是可行的，仅使用DNS进行实例发现，您可能会获得很长的路要走，尤其是在您的群集很简单的情况下。</p><p>  But for me, for this app, this is kind of an annoying place to leave off. I could pick a bunch of nits, but the big one is that there isn’t a good way to automatically get updates when the DNS changes. I can get a pretty good picture of the world when an instance starts up, but I have to go through contortions to update that picture as time ticks on.</p><p>  但是对我来说，对于这个应用程序，这是一个令人讨厌的地方。我可以选择一堆尼特，但是最重要的是，没有一种很好的方法可以在DNS更改时自动获取更新。当实例启动时，我可以获得一幅相当不错的世界图景，但是随着时间的流逝，我必须经过扭曲才能更新该图景。 </p><p>  When we were putting DNS together at Fly, we had the same thoughts. And yet we did nothing about them! We quickly concluded that if people wanted “interesting” service discovery, they could B.Y.O.</p><p>在Fly将DNS整合在一起时，我们有相同的想法。但是我们对它们什么也没做！我们很快得出结论，如果人们想要“有趣的”服务发现，他们可以B.Y.O.</p><p>  Let’s see how that plays out with this cluster. I’m going set up  HashiCorp Serf to make all the components of this cluster aware of each other.</p><p>  让我们看看如何在该集群中发挥作用。我将设置HashiCorp Serf，以使该群集的所有组件相互了解。</p><p>   They do somewhat similar things, but Serf gets less attention than its HashiCorp sibling Consul. Which is a shame, because Serf is a simpler, more approachable system that does 80% of what a lot of people use Consul for.</p><p>   他们做的事情有些相似，但是农奴比其HashiCorp兄弟姊妹领事少受到关注。真可惜，因为Serf是一个更简单，更易接近的系统，可完成许多人使用Consul的80％的工作。</p><p>  A reasonable mental model of Consul is that it’s a distributed system that solves 3 problems:</p><p>  Consul的合理思维模式是它是一个分布式系统，可以解决3个问题：</p><p>    Unlike Consul, Serf handles just one of these problems, #1. In fact, Consul uses Serf under the hood to solve that problem for itself. But Consul is much more complicated to set up. Serf runs without leaders (cluster members come and go, and everybody just figures things out) and no storage requirements.</p><p>    与Consul不同，Serf仅处理这些问题之一，即＃1。实际上，Consul在后台使用Serf自行解决该问题。但是领事馆的建立要复杂得多。农奴在没有领导者的情况下运行（集群成员来来往往，每个人都弄清楚了），并且没有存储需求。</p><p>  Serf is easy. In a conventional configuration — one where we run Serf as a program and not as a library embedded into our application — every node in the cluster runs a Serf agent, which, after installing Serf, is just the  serf agent command. All the configuration can get passed in command line arguments:</p><p>  农奴很容易。在常规配置中（我们将Serf作为程序运行，而不是作为嵌入到应用程序中的库运行），集群中的每个节点都运行Serf代理，在安装Serf之后，它只是serf agent命令。可以在命令行参数中传递所有配置：</p><p>  name = &#34; ${ FLY_APP_NAME } - ${ FLY_REGION } - $( hostname ) &#34;  paddr = $( grep fly-local-6pn /etc/hosts |  cut  -f 1 ) serf agent  \  -node = &#34; $name &#34;  \   -profile =wan  \  -bind = &#34;[ $paddr ]:7777&#34;  \  -tag  role = &#34; ${ FLY_APP_NAME } &#34;  \  -tag  region = &#34; ${ FLY_REGION } &#34;</p><p>  名称=＆＃34; $ {FLY_APP_NAME}-$ {FLY_REGION}-$（主机名）＆＃34; paddr = $（grep fly-local-6pn / etc / hosts | cut -f 1）农奴代理\ -node =＆＃34; $ name＆＃34; \ -profile = wan \ -bind =＆＃34; [$ paddr]：7777＆＃34; \ -tag角色=＆＃34; $ {FLY_APP_NAME}＆＃34; \-标记区域=＆＃34; $ {FLY_REGION}＆＃34; </p><p> There’s not much to it. We give every node a unique name. Serf by default assumes we’re running on a LAN and sets timers accordingly; we switch that to WAN mode. Importantly, we bind Serf to our 6PN private address. Then we set some tags, for our convenience later when selecting members.</p><p>没什么。我们给每个节点一个唯一的名称。默认情况下，Serf假定我们在局域网上运行，并相应地设置计时器；我们将其切换为WAN模式。重要的是，我们将Serf绑定到我们的6PN专用地址。然后，我们设置一些标签，以方便以后选择成员时使用。</p><p>  To help Serf find other members in the cluster and converge on the complete picture of its membership, can make some quick introductions:</p><p>  为了帮助Serf在集群中找到其他成员并了解其成员的完整情况，可以进行一些快速介绍：</p><p>  dig aaaa  &#34; ${ FLY_APP_NAME } .internal&#34; +short |  while  read raddr  ;  do if  [  &#34; $raddr &#34;  !=  &#34; $paddr &#34;  ] ;  then serf  join  &#34; $raddr &#34;  fi done</p><p>  挖aaaa＆＃34; $ {FLY_APP_NAME} .internal＆＃34; +短|同时阅读raddr;如果[＆＃34; $ raddr＆＃34; ！=＆＃34; $ paddr＆＃34; ]；然后农奴加入＆＃34; $ raddr＆＃34;完成</p><p> Here we’re just dumping the current snapshot of the cluster from DNS and using  serf join to introduce those members. Now, if we have nodes Alice, Bob, and Chuck, and Alice introduces herself to Bob and Bob introduces herself to Chuck, Bob will make sure Alice knows about Chuck as well. We’ll talk about how that works in a second.</p><p> 在这里，我们只是从DNS中转储群集的当前快照，并使用serf join引入这些成员。现在，如果我们有节点Alice，Bob和Chuck，并且Alice向Bob介绍了自己，而Bob向Chuck介绍了自己，则Bob将确保Alice也了解Chuck。稍后我们将讨论其工作原理。</p><p>  I wrap these two actions, running the agent and making introductions, up in a  little shell script. Because I’m now running multiple thingies in my Docker image, I use  overmind as my new entrypoint, which drives a  Procfile.  Here’s the whole Dockerfile.</p><p>  我将这两个动作（运行代理并进行介绍）包装在一个小的Shell脚本中。因为我现在在Docker映像中运行多个thingies，所以我将overmind用作驱动Procfile的新入口点。这是整个Dockerfile。</p><p>  What did this get me? Well, from now on, if I’m on the private IPv6 network for my organization, I can find  any node and instantly get a map of all the other nodes:</p><p>  这给我带来了什么？好吧，从现在开始，如果我在组织的专用IPv6网络上，我可以找到任何节点，并立即获得所有其他节点的地图：</p><p>   I can integrate this information with a shell script, but I can also just bring it into my application code directly (here with the relatively simple  serfx gem:</p><p>   我可以将这些信息与Shell脚本集成在一起，但是我也可以直接将其引入我的应用程序代码中（这里是相对简单的serfx gem： </p><p>   I could easily filter this down by location (via the “region”) tag, role, or, as we’ll see in a sec, network closeness. This interface is simpler than DNS, it’s lightning fast, and it’s always up-to-date.</p><p>我可以轻松地按位置（通过“区域”）标签，角色或网络紧密度（如下所述）过滤。该界面比DNS更为简单，闪电般快速，并且始终是最新的。</p><p>   Serf has a security feature: you can key your Serf communications statically, so rogue nodes without the key can’t participate or read messages.</p><p>   Serf具有安全功能：您可以静态设置Serf通信的密钥，因此没有密钥的恶意节点将无法参与或阅读消息。</p><p>  It’s fine, I guess. I’d be nervous if I was deploying Serf in an environment where I was really depending on Serf’s encryption for security. But, frankly, it doesn’t matter to us here, because we’re already running on a private network, and our external connectivity to that network takes advantage of the vastly more sophisticated cryptography in WireGuard.</p><p>  我想很好。如果我在确实依赖Serf加密的安全性环境中部署Serf，我会感到紧张。但是，坦率地说，这对我们来说并不重要，因为我们已经在专用网络上运行，并且与该网络的外部连接利用了WireGuard中极为复杂的加密技术。</p><p>   The first bit of distributed systems jargon that comes up when people describe Serf is SWIM, the “Scalable Weakly-Consistent Infection Membership” protocol. Distributed systems are full of protocols with acronymical names that are hard to get your head around, and SWIM is not one of those; I don’t think you even need a diagram to grok it.</p><p>   人们描述Serf时出现的分布式系统术语的第一位是SWIM，即“可伸缩的弱一致性感染成员身份”协议。分布式系统中充满了带有缩写名称的协议，很难理解，SWIM并不是其中之一。我认为您甚至不需要图来绘制它。</p><p>  You can imagine the simplest possible membership protocol, where you make introductions (like we did in the last section) and every member simply relays messages and tries to connect to every new host it learns about. That’s probably what you’d come up with if you ran into the membership problem unexpectedly in a project and just needed to bang something out to solve it, and it works fine to a point.</p><p>  您可以想象最简单的成员身份协议，在其中进行介绍（就像我们在上一节中所做的那样），每个成员都简单地中继消息并尝试连接到它所了解的每个新主机。如果您在项目中意外遇到成员资格问题，并且只需要敲出一些东西来解决它，这可能就是您想要的，它在某种程度上可以正常工作。</p><p>  SWIM is just a couple heuristic steps forward from that naive protocol, and those steps make the protocol (1) scale better, so you can handle many thousands of nodes, and (2) quickly detect failed nodes.</p><p>  SWIM只是从该朴素协议向前迈出的启发式步骤，这些步骤使协议（1）可以更好地扩展，因此您可以处理成千上万个节点，并且（2）快速检测失败的节点。</p><p>  First, instead of spamming every host we learn about with heartbeats on an interval, we instead select a random subset of them. We essentially just ping each host in that subset; if we get an ACK, we’ve confirmed they’re still members (and, when new nodes connect up to us, we can share our total picture of the world with them to quickly bring them up to date). If we don’t get an ACK, we know something’s hinky.</p><p>  首先，我们不是以一定的间隔向我们学习的每个主机发送垃圾邮件，而是选择一个随机子集。我们实质上只是对该子集中的每个主机执行ping操作。如果收到ACK，则表明他们仍然是成员（并且，当新节点连接到我们时，我们可以与他们共享整个世界的概况，以使它们快速更新）。如果我们没有收到ACK，则说明有些问题。 </p><p>  Now, to keep the group membership picture from flapping every time a ping fails anywhere in the network, we add one more transaction to the protocol: we mark the node we couldn’t ping as SUS, we pick another random subset of nodes, and we ask  them to ping the SUS node for us. If they succeed, they tell us, and the node is no longer SUS. If nobody can ping the node, we finally conclude that the node is the impostor, and eject them from the ship.</p><p>现在，为了防止每次网络中任何地方ping失败时组成员资格图不会震荡，我们向协议中添加了另一个事务：将无法ping的节点标记为SUS，我们选择了另一个随机的节点子集，我们要求他们为我们ping SUS节点。如果成功，他们会告诉我们，该节点不再是SUS。如果没有人可以对节点执行ping操作，我们最终得出结论，该节点是冒名顶替者，然后将其从船上弹出。</p><p>  Serf’s SWIM implementation has  some CS grace notes, but you could bang the basic protocol out in an hour or two if you had to.</p><p>  Serf的SWIM实施具有一些CS宽限说明，但如果需要，您可以在一两个小时内完成基本协议的制定。</p><p>  Serf isn’t just a SWIM implementation, and SWIM isn’t the most interesting part of it. That honor would have to go to the network mapping algorithm  Vivaldi. Vivaldi, which was authored by a collection of my MIT CSAIL heroes including Russ Cox, Frans Kaashoek, and (yes, that) Robert Morris, computes an all-points pairwise network distance map for a cluster.  Here’s a funny thread where Russ Cox finds out, years later, that HashiCorp implemented his paper for Serf.</p><p>  Serf不仅仅是SWIM的实现，SWIM也不是其中最有趣的部分。该荣誉将必须归功于网络映射算法Vivaldi。由我的MIT CSAIL英雄（包括Russ Cox，Frans Kaashoek和（是的）Robert Morris）合集创作的Vivaldi计算了一个群集的所有点成对网络距离图。几年后，拉斯·考克斯（Russ Cox）发现了一条有趣的话题，即HashiCorp为Serf实施了他的论文。</p><p>    We model the members of our cluster as existing in some space. To get your head around it, think of them as having Cartesian 3D coordinates. These coordinates are abstract; they have no relation to real 3D space.</p><p>    我们将集群成员建模为存在于某个空间中。为了让您绕开它，请将它们视为具有笛卡尔3D坐标。这些坐标是抽象的。它们与真实的3D空间无关。</p><p>  To assign nodes coordinates in this space, we attach them to each other with springs of varying (and, to start with, indeterminate) lengths. Our job will be to learn those lengths, which we’ll do by sampling network latency measurements.</p><p>  要在此空间中分配节点坐标，我们需要使用长度可变（并且以不确定为开始）的弹簧将它们相互连接。我们的工作将是学习这些长度，我们将通过采样网络延迟测量来做到这一点。</p><p>  To begin with, we’ll take our collection of spring-connected nodes and squish them down to the origin. The nodes are, to begin with, all sitting on top of each other.</p><p>  首先，我们将收集弹簧连接节点的集合并将其压缩到原点。首先，这些节点都彼此重叠。</p><p>  Then, as we collect measurements from other nodes, we’ll measure error, comparing our distance in the model to the distance reflected by the measurement. We’ll push ourselves away from the nodes we’re measuring in some random direction (by generating a random unit vector), scaled by the error and a sensitivity factor. That sensitivity factor will itself change based on the history of our error measurements, so that we update the model more or less confidently based on the quality of our measurements.</p><p>  然后，当我们从其他节点收集测量值时，我们将测量误差，将模型中的距离与测量值反映的距离进行比较。我们将沿着某个随机方向（通过生成随机单位矢量）将自己从正在测量的节点中移开，并按误差和灵敏度因子进行缩放。该灵敏度因子本身会根据我们的误差测量的历史记录发生变化，因此我们可以根据测量的质量或多或少地自信地更新模型。 </p><p>  Our cluster converges on a set of  network coordinates for all the nodes that, we hope, relatively accurately represents the true network distance between the nodes.</p><p>我们的群集收敛于所有节点的一组网络坐标，我们希望它们可以相对准确地表示节点之间的真实网络距离。</p><p>  This all sounds complicated, and I guess it is, but it’s complicated in the same sense that TCP congestion control (which was originally also based on a physical model) is complicated, not in the sense that, say, Paxos is: the complexity is mostly not exposed to us and isn’t costing meaningful performance. Serf sneaks Vivaldi data into its member updates, so we get them practically for free.</p><p>  这一切听起来都很复杂，我想是的，但是从同样的意义上讲它很复杂，TCP拥塞控制（它最初也基于物理模型）很复杂，而不是说Paxos就是这样：多数情况下不会暴露给我们，也不会牺牲有意义的性能。 Serf将Vivaldi数据潜入其成员更新中，因此我们实际上是免费获得它们。</p><p>  We can now ask Serf to give us the RTT’s between  any two points on the network:</p><p>  现在，我们可以要求Serf为我们提供网络上任意两点之间的RTT：</p><p>   If you’re like me, you read Serf’s description of their Vivaldi implementation and have a record scratch moment when they say they’re using an 8-dimensional coordinate system. What do those coordinates possibly represent? But you can sort of intuitively get your head around it this way:</p><p>   如果您像我一样，请阅读Serf关于其Vivaldi实现的说明，并在他们说自己使用8维坐标系时有一个记录性的擦伤时刻。这些坐标可能代表什么？但是您可以通过以下方式直观地解决问题：</p><p>  Imagine that network performance was entirely dictated by physical distance, so that by sampling RTTs and updating a model what we were effectively doing was recapitulating the physical map of where nodes where. Then, a 2D or 3D coordinate space might effectively model network distance. But we know there are many more factors besides physical distance that impact network distance! We don’t know what they are, but they’re embedded somehow in the measurement data we’re collecting. We want enough dimensionality in our coordinates so that by iteratively and randomly sproinging away from other nodes, we’re capturing all the factors that determine our RTTs, but not so much that the data that we’re collecting is redundant. Anyways, 8 coordinates, plus (again) some grace notes.</p><p>  想象一下，网络性能完全由物理距离决定，因此，通过对RTT进行采样并更新模型，我们有效进行的工作就是概括节点在何处的物理图。然后，2D或3D坐标空间可以有效地建模网络距离。但是我们知道，除了物理距离之外，还有更多因素会影响网络距离！我们不知道它们是什么，但是它们以某种方式嵌入到我们收集的测量数据中。我们希望在坐标中有足够的尺寸，以便通过迭代和随机远离其他节点的方式来捕获确定RTT的所有因素，但并没有那么多，以至于我们收集的数据是多余的。无论如何，要有8个坐标，再加上一些（再次）优雅的注释。</p><p>  Armon Dadger, the CTO of HashiCorp, has a  really excellent talk on Vivaldi that you should just watch if this stuff is interesting to you.</p><p>  HashiCorp的首席技术官Armon Dadger在维瓦尔第（Vivaldi）上发表了非常精彩的演讲，您应该只是看一下这些东西是否对您感兴趣。</p><p>  Frankly, I’m writing about Vivaldi because it’s neat, not because I get a huge amount of value out of it. In theory, Serf’s Vivaldi implementation powers “nearness” metrics in Consul, which in our experience have been good but not great; I’d trust relative distances and orders of magnitude. But RTT’s aside, you could also theoretically take the 8D coordinates themselves and use them to do more interesting modeling, like automatically creating clusters of nearby or otherwise similar nodes.</p><p>  坦率地说，我之所以写有关维瓦尔第的文章是因为它很简洁，而不是因为我从中获得了巨大的价值。从理论上讲，Serf的Vivaldi实施为Consul中的“近邻”指标提供了动力，根据我们的经验，这是很好的，但还不是很好。我相信相对距离和数量级。但是，除了RTT之外，理论上您还可以自己获取8D坐标，并使用它们进行更有趣的建模，例如自动创建附近或其他类似节点的集群。 </p><p>  A last Serf thing to point out: membership is interesting, but if you have a membership protocol, you’re epsilon away from having a messaging system, and Serf does indeed have one of those. You can send  events to a Serf cluster and tell your agent to react to them, and you can define  queries, which are events that generate replies. So, I can set up Serf this way:</p><p>Serf最后要指出的一点是：成员资格很有趣，但是如果您有成员资格协议，那么您就不会拥有消息传递系统，而Serf确实拥有其中之一。您可以将事件发送到Serf群集，并告诉您的代理对它们作出反应，还可以定义查询，这些事件会生成答复。因此，我可以这样设置Serf：</p><p>  serf agent  \  -node = &#34; $name &#34;  \  -profile =wan  \  -bind = &#34;[ $paddr ]:7777&#34;  \  -tag  role = &#34; ${ FLY_APP_NAME } &#34;  \  -tag  region = &#34; ${ FLY_REGION } &#34;  \  -event-handler =query:load = uptime</p><p>  农奴代理\ -node =＆＃34; $ name＆＃34; \ -profile = wan \ -bind =＆＃34; [$ paddr]：7777＆＃34; \ -tag角色=＆＃34; $ {FLY_APP_NAME}＆＃34; \-标记区域=＆＃34; $ {FLY_REGION}＆＃34; \-事件处理程序= query：load =正常运行时间</p><p>   &gt;  $ serf query load Query  &#39;load&#39; dispatchedAck from  &#39;ichabod-iad-bdc999ff&#39;Response from  &#39;ichabod-iad-bdc999ff&#39;: 23:51:58 up 1 day, 19:25, 0  users, load average: 0.00, 0.00, 0.00Ack from  &#39;ichabod-yyz-3a64c0ba&#39;Ack from  &#39;ichabod-ord-401dbe36&#39;Response from  &#39;ichabod-ord-401dbe36&#39;: 23:51:47 up 1 day, 19:25, 0  users, load average: 0.00, 0.00, 0.00Response from  &#39;ichabod-yyz-3a64c0ba&#39;: 23:51:59 up 1 day, 19:26, 0  users, load average: 0.00, 0.00, 0.00Total Acks: 3Total Responses: 3</p><p>   ＆gt; $ serf查询load Query＆＃39; load＆＃39;来自ichabod-iad-bdc999ff＆＃39的dispatchedAck：来自＆＃39; ichabod-iad-bdc999ff＆＃39;的响应：23:51:58最多1天，19：25、0个用户，平均负载：0.00， ＆＃39; ichabod-yyz-3a64c0ba的0.00，0.00Ack＆＃39; ichabod-ord-401dbe36的＆＃39;来自＆＃39; ichabod-ord-401dbe36＆＃39;的响应：23:51： 47天1天，19:25，0用户，平均负载：0.00，0.00，0.00来自＆＃39; ichabod-yyz-3a64c0ba＆＃39;的响应：23:51:59 1天，19:26，0用户，平均负载：0.00、0.00、0.00总攻击次数：3总响应次数：3</p><p> Under the hood, Serf is using  logical timestamps to distribute these messages somewhat (but imperfectly) reliably. I love logical timestamps so much.</p><p> 在幕后，Serf使用逻辑时间戳可靠（但不完美）地分发了这些消息。我非常喜欢逻辑时间戳。</p><p>    So anyways, my point here is, you can do a lot better than DNS for service discovery in a 6PN setup on Fly. Also my point is that Serf is really useful and much, much easier to set up and run than Consul or Zookeeper; you can bake it into a Dockerfile and forget about it.</p><p>    所以无论如何，我的意思是，在Fly的6PN设置中，您可以比DNS做得更好，可以发现服务。我的观点是，Serf确实有用，并且比Consul或Zookeeper更容易设置和运行。您可以将其烘烤到Dockerfile中，而不必理会。</p><p>  Also, my point is that Fly is a pretty easy way to take distributed systems tools like this out for a spin, which you should do! You can boot a Consul cluster up on Fly, or, if you’re an Elixir person, you could use Partisan instead of Serf, which does roughly the same kind of thing.</p><p>  另外，我的观点是，Fly是一种非常简单的方法，可以像这样随意使用分布式系统工具，您应该这样做！您可以在Fly上启动Consul集群，或者，如果您是Elixir，则可以使用Partisan而不是Serf，后者的工作原理大致相同。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fly.io/blog/building-clusters-with-serf/">https://fly.io/blog/building-clusters-with-serf/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/io/">#io</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/clusters/">#clusters</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/serf/">#serf</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>