<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>一个月的地形A Month of Terraform</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A Month of Terraform<br/>一个月的地形</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-23 05:14:26</div><div class="page_narrow text-break page_content"><p>I took Heroku for granted, and a month into setting up my own infra, I now know how much it bought me.</p><p>我将Heroku视为理所当然，并花了一个月的时间建立自己的基础设施，现在我知道它为我带来了多少收益。</p><p> A lot of my past work has been infrastructure-adjacent.I often find myself filling in the Build &amp; Integration role - the person that gets continuous integration off the ground and keeps it actually continuing rather than falling flat on its face.But often I’ve just been building one of a constellation of services, so the core infrastructure was already there,or I’ve been targeting something like Heroku, where you basically pick your poison, git push, and bob’s your uncle.</p><p> 我过去的许多工作都是与基础设施相邻的。我经常发现自己在Build＆Integration角色中工作-这个人要不断地进行整合并保持其持续进行，而不是丢在一边。我刚刚建立了一组服务，所以核心基础结构已经在那里，或者我一直在瞄准Heroku之类的东西，您基本上可以从中选择毒药，git push和bob的叔叔。</p><p> This time, I’m putting the pieces together using the AWS toolkit.And to smoosh them all together, I’m using Terraform,because heck if I’m going to be hand-writing YAML or JSON and praying it’s formatted right.Plus there’s more I want to orchestrate than just AWS, like, say, GitLab.</p><p> 这次，我将使用AWS工具包将各个部分放在一起。为了将所有部分都放在一起，我使用了Terraform，因为如果我要手写YAML或JSON并祈祷其格式正确，那会非常麻烦。除了GWS之外，我还需要整理更多的AWS。</p><p> I don’t wanna talk about AWS just now.It reminds me of learning Foundation &amp; Cocoa - you look at one piece, and it can do so much, and then you gotta put all those individually deep &amp; complex pieces together to do more stuff.I figure if I put in the hours reading docs, learning what’s all there, and getting stabbed by the pointy bits, it’ll probably all come out fine in the end.</p><p> 我现在不想谈论AWS，它使我想起了Foundation和Cocoa的学习-您可以看一看，它可以做很多事情，然后您必须将所有这些单独的，复杂而又复杂的部分放在一起，以做更多的事情我认为，如果我花费大量时间阅读文档，学习其中的全部内容并被尖尖的东西刺伤，那么最终一切都会好起来的。</p><p>   When it doesn’t, it generally fails in a useful way, and then I can fix it and try again.</p><p>   如果没有，通常它会以一种有用的方式失败，然后我可以对其进行修复，然后重试。</p><p>    Terraform: Up &amp; Running is excellent, and Terragrunt makes it even easier. Huge thanks to their team for providing the  duct tape we need. 🙌</p><p>    Terraform：“启动和运行”非常出色，Terragrunt使其更加容易。非常感谢他们的团队提供了我们所需的胶带。 🙌</p><p>  terraform-lsp is supposed to provide autocomplete, but it mostly doesn’t, in my experience. First it flipped its lid that I dared to have a repo with multiple root modules in it, so I just aimed VS Code at the folder with a single root module. Then the language server says it’s all hunky dory AFAICT, and yet it autocompletes nothing beyond bare language syntax. As a result, I’m manually referencing docs and writing stuff down and wasting tons of time that tools like autocomplete and integrated linting ought to be saving me from.</p><p>  根据我的经验，terraform-lsp应该提供自动完成功能，但大多数情况下不提供。首先，它打开盖子，我敢于在其中包含多个根模块的仓库，所以我只是将VS Code对准了具有单个根模块的文件夹。然后，语言服务器说这都是笨拙的AFAICT，但是除了裸语言语法外，它不会自动完成任何操作。结果，我要手动引用文档并写下来的东西，浪费大量时间，因为自动完成和集成棉绒之类的工具应该可以使我免于遭受损失。</p><p> State files contain secrets in plaintext. (You might enjoy the  six-year-old GitHub issue about the plaintext secrets problem.) You can mark outputs as secret, so they don’t get printed at the end of applying your infra spec, but run  terraform show instead of  terraform apply, and there they are, staring back at you. At least you can lock down and encrypt the S3 bucket holding the state. Pulumi’s secrets management is far more satisfying. But Pulumi is even more cutting-edge than v0.whatever Terraform, and I expect Hashicorp to keep TF running for a good while, while I’m not so confident in Pulumi, so I’m using TF. (Hashicorp of course would recommend  Vault.)</p><p>状态文件包含纯文本机密。 （您可能会喜欢有关纯文本秘密问题的已有六年历史的GitHub问题。）您可以将输出标记为秘密，因此在应用基础设施规范时不会输出它们，而是运行terraform show而不是terraform apply ，就在那里，凝视着你。至少您可以锁定并加密保存状态的S3存储桶。 Pulumi的秘密管理要令人满意得多。但是Pulumi比v0还要先进。无论Terraform是什么，我都希望Hashicorp能够使TF运行一段时间，而我对Pulumi不太自信，所以我正在使用TF。 （Hashicorp当然会推荐保险柜。）</p><p> Annoying asymmetries in the language about how you * declare and reference things in slightly variant ways - I trip over these over and over as a beginner: You declare locals in a  locals block, but you reference them as  local.thing, not  locals.thing.</p><p> 关于您如何以稍微不同的方式声明和引用事物的语言中令人讨厌的不对称性-作为初学者，我一遍又一遍地遍历这些不对称性：您在locals块中声明了locals，但是将它们引用为local.thing，而不是locals.thing 。</p><p>  You declare data sources as  data &#34;provider_thingy&#34; &#34;my_name_for_this_data&#34;, and then you have to access it as  data.provider_thingy.my_name_for_this_data. (This is actually pretty darn consistent, at least. Though, like, why the quotes around the provider thingy?)</p><p>  您将数据源声明为数据“ provider_thingy”“ my_name_for_this_data”，然后必须将其作为data.provider_thingy.my_name_for_this_data进行访问。 （至少这实际上是相当一致的。尽管如此，为什么提供商周围的引号很麻烦？）</p><p> You declare resources as  resource &#34;provider_thingy&#34; &#34;my_name&#34;. But you do NOT reference them as  resource.provider_thingy.my_name. Nope, you just reference them as bare  provider_thingy.my_name.</p><p> 您将资源声明为资源“ provider_thingy”“ my_name”。但是您不能将它们引用为resource.provider_thingy.my_name。不，您只需将它们引用为裸provider_thingy.my_name。</p><p> For that matter, there are other oddities as well. Pieces of syntax that seem like they should be orthogonal just aren’t.  for_each stands out here: You can generate multiple resources by just dropping a  for_each in the block:  resource &#34;provider_thing&#34; &#34;mine&#34; {} becomes  resource &#34;provider_thing&#34; &#34;mine&#34; { for_each = of_these }</p><p> 就此而言，还有其他奇怪之处。看起来好像应该正交的语法不是。 for_each在这里脱颖而出：您可以通过在块中放置for_each来生成多个资源：资源“ provider_thing”“ mine” {}变为资源“ provider_thing”“ mine” {for_each = of_these}</p><p> But nested  argument blocks require conversion from like  setting { namespace = &#34;blah&#34; } to  dynamic &#34;setting&#34; { for_each = thingy; content { namespace = &#34;blah&#34; }}. Have fun looking that up a few times.</p><p> 但是嵌套的参数块需要从类似的设置{namespace =“ blah”}转换为动态的“ setting” {for_each = somethingy;内容{名称空间=“ blah”}}。开心地看了几次。</p><p> And you can’t even use the  for_each trick with module imports. It just isn’t supported. Sorry, sucks to be you.</p><p> 而且，甚至无法在模块导入中使用for_each技巧。只是不支持。抱歉，很遗憾成为你。</p><p> Annoying gaps in the docs: Required vs optional parameters are not very clearly called out and are not at all segregated. So you get to play the game of “what is the minimal skeleton to declare this resource”. Actually running it a few times to see what you screwed up takes longer than just looking at the docs and puzzling it out, due to the lengthy iteration times in infra-land (see below).</p><p>文档中令人讨厌的差距：必需参数和可选参数的区别不是很清楚，也根本没有隔离。因此，您可以玩“声明此资源的最小框架是什么”的游戏。实际上，要运行几次以查看所要解决的问题要比仅仅查看文档和使之困惑的时间要长，这是因为在红外中的迭代时间很长（请参见下文）。</p><p> Types are not shown in the docs!!! All the outputs and arguments are typed. You have to declare those types. It’s right there in the code. But the docs don’t say what any of the types are. You just hit a type error at runtime. Fun fun!</p><p> 类型未显示在文档中！！！输入所有输出和参数。您必须声明这些类型。在代码中。但是文档没有说明任何类型。您只是在运行时遇到类型错误。好玩好玩！</p><p> The HCL language is doc’d under the CLI tool, not in and of itself. It was really hard to actually find the docs since my first thought when I have syntax questions isn’t “let’s look at the docs for the tool.” It’d be like pulling up the manpage for GCC (carefully draw your triangle of art first) when you have a question about C syntax.</p><p> HCL语言是通过CLI工具记录的，而不是其本身。实际上很难找到文档，因为当我遇到语法问题时，首先想到的不是“让我们看看该工具的文档”。当您对C语法有疑问时，就好像要拉起GCC的手册页（先仔细画出三角形）。</p><p> Annoying asymmetries in the AWS provider: Missing links: Sometimes you get into a “can’t get there from here” situation. Like trying to find the zone ID for an Elastic Beanstalk environment’s CNAME so you can aim a Route 53 alias at it. (Hint, you need a completely different resource, the  aws_elastic_beanstalk_hosted_zone.)</p><p> AWS提供程序中令人讨厌的不对称性：缺少链接：有时您会遇到“无法从此处到达”的情况。就像尝试为Elastic Beanstalk环境的CNAME查找区域ID一样，您可以将Route 53别名作为目标。 （提示，您需要一个完全不同的资源aws_elastic_beanstalk_hosted_zone。）</p><p> Irregular naming: Sometimes you can fish stuff out by  arn, or maybe by  id, or maybe it’s by  name - good luck. Keep the docs close to hand.</p><p> 命名不规则：有时候您可以通过arn，id或名称来钓鱼，祝您好运。将文档放在手边。</p><p> (It’s totally possible this is inherited from the AWS APIs themselves, but the whole point of an abstraction layer is to make things better and more usable, dangit.)</p><p> （这很有可能是从AWS API本身继承的，但是抽象层的全部目的是使事情变得更好，更有用，dangit。）</p><p>  Iteration times are way longer than with even mobile apps. Like, “you’re liable to task-switch while waiting to see plan output” longer.</p><p>  迭代时间远比移动应用程序长。例如，“您有可能在等待查看计划输出时进行任务切换”。</p><p> Testing is a pain. I haven’t pulled in  Terratest yet, because anyone maintaining this after me is unlikely to have Go experience, and my focus here isn’t builing reusable infra anyway - it’s building  this infra – so I’ve just been using  bats and Bash shell scripts (with  shellcheck, which is amazing) for some after-the-fact sanity checking using the AWS CLI. (Pro tip: Use the community-maintained fork   bats-core rather than the no-longer-maintained sstephenson original.) Policy assertions feel like a different flavor of test, but the tooling here seems to be fairly immature, with perhaps the exception of if you’re targeting Kubernetes.</p><p>测试是痛苦的。我还没有参加Terratest，因为在我之后坚持进行此操作的任何人都不太可能有Go的经验，而且我的关注点不是建立可重复使用的基础结构-它正在构建基础结构-因此，我一直在使用蝙蝠和Bash壳脚本（使用shellcheck，这非常了不起），用于使用AWS CLI进行事后完整性检查。 （专家提示：使用社区维护的fork bats-core，而不是不再维护的sstephenson原作。）策略断言感觉像是一种不同的测试风格，但是这里的工具似乎还很不成熟，也许除了如果您定位Kubernetes。</p><p>  I expect I’ll get used to most of the rough edges of the syntax in another month. And Terraform is stil v0, so hey, maybe some breaking changes will clear all this mess away. 🤞</p><p>  我希望我会在接下来的一个月中习惯语法的大部分粗糙之处。而且Terraform是stil v0，所以，嘿，也许一些重大更改将清除所有这些混乱。 🤞</p><p> I’m intentionally not getting sucked into hacking around the docs frustrations just now. Or even the  very tempting open issue about silencing all the Terragrunt logspew.</p><p> 我刻意不只是现在就沉迷于文档沮丧的黑客活动。甚至是关于使所有Terragrunt logspew静音的非常诱人的公开问题。</p><p> I do plan to spend a bit of time trying to get autocomplete working for resource and data source types and their arguments/attributes from the language server, at least. That would be a huge help.</p><p> 我确实计划花费一些时间，至少从语言服务器上尝试对资源和数据源类型及其参数/属性进行自动完成。那将是巨大的帮助。</p><p> It still feels like magic to run a command and have infrastructure just…happen.You hit return, wait a bit, and suddenly servers are serving and domains are aliasing and a whole constellation of systems are interoperating.It kinda reminds me of the magic of home automation with blinkenlights, only without any of that messy “hardware” stuff to break on you.</p><p> 运行命令并拥有基础设施……这仍然感觉很神奇，您会碰上回车，稍等片刻，然后服务器开始服务，域出现别名，整个系统群都在互操作。这让我想起了魔术带有blinkenlights的家庭自动化系统，而不会给您带来任何麻烦的“硬件”东西。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://jeremywsherman.com/blog/2020/11/21/a-month-of-terraform/">https://jeremywsherman.com/blog/2020/11/21/a-month-of-terraform/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/地形/">#地形</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/month/">#month</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>