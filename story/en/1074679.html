<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>简陋的编年史：布局Humble Chronicles: The Layout</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Humble Chronicles: The Layout<br/>简陋的编年史：布局</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-22 17:03:38</div><div class="page_narrow text-break page_content"><p>This is a second post documenting the process of developing  Humble UI, a Clojure UI framework. In this post, we discuss Humble UI approach to layout.</p><p>这是第二篇文章，记录了开发Humble UI（Clojure UI框架）的过程。在这篇文章中，我们将讨论简单的UI布局方法。</p><p> None of the decisions are complete or final and might change at any time. The main purpose of these posts is to share ideas and get a better understanding of what can work and what can’t. Feedback is welcome!</p><p>这些决定都不是完整的或最终的，可能随时会改变。这些帖子的主要目的是分享想法，更好地理解什么可行，什么不行。欢迎反馈！</p><p>    Logical sizes stay the same between screens, physical sizes vary depending on pixel density and OS settings.</p><p>屏幕之间的逻辑大小保持不变，物理大小取决于像素密度和操作系统设置。</p><p>  Logical pixels are converted to physical ones by multiplying them to UI scale. Old-fashioned 1080p screens usually use UI scale of 1.0. Retina screens use UI scale of 2.0. For Windows and Linux, UI scale could be any number: 1, 1.25, 1.5, 1.75, 2, 2.5 are all reasonable UI scales.</p><p>通过将逻辑像素乘以UI比例，将其转换为物理像素。老式的1080p屏幕通常使用1.0的用户界面比例。视网膜屏幕使用2.0的用户界面比例。对于Windows和Linux，UI规模可以是任何数字：1、1.25、1.5、1.75、2、2.5都是合理的UI规模。</p><p>  By default UI scale is set to OS settings, but could be also arbitrarily adjusted.</p><p>默认情况下，UI比例设置为OS设置，但也可以任意调整。</p><p> So there could be no 20.5 physical px button in Humble UI, but 20.5 logical px—why not? As long as physical result fits the physical pixel grid, we are happy:</p><p>所以在简陋的UI中可能没有20.5物理px按钮，但20.5逻辑px为什么不呢？只要物理结果符合物理像素网格，我们很高兴：</p><p>  UI scale is not a hard-coded number, does not have to match OS setting and everything in Humble UI is scale-aware and ready to render at any scale.</p><p>UI比例不是硬编码的数字，不必匹配操作系统设置，Humble UI中的所有内容都具有比例意识，可以以任何比例呈现。</p><p> By default, it is used to match OS settings, but can also be used to easily zoom your UI per window:</p><p>默认情况下，它用于匹配操作系统设置，但也可用于轻松缩放每个窗口的用户界面：</p><p>       Draw calls are top-down: starting from the outermost container, we divide space and ask internal components to fill it.</p><p>Draw调用是自上而下的：从最外层的容器开始，我们划分空间，并要求内部组件填充它。</p><p> Measures are bottom-up: if you want to measure a container, it asks its children to measure themselves, then combines the results.</p><p>度量是自下而上的：如果你想度量一个容器，它会让它的子容器自己度量，然后结合结果。</p><p> If you put a button directly into a window, it will fill the whole window:</p><p>如果你把一个按钮直接放进一个窗口，它会填满整个窗口：</p><p>  Under the hood, a window will just ask the button to  -draw with a known window size:</p><p>在引擎盖下，一个窗口将只要求按钮使用已知的窗口大小绘制：</p><p>  Alternatively, if you wrap the button with  align to center it, the situation will change:</p><p>或者，如果使用“对齐”将按钮包裹在中间，情况会发生变化：</p><p> align will translate  canvas and then ask the button to  -draw, but with its own previously determined size.</p><p>align将转换画布，然后要求按钮绘制，但要使用之前确定的大小。</p><p>  So far this model proved sufficient enough, we’ll see how much it can handle as Humble UI evolves.</p><p>到目前为止，这个模型已经被证明是足够的，我们将看到随着谦逊用户界面的发展，它能处理多少。</p><p>  Button stretching to the full window might sound counter-intuitive at first, but if you think about it, it’s the only logical thing to do: button inside a container without anything else  must fill the whole container.</p><p>一开始，按钮延伸到整个窗口可能听起来有悖常理，但如果你仔细想想，这是唯一合乎逻辑的做法：容器中的按钮没有任何其他东西，必须填满整个容器。</p><p> Now, if you want different behavior, you must specify it further. Do you want it aligned to the top left corner? Left centered? Centered stretched? None of these sounds like an obvious default, so you must add it explicitly.</p><p>现在，如果您想要不同的行为，您必须进一步指定它。你想让它对准左上角吗？左中？中心拉伸？所有这些听起来都不是一个明显的默认值，所以您必须明确地添加它。</p><p>  Humble UI favors small single-purpose components over settings or modifiers because they tend to compose better.</p><p>与设置或修改器相比，Humble UI更喜欢小型的单一用途组件，因为它们往往组合得更好。</p><p> E.g. there’s no setting on a button to set its width to 300px, but there’s  width component that can set width to any child it contains. Same for vertical/horizontal alignment, padding, etc.</p><p>例如，按钮上没有将其宽度设置为300px的设置，但有一个宽度组件可以将宽度设置为它包含的任何子项。垂直/水平对齐、填充等也一样。</p><p>     Basically you add more and more stuff until you get what you want. Don’t like something, or want to do something differently? Pull it apart, replace, add, all without modifying components themselves.</p><p>基本上你会添加越来越多的东西，直到你得到你想要的。不喜欢某样东西，或者想做一些不同的事情？拆下、更换、添加，所有这些都不需要修改组件本身。</p><p> Looks a little verbose, but hopefully this approach will be more “simple than easy” and faster to understand than, say, CSS.</p><p>看起来有点冗长，但希望这种方法比CSS更“简单而不容易”，更容易理解。</p><p> The tricky part was to figure out a model that actually combines well. At various stages, I’ve seen component stretching or not stretching where expected,  halign not being able to be nested inside  valign and vice versa,  halign not working inside  column/ valign inside  row and many others.</p><p>棘手的部分是找出一个实际结合良好的模型。在不同的阶段，我看到组件在预期的地方拉伸或不拉伸，halign不能嵌套在valign中，反之亦然，halign不能在column/valign inside row中工作，以及许多其他情况。</p><p> But all well that ends well, and I am happy with where we are at right now:</p><p>但一切都很好，结局也很好，我对我们现在的处境感到高兴：</p><p>     If you try to describe it with words, you would say something like “profile picture, profile link and logout link with 10 px between components”.</p><p>如果你试图用文字来描述它，你会说“配置文件图片、配置文件链接和注销链接，组件之间有10像素”。</p><p> We think about 10 px spacing as its own thing, part of the layout, not part of the components. We don’t say “profile picture with 10 px right margin” because that’s not how we think.</p><p>我们认为10px的间距是它自己的东西，是布局的一部分，而不是组件的一部分。我们不说“10像素右边缘的个人资料图片”，因为这不是我们的想法。</p><p> In CSS, however, the way to add spacing between components is to modify components themselves, adding the right margin, like this:</p><p>然而，在CSS中，在组件之间添加间距的方法是修改组件本身，添加右边距，如下所示：</p><p>    Components with margins are hard to reuse. That’s because margins make sense only in a certain context. They belong to the container, not to the component.</p><p>有余量的组件很难重复使用。这是因为利润只有在特定的环境下才有意义。它们属于容器，而不是组件。</p><p>  First/last components need special treatment because you don’t want 10 extra pixels there.</p><p>第一个/最后一个组件需要特殊处理，因为您不需要额外的10个像素。</p><p> Space between components doesn’t naturally belong to one or the other. It’s literally  between them.</p><p>组件之间的空间自然不属于其中一个。这是他们之间的事。</p><p>   Gaps are great because they are simple things that you  add to your layout instead of modifying existing components. Logically they live on the same level as other container children, which is where they belong.</p><p>间隙非常大，因为它们是简单的东西，可以添加到布局中，而不是修改现有组件。从逻辑上讲，他们和其他容器孩子生活在同一个水平上，这就是他们所属的地方。</p><p>  They are also easy to work with and have a simple conceptual model: they are just blocks, like any other block.</p><p>它们也很容易使用，并且有一个简单的概念模型：它们只是块，就像任何其他块一样。</p><p>  Align idea is  stolen from Flutter, with the only difference being that I split horizontal and vertical aligns into two separate components.</p><p>Align的想法是从Flatter中偷来的，唯一的区别是我将水平和垂直对齐分割为两个独立的组件。</p><p> To align something inside a container, you specify two numbers: percentage of the child’s width and percentage of the container’s width.</p><p>要对齐容器内的某个对象，需要指定两个数字：子对象宽度的百分比和容器宽度的百分比。</p><p>    What’s cool about this model is that it gives you all the usual alignment modes:</p><p>这款车型的酷之处在于，它提供了所有常见的对齐模式：</p><p>     If you read my  deep dive into font construction, you know that I don’t like how text is aligned right now on the web. Humble UI feels like a good moment to revisit it and improve on the status quo.</p><p>如果你读过我对字体构造的深入研究，你就会知道我不喜欢现在网络上文本的对齐方式。简陋的用户界面让人觉得是重新审视它、改善现状的好时机。</p><p> In short, text boundaries in Humble UI are defined by baseline and cap-height, not by ascender/descender/em square or any other arbitrary unit.</p><p>简而言之，简陋用户界面中的文本边界是由基线和封顶高度定义的，而不是由上升/下降/em square或任何其他任意单位定义的。</p><p>           But wait, what about ascenders/descenders? They will render outside the boundary box? Yes they will:</p><p>但是等等，上升者/下降者呢？它们将在边界框外渲染？是的，他们会：</p><p>  I don’t consider that a problem because most of the time you add extra padding around text blocks anyway.</p><p>我不认为这是一个问题，因为大多数时候你在文本块周围添加了额外的填充。</p><p>  Remember  calc from CSS? Well, you can do a similar thing in Humble UI, but using plain Clojure code:</p><p>还记得CSS中的calc吗？在简陋的UI中也可以做类似的事情，但使用简单的Clojure代码：</p><p> (ui/width #(-&gt; (:width %) (- (* 3 padding)) (/ 2) (+ padding)) (button &#34;C&#34; color-clear))</p><p>（ui/width#（&gt；（：width%）（（（*3填充））（/2）（+padding））（按钮和#34；C和#34；颜色清晰））</p><p>       Am I missing something else? Do you have an opinion? Make sure to  let me know!</p><p>我还缺什么吗？你有什么意见吗？一定要让我知道！</p><p>     I also create open-source stuff: Fira Code, AnyBar, DataScript and Rum. If you like what I do and want to get early access to my articles (along with other benefits), you should  support me on Patreon.</p><p>我还创建了开源软件：Fira代码、AnyBar、DataScript和Rum。如果你喜欢我所做的，并且想尽早获得我的文章（以及其他好处），你应该在Patreon上支持我。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编年史/">#编年史</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/组件/">#组件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>