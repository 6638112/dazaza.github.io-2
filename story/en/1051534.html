<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么你公司的文档很糟糕 Why Your Company's Documentation Sucks</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why Your Company's Documentation Sucks<br/>为什么你公司的文档很糟糕 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-11 02:42:25</div><div class="page_narrow text-break page_content"><p>There is a common trope about software engineers that they hate to write and maintain documentation. From a shallow view of all of the companies I have worked for, this stereotype seems to hold. Each company has had absolutely garbage documentation: it didn&#39;t exist, it was poorly organized, it was completely out of date, and/or it was written terribly.</p><p>有关他们讨厌编写和维护文档的软件工程师有一个共同的轨迹。从我所努力的所有公司的浅视看法，这种刻板印象似乎持有。每家公司都有绝对垃圾文档：它没有存在，它有点差，它完全过时，和/或它写得非常糟糕。</p><p> Yet, the engineers I have worked with have never been unhelpful; all of them would go out of their way to write long Slack comments or emails or even ad-hoc documents in order to explain concepts or projects. These were all forms of documentation, and extremely useful, but were ephemeral and lost in time (or linked-to in a messy manner).</p><p> 然而，我与之合作的工程师从来没有过上过;所有这些都会竭尽全力编写长时间的懈怠评论或电子邮件甚至是ad-hoc文件，以解释概念或项目。这些都是一切形式的文件，非常有用，但是短暂的，并及时丢失（或以凌乱的方式联系）。</p><p> Interestingly, when a manager came in and tried to force everyone to use &#34;proper&#34; documentation tools, the documentation would get worse! Instead of using ad-hoc methods, which caused you to get yelled at, people just  stopped -- they didn&#39;t start using the &#34;proper&#34; documentation tools. Well, they did, for a little while, but inevitably the &#34;proper&#34; documentation just decayed and eventually nobody used it. My favorite behavior was engineers linking to the documentation in public Slack channels, and then immediately following up in a private correspondence explaining that the docs were terrible and provided a short-hand explanation (the ad-hoc method, but in private).</p><p> 有趣的是，当经理进来时试图强迫每个人使用＆＃34;正确的＆＃34;文档工具，文档会变得更糟！而不是使用ad-hoc方法，这导致你喊道，人们刚刚停止 - 他们在使用＆＃34;正确的＆＃34;文档工具。好吧，他们做了一段时间，但不可避免地是＆＃34;适当的＆＃34;文档刚刚腐烂，最终没有人使用它。我最喜欢的行为是与公共休闲频道中的文档相关联的工程师，然后立即在私人通信中追随解释文档是可怕的并且提供了短手解释（私人方法，但私有）。</p><p> The amount of time and effort spent on ad-hoc documentation shows that software engineers  don&#39;t hate writing documentation. We all know that it saves time and effort, and helps make our coworkers more autonomous. So why the hell is documentation consistently  so bad, and why do engineers spend more effort on ad-hoc documentation than using the proper documentation tooling that the company specifies?</p><p> 在Ad-hoc文件上花费的时间和精力显示软件工程师Don＆＃39; t讨厌写作文件。我们都知道它节省了时间和精力，并有助于使我们的同事更加自主。那么为什么地狱是一个始终如一的文档，为什么工程师在ad-hoc文件上花费更多的努力，而不是使用公司指定的正确文档工具？</p><p> The issue is that the documentation tools that so many companies have standardized on are absolutely garbage for actually writing documentation. And it isn&#39;t just because they are buggy, slow, and/or UX disasters (Confluence I&#39;m looking at you!). The issue is in the way that these documentation tools attempt to organize information. I call it the Tree approach versus the Graph approach.</p><p> 问题是，这么多公司已经标准化的文档工具是绝对垃圾，用于实际编写文件。它是不是因为他们是越野车，慢，和/或ux灾害（Confluence I＆＃39;看着你）。该问题是这些文档工具尝试组织信息的方式。我称之为树方法与图形方法相比。</p><p>  The obvious way to organize information is with a tree. For instance, look at the way filesystems work. We have a hierarchy of files and everything is organized within this system. To find some X piece of information, we can simply start at the top and travel down, choosing the branch which makes the most sense for what we are looking for. For instance, the documentation for a set of projects at a company might look like so:</p><p>  组织信息的显而易见的方法是用树。例如，请查看文件系统的工作方式。我们有一个文件层次结构，在这个系统中组织了所有内容。要查找一些x信息，我们可以简单地从顶部开始行驶，选择该分支，这对我们正在寻找的东西最有意义。例如，公司的一组项目的文档可能如下所示：</p><p> Projects|- Project A| |- Architecture Overview| |- Setup Guide| `- ...||- Project B| |- Architecture Overview| |- Setup Guide| `- ...|`- Project C |- ...</p><p> 项目|  - 项目A | |  - 架构概述| |  - 设置指南| ` -  ... ||  - 项目B | |  - 架构概述| |  - 设置指南| ` -  ... |` - 项目c |  -  ... </p><p> As software engineers, we know that a balanced tree like this has lookup time of  O(log(n)). This seems great: as our collective knowledge grows the amount of effort to find any given part of it is logarithmic to the size of that knowledge, which means we should always be able to find what we&#39;re looking for in a short amount of time. And this is true, for a perfectly organized body of knowledge.</p><p>作为软件工程师，我们知道像这样的平衡树具有O的查找时间（log（n））。这似乎很棒：由于我们的集体知识增长了找到它的任何特定部分的努力，所以对那种知识的大小是对数的，这意味着我们应该能够在短短时寻找我们的＆＃39;重新寻找什么时间。这是真的，适​​用于一个完美有组织的知识。</p><p> The issue is when we have a piece of knowledge we want to document that pertains to both Project A and Project B -- where does it go in this hierarchy? Do we duplicate the information to both sections? Do we create a new section entirely just to deal with documenting these edge-cases? Do we just put it in Project A and somehow link to it  somewhere in Project B&#39;s documentation? Or do we just put it in Project A because it is  slightly more relevant and just ignore Project B? Each person trying to add to the collective knowledge has to go through this thought process, and they will not make the same decision. This is documentation rot, and it makes it so that you are not confident where some bit of information might be if it doesn&#39;t perfectly fit into the hierarchy.</p><p> 问题是我们有一段知识，我们想要记录到Project A和Project B的Project A和Project B  - 它在这个层次结构中都在哪里？我们是否将信息复制到两个部分？我们是否完全创建了一个新部分，只是为了处理这些边缘案件的记录？我们只是把它放在项目A和某种方式链接到项目B＆＃39;文件中的某个地方？或者我们只是把它放在项目a中，因为它稍微相关，只是忽略项目b？每个人都试图增加集体知识必须通过这个思想过程，他们不会做出同样的决定。这是文档腐烂，它使得您并不确立某些信息，如果它不完全适合层次结构。</p><p> Looking back at our knowledge lookup time, it is clear that it is only  O(log(n)) if we actually make the right decision on each branch. But if our information is poorly organized and we don&#39;t make the right decision on a branch, we are now in backtracking territory. Unlike computers, humans are  really bad at backtracking, because we think &#34;well maybe I just missed it when I went down branch X.&#34; This leads to frustration, this leads to annoyance, and it leads to engineers loosing trust in the documentation. And if they don&#39;t trust the documentation they won&#39;t use it, and if they don&#39;t use it they won&#39;t add to it.</p><p> 回顾我们的知识查找时间，很明显，如果我们实际在每个分支机构做出正确的决定，那么它就是o（log（n））。但如果我们的信息组织不佳，我们不对分支机构做出正确的决定，我们现在正在回溯领土。与计算机不同，人类在回溯时真的很糟糕，因为我们认为＆＃34;嗯，也许我刚刚错过了它，当我下来分支x。＆＃34;这导致令人沮丧，这导致烦恼，它导致工程师在文档中失去信任。如果他们不相信他们赢得的文件，他们使用它，如果他们不使用它，他们会使用它。</p><p>  Let us consider two of the most widely revered documentation systems: Wikipedia and the Arch Linux Wiki. Anyone who has used either knows that they are just incredible. In terms of managing information and collective knowledge, I don&#39;t know of anything that is better than Wikipedia or the Arch Linux Wiki. This is in large part due to the wonderful job of the maintainers of these bodies of knowledge (huge thanks to these folks), but I would argue it is also because they organize their information in a different way from a strict hierarchy.</p><p>  让我们考虑两个最广泛尊敬的文档系统：维基百科和拱门Linux Wiki。任何使用的人都知道他们只是令人难以置信的。在管理信息和集体知识方面，我不知道任何比Wikipedia或Arch Linux Wiki更好的东西。这在很大程度上是由于这些知识体系的伟大工作（巨大感谢这些人），但我争论也是因为他们以不同的方式从严格的层次结构上以不同的方式组织他们的信息。</p><p> Both take a  graph approach to organizing data. Instead of a hierarchy in which everything is organized, each document is basically free-floating. Rather than  where a document lives determining which other documents it is related to, it instead uses links  between documents to create that relationship. Look at a random Wikipedia page and see how many links there are to other pages that are related. This dense network created by links between pages is what makes these documentation systems the best around.</p><p> 两者都采取了组织数据的图形方法。每个文档都基本上是自由的，而不是组织一切的层次结构。而不是文档生活确定它与之相关的其他文档，而是使用文档之间的链接来创建该关系。查看随机维基百科页面，看看有多少链接与其他页面有关。通过页面之间的链接创建的这种密集的网络是使这些文档系统的最佳状态。</p><p> Let us consider the lookup time for any given piece of information. This is a bit trickier to determine since it is dependent on the  density of links. In fact, I don&#39;t think we can determine the algorithmic runtime without specifying a few other parameters. It is certainly less than  O(n), and likely approximates  O(log(n)), but it doesn&#39;t actually matter. What matters is worst-case lookup time.</p><p> 让我们考虑任何给定信息的查找时间。这是一个棘手的棘手，因为它取决于链接的密度。事实上，我认为我们认为我们可以确定算法运行时，而无需指定一些其他参数。它肯定小于O（n），并且可能近似O（log（n）），但它实际上并不重要。重要的是最糟糕的案例查找时间。</p><p> If we reach the wrong page, rather than having to potentially backtrack to the root, we can just do a random walk around the page we are at. In a minimally organized system, this should still lead us to the information we want, because the pages will be linking to other pages that are relevant.</p><p> 如果我们到达错误的页面，而不是必须潜在地回溯到root，我们只能在我们的页面上进行随机漫步。在最微小的组织系统中，这仍应导致我们所需的信息，因为页面将链接到其他相关的页面。 </p><p> More importantly, new pieces of information can just be added, and there are no decisions that need to be made about where to put that information. If a piece of information is relevant to Project A and Project B, we just add it as a new document and link from both Project A and Project B. This is now the  natural process, and scales organically. Of course, some care is required to prevent this from becoming a complete mess, but it isn&#39;t particularly difficult to put some guidelines on this.</p><p>更重要的是，可以刚刚添加新的信息，并且没有关于将该信息放在哪里需要做出的决定。如果一条信息与项目A和Project B相关，我们只需将其添加为项目A和项目B的新文档和链接。这是现在是自然过程，并且有机缩放。当然，需要一些关心来防止这种情况变得完全乱七八糟，但它是特别困难，对此有一些指导。</p><p> It should come as no surprise that the ad-hoc documentation methods I described above are  effectively the graph approach. Free-standing documentation that is  linked by people (rather than within the documents). Yet instead of leaning into this natural way of doing things, I have seen companies use tools which fight  against this way of organizing information.</p><p> 它应该毫不奇怪，上面描述的ad-hoc文件方法是有效的图形方法。人员链接的独立文件（而不是在文件中）。然而，我已经看到公司使用工具，而不是倾向于这种自然的做法方式。</p><p>  Every company I have worked at has used a tree-based approach to organizing documentation, and they have all been absolutely horrible. Two of the most popular, and largest, sources of documentation, Wikipedia and the Arch Linux Wiki, both use a graph-based approach to documentation and are widely loved and easy to use. One group has  paid employees whose job is partly to keep this documentation up-to-date, and the other group is full of volunteers. If that is not argument enough to ditch Confluence for Media Wiki then frankly I don&#39;t know what is.</p><p>  我曾经工作过的每家公司都使用了一种基于树的方法来组织文件，并且他们一直非常可怕。其中两个最受欢迎，最大的文档来源，维基百科和Arch Linux Wiki，都使用基于图形的文档方法，并且广泛喜欢和易于使用。一组已支付员工，其工作部分是为了使本文件保持最新，而另一个团队已充满志愿者。如果这不是足够的争论对媒体的沟渠，那么坦率地说，我不知道是什么。</p><p> Of course, this does not mean you should not have other guidelines for your documentation. A graph-based system does not solve  all of the problems. For instance, the  4 types of documentation is important to keep in mind and use. A mess will always be a mess, regardless of whether it is in a hierarchy or a graph.</p><p> 当然，这并不意味着您不应该为您的文档提供其他指南。基于图形的系统无法解决所有问题。例如，4种类型的文档对于记住和使用非常重要。无论它是层次结构还是图形，它都会始终是一团糟。</p><p> Stop using hierarchy based documentation. It doesn&#39;t scale, it requires far more effort, and it is simply holding your organization back.</p><p> 停止使用基于层次结构的文档。它并不规模，它需要更多的努力，它只是持有你的组织。</p><p> Do start using a graph-based system for documentation. It scales easily and engineers will naturally contribute.</p><p> 请开始使用基于图形的文档系统。它轻松和工程师将自然贡献。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.worldofbs.com/why-documentation-sucks/">https://www.worldofbs.com/why-documentation-sucks/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/文档/">#文档</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>