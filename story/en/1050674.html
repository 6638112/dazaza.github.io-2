<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Deno v1.8 –支持WebGPU，私有模块，Intl等 Deno v1.8 – support for WebGPU, private modules, Intl, and much more</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Deno v1.8 – support for WebGPU, private modules, Intl, and much more<br/>Deno v1.8 –支持WebGPU，私有模块，Intl等 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-03 23:00:43</div><div class="page_narrow text-break page_content"><p>&lt;- Other News   GitHub      Today we are releasing Deno 1.8.0. This release contains a massive amount of newfeatures and stabilizations:</p><p>＆lt;  - 其他新闻Github今天我们释放了Deno 1.8.0。此版本包含大量的新种和稳定性：</p><p> Experimental support for WebGPU API:paving a path towards out-of-the-box GPU accelerated machine learning in Deno</p><p> WebGPU API的实验支持：铺平丹哥箱外加速机器学习的路径</p><p>    Support for fetching private modules:fetch your remote modules from a private server using auth tokens</p><p>    支持获取私有模块：使用Auth标记从私人服务器获取远程模块</p><p> If you already have Deno installed you can upgrade to 1.8 by running deno upgrade. If you are installing Deno for the first time, you can use oneof the methods listed below:</p><p> 如果您已安装Deno安装，则通过运行Deno升级，您可以升级到1.8。如果您首次安装DENO，则可以使用以下方法的ONEOF：</p><p>      The WebGPU API gives developers a low level, high performance, crossarchitecture way to program GPU hardware from JavaScript. It is the effectivesuccessor to WebGL on the Web. The spec has not yet been finalized, but supportis currently being added to Firefox, Chromium, and Safari; and now also in Deno.</p><p>      WebGPU API为开发人员提供低级别，高性能，串建筑地区，用于从JavaScript中编程GPU硬件。它是WebGL上WebGL的有效性Cessor。该规范尚未最终确定，但目前正在添加到Firefox，Chromium和Safari中的支持;现在也在丹诺。</p><p> This API gives you access to GPU rendering and general purpose GPU compute rightfrom within Deno. Once finished, stabilized, and unflagged, this will provide aportable way to access GPU resources from web, server, and developer machine.</p><p> 此API使您可以访问GPU渲染和通用GPU在丹麦中计算RightFom。完成后，稳定和unflagged，这将提供无与伦比的方法来访问Web，服务器和开发人员机器的GPU资源。</p><p> GPUs allow programmers to make some numerical algorithms highly parallel. Thisis useful beyond rendering graphics and games. Effective use of GPUs in MachineLearning has enabled more complex neural networks - what is called DeepLearning. The rapid progress in computer vision, translation, image generation,re-enforcement learning, and more all stem from making effective use of GPUhardware.</p><p> GPU允许程序员使一些数字算法高度平行。此目的超出渲染图形和游戏。有效地利用Machinelearning的GPU已经启用了更复杂的神经网络 - 所谓的解读。计算机愿景，翻译，图像生成，重新实施学习以及更多所有词源的快速进展，从而有效地利用GPUhardware。 </p><p> These days, most neural networks are defined in Python with the computationoffloaded to GPUs. We believe JavaScript, instead of Python, could act as anideal language for expressing mathematical ideas if the proper infrastructureexisted. Providing WebGPU support out-of-the-box in Deno is a step in thisdirection. Our goal is to run  Tensorflow.js onDeno, with GPU acceleration. We expect this to be achieved in the coming weeksor months.</p><p>如今，大多数神经网络都是使用Python定义的，其计算任务已转移至GPU。我们相信，如果存在适当的基础架构，JavaScript（而不是Python）可以充当表达数学思想的理想语言。在Deno中提供现成的WebGPU支持是朝着这个方向迈出的一步。我们的目标是通过GPU加速在Tensorflow上运行Tensorflow.js。我们预计这将在未来几周或几个月内实现。</p><p> Here is a basic example that demonstrates accessing an attached GPU device, andreading out the name and supported features:</p><p> 这是一个基本示例，演示了如何访问连接的GPU设备以及读取名称和支持的功能：</p><p>  Here is a little example that demonstrates the GPU rendering a simple redtriangle on a green background using a render shader:</p><p>  这是一个小示例，演示了GPU使用渲染着色器在绿色背景上渲染一个简单的红色三角形：</p><p>    The final PR weighed in at a whopping 15.5k lines of code, and took a whole 5months to merge after opening. Many thanks to crowlKats who led the integration of WebGPU intoDeno. We would also like to thank to all contributors to the wgpu and gfx-rs projects that underpin theWebGPU implementation in Deno. Special thanks also to kvark, editor on the WebGPU spec, and the leaddeveloper of wgpu and gfx-rs, for the great guidance while implementing theWebGPU API.</p><p>    最终的PR占用了多达15.5万行代码，并且在打开后花了整整5个月的时间合并。非常感谢crowlKats领导了将WebGPU集成到Deno中。我们还要感谢为Deno中的WebGPU实现奠定基础的wgpu和gfx-rs项目的所有贡献者。特别感谢WebGPU规范的编辑kvark以及wgpu和gfx-rs的主要开发人员，他们为实现WebGPU API提供了出色的指导。</p><p>   ICU support has been the second most requested feature in Deno repository. We&#39;rehappy to announce that Deno v1.8 ships with full ICU support.</p><p>   在Deno存储库中，ICU支持已成为需求第二大的功能。我们很高兴地宣布Deno v1.8附带了完整的ICU支持。</p><p>      This release expands our coverage infrastructure to add some great newcapabilities. The main change in this release is that coverage handling is nowsplit into coverage collection and coverage reporting.</p><p>      此版本扩展了我们的覆盖范围基础架构，以添加一些强大的新功能。此版本的主要变化是，覆盖率处理现在分为覆盖率集合和覆盖率报告。</p><p> Previously coverage collection and reporting would all happen in a singlesubcommand, by specifying the  --coverage flag when starting  deno test. Nowthe  --coverage flag for  deno test takes an argument - a path to a directorywhere to store the collected profiles. This is the coverage collection. In asecond step you now call  deno coverage with the path to the directory storingthe coverage profiles. This subcommand can either return a report as pretty textoutput right on the console, or it can output an lcov file ( --lcovflag) for use with tools like  genhtml, coveralls.io, or codecov.io.</p><p> 以前，覆盖范围的收集和报告都将在单个子命令中进行，方法是在启动deno测试时指定--coverage标志。现在，用于deno测试的--coverage标志带有一个参数-用来存储收集的配置文件的目录的路径。这是coverage集合。在第二步中，您现在调用deno Coverage以及存储coverage配置文件的目录路径。此子命令可以在控制台上直接以漂亮的文本输出形式返回报告，也可以输出lcov文件（--lcovflag）以供genhtml，coveralls.io或codecov.io之类的工具使用。 </p><p> We have been dogfooding this feature on  deno_std for a few days now. We uploada coverage report to codecov.io for each commit. You can view these here https://codecov.io/gh/denoland/deno_std. Adding this was trivial, with only a 10line change to our GitHub Actions workflow:</p><p>几天来，我们一直在deno_std上对该功能进行测试。我们将每次提交的覆盖率报告上载到codecov.io。您可以在这里https://codecov.io/gh/denoland/deno_std查看这些内容。添加起来很简单，对我们的GitHub Actions工作流仅进行了10行更改：</p><p>     Import maps were stabilized in Chrome 89,and following that our implementation has been updated to match the latestrevision of the specification and is now also considered stable. This means thatthe  --unstable flag is no longer required when using  --import-map.</p><p>     导入地图在Chrome 89中已稳定，随后我们的实现已更新为与规范的最新版本相匹配，现在也被认为是稳定的。这意味着使用--import-map时不再需要--unstable标志。</p><p>  Additionally the  --import-map flag now accepts not only local paths, but alsoURLs, allowing you to load import maps from remote servers.</p><p>  另外，--import-map标志现在不仅接受本地路径，而且接受URL，从而使您可以从远程服务器加载导入地图。</p><p>  Import maps allow a user to use so-called &#34;bare&#34; specifiers for dependencies,instead of relative or absolute file / http URLs:</p><p>  导入映射使用户可以使用所谓的“裸机”。依赖性的说明符，而不是相对或绝对文件/ http URL：</p><p>   Users should keep in mind that import maps  are not composable: this meansyou can only provide a single import map to  deno run /  deno test. Because ofthis library authors should still use regular, non-bare specifiers (relative orabsolute file / http URLs); otherwise the users of the library will manuallyneed to add your libraries (and your libraries dependencies) bare specifiersinto their import map.</p><p>   用户应记住，导入映射不可组合：这意味着您只能为deno run / deno测试提供单个导入映射。因此，作者仍应使用常规的，非裸露的说明符（相对或绝对文件/ http URL）；否则，该库的用户将需要手动将您的库（和您的库依赖项）裸露的说明符添加到其导入映射中。</p><p> A much more useful feature for import maps is ability to remap regularspecifiers to completely different ones. For example if you have some brokendependency that is deeply nested in your module graph you can replace it withfixed version before it&#39;s fixed upstream, or if you use a build process thatadds hashes to your modules filenames, you can refer to the file without hashesin your source code and remap the specifiers only at runtime using an importmap.</p><p> 导入映射的一个更有用的功能是能够将正则说明符重新映射为完全不同的规范符。例如，如果您的模块图中深深地嵌套了一些brokendependency，则可以在上游修复固定版本之前将其替换为固定版本，或者如果您使用将哈希添加到模块文件名的构建过程，则可以引用该文件源代码中没有哈希值，并且仅在运行时使用importmap重新映射说明符。</p><p>    Not all code openly is available on the public internet. Previously Deno had nocapability to download code from a server that required authentication. In thisrelease we have added the ability for users to specify per domain auth tokensthat are used when fetching modules for the first time.</p><p>    并非所有代码都可以在公共互联网上公开获得。以前，Deno无法从需要身份验证的服务器上下载代码。在此版本中，我们增加了用户指定每次首次获取模块时使用的每个域身份验证令牌的功能。 </p><p> To do this the Deno CLI will look for an environment variable named DENO_AUTH_TOKENS to determine what authentication tokens it should considerusing when requesting remote modules. The value of the environment variable isin the format of a n number of tokens delimited by a semi-colon ( ;) where eachtoken is in the format of  {token}@{hostname[:port]}.</p><p>为此，Deno CLI将查找名为DENO_AUTH_TOKENS的环境变量，以确定在请求远程模块时应考虑使用的身份验证令牌。环境变量的值的格式为以分号（;）分隔的n个令牌的格式，其中每个令牌的格式为{token} @ {hostname [：port]}。</p><p>     When Deno goes to fetch a remote module, where the hostname matches the hostnameof the remote module, Deno will set the  Authorization header of the request tothe value of  Bearer {token}. This allows the remote server to recognize thatthe request is an authorized request tied to a specific authenticated user, andprovide access to the appropriate resources and modules on the server.</p><p>     当Deno提取与主机名匹配的远程模块的远程模块时，Deno会将请求的Authorization标头设置为Bearer {token}的值。这允许远程服务器识别该请求是绑定到特定经过身份验证的用户的授权请求，并提供对服务器上适当资源和模块的访问。</p><p> For a more detailed usage guide and instructions for configuring yourenvironment to pull from private GitHub repos, see the related manual entry.</p><p> 有关更详细的使用指南和配置您的环境以从私有GitHub存储库中提取信息的说明，请参阅相关的手册条目。</p><p>   The  Deno.test API already has two sanitizersthat help ensure that your code is not &#34;leaking&#34; ops or resources - ie. that allopen file/network handles are closed before test case ends, and that there areno more pending syscalls.</p><p>   Deno.test API已经具有两个清除程序，可帮助确保您的代码不会“泄漏”。操作或资源-即在测试用例结束之前，已关闭allopen文件/网络句柄，并且没有其他挂起的syscall。</p><p> Deno 1.8 adds a new sanitizer that ensures that tested code doesn&#39;t call Deno.exit(). Rogue exit statements can signal false positive test results andare most often misused or were forgotten to be removed.</p><p> Deno 1.8添加了一个新的清理程序，以确保已测试的代码不会调用Deno.exit（）。流氓出口声明可能表示错误的阳性测试结果，并且经常被滥用或忘记删除。</p><p> This sanitizer is enabled by default for all tests, but can be disabled bysetting the  sanitizeExit boolean to false in the test definition.</p><p> 默认情况下，所有测试都会启用此清理程序，但可以通过在测试定义中将sanitizeExit布尔值设置为false来禁用此清理程序。</p><p>     Deno&#39;s security model is based on permissions. Currently these permissions canonly be granted when the application is started. This works well for mostscenarios, but in some cases it is a better user experience to request / revokepermissions at runtime.</p><p>     Deno的安全模型基于权限。当前，只有在启动应用程序时才能授予这些权限。在大多数情况下，此方法效果很好，但在某些情况下，在运行时请求/撤消权限会带来更好的用户体验。 </p><p> In Deno 1.8 there is now a stable API to  query,  request, and  revokepermissions. These APIs are contained in the  Deno.permissions object. Here isan example of how this works:</p><p>在Deno 1.8中，现在有一个稳定的API可以查询，请求和撤消权限。这些API包含在Deno.permissions对象中。这是一个如何工作的示例：</p><p> // Try to get the home directory (this should fail, as no env permission yet).</p><p> //尝试获取主目录（此操作将失败，因为还没有env权限）。</p><p>      Before stabilization these APIs went through a security review and properpermissions are required to use them.</p><p>      在稳定之前，这些API都要经过安全审查，并且必须获得适当的权限才能使用它们。</p><p>     As Deno becomes more stable it is becoming more important have easy ways fordevelopers to instrument their applications. This starts at the lowest level, atthe runtime itself. In Deno all privileged operations in JS (the ones that go toRust), are done via a single central interface between JS and Rust. We call therequests going over that interface &#34;ops&#34;. For example, calling  Deno.open wouldinvoke the  op_open_async op to the privileged side, which would return theresource id of the opened file (or an error).</p><p>     随着Deno变得更加稳定，对于开发人员来说，使用简便的方法来检测其应用程序变得越来越重要。这从最低级别开始，即在运行时本身。在Deno中，JS中的所有特权操作（转到Rust的操作）都是通过JS和Rust之间的单个中央接口来完成的。我们称通过该接口的问题为“＆op34”。例如，调用Deno.open将调用op_open_async op到特权端，这将返回打开文件的源ID（或错误）。</p><p> More than two years ago, on Oct 11, 2018 we added a way for you to view metricsfor all of the ops between Rust and JS:  Deno.metrics. This API currentlyexposes the count of started, and completed synchronous and asynchronous ops,and the amount of data that has been sent over the ops interface. So far thishas been limited to combined data for all of the different ops. There was no wayto figure out  which ops were invoked how many times, only all ops in general.</p><p> 两年多以前，即2018年10月11日，我们为您提供了一种查看Rust和JS之间所有操作的指标的方法：Deno.metrics。该API当前公开了已开始和已完成的同步和异步操作的计数，以及通过操作接口发送的数据量。到目前为止，这仅限于所有不同操作的组合数据。没有办法确定哪个操作被调用了多少次，只有一般的所有操作。</p><p> When running with  --unstable, this release adds a new field to  Deno.metricscalled  ops. This field contains per op information about how often the API wasinvoked and how much data has been transmitted over it. This allows for far moregranular instrumentation of the runtime.</p><p> 与--unstable一起运行时，此版本向Deno.metrics添加了一个名为ops的新字段。此字段包含每个操作的信息，这些信息涉及API的调用频率以及已通过API传输了多少数据。这允许对运行时进行更多粒度的检测。</p><p>   In an upcoming release this new information will be used by the async opsanitizer in  Deno.test to give more actionable errors when an async op is notcompleted before test completion. We have already seen this feature being usedto instrument applications and pipe the data into monitoring software:</p><p>   在即将发布的版本中，Deno.test中的异步opsanitizer将使用此新信息，以在测试完成之前未完成异步操作时提供更多可操作的错误。我们已经看到此功能用于检测应用程序并将数据通过管道传输到监视软件中： </p><p>    deno fmt can now format  .json and  .jsonc files. Just like with JS/TS, theformatter will also format json and jsonc codeblocks inside of markdown files.</p><p>deno fmt现在可以格式化.json和.jsonc文件。就像JS / TS一样，formatter还将在markdown文件中格式化json和jsonc代码块。</p><p>    By default output format will still be  esm, but users can change this bysetting the  EmitOptions.bundle option to  iife:</p><p>    默认情况下，输出格式仍为esm，但用户可以通过将EmitOptions.bundle选项设置为iife来更改此格式：</p><p>        We have been working on a replacement for our old editor integration for VSCode, the Deno extension for the last few months. The old extension only workedfor VS Code, and the resolved types did not always match the ones in the DenoCLI.</p><p>        在过去的几个月中，我们一直在努力替代VSCode（Deno扩展）的旧编辑器集成。旧的扩展名仅适用于VS Code，而且解析的类型并不总是与DenoCLI中的类型匹配。</p><p> In Deno 1.6 we released  deno lsp in canary - a builtin language server forDeno. LSP allows us to provide editor integration to all LSP capable editorsfrom just a single codebase. The built in language server is built on the samearchitecture as the rest of the Deno CLI - it thus provides TypeScriptdiagnostics the same way as the rest of the CLI.</p><p> 在Deno 1.6中，我们在canary（Deno的内置语言服务器）中发布了deno lsp。 LSP使我们能够从单个代码库向所有支持LSP的编辑器提供编辑器集成。内置的语言服务器与Deno CLI的其余部分基于相同的体系结构-因此，它提供的TypeScript诊断功能与CLI的其余部分相同。</p><p> Two weeks ago, in Deno 1.7.5 we stabilized  deno lsp and switched our offical VS Code extensionto use it. So far we have gotten some great feedback, and will be working toaddress all reported issues. If you are run into issues with the extension,please report it on our issue tracker. We can not fix issues that we do not knowabout.</p><p> 两周前，在Deno 1.7.5中，我们稳定了deno lsp并切换了正式的VS Code扩展以使用它。到目前为止，我们已经收到了很好的反馈，并将努力解决所有报告的问题。如果您在扩展程序中遇到问题，请在我们的问题跟踪器中报告。我们无法解决我们不知道的问题。</p><p> In addition to the offical VS Code integration, more community integrations havebeen created that are built on  deno lsp:</p><p> 除了官方的VS Code集成以外，还创建了更多基于deno lsp构建的社区集成： </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://deno.land/posts/v1.8">https://deno.land/posts/v1.8</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/deno/">#deno</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/webgpu/">#webgpu</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>