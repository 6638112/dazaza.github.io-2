<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#类型</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#类型</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021590.html">TypeScript添加了对模板字符串类型的支持</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/microsoft/TypeScript/pull/40336">TypeScript adds support for Template String types</a><span>(github.com)</span></div><span class="my_story_list_date">2020-9-1 20:55</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1021590.html"><img src="http://img2.diglog.com/img/2020/9/thumb_4b7d9ecba1881eda1176c27aaa7da297.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">模板字符串类型，这是字符串文字的一种形式，带有嵌入的泛型占位符，可以通过类型实例化用实际的字符串文字替换。
MAPPLED TYPE AS子句，提供转换映射类型中的属性名称的功能。
模板字符串类型是与模板字符串表达式等效的类型空间。与模板字符串表达式类似，模板字符串类型包含在反引号分隔符中，并且可以包含${T}形式的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/添加/">#添加</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/adds/">#adds</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021566.html">(.NET)引入半类型</a></div><div class="item_title_en"><a target="_blank" href="https://devblogs.microsoft.com/dotnet/introducing-the-half-type">(.NET) Introducing the Half Type</a><span>(devblogs.microsoft.com)</span></div><span class="my_story_list_date">2020-9-1 15:9</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1021566.html"><img src="http://img2.diglog.com/img/2020/9/thumb_4d8f7fb3aa7a46aaaf49c2063aca8438.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">IEEE754规范定义了许多浮点类型，包括：二进制16、二进制32、二进制64和二进制128。大多数开发人员熟悉binary32(相当于C#中的Float)和binary64(相当于C#中的Double)。它们提供了一种标准格式来以许多应用程序可以接受的精度表示大范围的值。.NET一直有Float和Double两种类......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/net/">#net</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021379.html">“朱莉娅与锈”中的和类型</a></div><div class="item_title_en"><a target="_blank" href="https://andreaskroepelin.de/blog/sum_types/">Sum Types in Julia and Rust</a><span>(andreaskroepelin.de)</span></div><span class="my_story_list_date">2020-8-31 12:35</span><div class="my_story_list_item_desc">正如我在本博客的其他帖子中提到的(这里肯定很多人都会同意)，我坚信设计程序的一个很好的开始是找出人们试图解决的现实问题的良好表示形式，即定义适当的类型。定义类型的一种有用的技术是所谓的SUM类型。有趣的是，它们在不同的编程语言中的用法完全不同，我想在本文中以Rust和Julia为例简要说明这一点。
备注：Julia和......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/julia/">#julia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/types/">#types</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1020658.html">另一种类型的档案馆</a></div><div class="item_title_en"><a target="_blank" href="http://blog.archive.org/2020/08/26/an-archive-of-a-different-type/">An Archive of a Different Type</a><span>(blog.archive.org)</span></div><span class="my_story_list_date">2020-8-27 20:4</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1020658.html"><img src="http://img.diglog.com/img/2020/8/thumb_03c52b15eee741f7d92dbfdb5c429c9b.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">应该是杂志的。伊莱恩·伍顿(Elaine Wooton)和许多人一样，在一个关闭并放弃的项目中联系了我，询问互联网档案馆是否会想要一些预定用于深度存储或垃圾压缩器的东西。她说，在这种情况下，我可能会想要一些旧的期刊和杂志。他们围绕着现代办公室的文化和创新，“现代”是指20世纪70年代和80年代。我的一般政策是同意，如......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/archive/">#archive</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/打字机/">#打字机</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1019529.html">已发布TypeScript v4.0.2</a></div><div class="item_title_en"><a target="_blank" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0-rc/">TypeScript v4.0.2 Released</a><span>(devblogs.microsoft.com)</span></div><span class="my_story_list_date">2020-8-21 11:33</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1019529.html"><img src="http://img.diglog.com/img/2020/8/thumb_13723ce00d0c2dccea3d439ea3a481ae.gif" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">虽然这个RC使我们更接近一个新的主要版本的TypeScript，但不要担心-没有比往常更大的突破性变化。我们发展TypeScript的理念一直是提供一条升级路径，将破坏性的破坏性更改降至最低，同时仍给我们一些灵活性，以便在适当的时候将可疑代码标记为错误。出于这个原因，我们继续使用与以前版本类似的版本控制模型，因此4.......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1019422.html">关于ML类型推理的轶事(1994)</a></div><div class="item_title_en"><a target="_blank" href="https://web.archive.org/web/20081006181650/http://www.usenix.org/publications/library/proceedings/vhll/full_papers/koenig.a">An Anecdote About ML Type Inference (1994)</a><span>(web.archive.org)</span></div><span class="my_story_list_date">2020-8-21 1:35</span><div class="my_story_list_item_desc">清单现在是最难的部分了：如何着手写呢？最明显的方法就是把清单的前半部分放在一处，后半部分放在-4-其他地方。这样做的问题是，如果不遍历列表，我们就不知道它有多大；因此有必要再次遍历它才能进行实际的拆分。避免这种两遍属性会很好。想了一会儿，我意识到这个问题就像把一副牌等分成两堆。如果我想通过切牌来做到这一点，我必须先数......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ml/">#ml</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/列表/">#列表</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1019416.html">Tyescript 4.0</a></div><div class="item_title_en"><a target="_blank" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/">TypeScript 4.0</a><span>(devblogs.microsoft.com)</span></div><span class="my_story_list_date">2020-8-21 1:32</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1019416.html"><img src="http://img.diglog.com/img/2020/8/thumb_35f746c124bbf5bb2883906507a242fb.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">今天，我们非常高兴地宣布TypeScript4.0已经面市！随着我们更深入地研究可表现性、生产力和可伸缩性，该语言版本代表了我们的下一代Tyescript版本。
如果您不熟悉TypeScript，那么它是一种通过添加静态类型语法而构建在JavaScript之上的语言。其想法是，通过写下值的类型以及它们的使用位置，您可......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/tyescript/">#tyescript</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1019034.html">TS-Migrate：自动将JavaScript项目迁移到TS的工具</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/airbnb/ts-migrate">Ts-migrate: tool to automatically migrate JavaScript projects to TS</a><span>(github.com)</span></div><span class="my_story_list_date">2020-8-19 8:34</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1019034.html"><img src="http://img.diglog.com/img/2020/8/thumb_481dc1baaf58733824b9b3045c6e1e06.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Ts-Migrate是一个帮助将代码迁移到TypeScript的工具，它接收JavaScript或部分类型脚本项目，并给出一个编译类型脚本项目。
TS-Migrate旨在加快打字稿迁移过程。生成的代码将通过构建，但需要后续操作来提高类型安全性。将会有很多//@ts-expect-error，并且任何需要随着时间的推移......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ts/">#ts</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/migrate/">#migrate</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1018786.html">IDRIS：一种用于类型驱动开发的语言</a></div><div class="item_title_en"><a target="_blank" href="https://www.idris-lang.org/index.html">Idris: A Language for Type-Driven Development</a><span>(www.idris-lang.org)</span></div><span class="my_story_list_date">2020-8-18 7:52</span><div class="my_story_list_item_desc">在类型驱动开发中，类型是构造程序的工具。我们将类型作为程序的计划，并使用编译器和类型检查器作为我们的助手，引导我们找到满足该类型的完整程序。越有表现力的类型是我们放弃前面，我们就越有信心，结果程序将是正确的。
在Idris中，类型是语言中的一级构造。这意味着类型可以作为参数传递给函数，并且可以像任何其他值一样从函数返......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/language/">#language</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1018352.html">DAScript-高性能静态强类型脚本语言</a></div><div class="item_title_en"><a target="_blank" href="https://dascript.org/">DaScript – high-performance statically strong typed scripting language</a><span>(dascript.org)</span></div><span class="my_story_list_date">2020-8-16 2:35</span><div class="my_story_list_item_desc">概述daScript是一种高性能的静态强类型脚本语言，设计为面向数据的可嵌入“脚本”语言，用于性能关键型应用程序(如游戏或后端/服务器)。
速度极快。即使在解释器模式下，也可以将DAScript与编译或JIT语言进行比较，总是比Lua这样的动态解释脚本语言快。在AOT中，它通常比简单编写的C++(由于SSE友好的PO......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/高性能/">#高性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/high/">#high</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1018308.html">类型作为公理，或者：使用静态类型扮演上帝</a></div><div class="item_title_en"><a target="_blank" href="https://lexi-lambda.github.io/blog/2020/08/13/types-as-axioms-or-playing-god-with-static-types/">Types as axioms, or: playing god with static types</a><span>(lexi-lambda.github.io)</span></div><span class="my_story_list_date">2020-8-15 17:17</span><div class="my_story_list_item_desc">函数emptyLike(val：number|string)：number|string{if(typeof val=&#34；number&#34；){return 0；}Else{return&#34；&#34；；}}。
现在，如果我们编写emptyLike(42)*10，类型检查器将再次抱怨，声称结果可能是一个......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/types/">#types</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1018222.html">沮丧吗？不是你的问题，是铁锈的问题</a></div><div class="item_title_en"><a target="_blank" href="https://fasterthanli.me/articles/frustrated-its-not-you-its-rust">Frustrated? It's not you, it's Rust</a><span>(fasterthanli.me)</span></div><span class="my_story_list_date">2020-8-15 5:17</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1018222.html"><img src="http://img.diglog.com/img/2020/8/thumb_99194f67e5542018f2c1c325832cade0.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">学习生锈是..。一种体验。一次情感之旅。在我努力学习“锈”的最初几个月里，我几乎没有比这更沮丧的了。
更糟糕的是，不管你以前有多少Java、C#、C++或其他方面的经验，它仍然会让你感到不安。
事实上，更多的经验可能会让事情变得更糟！习惯已经变得更深了，而且有一种特定的期望，那就是，到现在，你应该能够在更短的时间内完......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1017042.html">打字很难</a></div><div class="item_title_en"><a target="_blank" href="https://typing-is-hard.ch/">Typing Is Hard</a><span>(typing-is-hard.ch)</span></div><span class="my_story_list_date">2020-8-9 5:34</span><div class="my_story_list_item_desc">类型检查是在某种编程语言中使用给定程序并计算出所有变量和表达式是否都具有正确类型的过程，即将字符串分配给字符串，算术表达式只涉及数字等。一些语言还提供类型推理，任务是编译器自己找出正确的类型。根据语言的特点，类型检查和类型推断问题的范围从微不足道到无法确定。
一个决策问题是可判定的，如果对于任何输入，我们可以计算该输......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/打字/">#打字</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/typing/">#typing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1016368.html">利斯科夫替代原理的一个例子是什么？</a></div><div class="item_title_en"><a target="_blank" href="https://stackoverflow.com/questions/56860/what-is-an-example-of-the-liskov-substitution-principle">What is an example of the Liskov Substitution Principle?</a><span>(stackoverflow.com)</span></div><span class="my_story_list_date">2020-8-5 18:24</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1016368.html"><img src="http://img.diglog.com/img/2020/8/thumb_ff0287210796737fd34a6056d629fa7a.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我听说利斯科夫替换原则(LSP)是面向对象设计的基本原则。它是什么？它的用法有哪些例子？
一个很好的例子说明了LSP(由Bob叔叔在我最近听到的一个播客中给出的)是，有时在自然语言中听起来正确的东西在代码中并不能很好地工作。
在数学中，正方形是一个矩形。实际上，它是矩形的特色化。&lt;#34；&gt;是&lt;#3......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/斯科夫/">#斯科夫</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1016164.html">SWIFT类型检查无法决定</a></div><div class="item_title_en"><a target="_blank" href="https://forums.swift.org/t/swift-type-checking-is-undecidable/39024">Swift type checking is undecidable</a><span>(forums.swift.org)</span></div><span class="my_story_list_date">2020-8-4 22:57</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1016164.html"><img src="http://img.diglog.com/img/2020/8/thumb_24f5ee8e405405bddf4968b8e8e78fd6.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">更确切地说，SE-0142和SE-0157的引入使得规范型计算变成了一个不可判定的问题。在提出我的论点之前，我将从必要的背景信息开始，然后概述下一步。规范类型考虑这两个协议，从标准库中的实际实现中剥离出来：协议迭代器协议{关联类型元素}协议序列{关联类型迭代器：迭代器协议关联类型元素...</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/type/">#type</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/协议/">#协议</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1015199.html">PostgreSQL的新联接类型：横向(2014)</a></div><div class="item_title_en"><a target="_blank" href="https://heap.io/blog/engineering/postgresqls-powerful-new-join-type-lateral">PostgreSQL’s New Join Type: LATERAL (2014)</a><span>(heap.io)</span></div><span class="my_story_list_date">2020-7-31 0:2</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1015199.html"><img src="http://img.diglog.com/img/2020/7/thumb_69e9295cb9800bb2d555b36a4af09331.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">PostgreSQL9.3有了一个新的连接类型！横向联接并没有大张旗鼓地出现，但它们启用了一些功能强大的新查询，这些查询以前只能通过过程代码来处理。在这篇文章中，我将介绍一个转换漏斗分析，这在PostgreSQL9.2中是不可能的。
文档中的最佳描述位于FROM子句选项列表的底部：
横向关键字可以在子SELECT F......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/join/">#join</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1015011.html">RBS，Ruby的新型签名语言</a></div><div class="item_title_en"><a target="_blank" href="https://developer.squareup.com/blog/the-state-of-ruby-3-typing">RBS, Ruby’s new type signature language</a><span>(developer.squareup.com)</span></div><span class="my_story_list_date">2020-7-30 3:3</span><div class="my_story_list_item_desc">我们很高兴地宣布Ruby3的新类型签名语言RBS。Ruby3长期声明的目标之一是添加类型检查工具。在与Matz和Ruby提交者团队进行了大量讨论之后，我们决定逐步增加一种名为“RBS”的基础类型签名语言，该语言将随Ruby3一起发布，并附带stdlib的签名。RBS命令行工具也将随Ruby3一起提供，因此您可以为自己......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rbs/">#rbs</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1014991.html">JavaScriptCore中的推测</a></div><div class="item_title_en"><a target="_blank" href="https://webkit.org/blog/10308/speculation-in-javascriptcore/">Speculation in JavaScriptCore</a><span>(webkit.org)</span></div><span class="my_story_list_date">2020-7-30 2:31</span><div class="my_story_list_item_desc">这篇文章都是关于JavaScriptCore虚拟机上下文中的投机性编译，或者简称为投机性编译。推测性编译是使动态语言或任何具有足够动态特性的语言运行得更快的理想选择。在这篇文章中，我们将关注对JavaScript的猜测。从历史上看，这种技术或密切相关的变体已经成功地应用于Smalltalk、Self、Java、.NE......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1014344.html">为什么免费的Pascal比PHP更好？</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/swlh/why-is-free-pascal-better-than-php-654d6c569e7b">Why Is Free Pascal Better Than PHP?</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-7-27 9:6</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1014344.html"><img src="http://img.diglog.com/img/2020/7/thumb_05722914f90de48141608d462baabf55.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">随着现代代码库以疯狂的速度增长，我们通常已经接受这样一个事实，即我们喜爱的编程语言中的某些特性以这样或那样的方式决定了最终产品的质量。无论是对无缝模块化编程、静态类型系统的支持，还是对分布式系统中具有健壮状态维护方式的并发性和并行性的支持。
然而，在某些方面(当然有许多例外)，我们仍然使用与大约20年前相同的编程语言......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pascal/">#pascal</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1014292.html">揭开MLsub的神秘面纱--代数子类型化的简单本质</a></div><div class="item_title_en"><a target="_blank" href="https://lptk.github.io/programming/2020/03/26/demystifying-mlsub.html">Demystifying MLsub – The Simple Essence of Algebraic Subtyping</a><span>(lptk.github.io)</span></div><span class="my_story_list_date">2020-7-26 23:53</span><div class="my_story_list_item_desc">注：这篇网络文章是一篇论文的较旧版本，现已作为ICFP珍珠出版。你可以在这里找到那份报纸的预印本。
代数子类型化是有子类型化的全局类型推理的一种新方法。它扩展了传统的Hindley-Milner类型推理，同时保留了主体类型属性-也就是说，它总是可以为任何给定的表达式推断出最通用的类型。这种方法是由斯蒂芬·多兰(Ste......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/揭开/">#揭开</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/mlsub/">#mlsub</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1014222.html">您需要(和不需要)了解的关于PHP类型系统的所有内容</a></div><div class="item_title_en"><a target="_blank" href="https://thephp.website/en/issue/php-type-system/">Everything you need (and don't need) to know about PHP's type system</a><span>(thephp.website)</span></div><span class="my_story_list_date">2020-7-26 11:50</span><div class="my_story_list_item_desc">PHP是一种动态类型的脚本语言，在2015年之前，PHP根本不支持静态声明的类型。可以在代码中显式地强制转换为标量类型，但是直到PHP7.0使用标量类型声明和返回类型声明RFC时，才在方法和函数签名中声明标量类型。
不过，这并不意味着从7.0版开始，PHP就变成了一种静态类型语言。它有类型提示，可以统计分析，但仍然支......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/了解/">#了解</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/php/">#php</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1014151.html">了解DART中的零安全</a></div><div class="item_title_en"><a target="_blank" href="https://dart.dev/null-safety/understanding-null-safety">Understanding Null Safety in Dart</a><span>(dart.dev)</span></div><span class="my_story_list_date">2020-7-26 0:30</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1014151.html"><img src="http://img.diglog.com/img/2020/7/thumb_d7888eb6d03bf1e76d8be26c7cc8bb79.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">零安全性是自从我们在DART 2.0中用健全的静态类型系统替换了原来不完善的可选类型系统以来，我们对DART所做的最大更改。当DART首次推出时，编译时空安全是一个需要长时间介绍的罕见功能。今天，科特林、斯威夫特、拉斯特和其他语言都有自己的答案，这已经成为一个非常熟悉的问题。下面是一个例子：
如果在没有空安全性的情况......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/dart/">#dart</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/了解/">#了解</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/null/">#null</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012767.html">键入的Lisp，A Primer(2019年)</a></div><div class="item_title_en"><a target="_blank" href="https://alhassy.github.io/TypedLisp.html">Typed Lisp, a Primer (2019)</a><span>(alhassy.github.io)</span></div><span class="my_story_list_date">2020-7-19 3:10</span><div class="my_story_list_item_desc">摘要我们先与Haskell作一个简单的比较，快速浏览一下类型理论，然后徒劳地试图为动态方法辩护，给出一个有点幽默的历史描述，注意到您已经上当了-类型一直都在那里-然后深入一些Lisp类型的技术细节，最后展示宏是如何允许输入的。
展示如何在Lisp中定义像Pair和可能这样的代数多态类型。包括异构类型的列表！
除非另有......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012483.html">基于D3.js的图表库billboard.js 2.0推出，体积更小，速度更快</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/@alberto.park/billboard-js-2-0-is-out-15e84b52ab11">D3.js based chart library billboard.js 2.0 is out, more smaller and faster</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-7-17 15:43</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1012483.html"><img src="http://img.diglog.com/img/2020/7/thumb_560429c5b109094845f9c7825689548b.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">经过几个月的努力，今天自豪地宣布了期待已久的重大更新！
我们决定将整个代码库移到打字脚本，以使贡献者更容易访问和理解代码。
此外，还从地面应用了重新架构，以方便图书馆的维护。
减小送货尺寸是提高装车效率的有力关键。在大多数情况下，并非在所有情况下都使用每种图表类型。无论以前版本中的用法如何，都会交付那些未使用的类型代......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/图表/">#图表</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/based/">#based</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012306.html">2020年的出货常量泛型</a></div><div class="item_title_en"><a target="_blank" href="https://without.boats/blog/shipping-const-generics/">Shipping Const Generics in 2020</a><span>(without.boats)</span></div><span class="my_story_list_date">2020-7-16 23:27</span><div class="my_story_list_item_desc">很难相信，自从我开通RFC2000以来，已经有3年多的时间了，它定义了Rust的常量泛型。同时，阅读RFC线程，这一领域也发生了巨大的变化：首先，在编写RFC的时候，const FNS是不稳定的，而且const甚至还没有使用MIRI进行评估。多年来，关于const泛型特性已经做了很多工作，但是仍然没有发布。然而，我认......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/常量/">#常量</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/const/">#const</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012244.html">禁用的Haskell类型</a></div><div class="item_title_en"><a target="_blank" href="https://semantic.org/post/forbidden-haskell-types/">Forbidden Haskell Types</a><span>(semantic.org)</span></div><span class="my_story_list_date">2020-7-16 18:8</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1012244.html"><img src="http://img.diglog.com/img/2020/7/thumb_7cf484ceeae6bc7fc2161eddc603cd15.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">有时，编写Haskell就像与编译器发生争执。你给它推理，它就会检查它是否有瑕疵。如果它认为它找到了一个，它会告诉你所有关于它的事情。然后，你必须仔细检查它告诉你的内容，并找出它的确切抱怨是什么。我刚才表达得不好吗？还是我真的错了？或者，在非常偶然的情况下，编译器只是脾气暴躁，您必须解决这个问题。当然，如果你真的对G......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/haskell/">#haskell</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1011330.html">关于一种新型Perl/CORE系统的思考</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/Ovid/Cor/wiki/Type-System">Thinking about a New Type System for Perl/Cor</a><span>(github.com)</span></div><span class="my_story_list_date">2020-7-12 19:29</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1011330.html"><img src="http://img.diglog.com/img/2020/7/thumb_6d89de2aa490a09245f81fb213c28a89.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">COR需要一个类型系统。但是，这可能会出现在v2中，因为事实证明a)很难，b)我们需要类型用于：
变量声明没有太多的讨论，而Dave Mitchell在签名类型方面的工作早于Cor在声明类型方面的尝试，所以它是不兼容的。我已经在Perl git repo上打开了一张关于类型的门票。我们绝对不能有一个COR的类型系统，......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/core/">#core</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/type/">#type</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010350.html">静态大小更高种类的多态性</a></div><div class="item_title_en"><a target="_blank" href="http://blog.ielliott.io/sized-hkts/">Statically sized higher-kinded polymorphism</a><span>(blog.ielliott.io)</span></div><span class="my_story_list_date">2020-7-8 0:18</span><div class="my_story_list_item_desc">内存敏感的语言，如C++和Rust，使用编译时信息来计算数据类型的大小。这些大小用于以提高运行时性能的方式通知对齐、分配和调用约定。此设置中的现代语言支持泛型类型，但到目前为止，这些语言只允许对类型进行参数化，而不允许对类型构造函数进行参数化。在本文中，我将描述如何在任意类型构造上启用参数化，同时仍然保留数据类型大小......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/种类/">#种类</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sized/">#sized</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010158.html">在类型档案馆</a></div><div class="item_title_en"><a target="_blank" href="https://www.lrb.co.uk/the-paper/v42/n13/alice-spawls/at-the-type-archive">At the Type Archive</a><span>(www.lrb.co.uk)</span></div><span class="my_story_list_date">2020-7-7 2:3</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1010158.html"><img src="http://img.diglog.com/img/2020/7/thumb_d5df290036396cd1d89336aba3b192bb.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">伦敦斯托克韦尔附近的T​曾经是出租车马和马戏团动物的医院，但自1992年以来，它已经成为各种霉菌、基质、骨灰、胸肌和鼻涕的家园。该档案馆收藏着近六百年的排版设备，但其主要藏品与单字印刷技术有关。这个大写字母很重要：这不是美术家的单版印刷(单字印刷，见德加)，而是19世纪末莫纳印刷公司(MonTypte Corpora......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/type/">#type</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/印刷/">#印刷</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1009840.html">回到老把戏，或者说，生锈的婴儿步</a></div><div class="item_title_en"><a target="_blank" href="https://donsbot.wordpress.com/2020/07/04/back-to-old-tricks-or-baby-steps-in-rust/">Back to old tricks, or, baby steps in Rust</a><span>(donsbot.wordpress.com)</span></div><span class="my_story_list_date">2020-7-5 2:11</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1009840.html"><img src="http://img.diglog.com/img/2020/7/thumb_54587e731f148e21e100a134f51ef8dc.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在过去的二十天左右的时间里，我一直在学习“锈”，我在读“布兰迪与奥伦多夫”这本书，边走边编。一旦我开始使用Rust特征和闭包以及相关类型，就会发现在Haskell中使用类型类、数据结构、闭包传递和相关类型进行编程的相似性非常明显。
作为热身，我想我应该尝试将流融合核心从Haskell移植到Rust。这是我十多年前编写......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/婴儿/">#婴儿</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/baby/">#baby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="/tag/类型/">0</a></li><li class="page-item"><a class="page-link" href="/tag/类型/page1.html">1</a></li><li class="page-item"><a class="page-link" href="/tag/类型/page2.html">2</a></li><li class="page-item active"><a class="page-link" href="/tag/类型/page3.html">3</a></li><li class="page-item"><a class="page-link" href="/tag/类型/page4.html">4</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>