<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Node.example.com是IP地址 Node.example.com Is an IP Address</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Node.example.com Is an IP Address<br/>Node.example.com是IP地址 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-29 14:33:23</div><div class="page_narrow text-break page_content"><p>Hello! Welcome to the once-yearly blog post! This year I&#39;d like to examine themost peculiar bug I encountered at work. To set the stage, let&#39;s start with alittle background. 📚</p><p>你好！欢迎来到每年一次的博客文章！今年，我想研究一下我在工作中遇到的最奇怪的错误。为了做好准备，让我们从各种背景开始。 📚</p><p> When we write  URLs with a  non-standard  port wespecify the port after a  :. With  hostnames and  IPv4 addressesthis is straightforward. Here&#39;s some  Python code to show how easy it is.</p><p> 当我们使用非标准端口编写URL时，请在：之后指定端口。使用主机名和IPv4地址，这很简单。这是一些Python代码，以显示它是多么容易。</p><p>   &gt;&gt;&gt;  url  =  urllib.parse.urlparse( ...  &#34;https://fdc8:bf8b:e62c:abcd:1111:2222:3333:4444:8000&#34; ... ) ... &gt;&gt;&gt;  url.hostname &#39;fdc8&#39; &gt;&gt;&gt;  try : ...  url.port ...  except  ValueError  as  error: ...  print (error) ...Port could  not  be cast to integer value  as   &#39;bf8b:e62c:abcd:1111:2222:3333:4444:8000&#39;</p><p>   ＆gt;＆gt;＆gt; url = urllib.parse.urlparse（...＆＃34; https：// fdc8：bf8b：e62c：abcd：1111：2222：3333：4444：8000＆＃34; ...）...＆gt;＆gt; ＆gt; url.hostname＆＃39; fdc8＆＃39; ＆gt;＆gt;＆gt;尝试：... url.port ...除了ValueError作为错误：... print（错误）...端口无法转换为＆＃39; bf8b：e62c：abcd：1111：2222：3333 ：4444：8000＆＃39;</p><p> Since IPv6 addresses use a &#34;colon-hex&#34; format with  hexadecimal fieldsseparated by  : we can&#39;t tell a port apart from a normal field. Notice in theexample above that the hostname is truncated after the first  :, not the onejust before  8000.</p><p> 由于IPv6地址使用＆＃34;十六进制＆＃34;格式，十六进制字段之间用：分隔：我们不能区分端口与普通字段。请注意，在上面的示例中，主机名在第一个：之后被截断，而不是在8000之前被截断。</p><p> Fortunately, the spec for URLs recognizes this ambiguity and gives us a way tohandle it.  RFC 2732 ( Format for Literal IPv6 Addresses in URL&#39;s)says</p><p> 幸运的是，URL规范认识到了这种歧义，并为我们提供了一种处理方法。 RFC 2732（URL中的文字IPv6地址格式）说</p><p> To use a literal IPv6 address in a URL, the literal address should beenclosed in &#34;[&#34; and &#34;]&#34; characters.</p><p> 要在URL中使用原义IPv6地址，应在＆＃34; [＆＃34;和＆＃34;]＆＃34;字符。</p><p>      from  ipaddress  import  ip_address def  safe_host ( host ):  &#34;&#34;&#34;Surround `host` with brackets if it is an IPv6 address.&#34;&#34;&#34;  try :  if  ip_address(host) .version  ==  6 :  return  &#34;[ {} ]&#34; .format(host)  except  ValueError :  pass return  host</p><p>      从ipaddress导入ip_address def safe_host（host）：如果是IPv6地址，请用括号将＆quot; host包围起来。＆quot;尝试：如果ip_address（host）.version == 6：返回＆＃34; [{}]＆＃34; .format（host），除了ValueError：传递返回主机 </p><p> Elsewhere in the code it was invoked something like this, so that hostnames,IPv4 addresses, and IPv6 addresses could all be safely interpolated.</p><p>在代码的其他地方，也调用了类似的方法，以便可以安全地插入主机名，IPv4地址和IPv6地址。</p><p>   def  test_safe_host_with_hostname ():  &#34;&#34;&#34;Hostnames should be unchanged.&#34;&#34;&#34;  assert  safe_host( &#34;node.example.com&#34; )  ==  &#34;node.example.com&#34; def  test_safe_host_with_ipv4_address ():  &#34;&#34;&#34;IPv4 addresses should be unchanged.&#34;&#34;&#34;  assert  safe_host( &#34;192.168.0.1&#34; )  ==  &#34;192.168.0.1&#34; def  test_safe_host_with_ipv6_address ():  &#34;&#34;&#34;IPv6 addresses should be surrounded by brackets.&#34;&#34;&#34;  assert  (  safe_host( &#34;fdc8:bf8b:e62c:abcd:1111:2222:3333:4444&#34; )  ==  &#34;[fdc8:bf8b:e62c:abcd:1111:2222:3333:4444]&#34;  )</p><p>   def test_safe_host_with_hostname（）：＆＃34;＆＃34;＆＃34;主机名应保持不变。＆＃34;＆＃34;＆＃34;断言safe_host（＆＃34; node.example.com＆＃34;）==＆＃34; node.example.com＆＃34; def test_safe_host_with_ipv4_address（）：＆＃34;＆＃34;＆＃34; IPv4地址应保持不变。＆＃34;＆＃34;＆＃34;断言safe_host（＆＃34; 192.168.0.1＆＃34;）==＆＃34; 192.168.0.1＆＃34; def test_safe_host_with_ipv6_address（）：＆＃34;＆＃34;＆＃34; IPv6地址应用方括号括起来。＆＃34;＆＃34;＆＃34;断言（safe_host（＆＃34; fdc8：bf8b：e62c：abcd：1111：2222：3333：4444＆＃34;）==＆＃34; [fdc8：bf8b：e62c：abcd：1111：2222：3333：4444] ＆＃34;）</p><p> Thank goodness they did. The Python 2 tests failed ( don&#39;t look at me likethat 😒).</p><p> 谢天谢地，他们做了。 Python 2测试失败（不要那样看着我😒）。</p><p> ✖  FAIL  py27 in  1 . 83  seconds✔  OK  py36 in  2 . 82  seconds✔  OK  py37 in  2 . 621  seconds✔  OK  py38 in  2 . 524  seconds✔  OK  py39 in  2 . 461  seconds</p><p> in py27 in 1失败。 83秒✔确定py36 in 2。 82秒✔确定py37 in 2。 621秒✔确定py38 in 2。 524秒✔确定py39 in 2。 461秒</p><p> Both the hostname and IPv6 address tests failed. But   why did they fail?And why did the Python 3 tests pass? 🤔</p><p> 主机名和IPv6地址测试均失败。但是为什么它们失败了，为什么Python 3测试通过了呢？ 🤔</p><p>   The failure says  node.example.com was surrounded by brackets, but that&#39;sonly supposed to happen for IPv6 addresses! Let&#39;s crack open a Python 2interpreter for a quick sanity check.</p><p>   失败表明node.example.com被方括号包围，但这仅应发生在IPv6地址上！让我们打开一个Python 2解释器以进行快速的健全性检查。</p><p>    If, like Jeff Bridges, you were confused by that result,  relax. We&#39;reprobably not in a  Bizarro World where  node.example.com is a valid IPv6address. There must be an explanation for this behavior.</p><p>    如果您像Jeff Bridges一样对结果感到困惑，请放松。我们很可能不在Bizarro世界中，其中node.example.com是有效的IPv6地址。必须对此行为做出解释。 </p><p> Things start to become a little more clear when we see the result of the  ip_address() function for ourselves.</p><p>当我们自己看到ip_address（）函数的结果时，事情开始变得更加清晰。</p><p>   &gt;&gt;&gt;  try : ...  ipaddress.ip_address( &#34;node.example.com&#34; ) ...  except  ValueError  as  error: ...  print (error) ...  &#39;node.example.com&#39;  does  not  appear to be an IPv4  or  IPv6 address</p><p>   ＆gt;＆gt;＆gt;尝试：... ipaddress.ip_address（＆＃34; node.example.com＆＃34;）...除了ValueError作为错误：...打印（错误）...＆＃39; node.example.com＆＃ 39;似乎不是IPv4或IPv6地址</p><p> Python 3 knows that&#39;s not an IPv6 address, so why doesn&#39;t Python 2? The answeris in how differently the two Python versions handle text.</p><p> Python 3知道这不是IPv6地址，所以Python 2为什么不呢？答案是两个Python版本在处理文本方面有何不同。</p><p>  Computers don&#39;t operate on text as humans think of it. They operate on numbers.That&#39;s part of why we have IP addresses to begin with. In order to representhuman-readable text with computers we had to assign meaning to the numbers.Thus,  ASCII was born.</p><p>  计算机不会像人们认为的那样对文本进行操作。它们以数字运算。这就是为什么我们要以IP地址开头的部分原因。为了用计算机表示人类可读的文本，我们必须给数字赋予含义。因此，ASCII诞生了。</p><p> ASCII is a  character encoding, which means it specifies how to interpret bytes as text we understand (provided you speak English). So, when yourcomputer sees  01101110 in  binary ( 110 in  decimal) you see  n becausethat&#39;s what ASCII says it is.</p><p> ASCII是一种字符编码，这意味着它指定如何将字节解释为我们理解的文本（假设您说英语）。因此，当您的计算机看到二进制形式的01101110（十进制为110）时，您会看到n，因为这就是ASCII所表示的意思。</p><p>   In fact, it doesn&#39;t matter what numbering system you use. If you specifybinary,  octal, decimal, hexadecimal, whatever... If it can be understood asthe right integer it will be displayed correctly.</p><p>   实际上，使用哪种编号系统都没有关系。如果指定了二进制，八进制，十进制，十六进制等，则...如果可以将其理解为正确的整数，则它将正确显示。</p><p>    Just for giggles, humor me and let&#39;s look at the character-number translationsfor  node.example.com. We&#39;ll leave out binary and octal, because they makethis table uglier than it already is.</p><p>    只是为了咯咯地笑，让我很幽默，让我们看一下node.example.com的字符编号转换。我们将省略二进制和八进制，因为它们使此表比原来更丑。 </p><p>  Hey, hold on a second... If you tilt your head sideways and squint that lastrow looks kinda like an IPv6 address, doesn&#39;t it?</p><p>嘿，请稍等...如果您侧向倾斜头并斜视那行看上去有点像IPv6地址，不是吗？</p><p> We should verify, just to be absolutely certain. You&#39;ve still got that Python 2interpreter open, right?</p><p> 我们必须进行验证，以便绝对确定。您仍然可以打开Python 2解释器，对吗？</p><p> &gt;&gt;&gt;  # Convert the characters in the hostname to hexadecimal. &gt;&gt;&gt;  hostname  =  &#34;node.example.com&#34; &gt;&gt;&gt;  hostname_as_hexadecimal  =  &#34;&#34; .join( hex ( ord (c))[ 2 :]  for  c  in  hostname) &gt;&gt;&gt;  hostname_as_hexadecimal &#39;6e6f64652e6578616d706c652e636f6d&#39; &gt;&gt;&gt;&gt;&gt;&gt;  # Convert the &#34;IP address&#34; to text. &gt;&gt;&gt;  address  =  ipaddress.ip_address(hostname) &gt;&gt;&gt;  str (address) &#39;6e6f:6465:2e65:7861:6d70:6c65:2e63:6f6d&#39; &gt;&gt;&gt;&gt;&gt;&gt;  # Remove the colons from that text. &gt;&gt;&gt;  address_without_colons  =  str (address).replace( &#34;:&#34; ,  &#34;&#34; ) &gt;&gt;&gt;  address_without_colons &#39;6e6f64652e6578616d706c652e636f6d&#39; &gt;&gt;&gt;&gt;&gt;&gt;  # Compare the results and see they&#39;re equal. &gt;&gt;&gt;  hostname_as_hexadecimal  ==  address_without_colons True</p><p> ＆gt;＆gt;＆gt; ＃将主机名中的字符转换为十六进制。 ＆gt;＆gt;＆gt;主机名=＆＃34; node.example.com＆＃34; ＆gt;＆gt;＆gt; hostname_as_hexadecimal =＆＃34;＆＃34; .join（hex（ord（c））[2：] for hostname中的c）＆gt;＆gt; hostname_as_hexadecimal＆＃39; 6e6f64652e6578616d706c652e636f6d＆＃39; ＆gt;＆gt;＆gt;＆gt;＆gt; ＃转换＆＃34; IP地址＆＃34;到文本。 ＆gt;＆gt;＆gt;地址= ipaddress.ip_address（主机名）＆gt;＆gt; str（地址）＆＃39; 6e6f：6465：2e65：7861：6d70：6c65：2e63：6f6d＆＃39; ＆gt;＆gt;＆gt;＆gt;＆gt; ＃从该文本中删除冒号。 ＆gt;＆gt;＆gt; address_without_colons = str（地址）.replace（＆＃34;：＆＃34;，＆＃34;＆＃34;）＆gt;＆gt; address_without_colons＆＃39; 6e6f64652e6578616d706c652e636f6d＆＃39; ＆gt;＆gt;＆gt;＆gt;＆gt; ＃比较结果，看看结果是否相等。 ＆gt;＆gt;＆gt; hostname_as_hexadecimal == address_without_colons是</p><p> Sure enough, when you boil them both down to numbers they&#39;re the same mess ofhexadecimal.</p><p> 果然，当您将它们都煮成数字时，它们都是十六进制的一团糟。</p><p>  If we dig into the source code for the Python 2 version of the  ipaddress module we ultimately come to a curious set of lines.</p><p>  如果我们深入研究ipaddress模块​​的Python 2版本的源代码，我们最终会遇到一些奇怪的问题。</p><p> # Constructing from a packed address if  isinstance (address,  bytes ) :  self._check_packed_address(address,  16 )  bvs  =  _compat_bytes_to_byte_vals(address) self ._ip  =  _compat_int_from_byte_vals(bvs,  &#39;big&#39; )  return</p><p> ＃如果isinstance（address，bytes）从压缩地址构造：self._check_packed_address（address，16）bvs = _compat_bytes_to_byte_vals（address）self ._ip = _compat_int_from_byte_vals（bvs，＆＃39; big＆＃39;）return</p><p> It turns out that, under certain conditions, the  ipaddress module can createIPv6 addresses from raw bytes. My assumption is that it offers this behavior asa convenient way to parse IP addresses from data fresh off the  wire.</p><p> 事实证明，在某些条件下，ipaddress模块​​可以从原始字节创建IPv6地址。我的假设是，它提供了这种行为，作为从离线数据中解析IP地址的便捷方法。 </p><p> Does  node.example.com meet those certain conditions? You bet it does. Becausewe&#39;re using Python 2 it&#39;s just  bytes and it happens to be 16 characters long.</p><p>node.example.com是否满足那些特定条件？你敢打赌。因为我们使用的是Python 2，所以它只是字节，恰好是16个字符长。</p><p> &gt;&gt;&gt;  isinstance ( &#34;node.example.com&#34; ,  bytes ) True &gt;&gt;&gt;  # `self._check_packed_address` basically just checks how long it is. &gt;&gt;&gt;  len ( &#34;node.example.com&#34; )  ==  16True</p><p> ＆gt;＆gt;＆gt; isinstance（＆＃34; node.example.com＆＃34;，字节）True＆gt;＆gt;＆gt; ＃`self._check_packed_address`基本上只是检查它有多长时间。 ＆gt;＆gt;＆gt; len（＆＃34; node.example.com＆＃34;）== 16真</p><p> The rest of the  ipaddress lines say to interpret the sequence of bytes as a big-endian integer. That&#39;s  magic best leftfor another blog post, but the gist is that hexadecimal interpretation of node.example.com is condensed into a single,  huge number.</p><p> 其余的ipaddress行表示将字节序列解释为big-endian整数。魔术最适合留给另一篇博客文章，但要点是node.example.com的十六进制解释被压缩为一个巨大的数字。</p><p>  That&#39;s an absolutely massive number, but not so massive it won&#39;t fit within the IPv6 address space.</p><p>  这绝对是一个很大的数字，但并不是那么大，以至于它无法容纳在IPv6地址空间中。</p><p>  As it turns out, if you&#39;re liberal in your interpretation,  node.example.com can be an IPv6 address!</p><p>  事实证明，如果您的解释自由，则node.example.com可以是IPv6地址！</p><p>   There&#39;s a quote about numbers which is apocryphally attributed to  W.E.B. DuBois, but that actually comes from  Harold Geneen&#39;s book,  Managing.</p><p>   关于数字的一句报价引自W.E.B. DuBois，但这实际上来自Harold Geneen的书《 Managing》。</p><p> When you have mastered the numbers, you will in fact no longer be readingnumbers, any more than you read words when reading a book. You will bereading meanings.</p><p> 掌握了数字之后，实际上，您将不再是阅读数字，而是阅读书籍时读的单词。您将阅读含义。 </p><p> Having not read the book I&#39;m probably taking the quote way out of context, butI think it fits our situation well.</p><p>我可能没有读过这本书，但很可能是出于上下文的考虑，但我认为这很适合我们的情况。</p><p> As we&#39;ve seen above, we can freely convert characters to numbers and backagain. The root of our problem is that when we use Python 2 it considers textto be bytes. There&#39;s not a deeper, inherent meaning. Maybe the bytes are meantto be ASCII, maybe they&#39;re meant to be a long number, maybe they&#39;re meant to bean IP address. The interpretation of those bytes is up to us.</p><p> 如上所述，我们可以自由地将字符转换为数字并重新返回。问题的根源在于，当我们使用Python 2时，它将文本视为字节。没有更深的内在含义。字节可能是ASCII，也许是长整数，也许是bean IP地址。这些字节的解释取决于我们。</p><p> Python 2 doesn&#39;t differentiate between bytes and text by default. In fact, the bytes type is just an  alias for  str.</p><p> Python 2默认不区分字节和文本。实际上，字节类型只是str的别名。</p><p>  To make that even more concrete, see how Python 2 considers  n to be the sameas this sequence of raw bytes.</p><p>  为了更具体一点，请参阅Python 2如何将n视为与此原始字节序列相同。</p><p>  Our Python 2 code doesn&#39;t work the way we want it to because raw bytes can havearbitrary meaning and we haven&#39;t told it to use our intended meaning.</p><p>  我们的Python 2代码无法按我们希望的方式工作，因为原始字节可以具有任意含义，并且我们还没有告诉它使用我们想要的含义。</p><p> So now we know why Python 2 interprets  node.example.com as an IPv6 address,but why does Python 3 behave differently? More importantly, how can wereconcile the two?</p><p> 因此，现在我们知道了为什么Python 2将node.example.com解释为IPv6地址，但是为什么Python 3的行为有所不同？更重要的是，如何使两者融为一体？</p><p>  ASCII looked like a good idea in the 1960&#39;s. With decades of hindsight weknow the 256 characters afforded to us by  Extended ASCII are insufficient tohandle all of the world&#39;s writing systems. Thus,  Unicode was born.</p><p>  在1960年代，ASCII看起来是个好主意。经过几十年的事后分析，我们知道扩展ASCII提供给我们的256个字符不足以处理世界上所有的书写系统。因此，Unicode诞生了。 </p><p> There are scads of blog posts, Wikipedia articles, and technical documents thatwill do a better job than I can of explaining Unicode in detail. You shouldread them if you care to, but here&#39;s my gist.</p><p>有大量的博客文章，Wikipedia文章和技术文档会比我详细解释Unicode更好。如果需要，您应该阅读它们，但这是我的主旨。</p><p> Unicode is a set of character encodings.  UTF-8 is the dominant encoding.UTF-8 overlaps with ASCII, so ASCII characters are still just one byte. Tohandle the multitude of other characters, however, multiple bytes can express asingle character.</p><p> Unicode是一组字符编码。 UTF-8是主要的编码.UTF-8与ASCII重叠，因此ASCII字符仍然只是一个字节。为了处理大量其他字符，多个字节可以表示单个字符。</p><p> &gt;&gt;&gt;  &#34;n&#34; .encode( &#34;utf-8&#34; ).hex()  # 1 character (U+006E), 1 byte. &#39;6e&#39; &gt;&gt;&gt;  &#34;🤿&#34; .encode( &#34;utf-8&#34; ).hex()  # 1 character (U+1F93F), 4 bytes. &#39;f09fa4bf&#39; &gt;&gt;&gt;  &#34;悟り&#34; .encode( &#34;utf-8&#34; ).hex()  # 2 characters (U+609F, U+308A), 6 bytes. &#39;e6829fe3828a&#39;</p><p> ＆gt;＆gt;＆gt; ＆＃34; n＆＃34; .encode（＆＃34; utf-8＆＃34;）.hex（）＃1个字符（U + 006E），1个字节。 ＆＃39; 6e＆＃39; ＆gt;＆gt;＆gt; ＆＃34;🤿＆＃34; .encode（＆＃34; utf-8＆＃34;）.hex（）＃1个字符（U + 1F93F），4个字节。 ＆＃39; f09fa4bf＆＃39; ＆gt;＆gt;＆gt; ＆＃34;悟り＆＃34; .encode（＆＃34; utf-8＆＃34;）.hex（）＃2个字符（U + 609F，U + 308A），6个字节。 ＆＃39; e6829fe3828a＆＃39;</p><p> Every programming language I know of that respects the difference betweenraw bytes and Unicode text maintains a strict separation between the twodatatypes.</p><p> 我所知道的每种编程语言都尊重原始字节和Unicode文本之间的差异，这两种数据类型之间保持严格的分隔。</p><p> In Python 3 this strict separation is enabled by default. Notice that itdoesn&#39;t consider  n and this sequence of raw bytes to be the same thing.</p><p> 在Python 3中，默认情况下会启用此严格分隔。请注意，它不认为n与原始字节序列是同一回事。</p><p>    If we can get Python 2 to understand Unicode like Python 3 does, then we canprobably fix our bug.</p><p>    如果我们可以像Python 3一样让Python 2理解Unicode，那么我们就可以修复我们的错误。</p><p> As an aside, if you want to learn more about how to handle Unicode in Python,check out  Ned Batchelder&#39;s talk on   Pragmatic Unicode.</p><p> 另外，如果您想了解更多有关如何在Python中处理Unicode的信息，请查看Ned Batchelder关于实用Unicode的演讲。 </p><p>  Python 2 does actually know about Unicode, but it considers Unicode text tobe separate from &#34;normal&#34; text. At some point in Python 2 history the  unicode type was bolted onto the side of the language andnot enabled by default. Hard to get excited about it, but it does the trick.At least they knew it&#39;s a pain to type  unicode() all the time, so there&#39;s ahandy literal syntax using a  u prefix.</p><p>Python 2实际上确实了解Unicode，但是它认为Unicode文本与＆＃34; normal＆＃34;是分开的。文本。在Python 2历史记录中的某个时候，unicode类型被固定在该语言的一侧，并且默认情况下未启用。很难对此感到兴奋，但是它确实成功了。至少他们知道总是一直键入unicode（）是一件很麻烦的事，因此使用u前缀可以方便地实现文字语法。</p><p>  This is  not the best fix, but it did in a pinch. We added a line convertingthe hostname to Unicode right off the bat. We also applied the sametransformation to the line with brackets. This way we always process thehostname as Unicode and we always return a Unicode value.</p><p>  这不是最好的解决方案，但确实很关键。我们立即添加了将主机名转换为Unicode的行。我们还将相同的变换应用于带方括号的行。这样，我们始终将主机名处理为Unicode，并且始终返回Unicode值。</p><p> def safe_host(host): &#34;&#34;&#34;Surround `host` with brackets if it is an IPv6 address.&#34;&#34;&#34; + host = u&#34;{}&#34;.format(host)  try: if ip_address(host).version == 6: - return &#34;[{}]&#34;.format(host) + return u&#34;[{}]&#34;.format(host)  except ValueError: pass</p><p> def safe_host（host）：如果主机是IPv6地址，请用括号将＆quot; host括起来；＆＃34;＆＃34;＆＃34; + host = u＆＃34; {}＆＃34; .format（host）尝试：if ip_address（host）.version == 6：-返回＆＃34; [{}]＆＃34; .format（host） +返回u＆＃34; [{}]＆＃34; .format（host），但ValueError：通过</p><p> Luckily for us the  u prefix also works in Python 3 whereas  unicode() does not(because  all text is Unicode by default, so the type has nobusiness existing). In Python 3 the  u is treated as a  no-op.</p><p> 对我们来说幸运的是，u前缀也可以在Python 3中使用，而unicode（）则不能（因为默认情况下所有文本都是Unicode，所以该类型不存在任何业务）。在Python 3中，将u视为无操作。</p><p>   When we use the  unicode type the  ipaddress module no longer tries tointerpret  node.example.com as  bytes and convert those bytes to an IPaddress. We get just what we expect</p><p>   当我们使用unicode类型时，ipaddress模块​​不再尝试将node.example.com解释为字节并将这些字节转换为IP地址。我们得到了我们所期望的</p><p> &gt;&gt;&gt;  try : ...  ipaddress.ip_address( u &#34;node.example.com&#34; ) ...  except  ValueError  as  error: ...  print (error) ...  u &#39;node.example.com&#39;  does  not  appear to be an IPv4  or  IPv6 address</p><p> ＆gt;＆gt;＆gt;尝试：... ipaddress.ip_address（u＆＃34; node.example.com＆＃34;）...除了ValueError作为错误：... print（error）... u＆＃39; node.example。 com＆＃39;似乎不是IPv4或IPv6地址</p><p>  ✔  OK  py27 in  1 . 728  seconds✔  OK  py36 in  2 . 775  seconds✔  OK  py37 in  2 . 717  seconds✔  OK  py38 in  2 . 674  seconds✔  OK  py39 in  2 . 506  seconds</p><p>  ✔确定py27 in 1。 728秒✔确定py36 in 2。 775秒✔确定py37 in 2。 717秒✔确定py38 in 2。 674秒✔确定py39 in 2。 506秒 </p><p>  I mentioned above that our fix wasn&#39;t the best. Given more time, how can we dobetter?</p><p>我在上面提到我们的解决方案不是最好的。如果有更多时间，我们该如何做呢？</p><p> The first (and best) solution here is to drop Python 2 support. It&#39;s 2020now and Python 2 is officially no longer supported. The original code worked onPython 3. The best long-term decision is to migrate the code to run on Python 3 only and avoid the hassle of Python 2 maintenance. Unfortunately many ofthe people running this code still depend on it working on Python 2, so we&#39;llhave to make that transition gracefully.</p><p> 这里的第一个（也是最好的）解决方案是放弃对Python 2的支持。 2020now和Python 2正式不再受支持。原始代码适用于Python3。最好的长期决策是迁移代码使其仅在Python 3上运行，并避免Python 2维护的麻烦。不幸的是，运行此代码的许多人仍然依赖于在Python 2上运行的代码，因此我们必须进行适当的过渡。</p><p> If a migration away from Python 2 isn&#39;t possible in the near-term, the nextbest thing to do is update our code so that it uses a compatibility layer like  future or   six. Those libraries are designed to modernizePython 2 and help smooth over issues like this one.</p><p> 如果在短期内无法从Python 2迁移出去，那么接下来要做的就是更新我们的代码，以便它使用诸如future或6这样的兼容性层。这些库旨在使Python 2现代化，并帮助解决此类问题。</p><p> It also wouldn&#39;t hurt for us to take a page from  Alexis King&#39;s  Parse, don&#39;t validate school of thought. When thehostname enters our program via user input it should  immediately beconverted to the  unicode type (or maybe even an IP address type) so we don&#39;tend up solving this problem in several different places throughout the code.</p><p> 对我们来说，从亚历克西斯·金（Alexis King）的Parse翻页也不会感到伤害，也不必验证思想流派。当主机名通过用户输入进入我们的程序时，应立即将其转换为unicode类型（甚至IP地址类型），因此在整个代码中，我们不会在多个不同位置解决此问题。</p><p> Finally, though our program doesn&#39;t currently handle any hostnames in languagesother than English, it&#39;s probably best to be thinking in Unicode anyway. Again,it&#39;s 2020 and  internationalized domain names like  https://Яндекс.рфare a thing.</p><p> 最后，尽管我们的程序当前不使用英语以外的其他语言来处理任何主机名，但无论如何，最好还是以Unicode的方式进行思考。同样，2020年和https：//andндекс.рф之类的国际化域名也很重要。</p><p> If you made it this far, thanks for reading. It was fun to turn a briefdebugging session with my co-worker into a treatise on the perils of Python 2and the value of Unicode. See you next year! 😂</p><p> 如果您到现在为止，请多谢阅读。将与我的同事进行的简短调试会议变成关于Python 2的危险和Unicode的价值的论文很有趣。明年再见！ 😂 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://tuckersiemens.com/posts/node-example-com-is-an-ip-address/">https://tuckersiemens.com/posts/node-example-com-is-an-ip-address/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ip/">#ip</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>