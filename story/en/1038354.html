<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么是可空类型？ Why Nullable Types?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why Nullable Types?<br/>为什么是可空类型？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-08 10:58:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/d0ac1494563e306aafe8b8f3aababd46.jpeg"><img src="http://img2.diglog.com/img/2020/12/d0ac1494563e306aafe8b8f3aababd46.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>A few weeks ago, we announced Dart null safety beta, a major productivity feature intended to help you avoid null errors. Speaking of null values, in the /r/dart_lang subreddit  a user recently asked:</p><p>几周前，我们发布了Dart null安全测试版，这是一项主要的生产力功能，旨在帮助您避免null错误。说到空值，用户最​​近在/ r / dart_lang subreddit中询问：</p><p> But why do we even still have/want null values? Why not get rid of it completely? I’m currently also playing around with Rust and it doesn’t have null at all. So it seems to be possible to live without it.</p><p> 但是，为什么我们仍然有/想要空值？为什么不彻底摆脱它呢？我目前也在玩Rust，它根本没有null。因此，似乎没有它就可以生存。</p><p> I love this question. Why  not get rid of  null completely? This article is an expanded version of what I answered on that thread.</p><p> 我喜欢这个问题。为什么不完全摆脱null？本文是我在该线程上回答的扩展版本。</p><p> The short answer is that, yes, it is entirely possible to live without  null, and languages like Rust do. But programmers  do use  null, so before we can take it away, we need to understand why it’s used. What is  null usually  doing when we use it in languages that do have it?</p><p> 简短的答案是，是的，完全有可能没有null，Rust这样的语言也可以。但是程序员确实会使用null，因此在我们将其取消之前，我们需要了解为什么使用它。当我们在拥有null的语言中使用null时，通常会做什么？</p><p> It turns out that  null is typically used to represent the  absence of a value, which is eminently useful. Some people don’t have middle names. Some mailing addresses don’t have apartment numbers. Some monsters don’t have any treasure to drop when you slay them.</p><p> 事实证明，空值通常用于表示缺少值，这非常有用。有些人没有中间名。有些邮寄地址没有公寓号码。杀死某些怪物时，它们不会掉落任何宝藏。</p><p> In cases like that, we want a way to express, “This variable could have a value of type X, or it may have no value at all.” The question then is how do we model that?</p><p> 在这种情况下，我们需要一种表达方式，“此变量可能具有类型X的值，或者可能根本没有任何值。”那么问题是我们如何建模呢？</p><p> One option is to say that a variable can contain a value of the expected type, or it can contain the magic value  null. If we try to use the value when it’s  null, we get a runtime failure. This is what Dart did before null safety, what SQL does, what Java does for non-primitive types, and what C# does for class types.</p><p> 一种选择是说变量可以包含期望类型的值，或者可以包含幻值null。如果尝试使用该值为null的值，则会导致运行时失败。这是Dart在执行null安全之前所做的事情，SQL所做的事情，Java对非原始类型所做的事情以及C＃对类类型所做的事情。 </p><p> But failing at runtime sucks. It means our users experience the bug. We programmers would rather find those failures before they do. In fact, we’d be happy if we could find the bugs even before  we ran our program. So how do we model the absence of a value in a way that the type system understands? In other words, how do we give “potentially absent” values and “definitely present” values different static types?</p><p>但是在运行时失败很糟糕。这意味着我们的用户会遇到该错误。我们程序员宁愿先找到那些失败，然后再去发现。实际上，如果在运行程序之前就可以找到错误，我们将非常高兴。那么，如何以类型系统可以理解的方式对缺少值进行建模？换句话说，我们如何给“可能不存在”的值和“绝对存在”的值提供不同的静态类型？</p><p>    This is what  ML and most functional languages derived from ML (including Rust, Scala, and Swift) do. When we know we will definitely have a value, we just use the underlying type. If we write  int it means, “There is definitely an integer here.”</p><p>    这就是ML和从ML派生的大多数功能语言（包括Rust，Scala和Swift）所做的事情。当我们知道肯定会有一个值时，我们只使用基础类型。如果我们将int写为int，则表示“这里肯定有一个整数”。</p><p> To express a potentially absent value, we  wrap the underlying type in an  option type. So  Option&lt;int&gt; represents a value that might be an integer or might be nothing at all. It’s like a collection type that can contain zero or one item.</p><p> 为了表示一个可能不存在的值，我们将基础类型包装在一个选项类型中。因此Option＆lt; int＆gt;表示一个可能是整数或根本没有值的值。就像一个集合类型，可以包含零个或一个项目。</p><p> From the type system’s perspective, there is no direction relationship between  int and  Option&lt;int&gt;. Treating these as distinct types means we can’t accidentally pass a potentially-absent  Option&lt;int&gt; to something expecting a real  int. We also can’t accidentally try to use an  Option&lt;int&gt; as if it were an integer since it doesn’t support any of those operations. We can’t perform arithmetic on an  Option&lt;int&gt; any more than we could on a  List&lt;int&gt;.</p><p> 从类型系统的角度来看，int和Option＆lt; int＆gt;之间没有方向关系。将它们视为不同的类型意味着我们不会意外地传递可能不存在的Option＆lt; int＆gt;期待真正的诠释。我们也不能偶然尝试使用Option＆lt; int＆gt;好像是整数，因为它不支持任何这些操作。我们无法对Option＆lt; int＆gt;执行算术运算比我们在List＆lt; int＆gt;上所能提供的更多。</p><p> To create a value of an option type from a present value of the underlying type (say  3), you construct the option like  Some(3). To create an option type when the value is absent, you write something like  None().</p><p> 要从基础类型的当前值（例如3）创建选项类型的值，您可以构建类似于Some（3）的选项。要在缺少值时创建选项类型，请编写类似None（）的内容。</p><p> In order to use a potentially absent integer stored in an  Option&lt;int&gt;, we have to first check and see if the value is there. If so, we can extract the integer from the option and use it, just like reading a value out of a collection. Languages that have option types usually also have nice  pattern matching syntax, which gives us an elegant way to check if the value is there and use it if so.</p><p> 为了使用存储在Option＆lt; int＆gt;中的可能不存在的整数，我们必须首先检查并查看该值是否存在。如果是这样，我们可以从选项中提取整数并使用它，就像从集合中读取值一样。具有选项类型的语言通常也具有很好的模式匹配语法，这为我们提供了一种优雅的方式来检查值是否存在，如果有，则使用它。</p><p>  The other option (heh), is what Kotlin, TypeScript, and now Dart do.  Nullable types are a special case of  union types.</p><p>  另一个选项（heh）是Kotlin，TypeScript和现在的Dart所做的。可空类型是联合类型的特殊情况。 </p><p> (Tangent: The naming gets really confusing here. Option types — what ML and friends do above — are a special case of  algebraic datatypes. Another name for algebraic datatypes is “discriminated unions”. But, despite “union” being in the name, “discriminated unions” are quite different from “union types”. As Phil Karlton said, there are only two hard problems in computer science: cache invalidation and naming things.)</p><p>（Tangent：这里的命名确实让人感到困惑。选项类型-ML和朋友在上面所做的事情-是代数数据类型的特例。代数数据类型的另一个名称是“歧视联合”。但是，尽管有“工会”的名字， “有区别的工会”与“工会类型”大不相同。正如菲尔·卡尔顿所说的那样，计算机科学中只有两个难题：缓存失效和事物命名。）</p><p> Similar to the option type approach, we use the underlying type to represent a definitely present value. So  int again means we absolutely have an integer. If we want a potentially absent integer, we instead use the  int? nullable type. The little question mark is syntactic sugar for writing what is essentially a union type like  int | Null.</p><p> 与期权类型方法类似，我们使用基础类型表示绝对现值。所以int再次表示我们绝对有一个整数。如果我们想要一个可能不存在的整数，则使用int吗？可为null的类型。小问号是语法糖，用于编写本质上像int |的联合类型。空值。</p><p> Just like with option types, a nullable type does not support the same operations as the underlying type. The type system won’t let us try to perform arithmetic on a nullable  int because that isn’t safe. Likewise, we can’t pass a nullable integer to something that requires an actual integer.</p><p> 与选项类型一样，可为空的类型不支持与基础类型相同的操作。类型系统不允许我们尝试对可为null的int进行算术运算，因为那是不安全的。同样，我们无法将可为空的整数传递给需要实际整数的对象。</p><p> However, the type system is a little more flexible than with option types. The type system understands that a union type is a supertype of its branches. In other words,  int is a subtype of  int?. That means we  can pass a definitely-present-integer to something that expects a maybe-present-integer since that’s safe to do. It’s an upcast, just like we can pass a  String to a function that takes  Object. Dart only prohibits us from going the other way—from nullable to non-nullable—because that would be a downcast and those could fail.</p><p> 但是，类型系统比选项类型更具灵活性。类型系统理解联合类型是其分支的超类型。换句话说，int是int？的子类型。这意味着我们可以将肯定存在的整数传递给期望可能存在的整数，因为这样做是安全的。就像我们可以将String传递给采用Object的函数一样，这是一个失败。 Dart仅禁止我们采取其他方式-从可为空到不可为空-因为这将是一个失败的选择，并且可能会失败。</p><p> When we have a value of a nullable type and we want to see if there is an actual value or  null there, we check the value imperatively just like we would naturally do in C or Java:</p><p> 当我们有一个可为null的类型的值并且想要查看是否存在实际值或为null时，我们就必须像在C或Java中那样自然地对值进行强制检查：</p><p>  The language then uses  flow analysis to determine which parts of the program are guarded behind those checks. The analysis determines that code can only be reached if the variable is not  null, so inside those regions, the type system tightens the variable’s type to be non-nullable. So, here, it treats  i as having type  int inside the  if statement.</p><p>  然后，该语言使用流程分析来确定程序的哪些部分在这些检查之后受到保护。分析确定只有在变量不为null时才能访问代码，因此在这些区域内，类型系统将变量的类型限制为不可为null。因此，在这里，它将i视为在if语句中具有int类型。</p><p>  So when we on the Dart team decide to make the language handle null in a safer way, how should we go about choosing solution 1 or 2? We can start by observing our users. How do they want to write code that checks for absent values? In functional languages, pattern matching is one of the primary control flow structures, and users there are very comfortable with it. Using option types and pattern matching is natural in that style.</p><p>  因此，当我们Dart团队决定以一种更安全的方式使语言处理为空时，我们应该如何选择解决方案1或2？我们可以从观察用户开始。他们想如何编写代码来检查缺少的值？在功能语言中，模式匹配是主要的控制流程结构之一，用户对此非常满意。在这种风格中，使用选项类型和模式匹配是很自然的。 </p><p> In imperative languages derived from C, code like my previous example is the idiomatic way to check for  null. Using flow analysis and nullable types makes that familiar code work correctly and safely. In fact, with Dart, we’ve found that  most existing code is already statically null safe with the new type system because the new flow analysis correctly analyzes the already written code.</p><p>在从C派生的命令式语言中，像我之前的示例一样的代码是检查null的惯用方式。使用流分析和可为空的类型可以使熟悉的代码正确，安全地工作。实际上，借助Dart，我们发现对于新类型的系统，大多数现有代码已经静态地为null安全，因为新的流程分析可以正确分析已编写的代码。</p><p> (This is in some ways not a surprise.  Most code is already  dynamically correct with regards to handling  null. If it wasn’t, it would be crashing all the time. Much of the job is simply making the type system smart enough to see that that code is already correct, so that the user’s attention is drawn to the few bits that are  not.)</p><p> （这在某些方面不足为奇。大多数代码在处理null方面已经是动态正确的。如果不是，那么它将一直崩溃。许多工作只是使类型系统足够智能，以至于可以看到该代码已经正确，因此用户的注意力会吸引到一些不正确的代码上。）</p><p> So if our goal is to maximize familiarity and user comfort (which  are important criteria in language design), we should just follow the path that our language’s control flow structures lay out for us.</p><p> 因此，如果我们的目标是最大程度地提高用户的熟悉度和用户舒适度（这是语言设计中的重要标准），那么我们应该遵循我们的语言控制流程结构为我们提供的路径。</p><p>  There is a deeper way to approach this question based on differences between how option types and nullable types are represented. That representation difference forces a few key trade-offs on us, and those might lean us in one direction or the other.</p><p>  根据选项类型和可为空类型的表示方式之间的差异，有一种更深层的方法可以解决此问题。这种表示差异会给我们带来一些关键的权衡，而这些权衡可能会使我们朝一个方向或另一个方向倾斜。</p><p> With the first approach, a value of option type has a runtime representation distinct from the underlying value. Say we chose option types in Dart, and you created one and then upcast it to  Object:</p><p> 使用第一种方法，选项类型的值具有与基础值不同的运行时表示形式。假设我们在Dart中选择了选项类型，然后您创建了一个选项类型，然后将其向上转换为Object：</p><p>  Note the last line. An  Option&lt;int&gt; value, even when present, is  not the same kind of thing as a value of the underlying type.  Some(3) and  3 are distinct, distinguishable values.</p><p>  注意最后一行。 Option＆lt; int＆gt;值（即使存在）与基础类型的值也不一样。 Some（3）和3是不同的，可区分的值。</p><p>   Nullable types exist in the  static type system, but the runtime representation of values uses the underlying type. If you have a “nullable 3”, at runtime it’s just the number  3. If you have an absent value of some nullable type, at runtime you just have the solitary magic value  null.</p><p>   可空类型存在于静态类型系统中，但是值的运行时表示形式使用基础类型。如果您有一个“可空3”，那么在运行时它只是数字3。如果您缺少某个可空类型的值，那么在运行时，您将单独的魔术值设为空。 </p><p>      Since values of option types are different from the underlying type, this gives us an important capability: Option types can nest.</p><p>由于选项类型的值与基础类型不同，因此这为我们提供了一项重要功能：选项类型可以嵌套。</p><p> Let’s say we have some network service that gives out resource strings when given a request with some integer ID. Some resources are not present and the server will respond with no data for that ID. Since hitting the network is slow, we want to locally cache the results of requests we’ve already performed.</p><p> 假设我们有一些网络服务，当提供带有整数ID的请求时，该服务会发出资源字符串。某些资源不存在，服务器将不响应该ID的任何数据。由于连接网络的速度很慢，因此我们希望在本地缓存已经执行的请求的结果。</p><p>   So before making a network request for some ID, we use the subscript operator on the cache map to look up the resource’s ID. That operator is defined on  Map to return  null if the key is not present. But the key could also be present and associated with a  null value. If we do a lookup and get back  null, it could mean either:</p><p>   因此，在向网络请求某些ID之前，我们使用缓存地图上的下标运算符来查找资源的ID。如果键不存在，则该操作符在Map上定义为返回null。但是键也可以存在并且与空值关联。如果我们进行查找并返回null，则可能意味着：</p><p> The key was not present in the map. This means we haven’t done the request yet, so we should ask the server to look up the resource.</p><p> 钥匙不在地图上。这意味着我们尚未完成请求，因此我们应要求服务器查找资源。</p><p> The key was present and associated with  null. This means we already did ask the server, found that the resource wasn’t present, and stored that in the cache. We should use that result and not query the server again.</p><p> 密钥存在并且与null关联。这意味着我们确实已经询问服务器，发现资源不存在，并将其存储在缓存中。我们应该使用该结果，而不要再次查询服务器。</p><p> Because there’s only a single  null value in the entire system, we don’t have a runtime representation that can distinguish these two cases. This is why the  Map class has a separate  containsKey() method. That API provides a way to distinguish these two cases.</p><p> 由于整个系统中只有一个null值，因此我们没有可以区分这两种情况的运行时表示形式。这就是Map类具有单独的containsKey（）方法的原因。该API提供了区分这两种情况的方法。</p><p>     In the case of our  Map&lt;int, Option&lt;String&gt;&gt;, that means the return type is  Option&lt;Option&lt;String&gt;&gt;. Note the nesting! Now, when we look up a key in the cache, we can get a few different results:</p><p>     在我们的Map＆lt; int，Option＆lt; String＆gt;＆gt;的情况下，这意味着返回类型是Option＆lt; Option＆lt; String＆gt;＆gt;。注意嵌套！现在，当我们在缓存中查找键时，我们可以得到一些不同的结果： </p><p> A  Some(Some(string)) means the resource did exist on the server, and we have it in the cache now.</p><p>Some（Some（string））表示资源确实存在于服务器上，现在我们将其保存在缓存中。</p><p> A  Some(None()) means we did ask the server and the resource was not there, so we have cached the fact that the resource doesn’t exist.</p><p> Some（None（））意味着我们确实询问了服务器并且资源不存在，因此我们缓存了资源不存在的事实。</p><p> We can distinguish the last two cases because options always wrap their underlying value in some extra state. At runtime, we can determine how many layers there are and peel them off individually.</p><p> 我们可以区分最后两种情况，因为选项始终将其基础值包装在某些额外状态中。在运行时，我们可以确定有多少层并将其单独剥离。</p><p> Nullable types, since they have no explicit runtime representation, are implicitly flattened. So  int? and  int?? are equivalent types to the type system and have equivalent sets of values at runtime. This is why fans of option types describe them as “more expressive”: because optional types give you a way to represent more kinds of values than nullable types do.</p><p> 可空类型，因为它们没有显式的运行时表示形式，因此被隐式拉平。如此诠释？和诠释？是类型系统的等效类型，并且在运行时具有等效的值集。这就是为什么选项类型的爱好者将它们描述为“更具表现力”的原因：因为与可空类型相比，可选类型为您提供了一种表示更多类型的值的方式。</p><p>  Another way of thinking about “expressiveness” is how much  effort it takes for the user to express what they actually want to express. A language is more expressive if the user can reach their goal while jumping through fewer hoops.</p><p>  关于“表达能力”的另一种思考方式是，用户表达自己实际想要表达的内容要花费多少精力。如果用户可以通过较少的跳动而达到目标，那么语言将更具表现力。</p><p> An advantage of having no distinct representation for nullable types is that values can flow from non-nullable to nullable contexts much more easily. Let’s say you have a function that accepts an optional integer parameter. With option types, the signature would look something like:</p><p> 对于可空类型没有明显表示的优点是，值可以更容易地从不可空上下文流向可空上下文。假设您有一个接受可选整数参数的函数。使用选项类型时，签名将类似于：</p><p>  To call this function with a known integer, it must be wrapped in an option first:</p><p>  要使用已知整数调用此函数，必须先将其包装在选项中： </p><p>  With nullable types, since there is no representation difference, you can pass a value of the underlying type directly:</p><p>对于可为空的类型，由于没有表示形式的差异，因此可以直接传递基础类型的值：</p><p>  You get this flexibility everywhere in the type system. You can override a method that returns a nullable type to return a non-nullable type. You can pass a  List&lt;int&gt; to a function that wants a  List&lt;int?&gt;.</p><p>  您可以在类型系统中的任何地方获得这种灵活性。您可以重写返回可为null的类型的方法以返回不可为null的类型。您可以传递List＆lt; int＆gt;到需要List＆lt; int？＆gt;的函数。</p><p> So while nullable types lose the ability to nest and represent multiple distinct  kinds of “absence”, in return they make it much easier to work with the one blessed notion of  null.</p><p> 因此，尽管可空类型失去嵌套和表示多种不同类型“缺席”的能力，但作为回报，它们却使使用一个受祝福的空概念更加容易。</p><p>  Dart is an imperative language where people already use  if statements to check for absent values at runtime. It’s also an object-oriented language where we already have a special  null value with its own runtime representation. So solution 2, nullable types, was the natural answer for us. It lets our users write the kind of code they are familiar with, and takes advantage of how the runtime already represents values.</p><p>  Dart是一种命令式语言，人们已经在运行时使用if语句检查缺少的值。这也是一种面向对象的语言，我们已经有了一个特殊的null值及其自己的运行时表示形式。因此，解决方案2（可为空的类型）是我们的自然选择。它使我们的用户可以编写他们熟悉的代码类型，并利用运行时已经如何表示值的优势。</p><p> For more information about nullability in Dart, check out the  Where to learn more section of the  Dart null safety docs.</p><p> 有关Dart中的可空性的更多信息，请查看Dart null安全文档的“从哪里了解更多信息”部分。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nullable/">#nullable</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>