<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>图书：RISC-V二进制翻译 Libriscv: RISC-V Binary Translation</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Libriscv: RISC-V Binary Translation<br/>图书：RISC-V二进制翻译 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-01 09:01:51</div><div class="page_narrow text-break page_content"><p>I’ve had some thoughts about how to translate instructions one by one into C++ code and then   try to run that. I knew that I would want to translate RISC-V to some simple low level code, compile it and then load it as a shared object. The hope was that it would provide a significant speedup, removing some of the emulation overhead.  libriscv is already a fairly fast emulator that decodes every instruction into a function pointer for a single execute segment, however that’s naturally far behind native performance. With binary translation the hope is that this will allow me to come within 1/4 of native, although not in the first version.</p><p>我曾考虑过如何将指令一个接一个地转换为C ++代码，然后尝试运行该代码。我知道我想将RISC-V转换为一些简单的低级代码，进行编译，然后将其作为共享对象加载。希望它可以提供显着的加速，消除一些仿真开销。 libriscv已经是相当快的仿真器，可以将每个指令解码为单个执行段的函数指针，但是自然要远远落后于本机性能。使用二进制翻译，希望这将使我的母语翻译能力降低到1/4之内，尽管不是第一个版本。</p><p> This all began when I was reading the famous Popek &amp; Goldberg paper on the  requirements of virtual machines, and I realized I had to at least try to create some kind of efficient code for maybe the most important parts of the programs.</p><p> 这一切都是从我读著名的Popek＆amp; Goldberg谈到了虚拟机的需求，我意识到我至少必须尝试为程序中最重要的部分创建某种有效的代码。</p><p>  In the first version I started translating the RISC-V instructions one by one into C++, which could directly transform the state of the RISC-V machine. For the tiny executables I was working with this was not a problem. I quickly found out that code-block detection is really an art. I ended up stopping at every kind of branch and system instruction. In the end this would provide very little speedup due to many factors. One being not supporting enough instructions yet, as I was incrementally supporting more and more. The other issue was that translated blocks ended up being too short, adding overhead from entering and leaving this code. Worst of all though, the compilation times were horrible on bigger programs, and I was dependent on headers from the RISC-V emulators own project!</p><p>  在第一个版本中，我开始将RISC-V指令一个接一个地转换为C ++，这可以直接转换RISC-V机器的状态。对于那些很小的可执行文件，这不是问题。我很快发现，代码块检测确实是一门艺术。我最终停止了每种分支和系统指令。最后，由于许多因素，这将提供很少的加速。一个人还没有支持足够的指令，因为我越来越多地支持。另一个问题是，翻译后的块最终变得太短，增加了输入和离开此代码的开销。最糟糕的是，在较大的程序上，编译时间太可怕了，我依赖于RISC-V模拟器自己项目的标头！</p><p>  By only exiting the translated native code when a branch actually hit I could continue translating longer blocks which provided a bigger speedup. I also generated a custom API header which I embedded into the shared object, and freed myself of unneeded dependencies. Compilation times dropped significantly, but C++ remained complex to parse. I checked out the -ftime-report and there wasn’t much I could do other than contemplate moving on to C code generation. I actually seriously looked into how to reduce compilation times in general for both C and C++, and I couldn’t find much that I didn’t know already: Compile on  tmpfs, reduce header includes, avoid templates and so on.</p><p>  通过仅在分支实际命中时退出已翻译的本机代码，我可以继续翻译更长的块，从而提供更大的加速。我还生成了一个自定义API标头，将其嵌入共享对象中，并释放了不需要的依赖关系。编译时间大大减少，但是C ++解析仍然很复杂。我检查了-ftime-report，除了考虑继续进行C代码生成之外，我无能为力。实际上，我实际上认真地研究了如何减少C和C ++的编译时间，但我发现很多未知的东西：在tmpfs上进行编译，减少头文件，避免使用模板等等。</p><p>  By rewriting the whole thing to generate standard C the compilation times were now low enough to make this thing more usable for bigger executables. I also finished all the normal instructions and I saw significant speedup vs. my own untranslated benchmarks.</p><p>  通过重写整个东西以生成标准C，现在的编译时间已经足够短，可以使该东西对更大的可执行文件更有用。我还完成了所有正常的说明，与未翻译的基准测试相比，我看到了明显的加速。</p><p>  However, the biggest change was detecting loops! I was unable for the longest time to be faster than LuaJIT for fib(40) due to not being able to return to native code at loop locations. By scanning for negative-offset branch instructions and going back later to generate code for them I was able to fly right by LuaJIT. That is of course not very surprising when done properly, because I’m translating an optimized executable, while LuaJIT is doing everything alone — very quickly too! Truth be told, I’m comparing against Lua simply because of how easy it is to integrate. And it serves as a good target to compare against for a hobby project!</p><p>  但是，最大的变化是检测循环！由于无法在循环位置返回本机代码，我无法在最长的时间内比LuaJIT的fib（40）更快。通过扫描负偏移量的分支指令，然后回头为它们生成代码，我可以通过LuaJIT进行正确的飞行。如果正确完成，那当然也就不足为奇了，因为我正在翻译一个优化的可执行文件，而LuaJIT却独自完成了所有事情-很快！实话实说，我之所以与Lua进行比较，仅仅是因为它很容易集成。它是与业余项目进行比较的一个很好的目标！</p><p>    Since compilation can take some time depending on the size of the program it would be nice if we could just keep it for later, in a temp location. So, if you enable the feature in the library, it will CRC32 the code and compiler arguments and use the checksum as part of the filename. We can then find the same file again later. We don’t want to have obscure bugs where some minor change caused a cached shared object to behave erroneously, so this is a great way to avoid that. I call it this the translation cache, and it’s shared libraries that are compiled from translated RISC-V. The code generation is quite fast, and it can be made faster again with C++20’s std::format whenever that is widely available. The check-summing is also very fast as I made sure to use the CRC32-C instructions when SSE4.2 is available.</p><p>    由于编译可能要花费一些时间，具体取决于程序的大小，因此，如果我们可以稍后将其保存在临时位置，那将是很好的。因此，如果在库中启用该功能，它将对代码和编译器参数进行CRC32校验，并将校验和用作文件名的一部分。然后，我们可以稍后再次找到相同的文件。我们不希望出现一些不起眼的错误，因为一些微小的更改会导致缓存的共享库出现错误，因此，这是避免这种情况的好方法。我将其称为翻译缓存，它是从翻译后的RISC-V编译的共享库。代码生成非常快，只要有广泛的使用，就可以使用C ++ 20的std :: format再次使其更快。由于SSE4.2可用时，我确保使用CRC32-C指令，因此校验和也非常快。 </p><p> It’s certainly very interesting seeing the translator ignoring your new binary if all you changed was the names of some variables and some comments. Sometimes the code is the same, and the checksum will reflect that.</p><p>如果您更改的只是一些变量的名称和一些注释，那么看到翻译器忽略您的新二进制文件肯定会很有趣。有时代码是相同的，校验和将反映出这一点。</p><p>  So let’s talk about some of the hurdles that remain, and might not ever be solved. First off, when you scan for code blocks to translate you have to use a treshold for minimum block size. If you don’t you can sit there and translate forever and increase compile times, very likely with little benefit.</p><p>  因此，让我们谈谈仍然存在的，可能永远无法解决的一些障碍。首先，当您扫描要翻译的代码块时，必须使用阈值以最小化块大小。如果您不这样做，则可以坐在那里永久地翻译并增加编译时间，这几乎没有什么好处。</p><p> Another is that there is a maximum number of code blocks and instructions (counted separately) that you are willing to translate. And surprisingly this works out very well, because the code you care about is higher up in the executable layout! I tried experimenting with a lot of combinations of code block and instruction counts, and after a certain number you don’t get anything back anymore. Maybe you get it back in startup time, but for my projects I don’t care about that — especially if I’m using binary translation with an expensive compilation stage.</p><p> 另一个是您愿意翻译的代码块和指令（单独计算）的最大数量。出乎意料的是，该方法效果很好，因为您关心的代码在可执行文件布局中更高！我尝试了多种代码块和指令计数的组合，经过一定数量的尝试后，您一无所有。也许您在启动时就将其恢复了，但是对于我的项目，我并不在乎，特别是如果我在编译阶段使用二进制翻译的时候。</p><p> Every register-change inevitably has to be saved in the emulators register file. This means extra instructions, extra stores and while it can be improved upon by optimizers, especially in tight loops, at the end these stores have to be committed only for most of the stores to be ignored afterwards.</p><p> 每个寄存器更改不可避免地必须保存在仿真器寄存器文件中。这意味着需要额外的指令，额外的存储，尽管可以通过优化器对其进行改进，尤其是在紧密循环中，但最后只必须提交这些存储，之后大部分存储都将被忽略。</p><p> There are significant differences in compile times between compilers. The fastest so far has been  clang with - fuse-ld=lld. Reducing the time it takes to compile the translated code is the biggest hurdle right now. Right now small executables finish almost instantly, but larger executables have an exponential scaling in compile times. For example a C++ example program with exceptions and everything enabled will take a few seconds to compile, with optimizations enabled (-O2). Less so with optimizations off (-O0). I made it so that you can pass CC and CFLAGS to the process that hosts libriscv to control these things.</p><p> 编译器之间的编译时间有很大差异。到目前为止，最快的是-fuse-ld = lld。减少编译翻译代码所花费的时间是目前最大的障碍。现在，小型可执行文件几乎立即完成，但是大型可执行文件的编译时间呈指数级增长。例如，一个带有例外且启用了所有功能的C ++示例程序将花费几秒钟的时间进行编译，并且启用了优化（-O2）。禁用优化（-O0）则更少。我这样做是为了使您可以将CC和CFLAGS传递给托管libriscv的进程来控制这些事情。</p><p> On the flipside, you can just turn it off and get instant execution.  It depends on your needs.</p><p> 另一方面，您可以将其关闭并立即执行。这取决于您的需求。</p><p>  I’m sure many of you are wondering why I’m not just generating assembly directly. That is completely out of the question. It’s not portable, it’s going to take months and maybe years to get everything right. It does have nearly instant linking time. But, I will miss the big picture all the time. I won’t be able to generate optimal assembly at all without reinventing the optimization wheel. The most common way to optimize assembly is peephole-optimization. Instead, there is now a portable solution to binary translation that you can tune optimization levels for. It will work on your ARM server, your desktop and your mobile phone! For iOS and Nintendo Switch you can just turn off binary translation.</p><p>  我敢肯定，你们中的许多人都在想为什么我不只是直接生成程序集。那完全是不可能的。它不是便携式的，要花费一切，可能要花几个月甚至几年的时间。它确实具有几乎即时的链接时间。但是，我会一直怀念全局。如果不重新发明优化轮，我将无法生成最佳装配。优化装配的最常见方法是窥孔优化。取而代之的是，现在有一个可移植的二进制转换解决方案，您可以调整其优化级别。它可以在您的ARM服务器，台式机和手机上使用！对于iOS和Nintendo Switch，您只需关闭二进制翻译即可。 </p><p>  If any stage of binary translation fails the emulator will clean up temporaries and fall back to regular emulation. I’m not sure if it’s the right thing to do, but there is a boolean getter in Machine that tells you if the currently running program is using a natively compiled shared object or not.</p><p>如果二进制翻译的任何阶段失败，则仿真器将清理临时文件并退回常规仿真。我不确定这样做是否正确，但是Machine中有一个布尔型getter来告诉您当前正在运行的程序是否正在使用本机编译的共享库。</p><p>  I actually don’t have any set plans other than sitting on this feature branch for a week to see if it’s stable and if the compilation times can be improved upon. I was considering trying out libtcc, so I could translate and compile to amd64 directly to memory. I already tried using it to manually compile the output from binary translation and loading that, however there is clearly some miscompilation going on as the guest fails on every program I tested. Not sure if I have some unclear C code or TCC is just being a bit buggy, but it compiles without warnings and all the public symbols are present. So I have put it on a shelf for now. The first thing I would check is if it miscompiles sign extension casts, for example:  (int64_t)(int8_t)value. Or if it misbehaves when I’m using unions to modify floating-point values.</p><p>  实际上，除了坐在该功能分支上一周以查看它是否稳定以及是否可以改善编译时间外，我没有任何计划。我当时正在考虑尝试libtcc，这样我就可以将amd64编译并直接编译到内存中。我已经尝试过使用它来手动编译二进制翻译和加载的输出，但是由于来宾在我测试的每个程序上均失败，因此显然存在一些误编译。不知道我是否有一些不清楚的C代码或TCC是否只是个小虫，但是它编译时没有警告，并且所有公共符号都存在。所以我现在把它放在架子上。我要检查的第一件事是它是否错误编译符号扩展名强制转换，例如：（int64_t）（int8_t）value。或者，当我使用联合来修改浮点值时，如果行为不当。</p><p> There are also still many improvements I can do to simplify the generated C code. I tried caching function prologues/epilogues, but I failed to see much of an improvement in actual run-time which just reaffirms that C compilers are really good, or maybe its the hardware too. I’m glad I chose C in the end because it’s a language where you can seriously reduce the code size as-needed, as that was one of its primary goals in the beginning. That’s why you have the ternary operator, ++ and single-char operators (^) instead of words (xor). It’s perfect for my use-case and I can probably improve on the compile times somewhat by reducing the overall code size.</p><p> 我仍然可以做很多改进来简化生成的C代码。我尝试了缓存函数序言/结尾，但是我没有看到实际运行时的很多改进，只是重申了C编译器确实很好，或者它的硬件也是如此。我很高兴最终选择了C，因为它是一种您可以根据需要严重减少代码大小的语言，因为这是一开始它的主要目标之一。这就是为什么要使用三元运算符，++和单字符运算符（^）而不是单词（xor）的原因。它非常适合我的用例，并且可以通过减少整体代码大小来改善编译时间。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fwsgonzo.medium.com/libriscv-risc-v-binary-translation-e080f52ee696">https://fwsgonzo.medium.com/libriscv-risc-v-binary-translation-e080f52ee696</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>