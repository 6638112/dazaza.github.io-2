<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用UNION按数量级加速SQL查询 Speeding up SQL queries by orders of magnitude using UNION</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Speeding up SQL queries by orders of magnitude using UNION<br/>使用UNION按数量级加速SQL查询 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-21 03:44:03</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/dc27ff01a01c95d2ea8e490a3ca95c8b.jpg"><img src="http://img2.diglog.com/img/2021/3/dc27ff01a01c95d2ea8e490a3ca95c8b.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>SQL is a very powerful tool for querying data. It allows you to write queries against your relational data in a declarative manner, letting you describe  what data that you want to retrieve without having to describe  how to retrieve it. In most cases, this works very well, and the query optimizer in many database engines (MySQL, PostgreSQL, etc.) will create an efficient query plan.</p><p>SQL是一个非常强大的查询数据的工具。它允许您以声明方式对您的关系数据编写查询，让您描述要检索的数据，而无需介绍如何检索它。在大多数情况下，这很好地运行，并且许多数据库引擎（MySQL，PostgreSQL等）中的查询优化器将创建一个有效的查询计划。</p><p> Efficient query plans rely on a schema that uses appropriate data types, especially for primary key columns, where doing things such as misusing  VARCHAR can kill performance. Another critical element of enabling fast query plans is appropriately indexing columns, which eliminates the need to perform full table scans when retrieving data. Unfortunately, even following these schema rules, it’s possible to write SQL queries that have surprisingly poor performance, often leading to the bewilderment of the developer writing such a query. Perhaps the most surprising aspect of this type of query is that it is often written in the most intuitive way to describe the data.</p><p> 高效的查询计划依赖于使用适当的数据类型的模式，特别是对于主键列，其中误用varchar等事物可以杀死性能。启用快速查询计划的另一个关键元素是适当的索引列，这消除了在检索数据时执行全表扫描的需要。遗憾的是，即使遵循这些模式规则，也可以编写令人惊讶的表现令人惊讶的SQL查询，往往导致开发人员写作此类查询的困惑。也许这类查询的最令人惊讶的方面是它通常以最直观的方式编写来描述数据。</p><p>  One of the most common cases where SQL query performance can degrade significantly is in a diamond shaped schema, where there are multiple ways of joining two tables together. In such a schema, a query is likely to use  OR to join tables in more than one way, which eliminates the optimizer’s ability to create an efficient query plan. This scenario is best illustrated through an example.</p><p>  SQL查询性能可能显着降低的最常见情况之一是菱形模式，其中有多种方式将两个表连接在一起。在这样的模式中，查询可能会使用或以多种方式加入表，这消除了优化程序创建有效查询计划的能力。这种情况是最好通过一个例子说明的。</p><p> Imagine we have the following schema for a chain of retail stores that sell food and drink. The table layout is as follows:</p><p> 想象一下，我们有以下零售商店的架构，销售食品和饮料。表布局如下：</p><p> stores +---------+------+ customers +----&gt;| id | int |&lt;----------------+ +----------+------+ | | address | text | |+---&gt;| id | int | | +---------+------+ || | name | text | | || | store_id | int +--+ employees || +----------+------+ +----------+------+ || +-----&gt;| id | int | || | | name | text | || customer_orders | | role | text | || +-------------+-----------+ | | store_id | int +--+| | id | int |&lt;--+ | +----------+------++--+ customer_id | int | | | | created | timestamp | | | +-------------+-----------+ | | employee_markouts | | +--------------+-----------+ | | | id | int | customer_order_items | +--+ employee_id | int | +-------------------+-----+ | | meal_item_id | int +--+ | id | int | | | created | timestamp | | | customer_order_id | int +--+ +--------------+-----------+ | +--+ meal_item_id | int | | | +-------------------+-----+ | | meal_items | | +-------+------+ | +--------------------------------&gt;| id | int |&lt;--------------------+ | label | text | | price | int | +-------+------+</p><p> 商店+ --------- + ------ +客户+ ----＆gt; | ID | INT |＆lt;  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -  --------- + ------ + | |地址|文字| | + ---＆gt; | ID | int | | + --------- + ------ + || |名称|文字| | || | store_id | int +  -  +员工|| + ---------- + ------ + + --------- + ------ + || + -----＆gt; | ID | int | || | |名称|文字| || customer_orders | |角色|文字| || + ------------- + ----------- + | | store_id | int +  -  + | | ID | int |＆lt;  -  + | + ---------- + ------ ++  -  + customer_id | int | | | |创造|时间戳| | | + ------------- + ----------- + | | employee_markouts | | + ------------- + ----------- + | | | ID | int | customer_order_items | +  -  +员工_ID | int | + ------------------ + ----- + | | meat_item_id | int +  -  + | ID | int | | |创造|时间戳| | | customer_order_id | int +  -  + + ------------- + ----------- + | +  -  + ENTEM_ITEM_ID | int | | | + ------------------ + ----- + | | meat_items | | + ------- + ------ + | + ----------------------------＆gt; | ID | int |＆lt;  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -  + |标签|文字| |价格| int | + ------- + ------ +</p><p>  Both  customer_order_items and  employee_markouts reference  meal_items, which include the labels and prices of the food items sold.</p><p>  Customer_Order_Items和employee_markouts参考日内，其中包括销售的食品的标签和价格。</p><p> For the purposes of our testing, we’ll be deploying this schema with proper indexing on a PostgreSQL 12.6 database with the following number of records in each table:</p><p> 出于我们的测试的目的，我们将在PostgreSQL 12.6数据库上部署此架构，其中包含每个表中的以下记录数： </p><p>  All of the orders and markouts are randomly distributed amongst the customers and employees, respectively. Employees and customers are also randomly distributed across stores.</p><p>所有订单和Markout都分别在客户和员工之间随机分发。员工和客户也随机分发跨门。</p><p>  In order to audit inventory, the logistics team at the corporate headquarters requests a tool that can generate a report containing all  meal_items that left a given store’s inventory on a particular day. This requires a query that includes items that were both sold to customers as well as recorded as employee markouts for the specified store on the specified day.</p><p>  为了审计清单，公司总部的物流团队要求一个工具，可以生成包含所有在特定一天留下特定商店库存的所有膳食的报告。这需要一个查询，其中包括销售给客户的项目，并在指定的日期录制为指定商店的员工Markouts。</p><p> To break this request down into more manageable segments, we’ll first retrieve all of the meal items that are a part of an employee markout created on the given day at the given store. Once we have this, we’ll expand it to include meal items that have been purchased by customers.</p><p> 要将此请求缩小到更可管理的段中，我们将首先检索在给定商店的给定日期创建的员工Markout的一部分的所有膳食项目。一旦我们有这个，我们将扩展它以包括客户购买的膳食物品。</p><p> The query that retrieves only employee markout data starts at the  stores table and joins the employee tables down to the  meal_items table. This is a fairly straightforward query, and since the columns are indexed, we expect it to perform well.</p><p> 只检索员工Markout数据的查询在存储表中开始，并将员工表DEPT到DIME_ITEMS表中。这是一个相当简单的查询，并且由于列被索引，我们希望它表现良好。</p><p>  SELECT meal_items. *, employee_markouts.employee_id   FROM stores   INNER  JOIN employees   ON stores. id  = employees.store_id   INNER  JOIN employee_markouts   ON employees. id  = employee_markouts.employee_id   INNER  JOIN meal_items   ON employee_markouts.meal_item_id  = meal_items. id   WHERE stores. id  =  250   AND employee_markouts.created  &gt;=  &#39;2021-02-03&#39;   AND employee_markouts.created  &lt;  &#39;2021-02-04&#39;;</p><p>  选择Enal_Items。 *，employee_markouts.employee_id来自Stores上的存储内部员工。 id = employees.store_id Inner加入员工上的Employee_markouts。 ID = employee_markouts.employEe_ID Inner Join_Items在employee_markouts.meal_item_id = dinal_items上。 id商店的id。 id = 250和employee_markouts.created＆gt; =＆＃39; 2021-02-03＆＃39;和employee_markouts.created＆lt; ＆＃39; 2021-02-04＆＃39 ;;</p><p>    This query gives us the data we’re looking for and runs in a blazing fast 1.499 milliseconds—the excellent performance we expected. The problem is that we’re not done yet, we also need to retrieve the meal items that are a part of customer orders. In order to do this, we’ll modify the above query in the following ways:</p><p>    此查询为我们提供了我们正在寻找的数据，并以炽热的快速运行1.499毫秒 - 我们预期的出色表现。问题是我们还没有完成，我们还需要检索一部分客户订单的膳食物品。为此，我们将以以下方式修改上述查询：</p><p> We’ll include a second branch of joins from  stores to  meal_items through the customers tables, updating the final join into the  meal_items table to use an  OR to merge both branches.</p><p> 我们将通过客户表中包含从商店到Ende_Items的第二个分支，将最终的连接更新到Ente_Items表中以使用或合并两个分支。 </p><p> Since we’re looking for meal items that are a part of either employee markouts or customer orders, we’ll convert all of our joins to be  LEFT joins and add a condition in our customers branch to ignore employee markouts.</p><p>由于我们正在寻找员工Markouts或客户订单的一部分的餐品，我们将把我们的所有加入都转换为左转，并在客户分支机构中添加一个条件，以忽略员工的Markouts。</p><p> We’ll also change the columns we’re selecting to include either one of the  employee_id or the  customer_id that the meal item belongs to.</p><p> 我们还将更改我们选择的列以包含员工属于employee_id或customer_id中的一个。</p><p>   SELECT   meal_items. *,   employee_markouts.employee_id,   customer_orders.customer_id   FROM stores   -- employees branch   LEFT  JOIN employees   ON stores. id  = employees.store_id   LEFT  JOIN employee_markouts   ON employees. id  = employee_markouts.employee_id   -- customers branch   LEFT  JOIN customers   ON (stores. id  = customers.store_id  AND employee_markouts. id  IS  null)   LEFT  JOIN customer_orders   ON customers. id  = customer_orders.customer_id   LEFT  JOIN customer_order_items   ON customer_orders. id  = customer_order_items.customer_order_id   -- join both branches into meal_items   LEFT  JOIN meal_items   ON (customer_order_items.meal_item_id  = meal_items. id    OR employee_markouts.meal_item_id  = meal_items. id   )   WHERE stores. id  =  250   AND meal_items. id  IS  NOT  null   AND ( employee_markouts.created  &gt;=  &#39;2021-02-03&#39;  AND employee_markouts.created  &lt;  &#39;2021-02-04&#39;    OR customer_orders.created  &gt;=  &#39;2021-02-03&#39;  AND customer_orders.created  &lt;  &#39;2021-02-04&#39;   )   GROUP  BY meal_items. id, employee_markouts. id, customer_orders. id, customer_order_items. id;</p><p>   选择Enal_Items。 *，employee_markouts.employee_id，customer_orders.Customer_ID来自Stores  - 员工分支左派加入商店的员工。 id = employees.store_id left加入员工的employee_markouts。 id = employee_markouts.employee_id  - 客户分支左加入客户（存储。id = customers.store_id和employee_markouts。id为null）level and customer_orders。 id = customer_orders.customer_id left加入customer_orders上的customer_order_items。 id = customer_order_items.customer_order_id  - 将分支加入DIME_ITEMS leap join_items上（customer_order_items.meal_item_Item_Ind_items。ID或employee_markouts.meal_item_id = dinal_items。ID）在哪里存储。 ID = 250和End_Items。 ID不是null和（employee_markouts.created＆gt; =＆＃39; 2021-02-03＆＃39;和employee_markouts.created＆＃39;或customer_orders.created＆gt; =＆ ＃39; 2021-02-03＆＃39;和customer_orders.created＆＃39; 2021-02-04＆＃39;）＆＃39;）小组由dinal_items组。 ID，Employee_markouts。 ID，Customer_orders。 ID，Customer_Order_Items。 ID;</p><p>    Of the 45 results, 43 represent meal items purchased by customers, and we continue to see the two meal items from the previous query that come from employee markouts. Unfortunately, the performance of this multi-branch query is far worse than before. The sub-2-millisecond query from before has ballooned into a sluggish 3,264 milliseconds.</p><p>    在45个结果中，43个代表客户购买的膳食物品，我们继续看到来自员工Markouts的上一个查询的两餐。不幸的是，这个多分支查询的性能远远差。从之前的Sub-2-millisecond查询崩溃成一个缓慢的3,264毫秒。</p><p> This performance may be acceptable for a one-off query, but for any other use case, this execution time of more than three seconds is very poor given the relatively small amount of data in our database. Our database has roughly only 750,000 rows. If we were dealing with row counts in the tens or hundreds of millions, the performance of our report would likely be in the tens of seconds. This is an unacceptable amount of time to make our end users wait, especially if they need to run multiple reports, so we need to find a way to achieve better performance.</p><p> 对于一次性查询来说，这种性能可能是可以接受的，但对于任何其他用例，在我们的数据库中的数据量相对较少的数据，这是一个以上的执行时间非常差。我们的数据库大概只有75万行。如果我们正在处理数十或数亿岁的行计数，我们的报告表现可能在几十秒内。这是使我们的最终用户等待的不可接受的一段时间，特别是如果他们需要运行多个报告，那么我们需要找到实现更好性能的方法。</p><p>  After running each of our two queries, it’s apparent that attempting to retrieve meal item counts for both employees and customers in a single query in the way that we wrote query #2 resulted in a significant degradation in performance. Even without being familiar with the specifics of the query plan (which we can see by re-running the query prefixed with  EXPLAIN or  EXPLAIN ANALYZE), we can try to stick to using simpler queries that we think will have better performance, and see whether there’s a better way to compose the results.</p><p>  在运行我们的两个查询之后，显而易见的是，尝试在单个查询中检索员工和客户的膳食项目，以便我们编写查询＃2导致性能显着下降。即使在不熟悉查询计划的细节（通过重新运行查询以解释或解释分析），我们可以尝试使用我们认为具有更好性能的更简单的查询，并查看是否有一种更好的方法来构成结果。</p><p> Query #1 retrieved meal items only a part of employee markouts and it performed extremely well. Let’s try writing the query to retrieve only the meal items that are a part of customer orders and examine its performance. Like the query for employee data, this query will join the tables between the  stores and  meal_items tables, but instead do so through the customer tables. There’s three customer-specific tables rather than two employee-specific tables, but otherwise this query is very similar to the first:</p><p> 查询＃1只检索员工Markouts的一部分员工市场，它表现得非常良好。让我们尝试编写查询只能检索一部分客户订单的餐项目并检查其性能。与员工数据的查询一样，此查询将加入商店和End_Items表之间的表，而是通过客户表来执行此操作。有三个客户特定的表而不是两个特定于员工的表，否则此查询与第一个类似： </p><p>  SELECT meal_items. *, customer_orders.customer_id   FROM stores   INNER  JOIN customers   ON stores. id  = customers.store_id   INNER  JOIN customer_orders   ON customers. id  = customer_orders.customer_id   INNER  JOIN customer_order_items   ON customer_orders. id  = customer_order_items.customer_order_id   INNER  JOIN meal_items   ON customer_order_items.meal_item_id  = meal_items. id   WHERE stores. id  =  250   AND customer_orders.created  &gt;=  &#39;2021-02-03&#39;   AND customer_orders.created  &lt;  &#39;2021-02-04&#39;;</p><p>选择Enal_Items。 *，customer_orders.customer_id来自商店内部的商店上的客户。 ID = Customers.Store_ID Inner Jourse Customer_orders在客户身上。 id = customer_orders.customer_id Inner加入Customer_Order_Items上的Customer_orders。 id = customer_order_items.customer_order_id Inner Join_Items在customer_order_items.meal_item_id = dinam_items。 id商店的id。 id = 250和customer_orders.created＆gt; =＆＃39; 2021-02-03＆＃39;和customer_orders.created＆lt; ＆＃39; 2021-02-04＆＃39 ;;</p><p>    We get exactly the results we expect. Looking at the performance, we see that this query runs in only 102 milliseconds. This is slower than query #1 because we have significantly more customers than employees in our database, but still far faster than the 3264 milliseconds query #2 took to run.</p><p>    我们完全得到了我们预期的结果。查看性能，我们看到此查询仅在102毫秒内运行。这比查询＃1慢，因为我们的数据库中的员工有更多的客户，但仍然比3264毫秒Query＃2更快地运行。</p><p> Now we are in a situation where we retrieve the correct results, albeit split across two queries. Despite this, the runtime of both query #1 (only employee meal items) and query #3 (only customer meal items) put together is more than  30 times faster than query #2 (both employee and customer meal items through multi-branch joins). All we need to do is merge the results of these queries. The good news is that SQL has an operation that will let us do this while preserving this speed.</p><p> 现在我们处于检索正确结果的情况，尽管跨越两个查询。尽管如此，查询＃1（仅员工膳食物品）和查询＃3（仅客户膳食项目）的运行时间比查询＃2（员工和客户膳食项目通过多分支加入速度快30倍以上）。我们需要做的就是合并这些查询的结果。好消息是，SQL有一个操作，让我们在保留此速度时执行此操作。</p><p>  The  UNION operation allows us to merge the results of two queries. Since we know that query #1 and query #3 are each significantly faster than query #2, we would expect that the results of the  UNION operation will be fast as well.</p><p>  UNION操作允许我们合并两个查询的结果。既然我们知道查询＃1和查询＃3都比查询＃2的速度明显快，我们希望联盟操作的结果也快。</p><p> We use both query #1 and query #3 nearly verbatim in what will be our new combined query. Since the  UNION operation requires that the results of each query contain the same columns, we have to include a  NULL placeholder column for whichever type of data (either  employee_id or  customer_id) the given side of the  UNION will not retrieve.</p><p> 我们几乎逐字使用查询＃1和查询＃3在我们的新组合查询将是什么。由于Union操作要求每个查询的结果包含相同的列，因此我们必须包含一个null占位符列，无论哪个类型的数据（employee_id或customer_id）都不会检索。</p><p> One other thing that the  UNION operation does is deduplicate rows in the result set. Since we don’t care about deduplication, we can use  UNION ALL to tell the database engine that it can skip the deduplication step. This results in a performance boost with larger data sets.</p><p> 联合操作所做的另一件事是结果集中的重复数据删除行。由于我们不关心重复数据删除，我们可以使用联盟所有人告诉数据库引擎它可以跳过重复数据删除步骤。这导致具有较大数据集的性能提升。</p><p>   SELECT  -- employees query   meal_items. *,   employee_markouts.employee_id,    null  as customer_id   FROM stores   INNER  JOIN employees   ON stores. id  = employees.store_id   INNER  JOIN employee_markouts   ON employees. id  = employee_markouts.employee_id   INNER  JOIN meal_items   ON employee_markouts.meal_item_id  = meal_items. id   WHERE stores. id  =  250   AND employee_markouts.created  &gt;=  &#39;2021-02-03&#39;   AND employee_markouts.created  &lt;  &#39;2021-02-04&#39;   UNION  ALL   SELECT  -- customers query   meal_items. *,    null  as employee_id,   customer_orders.customer_id   FROM stores   INNER  JOIN customers   ON stores. id  = customers.store_id   INNER  JOIN customer_orders   ON customers. id  = customer_orders.customer_id   INNER  JOIN customer_order_items   ON customer_orders. id  = customer_order_items.customer_order_id   INNER  JOIN meal_items   ON customer_order_items.meal_item_id  = meal_items. id   WHERE stores. id  =  250   AND customer_orders.created  &gt;=  &#39;2021-02-03&#39;   AND customer_orders.created  &lt;  &#39;2021-02-04&#39;;</p><p>   选择 - 员工查询End_Items。 *，employee_markouts.employee_id，null as customer_id从商店内部加入员工在商店上。 id = employees.store_id Inner加入员工上的Employee_markouts。 ID = employee_markouts.employEe_ID Inner Join_Items在employee_markouts.meal_item_id = dinal_items上。 id商店的id。 id = 250和employee_markouts.created＆gt; =＆＃39; 2021-02-03＆＃39;和employee_markouts.created＆lt; ＆＃39; 2021-02-04＆＃39; Union所有选择 - 客户查询End_Items。 *，null作为employee_id，customer_orders.customer_id来自Stores Inner Joind Customers上的商店。 ID = Customers.Store_ID Inner Jourse Customer_orders在客户身上。 id = customer_orders.customer_id Inner加入Customer_Order_Items上的Customer_orders。 id = customer_order_items.customer_order_id Inner Join_Items在customer_order_items.meal_item_id = dinam_items。 id商店的id。 id = 250和customer_orders.created＆gt; =＆＃39; 2021-02-03＆＃39;和customer_orders.created＆lt; ＆＃39; 2021-02-04＆＃39 ;; </p><p> Given what we’ve seen above, we expect 45 results from this query. Two for employees, and 43 for customers. Running the query gives the following results:</p><p>鉴于我们在上面看到的内容，我们预期45个结果是由此查询的结果。两人为员工，43为客户。运行查询给出以下结果：</p><p>   We get exactly the same results we expect, in a blazing fast 112 milliseconds. This is now a single query that gives us the same results that query #2 gave us, but does so approximately 30 times faster. Using  UNION here costs us virtually nothing in terms of performance. The time is essentially just the sum of the two underlying queries.</p><p>   我们完全相同的结果，我们期望的结果，在炽热的快速112毫秒。这是一个单一的查询，为我们提供了查询＃2给我们的同样的结果，但这样做的速度大约是约30倍。在这里使用联盟在表现方面几乎没有任何内容。时间基本上只是两个底层查询的总和。</p><p> It’s worth noting that the results of the above query are ordered differently than our original query, which is ordered by the  id column. This is because the  UNION operation appends rows in the order that it runs each underlying query (which is also why we get the employee meal items first). If we need the order to match, we can achieve this by wrapping query #4 in a very simple  SELECT operation that orders the results by  id:</p><p> 值得注意的是，上述查询的结果与我们的原始查询不同，它由ID列订购。这是因为联盟操作按照它运行每个底层查询的顺序附加行（这也是我们首先获得员工膳食项目的原因）。如果我们需要命令匹配，我们可以通过在一个非常简单的选择操作中包装查询＃4来实现这一目标，这些操作按ID命令结果：</p><p> Query #5 - Retrieving both employee and customer meal items using  UNION, ordered by  id</p><p> 查询＃5  - 使用ID命令使用Union检索员工和客户膳食物品</p><p> SELECT  *  FROM (    -- ... Query #4 from above, omitted for brevity  ) results  ORDER  BY  id;</p><p> 从上面的（ -  ...查询＃4中，为简洁起见）exceed *</p><p>    Query #5 gives us exactly the same results in the same order as query #2, but with a 2,880% increase in performance. This is an outstanding improvement, and is now performant enough as to where query #5 can be used in any application.</p><p>    查询＃5以与查询＃2相同的顺序给我们完全相同的结果，但性能增加了2,880％。这是一个突出的改进，现在表现足够的查询＃5可以在任何应用程序中使用。</p><p>  There are many ways to write a SQL query to retrieve a given set of results. Most database engines are great at creating performant query plans, but certain features within a query can derail the query planner and result in a very slow query. In this post, we covered a common scenario that results in poor query performance: using  OR to combine multiple branches of joins in a single query.</p><p>  有很多方法可以编写SQL查询来检索给定的一组结果。大多数数据库引擎都非常适合创建表演查询计划，但查询中的某些功能可以忽略查询策划器并导致非常慢的查询。在此帖子中，我们介绍了一个常见的场景，导致查询性能差：使用或将多个连接的多个分支组合在一个查询中。 </p><p> Arriving at query #2 to get the combined results was the intuitive way of thinking through the problem, and something that someone with intermediate or advanced SQL skills could come up with. However, once we realized that performance was bad, we applied the following steps to find a solution:</p><p>到达Query＃2以获得综合结果是通过问题的直观思考方式，以及中间或高级SQL技能可能会提出的东西。但是，一旦我们意识到表现不好，我们应用以下步骤找到解决方案：</p><p> We focused on writing only simpler and well-performing queries that each gave different portions of our desired results.</p><p> 我们专注于编写更简单和良好的疑问，每个查询都给了我们所需结果的不同部分。</p><p> This technique can be applied in many situations where query performance is poor due to this type of diamond-shaped branching and merging. When working on production software systems, we often see performance bottlenecks caused by slow queries removed when rewriting queries in this manner. In many cases, the performance improvement is so dramatic that it absolves the need to cache query results in systems like Redis, resulting in less system complexity in addition to better performance.</p><p> 这种技术可以应用于许多情况，其中由于这种类型的菱形分支和合并，查询性能较差。在生产软件系统上时，我们经常看到在以这种方式重写查询时删除的缓慢查询引起的性能瓶颈。在许多情况下，性能改进是如此戏剧性地，它绝对需要缓存查询导致REDIS的系统，导致除了更好的性能之外的系统复杂性较少。</p><p> SQL’s  UNION operation is not usually thought of as a means to boost performance. However, in many cases it can dramatically speed queries up by enabling an otherwise complex query to be split into several faster and simpler queries that are then merged together. Recognizing when  UNION can be applied takes some practice, but once someone is aware of this technique, it’s possible to look for situations where a performance bottleneck can be removed through this approach.</p><p> SQL的Union操作通常不会被认为是提高性能的手段。但是，在许多情况下，它可以通过使否则复杂的查询分成几个更快，更简单的查询，从而大大加速查询，然后将其合并在一起。识别联盟可以应用何时应用一些练习，但是一旦有人知道这种技术，就可以通过这种方法寻找能够去除性能瓶颈的情况。</p><p>  Ben Levy and Christian Charukiewicz are Partners and Principal Software Engineers at Foxhound Systems. At Foxhound Systems, we focus on building fast and reliable custom software. Are you facing a performance issue or looking for help with something you’re working on? Reach out to us at  info@foxhound.systems.</p><p>  Ben Levy和Christian Charukiewicz是Foxhound Systems的合作伙伴和主要软件工程师。在Foxhound Systems，我们专注于建设快速可靠的自定义软件。您是否面临绩效问题或寻求帮助您正在进行的事情？在info@foxhound.systems acto act向我们伸出援手。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.foxhound.systems/blog/sql-performance-with-union/">https://www.foxhound.systems/blog/sql-performance-with-union/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/union/">#union</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sql/">#sql</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/查询/">#查询</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>