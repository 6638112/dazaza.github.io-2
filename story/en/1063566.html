<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>英特尔和AMD考虑了X86中断处理的不同替代品 Intel and AMD Contemplate Different Replacements for x86 Interrupt Handling</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Intel and AMD Contemplate Different Replacements for x86 Interrupt Handling<br/>英特尔和AMD考虑了X86中断处理的不同替代品 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-05 02:55:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/f76d489a0a2a7d0f511ef5816254cbfb.png"><img src="http://img2.diglog.com/img/2021/6/f76d489a0a2a7d0f511ef5816254cbfb.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>At some point, the house of cards begins to topple over. It’s no secret that the x86 processor architecture is almost aged enough to collect a pension. It is, not to put too fine a point on it, a creaking old bit of wheezing ironmongery that, had the gods of microprocessor architecture been more generous, would have been smote into oblivion long ago.</p><p>在某些时候，卡的房子开始倒下。 X86处理器架构几乎足够老化，无法秘密收集养老金。这是，不要太精细的一点，一个吱吱作响的喘息的熨斗，让微处理器建筑的神越来越慷慨，很久以前就会被吹入遗忘。</p><p> Intel and AMD have done an amazing job keeping the old girl running for all these decades, but the strain is beginning to tell. Programming x86 chips is hard and it’s frustrating, because new features keep piling on while the old ones never go away. It’s like operating a rocket ship using tiller, sails, and hawser. It’s a miracle it works at all.</p><p> 英特尔和AMD做了一个惊人的工作，让老女孩在这几十年里奔跑，但是这种紧张开始讲述。编程x86芯片很难，这是令人沮丧的，因为新功能在旧的功能永远不会消失时保持打击。这就像使用耕地，帆和豪塞尔经营火箭船一样。这是一个奇迹，它完全适用。</p><p> So, it’s no surprise that Intel and AMD – to say nothing of the thousands of x86 programmers around the world – might be eager to cast off some of that grating machinery and replace it with something less… quaint.</p><p> 所以，英特尔和AMD毫不奇怪 - 在世界各地的数千名X86程序员中毫不犹豫地说 - 可能会渴望抛弃一些光栅机械，并用更少的东西更换它......古雅。</p><p> Case in point: interrupt handling. Ever since the days of the ’286 (circa MCMLXXXII) the world’s x86 processors have all used a Byzantine system to manage interrupts, faults, and exceptions that combined lookup tables, privilege checks, bounds juggling, context preservation, and memory management that confounded many a programmer – and yet somehow worked. Most of the time.</p><p> 案例在点：中断处理。自从'286（CIRCA MCMLXXXII）的日子以来，世界X86处理器都使用了拜占庭系统来管理组合查找表，特权检查，界限，上下文保存和内存管理的中断，故障和例外，以便混淆许多程序员 - 但以某种方式工作。大多数时候。</p><p> Not surprisingly, there were some bugs in the interrupt descriptor table (IDT) system, and they tended to be fiendishly subtle. Race conditions, lockups, infinite loops, and privilege violations were generally rare but unavoidable. Not every operating system has the Blue Screen of Death, but they’ll have something similar. OS programmers have spent a lot of time sussing out and patching the arcane and abstruse details of x86 interrupt handling.</p><p> 毫不奇怪，中断描述符表（IDT）系统中存在一些错误，他们往往是微妙的微妙。种族条件，锁定，无限循环和特权违规通常是罕见的，但不可避免的。不是每个操作系统都有蓝屏死亡，但他们会有类似的东西。操作系统程序员已经花了很多时间阐明和修补arthane和x86中断处理的奥秘细节。</p><p> Time for a reboot? Maybe. Intel and AMD have independently come up with schemes to simplify the way x86 processors handle faults, traps, and interrupts. Naturally, the two approaches are different and incompatible with each other. Intel’s is more ambitious, but it also represents more work for programmers hoping to take advantage of the new mechanism. AMD’s approach is simpler; it’s more of a patch than an overhaul.</p><p> 重新启动的时间？也许。 Intel和AMD独立地提出了方案，以简化X86处理器处理故障，陷阱和中断的方式。当然，这两种方法彼此不同，不相容。英特尔更雄心勃勃，但它还代表了更多的工作人员希望利用新机制。 AMD的方法更简单;它更像是一种修补程序而不是大修。</p><p>  For the first time in a long time, Intel actually wants to jettison, not just tweak, one of its major features. The   proposed FRED (Flexible Return and Event Delivery) system  would entirely replace the IDT, along with its interrupt descriptors. It also effectively reduces the number of privilege levels from four to just two. Finally, call gates become a thing of the past. In return (so to speak), interrupt handling would be faster, simpler, more complete, and less prone to corner-case bugs. For many of us, it will be the first rework of x86 interrupt handling in our lifetimes.</p><p>  在很长一段时间内，英特尔实际上想要抛弃，而不仅仅是调整它的主要功能之一。建议的FRED（灵活返回和事件交付）系统将完全替换IDT，以及其中断描述符。它还有效地减少了从四到两个的特权级别的数量。最后，呼叫门成为过去的事情。作为回报（所以说话），中断处理将更快，更简单，更完整，更容易发生角色案例错误。对于我们许多人来说，它将是我们生命中的第一个返工X86中断处理。 </p><p> FRED will be optional, so the nostalgic can still use the current IDT approach, with or without call gates. You’ll be able to switch FRED on and off at boot time, so older and newer operating systems can coexist on the same silicon. With FRED enabled, the processor completely ignores and bypasses the IDT. Or, more accurately, you won’t have to create an IDT or interrupt descriptors to begin with.</p><p>FRED将是可选的，因此怀旧仍然可以使用当前的IDT方法，有或没有呼叫门。您将能够在启动时切换Fred和Off，所以更旧的操作系统可以在同一芯片上共存。使用FRED启用，处理器完全忽略并绕过IDT。或者更准确地，您不必创建一个idt或中断描述符以开始。</p><p> Interrupts, traps, and exceptions are collectively called “events,” and routing those events to their appropriate handler becomes “event delivery.” All event handlers (that is, interrupt handlers, fault handlers, exception handlers, etc.) run at privilege level 0, the most privileged and innermost of the four privilege “rings.” Rather than use the IDT to locate the entry point of each handler, processor hardware will simply calculate an offset from a fixed base address. It’s less flexible than the IDT system, but it’s simpler to set up and quicker for the hardware to implement.</p><p> 中断，陷阱和例外集体称为“事件”，并将这些事件路由到其适当的处理程序成为“事件传递”。所有事件处理程序（即中断处理程序，故障处理程序，异常处理程序等）在特权级别0中运行，是四个特权的最特权和最内最内心的“环”。而不是使用IDT来定位每个处理程序的入口点，因此处理器硬件将简单地计算来自固定基地址的偏移量。它不如IDT系统的灵活性，但它更简单地设置和更快地实现硬件实现。</p><p>  Each handler will automatically have not one, but two, entry points exactly 64 bytes apart. The first (lowest offset address) is for when the handler was called from unprivileged code. The other is for when the handler was called from a privileged CPL0 code. The split allows you to write two exit routines, depending on whether you’re returning to privileged or unprivileged code. Simple, but effective.</p><p>  每个处理程序都将自动没有，但两个，入口点恰好接触到64字节。第一个（最低偏移地址）是用于从非特权代码调用处理程序时的。另一个是从特权CPL0代码调用处理程序时。拆分允许您编写两个退出例程，具体取决于您是否返回特权或非特权代码。简单，但有效。</p><p> Why only two privilege levels? FRED collapses the x86 family’s four privilege rings into just two: user and supervisor. That’s a big step back from when the four-level scheme was introduced in the 1980s, but the intervening decades have shown that few programmers ever used all four levels. Most just separated privileged from nonprivileged, so Intel took the opportunity with FRED to sanctify what everyone was doing anyway.</p><p> 为什么只有两个特权水平？ FRED将X86家族的四个特权折叠倒入两个：用户和主管。这是从20世纪80年代推出的四级方案何时引入的一大步，但干预数十年表明，很少有程序员使用了所有四个层面。大多数刚刚从非普剧中分开的特权，所以英特尔趁机弗雷德来确定每个人都在做的事情。</p><p> The user/supervisor distinction is important because it determines whether you change stacks or not. This was always a weak point of x86 interrupt handling, and it got even weirder with 64-bit extensions and operating systems. The processor nominally maintained four separate stacks (one for each privilege level), plus a possible “shadow stack” for the operating system or hypervisor. It got tricky to know which stack to use, which to preserve, and which to never, ever touch.</p><p> 用户/主管区别很重要，因为它决定了你是否改变堆栈。这始终是X86中断处理的弱点，它甚至具有64位扩展和操作系统的奇迹。处理器名义上维护了四个单独的堆栈（每个特权级别一个），以及用于操作系统或管理程序的可能的“阴影堆栈”。它很棘手要知道要使用的堆栈，它要保存，它永远不会触摸。</p><p> By convention, 64-bit operating systems also used the GS segment register to maintain thread integrity, but this wasn’t managed by the hardware. Interrupt handlers had to juggle GS selectors and memory segments, hoping to preserve the incoming context, and there are no atomic operations to do this.</p><p> 按照惯例，64位操作系统还使用GS段寄存器来维护线程完整性，但这不是由硬件管理的。中断处理程序必须跳动GS选择器和内存段，希望保留传入的上下文，并且没有原子操作来执行此操作。</p><p> FRED will do all of that automatically. It pushes 40 bytes onto the privileged stack of the event handler, along with another 64 bytes of event information (essentially a mini-core dump) elsewhere. By the time it’s called, the event handler should have all the context it needs to get directly to work.</p><p> Fred将自动完成所有这些。它将40个字节推到事件处理程序的特权堆栈上，以及其他64个字节的事件信息（基本上是一个迷你核心转储）。当它调用时，事件处理程序应该具有它需要直接工作的所有上下文。 </p><p> Intel’s documentation says, “The principal functionality of FRED event delivery is to establish a new context, that of the event handler in ring 0, while saving the old context for a subsequent return. Some parts of the new context have fixed values, while others depend on the old context, the nature of the event being delivered, and software configuration.”</p><p>英特尔的文档说：“FRED事件传递的主要功能是建立一个新的上下文，导致戒指0中的事件处理程序，同时保存后续返回的旧上下文。新上下文的某些部分具有固定值，而其他部分则依赖于旧的上下文，所传送的事件的性质和软件配置。“</p><p> Returning from the event handler will use two new instructions, ERETU and ERETS (Event Return to User/Supervisor). The user-mode version restores all the nonprivileged context, including stack, instruction pointer, registers, and so on. The supervisor version is simpler and therefore quicker because it’s not crossing privilege-level boundaries.</p><p> 从事件处理程序返回将使用两个新的指令，ERETU和ERET（事件返回用户/主管）。用户模式版本还原所有非普遍上下文，包括堆栈，指令指针，寄存器等。 Supervisor版本更简单，因此更快，因为它不会交叉特权级边界。</p><p> Similarly, the SYSCALL and SYSENTER instructions change behavior. They still enable system-level function calls but no longer vector through the (nonexistent) IDT.</p><p> 同样，SYSCALL和SYSENTER指令改变行为。它们仍然能够启用系统级功能调用，但不再通过（不存在）IDT。</p><p> Another big change is to call gates. Forget ’em. The IDT could be populated with call gates, which both defined the interrupt handler’s entry point and its privilege level. Now, all event handlers have predefined entry points, and they all run at the highest privilege level. Ergo, no need for call gates in the IDT.</p><p> 另一个巨大的变化是打电话给盖茨。忘了他们。可以使用呼叫门填充IDT，这两个都定义了中断处理程序的入口点及其特权级别。现在，所有事件处理程序都有预定义的入口点，它们都以最高权限级别运行。 ERGO，不需要IDT中的呼叫门。</p><p> What about call gates elsewhere, like in the GDT or LDT? Still no. Says Intel, “When FRED transitions are enabled, any execution of far CALL or far JMP that references a call gate causes a general-protection exception (#GP).” In other words, you can still call/jump to code in other segments, but it must be at the same privilege level.</p><p> 在其他地方的电话盖茨怎么样，就像在GDT或LDT？仍然没有。 Intel说：“启用FRED转换时，引用呼叫门的任何执行呼叫或远的JMP会导致普通保护异常（#gp）。”换句话说，您仍然可以在其他段中调用/跳转到代码，但它必须处于相同的权限级别。</p><p>  Call gates used to be a common – and officially accepted – way to elevate privilege, but no more. FRED doesn’t allow privilege changes (“ring crossings”) except through its own mechanism, which means a deliberate interrupt or exception.</p><p>  呼叫盖茨曾经是一个共同和官方接受的方式来提升特权，但不再是。 FRED不允许特权更改（“环线交叉”）除了通过自己的机制，这意味着刻意中断或异常。</p><p> This raises an interesting side effect, which I’m sure was deliberate. If all privilege changes have to go though FRED events, and if FRED recognizes only two privilege levels, there’s no longer any way to reach code at privilege levels 1 or 2. Those two intermediate privilege levels have effectively been banished and rendered unusable. Even if you somehow manage to start out running at CPL1 or CPL2, the very first interrupt or exception will kick you up to a CPL0 event handler, which will then return you to CPL3 when it exits. Yup, I’d say those two extra privilege levels are   processora non grata .</p><p> 这提出了一个有趣的副作用，我肯定是故意的。如果所有权限更改都必须走得更好，并且如果FRED仅识别两个权限级别，则不再达到特权级别1或2的任何方法。这两个中间权限级别有效地解除了并呈现了不可用的。即使您以某种方式进出CPL1或CPL2，即使是第一个中断或异常也会踢到CPL0事件处理程序，然后将您返回到CPL3退出时。 Yup，我会说这两个额外的特权级别是ProcessOra非Grata。 </p><p>  In contrast to Intel’s interrupt overhaul, AMD’s approach is just a light spit and polish. The company’s proposed   Supervisor Entry Extensions (SEE)  retain the familiar IDT, call gates, and four privilege rings. It tweaks the existing SYSCALL instruction, adds a status bit to mark interrupt handlers as reentrant, and makes nonmaskable interrupts maskable(!).</p><p>与英特尔的中断大修相比，AMD的方法只是轻微的唾液和抛光。该公司的拟议主管入境扩展（见）保留熟悉的IDT，呼叫门和四个特权环。它调整了现有的SYSCALL指令，将状态位添加到将中断处理程序标记为重圈，并使不可掩除中断可屏蔽（！）。</p><p> SEE seeks merely to patch up some of the loopholes that have been uncovered by years of software development “to properly deal with circumstances that in practice are rare but cannot be ignored.” One is the problem of reentrant fault handlers: they aren’t. It’s all too easy to get a fault or exception, jump to the relevant fault handler (through the IDT) and quickly get a second identical fault before you’ve properly saved enough context from the first one. With just a bit of bad luck, it’s possible to lose context, or to create an infinite loop if you’re in the midst of setting up stack pointers.</p><p> 请参阅Seepely仅修补多年软件开发中未发现的一些漏洞“以正确处理在实践中的情况很少，但不能被忽视。”一个是重圈故障处理程序的问题：它们不是。这太容易获得了故障或异常，跳转到相关的故障处理程序（通过IDT）并在从第一个上保存足够的上下文之前快速获得第二个相同的故障。只需有点运气，可以丢失上下文，或者如果您在设置堆栈指针的中间，则可以创建无限循环。</p><p> SEE fixes this by allocating a bit in each interrupt descriptor to say, “this handler is not reentrant.” When set, the processor hardware will set another “busy” bit any time this handler is called and it won’t call the handler a second time until it’s cleared. The busy bit gets cleared automatically upon exit from the handler or, if you’re brave, you can clear it earlier in software.</p><p> 通过在每个中断描述符中分配一点来说明，请参阅解决方法，“此处理程序不重新入住。”设置后，随时调用此处理程序，处理器硬件将设置另一个“忙”位，并且它不会将处理器第二次调用，直到它清除。退出处理程序后，忙碌的位会自动清除，或者如果您是勇敢的话，您可以在软件中提前清除它。</p><p> This also works for nonmaskable interrupts (NMI), which seems recklessly dangerous, not to mention oxymoronic. If the NMI handler is active, the processor will postpone, but not ignore, further NMI interrupts until such time as the handler is prepared to, well, handle them.</p><p> 这也适用于不可掩除的中断（NMI），这似乎令人难以肆无忌惮地危险，更不用说奥克朗。如果NMI处理程序处于活动状态，则处理器将推迟，但不会忽略，进一步的NMI中断，直到处理程序准备好，处理它们。</p><p>  Both proposals are brand new, and both went relatively unnoticed until a certain   Linus Torvalds weighed in  with a characteristically colorful opinion. His view? They’re both good ideas. Why not implement them both? Although Intel and AMD took completely separate approaches, the two are not mutually exclusive. In the worst case, you could imagine implementing them both and then enabling one or the other (or neither) at boot time. What’s one more configuration option?</p><p>  这两个建议都是全新的，两者都相对没有被忽视，直到某种Linus Torvalds以特征性地称重的意见。他的观点？他们都是好的想法。为什么不实现它们？虽然英特尔和AMD采取了完全分开的方法，但这两者不互相排斥。在最坏的情况下，您可以想象实现它们，然后在启动时启用一个或另一个（或两者）。什么是一个配置选项？</p><p> It’s not often that we see a major change to the x86 processor family. Maybe it’s long overdue. But changing the wings on a jetliner in midflight (to borrow an old analogy) is tricky business. The x86 family has survived in large part due to its backward compatibility. Both companies realize this; these proposals are   options , not mandatory replacements. And they should affect only OS kernel code, not applications or drivers, so they’ll be invisible to almost everyone. It’s possible that we’ll never see either one. Or we might look forward to ever-so-slightly less buggy interrupt handling.</p><p> 我们不经常看到X86处理器家庭的重大变化。也许它姗姗来迟。但是在云灯中改变翅膀上的翅膀（借用旧的类比）是棘手的业务。由于其向后兼容性，X86家族在很大程度上幸存下来。两家公司都意识到这一点;这些提案是选项，而不是强制替代品。他们应该只影响OS内核代码，而不是应用程序或驱动程序，所以他们几乎所有人都会看不见。我们可能会看到任何一个。或者我们可能期待略低于略低的越野中断处理。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.eejournal.com/article/we-interrupt-this-program/">https://www.eejournal.com/article/we-interrupt-this-program/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/英特尔/">#英特尔</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/amd/">#amd</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/特权/">#特权</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>