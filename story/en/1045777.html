<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Cgit，Nginx和Gitolite：个人Git服务器 Cgit, Nginx and Gitolite: A Personal Git Server</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Cgit, Nginx and Gitolite: A Personal Git Server<br/>Cgit，Nginx和Gitolite：个人Git服务器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-22 20:09:41</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/b6017e37f569e78ce8b9ae4d00abdb5e.png"><img src="http://img2.diglog.com/img/2021/1/b6017e37f569e78ce8b9ae4d00abdb5e.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I&#39;ve been on a  &#34;own my online presence&#34; kick for more than a year now. So for this (overly protracted) essay, I thought I&#39;d publish my notes on how I created my own Git server.</p><p>我已经拥有我的在线形象＆＃34;现在踢了一年多。因此，对于这篇（过于冗长的）文章，我认为我会发布有关如何创建自己的Git服务器的注释。</p><p> There are many open source projects like  GitTea or  GitLab to make hosting your own git projects effortless; however I wanted a much more simple (read: old school) setup. I ended up with something that uses many of the same projects that the  Linux Organization uses to publish the  Linux Kernel</p><p> 有许多开源项目，例如GitTea或GitLab，可以轻松托管自己的git项目。但是我想要一个更简单的（阅读：旧学校）设置。最后，我使用了Linux组织用于发布Linux内核的许多相同项目。</p><p> The server (as of this writing) uses  Ubuntu&#39;s 20.04.1 LTS (Focal Fossa) running on  Digital Ocean&#39;s hardware ( referral-link). I wholeheartedly support and recommend you chose a different setup. Diversity in people and in tech stack is always and will always be a great thing.</p><p> 该服务器（在撰写本文时）使用了在Digital Ocean的硬件（参照链接）上运行的Ubuntu 20.04.1 LTS（Focal Fossa）。我全力支持，建议您选择其他设置。人们和技术堆栈中的多样性永远都是一件好事。</p><p>  The Start prepares a newly minted server for git hosting duties. Creating a new admin user, locking down the OpenSSH daemon, and installing fail2ban.</p><p>  开始为git托管任务准备了一个新创建的服务器。创建一个新的管理员用户，锁定OpenSSH守护程序，并安装fail2ban。</p><p> Gitolite installs and configures the server to allow us (and colleagues) to have more fine-grained control over who has access to  git push|fetch on the server.</p><p> Gitolite安装并配置了服务器，以使我们（和同事）可以更精细地控制谁可以访问服务器上的git push | fetch。</p><p>  I often find security  &#34;best practices&#34; are a lot like driving down the highway. Some people speeding past you are  &#34;obviously&#34; just moments away from a major data breach, while the others you&#39;re passing are  &#34;clearly&#34; so worried about the entire data-center burning down, they couldn&#39;t possibly get anything else done. Everyone thinks everyone else has lost their marbles.</p><p>  我经常会发现安全性＆最佳做法＆＃34;很像在高速公路上开车。有些人超速驶过你，显然是＆＃34;距重大数据泄露事件仅片刻之遥，而您正在传递的其他数据则很明显地＆＃34;如此担心整个数据中心的烧毁，他们不可能做其他任何事情。每个人都认为其他人都丢了大理石。</p><p> So with that in mind, here are a few steps I took to secure my newly minted server. Please feel free to use only the  &#34;best practices&#34; you deem appropriate for your mission.</p><p> 因此，考虑到这一点，我采取了一些措施来保护新创建的服务器。请随时仅使用＆＃34;最佳做法＆＃34;您认为适合您的任务。 </p><p>  For whatever reason, be it for security or protecting the server from my stupidity, one of the first things I do when creating a new server is add a new user for my general admin tasks.</p><p>无论出于何种原因，无论是出于安全考虑还是为了保护服务器免受愚蠢之苦，创建新服务器时要做的第一件事就是为常规管理任务添加新用户。</p><p>   You&#39;ll be prompted to answer a few questions, including creating a new UNIX password. This will be the password you&#39;ll need to  sudo -i and gain  root permissions, so make it a good one, or use tools like  Pass, or  BitWarden to help you remember.</p><p>   系统将提示您回答一些问题，包括创建新的UNIX密码。这将是您需要sudo -i并获得root权限的密码，因此使其成为一个很好的密码，或者使用Pass或BitWarden之类的工具来帮助您记住。</p><p>   I&#39;ve also largely eliminated all password based authentication when signing into servers, relying on open source smart cards like  NitroKey for authentication. If interested, this requires we setup  .ssh/authorized_keys for our  limb user:</p><p>   在登录服务器时，我还很大程度上消除了所有基于密码的身份验证，而依赖于NitroKey等开源智能卡进行身份验证。如果有兴趣，这要求我们为肢体用户设置.ssh / authorized_keys：</p><p>   Next, set the  .ssh directory&#39;s file permissions so the  ssh daemon can read the files:</p><p>   接下来，设置.ssh目录的文件许可权，以便ssh守护程序可以读取文件：</p><p>   If everything worked, after you restart the  ssh daemon ( service sshd restart) you will now be able to login as the administrator user:</p><p>   如果一切正常，则在重新启动ssh守护程序（service sshd restart）之后，您现在可以以管理员用户身份登录：</p><p> Git and Gitolite ( installed in the next sections) will need us to keep port 22 open, allowing us to  git push from anywhere on the internet. This open port will eventually attract  &#34;a lot&#34; of attention from bots who endlessly scour the internet looking for vulnerable servers, mindlessly stuffing passwords, hoping one password will eventually let them in.</p><p> Git和Gitolite（将在下一部分中安装）将需要我们保持端口22开放，从而允许我们从Internet上的任何位置进行git push。这个开放的港口最终会吸引很多人。僵尸程序的关注，他们无休止地搜寻互联网以寻找易受攻击的服务器，漫不经心地塞满密码，希望一个密码最终可以让它们进入。</p><p> We can eliminate all worry about weak or compromised passwords by disabling all password based authentication, relying solely on  asymmetric cryptography, or  &#34;ssh keys&#34;. Just use your favorite text editor to open  /etc/ssh/sshd_config and ensure these lines exist somewhere in it:</p><p> 通过禁用所有基于密码的身份验证，完全依靠非对称密码或＆＃34; ssh密钥＆＃34 ;，我们可以消除所有有关密码弱或被泄露的担忧。只需使用您喜欢的文本编辑器打开/ etc / ssh / sshd_config并确保这些行存在于其中： </p><p>   While we&#39;re here, a large majority  [1] of these bots are interested in logging in as the  root user. If you created a new admin account in  the previous section and ensured you can login using your public key, you can also disable  root logins entirely with this line in the config:</p><p>当我们在这里时，这些机器人中的绝大多数[1]有兴趣以root用户身份登录。如果您在上一节中创建了一个新的管理员帐户，并确保可以使用公共密钥登录，则还可以使用config中的以下行完全禁用root登录：</p><p>  Some simple  &#34;bash-fu&#34; on my  /var/log/auth.log shows ~93.58% of the roughly 15,000 login attempts since I started this server, tried to login as  root Second place was the user  git (including legitimate logins) at ~1.82%.</p><p>  一些简单的“ bash-fu”在我的/var/log/auth.log上，显示了自启动此服务器以来大约15,000次登录尝试中的〜93.58％，尝试以root用户身份登录第二名是git用户（包括合法登录），为〜1.82％。</p><p> If you uploaded your public key to your VPS provider, most of these changes should have already been configured for you. But in the off chance you had to make some changes, restart the  ssh service to load the new config changes in:</p><p> 如果您将公用密钥上载到VPS提供商，则其中大多数更改应该已经为您配置。但是如果您必须进行一些更改，请重新启动ssh服务以在以下位置加载新的配置更改：</p><p> Depending on your VPS provider, they may also have a firewall system built into their admin panel allowing you to apply rules simply by adding tags to a server. However, I enjoy keeping all my firewall rules inside each box, if only for the same reason I  keep all my socks on the left hand drawer, so everything stays organized and in the same place.</p><p> 根据您的VPS提供商的不同，他们还可能在其管理面板中内置了防火墙系统，使您可以简单地通过向服务器添加标签来应用规则。但是，如果出于同样的原因，我喜欢将所有的袜子规则都保留在左抽屉中，那么我喜欢将所有防火墙规则都保留在每个盒子中，从而使一切保持井井有条，并位于同一位置。</p><p>   Right now, the only thing we have enabled is  ssh which uses port 22. To allow port 22 through  ufw just use the following command:</p><p>   现在，我们启用的唯一功能是使用端口22的ssh。要通过ufw允许端口22，只需使用以下命令：</p><p> Even though we&#39;ve turned off password based authentication  in a previous section, we will still receive a significant amount of bots wasting our compute cycles trying to login. And while the likelihood of this being successful is  zero when rounded to any order of magnitude, the bots will nevertheless continue to pilfer a non-zero amount of CPU if given the opportunity.</p><p> 即使我们已在上一节中关闭了基于密码的身份验证，我们仍然会收到大量的机器人在浪费我们的计算周期来尝试登录。而且，如果四舍五入到任意数量级，成功的可能性为零，但是如果有机会，机器人将继续窃取非零数量的CPU。</p><p> To stop the most brazen of these bots, tools like  Fail2Ban, which creates temporary firewall rules to block IP address who repeatedly fail to authenticate with  ssh, are a great compromise between usefulness and annoyance.</p><p> 为了阻止这些僵尸程序中最肆无忌bra的工具，Fail2Ban之类的工具会在有用性和烦恼之间做出巨大折衷，这些工具会创建临时防火墙规则来阻止反复通过ssh进行身份验证的IP地址。 </p><p>   Once installed, the  ssh &#34;jail&#34; will come pre-enabled for you. If you wish to make any changes, you will need to make a copy of the  fail2ban config file:</p><p>安装后，ssh＆＃34; jail＆＃34;将为您预先启用。如果要进行任何更改，则需要制作fail2ban配置文件的副本：</p><p>   fail2ban does a great job documenting what each option does in the config file. Some of the changes I made are:</p><p>   fail2ban在记录配置文件中每个选项的功能方面做得很好。我所做的一些更改是：</p><p> enabled  bantime.increment to increase the duration of a ban based on how many times the IP address has been banned previously.</p><p> 启用bantime.increment可以根据以前禁止IP地址的次数来增加禁止时间。</p><p> enabled  bantime.rndtime to  &#34;randomize&#34; the length of a ban, preventing bots from knowing exactly when they can resume their assault.</p><p> 启用bantime.rndtime来＆＃34; randomize＆＃34;禁止的时间长度，以防止漫游器确切知道何时可以恢复攻击。</p><p> enabled  bantime.maxtime so I won&#39;t need to unban IP addresses (if you&#39;re unfortunate enough to share an IP with a bot).</p><p> 启用bantime.maxtime，这样我就不需要取消IP地址限制（如果您不幸与机器人共享IP）。</p><p> lowered  bantime,  findtime and  maxretry allowing me to issue small bans that increase in severity as the IP address continues to antagonize.</p><p> 降低了bantime，findtime和maxretry，使我可以发布一些小禁令，这些禁令的严重性随着IP地址的持续对抗而增加。</p><p>     Depending on how  &#34;popular&#34; you are on the internet, you should start to see  NOTICE lines in  /var/log/fail2ban.log of misbehaving bots and the equivalent firewall rules in  ufw.</p><p>     取决于受欢迎程度如果您在互联网上，则应该开始在/var/log/fail2ban.log中看到行为不当的漫游器和ufw中等效的防火墙规则的NOTICE行。 </p><p> $ cat /var/log/fail2ban.log | grep &#39;NOTICE&#39; | tail -1... [125553]: NOTICE [sshd] Ban 156.155.159.161$ ufw statusStatus: activeTo Action From-- ------ ----Anywhere REJECT 156.155.159.16122/tcp ALLOW Anywhere22/tcp (v6) ALLOW Anywhere (v6)</p><p>$ cat /var/log/fail2ban.log | grep＆＃39; NOTICE＆＃39; | tail -1 ... [125553]：注意[sshd]禁止156.155.159.161 $ ufw statusStatus：activeTo操作来自------- ---- Anywhere REJECT 156.155.159.16122 / tcp ALLOW Anywhere22 / tcp（v6 ）任何地方（v6）</p><p> Installing  Gitolite is amazingly simple, there are no binaries to compile or daemons to monitor.</p><p> 安装Gitolite非常简单，无需编译任何二进制文件或监控守护程序。</p><p> At its core, Gitolite is just a collection of  Perl scripts that run after someone signs into the server using the  ssh daemon  we configured in the previous sections. Once installed, Gitolite will give us more fine-grained-control over who has  git push|fetch permissions to each repository. I encourage you to checkout  Gitolite&#39;s amazing documentation if only to see how capable Gitolite can be.</p><p> Gitolite的核心只是Perl脚本的集合，当有人使用我们在上一节中配置的ssh守护程序登录服务器后，它们便会运行。安装后，Gitolite将使我们对谁对每个存储库具有git push | fetch权限具有更细化的控制。如果您只是想了解Gitolite的能力，我鼓励您查阅Gitolite的出色文档。</p><p> Before we install Gitolite, we&#39;ll need to create a new user for everyone to log into and to run Gitolite&#39;s Perl scripts. I typically use the username  git for this, feel free to replace  git with the username that you feel is more appropriate.</p><p> 在安装Gitolite之前，我们需要为每个人创建一个新用户以登录并运行Gitolite的Perl脚本。我通常为此使用用户名git，请随时用您认为更合适的用户名替换git。</p><p>  This creates a new system-user on the server called  git. Because this is not a  &#34;normal&#34; user, there will be no aging information in  /etc/shadow, which is convenient when nobody will be monitoring this account.</p><p>  这将在名为git的服务器上创建一个新的系统用户。因为这不是＆＃34;正常＆＃34;用户，/ etc / shadow中将没有老化信息，这在没有人监视此帐户时很方便。</p><p> We also used the  --home option to set the  $HOME variable to  /var/lib/git. This is where we will eventually put Gitolite&#39;s configuration files and our Git repositories. Feel free to adjust this to where you prefer, I&#39;ve seen many use  /home/git.</p><p> 我们还使用--home选项将$ HOME变量设置为/ var / lib / git。这是我们最终放置Gitolite的配置文件和Git存储库的地方。可以随意将其调整为您喜欢的位置，我已经看到很多人使用/ home / git。</p><p> I included the  --disabled-password to disable any password based access into our new user. In  the previous sections, we&#39;ve disabled all password based authentication into the server and Gitolite requires ssh keys for authentication, so disabling passwords for our user is a smart move.</p><p> 我添加了--disabled-password来禁用对新用户的任何基于密码的访问。在前面的部分中，我们已将所有基于密码的身份验证禁用到服务器中，并且Gitolite要求使用ssh密钥进行身份验证，因此为用户禁用密码是明智之举。 </p><p> Because Gitolite is just a bunch of Perl scripts, I prefer to install Gitolite from  the source. As we will see, installing Gitolite from source also has the benefit of making upgrades and adding custom patches in the future extremely easy.</p><p>因为Gitolite只是一堆Perl脚本，所以我更喜欢从源代码安装Gitolite。正如我们将看到的，从源代码安装Gitolite还具有使升级和将来添加自定义补丁程序非常容易的好处。</p><p>   When we (or a colleague) signs into the server, using the  git user, we will automatically run Gitolite&#39;s Perl scripts, which means these scripts must be executable by our  git user. So, to make managing file permissions easier, we&#39;ll use our  git user for the rest of the installation process.</p><p>   当我们（或同事）使用git用户登录服务器时，我们将自动运行Gitolite的Perl脚本，这意味着这些脚本必须由git用户可执行。因此，为简化文件权限管理，我们将在其余的安装过程中使用git用户。</p><p> Log into our  git user with the &#34;substitute user&#34; command: (assuming you&#39;re the  root user)</p><p> 使用＆＃34;替代用户＆＃34;登录到我们的git用户。命令：（假设您是root用户）</p><p>  Then clone Gitolite&#39;s source code into the  $HOME directory: (this should be  /var/lib/git unless  you changed it when we setup the  git user above)</p><p>  然后将Gitolite的源代码克隆到$ HOME目录中：（除非您在上面设置git用户时更改了它，否则它应该是/ var / lib / git）</p><p> To setup Gitolite on the server, we&#39;ll need to assign Gitolite an admin that will have full control over editing Gitolite&#39;s configuration repository. This will most likely be you.</p><p> 要在服务器上设置Gitolite，我们需要为Gitolite分配一个管理员，该管理员将完全控制编辑Gitolite的配置存储库。这很可能是你。</p><p> Still as the  git user, use  your favorite text editor to create a new file with your desired username in the  $HOME directory and copy your  public ssh key into it. For example, my file would be called  bryanbrattlof.pub and look like this:</p><p> 仍然以git用户身份，使用您喜欢的文本编辑器在$ HOME目录中创建具有所需用户名的新文件，并将您的公共ssh密钥复制到该文件中。例如，我的文件名为bryanbrattlof.pub，如下所示：</p><p>       I recommend consulting  Gitolite&#39;s incredible documentation to understand how to properly configure access and add hooks to all of your projects.</p><p>       我建议查阅Gitolite令人难以置信的文档，以了解如何正确配置访问权限并为所有项目添加挂钩。 </p><p> While not technically needed for Gitolite to function properly, I find adding gitolite to our  git user&#39;s  $PATH is a great quality of life improvement on the rare days I need to play system administrator.</p><p>虽然从技术上来说Gitolite不能正常运行，但我发现在我们的git用户的$ PATH中添加gitolite可以极大地改善生活质量，而我很少需要扮演系统管理员的角色。</p><p>      Now, we can use Gitolite&#39;s  install script to add a symbolic link inside our  $HOME/bin folder:</p><p>      现在，我们可以使用Gitolite的安装脚本在$ HOME / bin文件夹中添加一个符号链接：</p><p>   Logout and back in to the  git user (or use  source $HOME/.profile) to pick up the changes. If everything was done correctly, you won&#39;t need to type the full path to Gitolite anymore.</p><p>   注销并重新登录到git用户（或使用源$ HOME / .profile）以获取更改。如果一切操作正确，您将无需再键入Gitolite的完整路径。</p><p> Cgit is a script (written in C) that uses the  Common Gateway Interface (CGI) specification to give people a web view of our projects. Convenient when you don&#39;t have access to your terminal or just want to lookup (or showoff) some changes to a project.</p><p> Cgit是一个脚本（用C编写），它使用通用网关接口（CGI）规范为人们提供了我们项目的Web视图。当您无权访问终端或只想查找（或展示）对项目的某些更改时很方便。</p><p> It operates as a back-end (much like  PHP) to a webserver (we&#39;ll install Nginx  in the next sections) that will parse our repositories and return a web-page for our webserver to distribute.</p><p> 它作为Web服务器的后端（类似于PHP）运行（我们将在下一部分中安装Nginx），该服务器将解析我们的存储库并返回一个网页，供我们的Web服务器分发。</p><p> To get an idea for what Cgit will look like, some of the more popular projects that use Cgit are the  Linux and  FreeBSD kernels, along with  Wireguard and  Cgit itself.</p><p> 为了了解Cgit的外观，一些使用Cgit的比较流行的项目是Linux和FreeBSD内核，以及Wireguard和Cgit本身。</p><p> Just like with Gitolite, I prefer to install Cgit  from source so I can add personal patches and quickly change what version is running on the server. This also means we&#39;ll need to install the dependencies ourselves:</p><p> 就像使用Gitolite一样，我更喜欢从源代码安装Cgit，以便添加个人补丁并快速更改服务器上正在运行的版本。这也意味着我们需要自己安装依赖项： </p><p>  We&#39;ll also need the  build-essential packages to install the  gcc and  make tools needed to compile Cgit after we&#39;ve cloned the project:</p><p>克隆项目后，我们还需要构建必需的软件包来安装gcc并提供编译Cgit所需的工具：</p><p>    Because Cgit uses parts of Git&#39;s source code, (included as a  submodule) we&#39;ll need to use  git submodule to download the remaining code from the Git project.</p><p>    由于Cgit使用了Git源代码的一部分（包含在子模块中），因此我们需要使用git子模块从Git项目中下载其余代码。</p><p>  $ git submodule init # register the git submodule in .git/config$ git submodule update # clone/fetch and checkout correct git version</p><p>  $ git submodule init＃在.git / config中注册git子模块$ git submodule update＃克隆/获取并检出正确的git版本</p><p> With a full copy of Cgit on the server, we can now create some patches to customize it for our use-case. We&#39;ll start with creating  cgit.conf inside the  cgit project we just cloned, to tell  make where we want to install the Cgit binaries.</p><p> 在服务器上拥有Cgit的完整副本之后，我们现在可以创建一些补丁以针对我们的用例对其进行自定义。我们将从在刚刚克隆的cgit项目中创建cgit.conf开始，以告诉make我们要将Cgit二进制文件安装在何处。</p><p>  Because this is a version controlled project, we can commit our changes to save our work:</p><p>  因为这是一个版本控制的项目，所以我们可以提交更改以保存我们的工作：</p><p>      If everything went well, when you execute Cgit from the terminal, a web-page should print out:</p><p>      如果一切顺利，那么当您从终端执行Cgit时，应该会打印出一个网页：</p><p> $ ./cgitContent-Type: text/html; charset=UTF-8Last-Modified: Tue, 12 Jan 2021 22:35:43 GMTExpires: Tue, 12 Jan 2021 22:40:43 GMT&lt;!DOCTYPE html&gt;</p><p> $ ./cgitContent-Type：text / html; charset = UTF-8最后修改时间：2021年1月12日星期二22:35:43 GMT到期时间：2021年1月12日星期二22:40:43 GMT＆lt;！DOCTYPE html＆gt; </p><p>  We can further customize Cgit&#39;s behavior using the  cgitrc file located at  /var/www/html/cgit/cgitrc. Feel free to check out  the man page for a complete description of what every option does.</p><p>我们可以使用位于/ var / www / html / cgit / cgitrc的cgitrc文件进一步自定义Cgit的行为。请随意查看手册页，以获取每个选项的完整描述。</p><p>  set  project-list to the location of the  projects.list file Gitolite creates, adding descriptions and categories to the list of repositories on Cgit&#39;s index page</p><p>  将project-list设置为projects.list的位置Gitolite创建，在Cgit的索引页面上的存储库列表中添加描述和类别</p><p> Cgit, which uses code from Git, was designed to let users run a command (eg:  git push) then exit, allowing our computers to reclaim the used resources between each call. Nginx uses a faster protocol ( FastCGI) which calls the same program multiple times without exiting.</p><p> Cgit使用Git中的代码，旨在让用户运行命令（例如：git push）然后退出，从而使我们的计算机可以在每次调用之间回收使用的资源。 Nginx使用更快的协议（FastCGI），该协议多次调用同一程序而不会退出。</p><p> However because Cgit was designed to exit after every run, it will never give back its used resources and will continue to take more, quickly exhausting all of the computer&#39;s available resources. This is why we need  fcgiwrap.</p><p> 但是，由于Cgit旨在在每次运行后退出，因此它将永远不会退回其使用的资源，并且会继续消耗更多资源，从而迅速耗尽计算机的所有可用资源。这就是为什么我们需要fcgiwrap。</p><p> With  Cgit and the  FastCGI Wrapper installed, we can now turn our attentions to Nginx, which can be installed using the Advanced Packaging Tool:</p><p> 安装了Cgit和FastCGI Wrapper之后，我们现在可以将注意力转移到Nginx上，可以使用Advanced Packaging Tool进行安装：</p><p>  Next, create a new configuration file in the  /etc/nginx/sites-enabled directory, replacing  git.bryanbrattlof.com with your domain. The minimum configuration file you&#39;ll need for Cgit to work will look something like this:</p><p>  接下来，在/ etc / nginx / sites-enabled目录中创建一个新的配置文件，将git.bryanbrattlof.com替换为您的域。 Cgit工作所需的最低配置文件如下所示：</p><p> server { server_name git.bryanbrattlof.com; listen [::]:80; listen 80; access_log /var/log/nginx/cgit-access.log; error_log /var/log/nginx/cgit-error.log; root /var/www/html/cgit/cgi; try_files $uri @cgit; location @cgit { include fastcgi_params; fastcgi_param SCRIPT_FILENAME /var/www/html/cgit/cgi/cgit.cgi; fastcgi_pass unix:/run/fcgiwrap.socket; fastcgi_param PATH_INFO $uri; fastcgi_param QUERY_STRING $args; fastcgi_param HTTP_HOST $server_name; }}</p><p> 服务器{server_name git.bryanbrattlof.com;听[::]：80;听80; access_log /var/log/nginx/cgit-access.log; error_log /var/log/nginx/cgit-error.log;根目录/ var / www / html / cgit / cgi; try_files $ uri @cgit; location @cgit {包括fastcgi_params; fastcgi_param SCRIPT_FILENAME /var/www/html/cgit/cgi/cgit.cgi; fastcgi_pass Unix：/run/fcgiwrap.socket; fastcgi_param PATH_INFO $ uri; fastcgi_param QUERY_STRING $ args; fastcgi_param HTTP_HOST $服务器名称; }} </p><p> Feel free to add more to this, I&#39;ve added a custom  5xx page, caching headers, as well as recommendations from  Mozilla Observatory.</p><p>请随意添加更多内容，我添加了一个自定义5xx页面，缓存标题以及Mozilla Observatory的建议。</p><p>   If something went wrong, or if you ever change the configuration file, you can use  nginx -t to check the configuration for errors and  nginx -s reload to restart the Nginx server.</p><p>   如果出了点问题，或者曾经更改过配置文件，则可以使用nginx -t检查配置是否有错误，并使用nginx -s reload重新启动Nginx服务器。</p><p> By now we should have a working git server. However like most creative things  &#34;90% done ... 90% left to go.&#34; There is truly an endless supply of things you can and should add or configure to make your server more secure and accessible. If you&#39;re the type that likes to learn, then you&#39;ll likely find this as fun and rewarding experience as I did.</p><p> 现在，我们应该已经可以使用git服务器了。但是，像大多数创造性的事情一样，＆＃34; 90％完成了... 90％可以去了。＆＃34;确实可以提供无穷无尽的东西，应该添加或配置这些东西，以使您的服务器更加安全和可访问。如果您是喜欢学习的人，那么您可能会像我一样觉得这是有趣而有益的经历。</p><p>  Installed  certbot to install and manage a free SSL certificate from  Let&#39;s Encrypt. This has largely been mandatory for any public server for around 5 years now</p><p>  已安装certbot，以安装和管理来自Let's Encrypt的免费SSL证书。大约5年以来，这在所有公共服务器上都是强制性的</p><p> Created a  Borg based backup script with a Borg specific subscription to  rsync.net to backup my projects. Useful when  that jackass we talked about finds a 0-day</p><p> 使用Borg特定的rsync.net订阅创建了一个基于Borg的备份脚本，以备份我的项目。当我们谈论的公驴发现0天时很有用</p><p> Created a  Git Daemon service to allow people to clone my projects using the  git:// protocol, if they prefer</p><p> 创建了一个Git Daemon服务，让人们可以根据需要使用git：//协议克隆我的项目</p><p> Placed a bunch of  Healthchecks Pings in the scripts and service required to keep everything running. Fail2Ban, Borg Backup, Certbot, all will alert me when  cron or  systemd fall over</p><p> 在保持一切正常运行所需的脚本和服务中放置了一堆Healthcheck Pings。当cron或systemd跌倒时，Fail2Ban，Borg Backup，Certbot都会提醒我 </p><p> All of which should be given their own essay as they can be used in all your setups, not just in this fully open-source and free (as in libre) git server.</p><p>所有这些都应该给出自己的文章，因为它们可以在您的所有设置中使用，而不仅是在此完全开源和免费（如libre）的git服务器中。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bryanbrattlof.com/cgit-nginx-gitolite-a-personal-git-server/">https://bryanbrattlof.com/cgit-nginx-gitolite-a-personal-git-server/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/nginx/">#nginx</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>