<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#c++</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#c++</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1049143.html">在C ++中实现并行Copy_If </a></div><div class="item_title_en"><a target="_blank" href="https://www.cppstories.com/2021/par-copyif/">Implementing Parallel Copy_If in C++</a><span>(www.cppstories.com)</span></div><span class="my_story_list_date">2021-2-25 2:14</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1049143.html"><img src="http://img2.diglog.com/img/2021/2/thumb_17e7ecd194befaf639813457d932baf4.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在有关十二种过滤元素的博客文章中，我只提到了代码的串行版本。但是如何利用并发呢？也许我们可以抛出更多线程和异步任务并更快地完成复制？
 例如，我的机器上有6个内核，因此很高兴看到，例如顺序复制速度提高了5倍？
 在C ++ 17中，我们有并行算法，因此让我们尝试使用std :: execution :: par调用s......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/实现/">#实现</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parallel/">#parallel</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/std/">#std</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1048664.html">Watcom C / C ++ CD-ROM的优秀存档（Archive.org）（2018） </a></div><div class="item_title_en"><a target="_blank" href="https://virtuallyfun.com/wordpress/2018/05/29/excellent-archive-of-watcom-c-c-cd-roms-on-archive-org/">Excellent archive of Watcom C/C++ CD-ROMs on Archive.org (2018)</a><span>(virtuallyfun.com)</span></div><span class="my_story_list_date">2021-2-21 7:50</span><div class="my_story_list_item_desc">我最近偶然发现了这个收藏，但值得分享。 当时我是Watcom C / C ++ 10.0的超级粉丝，因为它不仅包含许多目标，而且还包含主机设置，使其成为当天针对16位MS-DOS，32位扩展DOS的出色编译器 ，OS / 2 16位＆amp; 32位，Win16，Win32，自定义的32位Windows扩展程序，32......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cd/">#cd</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/archive/">#archive</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/扩展/">#扩展</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1048648.html">libstdc ++和Libc ++之间的Unique_ptr差异使您的应用程序崩溃 </a></div><div class="item_title_en"><a target="_blank" href="https://blogs.kde.org/2021/02/20/uniqueptr-difference-between-libstdc-and-libc-crashes-your-application">Unique_ptr difference between libstdc++ and Libc++ crashes your application</a><span>(blogs.kde.org)</span></div><span class="my_story_list_date">2021-2-21 7:45</span><div class="my_story_list_item_desc">感谢KDE FreeBSD CI，它在libc ++之上运行我们的代码，我们发现libstdc ++和libc ++的unique_ptr实现之间存在有趣的区别。这是完全出乎意料的，并且用户的实际结果甚至更出乎意料：在特定情况下可能导致崩溃。当小部件（使用d指针作为其d指针，这是当今的惯例）安装事件过滤器时，就会发生......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ptr/">#ptr</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/事件/">#事件</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1047180.html">C ++ 11元组实现详细信息（2012） </a></div><div class="item_title_en"><a target="_blank" href="http://mitchnull.blogspot.com/2012/06/c11-tuple-implementation-details-part-1.html">C++11 Tuple Implementation Details (2012)</a><span>(mitchnull.blogspot.com)</span></div><span class="my_story_list_date">2021-2-6 20:23</span><div class="my_story_list_item_desc">Warning: Can only detect less than 5000 characters
非递归元组实现背后的基本思想是，元组元素存储在TupleLeaf基类中，但是递归实现使用深层次的类层次结构，而我们将使用多重继承。用伪代码：
 模板＆lt; typename T0，typename T1，...，t......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/实现/">#实现</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lt/">#lt</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1046835.html">Joern – C / C ++的开源代码查询引擎 </a></div><div class="item_title_en"><a target="_blank" href="https://joern.io/">Joern – Open-Source Code Querying Engine for C/C++</a><span>(joern.io)</span></div><span class="my_story_list_date">2021-1-30 8:14</span><div class="my_story_list_item_desc">Joern是屡获殊荣的开源平台，用于基于C / C ++的基于查询的强大分析。它使用基于Scala的特定于域的查询语言来为漏洞挖掘大型代码库，并为代码属性图提供参考实现。凭借其模糊的解析方法，它特别适合于机器学习应用程序。 Joern是ShiftLeft上商业SAST和代码探索产品的基础。
 代码属性图（CPG）是设......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/开源/">#开源</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/查询/">#查询</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/open/">#open</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1045736.html">C ++反模式 </a></div><div class="item_title_en"><a target="_blank" href="https://martin-ueding.de/posts/cpp-antipatterns/">C++ Anti-Patterns</a><span>(martin-ueding.de)</span></div><span class="my_story_list_date">2021-1-22 13:2</span><div class="my_story_list_item_desc">预处理程序常数应始终使用大写字母。否则，您将得到最奇怪的错误，需要花费数小时至数天才能找到。假设您要在编译时打开/关闭某些功能。一种使用#ifdef的方法是这样的：
 int make_query（Query const＆amp; q）{//在此处进行一些查询。 #ifdef VERIFY_RESULT //执行一些......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/模式/">#模式</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/anti/">#anti</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1045324.html">2020年Go和C ++中的错误与异常 </a></div><div class="item_title_en"><a target="_blank" href="https://dr-knz.net/go-errors-vs-exceptions-2020.html">Errors vs. exceptions in Go and C++ in 2020</a><span>(dr-knz.net)</span></div><span class="my_story_list_date">2021-1-20 19:33</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1045324.html"><img src="http://img2.diglog.com/img/2021/1/thumb_5f63c04a23404eeb4b88f6421ddb2a74.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">早在2018年，我们就低级调用约定从经验上比较了Goand C ++的性能开销：传递参数，返回多个值以及传播异常时。
 这些结果是使用Go 1.10和Clang 6.0获得的。从那时起，编译器不断发展，我们现在使用Go 1.15和Clang11.0运行。从那以后发现有变化吗？
  什么是便宜的：通过err：= .........</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1044525.html">GitHub上的新“动作类Rogue” C ++项目 </a></div><div class="item_title_en"><a target="_blank" href="https://www.tomlooman.com/action-roguelike-cpp-ue4/">New ‘Action Roguelike’ C++ Project on GitHub</a><span>(www.tomlooman.com)</span></div><span class="my_story_list_date">2021-1-16 17:17</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1044525.html"><img src="http://img2.diglog.com/img/2021/1/thumb_9e4e0fd42f10fa5ab8350f415bf06458.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">对于斯坦福大学的2020年秋季课程，我构建了一个小游戏项目，主要使用C ++和虚幻引擎中的一些蓝图混合而成。对于那些感兴趣的人，整个计算机科学课程（CS193U）通过Zoom讲座提供并已记录。我正在努力出版此书，与此同时，该项目已经通过GitHub开放源代码，任何人都可以拆解！
    该游戏具有多种功能，可涵盖对学......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/github/">#github</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/动作类/">#动作类</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/roguelike/">#roguelike</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/功能/">#功能</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1044463.html">为什么已经有C ++和Rust时就使用Zig？ </a></div><div class="item_title_en"><a target="_blank" href="https://ziglang.org/learn/why_zig_rust_d_cpp/">Why Zig When There Is Already C++ and Rust?</a><span>(ziglang.org)</span></div><span class="my_story_list_date">2021-1-16 7:0</span><div class="my_story_list_item_desc">如果Zig代码看起来像是跳了起来就无法调用函数，则不是。这意味着您可以确保以下代码仅调用foo（）然后再调用bar（），并且可以确保无需知道任何类型的代码：
   D具有@property函数，这些函数可以通过类似于字段访问的方式来调用，因此在上面的示例中，c.d可能会调用一个函数。
 C ++，D和Rust具有运算......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/zig/">#zig</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1044066.html">CMake和C ++软件包管理的未来 </a></div><div class="item_title_en"><a target="_blank" href="http://ibob.github.io/blog/2020/01/13/cmake-package-management/">CMake and the Future of C++ Package Management</a><span>(ibob.github.io)</span></div><span class="my_story_list_date">2021-1-15 19:57</span><div class="my_story_list_item_desc">我最近遇到了一个我不知道的CMake功能。它是FetchContent。我敢肯定，这对大多数人来说不是什么新闻，因为它是在CMake 3.14 1中添加的，并且自2019年2月以来一直存在，所以已经有两年了，但这是一个启示。
 它可以……不，应该……不，它必须成为C和C ++包管理器未来的垫脚石。
 …问题解决后，我......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/软件包/">#软件包</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/future/">#future</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cmake/">#cmake</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1043110.html">适用于Swift开发人员的C ++ </a></div><div class="item_title_en"><a target="_blank" href="https://whackylabs.com/swift/cpp/languages/2021/01/03/cpp-for-swift-devs/">C++ for Swift Developers</a><span>(whackylabs.com)</span></div><span class="my_story_list_date">2021-1-4 20:3</span><div class="my_story_list_item_desc">从某种意义上讲，Swift非常类似于C ++，当我说C ++时，我的意思是C ++ 11及更高版本。也可能会说Swift是更干净的C ++，或者说C ++没有80年代的向后兼容能力。为了给出一个想法，这里是一个最小的现代C ++代码：
 #include＆lt; iostream＆gt; // 1使用命名空间std;......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/swift/">#swift</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1042857.html">Concurrencpp –一个C ++并发库 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/David-Haim/concurrencpp">Concurrencpp – A C++ concurrency library</a><span>(github.com)</span></div><span class="my_story_list_date">2021-1-2 8:21</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1042857.html"><img src="http://img2.diglog.com/img/2021/1/thumb_ef812e52d976fb74194da576eed9833d.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">concurrencpp是C ++的任务库，允许开发人员通过使用任务，执行程序和协程轻松安全地编写高度并发的应用程序。使用concurrencpp应用程序可以将需要异步处理的大型过程分解为可并行运行并可以在内部运行的较小任务。合作的方式来达到所需的结果。concurrencpp还允许应用程序使用并行协程轻松编写并行算......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/任务/">#任务</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1042783.html">2020年首创（或C ++的好消息）– Herb Sutter </a></div><div class="item_title_en"><a target="_blank" href="https://herbsutter.com/2020/12/30/firsts-in-2020-or-a-little-dose-of-good-news/">Firsts in 2020 (or, A little dose of good news for C++) – Herb Sutter</a><span>(herbsutter.com)</span></div><span class="my_story_list_date">2021-1-1 9:3</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1042783.html"><img src="http://img2.diglog.com/img/2021/1/thumb_4127c1d751fd486005de4a5a9ebd8340.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">2020年几乎是可怕的。其中包括C ++委员会和我们的许多社区，就在本月，我们失去了Beman Dawes。 Beman是世界上最重要和最有影响力的C ++专家之一，他的许多贡献大部分是在幕后进行的。我和其他曾经从任何标准化STL，Boost，C ++ Now，std :: filesystem，C ++ 98/11......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/好消息/">#好消息</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/good/">#good</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/功能/">#功能</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1042272.html">深入：C ++中的函数式编程（John Carmack，2012年） </a></div><div class="item_title_en"><a target="_blank" href="https://gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php">In-depth: Functional programming in C++ (John Carmack, 2012)</a><span>(gamasutra.com)</span></div><span class="my_story_list_date">2020-12-29 5:5</span><div class="my_story_list_item_desc">Warning: Can only detect less than 5000 characters</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/john/">#john</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1042200.html">Wisp：用C ++编写的轻量级Lisp </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/adam-mcdaniel/wisp">Wisp: A light Lisp written in C++</a><span>(github.com)</span></div><span class="my_story_list_date">2020-12-28 22:47</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1042200.html"><img src="http://img2.diglog.com/img/2020/12/thumb_13978cda23992f3c036f3b2810e7c91f.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Lisp是人们真正习惯于使用的那些利基，优美的语言之一
   答案很简单：我对隔离感到无聊。如果您想找出为什么这种特殊的口吻特别特别，那么您将一无是处。
     像其他所有lisp一样，该语言将s表达式用于代码语法和数据语法。因此，例如，s表达式（打印5）既是有效的代码段，又是包含列表print和5的有效列表。
 ......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/wisp/">#wisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/light/">#light</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/评估/">#评估</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1042100.html">东正教C ++ </a></div><div class="item_title_en"><a target="_blank" href="https://gist.github.com/bkaradzic/2e39896bc7d8c34e042b">Orthodox C++</a><span>(gist.github.com)</span></div><span class="my_story_list_date">2020-12-28 5:47</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1042100.html"><img src="http://img2.diglog.com/img/2020/12/thumb_b5d0f1167a86fdbbb8945644fc4c54f6.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">正统C ++（有时称为C +）是C ++的最小子集，可改进C，但避免了所谓的Modern C ++中的所有不必要的事情。它与现代C ++的假设完全相反。
  早在1990年代末，我们还是当时的C ++潮人，我们使用了最新功能。我们还告诉所有人，他们也应该使用这些功能。随着时间的流逝，我们了解到不必仅仅因为存在某些语言......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/东正教/">#东正教</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/orthodox/">#orthodox</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041879.html">Dev-C ++是内置于Delphi中的低内存Windows Native C ++ IDE </a></div><div class="item_title_en"><a target="_blank" href="https://blogs.embarcadero.com/dev-c-is-a-low-memory-windows-native-c-ide-built-in-delphi/">Dev-C++ Is a Low Memory Windows Native C++ IDE Built in Delphi</a><span>(blogs.embarcadero.com)</span></div><span class="my_story_list_date">2020-12-26 10:33</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1041879.html"><img src="http://img2.diglog.com/img/2020/12/thumb_6aa94bd50df08daa9373a24000494d15.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Embarcadero Dev-C ++是Bloodshed Dev-C ++和Orwell Dev-C ++的新改进版（由Embarcadero赞助）。 它是功能齐全的集成开发环境（IDE）和C / C ++编程语言的代码编辑器。 它使用TDM-GCC 9.2.0中GCC的Mingw端口（GNU编译器集合）作为具有......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/delphi/">#delphi</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041761.html">使用Nvc ++和Cython在GPU上加速Python </a></div><div class="item_title_en"><a target="_blank" href="https://developer.nvidia.com/blog/accelerating-python-on-gpus-with-nvc-and-cython/">Accelerating Python on GPUs with Nvc++ and Cython</a><span>(developer.nvidia.com)</span></div><span class="my_story_list_date">2020-12-25 18:40</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1041761.html"><img src="http://img2.diglog.com/img/2020/12/thumb_74aa7d58bf55c1fc21282821d397be3a.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">C ++标准库包含丰富的容器，迭代器和算法的集合，这些容器，迭代器和算法可以组合起来以产生复杂问题的优雅解决方案。最重要的是，它们速度很快，使C ++成为编写高性能代码的诱人选择。
 NVIDIA最近推出了stdpar：一种使用nvc ++编译器在GPU上自动加速C ++标准库算法执行的方法。这意味着使用标准库容器和......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nvc/">#nvc</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041588.html">数据科学的交互式C ++ </a></div><div class="item_title_en"><a target="_blank" href="https://blog.llvm.org/posts/2020-12-21-interactive-cpp-for-data-science/">Interactive C++ for Data Science</a><span>(blog.llvm.org)</span></div><span class="my_story_list_date">2020-12-24 21:40</span><div class="my_story_list_item_desc">在我们以前的博客文章“ Interactive C ++ with Cling”中，我们提到了探索性编程是减少问题复杂性的有效方法。这篇文章将讨论为支持数据科学研究人员而开发的Cling的一些应用程序。特别是，交互式探测数据和接口使复杂的库和复杂的数据更易于访问。我们旨在大规模展示Cling的某些功能； Cling的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/科学/">#科学</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cling/">#cling</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1041546.html">C ++使用指令如何工作？ </a></div><div class="item_title_en"><a target="_blank" href="https://quuxplusone.github.io/blog/2020/12/21/using-directive/">How do C++ using-directives work?</a><span>(quuxplusone.github.io)</span></div><span class="my_story_list_date">2020-12-24 21:18</span><div class="my_story_list_item_desc">使用声明在语义上类似于声明；它在当前范围内引入了名称的新含义。如果该名称已经具有来自外部作用域的一个或多个含义，则这些现有的含义将被新声明隐藏或遮盖。 Godbolt：
 命名空间AnimalUtils {int foo（Zoo :: Animal）;}命名空间Outer {int foo（Zoo :: Lion）;......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/foo/">#foo</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1040971.html">在现代C ++中编写自定义迭代器 </a></div><div class="item_title_en"><a target="_blank" href="https://www.internalpointers.com/post/writing-custom-iterators-modern-cpp">Writing a custom iterator in modern C++</a><span>(www.internalpointers.com)</span></div><span class="my_story_list_date">2020-12-21 9:55</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1040971.html"><img src="http://img2.diglog.com/img/2020/12/thumb_49378e695281bcc7cb8b5aaf5698c966.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">迭代器是指向容器内元素的对象。像指针一样，迭代器可用于访问其指向的元素，并可在容器的内容中移动。 C ++标准库中的每个容器都提供了自己的迭代器以及一些检索它的方法。使用迭代器非常简单：从容器中获取实例，将其移动到需要的地方，然后获取指向的元素。
 具体而言，迭代器是一个简单的类，提供了许多运算符：增量++，解引用*......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/迭代/">#迭代</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/custom/">#custom</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1040863.html">报告：PHP，C ++，Java和.NET应用程序最经常出现缺陷 </a></div><div class="item_title_en"><a target="_blank" href="https://www.techrepublic.com/article/the-worst-bugs-in-the-top-programming-languages/">Report: PHP, C++, Java, and .NET Applications are the Most Frequently Flawed</a><span>(www.techrepublic.com)</span></div><span class="my_story_list_date">2020-12-20 16:52</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1040863.html"><img src="http://img2.diglog.com/img/2020/12/thumb_9559637fd60b56cc2a1a91f1089d2d4f.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">热图显示，PHP的缺陷最多，其次是C ++，其次是Veracode的年度安全报告中的Java，.Net，JavaScript和Python。
  Veracode已发布其年度软件安全状况报告的第11卷，其调查结果表明存在缺陷的应用程序已成为常态，开放源代码库越来越不可信，并且花费很长时间来解决问题。
    该报告发......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/php/">#php</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/应用程序/">#应用程序</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1040625.html">ganja.js：适用于JavaScript，C ++，C＃，Rust，Python的几何代数生成器 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/enkimute/ganja.js">ganja.js: Geometric Algebra Generator for JavaScript, C++, C#, Rust, Python</a><span>(github.com)</span></div><span class="my_story_list_date">2020-12-19 4:57</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1040625.html"><img src="http://img2.diglog.com/img/2020/12/thumb_39ca867ff67cf83ce66c43d01cdf082a.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Ganja.js是JavaScript的几何代数代码生成器。它生成任何签名的Clifford代数和子代数，并实现运算符重载和代数常数。
  @misc {https://doi.org/10.5281/zenodo.3635774，doi = {10.5281 / ZENODO.3635774}，url = {htt......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c#/">#c#</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1040572.html">C ++中的设计模式 </a></div><div class="item_title_en"><a target="_blank" href="https://www.fluentcpp.com/2020/12/18/on-design-patterns-in-cpp/">On Design Patterns in C++</a><span>(www.fluentcpp.com)</span></div><span class="my_story_list_date">2020-12-19 1:56</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1040572.html"><img src="http://img2.diglog.com/img/2020/12/thumb_ab96c9f2137701f846c007beca18e5c1.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我知道的对“设计模式”的第一个参考是著名的GoF书：
 这本书是编程的经典著作，它位于世界各地许多程序员的桌上。
 本书描述的设计模式是多种结构化代码以解决特定问题的方法。这些模式已标记有“策略”，“访问者”，“适配器”，“命令链”等名称。
 设计模式不是特定于语言的：它们可以以C ++，Java，C＃和许多其他语言......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/设计模式/">#设计模式</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/patterns/">#patterns</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1039986.html">ISO / IEC 14882：2020 C ++标准发布 </a></div><div class="item_title_en"><a target="_blank" href="https://www.iso.org/standard/79358.html">ISO/IEC 14882:2020 C++ Standard Published</a><span>(www.iso.org)</span></div><span class="my_story_list_date">2020-12-16 14:4</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1039986.html"><img src="http://img2.diglog.com/img/2020/12/thumb_48908365c083987b0603c0f86af2350f.gif" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">ISO / IEC 14882：2020本文档规定了C ++编程语言的实现要求。 第一个这样的要求是它们必须实现语言，因此本文档还定义了C ++。 其他需求  C ++是基于C编程语言的通用编程语言，如所述。  ISO / IEC 9899：2018编程语言-C（以下称为C标准）。 C ++提供 </div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/iso/">#iso</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/standard/">#standard</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1039426.html">使用C ++ 20进行位操作 </a></div><div class="item_title_en"><a target="_blank" href="http://www.modernescpp.com/index.php/bit-manipulation-with-c-20">Bit Manipulation with C++20</a><span>(www.modernescpp.com)</span></div><span class="my_story_list_date">2020-12-13 17:22</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1039426.html"><img src="http://img2.diglog.com/img/2020/12/thumb_06d3aad1627e300211563c2e6e97eabe.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这篇文章总结了我对C ++ 20库功能的介绍。今天，我写关于类std :: source_location和一些用于位操作的函数的文章。
    std :: source_location表示有关源代码的信息。该信息包括文件名，行号和函数名。当您需要有关呼叫站点的信息（例如用于调试，记录或测试目的）时，此信息非常宝......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/std/">#std</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1038059.html">Skybolt：具有Python绑定的C ++行星环境渲染引擎 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/Piraxus/Skybolt">Skybolt: A C++ planetary environment rendering engine with Python bindings</a><span>(github.com)</span></div><span class="my_story_list_date">2020-12-6 20:46</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1038059.html"><img src="http://img2.diglog.com/img/2020/12/thumb_977df6d26a6381e3ca831650b8902e09.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Skybolt是一种实时行星环境渲染引擎，旨在用于飞行模拟器，航空航天研发和地理空间应用。 Skybolt用C ++编写，基于OpenSceneGraph，并支持CIGI与主机应用程序进行通信。 Skybolt还具有Python API，可轻松与科学和工程研究工具集成。
 Skybolt存储库包括Sprocket，这......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/具有/">#具有</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gt/">#gt</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1038051.html">C ++仍需要预处理器吗？ （2017） </a></div><div class="item_title_en"><a target="_blank" href="https://foonathan.net/2017/05/preprocessor/">Is the preprocessor still needed in C++? (2017)</a><span>(foonathan.net)</span></div><span class="my_story_list_date">2020-12-6 20:21</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1038051.html"><img src="http://img2.diglog.com/img/2020/12/thumb_46d9b42d58b021e14ad294ce56bed05f.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">它是必须与C ++一起使用的原始文本替换工具。但是“必须”确实如此吗？由于新的和更好的C ++语言功能，大多数用法已经过时了。模块之类的更多功能很快就会出现™那么我们能摆脱预处理器吗？如果是的话，我们该怎么办呢？
  预处理器的大部分使用已经是不好的做法：不要将其用于符号常量，请勿将其用于内联函数等。
 因为这引起了......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/需要/">#需要</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/needed/">#needed</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037957.html">一种特殊的地狱：C和C ++中的intmax_t </a></div><div class="item_title_en"><a target="_blank" href="https://thephd.github.io/intmax_t-hell-c++-c">A Special Kind of Hell: intmax_t in C and C++</a><span>(thephd.github.io)</span></div><span class="my_story_list_date">2020-12-6 3:54</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1037957.html"><img src="http://img2.diglog.com/img/2020/12/thumb_b28292cfd6e08266eb3ade4fe4286595.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">C和C ++作为语言有一些东西使它们彼此分开，主要是在它们的详细信息上，偶尔还有较大的功能集，例如指定的初始化程序。但是，令人烦恼的是，大量的C ++可以简单地完成C的工作，远胜于C，包括解决C和C ++的发展面临的一些最大问题时。
 让我们来解决一个同时困扰C和C ++的当代问题，它影响了从标准库维护人员到项目开发......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/地狱/">#地狱</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/kind/">#kind</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/imaxabs/">#imaxabs</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037915.html">std :: visit是现代C ++的所有错误（2017） </a></div><div class="item_title_en"><a target="_blank" href="https://bitbashing.io/std-visit.html">std::visit is everything wrong with modern C++ (2017)</a><span>(bitbashing.io)</span></div><span class="my_story_list_date">2020-12-5 22:9</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1037915.html"><img src="http://img2.diglog.com/img/2020/12/thumb_50a96ec38224a65e065993b6f8c5b389.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">一个求和类型，也称为区分联合，可以容纳几种类型的事物中的一种（并且只有一种），例如，考虑类似INI的配置文件中的某些设置，假设每个设置必须是一个字符串，一个整数或布尔值。如果要在C ++中推出自己的解决方案，我们可能会写类似以下内容：
 结构设置{union {字符串str;整数;布尔b; };枚举类型{Str，In......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/visit/">#visit</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="/tag/c++/">0</a></li><li class="page-item active"><a class="page-link" href="/tag/c++/page1.html">1</a></li><li class="page-item"><a class="page-link" href="/tag/c++/page2.html">2</a></li><li class="page-item"><a class="page-link" href="/tag/c++/page3.html">3</a></li><li class="page-item"><a class="page-link" href="/tag/c++/page4.html">4</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>