<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>对文本协议的案例 A case against text protocols</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A case against text protocols<br/>对文本协议的案例 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-17 14:12:36</div><div class="page_narrow text-break page_content"><p>Human-computer interaction is very different from computer-computer interaction. For a human to communicate with a computer, English-like commands on text shell or graphical user interfaces that uses point-and-click model works great. But once that ends and when two or more computers have to interact, text protocols may not be all that helpful. Yet, text based computer-to-computer protocols are extremely common and often seemingly ubiquitous even in places where it&#39;s impossible for an average human to interact.</p><p>人机交互与计算机计算机交互非常不同。对于与计算机进行通信的人，在文本shell或使用点击模型的图形用户界面上的英语命令很大。但是，一旦结束，当两个或更多计算机必须交互时，文本协议可能并不是所有有帮助的。然而，基于文本的计算机到计算机协议非常常见，并且甚至在它的地方常见的地方似乎普遍无处不在。</p><p> Here are some shaky arguments you&#39;ll come across on the internet that glorifies text based protocols.</p><p> 以下是您＆＃39; ll在互联网上浏览基于文本的协议的一些摇摇欲坠的论点。</p><p>    To be clear, historically computers had different bit widths ranging anywhere from 1 to 48 bits per byte between vendors and models. Even text itself was encoded differently on different computers from BCD, IBM, ISO, and 100s more. If you have any latest Linux or BSD computer, type  iconv -l to list some popular text encoding formats. ASCII and UTF-8/16/32 eventually fixed the encoding problems only recently in late 80s and early 90s. Text was never as portable as it&#39;s believed to be.</p><p>    要清楚，历史上计算机的比特宽度不同于供应商和模型之间每一个字节的1到48位。甚至文本本身在BCD，IBM，ISO和100S的不同计算机上被不同地编码。如果您有任何最新的Linux或BSD计算机，请键入iconv -l以列出一些流行的文本编码格式。 ASCII和UTF-8/16 / 32最终仅在80年代末期和90年代初期固定了编码问题。文本永远不会像＆＃39所说的那样便携。</p><p> It was only somewhere in early 90s did  ISO/IEC 2382-1:1993 came up suggesting power of 2 for measuring data widths -- fixing byte as 8 bits. And now nearly almost all CPUs in use today represent numbers in two&#39;s complement making binary messages a simpler alternative over text formats.</p><p> 它只在90年代初的某个地方ISO / IEC 2382-1：1993提出了2的力量，用于测量数据宽度 - 将字节固定为8位。现在几乎几乎所有的CPU都代表了两个＆＃39; s补充的数字，使二进制消息更简单的文本格式。</p><p>  Surely, it&#39;s not like you will open a terminal on your cell-phone and then type in  SIP like this to call your friend.</p><p>  当然，它＆＃39;不喜欢你将在手机上打开一个终端，然后在这样的SIP中键入，以便打电话给您的朋友。</p><p> INVITE sip:1001@10.0.0.1:2780;transport=udp SIP/2.0Via: SIP/2.0/UDP 10.0.1.12:5060;rportFrom: &lt;sip:2001@10.0.1.12&gt;;tag=a1b2c3d4e5To: &#34;1001&#34;&lt;sip:1001@10.0.1.12&gt;;tag=z1y2x3w4v5Contact: &lt;sip:2001@10.0.1.12&gt;Call-ID: OWYwZTg2NDRkOTZjYjc4NjUzYTE1ZGY5ZGY3ZGVkMmQ.CSeq: 102 INVITEUser-Agent: Asterisk PBXMax-Forwards: 70Allow: INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, SUBSCRIBE, NOTIFY, INFOSupported: replacesContent-Type: application/sdpContent-Length: 210.v=0o=root 6668 6669 IN IP4 10.0.0.2s=sessionc=IN IP4 10.0.0.2t=0 0m=audio 5004 RTP/AVP 8 101a=rtpmap:8 PCMA/8000a=rtpmap:101 telephone-event/8000a=fmtp:101 0-16a=ptime:20a=sendrecv</p><p> 邀请SIP：1001@10.0.0.1：2780;运输= UDP SIP / 2.0VIA：SIP / 2.0 / UDP 10.0.1.12:5060;＆lt; sip：2001@10.0.1.12&gt ;;标记= a1b2c3d4e5to：＆＃ 34; 1001＆＃34;＆lt; sip：1001@10.0.1.12&gt;标签= z1y2x3w4v5 contact：＆lt; sip：2001@10.0.1.12&gt;呼叫ID：owywztg2ndrkotzjyjc4nuzyte1zgy5zgy3zgvkmmq.cseq：102 InviteUser-Agent：Asterisk PBXMax-Forwards ：70Allow：邀请，ACK，取消，选项，再见，参考，订阅，通知，Infosupported：换乘文字类型：应用程序/ sdpContent-length：210.v = 0o = root 6668 6669在IP4 10.0.0.2s = sessionc =中IP4 10.0.0.2T = 0 0M =音频5004 RTP / AVP 8 101A = RTPMAP：8 PCMA / 8000A = RTPMAP：101电话 - 事件/ 8000A = FMTP：101 0-16A = PTime：20a = sendrecv</p><p> People don&#39;t even dial an actual number any more these days. It&#39;s usually a name searched in contacts followed by the &#34;Dial&#34; button. Any argument around this usually derives from the idea that it&#39;s as easy as opening a socket and typing out a command. It maybe true with FTP or  telnet, but not so much with HTTP or any modern day text based protocols.</p><p> 这些天，人们甚至拨打了实际数字。它通常是在联系人中搜索的名称，然后是＆＃34;拨号＆＃34;按钮。围绕这的任何论点通常都来自它的想法和＃39; s＆＃39; s易于打开套接字并键入命令。它可能是FTP或Telnet的真实，但与HTTP或任何现代文本的协议都不是如此。 </p><p>   Without a visualiser (even a  rudimentary one), the above message and the subsequent control-plane communication is not easy to debug. Sure you can view this on a terminal or edit this in your favourite text editor, but what next? How are you going to feed this into the call controller machinery without extensive debug openings into the state machine library?</p><p>如果没有视觉is（甚至是基本的一个），上述消息和随后的控制平面通信不容易调试。确保您可以在终端上查看此终端或在您喜欢的文本编辑器中编辑此内容，但下一步是什么？您将如何将其送入呼叫控制器机器，而在状态机库中没有广泛的调试开口？</p><p>  struct ntp_ts { uint32_t secs; uint32_t frac;};struct ntp_packet { unsigned int li: 2; /* Leap Indicator */ unsigned int vn: 3; /* Version number of the protocol */ unsigned int mode: 3; /* Client or server */ uint8_t stratum; /* Stratum level of the local clock */ uint8_t poll; /* Maximum interval between successive messages */ uint8_t precision; /* Precision of the local clock */ uint32_t root_delay; /* Total round trip delay time */ uint32_t root_dispersion; /* Maximum error allowed from primary clock source */ uint32_t ref_id; /* Reference clock identifier */ struct ntp_ts ref_ts; /* Reference time-stamp */ struct ntp_ts org_ts; /* Originate time-stamp */ struct ntp_ts rx_ts; /* Received time-stamp seconds */ struct ntp_ts tx_ts; /* Important field for client: Transmit time-stamp */} __attribute__((packed));</p><p>  struct ntp_ts {uint32_t秒; UINT32_T FRAC;}; struct ntp_packet {unsigned int li：2; / * LEAP指示灯* / unsigned int VN：3; / *协议的版本号* / unsigned int模式：3; / *客户端或服务器* / uint8_t stratum; / *本地时钟的地层水平* / UINT8_T民意调查; / *连续消息之间的最大间隔* / uint8_t精度; / *本地时钟* / uint32_t root_delay的精度; / *总往返延迟时间* / uint32_t root_dispersion; / *主时钟源允许的最大误差* / uint32_t ref_id; / *参考时钟标识符* / struct ntp_ts ref_ts; / *参考时间戳* / struct ntp_ts org_ts; / *来源时间戳* / struct ntp_ts rx_ts; / *收到的时间戳秒* / struct ntp_ts tx_ts; / *客户的重要领域：传输时间戳* /} __Attribute __（（包装））;</p><p> It is as simple as dumping  struct ntp_packet on wire and reading it off it -- no parsing involved except for calling  ntohX()/ htonX() on all fields except  li,  vn and  mode. But with SIP/HTTP, a simple line like  Content-Length: 300 will require a good bit of string parsing, manipulation, etc.</p><p> 它与在线上转储结构NTP_Packet一样简单，并将其读取它 - 没有解析涉及的解析，除了除LI，VN和Mode之外的所有字段上调用ntohx（）/ htonx（）。但是使用SIP / HTTP，一种简单的线，如内容长度：300将需要一个很好的字符串解析，操作等。</p><p> Do you think JSON/XML would look nicer? If a parser was to be written that parsed NTP over JSON using DOM or Stream parser, it won&#39;t be apparent what is being parsed by just looking at the source code. Now of course you can add a few extra layers on top where there is some kind of style sheet or meta XML that is parsed during build that gives you a  class NTPPacket with several  get/ set functions and also a cute looking serializer function or perhaps a class too. Parsing now is no more a  O(1) problem but a complex  O(wtf) problem with equally complex memory usage. But because that equation can somehow be expressed in terms of  n, people will have cartoonish light bulb moment, concluding that the said parsing algorithm is  linearly scalable. Since hardware is also cheap, it&#39;s easier to add more hardware to handle more messages, so it&#39;s a matter of client side economics and that there&#39;s nothing to worry about code-readability and long term maintainability. Any attempt to use  struct again will be branded backward thinking or a futile attempt at premature optimisation.</p><p> 你认为JSON / XML看起来更好吗？如果要编写解析器，请使用DOM或Stream Parser解析NTP，它赢得了＆＃39; t是显而易见的只是通过查看源代码解析的内容。现在当然，您可以在顶部添加一些额外的图层，其中有一些类型的样式表或Meta XML，在构建过程中解析，为您提供了一个带有多个GET / SET功能的类NTPPacket，也可以是可爱的序列化函数或者也许是一个课程也是如此。解析现在不再是O（1）问题，而是一个复杂的O（WTF）问题，具有同样复杂的内存使用情况。但是因为在某些方程式中可以以某种方式表达，人们将有卡通灯泡时刻，得出结论，即所述解析算法是线性可扩展的。由于硬件也很便宜，它更容易添加更多硬件来处理更多消息，所以它＆＃39; SA问题的客户侧经济学和＃39;没有什么可担心的代码可读性和长期可维护性。任何尝试再次使用结构将被落后思考或在过早优化时进行徒劳的尝试。</p><p>  When people talk about extensibility, they often expect adding or removing fields at will. Probably, they&#39;ve never heard of  Tag-Length-Value technique or the modern day  CBOR. I mean sure, you can add a new  Content-Type: application/batmobile but if the other end doesn&#39;t recognise the value or even the entire field, it isn&#39;t so much useful anyway.</p><p>  当人们谈论可扩展性时，他们通常会期望随意添加或删除字段。可能，他们从未听说过标签长度 - 价值技术或现代CBOR。我的意思是，你可以添加一个新的内容类型：应用程序/ batmobile，但如果另一端没有识别值甚至整个字段，它无论如何都是非常有用的。</p><p>  How many HTTP/XML/JSON parsers out there recover from failed tokens and read the remaining contents? And how useful will that data be overall? Most popular parsers usually fail on the first error and report it. Protocols built on this usually send an error message back. So there&#39;s not much of error recovery either. Arguments around this usually suggests that somehow text protocols are resilient to 1 off errors and that the message as a whole is not corrupted. This argument is actually true for  syslog vs  journalctl but not so much in communication protocols.</p><p>  从失败的令牌中恢复了多少HTTP / XML / JSON解析器并读取剩余内容？数据总体如何有用？最流行的解析器通常在第一个错误上失败并报告。构建的协议通常会发送错误消息。所以那里的错误恢复并不多。围绕此争论通常表明，某种文本协议是有弹性的，并且整个消息不会破坏。对于syslog vs journalctl而言，此参数实际上是真的，但在通信协议中没有太多。</p><p>  This is not to say text protocols are wrong; they have a place. They are very useful in programming languages that cannot offset into a memory chunk directly without using  unholy,  bloated APIs. But using them in telecommunication systems which is predominantly machine-to-machine is just an overkill. Hardware is getting cheaper by the day and adding more memory and more CPUs to do a task will be economical. Nevertheless, binary protocols are both space and time efficient. They have less overhead in parsing/building and are slightly easier to maintain.</p><p>  这并不是说文本协议是错误的;他们有一个地方。它们在无法直接抵消存储器块的编程语言中非常有用，而不使用unholy臃肿的apis。但在主要是机器到机器的电信系统中使用它们只是矫枉过正。硬件当天越来越便宜，并添加更多内存和更多CPU来完成任务将是经济的。然而，二进制协议是空间和时间效率。它们在解析/建筑物中具有较少的开销，并且稍微更容易维护。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://unmdplyr-new.bearblog.dev/a-case-against-text-protocols/">https://unmdplyr-new.bearblog.dev/a-case-against-text-protocols/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/协议/">#协议</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/text/">#text</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>