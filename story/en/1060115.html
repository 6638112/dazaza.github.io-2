<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>MAL  - 制作一个LISP Mal – Make a Lisp</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Mal – Make a Lisp<br/>MAL  - 制作一个LISP </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-26 10:26:11</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/e5588f7b88756aef0d3a734b39728542.png"><img src="http://img2.diglog.com/img/2021/4/e5588f7b88756aef0d3a734b39728542.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Each implementation of mal is separated into11 incremental, self-contained (and testable) steps that demonstratecore concepts of Lisp. The last step is capable of self-hosting(running the mal implementation of mal). See the  make-a-lisp processguide.</p><p>每次实施MAL都分开了11个增量，独立（和可测试的）步骤，该步骤规范了LISP的概念。最后一步能够自托管（运行MAL的MAL实现）。请参阅Make-A-Lisp ProcessGuide。</p><p>   Each make-a-lisp step has an associated architectural diagram. That elementsthat are new for that step are highlighted in red.Here is the final diagram for  step A:</p><p>   每个make-a-lisp步骤都有一个相关的架构图。元素突出显示该步骤的新功能是Red.re是步骤a的最终图：</p><p>  If you are interested in creating a mal implementation (or justinterested in using mal for something), please drop by the #malchannel on freenode. In addition to the  make-a-lisp processguide there is also a  mal/make-a-lispFAQ where I attempt to answer some common questions.</p><p>  如果您有兴趣创建MAL实现（或在使用MAR中的内容中刚刚入口），请在Freenode上删除#malchannel。除了Make-A-Lisp ProcessGuide还有一个Mal / Make-A-Lispfaq，我试图回答一些常见问题。</p><p>    Mal was presented publicly for the first time in a lightning talk atClojure West 2014 (unfortunately there is no video). Seeexamples/clojurewest2014.mal for the presentation that was given at theconference (yes, the presentation is a mal program).</p><p>    MAL在2014年闪电谈话中首次公开展示（不幸的是没有视频）。 Seexamples / ClojureWest2014.对于在Thecenference提供的演示文稿（是的，演示文稿是一个MAL程序）。</p><p> At Midwest.io 2015, Joel Martin gave a presentation on Mal titled&#34;Achievement Unlocked: A Better Path to Language Learning&#34;. Video, Slides.</p><p> 在2015年中西欧，Joel Martin在标题为＆＃34的Mal;成就解锁的展示：更好的语言学习道路和＃34;视频，幻灯片。</p><p> More recently Joel gave a presentation on &#34;Make Your Own Lisp Interpreterin 10 Incremental Steps&#34; at LambdaConf 2016: Part 1, Part 2, Part 3, Part 4, Slides.</p><p> 最近的乔尔更加努力给出＆＃34;让自己的LISP译员10个增量步骤＆＃34;在Lambdaconf 2016：第1部分，第2部分，第3部分，第4部分，幻灯片。</p><p>  The simplest way to run any given implementation is to use docker.Every implementation has a docker image pre-built with languagedependencies installed. You can launch the REPL using a convenienttarget in the top level Makefile (where IMPL is the implementationdirectory name and stepX is the step to run):</p><p>  运行任何给定实现的最简单方法是使用Docker.every实现使用安装了LobsicigeNepyencies预构建的Docker映像。您可以使用顶级Makefile中使用方便机构启动REPT（其中ichl是实现指向漫步名称和stepx是运行的步骤）： </p><p>       by vi - using  Pest grammar, not using typical Mal infrastructure (cargo-ized steps and built-in converted tests).</p><p>通过VI  - 使用害虫语法，而不是使用典型的MAL基础设施（货物-IZED步骤和内置转换测试）。</p><p>  malc - Mal (Make A Lisp) compiler. Compiles a Mal program to LLVM assembly language, then binary.</p><p>  MALC  -  MAL（制作一个LISP）编译器。将MAL程序编译为LLVM汇编语言，然后是二进制文件。</p><p> malcc - malcc is an incremental compiler implementation for the Mal language. It uses the Tiny C Compiler as the compiler backend and has full support for the Mal language, including macros, tail-call elimination, and even run-time eval.  &#34;I Built a Lisp Compiler&#34; post about the process.</p><p> Malcc  -  Malcc是MAL语言的增量编译器实现。它使用Tiny C编译器作为编译器后端，并完全支持MAL语言，包括宏，尾呼救，甚至运行时eMP。 ＆＃34;我建造了一个lisp编译器＆＃34;帖子关于这个过程。</p><p>   The Ada implementation was developed with GNAT 4.9 on debian. It alsocompiles unchanged on windows if you have windows versions of git,GNAT and (optionally) make. There are no external dependencies(readline not implemented).</p><p>   ADA实施是在Debian上的GNAT 4.9开发的。如果您有Windows版本的Git，GNAT和（可选）制作，则它在Windows上不变。没有外部依赖项（未实现读数）。</p><p>   The second Ada implementation was developed with GNAT 8 and links withthe GNU readline library.</p><p>   第二个ADA实现是用GNAT 8开发的，与GNU Readline Library的链接。</p><p>        The BASIC implementation uses a preprocessor that can generate BASICcode that is compatible with both C64 BASIC (CBM v2) and QBasic. TheC64 mode has been tested with cbmbasic (the patched version iscurrently required to fix issues with line input) and the QBasic modehas been tested with  qb64.</p><p>        基本实现使用可以生成与C64基本（CBM V2）和QBASIC兼容的基本代码的预处理器。 THEC64模式已使用CBMBASIC进行测试（修复的修补版本需要使用行输入修复问题），并且使用QB64测试QBASIC MODEHAS。</p><p>            The C implementation of mal requires the following libraries (lib andheader packages): glib, libffi6, libgc, and either the libedit or GNU readlinelibrary.</p><p>            MAL的C实现需要以下库（lib和header软件包）：glib，libffi6，libgc，以及libedit或gnu readlinelibrary。 </p><p>   The C++ implementation of mal requires g++-4.9 or clang++-3.5 anda readline compatible library to build. See the  cpp/README.md formore details:</p><p>MAL的C ++实现需要G ++  -  4.9或Clang ++  -  3.5和A Readline兼容库来构建。查看CPP / README.MD Formore详细信息：</p><p>   The C# implementation of mal has been tested on Linux using the MonoC# compiler (mcs) and the Mono runtime (version 2.10.8.1). Both arerequired to build and run the C# implementation.</p><p>   使用MONOC＃编译器（MCS）和MONO运行时（版本2.10.8.1版本）在Linux上测试了MAL的C＃实现。两个都是为了构建和运行C＃实现。</p><p>      For the most part the Clojure implementation requires Clojure 1.5,however, to pass all tests, Clojure 1.8.0-RC4 is required.</p><p>      在大多数情况下，Clojure实现需要Clojure 1.5，但是，通过所有测试，需要Clojure 1.8.0-RC4。</p><p>     The implementation has been tested with SBCL, CCL, CMUCL, GNU CLISP, ECL andAllegro CL on Ubuntu 16.04 and Ubuntu 12.04, seethe  README for more details. Provided you have thedependencies mentioned installed, do the following to run the implementation</p><p>     在Ubuntu 16.04和Ubuntu 12.04上，使用SBCL，CCL，CMUCL，GNU CLISP，ECL和Allegro CL进行了测试。更多细节，Seethe Readme。如果您已安装了绑定，则执行以下操作以运行执行</p><p>      The D implementation of mal was tested with GDC 4.8. It requires the GNUreadline library.</p><p>      使用GDC 4.8测试MAL的D实施。它需要GNUreadline库。</p><p>      The Emacs Lisp implementation of mal has been tested with Emacs 24.3and 24.5. While there is very basic readline editing ( &lt;backspace&gt;and  C-d work,  C-c cancels the process), it is recommended to use rlwrap.</p><p>      EMACS LISP MAL的实施已通过Emacs 24.3和24.5进行了测试。虽然存在非常基本的readline编辑（＆lt; backspace＆gt;和c-d工作，c-d取消该过程），建议使用rlwrap。</p><p> cd impls/elispemacs -Q --batch --load stepX_YYY.el# with full readline supportrlwrap emacs -Q --batch --load stepX_YYY.el</p><p> CD iclims / ELISPEMACS -Q --batch -load Stepx_yyy.el＃与完整readline supportrlwrap emacs -q  - 托 -  --load stepx_yyy.el </p><p>           The ES6 / ECMAScript 2015 implementation uses the babel compiler to generate ES5 compatibleJavaScript. The generated code has been tested with Node 0.12.4.</p><p>ES6 / ECMAScript 2015实现使用Babel编译器来生成ES5兼容性javascript。生成的代码已使用节点0.12.4进行测试。</p><p>   The F# implementation of mal has been tested on Linux using the MonoF# compiler (fsharpc) and the Mono runtime (version 3.12.1). The mono C#compiler (mcs) is also necessary to compile the readline dependency. All arerequired to build and run the F# implementation.</p><p>   使用Monof＃编译器（FSHARPC）和Mono Runtime（版本3.12.1）在Linux上测试了MAL的F＃实现。单声道C＃编译器（MCS）也需要编译读数依赖性。所有内容都是为了构建和运行F＃实现。</p><p>                   The Go implementation of mal requires that go is installed on on thepath. The implementation has been tested with Go 1.3.1.</p><p>                   MAL的GO实现需要转移到路径上。该实施已通过Go 1.3.1进行了测试。</p><p>   The Groovy implementation of mal requires Groovy to run and has beentested with Groovy 1.8.6.</p><p>   Groovy的Mal的实现需要Groovy运行，并且已经有了Groovy 1.8.6。</p><p>   The Haskell implementation requires the ghc compiler version 7.10.1 orlater and also the Haskell parsec and readline (or editline) packages.</p><p>   Haskell实现需要GHC编译器7.10.1 Orlater以及Haskell Parsec和Readline（或编辑线）软件包。</p><p>   The Haxe implementation of mal requires Haxe version 3.2 to compile.Four different Haxe targets are supported: Neko, Python, C++, andJavaScript.</p><p>   MAL的HAXE实现需要HAXE 3.2版编译。支持不同的HAXE目标：NEKO，PYTHON，C ++，ANDJAVASCRIPT。</p><p>                                The Lua implementation of mal has been tested with Lua 5.3.5 Theimplementation requires luarocks to be installed.</p><p>                                使用Lua 5.3.5的Lua实施MAL的实现需要安装Luocks。 </p><p>   Running the mal implementation of mal involves running stepA of one ofthe other implementations and passing the mal step to run as a commandline argument.</p><p>运行MAL的MAL实现涉及运行其他实现之一的STEPA，并将MAL步骤作为CommandLine参数运行。</p><p>     The NASM implementation of mal is written for x86-64 Linux, and has been testedwith Linux 3.16.0-4-amd64 and NASM version 2.11.05.</p><p>     MAL的NASM实现是为X86-64 Linux编写的，并且已经测试过Linux 3.16.0-4-AMD64和NASM版本2.11.05。</p><p>      The Object Pascal implementation of mal has been built and tested onLinux using the Free Pascal compiler version 2.6.2 and 2.6.4.</p><p>      使用免费的Pascal Compiler版本2.6.2和2.6.4，已经建立和测试了MAL的对象Pascal实施。</p><p>   The Objective C implementation of mal has been built and tested onLinux using clang/LLVM 3.6. It has also been built and tested on OSX using XCode 7.</p><p>   使用Clang / LLVM 3.6，已建立和测试MAL的目标C实现。它也使用Xcode 7在OSX上构建和测试。</p><p>     The MatLab implementation has been tested with GNU Octave 4.2.1.It has also been tested with MATLAB version R2014a on Linux. Note thatMATLAB is a commercial product.</p><p>     MATLAB实现已经使用GNU Octave 4.2.1进行了测试。它也在Linux上使用Matlab版R2014A进行了测试。请注意，据此是商业产品。</p><p> cd impls/matlab./stepX_YYYoctave -q --no-gui --no-history --eval &#34;stepX_YYY();quit;&#34;matlab -nodisplay -nosplash -nodesktop -nojvm -r &#34;stepX_YYY();quit;&#34; # OR with command line argumentsoctave -q --no-gui --no-history --eval &#34;stepX_YYY(&#39;arg1&#39;,&#39;arg2&#39;);quit;&#34;matlab -nodisplay -nosplash -nodesktop -nojvm -r &#34;stepX_YYY(&#39;arg1&#39;,&#39;arg2&#39;);quit;&#34;</p><p> CD iclows / matlab。/ stepx_yyyoctave -q --no-gui --no-hardent --eval＆＃34; stepx_yyy（）; quit;＆＃34; matlab -nodisplay --nosplash -nodektop -nojvm -r＆＃34 ; stepx_yyy（）; quit;＆＃34; ＃或使用命令行argumentsoctave -q  -  n  -  no-gui --no-hardent  -  verg＆＃34; stepx_yyy（＆＃39; arg1＆＃39;＆＃39; arg2＆＃39;）; z. 34; matlab -nodisplay --nosplash -nodektop -nojvm -r＆＃34; stepx_yyy（＆＃39; arg1＆＃39;＆＃39; arg2＆＃39; arg2＆＃39;）;＆＃34;</p><p>  miniMAL is small Lisp interpreterimplemented in less than 1024 bytes of JavaScript. To run the miniMALimplementation of mal you need to download/install the miniMALinterpreter (which requires Node.js).</p><p>  最小的LISP在少于1024个字节的JavaScript中诠释仪表层。要运行MAL的最小值，您需要下载/安装最小interpreter（这需要node.js）。 </p><p> cd impls/miniMAL# Download miniMAL and dependenciesnpm installexport PATH=`pwd`/node_modules/minimal-lisp/:$PATH# Now run mal implementation in miniMALminiMAL ./stepX_YYY</p><p>CD iclims / minimal＃下载最小和依赖关系，installexport路径=`pwd` / node_modules / minimal-lisp /：$ path＃现在在Minimalminal中运行MAL实现./stepx_yyy</p><p>                  The PL/pgSQL implementation of mal requires a running PostgreSQL server(the &#34;kanaka/mal-test-plpgsql&#34; docker image automatically startsa PostgreSQL server). The implementation connects to the PostgreSQL serverand create a database named &#34;mal&#34; to store tables and storedprocedures. The wrapper script uses the psql command to connect to theserver and defaults to the user &#34;postgres&#34; but this can be overriddenwith the PSQL_USER environment variable. A password can be specifiedusing the PGPASSWORD environment variable. The implementation has beentested with PostgreSQL 9.4.</p><p>                  MAL的PL / PGSQL实现需要运行的PostgreSQL服务器（＆＃34; kanaka / mal-test-plpgsql＆＃34; Docker Image自动启动PostgreSQL Server）。该实现连接到PostgreSQL Server和创建名为＆＃34; Mal＆＃34;存储表格和存储程序。包装脚本使用psql命令连接到子宫和默认为用户＆＃34; postgres＆＃34;但这可以覆盖PSQL_USER环境变量。可以指定密码pgpassword环境变量。在PostgreSQL 9.4中已经存在了实施。</p><p>   The PL/SQL implementation of mal requires a running Oracle DBserver (the &#34;kanaka/mal-test-plsql&#34; docker image automaticallystarts an Oracle Express server). The implementation connects to theOracle server to create types, tables and stored procedures. Thedefault SQL*Plus logon value (username/password@connect_identifier) is&#34;system/oracle&#34; but this can be overridden with the ORACLE_LOGONenvironment variable. The implementation has been tested with OracleExpress Edition 11g Release 2. Note that any SQL*Plus connectionwarnings (user password expiration, etc) will interfere with theability of the wrapper script to communicate with the DB.</p><p>   MAL的PL / SQL实现需要运行的Oracle DBServer（＆＃34; kanaka / mal-test-plsql＆＃34; docker映像自动启动Oracle Express Server）。该实现连接到Theoracle服务器以创建类型，表和存储过程。 thedefault sql * plus登录值（用户名/ password @ connect_identifier）是＆＃34;系统/ oracle＆＃34;但这可以通过Oracle_LogonEnvironment变量覆盖。使用OracleExpress Edition 11G版本2.注意，任何SQL * Plus ConnectionWarnings（用户密码到期等）都会干扰包装脚本的戏剧与DB通信。</p><p>   The PostScript implementation of mal requires Ghostscript to run. Ithas been tested with Ghostscript 9.10.</p><p>   MAL的PostScript实施需要GhostScript运行。伊萨已经用ghostscript 9.10进行了测试。</p><p>   The PowerShell implementation of mal requires the PowerShell scriptlanguage. It has been tested with PowerShell 6.0.0 Alpha 9 on Linux.</p><p>   PowerShell执行MAL需要PowerShell ScriptLanguage。它已经在Linux上使用PowerShell 6.0.0 Alpha 9进行了测试。</p><p>   The Prolog implementation uses some constructs specific to SWI-Prolog,includes readline support and has been tested on Debian GNU/Linux withversion 8.2.1.</p><p>   Prolog实现使用特定于SWI-prolog的构造，包括读线路支持，并已在Debian GNU / Linux中进行测试8.2.1。</p><p>     The second Python implementation makes heavy use of type annotations and uses the Arpeggio parser library.</p><p>     第二个Python实现批次使用类型注释并使用Arpeggio Parser库。 </p><p>                       The Scheme implementation of mal has been tested with Chibi-Scheme0.7.3, Kawa 2.4, Gauche 0.9.5, CHICKEN 4.11.0, Sagittarius 0.8.3,Cyclone 0.6.3 (Git version) and Foment 0.4 (Git version). You shouldbe able to get it running on other conforming R7RS implementationsafter figuring out how libraries are loaded and adjusting the Makefile and  run script accordingly.</p><p>该方案实施MAL已用Chibi-scheme0.7.3，Kawa 2.4，Gauche 0.9.5，鸡肉4.11.0，射手座0.8.3，旋风0.6.3（Git版）和Foment 0.4（Git版本）。您应该能够将其运行在其他符合R7RS实现中，以确定如何加载库和调整Makefile并相应地运行脚本。</p><p> cd impls/schememake symlinks# chibischeme_MODE=chibi ./run# kawamake kawascheme_MODE=kawa ./run# gauchescheme_MODE=gauche ./run# chickenmake chickenscheme_MODE=chicken ./run# sagittariusscheme_MODE=sagittarius ./run# cyclonemake cyclonescheme_MODE=cyclone ./run# fomentscheme_MODE=foment ./run</p><p> CD iclims / schememake symlinks＃chibischeme_mode = chibi ./run# kawamake kawascheme_mode = kawa ./run# gauchescheme_mode = gauche ./run# chickenmake chickenscheme_mode = chicken ./run# sagittariusscheme_mode = sagittarius ./run# cyclonemake cyclonescheme_mode = cyclone ./run ＃fomentscheme_mode = foment ./run</p><p>     The Swift implementation of mal requires the Swift 2.0 compiler (XCode7.0) to build. Older versions will not work due to changes in thelanguage and standard library.</p><p>     SWIFT的MAR需要SWIFT 2.0编译器（Xcode7.0）来构建。由于中风和标准库的变化，较旧版本无法正常工作。</p><p>   The Swift 3 implementation of mal requires the Swift 3.0 compiler. Ithas been tested with Swift 3 Preview 3.</p><p>   SWIFT 3 MAL的实施需要SWIFT 3.0编译器。伊萨已经用Swift 3预览3进行了测试。</p><p>   The Swift 4 implementation of mal requires the Swift 4.0 compiler. Ithas been tested with Swift 4.2.3 release.</p><p>   SWIFT 4 MAR的实施需要SWIFT 4.0编译器。伊萨已经用Swift 4.2.3发布进行了测试。</p><p>   The Swift 5 implementation of mal requires the Swift 5.0 compiler. Ithas been tested with Swift 5.1.1 release.</p><p>   SWIFT 5 MAL的实施需要SWIFT 5.0编译器。 ithas通过swift 5.1.1发布进行了测试。</p><p>   The Tcl implementation of mal requires Tcl 8.6 to run. For readline lineediting support, install tclreadline.</p><p>   MAL的TCL实施需要TCL 8.6运行。对于readline Lineed支持，请安装TClreadline。 </p><p>   The TypeScript implementation of mal requires the TypeScript 2.2 compiler.It has been tested with Node.js v6.</p><p>MAL的TypeScript实现需要使用Node.js v6测试Ringscript 2.2 Compiler.it。</p><p>   The Vala implementation of mal has been tested with the Vala 0.40.8compiler. You will need to install  valac and  libreadline-dev orequivalent.</p><p>   MAL的VALA实施已通过VALA 0.40.8计量器进行测试。您需要安装Valac和LibreaDline-Dev Orequivalent。</p><p>         The VB.NET implementation of mal has been tested on Linux using the MonoVB compiler (vbnc) and the Mono runtime (version 2.10.8.1). Both arerequired to build and run the VB.NET implementation.</p><p>         使用MONOVB编译器（VBNC）和MONO运行时（版本为2.10.8.1），在Linux上测试了MAL的VB.NET实现。两个都是为了构建和运行VB.NET实现。</p><p>   The WebAssembly implementation is written in Wam (WebAssembly Macro language) andruns under several different non-web embeddings (runtimes): node, wasmtime, wasmer, lucet, wax, wace, warpy.</p><p>   Webassembly实现是用WAM（Webassemblymbly宏语言）的andruns编写的，在几个不同的非网络嵌入式（运行时）：节点，Wasmtime，Waser，LuceT，Wax，WACE，Warpy。</p><p> cd impls/wasm# nodemake wasm_MODE=node./run.js ./stepX_YYY.wasm# wasmtimemake wasm_MODE=wasmtimewasmtime --dir=./ --dir=../ --dir=/ ./stepX_YYY.wasm# wasmermake wasm_MODE=wasmerwasmer run --dir=./ --dir=../ --dir=/ ./stepX_YYY.wasm# lucetmake wasm_MODE=lucetlucet-wasi --dir=./:./ --dir=../:../ --dir=/:/ ./stepX_YYY.so# waxmake wasm_MODE=waxwax ./stepX_YYY.wasm# wacemake wasm_MODE=wace_libcwace ./stepX_YYY.wasm# warpymake wasm_MODE=warpywarpy --argv --memory-pages 256 ./stepX_YYY.wasm</p><p> CD iclims / wasm＃nodemake wasm_mode = node。/ run.js ./stepx_yyy.wasm# wasmtimemake wasm_mode = wasmtimewasmtime --dir =。/ --dir =。/ --dir = / ./stepx_yyy.wasm# wasmermake wasm_mode = wasmerwasmer运行--dir =。/ --dir =。/ --dir = / ./stepx_yyy.wasm# lucetmake wasm_mode = lucetlucet-wasi --dir =。/：./ --dir = .. /： ../ --dir = /：/ ./stepx_yyy.so# waxmake wasm_mode = waxwax ./stepx_yyy.wasm# wacemake wasm_mode = wace_libcwace ./stepx_yyy.wasm# warpypake wasm_mode = warpywarpy --argv --memory-pages 256。 /stepx_yyy.wasm.wasm.</p><p>  The XSLT implementation of mal is written with XSLT 3 and tested on Saxon 9.9.1.6 Home Edition.</p><p>  MAL的XSLT实现是用XSLT 3编写的，并在Saxon 9.9.1.6 Home Edition上进行测试。</p><p>            The top level Makefile has a number of useful targets to assist withimplementation development and testing. The  help target providesa list of the targets and options:</p><p>            顶级Makefile拥有许多有用的目标，可以帮助实现开发和测试。帮助目标提供目标和选项列表： </p><p>   The are almost 800 generic functional tests (for all implementations)in the  tests/ directory. Each step has a corresponding test filecontaining tests specific to that step. The  runtest.py test harnesslaunches a Mal step implementation and then feeds the tests one ata time to the implementation and compares the output/return value tothe expected output/return value.</p><p>Tests /目录中的几乎是800个通用功能测试（对于所有实现）。每个步骤都有一个特定于该步骤的相应测试杂交测试。 runtest.py test harnesslaunches一个mal步骤实现，然后将测试一个ATA时间馈送到实现，并比较了预期输出/返回值的输出/返回值。</p><p>          To run the functional tests in self-hosted mode, you specify  malas the test implementation and use the  MAL_IMPL make variableto change the underlying host language (default is JavaScript):</p><p>          要在自托管模式下运行功能测试，请指定MALAS测试实现并使用MAL_IMPL MARE MARE更改底层主机语言（默认为JavaScript）：</p><p>       To start the REPL of the self-hosted implementation, specify  mal as theREPL implementation and use the  MAL_IMPL make variable to change theunderlying host language (default is JavaScript):</p><p>       要启动自托管实现的求建，请指定MAL，因此执行并使用MAL_IMPL使变量更改underwing host语言（默认为javascript）：</p><p>   Warning: These performance tests are neither statistically valid norcomprehensive; runtime performance is a not a primary goal of mal. Ifyou draw any serious conclusions from these performance tests, thenplease contact me about some amazing oceanfront property in Kansasthat I&#39;m willing to sell you for cheap.</p><p>   警告：这些性能测试既不是统计上有效的;运行时性能不是MAL的主要目标。如果你从这些表演测试中得出任何认真的结论，那么请与我联系在堪萨斯那我愿意卖给你的一些惊人的海滨物业。</p><p>         Every implementation directory contains a Dockerfile to createa docker image containing all the dependencies for thatimplementation. In addition, the top-level Makefile contains supportfor running the tests target (and perf, stats, repl, etc) withina docker container for that implementation by passing  &#34;DOCKERIZE=1&#34;on the make command line. For example:</p><p>         每个实现目录都包含一个dockerfile到Cantea Docker映像，包含所有依赖性的overementation。此外，顶级Makefile包含通过通过＆＃34运行该实现的测试目标（和perf，stats，repl等）的支持，以便通过＆＃34; dockerize = 1＆＃34;在make命令行上。例如：</p><p>  Existing implementations already have docker images built and pushedto the docker registry. However, ifyou wish to build or rebuild a docker image locally, the toplevelMakefile provides a rule for building docker images:</p><p>  现有实现已经构建并推送了Docker注册表。但是，如果您希望在本地构建或重建Docker图像，TopleVelmakefile提供了构建Docker图像的规则：</p><p>   JVM-based language implementations (Groovy, Java, Clojure, Scala):you will probably need to run this command once manuallyfirst  make DOCKERIZE=1 &#34;repl^IMPL&#34; before you can run tests becauseruntime dependencies need to be downloaded to avoid the tests timingout. These dependencies are downloaded to dot-files in the /maldirectory so they will persist between runs.</p><p>   基于JVM的语言实现（Groovy，Java，Clojure，Scala）：您可能需要一次手动运行此命令，使Dockerize = 1＆＃34; Repl ^ impl＆＃34;在您可以运行测试之前，需要下载依赖的依赖项，以避免测试时序输出。这些依赖项将在/ maldirectory中下载到dot文件，以便它们将在运行之间持续存在。 </p><p>  Mal (make-a-lisp) is licensed under the MPL 2.0 (Mozilla PublicLicense 2.0). See LICENSE.txt for more details.</p><p>MAL（Make-A-Lisp）在MPL 2.0下获得许可（Mozilla Publiclicense 2.0）。 有关更多详细信息，请参阅License.txt。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/kanaka/mal">https://github.com/kanaka/mal</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/mal/">#mal</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/实现/">#实现</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>