<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Python中的交换案例等效是什么？ What Is the Switch-Case Equivalent in Python?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What Is the Switch-Case Equivalent in Python?<br/>Python中的交换案例等效是什么？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-04 05:26:04</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/9b5cdc184ef69f39458e662451cadb19.jpg"><img src="http://img2.diglog.com/img/2021/4/9b5cdc184ef69f39458e662451cadb19.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Historically, the Python syntax hasn&#39;t had a switch-case statement. In 2006  Guido van Rossum, the original author of Python,  proposed different alternatives for the switch-case syntax in PEP 3103 but they all seemed to have some problems and the idea didn&#39;t gain enough popular support. The proposal was therefore rejected. Python version 3.10 changes this.</p><p>从历史上看，Python语法Hasn＆＃39; t有一个切换案例语句。 2006年Guido Van Rossum是Python的原始作者，提出了PEP 3103中的交换案例语法的不同替代方案，但它们似乎都有一些问题，并且想法没有获得足够的流行支持。因此，提案被拒绝了。 Python版本3.10更改了此功能。</p><p> Pattern matching is the switch-case equivalent in Python 3.10 and newer. A pattern matching statement starts with the  match keyword, and it contains one or more  case blocks.</p><p> 模式匹配是Python 3.10和较新的交换案例等效。模式匹配语句从匹配关键字开始，它包含一个或多个案例块。</p><p>  It will take a long time until any library code can safely adapt this new functionality since Python 3.9 will reach its end of life  approximately in October 2025. Therefore I&#39;ve split this post into two parts, depending on which version you need to target. In the first part we&#39;ll go through the new pattern matching model, then I will show how to emulate switch-case in older versions.  Scroll down if you&#39;re only interested in the old method.</p><p>  由于Python 3.9将在2025年10月达到其生命结束以来，任何图书馆代码都可以安全地调整这种新功能，因此需要很长时间。因此，我将这篇文章分成了两部分，取决于您需要的哪个版本目标。在第一部分中我们＆＃39; ll通过新的模式匹配模型，然后我将展示如何在旧版本中模拟交换机。如果你＆＃39;唯一对旧方法感兴趣的话。</p><p>  Before going to the Python details let&#39;s start with another language that implements the switch-case statement, C++. The syntax is simple, you start a block with  switch, define conditions with  case, and exit from the conditions with  break, for example:</p><p>  在进入Python详细信息之前，让＆＃39; s从实现交换案例语句的另一种语言，c ++。语法很简单，您可以使用交换机启动一个块，使用案例定义条件，并从断裂中退出条件，例如：</p><p> switch(i) {  case  1: cout &lt;&lt;   &#34; First case &#34;;  break;  case  2: cout &lt;&lt;   &#34; Second case &#34;;  break;  default: cout &lt;&lt;   &#34; Didn&#39;t match a case &#34;;}</p><p> 开关（i）{壳体1：cout <cout＆lt; ＆＃34;第一次案例＆＃34 ;;休息;壳体2：COUT <＆lt;＆lt; ＆＃34;第二个案例＆＃34 ;;休息;默认值：cout <＆lt;＆lt; ＆＃34;不匹配案例＆＃34 ;;}</p><p> The above code uses the value of  i to decide what should be printed on the console. If there is no match then the default value will be printed. If the break statement is excluded then the execution would continue on the next line.</p><p> 上面的代码使用i的值来决定应在控制台上打印什么。如果没有匹配，则将打印默认值。如果排除Break语句，则执行将继续下一行。</p><p> switch(i) {  case  1: cout &lt;&lt;   &#34; First case &#34;;  case  2: cout &lt;&lt;   &#34; Second case &#34;;  default: cout &lt;&lt;   &#34; Didn&#39;t match a case &#34;;}</p><p> 开关（i）{壳体1：cout <cout＆lt; ＆＃34;第一次案例＆＃34 ;;壳体2：COUT <＆lt;＆lt; ＆＃34;第二个案例＆＃34 ;;默认值：cout <＆lt;＆lt; ＆＃34;不匹配案例＆＃34 ;;} </p><p> With an input value of 1 the code above would print out all cases. Typically you&#39;d want to have the break statements there, forgetting to add one can be a source for bugs in your code.</p><p>输入值为1的代码将打印出所有情况。通常，您希望在那里进行中断语句，忘记添加一个可以是代码中错误的源。</p><p>   As I already mentioned, from Python 3.10 onwards you can start using a feature called structural pattern matching. The full specification is available on  PEP 634, and a friendlier introduction can be found from  PEP 636. Here I&#39;m trying to give you a quick introduction to the concept.</p><p>   正如我已经提到的那样，从Python 3.10开始，您可以使用称为结构模式匹配的功能开始。 PEP 634上有完整规范，可以从PEP 636找到一个友好的介绍。在这里，我试图为您提供快速介绍该概念。</p><p> Pattern mathcing is not just your typical switch-case, but it&#39;s actually  much more powerful than that. However, you can use it just like a switch-case statement too, this is equivalent to the first C++ example:</p><p> 模式Mathcing不仅仅是你的典型交换机，但它实际上比这更强大。但是，您也可以像Switch-case语句一样使用它，这相当于第一个C ++示例：</p><p> match i: case  1:  print(  &#34; First case &#34;) case  2:  print(  &#34; Second case &#34;) case _:  print(  &#34; Didn &#39; t match a case &#34;)</p><p> 匹配i：案例1：打印（＆＃34;第一个案例＆＃34;）案例2：打印（＆＃34;第二案例和＃34;）案例_：打印（＆＃34; didn＆＃39; t匹配案例＆＃34;）</p><p> The main differences to C++ are that the keyword is  match instead of  switch, you don&#39;t need to use  break to prevent the code from continuing with the next case, and the default case is defined with an underscore, which will always match.</p><p> C ++的主要差异是关键字与交换机匹配而不是开关，您不需要使用break以防止代码继续下一个案例，并且默认情况会使用下划线定义，默认情况会始终匹配。</p><p>  In addition to matching  literal patterns such as string literals, number literals, boolean values or  None, you can create more complicated capture patterns. Your cases can also be lists or tuples, allowing you to match different combinations.</p><p>  除了匹配字符串文字，数字文字，布尔值等之外，您还可以创建更复杂的捕获模式。您的案例也可以列出或元组，允许您匹配不同的组合。</p><p> Let&#39;s say that you need to do web requests based on an input where you get the HTTP method, destination URL, and possible data. Your function needs to support  GET,  POST and  DELETE, and raise an error otherwise. The implementation with pattern matching and the  Requests HTTP library could look like this (if we forget the existence of  requests.request):</p><p> 假设您需要根据获取HTTP方法，目标URL和可能数据的输入，根据输入，您需要执行Web请求。您的功能需要支持Get，Post和Delete，并否则提出错误。具有模式匹配和请求HTTP库的实现可以如下所示（如果我们忘记了请求的存在.Request）： </p><p> import  requests def  do_request(method, url, data=None): match (method, data): case (  &#34; GET &#34;, None):  return requests.get(url) case (  &#34; POST &#34;, _):  return requests.post(url, data=data) case (  &#34; DELETE &#34;, None):  return requests.delete(url) case _:  raise ValueError(  &#34; Invalid arguments &#34;)</p><p>导入请求def do_request（方法，URL，data = none）：匹配（方法，数据）：案例（＆＃34; get＆＃34; none）：return请求。重点（url）案例（＆＃34;帖子＆＃34;，_）：返回请求.post（url，data = data）案例（＆＃34; delete＆＃34; none）：return请求.delete（url）案例_：提升valueerror（＆＃34 ;无效的参数＆＃34;）</p><p> The cases are matched based on the values within the tuple, so only the allowed argument combinations will be executed. If you attempt to add data to other methods than  POST, you will get a  ValueError.</p><p> 该案例基于元组内的值匹配，因此只有允许的参数组合将被执行。如果您尝试将数据添加到其他方法而不是POST，您将获得一个值。</p><p> The sequences can also vary in length. This is a dummy structure for a command line program that has different levels of help information, and two commands:</p><p> 序列的长度也可以变化。这是一个具有不同级别的帮助信息和两个命令的命令行程序的伪结构：</p><p> import  sysmain(): match sys.argv[ 1:]: case [  &#34; help &#34;]:  print(  &#34; Print general help for all available options &#34;) case [  &#34; help &#34;,   &#34; start &#34;]:  print(  &#34; Print detailed help for the start command &#34;) case [  &#34; help &#34;,   &#34; stop &#34;]:  print(  &#34; Print detailed help for the stop command &#34;) case [  &#34; help &#34;, command]:  print(f  &#34; No help entry for command: {command} &#34;) case [  &#34; start &#34;, *args]:  print(f  &#34; Run start command with: {args} &#34;) case [  &#34; stop &#34;, *args]:  print(f  &#34; Run stop command with: {args} &#34;) case []:  print(  &#34; No command defined! &#34;) case _:  print(  &#34; Invalid input &#34;) if __name__ ==   &#34; __main__ &#34;: main()</p><p> 导入sysmain（）：匹配sys.argv [1：]：案例[＆＃34;帮助＆＃34;]：打印（＆＃34;打印所有可用选项和＃34的一般帮助;）案例[＆＃34;帮助＆＃34 ;,＃34;开始＆＃34;]：打印（＆＃34;打印开始命令的详细帮助＆＃34;）案例[＆＃34;帮助＆＃34 ;,＃34;停止＆＃34;]：打印（＆＃34;打印stop命令＆＃34的详细帮助;）案例[＆＃34;帮助＆＃34;，命令]：打印（f＆＃34;没有帮助条目命令：{命令}＆＃34;）案例[＆＃34;开始＆＃34;，* args]：打印（f＆＃34;运行start命令：{args}＆＃34;）案例[＆＃34;停止＆＃34;，* args]：打印（f＆＃34;运行stop命令：{args}＆＃34;）案例[]：打印（＆＃34;没有命令定义！＆＃34;）案例_：打印（＆＃34;无效的输入＆＃34;）如果_name__ ==＆＃34; __main__＆＃34 ;: main（）</p><p> The  sys.argv variable contains the command line arguments for the program, and the first value is always the the name of the running script, so we use list slicing to drop that away and only use the remaining arguments.</p><p> sys.argv变量包含程序的命令行参数，第一个值始终是运行脚本的名称，因此我们使用列表切片来删除并仅使用剩余的参数。</p><p> If the input argument is  help, then the program will print a general help text that could show basic usage and available options. Then typing  help start would show more detailed information about the start functionality, and so on.</p><p> 如果输入参数是帮助，则程序将打印一个可以显示基本使用和可用选项的一般帮助文本。然后键入帮助启动将显示有关启动功能的更详细信息等。</p><p> The fourth case captures help with an unknown command. This matches a sequence of two elements where the first item is the string  &#34;help&#34;, and the second item is saved in a variable called  command. This really shows the power of pattern matching since you can also match the  structure of the input, not just  values.</p><p> 第四种案例捕获有关未知命令的帮助。这与第一项是字符串＆＃34的两个元素序列匹配;帮助＆＃34;，第二项保存在名为命令的变量中。这真的显示了模式匹配的力量，因为您还可以匹配输入的结构，而不仅仅是值。 </p><p> The  start and  stop cases show how to match a sequence of items using the  * operator. With sequence unpacking you can match zero or more items at any position of the sequence.  Only one item is allowed to use a star in the pattern.</p><p>启动和停止案例显示如何使用*运算符匹配一系列项目。序列打开包装您可以在序列的任何位置匹配零个或多个项目。只允许一个项目在图案中使用明星。</p><p>  If both  start and  stop called the same function, it would not make much sense to separate these to different cases. Case patterns can use  | as the OR operator to match many different values. The start and stop functionailty could be refactored to this:</p><p>  如果两个开始和停止称为相同的函数，将这些与不同的案例分开时，它不会很有意义。案例模式可以使用|作为或运算符匹配许多不同的值。启动和停止功能可以重新开始：</p><p> match sys.argv[ 1:]: ... case [(  &#34; start &#34; |   &#34; stop &#34;)  as command, *args]:  print(f  &#34; Run {command} command with: {args} &#34;) ...</p><p> 匹配sys.argv [1：]：......案例[（＆＃34; start＆＃34; |＆＃34; stop＆＃34;）作为命令，* args]：print（f＆＃34;运行{命令}命令：{args}＆＃34;）...</p><p> Here the first item in the list matches either  &#34;start&#34; or  &#34;stop&#34;, and then the rest of the command is captured as a sequence. The  as keyword stores the actual matched value as the  command variable so that we can use it later.</p><p> 这里列表中的第一个项目匹配＆＃34; start＆＃34;或＆＃34;停止＆＃34;，然后将其余的命令捕获为序列。 AS关键字将实际匹配的值存储为命令变量，以便我们稍后可以使用它。</p><p> This pattern has one restriction: the alternatives should bind the same variables. So you cannot have one side bind a value to  x , and then try to use  y on the other side like this:</p><p> 此模式具有一个限制：备选方案应绑定相同的变量。所以你不能有一个侧面将值绑定到x，然后尝试在另一侧使用y：</p><p>   The matcher is not limited to primitive types and strings, but it works with objects too. Consider this simple  User class that could be used in a web service:</p><p>   匹配器不限于原始类型和字符串，但它也适用于对象。考虑此简单的用户类，可用于Web服务：</p><p> from  dataclasses  import dataclass @dataclass class  User:  id:  int username:  str email:  str admin:  bool region:  str</p><p> 来自Dataclasses Import DataClass @DataClass类用户：ID：int用户名：str电子邮件：str admin：bool区域：str </p><p> You might want to handle admin users in a different way than non-admin users. Additionally, maybe EU residents need some special treatment:</p><p>您可能希望以不同的方式处理管理员用户而不是非管理员用户。此外，也许欧盟居民需要一些特殊的治疗方法：</p><p> match user: case User(admin=True):  print(  &#34; This is an admin user &#34;) case User(region=  &#34; EU &#34;):  print(  &#34; This is a customer in the EU &#34;) case User():  print(  &#34; This is a customer somewhere else &#34;) case _:  print(  &#34; Error: Not a user! &#34;)</p><p> 匹配用户：案例用户（admin = true）：打印（＆＃34;这是一个管理员用户＆＃34;）案例用户（eque =＆＃34;欧盟＆＃34;）：print（＆＃34;这个）是欧盟＆＃34;）案例user（）：打印（＆＃34;这是一个客户在其他地方＆＃34;）案例_：print（＆＃34;错误：不是用户！＆＃ 34;）</p><p> Even though the cases look like they are creating objects using constructors that is not the case. Pattern matching uses these constructor like definitions to find the correct match, any attribute that is left undefined will be handled as a wildcard.</p><p> 即使案例看起来像是使用不这样的构造函数创建对象。模式匹配使用这些构造函数，如定义，以查找正确的匹配，因此留下未定义的任何属性将作为通配符处理。</p><p> Therefore the first case will match for all users that are admins. The second case applies to users whose region is  &#34;EU&#34;, and the third one matches any remaining users. The last case is used when the object is not a user, but for example  None.</p><p> 因此，第一个案例将匹配管理员的所有用户。第二种案例适用于其区域为＆＃34;欧盟＆＃34;，第三个案例与剩下的任何用户匹配。当对象不是用户时，使用最后一个情况，但例如无。</p><p>  So far I&#39;ve been using literal values in the matching statements but wouldn&#39;t it be nicer to define them as constants?  This is where you need to be careful so that you don&#39;t introduce bugs in your code!</p><p>  到目前为止，我一直在匹配陈述中使用字面价值，但是将它们定义为常量，以＆＃39;它是更好的？这是你需要小心的地方，以便你不要在你的代码中引入错误！</p><p> If we continue with the  User class from the previous section we could think that it&#39;s cleaner to handle the EU special case with a constant so that we don&#39;t need to use hard-coded values everywhere:</p><p> 如果我们从上一部分继续使用用户类，我们可以认为它＆＃39; S Cleaner以常量处理欧盟特殊情况，以便我们无处不在地使用硬编码值：</p><p>  Here we get to the point of capturing variable values. Now, you would expect that a user who is in North America ( &#34;NA&#34;) would not match, and the code would say that the customer is somewhere else.  What actually happens is that the variable  REGION_EU will now contain the string  &#34;NA&#34; and the case will match!</p><p>  在这里，我们达到了捕获变量值的重点。现在，你会期望在北美（＆＃34; Na＆＃34;）的用户不匹配，而代码会说客户是其他地方。实际发生的是变量区域_eu现在将包含字符串＆＃34; na＆＃34;案件会匹配！ </p><p> This means that we can capture variables also from objects. So if we&#39;re only interested in the region of non-admin users we could use this kind of pattern:</p><p>这意味着我们也可以从对象捕获变量。所以，如果我们＆＃39;只有在非管理员用户的区域才能使用这种模式：</p><p> match user: case User(admin=False, region=region):  print(f  &#34; This is a customer in {region} &#34;) case User():  print(  &#34; This is an admin user &#34;) case _:  print(  &#34; Error: Not a user! &#34;)</p><p> 匹配user：案例用户（admin = false，区域=区域）：打印（F＆＃34;这是{Region}＆＃34;）案例用户（）：打印（＆＃34;这是一个admin用户＆＃34;）案例_：打印（＆＃34;错误：不是用户！＆＃34;）</p><p> But how can we use constants then? They need to be dotted names to prevent the matcher from overriding the values. One option is to use enumerations:</p><p> 但我们如何使用常量？他们需要是点缀的名称来防止匹配覆盖值。一个选项是使用枚举：</p><p> from  dataclasses  import dataclass from  enum  import Enum class  Region( str, Enum): AFRICA =   &#34; AF &#34; ASIA =   &#34; AS &#34; EUROPE =   &#34; EU &#34; NORTH_AMERICA =   &#34; NA &#34; OCEANIA =   &#34; OC &#34; SOUTH_AND_CENTRAL_AMERICA =   &#34; SA &#34; @dataclass class  User:  id:  int username:  str email:  str admin:  bool region: Region...match user: case User(admin=False, region=Region.EUROPE):  print(  &#34; European customer &#34;) case User(admin=False):  print(  &#34; Other customer &#34;) case User(admin=True):  print(  &#34; Admin user &#34;) case _:  print(  &#34; Error: Not a user! &#34;)</p><p> 来自Dataclasses Import DataClass from Enum Import Enum Class Region（STR，ENUM）：非洲=＆＃34; AF＆＃34;亚洲=＆＃34;和＃34;欧洲=＆＃34;欧盟＆＃34; North_america =＆＃34; na＆＃34;大洋洲=＆＃34; OC＆＃34; south_and_central_america =＆＃34; SA＆＃34; @dataClass类用户：ID：int用户名：str电子邮件：str admin：bool区域：区域...匹配用户：案例用户（admin = false，region = region.europe）：打印（＆＃34;欧洲客户＆＃ 34;）案例用户（admin = false）：打印（＆＃34;其他客户＆＃34;）案例用户（admin = true）：print（＆＃34; admin用户＆＃34;）案例_：print（ ＆＃34;错误：不是用户！＆＃34;）</p><p>  Now you would think that was all and there couldn&#39;t possibly be anything more to remember? Wrong! You can also include conditionals in the cases.</p><p>  现在你会认为这就是所有人，都有可能有更多的记忆吗？错误的！您还可以在案例中包含条件。</p><p> Let&#39;s continue with the user example a little further. This time we want to handle the case where two users are in the same region:</p><p> 让＆＃39;■稍微继续使用用户示例。这次我们要处理两个用户在同一区域的情况：</p><p> match users: case [User()  as u1, User()  as u2]  if u1.region == u2.region:  print(f  &#34; Received two users in the same region: {u1.region} &#34;) case [User(), User()]:  print(f  &#34; Received two users in different regions &#34;) case _:  print(  &#34; Received something else &#34;)</p><p> 匹配用户：案例[user（）作为u1，user（）作为u2]如果u1.region == u2.region：print（f＆＃34;在同一区域中收到的两个用户：{u1.region}＆＃34 ;）案例[user（），user（）]：打印（F＆＃34;在不同地区的两个用户接收到不同地区＆＃34;）案例_：打印（＆＃34;收到别的东西＆＃34;） </p><p> We can capture items in the patterns with the  as keyword. With the  if conditional the pattern will fully match only if the conditional expression also matches. If the part before  if matches, the  u1 and  u2 variables will be initialized before evaluating the condition. They will remain available in later steps too, so be aware that this has the potential to ovewrite things even if the condition itself wouldn&#39;t fully match due to the if-statement.</p><p>我们可以使用作为关键字的模式中的项目捕获。如果条件，则该模式才会完全匹配，仅当条件表达式也匹配时。如果之前的零件匹配，则在评估条件之前将初始化U1和U2变量。他们将在以后的步骤中仍然可用，因此请注意，即使条件本身不会由于IF-陈述而完全匹配，这也意识到这一点是Ove WOVEWRITE的东西。</p><p>  If your Python version does not support pattern matching, then you need to use an alternative method to mimic switch-case. There are basically two ways to do it, so let&#39;s see what they are.</p><p>  如果您的Python版本不支持模式匹配，则需要使用替代方法来模拟切换器。基本上有两种方法可以做到这一点，所以让＆＃39;看到它们是什么。</p><p>  The most basic and easy way to emulate a switch statement is to use plain if else statements. The equivalent of the first C++ example would look like this:</p><p>  最基本且简单的模拟Switch语句的方法是使用普通的陈述。相当于第一个C ++示例将如下所示：</p><p> def  print_case(value):  if value ==  1:  print(  &#34; First case &#34;)  elif value ==  2:  print(  &#34; Second case &#34;)  else:  print(  &#34; Didn &#39; t match a case &#34;)</p><p> def print_case（value）：如果值== 1：打印（＆＃34;第一个案例＆＃34;）Elif值== 2：打印（＆＃34;第二案例＆＃34;）else：print（＆＃ 34; DIDN＆＃39; t匹配案例＆＃34;）</p><p> The  value is compared against every option until a match is found or until the final else statement is reached.</p><p> 将该值与每个选项进行比较，直到找到匹配项或达到最终的else语句。</p><p> The code is quite easy to reason about but with lots of cases it can become difficult to manage. There are also many state comparisons that we need to write manually which can be error prone. However, this should probably be your choice for simple cases with only a few possible states. This is also what the  Python docs suggest as the substitute.</p><p> 代码很容易理解，但有很多情况，它可能变得难以管理。还有许多状态比较，我们需要手动编写，这可能会出错。但是，这应该是您选择只有几个可能的状态的简单案例。这也是Python文档作为替代品的内容。</p><p>  Another way to achieve similar results is to put callables inside a dictionary. This method is  also mentioned in the Python docs.</p><p>  实现类似结果的另一种方法是将胼callable放在字典中。该方法也在Python文档中提到。 </p><p> def  print_case(value): cases = {  1:  lambda:  print(  &#34; First case &#34;),  2:  lambda:  print(  &#34; Second case &#34;),  3:  lambda:  print(  &#34; Third case &#34;),  4:  lambda:  print(  &#34; Fourth case &#34;), } cases.get(value,  lambda:  print(  &#34; Didn &#39; t match a case &#34;))()</p><p>def print_case（value）：案例= {1：lambda：打印（＆＃34;第一个案例＆＃34;），2：lambda：print（＆＃34;第二案例＆＃34;），3：lambda：print （＆＃34;第三案和＃34;），4：lambda：print（＆＃34;第四个案例＆＃34;），}}}}}}}}}}}}}}}}}}}}}} subsice.get（价值，lambda：print（＆＃34; didn＆＃39 ; t匹配案例＆＃34;））（）</p><p> As you can see this can look a bit cleaner with more options as compared to the if-else statements.</p><p> 如您所见，与IF-ELSE语句相比，这可以看起来有点清洁器。</p><p> In this code each key in the dictionary contains a lambda function without parameters, which then calls the appropriate print function. Lambda functions are anonymous functions that can be stored in variables and then used just as normal functions.</p><p> 在此代码中，字典中的每个键都包含一个没有参数的Lambda函数，然后调用适当的打印功能。 lambda函数是可以存储在变量中的匿名函数，然后用作正常功能。</p><p> The correct function is fetched using the  get method from the dict and then it is called without arguments. The second argument of the get method is the default value which will print a message if a matching case was not found.</p><p> 使用来自dict的get方法获取正确的函数，然后在没有参数的情况下调用它。 Get方法的第二个参数是如果找不到匹配的情况，则将打印邮件的默认值。</p><p> Notice the parentheses at the end of the last line. That is the actual function call.</p><p> 请注意最后一行末尾的括号。这是实际的函数调用。</p><p>  def  print_case(value): cases = {  1:  lambda:  print(  &#34; First case &#34;),  2:  lambda:  print(  &#34; Second case &#34;),  3:  lambda:  print(  &#34; Third case &#34;),  4:  lambda:  print(  &#34; Fourth case &#34;), } cases[value]()</p><p>  def print_case（value）：案例= {1：lambda：打印（＆＃34;第一个案例＆＃34;），2：lambda：print（＆＃34;第二案例＆＃34;），3：lambda：print （＆＃34;第三案和＃34;），4：lambda：print（＆＃34;第四个案例＆＃34;），}}}}}}}}}案例[value]（）</p><p> If you try to call the  print_case function with an invalid value such as  5 the code will raise a  KeyError. This might be desired so that your program won&#39;t continue with an invalid input. Just be sure to handle the error elsewhere in your code.</p><p> 如果您尝试使用无效值调用print_case函数，例如5，则代码将升级键架。这可能是希望的，以便您的程序赢得＆＃39; t继续输入无效输入。只需务必在代码中的其他地方处理错误。 </p><p>   Let&#39;s change our example a bit. Now what if we wanted to create a function called  calculate that takes an operator and two operands, and returns the result of the calculation? We could implement it like this:</p><p>让＆＃39改变我们的示例。现在，如果我们想创建一个名为Calculate的函数，何时何地创建一个运算符和两个操作数，并返回计算结果？我们可以这样实施：</p><p> def  calculate(operator, x, y): cases = {   &#34; + &#34;:  lambda a, b: a + b,   &#34; - &#34;:  lambda a, b: a - b,   &#34; * &#34;:  lambda a, b: a * b,   &#34; / &#34;:  lambda a, b: a / b, }  return cases[operator](x, y)</p><p> def计算（运算符，x，y）：案例= {＆＃34; +＆＃34 ;: lambda a，b：a + b，＆＃34; - ＆＃34 ;: lambda a，b：a  -  b，＆＃34; *＆＃34 ;: lambda a，b：a * b，＆＃34; /＆＃34 ;: lambda a，b：a / b，}返回案例[运算符]（x，y）</p><p> Each of the lambda functions now has two arguments that are defined before the colon. The final function call then passes the  x and  y arguments to the selected lambda. Notice that the lambda functions don&#39;t contain the  return keyword.</p><p> 每个Lambda函数现在有两个在冒号之前定义的参数。然后，最终函数调用将x和y参数传递给所选的lambda。请注意，Lambda函数Don＆＃39; t包含return关键字。</p><p>     def  add(x, y):  return x + y def  subtract(x, y):  return x - y def  multiply(x, y):  return x * y def  divide(x, y):  return x / y def  calculate(operator, x, y): cases = {   &#34; + &#34;: add,   &#34; - &#34;: subtract,   &#34; * &#34;: multiply,   &#34; / &#34;: divide, }  return cases[operator](x, y)</p><p>     def添加（x，y）：返回x + y def减法（x，y）：返回x  -  y def乘以（x，y）：返回x * y def划分（x，y）：返回x / y def计算（运算符，x，y）：案例= {＆＃34; +＆＃34;：添加，＆＃34; - ＆＃34;：减去，＆＃34; *＆＃34 ;:乘法，＆＃34; /＆＃34 ;: divide，}返回案例[运算符]（x，y）</p><p> The results are still the same. This time we used normal named functions that are used as objects in the case lookup dict.</p><p> 结果仍然是相同的。这次我们使用正常的命名函数，该函数用作案例查找的对象。</p><p> If you&#39;re really worried about performance then you could move the dictionary generation outside of the function. Then it won&#39;t be regenerated each time  calculate is called. In practice there shouldn&#39;t be much difference.</p><p> 如果您＆＃39;重新担心性能，那么您可以在函数外移动字典生成。然后，每次调用计算时都会重新生成。在实践中，＆＃39; t很大差异。</p><p>  Pattern matching is a whole new beast to tackle, and it can be a little intimidating at first. Hopefully this post has shed some light on the topic, and you feel comfortable to learn more. If you need to target older Python versions, you can still use the alternatives that I described here in the end.</p><p>  模式匹配是一个全新的野兽来解决，并且起初可能有点恐吓。希望这篇文章在这个主题上揭示了一些亮点，而且你感到舒服地了解更多。如果您需要定位较旧的Python版本，您仍然可以使用我最后描述的替代方案。 </p><p>  What&#39;s new with PäksTech? Subscribe to receive occasional emails where I will sum up stuff that has happened at the blog and what may be coming next.</p><p>什么＆＃39;新的Päkstech新的？ 订阅接收偶尔的电子邮件，我将总结在博客中发生的东西，并且接下来可能会发生什么。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://pakstech.com/blog/python-switch-case/">https://pakstech.com/blog/python-switch-case/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/案例/">#案例</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/case/">#case</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>