<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>C ++ 11元组实现详细信息（2012） </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">C ++ 11元组实现详细信息（2012） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-06 20:23:48</div><div class="page_narrow text-break page_content"><p>Warning: Can only detect less than 5000 characters</p><p>非递归元组实现背后的基本思想是，元组元素存储在TupleLeaf基类中，但是递归实现使用深层次的类层次结构，而我们将使用多重继承。用伪代码：</p><p> 模板＆lt; typename T0，typename T1，...，typename Tn＆gt;类PseudoTuple：TupleLeaf＆lt; 0，T0＆gt;，TupleLeaf＆lt; 1，T1＆gt;，...，TupleLeaf＆lt; n，Tn＆gt; {...};</p><p> 每个叶子都有一个索引，因此即使每个基类所包含的类型相同，它们也都将是唯一的，因此我们可以使用简单的static_cast访问n元素：</p><p>    // TupleLeaftemplate＆lt; size_t I_，类型名称ValueType_，布尔值IsEmpty_ = is_empty＆lt; ValueType_＆gt; :: value＃if __has_feature（is_final）＆amp;＆amp; ！__ is_final（ValueType _）＃endif＆gt; class TupleLeaf;模板＆lt; size_t I，类型名ValueType，bool IsEmpty＆gt;内联void swap（TupleLeaf＆lt; I，ValueType，IsEmpty＆amp; a，TupleLeaf＆lt; I，ValueType，IsEmpty＆gt;＆amp; b）{swap（a.get（），b.get（））;}模板＆lt; size_t I_，类型名ValueType_，bool IsEmpty_＆gt; class TupleLeaf {ValueType_ value_;元宝叶运算符=（const TupleLeaf＆amp;）= delete; public：TupleLeaf（）：value_（）{static_assert（！is_reference＆lt; ValueType_＆gt; :: value，＆＃34;尝试默认在元组中构造引用元素＆＃34;）; } TupleLeaf（const TupleLeaf＆amp; t）：value_（t.get（））{static_assert（！is_rvalue_reference＆lt; ValueType_＆gt; :: value，＆＃34;无法复制带有右值引用成员的元组＆＃34;）； }模板＆lt; typename T，typename = typename enable_if＆lt; is_constructible＆lt; ValueType_，T＆gt; :: value＆gt; :: type＆gt;显式TupleLeaf（T＆amp; t）：value_（forward＆lt; T＆gt;（t））{static_assert（！is_reference＆lt; ValueType_＆gt; :: value ||（is_lvalue_reference＆lt; ValueType_＆gt; :: value＆amp;＆amp;（is_lvalue_reference＆lt; T＆gt; :: value || is_same＆lt; typename remove_reference＆lt; T＆gt; :: type，reference_wrapper＆lt; typename remove_reference＆lt; ValueType_＆gt; :: type＆gt;＆gt; :: value））||（is_rvalue_reference＆lt; ValueType_＆gt; :: value＆amp;＆amp ;! is_lvalue_reference＆lt; T＆gt; :: value），＆＃34;试图在具有rvalue＆＃34;的元组中构造引用元素。 }模板＆lt; typename T＆gt;显式TupleLeaf（const TupleLeaf＆lt; I_，T＆amp; t）：value_（t.get（））{} template＆lt; typename T＆gt;元宝叶运算符=（T＆amp; t）{value_ = forward T（t）;返回* this; } int swap（TupleLeaf＆amp; t）{migl2 :: detail :: swap（* this，t）;返回0; } ValueType_＆amp; get（）{返回value_; } const ValueType_＆amp; get（）const {return value_; }};</p><p> 在这里，我们声明了TupleLeaf模板，并在可以使用Empty Base Class Optimization时将IsEmpty值设置为true。这里需要一些技巧：如果实现支持最​​终类，那么我们必须检查ValueType_是否为最终类。由于我们不能将最终类作为子类，因此在这种情况下我们不能使用EBCO。</p><p>  通过交换包含的元素交换两个TupleLeafs。我们将从交换成员函数中使用它。</p><p>  适用于一般情况的TupleLeaf实现（无空基类优化）。我们将禁用正常的复制分配（第17行），因为我们将始终使用转发复制分配（第53-57行）。唯一有趣的是交换的返回类型（第59-62行）。通常，它应该是空的，但是稍后我们将使用模板包扩展从TupleImpl :: swap中调用此swap成员，并为此需要一个具有返回类型的函数。请参阅下面的吞咽功能。 </p><p>接下来，我们专门针对TupleLeaf进行使用空基类优化的情况，以免浪费空Tuple成员的空间：</p><p> // TupleLeaf专业化，以防我们可以使用空基类优化：template＆lt; size_t I_，typename ValueType_＆gt; class TupleLeaf＆lt; I_，ValueType_，true＆gt; ：私有ValueType_ {TupleLeaf＆amp;运算符=（const TupleLeaf＆amp;）= delete; public：TupleLeaf（）{} TupleLeaf（const TupleLeaf＆t）：ValueType_（t.get（））{static_assert（！is_rvalue_reference＆lt; ValueType_＆gt; :: value，＆＃34; Can不复制带有右值引用成员的元组＆＃34;）; }模板＆lt; typename T，typename = typename enable_if＆lt; is_constructible＆lt; ValueType_，T＆gt; :: value＆gt; :: type＆gt;显式TupleLeaf（T＆amp; t）：ValueType_（forward＆lt; T＆gt;（t））{}模板＆lt; typename T＆gt;显式TupleLeaf（const TupleLeaf＆lt; I_，T＆amp; t）：ValueType_（t.get（））{} template＆lt; typename T＆gt;元宝叶operator =（T＆amp; t）{ValueType _ :: operator =（forward＆lt; T＆gt;（t））;返回* this; } int swap（TupleLeaf＆amp; t）{migl2 :: detail :: swap（* this，t）;返回0; } ValueType_＆amp; get（）{return static_cast＆lt; ValueType_＆amp;＆gt;（* this）; } const ValueType_＆amp; get（）const {return static_cast＆lt; const ValueType_＆amp;＆gt;（* this）; }};</p><p>  我们需要TupleLeafs的索引和相应的类型。为了处理它们的耦合，我们将创建两个用于存储它们的帮助程序类以及在需要时创建它们的相应模板：</p><p> // TupleIndexestemplate＆lt; size_t ... Is_＆gt; struct TupleIndexes {}; template＆lt; size_t Start_，类型名称TupleIndexes_，size_t End_＆gt; struct MakeTupleIndexesImpl; template＆lt; size_t Start_，size_t ... ，TupleIndexes＆lt; Indexes _...＆gt;，End_＆gt; {typedef typename MakeTupleIndexesImpl＆lt; Start_ + 1，TupleIndexes＆lt; Indexes _...，Start_＆gt ;, End_＆gt; :: type type;};模板＆lt; size_t End_，size_t ... Indexes_＆gt;结构MakeTupleIndexesImpl＆lt; End_，TupleIndexes＆lt; Indexes_。 。＆gt;，End_＆gt; {typedef TupleIndexes＆lt; Indexes _...＆gt;类型；};模板＆lt; size_t End_，size_t Start_ = 0＆gt;结构MakeTupleIndexes {static_assert（Start_＆lt; = End_，＆＃34; MakeTupleIndexes：无效参数＆＃34;）； typedef typename MakeTupleIndexesImpl＆lt; Start_，TupleIndexes＆lt;＆gt ;, End_＆gt; :: type type;};</p><p> MakeTupleIndexes创建用于编码从Start_到End_的索引的类型，例如：TupleTypes＆lt; 0，1，2＆gt;。可能会更简单一些，但是我们将使用一个构造函数来扩展标准元组，该构造函数所使用的参数要少于实际的元组元素数量（默认情况下构造其余的），为此，我们需要能够从任意索引而不是0开始创建TupleIndexes。下面的MakeTupleTypes也是如此。这两个模板都使用帮助程序模板来逐步建立其值。最终结果是用于完整索引和类型的typedef。</p><p> 注意：自撰写本文以来，c ++ 14引入了std :: index_sequence，因为发现该概念在许多情况下都是有用的。序列生成的实现也可以被优化：代替上述线性递归，可以使用对数实现，或者序列生成甚至可以是编译器固有的。元组实现可以在此处更新为使用新的index_sequence。</p><p> // TupleTypestemplate＆lt; typename ... Ts_＆gt; struct TupleTypes {}; // TupleSizetemplate＆lt; typename T_＆gt; struct TupleSize：public tuple_size＆lt; T_＆gt; {}; template＆lt; typename T_＆gt; struct TupleSize＆lt; const T_＆gt; ：公共TupleSize＆lt; T_＆gt; {}; template＆lt; typename T_＆gt; struct TupleSize＆lt; volatile T_＆gt; ：公共TupleSize＆lt; T_＆gt; {}; template＆lt; typename T_＆gt; struct TupleSize＆lt; const volatile T_＆gt; ：公共TupleSize＆lt; T_＆gt; {};模板＆lt;类型名... Ts_＆gt;结构TupleSize＆lt; TupleTypes＆lt; Ts _...＆gt;＆gt; ：公共integer_constant＆lt; size_t，sizeof ...（Ts _）＆gt; {}; // Tupletemplate＆lt; typename ... Ts_＆gt; struct TupleSize＆lt; Tuple＆lt; Ts _...＆gt;的特殊化； ：公共integer_constant＆lt; size_t，sizeof ...（Ts _）＆gt; {}; </p><p>在这里，我们声明了特殊的类型持有者TupleTypes，然后可以使用sizeof ...运算符为其定义TupleSize。我们自己的Tuple的TupleSize使用TupleTypes。对于所有其他类型，我们都使用标准的tuple_size模板，因此我们的内部TupleSize也将适用于std :: tuple，std :: pair和std :: array。符合cv要求的类型将转发给不符合要求的TupleTypes的实现。</p><p> 类似地，我们的内部TupleElement是为TupleTypes和Tuple定义的，但是回退到其他类型的标准tuple_element上：</p><p> // TupleElementtemplate＆lt; size_t I_，类型名T_＆gt; class TupleElement：public tuple_element＆lt; I_，T_＆gt; {}; template＆lt; size_t I_＆gt; class TupleElement＆lt; I_，TupleTypes＆lt;＆gt; {public：static_assert（I _！= I _，＆＃34; tuple_element索引超出范围＆＃34;）;};模板＆lt;类型名H_，类型名... Ts_＆gt;类TupleElement＆lt; 0，TupleTypes＆lt; H_，Ts_。 。＆gt;＆gt; {public：typedef H_type；}；模板＆lt; size_t I_，typename H_，typename ... Ts_＆gt; class TupleElement＆lt; I_，TupleTypes＆lt; H_，Ts _...＆gt;＆gt; {public：typedef typename TupleElement＆lt; I-1，TupleTypes＆lt; Ts _...＆gt; :: type type;}; // Tupletemplate的特殊化＆lt; size_t I_，typename ... Ts_＆gt;类TupleElement＆lt; I_，Tuple＆lt; ; Ts _...＆gt;＆gt; {public：typedef typename TupleElement＆lt; I_，TupleTypes＆lt; Ts _...＆gt; :: type type;};模板＆lt; size_t I_，typename ... Ts_＆gt; class TupleElement＆lt; I_，const Tuple＆lt; Ts _... ＆gt;＆gt; {public：typedef typename add_const＆lt; typename TupleElement＆lt; I_，TupleTypes＆lt; Ts _...＆gt;＆gt; :: type＆gt; :: type type;};模板＆lt; size_t I_，typename ... Ts_＆gt; class TupleElement＆lt; I_，挥发性元组Ts _...＆gt; {public：typedef typename add_volatile＆lt; typename TupleElement＆lt; I_，TupleTypes＆lt; Ts _...＆gt; :: type＆gt; :: type type;};模板＆lt; size_t I_，typename ... Ts_＆gt; class TupleElement＆lt; I_， const volatile Tuple Ts _...＆gt; {public：typedef typename add_cv＆lt; typename TupleElement＆lt; I_，TupleTypes＆lt; Ts _...＆gt;＆gt; :: type＆gt; :: type type;}；</p><p> TupleElement是一个经典的递归模板。当我们减少索引时（在主模板中的I_，第19-23行），我们从列表的开头切掉了这些类型。停止条件是当我们达到I_ == 0（第13-17行）时。如果其余的TupleTypes在达到停止条件之前为空，则将通过static_assert发出错误信号（第7-11行）。最终结果（如果一切顺利的话）是与我们的TupleTypes中的I_元素相对应的typedef（TupleElement :: type）。我们最终的Tuple的专业化使用针对const和volatile限定符调整的TupleType。</p><p> 注意：可以通过让重载分辨率为我们找到正确的类型而不是上面介绍的线性递归来实现TupleElement。有关详细信息，请参阅其他有关元组的不错的博客文章。</p><p>  // MakeTupleTypestemplate＆lt; typename TupleTypes_，typename Tuple_，size_t Start_，size_t End_＆gt; struct MakeTupleTypesImpl; template＆lt; typename ... Types_，typename Tuple_，size_t Start_，size_t End_＆gt; struct MakeTupleTypesImpl＆lt; TupleTypes ...＆lt; Tuple_，Start_，End_＆gt; {typedef typename remove_reference＆lt; Tuple_＆gt; :: type TupleType; typedef typename MakeTupleTypesImpl＆lt; TupleTypes＆lt; Types _...，typename conditional＆lt; is_lvalue_reference＆lt; Tuple_＆gt; :: value，//如果tuple_是ref类型名，则附加ref TupleElement＆lt; Start_，TupleType＆gt; :: type＆amp; TupleElement＆lt; Start_，TupleType＆gt; :: type＆gt; :: type＆gt ;, Tuple_，Start_ + 1，End_＆gt; :: type type;};模板＆lt; typename ... Types_，typename Tuple_，size_t End_＆gt;结构MakeTupleTypesImpl＆lt; TupleTypes＆lt; Types _...＆gt;，Tuple_，End_，End_＆gt; {typedef TupleTypes＆lt; Types _...＆gt; type;};模板＆lt; typename Tuple_，size_t End_ = TupleSize＆lt; typename remove_reference＆lt; Tuple_＆gt; :: type＆gt; :: value，size_t Start_ = 0＆gt; struct MakeTupleTypes {static_assert（Start_＆lt; = End_，＆＃34; MakeTupleTypes：无效的参数＆＃34;）; typedef typename MakeTupleTypesImpl＆lt; TupleTypes＆lt;＆gt ;, Tuple_，Start_，End_＆gt; :: type type;};</p><p> MakeTupleTypes从[Start_ .. End_]范围内的Tuple_中提取类型，并将其存储在我们的TupleTypes类型中。元素类型由上面定义的TupleElement确定，并附加到临时列表中。由于std :: tuple_element（因此，我们的TupleElement）不适用于引用类型，因此我们将typedef用作Tuple_的引用剥离类型（第8行的TupleType），但是我们将结果类型从TupleElement转换为a如果原始Tuple_是lvalue_reference（此转换不会影响原元组中已经为引用类型的类型），则为reference。 </p><p>我们已经准备好将这些片段组装到我们内部的TupleImpl类中，该类将成为最终Tuple的基础。</p><p> // TupleImpltemplate＆lt; typename ... Ts＆gt; void swallow（Ts＆amp; ...）{} template＆lt; typename TupleIndexes_，typename ... Ts_＆gt; struct TupleImpl; template＆lt; size_t ... Indexes_，typename。 .. Ts_＆gt;结构TupleImpl＆lt; TupleIndexes＆lt; Indexes _...＆gt;，Ts _...＆gt; ：public TupleLeaf＆lt; Indexes_，Ts_＆gt; ... {模板＆lt; size_t ... FirstIndexes，类型名... FirstTypes，size_t ... LastIndexes，类型名... LastTypes，类型名... ValueTypes＆gt;显式TupleImpl（TupleIndexes＆lt; FirstIndexes ...＆gt;，TupleTypes＆lt; FirstTypes ...＆gt;，TupleIndexes＆lt; LastIndexes ...＆gt;，TupleTypes＆lt; LastTypes ...＆gt;，ValueTypes＆amp; amp; ...值）：TupleLeaf＆lt; ; FirstIndexes，FirstTypes＆gt;（forward＆lt; ValueTypes＆gt;（值））...，TupleLeaf＆lt; LastIndexes，LastTypes＆gt;（）... {}模板＆lt; typename OtherTuple＆gt; TupleImpl（OtherTuple＆amp; t）：TupleLeaf＆lt; Indexes_，Ts_＆gt;（转发类型名称TupleElement＆lt; Indexes_，类型名称MakeTupleTypes＆lt; OtherTuple＆gt; :: type＆gt; :: type＆gt;（get＆lt; Indexes_＆gt;（t）））... {}模板＆lt; typename OtherTuple＆gt; TupleImpl＆amp; operator =（OtherTuple＆amp; t）{swallow（TupleLeaf＆lt; Indexes_，Ts_＆gt; :: operator =（forward＆lt; typename TupleElement＆lt; Indexes_，typename MakeTupleTypes＆lt; OtherTuple＆gt; :: type＆gt; :: type＆gt;（get＆lt; Indexes_＆gt; t）））...）;返回* this; } TupleImpl＆amp; operator =（const TupleImpl＆amp; t）{swallow（TupleLeaf＆lt; Indexes_，Ts_＆gt; :: operator =（static_cast＆lt; const TupleLeaf＆lt; Indexes_，Ts_＆amp;＆gt;（t）.get（））...）;返回* this; } void swap（TupleImpl＆amp; t）{swallow（TupleLeaf＆lt; Indexes_，Ts_＆gt; :: swap（static_cast＆lt; TupleLeaf＆lt; Indexes_，Ts_＆gt;＆gt;（t））...）; }};</p><p> swallow（）函数只是一个小技巧，它允许我们在不可能的地方使用template-parameter-pack扩展：当我们要为template-parameter的每个元素调用foo（）时-pack，我们用这样的扩展调用swallow（）：swallow（）的参数绑定到除void以外的任何内容，因此我们需要确保foo（）确实返回某些内容（不是void foo（ ））。这就是为什么我们有奇怪的原因TupleLeaf :: swap（）函数的签名。由于功能本身</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://mitchnull.blogspot.com/2012/06/c11-tuple-implementation-details-part-1.html">http://mitchnull.blogspot.com/2012/06/c11-tuple-implementation-details-part-1.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/实现/">#实现</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lt/">#lt</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1045324.html"><img src="http://img2.diglog.com/img/2021/1/thumb_5f63c04a23404eeb4b88f6421ddb2a74.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1045324.html">2020年Go和C ++中的错误与异常 </a></div><span class="my_story_list_date">2021-1-20 19:33</span></div><div class="col-sm"><div><a target="_blank" href="/story/1044525.html"><img src="http://img2.diglog.com/img/2021/1/thumb_9e4e0fd42f10fa5ab8350f415bf06458.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1044525.html">GitHub上的新“动作类Rogue” C ++项目 </a></div><span class="my_story_list_date">2021-1-16 17:17</span></div><div class="col-sm"><div><a target="_blank" href="/story/1042857.html"><img src="http://img2.diglog.com/img/2021/1/thumb_ef812e52d976fb74194da576eed9833d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042857.html">Concurrencpp –一个C ++并发库 </a></div><span class="my_story_list_date">2021-1-2 8:21</span></div><div class="col-sm"><div><a target="_blank" href="/story/1042783.html"><img src="http://img2.diglog.com/img/2021/1/thumb_4127c1d751fd486005de4a5a9ebd8340.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042783.html">2020年首创（或C ++的好消息）– Herb Sutter </a></div><span class="my_story_list_date">2021-1-1 9:3</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>