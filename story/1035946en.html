<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>玩信号处理程序Having Fun with Signal Handlers</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Having Fun with Signal Handlers<br/>玩信号处理程序</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-23 00:58:13</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/38185431bf4562d9ba5994f88a5d7b03.jpeg"><img src="http://img2.diglog.com/img/2020/11/38185431bf4562d9ba5994f88a5d7b03.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>As every C and C++ programmer knows far too well, if you dereference apointer that points outside of the space mapped on your process&#39;memory, you get a segmentation fault and your programs crashes. As faras the language itself is concerned, you don&#39;t have a second chanceand you cannot know in advance whether that dereferencing operation isgoing to set a bomb off or not. In technical terms, you are invoking undefined behaviour, and you should never do that: you areresponsible for knowing in advance if your pointers are valid, and ifthey are not you keep the pieces.</p><p>正如每个C和C ++程序员所了解的那样，如果您取消引用指向进程内存中映射空间之外的指针，则会出现分段错误，并且程序将崩溃。就语言本身而言，您没有第二次机会，也无法提前知道该取消引用操作是否会引爆炸弹。用技术术语来说，您正在调用未定义的行为，因此绝对不要这样做：您有责任事先知道指针是否有效，如果指针不正确，则必须保留这些指针。</p><p> However, turns out that most actual operating system give you a secondchance, although with a lot of fine print attached. So I tried toimplement a function that tries to dereference a pointer: if it can,it gives you the value; if it can&#39;t, it tells you it couldn&#39;t. Again,I stress this should never happen in a real program, except possiblyfor debugging (or for having fun).</p><p> 但是，事实证明，尽管附带了很多精美的印刷品，但大多数实际的操作系统都会给您带来第二次机会。因此，我试图实现一个试图取消引用指针的函数：如果可以，它将为您提供值；如果不能，它会告诉您不能。我再次强调，除非是为了调试（或为了获得乐趣），否则这绝不应在实际程序中发生。</p><p>   The function is basically equivalent to  return *addr, except that if addr is not mapped it doesn&#39;t crash, and if  success is not NULL itis set to  0 or  1 to indicate that  addr was not mapped ormapped. If  addr was not mapped the return value is meaningless.</p><p>   该函数基本上等效于返回* addr，不同之处在于，如果未映射addr不会崩溃，并且如果成功不是NULL，则将其设置为0或1表示未映射或映射addr。如果未映射addr，则返回值没有意义。</p><p> I won&#39;t explain it in detail to leave you some fun. Basically the ideais to install a handler for  SIGSEGV: if the address is invalid, thehandler is called, which basically fixes everything by advancing alittle bit the instruction pointer, in order to skip the faultinginstruction. The dereferencing instruction is written as hardcodedAssembly bytes, so that I know exactly how many bytes I need to skip.</p><p> 为了给您带来一些乐趣，我不会详细解释。基本上，想法是为SIGSEGV安装一个处理程序：如果地址无效，则调用该处理程序，该处理程序基本上是通过略微提高指令指针的位来修复所有内容，从而跳过故障指令。取消引用指令写为hardcodedAssembly字节，因此我确切地知道需要跳过多少个字节。</p><p> Of course this is very architecture-dependent: I wrote the  i386 and amd64 variants (no  x32). And I don&#39;t guarantee there are no bugsor subtelties!</p><p> 当然，这非常依赖于体系结构：我编写了i386和amd64变体（没有x32）。而且我不保证没有bugsor子字幕！</p><p> Another solution would have been to just parse  /proc/self/mapsbefore dereferencing and check whether the pointer is in a mappedarea, but it would have suffered of a TOCTTOUproblem: another thread might have changed the mappings between thetime when  /proc/self/maps was parsed and when the pointer wasdereferenced (also, parsing that file can take a relatively longamount of time). Another less architecture-dependent but still notpure-C approach would have been to establish a  setjmp beforeattempting the dereference and  longjmp-ing back from the signalhandler (but again you would need to use different  setjmp contextsin different threads to exclude race conditions).</p><p> 另一个解决方案是在解引用之前仅解析/ proc / self / maps并检查指针是否在被映射的区域中，但这会遇到TOCTTOUproblem的问题：另一个线程可能已更改了/ proc / self / maps之间的映射被解析以及指针被取消引用的时间（同样，解析该文件可能会花费相对较长的时间）。另一种不太依赖体系结构但仍不是纯C的方法是在尝试从信号处理程序进行取消引用和长跳转之前建立一个setjmp（但同样，您将需要在不同线程中使用不同的setjmp上下文以排除竞争条件）。</p><p>  #define   _GNU_SOURCE  #include   &lt; stdint . h &gt;  #include   &lt; signal . h &gt;  #include   &lt; assert . h &gt;  #include   &lt; stdlib . h &gt;  #include   &lt; stdio . h &gt;  #include   &lt; ucontext . h &gt;  #ifdef   __i386__  typedef   uint32_t   word_t ;  #define   IP_REG   REG_EIP  #define   IP_REG_SKIP   3  #define   READ_CODE   __asm__   __volatile__ ( &#34;.byte 0x8b, 0x03\n&#34;   /* mov (%ebx), %eax */   \    &#34;.byte 0x41\n&#34;   /* inc %ecx */   \    :   &#34;=a&#34; ( ret ),   &#34;=c&#34; ( tmp )   :   &#34;b&#34; ( addr ),   &#34;c&#34; ( tmp ));  #endif  #ifdef   __x86_64__  typedef   uint64_t   word_t ;  #define   IP_REG   REG_RIP  #define   IP_REG_SKIP   6  #define   READ_CODE   __asm__   __volatile__ ( &#34;.byte 0x48, 0x8b, 0x03\n&#34;   /* mov (%rbx), %rax */   \    &#34;.byte 0x48, 0xff, 0xc1\n&#34;   /* inc %rcx */   \    :   &#34;=a&#34; ( ret ),   &#34;=c&#34; ( tmp )   :   &#34;b&#34; ( addr ),   &#34;c&#34; ( tmp ));  #endif  static   void   segv_action ( int   sig ,   siginfo_t   * info ,   void   * ucontext )   {    ( void )   sig ;    ( void )   info ;    ucontext_t   * uctx   =   ( ucontext_t * )   ucontext ;    uctx -&gt; uc_mcontext . gregs [ IP_REG ]   +=   IP_REG_SKIP ;  }  struct   sigaction   peek_sigaction   =   {    . sa_sigaction   =   segv_action ,    . sa_flags   =   SA_SIGINFO ,    . sa_mask   =   0 ,  } ;  word_t   peek ( word_t   * addr ,   int   * success )   {    word_t   ret ;    int   tmp ,   res ;    struct   sigaction   prev_act ;    res   =   sigaction ( SIGSEGV ,   &amp; peek_sigaction ,   &amp; prev_act );    assert ( res   ==   0 );    tmp   =   0 ;    READ_CODE    res   =   sigaction ( SIGSEGV ,   &amp; prev_act ,   NULL );    assert ( res   ==   0 );    if   ( success )   {    * success   =   tmp ;    }    return   ret ;  }  int   main ()   {    int   success ;    word_t   number   =   22 ;    word_t   value ;    number   =   22 ;    value   =   peek ( &amp; number ,   &amp; success );    printf ( &#34;%d %d\n&#34; ,   success ,   value );    value   =   peek ( NULL ,   &amp; success );    printf ( &#34;%d %d\n&#34; ,   success ,   value );    value   =   peek (( word_t * ) 0x1234 ,   &amp; success );    printf ( &#34;%d %d\n&#34; ,   success ,   value );    return   0 ;  }</p><p>  #define _GNU_SOURCE #include  #include  #include  #include  #include  #include  #ifdef __i386__ typedef uint32_t word_t; #define IP_REG REG_EIP #define IP_REG_SKIP 3 #define READ_CODE __asm__ __volatile__（“ .byte 0x8b，0x03 \ n” / * mov（％ebx），％eax * / \“ .byte 0x41 \ n” / * inc％ecx * / \：“ = a”（ret），“ = c”（tmp）：“ b”（addr），“ c”（tmp））; #endif #ifdef __x86_64__ typedef uint64_t word_t; ＃定义IP_REG REG_RIP＃定义IP_REG_SKIP 6＃定义READ_CODE __asm__ __volatile__（“ .byte 0x48，0x8b，0x03 \ n” / * mov（％rbx），％rax * / \“ .byte 0x48，0xff，0xc1 \ n” / * inc％rcx * / \：“ = a”（ret），“ = c”（tmp）：“ b”（addr），“ c”（tmp））; #endif静态void segv_action（int sig，siginfo_t * info，void * ucontext）{（void）sig; （无效）信息; ucontext_t * uctx =（ucontext_t *）ucontext; uctx-> uc_mcontext gregs [IP_REG] + = IP_REG_SKIP; } struct sigaction peek_sigaction = {。 sa_sigaction = segv_action，。 sa_flags = SA_SIGINFO，。 sa_mask = 0，}; word_t偷看（word_t * addr，int *成功）{word_t ret;内部tmp，res;结构签名prev_act; res = sigaction（SIGSEGV，＆peek_sigaction，＆prev_act）;断言（res == 0）; tmp = 0; READ_CODE res = sigaction（SIGSEGV，＆prev_act，NULL）;断言（res == 0）;如果（成功）{*成功= tmp;返回ret; } int main（）{int成功； word_t数字= 22; word_t值;数字= 22;价值=偷看（＆数字，＆成功）; printf（“％d％d \ n”，success，value）;值= peek（NULL，＆成功）; printf（“％d％d \ n”，success，value）;值=窥视（（word_t *）0x1234，＆成功）; printf（“％d％d \ n”，success，value）;返回0; }</p><p>         No comments yet!</p><p>暂时没有评论！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.giovannimascellani.eu/having-fun-with-signal-handlers.html">https://www.giovannimascellani.eu/having-fun-with-signal-handlers.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/信号处理/">#信号处理</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/signal/">#signal</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指针/">#指针</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>