<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Cassandra的麻烦：为什么它是对象存储元数据数据库的不佳选择 The Trouble with Cassandra: Why It's a Poor Choice for Object Store Metadata DB</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Trouble with Cassandra: Why It's a Poor Choice for Object Store Metadata DB<br/>Cassandra的麻烦：为什么它是对象存储元数据数据库的不佳选择 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-24 22:02:50</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/1903ab6abf17ee0cf74f1be19a14984d.jpg"><img src="http://img2.diglog.com/img/2021/2/1903ab6abf17ee0cf74f1be19a14984d.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Cassandra is a popular, tried-and-true NoSQL database that supports key-value wide-column tables. Like any powerful tool, Cassandra has its ideal use cases - in particular, Cassandra excels at supporting write-heavy workloads, while having limitations when supporting read-heavy workloads. Cassandra&#39;s eventual consistency model and lack of transactions, multi-table support like joins, subqueries can also limit its usefulness.</p><p>Cassandra是一个受欢迎的验证和真正的NoSQL数据库，支持键值宽列表。与任何强大的工具一样，Cassandra具有其理想的用例 - 特别是Cassandra擅长支持写入繁重的工作负载，同时在支持读取重型工作负载时具有局限性。 Cassandra＆＃39; s最终一致性模型和缺乏交易，多表支持，如加入，子查询也可以限制其有用性。</p><p> However, using Cassandra as a metadata database for an object storage system introduces significant complexity resulting in data integrity and performance issues at scale - particularly if one wants to use their object store as a primary storage system. Object storage needs are far simpler and different from what Cassandra is built for.</p><p> 但是，使用Cassandra作为对象存储系统的元数据数据库，引入了显着的复杂性，从而导致规模的数据完整性和性能问题 - 特别是如果想要将其对象存储用作主存储系统。对象存储需求远更简单，与Cassandra建造的不同。</p><p> Because the implications of employing Cassandra as a object storage metadata database were not properly understood, many object storage vendors made it a foundational part of their architecture - unfortunately it keeps them from ever moving past simple archival workloads into the modern workloads that define the future of object storage (AI/ML, analytics, web/mobile applications).</p><p> 由于雇用Cassandra作为对象存储元数据数据库的含义未正确理解，因此许多对象存储供应商使其成为其架构的基础部分 - 不幸的是，它使它们永远将过去的简单归档工作负载转移到定义未来的现代工作负载中对象存储（AI / ML，Analytics，Web / Mobile应用程序）。</p><p>  Cassandra was never designed to manage file or object storage metadata and it is predictably weak in this regard. It is  not ACID compliant. It does not have the rigidity to prevent partially successful writes, dupes, contradictions and the like. Cassandra does not support joins or foreign keys, and consequently does not offer consistency in the ACID sense. Further, there is no capacity to roll back transactions in the event of a failure.   While Cassandra supports atomicity and isolation at the row-level, it trades transactional isolation and atomicity for high availability and fast write performance.</p><p>  Cassandra从未设计用于管理文件或对象存储元数据，在这方面可以预测地弱。它不符合酸。它没有防止部分成功的写入，欺骗，矛盾等的僵化。 Cassandra不支持连接或外键，因此在酸感的不提供一致性。此外，在发生故障时没有滚动交易的容量。虽然Cassandra在行级支持了原子性和隔离，但它交易了用于高可用性和快速写入性能的事务隔离和原子性。</p><p> Cassandra is categorized as an AP system in CAP. Meaning it trades Consistency for Availability and Partition tolerance. When employing Cassandra as a metadata database for an object store, you can either be fast or consistent - but not both at the same time.   Cassandra’s tunable consistency is a compromise, not a feature. Any setting other than  QUORUM or ALL means you are at risk of reading stale data. It is important to apply this consistency setting for both read and write operations in addition to the object data operations performed outside of it.   In the object storage world, the implication is that you can be good for archival use cases (write once, read very infrequently) or you choose a different architecture.</p><p> Cassandra被归类为CAP中的AP系统。意味着它交易了可用性和分区容差的一致性。在使用Cassandra作为对象存储的元数据数据库时，您可以快速或一致 - 但不是同时。 Cassandra的可调一致性是一个妥协，而不是一个功能。仲裁以外的任何设置或一切都意味着您面临陈旧数据的风险。除了在其外部执行的对象数据操作之外，还可以针对读写操作应用此一致性设置。在对象存储世界中，含义是您可以对档案用例（写一次，非常不经常读取）或者选择不同的架构。</p><p> Similar to the consistency problem, durability guarantee is also a tradeoff between performance and correctness. The storage engine’s default  commit log is set to sync periodically every 10 seconds. This means you will lose up to 10 seconds worth of latest updates in the event of power failure. The only reasonable way to make Cassandra durable is to use the synchronous batch mode committer which comes with a performance penalty.</p><p> 类似于一致性问题，耐用性保证也是性能和正确性之间的权衡。存储引擎的默认提交日志设置为每10秒定期同步。这意味着在电源故障时，您将减少最新的最新更新。使Cassandra持久的唯一合理方式是使用具有性能损失的同步批量模式提名。</p><p> Cassandra’s high-availability guarantee is not suited for erasure coded object stores. With a replication factor of 3 and consistency quorum of 2, Cassandra can only tolerate a single node / drive failure within a replication group. Increasing the replication factor and quorum consistency to 5 or higher serves only to make the meta performance go from bad to worse. Unlike replication, erasure coding can tolerate multiple servers and drives failures in a distributed system. Even if you have configured the erasure code setting to 6 parity (any 6 nodes may fail) in a 16 node setup, you are still limited by the weak link, i.e Cassandra’s replication factor. The ops team is often unaware of these high-availability surprises until it is too late.</p><p> Cassandra的高可用性保证不适合擦除编码对象商店。对于3的复制因子和2的一致性仲裁因子，Cassandra只能在复制组中容忍单个节点/驱动器故障。增加复制因子和法定量为5或更高的一致性，仅用于使元表现从坏差。与复制不同，擦除编码可以容忍多个服务器并驱动分布式系统中的故障。即使您已将擦除代码设置配置为6个奇偶校验（任何6个节点可能发生故障），您仍然受到弱链路的限制，即Cassandra的复制因子。 ops团队往往没有意识到这些高可用性的惊喜，直到为时已晚。 </p><p> Object storage systems organize the data in a tree structured hierarchical namespace. Since Cassandra does not support a hierarchical key namespace, you will have to build a tree data model on top for each directory prefix and also maintain a flat list for direct lookups without directory walk. Atomically updating multiple tables with batched commit log and full read / write quorum is slow and prone to  corruption.</p><p>对象存储系统在树形结构化分层命名空间中组织数据。由于Cassandra不支持分层密钥命名空间，因此您必须为每个目录前缀构建一棵树数据模型，并在没有目录步行的情况下维护一个平面列表。具有批量提交日志和完整读/写法仲裁的多个表慢并且容易损坏多个表。</p><p> While objects themselves are immutable, the object storage system is mutable. When you add, remove, overwrite objects and its metadata, apply policies, collect metrics, grant session tokens and rotating credentials, the metadata is always mutating. Cassandra is not designed to handle this level of metadata mutation and definitely not for the primary storage workloads. Long term archival use cases where the objects are large (GBs in size) and infrequently accessed, will work - other use cases will not..  The reason is that Cassandra&#39;s log structured storage system quickly appends new writes to the end of the log file, but delays the deletes and overwrites with a tombstone marker. Vacuuming these tombstones is an expensive operation, because the actual delete operation is applied by copying the SSTables to a new table sieving the stale entries in the process. This operation has to be performed on all the nodes simultaneously. If you delay vacuuming, excessive tombstones will result in increased read latencies, memory GC pauses and failed queries. Some object storage vendors use an additional Redis database to offload Cassandra’s pressure. Using two databases to manage an object stores metadata is hardly elegant and introduces additional points of failure.    The biggest gotcha? You won’t see these problems until you are deep into production and it is too late.</p><p> 虽然对象本身是不可变的，但对象存储系统是可变的。添加，删除，覆盖对象及其元数据时，应用策略，收集指标，授予会话令牌和旋转凭据，元数据始终突变。 Cassandra不设计用于处理这种级别的元数据突变，并且绝对不是主要存储工作负载。长期档案用例，物体大（GB大小）和不经常访问，将工作 - 其他用例不会。原因是Cassandra＆＃39; S日志结构存储系统快速附加到结尾的新写字日志文件，但延迟删除和覆盖墓碑标记。吸取这些墓碑是一个昂贵的操作，因为通过将SSSTables复制到筛选过程中的陈旧条目的新表来应用实际删除操作。必须同时在所有节点上执行此操作。如果您延迟吸尘，过多的墓碑将导致读取延迟增加，内存GC暂停和失败的查询。一些对象存储供应商使用额外的REDIS数据库来卸载CASSANDRA的压力。使用两个数据库来管理对象存储元数据几乎不优雅，并引入了其他失败点。最大的gotcha？在您深入生产之前，您将不会看到这些问题，为时已晚。</p><p> Small objects (KB to MB in size) will fill up the metadata drives dedicated to Cassandra much sooner than the data drives. Also small object workloads exacerbate Cassandra’s limitations, because they are sensitive to latency and consistency issues.  Some vendors store small objects entirely inside Cassandra to address this problem. At this point, you are merely looking at an S3 proxy on top of Cassandra database.   This too is a bad practice.   If you use your object store for large objects and employ erasure coding and use Cassandra as your data store for small objects and use replication - you have introduced a non-trivial SLA problem. In this approach, data is protected by different guarantees. Given that drives die all the time, the probability of serving an old object or a corrupted object goes up considerably.   As noted above, your metadata database is now the weak link. Availability, consistency and durability guarantees are only as good as the weakest link. If the weakest link employs replication (three copies) you can only withstand one-node or one drive failure before losing data.  A counter argument might be to replicate five copies. The result is a massive performance hit and you can still really only withstand two-node or two-drive failure.   In using replication for small objects and erasure coding for large objects you also undermine the efficiency gains associated with EC. If you only use erasure code for large objects (likely a small percent of your overall object pool) you don’t gain much but increase your exposure considerably.</p><p> 小对象（大小的kB到MB）将填充专用于Cassandra的元数据驱动器，而不是数据驱动器。还有小对象工作负载加剧了Cassandra的局限性，因为它们对延迟和一致性问题很敏感。一些供应商完全在Cassandra内存的小物体来解决这个问题。此时，您只需在Cassandra数据库上看一个S3代理。这也是一个糟糕的做法。如果您使用对象存储以进行大型对象并使用擦除编码并使用Cassandra作为您的小对象的数据存储和使用复制 - 您已经介绍了一个非平凡的SLA问题。在这种方法中，数据受到不同保证的保护。鉴于驱动器一直死在一起，服务旧对象或损坏对象的可能性很大。如上所述，您的元数据数据库现在是薄弱的链接。可用性，一致性和耐用性保证仅与最薄弱的联系一样好。如果最弱的链接采用复制（三个副本），则可以在丢失数据之前抵消一个节点或一个驱动器故障。柜台参数可能是复制五个副本。结果是一个大规模的绩效命中，您仍然只能承受两个节点或两个驱动器故障。在使用对大型物体的小物体和擦除编码的复制中，您还破坏了与EC相关的效率增益。如果您只使用大型对象的擦除代码（可能是整个对象池的少量百分比），您不会得到很多，但大大增加您的曝光。</p><p> Employing Cassandra as your metadata database for an object store also introduces a troublesome Java dependency. This in turn can result in bloatware and memory management issues. Cassandra taxes the JVM memory management with constant large scale metadata allocation and mutation resulting in memory exhaustion and garbage collection pauses.</p><p> 使用Cassandra作为对象存储的元数据数据库也引入了麻烦的Java依赖项。这反过来可能导致陷阱软件和内存管理问题。 Cassandra以恒定的大规模元数据分配和突变征收JVM内存管理，导致内存耗尽和垃圾收集暂停。</p><p> The obvious takeaway is that it is a lot more complicated to operate a Cassandra cluster than a properly designed object storage system. Cassandra is built for a different purpose and object-storage meta-data is not one of them. The areas where Cassandra struggles are the areas that are core to a performant, scalable and resilient object store.</p><p> 显而易见的外带是，操作Cassandra集群比适当设计的对象存储系统更复杂。 Cassandra是为不同的目的而构建的，对象存储的元数据不是其中之一。 Cassandra斗争的领域是表演，可扩展和弹性对象商店的核心。</p><p> The last point is of note - object storage is a natural fit for blob data and that is why Erasure Coding is so effective and efficient. Cassandra is designed for replication. When you use that model for metadata it breaks the object store’s erasure coding advantage (or at the very least makes it brittle and prone to breakage).</p><p> 最后一点是注 - 对象存储是Blob数据的自然适合，这就是擦除编码如此有效和高效的原因。 Cassandra专为复制而设计。当您使用该型号进行元数据时，它会破坏对象存储的擦除编码优势（或者最不使其脆弱并且容易破损）。</p><p>  We welcome your comments. Feel free to engage us on Twitter, on our Slack channel or by dropping us a note at  hello@min.io.</p><p>  我们欢迎您的意见。在我们的松懈频道上，或通过在hello@min.io下放记笔，随时致力于推特。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.min.io/the-trouble-with-cassandra-based-object-stores/">https://blog.min.io/the-trouble-with-cassandra-based-object-stores/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/麻烦/">#麻烦</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cassandra/">#cassandra</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>