<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从土生土长到反应土生土长到飘动From Native to React Native to Flutter</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">From Native to React Native to Flutter<br/>从土生土长到反应土生土长到飘动</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-14 20:40:40</div><div class="page_narrow text-break page_content"><p>At Zerodha, the first mobile version our flagship trading platform  Kite was written as a native Android app in 2015. After building a cross-platform version in React Native in 2017, we finally settled for a full rewrite in Flutter in 2018, a choice that has paid off really well for us. There were several factors and trade-offs that prompted these rewrites.</p><p>在Zerodha，我们的旗舰交易平台Kite的第一个移动版本于2015年作为原生安卓应用程序编写。2017年，在React Native中构建了一个跨平台版本后，我们终于决定在2018年对Flitter进行全面重写，这一选择对我们来说回报颇丰。有几个因素和权衡促使这些重写。</p><p> This post covers our journey and experiences with each of the frameworks, and why we finally bet on Flutter even when it was bleeding edge alpha technology. It also illustrates the thought process and our first-principle based approach that enables just two mobile developers to build and maintain multiple financial apps used by millions of people.</p><p>这篇文章介绍了我们使用每一个框架的过程和经验，以及为什么我们最终把赌注押在flift上，即使它是最前沿的alpha技术。它还展示了我们的思维过程和第一个基于原则的方法，使两个移动开发者能够构建和维护数百万人使用的多个金融应用程序。</p><p>  In the beginning, there was only Kite web, which was built as a web frontend to the  Kite Connect APIs. We started working on Kite Android as a native app sometime in 2015. Interestingly, this was a time when trading on mobile was largely uncommon in the Indian capital markets and smartphone penetration was very low compared to what it is today. Since we had no experience building mobile apps, Sujith, our lone mobile developer at the time, built it over several months by trial and error. This was also around the time when he invented the infamous SujithSort™ algorithm. The first public release came out in early 2016. While it was a very basic app compared to what we have today, it still was far better than what was popular in the industry at the time.</p><p>起初，只有Kite web，它是作为Kite Connect API的web前端构建的。2015年的某个时候，我们开始将Kite Android作为本机应用进行开发。有趣的是，当时在印度资本市场上，手机交易基本上不常见，智能手机的普及率与今天相比非常低。由于我们没有开发移动应用程序的经验，我们当时唯一的移动开发者Sujith通过反复试验，在几个月的时间里开发了它。这也是他发明臭名昭著的苏吉特运动的时候™ 算法。第一次公开发布于2016年初。虽然与我们今天的应用相比，它是一款非常基础的应用，但它仍然远远好于当时业界流行的应用。</p><p> We did not immediately plan on developing a native iOS app as we didn’t have the expertise and there was very little demand in the market for an iOS app. While this has now changed considerably, the trend still continues, where only about 10% of our users use iOS. However, to maintain a basic presence on the app store, we released an iOS version that wrapped our responsive web app in a webview.</p><p>我们没有立即计划开发原生iOS应用程序，因为我们没有专业知识，而且市场上对iOS应用程序的需求非常少。虽然这一点现在已经发生了很大变化，但这一趋势仍在继续，我们只有约10%的用户使用iOS。然而，为了保持应用商店的基本状态，我们发布了一个iOS版本，将我们的响应式web应用包装在一个webview中。</p><p> The native Android app went through a ton of changes and feature additions as our trading platform evolved. We would release new features first on the web app, collect feedback from web users, iron out bugs and stabilize the API, and then add it to the mobile app. We have followed this strategy from the very beginning to compensate for increased development and testing effort required in the mobile release flow.</p><p>随着交易平台的发展，原生安卓应用经历了大量的变化和功能添加。我们将首先在web应用程序上发布新功能，收集web用户的反馈，消除漏洞并稳定API，然后将其添加到移动应用程序中。我们从一开始就遵循这一策略，以弥补移动发布流程中增加的开发和测试工作。</p><p> As the rate of changes picked up and we started building more complex features, our development and testing process started to slow down compounded by a rising number of device-specific and OEM issues. This was also the time when we started to see an increase in the number of iOS users and we figured we needed to have an actual app rather than a webview frame.</p><p>随着变化的速度加快，我们开始构建更复杂的功能，我们的开发和测试过程开始放缓，同时出现了越来越多的设备特定问题和OEM问题。这也是我们开始看到iOS用户数量增加的时候，我们认为我们需要一个实际的应用程序，而不是webview框架。</p><p>  I joined the team in early 2017 and around this time, we began our experiments with React Native when it was at version 0.42. We picked it over other web based cross-platform frameworks because of its “native” end result. A native UI with a UX that follows the operating system is the USP of React Native. End users do feel the native UX, but only when it works unfortunately! We had also hoped that we could reuse a lot of logic from Kite web even though it was written in AngularJS at that time. But in reality, the potential of reuse turned out to be very low except for some data processing libraries with some minor modifications.</p><p>我在2017年初加入了这个团队，大约在这个时候，我们在0.42版本的React Native上开始了我们的实验。与其他基于web的跨平台框架相比，我们选择了它，因为它的最终结果是“原生的”。带有遵循操作系统的UX的本机UI是React native的USP。最终用户确实感觉到了原生用户体验，但只有在它不幸奏效的时候！我们还希望能够重用Kite web中的大量逻辑，尽管当时它是用AngularJS编写的。但在现实中，重用的潜力被证明是非常低的，除了一些稍作修改的数据处理库。</p><p> Since our iOS app was lagging behind, we decided to rewrite Kite in React Native for iOS first and eventually replace the native Android app which had started to gain traction. After 5 months of development, we released Kite for iOS written in React Native in mid 2017. We were quite surprised by the considerably less development time compared to the native Android app. While it was a port of the Android app, we added a bunch of UI improvements with iOS specific elements. Soon after though, React Native started showing its fair share of issues.</p><p>由于我们的iOS应用落后，我们决定首先在React Native for iOS中重写Kite，并最终替换已经开始获得吸引力的本机Android应用。经过5个月的开发，我们于2017年年中发布了用React Native编写的iOS版Kite。与原生安卓应用相比，开发时间大大缩短，这让我们非常惊讶。虽然它是Android应用程序的一个端口，但我们添加了一系列针对iOS特定元素的UI改进。然而，不久之后，React Native开始展示其公平的问题份额。</p><p>  Let’s start with JavaScript. Besides the well known language quirks, we were also frustrated by the amount of chaos brought by the massive number of Node module dependencies React Native had. Every now and then something would break out of the blue and the only solution would be to nuke the entire node_modules cache and to re-install them. How or why something broke was often a mystery. Every time we did this, macOS Spotlight, a system-wide search service, would start indexing the hundreds of thousands of files in the node_modules folder. This indexing issue ( yarn#6453,  npm#15346) is still the responsibility of the user to manually fix every time.</p><p>让我们从JavaScript开始。除了众所周知的语言怪癖，我们还对大量节点模块依赖关系带来的混乱感到失望。时不时会有事情突然发生，唯一的解决办法就是用核弹炸掉整个node_模块缓存并重新安装它们。事情是如何或为什么破裂的往往是个谜。每次我们这样做，macOS Spotlight，一个全系统的搜索服务，就会开始索引node_modules文件夹中的数十万个文件。这个索引问题（纱线#6453，npm#15346）仍然是用户每次手动修复的责任。</p><p> One fine day, the entire Android build started to fail ( react-native#19259). Turned out, someone had uploaded a fake React Native build to JCenter and Gradle preferred it over the official build ( react-native#13094). This broke everyone’s projects that were on a different version than this fake lib’s. This was scary and we got lucky because we were stuck on a lower version. Imagine those who had the same version, they would have built their app with the fake lib and shipped it without ever realizing it.</p><p>一个晴朗的日子，整个Android构建开始失败（react native#19259）。结果是，有人把一个假的React-Native版本上传到了JCenter，Gradle更喜欢它而不是官方版本（React-Native#13094）。这打破了每个人的项目，这些项目的版本与这个假库不同。这很可怕，我们很幸运，因为我们被困在了一个较低的版本上。想象一下，那些拥有相同版本的人，他们会用假库构建自己的应用程序，并在没有意识到的情况下发布。</p><p> Another problem was quality issues with third party libraries. Since React Native was tightly tied to the native SDKs, if there was an API or UI element that was not built-in, we had no choice but to look for third party libs. For example, to use the native Android CheckBox, a third party lib was required. It was a pain having to fork every single dependency to upgrade the Android build and SDK versions ( react-native-android-checkbox@07ac303) or the project wouldn’t work with a newer React Native version.</p><p>另一个问题是第三方图书馆的质量问题。由于React Native与本机SDK紧密相连，因此如果存在未内置的API或UI元素，我们别无选择，只能寻找第三方LIB。例如，要使用原生Android复选框，需要第三方库。为了升级Android build和SDK版本（react native Android），不得不放弃每一个依赖项，这是一种痛苦-checkbox@07ac303)或者该项目无法使用更新的React原生版本。</p><p> If we were to build one of these libs from scratch, the poor IDE support while navigating through projects and writing native modules made it extremely hard. It really reminded me of editing PHP files via net2ftp. Hopefully this has improved now. Also our lack of expertise in ObjectiveC and the impossible task of converting Swift code snippets from StackOverflow spanning multiple Swift versions and breaking language changes contributed to this bad experience.</p><p>如果我们要从头开始构建其中一个lib，那么在项目中导航和编写本机模块时糟糕的IDE支持会让我们非常困难。它真的让我想起了通过net2ftp编辑PHP文件。希望现在情况有所改善。此外，我们缺乏Objective方面的专业知识，无法将跨越多个Swift版本的Swift代码片段从StackOverflow中转换出来，以及破坏性的语言更改，也导致了这种糟糕的体验。</p><p> Speaking of upgrading React Native, it almost never happened. Every time we tried we were greeted with countless cryptic errors. To be able to fix the trademark React Native red error screen, we often had to do a process of elimination by progressively deleting parts of the app until we got an error free launch, and it often came down to a faulty lib that used some internal API which had gone through a breaking change. If only there was some kind of clue in the stack trace that pinpointed at the errors. Instead, the stack traces were usually pointing at something inside the platform native code of React Native, making it impossible to trace back to the part of our code or a lib.</p><p>说到升级，这几乎从未发生过。每次我们尝试时，都会遇到数不清的神秘错误。为了修复商标React本机红色错误屏幕，我们通常必须通过逐步删除应用程序的部分来进行消除，直到我们获得无错误启动，这通常归结为一个错误库，该库使用了一些内部API，该API经历了突破性的更改。如果堆栈跟踪中有某种线索可以精确定位错误就好了。相反，堆栈跟踪通常指向React native的平台本机代码中的某些内容，因此无法追溯到代码或库的部分。</p><p>  Coming back to Kite on iOS, despite the development pains, it was a success with the users. React Native worked reasonably well on iOS, thanks to the snappy and stable naive UI components, UX consistent with the rest of the OS, and the solid performance of JavaScriptCore, the native iOS JavaScript engine that React Native used.</p><p>回到iOS上的Kite，尽管开发过程中遇到了困难，但它在用户中取得了成功。React Native在iOS上运行得相当好，这要归功于简洁稳定的朴素UI组件、与其他操作系统一致的用户体验，以及使用React Native的iOS原生JavaScript引擎JavaScriptCore的稳定性能。</p><p> However, when we tried to bring it to Android, we were very disappointed by the performance, especially on mid-range and budget smartphones. The most evident aspect was the updates of stock market ticks (prices). As a trading app, Kite subscribes to a large number of stock ticks, parses binary data received from a Websocket connection multiple times a second, performs several calculations, and finally renders the numbers on the screen. Combine that with the  setState batching of React, user interactions and UI transitions that happen simultaneously, lack of a synchronous–low latency–lazily rendered listview and the performance issues of the JS-Native bridge, it resulted in really bad UX. The ticks were never in sync with the native Android app, would sometimes get delayed by up to a second, and would sometimes flash unintelligibly fast due to  setState batching.</p><p>然而，当我们试图将其应用到安卓系统时，我们对其性能非常失望，尤其是在中端和廉价智能手机上。最明显的方面是股市行情的更新。作为一款交易应用程序，Kite订阅大量股票行情，每秒多次解析从Websocket连接接收到的二进制数据，进行多次计算，最后在屏幕上呈现这些数字。再加上同时发生的反应、用户交互和UI转换的setState批处理、缺少同步的、低延迟的、延迟呈现的listview，以及JS本机网桥的性能问题，这导致了非常糟糕的用户体验。滴答声从未与本机Android应用程序同步，有时会延迟一秒钟，有时会由于设置状态批处理而以无法理解的速度闪烁。</p><p> We tried many ways to fix it. Reduced the scope of the rendering down to the  Text element, tuned reconciliation with  shouldComponentUpdate, throttled updates to fixed time frames, used  setNativeProps and read only  TextInput to show the ticks to avoid  setState. We managed to solve it to an acceptable level.</p><p>我们尝试了很多方法来修复它。将渲染范围缩小到文本元素，调整与shouldComponentUpdate的协调，将更新限制到固定的时间范围，使用setNativeProps和只读TextInput显示刻度，以避免setState。我们设法把问题解决到了可以接受的程度。</p><p> But, this was just the tip of the iceberg. The next big challenge was navigation. We were using a navigation library from Wix and while it worked flawlessly on iOS, it was buggy on Android. After going through a lot of similar pain, in the end, we gave up on the plans to replace the native Android app with a React Native version and kept the React Native version only for iOS.</p><p>但是，这只是冰山一角。下一个大挑战是导航。我们使用的是Wix的导航库，虽然它在iOS上工作得很完美，但在Android上却有问题。在经历了许多类似的痛苦之后，最终，我们放弃了用React原生版本替换原生Android应用程序的计划，并将React原生版本仅用于iOS。</p><p> In the meanwhile, to reduce the constant issues with the large number of dependencies, we wrote a highly opinionated and extremely light weight lib that did state management, network calls, data unpacking, store persistence etc. We also built a navigation lib that used only hardware accelerated transitions instead of the ones controlled by JavaScript. Later, when we built a mobile app for  Coin in React Native, these libs helped us to build a snappy UI easily. Since the screens on Coin don’t update like the real time screens on Kite, there wasn’t much of a performance hit.</p><p>与此同时，为了减少大量依赖项带来的持续问题，我们编写了一个高度固执己见、重量极轻的lib，用于状态管理、网络调用、数据解包、，存储持久性等。我们还构建了一个导航库，它只使用硬件加速的转换，而不是由JavaScript控制的转换。后来，我们在React Native中为Coin构建了一个移动应用程序，这些LIB帮助我们轻松构建了一个简洁的UI。由于Coin上的屏幕不像Kite上的实时屏幕那样更新，所以性能没有太大的提升。</p><p> Despite all the issues with React Native, the one thing that we appreciated was its Code Push support. The fact that you could update the code bundle of your app over the air was very useful in certain emergency scenarios where you really had to push a hot patch. While this worked on the vast majority of devices, on a certain percentage of devices, the rollback system in Code Push that restores the bundle in case of an unsuccessful update, turned out to be a problem. There were way too many inexplicable rollbacks ( react-native-code-push#1488) that just could not be debugged. Because we were using this as a last resort option to fix the critical bugs, it was critical that the updates went through no matter what.</p><p>尽管React Native存在所有问题，但我们欣赏它的代码推送支持。在某些紧急情况下，你可以通过无线方式更新应用程序的代码包，这一点非常有用，因为在这些情况下，你真的需要推送一个热补丁。虽然这在绝大多数设备上有效，但在一定比例的设备上，代码推送中的回滚系统在更新失败的情况下恢复捆绑包，结果证明是一个问题。有太多无法解释的回滚（react native code push#1488）无法调试。因为我们将此作为修复关键漏洞的最后手段，所以无论发生什么情况，更新都是至关重要的。</p><p> Some of these issues seem to be fixed now. But, the new changes in React Native seem very promising, like Hermes replacing JavaScriptCore and the new upgrade tools. The  Varsity app that was built more recently in React Native works well. So it is still a viable option for many types of apps, just that it didn’t have the right trade-offs for Kite.</p><p>其中一些问题现在似乎已经解决了。但是，React Native的新变化似乎非常有希望，比如Hermes取代了JavaScriptCore和新的升级工具。最近在React Native中开发的Varsity应用程序运行良好。因此，对于许多类型的应用程序来说，它仍然是一个可行的选择，只是它没有为Kite做出正确的权衡。</p><p>  We stumbled upon Flutter in early 2018. It was an alpha version and from the first look, it resembled projects like  Shiny,  Nuklear, and  NanoVG. After trying it out once, it did feel like a more mature project, and the development experience also felt superior to React Native. I immediately started using it for my personal projects to get the hang of it. It took me back to the Visual Basic 6 days when I could see the UI changes instantaneously during development.</p><p>2018年初，我们偶然发现了弗利特。这是一个阿尔法版本，从第一眼看，它类似于闪亮、Nuklear和NanoVG等项目。在尝试过一次之后，它确实感觉像是一个更成熟的项目，而且开发体验也感觉优于React Native。我立即开始在我的个人项目中使用它来掌握诀窍。我花了6天时间回到Visual Basic，在开发过程中，我可以立即看到UI的变化。</p><p> But, there was some friction. It required a whole new language, Dart, and that didn’t feel comfortable in the beginning. The bundle size of a “hello world” app could be as much as 5 MB. This was huge given that a similar native Android app could be brought  as low as 6KB. The Webview plugin available at that time wasn’t that good. The biggest open source app that was built with Flutter was the demo Gallery app that showcased all the widgets of the framework. It wasn’t a good example on how to structure a serious project. The only state management library was  scoped_model, and it looked nothing like what we had used before.</p><p>但是，有一些摩擦。它需要一种全新的语言，Dart，而这在一开始并不舒服。“hello world”应用的捆绑包大小可能高达5MB。考虑到一款类似的原生安卓应用可以低至6KB，这是一个巨大的挑战。当时可用的Webview插件不是很好。使用Flatter构建的最大的开源应用程序是演示库应用程序，它展示了框架的所有小部件。这不是一个关于如何组织一个严肃项目的好例子。唯一的州管理库是scoped_模型，它与我们以前使用的完全不同。</p><p> In the meanwhile, I built several personal projects in Flutter. An infinitely nested todo list, a control UI for my Raspberry Pi router, a UI for my dad to monitor the water level data of the rooftop tank served from an ESP8266 WiFi module, a rewrite of the  Olam dictionary app, and other automation tools. Flutter made UI building effortless while also making it easy to build external integrations thanks to its clean APIs for File IO/HTTP/Raw Sockets and the ease of writing native plugins.</p><p>与此同时，我在Flatter中创建了几个个人项目。一个无限嵌套的待办事项列表，一个用于我的Raspberry Pi路由器的控制用户界面，一个用于我父亲监控从ESP8266 WiFi模块提供的屋顶水箱水位数据的用户界面，一个重写Olam字典应用程序的用户界面，以及其他自动化工具。Flatter为文件IO/HTTP/Raw套接字提供了干净的API，并且易于编写本机插件，因此它可以轻松构建UI，同时也可以轻松构建外部集成。</p><p>  After a couple of months, things started to make sense. We became more comfortable with Dart, its syntax, type checking, and code organization. It turned out to be easier than we had anticipated. The IDE support and the documentation were also exceptional, both for the language and the framework. The package management with the pub tool was also well structured and reliable. Thanks to the global package cache, it didn’t eat disk space unnecessarily.</p><p>几个月后，事情开始变得有意义了。我们对Dart、其语法、类型检查和代码组织更加熟悉。结果比我们预想的要容易。IDE支持和文档在语言和框架方面都是例外。使用pub工具进行的包管理也是结构良好且可靠的。多亏了全局包缓存，它没有不必要地占用磁盘空间。</p><p> An important aspect of Flutter was the similarity of its layout mechanism with flexbox which we were already familiar with in React Native. This made conceptualizing and writing UI layouts a breeze. If we wanted to create something very custom, we could always fall back to the graphics, layout, and physics primitives to write our own.</p><p>颤振的一个重要方面是其布局机制与我们在React Native中已经熟悉的flexbox的相似性。这使得构思和编写UI布局变得轻而易举。如果我们想创建一些非常定制的东西，我们可以使用图形、布局和物理原语来编写自己的。</p><p> On the compiler side, the JIT mode for fast startup and debug friendliness was nice. The AOT mode for production builds with reduced binary size and the consistent and optimal performance was impressive. The best feature though, Hot Reload, was simply a rebrand of Dart VM’s runtime source reload mechanism. Comparing React Native’s Hot Module Replacement (HMR) and Flutter’s Hot Reload was like night and day. The bundle size did not increase significantly from the base size as the size and complexity of the app increased as we had initially worried. Bulk of the base size was just the graphics engine, Flutter framework, and Unicode ICU data for internationalization.</p><p>在编译器方面，快速启动和调试友好的JIT模式很不错。用于生产构建的AOT模式减少了二进制大小，一致且最佳的性能令人印象深刻。不过，最好的特性是热重新加载，它只是对Dart VM的运行时源代码重新加载机制的一个重新命名。比较React Native的热模块更换（HMR）和Flatter的热重新加载就像是日以继夜。捆绑包的大小并没有像我们最初担心的那样，随着应用程序的大小和复杂性的增加而从基本大小显著增加。基本规模的大部分只是用于国际化的图形引擎、颤振框架和Unicode ICU数据。</p><p> However, the lack of Dart’s runtime reflection (mirrors) in Flutter was an issue while porting the serializers from our existing codebase. This was apparently to facilitate tree shaking during compilation to reduce binary size. If there was a way to enable reflection for specific declarations using some kind of compiler annotation, it would’ve been great. The official solution was to use code generation which also avoided the performance hit with reflection. This is still the case.</p><p>然而，在从现有代码库移植序列化程序时，颤振中缺少Dart的运行时反射（镜像）是一个问题。这显然是为了在编译过程中简化树结构，以减少二进制大小。如果有一种方法可以使用某种编译器注释为特定声明启用反射，那就太好了。官方的解决方案是使用代码生成，这也避免了反射对性能的影响。情况仍然如此。</p><p> The frequent improvements to the Dart language over time have been excellent for Flutter. For instance, the removal of the  new keyword before class constructors has reduced verbosity. Non-nullable by default (NNBD) types have significantly reduced null pointer exceptions. Foreign Function Interface (FFI) support allows Dart to communicate with native binaries built with C/C++/Rust/Go etc. Isolates (Dart equivalent of threads) in Dart 2.15, reuses the heap, reducing memory copy when exchanging data between isolates. This makes them a lot more useful in cases where your app has to do a lot of processing that might cause delay in rendering, leading to frame drops.</p><p>随着时间的推移，Dart语言的频繁改进对于颤振来说是极好的。例如，在类构造函数之前删除new关键字可以减少冗长。默认情况下不可空（NNBD）类型显著减少了空指针异常。外部函数接口（FFI）支持允许Dart与使用C/C++/Rust/Go等构建的本机二进制文件通信。Dart 2.15中的隔离（Dart相当于线程）重用堆，在隔离之间交换数据时减少内存拷贝。这使得它们在应用程序需要进行大量处理的情况下更加有用，这些处理可能会导致渲染延迟，从而导致帧丢失。</p><p>  Back in 2018 though, it wasn’t a simple decision for us to consider Flutter for production use, let alone rewrite Kite in it. It would be a major long term commitment and it would take away significant amounts of our developer bandwidth at a time when our userbase was growing, and we were shipping an increasing number of features. Not to mention, there were only the two of us developing the mobile apps. Actually, today, it is still just the two of us.</p><p>然而，在2018，我们考虑使用颤动不是一个简单的决定，更不用说改写风筝了。这将是一项重大的长期承诺，它将在我们的用户群不断增长、我们提供的功能越来越多的时候，占用我们开发人员的大量带宽。更不用说，只有我们两个人在开发移动应用。事实上，今天，仍然只有我们两个人。</p><p> At the same time, our two completely different codebases, native and React native, were expanding and becoming increasingly painful to maintain. We really needed to unify these codebases if we wanted to ship features fast and not lag behind the web app. We wanted to set our focus and spend most of our time on the development of the app instead of worrying about the issues in the framework and external dependencies. And Flutter had started to look like a viable alternative.</p><p>与此同时，我们的两个完全不同的代码库，native和React native，正在扩展，维护起来越来越痛苦。如果我们想快速发布功能，并且不落后于web应用程序，我们真的需要统一这些代码库。我们想集中精力，把大部分时间花在应用程序的开发上，而不是担心框架中的问题和外部依赖性。而弗利特开始看起来像是一个可行的选择。</p><p> Still, because Kite was a critical financial app, even the smallest decisions and changes carried huge amounts of risk. So, we discussed and deliberated over many cups of bland office machine coffee. We considered all possible tradeoffs that we could think of. We also seriously thought of the long term implications of betting on a bleeding edge technology that could stop being maintained. Thanks to it being open source, and its decent state back then even as alpha software, we figured that even if it was killed, we would still be able to use it meaningfully for a few years.</p><p>尽管如此，由于Kite是一款关键的金融应用程序，即使是最小的决定和改变也会带来巨大的风险。所以，我们讨论和商议了很多杯乏味的办公室咖啡。我们考虑了所有可能的权衡。我们还认真考虑了押注前沿技术的长期影响，这种技术可能会停止使用。多亏了它是开源的，以及它当时作为alpha软件的良好状态，我们认为即使它被杀了，我们仍然能够在几年内有意义地使用它。</p><p> Because of these reasons, despite Flutter being alpha, we decided to consider it for Kite rewrite. Thankfully, my personal projects had given me a good deal of confidence in Flutter too. We had already spent on-and-off time over several months experimenting with potential project structures, porting some of our old ReactNative JS libraries to Dart, and building helper tools for code generation, debugging etc. to understand it better. To make the final call, we built a fully functional UI prototype of Kite complete with proper navigation, screens loaded with mock data, and of course simulated market ticks which only took about a week or so, which we then proceeded to stress test. And, it just didn’t break a sweat. The one was chosen.</p><p>由于这些原因，尽管颤动是阿尔法，我们决定考虑它风筝改写。谢天谢地，我的个人项目也给了我很大的信心。我们已经花了几个月的时间断断续续地试验潜在的项目结构，将一些旧的ReactNative JS库移植到Dart，并构建用于代码生成、调试等的帮助工具，以便更好地理解它。为了进行最后的通话，我们构建了一个功能齐全的Kite用户界面原型，包括正确的导航、加载模拟数据的屏幕，当然还有只花了大约一周时间的模拟市场行情，然后我们进行了压力测试。而且，它一点也不冒汗。那一个被选中了。</p><p>  We started the rewrite in mid 2018. Our plan was to first replace the native Android app as that was starting to become a maintenance nightmare and also because it had the biggest user base. We had written a few helper tools for code generation and debugging and they sped up the rewrite process and made the Flutter app as close architecturally as possible to our React Native app. It only took about 3 months to get to feature parity with our production app.</p><p>我们在2018年年中开始重写。我们的计划是首先替换原生安卓应用，因为这开始成为维护的噩梦，也因为它拥有最大的用户群。我们已经编写了一些用于代码生成和调试的辅助工具，它们加快了重写过程，并使Flatter应用程序在架构上尽可能接近我们的React原生应用程序。只花了大约3个月的时间就可以与我们的生产应用程序实现功能对等。</p><p>  To help with a rewrite, we built a code generator (serializers, string enum maps, static asset embedding etc.) to port a lot of the state management behaviour of the React Native app without which we would end up writing a lot of boilerplate code. We had tried to do this with the official generator system -  build_runner, but there were no simple and straightforward examples or a guide on writing our own generators using it. Also, some aspects of it were sub-optimal, like the scary nested staircase looking YAML config which we worried would require the deployment of our resident YAML ninja,  @karan “k3n” Sharma, to handle.</p><p>为了帮助重写，我们构建了一个代码生成器（序列化程序、字符串枚举映射、静态资产嵌入等），以移植React本机应用程序的许多状态管理行为，如果没有这些行为，我们将编写大量样板代码。我们曾尝试使用官方的生成器系统build_runner来实现这一点，但没有简单明了的例子，也没有关于使用它编写我们自己的生成器的指南。此外，它的某些方面还不太理想，比如可怕的嵌套楼梯状YAML配置，我们担心这需要部署我们的常驻YAML忍者@karan“k3n”Sharma来处理。</p><p> So we went back to first principles. Our generator uses @hints (annotations) to generate helper functions like how a Java IDE inserts getters and setters for classes. It uses the official  analyzer package which can parse the latest Dart syntax. The early version used Regular Expressions which started getting out of hand. Since the code generator is an external CLI tool in Dart, running it requires a full cold of the Dart VM, which is a slow process. To make hot-reloading available while building Dart CLIs, we wrote  recharge.</p><p>所以我们回到了第一原则。我们的生成器使用@hints（注释）生成助手函数，比如Java IDE如何为类插入getter和setter。它使用官方的analyzer包，可以解析最新的Dart语法。早期版本使用的正则表达式开始失控。由于代码生成器是Dart中的一个外部CLI工具，因此运行它需要完全冷却Dart VM，这是一个缓慢的过程。为了在构建Dart CLI时提供热重新加载，我们编写了充值。</p><p>  Since we were rewriting the whole app anyway we thought we could also refresh our UI a bit too. Given how powerful the UI building capabilities of Flutter was, we were able to build the UI/UX elements we wanted without depending on any external libs. If we didn’t like the way a built-in widget worked, we would simply copy its source, tweak it, fix the import paths, replace some variables and it would be good to go. The framework’s source code is very readable, approachable, and heavily commented. A few interesting patches we did were:</p><p>因为我们正在重写整个应用程序，所以我们认为我们也可以刷新一下用户界面。考虑到Flatter的UI构建功能是多么强大，我们能够在不依赖任何外部LIB的情况下构建我们想要的UI/UX元素。如果我们不喜欢内置小部件的工作方式，我们只需复制它的源代码，调整它，修复导入路径，替换一些变量，就可以了。该框架的源代码可读性强，易于理解，并有大量注释。我们做了几个有趣的补丁：</p><p> A modified version of tab view with slightly different physics to allow a vertical scroll quickly after a horizontal page scroll. This is observable when quickly navigating certain screens.</p><p>tab view的一个修改版本，物理特性略有不同，允许在水平页面滚动之后快速进行垂直滚动。在快速浏览某些屏幕时可以观察到这一点。</p><p>  Customizations to many built-in widgets which we gradually removed as they improved with new versions of Flutter.</p><p>对许多内置小部件的定制，随着新版本的Flatter的改进，我们逐渐删除了这些小部件。</p><p> A modification to the WebSocket implementation in the Dart standard lib to add support for connection timeouts, which is crucial for mobile applications expected to be used with flaky internet connections. Unfortunately this issue ( web_socket_channel#61) doesn’t seem to get the attention it deserves.</p><p>对Dart标准库中的WebSocket实现进行了修改，以添加对连接超时的支持，这对于预期用于脆弱互联网连接的移动应用程序至关重要。不幸的是，这个问题（web_socket_channel#61）似乎没有得到应有的关注。</p><p> Also,  @knadh despised the default refresh indicator of iOS in React Native. We can neither confirm nor deny whether that was the actual reason to switch to Flutter. We are glad that we have a nice looking spinner out of the box now.</p><p>此外，@knadh轻视React Native中iOS的默认刷新指示器。我们既不能确认也不能否认这是否是切换到颤振的实际原因。我们很高兴我们现在有一个漂亮的纺纱机。</p><p>  One of the most important features of any investment platform is financial charting. We provide two different web based financial charting systems using WebViews. However, since the entire Flutter app is a 2D drawing on OpenGL/Metal surfaces, it is</p><p>任何投资平台最重要的特征之一就是财务图表。我们使用WebView提供了两种不同的基于web的财务图表系统。然而，由于整个颤振应用程序都是OpenGL/金属表面上的2D图形，所以它是</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/flutter/">#flutter</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/土生土长/">#土生土长</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/native/">#native</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/应用程序/">#应用程序</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>