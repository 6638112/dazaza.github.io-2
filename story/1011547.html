<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>结合使用Grok和Elasticsearch为数据添加结构</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">结合使用Grok和Elasticsearch为数据添加结构</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-07-14 00:53:02</div><div class="story_img_container"><a href="http://img.diglog.com/img/2020/7/097b3471c191b40e080030b5cb96edec.png"><img src="http://img.diglog.com/img/2020/7/097b3471c191b40e080030b5cb96edec.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>每个人都知道Elasticsearch在搜索方面非常出色，但有些人可能没有意识到Elasticsearch也是一个强大的分析引擎。为了充分利用Elasticsearch的分析功能，组织数据通常很有帮助。</p><p>在这篇博客中，我将讨论为什么结构化数据很重要，然后我将向您展示如何在Grok处理器中使用摄取节点为非结构化文档添加结构。然后，我将描述一种构造新Grok模式的简单方法，以及一种可用于调试现有Grok模式中的错误的方法。最后，我将提供一些公开可用的Grok模式的链接，然后简要介绍作为Grok的可能替代方案的DissectProcessor。</p><p>ElasticSearch是一个功能强大的分析引擎。但是，为了充分利用Elasticsearch的近乎实时的分析功能，在数据被吸收到Elasticsearch中时向其添加结构是很有用的。这方面的原因在写入时的架构与读取文章时的架构中有很好的解释。在本博客的其余部分中，当我们谈论结构化数据时，我们指的是写入时模式。</p><p>另外，如果您打算努力构建数据结构，则应该考虑构建数据结构，使其符合Elastic Common Schema，这将有助于分析来自不同来源的数据。</p><p>发送到Elasticsearch的文档与以下内容类似的情况并不少见：</p><p>上述文档中的消息字段包含非结构化数据。它是一系列不适合近实时分析的单词和数字。为了充分利用Elasticsearch强大的分析能力，我们应该解析消息字段来提取相关数据。例如，我们可以从上述消息中提取以下字段：</p><p>添加这样的结构将允许您在数据上释放Elasticsearch的全部功能。</p><p>Grok是一种工具，可用于从文档内的给定文本字段中提取结构化数据。您可以定义要从中提取数据的字段，以及匹配的Grok模式。Grok位于正则表达式之上。但是，与正则表达式不同，Grok模式由可重用模式组成，这些模式本身可以由其他Grok模式组成。</p><p>在详细介绍如何构建和调试您自己的Grok模式之前，我们首先简要概述Grok模式是什么样子，如何在摄取管道中使用它，以及如何模拟它。如果您还没有完全理解Grok表达式的细节，请不要担心，因为这些细节将在本博客的后续部分深入讨论。</p><p>通过使用以下Grok表达式，可以从该示例消息字段中提取所需的结构：</p><p>put_ingest/Pipeline/Example_grok_Pipeline{&#34；description&#34；：&#34；使用Grok&#34；，&#34；处理器&#34；的简单示例：[{&#34；grok&#34；：{&#34；field&#34；：&#34；message&#34；，&#34；pattern&#34；：[&#34；%{ip：host.ip}%{word：http.request.method}%{URIPATHPARAM：url.Original}%{number：http.request.bytes：int}%{number：event.uration：Double}%{GREEDYDATA}&#34；]}}。</p><p>发布_ingest/pipeline/example_grok_pipeline/_simulate{&#34；文档&#34；：[{&#34；_SOURCE&#34；：{&#34；消息&#34；：&#34；55.3.244.1获取/索引.html 15824 0.043其他内容&#34；}}]}。</p><p>{&#34；docs&#34；：[{&#34；doc&#34；：{&#34；_index&#34；：&#34；_index&#34；，&#34；_type&#34；：&#34；_doc&#34；，&#34；_id&#34；，&#34；_id&#34；，&#34；_source&#34；：{&#34；host&#34；：{&#34；ip&#34；：&#34；55.3.244.1&#34；}，&#34；http&#34；：{&#34；请求&#34；：{&#34；方法&#34；：&#34；获取&#34；，&#34；字节&#34；：15824}}，&#34；消息&#34；：&#34；55.3.244.1获取/索引.html 15824 0.043其他内容&#34；，&#34；事件&#34；：{&#34；持续时间&#34；：0.043}，&#34；url&#34；：{&#34；原始&#34；：&#34；/index.html&#34；}}，&#34；_ingest&#34；：{&#34；时间戳&#34；：&#34；2020-06-24T22：41：47.153985Z&#34；}]}。</p><p>该文档包含原始的非结构化邮件字段，还包含从邮件中提取的所有附加字段。我们现在有了一个包含结构化数据的文档！</p><p>在上面的示例中，我们模拟了包含Grok模式的摄取管道的执行，但实际上并没有在任何实际文档上运行它。如摄取节点文档中所述，摄取管道设计为在摄取时处理文档。执行摄取管道的一种方法是将管道名称添加到PUT命令，如下所示：</p><p>可替换地(并且可能优选地)，可以通过将其添加到索引设置来默认地将摄取流水线应用于写入到给定索引的所有文档：</p><p>将管道添加到设置后，写入EXMANCE_INDEX的任何文档都将自动应用EXMANCE_GROK_PIPELINE。</p><p>不出所料，它将返回我们刚刚编写的文档。本文档包含从消息字段提取的新字段：</p><p>{&#34；_index&#34；：&#34；example_index&#34；，&#34；_type&#34；：&#34；_doc&#34；，&#34；_id&#34；：&#34；2&#34；，&#34；_version&#34；：3，&#34；_seq_no&#34；：2，&#34；_primary_term&#34；：1，&#34；找到&#34；：true，&#34；_source&#34；：{&#34；host&#34；：{&#34；IP&#34；：&#34；66.3.244.1&#34；}，&#34；http&#34；：{&#34；请求&#34；：{&#34；方法&#34；：&#34；获取&#34；，&#34；字节&#34；：500}}，&#34；消息&#34；：&#34；66.3.244.1get/index.html 500 0.120新的其他内容&#34；，&#34；事件&#34；：{&#34；持续时间&#34；：0.12}，&#34；url&#34；：{&#34；原始&#34；：&#34；/index.html&#34；}。</p><p>然后，我们使用以下Grok模式从消息字段中提取结构化数据：</p><p>正如Grok Processor文档中所述，Grok模式的语法有三种形式：%{语法：语义}、%{语法}、%{语法：语义：类型}，所有这些都可以在上面的Grok模式中看到。语法是将与您的文本匹配的模式的名称。可以在GitHub上看到内置的语法模式。语义是将存储与语法模式匹配的数据的字段的名称。该类型是您希望强制转换命名字段的类型。</p><p>此声明将匹配IP地址(对应于IP Grok模式)，并将其存储在名为host.ip的字段中。这会将值55.3.244.1提取到我们之前执行的模拟中的host.ip字段。</p><p>如果我们需要有关IP Grok模式的更多详细信息，可以查看Github上的Grok模式，我们将看到以下定义：</p><p>这意味着IP模式将与IPv6或IPv4 Grok模式之一匹配。要理解什么是IPv6和IPv4模式，我们可以再次查看Github上的Grok模式以查看它们的定义，以此类推。</p><p>Grok模式的下一部分是单个空格字符，后跟以下表达式：</p><p>它将提取与单词模式匹配的字符序列，并将其存储到名为http.request.method的字段中。再一次，如果我们想要理解单词模式的定义，我们可以看看Github上的格罗克模式。</p><p>可以进行相同类型的分析，以了解与url.Original、request.bytes和event.uration字段匹配的模式，我们将这些字段留给读者作为练习。</p><p>该表达式没有语义部分，这意味着匹配的数据不会存储到任何字段中。此外，GREEDYDATA Grok模式将尽可能多地使用文本，这意味着在我们的示例中，它将匹配event.uration字段之后的所有内容。在调试复杂的Grok模式时，GREEDYDATA表达式将派上用场，本博客的以下部分将对此进行讨论。</p><p>在构建新的Grok模式时，通常最容易的方法是从左侧开始逐步构建Grok模式，直到我们试图匹配的非结构化文本的右侧。</p><p>可以帮助构建和调试Grok模式的两个工具是我们在本文前面使用的模拟管道API和Kibana的Grok调试器。此处显示的渐进式构造方法将同样适用于这两种工具中的任何一种。</p><p>让我们假设我们被告知要编写一个Grok模式来解析以下消息(与前面的消息相同)：</p><p>我们还假设已被告知要将上述数据构建为符合ECS的字段名，并且我们已收到关于上述消息的以下信息：</p><p>剩下的文本只是一些我们不关心的附加文本。</p><p>根据这些说明，对于上述消息，我们希望提取以下符合ECS的字段，正如我们在本博客前面讨论的那样：</p><p>请记住，我们正在从左到右递增地构建Grok表达式。那么，让我们先看看是否能从消息中提取出IP地址。我们将使用IP Grok模式匹配host.ip字段，使用GREEDYDATA模式捕获IP地址之后的所有内容。这将如下所示：</p><p>让我们使用Kibana的Grok调试器来查看此Grok模式是否能够解析消息。这将如下所示：</p><p>已按预期工作-已正确提取host.ip字段，并且消息的其余部分已存储在my_greedy_match中。</p><p>让我们添加Grok模式的下一部分。我们知道这是http.request.method字段，这是一个Word Grok模式。因此，我们对Grok模式进行了如下增强：</p><p>但是，如下所示，在Kibana的调试器中测试会得到空响应。这不是我们想要的！</p><p>响应为空的原因是因为模式不匹配。这是因为消息在host.ip(在本例中为55.3.244.1)和request.method(在本例中为get)之间有一个空格，但是我们在Grok模式中没有包含空格。让我们修复这个错误，然后使用以下Grok模式重试。</p><p>这招奏效了！现在我们已经提取了host.ip和http.request.method字段。但我们仍有工作要做，以解析其余字段。我们可以继续递增地添加到Grok模式中，直到最终得到以下Grok模式：</p><p>它就像预期的那样工作！但是，(对于本例)我们对保留MY_GREEDY_MATCH字段不感兴趣，因此我们可以将其从Grok表达式中删除，如下所示：</p><p>这看起来就是我们想要的样子！我们现在有了一个Grok模式，我们可以使用它来构建包含在消息字段中的数据的结构。</p><p>我们还可以使用模拟管道API或Kibana的Grok调试器来帮助我们调试损坏的Grok模式。下面描述的分而治之的方法与这两种工具一样可以很好地工作，应该可以帮助您快速找到Grok模式与您的数据不匹配的原因。</p><p>假设我们正在尝试解析一条相对较长的消息，例如下面的消息，它是来自Elasticsearch慢速日志的条目。</p><p>让我们假设我们在Internet上发现了以下Grok模式，我们被告知应该解析Elasticsearch慢日志，但由于某些原因它不起作用！</p><p>我们可以使用Kibana的Grok调试器来尝试找出错误所在。我们将数据和Grok模式粘贴到Grok调试器中，如下所示：</p><p>结构化数据响应为空，这确认Grok模式与样本数据不匹配。让我们通过定义一个我们知道将匹配任何内容的模式来确保Grok调试器正常工作，并将结果存储在名为MY_GREEDY_MATCH的字段中。这可以通过将Grok模式定义为%{GREEDYDATA：MY_GREEDEDY_MATCH}来实现。这将产生如下所示的输出：</p><p>对于此模式，Grok已将样本数据的全部内容存储到名为my_greedy_match的字段中，这正是我们在此测试中所期望的。</p><p>接下来，我们开始一种分而治之的方法，找出Grok模式中的错误所在。我们可以通过将中断的Grok模式的大约前半部分复制到一个新表达式中，并用我们刚才看到的GREEDYDATA表达式替换后半部分来实现这一点。这个新的Grok模式如下所示：</p><p>将此Grok模式粘贴到Kibana的Grok Debugger后，我们看到结构化数据响应仍然为空。</p><p>这意味着错误出现在Grok模式的前半部分。所以让我们再把它一分为二，如下所示：</p><p>将其粘贴到Kibana的调试器中，如下所示显示已正确提取结构化数据：</p><p>现在我们知道Grok模式的第一个季度没有错误，并且在Grok模式的中点之前有错误。因此，让我们将GREEDYDATA表达式放在原始Grok模式的大约3-8个位置，如下所示：</p><p>在Kibana的调试器中，这将如下所示-这是匹配的。</p><p>所以我们知道误差在3-8点和格罗克模式的中点之间。让我们尝试添加更多原始Grok模式，如下所示：</p><p>因此，在提取slowlog.shard.int值之后出现了一些问题。如果我们重新检查我们正在解析的消息，我们将看到所提取的字符串前面应该有一个空格字符。让我们修改Grok模式，看看当我们在Take前面指定一个空格时它是否工作，如下所示：</p><p>但是我们仍然在my_greedy_match中存储了大量数据。让我们重新添加原始Grok模式的其余部分，如下所示：</p><p>格罗克模式奏效了！现在，我们已经从以前的非结构化慢速日志条目中提取了结构化数据。</p><p>使用基本的Grok模式，您可以构建复杂的模式来匹配您的数据。此外，弹性堆栈附带了许多可重复使用的摸索模式。有关模式的完整列表，请参见摄取节点摸索模式和日志存储摸索模式。</p><p>在某些情况下，可以使用解剖处理器从单个文本字段中提取结构化字段。与Grok处理器类似，DISSECT还从文档中的单个文本字段中提取结构化字段。但是，与Grok处理器不同的是，DISSECT不使用正则表达式。这使得DISSECT的语法很简单，并且可能比Grok处理器更快。</p><p>在本博客中，我们讨论了为什么组织数据有助于利用Elasticsearch的分析功能。然后，我们展示了如何使用Grok来结构化非结构化数据。接下来，我们展示了增量构建Grok模式的简单方法，以及调试现有Grok模式中的错误的方法。最后，我们提供了一些公开可用的Grok模式的链接，并简要介绍了作为Grok的替代方案的DissectProcessor。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://alexmarquardt.com/using-grok-with-elasticsearch-to-add-structure-to-your-data/">https://alexmarquardt.com/using-grok-with-elasticsearch-to-add-structure-to-your-data/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/grok/">#grok</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>