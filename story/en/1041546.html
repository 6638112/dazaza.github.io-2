<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>C ++使用指令如何工作？ How do C++ using-directives work?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How do C++ using-directives work?<br/>C ++使用指令如何工作？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-24 21:18:16</div><div class="page_narrow text-break page_content"><p>A using-declaration is semantically similar to a declaration;it introduces into the current scope a new meaning for a name. If thatname already had one or more meanings from outer scopes, those existingmeanings are  hidden, or  shadowed, by the new declaration. Godbolt:</p><p>使用声明在语义上类似于声明；它在当前范围内引入了名称的新含义。如果该名称已经具有来自外部作用域的一个或多个含义，则这些现有的含义将被新声明隐藏或遮盖。 Godbolt：</p><p> namespace AnimalUtils { int foo(Zoo::Animal);}namespace Outer { int foo(Zoo::Lion); namespace Inner { int foo(Zoo::Cat); // declaration hides Outer::foo int test1() { return foo(Zoo::Lion()); } int test2() { using AnimalUtils::foo; // using-declaration hides Inner::foo return foo(Zoo::Lion()); // calls AnimalUtils::foo } }}</p><p> 命名空间AnimalUtils {int foo（Zoo :: Animal）;}命名空间Outer {int foo（Zoo :: Lion）;命名空间Inner {int foo（Zoo :: Cat）; //声明隐藏了Outer :: foo int test1（）{return foo（Zoo :: Lion（））; } int test2（）{使用AnimalUtils :: foo; // using-declaration隐藏Inner :: foo return foo（Zoo :: Lion（））; //调用AnimalUtils :: foo}}}</p><p> The declaration of  foo in  Inner  hides, or  shadows, the previous meaning that  foo had had;so when we look up the name  foo inside  test1, we find only  Inner::foo.We don’t even consider  Outer::foo as a candidate.</p><p> Inner中foo的声明隐藏或覆盖了foo之前的含义；因此，当我们在test1中查找名称foo时，我们仅发现Inner :: foo。甚至不将Outer :: foo视为候选人。</p><p> The using-declaration of  foo in  test2  hides, or  shadows, the previous meaning that  foohad had; so when we look up the name  foo inside  test2, we find only  AnimalUtils::foo.We don’t even consider  Inner::foo as a candidate.</p><p> 在test2中对foo的使用声明隐藏或遮盖了foohad的先前含义；因此，当我们在test2中查找名称foo时，只会发现AnimalUtils :: foo。我们甚至都没有考虑将Inner :: foo作为候选对象。</p><p> (So how does  the  std::swap two-step work?Well, besides the normal unqualified lookup, we also do a  separate argument-dependent lookup,and merge the two candidate sets. So in this particular case, overload resolution would alsoconsider any meanings of  foo declared in namespace  Zoo. But there is no such  foo inthis example.)</p><p> （所以std :: swap两步工作如何工作？那么，除了正常的不合格查找外，我们还进行单独的参数依赖查找，并合并两个候选集。因此，在这种特殊情况下，重载解析也将考虑任何在名称空间Zoo中声明的foo的含义。但是此示例中没有这样的foo。）</p><p>  Using-directives are subtler than using-declarations. But the good news is that you should never use them!Seriously, don’t ever write  using namespace Whatever; and then you won’t haveany trouble with them. Just pretend they don’t exist.</p><p>  using指令比using声明更巧妙。但是，好消息是您永远不要使用它们。严重的是，永远不要使用命名空间进行写操作。这样您就不会遇到任何麻烦。只是假装它们不存在。</p><p>  Using-directives also introduce new meanings for names into scopes. But the surprisingthing is that they don’t introduce those meanings into the  current scope! A using-directiveintroduces its new meanings into the scope which is the lowest common ancestorof the current scope and the target namespace’s own scope.</p><p>  使用指令还将名称的新含义引入范围。但是令人惊讶的是，他们没有将这些含义引入当前的范围！ using指令将其新含义引入范围，该范围是当前范围和目标名称空间自己的范围的最低共同祖先。 </p><p> In a directed acyclic graph (DAG), the “lowest common ancestor” of two nodes  A and  Bcan be found by tracing a path from  A up to the root, and tracing a path from  B up tothe root — the lowest common ancestor is the place where the two paths first meet up.</p><p>在有向无环图（DAG）中，可以通过追踪从A到根的路径，再追踪从B到根的路径来找到两个节点A和B的“最低共同祖先” —最低共同祖先是两条路径首先汇合的地方。</p><p> Alternatively, start tracing a “fully qualified path” downward from the root; thelowest common ancestor corresponds to the longest common prefix of these fully qualifiednames. For example, consider this hierarchy of namespaces:</p><p> 或者，从根向下开始跟踪“完全限定的路径”；最低的公共祖先对应于这些完全限定名称中的最长的公共前缀。例如，考虑以下名称空间层次结构：</p><p> namespace NA { }namespace NB { namespace NC { namespace N1 { } namespace N2 { } }}</p><p> 名称空间NA {}名称空间NB {名称空间NC {名称空间N1 {}名称空间N2 {}}}</p><p> The lowest common ancestor of  NB::NC::N1 and  NB::NC::N2 is  NB::NC.The lowest common ancestor of  NA and  NB::NC::N2 is the root (the global namespace).</p><p> NB :: NC :: N1和NB :: NC :: N2的最低公共祖先是NB :: NC.NA和NB :: NC :: N2的最低公共祖先是根（全局命名空间）。</p><p>  namespace NA { int foo(Zoo::Lion);}namespace NB { int foo(Zoo::Lion); namespace NC { namespace N1 { int foo(Zoo::Cat); } namespace N2 { int test() { using namespace N1; using namespace NA; return foo(Zoo::Lion()); } } }}</p><p>  命名空间NA {int foo（Zoo :: Lion）;}命名空间NB {int foo（Zoo :: Lion）;名称空间NC {名称空间N1 {int foo（Zoo :: Cat）; }命名空间N2 {int test（）{使用命名空间N1;使用名称空间NA；返回foo（Zoo :: Lion（））; }}}}</p><p> You might reasonably expect that when  test passes a  Lion to  foo,it would result in a call to  NA::foo(Lion), because we “using-directive’d” namespace NA. Or at least it might call  NB::foo(Lion), since that’swhat would happen in the absence of any using-directives at all.But in fact it calls  N1::foo(Cat)!</p><p> 您可能有理由期望，当测试将Lion传递给foo时，它将导致对NA :: foo（Lion）的调用，因为我们“使用指令的”命名空间NA。或至少它可以称为NB :: foo（Lion），因为在完全没有任何使用指令的情况下会发生这种情况。但实际上，它称为N1 :: foo（Cat）！</p><p> As shown in the diagram below:  using namespace N1 causes a declaration of N1::foo(Cat) to be injected into the least common ancestor of  N1 and  N2,which is  NC. This declaration of the name  foo  hides any and all meaningsof  foo introduced in higher-up scopes, such as  NB::foo(Lion).</p><p> 如下图所示：使用命名空间N1导致将N1 :: foo（Cat）声明注入到N1和N2的最小公祖中，即NC。此名称foo的声明隐藏了在更高范围内引入的foo的所有含义，例如NB :: foo（Lion）。 </p><p> using namespace NA causes a declaration of  NA::foo(Lion) to be injectedinto the least common ancestor of  NA and  N2, which is the global namespace.This injected declaration ends up being hidden by the declaration of  NB::foo(Lion),which is in turn hidden by the declaration of  N1::foo(Cat) which has beeninjected into namespace  NC.</p><p>使用命名空间NA会导致将NA :: foo（Lion）的声明注入到NA和N2的最小公共祖先中，这是全局命名空间。此注入的声明最终被NB :: foo（Lion）的声明隐藏。 ，而这又被注入到命名空间NC中的N1 :: foo（Cat）声明所隐藏。</p><p>  By the way, even though the declaration of  N1::foo has been injected into  NC,you can’t actually refer to it as  NC::foo. It has been injected only for the purposesof  unqualified lookups — and only for the purposes of unqualified lookups that happenwithin this scope. Nobody outside of the scope of  test is going to “see” thatdeclaration of  foo injected into namespace  NC.</p><p>  顺便说一句，即使N1 :: foo的声明已经注入到NC中，您实际上也不能将其称为NC :: foo。它仅出于不合格查找的目的而注入，并且仅出于在此范围内发生的不合格查找的目的而注入。测试范围之外的任何人都不会“看到”将foo声明注入名称空间NC的声明。</p><p>   namespace detail { struct Impl {}; void swap(Impl&amp;, Impl&amp;); template&lt;class T&gt; void example(T&amp; x, T&amp; y) { using namespace std; swap(x, y); }}</p><p>   命名空间详细信息{struct Impl {}; void swap（Impl＆amp ;, Impl＆amp;）;模板＆lt; T类＆gt; void example（T＆amp; x，T＆amp; y）{使用命名空间std; swap（x，y）; }}</p><p> It’s bad for three reasons. Number one, it fails to use the hidden friend idiomfor  swap(Impl&amp;, Impl&amp;). Number two, it uses  using namespace std. (Both of these arered flags that should insta-fail any code review you do.)Number three, its use of  using namespace is wrong in terms of the “ std::swap two-step.”(See  “What is the  std::swap two-step?” (2020-07-11).)In the two-step, we  want to bring the meaning of  swap from namespace  std into our current scope,so that  swap(x, y) will consider that meaning in addition to any meaning assignedby ADL. But what we’re doing here, instead, is to bring the meaning of  swap (and everyother name in  std) from namespace  std into  the least common ancestor namespace of std and  detail; i.e., into the global namespace.</p><p> 不好的原因有三个。第一，它无法使用隐藏的朋友习惯用法进行交换（Impl＆amp;，Impl＆amp;）。第二，它使用命名空间std。 （这两个标记都应该使您进行的任何代码检查都无法通过。）第三，就“ std :: swap两步操作”而言，使用命名空间是错误的。（请参阅“什么是std： ：swap two-step？”（2020-07-11）。）在这两个步骤中，我们希望将名称空间std的swap的含义带入当前作用域，以便swap（x，y）会考虑该含义。除了ADL分配的任何含义。但是，我们要做的是将交换（以及std中的其他名称）的含义从std名称空间引入到std和detail的最不常见的祖先名称空间中；即进入全局名称空间。</p><p> So when we try to instantiate  example&lt;int&gt;, unqualified lookup looks for declarations of swap in our current scope working outward, and it finds  detail::swap(Impl&amp;, Impl&amp;) and stopsthere. It never finds the templated  std::swap declared in the global namespace. Oops!That’s why the  correct version of the  std::swap two-step uses a using-declaration andnot a using-directive.</p><p> 因此，当我们尝试实例化example＆lt; int＆gt;时，不合格的查找将在我们当前作用域中向外寻找交换的声明，并查找detail :: swap（Impl＆amp ;, Impl＆amp;）并在那里停止。它永远找不到在全局名称空间中声明的模板化std :: swap。糟糕！这就是为什么正确的std :: swap两步版本使用using-声明而不是using-directive的原因。</p><p>   namespace ND::N3 { int foo(Zoo::Cat);}namespace NE { using namespace ND::N3; int foo(Zoo::Lion);}namespace ND { namespace N4 { int test3() { using namespace NE; return foo(Zoo::Lion()); } }}</p><p>   名称空间ND :: N3 {int foo（Zoo :: Cat）;}名称空间NE {使用名称空间ND :: N3; int foo（Zoo :: Lion）;}命名空间ND {命名空间N4 {int test3（）{使用命名空间NE;返回foo（Zoo :: Lion（））; }}}</p><p> Using-directives are “transitive”; since  NE visibly contains a using-directivefor  ND, it’s as if  test3 contains  both  using namespace NE  and  using namespace ND::N3.</p><p> 使用指令是“传递”的；由于NE显然包含ND的using指令，因此test3似乎同时包含使用命名空间NE和使用命名空间ND :: N3。 </p><p> In this contrived example, the names from  NE are injected into the least common ancestorof  ND::N4 and  NE (i.e., the global namespace). The names from  ND::N3 are injected into theleast common ancestor of  ND::N4 and  ND::N3 (i.e.,  ND). Then, unqualifiedlookup for  foo scans outward from  ND::N4::test3, stopping as soon as it finds the declaration of ND::N3::foo(Cat) that has been injected into namespace  ND. That declaration  hidesthe ostensibly better-matching  NE::foo(Lion) that was injected into the global namespace.</p><p>在这个人为的示例中，来自NE的名称被注入到ND :: N4和NE的最不常见祖先（即全局名称空间）中。将ND :: N3中的名称注入ND :: N4和ND :: N3（即ND）的最小公共祖先中。然后，foo的unqualifiedlookup从ND :: N4 :: test3向外扫描，并在找到已注入命名空间ND的ND :: N3 :: foo（Cat）声明后立即停止。该声明隐藏了表面上更好匹配的NE :: foo（Lion），它被注入到全局名称空间中。</p><p> Note that the “transitivity” of using-directives applies only to using-directives that are  directlywithin the using’ed namespace. If  test3 had said  using namespace NE::N5, it would havetransitively picked up the using-directives from  NE::N5, but not from its parent namespace  NE(and not from the global namespace).</p><p> 请注意，using指令的“传递性”仅适用于using命名空间中直接存在的using指令。如果test3说使用命名空间NE :: N5，它将从NE :: N5而不是从其父命名空间NE（而不是从全局命名空间）中选择使用指令。</p><p> And how does all this interact with   inline namespace?Well, let’s save that for another day.</p><p> 以及所有这些如何与内联名称空间交互？好吧，让我们再保留一天。</p><p>  Some of these examples probably surprised you. I hope the explanations made sense anyway, in retrospect.But is any of this information  useful to a good C++ programmer? I would have to say  no it is not.Good C++ programmers don’t use using-directives — and I hope this blog post has convinced youto join them!</p><p>  其中一些示例可能会让您感到惊讶。回顾一下，我希望这些解释还是有意义的，但是这些信息对优秀的C ++程序员有用吗？我不得不说不，不是。好的C ++程序员不要使用using指令-我希望这篇博客文章已说服您加入他们！</p><p>  As for  why using-directives work in this bizarrely unintuitive way, I’ve asked thatquestion  over on Stack Overflow.So if you’ve got a good answer, that’s a great place to type it up!</p><p>  至于为什么使用指令以这种奇怪的，不直观的方式工作，我已经在Stack Overflow上询问了这个问题。因此，如果您有一个好的答案，那是输入它的好地方！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://quuxplusone.github.io/blog/2020/12/21/using-directive/">https://quuxplusone.github.io/blog/2020/12/21/using-directive/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/foo/">#foo</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>