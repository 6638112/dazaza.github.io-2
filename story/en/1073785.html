<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>基于回合的游戏的网络化Networking of a turn-based game</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Networking of a turn-based game<br/>基于回合的游戏的网络化</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 10:17:03</div><div class="page_narrow text-break page_content"><p>3 years ago, I started developing   Swords &amp; Ravens, an open-source online multi-player adaptation of a strategy board game I love,  A Game of Thrones: The Board Game (Second Edition), designed by Christian T. Petersen and published by  Fantasy Flight Games. As of Febuary 2022, around 500 players gather daily on the platform and more than 2000 games have been played since its release. While I stopped actively developping S&amp;R, the platform is still seeing new features being added thanks to the work of the open-source community.</p><p>3年前，我开始研发剑与剑；Ravens是一款开源的在线多玩家游戏，改编自《我爱》战略棋盘游戏《权力的游戏：棋盘游戏》（第二版），由Christian T.Petersen设计，由Fantasy Flight Games出版。截至2022年2月，每天约有500名玩家聚集在该平台上，自发布以来，已经玩了2000多个游戏。当我停止积极开发S&amp；R、 由于开源社区的努力，该平台仍在增加新功能。</p><p>  I’ve learned a lot while developing S&amp;R, and I wanted to share some of the knowledge I’ve gained to people that might be interested in doing a similar project. There is a lot to say about how it works but this blog post will focus on how I’ve designed the networking part of the game. I’ll first describe the problem in a more formal way. I’ll continue by explaining how it’s solved in S&amp;R, as well as describe other possible solutions that I’ve discovered or imagined. I’ll detail the advantages &amp; disadvantages of each method and conclude with which method I think is the best (Spoiler alert: it’s the last one 👀).</p><p>我在开发S&amp；R、 我想把我学到的一些知识分享给可能有兴趣做类似项目的人。关于它是如何工作的，有很多话要说，但这篇博文将重点介绍我如何设计游戏中的网络部分。我将首先以更正式的方式描述这个问题。我将继续解释如何在s&amp；R、 以及描述我发现或想象的其他可能的解决方案。我将详细介绍其优点和优点；每种方法的缺点，并总结出我认为最好的方法（剧透警告：这是最后一种）👀).</p><p>  In a single-player game, everything lives inside a single computer. The player’s actions are applied to the game state, and modifications to this game state are reflected on the screen of the player. In an online multiplayer environment, things are different. Each player is playing on its own computer, which all have their own current information about the game, and which all have their own UI to display the current state of the game.</p><p>在单人游戏中，所有东西都生活在一台计算机中。玩家的动作将应用于游戏状态，对该游戏状态的修改将反映在玩家的屏幕上。在在线多人游戏环境中，情况就不同了。每个玩家都在自己的电脑上玩，电脑上都有自己当前的游戏信息，并且都有自己的UI来显示游戏的当前状态。</p><p>           UI           Client A        Server            Pl...        Game State        Game State                 UI        Client B            Pl...        Game State               Viewer does not support full SVG 1.1  The  UI displays to the player the current state of the game, based on the local copy of the state of the game. The  Clients are responsible for the communication with the server, both to send the actions of the player and to receive new information about the game state.</p><p>用户界面客户端服务器程序。。。游戏状态游戏状态用户界面客户端程序。。。游戏状态查看器不支持完整的SVG 1.1。UI根据游戏状态的本地副本向玩家显示游戏的当前状态。客户端负责与服务器的通信，既发送玩家的动作，又接收有关游戏状态的新信息。</p><p> The problem we’re interested in solving is how to synchronize the different local states of the game of the clients with the game state of the server. More specifically: when the server applies the action of a player to its game state, how must it communicate the modifications to the game state to the clients.</p><p>我们感兴趣的问题是如何将客户端游戏的不同本地状态与服务器的游戏状态同步。更具体地说：当服务器将玩家的动作应用于其游戏状态时，它必须如何将对游戏状态的修改传达给客户端。</p><p>  The most obvious solution is to apply any action received by the server to the game and transmit the different updates to the state of the game to the clients. The following diagram shows it in action.</p><p>最明显的解决方案是将服务器接收到的任何操作应用于游戏，并将游戏状态的不同更新传输给客户端。下图显示了它的作用。</p><p>          Client A        Client B        Server             Attack King&#39;s Landing with Fo...                Remove Footman from Wint...        Add Footman in King&#39;s La...        Start Fight in King&#39;s La...          Remove Footman from Wint...        Add Footman in King&#39;s La...        Start Fight in King&#39;s La...        Viewer does not support full SVG 1.1  This is the method used by Swords &amp; Ravens. It’s simple, intuitive and it’s easy to know which kind of data you’re sending or not to the different clients. This also makes it trivial to have secret data (i.e. data that should only be known to a subset of the players). If a player draws a card and place it in his (secret) hand, then you can transmit which card was drawn only to this player so that no other player knows which card it is.</p><p>客户端A客户端B服务器攻击王&#39；他和Fo一起着陆。。。从Wint中删除Footman。。。在King&#39中添加步兵；s洛杉矶。。。在King&#39开始战斗；s洛杉矶。。。从Wint中删除Footman。。。在King&#39中添加步兵；s洛杉矶。。。在King&#39开始战斗；s洛杉矶。。。查看器不支持完整的SVG 1.1。这是刀剑&amp；乌鸦。它简单、直观，并且很容易知道您正在向不同的客户发送或不发送哪种数据。这也使得拥有秘密数据变得微不足道（即，应该只有一部分玩家知道的数据）。如果一名玩家抽到一张牌，并将其放在他的（秘密）手中，那么你可以只将抽到的牌传送给该玩家，这样其他玩家就不会知道这是哪张牌。</p><p> The first downside to this method is that you must code all the possible updates to the state of your game. While there are certainly ways to automate this in JS using, for example, decorators to control the access to the variables of your game state, it may make your code less readable.</p><p>这种方法的第一个缺点是，必须对游戏状态的所有可能更新进行编码。当然，在JS中有一些方法可以自动实现这一点，例如使用装饰程序来控制对游戏状态变量的访问，但这可能会降低代码的可读性。</p><p> The second downside is that since you’re possibly sending multiple updates for a single action, the local game state of a client might temporarily be in an invalid state before all the updates have been received. In the diagram shown above, between the update  Remove footman in Winterfell and  Add footman in Kings&#39; Landing, there is a missing Footman which would modify the count of Footman shown in the UI. Though this particular issue could be solved by sending a combined update (for example  Move Footman Footman from Winterfell to King&#39;s Landing), not all updates can easily be concatenated.</p><p>第二个缺点是，由于您可能会为一个操作发送多个更新，因此在收到所有更新之前，客户端的本地游戏状态可能暂时处于无效状态。在上图中，在更新“冬城移除步兵”和“国王添加步兵”之间&#39；着陆时，缺少一名步兵，这将修改UI中显示的步兵数量。虽然这个特殊问题可以通过发送一个组合更新来解决（例如，将步兵从冬城移动到国王登陆），但并非所有更新都可以轻松连接。</p><p> A better way to address this would be to combine all the updates done because of the action and send them at once. This is essentially what the next method is about.</p><p>解决这一问题的更好方法是合并由于该操作而完成的所有更新，并立即发送它们。这就是下一种方法的本质。</p><p>  The delta-update propagation method works by computing the delta between the new state of the game and the state of the game before the action was applied. This delta is then sent to the clients so that they can apply it to their own local state of the game. This is how the game engine  boardgame.io works.</p><p>增量更新传播方法的工作原理是计算游戏的新状态与应用动作之前的游戏状态之间的增量。然后将该增量发送给客户端，以便他们可以将其应用于自己的本地游戏状态。这就是游戏引擎boardgame的方式。木卫一工作。</p><p>          Client A        Client B        Server             Attack King&#39;s Landing with Fo...            Remove Footman in King&#39;s Landing,...        Remove Footman in King&#39;s Landing,...      Viewer does not support full SVG 1.1  This solves the 2 downsides described in the previous method. We no longer need to code all the possible updates, since once you change something, it will be computed in the delta after the action has been processed. You no longer get transient invalid states, since the updates will be applied at once, atomically.</p><p>客户端A客户端B服务器攻击王&#39；他和Fo一起着陆。。。移除《国王与#39》中的男仆；s着陆，。。。移除《国王与#39》中的男仆；s着陆，。。。查看器不支持完整的SVG 1.1。这解决了前面方法中描述的两个缺点。我们不再需要对所有可能的更新进行编码，因为一旦您更改了某些内容，它将在操作处理后在增量中进行计算。您不再会获得暂时的无效状态，因为更新将立即以原子方式应用。</p><p> One thing we’ve lost, though, is the easiness of managing secret state. If you want to prevent some secret information to be sent to a specific client, the server must filter the delta out of any potential private information before sending it to the clients.</p><p>然而，我们失去了一件事，那就是管理秘密国家很容易。如果要防止某些机密信息被发送到特定客户机，服务器必须在将其发送到客户机之前过滤掉任何潜在的私人信息。</p><p>   It relies on the assumption that processing the actions of a player is deterministic, meaning that for a given state of the game, applying an action will always give us the same resulting state of the game. We can exploit this property to avoid having to propagate the updates to the state of the game to the clients. Instead, the server can apply the action it has received from the client, and then propagate this action to the clients who can then apply the action to derive their own new game state. Since applying the action is deterministic, the clients will arrive at the same state of the game as the server.  1</p><p>它依赖于这样一个假设，即处理玩家的动作是确定性的，这意味着对于给定的游戏状态，应用一个动作将始终为我们提供相同的游戏结果状态。我们可以利用这个属性来避免将游戏状态的更新传播给客户端。相反，服务器可以应用它从客户机收到的操作，然后将此操作传播给客户机，然后客户机可以应用该操作来派生自己的新游戏状态。由于应用动作是确定性的，客户端将达到与服务器相同的游戏状态。1.</p><p>          Client A        Client B        Server             Attack King&#39;s Landing with Fo...            Attack King&#39;s Landing wit...        Attack King&#39;s Landing wit...      Viewer does not support full SVG 1.1   First, we don’t need to code additional network logic in our code. The only thing that needs to be implemented is the propagation of the action done by the players.</p><p>客户端A客户端B服务器攻击王&#39；他和Fo一起着陆。。。攻击国王&#39；是降落机智。。。攻击国王&#39；是降落机智。。。查看器不支持完整的SVG1.1。首先，我们不需要在代码中编写额外的网络逻辑。唯一需要实现的是传播玩家所做的动作。</p><p> Secondly, bandwidth consumption isn’t tied to the size of the modifications done to the game state. If a single player action changes 1000 entities in our game state, the server will still only need to transmit the action and not the changes. This is actually  the reason why deterministic lockstep is used for real-time strategy games, such as Age of Empires. While it is quite uncommon for turn-based games (even less so for board games) to have lots of moving entities when performing an action, having this opens up new possibilities for turn-based games.</p><p>其次，带宽消耗与对游戏状态所做修改的大小无关。如果一个玩家的动作在我们的游戏状态中改变了1000个实体，服务器仍然只需要传输动作，而不需要传输更改。这就是为什么确定性锁步被用于实时战略游戏的原因，比如《帝国时代》。虽然回合制游戏（棋盘游戏更不常见）在执行动作时会有很多移动实体，但这为回合制游戏开辟了新的可能性。</p><p> Thirdly, since the actual gameplay code is run on the client, we can perform animations of the different updates done to the game state. For example, if a player action would reduce their amount of money by 10 and then raise it by 40, we could play 2 different animations client-side while with the previous solution, we would only receive from the server the fact that the amount of money was raised by 30, preventing the client from doing so.</p><p>第三，由于实际的游戏代码是在客户端上运行的，我们可以对游戏状态进行不同更新的动画。例如，如果一个玩家的动作会将他们的钱减少10，然后增加40，我们可以在客户端播放两个不同的动画，而在之前的解决方案中，我们只会从服务器收到这样一个事实，即筹集的钱是30，这阻止了客户端这样做。</p><p> Fourthly, when the player decides to perform an action, the client can directly apply the action to its own game state after sending it to the server without waiting for confirmation from the server. This process, called “optimistic update”, allows us to provide a lag-free experience to the players.</p><p>第四，当玩家决定执行一个动作时，客户端可以在将动作发送到服务器后直接将其应用到自己的游戏状态，而无需等待服务器的确认。这一过程被称为“乐观更新”，让我们能够为玩家提供无滞后体验。</p><p> Overall, this solution is quite elegant. We just need to implement the propagation of the actions of the player and once it’s done,  ta-da, we can focus on implementing the gameplay and don’t need to touch the networking code at all!</p><p>总的来说，这个解决方案相当优雅。我们只需要实现玩家行为的传播，一旦完成，我们就可以专注于实现游戏性，而不需要接触网络代码！</p><p> There is one big downside, though. To make sure that the clients and the server arrives at the same game state after processing an action, we must ensure that they both possess exactly the same game state initially. At first, this might make you think that it would be impossible to have secret state. Indeed, how could we have state that is only kept server-side if our networking solution relies on the game state being the same between all actors?</p><p>不过，有一个很大的缺点。为了确保客户端和服务器在处理一个动作后到达相同的游戏状态，我们必须确保它们最初都拥有完全相同的游戏状态。一开始，这可能会让你觉得不可能有秘密状态。事实上，如果我们的网络解决方案依赖于所有参与者之间的游戏状态相同，我们怎么可能只有服务器端的状态？</p><p>  We can solve this issue quite elegantly by allowing the clients to slightly differ from the server. If an action requires state that was previously hidden to one or multiple clients, we can make the server reconciliates the difference by sending this specific part of the game state to the clients.</p><p>通过允许客户机与服务器略有不同，我们可以非常优雅地解决这个问题。如果一个动作需要一个或多个客户端之前隐藏的状态，我们可以让服务器通过向客户端发送游戏状态的这一特定部分来协调差异。</p><p> Let’s illustrate this with an example from Swords &amp; Ravens. When a player moves their army into the territory of another player, they trigger a combat. Resolving a combat in S&amp;R involves both players simultaneously choosing, from their hand, a general of their house to lead their armies. This mechanic leads to intense mind-games where both players try to guess which general their opponent will take so they can pick the appropriate counter, while wondering if their opponent will not plan for this and take the counter of the counter, requiring you to pick the counter of the counter of the counter, and so on.</p><p>让我们用《剑与剑》中的一个例子来说明这一点；乌鸦。当一个玩家将他们的军队移动到另一个玩家的领地时，他们会触发一场战斗。解决S&amp；R涉及两名玩家同时从他们手中选择一名将军来领导他们的军队。这种机制会导致激烈的心智游戏，两名玩家都会尝试猜测对手将选择哪种将军，以便选择合适的计数器，同时怀疑对手是否不会计划这样做，并选择计数器的计数器，要求你选择计数器的计数器，以此类推。</p><p> Obviously, it is important to keep secret the choice of one of the opposing players if the other player has not made their choice yet.</p><p>显然，如果对方球员还没有做出选择，保密对方球员的选择是很重要的。</p><p>           Client A        Client B        Server             Choose Tywin Lannister            (A) Choose a card        (A) Choose Tywin Lannister          Choose Margeary Tyrell            (B) Choose Margeary Tyrel...        (B) Choose a card...        Clients and server have the same game state, proceed safely        Client B&#39;s game state differs from Server&#39;s game state         Viewer does not support full SVG 1.1  When  Client A sends their action to the server (Choosing Tywin Lannister), we propagate this action to both players, but not before filtering the chosen leader out of the message sent to  Client B. At this point,  Client B’s game state differs from  Server’s game state since it does not know which leader  A has chosen. When  Client B sends their action (Choosing Margaery Tyrell), we apply the same logic and filter out the chosen leader out of the message sent to  Client A. Since both players have chosen their leaders, we can reconciliate the differences in game state by sending out the choice of the other players. After this little manoeuver, all clients have the same game state and can resolve the rest of the combat deterministically.</p><p>客户A客户B服务器选择泰温·兰尼斯特（A）选择卡片（A）选择泰温·兰尼斯特选择玛格利·泰瑞尔（B）选择玛格利·泰瑞尔。。。（B） 选择一张卡片。。。客户端和服务器有相同的游戏状态，安全地进行客户端B和#39；s的游戏状态不同于服务器&#39；s game state Viewer不支持完整的SVG 1.1。当客户端A将其操作发送到服务器（选择Tywin Lannister）时，我们会将此操作传播给两名玩家，但不会在从发送到客户端B的消息中筛选出所选的领导者之前，客户机B的游戏状态与服务器的游戏状态不同，因为它不知道A选择了哪个领导者。当客户B发送他们的操作（选择Margaery Tyrell）时，我们应用相同的逻辑，从发送给客户A的消息中过滤出所选的领导者。由于两个玩家都选择了他们的领导者，我们可以通过发送其他玩家的选择来调和游戏状态的差异。在这个小动作之后，所有的客户机都有相同的游戏状态，可以决定性地解决剩余的战斗。</p><p> Note that while we could have opted not to send anything to  Client B after  A had chosen their leader, sending this information makes it possible to display in the UI of  B that  A has already chosen their leader.</p><p>请注意，虽然我们可以选择在A选择了客户B的负责人后不向其发送任何信息，但发送此信息可以在B的UI中显示A已经选择了他们的负责人。</p><p>  If I had to develop Swords &amp; Ravens from scratch, I would do it using a deterministic method. Having to implement the networking only once, and be done with it, is quite elegant and appealing. Since AGoT:TBG is quite a complex game with a lot of different phases, having to network every interaction produced a lot of boilerplate code, which amounts to a big portion of the code. On top of that, I never managed to easily add animations (pieces moving, cards moving from hand to board, …) to the UI, which does not help a lot with AGoT:TBG where a single action can have a lot of state updates.</p><p>如果我必须开发剑&amp；乌鸦从无到有，我会用确定性的方法。只需实现一次网络，并完成它，这是非常优雅和吸引人的。因为AGoT:TBG是一个相当复杂的游戏，有很多不同的阶段，必须将每个交互连接起来，产生大量样板代码，这相当于代码的很大一部分。最重要的是，我从来没有设法轻松地将动画（片段移动、卡片从手到板移动等）添加到UI中，这对AGoT:TBG没有太大帮助，因为一个动作可以有很多状态更新。</p><p> Another nice thing about using a deterministic method is that you can easily make a library that handles all the networking part of a turn-based game, letting the developer focus on developing the mechanics of the game itself. I’ve started working on such a library,  Ravens. Unfortunately, due to external circumstances, I have not continued developing it.</p><p>使用确定性方法的另一个好处是，你可以很容易地创建一个库来处理基于回合的游戏中的所有网络部分，让开发人员专注于开发游戏本身的机制。我已经开始研究这样一个图书馆了Ravens。不幸的是，由于外部环境，我没有继续开发它。</p><p> If you’re actually in the process of implementing a turn-based multiplayer game, I hope that this article was able to help you on choosing a sound architecture. If not, then I hope the content and the writing was interesting enough!</p><p>如果您实际上正在实现一个基于回合的多人游戏，我希望本文能够帮助您选择一个合理的架构。如果没有，那么我希望内容和写作足够有趣！</p><p> Though having randomness in your game (shuffling, rolling dices, …) might seem like it breaks the determinism property, you can use seeded pseudo-random number generator to make sure that a random roll will always be the same client-side and server-side. ↩</p><p>虽然游戏中的随机性（洗牌、掷骰子等）可能会打破决定论属性，但您可以使用种子伪随机数生成器来确保随机掷骰始终是相同的客户端和服务器端。↩</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/turn/">#turn</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1072771.html"><img src="http://img2.diglog.com/img/2022/2/thumb_48c899ae546261e3d6be47e8f30c370e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072771.html">不和谐是信息的黑洞</a></div><span class="my_story_list_date">2022-2-13 1:19</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072745.html"><img src="http://img2.diglog.com/img/2022/1/thumb_7234b1548bc6464c285924d6228a0cc9.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072745.html">Take-2获得社交游戏开发商Zynga以12.7亿美元的交易</a></div><span class="my_story_list_date">2022-1-11 18:48</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072619.html"><img src="http://img2.diglog.com/img/2022/1/thumb_64a5f78ebf9c6cf5cfbb4f1429c60163.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072619.html">LatencyFlex：减少游戏延迟的新方法</a></div><span class="my_story_list_date">2022-1-10 22:39</span></div><div class="col-sm"><div><a target="_blank" href="/story/1072580.html"><img src="http://img2.diglog.com/img/2022/1/thumb_393380c31d4b4acd43128612b654f279.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1072580.html">NFT Fantasy：为什么 -  AS-AS-NFT不会在游戏之间转移资产</a></div><span class="my_story_list_date">2022-1-10 9:40</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>