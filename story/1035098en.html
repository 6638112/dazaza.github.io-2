<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们需要功能较弱的语言</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我们需要功能较弱的语言</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-14 17:58:41</div><div class="page_narrow text-break page_content"><p>Many systems boast of being ‘powerful’, and it sounds difficult to argue thatthis is a bad thing. Almost everyone who uses the word assumes that it is alwaysa good thing.</p><p>许多系统都吹嘘自己“强大”，听起来很难辩称这是一件坏事。几乎每个使用这个词的人都认为它总是一件好事。</p><p> The thesis of this post is that in many cases we need  less powerfullanguages and systems.</p><p>这篇文章的主题是，在很多情况下，我们需要功能较弱的语言和系统。</p><p> Before I get going, there is very little original insight in thispost. The train of thought behind it was set off byreading Hofstadter’s book  Gödel, Escher, Bach — an Eternal Golden Braid which helped me pulltogether various things in my own thinking where I’ve seen the principle inaction. Philip Wadler’s post on  the rule of least power was alsoformative, and most of all I’ve also taken a lot from the content of  this videofrom a Scala conference about everything that is wrong with Scala, which makes thefollowing fairly central point:</p><p>在我开始之前，这篇文章几乎没有什么独到的见解。这背后的思路是通过阅读霍夫施塔特的书《哥德尔、埃舍尔、巴赫--永恒的金色辫子》来展开的，这本书帮助我在自己的思考中汇集了各种东西，在这些东西中，我看到了无所作为的原则。菲利普·瓦德勒(Philip Wadler)关于最小功率规则的帖子也很有启发性，最重要的是，我还从Scala会议上这段视频的内容中学到了很多，这段视频讲述了Scala的所有错误之处，它提出了以下相当核心的观点：</p><p> Every increase in expressiveness brings an increased burden on all who careto understand the message.</p><p>表现力的每一次提升都会给所有想要理解这一信息的人带来更大的负担。</p><p> My aim is simply to illustrate this point using examples that might be moreaccessible to the Python community than the internals of a Scala compiler.</p><p>我的目的只是用一些例子来说明这一点，这些例子可能比Scala编译器的内部更容易被Python社区访问。</p><p> I also need a word about definitions. What do we mean by “more powerful” or“less powerful” languages? In this article, I mean something roughly like this:“the freedom and ability to do whatever you want to do”, seen mainly from theperspective of the human author entering data or code into the system. Thisroughly aligns with the concept of “expressiveness”, though not perhaps with aformal definition. (More formally, many languages have equivalent expressivenessin that they are all Turing complete, but we still recognise that some are morepowerful in that they allow a certain outcome to be produced with fewer words orin multiple ways, with greater freedoms for the author).</p><p>我还需要一句关于定义的话。我们所说的“更强大”或“更不强大”的语言是什么意思？在本文中，我大致指的是：“做任何你想做的事的自由和能力”，这主要是从人类作者向系统中输入数据或代码的角度来看的。这大致符合“表现力”的概念，尽管可能不符合正式的定义。(更正式地说，许多语言都有同等的表现力，因为它们都是图灵完成的，但我们仍然认识到，有些语言更强大，因为它们允许用更少的词语或以多种方式产生某种结果，给作者更大的自由)。</p><p> The problem with this kind of freedom is that every bit of power you insist onhaving when writing in the language corresponds to power you must give up at otherpoints of the process — when ‘consuming’ what you have written. I’ll illustratethis with various examples which range beyond what might be described asprogramming, but have the same principle at heart.</p><p>这种自由的问题是，当你用英语写作时，你坚持拥有的每一点权力都与你在这个过程的其他点上必须放弃的权力相对应--当你“消费”你所写的东西时。我将用不同的例子来说明这一点，这些例子的范围可能超出了编程的范围，但本质上是相同的原则。</p><p> We’ll also need to ask “Does this matter?” It matters, of course, to the extentthat you need to be able to ‘consume’ a message you have put in. Differentplayers who might ‘consume’ the message are software maintainers, compilers andother development tools, which means you almost always care — this hasimplications both for performance and correctness as well as human concerns.</p><p>我们还需要问“这重要吗？”当然，这一点很重要，因为你需要能够“领会”你输入的信息。可能“消费”消息的不同参与者是软件维护员、编译器和其他开发工具，这意味着你几乎总是关心--这既涉及到性能和正确性，也涉及到人的安全问题。</p><p> Starting at the low end of the scale in terms of expressiveness, there is whatyou might call data rather than language. But both “data” and “language” can bethought of as “messages to be received by someone”, and the principle appliesto both.</p><p>从表现力的最低端开始，你可以称之为数据，而不是语言。但是，“数据”和“语言”都可以被认为是“要被某人接收的信息”，这一原则也适用于两者。</p><p> In my years of software development, I’ve found that clients and users often askfor “free text” fields, often for “notes”. A free text field is maximallypowerfully as far as the end user is concerned — they can put whatever they likein. In this sense, this is the “most useful” field — you can use it for anything.</p><p>在我多年的软件开发中，我发现客户和用户经常要求“自由文本”域，通常是“备注”。对于最终用户而言，自由文本域是最重要的--他们可以放入他们喜欢的任何内容。从这个意义上说，这是“最有用”的字段--你可以用它做任何事情。</p><p> But precisely because of this, it is also the least useful, because it is theleast structured. Even search doesn’t work reliably because of typos andalternative ways of expressing the same thing. The longer I do softwaredevelopment involving databases, the more I want to tightly constrain everythingas much as possible. When I do so, the data I end up with is massively moreuseful. I can do powerful things when consuming the data only when I severelylimit the power (i.e. the freedom) of the agents putting data into the system.</p><p>但正因为如此，它也是最没有用处的，因为它是最基本的结构。即使是搜索也不可靠，因为打字错误和表达相同内容的不同方式。我从事涉及数据库的软件开发的时间越长，我就越想尽可能严格地约束一切。当我这样做的时候，我最终得到的数据要有用得多。只有当我严格限制代理将数据输入系统的权力(即自由)时，我才能在消费数据时做一些强有力的事情。</p><p> In terms of database technologies, the same point can be made. Databases thatare “schema-less” give you great flexibility and power when putting data in, andare extremely unhelpful when getting it out. A key-value store is a moretechnical version of “free text”, with the same drawbacks — it is prettyunhelpful when you want to extract info or do anything with the data, since youcannot guarantee that any specific keys will be there.</p><p>在数据库技术方面，也可以提出同样的观点。“无模式”的数据库在放入数据时为您提供了极大的灵活性和强大的功能，而在取出数据时则极为无用。键值存储是“自由文本”的一个更技术性的版本，有相同的缺点-当你想要提取信息或对数据做任何事情时，它是非常无用的，因为你不能保证那里会有任何特定的键。</p><p> The success of the web has been partly due to the fact that some of the coretechnologies,  HTML and  CSS, have been deliberately limited in power. Indeed,you probably wouldn’t call them programming languages, but markup languages.This, however, was not an accident, but a  deliberate design principle on the part of TimBerners Lee. I can’t do better than to quote that page at length:</p><p>网络的成功在一定程度上要归功于一些核心技术，如超文本标记语言(HTML)和样式表(CSS)，它们的能力受到了刻意的限制。事实上，你可能不会称它们为编程语言，而是标记语言。然而，这不是偶然的，而是TimBerners Lee刻意制定的设计原则。我只能长篇大论地引用这一页：</p><p> Computer Science in the 1960s to 80s spent a lot of effort making languageswhich were as powerful as possible. Nowadays we have to appreciate thereasons for picking not the most powerful solution but the least powerful.The reason for this is that the less powerful the language, the more you cando with the data stored in that language. If you write it in a simpledeclarative form, anyone can write a program to analyze it in many ways. TheSemantic Web is an attempt, largely, to map large quantities of existingdata onto a common language so that the data can be analyzed in ways neverdreamed of by its creators. If, for example, a web page with weather datahas  RDF describing that data, a user can retrieve it as a table, perhapsaverage it, plot it, deduce things from it in combination with otherinformation. At the other end of the scale is the weather informationportrayed by the cunning Java applet. While this might allow a very cooluser interface, it cannot be analyzed at all. The search engine finding thepage will have no idea of what the data is or what it is about. This theonly way to find out what a Java applet means is to set it running in frontof a person.</p><p>20世纪60年代到80年代的计算机科学花费了大量的精力来制造尽可能强大的语言。如今，我们不得不理解选择最强大的解决方案而不是最不强大的解决方案的原因，因为语言越不强大，你就可以更多地利用以该语言存储的数据。如果你用简单的说明性的形式写它，任何人都可以写一个程序来以多种方式分析它。语义网络在很大程度上是一种尝试，将大量现存的数据映射到一种公共语言上，这样数据就可以以其创建者做梦也想不到的方式进行分析。例如，如果一个带有天气数据的网页有描述该数据的RDF，用户可以将其作为表格检索，可能会对其进行保存、绘制，并结合其他信息从中推断事物。天平的另一端是由狡猾的Java小程序描绘的天气信息。虽然这可能会提供一个非常酷的用户界面，但它根本不能被分析。找到该页面的搜索引擎不会知道数据是什么，也不知道它是关于什么的。要了解Java小程序的含义，唯一的方法就是让它在人面前运行。</p><p>  Good Practice: Use the least powerful language suitable for expressinginformation, constraints or programs on the World Wide Web.</p><p>好的做法：使用最弱的语言来表达万维网上的信息、约束或程序。</p><p> Note that this is almost exactly the opposite of  Paul Graham’s advice (with the caveat that ‘power’ is oftentoo informally defined to compare):</p><p>请注意，这与保罗·格雷厄姆的建议几乎完全相反(但需要注意的是，“权力”通常是非正式的定义，不能与之相比)：</p><p> if you have a choice of several languages, it is, all other things beingequal, a mistake to program in anything but the most powerful one.</p><p>如果你有几种语言可供选择，那么在其他条件相同的情况下，除了最强大的一种语言之外，用任何一种语言编程都是错误的。</p><p> Moving up towards ‘proper’ programming language, I came across this example —the  MANIFEST.in file format used by distutils/setuptools. If you have had tocreate a package for a Python library, you may well have used it.</p><p>在学习“合适的”编程语言时，我看到了这个例子--distutils/setuptools使用的MANIFEST.in文件格式。如果您必须为一个Python库创建一个包，那么您很可能已经使用过它。</p><p> The file format is essentially a very small language for defining what filesshould be included in your Python package (relative to the  MANIFEST.in file,which we’ll call the working directory from now on). It might look somethinglike this:</p><p>文件格式本质上是一种非常小的语言，用于定义哪些文件应该包含在您的Python包中(相对于MANIFEST.in文件，从现在起我们将其称为工作目录)。它可能看起来像这样：</p><p>  There are two types of directive:  include type directives ( include,  recursive-include,   global-include and  graft), and  exclude typedirectives ( exclude,   recursive-exclude,   global-exclude and prune).</p><p>有两种类型的指令：包括类型指令(包括、递归-包含、全局-包括和嫁接)和排除类型指令(排除、递归-排除、全局-排除和修剪)。</p><p> There comes a question — how are these directives to be interpreted (i.e. whatare the semantics)?</p><p>出现了一个问题--如何解释这些指令(例如，这些指令的语义是什么)？</p><p>  A file from the working directory (or sub-directories) should be included inthe package if it matches at least one  include type directive, and doesnot match any  exclude type directive.</p><p>如果工作目录(或子目录)中的文件与至少一个包含类型指令匹配，并且与任何排除类型指令都不匹配，则该文件应该包含在包中。</p><p>  Unfortunately, that is not how the language is defined. The  distutils docs for MANIFEST.in arespecific about this — the directives are to be understood as follows (my paraphrase):</p><p>不幸的是，这不是语言的定义。MANIFEST的distutils文档。在关于这一点的专门说明中-指令应理解如下(我的解释如下)：</p><p> Start with an empty list of files to include in the package (or technically,a default list of files).</p><p>从要包含在包中的空文件列表开始(或者从技术上讲，默认的文件列表)。</p><p>  For every  include type directive, copy any matchingfiles from the working directory to the list for the package.</p><p>对于每个包含类型指令，将所有匹配文件从工作目录复制到包列表中。</p><p> As you can see, this interpretation defines a language that is imperative innature — each line of  MANIFEST.in is a command that implies an action with side effects.</p><p>正如您所看到的，这种解释定义了一种本质上是命令性的语言--MANIFEST.in的每一行都是一个命令，暗示一个具有副作用的操作。</p><p> The point to note is that this makes the language  more powerful than myspeculative declarative version above. For example, consider the following:</p><p>需要注意的是，这使得该语言比上面的我推测的声明式版本更强大。例如，考虑以下几点：</p><p>  The end result of the above commands is that  .png files that are below foo/bar are included, but all other files below  foo/bar are not. If I’mthinking straight, to replicate the same result using the declarative languageis harder — you would have to do something like the following, which isobviously sub-optimal:</p><p>上述命令的最终结果是包括foo/bar下的.png文件，但不包括foo/bar下的所有其他文件。如果我思维清醒，使用声明性语言复制相同的结果会更困难--你必须做类似以下的事情，这显然不是最优的：</p><p>  So, because the imperative language is more powerful, there is a temptation toprefer that one. However, the imperative version comes with significant drawbacks:</p><p>因此，因为命令式语言更强大，所以有一种诱惑要提到它。然而，命令性版本伴随着重大的缺陷：</p><p> When it comes to interpreting the  MANFIEST.in and building a list of files toinclude in the package, one fairly efficient solution for a typical case isto first build an immutable list of all files in the directory and itssub-directories, and then apply the rules: addition rules involve copyingfrom the full list to an output list, and subtraction rules involve removingfrom the output list. This is how the Python implementation currently does it.</p><p>在解释MANFIEST.in和构建要包含在包中的文件列表时，典型情况下的一个相当有效的解决方案是，首先构建目录及其子目录中所有文件的不可变列表，然后应用规则：加法规则涉及从完整列表到输出列表的复制，减法规则涉及从输出列表中删除。这就是目前的Python实现所做的事情。</p><p> This works  OK, unless you have many thousands of files in the full list, mostof which are going to get pruned or not included, in which case you can spenda lot of time building up the full list, only to ignore most of it.</p><p>这很好用，除非你在完整的列表中有成千上万的文件，其中大多数将被删减或不包括在内，在这种情况下，你可能会花费大量的时间建立完整的列表，结果却忽略了其中的大部分。</p><p> An obvious shortcut is to not recurse into directories that would beexcluded by some exclude directive. However, you can only do that if theexclude directives come after all include directives.</p><p>一个明显的捷径是不要递归到某些EXCLUDE指令会排除的目录中。然而，只有在排除指令毕竟包括指令的情况下，才能做到这一点。</p><p> This is not a theoretical problem — I’ve found that doing  setup.py sdistand other commands can take 10 minutes to run, due to a large number of filesin the working directory if you use the tool  tox for instance. This means that runs of tox itself (which uses  setup.py) become very slow. I am currentlyattempting to  fix this issue,but it is looking like it will be really hard.</p><p>这不是理论上的问题--例如，我发现执行setup.py sdisp和其他命令可能需要10分钟才能运行，因为如果您使用工具tox，工作目录中会有大量文件。这意味着运行tox本身(使用setup.py)变得非常慢。我目前正在尝试解决这个问题，但看起来真的很难。</p><p> Adding the optimised case might not look that hard (you can shortcut the filesystem traversal using any exclude directives that come after all includedirectives), but it adds sufficiently to the complexity that a patch isunlikely to be accepted — it increases the number of code paths and thechances of mistakes, to the point of it not being worth it.</p><p>添加优化后的用例可能看起来并不难(您可以使用所有包含指令之后的任何EXCLUDE指令来简化文件系统遍历)，但它会充分增加补丁不太可能被接受的复杂性-它增加了代码路径的数量和错误的发生率，以至于不值得这么做。</p><p> It might be that the only practical solution is to avoid  MANIFEST.inaltogether and optimise only the case when it is completely empty.</p><p>可能唯一实际的解决方案是完全避免MANIFEST.inall，只有在MANIFEST.inall完全空的情况下才进行优化。</p><p> First, in understanding how the language works — the docs for this areconsiderably longer than for the declarative version I imagined.</p><p>首先，在理解语言是如何工作的方面--这方面的文档比我想象的声明性版本要长得多。</p><p> Second, in analysing a specific  MANIFEST.in file — you have to execute thecommands in your head in order to work out what the result will be, ratherthan being able to take each line on its own, or in any order that makessense to you.</p><p>其次，在分析一个特定的MANIFEST.in文件时，你必须执行你头脑中的命令，以便计算出结果，而不是能够单独取每一行，或者以任何对你有意义的顺序。</p><p> This actually results in packaging bugs. For instance, it would be easy to believethat a directive like:</p><p>这实际上会导致包装错误。例如，很容易相信一个指令是这样的：</p><p>  at the top of a  MANIFEST.in file would result in any file name ending in ~ (temporary files created by some editors) being excluded from thepackage. In reality it does nothing at all, and the files will be erroneouslyincluded if other commands include them.</p><p>在MANIFEST.in文件的顶部，任何以~结尾的文件名(由某些编辑创建的临时文件)都会被排除在包中。实际上，它什么都不做，如果其他命令包含这些文件，那么这些文件将被错误地包含在其中。</p><p> Examples I’ve found of this mistake ( exclude directives that don’tfunction as intended or are useless) include:</p><p>我发现的这个错误的例子(排除不能按预期工作或无用的指令)包括：</p><p> Another result is that you cannot groups lines in the  MANIFEST.in file in anyway you please, for clarity, since re-ordering changes the meaning of the file.</p><p>另一个结果是，为了清楚起见，您不能以任何您喜欢的方式对MANIFEST.in文件中的行进行分组，因为重新排序会改变该文件的含义。</p><p> In addition, virtually no-one will actually use the additional power. I’mwilling to bet that 99.99%  MANIFEST.in files do not make use of the additionalpower of the imperative language (I downloaded 250 and haven’t found any thatdo). So we could have been served much better by a declarative language hereinstead of an imperative one. But backwards compatibility forces us to stickwith this. That highlights another point — it is often possible to add featuresto a language to make it more powerful, but compatibility concerns usually don’tallow you to make it less powerful, for example by removing features or adding constraints.</p><p>此外，实际上没有人会真正使用额外的能量。我敢打赌99.99%的MANIFEST.in文件没有使用命令式语言的附加功能(我下载了250个，但没有找到任何可以使用的)。因此，在这里，使用声明性语言而不是命令式语言会更好地服务于我们。但向后兼容迫使我们坚持这一点。这突出了另一点--通常可以为一种语言添加特性以使其功能更强大，但兼容性问题通常不会让您降低它的功能，例如通过删除特性或添加更多约束。</p><p> One core piece of the  Django web frameworkis  URL routing. This is the component that parses URLs and dispatches them tothe handler for that  URL, possibly passing some components extracted from the URL.</p><p>Django网络框架的一个核心部分是URL路由。这是解析URL并将其分派给该URL的处理程序的组件，可能会传递从该URL提取的一些组件。</p><p> In Django, this is done using regular expressions. For an app that displaysinformation about kittens, you might have a  kittens/urls.py with the following:</p><p>在Django中，这是使用正则表达式完成的。对于一个显示小猫信息的应用程序，你可能会有一个kitten/urls.py，其中包含以下内容：</p><p> from  django.conf.urls  import  url from  kittens  import  views urlpatterns  =  [  url ( r &#39;^kittens/$&#39; ,  views . list_kittens ,  name = &#34;kittens_list_kittens&#34; ),  url ( r &#39;^kittens/(?P&lt;id&gt;\d+)/$&#39; ,  views . show_kitten ,  name = &#34;kittens_show_kitten&#34; ), ]</p><p>Urls从小猫导入url导入视图urlPatterns=[url(r&#39；^kitten/$&#39；，view。List_kitten，name=&#34；kitten_list_kitten&34；)，url(r&#39；^kitten/(？p&lt；id&gt；\d+)/$&#39；，查看。Show_kitten，name=&#34；kitten_show_kitten&#34；)，]。</p><p>   Regular expressions have a capture facility built in, which is used to captureparameters that are passed to the view functions. So, for example, if this appwere running on cuteness.com, a  URL like   http://www.cuteness.com/kittens/23/results in calling the Python code  show_kitten(request,  id=&#34;23&#34;).</p><p>正则表达式有一个内置的捕获工具，用于捕获传递给视图函数的参数。因此，例如，如果这个应用程序运行在cuteness.com上，那么像http://www.cuteness.com/kittens/23/results这样的网址调用Python代码show_kitten(Requestid=&#34；23&#34；)。</p><p> Now, as well as being able to route URLs to specific functions, web apps almostalways need to generate URLs. For example, the kitten list page will need toinclude links to the individual kitten page i.e.  show_kitten. Obviously wewould like to do this in a  DRY way, re-using the  URL routing configuration.</p><p>现在，除了能够将URL发送到特定功能之外，Web应用程序几乎总是需要生成URL。例如，小猫列表页面需要包含指向单个小猫页面的链接，即show_kitten。显然，我们希望以一种干爽的方式来完成这项工作，重新使用URL路由和配置。</p><p> However, we would be using the  URL routing configuration in the oppositedirection. When doing  URL routing, we are doing:</p><p>但是，我们将在相反的方向上使用URL路由配置。在做URL路由的时候，我们还在做：</p><p>  In  URL generation, we know the handler function and arguments we want the userto arrive at, and want to generate a  URL that will take the user there,  aftergoing through the  URL routing:</p><p>在URL生成中，我们知道希望用户到达的处理程序函数和参数，并希望在完成URL路由之后生成一个将用户带到那里的URL：</p><p>  In order to do this, we essentially have to predict the behaviour of the  URLrouting mechanism. We are asking “given a certain output, what is the input?”</p><p>为了做到这一点，我们基本上必须预测URLRouting机制的行为。我们问的是“给定一定的产出，最终的投入是多少？”</p><p> In the very early days Django did not include this facility, but it was  foundthat with most URLs, it was possible to ‘reverse’ the  URL pattern. The regex canbe parsed looking for the static elements and the capture elements.</p><p>在很早的时候，Django并不包括这个功能，但是人们发现，对于大多数的URL来说，有可能“颠倒”URL模式。可以解析regex以查找静态元素和捕获元素。</p><p> Note, first of all, that this is only possible at all because the language beingused to define  URL routes is a limited one — regular expressions. We couldeasily have defined  URL routes using a more powerful language. For example, we couldhave defined them using functions that:</p><p>请注意，首先，这是完全可能的，因为用于定义URL路由的语言是一种有限的正则表达式。我们可以很容易地使用更强大的语言来定义URL路由。例如，我们可以使用以下函数定义它们：</p><p>   from  django.conf.urls  import  url ,  NoMatch def  match_kitten ( path ):  KITTEN  =  &#39;kitten/&#39;  if  path . startswith ( KITTEN ):  return  path [ len ( KITTEN ):],  {}  raise  NoMatch () def  capture_id ( path ):  part  =  path . split ( &#39;/&#39; )[ 0 ]  try :  id  =  int ( part )  except  ValueError :  raise  NoMatch ()  return  path [ len ( part ) + 1 :],  { &#39;id&#39; :  id } urlpatterns  =  [  url ([ match_kitten ],  views . list_kittens ,  name = &#39;kittens_list_kittens&#39; ),  url ([ match_kitten ,  capture_id ],  views . show_kitten ,  name = &#34;kittens_show_kitten&#34; ), ]</p><p>从django.conf.urls导入url，NoMatch def Match_kitten(Path)：kitten=&#39；kitten/&#39；if path。以(小猫)开始：返回路径[len(小猫)：]，{}Raise NoMatch()def Capture_id(Path)：part=Path。Split(&#39；/&#39；)[0]try：id=int(Part)，ValueError：Raise NoMatch()返回路径[len(Part)+1：]，{&#39；id&#39；：id}urlPatterns=[url([Match_kitten]，Views)。List_kitten，name=&#39；kitten_list_kitten&#39；)，url([Match_kitten，Capture_id]，Views。Show_kitten，name=&#34；kitten_show_kitten&#34；)，]。</p><p> Of course, we could provide helpers that make things like  match_kitten and capture_id much more concise:</p><p>当然，我们可以提供一些帮助器，让Match_kitten和Capture_id这样的东西变得更加简洁：</p><p> from  django.conf.urls  import  url ,  m ,  c urlpatterns  =  [  url ([ m ( &#39;kitten/&#39; ),  views . list_kittens ,  name = &#39;kittens_list_kittens&#39; ),  url ([ m ( &#39;kitten/&#39; ),  c ( id = int )],  views . show_kitten ,  name = &#34;kittens_show_kitten&#34; ), ]</p><p>Urls从django.conf.urls导入url，m，c urlPatterns=[url([m(&#39；kitten/&#39；)，Views([m(&#39；kitten/&#39；)，View.。List_kitten，name=&#39；kitten_list_kitten&#39；)，url([m(&#39；kitten/&#39；)，c(id=int)]，Views。Show_kitten，name=&#34；kitten_show_kitten&#34；)，]。</p><p> Now, this language for  URL routing is actually a lot more powerful than ourregex based one, assuming that  m and  c are returning functions as above.The interface for matching and capturing is not limited to the capabilities ofregexes — for instance, we could do database lookups for the IDs, or many other things.</p><p>现在，这种用于URL路由的语言实际上比基于正则表达式的语言强大得多，假设m和c返回上述函数。用于匹配和捕获的接口并不局限于正则表达式的功能-例如，我们可以在数据库中查找ID，或者其他许多类似的东西。(=</p><p> The downside, however, is that  URL reversing would be entirely impossible. Forgeneral, Turing complete languages, you cannot ask “given this output, what isthe input?”. We could potentially inspect the source code of the function andlook for known patterns, but it quickly becomes totally impractical.</p><p>然而，缺点是，URL颠倒是完全不可能的。一般而言，对于图灵完整语言，你不能问“给出这个输出，输入是什么？”我们可能会检查该函数的源代码并寻找已知的模式，但这很快就变得完全不切实际了。</p><p> With regular expressions, however, the limited nature of the language gives usmore options. In general,  URL configuration based on regexes is not reversible —a regex as simple as  . cannot be reversed uniquely. (Since we want togenerate canonical URLs normally, a unique solution is important. As it happens,for this wild card, Django currently picks an arbitrary character, but otherwild cards are not supported). But as long as wild cards of any sort are onlyfound within capture groups (and possibly some other constraints), the regex canbe reversed.</p><p>然而，对于正则表达式，语言的有限性质给了我们更多的选择。一般来说，基于正则表达式的URL配置是不可逆的-一个简单的正则表达式。不能唯一反转。(因为我们希望正常生成规范的URL，所以唯一的解决方案很重要。碰巧的是，对于这个通配符，Django当前选择了一个任意字符，但不支持其他通配符)。但是，只要任何类型的通配符只在捕获组中找到(可能还有其他一些限制)，正则表达式就可以反转。</p><p> So, if we want to be able to reliably reverse the  URL routes, we actually want alanguage less powerful than regular expressions. Regular expressions werepresumably chosen because they were powerful enough, without realising that theywere too powerful.</p><p>因此，如果我们希望能够可靠地反向URL路由，我们实际上需要一种比正则表达式更弱的语言。选择正则表达式大概是因为它们足够强大，而没有意识到它们太强大了。</p><p> Additionally, in Python defining mini-languages for this kind of thing is quitehard, and requires a fair amount of boilerplate and verbosity both forimplementation and usage — much more than when using a string based languagelike regexes. In languages like Haskell, relatively simple features like easydefinitions of algebraic data types and pattern matching make these things much easier.</p><p>此外，在Python中为这类事情定义迷你语言是非常困难的，而且在实现和使用时都需要相当多的样板和冗长-比使用基于字符串的类语言正则表达式要多得多。在像Haskell这样的语言中，代数数据类型的轻松定义和模式匹配等相对简单的功能使这些事情变得容易得多。</p><p> The mention of regexes as used in Django’s  URL routing reminds me of another problem:</p><p>提到Django的URL路由中使用的regex，我想到了另一个棘手的问题：</p><p> Many usages of regexes are relatively simple, but whenever you invoke a regex,you get the full power whether you need it or not. One consequence is that forsome regular expressions, the need to do backtracking to find all possiblematches means that it is possible to construct malicious input that takes a hugeamount of time to be processed by the regex implementation.</p><p>Regex的许多用法都相对简单，但无论何时调用regex，无论您是否需要，都可以获得全部功能。结果之一是，对于某些正则表达式，需要进行回溯以查找所有可能的匹配，这意味着有可能构建恶意输入，而正则表达式的实现需要花费大量时间来处理这些输入。</p><p> This has been the cause of a  whole class of Denial Of Service vulnerabilitiesin many web sites and services, includingone in Django due to an accidentally ‘evil’ regex in the  URL validator —  CVE-2015-5145 (and onethat  took down the whole of Stack Exchange -update 2016-07-22).</p><p>这是许多网站和服务中一大类拒绝服务漏洞的原因，包括Django中的一个漏洞，是由于URL验证器CVE-2015-5145中意外的“邪恶”正则表达式造成的(还有一个关闭了整个Stack Exchange-2016-07-22更新)。</p><p> The  Jinja template engine was inspired by the Django template language,but with some differences in philosophy and syntax.</p><p>JJJA模板引擎的灵感来自于Django模板语言，但在理念和语法上有所不同。</p><p> One major advantage of Jinja2 over Django is that of  performance.Jinja2 has an implementation strategy which is to compile to Python code, ratherthan run an interpreter written in Python, which is how Django works, and thisresults in a big performance increase —  often 5 to 20 times. ( YMMV etc.)</p><p>与Django相比，JJIA2的一个主要优势是性能。JJIA2有一个实现策略，即编译成Python代码，而不是运行用Python编写的解释器，这就是Django的工作方式，这将导致性能大幅提升-通常是5到20倍。(YMMV等)。</p><p> Armin Ronacher, the author of Jinja,  attemptedto use the same strategy to speed up Django template rendering. There wereproblems, however.</p><p>Armin Ronacher，JJJA的作者，试图使用同样的策略来加速Django模板渲染。然而，也存在一些问题。</p><p> The first he knew about when he  proposedthe project — namely that the extension  API in Django makes the approach takenin Jinja very difficult. Django allows custom template tags that have  almostcomplete controlover the compilation and rendering steps. This allows some powerful customtemplate tags like  addtoblock in django-sekizai that seems impossible at first glance. However, if a slowerfallback was provided for these less common situations, a fast implementationmight still have been useful.</p><p>当他提出这个项目时，他知道的第一点是，Django中的扩展API使得在JJJA中采用的方法非常困难。Django允许自定义模板标记，几乎完全控制编译和呈现步骤。这允许一些强大的自定义模板标记，比如django-sekizai中的addtoblock，这乍一看似乎是不可能的。然而，如果为这些不太常见的情况提供较慢的后备，快速实现可能仍然很有用。</p><p> However, there is another key difference that affects a lot of templates, whichis that the context object that is passed in (which holds the data needed by thetemplate) is writable within the template rendering process in Django.Template tags are able to assign to the context, and in fact some built-intemplate tags like  url do just that.</p><p>然而，还有一个影响很多模板的关键区别，那就是传入的上下文对象(保存模板所需的数据)在Django的模板呈现过程中是可写的。模板标记能够分配给上下文，实际上一些内置的模板标记(如url)正好可以做到这一点。</p><p>  Notice that in both of these, it is the power of Django’s template engine thatis the problem — it allows code  authors to do things that are not possiblein Jinja2. However, the result is that a very large obstacle is placed in theway of attempts to compile to fast code.</p><p>请注意，在这两种情况下，Django模板引擎的强大功能才是问题所在--它允许代码作者做一些在JJIA2中不可能做的事情。然而，其结果是，在尝试编译为快速代码的过程中设置了非常大的障碍。</p><p> This is not a theoretical consideration. At some point, performance of templaterendering becomes an issue for many projects, and  a number havebeen forced to switch to Jinja because of that. This is far from an optimal situation!</p><p>这不是理论上的考虑。在某种程度上，模板制作的性能成为许多项目的一个问题，因此许多项目被迫改用金佳。这远远谈不上是最理想的经济形势！</p><p> Often the issues that make optimisation difficult are only clear with thebenefit of hindsight, and it isn’t true to say that simply adding restrictionsto a language is necessarily going to make it easier to optimise. There arecertainly languages which somehow manage to hit a “sour spot” of providinglittle to power to either the authors or the consumers!</p><p>通常情况下，让优化变得困难的问题只有在事后才能弄清楚，并不是说简单地给一种语言添加限制就一定会让它更容易优化。有一些语言不知何故成功地击中了一个“酸点”，给作者或消费者提供的力量微乎其微！</p><p> You might also say that for the Django template designers, allowing the contextobject to be writable was the obvious choice because Python data structures aretypically mutable by default. Which brings us to Python…</p><p>您可能还会说，对于Django模板设计人员来说，允许上下文对象是可写的是显而易见的选择，因为默认情况下，Python数据结构通常是可变的。这就把我们带到了巨蟒…</p><p> There are many ways that we could think about the power of the Python language,and how it makes life hard for every person and program that </p><p>我们可以用很多方式来思考Python语言的强大，以及它如何使每个人和程序的生活变得艰难。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://lukeplant.me.uk/blog/posts/less-powerful-languages/">https://lukeplant.me.uk/blog/posts/less-powerful-languages/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/需要/">#需要</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/powerful/">#powerful</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034722.html"><img src="http://img2.diglog.com/img/2020/11/thumb_78b630added4d0de817f404000722185.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034722.html">需要计划些什么吗？看看这份圆滑的总体规划</a></div><span class="my_story_list_date">2020-11-12 14:14</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034183.html"><img src="http://img2.diglog.com/img/2020/11/thumb_177bb5f468998176543118bd64774bd2.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034183.html">财富创造的阶梯</a></div><span class="my_story_list_date">2020-11-10 9:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033803.html"><img src="http://img2.diglog.com/img/2020/11/thumb_891db59fe7cc7e125bf6509eafbfe59b.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033803.html">晶体管2N2222：你需要知道的一切</a></div><span class="my_story_list_date">2020-11-8 12:58</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033747.html"><img src="http://img2.diglog.com/img/2020/11/thumb_089f03c5752afe831fc98892f468df3e.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033747.html">蒂姆·费里斯改变了他对成功的看法</a></div><span class="my_story_list_date">2020-11-8 9:30</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>