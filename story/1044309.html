<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>置换解析器，不验证 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">置换解析器，不验证 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-15 22:27:05</div><div class="page_narrow text-break page_content"><p>一段时间以来，“解析，不验证”一直是我最喜欢的编程文章之一。这篇文章的主旨是，当以类型驱动的方式编写时，您的贪婪口号应该是：</p><p>  可以通过查看两个非常相似的函数来解释解析和验证之间的核心区别：</p><p> parseInt ::字符串-＆gt;也许Int parseInt str = Text.Read.readMaybe str validateInt :: String-＆gt; Bool validateInt str = Text.Read.readMaybe str / =什么都没有</p><p> 如您所见，它们看起来非常相似。主要区别在于parseInt返回一个有用的值，即我们要解析的Int，而validateInt接受了该有用的值并将其丢弃。在奇妙的Haskell迷你模式手册中也提到了“证据”模式。</p><p> 此处的关键问题是，通过调用返回Bool的函数，您会丢失有关较早执行的验证的信息。相反，您可以通过对验证或结果进行显式模式匹配来保留此信息。</p><p> 在本文中，我想通过一个实际的例子来展示将这个概念发挥到极致的力量。带我们去…</p><p>   -拜尔（出生年）-伊尔（签发年）-年（到期年）-hgt（身高）-hcl（头发颜色）-ecl（眼睛颜色）-pid（护照ID）-cid（国家ID） </p><p>除cid字段外，所有字段都是必填字段，cid字段是可选字段。请注意，这些字段可以按任何顺序写入，这将在以后变得很重要。我们的批次由多行护照组成，并用空行（input.txt）隔开：</p><p> ecl：gry pid：860033327 eyr：2020 hcl：#fffffdbyr：1937 iyr：2017 cid：147 hgt：183cmiyr：2013 ecl：amb cid：350 eyr：2023 pid：028048884hcl：＃cfa07d byr：1929hcl：＃ae17e1 iyr：2013eyr ：2024ecl：brn pid：760753108 byr：1931hgt：179cmhcl：＃cfa07d eyr：2025 pid：166559648iyr：2011 ecl：brn hgt：59in</p><p> 第三本护照很有趣：唯一缺少的字段是可选的cid，这使其有效。</p><p> 第四本护照缺少两个字段，cid和byr。缺少身份证件是可以的，但缺少伯尔先生则不能，因此该护照无效。</p><p>  让我们编写一些代码来打开文件并解析每组护照字段：</p><p> 模块Main，在其中导入合格的Data.List.Split作为S main :: IO（）main =做内容＆lt;-readFile＆＃34; input.txt＆＃34; let条目=映射parseEntry（S.splitOn＆＃34; \ n \ n＆＃34;内容）打印条目数据PassportEntry =派生（显示）parseEntry :: String-＆gt;的PassportEntry PassportEntry parseEntry文本=未定义</p><p> 这里没什么好想的，我们使用splitpackage中的Data.List.Split进行繁重的工作。并且parseEntry的实现已被方便地取消了代码的编译范围。 </p><p>现在，我们的PassportEntry数据结构应该如何？我最终希望将护照表示为：</p><p> 数据Passport = Passport {birthYear :: Int，issueYear :: Int，expirationYear :: Int，height :: String，hairColor :: String，eyeColor :: String，passportId :: String，countryId :: Maybe Int}</p><p> 如果我们想象顺序地解析每个字段，那么我们将无法在单个操作中构造该数据结构。在准备好创建适当的护照之前，我们必须累积数据。</p><p> 存储字段的一种方法是将它们插入哈希。首先，我们将使用自定义数据类型来表示哈希键。为什么？我们真的不希望稍后在比较＆＃34; ecl＆＃34;和＆＃34; elc＆＃34;。我们将使用Data.HashMap.Strict模块中的HashMap：</p><p> 将合格的Data.HashMap.Strict导入为HM数据PassportField = BirthYear |发行年份|到期年份|身高|发色| EyeColor | PassportId | CountryId派生（Eq，Show）类型PassportEntry = HM.HashMap PassportField字符串</p><p> 当然，事情不可能那么容易。我们还需要使我们的类型实现成为Hashable类型类：</p><p> {-＃LANGUAGE DeriveGeneric＃-}导入合格的Data.HashMap.Strict作为HM导入Data.Hashable导入GHC.Generics（Generic）数据PassportField = BirthYear |发行年份|到期年份|身高|发色| EyeColor | PassportId | CountryId派生（Eq，Show，Generic）实例Hashable PassportField类型PassportEntry = HM.HashMap PassportField字符串 </p><p>不用担心我们添加的内容。只要把它们当作上帝赐予的真理。 👼</p><p>  import Data.Maybe（mapMaybe）将合格的Data.Char导入为char parseEntry :: String-＆gt; PassportEntry parseEntry行= HM.fromList $ mapMaybe parseTag $ S.splitWhen Char。 isSpace行parseTag :: String-＆gt;也许（PassportField，String）parseTag值= case S.splitOn＆＃34;：＆＃34; [＆＃34; byr＆＃34; ，byr]-＆gt;只是（BirthYear，byr）[＆＃34; iyr＆＃34; ，iyr]-＆gt;只是（IssueYear，iyr）[＆＃34; eyr＆＃34; ，eyr]-＆gt;只是（ExpirationYear，eyr）[＆＃34; hgt＆＃34; ，高度]-＆gt;只是（身高，身高）[＆＃34; hcl＆＃34; ，颜色]-＆gt;只是（HairColor，color）[＆＃34; ecl＆＃34; ，颜色]-＆gt;只是（EyeColor，color）[＆＃34; pid＆＃34; ，pid]-＆gt;只是（PassportId，pid）[＆＃34; cid＆＃34; ，cid]-＆gt;只是（CountryId，cid）_-＆gt;没有</p><p> 我们尝试将每个字段（例如byr：2002）解析为PassportFieldtype，然后最终使用HM.fromList构建哈希。我们可以进行以下讨论：</p><p> 前奏＆gt; ：l Main.hs * Main＆gt; main [fromList [（CountryId，＆＃34; 147＆＃34;），（BirthYear，＆＃34; 1937＆＃34;），（IssueYear，＆＃34; 2017＆＃34;），（HairColor，＆＃34; ＃fffffd＆＃34;），（ExpirationYear，＆＃34; 2020＆＃34;），（EyeColor，＆＃34; gry＆＃34;），（Height，＆＃34; 183cm＆＃34;），（PassportId，＆ ＃34; 860033327＆＃34;）]，从列表[（CountryId，＆＃34; 350＆＃34;），（出生年份，＆＃34; 1929＆＃34;），（IssueYear，＆＃34; 2013＆＃34;） ，（HairColor，＆＃34;＃cfa07d＆＃34;），（ExpirationYear，＆＃34; 2023＆＃34;），（EyeColor，＆＃34; amb＆＃34;），（PassportId，＆＃34; 028048884＆＃ 34;）]，fromList [（BirthYear，＆＃34; 1931＆＃34;），（IssueYear，＆＃34; 2013＆＃34;），（HairColor，＆＃34;＃ae17e1＆＃34;），（ExpirationYear， ＆＃34; 2024＆＃34;），（EyeColor，＆＃34; brn＆＃34;），（Height，＆＃34; 179cm＆＃34;），（PassportId，＆＃34; 760753108＆＃34;）]， fromList [（IssueYear，＆＃34; 2011＆＃34;），（HairColor，＆＃34;＃cfa07d＆＃34;），（ExpirationYear，＆＃34; 2025＆＃34;），（EyeColor，＆＃34 ; brn＆＃34; ），（高度，＆＃34; 59in＆＃34;），（PassportId，＆＃34; 166559648＆＃34;）]]]</p><p>  现在，我们的目标是验证这些组中的哪一个有效。首先，我们应该定义一个必填字段列表：</p><p>     main :: IO（）main =做内容＆lt;-readFile＆＃34; input.txt＆＃34;让entry =映射parseEntry（S.splitOn＆＃34; \ n \ n＆＃34;内容）打印$长度$过滤器isEntryValid条目</p><p> 运行此生成2，这是正确的答案！如果您觉得自己需要重新整理，这里是到目前为止我们编写的所有代码。 </p><p>-拜尔（生日）-四位数；在1920年至2002年之间。-年（发行年份）-四位数；在2010年至2020年之间。-eyr（有效年）-四位数；在2020年至2030年之间。-hgt（高度）-一个数字，后跟cm或in：-如果为cm，则该数字必须介于150和193之间。-如果为cm，则该数字必须介于59和76之间。-hcl（毛发颜色）-＆＃39;＃＆＃39;后面跟着六个字符0-9或af。-ecl（眼睛颜色）-以下之一：-pid（护照ID）-九位数字。-cid（国家ID）-被忽略，缺少或没有。</p><p>    这些新要求有点烦人。我们检查所有必填字段是否存在的简单方法将不再起作用。我们可以改为执行isFieldValid函数来检查所有字段是否有效。</p><p> isFieldValid ::（PassportField，String）-＆gt; Bool isFieldValid（field，value）= BirthYear的case字段->令v ＝长度值＝＝ 4的inInt值。 v＆gt; = 1920＆amp;＆amp; v＆lt; = 2002 IssueYear-＆gt;令v ＝长度值＝＝ 4的inInt值。 v＆gt; = 2010＆amp;＆amp; v＆lt; = 2020年有效期-＆gt;令v ＝长度值＝＝ 4的inInt值。 v＆gt; = 2020＆amp;＆amp; v＆lt; = 2030高度-＆gt;案例跨度Char。 （num，＆＃34; cm＆＃34;）-＆gt;的isDigit值设n = toInt num in n＆gt; = 150＆amp; n＆lt; = 193（num，＆＃34; in＆＃34;）-＆gt;设n = toInt num in n＆gt; = 59＆amp;＆amp; n＆lt; = 76 _-＆gt;假发色-＆gt; case（length value，value）为（7，＆＃39;：rest）-＆gt;全部（`elem` allowedHexChars）其余_-＆gt;假EyeColor-＆gt;值`elem` validEyeColors PassportId-＆gt;长度值== 9＆amp;＆amp;所有字符。 isDigit值CountryId-＆gt;所有字符。 isDigit值toInt ::字符串-＆gt; Int toInt =读取validEyeColors :: [String] validEyeColors = [＆＃34; amb＆＃34; ，＆＃34; blu＆＃34; ，＆nbn＆＃34; ，＆gry＆＃34; ，＆＃34; grn＆＃34; ，＆＃34; hzl＆＃34; ，＆oth＆＃34; ] allowedHexChars :: [Char] allowedHexChars = [＆＃39; 0＆＃39; ..＆＃39; 9＆＃39; ]＆lt;＆gt; [＆＃39; a＆＃39; ..＆＃39; f＆＃39; ]</p><p>  isEntryValid :: PassportEntry-＆gt;布尔isEntryValid条目= requiredFieldsPresent＆amp;＆amp; allFieldsValid其中requiredFieldsPresent =所有（“ HM.member”条目）requiredFields allFieldsValid =所有isFieldValid（HM.toList条目）</p><p> 在我们的第二个数据样本上运行该程序将得到1，这足以解决代码的到来挑战，并为我们赢得那些甜蜜的星星。</p><p>   如果我们回顾一下代码的当前状态，可以看到我们正在做很多验证。</p><p> 我们做了很多工作来验证某些东西是否有效，然后将其全部扔出窗口以返回一个微不足道的布尔。十六世纪的德国人会偷偷地告诉我们： </p><p>使用我们当前的代码，我们知道哪本护照有效，但是我们无法提取有效护照的眼睛颜色。这就是为什么我们前面提到这种Passport表示的原因：</p><p> 数据Passport = Passport {birthYear :: Int，issueYear :: Int，expirationYear :: Int，height :: String，hairColor :: String，eyeColor :: String，passportId :: String，countryId :: Maybe Int}</p><p> 如果我们有一个像parsePassport这样的函数，它从String变为MaybePassport，那么我们可以编写如下代码：</p><p>  但是，不要让自己过分领先。让我们尝试重构当前代码以执行类似的操作。首先，我们可以尝试编写一个像这样的函数：</p><p>  此函数采用一系列护照字段的中间表示形式，并返回“已验证”护照。我们还可以使用以下技巧重用isFieldValid函数：</p><p> parseField ::（PassportField，String）-＆gt;也许（PassportField，String）parseField元组=如果isFieldValid元组，则只是元组，否则</p><p> 我们仍然在重用验证逻辑，但是最终返回了一些有用的东西。记住，我们正在缓慢地将代码从验证数据迁移到解析数据。 </p><p>使用新的帮助程序，我们最终可以实现entryToPassport函数。我们将分两个步骤进行操作。首先，我们将获得必填字段的所有值：</p><p> getAllRequiredFields :: PassportEntry-＆gt;也许[String] getAllRequiredFields e =遍历（\ field-＆gt; do v＆lt;-HM.lookup field e（_field，text）＆lt;-parseField（field，v）返回text）requiredFields</p><p> 遍历魔术可以确保我们将要查找的所有值包装在Just中，如果其中任何一个无效，则为Nothing。好的，我们现在就可以开始滚动！</p><p> entryToPassport :: PassportEntry-＆gt;也许Passport entryToPassport entry = Just [byr，iyr，eyr，hgt，hcl，ecl，pid]的case getAllRequiredFields条目->只需$护照{birthYear = toInt byr，issueYear = toInt iyr，expirationYear = toInt eyr，height = hgt，hairColor = hcl，eyeColor = ecl，passportId = pid，countryId = toInt＆lt; $＆gt; HM。查找CountryId条目} _-＆gt;没有</p><p> 我们最终不得不传递字符串值，需要再次将其解析为所需的确切类型。另外，我们需要将这些值传递到列表中，并希望不要弄乱字段的顺序。 Soit远非完美，但我们正在取得进展。</p><p> 为了在我们的main中使用此功能，我们从以下位置替换main函数的最后一行：</p><p>    运行此ontest批处理仍会返回1，这表明我们没有做任何事情。 </p><p>不过，这段代码令我特别不满意的一件事：我们使用的护照的中间表示形式没有实域值。没有人关心PassportField和PassportEntry，但是我们需要具有这些类型才能构建我们的Passport。</p><p> 不仅如此，拥有这些中间类型还意味着当我们将它们转换为所需的数据类型时，有一些错误等待发生：</p><p>   Shotgun解析是一种编程反模式，解析和输入验证代码与处理代码混合并分布在处理代码之间，从而在输入处抛出一堆检查，并希望在没有任何系统理由的情况下，一个或另一个将捕获所有“不良”信息案件。</p><p> 亚历克西斯·金（Alexis King）在“解析，不验证”一书中继续描述了它与解析和验证之间的特定关系：</p><p> shot弹枪解析与验证有什么关系可能尚不明显，毕竟，如果您事先进行了所有验证，就可以减轻of弹枪解析的风险。问题在于，基于验证的方法使得很难或不可能确定所有事情是否都经过了预先验证，或者是否确实可能发生了一些所谓的“不可能”情况。整个计划都必须假设，不仅在任何地方都可能引发异常，而且这是经常性的。</p><p>   我们将使用monsec的parsercombinator库parsec编写相同的程序。我最近接触了Parsercombinator的出色演练，我一直建议阅读。</p><p>   它通过使用输入字符串中的输入字符并返回具有两个值的元组来工作： </p><p>第一个值是输入字符串的剩余值，以便其他解析器可以继续解析其余的输入。</p><p> 第二个值包含解析错误或类型为a的正确解析值。</p><p>    -拜尔（生日）-四位数；在1920年到2002年之间。byrParser ::解析器Int byrParser = do P.string＆＃34; byr＆＃34; P.char＆＃39;：＆＃39;值＆lt;-P.count 4个P.digit P.spaces，让int =读取值保护（int＆gt; = 1920＆amp; int＆lt; = 2002）return int-iyr（Issue Year）-四位数字;在2010年至2020年之间。iyrParser :: Parser Int iyrParser = do P.string＆＃34; iyr＆＃34; P.char＆＃39;：＆＃39;值＆lt;-P.count 4个P.digit P.spaces，让int =读取值保护（int＆gt; = 2010＆amp; int＆lt; = 2020）return int-eyr（有效年）-四位数字;在2020年到2030年之间。eyrParser :: Parser Int eyrParser = do P.string＆＃34; eyr＆＃34; P.char＆＃39;：＆＃39;值＆lt;-P.count 4个P.digit P.spaces，让int =读取值保护（int＆gt; = 2020＆amp;＆amp; int＆lt; = 2030）返回int</p><p> 在这里，我们使用保护功能引入一个断言，当不满足条件时，该断言将使解析器失败。总的来说，我觉得这段代码可读性很强，但是我们可能想提取一个可重用的帮助器来分析几年：</p><p> yearParser ::字符串-＆gt; （Int，Int）-> Parser Int yearParser值（rangeStart，rangeEnd）=做P.string值P.char＆＃39;：＆＃39;值＆lt;-P.count 4个P.digit P.spaces，让int =读取值保护（int＆gt; = rangeStart＆amp;＆amp; int＆lt; = rangeEnd）返回int byrParser :: Parser Int byrParser = do yearParser＆＃34 ; byr＆＃34; （1920年，2002年）iyrParser :: Parser Int iyrParser = do yearParser＆＃34; iyr＆＃34; （2010年，2020年）eyrParser :: Parser Int eyrParser = do yearParser＆＃34; eyr＆＃34; （2020，2030）</p><p>  这就是编写解析器组合器的美妙之处。它们非常易于重用和组合。</p><p> 现在我们要为高度字段编写一个解析器。使用更专业的数据类型来表示可能会很好： </p><p>-hgt（高度）-一个数字，后跟cm或in：–如果为cm，则该数字必须介于150和193之间。–如果为cm，则该数字必须介于59和76之间。heightParser :: Parser Height heightParser =做P.string＆＃34; hgt＆＃34; P.char＆＃39;：＆＃39;位数＆lt;-P.many1 P.digit let value =读取的数字结果＆lt;-InCms _ unitParser值大小写结果_-＆gt;保护（值＆gt; = 150＆amp;＆amp;值＆lt; = 193）InInches _-＆gt;保护（值＆gt; = 59＆amp;＆amp;值＆lt; = 76）P.spaces返回结果</p><p>  unitParser :: Int-＆gt;分析器高度unitParser值=让cmParser =执行P.string＆＃34; cm＆＃34; return（InCms value）inParser =做P.string＆＃34; in＆＃34;在P.choice [cmParser，inParser]中返回（InInches值）</p><p> 其余的解析器基本上是对英语要求的逐步翻译：</p><p> -hcl（发色）-a＆＃39;＃＆＃39;随后是六个字符0-9或a-f。 hairColorParser ::解析器字符串hairColorParser = do P.string＆＃34; hcl＆＃34; P.char＆＃39;：＆＃39;夏尔＆＃39;＃＆＃39; v＆lt;-P.count 6（P.oneOf＆＃34; 0123456789abcdef＆＃34;）P.spaces返回v</p><p> -pid（护照ID）-一个九位数的数字。 passwordIdParser ::解析器字符串passwordIdParser =做P.string＆＃34; pid＆＃34; P.char＆＃39;：＆＃39; v＆lt;-P.count 9个P位数字P.spaces返回v</p><p> -cid（国家/地区ID）-已忽略，缺失或缺失。 countryIdParser ::解析器Int countryIdParser =做P.string＆＃34; cid＆＃34; P.char＆＃39;：＆＃39;值＆lt;-P.many1 P.digit P.spaces返回$读取值</p><p> -ecl（眼睛颜色）-其中之一：amb blu brn gry grn hzl oth。 eyeColorParser ::解析器字符串eyeColorParser = do P.string＆＃34; ecl＆＃34; P.char＆＃39;：＆＃39; v＆lt;-P.choice $ map（P.try。P.string）[＆＃34; amb＆＃34; ，＆＃34; blu＆＃34; ，＆nbn＆＃34; ，＆gry＆＃34; ，＆＃34; grn＆＃34; ，＆＃34; hzl＆＃34; ，＆oth＆＃34; P.spaces返回v </p><p>您会注意到我们必须在最后一个片段中使用此神秘的P.try函数。当我们需要在输入字符串中向前看时，这非常有用。考虑一下blu和brn的示例：消费了初始b字符后，我们进入了blu分支。如果此时遇到r字符，我们意识到我们需要返回并选择brn分支。但是默认情况下，解析将停止，因为我们已经消耗了第一个字符。 P.try会这样做，因此我们的解析器不会假装使用任何输入，因此我们可以继续尝试其他替代方案。</p><p> 现在，我们已经为每个字段编写了解析器。现在是时候将它们组合在一起了……</p><p>   由于我们的解析器尝试一次消耗一个字符，因此我们该如何编写一个必须处理随机输入的字符呢？</p><p>    此模块实现置换解析器。排列短语是元素（可能是不同类型）的序列，其中每个元素恰好出现一次且顺序无关紧要。一些置换元素可能是可选的。</p><p>    permute是最后一个调用，它将包装所有内容并返回某些解析器。</p><p> ＆lt; $$＆gt;用于将我们解析的所有字段分配给某些内容。在这种情况下，它将是护照。</p><p>  PassportParser :: Parser Passport PassportParser =置换$ Passport＆lt; $$＆gt; byrParser＆lt; ||＆gt; iyrParser＆lt; ||＆gt; P.try eyrParser＆lt; ||＆gt; P.try heightParser＆lt; ||＆gt; P.try hairColorParser＆lt; ||＆gt; P.try eyeColorParser＆lt; ||＆gt; PassportIdParser＆lt; |？＆gt; （没什么，只要＆lt; $＆gt; countryId </p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://juliu.is/permutate-parsers/">https://juliu.is/permutate-parsers/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/置换/">#置换</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parsers/">#parsers</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>