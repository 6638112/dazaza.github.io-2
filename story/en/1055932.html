<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>关于C ++复制ELISION的悲伤真相 The Sad Truth About C++ Copy Elision</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Sad Truth About C++ Copy Elision<br/>关于C ++复制ELISION的悲伤真相 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-03 20:21:12</div><div class="page_narrow text-break page_content"><p>Copy elision is a C++compiler optimization that, as its name suggests, eliminates extracopy and move operations. It is similar to the classical  copypropagationoptimization, but specifically performed on C++ objects that may havenon-trivial copy and move constructors. In this post, I’ll walkthrough an example where an obvious optimization you might expect fromyour compiler doesn’t actually happen in practice.</p><p>复制ELISION是一个C ++编译器优化，因为它的名称表明，消除了胸部和移动操作。它类似于经典的副作复优化，但专门对可能对普通复制和移动构造函数的C ++对象执行。在这篇文章中，我会演练一个一个明显优化的一个例子，你可能期望的来自你的编译器实际上并没有在实践中发生。</p><p>  Let’s say that you have a long function call that returns an object,and you want to immediately pass that object to another function, likethis:</p><p>  假设您有一个长期函数调用返回一个对象，并且您希望立即将该对象传递给另一个函数，likethis：</p><p> #include  &lt;string&gt;  #include  &lt;string_view&gt;   // Some type that is expensive to copy, non-trivial to destroy, and cheap but // not free to move.  struct  Widget { std ::string s;}; void  consume(Widget w);Widget  doSomeVeryComplicatedThingWithSeveralArguments(  int arg1, std ::string_view arg2); void  someFunction() { consume(doSomeVeryComplicatedThingWithSeveralArguments( 123,  &#34;hello&#34;));}</p><p> #include＆lt; string＆gt; #include＆lt; string_view＆gt; //复制的某些类型，不易于摧毁，廉价但是//不自由移动。 struct widget {std :: string s;}; void消费（窗口小部件w）;窗口小部件dosomeverycomplicationthingwithseveralguments（int arg1，std :: string_view arg2）; void somefunction（）{cenume（dosomeverycomplicationthingwithseveralarguments（123，＆＃34; hello＆＃34;））;}</p><p>  someFunction():  # @someFunction()   pushq %rbx  subq  $32, %rsp  movq %rsp, %rbx  movl  $5, %edx  movl  $.L.str, %ecx  movq %rbx, %rdi  movl  $123, %esi  callq  doSomeVeryComplicatedThingWithSeveralArguments( int,  std:: basic_string_view &lt; char,  std:: char_traits &lt; char &gt;  &gt;)  movq %rbx, %rdi  callq  consume( Widget)  movq (%rsp), %rdi  leaq  16(%rsp), %rax  cmpq %rax, %rdi  je  .LBB0_2  callq  operator  delete( void*).LBB0_2:  addq  $32, %rsp  popq %rbx  retq.L.str:  .asciz  &#34;hello&#34;</p><p>  某种功能（）：＃@somefunction（）pushq％rbx子q $ 32，％rsp movq％rsp，％rbx movl $ 5，％edx movl $ .l.str，％ECX MOVIQ％RBX，％RDI MOVL $ 123，％ESI CallQ DosomeVeryComplationTiptthingwithseveralguments （int，std :: basic_string_view＆lt; char，std :: char_traits＆lt; char＆gt;）movq％RBX，％RDI CallQ消费（小部件）MOVIQ（％RSP），％RDI Leaq 16（％RSP），％ rax cmpq％rax，％rdi je .lbb0_2 callq运算符删除（void *）。lbb0_2：addq $ 32，％rsp popq％rbx retq.l.str：.cr：.criz＆＃34;你好＆＃34;</p><p> Our temporary  Widget returned from doSomeVeryComplicatedThingWithSeveralArguments is constructed in thestack space that  someFunction allocated for it, and then a pointerto that stack space is passed straight to  consume, as we shouldexpect from  learning about parameterpassing previously.</p><p> 我们的临时窗口小部件从DosomeVeryComplicationTiptthingWithSeverAlguments返回的初始空间构建，即某种方式为其分配，然后将堆栈空间通过直接消耗的部分来消耗，因为我们应该从学习之前学习参数通知。</p><p> Now, imagine that you decide that your single line in  someFunctionis too long, or that you want to give a meaningful name to the result of doSomeVeryComplicatedThingWithSeveralArguments, so you change the code:</p><p> 现在，想象一下，您可以在某些功能中的单线中决定太长，或者您希望向DosomeVeryComplicationTiptthingWithSeverthuments提供有意义的名称，因此您更改了代码：</p><p>   someFunctionV2():  # @someFunctionV2()   pushq %r15  pushq %r14  pushq %r12  pushq %rbx  subq  $72, %rsp  leaq  40(%rsp), %rdi  movl  $5, %edx  movl  $.L.str, %ecx  movl  $123, %esi  callq  doSomeVeryComplicatedThingWithSeveralArguments( int,  std:: basic_string_view &lt; char,  std:: char_traits &lt; char &gt;  &gt;)  leaq  24(%rsp), %r12  movq %r12,  8(%rsp)  movq  40(%rsp), %r14  movq  48(%rsp), %rbx  movq %r12, %r15  cmpq  $16, %rbx  jb  .LBB1_4  testq %rbx, %rbx  js  .LBB1_13  movq %rbx, %rdi  incq %rdi  js  .LBB1_14  callq  operator  new( unsigned  long)  movq %rax, %r15  movq %rax,  8(%rsp)  movq %rbx,  24(%rsp).LBB1_4:  testq %rbx, %rbx  je  .LBB1_8  cmpq  $1, %rbx  jne  .LBB1_7  movb (%r14), %al  movb %al, (%r15)  jmp  .LBB1_8.LBB1_7:  movq %r15, %rdi  movq %r14, %rsi  movq %rbx, %rdx  callq  memcpy.LBB1_8:  movq %rbx,  16(%rsp)  movb  $0, (%r15,%rbx)  leaq  8(%rsp), %rdi  callq  consume( Widget)  movq  8(%rsp), %rdi  cmpq %r12, %rdi  je  .LBB1_10  callq  operator  delete( void*).LBB1_10:  movq  40(%rsp), %rdi  leaq  56(%rsp), %rax  cmpq %rax, %rdi  je  .LBB1_12  callq  operator  delete( void*).LBB1_12:  addq  $72, %rsp  popq %rbx  popq %r12  popq %r14  popq %r15  retq.LBB1_13:  movl  $.L.str.2, %edi  callq  std:: __throw_length_error( char  const*).LBB1_14:  callq  std:: __throw_bad_alloc().L.str:  .asciz  &#34;hello&#34;.L.str.2:  .asciz  &#34;basic_string::_M_create&#34;</p><p>   DemencurbenctionV2（）：＃@ demenctionv2（）PUSHQ％R15 PUSPQ％R14 PUSPQ％R12 PUSHQ％RBX子Q $ 72，％RSP LEVE 40（％RSP），％RDI MOVL $ 5，％EDX MOVL $ .l.str，％ECX MOVL $ 123，％ESI CallQ DosomeVeryComplicationTiptthingWithSeverAlguments（int，std :: basic_string_view＆lt; char，std :: char_traits＆lt; char＆gt;）Leaq 24（％RSP），％R12 MOVIQ％R12,8（％RSP）MOVQ 40（ ％RSP），％R14 MOVQ 48（％RSP），％RBX MOVQ％R12，％R15 CMPQ $ 16，％RBX JB .LBB1_4 TestQ％RBX，％RBX JS .LBB1_13 MOVE％RBX，％RDI Incq％RDI JS .LBB1_14 CallQ运算符新（无符号长）MOVQ％rax，％r15 movq％rax，8（％rsp）movq％RBX，24（％RSP）.lBB1_4：TestQ％RBX，％RBX JE .LBB1_8 CMPQ $ 1，％RBX JNE。 LBB1_7 MOVB（％R14），％AL MOVB％AL，（％R15）JMP .LBB1_8.LBB1_7：MOVQ％R15，％RDI MOVIQ％R14，％RSI MOVIQ％RBX，％RDX CallQ Memcpy.LBB1_8：Movq％RBX， 16（％RSP）MOVB $ 0，（％R15，％RBX）LIAQ 8（％RSP），％RDI CallQ消耗（窗口小部件）MOVIQ 8（％RSP），％RDI CMPQ％R12，％RDI JE .LBB1_10 CallQ运算符删除（voi. D *）。LBB1_10：MOVQ 40（％RSP），％RDI LEAQ 56（％RSP），％rax cmpq％rax，％rdi je .lbb1_12 callq运算符删除（void *）。lbb1_12：addq $ 72，％rsp popq％ RBX popq％r12 popq％r14 popq％r15 retq.lbb1_13：movl $ .l.l.l.l.l.2，％edi callq std :: __throw_length_error（char conten *）。lbb1_14：callq std :: __throw_bad_alloc（）。l.str： .asciz＆＃34;你好＆＃34; .str.2：.sciz＆＃34; basic_string :: _ m_create＆＃34; </p><p> Now we take our perfectly good  Widget,  complicatedThingResult, andcopy it into a new temporary  Widget to serve as the first argumentto  consume. When we’re done, we have to destroy  two  Widgets:both  complicatedThingResult and the unnamed temporary  Widget wepassed to  consume. You might expect that the compiler would optimize someFunctionV2() to be just like  someFunction, but it won’t.</p><p>现在，我们将我们完美的良好的小部件，复杂的问题，AndCopy它进入了一个新的临时小部件，以作为第一个消耗的Argumentto。当我们完成后，我们必须销毁两个小部件：复杂的资源和未命名的临时小部件遍布消费。您可能希望编译器会优化某些功能（）就像某种功能一样，但它不会。</p><p>    someFunctionV3():  # @someFunctionV3()   pushq %r14  pushq %rbx  subq  $72, %rsp  leaq  8(%rsp), %rdi  movl  $5, %edx  movl  $.L.str, %ecx  movl  $123, %esi  callq  doSomeVeryComplicatedThingWithSeveralArguments( int,  std:: basic_string_view &lt; char,  std:: char_traits &lt; char &gt;  &gt;)  leaq  56(%rsp), %r14  movq %r14,  40(%rsp)  movq  8(%rsp), %rax  leaq  24(%rsp), %rbx  cmpq %rbx, %rax  je  .LBB1_1  movq %rax,  40(%rsp)  movq  24(%rsp), %rax  movq %rax,  56(%rsp)  jmp  .LBB1_3.LBB1_1:  movups (%rax), %xmm0  movups %xmm0, (%r14).LBB1_3:  movq  16(%rsp), %rax  movq %rax,  48(%rsp)  movq %rbx,  8(%rsp)  movq  $0,  16(%rsp)  movb  $0,  24(%rsp)  leaq  40(%rsp), %rdi  callq  consume( Widget)  movq  40(%rsp), %rdi  cmpq %r14, %rdi  je  .LBB1_5  callq  operator  delete( void*).LBB1_5:  movq  8(%rsp), %rdi  cmpq %rbx, %rdi  je  .LBB1_7  callq  operator  delete( void*).LBB1_7:  addq  $72, %rsp  popq %rbx  popq %r14  retq.L.str:  .asciz  &#34;hello&#34;</p><p>    某种功能（）：＃@ demenctionv3（）PUSHQ％R14 PUSPQ％RBX子Q $ 72，％RSP LEAQ 8（％RSP），％RDI MOVL $ 5，％EDX MOVL $ .l.str，％ECX MOVL $ 123，％ESI CallQ DosomeVeryComplationTiptthingWithSeverGumber （int，std :: basic_string_view＆lt; char，std :: char_traits＆lt; char＆gt;）Leaq 56（％RSP），％R14 MOVQ％R14,40（％RSP）MOVQ 8（％RSP），％rax％ Leaq 24（％RSP），％RBX CMPQ％RBX，％rax JE .LBB1_1 MOVQ％rax，40（％rsp）MOVQ 24（％RSP），％rax movq％rax，56（％rsp）jmp .lbb1_3.lbb1_1 ：MOVUPS（％rax），％xmm0 movup％xmm0，（％r14）.lbb1_3：movq 16（％rsp），％rax movq％rax，48（％rsp）movq％RBX，8（％RSP）MOVIQ $ 0， 16（％RSP）MOVB $ 0,24（％RSP）LEAQ 40（％RSP），％RDI CallQ消耗（窗口小部件）MOVIQ 40（％RSP），％RDI CMPQ％R14，％RDI JE .LBB1_5 CallQ运算符删除（void *。 .asciz＆＃34;你好＆＃34;</p><p> We  still have two  Widgets, it’s just that the temporary argumentto  consume is move constructed now. Our first version of someFunction is still smaller and faster!</p><p> 我们仍有两个小部件，它只是临时参数消耗是移动的。我们的第一个版本的某种功能仍然更小，更快！</p><p>  The fundamental problem with copy elision is that it is only allowedin  a specific list ofcircumstances. (Briefly,RVO and initializing from a prvalue are required, NRVO is allowed, andsome other cases with exceptions and coroutines are alsoallowed. Nothing else.) There is a philosophical reason for this: youwrote a copy constructor for your class that could do anything, andyou expect it to run whenever objects of your class are copiedaccording to the rules of C++. If compilers were to unpredictablyremove copies, and thus remove pairs of copy/move constructor &amp;destructor calls, they might break your code.</p><p>  复制ELISION的根本问题是它仅允许特定列表的特定列表。 （简要介绍，RVO和从Prvalue初始化，允许NRVO，并且许多案例也是如此，具有异常和考文表。没有别的。）有一种哲学原因，这是一个哲学原因：YOYWROTE为您的课程的复制构造函数，可以做任何事情，当您对C ++的规则复制到C ++的对象时，您希望它运行。如果编译器是unprevicticledremove副本，因此删除了复制/移动构造函数和ramp;析构函数调用，他们可能会破坏您的代码。</p><p> Specifically, there is simply nothing on the list of allowedcircumstances for copy elision that applies to the examples we sawhere. That list doesn’t include things like “the last time I use avariable before it goes out of scope” or “passing a variable to afunction by value when I haven’t done anything else with it and itlooks obviously safe”. Maybe it will in the future, but not in C++20or before!</p><p> 具体来说，对于复制的ELINION的QuancedFircumstances列表中，适用于我们索引的示例的允许鼠标。该列表不包括“我最后一次使用在其范围内的最后一次使用”或“当我没有使用其他任何别的任何别的时出现的可移量和它的速度和它明显安全”。也许它将在未来，但不是在C ++之前！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://wolchok.org/posts/sad-truth-about-cxx-copy-elision/">https://wolchok.org/posts/sad-truth-about-cxx-copy-elision/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/复制/">#复制</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/truth/">#truth</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rbx/">#rbx</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>