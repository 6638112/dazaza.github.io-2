<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我使用Reaction的渲染器进行了一些测试，以分析其渲染行为</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我使用Reaction的渲染器进行了一些测试，以分析其渲染行为</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-30 12:58:30</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/79cd381ed86813516edbe1474d5650d7.png"><img src="http://img2.diglog.com/img/2020/10/79cd381ed86813516edbe1474d5650d7.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In this post we’ll run a few experiments to see how React’s renderer works and gain a understanding of some of its guaranteed ( spoiler: I’ll use this word a lot 😅) behaviors.</p><p>在这篇文章中，我们将运行一些实验，看看Reaction的渲染器是如何工作的，并了解它的一些有保证的(剧透：我会经常使用这个词😅)行为。</p><p>    Let’s start with our first experiment so you can get familiar with them.</p><p>让我们从我们的第一个实验开始，这样你就可以熟悉它们了。</p><p> We’ll start with simple component hierarchy consisting of a root component and two children components “A” and “B”:</p><p>我们将从由一个根组件和两个子组件“A”和“B”组成的简单组件层次结构开始：</p><p>    Note: This  is a simple colored output from   Firefox DevTools  used to describe a sequence of events. A green “Rendered” means that a component is rendered (i.e: it’s function body is called) and a blue “useEffect” means that an effect inside a component was run. Every log is accompanied with a colored label to make it easier to follow along.</p><p>注意：这是Firefox DevTools用于描述事件序列的简单彩色输出。绿色的“呈现”表示组件被呈现(即：调用了它的函数体)，蓝色的“useEffect”表示组件内部的效果已经运行。每根原木都有一个彩色标签，以便更容易跟踪。</p><p> As you can see, first, every component is rendered from top to bottom starting from the root component followed by each children. Then, effects are run on the opposite side, from bottom to top.</p><p>如您所见，首先，每个组件都是从上到下呈现的，从根组件开始，然后是每个子组件。然后，效果在相反的一侧运行，从下到上。</p><p> Since our components is relatively simple, it doesn’t give us the whole picture of renderer’s behavior. Let’s add more complexity to our tree.</p><p>因为我们的组件相对简单，所以它不能给我们提供渲染器行为的全部情况。让我们为我们的树增加更多的复杂性。</p><p>  To gain more insight about the rendering process, let’s add a few more nodes to our tree:</p><p>为了更深入地了解渲染过程，我们再向树中添加几个节点：</p><p>    We keep the same behavior than before: tree is rendered from top to bottom and each child is traversed too. As you can see, there’s an interesting thing: nodes are traversed in sequence (from “left” to “right”). However,  this is behavior from React’s current implementation and   not guaranteed behavior , so don’t rely on this by any means! (Actually, why you would need to rely on this?)</p><p>我们保持与以前相同的行为：从上到下渲染树，并且还遍历每个子对象。正如您所看到的，有一件有趣的事情：节点是按顺序(从“左”到“右”)遍历的。但是，这是Reaction当前实现的行为，不能保证行为，所以无论如何都不要依赖它！(实际上，您为什么需要依赖这个？)</p><p> On the effects side, we can see that they’re run bottom to top.  It’s guaranteed that children effects will run before the ones from the parent but sibling effects’ order aren’t guaranteed to run in any order (Again, why would you need that?).</p><p>在效果方面，我们可以看到它们是从下到上运行的。可以保证子级特效将在父级特效之前运行，但是不能保证兄弟级特效的顺序会以任何顺序运行(再说一遍，您为什么需要这样做呢？)。</p><p>  Until now, everything we analyzed was the first render behavior. We haven’t tested what happens on re-renders and how effects’ cleanups behave.</p><p>到目前为止，我们分析的所有内容都是第一个渲染行为。我们还没有测试在重新渲染时会发生什么，以及效果的清理操作是如何进行的。</p><p>  Let’s start with a leaf node (a node without childrens). When you click the node “3”, it is rendered again and its previous associated effects are cleanup before triggering them again with the new props and state:</p><p>让我们从叶节点(没有子节点的节点)开始。单击节点“3”时，将再次渲染该节点，并且在使用新的道具和状态再次触发它们之前，将清理其先前关联的效果：</p><p>  React docs says that “The clean-up function runs before the component is removed from the UI to prevent memory leaks” and that on re-renders, any “previous effect is cleaned up before executing the next effect”.</p><p>React文档说“清理功能在组件从UI中移除之前运行，以防止内存泄漏”，在重新渲染时，任何“前一个效果在执行下一个效果之前都会被清除”。</p><p> When you click on a node that has childrens, it calls the render method for each one of them and then proceeds to cleanup previous effects and run the new ones on a per-component basis:</p><p>当您单击具有子节点的节点时，它会为每个子节点调用Render方法，然后继续清理以前的效果，并在每个组件的基础上运行新的效果：</p><p>  An important (and guaranteed) behavior to notice is that  React runs all childrens’ effects and cleanups before the ones from the parent.</p><p>需要注意的一个重要(且有保证的)行为是，Reaction在父级的效果和清理之前运行所有子级的效果和清理。</p><p>  As we saw before, there are some consistent behavior in the React rendering process. However, the current implementation doesn’t guarantee anything about future behaviors. There are only a few documented guaranteed behaviors that React guarantees and that you can take advantage of:</p><p>正如我们之前看到的，在Reaction呈现过程中有一些一致的行为。但是，当前的实现不能保证有关未来行为的任何内容。只有几种记录在案的担保行为可以对担保做出反应，您可以利用这些行为：</p><p> All previous effects are cleaned up before apply the new ones when a component updates.</p><p>当组件更新时，在应用新效果之前，所有以前的效果都会被清除。</p><p>   I want to be clear that not guaranteed doesn’t mean that it was necessarily discussed and decided in this way. In can change in the future, but for now, your components should only make assumptions about guaranteed behavior. Any current behavior can change in future React versions without previous notice.</p><p>我想澄清的是，没有保证并不意味着它一定是以这种方式讨论和决定的。可以在将来更改，但目前，您的组件应该只假设有保证的行为。任何当前行为都可以在未来的Reaction版本中更改，而无需事先通知。</p><p> A good thing about not guaranteed certain behaviors is that you have more flexibility.  React Fiber is a great example about this. In a very few words, React Fiber  is an internal implementation (thus, you don’t need to learn it to use React) that allows among other things to pause work and continue it later, assign priority to different types of work, and abort work if it’s no longer needed. This is very useful if you have different types of work that needs to be done. For example:</p><p>不保证某些行为的好处是你有更多的灵活性。反应纤维就是一个很好的例子。简而言之，Reaction纤程是一个内部实现(因此，您不需要学习使用REACT)，它允许暂停工作并稍后继续，为不同类型的工作分配优先级，并在不再需要工作时中止工作。如果您有不同类型的工作需要完成，这是非常有用的。例如：</p><p>  In the classic React’s renderer, it’s not possible to do this kind of things. However, by not guaranteeing that renders happen in sequence, this is completely possible and way easier to do it in a backwards compatible way than without it.</p><p>在经典Reaction的渲染器中，不可能执行此类操作。但是，通过不保证渲染按顺序进行，这是完全可能的，而且以向后兼容的方式进行渲染比没有向后兼容的方式更容易。</p><p>  We make  real experiments with React and learned how it internally handles rendering. We started with a simple version and increase complexity gradually to understand how rendering works.</p><p>我们用Reaction做了真实的实验，了解了它是如何在内部处理渲染的。我们从一个简单的版本开始，然后逐渐增加复杂性，以了解渲染是如何工作的。</p><p> We were able to discover what React does and doesn’t guarantee, so you can get back to this in case you need it in the future :-) However, I don’t think most of the time you need to be aware of this and so, it isn’t needed to code in React, but I think it’s fun to know this little details!</p><p>我们能够发现Reaction做什么和不做什么保证，所以您可以在将来需要的时候回到这里：-)但是，我认为大多数时候您不需要知道这一点，所以不需要在Reaction中编写代码，但我认为了解这些小细节是很有趣的！-)然而，我认为在大多数情况下您不需要知道这一点，所以不需要在Reaction中编写代码，但是我认为了解这些小细节是很有趣的！</p><p> If you want to go (really) deep on React’s rendering behavior, check Mark Erikson’s article  A (Mostly) Complete Guide to React Rendering Behavior.</p><p>如果您想(真正地)深入了解Reaction的呈现行为，请查看Mark Erikson的文章A(大部分)Complete Guide to Reaction呈现行为。</p><p> If you have any questions, you can reach out to me on  Twitter or send me an  email. I’d be glad to help you with anything!</p><p>如果你有任何问题，你可以在推特上联系我，或者给我发一封电子邮件。我很乐意为你做任何事！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gbenussi.medium.com/having-fun-with-reacts-renderer-be15b39c4556">https://gbenussi.medium.com/having-fun-with-reacts-renderer-be15b39c4556</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/reaction/">#reaction</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/react/">#react</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031336.html"><img src="http://img2.diglog.com/img/2020/10/thumb_1a65df924f8779c225ea2e11e4155568.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031336.html">使用Reaction Native for Web在Web上运行您的Reaction Native应用程序</a></div><span class="my_story_list_date">2020-10-27 6:19</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030818.html"><img src="http://img2.diglog.com/img/2020/10/thumb_a16397eb55f8b10fdacb1227d4145217.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030818.html">创建Reaction App 4.0</a></div><span class="my_story_list_date">2020-10-24 7:29</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030306.html"><img src="http://img2.diglog.com/img/2020/10/thumb_6d24beff447f24869b2bc45eca6b3503.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030306.html">Reaction v17.0</a></div><span class="my_story_list_date">2020-10-21 21:32</span></div><div class="col-sm"><div><a target="_blank" href="/story/1028783.html"><img src="http://img2.diglog.com/img/2020/10/thumb_8ac4a2539cce0cab342d033f848ab3e4.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1028783.html">世界对美国选民排长队的反应</a></div><span class="my_story_list_date">2020-10-14 23:22</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>