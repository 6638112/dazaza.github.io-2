<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>RISC与CISC是用于比较现代X86，ARM CPU的错误镜头 RISC vs. CISC is the Wrong Lens for Comparing Modern x86, ARM CPUs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">RISC vs. CISC is the Wrong Lens for Comparing Modern x86, ARM CPUs<br/>RISC与CISC是用于比较现代X86，ARM CPU的错误镜头 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-06 18:49:40</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/79618e1ccc6336f6fcc8df95a2cfe8ee.jpg"><img src="http://img2.diglog.com/img/2021/6/79618e1ccc6336f6fcc8df95a2cfe8ee.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This site may earn affiliate commissions from the links on this page.  Terms of use.</p><p>本网站可以从本页的链接获取会员委员会。使用条款。</p><p>      With Apple’s WWDC coming up soon, we’re expecting to hear more about the company’s updated, ARM-based MacBook Pro laptops. Rumors point to Apple launching a slate of upgraded systems, this time based around its “M2” CPU, a scaled-up version of the M1 core that debuted last year. The M2 could reportedly field eight high-performance cores and two high-efficiency cores, up from a 4+4 configuration in the existing M1.</p><p>      随着Apple的WWDC即将推出，我们期待更多地了解该公司更新的基于ARM的MacBook Pro笔记本电脑。谣言指向Apple启动升级系统的Slate，这次基于其“M2”CPU，去年首次亮起的M1核心的缩放版本。据报道，M2可以举报八个高性能核心和两个高效核心，从现有M1中的4 + 4配置。</p><p> With the launch of the ARM-based M1 came a raft of x86-versus-ARM comparisons and online discussions comparing and contrasting the new architectures. In these threads, you’ll often see authors bring up two additional acronyms: CISC and RISC. The linkage between “ARM versus x86” and “CISC versus RISC” is so strong, every single story on the first page of Google results defines the first with reference to the second.</p><p> 随着扶手的M1推出来到X86的筏子 - 与武术比较和在线讨论比较和对比新架构。在这些线程中，您通常会看到作者提出两份额外的首字母缩略词：CISC和RISC。 “ARM与X86”和“CISC与RISC”之间的联动是如此强大，Google结果的第一页上的每个故事都定义了第一个第二页。</p><p>  This association mistakenly suggests that “x86 versus ARM” can be classified neatly into “CISC versus RISC,” with x86 being CISC and ARM being RISC. Thirty years ago, this was true. It’s not true today. The battle over how to compare x86 CPUs to processors built by other companies isn’t a new one. It only feels new today because x86 hasn’t had a meaningful architectural rival for nearly two decades. ARM may  prominently identify itself as a RISC CPU company, but today these terms conceal as much as they clarify regarding the modern state of x86 and ARM CPUs.</p><p>  这种协会误认为，“X86与ARM”可以整齐地分为“CESC与RISC”，X86是CISC和ARM是RISC。三十年前，这是真的。今天不是真的。关于如何将X86 CPU与其他公司建造的处理器进行比较的战斗不是一个新的。它只感到新的今天，因为X86近二十年没有有意义的建筑竞争对手。 ARM可能会突出地将自己识别为RISC CPU公司，但今天这些条款隐藏着澄清X86和ARM CPU的现代状态。</p><p>   RISC is a term coined by David Patterson and David Ditzel in their 1981 seminal paper “ The Case for a Reduced Instruction Set Computer.” The two men proposed a new approach to semiconductor design based on observed trends in the late 1970s and the scaling problems encountered by then-current CPUs. They offered the term “CISC” — Complex Instruction Set Computer — to describe many of the various CPU architectures already in existence that did not follow the tenets of RISC.</p><p>   RISC是由David Patterson和David DiTzel的一个术语，1981年的精灵纸上“减少指令集电脑的案例”。这两个人提出了一种基于20世纪70年代后期观察到的趋势的新方法，以及当前CPU遇到的缩放问题。他们提供了“CISC”一词 - 复杂的指令集电脑 - 描述已经存在的许多不同的CPU架构，这些架构没有遵循RISC的原则。</p><p> This perceived need for a new approach to CPU design came about as the bottlenecks limiting CPU performance changed. So-called CISC designs, including the original 8086, were designed to deal with the high cost of memory by moving complexity into hardware. They emphasized code density and some instructions performed multiple operations in sequence on a variable. As a design philosophy, CISC attempted to improve performance by minimizing the number of instructions a CPU had to execute in order to perform a given task. CISC instruction set architectures typically offered a wide range of specialized instructions.</p><p> 由于限制CPU性能改变的瓶颈，因此对CPU设计进行了新方法的感知需求。所谓的CISC设计，包括原始8086，旨在通过将复杂性转化为硬件来处理高成本的内存。它们强调代码密度，有些指令在变量上依次执行多个操作。作为一种设计理念，CISC试图通过最小化CPU必须执行的指令数量来提高性能，以便执行给定任务。 CISC指令集架构通常提供广泛的专业说明。</p><p>  By the late 1970s, CISC CPUs had a number of drawbacks. They often had to be implemented across multiple chips, because the VLSI (Very Large Scale Integration) techniques of the time period couldn’t pack all the necessary components into a single package. Implementing complicated instruction set architectures, with support for a large number of rarely used instructions, consumed die space and lowered maximum achievable clock speeds. Meanwhile, the cost of memory was steadily decreasing, making an emphasis on code size less important.</p><p>  到了20世纪70年代末，CISC CPU有很多缺点。它们通常必须跨多个芯片实现，因为时间段的VLSI（非常大规模集成）技术无法将所有必要的组件包装到单个包中。实现复杂的指令集架构，支持大量很多很少使用的指令，消耗芯片空间，降低了可实现的最大时钟速度。同时，内存成本稳步下降，重点是代码规模不太重要。 </p><p> Patterson and Ditzel argued that CISC CPUs were still attempting to solve code bloat problems that had never quite materialized. They proposed a fundamentally different approach to processor design. Realizing that the vast majority of CISC instructions went unused (think of this as an application of the  Pareto principle, or 80/20 rule), the authors proposed a much smaller set of fixed-length instructions, all of which would complete in a single clock cycle. While this would result in a RISC CPU performing less work per instruction than its CISC counterpart, chip designers would compensate for this by simplifying their processors.</p><p>帕特森和DITZEL认为，CISC CPU仍在试图解决从未实现过实物化的代码臃肿问题。他们提出了一种对处理器设计的根本不同的方法。意识到绝大多数CISC指令未使用（将此视为帕累托原则的应用，或80/20规则），提出了一系列较小的固定长度指令，所有这些都将在一个单一中完成时钟周期。虽然这将导致RISC CPU每条指令执行较少的工作，而不是其CICS对应，芯片设计人员将通过简化处理器来弥补这一点。</p><p> This simplification would allow transistor budgets to be spent on other features like additional registers.  Contemplated future features in 1981 included “on-chip caches, larger and faster transistors, or even pipelining.” The goal for RISC CPUs was to execute as close to one IPC (instruction per clock cycle, a measure of CPU efficiency) as possible, as quickly as possible. Reallocate resources in this fashion, the authors argued, and the end result would outperform any comparative CISC design.</p><p> 这种简化将允许晶体管预算在其他寄存器上花费在其他特征上。 1981年预期的未来功能包括“片上缓存，较大且晶体管，甚至管道。” RISC CPU的目标是尽可能快地执行靠近一个IPC（每时钟周期的指令，衡量CPU效率）。作者认为，以这种方式重新分配资源，最终结果将优于任何比较的CISC设计。</p><p>  It didn’t take long for these design principles to prove their worth. The R2000, introduced by MIPS in 1985, was capable of sustaining an IPC close to 1 in certain circumstances. Early RISC CPU families like SPARC and HP’s PA-RISC family also set performance records. During the late 1980s and early 1990s, it was common to hear people say that CISC-based architectures like x86 were the past, and perhaps good enough for home computing, but if you wanted to work with a  real CPU, you bought a RISC chip. Data centers, workstations, and HPC is where RISC CPUs were most successful, as illustrated below:</p><p>  这些设计原则并不需要很长时间来证明他们的价值。由MIPS引入1985年的R2000，在某些情况下，能够维持IPC接近1的IPC。早期RISC CPU系列SPARC和HP的PA-RISC系列也设置了性能记录。在20世纪80年代后期和20世纪90年代初，很常见的是，人们说，X86这样的基于CISC的架构是过去，也许足以满足家庭计算，但如果你想用真正的CPU，你买了一个RISC芯片。数据中心，工作站和HPC是RISC CPU最成功的地方，如下所示：</p><p>  Consider what this image says about the state of the CPU market in 1990. By 1990, x86 had confined non-x86 CPUs to just 20 percent of the personal computer market, but it had virtually no x86 share in data centers and none in HPC. When Apple wanted to bet on a next-generation CPU design, it chose to bet on PowerPC in 1991 because it believed high-performance CPUs built along RISC principles were the future of computing.</p><p>  考虑1990年的CPU市场的状态所说的。到1990年，X86将非X86 CPU限制在个人计算机市场的20％，但它几乎没有X86在数据中心中分享，在数据中心中也没有股权。当Apple想投注下一代CPU设计时，它选择在1991年投注PowerPC，因为它相信沿RISC原则建立的高性能CPU是计算的未来。</p><p> Agreement on the mutual history of CISC versus RISC stops in the early 1990s. The fact that Intel’s x86 architecture went on to dominate the computing industry across PCs, data centers, and high-performance computing (HPC) is undisputed. What’s disputed is whether Intel and AMD accomplished this by adopting certain principles of RISC design or if their claims to have done so were lies.</p><p> 20世纪90年代初期对CISC相互历史的协议。英特尔X86架构继续在PC，数据中心和高性能计算（HPC）中占据占据计算工业的事实无可争议。有什么争议的是，通过采用RISC设计的某些原则，或者如果他们的声称所做的某些原则是谎言，那么intel和AMD是否已经完成了这一点。</p><p>   One of the reasons why terms like RISC and CISC are poorly understood is because of a long-standing disagreement regarding the meaning and nature of certain CPU developments. A pair of quotes will illustrate the problem:</p><p>   RISC和CISC等条款理解的原因之一是因为有关某些CPU发展的意义和性质的长期分歧。一对引号将说明问题：</p><p> First, here’s Paul DeMone from RealWorldTech, in “ RISC vs. CISC Still Matters:”</p><p> 首先，这里是来自Realworldtech的Paul Demone，在“RISC VS.CISC仍然很重要：” </p><p> The campaign to obfuscate the clear distinction between RISC and CISC moved into high gear with the advent of the modern x86 processor implementations employing fixed length control words to operate out-of-order execution data paths… The “RISC and CISC are converging” viewpoint is a fundamentally flawed concept that goes back to the i486 launch in 1992 and is rooted in the widespread ignorance of the difference between instruction set architectures and details of physical processor implementation.</p><p>在使用固定长度控制字的现代X86处理器实现中，使用固定长度控制单位的现代X86处理器实现的出现来运行秩序的执行数据路径的现代X86处理器实现之间的广告系列。“RISC和CISC正在收敛”的观点是一个基本缺陷的概念，返回到1992年的I486发布，并植根于广泛的无知，对指令集架构和物理处理器实现的细节之间的差异。</p><p> In contrast, here’s Jon “Hannibal” Stokes in “ RISC vs. CISC: the Post-RISC Era:”</p><p> 相比之下，这里是“RISC与CISC：后risc时代的risc rise：”的jon“hannibal”Stokes：“</p><p> By now, it should be apparent that the acronyms “RISC” and “CISC” belie the fact that both design philosophies deal with much more than just the simplicity or complexity of an instruction set… In light of what we now know about the the historical development of RISC and CISC, and the problems that each approach tried to solve, it should now be apparent that both terms are equally nonsensical… Whatever “RISC vs. CISC” debate that once went on has long been over, and what must now follow is a more nuanced and far more interesting discussion that takes each platform–hardware and software, ISA and implementation–on its own merits.</p><p> 到目前为止，应该显而易见的是，首字母缩略词“RISC”和“CISC”相信这一事实，设计哲学均以仅仅是指令集的简单性或复杂性......鉴于我们现在所知的历史信息RISC和CISC的发展，以及每种方法都试图解决的问题，现在应该显而易见，这两个术语都同样是荒谬的......无论曾经继续前进的“RISC与CISC”的辩论一样长，现在必须遵循什么是一个更细致的更细微和更有趣的讨论，可带走每个平台 - 硬件和软件，ISA和实现自己的优点。</p><p> Neither of these articles is new. Stokes’ article was written in 1999, DeMone’s in 2000. I’ve quoted from them both to demonstrate that the question of whether the RISC versus CISC distinction is relevant to modern computing is literally more than 20 years old. Jon Stokes is a former co-worker of mine and more than expert enough to not fall into the “ignorance” trap DeMone references.</p><p> 这些文章都不是新的。斯托克斯的文章于1999年被编写，在2000年的德蒙斯。我从他们那里引用，证明RISC与CISC区别的问题与现代计算有关，实际上超过20岁。 Jon Stokes是我的前同事，而且超过专家，不足以落入“无知”陷阱救济参考文献。</p><p>   The two quotes above capture two different views of what it means to talk about “CISC versus RISC.” DeMone’s view is broadly similar to ARM or Apple’s view today. Call this the ISA-centric position.</p><p>   上面的两个引号捕获了谈论“CISC与RISC”意味着什么意思。 DEVONE的观点与今天的ARM或Apple的观点大致相似。称为以ISA为中心的位置。</p><p> Stokes’ viewpoint is what has generally dominated thinking in the PC press for the past few decades. We’ll call this the implementation-centric position. I’m using the word “implementation” because it can contextually refer to both a CPU’s microarchitecture or the process node used to manufacture the physical chip. Both of these elements are relevant to our discussion. The two positions are described as “centric,” because there’s overlap between them. Both authors acknowledge and agree on many trends, even if they reach different conclusions.</p><p> 斯托克斯的观点是过去几十年的PC媒体中的思维思考。我们将此称为以上以上方式的位置。我正在使用“实现”这个词，因为它可以上下文中可以参考CPU的微校验结构或用于制造物理芯片的过程节点。这两个元素都与我们的讨论有关。两个位置被描述为“中心”，因为它们之间存在重叠。即使他们达到不同的结论，这两个作者都承认并同意许多趋势。</p><p> According to the ISA-centric position, there are certain innate characteristics of RISC instruction sets that make these architectures more efficient than their x86 cousins, including the use of fixed-length instructions and a load/store design. While  some of the original differences between CISC and RISC are no longer meaningful, the ISA-centric view believes the remaining differences are still determinative, as far as performance and power efficiency between x86 and ARM are concerned, provided an apples-to-apples comparison.</p><p> 根据ISA的位置，RISC指令集有一定的先天特性，使这些架构比X86表兄弟更有效，包括使用固定长度指令和装载/商店设计。虽然CISC和RISC之间的一些原始差异不再有意义，但以ISA为中心的观点认为剩下的差异仍然是决定性的，就X86和ARM之间的性能和功率效率而言，提供了苹果到苹果的比较。 </p><p>  This ISA-centric perspective holds that Intel, AMD, and x86 won out over MIPS, SPARC, and POWER/PowerPC for three reasons: Intel’s superior process manufacturing, the gradual reduction in the so-called “CISC tax” over time that Intel’s superior manufacturing enabled, and that binary compatibility made x86 more valuable as its install base grew whether or not it was the best ISA.</p><p>这个以ISA为中心的角度持有英特尔，AMD和X86赢得了MIPS，SPARC和Power / PowerPC的三个原因：英特尔的卓越过程制造，即所谓的“CISC税”逐步减少，随着时间的推移，英特尔的优越启用了制造，并且二进制兼容性使x86更有价值，因为它是它是最好的ISA。</p><p> The implementation-centric viewpoint looks to the ways modern CPUs have evolved since terms like RISC and CISC were invented and argues that we’re working with an utterly outdated pair of categories.</p><p> 以实际的观点为中心的观点来看待现代CPU已经进化的方式，自RISC和CISC的术语被发明并且认为我们正在使用完全过时的类别。</p><p> Here’s an example. Today, both x86 and high-end ARM CPUs use out-of-order execution to improve CPU performance. Using silicon to re-order instructions on the fly for better execution efficiency is entirely at odds with the original design philosophy of RISC. Patterson and Ditzel advocated for a less complicated CPU capable of running at higher clock speeds. Other common features of modern ARM CPUs, like SIMD execution units and branch prediction, also didn’t exist in 1981. The original goal of RISC was for all instructions to execute in a single cycle, and most ARM instructions conform to this rule, but the ARMv8 and ARMv9 ISAs contain instructions that take more than one clock cycle to execute. So do modern x86 CPUs.</p><p> 这是一个例子。如今，X86和高端ARM CPU使用超出订单执行以提高CPU性能。使用Silicon以重新订购指令，以便更好地执行效率与RISC的原始设计哲学完全有所不同。 Patterson和Ditzel主张能够以更高的时钟速度运行的较不复杂的CPU。现代臂CPU的其他常见功能，如SIMD执行单元和分支预测，也不存在于1981年.RIS的原始目标是在单个周期中执行所有指令，大多数ARM指令符合此规则，但ARMv8和ARMv9 ISAS包含需要多个时钟周期执行的说明。所以现代X86 CPU。</p><p>  The implementation-centric view argues that a combination of process node improvements and microarchitectural enhancements allowed x86 to close the gap with RISC CPUs long ago and that ISA-level differences are irrelevant above very low power envelopes. This is the point of view backed by a 2014  study on ISA efficiency that I have written about in the past. It’s a point of view generally backed by Intel and AMD, and it’s one  I’ve argued for.</p><p>  以上实施的视图认为，过程节点改进和微架构增强的组合允许x86很久以前与RISC CPU的间隙关闭，并且ISA级别差异在非常低的功率信封上方不相关。这是2014年对我过去撰写的ISA效率研究的观点。这是英特尔和AMD支持一般支持的观点，是我争论的。</p><p>   The implementation-centric view is that CISC and RISC CPUs have evolved towards each other for decades, beginning with the adoption of new “RISC-like” decoding methods for x86 CPUs in the mid-1990s.</p><p>   以实心为中心的视图是，在20世纪90年代中期采用X86 CPU的新“RISC样”解码方法，CISC和RISC CPU已经发展到了几十年。</p><p>  The common explanation goes like this: In the early 1990s, Intel and other x86 CPU manufacturers realized that improving CPU performance in the future would require more than larger caches or faster clocks. Multiple companies decided to invest in x86 CPU microarchitectures that would reorder their own instruction streams on the fly to improve performance. As part of that process, native x86 instructions were fed into an x86 decoder and translated to “RISC-like” micro-ops before being executed.</p><p>  常见的解释是这样的：在20世纪90年代初，英特尔和其他X86 CPU制造商意识到，将来提高CPU性能需要更多的缓存或更快的时钟。多家公司决定投资于X86 CPU微体系结构，即在飞行中重新排序自己的指令流以提高性能。作为该过程的一部分，本地X86指令被馈送到x86解码器中，并在执行之前转换为“risc样”微型操作。</p><p> This has been the conventional wisdom for over two decades now, but it’s been challenged again recently. In a story posted to Medium  back in 2020, Erik Engheim wrote: “There are no RISC internals in x86 chips. That is just a marketing ploy.” He points to both DeMone’s story and a quote by Bob Colwell, the chief architect behind the P6 microarchitecture.</p><p> 这是现在二十年来的传统智慧，但最近被挑战了。在2020年发布到中等后的故事中，Erik Engheim写道：“X86芯片中没有RISC内部。这只是一个营销伎俩。“他指出了P6微架构后面的首席建筑师Bob Colwell的Semone的故事和报价。 </p><p> The P6 microarchitecture was the first Intel microarchitecture to implement out-of-order execution and a native x86-to-micro-op decode engine. P6 was shipped as the Pentium Pro and it evolved into the Pentium II, Pentium 3, and beyond. It’s the grandfather of modern x86 CPUs. If anyone ought to know the answer to this question, it would be Colwell, so here’s what he  had to say:</p><p>P6 MicroArchitecture是第一个用于实现订单超出执行和天然X86到微型OP解码引擎的Intel微架构。 P6作为奔腾专业人士运送，它进化到奔腾II，奔腾3及以后。这是现代X86 CPU的祖父。如果有人应该知道这个问题的答案，那将是Colwell，所以这就是他所说的话：</p><p>  Intel’s x86’s do NOT have a RISC engine “under the hood.” They implement the x86 instruction set architecture via a decode/execution scheme relying on mapping the x86 instructions into machine operations, or sequences of machine operations for complex instructions, and those operations then find their way through the microarchitecture, obeying various rules about data dependencies and ultimately time-sequencing.</p><p>  英特尔的X86在引擎盖下没有RISC发动机。它们通过依赖于将x86指令映射到机器操作中的解码/执行方案来实现x86指令集架构，或者为复杂指令的机器操作序列，然后通过微校验结构找到它们的方式，遵守数据依赖性的各种规则和最终排序。</p><p> The “micro-ops” that perform this feat are over 100 bits wide, carry all sorts of odd information, cannot be directly generated by a compiler, are not necessarily single cycle. But most of all, they are a microarchitecture artifice — RISC/CISC is about the instruction set architecture… The micro-op idea was not “RISC-inspired”, “RISC-like”, or related to RISC at all. It was our design team finding a way to break the complexity of a very elaborate instruction set away from the microarchitecture opportunities and constraints present in a competitive microprocessor.</p><p> 执行此专长的“微型操作”超过100位宽，携带各种奇数信息，不能由编译器直接生成，不一定是单周期。但大多数情况下，它们是微型建筑技巧 -  RISC / CISC是关于指令集架构......微型op的想法并非“RISC启发”，“RISC样”，或者与RISC相关。我们的设计团队找到一种方法来打破远离竞争微处理器中存在的微体系结构机会和限制的非常精致的指令的复杂性。</p><p>    Not exactly.  (Click above for an approximation of how I feel when even appearing  to contradict Bob Colwell)</p><p>    不完全是。 （点击上面的近似似乎在出现矛盾的鲍勃Colwell时感觉如何</p><p> Intel wasn’t the first x86 CPU manufacturer to combine an x86 front-end decoder with what was claimed to be a “RISC-style” back-end. NexGen, later acquired by AMD, was. The NexGen 5×86 CPU debuted in March 1994, while the Pentium Pro wouldn’t launch until November 1995. Here’s how NexGen described its CPU: “The Nx586 processor is the first implementation of NexGen’s innovative and patented  RISC86 microarchitecture.” (Emphasis added). Later, the company gives some additional detail: “The innovative RISC86 approach dynamically translates x86 instructions into RISC86 instructions. As shown in the figure below, the Nx586 takes advantage of RISC performance principles. Due to the RISC86 environment, each execution unit is smaller and more compact.”</p><p> 英特尔不是第一个将X86前端解码器组合在一起的X86 CPU制造商，其中包含了“RISC-Sique”后端的内容。 Nexgen，后来被AMD获得的。 Nexgen 5×86 CPU于1994年3月首次亮相，而Pentium Pro将不会推出至1995年11月。这是Nexgen描述其CPU的方式：“NX586处理器是Nexgen的创新和专利RISC86微体建筑的第一次实施。” （重点添加）。后来，该公司提供了一些额外的细节：“创新的RISC86方法将X86指令动态转换为RISC86说明。如下图所示，NX586利用RISC性能原则。由于RISC86环境，每个执行单元较小，更紧凑。“</p><p>  It could still be argued that this is marketing speak and nothing more, so let’s step ahead to 1996 and the AMD K5. The K5 is typically described as an x86 front-end married to an execution backend AMD borrowed from its 32-bit RISC micro-controller, the Am29000. Before we check out its block diagram, I want to compare it against the original Intel Pentium. The Pentium is arguably the pinnacle of CISC x86 evolution, given that it implements both pipelining and superscaling in an x86 CPU, but does not translate x86 instructions into micro-ops and lacks an out-of-order execution engine.</p><p>  仍然可以争辩说，这是营销的说话，而且更多的是，让我们走到1996年和AMD K5。 K5通常被描述为与从其32位RISC微控制器，AM29000借用的执行后端AMD的X86前端。在查看其框图之前，我想将其与原始英特尔奔腾进行比较。 Pentium可以说是CISC X86演进的巅峰，因为它在X86 CPU中实现了流水线和超级，但不会将X86指令转换为微型操作，并且缺乏偏转的执行引擎。</p><p>    If you’ve spent any time looking at microprocessor block diagrams, the K5 should look familiar in a way that the Pentium doesn’t. AMD bought NexGen after the launch of the Nx586. The K5 was a homegrown AMD design, but K6 was originally a NexGen product. From this point forward, CPUs start  looking more like the chips we’re familiar with today. And according to the engineers that designed these chips, the similarities ran more than skin deep.</p><p>    如果您花了任何时间看微处理器框图，K5应该看起来熟悉奔腾没有的方式。 AMD在发射NX586后买了Nexgen。 K5是本土AMD设计，但K6最初是Nexgen产品。从这一点前进，CPU开始看起来更像是我们熟悉的筹码。根据设计这些芯片的工程师，相似之处比皮肤深度多。 </p><p> David Christie of AMD  published an article in IEEE Micro on the K5 back in 1996 that speaks to how it hybridized RISC and CISC:</p><p>AMD的David Christie于1996年在K5的K5上发表了一篇文章，涉及其杂交的RISC和CISC：</p><p> We developed a micro-ISA based loosely on the 29000’s instruction set. Several additional control fields expanded the microinstruction size to 59 bits. Some of these simplify and speed up the superscalar control logic. Others provide x86-specific functionality that is too performance critical to synthesize with sequences of micro instructions. But these micro instructions still adhere to basic RISC principles: simple register-to register operations with fixed-position encoding of register specifiers and other fields, and no more than one memory reference per operation. For this reason we call them RISC operations, or ROPs for short (pronounced R-ops). Their simple, general-purpose nature gives us a great deal of flexibility in implementing the more complex x86 operations, helping to keep the execution logic relatively simple.</p><p> 我们在29000年代的指令集上摆脱了一款微型ISA。几个额外的控制字段扩展了MicroInstruction大小至59位。其中一些简化并加快超卡控制逻辑。其他提供x86特定的功能，这对于综合微型指令序列来说是至关重要的。但这些微型指令仍然坚持基本的RISC原则：简单的寄存器 - 以寄存器说明符和其他字段的固定位置编码注册操作，每个操作不超过一个内存参考。出于这个原因，我们称之为RISC操作，或短（发音为R-OP）的ROPS。他们简单，通用的性质使我们在实现更复杂的x86操作方面使我们有着极大的灵活性，有助于保持执行逻辑比较简单。</p><p>  The most important aspect of the RISC microarchitecture, however, is that the complexity of the x86 instruction set stops at the decoder and is largely transparent to the out-of-order execution core. This approach requires very little extra control complexity beyond that needed for speculative out-of-order RISC execution to achieve speculative out-of-order x86 execution. The ROP sequence for a task switch looks no more complicated than that for a string of simple instructions. The complexity of the execution core is effectively isolated from the complexity of the architecture, rather than compounded by it.</p><p>  然而，RISC微架构的最重要方面是X86指令集的复杂性在解码器处停止，并且对终止执行核心很透明。这种方法需要极大的控制复杂性，超出投机超出RISC执行所需的额外控制复杂性，以实现投机性超出X86执行。任务交换机的ROP序列看起来没有比一串简单指令更复杂。执行核心的复杂性有效地隔离了架构的复杂性，而不是由它复杂。</p><p> Christie is not confusing the difference between an ISA and the details of a CPU’s physical implementation. He’s arguing that the physical implementation is itself “RISC-like” in significant and important ways.</p><p> Christie并不令人困惑ISA与CPU的物理实施的细节。他认为，实际实施本身就是“RISC样”，以重要而重要的方式。</p><p> The K5 re-used parts of the execution back-end AMD developed for its Am29000 family of RISC CPUs, and it implements an internal instruction set that is more RISC-like than the native x86 ISA. The RISC-style techniques NexGen and AMD refer to during this period reference concepts like data caches, pipelining, and superscalar architectures. Two of these — caches and pipelining — are named in Patterson’s paper. None of these ideas are  strictly RISC, but they all debuted in RISC CPUs first, and they were advantages associated with RISC CPUs when K5 was new. Marketing these capabilities as “RISC-like” made sense for the same reason it made sense for OEMs of the era to describe their PCs as “IBM-compatible.”</p><p> K5重新使用的部分执行后端AMD为其AM29000 RISC CPU开发，它实现了一个更频繁的内部指令集，而不是原生X86 ISA。 RISC样式技术Nexgen和AMD在此期间参考数据库，流水线和超卡架构等参考概念。其中两个 - 缓存和流水线 - 以帕特森的纸命名。这些想法都不是严格的RISC，但他们都在RISC CPU首先在RISC CPU中首次亮相，当K5是新的时，他们是与RISC CPU相关的优势。营销这些能力作为“类似于RISC的”是有道理的，因为它对时代的OEM描述了他们的PC作为“IBM兼容”所作的感觉。</p><p>  The degree to which these features are RISC and the answer to whether x86 CPUs decode RISC-style instructions depends on the criteria you choose to frame the question. The argument is larger than the Pentium Pro, even if P6 is the microarchitecture most associated with the evolution of techniques like an out-of-order execution engine. Different engineers at different companies had their own viewpoints.</p><p>  这些功能是RISC的程度，答案x86 CPU解码RISC样式指令取决于您选择框架的标准。该参数比Pentium Pro大，即使P6是与阶层超时的执行引擎的技术的演变最多相关的微体系结构。不同公司的不同工程师有自己的观点。</p><p>   It’s time to pull this discussion into the modern era and consider what the implications of this “RISC versus CISC” comparison are for the ARM and x86 CPUs actually shipping today. The question we’re really asking when we compare AMD and Intel CPUs with Apple’s M1 and future M2 is whether there are historical x86 bottlenecks that will prevent x86 from competing effectively with Apple and future ARM chips from  companies such as Qualcomm?</p><p>   现在是时候将这一讨论拉到现代时代，并考虑到这一“RISC与CISC”比较的影响是为了当今实际发运的ARM和X86 CPU。我们真正询问我们在与Apple的M1和Future M2比较AMD和Intel CPU时是否存在历史X86瓶颈，这将防止X86有效地与苹果公司和未来的武器筹码有关高通公司的公司吗？ </p><p>  According to AMD and Intel: No. According to ARM: Yes. Since all of the companies in question have obvious conflicts of interest, I asked Agner Fog instead.</p><p>根据AMD和英特尔：不，根据ARM：是的。由于有问题的所有公司都有明显的利益冲突，我询问了Agner Fog。</p><p> Agner Fog is a Danish evolutionary anthropologist and computer scientist, known for the extensive resources he maintains on the x86 architecture. His microarchitectural manuals  are practically required reading if you want to understand the low-level behavior of various Intel and AMD CPUs:</p><p> Agner Fog是一位丹麦进化人类学家和计算机科学家，以其在X86架构上维护的广泛资源而闻名。如果您想了解各种英特尔和AMD CPU的低级行为，他的微观建筑手册实际上是必需的阅读：</p><p> ISA is not irrelevant. The x86 ISA is very complicated due to a long history of small incremental changes and patches to add more features to an ISA that really had no room for such new features…</p><p> ISA不是无关紧要的。由于小增量变化和补丁的历史悠久，x86 isa非常复杂，以向ISA添加更多特征，这对于这种新功能没有空间......</p><p>  The complicated x86 ISA makes decoding a bottleneck. An x86 instruction can have any length from 1 to 15 bytes, and it is quite complicated to calculate the length. And you need to know the length of one instruction before you can begin to decode the next one. This is certainly a problem if you want to decode 4 or 6 instructions per clock cycle! Both Intel and AMD now keep adding bigger micro-op caches to overcome this bottleneck. ARM has fixed-size instructions so this bottleneck doesn’t exist and there is no need for a micro-op cache.</p><p>  复杂的X86 ISA使瓶颈进行解码。 X86指令可以具有1到15个字节的任何长度，计算长度非常复杂。并且在开始解码下一个指令之前，您需要知道一个指令的长度。如果您要解码每个时钟周期的4或6个指令，这肯定是一个问题！ Intel和AMD都是继续添加更大的Micro-Op缓存以克服这个瓶颈。 ARM具有固定尺寸的指示，因此该瓶颈不存在，并且不需要微型op缓存。</p><p> Another problem with x86 is that it needs a long pipeline to deal with the complexity. The branch misprediction penalty is equal to the length of the pipeline. So they are adding ever-more complicated branch prediction mechanisms with large branch history tables and branch target buffers. All this, of course, requires more silicon space and more power consumption.</p><p> X86的另一个问题是它需要一个长期的管道来处理复杂性。分支错误规定的罚款等于管道的长度。因此，它们正在添加具有大分支历史表和分支目标缓冲区的更加复杂的分支预测机制。当然，这一切都需要更多的硅空间和更多的功耗。</p><p> The x86 ISA is quite successful despite of these burdens.</p><p> 尽管这些负担，X86 ISA非常成功。</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.extremetech.com/computing/323245-risc-vs-cisc-why-its-the-wrong-lens-to-compare-modern-x86-arm-cpus">https://www.extremetech.com/computing/323245-risc-vs-cisc-why-its-the-wrong-lens-to-compare-modern-x86-arm-cpus</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/cisc/">#cisc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/wrong/">#wrong</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>