<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用于web项目的简单无密码身份验证Simple passwordless authentication for web projects</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Simple passwordless authentication for web projects<br/>用于web项目的简单无密码身份验证</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-21 11:36:15</div><div class="page_narrow text-break page_content"><p>I hate passwords. Not as a user as password management is basically solved with most modern browsers and password managers.What I hate is having to deal with them as a developer. Hashing, storing, authentication, etc.</p><p>我讨厌密码。大多数现代浏览器和密码管理器基本上解决了密码管理问题。我讨厌的是作为一个开发人员来处理他们。散列、存储、身份验证等。</p><p> I did a small project recently using my socket.io synced vuex state and needed a system where users could easily login.I will put a  huge disclaimer on this that this is just what I did for my personal project where security isn’t critical.If a login gets stolen, it’s to a silly game that my friends and I play.The techniques described shouldn’t be used in production without some refinement.If you have ideas on how to implement this in a more secure way, definitely reach out to me!</p><p>我最近用我的套接字做了一个小项目。io同步了vuex状态，需要一个用户可以轻松登录的系统。我将在此声明，这正是我为我的个人项目所做的，安全性并不重要。如果登录被窃取，那就是我和朋友玩的一个愚蠢的游戏。所描述的技术不应在生产中使用，除非经过一些改进。如果你对如何以更安全的方式实现这一点有想法，一定要联系我！</p><p>  I’m using express as a server, so I’ll put that out there as a baseline.I’m also using TypeScript, because why would you not use it?Setting up my server I have a controller type file that I can pass in.So here’s my server file:</p><p>我使用express作为服务器，所以我将把它作为基准。我也在使用TypeScript，因为你为什么不使用它呢？在设置服务器时，我有一个控制器类型的文件，可以传入。这是我的服务器文件：</p><p> // SERVER CODE  import  express  from  &#34;express&#34;; import  bodyParser  from  &#34;body-parser&#34;; import  path  from  &#34;path&#34;; import  http  from  &#34;http&#34;; import  AuthController  from  &#39;./controllers/auth&#39;; // configure the app and folder locations  const  app  =  express(); // Reset the database every time we start the database  const  db  =  GetDB(); db. connect(); // Serve static content  const  server  =  http. createServer( app); AuthController( app,  db); app. use( express. static( client_folder)); app. get( &#34;/api/*&#34;, ( req, res) =&gt;{  res. status( 404). send( &#34;NOT FOUND&#34;);}) app. post( &#34;/api/*&#34;, ( req, res) =&gt;{  res. status( 404). send( &#34;NOT FOUND&#34;);}) app. get( &#39;*&#39;, ( req,  res)  =&gt; {  res. sendFile( path. resolve( client_folder,  &#39;index.html&#39;));}); server. listen( app. get( &#34;port&#34;), ()  =&gt; {  console. log(  &#34;App is running at http://localhost:%d in %s mode&#34;,  app. get( &#34;port&#34;),  app. get( &#34;env&#34;) );  console. log( &#34;Press CTRL-C to stop\n&#34;);});</p><p>//服务器代码从&#34导入express；快递&#34；；从&#34导入bodyParser；体分析器&#34；；从&#34导入路径；路径&#34；；从&#34导入http；http&#34；；从&#39；导入AuthController/控制器/auth&#39；；//配置应用和文件夹位置const app=express（）；//每次启动数据库const db=GetDB（）时重置数据库；db。connect（）；//服务静态内容const server=http。createServer（应用程序）；AuthController（应用程序，数据库）；应用程序。使用（express.static（client_文件夹））；应用程序。获取（&#34；/api/*&#34；，（请求、回复）=&gt；{res.status（404）.send（&#34；找不到&#34；）；}）应用程序。post（&#34；/api/*&#34；，（请求、回复）=&gt；{res.status（404）.send（&#34；找不到&#34；）；}）应用程序。获取（&#39；*&#39；，（请求、回复）=&gt；{res.sendFile（path.resolve（client_folder，&#39；index.html&#39；）；}）；服务器听（app.get（&#34；port&#34；），（）=&gt；{console.log（&#34；应用程序正在运行http://localhost:%d在%s模式下&#34；，应用程序。获取（&#34；端口&#34；），应用程序。获取（&#34；env&#34；）；安慰日志（&#34；按CTRL-C停止\n&#34；）；）；</p><p> It’s trimmed down a but you can get the idea of where I’m going.This is me hand trimming my code down, so don’t expect to copy and paste this and get off to the races.</p><p>它被修剪了一段，但你可以知道我要去哪里。这是我手工修改代码的过程，所以不要指望复制并粘贴这些代码，然后去参加比赛。</p><p> You might notice I have something called the auth controller. The auth controller is where the magic happens.</p><p>你可能会注意到我有一个叫做auth控制器的东西。auth控制器是魔法发生的地方。</p><p>     import {  Express }  from  &#34;express&#34;; export  default  function  RegisterEndPoints( app:  Express,  db:  DataBase) {  app. post( ApiEndpointRoot  +  ApiEndpoints. LOGIN_TEMP,  async ( req,  res)  =&gt; {  // ...  });  // magic link login   app. get( ApiEndpointRoot  +  ApiEndpoints. LOGIN_MAGIC,  async ( req,  res)  =&gt; {  // ...  });  // Attempt to login a user   app. post( ApiEndpointRoot  +  ApiEndpoints. LOGIN,  async ( req,  res)  =&gt; {  // ...  });  // check if we&#39;re logged in   app. use( async ( req,  res,  next)  =&gt; {  // ...  });  app. get( ApiEndpointRoot  +  ApiEndpoints. LOGOUT, ( req,  res)  =&gt; {  // clear the login token   res. clearCookie( &#39;token&#39;);  res. redirect( &#34;/&#34;); });}</p><p>从&#34导入{Express}；快递&#34；；导出默认函数RegisterEndPoints（app:Express，db:DataBase）{app.post（apidentroot+apidentpoints.LOGIN_TEMP，async（req，res）=&gt；{//…}）；//神奇链接登录应用。get（ApiEndpointRoot+ApiEndpoints.LOGIN_MAGIC，async（req，res）=&gt；{  // ...  });  // 尝试登录用户应用程序。post（APINDPROOT+APINDPROOT.LOGIN，异步（req，res）=&gt；{  // ...  });  // 检查我们是否&#39；重新登录应用程序。使用（异步（req、res、next）=&gt；{  // ...  });  应用程序。获取（ApiEndpointRoot+ApiEndpoints.LOGOUT，（req，res）=&gt；{//清除登录令牌res.clearCookie（&#39；令牌&#39；）；res.重定向（&#34；/&#34；）；）</p><p> I’ve taken out some of the code for brevity.In this project, the client and server are in the same repo and are built together.They have a folder called  common that includes the state machine that powered the game, API endpoint definitions, and common types.Makes it really handy to make sure that the server and the client won’t get out of sync from a development standpoint, since typescript catches a lot of things.Doesn’t make it fool proof (browser caches can be tricky for weird bugs), but it solves a lot of problems as projects get larger.</p><p>为了简洁起见，我删除了一些代码。在这个项目中，客户机和服务器位于同一个repo中，并且构建在一起。他们有一个名为common的文件夹，其中包括为游戏提供动力的状态机、API端点定义和公共类型。从开发的角度来看，确保服务器和客户端不会失去同步非常方便，因为typescript捕获了很多东西。这并不能让它变得简单（浏览器缓存对于奇怪的bug来说可能很棘手），但随着项目规模的扩大，它解决了很多问题。</p><p> There’s a few helper functions, mostly around reading and writing the JWT token.</p><p>有几个助手函数，主要是关于读取和写入JWT令牌的。</p><p> export  function  DecodeJwtToken( token:  string) :  JwtUser  |  null {  const  results  = ( JwtDecode( token)  as  any);  if ( results  ==  null)  return  null;  const  user:  JwtUser  = {  name:  results.name,  _id:  results._id,  temporary:  results.temporary, };  return  user;} function  GiveToken( token_user:  JwtUser,  res:  any,  message:  string,  temporary?:  boolean) {  if ( temporary  ==  undefined  ||  temporary  ==  null)  temporary  =  false;  const  expireInHours  =  temporary  ?  24 :  10000;  // about a year   const  token  =  JwtSign( token_user,  JWT_SECRET, {  expiresIn:  expireInHours  +  &#39;h&#39; });  res. cookie( &#39;token&#39;,  token, {  maxAge:  1000  *  60  *  60  *  expireInHours,  secure: true });  if ( message  !=  &#39;&#39;) {  res. json({  token,  message }); }} function  GenerateMagicCode() {  const  magic_key_length  =  25;  const  characters  =  &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#39;;  const  charactersLength  =  characters. length;  let  result  = Array( magic_key_length). fill( &#39;&#39;). map(( x) =&gt; characters. charAt(Math. floor(Math. random()  *  charactersLength))). join( &#39;&#39;);  return  result;}</p><p>导出函数DecodeJwtToken（令牌：字符串）：JwtUser |null{const results=（JwtDecode（令牌）如有）；if（results==null）返回null；const user:JwtUser={name:results.name，_id:results._id，temporary:results.temporary，}；返回用户；}函数GiveToken（token_user:JwtUser，res:any，message:string，temporary？：boolean）{if（temporary==undefined | | temporary==null）temporary=false；const expireInHours=temporary？24:10000；//大约一年const token=JwtSign（token_user，jwtu SECRET，{expiresIn:expireInHours+&#39；h&#39；}）；res.cookie（&#39；token&#39；，token，{maxAge:1000*60*60*expireInHours，secure:true}）；如果（消息！=&#39；&#39；）{res.json（{token，message}）；}函数生成器magiccode（）{const magic_key_length=25；const characters=&#39；abcdefghijklmnopqrstuvxyzabcdefghijklmnopqrstuvxyzo123456789&#39；；const charactersLength=characters.length；let result=Array（magic#key_length）。fill（&#39；&#39；&#39；）。地图（（x）=&gt；角色。charAt（Math.floor（Math.random（）*charactersLength）））。加入（&#39；&#39；）；返回结果；}</p><p> There are three functions: one to decode a token, one to give a token, and one to generate a magic code.The token is just stored in a browser cookie named  token.In the future, it would be nice to have some sort of browser specific fingerprint encoded in the token.Or some other mechanism to prevent cookies from being stolen from the browser and used.Perhaps in the future, some sort of refresh token mechanism could be employed.Right now a session will last a very long time. In the future, there could be a refresh dance that isn’t often transmitted (maybe in localstorage or something).</p><p>有三个功能：一个用于解码令牌，一个用于给出令牌，一个用于生成魔法代码。令牌存储在名为token的浏览器cookie中。将来，在令牌中编码某种特定于浏览器的指纹会很好。或者其他一些机制来防止cookie从浏览器中被盗并被使用。也许在未来，可以使用某种刷新令牌机制。现在，一个会议将持续很长时间。在未来，可能会有一个不经常传输的刷新舞蹈（可能在本地存储或其他地方）。</p><p>  export  default  function  RegisterEndPoints( app:  Express,  db:  DataBase) {  // ...   app. post( ApiEndpointRoot  +  ApiEndpoints. LOGIN_TEMP,  async ( req,  res)  =&gt; {  try {  const  new_user_data:  User  = {  email :  &#39;&#39;,  name:  RandomName(),  temporary:  true, }  let  new_user  =  await  db. userAdd( new_user_data);  if ( new_user  ==  null) {  res. status( 500). send( &#34;Unable to create temporary user&#34;);  return; }  const  token_user:  JwtUser  = {  _id:  new_user._id,  name:  new_user.name,  temporary:  true, };  GiveToken( token_user,  res,  &#34;Created new temp account&#34;,  true);  return; }  catch ( e) {  console. error( &#34;LoginUserTemp error:&#34;  +  e);  res. status( 500). send( &#34;Not implemented&#34;); } });  // ...</p><p>导出默认函数RegisterEndPoints（app:Express，db:DataBase）{/..app.post（apidemproot+apidemps.LOGIN_TEMP，async（req，res）=&gt；{try{const new_user_data:user={email:&#39；&#39；，name:RandomName（），temporary:true，}让新用户=wait db。用户添加（新用户数据）；if（new#u user==null）{res.status（500）.send（&#34；无法创建临时用户&#34；）；返回；}const token_user:JwtUser={_id:new_user._id，name:new_user.name，temporary:true，}；GiveToken（token#u user，res，&#34；创建了新的临时帐户&#34；，true）；返回；}catch（e）{console.error（&#34；LoginUserTemp error:&#34；+e）；res.status（500）。send（&#34；Not implemented（&#34；）；}）//。。。</p><p> Basically, we generate a new user in the database, marking them as temporary.Any account that is marked as temporary and is more than 36 hours old is cleaned out of the database.We give them a token that only lasts 24 hours and there is no way to upgrade to a permanent account.</p><p>基本上，我们在数据库中生成一个新用户，将其标记为临时用户。任何被标记为临时且使用时间超过36小时的帐户都将从数据库中清除。我们给他们一个只持续24小时的代币，而且无法升级到永久账户。</p><p> export  default  function  RegisterEndPoints( app:  Express,  db:  DataBase) {  // ...   // Attempt to login a user   app. post( ApiEndpointRoot  +  ApiEndpoints. LOGIN,  async ( req,  res)  =&gt; {  if ( req. body[ &#39;email&#39;]  ==  undefined) {  res. status( 300). send( &#34;Email missing&#34;);  return; }  const  email  =  req. body[ &#39;email&#39;];  if ( req. body[ &#39;email&#39;]  ==  &#39;&#39;) {  res. status( 300). send( &#34;Email blank&#34;);  return; }  const  valid_email  =  validateEmail( email);  if ( ! valid_email) {  res. status( 300). send( &#34;Email is not valid&#34;);  return; }  let  user  =  await  AttemptLoginOrRegister( db,  email);  if ( user  ==  null) {  res. status( 300). send( &#34;Unable to create new account&#34;);  return; }  if ( user  ==  &#39;email&#39;) {  // tell the user to check their email   res. send( &#34;Check email&#34;);  return; }  const  token_user:  JwtUser  = {  _id:  user._id,  name:  user.name,  temporary:  user.temporary  ||  false, };  GiveToken( token_user,  res,  &#34;created user&#34;); });</p><p>导出默认函数RegisterEndPoints（app:Express，db:DataBase）{//……//尝试登录用户app.post（apidentroot+apidentpoints.login，async（req，res）=&gt；{if（req.body[&#39；email&#39；]）=未定义）{res.status（300）。发送（&#34；电子邮件丢失&#34；）；返回；}const email=req。正文[&#39；电子邮件&#39；]；如果（请求正文[&#39；电子邮件&#39；]）=&#39;&#39;) {res.status（300）。发送（&#34；电子邮件空白&#34；）；返回；}const valid_email=validateEmail（电子邮件）；如果（！valid_email）{res.status（300）。发送（&#34；email无效&#34；）；返回；}let user=wait AttemptLoginOrRegister（数据库，电子邮件）；if（user==null）{res.status（300）.send（&#34；无法创建新帐户&#34；）；返回；}如果（用户==&#39；电子邮件&#39；）{//告诉用户检查他们的电子邮件资源。发送（&#34；检查电子邮件&#34；）；返回；}const-token_-user:JwtUser={u-id:user._-id，name:user.name，temporary:user.temporary | | false，}；GiveToken（token#u user，res，&#34；created user&#34；）；}）；</p><p> Here we expect a post request that expects an email inside.We validate the email (you’ll need to provide this function) and then call  AttemptLogin.If the user already exists, we return back  email which is a dumb design that tells us the account already exists.Otherwise, a new user is created.</p><p>在这里，我们期待一个post请求，其中包含一封电子邮件。我们验证电子邮件（您需要提供此功能），然后调用AttemptLogin。如果用户已经存在，我们会返回电子邮件，这是一个愚蠢的设计，告诉我们帐户已经存在。否则，将创建一个新用户。</p><p> // Attempt to login a given email, if they already exist then   async  function  AttemptLoginOrRegister( db:  DataBase,  email:  string) :  Promise&lt; DbUser  |  null  |  &#39; email &#39;&gt; {  try {  if ( email  ==  &#39;&#39;)  return  null;  // Step 1: check if the user already exists, if so return email   const  user  =  await  db. userFind( email,  null);  // The user exists, set their magic code and return   if ( user  !=  null) {  // TODO: generate a magic thing and set it into their user   const  magic_code  =  GenerateMagicCode();  user. magicCode  =  magic_code;  sendMagicCodeEmail( user,  magic_code);  console. log( &#34;http://localhost:3000&#34; + ApiEndpointRoot + ApiEndpoints. LOGIN_MAGIC + &#34;?code=&#34; + magic_code + &#34;&amp;id=&#34; + user. _id);  await  db. userUpdate( user);  return  &#39;email&#39;; }  const  name_parts  =  email. split( &#39;@&#39;);  const  name  =  name_parts[ 0];  // Step 2: the user doesn&#39;t exist so we need to create them   const  new_user_data:  User  = {  email,  name, }  let  new_user  =  await  db. userAdd( new_user_data);  if ( new_user  ==  null)  return  null;  return  new_user; }  catch ( e) {  console. error( &#34;AttemptLoginOrRegister error:&#34;  +  e);  return  null; }}</p><p>//尝试登录给定的电子邮件，如果它们已经存在，那么异步函数AttemptLoginOrRegister（db:DataBase，email:string）：Promise&lt；DbUser | null |和#39；电子邮件&#39&gt；{试试{if（email==&#39；&#39；）返回null；//第一步：检查用户是否已经存在，如果已经存在，返回email const user=wait db。userFind（电子邮件，空）；//用户存在，设置他们的魔法代码并返回if（user！=null）{//TODO:生成一个魔法东西，并将其设置到他们的用户const magic_code=GenerateMagicCode（）；user.magicCode=magic_code；sendMagicCodeEmail（user，magic_code）；console.log（&#34；http://localhost:3000&#34; + ApiEndpointRoot+ApiEndpoints。登录_MAGIC+&#34；？代码=&#34；+魔法代码+&#34&amp；id=&#34；+用户_身份证）；等待db。用户更新（用户）；返回&#39；电子邮件&#39；}const name_parts=电子邮件。分裂（&#39；@&#39；）；const name=name_parts[0]；//第二步：用户不&#39；t exist所以我们需要创建它们const new_user_data:user={email，name，}let new_user=wait db。用户添加（新用户数据）；if（new_user==null）返回null；返回新用户；}catch（e）{console.error（&#34；AttemptLoginOrRegister error:&#34；+e）；返回null；}}</p><p> In a nutshell, if they try to login in, we create a magic code in the database which gets sent to their email.Otherwise, if it’s a unique email, create a new account and sign them in.By default their username is the first part of the their email. However, usernames are not unique, emails are.</p><p>简而言之，如果他们试图登录，我们会在数据库中创建一个魔法代码，并将其发送到他们的电子邮件中。否则，如果是一封独特的电子邮件，请创建一个新帐户并登录。默认情况下，他们的用户名是电子邮件的第一部分。然而，用户名不是唯一的，电子邮件是唯一的。</p><p>  export  default  function  RegisterEndPoints( app:  Express,  db:  DataBase) {  // ...   // magic link login   app. get( ApiEndpointRoot  +  ApiEndpoints. LOGIN_MAGIC,  async ( req,  res)  =&gt; {  if ( req. query[ &#39;code&#39;]  ==  undefined) {  res. status( 300). send( &#34;Code missing&#34;);  return; }  if ( req. query[ &#39;id&#39;]  ==  undefined) {  res. status( 300). send( &#34;id missing&#34;);  return; }  const  id  = parseInt( req. query[ &#39;id&#39;]. toString());  const  user  =  await  db. userFind( null,  id);  if ( user  ==  null) {  res. status( 300). send( &#34;user not found&#34;);  return; }  const  magic  =  req. query[ &#39;code&#39;];  const  curr_magic  =  user. magicCode;  // erase the magic code   if ( user. magicCode  !=  &#39;&#39;) {  user. magicCode  =  &#39;&#39;;  db. userUpdate( user); }  // check if they don&#39;t have a magic code   if ( curr_magic  ==  null  ||  curr_magic  ==  undefined  ||  user. temporary  ||  curr_magic  ==  &#39;&#39;  ||  magic  != curr_magic) {  res. status( 300). send( &#34;Magic code doesn&#39;t match&#34;);  // TODO: erase magic code?   return; }  const  token_user:  JwtUser  = {  _id:  user._id,  name:  user.name,  temporary:  user.temporary  ||  false, };  res. status( 200)  GiveToken( token_user,  res,  &#34;&#34;);  //res.send(&#34;&lt;script&gt;window.location.replace(&#39;/&#39;);&lt;/script&gt;&#34;)   res. redirect( &#34;/&#34;)  return });</p><p>导出默认函数RegisterEndPoints（app:Express，db:DataBase）{//…//magic link login app.get（apidentroot+apidentpoints.login_magic，async（req，res）=&gt；{if（req.query[&#39；code&#39；]）=未定义）{res.status（300）.发送（&#34；代码缺失&#34；）；返回；}如果（请求查询[&#39；id&#39；]）=未定义）{res.status（300）.send（&#34；id缺失&#34；）；返回；}const id=parseInt（请求查询[&#39；id&#39；]）。toString（））；const user=wait db。userFind（null，id）；if（user==null）{res.status（300）.send（&#34；找不到用户&#34；）；返回；}const magic=req。查询[&#39；代码&#39；]；const curr_magic=用户。magicCode；//如果（user.magicCode！=&#39；&#39；）出现以下情况，请删除魔法代码{user.magicCode=&#39；&#39；db.userUpdate（user）；}//检查他们是否没有&#39；如果（curr|u magic==null | | curr|u magic==undefined | | user.temporary | | curr| u magic==&#39；&| magic！=curr|u magic）{res status（300）。发送（&#34；magic code不匹配&#34；）//TODO:删除魔法代码？返回；}const-token_-user:JwtUser={u-id:user._-id，name:user.name，temporary:user.temporary | | false，}；res.status（200）GiveToken（token#u user，res，&#34；&#34；）//res.send（&#34；&lt；script&gt；window.location.replace（&#39；/&#39；）&lt/脚本&gt&#34;)   res.重定向（&#34；/&#34；）返回}）；</p><p> We send the user an email with a link to this endpoint via sendgrid (not sponsored, just easy to use).</p><p>我们通过sendgrid向用户发送一封电子邮件，其中包含指向该端点的链接（不受赞助，只是易于使用）。</p><p>  export  default  function  RegisterEndPoints( app:  Express,  db:  DataBase) {  // ...   // check if we&#39;re logged in   app. use( async ( req,  res,  next)  =&gt; {  const  path  =  req. path;  if ( path  ==  &#39;/favicon.ico&#39;  ||  path. startsWith( &#39;/js/&#39;)  ||  path. startsWith( &#39;/img/&#39;)  ||  path. startsWith( &#39;/css/&#39;)  ||  path  ==  &#39;/login&#39;  ||  path. indexOf( &#39;.&#39;)  !=  - 1) {  return  next(); }  try {  //console.error(&#34;Checking auth for &#34;+ path);   const  token  = ( req. cookies)  ?  req. cookies[ &#39;token&#39;]  :  req. headers. authorization ?. split( &#34;Bearer &#34;)[ 1];  if ( ! token)  throw  new Error( &#34;No Authorization Header&#34;);  await  JwtVerify( token,  JWT_SECRET);  res. locals. token  =  token;  const  results  = ( JwtDecode( token)  as  any);  // TODO: check if the user actually exists?   res. locals. user  =  results;  return  next(); }  catch ( e) {  //console.error(&#34;Auth check&#34;, e);  }  // TODO: redirect to login page if we&#39;re on a page that needs it   if ( path. startsWith( &#39;/api/&#39;)  ||  path  ==  &#39;/logout&#39;) {  return  next(); }  // redirect to login   console. error( &#34;Redirecting from &#34;  +  req. path  +  &#34; to /login&#34;);  return  res. redirect( &#39;/login&#39;); });</p><p>导出默认函数RegisterEndPoints（app:Express，db:DataBase）{/…//检查我们是否重新登录app.use（async（req，res，next）=&gt；{const path=req.path；if（path=&#39；/favicon.ico&#39；| path.startsWith（&；/39 js&#39；）|路径开始（&#39；/img/&#39；）|路径开始（&#39；/css/&#39；）|路径==&#39/登录&#39；|124;路径indexOf（&#39；&#39；）！=-1） {return next（）；}请尝试{//console.error（&#34；检查auth以获得&#34；+path）；const token=（请求cookies）？请求cookies[&#39；token&#39；]：请求。标题。批准分割（&#34；持票人&#34；）[ 1];  如果（！token）抛出新错误（&#34；无授权头&#34；）；等待JwtVerify（令牌，JWT_机密）；当地人。令牌=令牌；const results=（JwtDecode（令牌）如有）；//TODO:检查用户是否确实存在？当地人。用户=结果；返回next（）；}catch（e）{//console.error（&#34；Auth check&#34；e）}/TODO:如果我们&#39；如果（path.startsWith（&#39；/api/&#39；）| |路径==&#39/注销（#39；）{return next（）；}//重定向到登录控制台。错误（&#34；从&#34；+请求路径+&#34；重定向到/登录&#34；）；return res.redirect（&#39；/login&#39；）；}）；</p><p> That’s pretty much all there is to it.User creates an account with just their email or can create a temporary account.Their session lasts for a long time.If it expires or they try to login from a different browser, they get a code to their email.It’s a great solution for a simple site that doesn’t get much traffic.</p><p>差不多就这些了。用户只需通过电子邮件创建一个帐户，也可以创建一个临时帐户。他们的会议持续了很长时间。如果过期或他们试图从其他浏览器登录，他们会在电子邮件中获得一个代码。对于一个流量不大的简单网站来说，这是一个很好的解决方案。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/密码/">#密码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/const/">#const</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>