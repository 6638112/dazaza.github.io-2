<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>自举</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">自举</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-09-24 21:23:16</div><div class="page_narrow text-break page_content"><p>简单说明：自举是指使用比自身更小的工具构建编译器，而不是使用已构建的自身版本构建编译器。第二个问题是：预构建的二进制文件是从哪里来的？</p><p>这是从使用十六进制编辑器编写的十六进制汇编器开始引导一系列语言过程的详细日志。</p><p>本文讨论了软件长期保存的方法。简要介绍不会随着时间的推移而降级的硬件，但本文的大部分内容是关于如何设计在遥远的将来可以执行的软件堆栈。为了实现这一点，他们建议使用简短、简单的规范来构建所有的机器。</p><p>描述FORTS的完整实现的深度识字编程。从包含大量汇编宏的英特尔32位汇编语言引导到一个完全自扩展的FORTH。这是一本很有启发性的读物，教会了很多关于Forward的细节，并展示了用来编写编程语言的运行时是多么的少。</p><p>Kragen(再次)做了令人惊叹的自举/自托管工作。这第四个是在满屏的代码中实现的，能够直接发出ELF文件。可自我扩展。单字符字名称。</p><p>这些幻灯片概述了ROL和琥珀的发展。这是一种由汇编语言自举而来的编程语言。直接在汇编语言中实现ROWL，然后在ROWL中实现琥珀VM和编译器的一部分，然后通过自托管实现AMBER的其余部分。</p><p>一种设计为安全的面向语句的编程语言，它从x86机器代码引导，只使用少量Linux syscall(不使用libc)。在60k行的x86机器代码表示法中实现，其中40k行是自动测试。编译器的安全检查仍在进行中。</p><p>这个项目建立了一个SiCp风格，方案解释器与REPL在围棋。这篇博文描述了每个阶段。它们看起来很简单。Github将其集成到总共240行代码中。作为一种简单的语言，Go实现可以移植到我们集合中的任何其他地方，也可以直接手工汇编。然后，更复杂的东西建立在它之上，就像90年代或其他LISP所做的那样。</p><p>一个用C语言实现的非常小的x86 JIT堆栈计算器。所有的指令都以一种巧妙的方式编码，使它们每个都是双字或四字。</p><p>QCC项目：将TCC前端与QCC的代码生成器挂钩，并创建一套cc、as、ld工具的Toybox样式。</p><p>在处理对硬件的信任时，一个很大的问题是它是否被颠覆了。出于管理目的，英特尔、AMD和许多其他大牌公司的芯片中都有后门。在其他事情中……(；)获得可信形象的一个骗局是只使用一台你没有理由相信被颠覆的计算机。在一个无聊的买家下收购它，它本身就是一项无聊的技术，在它里面做你的自助式事情，用它产生的东西。默认情况下，它很可能“不会”被颠覆，因为拦截者和TAO人员的资源有限，没有理由以系统为目标。为了获得最佳效果，请使用多个不同的选项。为了帮助这一点，我(尼克·P)。在Schneier的博客上列出所有类型的CPU和执行策略。我遗漏了一些旧的TI-82计算器，Palm Pilot，等等。很多旧的东西放在你身边，你可以亲自拿到可能是未被破坏的现金。</p><p>现在是用GO编写围棋编译器的时候了，而不是用C编写。我将讨论围棋团队为实现这一目标而采取的不同寻常的过程：将现有的C编译器机械转换为惯用的围棋代码。他们用C语言编写编译器，然后几乎自动地将源代码从C翻译成GO(必须进行一些手动修复)。这是一种有趣的方法。让我们将其命名为自托管的Transspile方法。</p><p>这是一个完全用汇编语言实现的Linux发行版。它不依赖于libc或任何东西。</p><p>Henry G.Baker实现了Comfy-65，这是一个托管在LISP上的宏汇编程序。由于可以在Comfy-65宏中使用整个Lisp语言的强大功能，因此可以在这些宏中嵌入的智能量是无限的。</p><p>这是一份讲解如何在FORTH中编写汇编器的教学文档！它展示了一种非常惯用的编程风格，而且一旦你有了工作，做一个高级汇编器是多么容易。</p><p>这是一个用C++编写的RUST编译器，它将RUST翻译成C语言，它使普通的自托管Rustc编译器可以引导！它忽略了借用检查器，但仍然能够正确编译有效的输入源。</p><p>这才是真正的交易。Ian Piumarta在这里实现了一个完全可引导的方案，从C开始，然后自托管到直接发出二进制的编译器。令人印象深刻！</p><p>CakeML真的很吸引人。他们创造了HOL中SML程序的理论，允许他们证明嵌入HOL中的SML程序的特性。他们已经创建了一个从SML到汇编的(严肃的)编译器，并证明了它完全保留了语义。然后，他们能够同时编译编译，引导证明以创建经验证的编译器二进制文件，对于该二进制文件，证明它编译输入程序并保留它们的语义。据我所知，这是第一次这样的发展。</p><p>这是一个开发得非常好的自举项目。十六进制汇编器。精灵制造者。X86汇编程序。链接器。B编译器。C编译器。包括各种POSIX样式的libc函数的实现。这本书写得非常好，值得研究！</p><p>ASMC项目是一个小的可引导内核，它加载一个有效负载。汇编编译器和G语言编译器存在有效负载。G语言是一种低于C语言的低级语言，发明它是为了简化引导。用G.实现了一个汇编器(可以构建内核)。</p><p>Cmeta-使用来自元编译器PIM的思想，从原始十六进制构建元语言。BLC-二进制λ演算实现，能够计算素数阶乘程序。使用cmeta系统构建。简明扼要得令人难以置信。令人惊讶的是，元编译器的技术可以在如此低的级别上应用。这个项目的杠杆率可能是最高的。</p><p>它编译并运行修订后的PASCAL语言的子集。该子集被设计为新机器实现自编译所需的最小语言。它是一个引导工具包的一部分，该工具包旨在方便将Pascal移植到新机器上。PASCAL语言的实现考虑到了自举的意图。它们有一种简单的字节码语言，可以简化这一过程。</p><p>这是第四个内置了诸如编辑器和LISP解释器的emacs的操作系统。它是一个1700行汇编脚本，用于可引导的FORTH编译器/解释器，然后整个系统的其余部分在FORTS中实现。我没有尝试过，但显然它可以用汇编器自行构建。这是一项令人印象深刻的工作。</p><p>Wirth等人的Project Oberon(简单的语言、编译器、操作系统和RISC CPU，源代码布局就像一本书。)</p><p>ML/I和SAL by Tannenbaum(宏系统引导低级语言，SAL，他们用来构建操作系统)。</p><p>Rakocevic等人的Red Language(类似LISP的电源/数字用户线，可以低电平，含电池，1MB独立)。</p><p>IPA的MinCaml(用于2000行和14周片断的最小函数式语言的高效编译器)。</p><p>Spry by Krampe(结合了LISP、Rebol、Smalltalk和Forth的特点；托管在Nim上；2300loc)。</p><p>Hanson和Fraser的LCC(20Kloc编译器，描述其工作原理的书；识字代码；非自由/开源，但免费，非商业性)。</p><p>Hyde的高级汇编(具有高级数据类型、控制流的汇编&amp；a stdlib；使用/检查您需要的内容)。</p><p>Daniel Bernstein的qhasm(汇编语言的可移植形式，可跨CPU标准化机器指令语法)。</p><p>Debian重新引导项目的理念是引导Debian应该是一个可重复的过程，而不是一件陈词滥调的一次性事情</p><p>Wheeler的SCM Security(安全分发&源代码基础的汇编；Karger建议掌握它)。</p><p>Leroy等人的CompCert(经过数学验证的C编译器，其规格和证明用微型的、经过验证的检查器检查)。</p><p>Myreen等人的CakeML(数学验证的SML编译器，其规格和证明由不同的微型验证检查器检查)。</p><p>Oliva和Wand的VLISP(文章有链接到VLISP，它以数学方式验证了PreScheme和Scheme48)。</p><p>Rosu等人的KCC(重写逻辑中C的可执行形式语义；可以用更简单的引擎来实现)。</p><p>Cornell的滑石粉(打字，使用汇编语言验证安全性，不使用编译器；检查器可以很简单；C子集+验证的编译器到滑石粉)。</p><p>Microsoft Research的CoqASM(可验证的安全程序集中的引导-由微小的、经过验证的检查器检查的验证程序中的程序集)。</p><p>这些工具是用无处不在的语言编写的，因此可以在各种各样的上下文中使用。</p><p>[4]一个新的引导项目，它是从最小的DOS平台构建到汇编语言之上的自我宿主语言。</p><p>Selfie是一个针对C子集的小型自编译编译器、一个小型自执行MIPS仿真器和一个小型自托管MIPS虚拟机管理程序，所有这些都在一个7kLoC文件中。HN讨论。纸。</p><p>McKeeman和He的语法执行机器(在解释器中增量地将语言从简单语法扩展到复杂语法)。</p><p>Bayfront Tech的Meta II(带实时代码和详细教程的原始元编译器；OMeta是后续版本)。</p><p>由Lugon实现的meta II(看起来像是meta II的小型实现；也是在meta II中引导的)。</p><p>由Allison提供的Tiny Basic(Small Basic，其原始虚拟机占用120个，虚拟操作码使用3KB RAM实现)。</p><p>Klip by Cut(面向学生的简单语言的编译器&amp；运行库；用C#；运行库实现的可读性非常好)。</p><p>NAND2Tetris by Nisan和Schocken(该指南以有趣的方式一步一步地教授硬件，并出现了简单的CPU)</p><p>J1 by by Bowman(在FPGA上运行100MIPS的200行Verilog中的第四个16位CPU)。</p><p>H2作者：Howe(J1的VHDL版本，有详细说明和Howe的代码，麻省理工学院许可)。</p><p>Wirth的RISC-0(SIMPLE，RISC CPU&amp；SOC专为Oberon语言设计，在线提供详细的文档和源代码)。</p><p>Shoeberl等人的Jop(在FPGA上占用1830片的嵌入式Java处理器)。</p><p>Sortix-POSIX在C语言中的现代重新实现。(注：没有perl端口，GCC也不是在它上面本地构建的。(目前还没有。)。</p><p>NetBSD build.sh-从外来操作系统交叉构建完整的NetBSD ISO。在NetBSD官方文档中也有一份指南。</p><p>Robert Landley的https://landley.net/toybox/about.html-tobox，Busybox的替代，参见同一作者的土著linux和mkroot，它们都面向最小的可引导系统。</p><p>AWOW-编译器GitHub列表，包含大量信息(将相关部分复制到此维基)</p><p>用ACL2进行形式化编译器验证--用ACL2证明编译器是正确的，并讨论了正确性和自编译。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bootstrapping.miraheze.org/wiki/Main_Page">https://bootstrapping.miraheze.org/wiki/Main_Page</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1013875.html"><img src="http://img.diglog.com/img/2020/7/thumb_fef3789ffd179224a0c938d558d394e9.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1013875.html">使D成为我最喜欢的编程语言的特性</a></div><span class="my_story_list_date">2020-7-24 7:59</span></div><div class="col-sm"><div><a target="_blank" href="/story/1010197.html"><img src="http://img.diglog.com/img/2020/7/thumb_fe5ff336acc9de4afb0853043ce93294.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1010197.html">Go与C#：编译器、运行时、类型系统、模块</a></div><span class="my_story_list_date">2020-7-7 5:42</span></div><div class="col-sm"><div><a target="_blank" href="/story/1008669.html"><img src="http://img.diglog.com/img/2020/6/thumb_c72a4bdf84c77ccc3eff0558d5edc17a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1008669.html">GNU GCC不将浮点除法舍入到最接近的值</a></div><span class="my_story_list_date">2020-6-28 6:44</span></div><div class="col-sm"><div><a target="_blank" href="/story/1005256.html"><img src="http://img.diglog.com/img/2020/6/thumb_c72a4bdf84c77ccc3eff0558d5edc17a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1005256.html">Go编译器需要更智能</a></div><span class="my_story_list_date">2020-6-5 11:47</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>