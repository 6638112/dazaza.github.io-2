<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>信号量(编程)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">信号量(编程)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-03 13:55:59</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/0cc89c062fa51d7ddb60a4c7ab23abb9.jpg"><img src="http://img2.diglog.com/img/2020/11/0cc89c062fa51d7ddb60a4c7ab23abb9.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Jump to navigation  Jump to search  In  computer science, a  semaphore is a  variable or  abstract data type used to control access to a common resource by multiple  processes in a  concurrent system such as a  multitasking operating system. A semaphore is simply a variable. This variable is used to solve  critical section problems and to achieve process synchronization in the multi processing environment. A trivial semaphore is a plain variable that is changed (for example, incremented or decremented, or toggled) depending on programmer-defined conditions.</p><p>跳转到导航跳转在计算机科学中，信号量是一种变量或抽象数据类型，用于控制并发系统(如多任务操作系统)中的多个进程对公共资源的访问。信号量只是一个变量。此变量用于解决多处理环境中的临界区问题和实现进程同步。普通信号量是一个普通变量，可以根据程序员定义的条件进行更改(例如，递增、递减或切换)。</p><p> A useful way to think of a semaphore as used in the real-world system is as a record of how many units of a particular resource are available, coupled with operations to adjust that record  safely (i.e., to avoid  race conditions) as units are acquired or become free, and, if necessary, wait until a unit of the resource becomes available.</p><p>将信号量视为在真实世界系统中使用的一种有用的方式是将特定资源的多少个单元可用的记录与在单元被获取或变为空闲时安全地调整该记录(即，避免竞争条件)的操作相结合，并且如果需要，则等待直到资源的单元变为可用。</p><p> Semaphores are a useful tool in the prevention of race conditions; however, their use is by no means a guarantee that a program is free from these problems. Semaphores which allow an arbitrary resource count are called  counting semaphores, while semaphores which are restricted to the values 0 and 1 (or locked/unlocked, unavailable/available) are called  binary semaphores and are used to implement  locks.</p><p>信号量是防止争用条件的有用工具；但是，使用信号量并不能保证程序不会出现这些问题。允许任意资源计数的信号量称为计数信号量，而限制为值0和1(或锁定/解锁、不可用/可用)的信号量称为二进制信号量，用于实现锁定。</p><p> The semaphore concept was invented by  Dutch  computer scientist  Edsger Dijkstra in 1962 or 1963,  [2] when Dijkstra and his team were developing an  operating system for the  Electrologica X8. That system eventually became known as  THE multiprogramming system.</p><p>信号量的概念是由荷兰计算机科学家Edsger Dijkstra在1962年或1963年发明的，当时Dijkstra和他的团队正在为Electrlogica X8开发操作系统。该系统最终被称为多道程序设计系统。</p><p>   Suppose a library has 10 identical study rooms, to be used by one student at a time. Students must request a room from the front desk if they wish to use a study room. If no rooms are free, students wait at the desk until someone relinquishes a room. When a student has finished using a room, the student must return to the desk and indicate that one room has become free.</p><p>假设一个图书馆有10个相同的自习室，每次供一个学生使用。如果学生想使用自习室，他们必须向前台申请房间。如果没有空余的房间，学生们在桌子旁等待，直到有人让出房间。当学生使用完一个房间后，他必须回到课桌前，并指出有一个房间是空闲的。</p><p> In the simplest implementation, the clerk at the front desk knows only the number of free rooms available, which they only know correctly if all of the students actually use their room while they&#39;ve signed up for them and return them when they&#39;re done. When a student requests a room, the clerk decreases this number. When a student releases a room, the clerk increases this number. The room can be used for as long as desired, and so it is not possible to book rooms ahead of time.</p><p>在最简单的实现中，前台的办事员只知道可用的空房数量，只有当所有学生在签约时确实使用了他们的房间，并在他们使用完毕后归还房间时，他们才能正确地知道这一点。当学生要求房间时，办事员会减少这个数字。当学生腾出房间时，办事员会增加这个数字。房间可以用多久就用多久，所以不可能提前订房。</p><p> In this scenario the front desk count-holder represents a counting semaphore, the rooms are the resource, and the students represent processes/threads. The value of the semaphore in this scenario is initially 10, with all rooms empty. When a student requests a room, they are granted access, and the value of the semaphore is changed to 9. After the next student comes, it drops to 8, then 7 and so on. If someone requests a room and the current value of the semaphore is 0,  [3] they are forced to wait until a room is freed (when the count is increased from 0). If one of the rooms was released, but there are several students waiting, then any method can be used to select the one who will occupy the room (like  FIFO or flipping a coin). And of course, a student needs to inform the clerk about releasing their room only after really leaving it, otherwise, there can be an awkward situation when such student is in the process of leaving the room (they are packing their textbooks, etc.) and another student enters the room before they leave it.</p><p>在此场景中，前台计数持有者代表计数信号量，房间是资源，学生代表进程/线程。在这个场景中，信号量的值最初是10，所有房间都是空的。当一名学生请求房间时，他们将被授予访问权限，信号量的值被更改为9。在下一名学生到来后，信号量将降至8，然后是7，依此类推。如果有人请求房间，并且信号量的当前值为0，[3]他们将被迫等待，直到房间被释放(当计数从0增加时)。如果其中一个房间被腾出，但有几个学生在等待，那么可以使用任何方法来选择将占用该房间的人(如FIFO或抛硬币)。当然，学生只有在真正离开房间后才需要通知工作人员释放他们的房间，否则，当学生在离开房间的过程中(他们正在收拾课本等)时，可能会出现尴尬的情况。另一个学生在他们离开之前进入了房间。</p><p>  When used to control access to a  pool of resources, a semaphore tracks only  how many resources are free; it does not keep track of  which of the resources are free. Some other mechanism (possibly involving more semaphores) may be required to select a particular free resource.</p><p>当用于控制对资源池的访问时，信号量只跟踪有多少资源是空闲的；它不会跟踪哪些资源是空闲的。可能需要一些其他机制(可能涉及更多信号量)来选择特定的空闲资源。</p><p> The paradigm is especially powerful because the semaphore count may serve as a useful trigger for a number of different actions. The librarian above may turn the lights off in the study hall when there are no students remaining, or may place a sign that says the rooms are very busy when most of the rooms are occupied.</p><p>该范例特别强大，因为信号量计数可以用作许多不同操作的有用触发器。上面的图书管理员可以在没有学生的时候关掉自习室的灯，或者在大部分房间都被占满的时候放一个牌子，说明房间很忙。</p><p> The success of the protocol requires applications to follow it correctly. Fairness and safety are likely to be compromised (which practically means a program may behave slowly, act erratically,  hang or  crash) if even a single process acts incorrectly. This includes:</p><p>该协议的成功需要应用程序正确遵循它。公平和安全很可能会受到损害(这实际上意味着程序可能运行缓慢、不稳定、挂起或崩溃)，即使只有一个进程运行不正确。这包括：</p><p>  Even if all processes follow these rules,  multi-resource  deadlock may still occur when there are different resources managed by different semaphores and when processes need to use more than one resource at a time, as illustrated by the  dining philosophers problem.</p><p>即使所有进程都遵循这些规则，当存在由不同信号量管理的不同资源时，以及当进程需要一次使用多个资源时，仍可能发生多资源死锁，如进餐哲学家问题所示。</p><p>  Counting semaphores are equipped with two operations, historically denoted as P and V (see  § Operation names for alternative names). Operation V increments the semaphore  S, and operation P decrements it.</p><p>计数信号量配备了两个操作，历史上分别表示为P和V(有关替代名称，请参阅§“操作名称”)。运算V递增信号量S，运算P递减它。</p><p> The value of the semaphore  S is the number of units of the resource that are currently available. The P operation  wastes time or  sleeps until a resource protected by the semaphore becomes available, at which time the resource is immediately claimed. The V operation is the inverse: it makes a resource available again after the process has finished using it.One important property of semaphore  S is that its value cannot be changed except by using the V and P operations.</p><p>信号量S的值是当前可用的资源单位数。P操作浪费时间或休眠，直到受信号量保护的资源变为可用，此时该资源被立即认领。V操作与之相反：它使资源在进程使用完毕后再次可用。信号量S的一个重要属性是，除了使用V和P操作外，它的值不能更改。</p><p>  wait: Decrements the value of semaphore variable by 1. If the new value of the semaphore variable is negative, the process executing   wait is blocked (i.e., added to the semaphore&#39;s queue). Otherwise, the process continues execution, having used a unit of the resource.</p><p>WAIT：将信号量变量的值减1。如果信号量变量的新值为负，则阻塞执行WAIT的进程(即，添加到信号量的队列中)。否则，进程在使用了一个资源单元后继续执行。</p><p> signal: Increments the value of semaphore variable by 1. After the increment, if the pre-increment value was negative (meaning there are processes waiting for a resource), it transfers a blocked process from the semaphore&#39;s waiting queue to the ready queue.</p><p>Signal：将信号量变量的值递增1。递增后，如果预增量值为负(表示有进程在等待资源)，它会将阻塞的进程从信号量的等待队列转移到就绪队列。</p><p> Many operating systems provide efficient semaphore primitives that unblock a waiting process when the semaphore is incremented. This means that processes do not waste time checking the semaphore value unnecessarily.</p><p>许多操作系统提供当信号量递增时解锁等待进程的有效信号量原语。这意味着进程不会不必要地浪费时间检查信号量的值。</p><p> The counting semaphore concept can be extended with the ability to claim or return more than one &#34;unit&#34; from the semaphore, a technique implemented in  Unix. The modified V and P operations are as follows, using square brackets to indicate  atomic operations, i.e., operations which appear indivisible from the perspective of other processes:</p><p>可以扩展计数信号量的概念，使其能够从信号量中声明或返回一个以上的单元，这是Unix中实现的一项技术。修改后的V和P操作如下，使用方括号表示原子操作，即从其他进程的角度看是不可分割的操作：</p><p> function V(semaphore S, integer I): [S ← S + I] function P(semaphore S, integer I):  repeat: [ if S ≥ I: S ← S − I  break]</p><p>函数V(信号量S，整数I)：[s←S+I]函数P(信号量S，整数I)：重复：[If S≥I：s←S−I Break]。</p><p> However, the remainder of this section refers to semaphores with unary V and P operations, unless otherwise specified.</p><p>但是，除非另有说明，否则本节的其余部分指的是具有一元V和P运算的信号量。</p><p> To avoid  starvation, a semaphore has an associated  queue of processes (usually with  FIFO semantics). If a process performs a P operation on a semaphore that has the value zero, the process is added to the semaphore&#39;s queue and its execution is suspended. When another process increments the semaphore by performing a V operation, and there are processes on the queue, one of them is removed from the queue and resumes execution. When processes have different priorities the queue may be ordered by priority, so that the highest priority process is taken from the queue first.</p><p>为了避免饥饿，信号量有一个关联的进程队列(通常使用FIFO语义)。如果进程对值为零的信号量执行P操作，则该进程将被添加到信号量的队列中，并挂起其执行。当另一个进程通过执行V操作来递增信号量时，如果队列中有进程，则从队列中删除其中一个进程并恢复执行。当进程具有不同的优先级时，可以按优先级对队列进行排序，从而首先从队列中取出最高优先级的进程。</p><p> If the implementation does not ensure atomicity of the increment, decrement and comparison operations, then there is a risk of increments or decrements being forgotten, or of the semaphore value becoming negative. Atomicity may be achieved by using a machine instruction that is able to  read, modify and write the semaphore in a single operation. In the absence of such a hardware instruction, an atomic operation may be synthesized through the use of a  software mutual exclusion algorithm. On  uniprocessor systems, atomic operations can be ensured by temporarily suspending  preemption or disabling hardware  interrupts. This approach does not work on multiprocessor systems where it is possible for two programs sharing a semaphore to run on different processors at the same time. To solve this problem in a multiprocessor system a locking variable can be used to control access to the semaphore. The locking variable is manipulated using a  test-and-set-lock command.</p><p>如果实现不能确保递增、递减和比较操作的原子性，则存在忘记递增或递减或信号量值变为负值的风险。原子性可以通过使用能够在单个操作中读取、修改和写入信号量的机器指令来实现。在没有这样的硬件指令的情况下，可以通过使用软件互斥算法来合成原子操作。在单处理器系统上，可以通过暂时挂起抢占或禁用硬件中断来确保原子操作。这种方法在多处理器系统上不起作用，在多处理器系统中，共享一个信号量的两个程序可能同时在不同的处理器上运行。要在多处理器系统中解决此问题，可以使用锁定变量来控制对信号量的访问。使用test-and-set-lock命令操作锁定变量。</p><p>   Consider a variable  A and a boolean variable  S.  A is only accessed when  S is marked true. Thus,  S is a semaphore for  A.</p><p>考虑变量A和布尔变量S。只有当S标记为真时，才能访问A。因此，S是A的信号量。</p><p> One can imagine a stoplight signal ( S) just before a train station ( A). In this case, if the signal is green, then one can enter the train station. If it is yellow or red (or any other color), the train station cannot be accessed.</p><p>可以想象，就在火车站(A)前面有一个红绿灯信号(S)。在这种情况下，如果信号是绿色的，那么就可以进入火车站。如果是黄色或红色(或任何其他颜色)，则不能进入火车站。</p><p>  Consider a system that can only support ten users (S=10). Whenever a user logs in, P is called, decrementing the semaphore  S by 1. Whenever a user logs out, V is called, incrementing  S by 1 representing a login slot that has become available. When  S is 0, any users wishing to log in must wait until   S &gt; 0 and the login request is enqueued onto a FIFO queue;  mutual exclusion is used to ensure that requests are enqueued in order. Whenever  S becomes greater than 0 (login slots available), a login request is dequeued, and the user owning the request is allowed to log in.</p><p>假设一个系统只能支持10个用户(S=10)。每当用户登录时，将调用P，将信号量S减去1。每当用户注销时，将调用V，将S递增1，表示已变为可用的登录槽。当S为0时，任何希望登录的用户都必须等到S&gt；0并且登录请求排入FIFO队列；互斥用于确保请求按顺序排队。只要S大于0(可用的登录槽)，登录请求就会出列，并且允许拥有该请求的用户登录。</p><p>  In the  producer–consumer problem, one process (the producer) generates data items and another process (the consumer) receives and uses them. They communicate using a queue of maximum size  N and are subject to the following conditions:</p><p>在生产者-消费者问题中，一个进程(生产者)生成数据项，另一个进程(消费者)接收并使用它们。它们使用最大大小为N的队列进行通信，并受以下条件的限制：</p><p> the consumer must wait for the producer to produce something if the queue is empty;</p><p>如果队列是空的，消费者必须等待生产者生产产品；</p><p> the producer must wait for the consumer to consume something if the queue is full.</p><p>如果队列已满，生产者必须等待消费者消费一些东西。</p><p> The semaphore solution to the producer–consumer problem tracks the state of the queue with two semaphores:  emptyCount, the number of empty places in the queue, and  fullCount, the number of elements in the queue. To maintain integrity,  emptyCount may be lower (but never higher) than the actual number of empty places in the queue, and  fullCount may be lower (but never higher) than the actual number of items in the queue. Empty places and items represent two kinds of resources, empty boxes and full boxes, and the semaphores  emptyCount and  fullCount maintain control over these resources.</p><p>生产者-消费者问题的信号量解决方案使用两个信号量跟踪队列的状态：emptyCount(队列中的空位数)和fullCount(队列中的元素数)。为了保持完整性，emptyCount可能低于队列中的实际空位数(但从不高于)，fullCount可能低于(但从不高于)队列中的实际项目数。空位置和项代表两种资源，空箱和满箱，信号量emptyCount和fullCount维护对这些资源的控制。</p><p> The binary semaphore  useQueue ensures that the integrity of the state of the queue itself is not compromised, for example by two producers attempting to add items to an empty queue simultaneously, thereby corrupting its internal state. Alternatively a  mutex could be used in place of the binary semaphore.</p><p>二进制信号量useQueue确保队列本身的状态完整性不会受到损害，例如，两个生产者试图同时将项添加到空队列，从而破坏其内部状态。或者，可以使用互斥锁来代替二进制信号量。</p><p>       Several producers enter the producer critical section. No more than  N producers may enter their critical section due to  emptyCount constraining their entry.</p><p>几位制片人进入制片人临界区。由于EmptyCount限制其进入临界区，不能超过N个生产者进入其临界区。</p><p> The producers, one at a time, gain access to the queue through  useQueue and deposit items in the queue.</p><p>生产者，一次一个，通过useQueue获得对队列的访问，并将项目存放在队列中。</p><p> Once the first producer exits its critical section,  fullCount is incremented, allowing one consumer to enter its critical section.</p><p>一旦第一个生产者退出其临界区，fullCount就会递增，从而允许一个使用者进入其临界区。</p><p> Note that  emptyCount may be much lower than the actual number of empty places in the queue, for example in the case where many producers have decremented it but are waiting their turn on  useQueue before filling empty places. Note that  emptyCount + fullCount ≤  N  always holds, with equality if and only if no producers or consumers are executing their critical sections.</p><p>请注意，EmptyCount可能比队列中的实际空位数低得多，例如，在许多生产者已将其递减但在填充空位之前等待轮到useQueue的情况下。请注意，当且仅当没有生产者或消费者执行其临界区时，EmptyCount+FullCount≤N始终保持相等。</p><p>  The canonical names V and P come from the initials of  Dutch words. V is generally explained as  verhogen (&#34;increase&#34;). Several explanations have been offered for P, including  proberen (&#34;to test&#34; or &#34;to try&#34;),  [4]  passeren (&#34;pass&#34;), and  pakken (&#34;grab&#34;). Dijkstra&#39;s earliest paper on the subject  [2] gives  passering (&#34;passing&#34;) as the meaning for  P, and  vrijgave (&#34;release&#34;) as the meaning for V. It also mentions that the terminology is taken from that used in railroad signals. Dijkstra subsequently wrote that he intended  P to stand for the  portmanteau  prolaag,  [5] short for  probeer te verlagen, literally &#34;try to reduce&#34;, or to parallel the terms used in the other case, &#34;try to decrease&#34;.  [6]  [7]  [8]</p><p>规范名称V和P来自荷兰语单词的首字母。V通常解释为马鞭草(&#34；增加&#34；)。已经为P提供了几种解释，包括proberen(&#34；测试&#34；或&#34；尝试&#34；)、[4]passeren(&#34；pass&#34；)和pakken(&#34；Grab&34；)。Dijkstra关于这一主题的最早的论文[2]给出了Passering(通过)作为P的含义，vrijget(释放)作为V的含义。它还提到这个术语取自铁路信号中使用的术语。Dijkstra随后写道，他打算用P来代表合成词Promanteau Prolaag，[5]是ProBeer te verlagen的缩写，字面意思是尽量减少，或者平行于另一种情况下使用的术语，尽量减少。[6][7][8]。</p><p> In  ALGOL 68, the  Linux kernel,  [9] and in some English textbooks, the  V and  P operations are called, respectively,  up and  down. In software engineering practice, they are often called  signal and  wait,  [10]  release and  acquire  [10] (which the standard  Java library  [11] uses), or  post and  pend. Some texts  [12]  [13] call them  vacate and  procure to match the original Dutch initials.</p><p>在Linux内核ALGOL 68中，[9]和一些英语教科书中，V和P运算分别称为向上和向下。在软件工程实践中，它们通常称为Signal and Wait、[10]Release和Acquisition[10](标准Java库[11]使用)，或者POST和Pend。有些文本[12][13]称它们为“腾空”和“追求”，以便与荷兰语原文的首字母相匹配。</p><p>  A  mutex is a  locking mechanism that sometimes uses the same basic implementation as the binary semaphore. The differences between them are in how they are used. While a binary semaphore may be colloquially referred to as a mutex, a true mutex has a more specific use-case and definition, in that only the  task that locked the mutex is supposed to unlock it. This constraint aims to handle some potential problems of using semaphores:</p><p>互斥是一种锁定机制，有时使用与二进制信号量相同的基本实现。它们之间的不同之处在于它们的使用方式。虽然二进制信号量可能俗称为互斥锁，但真正的互斥锁有更具体的用例和定义，因为只有锁定互斥锁的任务才能解锁它。此约束旨在处理使用信号量的一些潜在问题：</p><p> Priority inversion: If the mutex knows who locked it and is supposed to unlock it, it is possible to promote the priority of that task whenever a higher-priority task starts waiting on the mutex.</p><p>优先级反转：如果互斥体知道是谁锁定了它，并且应该解锁它，那么每当更高优先级的任务开始等待互斥体时，就有可能提升该任务的优先级。</p><p> Premature task termination: Mutexes may also provide deletion safety, where the task holding the mutex cannot be accidentally deleted. [   citation needed]</p><p>任务过早终止：Mutexes还可以提供删除安全性，其中保存互斥锁的任务不会被意外删除。[需要引用]。</p><p> Termination deadlock: If a mutex-holding task terminates for any reason, the  OS can release the mutex and signal waiting tasks of this condition.</p><p>终止死锁：如果持有互斥锁的任务因任何原因终止，操作系统可以释放该条件下的互斥锁和信号等待任务。</p><p> Recursion deadlock: a task is allowed to lock a  reentrant mutex multiple times as it unlocks it an equal number of times.</p><p>递归死锁：允许任务在解锁可重入互斥锁相同次数时多次锁定该互斥锁。</p><p> Accidental release: An error is raised on the release of the mutex if the releasing task is not its owner.</p><p>意外释放：如果释放任务不是其所有者，则在释放互斥锁时引发错误。</p><p>    ^    Dijkstra, Edsger W.   Over seinpalen (EWD-74)  (PDF). E.W. Dijkstra Archive. Center for American History,  University of Texas at Austin.  ( transcription)</p><p>书名/作者Dejkstra，Edsger W.Over Seinpalen(EWD-74)(PDF)。E.W.迪克斯特拉档案馆。德克萨斯大学奥斯汀分校美国历史中心。(抄本)。</p><p> ^     a     b    Dijkstra, Edsger W.   Over de sequentialiteit van procesbeschrijvingen (EWD-35)  (PDF). E.W. Dijkstra Archive. Center for American History,  University of Texas at Austin.   ( transcription) (undated, 1962 or 1963)</p><p>A b Dijkstra，Edsger W.Over de Sequentialiteit van Procedesbeschrijvingen(EWD-35)(PDF)。E.W.迪克斯特拉档案馆。德克萨斯大学奥斯汀分校美国历史中心。(抄本)(未注明日期，1962年或1963年)。</p><p>   ^    Dijkstra, Edsger W.   EWD-74  (PDF). E.W. Dijkstra Archive. Center for American History,  University of Texas at Austin.   ( transcription)</p><p>书名/作者Dejkstra，Edsger W.EWD-74(PDF)。E.W.迪克斯特拉档案馆。德克萨斯大学奥斯汀分校美国历史中心。(抄本)。</p><p> ^    Dijkstra, Edsger W.   MULTIPROGAMMERING EN DE X8 (EWD-51)  (PDF). E.W. Dijkstra Archive. Center for American History,  University of Texas at Austin.   ( transcription) (in  Dutch)</p><p>^Dijkstra，Edsger W.MULTIPROGAMMERING EN DE X8(EWD-51)(PDF)。E.W.迪克斯特拉档案馆。德克萨斯大学奥斯汀分校美国历史中心。(抄本)(荷兰语)。</p><p> ^  Dijkstra&#39;s own translation reads &#34;try- and-decrease&#34;, although that phrase might be confusing for those unaware of the  colloquial &#34;try-and...&#34;</p><p>^Dijkstra自己的翻译是Try-and-Reduce&34；，尽管对于那些没有意识到口语中的Try-and……的人来说，这个短语可能会让人感到困惑。</p><p> ^   (PATCH 1/19) MUTEX: Introduce simple mutex implementation Linux Kernel Mailing List, 19 December 2005</p><p>^(补丁程序1/19)MUTEX：介绍简单互斥实现Linux内核邮件列表，2005年12月19日。</p><p>  ^     a     b   Mullender, Sape; Cox, Russ (2008).   Semaphores in Plan 9  (PDF). 3rd International Workshop on  Plan 9.</p><p>^a b Mullender，Sape；Cox，Russ(2008)。图9中的信号量(PDF)。关于计划9的第三次国际研讨会。</p><p>   Hilsheimer, Volker (2004). &#34; Implementing a Read/Write Mutex&#34; (Web page).  Qt Quarterly, Issue 11 - Q3 2004</p><p>沃尔克·希尔斯海默(2004)。&#34；实现读/写互斥&#34；(网页)。Qt季刊，2004年第11期-第3季度。</p><p> Zelenski, Julie; Parlante, Nick.  &#34;Thread and Semaphore Examples&#34;  (pdf).  Handout. CS107 Programming Paradigms. Stanford Engineering Everwhere (SEE). Spring 2008 (23).</p><p>泽伦斯基，朱莉；帕兰特，尼克。线程和信号量示例&#34；(Pdf)。讲义。CS107编程范例。斯坦福工程公司Everwhere(参见)。2008年春季(23)。</p><p>  Dijkstra, Edsger W.   Cooperating sequential processes (EWD-123)  (PDF). E.W. Dijkstra Archive. Center for American History,  University of Texas at Austin.   ( transcription) (September 1965)</p><p>合作顺序过程(EWD-123)(PDF)。E.W.迪克斯特拉档案馆。德克萨斯大学奥斯汀分校美国历史中心。(文字稿)(1965年9月)。</p><p> &#34;semaphore.h - semaphores (REALTIME)&#34;.  Programming interface. Base Specifications. Open Group. IEEE Std 1003.1 (Issue 6). 2004.</p><p>&#34；semaphore.h-信号量(实时)&#34；。编程接口。基本规格。打开组。IEEE标准1003.1(第6版)。2004年。</p><p> Downey, Allen B. (2016) [2005].  &#34;The Little Book of Semaphores&#34; (2nd ed.). Green Tea Press.</p><p>唐尼，艾伦·B(2016)[2005]。“信号量小书”(第二版)。绿茶出版社。</p><p> Leppäjärvi, Jouni (May 11, 2008).  &#34;A pragmatic, historically oriented survey on the universality of synchronization primitives&#34;  (pdf). University of Oulu, Finland.</p><p>Leppäjärvi，Jouni(2008年5月11日)。关于同步原语普遍性的语用的、面向历史的调查(Pdf)。芬兰奥卢大学。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">https://en.wikipedia.org/wiki/Semaphore_%28programming%29</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/信号量/">#信号量</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/semaphore/">#semaphore</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1032711.html"><img src="http://img2.diglog.com/img/2020/11/thumb_5e2df8cc5948ef745d260d73d8ee4226.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032711.html">计算机编程课程应该把重点放在项目上而不是“逻辑谜题”上吗？</a></div><span class="my_story_list_date">2020-11-2 10:44</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032551.html"><img src="http://img2.diglog.com/img/2020/11/thumb_0a8f1c493ac8e56198471312bf491773.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032551.html">关于编程的文章我想了很多</a></div><span class="my_story_list_date">2020-11-1 6:11</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032499.html"><img src="http://img2.diglog.com/img/2020/10/thumb_2716eedb121258a24a3b9d05b8246e63.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032499.html">2020年增长最快的科技工作岗位是什么？编程语言PHP走在前列</a></div><span class="my_story_list_date">2020-10-31 23:44</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032461.html"><img src="http://img2.diglog.com/img/2020/10/thumb_f19c2495d59cfc182245cd3687140648.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032461.html">Catala：一种面向社会财政立法知识编程的编程语言</a></div><span class="my_story_list_date">2020-10-31 15:50</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>