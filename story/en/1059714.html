<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>小集装箱挑战：建立6KB集装箱HTTP服务器 Tiny Container Challenge: Building a 6kB Containerized HTTP Server</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Tiny Container Challenge: Building a 6kB Containerized HTTP Server<br/>小集装箱挑战：建立6KB集装箱HTTP服务器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-22 15:15:37</div><div class="page_narrow text-break page_content"><p>Categories:  Tags:  TL;DR I set out to build the smallest container image that I could that was still able to do something useful. By taking advantage of multistage builds, the  scratch base image, and a tiny assembly based http server, I was able to get it down to 6.32kB!</p><p>类别：标签：TL;我设置的DR才能构建我能够做一些有用的东西的最小的容器图像。通过利用多级构建，划痕基础图像和基于微小的组装的HTTP服务器，我能够将其降至6.32KB！</p><p>        Containers are often touted as a silver bullet to solve every challenge associated with operating software. While I love containers, I often encounter container images in the wild that have a variety of issues. One common issue is size, with images sometimes clocking in at multiple GB!</p><p>        容器通常被吹捧为银弹，以解决与操作软件相关的每一个挑战。虽然我喜欢容器，但我经常在野外遇到包含各种问题的容器图像。一个常见的问题是大小，图像有时在多个GB时计时！</p><p> Because of this, I decided to challenge myself and others to build the smallest possible image.</p><p> 正因为如此，我决定挑战自己和他人建立最小的图像。</p><p>   The container should serve the contents of a file over http on the port of your choosing</p><p>   容器应在选择的端口上为HTTP提供文件的内容</p><p> No volume mounts are allowed (Also known as “The Marek Rule” 😜)</p><p> 不允许卷安装（也称为“Marek规则”😜）</p><p>  To get a baseline image size, we can use node.js to create a simple server  index.js:</p><p>  要获得基线图像大小，我们可以使用Node.js创建一个简单的服务器index.js：</p><p> const  fs  =  require( &#34;fs&#34;); const  http  =  require( &#39;http&#39;); const  server  =  http. createServer(( req,  res) =&gt; {  res. writeHead( 200, {  &#39;content-type&#39; :  &#39;text/html&#39; })  fs. createReadStream( &#39;index.html&#39;). pipe( res)}) server. listen( port,  hostname, () =&gt; {  console. log( `Server: http://0.0.0.0:8080/`);});</p><p> const fs =要求（＆＃34; fs＆＃34;）; const http =要求（＆＃39; http＆＃39;）; const server = http。 createserver（（req，res）=＆gt; {res。写点（200，{＆＃39; content-type＆＃39;：＆＃39; text / html＆＃39;}）fs。Creeateadstream（＆＃39;索引.html＆＃39;）。管道（RES）}）服务器。侦听（端口，主机名，（）=＆gt; {控制台。日志（`server：http：//0.0.0.0：8080 //0.0.0.0）; </p><p>     One of the simplest and most obvious tactics for reducing image size is to use a smaller base image. The official node image has a  slim variant (still debian based, but with fewer dependencies preinstalled) and an  alpine variant based on  Alpine Linux.</p><p>用于降低图像尺寸的最简单和最明显的策略之一是使用较小的基础图像。官方节点映像具有SLIM变体（仍然基于Debian，但预先安装较少的依赖项）和基于Alpine Linux的Alpine变体。</p><p> Using  node:14-slim and  node:14-alpine as the base image brought the image size down to  167MB and  116MB respectively.</p><p> 使用节点：14-SLIM和Node：14- alpine，因为基础图像分别将图像尺寸降至167MB和116MB。</p><p> Because docker images are additive, which each layer building on the next there isn’t much else we can do to make the node.js solution smaller.</p><p> 由于Docker图像是附加的，所以每个层都在接下来的情况下，我们可以做的是，我们可以做的是让节点.js解决方案变小。</p><p>  To take things to the next level we can move to a compiled language with many fewer runtime dependencies. There are a variety of options, but for building web services,  golang is a popular choice.</p><p>  要将事物带到下一个级别，我们可以转移到编译的语言，运行时依赖性更少。有各种各样的选择，但对于建立网络服务，Golang是一个受欢迎的选择。</p><p>  package  main import (	 &#34;fmt&#34;	 &#34;log&#34;	 &#34;net/http&#34;) func  main() {	 fileServer  :=  http. FileServer( http. Dir( &#34;./&#34;))	 http. Handle( &#34;/&#34;,  fileServer)	 fmt. Printf( &#34;Starting server at port 8080\n&#34;)	 if  err  :=  http. ListenAndServe( &#34;:8080&#34;,  nil);  err  !=  nil {			 log. Fatal( err)	}}</p><p>  包主要导入（＆＃34; fmt＆＃34;＆＃34; log＆＃34;＆＃34; net / http＆＃34;）func main（）{fileServer：= http。 fileserver（http.dir（＆＃34; ./&# 34;））http。把手（＆＃34; /＆＃34;，fileserver）fmt。 printf（＆＃34;在端口8080 \ n＆＃34的启动服务器，如果err：= http。 Histendsdserve（＆＃34;：8080＆＃34;，nil）; err！= nil {log。致命（err）}}</p><p>    The issue here is that the golang base image has a lot of dependencies installed that are useful when building go software but aren’t needed to run the software.</p><p>    此处的问题是Golang基础图像的安装很多依赖项，在构建Go软件时非常有用，但不需要运行软件。</p><p>  Docker has a feature called  multi-stage builds which make it easy to build the code in an environment with all of the necessary dependencies, and then copy the resulting executable into a different image.</p><p>  Docker有一个名为多级构建的功能，可以轻松地在环境中构建所有必要的依赖项，然后将结果的可执行文件复制到其他图像中。 </p><p> This is useful for a variety of reasons, but one of the most obvious is image size! By refactoring the dockerfile as follows:</p><p>这与各种原因有用，但最明显的是图像尺寸！通过重构DockerFile如下：</p><p> ### build stage ###FROM golang:1.14-alpine AS builderCOPY . .RUN go build -o server . ### run stage ###FROM alpine:3.12COPY --from =builder /go/server ./serverCOPY index.html index.htmlCMD  [ &#34;./server&#34; ]</p><p> ###来自golang的阶段###：1.14-高山作为BuilderCopy。 .RUN Go Build -o Server。 ###运行阶段###来自Alpine：3.12Copy --from = Builder / Go / Server ./servercopy inders.html index.htmlcmd [＆＃34; ./服务器＆＃34; ]</p><p>   13 MB isn’t too bad, but there are still a couple of tricks we can play to make it even smaller.</p><p>   13 MB并不是太糟糕，但仍然有几个技巧我们可以玩，让它变小。</p><p> There is a base image called  scratch which is explicitly empty and has zero size. Because the  scratch has nothing inside, any image built from it must bring all of its necessary dependencies.</p><p> 有一个称为划痕的基础图像，它显式为空，具有零大小。因为划痕内部没有内部，所以任何由它构建的图像必须带来所有必要的依赖项。</p><p> To make this possible with our go based server, we need to add a few flags to the compilation step in order to ensure the necessary libraries are statically linked into the executable:</p><p> 要使用我们的GO基于服务器实现此可能，我们需要将一些标志添加到编译步骤中，以确保必要的库静态链接到可执行文件中：</p><p> ### build stage ###FROM golang:1.14 as builderCOPY . .RUN go build  \  -ldflags  &#34;-linkmode external -extldflags -static&#34;  \  -a server.go ### run stage ###FROM scratchCOPY --from =builder /go/server ./serverCOPY index.html index.htmlCMD  [ &#34;./server&#34; ]</p><p> ###来自golang的阶段###：1.14作为BuilderCopy。 .run go build \ -ldflags＆＃34; -linkmode外部-extldflags -static＆＃34; \ -a server.go ###运行阶段### from scratchcopy --from = builder / go / server ./servercopy index.html index.htmlcmd [＆＃34; ./服务器＆＃34; ]</p><p> Specifically, we set the link mode to  external and pass the  -static flag to the external linker.</p><p> 具体来说，我们将链接模式设置为外部并将 - 将天标传递给外部链接器。 </p><p>   An image less than 10MB, written in a language like Go is plenty small for almost any circumstance… but we can go smaller! Github user  nemasu fully functional http server written in assembly on github named  assmttpd.</p><p>以一种小于10MB的图像，以像Go的语言写入的东西，几乎是任何情况都很小...但我们可以越小！ GitHub用户Nemasu全功能HTTP服务器在Github上编写的Github命名为Assmttpd。</p><p> All that was required to containerize it was to install a few build dependencies into the ubuntu base image before running the provided  make release recipe:</p><p> 容器中所需的只是在运行提供的Make Release Recipe之前将一些构建依赖性安装到Ubuntu基础映像中：</p><p> ### build stage ###FROM ubuntu:18.04 as builderRUN apt updateRUN apt install -y make yasm as31 nasm binutils COPY . .RUN make release ### run stage ###FROM scratchCOPY --from =builder /asmttpd /asmttpdCOPY /web_root/index.html /web_root/index.htmlCMD  [ &#34;/asmttpd&#34;,  &#34;/web_root&#34;,  &#34;8080&#34; ]</p><p> ###来自Ubuntu的Build Stage ### .run使释放### Run Stage ###从ScratchCopy --from = Builder / Asmttpd / Asmttpdcopy / web_root/index.html / web_root/index.htmlcmd [＆＃34; / asmttpd＆＃34 ;,＃34; / web_root＆＃34 ;,＆＃34; 8080＆＃34; ]</p><p> The resulting  asmttpd executable is then copied into the scratch image and invoked with the  CMD. This resulted in an image size of just 6.34kB! 🥳</p><p> 然后将生成的ASMTTPD可执行文件复制到划痕图像中并用CMD调用。这导致图像尺寸仅为6.34KB！ 🥳</p><p>  Hopefully you enjoyed this journey from our initial 943MB Node.js image all the way to this tiny 6.34kB Assembly image and learned some techniques you can apply to make your container images smaller in the future.</p><p>  希望您从初始943MB节点943MB Node.js拍摄此旅程一直享受这个微小的6.34KB装配图像，并学习了一些技术，您可以应用于使您的容器图像更小。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://devopsdirective.com/posts/2021/04/tiny-container-image/">https://devopsdirective.com/posts/2021/04/tiny-container-image/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/集装箱/">#集装箱</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/container/">#container</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/图像/">#图像</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>