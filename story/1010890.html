<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Apache Solr JSON刻面API相关度和语义知识图</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Apache Solr JSON刻面API相关度和语义知识图</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-07-10 06:01:39</div><div class="page_narrow text-break page_content"><p>JSON刻面模块公开了与Solr的传统刻面模块类似的功能，但更加强调可用性。与传统的镶嵌面相比，它有几个好处：</p><p>JSON提供的嵌套和结构使刻面比传统刻面API的平面命名空间更易于阅读和理解。</p><p>计算给定存储桶数据的方面(通常是度量、统计或分析函数)。</p><p>下面是一个分组面的示例，它根据cat字段(CATEGORY的缩写)将文档划分到存储桶中，并返回前3个存储桶：</p><p>cURL http://localhost:8983/solr/techproducts/query-d&#39；{&#34；查询&#34；：&#34；*：*&#34；，&#34；方面&#34；：{&#34；类别&#34；：{&#34；类型&#34；：&#34；术语&#34；，&#34；字段&#34；：&#34；CAT&#34；，&#34；限制&#34；：3})&#39；</p><p>Final TermsFactMap Category yFacet=new TermsFactMap(&#34；cat&#34；)。setLimit(3)；最终JsonQueryRequest请求=new JsonQueryRequest()。setQuery(&#34；*：*&#34；)。with Facet(&#34；Categories&#34；，Category yFacet)；QueryResponse queryResponse=Request。process(solrClient，Collection_name)；</p><p>下面的响应显示有32个文档与默认根域匹配。12份文件有CAT：Electronics，4份文件有CAT：Currency等。</p><p>[.]&#34；方面&#34；：{&#34；计数&#34；：32，&#34；类别&#34；：{&#34；桶&#34；：[{&#34；val&#34；：&#34；Electronics&#34；，&#34；计数&#34；：12}，{&#34；val&#34；：&#34；货币&#34；，&#34；计数&#34；：4}，{&#34；val&#34；：&#34；内存&#34；，&#34；计数&#34；：3}，]}}</p><p>除了查询结果本身之外，Stat(也称为聚合或分析)方面对于显示从查询结果派生的信息很有用。例如，可以使用statfacet为电子商务站点上寻找内存的用户提供上下文。下面的例子计算了平均价格(和其他统计数据)，并允许用户判断购物车中的记忆棒是否物美价廉。</p><p>最终JsonQueryRequest请求=new JsonQueryRequest()。setQuery(&#34；Memory&#34；)。with Filter(&#34；INSTOCK：TRUE&#34；)。with StatFacet(&#34；avg_price&#34；，&#34；avg(Price)&#34；)。with StatFacet(&#34；min_Manufacturing turedate_dt&34；，&#34；min(Manufacturing_Dt)&#34；)。with StatFacet(&#34；Num_Supplier&#34；，&#34；Unique(Manu_Exact)&#34；)。with StatFacet(&#34；Medium_Weight&#34；，&#34；Percententile(Weight，50)&#34；)；QueryResponse queryResponse=请求。process(solrClient，Collection_name)；</p><p>对上面的facet请求的响应将从匹配根域的文档开始(文档包含&#34；memory&#34；with INstock：true)，然后是facets块中请求的统计信息：</p><p>&#34；面&#34；：{&#34；计数&#34；：4，&#34；平均价格&#34；：109.9950008392334，&#34；供应商数量&#34；：3，&#34；中位数_权重&#34；：352.0}。</p><p>&#34；术语&#34；和&#34；范围&34；方面生成多个存储桶，并将域中的每个文档分配到这些存储桶中的一个(或多个)中。</p><p>&#34；查询&#34；和&#34；热点图&#34；方面始终生成域中所有文档所属的单个存储桶。</p><p>cURL http://localhost:8983/solr/techproducts/query-d&#39；{&#34；查询&#34；：&#34；*：*&#34；，&#34；方面&#34；：{类别：{&#34；类型&#34；：&#34；术语&#34；，&#34；字段&#34；：&#34；CAT&#34；，&#34；限制&#34；：5}。</p><p>Final TermsFactMap Category yFacet=new TermsFactMap(&#34；cat&#34；)。setLimit(5)；最终JsonQueryRequest请求=new JsonQueryRequest()。setQuery(&#34；*：*&#34；)。with Facet(&#34；Categories&#34；，Category yFacet)；QueryResponse queryResponse=Request。process(solrClient，Collection_name)；</p><p>“count”指定文档计数，“index”按存储桶值的索引(自然)顺序排序。还可以按存储桶中出现的任何面函数/统计信息排序。默认值为“count desc”。此参数也可以在JSON中指定，如排序：{COUNT：DESC}。排序顺序可以是“asc”或“desc”</p><p>超过分布式搜索期间从分片内部请求的限制的存储桶数。</p><p>较大的值可以提高当单个碎片具有非常不同的顶级术语时返回的最终顶级术语的准确性。</p><p>默认值-1会导致根据指定的其他选项应用大体。</p><p>如果为True，则启用分布式镶嵌面优化。这使用第二个阶段从未在其初始内部结果中包含这些存储桶的分片中检索最终结果所需的任何存储桶，以便每个分片都对此方面和任何子方面中返回的每个存储桶做出贡献。这使得返回的存储桶的计数&amp；统计准确。</p><p>确定要优化哪些存储桶时，在分布式搜索期间要内部考虑的超出限制的存储桶数。</p><p>较大的值可以提高当各个碎片具有非常不同的顶级术语时返回的最终顶级术语的准确性，并且当前排序选项可能会导致细化将术语向下推入排序列表(例如：Sort：&#34；Count ASC&34；)(例如：Sort：&#34；Count ASC&34；)。</p><p>默认值-1会导致根据指定的其他选项应用大体。</p><p>一个布尔值，指定是否应返回由字段中没有值的文档定义的特殊“缺失”存储桶。默认值为false。</p><p>布尔值。如果为true，则将“numBuckets”添加到响应中，这是一个整数，表示面的存储桶数(与返回的存储桶数相对)。默认值为false。</p><p>布尔值。如果为true，则向响应添加一个“allBuckets”存储桶，表示所有存储桶的并集。对于多值字段，这与域中所有文档的存储桶不同，因为单个文档可以属于多个存储桶。默认值为false。</p><p>一个可选参数，用于指定在初始收集顶部存储桶期间使用的最终排序的近似值(当排序参数非常昂贵时)。</p><p>查询方面生成与域和指定查询相匹配的单桶文档。</p><p>cURL http://localhost:8983/solr/techproducts/query-d&#39；{&#34；查询&#34；：&#34；*：*&#34；，&#34；方面&#34；：{&#34；高_人气&#34；：{&#34；类型&#34；：&#34；查询&#34；，&#34；Q&#34；：&#34；人气：[8至10]&#34；}}&#39；</p><p>QueryFetMap queryFacet=new QueryFetMap(&#34；Popular：[8 to 10]&#34；)；最终JsonQueryRequest请求=new JsonQueryRequest()。setQuery(&#34；*：*&#34；)。with Facet(&#34；High_Popular&#34；，queryFacet)；QueryResponse queryResponse=Request。process(solrClient，Collection_name)；</p><p>curl http://localhost:8983/solr/techproducts/query-d&#39；{&#34；查询&#34；：&#34；*：*&#34；，&#34；方面&#34；：{&#34；高_人气&#34；：{&#34；类型&#34；：&#34；查询&#34；，&#34；Q&#34；：&#34；人气：[8至10]&#34；，&#34；分面&#34；：{&#34；Average_Price&#34；：&#34；AVG(价格)&#34；}&#39；</p><p>QueryFtracMap queryFacet=new QueryFetMap(&#34；Popular：[8 to 10]&#34；)。with StatSubFacet(&#34；Average_Price&#34；，&#34；avg(Price)&#34；)；最终JsonQueryRequest请求=new JsonQueryRequest()。setQuery(&#34；*：*&#34；)。with Facet(&#34；High_Popular&#34；，queryFacet)；QueryResponse queryResponse=Request。process(solrClient，Collection_name)；</p><p>cURL http://localhost:8983/solr/techproducts/query-d&#39；{&#34；查询&#34；：&#34；*：*&#34；，&#34；方面&#34；：{&#34；价格&#34；：{&#34；类型&#34；：&#34；范围&#34；，&#34；字段&#34；：&#34；价格&#34；，&#34；开始&#34；：0，&#34；结束&#34；：100，&#34；间隙&#34；：20}&#39；</p><p>RangeFaceMap rangeFacet=new RangeFetMap(&#34；Price&#34；，0.0,100.0，20.0)；最终的JsonQueryRequest请求=new JsonQueryRequest()。setQuery(&#34；*：*&#34；)。with Facet(&#34；Price&#34；，rangeFacet)；QueryResponse queryResponse=Request。process(solrClient，Collection_name)；</p><p>&#34；价格&#34；：{&#34；Buckets&#34；：：[{&#34；val&#34；：0.0，//存储桶值代表每个范围的开始。此存储桶涵盖0-20&#34；count&#34；：5}，{&#34；val&#34；：20.0，&#34；count&#34；：0}，{&#34；val&#34；：0}，{&#34；val&#34；：60.0，&#34；count&#34；：1}，{&#34；val&#34；：80.0，&#34；计数&#34；：1}]}。</p><p>范围分面参数名称和语义在很大程度上反映了分面。范围查询-参数样式分面。例如，这里的&#34；start&#34；对应于facet.range命令中的&#34；facet.range.start&#34；。</p><p>一个布尔值，如果为真，则意味着最后一个存储桶将在“end”处结束，即使它小于“间隙”宽度也是如此。如果为False，则最后一个存储桶将是“间隙”宽的，可能会延伸到“End”之后。</p><p>此参数指示除了开始和结束之间的每个范围约束的计数外，还应计算…的计数。</p><p>&#34；之后&#34；字段值大于最后一个范围上限的所有记录</p><p>&#34；介于&#34；之间的所有记录，其字段值在所有范围的开始和结束边界之间。</p><p>默认情况下，用于计算开始和结束之间的范围镶嵌面的范围包括其下限，不包括上限。“之前”范围是排除的，“之后”范围是包含的。此缺省值相当于下面的&#34；低&#34；，不会导致边界重复计数。Include参数可以是以下选项的任意组合：</p><p>即使未指定相应的上/下选项，第一个和最后一个间隙范围也包括它们的边边界(即，第一个间隙范围的下限为第一个间隙范围的下限，最后一个间隙范围的上限为最后一个间隙范围的上限。</p><p>外部“之前”和“之后”范围将包含它们的边界，即使第一个或最后一个范围已经包括这些边界。</p><p>指定时的任意范围列表计算给定范围上的面，而不是开始、间隙和结束。对于开始、结束和间隙，范围或桶的宽度始终是固定的。如果需要在变化的范围宽度上计算范围刻面，则应指定范围。</p><p>当在Range方面中指定范围时，将忽略hardEnd、Include和其他参数。</p><p>任意范围由计算范围桶的From和To值组成。此范围可以用两种语法指定。</p><p>一个布尔值，如果为True，则表示包含FROM的下限。此默认值为true。</p><p>一个布尔值，如果为True，则表示包含的上限为。此默认值为False。</p><p>然后指定Range时，将忽略该范围中的所有上述参数From、To和ETC。</p><p>如果指定了Range，则会忽略其他参数，但有一些方法可以实现与Range相同的行为。</p><p>如果指定了Range，则忽略Include参数，但是有一些方法可以实现与Range相同的行为。使用INCLUSIVE_TO和INCLUSIVE_FROM的组合可以实现下、上、外、边全部。</p><p>cURL http://localhost:8983/solr/techproducts/query-d&#39；{&#34；查询&#34；：&#34；*：*&#34；，&#34；方面&#34；：{&#34；价格&#34；：{&#34；类型&#34；：&#34；范围&#34；，&#34；字段&#34；：&#34；价格&#34；，&#34；范围&#34；：[{&#34；From&#34；：0，&#34；to&#34；：20，&#34；Include_From&#34；：true，&#34；Include_to&#34；：false}，{&#34；range&#34；：&#34；[40,100)&#34；}]}&#39；</p><p>{&#34；价格&#34；：{&#34；桶&#34；：[{&#34；val&#34；：&#34；[0，20)&#34；，&#34；count&#34；：5}，{&#34；val&#34；：&#34；[40,100)&#34；，&#34；count&#34；：2}]}}。</p><p>当指定Range时，其在请求中的值将用作响应中的键。在另一种情况下，使用FROM、TO、INCLUDE_TO和INCLUDE_FROM生成密钥。目前不支持自定义密钥。</p><p>热图分面为在每个网格单元中具有空间数据的文档生成分面计数的2D网格。</p><p>此功能主要记录在《参考指南》的空间一节中。关键参数是type以指定heatmap，而field以指示空间RPT字段。其余参数名称使用相同的名称和语义镜像方面。heatmap查询-参数样式方面，尽管没有&#34；facet.heatmap。&#34；前缀。例如，此处的geom对应于facet.heatmap命令中的facet.heatmap.geom。</p><p>与将域划分为存储桶的其他方面不同，热图方面目前不支持嵌套方面。</p><p>cURL http://localhost:8983/solr/spatialdata/query-d&#39；{&#34；查询&#34；：&#34；*：*&#34；，&#34；面&#34；：{&#34；位置&#34；：{&#34；类型&#34；：&#34；热点图&#34；，&#34；字段&#34；：&#34；LOCATION_SRPT&#34；，&#34；GEOM&#34；：&#34；[\&#34；50 20\&#34；到\&#34；180 90\&#34；]&#34；，&#34；gridLevel&#34；：4}&#39；</p><p>最终JsonQueryRequest请求=new JsonQueryRequest()。setQuery(&#34；*：*&#34；)。setLimit(0)。使用Facet(&#34；Locations&#34；，new HeatmapFetMap(&#34；location_srpt&#34；))。setHeatmapFormat(HeatmapFaceMap.。HeatmapFormat。INTS2D)。setRegionQuery(&#34；[\&#34；50 20\&#34；to\&#34；180 90\&#34；]&#34；)。setGridLevel(4))；</p><p>与到目前为止讨论的所有方面不同，聚合函数(也称为面函数、分析函数或度量)不会将数据划分为存储桶。取而代之的是，他们对域中的所有文档进行计算。</p><p>给定字段的唯一值数。如果超过100个值，则会产生不准确的估计。</p><p>与上面相同，但占用空间更小，严格用于计算Block Join块的数量。给定字段在块之间必须是唯一的，并且仅支持单值字符串字段，建议使用docValue。</p><p>通过t-digest算法进行百分位数估计。按此度量排序时，列出的第一个百分位数用作排序值。</p><p>用于计算域中的文档相对于背景集合(两者都被定义为查询)与前景集合的相关性分数的函数。这主要是在构建语义知识图时使用的。</p><p>诸如avg之类的数值聚合函数可以位于任何数值字段上，也可以位于多个数值字段的嵌套函数上，例如avg(div(Popular，Price))。</p><p>请求聚合函数的最常见方式是将其作为包含要计算的表达式的简单字符串：</p><p>curl http://localhost:8983/solr/techproducts/query-d&#39；{&#34；查询&#34；：&#34；*：*&#34；，&#34；筛选器&#34；：[&#34；价格：[1.0to*]&#34；，&#34；人气：[0至10]&#34；]，&#34；方面&#34；：{&#34；avg_value&#34；：&#34；avg(div(人气，价格))&#34；}}&#39；</p><p>最终JsonQueryRequest请求=new JsonQueryRequest()。setQuery(&#34；*：*&#34；)。with Filter(&#34；价格：[1.0至*]&#34；)。with Filter(&#34；人气：[0到10]&#34；)。with StatFacet(&#34；min_manu_id_s&#34；，&#34；min(Manu_Id_S)&#34；)。with StatFacet(&#34；avg_value&#34；，&#34；avg(div(人气，价格))&#34；)；QueryResponse queryResponse=请求。process(solrClient，Collection_name)；</p><p>展开的表单允许指定本地参数。它们可以由一些专门的聚合(如relatedness())显式使用，但也可以用作参数引用，以使聚合表达式更具可读性，而不需要使用(全局)请求参数：</p><p>curl http://localhost:8983/solr/techproducts/query-d&#39；{&#34；查询&#34；：&#34；*：*&#34；，&#34；筛选器&#34；：[&#34；价格：[1.0to*]&#34；，&#34；人气：[0至10]&#34；]，&#34；方面&#34；：{&#34；avg_value&#34；：{&#34；类型&#34；：&#34；func&#34；，&#34；func&#34；：&#34；avg(div($numer，$denom))&#34；，&#34；numer&#34；：&#34；mul(Popular，3.0)&#34；，&#34；denom&#34；：&#34；Price&#34；}}&#39；</p><p>Final Map&lt；String，Object&gt；ExpandedStatFacet=new HashMap&lt；&gt；()；expecdedStatFacet。放置(&#34；type&#34；，&#34；func&#34；)；expecdedStatFacet。put(&#34；func&34；，&#34；avg(div($numer，$denom))&#34；)；expecdedStatFacet。put(&#34；numer&34；，&#34；mul(Popular，3.0)&#34；)；expecdedStatFacet。put(&#34；denom&#34；，&#34；price&#34；)；最终JsonQueryRequest请求=new JsonQueryRequest()。setQuery(&#34；*：*&#34；)。with Filter(&#34；价格：[1.0至*]&#34；)。with Filter(&#34；人气：[0到10]&#34；)。with Facet(&#34；avg_value&#34；，expenddedStatFacet)；QueryResponse queryResponse=Request。process(solrClient，Collection_name)；</p><p>嵌套的方面或子方面允许用户在将域划分为桶(即，术语、范围、查询)的任何方面命令下嵌套方面命令。然后，根据其父存储桶中的所有文档集合定义的域评估这些子方面。</p><p>语法与顶级facet相同-只需向父facet的facet命令块添加一个facet命令即可。从技术上讲，每个facet命令实际上都是一个子facet，因为我们从单个facet存储桶开始，其中包含由主查询和过滤器定义的域。</p><p>让我们从CATEGORY字段cat上的一个简单的非嵌套术语facet开始：</p><p>cURL http://localhost:8983/solr/techproducts/query-d&#39；{&#34；查询&#34；：&#34；*：*&#34；，&#34；方面&#34；：{&#34；类别&#34；：{&#34；类型&#34；：&#34；术语&#34；，&#34；字段&#34；：&#34；CAT&#34；，&#34；限制&#34；：3})&#39；</p><p>Final TermsFactMap Category yFacet=new TermsFactMap(&#34；cat&#34；)。setLimit(3)；最终JsonQueryRequest请求=new JsonQueryRequest()。setQuery(&#34；*：*&#34；)。with Facet(&#34；Categories&#34；，Category yFacet)；QueryResponse queryResponse=Request。process(solrClient，Collection_name)；</p><p>上述方面的响应将显示顶级类别和落入每个类别存储桶中的文档数量。嵌套的方面可用于收集有关每个文档桶的附加信息。例如，使用下面的嵌套方面，我们可以找到排名靠前的类别以及每个类别中的主要制造商是谁：</p><p>cURL http://localhost:8983/solr/techproducts/query-d&#39；{&#34；查询&#34；：&#34；*：*&#34；，&#34；方面&#34；：{&#34；类别&#34；：{&#34；类型&#34；：&#34；术语&#34；，&#34；字段&#34；：&#34；CAT&#34；，&#34；限制&#34；：3，&#34；方面&#34；：{&#34；TOP_MANUCTORIER&#34；：{&#34；类型&#34；：&#34；术语&#34；，&#34；字段&#34；：&#34；Manu_id_s&#34；，&#34；限制&#34；：1}；</p><p>Final TermsFactMap topCategoriesFacet=new TermsFactMap(&#34；cat&#34；)。setLimit(3)；Final TermsFactMap topManufacturerFacet=new TermsFaceMap(&#34；manu_id_s&#34；)。setLimit(1)；topCategoriesFacet.。with SubFacet(&#34；TOP_MANAGERS&#34；，topManufacturerFacet)；最终JsonQueryRequest请求=new JsonQueryRequest()。setQuery(&#34；*：*&#34；)。with Facet(&#34；Categories&#34；，topCategoriesFacet)；QueryResponse queryResponse=Request。process(solrClient，Collection_name)；</p><p>&#34；方面&#34；：{&#34；计数&#34；：32，&#34；类别&#34；：{&#34；存储桶&#34；：[{&#34；VAL&#34；：&#34；电子&#34；，&#34；计数&#34；：12，&#34；TOP_MANUCTORIER&#34；：{&#34；存储桶&#34；：[{&#34；val&#34；：&#34；Corsair&#34；，&#34；count&#34；：3}]}}，{&#34；val&#34；：&#34；Currency&#34；，&#34；count&#34；：4，&#34；top_Manufacturer&#34；：{&#34；bucket&#34；：[{&#34；val&#34；：&#34；boa&#34；，&#34；count&#34；：1}]}。</p><p>字段或术语方面的默认排序是按存储桶计数降序排序。我们可以选择按每个存储桶中出现的任何面函数进行升序或降序排序。</p><p>cURL http://localhost:8983/solr/techproducts/query-d&#39；{&#34；查询&#34；：&#34；*：*&#34；，&#34；方面&#34；：{&#34；类别&#34；：{&#34；类型&#34；：&#34；术语&#34；，//术语方面为字段&#34；字段&#34；：&#34；CAT&#34；中的每个索引术语创建一个桶。，&#34；限制&#34；：3，&#34；排序&#34；：&#34；平均价格说明&#34；，&#34；方面&#34；：{&#34；平均价格&#34；：&#34；平均(价格)&#34；，}&#39；</p><p>Final TermsFactMap topCategoriesFacet=new TermsFactMap(&#34；cat&#34；)。setLimit(3)。使用StatSU。</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://lucene.apache.org/solr/guide/8_5/json-facet-api.html#relatedness-and-semantic-knowledge-graphs">https://lucene.apache.org/solr/guide/8_5/json-facet-api.html#relatedness-and-semantic-knowledge-graphs</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/solr/">#solr</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/范围/">#范围</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>