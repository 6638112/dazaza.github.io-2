<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Reaction显影剂的代数效果</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Reaction显影剂的代数效果</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-02 06:32:00</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/1ad66aad5180eadddad9676110c78c08.png"><img src="http://img2.diglog.com/img/2020/11/1ad66aad5180eadddad9676110c78c08.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>It’s in words that the magic is—Abracadabra, Open Sesame, and the rest—but the magic words in one story aren’t magical in the next.The real magic is to understand which words work, and when, and for what; the trick is to learn the trick.</p><p>魔力在于文字--“阿布拉卡达布拉”、“芝麻开场”等--但一个故事中的魔术词语在下一个故事中并不具有魔力。真正的魔力在于理解哪些词语有效，什么时候起作用，什么时候起作用；诀窍在于学会诀窍。</p><p> It’s been quite some time since Hooks were officially stabilized in  React 16.8, and with them came a fundamentally different way of understanding the way our applications work.This is both a blessing and a curse: Hooks are much closer to the React programming model and help avoid a certain class of subtle and confusing bugs, but some developers have also expressed concerns that  React is becoming a black box.These concerns are completely valid; Hooks can often seem “magical,” since most of the complexities are hidden away in React’s internals.</p><p>自从钩子在React 16.8中正式稳定以来，已经有很长一段时间了，随之而来的是理解我们应用程序工作方式的一种根本不同的方式。这既是好事，也是坏事：钩子更接近于Reaction编程模型，有助于避免某种微妙而令人困惑的错误，但一些开发人员也表示担心，Reaction正在变成一个黑匣子。这些担忧是完全有道理的；钩子通常看起来很“神奇”，因为大多数复杂性都隐藏在React的内部。</p><p> Much of that “magical” feeling is simply due to the fact that Hooks are based on some  prior art and programming language research that many developers simply aren’t familiar with.Understanding some of the motivations and inspirations for Hooks can help build a mental model for what’s happening behind the scenes.While there are several sources of influence on the original Hooks proposal, arguably the most important is the notion of algebraic effects.</p><p>这种“神奇”的感觉在很大程度上是因为Hooks是基于许多开发人员根本不熟悉的一些现有技术和编程语言研究。理解Hooks的一些动机和灵感可以帮助为幕后发生的事情建立一个心理模型。虽然Hooks最初的提议有几个影响来源，但可以说最重要的是代数效应的概念。</p><p> ❗❗ Note that this article is  not an introduction into how to  use Hooks or how Hooks work internally.This is merely a way to  think about Hooks. For more information about how to use them, I suggeststarting with  the docs.</p><p>❗❗请注意，本文并不是介绍如何使用钩子或钩子如何在内部工作，这只是一种思考钩子的方式。有关如何使用它们的更多信息，我建议从文档开始。</p><p> Before diving into the details of algebraic effects, let’s first take a step back.</p><p>在深入到代数效果的细节之前，让我们先退一步。</p><p>  Class components seemed to be working well enough, why add  another way of writing components that, at least at face value, do the same thing?</p><p>类组件似乎工作得很好，为什么要添加另一种编写组件的方式，至少从表面上看，这样做是一样的呢？</p><p>  One of React’s core principles is the idea that an application’s user interface is a pure function of that application’s state.Here, “state” can refer to any combination of local component state and global state, such as a Redux store.When that state changes and propagates through your component tree, the output represents your new UI after that state change.This is, of course, an abstraction over the nuts and bolts of how that update actually happens, since React handles the actual reconciliation and DOM updates that are necessary, but this core principle means, at least in theory, that our UI is always synchronized with our data.</p><p>React的核心原则之一是，应用程序的用户界面是该应用程序状态的纯函数。在这里，“状态”可以指本地组件状态和全局状态的任意组合，例如Redux存储。当该状态更改并在组件树中传播时，输出表示该状态更改后的新UI。当然，这是对更新实际发生方式的具体细节的抽象，因为React处理必要的实际协调和DOM更新，但这个核心原则意味着，至少在理论上，我们的UI始终与我们的数据同步。</p><p> Of course, this isn’t always true.Class components expose certain scenarios that allow us to ignore changes in state if we don’t effectively handle those state changes in our lifecycle methods.Dan Abramov wrote an  excellent article on some common pitfalls related to this that’s worth a read for more detail.In short, class components use different lifecycle methods to handle side effects, but that maps side effects to DOM operations,  not state changes.This means that while the visual elements of our UI may respond to state changes, our side effects might not.</p><p>当然，这并不总是正确的。类组件公开了某些场景，如果我们在生命周期方法中没有有效地处理这些状态更改，那么这些场景允许我们忽略状态更改。Dan Abramov就与此相关的一些常见陷阱写了一篇出色的文章，值得阅读更多详细信息。简而言之，类组件使用不同的生命周期方法来处理副作用，但是这会将副作用映射到DOM操作，而不是状态更改。这意味着，虽然UI的可视元素可能会响应状态更改，但副作用可能不会。</p><p> Because class components have to do these internal updates to synchronize their internal state when props change, they are by definition  impure. But wait, you say,  I thought we said that UI was a  pure function of state.</p><p>由于类组件必须在道具更改时执行这些内部更新以同步其内部状态，因此根据定义它们是不纯净的。但是等等，你说，我想我们说过UI是一个纯粹的状态函数。</p><p>  Hooks represent a different way of thinking about effects.Instead of thinking about the entire lifecycle of a component, Hooks allow us to narrow our focus to only the current state.We can then  declare the states in which we want our effects to run, ensuring that those state changes are reflected in our effects.Of course, an “effect” can be many things, from handling state with  useState, making network requests or manually updating the DOM with  useEffect, or calculating expensive callback functions with  useCallback.</p><p>钩子代表了一种不同的思考效果的方式。钩子不是考虑组件的整个生命周期，而是允许我们将焦点缩小到当前状态。然后，我们可以声明我们希望效果在哪些状态下运行，确保那些状态更改反映在我们的效果中。当然，“效果”可以是很多事情，从使用useState处理状态、使用useEffect发出网络请求或手动更新DOM，或者使用useCallback计算昂贵的回调函数。</p><p> But how do we reason about those side effects within a pure function?I’m glad you asked!</p><p>但是，我们如何在一个纯函数中解释这些副作用呢？我很高兴您问到了这一点！</p><p>  Algebraic effects are a generalized approach to reasoning about computational effects in pure contexts by defining an  effect, a set of operations, and an effect  handler, which is responsible for handling the semantics of how to implement effects.  1Algebraic effects generalize over a whole host of potential uses, like input and output, handling state,  async/ await, and many more.</p><p>代数效果是在纯上下文中通过定义效果、一组操作和负责处理如何实现效果的语义的效果处理程序来推理计算效果的通用方法。1代数效果概括了一系列潜在的用途，如输入和输出、处理状态、异步/等待等等。</p><p> This is a little abstract, so let’s write some code to see how this works in practice.Unfortunately, JavaScript doesn’t actually support algebraic effects, although React might mimic them internally.While there are a few different languages  2 that support algebraic effects, we’re going to use  Eff, a functional programming language designed specifically around algebraic effects.Don’t worry,  most people won’t know Eff, so I’ll explain some syntax as we go along  3.</p><p>这有点抽象，所以让我们编写一些代码来看看它在实践中是如何工作的。不幸的是，JavaScript实际上并不支持代数效果，尽管Reaction可能会在内部模仿它们。虽然有几种不同的语言2支持代数效果，但我们将使用EFF，这是一种专门围绕代数效果设计的函数式编程语言。别担心，大多数人不会知道EFF，所以我将在学习3的过程中解释一些语法。</p><p> A common use case for algebraic effects is handling stateful computations.Remember that effects are just in an interface with a set of operations.In Eff, we defined effects with the  effect keyword and a type signature:</p><p>代数效果的一个常见用例是处理有状态计算。请记住，效果只是在具有一组操作的接口中。在EFF中，我们使用Effect关键字和类型签名定义了效果：</p><p> (* state.eff *) (* A user with a name and age *) type user  = string  * inteffect  Get : usereffect  Set : user  -&gt; unit</p><p>(*state.eff*)(*a user with a name and age*)type user=string*interffect get：userEffect set：user-&&gt;unit。</p><p> Once we’ve defined what effects our effects will look like, we can define how our effects are handled by using the  handler keyword.</p><p>一旦我们定义了效果的外观，我们就可以通过使用HANDLER关键字来定义如何处理我们的效果。</p><p> let state  = handler  | y  -&gt;  fun currentState  -&gt;  (y , currentState )  | effect  Get k  -&gt;  ( fun currentState  -&gt;  (continue k currentState ) currentState )  | effect  ( Set newState ) k  -&gt;  ( fun  _  -&gt;  (continue k  ( ) ) newState ) ; ;</p><p>WET STATE=HANDLER|y-&&gt;；FUN currentState-&gt；(y，currentstate)|Effect Get k-&gt；(FUN currentstate-&gt；(Continue K Currentstate)currentState)|Effect(Set Newstate)k-&gt；(FUN_-&gt；(Continue k())Newstate)；；</p><p> Hmm, this looks a little trickier — let’s break it down a bit.We have a  handler with three branches, and all of them return a function.That function will be used to handle some effect (or lack thereof).</p><p>嗯，这看起来有点棘手-让我们把它分解一下。我们有一个有三个分支的处理程序，它们都返回一个函数。这个函数将用来处理一些效果(或缺少效果)。</p><p> The first branch,  y -&gt; fun currentState -&gt; (y, currentState), represents  no effect, which happens when we reach the end of the block we’re handling (which we’ll see shortly).  y here is the return value of the function, so this simply returns a tuple of the inner return and the state.</p><p>第一个分支y-&gt；Fun currentstate-&gt；(y，currentstate)表示没有效果，当我们到达正在处理的块的末尾时就会发生这种情况(我们很快就会看到)。这里是函数的返回值，所以这只返回内部返回和状态的元组。</p><p> The second and third branches match our effects, but there’s a suspicious argument  k. k here is a  continuation, which represents the rest of the computation  after where we perform an effect.</p><p>第二个和第三个分支与我们的效果相匹配，但是有一个可疑的参数kk，这里是一个延续，它表示在我们执行效果之后的其余计算。</p><p>  Because continuations represent the entire process in action, they’re essentially a snapshot of the call stack at the time of the effect.When we get to an effect, it’s almost as if we hit a giant pause button on the computation until we properly handle the effect.Calling  continue k  4 is like hitting the play button again.</p><p>因为延续代表了整个运行中的过程，所以它们本质上是调用堆栈在效果发生时的快照。当我们达到效果时，几乎就像我们在计算上按了一个巨大的暂停按钮，直到我们正确地处理了效果。调用Continue k 4就像是再次按下了Play按钮。</p><p> Alright, I think we’re ready to see our effect handlers in action.Right now, we have a user in state; let’s wish them well on their birthday:</p><p>好了，我想我们已经准备好看到我们的效果处理程序在运行了。现在，我们有一个用户处于状态；让我们祝他们生日快乐：</p><p> let celebrate  =  with state handle  let  (name , age )  = perform  Get  in print _string  &#34;Happy Birthday, &#34; ; print _string name ; print _endline  &#34;!&#34; ; perform  ( Set  (name , age + 1 ) ) ; perform  Get ; ;celebrate ( ( &#34;Henry&#34; ,  39 ) ) ; ;</p><p>让CREARY=WITH状态句柄let(name，age)=Perform Get in print_string&#34；Happy Birthday，&#34；；print_string name；print_endline&#34；！&#34；；Performance(Set(Name，age+1))；Perform Get；；CREARY((&#34；Henry&#34；，39))；；</p><p> When we start off this computation, we first  Get our user from state, which runs the second branch in our handler.At this point, we’ve hit the pause button, so the function has stopped running while we get this from state.The handler gives us back a function, which calls  continue k currentState, resuming our computation with the value of  currentState.</p><p>当我们开始计算时，我们首先从state获取用户，它运行处理程序中的第二个分支。此时，我们已经点击了暂停按钮，所以当我们从state获取时，函数已经停止运行。处理程序返回一个函数，该函数调用Continue k currentstate，使用currentstate值继续我们的计算。</p><p> This same flow happens every time we  perform an effect.Hit pause, do some work, hit play.</p><p>每次我们执行效果时，都会发生同样的流程。暂停，做一些工作，点击播放。</p><p>   And here, dear reader, is where the power of algebraic effects really shines.You see, it doesn’t really  matter how we hold state.Sure, right now it’s just an object in memory, but what if it was in a database?What if it was stored in a browser’s  localStorage?As far as  celebrate knows, these are  all the same.If we wanted, we could swap out our  state handler with a  redisState handler that stored state in a key-value store.</p><p>亲爱的读者，这里才是代数效果真正闪耀的地方。你看，我们如何保持状态其实并不重要。当然，现在它只是内存中的一个对象，但如果它在数据库中呢？如果它存储在浏览器的localStorage中呢？就CRESTARY所知，这些都是相同的。如果我们愿意，我们可以用在键值存储中存储状态的redisState处理程序来交换我们的状态处理程序。</p><p> In JavaScript, your code has to be aware of what’s synchronous and what’s not.If this were to change in the future, and state was handled asynchronously, we would need to start handling Promises, which would require changes across  everything that touches this function.But with algebraic effects, instead of maintaining a running process that holds a reference to a  different process, we can simply stop the current process altogether until our effects are finished.</p><p>在JavaScript中，您的代码必须知道哪些是同步的，哪些是不同步的。如果这在将来发生变化，并且状态是异步处理的，我们将需要开始处理承诺，这将需要对涉及此函数的所有内容进行更改。但是，使用代数效果，我们可以简单地完全停止当前进程，直到我们的效果结束，而不是维护一个包含对不同进程的引用的正在运行的进程。</p><p> Of course, state isn’t the only thing that we can handle with algebraic effects.Let’s say we have some network request we want to make or cleanup we want to execute, but we only want to do it  after our function is done.We’ll call it a  Defer effect.</p><p>当然，状态不是我们唯一可以用代数效应来处理的东西，比方说我们有一些网络请求想要执行，但我们只想在函数完成之后执行，我们称之为延迟效应。</p><p> effect  Defer :  (unit  -&gt; unit )  -&gt; unit let defer  = handler  | y  -&gt;  fun  ( )  -&gt;  ( )  | effect  ( Defer effectFunc ) k  -&gt;  ( fun  ( )  -&gt; continue k  ( ) ; effectFunc  ( )  ) ; ;</p><p>Effect DEFER：(unit-&gt；unit)-&gt；unit let defer=HANDLER|y-&gt；Fun()-&gt；(Effect(DeferEffect Func)k-&gt；(Fun()-&gt；Continue k()；Effect Func())；；</p><p> Notice that  continue k () doesn’t have to be the last part of the handler, as it was in our  state handler.We can call continuations  whenever we want and however many times we want — remember, they’re just representations of a process.</p><p>请注意，Continue k()不必是处理程序的最后部分，就像在我们的状态处理程序中一样，我们可以随时调用Continuations，想调用多少次就调用多少次-记住，它们只是一个流程的表示。</p><p> To make sure this works as intended, let’s make a quick sketch of how this might work in practice:</p><p>为确保此功能按预期工作，让我们快速概述一下此功能在实践中的工作原理：</p><p> let runWithCleanup  =  with defer handle print _endline  &#34;Starting our computation&#34; ; perform  ( Defer  fun  ( )  -&gt; print _endline  &#34;Running cleanup&#34; ) ;  (* Do some work *) print _endline  &#34;Finishing computation&#34; ; ;runWithCleanup ( ) ; ;</p><p>让runWithCleanup=WITH DEFER句柄print_endline&#34；开始我们的计算；Perform(DEFER FUN()-&gt；print_endline&#34；Running Cleanup&#34；)；(*做一些工作*)print_endline&#34；正在完成计算&#34；runWithCleanup()；；</p><p>    At this point, I’m sure you’re thinking  “Great, so we can sort of pause execution whenever we want. What does this have to do with Hooks?”Well, the two effects that we laid out here in Eff exist in React, just by other names: the  state handler (unsurprisingly) mirrors  useState, and our  defer handler works a lot like a simplified  useEffect.The examples from before aren’t directly related to user interfaces, but the mental model of pausing and resuming processes, as well as scheduling effects  after continuations, are core to understanding Hooks and the future of React.</p><p>在这一点上，我相信你在想：“太好了，我们可以随时暂停执行。这与Hooks有什么关系？“嗯，我们在EFF中列出的两个效果存在于React中，只是用了其他名称：状态处理程序(不出所料)映射useState，我们的延迟处理程序的工作方式与简化的useEffect非常相似。前面的示例与用户界面没有直接关系，但是暂停和恢复进程的心理模型，以及延续之后的调度效果，是理解Hooks和Reaction的未来的核心。</p><p>  So let’s turn our attention back to React.Previously we discussed why we need Hooks, but the question arose of how we  think about Hooks.Recall our original definition of algebraic effects as a set of operations and a set of effect handlers.The operations here are our Hooks (i.e.  useState,  useEffect, and so on), and React handles these effects during a render.</p><p>那么让我们把注意力转回到React上。前面我们讨论了为什么需要Hooks，但是出现了我们如何看待Hook的问题。回想一下我们对代数效果的原始定义，即一组操作和一组效果处理程序。这里的操作是我们的Hooks(即useState、useEffect等等)，Reaction在渲染期间处理这些效果。</p><p> We know the effect handlers are a part of the React render cycle because of some of the rules of Hooks.If, for example, you attempt to call  useEffect outside of a React component, you’ll likely get an error along the lines of  Invalid hook call. Hooks can only be called inside of the body of a function component.Similarly, if you  perform an effect in Eff without properly handling it, you’ll see  Runtime error: uncaught effect Defer.While we had to set up the handlers ourselves in Eff, in React they’re set up as part of the render cycle.</p><p>我们知道，由于钩子的某些规则，效果处理程序是Reaction呈现周期的一部分。例如，如果您试图在Reaction组件外部调用useEffect，则很可能会收到与无效钩子调用类似的错误。钩子只能在函数组件的主体内调用。同样，如果在EFF中执行效果时没有正确处理它，您将看到运行时错误：未捕获效果延迟。虽然我们必须在EFF中自己设置处理程序，但在Reaction中，它们被设置为呈现周期的一部分。</p><p> So why does this matter?Understanding that React is responsible for much of the implementation of  when and  how your effects run is important because it allows us to stash enormous amounts of complexity within React.For example, one of the key uses of  useEffect is as a scheduler.Particularly for computationally expensive UIs (such as complex animations), scheduling units of work is incredibly complex, and React needs to be able to make decisions about what work is the highest priority.At a higher level, React can pause and resume the rendering of individual components, which again can prioritize onscreen components or components that respond to user input.Andrew Clark wrote an  excellent overview of how React Fiber works and its design goals, but this tidbit about scheduling is particularly important here:</p><p>那么为什么这么重要呢？了解Reaction负责实现效果运行的时间和方式，这一点很重要，因为它允许我们在React中隐藏巨大的复杂性。例如，useEffect的主要用途之一是作为调度器。特别是对于计算昂贵的UI(如复杂动画)，调度工作单元极其复杂，Reaction需要能够决定哪些工作是最优先的。在更高级别，Reaction可以暂停和恢复单个组件的渲染，它还可以确定屏幕组件或响应用户输入的组件的优先级。Andrew Clark写了一篇出色的概述，介绍了Reaction Fibre的工作原理及其设计目标，但下面这段关于计划的花絮在这里特别重要：</p><p> A push-based approach requires the app (you, the programmer) to decide how to schedule work.A pull-based approach allows the framework (React) to be smart and make those decisions for you.</p><p>基于推送的方法需要应用程序(您，程序员)决定如何安排工作，基于拉动的方法使框架(反应)变得智能，并为您做出决定。</p><p> By allowing React to separate effects and rendering, we allow it to relieve us of some complexity.This will become increasingly important as React moves more and more towards features like  Suspense and  Concurrent Mode.</p><p>通过允许Reaction来分离效果和渲染，我们可以让它减轻一些复杂性。随着Reaction越来越多地向悬念和并发模式等功能发展，这一点将变得越来越重要。</p><p>  Often the most painful bugs come from when our mental model of a tool doesn’t quite line up with how it works.For many React developers, I think we struggle to see grok what’s happening when we call  useState.My hope is that understanding algebraic effects at least provides a slightly better model for what Hooks are doing behind the scenes.Of course, it’s worth reiterating that this is not to suggest that this is how Hooks  actually work — it’s simply to try and make sense out of them.</p><p>通常，最痛苦的错误来自于我们对工具的心理模型与它的工作方式不完全一致的时候。对于许多Reaction开发人员来说，我认为我们很难理解当我们调用useState时发生了什么。我希望理解代数效应至少为Hooks在幕后的工作提供了一个稍微好一点的模型。当然，值得重申的是，这并不是说这就是Hooks的实际工作方式-它只是尝试并理解它们。</p><p> This article didn’t dive too much on the literal inner workings of React, but hopefully it instead provided a better intuition about Hooks and effects more generally.Algebraic effects are a fairly recent area of programming language research, and I know for myself at least, it took a  lot of reading to better understand what they are.If you want to do a deep-dive into the research behind algebraic effects, I’ve put some suggested reading below.</p><p>这篇文章没有太深入地研究Reaction的字面内部工作原理，但希望它能更好地提供有关钩子和效果的更一般的直观信息。代数效果是编程语言研究的一个相当新的领域，至少我自己知道，需要大量阅读才能更好地理解它们是什么。如果您想深入了解代数效果背后的研究，我在下面提供了一些建议阅读。</p><p> Despite some complaints in the community about React becoming a black box, it’s important to remember that new tools exist for a reason, and that a primary goal of Hooks and React more broadly is to shield us from a certain amount of complexity that we don’t want to deal with, allowing us to focus on building better UIs and delighting our users.</p><p>尽管社区中有些人抱怨Reaction变成了一个黑匣子，但重要的是要记住，新工具的存在是有原因的，Hooks和更广泛的Reaction的一个主要目标是保护我们免受我们不想处理的一定程度的复杂性的影响，使我们能够专注于构建更好的UI并取悦我们的用户。</p><p>  Daan Leijen’s talk  “Asynchrony with Algebraic Effects” gives a great overview of how algebraic effects generalize to  even more use cases like iterators,  async/ await, and more. If reading papers is more your thing, he also wrote  “Algebraic Effects for Functional Programming”, which lays out some of the specifics. Daan is the creator of  Koka, another research language focused on algebraic effects.</p><p>Daan Leijen的演讲“与代数效果的异步”很好地概述了代数效果如何推广到更多的用例，如迭代器、异步/等待等等。如果你更喜欢阅读论文，他还写了“函数式编程的代数效应”，其中列出了一些细节。Daan是Koka的创建者，Koka是另一种专注于代数效应的研究语言。</p><p>  If you want to see how algebraic effects work in another language, you can find a tutorial  here on algebraic effects in Multicore OCaml. There’s also  this talk by Leo White on the implementation of an effect system in OCaml.</p><p>如果你想看看代数特效在另一种语言中是如何工作的，你可以在这里找到一个关于多核OCaml中的代数特效的教程。还有利奥·怀特关于在OCaml中实施效果系统的演讲。</p><p> For an overview on React Fiber, algebraic effects, scheduling, and the future of React, Brandon Dail gave a talk a few years ago called  “Algebraic effects, Fibers, Coroutines Oh my!” on how algebraic effects are implemented in React.</p><p>为了概述Reaction光纤、代数效果、调度和Reaction的未来，Brandon Dail在几年前做了一次演讲，题目是“代数效果、光纤、协程哦，我的天！”(Algebraic Effects，Fibers，Coroutines On My！)。关于代数效果是如何在Reaction中实现的。</p><p> This separation between an effect and its handler is one of the reasons that algebraic effects have gained increasing interest since their introduction. For readers familiar with monads, algebraic effects are restrictions on monads, which in some cases makes them a “weaker” abstraction, but in practice leads to a cleaner distinction between interfaces and implementations.</p><p>这种效应与其处理程序之间的分离是代数效应自引入以来获得越来越多兴趣的原因之一。对于熟悉Monad的读者来说，代数效果是对Monad的限制，这在某些情况下使它们成为“较弱”的抽象，但在实践中，接口和实现之间的区别更加清晰。</p><p> ↩</p><p>↩。</p><p> Multicore OCaml is specifically mentioned as an inspiration in the  React docs, but languages like  Eff or  Koka — despite being primarily research languages and not ready for the production spotlight — were built  specifically with effects in mind, which makes them a little easier to read for folks who don’t yet know the language.</p><p>多核OCaml在Reaction文档中被特别提到是一种灵感，但像EFF或Koka这样的语言-尽管它们主要是研究型语言，还没有准备好成为生产焦点-是专门考虑到效果的，这使得它们对于还不懂该语言的人来说更容易阅读。</p><p> ↩</p><p>↩</p><p>  A minor point:  continue in Eff is actually just an identity function (provided in Eff’s   pervasives.eff). It was recommended by the Eff creators as a way to distinguish the continuation from a regular function, but of course you can always ignore it if you wish.</p><p>需要注意的是：在EFF中继续实际上只是一个标识函数(在EFF的pervasives.eff中提供)。它是由EFF创建者推荐的，作为区分延续函数和常规函数的一种方式，当然，如果您愿意，也可以忽略它。</p><p> ↩</p><p>↩。</p><p> The Smalltalk community even has a web framework that uses continuations quite heavily, called  Seaside.</p><p>Smalltalk社区甚至有一个大量使用延续的Web框架，称为Seside。</p><p> ↩</p><p>↩</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://reesew.io/posts/react-algebraic-effects">https://reesew.io/posts/react-algebraic-effects</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/显影剂/">#显影剂</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/effects/">#effects</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/效果/">#效果</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>