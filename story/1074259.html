<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Java中的并发性——我提出了一个我觉得舒服的设计</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Java中的并发性——我提出了一个我觉得舒服的设计</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 18:03:19</div><div class="page_narrow text-break page_content"><p>经过多年对线程、可调用函数和执行器池的研究，终于找到了一种设置并发任务的简单方法</p><p>问题是：有一个并发执行的任务，但要保证代码不受可调用和其他线程逻辑的影响</p><p>多年来，我一直致力于让代码的某些部分以并发方式执行。向量的成对计算，推文上数千条的文本挖掘操作，网络中节点和边缘的简单检查和操作，等等。</p><p>将代码中可以并发执行的部分隔离在一个单独的类中：这就是任务。</p><p>让这个类实现可运行接口，或者更可能是可调用接口，因为它允许返回一个对象。</p><p>在代码的主要部分，设置Executor服务。实例化所有任务并将其提交给执行者。</p><p>我想这没什么错。实际上，这对我不起作用。根本原因在于：</p><p>将任务设置为可运行的或可调用的，即使这非常简单和轻量级，也会专门处理此用例的代码。如果我想在另一个上下文中重复使用代码，而这个上下文要求逻辑以不同的接口运行，或者因为代码逻辑的复杂性增加而重构任务，那么我为并发性添加的这些接口将成为样板。我会说：“哦，我添加了一种可调用的方式来运行这个特定项目的代码，但在另一个项目中，这只是我的一种方式。我必须删除它。”所以在实践中，当我开发一些并发代码时，我很快就放弃了它，开始了无障碍的工作。</p><p>在代码库的主端设置Executor/Future逻辑比看起来更难。这些API上有太多的变体，因此每次都需要花费大量精力来记住和确定应该如何设置。这是因为多线程和并发是低级的，有人可能会说“有一个库为您打包了这个”。但我真的会避免依赖库来实现并发性，它们可能非常大，而且对于我想要做的事情来说范围太广。</p><p>它不涉及聪明或复杂的技巧，所以不要期待一个大“哇”。它具有简单性和健壮性，并且自Java11的HttpClient以来变得非常简单。</p><p>解决方案是：将任务放在REST API后面，并使用Java 11的HttpClient异步请求调用它</p><p>在主代码库中，使用Java11的HttpClient调用每个任务，使用异步特性。这就是并发性的作用所在！！</p><p>用例包括对数千条推文进行情绪分析。与其按顺序进行，还可以同时进行。</p><p>输入：每行文本（每条推文）以对象映射的形式存储为一个字符串，带有一个唯一标识符的整数&lt；整数，字符串&gt；地图。</p><p>输出：每一行文本、其唯一标识符和找到的情绪都存储在一个文档对象中，其本身存储在一个对象ConcurrentHashMap中&lt；整数，文档&gt；临时结果。该映射必须是ConcurrentHashMap，因为它将由多个线程写入。</p><p>字符串selectedLanguage=&#34；嗯&#34；地图&lt；整数，字符串&gt；mapOfLines=newhashmap（）；地图。这是一个测试。并发性是惊人的！&#34；）；地图。put（1，&#34；这是一个测试。并发性很难！&#34；）；ConcurrentHashMap&lt；整数，文档&gt；tempResults=new ConcurrentHashMap（）；HttpRequest请求；HttpClient=HttpClient。newHttpClient（）；设置&lt；完全未来&gt；futures=newhashset（）；//这是我为计时而设计的一门方便的课程，在这里可以买到https://github.com/seinecle/Utils时钟时钟=新时钟（&#34；为并发任务计时&#34；）；尝试{for（Map.Entry&lt；Integer，String&gt；Entry:mapOfLines.entrySet（））{Document doc=new Document（）；doc.setText（Entry.getValue（））；doc.setId（Entry.getKey（））；doc.setsential（Category.10）；URI URI=new URI（&#34；http://localhost:45/api/sentimentForAText/&#34; +选择的语言+&#34；？id=&#34；+博士。getId（）+&#34&amp；text=&#34；+URL编码器。encode（entry.getValue（），StandardCharset）。UTF_8。toString（））；request=HttpRequest。newBuilder（）。uri（uri）。构建（）；完整的未来&lt；Void&gt；未来=客户。sendAsync（request，HttpResponse.BodyHandlers.ofString（））。然后accept（resp-&gt；{String body=resp.body（）；//任务返回一个JSON对象，为了便于处理//如下所示，在每个并发任务JsonReader JsonReader=JSON.createReader返回的体（这里是一个字符串）上定义操作//非常简单方便（新StringReader（正文））；JsonObject=jsonReader。readObject（）；Document docReturn=新文档（）；if（jsonObject！=null&amp；！jsonObject.isEmpty（））{String key=jsonObject.keySet（）.iterator（）.next（）；docReturn.setId（Integer.valueOf（key））；docReturn.setText（mapOfLines.get（Integer.valueOf（key））；//Category._11是#34；积极情绪&#34；if的标签（jsonObject.getString（键）。equals（Category.Category.toString（））{docReturn.setSenition（Categories.Category._11）；}//Category_12是&#34的标签；负面情绪&#34；if（jsonObject.getString（键）。等于（Category.Category.toString（））{docReturn.setSetEntity（Categories.Category.toString）}tempResults。put（Integer.valueOf（key），docReturn）；			 }		 }		 );期货添加（未来）；}可完成的未来&lt；Void&gt；combinedFuture=可完成的未来。allOf（futures.toArray（（新的CompletableFuture[0]））；结合未来。加入（）；//tempResults准备好在代码中进一步使用了！}catch（URISyntaxException异常）{System.out.println（&#34；URI语法异常&#34；+异常）；}catch（UnsupportedEncodingException ex）{System.out.println（&#34；编码异常：&#34；+ex）}时钟closeAndPrintClock（）；</p><p>这项任务的背后是一个简单的REST API，使用超轻量级的Javalin框架（但任何其他REST框架都可以）。这段代码驻留在一个单独的Java SE项目中，该项目编译在一个jar中，我可以将其部署在任何地方，并与主代码库分开：</p><p>公共类APIController{/***@param args命令行参数*/public static void main（String[]args）{Javalin app=Javalin.create（）.start（45）；System.out.println（&#34；运行api&#34；）；//用于情绪分析的对象初始化，在部署jar时只需初始化一次。//每次调用API都会发现这些对象可以使用，这会加快速度。//这是一个免费的开源工具：https://github.com/seinecle/umigon-coreUmigonController UmigonController=新的UmigonController（）；ClassifierMachineDocument classifierOneDocEN=新的ClassifierMachineDocument（umigonController.getSemanticsEN（））；ClassifierMachineDocument classifierOneDocFR=新的ClassifierMachineDocument（umigonController.getSemanticsFR（））；应用程序。get（&#34；/api/MONTUREFORATEXT/{lang}&#34；，ctx-&gt；{JsonObjectBuilder objectBuilder=Json.createObjectBuilder（）；String text=ctx.queryParam（&#34；text&#34；）；字符串id=ctx。queryParam（&#34；id&#34；）；如果（id==null）{id=UUID.randomUUID（）.toString（）.substring（0,10）；}如果（text==null）{objectBuilder.add（id，&#34；文本参数不存在&#34；）；JsonObject JsonObject=objectBuilder。构建（）；ctx。结果（jsonObject.toString（））。状态（HttpCode.BAD_请求）；}else{String lang=ctx.pathParam（&#34；lang&#34；）；Document doc=新文档（）；医生。setText（文本）；switch（lang）{case&#34；en&#34；：doc=classifiedocen.call（doc）；break；case&#34；fr&#34；：doc=classifiedornedocr.call（doc）；break；默认值：objectBuilder.add（&#34；-99&#34；&#34；lang lang-lang的参数错误，不支持&#34；）；JsonObject JsonObject=objectBuilder。构建（）；ctx。结果（jsonObject.toString（））。状态（HttpCode.BAD_请求）；}objectBuilder。添加（id，doc.gettouction（）。toString（））；JsonObject JsonObject=objectBuilder。构建（）；ctx。结果（jsonObject.toString（））。状态（HttpCode.OK）；}}}</p><p>看看上面的代码，我意识到反应可能是Whaaat，但这段代码实际上比使用ExecutorService等要复杂得多！好吧，让我们来分析一下利弊：</p><p>该任务完全没有并发逻辑。不可调用也不可运行。那会解放你的思想！</p><p>因此，从主代码库的角度来看，任务是完全可重用的，并且可以在不影响并发逻辑的情况下进行重构。这是一个巨大的好处，因为在处理代码的逻辑时，您不想因为使代码“并发兼容”的问题而受到干扰。</p><p>REST API背后的封装是一个好处：任务的代码库在接口之间是相同的。实际上，情绪分析任务由web应用程序界面和API上的相同代码执行，如下所示：https://nocodefunctions.com/umigon/sentiment_analysis_tool.html</p><p>任务从主代码库中卸载，这有助于使事情更有条理</p><p>从主代码库调用并发任务相对简单。不需要实例化或摆弄执行器，因为它已经捆绑在HttpClient中。但如果需要的话，它可以是泰勒色的。</p><p>使用json将任务的响应带回主代码库会让事情变得脆弱。我可能需要更改REST API端的Json格式，忘记更新在主代码库中读取Json对象的方式。</p><p>速度：在多核机器上，执行时间比顺序执行快4到6倍。</p><p>限制：本地与远程：当REST API与主代码库位于同一台机器上时，可以获得如上所示的并发性。当我尝试混合时（主代码基于远程服务器上的本地膝上型电脑x REST API），代码的速度非常慢。我没有调查原因。</p><p>当REST API在Windows计算机上时，连接有一个最大限制。达到此限制会导致异常。奇怪的因此，请确保在linux上托管REST API。</p><p>我将逐步重构nocodefunctions上的所有函数。com来采用这种设计。目前（2022年2月19日），只对网站的测试版本进行了情绪分析。因此，现在分析6000条推文只需10秒钟（每秒600条推文！），一分钟前。</p><p>在阅读了专业Java开发人员和StackOverflow Q&amp；像我感谢所有的贡献者，我希望这篇新的博文能对下一个研究这些话题的人有所帮助。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>