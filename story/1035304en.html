<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>属性案例：编程语言设计</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">属性案例：编程语言设计</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-16 02:38:44</div><div class="page_narrow text-break page_content"><p>Properties are a really nice feature of modern languages, and I&#39;ve recently gotten attached to them in Kotlin. For a while I wasn&#39;t comfortable with the idea of &#39;fields&#39; performing arbitrary computation, but having used them for a few months now I&#39;m really enjoying the simplicity -  especially when moving back to Java!</p><p>属性是现代语言的一个非常好的特性，我最近在Kotlin中对它们产生了浓厚的兴趣。有一段时间，我对使用字段执行任意计算的想法感到不舒服，但在使用了几个月之后，我真的很享受它的简单性--特别是当我搬回Java的时候！</p><p>  Having given it some thought, I wanted to lay out a case in support of properties which highlights their benefits over directly accessing fields (which is mostly about getters/setters, but nonetheless), and how we can establish some guidelines on when properties should not be used to avoid the issue of arbitrary computation causing side effects or other unexpected behavior.</p><p>经过深思熟虑后，我想给出一个支持属性的案例，它强调了属性相对于直接访问字段的好处(主要是关于getter/setter，但尽管如此)，以及我们如何才能建立一些关于何时不应该使用属性的指导方针，以避免导致副作用或其他意外行为的任意计算的问题。</p><p>    In short, a property is  syntax sugar for getter/setter methods that look like fields. Instead of having to use the methods  item.getQuantity() and  item.setQuantity(), we can access the property  item.quantity and set it using  item.quantity = 1, exactly like a field. The compiler transforms property access and assignment to use the appropriate getters/setters (hence, syntax sugar).</p><p>简而言之，属性是看起来像字段的getter/setter方法的语法糖。无需使用方法item.getQuantity()和item.setQuantity()，我们可以访问属性item.Quantity并使用item.Quantity=1设置它，这与字段完全一样。编译器转换属性访问和赋值，以使用适当的getter/setter(因此，语法糖化)。</p><p>  The most noteworthy consequence of this is, in my opinion, allowing  validation on assigment. For example,  item.quantity may be defined as follows (in Kotlin):</p><p>在我看来，这最值得注意的后果是，允许在分配时进行验证。例如，item.Quantity可以定义如下(以科特林为单位)：</p><p> class  Item {  var  quantity:  Int =    set(value) { require(value &gt;=  )  //throws if negative  field = value }}</p><p>类项目{var Quantity：int=set(Value){Required(value&gt；=)//如果负字段=value}则抛出}。</p><p>     The largest benefit of properties is replacing field use, which has a massive amount of drawbacks, with methods instead. In languages like C++ and Java that don&#39;t have properties, the best practice is to keep all fields private and manually create getters and setters. More modern languages, like C# and Kotlin, use properties for this instead which can do that automatically.</p><p>属性的最大好处是用方法取代了具有大量缺点的现场使用。在C++和Java等没有属性的语言中，最佳实践是让所有字段保持私有，并手动创建getter和setter。更多的现代语言，如C#和Kotlin，使用属性来代替，这些属性可以自动完成。</p><p>  Most of the following points are also benefits of using getters/setters over fields, and then properties step in to provide the extra bit of syntax sugar icing on the cake.</p><p>下面的大多数要点也是使用getter/setter而不是字段的好处，然后属性介入提供额外的语法糖霜。</p><p>    Property getters/setters can have different  access modifiers, allowing for fields which are read-only for external use but still mutable within the class.  Example: In Kotlin,  val counter = 0 private set defines a  counter field that can be publicly accessed but not modified (unless within the class).</p><p>属性getter/setter可以有不同的访问修饰符，允许外部使用只读但在类内仍然可变的字段。例如：在Kotlin中，val的计数器=0x0定义了一个可以公开访问但不能修改的计数器域(除非在类中)。</p><p>  Getters/setters can be used to maintain  invariants and perform other validation work, such as  quantity &gt;= 0 in the opening example.</p><p>Getters/setter可用于维护不变量和执行其他验证工作，例如开头示例中的数量为1&gt；=0。</p><p>  Since getters/setters are methods, the implementation can be changed without breaking either  API or  ABI compatibility.  Example: A  Vector class could have  x/y/z properties, but change the implementation to use a component array  [x, y, z] instead without issue.</p><p>因为getters/setter是方法，所以可以在不破坏API或ABI兼容性的情况下更改实现。例如：Vector类可以有x/y/z属性，但更改实现以使用组件数组[x，y，z]而不会出现问题。</p><p>  Additionally, getters/setters can be inlined during optimization to speed up performance at the cost of ABI compatibility.</p><p>此外，可以在优化期间内联getter/setter以牺牲ABI兼容性来提高性能。</p><p>    Properties can be used in interfaces since they&#39;re backed by methods, while fields require getters/setters to be defined for them. Notably, these getters/setters would still need to have fields defined in the implementing class to handle their values, while a property can handle that automatically.</p><p>属性可以在接口中使用，因为它们由方法支持，而字段需要为它们定义getter/setter。值得注意的是，这些getter/setter仍然需要在实现类中定义字段来处理它们的值，而属性可以自动处理。</p><p>  Properties can be used for methods which often behave like fields, but cannot be implemented with one due to subtypes requiring computation or other restrictions.  Example:  List#size() generally doesn&#39;t need computation and returns the value of a field, but some implementations (such as a  cons list) might.</p><p>属性可用于通常行为类似于字段的方法，但由于子类型需要计算或其他限制而无法使用字段实现。例如：list#size()通常不需要计算并返回字段的值，但有些实现(如cons list)可能会。</p><p>  Whether  List#size() should be a property is certainly debatable, but with how frequently collections are used I think it&#39;s almost a necessity.</p><p>List#size()是否应该成为一个属性当然是有争议的，但考虑到集合的使用频率，我认为这几乎是必要的。</p><p>    Properties are a  single unit. Getters/setters are located in the same location in the source code as the property declaration, making it easier to fully understand a field as opposed to having them defined in separate locations.</p><p>属性是一个单一的单元。在源代码中，getter/setter与属性声明位于相同的位置，与在不同的位置定义它们相比，更容易完全理解一个字段。</p><p>  Properties almost always have syntax sugar for providing default implementations of  get/set (if it&#39;s not already done automatically). In Kotlin,  val property provides a default getter while  var property provides both a getter and setter.</p><p>属性几乎总是使用语法来提供默认的get/set实现(如果它还没有自动完成的话)。在Kotlin中，val属性提供默认的getter，而var属性同时提供getter和setter。</p><p>  Debugging properties is possible without a dedicated debugger by using getters/setters. This may be minor for large languages, but if your language doesn&#39;t have an IDE or still in development this is  extremely useful.</p><p>使用getters/setters可以在没有专用调试器的情况下调试属性。对于大型语言来说，这可能是次要的，但如果您的语言没有IDE或仍在开发中，这将非常有用。</p><p>  Readability is often increased, albeit debatable. I personally find  item.quantity = 1 to be more readable than  item.setQuantity(1), especially in large chains.</p><p>尽管有争议，但可读性往往会提高。我个人认为item.Quantity=n1比item.setQuantity(1)更具可读性，尤其是在大型连锁店中。</p><p>  Generally, properties imply &#39;simple&#39; behavior, like fields, as opposed to complex computation that some methods may perform. We&#39;ll talk about this in detail soon.</p><p>通常，属性暗示简单的行为，就像字段一样，而不是某些方法可能执行的复杂计算。我们稍后将详细讨论这个问题。</p><p>    I think there are two notable downsides to having properties. First, the performance difference between field access and method calls can be significant, especially in low level languages. Second, field access has clear, well-defined behavior while a method call could effectively do anything, thus making it harder to reason about code. Let&#39;s dig in to both of these.</p><p>我认为拥有房产有两个值得注意的缺点。首先，字段访问和方法调用之间的性能差异可能很大，尤其是在低级语言中。其次，字段访问具有清晰、定义良好的行为，而方法调用可以有效地执行任何操作，因此更难对代码进行推理。让我们深入研究这两个问题。</p><p>    Field access is almost always language primitive, and is therefore faster than doing the work of a method call (which then has to access  something anyways).</p><p>字段访问几乎总是语言原始的，因此比执行方法调用(不管怎样，方法调用必须访问某些内容)的工作更快。</p><p>  That said, compiler optimizations like  inlining can easily resolve this for simple properties. In more complex cases, this is actually where properties are most useful - a field itself wasn&#39;t sufficient, so the alternative would have been a method call or sacrificing validation anyways.</p><p>也就是说，像内联这样的编译器优化可以很容易地解决简单属性的这个问题。在更复杂的情况下，这实际上是属性最有用的地方--一个字段本身是不够的，所以另一种选择就是调用方法或牺牲验证。</p><p>  In low level languages where memory layout is often important, knowing a field access corresponds to a memory lookup (and not arbitrary computation) can be important. In higher level languages, particularly Object Oriented ones that often encapsulate fields behind methods anyways, I don&#39;t believe this distinction is as necessary.</p><p>在内存布局通常很重要的低级语言中，了解字段访问对应于内存查找(而不是任意计算)可能很重要。在更高级的语言中，尤其是那些经常将字段封装在方法后面的面向对象语言中，我不认为这种区别是必要的。</p><p>    Finally, we&#39;ve made our way to what I believe is the core issue: since properties can perform arbitrary computation, it is unclear what potential behavior getting/setting a property may have. The extreme example here, of course, is deleting the entire file system. Fields on the other hand have clearly defined behavior - get or set the value, nothing more.</p><p>最后，我们谈到了我认为最核心的问题：因为属性可以执行任意计算，所以还不清楚获取/设置属性可能会有什么潜在行为。当然，这里最极端的例子是删除整个文件系统。另一方面，字段有明确定义的行为-获取或设置值，仅此而已。</p><p>  However, these type of assumptions are not unique to properties. We apply the same assumptions to methods (and honestly everything) as well. I often presume that  getX() and  setX(x) have &#39;simple&#39; behavior, but they could use lazy initialization, have unexpected validation checks, or cause side-effects and other unexpected behavior like a database  getConnection(). Naming is one of the two hard problems in computer science, likely because we carry assumptions with us that may not always fit.</p><p>然而，这些类型的假设并不是属性所特有的。我们也将同样的假设应用于方法(老实说，也适用于所有方法)。我经常假设getX()和setx(X)具有简单的行为，但它们可能使用懒惰的初始化、意外的验证检查或导致副作用和其他意外行为，如数据库getConnection()。命名是计算机科学中的两个难题之一，这可能是因为我们随身携带的假设可能并不总是合适的。</p><p>  That said, these assumptions still have value and help us reason about code without having to memorize the API of the entire system. So, I thought about the assumptions I make about properties and what guidelines could be put in place to restrict what they  should do. I&#39;m not confident enough to claim these as rules (yet!), and I welcome any counterexample that these guidelines do not address.</p><p>也就是说，这些假设仍然有价值，可以帮助我们在不必记住整个系统的API的情况下对代码进行推理。因此，我思考了我对房产的假设，以及可以制定什么样的指导方针来限制它们应该做什么。我没有足够的信心声称这些是规则(目前！)，我欢迎这些指导方针没有涉及的任何反例。</p><p>    Properties should be pure, excluding state managed by the property itself. This is intended to allow lazy initialization and setting backing fields or delegated properties as needed, but restricts modifying unrelated state or performing other side effects.</p><p>属性应该是纯属性，不包括由属性本身管理的状态。这旨在允许延迟初始化，并根据需要设置后备字段或委托属性，但会限制修改无关状态或执行其他副作用。</p><p>  Next up, let&#39;s revisit  getConnection - this method not only causes side effects but can also fail if the database is unavailable (among others). This is something I believe to be beyond a property, as it&#39;s doing computational work the caller may have to recover from (emphasis here). As such, the next guideline is...</p><p>接下来，让我们重新访问getConnection--这种方法不仅会带来副作用，而且如果数据库不可用(以及其他)，也会失败。我认为这不只是一个属性，因为它正在做调用者可能需要恢复的计算工作(这里强调)。因此，下一个指导方针是……。</p><p>  Properties should not cause errors, excluding non-recoverable errors (failure). This includes state/argument validation and potential internal errors.</p><p>属性不应导致错误(不包括不可恢复的错误(故障))。这包括状态/参数验证和潜在的内部错误。</p><p>    Properties should be used for  amortized constant-time operations, excluding inherited properties where the implementation can&#39;t support it. This is intended to avoid complex calculations while still allowing lazy initialization and  list.size for something like a  cons list. (though could be made amortized if cached).</p><p>属性应用于摊销的常量时间操作，但不包括实现无法支持的继承属性。这是为了避免复杂的计算，同时仍然允许对诸如cons list之类的东西进行延迟初始化和list.size。(不过，如果缓存的话，可以摊销)。</p><p>  This is certainly contrived to fit these cases, but I think this is the best justification I can give right now for why  list.size is acceptable as a property while something like  list.sorted() probably isn&#39;t. There&#39;s likely some odd cases I haven&#39;t thought of yet, like  file.lines being okay if it returns a sequence (lazy computation) but a list result is probably not a good choice.</p><p>这当然是为适应这些情况而设计的，但我认为这是我现在能给出的最好的解释，解释为什么list.size作为一个属性是可以接受的，而像list.sorted()这样的属性可能不是。可能还有一些我还没有想到的奇怪情况，比如文件。如果返回一个序列(惰性计算)，行是可以的，但是列表结果可能不是一个好的选择。</p><p>    Keeping these guidelines in mind, I think it&#39;d be useful to examine some example use cases of properties which I believe work really well. Both of these showcase properties being used to provide different  views on data which can be used more effectively than through methods.</p><p>牢记这些指导原则，我认为研究一些我认为非常有效的属性的示例用例会很有用。这两个Showcase属性都用于提供数据的不同视图，这些视图可以比通过方法更有效地使用。</p><p>    This example uses properties to work with individual red, blue, and green components in a  RGB hex color. These are  virtual properties, and thus the only data being stored in memory is the hex value itself. A similar approach can be used for flags.</p><p>此示例使用属性处理RGB十六进制颜色中的单个红色、蓝色和绿色组件。这些都是虚拟属性，因此内存中存储的唯一数据是十六进制值本身。可以对标志使用类似的方法。</p><p> data  class  RgbColor( var  hex:  Int) {  var  red:  Int  get() =  hex.and( ).shr( )  set(value) { require(value  in  .. )  hex =  hex.and( ).or(value.shl( )) }  var  blue:  Int = ...  var  green:  Int = ...}</p><p>数据类RgbColor(var hex：int){var red：int get()=he.and().shr()set(Value){Required(value in..。)。Hex=he.and().or(value.shl())}变量蓝：int=...。变量GREEN：INT=...}。</p><p>     This example takes things a step further and uses properties to return a new object. The example below uses properties twice: once to provide a view of the map&#39;s values as a  Collection&lt;Int&gt;, and a second time to provide another view which can be used to mutate the original map.</p><p>此示例更进一步，使用属性返回新对象。下面的示例使用了两次属性：第一次用于提供映射值的视图作为集合&lt；Int&gt；，第二次用于提供可用于改变原始映射的另一个视图。</p><p> val map = mapOf( &#34;x&#34; to  ,  &#34;y&#34; to  ,  &#34;z&#34; to  );map. values. mutable.map {  it *  it };println(map);</p><p>VAL MAP=mapOf(&#34；x&34；to，&#34；y&34；to，&#34；z&34；to)；映射。价值观。Mutable e.map{it*it}；println(Map)；</p><p>  For  some reason, Kotlin&#39;s standard library doesn&#39;t do this so the code above naturally won&#39;t compile if you try it yourself. Maybe someday in  Rhovas?</p><p>出于某种原因，Kotlin的标准库不能做到这一点，所以如果你亲自尝试，上面的代码自然不会编译。也许有一天在罗瓦斯？</p><p>  To me, the use of properties to do this with  map.values.mutable.map { ... } is clearer than the alternative with methods,  map.values().mutable().map { ... }, as the connection between the original map and the mutable view at the end is lost by the method calls. While Kotlin does support  map.mapValues and related, these need to be duplicated for  keys and  entries and may be missing other helpful functions as well. Maybe this isn&#39;t something you should do anyways, but I think it&#39;s an interesting idea and works well enough in the above example.</p><p>对我来说，使用属性对map.values.mutable.map进行此操作要比使用方法(map.values.mutable().map：{...})更清楚，因为方法调用丢失了原始映射和末尾可变视图之间的连接。虽然Kotlin确实支持map.mapValues和相关内容，但是需要为键和条目复制这些内容，并且可能会缺少其他有用的功能。也许这不是你应该做的事，但我认为这是一个有趣的想法，而且在上面的例子中效果足够好。</p><p>    I really enjoy working with properties in modern languages, and I hope this provides a fair case for why they can be a good language feature when used properly (no pun intended).</p><p>我真的很喜欢使用现代语言中的属性，我希望这能提供一个公平的案例，说明为什么当使用得当时，它们可以成为一种很好的语言功能(没有双关语的意思)。</p><p>  In quick summary, properties offer a large number of benefits over fields with respect to correctness, semantic capability, and usability with relatively few downsides in turn. The guidelines we established to avoid unexpected behavior with properties are:</p><p>简而言之，与字段相比，属性在正确性、语义能力和可用性方面提供了大量好处，而缺点相对较少。我们为避免属性出现意外行为而制定的准则如下：</p><p>    Feel free to reach out with questions or comments, and I&#39;d love to hear feedback on the above guidelines and whether this post has impacted your opinion on properties.</p><p>你可以随时提出问题或评论，我很想听听大家对上述指南的反馈，以及这篇文章是否影响了你对房产的看法。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.willbanders.dev/articles/a-case-for-properties.html">https://blog.willbanders.dev/articles/a-case-for-properties.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/案例/">#案例</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1035217.html"><img src="http://img2.diglog.com/img/2020/11/thumb_081b972fbb530ac75be628cb6bfed512.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035217.html">Instagram推出高风险的重新设计-用户不满意</a></div><span class="my_story_list_date">2020-11-15 9:25</span></div><div class="col-sm"><div><a target="_blank" href="/story/1035041.html"><img src="http://img2.diglog.com/img/2020/11/thumb_34e35c5d0ce00b1c8507dd7284ab1b8e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035041.html">API设计停留在过去</a></div><span class="my_story_list_date">2020-11-14 9:8</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034772.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c83d0d8ca23f3104d0f7450b748daf39.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034772.html">苹果HomePod迷你评论：设计紧凑，价格合理，Siri速度快，但听起来不如类似价格的竞争对手</a></div><span class="my_story_list_date">2020-11-12 22:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034771.html"><img src="http://img2.diglog.com/img/2020/11/thumb_335f8e5f9f9993f06ce19d5b4508c834.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034771.html">Facebook重新设计了Instagram的布局，在应用程序的导航栏中增加了专门的购物标签和卷轴</a></div><span class="my_story_list_date">2020-11-12 22:37</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>