<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Morphic简介：Self的UI工具包 An introduction to Morphic: Self's UI toolkit</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">An introduction to Morphic: Self's UI toolkit<br/>Morphic简介：Self的UI工具包 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-21 02:40:28</div><div class="page_narrow text-break page_content"><p>In my previous two posts, I talked about Self as the language, and the systemwhich allows it to serialize objects into text format. Now let’s talk aboutanother big part of Self, which is the programming environment and the UItoolkit that it is created from: Morphic.</p><p>在我的前两篇文章中，我谈到了Self语言，以及允许它将对象序列化为文本格式的系统。现在，让我们讨论一下Self的另一个重要部分，它是编程环境和由其创建的UItoolkit：Morphic。</p><p>  Morphic is an abstract UI toolkit built for Self. It has backends for X11 andQuartz, for GNU/Linux and macOS respectively. It is based on the idea of morphs, which are known as widgets in modern UI toolkits. The difference here,obviously, is the prototypical approach; it is after all written entirely inSelf, and so employs a prototypical-inheritance programming paradigm. All morphshave a family tree that can be traced back to the original  morph whichprovides the building blocks for implementing your own morphs.</p><p>  Morphic是为Self构建的抽象UI工具包。它具有X11和Quartz的后端，分别用于GNU / Linux和macOS。它基于变形的概念，在现代UI工具箱中称为小部件。显然，这里的区别是原型方法。毕竟，它完全是自写的，因此采用了原型继承编程范例。所有的morphshave都有一个可以追溯到原始morph的族谱树，它提供了实现自己的morph的基础。</p><p> Now, consider this scenario: an update to Morphic is made (this scenario ishypothetical), and a new field is added to the root  morph object which mustpropagate to all other morphs and is needed to display the morphs. Or a simplerscenario; you want to change a default for all morphs and you want this changeto propagate to all other morphs. However, you might remember that we previouslytalked about how instances in Self work and specifically, how they work by copying a prototype. So how can we easily propagate new slot information fromparents to copied children? The answer is  copy-downs.</p><p> 现在，考虑这种情况：对Morphic进行了更新（这种情况是假设的），并且向根变形对象添加了一个新字段，该对象必须传播到所有其他变形，并且需要显示该变形。或更简单的场景；您想要更改所有变形的默认设置，并且希望此更改传播到所有其他变形。但是，您可能还记得我们之前曾讨论过Self中的实例如何工作，尤其是通过复制原型来讨论它们如何工作。那么我们如何轻松地将新的广告位信息从父母那里传播到复制的孩子们呢？答案是抄写。</p><p>  “Copy-down” is what Self calls replicating slots that exist in another object,and updating those slots when that object changes. You may remember in theprevious post that an object had a few slots related to copy-down in itsannotation section.</p><p>  “复制”是Self称为复制另一个对象中存在的插槽，并在该对象更改时更新这些插槽的功能。您可能还记得在以前的文章中，对象的注释部分中有一些与复制相关的插槽。</p><p>  In the previous post we ignored these, but when programming in Morphiccopy-downs are important, so I’ll go into detail here. Copy-downs work bysending the “copy-down selector” as a message to the “copy-down parent” (whichis an object), and then copying down the slots (except the ones listed in “slotsto omit”). This allows changes to parent objects to propagate as long as thechange is not omitted. This is similar to “sub-classing” in that it “inherits”slots from a parent.</p><p>  在上一篇文章中，我们忽略了这些内容，但是当进行Morphiccopy-downs编程很重要时，我将在这里进行详细介绍。向下复制的工作方式是将“向下复制选择器”作为消息发送给“向下复制父对象”（是一个对象），然后向下复制插槽（“插槽省略”中列出的插槽除外）。只要不忽略更改，就可以传播对父对象的更改。这类似于“子分类”，因为它从父级“继承”了插槽。</p><p> Copy-down is not a part of the Self language, but instead of the programmingenvironment that comes with it, and its implementation is done entirely withinannotations and the mirror system (we’ll look into mirrors later, just know thatmirrors are Self’s reflection system).</p><p> 向下复制不是Self语言的一部分，而不是其自身的编程环境，其实现完全在注释和镜像系统内完成（我们将在以后的镜像中研究，只知道镜子是Self的反射系统）。 。</p><p> The handbook section aboutcopy-downgives some important information about copy-downs, but nothing that is reallyomitted here. At the end it mentions this:</p><p> 手册部分“关于复制”提供了一些有关“复制”的重要信息，但此处没有真正省略的内容。最后，它提到了这一点： </p><p> The least convenient aspect of using copy-downs is that to do the moral equivalent of creating a subclass, the programmer has to create two objects: a new traits object, and a new prototype, and then set the object annotation of the new prototype. Perhaps someday there will be a button to do this, or perhaps other styles of programming will emerge.</p><p>使用抄写的最不方便的方面是，要在道德上等同于创建子类，程序员必须创建两个对象：新的traits对象和新的原型，然后设置新原型的对象注释。也许有一天会有一个按钮来执行此操作，或者可能会出现其他样式的编程。</p><p> It turns out this document is outdated, as we  do have a way to do this in Selfnow which we will take advantage of in a short bit, when we start building ourown morph. For now, let’s take a look at what a morph actually is.</p><p> 事实证明，该文档已过时，因为我们确实可以在Selfnow中做到这一点，当我们开始构建自己的变形时，我们将在短时间内利用它。现在，让我们看一下变形实际上是什么。</p><p>  When we get the root morph prototype by typing  morph in the shell and then“Get it”, we get this object:</p><p>  当我们通过在外壳中键入morph然后然后“获取”来获得根顶点原型时，我们得到了这个对象：</p><p>  Most of the slots here isn’t of concern to us, because they are managedautomatically by Morphic when we send it messages (either directly with anevaluator, or by interacting with the morph directly). A few points that mightbe interesting are:</p><p>  这里的大多数广告位都不是我们关心的问题，因为它们在我们发送消息时由Morphic自动管理（直接与anavaluator或直接与morph交互）。可能有趣的几点是：</p><p> hResizing/ vResizing: These determine how the object sizes itselfaccording to its parent or its children. There are three modes of resizing inMorphic, which are: Rigid: The object stays at its defined width and height and does not changeits size based on its surroundings, parents or children.</p><p> hResizing / vResizing：这确定对象根据其父对象或子对象如何调整大小。在“顶点变形”中有三种调整大小的模式，分别是：刚性：对象保持其定义的宽度和高度，并且不会根据其周围环境，父母或孩子的大小而改变大小。</p><p>  Flexible (or space-filling): The object enlarges to fill available space.If multiple sibling objects have this property, they all distribute thewidth/height equally.</p><p>  灵活的（或填充空间的）：对象会扩大以填充可用空间。如果多个同级对象都具有此属性，则它们都将平均分配宽度/高度。</p><p> noStickOuts: Morphic optimizes drawing if the morph is a simple rectanglewith nothing sticking out of it.</p><p> noStickOuts：如果变形是一个简单的矩形而没有任何突出物，则Morphic会优化图形。 </p><p> velcroFlag: Kind of a weirdly named one. If this is  true then thesubmorphs of this morph cannot be yanked from the morph, and you cannotdrag-and-drop new submorphs to this morph.</p><p>velcroFlag：一种奇怪的名字。如果为真，则无法从该变形中拉出该变形的子变形，也无法将新的子变形拖放到该变形中。</p><p> Different “subclasses” of  morph have their own unique slots. Thankfully,the authors of Morphic have categorized each morph’s slots such that a morphthat is copied down from another will have its unique slots under a separatecategory, which makes it a lot easier to see what belongs to which morph.</p><p> 变形的不同“子类”具有其自己的独特位置。值得庆幸的是，Morphic的作者对每个变体的插槽进行了分类，这样，从另一个变体复制下来的一个变体将在一个单独的类别下具有其唯一的插槽，这使得查看属于哪个变体的工作变得容易得多。</p><p>  Each morph may only appear once. If you use “Show Morph” on an outliner for amorph that already exists somewhere else, it will remove itself from there andattach it to your hand (similar to the Javascript DOM in this respect).</p><p>  每个变体只能出现一次。如果您在大纲板上使用“ Show Morph”来显示已经存在于其他位置的amorph，它将从那里删除自身并将其附加到您的手上（在这方面类似于Javascript DOM）。</p><p>  As it stands, a complex morph with many submorphs in it is hard to inspect. Thesubmorphs of a morph are hidden inside a  vector called  rawMorphs and there’sno easy way to display a tree of what submorphs are available in a morph.Luckily, there is a tool in the Self programming environment that allows us toeasily inspect a submorph and its parents: the  core sampler.</p><p>  就目前而言，其中包含许多子变形的复杂变形很难检查。变形的子变形隐藏在称为rawMorphs的向量中，没有简单的方法来显示变形中可用的子变形的树。幸运的是，自编程环境中有一个工具可以让我们轻松地检查子变形及其父母：核心抽样者。</p><p>  The core sampler will list all the morphs under its “magnifying glass” (thecrosshair), starting from the innermost one up to the outermost. Each entry inthe list allows you to see its color, and to see and modify its resizing mode.You can also middle-click an entry to access the morph’s properties panel andalso get an outliner for the morph.</p><p>  核心采样器将在其“放大镜”（十字准线）下列出所有变体，从最里面的到最外面。列表中的每个条目均允许您查看其颜色，以及查看和修改其调整大小模式。您还可以在条目上单击鼠标中键以访问变形的属性面板，并获得该变形的轮廓线。</p><p>    The core sampler is extremely helpful to figure out why a submorph ismisbehaving, because you can directly see its hierarchy and open an outliner forit, debugging the morph as it operates. This is one of my favorite parts ofSelf, because you interact with the system while it’s running, having alldebugging info at hand.</p><p>    核心采样器对于弄清子变形的原因非常有帮助，因为您可以直接查看其子级并为其打开大纲视图，并在变形运行时对其进行调试。这是我最喜欢的Self之一，因为您可以在系统运行时与系统进行交互，并掌握所有调试信息。</p><p>   Let’s build a desktop calculator. It’s better than a toy example (because itactually does something) while being simple enough that this post won’t becometoo long (longer than it already is, anyway). The hierarchy of the final calculatorMorph is presented below.</p><p>   让我们构建一个桌面计算器。它比玩具示例要好（因为它实际上是在做某事），同时又足够简单，以至于帖子不会太长（反而比现在更长）。最终的计算器图形的层次结构如下所示。 </p><p> calculatorMorph columnMorph (layout) rowMorph (titleBar) labelMorph (title) uglyTextEditorMorph (editor) rowMorph (buttonRows at: 0) buttonMorph (&#39;(&#39;) buttonMorph (&#39;)&#39;) buttonMorph (&#39;CE&#39;) buttonMorph (&#39;+&#39;) rowMorph (buttonRows at: 1) buttonMorph (&#39;7&#39;) buttonMorph (&#39;8&#39;) buttonMorph (&#39;9&#39;) buttonMorph (&#39;-&#39;) rowMorph (buttonRows at: 2) buttonMorph (&#39;4&#39;) buttonMorph (&#39;5&#39;) buttonMorph (&#39;6&#39;) buttonMorph (&#39;*&#39;) rowMorph (buttonRows at: 3) buttonMorph (&#39;1&#39;) buttonMorph (&#39;2&#39;) buttonMorph (&#39;3&#39;) buttonMorph (&#39;/&#39;) rowMorph (buttonRows at: 4) buttonMorph (&#39;.&#39;) buttonMorph (&#39;0&#39;) buttonMorph (&#39;BS&#39;) buttonMorph (&#39;=&#39;)</p><p>CalculatorMorph columnMorph（layout）rowMorph（titleBar）labelMorph（title）uglyTextEditorMorph（editor）rowMorph（buttonRows at：0）buttonMorph（＆＃39;（＆＃39;）buttonMorph（＆＃39;）＆＃39;）buttonMorph（ ＆＃39; CE＆＃39;）buttonMorph（＆＃39; +＆＃39;）rowMorph（buttonRows at：1）buttonMorph（＆＃39; 7＆＃39;）buttonMorph（＆＃39; 8＆＃39;） buttonMorph（＆＃39; 9＆＃39;）buttonMorph（＆＃39;-＆＃39;）rowMorph（buttonRows at：2）buttonMorph（＆＃39; 4＆＃39;）buttonMorph（＆＃39; 5＆＃39 ;）buttonMorph（＆＃39; 6＆＃39;）buttonMorph（＆＃39; *＆＃39;）rowMorph（buttonRows at：3）buttonMorph（＆＃39; 1＆＃39;）buttonMorph（＆＃39; 2＆ ＃39;）buttonMorph（＆＃39; 3＆＃39;）buttonMorph（＆＃39; /＆＃39;）rowMorph（buttonRows at：4）buttonMorph（＆＃39;。＆＃39;）buttonMorph（＆＃ 39; 0＆＃39;）buttonMorph（＆＃39; BS＆＃39;）buttonMorph（＆＃39; =＆＃39;）</p><p>  Let’s start out by copying  frameMorph, which provides a rectangular framearound its contents. Open a shell with  New shell... from the background menu,and type in  frameMorph then “Get it” to get the  frameMorph prototype.</p><p>  让我们首先复制frameMorph，它会在其内容周围提供一个矩形框架。从后台菜单中打开带有New shell ...的shell，然后键入frameMorph，然后“获取”以获取frameMorph原型。</p><p>  Earlier we talked about copy-downs and said this is how we create “sub-classes”of morphs. We will now copy-down  frameMorph as the basis of our calculatorMorph. Middle-click  frameMorph’s header and click  &#34;Subclass&#34; Me(this is the easy method of copying down we talked about earlier). When askedfor a copydown selector, leave it as the default and click “Okay”.</p><p>  之前我们谈到了复制，并说这是我们创建变形的“子类”的方式。现在，我们将下来抄写frameMorph作为我们的CalculatorMorph的基础。右键点击frameMorph的标题，然后点击＆＃34; Subclass＆＃34;我（这是我们之前提到的简单复制方法）。当要求提供复制选择器时，将其保留为默认设置，然后单击“确定”。</p><p>    You can now dismiss the original  frameMorph either with right-click &gt;“Dismiss” or with the  X on the top right.</p><p>    现在，您可以通过右键单击＆gt;“关闭”或使用右上角的X来关闭原始frameMorph。</p><p> Now that we have the basis for our calculator, we can display it! Middle-clickthe header of our newly created morph, and click “Show Morph”. A little bluesquare should be attached to the cursor, which we can simply drop to any emptyspot.</p><p> 现在我们有了计算器的基础，就可以显示它了！右键单击我们新创建的变形的标题，然后单击“显示变形”。应该在光标上附加一个小方块，我们可以将其简单地放置到任何空白处。</p><p>  Of course, we want it to look like a part of our Morphic system, so let’s pick abetter color for it than blue  1. Open the evaluator on our morph’s outliner,and enter  color: paint named: &#39;lightGray&#39;. and then “Do it”.</p><p>  当然，我们希望它看起来像是Morphic系统的一部分，所以让我们为它选择比蓝色更好的颜色1。在变形轮廓器上打开评估器，然后输入颜色：paint名称：＆＃39; lightGray＆＃39; 。然后“做”。</p><p>  color: is a message that is provided to us by  traits morph. You can evaluate traits morph in the shell to see what functions are available. Be warned, the traits morph object is quite large and it can be hard to find a specific thingyou’re looking for, but it is categorized like most other standard libraryobjects.</p><p>  color：是由traits morph提供给我们的消息。您可以在外壳中评估特征变形，以查看可用的功能。请注意，traits morph对象很大，很难找到您要查找的特定对象，但是它与大多数其他标准库对象一样被分类。 </p><p> Now let’s define a few slots that we will be using (under a new category, so wedon’t get confused later down the line). Above in the hierarchy I put a fewnames in parenthesis for the morphs that we will hold a reference to. Createthe category by selecting “Add Category” from the object menu, then create slotson it by middle-clicking the category and selecting “Add Slot”  2.</p><p>现在，我们定义一些我们将要使用的广告位（在一个新类别下，这样以后就不会感到困惑了）。在层次结构的上方，我在括号中为将要引用的变形命名了几个名称。通过从对象菜单中选择“添加类别”来创建类别，然后通过右键单击类别并选择“添加插槽”在其上创建插槽2。</p><p>   Before we proceed further, let’s set the resizing mode of our calculator. Bydefault, it is in flexible mode, but we want it to wrap around its contents.There are two ways of changing the resizing mode:</p><p>   在继续进行操作之前，让我们设置计算器的调整大小模式。默认情况下，它处于灵活模式下，但我们希望它包装其内容。更改大小调整模式有两种方法：</p><p>  I personally chose the former as it is faster for me, but you can do it howeveryou like.</p><p>  我个人选择了前者，因为它对我来说更快，但是您可以按自己的意愿来做。</p><p> Now let’s create the layout morph for our calculator. We want to layout thetitle, the editor and then the buttons vertically, so we will use a columnMorph which allows us to put multiple rows below each other. Copythe  columnMorph prototype and set the  layout slot to it, and then add it toour calculator morph.</p><p> 现在，让我们为计算器创建布局变形。我们想要垂直放置标题，编辑器和按钮，因此我们将使用columnMorph，它使我们可以将多行放置在彼此下方。复制columnMorph原型并为其设置布局插槽，然后将其添加到我们的计算器变形中。</p><p>   By default  columnMorph comes with an ugly brown-ish color. We can set it tonot display color at all, by evaluating layout color: paint named &#39;transparent&#39;.While we’re at it, let’s make it also shrink-wrap its contents by evaluating layout beShrinkWrap  3.</p><p>   默认情况下，columnMorph带有丑陋的棕褐色。我们可以通过评估布局颜色将其设置为根本不显示颜色：名为＆＃39; transparent＆＃39;的油漆。尽管如此，我们也可以通过评估布局beShrinkWrap 3使其收缩包装内容。</p><p>  Now let’s create the title bar. First, we will create the  labelMorph with thelabel  Calculator and make it white in color and with a font size of 12. Thenwe will create a  rowMorph for  titleBar and set its color to  blue. Finally,we will add  title to  titleBar, and add  titleBar to  layout.</p><p>  现在，我们创建标题栏。首先，我们将使用label Calculator创建labelMorph，并使其颜色为白色，字体大小为12。然后，为titleBar创建一个rowMorph，并将其颜色设置为蓝色。最后，我们将标题添加到titleBar，并将titleBar添加到布局。</p><p> title :  labelMorph  copyLabel :  &#39;Calculator&#39;  FontSpec :  ( labelMorph  fontSpec  copySize :  12 )  Color :  ( paint  named :  &#39;white&#39; ) . titleBar :  rowMorph  copy  beFlexible  borderWidth :  2 . titleBar  color :  paint  named :  &#39;blue&#39; . titleBar  addMorph :  title . layout  addMorph :  titleBar .</p><p> 标题：labelMorph copyLabel：＆＃39; Calculator＆＃39; FontSpec：（labelMorph fontSpec copySize：12）Color：（绘制名称：＆＃39; white＆＃39;）。 titleBar：rowMorph复制beFlexible borderWidth：2。 titleBar颜色：油漆名为：＆＃39; blue＆＃39; 。 titleBar addMorph：标题。布局addMorph：titleBar。 </p><p>  (You may not agree with my stylistic choices, of course. Feel free to mess aroundwith the colors and font sizes. If you mess up along the way, evaluate removeAllMorphs to clear the submorphs and restart from the  layout section.)</p><p>（当然，您可能不同意我的风格选择。请随意弄乱颜色和字体大小。如果您一路搞砸，请评估removeAllMorphs以清除子变形并从布局部分重新开始。）</p><p> Now let’s add the editor morph, which will be our calculator display.  Thehandbookgives us two options from the available morphs as editors:  editorMorph whichis a regular text editor (that can hold morphs as well as text!), and uglyTextEditorMorph which only holds text but is higher performance. Ipersonally prefer the  uglyTextEditorMorph, because it is what is used in theevaluator and I think it looks cooler.</p><p> 现在，添加编辑器变形，这将成为我们的计算器显示。该手册从可用的变形中提供了两个选项作为编辑器：editorMorph是常规文本编辑器（既可以容纳变形又可以容纳文本！），以及uglyTextEditorMorph仅容纳文本但性能更高。我个人更喜欢uglyTextEditorMorph，因为它是评估程序中使用的，而且我认为它看起来更酷。</p><p> &#34;offWhite is the color that the evaluator uses for the editor.&#34; editor :  uglyTextEditorMorph  copyString :  &#39;0&#39;  Style :  ( |  color  =  paint  named :  &#39;offWhite&#39; .  | )  layout  addMorphLast :  editor .</p><p> ＆＃34; offWhite是评估程序用于编辑器的颜色。＆＃34;编辑器：uglyTextEditorMorph copyString：＆＃39; 0＆＃39;样式：（| color =绘画名称：＆＃39; offWhite＆＃39;。|）布局addMorphLast：编辑器。</p><p>  Finally, we will build our buttons. I have decided to arrange the buttons as 5rows of 4 buttons each. But that’s 20 buttons! Should we really have to type outthe initialization of all of those buttons manually?</p><p>  最后，我们将构建按钮。我决定将按钮排列为5行，每行4个按钮。但这是20个按钮！我们是否真的必须手动键入所有这些按钮的初始化？</p><p> Well, there’s a better way. If you check out the outliner of our calculator, youwill notice that  parent* points to  a slots object. If you click on thebutton next to it, it will bring up a separate object.</p><p> 好，有更好的方法。如果您查看我们的计算器的大纲视图，您会注意到parent *指向插槽对象。如果单击旁边的按钮，它将弹出一个单独的对象。</p><p>  This object is what is known as a  trait object. You may have seen some ofthose if you have explored the Self environment for yourself a little bit. Ifthey are within the global  traits object, the outliner will mark it as a traitby coloring it purple on the left edge. However, as the comment on the  traitsobject says, not all traits have to be in this object and many objects storetheir traits privately on their prototype (still accessible, but not registeredas an “official” trait).</p><p>  该对象是所谓的特征对象。如果您自己进行了一些自我环境的探索，您可能已经看到了其中的一些内容。如果它们在全局特征对象中，则轮廓绘制器将通过在左侧边缘上将其着色为紫色来将其标记为特征。但是，正如对traits对象的评论所言，并非所有特性都必须在该对象中，并且许多对象将其特性私密地存储在其原型中（仍可访问，但未注册为“官方”特性）。</p><p> In Self, a good style is to always separate the changing parts of an object fromunchanging parts. Unchanging parts would be code, and changing parts would bedata, like the  rawBox property on our calculator morph. Code will change veryrarely, and when we need to change functionality we can just create a new objectthat refers to our original traits object and refer to that with a parent slot;however, data will change very frequently as we copy, and it would be wastefulto copy the code everytime we want to create a copy of the prototype. To solvethis, we use trait objects for code and prototypes for initial data.</p><p> 在“自我”中，良好的风格是始终将对象的变化部分与不变的部分分开。不变的部分将是代码，而可变的部分将是数据，就像我们的计算器变形中的rawBox属性一样。代码将很少更改，并且当我们需要更改功能时，我们可以创建一个新对象，该对象引用原始的traits对象，并使用父插槽引用该对象；但是，在复制时数据将非常频繁地更改，这将浪费很多时间。每当我们要创建原型副本时，都复制代码。为了解决这个问题，我们将特征对象用于代码，将原型用于初始数据。 </p><p> When we “subclassed” the  frameMorph to create our calculator morph, Selfautomatically created a new traits object for us that references traits frameMorph and attached it to our newly created morph. This allows usto quickly add new methods to our calculator morph. So let’s add a conveniencemethod to quickly build a button for us.</p><p>当我们“子类化” frameMorph以创建计算器变形时，Selfautomatically为我们创建了一个新的traits对象，该对象引用了traits frameMorph并将其附加到我们新创建的变形中。这使我们能够快速将新方法添加到计算器变形中。因此，我们添加一种便捷方法来为我们快速构建一个按钮。</p><p> One last thing you need to know that buttons in Morphic need a  target (anobject to execute their action on) and a  script (code that will execute whenthe button is pressed). In the script, you can refer to  target to refer to theobject that the button is targetting.</p><p> 您需要知道的最后一件事是，Morphic中的按钮需要一个目标（一个对象来执行其操作）和一个脚本（当按下按钮时将执行的代码）。在脚本中，您可以引用target来引用按钮定位的对象。</p><p> With all of that out of the way, let’s add  buildButton:Script: on our traitobject:</p><p> 一切就绪后，让我们在traitobject上添加buildButton：Script：：</p><p> buildButton :  label  Script :  s  =  ( |  b  |  &#34;Create the new button.&#34;  b :  ui2Button  copyColor :  ( paint  named :  &#39;lightGray&#39; )  Target :  self .  &#34;Make it flexible, set its label and script. , is the concatenation operator.&#34;  b  beFlexible .  b  label :  label .  b  script :  &#39;target &#39; ,  s .  b )</p><p> buildButton：标签脚本：s =（| b |＆＃34;创建新按钮。＆＃34; b：ui2Button copyColor ：（绘制名为：＆＃39; lightGray＆＃39;）目标：self。使它变得灵活，设置其标签和脚本。是串联运算符。b beFlexible。b标签：label。b脚本：＆＃39; target＆＃39;，s。b）</p><p>  Let’s test it out. Enter  buildButton: &#39;1&#39; Script: &#39;addCharacter: \&#39;1\&#39;&#39; on ourcalculator morph’s evaluator and “Get it”. A button outliner should be attachedto our hands which we can drop anywhere. We can then display the button using“Show Morph” from the object menu on the button outliner.</p><p>  让我们测试一下。输入buildButton：＆＃39; 1＆＃39;脚本：＆＃39; addCharacter：\＆＃39; 1 \＆＃39;＆＃39;在ourcalculator morph的评估器上，然后“获取”。按钮轮廓器应附着在我们的手上，我们可以将其放到任何地方。然后，我们可以使用按钮轮廓器上对象菜单中的“显示变形”来显示按钮。</p><p>  Now, if we click this button, we will get an error, because we didn’t define addCharacter: for our calculator morph yet. So let’s do that now. I will placeit under the “text operations” category.</p><p>  现在，如果单击此按钮，将会收到错误消息，因为我们尚未为计算器变形定义addCharacter：。现在开始吧。我将其放置在“文本操作”类别下。</p><p> addCharacter :  c  =  (  &#34;If the display shows 0 and we didn&#39;t press ., replace the display contents  with the character we just entered, like calculators do.&#34;  ( editor  contentsString  =  0 )  &amp;&amp;  [ c  !=  &#39;.&#39; ]  ifTrue :  [ editor  setText :  c ]  &#34;Otherwise, simply insert the character at the cursor point.&#34;  False :  [ editor  text  insert_char :  c ].  self )</p><p> addCharacter：c =（＆＃34;如果显示为0，而我们没有按。，则将显示内容替换为我们刚才输入的字符，就像计算器一样。＆＃34;（编辑者contentsString = 0）＆amp ;＆amp; [c！=＆＃39;。＆＃39;] ifTrue：[编辑器setText：c]＆＃34;否则，只需将字符插入光标点。＆＃34; False：[编辑器文本insert_char ：c]。self） </p><p> If you click the button now, you should see the it fill the calculator displaywith 1s. You just learned how to hook up Morphic widgets! But wait, we’re notdone yet. We need to create a grid of buttons for our calculator like I showedin the hierarchy earlier in this post. To do this, we will just define a new vector on our  buttonRows slot, fill each element of it with  rowMorphs, andinsert our buttons to each row.</p><p>如果现在单击该按钮，您应该看到它以1s填充计算器显示。您刚刚学习了如何连接Morphic小部件！但是，等等，我们还没有完成。我们需要为计算器创建一个按钮网格，就像我在本文前面的层次结构中所显示的那样。为此，我们只需要在buttonRows插槽上定义一个新向量，并用rowMorphs填充其中的每个元素，然后将按钮插入每行。</p><p> (You can get rid of the button we just created by selecting “Dismiss” from themorph menu (right-click)).</p><p> （您可以通过从变形菜单中选择“关闭”（右键单击）来摆脱刚刚创建的按钮）。</p><p> Let’s take it one step at a time. First, let’s fill out our  buttonRows with rowMorphs by evaluating the following snippet in the evaluator.</p><p> 让我们一次迈出一步。首先，让我们通过在评估器中评估以下代码段，用rowMorphs填充buttonRows。</p><p> buttonRows :  vector  copySize :  5 . &#34;traits integer do: is how range loops are done in Self, similar to Ruby.&#34; 5  do :  [|  :i .  r  |  r :  rowMorph  copy  beFlexible  borderWidth :  0 .  r  color :  paint  named :  &#39;transparent&#39; .  buttonRows  at :  i  Put :  r .  layout  addMorphLast :  r . ]. &#34;Let layout know that the layout changed.&#34; layout  layoutChanged .</p><p> buttonRows：矢量copySize：5。特质整数do：是在Self中完成范围循环的方式，类似于Ruby。 5做：[| ：一世 。 r | r：rowMorph复制beFlexible borderWidth：0。 r颜色：油漆名称：＆＃39;透明＆＃39; 。 buttonRows位于：i放置：r。布局addMorphLast：r。 ]。 ＆＃34;让布局知道布局已更改。＆＃34;布局layoutChanged。</p><p>  We can finally add our buttons. Since each button is unique, we’ll just add themone by one:</p><p>  我们终于可以添加按钮了。由于每个按钮都是唯一的，因此我们将它们逐个添加：</p><p> ( buttonRows  at :  0 )  addMorphLast :  buildButton :  &#39;(&#39;  Script :  &#39;addCharacter: \&#39;(\&#39;&#39; . ( buttonRows  at :  0 )  addMorphLast :  buildButton :  &#39;)&#39;  Script :  &#39;addCharacter: \&#39;)\&#39;&#39; . ( buttonRows  at :  0 )  addMorphLast :  buildButton :  &#39;CE&#39;  Script :  &#39;clear&#39; . ( buttonRows  at :  0 )  addMorphLast :  buildButton :  &#39;+&#39;  Script :  &#39;addCharacter: \&#39;+\&#39;&#39; . ( buttonRows  at :  1 )  addMorphLast :  buildButton :  &#39;7&#39;  Script :  &#39;addCharacter: \&#39;7\&#39;&#39; . ( buttonRows  at :  1 )  addMorphLast :  buildButton :  &#39;8&#39;  Script :  &#39;addCharacter: \&#39;8\&#39;&#39; . ( buttonRows  at :  1 )  addMorphLast :  buildButton :  &#39;9&#39;  Script :  &#39;addCharacter: \&#39;9\&#39;&#39; . ( buttonRows  at :  1 )  addMorphLast :  buildButton :  &#39;-&#39;  Script :  &#39;addCharacter: \&#39;-\&#39;&#39; . ( buttonRows  at :  2 )  addMorphLast :  buildButton :  &#39;4&#39;  Script :  &#39;addCharacter: \&#39;4\&#39;&#39; . ( buttonRows  at :  2 )  addMorphLast :  buildButton :  &#39;5&#39;  Script :  &#39;addCharacter: \&#39;5\&#39;&#39; . ( buttonRows  at :  2 )  addMorphLast :  buildButton :  &#39;6&#39;  Script :  &#39;addCharacter: \&#39;6\&#39;&#39; . ( buttonRows  at :  2 )  addMorphLast :  buildButton :  &#39;*&#39;  Script :  &#39;addCharacter: \&#39;*\&#39;&#39; . ( buttonRows  at :  3 )  addMorphLast :  buildButton :  &#39;1&#39;  Script :  &#39;addCharacter: \&#39;1\&#39;&#39; . ( buttonRows  at :  3 )  addMorphLast :  buildButton :  &#39;2&#39;  Script :  &#39;addCharacter: \&#39;2\&#39;&#39; . ( buttonRows  at :  3 )  addMorphLast :  buildButton :  &#39;3&#39;  Script :  &#39;addCharacter: \&#39;3\&#39;&#39; . ( buttonRows  at :  3 )  addMorphLast :  buildButton :  &#39;/&#39;  Script :  &#39;addCharacter: \&#39;/\&#39;&#39; . ( buttonRows  at :  4 )  addMorphLast :  buildButton :  &#39;.&#39;  Script :  &#39;addCharacter: \&#39;.\&#39;&#39; . ( buttonRows  at :  4 )  addMorphLast :  buildButton :  &#39;0&#39;  Script :  &#39;addCharacter: \&#39;0\&#39;&#39; . ( buttonRows  at :  4 )  addMorphLast :  buildButton :  &#39;BS&#39;  Script :  &#39;backspace&#39; . ( buttonRows  at :  4 )  addMorphLast :  buildButton :  &#39;=&#39;  Script :  &#39;evaluate&#39; .</p><p> （buttonRows位于：0）addMorphLast：buildButton：＆＃39;（＆＃39;脚本：＆＃39; addCharacter：\＆＃39;（\＆＃39;＆＃39;。（buttonRows位于0）addMorphLast ：buildButton：＆＃39;）＆＃39;脚本：＆＃39; addCharacter：\＆＃39;）\＆＃39;＆＃39; 。 （buttonRows位于：0）addMorphLast：buildButton：＆＃39; CE＆＃39;脚本：＆＃39;清除＆＃39; 。 （buttonRows位于：0）addMorphLast：buildButton：＆＃39; +＆＃39;脚本：＆＃39; addCharacter：\＆＃39; + \＆＃39;＆＃39; 。 （buttonRows位于：1）addMorphLast：buildButton：＆＃39; 7＆＃39;脚本：＆＃39; addCharacter：\＆＃39; 7 \＆＃39;＆＃39; 。 （buttonRows位于：1）addMorphLast：buildButton：＆＃39; 8＆＃39;脚本：＆＃39; addCharacter：\＆＃39; 8 \＆＃39;＆＃39; 。 （buttonRows位于：1）addMorphLast：buildButton：＆＃39; 9＆＃39;脚本：＆＃39; addCharacter：\＆＃39; 9 \＆＃39;＆＃39; 。 （buttonRows位于：1）addMorphLast：buildButton：＆＃39;-＆＃39;脚本：＆＃39; addCharacter：\＆＃39;-\＆＃39;＆＃39; 。 （buttonRows位于：2）addMorphLast：buildButton：＆＃39; 4＆＃39;脚本：＆＃39; addCharacter：\＆＃39; 4 \＆＃39;＆＃39; 。 （buttonRows位于：2）addMorphLast：buildButton：＆＃39; 5＆＃39;脚本：＆＃39; addCharacter：\＆＃39; 5 \＆＃39;＆＃39; 。 （buttonRows位于：2）addMorphLast：buildButton：＆＃39; 6＆＃39;脚本：＆＃39; addCharacter：\＆＃39; 6 \＆＃39;＆＃39; 。 （buttonRows位于：2）addMorphLast：buildButton：＆＃39; *＆＃39;脚本：＆＃39; addCharacter：\＆＃39; * \＆＃39;＆＃39; 。 （buttonRows位于：3）addMorphLast：buildButton：＆＃39; 1＆＃39;脚本：＆＃39; addCharacter：\＆＃39; 1 \＆＃39;＆＃39; 。 （buttonRows位于：3）addMorphLast：buildButton：＆＃39; 2＆＃39;脚本：＆＃39; addCharacter：\＆＃39; 2 \＆＃39;＆＃39; 。 （buttonRows位于：3）addMorphLast：buildButton：＆＃39; 3＆＃39;脚本：＆＃39; addCharacter：\＆＃39; 3 \＆＃39;＆＃39; 。 （buttonRows位于：3）addMorphLast：buildButton：＆＃39; /＆＃39;脚本：＆＃39; addCharacter：\＆＃39; / \＆＃39;＆＃39; 。 （buttonRows位于：4）addMorphLast：buildButton：＆＃39;。＆＃39;脚本：＆＃39; addCharacter：\＆＃39;。\＆＃39;＆＃39; 。 （buttonRows位于：4）addMorphLast：buildButton：＆＃39; 0＆＃39;脚本：＆＃39; addCharacter：\＆＃39; 0 \＆＃39;＆＃39; 。 （buttonRows位于：4）addMorphLast：buildButton：＆＃39; BS＆＃39;脚本：＆＃39;退格＆＃39; 。 （buttonRows位于：4）addMorphLast：buildButton：＆＃39; =＆＃39;脚本：＆＃39;评估＆＃39; 。</p><p> Most of these are pretty straight-forward, they just add characters to thedisplay, but there are a few functions we didn’t implement, so let’s do that nowon the traits object.</p><p> 这些功能大多数都非常简单明了，它们只是向显示器添加字符，但是有一些我们尚未实现的功能，所以现在就在traits对象上进行操作。 </p><p> Each method is a separate slot, so make sure you create 3 new slots from theobject menu.</p><p>每个方法都是一个单独的插槽，因此请确保从对象菜单中创建3个新插槽。</p><p> &#34;Resets the calculator input.&#34; clear  =  ( editor  setText :  &#39;0&#39; ) . &#34;Removes one character at cursor point. If display is empty, set it to &#39;0&#39;.&#34; backspace  =  (  editor  text  backspace .  ( editor  contentsString  =  &#39;0&#39; )  ifTrue :  [ editor  setText :  &#39;0&#39; ]. ) . &#34;Evaluates the expression on the editor display and writes the result.&#34; evaluate  =  ( editor  setText :  editor  text  eval  asString ) .</p><p> ＆＃34;重置计算器输入。 clear =（编辑器setText：＆＃39; 0＆＃39;）。 ＆＃34;在光标处删除一个字符。如果显示为空，则将其设置为＆＃39; 0＆＃39;。 Backspace =（编辑器文本Backspace。（编辑contentString =＆＃39; 0＆＃39;）ifTrue：[编辑器setText：＆＃39; 0＆＃39;]。 ＆＃34;在编辑器显示上求值表达式并写入结果。评估=（编辑setText：编辑文本eval asString）。</p><p> evaluate uses  traits string eval to evaluate the contents of the textdisplay as a Self expression, which works just fine. However, Self does not haveoperator precedence (because operators are just messages with special names),and will complain if you put different operators next to each other, so you willneed to use parentheses.</p><p> 评估使用traits字符串eval来评估文本显示的内容作为Self表达式，这很好用。但是，Self不具有运算符优先级（因为运算符只是具有特殊名称的消息），并且如果您将不同的运算符彼此并排放置，则会抱怨，因此您需要使用括号。</p><p> And our calculator is finally done! With practice (and a lot of exploring theMorphic toolkit), it took me about 15 minutes to build it from scratch for thispost.</p><p> 我们的计算器终于完成了！通过实践（以及大量的Morphic工具包探索），我花了大约15分钟从头开始构建它。</p><p>   Of course, we built our calculator, but we built it as the “prototype”calculator: when users want to use the calculator, they should copy it and usethat copy. For this, we need to set up a couple more things.</p><p>   当然，我们构建了计算器，但是将其构建为“原型”计算器：当用户想要使用计算器时，他们应该复制并使用该副本。为此，我们需要设置更多内容。</p><p> When we copy our calculator, Self will create a copy of all slots: this includessubmorphs  and our reference slots. Obviously this poses a problem: now twodiverging copies of the morphs we reference exist, the value of the slot and thesubmorph embedded in the morph. To solve this problem,  traits morphspecializes  copy to do some extra work. In particular, after copying is done,it will call  mapReferencesUsing: on each morph that has been copied with adictionary of old morph references to new ones. Using </p><p> 当我们复制计算器时，Self将创建所有插槽的副本：这包括子变形和我们的参考插槽。显然，这带来了一个问题：现在存在我们所引用的变形的两个不同副本，插槽的值和嵌入在变形中的子变形。为了解决这个问题，特质使副本词形化以做一些额外的工作。特别是，复制完成后，它将对每个复制的morph调用mapReferencesUsing：将旧的morph引用归结为新的morph。使用</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://sin-ack.github.io/posts/morphic-intro/">https://sin-ack.github.io/posts/morphic-intro/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/简介/">#简介</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/morphic/">#morphic</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/变形/">#变形</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>