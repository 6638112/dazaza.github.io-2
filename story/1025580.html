<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>纯Python中的Haskell语言特性和标准库</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">纯Python中的Haskell语言特性和标准库</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-09-22 22:38:33</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/9/06fbcba336cdbb52814524f2b061aa00.png"><img src="http://img2.diglog.com/img/2020/9/06fbcba336cdbb52814524f2b061aa00.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Hask是一个纯Python、零依赖的库，它模仿了来自Haskell的大多数核心语言工具，包括：</p><p>完整的Hindley-Milner类型系统(带有类型类)，它将对任何装饰有Hask类型签名的函数进行类型检查。</p><p>所有您喜欢的语法和控制流工具，包括运算符节、一元错误处理、保护等。</p><p>来自Haskell基库的(一些)标准库的Python移植，包括：来自Haskell基库的类型类，包括Functor、Applative、Monad、Enum、Num等。</p><p>请注意，所有这一切仍然在很大程度上是在进行alpha之前的工作，有些事情可能是错误的！</p><p>我想把尽可能多的Haskell塞到Python中，同时仍然与Python的其余部分100%兼容，只是想看看结果中是否有什么有用的想法。而且，这也很有趣！</p><p>本实验的贡献、分支和扩展总是受欢迎的！请随时提交拉取请求、打开问题或给我发电子邮件。本着这个项目的精神，鼓励尽可能多地滥用Python语言。</p><p>Hask是一个大的伪Haskell函数编程库。本自述的其余部分介绍了基础知识。</p><p>要导入所有语言功能：从Hask import*导入前奏：从Hask import Prelu导入基本库，例如数据。List：从Hask导入数据。List。</p><p>Hask提供了List类型，这是一种惰性的静态类型列表，类似于Haskell的标准列表类型。</p><p>要创建一个新列表，只需将元素放在L[和]括号内，或将现有的迭代器放在L[]内。</p><p>&gt；&gt；&gt；L[1，2，3]L[1，2，3]&gt；&gt；my_list=[&#34；a&#34；，&#34；c&#34；]&gt；&gt；L[my_list]L[&#39；a&#39；，&#39；b&#39；，&#39；C&#39；]&gt；&gt；&gt；L[(x**2 for x in range(1，11))]L[1...]。</p><p>要将元素添加到列表的前面，请使用cons运算符^。要组合两个列表，请使用连接运算符+。</p><p>&gt；&gt；1^L[2，3]L[1，2，3]&gt；&gt；&#34；^(&#34；甜蜜&#34；^(&#34；Prince&#34；^L[[]]))L[&#34；晚安&#34；，&#34；甜蜜&#34；]&gt；&gt；&#34；a&#34；^L[1.0，10.3]#类型错误&gt；&gt；&gt；L[1，2]+L[3，4]L[1，2，3，4]。</p><p>列表总是延迟计算，并且只在需要时计算列表元素，因此您可以使用无限列表或在列表中放置永不结束的生成器。(当然，如果您尝试计算一个无限列表的整体，例如，通过尝试使用len查找列表的长度，您仍然可以炸毁解释器。)。</p><p>创建无限列表的一种方式是通过列表理解。与Haskell一样，列表理解有四种基本类型：</p><p>#list从1到无穷大，按1计数L[1，...]#list从1到无穷，按二L[1，3，...]#list从1到20(含)，按一L[1，...，20]#list从1到20(含)，按四个L[1，5，...，20]计数。</p><p>列表理解可以用于整数、长整型、浮点型、单字符串或Enum类型类的任何其他实例(稍后将详细介绍)。</p><p>Hask提供了用于列表操作(Take、Drop、Take While等)的所有Haskell函数，或者您也可以使用Python风格的索引。</p><p>&gt；&gt；&gt；L[1，...]。L[1...]&gt；&gt；&gt；来自Hask。数据。列出导入Take&gt；&gt；&gt；Take(5，L[&#34；a&#34；，&#34；b&#34；，...])。L[&#39；a&#39；，&#39；b&#39；，&#39；c&#39；，&#39；d&#39；，&#39；e&#39；]&gt；&gt；&gt；L[1，...][5：10]L[6，7，8，9，10]&gt；&gt；&gt；出自Hask。数据。列出从Hask导入的地图&gt；&gt；&gt；。数据。字符导入chr&&gt;；&gt；&gt；Letters=map(chr，L[97，...])&gt；&gt；字母[：9]L[&#39；a&#39；，&#39；b&#39；，&#39；c&#39；，&#39；d&#39；，&#39；e&#39；，&#39；f&#39；，&#39；g&#39；，&#39；g&#39；，&#39；H&#39；，&#39；I&#39；]&gt；&gt；&gt；len(L[1，3，...])#嗯哦。</p><p>Hask允许您定义代数数据类型，这些类型是具有固定数量的类型化的未命名字段的不可变对象。</p><p>从Hask导入数据d派生自Hask导入读取、显示、公式、命令可能为Nothing，仅为=\Data。可能(&#34；a&#34；)==d.没有|d.仅(&#34；a&#34；)&amp；派生(Read，Show，Eq，Ord)。</p><p>要定义此类型的数据构造函数，请使用d。数据构造函数的名称排在第一位，后跟其字段。多个数据构造函数应用|分隔。如果您的数据构造函数没有字段，则可以省略括号。例如：</p><p>要自动派生类型的类型类实例，请添加&amp；派生(...类型类...)。在数据构造函数声明之后。目前，唯一可以派生的类型类是Eq、Show、Read、Ord和Bound。</p><p>左、右=\DATA。(&#34；a&#34；，&#34；b&#34；)==d.Left(&#34；a&#34；)|d.Right(&#34；b&#34；)&amp；派生(Read，Show，Eq)排序，LT，EQ，GT=\DATA。排序==d.lt|d.EQ|d.gt&amp；派生(Read，Show，Eq，Ord，Bound)。</p><p>现在可以使用DATA语句中定义的数据构造函数来创建这些新类型的实例。如果数据构造函数不带参数，则可以像使用变量一样使用它。</p><p>您可以使用_t查看对象的类型(相当于GHCI中的：t)。</p><p>&gt；&gt；&gt；来自Hask import_t&gt；&gt；&gt；(1)int&gt；&gt；&gt；_t(Just(&#34；Soylent green&#34；))(可能是str)&gt；&gt；&gt；(right((&#34；a&#34；，1))(a(str，int))&gt；&gt；&gt；_t(Just)(a-&gt；可能a)&gt；&gt；&gt；_t(L[1，2，3，4])[int]。</p><p>那么这些类型的人是怎么回事呢？Hask在Python的类型系统之上运行自己的影子Hindley-Milnertype系统；_t显示特定对象的Hask类型。</p><p>在Hask中，类型化函数采用TypedFunc对象的形式，这些对象是Python函数周围的类型选择器。创建TypedFuncobject有两种方法：</p><p>使用**运算符(类似于Haskell中的：：)提供类型。用于将函数或lambda转换为REPL中的TypedFunc对象，或包装已定义的Python函数。</p><p>TypedFunc对象有几个特殊属性。首先，对它们进行类型检查--当提供参数时，类型推理引擎将检查它们的类型是否与类型签名匹配，如果存在差异则引发TypeError。</p><p>&gt；&gt；&gt；f=(lambda x，y：x+y)**(H/int&gt；&gt；int&gt；&gt；int)&gt；&gt；&gt；f(2，3)5&gt；&gt；&gt；f(9，1.0)#类型错误。</p><p>&gt；&gt；&gt；g=(lambda a，b，c：a/(b+c))**(H/int&gt；&gt；int)&gt；&gt；&gt；g(10，2，3)2&gt；&gt；&gt；part_g=g(12)&gt；&gt；&gt；Part_g(2，2)3&gt；&gt；&gt；g(20，1)(4)4。</p><p>TypedFunc对象还有两个特殊的中缀操作符，即*和%操作符。*是合成运算符(相当于(.)。在Haskell中)，所以f*g等同于lambda x：f(g(X))。%只是Apply操作符，它将TypedFunc应用于一个参数(相当于Haskell中的($))。该表示法(与部分应用程序结合使用时)的方便性怎么强调都不为过--这样可以消除大量嵌套括号。</p><p>&gt；&gt；&gt；出自Hask。前奏导入Flip&gt；&gt；&gt；h=(lambda x，y：x/y)**(H/Float&gt；&gt；Float&gt；&gt；Float)&gt；&gt；h(3.0)*h(6.0)*Flip(h，2.0)%36.0 9.0。</p><p>组合操作也是类型检查的，这使得它对以无指针风格编写程序很有吸引力，即，用组合将许多函数链接在一起，并依赖类型系统来捕获编程错误。</p><p>类型签名语法非常简单，它由几个基本原语组成，可以组合这些原语来构建任何类型签名：</p><p>#将两个整数加在一起@sig(H/int&gt；&gt；int&gt；&gt；int)def add(x，y)：return x+y#函数参数顺序相反@sig(H/(H/&#34；a&#34；&gt；&gt；&#34；b&#34；&gt；&#34；c&#34；)&gt；&gt；&#34；b&#34；&gt；&gt；&#34；a&#34；&gt；&gt；&#34；c&#34；)def flip(f，b，a)：return f(a，b)#在Python(非类型化)上映射Python(非类型化)函数set@sig(H/func&&gt;&gt；set&gt；&gt；Set)def set_map(fn，lst)：return set((fn(X)for x in lst))#将类型化函数映射到列表上@sig(H/(H/&#34；a&#34；&gt；&#34；b&#34；)&gt；&gt；[&#34；a&#34；]&gt；&gt；[&#34；b&#34；])def map(f，xs)：返回L[(f(X)for x in xs)]#带有公式约束的类型签名@sig(H[(Eq，&#34；a&#34；)]/&#34；a&#34；&gt；&gt；[&#34；a&#34；]&gt；&gt；Bool)def not_in(y，xs)：return not any((x==y for x in xs))#具有类型参数的类型构造函数(可能)的类型签名@sig(H/int&gt；&gt；(可能，int))def safe_div(x，y)：如果y==0，则不返回任何内容，否则只返回(x/y)#不返回任何内容的函数的类型签名@sig(H/int&gt；&gt；&gt；无)定义发射导弹(导弹数量)：打印正在发射{0}枚导弹！投掷炸弹！&#34；%枚导弹。</p><p>还可以使用t创建类型同义词。例如，查看Rational的定义：</p><p>比率，R=\DATA。Ratio(&#34；a&#34；)==d.R(&#34；a&#34；，&#34；a&#34；)&amp；派生(Eq)Rational=t(Ratio，int)@sig(H/Rational&gt；&gt；Rational&gt；&gt；Rational)def addRational(rat1，rat2)：...。</p><p>模式匹配是一种比if语句更强大的控制流工具，可用于解构可迭代和ADT，并将值绑定到局部变量。</p><p>下面的函数使用模式匹配来计算fibonaccisequence。请注意，在模式匹配表达式中，m.*用于绑定变量，p.*用于访问它们。</p><p>Def fib(X)：return~(case of(X)|m(0)&gt；&gt；1|m(1)&gt；&gt；1|m(M.n)&gt；&gt；fib(P.n-1)+fib(p.n-2))&gt；&gt；fib(1)1&gt；&gt；fib(6)13。</p><p>如上面的示例所示，您可以毫不费力地组合模式匹配和递归函数。</p><p>您也可以使用^(cons运算符)解构一个迭代器。^之前的变量绑定到迭代的第一个元素，^之后的变量绑定到迭代的其余元素。下面是一个函数，它将任何可迭代的前两个元素相加，如果只有两个元素，则不返回任何内容：</p><p>@sig(H[(Num，&#34；a&#34；)]/[&#34；a&#34；]&gt；&gt；t(可能，&#34；a&#34；)def add_first_Two(Xs)：return~(caseof(Xs)|m(M.x^(M.y^M.z))&gt；&gt；Just(P.x+P.y)|m(M.x)&gt；&gt；无)&gt；&gt；&gt；Add_First_Two(L[1，2，3，4，5])仅(3)&gt；&gt；&gt；Add_First_Two(L[9.0])无。</p><p>模式匹配对于解构ADT并将其字段分配给临时变量也非常有用。</p><p>如果您发现ADT上的模式匹配太麻烦，您也可以在ADT字段上使用数字索引。如果你把事情搞砸了，就会抛出一个索引错误(IndexError)。</p><p>类型类允许您向ADT添加附加功能。Hask实现了Haskell的所有主要类型类(完整列表请参见附录)，并提供了用于创建新类型类实例的语法。</p><p>例如，让我们为“可能”类型添加一个Monad实例。但是，首先可能需要函数器和应用实例。</p><p>定义可能_FMAP(fn，x)：&#34；&#34；&#34；&#34；将函数应用于(可能是a)值&#34；&#34；&#34；返回~(caseof(X)|m(Nothing)&gt；&gt；Nothing|m(Just(M.x))&gt；&gt；Just(fn(p.x)实例(可能是函数器)。其中(FMAP=可能_FMAP)。</p><p>也许现在是函数器的一个实例。这允许我们调用fmap并将任何a-&gt；b类型的函数映射到可能是a类型的值。</p><p>&gt；&gt；&gt；Times2=(lambda x：x*2)**(H/int&gt；&gt；int)&gt；&gt；&gt；toFloat=Float**(H/int&gt；&gt；Float)&gt；&gt；FMAP(toFloat，Just(10))Just(10.0)&gt；&gt；FMAP(toFloat，FMAP(Times2，Just(25)Just(50.0)。</p><p>很多对FMAP的嵌套调用很快就变得笨拙起来。幸运的是，函数器的任何实例都可以与中缀FMAP操作符*一起使用。这相当于哈斯克尔中的&lt；$&gt；。从上面重写我们的示例：</p><p>请注意，本例同时使用*作为函数组合运算符和FMAP，以将函数提升为可能值。如果这看起来令人困惑，请记住函数的FMAP只是函数组合！</p><p>既然可能是Functor的一个实例，我们可以通过定义适当的函数实现，使其成为Applicative的实例，然后成为Monad的实例。要实现应用性，我们只需要提供纯净的。要实现Monad，我们需要提供绑定。</p><p>从Hask导入应用程序，Monad实例(可能是应用程序)。其中(纯=仅)实例(可能是Monad)。其中(bind=lambda x，f：~(case of(X)|m(Just(M.a))&gt；&gt；f(p.a)|m(Nothing)&gt；&gt；Nothing))。</p><p>@sig(H/int&gt；&gt；int&gt；&gt；t(可能，int))def safe_div(x，y)：如果y==0，则不返回任何内容，否则仅从Hask返回(x/y)&gt；&gt；。前奏导入翻转&gt；&gt；&gt；divBy=flip(Safe_Div)&gt；&gt；&gt；divBy(3)Just(3)&gt；&gt；&gt；divBy(2)&gt；&gt；divBy(3)Just(1)&gt；&gt；&gt；Just(12)&gt；divBy(2)&gt；&gt；divBy(3)Just(1)&gt；&gt；&gt；Just(12)&gt；&gt；divBy(0)&gt；&gt；divBy(6)无。</p><p>与在Haskell中一样，List也是一个monad，List类型的绑定只是connecatMap。</p><p>&gt；&gt；&gt；出自Hask。数据。LIST IMPORT REPLICATE&gt；&gt；L[1，2]&gt；&gt；Replicate(2)&gt；Replicate(2)L[1，1，1，1，2，2，2]。</p><p>类Person(Object)：def__init__(自我，姓名，年龄)：自我。名称=名称自我。Age=age实例(Eq，Person)。式中(eq=λp1，p2：p1。名称==p2。名称和p1。年龄==p2。年龄)&gt；&gt；&gt；人(&#34；Philip Wadler&#34；，59)==人(&#34；Simon Peyton Jones&#34；，57)false。</p><p>如果您的ADT需要Show、Eq、Read、Ord和BoundedType类的实例，建议使用派生自动生成实例，而不是手动定义它们。</p><p>定义您自己的类型类非常简单--看看Help(Typeclass)，看看在Data.Functor和Data.Num中定义的类型类，看看它是如何完成的。</p><p>Hask还支持操作员部分(例如，Haskell中的(1+))。节只是TypedFunc对象，因此它们会自动进行Currate和类型检查。</p><p>&gt；&gt；&gt；来自Hask import__&gt；&gt；&gt；f=(__-20)*(2**__)*(__+3)&gt；&gt；&gt；f(10)8172&gt；&gt；(90/__)*(10+_))*Just(20)Just(3)&gt；&gt；&gt；从哈斯克寄来的。数据。列出导入Take While&gt；&gt；&gt；Take While(__&lt；5，L[1，...])。L[1，2，3，4]&gt；&gt；&gt；(__+__)(&#39；Hello&#39；，&#39；world&#39；)&#39；Hello world&39；&gt；&gt；&gt；(_**__)(2)(10)1024&gt；&gt；来自Hask。数据。列出导入zipWith，Take&gt；&gt；&gt；Take(5)%zipWith(__*__，L[1，...]，L[1，...])。L[1，4，9，16，25]。</p><p>如您所见，这比使用lambda并使用(lambda x：...)**(H/...)添加类型签名要容易得多。语法。</p><p>此外，SECTIONS创建的TypedFuncs的类型总是多态的，以允许任何运算符重载。</p><p>请注意，如果您使用的是IPython，则Hask__将与IPython特别的双下划线变量冲突。为避免冲突，可以在IPython中使用from Hask import__as_s。</p><p>如果您不需要模式匹配的全部功能，而只需要一条neaterswitch语句，您可以使用卫士。警卫的语法几乎与模式匹配的语法相同。</p><p>与在Haskell中一样，否则将始终求值为True，并可用作保护表达式中的acatch-all。如果没有找到匹配项(并且不存在其他子句)，则将引发NoGuardMatchException。</p><p>&gt；&gt；&gt；来自Hask import Guard，c，否则&gt；&gt；&gt；粥_温度=80&gt；&gt；&gt；~(Guard(粥_温度)...。|c(__&lt；20)&gt；&#34；粥太凉！&#34；...|c(__&lt；90)&gt；&gt；&#34；粥正好！&#34；...|c(__&lt；150)&gt；&#34；粥太烫！&#34；...|否则&gt；&gt；&#34；粥已经变成热核粥了！&#39；粥恰到好处！&#39；</p><p>如果您需要更复杂的条件，您可以随时使用lambdas、RegularPython函数，或者在您的守卫条件中使用任何其他可调用的函数。</p><p>Def EXTEMPORD_PASSWORD_SECURITY(PASSWORD)：Analysis=~(Guard(Password)|c(lambda x：en(X)&gt；20)&gt；&34；哇，这是一个安全密码&#34；|c(lambda x：en(X)&lt；5)&&gt;&&gt;您让布鲁斯·施奈尔哭了&#34；|c(_==&#34；12345&#34；)&&gt;。与我的行李相同的组合！&#34；|否则&&gt;&&gt;&34；希望它&#39；不是密码&#39；密码&#39；&34；)退货分析&gt；&gt；&gt；核启动代码=&#34；12345&#34；&gt；&gt；检查_密码_安全(核启动代码)&#39；与我的行李的组合相同！&#39；</p><p>如果您想使用Maybe and One来处理由定义在Hask外部的PythonFunctions引发的错误，您可以使用_Maybe和In_One中的修饰符来创建调用原始函数的函数，并返回包装在Maybe或任意值中的结果。</p><p>如果包装在_中的函数可能引发异常，则包装的函数将不返回任何内容。否则，结果将被封装在Just中返回。</p><p>定义吃_奶酪(奶酪)：如果奶酪&lt；=0：提高值错误(&#34；超出奶酪错误&#34；)返回奶酪-1可能_吃=可能(吃_奶酪)&gt；&gt；&gt；可能_吃(1)只(0)&gt；&gt；&gt；可能_吃(0)什么都不返回。</p><p>请注意，这相当于将原始函数提升到Maybemonad中。也就是说，它的类型已经从函数更改为a-&gt；也许是b。这使得在现有的Python函数中更容易使用Haskell中常见的方便的Monad错误处理风格。</p><p>继续这个愚蠢的例子，让我们试着吃三块奶酪，如果尝试不成功，什么也不返回：</p><p>&gt；&gt；&gt；奶酪=10&gt；&gt；&gt；奶酪_Left=Just(奶酪)&gt；&gt；可能_Eat&gt；&gt；可能_Eat&gt；&gt；&gt；奶酪_Left Just(7)&gt；&gt；&gt；奶酪=1&gt；&gt；&gt；奶酪_Left=Just(奶酪)&gt；&gt；可能_Eat&gt；&gt；可能_Eat&gt；&gt；可能_Eat&gt；&gt；&gt；奶酪_什么也没留下</p><p>请注意，我们采用了抛出异常的常规Python函数，现在正在以类型安全的单行方式处理它。</p><p>这两个函数中的任何一个函数的工作方式都与in_be类似。如果抛出异常，包装函数将返回左侧包装的异常。否则，将返回右包装的结果。</p><p>Prelude、Data.List、Data.Maybe、Data.Other、Data.Monoid等您喜欢的所有函数也都实现了。每件事都有很好的文档记录，所以如果你对某些函数或类型类不太确定，可以随意使用帮助。有关模块的完整列表，请参阅下面的附录。一些亮点：</p><p>&gt；&gt；&gt；出自Hask。数据。可以从Hask导入mapMaybe&gt；&gt；&gt；mapMaybe(safe_div(12))%L[0，1，3，0，6]L[12，4，2]&gt；&gt；。数据。List import isInfix Of&gt；&gt；&gt；isInfix Of(L[2，8]，L[1，4，6，2，8，3，7])True&gt；&gt；&gt；from Hask。控制力。单项导入联接&&gt;；&&gt;；&gt；联接(Just(Just(1)Just(1)。</p><p>Hask还为__Builtins__中的所有内容提供了TypeFunc包装器，以便于兼容性。(最终，Hask将为大部分Python标准库提供类型化包装。)。</p><p>&gt；&gt；&gt；出自Hask。从Hask进口Flip&gt；&gt；&gt；前奏。数据。从Hask导入元组nd&gt；&gt；&gt；。蟒蛇。内置。</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/billpmurphy/hask">https://github.com/billpmurphy/hask</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/language/">#language</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1025394.html"><img src="http://img2.diglog.com/img/2020/9/thumb_67ed31338672dd1683f4fe590032ee50.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1025394.html">Python练习题：为下一次面试做好准备</a></div><span class="my_story_list_date">2020-9-22 2:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1025312.html"><img src="http://img2.diglog.com/img/2020/9/thumb_bcf94ba346d567aecdf73449ce32c4f6.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1025312.html">Sktime：用于时间序列机器学习的统一Python工具箱</a></div><span class="my_story_list_date">2020-9-21 19:54</span></div><div class="col-sm"><div><a target="_blank" href="/story/1024912.html"><img src="http://img2.diglog.com/img/2020/9/thumb_9bf1e687e7e3f7e1f2bbd1554eaafec3.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1024912.html">CadQuery：一个基于OCCT的Python参数化CAD脚本框架</a></div><span class="my_story_list_date">2020-9-19 3:15</span></div><div class="col-sm"><div><a target="_blank" href="/story/1024795.html"><img src="http://img2.diglog.com/img/2020/9/thumb_2671e44894df6b9621d0f6ed353eaf42.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1024795.html">Python 3.8中的类型注记</a></div><span class="my_story_list_date">2020-9-18 16:12</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>