<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>精益定理证明的回顾 A Review of the Lean Theorem Prover</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A Review of the Lean Theorem Prover<br/>精益定理证明的回顾 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-28 21:50:42</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/cf34829ef4e812aaac2f7281a7d63164.png"><img src="http://img2.diglog.com/img/2020/12/cf34829ef4e812aaac2f7281a7d63164.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I turned to  Lean when I started looking for a system with more foundational strength than  HOL-Light, a proof assistant I have been happily using for many years. HOL-Light is great at what it does (such as real and complex analysis), but it falls short in its treatment of big objects, such as the category of all sets.</p><p>当我开始寻找比HOL-Light更强大的基础系统时，我转向了Lean。HOL-Light是我多年来一直乐于使用的校对助手。 HOL-Light擅长于其工作（例如真实和复杂的分析），但在处理大型对象（例如所有集合的类别）方面却不足。</p><p> Both  Coq and Lean are based on the logical foundations of  CiC (calculus of inductive constructions). Unlike HOL, CiC can readily encode most structures in widespread use in mathematics.</p><p> Coq和Lean均基于CiC（归纳结构演算）的逻辑基础。与HOL不同，CiC可以轻松地对在数学中广泛使用的大多数结构进行编码。</p><p>  1. Lean  sounds wonderful:  open source, a small trusted kernel, a powerful elaboration engine including a Prolog-like algorithm for type-class resolution, multi-core support, incremental compilation, support for both constructive and classical mathematics,  successful projects in  homotopy type theory, excellent documentation, and a web browser interface.  Lean source files can be edited in Emacs, Visual Studio Code, or CoCalc.</p><p>  1.精益听起来很棒：开源，小的可信任内核，强大的精心制作引擎，包括类似于Prolog的用于类分类解析的算法，多核支持，增量编译，对构造和经典数学的支持，同构的成功项目类型理论，出色的文档和Web浏览器界面。精益源文件可以在Emacs，Visual Studio Code或CoCalc中进行编辑。</p><p> Lean seems to have learned from the past decade of research into the Coq system.</p><p> 精益似乎是从过去十年对Coq系统的研究中学到的。</p><p> 2. In more detail, a “ minimalist and high performance kernel” was an explicit goal of the Lean. Independent implementations of the kernel have been given ( Selsam in 2000 lines, etc.) alleviating any concerns about a bug in the C++ implementation of Lean.</p><p> 2.更详细地讲，“极简和高性能内核”是精益的明确目标。已经给出了内核的独立实现（Selsam在2000行中，等等），从而减轻了对Lean C ++实现中的错误的担忧。</p><p> 3. The semantics of Lean are now completely spelled out (thanks to  Mario Carneiro, building on  Werner). In particular, Carneiro has built a model of Lean’s logic (CiC with non-cumulative universes) in ZFC set theory (augmented by a countable number of inaccessible cardinals).</p><p> 3.现在，已经完全阐明了“精益”的语义（这要感谢基于Werner的Mario Carneiro）。特别是，卡内罗（Carneiro）在ZFC集合论中建立了精益逻辑模型（具有非累积性Universe的CiC）（通过数量众多的难以接近的基数来增强）。</p><p> 4. Lean has a clean syntax. For example, to add two elements in an abelian group, one can simply write  x+y and Lean correctly infers the group in which the addition is to be performed. I have more to say about Lean’s syntax later.</p><p> 4.精益语法干净。例如，要在一个阿贝尔群中添加两个元素，一个元素可以简单地写x + y，而精益正确地推断出要在其中进行相加的组。稍后，我还有更多要讲的精益语法。 </p><p> 5. Lean makes it easy to switch from constructive to classical logic (you just open the  classical logic module). Lean makes quotient types easy (unlike Coq, when tends to work with awkward setoids).</p><p>5.精益使您可以轻松地从构造逻辑转换为经典逻辑（只需打开经典逻辑模块）。精益使商类型变得容易（与Coq不同，后者倾向于使用笨拙的setoid）。</p><p> 6. Lean is its own meta language. I find this very appealing. Contrast this with HOL-Light, which has OCaml as meta-language or Coq which has a domain-specific language Ltac for tactics.</p><p> 6.精益是它自己的元语言。我觉得这很吸引人。与此形成对比的是HOL-Light，后者将OCaml作为元语言，而Coq则具有针对战术的领域专用语言Ltac。</p><p> 7. Finally, there was a personal reason. Carnegie-Mellon University is a center of Lean library development. I live in Pittsburgh and am a regular participant in CMU’s Lean group meetings.</p><p> 7.最后，有个人原因。卡内基-梅隆大学是精益图书馆发展的中心。我住在匹兹堡，并且经常参加CMU的精益小组会议。</p><p>  1. The kernel is bloated. Specifically, from what I hear, for performance reasons, mutually inductive types will soon be moved into the kernel. This destroys the former claims of a minimalist kernel.</p><p>  1.内核is肿。具体而言，据我所知，出于性能原因，互归类型将很快移入内核。这破坏了极简内核的先前主张。</p><p> 2. Lean is not backwards compatible. Lean 3 broke the Lean 2 libraries, and old libraries still haven’t been ported to Lean 3. After nearly 2 years, it doesn’t look like that will ever happen. Instead new libraries are being built at great cost. Lean 4 is guaranteed to break the Lean 3 libraries when it arrives.  In short, Lean is experimental, evolving, and unstable.</p><p> 2.精益不向后兼容。精益3打破了精益2的库，并且旧库仍未移植到精益3。在将近两年之后，这种情况似乎永远不会发生。取而代之的是，新图书馆的建造成本很高。精益4保证在精益3库到达时就打破它。简而言之，精益是实验性的，不断发展的且不稳定的。</p><p> 3. The learning curve is steep. It is  very hard to learn to use Lean proficiently. Are you a graduate student at Stanford, CMU, or Pitt writing a thesis on Lean? Are you a student at Imperial being guided by Kevin Buzzard? If not, Lean might not be for you.</p><p> 3.学习曲线陡峭。学会熟练使用精益是非常困难的。您是斯坦福大学，CMU或Pitt的研究生吗？您是凯文·巴扎德（Imperial Buzzard）指导下的Imperial大学学生吗？如果没有，精益可能不适合您。</p><p> 4. Lean is its own metalanguage. Lean is new, and the language libraries are almost nonexistent.  Hardly any major programs have been written in Lean.   Java programmers outnumber Lean programmers by a million to one.  To first approximation, it is impossible to do any serious programming in Lean.</p><p> 4.精益是自己的语言。精益是新的，语言库几乎不存在。几乎没有任何主要程序是用精益编写的。 Java程序员比精益程序员大一百万。首先，在Lean中不可能进行任何认真的编程。 </p><p> I miss HOL-Light, whose metalanguage is an established programming language (OCaml) with large supporting libraries. Whenever I needed a tactic, I just sat down and wrote it in OCaml. I can’t do this in Lean, and it is  extremely frustrating to work in a environment that is not equipped for serious programming.</p><p>我想念HOL-Light，他的语言是一种成熟的编程语言（OCaml），带有大型支持库。每当我需要战术时，我就坐下来用OCaml编写。我在精益开发中无法做到这一点，并且在无法进行认真编程的环境中工作非常令人沮丧。</p><p> In fact, I could live with almost all my other criticisms, if I could write my own code in Lean to fix what I don’t like. I have discussed Lean programming issues with experts, and the tools simply are not available.</p><p> 实际上，如果我可以用精益编写自己的代码来解决我不喜欢的问题，那么我几乎可以接受所有其他批评。我已经与专家讨论了精益编程问题，这些工具根本不可用。</p><p> 5. Typing in Lean is  nominal rather than structural.  As a mathematician and OCaml programmer, I would have preferred design decisions that favor a structural approach.  Mathematicians are used to working in set theory, and decisions should be made that push the type theory to be more set-like, by making types more interoperable.</p><p> 5.精益打字是名义上的，而非结构性的。作为数学家和OCaml程序员，我会偏向于倾向于结构化方法的设计决策。数学家习惯于使用集合论，并且应该做出决策，通过使类型更可互操作来推动类型论变得更像集合。</p><p> 6. There are performance issues. It is not clear (to me or perhaps even to anyone) why performance is such a big problem, because Lean was implemented in C++ for the sake of performance. However in fact, the compilation of the math libraries is currently very slow. Something is wrong here.</p><p> 6.存在性能问题。 （对我，甚至对任何人）尚不清楚为什么性能如此大的问题，因为Lean是为实现性能而用C ++实现的。但是实际上，数学库的编译当前非常缓慢。这里不对劲。</p><p> 7. Ugly projection chains are required. Consider the definition of semigroup (a mathematical structure with an associative binary operation)</p><p> 7.需要丑陋的投影链。考虑半群的定义（具有关联二进制运算的数学结构）</p><p> universe u class semigroup (α : Type u) extends has_mul α := (mul_assoc : ∀ a b c : α, a * b * c = a * (b * c))</p><p> 宇宙u类半群（α：类型u）扩展has_mulα：=（mul_assoc：∀a b c：α，a * b * c = a *（b * c））</p><p> This looks simple enough, and it has an appealing syntax that allows the symbol  * to be used for multiplication because the class extends  has_mul. However, the elaborator expands this into something ugly</p><p> 这看起来很简单，并且具有吸引人的语法，因为该类扩展了has_mul，因此允许将符号*用于乘法。但是，细化者将其扩展为丑陋的东西 </p><p> @[class, priority 100] structure semigroup : Type u → Type u fields: semigroup.mul : Π {α : Type u} [c : semigroup α], α → α → α semigroup.mul_assoc : ∀ {α : Type u} [c : semigroup α] (a b c_1 : α), @eq α (@has_mul.mul α (@has_mul.mk α (@semigroup.mul α c)) (@has_mul.mul α (@has_mul.mk α (@semigroup.mul α c)) a b) c_1) (@has_mul.mul α (@has_mul.mk α (@semigroup.mul α c)) a (@has_mul.mul α (@has_mul.mk α (@semigroup.mul α c)) b c_1))</p><p>@ [类，优先级100]结构semigroup：类型u→类型u字段：semigroup.mul：{{α：类型u} [c：半组α]，α→α→αsemigroup.mul_assoc：∀{α：类型u } [c：半群α]（ab c_1：α），@ eqα（@ has_mul.mulα（@ has_mul.mkα（@ semigroup.mulαc）））（@ has_mul.mulα（@ has_mul.mkα （@ semigroup.mulαc））ab）c_1）（@ has_mul.mulα（@ has_mul.mkα（@ semigroup.mulαc））a（@ has_mul.mulα（@ has_mul.mkα（@semigroup .mulαc））b c_1））</p><p> Every time the multiplication symbol is used, the semigroup is explicitly converted to another structure  has_mul, which is responsible for handling the multiplication.</p><p> 每次使用乘法符号时，半群都将显式转换为另一个结构has_mul，该结构负责处理乘法。</p><p> I have intentionally selected a very simple example. Things are much much worse when you look at the ugly expansions of a more complicated mathematical structure (such as an ordered ring).</p><p> 我特意选择了一个非常简单的示例。当您看一看更复杂的数学结构（例如有序环）的丑陋扩展时，情况会变得更加糟糕。</p><p> 8. Structure depends on notation. Lean has a library of results about multiplicative groups and a separate library of results about additive groups. The only difference is that one uses the symbol  * for the group operation and the other uses the symbol  + for the group operation. Mathematician find it absurd that the theorems in group theory have been made to depend on the symbol used for composition.</p><p> 8.结构取决于符号。精益有一个关于乘法组的结果库和一个独立的关于加性组的结果库。唯一的区别是，一个使用符号*进行分组操作，另一个使用符号+进行分组操作。数学家发现使群论中的定理依赖于用于合成的符号是荒谬的。</p><p> The problem grows worse in structures that depend on groups. For example, there are four types of products of two groups, because the first factor can be either a  +-group or a  *-group and the second factor can also be either of the two.</p><p> 在依赖群体的结构中，问题变得更加严重。例如，有两种类型的两组乘积，因为第一个因子可以是+-组或*-组，第二个因子也可以是两者中的任一个。</p><p> There is an interesting history behind this design flaw.  Originally, type classes were introduced into functional languages to make  ad hoc polymorphism less ad hoc. What started as a way to clean up operator overloading notation, ended up welding notation to structures where it is not welcome.</p><p> 这个设计缺陷背后有一段有趣的历史。最初，类型类被引入功能语言中，以减少即席多态性。最初是清除操作员超载符号的一种方法，最后是将焊接符号焊接到不受欢迎的结构上。</p><p> 9. No  diamonds are allowed. From a programming language point of view, I understand the issues surrounding diamonds. However, for mathematicians, diamonds are extremely natural and they occur in great abundance under many names (pullbacks, fibered products, Cartesian squares, etc.). It seems to me that a system designed for doing mathematics should do more than just declare them illegal.</p><p> 9.禁止携带钻石。从编程语言的角度来看，我了解与钻石有关的问题。但是，对于数学家来说，钻石是极其天然的，并且以很多名称（回弹，纤维产品，笛卡尔方等）大量出现。在我看来，设计用于数学的系统所要做的不只是宣布它们为非法。 </p><p> Read the  full discussion that led to the diamond ban, where it argued (unpersuasively) that even though the algebra library used diamonds “in many different places,” the ban would only “be a minor annoyance.” In fact, I find it to be a major impediment. I’m told that I can just give my own implementation of classes with diamonds, but see item 4 above — I effectively have no computer language to use for this.</p><p>阅读导致钻石禁令的完整讨论，在辩论中（毫无说服力地）指出，即使代数图书馆在许多地方都使用钻石，但该禁令只会``成为一个小麻烦''。实际上，我认为这是一个主要障碍。有人告诉我，我只能给出自己的带有菱形的类的实现，但是请参见上面的第4项-实际上，我没有计算机语言可用于此目的。</p><p> 10. Structures are meaninglessly parameterized from a mathematical perspective. To briefly introduce the topic of parameters and bundling, users choose whether data appears as an external parameter. Here is an example of  magma, both in parametric and bundled form</p><p> 10.从数学的角度来看，结构是毫无意义的参数化。为了简要介绍参数和捆绑的主题，用户选择数据是否作为外部参数出现。这是参数和捆绑形式的岩浆示例</p><p> structure magma_with_parameter (α : Type*) := (op : α → α → α) structure magma_bundled := (α : Type*) (op : α → α → α)</p><p> 结构magma_with_parameter（α：Type *）：=（op：α→α→α）结构magma_bundled：=（α：Type *）（op：α→α→α）</p><p> I think of the parametric versus bundled variants as analogous to currying or not; are the arguments to a function presented in succession or as a single ordered tuple? However, there is a big difference between currying functions and currying structures. Switching between curried and uncurried functions is cheap, but it is nearly impossible in Lean to  curry a structure. That is, what is bundled cannot be later opened up as a parameter. (Going the other direction towards increased bundling of structures is easily achieved with sigma types.) This means that library designers are forced to take a conservative approach and expose as a parameter anything that any user might reasonably want exposed, because once it is bundled, it is not coming back.</p><p> 我认为参数化或捆绑式变体类似于或不类似于柯里化；函数的参数是连续显示还是作为单个有序元组显示？但是，currying函数和currying结构之间存在很大差异。在咖喱函数和非咖喱函数之间切换很便宜，但是精益几乎不可能咖喱一个结构。即，捆绑的内容以后无法作为参数打开。 （使用sigma类型可以很容易地朝着增加结构捆绑的方向发展。）这意味着库设计师被迫采取保守的方法，并公开任何用户可能希望公开的任何内容作为参数，因为一旦捆绑，它不会回来。</p><p> Mathematicians tend to be flexible about what information they choose to expose about a structure, according to whatever information is relevant to the given context. They don’t want a predetermined bundling decision that is hard-wired into the libraries.</p><p> 根据与给定上下文相关的任何信息，数学家倾向于灵活地选择公开哪些信息。他们不希望将硬捆绑到库中的预定捆绑决策。</p><p> How are Lean structures meaninglessly parametrized? As an illustration, the type  α : Type* of the underlying carrier of the group is passed as a parameter (as in the  magma_with_parameter example above). For a mathematician this is entirely meaningless information that is passed as a parameter. Who cares about the particularities of the underlying set of the group? What matters is the group structure. A mathematician says, let  G be a group, but never let α be a set and let  G be a group constructed on carrier α. Lean requires the user to give both α and  G every damn time. Other language designers fight on behalf of the users to  save them keystrokes and boilerplate. I expect the same from Lean.</p><p> 精益结构如何无意义地参数化？作为说明，该组的基础载波的类型α：Type *作为参数传递（如上述magma_with_parameter示例中所示）。对于数学家来说，这完全是毫无意义的信息，它作为参数传递。谁在乎该基础组的特殊性？重要的是小组的结构。数学家说，令G为群，但绝不让α为集合，而令G为在载体α上构造的群。精益要求用户在每该死的时间都给α和G。其他语言设计师则代表用户奋斗，以节省他们的按键和样板。我希望精益也一样。</p><p> This gets worse as the algebraic structures grow in complexity. You cannot just say, let  M be a topological module of a topological ring  R. I count 7 different structures that first have to be explicitly declared every time a topological module is introduced in Lean. This is intolerable. I haven’t made the count for tensor products of topological bi-modules, but you get the idea. And in case you are wondering, yes, mathematicians do  take tensor products of topological bi-modules.</p><p> 随着代数结构的复杂性增加，情况变得更糟。您不能只是说，让M为拓扑环R的拓扑模块。我计算7种不同的结构，每次在Lean中引入拓扑模块时都必须首先明确声明。这是无法忍受的。我还没有计算拓扑双模的张量积，但您明白了。如果您想知道，是的，数学家会采用拓扑双模的张量积。 </p><p> (Lean does it this way for a reason: it uses the exposed parameter α as an index for type-class resolution, as a cheap way to avoid diamonds, etc. But why should mathematicians be forced to wander into Lean internals?)</p><p>（精益之所以这样做是有原因的：它使用暴露的参数α作为类型分类解析的索引，作为避免钻石的廉价方法，等等。但是为什么要强迫数学家进入精益内部？</p><p> 11. Lean discards valuable information that is later reconstructed (at a cost) by its type class resolution engine.</p><p> 11.精益舍弃了有价值的信息，这些信息随后将由其类型类解析引擎重建（以成本为代价）。</p><p> For example, we write  G:group α in Lean to say that  G is a group with carrier α. Then, when we write the associative law,  ∀ (x y z : α), x * y * z = x * (y * z), valuable information is lost because all typing information refers to the carrier α instead of the group  G, so Lean must hunt around for a group  G associated with the raw type α.</p><p> 例如，我们在Lean中写G：groupα表示G是一个带有载波α的组。然后，当我们写关联定律x（xyz：α），x * y * z = x *（y * z）时，有价值的信息会丢失，因为所有类型信息都指向载体α而不是组G，所以精益必须寻找与原始类型α相关的G组。</p><p> If there are two groups on the same underlying carrier (which happens for example with semi-direct products), then Lean gives unpredictable results. There is a way to set priorities here, but that is not advised, because these settings have global scope.</p><p> 如果同一基础载体上有两个组（例如发生在半直接产品上），那么精益将给出不可预测的结果。这里有一种设置优先级的方法，但是不建议这样做，因为这些设置具有全局范围。</p><p>  ∀ (x y z : G), x * y * z = x * (y * z).</p><p>  ∀（x y z：G），x * y * z = x *（y * z）。</p><p> The difference with Lean might appear small, but now the statement has not discarded the group  G and we do not have to hunt for it. Since  G is not a type,  z : G coerces to  z : G.carrier, or more verbosely,  z : group.carrier G, and the group is still visible.</p><p> 与精益的区别可能很小，但现在该语句尚未丢弃G组，我们也不必寻找它。由于G不是类型，因此z：G强制转换为z：G.carrier，或更详细地说，z：group.carrier G，并且该组仍然可见。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/">https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/定理/">#定理</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lean/">#lean</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/精益/">#精益</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>