<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Emacs和PostgreSQL上运行面包店 Running a Bakery on Emacs and PostgreSQL</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Running a Bakery on Emacs and PostgreSQL<br/>在Emacs和PostgreSQL上运行面包店 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-22 02:16:54</div><div class="page_narrow text-break page_content"><p>Just over a year ago now, I finally opened the bakery I’d been dreaming of for years. It’s been a big change in my life, from spending all my time sat in front of a computer, to spending most of it making actual stuff. And stuff that makes people happy, at that. It’s been a huge change, but I can’t think of a single job change that’s ever made me as happy as this one.</p><p>就在一年前，我终于开了面包店，我一直在梦想多年。我生命中的一大大变化，从一整个时间坐在电脑前，到了大部分它做实际的东西。和让人开心的东西。这是一个巨大的变化，但我想不出一项工作变化，让我像这个一样快乐。</p><p> One of the big changes that came with going pro was that suddenly I was having to work out how much stuff I needed to mix to fill the orders I needed. On the face of it, this is really simple, just work out how much dough you need, then work out what quantities to mix to make that much dough. Easy. You can do it with a pencil and paper. Or, in traditional bakers&#39; fashion, by scrawling with your finger on a floured work bench.</p><p> Pro的一个大变化之一是，突然，我必须努力解决我需要多少钱，以填补我需要的订单。面对它，这真的很简单，只是制定你需要多少面团，然后解决一定量的混合来制作那么多面团。简单。你可以用铅笔和纸。或者，在传统的面包师＆＃39;时尚，通过用手指潦草地滚动在面粉的工作台上。</p><p> And that’s how I coped for a few weeks early on. But I kept making mistakes, which makes for an inconsistent product (bread is very forgiving, you have to work quite hard to make something that isn’t bread, but consistency  matters). I needed to automate.</p><p> 这就是我如何提前几周被调配。但我一直犯错误，这使得产品不一致（面包非常宽容，你必须很难做出不是面包的东西，而是一致的事情）。我需要自动化。</p><p> I’d been on one of Bread Matters&#39; “Baking for a Living” courses and as part of the course materials had received a copy of a spreadsheet that could be used to go from a list of orders to a list of ingredients to mix alongside accurate costings and other useful bits and bobs. It was great and certainly opened my eyes to the possibilities for automation of this part of the job.</p><p> 我一直在面包之一和＃39; “为谋生”课程，作为课程材料的一部分，已经收到了一份电子表格的副本，这些电子表格可用于从订单列表中获取成分列表，以便与准确的成品和其他有用的位和鲍勃混合。它很棒，当然睁开眼睛对这部分工作的自动化的可能性。</p><p>  Spreadsheets aren’t my favourite computational model so maybe it was just my lack of experience with them, but adding a new recipe was like pulling teeth; lots of tedious copying, pasting and repetition of formulae. It just seemed wrong, especially as the underlying computations were so straightforward (ish). There had to be a better way.</p><p>  电子表格不是我最喜欢的计算模型，所以也许这只是我对他们的经验，但是增加了一个新的食谱就像拉牙;许多乏味的复制，粘贴和重复公式。它似乎是错误的，特别是因为底层计算非常简单（ISH）。必须有更好的方法。</p><p> The key insight is that a bakery formula is so cliched that it can be represented as data. Here’s the formula for seedy malt loaves:</p><p> 关键洞察力是面包店公式如此陈述，它可以表示为数据。这是Seefy Malt Loaves的公式：</p><p>  Of course, that’s not the full set of formulae, because it doesn’t tell you how to make ‘Seedy malt dough’, but that’s just another formula, which consists of flour, water, starter, salt and a multiseed ‘soaker’, where the starter and the soaker are the results of other formulae, which are (finally) made from basic ingredients With a certain amount of handwaving to deal with the fact that a starter is strictly made with flour, water and starter.</p><p>  当然，这不是全套公式，因为它没有告诉你如何制作“种子麦芽面团”，但这只是另一个配方，它由面粉，水，起动器，盐和多功能的“浸入者”组成，起动器和浸泡剂是其他配方的结果，其（最后）由具有一定量掌控的基本成分制成，以处理起动器严格用面粉，水和起动器进行起动器。 </p><p>. I did consider reaching for the object oriented hammer at this point, but thought that I might be able to do everything I needed without leaving SQL. It was relatively straightforward to move the shape of the calculations in the Bread Matters spreadsheet into my database schema, the only real sticking point being the recursive nature of the formulae, but it turns out that recursive queries are a thing in modern SQL, albeit a little tricky to get absolutely right first time.</p><p>。我确实考虑在这一点上达到面向对象的锤子，但以为我可能能够在不离开SQL的情况下完成我需要的一切。将诸如数据库模式中的计算事项的计算形状移动到我的数据库模式相对简单，这是唯一真正的粘附点是公式的递归性，但事实证明，递归查询是现代SQL中的一件事，尽管是一个一点棘手，绝对是正确的第一次。</p><p> If you’re curious And several of you seem to be, so I wrote  another post with a bit more detail and some sample code.</p><p> 如果你很好奇，你们的几个似乎是，所以我写了另一个帖子，更详细地有一些细节和一些示例代码。</p><p>about the details of the schema, you can find it in my  github repo for the bakery.</p><p>关于架构的细节，您可以在我的Github回购中找到它的面包店。</p><p> So now, a few days before a bake, I’d setup my  production_order table with the orders for the bake, and run a query on the  production_list view to find out what I needed to mix when. And all was great. Well, sort of. I had to add a bit extra onto the quantities in the initial starter mix to allow for the bits that get stuck to the bowl and lost to the final dough, and it was all very well until I wanted to bake two days in a row (a bake is a two day process from mixing the starters on a Wednesday evening, through mixing, fermenting and shaping on Thursday to baking the resulting loaves at four on Friday morning). But, vitally, it was much, much easier to add and adjust formulae, and the limitations were no worse than the limitations of the spreadsheet. All was well.</p><p> 所以现在，烘焙前几天，我将我的Production_order表设置了烘焙的订单，并在Production_List视图上运行查询，以了解我需要的时间。一切都很棒。好吧，有点。我不得不在初始启动器混合中添加一点额外的数量，以允许粘在碗上并丢失到最后的面团的比特，并且一切都很好，直到我想连续两天烘烤（烘烤是一项两天的过程，通过在周三晚上将初学者混合，通过周四混合，发酵和塑造，在周五早上四个烘焙所产生的大面积）。但是，最重要的是，添加和调整公式更容易，并且局限性比电子表格的局限性更差。一切都好。</p><p> It’s the nature of business that you need to keep records. How much got baked? How much sold? Did we clean the floor? Were there any accidents? What sort? How do we prevent them next time? The list is endless. It all needs to be recorded, for both legal and pragmatic reasons. So I started a day book. This is just an .org file Org-mode is an amazing emacs package that’s a sort of outliner/task manager/publishing tool/spreadsheet/diary/literate programming environment. It’s bewilderingly capable, and is probably the primary driver of the emacs renaissance as people are coming to the editor for org-mode, and porting the rest of their environment - hence the rise of  evil-mode, the emacs vim emulation layer.</p><p> 这是您需要保留记录的业务的性质。烤了多少钱？卖多少钱？我们清洁地板吗？有什么事故吗？什么样的？我们下次如何防止他们？列表是无穷无尽的。所有这些都需要记录，以便有法律和务实的原因。所以我开始了一天的书。这只是一个.org文件org-mode是一个惊人的emacs包，它是一种outliner / task manager /发布工具/电子表格/日记/识字编程环境。这是令人困惑的能力，可能是emacs文艺复兴的主要驾驶员，因为人们来到编辑的组织模式，并搬到其余的环境 - 因此邪恶模式的崛起，Emacs Vim仿真层。</p><p>. Every day I come into the bakery, I run  org-capture and I get a template for the day’s entry in the daybook, which I fill in as the day goes on.</p><p>。每天我都进入面包店，我跑了Org-Capture，我在白天进入的那一天的一个模板，我填写了这一天。</p><p> One of the features of org-mode is  org-babel, a literate programming environment, which lets me write something like:</p><p> Org-Mode的一个特征是org-babel，一个识字的编程环境，让我写的东西： </p><p>  and then, with the cursor somewhere in the code block, hit  C-c C-c whereupon Emacs will run that SQL against the bakery database and populate a table like:</p><p>然后，在代码块中的某个地方的光标中，点击C-C C-C，于是将该SQL运行该SQL对面包店数据库并填充桌子：</p><p>  If that were all org-mode did to assist, it’d be awesome enough, but the queries I make are a little more complex than that, the current version of the database understands about dates and can cope with overlapping bakes, but all that makes the queries a little more complex. Org-mode helps with that too, because I can file away snippets of code in a ‘library of babel’ and just reference them from the daybook. And I can set arbitrary variables at any point in the hierarchy of the document.</p><p>  如果这是所有的组织模式来协助，它就足够了，但是我所做的查询比这更复杂，数据库的当前版本了解日期，可以应对重叠的烘焙，但所有这些让查询更加复杂。 ORG模式也有助于它，因为我可以在'Babel库'中提交代码片段，并仅从日本中引用它们。并且我可以在文档的层次结构中的任何点处设置任意变量。</p><p> So I have a bit of code in my emacs config that tweaks the day’s entry in a daybook like so:</p><p> 所以我在我的Emacs Config中有一点代码，在那样调整日常的日期条目，如下所示：</p><p> (defun pdc//in-bakery-daybook? ()  &#34;Are we in the bakery daybook?&#34; ( equal ( buffer-name)  &#34;CAPTURE-loafery-daybook.org&#34;)) (defun pdc/set-daybook-entry-properties ()  &#34;Set the properties we rely on in our boilerplated daybook queries&#34; (save-excursion (while (not ( looking-at  &#34;*+ [[:digit:]]\\{4\\}\\(-[[:digit:]]\\{2\\}\\)\\{2\\}&#34;)) (org-up-element)) (let ((entry-date (first (s-split  &#34; &#34; (org-entry-get ( point)  &#34;ITEM&#34;))))) (org-entry-put ( point)  &#34;header-args+&#34; ( format  &#34;:var work_date=\&#34;&#39;%s&#39;\&#34;&#34; entry-date))) (org-babel-execute-subtree))) (defun pdc/org-capture-before-finalize-daybook-entry () (when (pdc//in-bakery-daybook?) (pdc/set-daybook-entry-properties))) (add-hook  &#39;org-capture-before-finalize-hook  #&#39;pdc/org-capture-before-finalize-daybook-entry)</p><p> （Defun PDC // In-Bakery-Daybook？（）＆＃34;我们在面包店日书吗？＆＃34;（平等（缓冲区名称）＆＃34; capture-loafery-daybook.org＆＃34;） ）（defun pdc / set-waybook-rent-properties（）＆＃34;设置我们依赖于我们的锅炉化的日本查询＆＃34的属性;（保存 - 游览（而不是（看 - ＆＃34; * + [：数字：]] \\ {4 \\} \\（ -  [[[[[[[[[[[[：DIGIT：]] \\ {2 \\} \\）\\ {2 \\}＆＃34;））（组织-UP-ELEMENT））（设（进入日期（第一个（S-SPLINT＆＃34;＆＃34;（ORG-RENTS-GET（POINT）＆＃34;项目＆＃34;））））））））））））））））））））（组织进入（点）＆＃34;标题args +＆＃34;（格式＆＃34;：var work_date = \＆＃34;＆＃39;％s＆＃39; \＆＃34;＆ ＃34;入场日期）））（org-babel-execute-subtreree）））（defun pdc / rg-capture-pressize-daybook-ress（）（当（pdc // in-bakery-waybook？） （PDC / SET-DOITBOOK-RESTER-PROPURATION）））（添加挂钩＆＃39;组织 - 捕获前 -  FINALIZE-HOOK＃＆＃39; PDC / ORG-CAPTURE- FINALIZE-DAYBOCK-REST之前）</p><p> It won’t win any code beauty contests, but it does the job of setting a  work_date variable for the day’s entry and running any code in the subtree as part of the capture process. The capture template has lines like  #+call:mixes(), which call the stored code snippets, that reference the variable set in the current subtree and so make the query for the right day. This means that all I have to do to know what I should be doing when I get into the bakehouse is to run an org-capture and check the resulting entry in my daybook. Provided, that is, that I’ve added the appropriate rows to the database.</p><p> 它不会赢得任何代码美容竞赛，但它可以为日期的条目设置工作_date变量并将子树中的任何代码作为捕获过程的一部分进行。捕获模板具有像＃+呼叫：MIXES（）调用存储的代码片段的线条，该方法引用当前子树中的变量设置，因此为正确的日期进行查询。这意味着当我进入烤棚时，我必须要做的就是要做什么我应该做的事情是运行一个组织捕获并检查我的日常书中的结果。提供了，即，已将适当的行添加到数据库。</p><p>  The software isn’t done, of course, no software ever is. But it’s good enough that it’s been managing my mixes without a hitch for the last few months, telling me what to pack for which customer and generally removing the need to work anything out with a pencil and paper. It’s nowhere near as mature or capable of commercial production management software, but it fits me. I understand what it does and why, how it does it, the limitations it has and how to work around them. When it becomes annoying enough, I might sit down and work out how to fix it, but I’ll do that when I’m in the right frame of mind. My current list of niggles looks something like this:</p><p>  当然，该软件没有完成，没有任何软件。但它足以让它在过去几个月里没有挂钩的情况下管理我的混合物，告诉我该包怎样用铅笔和纸张用铅笔打包。它无处可行，靠近商业生产管理软件，但它适合我。我明白它做了什么以及为什么，它是如何做到的，它具有的局限性以及如何解决它们。当它变得足够烦人时，我可能会坐下来解决如何解决它，但是当我在正确的心态时，我会这样做。我目前的niggles列表看起来像这样：</p><p> The database already knows how to do costings based on raw ingredient costs etc, but I should probably be able to use it to keep my books as well, using  org-ledger</p><p> 该数据库已经知道如何基于原始成分成本等成本核算，但我可能能够使用它来保留我的书籍，使用Org-Ledger </p><p>  At a certain point, it becomes easier to mix a ‘stiff starter’ in my mixer than it is to just mix the usual wet starter by hand. This breakpoint comes at around 3kg of flour. Right now, I manage this by looking at the mixes for my starters and, if it looks like a lot, changing the order to use 2-stage versions of the formulae and running the query again. I think it should be possible to automate this through a more sophisticated query, but I need to work that out.</p><p>在某种程度上，在我的混合器中将“硬起动器”混合比它用手混合在一起混合。这个断点来自面粉约3千克。现在，我通过查看我的初学者的混音来管理这一点，如果看起来很多，更改命令使用2级版本的公式并再次运行查询。我认为应该可以通过更复杂的查询自动化这一点，但我需要解决这个问题。</p><p>  things get weird if a batch of dough would be more than I can mix in a single go. Right now there are other physical limitations that mean that I simply can’t make that much bread anyway, but once I get a few more bannetons and racks, this will become a much more pressing issue.</p><p>  如果一批面团比我可以单独混合，事情会变得奇怪。现在有其他身体限制意味着我根本无法制作那么多面包，但一旦我得到了更多的Bannetons和Racks，这将成为一个更加紧迫的问题。</p><p>  Right now, I manage orders through Postico talking to the database, which is okay, but a little frustrating in places. An autocompleting environment for orders within emacs would be a much neater way to manage things.</p><p>  现在，我通过Postico管理订单与数据库交谈，这没关系，但在地方有点令人沮丧。在EMACS中的订单的自动完成环境将是一种用于管理事物的人。</p><p>  Computers are amazing. They are versatile tools even if you don’t know how to program them, because there’s almost always an app for what you want, or something close enough that you cant work around its infelicities. It’s quite remarkable the things that folks can do with their kit with no programming skill at all.</p><p>  计算机很棒。它们是多功能的工具，即使您不知道如何编程它们，因为几乎总是一个应用程序对于您想要的东西，或者您无法围绕其侵扰性努力工作。这对人们能够与他们的套件有关的事情是非常显着的。</p><p> But… learn to program, and a whole other vista of possibility opens up to you. With good programmable tooling you’re only really limited by your skill and understanding. Instead of accommodating yourself to your software, you can accommodate your software to you, and make the right functionality trade-offs for you. There’s a brilliant commercial piece of music looping sofware I use that could be massively more brilliant if there were a way of picking up the tempo automatically from the first recorded loop - it would free me from having to sing to a click and generally make the whole process easier. The developers have other (understandable) priorities, like porting the app to windows. And they’re not wrong to do so. There were folk clamoring for a windows version, and if a developer isn’t making money from a commercial application, then development will stop. I’m definitely not complaining, the feature is not so dramatically necessary that I’m prepared to spend the time learning how to do real time music programming in order to implement it, but if I want software to dance to  my tune then doing it myself is the only way.</p><p> 但是......学会编程，并且整个其他可能性的vista打开给你。具有良好的可编程工具，您只能受到您的技能和理解的限制。您可以将您的软件容纳您的软件，而不是为您提供适应您的软件，并为您提供正确的功能权衡。有一个辉煌的商业循环软件循环软件软件，我使用这可能是巨大的辉煌，如果有一种从第一个录制的循环自动拾取速度的方式 - 它会释放我不得不唱歌点击，一般都是整体过程更容易。开发人员具有其他（可理解的）优先级，如将应用程序移植到Windows。他们这样做并没有错。 Windows版本有民间吵闹，如果开发人员没有从商业应用程序赚钱，那么开发将停止。我肯定没有抱怨，这个功能并不是如此急剧上，我准备花时间学习如何做出如何做实时音乐编程来实现它，但如果我想软件跳舞，那么这样做我自己是唯一的方法。</p><p> So… choose tools that let you program them. I choose emacs and PostgreSQL, you might choose vim and SQLite or Atom and a NoSQL database, or you might just live in your Smalltalk image. Once you start to see your computing environment as truly soft and malleable, you can do amazing things, assisted by a computer that is truly  yours.</p><p> 所以...选择让您编程的工具。我选择Emacs和PostgreSQL，您可能会选择Vim和SQLite或Atom和NoSQL数据库，或者您可能只在您的SmallTalk图像中居住。一旦您开始将计算环境视为真正的柔软和可延展性，您可以做令人惊叹的事情，由真正为您的计算机辅助。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bofh.org.uk/2019/02/25/baking-with-emacs/">https://bofh.org.uk/2019/02/25/baking-with-emacs/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/emacs/">#emacs</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bakery/">#bakery</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/org/">#org</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>