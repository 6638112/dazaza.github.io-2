<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>比JSON好吗？</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">比JSON好吗？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-24 07:28:35</div><div class="page_narrow text-break page_content"><p>I want to take a brief look at various data serialization formats and compare them. Basically the goal is to answer the question, “can we find something better than JSON?” However, note that we are looking at these things for DATA SERIALIZATION, not for config files and stuff, so that’s the goal by which these will be judged.</p><p>我想简要介绍一下各种数据序列化格式，并对它们进行比较。基本上，我们的目标是回答这个问题，“我们能找到比JSON更好的东西吗？”但是，请注意，我们查看这些内容是为了数据序列化，而不是为了配置文件或其他东西，因此这是判断这些内容的目标。</p><p>   That is, whether the type information for a structure is defined in a separate file (a schema) that a receiving program checks against, or whether the message itself contains type information. It’s almost exactly the difference between statically and dynamically typed programming languages. Like programming languages, both have pros and cons, neither of them are always better than the other. The goal of this is to compare apples to apples, so we’re gonna note which category these things fall into but not make value judgements based on them. There’s also fuzzy edges; many self-describing formats optionally have a schema layer too. Similarly, we will not really compare tooling quality; the goal is to look at the intrinsic properties of the formats. The culture surrounding them may be considered though.</p><p>也就是说，结构的类型信息是在接收程序检查的单独文件(模式)中定义的，还是消息本身包含类型信息。这几乎就是静态类型编程语言和动态类型编程语言之间的区别。就像编程语言一样，这两种语言都有优缺点，它们中的任何一种都不总是比另一种更好。这样做的目的是将苹果与苹果进行比较，所以我们会注意到这些东西属于哪一类，但不会根据它们做出价值判断。还有模糊的边；许多自描述格式也可以有一个架构层。同样，我们不会真正比较工具质量；我们的目标是查看格式的内在属性。不过，他们周围的文化可能会被考虑在内。</p><p> This is also important not to conflate with an RPC protocol, though many of these things are used IN RPC protocols. Keep in mind that HTTP/REST interfaces are often just a type of RPC protocol, whether realized that way or not.</p><p>这一点也很重要，不要与RPC协议混为一谈，尽管RPC协议中使用了其中许多内容。请记住，HTTP/REST接口通常只是一种RPC协议，无论是否以这种方式实现。</p><p> Up to date as of October 2020. Doesn’t try to include myriad minor things, ’cause there’s only so much time in the world.</p><p>截至2020年10月的最新情况。不会尝试包括无数的小事，因为世界上只有那么多时间。</p><p>    What everything gets currently compared against. We all know JSON, we all agree it’s Sorta Good Enough but really is kinda crap.</p><p>现在所有的东西都会拿来做比较。我们都知道JSON，我们都同意它已经足够好了，但是真的有点垃圾。</p><p> Category: Human-readable, self-describing. ( https://json-schema.org/ exists but does not seem very widely used.) Has an  RPC protocol but it also seems lightly used,  this might be more general.</p><p>类别：人类可读的、自我描述的。(https://json-schema.org/是存在的，但似乎没有得到广泛使用。)。有一个RPC协议，但它似乎也很少使用，这可能更通用。</p><p>   Simple – Easy to read, write, and understand… at least for simple things.  Turns out there’s a lot of gotcha’s though.</p><p>简单-易于读、写和理解…。至少对简单的事情来说是这样。不过，结果还是有很多人被抓到了。</p><p>  Type system is pretty shit – no date/time, no real integers, no real structs, no unions/tuples/etc</p><p>类型系统非常垃圾-没有日期/时间，没有实型整数，没有实型结构，没有联合/元组/等等</p><p> Tends to discourage schema’s – “So simple it doesn’t need it”, until it becomes less simple.</p><p>倾向于不鼓励模式的“简单到不需要它”，直到它变得不那么简单。</p><p> No normalized form – fields may be reordered,  duplicated, etc. Makes hashing it hard, gotta read whole message to begin verifying it, etc.</p><p>没有标准化的表单域可以被重新排序、复制等。这使得散列它变得困难，必须读取整个消息才能开始验证它，等等。</p><p>         Way too complicated – they made it a strict superset of JSON for some damn reason, and nobody uses that form, so it’s just a pile of wasted effort</p><p>太复杂了-出于某些该死的原因，他们将其打造成JSON的严格超集，而且没有人使用这种形式，所以这只是一堆徒劳。</p><p>   Not sure anyone really knows how XML happened. It’s basically the W3C’s fault, I think? It’s okay for some things but in the end I’m not sure it’s something anyone actually  wants to use, it’s just going to be one more of those mistakes of the past.</p><p>不确定是否有人真正知道XML是如何发生的。我想这基本上是W3C的错吧？有些事情是可以的，但最终我不确定这是不是任何人真正想要使用的东西，这只会是过去的又一个错误。</p><p> Category: Human-readable, self-describing with common schema usage. Has an  RPC protocol and many other complicated things.</p><p>类别：人类可读的、自我描述的、具有常见模式用法的。有RPC协议和许多其他复杂的东西。</p><p>         aka Protocol Buffers, but that’s a pretty dumb name. Google’s common, fast on-the-wire serialization format.</p><p>又名Protocol Buffers，但这是一个相当愚蠢的名字。谷歌常用的、快速的在线序列化格式。</p><p>    Backed by Google, so it’s going to be good at the things Google values</p><p>在谷歌的支持下，它将擅长谷歌看重的东西。</p><p>  Now has some support for versioning schemas, though it’s a hard problem in general</p><p>现在对版本化方案提供了一些支持，尽管这通常是一个很难解决的问题</p><p>  Backed by Google, so it’s going to be good at the things Google values</p><p>在谷歌的支持下，它将擅长谷歌看重的东西。</p><p>    Category: Machine-readable, schema-defined. Designed primarily for RPC, which is built in to the reference implementation.</p><p>类别：机器可读，模式定义。主要针对RPC设计，它内置于参考实现中。</p><p> Users: sandstorm.io, Cloudflare?, various other people but it doesn’t seem like that many</p><p>用户：SandStorm.io、Cloudflare？、各种其他用户，但看起来并不多。</p><p>  Made by one of the people who worked heavily on Protobuf at Google, so  there’s lots of experience behind it. That said, doesn’t mean this cat’s always  right, but there’s certainly opinions that are trying to be expressed.</p><p>是由一位在谷歌致力于Protobuf的人制作的，所以它背后有很多经验。也就是说，这并不意味着这只猫总是正确的，但肯定有一些观点试图表达出来。</p><p>  Lots of the docs and concepts are pretty low level, you usually ain’t gonna need it</p><p>很多文档和概念都是相当低级的，您通常不需要它。</p><p> Seems more complicated than protobuf – this might be one reason there’s fewer 3rd-party implementations</p><p>看起来比协议Buf更复杂-这可能是第三方实现较少的原因之一。</p><p>   Apache’s version of Protobuf. Does anyone actually use this? Facebook, apparently, since they invented it and then gave it to Apache. Anyone else?</p><p>阿帕奇版本的Protobuf。有人真的用这个吗？显然，Facebook，因为他们发明了它，然后把它给了阿帕奇。还有其他人吗？</p><p>  Users: Basically mostly Facebook? Twitter and AirBNB also apparently use it, so apparently it’s not UNpopular.</p><p>用户：基本上都是Facebook？Twitter和Airbnb显然也在使用它，所以显然它并不是不受欢迎。</p><p>       Feels a little like Google’s answer to Cap’n Proto, as it has some of the same design goals – zero-copy serialization and layouts that are more amenable to versioning.</p><p>感觉有点像谷歌对Capn Proto的回应，因为它有一些相同的设计目标--零拷贝序列化和更易于版本化的布局。</p><p>             Pretty good type system – there’s things like fixnum’s, datetime’s, blobs, etc</p><p>非常好的类型系统-有诸如fixnum、DateTime、BLOBS之类的东西。</p><p>  Kinda more complicated than it needs to be, though this is for the sake of compactness and comprehensive types. Numbers are densely packed into fewer bits when possible, for example.</p><p>比需要的要复杂一些，尽管这是为了紧凑和全面的类型。例如，在可能的情况下，数字被密集地打包成更少的比特。</p><p>   The Other CBOR, or rather,  CBOR is derived from this. Designed to be simple and compact. Kinda a  lot like a slightly chopped down CBOR, actually, their integer specification stuff looks nearly identical.</p><p>另一个CBOR，或者更确切地说，CBOR就是从这个派生出来的。设计简单紧凑。有点像稍微降低的CBOR，实际上，它们的整数规范内容看起来几乎相同。</p><p>         As the name implies, a binary-ifcation of JSON. Created by MongoDB as its internal data format.</p><p>顾名思义，JSON的二进制分支。由MongoDB创建，作为其内部数据格式。</p><p>        Things that are interesting but not actually in the scope of serialization languages, or are otherwise irrelevant.</p><p>有趣但实际上不在序列化语言范围内的东西，或者在其他方面不相关的东西。</p><p>   Invalid, it’s designed as a config language, not a serialization format. It’s basically an attempt to make something as simple and ubiquitous as windows .INI files that is an actual specification rather than a fashion.</p><p>无效，它被设计为配置语言，而不是序列化格式。它基本上是一种尝试，试图使像windows.INI文件这样简单和普遍的东西成为一种实际的规范，而不是一种时尚。</p><p> Category: Human-readable, sorta self-describing though usually you have a specific data structure you’re trying to fit it into.</p><p>类别：人类可读的，有点自我描述的，尽管通常您有一个特定的数据结构，您试图将其与之相适应。</p><p>        Rusty Object Notation. Because shoehorning Rust’s ML-y type systeminto JSON isn’t very much fun. Works startlingly well for this purpose but is basically untried elsewhere.</p><p>生锈的物体符号。因为将Rust的ML-y类型系统硬塞到JSON中并不是很有趣。在这个目的上效果非常好，但在其他地方基本上没有尝试过。</p><p> Category: Human-readable, sorta self-describing though usually you have a specific data structure you’re trying to fit it into.</p><p>类别：人类可读的，有点自我描述的，尽管通常您有一个特定的数据结构，您试图将其与之相适应。</p><p>        Included mainly for completeness. It’s not standardized outside of a single particular implementation which doesn’t promise stability, so not intended for general-purpose use. It’s intended as a fast and easy RPC/IPC format for Servo, and the actual format is basically an implementation detail of that goal.</p><p>包括主要是为了完整性。除了不能保证稳定性的单个特定实现之外，它不是标准化的，因此不打算用于通用用途。它的目的是作为一种用于Servo的快速而简单的RPC/IPC格式，而实际的格式基本上是该目标的实现细节。</p><p> Users: Servo, programs written by introverts who don’t care about being able to talk to each other. (Turns out this is a useful niche though, who knew.)</p><p>用户：伺服，由内向的人编写的程序，他们不在乎能否相互交谈。(但事实证明，这是一个有用的利基市场，谁知道呢？)。</p><p>    Anything other than that specific version of that specific library is undefined. If you’re OK with that though, it’s great.</p><p>该特定库的特定版本以外的任何内容都是未定义的。不过，如果你不介意的话，那就太好了。</p><p>   Some stupid telecom standards body’s attempt at doing what protobuf would do later. The standard body in question is related to the one that created the willful illusion of reality called  the OSI networking model.</p><p>某个愚蠢的电信标准机构试图做协议稍后会做的事情。所讨论的标准机构与创造现实的任性幻觉的标准机构有关，该机构被称为OSI网络模型。</p><p> Actually has some up sides though. If it wasn’t willfully complicated and overdesigned, it might be pretty good.</p><p>但实际上也有好的一面。如果它不是故意复杂和过度设计，它可能会相当不错。</p><p>  Users: Hopefully the only places you’ve seen this are in LDAP and in SSL certificates.</p><p>用户：希望您看到的唯一位置是在LDAP和SSL证书中。</p><p>  Binary and text forms, with methods for it to be shoved into just about any other data format ever</p><p>二进制和文本格式，以及将其放入几乎任何其他数据格式的方法。</p><p>     Included mainly for hysterical raisins. Sun Microsystems’s attempt at doing what protobuf would do later.</p><p>包括的主要是歇斯底里的葡萄干。太阳微系统公司试图做Protobuf后来会做的事情。</p><p> Basically what happens when you’re a very good C coder and want to transmit structured data over the network. Pretty reasonable as far as that goes, though.</p><p>基本上，当您是一名非常优秀的C程序员，并且希望通过网络传输结构化数据时，会发生什么情况。不过，就这一点而言，这是相当合理的。</p><p>      Doesn’t necessarily do much unless you’re a C program from the early 1990’s</p><p>除非你是20世纪90年代初的C程序，否则不一定能做很多事情。</p><p>  What Lisp code is made of,  an elegant notation from a more civilized time. Like lots of Lisp solutions, it works really well until you need to get two Lisp implementations to use the same kind of thing. Has steadfastly not managed to catch on outside of Lisp despite trying since at least the 1970’s.</p><p>Lisp代码是由什么组成的，一个来自更文明时代的优雅符号。与许多Lisp解决方案一样，它工作得非常好，直到您需要获得两个Lisp实现才能使用相同的东西。尽管至少从20世纪70年代开始尝试，但在Lisp之外一直没有成功地流行起来。</p><p> Does not have an actual universal spec, let alone implementations.  EDN is a pretty nice start though.</p><p>没有真正的通用规范，更不用说实现了。不过，EDN是一个相当不错的开端。</p><p>  Users: Any Lisp-like language, primary Real Examples are Scheme, Racket, Clojure and theoretically Common Lisp.</p><p>用户：任何类似Lisp的语言，主要的真实示例是Scheme、racket、Clojure和理论上的Common Lisp。</p><p>    Anyone out there with a Lisp interpreter will try to read it with  READ, despite  it already been proven that’s a terrible idea.</p><p>任何有Lisp解释器的人都会尝试用read来阅读它，尽管这已经被证明是一个糟糕的想法。</p><p> No matter what form of S-expression you use, somewhere out there someone will be annoyed that their particular form of Lisp can’t load it with  READ.</p><p>无论您使用哪种形式的S表达式，总会有人为他们的特定形式的Lisp不能加载Read而感到恼火。</p><p>         This is actually kinda interesting ’cause it’s easy to trace each format as a reaction to ones before it. ASN.1, XDR and a zoo of even stranger stuff predate the current internet age. The Modern Age starts with XML. XML has a long lineage of its own, but it forms a kinda bottleneck. It’s one of those technological ontology changes, like a mass extinction. Most of the things people actually care about formed in reaction to XML, so that’s where I’m going to start.</p><p>这实际上有点有趣，因为很容易将每种格式作为对之前格式的反应进行跟踪。ASN.1、XDR和一个由更奇怪的东西组成的动物园早在当前的互联网时代之前就存在了。现代始于XML。XML有自己的悠久历史，但它形成了某种瓶颈。这是技术本体论的变化之一，就像大灭绝一样。人们真正关心的大多数事情都是在对XML的反应中形成的，所以这就是我要从这里开始的。</p><p> So, the family tree of the most widespread things would be (apologies for those on mobile):</p><p>因此，最广为流传的事情的家谱是(对那些使用手机的人表示歉意)：</p><p> /--&gt; CBORXML---(XML is too verbose)-+---&gt; JSON --(JSON but binary and compact)---+--&gt; msgpack | \---&gt; YAML \--&gt; BSON | | \---(XML but binary)------+---&gt; Protobuf --(Protobuf but faster)---+---&gt; Cap&#39;n Proto \---&gt; Thrift \---&gt; Flatbuffers</p><p>/--&&gt；CBORXML-(XML过于冗长)-+-&&gt；JSON--(JSON，但二进制且紧凑)--+-&gt；msgpack|\-&gt；YAML\--&gt；bson||\-(XML，但二进制)-+--&&gt；Protobuf--(协议，但速度更快)-+--&gt；Cap&39；n协议\-&gt；平缓冲器。</p><p>  So when you actually look at this list, one thing stands out: There isn’t actually a replacement for JSON. Nothing better than it in the “human readable” column. Oh, there’s been many that have  tried, such as:</p><p>因此，当您实际查看此列表时，有一件事非常突出：实际上并没有JSON的替代品。在“人类可读”专栏里，没有什么比这更好的了。哦，已经有很多人试过了，比如：</p><p>  …But few of those seem kept up to date, let alone used widely. JSON5 probably comes closest, by virtue of being closest to its predecessor. This seems an area ripe for innovation though.</p><p>…。但其中似乎没有几个是最新的，更不用说广泛使用了。JSON5可能是最接近的，因为它最接近它的前身。不过，这似乎是一个创新的成熟领域。</p><p>   That said, please stop suggesting more unless they get actually used by more than one organization</p><p>也就是说，除非实际被多个组织使用，否则请停止建议更多内容</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://wiki.alopex.li/BetterThanJson">https://wiki.alopex.li/BetterThanJson</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/json/">#json</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>