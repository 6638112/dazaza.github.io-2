<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>编译器将优化它 The compiler will optimize that away</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The compiler will optimize that away<br/>编译器将优化它 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-05 20:43:17</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/2dc7adb413e443e6dedaa2c19a2ef1c2.png"><img src="http://img2.diglog.com/img/2021/5/2dc7adb413e443e6dedaa2c19a2ef1c2.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>A lot of programmers believe that compilers are magic black boxes in which you putyour messy code in and get a nice optimized binary out. The hallway philosopherswill often start a debate on which language features or compiler flags to usein order to capture the full power of the compiler’s magic.If you have ever seen the GCC codebase, you would really believe it must be doingsome magical optimizations coming from another planet.</p><p>很多程序员都认为编译器是魔法黑匣子，您可以在其中普通杂乱的代码，并获得一个很好的优化二进制。走廊哲学家频道经常开始争论哪个语言功能或编译器标志使用的命令来捕获编译器的魔术的全部力量。如果您见过GCC码库，您真的相信它必须是来自另一个星球的工人魔法优化。</p><p> Nevertheless, if you analyze the compiler’s output you will found out thatthe compilers are not really that great at optimizing your code. Not becausepeople writing them wouldn’t know how to generate efficient instructions,but simply because the compilers can only reason about a very smallpart of the problem space   1.</p><p> 尽管如此，如果您分析编译器的输出，您将发现编译器并不是在优化代码时非常重要。不是因为编写它们的人不会知道如何生成有效的指示，而是因为编译器只能推理一个非常小的问题空间1。</p><p> In order to understand why magic compiler optimizations are not going to speed upyour software, we have to go back in time when the dinosaurs roamed the earth and theprocessors were still extremely slow. The following graph shows the relativeprocessor and memory performance improvements throughout the years (1980-2010), taken from   2:</p><p> 为了理解为什么魔术编译器优化不会加快速度的软件，我们必须回到过去的恐龙漫游地球和处理器仍然非常慢。下图显示了整个年份（1980-2010）的一个相对处理者和内存性能改进，从2中获取：</p><p>  The problem that this picture represents is that the CPU performanceimproved tremendously over the years (y axis is in a logarithmic scale),while the memory performance increased at a much slower pace:</p><p>  这张图片代表的问题是多年来，CPU经过大多数的CPU（Y轴处于对数刻度），而内存性能以较慢的速度增加：</p><p>  So, what? We spend a few more cycles when loading something from the memory,but the computers are still way faster than they used to be. Who cares how many cycleswe spend?</p><p>  所以呢？我们在从内存加载某些东西时花了几个周期，但计算机仍然比以前更快的方式。谁关心多少次度过的花费？</p><p> Well, for one it’s sad to know that even if we get better compilers or faster hardware,the speed of our software is not going to drastically improve, sincethey are not the reason why our software is slow. The main problem thatwe have today lies in utilizing the CPUs to their full potential.</p><p> 那么，对于一个很悲哀地知道，即使我们得到更好的编译器或更快的硬件，我们的软件的速度不会显着提高，sincethey并不是让我们的软件速度慢的原因。今天的主要问题是利用CPU到他们的全部潜力。</p><p> The following table displays the latency numbers of common operations, taken from  3. Scaled latency column represents latency in numbers that are easierto understand for humans.</p><p> 下表显示了常见操作的延迟编号，从3中获取。缩放延迟列表示easierto对人类的数字的延迟。 </p><p>  When looking at the scaled latency column we can quickly figure out thataccessing memory is not free and for the vast majority of applicationsthe CPU is twiddling its thumbs while waiting for the memory to arrive   4.The reasons for that are two-fold:</p><p>在查看缩放延迟列时，我们可以快速弄清楚那个Accessing Memory不是免费的，对于绝大多数ApplicationSthe CPU在等待内存到达时，CPU正在旋转它的拇指4.这是两倍的原因：</p><p> The programming languages, which we are still using today, were made in time whenthe processors were slow and the memory access latency wasn’t much of a problem.</p><p> 我们仍在使用今天的编程语言是在时间的时间内完成，而处理器缓慢，内存访问延迟并不大大问题。</p><p> The industry best practices are still revolving around the object oriented programmingwhich does not perform well on a modern hardware.</p><p> 行业最佳实践仍在围绕面向对象的编程，在现代硬件上表现不佳。</p><p>   The programming languages listed above are all over 20 years old and their initial design decisions,like Python’s global interpreter lock or Java’s everything is an object mindset,no longer make any sense today   5. The hardware has changed tremendouslywith the addition of the CPU caches and multiple cores, while the programming languages arestill based on the ideas that are no longer true.</p><p>   上面列出的编程语言全部超过20岁及其初始设计决策，如Python的全局翻译锁定或Java的一切都是一个对象的心态，不再发出任何意义。硬件在添加CPU缓存和添加CPU缓存时更改了。多个核心，而编程语言基于不再是真实的想法竞争。</p><p> Most of the modern programming languages are trying to make your life easierby taking away the sorrows of manual memory management. While not having to thinkabout the memory is going to make you more productive, that productivitycomes at a heavy price.</p><p> 大多数现代编程语言都试图让您的生活更轻松地脱离手动内存管理的悲伤。虽然不必思考记忆将使您更加富有成效，但以沉重的价格提供生产力。</p><p> Allocating chunks of memory without oversight is going tomake your program slow, mostly due to random memory accesses (cache misses)that will cost you a few hundred CPU cycles each. Nevertheless,most programming languages listed above still act like the random memoryallocation is not a big deal and you shouldn’t worry about it because the computersare so fast.</p><p> 在没有监督的情况下分配内存的块是慢慢的，大部分是由于随机内存访问（缓存未命中），这将花费几百个CPU周期。尽管如此，上面列出的大多数编程语言仍然像随机内存放置一样，你不应该担心它，因为电脑太快了。</p><p> Yes, the computers are extremely fast, but only if you write your software in a waythat plays nice with your hardware. On the same hardware you can experience a butterysmooth 3D game and a visibly lagging MS Word. Obviously, the hardware is not the issuehere and we can squeeze much more out of it than an average application does.</p><p> 是的，计算机非常快，但只有当您以Waythat写下您的软件时，只有您的硬件播放。在相同的硬件上，您可以体验蝴蝶3D游戏和明显滞后的MS Word。显然，硬件不是问题，我们可以比平均应用程序更多地挤出更多。 </p><p>  Another problem with the current programming languages is that they didn’tevolve beyond the C-style type of programming. Not that there is anything wrongwith writing for loops, but it’s getting harder and harder to exploitour CPUs to their full potential while still managing the complexity of the modernprograms.</p><p>目前编程语言的另一个问题是它们不超过C型编程类型。不是写入循环写作的任何东西，但它越来越难以利用CPU来充分潜力，同时仍然管理现代人的复杂性。</p><p> In some way, they lack the functionality that would allow you to programin a way that is convenient for humans, while still leveraging the hardwareto achieve the best possible performance. While the sorts of abstractions that we areusing today are convenient, they tend to not perform well on a modern hardware.</p><p> 在某种程度上，他们缺乏允许您对人类方便的方式进行编程的功能，同时仍然利用HardWareto来实现最佳性能。虽然我们今天非常方便的抽象方便，但它们往往不会在现代硬件上表现良好。</p><p> This is going to be a long winded explanation, but let’s start with an example:</p><p> 这将是一个很长的蜿蜒解释，但让我们从一个例子开始：</p><p> Imagine we are simulating an ant colony. The colony’s administration departmentwas destroyed in the latest anteater attack, thus they no longer know how manywarrior ants are still living in the colony.</p><p> 想象一下，我们正在模拟蚂蚁殖民地。殖民地的行政管理部门在最新的食蚁兽攻击中被摧毁，因此他们不再了解了许多争吵蚂蚁仍然生活在殖民地。</p><p> Here is an example of how the majority of programmers, including myself,would write the code for solving this problem. It’s written in a typicalObject Oriented Enterprise Cache Trasher way, pardon my Java:</p><p> 以下是大多数程序员（包括我自己）的示例是如何编写解决此问题的代码。它是用典型的对象导向的企业缓存Trasher方式，原谅我的Java：</p><p> class  Ant  {  public  String  name  =  &#34;unknownAnt&#34; ;  public  String  color  =  &#34;red&#34; ;  public  boolean  isWarrior  =  false ;  public  int  age  =  0 ; } // shh, it&#39;s a tiny ant colony  List &lt; Ant &gt;  antColony  =  new  ArrayList &lt;&gt;( 100 ); // fill the colony with ants  // count the warrior ants  long  numOfWarriors  =  0 ; for  ( Ant  ant  :  antColony )  {  if  ( ant . isWarrior )  {  numOfWarriors ++;  } }</p><p> All {公共字符串名称=＆＃34;未知用品＆＃34; ;公共字符串颜色=＆＃34;红色＆＃34; ;公共布尔isWarrior = false;公共int年龄= 0; } // shh，它＆＃39; s一个微小的蚁群名单＆lt;蚂蚁＆gt; Antcolony =新的ArrayList＆lt;（100）; //用蚂蚁填充菌落//计算战士蚂蚁长号numofwarriors = 0; for（蚂蚁蚂蚁：antcolony）{if（蚂蚁。iswarrior）{numofwarriors ++; }}</p><p> The solution above is short and easy to understand. Unfortunately it doesn’t performwell on a modern hardware.</p><p> 上述解决方案短且易于理解。不幸的是，它并不是在现代硬件上的表现。 </p><p> Every time you request a byte of memory that is not already present in one of the CPU caches,an entire cache line is fetched from the main memory even if you need only 1 byte.Since fetching the data from the main memory is quite expensive(see the latency table above), we would prefer to keepthe number of memory fetches as small as possible. This could be achieved in two ways:</p><p>每次请求尚未存在于其中一个CPU高速缓存中的内存字节时，即使只需要1个字节，也从主内存中获取整个高速缓存行。从主内存中获取数据非常昂贵（请参阅上面的延迟表），我们宁愿保留尽可能小的内存量。这可以通过两种方式实现：</p><p> By keeping the necessary data in contiguous blocks in order to fully utilize thecache lines.</p><p> 通过将必要的数据保持在连续块中，以便充分利用TheCache行。</p><p> For the example above, we can reason about the data that is being fetchedas (I am assuming compressed oops are being used, please correct me if I am wrong):</p><p> 对于上面的例子，我们可以推理有关福切斯的数据（我假设正在使用压缩糟糕，请纠正我，如果我错了）：</p><p> + 4 bytes for the name reference+ 4 bytes for the color reference+ 1 byte for the warrior flag+ 3 bytes for padding+ 4 bytes for the age integer+ 8 bytes for the class headers---------------------------------24 bytes per ant instance</p><p> + 4个字节的名称参考+ 4个字节的颜色引用+ 1个字节为Warrior Flag + 3个字节用于填充+ 4个字节的年龄整数+ 8个字节为类标题------------- ---------------------24字节是每个蚂蚁</p><p> How many times do we have to touch the main memory in order to count all the warriorants (assuming the ant colony data is not already loaded in the cache)?</p><p> 我们必须多次触摸主内存，以计算所有战士（假设蚁群数据尚未在缓存中加载）？</p><p> If we take in consideration that on a modern CPU the cache line size is 64 bytes,that means we can fetch at most 2.6 ant instances per cache line. Since this exampleis written in Java, where everythingis an object that lives somewhere in the heap, we know that the ant instancesmight live on a different cache lines   6.</p><p> 如果我们考虑在现代CPU上，缓存行大小是64个字节，这意味着我们可以在每个缓存行中最多2.6个蚂蚁实例获取。自从该examps中写入Java以来​​，其中一般的一个物体在堆中的某个地方生活，我们知道Ant实例可以在不同的高速缓存行6上实现。</p><p> In the worst case scenario, the ant instances are not allocated one after another andwe can fetch only one instance per cache line. For the entire ant colony that meanswe have to touch the main memory 100 times and for every cache line fetched (64 bytes),we are only using 1 byte. In other words, we are throwing away 98% of the fetcheddata. This is a pretty inefficient approach for counting our ants.</p><p> 在最糟糕的情况下，ant实例未在另一个陆续分配，并且我们只能从每个缓存行中获取一个实例。对于易于触摸主内存的整个蚁群100次，并且对于每个缓存行（64字节），我们仅使用1字节。换句话说，我们扔掉了98％的Fetcheddata。这是计算我们蚂蚁的一种非常低效的方法。 </p><p>  Can we rewrite our program in a way that would be more prudent with fetching the memoryand thus improve the performance of our program? Yes, we can.</p><p>我们可以以更谨慎的方式重写我们的程序，从而提高我们程序的性能吗？我们可以。</p><p> We are going to use the most naive  data orientedapproach. Instead of modelling ants one by one, we model the entire colony at once:</p><p> 我们将使用最幼稚的数据riendedaproach。而不是一个接一个地建模蚂蚁，我们立即模拟整个殖民地：</p><p> class  AntColony  {  public  int  size  =  0 ;  public  String []  names  =  new  String [ 100 ];  public  String []  colors  =  new  String [ 100 ];  public  int []  ages  =  new  int [ 100 ];  public  boolean []  warriors  =  new  boolean [ 100 ];  // I am aware of the fact that this array could be removed   // by splitting the colony in two (warriors, non warriors),   // but that is not the point of this story.   //    // Yes, you can also sort it and enjoy in an additional    // speedup due to branch predictions.  } AntColony  antColony_do  =  new  AntColony (); // fill the colony with ants and update size counter  // count the warrior ants  long  numOfWarriors  =  0 ; for  ( int  i  =  0 ;  i  &lt;  antColony_do . size ;  i ++)  {  boolean  isWarrior  =  antColony_do . warriors [ i ];  if  ( isWarrior )  {  numOfWarriors ++;  } }</p><p> 类antcolony {public int size = 0;公共字符串[]名称=新字符串[100]; public string []颜色=新字符串[100];公共int []年龄= new int [100]; Public Boolean [] Warriors = New Boolean [100]; //我知道这个阵列可以删除//通过将殖民区分成两个（勇士，非战士），//而不是这个故事的重点。 // //是的，您还可以对其进行排序，并在额外的//由于分支预测而享受。 antcolony antcolony_do = new antcolony（）; //用蚂蚁填充殖民地，更新尺寸计数器//计算战士蚂蚁长numofwarriors = 0; for（int i = 0; i＆lt; antcolony_do。size; i ++）{boolean iswarrior = antcolony_do。勇士[I]; if（isswarrior）{numofwarriors ++; }}</p><p> The two presented examples are algorithmically equivalent (O(n)),but the data oriented solution outperforms the object oriented one. Why?</p><p> 两个呈现的示例是算法等效的（O（n）），但是数据面向解决方案优于面向对象的情况。为什么？</p><p> It’s because the data oriented example fetches less data and that data is fetched incontiguous chunks - we fetch 64 warrior flags at once and there is no waste.Since we are only fetching the data that we need, we only have to touch the main memorytwice instead of once for every ant (100 times).This is a way more efficient approach for counting our warrior ants.</p><p> 这是因为数据导向示例取消了更少的数据，并且数据被获取了中间的块 - 我们立即获取64个战士标志，没有浪费.Since我们只获取我们需要的数据，我们只需要触摸主内存每一个蚂蚁一次（100次）。这是一种更有效地计算我们的战士蚂蚁的方法。</p><p> I made some performance benchmarks with the Java Microbenchmark Harness (JMH)toolkit and the results are shown in the table below (measured on Intel i7-7700HQ @3.80GHz).I ignored the confidence intervals in order to keep the table clean,but you can run your own benchmarks by downloading and running the  benchmark code.</p><p> 我用Java Microbenchmark Marness（JMH）工具包进行了一些性能基准，结果如下表所示（在英特尔I7-7700HQ @ 3.80GHz上测量）。我忽略了置信区间以保持表格清洁，但是你可以通过下载和运行基准代码来运行自己的基准。</p><p>  By changing the way we look at the problem, we were able to gain a largespeedup. Keep in mind that in our example the ant class is relativelysmall, therefore that data will most likely stay in one of the CPU cachesand the difference between the two approaches is not as exaggerated(according to the latency table, accessing memory from the cache is30-100 times faster).</p><p>  通过改变我们看待问题的方式，我们能够获得巨额救护。请记住，在我们的示例中，蚂蚁类是相对体积的，因此数据很可能留在其中一个CPU缓存和两个方法之间的差异不像夸张（根据延迟表，从缓存中访问存储器IS30- 100倍更快）。 </p><p> Even though the examples above are written in the free spirited everything ispublic approach, the data oriented design does not prohibit you from using theenterprise control freak approach. You can still make every field private and final,provide getters and setters and implement a few interfaces if you are really intothat.</p><p>尽管上面的示例是在自由敏锐的一切中写入的一切，但数据导向的设计并没有禁止您使用Iterprise控制围栏方法。您仍然可以使每个字段私有和最终，提供Getters和Setter，如果您真的Intothat，请执行一些接口。</p><p> You may even realize that all of that enterprise cruft is not really necessary,who knows? But the most important takeaway from this example is to stopthinking about ants in an one by one fashion and rather think aboutthem as a group. After all, where have you seen only one ant?</p><p> 您甚至可能意识到所有企业Cruft并不是必要的，谁知道？但是这个例子中最重要的外卖器是通过一种时尚举行一个时尚，而不是作为一个群体思考的蚂蚁。毕竟，你只有一只蚂蚁见过什么？</p><p>  But, wait! Why is an object oriented approach so popular if it performs so badly?</p><p>  可是等等！为什么一个面向对象的方法如此流行，如果它表现得如此糟糕？</p><p> Most languages support this type of programming and it’s easy to wrap your mindaround the notion of objects.</p><p> 大多数语言都支持这种类型的编程，并且很容易将您的心态包裹在对象的概念。</p><p> The performance requirements for most enterprise software are embarrassingly low andany ol&#39; code will do. This is also known as the “but, the customer is not going topay for that” syndrome.</p><p> 大多数企业软件的性能要求是令人尴尬的低ANDANY OL＆＃39;代码会。这也被称为“但是，顾客不会追逐”综合征。</p><p> The ideas in the industry are moving slowly and the software cultists refuse to change.A mere 20 years ago memory latency wasn’t a big problem and the programming best practiceshaven’t caught up with the changes in the hardware.</p><p> 行业中的想法正在缓慢地移动，软件邪教者拒绝改变。仅仅20年前的内存延迟不是一个大问题，并且编程最佳实践并未陷入硬件的变化。</p><p> Problems: say we would like to find out how many red ants older than 1 ant yearare living in the colony. With the object oriented approach, that is pretty simple:</p><p> 问题：假设我们想了解超过1岁的红蚂蚁，生活在殖民地的1岁。与面向对象的方法，这很简单： </p><p> long  numOfChosenAnts  =  0 ; for  ( Ant  ant  :  antColony )  {  if  ( ant . age  &gt;  1  &amp;&amp;  &#34;red&#34; . equals ( ant . color ))  {  numOfChosenAnts ++;  } }</p><p>长号numofchosenants = 0; for（蚂蚁蚂蚁：antcolony）{if（蚂蚁年龄＆gt; 1＆amp;＆＃34;红色＆＃34;。等于（蚂蚁。颜色））{numofchosenators ++; }}</p><p> With the data oriented approach, it gets slightly more annoying as we have to be carefulhow we iterate over our arrays (we have to use the element located at the same index):</p><p> 通过面向数据的方法，它会稍微烦人，因为我们必须小心我们迭代我们的阵列（我们必须使用位于同一索引的元素）：</p><p> long  numOfChosenAnts  =  0 ; for  ( int  i  =  0 ;  i  &lt;  antColony . size ;  i ++)  {  int  age  =  antColony . ages [ i ];  String  color  =  antColony . colors [ i ];  if  ( age  &gt;  1  &amp;&amp;  &#34;red&#34; . equals ( color ))  {  numOfChosenAnts ++;  } }</p><p> 长号numofchosenants = 0; for（int i = 0; i＆lt; antcolony。尺寸; i ++）{int年龄= antcolony。年龄[i];字符串颜色= antcolony。颜色[i]; if（年龄＆gt; 1＆amp;＆amp;＆＃34;红色＆＃34;。等于（颜色））{numofchosenants ++; }}</p><p> Now imagine someone would like to sort all the ants in the colony based on their nameand then do something with the sorted data (e.g., count all the red ants of the first10% of the sorted data. Ants might have weird business rules like that, don’t judge them).In an object oriented way, you simply use the sort function from the standard library.In the data oriented way, you have to sort an array of names, but at the sametime also sort all the other arrays based on how the indices of the name array moved(assuming you care which color, age and warrior flag goes with the ant’s name)   7.</p><p> 现在现在想象有人想根据他们的命名方式对殖民地中的所有蚂蚁分类，然后用排序数据做点什么（例如，计算排序数据的前10％的所有红色蚂蚁。蚂蚁可能具有这样的奇怪业务规则，不要判断它们）。在面向对象的方式中，您只需使用标准库的排序函数。在面向数据的方式中，您必须对一个名称数组进行排序，但在Sametime也基于所有其他阵列关于名称阵列的指标如何移动（假设您关注哪种颜色，年龄和战士标志与ANT的名称一起使用）7。</p><p> This is exactly the type of problem that should be solved via the featuresof our programming languages, since writing these custom sorting functionsis very tedious. What if a programming language would provide us with astructure that would act like an array of structs, but internally itwould really behave like a struct of arrays? We could program in the typicalobject oriented way that is convenient for humans, while still enjoyingin great performance due to playing nice with the hardware.</p><p> 这正是通过我们的编程语言的特性解决的问题的类型，因为写出这些自定义排序功能非常繁琐。如果编程语言向我们提供的ASTructure，那么像一个结构阵列，但内部它会真的表现得像阵列的结构？我们可以以典型的方式编程方便的人类，同时仍然享受着良好的性能，因为它的硬件很好。</p><p> So far, the only programming language I know of that supports this type ofcrazy data transformations is JAI, but unfortunately it’s still in closed beta andnot available for the general public to use. Why on earth is this functionalitynot baked in our “modern” programming languages is something to ponder about.</p><p> 到目前为止，我知道这个支持这种类型的杂交数据转换的唯一编程语言是jai，但遗憾的是它仍然是封闭的beta和未使用的普通公众使用。为什么在地球上是这种功能，在我们的“现代”编程语言中烘焙了一些事情要思考。</p><p>  If you ever stepped into an enterprise shop and snooped around in their codebase,what you most likely saw was a giant pile of classes with numerous member fieldsand interfaces sprinkled on top. Most of the software is still written in that way,because it’s relatively easy to wrap your mind around that type of programmingand due to influences from the past.Large codebases are also a giant molasses   8 and thosewho are working on them will naturally gravitate towards the familiar stylethat they see every day.</p><p>  如果您曾进入企业商店并在其Codebase中窥探，您最有可能看到的是一堆巨大的课程，其中众多成员字段和遍在场洒在上面。大多数软件仍然是以这种方式编写的，因为由于过去的影响，将你的思想围绕这种类型的编程方式相对容易.LARGE CodeBases也是一个巨大的糖蜜8，那么巨大的糖蜜8，那么那样正在倾向于倾向于倾向于熟悉的样式，他们每天都看到。 </p><p> Changing the ideas on how to approach problems usually takes more effort thanparroting: “Use const and the compiler will optimize that away!”Nobody knows what the compiler will do, if nobody checked what the compiler did.</p><p>改变关于如何接近问题的想法通常需要更多的努力，而不是占据Parroting：“使用const和编译器将优化它！”没有人知道编译器会做什么，如果没有人检查编译器所做的内容。</p><p>  The reason why I wrote this article is because a lot of programmers believe that you haveto be a genius or know arcane compiler tricks in order to write code that performs well.A simple reasoning about the data that flows in your system will get you therefor the most part   9. In a complex program it’s not always easy to do that, but that isalso something that anyone can learn if they are willing to spend some time tinkeringwith these concepts.</p><p>  我写这篇文章的原因是因为很多程序员都认为你是一个天才或知道artacane编译器技巧，以便编写执行的代码。关于系统中流动的数据的简单推理将让您带来您的系统大多数部分9.在一个复杂的计划中，这并不总是容易，但是那么任何人都可以学习的东西，如果他们愿意花一些时间来修补这些概念。</p><p> If you would like to learn more about this topic, make sure to read the Data-Oriented Design book and therest of the links that are listed in the notes section.</p><p> 如果您想了解有关此主题的更多信息，请务必阅读“有关数据导向的设计书”，并在“注释”部分中列出的链接。</p><p>  [EXTRA] An article describing the problems of object oriented programming: Data-Oriented Design (Or Why You Might Be Shooting Yourself in The Foot With OOP)</p><p>  [额外]一篇文章，描述了面向对象的编程问题：以数据为导向的设计（或者为什么您可能会用OOP射击自己）</p><p> From the  Data Oriented Design - Mike Acton (2014)talk in which he pointed out that in the analyzed snippet only 10% of the problemis what the compiler can optimize in theory and the 90% of the problem is what the compilercan’t possibly optimize.</p><p> 从面向数据的设计 -  Mike Acton（2014）谈谈他指出，在分析的赛段中只有10％的问题，编译器可以在理论上优化的问题，90％的问题是Compilercan不可能优化的内容。</p><p> If you would like to learn more about the memory, you may want to read What every programmer should know about memory.If you are curious about the number of cycles that a certain CPU instruction burns,feel free to dive into the CPU instruction tables.  ↩︎</p><p> 如果您想了解有关内存的更多信息，您可能希望阅读每个程序员应该了解内存的内容。如果您对某个CPU指令刻录的周期数感到好奇，请随时潜入CPU指令表。 ↩︎</p><p> From the  Pitfalls of object oriented programming - Tony Albrecht (2009),slide 17. You can also check out his  video (2017)on the same topic.  ↩︎</p><p> 来自面向对象的陷阱 -  Tony Albrecht（2009），幻灯片17.您还可以在同一主题查看他的视频（2017）。 ↩︎ </p><p>  Memory is not always the bottleneck. If you are writingor reading a lot of data, the bottleneck will most likely be your hard drive.If you are rendering a lot of things on the screen, the bottleneck might beyour GPU.  ↩︎</p><p>内存并不总是瓶颈。如果您是写入大量数据的写作，那么瓶颈很可能是您的硬盘。如果您在屏幕上渲染很多东西，则瓶颈可能会Beyour GPU。 ↩︎</p><p> We all know what a mess is C++. I know your favorite niche language is notpresent in the list and that C# is only 19 years old, calm down.  ↩︎</p><p> 我们都知道一团糟是c ++。我知道你最喜欢的利基语言是在列表中的不熟句，C＃只有19岁，冷静下来。 ↩︎</p><p> If you allocate all the instances at the same time one after another,chances are, they will also be located one after another in the heap whichwill speed up your iterations. In general it’s best to preallocate all your dataat startup to avoid having your instances spread out through your entire heap,although if you are using a managed language it’s hard to speculate what thegarbage collectors will do in the background. For example, the JVM developersclaim that allocating small objects and deallocating them right aftermight perform better than keeping a pool of preallocated objects due tothe way the generational garbage collectors work.  ↩︎</p><p> 如果您同时分配所有实例，则机会是，它们也将在堆中接一个地位于堆中的迭代中。一般而言之，最好预先释放所有Dataat启动，以避免使用整个堆的实例，虽然如果您使用的是托管语言，但很难推出在背景中拨打的内副函数收集者的作用。例如，JVM DevelopersClaim将拨出小对象并将其释放后能够更好地执行，而不是保持原代垃圾收集器的方式所做的代价池。 ↩︎</p><p> You could also copy the name array, sort it and find the relevant namein the original unsorted name array to get back the index of the relevant element.Once you have the element array index you can do whatever you want, but it’s tediousto make this kind of lookups. If your arrays are big this approach is also quite slow.Know your data!</p><p> 您也可以复制名称数组，对其进行排序并查找原始未排序的名称阵列的相关名称以返回相关元素的索引。您拥有元素数组索引您可以做任何您想要的，但它是泰迪托制作这种查找。如果你的阵列很大，这种方法也很慢。知道你的数据！</p><p> Another problem that was not mentioned above is inserting or deleting elementsfrom the middle of the array. When you add or remove the element from the middleof the array that usually involves copying the entire modified array to a newlocation in memory. Copying the data is slow and if you are not careful withhow you copy the data, you could also run out of memory.</p><p> 上面未提及的另一个问题是从数组中间插入或删除元素。当您从中间添加或删除通常涉及将整个修改的数组复制到内存中的新位置的数组中的元素时。复制数据很慢，如果您不小心携带数据，您也可以用完内存。</p><p> If the order of the elements in the arrays do not matter, you can also swapthe deleted element with the last element of the array and decrease the internalcounter that counts the number of active elements in your group. When iteratingover the elements in this situation, you will essentially only iterate throughthe active part of the group.</p><p> 如果阵列中元素的顺序无关紧要，您还可以使用阵列的最后一个元素交换已删除的元素，并减少计算组中活动元素数的内部关闭。在这种情况下迭代元素时，您将基本上只迭代集团的活动部分。</p><p> Linked list is not a viable solution for this problem, since your data isnot allocated in contiguous chunks which makes the iteration very slow (poorcache utilization).  ↩︎</p><p> 链接列表不是此问题的可行解决方案，因为您的数据是在连续的块中分配的数据，这使得迭代非常慢（不足的利用率）。 ↩︎ </p><p>  That doesn’t mean the code will be always simple and easy to understand -the code for efficient matrix multiplication is quite hairy.  ↩︎</p><p>这并不意味着代码将始终简单且易于理解 - 高效矩阵乘法的代码非常毛茸茸。 ↩︎ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.royalsloth.eu/posts/the-compiler-will-optimize-that-away/">https://blog.royalsloth.eu/posts/the-compiler-will-optimize-that-away/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compiler/">#compiler</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>