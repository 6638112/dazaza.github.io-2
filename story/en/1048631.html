<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>拥抱Ruby中的函数式编程（2017） Embracing Functional Programming in Ruby (2017)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Embracing Functional Programming in Ruby (2017)<br/>拥抱Ruby中的函数式编程（2017） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-21 07:40:00</div><div class="page_narrow text-break page_content"><p>At  Gusto, we’ve been knee-deep in a substantial refactor of our system for running payrolls.</p><p>在古斯托（Gusto），我们一直在深思熟虑运行工资单的系统。</p><p> Running a payroll requires taking several different inputs such as how much an employee should get paid, where did they work, how much did they work, how much taxes should they pay, how much taxes have they paid this year, and so on and so on.</p><p> 进行工资核算需要采取几种不同的输入方法，例如员工应该得到多少薪水，他们在哪里工作，他们工作了多少，他们应该缴纳多少税，今年他们缴纳了多少税等等。在。</p><p> As a company that offers a payroll service, keeping this piece of the system in tip-top shape is important for the business. Customers love Gusto for its simplicity and speed when it comes to running payroll.</p><p> 作为一家提供薪资服务的公司，将系统的这一部分保持在顶尖状态对于企业来说很重要。客户喜欢Gusto，因为它在运行工资单方面既简单又快速。</p><p> Over the years, this system grew beyond its original mandate. Rather than just serve payroll for one state, it now serves them for all 50 states and the District of Columbia. Although customers love our payroll, internally new engineers had a difficult time understanding the code and making changes safely. This system needed a tune up, so we embarked on a sizable refactor.</p><p> 多年来，该系统已超出其最初的授权范围。现在，它不仅为一个州提供薪资，还为所有50个州和哥伦比亚特区提供薪水。尽管客户喜欢我们的工资单，但是内部新工程师很难理解代码并安全地进行更改。该系统需要调整，因此我们着手进行大规模的重构。</p><p> Because the process of calculating what you need for a payroll is one big formula, we set the goal of making this system “more functional” as in functional programming. We wanted to take the process of calculating a payroll and make it one big stateless operation.</p><p> 因为计算薪水所需的过程是一个很大的公式，所以我们设定了使该系统像功能编程那样“更具功能性”的目标。我们希望采用计算工资单的过程，并使之成为一项大型无状态操作。</p><p> The server-side code at Gusto is written in Ruby, a language usually known for its object-oriented and metaprogrammatic roots. Nonetheless, we wanted to integrate some more functional concepts into our code in the hopes of increasing the system’s safety and clarity. The result has been maintainable code that is easier to reason about and safer to change.</p><p> Gusto的服务器端代码是用Ruby编写的，该语言通常以面向对象和元编程的根源而闻名。尽管如此，我们还是希望将更多功能性概念集成到我们的代码中，以期提高系统的安全性和清晰度。结果是可维护的代码，使代码更容易推理，更安全。</p><p>  Ruby is an expressive language, but it does not lend itself to some common functional practices. Although Ruby allows for closures and first-class functions via  Procs, one does not see many  Procs passed around as objects in idiomatic Ruby.</p><p>  Ruby是一种富有表现力的语言，但是它并不适合某些常见的功能实践。尽管Ruby允许通过Procs进行闭包和一流的功能，但是在惯用的Ruby中并没有看到许多Procs作为对象传递。 </p><p> Throughout our work, we discovered that you can create expressive interfaces with clean internals by embracing both OO and functional aspects of Ruby.</p><p>在我们的整个工作中，我们发现您可以通过同时拥抱Ruby的OO和功能方面来创建具有干净内部结构的表达接口。</p><p> To do this, we used a pattern called  Pure Function as an Object (PFaaO). Essentially, you design objects as you would a  pure function but dress them up as Ruby classes.</p><p> 为此，我们使用了一种称为“纯函数作为对象”（PFaaO）的模式。本质上，您可以像对待纯函数一样设计对象，但是将它们打扮成Ruby类。</p><p> A pure function is a function without observable side effects that always returns the same value for a given set of inputs. That means no talking to the database, no modifying the state of other objects, no accessing the system clock, etc. When we write a PFaaO in Ruby, we want to build an object that has no side effects.</p><p> 纯函数是没有明显副作用的函数，对于给定的一组输入，该函数始终返回相同的值。这意味着不与数据库对话，不修改其他对象的状态，不访问系统时钟等。当我们用Ruby编写PFaaO时，我们希望构建一个没有副作用的对象。</p><p>  class  PayrollCalculator  def  self . calculate ( payroll )  new ( payroll ). calculate  end  def  initialize ( payroll )  @payroll  =  payroll  end  private_class_method  :new  def  calculate  PayrollResult . new (  payroll:  payroll ,  paystubs:  paystubs ,  taxes:  taxes ,  debits:  debits  )  end  def  paystubs  # ...  end  def  taxes  # ...  end  def  debits  # ...  end end</p><p>  PayrollCalculator def self类。计算（工资）新（工资）。计算结束def初始化（工资）@payroll =结束工资private_class_method：new def计算PayrollResult。新的（payroll：payroll，paystubs：paystubs，tax：tax，debits：debits）end def paystubs＃... end def tax＃... end def debits＃... end end</p><p> There’s quite a bit going on here, so let’s break it down bit by bit.</p><p> 这里有很多事情，所以让我们一点一点地分解。</p><p> First, our class has only one effective public interface:  PayrollCalculator.calculate. Because we’ve declared the constructor private using  private_class_method :new, the instance method  #calculate is effectively private.  1</p><p> 首先，我们的类只有一个有效的公共接口：PayrollCalculator.calculate。由于我们已使用private_class_method：new将构造函数声明为私有，因此实例方法#calculate实际上是私有的。 1个</p><p> This means that all of the other instance methods we declare are implicitly private, even though there is no explicit  private block within this class. Because there’s no way to  .new up an instance, there is not a vector to call any instance methods.</p><p> 这意味着，即使此类中没有显式的私有块，我们声明的所有其他实例方法也是隐式私有的。由于无法更新实例，因此没有向量可以调用任何实例方法。 </p><p> Our method only has one public interface and its designed operation is effectively stateless, therefore we only need to exercise one interface in our tests. Put some data in, assert that the data coming out is what we expected.</p><p>我们的方法只有一个公共接口，其设计的操作实际上是无状态的，因此我们只需要在测试中使用一个接口即可。放入一些数据，断言数据出来就是我们所期望的。</p><p>  In our above example, let’s say that the process of calculating taxes is expensive from a time perspective.  2 Thus, we want to make a time/space tradeoff to consume more memory to minimize the number of times we need to compute taxes. In our example, calculating both  #paystubs and  #debits will require the result of  #taxes.</p><p>  在上面的示例中，假设从时间角度来看，计算税收的过程非常昂贵。 2因此，我们希望在时间/空间上进行权衡以消耗更多的内存，以最大程度地减少计算税金的次数。在我们的示例中，同时计算#paystubs和#debits将需要#taxes的结果。</p><p> Now because each of these private methods is a pure function, we have referential transparency. This means we can replace a method and its parameters with its return value. Think of it like algebra: Given the function  f(x) = x + 5, you can safely replace any occurrence of  f(2) with the value  7.</p><p> 现在，由于每个私有方法都是纯函数，因此我们具有引用透明性。这意味着我们可以将方法及其参数替换为其返回值。像代数一样思考它：给定函数f（x）= x + 5，您可以安全地用值7替换任何出现的f（2）。</p><p>   Memoization is a form of caching, and can be fraught with issues if the memoized value does not actually come from a pure function. But because we make everything within the PFaaO pure, we can safely memoize this method call.</p><p>   备忘是一种缓存形式，如果备忘的值实际上并非来自纯函数，则可能会遇到很多问题。但是，因为我们使PFaaO中的所有内容都是纯净的，所以我们可以安全地记住此方法调用。</p><p> This is interesting because it looks like this class is no longer stateless: it now assigns local values. However the only interface is the single  .calculate class method, each instance of our PFaaO is single-use. Any intermediate state can never be accessed by externally. Because this cached state is not observable externally, our function is still technically pure.</p><p> 这很有趣，因为看起来此类不再是无状态的：它现在分配局部值。但是，唯一的接口是单个.calculate类方法，我们的PFaaO的每个实例都是一次性的。任何中间状态都不能从外部访问。由于无法从外部观察此缓存状态，因此我们的功能在技术上仍然是纯净的。</p><p> Much in the way a developer can abstract synchronous and asynchronous behavior, you can do the same with functional purity. Any local state changes are irrelevant in the lifecycle of the PFaaO. These local state changes are not observable from the outside world.</p><p> 开发人员可以通过许多抽象方式来抽象同步和异步行为，而您可以在功能纯净的情况下进行相同的操作。任何本地状态更改与PFaaO的生命周期无关。这些局部状态的变化无法从外部观察到。</p><p>  As I’ve grown in my career, I have become less interested in how software is written but how it is maintained. Software maintenance is the blessing and the curse of any successful project:  Congratulations! You have a business with lasting value.  Our condolences! You must now pay for all of your mistakes. Nonetheless, it is always preferred to have a business that exists with technical debt, than to have a bankrupt company with a pristine code base.</p><p>  随着我职业的发展，我对软件的编写方式和维护方式的兴趣已减弱。软件维护是任何成功项目的祝福和诅咒：恭喜！您的企业具有持久的价值。我们的哀悼！您现在必须为所有错误付费。但是，始终首选拥有技术债务的企业，而不是拥有原始代码库的破产公司。 </p><p> PFaaOs in Ruby are great because they are easy to maintain. Not only are they easy to test, but they are predisposed to healthy growth.</p><p>Ruby中的PFaaO很棒，因为它们易于维护。它们不仅易于测试，而且易于健康成长。</p><p>  Let’s again take the example of our  #taxes method. Early in Gusto’s history (back when it was still known as ZenPayroll), we only offered payroll services in California. Thus, we only needed to worry about payroll taxes for California.</p><p>  让我们再次以#taxes方法为例。在Gusto的历史早期（当时仍称为ZenPayroll），我们仅在加利福尼亚提供薪资服务。因此，我们只需要担心加利福尼亚的工资税。</p><p> In the grand scheme of things, California is a simple state when it comes to payroll taxes. Our taxes method might have looked like nothing more than the following:</p><p> 按照宏伟的计划，在工资税方面，加利福尼亚是一个简单的州。我们的税收方法可能看起来仅是以下内容：</p><p>  Now let’s say we expanded into a new state, New York. Now our method grows a little bit:</p><p>  现在说我们扩展到一个新的州，纽约。现在我们的方法有了一点增长：</p><p>  As we expand into every state,  3 this method will grow to be quite large! Furthermore, each of these methods adds to the length of our  PayrollCalculator class. Without constant gardening, the class could become difficult to understand.</p><p>  随着我们扩展到每种状态，3这种方法将变得非常大！此外，这些方法中的每一个都增加了PayrollCalculator类的长度。没有持续的园艺，班级将变得难以理解。</p><p> But because each of our methods within a PFaaO is itself a pure function, we are able to extract classes as we see fit and make each one a new PFaaO. We can safely replace our growing methods with new PFaaOs:</p><p> 但是由于PFaaO中的每个方法本身都是纯函数，因此我们能够按自己认为合适的方式提取类，并将每个类都设为新的PFaaO。我们可以用新的PFaaO安全地替换我们的增长方法：</p><p>  As we tease apart these different PFaaOs, we also get a much better idea of the input requirements for these service classes. Our  @payroll is a large parameter object, and each extracted PFaaO probably only needs a subset of its data.</p><p>  当我们梳理这些不同的PFaaO时，我们也对这些服务类的输入要求有了更好的了解。我们的@payroll是一个大参数对象，每个提取的PFaaO可能只需要其数据的一个子集。 </p><p>   Here we assume that the  Payroll#only_pay_and_location_data returns a slice of the total data within the instance as a new  Value Object. This Value Object represents only the data required to calculate the taxes part of running a payroll.</p><p>在这里，我们假设Payroll＃only_pay_and_location_data作为新的Value Object返回实例中总数据的一部分。此值对象仅表示计算运行工资单的税款部分所需的数据。</p><p>  Another important ingredient for scalable PFaaOs is the requirement that all data be immutable by default.  This is a drastic change from how most folks traditionally write Ruby.</p><p>  可伸缩PFaaO的另一个重要因素是要求所有数据默认情况下都是不变的。与大多数人传统上编写Ruby的方式相比，这是一个巨大的改变。</p><p> Every time you reach for your  =, you’ll need to replace it with a  #set or  #put. Rather than modifying objects in place, you will get used to returning new copies with new values. ( Hamster, which provides great immutable data structures, can help you from having to hand-roll FP functionality.)</p><p> 每次达到=时，都需要用#set或#put替换它。您将习惯于返回具有新值的新副本，而不是在适当位置修改对象。 （仓鼠提供了很好的不可变数据结构，可以帮助您不必手动设置FP功能。）</p><p> What does this mean for Rails? It will often mean creating functions or classes that take  ActiveRecord objects and convert them into immutable value objects. For us, we carve out these value objects into the namespace of what we’re doing. For example, here are the two representations of a payroll in our system:</p><p> 这对Rails意味着什么？这通常意味着创建带有ActiveRecord对象的函数或类，并将它们转换为不可变的值对象。对于我们来说，我们将这些值对象切入正在执行的操作的名称空间中。例如，以下是我们系统中薪资的两种表示形式：</p><p>  The  ActiveRecord version of a payroll represents the data that lives in the database. It is a superset of the data required for actually running a payroll. Although they have the same name, they do not have the same attributes. For example, the  ActiveRecord version of  Payroll will have a  processed_at attribute, whereas the  Payroll that lives in the calculation domain does not.</p><p>  工资单的ActiveRecord版本表示存在于数据库中的数据。它是实际运行工资单所需数据的超集。尽管它们具有相同的名称，但它们不具有相同的属性。例如，ActiveRecord版本的薪资将具有处理的_at属性，而位于计算域中的薪资则没有。</p><p> In the words of   Domain-Driven Design, each namespace here is a different Bounded Context. We implement adapters to take  ActiveRecord payrolls and turn them into  PayrollCalculator payrolls, and vice versa.</p><p> 用域驱动设计的话来说，这里的每个命名空间都是一个不同的绑定上下文。我们实现适配器以获取ActiveRecord工资单并将其转换为PayrollCalculator工资单，反之亦然。</p><p> The upside of this is the same that you might see in any other large system with well-defined abstractions; changes in models don’t cross domains. In our example, we can change the structure of the  Payroll in our database without needing to change the calculation code. We would only need to change our adapter. Furthermore, this context is entirely separate from the machinations of Rails. We could easily and safely pull this into its own gem or a separate service entirely.</p><p> 它的好处与您在具有定义良好的抽象的任何其他大型系统中可能看到的一样。模型更改不会跨域。在我们的示例中，我们可以更改数据库中薪资的结构，而无需更改计算代码。我们只需要更改适配器。此外，此上下文与Rails的阴谋完全分开。我们可以轻松安全地将其放入其自己的gem或完全独立的服务中。 </p><p> Were our  ActiveRecord objects be parameters to our calculator, adding or removing columns from the  ActiveRecord objects could cause a series of cascading, painful, and dangerous changes.</p><p>如果将ActiveRecord对象作为计算器的参数，则从ActiveRecord对象中添加或删除列可能会导致一系列级联，痛苦而危险的更改。</p><p> For young Rails apps, this level of indirection is overkill. As apps grow and multiple teams begin contributing to the same application, Bounded Contexts like these are necessary.</p><p> 对于年轻的Rails应用而言，这种间接级别是过高的。随着应用程序的增长以及多个团队开始为同一个应用程序做贡献，像这样的绑定上下文是必要的。</p><p>  We’ve been slowly refactoring our payroll calculators toward this model and use it to safely process upwards of $1 billion per month.</p><p>  我们一直在慢慢地将薪资计算器重构为该模型，并使用它来安全地每月处理10亿美元以上的费用。</p><p> The results have been remarkable: adding or changing payroll code is now a much safer operation. Because each change is much more isolated, a developer only needs to concern herself with the local implementation.</p><p> 结果非常了不起：添加或更改薪资代码现在更安全了。因为每个更改都更加孤立，所以开发人员只需要关心本地实现。</p><p> Although this post does not cover it, testing PFaaOs with immutable data is a breeze. We find ourselves performing less setup for each method and class. Our tests remain fast as they do not hit the database.</p><p> 尽管这篇文章没有涵盖它，但是使用不可变数据测试PFaaO轻而易举。我们发现自己为每个方法和类执行的设置较少。我们的测试保持快速，因为它们没有访问数据库。</p><p> It’s not all sunshine and rainbows, though. This approach  does result in a larger volume of code. My rough estimate would peg it at about a 1.5x - 2x increase in code volume. Some developers dislike the the sprawling nature of the many PFaaOs that result. Although the total lines of code will increase, you should develop a better understanding of the data requirements of each Bounded Context. Put another way: you don’t need to pass around whole  ActiveRecord objects, but just small bundles of their attributes.</p><p> 不过，并非所有的阳光和彩虹。这种方法确实会导致大量的代码。我的粗略估计将使代码量增加1.5倍至2倍。一些开发人员不喜欢由此产生的许多PFaaO的庞大性质。尽管代码总行数会增加，但是您应该对每个有界上下文的数据要求有更好的了解。换句话说，您不需要传递整个ActiveRecord对象，而只需传递它们的属性的一小束。</p><p> Before embracing this completely, discuss with your team to set up a few ground rules. We typically shoot for about 100 lines per class, but your team might decide on something different. Make sure to get on the same page and agree that your app is at the size where it might benefit from this style of thinking.</p><p> 在完全接受之前，请与您的团队讨论以制定一些基本规则。我们通常每节课拍摄约100条线，但是您的团队可能会决定采取其他不同的方法。确保进入同一页面，并同意您的应用处于可以从这种思维方式中受益的大小。 </p><p> For some teams, the extra layers of abstraction between  ActiveRecord and doing interesting things with the data might seem like overkill. In many situations, it will be. Again, I encourage you to have a healthy discussion with your team to decide if the benefits of this approach outweigh the negatives.</p><p>对于某些团队而言，ActiveRecord和对数据执行有趣的操作之间多余的抽象层似乎过大了。在许多情况下，情况将会如此。同样，我鼓励您与团队进行健康的讨论，以确定这种方法的好处是否大于缺点。</p><p> For us, we’re employing it everywhere appropriate. Give this pattern a shot and let me know how it goes!</p><p> 对于我们来说，我们会在适当的地方使用它。试一下这个模式，让我知道它的进展！</p><p>  Special thanks to  Justin Duke,  Eddie Kim,  Bo Sørensen,  Matt Lewis, and  Julia Lee for providing feedback on early drafts of this post.</p><p>  特别感谢Justin Duke，Eddie Kim，BoSørensen，Matt Lewis和Julia Lee提供了有关此职位的初稿的反馈。</p><p> If you’re interested in receiving blog posts like this regularly, join hundreds of developers and  subscribe to my newsletter.</p><p> 如果您有兴趣定期收到这样的博客文章，请加入数百名开发人员并订阅我的新闻通讯。</p><p> Keen writers will know that nothing is ever  really private in Ruby. There is always  #send.  ↩</p><p> 敏锐的作者会知道，Ruby中没有什么是真正私有的。总有#send。 ↩</p><p>  At Gusto, calculating taxes is expensive! Did you know that there are more than 6,000 payroll taxes within the United States? Each one may or may not need to be applied for a given payroll, based on the different parameters of the payroll itself.  ↩</p><p>  在Gusto，计算税收非常昂贵！您知道美国境内有6,000多种工资税吗？根据工资单本身的不同参数，每个人可能不需要申请给定工资单。 ↩</p><p>  Today, Gusto provides payroll services in every state including D.C. with some of the lowest error rates in the industry.  ↩</p><p>  如今，Gusto在包括华盛顿州在内的每个州都提供薪资服务，并且出错率是业内最低的。 ↩ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://kellysutton.com/2017/09/13/embracing-functional-programming-in-ruby.html">https://kellysutton.com/2017/09/13/embracing-functional-programming-in-ruby.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/拥抱/">#拥抱</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>