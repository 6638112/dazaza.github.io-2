<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>反对ORM仇恨 Objection to ORM Hatred</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Objection to ORM Hatred<br/>反对ORM仇恨 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-09 21:34:37</div><div class="page_narrow text-break page_content"><p>Whenever someone asks which  Node.js ORM they should use, one of the first answers is always some version of “ don’t use an ORM, just write SQL”. This answer is then usually attacked with an opposite opinion along the lines of “ you need to use an ORM to hide all that nasty SQL”. People always seem to ignore the third option: using  an ORM that embraces SQL!</p><p>每当有人问他们应该使用哪个Node.js ORM时，第一个答案始终是“不使用ORM，只需编写SQL”的某种版本。然后通常会以“您需要使用ORM来隐藏所有讨厌的SQL”的方式以相反的观点来攻击该答案。人们似乎总是无视第三个选择：使用包含SQL的ORM！</p><p> I completely understand where the hatred comes from though. There are real problems in many ORMs, that  Thomas Hunter II summarizes well in his post  Why you should avoid ORMs. The main points Thomas listed were</p><p> 我完全理解仇恨的来源。在许多ORM中确实存在问题，Thomas Hunter II在他的帖子中很好地总结了为什么您应该避免使用ORM。托马斯列出的要点是</p><p> You learn the ORM, not SQL and that knowledge is usually not transferable to other tools.</p><p> 您学习的是ORM，而不是SQL，并且该知识通常不能转移到其他工具。</p><p> Complex ORM calls are inefficient. ORMs have their own object-oriented query language which they try to convert to SQL, and it’s usually really difficult.</p><p> 复杂的ORM调用效率低下。 ORM拥有自己的面向对象的查询语言，它们会尝试将其转换为SQL，这通常非常困难。</p><p> ORMs can’t do everything. The object oriented approach of most ORMs doesn’t map well to SQL. For many SQL operations, there is no object oriented equivalent.</p><p> ORM不能做所有事情。大多数ORM的面向对象方法无法很好地映射到SQL。对于许多SQL操作，没有等效的面向对象。</p><p> These problems arise from the fact that most ORMs are designed to abstract away SQL in favor of some object oriented interface. But not all ORMs are like that!</p><p> 这些问题源于以下事实：大多数ORM都旨在将SQL抽象化，以支持某些面向对象的接口。但是并不是所有的ORM都是这样！</p><p> I created an ORM called  objection.js for exactly the reasons Thomas listed. The design goal of objection.js is to allow you to use SQL whenever possible and only provide a DSL (Domain Specific Language) or a custom concept when something cannot be easily done using SQL. I’ll get back to objection.js soon. First, I’ll introduce you to the most common argument for avoiding ORMs:</p><p> 正是出于Thomas列出的原因，我创建了一个名为objection.js的ORM。 objection.js的设计目标是允许您尽可能使用SQL，并且在无法使用SQL轻松完成某些操作时仅提供DSL（特定域语言）或自定义概念。我将尽快返回objection.js。首先，我将向您介绍避免ORM的最常见论点： </p><p>  Yes, if you only need a flat list of items from one table at a time, by all means, don’t use an ORM! Of course you can use joins, subqueries and multiple queries to access related items in other tables, but that easily becomes tedious. For example, here’s a very basic query that joins a many-to-many relationship (children of a person) and a has-many relationship (pets of a person)</p><p>是的，如果您一次只需要一个表中的一个平面项目清单，那么绝对不要使用ORM！当然，您可以使用联接，子查询和多个查询来访问其他表中的相关项，但这很容易变得乏味。例如，这是一个非常基本的查询，将多对多关系（一个人的孩子）和多对多关系（一个人的宠物）联系在一起</p><p>  That’s already quite a bit of SQL. What if you want to join more relationships? How about nested relationships? You also need to repeat that every time you want to fetch the related objects. Not to mention the result of that query is a flat list of items and not a nested tree of objects.</p><p>  那已经是很多SQL了。如果您想加入更多的关系该怎么办？嵌套关系如何？您还需要在每次要获取相关对象时重复该操作。更不用说该查询的结果是项目的完整列表，而不是对象的嵌套树。</p><p> The next thing any ORM hater would do is to use a library that converts that flat result list into a nicely nested object tree and then proceed to writing a bunch of helper functions for adding those joins to queries so that you don’t need to repeat yourself. You quickly realize that most of these helper functions look the same and only the table names and foreign keys are different. Then the obvious choice is to go ahead and define the relationships in a single place as objects and create a generic function that takes a relationship description object and outputs the needed joins.</p><p> 讨厌ORM的下一件事是使用一个库，该库将平面结果列表转换为嵌套良好的对象树，然后继续编写一堆帮助程序函数以将这些联接添加到查询中，从而您无需重复你自己您很快就会意识到，大多数这些帮助器函数看起来都是一样的，只是表名和外键是不同的。然后，显而易见的选择是继续在单个位置将关系定义为对象，并创建一个接受关系描述对象并输出所需联接的泛型函数。</p><p>  In my opinion, that’s all a good ORM is: a set of tools to make using SQL easier! It allows you to fully use all the features of SQL and the underlying database engine and only provides helpers and custom solutions to things that are difficult to achieve with just plain SQL.</p><p>  我认为，好的ORM就是：一套使使用SQL更加容易的工具！它使您可以充分利用SQL和基础数据库引擎的所有功能，并且仅针对普通SQL难以实现的事情提供帮助程序和自定义解决方案。</p><p>    With objection.js, you always work with a  query builder. You can build any query and use as much SQL as you want but it also helps you to deal with the repetitive stuff like relations if you want it to. The  leftJoinRelation method is given the names of the relations you want to join and objection.js uses the  relation mappings to create the joins.</p><p>    使用objection.js，您始终可以使用查询生成器。您可以构建任何查询并使用任意数量的SQL，但如果需要，它也可以帮助您处理诸如关系之类的重复性内容。给leftJoinRelation方法指定了要连接的关系的名称，而objection.js使用关系映射来创建连接。</p><p> Now you may be thinking, “that’s not much shorter and I still need to define the relationships somewhere”. Well yeah, but you only need to do that once. If your project is so simple that defining the relationships and models takes a significant part of your development time, it doesn’t matter whether you use an ORM or not.</p><p> 现在您可能会想，“这并不太短，我仍然需要在某处定义关系”。是的，但是您只需要这样做一次。如果您的项目是如此简单，以至于定义关系和模型需要花费大量的开发时间，那么是否使用ORM都无关紧要。</p><p> The  joinRelation query above is 100% equivalent to the previous SQL query and would still produce a flat list of result rows. You can easily get a tree of objects using the  joinEager method:</p><p> 上面的joinRelation查询等效于上一个SQL查询的100％，并且仍然会生成结果行的平面列表。您可以使用joinEager方法轻松获得一棵对象树： </p><p>    And in the next code block is the minimal SQL needed to carry out that query. The selects with aliases are needed to be able to build the object tree from the flat list.</p><p>在下一个代码块中，是执行该查询所需的最少SQL。需要具有别名的选择才能从平面列表构建对象树。</p><p>  For many ORMs, SQL concepts like subqueries are difficult or impossible to write. Since all objection.js operations return a  query builder, writing  subqueries is just as easy as using plain SQL. For example, fetching all people that have at least one pet called ‘Fluffy’</p><p>  对于许多ORM，很难或不可能编写SQL概念（如子查询）。由于所有objection.js操作均返回查询生成器，因此编写子查询与使用普通SQL一样容易。例如，获取所有养育至少一只名为“蓬松”宠物的人</p><p>    But there’s also an easier way to write this in objection.js if you have defined the  pets relationship for the  Person model:</p><p>    但是，如果您已经为Person模型定义了pets关系，那么还有一种更简单的方法可以在objection.js中编写：</p><p>  But that requires you to learn the ORM (which was one of the arguments against ORMs). You can still start by writing the SQL solution you are familiar with. Once you learn more about objection.js, you find helpers like this that improve your productivity.</p><p>  但这需要您学习ORM（这是反对ORM的论点之一）。您仍然可以通过编写熟悉的SQL解决方案开始。了解了objection.js的更多信息后，您会发现类似这样的帮助程序，它们可以提高您的生产率。</p><p>   If your application is simple and you rarely need to deal with nested data and relations, using plain SQL or a query builder like  knex can be a good option. However, in most applications you want to work with nested data and a lot of relations and an ORM can be a helpful tool. With objection.js, you don’t need to make a compromise. You get the flexibility of a query builder and the relational power of an ORM in the same package.</p><p>   如果您的应用程序很简单，并且您几乎不需要处理嵌套的数据和关系，那么使用纯SQL或类似knex的查询构建器可能是一个不错的选择。但是，在大多数应用程序中，您希望使用嵌套数据和许多关系，而ORM可能是有用的工具。使用objection.js，您无需妥协。您可以在同一程序包中获得查询构建器的灵活性以及ORM的关系功能。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.jakso.me/blog/objection-to-orm-hatred">https://www.jakso.me/blog/objection-to-orm-hatred</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/orm/">#orm</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sql/">#sql</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>