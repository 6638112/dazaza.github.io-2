<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>捍卫模糊研究 In Defense of Blub Studies</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">In Defense of Blub Studies<br/>捍卫模糊研究 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-06 10:22:01</div><div class="page_narrow text-break page_content"><p>Sometimes people ask me what they should learn to become a better programmer. I feel like the default recommendation here is usually an obscure programming language or a textbook on some high-powered machinery like ML. So I always feel a little bit embarrassed and boring when I instead suggest going really deep on what you already know: your main programming language, web framework, object-relational mapper, UI library, version control system, database, Unix tools, etc. It’s not shiny or esoteric, but for me, building a detailed mental model of those (and how they compare to alternatives) might be the learning that’s contributed most to my effectiveness as an engineer.</p><p>有时人们会问我应该怎样学习才能成为一个更好的程序员。我觉得这里的默认建议通常是晦涩的编程语言或某些高级机器（如ML）上的教科书。因此，当我建议深入了解您已经了解的内容时，我总是会感到有些尴尬和无聊：您的主要编程语言，Web框架，对象关系映射器，UI库，版本控制系统，数据库，Unix工具等。这不是闪亮的或深奥的，但对我来说，建立一个详细的思维模型（以及它们与替代方案的比较）可能是对我作为工程师的作用最大的学习。</p><p> A coworker coined the phrase “blub studies” to refer to this sort of mundane, ultra-specific-seeming knowledge. “Blub” comes from a Paul Graham essay,  Beating the Averages, in which Blub is a hypothetical middlebrow language whose programmers get defensive when Graham asserts that Lisp is superior. Blub studies is the study of what goes on in the guts of these boring, everyday systems—not the kind you get tenure for inventing, but the kind people actually use.</p><p> 一位同事创造了“俱乐部研究”一词来指代这种平凡的，超特定的知识。 “ Blub”来自Paul Graham的一篇文章，击败平均水平，其中Blub是一种假设的中间语言，当Graham断言Lisp优越时，其程序员会采取防御措施。模糊研究是对这些无聊的日常系统的内在状况进行的研究，而不是发明的任职期限，而是人们实际使用的那种。</p><p> Blub studies is a never-ending treadmill of engineering know-how. It’s the fiddly technical details of how Git stores data, or how Postgres locking semantics  caused your migration to bring down prod, or why  pip install failed  this time. It’s what goes on inside the boiler rooms of your computer. There’s a seemingly infinite amount of it, full of bespoke details for you to stumble over, and that makes it, often, unbelievably frustrating. Experts in shiny fields like machine learning write shiny-sounding articles like   A theory of the learnable; experts in blub studies emit screeds like  The Law of Leaky Abstractions and  Programming Sucks.</p><p> 模糊研究是工程技术永无止境的跑步机。这是有关Git如何存储数据，Postgres锁定语义如何导致您的迁移降低产品质量或为何这次pip安装失败的技术细节。这就是计算机锅炉房内部发生的事情。似乎有无穷无尽的内容，其中充满了定制的详细信息，让您迷失了方向，这常常令人难以置信地令人沮丧。机器学习等领域的专家撰写的文章听起来很响亮，例如《可学习的理论》； blub研究的专家散发着冗长的句子，例如“泄漏抽象定律”和“编程吸吮”。</p><p> In short, if you’re in search of generalizable knowledge that  compounds exponentially over time, then blub studies looks like the crap you have to wade through to get to the good stuff. So it’s easy to see why people give up on understanding all the blub they’re surrounded by, except what they need to get the job done.</p><p> 简而言之，如果您要寻找随时间呈指数增长的可概括性知识，那么blub研究看起来就像您必须经过的废话才能获得的好东西。因此，很容易看出人们为什么会放弃对周围环境的理解，除了完成工作所需的东西。</p><p> But for me, the opposite attitude has been more productive.  Computers can be understood—even if it’s hard and takes a while. Blub studies is more generalizable than it seems, and has its own way of compounding over time, too. That makes it a lot more useful than you’d expect.  ✻    ✻Of course, there are useless parts of blub studies: if this essay gets you excited to memorize a bunch of command-line flags, consider  reversing this advice. But in my experience, it’s more common to neglect the useful parts of blubs, than to over-index on trivia.</p><p> 但是对我而言，相反的态度更具生产力。电脑是可以理解的，即使很难而且需要一段时间。模糊研究比看起来更具有通用性，并且随着时间的流逝也有其自己的复合方式。这使它比您预期的有用得多。 ✻✻当然，blub研究没有什么用处：如果本文让您兴奋地记住一堆命令行标志，请考虑逆转此建议。但以我的经验来看，忽略blub的有用部分比对琐事过度索引更为常见。</p><p>  The most straightforward benefit of blub expertise is that it saves you time.  “You can’t apply those brilliant insights you learned from SICP if you don’t have the knowledge base and emotional fortitude to fight through  pip install first.&#34; If you know how Git’s internal model works, you can get your repository out of its borked state without spending hours on Stack Overflow.</p><p>  blub专业知识最直接的好处是可以节省您的时间。 “如果您不具备首先通过点子安装进行斗争的知识和情感毅力，就无法应用从SICP那里学到的精辟见解。＆＃34;如果您知道Git的内部模型是如何工作的，则可以将存储库从混乱状态中解脱出来，而无需花费大量时间进行Stack Overflow。</p><p> This effect is larger than it might seem. If you’re working with a system you don’t understand, you’re limited to debugging via guess-and-check, which can be arbitrarily slow. A more efficient method would be to  get as much information as possible about your program’s execution and then use that information to exclude most of the hypothesis space. But this requires a good understanding of both the system, and the tools available for inspecting it. If you’re tracking down, say, a networking problem, staring at some  tcpdump output will often get you most of the way there, but only if you know how to interpret it and what to look for.</p><p> 此效果比看起来要大。如果您使用的系统不了解，则只能通过猜测检查进行调试，这可能会很慢。一种更有效的方法是获取有关程序执行的尽可能多的信息，然后使用该信息排除大部分假设空间。但这需要对系统以及可用于检查系统的工具有充分的了解。例如，如果您正在跟踪网络问题，则盯着某些tcpdump输出通常会带您到达大多数地方，但前提是您知道如何解释它以及寻找什么。 </p><p> If you spend half your programming time debugging, and being a blub expert lets you debug twice as fast, then just the speed gain from blub expertise will let you increase your output by a third.  †    †If you think “half of programming time debugging” sounds high, imagine how much faster you’d be if all your code worked the first time.  Doubling debugging speed is probably a conservative estimate—you can save pretty much unlimited time via things like  “hmm, 40 milliseconds sounds like the timeout for Nagle’s algorithm, try setting  TCP_NODELAY”. I somewhat frequently debug tricky things 5x+ faster than coworkers, just because I’ve been working with our stack for a long time, so I know where to look for problems and how to quickly test hypotheses. That justifies a lot of time staring at  tcpdump output! But there are also more subtle reasons I’ve gotten so much from blub studies. It’s both more general, lasts longer, and has more of a compounding effect, than I expected.</p><p>如果您花费一半的编程时间进行调试，而成为blub专家则使您的调试速度快两倍，那么blub专业技术所带来的速度提升将使您的输出提高三分之一。 ††如果您认为“一半的编程时间调试”听起来很高，请想象一下，如果所有代码都第一次工作，您的速度会提高多少。调试速度加倍可能是一个保守的估计，您可以通过“嗯，Nagle算法的超时时间为40毫秒，尝试设置TCP_NODELAY”之类的方法来节省几乎无限的时间。我经常调试棘手的东西要比同事快5倍以上，这是因为我使用堆栈已有很长时间了，所以我知道在哪里寻找问题以及如何快速检验假设。这证明有很多时间盯着tcpdump输出！但是，还有很多微妙的原因使我从blub研究中受益匪浅。它比我预期的更通用，持续时间更长，并且具有更多的复合效果。</p><p>  Blub studies are surprisingly broadly applicable because, even if you’re learning about the details of some specific blubby system, that system’s design will contain a juicy non-blubby core of extractible general principles. Unlike many “general principles” people try to teach you, the ones you learn via blub studies are guaranteed to be important to at least one real-world system (the one you’re learning about). And you’ll see them realized in all their messy detail, which academic presentations often leave out.</p><p>  令人难以置信的是，模糊研究广泛地适用，因为即使您正在学习某些特定​​的笨拙系统的细节，该系统的设计也将包含可提取的通用原理的多汁，非笨拙的核心。与许多人试图教给您的“一般性原则”不同，您通过blub学习所学到的那些对保证至少对一个现实世界系统（您正在学习的系统）很重要。而且您会看到他们在所有凌乱的细节中都意识到了这一点，而学术报告经常忽略了这些细节。</p><p> Suppose your blub of choice is React. You might worry that learning the gory details will be useless if you ever move to a different part of the stack, or even a different web framework. And, yes, some of them will. But the core idea of React—writing pure render functions, using  reconciliation to make updates fast—is extremely powerful and general. In fact, it’s now been copied by the next generation of UI frameworks on both iOS ( SwiftUI) and Android ( Jetpack Compose). Learning the principles behind React makes it easier to learn those other frameworks. In fact, it can even be a useful source of ideas to “import” from one to the other. At Wave, for instance, we’ve gotten a lot of mileage out of importing ideas from  Relay into our mobile apps.</p><p> 假设您选择的对象是React。您可能会担心，如果您移至堆栈的不同部分甚至是不同的Web框架，则学习gory细节将毫无用处。是的，其中一些会。但是，React的核心思想（编写纯渲染函数，使用协调功能使更新速度更快）非常强大且通用。实际上，它已被iOS（SwiftUI）和Android（Jetpack Compose）上的下一代UI框架复制。学习React背后的原理使学习其他框架变得更加容易。实际上，它甚至可以成为从一个“导入”到另一个的思想的有用来源。例如，在Wave，我们从中继将思想导入到我们的移动应用程序中已经取得了很多进展。</p><p> This is a good example of an idea that, as far as I know, you can  only learn about through blub studies. Academia didn’t give much attention to React-style UI programming. In fact, it doesn’t seem to view user-interface programming paradigms as a particularly interesting object of study at all. People do sometimes publish on it but, for instance, I couldn’t find any courses on it in MIT’s extensive course catalog.  ‡    ‡You could argue that this is because UI programming is “too applied” and one shouldn’t expect it to be covered in an academic curriculum. But computer science covers many other equally-“applied” areas, like networking, databases, operating systems, and graphics.</p><p> 这是一个很好的例子，据我所知，您只能通过blub学习来学习。学术界并未对React风格的UI编程给予太多关注。实际上，似乎根本没有将用户界面编程范例视为一个特别有趣的研究对象。人们有时会在上面发布它，但是，例如，我在MIT的广泛课程目录中找不到关于它的任何课程。 ‡‡您可能会争辩这是因为UI编程“应用过多”，并且不应期望它会被学术课程所涵盖。但是计算机科学涵盖了许多其他同样“应用”的领域，例如网络，数据库，操作系统和图形。</p><p>  Blub studies also compound more than you’d naively expect, in two ways. First, knowing about one blub makes it easier to learn about alternative blubs that serve the same purpose—like the React/SwiftUI example above. Second, knowing more about one blub helps you learn blubs in  adjacent parts of the stack more quickly.</p><p>  模糊研究还通过两种方式超出了您天真的期望。首先，了解一种blub使其更容易了解具有相同目的的替代blub，例如上面的React / SwiftUI示例。其次，更多地了解一种blub，可以帮助您更快地学习堆栈中相邻部分的blub。</p><p> Once, while pair programming with a more junior coworker, we were writing a complicated SQLAlchemy query. My coworker used  user.name (the  name field of an object stored in the  user variable) instead of  User.name (the  name field of the  class  User) and was wondering why her query gave the wrong results. I tried to explain the “magic” by which  User.name was an instance of  Column while  user.name was a simple  str. I went around in circles for a little while until I eventually explained Python’s  descriptor protocol to her (the language feature SQLAlchemy uses to enable the “declarative” ORM syntax). At that point, everything clicked—and I realized that Python’s  __dunder__ methods are the key to decoding quite a lot of “magical” seeming code. If you learn the Python language features well, lots of complicated libraries will become a lot easier to understand.</p><p> 有一次，当与一个更初级的同事进行结对编程时，我们正在编写一个复杂的SQLAlchemy查询。我的同事使用user.name（存储在user变量中的对象的名称字段）而不是User.name（User类的名称字段），并且想知道为什么她的查询给出了错误的结果。我试图解释“魔术”，其中User.name是Column的实例，而user.name是简单的str。我转了一圈，直到最终向她解释了Python的描述符协议（SQLAlchemy使用的语言功能来启用“声明式” ORM语法）。那时，一切都点击了—我意识到Python的__dunder__方法是解码很多“魔术”外观代码的关键。如果您很好地学习了Python语言功能，那么许多复杂的库将变得更容易理解。</p><p> I had a similar experience myself with Kubernetes. The first time I tried to learn it, it was a bewildering morass of jargon—all those namespaces and containers and Pods and Deployments and Services and Ingresses just to get a simple HTTP server running! Then I read  a networking textbook and everything made much more sense. The (arguably) most complicated parts of Kubernetes exist to solve networking-related problems—allowing hundreds of containers to talk to each other independently while hosted on a much smaller set of computers—so the networking textbook gave me a schema onto which I could hang all my Kubernetes factoids. Once I knew how Linux’s IP routing, iptables, and network namespaces worked, it was much easier for me to understand what exactly something like “kube-proxy” was doing.</p><p> 我自己在Kubernetes上也有类似的经历。我第一次尝试学习它时，这真是一团混乱的行话—所有这些名称空间和容器以及Pod和Deployments，Services和Ingress只是为了运行一个简单的HTTP服务器！然后，我读了一本网络教科书，一切都变得更有意义了。 Kubernetes的（可能是）最复杂的部分可以解决与网络相关的问题-允许数百个容器在较小的计算机上托管时彼此独立地交谈-因此网络教科书为我提供了一个可以挂在其上的模式我所有的Kubernetes类事实。一旦我知道了Linux的IP路由，iptables和网络名称空间是如何工作的，对我来说，更容易理解“ kube-proxy”之类的功能。 </p><p> If you know enough different blubs, you can end up at the point where you don’t even need to look things up to figure out how they’re (probably) implemented. An experienced Python programmer can guess immediately how SQLAlchemy’s “declarative” ORM works under the hood. That’s the point when your blub expertise will really start compounding—almost as soon as you start working with something new, you’ll start figuring out how it works and extracting the kernel of generally-interesting ideas.</p><p>如果您知道足够多的不同内容，那么您可能根本不需要查找所有内容即可弄清楚它们的实施方式（可能）。经验丰富的Python程序员可以立即猜测SQLAlchemy的“声明式” ORM是如何工作的。这就是您的blub专业知识真正开始复合的时候-几乎在您开始使用新事物时，您将开始弄清楚它是如何工作的，并提取出人们普遍感兴趣的想法的核心。</p><p>  Because of this compounding effect, the most important step toward becoming a blub master is to kickstart your “blub flywheel”—the virtuous cycle of blub accumulation—however you can. That means starting with whichever blubs are the easiest or most motivating to learn, and branching out from there. For me, the easiest place to start has been with blubs I’m already using at my day job. I have a couple strategies for getting the most out of those.</p><p>  由于这种复合作用，要成为一名blub大师，最重要的步骤就是尽快启动“ blub飞轮”，即blub积累的良性循环。这意味着从最容易学习或最有动力的学习开始，然后从那里开始。对我来说，最简单的起点就是在日常工作中使用的blub。我有两种策略可以充分利用这些策略。</p><p> First, I’ll try to  go deeper than necessary. If I really want to ship something, it’s easy to give into temptation to, say, Google an error message, copy-paste a fix from Stack Overflow, and move on with my day. But it often doesn’t take that much longer to actually read the error message, understand what it means, and try to figure out  why that Stack Overflow answer fixed my problem. Similarly, if I’m stuck in a tricky yak shave, I’ll bias against “guess-and-check” style debugging in favor of getting a better understanding of the system I’m trying to debug. It doesn’t always feel worth it to, e.g., dive into the docs of  tcpdump and  iptables rules to track down my weird one-off networking issue—but over time I’ve run into enough “weird one-off networking issues” that it’s paid off many times over.</p><p> 首先，我会尝试超出必要的范围。如果我真的想发货，很容易受到诱惑，例如向Google发送错误消息，从Stack Overflow复制粘贴修复程序，然后继续前进。但是，实际阅读该错误消息，了解其含义并尝试弄清为什么Stack Overflow答案可以解决我的问题，通常并不需要花费更长的时间。同样，如果我陷入棘手的y牛刮胡，我会偏向于“猜测并检查”样式的调试，以更好地了解我要调试的系统。例如，深入研究tcpdump和iptables规则的文档以跟踪我奇怪的一次性网络问题并不总是值得的，但是随着时间的推移，我遇到了足够多的“奇怪的一次性网络问题”，它已经获得了很多倍的回报。</p><p> The second part of my blub flywheel is to  pay attention to magic. Whenever I’m working with something new, I try to continuously update my best-guess mental model of how it’s implemented. “Okay, the docs are telling me to create an  Ingress, I guess this is probably the widget that provisions a load balancer to talk to my backend containers?” If I realize I’m wrong, I’ll dig in and update. “Hmm, I can’t ping those pods from outside the cluster, so how could the load balancer be talking to them? Aha—it’s talking to the nodes, and there’s a NodePort Service as a second layer of indirection.” If I have no idea at all how something could work, that usually means it’s time to read a book.</p><p> 我的blub飞轮的第二部分是注意魔术。每当我使用新的东西时，我都会不断地更新关于如何实现它的最好的思维模型。 “好吧，文档告诉我要创建一个Ingress，我想这可能是为负载均衡器提供了与我的后端容器对话的小部件吗？”如果我发现自己错了，我将进行挖掘和更新。 “嗯，我无法从集群外部ping这些pod，那么负载均衡器将如何与它们对话？啊哈-它正在与节点进行通信，并且有一个NodePort服务作为第二个间接层。”如果我完全不知道怎么做，那通常意味着该读一本书了。</p><p> One thing I wish other engineers would do to make blub studies easier is to produce more and better “advanced” documentation of their software. Most mature and widely-used libraries have great tutorials and introductory content, but far fewer make it easy to get past the “copy-pasting examples” stage. I think this is mostly a matter of organization and navigation; if I comb through, say, the  SQLAlchemy docs, I can actually find enough information to piece together a good mental model of the system, but it’s scattered among many different pages and it’s not clear what order I should read them in. The  React docs are probably the best I know of here, but still leave a lot out.</p><p> 我希望其他工程师能够简化blub研究的一件事是产生更多，更好的软件“高级”文档。大多数成熟且使用广泛的库都有不错的教程和介绍性内容，但是很少有库可以轻松地超过“复制粘贴示例”阶段。我认为这主要是组织和导航问题；如果我仔细研究一下SQLAlchemy文档，我实际上可以找到足够的信息来组成一个良好的系统思维模型，但是它分散在许多不同的页面中，并且不清楚应该以什么顺序阅读它们。React文档可能是我所知道的最好的，但仍然有很多遗漏。</p><p>  Over time, by consistently exploring the guts of anything I’m working with that seems magical, I’ve built up a broad base of knowledge about how various technical systems work. This helps me in tons of different ways. It makes it easier to track down tricky bugs across many layers of the stack. I can learn new languages and libraries quickly by pattern-matching them to what I already know. It gives me better ideas for software designs, by imitating other systems I’ve seen, or by reusing ideas or tools I’ve heard of in a different context. Maybe most importantly, it gives me the confidence that, if I run into a tricky problem, I can learn enough to solve it, instead of feeling like I’m at the mercy of a system too complex to hope to understand.</p><p>  随着时间的流逝，通过不断探索我正在研究的事物的内在魔力，我建立了广泛的知识基础，了解各种技术系统的工作方式。这以多种方式帮助我。它使在堆栈的多个层中追踪棘手的错误变得更加容易。通过将它们与我已经知道的内容进行模式匹配，我可以快速学习新的语言和库。通过模仿我见过的其他系统，或者在不同的环境中重用我所听到的想法或工具，它为我提供了更好的软件设计想法。也许最重要的是，它给了我信心，如果遇到一个棘手的问题，我将学到足够的知识来解决它，而不会觉得自己受制于过于复杂以至于无法理解的系统。</p><p> So if you’re looking to learn something that will make you a better, and happier, programmer, ask yourself which parts of your most-used blub seem magical to you, and try to understand how they work. You’ll learn than you think!</p><p> 因此，如果您想学习一些可以使您成为更好，更快乐的程序员的知识，请问自己最常用的blub的哪些部分对您来说很神奇，然后尝试了解它们的工作原理。您将学到比您想像的还要多！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.benkuhn.net/blub/">https://www.benkuhn.net/blub/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/捍卫/">#捍卫</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/blub/">#blub</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>