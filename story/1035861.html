<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Python的Bisect模块</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">使用Python的Bisect模块</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-22 13:18:24</div><div class="page_narrow text-break page_content"><p>博客JUNTO联系人bisect模块的目标是使您能够有效地搜索和更新排序的列表。为此，它提供：</p><p>   在统计数据装仓中，您有一个要分组为“箱”的数据。例如。</p><p> 您具有学生成绩的数据，并且希望将80到90之间的分数分组为“ B”，将90到100之间的分数分组为“ A”，依此类推。</p><p> 对我来说，一种简单的方法是编写一个计算bin的函数，例如对水果进行装箱：</p><p> def bin_fruit（fruit）：如果[“ lemon”，“ orange”]中的水果：返回“ citrus” elif [[“ apple”，“ pear”]中的水果：返回“ malinae” import randomdata = random.choices（[ “，” orange“，” apple“，” pear“]，k = 10）data</p><p>def bin_score（分数）：如果90 <=分数<= 100：返回“ A” elif 80 <=分数<90：返回“ B” elif 70 <=分数<80：返回“ C” elif 60 <=分数<70 ：返回“ D” Elif得分<60：返回“ F” import randomdata = [ran_randrand（50，100）for _ in range（10）] data</p><p>    对于n个记录和m个仓的数据集，此方法的时间复杂度往往是</p><p>  由于对一个记录进行分箱需要O（m）的时间-选中O（m）if语句-并且需要对n个记录进行分箱。</p><p> 如果箱数m为常数，则整个时间复杂度仅为O（n）。</p><p> 但是，如果箱数m足够大而直接方法太慢怎么办？</p><p>bins = {“柠檬”：“柑橘”，“橙色”：“柑橘”，“苹果”：“麦莉娜”，“梨”：“麦莉娜”，} def bin_fruit（fruit）：return bins [fruit] import randomdata = random.choices（[“柠檬”，“橙色”，“苹果”，“梨”]，k = 10）数据</p><p>    这种方式对一个记录进行绑定需要O（1）时间-不管bin的数量是多少-因为字典是使用哈希表实现的。创建字典需要O（m）时间-每个bin都有一个条目。因此，对于n个记录和m个仓，总的时间复杂度为</p><p> score_bins = [60、70、80、90] score_letters = [“ F”，“ D”，“ C”，“ B”，“ A”] import bisectdef bin_score（score）：i = bisect.bisect（score_bins，得分）return score_letters [i] import randomdata = [range（10）中_的[random.randint（50，100）]</p><p>    用这种方式对一条记录进行绑定需要O（log m）时间，因为bisect.bisect使用二进制搜索来导航score_bins。创建score_bins需要O（m）时间。因此，对于n个记录和m个仓，总的时间复杂度为</p><p>  注意：如果您能够使用第三方库（例如NumPy或Pandas），请查看以下函数：numpy.digitize，numpy.searchsorted，pandas.Series.searchsorted，pandas.qcut，pandas.cut。</p><p>例如，您可以想象有一个定期报告温度的温度传感器。您希望定期报告中间温度，并能够在到达时合并新的温度数据。</p><p>  def add_new_measurement（数据，温度）：data.append（温度）def中值（数据）：返回统计信息。median（数据）import randomimport statisticsdata = [ran_randrand（93，100）for _ in range（10）] data</p><p>          因此，如果工作负载需要频繁添加新数据并且不经常计算中位数，则此方法效果很好。</p><p> 但是如果工作量倒退了怎么办？例如，如果每两分钟收到一次温度测量值，但必须每两秒钟计算一次中值。</p><p> 在那种情况下，我认为我们最好通过加快计算中位数来解决问题，即使是以减慢添加新数据的代价为代价。</p><p>如果数据已经排序，则可以在O（1）时间内完成计算订单统计信息。因此，处理此工作负载的一种直接方法是在附加数据后对数据进行排序，并利用对数据进行排序的事实来有效地计算中位数：</p><p> def add_new_measurement（数据，温度）：data.append（温度）data.sort（）def中位数（数据）：n = len（数据）如果n％2 == 0：返回（data [（n // 2）- 1] + data [n // 2]）/ 2 else：返回数据[n // 2] import randomdata = sorted（random.randint（93，100）for _ in range（10））data</p><p>          但是我认为使用bisect.insort可以进一步提高添加新数据的时间复杂度。</p><p>         在本周的帖子中，您学习了如何使用bisect模块进行统计数据装仓并将新数据添加到已排序列表中。</p><p>  像温度传感器一样，逐段处理输入的算法称为在线算法。</p><p>bisect.insort可用于实现插入排序。 Insertionsort是一种在线算法，并且与Python的内置timsort一起是一种自适应排序算法，因为它利用了部分排序的数据的优势。</p><p>   如果您喜欢本周的帖子，请与您的朋友分享，并继续关注下一周的帖子。回头见！</p><p>  （如果您发现此帖子有任何错误或错别字，请通过我的联系页面与我联系</p><p>）</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://johnlekberg.com/blog/2020-11-21-stdlib-bisect.html">https://johnlekberg.com/blog/2020-11-21-stdlib-bisect.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bisect/">#bisect</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1035786.html"><img src="http://img2.diglog.com/img/2020/11/thumb_0b936c4ed4fcaefb7422e1fcdea73cc4.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035786.html">综合数据保险库（SDV）：用于数据集建模的Python库</a></div><span class="my_story_list_date">2020-11-22 3:27</span></div><div class="col-sm"><div><a target="_blank" href="/story/1035508.html"><img src="http://img2.diglog.com/img/2020/11/thumb_0cb771c51c42645e19f2b9929865dd2f.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035508.html">Opytimizer：Python中自然启发式的计算</a></div><span class="my_story_list_date">2020-11-21 12:20</span></div><div class="col-sm"><div><a target="_blank" href="/story/1035170.html"><img src="http://img2.diglog.com/img/2020/11/thumb_09024c8ba8a46ad10f1e625297d2c9fe.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035170.html">Python创建者Guido Van Rossum加入微软后会发生什么？</a></div><span class="my_story_list_date">2020-11-15 3:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034850.html"><img src="http://img2.diglog.com/img/2020/11/thumb_6cfc335b69ffd5625609f9f8a1e20ee6.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034850.html">Python的创建者Guido van Rossum表示，他已经从退休中复出，加入了微软的开发者部门</a></div><span class="my_story_list_date">2020-11-13 19:2</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>