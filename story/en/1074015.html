<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Littlefs–一个为微控制器设计的小型故障安全文件系统Littlefs – A little fail-safe filesystem designed for microcontrollers</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Littlefs – A little fail-safe filesystem designed for microcontrollers<br/>Littlefs–一个为微控制器设计的小型故障安全文件系统</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-19 04:30:39</div><div class="page_narrow text-break page_content"><p>| | | .---._____ .-----. | |--|o |---| littlefs |--| |---| | &#39;-----&#39; &#39;----------&#39; | | |</p><p>| | | .---._____ .-----. | |--|o |--| littlefs |--| |--| | 39-----&#39; &#39;----------&#39; | | |</p><p> Power-loss resilience - littlefs is designed to handle random powerfailures. All file operations have strong copy-on-write guarantees and ifpower is lost the filesystem will fall back to the last known good state.</p><p>功率损失恢复能力——littlefs设计用于处理随机电源故障。所有文件操作都有很强的写时拷贝保证，如果断电，文件系统将恢复到上一次已知的良好状态。</p><p> Dynamic wear leveling - littlefs is designed with flash in mind, andprovides wear leveling over dynamic blocks. Additionally, littlefs candetect bad blocks and work around them.</p><p>动态磨损均衡-littlefs的设计考虑了flash，并在动态块上提供磨损均衡。此外，小家伙可以发现坏的积木，并在它们周围工作。</p><p> Bounded RAM/ROM - littlefs is designed to work with a small amount ofmemory. RAM usage is strictly bounded, which means RAM consumption does notchange as the filesystem grows. The filesystem contains no unboundedrecursion and dynamic memory is limited to configurable buffers that can beprovided statically.</p><p>有界RAM/ROM——littlefs设计用于处理少量内存。RAM使用受到严格限制，这意味着RAM消耗不会随着文件系统的增长而改变。文件系统不包含无限缓存，动态内存仅限于可静态提供的可配置缓冲区。</p><p>  Here&#39;s a simple example that updates a file named  boot_count every timemain runs. The program can be interrupted at any time without losing trackof how many times it has been booted and without corrupting the filesystem:</p><p>这里&#39；这是一个简单的例子，每次Main运行时都会更新一个名为boot_count的文件。程序可以随时中断，而不会丢失其启动次数的跟踪，也不会损坏文件系统：</p><p> # include   &#34;lfs.h &#34;  // variables used by the filesystem lfs_t lfs; lfs_file_t file;  // configuration of the filesystem is provided by this struct const  struct lfs_config cfg = {   // block device operations . read = user_provided_block_device_read, . prog = user_provided_block_device_prog, . erase = user_provided_block_device_erase, . sync = user_provided_block_device_sync,   // block device configuration . read_size =  16, . prog_size =  16, . block_size =  4096, . block_count =  128, . cache_size =  16, . lookahead_size =  16, . block_cycles =  500,};  // entry point int  main( void) {   // mount the filesystem  int err =  lfs_mount(&amp;lfs, &amp;cfg);   // reformat if we can&#39;t mount the filesystem   // this should only happen on the first boot  if (err) {  lfs_format(&amp;lfs, &amp;cfg);  lfs_mount(&amp;lfs, &amp;cfg); }   // read current count  uint32_t boot_count =  0;  lfs_file_open(&amp;lfs, &amp;file,   &#34;boot_count &#34;, LFS_O_RDWR | LFS_O_CREAT);  lfs_file_read(&amp;lfs, &amp;file, &amp;boot_count,  sizeof(boot_count));   // update boot count boot_count +=  1;  lfs_file_rewind(&amp;lfs, &amp;file);  lfs_file_write(&amp;lfs, &amp;file, &amp;boot_count,  sizeof(boot_count));   // remember the storage is not updated until the file is closed successfully  lfs_file_close(&amp;lfs, &amp;file);   // release any resources we were using  lfs_unmount(&amp;lfs);   // print the boot count  printf(  &#34;boot_count:  %d \n &#34;, boot_count);}</p><p>#包括&#34；lfs。h&#34；//文件系统lfs_t lfs使用的变量；lfs_file_t file；//文件系统的配置由这个struct const struct lfs_config cfg={//block device operations.read=user_-provided_-block_-device_-read、.prog=user_-provided_-block_-device_-erase、.sync=user_-provided_-device_-sync、//block device configuration.read_-size=16、.prog_-size=16、.block-count=128、.cache_-size=16、.lookahead_-size=16。块_循环=500，}；//入口点int main（void）{//mount the filesystem int err=lfs_mount（&amp；lfs，&amp；cfg）；//如果我们能够&#39；t mount the filesystem，请重新格式化//读取当前计数uint32\u t boot\u count=0；lfs_file_open（&amp；lfs，&amp；file，&34；boot_count&#34；，lfs_O_RDWR | lfs_O_CREAT）；lfs_file_read（&amp；lfs，&amp；file，&amp；boot_count，sizeof（boot_count））；//更新引导计数引导计数+=1；lfs_文件_倒带（&amp；lfs，&amp；文件）；lfs_file_write（&amp；lfs，&amp；file，&amp；boot_count，sizeof（boot_count））；//请记住，只有成功关闭文件（lfs_file_close（&amp；lfs，&amp；file）；//释放我们使用lfs_unmount（&amp；lfs）的所有资源；//打印启动计数printf（&#34；启动计数：%d\n&#34；启动计数）；）</p><p>  Detailed documentation (or at least as much detail as is currently available)can be found in the comments in  lfs.h.</p><p>详细的文档（或至少是目前可用的尽可能多的细节）可以在lfs的评论中找到。H</p><p> littlefs takes in a configuration structure that defines how the filesystemoperates. The configuration struct provides the filesystem with the blockdevice operations and dimensions, tweakable parameters that tradeoff memoryusage for performance, and optional static buffers if the user wants to avoiddynamic memory.</p><p>littlefs采用了一种配置结构，定义了文件系统的操作方式。configuration struct为文件系统提供了块设备操作和维度、可调整的参数，这些参数可以在内存使用和性能之间进行权衡，如果用户希望避免动态内存，还可以提供可选的静态缓冲区。</p><p> The state of the littlefs is stored in the  lfs_t type which is left upto the user to allocate, allowing multiple filesystems to be in usesimultaneously. With the  lfs_t and configuration struct, a user canformat a block device or mount the filesystem.</p><p>littlefs的状态存储在lfs_t类型中，由用户分配，允许多个文件系统同时使用。使用lfs_t和配置结构，用户可以格式化块设备或挂载文件系统。</p><p> Once mounted, the littlefs provides a full set of POSIX-like file anddirectory functions, with the deviation that the allocation of filesystemstructures must be provided by the user.</p><p>一旦安装，littlefs就提供了一整套类似POSIX的文件和目录功能，不同之处在于文件系统结构的分配必须由用户提供。</p><p> All POSIX operations, such as remove and rename, are atomic, even in eventof power-loss. Additionally, file updates are not actually committed tothe filesystem until sync or close is called on the file.</p><p>所有POSIX操作，例如删除和重命名，都是原子操作，即使在断电的情况下也是如此。此外，在文件上调用sync或close之前，文件更新实际上不会提交到文件系统。</p><p>  Littlefs is written in C, and specifically should compile with any compilerthat conforms to the  C99 standard.</p><p>Littlefs是用C编写的，特别是应该使用任何符合C99标准的编译器进行编译。</p><p> All littlefs calls have the potential to return a negative error code. Theerrors can be either one of those found in the  enum lfs_error in lfs.h, or an error returned by the user&#39;s block device operations.</p><p>所有littlefs调用都可能返回一个否定的错误代码。错误可以是在lfs中的enum lfs_错误中找到的其中一个。h、 或者用户返回的错误&#39；阻止设备操作。</p><p> In the configuration struct, the  prog and  erase function provided by theuser may return a  LFS_ERR_CORRUPT error if the implementation already candetect corrupt blocks. However, the wear leveling does not depend on the returncode of these functions, instead all data is read back and checked forintegrity.</p><p>在配置结构中，如果实现已检测到损坏块，则用户提供的prog和erase函数可能会返回LFS_ERR_CORRUPT error。然而，磨损水平不取决于这些函数的返回代码，而是将所有数据读回并检查完整性。</p><p> If your storage caches writes, make sure that the provided  sync functionflushes all the data to memory and ensures that the next read fetches the datafrom memory, otherwise data integrity can not be guaranteed. If the  writefunction does not perform caching, and therefore each  read or  write callhits the memory, the  sync function can simply return 0.</p><p>如果存储缓存写操作，请确保提供的同步功能将所有数据刷新到内存中，并确保下一次读取从内存中获取数据，否则无法保证数据完整性。如果writefunction不执行缓存，因此每次读或写调用都会命中内存，那么同步函数可以简单地返回0。</p><p>  At a high level, littlefs is a block based filesystem that uses small logs tostore metadata and larger copy-on-write (COW) structures to store file data.</p><p>从高层来看，littlefs是一个基于块的文件系统，它使用小日志存储元数据，使用较大的写时拷贝（COW）结构存储文件数据。</p><p> In littlefs, these ingredients form a sort of two-layered cake, with the smalllogs (called metadata pairs) providing fast updates to metadata anywhere onstorage, while the COW structures store file data compactly and without anywear amplification cost.</p><p>在littlefs中，这些成分形成了一种两层蛋糕，小日志（称为元数据对）提供了对存储中任何地方的元数据的快速更新，而COW结构紧凑地存储文件数据，没有任何开销。</p><p> Both of these data structures are built out of blocks, which are fed by acommon block allocator. By limiting the number of erases allowed on a blockper allocation, the allocator provides dynamic wear leveling over the entirefilesystem.</p><p>这两种数据结构都是由块构建的，这些块由一个公共块分配器提供。通过限制blockper分配上允许的擦除次数，分配器提供了整个系统的动态磨损均衡。</p><p> root .--------.--------. | A&#39;| B&#39;| | | | |-&gt; | | | | | &#39;--------&#39;--------&#39; .----&#39; &#39;--------------. A v B v .--------.--------. .--------.--------. | C&#39;| D&#39;| | | E&#39;|new| | | | |-&gt; | | | E&#39;|-&gt; | | | | | | | | | &#39;--------&#39;--------&#39; &#39;--------&#39;--------&#39; .-&#39; &#39;--. | &#39;------------------. v v .-&#39; v.--------. .--------. v .--------.| C | | D | .--------. write | new E || | | | | E | ==&gt; | || | | | | | | |&#39;--------&#39; &#39;--------&#39; | | &#39;--------&#39; &#39;--------&#39; .-&#39; | .-&#39; &#39;-. .-------------|------&#39; v v v v .--------. .--------. .--------. | F | | G | | new F | | | | | | | | | | | | | &#39;--------&#39; &#39;--------&#39; &#39;--------&#39;</p><p>根。-------------.|A&#39；|B&#39；| | | ||-&gt；| | | |&#39;--------&#39;--------&#39; .----&#39; &#39;--------------. A v B v。-------------------------|C&#39；|D&#39；| | |E&#39|新的| | | | |-&gt；| | |E&#39|-&gt；| | | | | | |&#39;--------&#39;--------&#39; &#39;--------&#39;--------&#39; .-&#39; &#39;--. | &#39;------------------. v v-&#39; v、 ---------。v.--------|C | | D |.----------。写|新E | | | | | | E |=&gt；| | | | ||&#39;--------&#39; &#39;--------&#39; | | &#39;--------&#39; &#39;--------&#39; .-&#39; | .-&#39; &#39;-. .-------------|------&#39; v v v。-------------------------F | | G | | | | | | | | | | | | | | |和#39--------&#39; &#39;--------&#39; &#39;--------&#39;</p><p>  DESIGN.md - A fully detailed dive into how littlefs works.I would suggest reading it as the tradeoffs at work are quite interesting.</p><p>设计md——详细了解littlefs的工作原理。我建议读一下，因为工作中的权衡是很有趣的。</p><p> SPEC.md - The on-disk specification of littlefs with all thenitty-gritty details. May be useful for tooling development.</p><p>SPEC.md——littlefs的磁盘规格，包括所有不完整的细节。可能对工具开发有用。</p><p>  The littlefs comes with a test suite designed to run on a PC using the emulated block device found in the  bd directory.The tests assume a Linux environment and can be started with make:</p><p>littlefs附带了一个测试套件，可以使用bd目录中的模拟块设备在PC上运行。测试假设为Linux环境，可以使用make启动：</p><p>   The littlefs is provided under the  BSD-3-Clause license. See LICENSE.md for more information. Contributions to this projectare accepted under the same license.</p><p>littlefs是根据BSD-3条款许可证提供的。见许可证。md了解更多信息。对本项目的贡献在同一许可下被接受。</p><p>   This enables machine processing of license information based on the SPDXLicense Identifiers that are here available:  http://spdx.org/licenses/</p><p>这使机器能够根据此处提供的SPDXLicense标识符处理许可证信息：http://spdx.org/licenses/</p><p>  littlefs-fuse - A  FUSE wrapper for littlefs. The project allows you tomount littlefs directly on a Linux machine. Can be useful for debugginglittlefs if you have an SD card handy.</p><p>littlefs fuse-用于littlefs的保险丝包装。该项目允许您直接在Linux机器上安装littlefs。如果你手边有SD卡，这对调试小文件很有用。</p><p> littlefs-js - A javascript wrapper for littlefs. I&#39;m not sure why you wouldwant this, but it is handy for demos. You can see it in action here.</p><p>littlefs js——littlefs的javascript包装。我&#39；我不知道你为什么想要这个，但它对演示很方便。你可以在这里看到它的作用。</p><p> littlefs-python - A Python wrapper for littlefs. The project allows youto create images of the filesystem on your PC. Check if littlefs will fityour needs, create images for a later download to the target memory orinspect the content of a binary image of the target memory.</p><p>littlefs python——littlefs的python包装。该项目允许您在PC上创建文件系统的映像。检查littlefs是否符合您的需要，创建映像以便稍后下载到目标内存，或者检查目标内存的二进制映像的内容。</p><p> mklfs - A command line tool built by the  Lua RTOS guys for makinglittlefs images from a host PC. Supports Windows, Mac OS, and Linux.</p><p>mklfs——一个由Lua RTOS人员构建的命令行工具，用于从主机PC生成Littlefs图像。支持Windows、Mac OS和Linux。</p><p> Mbed OS - The easiest way to get started with littlefs is to jump into Mbedwhich already has block device drivers for most forms of embedded storage.littlefs is available in Mbed OS as the  LittleFileSystem class.</p><p>Mbed操作系统——开始使用littlefs最简单的方法是跳转到Mbed，它已经为大多数形式的嵌入式存储提供了块设备驱动程序。littlefs在Mbed操作系统中作为LittleFileSystem类提供。</p><p> SPIFFS - Another excellent embedded filesystem for NOR flash. As a moretraditional logging filesystem with full static wear-leveling, SPIFFS willlikely outperform littlefs on small memories such as the internal flash onmicrocontrollers.</p><p>SPIFFS是NOR flash的另一个优秀的嵌入式文件系统。作为一个更传统的日志文件系统，SPIFFS具有完全的静态磨损均衡功能，在小型内存（如Microcontrollers上的内部闪存）方面，它的性能可能会优于littlefs。</p><p> Dhara - An interesting NAND flash translation layer designed for smallMCUs. It offers static wear-leveling and power-resilience with only a fixed O(|address|) pointer structure stored on each block and in RAM.</p><p>Dhara-一个有趣的NAND闪存转换层，专为SmallMCU设计。它只在每个块和RAM中存储一个固定的O（|地址|）指针结构，提供静态磨损均衡和电源恢复能力。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/微控制器/">#微控制器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fail/">#fail</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/littlefs/">#littlefs</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>