<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>反模糊：阻碍二进制可执行文件的模糊审计AntiFuzz: Impeding Fuzzing Audits of Binary Executables</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">AntiFuzz: Impeding Fuzzing Audits of Binary Executables<br/>反模糊：阻碍二进制可执行文件的模糊审计</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-22 02:05:08</div><div class="page_narrow text-break page_content"><p>Fuzzing is one of the most widely used and successful methods of finding security vulnerabilities in software programs. Fuzzing tools automatically and randomly generates input to a program, and run the program using these inputs until it crashes. These crashes usually indicate the presence of a security vulnerability that can be exploited by an attacker.</p><p>模糊化是在软件程序中发现安全漏洞最广泛、最成功的方法之一。Fuzzing工具会自动随机生成程序的输入，并使用这些输入运行程序，直到程序崩溃。这些崩溃通常表示存在可被攻击者利用的安全漏洞。</p><p>  But fuzzing can also be used by attackers who want to exploit the program. Can we therefore make our program difficult to fuzz so an attacker can not detect any hidden vulnerability in our program? To find out, the authors of this paper developed strategies that make fuzzing a program difficult. They identified some assumptions that existing fuzzing tools depend on to work successfully then developed a tool, AntiFuzz, that can be used to modify the target program and impede fuzzing. Some assumptions and counter-measures include:</p><p>但是，想要利用该程序进行攻击的攻击者也可以使用模糊技术。因此，我们能否使我们的程序难以模糊化，从而使攻击者无法检测到我们程序中的任何隐藏漏洞？为了找到答案，本文的作者开发了一些策略，使得模糊化程序变得困难。他们确定了现有模糊化工具成功工作所依赖的一些假设，然后开发了一个工具AntiFuzz，可用于修改目标程序并阻止模糊化。一些假设和对策包括：</p><p>  Fuzzers try to generate inputs that can transverse all parts of the program code using coverage information. Hence, if we can make our program return false coverage information, fuzzing would be significantly impeded. To achieve this, AntiFuzz returns different, fake coverage information for each input to the program.</p><p>模糊程序试图利用覆盖率信息生成可以跨越程序代码所有部分的输入。因此，如果我们能让我们的程序返回虚假的覆盖信息，模糊化将受到极大的阻碍。为了实现这一点，AntiFuzz为程序的每个输入返回不同的虚假覆盖信息。</p><p>  Fuzzers monitor the operating system in order to detect program crashes. To counter this, AntiFuzz sends fake crash signals to the operating systems.</p><p>模糊程序监控操作系统以检测程序崩溃。为了应对这种情况，AntiFuzz向操作系统发送虚假的崩溃信号。</p><p>  Fuzzers need to execute the program many times per second in order to operate efficiently. Since most of the input generated by the fuzzers is malformed, AntiFuzz slows the program down when it detects such inputs.	While this slowdown would not be noticed by a normal user, it can significantly impede the efficient operation of the fuzzer.</p><p>模糊程序需要每秒执行多次程序才能有效运行。由于fuzzers生成的大多数输入都是错误的，因此当反模糊程序检测到这些输入时，它会减慢程序的速度。虽然正常用户不会注意到这种减速，但它会严重阻碍fuzzer的高效运行。</p><p>  To see if their approach actually worked, the authors used four different state-of-the-art fuzzers to fuzz a set of target programs which contained several bugs. Their results show that AntiFuzz successfully prevented the detection of all bugs previously detected when all the counter-measures were applied.</p><p>为了看看他们的方法是否真的有效，作者使用了四种不同的最先进的模糊器来模糊一组包含几个bug的目标程序。他们的结果表明，在采取所有应对措施时，AntiFuzz成功地阻止了之前检测到的所有漏洞的检测。</p><p>  I love their approach to impeding fuzzing because it combines multiple measures. However, by making the publicly deployed and accessible version of a program resistant to fuzzing, this would restrict the fuzzing operation to only the program developers, impeding the detection of security vulnerabilities by security researchers and white hat hackers who also rely on fuzzing.</p><p>我喜欢他们阻止模糊化的方法，因为它结合了多种措施。然而，通过使公开部署和可访问的程序版本抵抗模糊化，这将使模糊化操作仅限于程序开发人员，从而妨碍同样依赖模糊化的安全研究人员和白帽黑客检测安全漏洞。</p><p> GulerAntifuzz2019 Emre Güler, Cornelius Aschermann, Ali Abbasi, and Thorsten Holz: &#34; AntiFuzz: Impeding Fuzzing Audits of Binary Executables&#34;.  2019 USENIX Security Symposium.</p><p>Gulerantifuzzz2019 Emre Güler、Cornelius Aschermann、Ali Abbasi和Thorsten Holz:&#34；反模糊：阻碍二进制可执行文件的模糊审计；。2019年USENIX安全研讨会。</p><p> A general defense strategy in computer security is to increase the cost of successful attacks in both computational resources as well as human time. In the area of binary security, this is commonly done by using obfuscation methods to hinder reverse engineering and the search for software vulnerabilities. However, recent trends in automated bug finding changed the modus operandi. Nowadays it is very common for bugs to be found by various fuzzing tools. Due to ever-increasing amounts of automation and research on better fuzzing strategies, large-scale, dragnet-style fuzzing of many hundreds of targets becomes viable. As we show, current obfuscation techniques are aimed at increasing the cost of human understanding and do little to slow down fuzzing.</p><p>计算机安全中的一种通用防御策略是增加成功攻击的计算资源和人力成本。在二进制安全领域，这通常是通过使用模糊处理方法来阻止逆向工程和搜索软件漏洞来实现的。然而，最近在自动错误查找方面的趋势改变了操作方式。如今，通过各种模糊工具发现bug是很常见的。由于越来越多的自动化和对更好的模糊策略的研究，对数百个目标进行大规模、拖网式模糊变得可行。正如我们所展示的，当前的模糊处理技术旨在增加人类理解的成本，对减缓模糊化几乎没有作用。</p><p>  In this paper, we introduce several techniques to protect a binary executable against an analysis with automated bug f inding approaches that are based on fuzzing, symbolic/concolic execution, and taint-assisted fuzzing (commonly known as hybrid fuzzing). More specifically, we perform a systematic analysis of the fundamental assumptions of bug finding tools and develop general countermeasures for each assumption. Note that these techniques are not designed to target specific implementations of fuzzing tools, but address general assumptions that bug finding tools necessarily depend on. Our evaluation demonstrates that these techniques effectively impede fuzzing audits, while introducing a negligible performance overhead. Just as obfuscation techniques increase the amount of human labor needed to find a vulnerability, our techniques render automated fuzzing-based approaches futile.</p><p>在本文中，我们介绍了几种技术，以保护二进制可执行文件不受基于模糊、符号/协同执行和污染辅助模糊（通常称为混合模糊）的自动缺陷发现方法的分析的影响。更具体地说，我们对缺陷发现工具的基本假设进行系统分析，并为每个假设制定一般对策。请注意，这些技术不是针对模糊工具的特定实现而设计的，而是针对bug查找工具必须依赖的一般假设。我们的评估表明，这些技术有效地阻止了模糊审计，同时带来了微不足道的性能开销。正如模糊处理技术增加了发现漏洞所需的人力，我们的技术也使得基于模糊处理的自动化方法无效。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/二进制/">#二进制</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/impeding/">#impeding</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>