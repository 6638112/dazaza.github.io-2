<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>CSS容器在Web组件中查询 CSS Container Queries in Web Components</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">CSS Container Queries in Web Components<br/>CSS容器在Web组件中查询 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-16 21:07:39</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/01fa27fcc177ab731dc2286a676c30b7.jpg"><img src="http://img2.diglog.com/img/2021/5/01fa27fcc177ab731dc2286a676c30b7.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Container Queries are one of the most anticipated new features in CSS. I recently got a chance to play with them a bit to take the new syntax for a spin.</p><p>容器查询是CSS中最常用的新功能之一。我最近有机会与他们一起玩一些旋转的新语法。</p><p> I came up with this demo of a book store. Each of the books is draggable and can be moved to one of three sections, with varying available space. Depending on where it is placed, different styles will be applied to the book. The  full source code is up on Codepen. Here’s how it looks:</p><p> 我想出了这款书店的演示。每本书都可以拖动，可以移动到三个部分中的一个，具有不同的可用空间。根据放置的位置，不同的风格将应用于书籍。 CODEPEN上的完整源代码。这是它看起来的看法：</p><p>  This demo currently only works in  Chrome Canary. Download the latest version, then enable Container Queries under  chrome://flags to see them in action.</p><p>  此演示目前仅在Chrome Canary工作。下载最新版本，然后在Chrome下启用容器查询：//标志以查看它们。</p><p>  Each of these books is a custom element, or “web component”. They each contain a cover image, a title and an author. In markup they look like this:</p><p>  这些书籍中的每一个都是自定义元素或“Web组件”。它们每个都包含一个封面图像，标题和作者。在标记中，他们看起来像这样：</p><p>  This then gets applied to a template which defines the internal Shadow DOM of the component. The  &lt;slot&gt; elements in there will get replaced by the actual content we’re passing in.</p><p>  然后，它将应用于定义组件的内部阴影DOM的模板。 ＆lt; slot＆gt;将通过我们传递的实际内容替换。</p><p>   The magic happens when we apply some internal styling to this. Everything inside that  &lt;style&gt; tag will be scoped to the component - and since styles can not leak out of the shadow DOM and we can’t (easily) style its contents from the outside, we have real component encapsulation.</p><p>   当我们对此应用一些内部样式时，魔法就会发生。内部内部的一切＆lt; style＆gt;标签将被选中到组件 - 而且由于样式无法泄漏出暗影DOM，而且我们不能（轻松地）从外部中的内容中的内容，我们有真正的组件封装。</p><p> Container Queries are one of the last few missing puzzle pieces in component-driven design. They enable us to give components  intrinsic styles, meaning they can adapt themselves to whatever surroundings they are placed in.</p><p> 容器查询是组件驱动设计中的最后几个丢失的拼图之一。它们使我们能够提供组件内在风格，这意味着它们可以使自己适应它们的任何周围环境。 </p><p> The new key property there is  contain - it lets us define an element as a container to compare container queries against. A value of  layout indicates that nothing outside the element may affect its internal layout and vice versa.</p><p>包含的新关键属性包含 - 它允许我们将元素定义为容器以比较容器查询。 Layout的值表示元素外部的内部不影响其内部布局，反之亦然。</p><p> This allows the browser to optimize the number of calculations necessary to create the page layout. By adding  inline-size to the rule, we also tell the browser to respond to changes in width of the container.</p><p> 这允许浏览器优化创建页面布局所需的计算次数。通过向规则添加内联大小，我们还告诉浏览器响应容器宽度的变化。</p><p> /* Use Web Component as the Layout Container */   :host  {   display : block ;   contain : layout inline-size ;   }     ...</p><p> / *使用Web组件作为布局容器* /：host {display：block;包含：布局内联尺寸; } ......</p><p> In the bookstore demo, I created three variants that depend on the width of the component’s  :host (which translates to the  &lt;book-element&gt; itself). I’ve omitted some of the styling for brevity here, but this part is where we define the multi-column or 3D book styles.</p><p> 在书店演示中，我创建了三个依赖于组件：主机的宽度的变体（它转换为＆lt; book-compent＆gt;本身）。我省略了一些在这里的简洁性的样式，但这部分是我们定义多列或3D书样式的地方。</p><p> /* Small Variant: Simple Cover + Title */   @container  ( max-width : 199px )  {   .book  {   padding : 0 ;   }  }  /* Medium Variant: Multi-Column, with Author */   @container  ( min-width : 200px )  and  ( max-width : 399px )  {   .book  {   display : grid ;   grid-template-columns : 1fr 1fr ;   gap : 1rem ;   }  }  /* Large Variant: 3D Perspective */   @container  ( min-width : 400px )  {   .book  {   position : relative ;   transform-style : preserve-3d ;   transform :  rotateY (-25deg ) ;   }  }</p><p> / *小变种：简单封面+标题* / @container（max-width：199px）{.book {padding：0; }} / *介质变量：多列，带作者* / @container（min-width：200px）和（max-width：399px）{.book {display：grid;网格模板列：1FR 1FR;差距：1REM; } / *大型变体：3D透视图* / @container（min-width：400px）{.book {位置：相对;变换风格：Preserve-3D;变换：旋转（-25deg）; }}</p><p> By adding  Dragula.js to enable drag-and-drop functionality, we can then move the individual components around. As soon as they’re moved to a different section in the DOM, its internal styles are re-calculated to match the new environment, and the corresponding CSS block is applied. Magic!</p><p> 通过添加Dragula.js来启用拖放功能，我们可以移动各个组件。一旦它们移动到DOM中的不同部分，它就会重新计算其内部样式以匹配新环境，并且应用相应的CSS块。魔法！</p><p>  Now theoretically, we could have achieved a similar effect by using the cascade itself. We could for example apply the 3D styles to all  .books inside  .stage. But that would have some problems:</p><p>  现在，我们可以通过使用级联本身来实现类似的效果。例如，我们可以将3D样式应用于所有.books .stage。但这会有一些问题： </p><p> it wouldn’t be responsive - if  .stage ever gets too narrow, it would break</p><p>它不会响应 - 如果.stage曾经太狭窄了，它会破裂</p><p> It’s generally a  good idea in CSS to separate “layout” from “content” components and let each handle their own specific areas of responsibility. I like to think of Japanese bento boxes as a metaphor for this: a container divided into specific sections that can be filled with anything.</p><p> 在CSS中，从“内容”组件中分开“布局”，这通常是一个好主意，并让每个人处理自己的特定责任领域。我喜欢将日本的Bento盒子视为一个隐喻：一个容器分为可以充满任何东西的具体部分。</p><p>   It’s a grid divided into three sections, the middle one containing a nested flexible grid itself.</p><p>   它是一个分为三个部分的网格，中间包含嵌套的灵活网格本身。</p><p>  /* main layout sections */  .stage, .content, .cart  {   padding :  var (--spacing ) ;  }   /* nested sub-grid */  .itemlist  {   display : grid ;   grid-template-columns :  repeat (auto-fill ,  minmax (200px , 1fr ) ) ;   gap :  var (--spacing ) ;  }   /* desktop layout */   @media  ( min-width : 1024px )  {   .layout  {   display :grid ;   height : 100vh ;   grid-template-columns : 480px 1fr 130px ;   }  }</p><p>  / *主布局部分* / .stage，.content，.cart {填充：var（--spacing）; } / *嵌套子网格* / .itemlist {显示：网格;网格模板列：重复（自动填充，minmax（200px，1fr））;差距：var（--spacing）; } / *桌面布局* / @media（min-width：1024px）{.layout {display：grid;身高：100VH;网格模板列：480px 1fr 130px; }}</p><p> The parts of the layout are only concerned with the alignment and dimensions of boxes. They have no effect whatsoever on their children other than giving them a certain amount of space to fill. Just like a bento box, it doesn’t care what we put into it, so we could easily re-use the layout for a completely different product. It is  content-agnostic.</p><p> 布局的部分仅涉及盒子的对齐和尺寸。除了为他们提供一定的空间以外，他们对他们的孩子没有任何影响。就像一个Bento盒子一样，它不在乎我们投入的东西，因此我们可以轻松重新使用完全不同产品的布局。它是满足的无话可标。</p><p> That’s why Container Queries pair so well with CSS Grid. Grid defines a flexible layout from the outside, while container queries adapt whatever content sits inside it to the optimal size for the available space.</p><p> 这就是为什么容器查询与CSS网格相吻合。 Grid定义了从外部的灵活布局，而容器查询适应其内部的内容，以实现可用空间的最佳大小。</p><p> Container Queries bring us one step closer to  “Intrinsic Layouts” and a future of truly independent, component-driven design. Exciting stuff ahead!</p><p> 容器查询为我们带来了一个更接近“内在布局”的一步，以及真正独立，组件驱动的设计的未来。令人兴奋的东西！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://mxb.dev/blog/container-queries-web-components/">https://mxb.dev/blog/container-queries-web-components/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/容器/">#容器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/container/">#container</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/组件/">#组件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>