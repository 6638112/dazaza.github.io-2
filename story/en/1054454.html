<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么OO糟糕的乔阿姆斯特朗（2000） Why OO Sucks by Joe Armstrong (2000)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why OO Sucks by Joe Armstrong (2000)<br/>为什么OO糟糕的乔阿姆斯特朗（2000） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-26 20:19:57</div><div class="page_narrow text-break page_content"><p>When I was first introduced to the idea of OOP I was skeptical butdidn’t know why - it just felt “wrong”. After its introduction OOPbecame very popular (I will explain why later) and criticising OOP wasrather like “swearing in church”. OOness became something that everyrespectable language just had to have.</p><p>当我第一次介绍OOP的想法时，我持怀疑态度，不知道为什么 - 它只是觉得“错误”。在它引入oopbecame之后非常受欢迎（我将解释为什么以后）并批评像“在教堂咒骂”这样的oop。 Ooness成为刚刚拥有的所有门口的语言。</p><p> As Erlang became popular we were often asked “Is Erlang OO” -well, of course the true answer was “No of course not” - but we didn’tto say this out loud - so we invented a serious of ingenious ways ofanswering the question that were designed to give the impression that Erlangwas (sort of) OO (If you waved your hands a lot) but not really (If youlistened to what we actually said, and read the small print  carefully).</p><p> 随着erlang变得流行我们经常被问到“是erlang oo” - 当然，真正的答案是“当然不是” - 但我们没有大声说出来 - 所以我们发明了一个严肃的巧妙方式的问题这是旨在给人的印象，即erlangwas（有点）oo（如果你挥手了很多），但不是真的（如果是你实际上所说的话，并仔细阅读小字）。</p><p> At this point I am reminded of the keynote speech of the thenboss of IBM in France who addressed the audience at the 7th IEEE Logicprogramming conference in Paris. IBM prolog had added a lot of OOextensions, when asked why he replied:</p><p> 此时，我提醒在法国的IBM of IBM的主题演讲，他们在巴黎的第7届IEEE Logicagramming会议上讨论了观众。 IBM Prolog添加了很多ooextensions，当被问及为什么他回答：</p><p>  I remember thinking “how simple, no qualms of conscience, nosoul-searching, no asking &#34;Is this the right thing to do” …</p><p>  我记得思考“有多么简单，良心，诺萨尔搜索，没有问＆＃34;这是正确的事情”......</p><p>  My principle objection to OOP goes back to the basic ideas involved,I will outline some of these ideas and my objections to them.</p><p>  我对OOP的原则反对追溯到所涉及的基本想法，我将概述其中一些想法和对他们的反对意见。</p><p>  Objects bind functions and data structures togetherin indivisible units. I think this is a fundamental error sincefunctions and data structures belong in totally different worlds. Why is this?</p><p>  对象绑定功能和数据结构在一起不可分割的单位。我认为这是一个根本错误，因为功能和数据结构属于完全不同的世界。为什么是这样？</p><p> *Functions do things. They have inputs and outputs. The inputs andoutputs are data structures, which get changed by the functions. Inmost languages functions are built from sequences of imperatives: “Dothis and then that …” to understand functions you have to understandthe order in which things get done (In lazy FPLs and logical languagesthis restriction is relaxed).</p><p> *功能做事。他们有输入和输出。输入和输出量是数据结构，其通过函数更改。最黑色的函数是从命令员的序列构建的：“dothis然后那个......”了解你必须了解完成事情的顺序（在懒惰的FPLS和逻辑andlecysthis限制中放宽）。 </p><p> Data structures just are. They don’t do anything. They are intrinsicallydeclarative. “Understanding” a data structure is a lot easier than“understanding” a function.</p><p>数据结构就是。他们什么都不做。它们是内在的偏振。 “了解”数据结构比“了解”功能更容易。</p><p> Functions are understood as black boxes that transform inputs tooutputs. If I understand the input and the output then I haveunderstood the function.  This does not mean to say that I couldhave written the function.</p><p> 函数被理解为变换输入待消费的黑匣子。如果我理解输入和输出，那么我覆盖了该功能。这并不意味着说我可以写入该功能。</p><p> Functions are usually “understood”by observing that they are the things in a computational system whose jobis to transfer data structures of type T1 into data structure of type T2.</p><p> 通过观察它们是计算系统中的东西，通常“理解”的功能通常是在T2型数据结构中转移T1类型的数据结构。</p><p> Since functions and data structures are completely different types ofanimal it is fundamentally incorrect to lock them up in the same cage.</p><p> 由于函数和数据结构是完全不同的类型，因此在同一笼子中锁定它们是根本的不正确。</p><p>  Consider “time”. In an OO language “time” has to be an object.But in a non OO language a “time” is a instance ofa data type. For example, in Erlang there are lots of differentvarieties of time, these can be clearly and unambiguously specifiedusing type declarations, as follows:</p><p>  考虑“时间”。在OO语言中，“时间”必须是一个对象。在非OO语言中，“时间”是数据类型的实例。例如，在erlang中有很多不同的时间，这些可以清楚地明确地指定类型声明，如下所示：</p><p> -deftype day() = 1..31.-deftype month() = 1..12.-deftype year() = int().-deftype hour() = 1..24.-deftype minute() = 1..60.-deftype second() = 1..60.-deftype abstime() = {abstime, year(), month(), day(), hour(), min(), sec()}.-deftype hms() = {hms, hour(), min(), sec()}....</p><p> -deftype day（）= 1..31.-deftype月份（）= 1..12.-deftype年（）= int（）.- deftype小时（）= 1..24。-deftype mimon（）= 1 ..60.-deftype second（）= 1..60.-deftype abstime（）= {abstime，年（），月（），day（），小时（），min（），sec（）} .- deftype hms（）= {hms，hours（），min（），sec（）} ....</p><p> Note that these definitions do not belong to any particular object.they are ubiquitous and data structures representing times can bemanipulated by any function in the system.</p><p> 请注意，这些定义不属于任何特定对象。它们是无处不在的，并且代表时间的数据结构可以通过系统中的任何功能Bippute。 </p><p>  Objection 3 - In an OOPL data type definitions are spread out all over the place</p><p>异议3  - 在OOPL数据类型定义中分布在整个地方</p><p> In an OOPL data type definitions belong to objects. So I can’t findall the data type definition in one place. In Erlang or C I can defineall my data types in a single include file or data dictionary. In an OOPLI can’t - the data type definitions are spread out all over the place.</p><p> 在OOPL数据类型定义中属于对象。因此，我无法在一个地方找到数据类型定义。在erlang或c中，我可以在单个包含文件或数据字典中确定我的数据类型。在一个OOPLI中，无法 - 数据类型定义遍布到处。</p><p> Let me give an example of this. Suppose I want to define aubiquitous data structure.  ubiquitous data type is a data typethat occurs “all over the place” in a system.</p><p> 让我举个例子。假设我想定义辅助数据结构。无处不在的数据类型是数据类型，在系统中发生“全部遍布”。</p><p> As lisp programmers have know for a long time it is better to havea smallish number of ubiquitous data types and a large number of smallfunctions that work on them, than to have a large number of data typesand a small number of functions that work on them.</p><p> 随着Lisp程序员长期以来，它更好地HAVEA占据了无处不在的数据类型和对它们的大量小型功能，而不是拥有大量数据类型和对它们工作的少量功能。</p><p> A ubiquitous data structure is something like a linked list, or an arrayor a hash table or a more advanced object like a time or date or filename.</p><p> 无处不在的数据结构类似于链接列表，或者散列表或哈希表或更高级对象，如时间或日期或文件名。</p><p> In an OOPL I have to choose some base object in which I will definethe ubiquitous data structure, all other objects that want to usethis data structure must inherit this object. Suppose now I want tocreate some “time” object, where does this belong and in which object…</p><p> 在一个OOPL中必须选择一些基础对象，其中我将默认的数据结构彻底，所有想要的数据结构都必须继承此对象。假设现在我想要一些“时间”对象，这属于哪些对象......</p><p>  State is the root of all evil. In particular functions with side effectsshould be avoided.</p><p>  国家是所有邪恶的根源。特别是具有副作用的功能应该避免。 </p><p> While state in programming languages is undesirable, in the realworld state abounds. I am highly interested in the state of my bankaccount, and when I deposit or withdraw money from my bank I expectthe state of my bank account to be correctly updated.</p><p>虽然在RealWorld StateBounds中，在编程语言中的状态是比比。我对我的银行业的状态非常感兴趣，当我从银行存入或取款时，我预计我的银行账户的状态被正确更新。</p><p> Given that state exists in the real world what facilitiesshould programming language provide for dealing with state?</p><p> 鉴于现实世界存在的状态存在哪些有限公司的编程语言提供处理状态？</p><p> OOPLs say “hide the state from the programmer”. The states is hidden and visible only through access functions.</p><p> OOPLS说“隐藏程序员的状态”。只能通过访问功能隐藏和可见状态。</p><p> Conventional programming languages (C, Pascal) say that the visibility of state variables is controlled by the scope rules of the language.</p><p> 传统的编程语言（C，Pascal）表示，状态变量的可见性由语言的范围规则控制。</p><p> The global state of thesystem is carried into all functions and comes out from all functions.Mechanisms like monads (for FPLs) and DCGs (logic languages) are used tohide state from the programmer so they can program “as if state didn’t matter”but have full access to the state of the system should this be necessary.</p><p> 全球和谐的状态被带入所有职能，并从所有函数中出来。Monad（FPLS）和DCGS（逻辑语言）等机制用于从程序员那样用于将状态进行，因此他们可以编程“仿佛似乎并不重要”但是，应该完全访问系统的状态。</p><p> The “hide the state from the programmer” option chosen by OOPLs is theworse possible choice. Instead of revealing the state andtrying to find ways to minimise the nuisance of state, they hide itaway.</p><p> OOLTS选择的“隐藏程序员的状态”选项是Worworse可能的选择。他们不是揭示国家和特生来寻找最小化状态滋扰的方法，而是隐藏它。</p><p>   I see no evidence of 1 and 2. Reasons 3 and 4 seem to be the drivingforce behind the technology. If a language technology is so bad thatit creates a new industry to solve problems of its own making thenit must be a good idea for the guys who want to make money.</p><p>   我没有看到1和2的证据。原因3和4似乎是技术背后的推动力。如果语言技术如此糟糕，那就创造了一个新的行业来解决自己的问题问题，这对想要赚钱的人来说一定是一个好主意。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://harmful.cat-v.org/software/OO_programming/why_oo_sucks">http://harmful.cat-v.org/software/OO_programming/why_oo_sucks</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/oo/">#oo</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sucks/">#sucks</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/状态/">#状态</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>