<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Eytzinger二进制搜索 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Eytzinger二进制搜索 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-05 18:57:32</div><div class="page_narrow text-break page_content"><p>本教程松散地基于Paul-Virak Khuong和Pat Morin为比较的搜索阵列布局的46页纸张，并描述了通过在缓存友好中重新排列排序阵列的元素来执行有效二进制搜索的一种特定方式方法。</p><p> 我们简要介绍处理器架构中的相关概念;如果您想更深，我们建议您阅读原始2015纸，以及这些文章：</p><p>  我们的简约实现仅限〜15行代码，同时提供4-5倍的Speedup over std :: dight_bound。精确加速度在可用的内存带宽上取决于很多（请参阅下面的注释）。</p><p> 如果您现在正在写一场比赛，请卡在二进制搜索是一个瓶颈的问题上，突然记住了这篇文章，直接跳转到“完成”，它是可编译和复制的粘贴。</p><p>  以下是在排序阵列中搜索不小于\（x \）的第一个元素的标准方法：</p><p>  此（或任何）算法的运行时间不仅仅是其所有算术运算的“成本”，而且，这一成本加上等待数据从内存中获取的时间。因此，根据算法和问题限制，它可以是CPU绑定或内存绑定的，这意味着运行时间由其组件之一主导。</p><p> 如果阵列足够大 - 通常在其停止拟合缓存中的点围绕缓存并取得更大速度 - 二进制搜索的运行时间因内存提取而占主导地位。 </p><p>要了解一个想法，以下代码仅〜5％=（n \约10 ^ 6 \）：</p><p>      现实更复杂，即G。主内存具有分页和HDD实际上是具有奇怪的访问模式的旋转物理的东西，但我们坚持这个类比并向它介绍一些重要的实体：</p><p> 缓存层次结构是一种内存架构，其使用基于变化的访问速度来缓存数据的内存存储层次结构。相邻的缓存层通常大小不同，倍率为8到10，延迟倍率为3到5.大多数现代CPU具有3层高速缓存（名为L1，L2和L3，从最快/最小/最慢/最大）最大的是几兆字节大。</p><p> 缓存行是CPU和主存储器之间的数据传输单位。 PC的缓存行最有可能是64个字节，这意味着主内存被分成64个字节的块，并且只要您请求字节，您也将获取其缓存行邻居，无论您是否想要它。获取缓存线就像抓取6包。</p><p> 驱逐政策是决定将哪些数据保留在缓存中的方法。在CPU中，它由硬件控制，而不是软件。为简单起见，程序员可以假设使用最少使用最少使用的（LRU）策略，这只是逐步逐步用于最长时间的项目。这就像偏好的啤酒一样，以后的到期日期。</p><p> 带宽是可以读取或存储数据的速率。出于设计算法的目的，一个更重要的特征是带宽 - 延迟产品，基本上讲述了在没有排队的情况下等待第一个的同时可以请求的高速缓存行。大多数系统约为5或更多。这就像让您可以异步为贝勒发送的朋友。</p><p> 时间位置是一种访问模式，其中如果在一个点请求特定项目时，则可能在不久的将来再次请求相同的位置。这就像一遍又一遍地取出相同类型的啤酒。 </p><p>空间局部是一种访问模式，其中如果要求存储器位置，则可能在不久的将来再次请求附近的存储器位置。这就像在同一架子上储存你喜欢的啤酒。</p><p> 通过排序阵列的二进制搜索的主要问题是其存储器访问模式既不临时也不是间接本地。例如，元素\（\ lfloor \ frac n 2 \ rfloor \）经常访问（每个搜索）和元素\（\ lfloor \ frac n 2 \ rfloor + 1 \）不是，而他们可能占据相同缓存行。通常，只有前3-5读数是临时本地，只有最后3-4读数是完整的本地本地，其余的只是随机内存访问。</p><p> 我们可以通过以更加缓存的方式枚举和释放数组元素来克服此功能。我们使用的作用实际上是半千禧年的历史，你已经知道了它。</p><p>  MichaëlEytzinger是一个16世纪的奥地利贵族，以他的工作在族裔的工作中，特别是为一个名为Ahnentafel的祖先的系统（德语为“祖先桌”）。</p><p> 祖先回到了很大问题，但是写下数据很昂贵。 Ahnentafel允许通过绘图图浪费额外的空间，允许在不浪费额外的空间的情况下展示一个人的家谱。</p><p> 它列出了一个人以固定的上升顺序的直接祖先。首先，他们自己被列为1号，然后，递归地，对于编号的每个人，他们的父亲被列为\（2k \）和他们的母亲作为\（（2k + 1）\）。</p><p>   除了紧凑，它有一些很好的属性，就像所有偶数人都是男性，所有奇数（可能与1分开）是女性。 </p><p>人们还可以找到特定祖先的数量，只知道他们的后代的性格。例如，彼得伟大的血统是保罗我→彼得III→Anna Petrovna→彼得大伟大，所以他的号码应该是\（（（1 \ times 2）\ times 2 + 1）\ times 2 = 10 \）。</p><p> 在计算机科学中，此枚举已被广泛用于隐式（即，无指针）实现堆，段树和其他二进制树结构，而不是将其存储在底层数组项的名称中。</p><p>   您可以立即了解其时间位置如何更好（实际上，理论上最佳），因为靠近根的元素更接近阵列的开头，因此更有可能从缓存中获取。</p><p>   它需要两个索引\（i \）和\（k \） - 原始阵列中的一个，一个在构造 - 且递归地到两个分支，直到达到叶节点，这可以通过断言\（k \ Leq n \）作为Eytzinger阵列应该具有相同数量的物品。</p><p>  尽管存在递归，但实际上这实际上是一个非常快的实现，因为所有内存读数都是顺序的。</p><p> 请注意，第一个元素未填充，整个阵列本质上为1移位。这实际上将成为一个巨大的性能助推器。</p><p>  我们现在可以仅使用指数下降这个数组：我们刚刚从\（k = 1 \）开始，如果我们需要左右，则执行\（k：= 2k \），如果我们，\（k：= 2k + 1 \）需要走向。我们甚至不需要存储和重新计算二进制搜索边界。 </p><p>当我们需要恢复生成元素的索引时，才会出现唯一的问题，因为\（k \）可能最终未指向叶节点。这是一个如何发生的例子：</p><p>  在这里，我们查询\（[1，...，8] \）的阵列，以获取\（x = 4 \）的下限。我们将其与\（4 \），\（2 \）和\（5 \）进行比较，然后左右转到右侧，并以\（k = 11 \）结束，甚至不是有效的数组索引。</p><p> 注意，除非答案是数组的最后一个元素，否则我们将\（x \）与它相比在某个时候，并且在我们了解到它不小于\（x \）后，我们开始比较\（x \ ）针对左侧的元素，所有这些比较将评估真实（即导致右侧）。因此，要恢复所得元素的解决方案是取消一些右转。</p><p> 这可以通过观察右转旋转以\（k \）为1位的二进制符号记录，因此我们只需要找到二进制符号中的尾随数量和右转 - 按照该金额换档\（k \）。</p><p> 为此，我们可以在大多数系统上颠倒（〜x）并呼叫“查找第一个设置”指令。在GCC中，相应的内置是__builtin_ffs。</p><p>  请注意，如果二进制搜索返回任何结果（即，所有元素少于\（x \），则右转，所有元素均为右转，并且所有转弯都会被取消）。在这种情况下，您可以在B的第一个元素中放置特殊标志。</p><p> 这已经比std :: dight_bound快2-3倍，但我们不会停止那里并应用一系列小的增量改进。 </p><p>编译的程序指令也从主内存存储和加载，就像正常数据一样。它们在通过类似机制执行期间获取它们，并且它们具有单独的指令缓存。实际上，在大型应用程序中，您有时可以删除字面上未使用的代码的块，并且由于更好的指令缓存命中率，程序可能会运行得更快，但这是另一个文章的主题。</p><p> 为避免在此处的内存延迟引起的性能点击，CPU提前加载20-ISH指令，但要执行此操作，因此需要提前了解哪些指令。如果程序有条件执行（if-s，while-s，for-s），则无法选中猜测。</p><p> 分支错误规定（猜测“错误”分支的“IF”）成本约为10-20个周期。部分否定此惩罚，开发了硬件分支预测因子。这些是复杂的ad-hoc系统，使用统计方法 - 有些甚至使用简单的神经网络 - 以更准确的猜测。</p><p> 在二进制搜索的情况下，如果我们的所有数据都是随机的，则分支预测根本没有帮助，仅仅因为它不能：所有比较都是50-50。这就是为什么我们需要摆脱if-s并将我们的主循环重写为以下方式：</p><p>    编译器不喜欢CPU在等待内存提取时闲置。有时它可能需要猜测哪个缓存行将很快需要，并提前获取它（回想一下，带宽 - 延迟产品通常大于1）。</p><p> 这适用于简单的访问模式，例如在越来越多或减少的顺序中迭代阵列，但对于类似于我们在这里的东西，它不会表现良好。</p><p> 正如我们更多地了解我们的问题，而不是编译器所做的那样，我们可以明确地告诉它预取我们需要的缓存行。这是通过__builtin_prefetch在gcc中完成的： </p><p>这里，block_size等于16，正是覆盖高速缓存行所需的界面是多少。当我们在b + k * block_size引用缓存行时，我们引用\（k）的大孙子（block_size = \（2 \ times 2 \ times 2 \ times 2 \）或4左转）他的一层中的一些邻居（回想一下，同一级别的索引只是连续数字）。</p><p> 这样做的一切都是有很大的机会，我们将预取一个我们将稍后使用的元素（（i + 4）\） - 迭代。什么机会，究竟是什么？嗯，事实证明，每次迭代都是恒定的。</p><p>  请注意，对于树中的每个图层，除了第一个4且可能是最后一个，该层中的节点的数量可被16个，块大小可分开。这意味着每次迭代上的覆盖节点的分数仅取决于阵列关于其高速缓存行的第一偏移的位置。但更重要的是，可以让所有的\（k \）的祖孙被同样的缓存线覆盖。</p><p> 实现这一目标的方法是将阵列的第一个元素放置到高速缓存行的第一位置（0索引），或者在高速缓存行的开头上放置数组本身，因为它是第一（即B [0] ）元素通过设计空白。这样的方式，前4个层的下一个\（1 + 2 + 4 + 8 = 15 \）元素将占据缓存行的其余部分，并且阵列的其余部分是在共享a的漂亮16元节点的漂亮16元块中anijigned。爷爷。</p><p> 我们只需要询问内存管理器在缓存行的开头上分配我们的数组（默认情况下，它将在任何地方分配阵列），就是这样。为此，我们可以使用alplats说明符：</p><p>  就是这个。现在，我们的算法在时间内不断预取4层/高速缓存行，这是由我们RAM的带宽覆盖的。这样，有效延迟减少了4倍，我们基本上交易带宽以实现延迟。</p><p>    当\（n \）是2或靠近它的功率时，它适用最佳，因为分支预测器将难以弄定展开\（（\ log n）\） -  th周期。 </p><p>其性能因缓存大小和阵列长而异，但即使在较小的阵列（＆lt; 1mb）上，也可以保持＆gt; 3x。</p><p> 预处理并不昂贵。射击与数组大小相同数量的查询成本的1％左右。</p><p> 现代硬件不会为预取不属于您的缓存行而惩罚您，尽管这可能是旧CPU的问题，这可以通过简单的IF语句来解决。</p><p> 出于某种原因，基本的二进制搜索实现（本文中的第一个代码块）已经比STD :: Sort快20％〜20％。</p><p>  B树基本上是\（（k + 1）\） -  ary树，意味着它们存储每个节点中的\（k \）元素，并在\（（k + 1）\）之间选择可能的分支而不是2。</p><p> 它们广泛用于数据库中的索引，尤其是那些在磁盘上运行的人，因为如果\（k \）很大，这允许大的顺序内存访问在减少树的高度时。</p><p> 为了执行静态二进制搜索，可以以隐式方式实现B树，i。 e。在没有实际存储任何指针并仅消费\（O（1）\）附加内存，并且可以等于高速缓存行大小，使得每个节点请求精确地提取一个高速缓存行。 </p><p>结果，它们具有相同的生长速率，但似乎更大的计算持续的恒定。 虽然后者是可解释的（我们的循环只有5个指示;不能超过那个），以前是令人惊讶的。  如果计算无关紧要，Eytzinger二进制搜索应该更快地\（4 \）倍，因为它平均要求它们〜4倍。  B树使\（\ frac {\ log_ {17} n} {\ log_2 n} = \ frac {\ log n} {\ log 17} \ frac {\ log 2} {\ log n} = \ frac {\ log 2} {\ log 17} \约0.245 \）存储器访问每个二进制搜索请求，i。 e。 它请求〜4倍的缓存行才能获取  请注意，此方法虽然适用于单线程世界，但不太可能进入数据库和繁重的多线程应用程序，因为它牺牲了带宽以实现低延迟。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://algorithmica.org/en/eytzinger">https://algorithmica.org/en/eytzinger</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/二进制/">#二进制</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/binary/">#binary</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/缓存/">#缓存</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1055238.html"><img src="http://img2.diglog.com/img/2021/3/thumb_0a6ee23a8333e5e2c73d43934d24972d.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1055238.html">Bebop：基于型号的基于模式的二进制序列化格式 </a></div><span class="my_story_list_date">2021-3-30 17:31</span></div><div class="col-sm"><div><a target="_blank" href="/story/1045976.html"><img src="http://img2.diglog.com/img/2021/1/thumb_90af1d8d66124624d0ca33eb2826b4b6.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1045976.html">Deno 1.7：独立二进制文件大小减少60％ </a></div><span class="my_story_list_date">2021-1-23 16:5</span></div><div class="col-sm"><div><a target="_blank" href="/story/1042611.html"><img src="http://img2.diglog.com/img/2020/12/thumb_4c2092f049c272f7cb96ac2d7a38289e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042611.html">格拉斯哥Haskell编译器9.0，支持线性类型 </a></div><span class="my_story_list_date">2020-12-31 2:49</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030633.html"><img src="http://img2.diglog.com/img/2020/10/thumb_21054de7abd23919431e2a8a7caa1f96.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030633.html">使用Bakeware将Elixir应用程序编译为单个可执行的二进制文件</a></div><span class="my_story_list_date">2020-10-23 2:54</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>