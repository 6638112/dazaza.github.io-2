<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么cobol不是问题 Why COBOL Isn't the Problem</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why COBOL Isn't the Problem<br/>为什么cobol不是问题 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-17 00:45:02</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/4126e18d91aa04180e145c37d0d45d9f.png"><img src="http://img2.diglog.com/img/2021/3/4126e18d91aa04180e145c37d0d45d9f.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This article is the first part of a two-part series on dealing with technical debt. The second part is  here.</p><p>本文是处理技术债务的两部分系列的第一部分。第二部分在这里。</p><p> Our modern world runs on an enormous amount of technology. A lot of it is older than people realize. This technology is mostly invisible when it is working, but when it isn’t it can cause real problems. When it fails, it is only natural for people to ask questions and try to understand why things went wrong. Even in a best-case scenario where nobody is being blamed or hurt, the technology generally needs to be fixed, and understanding how it failed is important.</p><p> 我们现代世界符合巨大的技术。很多比人们意识到的那么大。这项技术在工作时大多是不可见的，但是当它不是它可能导致真正的问题。当它失败时，人们才能提出问题并试图理解为什么事情出现问题是自然的。即使在没有人被归咎于或受伤的最佳情况下，技术通常需要修复，并了解它失败的重要性。</p><p> Most computer technology is quite opaque to non-specialists. Because of this, it is easy to be distracted by the most visible aspects of the technology. As we will show, one of the most commonly blamed parts is the programming language used to give the computer instructions, especially if it is an old but common programming language like COBOL. In reality this is about as useful as blaming car problems on the color of the paint. The real problem is, and always has been, the fact that the failed systems  hadn’t been maintained properly.   Our goal in this article is two-fold. First we wish to convince you that COBOL code failing in the modern world is a  symptom of insufficient maintenance, not a  cause of failure. In other words, if a system you are using or are maintaining fails, even if COBOL is used somewhere inside it, that fact is mostly irrelevant. Secondly, we will describe the concepts of refactoring and technical debt, which give a far more useful explanation for why complex technical systems fail. In a follow-up article, we will describe ways governments and businesses can manage refactoring and technical debt.</p><p> 大多数计算机技术对非专家来说是不透明的。因此，很容易被这项技术的最明显的方面分散注意力。正如我们将展示的那样，最常用的部分之一是用于提供计算机指令的编程语言，特别是如果它是一种旧但常见的编程语言，如COBOL。实际上这与涂料颜色的责备汽车问题一样有用。真正的问题是，并且始终是，失败的系统尚未正确维护。我们在本文中的目标是两倍。首先，我们希望说服您在现代世界中失败的COBOL代码是维护不足的症状，而不是失败的原因。换句话说，如果您使用的系统或维持失败，即使在其内部使用COBOL，即使在其内部使用，那么该事实大多是无关紧要的。其次，我们将描述重构和技术债务的概念，这给出了复杂的技术系统失败的原因更有用的解释。在后续文章中，我们将描述各国政府和企业可以管理重构和技术债务的方式。</p><p>  Imagine that you have just been laid off. Not only that, but you were laid off because a brand new disease was spreading across the world, killing people and overwhelming hospitals. Nobody seems to have been prepared for this, and it feels kind of like the world is falling apart. Despite all this, there is some hope: government officials are saying that you can still apply for unemployment benefits. In fact,  more people can apply for unemployment benefits than ever before. It’ll at least be something, right? How hard can it be?</p><p>  想象一下，你刚刚被解雇了。不仅如此，而且你被揭露，因为一个全新的疾病在世界范围内蔓延，杀害了人们和压倒性的医院。没有人似乎已经为此做好了准备，并且感觉就像世界崩溃了。尽管如此，有一些希望：政府官员仍然申请失业救济金。事实上，更多人可以申请失业救济金。这至少是什么，对吗？它能有多难？</p><p> Really hard, even in the best of times, it turns out. The system is kind of complicated. There are all kinds of deadlines, and even in the best case, it’ll take a while to get the money. You try to go through the process and…</p><p> 它真的很难，即使在最好的时候，它就异常。该系统有点复杂。有各种截止日期，甚至在最好的情况下，它需要一段时间才能拿到这笔钱。你试着经历这个过程......</p><p> …and the unemployment website is down. The unemployment phone lines are down. You can’t hit those all-important deadlines. You can’t even get instructions on how to do it. And the people in charge don’t seem to know what is going on.</p><p> ......并且失业网站已拒绝。失业电话线已关闭。你无法击中那些全部重要的截止日期。您甚至无法获取有关如何执行的指示。而负责人似乎没有知道发生了什么。</p><p> This is the nightmare that hit the people of New Jersey during late April and May of 2020. Many businesses across the world laid off record numbers of employees because of the COVID-19 pandemic. According to the  Labor Department for New Jersey, this caused the number of unemployment claims they received to balloon a massive 1600%. The state unemployment website began to suffer  outages in April, continuing  into May. Similar problems were reported to have happened in  other states, although most were not as widely reported as in New Jersey.  After the first outages, the Governor of New Jersey, Phil Murphy,  promised to get to the root of the problem. The next day, the state was looking for volunteers who could program in a sixty-year-old  programming language called  COBOL (an acronym for COmmon Business-Oriented Language); some of the systems that had gone down were apparently written in COBOL, and they needed immediate help fixing those systems. This is the part of the story that made headlines across the country. New York Magazine, for instance, had an  article snidely titled “NJ Governor Requests Expertise of 6 People Who Still Know COBOL.” Slate magazine’s  commentary had the somewhat more factual headline “Why New Jersey’s Unemployment Insurance System Uses a 60-Year-Old Programming Language.”  Business Insider went with the rather more educational  headline “The governor of New Jersey is asking for urgent help with COBOL, a 61-year-old programming language. Here’s why it’s causing problems with unemployment systems, and why it’s so hard to replace.”</p><p> 这是在4月下旬和2020年5月袭击了新泽西州的噩梦。由于Covid-19大流行，世界各地的许多企业都会下定员工的纪录数。据新泽西州的劳工处说，这导致他们收到的失业索赔数量大规模1600％。国家失业网站于4月开始遭受中断，持续到5月。据报道，在其他国家发生了类似的问题，尽管大多数并没有像新泽西一样被广泛报道。在菲尔墨菲的新泽西州的第一次停电后，答应了解决问题的根源。第二天，该国正在寻找可以以六十岁的编程语言编制一个名为COBOL的志愿者（以普通的商业为导向的缩写）;一些已经下降的系统显然是用COBOL写的，他们需要立即帮助解决这些系统。这是全国各地的头条新闻的故事的一部分。例如，纽约杂志有一篇狡猾的文章，标题为“NJ总督要求6个人仍然知道COBOL的专业知识”。 Slate Magazine的评论有点更多的事实标题“为什么新泽西的失业保险制度使用了一个60岁的编程语言。”商业内幕与“新泽西州长州长”致力于与COBOL的紧急帮助，这是一个61岁的编程语言的帮助。这就是为什么它导致失业系统问题，以及为什么它很难取代。“ </p><p> As we mentioned in the introduction, most of these articles really should have had different headlines. Their mistake was in referencing COBOL at all  1. Their failures are as natural and predictable as having your car’s engine fail after years of never changing the oil. Unlike with cars, though, the knowledge of how to maintain complex computer systems has never really spread to non-specialists, and so these kinds of failures continue to take businesses and governments by surprise. Continuing our analogy above, they either forgot to install an oil service light, or decided to ignore it, generally for years.</p><p>正如我们在介绍中提到的那样，这些文章中的大多数真正应该有不同的头条新闻。他们的错误是在引用COBOL的情况下。他们的失败是自然和可预测的，因为在永不改变石油之后拥有汽车的发动机失败。但是，与汽车不同，如何维护复杂的计算机系统从未真正传播给非专家，因此这些失败继续让企业和政府惊讶地占据。继续我们上面的类比，他们要么忘了安装石油服务灯，或者决定忽略它，一般多年。</p><p> We’re not blaming the reporters for this, for two reasons. First, if you look past the headlines, you’ll get more of these details; they tried. Second, many inexperienced programmers (often loudly, on the internet) make the same mistake, so who can blame the reporters for believing them?</p><p> 由于两个原因，我们不会责怪记者。首先，如果您浏览了头条新闻，您将获得更多这些细节;他们尝试了。其次，许多缺乏经验的程序员（通常大声地，在互联网上）犯了同样的错误，所以谁可以责怪记者相信它们？</p><p>  Once you know how to program, learning programming languages is  easy. Understanding existing programs is  hard. Maintaining existing programs (in the form of what we call refactoring) is the most difficult part, by far.</p><p>  一旦你知道如何编程，学习编程语言很容易。了解现有计划很难。维护现有计划（以我们所谓的重构）的形式是最困难的部分，到目前为止。</p><p> If you need to change old programs, hiring experienced programmers and teaching them COBOL is the  cheap part. Getting even an experienced programmer up to speed on the  existing program/system enough to actually fix it? That’s much more expensive. Actually providing the programmers the time and money to make sure the fixes  stick when things need to change again? That’s the real cost, right there.</p><p> 如果您需要更改旧计划，招聘经验丰富的程序员并教授COBOL是便宜的部分。即使是经验丰富的程序员也可以在现有的程序/系统上速度速度，以实际修复它？这更昂贵。实际上为程序员提供了时间和金钱，以确保修复程序粘贴在需要再次改变时？这是真正的成本，就在那里。</p><p>  COBOL, as its acronym suggests, is what is known as a programming language. A programming language is a special kind of language that both humans and computers understand. In many ways, programming languages are like so-called natural languages, i.e. languages that humans use to communicate with each other, such as English or Standard Chinese.</p><p>  COBOL，因为其首字母缩写表达，是所谓的编程语言。编程语言是一种人类和计算机的特殊语言。在许多方面，编程语言就像所谓的自然语言，即人类使用彼此沟通的语言，例如英语或标准汉语。</p><p> COBOL is one of the oldest programming languages around, with the original version being created in the early 1960’s. To make a long story short, it was deliberately created and promoted by the United States of America’s Department of Defense as a standard programming language that could be used across many different types of systems. With their support, it rapidly spread both to other government agencies and to many types of businesses, and is still used heavily by both.  A set of instructions, written in a programming language, telling a computer how to do specific things, are called a program. Programs written in COBOL are currently being used to control such important things as ATM transactions, inventory management, government data processing, and much more. It is a part of our modern life, invisible but always there. As the world changes, the system’s behaviours need to be updated to keep up with new demands and other changes. Because of this, we still need humans who understand COBOL well enough to update the computers’ instructions.</p><p> Cobol是最古老的编程语言之一，原始版本在1960年代早期创建。为了缩短悠久的故事，由美国的美国国防部被刻意创造和推广，作为一种标准的编程语言，可以在许多不同类型的系统上使用。随着他们的支持，它迅速传播到其他政府机构以及多种类型的企业，并且仍然是两者繁重的。用编程语言编写的一组指令，告诉计算机如何进行特定事物，称为程序。在COBOL中编写的计划目前用于控制atm交易，库存管理，政府数据处理等等的重要事项。这是我们现代生活的一部分，看不见，但总是在那里。随着世界的变化，系统的行为需要更新以跟上新的需求和其他变化。因此，我们仍然需要人类了解COBOL，足以更新计算机的说明。</p><p>  A fact that I suspect will not surprise my technical readers, but will surprise many others, is that programming languages are  really easy to learn. After some serious study, the authors have decided that COBOL is no exception to this rule  2 (it has some striking oddities compared to more standard programming languages, see below, but the strangeness doesn’t increase the difficulty enough to matter). With modern resources such as the internet and proper reference books, using one of COBOL’s many variants is entirely manageable for an experienced programmer; they will get up to speed on it quickly (although we do not recommend it for beginning programmers; it is too easy to learn bad programming habits from dealing with the language’s limitations).</p><p>  事实上，我怀疑我的技术读者不会让我的技术读者感到惊讶，但会让许多人感到惊讶，是编程语言真的很容易学习。经过一些认真的研究，作者已经决定，COBOL对此规则2（相比，与更多标准的编程语言相比，它有一些醒目的奇怪，但奇怪不会增加足够的难度）。通过互联网和适当的参考书等现代资源，使用COBOL的许多变体之一对经验丰富的程序员来说是完全可控的;他们将快速加速（虽然我们不推荐它的开始编程人员;它太容易学习从处理语言的局限性处理的不良编程习惯）。 </p><p> For evidence of how easy it is to learn programming languages, one of the authors of the current paper has, over the course of his life, learned 18 distinct programming languages. His father, a physics professor, claims to have used 20 and 30 programming languages. A quick poll of engineers at Lucid Software showed that this was not unique, with all of the engineers having used at least two programming languages, and the majority having used somewhere between 5 to 20. What’s more, the longer the participant had been working with computers, the more programming languages they had learned, well into the later stages of their career.</p><p>对于学习编程语言有多容易的证据，目前纸张的作者之一在他的生活过程中，学习了18名不同的编程语言。他的父亲是一个物理教授，声称使用了20和30个编程语言。 Lucid软件的一项快速投票员表明，这并不是独一无二的，所有工程师都使用了至少两种编程语言，并且大多数人在5到20之间使用的大部分。更重要的是，参与者与之合作的时间越长计算机，他们学到的编程语言越多，良好地进入他们职业生涯的后期阶段。</p><p> The participants in the survey also commented on their experience learning these programming languages. The consensus was that once you have learned to actually program, learning the  languages themselves are the easiest part of the whole process. In fact, programming languages build on each other: the more you learn, the easier learning new languages is. Sometimes learning a new programming language also requires learning new programming techniques, and learning these techniques can be difficult. However, it is the programming techniques, not the language, that are the real barrier.  If you compare computer languages with natural languages, it’s pretty easy to see why computer languages are much easier to learn than natural ones.. Your typical natural language speaker knows something like 20,000 words  3 from their native language. Programming languages are really small—a typical programming language has somewhere between 20 to 50 “keywords” along with a few hundred extra words from what are usually called “standard libraries”  4. Even including special symbols (e.g. `, $, &amp;, and so on) and mathematics, programming languages really are very small compared to natural languages.</p><p> 调查中的参与者还评论了他们学习这些编程语言的经验。共识是，一旦您学会了实际计划，学习语言本身就是整个过程中最容易的部分。事实上，编程语言相互建立：您学到的越多，更容易学习的新语言是。有时学习新的编程语言还需要学习新的编程技术，并学习这些技术可能是困难的。但是，它是编程技术，而不是语言，是真正的障碍。如果您将计算机语言与自然语言进行比较，这很容易看出为什么计算机语言更容易学习，而不是自然的。您的典型自然语言扬声器从其母语中知道20,000字3.编程语言是非常小的，典型的编程语言在20到50“关键字”之间以及通常被称为“标准库”4的几百个额外的单词。甚至包括特殊符号（例如`，$，＆amp;，等等）和数学，与自然语言相比，编程语言非常小。</p><p> Of course, words aren’t everything. There’s the matter of grammar, of how you can put words together to say something useful. In the case of programming languages, learning the grammar really is rather hard. Computers aren’t like people; if things are wrong in a program, the computer will either reject what you say as nonsense, or—much worse—interpret it the wrong way. In order to program, you have to learn special kinds of skills, such as how to think very slowly and carefully, how to solve complex problems in ways that other people can read later, and how to be detail-oriented. Acquiring these skills is why programming is challenging to learn. But once you  have squeezed your mind into that strange space, you can see how all the languages use different words and variations to communicate the same concept. If you learn a range of techniques, build some small apps or websites, and practice, you’ll find all the languages (and even different grammars) overlap and blur together.</p><p> 当然，言语不是一切。有语法的问题，你如何把言语放在一起来说有用的东西。在编程语言的情况下，学习语法真的很难。电脑不像人;如果程序中的事情是错误的，那么计算机将拒绝你认为是无意义的，或者 - 更糟糕 - 解释错误的方式。为了编程，您必须学习特殊的技能，如如何慢慢地仔细地思考，如何以其他人可以稍后阅读的方式解决复杂的问题，以及如何进行详细介绍。获取这些技能是为什么编程是挑战的原因。但是一旦你把你的思想挤进了那个奇怪的空间，你就可以看到所有语言如何使用不同的单词和变体来传达相同的概念。如果您学习一系列技术，建立一些小型应用程序或网站，以及练习，您将找到所有语言（甚至不同语法）重叠和模糊在一起。</p><p>  COBOL was designed to look more like English than most other programming languages (in a failed attempt to make it more readable to non-programmers), so it has a somewhat larger vocabulary than other programming languages. It’s still nothing compared to natural languages, though (it maxes out at about 1000 words for some COBOL variants), especially for fluent English speakers, since most of COBOL’s words are English loanwords.</p><p>  COBOL旨在看起来更像英语，比大多数其他编程语言（在失败的尝试中使其更可读对非程序员），因此它具有比其他编程语言更大的词汇表。与自然语言相比，它仍然是什么？（它为某些COBOL变体大约1000字），特别是对于流利的英语扬声器，因为大多数COBOL的话是英语借词。</p><p> COBOL’s grammar and structure is rather different from the most common families of programming languages, but not  that different; most programmers will have learned far wilder syntax elsewhere  5.</p><p> COBOL的语法和结构与最常见的编程语言家庭不同，但不是不同的;大多数程序员将在其他地方学习远行语法。</p><p> One of the authors was able to make sense of the sample programs in reference 2 within a week, simply by studying said textbook. As we will show in the next section, the sheer size of the programs written in the language itself dwarf both of these concerns.</p><p> 其中一位作者能够在一周内在参考2中发表示例计划，只需通过研究所述教科书。正如我们将在下一节上展示，以语言本身编写的程序的纯粹规模涉及这些问题。</p><p> This came from an extensive study of  ex. [1], “Beginning COBOL for Programmers.”</p><p> 这来自于对EX的广泛研究。 [1]，“为程序员开始COBOL。” </p><p> This can be hard to define and measure; what is a word, exactly? (See  ex. [2] for a discussion). Luckily for us, the size difference between programming and natural languages is so big, the details don’t matter much.</p><p>这可能很难定义和测量;什么是一个词，究竟是什么？ （见前任[2]讨论）。幸运的是，编程和自然语言之间的大小差异如此之大，细节并不重要。</p><p> Especially nowadays, popular languages usually have very large standard libraries and a lot of “non-standard” libraries. The point here is that you don’t have to learn all the extra words in order to “know the language”. Just like most people only look up unfamiliar words when they run into them, programmers refer to documentation with the more specialized parts of the language. the details don’t matter much.</p><p> 特别是现在，流行语言通常具有非常大的标准库和许多“非标准”图书馆。这一点是您不必学习所有额外的单词以“知道语言”。就像大多数人只在他们遇到陌生的话语时才仔细查询他们的陌生词语，程序员是指与语言更专业的部分的文档。细节并不重要。</p><p> Regular expressions come to mind. So do HTML, CSS, and the many, many formats used for build systems. There are so many unusual domain-specific languages.</p><p> 正常表达来到了。因此，HTML，CSS和许多用于构建系统的格式。有这么多不寻常的域名语言。</p><p>   Programs can be truly enormous. According to one source ( ex. [1]), some single COBOL programs were upwards of 100,000 lines; in all likelihood, some of those are still around today. Even if they were split into smaller files at some point, most of those lines will still be somewhere. To get a feeling for just how long this is, if a 100,000 line program averaged 6 words per line, it would be longer than the novel “War and Peace.” Although in its defense, the programs’ plot would be more engaging  6.</p><p>   程序可以真正巨大。根据一个来源（例如[1]），一些单一的COBOL计划是100,000线的向上;在所有可能性中，其中一些仍然在今天。即使它们在某些时候被分成较小的文件，大多数这些行仍将在某个地方。为了让这种感觉是多长时间，如果100,000线计划平均每行6个单词，那将比小说“战争与平”长。虽然在其防御中，程序的情节将更多地参与6。</p><p> There are extra problems with reading large programs, beyond their simple length. The number of programmer-defined words in a program can be, and very often is, larger than all the words in the original programming language itself. When writing a large program, the programmers will have been forced to invent thousands of all-new, program-specific words (in programming terms, variable names  7) to describe their particular problem. While these names are more often useful than not in understanding what the program is doing, not-useful names are still far too common  8. Even if they are individually easy to understand, the very number of words means that programming language-specific knowledge helps very little.</p><p> 阅读大型程序存在额外的问题，超出其简单的长度。程序中的程序员定义的单词的数量可以是，通常比原始编程语言本身中的所有单词大。编写大型程序时，程序员将被迫造影数千个全新的程序特定的单词（编程术语，变量名7）来描述其特定问题。虽然这些名称更常用于未经理解程序所做的内容，但是不用有用的名称仍然太常见了8.即使它们是单独容易理解的，那么单词也意味着编程语言特定知识有所帮助很少。</p><p> These kinds of programs don’t live alone, either; they are part of bigger systems. To fully understand them, you not only have to read a novel-lengths’ worth of code, you have to understand why the program was written and what the original programmers were dealing with when they wrote it. For another literary analogy, most large programs read more like “Finnegan’s Wake” than “War and Peace.” As for written explanations of what it does and why, we should be so lucky.</p><p> 这些程序也不生活;它们是更大系统的一部分。要完全理解它们，您不仅要读取了一个新的长度的价值代码，您必须了解为什么该计划的编写以及原始程序员在写它时处理的是什么。对于另一个文学类比，大多数大型计划更像“Finnegan的唤醒”而不是“战争与和平”。关于它的书面解释以及为什么，我们应该如此幸运。</p><p> It gets worse when you realize that despite our little joke above about the plot of “War and Peace,” programs don’t even have the decency to start at the beginning and go straight through to the end, telling a single story. Instead, they can go backwards and forwards and jump around in the strangest possible ways  9. It’s like trying to read five different pages in “War and Peace” at the same time. This is particularly bad with old programs (written before we discovered that this was a serious problem) and with programs that have been heavily changed without the effort to keep them readable.</p><p> 当你意识到尽管我们的小笑话是关于“战争和平的剧情”的笑话时，计划甚至没有十分之一开始，直到最后，讲一个故事。相反，他们可以以最奇怪的方式向后和向前跳转并跳跃9.这就像尝试同时在“战争和平”中读五个不同的页面。这与旧计划特别糟糕（在我们发现这是一个严重的问题之前，没有努力让他们可读的措施已经严重改变。 </p><p> The upshot of all this is that in the long run, it doesn’t matter whether you hire a room full of experienced COBOL programmers or a room full of experienced Java programmers to fix a large COBOL program; practically  all of their work will go into understanding the actual program, rather than the language it was written in. The Java programmers would of course be somewhat slower at first, but they’d catch up quickly enough, and then begin running into the same walls as the COBOL programmers would: it’s just too much to read and understand, especially if you don’t know exactly what the program is doing (or what it’s supposed to be doing).</p><p>所有这一切的结果是，从长远来看，您是否聘请了一个充满了经验丰富的COBOL程序员或充满经验丰富的Java程序员的房间以修复大型COBOL计划的房间并不重要;实际上，他们的所有工作都将对实际的程序进行了解，而不是它写入的语言。Java程序员当然一开始就会稍微慢，但它们会迅速赶上，然后开始跑步墙壁作为COBOL程序员：这太过分了阅读和理解，特别是如果你不知道该计划正在做什么（或它应该做的事情）。</p><p> Just kidding. We’ve never read “War and Peace” in any form.</p><p> 只是在开玩笑。我们从未以任何形式读过“战争和平”。</p><p> Also, function names, class names, file names, and on and on. There’s a lot of naming in programming.</p><p> 此外，函数名称，类名，文件名和开启和开启。编程有很多命名。</p><p> This is observed in every sizable codebase, old or new. Constantly fixing names is part of basic program maintenance.</p><p> 在每个大量的代码库，旧或新的时都观察到这一点。不断修复名称是基本程序维护的一部分。</p><p> A truly remarkable amount of work on how to program well has been studying how to make a program both tell a single coherent story and still do everything it needs to do. Most published books written by humans for humans don’t face this problem unless they actively chose to.</p><p> 关于如何编程的真正显着的工作，一直在研究如何制作一个程序都讲述一个连贯的故事并仍然可以做到它需要的一切。除非主动选择，否则人类为人类撰写的大多数发表的书籍都不会面临这个问题。</p><p>  At this point the careful reader might notice that the real world seems to contradict our position. After all, programs written today are doing much more complicated things now than ever before. Forty years ago, most people interacted with computers through purely textual interfaces that were hard to learn and mostly acted like glorified printers (assuming they weren’t  actually printers). Nowadays, most people interact with computers through sophisticated graphical interfaces with smooth animation and deliberately broad appeal. The code needed to do something as common as opening a web browser is surprisingly complex when you look at it from a programmer’s point of view. If our last two sections are true, how did we get this far?  The answer is that lots of smart people saw what happened when programs began to become too long. When they noticed it, they didn’t just say “Oh no, I guess we’ve hit our limits.” Instead they studied what people could do to avoid the problem. They found examples of large programs that became long but still were easy to change. They carefully studied how humans actually read and write programs. They brainstormed new ideas. They created and tested new programming languages and new programming techniques. The end result was that, on average, and over decades of hard work and experience, we have gotten better at writing programs.</p><p>  此时，谨慎的读者可能会注意到现实世界似乎与我们的立场相矛盾。毕竟，今天写的计划现在比以往任何时候都更加复杂。四十多年前，大多数人通过纯粹的文本界面与计算机互动，这很难学习，大多数情况都像光荣的打印机一样（假设他们实际上并不是打印机）。如今，大多数人通过具有平滑动画的复杂的图形接口和故意广泛的吸引力与计算机互动。当您从程序员的角度来看，在打开Web浏览器时，将常见的代码是令人惊讶的复杂性。如果我们的最后两部分是真的，我们是如何实现这一目标的？答案是，很多聪明人看到程序开始变得太久时发生了什么。当他们注意到它时，他们不只是说“哦不，我想我们已经达到了我们的极限。”相反，他们研究了人们可以做些什么来避免这个问题。他们发现了大型程序的例子，但仍然很容易改变。他们仔细研究了人类如何实际读写程序。他们集思广益。他们创建并测试了新的编程语言和新的编程技术。最终的结果是，平均而言，多十年的艰苦工作和经验，我们在编写计划时更好地获得了更好。</p><p> In the big picture, these improvements are very good news. They have enabled a truly remarkable growth in what computers can do for us. The problem is that practically all of these techniques and methods require some very important things:</p><p> 在大局中，这些改进是非常好的新闻。他们在电脑可以为我们做的事情中启用了真正显着的增长。问题是，实际上所有这些技术和方法都需要一些非常重要的事情： </p><p> Strongly disciplined programmers. Good languages help, but bad programmers can make a mess in  any language.</p><p>强烈纪律的程序员。好语言有帮助，但坏程序员可以用任何语言弄乱。</p><p> The ability to extend programs with “general-purpose” code written by other people. That way, the programmers can focus on new problems, rather than solving old problems for the umpteenth time.</p><p> 通过其他人写的“通用”代码扩展程序的能力。这样，程序员可以专注于新问题，而不是解决UMPTENTEN的旧问题。</p><p> What is known in programming circles as  refactoring. Refactoring means that when a programmer goes to change a program, they don’t make the smallest and easiest change that works. Instead, they work out the smallest change that is  also readable and maintainable. It often results in bigger changes to the code but a better program. It’s the difference between building a shed on the side of a house, and actually expanding the house’s foundation to add a new room.</p><p> 在编程圈中所知为重构。重构意味着当程序员要更改程序时，它们不会使工作的最小和最简单的更改。相反，它们锻炼了也是可读和可维护的最小变化。它通常会导致代码更大但更好的程序。在房子一侧建造一个棚子之间的区别，实际上扩大了房子的基础，以添加新房间。</p><p> Of these, only item 3 has really become normal and easily available to modern businesses and governments  10. Items 1, 2, and 4 require employees with training, experience, and dedication to both quality and to the good of the employer. Perhaps most importantly, though, item 4 requires both commitment and understanding  from the employer.</p><p> 其中，只有第3项确实变得正常，可以易于现代企业和政府10.项目1,2和4，要求员工进行培训，经验和奉献的质量和雇主的利益。但是，尽管如此，第4项需要对雇主的承诺和理解。</p><p> At this point, it makes sense to expand our analogy from item 4 above. You can imagine a small house that is well-built and safe and stable. That often describes how a program starts when it is first written by a single person. Then things change; you need a little bit more room. Do you expand the house (and the foundation) or do you build a cheap shed outside?</p><p> 此时，扩展我们上文第4项的类比有意义。你可以想象一个充足性和安全稳定的小房子。这通常描述程序如何在一个人写入时开始。然后事情发生变化;你需要更多的空间。你是否展开了房子（和基础），或者你在外面建一个廉价棚屋吗？</p><p> The temptation is to just build the cheap shed. Sometimes that’s even the right choice. After all, it’s easy and cheap and works fine. The problem is that you don’t build a big house by starting with a small house and then bolting a bunch of sheds onto the side. The whole thing can end up as a pile of sheds. The original house may end up crushed under the weight of all the extra sheds. It’s an unstable mess that sways worryingly in the lightest breeze.  In building a real house, at some point, you have to stop adding more sheds and actually expand the house. It’s more expensive, but if you want it to not fall down under winds of more than 5 mph, you don’t have much choice. If you do it  right, you might even slowly turn your small house into a beautiful mansion, or office building</p><p> 诱惑是为了建造便宜的棚屋。有时甚至是正确的选择。毕竟，它很容易便宜，工作正常。问题是，你不会通过一个小房子开始建一个大房子，然后将一堆棚子拧到侧面。整个东西最终可以成为一堆棚子。原来的房子最终可能会在所有额外棚的重量下压碎。这是一个不稳定的混乱，令人担忧的是最轻的微风。在建造一个真正的房子，在某些时候，你必须停止添加更多的棚子并实际上扩展房子。它更贵，但如果你想要它不会在超过5英里/小时的风中倒下，你就没有太多的选择。如果你对，你甚至可能慢慢把你的小房子变成一个美丽的豪宅或办公楼</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.lucidchart.com/techblog/2020/11/13/why-cobol-isnt-the-problem/">https://www.lucidchart.com/techblog/2020/11/13/why-cobol-isnt-the-problem/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/cobol/">#cobol</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/isn/">#isn</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012 - 2021 diglog.com </div></div></body></html>