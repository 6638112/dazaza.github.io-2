<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>镍：以更少的成本实现更好的配置</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">镍：以更少的成本实现更好的配置</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-22 23:02:44</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/022ae1f163e3837faf7572f4d1b4761b.png"><img src="http://img2.diglog.com/img/2020/10/022ae1f163e3837faf7572f4d1b4761b.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>We are making the  Nickel repository public. Nickel is an experimental configurationlanguage developed at Tweag. While this is not the time for the firstrelease yet, it is an occasion to talk about this project. The goal of thispost is to give a high-level overview of the project. If your curiosity is tickledbut you are left wanting to learn more, fear not, as we will publishmore blog posts on specific aspects of the language in the future. But fornow, let’s have a tour!</p><p>我们正在将镍库公之于众。镍是Tweag开发的一种实验配置语言。虽然现在还不是第一次租赁的时候，但这是一个谈论这个项目的机会。这篇文章的目标是对该项目进行一个高层次的概述。如果你的好奇心很强，但你还想学更多，那就不要害怕，因为我们将来会发布更多关于英语具体方面的博客文章。但是现在，让我们来游览一下吧！</p><p> [ Disclaimer: the actual syntax of Nickel being still worked on, I’m freelyusing as-of-yet non-existing syntax for illustrative purposes. The underlyingfeatures are however already supported.]</p><p>[免责声明：Nickel的实际语法仍在研究中，出于说明的目的，我自由使用目前尚未存在的语法。但是，已经支持底层功能。]。</p><p>  We, at Tweag, are avid users of the  Nix package manager. As ithappens, the configuration language for Nix (also called Nix) isa pretty good configuration language, and would be applicable to manymore things than just package management.</p><p>在Tweag，我们是NIX包管理器的忠实用户。事实证明，NIX的配置语言(也称为NIX)是一种非常好的配置语言，它不仅适用于包管理，还适用于更多的事情。</p><p> All in all, the Nix language is a lazy JSON with functions. It issimple yet powerful. It is used to generate Nix’s package descriptionsbut would be wellsuited to write any kind of configuration ( Terraform, Kubernetes, etc…).</p><p>总而言之，Nix语言是一种带函数的懒惰JSON。它很简单，但功能强大。它用于生成NIX的包描述，但非常适合编写任何类型的配置(Terraform、Kubernetes等…)。。</p><p> The rub is that the interpreter for Nix-the-language is tightlycoupled with Nix-the-package manager. So, as it stands, using theNix language for anything else than package management is a ratherpainful exercise.</p><p>问题在于，Nix-the-language的解释器与Nix-the-Package管理器紧密耦合。因此，按照目前的情况，将NIX语言用于包管理以外的任何事情都是一项非常痛苦的工作。</p><p> Nickel is our attempt at answering the question: what wouldNix-the-language look like if it was split from the package manager?While taking the opportunity to improve the language a little,building on the experience of the Nix community over the years.</p><p>我们试图回答这个问题：如果Nix-the-language从包管理器中分离出来，它会是什么样子？同时抓住机会稍微改进一下语言，以Nix社区多年来的经验为基础。</p><p>  Nickel is a lightweight generic configuration language. In that it canreplace YAML as your application’s configuration language. UnlikeYAML, though, it anticipates large configurations by beingprogrammable. Another way to use Nickel is to generate staticconfiguration files —  e.g. in JSON, YAML — that are then fed to another system. LikeNix, it is designed to have a simple, well-understood core: at itsheart, it is JSON with functions.</p><p>NICI是一种轻量级通用配置语言。因为它可以取代YAML作为应用程序的配置语言。不过，与YAML不同的是，它通过可编程实现了大型配置。使用Nickel的另一种方式是生成静态配置文件(例如JSON、YAML)，然后将其提供给另一个系统。像NikeNix一样，它被设计成有一个简单的、易于理解的核心：实际上，它是带有函数的JSON。</p><p> But past experience with Nix also brings some insights on which aspects of thelanguage could be improved. Whatever the initial scope of a language is, it willalmost surely be used in a way that deviates from the original plan: you createa configuration language to describe software packages, and next thing you know,somebody needs to implement a  topological sort.</p><p>但过去使用Nix的经验也带来了一些关于这种语言的哪些方面可以改进的见解。无论一种语言的初始范围是什么，它几乎肯定会以一种与原始计划不同的方式使用：您创建了一种配置语言来描述软件包，接下来您知道，需要有人实现拓扑排序。</p><p> Nickel strives to retain the simplicity of Nix, while extending itaccording to this feedback.Though, you can do perfectly fine without the new features and just write Nix-like code.</p><p>Niel努力保持Nix的简单性，同时根据这个反馈对其进行扩展，不过，您可以在没有新特性的情况下做得非常好，只需编写类似Nix的代码即可。</p><p>  At this point you’re probably wondering if this hasn’t already been done elsewhere.It seems that more and more languages are born every day, and surely therealready exist configuration languages with a similar purpose to Nickel: Starlark,  Jsonnet,  Dhall or  CUE, to namea few. So why Nickel?</p><p>在这一点上，您可能会想这是不是已经在其他地方做过了，似乎每天都有越来越多的语言诞生，并且肯定已经存在了与Nickel具有类似用途的配置语言：Starlark、Jsonnet、DHall或CUE，不一而足。那为什么是镍呢？</p><p>  Perhaps the most important difference with other configuration languages isNickel’s approach to typing.</p><p>也许与其他配置语言最重要的区别在于Nickel的键入方法。</p><p> Some languages, such as  Jsonnet or  Starlark, are notstatically typed. Indeed, static types can be seen as superflous in a configurationlanguage: if your program is only run once on fixed inputs, any type error willbe reported at run-time anyway. Why bother with a static type system?</p><p>一些语言，如Jsonnet或Starlark，不是静态类型的。实际上，静态类型在配置语言中可以被视为多余的：如果您的程序只在固定输入上运行一次，那么无论如何都会在运行时报告任何类型错误。为什么要为静态类型系统而烦恼呢？</p><p> On the other hand, more and more systems rely on complex configurations, such ascloud infrastructure ( Terraform,  Kubernetes or NixOps), leading the corresponding programs to become increasinglycomplex, to the point where static types are beneficial. For reusable code —that is, library functions — static types add structure, serve asdocumentation, and eliminate bugs early.</p><p>另一方面，越来越多的系统依赖于复杂的配置，如云基础设施(Terraform、Kubernetes或NixOps)，导致相应的程序变得越来越复杂，以至于静态类型是有益的。对于可重用的代码-也就是说，库函数-静态类型添加结构，作为文档，并及早消除错误。</p><p>  Dhall features a powerful type system that is able to type a wide range ofidioms. But it is complex, requiring some experience to become fluent in.</p><p>DHall有一个功能强大的打字系统，可以打字范围很广。但它很复杂，需要一些经验才能变得流利。</p><p> CUE is closer to what we are striving for. It has an optional and well-behavedtype system with strong guarantees. In exchange for which, one can’t write nortype higher-order functions in general, even if some simple functions arepossible to encode.</p><p>CUE更接近我们的奋斗目标。它有一个可选的、行为良好的系统，有很强的保证。作为交换，人们通常不能编写Nortype高阶函数，即使一些简单的函数可以编码。</p><p>  Nickel, features a   gradual type system.Gradual types are unobtrusive: they make it possible to staticallytype reusable parts of your programs, but you are still free to writeconfigurations without any types. Theinterpreter safely handles the interaction between the typed and untyped worlds.</p><p>渐变类型并不引人注目：它们使你可以对程序的可重用部分进行静态类型，但是你仍然可以自由地编写没有任何类型的配置。解释器安全地处理类型化和非类型化世界之间的交互。</p><p>  // file: mylib.ncl{ numToStr : Num -&gt; Str = fun n =&gt; ...; makeURL : Str -&gt; Str -&gt; Num -&gt; Str = fun proto host port =&gt; &#34;${proto}://${host}:${numToStr port}/&#34;;}</p><p>//文件：mylib.ncl{numToStr：Num-&gt；Str=Fun n=&gt；...；makeURL：Str-&gt；Str-&gt；Num-&gt；Str=Fun原始主机端口=&gt；&#34；${proto}：//${host}：${numToStr port}/&#34；；}。</p><p>  // file: server.ncllet mylib = import &#34;mylib.ncl&#34; inlet host = &#34;myproject.com&#34; in{ host = host; port = 1; urls = [ mylib.makeURL &#34;myproto&#34; host port, {protocol = &#34;proto2&#34;; server = &#34;sndserver.net&#34;; port = 4242} ];}</p><p>//file：server.ncllet mylib=import&#34；mylib.ncl&#34；input host=&#34；myproject.com&#34；in{host=host；port=1；urls=[mylib.makeURL&#34；myproto&#34；host port，{protocol=&#34；proto2&#34；；server=&#34；sndserver.net&#34；；port=4242}]；}。</p><p> In the first snippet, the body of  numToStr and  makeURL are staticallychecked: wrongfully calling  numToStr proto inside  makeURL would raise anerror even if  makeURL is never used. On the other hand, the second snippet isnot annotated, and thus not statically checked. In particular, we mix an URLrepresented as a string together with one represented as a record in the samelist. The interpreter rather inserts run-time checks, or  contracts, suchthat if  makeURL is misused then the program fails with anappropriate error.</p><p>在第一个代码片段中，对numToStr和makeURL的主体进行了统计检查：错误地在makeURL内调用numToStr proto会引发错误，即使从未使用过makeURL。另一方面，第二个代码段没有注释，因此没有进行静态检查。特别地，我们在同一列表中将表示为字符串的URL与表示为记录的URL混合在一起。相反，解释器会插入运行时检查或契约，例如，如果make URL被误用，则程序会失败，并出现相应的错误。</p><p> Gradual types also lets us keep the type system simple: even instatically typed code if you want to write a component that the typechecker doesn’t know how to verify, you don’t have to type-check thatpart.</p><p>渐进式类型还让我们保持类型系统的简单：即使是内部类型的代码，如果您要编写类型检查器不知道如何验证的组件，也不必对该部分进行类型检查。</p><p>  Complementary to the static type system, Nickel offers  contracts. Contractsoffer precise and accurate dynamic type error reporting, even in thepresence of function types. Contracts are used internally byNickel’s interpreter to insert guards at the boundary between typed and untypedchunks. Contracts are available to the programmer as well, to give them theability to enforce type assertions at run-time in a simple way.</p><p>作为静态类型系统的补充，Nickel提供合同。Contractsoffer精确而准确的动态类型错误报告，即使在存在函数类型的情况下也是如此。Nickel的解释器在内部使用合约在类型块和非类型块之间插入保护。合同也可供程序员使用，使他们能够以一种简单的方式在运行时强制执行类型断言。</p><p> One pleasant consequence of this design is that the exposure of the user to thetype system can be progressive:</p><p>这种设计的一个令人愉快的结果是，用户接触该类型系统的过程可以是渐进的：</p><p> Users writing configurations can just write Nix-like code while ignoring(almost) everything about typing, since you can seamlessly call a typedfunction from untyped code.</p><p>编写配置的用户可以只编写类似Nix的代码，而忽略(几乎)所有关于键入的内容，因为您可以从非类型化代码无缝调用typedfunction。</p><p>   While the basic computational blocks are functions, the basic data blocks inNickel are records (or objects in JSON). Nickel supports writing self-documentingrecord schemas, such as:</p><p>基本计算块是函数，而Nickel中的基本数据块是记录(或JSON中的对象)。Ni支持编写自记录记录模式，例如：</p><p> { host | type: Str | description: &#34;The host name of the server.&#34; | default: &#34;fallback.myserver.net&#34; ; port | type: Num | description: &#34;The port of the connection.&#34; | default: 4242 ; url | type: Url | description: &#34;The host name of the server.&#34; ;}</p><p>{host|type：str|description：&#34；|default：&#34；faulback.myserver.net&#34；；port|type：num|description：&#34；|default：4242；url|type：url|description：&#34；；}。</p><p> Each field can contain metadata, such as a description or defaultvalue. These aim at being displayed in documentation, or queried bytools.</p><p>每个字段都可以包含元数据，如描述或默认值。它们的目的是在文档中显示，或通过工具查询。</p><p> The schema can then be used as a contract. Imagine that a function hasswapped two values in its output and returns:</p><p>然后可以将该架构用作合同。假设一个函数在其输出中设置了两个值并返回：</p><p>  Without types, this is hard to catch. Surely, an error will eventually pop updownstream in the pipeline, but how and when? Using the schema abovewill make sure that, whenever the fields are actually evaluated, thefunction will be blamed in the type error.</p><p>没有类型，就很难捕捉到这一点。当然，错误最终会在管道的下游弹出，但如何以及何时出现错误呢？使用上面的模式可以确保，无论何时实际计算字段，函数都会被归咎于类型错误。</p><p> Schemas are actually part of a bigger story involving merging recordstogether, which, in particular, lets the schema instantiate missingfields with their default values. It is very much inspired by the NixOs module system and the  CUE language, butit is a story for another time.</p><p>模式实际上是涉及将记录合并在一起的更大故事的一部分，尤其是让模式用缺省值实例化缺少的字段。它非常受NixOS模块系统和CUE语言的启发，但这是另一个时代的故事。</p><p>  I hope that I gave you a sense of what Nickel is trying to achieve. Ionly presented its most salient aspects: its gradual type system withcontracts, and built-in record schemas. But there is more to explore!The language is not ready to be used in real world applications yet, but a goodshare of the design presented here is implemented. If you are curious about it, check it out!</p><p>我希望我能让你们对Nickel想要实现的目标有个了解。我只介绍了它最突出的方面：它的渐进型系统和合同，以及内置的记录模式。但是还有更多需要探索的地方！该语言还没有准备好在现实世界的应用程序中使用，但是这里展示的设计的很大一部分已经实现。如果你对它很好奇，那就去看看吧！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.tweag.io/blog/2020-10-22-nickel-open-sourcing/">https://www.tweag.io/blog/2020-10-22-nickel-open-sourcing/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/成本/">#成本</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/nickel/">#nickel</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>