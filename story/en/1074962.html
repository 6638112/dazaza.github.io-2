<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>黎明的基础：非类型多级级联演算Foundations of Dawn: The Untyped Multistack Concatenative Calculus</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Foundations of Dawn: The Untyped Multistack Concatenative Calculus<br/>黎明的基础：非类型多级级联演算</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-25 19:51:22</div><div class="page_narrow text-break page_content"><p>In the  last  Foundations of Dawn post, I formally defined the untyped (single stack) concatenative calculus (UCC), demonstrated encodings for booleans and natural numbers, and provided a toy programming language based on the UCC. In this post I will do the same for the untyped multistack concatenative calculus (UMCC), which enhances the UCC with an arbitrary number of arbitrarily named stacks. These extra stacks relieve much of the pain associated with stack shuffling in the UCC. They also provide some other benefits that we’ll begin to look at in this post and explore further in future posts.</p><p>在《黎明邮报》的最后一篇基础文章中，我正式定义了非类型（单堆栈）连接演算（UCC），演示了布尔数和自然数的编码，并提供了一种基于UCC的玩具编程语言。在这篇文章中，我将对非类型化多级级联演算（UMCC）做同样的事情，它通过任意数量的任意命名堆栈来增强UCC。这些额外的堆栈减轻了UCC中与堆栈洗牌相关的许多痛苦。它们还提供了一些其他好处，我们将在本文中开始介绍，并在未来的文章中进一步探讨。</p><p> If you identify any errors or omissions in this post or in the associated toy programming language, I would greatly appreciate it if you would  notify me. I would be happy to give attribution for any corrections or suggestions.</p><p>如果您在本文或相关玩具编程语言中发现任何错误或遗漏，如果您能通知我，我将不胜感激。我很乐意给出任何更正或建议的归属。</p><p>  The syntax of the UMCC extends that of the UCC by introducing the concept of stack contexts, which we denote by       ( s ∣ e ) (s|e)    ( s ∣ e ), where       s s    s is a stack identifier and       e e    e is an expression:</p><p>UMCC的语法通过引入堆栈上下文的概念扩展了UCC的语法，我们用（s）表示堆栈上下文∣ |e | e | s∣ e），其中s是堆栈标识符，e是表达式：</p><p> Expressions   e   =   i      intrinsic          ∣    [ e ]      quote          ∣     e 1    e 2   . . .    e n      compose          ∣    ( s ∣ e )    where  s ∉ S ( e )   stack context \begin{array}{ l l l l l l }\text{Expressions} &amp; e &amp; = &amp; i &amp; &amp; \text{intrinsic} \\ &amp; &amp; | &amp; [e] &amp; &amp; \text{quote} \\ &amp; &amp; | &amp; e_1~e_2~...~e_n &amp; &amp; \text{compose} \\ &amp; &amp; | &amp; (s|e) &amp; \text{where}~s\notin \mathbb{S}(e) &amp; \text{stack context} \\\end{array}               Expressions          ​             e          ​             =    ∣    ∣    ∣ ​             i    [ e ]     e        1 ​       e        2 ​      ...    e        n ​       ( s ∣ e ) ​                       where   s    ∈       /    S ( e ) ​              intrinsic     quote     compose     stack context ​</p><p>表达式e=i∣    [e]引用∣     e 1 e 2。作曲∣    （s）∣ e）在哪里∉ S（e）堆栈上下文\begin{array}{l}\text{Expressions}&amp；e&amp；=&amp；i&amp&amp；\文本{injective}\\\\&amp&|&amp；[e] &amp&amp；\文本{quote}\\\\&amp&|&amp；e_1~e_2~~e_n&amp&amp；\文本{compose}\\\\&amp&|&amp；（东南）及；\文本{where}~s\notin\mathbb{s}（e）&amp；\文本{stack context}\\\结束{array}表达式​             E​             =    ∣    ∣    ∣ ​             i[e]e 1​    E2​      ... 伊恩​       （s）∣ （e）​                       在哪里∈       /    S（e）​              内部引用组合堆栈上下文​</p><p>  S ( i )   =    { }     S ( [ e ] )   =    { }     S (  e 1    e 2   . . .    e n )   =    S (  e 1 ) ⋃ S (  e 2 ) ⋃ . . . ⋃ S (  e n )     S ( ( s ∣ e ) )   =    { s } ⋃ S ( e ) \begin{array}{ l l l l l l }\mathbb{S}(i ) &amp; = &amp; \{\} \\\mathbb{S}([e] ) &amp; = &amp; \{\} \\\mathbb{S}(e_1~e_2~...~e_n) &amp; = &amp; \mathbb{S}(e_1) \bigcup \mathbb{S}(e_2) \bigcup ... \bigcup \mathbb{S}(e_n) \\\mathbb{S}((s|e) ) &amp; = &amp; \{s\} \bigcup \mathbb{S}(e) \\\end{array}              S ( i )    S ([ e ])    S (  e        1 ​       e        2 ​      ...    e        n ​    )    S (( s ∣ e )) ​             =    =    =    = ​             { }    { }    S (  e        1 ​    )    S (  e        2 ​    )    ...    S (  e        n ​    )    { s }    S ( e ) ​</p><p>S（i）={S（[e]）={S（e1e2…en）=S（e1）⋃ S（E2）⋃ . . . ⋃ S（e n）S（（S）∣ e））={s}⋃ S（e）\begin{array}{l}\mathbb{S}（i）&amp；=&amp\{\}\\\mathbb{S}（[e]）&amp；=&amp\{\\\\mathbb{S}（e_1~e_2~…~e_n）&amp；=&amp；\mathbb{S}（e_1）\bigcup\mathbb{S}（e_2）\bigcup。。。\bigcup\mathbb{S}（e_n）\\\mathbb{S}（（S|e））&amp；=&amp\{s\}\bigcup\mathbb{s}（e）\\\end{array}s（i）s（[e]）s（e1）​    E2​      ... 伊恩​    )    S（（S）∣ （e）​             =    =    =    = ​             {}{}S（e1）​    )    S（E2）​    )    ...    S（e）n​    )    {s}s（e）​</p><p> The       s ∉ S ( e ) s\notin \mathbb{S}(e)    s    ∈       /      S ( e ) restriction essentially means that nested, unquoted stack contexts must have disjoint stack identifiers. Later in this post, we’ll look at how the       s ∉ S ( e ) s\notin \mathbb{S}(e)    s    ∈       /      S ( e ) restriction can effectively be lifted when implementing this calculus as a programming language.</p><p>s∉ S（e）S\notin\mathbb{S}（e）S∈       /      S（e）限制本质上意味着嵌套的、不带引号的堆栈上下文必须具有不相交的堆栈标识符。在这篇文章的后面，我们将看看∉ S（e）S\notin\mathbb{S}（e）S∈       /      将该演算作为编程语言实现时，可以有效地解除S（e）限制。</p><p>  The semantics of this calculus are defined by the effects that expressions have on value multistacks, which are essentially maps from stack identifiers to value stacks:</p><p>该演算的语义由表达式对值多个堆栈的影响定义，这些值多个堆栈本质上是从堆栈标识符到值堆栈的映射：</p><p> Values   v   =    [ e ]   quoted expression        Value Stacks   ⟨  s ∣ V ⟩   =   ⟨  s ∣ ⟩    empty stack  s          ∣   ⟨  s ∣ V   v ⟩    push  v  onto stack  s        Value Multistacks   V   =    V ϵ   empty multistack          ∣    V ⟨  s ∣ V ⟩    add stack  s \begin{array}{ l l r l l }\text{Values}&amp; v &amp; = &amp; [e] &amp; \text{quoted expression} \\\\\text{Value Stacks}&amp; \braket{s|V} &amp; = &amp; \braket{s|} &amp; \text{empty stack}~s \\&amp; &amp; | &amp; \braket{s|V~v} &amp; \text{push}~v~\text{onto stack}~s \\\\\text{Value Multistacks}&amp; \mathbb{V} &amp; = &amp; \mathbb{V}_\epsilon &amp; \text{empty multistack} \\&amp; &amp; | &amp; \mathbb{V} \braket{s|V} &amp; \text{add stack}~s \\\end{array}               Values        Value Stacks           Value Multistacks    ​             v     ⟨  s ∣ V ⟩       V    ​             =    =    ∣    =    ∣ ​             [ e ]     ⟨  s ∣ ⟩     ⟨  s ∣ V   v ⟩     V        ϵ ​       V   ⟨  s ∣ V ⟩ ​              quoted expression     empty stack   s     push   v    onto stack   s     empty multistack     add stack   s ​</p><p>Values v=[e]引用的表达式值堆栈⟨  s∣ 五、⟩   =   ⟨  s∣ ⟩    空栈∣   ⟨  s∣ V V⟩    将v推到堆栈s值多个堆栈v=vϵ空多个堆栈∣    五、⟨  s∣ 五、⟩    添加堆栈s\begin{array}{l}\text{Values}&amp；v&amp；=&amp；[e] &amp；\text{quoted expression}\text{Value Stacks}&amp；\布拉克特{s|V}&amp；=&amp；\布拉克特{s|}；\文本{empty stack}~s\\&amp&|&amp；\布拉克特{s|V~V}&amp；\text{push}~v~\text{on stack}~s\text{Value multistack}&amp；\mathbb{V}&amp；=&amp；\mathbb{V}\epsilon&amp；\文本{empty multistack}\\\\&amp&|&amp；\mathbb{V}\braket{s|V}&amp；\文本{add stack}~s\\\end{array}值堆栈值多个堆栈​             五、⟨  s∣ 五、⟩       五、​             =    =    ∣    =    ∣ ​             [e]⟨  s∣ ⟩     ⟨  s∣ V V⟩     Vϵ​       五、⟨  s∣ 五、⟩ ​              引用表达式空堆栈s将v推到堆栈s空多堆栈添加堆栈s​</p><p> Compared to the UCC, in the UMCC we replace the       swap \text{swap}     swap intrinsic with       push \text{push}     push and       pop \text{pop}     pop, which move values between stacks. So, in the UMCC there are seven intrinsic concatenative terms,       push \text{push}     push,       pop \text{pop}     pop,       clone \text{clone}     clone,       drop \text{drop}     drop,       quote \text{quote}     quote,       compose \text{compose}     compose, and       apply \text{apply}     apply, which are defined by the following small-step semantics:</p><p>与UCC相比，在UMCC中，我们用push\text{push}push和pop\text{pop}pop来替换swap\text{swap}swap内在函数，它们在堆栈之间移动值。因此，在UMCC中有七个内在的连接术语，push\text{push}push、pop\text{pop}pop、clone\text{clone}clone、drop\text{drop}drop、quote\text{quote}quote、compose\text{compose}compose和apply\text{apply}apply，由以下小步语义定义：</p><p> V ⟨  s ∣ V   v ⟩ ⟨   s ′ ∣  V ′    v ′ ⟩    (  s ′ ∣ ( s ∣ push ) )   ⟶    V ⟨  s ∣ V   v    v ′ ⟩ ⟨   s ′ ∣  V ′ ⟩     V ⟨  s ∣ V   v ⟩ ⟨   s ′ ∣  V ′    v ′ ⟩    (  s ′ ∣ ( s ∣ pop ) )   ⟶    V ⟨  s ∣ V ⟩ ⟨   s ′ ∣  V ′    v ′   v ⟩     V ⟨  s ∣ V   v ⟩    (  s ′ ∣ ( s ∣ clone ) )   ⟶    V ⟨  s ∣ V   v   v ⟩     V ⟨  s ∣ V   v ⟩    (  s ′ ∣ ( s ∣ drop ) )   ⟶    V ⟨  s ∣ V ⟩     V ⟨  s ∣ V   v ⟩    (  s ′ ∣ ( s ∣ quote ) )   ⟶    V ⟨  s ∣ V   [ v ] ⟩     V ⟨  s ∣ V   [  e 1   . . .    e n ]   [  e 1 ′   . . .    e n ′ ] ⟩    (  s ′ ∣ ( s ∣ compose ) )   ⟶    V ⟨  s ∣ V   [  e 1   . . .    e n    e 1 ′   . . .    e n ′ ] ⟩     V ⟨  s ∣ V   [ e ] ⟩    (  s ′ ∣ ( s ∣ apply ) )   ⟶    V ⟨  s ∣ V ⟩ (  s ′ ∣ ( s ∣ e ) ) \begin{array}{ l l l l }\mathbb{V}\braket{s|V~v}\braket{s&#39;|V&#39;~v&#39;} &amp; (s&#39;|(s|\text{push})) &amp; \longrightarrow &amp; \mathbb{V}\braket{s|V~v~v&#39;}\braket{s&#39;|V&#39;} \\\mathbb{V}\braket{s|V~v}\braket{s&#39;|V&#39;~v&#39;} &amp; (s&#39;|(s|\text{pop})) &amp; \longrightarrow &amp; \mathbb{V}\braket{s|V}\braket{s&#39;|V&#39;~v&#39;~v} \\\mathbb{V}\braket{s|V~v} &amp; (s&#39;|(s|\text{clone})) &amp; \longrightarrow &amp; \mathbb{V}\braket{s|V~v~v} \\\mathbb{V}\braket{s|V~v} &amp; (s&#39;|(s|\text{drop})) &amp; \longrightarrow &amp; \mathbb{V}\braket{s|V} \\\mathbb{V}\braket{s|V~v} &amp; (s&#39;|(s|\text{quote})) &amp; \longrightarrow &amp; \mathbb{V}\braket{s|V~[v]} \\\mathbb{V}\braket{s|V~[e_1~...~e_n]~[e&#39;_1~...~e&#39;_n]} &amp; (s&#39;|(s|\text{compose})) &amp; \longrightarrow &amp; \mathbb{V}\braket{s|V~[e_1~...~e_n~e&#39;_1~...~e&#39;_n]} \\\mathbb{V}\braket{s|V~[e]} &amp; (s&#39;|(s|\text{apply})) &amp; \longrightarrow &amp; \mathbb{V}\braket{s|V} (s&#39;|(s|e)) \\\end{array}              V   ⟨  s ∣ V   v ⟩   ⟨   s         ′ ∣  V         ′    v         ′ ⟩    V   ⟨  s ∣ V   v ⟩   ⟨   s         ′ ∣  V         ′    v         ′ ⟩    V   ⟨  s ∣ V   v ⟩    V   ⟨  s ∣ V   v ⟩    V   ⟨  s ∣ V   v ⟩    V   ⟨  s ∣ V   [  e        1 ​      ...    e        n ​    ]   [  e        1     ′ ​      ...    e        n     ′ ​    ] ⟩    V   ⟨  s ∣ V   [ e ] ⟩ ​             (  s         ′ ∣ ( s ∣  push ))    (  s         ′ ∣ ( s ∣  pop ))    (  s         ′ ∣ ( s ∣  clone ))    (  s         ′ ∣ ( s ∣  drop ))    (  s         ′ ∣ ( s ∣  quote ))    (  s         ′ ∣ ( s ∣  compose ))    (  s         ′ ∣ ( s ∣  apply )) ​             ⟶    ⟶    ⟶    ⟶    ⟶    ⟶    ⟶ ​             V   ⟨  s ∣ V   v    v         ′ ⟩   ⟨   s         ′ ∣  V         ′ ⟩    V   ⟨  s ∣ V ⟩   ⟨   s         ′ ∣  V         ′    v         ′   v ⟩    V   ⟨  s ∣ V   v   v ⟩    V   ⟨  s ∣ V ⟩    V   ⟨  s ∣ V   [ v ] ⟩    V   ⟨  s ∣ V   [  e        1 ​      ...    e        n ​       e        1     ′ ​      ...    e        n     ′ ​    ] ⟩    V   ⟨  s ∣ V ⟩  (  s         ′ ∣ ( s ∣ e )) ​</p><p>五、⟨  s∣ V V⟩ ⟨   s′∣  V'V'⟩    （s′）∣ （s）∣ 推）⟶    五、⟨  s∣ V′⟩ ⟨   s′∣  V′⟩     五、⟨  s∣ V V⟩ ⟨   s′∣  V'V'⟩    （s′）∣ （s）∣ 流行音乐）⟶    五、⟨  s∣ 五、⟩ ⟨   s′∣  V′V′V⟩     五、⟨  s∣ V V⟩    （s′）∣ （s）∣ 克隆）⟶    五、⟨  s∣ V V V⟩     五、⟨  s∣ V V⟩    （s′）∣ （s）∣ 下降）⟶    五、⟨  s∣ 五、⟩     五、⟨  s∣ V V⟩    （s′）∣ （s）∣ 引用）⟶    五、⟨  s∣ V[V]⟩     五、⟨  s∣ V[e1…en][e1′…en′]⟩    （s′）∣ （s）∣ 作曲）⟶    五、⟨  s∣ V[e1…e1′…enn′]⟩     五、⟨  s∣ V[e]⟩    （s′）∣ （s）∣ （适用）⟶    五、⟨  s∣ 五、⟩ （s′）∣ （s）∣ e））\begin{array}{l}\mathbb{V}\braket{s|V~V}\braket{s&#39；|V&#39；~V&#39；}&amp；（s&#39；|（s | \text{push}））和；\longrightarrow&amp；\mathbb{V}\braket{s|V~V~V&#39；}\布拉克特{s&#39；|V&#39；}\\\mathbb{V}\braket{s|V~V}\braket{s&#39；|V&#39；~V&#39；}&amp；（s&#39；|（s | \text{pop}））和；\longrightarrow&amp；\mathbb{V}\braket{s|V}\braket{s&#39；|V&#39；~V&#39；~V}\\\ mathbb{V}\braket{s | V~V}&amp；（s&#39；|（s | \text{clone}））&amp；\longrightarrow&amp；\mathbb{V}\braket{s|V~V~V}\\\ mathbb{V}\braket{s|V~V}&amp；（s&#39；|（s | \text{drop}））&amp；\longrightarrow&amp；\mathbb{V}\braket{s|V}\\\ mathbb{V}\braket{s|V~V}&amp；（s&#39；|（s | \text{quote}）和；\longrightarrow&amp；\mathbb{V}\braket{s|V~[V]}\\\ mathbb{V}\braket{s|V~[e|u 1~~~e#n]~[e&#39；#u 1~~~e&#39；#n]&amp；（s&#39；|（s | \text{compose}））和；\longrightarrow&amp；\mathbb{V}\braket{s|V~[e|1~~~e|n~e&#39；_1~~~e&#39；#n]\\\\ mathbb{V}\braket{s|V~[e]}&amp；（s&#39；|（s | \text{apply}））&amp；\longrightarrow&amp；\mathbb{V}\braket{s|V}（s&#39；|（s|e））\\\end{array}V⟨  s∣ V V⟩   ⟨   s′∣  V'V'⟩    五、⟨  s∣ V V⟩   ⟨   s′∣  V'V'⟩    五、⟨  s∣ V V⟩    五、⟨  s∣ V V⟩    五、⟨  s∣ V V⟩    五、⟨  s∣ V[e 1​      ... 伊恩​    ] [e1′”​      ... e n′的​    ] ⟩    五、⟨  s∣ V[e]⟩ ​             （s′）∣ （s）∣  推（s′）∣ （s）∣  （流行音乐）∣ （s）∣  克隆（s′）∣ （s）∣  下降（s′）∣ （s）∣  （引语）∣ （s）∣  组合（s′）∣ （s）∣  （适用）​             ⟶    ⟶    ⟶    ⟶    ⟶    ⟶    ⟶ ​             五、⟨  s∣ V′⟩   ⟨   s′∣  V′⟩    五、⟨  s∣ 五、⟩   ⟨   s′∣  V′V′V⟩    五、⟨  s∣ V V V⟩    五、⟨  s∣ 五、⟩    五、⟨  s∣ V[V]⟩    五、⟨  s∣ V[e 1​      ... 伊恩​    e1′​      ... e n′的​    ] ⟩    五、⟨  s∣ 五、⟩  （s′）∣ （s）∣ （e）​</p><p>  V ⟨  s ∣ V ⟩    (  s ′ ∣ ( s ∣ [ e ] ) )   ⟶    V ⟨  s ∣ V   [ e ] ⟩ \begin{array}{ l l l l }\mathbb{V}\braket{s|V} &amp; (s&#39;|(s|[e])) &amp; \longrightarrow &amp; \mathbb{V} \braket{s|V~[e]} \\\end{array}              V   ⟨  s ∣ V ⟩ ​             (  s         ′ ∣ ( s ∣ [ e ])) ​             ⟶ ​             V   ⟨  s ∣ V   [ e ] ⟩ ​</p><p>五、⟨  s∣ 五、⟩    （s′）∣ （s）∣ [e]））⟶    五、⟨  s∣ V[e]⟩ \开始{array}{l}\mathbb{V}\braket{s|V}&amp；（s&#39；|（s |[e]））&amp；\longrightarrow&amp；\mathbb{V}\braket{s|V~[e]}\\\ end{array}V⟨  s∣ 五、⟩ ​             （s′）∣ （s）∣ [e]））​             ⟶ ​             五、⟨  s∣ V[e]⟩ ​</p><p>  V    e 1    e 2   . . .    e n   =    ( ( ( ( V    e 1 )    e 2 )   . . . )    e n ) \begin{array}{ l l l }\mathbb{V}~e_1~e_2~...~e_n &amp; = &amp; ((((\mathbb{V}~e_1)~e_2)~...)~e_n) \\\end{array}              V    e        1 ​       e        2 ​      ...    e        n ​    ​             = ​             (((( V    e        1 ​    )    e        2 ​    )   ... )    e        n ​    ) ​</p><p>ve1e2。eN=（（ve1）e2）en）\begin{array}{l}\mathbb{V}~e_1~e_2~~e_n&amp；=&amp；（（（\mathbb{V}~e_1）~e_2）~.）~e_n）\\\end{array}V e 1​    E2​      ... 伊恩​    ​             = ​             （（（V）e 1）​    ) E2​    )   ... ) 伊恩​    ) ​</p><p> Compared to the UCC, three additional rules are needed in order to reduce all valid UMCC expressions. First, stack contexts distribute over composed sub-expressions:</p><p>与UCC相比，为了减少所有有效的UMCC表达式，还需要三条额外的规则。首先，堆栈上下文分布在组合的子表达式上：</p><p> ( s ∣  e 1    e 2   . . .    e n )   ⟷    ( s ∣  e 1 )   ( s ∣  e 2 )   . . .   ( s ∣  e n ) \begin{array}{ l l l }(s|e_1~e_2~...~e_n) &amp; \longleftrightarrow &amp; (s|e_1)~(s|e_2)~...~(s|e_n) \\\end{array}              ( s ∣  e        1 ​       e        2 ​      ...    e        n ​    ) ​             ⟷ ​             ( s ∣  e        1 ​    )   ( s ∣  e        2 ​    )   ...   ( s ∣  e        n ​    ) ​</p><p>（s）∣  e 1 e 2。e（n）⟷    （s）∣  e 1）（s）∣  e 2）。（s）∣  开始{array}{l}（s|e_1~e_2~…~e_n）&amp；\longleftrightarrow&amp；（s|e_1）～（s|e_2）～~（s | e_n）\\\end{array}（s）∣  e 1​    E2​      ... 伊恩​    ) ​             ⟷ ​             （s）∣  e 1​    ) （s）∣  E2​    )   ... （s）∣  伊恩​    ) ​</p><p> Second, when more than two stack contexts are directly nested, the outer-most context is redundant and can be removed:</p><p>其次，当两个以上的堆栈上下文直接嵌套时，最外层的上下文是冗余的，可以删除：</p><p> (  s  ′ ′ ∣ (  s ′ ∣ ( s ∣ e ) ) )   ⟶    (  s ′ ∣ ( s ∣ e ) ) \begin{array}{ l l l }(s&#39;&#39;|(s&#39;|(s|e))) &amp; \longrightarrow &amp; (s&#39;|(s|e)) \\\end{array}              (  s         ′′ ∣ (  s         ′ ∣ ( s ∣ e ))) ​             ⟶ ​             (  s         ′ ∣ ( s ∣ e )) ​</p><p>（s′）∣ （s′）∣ （s）∣ （e）⟶    （s′）∣ （s）∣ e））\begin{array}{l}（s&#39；&#39；|（s&#39；|（s | e））&amp；\longrightarrow&amp；（s&#39；|（s|e））\\\end{array}（s′）∣ （s′）∣ （s）∣ （e）​             ⟶ ​             （s′）∣ （s）∣ （e）​</p><p>  (  s ′ ( s ∣ ) )   ⟶    (  s ′ ∣ )   ⟶   . \begin{array}{ l l l l l }(s&#39;(s|)) &amp; \longrightarrow &amp; (s&#39;|) &amp; \longrightarrow &amp; . \\\end{array}              (  s         ′ ( s ∣ )) ​             ⟶ ​             (  s         ′ ∣ ) ​             ⟶ ​             . ​</p><p>（s′）∣ ) )   ⟶    （s′）∣ )   ⟶   . \开始{array}{l}（s&#39；（s|）和；\longrightarrow&amp；（s&#39；|）和；\longrightarrow&amp\\\结束{array}（s′）∣ )) ​             ⟶ ​             （s′）∣ ) ​             ⟶ ​             . ​</p><p> This completes the operational semantics for the UMCC. By extending the UCC with stack contexts, a few new rules for reducing them, and two new intrinsics for moving values between stacks, we arrive at a concatenative calculus that is still incredibly small and simple while being considerably more practical for writing useful programs. As I began describing in   Introducing Dawn (Part 1), multistacks alleviate the pain of stack shuffling and significantly improve readability and writability compared to other concatenative languages, while retaining the positive aspects of concatenative languages. Furthermore, as we’ll begin to see later in this post, multistack concatenative languages have other interesting features such as something like global variables but without the drawbacks that global variables typically entail.</p><p>这就完成了UMCC的操作语义。通过使用堆栈上下文扩展UCC、减少它们的一些新规则，以及在堆栈之间移动值的两个新内部函数，我们得到了一个级联演算，它仍然非常小和简单，同时对于编写有用的程序来说更实用。正如我在介绍Dawn（第1部分）中开始描述的那样，与其他级联语言相比，Multistack减轻了堆栈洗牌的痛苦，显著提高了可读性和可写性，同时保留了级联语言的积极方面。此外，正如我们将在本文后面开始看到的，多级连接语言还有其他有趣的特性，比如全局变量，但没有全局变量通常带来的缺点。</p><p>  We can embed the UCC in the UMCC by translating any UCC expression,        e  U C C e_{UCC}     e         U CC ​   , into the corresponding UMCC expression,        e  U M C C = (  s ′ ∣ ( s ∣  e  U C C ) ) e_{UMCC} = (s&#39;|(s|e_{UCC}))     e         U MCC ​     =    (  s         ′ ∣ ( s ∣  e         U CC ​    )), and by defining a       swap \text{swap}     swap term. To define       swap \text{swap}     swap, we simply need to pick two fresh stack identifiers, e.g.        s 1 s_1     s        1 ​    and        s 1 ′ s&#39;_1     s        1     ′ ​   , push the top two values onto them, and then pop them off in swapped order:</p><p>我们可以通过翻译任何UCC表达式来将UCC嵌入到UMCC中​   , 在相应的UMCC表达式中，eum C=（s′）∣ （s）∣  e U C C）e_{UMCC}=（s&#39；|（s|e_{UCC}））e U MCC​     =    （s′）∣ （s）∣  e U CC​    )), 通过定义swap\text{swap}交换项。要定义swap\text{swap}swap，我们只需要选择两个新的堆栈标识符，例如s1 s_1 s1​    s1&#39_1s1′​   , 将最上面的两个值按在上面，然后按交换顺序将其弹出：</p><p> swap = (  s 1 ∣ push ) (  s 1 ′ ∣ push ) (  s 1 ∣ pop ) (  s 1 ′ ∣ pop ) \qquad\text{swap} = (s_1|\text{push}) (s&#39;_1|\text{push}) (s_1|\text{pop}) (s&#39;_1|\text{pop})      swap  =    (  s        1 ​    ∣  push ) (  s        1     ′ ​    ∣  push ) (  s        1 ​    ∣  pop ) (  s        1     ′ ​    ∣  pop )</p><p>互换=（s1）∣ 推（s1′）∣ 推（s1）∣ pop）（s1′）∣ pop）\qquad\text{swap}=（s|1 | \text{push}）（s&#39；|1 | \text{push}）（s|u 1 | \text{pop}）（s&#39；|1 | \text{pop}）swap=（s1​    ∣  推（s1′）​    ∣  推（s1）​    ∣  pop）（s1′）​    ∣  （流行音乐）</p><p>  When implementing the UMCC as a programming language, we will want to extend the core calculus with user-defined terms. Unfortunately, the       s ∉ S ( e ) s\notin \mathbb{S}(e)    s    ∈       /      S ( e ) restriction on stack contexts presents a problem that we must address. If the user defines a term that contains the stack identifier       s s    s, then obeying the       s ∉ S ( e ) s\notin \mathbb{S}(e)    s    ∈       /      S ( e ) restriction would preclude use of that term inside of any other       s s    s stack context, which is an undesirable limitation. If we ignore this restriction without any other changes, though, then that term would behave differently depending on whether or not it’s used inside an       s s    s stack context, which could result in considerable confusion.</p><p>在将UMCC作为编程语言实现时，我们希望用用户定义的术语扩展核心演算。不幸的是∉ S（e）S\notin\mathbb{S}（e）S∈       /      S（e）对堆栈上下文的限制提出了一个我们必须解决的问题。如果用户定义了一个包含堆栈标识符的术语，则遵循∉ S（e）S\notin\mathbb{S}（e）S∈       /      S（e）限制将阻止在任何其他S堆栈上下文中使用该术语，这是一个不受欢迎的限制。但是，如果我们忽略这个限制而不做任何其他更改，那么这个术语的行为就会有所不同，这取决于它是否在s的堆栈上下文中使用，这可能会导致相当大的混乱。</p><p> Luckily, we can easily resolve this issue by having the interpreter/compiler automatically rename unquoted stack identifiers when they shadow an outer stack context. We will refer to this transformation as stack identifier  deshadowing. There are two situations in which deshadowing is necessary—first, when evaluating the       apply \text{apply}     apply intrinsic, and second, when evaluating (i.e. expanding) a user-defined term. In order to make it trivial for users to inline term definitions even when they contain unquoted shadowing stack identifiers, we can additionally apply deshadowing when defining new terms and when beginning to reduce a new expression in the interpreter’s read-eval-print loop (REPL). If applied in all four of these situations, deshadowing effectively lifts the       s ∉ S ( e ) s\notin \mathbb{S}(e)    s    ∈       /      S ( e ) restriction, entirely.</p><p>幸运的是，我们可以通过让解释器/编译器在对外部堆栈上下文进行阴影处理时自动重命名未引用的堆栈标识符来轻松解决这个问题。我们将此转换称为堆栈标识符去阴影。有两种情况需要去阴影，第一种是在评估apply\text{apply}apply内在时，第二种是在评估（即扩展）用户定义的术语时。为了让用户即使在术语定义包含无引号的阴影堆栈标识符时也可以内联术语定义，我们还可以在定义新术语以及开始减少解释器的read-eval-print循环（REPL）中的新表达式时应用去阴影。如果在这四种情况下都使用，去阴影可以有效地提升阴影∉ S（e）S\notin\mathbb{S}（e）S∈       /      完全是S（e）限制。</p><p>  Just as for the UCC, in order to test and validate everything written in this post, I have implemented an interpreter, the UMCCI, for a toy programming language based on this calculus. The toy programming language extends the core calculus with user-defined terms, which can be directly or mutually recursive, and uses stack identifier deshadowing to lift the       s ∉ S ( e ) s\notin \mathbb{S}(e)    s    ∈       /      S ( e ) restriction, as described above. In addition, in order to reduce boilerplate, when evaluating an expression without any stack contexts, the interpreter automatically wraps the expression in default stack contexts.</p><p>就像UCC一样，为了测试和验证本文中的所有内容，我为一种基于这种演算的玩具编程语言实现了一个解释器UMCCI。toy编程语言使用用户定义的术语扩展了核心演算，这些术语可以直接或相互递归，并使用堆栈标识符去阴影来提升∉ S（e）S\notin\mathbb{S}（e）S∈       /      S（e）限制，如上所述。此外，为了简化样板文件，当在没有任何堆栈上下文的情况下计算表达式时，解释器会自动将表达式包装在默认堆栈上下文中。</p><p> The interpreter is available to  try in your browser, and the  source code is available on Github. Most of the terms described in this post come predefined, but any and all terms can be redefined by the user. Example sessions will be shown in the remainder of this post.</p><p>解释器可以在浏览器中试用，源代码可以在Github上获得。本文中描述的大多数术语都是预定义的，但任何术语都可以由用户重新定义。示例会话将在本文的其余部分显示。</p><p>  Next, we’ll take a look at how we might perform some computations in this calculus, just as we did for the UCC. This calculus still does not include any built-in data types, so we will still encode data types as quoted expressions. While we  could use the same encodings for booleans and natural numbers that we did in the UCC, we’ll instead use a more general and systematic encoding, and we’ll take advantage of multistacks to improve ergonomics. In particular, we will take inspiration from the  Scott encoding for arbitrary (including recursive) algebraic data types (ADTs) in the untyped lambda calculus, and apply the same concept to the UMCC. First, we’ll formally define the encoding, and then we’ll take a look at several examples including booleans and natural numbers.</p><p>接下来，我们将看看如何在这个微积分中执行一些计算，就像我们在UCC中所做的那样。这个演算仍然不包括任何内置的数据类型，所以我们仍然将数据类型编码为带引号的表达式。虽然我们可以使用与UCC中相同的布尔和自然数编码，但我们将使用更通用、更系统的编码，我们将利用多个堆栈来改进人体工程学。特别是，我们将从非类型化lambda演算中任意（包括递归）代数数据类型（ADT）的Scott编码中获得灵感，并将相同的概念应用于UMCC。首先，我们将正式定义编码，然后我们将看几个例子，包括布尔数和自然数。</p><p>  The basic idea behind  Scott encoding is to encode each variant of an algebraic data type as a higher-order term that acts as both the constructor and destructor (a.k.a. eliminator). When applied to a variant’s input data, the constructor returns a closure over that input data. When that closure is then applied to a case expression for each possible variant, it applies only the case expression for the encoded variant to the closed-over data. So the closure acts as the destructor. In the untyped lambda calculus, the destructor is applied to case expressions in a particular order. Similarly, in the UCC, we would place quoted case expressions on top of the stack in a particular order and then apply the destructor. In the UMCC, we’ll instead place quoted case expressions on top of particular stacks and then apply the destructor.</p><p>Scott编码背后的基本思想是将代数数据类型的每个变量编码为一个高阶项，该项同时充当构造函数和析构函数（也称为消除器）。当应用于变量的输入数据时，构造函数返回该输入数据的闭包。然后，当该闭包应用于每个可能变量的case表达式时，它仅将编码变量的case表达式应用于闭合的over数据。所以闭包充当析构函数。在非类型化lambda演算中，析构函数按特定顺序应用于case表达式。类似地，在UCC中，我们将按特定顺序将带引号的大小写表达式放在堆栈顶部，然后应用析构函数。在UMCC中，我们将把带引号的大小写表达式放在特定堆栈的顶部，然后应用析构函数。</p><p> Formally, let       D D    D be an algebraic data type with       N N    N constructors,       {  C i  }  i = 1 N \{C_i\}_{i=1}^N    {  C        i ​     }         i = 1    N ​   , such that constructor        C i C_{i}     C         i ​    has arity        A i A_{i}     A         i ​   . The encoding of constructor        C i C_{i}     C         i ​    of the data type       D D    D is given by</p><p>形式上，设D是一个具有N个构造函数的代数数据类型，{C i}i=1 N\{C_i\}{i=1}^N{C i​     }         i=1N​   , 这样构造函数ci_{i}ci​    有arity A i_{i}A i吗​   . 构造函数ci_{i}ci的编码​    数据类型D的</p><p> C i =  quote  A i   [  C i ′ ]  compose \qquad C_i = \text{quote}_{A_i}~[C&#39;_i]~\text{compose}      C        i ​     =      quote          A        i ​    ​      [  C        i     ′ ​    ]    compose</p><p>C i=quote A i[C i′]组合\qquad C_i=\text{quote}{A_i}~[C&#39；_i]~\text{compose}C i​     =      引用我的话​    ​    [ci′的​    ] 谱写</p><p>  C i ′ = ( case_  C 1 ∣ drop ) . . . ( case_  C  i − 1 ∣ drop ) ( case_  C i ∣ pop ) ( case_  C  i + 1 ∣ drop ) . . . ( case_  C N ∣ drop )  apply \qquad C&#39;_i = (\text{case\_}C_1|\text{drop}) ... (\text{case\_}C_{i-1}|\text{drop})(\text{case\_}C_i|\text{pop})(\text{case\_}C_{i+1}|\text{drop})... (\text{case\_}C_N|\text{drop})~\text{apply}      C        i     ′ ​     =    (  case_  C        1 ​    ∣  drop ) ... (  case_  C         i − 1 ​    ∣  drop ) (  case_  C        i ​    ∣  pop ) (  case_  C         i + 1 ​    ∣  drop ) ... (  case_  C        N ​    ∣  drop )    apply</p><p>C i′=（案例1）∣ 放下）。（案例一）− 1.∣ （第一种情况）∣ （pop）（案例1+1）∣ 放下）。（案例N）∣ 下拉）应用\qquad C和#39_i=（\text{case\}C_1 | \text{drop}）。。。（\text{case\}C{i-1}| \text{drop}）（\text{case\}C_i | \text{pop}）（\text{case\}C{i+1}| \text{drop}）。。。（\text{case\\}C|N | \text{drop}）~\text{apply}ci′​     =    （案例1）​    ∣  放下）。。。（案例一）− 1.​    ∣  （第一种情况）​    ∣  （pop）（案例1+1）​    ∣  放下）。。。（案例N）​    ∣  放弃）申请</p><p> and where        quote n \text{quote}_{n}      quote         n ​    accepts       n n    n inputs and returns a single quote containing all of the inputs:</p><p>其中quote n\text{quote}{n}quote n​    接受n个输入并返回一个包含所有输入的单引号：</p><p> V ⟨  s ∣ V    v 1 . . .  v n ⟩ (  s ′ ∣ ( s ∣  quote n ) ) ⇓ V ⟨  s ∣ V   [  v 1 . . .  v n ] ⟩ \qquad\mathbb{V}\braket{s|V~v_1...v_n} (s&#39;|(s|\text{quote}_n)) \Downarrow \mathbb{V}\braket{s|V~[v_1...v_n]}     V   ⟨  s ∣ V    v        1 ​    ...  v        n ​    ⟩  (  s         ′ ∣ ( s ∣   quote        n ​    ))  ⇓    V   ⟨  s ∣ V   [  v        1 ​    ...  v        n ​    ] ⟩</p><p>五、⟨  s∣ v1。v n⟩ （s′）∣ （s）∣  引用（n））⇓ 五、⟨  s∣ V[v1…vn]⟩ \qquad\mathbb{V}\braket{s|V~V|1…V|n}（s&#39；|（s | \text{quote}n））\Downarrow\mathbb{V}\braket{s|V~[V|1…V|n]}V⟨  s∣ v1​    ...  v n​    ⟩  （s′）∣ （s）∣   引用n​    ))  ⇓    五、⟨  s∣ V[v1​    ...  v n​    ] ⟩</p><p>    quote  n &gt; 1 = (  s n ∣ push ) . . . (  s 1 ∣ push )   (  s 1 ∣ quote pop ) . . . (  s n ∣ quote pop )    compose n \qquad\text{quote}_{n&gt;1} = (s_n| \text{push})...(s_1| \text{push})~(s_1|\text{quote}~\text{pop})...(s_n|\text{quote}~\text{pop})~\text{compose}_n       quote         n &gt; 1 ​     =    (  s        n ​    ∣  push ) ... (  s        1 ​    ∣  push )   (  s        1 ​    ∣  quote    pop ) ... (  s        n ​    ∣  quote    pop )     compose        n ​</p><p>引用n&gt；1=（s n）∣ 推）。（s 1）∣ 推（s1）∣ 引用流行音乐）。（s）n∣ quote pop）组合n\qquad\text{quote}{n&gt；1}=（s_n | \text{push}）。。。（s|1 | \text{push}）~（s|1 | \text{quote}~\text{pop}）。。。（s|n | \text{quote}~\text{pop}）~\text{compose}n quote n&gt；1.​     =    （s）n​    ∣  推）。。。（s 1）​    ∣  推（s1）​    ∣  引用流行音乐）。。。（s）n​    ∣  引用流行语​</p><p> where        compose n \text{compose}_n      compose        n ​    composes       n n    n quotes and has the same definition as in the  previous post on the UCC.</p><p>其中compose n\text{compose}n compose n​    由n个引号组成，定义与UCC上的前一篇文章相同。</p><p> To destructure an ADT encoded in this way, place a quoted case expression on top of each case stack and then apply the destructor:</p><p>要分解以这种方式编码的ADT，请在每个case堆栈的顶部放置一个带引号的case表达式，然后应用析构函数：</p><p> ( case_  C 1 ∣ [  e 1 ] ) . . . ( case_  C N ∣ [  e N ] )  apply \qquad(\text{case\_}C_1|[e_1]) ... (\text{case\_}C_N|[e_N])~\text{apply}     (  case_  C        1 ​    ∣ [  e        1 ​    ]) ... (  case_  C        N ​    ∣ [  e        N ​    ])    apply</p><p>（案例1）∣ [e 1]）。（案例N）∣ [en]）应用\qquad（\text{case\}C_1 |[e_1]）。。。（\text{case\}C|N |[e_N]）~\text{apply}（case_c1​    ∣ [e 1​    ]) ... （案例N）​    ∣ [e N​    ]) 申请</p><p> As we’ll see in the examples below, destructuring closely resembles simple exhaustive pattern matching in ML-family languages. Ultimately, Dawn will include more ergonomic forms of pattern matching, such as recursive and multi-value matching. In a future post, we’ll examine such ergonomic pattern matching forms and derive how they can be lowered to the limited form of destructing available in the UMCC.</p><p>正如我们将在下面的示例中看到的，解构非常类似于ML家族语言中的简单穷举模式匹配。最终，Dawn将包括更多符合人体工程学的模式匹配形式，如递归和多值匹配。在未来的帖子中，我们将研究这种符合人体工程学的模式匹配形式，并推导出如何将它们降低到UMCC中可用的有限破坏形式。</p><p>  In the last post on the UCC, we encoded booleans as quoted higher-order terms that, when applied, accepted two  values, one for the false case and one for the true case, dropped the non-matching case value, and kept the matching case value. Here, our encoding of booleans will accept two  quoted case expressions, one for the false case and one for the true case, drop the non-matching quoted case expression, and keep  and apply the matching quoted case expression. The result is that applying a boolean is analogous to simple exhaustive pattern matching on a boolean in an ML-family language, such as Haskell. Thus, the following Haskell and UMCC definitions are equivalent:</p><p>在UCC上的最后一篇文章中，我们将布尔值编码为引用的高阶项，当应用时，它们接受两个值，一个用于false case，一个用于true case，删除不匹配的case值，并保留匹配的case值。在这里，我们的布尔编码将接受两个带引号的大小写表达式，一个用于假大小写，一个用于真大小写，删除不匹配的带引号的大小写表达式，保留并应用匹配的带引号的大小写表达式。结果是，应用布尔值类似于在ML家族语言（如Haskell）中对布尔值进行简单的穷举模式匹配。因此，以下Haskell和UMCC定义是等效的：</p><p>  data Bool = False | Truenot a = case a of False -&gt; True True -&gt; Falseor a b = case b of False -&gt; case a of False -&gt; False True -&gt; True True -&gt; Trueand a b = case b of False -&gt; False True -&gt; case a of False -&gt; False True -&gt; True</p><p>数据Bool=False | Truenot a=False的情况a-&gt；正确-正确-&gt；Falseor a b=情况b为False-&gt；错误案例a-&gt；假-真-&gt；正确-正确-&gt；True和a b=情况b为False-&gt；假-真-&gt；错误案例a-&gt；假-真-&gt；符合事实的</p><p>  {term False = quote0 [_False] compose}{term True = quote0 [_True] compose}{term _False = (case_False|pop) (case_True|drop) apply}{term _True = (case_False|drop) (case_</p><p>{term False=quote0[_False]compose}{term True=quote0[_真]compose}{term _False=（case | False | pop）（case | True | drop）apply}{term(case | False | drop)_</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/黎明/">#黎明</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/dawn/">#dawn</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/堆栈/">#堆栈</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>