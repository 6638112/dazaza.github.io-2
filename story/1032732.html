<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Unix域套接字上的文件描述符传输</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Unix域套接字上的文件描述符传输</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-02 14:21:43</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/5ef2ea312d19aa1f2a1506f2e04253c4.png"><img src="http://img2.diglog.com/img/2020/11/5ef2ea312d19aa1f2a1506f2e04253c4.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>昨天，我读了一篇现象级的论文，内容是如何无中断地发布使用不同协议并服务于不同类型的请求(长时间的TCP/UDP会话、涉及大量数据的请求等)的服务。在脸书工作。</p><p>Facebook使用的技术之一是他们所说的“套接字接管”。</p><p>套接字接管通过并行启动接管侦听套接字的更新实例来实现Proxygen的零停机重新启动，而旧实例则进入正常排出阶段。新实例承担服务新连接和响应来自L4LB Katran的运行状况检查探测的责任。旧连接由较旧的实例服务，直到排空周期结束，在此之后，其他机制(例如，下行连接重用)开始发挥作用。</p><p>当我们将打开的FD从旧进程传递到新旋转的进程时，传递进程和接收进程共享侦听套接字的相同文件表项，并处理各自接受的连接，它们在这些连接上为连接级事务提供服务。我们利用以下Linux内核功能来实现这一点：</p><p>CMSG：sendmsg()中的一个特性允许在本地进程之间发送控制消息(通常称为辅助数据)。在L7LB进程重启期间，我们使用此机制将每个VIP(服务的虚拟IP)的所有活动侦听套接字的FD集从活动实例发送到新旋转的实例。此数据通过UNIX域套接字使用sendmsg和recvmsg进行交换。</p><p>SCM_RIGHTS：我们将此选项设置为发送开放式FD，其数据部分包含开放式FD的整数数组。在接收端，这些FD的行为就像它们是使用DUP(2)创建的一样。</p><p>我在推特上收到了许多人的回复，他们对这一可能性表示惊讶。事实上，如果您不太熟悉Unix域套接字的一些特性，本文中的前述段落可能会让人费解。</p><p>Unix域套接字上的传输环TCP套接字实际上是实现“热重新启动”或“零停机重新启动”的一种久经考验的方法。流行的代理(如HAProxy和特使)使用非常类似的机制将连接从一个代理实例排出到另一个实例，而不会丢弃任何连接。然而，这些功能中的许多并不是非常广为人知的。</p><p>在这篇文章中，我想探讨Unix域套接字的一些特性，这些特性使其适合于其中几种用例，特别是在两个进程之间不一定存在父子关系的情况下，将套接字(或任何文件描述符)从一个进程传输到另一个进程。</p><p>众所周知，Unix域套接字允许同一主机系统上的进程之间进行通信。UNIX域套接字用于许多流行的系统中：HAProxy、特使、AWS的Firecracker虚拟机监视器、Kubernetes、Docker和Istio等等。</p><p>与网络套接字一样，Unix域套接字支持流和数据报套接字类型。但是，与采用IP地址和端口作为地址的网络套接字不同，Unix域套接字地址采用路径名的形式。与网络套接字不同，Unix域套接字之间的I/O不涉及底层设备上的操作(这使得Unix域套接字比在同一主机上执行IPC的网络套接字快得多)。</p><p>使用bind(2)将名称绑定到Unix域套接字将在文件系统中创建名为path name的套接字文件。但是，此文件不同于您可能创建的任何普通文件。</p><p>创建监听Unix域套接字的“回显服务器”的简单GO程序如下所示：</p><p>如果您构建并运行此程序，可以观察到一些有趣的事实。</p><p>首先，套接字文件/tmp/uds.sock被标记为套接字。将stat()应用于此路径名时，它在stat结构的st_mode字段的file-type组件中返回值S_IFSOCK。</p><p>当使用ls-l列出时，UNIX域套接字在第一列显示类型为s，而ls-F在套接字路径名后附加等号(=)。</p><p>Root@1fd53621847b：~/uds#./udds^C root@1fd53621847b：~/uds#ls-ls/tmp总计0 0 srwxr-xr-x 1根根0 8月5 01：45 uds.sock root@1fd53621847b：~/udds#stat/tmp/uds.sock File：/tmp/uds.sock File：/tmp/uds.sock size：0 Block：0 IO Block：4096 Socket Device：71H/113D inode：1835567 link：1 access：(0755/srwxr-xr-x)uid：(0/root)gid：(0/root)。)访问：2020-08-05 01：45：41.650709000+0000修改：2020-08-05 01：45：41.650709000+0000更改：2020-08-05 01：45：41.650709000+0000出生：-ROOT@5247072fc542：~/uds#ls-F/tmp uds.sock=root@5247072fc542：~/uds#。</p><p>处理文件的正常系统调用不适用于套接字文件：这意味着诸如open()、close()、read()之类的系统调用不能用于套接字文件。相反，套接字特定的系统调用(如Socket()、bind()、recv()、sendmsg()、recvmsg()等)用于处理Unix域套接字。</p><p>关于套接字文件的另一个有趣事实是，它不是在套接字关闭时删除的，而是通过调用以下命令来关闭的：</p><p>SO_REUSEPORT选项允许任何给定主机上的多个网络套接字连接到相同的地址和端口。尝试绑定到给定端口的第一个套接字需要设置SO_REUSEPORT选项，并且任何后续套接字都可以绑定到同一端口。</p><p>Linux 3.9及更高版本中引入了对SO_REUSEPORT的支持。但是，在Linux上，希望共享相同地址和端口组合的所有套接字必须属于共享相同有效UID的进程。</p><p>Int fd=socket(domain，socktype，0)；int optval=1；setsockopt(SFD，SOL_SOCKET，SO_REUSEPORT，&amp；optval，sizeof(Optval))；bind(sfd，(struct sockaddr*)&amp；addr，addrlen)；</p><p>但是，两个Unix域套接字不可能绑定到同一路径。</p><p>函数的作用是：创建两个套接字，然后将它们连接在一起。从某种意义上说，这与PIPE非常相似，不同之处在于它支持双向数据传输。</p><p>SocketPair仅适用于Unix域套接字。它返回两个已经彼此连接的文件描述符(因此，在开始传输数据之前，不必执行整个套接字→绑定→Listen→Accept舞蹈来设置侦听套接字，并执行套接字→连接舞蹈来创建侦听套接字的客户端！)。</p><p>既然我们已经确定Unix域套接字允许同一台主机上的两个进程之间进行通信，那么现在是时候探索可以通过Unix域套接字传输什么类型的数据了。</p><p>由于Unix域套接字在许多方面类似于网络套接字，因此通常通过网络套接字发送的任何数据都可以通过Unix域套接字发送。</p><p>此外，特殊的系统调用sendmsg和recvmsg允许跨Unix域套接字发送特殊消息。此消息由内核专门处理，允许将打开的文件描述从发送方传递到接收方。</p><p>请注意，我提到的是文件描述，而不是文件描述符。这两者之间的区别是微妙的，通常并不是很好地理解。</p><p>文件描述符实际上只是一个指向底层内核数据结构的每个进程的指针，该数据结构称为(令人困惑的)文件描述。内核维护一个包含所有打开文件描述的表，称为打开文件表。如果两个进程(A和B)尝试打开同一文件，则这两个进程可能有各自单独的文件描述符，这些描述符指向打开的文件表中的相同文件描述。</p><p>因此，使用sendmsg()从一个Unix域套接字向另一个Unix域套接字“发送文件描述符”实际上意味着发送对文件描述的引用。如果进程A向进程B发送文件描述符0(Fd0)，则该文件描述符很可能在进程B中由数字3(Fd3)引用。但是，它们将引用相同的文件描述。</p><p>发送进程调用sendmsg通过Unix域套接字发送描述符。接收进程调用recvmsg来接收Unix域套接字上的描述符。</p><p>即使发送进程在接收进程调用recvMsg之前关闭其引用通过sendMSG传递的文件描述的文件描述符，该文件描述对于接收进程也保持打开。发送描述或将描述的引用计数加1。如果引用计数降至0，则内核仅从其打开的文件表中删除文件描述。</p><p>可以使用sendmsg在Unix域套接字上传输的特殊“消息”由msghdr指定。希望将文件描述发送到另一个进程的进程创建包含要传递的描述的MSGHDR结构。</p><p>Struct msghdr{void*msg_name；/*可选地址*/socklen_t msg_namelen；/*地址大小*/struct iovec*msg_IOV；/*散布/聚集数组*/int msg_iovlen；/*#msg_iov中的元素*/void*msg_control；/*辅助数据见下文*/socklen_t msg_control len；/*辅助数据缓冲区*/int msg_flag；/*接收消息的标志*/}；</p><p>Msghdr结构的msg_control成员的长度为msg_control len，它指向以下形式的消息缓冲区：</p><p>Struct cmsghdr{socklen_t cmsg_len；/*数据字节数，包头*/int cmsg_level；/*发起协议*/int cmsg_type；/*协议具体类型*//*后跟*/unsign char cmsg_data[]；}；</p><p>在POSIX中，带有附加数据的struct cmsghdr结构的缓冲区称为辅助数据。在Linux上，可以通过修改/proc/sys/net/core/optmem_max来设置每个套接字允许的最大缓冲区大小。</p><p>虽然这样的数据传输有太多的问题，但如果使用得当，它可以成为实现许多目标的一种非常强大的机制。</p><p>在Linux上，有三种类型的“辅助数据”可以在两个Unix域套接字之间共享：</p><p>所有三种形式的辅助数据都只能使用下面描述的宏来访问，并且绝对不能直接访问。</p><p>Struct cmsghdr*CMSG_FIRSTHDR(struct msghdr*msgh)；struct cmsghdr*CMSG_NXTHDR(struct msghdr*msgh，struct cmsghdr*cmsg)；size_t CMSG_ALIGN(Size_T Length)；size_t CMSG_space(Size_T Length)；size_t CMSG_LEN(Size_T Length)；unsign char*CMSG_data(struct cmsghdr*cmsg)；</p><p>虽然我从来不需要使用后两者，但SCM_RIGHT是我希望在这篇文章中更多地探讨的内容。</p><p>Scm_right允许一个进程使用sendmsg从另一个进程发送或接收一组打开的文件描述符。</p><p>Cmsghdr结构的cmsg_data组件可以包含一个进程想要发送给另一个进程的文件描述符的数组。</p><p>Struct cmsghdr{socklen_t cmsg_len；/*数据字节数，包头*/int cmsg_level；/*发起协议*/int cmsg_type；/*协议具体类型*//*后跟*/unsign char cmsg_data[]；}；</p><p>“Linux编程接口”一书对如何使用sendmsg和recvmsg有一个很好的编程指南。</p><p>如前所述，当尝试通过Unix域套接字传递辅助数据时，有许多问题。</p><p>在Linux上，至少需要一个字节的“真实数据”才能通过Unix域流套接字成功发送辅助数据。</p><p>但是，在Linux上通过Unix域数据报套接字发送辅助数据时，不需要发送任何附带的实际数据。也就是说，当通过数据报套接字发送辅助数据时，便携式应用程序还应该包括至少一个字节的实际数据。</p><p>如果用于接收包含文件描述符的辅助数据的缓冲区cmsg_data太小(或不存在)，则辅助数据被截断(或丢弃)，并且在接收过程中自动关闭多余的文件描述符。</p><p>如果在辅助数据中接收的文件描述符的数量导致进程超过其RLIMIT_NOFILE资源限制，则在接收进程中会自动关闭多余的文件描述符。不能在多个recvmsg调用上拆分该列表。</p><p>Sendmsg和recvmsg的行为类似于send和recv系统调用，因为在每个send调用和每个recv调用之间不存在1：1的映射。</p><p>单个RecvMSG调用可以从多个SendMSG调用读取数据。同样，可能需要多个recvmsg调用才能使用通过单个sendmsg调用发送的数据。这具有严重而令人惊讶的影响，其中一些已经在这里报道过。</p><p>内核常量SCM_MAX_FD(253(在2.6.38之前的内核中为255))定义了数组中文件描述符的数量限制。</p><p>尝试发送大于此限制的数组会导致sendmsg失败，并显示错误EINVAL。</p><p>使用此功能的一个非常具体的实际用例是零停机代理重新加载。</p><p>任何曾经使用过HAProxy的人都可以证明，“零停机时间配置重新加载”在很长一段时间内都不是真正意义上的事情。通常，过多的Rube Goldberg风格的黑客就是用来实现这一点的。</p><p>在2017年末，HAProxy 1.8发布时支持通过将侦听套接字文件描述符从旧的HAProxy进程转移到新的进程来实现无中断重新加载。特使使用类似的机制进行热重新启动，其中文件描述符通过Unix域套接字传递。</p><p>在2018年末，Cloudflare在博客中介绍了它将文件描述符从nginx传输到Go TLS 1.3代理的情况。</p><p>这篇关于Facebook如何实现零停机释放的文章促使我撰写了整篇博客文章，它使用了selfame CMSG+SCM_RIGHT技巧，将实时文件描述符从排出进程传递到新发布的进程。</p><p>如果使用得当，可以证明通过Unix域套接字传输文件描述符非常有效。我希望这篇文章能让你对Unix域套接字及其支持的特性有一个更好的理解。</p><p>LWN.net有一篇有趣的文章，介绍了在Unix域套接字上传递文件描述时创建循环，以及对新的令人难以置信的io_uring内核API的影响。Https://lwn.net/Articles/779472/</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://copyconstruct.medium.com/file-descriptor-transfer-over-unix-domain-sockets-dcbbf5b3b6ec">https://copyconstruct.medium.com/file-descriptor-transfer-over-unix-domain-sockets-dcbbf5b3b6ec</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/描述符/">#描述符</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/进程/">#进程</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>