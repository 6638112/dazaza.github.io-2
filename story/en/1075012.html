<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何在2022年加速Rust编译器How to speed up the Rust compiler in 2022</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to speed up the Rust compiler in 2022<br/>如何在2022年加速Rust编译器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-25 23:42:05</div><div class="page_narrow text-break page_content"><p>Between 2016 and 2020 I wrote a series of blog posts called  “How to speed upthe Rustcompiler”.These were mostly about my work on the Rust compiler, plus some updates on theprogress on the Rust compiler’s speed in general.</p><p>在2016年至2020年间，我写了一系列博客文章，名为“如何加速编译器”。这些主要是关于我在Rust编译器上的工作，以及关于Rust编译器总体速度的一些更新。</p><p> I am now back on the Rust bandwagon as a member of Futurewei’s Rust team, andit’s time to start up the blog series again.</p><p>现在，我作为Futurewei的Rust团队的一员，回到了Rust潮流，是时候重新开始博客系列了。</p><p>   #90746: This PR changed a hotbut non-critical  assert! to a  debug_assert!, meaning it isn’t run inrelease builds, for wins of up to 5% on two benchmarks.</p><p>#90746：这次公关改变了一个热门但非关键的断言！到一个调试断言！，这意味着它不会在Release构建中运行，在两个基准测试中获得高达5%的胜利。</p><p> #91246:  Layout::array is afunction, involved with vector growth, that is instantiated frequently. This PRmade it more concise, reducing the amount of generated LLVM IR, and reducingcompile times by up to 4% on a few benchmarks, with sub-1% improvements on lotsof benchmarks, though the results were a bit noisy.</p><p>#91246:Layout:：array是一个函数，涉及向量增长，经常被实例化。这使得它更加简洁，减少了生成的LLVM IR的数量，在一些基准测试中，编译时间最多减少了4%，而在很多基准测试中，编译时间只提高了不到1%，尽管结果有点嘈杂。</p><p> #91844: This PR eliminated the ObligationCauseData structure, reducing allocation rates, for some sub-1%wins in lots of benchmarks.</p><p>#91844：该公共关系消除了债务导致的数据结构，降低了分配率，在许多基准测试中获得了低于1%的胜利。</p><p> hashbrown #305: rustc useshash tables heavily, and I discovered that approximately one third of allnon-modifying hash table lookups are on an empty table!  hashbrown wouldnonetheless hash the inputs and perform a normal lookup in the case. This PRchanged it to fail immediately if the table is empty, for one win of 11% andlots in the 1-4% range. This change was later merged into rustc as part of the hashbrown update in #92998.</p><p>hashbrown#305:rustc大量使用shash表，我发现大约三分之一的非修改哈希表查找都在空表上！hashbrown仍然会对输入进行散列，并在本例中执行正常的查找。如果表格是空的，这会改变它立即失败，一次赢11%，并且在1-4%的范围内抽签。这一变化后来作为#92998年hashbrown更新的一部分合并到了rustc中。</p><p> #91948: This PR, co-authoredwith  camelid, avoided lots of allocations inrustdoc caused by symbol-to-string conversions, for good wins across allrustdoc benchmarks of up to 5%.</p><p>#91948：这篇与camelid合著的PR避免了因符号到字符串转换而在RustDoc中进行的大量分配，从而在所有RustDoc基准测试中获得了高达5%的好成绩。</p><p> #92604: This PR optimizedLEB128 reading during metadata encoding (yet again) for wins of up to 3%across many benchmarks.</p><p>#92604：这个PR优化了在元数据编码期间（再次）读取B128，从而在许多基准测试中获得高达3%的胜利。</p><p> #93066: The  Decoder traitused for metadata decoding was fallible, using  Result throughout. Butdecoding failures should only happen if something highly unexpected happens(e.g. metadata is corrupted) and on failure the calling code would just abort.This PR changed  Decoder to be infallible throughout—panicking immediatelyinstead of panicking slightly later—thus avoiding lots of pointless  Resultpropagation, for wins across many benchmarks of up to 2%.</p><p>#93066:为元数据解码而跟踪的解码器容易出错，在整个过程中使用结果。但是，只有在发生了非常意外的事情（例如元数据被破坏）时，解码才会失败，一旦失败，调用代码就会中止。这个PR改变了解码器，使其在整个过程中立即恐慌，而不是稍晚恐慌，从而避免了许多毫无意义的结果传播，因为在许多基准测试中获胜率高达2%。</p><p> #93148: rustc uses interning pervasively, forstrings and many other internal types. Interned types are guaranteed unique andcan be compared and hashed cheaply (by considering just the pointer, ratherthan the contents), but some of the interned types weren’t taking advantage ofthat. This large PR overhauled the types used for interning so they were moreconsistent, for wins across many benchmarks of up to 4%.</p><p>#93148:rustc广泛使用interning、ForString和许多其他内部类型。内部类型被保证是唯一的，并且可以进行比较和廉价的散列（只考虑指针，而不是内容），但是一些内部类型没有利用这一点。这项大型公关改革了用于实习的类型，使其更加一致，赢得了高达4%的许多基准。</p><p>   I tried to speed up lexing for the   externs stresstestby changing the handling of the first char in new tokens, but it didn’t help.</p><p>我试图通过更改新令牌中第一个字符的处理来加速externs Stress Test的词法分析，但没有任何帮助。</p><p>  I tried shrinking various arena-allocated types, such as  Ty and Predicate, but it didn’t help enough to be worth the effort.</p><p>我尝试缩小各种分配给竞技场的类型，比如Ty和Predicate，但这并没有起到足够的作用。</p><p>  I drafted a dead store elimination optimization pass for MIR, inspired by thepresence of obviously redundant code relating to drop flags. It worked, butthe measurable performance benefits were negligible, and not worth the extracode.</p><p>我为MIR起草了一份死区消除优化通行证，灵感来自于与丢弃标志相关的明显冗余代码的存在。这是可行的，但可测量的性能优势微不足道，不值得额外的代码。</p><p>  I tried various ways to improve the representation of vectors use with ast::PathSeg and  AttrVec, without success.</p><p>我尝试了各种方法来改进使用ast:：PathSeg和AttrVec的向量表示，但都没有成功。</p><p>  I tried to  further optimizecode relating to vector growth to minimize LLVM IR generation, but failed to do it in a way thatdidn’t reduce the speed of the compiled code.</p><p>我试图进一步优化与向量增长相关的代码，以最小化LLVM IR生成，但未能以不降低编译代码速度的方式实现。</p><p>  I tried changing the minimum capacity of non-empty Hash tables from 3 to 7.This gave some small (1-2%) performance wins, but increased peak memory usageby more (5-10%) and so wasn’t worth it.</p><p>我尝试将非空哈希表的最小容量从3更改为7。这带来了一些小的（1-2%）性能提升，但将峰值内存使用率提高了更多（5-10%），因此不值得这么做。</p><p>  I tried  numerousthingsto improve the  FxHasher algorithm used by rustc’s hash tables, withoutsuccess.</p><p>我尝试了很多方法来改进rustc哈希表使用的FxHasher算法，但没有成功。</p><p>  I tried increasing the buffer size used by  StableHasher, which is usedwith incremental compilation, but caused a slight performance regression.</p><p>我尝试增加StableHasher使用的缓冲区大小，这与增量编译一起使用，但导致性能略有下降。</p><p>  I tried some tweaks with interning: pre-interning some common internedvalues, caching some recently interned values, and avoiding a double lookupwhen interning symbols. None of them helped.</p><p>我尝试了一些调整：预实习一些常见的InternedValue，缓存一些最近实习的值，以及避免实习符号时的双重查找。他们都没帮上忙。</p><p>  I tried speeding up  find_library_crate and failed, though some clean-ups I did along the way  weremerged.</p><p>我试着加快寻找图书馆板条箱的速度，但失败了，尽管我一路上做了一些清理工作。</p><p>    I tried a bunch of things to get jemalloc to provide accurate actual sizes ofallocated blocks, without success. (The design of various Rust and jemallocAPI boundaries made this task more difficult than I would have liked.) I alsoexperimented with jemalloc’s “sized deallocation” feature, which severalpeople assured me would be a win, but it slowed things down. The way jemallocis hooked into rustc is quite messy and at least I was able to  clarify it alittle.</p><p>我尝试了很多方法让jemalloc提供分配块的准确实际大小，但没有成功。（各种锈迹和jemallocAPI边界的设计使这项任务比我希望的更困难。）我还试用了jemalloc的“大小交易”功能，有几个人向我保证这将是一场胜利，但它减慢了速度。jemallocis和rustc的关系非常混乱，至少我能澄清一点。</p><p> You can see that I had more failures than successes. Finding performance winsis a lot harder than it used to be. Much of the low-hanging fruit has beenplucked, and my success rate is down. Running the usual profilers on the  usualbenchmarks(and only measuring the final crate of each benchmark, not the wholecompilation graph) is less effective than before.</p><p>你可以看到我的失败多于成功。找到性能赢家比过去困难得多。很多低垂的果实都被摘下来了，我的成功率也下降了。在usualbenchmarks上运行通常的分析器（并且只测量每个基准的最终板条箱，而不是整个合成图）比以前效率更低。</p><p>   Fortunately, there is a path forward.  lqd recentlystarted working full-time on compiler performance, and he did a  large datagathering exercise, running avariety of profilers across almost 800 of the most popular crates on crates.io. This included both intra-crate andcross-project measurements. The results give us insight into compilerperformance across a much larger range of real-world code than the benchmarksuite, which has 46 benchmarks, only half of which are derived from real-worldcrates.</p><p>幸运的是，有一条前进的道路。lqd最近开始全职研究编译器性能，他做了一个大型的数据收集练习，在近800个最受欢迎的板条箱上运行了各种分析器。伊奥。这包括板条箱内部和跨项目测量。与benchmarksuite相比，这些结果让我们能够深入了解编译器在更大范围的真实代码中的性能，benchmarksuite有46个基准，其中只有一半来自真实世界。</p><p>  Some parts of the compiler are hot for some crates, but these don’t show upin the existing benchmarks. Macro parsing is the most extreme example, andlooks likely to be quite optimizable.</p><p>编译器的某些部分对于某些板条箱来说是热门的，但这些在现有的基准测试中没有显示出来。宏解析是最极端的例子，看起来很可能是可以优化的。</p><p>  Certain crates are both widely used and slow to compile, such as syn/ quote/ proc-macro2. Can they be improved?</p><p>某些板条箱被广泛使用且编译速度较慢，例如syn/quote/proc-macro2。可以改进吗？</p><p>    Our benchmark suite has versions of numerous popular crates that are 3 or 4years old. We should update them, and possibly add/remove some.</p><p>我们的基准套件有许多3或4年历史的流行板条箱版本。我们应该更新它们，并可能添加/删除一些。</p><p> This analysis has informed a roadmap for compilerperformance work in 2022. I finished the draft analysis and roadmap documentsjust yesterday, but they are already bearing fruit…</p><p>该分析为2022年的编译器性能工作提供了路线图。我昨天刚刚完成了分析草案和路线图文件，但它们已经取得了成果…</p><p> #93984: This PR introduced anoptimized representation for large bitsets, which greatly reduces the peakmemory requirements for a few crates (by up to 60%!), and also avoids a lot ofmemory copying, for speed wins of up to 14%. Pleasingly, this fixed the  final outstanding performanceregression from theintroduction of the “new” borrow checker back in 2018!</p><p>#93984：该PR为大位集引入了一种优化的表示法，这大大降低了少数板条箱的峰值内存要求（最多降低60%！），而且还避免了大量的内存复制，速度最高可达14%。令人高兴的是，这修复了自2018年推出“新”借阅检查器以来的最终卓越性能退化！</p><p> #94316: This PR optimized theprocessing of string literals containing escapes, for up to 7% wins on a fewpopular crates.</p><p>#94316：该PR优化了包含转义符的字符串文本的处理，在少数流行的板条箱上最多可获得7%的胜利。</p><p>   From the period  2021-11-11 to2022-02-25there were 303 improvements to the results of the rustc benchmark suite, manyof which were over 10%, and only 21 regressions, as the following screenshotsummarizes.</p><p>从2021年11月11日到2022年02月25日，rustc基准套件的结果有303项改进，其中许多改进超过了10%，只有21项回归，如下截图总结。</p><p>  For rustc developers there was the additional nice result that rustc bootstraptimes dropped by 10%.</p><p>对于rustc开发人员来说，还有一个很好的结果，就是rustc引导时间减少了10%。</p><p> This is a healthy result for this 3.5 month period. It is due to the efforts ofmany people, and continues the long trend of performance improvements.</p><p>在这3.5个月的时间里，这是一个健康的结果。这要归功于许多人的努力，并延续了绩效改进的长期趋势。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>