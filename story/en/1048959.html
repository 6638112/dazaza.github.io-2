<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>模块，单甘油和微服务 Modules, Monoliths, and Microservices</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Modules, Monoliths, and Microservices<br/>模块，单甘油和微服务 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-24 22:01:30</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/ea1865f54c8d4d8aaf0a14292b37ffd9.png"><img src="http://img2.diglog.com/img/2021/2/ea1865f54c8d4d8aaf0a14292b37ffd9.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Lately, I get people asking me when microservices are a good idea. In  systems design explains the world, I talked about big-picture issues like second system effect, innovator’s dilemmas, and more. Can systems design answer the microservices question?</p><p>最近，有人问我什么时候微服务是个好主意。在解释世界的系统设计中，我谈到了诸如第二系统效果，创新者的困境之类的大问题。系统设计可以回答微服务问题吗？</p><p>   You can find various definitions on the Internet. Here&#39;s mine: microservices are the most extreme possible backlash against  monoliths.</p><p>   您可以在Internet上找到各种定义。这是我的：微服务是对整体的最大抵制。</p><p> Monoliths are what happen when you link everything your entire app needs into one giant program and deploy it as one big blob. Monoliths have a long history, going back to frameworks like CGI, Django, Rails, and PHP.</p><p> 当您将整个应用程序所需的所有内容链接到一个大型程序并将其部署为一个大型Blob时，就会发生独石。 Monoliths历史悠久，可以追溯到CGI，Django，Rails和PHP等框架。</p><p> Right away, let&#39;s abandon the assumption that a monolith and a fleet of microservices are the only two options. There&#39;s a wide and nuanced continuum from &#34;one giant service that does everything&#34; to &#34;infinite tiny services that each do nearly nothing.&#34;</p><p> 立即让我们放弃这样的假设，即单一的服务和一组微服务是仅有的两个选择。一项可以完成所有任务的巨型服务提供了广泛而细微的连续体到无限微小的服务，每个服务几乎什么都不做。</p><p> If you follow fads, you&#39;ll have built a monolith at least once (whether on purpose or because that&#39;s what traditional frameworks encouraged you to do), then discovered some problems with monoliths, then heard that microservices are the answer, then started rearchitecting everything as microservices.</p><p> 如果您追随潮流，那么您至少会构建一个整体（无论是有意使用还是因为传统框架鼓励您这样做），然后发现整体存在一些问题，然后听说微服务是答案，然后开始将所有内容重新配置为微服务。</p><p> But don&#39;t follow fads. There are many points in between those extremes. One of them is probably right for you. A better approach starts with where you want to put your  interfaces.</p><p> 但是不要追随时尚。在这些极端之间有很多要点。其中之一可能很适合您。更好的方法从要放置接口的位置开始。</p><p>  An interface is the connection between  modules. A module is a collection of related code. In systems design, we talk about &#34;boxes and arrows&#34; engineering: modules are the boxes, and interfaces are the arrows.</p><p>  接口是模块之间的连接。模块是相关代码的集合。在系统设计中，我们谈论的是“框和箭”。工程：模块是盒子，界面是箭头。 </p><p> The deeper question then is: how big are the boxes? How much goes in each box? How do we decide when to split one big box into two smaller ones? What&#39;s the best way to connect the boxes? There are many approaches to all this. Nobody quite knows what&#39;s best. It&#39;s one of the hardest problems in software architecture.</p><p>那么，更深层的问题是：盒子有多大？每个盒子多少钱？我们如何确定何时将一个大盒子分成两个小盒子？连接盒子的最佳方法是什么？所有这些都有很多方法。没有人知道最好的。这是软件体系结构中最困难的问题之一。</p><p> Over the decades, we&#39;ve evolved through many kinds of &#34;boxes.&#34;  Goto statements were &#34;considered harmful&#34; largely because they prevented any hierarchy at all. Then we added functions or procedures; those are very simple boxes, with interfaces (parameters and return codes) between them.</p><p> 在过去的几十年中，我们经历了许多种类的盒子。 Goto陈述被认为是有害的主要是因为它们根本阻止了任何等级制度。然后，我们添加了功能或过程；这些是非常简单的盒子，它们之间具有接口（参数和返回码）。</p><p> Depending which branch of programming you go down, you then discover recursive functions, static function prototypes, libraries (statically or runtime-linked), objects (OOP), coroutines, protected virtual memory, processes, threads, JITs, namespaces, sandboxes, chroots, jails, containers, virtual machines, supervisors, hypervisors, microkernels, and  unikernels.</p><p> 然后根据递归的编程分支发现递归函数，静态函数原型，库（静态或运行时链接），对象（OOP），协程，受保护的虚拟内存，进程，线程，JIT，名称空间，沙箱，chroot ，监狱，容器，虚拟机，主管，管理程序，微内核和unikernel。</p><p> And that&#39;s just the boxes! Once you have boxes isolated from each other, then you need to connect them with arrows. For that, we have ABIs, APIs, syscalls, sockets, RPCs, filesystems, databases, message passing systems, and &#34;virtualized hardware.&#34;</p><p> 就是盒子了！一旦盒子彼此隔离，则需要用箭头将它们连接起来。为此，我们有ABI，API，系统调用，套接字，RPC，文件系统，数据库，消息传递系统和“虚拟化硬件”。</p><p> If you tried to draw a complete boxes-and-arrows diagram of a modern Unix system (which I won&#39;t), it would be wild: functions inside threads inside processes inside containers inside userspace, layered under a kernel, inside a VM, running on hardware in a rack in a datacenter in a cloud provider tied together by an orchestration system, and so on.</p><p> 如果您试图绘制现代Unix系统的完整方框图（我赢了），那将是很疯狂的：函数位于用户空间内的容器内部，内核之下， VM，在由编排系统捆绑在一起的云提供商的数据中心机架中的硬件上运行，依此类推。</p><p> Each of those boxes at each of the abstraction layers is somehow isolated from and then connected to some of the others, at the same or other layers. Some are inside others. You couldn&#39;t draw an honest version of this picture in a mere two dimensions without lines criss-crossing hopelessly.</p><p> 每个抽象层上的这些框中的每个框都以某种方式与相同或其他层的其他框隔离，然后连接到其他框。有些在其他里面。您无法在仅二维的情况下绘制出真实的这张照片，而没有线条纵横交错的希望。</p><p> This all evolved over decades. Fancy people call it &#34;path dependence.&#34; I call it a mess. And let&#39;s be clear: most of the mess no longer provides much value.</p><p> 这一切都在数十年间演变。花哨的人称其为“路径依赖”。我称之为混乱。而且要弄清楚：大多数混乱不再提供太多价值。 </p><p> Instead of focusing on what became very ugly evolutionary results, let&#39;s talk about what people were  trying to do while they invented all that stuff.</p><p>而不是专注于患有非常丑陋的进化结果的东西，而是谈论他们在发明所有这些东西时努力做的事情。</p><p>   Upgrade, downgrade, and scale some bits without having to upgrade all the other bits simultaneously.</p><p>   升级，降级并缩放一些位，而无需同时升级所有其他位。</p><p> The computer industry spends an absolutely immense amount of time messing around, trying to find the perfect balance of all these modularity issues, while still trying to keep development as painless and easy as possible.</p><p> 计算机行业花费绝对巨大的时间乱搞，试图找到所有这些模块化问题的完美平衡，同时仍然试图使开发成为无痛和轻松。</p><p>  By far the part we&#39;re worst at is #1, isolation. If we could truly and efficiently isolate one bit of code from another, the other goals would mostly fall into place. But we simply do not know how.</p><p>  到目前为止，我们＆＃39;在最糟糕的是＃1，隔离。如果我们可以真正和有效地隔离另一个代码，另一个目标大多落在地上。但我们根本不知道如何。</p><p> Isolation is a super hard problem. Goodness knows people have tried. Yet browser sandbox escapes still happen regularly, undetected privilege escalation attacks are simply assumed to exist on every OS, iOS still gets jailbroken periodically, DRM never works (for better or worse), virtual machines and containers regularly have vulnerabilities discovered, and systems like  k8s have their containers configured insecurely by default.</p><p> 隔离是一个超硬问题。善良知道人们已经尝试过。然而，浏览器沙箱逃脱仍然是经常发生的，每个操作系统都证明未检测到的特权升级攻击，iOS仍然会定期越狱，DRM永远不会工作（无论好坏），虚拟机和容器定期发现漏洞，以及K8S这样的系统默认情况下，将其包含不安全配置的容器。</p><p> People have even been known to  figure out encryption keys on remote servers by sending well-timed packets to them over the Internet. Meanwhile, the most spectacular isolation failures in recent memory were the  Meltdown and Spectre attacks, which allowed any program on a computer, even a javascript app in a web browser, to read the memory of other programs on the same computer, even across sandboxes or virtual machines.</p><p> 甚至可以通过在Internet上向它们发送井定时数据包来弄清楚远程服务器上的加密密钥。同时，近期内存中最壮观的隔离失败是崩溃和幽灵攻击，它允许计算机上的任何程序，甚至是Web浏览器中的JavaScript应用程序，即使是沙箱或跨越沙箱虚拟机。</p><p> Every new isolation technology goes through a cycle like the following, from optimism to despair:</p><p> 每一个新的隔离技术都会通过以下循环，从乐观到绝望： </p><p> (Users complain that it&#39;s even slower and more tedious than the last thing we tried.)</p><p>（用户抱怨说，这比我们最后尝试的还要慢，而且更乏味。）</p><p>      But also we can never retire this isolation method because now too many people are depending on it.</p><p>      但是我们也永远不能淘汰这种隔离方法，因为现在有太多人依赖它。</p><p> For example, at this point security people simply don&#39;t believe that any of the following (each one the very best technology available at the time) is totally safe:</p><p> 例如，此时安全人员根本不相信以下任何一种（每一种都是当时可用的最好的技术）都是绝对安全的：</p><p> Privilege separation between OS processes when remote code execution (&#34;RCE&#34; for security people) is allowed.</p><p> 当允许远程执行代码（对于安全人员来说是RCE）时，OS进程之间的特权分离。</p><p> As far as I know, the state of the art, the very best isolation, is something like the Chrome sandbox or  gVisor. The big browser vendors and cloud providers all use tools like these. The tools remain imperfect, but providers do chase down every new breach as fast as they can, and the rate of new flaws is fairly slow.</p><p> 据我所知，最好的隔离状态是Chrome沙箱或gVisor。大型浏览器供应商和云提供商均使用此类工具。这些工具仍然不完善，但是提供商确实会尽快追捕每一个新的漏洞，而且新漏洞的发生速度也相当慢。</p><p> Isolation is better than it&#39;s ever been before… if you put all your isolation at the virtual machine (VM) level so that your cloud provider can do it for you because nobody else knows how, or updates often enough.</p><p> 隔离比以往任何时候都要好。。。如果您将所有隔离都放在虚拟机（VM）级别，以便您的云提供商可以做到这一点，因为没人能知道或经常更新。</p><p> If you trust your cloud provider&#39;s VM isolation, you can have hope that all known problems are mitigated; but we have every reason to think more problems will be found.</p><p> 如果您信任云提供商的VM隔离，则可以希望所有已知问题都得到缓解。但是我们有充分的理由认为会发现更多的问题。 </p><p> That&#39;s… actually pretty good, all things considered. At least we have  something that works.</p><p>考虑到所有因素，这实际上还不错。至少我们有一些可行的方法。</p><p>  Well, hold on. Spinning up an isolated VM for every little module is a pain. And how big is a module?</p><p>  好吧，等等。为每个小模块启动一个隔离的虚拟机是很痛苦的。模块有多大？</p><p> Long ago, when Java first came out, the dream was that every line of every function in every object could have permissions enforced, even between objects in the same application binary, so that CPU-enforced memory protection wouldn&#39;t be needed. Nobody believes anymore that they can make that work. And marketing claims like &#34;cloud functions&#34; aside, nobody really thinks you should try.</p><p> 很久以前，当Java首次面世时，梦想是每个对象中每个函数的每一行都可以强制执行权限，即使是在同一应用程序二进制文件中的对象之间也是如此，因此不需要CPU强制的内存保护。没有人再相信他们可以做到这一点。以及诸如“云功能”之类的营销主张除了，没有人真的认为您应该尝试。</p><p> None of the currently-known isolation methods work  perfectly, but each of them works to  some approximation. Increasingly skilled attackers, or increasingly valuable targets, require better and more annoying isolation. The best isolation we know right now is inter-VM sandboxing provided by tier-1 cloud providers. The worst, well, it goes down to zero.</p><p> 当前已知的隔离方法都无法完美地发挥作用，但是它们中的每一种都可以近似地工作。越来越熟练的攻击者或越来越有价值的目标，需要更好和更烦人的隔离。我们目前所知道的最佳隔离是第1层云提供商提供的VM间沙箱。最坏的是，它下降到零。</p><p> Let&#39;s also assume, skipping over the evidence, that most systems are so tightly coupled that  a reasonably skilled attacker can break through laterally between modules. So, for example, if someone can link a malicious library into your Go or C++ program, they can probably take control of that entire program.</p><p> 我们还跳过了证据，假设大多数系统是如此紧密地耦合在一起，以至于熟练的攻击者可以在模块之间横向突破。因此，例如，如果有人可以将恶意库链接到您的Go或C ++程序中，那么他们很可能可以控制整个程序。</p><p> Similarly, if your program has write access to a database, attackers can probably make it write  anywhere in the database. If it can contact the network, they can probably contact  anywhere in the network. If it can execute arbitrary Unix commands or system calls, they can probably get Unix root access. If it&#39;s in a container, they can probably break out of the container and into other containers. If malicious data can  crash the png decoder, they can probably make it do anything else the decoder program is allowed to do. And so on.</p><p> 同样，如果您的程序具有对数据库的写访问权，则攻击者可能会使其在数据库中的任何位置进行写操作。如果可以联系网络，他们可能可以联系网络中的任何地方。如果它可以执行任意的Unix命令或系统调用，则它们可能可以获得Unix根访问权限。如果在容器中，它们可能会从该容器中破裂并进入其他容器。如果恶意数据可能导致png解码器崩溃，则它们可能会使它执行解码器程序允许执行的其他任何操作。等等。</p><p> An especially powerful form of attack is getting the ability to commit code, because that code will eventually be run on developer machines, and some developer or production machine somewhere probably has access to do what you want to do.</p><p> 一种特别强大的攻击形式是提交代码的能力，因为该代码最终将在开发人员机器上运行，并且某些开发人员或生产机器可能在某处有权执行您想做的事情。 </p><p> The above is maybe a little too pessimistic, but making those assumptions can help avoid overcomplicating your systems without improving actual security. In  Some thoughts on security after ten years of qmail 1.0, Daniel J. Bernstein points out (if I may heavily paraphrase) that many of the defenses he added in qmail, particularly isolating the different components from each other using chroot and different Unix uids, were not worthwhile and have never paid off.</p><p>上面的内容可能有点过于悲观，但是做出这些假设可以帮助避免在不提高实际安全性的情况下使系统过于复杂。 Daniel J. Bernstein在qmail 1.0十年后对安全性的一些思考中指出（如果我可能要大量解释的话），他在qmail中添加了许多防御措施，特别是使用chroot和不同的Unix uid将不同的组件彼此隔离，不值得，也从未获得回报。</p><p> Anyway, let&#39;s take it for granted that attackers with the ability to execute code can &#34;usually&#34; jump laterally between coupled modules, for  almost any module isolation technique. That means there are only two kinds of module boundaries:</p><p> 无论如何，让我们认为具有执行代码能力的攻击者通常可以＆＃34;对于几乎所有的模块隔离技术，都可以在耦合模块之间横向跳转。这意味着只有两种模块边界：</p><p> Trustworthy: Boundaries where the two modules mutually trust each other not to be malicious and therefore can use  weak isolation.</p><p> 可信赖的：两个模块相互信任的边界不是恶意的，因此可以使用弱隔离。</p><p> Untrustworthy: Boundaries where modules do not trust each other, so they must use  strong isolation.</p><p> 不可信：模块之间不相互信任的边界，因此它们必须使用强隔离。</p><p> I&#39;m not saying anything terribly insightful here. Popular modern platforms are already built around this distinction.</p><p> 我在这里没有说什么非常有见地的东西。围绕这种区别的流行现代平台已经建立。</p><p> For example, Chrome runs random web javascript in strongly isolated sandbox VMs because web pages are untrustworthy.</p><p> 例如，由于网页不可信任，因此Chrome在高度隔离的沙箱VM中运行随机的Web javascript。</p><p> Most OSes run native apps as mere processes (no sandbox), with shared filesystems, network namespaces, etc, because we once thought they were relatively trustworthy. (And that&#39;s how viruses happened.)</p><p> 大多数OS都将本机应用程序作为纯粹的进程（没有沙箱），共享文件系统，网络名称空间等运行，因为我们曾经认为它们相对值得信赖。 （这就是病毒的发生方式。） </p><p> Experts don&#39;t trust multi-user unix systems anymore, because process isolation turned out to be weak. Cloud VMs default to passwordless sudo, because root vs non-root isolation turned out to be weak, so why even bother.</p><p>专家不再信任多用户的unix系统，因为事实证明进程隔离很弱。云虚拟机默认为无密码sudo，因为事实证明根与非根隔离很弱，所以为什么还要打扰。</p><p> (We still make people type sudo to help reduce the impact of human error when deleting all your files or whatever.)</p><p> （我们仍然让人们输入sudo来帮助减少删除所有文件或其他内容时人为错误的影响。）</p><p> Shared libraries and DLLs from multiple vendors get linked into apps from other vendors because all the code is assumed trustworthy. (This opens the way to supply chain attacks via open-source library vendors. I remain surprised these don&#39;t happen a lot more often. In my cynical moments, I think maybe they do, and they&#39;re just rarely detected.)</p><p> 来自多个供应商的共享库和DLL被链接到其他供应商的应用程序中，因为所有代码都被认为是可信赖的。 （这为通过开放源代码库供应商进行供应链攻击开辟了道路。令我感到惊讶的是，这种情况不会经常发生。在我愤世嫉俗的时刻，我想也许是这样，而且他们很少检测到。）</p><p> Phone OSes get jailbroken because app store restrictions are supposed to make app sandboxes trustworthy enough, but the isolation still invariably turns out to be too weak.</p><p> 手机操作系统会越狱，因为应用商店限制本应使应用沙箱足够值得信赖，但是隔离仍然总是太弱。</p><p> Kubernetes and Docker run multiple not-well-isolated containers in a single machine or VM because the containers are all, implicitly, considered trustworthy. They strongly recommend that you don&#39;t try to run a &#34;multi-tenant&#34; Kubernetes cluster (with untrustworthy apps acting on behalf of separate, not mutually trusted, users) because container isolation turns out to be weak.</p><p> Kubernetes和Docker在单个机器或VM中运行多个隔离程度不高的容器，因为这些容器隐式地被认为是值得信任的。他们强烈建议您不要尝试运行多租户。 Kubernetes集群（不可信的应用程序代表单独的用户而不是相互信任的用户运行），因为容器隔离实际上很弱。</p><p> Oh also, even if you use strong isolation like gVisor&#39;d VMs for every service, that won&#39;t help if the code itself isn&#39;t built using a strongly isolated toolchain. If one set of people can update a library that is then linked into a set of apps, then those apps are not really isolated from each other, no matter how they are run.</p><p> 哦，即使对每个服务都使用gVisor虚拟机之类的强隔离，如果代码本身不是使用强隔离的工具链构建的，那也无济于事。如果一组人可以更新一个库，然后将其链接到一组应用程序中，那么这些应用程序实际上并不是彼此隔离的，无论它们如何运行。</p><p>   History, mostly; security would be not much impacted, and simplicity would be improved, if we threw away most of these layers. I expect this will happen, over time. We&#39;re already seeing this trend. Multi-user unix systems are almost extinct; &#34;serverless&#34; servers abandon all isolation types except the strongest kind and helpfully try to lock you into your cloud provider while you&#39;re there.</p><p>   历史大部分如果我们放弃了大多数这些层，那么安全性不会受到太大影响，并且简单性将得到改善。我希望随着时间的推移会发生这种情况。我们已经看到了这一趋势。多用户的Unix系统几乎已经不存在了。 ＆＃34;无服务器＆＃34;服务器会丢弃除最强类型之外的所有隔离类型，并在您在那里时尝试将您锁定在云提供商中。 </p><p> But let&#39;s leave history aside. I had to introduce all those isolation concepts so I can say something simpler:  you almost never define module boundaries for security reasons.</p><p>但是让＆＃39;留下历史。我不得不介绍所有这些孤立概念，所以我可以说些简单的东西：出于安全原因，你几乎从不定义模块边界。</p><p> Instead, module boundaries typically follow  Conway&#39;s law. People break up modules based on how they want to subdivide the development work on their team, and modules end up communicating based on how the teams and teammates communicate. (Conway&#39;s law is fascinating and real, but you can read about it in many other places. Let&#39;s skip it for now.)</p><p> 相反，模块边界通常遵循Conway＆＃39;法律。人们根据他们想要在其团队中细分开发工作的方式分手模块，并根据团队和队友的沟通方式最终结束沟通。 （Conway＆＃39;法律是迷人和真实的，但你可以在许多其他地方阅读它。让＆＃39;现在跳过它。）</p><p>   ChromeOS has thousands of developers, but users receive a single update containing a fully-tested combination of Linux kernel, device drivers, window manager, web browser, etc. The interfaces between these modules could change in any version because they don&#39;t need backward compatibility (except of course with hardware, and the web). macOS, iOS, and Android follow a similar model.</p><p>   Chromeos有数千名开发人员，但用户收到了一个包含一个完全测试的Linux内核组合的单个更新，窗口管理器，Web浏览器等。这些模块之间的接口可能会在任何版本中更改，因为它们不会＆＃39; t需要向后兼容性（除了包含硬件和Web的课程之外）。 MacOS，iOS和Android遵循类似的型号。</p><p> Debian Linux has thousands of developers, but users download and install individual packages. You can run one package from ancient Debian-oldstable alongside a new package from today&#39;s Debian-unstable, and most likely it&#39;ll work. Probably nobody has ever tested your particular combination, but probably it works, because of very strongly defined interfaces between packages.</p><p> Debian Linux有数千名开发人员，但用户下载并安装单个包。您可以从今天的新包装中从古代Debian-Oldstable运行一个包，并从今天＆＃39; s debian-unstable，最有可能的＆＃39; ll工作。可能没有人曾经测试过您的特定组合，但可能是它的工作原因，因为包之间的界面非常明确。</p><p> (People make jokes about the unreliability of &#34;Linux on the desktop.&#34; They&#39;re always talking about the second, niche, hard-to-test kind, not the first, mainstream, easier-to-test kind. I don&#39;t think the perceived quality difference is actually caused by corporate money vs open source. The difference is the deployment model.)</p><p> （人们对桌面上的Linux的不可靠性笑话。＆＃34;他们始终谈论第二个，利基，难以测试的类型，而不是第一个，主流，更容易 - 最佳。我不认为感知的质量差异实际上是由公司金钱与开源的。差异是部署模型。）</p><p> Both systems contain numerous packages (modules) developed by numerous developers organized into teams. Both of them have interfaces between modules. If you drew a boxes-and-arrows diagram of each system, it would probably look pretty similar: kernels, drivers, windowing systems, sandboxes, web browsers, etc.</p><p> 这两个系统都包含众多由众多开发商组织成团队的软件包（模块）。它们都有模块之间的界面。如果您画了每个系统的盒子和箭头图，它可能看起来很相似：核，驱动程序，窗口系统，沙箱，Web浏览器等。</p><p> And yet, if these were backend cloud  services instead of OSes, we would call these two models  monoliths and  microservices, respectively, because of their deployment models. One has only one deployed &#34;service,&#34; while the other has lots of them, each deployed separately. For the same module architecture! What&#39;s going on?</p><p> 然而，如果这些是后端云服务而不是iSS，我们将分别称为这两个模型和微服务，因为他们的部署模型。一个只有一个部署的＆＃34;服务，＆＃34;虽然另一个有很多，但每个都分别部署。对于相同的模块架构！什么＆＃39;正在继续？ </p><p>    Isolation: If you really need strong isolation for security purposes, you need separate services for now, because the only way to roll out isolated VMs is separately.(Note though: this is more of a limitation of our isolation systems, not an architectural goal. &#34;Infrastructure as code&#34; and  blue/green deployments try to get these services back in sync again, so you can have a monolithic deployment model.)</p><p>隔离：如果出于安全性目的确实需要强隔离，则现在需要单独的服务，因为推出隔离的VM的唯一方法是单独进行（尽管请注意：这更多是对我们的隔离系统的限制，而不是架构目标。作为代码的基础架构和蓝色/绿色部署尝试使这些服务再次恢复同步，因此您可以使用整体式部署模型。）</p><p> Connection: follows Conway&#39;s law. Module boundaries tend to follow your team&#39;s personal communication patterns. But counterintuitively, Conway&#39;s law needn&#39;t define service boundaries.</p><p> 联系：遵循康威定律。模块边界倾向于遵循您团队的个人沟通模式。但是违反直觉的是，康韦定律不需要定义服务边界。</p><p> Compatibility guarantees: pressure you toward monoliths. This is especially true if your monolith is written in a type safe language like Go, typescript, rust, or even C++. (eg. Chrome is one giant binary.)</p><p> 兼容性保证：向整体施加压力。如果您的整体语言是使用Go，Typescript，rust甚至C ++之类的类型安全语言编写的，则尤其如此。 （例如，Chrome是一个巨大的二进制文件。）</p><p> Upgrades, downgrades, and scalability: These are mainly what determines your service boundaries. Let&#39;s talk about them a bit more.</p><p> 升级，降级和可伸缩性：这些主要决定了您的服务边界。让我们再谈谈他们。</p><p>  Does your monolith take a long time to startup? That makes upgrades a pain, so you might want to split out the slow part to make upgrading other things go faster.</p><p>  您的整体需要长时间启动吗？这使升级变得很痛苦，因此您可能希望将较慢的部分分开，以使其他升级过程变得更快。</p><p> Do you need the right datastore schema version? That sometimes requires lockstep upgrades/downgrades of all instances of a backend so they&#39;re on the same schema version. Lockstep upgrades are risky and tend to prevent rollbacks; you sometimes want to keep the schema-dependent part as small as possible.</p><p> 您是否需要正确的数据存储架构版本？有时，需要对后端的所有实例进行锁步升级/降级，以使它们位于同一架构版本上。锁步升级存在风险，并且倾向于防止回滚。您有时希望将与架构相关的部分保持尽可能小。</p><p> Are continuous integration tests frequently failing? If so, then I have bad news. Those failing tests are saying your code is broken. That&#39;s a feature! Splitting services and rolling them out separately will probably fool your tests into passing, but then you&#39;ll have compatibility and version skew problems in production instead. That&#39;s no help.</p><p> 连续集成测试是否经常失败？如果是这样，那我有个坏消息。那些失败的测试表明您的代码已损坏。这是一个功能！分离服务并分别推出它们可能会使测试无法通过，但是随后您将在生产中遇到兼容性和版本偏斜问题。那没有帮助。 </p><p> Do some parts scale differently from other parts? For example, some operations are memory-heavy while others are CPU-heavy. This is not important as often as you&#39;d think. If all your instances are load balanced properly, then the load tends to naturally spread around in a pretty efficient way. If load balancing becomes a problem, you can measure it and fix the specific granularity problem later.</p><p>与其他部分不同的部分尺度缩放？例如，某些操作是内存重的，而其他操作则是CPU-Shive。这并不像你一样重要。如果您的所有实例正确平衡，那么负载往往以非常有效的方式自然地传播。如果负载平衡成为问题，则可以稍后测量并修复特定的粒度问题。</p><p> Do expensive requests need to be run with less parallelism? A common microservice architecture is to dump requests into a message queue and have worker instances process requests sequentially. But this goes wrong more often than you&#39;d think, and  there are better designs that avoid &#34;queue explosion&#34; problems. You can implement those same designs in a monolith.</p><p> 昂贵的请求是否需要使用较少的并行性运行？常见的微服务架构是将请求转储到消息队列中，并顺序地具有工人实例请求。但是，这比思考更频繁地出错了，想想，有更好的设计避免＆＃34;队列爆炸＆＃34;问题。您可以在整料中实施相同的设计。</p><p> Do you have services with different quality/reliability targets? This can be a good reason to split services. For example, at Tailscale we have only a couple of services with very strict uptime goals: the  coordination service and the  log catcher service. Those two are already split for security isolation since logs are so sensitive. On top of that, our &#34;real-time&#34; log/metrics processing pipeline can tolerate more downtime and therefore more experimentation, so it&#39;s split from the high-reliability services and can have different deployment procedures.</p><p> 您是否拥有不同的质量/可靠性目标服务？这可能是分裂服务的充分理由。例如，在TailScale下，我们只有几个具有非常严格的正常运行时间目标的服务：协调服务和日志捕集服务。这两个已经拆分为安全隔离，因为日志非常敏感。在那之上，我们的＆＃34;实时＆＃34;日志/指标处理管道可以容忍更多的停机时间，因此更具实验，所以它与高可靠性服务分开，可以具有不同的部署过程。</p><p> In truth, most of the above are usually pretty uncompelling reasons to create boundaries between services. They can be great reasons to create boundaries between modules or teams! But you can roll out the modules after recombining them into one or a few monoliths.</p><p> 事实上，上述大部分的大多数都是相当具有在服务之间创造界限的不铭文的理由。它们可能是在模块或团队之间创造界限的绝佳原因！但是，在将它们重新结合成一个或多种整体之后，您可以推出模块。</p><p> Remember, ChromeOS is a monolith. iOS is a monolith. Your team is probably much smaller than either of those teams. You simply don&#39;t need to juggle a lot of microservices to get what you want. Architect things the easy way until you&#39;re absolutely forced to do them the hard way. That&#39;s what we do.</p><p> 请记住，Chromeos是一片巨石。 ios是一块巨石。您的团队可能比这些团队中的任何一个小得多。你只是不需要拼凑了很多微服务来获得你想要的东西。建筑物的东西简单的方式，直到你＆＃39;绝对被迫这样做艰难的方式。那个＆＃39;我们做了什么。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://tailscale.com/blog/modules-monoliths-and-microservices/">https://tailscale.com/blog/modules-monoliths-and-microservices/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/甘油/">#甘油</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/monoliths/">#monoliths</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/隔离/">#隔离</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>