<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>BMC：使用内核缓存和堆栈预处理加速Memcached </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">BMC：使用内核缓存和堆栈预处理加速Memcached </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-13 17:53:25</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/fcffb318e6bdeeea502682e1ef37a7a4.png"><img src="http://img2.diglog.com/img/2021/5/fcffb318e6bdeeea502682e1ef37a7a4.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>明天，yoann ghigoff等。将介绍他们的论文BMC：在NSDI 2021，使用安全的内核缓存和堆栈预堆叠处理加速Memcached。在本文中，提议通过在XDP钩子处实现透明，第一级缓存来加速Memcached使用EBPF。它不是每天看到在应用协议上使用的BPF！</p><p> 此博客文章是本文的摘要及其主要结果。披露，我曾经与一些作者合作。</p><p>   memcached是一个受欢迎的key-value存储，最常用作其他应用程序的缓存.bmc充当memcached前​​面的第一级缓存：</p><p> 我们呈现BMC，用于MEMCACHED的内核缓存，用于在执行标准网络堆栈之前服务请求。尽管EBPF的安全约束，我们表明可以实现复杂的缓存服务。</p><p> BMC依赖于EBPF和拦截XDP和TC挂钩的数据包，同时进入和出口。我们将看到，实现的挑战之一是解决EBPF验证者的复杂性约束。</p><p> 由于BMC在商品硬件上运行并需要修改Linux内核和Memcached应​​用程序，因此可以广泛地部署在现有系统上。</p><p> 这通常是基于BPF的应用程序。这里特别是，因为BMC是透明的缓存，它不需要更改MEMCACHED。 </p><p>BMC专注于加速UDP的小型Get请求的处理，以实现高吞吐量，因为从Facebook的以前的工作表明，这些请求构成了重要的部分Memcached流量。</p><p> 我喜欢作者在纸质早期说明目标流量.They目标小UDP请求，但由于BMC充当一级缓存，因此它们总是可以向Memcached退回以获取不受支持的请求。</p><p> 这提供了使用低延迟的请求的能力，并且当BMC无法处理请求时返回MEMCACHED应用程序。</p><p> 当然，如果您的Memcached应​​用程序仅在TCP上侦听，BMC将不会有很多使用。</p><p>   作者首先查看Memcached及其CPU瓶颈的UDP性能。在用户空间中，MEMCACHED包括良好优化的数据结构来处理键值对，具有LRU算法，以驱动“陈旧”数据。</p><p> MEMCACHED的数据管理已得到很好的优化，并依赖于SLAB分配，LRU算法和哈希表来分配，删除和检索存储在内存中的项目。</p><p> 然而，内核占MEMCACHED的大部分CPU消耗，主要是通过网络发送和接收数据。作者评估了超过一半的CPU时间在内核中，随着线程数量的增加而增加，随着线程的数量增加。 </p><p>上面列出的内核函数说明了锁定争用浪费了很多CPU循环，因为使用了单个UDP套接字。在比较BMC对此慢动作中的比较时，作者修补程序归功于SO_REUSEPORT.支持多个套接字来支持多个套接字。支持多个套接字有所帮助跨越核心，使用8个核心时的性能改进。补丁MEMCACHED与BMC进行了更现实的比较，从毕竟Facebook使用类似的优化（但没有SO_REUSEPORT）。</p><p> Vanilla Memcached尚未包含这种优化有点令人惊讶。这是我写这一点的时间，作者尚未试图提交修补程序上游（尚未）。</p><p>   由于本文的大部分讨论了作者如何围绕验证者的复杂性约束，他们在潜入设计之前提供了一点关于BPF的BPF字节码验证。</p><p> 分析所有条件分支以探索程序的所有可能执行路径。如果验证者达到BPF Exit指令，则特定路径有效，并且验证者的状态包含有效返回值，或者验证者达到等同于一个的状态已知有效。然后验证者返回到未开发的分支状态，并继续此过程，直到检查所有路径。</p><p> 这个简洁的解释包含很多信息，因此让我们解开它。BPF验证者必须确保通过程序的所有路径有效，因此在下面的示例中，意味着Abcef和Abdef应该有效。它漫命，验证者infers所有堆栈插槽和寄存器的界限和类型（上述验证器状态）。该信息用于验证指令的正确性（例如，内存负载是有界的，直到达到出口指令，直到达到出口指令Point Path被视为有效。该点，验证者背包到未开发的分支并继续，所以在我们的示例中，它可以分析Abcef然后返回到D分析第二条路径的DEF。</p><p>  分析的指令数量随着分支的数量呈指数增加，因此验证者具有一个额外的尺寸，状态灌注。具体指令1，它将当前状态与先前验证的状态进行比较。如果当前状态相当于前一级的状态。验证状态，然后没有必要走路的其余部分。在我们的示例中，在第二次分析E时，如果验证者的状态相当于它第一次走路时的状态，它将跳过F的分析。</p><p> 最后，验证者保持指令预算：在放弃之前将分析的指令有多少指令。最近的内核（v5.2 +），此预算为100万条指令，构成主要复杂性约束。我将参考该数量指令需要完全验证程序作为该计划的复杂性。 </p><p>要充当透明的缓存，BMC必须构建其自己的Memcached数据子集的副本。到该结束，BMC拦截所有集合和获取请求，如下所示。它通过拦截响应来了解新的（key，值）条目获取来自Memcached（更新案例）的请求。对于已经请求的键，BMC可以在不涉及MEMCACHECACE（查找案例）的情况下回复。</p><p>  最后，在拦截SET请求时，BMC只是使其对应的（key，value）条目（无效情况）.since一个设置请求更新键的值，BMC需要确保它不会在下一个错误的键回答错误键获取请求。</p><p> 您可能想知道为什么BMC在拦截SET请求时不简单地更新其本地缓存。作者提供了两个原因：</p><p> 我们选择不使用BMC拦截的SET请求更新内核缓存，因为TCP的拥塞控制可能在执行后拒绝新段.OWore，使用SET请求更新内核高速缓存要求BMC和MEMCACHED进程中的请求保持BMC缓存一致的顺序相同，这很难保证过度昂贵的同步机制。</p><p> 由于变量大小的键和值，作者无法重用BPF的哈希表，因此他们必须自行构建。</p><p> 它是一个直接映射的缓存，这意味着散列表中的每个桶只能在时间存储一个条目.bmc使用32位fnv-1a [21]哈希函数来计算散列值。</p><p> 他们的哈希表非常简单，并且没有提供任何碰撞解决，可能是因为在BPF中这样做就在指令方面是昂贵的。在哈希碰撞的情况下，可以始终通过MEMCACHED在USEMACE中处理请求。 </p><p>BMC缓存由所有内核共享，并且不需要全局锁定方案，因为它的数据结构是不可变的。然而，使用旋转锁来保护每个缓存条目。</p><p>   BPF实施和随后的评估构成了这项工作的关键。要计算哈希和复制键和值，BMC循环2通过数据，byte逐个字节。这当然是非常昂贵的指示和天真的实现迅速吃整个验证者指令预算。</p><p> BMC使用循环从网络数据包复制键和值到其缓存，反之亦然。</p><p> 为避免在每个请求上花费太多指示，作者首先限制请求BMC将处理：</p><p> 为了确保单个EBPF程序的复杂性不超过验证者可以分析的最大指令数，我们经验将最大键长度BMC可以处理到250字节，最大值长度为1000字节。根据Facebook的工作负载分析[13]，约95％的观察值小于1000字节。</p><p> 少数请求BMC无法处理的Memcached在Userspace中提供服务，因此这里唯一的缺点是缓存效率的小损失。</p><p> 这些限制不足以使BPF计划保持在100万条指令限制下。因此，作者需要将其分成较小的程序，由尾部呼叫加入，如下图所示。 </p><p>因此，对MEMCACHED请求的处理分为7个BPF程序，每个程序都有自己的任务，包括计算键散列，准备回复数据包或将数据写入本地缓存或回复数据包。</p><p> 说到回复数据包，您可能会想知道BMC如何创建它，因为BPF没有帮助程序来创建和发送数据包。事实证明，它们只是在BPF开发人员之间变得常见的方式回收所接收的数据包：</p><p> 此EBPF程序增加了接收数据包的大小，并修改其协议标题以准备响应数据包，交换源和目标以太网地址，IP地址和UDP端口。</p><p>   作者通过测量其BPF程序的尺寸和复杂性来开始评估，我绘制下面（不要错过的是复杂性的第二y轴）。他们使用LLVM 9.0与V1指令集和Linux V5.3。</p><p>  首先，我们可以首先注意到通过数据包的Playload循环的程序（Update_cache，hash_keys，Invalidate_cache和write_reply）具有更高的复杂性。在指令数量和复杂性之间也没有明显的关系。这可能似乎是违反直观的，但到期为了使用循环：如果验证者需要行走循环的所有迭代，那么具有很少的指令的程序可能具有很高的复杂性。即使hash_keys具有比prepaster_packet更少的指令（142与178），所以它使用循环以迭代键的每个字节，它具有更高的复杂性（788K对181）。</p><p> X86和EBPF指令之间的相关性更清晰。JIDED程序通常需要多于其字节码对应物的指示，部分原因是X86 PROLOGUE＆AMP;结尾和一些助手的内联4。</p><p> 然后，作者潜入吞吐量评估。他们将BMC与其修补的Memcached，命名的MemcachedSR和未被捕获的Memcached进行比较。 </p><p>它们将2.5 GB内存分配到BMC和10 GB以MEMCACHED在用户空间中，这使得与生产服务器相比相当小的MEMCACHED 5.THEIR评估工作负载由100万个键值对组成，其中ZIPF分布后请求密钥具有偏斜0.99.这一高度偏斜的分布非常赞成任何缓存机制，如BMC.PRODUCTING工作量也高度倾斜（CF.Book的纸张，图5），但如果两个是可比的，则目前尚不清楚。歪斜似乎可能对BMC的表现产生强烈影响。</p><p>  作者首先衡量吞吐量，因为核心的数量增长。此评价表明：</p><p>  当然，性能也取决于给予BMC可以在给出其限制的情况下处理多少。因此，作者将性能评估为支持的请求的数量（具有小于1KB的值）的增加。</p><p>  我们可以看到，即使具有少量支持的请求（25％），BMC已经重链MEMCACHED的性能。</p><p> 本文有很多评估，我不会在此处重现，包括：</p><p> 表示BMC的评估即使使用总存储器的0.1％，也可以提高性能。这主要是由于偏斜的关键分布，但令人印象深刻！</p><p>  与Memcached，Seastar的基于DPDK的实现的比较，使用较少的CPU资源在较少的同时表现出BMC优势。 </p><p>这些强度吞吐量结果的原因是使用XDP，这允许BMC回答Linux网络堆栈中非常早期的请求。然而，堆栈中的这一点在此时的TCP请求将困难，这就是BMC的原因目前仅限于UDP请求。这也限制了BMC对Redis等其他键值存储的相关性。</p><p> 因为redis请求仅在TCP上传输，所以将BMC调整为Redis需要支持TCP协议。这可以通过从EBPF程序发送确认或通过拦截通过TCP堆栈来重用现有的TCP内核实现来完成。</p><p> 正如作者所指出的那样，它们可以拦截Linux堆栈中的TCP请求更高，但性能效益将更小。</p><p>  虽然静态内存分配验证了BMC的EBPF程序，但它也浪费了内存.BMC遭受内部碎片，因为每个缓存条目都是由它可以存储和插入小于此绑定的数据的最大数据大小。</p><p>    很难说这项工作如何是制作MEMCACHED服务器。赛道6似乎表示MEMCACHED可能更常见于TCP，除了可能在Facebook上也不清楚CPU  - 而不是内存 - 是大多数MEMCACHED服务器上的瓶颈。</p><p> 在任何情况下，都可以令人兴奋地看到应用程序协议。作者设法为应用程序协议创建了高性能缓存，尽管BPF验证者的约束，但虽然我会喜欢查看其他关键分布的吞吐量评估，本文的评估相当广泛。他们强调了BMC与Memcachedsr的各种权衡。去看看！</p><p> BMC和MEMCACHEDSR的源代码在GitHub上，具有在家中重现的步骤。 </p><p>如何确定修剪点取决于内核版本，但它们可能包括辅助呼叫或分支目标。 ↩  SEASTAR通过TCP进行了更好的表现，MEMCACHED具有通过UDP套接字的锁定争用。 这可能是因为用户对TCP性能更感兴趣吗？ ↩ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://pchaigno.github.io/ebpf/2021/04/12/bmc-accelerating-memcached-using-bpf-and-xdp.html">https://pchaigno.github.io/ebpf/2021/04/12/bmc-accelerating-memcached-using-bpf-and-xdp.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/缓存/">#缓存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/bmc/">#bmc</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1061530.html"><img src="http://img2.diglog.com/img/2021/5/thumb_ee775fb835227d1dc3ff4700017a2420.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1061530.html">丢弃缓存没有下降缓存 </a></div><span class="my_story_list_date">2021-5-10 7:41</span></div><div class="col-sm"><div><a target="_blank" href="/story/1060709.html"><img src="http://img2.diglog.com/img/2021/5/thumb_8584c8aa171895dd7f5fc4a55efe6467.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1060709.html">新的幽灵攻击再次发送英特尔和AMD争抢进行修复 </a></div><span class="my_story_list_date">2021-5-5 21:45</span></div><div class="col-sm"><div><a target="_blank" href="/story/1051485.html"><img src="http://img2.diglog.com/img/2021/3/thumb_f01bda1c07881949f16346d570f531a8.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1051485.html">留出了ttl地狱 </a></div><span class="my_story_list_date">2021-3-11 1:4</span></div><div class="col-sm"><div><a target="_blank" href="/story/1048521.html"><img src="http://img2.diglog.com/img/2021/2/thumb_be27bba143ef5239d8ec2e183975d351.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1048521.html">即使刷新缓存或隐身，新的浏览器跟踪黑客也可以使用 </a></div><span class="my_story_list_date">2021-2-19 21:16</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>