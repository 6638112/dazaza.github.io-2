<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Swift：异步/等待 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Swift：异步/等待 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-05 18:05:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/9288d7ad6e1e89befcae18c6478b039f.png"><img src="http://img2.diglog.com/img/2020/12/9288d7ad6e1e89befcae18c6478b039f.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>现代Swift开发涉及大量使用闭包和完成处理程序的异步（或async＆＃34;）编程，但是这些API很难使用。当使用许多异步操作，需要错误处理或异步调用之间的控制流程变得复杂时，这尤其成问题。该建议描述了一种语言扩展，以使其更加自然和更少出错。</p><p> 该设计向Swift引入了协程模型。函数可以选择异步，从而允许程序员使用常规的控制流机制来编写涉及异步操作的复杂逻辑。编译器负责将异步函数转换为适当的闭包和状态机集。</p><p> 该提议定义了异步函数的语义。但是，它不提供并发性：引入结构化并发性的单独建议涵盖了并发性，该建议将异步功能与并发执行的任务相关联，并提供用于创建，查询和取消任务的API。</p><p>   使用显式回调（也称为完成处理程序）的异步编程存在许多问题，我们将在下面进行探讨。我们建议通过将异步函数引入该语言来解决这些问题。异步功能允许将异步代码编写为直线代码。它们还允许实现直接推理代码的执行模式，从而使回调运行得更加有效。</p><p>  简单异步操作序列通常需要深度嵌套的闭包。这是一个显示此内容的虚构示例：</p><p> func processImageData1（completeBlock：（_ result：Image）-> Void）{loadWebResource（＆＃34; dataprofile.txt＆＃34;）{loadWebResource（＆＃34; imagedata.dat＆＃34;）中的dataResource {imageResource在解码图像（dataResource，imageResource）中{在dewarpAndCleanupImage（imageTmp）中的imageTmp {在completionBlock（imageResult）中的imageResult}}}}}}} processImageData1 {display（image）中的图像}</p><p> 这个“厄运金字塔”使得难以阅读和跟踪代码的运行位置。另外，必须使用一堆闭包会导致许多二阶效果，我们将在后面讨论。 </p><p>回调使错误处理变得困难且非常冗长。 Swift 2引入了用于同步代码的错误处理模型，但是基于回调的接口并未从中获得任何好处：</p><p> //（2a）对每个回调使用`guard`语句：func processImageData2a（completeBlock：（_ result：Image？，_ error：Error？）-＆gt;无效）{loadWebResource（＆＃34; dataprofile.txt＆＃ 34;）{dataResource，后卫的错误让dataResource = dataResource else {completeBlock（nil，错误）返回} loadWebResource（＆＃34; imagedata.dat＆＃34;）{imageResource，后卫的错误let imageResource = imageResource else {completeBlock （nil，错误）返回} encodeImage（dataResource，imageResource）{imageTmp，后卫发生错误，使imageTmp = imageTmp else {completeBlock（nil，错误）返回} defwarpAndCleanupImage（imageTmp）{imageResult，后卫发生错误，使imageResult = imageResult else { （nil，错误）返回} completeBlock（imageResult）}}}}} processImageData2a {图片，后卫错误让image =图片else {display（今天没有图片＆＃34 ;，错误）返回} display（image ）}</p><p> 将结果添加到标准库中，改进了Swift API的错误处理。异步API是导致Result的主要动力之一：</p><p> //（2b）对每个回调使用`do-catch`语句：func processImageData2b（completeBlock：（Result＆lt; Image，Error＆gt;）-＆gt;无效）{loadWebResource（＆＃34; dataprofile.txt＆＃34;） {做中的dataResourceResult {让dataResource =尝试dataResourceResult。 get（）loadWebResource（＆＃34; imagedata.dat＆＃34;）{do中的imageResourceResult {让imageResource =尝试imageResourceResult。 get（）encodeimage（dataResource，imageResource）{在do中的imageTmpResult {让imageTmp =尝试imageTmpResult。 get（）dewarpAndCleanupImage（imageTmp）{imageResult in progressBlock（imageResult）}} catch {completeBlock（。failure（error））}}} catch {completeBlock（。failure（error））}}} catch { ））}}} processImageData2b {产生结果{产生图像=尝试结果。 get（）display（image）} catch {display（＆＃34;今天没有图像＆＃34 ;，错误）}}</p><p> //（2c）对每个回调使用`switch`语句：func processImageData2c（completeBlock：（Result＆lt; Image，Error＆gt;）-＆gt;无效）{loadWebResource（＆＃34; dataprofile.txt＆＃34;）{dataResourceResult在switch dataResourceResult {case。 success（let dataResource）：loadWebResource（＆＃34; imagedata.dat＆＃34;）{开关imageResourceResult中的imageResourceResult {case。 success（let imageResource）：decodeImage（dataResource，imageResource）{imageTmpResult在切换imageTmpResult {case。 success（let imageTmp）：dewarpAndCleanupImage（imageTmp）{imageResult in completeBlock（imageResult）} case。失败（让错误）：completionBlock（。失败（错误））}} case。失败（让错误）：completionBlock（。失败（错误））}} case。 failure（let error）：completeBlock（。failure（error））}}} processImageData2c {导致切换结果{case。 success（let image）：display（image）case。 failure（let error）：显示（＆＃34;今天没有图像＆＃34 ;，错误）}}</p><p>   有条件地执行异步函数是一个巨大的痛苦。例如，假设我们需要＆＃34; swizzle＆＃34;获得图像后。但是，有时我们必须进行异步调用才能解码图像，然后才能产生混乱。构造此函数的最佳方法也许是在辅助程序中编写复杂的代码。在完成处理程序中有条件捕获的闭包，如下所示：</p><p> func processImageData3（收件人：Person，completionBlock：（_结果：Image）-＆gt;无效）{让swizzle：（（_ content：Image）-＆gt;无效= {// ...连续闭合，最终会调用completionBlock}，如果是接收者。 hasProfilePicture {swizzle（recipient。profilePicture）}否则{解码图像{swizzle（image）中的图像}}} </p><p>这种模式会颠倒函数的自然自上而下的组织方式：将在函数后半部分执行的代码必须出现在上半部分执行的部分之前。除了重组整个函数之外，我们现在还必须仔细考虑延续闭包中的捕获，因为闭包用于完成处理程序中。随着条件执行的异步函数数量的增加，问题变得更加严重，从而产生了本质上是倒置的“厄运金字塔”。</p><p>  通过简单地返回而不调用正确的完成处理程序块，可以很容易地提早解决异步操作。当被遗忘时，这个问题很难调试：</p><p> func processImageData4a（completionBlock：（_结果：图片？，_错误：错误？）-＆gt;无效）{loadWebResource（＆＃34; dataprofile.txt＆＃34;）{dataResource，警惕中的错误让dataResource = dataResource else {返回//＆lt;--忘记调用该块} loadWebResource（＆＃34; imagedata.dat＆＃34;）{imageResource，防护错误让imageResource = imageResource否则{返回//＆lt;--忘记调用该块} ...}}}</p><p> 当您确实记得调用该块时，您仍然可以忘记之后返回：</p><p> func processImageData4b（收件人：人，completionBlock：（_结果：图像？，_错误：错误？）-＆gt;无效）{如果是收件人。 hasProfilePicture {如果让图片=收件人。 profilePicture {completeBlock（image）//＆lt;-调用块后忘记返回}} ...}</p><p> 值得庆幸的是，防护语法可以防止忘记返回某种程度，但这并不总是相关的。</p><p>  这很难量化，但是作者认为，定义和使用异步API（使用完成处理程序）的尴尬已导致许多具有明显同步行为的API被定义，即使它们可以阻塞也是如此。这可能会导致UI应用程序中的性能和响应性问题，例如旋转的光标。当异步对于实现规模扩展至关重要时，也可能导致无法使用的API的定义。在服务器上。 </p><p>Warning: Can only detect less than 5000 characters</p><p>挂起点是异步函数执行中必须放弃其线程的点。悬挂点始终与函数中的确定性，句法明确的事件相关；从函数的角度来看，它们永远不会被隐藏或异步。挂起点的主要形式是对与不同执行上下文关联的异步函数的调用。</p><p> 重要的是，暂停点仅与显式操作相关联。实际上，此提议要求将可能暂停的调用包含在await表达式中，这一点非常重要。这是Swift的先例，该先例要求try表达式包含对可能引发错误的函数的调用。标记悬浮点特别重要，因为悬浮会中断原子性。例如，如果异步功能在受串行队列保护的给定上下文中运行，则到达挂起点意味着可以在同一串行队列上交错其他代码。关于原子性的一个经典但有点老套的例子是对银行进行建模：如果将存款记入一个帐户，但操作在处理匹配的提款之前挂起，则会创建一个窗口，可以对这些资金进行两次花费。对于许多Swift程序员来说，更紧密的示例是UI线程：暂停点​​是可以向用户显示UI的点，因此，构建其部分UI并随后暂停的程序可能会出现闪烁的，部分构造的UI。 （请注意，还使用显式回调在代码中显式调用了挂起点：挂起发生在外部函数返回的点与回调开始运行之间。）要求所有潜在的挂起点都已标记，以便程序员可以安全地假定没有潜在的悬浮点将具有原子性，并且更容易识别出有问题的非原子模式。</p><p> 由于挂起点只能出现在异步函数中显式标记的点上，因此长时间的计算仍会阻塞线程。当调用仅执行大量工作的同步函数时，或者遇到直接用异步函数编写的特别密集的计算循环时，可能会发生这种情况。无论哪种情况，线程都无法在这些计算运行时交错代码，这通常是正确性的正确选择，但也可能成为可伸缩性问题。需要进行大量计算的异步程序通常应在单独的上下文中运行它。如果不可行，则可以使用图书馆设施来人为地暂停并允许其他操作进行交错。</p><p> 异步函数应避免调用实际上可能阻塞线程的函数，尤其是当它们可以阻塞线程以等待无法保证当前正在运行的工作时。例如，获取互斥锁只能阻塞，直到某个当前正在运行的线程放弃该互斥锁为止。这有时是可以接受的，但必须小心使用，以免引起死锁或人为的可伸缩性问题。相反，等待条件变量可能会阻塞，直到安排了一些其他工作来发出信号为止。这种模式强烈反对推荐。需要进行持续的库工作以提供允许程序避免这些陷阱的抽象。</p><p>      类老师{init（hiringFrom：College）异步抛出{...}私有func raiseHand（）异步-＆gt;布尔{...}}</p><p> 原理：异步跟随参数列表，因为它是函数类型及其声明的一部分。这遵循引发掷球的先例。</p><p> 对声明为异步的函数或初始化程序的引用的类型是异步函数类型。如果该引用是对实例方法的“咖喱”静态引用，则它是＆＃34; inner＆＃34;。异步的函数类型，与此类引用的通常规则一致。 </p><p>诸如deinit和storage访问器（即属性和下标的getter和setter）之类的特殊功能不能异步。</p><p> 基本原理：仅具有getter的属性和下标可能是异步的。但是，还具有异步setter的属性和下标意味着能够将引用作为inout传递并深入到该属性本身的属性，这取决于setter有效地是“即时”实体。 （同步，非抛出）操作。禁止异步属性是比仅允许仅获取异步属性和下标更简单的规则。</p><p> 如果一个函数既是异步函数又是引发函数，那么async关键字必须在类型声明中的引发函数之前。如果异步并重新抛出，则适用相同的规则。</p><p> 理由：这种顺序限制是任意的，但不是有害的，并且消除了进行样式辩论的可能性。</p><p> 仅当超类具有零参数，同步的指定初始化器时，具有超类但未调用超类初始化器的类的异步初始化器才会获得对super.init（）的隐式调用。</p><p> 基本原理：如果超类初始化程序是异步的，则对异步初始化程序的调用是潜在的挂起点，因此，该调用（和必需的等待）必须在源中可见。</p><p>  异步函数类型与同步函数类型不同。但是，存在从同步功能类型到其相应异步功能类型的隐式转换。这类似于从非抛出函数到其抛出对应项的隐式转换，后者也可以与异步函数转换组成。例如： </p><p>struct FunctionTypes {var syncNonThrowing：（）-＆gt; 无效var syncThrowing：（）抛出-> 无效var asyncNonThrowing：（）async-> 无效var asyncThrowing：（）异步抛出-> 无效的变异函数showConverts（）{//可以添加＆＃39; async＆＃39; 和/或引发 asyncNonThrowing = syncNonThrowing asyncThrowing = syncThrowing syncThrowing = syncNonThrowing asyncThrowing = asyncNonThrowing //错误  ...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md">https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/swift/">#swift</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/async/">#async</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1035472.html"><img src="http://img2.diglog.com/img/2020/11/thumb_24f5ee8e405405bddf4968b8e8e78fd6.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035472.html">基于梯度的机器学习的可微编程</a></div><span class="my_story_list_date">2020-11-21 12:4</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033843.html"><img src="http://img2.diglog.com/img/2020/11/thumb_aa61ee6d247de527fb0441f6f9334bd7.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033843.html">Sintert：用SWIFT编写的适用于MacOS的用户态应用程序授权系统</a></div><span class="my_story_list_date">2020-11-8 20:20</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029433.html"><img src="http://img2.diglog.com/img/2020/10/thumb_9288d7ad6e1e89befcae18c6478b039f.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029433.html">SWIFT与C++的互操作性</a></div><span class="my_story_list_date">2020-10-17 19:38</span></div><div class="col-sm"><div><a target="_blank" href="/story/1025758.html"><img src="http://img2.diglog.com/img/2020/9/thumb_445a246e0207a82cea31dda8c9fffac4.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1025758.html">SWIFT项目宣布其语言工具现已可用于Windows 10</a></div><span class="my_story_list_date">2020-9-23 8:0</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>