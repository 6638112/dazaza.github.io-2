<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>多天堂语言Multi-Paradigm Languages</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Multi-Paradigm Languages<br/>多天堂语言</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-23 22:43:00</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/378f7213ec4a5e4bfa5fff9d24881661.jpg"><img src="http://img2.diglog.com/img/2020/11/378f7213ec4a5e4bfa5fff9d24881661.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>We need to learn how to effectively use multi-paradigm languages that support functional, object oriented, and procedural paradigms.</p><p>我们需要学习如何有效地使用支持功能，面向对象和过程范式的多范式语言。</p><p>  The programming world used to be split into functional languages, object-oriented languages, and everything else (mostly procedural languages). One “was” a functional programmer (at least as a hobby) writing Lisp, Haskell, or Erlang; or one “was” an OO programmer (at least professionally), writing code in Java or C++.  (One never called oneself a “procedural programmer”; when these names escaped from academia in the 1990s, calling yourself a “procedural programmer” would be akin to wearing wide ties and bell-bottom jeans.)</p><p>  编程世界曾经被划分为功能性语言，面向对象的语言以及其他所有语言（大多数是过程语言）。一个人是（至少是业余爱好的）函数式程序员，他们编写Lisp，Haskell或Erlang。或者一个“是” OO程序员（至少是专业的），用Java或C ++编写代码。 （一个人从来没有称自己为“程序程序员”；当这些名字在1990年代从学术界摆脱出来时，称自己为“程序程序员”将类似于穿着宽领带和喇叭裤。）</p><p> But this world has been changing. Over the past two decades, we’ve seen the rise of hybrid programming languages that combine both functional and object-oriented features. Some of these languages (like Scala) were multi-paradigm from the beginning. Others, like Python (in the transition from Python 2 to 3) or Java (with the introduction of Lambdas in Java 8) are object-oriented or procedural languages to which functional features were added. Although we think of C++ as an object-oriented language, it has also been multi-paradigm from the beginning. It started with C, a procedural language, and added object-oriented features. Later, beginning with the Standard Template Library, C++ was influenced by many ideas from Scheme, a descendant of LISP.  JavaScript was also heavily influenced by Scheme, and popularized the idea of anonymous functions and functions as first class objects. And JavaScript was object-oriented from the start, with a prototype-based object model and syntax (though not semantics) that gradually evolved to become similar to Java’s.</p><p> 但是这个世界正在改变。在过去的二十年中，我们看到了结合了功能性和面向对象功能的混合编程语言的兴起。这些语言中的某些语言（例如Scala）从一开始就是多范式。其他语言，例如Python（从Python 2过渡到3）或Java（在Java 8中引入Lambda），都是面向对象的或过程语言，其中添加了功能。尽管我们认为C ++是一种面向对象的语言，但从一开始它就已经是多种范例。它以一种程序语言C开头，并添加了面向对象的功能。后来，从标准模板库开始，C ++受LISP的后代Scheme的许多想法的影响。 JavaScript也受Scheme的严重影响，并普及了匿名函数和作为一流对象的函数的思想。 JavaScript从一开始就是面向对象的，其基于原型的对象模型和语法（尽管不是语义）逐渐演变为与Java类似的语法。</p><p>  We’ve also seen the rise of languages combining static and dynamic typing (TypeScript in the JavaScript world; the addition of optional type hinting in Python 3.5; Rust has some limited dynamic typing features). Typing is another dimension in paradigm space. Dynamic typing leads to languages that make programming fun and where it’s easy to be productive, while strict typing makes it significantly easier to build, understand, and debug large systems. It’s always been easy to find people praising dynamic languages, but, except for a few years in the late 00s, the dynamic-static paradigmatic hasn’t attracted as much attention.</p><p>  我们还看到了结合静态和动态类型的语言的兴起（JavaScript世界中的TypeScript； Python 3.5中添加了可选的类型提示； Rust具有一些有限的动态类型功能）。键入是范式空间中的另一个维度。动态打字会产生使编程变得有趣且易于生产的语言，而严格打字会大大简化构建，理解和调试大型系统的过程。总是很容易找到赞美动态语言的人，但是，除了00年代后期的几年，动态静态范式并未引起人们的广泛关注。</p><p> Why do we still see holy wars between advocates of functional and object-oriented programming? That strikes me as a huge missed opportunity. What might “multi-paradigm programming” mean? What would it mean to reject purity and use whatever set of features provide the best solution in any given context? Most significant software is substantial enough that it certainly has components where an object-oriented paradigm makes more sense, and components where a functional paradigm is superior.  For example, look at a “functional” feature like recursion.  There are certainly algorithms that make much more sense recursively (Towers of Hanoi, or printing a sorted binary tree in order); there are algorithms where it doesn’t make much of a difference whether you use loops or recursion (whenever tail recursion optimizations will work); and there are certainly cases where recursion will be slow and memory-hungry. How many programmers know which solution is best in any situation?</p><p> 为什么我们仍然看到函数式和面向对象编程的倡导者之间展开一场神圣的战争？那让我印象深刻，这是一个巨大的机会。 “多范式编程”可能意味着什么？在任何给定的情况下，拒绝纯度并使用任何提供最佳解决方案的功能意味着什么？最重要的软件足够重要，以至于它肯定具有使面向对象的范式更有意义的组件，以及具有功能性范式优越的组件。例如，查看“功能”功能（例如递归）。当然，有一些算法在递归上更有意义（河内的塔楼，或按顺序打印排序的二叉树）。在某些算法中，无论您使用循环还是递归都无济于事（每当尾部递归优化起作用时）；当然，在某些情况下，递归会很慢并且需要大量内存。有多少程序员知道哪种解决方案在任何情况下都是最佳选择？</p><p> These are the sort of questions we need to start asking. Design patterns have been associated with object-oriented programming from the beginning. What kinds of design patterns make sense in a multi-paradigm world? Remember that design patterns aren’t “invented”; they’re observed, they’re solutions to problems that show up again and again, and that should become part of your repertoire. It’s unfortunate that functional programmers tend not to talk about design patterns; when you realize that patterns are observed solutions, statements like “patterns aren’t needed in functional languages” cease to make sense. Functional programmers certainly solve problems, and certainly see the same solutions show up repeatedly. We shouldn’t expect those problems and solutions to be the same problems and solutions that OO programmers observe. What patterns yield the best of both paradigms? What patterns might help to determine which approach is most appropriate in a given situation?</p><p> 这些是我们需要开始提出的问题。从一开始，设计模式就已经与面向对象的编程相关联。在多范例世界中，哪种设计模式有意义？请记住，设计模式不是“发明”的；他们被观察到，它们是问题的解决方案，这些问题一遍又一遍地出现，并且应该成为您曲目中的一部分。不幸的是，函数式程序员往往不谈论设计模式。当您意识到模式是可观察的解决方案时，“在功能语言中不需要模式”之类的陈述就不再有意义了。函数式程序员肯定会解决问题，并且肯定会看到相同的解决方案反复出现。我们不应该期望这些问题和解决方案与OO程序员所观察到的问题和解决方案相同。哪种模式在这两种范式中都发挥了最佳作用？在给定情况下，哪种模式可能有助于确定哪种方法最合适？</p><p> Programming languages represent ways of thinking about problems. Over the years, the paradigms have multiplied, along with the problems we’re interested in solving. We now talk about event-driven programming, and many software systems are event-driven, at least on the front end. Metaprogramming was popularized by JUnit, the first widely used tool to rely on this feature that’s more often associated with functional languages; since then, several drastically different versions of metaprogramming have made new things possible in Java, Ruby, and other languages.</p><p> 编程语言代表思考问题的方式。多年来，随着我们感兴趣的问题的解决，范式成倍增加。现在我们讨论事件驱动的编程，至少在前端，许多软件系统都是事件驱动的。元编程由JUnit普及，它是第一个广泛使用的依赖于此功能的工具，该功能通常与功能语言相关联；从那时起，几种截然不同的元编程版本使Java，Ruby和其他语言的新事物成为可能。</p><p> We’ve never really addressed the problem of how to make these paradigms play well together; so far, languages that support multiple paradigms have left it to the programmers to figure out how to use them. But simply mixing paradigms ad hoc probably isn’t the ideal way to build large systems–and we’re now building software at scales and speeds that were hard to imagine only a few years ago. Our tools have improved; now we need to learn how to use them well. And that will inevitably involve blending paradigms that we’ve long viewed as distinct, or even in conflict.</p><p>我们从来没有真正解决过如何使这些范式一起发挥作用的问题；到目前为止，支持多种范例的语言已由程序员自行决定如何使用它们。但是，仅仅临时混合范式可能不是构建大型系统的理想方法-我们现在正在以几年前无法想象的规模和速度构建软件。我们的工具已经改进；现在我们需要学习如何很好地使用它们。这将不可避免地涉及混合我们长期以来一直被视为不同甚至冲突的范例。</p><p>  Receive weekly insight from industry insiders—plus exclusive content, offers, and more on the topic of software engineering.</p><p>  每周从行业内部人士那里获得见解，以及有关软件工程主题的独家内容，优惠和更多信息。</p><p>  View sample newsletter</p><p>  查看样本新闻通讯</p><p> Receive weekly insight from industry insiders—plus exclusive content, offers, and more on the topic of software engineering.</p><p> 每周从行业内部人士那里获得见解，以及有关软件工程主题的独家内容，优惠和更多信息。</p><p>  View sample newsletter</p><p>  查看样本新闻通讯</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.oreilly.com/radar/multi-paradigm-languages/">https://www.oreilly.com/radar/multi-paradigm-languages/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/天堂/">#天堂</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/paradigm/">#paradigm</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>