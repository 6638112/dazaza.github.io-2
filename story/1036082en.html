<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>单人SaaS的技术堆栈The Tech Stack of a One-Man SaaS</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Tech Stack of a One-Man SaaS<br/>单人SaaS的技术堆栈</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-23 22:41:16</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/34337e4e72acb24638ee6997b18c46d1.png"><img src="http://img2.diglog.com/img/2020/11/34337e4e72acb24638ee6997b18c46d1.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Being an engineer at heart, each time I see a company write about their tech stack, I brew a fresh cup of coffee, sit back and enjoy reading the newfound little treat.</p><p>作为一名内心的工程师，每当我看到一家公司撰写有关其技术堆栈的文章时，我都会冲泡一杯新鲜的咖啡，坐下来欣赏新发现的小点心。</p><p> There’s just something fascinating about getting to know what’s under the hood of other people’s businesses. It’s like gossip, but about software.</p><p> 了解其他人的业务背后隐藏着一些有趣的东西。就像八卦，但关于软件。</p><p> A couple of months ago I started working on  yet another private analytics service, a project which has gone through numerous iterations, and I feel lucky that 400+ websites have already integrated with it, even though it&#39;s still in the early stages.</p><p> 几个月前，我开始从事另一项私有分析服务，该项目经历了无数次迭代，我感到幸运的是，已经有400多个网站与之集成，即使它仍处于早期阶段。</p><p> That’s why, in the same spirit as Jake Lazaroff’s  Tools and Services I Use to Run My SaaS, I thought it’s now my turn to do a short write up of the technologies I’m using to run this new service.</p><p> 这就是为什么，本着与我用来运行SaaS的杰克·拉扎罗夫（Jake Lazaroff）的工具和服务相同的精神，我认为现在该轮到我来简要编写用于运行此新服务的技术了。</p><p>  Over the years I have added many programming languages to my toolbelt, but for solo projects I have converged to two in particular that strike a good balance of productivity and reliability.</p><p>  多年来，我在工具带中添加了许多编程语言，但是对于单独项目，我尤其是将两种语言融合在一起，从而在生产率和可靠性之间取得了很好的平衡。</p><p> Python: Most of the backend code is in Python. Which has enabled me to ship features incredibly fast. Additionally, I use  mypy for optional type hints, which helps keep the codebase manageable.</p><p> Python：大多数后端代码都在Python中。这使我能够以惊人的速度发布功能。另外，我将mypy用于可选的类型提示，这有助于使代码库易于管理。</p><p> Typescript: I used to avoid working on the frontend as much as I could. That is until I discovered Typescript about 4 years ago. It just makes the whole experience a lot better, and I now use it for all my projects together with React.</p><p> 打字稿：我以前尽量避免在前端工作。直到大约4年前我发现Typescript。它使整个体验变得更好了，现在我将它与React一起用于我的所有项目。</p><p>  This list could have been huge, as I stand on the shoulders of giants who have published the vast amount of open-source code which I rely on. But I&#39;d like to highlight only a handful due to their major role in the stack:</p><p>在我站在已经发布了我所依赖的大量开源代码的巨人的肩膀上时，该列表可能非常庞大。但由于它们在堆栈中的主要作用，我只想强调一下：</p><p> Django: It&#39;s like a superpower for solo developers. The longer you work in this industry, the more you appreciate not having to reinvent the wheel for the 100th time. A monolithic framework can get you  really,  really  far. To me, it&#39;s about predictable software that&#39;s fast in every way that matters. In case you&#39;re interested, I talk more about this topic on  Choose Boring Technology.</p><p> Django：对于单独开发人员来说就像一个超级大国。您在该行业中工作的时间越长，就越能避免在第100次重新发明轮子而倍感欣慰。单一框架可以使您真正，真正地受益。对我来说，这是关于可预测的软件，它在所有重要方面都非常快。如果您有兴趣，我会在“选择无聊技术”中讨论更多有关此主题的信息。</p><p> React: The web app for the dashboards is built using React + Webpack. After using Angular for a long time, I switched to React because it&#39;s just a pluggable view layer that doesn&#39;t get in the way. I use the fantastic  django-react-templatetags to embed the React components in my Django templates.</p><p> React：仪表板的Web应用程序是使用React + Webpack构建的。在长时间使用Angular之后，我切换到React，因为它只是可插拔的视图层，不会妨碍操作。我使用出色的django-react-templatetags将React组件嵌入到我的Django模板中。</p><p> NextJS: I use it for the landing pages, documentation and the blog which you are currently reading. It enables me to re-use various React components, and still reap the performance and SEO benefits of a statically generated site.</p><p> NextJS：我将其用于登录页面，文档和您当前正在阅读的博客。它使我能够重用各种React组件，并且仍然获得静态生成的站点的性能和SEO优势。</p><p> Celery: I use it for any kind of background/scheduled tasks. It does have a learning curve for more advanced use-cases, but it&#39;s quite reliable once you understand how it works, and more importantly when it fails.</p><p> 芹菜：我将其用于任何背景/预定任务。它确实具有针对更高级用例的学习曲线，但是一旦您了解了它的工作原理，并且更重要的是它失败了，它就非常可靠。</p><p> Bootstrap 4: I built a custom theme on top of Bootstrap. It has saved me a lot of time, and there&#39;s lots of documentation around it. That&#39;s why I picked it.</p><p> Bootstrap 4：我在Bootstrap的顶部构建了一个自定义主题。它节省了我很多时间，并且周围有很多文档。这就是我选择它的原因。</p><p>  I originally stored all data in a single SQLite database, doing backups meant making a copy of this file to an object storage like S3. At the time, it was more than enough for the small sites I tested Panelbear with. But as I added more features and websites, I needed more specialized software to support those features:</p><p>  我最初将所有数据存储在一个SQLite数据库中，进行备份意味着将该文件的副本复制到S3之类的对象存储中。当时，对于我测试过Panelbear的小型站点来说，这已经足够了。但是随着我添加更多功能和网站，我需要更多专门的软件来支持这些功能：</p><p> Clickhouse: I believe this is one of those technologies that over time will become ubiquitous. It&#39;s honestly a fantastic piece of software that enabled me to build features that initially seemed impossible on low-cost hardware. I do intend to write a future blog post on some lessons learned from running Clickhouse on Kubernetes. So stay tuned!</p><p>Clickhouse：我相信这是随着时间的推移将无处不在的那些技术之一。老实说，这是一款很棒的软件，使我能够构建起初在低成本硬件上似乎无法实现的功能。我确实打算在将来的博客中写一些关于在Kubernetes上运行Clickhouse的经验教训。敬请期待！</p><p> PostgreSQL: My go-to relational database. Sane defaults, battle-tested, and deeply integrated with Django. For Panelbear, I use it for all application data that is not analytics related. For the analytics data, I instead wrote a simple interface for querying Clickhouse within Django.</p><p> PostgreSQL：我的关系数据库。 Sane默认使用，经过测试并与Django深度集成。对于Panelbear，我将其用于与分析无关的所有应用程序数据。对于分析数据，我写了一个简单的界面来查询Django中的Clickhouse。</p><p> Redis: I use it for many things: caching, rate-limiting, as a task queue, and as a key/value store with TTL for various features. Rock-solid, and great documentation.</p><p> Redis：我将它用于许多方面：缓存，速率限制，作为任务队列以及作为具有各种功能的TTL的键/值存储。坚如磐石，功能强大的文档。</p><p>  I treat my infrastructure as  cattle instead of pets, things like servers and clusters are meant to come and go. So if one server gets &#34;sick&#34;, I just replace it with another one. That means everything is described as code in a git repo, and I do not change things by SSH&#39;ing into the servers. You can think of it like a template to clone my entire infrastructure with one command into any AWS region/environment.</p><p>  我将基础设施视为牲畜而不是宠物，服务器和集群之类的东西本该来来往往。因此，如果一台服务器“生病”，我将其替换为另一台。这意味着一切都在git repo中被描述为代码，我不会通过SSH进入服务器来进行更改。您可以将其视为一个模板，用一个命令将我的整个基础架构克隆到任何AWS区域/环境中。</p><p> This also helps me in case of disaster recovery. I just run a few commands, and some minutes later my stack has been re-created. This was particularly useful when I moved from DigitalOcean, to Linode, and recently to AWS. Everything is described in code, so it&#39;s easy to keep track of what components I own, even years later (all companies have some AWS IAM policy or VPC subnet lurking around which was created via clicky-clicky on the UI, and now everyone depends on it).</p><p> 这在灾难恢复时也对我有帮助。我只运行了一些命令，几分钟后，我的堆栈已重新创建。当我从DigitalOcean迁移到Linode，再到最近迁移到AWS时，这特别有用。一切都用代码描述，因此即使在几年后，也很容易跟踪我拥有的组件（所有公司都有一些通过用户界面上的clicky-clicky创建的AWS IAM策略或VPC子网，现在每个人都依赖它）。</p><p> Terraform: I manage most of my cloud infrastructure with Terraform. Things like EKS clusters, S3 buckets, roles, and RDS instances are declared in my Terraform manifests. The state is synced to an encrypted S3 bucket to avoid getting in trouble in case something happens to my development laptop.</p><p> Terraform：我使用Terraform管理大部分云基础架构。在我的Terraform清单中声明了诸如EKS集群，S3存储桶，角色和RDS实例之类的东西。状态会同步到加密的S3存储桶，以免在我的开发笔记本电脑发生故障时遇到麻烦。</p><p> Docker: I build everything as Docker images. Even stateful components like Clickhouse or Redis are packaged and shipped as Docker containers to my cluster. It also makes my stack very portable, as I can run it anywhere I can run Docker.</p><p> Docker：我将所有内容构建为Docker映像。甚至有状态组件（如Clickhouse或Redis）也作为Docker容器打包并运送到我的集群中。这也使我的堆栈非常可移植，因为我可以在可以运行Docker的任何地方运行它。</p><p> Kubernetes: Allowed me to simplify the operational aspects tremendously. However, I wouldn’t bindly recommend it to everyone, as I already felt comfortable working with it after having the pleasure of putting down multiple production fires for my employer over the years. I also rely on managed offerings, which helps reduce the burden too.</p><p>Kubernetes：允许我极大地简化操作方面。但是，我并不会向所有人推荐它，因为多年来我很高兴为雇主解雇了多次生产大火，因此我对使用它感到很自在。我还依靠托管产品，这也有助于减轻负担。</p><p> GitHub Actions: Normally I’d use  CircleCI in the past (which is also great), but for this project I prefer to use GitHub Actions as it removes yet another service which needs to have access to my repositories, and deployment secrets. However, CircleCI has plenty of good features, and I still recommend it.</p><p> GitHub Actions：过去我通常会使用CircleCI（这也很棒），但是对于这个项目，我更喜欢使用GitHub Actions，因为它删除了另一个需要访问我的存储库和部署机密的服务。但是，CircleCI具有很多好的功能，我仍然推荐它。</p><p>  I started in a single $5/mo instance in DigitalOcean, then moved to the managed Kubernetes offering as I was reinventing the wheel for a lot of things Kubernetes already gives me out of the box (service discovery, TLS certs, load balancing, log rotation, rollout, scaling, fault-tolerance, among others).</p><p>  我从DigitalOcean的一个月费$ 5的实例开始，然后转向管理型Kubernetes产品，因为我正在彻底改变Kubernetes已经为我提供的许多功能（服务发现，TLS证书，负载平衡，日志循环） ，卷展栏，缩放比例，容错等）。</p><p> Unfortunately, I had  reliability issues with DigitalOcean&#39;s Kubernetes offering, even on larger instances. The cluster API would often go down randomly and no longer recover, this disrupted a lot of cluster services including the load balancer, which translated into downtime for me. I had to create a new cluster each time this happened, and while Terraform made it trivial, this was not something that inspired a lot of confidence about their managed service. I suspect their control plane was underprovisioned, which would be kind of understandable given the price tag.</p><p> 不幸的是，即使在较大的实例上，DigitalOcean的Kubernetes产品也存在可靠性问题。群集API经常会随机关闭并且不再恢复，这破坏了包括负载均衡器在内的许多群集服务，这对我来说意味着停机。每当发生这种情况时，我都必须创建一个新集群，尽管Terraform使其变得微不足道，但这并没有激发人们对其托管服务的信心。我怀疑他们的控制飞机配置不足，考虑到价格，这是可以理解的。</p><p> Unfortunately I was not able to resolve the issue after several weeks. That&#39;s why I decided to move to  Linode, and had exactly 0 problems during the 1.5 month-long honeymoon that followed.</p><p> 不幸的是，几周后我无法解决问题。这就是为什么我决定搬到Linode的原因，在接下来的1.5个月的蜜月中，我遇到了0个问题。</p><p> However, I recently moved once again, this time to AWS due to a pretty good deal I received. It also enabled me to use managed services like RDS to offload managing PostgreSQL, which is a big plus. What made all these migrations relatively easy, was that all my infrastructure was described via Terraform and Kubernetes manifests. The migrations essentially consisted of an evening, some tea, and patience. But that&#39;s for another post.</p><p> 但是，由于我收到了一笔非常划算的交易，最近我又一次搬到了AWS。它还使我能够使用RDS等托管服务来减轻对PostgreSQL的管理负担，这是一个很大的优势。使所有这些迁移相对容易的原因是，我的所有基础结构都是通过Terraform和Kubernetes清单进行描述的。迁移主要包括一个晚上，一些茶和耐心。但这是另一篇文章。</p><p> AWS: Predictable, and lots of managed services. However, I use it at my full-time job, so I didn&#39;t have to spend too much time figuring things out. The main services I use are EKS, ELB, S3, RDS, IAM and private VPCs. I might also add Cloudfront and Kinesis in the future.</p><p> AWS：可预测，有很多托管服务。但是，我在全职工作中使用它，因此我不必花费太多时间来解决问题。我使用的主要服务是EKS，ELB，S3，RDS，IAM和专用VPC。将来我可能还会添加Cloudfront和Kinesis。</p><p> Cloudflare: I mainly use it for DDoS protection, serving DNS, and offloading edge caching of various static assets (currently shaves off 80% of the egress charges from AWS - their bandwidth pricing is insane!).</p><p>Cloudflare：我主要将其用于DDoS保护，为DNS服务以及卸载各种静态资产的边缘缓存（目前减少了AWS的80％出口费用-它们的带宽定价太疯狂了！）。</p><p> Let’s Encrypt: Free SSL certificate authority. I use cert-manager in my Kubernetes cluster to automatically issue and renew certificates based on my ingress rules.</p><p> 让我们来加密：免费的SSL证书授权。我在Kubernetes集群中使用cert-manager根据我的入口规则自动颁发和更新证书。</p><p> Namecheap: My domain name registrar of choice. Allows MFA for login which is an important security feature. Unlike other registrars, they haven&#39;t surprised me with an expensive renewal every few years. I like them.</p><p> Namecheap：我选择的域名注册商。允许MFA登录，这是一项重要的安全功能。与其他注册商不同，他们每隔几年就进行一次昂贵的续签，并不令我感到惊讶。我喜欢他们。</p><p>  The following components automate most of the devops work for me. I use several others too, but some of the main ones I use are:</p><p>  以下组件可以自动完成大部分开发工作。我也使用其他几个，但是我使用的一些主要是：</p><p> ingress-nginx: Rock-solid ingress controller for Kubernetes using NGINX as a reverse proxy, and load balancer. Sits behind the NLB which controls ingress to the cluster nodes.</p><p> ingress-nginx：使用NGINX作为反向代理和负载平衡器的Kubernetes坚如磐石的入口控制器。坐在NLB后面，该NLB控制进入群集节点的入口。</p><p>    flux: GitOps way to do continuous delivery in Kubernetes. Basically pulls and deploys new Docker images when I release them.</p><p>    Flux：GitOps在Kubernetes中进行连续交付的方式。当我发布新的Docker映像时，基本上会拉动并部署它们。</p><p>   kubectl: To interact with the Kubernetes cluster to watch logs, pods and services, SSH into a running container, and so on.</p><p>   kubectl：与Kubernetes集群进行交互以查看日志，pod和服务，SSH到正在运行的容器中，等等。</p><p>  Prometheus: Efficient storage of time series data for monitoring. Tracks all the cluster and app metrics. It was a lot cheaper than using Cloudwatch for app metrics.</p><p>Prometheus：有效存储时间序列数据以进行监视。跟踪所有群集和应用程序指标。这比使用Cloudwatch进行应用程序指标便宜得多。</p><p> Grafana: Nice dashboards for the Prometheus monitoring data. All dashboards are described in JSON files and versioned in the git repo.</p><p> Grafana：用于Prometheus监控数据的漂亮仪表板。所有仪表板均在JSON文件中描述，并在git repo中进行版本控制。</p><p> Sentry: Application exception monitoring and aggregation. Notifies when there are unhandled errors with additional metadata.</p><p> Sentry：应用程序异常监视和聚合。带有其他元数据的未处理错误时通知。</p><p> Loki: Log aggregation system inspired by Prometheus. It’s bundled with the prometheus-operator, and helps me search logs across the cluster.</p><p> Loki：受Prometheus启发的日志聚合系统。它与prometheus-operator捆绑在一起，可以帮助我在整个群集中搜索日志。</p><p>  Sendgrid: I use it for transactional emails (email verification, login security alerts, password reset, and so on). However, I have noticed that many account verification emails are not being delivered. It seems that their IP addresses are being blocked by several email providers, so I&#39;m considering moving to  Postmark in the future.</p><p>  Sendgrid：我将其用于交易电子邮件（电子邮件验证，登录安全警报，密码重置等）。但是，我注意到许多帐户验证电子邮件都没有发送。他们的IP地址似乎已被多家电子邮件提供商阻止，因此我将来考虑考虑迁移到Postmark。</p><p>  PyCharm: Probably the best IDE for Python. I can refactor and navigate the entire codebase with ease, and not just individual files. Works really well, even with large, dynamic codebases.</p><p>  PyCharm：可能是Python的最佳IDE。我可以轻松地重构和导航整个代码库，而不仅仅是单个文件。即使使用大型动态代码库，效果也很好。</p><p>    Invoked: I wrap all my codebase tasks in invoked commands. For example  inv build will prepare static assets, package the frontend/backend distribution, and build the docker image. This way, I can run locally the same commands that I would run on CI, in case it&#39;s needed.</p><p>    调用：我将所有代码库任务包装在调用的命令中。例如，inv build将准备静态资产，打包前端/后端分发，并生成docker映像。这样，就可以在本地运行与在CI上运行的命令相同的命令。</p><p>  Panelbear Analytics: Of course what better tool to track Panelbear&#39;s website analytics than Panelbear itself :) The benefits of dogfooding are real, as I am my own customer.</p><p>Panelbear Analytics：当然，有比Panelbear本身更好的工具来跟踪Panelbear的网站分析：)狗食的好处是真实的，因为我是我自己的客户。</p><p> Healthchecks: Notifies me via email/whatsapp when a scheduled job doesn&#39;t run. It&#39;s also a bootstrapped SaaS, and I was very happy to recommend them to my current employer a few years ago. Prevented a few incidents for them, so it already paid for itself.</p><p> 健康检查：当计划的作业没有运行时，通过电子邮件/ whatsapp通知我。它也是自举的SaaS，几年前我很高兴将其推荐给我的现任雇主。为他们防止了一些事件，因此它已经物有所值。</p><p>  Figma: Replaced  Sketch as my go-to tool for making quick mockups, banners, and illustrations for the landing pages.</p><p>  Figma：取代了Sketch作为我的入门工具，用于为目标页面快速制作模型，横幅和插图。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://panelbear.com/blog/tech-stack/">https://panelbear.com/blog/tech-stack/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/saas/">#saas</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/stack/">#stack</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>