<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>消息队列大指南 The Big Little Guide to Message Queues</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Big Little Guide to Message Queues<br/>消息队列大指南 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-01 08:09:14</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/fee825295c8896de286edf32d534cdc2.jpeg"><img src="http://img2.diglog.com/img/2021/1/fee825295c8896de286edf32d534cdc2.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Message Queues are now fairly prevalent—there are so many of them showing up so fast you&#39;d think they were  rabbits with an unlimited supply of  celery, resulting in an  kafkaesque situation where making a decision is like trying to catch a  stream in your hands. If only there were fewer  simple  services that could help with  publishing and subscribing, it would be so much easier to make a  zero-effort choice 😕</p><p>消息队列现在相当普遍-出现的消息队列是如此之快，以至于您认为它们是芹菜供应量无限的兔子，从而导致卡夫卡式风格的情况，做出决定就像试图抓住一条小溪你的双手。如果只有很少的简单服务可以帮助发布和订阅，那么做出零努力的选择就会容易得多😕</p><p> Whether we use them by themselves as-is to move data between parts of our application, or as an integral part of the architecture (like event driven systems), message queues are here to stay. In a way, they&#39;ve been here all along—just without as many names. But what are they? Why are they useful? And how do we use them effectively? Which implementation do we pick? Does it even matter which one we use? And do we need to learn each of them individually, or are there more general concepts that apply to all message queues?</p><p> 无论我们是按原样使用它们来在应用程序的各个部分之间移动数据，还是作为体系结构的组成部分（如事件驱动的系统），消息队列都将保留下来。从某种意义上说，他们一直在这里-只是名字不多。但是他们是什么？为什么有用？以及我们如何有效地使用它们？我们选择哪种实现？我们使用哪一个都不重要？我们是否需要分别学习它们，还是有适用于所有消息队列的更一般的概念？</p><p>  Patterns for fan-out and fan-in: delivering one message to many systems or messages from many systems into one.</p><p>  扇出和扇入的模式：将一条消息传递到多个系统，或将消息从许多系统组合成一个。</p><p>  Message Queues are a way to transfer information between two systems. This information—a message—can be data, metadata, signals, or a combination of all three. The systems that are sending and receiving messages could be processes on the same computer, modules of the same application, services that might but running on different computers or technology stacks, or entirely different kinds of systems altogether—like transferring information from your software into an email or an SMS on the cellphone network.</p><p>  消息队列是在两个系统之间传输信息的一种方式。此信息（一条消息）可以是数据，元数据，信号或这三者的组合。发送和接收消息的系统可以是同一台计算机上的进程，同一应用程序的模块，可能在不同计算机或技术堆栈上运行但可能完全不同种类的系统上运行的服务，例如将信息从软件传输到电子邮件或手机网络上的SMS。</p><p> The idea of a messaging system has been around a very long time, from the message boxes used for moving information between people or office departments (literally where the words  inbox and  outbox come from), to telegrams, to your local postal or courier service. The messaging systems in the physical world that come closest to what we have in computing are probably the  pnuematic  tubes that moved messages through buildings and cities using compressed air until a few decades ago (and are still used in some places today).</p><p> 消息传递系统的想法已经存在了很长的时间，从用于在人员或办公室部门之间移动信息的消息框（实际上是收件箱和发件箱的字眼来自哪里），电报到您当地的邮政或快递服务。物理世界中最接近我们计算能力的消息传递系统可能是气动管道，这些管道利用压缩空气将消息传递通过建筑物和城市，直到几十年前（如今仍在某些地方使用）。</p><p> The kinds of messages we transfer today might be a note that something technical happened, like CPU usage exceeding a limit; or a business event of interest, like a customer placing an order; or a signal, like a command that tells another service to do something. The contents of each message will be driven entirely by the architecture of your application and its purposes—so for the rest of this guide, we don&#39;t need to be concerned about what&#39;s inside a message—we&#39;re more concerned with how the message gets from the system where it originates (the  producer,  source, publisher or  sender) to the system where&#39;s it&#39;s supposed to go (the  consumer,  subscriber,  destination or  receiver).</p><p> 我们今天传输的消息类型可能表明发生了某些技术问题，例如CPU使用率超出限制；或感兴趣的商业事件，例如客户下订单；或信号，例如告诉其他服务执行某项操作的命令。每条消息的内容将完全由您的应用程序的体系结构及其用途来决定-因此，在本指南的其余部分中，我们不必担心消息中的内容-我们；更关注消息如何从消息起源的系统（生产者，源，发布者或发送者）到达应该发送到的系统（消费者，订户，目的地或接收者） ）。</p><p>  We need message queues because no system exists or works in isolation—all systems need to communicate with other systems in structured ways that they both can understand, and at a controlled speed that they both can handle. Any non-trivial process needs a way to move information between each stage of the process; any workflow needs a way to move the intermediate product between the stages of that workflow. Message queues are a great way to handle this movement. There are plenty of ways of getting these messages around using API calls, file systems, or many other abuses of the natural order of things; but all of these are ad-hoc implementations of the message queue that we sometimes refuse to acknowledge we need.</p><p>  我们需要消息队列，因为没有系统存在或无法孤立地工作-所有系统都需要以它们都可以理解的结构化方式并以它们都可以处理的受控速度与其他系统通信。任何非平凡的流程都需要一种在流程的各个阶段之间移动信息的方法。任何工作流程都需要一种在该工作流程的各个阶段之间移动中间产品的方法。消息队列是处理此移动的好方法。有很多方法可以使用API​​调用，文件系统或许多其他对事物自然顺序的滥用来获取这些消息。但是所有这些都是消息队列的临时实现，有时我们拒绝承认我们需要这些实现。 </p><p> The simplest mental model for a message queue is a very long tube that you can roll a ball into. You write your message on a ball, roll it into the tube, and someone or something else receives it at the other end. There are a lot of interesting benefits with this model, some of which are:</p><p>消息队列的最简单思维模型是一个很长的管，您可以将它扔进去。您将您的消息写在一个球上，将其滚动到管子中，另一端收到某人或其他东西。该模型有很多有趣的好处，其中包括：</p><p> We don&#39;t need to worry about  who or what is going to receive the message – that&#39;s one less responsibility for the sender to be concerned about.</p><p> 我们不必担心接收消息的是谁或什么，这使发件人不必担心。</p><p> We don&#39;t need to worry about  when the receiver is going to pick up the message.</p><p> 我们不必担心接收方何时接收消息。</p><p> We can put  as many messages as we want into the tube (let&#39;s assume we have a infinitely long tube) at whatever  speed is comfortable to us.</p><p> 我们可以按照自己喜欢的速度将任意数量的消息放入管道中（假设我们有无限长的管道）。</p><p> The receiver will  never be impacted by our actions—they will pull out as many messages as they want at whatever rate is comfortable to them.</p><p> 接收者永远不会受到我们行动的影响-他们将以他们希望的任何速率拉出任意数量的消息。</p><p>  Neither the sender nor the receiver are concerned with the  capacity or load of the other.</p><p>  发送方和接收方都不关心对方的容量或负载。</p><p> Neither system is concerned with  where the other one is – they may or many not reside on the same computer, network, continent or even the same planet.</p><p> 两个系统都不关心另一个系统的位置–它们可能位于或不在同一台计算机，网络，大陆或同一星球上。 </p><p> Each of these advantages (and this isn&#39;t even an exhaustive list) has very important benefits in software development—what they all have in common is  decoupling. One system is decoupled from the other in terms of responsibility, time, bandwidth, internal workings, load and geography. And decoupling is a very desirable part of any distributed or complex system—the more decoupled the parts of the system are, the easier it is to independently build, test, run, maintain and scale them.</p><p>所有这些优点（甚至不是详尽的清单）在软件开发中都具有非常重要的好处-它们的共同点是去耦。一个系统在职责，时间，带宽，内部工作方式，负载和地理位置方面与另一个系统是分离的。解耦是任何分布式或复杂系统中非常需要的部分-系统各部分之间的解耦越多，独立构建，测试，运行，维护和扩展它们就越容易。</p><p> Most systems interact with other outside or third-party systems as well—if we build a shopping site we might interact with a payment processor, and let’s say we attempt to directly communicate with the payment processor on each user click. If our system is under heavy load, we&#39;re also subjecting the other system to the same load. And vice versa—if our payment provider needs to send us millions of pieces of information about our past payment statues, our system better be ready. The two systems are now  coupled. The decisions and actions made by one system have a significant impact on the other, so the needs of both need to be taken into account while making every decision. Add enough other systems into the mix, like logistics or delivery systems, and we quickly have a paralysing mess that makes it difficult to decide anything at all. If one system goes down, the other systems have effectively gone down as well, for no fault of their own.</p><p> 大多数系统也可以与其他外部或第三方系统进行交互-如果我们建立购物网站，则可能会与支付处理器进行交互，并且假设我们尝试在每次用户点击时直接与支付处理器进行通信。如果我们的系统负载过重，我们还会使另一个系统承受相同的负载。反之亦然-如果我们的付款提供商需要向我们发送数百万条有关过去付款方式的信息，那么我们的系统就更好了。这两个系统现在已耦合。一个系统做出的决定和动作会对另一个系统产生重大影响，因此在做出每个决定时都必须考虑到两者的需求。将足够多的其他系统（例如物流或交付系统）添加到组合中，我们很快就会陷入瘫痪状态，这使得根本无法决定任何事情。如果一个系统发生故障，则其他系统也有效地发生故障，而它们本身没有故障。</p><p> We’re also in trouble if we want to switch out any one of these systems for another one, like a new payment processor or delivery system. We’d have to make deep changes in multiple places in our application, and it’s even more difficult to build code to split our messages between multiple providers—we may want to use a ratio to load balance them or split them by geography; or dynamically switch between them based on each provider’s availability or cost.</p><p> 如果我们想将这些系统中的任何一个切换为另一个系统，例如新的付款处理器或交付系统，也会遇到麻烦。我们必须在应用程序的多个位置进行深刻的更改，构建代码以在多个提供商之间拆分消息甚至更加困难。我们可能需要使用比率来负载均衡它们或按地理位置拆分它们；或根据每个提供商的可用性或成本在它们之间动态切换。</p><p> Message queues offer the decoupling that solves a lot of these problems. If we set up a queue between two systems that need to communicate with each other, they can now go about their work without having to worry about each other at all—we put our messages aimed at any system into a queue, and we expect information from the other system to come to us through another queue as well. We now have clear points at which we can add rules or make the changes we require, without either system knowing or caring about what&#39;s different.</p><p> 消息队列提供了解决许多这些问题的解耦功能。如果我们在两个需要相互通信的系统之间建立一个队列，那么他们现在就可以继续工作而不必担心彼此—我们将针对任何系统的消息放入队列中，我们期望获得信息也可以通过另一个队列来访问我们。现在，我们有了明确的要点，可以在其中添加规则或进行所需的更改，而无需系统了解或关心不同之处。</p><p>  Are message queues the holy grail of computing, though? Do they solve all the world&#39;s problems? No, of course not. There are plenty of situations where we might not want to use them. And we certainly don&#39;t want to use a queue just because we have one easily available and think it might be fun. There are some systems that are really simple that just don&#39;t require it—a message queue is a way to reduce to complexity of communicating systems, but two communicating systems will always be more complex than one system that doesn&#39;t have to communicate. If you have a system that’s simple enough to not require communication with any others, there simply isn&#39;t any reason to reach for a queue.</p><p>  消息队列是计算的圣杯吗？他们是否解决了世界上所有的问题？不，当然不。在很多情况下，我们可能不想使用它们。而且我们当然不希望仅仅因为我们有一个容易使用的队列而认为使用队列很有趣。有些系统真的很简单，只是不需要它—消息队列是一种降低通信系统复杂性的方法，但是两个通信系统总是比一个不需要通信系统更复杂。必须沟通。如果您的系统非常简单，不需要与其他任何人进行通信，那么根本就没有任何理由排队。</p><p> There are also systems that communicate with each other, but where the complexity added by that communication added is insignificant and not worth worrying about. Or more often the systems are already coupled, in the sense that they all need to work together to function. A really common example is an application server and a data service (in an  OLTP system). There&#39;s not much point in decoupling them with a queue, because neither can do anything useful without the direct involvement of the other.</p><p> 也有一些系统可以互相通信，但是这些通信所增加的复杂性微不足道，因此不必担心。从某种意义上说，它们都需要协同工作才能正常运行，或者更经常地，系统已经耦合。一个真正常见的示例是应用服务器和数据服务（在OLTP系统中）。将它们与队列解耦没有多大意义，因为如果没有另一个的直接参与，这两个都无法做任何有用的事情。</p><p> Then there&#39;s performance to consider as well—the whole point of decoupling two systems with regards to time and load is so that they can each process information at their own pace—but we certainly would  not want this to happen in performance sensitive applications or real-time systems. A queue might help us process more work at the same time (the receiver might have many processes working in parallel on the messages you send) but will remove any guarantees we need about the exact time taken for each piece of work. If predictability is more important than throughput, we&#39;re better off without a queue.</p><p> 然后，还要考虑性能-将两个系统在时间和负载方面解耦的重点是，以便它们可以按照自己的进度处理信息-但我们当然不希望这种情况在性能敏感的情况下发生应用程序或实时系统。队列可以帮助我们同时处理更多的工作（接收者可能有许多并行处理您发送的消息的工作），但会消除我们对每项工作所需的确切时间的保证。如果可预测性比吞吐量更重要，那么我们最好不要排队。 </p><p> Using a queue might increase the time taken to process each  individual message, but will allow you process many more messages at the same time across different computers—so your total number of messages processed per minute or hour, or  throughput, will increase.</p><p>使用队列可能会增加处理每条单个消息所花费的时间，但是将允许您在不同的计算机上同时处理更多的消息-因此，每分钟或每小时处理的消息总数或吞吐量将增加。</p><p> If we do have multiple systems that need to communicate, and that communication needs to be  durable (if we’ve put a message into a queue, we want to be sure that the messaging system isn’t going to ‘forget’ about it) and decoupled, a message queue is indispensable.</p><p> 如果确实有多个需要通信的系统，并且通信需要持久（如果将消息放入队列中，我们要确保消息传递系统不会“忘记”它）并且解耦后，消息队列必不可少。</p><p>  There&#39;s simply no way to learn about message queues without reading and/or arguing about delivery guarantees and semantics, so we might as well get to that quickly. People who build message queues will claim that their system offers one of three delivery guarantees—that each message you put into the queue will be delivered:</p><p>  在没有阅读和/或争论传递保证和语义的情况下，根本无法了解消息队列，因此我们也可以很快地了解它。建立消息队列的人将声称他们的系统提供了三种传递保证之一，即您放入队列中的每条消息都将被传递：</p><p>  Which guarantees we&#39;re using will have a massive impact on the design and working of our system, so let&#39;s unpack each of them one by one.</p><p>  这保证了我们正在使用该软件将对我们系统的设计和工作产生巨大影响，因此让我们将它们中的每一个都拆包。</p><p>  This is the most common delivery mechanism, and it&#39;s the simplest to reason about and implement. If I have a message for you, I will read it to you, and keep doing so again and again until you acknowledge it. That&#39;s it. In a system which works on an at-least-once basis, this means that when you receive a message from the queue and don&#39;t delete/acknowledge it, you will receive it again in the future, and will keep receiving it until you explicitly delete/acknowledge it.</p><p>  这是最常见的交付机制，也是最简单的推理和实施机制。如果我有一条要给您的消息，我会给您朗读，并不断反复，直到您确认为止。就是这样。在至少一次运行的系统中，这意味着当您从队列中收到一条消息并且不删除/确认该消息时，您将来会再次收到它，并将继续接收它直到您明确删除/确认它为止。</p><p> The reason this is the most common guarantee is that it&#39;s simple and gets the job done 100% of the time—there&#39;s no edge case in which the message gets lost. Even if the receiver crashes before acknowledging the message, it will simply receive the same message again. The flip side is that you as the receiver need to plan on receiving the same message multiple times—even if you haven&#39;t necessarily experienced a crash. This is because offering at-least-once is the simplest way to protect the queueing service from missing out messages as well—if your acknowledgement doesn&#39;t reach the queueing system over the network, the message will be sent again. If there&#39;s a problem persisting your acknowledgement, the message will be sent again. If the queuing system restarts before it can properly keep track of what&#39;s been sent to you, the message will be sent again. This simple remedy of sending the message again in case of any problem on any side is what makes this guarantee so reliable.</p><p> 这是最常见的保证，是因为它很简单并且可以100％地完成工作-不会出现消息丢失的情况。即使接收器在确认消息之前崩溃了，它也只会再次接收相同的消息。不利的一面是，作为接收方的您需要计划多次接收同一条消息，即使您不一定遇到崩溃也是如此。这是因为至少提供一次是保护排队服务也不会丢失消息的最简单方法-如果您的确认没有通过网络到达排队系统，则消息将再次发送。如果仍然存在您的确认问题，该消息将再次发送。如果排队系统在重新启动之前可以正确跟踪已发送给您的内容，则该消息将再次发送。在任何方面出现任何问题的情况下，再次发送消息的简单补救措施就是使此保证如此可靠。</p><p> But is message duplication/repetition a problem? That&#39;s really up to you and your application or use-case. If the message is a timestamp and a measurement, for example, there&#39;s no problem with receiving a million duplicates. But if you&#39;re moving money based on the messages, it definitely is a problem. In these cases you&#39;ll need to have a transactional (ACID) database at the receiving end, and maybe record the message ID in a unique index so that it can&#39;t be repeated. This is called using an  idempotency token or  tombstone—when you act on a message you store a unique permanent marker to keep track of your actions, often in the same database transaction as taking the action itself. The prevents you from repeating that action again even if the message is duplicated.</p><p> 但是消息重复/重复是一个问题吗？这实际上取决于您和您的应用程序或用例。例如，如果该消息是时间戳和度量，则接收一百万个副本没有问题。但是，如果您根据消息转移资金，那肯定是一个问题。在这些情况下，您将需要在接收端建立一个事务（ACID）数据库，并可能将消息ID记录在唯一的索引中，以使其无法重复。这称为使用幂等标记或逻辑删除-当您对消息进行操作时，您通常会在与执行操作本身相同的数据库事务中存储唯一的永久标记来跟踪您的操作。即使邮件重复，也会阻止您再次重复该操作。 </p><p> If you handle duplication, or if your messages are naturally resistant to duplication, your systems are said to be  idempotent. This means you can safely handle receiving the same message multiple times, without corrupting your work. It also often means you can tolerate the sender sending the same message multiple times—remember that senders will usually operate on the at-least-once principle when sending messages as well. If senders are unable to record the fact that they&#39;ve sent a particular message, they&#39;ll simply send it again. The senders are then responsible for making sure that they use the same tombstone or idempotency token if and when they re-send messages.</p><p>如果您处理重复，或者您的消息天生就可以抵抗重复，则可以说您的系统是幂等的。这意味着您可以安全地处理多次收到相同的消息，而不会破坏您的工作。这通常也意味着您可以容忍发件人多次发送相同的消息-请记住，发件人在发送消息时通常也将至少一次执行一次操作。如果发件人无法记录他们已发送特定消息的事实，则只需再次发送即可。然后，发件人有责任确保在重新发送邮件时使用相同的墓碑或幂等令牌。</p><p>  This is a pretty rare semantic, used for messages where duplication is so horribly explosive (or the message so utterly unimportant) that we&#39;d prefer not to send the message at all, rather than send it twice. At-most-once once implies that the queuing system will attempt to deliver the message to you once, but that&#39;s it. If you receive and acknowledge the message all is well, but if you don&#39;t, or anything goes wrong, that message will be lost forever—either because the queuing system has taken great pains to record the delivery to you before attempting to send it (in case the message is horribly explosive), or has not even bothered to record the message at all, and is just passing it on like a router passes on a UDP packet.</p><p>  这是一种非常少见的语义，用于重复非常可怕的消息（或者消息根本不重要），以至于我们不希望根本不发送消息，而不是发送两次。最多一次表示排队系统将尝试一次将消息传递给您，但仅此而已。如果您收到并确认该消息一切都很好，但是如果您不这样做或有任何错误，则该消息将永远丢失-要么是因为排队系统费了很大的劲才能在尝试发送之前记录下向您的传递发送它（以防该消息具有惊人的爆炸性），或者根本不用去记录该消息，就像路由器在UDP数据包上传递一样，只是在传递它。</p><p> This semantic usually comes into play for messaging systems that are either acting as stateless information routers; or in those cases where a repeat message is so destructive that an investigation or reconciliation is necessary in case there&#39;s any failure.</p><p> 这种语义通常在充当无状态信息路由器的消息传递系统中起作用。或者在重复消息具有破坏性的情况下，以防万一发生任何故障时必须进行调查或对帐。</p><p>  This is the holy grail of messaging, and also the fountain of a lot of snake-oil. It implies that every message is guaranteed to be delivered and processed exactly once, no more and no less. Everyone who builds or uses distributed systems has a point in their lives where they think “how hard can this be?”, and then they either (1) learn why it&#39;s impossible, figure out idempotency, and use at-least-once, or (2) they try to build a half-assed “exactly-once” system and sell it for lots of money to those who haven&#39;t figured out (1) yet.</p><p>  这是消息传递的圣杯，也是许多蛇油的源泉。这意味着保证每条消息都只发送一次，处理一次，最多也不会减少。构建或使用分布式系统的每个人在生活中都有一个观点，他们认为“这有多难？”，然后他们要么（1）了解为什么这是不可能的，找出幂等性，然后至少使用-一次，或（2）他们尝试建立一个半确定的“完全一次”系统，并以高价将其出售给尚未弄清（1）的那些人。</p><p>   If you think about the problem deeply, there are a lot of things that can go wrong:</p><p>   如果您深入思考问题，那么很多事情都会出错：</p><p> the acknowledgement that the messaging system has recorded the message might not reach the sender over the network</p><p> 邮件系统已记录邮件的确认可能无法通过网络到达发件人</p><p> the sender might not be able to record the acknowledgement that the messaging system has received the message</p><p> 发件人可能无法记录消息传递系统已收到消息的确认 </p><p> Let&#39;s say all goes well while sending the message—when the messaging system tries to deliver the message to the receiver:</p><p>假设发送消息时一切顺利-当消息传递系统尝试将消息传递给接收者时：</p><p> the messaging system’s database might not be able to record that the message has been delivered</p><p> 邮件系统的数据库可能无法记录邮件已传递</p><p> Given all the things that can go wrong, it&#39;s impossible for any messaging system to guarantee exactly-once delivery. Even if the messaging system is godlike in its perfection, most of the things that can go wrong are outside of it or in the interconnecting networks. Some systems do attempt to use the phrase “exactly once” anyway, usually because they claim their implementation will never have any of the messaging system problems mentioned above—but that doesn&#39;t mean the whole system is magically blessed with exactly-once semantics, even if the claims are actually true. It usually means that the queuing system has some form of ordering, locking, hashing, timers and idempotency tokens that will ensure it never re-delivers a messsage that&#39;s already been deleted/acknowledged—but this doesn&#39;t mean that the whole system including publisher + queue + subscriber has gained full exactly-once guarantees.</p><p> 考虑到所有可能出错的地方，任何消息传递系统都不可能保证一次发送。即使消息传递系统完美无瑕，大多数可能出问题的地方还是在消息传递系统之外或在互连网络中。某些系统确实尝试使用“仅一次”一词，通常是因为它们声称其实现绝不会遇到上述任何消息传递系统问题-但这并不意味着整个系统神奇地拥有一次语义，即使声明实际上是正确的。这通常意味着排队系统具有某种形式的排序，锁定，哈希，计时器和幂等性令牌，这将确保它永远不会重新传递已经被删除/确认的消息，但这并不意味着包括发布者+队列+订阅者在内的整个系统已经获得了完全精确的一次保证。</p><p> Most good messaging system engineers understand this and will  explain to their users why this semantic is unworkable. The simpler and more reliable way to handle messages is go back to the basics and embrace at-least-once with idempotency measures at every point on the sending, receiving and queuing process: if at first you don&#39;t succeed, retry, retry, retry...</p><p> 大多数优秀的邮件系统工程师都理解这一点，并将向用户解释为什么这种语义不可行。处理消息的更简单，更可靠的方法是回到基础知识，并在发送，接收和排队过程的每个点上至少一次采用幂等度量：如果一开始您不成功，请重试，重试，重试...</p><p>  After delivery semantics, another common question on peoples’ minds is “why can’t we just process messages in parallel while also making sure we process them in order?”. Unfortunately this is another tradeoff imposed on us by the tyranny of logic. Doing work in a sequence and doing multiple pieces of work at the same time are always at conflict with each other. Most message queue systems will ask you to pick one—AWS SQS started by prioritising parallelism over strict ordering; but recently introduced a separate FIFO (first in, first out) queuing system as well, which maintains strict sequential ordering. Before making a choice between the two, let’s go over what the difference is and why there needs to be a difference at all.</p><p>  在传递语义之后，人们心中的另一个常见问题是“为什么我们既不能并行处理消息，又要确保按顺序处理消息？”。不幸的是，这是逻辑专制强加给我们的另一个权衡。依次进行工作和同时进行多项工作总是相互冲突的。大多数消息队列系统都会要求您选择一个-AWS SQS是通过将并行性放在优先顺序之上来开始的；但最近又引入了一个单独的FIFO（先进先出）排队系统，该系统保持严格的顺序排序。在两者之间做出选择之前，让我们先探讨一下两者之间的区别以及为什么需要完全有所区别。</p><p> Returning to our earlier metaphor for a queue—a long tube into which we roll messages written on a ball—we probably imagined the tube to be just a little wider than a single ball. There&#39;s really no way the balls could overtake or pass each other inside the tube, so the only way a receiver could get these messages out is one-by-one, in the order they were put in. This guarantees strict ordering, but places strong limitations on our receiver. There can  only be one  agent on the receiver side that&#39;s processing each message—if there was more than one, there would be no guarantee that the messages were processed in order. Because each new agent could processes each message independently, they could each finish and start on the next message at any time. If the are two agents, A &amp; B, and Agent A receives the first message and Agent B the second; Agent B could finish processing the second message and start on the third message even before Agent A is finished processing the first message. Though the messages were  received from the queue strictly in the order that they were put in, if there are multiple receiving agents there’s no way to say the messages will  be processed in that order.</p><p> 回到我们较早的隐喻队列（长的管子，我们将写在球上的消息滚动到其中），我们可能想象管子比单个球要宽一点。实际上，球不可能在管内相互超越或通过，因此接收者发出这些消息的唯一方法是按照放入的顺序一个接一个地发送消息。这确保了严格的排序，但对我们的接收器有严格的限制。接收方只能有一个处理每个消息的代理，如果有一个以上，则不能保证消息是按顺序处理的。因为每个新代理都可以独立处理每个消息，所以它们可以随时完成并从下一条消息开始。如果是两个代理，则A＆amp;A。 B，并且代理A接收第一条消息，代理B接收第二条消息；甚至在代理A完成处理第一条消息之前，代理B即可完成第二条消息的处理并从第三条消息开始。尽管严格按照发送顺序从队列中接收消息，但是如果有多个接收代理，则无法说出消息将按照该顺序进行处理。</p><p> The agents could use a  distributed  lock of some kind to co-ordinate with each other, but this is basically the same as having only one agent—the lock would only allow one agent to work at any given time. This also means that one agent crashing would result in a  deadlock with no work being done.</p><p> 代理可以使用某种分布式锁相互协调，但这基本上与只有一个代理相同-该锁将只允许一个代理在任何给定时间工作。这也意味着一个代理崩溃将导致死锁，而无需完成任何工作。 </p><p> One way for the messaging system to guarantee order would be for the tube to refuse to give out the next ball until and unless the last ball that was received has been destroyed (the last message has been deleted/acknowledged). This is what FIFO queues in general will do—they&#39;ll provide the next message only after the last one has been acknowledged or deleted—but this means that only one agent can possibly be working at a time, even if there are  N agents waiting to receive messages from the queue.</p><p>消息传递系统保证命令的一种方式是，试管拒绝发出下一个球，直到并且除非接收到的最后一个球被破坏（最后一条消息已被删除/确认）为止。这通常是FIFO队列会做的-只有在确认或删除了最后一个消息后，它们才会提供下一条消息-但这意味着即使只有N个代理，一次也可能只能工作。代理等待从队列中接收消息。</p><p> Sometimes, this is exactly what we want. Some operations are easier to control effectively when we only have to deal with a single agent, like enforcing rules on financial transactions; respecting  rate limits; or generally processing messages whose formats have been designed assuming they would always be processed in order. But a lot of these “benefits” are not really coming from the decision to use FIFO ordering—any scenario where we have  N receivers that must somehow co-ordinate their work with each other will benefit from the special case of  N = 1. The key takeaway is that requiring a guaranteed order means we have to processes messages sequentially on only one receiver at a time.</p><p> 有时，这正是我们想要的。当我们只需要与单个代理人打交道时，某些操作就更易于有效控制，例如对金融交易执行规则；遵守速率限制；或通常假设将始终按顺序处理其格式已设计好的消息。但是，这些“好处”中的许多并非真正来自决定使用FIFO排序的情况-在任何情况下，如果我们有N个接收器，它们必须以某种方式彼此协调工作，则将受益于N = 1的特殊情况。关键的一点是，要求有保证的顺序意味着我们必须一次只在一个接收器上顺序处理消息。</p><p> This restriction also places severe pressure on the queuing system, so you&#39;ll find that FIFO queues are often more expensive and have less capacity than their parallel counterparts. This is because the same logical limits apply to the internal implementa</p><p> 这种限制也给排队系统带来了巨大压力，因此您会发现FIFO队列通常比并行队列更昂贵且容量更少。这是因为相同的逻辑限制适用于内部实现</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://sudhir.io/the-big-little-guide-to-message-queues/">https://sudhir.io/the-big-little-guide-to-message-queues/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/消息/">#消息</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/guide/">#guide</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/系统/">#系统</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>