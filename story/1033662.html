<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么输入Erlang很难：标准Erlang</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">为什么输入Erlang很难：标准Erlang</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-07 14:13:56</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/76fee038427af967d4a62ff40c6ab0a4.png"><img src="http://img2.diglog.com/img/2020/11/76fee038427af967d4a62ff40c6ab0a4.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>我之前听说过Erlang和BEAM没有打包静态类型系统，因为他们的创建者“无法构建它”。</p><p>虽然构建一个复杂、可靠和可伸缩的类型检查器绝对不是在公园里散步，但构建一个工作正常的类型检查器并不难。</p><p>如果这是可以做到的，它就会被完成，而且它会通过与OTP强化相同的过程来强化，并变成今天的样子：可靠性黄金标准。</p><p>因此，我决定编写一个Erlang类型检查器来真正理解输入Erlang的困难之处。我知道透析器的存在，这太棒了，我只是想从零开始对它有一个更好的理解。</p><p>我突然意识到，这里有一个分裂，有时很难注意到，这让世界变得截然不同。有一种名为Standard Erlang的Erlang语言，还有一种Erlang运行时，即BEAM。沿着相同的路线，首先是Java语言，然后是JVM。</p><p>我们倾向于把这两件事当作一件事来谈论，但是如果我们把语言从运行时中分离出来，我们会发现它们表现出非常不同的行为。</p><p>特别是，运行库给表分配和热代码加载带来了麻烦，这使得输入内容成为分布式系统的问题。是的，很有趣，但非常不切实际。</p><p>在接下来的文章中，我将对该语言的操作语义、如何实现您自己的类型检查器、运行库的分布式和动态特性以及它们如何相互交互做一个更全面、更正式的论述。</p><p>在这里，我将回顾一下我所学到的用更表面的方式输入Standard Erlang所需的知识，以及我们将会遇到的一些棘手的部分。</p><p>Erlang是一种动态的强类型语言。它只比典型的函数式编程语言多了一点内容。总体而言，Erlang不是那么大的语言。</p><p>我的粗略估计是它大约是OCaml的三分之一大小，大约是Java的五分之一大小。</p><p>%an Erlang模块-模块(HELLO_WORLD).-EXPORT([hi/1])。%&lt；--这是一个编译器注释hi(Noone)-&gt；ad；hi(Name)-&gt；&lt；&#34；Hello，&#34；，(Name)/inary，&#34；！&#34；&gt；&gt；。</p><p>一个Erlang程序由许多模块组成，每个模块只是一个文件，其中包含一系列函数和一些注释，这些注释用于告诉编译器导出了什么、模块作者是谁、函数类型应该是什么等等。</p><p>在Erlang中可以编写很多相对常见的内容：</p><p>还有一些事情根本就不常见：</p><p>但总的来说，语言的表现力来自于它相当简单。大多数问题都是通过使函数相互调用来解决的，大多数函数模式与它们需要的数据完全匹配，循环是通过递归实现的，然后我们就完成了。</p><p>异常非常常见，因为模式匹配失败将导致异常。为此，该语言支持CATCH和Try..Catch..After表达式，但是使用它们是非常简单的。</p><p>Erlang以监控而闻名的卓越正常运行时间实际上包含在运行时中，而不是语言中。语言本身没有进程、链接或发送消息的概念。它唯一拥有的就是用于消费消息的ReceiveExpression。</p><p>在编写类型检查器的过程中，我发现了一些值得提出来的事情：</p><p>可能还有其他语言结构对静态分析不友好。以后我会试着写更多的文章和报道更多的内容。</p><p>一个Erlang值可以有一个类型，但我们希望该类型只在运行时才知道。这意味着在我们运行函数之前，函数的输入类型和返回类型实际上都是未知的。</p><p>因此，无论何时您看到类似于上述hi/1的函数，调用它实际上都可能返回不同类型的值，这取决于函数是如何编写的。</p><p>例如，呼叫hi(Noone)将返回原子悲伤。相反，调用hi(&lt；&lt；&34；&gt；&gt；)会返回字符串&lt；&lt；&34；Hello，Joe！&gt；。原子Sad和弦有不同的类型。调用hi(0)将导致异常。</p><p>如果我们要写下这个函数的类型，我们必须这样写：</p><p>这在所有其他动态语言中都存在：LISP、Lua、Javascript、Python、Ruby、Smalltalk，应有尽有。</p><p>编写一个处理这个问题的类型检查器当然是可能的，就像以前在Flow和TypeScrip这样的工具中做过的那样，但是如何做当然不是很明显。</p><p>为了更好地理解如何处理这个问题，我们需要谈谈UnionTypes。</p><p>联合类型允许我们表示一个值可以同时属于多个不同类型中的一个。例如，1是一个数字，但它也是一个(数字|bool)。同样，True是bool，但它也是(number|bool)。</p><p>这里的关键是，值本身并没有关于它实际属于联合的类型的显式信息，我们一定会通过改进来发现这一点。</p><p>通过使用守卫和模式匹配，我们可以通过两种方式进行这些细化。</p><p>通过使用保护，我们可以将值的实际类型细化为单一类型。例如：</p><p>%the臭名昭著的Left_Pad函数Left_Pad(A，B)When is_Binary(A)-&gt；&lt；(A)/Binary，(B)/Binary&gt；&gt；；Left_Pad(A，B)When is_Number(A)-&gt；Left_Pad(Binary：Copy(&lt；&lt；&#34；&#34；&&gt;；&&gt;；A)，B)。</p><p>但多亏了IS_BINARY/1和IS_NUMBER/1保护，我们才能将输入类型细化为字符串或数字。</p><p>这使得可以说BINARY：COPY(&lt；&lt；&#34；&gt；&gt；，A)是安全的，因为在这一点上我们知道is_number(A)是真的，因此A的类型已经从字符串|Number改进为只有Number。否则守卫就会是假的。</p><p>然而，我们不能使用任何功能作为警卫。我们只能使用Erlang运行时附带的内置函数。</p><p>通过模式匹配，我们可以做一些非常相似的事情，并建立我们对价值观的期望。例如：</p><p>%a旧的列表长度计数(A=[_|_])-&gt；count(A，0).count([]，C)-&gt；C；count([_|T]，C)-&gt；count(T，C+1)。</p><p>在这种情况下，我们可以保证，如果我们的函数模式匹配，那么它将是一个列表。</p><p>我们真的不知道List元素是什么，但我们当然可以尝试继续模式匹配和使用保护，直到我们对其进行“足够”的提炼。</p><p>这两种方法虽然可以组合在一起，但它们有一个不幸的特性，它们不能推广到所有类型的数据。尽管如此，它们应该能够很好地工作：原子、文字，以及任何有警卫可用的东西。</p><p>地图、元组和记录可以使用它，但是它的伸缩性不是很好。实际上，每次需要支持新的地图/元组/记录名称时，都必须将其添加到联合中。即使你只需要他们中的一个领域。</p><p>在下一节中，我们将看到一种处理这些数据的不同方法，这种方法的可扩展性要好得多。</p><p>在使用将多个值打包为一个值的函数(与记录、映射或元组绑定)作为输入时，我们面临着一个不同的问题：只要输入类型中包含我们需要的内容，我们就不关心输入类型是什么。</p><p>例如，如果我们有两个共享某些东西的可能地图，它们都可以被认为是各自独立的类型，而这两种类型会有一些共同之处。</p><p>%This的类型为&#39；Character&#39；Character=#{Name=&&gt;；&34；Alexander Hamilton&#34；，Play=&&gt;34；Hamilton&#34；}。%This的类型为&#39；Performer&#39；Performer=#{Name=&&gt;；&#34；Lin-Manuel Miranda&#34；}。</p><p>事实上，我想说它对于任何映射都可以很好地工作，只要它有一个字符串的命名键。</p><p>所以我们的函数类型不完全是(Character|Performer)。它实际上是“任何地图，只要它有一个名称键是一个字符串”。为此，我将使用此符号：#{name}。</p><p>一些类型系统通过结构子类型来支持这一点，而另一些类型系统则使用行多态性。主要区别在这个getter函数中并不明显，但在下一个函数setter中变得很明显：</p><p>结构子类型化方法会说，无论您放入什么，现在都知道它只有一个名称键。因此，您的所有其他键都消失了(在类型系统的眼中)，如果您想恢复它们，就必须进行某种强制转换。这要归因于一种称为包容的子类型行为，以及TypeScrip处理这一问题的方式。</p><p>行多态方法没有信息丢失，而是携带M拥有的其余字段。这就是OCaml和PureScripths.com如何处理这个问题。在PureScript中，这适用于记录类型，而在OCaml中，这适用于面向对象系统。</p><p>这两种方法中的任何一种都适用于使用输入元组、记录或映射的所有字段的情况。</p><p>这比#1更容易处理，因为现在我们有了更多的信息来知道值的实际类型：标记。</p><p>%我们工作函数的类型(ATOM(&#34；OK&#34；)|ATOM(&#34；NOT_OK&34；))-&gt；{ATOM(&#34；OK&#34；)，ATOM(&#34；成功&#34；)}|{ATOM(&#34；错误&#34；)，字符串}。</p><p>它现在在四元组的左侧有这些常量值(ok，error)，我们可以用它来进一步缩小预期类型的范围。</p><p>这是Erlang生态系统中的一种成熟模式，大多数可能失败的函数都会返回带有ok或error标签的结果元组。</p><p>公平地说，这仍然存在#1的问题。我们可以创建一个函数，返回一个ok标记的值，该值也是类型的无标记联合。</p><p>%a我们工作功能的更复杂版本work(Ok)-&gt；{ok，go_on}；work(Done)-&gt；{ok，&lt；&gt；&#34；伟大的工作！&#34；&gt；&gt；}；work(Not_Ok)-&gt；{错误，&lt；&34；出现问题&#34；&gt；&gt；}。</p><p>%我们将忽略In类型，因为我们将重点放在输出类型(In)-&gt；{ATOM(&#34；OK&#34；)，ATOM(&#34；GO_ON&#34；)|STRING}|{ATOM(&#34；Error&#34；)，STRING}。</p><p>如果您得到的是{ok，value}，则键入value的问题与我们上面讨论的完全相同。</p><p>但是，此模式有助于我们输入内容，因为我们始终可以一直向下标记数据：</p><p>%与上一个工作函数相同，但带有标签！Work(Ok)-&gt；{ok，go_on}；Work(Done)-&gt；{ok，{Message，&lt；&lt；&#34；Good Job！&#34；&gt；&&gt;；}；Work(Not_OK)-&gt；{错误，&lt；&lt；&#34；&&gt;出现问题。</p><p>这有点繁琐，但也更易于进行类型检查，因为类型检查器可以将特定的标记与特定的类型相关联。</p><p>语言中存在一种不对称性：在语言层面上，我们只能接收信息。没有用于发送消息的特殊构造。要发送消息，我们只需使用Erlang：Send/2函数或其操作员版本！</p><p>因此，在任何函数中，当我们遇到接收表达式时，我们实际上是在说两件事：</p><p>下面是辅助输入--这个函数将接收一个不是直接参数的值，它可以像使用一个参数一样使用它。</p><p>如果有超时(后面的部分)，那么也有一个截止日期。从字面上讲，因为如果这是一个进程，它就会被扼杀。</p><p>我们现在不会太在意截止日期，但我们会看看我们收到的这些信息。以下是此表达式的一个示例：</p><p>我们对刚刚发生的模式匹配非常感兴趣，因为模式匹配本质上告诉我们可以接收什么消息。</p><p>如此之多，以至于我们可以将这个RECEIVE表达式看作是内置于语言中的一个函数，我们可以用自己的函数来调用它。</p><p>%将RECEIVE转换为函数调用器()-&gt；Receive{X，Y}-&gt；X+Y End。Adder()-&gt；Receive(Fun({X，Y})-&gt；X+Y End)。</p><p>现在我们可以用分析上面的点1、点2和点3的相同方式来分析这个内部函数。</p><p>如果我们使用加法器/0来启动进程，那么重新构造接收表达式实际上是让类型检查器能够理解进程可以接收到什么消息的关键。</p><p>另一个完全不同的地方是语言的动态部分，它允许我们在运行时通过特殊的语法来决定要运行什么代码。</p><p>Erlang支持完全动态地指定要在该模块中调用的模块和函数。</p><p>%M是我们的模块名称em=Hello。%F是我们的函数名称F=world。M：F()=：=Hello：world()。</p><p>但是，如果我们不准确跟踪M和F的值，我们怎么知道M：F()在这里会是什么类型呢？</p><p>我们必须计算M以获取实际的模块名称，并计算FT值以了解要查找的函数，然后查找该函数的实际类型。</p><p>如果M比上例中的变量绑定稍微复杂一些，我们可能无法知道它是什么。想象一下下面的场景：</p><p>%当IS_ATOM(名称)-&gt；名称结束时，我们将以MessageM=接收名称的形式接收模块名称。M：Run()。</p><p>我们需要等待收到消息后才能知道要查找哪个模块。这是不可信的，因为我们甚至不知道是谁在发送信息，也不知道信息是否会被发送。</p><p>当然，现实世界中的Erlang倾向于依靠行为来确保某些类型存在，因此注释预期的模块行为可能会有所帮助：</p><p>%同上，但类型-注解M：Runnable Behavior=Receive Name When is_atom(Name)-&gt；name end.M：run()。</p><p>这样，我们就能够分析这一点，并知道Run应该具有什么类型，或者立即抱怨Run实际上没有在该行为中实现，因此不能保证存在。</p><p>我希望我今天讨论的这几件事能让您了解输入Erlang语言的困难之处。这并不是不可能的，事实上，有些部分的打字相当简单，但它肯定有一些棘手的部分，我们应该小心处理。</p><p>在未来，我将写更多关于语言类型的内容，特别是像二进制字符串模式匹配这样的部分，以及运行库及其属性，例如热代码重载、确定进程类型以及如何检查类型安全的消息传递。</p><p>感谢Pontus Nagy、Manuel Rubio、Malcolm Matalka和Calin Capitanu抽出时间审阅本文的早期草稿。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://abstractmachines.dev/posts/am012-why-typing-erlang-is-hard.html">https://abstractmachines.dev/posts/am012-why-typing-erlang-is-hard.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/erlang/">#erlang</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1026706.html"><img src="http://img2.diglog.com/img/2020/9/thumb_072fe64d96ccbcb5b3247d6ba8fa20d4.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1026706.html">焦糖：OCaml的二郎后端</a></div><span class="my_story_list_date">2020-9-27 18:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1022486.html"><img src="http://img2.diglog.com/img/2020/9/thumb_f60f9f7f1e8283ef7b2e52a513e4099f.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1022486.html">长生不老药是二郎药，不是红宝石</a></div><span class="my_story_list_date">2020-9-7 8:59</span></div><div class="col-sm"><div><a target="_blank" href="/story/1019097.html"><img src="http://img.diglog.com/img/2020/8/thumb_6712fd6a82e5274a74ea326df7dd1044.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1019097.html">原子VM：微控制器上的Erlang</a></div><span class="my_story_list_date">2020-8-19 20:52</span></div><div class="col-sm"><div><a target="_blank" href="/story/1012169.html"><img src="http://img.diglog.com/img/2020/7/thumb_24545080258153d8e37a2016fa97a988.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1012169.html">与二郎共事十年的教训(2018年)</a></div><span class="my_story_list_date">2020-7-16 6:25</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>