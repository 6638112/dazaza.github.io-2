<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>数学不断变化 Math Keeps Changing</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Math Keeps Changing<br/>数学不断变化 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-04 20:46:03</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/190d960088f54337f8223d24d656cf75.jpg"><img src="http://img2.diglog.com/img/2020/12/190d960088f54337f8223d24d656cf75.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This is a written version of a talk that I gave at  WaffleJS in February, which itself was an expansion of a  Twitter conversation from October.</p><p>这是我2月在WaffleJS上发表的演讲的书面版本，它本身是10月以来Twitter对话的扩展。</p><p>  Okay, so it starts with my delayed math education. As part of my Computer Science program, I had access to world-class math professors, access that I mostly wasted. I didn’t like math: the topics were so removed from practice, and I was already frustrated by the highly theoretical, and – I thought at the time and mostly still do – out-of-touch CS program.</p><p>  好的，所以从我延迟的数学教育开始。作为我的计算机科学计划的一部分，我可以与世界一流的数学教授接触，而我最浪费的是接触。我不喜欢数学：将话题从实践中删除，并且我已经对理论性过高感到沮丧，而且-我当时以为并且大部分时间仍然如此-脱节的CS程序。</p><p> Unfortunately, a few years after graduating, I got the hunger for math. Seeing how I could apply just a little bit of math knowledge to great effect in my work &amp; hobbies had me inspired. But I had no clear way of learning it.</p><p> 不幸的是，毕业几年后，我对数学产生了渴望。看到我如何才能将一点点数学知识应用到我的工作中爱好使我受到启发。但是我没有明确的学习方法。</p><p> So I  started Simple Statistics in 2012 as a way to learn math, and ever since then, I’ve expanded and maintained the project. It now includes a lot of different algorithms, is one of the most ‘starred’ JavaScript math projects, and presumably is used by people.</p><p> 因此，我从2012年开始从事简单统计的学习，从那时起，我就扩展并维护了该项目。现在，它包含许多不同的算法，是最受好评的JavaScript数学项目之一，并且可能被人们使用。</p><p> But I started it in 2012. In tech years that’s a really long time ago. Between then and now, there have been 8 LTS releases of  Node. JavaScript and its environments have radically changed. 2012 was before the introduction of React or the first commit to Babel.</p><p> 但是我是从2012年开始的。在很久以前的技术时代。从那时到现在，已经有8个LTS版本的Node。 JavaScript及其环境已经发生了根本性的变化。 2012年是在引入React或Babel的第一次承诺之前。</p><p>  So what I noticed over the years was that tests kept breaking when I updated Node. I’d have a test like:</p><p>  因此，我多年来注意到的是，当我更新Node时，测试一直在中断。我会进行类似的测试：</p><p>  That would work in Node v10 and break in Node v12. And this is not some complex method: gamma is implemented with arithmetic, Math.pow, Math.sqrt, and Math.sin.</p><p>  那将在Node v10中工作，而在Node v12中中断。这不是什么复杂的方法：gamma是通过算术，Math.pow，Math.sqrt和Math.sin实现的。 </p><p>  So I know what you might be thinking: arithmetic. JavaScript, on Twitter, gets a lot of heat for this behavior:</p><p>所以我知道您可能在想什么：算术。 Twitter上的JavaScript为此行为引起了很多关注：</p><p>  As I wrote in  JavaScript wats, dissected, this is the behavior of every popular programming language, even stodgy pedantic ones like Haskell. Floating point arithmetic might be weird, but it’s very consistent and well-specified: the  IEEE 754 specification is rigorously implemented. So it’s not arithmetic: addition, subtraction, division, and multiplication are pretty set in stone.</p><p>  正如我在剖析的JavaScript故事中所写的那样，这是每种流行编程语言的行为，甚至是像Haskell这样笨拙的学究语言。浮点算法可能很奇怪，但是它非常一致且规格明确：IEEE 754规范得到严格实施。因此，这不是算术运算：加法，减法，除法和乘法是一成不变的。</p><p>  What it was, was Math. In particular, all of  the methods that come after  Math.</p><p>  那是数学。特别是Math之后的所有方法。</p><p> Methods like Math.sin, Math.cos, Math.exp, Math.pow, Math.tan:  essential ingredients for geometry and basic computation. I started isolating changes in basic function behavior between versions. For example:</p><p> 诸如Math.sin，Math.cos，Math.exp，Math.pow，Math.tan之类的方法：几何和基本计算的基本要素。我开始隔离版本之间基本功能行为的更改。例如：</p><p>     To make matters worse, it’s not just Node’s behavior that’s changing: so are browsers and other places you use JavaScript.</p><p>     更糟糕的是，不仅仅是Node的行为正在改变：浏览器和其他使用JavaScript的地方也在改变。</p><p>            Trigonometry methods are easy to  show: given a unit circle and a few months of high school, you know that cosine and sine will get you coordinates on the rim, and that they’ll draw little squigglies if plotted on X &amp; Y. Actually  deriving those methods is what you’ll learn in advanced classes, but the method that you use - the  Taylor series - relies on an  infinite series, which would be rather laborious for a computer to solve.</p><p>            三角法很容易显示：给定一个单位圆和几个月的高中学习，您知道余弦和正弦将使您在边缘上保持坐标，并且如果在X＆amp; amp;上绘制，它们将很少弯曲。是的。实际上，这些方法是您在高级课程中会学到的，但是您使用的方法-泰勒级数-依赖于无限级数，这对于计算机求解来说非常费力。</p><p> “There is no standard algorithm for calculating sine. IEEE 754-2008, the most widely used standard for floating-point computation, does not address calculating trigonometric functions such as sine.”</p><p> “没有用于计算正弦的标准算法。 IEEE 754-2008是浮点计算使用最广泛的标准，没有解决计算正弦等三角函数的问题。” </p><p>  Computers use a variety of different estimations and algorithms to do math, things like  CORDIC and various cheating algorithms and lookup tables. This heterogeny explains all of the  ‘fastmath’ libraries you can find on GitHub: there’s more than one way to implement Math.sin. Famously, Quake III Arena used a  faster replacement for the inverse square root method in order to speed up rendering.</p><p>计算机使用各种不同的估计和算法进行数学运算，例如CORDIC和各种作弊算法和查找表。这个异类解释了您可以在GitHub上找到的所有“ fastmath”库：实现Math.sin的方法不止一种。著名的Quake III Arena使用更快的替代平方根倒数方法来加快渲染速度。</p><p> So math is implemented as algorithms, and there are multiple common algorithms – and variations of those algorithms – used in practice.</p><p> 因此数学是作为算法实现的，实践中有多种常见算法-以及这些算法的变体。</p><p> Instead of telling implementations to pick an algorithm, the JavaScript specification grants them a  lot of wiggle room in terms of how they implement these basic functions.</p><p> JavaScript规范没有告诉实现选择算法，而是在如何实现这些基本功能方面给了他们很大的回旋余地。</p><p> The behaviour of the functions acos, acosh, asin, asinh, atan, atanh, atan2, cbrt, cos, cosh, exp, expm1, hypot, log,log1p, log2, log10, pow, random, sin, sinh, sqrt, tan, and tanh is not precisely specified here except to require specific results for certain argument values that represent boundary cases of interest.</p><p> 函数acos，acosh，asin，asinh，atan，atanh，atan2，cbrt，cos，cosh，exp，expm1，hypot，log，log1p，log2，log10，pow，pow，random，sin，sinh，sqrt，tan的行为和tanh在此处未明确指定，只是要求某些表示感兴趣边界情况的参数值需要特定结果。</p><p>  I don’t know the inner workings of the standards committees, but I imagine they wanted to make sure that just in case Intel or AMD introduce super-fast new math instructions in a new processor, JavaScript wouldn’t have a compatibility crisis.</p><p>  我不知道标准委员会的内部运作方式，但我想他们想确保万一Intel或AMD在新处理器中引入超快速新数学指令时，JavaScript不会出现兼容性危机。</p><p> Because there are a lot of JavaScript interpreters that are commonly used, because JavaScript is often used via web browsers and there still is some competition between web browsers, and because even popular JavaScript implementations are under pressure to evolve quickly to be the most performant… because of all that, this matters. You actually will encounter, on a regular basis, differences in math.</p><p> 因为有很多常用的JavaScript解释器，所以JavaScript通常是通过Web浏览器使用的，并且Web浏览器之间仍然存在一些竞争，并且因为甚至流行的JavaScript实现也面临着迅速发展成为性能最高的压力...最重要的是，这很重要。实际上，您会定期遇到数学上的差异。</p><p> This doesn’t matter as much in other interpreted languages, because they tend to have ‘canonical’ interpreters: most of the time you use the Python interpreter of the Python language.</p><p> 在其他解释语言中，这无关紧要，因为它们倾向于具有“规范”解释器：大多数情况下，您使用Python语言的Python解释器。 </p><p>  Next let’s zoom into  where these math implementations live. See, in JavaScript, there are three places where basic math can happen:</p><p>接下来，让我们放大这些数学实现的实现位置。在JavaScript中，可以在三个地方发生基本数学运算：</p><p>   This was my first guess: I assumed that since CPUs implement arithmetic, they might implement some higher-level math. It turns out that CPUs do have instructions to do trigonometry and other operations, but they’re rarely invoked. The CPU (x86) implementation of sine doesn’t get much love because it’s not reliably faster than an implementation in software (using arithmetic operations on the CPU), nor as accurate.</p><p>   这是我的第一个猜测：我假设由于CPU执行算术运算，因此它们可能会执行一些高级数学运算。事实证明，CPU确实具有执行三角函数和其他运算的指令，但很少被调用。正弦的CPU（x86）实施并没有引起人们的广泛关注，因为它不可靠地快于软件中的实施（使用CPU上的算术运算），也不准确。</p><p> Intel also bears some blame for  overstating the accuracy of their trigonometric operations by many magnitudes. That kind of mistake is especially tragic because, unlike software, you can’t patch chips.</p><p> 英特尔还因将三角运算的准确性高估了许多程度而受到指责。这种错误特别悲惨，因为与软件不同，您无法修补芯片。</p><p>  This is how most of the implementations do it, and they implement math in a variety of ways.</p><p>  这是大多数实现的方式，并且它们以多种方式实现数学。</p><p> V8 &amp; SpiderMonkey use (slightly different) ports of the  fdlibm library for most operations. It has been passed down through the generations, originally written at Sun Microsystems.</p><p> V8和对于大多数操作，SpiderMonkey使用fdlibm库的端口（略有不同）。它经过了几代人的传承，最初是由Sun Microsystems编写的。</p><p>  Internet Explorer used some cmath, but  also used some assembly instructions and actually  did use CPU-provided trig methods when it was compiled for CPUs that had them.</p><p>  Internet Explorer使用了一些cmath，但是也使用了一些汇编指令，并且在为具有它们的CPU进行编译时，实际上确实使用了CPU提供的trig方法。</p><p> Historically, all of these implementations have shifted: V8 used to use a homegrown solution for math, and then used  a port of fdlibm to JavaScript, before finally settling on fdlibm in C.</p><p> 从历史上看，所有这些实现都发生了变化：V8曾经使用本地开发的数学解决方案，然后使用fdlibm到JavaScript的移植，最后才决定使用C的fdlibm。 </p><p>  Here’s why this is a problem: it chips away at JavaScript’s ability to give consistent results to any problem including mathematics. And that especially hits  data science. I want JavaScript to be a contender for data science in the browser, and – amongst some other issues, like number types and a confounding lack of a commonly-used data-frames library – an inability to produce replicable results means adding more crisis to the  replication crisis in the sciences.</p><p>这就是问题所在的原因：它使JavaScript不能为包括数学在内的任何问题提供一致的结果，而使这种能力无法实现。尤其是数据科学。我希望JavaScript成为浏览器中数据科学的竞争者，并且-在其他一些问题中（例如数字类型和普遍使用的数据框架库的混乱缺乏）-无法产生可复制的结果意味着给应用程序带来更多危机科学中的复制危机。</p><p>  There is a way out that we can use today.  stdlib is a JavaScript library that reimplements higher-level math using arithmetic alone. Arithmetic is fully-specified and standard, so the results that stdlib gives you are also fully consistent, across all the platforms.</p><p>  今天我们可以使用一种出路。 stdlib是一个JavaScript库，仅使用算术即可重新实现更高级的数学。算术是完全指定的和标准的，因此stdlib为您提供的结果在所有平台上也完全一致。</p><p> This comes at the cost of complexity and speed: stdlib isn’t consistently as fast as built-in methods, and you’ll need to require a library ‘just’ to compute sine.</p><p> 这是以复杂性和速度为代价的：stdlib的速度不如内置方法那么快，并且您需要“仅”一个库来计算正弦。</p><p> But in the wider view, this is pretty normal! WebAssembly, for example, doesn’t give you higher-level math methods at all and recommends you include a math implementation in your modules themselves:</p><p> 但是从更广泛的角度来看，这很正常！例如，WebAssembly根本不提供高级数学方法，建议您在模块本身中包含数学实现：</p><p> “WebAssembly doesn’t include its own math functions like sin, cos, exp, pow, and so on. WebAssembly’s strategy for such functions is to allow them to be implemented as library routines in WebAssembly itself (note that x86’s sin and cos instructions are slow and imprecise and are generally avoided these days anyway).”</p><p> “ WebAssembly不包含自己的数学函数，例如sin，cos，exp，pow等。 WebAssembly针对此类功能的策略是允许将它们作为WebAssembly本身的库例程来实现（请注意，x86的sin和cos指令缓慢且不精确，如今无论如何通常都避免使用它们。）</p><p> And this is the way that compiled languages have always worked: when you compile a C program, the methods you import from  math.h are included in the compiled binary.</p><p> 这就是编译语言一直有效的方式：当编译C程序时，从math.h导入的方法将包含在已编译的二进制文件中。</p><p>  If you don’t want to include stdlib to do math but you do want to test math-heavy code, you’ll probably have to do what simple-statistics does right now: use an epsilon. Of the  5+ uses of epsilon in math, the one I’m referring to is “an arbitrarily small positive quantity”. It’s a tiny number. Here’s  simple-statistics’s implementation: the number 0.0001.</p><p>  如果您不想包括stdlib来进行数学运算，但又想测试大量数学代码，则可能必须要做简单统计现在所要做的：使用epsilon。在数学中使用epsilon的5种以上方法中，我指的是“任意小的正数”。这是一个很小的数字。这是简单统计信息的实现：数字0.0001。 </p><p> You then compare  Math.abs(result - expected) &lt; epsilon to make sure you got within range of the desired value, with a little bit of wiggle room.</p><p>然后，您比较Math.abs（结果-预期）＆lt; epsilon，以确保您在期望值的范围内，并有一点摆动空间。</p><p>  Here’s where I was a little short on time in person and have some room to expand.</p><p>  在这里，我本人的时间有些紧缺，还有一定的扩展空间。</p><p> First, what’s under the hood is rarely what you expect. Our current tech stack is heavily optimized and a lot of optimizations are really just dirty tricks. For example, the number of hardware instructions it takes to solve  Math.sin varies based on the input, because there are lots of special cases. When you get to more complex cases, like ‘sorting an array’, there are often multiple algorithms that the interpreter chooses between in order to give you your final result. Basically, the cost of anything you do in an interpreted language is variable.</p><p> 首先，幕后的东西很少是您所期望的。我们当前的技术堆栈已进行了高度优化，许多优化实际上只是肮脏的把戏。例如，解决Math.sin所需的硬件指令数量因输入而异，因为有很多特殊情况。当您遇到更复杂的情况时，例如“对数组进行排序”，解释器通常会选择多种算法，以便为您提供最终结果。基本上，使用解释语言进行的任何操作的成本都是可变的。</p><p> Second, don’t trust the system too much. What I was seeing between Node versions really  should have been a bug in the testing library, or something in my code, or maybe in simple-statistics itself. But in this case, digging deeper revealed that what I was seeing was exactly what you don’t expect: a glitch in the language itself.</p><p> 其次，不要太信任系统。我在Node版本之间看到的确实应该是测试库中的错误，代码中的错误或简单统计信息本身。但是在这种情况下，更深入的研究表明，我所看到的正是您所期望的：语言本身的故障。</p><p> Third, everyone’s winging it. Reading through the V8 implementation gives you a deep appreciation of the genius involved in implementing interpreters, but also an appreciation that it’s just humans doing the implementation: they make mistakes, and, as evidenced by the constantly-changing algorithms for mathematics, always have room to improve.</p><p> 第三，每个人都在努力。通过阅读V8实现，您可以深刻理解实现解释器所涉及的天才，但是也可以理解，这只是人类在执行实现：他们犯错，并且，正如不断变化的数学算法所证明的那样，总是有空间改善。</p><p>   Precision: Commentators on Twitter have pointed out that the variation in example results is outside the  significant digits of floating point. This is technically correct, and means that you could potentially come up with a slightly more precise way to compare them than using an epsilon. But practically it’s the same story – the trailing digits will propagate into results and create real-world discrepencies. Additionally, the examples I gave aren’t exhaustive: JavaScript interpreters can, without cheating the specification, introduce numerical differences in the significant portion of a result.</p><p>   精度：Twitter上的评论员指出，示例结果的变化超出了浮点数的有效位数。从技术上讲，这是正确的，这意味着您可能会比使用epsilon提出更精确的比较方法。但实际上是同一回事–尾随数字会传播到结果中并造成实际差异。此外，我给出的示例并不详尽：JavaScript解释器可以在不欺骗规范的情况下，在结果的重要部分引入数值差异。</p><p> JavaScript: This isn’t a critique of JavaScript. I think that the language made an appropriate compromise in the face of an uncertain future and lots and lots of platforms. And it’s really hard to compare any other language directly to JavaScript because the JavaScript ecosystem - lots of different interpreters of the language all coexisting - is pretty darn uncommon, and it’s also one of JavaScript’s biggest strengths. Also, to be clear, that this is totally different than JavaScript-the-language changing: that’s also a thing that’s happening, and I’m pretty  excited about what’s changing in the language.</p><p> JavaScript：这不是对JavaScript的批评。我认为，面对不确定的未来和众多平台，该语言已做出适当妥协。而且，很难将其他任何语言直接与JavaScript进行比较，因为JavaScript生态系统-许多共存的语言的不同解释器-相当罕见，它也是JavaScript的最大优势之一。另外，需要明确的是，这与JavaScript语言更改完全不同：这也是正在发生的事情，我对语言的更改感到非常兴奋。 </p><p> Stdlib or an epsilon: The practical solution in most cases is using an epsilon. Stdlib is fascinating and powerful, but the cost of including an additional library for mathematics is quite high – and in many cases these small differences in output don’t matter for applications.</p><p>Stdlib或epsilon：大多数情况下的实际解决方案是使用epsilon。 Stdlib引人入胜且功能强大，但是包括一个额外的数学库的成本非常高-在许多情况下，输出中的这些细微差别对应用程序无关紧要。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数学/">#数学</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/math/">#math</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>