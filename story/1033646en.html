<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>频域图像压缩与滤波</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">频域图像压缩与滤波</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-07 11:23:58</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/ba20b2ca998cfddefca72488e5196223.png"><img src="http://img2.diglog.com/img/2020/11/ba20b2ca998cfddefca72488e5196223.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Over 4 years ago I wrote a short blog post on images in the frequency domain:  https://blog.demofox.org/2016/07/28/fourier-transform-and-inverse-of-images/</p><p>4年多前，我写了一篇关于频域图像的简短博客文章：https://blog.demofox.org/2016/07/28/fourier-transform-and-inverse-of-images/。</p><p> It’s time to revisit the topic a bit and add some more things.</p><p>现在是时候再回顾一下这个话题，并补充一些东西了。</p><p> If you are curious about how the Fourier transform works, which can transform images or other data into the frequency domain, give this a read:  https://blog.demofox.org/2016/08/11/understanding-the-discrete-fourier-transform/</p><p>如果你想知道傅里叶变换是如何工作的，它可以将图像或其他数据转换到频域，请阅读以下内容：https://blog.demofox.org/2016/08/11/understanding-the-discrete-fourier-transform/。</p><p>   When you transform an image into the frequency domain, you get a complex number (with a real and imaginary component) per pixel that you can use to get information about the frequencies (literal sine and cosine waves) that go into making the image. One piece of information is the “phase” or starting angle of that wave. You get the phase by using atan2(imaginary, real). The other piece of information is the “amplitude” of that wave, or how large the wave is in the image. The amplitude is the length of the 2d vector (real, imaginary).</p><p>当您将图像变换到频域时，您会得到每个像素的复数(具有实部和虚部)，您可以使用该复数来获取有关制作图像的频率(文字正弦波和余弦波)的信息。一条信息是该波的“相位”或起始角。您可以使用atan2(虚数，实数)来获得相位。另一条信息是该波的“振幅”，或者说该波在图像中有多大。振幅是2D向量(实数、虚数)的长度。</p><p> A quick and easy way to do image compression then, is to convert an image to frequency space, find the lowest amplitude frequencies and throw them away – literally zero out the complex number. If you throw enough of them away, it’ll take less data to describe the frequency content of an image, than the pixels of the image, and you’ll have compressed the image.</p><p>那么，进行图像压缩的一个快速而简单的方法是将图像转换到频率空间，找到最低的振幅频率，然后丢弃它们--字面意思是将复数清零。如果你丢弃了足够多的图像，那么描述图像的频率内容所需的数据就会比图像的像素少，这样你就可以压缩图像了。</p><p> The more aggressive you are at throwing away frequencies though, the more the image quality will degrade. This is “lossy” compression and is a simplified version of how jpg image compression works. Lossy compression is in contrast to lossless compression like you find in png files, which use something more like a .zip compression algorithm to perfectly encode all the source data.</p><p>不过，你在丢弃频率方面越积极，图像质量就会下降得越多。这是一种“有损”压缩，是jpg图像压缩方式的简化版本。有损压缩与PNG文件中的无损压缩形成对比，PNG文件使用更像.zip压缩算法来完美地编码所有源数据。</p><p> In the code that goes with this post, the DoTestZeroing() function throws out the lowest 10% amplitude frequencies, then the lowest 20%, then 30% and so on up to 90%. At each stage, it writes all complex frequency values out into a binary file, which can then be compressed using .zip as a method for realizing the image compression. As the data gets more zeros, it gets more compressible.</p><p>在本文附带的代码中，DoTestZeroing()函数抛出最低10%的振幅频率，然后是最低的20%，然后是30%，以此类推，直到90%。在每个阶段，它将所有复频率值写出到一个二进制文件中，然后可以使用.zip作为实现图像压缩的方法来压缩该文件。随着数据变得更多零，它变得更可压缩。</p><p> The top row in the image below shows an original 512×1024 image, the DFT amplitude information, and the DFT phase information. The bottom row shows the same, but for an image which has had it’s lower 90% amplitude frequencies thrown away. The DFT data is 8MB for both (uncompressed), and compresses to 7.7MB for the top picture, but only 847KB for the bottom picture. The inverse DFT was used to turn the modified frequency data on the bottom back into an image.</p><p>下图顶行显示了原始512×1024图像、DFT幅度信息和DFT相位信息。最下面一行显示的是相同的，但对于已经丢弃了较低90%振幅频率的图像。两者(未压缩)的DFT数据都是8MB，顶部图片压缩到7.7MB，但底部图片只压缩到847KB。利用逆DFT将修改后的底部频率数据恢复为图像。</p><p>  Here is another image which is 512×512 and has DFT which is 4MB uncompressed. The top image’s DFT data compresses to 3.83MB, while the bottom compresses to 438KB.</p><p>这是另一幅512×512的图像，其DFT是4MB未压缩的。上图的DFT数据压缩到3.83MB，下图压缩到438KB。</p><p>  While fairly effective, this is also a pretty naive way of doing frequency based image compression!</p><p>虽然相当有效，但对于基于频率的图像压缩来说，这也是一种相当幼稚的方式！</p><p> More sophisticated methods use the “Discrete Cosine Transform” or DCT instead of the DFT because it tends to make more of the frequency magnitudes zero, consolidating the data into fewer important frequencies, which means it’s already smaller before you start throwing away frequencies. DCT and DFT also pretend that the images go on forever, instead of just stopping at the edge. DFT acts as if those images repeat in a tiled fashion, while DCT acts as if they are mirrored at each repeat, which can also be a nice property for image quality.</p><p>更复杂的方法使用“离散余弦变换”或DCT而不是DFT，因为它倾向于使更多的频率幅度为零，将数据合并到较少的重要频率，这意味着在你开始丢弃频率之前，它已经很小了。DCT和DFT还假装图像永远在继续，而不是仅仅停留在边缘。DFT的作用就像是以平铺的方式重复这些图像，而DCT的作用就像它们在每次重复时都被镜像一样，这也是图像质量的一个很好的属性。</p><p> Other methods break an image up into blocks before doing frequency based compression. Also, you can use wavelets to compress images, or principle component analysis or singular value decomposition. You can also fit your image with “whatever” basis functions you want, using L1 norm regularization to promote the coefficients of your fitting to be zero, to make the fit data be less sparse, just like DCT does compared to DFT.</p><p>其他方法在进行基于频率的压缩之前将图像分解成块。此外，您还可以使用小波来压缩图像，或者使用主成分分析或奇异值分解。你也可以用你想要的“任何”基函数来拟合你的图像，使用L1范数正则化将你的拟合系数提升为零，使拟合数据不那么稀疏，就像DCT和DFT相比所做的那样。</p><p> Another thing you can do is use compressed sensing to skip a couple steps: You take a couple randomized but roughly evenly spaced samples from the image (blue noise or LDS are going to be good options here), and then you can eg find Fourier basis coefficients (DFT!) that match the sparse/irregular data samples you took. This is like throwing out low frequencies, but without having to DFT the whole data set, and then throw things out. It starts with sparse data and then fits it.</p><p>你可以做的另一件事是使用压缩传感跳过几个步骤：你从图像中取几个随机但大致均匀的样本(蓝色噪声或LD将是很好的选择)，然后你就可以例如求出傅立叶基系数(DFT！)。与你采集的稀疏/不规则数据样本相匹配。这就像扔掉低频，但不必对整个数据集进行DFT，然后再扔掉。它从稀疏数据开始，然后再进行匹配。</p><p> Bart Wronski has several write ups on his blog in this area, so give them a read if you are interested:  https://bartwronski.com/2020/08/30/compressing-pbr-texture-sets-with-sparsity-and-dictionary-learning/</p><p>巴特·沃伦斯基(Bart Wronski)在他的博客上有几篇关于这一领域的文章，如果你感兴趣，请阅读它们：https://bartwronski.com/2020/08/30/compressing-pbr-texture-sets-with-sparsity-and-dictionary-learning/。</p><p> This is a great read showing how to fit data using L1 regularization and all the related information you might be interested in:  https://www.analyticsvidhya.com/blog/2017/06/a-comprehensive-guide-for-linear-ridge-and-lasso-regression/</p><p>这是一本很棒的读物，展示了如何使用L1正则化来拟合数据，以及您可能感兴趣的所有相关信息：https://www.analyticsvidhya.com/blog/2017/06/a-comprehensive-guide-for-linear-ridge-and-lasso-regression/。</p><p> This video is a great overview of the random grab bag of other things I mentioned:  https://www.youtube.com/watch?v=aHCyHbRIz44&amp;feature=youtu.be</p><p>这个视频很好地概述了我提到的其他东西的随机抓包：https://www.youtube.com/watch?v=aHCyHbRIz44&amp；feature=youtu.be</p><p>  In my previous post on this topic I showed how you could throw away frequencies that were farther than a certain distance from the center to low pass filter an image, aka blur it. I also showed how if you threw away frequencies closer than a certain distance, it would high pass filter an image, aka sharpen it.</p><p>在我上一篇关于这个主题的文章中，我展示了如何丢弃距离图像中心一定距离的频率，对图像进行低通滤波，也就是模糊图像。我还展示了，如果你扔掉比一定距离更近的频率，它会对图像进行高通滤波，也就是锐化图像。</p><p> That throwing away of frequency data based on distance is the same as multiplying the frequency data by a mask which has a 1.0 in some places and a 0.0 in others. You can generalize this to multiply frequencies by any number. In the below I restrict the multiplications to be between 0 and 1, but you could definitely go to larger numbers or even go to negative numbers if you wanted.</p><p>丢弃基于距离的频率数据等同于将频率数据乘以掩码，掩码在某些地方为1.0，在其他地方为0.0。您可以将其概括为将频率乘以任何数字。在下面我将乘法限制在0到1之间，但是如果你愿意，你绝对可以选择更大的数字，甚至是负数。</p><p> The below shows the patterns that the images are multiplied by in this section. Top row left to right is a low pass filter, then a stronger low pass filter (gets rid of more high frequencies than the other) and lastly is a notch filter or “band stop” filter. The bottom row is the complement, such that you get the bottom by subtracting the image from white (1.0). Left to right, the bottom row is a high pass filter, then a weaker high pass filter (lets more low frequencies in) and then a band pass filter which only lets certain frequencies through.</p><p>下面显示了在这一部分中图像相乘的模式。顶行从左到右是一个低通滤波器，然后是一个更强的低通滤波器(去掉了更多的高频)，最后是一个陷波滤波器或“带阻”滤波器。最下面的一行是补码，这样你就可以从白色(1.0)中减去图像得到底部。从左到右，最下面一行是一个高通滤波器，然后是一个较弱的高通滤波器(让更多的低频进入)，然后是一个只允许特定频率通过的带通滤波器。</p><p>  First up is the “Loki and Alan” picture. Frequencies and actual picture values filtered from the pictures on the top are present in the pictures on the bottom and vice versa. In this way, blurring compared to sharpening (and edge detection) are two sides of the same coin. It just matters which part you throw away and which part you keep.</p><p>首先关注的是“洛基和艾伦”的照片。从顶部的图片中过滤出的频率和实际图像值出现在底部的图片中，反之亦然。在这种情况下，模糊和锐化(和边缘检测)是一枚硬币的两面。重要的是你扔掉了哪部分，保留了哪部分。</p><p>  Here is what the frequency magnitudes look like. Note that each image has the magnitudes put through a log function, and also normalized to be 1.0 max. This is why even though the high pass filters (and band pass) darken the middle, it doesn’t seem like it. The renormalization obscures that fact a bit, and the middle is brightest (largest amplitudes) which we saw when throwing out the lowest amplitudes in the last section.</p><p>这是频率的大小看起来是什么样子。请注意，每幅图像都有经过对数函数的幅值，并且也归一化为1.0max。这就是为什么即使高通滤波器(和带通)会使中间部分变暗，但看起来并不是这样。重整化稍微掩盖了这一事实，中间是最亮的(振幅最大)，这是我们在最后一部分中抛出最低振幅时看到的。</p><p>  Here are the same filters applied to the scenery image. The top right image has some strange patterns in it if you look closely (click the image to view the full size in another tab).</p><p>以下是应用于风景图像的相同滤镜。如果你仔细观察，右上角的图片中有一些奇怪的图案(点击图片可以在另一个选项卡中查看完整尺寸)。</p><p>   In the last section, we made “images” by using a distance function, to make values to multiply the frequencies by to filter out certain frequencies.</p><p>在最后一节中，我们使用一个距离函数来制作“图像”，使值乘以特定的频率，从而滤除特定的频率。</p><p> In this section, we are going to take two images, put them into frequency space, multiply them together, take them out of frequency space, and see what kind of results come out.</p><p>在这一部分，我们将拍摄两幅图像，将它们放入频率空间，相乘，再从频率空间中取出，看看会产生什么样的结果。</p><p> There is something called the “convolution theorem” which tells us that multiplication in the frequency domain, is the same as convolution between the images. Convolution is an expensive operation, because you have to loop through all the pixels of one image, and at each pixel, loop through the pixels of the other image, and do some multiplications and additions. Convolution is so slow, that it can actually be quicker to take two images you want convolved to frequency domain, multiply them together, and then take them out of frequency space to be images again.</p><p>有一种叫做“卷积定理”的东西告诉我们，频域中的乘法与图像之间的卷积是一样的。卷积是一种昂贵的操作，因为您必须循环遍历一幅图像的所有像素，并在每个像素处循环遍历另一幅图像的像素，然后进行一些乘法和加法运算。卷积的速度非常慢，所以把你想要卷积到频域的两幅图像相乘在一起，然后把它们从频率空间中拿出来再次成为图像，实际上可能会更快。</p><p> Convolution is used in graphics for things like blurs, sharpening, or applying bokeh for depth of field, so speeding it up can be a big help! Convolution is also used in audio for things like reverberation which makes audio sound like it was played inside of a cave or a big cathedral.</p><p>卷积在图形中被用于模糊、锐化或应用bokeh来获得景深，所以加速它会有很大的帮助！卷积也被用于音频中，比如混响，它使音频听起来像是在洞穴或大教堂里播放的声音。</p><p> Technical note: the “kernel” image needs to be centered at pixel (0,0), not the center of the image. Also, the kernel image should be normalized so that summing up all of it’s pixels adds up to 1.0. You also need to zero pad (add a black pixel border to) both the source image and kernel image to be the size of source+kernel+1 on the x and y axis before DFT’ing so they are the same size, and to avoid wrapping problems. After you are done multiplying and inverse DFT’ing, you can remove the black border again.</p><p>技术说明：“内核”图片需要在像素(0，0)处居中，而不是图片的中心。另外，内核图像应该被规格化，这样它的所有像素加起来就是1.0。在进行DFT之前，您还需要将源图像和内核图像都填零(添加黑色像素边框)为x和y轴上的源+内核+1的大小，以使它们的大小相同，并避免包装问题。在完成乘法和逆DFT后，可以再次移除黑色边框。</p><p> Here are the 4 images we are going to use as kernel images: A star, a plus, a circle, and a blob.</p><p>以下是我们将用作内核图像的4个图像：一个星星、一个加号、一个圆圈和一个斑点。</p><p>      You can see that the images somehow take on the qualities of the kernel… the star one is very angular, the plus one is very “plus like” and the circular one is very circular. Note how the blob acts a lot like a low pass filter! In frequency space, it does actually look like one, so that makes sense:</p><p>您可以看到，这些图像以某种方式呈现出内核…的品质。星形的很有棱角，正的很“正像”，圆形的很圆。请注意，斑点的行为非常像一个低通滤波器！在频率空间中，它看起来确实像一个，所以这是有道理的：</p><p>    If you think the above looks weird when doing convolution on images, you should give a listen to convolution being used in audio. When used for reverb it sounds good, and sounds correct, but if you use it to convolve arbitrary audio samples together, you can get some really interesting and bizarre sounds! You can hear that here:  https://blog.demofox.org/2015/03/23/diy-synth-convolution-reverb-1d-discrete-convolution-of-audio-samples/</p><p>如果你觉得在图像上做卷积看起来很奇怪，你应该听听音频中使用的卷积。当用于混响时，它听起来很好听，而且听起来很正确，但是如果你用它把任意的音频样本卷积在一起，你可以得到一些非常有趣和奇怪的声音！你可以在这里听到：https://blog.demofox.org/2015/03/23/diy-synth-convolution-reverb-1d-discrete-convolution-of-audio-samples/。</p><p> The dark border around the image is an artifact from adding a black border around the images to make them the right size (zero padding). If you instead just make the convolution kernel image as large as the image you are convolving (and that is already a power of 2, since this FFT requires that), you’d get the below, which has part of the image “wrapping” across from the other side.</p><p>图像周围的黑色边框是通过在图像周围添加黑色边框以使其大小合适(零填充)而产生的瑕疵。如果你只是把卷积内核图像做得和你要卷积的图像一样大(这已经是2的幂了，因为这是FFT的要求)，你会得到下面的图像，它的一部分图像从另一面“包裹”过来。</p><p>  If you used the DCT (discrete cosine transform) instead, it would MIRROR the texture instead of wrapping it, so you’d get more similar pixels to what should be there most of the time, compared to DFT which wraps. Another way to solve this problem though is if you are doing convolution in image space, instead of frequency space, is you can throw away any samples that go outside of the valid area of the images. You want to sum up the weight of the samples you actually took though in this case, and divide the final convolution sum by that weight, to normalize it. That will make pixels near the border have higher weights than they should, but it can be a less jarring artifact than the black border, wrapping, or mirroring artifacts.</p><p>如果你使用DCT(离散余弦变换)，它会镜像纹理而不是包裹它，所以你会得到更多与大多数时候应该存在的像素相似的像素，而不是包裹的DFT。不过，解决这个问题的另一种方法是，如果你在图像空间而不是频率空间进行卷积，你可以丢弃任何超出图像有效区域的样本。你需要把你实际采集的样本的重量相加，然后将最终的卷积和除以这个重量，以使其归一化。这将使边界附近的像素具有比其应有的更高的权重，但与黑色边框、包裹或镜像瑕疵相比，它可能不是那么刺耳的瑕疵。</p><p> Truth be told, many of the operations in this article can be done in a handful of lines of python. I find a lot of value in implementing things myself though, as it helps me internalize the ideas to better understand when and how to use them, and how to avoid problems/mysteries that come up when things are used as black boxes. I feel the tide turning though after a recent look at the sea of algorithms relating to SVD,PCA and finding eigenvectors. That is some crazy stuff, and way too much for a single person to deal with, while still trying to be competent in other topics 😛</p><p>说实话，本文中的许多操作都可以在几行Python代码中完成。不过，我发现自己实现这些东西很有价值，因为它帮助我将想法内化，以便更好地理解何时以及如何使用它们，以及如何避免当东西被用作黑匣子时出现的问题/谜团。不过，在最近研究了与奇异值分解(SVD)、主成分分析(PCA)和寻找特征向量相关的大量算法之后，我感觉潮流发生了变化。这是一些疯狂的事情，对于一个人来说太难处理了，同时仍然试图在其他话题上胜任😛</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.demofox.org/2020/11/04/frequency-domain-image-compression-and-filtering/">https://blog.demofox.org/2020/11/04/frequency-domain-image-compression-and-filtering/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/图像压缩/">#图像压缩</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/domain/">#domain</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/图像/">#图像</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>