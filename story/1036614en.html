<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Str：另一个C语言字符串库Str: Yet another string library for C language</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Str: Yet another string library for C language<br/>Str：另一个C语言字符串库</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-26 05:27:11</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/b4a39ad6c2e54c1a59c8a9dc7f845916.png"><img src="http://img2.diglog.com/img/2020/11/b4a39ad6c2e54c1a59c8a9dc7f845916.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Bored with developing the same functionality over and over again, unsatisfiedwith existing libraries, so decided to make the right one, once and forever.  🙂</p><p>厌倦了一次又一次地开发相同的功能，对现有的库不满意，因此决定永久地选择合适的库。 🙂</p><p>    Just clone the project and copy (or symlink) the files  str.h and  str.c into your project,but please respect the  license.</p><p>    只需克隆项目并将文件str.h和str.c复制（或符号链接）到您的项目中，但是请遵守许可。</p><p>   str s = str_null; str_join(&amp;s, str_lit(  &#34;,  &#34;), str_lit(  &#34;Here &#34;), str_lit(  &#34;there &#34;), str_lit(  &#34;and everywhere &#34;)); str_cat(&amp;s, s, str_lit(  &#34;... &#34;)); assert(str_eq(s, str_lit(  &#34;Here, there, and everywhere... &#34;))); str_free(s);</p><p>   str s = str_null; str_join（＆s，str_lit（“，”），str_lit（“ Here”），str_lit（“ there”），str_lit（“ and Anywhere”））; str_cat（＆s，s，str_lit（“ ...”））; assert（str_eq（s，str_lit（“在这里，到处都有...”）））; str_free（s）;</p><p>  FILE*  const stream = fopen(...); int err = str_join(stream, str_lit(  &#34;,  &#34;),  str_lit(  &#34;Here &#34;), str_lit(  &#34;there &#34;), str_lit(  &#34;and everywhere... &#34;)); if(err !=  0) {   /* handle the error  */ }</p><p>  FILE * const stream = fopen（...）; int err = str_join（stream，str_lit（“，”），str_lit（“ Here”），str_lit（“ there”），str_lit（“ and Anywhere ...”））; if（err！= 0）{/ *处理错误* /}</p><p>  Disclaimer: This is the good old C language, not C++ or Rust, so nothing can be enforcedon the language level, and certain discipline is required to make sure there is no corruptor leaked memory resulting from using this library.</p><p>  免责声明：这是一种很好的旧C语言，不是C ++或Rust，因此在语言级别上不能强制执行任何操作，并且需要某些纪律以确保不会由于使用此库而导致破坏者泄漏的内存。</p><p> A string is represented by the type  str that maintains a pointer to some memory containingthe actual string. Objects of type  str are small enough (a struct of a  const char* and a  size_t)to be cheap to create, copy (pass by value), and move. The  str structure should be treatedas opaque (i.e., do not attempt to directly access or modify the fields in this structure).The strings are assumed to be immutable, like those in Java or Go, but only by means of  const char*pointers, so it is actually possible to write to such a string, although the required typecast to  char* offers at least some (mostly psychological) protection from modifying a stringby mistake.</p><p> 字符串由类型str表示，该类型维护指向包含实际字符串的某些内存的指针。 str类型的对象足够小（一个const char *和size_t的结构），可以便宜地创建，复制（按值传递）和移动。应该将str结构视为不透明的（即，不要尝试直接访问或修改此结构中的字段）。假定字符串是不可变的，就像Java或Go中的字符串一样，但只能通过const char * pointer进行，因此实际上可以写入这样的字符串，尽管对char *的必需类型转换至少提供了一些（主要是心理上的）保护，以防止错误修改字符串。</p><p>  All string objects must be initialised. Uninitialised objects will causeundefined behaviour. Use the provided constructors, or  str_null for empty strings.</p><p>  所有字符串对象都必须初始化。未初始化的对象将导致未定义的行为。使用提供的构造函数，或将str_null用于空字符串。</p><p> There are two kinds of  str objects: those actually owning the memory they point to, andnon-owning references. This property can be queried using  str_is_owner and  str_is_reffunctions, otherwise such objects are indistinguishable.</p><p>有两种str对象：那些实际上拥有它们指向的内存的对象，以及没有所有者的引用。可以使用str_is_owner和str_is_reffunctions查询此属性，否则此类对象是无法区分的。</p><p> Non-owning string objects are safe to copy and assign to each other, as long as the memorythey refer to is valid. They do not need to be freed.  str_free is a no-op for referenceobjects. A reference object can be cheaply created from a C string, a string literal,or from a range of bytes.</p><p> 只要它们所引用的内存有效，非所有字符串对象就可以安全地相互复制和分配。他们不需要被释放。 str_free是对引用对象的禁止操作。引用对象可以廉价地从C字符串，字符串文字或字节范围内创建。</p><p>  It is a good idea to have only one owning object per each allocated string, but sucha string can have many references to its underlying string, as long as those references do notoutlive the owning object.Sometimes this rule may be relaxed for code clarity, like in the above example wherethe owning object is passed directly to a function, but only if the function does notstore or release the object. When in doubt pass such an object via  str_ref.</p><p>  一个好主意是每个分配的字符串中只有一个拥有对象，但是这样的字符串可以对其基础字符串具有许多引用，只要这些引用不超过其拥有对象即可。有时，为了简化代码，可以放宽此规则，例如在上面的示例中，拥有对象直接传递给函数，但前提是该函数不存储或释放该对象。如有疑问，请通过str_ref传递此类对象。</p><p> Direct assignments (like  s2 = s1;) to owning objects will certainly leak memory, use str_assign function instead. In fact, this function can assign to any string object,owning or not, so it can be used everywhere, just to avoid any doubt.</p><p> 对拥有对象的直接分配（例如s2 = s1;）肯定会泄漏内存，请改用str_assign函数。实际上，此函数可以分配给任何拥有或不具有的字符串对象，因此可以在任何地方使用它，以免产生任何疑问。</p><p> There is no automatic memory management in C, so every owning object must be released atsome point, either directly by using  str_free function, or indirectly by assignment from str_assign or a similar function.</p><p> C语言没有自动内存管理功能，因此必须在某个时候释放每个拥有的对象，直接通过使用str_free函数或通过从str_assign或类似函数进行赋值来间接释放。</p><p> An owning object can be passed over to another location by using  str_move function. Thefunction resets its source object to an empty string.</p><p> 可以使用str_move函数将拥有的对象传递到另一个位置。该函数将其源对象重置为空字符串。</p><p> It is technically possible to create a reference to a string that is notnull-terminated. The library accepts strings without null-terminators, but every new stringallocated by the library is guaranteed to be null-terminated.</p><p> 从技术上讲，可以创建对非空终止字符串的引用。该库接受没有空终止符的字符串，但是保证库分配的每个新字符串都以空终止。</p><p>  A string object can be constructed form any C string, string literal, or a range of bytes.The provided constructors are computationally cheap to apply. Depending on the constructor,the new object can either own the actual string it refers to, or be a non-owning reference.Constructors themselves do not allocate any memory.</p><p>字符串对象可以由任何C字符串，字符串文字或一定范围的字节构造。提供的构造函数在计算上便宜。根据构造函数的不同，新对象可以拥有其引用的实际字符串，也可以是非所有者引用。构造函数本身不分配任何内存。</p><p>  Querying a property of a string object (like the length of the string via  str_len) is acheap operation.</p><p>  查询字符串对象的属性（如通过str_len的字符串长度）是acheap操作。</p><p>  C language does not allow for operator overloading, so this library provides a function str_assign that takes a string object and assigns it to the destination object, freeingany memory owned by the destination. It is generally recommended to use this functioneverywhere outside object initialisation.</p><p>  C语言不允许操作符重载，因此该库提供了str_assign函数，该函数接受字符串对象并将其分配给目标对象，从而释放目标拥有的所有内存。通常建议在外部对象初始化的任何地方都使用此功能。</p><p> An existing object can be moved over to another location via  str_move function.The function resets the source object to  str_null to guarantee the correct move semantics.The value returned by  str_move may be either used to initialise a new object, orassigned to an existing object using  str_assign.</p><p> 可以通过str_move函数将现有对象移动到另一个位置。该函数将源对象重置为str_null，以确保正确的移动语义。str_move返回的值可以用于初始化新对象，也可以使用分配给现有对象str_assign。</p><p>  String composition  functions can write their results to differentdestinations, depending on the  type of their  dest parameter:</p><p>  字符串组合函数可以将其结果写入不同的目的地，具体取决于其dest参数的类型：</p><p> str*: result is written to allocated memory and the reference to it is stored in the string object;</p><p> str *：将结果写入分配的内存中，并将对它的引用存储在字符串对象中；</p><p> The composition functions return 0 on success, or the value of  errno as retrieved at the pointof failure (including  ENOMEM on memory allocation error).</p><p> 组合函数在成功时返回0，或者在失败时返回errno的值（包括在内存分配错误时返回的ENOMEM）。</p><p>  Just to make things more clear, here is the same code as in the example above, but with comments:</p><p>为了使事情更清楚，这里的代码与上面的示例相同，但带有注释：</p><p> // declare a variable and initialise it with an empty stringstr s = str_null;  // join the given string literals around the separator (second parameter),  // storing the result in object &#34;s&#34; (first parameter); in this example we do not check  // the return values of the composition functions, thus ignoring memory allocation failures,  // which is probably not the best idea in general. str_join(&amp;s, str_lit(  &#34;,  &#34;), str_lit(  &#34;Here &#34;), str_lit(  &#34;there &#34;), str_lit(  &#34;and everywhere &#34;));  // create a new string concatenating &#34;s&#34; and a literal; the function does not modify its  // destination object &#34;s&#34; before the result is computed, also freeing the destination  // before the assignment, so it is safe to use &#34;s&#34; as both a parameter and a destination.  // note: we pass a copy of the owning object &#34;s&#34; as the second parameter, and here it is  // safe to do so because this particular function does not store or release its arguments. str_cat(&amp;s, s, str_lit(  &#34;... &#34;));  // check that we have got the expected result assert(str_eq(s, str_lit(  &#34;Here, there, and everywhere... &#34;)));  // finally, free the memory allocated for the string str_free(s);</p><p> //声明一个变量，并用一个空字符串初始化它s = str_null; //在分隔符（第二个参数）周围加入给定的字符串文字，//将结果存储在对象“ s”（第一个参数）中；在此示例中，我们不检查//组合函数的返回值，因此忽略了内存分配失败，//通常这不是最好的主意。 str_join（＆s，str_lit（“，”），str_lit（“ Here”），str_lit（“ there”），str_lit（“ and Anywhere”））; //创建一个新字符串，将“ s”和文字连接起来；该函数不会在计算结果之前修改//目标对象“ s”，也不会在赋值之前释放目标//，因此可以安全地将“ s”用作参数和目标。 //注意：我们将拥有对象“ s”的副本作为第二个参数传递，在这里//是安全的，因为此特定函数不会存储或释放其参数。 str_cat（＆s，s，str_lit（“ ...”））; //检查我们是否获得了预期的结果assert（str_eq（s，str_lit（“在这里，到处都是...”）））; //最后，释放分配给字符串str_free（s）的内存；</p><p>     size_t str_len(const str s) Returns the number of bytes in the string referenced by the object.</p><p>     size_t str_len（const str s）返回对象引用的字符串中的字节数。</p><p> const char* str_ptr(const str s) Returns a pointer to the first byte of the string referenced by the object. The pointer is never NULL.</p><p> const char * str_ptr（const str s）返回一个指针，该指针指向对象引用的字符串的第一个字节。指针永远不会为NULL。</p><p> const char* str_end(const str s) Returns a pointer to the next byte past the end of the string referenced by the object.The pointer is never NULL, but it is not guaranteed to point to any valid byte or location.For C strings it points to the terminating null character. For any given string  s the followingcondition is always satisfied:  str_end(s) == str_ptr(s) + str_len(s).</p><p> const char * str_end（const str s）返回一个指针，该指针指向对象所引用的字符串末尾之后的下一个字节。该指针永远不会为NULL，但不能保证指向任何有效的字节或位置。它指向终止的空字符。对于任何给定的字符串s，始终满足以下条件：str_end（s）== str_ptr（s）+ str_len（s）。</p><p>  bool str_is_owner(const str s) Returns &#34;true&#34; if the string object is the owner of the memory it references.</p><p>  bool str_is_owner（const str s）如果字符串对象是其引用的内存的所有者，则返回“ true”。</p><p> bool str_is_ref(const str s) Returns &#34;true&#34; if the string object does not own the memory it references.</p><p> bool str_is_ref（const str s）如果字符串对象不拥有其引用的内存，则返回“ true”。</p><p>   str str_ref(s) Constructs a non-owning object from either a null-terminated C string, or another  str object.Implemented as a macro.</p><p>str str_ref（s）从以null终止的C字符串或另一个str对象构造一个非所有者对象。实现为宏。</p><p> str str_ref_chars(const char* const s, const size_t n) Constructs a non-owning object referencing the given range of bytes.</p><p> str str_ref_chars（const char * const s，const size_t n）构造一个引用给定字节范围的非所有者对象。</p><p> str str_acquire_chars(const char* const s, const size_t n) Constructs an owning object for the specified range of bytes. The range should be safeto pass to  free(3) function.</p><p> str str_acquire_chars（const char * const s，const size_t n）为指定的字节范围构造一个拥有对象。该范围应该可以安全地传递给free（3）函数。</p><p> str str_acquire(const char* const s) Constructs an owning object from the given C string. The string should be safe to pass to free(3) function.</p><p> str str_acquire（const char * const s）从给定的C字符串构造一个拥有的对象。该字符串应该可以安全地传递给free（3）函数。</p><p>  void str_assign(str* const ps, const str s) Assigns the object  s to the object pointed to by  ps. Any memory owned by the targetobject is freed before the assignment.</p><p>  void str_assign（str * const ps，const str s）将对象s分配给ps指向的对象。目标对象拥有的所有内存在分配前都会释放。</p><p> str str_move(str* const ps) Saves the given object to a temporary, resets the source object to  str_null, and thenreturns the saved object.</p><p> str str_move（str * const ps）将给定对象保存到临时对象，将源对象重置为str_null，然后返回保存的对象。</p><p> void str_clear(str* const ps) Sets the target object to  str_null after freeing any memory owned by the target.</p><p> void str_clear（str * const ps）在释放目标拥有的所有内存之后，将目标对象设置为str_null。</p><p>  int str_from_file(str* const dest, const char* const file_name) Reads the entire file (of up to 64MB by default, configuarable via  STR_MAX_FILE_SIZE) intothe destination string. Returns 0 on success, or the value of  errno on error.</p><p>int str_from_file（str * const dest，const char * const file_name）将整个文件（默认情况下最大为64MB，可通过STR_MAX_FILE_SIZE配置）读入目标字符串。成功返回0，错误返回errno的值。</p><p>  int str_cmp(const str s1, const str s2) Lexicographically compares the two string objects, with usual semantics.</p><p>  int str_cmp（const str s1，const str s2）用通常的语义从字典上比较两个字符串对象。</p><p>    bool str_has_prefix(const str s, const str prefix) Tests if the given string  s starts with the specified prefix.</p><p>    bool str_has_prefix（const str s，const str prefix）测试给定的字符串s是否以指定的前缀开头。</p><p> bool str_has_suffix(const str s, const str suffix) Tests if the given string  s ends with the specified suffix.</p><p> bool str_has_suffix（const str s，const str suffix）测试给定的字符串s是否以指定的后缀结尾。</p><p>  int str_cpy(dest, const str src) Copies the source string referenced by  src to the generic destination  dest. Returns 0 on success,or the value of  errno on failure.</p><p>  int str_cpy（dest，const str src）将src引用的源字符串复制到通用目标dest。如果成功，则返回0；如果失败，则返回errno的值。</p><p> int str_cat_range(dest, const str* src, size_t count) Concatenates  count strings from the array starting at address  src, and writesthe result to the  generic destination  dest.Returns 0 on success, or the value of  errno on failure.</p><p> int str_cat_range（dest，const str * src，size_t count）从地址src开始连接数组中的计数字符串，并将结果写入通用目标dest。成功返回0，失败则返回errno的值。</p><p> int str_cat(dest, ...) Concatenates a variable list of  str arguments, and writes the result to the generic destination  dest.Returns 0 on success, or the value of  errno on failure.</p><p> int str_cat（dest，...）连接一个由str参数组成的变量列表，并将结果写入通用目标dest。成功则返回0，失败则返回errno的值。</p><p> int str_join_range(dest, const str sep, const str* src, size_t count) Joins around  sep the  count strings from the array starting at address  src, and writesthe result to the  generic destination  dest.Returns 0 on success, or the value of  errno on failure.</p><p>int str_join_range（dest，const str sep，const str * src，size_t count）从地址src处开始将数组中的计数字符串连接到sep处，并将结果写入通用目标dest。成功返回0或errno的值失败。</p><p> int str_join(dest, sep, ...) Joins around  sep the variable list of  str arguments, and writes the result to the generic destination  dest.Returns 0 on success, or the value of  errno on failure.</p><p> int str_join（dest，sep，...）在sep附近加入str参数的变量列表，并将结果写入通用目标dest。成功则返回0，失败则返回errno的值。</p><p>  void str_sort_range(const str_cmp_func cmp, str* const array, const size_t count) Sorts the given array of  str objects using the given comparison function. A numberof typically used comparison functions is also provided:</p><p>  void str_sort_range（const str_cmp_func cmp，str * const array，const size_t count）使用给定的比较函数对给定的str对象数组进行排序。还提供了许多通常使用的比较功能：</p><p>  const str* str_search_range(const str key, const str* const array, const size_t count) Binary search for the given key. The input array must be sorted using  str_order_asc.Returns a pointer to the string matching the key, or NULL.</p><p>  const str * str_search_range（const str key，const str * const array，const size_t count）二进制搜索给定的键。输入数组必须使用str_order_asc排序。返回指向与键匹配的字符串的指针，即NULL。</p><p> size_t str_partition_range(bool (*pred)(const str), str* const array, const size_t count) Reorders the string objects in the given range in such a way that all elements for whichthe predicate  pred returns &#34;true&#34; precede the elements for which predicate  predreturns &#34;false&#34;. Returns the number of preceding objects.</p><p> size_t str_partition_range（bool（* pred）（const str），str * const array，const size_t count）对给定范围内的字符串对象重新排序，以使谓词pred返回其“ true”的所有元素在要替换其的元素之前谓词predreturns返回“ false”。返回先前对象的数量。</p><p> size_t str_unique_range(str* const array, const size_t count) Reorders the string objects in the given range in such a way that there are two partitions:one where each object is unique within the input range, and another partition with all theremaining objects. The unique partition is stored at the beginning of the array, and issorted in ascending order, followed by the partition with all remaining objects.Returns the number of unique objects.</p><p> size_t str_unique_range（str * const array，const size_t count）以给定范围内的字符串对象重新排序的方式，使其具有两个分区：一个分区，每个对象在输入范围内是唯一的，另一个分区包含所有剩余的对象。唯一分区存储在数组的开头，并按升序排序，然后是带有所有剩余对象的分区。返回唯一对象的数量。</p><p>  for_each_codepoint(var_name, src_string) A macro that expands to a loop iterating over the given string  src_string (of type  str) by UTF-32code points. On each iteration the variable  var_name (of type  char32_t) is assignedthe value of the next valid UTF-32 code point from the source string. Upon exit from the loop thevariable has one on the following values:</p><p>  for_each_codepoint（var_name，src_string）一个宏，扩展为循环，以UTF-32code点遍历给定字符串src_string（类型为str）的循环。在每次迭代中，将变量var_name（类型为char32_t）分配给源字符串中下一个有效UTF-32代码点的值。从循环退出后，变量在以下值中具有一个：</p><p>  The source string is expected to be encoded in the  current program locale, as set by the mostrecent call to  setlocale(3).</p><p>如最近对setlocale（3）的调用所设置的，源字符串应在当前程序区域设置中编码。</p><p>  # include   &lt;uchar.h &gt;...str s = ...... char32_t c;	  // variable to receive UTF-32 values on each iteration for_each_codepoint(c, s){	  /* process c  */} if(c != CPI_END_OF_STRING){	  /* handle error  */}</p><p>  ＃include  ... str s = ...... char32_t c; //用于在每次迭代中接收UTF-32值的变量for_each_codepoint（c，s）{/ *处理c * /} if（c！= CPI_END_OF_STRING）{/ *处理错误* /}</p><p>   file-to-str: The script takes a file (text or binary) and a C variable name, andwrites to  stdout C source code where the variable (of type  str) is definedand initialised with the content of the file.</p><p>   file-to-str：脚本使用一个文件（文本或二进制文件）和一个C变量名称，并写入标准输出C源代码，其中定义了变量（类型为str）并使用文件的内容进行初始化。</p><p> gen-char-class: Generates character classification functions that do the same as their isw*() counterparts under the current locale as specified by  LC_ALL environment variable.Run  tools/gen-char-class --help for further details, or  tools/gen-char-class --spaceto see an example of its output.</p><p> gen-char-class：生成字符分类函数，其功能与LC_ALL环境变量指定的当前语言环境下的isw *（）对应函数相同。运行tools / gen-char-class --help了解更多详细信息，或者运行tools / gen-char-class --space查看其输出示例。</p><p>  The library requires at least a C11 compiler. So far has been tested on Linux Mint 19.3 and 20,with  gcc versions up to 9.3.0, and  clang versions up to 10.0.0; and on ALT Linux 9.1 forElbrus, with  lcc version 1.25.09.</p><p>  该库至少需要一个C11编译器。到目前为止，已经在Linux Mint 19.3和20上进行了测试，gcc版本最高为9.3.0，clang版本最高为10.0.0；在ALT Linux 9.1 forElbrus上，以及lcc版本1.25.09。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/maxim2266/str">https://github.com/maxim2266/str</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/字符串/">#字符串</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/string/">#string</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/str/">#str</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>