<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>带有答案集编程的规则引擎和知识密集型处理Rule Engines and Knowledge-Intensive Processing with Answer Set Programming</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rule Engines and Knowledge-Intensive Processing with Answer Set Programming<br/>带有答案集编程的规则引擎和知识密集型处理</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-25 03:46:19</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/df9ad49b80d6336bbcdf64e35a047792.jpg"><img src="http://img2.diglog.com/img/2020/11/df9ad49b80d6336bbcdf64e35a047792.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Answer Set Programming (ASP) is a software paradigm that can be used to  represent knowledge and to solve combinatorial and information-intensive problems. Combinatorial search problems are those believed to not have an efficient way to reduce the space of solutions (NP-hard), some examples of this sort are presented in this article. The notion of knowledge is very broad and very dependent on the domain. It is inclusive of beliefs to various degrees, facts and rules that can be applied for enabling reasoning, and generally, that commonsense understanding we have about the world.</p><p>答案集编程（ASP）是一种软件范例，可用于表示知识并解决组合和信息密集型问题。组合搜索问题是那些被认为没有减少解决方案空间的有效方法（NP-hard）的问题，本文提供了此类示例。知识的概念非常广泛，并且非常依赖领域。它包括各种程度的信念，事实和规则，这些信念，规则和规则可用于进行推理，并且通常包括我们对世界的常识性理解。</p><p> The puzzles presented here are solved within a programming tool I made, freely inspired by Datalog and Clingo, the ASP developed at University of Potsdam. Differently from Datalog, the scripts reported here are based on a domain specific language, and they leverage the strongly typed compiler of Scala. The objective of this dissertation is not to provide a more efficient way to do ASP but rather to build the tools for moving on with the project I’m conducting, and to explore the potential of this paradigm in other areas such as data management and rule systems. I wish to convey the awareness that this software paradigm brings advantages in terms elasticity and completeness for real world scenarios. ASP has been used for:</p><p> 我提出的一个编程工具可以解决这里提出的难题，该工具是由Datalog和波茨坦大学开发的ASP Clingo自由启发的。与Datalog不同，此处报告的脚本基于特定于域的语言，并且它们利用Scala的强类型编译器。本文的目的不是提供一种更有效的方式来执行ASP，而是构建用于继续进行我正在进行的项目的工具，并探索这种范例在诸如数据管理和规则等其他领域的潜力。系统。我希望传达一种认识，即该软件范例在现实情况下在弹性和完整性方面具有优势。 ASP已用于：</p><p> Decision support system to help the Space Shuttle controllers to deal with critical situations caused by multiple failures.</p><p> 决策支持系统，可帮助航天飞机控制器处理因多次故障导致的紧急情况。</p><p>  Classify profiles and actual needs of Telecom Italia users (1M calls/day) for creating personalized experience of customer care.</p><p>  分类意大利电信用户的个人资料和实际需求（每天100万次呼叫），以创建个性化的客户服务体验。</p><p> Configuration of products and services are subjected to complex rules in railways safety controls, tourism, automotive, computer hardware, software packages.</p><p> 产品和服务的配置要遵守铁路安全控制，旅游，汽车，计算机硬件，软件包中的复杂规则。</p><p> ASP is a form of  logic programming where rules (or arguments) can be thought of as executable specifications. An ASP program does not listen for queries, rather it applies all conditions recursively until the generated knowledge does not evolve anymore. When there are no more satisfiable conditions to run, the system returns the list of results, the so called stable models, or answer sets. Let’s see it with an example about prime numbers.</p><p> ASP是逻辑编程的一种形式，其中规则（或自变量）可以被视为可执行规范。 ASP程序不侦听查询，而是递归地应用所有条件，直到生成的知识不再发展为止。当没有其他可满足的条件要运行时，系统将返回结果列表，所谓的稳定模型或答案集。让我们看一个有关质数的例子。</p><p> What are prime numbers? Numbers only divisible by itself and one. In logic, for assessing a statement as a valid one, we have to disqualify any possible counterexample. A number is not prime if it is a product of two numbers different from one and itself. Reformulating the definition in this perspective we have:</p><p> 什么是质数？数字只能被一整除。在逻辑上，为了将一条陈述评估为有效，我们必须取消任何可能的反例。如果数字是两个与一个数字不同且与它本身不同的乘积，则不是质数。从这个角度重新定义定义，我们有：</p><p> X is a prime number if there is no evidence that it is a compound number.</p><p>如果没有证据表明X是质数，则X是质数。</p><p> Let’s get a list of compound (or composite) numbers by generating all possible combinations of factors in a given range, and then check whether their module (the remainder of their division) is zero.</p><p> 让我们通过在给定范围内生成所有可能的因子组合来获得复合（或复合）数字的列表，然后检查其模块（除法的余数）是否为零。</p><p> (&#34;compound&#34; :: X :: e) :- (X := (1 to N), Y := (2 to X - 1),  (X  %% Y) === 0)</p><p> （“化合物” :: X :: e）：-（X：=（1至N），Y：=（2至X-1），（X％％Y）=== 0）</p><p> In the first clause of the premise  (X := (1 to N)) I simply assign a list to a variable X. In the second, for each X there is a list of Y, and the corresponding combination of them is the cartesian product of all Xs and Ys. Last clause will check whether any single instance of X is divisible by Y. If so, a new atom “compound” is generated. Lastly, the following argument will instantiate the “prime” atoms:</p><p> 在前提的第一个子句中（X：=（1到N）），我只为变量X分配一个列表。在第二个子句中，每个X都有一个Y的列表，它们的对应组合是笛卡尔所有X和Y的乘积。最后一个子句将检查X的任何单个实例是否可被Y整除。如果是，则生成一个新的原子“化合物”。最后，以下参数将实例化“素数”原子：</p><p> (“prime” :: X :: e) :- (X := (1 to N), not “product” :: X :: e)</p><p> （“ prime” :: X :: e）：-（X：=（1至N），而不是“ product” :: X :: e）</p><p> What is new here is the  not keyword called  negation as a failure. It checks whether that atom instance  “product” :: X exists in the knowledge graph, and returns true when there is not. The full program is:</p><p> 这里的新功能是称为否定失败的not关键字。它检查知识图中是否存在原子实例“ product” :: X，如果不存在则返回true。完整的程序是：</p><p> import com.sap.cxlabs.bewater.logic.asp._val N = 7val  arguments = Args(    (&#34;compound&#34; :: X :: e) :- (Z := (1 to N), Y := (2 to Z - 1),  X := (Z  %% Y) === 0)    (“prime” :: X :: e) :- (X := (1 to N), not “product” :: X :: e))val results = arguments.deduct()</p><p> import com.sap.cxlabs.bewater.logic.asp._val N = 7val参数= Args（（“ compound” :: X :: e）：-（Z：=（1至N），Y：=（2至Z-1），X：=（Z %% Y）=== 0）（“素数” :: X :: e）：-（X：=（1到N），而不是“乘积” :: X： ：e））val结果= arguments.deduct（）</p><p> In ASP there are at least two main stages that denote the execution of the program:</p><p>在ASP中，至少有两个主要阶段表示程序的执行：</p><p>   This is a classical combinatorial problem where the nodes in a graph are colored by keeping in consideration that the color of a node must be different from the color of the adjacent ones. The input graph contains the nodes, the edges and the given colors:</p><p>   这是一个经典的组合问题，其中通过考虑节点的颜色必须不同于相邻节点的颜色来着色图中的节点。输入图包含节点，边和给定的颜色：</p><p> val facts = new FactBuilderfacts.node(1 to 6)facts.edge(1, 2);  facts.edge(1, 3);  facts.edge(1, 4)facts.edge(2, 4);  facts.edge(2, 5);  facts.edge(2, 6)facts.edge(3, 4);  facts.edge(5, 3);  facts.edge(5, 4)facts.edge(5, 6);  facts.edge(6, 3);  facts.edge(6, 5)facts.col(Seq(&#34;blue&#34;, &#34;green&#34;, &#34;red&#34;))</p><p> val facts =新的FactBuilderfacts.node（1到6）facts.edge（1，2）; facts.edge（1，3）; facts.edge（1，4）facts.edge（2，4）; facts.edge（2，5）; facts.edge（2，6）facts.edge（3，4）; facts.edge（5，3）; facts.edge（5，4）事实.edge（5，6）; facts.edge（6，3）; facts.edge（6，5）facts.col（Seq（“ blue”，“ green”，“ red”））</p><p>   In here the atom  “color” is generated for each node and each color present in the knowledge base. Given that a node is assigned one and only one color, we create all possible permutations and we specify (with the operation  ^(1)) that in each solution the field in the argument (1) is unique. The  FactBuilder is an helper tool for writing atoms in a more convenient way than in the previous example.</p><p>   在这里，为原子中存在的每个节点和每种颜色生成原子“颜色”。给定一个节点仅分配一种颜色，我们创建所有可能的排列，并指定（使用^（1）操作），在每个解决方案中，参数（1）中的字段都是唯一的。 FactBuilder是一个帮助工具，可以比上一个示例更方便地编写原子。</p><p> The solver part will drop out all solutions on which two adjacent nodes have the same color:</p><p> 求解器部分将删除两个相邻节点具有相同颜色的所有解决方案：</p><p>   val rules = Args( p.color(X, Y).^(1) :- (p.node(X), p.col(Y)), :-(p.edge(X, Y), p.color(X, W), p.color(Y, W)))rules.deduct(facts)</p><p>   val规则= Args（p.color（X，Y）。^（1）：-（p.node（X），p.col（Y））,: :-( p.edge（X，Y），p。 color（X，W），p.color（Y，W）））规则。扣除（事实）</p><p>   If you have already played Chess, you know that the Queen is the most powerful piece on the chessboard, and losing it is usually the preamble of a defeat. In this puzzle, the problem is to find all dispositions of N Queens in a N*N chessboard, on which any Queen can’t attack none of the others. The ASP program will generate all permutations of Queens in the chessboard, and it filter out all configurations on which:</p><p>   如果您已经下过国际象棋，您就会知道女王是棋盘上最强大的棋子，而输掉棋子通常是失败的序言。在这个难题中，问题是要在N * N棋盘中找到所有N个皇后的配置，任何一个皇后都不能攻击其他皇后。 ASP程序将在棋盘上生成所有皇后排列，并过滤出以下所有配置：</p><p>  How to check whether two pieces are in diagonal? They lay in the same diagonal when the difference of X axis is the same as the (absolute) difference of the Y axis.  Following the data and program:</p><p>如何检查两块是否对角线？当X轴的差与Y轴的（绝对）差相同时，它们位于同一对角线上。遵循数据和程序：</p><p> val N = 6val facts = new FactBuilderfacts.row(1 to N)facts.col(1 to N)val arguments = Args( ((&#34;queen&#34; :: X :: Y :: e) $$ (N)) :- (&#34;row&#34; :: X :: e, &#34;col&#34; :: Y :: e), :-(&#34;queen&#34; :: X :: Y :: e, &#34;queen&#34; :: X :: Z :: e, Y &lt;&gt; Z), :-(&#34;queen&#34; :: X :: Y :: e, &#34;queen&#34; :: Z :: Y :: e, X &lt;&gt; Z), :-(&#34;queen&#34; :: X :: Y :: e, &#34;queen&#34; :: W :: Z :: e, !((X === W) &amp;&amp; (Y === Z)), (X - W).abs === (Y - Z).abs),)arguments.deduct(facts)</p><p> val N = 6val事实=新的FactBuilderfacts.row（1至N）facts.col（1至N）val参数= Args（（（（“ queen” :: X :: Y :: e）$$（N））： -（“ row” :: X :: e，“ col” :: Y :: e），́ :-(“ queen” :: X :: Y :: e，“ queen” :: X :: Z :: e，Y <> Z），́ :-(“ queen” :: X :: Y :: e，“ queen” :: Z :: Y :: e，X <> Z），́ :-(“ queen”： ：X :: Y :: e，“ queen” :: W :: Z :: e，！（（X === W）&&（Y === Z）），（X-W）.abs == =（Y-Z）.abs），）arguments.deduct（事实）</p><p>   val f = new FactBuilderf.x(1 to 9)f.y(1 to 9)f.n(1 to 9)val p = new FactBuilderval arguments = Args( p.cell(X, Y, Z).^(1, 2) :- (p.x(X), p.y(Y), p.n(Z)), p.subgrid(X, Y, A, B) :- (p.x(X), p.x(A), p.y(Y), p.y(B), (X - 1) / 3 === (A - 1) / 3, (Y - 1) / 3 === (B - 1) / 3), :-(p.cell(X, Y, Z), p.cell(W, Y, Z), X &lt;&gt; W), :-(p.cell(X, Y, Z), p.cell(X, W, Z), Y &lt;&gt; W), :-(p.cell(X, Y, Z), p.cell(A, B, Z), p.subgrid(X, Y, A, B), X &lt;&gt; A, Y &lt;&gt; B))</p><p>   val f =新的FactBuilderf.x（1到9）fy（1到9）fn（1到9）val p =新的FactBuilderval参数= Args（p.cell（X，Y，Z）。^（1，2） ：-（px（X），py（Y），pn（Z）），p.subgrid（X，Y，A，B）：-（px（X），px（A），py（Y），py （B），（X-1）/ 3 ===（A-1）/ 3，（Y-1）/ 3 ===（B-1）/ 3）,: :-( p.cell（X， Y，Z），p.cell（W，Y，Z），X <> W），-：（p.cell（X，Y，Z），p.cell（X，W，Z），Y <> W），-:-( p.cell（X，Y，Z），p.cell（A，B，Z），p.subgrid（X，Y，A，B），X <> A，Y <> B ））</p><p> Unfortunately I can’t show you any results out of this program. In this puzzle the limits of such an explorative ASP engine are obvious. The space of solutions is prohibitive for the simple grounding algorithm I employed. Anyway, the efficiency and effectiveness of the tool  are not the point of this article. Instead, I invite you to run an equivalent program on Clingo. It takes something like a second the resolved matrixes, how can it be? Well, thanks to lazy-grounding, Conflict-Driven solvers, some giant leaps have been done even in the field of logic programming. The evolution of such algorithms is attributable to academic research. They are publicly accessible and there are no constraints on their implementation in commercial systems.</p><p> 很遗憾，我无法向您显示该程序的任何结果。在这个难题中，这种探索性ASP引擎的局限性显而易见。解决方案的空间对于我采用的简单接地算法是不允许的。无论如何，该工具的效率和有效性不是本文的重点。相反，我邀请您在Clingo上运行等效程序。解析矩阵大约需要一秒钟的时间，怎么可能呢？好吧，多亏了惰性接地，冲突驱动的求解器，即使在逻辑编程领域也取得了一些巨大的飞跃。这种算法的发展归因于学术研究。它们是可公开访问的，并且在商业系统中对其实施没有任何限制。</p><p>  In the shortest path, the problem is to find a way between two connected nodes in a graph and whether there are more than one path, select the ones with minimum cost. The data should contain the  “start” and  “end” nodes, and the edges, the connections between different nodes. The atoms  “edge” define the points and the weight of such a connection. The program is:</p><p>  在最短路径中，问题是要在图中的两个连接节点之间找到一条路径，并且是否存在一条以上的路径，请选择成本最低的路径。数据应包含“开始”和“结束”节点，以及边缘，不同节点之间的连接。原子“边缘”定义了这种连接的点和权重。该程序是：</p><p> val shortestPath = SModels(Args( p.path(X, Y, W) :-(p.start(X), p.edge(X, Y, W)), p.path(X, Z, A + B) :- (p.path(X, Y, A), p.edge(Y, Z, B)), p.shortest(W) :- (p.end(Y), p.path(X, Y, W), not p.path(X, Y, Z), W &lt; Z),))shortestPath.deduct(facts)</p><p> val shortestPath = SModels（Args（p.path（X，Y，W）:-( p.start（X），p.edge（X，Y，W）），p.path（X，Z，A + B ）：-（p.path（X，Y，A），p.edge（Y，Z，B）），p.shortest（W）：-（p.end（Y），p.path（X，Y ，W），而不是p.path（X，Y，Z），W <Z），））shortestPath.deduct（事实）</p><p> This is an example of recursivity in ASP. The SModels wrapper is intended to return stable models since the  “path” atom is generated for all connected edges, and the number of iterations depends on the distance degree of the nodes (e.g. Munich and Tokyo are certainly connected through roads, but the degree of distance between them is high).</p><p> 这是ASP中递归的示例。 SModels包装器旨在返回稳定的模型，因为会为所有连接的边生成“路径”原子，并且迭代次数取决于节点的距离程度（例如，慕尼黑和东京当然是通过道路连接的，但是它们之间的距离很高）。</p><p> I think it is interesting to note the last argument, which is intended to enlight the minimum cost:</p><p>我认为注意到最后一个参数很有趣，该参数旨在启发最低成本：</p><p>   “W is the minimum cost if there is no evidence that there exists a lesser one”</p><p>   “ W是最低成本，如果没有证据表明存在较小的成本”</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://cxlabs.sap.com/2020/11/24/rule-engines-and-knowledge-intensive-processing-with-answer-set-programming/">https://cxlabs.sap.com/2020/11/24/rule-engines-and-knowledge-intensive-processing-with-answer-set-programming/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/规则/">#规则</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/engines/">#engines</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/节点/">#节点</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>