<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Nexus 1.0：类型安全，代码优先GraphQL API的主要版本 Nexus 1.0: A Major Release for Type-Safe, Code-First GraphQL APIs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Nexus 1.0: A Major Release for Type-Safe, Code-First GraphQL APIs<br/>Nexus 1.0：类型安全，代码优先GraphQL API的主要版本 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-15 16:44:01</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/4fd512bb8fa4e1811cf790f0e93b230e.png"><img src="http://img2.diglog.com/img/2020/12/4fd512bb8fa4e1811cf790f0e93b230e.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Nexus is a library originally authored by  Tim Griesser that allows developers to build code-first and type-safe GraphQL APIs. Prisma has been a core contributor to the library for over two years and has helped shape its evolution.</p><p>Nexus是最初由Tim Griesser创作的库，它使开发人员可以构建代码优先和类型安全的GraphQL API。 Prisma两年来一直是该库的核心贡献者，并帮助塑造了它的发展。</p><p>  This release is the culmination of outstanding community feedback and contributions, years of battle-testing Nexus in production, and responding to lessons learned in creating an excellent developer experience for those building GraphQL APIs.</p><p>  此版本是杰出社区反馈和贡献的结晶，是Nexus在生产中经过多年的实战测试的结果，也是对为那些为GraphQL API的开发人员创造出色的开发人员经验的经验教训的回应。</p><p> Note: Prisma&#39;s products are no longer GraphQL-centric. You can use Prisma in a REST API, a GraphQL API, or in any other setting where you want to access a database in Node or Go. Although we contribute to Nexus, it is not necessary to use it alongside Prisma.  Find out more about what Prisma offers and how to use it.</p><p> 注意：Prisma的产品不再以GraphQL为中心。您可以在REST API，GraphQL API或要在Node或Go中访问数据库的任何其他设置中使用Prisma。尽管我们为Nexus做出了贡献，但没有必要将其与Prisma一起使用。了解有关Prisma提供的产品以及如何使用它的更多信息。</p><p>  Nexus offers a way to build code-first GraphQL APIs in Node. The code-first approach to building a GraphQL API is in contrast to the (potentially more common) schema-first approach.</p><p>  Nexus提供了一种在Node中构建代码优先的GraphQL API的方法。与建立优先的GraphQL API相比，代码优先的方法与模式优先的方法（可能更常见）形成了对比。</p><p> Most developers that are new to building GraphQL APIs start out by taking the schema-first approach that has been popularized by companies like Apollo and their Apollo Server offering.</p><p> 大多数刚建立GraphQL API的开发人员都是从采用模式优先的方法开始的，这种方法已被Apollo及其Apollo Server等公司所普及。</p><p> With the schema-first approach, writing the GraphQL API requires a set of  type definitions and accompanying  resolvers. A simple schema-first server might look like this:</p><p> 使用模式优先方法，编写GraphQL API需要一组类型定义和随附的解析器。一个简单的模式优先服务器可能看起来像这样：</p><p>  const Query  =  { posts :  ( )  =&gt;  [  { id :  &#39;1&#39; , title :  &#39;My first GraphQL server&#39; , body :  &#39;How I wrote my first GraphQL server&#39; ,  } ,  ] , }</p><p>  const Query = {posts：（）=＆gt; [{id：＆＃39; 1＆＃39; ，标题：“我的第一台GraphQL服务器” ，正文：我如何编写我的第一个GraphQL服务器＆＃39; ，}，]，} </p><p> While the schema-first approach is easy to get started with, it comes with some inherent drawbacks that can make development difficult when applications start getting bigger.</p><p>尽管模式优先方法很容易上手，但它具有一些固有的缺陷，这些缺陷会在应用程序开始变大时使开发变得困难。</p><p> Nexus takes a different approach to building GraphQL APIs. Instead of keeping a separate schema and set of resolvers, with Nexus, schemas and resolvers are written in the same spot using code.</p><p> Nexus采用了另一种方法来构建GraphQL API。使用Nexus，可以将模式和解析器写在同一位置，而不是使用单独的架构和一组解析器。</p><p>  import  { objectType , queryType , makeSchema  }  from  &#39;nexus&#39; const Post  =  objectType ( { name :  &#39;Post&#39; ,  definition (t )  { t . id ( &#39;id&#39; ) t . string ( &#39;title&#39; ) t . string ( &#39;body&#39; )  } , } ) const Query  =  queryType ( {  definition (t )  { t .list . field ( &#39;posts&#39; ,  { resolve :  ( )  =&gt;  [  { id :  &#39;1&#39; , title :  &#39;My first GraphQL server&#39; , body :  &#39;How I wrote my first GraphQL server&#39; ,  } ,  ] ,  } )  } , } ) const schema  =  makeSchema ( { types :  [Post , Query ] , } )</p><p>  从＆＃39; nexus＆＃39;导入{objectType，queryType，makeSchema} const Post = objectType（{name：＆＃39; Post＆＃39;，definition（t）{t。id（＆＃39; id＆＃39;）t。string（＆＃39; title＆＃39;）t。字符串（＆＃39; body＆＃39;}}）const Query = queryType（{定义（t）{t .list。字段（＆＃39; posts＆＃39;，{resolve：（）=＆gt; [ {id：＆＃39; 1＆＃39 ;，标题：＆＃39;我的第一个GraphQL服务器＆＃39;正文：＆＃39;我如何编写我的第一个GraphQL服务器＆＃39;，}，]，}）}} ，}）const schema = makeSchema（{类型：[发布，查询]，}）</p><p>    When building a schema-first GraphQL API, it is common to start out by placing all type definitions and resolvers in a single file. When both the schema and the resolvers live next to one another, it&#39;s fairly straightforward to work in both at the same time.</p><p>    在构建模式优先的GraphQL API时，通常首先将所有类型定义和解析器放在单个文件中来开始。当模式和解析器彼此相邻时，同时在两者中同时工作非常简单。</p><p> As the application grows, however, it is most often desired to move parts of the schema into their own separate modules and files. It&#39;s at this point that working on a GraphQL API becomes a bit more tedious. With this modularization comes the need to switch back and forth between the Schema Definition Language and JavaScript/TypeScript to write the resolvers. Not only does one need to constantly switch between files, they also need to do a context switch mentally to work between the two langauges.</p><p> 但是，随着应用程序的增长，最经常需要将模式的各个部分移动到它们自己的单独模块和文件中。此时，使用GraphQL API变得更加乏味。通过这种模块化，需要在模式定义语言和JavaScript / TypeScript之间来回切换以编写解析器。不仅需要不断地在文件之间切换，而且还需要在上下文上进行上下文切换以在两种语言之间工作。</p><p> With Nexus, our schema and its resolvers are always defined together. Nexus also allows us to write everything in a common language. This allows us to side-step the co-location/context switching issue altogether and helps us to be more productive, even as our applications grow to be quite large.</p><p> 使用Nexus，我们的架构及其解析器总是一起定义的。 Nexus还允许我们用通用语言编写所有内容。这使我们可以完全避开共址/上下文切换问题，即使我们的应用程序变得很大，也可以帮助我们提高生产力。</p><p>  One major benefit of using Nexus is its ability to automatically generate TypeScript types and GraphQL Schema Definition Language (SDL) files. The generated types are useful for adding extra type safety to the code used to power your GraphQL API. The generated SDL files can be used for many purposes. For example, we can configure our editors to know about the shape of our APIs to give us introspection for the queries and mutations we write.</p><p>  使用Nexus的主要好处之一是能够自动生成TypeScript类型和GraphQL架构定义语言（SDL）文件。生成的类型对于在为GraphQL API提供动力的代码中增加额外的类型安全性很有用。生成的SDL文件可用于许多目的。例如，我们可以配置我们的编辑器以了解我们API的形状，从而使我们能够对所编写的查询和变异进行自省。 </p><p> Type and SDL generation comes for free with Nexus and can be enabled by supplying some configuration in the  makeSchema call.</p><p>Nexus是免费提供类型和SDL生成的，可以通过在makeSchema调用中提供一些配置来启用它。</p><p> import path  from  &#39;path&#39; const schema  =  makeSchema ( { types :  [Post , Query ] , outputs :  { schema : path . join (__dirname ,  &#39;generated/schema.gen.graphql&#39; ) , typegen : path . join (__dirname ,  &#39;generated/nexusTypes.gen.ts&#39; ) ,  } , } )</p><p> 从＆＃39; path＆＃39;导入路径const schema = makeSchema（{类型：[Post，Query]，输出：{schema：path。join（__dirname，＆＃39; Generated / schema.gen.graphql＆＃39;），typegen：path。join（__dirname，＆ ＃39; generate / nexusTypes.gen.ts＆＃39;），}，}）</p><p>  There are a number of changes to Nexus at 1.0. Read the  full changelog and follow along below to see what&#39;s new!</p><p>  Nexus 1.0进行了许多更改。阅读完整的变更日志，然后按照下面的步骤查看新功能！</p><p>  Nexus 1.0 is now available under the  nexus package name. All imports now come from  nexus and not  @nexus/schema.</p><p>  Nexus 1.0现已在连结套件名称下提供。现在，所有导入都来自于nexus，而不是@ nexus / schema。</p><p>   In previous versions of Nexus, fields were treated as non-nullable by default. This differed from other GraphQL API frameworks which would treat fields as nullable unless otherwise specified. The Nexus authors took this approach because allowing fields to be non-nullable by default posed some long-term risks for API development.</p><p>   在Nexus的早期版本中，默认情况下将字段视为不可为空。不同于其他GraphQL API框架，除非另有说明，否则该框架会将字段视为可为空。 Nexus作者之所以采用这种方法，是因为默认情况下允许字段不可为空会给API开发带来一些长期风险。</p><p> The default nullability for fields has now been inverted in Nexus so that we can align with GraphQL best practices and expectations, specifically from the authors of GraphQL.</p><p> 字段的默认可为空性现已在Nexus中被颠倒，以便我们能够与GraphQL最佳做法和期望保持一致，特别是GraphQL的作者。</p><p>     The code for the  Post object type above uses a property called  nonNull which offers a bit more flexibility for specifying that fields should be non-null. It&#39;s useful for situations where the chaining API is not ideal, such as expressing deeply-nested types and when programmatically creating non-nullable types.</p><p>     上面的Post对象类型的代码使用称为nonNull的属性，该属性为指定字段应为非null提供了更大的灵活性。对于链API不太理想的情况，例如表达深度嵌套的类型以及以编程方式创建非空类型的情况，它很有用。 </p><p> import  { queryType , stringArg , nonNull  }  from  &#39;nexus&#39; queryType ( {  definition (t )  { t . field ( &#39;tags&#39; ,  {  type :  nonNull ( &#39;String&#39; )  // =&gt; String! args :  { id :  nonNull ( stringArg ( ) )  // or nonNull(&#39;String&#39;) =&gt; String!  } ,  resolve ( )  {  // ...  }  } )  } } )</p><p>从＆＃39; nexus＆＃39;导入{queryType，stringArg，nonNull} queryType（{definition（t）{t。field（＆＃39; tags＆＃39;，{type：nonNull（＆＃39; String＆＃39;）// =＆gt; String！args：{id：nonNull（stringArg （））//或nonNull（＆＃39; String＆＃39;）=＆gt; String！}，resolve（）{// ...}}}}}））</p><p> The  nonNull function accepts an argument which can be used to specify the type for a type or argument.</p><p> nonNull函数接受一个参数，该参数可用于指定类型或参数的类型。</p><p> While fields are now nullable by default, it&#39;s possible to change this behavior either globally or at the type level in your Nexus API.</p><p> 现在，默认情况下，字段可以为空，但可以全局更改此行为，也可以在Nexus API的类型级别更改此行为。</p><p> queryType ( { nonNullDefaults :  { output :  true ,  } ,  definition (t )  { t . string ( &#39;echo&#39; ,  { args :  { message :  &#39;String&#39; ,  } ,  resolve (_root , args )  {  return args .message  } ,  } )  } , } )</p><p> queryType（{nonNullDefaults：{output：true，}，定义（t）{t。string（＆＃39; echo＆＃39;，{args：{message：＆＃39; String＆＃39;，}，resolve（_root ，args）{return args .message}，}}}，}）</p><p> In this example, Nexus now expects that fields should be non-null for all query type fields.</p><p> 在此示例中，Nexus现在期望所有查询类型字段的字段都不应为空。</p><p> If you choose to change a type to be non-null by default, you can use the  nullable function to specify that certain fields should be nullable.</p><p> 如果您选择将类型默认更改为非null，则可以使用nullable函数来指定某些字段应该为null。</p><p> import  { queryType , stringArg , nullable  }  from  &#39;nexus&#39; queryType ( { nonNullDefaults :  { input :  true , output :  true ,  } ,  definition (t )  { t . field ( &#39;echo&#39; ,  {  type :  nullable ( &#39;String&#39; ) , args :  { message :  nullable ( stringArg ( ) ) ,  } ,  resolve (_root , args )  {  return args .message  } ,  } )  } , } )</p><p> 从＆＃39; nexus＆＃39;导入{queryType，stringArg，nullable} queryType（{nonNullDefaults：{input：true，output：true，}，definition（t）{t。field（＆＃39; echo＆＃39;，{type：nullable（＆＃39; String＆＃39;），args ：{消息：可为null（stringArg（）），}，解析（_root，args）{return args .message}，}}}}） </p><p> To find out more about how Nexus handles nullability, including other ways to interact with the API, read the  Nullability guide.</p><p>要了解有关Nexus如何处理可空性（包括与API进行交互的其他方式）的更多信息，请阅读可空性指南。</p><p>  Nexus 1.0 introduces a new function for working with list types. The  list function can be applied to inputs and outputs similar to how the  nonNull and  nullable functions are.</p><p>  Nexus 1.0引入了一项用于处理列表类型的新功能。列表函数可以应用于输入和输出，类似于nonNull和nullable函数的用法。</p><p> import  { queryType , stringArg , list  }  from  &#39;nexus&#39; queryType ( {  definition (t )  { t . field ( &#39;tags&#39; ,  {  type :  list ( &#39;String&#39; )  // -&gt; [String] args :  { ids :  list ( stringArg ( ) )  // or list(&#39;String&#39;) -&gt; [String]  } ,  resolve ( )  {  // ...  }  } )  } } )</p><p> 从＆＃39; nexus＆＃39;导入{queryType，stringArg，list} queryType（{definition（t）{t。field（＆＃39; tags＆＃39;，{type：list（＆＃39; String＆＃39;）//-＆gt; [String] args：{ids：list（ stringArg（））//或list（＆＃39; String＆＃39;）-＆gt; [String]}，resolve（）{// ...}}}}}）</p><p> The same chaining API for creating lists still remain, but the  list function exist to help for situations where chaining is not ideal.</p><p> 仍然保留了用于创建列表的相同链接API，但存在列表功能可帮助您在链接不理想的情况下提供帮助。</p><p>   Union types allow you to express polymorphic fields where members types can be totally different.</p><p>   联合类型允许您表达成员类型可以完全不同的多态字段。</p><p> Interface types let you express polymorphic fields wherein the field may return a number of different object types but they all share some subset of fields.</p><p> 接口类型使您可以表达多态字段，其中字段可以返回许多不同的对象类型，但是它们都共享字段的某些子集。</p><p> The official GraphQL JavaScript package supports three strategies for implementing Abstract types. Nexus 1.0 now offers an API for implementing these three strategies, providing type safety along the way.</p><p> 官方的GraphQL JavaScript软件包支持三种用于实现Abstract类型的策略。 Nexus 1.0现在提供了用于实施这三种策略的API，并始终提供类型安全性。 </p><p> Note that the following examples work with union types but it works similarly for interface types as well.</p><p>请注意，以下示例适用于联合类型，但对于接口类型也同样适用。</p><p>  The  Centralized strategy allows you to discriminate your union member types in a centralized (to the union type) way. For example:</p><p>  集中式策略允许您以集中式（针对联合类型）区分工会成员类型。例如：</p><p> const SearchResult  =  unionType ( { name :  &#39;SearchResult&#39; ,  resolveType (data )  {  const __typename  = data .album  ?  &#39;Song&#39;  : data .rating  ?  &#39;Movie&#39;  : data .width  ?  &#39;Photo&#39;  :  null  if  ( !__typename )  {  throw  new   (  `Could not resolve the type of data passed to union type &#34;SearchResult&#34;` )  }  return __typename  } ,  definition (t )  { t . members ( &#39;Photo&#39; ,  &#39;Movie&#39; ,  &#39;Song&#39; )  } , } )</p><p> const SearchResult = unionType（{name：＆＃39; SearchResult＆＃39;，resolveType（data）{const __typename = data .album？＆＃39; Song＆＃39;：data .rating？＆＃39; Movie＆＃39; ：data .width？＆＃39; Photo＆＃39;：如果（！__ typename）{抛出新错误（`无法解析传递给并集类型＆＃34; SearchResult＆＃34;`的数据类型）}返回__typename} ，定义（t）{t。成员（＆＃39; Photo＆＃39;，＆＃39; Movie＆＃39;，＆＃39; Song＆＃39;）}}）</p><p>  The  Discriminant Model Field (DMF) strategy allows you to discriminate your union member types in a potentialy modular way. It is based on supplying at __typename field in the model data returned by resolvers of fields typed as an abstract type. Here is an example:</p><p>  判别模型字段（DMF）策略允许您以潜在的模块化方式来区分工会成员类型。它基于在类型为抽象类型的字段的解析程序返回的模型数据中提供__typename字段。这是一个例子：</p><p> const Query  =  queryType ( {  definition (t )  { t . field ( &#39;search&#39; ,  {  type :  &#39;SearchResult&#39; , args :  { pattern :  stringArg ( ) ,  } ,  resolve (root , args , ctx )  {  return ctx .db . search (args .pattern ) . map (result  =&gt;  {  const __typename  = result .album  ?  &#39;Song&#39;  : result .rating  ?  &#39;Movie&#39;  : result .width  ?  &#39;Photo&#39;  :  null  if  ( !__typename )  {  throw  new   (  `Could not resolve the type of data passed to union type &#34;SearchResult&#34;` )  }  return  {  ...result , __typename ,  }  } )  } ,  } )  } , } )</p><p> const Query = queryType（{definition（t）{t。field（＆＃39; search＆＃39;，{type：＆＃39; SearchResult＆＃39;，args：{pattern：stringArg（），}，resolve（root ，args，ctx）{返回ctx .db。搜索（args .pattern）。map（result =＆gt; {const __typename = result .album？＆＃39; Song＆＃39;：result .rating？＆＃39; Movie＆ ＃39 ;：结果.width？＆＃39; Photo＆＃39 ;：如果if（！__ typename）{抛出新错误（无法解析传递给并集类型＆＃34; SearchResult＆＃34;的数据类型））}返回{...结果，__typename，}}}}，}}}}）</p><p>  The  Modular strategy allows you to discriminate your union member types in a modular way (surprise). It uses a predicate function that you implement that allows Nexus (actually GraphQL.js under the hood) to know at runtime if data being sent to the client is of a respective type or not. Here is an example:</p><p>  模块化策略使您能够以模块化方式（惊奇）来区分工会成员类型。它使用您实现的谓词功能，使Nexus（实际上是GraphQL.js）在运行时知道发送到客户端的数据是否属于相应类型。这是一个例子：</p><p> const Movie  =  objectType ( { name :  &#39;Movie&#39; ,  isTypeOf (data )  {  return  Boolean (data .rating )  } ,  definition (t )  { t . string ( &#39;url&#39; ) t . field ( &#39;rating&#39; ,  {  type :  &#39;MovieRating&#39; ,  } )  } , } ) const Photo  =  objectType ( { name :  &#39;Photo&#39; ,  isTypeOf (data )  {  return  Boolean (data .width )  } ,  definition (t )  { t . string ( &#39;url&#39; ) t . int ( &#39;width&#39; ) t . int ( &#39;height&#39; )  } , } ) const Song  =  objectType ( { name :  &#39;Song&#39; ,  isTypeOf (data )  {  return  Boolean (data .album )  } ,  definition (t )  { t . string ( &#39;url&#39; ) t . string ( &#39;album&#39; )  } , } )</p><p> const Movie = objectType（{name：＆＃39; Movie＆＃39;，isTypeOf（data）{返回布尔值（data .rating）}，定义（t）{t。字符串（＆＃39; url＆＃39;）t 。field（＆＃39; rating＆＃39;，{type：＆＃39; MovieRating＆＃39;}}}}）const Photo = objectType（{name：＆＃39; Photo＆＃39 ;, isTypeOf（data ）{return Boolean（data .width）}，定义（t）{t。字符串（＆＃39; url＆＃39;）t。int（＆＃39; width＆＃39;）t。int（＆＃39; height＆＃39;}}}）const Song = objectType（{name：＆＃39; Song＆＃39;，isTypeOf（data）{return Boolean（data .album）}}，定义（t）{t。字符串（＆ ＃39; url＆＃39;）t。字符串（＆＃39; album＆＃39;）}}） </p><p> Read the  Abstract Types guide for details on how strategies work, are enabled or disabled, are type safe, and more.</p><p>阅读抽象类型指南，详细了解策略如何工作，启用或禁用，类型安全等。</p><p>  As you begin to implement a schema for the first time, you will notice something that may not have been obvious at first. The data that the client sees in the data graph is not the same data flowing through the internal resolvers used to fulfill that graph. The client sees the API types but the API author deals with something else, traditionally referred to as &#34;backing&#34; or &#34;root&#34; types in Nexus.</p><p>  第一次开始实现模式时，您会发现一开始可能并不明显。客户端在数据图中看到的数据与流经用于实现该图的内部解析器的数据不同。客户端可以看到API类型，但API作者需要处理其他内容，通常称为＆＃34; backing＆＃34;或＆＃34; root＆＃34;在Nexus中输入类型。</p><p> At Nexus 1.0, &#34;backing&#34; and &#34;root&#34; types are now globally referred to as &#34;Source Types&#34;.</p><p> 在Nexus 1.0上，＆＃34; backing＆＃34;和＆＃34; root＆＃34;现在，这些类型在全球范围内被称为＆＃34;来源类型＆＃34;。</p><p> Read the  Source Types guide to find out more about what they are and how to work with them.</p><p> 阅读源代码类型指南，以了解有关它们是什么以及如何使用它们的更多信息。</p><p>  Nexus 1.0 offers an improved  documentation experience including additional guides, better navigation, JSDoc support, and upgrades to the Nexus Playground.</p><p>  Nexus 1.0提供了更好的文档体验，包括更多指南，更好的导航，JSDoc支持以及对Nexus Playground的升级。</p><p>      The Nexus playground has been converted to a set of prepared Codesandbox examples. The new Playground offers a ready-to-go Nexus API that you can fork and extend.</p><p>      Nexus游乐场已转换为一组准备好的Codesandbox示例。新的Playground提供了现成的Nexus API，您可以将其扩展和扩展。</p><p>   Nexus 1.0 represents a significant milestone in the library&#39;s evolution. The community has played a crucial role in the its formation and success over the past 2+ years. We&#39;d like to thank everyone who has tried out Nexus, submitted issues and pull requests, and has put it into production!</p><p>   Nexus 1.0是该库发展过程中的重要里程碑。在过去两年多的时间里，社区在社区的形成和成功中发挥了至关重要的作用。我们要感谢所有试用Nexus，提交问题和提出请求并将其投入生产的人！ </p><p> Follow  @nexusgql on Twitter and watch  the repo to get future updates on what&#39;s happening with Nexus.</p><p>在Twitter上关注@nexusgql并观看回购，以获取有关Nexus情况的未来更新。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.prisma.io/blog/announcing-the-release-of-nexus-schema-v1-b5eno5g08d0b">https://www.prisma.io/blog/announcing-the-release-of-nexus-schema-v1-b5eno5g08d0b</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/graphql/">#graphql</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>