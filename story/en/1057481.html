<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Simhashing（希望）简单（2012） Simhashing (Hopefully) Made Simple (2012)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Simhashing (Hopefully) Made Simple (2012)<br/>Simhashing（希望）简单（2012） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-10 20:14:17</div><div class="page_narrow text-break page_content"><p>When it comes to figuring out how similar various pieces of data are from one another (and which is the closest matching one in a large group of candidates), simhashing is one of my favourite algorithms. It&#39;s somewhat simple, brilliant in its approach, but still not obvious enough for most people (myself included) to come up with it on their own. Readers may be familiar with hashing algorithms such as MD5 or SHA, which aim to very quickly create a unique signature (hash) of the data. These functions are built so that identical files or blobs of data share the same hash, so you can rapidly see whether two blobs are identical or not, or if a blob still has the same signature after transmission to see if it was corrupted or not. Then different blobs, even if mostly the same, get an entirely different signature.</p><p>朝着弄清楚不同的各种数据彼此有何相似（并且哪个是大量候选人中最近的匹配），偶数是我最喜欢的算法之一。它＆＃39;在它的方法中有点简单，辉煌，但对于大多数人（我所包括的人）来说仍然不够明显。读者可能熟悉散列算法，例如MD5或SHA，其旨在非常快速地创建数据的唯一签名（哈希）。构建了这些功能，以便数据的相同文件或斑点共享相同的哈希，因此您可以快速查看两个斑点是否相同，或者如果在传输之后仍然存在相同的签名，请查看它是否已损坏或不具有相同的签名。然后是不同的斑点，即使大多数相同，也得到了完全不同的签名。</p><p> While simhashes still aim to have unique signatures for documents, they also attempt to make sure that documents that look the same get very similar hashes. That way, you can look for similar hashes to figure out if the documents are closely related, without needing to compare them bit by bit. It&#39;s a statistical tool to help us find near-duplicates faster.</p><p> 虽然Simhashes仍然旨在具有唯一的文档签名，但他们还试图确保看起来同样相同的哈希文档。这样，如果文档密切相关，则可以查看类似的哈希值，而无需将它们与位进行比较。它＆＃39;统计工具，以帮助我们更快地找到近复制。</p><p> That&#39;s a bit vague, but that&#39;s alright. I&#39;ll try to explain things in a way that gives a good understanding of things.</p><p> 那个＆＃39;有点模糊，但是，＆＃39;好吧。我＆＃39;请试图以一种良好理解的方式解释事物。</p><p>  Let&#39;s first take a look at ASCII. The character &#39;a&#39;, in ASCII, is the number 97, or in a binary representation, 01100001. All letters of the basic English alphabet can be represented that way:</p><p>  让＆＃39;首先看看ASCII。 ASCII中的字符＆＃39; A＆＃39;，AS＆＃39;，是第97号，或者在二进制表示中，01100001.基本英文字母的所有字母都可以表示：</p><p>  This is nothing new to most programmers out there. I could also represent entire words with sequences of these binary values:</p><p>  这对大多数程序员来说都不是新的。我还可以代表具有这些二进制值的序列的整个单词：</p><p>  Some readers will be able to read binary and ASCII straight away and know what these words are. We can easily see that the first 3 most significant bits (on the left) of all letters are the same, and we could discard them, getting:</p><p>  一些读者可以直接阅读二进制和ascii，知道这些词是什么。我们可以很容易地看到所有字母的前3位（左侧）都是一样的，我们可以丢弃它们，获取：</p><p>  If I were to ask you to group these words in two pairs of most similar to each other, chances are that you would put #1 and #3 together, and #2 and #4 together. You would be right to do so. The four words, in order, are &#34;banana&#34;, &#34;bozo&#34;, &#34;cabana&#34;, and &#34;ozone&#34;.</p><p>  如果我要在两对彼此相似的两对中将这些单词组分组，那么你将把＃1和＃3放在一起，＃2和＃4在一起。你会这样做。四个字，按顺序，是＆＃34;香蕉＆＃34 ;,＆＃34; bozo＆＃34 ;,＆＃34; cabana＆＃34 ;,＆＃34; ozone＆＃34; </p><p> By looking at the binary patterns, our brains are able to figure out a few things naturally. The position of each bit, the length of the word, the repetition of sequences of bits, and how &#39;light&#39; or &#39;dark&#39; a column looks are a few things we may pick up as some kind of signature of each word.</p><p>通过查看二进制模式，我们的大脑能够自然地弄清楚一些事情。每个比特的位置，单词的长度，重复位的比特序列，以及如何＆＃39;光＆＃39;或＃39;黑暗＆＃39;一列看起来是我们可能作为每个单词的某种签名的一些东西。</p><p> What&#39;s interesting is that each of these signatures is unique, yet we&#39;re somehow able to figure out how similar they are based on that. Compare this to the following four MD5 hashes of the same strings:</p><p> 什么＆＃39;很有趣的是，这些签名中的每一个都是独一无二的，但我们＆＃39;重新弄清楚他们是如何基于这一点的。将此与以下四个MD5散列进行比较：</p><p>  There&#39;s no way to know at a glance which is closer to the other. Again, there&#39;s nothing surprising there, given MD5 is not meant for hashes to be similar.</p><p>  ＆＃39;没有办法一目了然地知道哪个更近的。再次，在那里没有任何令人惊讶的是，给定MD5并不意味着哈希相似。</p><p> While our visual layout was nice to figure out how to match short words together, it&#39;s utterly impractical to use such visual signatures in a general manner -- programming software to recognize them the way a human would would take forever, and it would be slower than just comparing letters one by one.</p><p> 虽然我们的视觉布局很高兴地弄清楚如何将短文字匹配，它完全不切实际地用一般的方式使用这种视觉签名 - 编程软件以识别人类将永远占用的方式，而且它比仅比较一个字母逐渐比较慢。</p><p> What we have, though, is the idea that using the binary representation of a blob of data may be enough to create a decent signature that does respect similarity -- a simhash.</p><p> 但是，我们拥有的是，使用BLOB的二进制表示的想法可能足以创建一个尊重相似性的体面签名 - 一个simhash。</p><p> What could be nice would be to be able to compress the information a bit, so it&#39;s a bit more obvious what it contains. We could build a histogram of all the binary values: add 1 for each bit set to 1 in a column, the rest is skipped. This could give us an interesting layout, a bit like follows (I&#39;m making bars horizontal):</p><p> 什么可能很好就是能够压缩信息一点，所以它＆＃39;它有点明显它包含的内容。我们可以构建所有二进制值的直方图：在列中设置为1的每个位的1，跳过其余部分。这可能给我们一个有趣的布局，有点像如下（我制作酒吧水平）：</p><p>  That&#39;s not very good. The problem is that we&#39;re only looking at half the data. We&#39;re discarding all the 0 bits. Let&#39;s try doing it by pretending each empty bit (white square) is worth -1, and that others (black squares) are worth +1. We could represent things like sums:</p><p>  那个＆＃39;不是很好。问题是我们＆＃39;只看一半的数据。我们＆＃39;重新丢弃所有0位。让＆＃39;尝试通过假装每个空位（白方形）值-1，其他人（黑色方块）值得+1。我们可以代表Sums： </p><p>  Let&#39;s try it a bit more visually, representing each sum as a little histogram, again:</p><p>让＆＃39; S比视觉更重要，将每个总和表示为一点直方图，再次：</p><p>  It&#39;s now easier to see which is closest to which, if you squint right. It may even be easier to do so than when we had the full patterns in view, and we&#39;re doing it with a fraction of the data we had before. We&#39;re getting a decent signature.</p><p>  它＆＃39; s现在更容易看到最接近哪个，如果你眯着眼睛。它甚至可能更容易，而不是在观看中拥有完整的模式时，我们＆＃39;重新完成我们之前的数据的一小部分。我们＆＃39;获得一个体面的签名。</p><p> Let&#39;s push it a bit further. I&#39;ll take each of these final histograms, and for each value above or equal to 0, I&#39;ll fill a bit. For each value under 0, I&#39;ll leave it empty. My four signatures are now:</p><p> 让＆＃39; s进一步推动它。我＆＃39; ll取决于这些最终直方图，每个值高于或等于0，i＆＃39; ll填充一点。对于0下的每个值，i＆＃39; ll离开它。我的四个签名现在是：</p><p>  Hot damn, that worked fine. In this case, we  instantly see which are to be paired together. 1 and 3 obviously fit together, given they&#39;re the same, and 2 and 4 go together, as they get the same signature.</p><p>  热门炎热，工作正常。在这种情况下，我们立即看到要配对在一起。 1和3显然适合在一起，鉴于它们＆＃39;重复相同，2和4一起走，因为它们得到了相同的签名。</p><p> How would we find the distance between signatures when none of them are identical? If we had a piece of data resulting in the hash 10011, which one would it be the closest to? It turns out that using the  Hamming Distance is a decent way of doing it. The Hamming Distance is, in a nutshell, a way to look at two sequences of numbers, letters, or whatever piece of data, and see how different they are. With a bunch of groups of bits of the same length, it&#39;s done by looking at them one by one. Every time they&#39;re different, we add 1 to the hamming distance. If they&#39;re the same, we leave it as is. As such, the Hamming Distance between our two previous signatures and our new pattern is:</p><p> 我们如何在其中不相同时发现签名之间的距离？如果我们有一段数据导致散列10011，那将是最接近的？事实证明，使用汉明距离是一种做到的方式。汉明距离是一种简而言之，一种方式来看看两个数字，字母或任何数据序列，并看看它们是多么不同。通过一群相同的长度组，它通过一个接一个地看待它们而完成。每次他们＆＃39;重复不同，我们加1到汉明距离。如果他们＆＃39;重新相同，我们会像它一样离开它。因此，我们两个先前签名与我们的新模式之间的汉明距离是：</p><p>  Our new pattern has a hamming distance of 1 compared to signatures 1 and 3, and a distance of 3 compared to signatures 2 and 4. As such, we can say that the new signature is likely to be more similar to 1 than 2.</p><p>  与签名1和3相比，我们的新图案的汉明距离为1，与签名2和4相比，我们可以说新的签名可能与1比2更类似于1。</p><p> Now it&#39;s well possible that things are very similar according to our current simhashing without looking that way to the human eye -- the string &#34;sssss&#34; would have given us a signature closer to &#34;banana&#34; than &#34;bozo&#34;, for example, with a distance of 1. There are good explanations for that.</p><p> 现在它＆＃39;因为我们目前的偶像，事情非常相似，而不是那种对人眼的方式 - 弦＆＃34; sssss＆＃34;会给我们签名更接近＆＃34;香蕉＆＃34;比＆＃34;例如，Bozo＆＃34;，距离1.有很好的解释。 </p><p>  We just implemented a very, very basic version of the simhash algorithm. Why what we did works requires a bit of math. This is where the simhash papers tend to flex their statistical muscles. To make it short and overly simple, when we take fragments of an entire binary blob (here we took segments of 6 bits out of a stream of ones and zeroes), we&#39;re taking some kind of snapshot of the whole thing, and giving it weight based on how often it happens.</p><p>我们刚刚实现了一个非常非常基本的SimHash算法版本。为什么我们所做的工作需要一些数学。这就是Simhash论文倾向于弯曲统计肌肉的地方。为了使它短而过于简单，当我们拍摄整个二进制斑点的碎片时（这里我们从一个Zeroes流中拿出6位的片段），我们＆＃39;重新服用整件的某种快照，并根据它发生的频率来提供体重。</p><p> Let&#39;s look at our words again, but this time, by sorting letters by their most significant bits:</p><p> 让＆＃39再次看看我们的话，但这一次，通过他们最重要的比特排序来排序：</p><p>  This makes it a bit easier to see how the frequency of each letter (or rather, each  feature, as the papers call them) has an impact on the final value. If we have many identical letters (features), no matter their order, then the chances are signatures look rather similar in the end when we &#39;collapse&#39; the whole thing into a tiny 5-bit hash.</p><p>  这使得有点易于了解每个字母的频率（或者更确切地说，每个特征，因为论文称为他们）对最终值的影响。如果我们有许多相同的字母（特征），无论他们的订单，那么当我们＆＃39时，机会就会看起来相当相似;折叠＆＃39;整个东西变成了一个微小的5位哈希。</p><p>  If the order of features is not important, how do we make it understand that strings like &#34;hahahahaha!&#34; have a somewhat different meaning from &#34;aaaaaaahhhhhhh!&#34;?</p><p>  如果功能的顺序并不重要，我们如何使其了解＆＃34;哈哈哈哈！＆＃34;从＆＃34有一种不同的意义; aaaaaahhhhhhh！＆＃34 ;?</p><p> What do we do when letters that are way different have a rather similar binary representation? It would kind of suck that &#34;cc&#34; is seen as similar to &#34;bababababa&#34;, as they should give a very similar signature under our current scheme.</p><p> 当与不同的二进制表示相当类似的方式时，我们会做什么？这有点糟糕，＆＃34; cc＆＃34;被视为类似于＆＃34; Bababababa＆＃34 ;,因为他们应该在我们目前的计划下提供非常相似的签名。</p><p> How can we deal with data that is not ASCII text, where features may be of varying sizes?</p><p> 我们如何处理非ASCII文本的数据，其中功能可能会有不同的大小？</p><p> In fact, these three questions are somewhat related to figuring out a way to make significant hashes be longer than 5 or 8 bits, and giving it a regular length.</p><p> 事实上，这三个问题有点符合讨论散发比5或8位长的方式，并给予规则的长度。 </p><p>  The first easy way to improve the distribution of the bits in our feature is to pass them through some kind of function that keeps unique values, but makes them vary a lot even when they&#39;re similar. Does this ring a bell?</p><p>提高我们特征中的比特分布的第一种简单方法是通过某种函数来传递唯一的函数，但即使它们也使它们变化很大。这是铃铛吗？</p><p> Hashing algorithms like MD5, SHA, or even your common hashmap&#39;s hashing function will do this just fine. In fact, passing a letter through a MD5 hashing algorithm will give me 128 bits of data that is not too likely to be similar to the one obtained from other values. What&#39;s nice is that it will also let me take larger features (say a Unicode sequence of code points that requires multiple bytes to be represented) and give it the same weight as an ASCII character.</p><p> 散列算法如MD5，SHA，甚至是您的常见散列＆＃39; S Hashing函数将这样做。事实上，通过MD5散列算法传递一个字母将给我提供128位数据，这些数据不太可能与其他值获得的数据相似。什么＆＃39;很好的是它也将让我采取更大的功能（例如，需要表示需要多个字节的代码点序列），并给它与ASCII字符相同的权重。</p><p> By passing each feature (no matter what its size is) through a normal hashing function, we allow to give them all an identical weight. We can then calculate our simhash the same way we did earlier, but with the binary values from the new intermediary hash function.</p><p> 通过通过普通散列函数传递每个特征（无论其尺寸是什么），我们允许给它们所有相同的重量。然后，我们可以以前的方式计算我们的Simhash，但是使用新的中间哈希函数的二进制值。</p><p> This is interesting because if I do that, instead of using letters, I may as well use words for my simhash. Maybe the word &#34;cat&#34; will give me 01011001010111, and that &#34;romanesque&#34; will give me 01000101001101. It will then be possible to build simhashes out of much larger vocabularies by choosing what we consider to be a feature, and what isn&#39;t.</p><p> 这很有意思，因为如果我这样做，而不是使用字母，我也可以为我的simhash使用单词。也许这个词＆＃34; cat＆＃34;将给我010110010111，那个＆＃34;罗马式和＃34;将给我01000101001101。然后可以通过选择我们认为是一个特征，以及什么＆＃39; t。</p><p> We could solve the &#34;aaaaaaahhhhh!&#34; versus &#34;hahahahaha!&#34; problem by making syllables a feature: &#34;ah&#34; and &#34;aa&#34; and &#34;hh&#34; and &#34;!&#34; could be seen as different features. We would then be guaranteed a different result than if we took everything letter by letter.</p><p> 我们可以解决＆＃34; aaaaaahhhhh！＆＃34;与＆＃34;哈哈哈哈！＆＃34;通过制作音节的问题：＆＃34;啊＆＃34;和＆＃34; aa＆＃34;和＃34; hh＆＃34;和＃34;！＆＃34;可以被视为不同的特征。然后我们将保证不同的结果，而不是我们通过信函拿走一切信。</p><p> The second aspect of it is being able to give a weight to each feature. Let&#39;s imagine for a moment that we have 3 files on disk:</p><p> 它的第二方面是能够对每个特征提供重量。假设我们想象一下，我们在磁盘上有3个文件：</p><p>  We want to simhash them according to their  content, not their binary representation on disk. If we use simhashing over the whole file, we&#39;ll find out that the two PDF files are seen as very similar. That&#39;s because PDF is a heavier format than a .txt file, with metadata, headers, and some common structure that will overweight the content in many cases.</p><p>  我们想根据他们的内容偶发它们，而不是它们在磁盘上的二进制表示。如果我们在整个文件中使用Simhashing，我们会发现两个PDF文件被视为非常相似。那个＆＃39; s是因为pdf是比.txt文件更重的格式，具有元数据，标题和一些常见结构，这些结构将在许多情况下超重内容。 </p><p>   For a human reading this, it might be preferable to have sentences 1 and 3 closer together as they clearly talk about white cats in trees, whereas the sentence 2 is about something else entirely. Here are all the (fictional) hashes for the words in these sentences:</p><p>对于人类阅读这一点，可能更优选的是在树木中清楚地谈论白色猫，而句子2完全是关于别的东西的句子。以下是这些句子中的单词的所有（虚构）哈希：</p><p>  The three sentences can then have the following signatures (which I pre-sorted to make them easier to deal with):</p><p>  然后，这三个句子可以具有以下签名（我预先排序，使它们更容易处理）：</p><p>    Based on this one, sentences 1 and 2 are very close. How can we bring it the meaning we want? The solution is to create  weighed features. To do this, I could take words used frequently, with little meaning in the sentence like &#39;a&#39;, &#39;the&#39;, and &#39;in&#39; and give them a weight of 1, and take more unusual words like &#39;man&#39;, &#39;happy&#39;, or &#39;cat&#39; and give them a weight of 3.</p><p>    基于这一点，句子1和2非常接近。我们怎样才能带来我们想要的意义？解决方案是创建称重的功能。要做到这一点，我可以常常用句子，在句子中的少数意义＆＃39;一个＆＃39;和＃39;和＃39;＆＃39;并给他们一个体重1，并采取更不寻常的单词，如＆＃39;男人＆＃39; happy＆＃39;或＆＃39; cat＆＃39;并给予他们的重量为3。</p><p> When counting values, instead of doing +1 or -1, I do +Weight or -Weight, effectively giving me the following signatures:</p><p> 计数值时，而不是执行+1或-1，我做+重量或 - 重量，有效地给我以下签名：</p><p>    And as we hoped, strings 1 and 3 are now the closest with a Hamming distance of two.</p><p>    正如我们希望的那样，弦1和3现在最接近两个汉明距离。</p><p>  No, not really. As far as simhashing is concerned, that&#39;s it! The complexity now lies in figuring out ways to build &#39;vocabularies&#39; (dictionaries of weighted features) that are relevant to what we&#39;re trying to match: if you&#39;re interested in the structure of XML documents but not their text, serializing tree hierarchies and node types as features may be an approach that makes more sense to you than for someone who&#39;s looking to know if the textual content of an HTML site changed or not even when the structure itself changed.</p><p>  不，不是真的。就偶数而言，它＆＃39;它！现在的复杂性在于弄清楚建立＆＃39;词汇和＃39; （加权功能的字典）与我们尝试匹配的东西相关：如果您＆＃39;重新对XML文档的结构感兴趣，但不是它们的文本，序列化树层次结构和节点类型作为特征可能是一种方法这对你来说比＆＃39所希望知道了解HTML站点的文本内容是否更改了，这更加有意义，即使结构本身也改变了。</p><p> Building good vocabularies is where a huge part of the challenge lies when it comes to making simhashes useful. The other tricky area is figuring out how to be able to quickly match simhashes together. Comparing a ton of simhashes together to find the best matches still is a complex problem the same way it would be without simhashes: what you gain, however, is how much space it takes to store all the items to compare, and how long each comparison will be. For big files, it&#39;s quite an improvement already, but it won&#39;t compensate for large values of  N if you have an  O(n²) algorithm to compare everything. There are a few papers freely available on the question if you&#39;re interested.</p><p> 建立良好的词汇表是在让偶像有用的时候挑战的巨大部分挑战的地方。另一个棘手的区域是如何能够快速将Simhash匹配在一起。将一大吨的Simhash与众不同地找到最佳匹配仍然是一个复杂的问题，就像没有偶像一样的方式：但是，您收益的收益是多少来存储所有物品来比较，以及每个比较多长时间将。对于大档案，它已经＆＃39; S已经完全改进，但是它赢得了＆＃39;如果您有一个o（n²）算法来比较一切，请补偿n的大值。如果你＆＃39;遗嘱感兴趣，有几篇论文可以自由地提供。 </p><p> I hope I managed to make simhashing understandable and interesting as an algorithm. There are all kinds of interesting applications where simhashes could shine, from trying to figure out how similar data structures are, finding out if the layout or the content of a website you scrape changed,  detecting spam[PDF] or  real-time merging of near-duplicate log events.</p><p>我希望我设法使偶发可以理解和有趣作为算法。 有各种有趣的应用程序，偶发可以闪耀，试图弄清楚如何数据结构是如何，发现您刮擦的网站的布局或内容是否改变，检测垃圾邮件[PDF]或附近的实时合并 -Duplicate日志事件。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ferd.ca/simhashing-hopefully-made-simple.html">https://ferd.ca/simhashing-hopefully-made-simple.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/方式/">#方式</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>