<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>网络浏览器中IPFS连接指南</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">网络浏览器中IPFS连接指南</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-25 19:02:02</div><div class="page_narrow text-break page_content"><p>我们看到了很多关于如何开始在浏览器中使用js ipfs的问题。本文演示了一个完全在浏览器中使用js ipfs的聊天示例。它使用WebRTC在可能的情况下实现浏览器到浏览器的连接，并使用电路中继在不可能的情况下连接浏览器节点。消息传递是通过libp2p和#39完成的；酒吧。</p><p>你可以在这里看到实时演示（打开新窗口）。如果你&#39；我想要一份本地副本，你可以自己编辑，你可以使用IPFS下载整个目录：</p><p>然后简单地打开索引。网页浏览器中的html和你&#39；我们将立即开始自动连接到节点并寻找对等节点！</p><p>你也可以在GitHub上打开Discordian/browser ipfs聊天（打开新窗口），它&#39；I’我马上就准备好测试！如果您想部署自己的版本，只需编辑索引即可。并按照下面的设置信息进行操作。</p><p>本例中使用的库是js ipfs（打开新窗口）和Bootstrap（只是它们的缩小CSS）。如果你想要更新版本的js ipfs，可以在这里下载（打开新窗口）以使用最新版本😃.</p><p>在浏览器中，发现和连接同龄人可能非常困难，就像我们一样&#39；不要倾听新同事的声音，我们也不会&#39；我无法使用DHT。为了获得在浏览器中工作的最佳体验，它&#39；了解如何找到同龄人并与他们保持联系很重要。</p><p>聊天示例通过两种方式实现这一点。使用WebRTC星，实现了浏览器与浏览器的直接通信，并通过电路继电器，在中间有一个继电器。聊天应用程序在左上角还有一个状态指示器，可以让你知道你的连接类型。绿色意味着你&#39；重新连接到继电器，即使它&#39；通过另一个同龄人；黄色表示你&#39；我们只看到直接的同龄人；红色表示你没有同伴（至少没有使用聊天应用程序的同伴）。</p><p>🌟 上图展示了三用户网络的样子。它&#39；值得注意的是，浏览器节点也可以与go IPF通信，因此BrowserC不&#39；不必是浏览器，但可以是go ipfs节点！</p><p>在本节之后，我们&#39；我将介绍WebRTC Star和电路继电器的功能，以及如何设置它们。然而，如果你&#39；我想用Docker，I&#39；我准备了一张你可以使用的图片。这可能不是最好的长期解决方案，但如果你想快速开始并进行实验，这应该是很好的。</p><p>您需要一个域和SSL才能将此工具包与浏览器节点一起使用。下面有两个选项：一个将运行certbot并自动获取所提供域名的证书。另一个选项赢了&#39；我不能为你处理SSL，相反，你&#39；我们必须将代理端口9091反转为9090（SSL），将端口4011反转为4430（SSL）。</p><p>当您执行任一命令时，您的IPFS节点也将第一次被设置，为您提供其对等地址和电路中继地址等信息。注意这些——你&#39；I’我想将它们编辑到聊天客户端，这样你就可以使用自己的节点（参见WebRTC Star Usage和p2p circuit Usage了解用法示例，或者编辑index.html并将my node&#39；s multiaddresses更改为你自己的）。</p><p>确保端口80为&#39；如果正在使用，请遵循下面的检查表，然后运行以下命令：</p><p>docker run——mount source=ipfs_bundle，destination=/root-p9091:9091-p4011:4011-p9090:9090-p4430:4430-p80:80-it trdiscordian/ipfsbundle certbot域。组件对象模型</p><p>如果您选择此选项，则容器将赢得&#39；根本无法处理SSL，而您&#39；我们必须将代理端口9091反转为9090（SSL），将端口4011反转为4430（SSL）。</p><p>确保域正确地指向您的机器&#39；在上重新运行容器（子域也可以正常工作）</p><p>一旦你&#39；重新配置后，运行容器很简单。确保至少转发端口4430和9090。</p><p>🎉 现在，您应该可以将该机器用作WebRTC星形节点和p2p电路节点。</p><p>我们可以使用WebRTC Star（打开新窗口）节点来帮助发现我们可以直接通过浏览器到浏览器连接的其他节点。我发现很容易将其视为类似于STUN（打开新窗口），如果你&#39；我们已经熟悉这个概念了。实际上，每个连接节点都将获得一个WebRTC星形多地址（打开新窗口），其他节点可以使用该地址直接发现并连接到浏览器。这意味着，如果你与使用星型节点的人进行对等，而星型节点离线，你将保持连接！</p><p>ipfs=等待ipfs。创建（{repo:&#39；ok&#39；+Math.random（），//random，这样我们每次都会得到一个新的peerid，用于测试配置：{Addresses:{Swarm:[&#39；/dns4/star.thedisco.zone/tcp/9090/wss/p2p webrtc star#39；&#39；/dns6/star thedisco.zone/tcp/9090/wss/p2p webrtc star 39；}，}）；</p><p>请注意，这个例子使用了我自己的星型节点——然而，这些节点赢了&#39；在那里不一定总能找到。目前为&#39；重要的是找到一个可靠的星型节点或自己的主机。您只需按照此处的说明（打开新窗口）进行本机设置，并按照此处的说明（打开新窗口）进行Docker容器的托管，该容器包含Nginx（用于SSL）。如果您选择本机设置，我们将在本文后面介绍Nginx反向代理过程和SSL证书检索。</p><p>🚀 这是一种非常干净有效的P2P通信方法；然而，有时NAT会碍事。我们使用p2p电路（打开新窗口）来解决这个问题。</p><p>使用p2p circuit对复杂的NAT（或VPN，或其他任何东西）背后的对等方来说真的很有帮助。我发现p2p电路的中继类似于TURN（打开新窗口），所以它&#39；如果你&#39；我们已经很熟悉了。</p><p>一旦p2p电路的所有服务都放在一起，就可以通过几种不同的方式连接到节点。首先，要在启动时仅连接到我们的节点：</p><p>如果你&#39；如果你希望在不复制示例的情况下开发自己的客户，请确保&#39；重新与公告频道进行沟通，详见广告部分。聊天演示中的相关代码如下（简化）：</p><p>var ipfs；//存储您需要的IPFS节点&#39；在这个变量中重新使用//通过pubsub异步函数processannound（addr）{//get our peerid me=await ipfs.id（）；me=me.id；//如果它是从我们这里发出的，那么它就不是真正的通告，如果（addr.from==me）{return；}如果我们有一个keep alive，如果（addr==&#34；keep alive&#34；）就没什么可做的了{console.log（addr）；return；}peer=addr。拆分（&#34；/&#34；）[ 9 ] ; 安慰日志（&#34；对等：&#34；+对等）；安慰日志（&#34；Me:&#34；+Me）；if（peer==me）{//return如果所宣布的peer是us return；}//获取对等点列表=等待IPF。一大群同龄人（）；对于（对等体中的i）{//如果我们已经连接到对等体，那么不要费心做//电路连接，如果（对等体[i].peer==peer）{return；}//在我们&#39；我们将尝试连接控制台。日志（地址）；//连接几乎总是第一次失败，但几乎总是//第二次成功，所以我们这样做：尝试{wait ipfs.swarm.connect（addr）；}catch（err）{console.log（err）；wait ipfs.swarm.connect（addr）；}}//通过中继网络处理公告，并发布我们自己的//keep alives以保持频道的活力，等待IPF。pubsub。订阅（&#34；公告电路&#34；，流程公告）；setInterval（函数（）{ipfs.pubsub.publish（&#34；公告电路&#34；，&#34；对等活动&#34；）；），15000 ) ;</p><p>与星形节点一样，它&#39；We’重要的是，你可以自己管理自己的东西，因为这篇文章中的东西随时都可能离线。</p><p>在本例中，您&#39；我需要在托管自己的go ipfs（打开新窗口）节点的服务器上执行一些操作。你&#39；我还需要一个正常工作的Nginx安装程序，它将用于SSL，这是浏览器的一个要求。</p><p>首先配置Go节点，启用WebSocket（打开新窗口）支持，并将其指定为中继，以便我们可以通过编辑~/从浏览器与它通信。ipfs/config以添加以下设置：</p><p>{&#34；地址&#34；：{&#34；Swarm&#34；：[&#34；/ip4/0.0.0/tcp/4011/ws&#34；，&#34；/ip6/：：/tcp/4011/ws&#34；]&#34;Swarm&#34；：{&#34；EnableRelayHop&#34；：true}</p><p>以正常方式重新启动go ipfs节点（可能是systemctl——用户重新启动ipfs），我们&#39；我们已经准备好了！我们&#39；我们已经启用了具有中继支持的常规WebSocket，但是我们需要安全的WebSocket（在下面的SSL部分中概述）——否则浏览器将赢得&#39；我无法与我们联系。</p><p>使用p2p电路可能有点棘手。一旦我们从浏览器连接到中继，我们&#39；我们不是在宣传我们&#39；我们可以通过它联系到你！为此，我&#39；我创建了一个Python脚本，它与go ipfs一起运行，并用一个p2p回路多地址（打开新窗口）在PubSub（打开新窗口）上公布它遇到的浏览器js ipfs对等点。</p><p>您可以在这里找到Python脚本（打开新窗口）。它可以用一个简单的python ipfs_peeradvertiser运行。皮耶。但是，请确保首先使用自己的节点编辑回路&#39；这是你的信息，否则你赢了&#39；没有正确地宣布同龄人，他们赢了&#39；我不知道如何使用中继连接到其他同龄人。</p><p>你可以很容易地检索自己的电路信息。只需在go ipfs节点上运行ipfs id即可获得PeerID，然后按如下方式形成回路URL：</p><p>你应该在这里看到，你只需填写你获得SSL证书的域名，以及你的节点&#39；这是皮利德。对于脚本，前导斜杠和尾随斜杠也是必需的。</p><p>确保指定DNS6或DNS4，具体取决于&#39；正在重新形成IPv6或IPv4地址。它&#39；确保使用DNS很重要，否则浏览器节点可能会赢#39；我无法连接。还要注意端口4430；如果你用了另一个，你&#39；我需要具体说明一下。</p><p>到目前为止，我们&#39；ve设置不带SSL的WebRTC Star和p2p电路（除非使用WebRTC Star docker设置）。如果你想在互联网上通过浏览器使用你的节点，它们需要支持SSL。如果你&#39；重新使用默认设置当前WebRTC Star应在端口9090（无SSL）上运行，p2p电路将在端口4011（无SSL）上运行。我们&#39；我们将把它们分别放在端口9091（SSL）和端口4430（SSL）上。</p><p>我们&#39；我们将从下面的模板创建两个文件。确保你&#39；重新编辑像YOURDOMAIN这样的条目。COM与您计划用于服务的完整域（包括子域）进行通信。</p><p>map$http#u upgrade$connection#u upgrade{default upgrade；&#39；&#39；close；}上游ipfs{server127.0.0.1:4011；}服务器{server_name YOURDOMAIN.COM；listen 4430 ssl；ssl_certificate/etc/letsencrypt/live/YOURDOMAIN.COM/fullchain.pem；ssl_certificate_key/etc/letsencrypt/live/YOURDOMAIN.COM/privkey.pem；位置/{proxy_set_header X-Forwarded-For$proxy_add_X_Forwarded_For；proxy_pass http://ipfs；proxy_http_version 1.1；proxy_set_header Upgrade$http_Upgrade；proxy_set_header Connection$Connection_Upgrade；proxy_set_header Host$Host；}</p><p>map$http#u upgrade$connection#u upgrade{default upgrade；&#39；&#39；close；}上游星型{Server127.0.0.1:9090；}服务器{server_name YOURDOMAIN.COM；listen 9091 ssl；ssl_certificate/etc/letsencrypt/live/YOURDOMAIN.COM/fullchain.pem；ssl_certificate_key/etc/letsencrypt/live/YOURDOMAIN.COM/privkey.pem；位置/{proxy_set_header X-Forwarded-For$proxy_add_X_Forwarded_For；proxy_pass http://star；proxy_http_version 1.1；proxy_set_header Upgrade$http_Upgrade；proxy_set_header Connection$Connection_Upgrade；proxy_set_header Host$Host；}</p><p>在这个例子中，你可以看到我们&#39；重新接受端口4430上的SSL-这是我们的&#34；wss端口&#34；（WebSocket安全）-然后在4011本地将其传递到不安全的端口-这是我们的&#34；ws-port&#34；。所以如果我们想从浏览器连接到这个节点，我们&#39；d使用端口4430。</p><p>sudo systemctl stop nginx sudo certbot-d YOURDOMAIN。COM--独立#编辑你的域名。COM到您想要证书的域，如果需要多个，请填写多个或多次运行命令sudo ln-s/etc/nginx/sites available/ipfs/etc/nginx/sites enabled/ipfs sudo ln-s/etc/nginx/sites available/star/etc/nginx/sites enabled/star sudo systemctl start nginx</p><p>唷！既然你走了这么远，你可能会想&#34；沟通是什么样的&#34; 幸运的是，答案是&#39；与寻找同龄人相比，这很容易，只有一些小缺陷。我们&#39；我们将简单介绍一下我们&#39；在聊天示例中重新使用PubSub（打开新窗口），以及在开发过程中发现了哪些陷阱。</p><p>使用PubSub，我们&#39；我们可以订阅主题并检索发布到这些主题的任何消息。在js ipfs中，我们可以设置一个回调函数，在收到消息时调用该函数：</p><p>这实际上就是聊天演示所做的。它&#39；s订阅一个全球主题（名为&#34；discochat global&#34；），简单地传递人们在PubSub上键入的信息。</p><p>所以让我们&#39；比如说你&#39；我一切都做对了。你&#39；我们可以使用WebRTC Star和p2p circuit找到同龄人——太棒了！然而，你可能会发现你的连接过期了，你&#39；我们无法恢复它们。我&#39；我不完全确定是什么导致了这种行为（可能是一些浏览器策略）；然而，我们可以尽最大努力缓解这些问题！</p><p>我们通过几种方式与同龄人保持联系。第一种方式更直接：订阅并发送&#34；保持活力&#34；每4秒通过discochat keepalive发布一次公告：</p><p>这将有助于确保我们优先考虑希望聊天的同龄人。此外，我们每15秒报告一次电路，以确保我们与电路继电器保持连接，以便我们可以连接到NAT后面的对等方。那&#39；他是这样完成的：</p><p>//通过中继网络处理公告，并发布我们自己的keep alives，以保持频道的活力，等待IPF。pubsub。订阅（&#34；公告电路&#34；，流程公告）；setInterval（函数（）{ipfs.pubsub.publish（&#34；公告电路&#34；，&#34；对等活动&#34；）；），15000 ) ;</p><p>电路继电器上的Python脚本将每4秒报告一次keepalive。你可能已经注意到我们&#39；重新报告&#34；活着的同伴&#34；而不是&#34；保持活力&#34；；这是为了将对等请求与中继请求分开，以便在我们不再看到中继时更容易判断。</p><p>除了ProcessAnnound的简化版本外，在真实版本中，还有一些用于跟踪keep alive和peer alive的变量。它们分别是lastAlive和lastPeer。我们甚至通过lastBootstrap跟踪上次引导的时间。使用所有这些，我们可以在&#39；我们只连接到对等点（通过lastPeer跟踪），如果我们不连接&#39；在35秒内没有看到保持活动状态（我们在60秒内没有尝试过引导），我们可以尝试重新连接引导继电器（并显示红色状态）。这是这样完成的：</p><p>const bootstraps=[&#39；/dns6/ipfs.thedisco.zone/tcp/4430/wss/p2p/12d3koowchhfgdb9gj1gbhghakcur99ocymmevs4eucey67nt&#39；&#39；/dns4/ipfs.thedisco.zone/tcp/4430/wss/p2p/12d3koowchhfgdb9gy1gbhghakcur99ocymmevs4eucey67nt&#39；]；var lastAlive=0；//我们从继电器var lastPeer=0看到的最后一个保持活动状态；//上次我们从另一个对等服务器上看到的保持活动var lastBootstrap=0；//用于跟踪上次尝试引导时（可能重新连接到继电器）//如果重新连接为真，则为&#39；ll首先尝试断开与引导节点异步函数dobootstrap（reconnect）{now=new（）.getTime（）；if（now-lastBootstrap&lt；60000）{//don&#39；如果我们在最后60秒内尝试，请不要再次尝试引导返回；}lastBootstrap=now；对于（引导中的i）{if（重新连接）{try{wait ipfs.swarm.disconnect（引导[i]）；}catch（e）{console.log（e）；}else{wait ipfs.bootstrap.add（bootstraps[i]）；}等待ipfs。一大群连接（引导[i]）；}}//检查我们是否&#39；re仍然连接到电路中继函数checkalive（）{now=new（）.getTime（）；if（now-lastAlive&gt；=35000）{if（now-lastPeer&gt；=35000）{document.getElementById（&#34；状态球&#34；）。风格颜色=&#34；红色&#34；；}else{document.getElementById（&#34；状态球&#34；）。风格颜色=&#34；黄色&#34；；}dobootstrap（正确）；//让&#39；让我们尝试重新连接}else{document.getElementById（&#34；状态球&#34；）。风格颜色=&#34；酸橙设置间隔（checkalive，1000）；</p><p>🌟 以上内容应与完整版本的ProcessAnnound一起使用，因为它依赖于lastAlive和lastPeer，这两个版本不是&#39；t在简化版本中更新。</p><p>我希望这篇文章能提供足够的信息，让我们开始行动。如果你成功地遵循了整个指南，你现在就可以部署完全在浏览器中运行的强大IPFS应用程序，并尽可能利用分散的p2p！我&#39；我选择了一些有用的资源，并在下面分享它们，以供进一步阅读：</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/浏览器/">#浏览器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ipfs/">#ipfs</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>