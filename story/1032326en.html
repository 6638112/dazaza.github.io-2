<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>正在恢复丢失的漫游笔记</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">正在恢复丢失的漫游笔记</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-31 02:02:09</div><div class="page_narrow text-break page_content"><p>This post dives deep into a scary data loss scenario - we&#39;ll cover identifying the data loss, investigating the root cause, and finally recovering the data.</p><p>这篇文章深入探讨了一个可怕的数据丢失场景--我们将涵盖识别数据丢失、调查根本原因以及最终恢复数据的内容。</p><p> This bug affected Readwise users who exported their highlights (both manually &amp; automatically) to Roam on 10/27. If you are one of those users, you should contact Roam support &amp; use  my recovery code ASAP!</p><p>此错误影响ReadWise用户，他们在10/27导出其亮点(手动和自动)以漫游。如果您是这些用户中的一员，您应该尽快联系漫游支持&amp；Use My Recovery Code！</p><p>  Roam is a &#34;note-taking tool for networked thought&#34;. It supports all sorts of cool things - what&#39;s relevant here is that it automatically creates a new page for every day, your Daily Notes. Recently, I started using  Readwise, which ingests Kindle highlights and uses  spaced repetition to help you remember what you read. Readwise has a Roam integration, which automatically adds Kindle highlights to Roam. Unfortunately, since Roam doesn&#39;t have a public API yet, Readwise&#39;s integration seems to be effectively using Selenium - clicking on elements and pasting highlights which is inherently flaky.</p><p>漫游是网络思维的笔记工具。它支持各种很酷的东西--这里与之相关的是，它每天都会自动创建一个新页面，那就是你的“每日笔记”(Daily Notes)。最近，我开始使用ReadWise，它吸收Kindle的亮点，并使用间隔重复来帮助你记住所读的内容。ReadWise具有漫游集成功能，可以自动将Kindle亮点添加到漫游中。不幸的是，由于Roam还没有一个公共API，Readwise的集成似乎有效地使用了Selenium-点击元素和粘贴亮点，这在本质上是不可靠的。</p><p> Yesterday, I woke up without my Daily Notes from the day before. Disaster! Fortunately, with the help of the Roam Slack group and Tristan from Readwise, I was able to isolate the cause of note deletion and even restore my lost data. Here&#39;s what happened:</p><p>昨天，我醒来时没有带前一天的日记。灾难！幸运的是，在漫游松弛小组和来自Readwise的特里斯坦的帮助下，我能够隔离笔记删除的原因，甚至可以恢复我丢失的数据。事情是这样发生的：</p><p>  Roam uses  Datascript for its client-side database. Like Datomic, Datascript stores data as a  datom, defined as  [e a v tx], or  entity,  attribute,  value, and  transaction-id (incrementing integer). If you&#39;re interested in learning more,  Datascript&#39;s author has an excellent overview.</p><p>Roam将Datascript用于其客户端数据库。与DATOMIC类似，Datascript将数据存储为定义为[e a v tx]的DATOM，或实体、属性、值和事务ID(递增整数)。如果您有兴趣了解更多，Datascript的作者有一个很好的概述。</p><p> Importantly for us, Roam differs from other webapps in that it doesn&#39;t store all state and history in its backend. Instead, Roam&#39;s backend just stores a snapshotted Datascript database (updated ~daily as far as I can tell) and the list of transactions since that last snapshot. If we can download those two things before Roam&#39;s next snapshot, we have two breadcrumbs towards recovery: 1. We can find the transaction that deleted my Daily Notes page 2. We can also reconstruct our Datascript database, replaying transactions up until the point of deletion, and recover our Daily Notes from that!</p><p>对我们来说重要的是，Roam与其他web应用的不同之处在于它不会在后端存储所有的状态和历史。取而代之的是，roam的后端只存储一个快照的Datascript数据库(据我所知每天更新)和自上次快照以来的事务列表。如果我们可以在漫游下一个快照之前下载这两项内容，我们就有两个恢复的面包屑了：1.我们可以找到删除“我的每日笔记”页的事务2.我们还可以重建我们的Datascript数据库，在删除之前重新播放事务，并从中恢复我们的“每日笔记”！</p><p>  Our first step is to store Roam&#39;s database snapshot and transaction list. Instead of REST API calls, Roam uses a Websocket connection to send these to its web client. This complicates things for us: instead of just saving API responses with  curl, we need to download a  HAR file, which, fortunately for us, includes Websocket traffic with more recent Chrome versions. HAR files are just JSON archives stored in chronological order - it&#39;s easy to select just the Websocket traffic:</p><p>我们的第一步是存储漫游的数据库快照和事务列表。Roam使用WebSocket连接将这些调用发送到其Web客户端，而不是REST API调用。这让我们的事情变得复杂起来：我们需要下载一个HAR文件，而不是仅仅用cURL保存API响应，幸运的是，它包含了更新的Chrome版本的WebSocket流量。HAR文件只是按时间顺序存储的JSON档案-只选择WebSocket流量很容易：</p><p> (  parse-har [harfile] (  [json (  (  harfile)  true) ws-messages (  json  :log  :entries (  #(  ( :_webSocketMessages %))) second  :_webSocketMessages) ws-data (   :data ws-messages)] ws-data))</p><p>(parse-har[harfile]([json((Harfile)true)ws-message(json：log：entry(#((：_webSocketMessages%)Second：_webSocketMessages)ws-data(：data ws-message)]ws-data)</p><p> Inspecting this data more closely, it appears that Roam&#39;s websocket messages are generally JSON strings (and occasionally numbers). When a message is more than 16KB, it&#39;s split into multiple messages without wrapping - so we&#39;ll need to stitch these bigger messages together. One way to detect a non-split-message is to just try and parse it as JSON - if it&#39;s valid, we can say it&#39;s non-split. (There&#39;s an edge case we&#39;re unlikely to hit here: if the 16KB chunk just so happens to be valid JSON as well we&#39;ll be out of luck. Lucky for us, I didn&#39;t run into this!) Now, we can extend  parse-har as follows:</p><p>仔细检查这些数据，似乎漫游的WebSocket消息通常是JSON字符串(偶尔也是数字)。当一封邮件超过16KB时，它会拆分成多封邮件而不进行包装-因此我们需要将这些较大的邮件缝合在一起。检测非拆分消息的一种方法是尝试将其解析为JSON-如果它是有效的，我们可以说它是非拆分的。(这里有一个我们不太可能遇到的边缘情况：如果16KB的数据块碰巧也是有效的JSON，我们就不走运了。)。我们很幸运，我没有碰到这个！)。现在，我们可以按如下方式扩展parse-har：</p><p> (  parse-har [harfile] (  [json (  (  harfile)  true) ws-messages (  json  :log  :entries (  #(  ( :_webSocketMessages %))) second  :_webSocketMessages) ws-data (   :data ws-messages) try-parse #(  (  %  true) (  Throwable _  nil))  ;; Roam sends a series of JSON objects over WS messages.  ;; If an object is bigger than 16kb it&#39;s split across  ;; multiple messages - so we need to stitch them together. ws-json (  (  [{ :keys [done partial]} next] (  [potential-json-str (  partial next)] (  [json (  potential-json-str)] { :done (  done json)  :partial  &#34;&#34;} { :done done  :partial potential-json-str}))) { :done []  :partial  &#34;&#34;} ws-data)] (  (  ( :partial ws-json)  &#34;&#34;)) ( :done ws-json)))</p><p>(parse-har[harfile]([json((Harfile)true)ws-message(json：log：entry(#((：_webSocketMessages%)Second：_webSocketMessages)ws-data(：data ws-message)try-parse#((%true)(Throwable_Nil))；；Roam通过WS消息发送一系列JSON对象。；；如果一个对象大于16KB，它会被拆分；；多条消息-因此我们需要将它们缝合在一起。WS-json(([{：keys[Done Partial]}Next]([Potential-json-str(Partial Next)]([json(Potential-json-str)]{：Done(Done Json)：Partial&#34；&#34；}{：Done Done：Partial Potential-json-str})){：Done[]：Partial&#34；&#34；}ws-Data)](：Partial WS-json)&#34；&#34；))(：Done ws-json))。</p><p>  Armed with our parsed websocket messages, we can see that many of them look like transactions. One that looks particularly suspicious has a nested field named  tx-meta with the value  delete-page! The transaction looks something like this:</p><p>有了我们解析的WebSocket消息，我们可以看到其中许多消息看起来像是事务。其中一个看起来特别可疑的字段有一个名为tx-meta的嵌套字段，值为delete-page！交易如下所示：</p><p> { :app-version  &#34;0.7.4&#34;,  :email  &#34;hello@jeff.yt&#34;,  :session-id  &#34;uuid95d98efd-c8fa-4412-87a4-e7b7201bee24&#34;,  :t  1603947791561,  :time  1603947791542,  :tx  &#34;[[\&#34;^ \&#34;,\&#34;~:block/uid\&#34;,\&#34;ogCRjInhE\&#34;,\&#34;~:block/string\&#34;,\&#34;some-text-here\&#34;,\&#34;~:edit/time\&#34;,1603947791363,\&#34;~:edit/email\&#34;,\&#34;hello@jeff.yt\&#34;],[\&#34;^ \&#34;,\&#34;^0\&#34;,\&#34;4CpSytRnt\&#34;,\&#34;^1\&#34;,\&#34;Highlights first synced by #Readwise October 28th, 2020\&#34;,\&#34;^2\&#34;,1603947791364,\&#34;^3\&#34;,\&#34;hello@jeff.yt\&#34;],[\&#34;^ \&#34;,\&#34;^0\&#34;,\&#34;C-IOsE50G\&#34;,\&#34;^1\&#34;,\&#34;New highlights added October 28th, 2020 at 11:03 PM\&#34;,\&#34;^2\&#34;,1603947791364,\&#34;^3\&#34;,\&#34;hello@jeff.yt\&#34;],[\&#34;~:db.fn/retractEntity\&#34;,[\&#34;^0\&#34;,\&#34;hLBqaz4gS\&#34;]],[\&#34;^4\&#34;,[\&#34;^0\&#34;,\&#34;vwD08rqdT\&#34;]],[\&#34;^4\&#34;,[\&#34;^0\&#34;,\&#34;6VWOGgeAd\&#34;]],[\&#34;^4\&#34;,[\&#34;^0\&#34;,\&#34;P56-fWN2O\&#34;]],[\&#34;^4\&#34;,[\&#34;^0\&#34;,\&#34;SffV3NfN2\&#34;]],[\&#34;^4\&#34;,[\&#34;^0\&#34;,\&#34;qnZBZCGCv\&#34;]],[\&#34;^4\&#34;,[\&#34;^0\&#34;,\&#34;10-28-2020\&#34;]]]&#34;,  :tx-meta { :event-id  &#34;uuid719b009f-b969-47b6-b2db-41542d10b328&#34;,  :event-name  &#34;delete-page&#34;,  :tx-id  &#34;uuid289e80fc-4c27-4d54-9df4-d83ac0ceeaed&#34;,  :tx-name  &#34;delete-page&#34;}}</p><p>{：应用程序版本&#34；0.7.4&#34；，：电子邮件&#34；hello@jeff.yt&#34；，：Session-id&#34；uuid95d98efd-c8fa-4412-87a4-e7b7201bee24&#34；，：t 1603947791561，：Time 1603947791542，：tx&#34；[[\&#34；^\&#34；，\&#34；~：Block/uid\&#34；，\&#34；ogCRjInhE\&#34；，\&#34；~：Block/String\&#34；，\&#34；一些文本-此处\&#34；，\&#34；~：编辑/时间\&#34；，1603947791363，\&#34；~：编辑/电子邮件\&#34；，\&#34；hello@jeff.yt\&#34；]，[\&#34；^\&#34；，\&#34；^0\&#34；，\&#34；4CpSytRnt\&#34；，\&#34；^1\&#34；，\&#34；突出显示首次同步日期为#Readwise 10.28,2020\&#34；，\&#34；^2\&#34；，1603947791364，\&#34；^3\&#34；，\&#34；Hello@jeff.yt\&#34；]，[\&#34；^\&#34；，\&#34；^0\&#34；，\&#34；C-IOsE50G\&#34；，\&#34；^1\&#34；，\&#34；2020年10月28日晚上11：03添加新亮点\&#34；，\&#34；^2\&#34；，1603947791364，\&#34；^3\&#34；，\&#34；，[\&#34；~：db.fn/retractEntity\&#34；，[\&#34；^0\&#34；，\&#34；]]，[\&#34；^4\&#34；，[\&#34；^0\&#34；，\&#34；VwD08rqdT\&#34；]]，[\&#34；^4\&#34；，[\&#34；^0\&#34；，\&#34；6VWOGgeAd\&#34；]，[\&#34；^4\&#34；，[\&#34；^0\&#34；，\&#34；P56-fWN2O\&#34；]]，[\&#34；^4\&#34；，[\&#34；^0\&#34；，\&#34；SffV3NfN2\&34；]]，[\&#34；^4\&#34；，\&#34；^0\&#34；，\&#34；SffV3NfN2\&34；]]，[\&#34；^4\&#34；，[\&#34；^0\&#34；，\&#34；qnZBZCGCv\&#34；]]，[\&#34；^4\&#34；，[\&#34；^0\&#34；，\&#34；10-28-2020\&#34；]]&#34；，：tx-META{：Event-id&#34；uuid719b009f-b969-47b6-b2db-41542d10b328&#34；，：Event-Name&34；删除-第&#34页；，：tx-id&#34；uuid289e80fc-4c27-4d54-9df4-d83ac0ceeaed&#34；，：tx-name&#34；删除页面&#34；}}。</p><p> I omitted ~90% of the transaction to save space - but it&#39;s more of the same. This definitely looks like the transaction that deleted my Daily Notes page: I see  db.fn/retractEntity as well as  10-28-2020 in the transaction. Interestingly, this transaction captures two Readwise interactions as well. It&#39;s not a smoking gun, but it&#39;s definitely suspicious that Readwise was operating on my database at the  exact same time that my page was mysteriously deleted!</p><p>为了节省空间，我省略了大约90%的事务处理--但它们大同小异。这看起来绝对像删除了我的Daily Notes页面的事务：我在事务中看到db.fn/retractEntity和10-28-2020。有趣的是，该事务还捕获了两个ReadWise交互。这不是确凿的证据，但我的页面被神秘删除的同时，Readwise正在操作我的数据库，这一点绝对令人怀疑！</p><p> Let&#39;s pause here, and check in with the Roam Slack group. Someone else has already started a thread about data loss! They and others quickly confirm that they also all have Readwise&#39;s auto-export enabled. Again, it&#39;s not confirmation that Readwise is to blame, but it&#39;s enough for me to stop what I&#39;m doing and disable my Readwise integration! We&#39;ll also share our knowledge in the Slack thread and ask affected users to save their Roam HAR file like we did.</p><p>让我们在这里暂停一下，并与漫游松弛小组签到。已经有人开了一个关于数据丢失的帖子了！他们和其他人很快确认，他们也都启用了ReadWise的自动导出功能。再说一次，这并不是说Readwise是罪魁祸首，但这足以让我停止我正在做的事情，并禁用我的Readwise集成！我们还将在松弛线程中分享我们的知识，并要求受影响的用户像我们一样保存他们的roam Har文件。</p><p> Later,  Tristan, founder of Readwise, pops into Slack and quickly confirms that  a recent Roam behavior change combined with the Readwise integration can cause deleted pages. Huge props to Tristan who responds perfectly: he triages the issue, disables the feature to prevent any more users from hitting it, and fixes &amp; re-enables auto-export all within a couple hours! Tristan also remains communicative and takes full responsibility, even offering refunds, though I&#39;d argue that these hiccups are bound to happen when Roam still hasn&#39;t opened up their public API.</p><p>后来，Readwise的创始人特里斯坦突然进入Slake，并迅速证实，最近的漫游行为变化与Readwise的整合相结合，可能会导致页面被删除。特里斯坦做出完美回应的巨大道具：他对问题进行分类，禁用功能以防止更多用户点击它，并在几个小时内修复并重新启用自动导出！特里斯坦也很善于沟通，承担全部责任，甚至提供退款，尽管我认为，当Roam还没有开放他们的公共API时，这些问题肯定会发生。</p><p>  Peeking again at our parsed HAR file, we see what appears to be our serialized database - it&#39;s stored like this:</p><p>再次查看解析后的Har文件，我们会发现似乎是我们的序列化数据库-它是这样存储的：</p><p>    This looks like Transit!  Transit is a JSON-like format for sending data between applications ( this post is a good introduction). Datascript has its own  set of Transit handlers - let&#39;s import that and see if we get a working database! Of course, we&#39;ll also need to combine  split-db by smashing the Transit-encoded strings together.</p><p>这看起来像是过境！Transfer是一种类似JSON的格式，用于在应用程序之间发送数据(这篇文章是一个很好的介绍)。Datascript有它自己的传输处理程序集-让我们导入它，看看我们是否得到了一个工作的数据库！当然，我们还需要通过将传输编码的字符串粉碎在一起来组合Split-db。</p><p> (  &#39;[datascript.transit  :as dt])(  parse-db [parsed-har] (  [db-str (  parsed-har  ;; the database is deeply nested! (  #(  %  :d  :b  :d  :split-db)) first  :d  :b  :d  :split-db vals (   &#34;&#34;))] (  db-str)))</p><p>(&#39；[datcript.Transition：AS DT])(parse-db[parsed-har]([db-str(parsed-har；；数据库嵌套很深！(#(%：D：B：D：Split-db))first：D：B：D：Split-db(&#34；&#34；))](db-str))。</p><p> Voila - a real Datascript database! We can confirm it&#39;s my Roam database by querying it:</p><p>瞧--一个真正的Datascript数据库！我们可以通过查询确认它是我的漫游数据库：</p><p> (  &#39;[datascript.core  :as d])(  [db (  harfile ( ) ( )) conn (  db)] (  &#39;[ :find ?e  :where [?e  :node/title  &#34;Daily Template&#34;]] @conn)) ;; #{[1855]}</p><p>(&#39；[datcript.core：as d])([db(harfile()())conn(Db)](&#39；[：find？e：where[？e：node/title&#34；Daily Template&#34；]@conn))；；#{[1855]}。</p><p> With a working Roam database, our next step is to apply all of the transactions we have up until the deletion event. Transactions are Transit-encoded, and we&#39;ll have to do quite a bit of data manipulation to get a list of them. Once we have that list, we can sort the transactions and apply them sequentially:</p><p>对于正在运行的漫游数据库，我们的下一步是应用我们拥有的所有事务，直到删除事件。事务是传输编码的，我们必须进行相当多的数据操作才能获得它们的列表。一旦我们有了该列表，我们就可以对交易进行排序并按顺序应用它们：</p><p> (  apply-transactions-until [db parsed-har until-time] (  [transactions-to-apply (  parsed-har (  #(  %  :d  :b  :d)) (  seqable?) (  concat) (  #(  (  % first name)  &#34;-MK&#34;)) (  second) (  #(  ( :time %) until-time)) (   :time) (   :tx) (  dt/read-transit-str)) conn (  db)] (  [tx transactions-to-apply] (  conn tx)) (  conn)))</p><p>(Apply-Transaction-Until[db parsed-har Until-time]([要应用的事务(parsed-har(#(%：D：B：D)(seqable？)。(CONCAT)(#((%First Name)&#34；-MK&#34；))(Second)(#((：time%)to-time))(：time)(：tx)(dt/read-transportstr)conn(Db)]([要应用的Tx事务](Conn Tx))(Conn))。</p><p> Here,  until-time is the time of the deletion transaction. We&#39;re so close now! We&#39;ve managed to materialize my Roam database from  right before my notes were deleted! All we need to do now is pull that deleted page, and we&#39;ll be done!</p><p>这里，Until-time是删除事务的时间。我们现在就快到了！在我的笔记被删除之前，我们已经成功地实现了我的漫游数据库！我们现在需要做的就是删除那个页面，然后我们就可以完成了！</p><p>  Recovering my deleted page shouldn&#39;t be too hard: we can use Datascript&#39;s  pull to recursively grab the entire page&#39;s contents!</p><p>恢复我删除的页面应该不会太难：我们可以使用Datascript的拉动功能递归地抓取整个页面的内容！</p><p> (  recover [db] (  [conn (  db) note-eid (  (  `[ :find ?e  :where [?e  :block/uid ~missing-date]] @conn)) page (  db &#39;[ :block/string { :block/children [ :block/order  :block/string { :block/children ...}]}] note-eid)] page))(  db) ; #:block{:children [#:block{:order 0, ; :string &#34;[[Gym 💪🏽]]&#34;, ; :children [#:block{:order 0, ; :string &#34;#[[weight room]]&#34;, ; :children [#:block{:order 0, :string &#34;bench 5x5x225&#34;} ; #:block{:order 1, :string &#34;seated rows 4x12x100&#34;}]}]}</p><p>(recover[db]([conn(Db)note-eid((`[：find？e：where[？e：block/uid~Missing-Date]@conn))page(db&#39；[：block/string{：block/Children[：block/order：block/string{：block/Children...}]}]note-eid)]page))(Db)；#：block{：Children[#：block{：order 0，；：String&#34；[[体育馆💪🏽]]&#34；，；：儿童[#：Block{：Order 0，；；：String&#34；#[[Weight Room]]&#34；，；：Children[#：Block{：Order 0，：String&#34；Back 5x5x225&#34；}；#：Block{：Order 1，：String&#34；Seated row 4x12x100&#34；}]}。</p><p> Next, let&#39;s turn this data structure into something we can paste back into Roam. We can materialize a string by recursively materializing a block&#39;s children, increasing the indentation as we recurse:</p><p>接下来，让我们将此数据结构转换为可以粘贴回Roam中的内容。我们可以通过递归地物化块的子块来物化字符串，在递归时增加缩进：</p><p> (  materialize [{ :keys [block/string]  :as page} level] (  [indent (  level  4) children (  ( :block/children page) (   :block/order) (  #(  % (  level))) (  #(   &#34;%s- %s&#34; (  str (  indent  &#34; &#34;)) %)) (   &#34;\n&#34;))] (  (  string (  children)) (  string  &#34;\n&#34; children) (  children) children string string  :else  &#34;&#34;)))(  recover [db] (  [conn (  db) note-eid (  (  `[ :find ?e  :where [?e  :block/uid ~missing-date]] @conn)) page (  db &#39;[ :block/string { :block/children [ :block/order  :block/string { :block/children ...}]}] note-eid)] (  page  0)))(  db) ;- [[Gym 💪🏽]] ; - #[[weight room]] ; - bench 5x5x225 ; - seated rows 4x12x100</p><p>(物化[{：KEYS[块/字符串]：作为页面}级别]([缩进(级别4)子页面((：块/子页面)(：块/顺序)(#(%(级别)(#(&#34；%s-%s&#34；(str(缩进&#34；&#34；))%)(&#34；\n&#34；)])]((String(Children))(String&#34；\n&#34；Children)(Children)Children String：Else&#34；&#34；)(Recover[db]([conn(Db)note-eid((`[：find？e：where[？e：block/uid~Missing-Date]]@conn))页面(db&#39；[：BLOCK/String{：BLOCK/CHILD[：BLOCK/ORDER：BLOCK/STRING{：BLOCK/CHILD...}]}]备注-eid)](第0页))(Db)；-[[体育馆💪🏽]]；-#[[重量间]]；-工作台5x5x225；-座位行4x12x100。</p><p> That&#39;s it! Now we can copy that string into Roam, and we&#39;ve fully recovered our lost Roam page - structure and all! You can find the full code  here.</p><p>就是这样！现在我们可以将该字符串复制到漫游中，我们已经完全恢复了丢失的漫游页面结构和所有内容！您可以在这里找到完整的代码。</p><p>  What a way to spend a morning! I&#39;m super thankful that I was able to recover my lost notes. I was lucky that Roam hadn&#39;t snapshotted my database post-deletion - that would have made this method impossible. I&#39;m also grateful to Tristan from Readwise and everyone else who was in the Roam Slack for helping isolate and debug the problem. I hope that I was able to help at least a couple of them recover their data.</p><p>这是多么好的一种方式来度过一个上午啊！我非常感谢我能找回丢失的笔记。我很幸运，Roam在删除后没有对我的数据库进行快照-这将使这种方法变得不可能。我也感谢来自Readwise的特里斯坦和其他所有在漫游中的人，他们帮助隔离和调试了这个问题。我希望我能够帮助他们中的至少几个人恢复他们的数据。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://jeffchen.dev/posts/Recovering-Lost-Roam-Notes/">https://jeffchen.dev/posts/Recovering-Lost-Roam-Notes/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/恢复/">#恢复</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lost/">#lost</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/readwise/">#readwise</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>