<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>消除Firefox中的数据比赛 Eliminating Data Races in Firefox</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Eliminating Data Races in Firefox<br/>消除Firefox中的数据比赛 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-06 23:54:10</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/88ff4dec58afa367d96369000fda9bc3.jpg"><img src="http://img2.diglog.com/img/2021/4/88ff4dec58afa367d96369000fda9bc3.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>We successfully deployed  ThreadSanitizer in the Firefox project to eliminate data races in our remaining C/C++ components. In the process, we found several impactful bugs and can safely say that data races are often underestimated in terms of their impact on program correctness. We recommend that all multithreaded C/C++ projects adopt the ThreadSanitizer tool to enhance code quality.</p><p>我们成功部署了Firefox项目中的ThreadSanitizer，以消除剩余的C / C ++组件中的数据比赛。在此过程中，我们发现了几个有影响力的错误，并且可以安全地说数据种族通常在对计划正确性的影响方面低估。我们建议所有多线程C / C ++项目采用ThreadSanitizer工具来增强代码质量。</p><p>  ThreadSanitizer (TSan) is compile-time instrumentation to detect  data races according to the  C/C++ memory model on Linux. It is important to note that these data races are considered  undefined behavior within the C/C++ specification. As such, the compiler is free to assume that data races do not happen and perform optimizations under that assumption. Detecting bugs resulting from such optimizations can be hard, and data races often have an intermittent nature due to thread scheduling. Without a tool like ThreadSanitizer, even the most experienced developers can spend hours on locating such a bug. With ThreadSanitizer, you get a comprehensive data race report that often contains all of the information needed to fix the problem.</p><p>  ThreadSanitizer（TSAN）是编译时仪器，可根据Linux上的C / C ++内存模型检测数据比赛。值得注意的是，这些数据比赛被认为是C / C ++规范中的未定义行为。因此，编译器可以自由地假设数据比赛不会发生并在该假设下执行优化。检测由此类优化产生的错误可能是硬，并且数据竞争通常具有由于线程调度而具有间歇性的性质。如果没有像帖子化器这样的工具，即使是最经验丰富的开发人员也可以花费时间在找到这样的错误。使用ThreadSanitizer，您可以获得一个全面的数据竞争报告，通常包含解决问题所需的所有信息。</p><p>  One important property of TSan is that, when properly deployed, the data race detection does not produce false positives. This is incredibly important for tool adoption, as developers quickly lose faith in tools that produce uncertain results.</p><p>  TSAN的一个重要属性是，当正确部署时，数据竞争检测不会产生误报。这对工具采用非常重要，因为开发人员在产生不确定结果的工具中迅速失去信心。</p><p> Like other sanitizers, TSan is built into Clang and can be used with any recent Clang/LLVM toolchain. If your C/C++ project already uses e.g. AddressSanitizer (which we also highly recommend), deploying ThreadSanitizer will be very straightforward from a toolchain perspective.</p><p> 与其他消毒者一样，Tsan建于铿cl声，可以与最近的任何Clang / LLVM Toolchain一起使用。如果您的C / C ++项目已经使用了例如addresssanitizer（我们也强烈推荐），部署ThreadSanitizer从工具箱角度将非常简单。</p><p>   Despite ThreadSanitizer being a very well designed tool, we had to overcome a variety of challenges at Mozilla during the deployment phase. The most significant issue we faced was that it is really difficult to prove that data races are actually harmful at all and that they impact the everyday use of Firefox. In particular, the term “ benign” came up often. Benign data races acknowledge that a particular data race is actually a race, but assume that it does not have any negative side effects.</p><p>   尽管Threadsanitizer是一个非常精心设计的工具，但我们必须在部署阶段克服Mozilla的各种挑战。我们面临的最重要的问题是，难以证明数据种族实际上是有害的，并且它们影响了Firefox的日常使用。特别是，术语“良性”经常出现。良性数据种族承认特定数据种族实际上是一个种族，但假设它没有任何负面影响。</p><p> While benign data races do exist, we found (in agreement with previous work on this subject  [1]  [2]) that data races are very easily misclassified as benign. The reasons for this are clear: It is hard to reason about what compilers can and will optimize, and confirmation for certain “benign” data races requires you to look at the assembler code that the compiler finally produces. Needless to say, this procedure is often much more time consuming than fixing the actual data race and also not future-proof. As a result, we decided that the ultimate goal should be a  “no data races” policy that declares even benign data races as undesirable due to their risk of misclassification, the required time for investigation and the potential risk from future compilers (with better optimizations) or future platforms (e.g. ARM).</p><p> 虽然存在良性数据种族，我们发现（与之前的这个主题的工作协议[1] [2]），数据种族非常容易被错误分类为良性。对此的原因很清楚：很难推理编译器可以并将优化，并确认某些“良性”数据播放需要您查看编译器最终产生的汇编代码。毋庸置疑，这个程序通常比固定实际数据竞争和未来的未来更耗时。因此，我们决定最终目标应该是“无数据比赛”政策，甚至宣布良性数据种族因其错误分类风险而导致的不良，调查所需的时间和未来编制者的潜在风险（具有更好的优化）或未来的平台（例如ARM）。</p><p> However, it was clear that establishing such a policy would require a lot of work, both on the technical side as well as in convincing developers and management. In particular, we could not expect a large amount of resources to be dedicated to fixing data races with no clear product impact. This is where TSan’s  suppression list came in handy: We knew we had to stop the influx of new data races but at the same time get the tool usable without fixing all legacy issues. The suppression list (in particular  the version compiled into Firefox) allowed us to temporarily ignore data races once we had them on file and ultimately  bring up a TSan build of Firefox in CI that would automatically avoid further regressions. Of course, security bugs required specialized handling, but were usually easy to recognize (e.g. racing on non-thread safe pointers) and were fixed quickly without suppressions.</p><p> 但是，很明显，建立这样的政策需要在技术方面都需要大量工作以及令人信服的开发人员和管理。特别是，我们无法指望大量资源致力于修复数据比赛，没有明确的产品影响。这就是Tsan的抑制列表派上用场：我们知道我们不得不停止新数据种族的涌入，但同时可以获得工具可用的工具，而无需修复所有遗留问题。抑制列表（特别是编译到Firefox的版本）允许我们暂时忽略一旦我们在文件上暂时忽略数据比赛，并最终将在CI中提取的TSAN构建，以自动避免进一步的回归。当然，安全臭虫需要专门处理，但通常很容易识别（例如，在非线线安全指针上赛车），并且在没有抑制的情况下快速固定。 </p><p> To help us understand the impact of our work, we maintained an internal list of all the most serious races that TSan detected (ones that had side-effects or could cause crashes). This data helped convince developers that the tool was making their lives easier while also clearly justifying the work to management. In addition to this qualitative data, we also decided for a more quantitative approach: We looked at all the bugs we found over a year and how they were classified. Of the 64 bugs we looked at, 34% were classified as “benign” and 22% were “impactful” (the rest hadn’t been classified).</p><p>为了帮助我们了解我们的工作的影响，我们维持了一个最严重的种族的内部清单，即Tsan检测到的所有最严重的种族（有副作用或可能导致崩溃）。这些数据有助于说服开发人员，该工具使他们的生活更容易，同时也明确证明了管理工作。除了这种定性数据外，我们还决定了更加定量的方法：我们看着一年多的所有虫子以及如何分类。在我们看过的64个错误中，34％被归类为“良性”，22％是“影响”（其余的尚未被分类）。</p><p> We knew there was a certain amount of misclassified benign issues to be expected, but what we really wanted to know was: Do benign issues pose a risk to the project? Assuming that all of these issues truly had no impact on the product, are we wasting a lot of resources on fixing them? Thankfully, we found that  the majority of these fixes were trivial and/or improved code quality.</p><p> 我们知道有一定数量的错误分类是预期的，但我们真正想知道的是：良性问题对项目带来了风险吗？假设所有这些问题都没有对该产品产生影响，我们是否浪费了很多关于修复它们的资源？值得庆幸的是，我们发现这些修复的大多数是微不足道的和/或改善的代码质量。</p><p> The trivial fixes were mostly turning non-atomic variables into atomics (20%), adding permanent suppressions for upstream issues that we couldn’t address immediately (15%), or removing overly complicated code (20%). Only 45% of the benign fixes actually required some sort of more elaborate patch (as in, the diff was larger than just a few lines of code and did not just remove code). We concluded that the risk of benign issues being a major resource sink was not an issue and well acceptable for the overall gains that the project provided.</p><p> 琐碎的修复主要将非原子变量转化为原子学（20％），为上游问题增加了永久抑制，我们无法立即解决（15％），或删除过于复杂的代码（20％）。只有45％的良性修复实际上需要某种更多的更精细的补丁（如同，差异大于几行代码，而不只是删除代码）。我们得出结论，作为主要资源汇的良性问题的风险不是一个问题，并且可以为项目提供的整体收益可接受。</p><p>  As mentioned in the beginning, TSan does not produce false positive data race reports  when properly deployed, which includes instrumenting all code that is loaded into the process and avoiding primitives that TSan doesn’t understand (such as  atomic fences). For most projects these conditions are trivial, but larger projects like Firefox require a bit more work. Thankfully this work largely amounted to a few lines in TSan’s robust suppression system.</p><p>  如开始，Tsan在适当部署时不会产生假正数据竞争报告，其中包括将加载到过程中的所有代码进行了解，并避免了Tsan不理解的原语（例如原子围栏）。对于大多数项目，这些条件是微不足道的，但像Firefox这样的更大项目需要更多的工作。值得庆幸的是，这项工作大大于Tsan的强大抑制系统中的几行。</p><p> Instrumenting all code in Firefox isn’t currently possible because it needs to use shared system libraries like GTK and X11. Fortunately, TSan offers the “called_from_lib” feature that can be used  in the suppression list to ignore any calls originating from those shared libraries. Our other major source of uninstrumented code was build flags not being properly passed around, which was especially problematic for Rust code (see the Rust section below).</p><p> 在Firefox中检测所有代码目前无法使用，因为它需要使用像GTK和X11等共享系统库。幸运的是，TSAN提供了“调用_from_lib”功能，可以在抑制列表中使用，以忽略源自共享库的任何呼叫。我们的其他超级守则的主要来源是构建标志未正确传递，这对于生锈代码特别有问题（请参阅下面的锈部分）。</p><p> As for unsupported primitives, the only issue we ran into was the lack of support for fences. Most fences were the result of  a standard atomic reference counting idiom which could be trivially  replaced with an atomic load in TSan builds. Unfortunately, fences are fundamental to the design of the  crossbeam crate (a foundational concurrency library in Rust), and the only solution for this was  a suppression.</p><p> 至于不受支持的原语，我们遇到的唯一问题是缺乏对围栏的支持。大多数围栏是标准原子参考计数成语的结果，其可以在Tsan构建中的原子负荷替换。不幸的是，围栏是对设计的横梁板条箱（生锈的基础并发库）的基础，而唯一的解决方案是抑制。</p><p> We also found that there is a (well known)  false positive in deadlock detection that is however very easy to spot and also does not affect data race detection/reporting at all. In a nutshell, any deadlock report that only involves a single thread is likely this false positive.</p><p> 我们还发现，在死锁检测中存在（众所周知的）假阳性，但是非常容易发现，并且根本不会影响数据种族检测/报告。简而言之，任何仅涉及单个线程的死锁报告可能会对单个线程呈现出误报。 </p><p> The only true false positive we found so far turned out to be a rare bug in TSan and was fixed in the tool itself. However, developers  claimed on various occasions that a particular report must be a false positive. In all of these cases, it turned out that TSan was indeed right and the problem was just very subtle and hard to understand. This is again confirming that we need tools like TSan to help us eliminate this class of bugs.</p><p>我们发现的唯一真正的假阳性是Tsan的罕见错误，并在工具本身固定。但是，开发人员在各种情况下宣称特定报告必须是假阳性的。在所有这些情况下，证明Tsan确实是正确的，问题只是非常微妙，很难理解。这再次确认我们需要Tsan等工具来帮助我们消除这类错误。</p><p>  Currently, the TSan bug-o-rama contains around 20 bugs. We’re still working on fixes for some of these bugs and would like to point out several particularly interesting/impactful ones.</p><p>  目前，TSAN错误O-RAMA包含大约20个错误。我们仍在为一些这些错误进行修复，并希望指出几个特别有趣/有影响力的错误。</p><p>  Bitfields are a handy little convenience to save space for storing lots of different small values. For instance, rather than having 30 bools taking up 240 bytes, they can all be packed into 4 bytes. For the most part this works fine, but it has one nasty consequence: different pieces of data now alias. This means that accessing “neighboring” bitfields is actually accessing the same memory, and therefore a potential data race.</p><p>  位菲尔德是一种方便的便利，可以节省空间，以存储大量不同的小值。例如，而不是拥有30个BOOL占用240个字节，它们都可以将其包装为4个字节。在大多数情况下，这效果很好，但它有一个令人讨厌的后果：现在别名的不同数据。这意味着访问“邻居”位域实际上是访问相同的内存，因此是潜在的数据竞争。</p><p> In practical terms, this means that if two threads are writing to two neighboring bitfields, one of the writes can get lost, as both of those writes are actually read-modify-write operations of all the bitfields:</p><p> 实际上，这意味着如果两个线程写入两个相邻位字段，则其中一个写入可能会丢失，因为这两种写入都是读取所有位字段的写入操作：</p><p>  If you’re familiar with bitfields and actively thinking about them, this might be obvious, but when you’re just saying myVal.isInitialized = true you may not think about or even realize that you’re accessing a bitfield.</p><p>  如果您熟悉位域并积极思考它们，这可能是显而易见的，但是当您只是说Myval.Isinitialized = True时，您可能不会考虑或甚至意识到您正在访问位域。</p><p> We have had many instances of this problem, but let’s look at  bug 1601940 and its (trimmed) race report:</p><p> 我们有很多这个问题的实例，但让我们看看错误的1601940及其（修剪）的赛事报告：</p><p>  When we first saw this report, it was puzzling because the two threads in question touch different fields ( mAsyncTransformAppliedToContent vs.  mTestAttributeAppliers). However, as it turns out, these two fields are both  adjacent bitfields in the class.</p><p>  当我们第一次看到这份报告时，它很令人难以置疑，因为有问题的两个线程触摸不同的字段（MasynctRansformappliedTocontent与MtestattributeAppliers）。但是，事实证明，这两个字段都是类中的相邻位字段。 </p><p> This was causing intermittent failures in our CI and  cost a maintainer of this code valuable time. We find this bug particularly interesting because it demonstrates how hard it is to diagnose data races without appropriate tooling and we found more instances of this type of bug (racy bitfield write/write) in our codebase. One of the other instances even had the potential to cause network loads to supply invalid cache content, another hard-to-debug situation, especially when it is intermittent and therefore not easily reproducible.</p><p>这导致我们的CI中的间歇性失败，并花费了这个代码的维护者有价值的时间。我们发现这个错误特别有趣，因为它展示了在没有适当的工具的情况下诊断数据比赛的困难，我们在Codebase中找到了更多类型的错误（Racy Bitfield Write / Write）的更多实例。其中一个实例甚至可能有可能导致网络负载来提供无效的缓存内容，另一个难以调试的情况，尤其是当它间歇性并且因此不容易可再现时。</p><p> We encountered this enough that we eventually introduced a  MOZ_ATOMIC_BITFIELDS macro that generates bitfields with atomic load/store methods. This allowed us to quickly fix problematic bitfields for the maintainers of each component without having to redesign their types.</p><p> 我们遇到了这一点，我们最终推出了一个Moz_atomic_bitFields宏，它生成具有原子负载/存储方法的位域。这允许我们快速修复每个组件的维护者的问题位域，而无需重新设计它们的类型。</p><p>  We also found several instances of components which were explicitly designed to be single-threaded accidentally being used by multiple threads, such as  bug 1681950:</p><p>  我们还发现了几种组件实例，该组件被明确地设计为单线程被意外使用多个线程使用，例如错误1681950：</p><p>  The race itself here is rather simple, we are racing on the same file through stat64 and understanding the report was not the problem this time. However, as can be seen from frame 10, this call originates from the  PreferencesWriter, which is responsible for writing changes to the prefs.js file, the central storage for Firefox preferences.</p><p>  比赛本身在这里是相当简单的，我们通过Stat64赛车在同一个文件上，并理解报告这次不是问题。但是，从帧10中可以看出，此呼叫源自偏好要求，该呼叫负责将更改写入Prefs.js文件，是Firefox偏好的中央存储。</p><p> It was never intended for this to be called on multiple threads at the same time and we believe that this had the potential to corrupt the prefs.js file. As a result, during the next startup the file would fail to load and be discarded (reset to default prefs). Over the years, we’ve had quite a few bug reports related to this file magically losing its custom preferences but we were never able to find the root cause. We now believe that this bug is at least partially responsible for these losses.</p><p> 它永远不会在多个线程上同时调用它，我们认为这有可能破坏prefs.js文件。因此，在下次启动期间，文件将无法加载并丢弃（重置为默认Prefs）。多年来，我们有很多错误报告与此文件有关，神奇地丢失其自定义首选项，但我们从未找到根本原因。我们现在认为这个错误至少部分负责这些损失。</p><p> We think this is a particularly good example of a failure for two reasons: it was a race that had more harmful effects than just a crash, and it caught a larger logic error of something being used outside of its original design parameters.</p><p> 我们认为这是一个特别好的失败的例子，原因有两个：这是一个比崩溃更有害影响的种族，它捕获了在其原始设计参数之外使用的东西的更大逻辑错误。</p><p>  On several occasions we encountered a pattern that lies on the boundary of benign that we think merits some extra attention: intentionally racily reading a value, but then later doing checks that properly validate it. For instance, code like:</p><p>  在几个场合，我们遇到了一种在良性的边界上遇到的模式，我们认为有些额外的注意力：故意读取价值，但后来稍后做正确验证的检查。例如，代码： </p><p>   Please Don’t Do This. These patterns are really fragile and they’re ultimately undefined behavior, even if they  generally work right. Just write proper atomic code — you’ll usually find that the performance is perfectly fine.</p><p>请不要这样做。这些模式非常脆弱，即使它们通常工作，它们最终是未定义的行为。只需编写适当的原子代码 - 您通常会发现性能完全正常。</p><p>  Another difficulty that we had to solve during TSan deployment was due to part of our codebase now being written in Rust, which has much less mature support for sanitizers. This meant that we spent a significant portion of our bringup with all Rust code suppressed while that tooling was still being developed.</p><p>  在TSAN部署期间我们必须解决的另一个困难是由于我们的代码库的一部分是现在被锈写的，这对消毒者来说具有更大的成熟支持。这意味着我们在仍在开发的情况下，我们花了很大程度上的所有锈蚀代码。</p><p> We weren’t particularly concerned with our Rust code having a lot of races, but rather races in C++ code being obfuscated by passing through Rust. In fact, we strongly recommend writing new projects entirely in Rust to avoid data races altogether.</p><p> 我们并不特别关注我们的生锈代码，其中有很多比赛，而是通过通过Rust来混淆C ++代码中的比赛。事实上，我们强烈建议完全锈的新项目，以避免数据竞争。</p><p> The hardest part in particular is the need to rebuild the Rust standard library with TSan instrumentation. On nightly there is an unstable feature, -Zbuild-std, that lets us do exactly that, but it still has a lot of rough edges.</p><p> 特别是最困难的部分是需要使用Tsan仪器重建锈标准图书馆。在夜间有一个不稳定的功能-zbuild-std，让我们确切地做到这一点，但它仍然有很多粗糙的边缘。</p><p> Our biggest hurdle with build-std was that it’s currently incompatible with vendored build environments, which Firefox uses. Fixing this isn’t simple because cargo’s tools for patching in dependencies aren’t designed for affecting only a subgraph (i.e. just std and not your own code). So far, we have mitigated this by maintaining a small set of patches on top of rustc/cargo which implement this well-enough for Firefox but need  further work to go upstream.</p><p> 我们与Build-STD的最大障碍是它目前与助手建立环境不兼容，Firefox使用。修复这并不简单，因为货物用于在依赖项中修补的工具不是用于仅影响子图（即，STD而不是您自己的代码）。到目前为止，我们通过维持鲁道科/货物上的一小套补丁来减轻了这一点，这对Firefox提供了这一点，但需要进一步的工作来上游。</p><p> But with build-std hacked into working for us we were able to instrument our Rust code and were happy to find that there were very few problems! Most of the things we discovered were C++ races that happened to pass through some Rust code and had therefore been hidden by our blanket suppressions.</p><p> 但是通过Build-STD被攻击为我们为我们工作，我们能够为我们的锈蚀代码进行炼制，并且很乐意发现问题很少！我们发现的大多数事情是C ++竞赛，恰好通过一些铁锈代码，因此被我们的毯子抑制所隐藏。</p><p>  The first was  bug 1674770, which was a bug in the parking_lot library. This Rust library provides synchronization primitives and other concurrency tools and is written and maintained by experts. We did not investigate the impact but the issue was a couple atomic orderings being too weak and  was fixed quickly by the authors. This is yet another example that proves how difficult it is to write bug-free concurrent code.</p><p>  第一个是Bug 1674770，这是Park_lot库中的一个错误。该RUST库提供同步基元和其他并发工具，并由专家编写和维护。我们没有调查影响，但问题是夫妇原子排序太弱，并由作者迅速修复。这是又一个示例，证明了写无码并发代码是多么困难。 </p><p> The second was  bug 1686158, which was some code in WebRender’s software OpenGL shim. They were maintaining some hand-rolled shared-mutable state using raw atomics for part of the implementation but forgot to make one of the fields atomic. This was easy enough to fix.</p><p>第二个是错误1686158，这是WebRender软件OpenGL Shim中的一些代码。他们使用原始原子来维持一些手工卷起的共享变形状态，以实现部分实施，但忘了制作一个原子的原子。这很容易修复。</p><p> Overall Rust appears to be fulfilling one of its original design goals: allowing us to write more concurrent code safely. Both WebRender and Stylo are very large and pervasively multi-threaded, but have had minimal threading issues. What issues we did find were mistakes in the implementations of low-level and explicitly unsafe multithreading abstractions — and those mistakes were simple to fix.</p><p> 整体rust似乎符合其原始设计目标之一：允许我们安全地编写更多并发代码。 WebRender和Stylo都非常大而普遍地多线程，但具有最小的线程问题。我们发现的问题是在低级和明确不安全的多线程抽象中的实现中的错误 - 这些错误很简单。</p><p> This is in contrast to many of our C++ races, which often involved things being randomly accessed on different threads with unclear semantics, necessitating non-trivial refactorings of the code.</p><p> 这与我们的许多C ++比赛相反，这通常涉及在不同的线程上随机访问的语义上的不同线程中，需要代码的非琐碎重构。</p><p>  Data races are an underestimated problem. Due to their complexity and intermittency, we often struggle to identify them, locate their cause and judge their impact correctly. In many cases, this is also a time-consuming process, wasting valuable resources. ThreadSanitizer has proven to be not just  effective in locating data races and  providing adequate debug information, but also to be  practical even on a project as large as Firefox.</p><p>  数据种族是一个低估的问题。由于他们的复杂性和间歇性，我们经常努力识别它们，找到他们的原因并正确地判断他们的影响。在许多情况下，这也是一种耗时的过程，浪费了宝贵的资源。 ThreadSanitizer已被证明不仅有效地定位数据种族并提供足够的调试信息，而且即使在作为Firefox的项目中也是实用的。</p><p>  We would like to thank the authors of ThreadSanitizer for providing the tool and in particular Dmitry Vyukov (Google) for helping us with some complex, Firefox-specific edge cases during deployment.</p><p>  我们要感谢ThreadSanitizer的作者提供工具，特别是DMitry Vyukov（Google），帮助我们在部署期间帮助我们使用一些复杂的Firefox特定边缘案例。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hacks.mozilla.org/2021/04/eliminating-data-races-in-firefox-a-technical-report/">https://hacks.mozilla.org/2021/04/eliminating-data-races-in-firefox-a-technical-report/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/消除/">#消除</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/data/">#data</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>