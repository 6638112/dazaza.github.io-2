<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用于快速傅立叶变换的量子电路</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">用于快速傅立叶变换的量子电路</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-03 02:20:52</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/556e11f1c2630eadfbb9f62da735c80b.jpg"><img src="http://img2.diglog.com/img/2020/11/556e11f1c2630eadfbb9f62da735c80b.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>We propose an implementation of the algorithm for the fast Fourier transform (FFT) as a quantum circuit consisting of a combination of some quantum gates. In our implementation, a data sequence is expressed by a tensor product of vector spaces. Namely, our FFT is defined as a transformation of the tensor product of quantum states. It is essentially different from the so-called quantum Fourier transform (QFT) defined to be a linear transformation of the amplitudes for the superposition of quantum states. The quantum circuit for the FFT consists of several circuits for elementary arithmetic operations such as a quantum adder, subtractor and shift operations, which are implemented as effectively as possible. Namely, our circuit does not generate any garbage bits. The advantages of our method compared to the QFT are its high versatility, and data storage efficiency in terms, for instance, of the quantum image processing.</p><p>我们提出了一种实现快速傅立叶变换(FFT)的算法，它是由若干量子门组合而成的量子电路。在我们的实现中，数据序列由向量空间的张量积来表示。也就是说，我们的快速傅立叶变换被定义为量子态的张量积的变换。它与所谓的量子傅里叶变换(QFT)有本质的不同，QFT被定义为量子态叠加幅度的线性变换。FFT的量子电路由几个用于基本算术运算的电路组成，例如量子加法器、减法器和移位运算，这些电路被尽可能有效地实现。也就是说，我们的电路不会生成任何垃圾位。与QFT相比，我们的方法的优点是它的通用性强，并且在例如量子图像处理方面的数据存储效率。</p><p>  Quantum computing, which utilizes quantum entanglement and quantum superpositions inherent to quantum mechanics, is rapidly gaining ground to overcome the limitations of classical computing. Shor’s algorithm [ 1] solving the integer factorization problem in a polynomial time and Grover’s algorithm [ 2] making it possible to substantially speed up the search in unstructured databases   Footnote 1 are one of the best-known examples of the astounding properties of quantum computing (see [ 6], for example, for various applications of quantum computing).</p><p>量子计算利用量子力学固有的量子纠缠和量子叠加，正在迅速取得进展，以克服经典计算的局限性。Shor的算法[1]在多项式时间内解决整数因式分解问题，Grover的算法[2]使得在非结构化数据库中的搜索速度大大加快脚注1是量子计算惊人特性的最著名的例子之一(例如，对于量子计算的各种应用，参见[6])。</p><p> An implementation of the Fourier transform as a quantum circuit sometimes plays a crucial role on quantum computing. Indeed, the quantum Fourier transform (QFT) [ 7] is a key ingredient of many important quantum algorithms, including Shor’s factoring algorithm and the quantum phase estimation algorithm to estimate the eigenvalues of a unitary operator. Here, the QFT is the Fourier transform for the amplitudes of a quantum state:</p><p>傅里叶变换作为量子电路的实现有时在量子计算中起着至关重要的作用。事实上，量子傅立叶变换(QFT)[7]是许多重要量子算法的关键组成部分，包括Shor因子分解算法和估计酉算子特征值的量子相位估计算法。这里，QFT是量子态振幅的傅里叶变换：</p><p>  where we set  \(N=2^n\), and the amplitudes  \(\{X_k\}\) are the classical discrete Fourier transform of the amplitudes  \(\{x_j\}\)</p><p>其中N=2^n，振幅(Xk)是振幅(Xj)的经典离散傅立叶变换。</p><p>  where  \(W_N:=\exp (-2\pi i/N)\). Due to the superposition of the state ( 1.1) and quantum parallelism, the QFT can be implemented in a quantum circuit consisting of  \(O(n^2)\) quantum gates, which is much more efficient than the fast Fourier transform (FFT) [ 8] whose complexity of the computation is  \(O(n 2^n)\).</p><p>其中\(W_N：=\exp(-2\pi I/N)\)。由于态(1.1)和量子并行性的叠加，QFT可以在由O(n^2)个量子门组成的量子电路中实现，这比计算复杂度为O(n2^n)的快速傅立叶变换(FFT)[8]要高效得多。</p><p> The Fourier transform that we consider in this paper is somewhat different from the QFT: We propose a quantum implementation of the algorithm of the FFT rather than the QFT. In our procedure, a data sequence is expressed in terms of a tensor product of vector spaces:  \(\bigotimes _{j=0}^{N-1}|x_j\rangle \). Namely, the state vectors representing the given classical information are prepared via so-called  basis encoding [ 9]. (On the other hand, the QFT ( 1.1) is based on the  amplitude encoding.) Based on the basis encoding, the Fourier transform is defined as</p><p>我们在本文中考虑的傅里叶变换与QFT有所不同：我们提出了FFT而不是QFT算法的量子实现。在我们的过程中，数据序列用向量空间的张量积表示：\(\BigoTimes_{j=0}^{N-1}|x_j\Rangle\)。即，通过所谓的基编码来准备表示给定经典信息的状态向量[9]。(另一方面，QFT(1.1)基于幅度编码。)。基于基编码，傅里叶变换被定义为。</p><p>  where the data sequence  \(\{X_k\}\) is the Fourier transform of  \(\{x_j\}\) as expressed in ( 1.2). We adopt the reversible FFT [ 10] as an algorithm of the above Fourier transform and implement it as a quantum circuit whose computational complexity is  \(O(n 2^n)\). In this point of view, the processing speed is the same as the classical one, as long as we consider only a single data sequence. Nevertheless, there are following advantages compared to the classical FFT, and even compared to the QFT. The first is due to quantum parallelism. Namely, utilizing quantum superposition of multiple data sets, we can simultaneously process them. Note here that, there exist several problems how to encode classical data in quantum states (and also how to read resultant superposed quantum data), which are peculiar to quantum computing. To take advantage of quantum computing, a qRAM suitable for quantum computation [ 3, 4, 5] is necessary [see Sect.  5 for comparison of computational costs between the classical FFT and our quantum version of the FFT (let us denote it as QFFT) including data encoding]. The second is due to its high versatility: The method is always applicable to data sets that can be processed by the conventional FFT. The third advantage is its data storage efficiency in terms, for instance, of the quantum image (see [ 11, 12, 13, 14] for some applications of the QFT to quantum data sets).</p><p>其中数据序列\(xk\)是如(1.2)所示的\(xj\)的傅立叶变换。我们采用可逆FFT[10]作为上述傅里叶变换的算法，并将其实现为计算复杂度为O(n2^n)的量子电路。从这个角度来看，只要我们只考虑单一的数据序列，处理速度就与经典的处理速度相同。尽管如此，与经典的FFT相比，甚至与QFT相比，它有以下优点。第一个原因是量子平行。也就是说，利用多个数据集的量子叠加，我们可以同时处理它们。注意，这里存在几个问题，如何在量子态中编码经典数据(以及如何读取合成的叠加量子数据)，这是量子计算所特有的。为了利用量子计算的优势，需要一个适合于量子计算的qRAM[3，4，5][有关包括数据编码在内的经典FFT和我们的量子版本的FFT(让我们将其表示为QFFT)之间的计算成本的比较，请参见第295节]。第二个原因是它的通用性很强：该方法总是适用于传统FFT可以处理的数据集。第三个优点是它的数据存储效率，例如，就量子图像而言(参见[11，12，13，14]以了解量子数据集的一些应用)。</p><p> A  \(2\times 2\) pixel image with a grayscale value ranging from 0 to  \(M-1\) \((M=2^m)\) is depicted in the left panel.  \(x_{j,k}\) in the right panel denotes the value of the grayscale on the ( j,  k)-site. The quantum image can be represented as  \(|x_{0,0}\rangle \otimes |x_{0,1}\rangle \otimes |x_{1,0}\rangle \otimes |x_{1,1}\rangle \in (\mathbb {C}^2)^{\otimes 4m}\)</p><p>左面板中描绘了灰度值从0到(M-1)((M=2^m))的2×2像素图像。右侧面板中的\(X_{j，k}\)表示(j，k)站点上的灰度值。量子图像可以表示为\(|x_{0，0}\Rangle\oTimes|x_{0，1}\Rangle\oTimes|x_{1，0}\Rangle\oTimes|x_{1，1}\Rangle\in(\mathbb{C}^2)^{\oTimes 4M}\)</p><p> Let us illustrate the third advantage above with a simple example: an  \(L \times L\) pixel image with a grayscale value ranging from 0 to  \(M-1\) ( \(M=2^m\)) (see Fig.  1 for  \(L=2\)). (This problem is equivalent to a lattice quantum many-body problem on an  \(L\times L\) square lattice with each site occupied by a particle with  M degrees of freedom.) This quantum image  \(|\psi ^{(\alpha )}\rangle \) ( \(\alpha \) denotes the label of the image) can be represented by a tensor product of vector spaces [ 15, 16, 17, 18]:</p><p>让我们用一个简单的例子来说明上面的第三个优点：灰度值从0到(M-1)(M=2^m)的L×L\)像素图像(参见图)。1代表\(L=2\))。(这个问题等价于L×L正方形晶格上的晶格量子多体问题，每个格点由一个M个自由度的粒子占据。)。这个量子图像\(|\psi^{(\alpha)}\rangle\)(\(\alpha\)表示图像的标签)可以用向量空间[15，16，17，18]的张量积表示：</p><p> $$\begin{aligned} |\psi ^{(\alpha )}\rangle =\bigotimes _{(j,k)=(0,0)}^{(L-1,L-1)} |x^{(\alpha )}_{j,k}\rangle , \qquad 0\le x^{(\alpha )}_{j,k}\le M-1. \end{aligned}$$</p><p>$$\BEGIN{对齐}|\psi^{(\alpha)}\rangle=\bigoTimes_{(j，k)=(0，0)}^{(L-1，L-1)}|x^{(\alpha)}_{j，k}\rangle，\qquad 0\le x^{(\alpha)}_{j，k}\le M-1。\结束{对齐}$$。</p><p> Since  \(|\psi ^{(\alpha )}\rangle \in (\mathbb {C}^2)^{\otimes m L^2}\), it uses  \(mL^2\) qubits. By use of the quantum superposition, the QFFT can simultaneously process at most  \(2^{mL^2}\) quantum images:</p><p>由于(|\psi^{(\alpha)}\rangle\in(\mathbb{C}^2)^{\oTimes m L^2}\)，它使用\(mL^2)个量子比特。利用量子叠加，QFFT最多可以同时处理2^{mL^2}个量子图像：</p><p> $$\begin{aligned} |\Psi \rangle =\sum _{\alpha =1}^{2^{mL^2}} c_{\alpha } |\psi ^{(\alpha )}\rangle \in (\mathbb {C}^2)^{\otimes m L^2} \qquad (c_{\alpha }\in \mathbb {C}). \end{aligned}$$</p><p>$$\BEGIN{ALIGNED}|\psi\rangle=\sum_{\alpha=1}^{2^{mL^2}}c_{\alpha}|\psi^{(\alpha)}\rangle\in(\mathbb{C}^2)^{\oTimes m L^2}\qquad(c_{\alpha}\in\mathbb{C})。\结束{对齐}$$。</p><p> On the other hand, to apply the QFT to the above image processing, we need to prepare the quantum image in the form of</p><p>另一方面，要将量子傅立叶变换应用到上述图像处理中，需要将量子图像制备成。</p><p>  where  \(|\widetilde{\psi }^{(\alpha )}\rangle \in (\mathbb {C}^2)^{\otimes 2\log _2L}\) which uses only  \(2\log _2L\) qubits [cf. ( 1.4) for the QFFT] [ 19, 20, 21]. However, since the Fourier coefficients [see ( 1.1) and ( 1.2)] are expressed as the amplitudes of the superposition, it takes exponentially long time to extract all of them completely. Furthermore, to properly perform the Fourier transform for the multiple  \(2^{m L^2}\) quantum images, they must be represented as</p><p>其中\(|\widetilde{\psi}^{(\alpha)}\Rangle\in(\mathbb{C}^2)^{\oTimes 2\log_2L}\)仅使用\(2\log_2L\)量子位[参见。(1.4)QFFT][19、20、21]。然而，由于傅立叶系数[见(1.1)和(1.2)]被表示为叠加的振幅，要完全提取它们需要指数级的长时间。此外，为了正确地对多个\(2^{m L^2})个量子图像执行傅里叶变换，必须将它们表示为。</p><p> $$\begin{aligned} |\widetilde{\Psi }\rangle = \bigotimes _{\alpha =1}^{2^{mL^2}}|\widetilde{\psi }^{(\alpha )}\rangle \in (\mathbb {C}^2)^{\otimes (2^{mL^2+1})\log _2L}. \end{aligned}$$</p><p>$$\BEGIN{ALIGNED}|\widetilde{\psi}\rangle=\bigoTimes_{\alpha=1}^{2^{mL^2}}|\widetilde{\psi}^{(\alpha)}\rangle\in(\mathbb{C}^2)^{\oTimes(2^{mL^2+1})\log_2L}。\结束{对齐}$$。</p><p> Namely, for the QFT,  \((2^{mL^2+1})\log _2L\) qubits are required to process the  \(2^{m L^2}\) quantum images, which are much larger than  \(m L^2\) qubits for the QFFT. Moreover, the QFT must be applied to each image individually, since the data set ( 1.7) is not a superposition of images but a tensor product of each image.   Footnote 2 As a result, the total processing time for the QFFT is shorter than that for the QFT, when the number of the quantum images is sufficiently large.</p><p>也就是说，对于QFT，需要((2^{mL^2+1})\log2L\)个量子比特来处理(2^{m L^2})个量子图像，这些量子比特远远大于QFFT的(m L^2)个量子比特。此外，QFT必须单独应用于每个图像，因为数据集(1.7)不是图像的叠加，而是每个图像的张量积。脚注2因此，当量子图像的数量足够大时，QFFT的总处理时间比QFT短。</p><p> In this paper, we construct a quantum circuit of the above explained QFFT, by implementing some elementary arithmetic operations such as a quantum adder [ 22, 23, 24, 25, 26, 27], subtractor [ 28, 29, 30, 31] and newly developed shift-type operations, as efficiently as possible: Our quantum circuit does not generate any garbage bits.</p><p>本文通过实现一些基本的算术运算，如量子加法器[22，23，24，25，26，27]，减法器[28，29，30，31]和新开发的移位型运算，尽可能高效地构造了上述QFFT的量子电路：我们的量子电路不产生任何无用信息位。</p><p> The outline of the paper is as follows. In the subsequent section, introducing the algorithm of a quantum version of the FFT, we show the elementary arithmetic operations required for the implementation of the QFFT as a quantum circuit. In Sect.  3, we actually implement these elementary arithmetic operations into quantum circuits. In Sect.  4, combining these elementary circuits efficiently, we construct a quantum circuit for the QFFT. The number of quantum gates required for the implementation of the QFFT is estimated in Sect.  5. The computational costs between the classical FFT and the QFFT including data encoding are also discussed in this section. In Sect.  6, we illustrate a concrete example of an application of the QFFT. Section  7 is devoted to a summary and discussion. Some technical details are deferred to Appendix.</p><p>这篇论文的提纲如下。在接下来的部分，介绍FFT的量子版本的算法，我们将展示将QFFT实现为量子电路所需的基本算术运算。在第三节中，我们实际上将这些基本算术运算实现到量子电路中。在第四节中，我们将这些基本电路有效地结合起来，构造了QFFT的量子电路。第五节估计了实现QFFT所需的量子门数量。本节还讨论了经典FFT和QFFT之间的计算成本，包括数据编码。在第六节中，我们举例说明了QFFT的一个具体应用实例。第七节专门进行总结和讨论。一些技术细节将推迟到附录中。</p><p> In this section, we introduce the algorithm of a quantum version of the FFT and pictorially represent several arithmetic operations required for the implementation of the QFFT as a quantum circuit. (See [ 32], for instance, for the detailed algorithm of the FFT.) We only use the basis encoding method to obtain the quantum states. The matrix-like notations introduced here are helpful for the implementation of quantum algorithms.</p><p>在本节中，我们将介绍FFT的量子版本的算法，并图形化地表示将QFFT实现为量子电路所需的几种算术运算。(例如，有关FFT的详细算法，请参见[32]。)。我们只使用基编码的方法来获得量子态。这里介绍的矩阵式符号对量子算法的实现很有帮助。</p><p>  Let us start the formula ( 1.2) and ( 1.3) of the Fourier transform. Setting  \(W_{N}=\exp (-2\pi i/N)\) \((N=2^n)\) and decomposing the summation in ( 1.2) into the odd and even parts, we have</p><p>让我们从傅立叶变换的公式(1.2)和(1.3)开始。设置\(W_{N}=\exp(-2\pi I/N)\)\((N=2^n)\)并将(1.2)中的求和分解为奇数和偶数部分，我们得到。</p><p> $$\begin{aligned} \left| X_k\right\rangle =\left| G^{(n-1,0)}_k+W_{N}^{k} G^{(n-1,1)}_k\right\rangle , \,\, \left| X_{k+N/2}\right\rangle =\left| G^{(n-1,0)}_k-W_{N}^k G^{(n-1,1)}_k\right\rangle , \end{aligned}$$</p><p>$$\BEGIN{Alignment}\Left|X_k\Right\Rangle=\Left|G^{(n-1，0)}_k+W_{N}^{k}G^{(n-1，1)}_k\Right\Rangle，\Left|X_{k+N/2}\Rangle=\Left|G^G^{(n-1，0)}_k-W_{N}^k G^{(n-1，1)}_k\Rangle，\end{aligned}$。</p><p> where  \(0\le k \le N/2-1\), and  \({G_k^{(n-1,p)}}\) ( \(p=0,1\)) is the Fourier coefficients for  \(\{x_{2r+p}\}\) \((0\le r \le N/2-1)\):</p><p>其中\(0\le k\le N/2-1\)和\({G_k^{(n-1，p)})(\(p=0，1\))是\(x2r+p}\}\)\((0\le r\le N/2-1)\)的傅立叶系数：</p><p>  Note that  \(G^{(n-1,p)}_{k+N/2}=G^{(n-1,p)}_k\) and  \(W^{N/2}_N=-1\) hold. In general,  \(X_k\) is a complex number and the notation  \(\left| X_k\right\rangle \) stands for  \(\left| (X_k)_r\right\rangle \otimes \left| (X_k)_i\right\rangle \), where  \((X_k)_r\) and  \((X_k)_i\) are the real and imaginary part of  \(X_k\), respectively. Pictorially, ( 2.1) can be represented as so-called a butterfly diagram:</p><p>注意\(G^{(n-1，p)}_{k+N/2}=G^{(n-1，p)}_k\)和\(W^{N/2}_N=-1\)成立。通常，\(X_k\)是一个复数，记号\(\Left|X_k\Right\Rangle\)表示\(\Left|(X_K)_r\Right\rangle\Left|(X_K)_i\Right\Rangle\)，其中\((X_K)_r\)和\((X_K)_i\)分别是\(X_K)的实部和虚部。如图所示，(2.1)可以表示为所谓的蝴蝶图：</p><p>  where  \(0\le k \le N/2-1\). Here, the broken line means the multiplication by  \(-1\). For convenience, we also denote it as a matrix-like notation:</p><p>其中\(0\le k\le N/2-1\)。这里，虚线表示乘以\(-1\)。为方便起见，我们还将其表示为类似矩阵的表示法：</p><p> $$\begin{aligned} \begin{bmatrix} |X_k\rangle \\ |X_{k+N/2}\rangle \end{bmatrix} =\begin{bmatrix} 1 &amp;{} 1 \\ 1 &amp;{}-1 \end{bmatrix} \begin{bmatrix} 1 &amp;{} 0 \\ 0 &amp;{}W_N^k \end{bmatrix} \begin{bmatrix} \left| G^{(n-1,0)}_k\right\rangle \\ \left| G^{(n-1,1)}_k\right\rangle \end{bmatrix} =\begin{bmatrix} \left| G^{(n-1,0)}_k+W_{N}^{k} G^{(n-1,1)}_k\right\rangle \\ \left| G^{(n-1,0)}_k-W_{N}^{k} G^{(n-1,1)}_k\right\rangle \end{bmatrix}. \end{aligned}$$</p><p>$$\BEGIN{ALIGNED}\BEGIN{bMatrix}|X_k\Rangle\\|X_{k+N/2}\Rangle\end{bMatrix}=\Begin{bMatrix}1&amp；{}1\\1&amp；{}-1\\end{bMatrix}\Begin{bMatrix}1&amp；0\\0&amp；{}W_N^k\end{bMatrix}\Begin{bMatrix}\Left|G^{(n-1，0)}_k\Rangle\Left|G^{(n-1，1)}_k\Rangle\Rangle\end{bMatrix}=\Begin{bMatrix}\Left|G^{(n-1，0)}_k+W_{N}^{k}G^{{(n-1，1)}_k\Rangle\Left|G^{{(n-1，0)}_k-W_{N}^。{k}G^{(n-1，1)}_k\right\rangle\end{bMatrix}。\结束{对齐}$$。</p><p>  $$\begin{aligned} \begin{bmatrix} A &amp;{} B \\ C&amp;{} D \end{bmatrix} \begin{bmatrix} |a\rangle \\ |b\rangle \end{bmatrix} =\begin{bmatrix} |A a+B b\rangle \\ |C a+D d\rangle \end{bmatrix} \quad (A,B,C, D\in \mathbb {C}). \end{aligned}$$</p><p>$$\BEGIN{ALIGNED}\BEGIN{bMatrix}A&amp；{}B\\C&amp；{}D\End{bMatrix}\Begin{bMatrix}|a\Rangle\\|b\Rangle\End{bMatrix}=\Begin{bMatrix}|A a+B b\Rangle\C a+D d\Range\End{bMatrix}\quad(A，B，C，D\in\mathbb{C})。\结束{对齐}$$。</p><p> Do not confuse the above manipulation with conventional matrix operations: The results are  not liner combinations of  \(|a\rangle \) and  \(|b\rangle \). The matrix-like notations are useful to implement quantum algorithms as quantum circuits.</p><p>不要将上述操作与传统的矩阵运算混淆：结果不是\(|a\rangle\)和\(|b\rangle\)的线性组合。类似矩阵的符号对于将量子算法实现为量子电路很有用。</p><p> Again we decompose the Fourier transform for  \(\{x_{2r}\}\) (resp.  \(\{x_{2r+1}\}\)) into that for  \(\{x_{4s}\}\) and  \(\{x_{4s+2}\}\) (resp.  \(\{x_{4s+1}\}\) and  \(\{x_{4s+3}\}\)) ( \(0\le s \le N/4-1\)). The result reads</p><p>我们再一次分解\(x2r}\}\)的傅里叶变换。\({x{2R+1}\}))分为\({x{4s}\})和\({x4s+2}\})(分别为：\{x4s+1})和({x4s+2})(分别为：\{x4s})和({x4s+2})。\({x_{4s+1}\}\)和\({x_{4s+3}\})(\(0\le s\le N/4-1\))。结果为。</p><p> $$\begin{aligned} \begin{bmatrix} \left| G_k^{(n-1,p)}\right\rangle \\ \left| G_{k+N/4}^{(n-1,p)}\right\rangle \end{bmatrix} =\begin{bmatrix} \left| G_k^{(n-2,p)}+W_{N/2}^k G_k^{(n-2,p+2)}\right\rangle \\ \left| G_k^{(n-2,p)}-W_{N/2}^k G_k^{(n-2,p+2)}\right\rangle \end{bmatrix}\quad (p=0,1;0\le k \le N/4-1), \end{aligned}$$</p><p>$$\BEGIN{对齐}\BEGIN{bMatrix}\Left|G_k^{(n-1，p)}\Right\Rangle\\Left|G_{k+N/4}^{(n-1，p)}\Right\Rangle\end{bMatrix}=\Begin{bMatrix}\Left|G_k^{(n-2，p)}+W_{N/2}^k G_k^{(n-2，p+2)}\Right\Rangle\Left|G_k^{(n-2，p)}\Right\Rangle\Left|G_k^{(n-2，p)}\Right\Rangle\Left|G_k^{(n-2，p)}。P)}-W_{N/2}^k G_k^{(n-2，p+2)}\right\RangeEnd{bMatrix}\quad(p=0，1；0\le k\le N/4-1)，\end{aligned}$$。</p><p>  $$\begin{aligned} G_k^{(n-2,q)}=\sum _{s=0}^{N/4-1} W_N^{4 sk} x_{4s+q} \quad (0\le q \le 3; \,\, 0\le s \le N/4-1). \end{aligned}$$</p><p>$$\BEGIN{ALIGNED}G_k^{(n-2，q)}=\sum_{s=0}^{N/4-1}W_N^{4SK}x_{4s+q}\quad(0\le q\le3；\，\，0\le s\le N/4-1)。\结束{对齐}$$。</p><p>  $$\begin{aligned} \begin{bmatrix} \left| G_k^{(n-m,p)}\right\rangle \\ \left| G_{k+N/2^{m+1}}^{(n-m,p)}\right\rangle \end{bmatrix}= \begin{bmatrix} \left| G_k^{(n-m-1,p)}+W_{N/2^m}^k G_k^{(n-m-1,p+2^{m})}\right\rangle \\ \left| G_k^{(n-m-1,p)}-W_{N/2^m}^k G_k^{(n-m-1,p+2^{m})}\right\rangle \end{bmatrix}, \end{aligned}$$</p><p>$$\BEGIN{ALIGNED}\BEGIN{bMatrix}\Left|G_k^{(n-m，p)}\Right\Rangle\\Left|G_{k+N/2^{m+1}}^{(n-m，p)}\Right\Rangle\end{bMatrix}=\Begin{bMatrix}\Left|G_k^{(n-m-1，p)}+W_{N/2^m}^k G_k^{(n-m-1，P+2^{m})}\right\Rangle\\Left|G_k^{(n-m-1，p)}-W_{N/2^m}^k G_k^{(n-m-1，p+2^{m})}\right\range\end{bMatrix}，\end{aligned}$。</p><p>   This is the algorithm of the QFFT. The classical version is reproduced by just interpreting the state vectors as scalars.</p><p>这是QFFT的算法。经典版本仅通过将状态向量解释为标量来重现。</p><p> Most importantly, the QFFT/FFT is decomposed into  \(\log _2N\) “layers,” where each layer consist of  N/2 butterfly diagrams (see Fig.  2 for  \(N=8\)): Totally  \((N\log _2 N)/2\) diagrams are used in the QFFT/FFT. As a result, the total computational complexity of the Fourier transform ( 1.2) is reduced from  \(O(N^2)\) to  \(O(N\log _2 N)\) by the above procedure.</p><p>最重要的是，QFFT/FFT被分解成\(\log_2N\)“层”，每层由N/2个蝶形图组成(关于\(N=8)，见图2)：QFFT/FFT中全部使用\((N\log_2N)/2\)图。结果，通过上述过程，傅立叶变换(1.2)的总计算复杂度从O(N^2)降低到O(N\log2N)。</p><p> A pictorial representation of the QFFT  \(\bigotimes _{j=0}^{N-1}|x_j\rangle \longmapsto \bigotimes _{k=0}^{N-1}|X_k\rangle \) for  \(N=8\). Here,  \(W_{k}=\exp (-2\pi i/k)\), and  \(G^{(j,p)}_k\) is determined by the recursion relation ( 2.8) with ( 2.9)</p><p>(N=8)的QFFT\(\BigoTimes_{j=0}^{N-1}|x_j\Rangle\Longmapsto\BigoTimes_{k=0}^{N-1}|X_k\Rangle\)的图示。这里，\(W_{k}=\exp(-2\pi i/k)\)和\(G^{(j，p)}_k\)由递归关系(2.8)和(2.9)确定。</p><p>  As seen in ( 2.4), to implement the QFFT in a quantum circuit, the multiplication of the matrices</p><p>如(2.4)所示，为了在量子电路中实现QFFT，矩阵的乘法。</p><p>  should be carried out in terms of quantum computation. The first one is separated into an adder, a subtractor and shift operators by the LDU decomposition</p><p>应该从量子计算的角度来进行。第一种是通过LDU分解将其分解为加法器、减法器和移位算子。</p><p> $$\begin{aligned} \left[ \begin{matrix}1&amp;{}1\\ 1&amp;{}-1\end{matrix}\right] = \left[ \begin{matrix}1&amp;{}0\\ 1&amp;{}-1\end{matrix}\right] \left[ \begin{matrix}1&amp;{}0\\ 0&amp;{}2\end{matrix}\right] \left[ \begin{matrix}1&amp;{}1\\ 0&amp;{}1\end{matrix}\right] . \end{aligned}$$</p><p>$$\Begin{Alignment}\Left[\Begin{Matrix}1&amp；{}1\\1&amp；{}-1\End{Matrix}\Right]=\Left[\Begin{Matrix}1&amp；{}0\\1&amp；{}-1\End{Matrix}\Right]\Left[\Begin{Matrix}1&amp；2\End{Matrix}\Right]\Left[\Begin{Matrix}1&amp；{}1\\0&amp；{}1\End{Matrix}\Right]。\结束{对齐}$$。</p><p> Utilizing the matrix-like notation as in ( 2.4), the action of the first matrix defined in ( 2.4) on states  \(|a\rangle \) and  \(|b\rangle \) can be graphically interpreted as</p><p>利用(2.4)中的类似于矩阵的表示法，可以将(2.4)中定义的第一矩阵对状态\(|a\rangle\)和\(|b\rangle\)的动作图形化地解释为。</p><p>  Note again that the above operation differs from the conventional matrix operations. On the other hand, the second matrix is simply expressed as</p><p>再次注意，上述运算不同于传统的矩阵运算。另一方面，第二个矩阵简单地表示为。</p><p>    Consequently, the QFFT can be implemented into a quantum circuit consisting of adders, subtractors and shift operators. In the next section, we explain these arithmetic operators. An actual implementation of these operators into the butterfly operations ( 2.14) is deferred to Sect.  4.</p><p>因此，QFFT可以实现为由加法器、减法器和移位算符组成的量子电路。在下一节中，我们将解释这些算术运算符。这些运算符在蝶形运算(2.14)中的实际实现将推迟到第2.14节。</p><p> In this section, we pictorially present a concept of some quantum arithmetic operations such as a quantum adder, subtractor and shift operators, which are required to implement the QFFT as a quantum circuit.</p><p>在这一部分中，我们图形化地介绍了一些量子算术运算的概念，如量子加法器、减法器和移位运算符，这些运算是将QFFT实现为量子电路所必需的。</p><p> Here, we adopt two’s complement notation to represent a negative number. Let us write a state  \(|a\rangle \) \((a\ge 0)\) using the binary representation  \(|a\rangle =|a_{n-1} \cdots a_0\rangle :=|a_{n-1}\rangle \otimes \cdots \otimes |a_0\rangle \) ( \(a_j\in \{0,1\}\)). Let  m ( \(m&gt;n\)) be a total number of qubits of the system. Let us express  \(|a\rangle \) as</p><p>这里，我们采用二的补码记数法来表示负数。让我们使用二进制表示\(|a\rangle=|a_{n-1}\cdots a_0\rangle：=|a_{n-1}\rangle\oTimes\otime|a_0\rangle\)(\(a_j\in\{0，1\}))来写一个状态\(|a\rangle\)\((a\ge 0)\)。设m(\(m&gt；n\))是系统的量子比特总数。让我们将\(|a\rangle\)表示为。</p><p>  where  \(a_+=0\). Then, a negative number  \(|b\rangle \) ( \(=|-a-1\rangle \)) can be represented by the complement of  \(|a\rangle \):</p><p>其中\(a_+=0\)。然后，负数\(|b\rangle\)(\(=|-a-1\rangle\))可以由\(|a\rangle\)的补码表示：</p><p>  where  \(a_-=\bar{a}_+=1\),  \(\bar{0}=1\) and  \(\bar{1}=0\). Namely, for the  m-qubit system, the number  \(\{-2^{m-1},-2^{m-1}+1,\dots ,2^{m-1}-1\}\) can be expressed by this notation. For instance,  \(m=3\)</p><p>其中\(a_-=\bar{a}_+=1\)、\(\bar{0}=1\)和\(\bar{1}=0\)。也就是说，对于m量子比特系统，数字(-2^{m-1}，-2^{m-1}+1，\dots，2^{m-1}-1)可以用这个记号来表示。例如，\(m=3\)。</p><p> $$\begin{aligned} \begin{array}{llll} |0\rangle =|000\rangle ,&amp;{}\quad |1\rangle =|001\rangle ,&amp;{}\quad |2\rangle =|010\rangle ,&amp;{} |3\rangle =|011\rangle ,\\ |-4\rangle =|100\rangle ,&amp;{} \quad |-3\rangle =|101\rangle ,&amp;{}\quad |-2\rangle =|110\rangle ,&amp;{}\quad |-1\rangle =|111\rangle . \end{array} \end{aligned}$$</p><p>$$\BEGIN{ALIGNED}\BEGIN{array}{llll}|0\Rangle=|000\Rangle，&amp；{}\quad|1\Rangle=|001\Rangle，&amp；{}\quad|2\Rangle=|010\Rangle，&amp；{}|3\Rangle=|011\Rangle，\\-4\Rangle=|100\Rangle，&amp；{}\quad|-3\Rangle=|101\Rangle，&amp；{}\quad|-2\Rangle=|110\Rangle，&amp；{}\Quad|-1\Rangle=|111\Rangle。\结束{数组}\结束{对齐}$$。</p><p>  In the actual computation, to avoid overflow, we sometimes need to increase the number of bits (a so-called sign extension). This operation can be achieved by just inserting  \(a_{\pm }\)’s to the representation: For instance, the representation for the  m-qubit system can be extended to that for the  l-qubit system ( \(l&gt;m\)):</p><p>在实际计算中，为了避免溢出，有时需要增加位数(即所谓的符号扩展)。只需将\(a_{\pm}\)插入表示即可实现此操作：例如，可以将m-量子比特系统的表示扩展为l-量子比特系统的表示(\(l&gt；m\))：</p><p>  In Fig.  3, we show a quantum circuit to increase the number of digits from 4-qubit to 6-qubit.</p><p>在图3中，我们展示了一种将位数从4量子比特增加到6量子比特的量子电路。</p><p> In Appendix, the number of extra qubits  \(a_{\pm }\) required for the QFFT is discussed.</p><p>在附录中，讨论了QFFT所需的额外量子位数\(a_{\pm}\)。</p><p> An operation to increase the number of digits from 4-qubit  \(|a_{\pm } a_2 a_1 a_0\rangle \) to 6-qubit  \(|a_{\pm } a_{\pm } a_{\pm } a_2 a_1 a_0\rangle \), where  \(a_+=0\) (resp.  \(a_-=1\)) for a positive (resp. negative) number. The extended state is achieved by copying  \(a_{\pm }\) via CNOT gates</p><p>将位数从4量子比特\(|a_{\pm}a_2a_1 a_0\Rangle\)增加到6量子比特\(|a_{\pm}a_2a_1 a_0\Rangle\)的操作，其中\(a_+=0\)(。\(a_-=1\))表示正(分别为。负)编号。扩展状态是通过CNOT门复制\(a_{\pm}\)来实现的。</p><p>  Let us consider an adder and a subtractor, by slightly modifying the arguments developed in [ 27,  31].</p><p>让我们考虑一个加法器和一个减法器，稍微修改[27，31]中的论点。</p><p> An adder circuit for  \(|a_{\pm } a_{\pm } a_2 a_1 a_0 + b_{\pm } b_{\pm } b_2 b_1 b_0\rangle \). The circuit consists of the Toffoli and the Peres gates defined as in Fig.  5.  \(c_j\) and  \(s_j\) ( \(j=1, 2, 3\)) are the carry bit and the sum bit defined in ( 3.6)</p><p>用于(|a_{\pm}a_{\pm}a_2a_1a_0+b_{\pm}b_{\pm}b_2b_1b_0\rangle\)的加法器电路。该电路由图5中定义的Toffoli门和Peres门组成。\(c_j\)和\(s_j\)(\(j=1，2，3\))是(3.6)中定义的进位位和和位。</p><p> The addition of two  n-bit numbers with the binary representation  \(a=a_{n-1} \cdots a_0\) and  \(b=b_{n-1} \cdots b_0\) ( \(a_j, b_j\in \{0,1\}\)) is calculated as</p><p>具有二进制表示\(a=a_{n-1}\cdots a_0\)和\(b=b_{n-1}\cdots b_0\)(\(a_j，b_j\in\0，1\))的两个n位数的相加计算如下。</p><p>  where the carry bit  \(c_j\) and the sum bit  \(s_j\) ( \(j=1, \cdots n\)) are defined by</p><p>其中进位位\(c_j\)和和位\(s_j\)(\(j=1，\cdots n\))由下式定义。</p><p> $$\begin{aligned} c_j&amp;={\left\{ \begin{array}{ll} a_0 b_0 &amp;{}(j=1)\\ a_{j-1}b_{j-1} \oplus b_{j-1}c_{j-1} \oplus c_{j-1}a_{j-1} &amp;{}(2 \le j \le n)\end{array}\right. }, \nonumber \\ s_j&amp;={\left\{ \begin{array}{ll} a_0\oplus b_0 &amp;{}(j=0)\\ a_j \oplus b_j \oplus c_j &amp;{}(1 \le j \le n-1)\\ a_{\pm }\oplus b_{\pm }\oplus c_n &amp;{}(j=n) \end{array}\right. }. \end{aligned}$$</p><p>$$\BEGIN{ALIGNED}c_j&amp；={\Left\{\Begin{array}{ll}a_0 b_0&amp；{}(j=1)\\a_{j-1}b_{j-1}\o plus b_{j-1}c_{j-1}\o plus c_{j-1}a_{j-1}&amp；{}(2\le j\le n)\end{array}\right。}，\non number\\s_j&amp；={\Left\{\Begin{array}{ll}a_0\Oplus b_0&amp；{}(j=0)\\a_j\Oplus b_j\Oplus c_j&amp；{}(1\le j\le n-1)\\a_{\pm}\Oplus b_{\pm}\Oplus c_n&amp；{}(j=n)\end{array}\右。}。\结束{对齐}$$。</p><p> Note that the symbol  \(\oplus \) denotes exclusive disjunction. In terms of a quantum circuit, this addition is implemented in the transformation of the state</p><p>请注意，符号\(\Oplus\)表示异或运算。就量子电路而言，这种加法是在态的变换中实现的。</p><p>    Figure  4 shows the actual circuit which is a slightly modified version of a quantum adder originally developed in [ 27]. The adder circuit consists of the Toffoli gate [ 33] and the Peres gate [ 34] defined as in Fig.  5, where  V and  \(V^{\dagger }\) are, respectively, given by</p><p>图4显示了实际电路，它是最初在[27]中开发的量子加法器的略微修改版本。加法器电路由如图5中定义的Toffoli门[33]和Peres门[34]组成，其中V和\(V^{\dagger}\)分别由下式给出</p><p> $$\begin{aligned} V=\frac{1+i}{2}\begin{pmatrix}1 &amp;{} -i \\ -i &amp;{} 1\end{pmatrix}, \quad V^{\dagger }=\frac{1-i}{2} \begin{pmatrix}1 &amp;{} i \\ i &amp;{} 1\end{pmatrix}. \end{aligned}$$</p><p>$$\BEGIN{ALIGNED}V=\frac{1+i}{2}\Begin{pMatrix}1&amp；{}-i\\-i&amp；{}1\end{pMatrix}，\quad V^{\dagger}=\frac{1-i}{2}\Begin{pMatrix}1&amp；{}i\\i&amp；{}1\end{pMatrix}。\结束{对齐}$$。</p><p> The Toffoli gate (left panel) and the Peres gate (right panel).  V and  \(V^{\dagger }\) are defined by ( 3.9). The Toffoli and Peres gates require 5 and 4 quantum gates, respectively</p><p>Toffoli门(左图)和佩雷斯门(右图)。V和\(V^{\Dagger}\)由(3.9)定义。Toffoli和Peres门分别需要5个和4个量子门。</p><p> On the other hand, using the identity  \(\overline{\overline{a}+b} = a-b\), we define a quantum subtractor as</p><p>另一方面，使用恒等式\(\overline{\overline{a}+b}=a-b\)，我们将量子减法器定义为。</p><p> $$\begin{aligned} |a\rangle \otimes |b\rangle \longmapsto {\left\{ \begin{array}{ll} |a\rangle \otimes |\overline{ \overline{a}+b }\rangle = |a\rangle \otimes |a-b\rangle \\ |a\rangle \otimes |\overline{ a+\overline{b} }\rangle = |a\rangle \otimes |-a+b\rangle \end{array}\right. }, \end{aligned}$$</p><p>$$\BEGIN{ALIGNED}|a\Rangle\oTimes|b\Rangle\Longmapsto{\Left\{\Begin{array}{ll}|a\Rangle\oTimes|\overline{a}+b}\Rangle=|a\Rangle\oTimes|a-b\Rangle\\a\Rangle\oTimes|\overline{a+\overline{b}}\Rangle=|a\Rangle\oTimes|-a+b\Rangle\end{array}\right。}，\结束{对齐}$$。</p><p> which can be implemented by just inserting NOT gates (denoting it by the symbol  \(\bigoplus \)) to the above defined adder ( 3.8) [ 31]:</p><p>这可以通过将NOT门(用符号\(\Bigoplus\)表示)插入上述加法器(3.8)[31]来实现：</p><p>  The quantum circuit of the adder for  \(n_{\mathrm{in}}\)-qubit input data consists of 6 “layers” as in Fig.  4. (Note here that the number of the layers does not depend on  \(n_{\mathrm{in}}\).) The first, second, fifth and sixth layers, respectively, contain  \(n_{\mathrm{in}}-1\),  \(n_{\mathrm{in}}-2\),  \(n_{\mathrm{in}}-2\) and  \(n_{\mathrm{in}}-1\) CNOT gates. The third layer consists of  \(n_{\mathrm{in}}-1\) Toffoli gates:  \(5(n_{\mathrm{in}}-1)\) CNOT gates are required. The fourth layer contains  \(n_{\mathrm{in}}-1\) Peres gates and one CNOT gates:  \(4 (n_{\mathrm{in}}-1)+1\) CNOT gates are required. Note that the Toffoli (resp. Peres) gate requires 5 (resp. 4) CNOT gates as shown in Fig.  5. Thus, totally  \(13 n_{\mathrm{in}}-14\) quantum gates are required for the adder circuit for  \(n_{\mathrm{in}}\)-qubit data. On the other hand, the subtractor defined by ( 3.11) requires additional at most  \(3 n_{\mathrm{in}}\) CNOT gates, and hence, totally at most  \(16 n_{\mathrm{in}}-14\) quantum gates are required for the subtractor.</p><p>用于\(n_{\mathm{in}}\)-量子比特输入数据的加法器的量子电路由6个“层”组成，如图4所示。(此处请注意，层数与\(n_{\mathm{in}}\)无关。)。第一层、第二层、第五层和第六层分别包含\(n_{\mathm{in}-1\)、\(n_{\mathm{in}-2\)、\(n_{\mathm{in}}-2\)和\(n_{\mathm{in}}-1\)CNOT门。第三层由\(n_{\mathm{in}-1\)Toffoli门组成：\(5(n_{\mathm{in}}-1)-1)需要CNOT门。第四层包含\(n_{\mathm{in}}-1\)个Peres门和一个CNOT门：\(4(n_{\mathm{in}})-1)+1\)个CNOT门。请注意，Toffoli(分别为。Peres)GATE需要5个(分别为。4)CNOT门如图5所示。因此，对于\(n_{\mathm{in})-量子比特数据的加法器电路总共需要\(13 n_{\mathm{in}}-14\)个量子门。另一方面，(3.11)中定义的减法器最多需要3个n\mathm{in}}个CNOT门，因此减法器总共需要16个n\mathm{in}-14个量子门。</p><p>    we can change the sign of the input number by an adder with NOT gate:</p><p>我们可以通过带非门的加法器来改变输入数字的符号：</p><p>     This operation is carried out by shifting the digits to the left (arithmetic left shift):</p><p>此操作通过将数字向左移位(算术左移)来执行：</p><p> $$\begin{aligned} |a\rangle =|\underbrace{a_{\pm }\dots a_{\pm }}_{m-n} a_{n-1}\dots a_0\rangle \longmapsto |\underbrace{a_{\pm }\dots a_{\pm }}_{m-n-p} a_{n-1}\dots a_0 \underbrace{0\cdots 0}_p\rangle =|2^p a\rangle . \end{aligned}$$</p><p>$$\BEGIN{ALIGNED}|a\rangle=|\下括号{a_{\pm}\dots a_{\pm}}_{m-n}a_{n-1}\dots a_0\rangle\long mapsto|\下括号{a_{\pm}\dots a_{\pm}}_{m-n-p}a_{n-1}\dots a_0\下括号{0\cdots 0}_p\Rangle=|2^p a\Rangle。\结束{对齐}$$。</p><p>   In a similar manner, we can define an arithmetic right shift which is an operation to multiply by  \(2^{-p}\):</p><p>以类似的方式，我们可以定义算术右移位，它是乘以\(2^{-p}\)的运算：</p><p> $$\begin{aligned} |a\rangle =&amp;|\underbrace{a_{\pm }\dots a_{\pm }}_{m-n} a_{n-j-1} \dots a_{0}a_{-1}\cdots a_{-j}\rangle \nonumber \\&amp;\lo</p><p>$$\BEGIN{ALIGNED}|a\rangle=&amp；|\下括号{a_{\pm}\dots a_{\pm}}_{m-n}a_{n-j-1}\dots a_{0}a_{-1}\cdots a_{-j}\Rangle\non number\\&amp；\lo。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://link.springer.com/article/10.1007/s11128-020-02776-5">https://link.springer.com/article/10.1007/s11128-020-02776-5</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/变换/">#变换</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/circuit/">#circuit</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/量子/">#量子</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>