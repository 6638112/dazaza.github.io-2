<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们并不特别 We Are Not Special</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">We Are Not Special<br/>我们并不特别 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-21 06:04:15</div><div class="page_narrow text-break page_content"><p>No one thinks about moving the starting or ending point of the bridge midway through construction.  -Justin Cave</p><p>没有人考虑过在施工过程中移动桥梁的起点或终点。 -贾斯汀·凯夫（Justin Cave）</p><p> Carl worked as a mechanical verification engineer: he tested oil rigs to see how much they vibrated. Humans work and live on oil rigs for long stretches of time, and if they vibrate too much it can be impossible to sleep. While rigs are designed to stay below the threshold, the design and the final version often diverge.</p><p> 卡尔曾担任机械验证工程师：他对石油钻机进行了测试，以查看它们的振动程度。人类在石油钻塔上工作和生活很长一段时间，如果它们振动太大，就无法入睡。尽管钻机的设计要保持在阈值以下，但设计和最终版本通常会有所不同。</p><p> Currently, he was explaining how they find oil. After drilling a hole, he said, “you might also want to add other additives, like acid or hazelnut shells, but also-”</p><p> 目前，他正在解释他们如何找到石油。他说，在钻完一个孔之后，“您可能还想添加其他添加剂，例如酸或榛子壳，但还要-”</p><p>  He smiled. “Your oil reservoir is not like a balloon full of oil. It’s more like a porous structure in the rock.” When drilling in, you might hit a sudden loss of pressure in the pipe. This is extremely dangerous as you don’t know if you’ve broken into the open ocean or have just hit a local void. In the latter case, digging further and suddenly hitting a high pressure area could destroy the pipe. By pumping in hazelnut shells they can gradually fill in small voids and test if they are still in the structure, gradually equalizing the pressure if they are.</p><p>  他笑了。 “您的储油罐不像是一个充满油的气球。它更像是岩石中的多孔结构。”钻进时，您可能会突然遇到管道压力损失。这是非常危险的，因为您不知道自己是闯入大海还是刚撞到局部空隙。在后一种情况下，进一步挖掘并突然撞击高压区域可能会损坏管道。通过泵入榛子壳，它们可以逐渐填充小的空隙并测试它们是否仍在结构中，并逐渐平衡压力。</p><p>   Debates about traditional versus software engineering revolve around what makes us different. The clichés here come from a different camp than the “what makes an engineer” clichés. The ways people try to define “engineering” often work to marginalize software. Differences like “we don’t have licenses” or “we’re not rigorous” are ways of saying that software is less prestigious, less “good” than traditional engineering. As we saw in the  last essay, most of these don’t hold up, and the crossover engineers think the two jobs are much closer in nature than people who have only done one.</p><p>   关于传统工程与软件工程的争论围绕着使我们与众不同的原因。这里的陈词滥调与“什么造就了工程师”陈词滥调来自不同的阵营。人们尝试定义“工程”的方式通常会使软件边缘化。诸如“我们没有许可证”或“我们不严格”之类的区别是说软件比传统工程学没有那么负盛名，也没有“好”。正如我们在上一篇文章中看到的那样，其中大多数并没有解决，跨界工程师认为这两项工作本质上比只完成一项工作的人要亲密得多。</p><p> When people talk about the fundamental differences, in contrast, they’re usually not aiming to make delegitimize software development. Rather, the implicit emphasis is on making software “special”. Making software something that can’t be understood by the narrow lens of engineering.</p><p> 相比之下，当人们谈论基本差异时，他们通常不打算使软件开发合法化。相反，隐含的重点是使软件“特殊”。使软件成为工程学无法理解的东西。</p><p> I see this as a defense mechanism. If software is so different from trad, then it’s okay for us to “not be engineers”. We can say that, sure, we aren’t planning upfront, but that’s because software requirements change so much faster than everywhere else. We don’t apply engineering because we shouldn’t be applying engineering. A good example of this is the  NoEstimates movement: because estimates are difficult to make in software, supposedly unlike trad engineering, we should do away with them entirely.</p><p> 我认为这是一种防御机制。如果软件与传统有很大不同，那么我们可以“不做工程师”。我们可以肯定地说，我们并没有计划，但这是因为软件需求的变化比其他任何地方都快得多。我们不应用工程技术，因为我们不应该应用工程技术。一个很好的例子是NoEstimates运动：由于估计难以在软件中进行，这与传统的工程学不同，因此我们应该完全取消它们。 </p><p> There’s just one problem with this: as software engineers, we deeply misunderstand the nature of trad engineering. We are not special. Almost everything we think is unique about software appears in every other field of engineering. The upside of this is that—well, we are not special. Almost everything we think is awful about software is something everyone else struggles with, too.</p><p>这只有一个问题：作为软件工程师，我们深刻误解了传统工程的本质。我们并不特别。我们认为与软件有关的几乎所有事物都出现在工程的其他各个领域。这样做的好处是，我们并不特殊。我们认为几乎所有关于软件的事情都是其他人都在苦苦挣扎的事情。</p><p>  There’s a fallacy in comparing “trad”, which is an umbrella of different engineering disciplines, to software. Most arguments about engineering don’t go much beyond “software vs engineering”, or conflate “engineering” with civil engineering. All of the subfields are different, and the qualities of one don’t reflect on the qualities of others. After a few interviews, I settled on a set of “universal” differences to discuss:</p><p>  将“传统”（涵盖不同的工程学科）与软件进行比较存在一个谬论。有关工程的大多数论点并没有超出“软件与工程”范围，也没有将“工程”与土木工程混为一谈。所有子字段都是不同的，一个子字段的质量不能反映其他子字段的质量。经过几次采访后，我解决了一系列“普遍性”差异，以讨论：</p><p> Traditional engineering is best done in a Waterfall style, while software is best done in an Agile one.</p><p> 传统工程最好以瀑布样式完成，而软件最好以敏捷样式完成。</p><p>  Engineering is mostly about manufacture, while code is mostly about design, because “the code is the design”.</p><p>  工程主要与制造有关，而代码主要与设计有关，因为“代码就是设计”。</p><p> These aren’t all wrong. As we’ll see later, there are absolutely some differences between software and trad. But the majority of the differences are “wrong”, or at least lacking critical nuance.</p><p> 这些并非全都错了。稍后我们将看到，软件和交易之间绝对存在一些差异。但是大多数差异是“错误的”，或者至少缺乏关键的细微差别。</p><p>  If there’s one thing we think is uniquely software, it’s Agile.</p><p>  如果我们认为只有一件事是软件，那就是敏捷。</p><p> As it’s told, Agile was a rejection of “Waterfall”, the old paradigm Winston Royce invented in 1970. Royce came up with the Waterfall model to mimic how “real” engineers built buildings. Waterfall says that you should do everything in a strict order, only progressing to the next stage of development when the current stage is completed. You only develop after you complete design, only test after you finish development, etc. This works for “real” engineering but utterly fails for software, where requirements change and often the customer doesn’t know what they want before you build it. So this is rejected by the  Agile Manifesto in 2001, and everybody lived happily ever after.</p><p> 众所周知，敏捷是对“瀑布”（Waterfall）的拒绝，它是1970年温斯顿·罗伊斯（Winston Royce）的老范例。罗伊斯想出了瀑布模型来模仿“真正的”工程师如何建造建筑物。 Waterfall表示您应该严格执行所有操作，只有在当前阶段完成后才进入下一个开发阶段。您只能在完成设计后进行开发，仅在完成开发后进行测试，等等。这适用于“实际”工程，但对于软件来说完全是失败的，因为需求会发生变化，并且客户在构建之前通常都不知道他们想要什么。因此，这在2001年的《敏捷宣言》中遭到拒绝，从此以后每个人都过着幸福的生活。 </p><p> Of course, this story is more fiction than fact. While Waterfall was a dominant model for some time, it was never quite as strict as we think it was today. Nor was it all that ubiquitous: most developers in the 70s and 80s were either working with an ad hoc plan or working in one of the many, many, many “incremental” models that were in fashion, like the  Spiral Model and the  V Model. Agile wasn’t a radical shift as much as a natural consequence of the trends at the time.</p><p>当然，这个故事比事实更虚构。虽然Waterfall在一段时间以来一直是主导模型，但它从来没有像我们今天想象的那么严格。也不是无所不在：70年代和80年代的大多数开发人员要么是临时计划，要么是使用许多时尚的“增量”模型之一，例如Spiral Model和V Model 。敏捷并不是根本性的转变，而不仅仅是当时趋势的自然结果。</p><p> But all that is tangential to the core claim: software engineering is Agile, while trad engineering is Waterfall. And this, unsurprisingly, is a significant oversimplification.</p><p> 但是，所有与核心主张相切的东西是：软件工程是敏捷，而传统工程是瀑布。毫不奇怪，这是一个过分的简化。</p><p> It’s true that traditional engineers do a lot more upfront design and spend more time in dedicated testing than software engineers do. But this doesn’t mean they have Waterfall level rigidity, nor does it mean that our Agile is alien to them. Rather, spending a lot of time in phases is a natural consequence of the economic model. When iterations are longer and more expensive it makes more sense to spend more time planning them out. But people use “design” and “implement” in very different ways. When a civil engineer does a scale model, is that design or implementation? When an automotive engineer makes a  full clay replica of a car to test its aesthetics and aerodynamics, is that design or implementation?</p><p> 的确，与软件工程师相比，传统工程师要进行更多的前期设计，并在专用测试上花费更多的时间。但这并不意味着它们具有瀑布级的刚性，也不意味着我们的敏捷与他们格格不入。相反，分阶段花费大量时间是经济模型的自然结果。当迭代时间更长且成本更高时，花更多的时间进行规划就更有意义。但是人们以不同的方式使用“设计”和“实现”。土木工程师进行比例建模时，是设计还是实施？当汽车工程师为汽车制作完整的粘土复制品以测试其美观性和空气动力学性能时，该设计或实现是吗？</p><p> When it comes to things like making circuit boards, it’s pretty common for things not to work the first time. You have to do it again, and you have to send it out to the factory and do it again. You know it costs you another however many £1000 and another two weeks on the schedule.  -Mike (mechanical)</p><p> 当涉及到制作电路板之类的事情时，第一次不工作很普遍。您必须再次执行此操作，并且必须将其发送到工厂并再次执行。您知道它要另外花1000英镑，另外还要花两周时间。 -迈克（机械）</p><p> We see Agile-like innovations in every industry. Many tunnels today are built with  Austrian Tunneling, which relies on iterative development and lots of room for improvisation. The  Handbook of Industrial Engineering emphasises cross-collaboration and rapid client feedback. Even the most Waterfall form of engineering, civil engineering, gradually shifts to a more Agile-like process once construction starts. People need open communication and adaptation to deal with on-the-ground issues in building.</p><p> 我们在每个行业都看到类似敏捷的创新。如今，许多隧道都是通过“奥地利隧道”建造的，这取决于迭代开发和大量的即兴创作空间。 《工业工程手册》强调交叉合作和快速的客户反馈。一旦开始施工，即使是最瀑布形式的工程，即土木工程，也逐渐过渡到更像敏捷的过程。人们需要开放的沟通和适应能力，以解决建筑中的地面问题。</p><p> Why do we think software needs Agile and not Waterfall? Unpredictability. The Waterfall model only makes sense if we can accurately predict and estimate the obstacles inherent in our projects. Because software is unpredictable, the argument goes, we can’t use Waterfall. It could be that halfway through planning, we decide we need to start over. Is it any different for engineers? Is their work any more predictable, more certain than ours?</p><p> 为什么我们认为软件需要敏捷而不是瀑布？不可预测性。仅当我们可以准确地预测和估计项目中固有的障碍时，瀑布模型才有意义。由于软件是不可预测的，因此争论不休，我们无法使用Waterfall。可能是计划的一半，我们决定需要重新开始。对工程师有什么不同吗？他们的工作比我们的工作更可预测，更确定吗？</p><p>   Part of this misconception comes from us seeing the results of the engineering process, not the process itself. We don’t see the friction, the overruns, the delays that happen because someone built the wall one inch to the left, or when a critical supplier goes out of business. To assume that software is uniquely unpredictable is a special kind of arrogance.</p><p>   这种误解的部分原因是我们看到了工程过程的结果，而不是过程本身。我们看不到任何摩擦，超支，由于有人在左侧左一英寸处建造隔离墙或重要供应商停业而导致的延误。假定软件具有独特的不可预测性是一种特殊的傲慢。 </p><p> Another part comes from how fast software seems to change. It feels like every year or two there is a new dominant framework or language that everybody’s trying to switch to. We expect that traditional engineering doesn’t have the same constant churn of tooling and paradigm. To an extent, it doesn’t. But less churn is not the same as no churn, and there are many other ways that things can become unpredictable. One chip designer, Steve, found this especially funny:</p><p>另一部分来自软件变化的速度。好像每两年或每两年都有一个新的主导性框架或语言可供大家尝试使用。我们希望传统的工程技术不会持续不断地在工具和范例方面流失。在一定程度上，它不是。但是，减少客户流失与避免客户流失并不相同，并且还有许多其他方式可以使事情变得不可预测。一位芯片设计师史蒂夫（Steve）发现这一点特别有趣：</p><p> In the environment of software world, people are thinking ‘what’s the new JavaScript bundler of the month.’ In the hardware world, it’s ‘what can the silicon fab people do for us this month.’ If the foundry has new machinery to create chips, your plans change. Not as fast as libraries do, but still pretty fast.  -Steve (electrical)</p><p> 在软件世界中，人们正在思考“本月新的JavaScript捆绑器是什么？”在硬件世界中，“本月硅晶圆厂的人能为我们做些什么。”如果铸造厂拥有制造芯片的新设备。 ，您的计划就会改变。速度不如库快，但仍然非常快。 -史蒂夫（电）</p><p> There are too many anecdotes to go into them all. Territory claims changing in the middle of construction, hardened procedures suddenly and permanently failing, new discoveries well into development. One person talked about how frustrating it is to start work on a bridge foundation, only to find that  this particular soil freezes in a weird way that makes it liquefy too much in an earthquake. Back to the drawing board.</p><p> 轶事太多了，无法一一列举。领土声称在施工过程中发生了变化，程序突然变硬并永久失效，新发现不断涌入开发中。有人谈论在桥基上开始工作是多么令人沮丧，却发现这种特殊的土壤以一种怪异的方式冻结，使它在地震中液化过多。回到绘图板。</p><p>  [Code is design] was a reaction to the people who think “Oh, if we just build a beautiful model in UML and then autogenerate all the code from UML then everything will be fine.”</p><p>  [代码就是设计]对那些认为“哦，如果我们只是在UML中构建漂亮的模型，然后从UML中自动生成所有代码，那么一切都会很好。”</p><p> That’s from  Nick Coghlan. I was surprised when he reached out for an interview; I knew about him as a core CPython developer. Before that, though, he was a systems integration engineer for Boeing. “The diplomatic style of system architecture”, he called it. Boeing would have multiple independent systems- in his example, an airplane, air traffic control, and an antenna array. He had to work with all three teams to make sure they built compatible interfaces. Integration work, essentially. He saw “software is design” as the fundamental difference between his old job and his current one.</p><p> 来自尼克·科格兰（Nick Coghlan）。他伸手去采访时，我感到很惊讶。我知道他是CPython的核心开发人员。在此之前，他曾是波音公司的系统集成工程师。他称其为“系统体系结构的外交风格”。波音公司将有多个独立的系统-在他的例子中，飞机，空中交通管制和天线阵列。他必须与所有三个团队合作，以确保他们构建了兼容的界面。集成工作，本质上。他认为“软件就是设计”是他以前的工作与现在的工作之间的根本区别。</p><p> Others weren’t so sure. “From my view,” said one, “it was all design”, from the first schematics of the CPU to the final chips rolling out of the foundry. All of their time was spent on design, just like software. Construction was the easy part: just hand the design over to a foundry and get back completed chips.</p><p> 其他人不太确定。一个人说：“从我的角度来看，这全是设计，从最初的CPU示意图到铸造厂推出的最终芯片。就像软件一样，他们所有的时间都花在了设计上。施工是最简单的部分：只需将设计移交给铸造厂，然后取回完成的芯片。</p><p> Of course, the chips will come back flawed, which means a change in design. Design and construction aren’t nearly as disjoint as we software engineers think. Many of the mechanical engineers felt this strongly. The constructed product might show issues in the design, or it might show issues in the circumstances of construction. Mike, one mechanical engineer, called it “fettling”. Tweaking the design to deal with the slight imperfections of the construction process. Every construction changes the design, which changes the construction.</p><p> 当然，这些芯片将返回有缺陷的缺陷，这意味着设计将发生变化。设计和构造并没有我们软件工程师所认为的那么分散。许多机械工程师对此深有感触。构造的产品可能在设计中显示问题，或者在构造情况下可能显示问题。机械工程师迈克（Mike）称其为“点胶”。调整设计以应对施工过程中的轻微缺陷。每种构造都会更改设计，从而改变构造。 </p><p> Beyond that, there’s another problem: “design” is not well specified. Are we talking about the architectural overview? The formal specification? The detailed blueprints? If the code is the design then what’s the formal specification of our code? For complex projects there are a lot of different kinds of design at a lot of different levels of detail. If you look at  bridge plans, you see there are many layers of fractal detail.</p><p>除此之外，还有另一个问题：“设计”的定义不明确。我们在谈论架构概述吗？正式规格？详细的设计图？如果代码是设计，那么我们代码的正式规范是什么？对于复杂的项目，存在许多不同种类的设计，并且具有不同的详细程度。如果查看桥梁平面图，您会发现分形细节层很多。</p><p> I think this is another case where what we mean by design and construction really vary between different kinds of engineering. Yes, in civil engineering the construction phase takes the most time and money, but that’s civil engineering. And only certain kinds of civil engineering, too, the “bridges and buildings” work. The same kind of work on which we base our stereotypes.</p><p> 我认为这是另一种情况，在不同类型的工程之间，我们的设计和构造含义实际上有所不同。是的，在土木工程中，建设阶段花费大量时间和金钱，但这就是土木工程。而且，只有某些类型的土木工程也可以使用“桥梁和建筑物”。我们基于刻板印象的同类工作。</p><p> I find myself having to explain that there are many aspects of civil engineering that you wouldn’t specifically consider. […] I tell people it refers to anything that you need to build the city.  -Jen (civil)</p><p> 我发现自己必须解释一下，土木工程的许多方面您不会特别考虑。 […]我告诉别人，它指的是建造这座城市所需的一切。 -仁（民事）</p><p>  There’s like a 1,000,000 million times more checks and balances in software than in traditional engineering. […] Whenever someone’s tweeting about, like Excel horror stories *laughter* I have amazing Excel horror stories […] there’s days that I am shocked skyscrapers don’t fall over daily and planes don’t crash.  -Mat</p><p>  与传统工程技术相比，软件中的制衡能力要高出1万亿倍。 […]每当有人发推文时，例如Excel恐怖故事*（笑声）*我都会惊叹于Excel恐怖故事[…]有时候，我感到震惊的是，摩天大楼没有倒塌，飞机也没有坠毁。 -垫</p><p> People say that trad engineering is a lot more rigorous than software. Trad engineers reason carefully from first principles rather than copy-paste. This is usually presented as a problem with software that we need to change to become “real” engineering. It’s also wrong.</p><p> 人们说，交易工程比软件更为严格。传统工程师从第一原则出发要谨慎地推理，而不是复制粘贴。这通常表示为软件问题，我们需要对其进行更改才能成为“实际”工程。这也是错误的。</p><p> First of all, any less rigor we have isn’t entirely cultural, because the essential nature of software makes it a viable tradeoff. Nick explained it as a difference in “validating assumptions”: “you reach a point with the easiest way to check if your assumption is right is to just go in and do it.” Software lets us gather empirical information more easily, which itself is a source of rigour.</p><p> 首先，我们所拥有的不那么严格并不完全是文化上的，因为软件的本质使它成为可行的折衷方案。尼克将其解释为“验证假设”的不同之处：“您可以通过最简单的方法来检查您的假设是否正确，即进入并执行此操作。”软件使我们可以更轻松地收集经验信息，这本身就是一种严格的要求。</p><p> But statements about rigor are predicated on the end results of software being different, that trad products are more coherent and less slapdash. That’s not true. For example, we keep much better records and use more comprehensive verification. I heard plenty of horror stories of critical information stored in Excel sheets and old filing cabinets, growing obsolete and corrupt. Plenty would kill to get the same kind of automated testing we treat as a given.</p><p> 但是有关严谨性的陈述是基于软件的最终结果有所不同而得出的，即，交易产品更加连贯，更少打扰。这不是真的。例如，我们保留更好的记录并使用更全面的验证。我听到了很多可怕的故事，这些故事中的关键信息存储在Excel工作表和旧的文件柜中，变得过时和腐败。要获得与我们给定的相同的自动化测试，大量的测试将会失败。 </p><p>     Software is entirely synthesized. It’s bounded entirely by logic. It doesn’t wear out like a spring, right? It just does what it’s supposed to do. The only thing that can actually go wrong is the specifications. The software was bad.  -Nathan</p><p>软件是完全合成的。它完全受逻辑限制。它不会像春天一样磨损，对吗？它确实可以完成预期的工作。唯一可能真正出错的是规格。该软件很差。 -内森</p><p> Software is far more consistent than any other kind of engineering. We usually think of software as a giant mess, a haze of interdependencies and incompatible hardware, but we actually have it pretty nice. If I give you a sorting function, you can expect it to sort. You do not expect it to sort a given list of (nonpathological) numbers only 95% of the time. That would be ridiculous.</p><p> 软件比任何其他类型的工程都更加一致。我们通常认为软件是一团糟，相互依存且硬件不兼容，但实际上我们感觉还不错。如果我给您排序功能，您可以期待它进行排序。您不希望它仅在95％的时间内对给定的（非病理性）数字列表进行排序。那太荒谬了。</p><p> By contrast, let’s look at physical materials. In electrical engineering, a core component is the resistor: a wire that reduces the flow of current. Resistors are measured in ohms, and commodity off-the-shelf resistors can range from a single ohm to hundreds of millions of ohms. Many commodity resistors follow a color chart to make identifying the resistance easy:</p><p> 相比之下，让我们看一下物理材料。在电气工程中，核心组件是电阻器：减少电流流动的导线。电阻的测量单位为欧姆，现成的商用电阻的范围可以从一个欧姆到数亿欧姆。许多商品电阻器遵循颜色图表，以轻松识别电阻：</p><p>  So a band with green, blue, red will have 5600 ohms. Note the last band, though: that specifies the tolerance. The color code only describes the theoretical resistance: if the tolerance band is gold, that means the resistor can vary by up to 5%. If you have a batch of 100 of these resistors, some will be 5320 ohms, some will be 5880 ohms, and the only way to know which is which is to test each one individually. And this is to say nothing about wear and tear, or how resistance varies with temperature, etc.</p><p>  因此，绿色，蓝色，红色的频段将具有5600欧姆。但是，请注意最后一个频段：指定公差。颜色代码仅描述了理论电阻：如果公差带为金色，则意味着电阻可以相差5％。如果您有一批此类电阻，其中有100个，一些电阻为5320欧姆，一些电阻为5880欧姆，唯一的知道哪种方法就是分别测试每个电阻。而且，这与磨损或电阻随温度的变化等无关。</p><p> This is the case of all physical materials. One of my favorite discoveries on the internet, well before I started this project, was the  Fastenal labs page. Fastenal makes screws.  One of their pages warns against using stainless steel screws on an aluminum plate.</p><p> 所有物理材料都是如此。在我开始这个项目之前，我最喜欢的互联网发现之一就是Fastenal实验室页面。紧固件制造螺丝。他们的其中一页警告不要在铝板上使用不锈钢螺钉。</p><p>   The code is the spec for how the hardware should be running. In traditional engineering, we would have to do all that same work to share the spec, but then we have to wait and, like, let the fab or the machine shop finish building the damn thing. And then we’d have to sit there and install it either ourselves or hire somebody. And then we’d have to run testing on it for several weeks to see if it worked or not.  -Matt (chemical)</p><p>   该代码是有关硬件应如何运行的规范。在传统工程中，我们必须做所有相同的工作来共享规格，但是随后我们必须等待，例如让晶圆厂或机械车间完成该死的事情。然后我们必须坐在那里自己安装或雇用某个人。然后，我们必须对其进行几周的测试，以查看其是否有效。 -马特（化学）</p><p> This is irrefutable. We can change software much faster than anybody else can change their systems. Several engineers told me that changes had a quantifiable price tag: every time you needed to adjust something, you knew you were taking $5000 from of the budget. Whereas I can change some code and run all the tests in seconds.</p><p> 这是无可辩驳的。我们可以比任何人都可以更快地更改软件。几位工程师告诉我，变更的价格是可量化的：每次您需要进行调整时，您都知道自己从预算中拿走了5000美元。而我可以更改一些代码并在几秒钟内运行所有测试。 </p><p> The closest I found to this in any other field was chemical engineering. “I’d go in the morning and look at what went wrong last night,” said Raja, a former chemical engineer. Something like a one minute turnover would be unheard of, and that’s already in the fastest field of non-software engineering.</p><p>在其他任何领域，我发现最接近的是化学工程。 “我早上去看看昨晚出了什么问题，”前化学工程师拉贾（Raja）说。一分钟的周转率是闻所未闻的，这已经是最快的非软件工程领域。</p><p> This is the nature of our material. And it’s also why other engineering fields are progressively using more software by creating these design tools and simulations, engineers can prototype their ideas with software before implementing them.</p><p> 这就是我们材料的本质。这也是为什么其他工程领域通过创建这些设计工具和仿真来逐步使用更多软件的原因，工程师可以在实现它们之前用软件对他们的想法进行原型制作。</p><p> There is also a darker side to this. Because software can iterate faster than trad, trad often relies on software to compensate for problems in physical equipment.</p><p> 这也有一个黑暗的一面。由于软件的迭代速度比trad更快，因此trad通常依靠软件来补偿物理设备中的问题。</p><p> The software engineer is being squeezed by the rest of the team. They’re usually asked to save everyone’s bacon. If something is not quite working in the electronics or mechanics, often you can work around it with a software kludge.  -Mike</p><p> 其余的团队都在挤压软件工程师。通常要求他们保存所有人的培根。如果在电子学或机械学方面工作不正常，通常可以使用软件库解决它。 -麦克风</p><p> And sometimes this reliance has catastrophic consequences. In 2019 over 300 people died in two 737 MAX airplane crashes. Investigation pinned this to a bug in the “Maneuvering Characteristics Augmentation System” (MCAS), one of the automated flight control systems. But Boeing only added MCAS in the first place to compensate for late-discovered issues with the plane’s  aerodynamic profile. Rather than fix a trad issue with trad engineering, Boeing opted for the software kludge, and then people died.</p><p> 有时这种依赖会带来灾难性的后果。 2019年，两起737 MAX飞机失事导致300多人死亡。调查将其归因于“飞行特性增强系统”（MCAS）中的一个错误，该系统是自动飞行控制系统之一。但是，波音公司仅是首先添加了MCAS，以弥补飞机的空气动力学特性在后来发现的问题。波音公司没有解决传统技术的传统问题，而是选择了软件组合，然后人们丧命。</p><p>  They have a [chip] time budget, you have a time budget, you say ‘I can’t quite make it. Do you have a little slop there? Can I get a fraction of a nanosecond?’  -Steve</p><p>  他们有一个[筹码]时间预算，你有一个时间预算，你说'我做不到。你那里有一点儿水吗？我能得到几分之一秒的时间吗？’-史蒂夫（Steve）</p><p> One implicit undercurrent in all the interviews was the notion of constraint. There are hard physical limits that their products needed to obey. It has to be light enough, or strong enough, or resistant enough, or run cool enough. There is a known quantity they have to maximize or minimize.</p><p> 在所有采访中，一个隐性的暗流是约束的概念。他们的产品需要遵守严格的物理限制。它必须足够轻，足够坚固，足够耐力或足够凉爽。他们必须最大化或最小化已知数量。 </p><p> Constraints are present in software, too. Code must fit in the memory of an embedded hardware device, the sensor needs a response in exactly 10 cycles, the API must stay under the rate limit. But constraints in software tend to be soft constraints. It is bad to go over them and the more we go over the worse it gets. We can slightly fudge the line if doing so will give us other benefits, like faster development time or simpler algorithms. In traditional engineering, most constraints are hard constraints. If the area of your box is a bit too wide then it won’t fit in the door.</p><p>约束也存在于软件中。代码必须适合嵌入式硬件设备的内存，传感器需要准确地在10个周期内做出响应，API必须保持在速率限制之下。但是软件中的约束往往是软约束。越过它们是不好的，我们越越越过越糟。如果这样做会给我们带来其他好处，我们可以稍加改动，例如更快的开发时间或更简单的算法。在传统工程中，大多数约束是硬约束。如果您的盒子区域太宽，那么它将不适合放入门中。</p><p> Sometimes this leads to unusual solutions. One time Carl’s team had to install a  screw conveyor in an oil rig, then discovered it was just a couple inches too tall for the room. They couldn’t shrink the equipment, and they couldn’t raise the ceiling, since there were another four floors above it. The team’s solution? Cut a hole in the ceiling, put the equipment in, then put a box around the hole on the next floor so that nobody trips over it. Now that change is permanently part of the rig’s structure, something that has to be accommodated in every future change forever. And that leads to another difference: software engineers can undo their kludges. Trad engineers cannot.</p><p> 有时这会导致异常的解决方案。一次，卡尔的团队不得不在抽油装置中安装螺旋输送机，然后发现它对于房间来说只有几英寸高。他们无法收缩设备，也无法升高天花板，因为天花板上方还有另外四层。团队的解决方案？在天花板上切一个洞，将设备放进去，然后在下一层的洞周围放一个盒子，以便没人绊倒。现在，更改已永久成为钻机结构的一部分，以后的每一次更改都必须永久保留这些内容。这就带来了另一个差异：软件工程师可以消除他们的烦恼。传统工程师不能。</p><p>  While there are many ways we are different, there’s a difference between being “different” and being “special”. Yes, mechanical and chemical engineers don’t have to deal with the same security concerns we do. They also don’t have to deal with weather patterns to the same degree that civil engineers need to, and none of those three need to deal with the problems inherent in chemical engineering. Every field of engineering has unique challenges and software is no different.</p><p>  尽管我们有很多不同的方式，但“与众不同”与“特殊”之间会有区别。是的，机械工程师和化学工程师不必像我们一样处理安全问题。他们也不必以土木工程师所需要的程度来处理天气模式，这三者中的任何一个都不需要处理化学工程中固有的问题。每个工程领域都有独特的挑战，软件也不例外。</p><p> But they are all much more similar than they are different. Every field values upfront, abstract thinking, tidy work, and a good kludge in just the right place. Every field faces shifting requirements and unknown unknowns. Every field is siloed from the others: we know as little about the work of mechanical engineers as chemical engineers do. Many times in my interviews, people asked what the other fields of engineering were like. Nobody ever gets a chance to leave their bubble.</p><p> 但是它们之间的相似性远大于差异。每个领域都重视前瞻性，抽象的思维，整洁的工作以及在正确的位置进行的良好尝试。每个领域都面临着变化的要求和未知的未知数。每个领域都与其他领域隔离开来：与化学工程师一样，我们对机械工程师的工作知之甚少。在我的访谈中，很多次人们问工程的其他领域是什么样的。没有人有机会离开他们的泡沫。</p><p> And it’s a good thing that software isn’t special. It means that we can learn a lot on how to make software better from these other fields. And it means that they have a lot to learn from us. Because surprisingly, there are some ways that we are better at engineering than traditional engineers. Next time, we’ll cover what we can learn and what we can teach.</p><p> 没什么特别的软件是一件好事。这意味着我们可以从其他领域中学到很多有关如何使软件更好的知识。这意味着他们需要向我们学习很多东西。因为令人惊讶的是，在某些方面我们比传统工程师更擅长工程。下次，我们将介绍我们可以学习和可以教到的东西。</p><p> Part three, What Engineering Can Teach (and Learn from) Us,  will be posted on Frida</p><p> 第三部分，《工程学可以教给我们（和向我们学习）》，将发布在Frida上</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.hillelwayne.com/post/crossover-project/we-are-not-special/">https://www.hillelwayne.com/post/crossover-project/we-are-not-special/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/special/">#special</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>