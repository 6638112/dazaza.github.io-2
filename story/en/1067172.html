<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>高性能，柱状，内存存储，进入位图索引 High-performance, columnar, in-memory store with bitmap indexing in Go</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">High-performance, columnar, in-memory store with bitmap indexing in Go<br/>高性能，柱状，内存存储，进入位图索引 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-21 18:05:24</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/c106ce82fbc7c7d28936993aba2132a8.png"><img src="http://img2.diglog.com/img/2021/6/c106ce82fbc7c7d28936993aba2132a8.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This package contains a  high-performance, columnar, in-memory storage engine that supports fast querying, update and iteration with zero-allocations and bitmap indexing.</p><p>此包包含高性能，柱状内存存储引擎，支持快速查询，更新和迭代，具有零分配和位图索引。</p><p>    The general idea is to leverage cache-friendly ways of organizing data in  structures of arrays (SoA) otherwise known &#34;columnar&#34; storage in database design. This, in turn allows us to iterate and filter over columns very efficiently. On top of that, this package also adds  bitmap indexing to the columnar storage, allowing to build filter queries using binary  and,  and not,  or and  xor (see  kelindar/bitmap with SIMD support).</p><p>    一般思想是利用在阵列（SOA）结构中组织数据的缓存友好方式，否则以其他方式知道＆＃34;柱状＆＃34;存储在数据库设计中。这又允许我们非常有效地迭代和过滤列。最重要的是，此包还将位图索引添加到柱状存储，允许使用二进制文件和，而不是或XOR构建过滤器查询（请参阅与SIMD支持的Kelindar / Bitmap）。</p><p>   In order to get data into the store, you&#39;ll need to first create a  Collection by calling  NewCollection() method. Each collection requires a schema, which can be either specified manually by calling  CreateColumn() multiple times or automatically inferred from an object by calling  CreateColumnsOf() function.</p><p>   为了将数据放入商店，您＆＃39; ll需要首先通过调用newcollection（）方法创建一个集合。每个集合都需要模式，可以通过调用CreateColumn（）多次或通过调用CreateColumnSof（）函数从对象自动推断出来手动指定。</p><p> In the example below we&#39;re loading some  JSON data by using  json.Unmarshal() and auto-creating colums based on the first element on the loaded slice. After this is done, we can then load our data by inserting the objects one by one into the collection. This is accomplished by calling  Insert() method on the collection itself repeatedly.</p><p> 在下面的示例中，我们＆＃39;通过使用JSON.UNMARSHAL（）和基于加载切片上的第一个元素的自动创建COLUM来加载一些JSON数据。完成此后，我们可以通过将对象逐一插入集合来加载我们的数据。这是通过重复调用集合本身的INSERT（）方法来实现的。</p><p> data  :=  loadFromJson( &#34;players.json&#34;) // Create a new columnar collection players  :=  column. NewCollection() players. CreateColumnsOf( data[ 0]) // Insert every item from our loaded data for  _,  v  :=  range  data {	 players. Insert( v)}</p><p> 数据：= loadfromjson（＆＃34; players.json＆＃34;）//创建一个新的柱状集合播放器：=列。 newcollection（）玩家。 CreateColumnSof（数据[0]）//从我们加载的数据中插入每个项目for _，v：=范围数据{播放器。插入（v）}</p><p> Now, let&#39;s say we only want specific columns to be added. We can do this by calling  CreateColumn() method on the collection manually to create the required columns.</p><p> 现在，让＆＃39; s说我们只想要添加特定列。我们可以通过手动调用CreateColumn（）方法来完成此操作以创建所需列。</p><p> // Create a new columnar collection with pre-defined columns players  :=  column. NewCollection() players. CreateColumn( &#34;name&#34;,  column. ForString()) players. CreateColumn( &#34;class&#34;,  column. ForString()) players. CreateColumn( &#34;balance&#34;,  column. ForFloat64()) players. CreateColumn( &#34;age&#34;,  column. ForInt16()) // Insert every item from our loaded data for  _,  v  :=  range  loadFromJson( &#34;players.json&#34;) {	 players. Insert( v)}</p><p> //使用预定义的列播放器创建一个新的colument集合：=列。 newcollection（）玩家。 CreateColumn（＆＃34;姓名＆＃34;，列。forstring（））玩家。 CreateColumn（＆＃34;类＆＃34;，列。forstring（））玩家。 CreateColumn（＆＃34;余额＆＃34;，列。forfloat64（））玩家。 CreateColumn（＆＃34;年龄＆＃34;，列。forint16（））//从我们加载的数据中插入来自我们加载的数据的_，v：=范围loadfromjson（＆＃34;播放器。just＃34;）{玩家。插入（v）} </p><p> While the previous example demonstrated how to insert many objects, it was doing it one by one and is rather inefficient. This is due to the fact that each  Insert() call directly on the collection initiates a separate transacion and there&#39;s a small performance cost associated with it. If you want to do a bulk insert and insert many values, faster, that can be done by calling  Insert() on a transaction, as demonstrated in the example below. Note that the only difference is instantiating a transaction by calling the  Query() method and calling the  txn.Insert() method on the transaction instead the one on the collection.</p><p>虽然前面的示例演示了如何插入许多对象，但它是一个接一个地执行它并且相当效率。这是由于每个插入（）直接在集合上呼叫，发起一个单独的越野，并且在那里且＆＃39;＆＃39; s的小型性能成本。如果要执行批量插入并插入许多值，可以通过在事务上调用Insert（）来完成，如下面的示例中所示。请注意，唯一的区别是通过调用Query（）方法并在事务上调用Txn.insert（）方法而代替集合上的差异。</p><p> players. Query( func( txn  * Txn)  error {	 for  _,  v  :=  range  loadFromJson( &#34;players.json&#34;) {		 txn. Insert( v)	}	 return  nil  // Commit})</p><p> 玩家。查询（func（txn * txn）错误{for _，v：= loadfromjson（＆＃34; players.json＆＃34;）{txn。插入（v）} return nil // commit}）</p><p>  The store allows you to query the data based on a presence of certain attributes or their values. In the example below we are querying our collection and applying a  filtering operation bu using  WithValue() method on the transaction. This method scans the values and checks whether a certain predicate evaluates to  true. In this case, we&#39;re scanning through all of the players and looking up their  class, if their class is equal to &#34;rogue&#34;, we&#39;ll take it. At the end, we&#39;re calling  Count() method that simply counts the result set.</p><p>  该商店允许您根据某些属性的存在或其值查询数据。在下面的示例中，我们正在查询我们的集合并在事务上使用withValue（）方法应用过滤操作。此方法扫描值并检查某个谓词是否评估为true。在这种情况下，我们＆＃39;如果他们的班级等于＆＃34; rogue＆＃34;我们跳过他们的课程，扫描他们的课程，抬头看他们的课程。在最后，我们＆＃39;重新调用count（）方法，只计算结果集。</p><p> // This query performs a full scan of &#34;class&#34; column players. Query( func( txn  *column. Txn)  error {	 count  :=  txn. WithValue( &#34;class&#34;,  func( v  interface{})  bool {		 return  v  ==  &#34;rogue&#34;	}). Count()	 return  nil})</p><p> //此查询执行＆＃34;类＆＃34;列球员。查询（Func（TXN *列）错误{COUNT：= TXN。有value（＆＃34;类＆＃34; func（v接口{}）bool {return v ==＆＃34; rogue＆＃34;} ）。count（）返回nil}）</p><p> Now, what if we&#39;ll need to do this query very often? It is possible to simply  create an index with the same predicate and have this computation being applied every time (a) an object is inserted into the collection and (b) an value of the dependent column is updated. Let&#39;s look at the example below, we&#39;re fist creating a  rogue index which depends on &#34;class&#34; column. This index applies the same predicate which only returns  true if a class is &#34;rogue&#34;. We then can query this by simply calling  With() method and providing the index name.</p><p> 现在，如果我们＆＃39; ll需要经常做这个查询吗？可以简单地创建具有相同谓词的索引，并且每次（a）将对象插入到集合中并且（b）更新依赖列的值。看看下面的例子，我们＆＃39;重新创建一个依赖于＆＃34的流氓指数的拳头;柱子。此索引适用于相同的谓词，如果类是＆＃34;流氓＆＃34; rogue＆＃34;然后，我们可以通过简单地调用（）方法并提供索引名称来查询这一点。</p><p> An index is essentially akin to a boolean column, so you could technically also select it&#39;s value when querying it. Now, in this example the query would be around  10-100x faster to execute as behind the scenes it uses  bitmap indexing for the &#34;rogue&#34; index and performs a simple logical  AND operation on two bitmaps when querying. This avoid the entire scanning and applying of a predicate during the  Query.</p><p> 索引基本上类似于布尔列，因此您可以在技术上也可以选择它＆＃39; QUENCEITY。现在，在这个例子中，查询将在10-100倍的速度左右才能更快地执行，因为它使用Bitmap索引为＆＃34; Rogue＆＃34;索引并在查询时对两个位图执行简单的逻辑和操作。这避免了在查询期间的整个扫描和应用谓词。</p><p> // Create the index &#34;rogue&#34; in advance out. CreateIndex( &#34;rogue&#34;,  &#34;class&#34;,  func( v  interface{})  bool {	 return  v  ==  &#34;rogue&#34;}) // This returns the same result as the query before, but much faster players. Query( func( txn  *column. Txn)  error {	 count  :=  txn. With( &#34;rogue&#34;). Count()	 return  nil})</p><p> //创建索引＆＃34; rogue＆＃34;提前。 createIndex（＆＃34; rogue＆＃34;＆＃34;类＆＃34; func（v接口{}）bool {return v ==＆＃34; rogue＆＃34;}）//返回相同的结果以前的查询，但玩家更快。查询（Func（TXN *列）错误{count：= txn。与（＆＃34;流氓＆＃34;）。count（）返回nil}） </p><p> The query can be further expanded as it allows indexed  intersection,  difference and  union operations. This allows you to ask more complex questions of a collection. In the examples below let&#39;s assume we have a bunch of indexes on the  class column and we want to ask different questions.</p><p>查询可以进一步扩展，因为它允许索引交叉口，差异和联合操作。这允许您提出更复杂的集合问题。在下面的示例中，假设我们在类列中拥有一堆索引，我们希望提出不同的问题。</p><p> First, let&#39;s try to merge two queries by applying a  Union() operation with the method named the same. Here, we first select only rogues but then merge them together with mages, resulting in selection containing both rogues and mages.</p><p> 首先，让Let＆＃39; s尝试通过应用同一命名的方法来合并两个查询。在这里，我们首先选择只选择盗贼，然后将它们与法师合并，导致包含盗贼和法师的选择。</p><p>  Next, let&#39;s count everyone who isn&#39;t a rogue, for that we can use a  Without() method which performs a difference (i.e. binary  AND NOT operation) on the collection. This will result in a count of all players in the collection except the rogues.</p><p>  接下来，让＆＃39;统计每个人都没有一个流氓，因为我们可以使用一个没有（）方法，该方法在集合上执行差异（即二进制而不是操作）。除了盗贼之外，这将导致集合中所有玩家的计数。</p><p>  Now, you can combine all of the methods and keep building more complex queries. When querying indexed and non-indexed fields together it is important to know that as every scan will apply to only the selection, speeding up the query. So if you have a filter on a specific index that selects 50% of players and then you perform a scan on that (e.g.  WithValue()), it will only scan 50% of users and hence will be 2x faster.</p><p>  现在，您可以组合所有方法并保持更复杂的查询。当查询索引和非索引字段时，重要的是要知道，因为每次扫描都将仅适用于选择，加快查询。因此，如果您在特定索引上有过滤器，可选择50％的播放器，然后您对此进行扫描（例如，value（）），它只扫描50％的用户，因此将更快地扫描50％。</p><p> // How many rogues that are over 30 years old? players. Query( func( txn  * Txn)  error {	 txn. With( &#34;rogue&#34;). WithFloat( &#34;age&#34;,  func( v  float64)  bool {		 return  v  &gt;=  30	}). Count()	 return  nil})</p><p> //超过30岁的盗贼？玩家。查询（Func（txn * txn）错误{txn。与（＆＃34;流氓＆＃34;）。用float（＆＃34;年龄＆＃34; func（v float64）bool {return v＆gt; = 30}） 。count（）返回nil}）</p><p>  In all of the previous examples, we&#39;ve only been doing  Count() operation which counts the number of elements in the result set. In this section we&#39;ll look how we can iterate over the result set. In short, there&#39;s 2 main methods that allow us to do it:</p><p>  在以前的所有示例中，我们只做了计算结果集中元素数的计数（）操作。在本节中，我们＆＃39; ll看看我们如何迭代结果集。简而言之，有2个主要方法，让我们这样做：</p><p> Range() method which takes in a column name as an argument and allows faster get/set of the values for that column.</p><p> range（）方法以列名为参数，允许更快的get / set为该列的值。 </p><p> Select() method which doesn&#39;t pre-select any specific column, so it&#39;s usually a bit slower and it also does not allow any updates.</p><p>SELECT（）方法并未预选择任何特定列，因此它通常有点慢，它也不允许任何更新。</p><p> Let&#39;s first examine the  Range() method. In the example below we select all of the rogues from our collection and print out their name by using the  Range() method and providing &#34;name&#34; column to it. The callback containing the  Cursor allows us to quickly get the value of the column by calling  String() method to retrieve a string value. It also contains methods such as  Int(),  Uint(),  Float() or more generic  Value() to pull data of different types.</p><p> 首先检查＆＃39;首先检查范围（）方法。在下面的示例中，我们通过使用Range（）方法和提供＆＃34;姓名＆＃34;选择所有流氓并通过使用范围（）方法来打印出他们的名称。列到它。包含光标的回调允许我们通过调用字符串（）方法来快速获取列的值来检索字符串值。它还包含int（），uint（），float（）或更多通用值（）的方法，以提取不同类型的数据。</p><p> players. Query( func( txn  * Txn)  error {	 txn. With( &#34;rogue&#34;). Range( &#34;name&#34;,  func( v column. Cursor)  bool {		 println( &#34;rogue name &#34;,  v. String())  // Prints the name		 return  true	})	 return  nil})</p><p> 玩家。查询（Func（txn * txn）错误{txn。与（＆＃34;流氓＆＃34;）。范​​围（＆＃34;名称＆＃34; func（v列。游标）bool {println（＆＃34; Rogue name＆＃34;，v。字符串（））//打印名称返回true}）return nil}</p><p> Now, what if you need two columns? The range only allows you to quickly select a single column, but you can still retrieve other columns by their name during the iteration. This can be accomplished by corresponding  StringAt(),  FloatAt(),  IntAt(),  UintAt() or  ValueAt() methods as shown below.</p><p> 现在，如果你需要两列怎么办？该范围仅允许您快速选择单个列，但您仍然可以在迭代期间通过其名称检索其他列。这可以通过相应的StringAt（），floatat（），Intat（），UIntat（）或ValueAt（）方法来完成，如下所示。</p><p> players. Query( func( txn  * Txn)  error {	 txn. With( &#34;rogue&#34;). Range( &#34;name&#34;,  func( v column. Cursor)  bool {		 println( &#34;rogue name &#34;,  v. String())  // Prints the name		 println( &#34;rogue age &#34;,  v. IntAt( &#34;age&#34;))  // Prints the age		 return  true	})	 return  nil})</p><p> 玩家。查询（Func（txn * txn）错误{txn。与（＆＃34;流氓＆＃34;）。范​​围（＆＃34;名称＆＃34; func（v列。游标）bool {println（＆＃34; Rogue名称＆＃34;，v。字符串（））//打印名称println（＆＃34;流氓时代＆＃34; v。Intat（＆＃34;年龄＆＃34;））//打印年龄返回true}）返回nil}）</p><p> On the other hand,  Select() allows you to do a read-only selection which provides a  Selector cursor. This cursor does not allow any updates, deletes or inserts and is also not pre-select any particular column. In the example below we print out names of all of the rogues using a selector.</p><p> 另一方面，SELECT（）允许您执行提供选择光标的只读选择。此光标不允许任何更新，删除或插入，也不允许预选择任何特定列。在下面的示例中，我们使用选择器打印出所有流氓的所有盗贼的名称。</p><p> players. Query( func( txn  * Txn)  error {	 txn. With( &#34;rogue&#34;). Select( func( v column. Selector)  bool {		 println( &#34;rogue name &#34;,  v. StringAt( &#34;name&#34;))  // Prints the name		 return  true	})	 return  nil})</p><p> 玩家。查询（Func（txn * txn）错误{txn。与（＆＃34;流氓＆＃34;）。选择（func（v列选择器）bool {println（＆＃34; rogue name＆＃34; v。 Stringat（＆＃34;名称＆＃34;））//打印名称返回true}）返回nil}） </p><p> Now, what if you need to quickly delete all some of the data in the collection? In this case  DeleteAll() or  DeleteIf() methods come in handy. These methods are very fast (especially  DeleteAll()) and allow you to quickly delete the appropriate results, transactionally. In the example below we delete all of the rogues from the collection by simply selecting them in the transaction and calling the  DeleteAll() method.</p><p>现在，如果您需要快速删除集合中的所有一些数据，该怎么办？在这种情况下，deleteAll（）或deleteIf（）方法派上用方便了。这些方法非常快（尤其是deleteAll（）），并允许您快速删除适当的结果，同意。在下面的示例中，我们只需在事务中选择它们并调用DeleteAll（）方法，从集合中删除所有盗贼。</p><p>   In order to update certain items in the collection, you can simply call  Range() method and the corresponding  Cursor&#39;s  Update() or  UpdateAt() methods that allow to update a value of a certain column atomically. The updates won&#39;t be directly reflected given that the store supports transactions and only when transaction is commited, then the update will be applied to the collection. This allows for isolation and rollbacks.</p><p>   为了更新集合中的某些项目，可以简单地调用范围（）方法和相应的光标＆＃39; s更新（）或updateateate（）方法，允许原子地更新某个列的值。如果商店支持交易，并且只有在已提交事务时，才会将更新直接反映，但才能将更新应用于集合。这允许隔离和回滚。</p><p> In the example below we&#39;re selecting all of the rogues and updating both their balance and age to certain values. The transaction returns  nil, hence it will be automatically committed when  Query() method returns.</p><p> 在下面的例子中，我们＆＃39;重新选择所有流氓并更新它们的平衡和年龄，以某些值。事务返回nil，因此它将在query（）方法返回时自动提交。</p><p> players. Query( func( txn  * Txn)  error {	 txn. With( &#34;rogue&#34;). Range( &#34;balance&#34;,  func( v column. Cursor)  bool {		 v. Update( 10.0)  // Update the &#34;balance&#34; to 10.0		 v. UpdateAt( &#34;age&#34;,  50)  // Update the &#34;age&#34; to 50		 return  true	})  // Select the balance	 return  nil})</p><p> 玩家。查询（Func（txn * txn）错误{txn。与（＆＃34;流氓＆＃34;）。范​​围（＆＃34;余额＆＃34; func（v列。游标）bool {v。更新（10.0） //更新＆＃34;余额＆＃34;到10.0 v。Updateat（＆＃34;年龄＆＃34; 50）//更新＆＃34;年龄＆＃34;到50 return true} //选择余额返回nil}）</p><p> In certain cases, you might want to atomically increment or decrement numerical values. In order to accomplish this you can use the provided  Add() or  AddAt() operations of the  Cursor or  Selector. Note that the indexes will also be updated accordingly and the predicates re-evaluated with the most up-to-date values. In the below example we&#39;re incrementing the balance of all our rogues by  500 atomically.</p><p> 在某些情况下，您可能想要递归或减少数值。为了完成此操作，您可以使用光标或选择器的提供的添加（）或addat（）操作。注意，还将相应地更新索引，并且谓词以最新的值重新评估。在下面的例子中，我们＆＃39;重新将所有盗贼的平衡归因于原子而像。</p><p> players. Query( func( txn  * Txn)  error {	 txn. With( &#34;rogue&#34;). Range( &#34;balance&#34;,  func( v column. Cursor)  bool {		 v. Add( 500.0)  // Increment the &#34;balance&#34; by 500		 return  true	})	 return  nil})</p><p> 玩家。查询（Func（TXN * TXN）错误{TXN。与（＆＃34; rogue＆＃34;）。范​​围（＆＃34;余额＆＃34; func（v列。游标）bool {v。添加（500.0） //递增＆＃34;余额＆＃34; by 500返回true}）返回nil}）</p><p>  Sometimes, it is useful to automatically delete certain rows when you do not need them anymore. In order to do this, the library automatically adds an  expire column to each new collection and starts a cleanup goroutine aynchronously that runs periodically and cleans up the expired objects. In order to set this, you can simply use  InsertWithTTL() method on the collection that allows to insert an object with a time-to-live duration defined.</p><p>  有时，在不再需要它们时自动删除某些行是有用的。为此，库会自动将expire列添加到每个新集合中，并同时启动清除Goroutine，周期性地运行并清除已过期的对象。要设置此项，您可以简单地在集合上使用INSERTWITHTL（）方法，允许使用定义的时间持续时间插入对象。 </p><p> In the example below we are inserting an object to the collection and setting the time-to-live to  5 seconds from the current time. After this time, the object will be automatically evicted from the collection and its space can be reclaimed.</p><p>在下面的示例中，我们将对象插入集合并从当前时间将时间设置为5秒。在此之后，将自动从集合中自动驱逐对象，并且可以回收其空间。</p><p> players. InsertWithTTL( map[ string] interface{}{	 &#34;name&#34;:  &#34;Merlin&#34;,	 &#34;class&#34;:  &#34;mage&#34;,	 &#34;age&#34;:  55,	 &#34;balance&#34;:  500,},  5  *  time. Second)  // The time-to-live of 5 seconds</p><p> 玩家。 InsertWithttl（映射[String]接口{} {＆＃34;姓名＆＃34 ;:＆＃34; merlin＆＃34 ;,＆＃34;类＆＃34 ;:＆＃34;法师和＃34 ;,＆＃34;年龄＆＃34 ;:55，＆＃34;余额＆＃34;：500，}，5 *时间。第二）//时间到5秒</p><p> On an interestig node, since  expire column which is automatically added to each collection is an actual normal column, you can query and even update it. In the example below we query and conditionally update the expiration column. The example loads a time, adds one hour and updates it, but in practice if you want to do it you should use  Add() method which can perform this atomically.</p><p> 在一个有趣的节点上，由于自动添加到每个集合的到期列是一个实际的普通列，您可以查询甚至更新它。在下面的示例中，我们查询并有条理地更新到期列。示例加载时间，添加一小时并更新它，但在练习中，如果要执行此操作，则应使用可以原子执行的Add（）方法。</p><p> players. Query( func( txn  *column. Txn)  error {	 return  txn. Range( &#34;expire&#34;,  func( v column. Cursor)  bool {		 oldExpire  :=  time. Unix( 0,  v. Int())  // Convert expiration to time.Time		 newExpire  :=  expireAt. Add( 1  *  time. Hour). UnixNano()  // Add some time		 v. Update( newExpire)		 return  true	})})</p><p> 玩家。查询（Func（TXN *列）错误{RETURN TXN。范围（＆＃34; expire＆＃34; func（v列）bool {oldexpire：= time。unix（0，v。int（）） //将到期到期.Time.Time NewExt：= ExpiReat。添加（1 *时间。小时）。Unixnano（）//添加一些时间v。更新（newext）return true}）}）</p><p>  Transactions allow for isolation between two concurrent operations. In fact, all of the batch queries must go through a transaction in this library. The  Query method requires a function which takes in a  column.Txn pointer which contains various helper methods that support querying. In the example below we&#39;re trying to iterate over all of the players and update their balance by setting it to  10.0. The  Query method automatically calls  txn.Commit() if the function returns without any error. On the flip side, if the provided function returns an error, the query will automatically call  txn.Rollback() so none of the changes will be applied.</p><p>  事务允许在两个并发操作之间隔离。实际上，所有批处理查询都必须通过此库中的事务进行。查询方法需要一个函数，该函数占据了列的列指针，该指针包含支持查询的各种辅助方法。在下面的例子中我们＆＃39;重新尝试迭代所有玩家并通过将其设置为10.0来更新它们的余额。如果函数返回，则查询方法会自动调用txn.commit（），而没有任何错误。在翻盖方面，如果提供的函数返回错误，则查询将自动调用txn.rollback（），因此将应用任何更改。</p><p> // Range over all of the players and update (successfully their balance) players. Query( func( txn  *column. Txn)  error {	 txn. Range( &#34;balance&#34;,  func( v column. Cursor)  bool {		 v. Update( 10.0)  // Update the &#34;balance&#34; to 10.0		 return  true	})	 // No error, txn.Commit() will be called	 return  nil})</p><p> //范围在所有玩家和更新（成功为平衡）玩家。查询（FUNC（TXN *列）错误{TXN。范围（＆＃34;余额＆＃34; func（v列。游标）bool {v。更新（10.0）//更新＆＃34;余额＆＃ 34;至10.0返回true}）//否错误，txn.commit（）将被称为return nil}）</p><p> Now, in this example, we try to update balance but a query callback returns an error, in which case none of the updates will be actually reflected in the underlying collection.</p><p> 现在，在此示例中，我们尝试更新余额，但查询回调返回错误，在这种情况下，均未在底层集合中反映出更新。 </p><p> // Range over all of the players and update (successfully their balance) players. Query( func( txn  *column. Txn)  error {	 txn. Range( &#34;balance&#34;,  func( v column. Cursor)  bool {		 v. Update( 10.0)  // Update the &#34;balance&#34; to 10.0		 return  true	})	 // Returns an error, txn.Rollback() will be called	 return  fmt. Errorf( &#34;bug&#34;) })</p><p>//范围在所有玩家和更新（成功为平衡）玩家。查询（FUNC（TXN *列）错误{TXN。范围（＆＃34;余额＆＃34; func（v列。游标）bool {v。更新（10.0）//更新＆＃34;余额＆＃ 34;至10.0返回true}）//返回错误，txn.rollback（）将被称为return fmt。errorf（＆＃34; bug＆＃34;）}）</p><p> You can (but probablty won&#39;t need to) call  Commit() or  Rollback() manually, as many times as required. This could be handy to do partial updates but calling them too often will have a performance hit on your application.</p><p> 您可以（但是probablety won＆＃39; t需要）手动调用comment（）或滚动（），根据需要多次。这可以方便地进行部分更新，但是调用它们通常会在您的应用程序上击中绩效。</p><p> // Range over all of the players and update (successfully their balance) players. Query( func( txn  *column. Txn)  error {	 txn. Range( &#34;balance&#34;,  func( v column. Cursor)  bool {		 v. Update( 10.0)  // Update the &#34;balance&#34; to 10.0		 return  true	})	 txn. Commit()  // Manually commit all of the changes	 return  nil  // This will call txn.Commit() again, but will be a no-op})</p><p> //范围在所有玩家和更新（成功为平衡）玩家。查询（FUNC（TXN *列）错误{TXN。范围（＆＃34;余额＆＃34; func（v列。游标）bool {v。更新（10.0）//更新＆＃34;余额＆＃ 34;至10.0返回true}）txn。commit（）//手动提交所有更改返回nil //这将再次调用txn.commit（），但将是一个no-op}）</p><p>  This library also supports streaming out all transaction commits consistently, as they happen. This allows you to implement your own change data capture (CDC) listeners, stream data into kafka or into a remote database for durability. In order to enable it, you can simply provide an implementation of a  commit.Writer interface during the creation of the collection.</p><p>  此库还支持将所有交易始终拨出的流式传输，因为它们发生。这允许您实现自己的更改数据捕获（CDC）侦听器，将数据流入Kafka或远程数据库以进行耐用。要启用它，您可以简单地在创建集合期间提供Commit.Writer接口的实现。</p><p> In the example below we take advantage of the  commit.Channel implementation of a  commit.Writer which simply publishes the commits into a go channel. Here we create a buffered channel and keep consuming the commits with a separate goroutine, allowing us to view transactions as they happen in the store.</p><p> 在下面的示例中，我们利用Commit.Whannel实现了Commit.Writer，其简单地将提交发布到Go频道中。在这里，我们创建了一个缓冲的通道并继续使用单独的Goroutine消耗提交，允许我们在商店中发生时查看事务。</p><p> // Create a new commit writer (simple channel) and a new collection writer  :=  make(commit. Channel,  1024) players  :=  NewCollection(column. Options{	 Writer:  writer,}) // Read the changes from the channel go  func(){	 for  commit  :=  writer{		 println( &#34;commit&#34;,  commit. Type. String())	}}() // ... insert, update or delete</p><p> //创建一个新的提交编写器（简单频道）和一个新的集合编写器：= make（提交。频道，1024）播放器：= newCollection（列。选项{writer：writer，}）//读取来自频道的更改func（）{for commit：= writer {println（＆＃34; commit＆＃34;提交。键入。string（））}}（）// ...插入，更新或删除</p><p> On a separate note, this change stream is guaranteed to be consistent and serialized. This means that you can also replicate those changes on another database and synchronize both. In fact, this library also provides  Replay() method on the collection that allows to do just that. In the example below we create two collections  primary and  replica and asychronously replicating all of the commits from the  primary to the  replica using the  Replay() method together with the change stream.</p><p> 在单独的备注上，保证此更改流是一致和序列化的。这意味着您还可以复制其他数据库上的这些更改并同步两者。实际上，此库还在集合上提供允许执行此操作的重播（）方法。在下面的示例中，我们使用重播（）方法与更改流一起创建两个集合主和副本和asucronouse将所有提交从主到副本复制到副本。 </p><p> // Create a p rimary collection writer  :=  make(commit. Channel,  1024) primary  :=  column. NewCollection(column. Options{	 Writer:  &amp; writer,}) primary. CreateColumnsOf( object) // Replica with the same schema replica  :=  column. NewCollection() replica. CreateColumnsOf( object) // Keep 2 collections in sync go  func() {	 for  change  :=  range  writer {		 replica. Replay( change)	}}()</p><p>//创建一个p rimary集合编写器：= make（提交。频道，1024）primary：=列。 newcollection（专栏。选项{writer：＆amp; writer，}）主要。具有相同架构副本的CreateColumnSof（Object）//副本：=列。 newcollection（）副本。 CreateColumnSof（对象）// in sync go func（）{for change：= Range Writer {副本。重播（更改）}}（）</p><p>  func  main(){	 // Create a new columnar collection	 players  :=  column. NewCollection()	 // index on humans	 players. CreateIndex( &#34;human&#34;,  &#34;race&#34;,  func( v  interface{})  bool {		 return  v  ==  &#34;human&#34;	})	 // index for mages	 players. CreateIndex( &#34;mage&#34;,  &#34;class&#34;,  func( v  interface{})  bool {		 return  v  ==  &#34;mage&#34;	})	 // index for old	 players. CreateIndex( &#34;old&#34;,  &#34;age&#34;,  func( v  interface{})  bool {		 return  v.( float64)  &gt;=  30	})	 // Load the items into the collection	 loaded  :=  loadFixture( &#34;players.json&#34;)	 players. CreateColumnsOf( loaded[ 0])	 for  _,  v  :=  range  loaded {		 players. Insert( v)	}	 // This performs a full scan on 3 different columns and compares them given the 	 // specified predicates. This is not indexed, but does a columnar scan which is	 // cache-friendly.	 players. Query( func( txn  *column. Txn)  error {		 println( txn. WithString( &#34;race&#34;,  func( v  string)  bool {			 return  v  ==  &#34;human&#34;		}). WithString( &#34;class&#34;,  func( v  string)  bool {			 return  v  ==  &#34;mage&#34;		}). WithFloat( &#34;age&#34;,  func( v  float64)  bool {			 return  v  &gt;=  30		}). Count())  // prints the count		 return  nil	})	 // This performs a cound, but instead of scanning through the entire dataset, it scans	 // over pre-built indexes and combines them using a logical AND operation. The result	 // will be the same as the query above but the performance of the query is 10x-100x	 // faster depending on the size of the underlying data.	 players. Query( func( txn  *column. Txn)  error {		 println( txn. With( &#34;human&#34;,  &#34;mage&#34;,  &#34;old&#34;). Count())  // prints the count		 return  nil	})	 // Same condition as above, but we also select the actual names of those 	 // players and iterate through them.	 players. Query( func( txn  *column. Txn)  error {		 txn. With( &#34;human&#34;,  &#34;mage&#34;,  &#34;old&#34;). Range( &#34;name&#34;,  func( v column. Cursor)  bool {			 println( v. String())  // prints the name			 return  true		})  // The column to select		 return  nil	})}</p><p>  func main（）{//创建一个新的柱状集合播放器：=列。 newcollection（）//人类玩家的索引。 createIndex（＆＃34;人和＃34 ;,＃34;赛跑＆＃34; func（v interface {}）bool {return v ==＆＃34; mages玩家的索引。 CreateIndex（＆＃34;法师＆＃34;＆＃34;类＆＃34; func（v接口{}）bool {return v ==＆＃34;旧玩家的索引。 createIndex（＆＃34;旧＆＃34;＆＃34;年龄＆＃34; func（v interface {}）bool {return v。（float64）＆gt; = 30}）//将项目加载到加载的集合中：= loadfixture（＆＃34; players.json＆＃34;）玩家。 CreateColumnSof（加载[0]）对于_，v：= loaded {播放器。插入（v）} //这在3个不同的列上执行全扫描，并将它们与指定的谓词进行比较。这不是索引，但是柱状扫描是//缓存友好的。玩家。查询（Func（TXN *列）错误{println（txn。withstring（＆＃34; func（v string）bool {return v ==＆＃34;人和＃34;}）。有了（＆＃34;类＆＃34;，func（v string）bool {return v ==＆＃34;法师＆＃34;}）。用float（＆＃34;年龄＆＃34; func（v float64）bool {返回v＆gt; = 30}）。count（））//打印计数返回nil}）//这执行了cound，而不是通过整个数据集扫描，而不是通过预构建的索引扫描//使用逻辑和操作。结果//将与上面的查询相同，但查询的性能取决于底层数据的大小，更快地为10x-100x //。玩家。查询（Func（TXN *列）错误{Println（TXN。与（＆＃34;人和＃34;＆＃34;法师＆＃34;＆＃34;旧＆＃34;）。count（）） //打印计数返回nil}）//相同的条件如上所述，但我们还选择//播放器的实际名称并迭代它们。玩家。查询（Func（TXN *列）错误{TXN。与（＆＃34;人和＃34;＆＃34;法师＆＃34;，＆＃34;旧＆＃34;）。范​​围（＆＃34;名称＆＃34;，func（v列。光标）bool {println（v.ring string（））//打印名称返回true}）//列选择return nil}）}</p><p>  The benchmarks below were ran on a collection of  500 items containing a dozen columns. Feel free to explore the benchmarks but I strongly recommend testing it on your actual dataset.</p><p>  下面的基准在包含十几个列的500项的集合上运行。随意探索基准，但我强烈建议在实际数据集上测试它。</p><p> cpu: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHzBenchmarkCollection/insert-8 5013795 239.9 ns/op 27 B/op 0 allocs/opBenchmarkCollection/fetch-8 23730796 50.63 ns/op 0 B/op 0 allocs/opBenchmarkCollection/scan-8 234990 4743 ns/op 0 B/op 0 allocs/opBenchmarkCollection/count-8 7965873 152.7 ns/op 0 B/op 0 allocs/opBenchmarkCollection/range-8 1512513 799.9 ns/op 0 B/op 0 allocs/opBenchmarkCollection/update-at-8 5409420 224.7 ns/op 0 B/op 0 allocs/opBenchmarkCollection/update-all-8 196626 6099 ns/op 0 B/op 0 allocs/opBenchmarkCollection/delete-at-8 2006052 594.9 ns/op 0 B/op 0 allocs/opBenchmarkCollection/delete-all-8 1889685 643.2 ns/op 0 B/op 0 allocs/op</p><p> CPU：英特尔（R）核心（TM）I7-9700K CPU @ 3.60GHzBenchmarkCollection / Insert-8 5013795 239.9 NS / OP 27 B / OP 0 Allocs / OpbenchmarkCollection / Fetch-8 23730796 50.63 NS / OP 0 B / OP 0 Allocs / OpbenchMarkCollection / Scan-8 234990 4743 NS / OP 0 B / OP 0 Allocs / OpbenchmarkColection / Count-8 7965873 152.7 NS / OP 0 B / OP 0 Allocs / OpbenchmarkCollection / Range-8 1512513 799.9 NS / OP 0 B / OP 0 Allocs / OpbenchMarkCollection / Update-AT-8 5409420 224.7 NS / OP 0 B / OP 0 Allocs / OpbenchmarkCollection / Update-All-8 196626 6099 NS / OP 0 B / OP 0 Allocs / OpbenchmarkCollection / Delete-8 2006052 594.9 NS / OP 0 B / OP 0 Allocs / OpbenchmarkCollection / Delete-All-8 1889685 643.2 NS / OP 0 B / OP 0 Allocs / Op</p><p> When testing for larger collections, I added a small example (see  examples folder) and ran it with  20 million rows inserted, each entry has  12 columns and 4 indexes that need to be calculated, and a few queries and scans around them.</p><p> 当测试更大的集合时，我添加了一个小示例（请参阅示例文件夹）并使用2000万行插入，每个条目都有12列，需要计算4个索引，以及一些查询和扫描周围的扫描。</p><p> running insert of 20000000 rows...-&gt; insert took 52.8255618srunning full scan of age &gt;= 30...-&gt; result = 10200000-&gt; full sca</p><p> 运行插入刀片为20000000行....  - ＆gt;插入率为52.8255618SRunning全扫描时代＆gt; = 30 ...  - ＆gt;结果= 10200000-＆gt;全部SCA.</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/kelindar/column">https://github.com/kelindar/column</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/柱状/">#柱状</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/方法/">#方法</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>